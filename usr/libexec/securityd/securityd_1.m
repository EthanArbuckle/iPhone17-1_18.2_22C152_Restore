void sub_100142B30(uint64_t a1)
{
  NSObject *v2;
  const char *v3;
  NSObject *v4;
  uint32_t v5;
  CFTypeRef v6;
  NSObject *v7;
  CFTypeRef cf;
  uint8_t buf[4];
  CFTypeRef v10;

  cf = 0;
  if (sub_100026908(a1, @"DROP INDEX IF EXISTS genpagrp; DROP INDEX IF EXISTS genpsync;", &cf)
    && sub_100026908(a1, @"DROP INDEX IF EXISTS inetagrp; DROP INDEX IF EXISTS inetsync;", &cf)
    && sub_100026908(a1, @"DROP INDEX IF EXISTS certagrp; DROP INDEX IF EXISTS certsync;", &cf)
    && sub_100026908(a1, @"DROP INDEX IF EXISTS keysagrp; DROP INDEX IF EXISTS keyssync;", &cf)
    && sub_100026908(a1, @"DROP INDEX IF EXISTS genpsync0;", &cf)
    && sub_100026908(a1, @"DROP INDEX IF EXISTS inetsync0;", &cf)
    && sub_100026908(a1, @"DROP INDEX IF EXISTS certsync0;", &cf)
    && sub_100026908(a1, @"DROP INDEX IF EXISTS keyssync0;", &cf)
    && sub_100026908(a1, @"DROP INDEX IF EXISTS genpmusr;", &cf)
    && sub_100026908(a1, @"DROP INDEX IF EXISTS inetmusr;", &cf)
    && sub_100026908(a1, @"DROP INDEX IF EXISTS certmusr;", &cf)
    && sub_100026908(a1, @"DROP INDEX IF EXISTS keysmusr;", &cf)
    && sub_100026908(a1, @"DROP INDEX IF EXISTS item_backupmusr;", &cf)
    && sub_100026908(a1, @"DROP INDEX IF EXISTS backup_keybagmusr;", &cf)
    && sub_100026908(a1, @"DROP INDEX IF EXISTS backup_keyarchivemusr;", &cf)
    && sub_100026908(a1, @"DROP INDEX IF EXISTS archived_key_backupmusr;", &cf)
    && sub_100026908(a1, @"CREATE INDEX IF NOT EXISTS agrp_musr_tomb_svce ON genp(agrp, musr, tomb, svce);",
                       &cf)
    && sub_100026908(a1, @"CREATE INDEX IF NOT EXISTS agrp_musr_tomb_srvr ON inet(agrp, musr, tomb, srvr);",
                       &cf)
    && sub_100026908(a1, @"CREATE INDEX IF NOT EXISTS agrp_musr_tomb_subj ON cert(agrp, musr, tomb, subj);",
                       &cf)
    && sub_100026908(a1, @"CREATE INDEX IF NOT EXISTS agrp_musr_tomb_atag ON keys(agrp, musr, tomb, atag);",
                       &cf)
    && sub_100026908(a1, @"CREATE INDEX IF NOT EXISTS synckeys_contextID_ckzone_keyclass_state ON synckeys(contextID, ckzone, keyclass, state);",
                       &cf)
    && sub_100026908(a1, @"CREATE INDEX IF NOT EXISTS incomingqueue_contextID_ckzone_UUID ON incomingqueue(contextID, ckzone, UUID);",
                       &cf)
    && sub_100026908(a1, @"CREATE INDEX IF NOT EXISTS incomingqueue_contextID_ckzone_state ON incomingqueue(contextID, ckzone, state);",
                       &cf)
    && sub_100026908(a1, @"CREATE INDEX IF NOT EXISTS incomingqueue_contextID_ckzone_parentkeyUUID ON incomingqueue(contextID, ckzone, parentKeyUUID);",
                       &cf)
    && sub_100026908(a1, @"CREATE INDEX IF NOT EXISTS outgoingqueue_contextID_ckzone_UUID ON outgoingqueue(contextID, ckzone, UUID);",
                       &cf)
    && sub_100026908(a1, @"CREATE INDEX IF NOT EXISTS outgoingqueue_contextID_ckzone_state ON outgoingqueue(contextID, ckzone, state);",
                       &cf)
    && sub_100026908(a1, @"CREATE INDEX IF NOT EXISTS outgoingqueue_contextID_ckzone_parentkeyUUID ON outgoingqueue(contextID, ckzone, parentKeyUUID);",
                       &cf)
    && sub_100026908(a1, @"CREATE INDEX IF NOT EXISTS ckmirror_contextID_ckzone_UUID ON ckmirror(contextID, ckzone, UUID);",
                       &cf)
    && sub_100026908(a1, @"CREATE INDEX IF NOT EXISTS ckmirror_contextID_ckzone_parentkeyUUID ON ckmirror(contextID, ckzone, parentKeyUUID);",
                       &cf)
    && sub_100026908(a1, @"DROP INDEX IF EXISTS tlksharecontextID;", &cf)
    && sub_100026908(a1, @"DROP INDEX IF EXISTS currentitemscontextID;", &cf)
    && sub_100026908(a1, @"DROP INDEX IF EXISTS ckdevicestatecontextID;", &cf)
    && sub_100026908(a1, @"DROP INDEX IF EXISTS outgoingqueuecontextID;", &cf)
    && sub_100026908(a1, @"DROP INDEX IF EXISTS incomingqueuecontextID;", &cf)
    && sub_100026908(a1, @"DROP INDEX IF EXISTS synckeyscontextID;", &cf)
    && sub_100026908(a1, @"DROP INDEX IF EXISTS ckmirrorcontextID;", &cf)
    && sub_100026908(a1, @"DROP INDEX IF EXISTS currentkeyscontextID;", &cf)
    && sub_100026908(a1, @"DROP INDEX IF EXISTS ckstatecontextID;", &cf))
  {
    v2 = sub_10000B070("upgr");
    if (!os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_42;
    }
    *(_WORD *)buf = 0;
    v3 = "processed custom indexes (now or in the past)";
    v4 = v2;
    v5 = 2;
    goto LABEL_41;
  }
  v7 = sub_10000B070("SecError");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    v10 = cf;
    v3 = "upgr: failed to process custom indexes: %@";
    v4 = v7;
    v5 = 12;
LABEL_41:
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v3, buf, v5);
  }
LABEL_42:
  v6 = cf;
  if (cf)
  {
    cf = 0;
    CFRelease(v6);
  }
}

uint64_t sub_100142FBC(uint64_t a1)
{
  if (qword_10035CF48 != -1) {
    dispatch_once(&qword_10035CF48, &stru_1002FAF50);
  }
  v2 = (const void *)qword_10035CF50;
  v3 = &off_1002FE3E8;
  int v4 = 1;
  v5 = off_100300578;
  do
  {
    if (*((unsigned char *)v3 + 8))
    {
      v6 = (CFDictionaryRef *)sub_10000C7F0((uint64_t)v3, v2, 0, *(void *)(a1 + 32), *(__CFString ***)(a1 + 40));
      if (v6)
      {
        v7 = (const void **)v6;
        v8 = *(CFTypeRef **)(a1 + 40);
        uint64_t v15 = *(void *)(a1 + 48);
        v16[0] = _NSConcreteStackBlock;
        v16[1] = 0x40000000;
        v16[2] = sub_1001434DC;
        v16[3] = &unk_100304940;
        v16[4] = v2;
        v16[5] = v8;
        v14[0] = _NSConcreteStackBlock;
        v14[1] = 0x40000000;
        v14[2] = sub_1001434F0;
        v14[3] = &unk_1003049A0;
        v4 &= sub_10011C750(v6, v15, v8, &stru_1003048A0, &stru_1003048E0, (uint64_t)&stru_100304920, (uint64_t)v16, (uint64_t)v14);
        sub_10000C2C4(v7, 0);
      }
      else
      {
        v9 = sub_10000B070("transcrypt");
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v10 = (uint64_t)**(v5 - 1);
          uint64_t v11 = **(void **)(a1 + 40);
          *(_DWORD *)buf = 138412546;
          uint64_t v18 = v10;
          __int16 v19 = 2112;
          uint64_t v20 = v11;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "could not create query for class %@: %@", buf, 0x16u);
        }
      }
    }
    v12 = *v5++;
    v3 = v12;
  }
  while (v12);
  return v4 & 1;
}

void sub_1001431F0(uint64_t a1)
{
  if (byte_10035CFD8 == 1)
  {
    v2 = +[OTManager manager];
    [v2 initializeOctagon];
    [v2 setupAnalytics];
  }
  if (sub_1000B14D4())
  {
    uint64_t v3 = *(void *)(a1 + 32);
    v5 = +[CKKSViewManager manager];
    [v5 setupAnalytics];
    sub_100026884(v3, &stru_1002F8EF0);
    v6 = [v5 completedSecCKKSInitialize];
    [v6 fulfill];

    if (qword_10035CE28 != -1) {
      dispatch_once(&qword_10035CE28, &stru_1002F8F10);
    }
  }
}

void sub_1001432F0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (objc_opt_class() && atomic_load_explicit(dword_10035CD18, memory_order_acquire) <= 1) {
    sub_100026884(v1, &stru_100305160);
  }
  if (objc_opt_class() && atomic_load_explicit(dword_10035CD18, memory_order_acquire) < 2)
  {
    v2 = KCSharingLogObject();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)int v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Initializing sync controller", v4, 2u);
    }

    uint64_t v3 = +[KCSharingSyncController sharedInstance];
    [v3 preflightWithCompletion:&stru_100305180];
  }
  else
  {
    uint64_t v3 = KCSharingLogObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Change tracking is disabled, KCSharing won't preflight", buf, 2u);
    }
  }
}

void sub_100143428(id a1)
{
  uint64_t v1 = sub_10000B070("escrowrequest");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "performing EscrowRequestServerInitialize", v5, 2u);
  }

  v2 = +[EscrowRequestServer server];
  uint64_t v3 = [v2 controller];
  int v4 = [v3 stateMachine];
  [v4 startOperation];
}

uint64_t sub_1001434DC(uint64_t a1, sqlite3_stmt *a2, uint64_t a3)
{
  return sub_10000E8B0(a2, a3, *(const __CFString **)(a1 + 32), *(CFTypeRef **)(a1 + 40));
}

void sub_1001434F0(uint64_t a1, __CFString ***a2)
{
  int v4 = sub_10000B070("transcrypt");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138477827;
    CFTypeRef v10 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "handling item: %{private}@", buf, 0xCu);
  }
  CFTypeRef cf = 0;
  if (!sub_10011A8B0((uint64_t)a2, -6, (__CFString **)&cf))
  {
    v5 = sub_10000B070("transcrypt");
    if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_10;
    }
    *(_DWORD *)buf = 138412290;
    CFTypeRef v10 = cf;
    v6 = "failed to set keybag, but continuing. Error: %@";
    goto LABEL_9;
  }
  if (sub_10011D784(a2, (CFStringRef **)a2, *(void *)(a1 + 32), &cf, (uint64_t)&stru_100304980)) {
    return;
  }
  v5 = sub_10000B070("transcrypt");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138412290;
    CFTypeRef v10 = cf;
    v6 = "failed to update item, but continuing. Error: %@";
LABEL_9:
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v6, buf, 0xCu);
  }
LABEL_10:
  CFTypeRef v7 = cf;
  if (cf)
  {
    CFTypeRef cf = 0;
    CFRelease(v7);
  }
}

BOOL sub_100143680(id a1, __CFString *a2, BOOL *a3)
{
  CFStringAppendFormat(a2, 0, @"musr = ?");
  return 1;
}

BOOL sub_1001436C4(id a1, const SecDbAttr *a2)
{
  return 0;
}

BOOL sub_1001436CC(id a1, const SecDbAttr *a2)
{
  return (LOBYTE(a2->var2) >> 1) & 1;
}

BOOL sub_1001436D8(id a1, const SecDbAttr *a2)
{
  return a2->var1 == 8;
}

void sub_1001436E8(uint64_t a1, const void *a2, int a3)
{
  value = (void *)0xAAAAAAAAAAAAAAAALL;
  if (CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(a1 + 32), a2, (const void **)&value))
  {
    uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8 * a3 + 8);
    uint64_t v7 = *(void *)(*(void *)(a1 + 48) + 8 * (int)value + 8);
    if (CFEqual(*(CFTypeRef *)v6, *(CFTypeRef *)v7) && *(unsigned __int8 *)(v6 + 8) == *(unsigned __int8 *)(v7 + 8))
    {
      uint64_t v8 = *(void *)(v7 + 16);
      uint64_t v9 = *(void *)(v6 + 16);
      if (v9) {
        BOOL v10 = v8 == 0;
      }
      else {
        BOOL v10 = 1;
      }
      if (v10)
      {
LABEL_9:
        if (!(v9 | v8)) {
          return;
        }
      }
      else
      {
        uint64_t v11 = (uint64_t *)(v7 + 24);
        v12 = (uint64_t *)(v6 + 24);
        while (CFEqual(*(CFTypeRef *)v9, *(CFTypeRef *)v8)
             && *(_DWORD *)(v9 + 8) == *(_DWORD *)(v8 + 8)
             && *(void *)(v9 + 16) == *(void *)(v8 + 16)
             && *(void *)(v9 + 24) == *(void *)(v8 + 24)
             && *(void *)(v9 + 32) == *(void *)(v8 + 32))
        {
          uint64_t v13 = *v11++;
          uint64_t v8 = v13;
          uint64_t v14 = *v12++;
          uint64_t v9 = v14;
          if (!v14 || !v8) {
            goto LABEL_9;
          }
        }
      }
    }
    CFSetAddValue(*(CFMutableSetRef *)(a1 + 56), a2);
  }
}

void sub_100143814(uint64_t a1, const void *a2)
{
  int v4 = *(void **)(*(void *)(a1 + 40) + 8 * (int)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), a2) + 8);
  Value = (const void *)(int)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 48), a2);
  CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 64), 0, @"ALTER TABLE %@ RENAME TO %@_old;",
    **(void **)(*(void *)(a1 + 56) + 8 * (void)Value + 8),
    *v4);
  uint64_t v6 = *(__CFArray **)(a1 + 72);

  CFArrayAppendValue(v6, Value);
}

void sub_1001438B0(uint64_t a1, const void *a2, int a3)
{
  if (!CFSetContainsValue(*(CFSetRef *)(a1 + 32), a2) && !CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 40), a2)) {
    CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 56), 0, @"DROP TABLE IF EXISTS %@;",
  }
      **(void **)(*(void *)(a1 + 48) + 8 * a3 + 8));
}

void sub_10014392C(uint64_t a1, const void *a2, int a3)
{
  if (!CFSetContainsValue(*(CFSetRef *)(a1 + 32), a2) && !CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 40), a2))
  {
    CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 56), 0, @"DROP TABLE IF EXISTS %@;",
      **(void **)(*(void *)(a1 + 48) + 8 * a3 + 8));
    uint64_t v6 = *(__CFArray **)(a1 + 64);
    CFArrayAppendValue(v6, (const void *)a3);
  }
}

void sub_1001439D8(uint64_t a1, const void *a2)
{
}

void sub_1001439E0(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  CFTypeRef cf = 0;
  ++*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  *(void *)(a2 + 16) = *(void *)(a1 + 48);
  uint64_t v6 = sub_100119CB8((void *)a2, kSecAttrAccessible);
  uint64_t v7 = v6;
  if (v6) {
    BOOL v8 = kSecAttrAccessibleAlwaysPrivate == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8)
  {
    if (v6 == (const void *)kSecAttrAccessibleAlwaysPrivate) {
      goto LABEL_17;
    }
  }
  else if (CFEqual(v6, kSecAttrAccessibleAlwaysPrivate))
  {
    goto LABEL_17;
  }
  if (v7) {
    BOOL v10 = kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (!v10)
  {
    if (CFEqual(v7, kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate)) {
      goto LABEL_17;
    }
LABEL_15:
    *(_DWORD *)(a2 + 40) = 5;
    goto LABEL_25;
  }
  if (v7 != (const void *)kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate) {
    goto LABEL_15;
  }
LABEL_17:
  BOOL v12 = sub_100118DFC(a2, 1, (__CFString **)&cf);
  uint64_t v13 = *(void *)(*(void *)(a1 + 40) + 8);
  if (*(unsigned char *)(v13 + 24)) {
    BOOL v14 = v12;
  }
  else {
    BOOL v14 = 0;
  }
  *(unsigned char *)(v13 + 24) = v14;
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
    goto LABEL_38;
  }
  uint64_t v15 = (void *)sub_100118974(*(void **)(a2 + 16), 7, *(__CFString ***)(a1 + 56));
  char v16 = sub_1001196B4(a2, v15, kCFNull, *(__CFString ***)(a1 + 56));
  uint64_t v17 = *(void *)(*(void *)(a1 + 40) + 8);
  char v18 = *(unsigned char *)(v17 + 24) ? v16 : 0;
  *(unsigned char *)(v17 + 24) = v18;
  if ((v18 & 1) == 0) {
    goto LABEL_38;
  }
LABEL_25:
  CFStringRef v19 = (const __CFString *)sub_100119CB8((void *)a2, kSecAttrAccessGroup);
  if (v19) {
    BOOL v20 = kSecAttrAccessGroupToken == 0;
  }
  else {
    BOOL v20 = 1;
  }
  if (v20)
  {
    if (v19 != kSecAttrAccessGroupToken) {
      goto LABEL_34;
    }
  }
  else if (!CFEqual(v19, kSecAttrAccessGroupToken))
  {
LABEL_34:
    uint64_t v22 = *(void *)(a1 + 64);
    *(void *)buf = _NSConcreteStackBlock;
    *(void *)&buf[8] = 0x40000000;
    *(void *)&uint8_t buf[16] = sub_10011DDE8;
    v35 = &unk_1002FA9B0;
    uint64_t v36 = a2;
    __int16 v37 = 0;
    if ((sub_10011C214(a2, v22, (__CFString **)&cf, (uint64_t)buf) & 1) == 0)
    {
      v23 = sub_10000B070("SecError");
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138478083;
        *(void *)&uint8_t buf[4] = a2;
        *(_WORD *)&buf[12] = 2112;
        *(void *)&buf[14] = cf;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "item: %{private}@ insert during upgrade: %@", buf, 0x16u);
      }
      *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
    }
    goto LABEL_38;
  }
  if (sub_100119CB8((void *)a2, kSecAttrTokenID)) {
    goto LABEL_34;
  }
  v26 = sub_10000B070("upgr");
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138477827;
    *(void *)&uint8_t buf[4] = a2;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "dropping item during schema upgrade due to agrp=com.apple.token: %{private}@", buf, 0xCu);
  }
LABEL_38:
  if (!cf) {
    goto LABEL_67;
  }
  int OSStatus = SecErrorGetOSStatus();
  if (OSStatus <= -25331)
  {
    if (OSStatus != -536870186 && OSStatus != -536870184)
    {
      int v25 = -26275;
      goto LABEL_50;
    }
LABEL_52:
    v29 = sub_10000B070("upgr");
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      *(void *)&uint8_t buf[4] = cf;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Bailing in phase 1 because AKS is unavailable: %@", buf, 0xCu);
    }
    goto LABEL_54;
  }
  if (OSStatus > -25300)
  {
    if (OSStatus != -25291)
    {
      int v25 = -25299;
LABEL_50:
      if (OSStatus == v25) {
        goto LABEL_51;
      }
LABEL_54:
      CFTypeRef v30 = cf;
      if (cf)
      {
        CFRetain(cf);
        v31 = *(void **)(a1 + 56);
        if (v31 && !*v31) {
          void *v31 = v30;
        }
        else {
          CFRelease(v30);
        }
      }
      uint64_t v27 = *(void *)(*(void *)(a1 + 40) + 8);
      if (v30) {
        BOOL v32 = 1;
      }
      else {
        BOOL v32 = *(unsigned char *)(v27 + 24) == 0;
      }
      char v28 = !v32;
      goto LABEL_65;
    }
    goto LABEL_52;
  }
  if (OSStatus != -25330)
  {
    int v25 = -25308;
    goto LABEL_50;
  }
LABEL_51:
  uint64_t v27 = *(void *)(*(void *)(a1 + 40) + 8);
  char v28 = 1;
LABEL_65:
  *(unsigned char *)(v27 + 24) = v28;
  if (cf) {
    CFRelease(cf);
  }
LABEL_67:
  *a3 = *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) ^ 1;
}

void sub_100143E28(uint64_t a1, const void *a2)
{
  signed int Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), a2);
  CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 48), 0, @"DROP TABLE %@_old;",
    **(void **)(*(void *)(a1 + 40) + 8 * Value + 8));
}

uint64_t sub_100143E80(uint64_t a1, __CFString *a2, unsigned char *a3)
{
  return 1;
}

uint64_t sub_100143EDC(uint64_t a1, sqlite3_stmt *a2, uint64_t a3)
{
  int v3 = a3;
  uint64_t result = sub_10000E8B0(a2, a3, kSecAttrAccessibleAlwaysPrivate, *(CFTypeRef **)(a1 + 32));
  if (result)
  {
    CFStringRef v7 = (const __CFString *)kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate;
    BOOL v8 = *(CFTypeRef **)(a1 + 32);
    return sub_10000E8B0(a2, (v3 + 1), v7, v8);
  }
  return result;
}

void sub_100143F64(uint64_t a1, uint64_t a2, BOOL *a3)
{
  CFErrorRef err = 0;
  ++*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if (sub_100118DFC(a2, 1, (__CFString **)&err))
  {
    uint64_t v6 = (void *)sub_100118974(*(void **)(a2 + 16), 7, *(__CFString ***)(a1 + 48));
    int v7 = sub_1001196B4(a2, v6, kCFNull, (__CFString **)&err);
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v7;
    if (!v7) {
      goto LABEL_50;
    }
    CFStringRef v8 = (const __CFString *)sub_100119CB8((void *)a2, kSecAttrAccessGroup);
    if (v8) {
      BOOL v9 = kSecAttrAccessGroupToken == 0;
    }
    else {
      BOOL v9 = 1;
    }
    if (v9)
    {
      if (v8 != kSecAttrAccessGroupToken) {
        goto LABEL_12;
      }
    }
    else if (!CFEqual(v8, kSecAttrAccessGroupToken))
    {
      goto LABEL_12;
    }
    if (!sub_100119CB8((void *)a2, kSecAttrTokenID))
    {
      BOOL v20 = sub_10000B070("upgr");
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138477827;
        *(void *)&uint8_t buf[4] = a2;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "dropping item during item upgrade due to agrp=com.apple.token: %{private}@", buf, 0xCu);
      }
      off_10035CA60();
      unsigned __int8 v12 = sub_10011ED78((CFStringRef **)a2, *v21, kCFBooleanFalse, 0, (CFTypeRef *)&err);
      goto LABEL_13;
    }
LABEL_12:
    off_10035CA60();
    unsigned __int8 v12 = sub_10011E680((void **)a2, (void **)a2, *v11, 0, *(unsigned __int8 *)(*(void *)(a1 + 56) + 154), (__CFString **)&err);
LABEL_13:
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v12;
  }
  if (!err) {
    goto LABEL_52;
  }
  CFIndex Code = CFErrorGetCode(err);
  if (Code <= -25309)
  {
    if (Code <= -26276)
    {
      if (Code != -536870186 && Code != -536870184) {
        goto LABEL_36;
      }
LABEL_34:
      **(unsigned char **)(a1 + 64) = 1;
      uint64_t v17 = sub_10000B070("upgr");
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        *(void *)&uint8_t buf[4] = err;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Bailing in phase 2 because AKS is unavailable: %@", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (Code == -26275)
    {
      *(void *)buf = 0;
      off_10035CA60();
      sub_10011ED78((CFStringRef **)a2, *v23, kCFBooleanFalse, 0, (CFTypeRef *)buf);
      v24 = *(const void **)buf;
      if (*(void *)buf)
      {
        *(void *)buf = 0;
        CFRelease(v24);
      }
    }
    else if (Code != -25330)
    {
      goto LABEL_36;
    }
    goto LABEL_46;
  }
  if (Code > -25292)
  {
    if (Code == -25291) {
      goto LABEL_34;
    }
    if (Code == 19)
    {
      CFErrorDomain Domain = CFErrorGetDomain(err);
      if (!CFEqual(@"com.apple.utilities.sqlite3", Domain))
      {
        v26 = sub_10000B070("SecError");
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 138478083;
          *(void *)&uint8_t buf[4] = a2;
          __int16 v29 = 2112;
          CFErrorRef v30 = err;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Received SQLITE_CONSTRAINT with wrong error domain. Huh? Item: %{private}@, error: %@", buf, 0x16u);
        }
        goto LABEL_50;
      }
      BOOL v14 = sub_10000B070("upgr");
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_46;
      }
      *(_DWORD *)buf = 138477827;
      *(void *)&uint8_t buf[4] = a2;
      uint64_t v15 = "Received SQLITE_CONSTRAINT -- ignoring: %{private}@";
      goto LABEL_33;
    }
LABEL_36:
    CFErrorRef v18 = err;
    if (err)
    {
      CFRetain(err);
      CFStringRef v19 = *(CFErrorRef **)(a1 + 48);
      if (v19 && !*v19) {
        *CFStringRef v19 = v18;
      }
      else {
        CFRelease(v18);
      }
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v18 == 0;
    goto LABEL_50;
  }
  if (Code != -25308)
  {
    if (Code == -25299)
    {
      BOOL v14 = sub_10000B070("upgr");
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
LABEL_46:
        uint64_t v22 = *(void *)(*(void *)(a1 + 40) + 8);
        goto LABEL_47;
      }
      *(_DWORD *)buf = 138477827;
      *(void *)&uint8_t buf[4] = a2;
      uint64_t v15 = "Ignoring duplicate item: %{private}@";
LABEL_33:
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v15, buf, 0xCu);
      goto LABEL_46;
    }
    goto LABEL_36;
  }
  LKAReportKeychainUpgradeOutcomeWithError();
  **(unsigned char **)(a1 + 64) = 1;
  *a3 = 1;
  uint64_t v22 = *(void *)(*(void *)(a1 + 40) + 8);
LABEL_47:
  *(unsigned char *)(v22 + 24) = 1;
LABEL_50:
  if (err) {
    CFRelease(err);
  }
LABEL_52:
  BOOL v25 = *a3 || *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) == 0;
  *a3 = v25;
}

BOOL sub_100144454(id a1, const SecDbAttr *a2)
{
  return 0;
}

BOOL sub_10014445C(id a1, const SecDbAttr *a2)
{
  return 0;
}

BOOL sub_100144464(id a1, const SecDbAttr *a2)
{
  return (LOBYTE(a2->var2) >> 1) & 1;
}

uint64_t sub_100144470(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

BOOL sub_10014448C(uint64_t a1, uint64_t a2)
{
  v2 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_1001445BC;
  v4[3] = &unk_100303E48;
  v4[4] = *(void *)(a1 + 40);
  v4[5] = a2;
  long long v5 = *(_OWORD *)(a1 + 48);
  return sub_1001381F8(a2, 2, v2, (uint64_t)v4);
}

uint64_t sub_100144518(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = result;
  return result;
}

uint64_t sub_100144554(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = result;
  return result;
}

void sub_100144590(id a1)
{
  qword_10035D100 = (uint64_t)dispatch_queue_create("sec_kc_dbhandle", 0);
}

uint64_t sub_1001445BC(void *a1)
{
  CFTypeRef cf = 0;
  uint64_t v1 = a1[5];
  uint64_t v2 = a1[6];
  v33.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&v33.tv_usec = 0xAAAAAAAAAAAAAAAALL;
  gettimeofday(&v33, 0);
  int v3 = off_100300570;
  int v4 = &off_1002FE3E8;
  do
  {
    if (*((unsigned char *)v4 + 8))
    {
      CStringPtr = CFStringGetCStringPtr(*v4, 0x8000100u);
      uint64_t v6 = sqlite3_mprintf("%q", CStringPtr);
      if (v6)
      {
        int v7 = v6;
        CFStringRef v8 = CFStringCreateWithCString(kCFAllocatorDefault, v6, 0x8000100u);
        sqlite3_free(v7);
        CFStringRef v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"SELECT * FROM %@ WHERE persistref IS ''", v8);
        uint64_t v29 = 0;
        CFErrorRef v30 = (CFTypeRef *)&v29;
        uint64_t v31 = 0x2000000000;
        uint64_t v32 = 0;
        uint64_t v25 = 0;
        v26 = &v25;
        uint64_t v27 = 0x2000000000;
        CFMutableArrayRef Mutable = (CFMutableArrayRef)0xAAAAAAAAAAAAAAAALL;
        CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        v24[0] = _NSConcreteStackBlock;
        v24[1] = 0x40000000;
        v24[2] = sub_10013FA54;
        v24[3] = &unk_100303CC8;
        v24[4] = &v29;
        v24[5] = &v25;
        v24[6] = v1;
        v24[7] = v2;
        sub_10002742C(v1, (uint64_t)v9, v30 + 3, (uint64_t)v24);
        if (v9) {
          CFRelease(v9);
        }
        v22[0] = 0;
        v22[1] = v22;
        v22[2] = 0x2000000000;
        char v23 = 0;
        CFArrayRef v10 = (const __CFArray *)v26[3];
        *(void *)&long long context = _NSConcreteStackBlock;
        *((void *)&context + 1) = 0x40000000;
        v35 = sub_10013FADC;
        uint64_t v36 = &unk_100303DB8;
        __int16 v37 = v22;
        v38 = v3;
        uint64_t v39 = v1;
        p_CFTypeRef cf = &cf;
        uint64_t v41 = v2;
        v42.length = CFArrayGetCount(v10);
        v42.location = 0;
        CFArrayApplyFunction(v10, v42, (CFArrayApplierFunction)sub_10013FC68, &context);
        if (v8) {
          CFRelease(v8);
        }
        uint64_t v11 = (const void *)v26[3];
        if (v11)
        {
          v26[3] = 0;
          CFRelease(v11);
        }
        CFTypeRef v12 = v30[3];
        if (v12)
        {
          v30[3] = 0;
          CFRelease(v12);
        }
        _Block_object_dispose(v22, 8);
        _Block_object_dispose(&v25, 8);
        _Block_object_dispose(&v29, 8);
      }
    }
    uint64_t v13 = v3[1];
    ++v3;
    int v4 = v13;
  }
  while (v13);
  sub_10013F98C((uint64_t)&v33);
  SecCoreAnalyticsSendValue();
  SecCoreAnalyticsSendValue();
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = 1;
  if (cf)
  {
    BOOL v14 = sub_10000B070("SecError");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(context) = 138412290;
      *(void *)((char *)&context + 4) = cf;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "upgr-phase3: failed to perform persistent ref upgrade for keychain item(s): %@", (uint8_t *)&context, 0xCu);
    }
    CFTypeRef v15 = cf;
    if (cf)
    {
      CFRetain(cf);
      char v16 = (void *)a1[7];
      if (v16 && !*v16) {
        *char v16 = v15;
      }
      else {
        CFRelease(v15);
      }
      CFTypeRef v18 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        CFRelease(v18);
      }
    }
  }
  else
  {
    uint64_t v17 = sub_10000B070("upgr-phase3");
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(context) = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "finished upgrading keychain items' persistent refs", (uint8_t *)&context, 2u);
    }
  }
  return 1;
}

void sub_1001449B8(id a1)
{
  uint64_t v1 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  qword_10035D110 = (uint64_t)dispatch_queue_create("sec_async_db", v1);
}

uint64_t sub_1001449F0(uint64_t a1, uint64_t a2, const void *a3, const void *a4, const __CFArray *a5, int a6)
{
  LODWORD(v6) = a6;
  CFArrayRef theArray = 0;
  v30.length = CFArrayGetCount(a5);
  v30.location = 0;
  if (CFArrayContainsValue(a5, v30, a4)) {
    return 1;
  }
  keys[0] = (void *)kSecClass;
  keys[1] = (void *)kSecReturnRef;
  keys[2] = (void *)kSecAttrSubject;
  values[0] = (void *)kSecClassCertificate;
  values[1] = kCFBooleanTrue;
  values[2] = (void *)a4;
  CFDictionaryRef v14 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)keys, (const void **)values, 3, 0, 0);
  CFDictionaryRef v12 = v14;
  if (!v14) {
    return (uint64_t)v12;
  }
  v24 = 0;
  CFTypeRef v15 = (const void **)sub_10000C3CC(v14, a3, -1, 0, &v24);
  CFRelease(v12);
  if (v15)
  {
    sub_10000DE00(a1, v15, &theArray, a2, &v24);
    sub_10000C2C4(v15, (CFErrorRef *)&v24);
  }
  if (v24)
  {
    char v16 = sub_10000B070("SecError");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v27 = v24;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "items matching issuer parent: %@", buf, 0xCu);
    }
    CFArrayRef v17 = (CFArrayRef)v24;
    if (!v24) {
      return 0;
    }
    CFDictionaryRef v12 = 0;
    v24 = 0;
LABEL_24:
    CFRelease(v17);
    return (uint64_t)v12;
  }
  CFIndex Count = CFArrayGetCount(theArray);
  if (Count < 1)
  {
    CFDictionaryRef v12 = 0;
  }
  else
  {
    CFIndex v19 = Count;
    uint64_t v20 = 1;
    do
    {
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(theArray, v20 - 1);
      signed int Value = CFDictionaryGetValue(ValueAtIndex, kSecAttrIssuer);
      if (CFEqual(Value, a4) || (v23 = __OFSUB__(v6, 1), uint64_t v6 = (v6 - 1), ((int)v6 < 0) ^ v23)) {
        CFDictionaryRef v12 = 0;
      }
      else {
        CFDictionaryRef v12 = (const __CFDictionary *)sub_1001449F0(a1, a2, a3, Value, a5, v6);
      }
      if (v20 >= v19) {
        break;
      }
      ++v20;
    }
    while (!v12);
  }
  CFArrayRef v17 = theArray;
  if (theArray) {
    goto LABEL_24;
  }
  return (uint64_t)v12;
}

SecCertificateRef sub_100144C84(__CFString **a1, CFDictionaryRef theDict)
{
  if (a1 == &off_1002FFC58)
  {
    CFDataRef Value = (const __CFData *)CFDictionaryGetValue(theDict, @"certdata");
    CFStringRef v5 = @"certtkid";
  }
  else
  {
    if ((__CFString **)sub_10000C75C(@"cert", &qword_10035D030, (uint64_t)&unk_10035D028) != a1) {
      return 0;
    }
    CFDataRef Value = (const __CFData *)CFDictionaryGetValue(theDict, kSecValueData);
    CFStringRef v5 = kSecAttrTokenID;
  }
  uint64_t v6 = CFDictionaryGetValue(theDict, v5);
  if (!Value) {
    return 0;
  }
  if (v6)
  {
    CFDictionaryRef v7 = (const __CFDictionary *)SecTokenItemValueCopy();
    if (v7)
    {
      CFDictionaryRef v8 = v7;
      CFDataRef v9 = (const __CFData *)CFDictionaryGetValue(v7, @"data");
      if (v9)
      {
        SecCertificateRef v3 = SecCertificateCreateWithData(kCFAllocatorDefault, v9);
      }
      else
      {
        CFDictionaryRef v12 = sub_10000B070("SecError");
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "token item doesn't contain token value data", buf, 2u);
        }
        SecCertificateRef v3 = 0;
      }
      CFRelease(v8);
      return v3;
    }
    uint64_t v11 = sub_10000B070("SecError");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 138412290;
      uint64_t v14 = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "function SecTokenItemValueCopy failed with: %@", buf, 0xCu);
    }
    return 0;
  }

  return SecCertificateCreateWithData(kCFAllocatorDefault, Value);
}

void sub_100144EB0(uint64_t a1)
{
  v5[0] = 0;
  v5[1] = v5;
  v5[2] = 0x2000000000;
  uint64_t v6 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_100144F74;
  v4[3] = &unk_100303F90;
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 48);
  v4[5] = *(void *)(a1 + 40);
  void v4[6] = v3;
  v4[4] = v5;
  sub_10000CBA4(1, 1, v2, (uint64_t)&v6, (uint64_t)v4);
  CFRelease(*(CFTypeRef *)(a1 + 40));
  CFRelease(*(CFTypeRef *)(a1 + 32));
  _Block_object_dispose(v5, 8);
}

uint64_t sub_100144F74(void *a1, uint64_t a2)
{
  CFStringRef v4 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"DELETE FROM %@ WHERE rowid=%lli", a1[5], a1[6]);
  uint64_t v23 = 0;
  v24 = &v23;
  uint64_t v25 = 0x2000000000;
  char v26 = 1;
  uint64_t v5 = a1[4];
  uint64_t v6 = (CFTypeRef *)(*(void *)(v5 + 8) + 24);
  v22[0] = _NSConcreteStackBlock;
  v22[1] = 0x40000000;
  v22[2] = sub_1001451B8;
  void v22[3] = &unk_100303F68;
  v22[5] = v5;
  v22[6] = a2;
  v22[4] = &v23;
  int v7 = sub_10002742C(a2, (uint64_t)v4, v6, (uint64_t)v22);
  if (*((unsigned char *)v24 + 24)) {
    int v8 = v7;
  }
  else {
    int v8 = 0;
  }
  *((unsigned char *)v24 + 24) = v8;
  if (v8 != 1 || *(void *)(*(void *)(a1[4] + 8) + 24))
  {
    CFDataRef v9 = sub_10000B070("SecError");
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_9;
    }
    uint64_t v11 = a1[5];
    uint64_t v10 = a1[6];
    uint64_t v12 = *(void *)(*(void *)(a1[4] + 8) + 24);
    *(_DWORD *)buf = 138412802;
    uint64_t v28 = v11;
    __int16 v29 = 2048;
    uint64_t v30 = v10;
    __int16 v31 = 2112;
    uint64_t v32 = v12;
    uint64_t v13 = "Failed to delete corrupt item, %@ row %lli: %@";
    uint64_t v14 = v9;
    uint32_t v15 = 32;
    goto LABEL_8;
  }
  CFIndex v19 = sub_10000B070("item");
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v21 = a1[5];
    uint64_t v20 = a1[6];
    *(_DWORD *)buf = 134218242;
    uint64_t v28 = v20;
    __int16 v29 = 2112;
    uint64_t v30 = v21;
    uint64_t v13 = "Deleted corrupt rowid %lli from table %@";
    uint64_t v14 = v19;
    uint32_t v15 = 22;
LABEL_8:
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v13, buf, v15);
  }
LABEL_9:
  uint64_t v16 = *(void *)(a1[4] + 8);
  CFArrayRef v17 = *(const void **)(v16 + 24);
  if (v17)
  {
    *(void *)(v16 + 24) = 0;
    CFRelease(v17);
  }
  if (v4) {
    CFRelease(v4);
  }
  _Block_object_dispose(&v23, 8);
  return 1;
}

uint64_t sub_1001451B8(void *a1, sqlite3_stmt *a2)
{
  uint64_t result = sub_1000275B0(a1[6], a2, (CFTypeRef *)(*(void *)(a1[5] + 8) + 24), 0);
  uint64_t v4 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v4 + 24)) {
    char v5 = result;
  }
  else {
    char v5 = 0;
  }
  *(unsigned char *)(v4 + 24) = v5;
  return result;
}

BOOL sub_100145208(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 48;
  int v5 = CFEqual(*(CFTypeRef *)(a1 + 48), kSecClassIdentity);
  uint64_t v6 = &kSecClassCertificate;
  if (!v5) {
    uint64_t v6 = (const CFStringRef *)v4;
  }
  CFStringRef v7 = CFStringCreateWithFormat(0, 0, @"SELECT agrp FROM %@ WHERE persistref = ?", *v6);
  v13[0] = _NSConcreteStackBlock;
  uint64_t v8 = *(void *)(v4 + 8);
  long long v9 = *(_OWORD *)(v4 - 16);
  uint64_t v10 = (CFTypeRef *)(*(void *)(*(void *)(v4 - 16) + 8) + 24);
  v13[1] = 0x40000000;
  v13[2] = sub_1001456A0;
  v13[3] = &unk_100304AD0;
  uint64_t v15 = v8;
  uint64_t v16 = a2;
  long long v14 = v9;
  int v11 = sub_100010DE0(a2, v7, v10, (uint64_t)v13);
  if (v7) {
    CFRelease(v7);
  }
  return v11 && *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) != 0;
}

BOOL sub_100145324(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = a1 + 48;
  int v5 = CFEqual(*(CFTypeRef *)(a1 + 48), kSecClassIdentity);
  uint64_t v6 = &kSecClassCertificate;
  if (!v5) {
    uint64_t v6 = (const CFStringRef *)v4;
  }
  CFStringRef v7 = CFStringCreateWithFormat(0, 0, @"SELECT agrp FROM %@ WHERE rowid == %u", *v6, *(void *)(v4 + 8));
  v12[0] = _NSConcreteStackBlock;
  long long v8 = *(_OWORD *)(v4 - 16);
  uint64_t v9 = *(void *)(*(void *)(v4 - 16) + 8);
  v12[1] = 0x40000000;
  v12[2] = sub_100145584;
  v12[3] = &unk_100304B48;
  uint64_t v14 = a2;
  long long v13 = v8;
  int v10 = sub_100010DE0(a2, v7, (CFTypeRef *)(v9 + 24), (uint64_t)v12);
  if (v7) {
    CFRelease(v7);
  }
  return v10 && *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) != 0;
}

uint64_t sub_100145440(uint64_t a1)
{
  if (!a1 || !*(void *)(a1 + 48) || (CFArrayRef v2 = *(const __CFArray **)(a1 + 8)) == 0)
  {
    uint64_t v6 = sub_10000B070("SecError");
    BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v7) {
      return result;
    }
    *(_WORD *)uint64_t v12 = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "item: no app clip client or attributes not set, cannot verify restrictions", v12, 2u);
    return 0;
  }
  CFIndex Count = CFArrayGetCount(v2);
  if (Count != 2)
  {
    if (Count == 1)
    {
      uint64_t v4 = *(const void **)(a1 + 48);
      CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), 0);
      if (v4 && ValueAtIndex) {
        return CFEqual(v4, ValueAtIndex) != 0;
      }
      if (v4 == ValueAtIndex) {
        return 1;
      }
    }
    return 0;
  }
  v13.location = 0;
  v13.length = 2;
  FirstIndexOfCFDataRef Value = CFArrayGetFirstIndexOfValue(*(CFArrayRef *)(a1 + 8), v13, kSecAttrAccessGroupToken);
  if (FirstIndexOfValue == -1) {
    return 0;
  }
  int v10 = *(const void **)(a1 + 48);
  int v11 = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 8), FirstIndexOfValue == 0);
  if (v10 && v11) {
    return CFEqual(v10, v11) != 0;
  }
  else {
    return v10 == v11;
  }
}

uint64_t sub_100145584(void *a1, sqlite3_stmt *a2)
{
  uint64_t v3 = a1[6];
  uint64_t v4 = (CFTypeRef *)(*(void *)(a1[4] + 8) + 24);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = sub_100145628;
  v6[3] = &unk_100304B20;
  v6[4] = a1[5];
  v6[5] = a2;
  uint64_t result = sub_100010FD8(v3, a2, v4, (uint64_t)v6);
  if (result) {
    return *(void *)(*(void *)(a1[5] + 8) + 24) != 0;
  }
  return result;
}

BOOL sub_100145628(uint64_t a1)
{
  CFArrayRef v2 = (const UInt8 *)sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 40), 0);
  int v3 = sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 40), 0);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CFStringCreateWithBytes(0, v2, v3, 0x8000100u, 0);
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

BOOL sub_1001456A0(uint64_t a1, sqlite3_stmt *a2)
{
  BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 48));
  CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 48));
  BOOL v6 = sub_10000EE7C(a2, 1, BytePtr, Length, (CFTypeRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
  uint64_t v7 = *(void *)(a1 + 56);
  long long v8 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  v11[2] = sub_10014579C;
  v11[3] = &unk_100304AA8;
  v11[4] = *(void *)(a1 + 40);
  v11[5] = a2;
  if (sub_100010FD8(v7, a2, v8, (uint64_t)v11)) {
    BOOL v9 = !v6;
  }
  else {
    BOOL v9 = 1;
  }
  return !v9 && *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) != 0;
}

BOOL sub_10014579C(uint64_t a1)
{
  CFArrayRef v2 = (const UInt8 *)sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 40), 0);
  int v3 = sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 40), 0);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CFStringCreateWithBytes(0, v2, v3, 0x8000100u, 0);
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

BOOL sub_100145814(const __CFDictionary *a1)
{
  CFDataRef Value = CFDictionaryGetValue(a1, kSecAttrSynchronizable);
  uint64_t v2 = (uint64_t)Value;
  if (Value)
  {
    CFTypeID v3 = CFGetTypeID(Value);
    if (v3 == CFBooleanGetTypeID())
    {
      BOOL v4 = CFBooleanGetValue((CFBooleanRef)v2) == 0;
      return !v4;
    }
    CFTypeID v5 = CFGetTypeID((CFTypeRef)v2);
    if (v5 == CFNumberGetTypeID())
    {
      int valuePtr = 0;
      CFNumberGetValue((CFNumberRef)v2, kCFNumberSInt32Type, &valuePtr);
      BOOL v4 = valuePtr == 0;
      return !v4;
    }
    CFTypeID v7 = CFGetTypeID((CFTypeRef)v2);
    if (v7 == CFStringGetTypeID())
    {
      IntCFDataRef Value = CFStringGetIntValue((CFStringRef)v2);
      CFStringRef v9 = CFStringCreateWithFormat(0, 0, @"%ld", IntValue);
      int v10 = CFEqual(v9, (CFTypeRef)v2);
      if (IntValue) {
        BOOL v11 = v10 == 0;
      }
      else {
        BOOL v11 = 1;
      }
      uint64_t v2 = !v11;
      CFRelease(v9);
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

BOOL sub_100145928(const __CFDictionary *a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  if (sub_10000CAEC(a1, 0, a4))
  {
    long long v8 = sub_100145DE4((CFArrayRef *)a2);
    if (v8)
    {
      CFStringRef v9 = v8;
      CFIndex Count = CFArrayGetCount((CFArrayRef)v8);
      if (Count)
      {
        CFIndex v11 = Count;
        kdebug_trace();
        uint64_t v12 = sub_10000C3CC(a1, *(const void **)(a2 + 24), 0, a2, a4);
        if (!v12)
        {
          uint64_t v16 = 0;
          goto LABEL_64;
        }
        uint64_t v13 = v12;
        CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a1, kSecAttrAccessGroup);
        v40.location = 0;
        v40.length = v11;
        if (CFArrayContainsValue((CFArrayRef)v9, v40, @"*"))
        {
          CFRelease(v9);
          CFStringRef v9 = 0;
        }
        if (Value)
        {
          if ((sub_10000C1A8((const __CFArray *)v9, Value, a2) & 1) == 0)
          {
            BOOL v15 = sub_100012A40(-34018, a4, @"Client explicitly specifies access group %@ but is only entitled for %@", Value, v9);
            goto LABEL_16;
          }
        }
        else
        {
          CFStringRef Value = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a2 + 8), 0);
          sub_10000DF34(kSecAttrAccessGroup, (const __CFBoolean *)Value, v13);
        }
        BOOL v15 = 1;
LABEL_16:
        if (sub_10002925C())
        {
          CFDictionaryRef v25 = sub_100139704(0, v18, v19, v20, v21, v22, v23, v24, @"operation", @"add");
          if (v25)
          {
            CFDictionaryRef v26 = v25;
            sub_100029560(@"SecItem", v25);
            CFRelease(v26);
          }
        }
        int v27 = *(_DWORD *)(v13 + 192);
        if (v27 == 2 || v27 == 1 && *(unsigned char *)(a2 + 36))
        {
          uint64_t v28 = *(const void **)(v13 + 128);
          if (v28)
          {
            *(void *)(v13 + 128) = 0;
            CFRelease(v28);
          }
          CFDataRef v29 = CFDataCreateWithBytesNoCopy(0, byte_10026568C, 16, kCFAllocatorNull);
          *(void *)(v13 + 128) = v29;
        }
        else
        {
          *(_DWORD *)(v13 + 192) = 0;
          CFDataRef v29 = *(const __CFData **)(v13 + 128);
        }
        sub_10000E0A8(&off_100303FD0, v29, v13);
        if (!v15)
        {
          int v35 = 0;
          goto LABEL_63;
        }
        sub_100129654((uint64_t *)v13, Value);
        uint64_t v30 = CFDictionaryGetValue(a1, @"f_ckkscallback");
        if (v30)
        {
          *(unsigned char *)(v13 + 154) = 1;
          *(void *)(v13 + 160) = v30;
        }
        CFBooleanRef v31 = sub_10013F924();
        sub_10000DF34(@"persistref", v31, v13);
        CFBooleanRef v32 = *(const __CFBoolean **)(v13 + 80);
        if (v32 != v31)
        {
          if (!v31 || (CFRetain(v31), (CFBooleanRef v32 = *(const __CFBoolean **)(v13 + 80)) != 0)) {
            CFRelease(v32);
          }
          *(void *)(v13 + 80) = v31;
        }
        if (v31) {
          CFRelease(v31);
        }
        if (*(unsigned char *)(a2 + 44))
        {
          if ((sub_100145440(a2) & 1) == 0)
          {
            CFStringRef v34 = @"App clips are not permitted to use access groups other than application identifier";
            goto LABEL_45;
          }
          if (*(unsigned char *)(a2 + 44))
          {
            CFBooleanRef v33 = (CFBooleanRef)CFDictionaryGetValue(a1, kSecAttrSynchronizable);
            if (v33 && kCFBooleanTrue)
            {
              if (CFEqual(v33, kCFBooleanTrue))
              {
LABEL_42:
                CFStringRef v34 = @"App clips are not permitted to add synchronizable items to the keychain";
LABEL_45:
                int v36 = -34020;
LABEL_61:
                int v38 = sub_100012A40(v36, a4, v34);
                goto LABEL_62;
              }
            }
            else if (v33 == kCFBooleanTrue)
            {
              goto LABEL_42;
            }
          }
        }
        int v37 = *(_DWORD *)(v13 + 192);
        if (v37)
        {
          if (!*(unsigned char *)(a2 + 16))
          {
            CFStringRef v34 = @"client doesn't have entitlement for system keychain";
            goto LABEL_60;
          }
          if (v37 == 2 && sub_100145814(a1))
          {
            CFStringRef v34 = @"Can't store system keychain (always) and synchronizable";
LABEL_57:
            int v36 = -50;
            goto LABEL_61;
          }
        }
        if (*(_DWORD *)(v13 + 196) && !*(unsigned char *)(a2 + 17))
        {
          CFStringRef v34 = @"client doesn't have entitlement for syncbubble keychain";
        }
        else
        {
          if (*(void *)(v13 + 72) || *(void *)(v13 + 240))
          {
            CFStringRef v34 = @"q_row_id";
            goto LABEL_57;
          }
          if (!*(unsigned char *)(v13 + 116) || !CFDictionaryContainsKey(*(CFDictionaryRef *)(v13 + 8), kSecAttrSharingGroup))
          {
            if (*(void *)(v13 + 40))
            {
              int v35 = 1;
LABEL_63:
              uint64_t v16 = sub_100129708(v13, v35, (CFErrorRef *)a4);
              if (!v9)
              {
LABEL_65:
                kdebug_trace();
                return v16;
              }
LABEL_64:
              CFRelease(v9);
              goto LABEL_65;
            }
            v39[0] = _NSConcreteStackBlock;
            v39[1] = 0x40000000;
            v39[2] = sub_100145EC8;
            v39[3] = &unk_100304040;
            v39[4] = a4;
            v39[5] = v13;
            v39[6] = a3;
            int v38 = sub_10000CBA4(1, 1, 0, (uint64_t)a4, (uint64_t)v39);
LABEL_62:
            int v35 = v38;
            goto LABEL_63;
          }
          CFStringRef v34 = @"can't add shared item without Keychain Sharing client entitlement";
        }
LABEL_60:
        int v36 = -34018;
        goto LABEL_61;
      }
      CFRelease(v9);
    }
    return sub_100012A40(-34018, a4, @"Client has neither %@ entitlements", @"application-identifier nor keychain-access-groups");
  }
  return 0;
}

CFArrayRef *sub_100145DE4(CFArrayRef *a1)
{
  MutableCopy = a1;
  if (a1)
  {
    CFArrayRef v2 = a1[1];
    if (v2)
    {
      v6.length = CFArrayGetCount(v2);
      v6.location = 0;
      if (CFArrayContainsValue(MutableCopy[1], v6, kSecAttrAccessGroupToken))
      {
        MutableCopy = (CFArrayRef *)CFArrayCreateMutableCopy(kCFAllocatorDefault, 0, MutableCopy[1]);
        v7.length = CFArrayGetCount((CFArrayRef)MutableCopy);
        v7.location = 0;
        FirstIndexOfCFStringRef Value = CFArrayGetFirstIndexOfValue((CFArrayRef)MutableCopy, v7, kSecAttrAccessGroupToken);
        if (FirstIndexOfValue != -1)
        {
          for (CFIndex i = FirstIndexOfValue;
                i != -1;
                CFIndex i = CFArrayGetFirstIndexOfValue((CFArrayRef)MutableCopy, v8, kSecAttrAccessGroupToken))
          {
            CFArrayRemoveValueAtIndex((CFMutableArrayRef)MutableCopy, i);
            v8.length = CFArrayGetCount((CFArrayRef)MutableCopy);
            v8.location = 0;
          }
        }
      }
      else
      {
        MutableCopy = (CFArrayRef *)MutableCopy[1];
        if (MutableCopy) {
          CFRetain(MutableCopy);
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return MutableCopy;
}

BOOL sub_100145EC8(void *a1, uint64_t a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_100145F48;
  void v5[3] = &unk_100304020;
  CFArrayRef v2 = (CFTypeRef *)a1[4];
  uint64_t v3 = a1[6];
  v5[4] = a1[5];
  v5[5] = a2;
  v5[6] = v3;
  v5[7] = v2;
  return sub_1001381F8(a2, 2, v2, (uint64_t)v5);
}

uint64_t sub_100145F48(uint64_t a1)
{
  sub_1001397F8(*(CFDictionaryRef **)(a1 + 32));
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  BOOL v4 = *(CFDataRef **)(a1 + 48);
  CFTypeID v5 = *(__CFString ***)(a1 + 56);

  return sub_100138A0C(v2, v3, v4, v5);
}

CFNullRef sub_100145F88(const __CFDictionary *a1, CFTypeRef cf1, uint64_t a3, __CFString **a4)
{
  if (cf1)
  {
    CFBooleanRef v8 = (const __CFBoolean *)kSecAttrSharingGroupNone;
    if (!kSecAttrSharingGroupNone || !CFEqual(cf1, kSecAttrSharingGroupNone))
    {
      if (*(unsigned char *)(a3 + 57))
      {
        if (!sub_10000CAEC(a1, 1, a4)) {
          return 0;
        }
        if (CFDictionaryContainsKey(a1, kSecAttrTombstone))
        {
          CFStringRef v9 = @"Tombstones can't be shared";
          goto LABEL_5;
        }
        if (*(unsigned char *)(a3 + 36))
        {
          sub_100012A40(-909, a4, @"This client can't share items");
          return 0;
        }
        uint64_t v13 = sub_100145DE4((CFArrayRef *)a3);
        if (v13)
        {
          CFArrayRef v14 = (const __CFArray *)v13;
          if (CFArrayGetCount((CFArrayRef)v13))
          {
            v52.length = CFArrayGetCount(v14);
            v52.location = 0;
            if (CFArrayContainsValue(v14, v52, @"*"))
            {
              CFRelease(v14);
              CFArrayRef v14 = 0;
            }
            CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a1, kSecAttrAccessGroup);
            if (!Value)
            {
LABEL_26:
              uint64_t v24 = sub_10000C3CC(a1, *(const void **)(a3 + 24), -1, a3, a4);
              if (v24)
              {
                uint64_t v25 = v24;
                sub_10000C278(v24, v14);
                if ((sub_100129260(*(CFTypeRef *)(v25 + 128))
                   || sub_100012A40(-909, a4, @"Items from a multi-user view can't be shared"))
                  && (!*(_DWORD *)(v25 + 192) || sub_100012A40(-909, a4, @"System keychain items can't be shared")))
                {
                  if (*(_DWORD *)(v25 + 196)) {
                    BOOL v26 = sub_100012A40(-909, a4, @"Items in a sync bubble can't be shared");
                  }
                  else {
                    BOOL v26 = 1;
                  }
                }
                else
                {
                  BOOL v26 = 0;
                }
                int v27 = *(_DWORD *)(v25 + 48);
                *(_DWORD *)(v25 + 48) = 3;
                uint64_t v28 = *(void *)(v25 + 104);
                CFDataRef v29 = (const void *)kSecAttrSharingGroup;
                if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(v25 + 8), kSecAttrSharingGroup)) {
                  sub_10000DF34(v29, v8, v25);
                }
                if (v26 && (!*(void *)(v25 + 40) || (sub_10000C588(v25, (CFErrorRef *)a4) & 1) != 0))
                {
                  uint64_t v48 = 0;
                  v49 = &v48;
                  uint64_t v50 = 0x2000000000;
                  char v51 = 1;
                  uint64_t v44 = 0;
                  v45 = &v44;
                  uint64_t v46 = 0x2000000000;
                  uint64_t v47 = 0;
                  uint64_t v40 = 0;
                  uint64_t v41 = &v40;
                  uint64_t v42 = 0x2000000000;
                  uint64_t v43 = 0;
                  v38[0] = _NSConcreteStackBlock;
                  v38[1] = 0x40000000;
                  v38[2] = sub_100146510;
                  v38[3] = &unk_1003040B0;
                  v38[8] = v25;
                  v38[9] = v14;
                  v38[4] = &v48;
                  v38[5] = &v44;
                  v38[6] = &v40;
                  v38[7] = a4;
                  v38[10] = cf1;
                  int v39 = v27;
                  char v30 = sub_10000CBA4(1, 1, 0, (uint64_t)a4, (uint64_t)v38);
                  sub_10000C2C4((const void **)v25, (CFErrorRef *)a4);
                  if (v14) {
                    CFRelease(v14);
                  }
                  if (*((unsigned char *)v49 + 24))
                  {
                    if (v30)
                    {
                      sub_10013F0C8();
                      sub_10013F064();
                      if (!v27)
                      {
                        CFNullRef v11 = kCFNull;
                        goto LABEL_66;
                      }
                      if (v28 == 1)
                      {
                        if (CFArrayGetCount((CFArrayRef)v41[3]) != 1)
                        {
                          CFNullRef v11 = 0;
LABEL_66:
                          int v35 = (const void *)v41[3];
                          if (v35)
                          {
                            v41[3] = 0;
                            CFRelease(v35);
                          }
                          goto LABEL_68;
                        }
                        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v41[3], 0);
                        CFNullRef Copy = (const __CFNull *)CFRetain(ValueAtIndex);
                      }
                      else
                      {
                        CFNullRef Copy = CFArrayCreateCopy(kCFAllocatorDefault, (CFArrayRef)v41[3]);
                      }
                      CFNullRef v11 = Copy;
                      goto LABEL_66;
                    }
                    CFStringRef v34 = (const void *)v41[3];
                    if (v34)
                    {
                      v41[3] = 0;
                      CFRelease(v34);
                    }
                  }
                  else
                  {
                    CFBooleanRef v33 = (const void *)v41[3];
                    if (v33)
                    {
                      v41[3] = 0;
                      CFRelease(v33);
                    }
                    sub_1001465B0((__CFError *)v45[3], (CFErrorRef *)a4);
                  }
                  CFNullRef v11 = 0;
LABEL_68:
                  _Block_object_dispose(&v40, 8);
                  _Block_object_dispose(&v44, 8);
                  _Block_object_dispose(&v48, 8);
                  return v11;
                }
                sub_10000C2C4((const void **)v25, 0);
              }
              if (v14) {
                CFRelease(v14);
              }
              return 0;
            }
            uint64_t v16 = (uint64_t)Value;
            if (sub_10000C1A8(v14, Value, a3))
            {
              if (v14) {
                CFRelease(v14);
              }
              CFArrayRef v14 = sub_100146438(kCFAllocatorDefault, v17, v18, v19, v20, v21, v22, v23, v16);
              goto LABEL_26;
            }
            if (v14) {
              CFRelease(v14);
            }
            CFStringRef v36 = (const __CFString *)v16;
            uint64_t v37 = 0;
            CFStringRef v9 = @"Client explicitly specifies access group %@ but is only entitled for %@";
LABEL_14:
            int v10 = -34018;
            goto LABEL_6;
          }
          CFRelease(v14);
        }
        CFStringRef v36 = @"application-identifier nor keychain-access-groups";
        CFStringRef v9 = @"Client has neither %@ entitlements";
        goto LABEL_14;
      }
      CFStringRef v9 = @"Client doesn't have Keychain Sharing client entitlement";
      goto LABEL_14;
    }
  }
  CFStringRef v9 = @"A group must be specified to share the item";
LABEL_5:
  int v10 = -50;
LABEL_6:
  sub_100012A40(v10, a4, v9, v36, v37);
  return 0;
}

CFArrayRef sub_100146438(CFAllocatorRef allocator, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v19 = &a9;
  CFIndex v10 = -1;
  do
  {
    CFNullRef v11 = v19++;
    ++v10;
  }
  while (*v11);
  uint64_t v20 = (const __CFNull **)&a9;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(allocator, v10, &kCFTypeArrayCallBacks);
  if (!Mutable) {
    return 0;
  }
  for (CFIndex i = Mutable; v10; --v10)
  {
    CFArrayRef v14 = v20++;
    CFNullRef v15 = *v14;
    if (v15) {
      CFNullRef v16 = v15;
    }
    else {
      CFNullRef v16 = kCFNull;
    }
    CFArrayAppendValue(i, v16);
  }
  CFArrayRef Copy = CFArrayCreateCopy(allocator, i);
  CFRelease(i);
  return Copy;
}

BOOL sub_100146510(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(CFTypeRef **)(a1 + 56);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10014663C;
  v4[3] = &unk_100304088;
  long long v7 = *(_OWORD *)(a1 + 64);
  long long v5 = *(_OWORD *)(a1 + 32);
  uint64_t v8 = a2;
  CFStringRef v9 = v2;
  uint64_t v6 = *(void *)(a1 + 48);
  uint64_t v10 = *(void *)(a1 + 80);
  int v11 = *(_DWORD *)(a1 + 88);
  return sub_1001381F8(a2, 2, v2, (uint64_t)v4);
}

void sub_1001465B0(__CFError *cf, CFErrorRef *a2)
{
  if (cf && a2)
  {
    if (!*a2) {
      goto LABEL_13;
    }
    if (CFErrorGetCode(*a2) != -25330) {
      goto LABEL_9;
    }
    CFErrorRef v4 = *a2;
    if (!*a2)
    {
LABEL_13:
      *a2 = cf;
      return;
    }
    *a2 = 0;
    CFRelease(v4);
  }
  else
  {
    if (!cf) {
      return;
    }
    if (!a2) {
      goto LABEL_10;
    }
  }
LABEL_9:
  if (!*a2) {
    goto LABEL_13;
  }
LABEL_10:

  CFRelease(cf);
}

BOOL sub_10014663C(uint64_t a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  uint64_t v3 = *(void *)(a1 + 56);
  CFArrayRef v4 = *(const __CFArray **)(a1 + 64);
  uint64_t v5 = *(void *)(a1 + 72);
  uint64_t v6 = (__CFString **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  v35[0] = _NSConcreteStackBlock;
  v35[1] = 0x40000000;
  v35[2] = sub_100146B40;
  v35[3] = &unk_100304060;
  v35[4] = Mutable;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = sub_100138F00(v3, v4, v5, v6, (uint64_t)v35);
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    if (!Mutable) {
      return 0;
    }
LABEL_59:
    CFRelease(Mutable);
    return 0;
  }
  if (!CFArrayGetCount(Mutable))
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = sub_100012A40(-25300, *(__CFString ***)(a1 + 80), @"No items matched the query");
    if (!Mutable) {
      return 0;
    }
    goto LABEL_59;
  }
  CFIndex Count = CFArrayGetCount(Mutable);
  CFIndex v8 = 0;
  *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = CFArrayCreateMutable(kCFAllocatorDefault, Count, &kCFTypeArrayCallBacks);
  CFStringRef v9 = (const void *)kSecAttrUUID;
  CFTypeRef cf2 = (CFTypeRef)kSecAttrSharingGroup;
  CFBooleanRef v31 = Mutable;
  while (2)
  {
    if (v8 >= CFArrayGetCount(Mutable)) {
      goto LABEL_64;
    }
    CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(Mutable, v8);
    int v11 = (__CFString **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    uint64_t v12 = (void *)ValueAtIndex[2];
    uint64_t v13 = v12[2];
    if (!v13)
    {
LABEL_38:
      LOBYTE(v20) = sub_100012A40(-50, v11, @"Items of class '%@' can't be shared", *v12);
      goto LABEL_41;
    }
    CFIndex v33 = v8;
    CFArrayRef v14 = 0;
    CFNullRef v15 = 0;
    CFNullRef v16 = 0;
    uint64_t v17 = 0;
    uint64_t v30 = *(void *)(a1 + 72);
    CFDataRef v32 = *(const __CFData **)(a1 + 88);
    uint64_t v18 = v12 + 3;
    do
    {
      if (CFEqual(*(CFTypeRef *)v13, v9))
      {
        CFArrayRef v14 = (void *)v13;
        if (!v13) {
          goto LABEL_22;
        }
      }
      else if (CFEqual(*(CFTypeRef *)v13, cf2))
      {
        uint64_t v17 = (void *)v13;
        if (!v14) {
          goto LABEL_22;
        }
      }
      else if (CFEqual(*(CFTypeRef *)v13, kSecAttrSynchronizable))
      {
        CFNullRef v16 = (void *)v13;
        if (!v14) {
          goto LABEL_22;
        }
      }
      else
      {
        if (*(_DWORD *)(v13 + 8) == 16) {
          CFNullRef v15 = (void *)v13;
        }
        if (!v14) {
          goto LABEL_22;
        }
      }
      if (v17 && v16 && v15)
      {
        sub_10011B874((uint64_t)ValueAtIndex, v11);
        goto LABEL_27;
      }
LABEL_22:
      uint64_t v19 = *v18++;
      uint64_t v13 = v19;
    }
    while (v19);
    if (!v17)
    {
      uint64_t v12 = (void *)ValueAtIndex[2];
      CFMutableArrayRef Mutable = v31;
      CFIndex v8 = v33;
      goto LABEL_38;
    }
    sub_10011B874((uint64_t)ValueAtIndex, v11);
    if (v14)
    {
LABEL_27:
      int v20 = sub_1001196B4((uint64_t)ValueAtIndex, v14, 0, v11);
      if (v20) {
        goto LABEL_28;
      }
      goto LABEL_40;
    }
LABEL_28:
    if (v15)
    {
      CFDataRef v21 = sub_10013F924();
      int v22 = sub_1001196B4((uint64_t)ValueAtIndex, v15, v21, v11);
      if (v21) {
        CFRelease(v21);
      }
      if (!v22)
      {
        LOBYTE(v20) = 0;
        goto LABEL_40;
      }
    }
    int v20 = sub_1001196B4((uint64_t)ValueAtIndex, v17, v32, v11);
    if (!v20) {
      goto LABEL_40;
    }
    if (v16)
    {
      int v20 = sub_1001196B4((uint64_t)ValueAtIndex, v16, kCFBooleanFalse, v11);
      if (!v20) {
        goto LABEL_40;
      }
    }
    CFTypeRef cf = 0;
    v37[0] = _NSConcreteStackBlock;
    v37[1] = 0x40000000;
    v37[2] = sub_10011DDE8;
    v37[3] = &unk_1002FA9B0;
    v37[4] = ValueAtIndex;
    __int16 v38 = 0;
    if (sub_10011C214((uint64_t)ValueAtIndex, v30, (__CFString **)&cf, (uint64_t)v37)) {
      goto LABEL_36;
    }
    unsigned int v25 = sub_10011C1B8((__CFError *)cf);
    BOOL v26 = (__CFString *)cf;
    if (!v25)
    {
      if (cf)
      {
        CFMutableArrayRef Mutable = v31;
        CFIndex v8 = v33;
        if (*v11)
        {
          if (CFErrorGetCode((CFErrorRef)*v11) != -25330) {
            goto LABEL_55;
          }
          int v27 = *v11;
          if (*v11)
          {
            *int v11 = 0;
            CFRelease(v27);
LABEL_55:
            if (*v11)
            {
              CFRelease(v26);
              LOBYTE(v20) = 0;
              goto LABEL_41;
            }
          }
        }
        LOBYTE(v20) = 0;
        *int v11 = v26;
        goto LABEL_41;
      }
LABEL_36:
      LOBYTE(v20) = 1;
LABEL_40:
      CFMutableArrayRef Mutable = v31;
      CFIndex v8 = v33;
      goto LABEL_41;
    }
    CFMutableArrayRef Mutable = v31;
    CFIndex v8 = v33;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v26);
    }
    LOBYTE(v20) = sub_100012A40(-25299, v11, @"Item is already shared with this group", v29);
LABEL_41:
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v20;
    if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
      goto LABEL_64;
    }
    CFDataRef v23 = sub_1001387B4((uint64_t)ValueAtIndex, *(_DWORD *)(a1 + 96), (__CFString **)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
    if (v23)
    {
      CFDataRef v24 = v23;
      if (!CFEqual(v23, kCFNull)) {
        CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(*(void *)(a1 + 48) + 8) + 24), v24);
      }
      CFRelease(v24);
      ++v8;
      continue;
    }
    break;
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
LABEL_64:
  if (Mutable) {
    CFRelease(Mutable);
  }
  return *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

void sub_100146B40(uint64_t a1, const void *a2)
{
}

uint64_t sub_100146B48(uint64_t a1, uint64_t a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_100146BE0;
  v4[3] = &unk_100304138;
  void v4[4] = a2;
  v4[5] = a1;
  uint64_t v2 = sub_10000CBA4(1, 1, 0, a2, (uint64_t)v4);
  if (v2)
  {
    sub_10013F0C8();
    sub_10013F064();
  }
  return v2;
}

BOOL sub_100146BE0(int8x16_t *a1, uint64_t a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_100146C64;
  v4[3] = &unk_100304118;
  int8x16_t v2 = a1[2];
  int8x16_t v5 = vextq_s8(v2, v2, 8uLL);
  uint64_t v6 = a2;
  return sub_1001381F8(a2, 2, (CFTypeRef *)v2.i64[0], (uint64_t)v4);
}

uint64_t sub_100146C64(uint64_t a1)
{
  uint64_t v32 = 0;
  CFIndex v33 = &v32;
  uint64_t v34 = 0x2000000000;
  char v35 = 1;
  int8x16_t v2 = *(const void **)(*(void *)(a1 + 32) + 24);
  if (!v2)
  {
    if (qword_10035CF58 != -1) {
      dispatch_once(&qword_10035CF58, &stru_1002FAF90);
    }
    int8x16_t v2 = (const void *)qword_10035CF60;
  }
  v40[0] = sub_10000C75C(@"inet", &qword_10035D020, (uint64_t)&unk_10035D018);
  v40[1] = sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008);
  v40[2] = sub_10000C75C(@"cert", &qword_10035D030, (uint64_t)&unk_10035D028);
  v40[3] = sub_10000C75C(@"keys", &qword_10035D040, (uint64_t)&unk_10035D038);
  CFArrayRef v10 = sub_100146438(0, v3, v4, v5, v6, v7, v8, v9, @"com.apple.safari.credit-cards");
  int v11 = v33;
  if (*((unsigned char *)v33 + 24))
  {
    unint64_t v12 = 0;
    int v27 = (const void *)kSecAttrMultiUser;
    while (1)
    {
      uint64_t v13 = sub_10000B070("SecDeleteItemsOnSignOut");
      BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG);
      CFNullRef v15 = (uint64_t *)v40[v12];
      if (v14)
      {
        uint64_t v24 = *v15;
        *(_DWORD *)buf = 138412546;
        uint64_t v37 = v24;
        __int16 v38 = 2112;
        int v39 = v2;
        _os_log_debug_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "Deleting items from class=%@ with multi-user view=%@", buf, 0x16u);
      }
      CFNullRef v16 = (CFDictionaryRef *)sub_10000C7F0((uint64_t)v15, v2, 0, *(void *)(a1 + 32), *(__CFString ***)(a1 + 40));
      if (!v16) {
        break;
      }
      uint64_t v17 = v16;
      sub_10000DF34(v27, (const __CFBoolean *)v2, (uint64_t)v16);
      sub_10000DF34(kSecAttrSynchronizable, kCFBooleanTrue, (uint64_t)v17);
      for (CFIndex i = 0; i < CFArrayGetCount(v10); ++i)
      {
        CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(v10, i);
        sub_100129340(kSecAttrAccessGroup, ValueAtIndex, (uint64_t)v17);
      }
      uint64_t v20 = *(void *)(a1 + 48);
      uint64_t v29 = *(CFTypeRef **)(a1 + 40);
      v30.isa = _NSConcreteStackBlock;
      *(void *)&v30.flags = 0x40000000;
      v30.invoke = (void (*)(void *, ...))sub_10014708C;
      v30.descriptor = (Block_descriptor_1 *)&unk_1003040D0;
      CFBooleanRef v31 = v17;
      v28[0] = _NSConcreteStackBlock;
      v28[1] = 0x40000000;
      v28[2] = sub_1001470B8;
      v28[3] = &unk_1003040F8;
      v28[4] = &v32;
      v28[5] = v20;
      BOOL v21 = sub_10011C750(v17, v20, v29, 0, &v30, 0, 0, (uint64_t)v28);
      if (*((unsigned char *)v33 + 24)) {
        BOOL v22 = v21;
      }
      else {
        BOOL v22 = 0;
      }
      *((unsigned char *)v33 + 24) = v22;
      sub_10000C2C4((const void **)v17, 0);
      int v11 = v33;
      if (*((unsigned char *)v33 + 24))
      {
        if (v12++ < 3) {
          continue;
        }
      }
      goto LABEL_21;
    }
    int v11 = v33;
    *((unsigned char *)v33 + 24) = 0;
  }
LABEL_21:
  if (v10)
  {
    CFRelease(v10);
    int v11 = v33;
  }
  uint64_t v25 = *((unsigned __int8 *)v11 + 24);
  _Block_object_dispose(&v32, 8);
  return v25;
}

BOOL sub_10014708C(uint64_t a1, const void **a2)
{
  return CFDictionaryContainsKey(*(CFDictionaryRef *)(*(void *)(a1 + 32) + 8), *a2) != 0;
}

CFStringRef **sub_1001470B8(uint64_t a1, CFStringRef **a2, unsigned char *a3)
{
  uint64_t result = sub_10011ED78(a2, *(void *)(a1 + 40), kCFBooleanFalse, 0, *(CFTypeRef **)(a1 + 48));
  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v6 + 24)) {
    char v7 = (char)result;
  }
  else {
    char v7 = 0;
  }
  *(unsigned char *)(v6 + 24) = v7;
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    *a3 = 1;
  }
  return result;
}

BOOL sub_10014712C(const __CFDictionary *a1, const __CFDictionary *a2, uint64_t a3, __CFString **a4)
{
  if (!sub_10000CAEC(a1, 1, a4) || !sub_10000CAEC(a2, 2, a4)) {
    return 0;
  }
  uint64_t v8 = sub_100145DE4((CFArrayRef *)a3);
  if (!v8) {
    return sub_100012A40(-34018, a4, @"Client has neither %@ entitlements", @"application-identifier nor keychain-access-groups");
  }
  uint64_t v9 = v8;
  CFIndex Count = CFArrayGetCount((CFArrayRef)v8);
  if (!Count)
  {
    CFRelease(v9);
    return sub_100012A40(-34018, a4, @"Client has neither %@ entitlements", @"application-identifier nor keychain-access-groups");
  }
  CFIndex v11 = Count;
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a1, kSecAttrAccessGroup);
  if (!Value || (CFStringRef v13 = Value, (sub_10000C1A8((const __CFArray *)v9, Value, a3) & 1) != 0))
  {
    kdebug_trace();
    if (sub_10002925C())
    {
      CFDataRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v9, 0);
      uint64_t v41 = 0;
      CFStringRef v39 = @"AccessGroup";
      CFDictionaryRef v21 = sub_100139704(0, v14, v15, v16, v17, v18, v19, v20, @"operation", @"update");
      if (v21)
      {
        CFDictionaryRef v22 = v21;
        sub_100029560(@"SecItem", v21);
        CFRelease(v22);
      }
    }
    v45.location = 0;
    v45.length = v11;
    if (CFArrayContainsValue((CFArrayRef)v9, v45, @"*"))
    {
      CFRelease(v9);
      uint64_t v9 = 0;
    }
    uint64_t v23 = sub_10000C3CC(a1, *(const void **)(a3 + 24), -1, a3, a4);
    if (!v23)
    {
      uint64_t v28 = 0;
LABEL_74:
      if (v9) {
        CFRelease(v9);
      }
      kdebug_trace();
      return v28;
    }
    uint64_t v24 = v23;
    int v25 = *(_DWORD *)(v23 + 192);
    if (v25 == 2 || v25 == 1 && *(unsigned char *)(a3 + 36))
    {
      BOOL v26 = *(const void **)(v23 + 128);
      if (v26)
      {
        *(void *)(v24 + 128) = 0;
        CFRelease(v26);
      }
      *(void *)(v24 + 128) = CFDataCreateWithBytesNoCopy(0, byte_10026568C, 16, kCFAllocatorNull);
    }
    else
    {
      *(_DWORD *)(v23 + 192) = 0;
    }
    sub_10000C278(v24, v9);
    if (!*(unsigned char *)(a3 + 44)) {
      goto LABEL_41;
    }
    if ((sub_100145440(a3) & 1) == 0)
    {
      CFStringRef v30 = @"App clips are not permitted to use access groups other than application identifier";
LABEL_39:
      int v32 = -34020;
      goto LABEL_65;
    }
    if (!*(unsigned char *)(a3 + 44)) {
      goto LABEL_41;
    }
    CFBooleanRef v29 = (CFBooleanRef)CFDictionaryGetValue(a1, kSecAttrSynchronizable);
    if (v29 && kCFBooleanTrue)
    {
      if (!CFEqual(v29, kCFBooleanTrue)) {
        goto LABEL_35;
      }
    }
    else if (v29 != kCFBooleanTrue)
    {
LABEL_35:
      CFBooleanRef v31 = (CFBooleanRef)CFDictionaryGetValue(a2, kSecAttrSynchronizable);
      if (kCFBooleanTrue && v31)
      {
        if (CFEqual(v31, kCFBooleanTrue)) {
          goto LABEL_38;
        }
      }
      else if (v31 == kCFBooleanTrue)
      {
        goto LABEL_38;
      }
LABEL_41:
      int v33 = *(_DWORD *)(v24 + 192);
      if (v33)
      {
        if (!*(unsigned char *)(a3 + 16))
        {
          CFStringRef v30 = @"client doesn't have entitlement for system keychain";
          goto LABEL_59;
        }
        if (v33 == 2 && sub_100145814(a2))
        {
          CFStringRef v30 = @"Can't update a system keychain (always) item with synchronizable";
LABEL_64:
          int v32 = -50;
LABEL_65:
          if (sub_100012A40(v32, a4, v30))
          {
LABEL_66:
            v42[0] = _NSConcreteStackBlock;
            v42[1] = 0x40000000;
            v42[2] = sub_100147690;
            v42[3] = &unk_100304178;
            v42[4] = a4;
            v42[5] = v24;
            v42[6] = a2;
            v42[7] = v9;
            int v35 = sub_10000CBA4(1, 1, 0, (uint64_t)a4, (uint64_t)v42);
LABEL_73:
            uint64_t v28 = sub_100129708(v24, v35, (CFErrorRef *)a4);
            goto LABEL_74;
          }
LABEL_72:
          int v35 = 0;
          goto LABEL_73;
        }
      }
      if (*(_DWORD *)(v24 + 196) && !*(unsigned char *)(a3 + 17))
      {
        CFStringRef v30 = @"client doesn't have entitlement for syncbubble keychain";
      }
      else
      {
        if (*(void *)(v24 + 88))
        {
          CFStringRef v30 = @"use item list not supported";
          goto LABEL_64;
        }
        int v34 = *(_DWORD *)(v24 + 48);
        if (v34)
        {
          CFStringRef v30 = @"return data not supported by update";
          goto LABEL_64;
        }
        if ((v34 & 2) != 0)
        {
          CFStringRef v30 = @"return attributes not supported by update";
          goto LABEL_64;
        }
        if ((v34 & 4) != 0)
        {
          CFStringRef v30 = @"return ref not supported by update";
          goto LABEL_64;
        }
        if ((v34 & 8) != 0)
        {
          CFStringRef v30 = @"return persistent ref not supported by update";
          goto LABEL_64;
        }
        if (!*(unsigned char *)(v24 + 116) || !CFDictionaryContainsKey(*(CFDictionaryRef *)(v24 + 8), kSecAttrSharingGroup))
        {
          CFStringRef v36 = (const __CFString *)CFDictionaryGetValue(a2, kSecAttrAccessGroup);
          if (!v36) {
            goto LABEL_66;
          }
          CFStringRef v37 = v36;
          if (sub_10000C1A8((const __CFArray *)v9, v36, a3)) {
            goto LABEL_66;
          }
          __int16 v38 = sub_10000B070("SecError");
          if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412290;
            CFStringRef v44 = v37;
            _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "Cannot update keychain item to access group %@", buf, 0xCu);
          }
          if (sub_100012A40(-34018, a4, @"Client explicitly specifies access group %@ but is only entitled for %@", v37, v9, v39, ValueAtIndex, v41))
          {
            goto LABEL_66;
          }
          goto LABEL_72;
        }
        CFStringRef v30 = @"can't update shared items without Keychain Sharing client entitlement";
      }
LABEL_59:
      int v32 = -34018;
      goto LABEL_65;
    }
LABEL_38:
    CFStringRef v30 = @"App clips are not permitted to make items synchronizable";
    goto LABEL_39;
  }
  sub_100012A40(-34018, a4, @"Client explicitly specifies access group %@ but is only entitled for %@", v13, v9);
  CFRelease(v9);
  return 0;
}

BOOL sub_100147690(uint64_t a1, uint64_t a2)
{
  int8x16_t v2 = *(CFTypeRef **)(a1 + 32);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_100147718;
  v4[3] = &unk_100304158;
  void v4[4] = a2;
  long long v5 = *(_OWORD *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 56);
  char v7 = v2;
  return sub_1001381F8(a2, 2, v2, (uint64_t)v4);
}

BOOL sub_100147718(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  int8x16_t v2 = *(__CFString ***)(a1 + 64);
  if (*(void *)(v1 + 24) != *(void *)(v1 + 16))
  {
    CFStringRef v3 = @"match not supported in attributes to update";
    goto LABEL_5;
  }
  if (*(void *)(v1 + 64))
  {
    CFStringRef v3 = @"value ref not supported in attributes to update";
LABEL_5:
    return sub_100012A40(-50, v2, v3);
  }
  uint64_t v5 = *(void *)(a1 + 32);
  CFDictionaryRef v6 = *(const __CFDictionary **)(a1 + 48);
  uint64_t v7 = *(void *)(a1 + 56);
  if (*(void *)(v1 + 72) && *(void *)(v1 + 32))
  {
    CFStringRef v3 = @"attributes to update illegal; both row_id and other attributes can't be updated at the same time";
    goto LABEL_5;
  }
  if (*(void *)(v1 + 240) && *(void *)(v1 + 32) != 1)
  {
    CFStringRef v3 = @"attributes to update illegal; both token persistent ref and other attributes can't be updated at the same time";
    goto LABEL_5;
  }
  if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 48), kSecAttrSharingGroup))
  {
    CFStringRef v3 = @"Cannot change SharingGroup using this API";
    goto LABEL_5;
  }
  uint64_t v20 = 0;
  CFDictionaryRef v21 = &v20;
  uint64_t v22 = 0x2000000000;
  char v23 = 1;
  uint64_t v8 = (const void **)sub_10000C7F0(*(void *)v1, 0, v6, 0, v2);
  if (v8)
  {
    uint64_t v9 = v8;
    CFDictionaryApplyFunction(v6, (CFDictionaryApplierFunction)sub_100129784, v8);
    if (sub_10000C588((uint64_t)v9, (CFErrorRef *)v2))
    {
      uint64_t v10 = *((void *)*v9 + 2);
      if (v10)
      {
        CFIndex v11 = (uint64_t *)((char *)*v9 + 24);
        do
        {
          if (*(_DWORD *)(v10 + 8) == 6)
          {
            CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
            CFDataRef v13 = CFDateCreate(0, Current);
            sub_100139958((CFTypeRef *)v10, v13, (uint64_t)v9);
            if (v13) {
              CFRelease(v13);
            }
          }
          uint64_t v14 = *v11++;
          uint64_t v10 = v14;
        }
        while (v14);
      }
      v19[0] = _NSConcreteStackBlock;
      v19[1] = 0x40000000;
      v19[2] = sub_100139A44;
      v19[3] = &unk_1002FB9F0;
      v19[4] = &v20;
      v19[5] = v1;
      v19[6] = v7;
      v19[7] = v5;
      v19[8] = v2;
      v19[9] = v9;
      BOOL v15 = sub_100027B34(v5, 2, (CFTypeRef *)v2, (uint64_t)v19);
      if (*((unsigned char *)v21 + 24)) {
        BOOL v16 = v15;
      }
      else {
        BOOL v16 = 0;
      }
      *((unsigned char *)v21 + 24) = v16;
      if (v16 && !*(unsigned char *)(v1 + 113))
      {
        BOOL v17 = sub_100012A40(-25300, v2, @"No items updated");
        *((unsigned char *)v21 + 24) = v17;
      }
    }
    else
    {
      *((unsigned char *)v21 + 24) = 0;
    }
    if (sub_10000C2C4(v9, (CFErrorRef *)v2))
    {
      BOOL v18 = *((unsigned __int8 *)v21 + 24) != 0;
    }
    else
    {
      BOOL v18 = 0;
      *((unsigned char *)v21 + 24) = 0;
    }
  }
  else
  {
    BOOL v18 = 0;
  }
  _Block_object_dispose(&v20, 8);
  return v18;
}

BOOL sub_1001479D0(const __CFDictionary *a1, uint64_t a2, __CFString **a3)
{
  if (!sub_10000CAEC(a1, 3, a3)) {
    return 0;
  }
  CFDictionaryRef v6 = sub_100145DE4((CFArrayRef *)a2);
  if (!v6) {
    return sub_100012A40(-34018, a3, @"Client has neither %@ entitlements", @"application-identifier nor keychain-access-groups");
  }
  uint64_t v7 = v6;
  CFIndex Count = CFArrayGetCount((CFArrayRef)v6);
  if (!Count)
  {
    CFRelease(v7);
    return sub_100012A40(-34018, a3, @"Client has neither %@ entitlements", @"application-identifier nor keychain-access-groups");
  }
  CFIndex v9 = Count;
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(a1, kSecAttrAccessGroup);
  if (!Value || (CFStringRef v11 = Value, (sub_10000C1A8((const __CFArray *)v7, Value, a2) & 1) != 0))
  {
    kdebug_trace();
    if (sub_10002925C())
    {
      CFArrayGetValueAtIndex((CFArrayRef)v7, 0);
      CFDictionaryRef v19 = sub_100139704(0, v12, v13, v14, v15, v16, v17, v18, @"operation", @"delete");
      if (v19)
      {
        CFDictionaryRef v20 = v19;
        sub_100029560(@"SecItem", v19);
        CFRelease(v20);
      }
    }
    v31.location = 0;
    v31.length = v9;
    if (CFArrayContainsValue((CFArrayRef)v7, v31, @"*"))
    {
      CFRelease(v7);
      uint64_t v7 = 0;
    }
    uint64_t v21 = sub_10000C3CC(a1, *(const void **)(a2 + 24), -1, a2, a3);
    if (!v21)
    {
      uint64_t v26 = 0;
LABEL_45:
      if (v7) {
        CFRelease(v7);
      }
      kdebug_trace();
      return v26;
    }
    uint64_t v22 = v21;
    int v23 = *(_DWORD *)(v21 + 192);
    if (v23 == 2 || v23 == 1 && *(unsigned char *)(a2 + 36))
    {
      uint64_t v24 = *(const void **)(v21 + 128);
      if (v24)
      {
        *(void *)(v22 + 128) = 0;
        CFRelease(v24);
      }
      *(void *)(v22 + 128) = CFDataCreateWithBytesNoCopy(0, byte_10026568C, 16, kCFAllocatorNull);
    }
    else
    {
      *(_DWORD *)(v21 + 192) = 0;
    }
    sub_10000C278(v22, v7);
    if (*(unsigned char *)(a2 + 44) && (sub_100145440(a2) & 1) == 0)
    {
      int v28 = sub_100012A40(-34020, a3, @"App clips are not permitted to use access groups other than application identifier");
LABEL_44:
      uint64_t v26 = sub_100129708(v22, v28, (CFErrorRef *)a3);
      goto LABEL_45;
    }
    if (*(_DWORD *)(v22 + 192) && !*(unsigned char *)(a2 + 16))
    {
      CFStringRef v27 = @"client doesn't have entitlement for system keychain";
    }
    else if (*(_DWORD *)(v22 + 196) && !*(unsigned char *)(a2 + 17))
    {
      CFStringRef v27 = @"client doesn't have entitlement for syncbubble keychain";
    }
    else
    {
      if (*(void *)(v22 + 104) != -1)
      {
        CFStringRef v27 = @"match limit not supported by delete";
LABEL_42:
        int v29 = -50;
        goto LABEL_43;
      }
      if (*(void *)(v22 + 24) != *(void *)(v22 + 16))
      {
        CFStringRef v27 = @"match not supported by delete";
        goto LABEL_42;
      }
      if (*(void *)(v22 + 64))
      {
        CFStringRef v27 = @"value ref not supported by delete";
        goto LABEL_42;
      }
      if (*(void *)(v22 + 72) && *(void *)(v22 + 32))
      {
        CFStringRef v27 = @"rowid and other attributes are mutually exclusive";
        goto LABEL_42;
      }
      if (*(void *)(v22 + 240) && *(void *)(v22 + 32) != 1)
      {
        CFStringRef v27 = @"token persistent ref and other attributes are mutually exclusive";
        goto LABEL_42;
      }
      if (!*(unsigned char *)(v22 + 116) || !CFDictionaryContainsKey(*(CFDictionaryRef *)(v22 + 8), kSecAttrSharingGroup))
      {
        v30[0] = _NSConcreteStackBlock;
        v30[1] = 0x40000000;
        v30[2] = sub_100147DB4;
        v30[3] = &unk_1003041B8;
        v30[4] = a3;
        v30[5] = v22;
        v30[6] = v7;
        int v28 = sub_10000CBA4(1, 1, 0, (uint64_t)a3, (uint64_t)v30);
        goto LABEL_44;
      }
      CFStringRef v27 = @"can't delete shared items without Keychain Sharing client entitlement";
    }
    int v29 = -34018;
LABEL_43:
    int v28 = sub_100012A40(v29, a3, v27);
    goto LABEL_44;
  }
  sub_100012A40(-34018, a3, @"Client explicitly specifies access group %@ but is only entitled for %@", v11, v7);
  CFRelease(v7);
  return 0;
}

BOOL sub_100147DB4(uint64_t a1, uint64_t a2)
{
  int8x16_t v2 = *(CFTypeRef **)(a1 + 32);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_100147E38;
  v4[3] = &unk_100304198;
  void v4[4] = a2;
  long long v5 = *(_OWORD *)(a1 + 40);
  CFDictionaryRef v6 = v2;
  return sub_1001381F8(a2, 2, v2, (uint64_t)v4);
}

BOOL sub_100147E38(uint64_t a1)
{
  return sub_100139FCC(*(void *)(a1 + 32), *(void *)(a1 + 40), *(void *)(a1 + 48), *(CFTypeRef **)(a1 + 56));
}

uint64_t sub_100147E48(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __CFString **a5)
{
  if (*(unsigned char *)(a4 + 44))
  {
    return sub_100012A40(-34020, a5, @"App Clips may not call this API");
  }
  else
  {
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    v6[2] = sub_100147F04;
    v6[3] = &unk_1003041F8;
    v6[4] = a5;
    v6[5] = a1;
    void v6[6] = a2;
    v6[7] = a4;
    v6[8] = a3;
    return sub_10000CBA4(1, 1, 0, (uint64_t)a5, (uint64_t)v6);
  }
}

BOOL sub_100147F04(uint64_t a1, uint64_t a2)
{
  int8x16_t v2 = *(CFTypeRef **)(a1 + 32);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_100147F90;
  void v5[3] = &unk_1003041D8;
  v5[4] = a2;
  long long v6 = *(_OWORD *)(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 64);
  uint64_t v7 = *(void *)(a1 + 56);
  uint64_t v8 = v2;
  uint64_t v9 = v3;
  return sub_1001381F8(a2, 2, v2, (uint64_t)v5);
}

uint64_t sub_100147F90(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  uint64_t v9 = 0;
  CFErrorRef err = 0;
  v33[0] = kSecClassGenericPassword;
  v33[1] = kSecClassInternetPassword;
  v33[2] = kSecClassCertificate;
  v33[3] = kSecClassKey;
  do
  {
    uint64_t v10 = *(void *)(a1 + 32);
    CFStringRef v11 = *(const void **)(a1 + 48);
    uint64_t v12 = *(void *)(a1 + 56);
    CFDictionaryRef v13 = sub_100139704(kCFAllocatorDefault, a2, a3, a4, a5, a6, a7, a8, (uint64_t)kSecClass, v33[v9]);
    uint64_t v14 = sub_10000C3CC(v13, *(const void **)(v12 + 24), -1, v12, (__CFString **)&err);
    CFRelease(v13);
    if (!v14
      || (sub_10000C278(v14, v11),
          BOOL v15 = sub_100139FCC(v10, v14, (uint64_t)v11, (CFTypeRef *)&err),
          (sub_100129708(v14, v15, &err) & 1) == 0))
    {
      CFIndex Code = CFErrorGetCode(err);
      CFErrorRef v17 = err;
      if (Code != -25300)
      {
        if (err)
        {
          CFStringRef v30 = *(CFErrorRef **)(a1 + 64);
          if (v30 && !*v30)
          {
            uint64_t result = 0;
            *CFStringRef v30 = err;
            return result;
          }
          CFRelease(err);
        }
        return 0;
      }
      if (err)
      {
        CFErrorRef err = 0;
        CFRelease(v17);
      }
    }
    ++v9;
  }
  while (v9 != 4);
  CFArrayRef v18 = *(const __CFArray **)(a1 + 72);
  if (v18)
  {
    CFIndex v19 = 0;
    while (v19 < CFArrayGetCount(v18))
    {
      uint64_t v20 = *(void *)(a1 + 32);
      CFIndex v31 = v19;
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 72), v19);
      CFIndex v22 = 0;
      CFArrayRef v23 = *(const __CFArray **)(a1 + 48);
      uint64_t v24 = *(void *)(a1 + 56);
      int v25 = *(__CFString ***)(a1 + 64);
      while (v22 < CFArrayGetCount(v23))
      {
        uint64_t result = sub_10000C3CC(ValueAtIndex, *(const void **)(v24 + 24), 0, v24, v25);
        if (!result) {
          return result;
        }
        CFStringRef v27 = (uint64_t *)result;
        CFBooleanRef v28 = (const __CFBoolean *)CFArrayGetValueAtIndex(v23, v22);
        sub_10000DF34(kSecAttrAccessGroup, v28, (uint64_t)v27);
        sub_100129654(v27, v28);
        if (v27[5])
        {
          int v29 = 0;
        }
        else
        {
          sub_1001397F8((CFDictionaryRef *)v27);
          int v29 = sub_100138A0C(v20, (uint64_t)v27, 0, v25);
        }
        ++v22;
        if ((sub_100129708((uint64_t)v27, v29, (CFErrorRef *)v25) & 1) == 0) {
          return 0;
        }
      }
      CFIndex v19 = v31 + 1;
      CFArrayRef v18 = *(const __CFArray **)(a1 + 72);
    }
  }
  return 1;
}

uint64_t sub_10014824C(uint64_t a1)
{
  int8x16_t v2 = sub_10000B070("SecError");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v4[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SecItemServerDeleteAll", (uint8_t *)v4, 2u);
  }
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_100148318;
  v4[3] = &unk_100304BB0;
  void v4[4] = a1;
  return sub_10000CBA4(1, 1, 0, a1, (uint64_t)v4);
}

uint64_t sub_100148318(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(CFTypeRef **)(a1 + 32);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = sub_1001483B8;
  v6[3] = &unk_100304B90;
  v6[4] = a2;
  v6[5] = v4;
  uint64_t result = sub_1001381F8(a2, 2, v4, (uint64_t)v6);
  if (result) {
    return sub_100026908(a2, @"VACUUM;", *(CFTypeRef **)(a1 + 32));
  }
  return result;
}

uint64_t sub_1001483B8(uint64_t a1)
{
  int v2 = sub_100026908(*(void *)(a1 + 32), @"DELETE FROM genp WHERE sync=1;", *(CFTypeRef **)(a1 + 40));
  int v3 = v2 & sub_100026908(*(void *)(a1 + 32), @"DELETE FROM inet WHERE sync=1;", *(CFTypeRef **)(a1 + 40));
  int v4 = sub_100026908(*(void *)(a1 + 32), @"DELETE FROM cert WHERE sync=1;", *(CFTypeRef **)(a1 + 40));
  int v5 = v3 & v4 & sub_100026908(*(void *)(a1 + 32), @"DELETE FROM keys WHERE sync=1;", *(CFTypeRef **)(a1 + 40));
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008);
  LODWORD(v6) = sub_10014850C(v6, v7, *(const void ***)(a1 + 40));
  uint64_t v8 = *(void *)(a1 + 32);
  uint64_t v9 = sub_10000C75C(@"inet", &qword_10035D020, (uint64_t)&unk_10035D018);
  LODWORD(v8) = v6 & sub_10014850C(v8, v9, *(const void ***)(a1 + 40));
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = sub_10000C75C(@"cert", &qword_10035D030, (uint64_t)&unk_10035D028);
  LODWORD(v8) = v5 & v8 & sub_10014850C(v10, v11, *(const void ***)(a1 + 40));
  uint64_t v12 = *(void *)(a1 + 32);
  uint64_t v13 = sub_10000C75C(@"keys", &qword_10035D040, (uint64_t)&unk_10035D038);
  return v8 & sub_10014850C(v12, v13, *(const void ***)(a1 + 40));
}

BOOL sub_10014850C(uint64_t a1, uint64_t a2, const void **a3)
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDictionaryAddValue(Mutable, kSecMatchLimit, kSecMatchLimitAll);
  uint64_t v16 = 0;
  CFErrorRef v17 = (CFTypeRef *)&v16;
  uint64_t v18 = 0x2000000000;
  CFIndex v19 = 0;
  uint64_t v7 = (CFDictionaryRef *)sub_10000C7F0(a2, 0, Mutable, 0, &v19);
  if (!v7)
  {
    uint64_t v13 = sub_10000B070("SecError");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      CFTypeRef v14 = v17[3];
      *(_DWORD *)buf = 138412290;
      CFTypeRef v21 = v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "SecItemServerDeleteAll: aborting because failed to initialize Query: %@", buf, 0xCu);
    }
    abort();
  }
  uint64_t v8 = (const void **)v7;
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000;
  v15[2] = sub_100148724;
  v15[3] = &unk_100304C18;
  v15[5] = a2;
  v15[6] = a1;
  v15[4] = &v16;
  sub_10011C750(v7, a1, v17 + 3, &stru_100304BF0, 0, 0, 0, (uint64_t)v15);
  sub_10000C2C4(v8, (CFErrorRef *)v17 + 3);
  CFTypeRef v9 = v17[3];
  if (v9)
  {
    if (a3)
    {
      uint64_t v10 = *a3;
      CFTypeRef v11 = v17[3];
      if (*a3)
      {
        *a3 = 0;
        CFRelease(v10);
        CFTypeRef v11 = v17[3];
      }
      *a3 = v11;
    }
    else
    {
      v17[3] = 0;
      CFRelease(v9);
    }
  }
  _Block_object_dispose(&v16, 8);
  return v9 == 0;
}

uint64_t sub_100148724(void *a1, uint64_t a2)
{
  uint64_t result = sub_10013A508(*(const __CFDictionary **)(a2 + 48), a1[5], 0);
  if ((result & 1) == 0)
  {
    CFStringRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 48), kSecAttrAccessGroup);
    uint64_t result = CFEqual(Value, @"com.apple.bluetooth");
    if (!result)
    {
      uint64_t v6 = a1[6];
      uint64_t v7 = (CFTypeRef *)(*(void *)(a1[4] + 8) + 24);
      return (uint64_t)sub_10011ED78((CFStringRef **)a2, v6, kCFBooleanFalse, 0, v7);
    }
  }
  return result;
}

BOOL sub_1001487C0(id a1, const SecDbAttr *a2)
{
  return (a2->var2 & 2) != 0 && CFEqual(a2->var0, @"data") == 0;
}

uint64_t sub_1001487FC(const void *a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v15 = 0;
  uint64_t v16 = &v15;
  uint64_t v17 = 0x2000000000;
  char v18 = 1;
  if (qword_10035D0E8 != -1) {
    dispatch_once(&qword_10035D0E8, &stru_100304238);
  }
  v19[0] = sub_10000C75C(@"inet", &qword_10035D020, (uint64_t)&unk_10035D018);
  v19[1] = sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008);
  v19[2] = sub_10000C75C(@"keys", &qword_10035D040, (uint64_t)&unk_10035D038);
  v19[3] = sub_10000C75C(@"cert", &qword_10035D030, (uint64_t)&unk_10035D028);
  if (a1)
  {
    CFTypeID v7 = CFGetTypeID(a1);
    if (v7 == CFArrayGetTypeID())
    {
      if (CFArrayGetCount((CFArrayRef)a1))
      {
        context[0] = _NSConcreteStackBlock;
        context[1] = 0x40000000;
        context[2] = sub_100148AD0;
        context[3] = &unk_100304280;
        context[4] = &v15;
        context[5] = a3;
        context[6] = a1;
        v20.length = CFArrayGetCount((CFArrayRef)a1);
        v20.location = 0;
        CFArrayApplyFunction((CFArrayRef)a1, v20, (CFArrayApplierFunction)sub_10013FC68, context);
        if (*((unsigned char *)v16 + 24))
        {
          v13[0] = _NSConcreteStackBlock;
          v13[1] = 0x40000000;
          v13[2] = sub_100148B9C;
          v13[3] = &unk_1003042C0;
          void v13[4] = a3;
          v13[5] = v19;
          v13[6] = a2;
          v13[7] = a1;
          char v10 = sub_10000CBA4(1, 1, 0, (uint64_t)a3, (uint64_t)v13);
          *((unsigned char *)v16 + 24) = v10;
        }
      }
      else
      {
        *((unsigned char *)v16 + 24) = 0;
        sub_1000297A0(1, @"com.apple.security.xpc", 0, a3, v9, @"accessGroups e empty");
      }
    }
    else
    {
      *((unsigned char *)v16 + 24) = 0;
      sub_1000297A0(1, @"com.apple.security.xpc", 0, a3, v8, @"accessGroups not CFArray, got %@", a1);
    }
  }
  else
  {
    *((unsigned char *)v16 + 24) = 0;
    sub_1000297A0(1, @"com.apple.security.xpc", 0, a3, v6, @"accessGroups not CFArray, got %@", 0);
  }
  uint64_t v11 = *((unsigned __int8 *)v16 + 24);
  _Block_object_dispose(&v15, 8);
  return v11;
}

void sub_100148AD0(uint64_t a1, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (cf)
  {
    CFTypeID v7 = CFGetTypeID(cf);
    if (v7 == CFStringGetTypeID())
    {
      if (!CFSetContainsValue((CFSetRef)qword_10035D0F0, cf)) {
        return;
      }
      sub_1000297A0(1, @"com.apple.security.xpc", 0, *(CFTypeRef **)(a1 + 40), v9, @"illegal access group: %@", *(void *)(a1 + 48));
    }
    else
    {
      sub_1000297A0(1, @"com.apple.security.xpc", 0, *(CFTypeRef **)(a1 + 40), v8, @"access not a string: %@", cf);
    }
  }
  else
  {
    sub_1000297A0(1, @"com.apple.security.xpc", 0, *(CFTypeRef **)(a1 + 40), a5, @"access not a string: %@", 0);
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
}

uint64_t sub_100148B9C(uint64_t a1, uint64_t a2)
{
  int v4 = *(CFTypeRef **)(a1 + 32);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = sub_100148C4C;
  v6[3] = &unk_1003042A0;
  long long v7 = *(_OWORD *)(a1 + 40);
  uint64_t v8 = v4;
  uint64_t v9 = a2;
  uint64_t v10 = *(void *)(a1 + 56);
  uint64_t result = sub_1001381F8(a2, 2, v4, (uint64_t)v6);
  if (result) {
    return sub_100026908(a2, @"VACUUM", *(CFTypeRef **)(a1 + 32));
  }
  return result;
}

uint64_t sub_100148C4C(uint64_t a1)
{
  uint64_t v2 = 0;
  CFTypeRef cf = 0;
  do
  {
    int v3 = (const void **)sub_10000C7F0(*(void *)(*(void *)(a1 + 32) + v2), *(const void **)(*(void *)(a1 + 40) + 24), 0, *(void *)(a1 + 40), *(__CFString ***)(a1 + 48));
    if (v3)
    {
      int v4 = v3;
      sub_100139FCC(*(void *)(a1 + 56), (uint64_t)v3, *(void *)(a1 + 64), &cf);
      int v5 = *(CFErrorRef **)(a1 + 48);
      int v3 = v4;
    }
    else
    {
      int v5 = *(CFErrorRef **)(a1 + 48);
    }
    sub_10000C2C4(v3, v5);
    CFTypeRef v6 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v6);
    }
    v2 += 8;
  }
  while (v2 != 32);
  return 1;
}

void sub_100148CEC(id a1)
{
  v1[0] = *(_OWORD *)off_100304258;
  v1[1] = *(_OWORD *)off_100304268;
  qword_10035D0F0 = (uint64_t)CFSetCreate(0, (const void **)v1, 4, &kCFTypeSetCallBacks);
}

BOOL sub_100148D64(const __CFDictionary *a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t *a6, __CFString **a7)
{
  long long v93 = 0u;
  long long v94 = 0u;
  long long v91 = 0u;
  long long v92 = 0u;
  uint64_t v13 = (void *)CFDictionaryGetValue(a1, kSecAttrServer);
  CFTypeRef v14 = v13;
  if (v13) {
    CFRetain(v13);
  }
  value = (void *)CFDictionaryGetValue(a1, kSecAttrAccount);
  CFStringRef v15 = (const __CFString *)CFDictionaryGetValue(a1, kSecSharedPassword);
  values = @"*";
  *(void *)buf = 0;
  xpc_object_t v16 = sub_1001D81A0(7u, (CFTypeRef *)buf);
  CFStringRef v83 = v15;
  if (v16)
  {
    uint64_t v17 = v16;
    xpc_dictionary_set_data(v16, "client", a3, 0x20uLL);
    xpc_object_t v18 = sub_1001D7F5C(v17, (CFTypeRef *)buf);
    if (v18)
    {
      CFIndex v19 = v18;
      BOOL v20 = sub_1001D8220(v18, (__CFString **)buf) > 0;
      xpc_release(v19);
    }
    else
    {
      BOOL v20 = 0;
    }
    xpc_release(v17);
  }
  else
  {
    BOOL v20 = 0;
  }
  if (*(void *)buf) {
    CFRelease(*(CFTypeRef *)buf);
  }
  if (!v20)
  {
    sub_100012A40(-909, a7, @"Password AutoFill for iCloud Keychain must be enabled in Settings > Passwords to save passwords");
    goto LABEL_41;
  }
  if (!v14)
  {
    if (value)
    {
LABEL_39:
      sub_100012A40(-50, a7, @"No domain provided");
      BOOL v43 = 0;
      CFTypeRef v14 = 0;
      goto LABEL_42;
    }
    CFTypeRef v14 = 0;
LABEL_40:
    sub_100012A40(-50, a7, @"No account provided");
    goto LABEL_41;
  }
  v81 = a3;
  uint64_t v82 = a4;
  *(void *)buf = v14;
  CFIndex v22 = +[NSArray arrayWithObjects:buf count:1];
  CFArrayRef v23 = +[_SWCServiceSpecifier serviceSpecifiersWithEntitlementValue:v22 error:0];
  id v24 = [v23 firstObject];

  if (v24
    || (id v24 = [objc_alloc((Class)_SWCServiceSpecifier) initWithServiceType:0 applicationIdentifier:0 domain:v14]) != 0)
  {
    id v25 = v24;

    CFRelease(v14);
    id v26 = v25;
    CFTypeRef v14 = [v26 domainHost];

    CFStringRef v27 = [v26 domainPort];
    CFBooleanRef v28 = v27;
    uint64_t v29 = v82;
    if (v27) {
      unsigned int v85 = [v27 unsignedShortValue];
    }
    else {
      unsigned int v85 = -1;
    }

    if (v14) {
      CFRetain(v14);
    }
    CFRelease(v26);
  }
  else
  {
    unsigned int v85 = -1;
    uint64_t v29 = v82;
  }
  if (!value) {
    goto LABEL_40;
  }
  if (!v14) {
    goto LABEL_39;
  }
  if (!v29)
  {
    sub_100012A40(-34018, a7, @"Missing application-identifier entitlement");
    goto LABEL_41;
  }
  v78 = a6;
  v80 = a7;
  uint64_t v77 = _SWCServiceTypeWebCredentials;
  +[_SWCServiceSpecifier serviceSpecifiersWithEntitlementValue:serviceType:error:](_SWCServiceSpecifier, "serviceSpecifiersWithEntitlementValue:serviceType:error:", a5);
  long long v95 = 0u;
  long long v96 = 0u;
  long long v97 = 0u;
  long long v98 = 0u;
  id v30 = (id)objc_claimAutoreleasedReturnValue();
  id v31 = [v30 countByEnumeratingWithState:&v95 objects:buf count:16];
  uint64_t v32 = v85;
  if (!v31) {
    goto LABEL_37;
  }
  id v33 = v31;
  uint64_t v34 = *(void *)v96;
  while (2)
  {
    for (CFIndex i = 0; i != v33; CFIndex i = (char *)i + 1)
    {
      if (*(void *)v96 != v34) {
        objc_enumerationMutation(v30);
      }
      CFStringRef v36 = *(void **)(*((void *)&v95 + 1) + 8 * i);
      CFStringRef v37 = [v36 domainHost];
      if (![v37 caseInsensitiveCompare:v14])
      {
        if ((v32 & 0x80000000) != 0) {
          goto LABEL_47;
        }
        __int16 v38 = [v36 domainPort];
        CFStringRef v39 = +[NSNumber numberWithInt:v32];
        unsigned __int8 v40 = [v38 isEqualToNumber:v39];

        uint64_t v32 = v85;
        if (v40)
        {
LABEL_47:

          uint64_t v46 = sub_10000B070("swc");
          if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412546;
            *(void *)&uint8_t buf[4] = v82;
            __int16 v100 = 2112;
            v101 = v14;
            _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "Application %@ is requesting approval for %@", buf, 0x16u);
          }

          id v47 = [objc_alloc((Class)_SWCServiceSpecifier) initWithServiceType:v77 applicationIdentifier:v82 domain:v14];
          *(void *)&long long v95 = 0;
          uint64_t v48 = +[_SWCServiceDetails serviceDetailsWithServiceSpecifier:v47 error:&v95];
          id v49 = (id)v95;
          if (v48)
          {
            uint64_t v50 = [v48 firstObject];
            char v51 = v50;
            if (v50)
            {
              unsigned int v52 = [v50 userApprovalState];
              if (v52 == 1) {
                char v53 = 1;
              }
              else {
                char v53 = 2 * (v52 == 2);
              }
              unsigned int v54 = [v51 siteApprovalState];
              char v55 = v53 | 4;
              if (v54 != 1) {
                char v55 = v53;
              }
              if (v54 == 2) {
                char v56 = v53 | 8;
              }
              else {
                char v56 = v55;
              }
LABEL_64:

              int v57 = v56 & 4;
              if (v80)
              {
                if ((v56 & 4) != 0)
                {
                  if ((v56 & 2) == 0) {
                    goto LABEL_70;
                  }
                  int v57 = 1;
                  sub_100012A40(-25293, v80, @"User denied access to \"%@\" by \"%@\"", v14, v82);
                }
                else
                {
                  sub_100012A40(-25293, v80, @"\"%@\" failed to approve \"%@\"", v14, v82);
                }
              }
              if (!v57) {
                goto LABEL_41;
              }
LABEL_70:
              *(void *)&long long v91 = 0;
              *((void *)&v91 + 1) = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
              *((void *)&v92 + 1) = *(void *)(a2 + 24);
              LOWORD(v92) = 0;
              BYTE2(v92) = 0;
              CFMutableArrayRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
              if (!Mutable)
              {
                sub_100012A40(-108, v80, @"Unable to create query dictionary");
                goto LABEL_41;
              }
              v59 = Mutable;
              CFDictionaryAddValue(Mutable, kSecClass, kSecClassInternetPassword);
              CFDictionaryAddValue(v59, kSecAttrAccessGroup, @"com.apple.cfnetwork");
              CFDictionaryAddValue(v59, kSecAttrAuthenticationType, kSecAttrAuthenticationTypeHTMLForm);
              CFDictionaryAddValue(v59, kSecAttrServer, v14);
              CFDictionaryAddValue(v59, kSecAttrSynchronizable, kCFBooleanTrue);
              CFDictionarySetValue(v59, kSecAttrAccount, @"Passwordsnotsaved");
              BOOL v60 = sub_10000BA20(v59, (uint64_t)&v91, v78, v80);
              if (v78)
              {
                v61 = (const void *)*v78;
                if (*v78)
                {
                  uint64_t *v78 = 0;
                  CFRelease(v61);
                }
              }
              if (v80)
              {
                v62 = *v80;
                if (*v80)
                {
                  *v80 = 0;
                  CFRelease(v62);
                }
              }
              if (v60)
              {
                sub_100012A40(-25299, v80, @"Item already exists for this server");
              }
              else
              {
                CFDictionarySetValue(v59, kSecAttrAccount, value);
                if (v85 - 1 <= 0xFFFFFFFD)
                {
                  *(_WORD *)buf = v85;
                  CFNumberRef v63 = CFNumberCreate(0, kCFNumberSInt16Type, buf);
                  CFDictionaryAddValue(v59, kSecAttrPort, v63);
                  if (v63) {
                    CFRelease(v63);
                  }
                }
                CFDictionaryAddValue(v59, kSecReturnData, kCFBooleanTrue);
                BOOL v64 = sub_10000BA20(v59, (uint64_t)&v91, v78, v80);
                CFDictionaryRemoveValue(v59, kSecReturnData);
                if (v64)
                {
                  if (v83)
                  {
                    v65 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                    CFDataRef ExternalRepresentation = CFStringCreateExternalRepresentation(kCFAllocatorDefault, v83, 0x8000100u, 0);
                    CFDictionaryAddValue(v65, kSecValueData, ExternalRepresentation);
                    BOOL v67 = v78 && *v78 && CFEqual((CFTypeRef)*v78, ExternalRepresentation) != 0;
                    if (ExternalRepresentation) {
                      CFRelease(ExternalRepresentation);
                    }
                    CFDictionaryAddValue(v65, kSecAttrComment, @"default");
                    BOOL v43 = (v67
                        || (v89[0] = _NSConcreteStackBlock,
                            v89[1] = 0x40000000,
                            v89[2] = sub_100149A3C,
                            v89[3] = &unk_1003042E8,
                            v89[4] = a2,
                            v89[5] = v82,
                            sub_1001D8470(1u, v81, v59, (CFTypeRef *)v80, (uint64_t)v89)))
                       && sub_10014712C(v59, v65, (uint64_t)&v91, v80);
                  }
                  else
                  {
                    v88[0] = _NSConcreteStackBlock;
                    v88[1] = 0x40000000;
                    v88[2] = sub_100149A58;
                    v88[3] = &unk_100304308;
                    v88[4] = a2;
                    v88[5] = v82;
                    BOOL v43 = sub_1001D8470(2u, v81, v59, (CFTypeRef *)v80, (uint64_t)v88)
                       && sub_1001479D0(v59, (uint64_t)&v91, v80);
                    v65 = 0;
                  }
                  if (v78)
                  {
                    v75 = (const void *)*v78;
                    if (*v78)
                    {
                      uint64_t *v78 = 0;
                      CFRelease(v75);
                    }
                  }
                  if (v80)
                  {
                    v76 = *v80;
                    if (*v80)
                    {
                      *v80 = 0;
                      CFRelease(v76);
                    }
                  }
                  if (v65) {
                    CFRelease(v65);
                  }
                  goto LABEL_127;
                }
                if (v78)
                {
                  v68 = (const void *)*v78;
                  if (*v78)
                  {
                    uint64_t *v78 = 0;
                    CFRelease(v68);
                  }
                }
                if (v80)
                {
                  v69 = *v80;
                  if (*v80)
                  {
                    *v80 = 0;
                    CFRelease(v69);
                  }
                }
                if (v83)
                {
                  CFStringRef v70 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@ (%@)", v14, value);
                  if (v70)
                  {
                    CFStringRef v71 = v70;
                    CFDictionaryAddValue(v59, kSecAttrLabel, v70);
                    CFRelease(v71);
                  }
                  CFDictionaryAddValue(v59, kSecAttrProtocol, kSecAttrProtocolHTTPS);
                  CFDataRef v72 = CFStringCreateExternalRepresentation(kCFAllocatorDefault, v83, 0x8000100u, 0);
                  CFDictionarySetValue(v59, kSecValueData, v72);
                  if (v72) {
                    CFRelease(v72);
                  }
                  CFDictionarySetValue(v59, kSecAttrComment, @"default");
                  if (*((void *)&v91 + 1)) {
                    CFRelease(*((CFTypeRef *)&v91 + 1));
                  }
                  *((void *)&v91 + 1) = CFArrayCreate(kCFAllocatorDefault, (const void **)&off_1003042E0, 1, &kCFTypeArrayCallBacks);
                  *(_DWORD *)buf = 1937204065;
                  CFNumberRef v73 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, buf);
                  if (v73)
                  {
                    CFNumberRef v74 = v73;
                    CFDictionarySetValue(v59, kSecAttrCreator, v73);
                    CFRelease(v74);
                  }
                  v87[0] = _NSConcreteStackBlock;
                  v87[1] = 0x40000000;
                  v87[2] = sub_100149A74;
                  v87[3] = &unk_100304328;
                  v87[4] = a2;
                  v87[5] = v82;
                  BOOL v43 = 0;
                  if (sub_1001D8470(0, v81, v59, (CFTypeRef *)v80, (uint64_t)v87)) {
                    BOOL v43 = sub_100145928(v59, (uint64_t)&v91, (uint64_t)v78, v80);
                  }
                  goto LABEL_127;
                }
              }
              BOOL v43 = 1;
LABEL_127:
              CFRelease(v59);
              goto LABEL_42;
            }
          }
          else
          {
            char v51 = sub_10000B070("SecError");
            if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 138412290;
              *(void *)&uint8_t buf[4] = v49;
              _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "+[_SWCServiceDetails serviceDetailsWithServiceSpecifier:error:] failed with %@", buf, 0xCu);
            }
          }
          char v56 = 0;
          goto LABEL_64;
        }
      }
    }
    id v33 = [v30 countByEnumeratingWithState:&v95 objects:buf count:16];
    if (v33) {
      continue;
    }
    break;
  }
LABEL_37:

  CFStringRef v41 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@ not found in %@ entitlement", v14, @"com.apple.developer.associated-domains");
  if (v41)
  {
    CFTypeRef v42 = v41;
    sub_100012A40(-34018, v80, @"%@", v41);
    goto LABEL_82;
  }
  CFTypeRef v42 = CFRetain(@"Requested domain not found in entitlement");
  sub_100012A40(-34018, v80, @"%@", v42);
  if (v42) {
LABEL_82:
  }
    CFRelease(v42);
LABEL_41:
  BOOL v43 = 0;
LABEL_42:
  if (*((void *)&v91 + 1)) {
    CFRelease(*((CFTypeRef *)&v91 + 1));
  }
  if (v14) {
    CFRelease(v14);
  }
  return v43;
}

void sub_100149A3C(uint64_t a1, uint64_t a2)
{
  if (a2) {
    sub_10012F098(*(void *)(a1 + 40), a2, kCFBooleanFalse);
  }
}

void sub_100149A58(uint64_t a1, uint64_t a2)
{
  if (a2) {
    sub_10012F098(*(void *)(a1 + 40), a2, kCFBooleanFalse);
  }
}

void sub_100149A74(uint64_t a1, uint64_t a2)
{
  if (a2) {
    sub_10012F098(*(void *)(a1 + 40), a2, kCFBooleanFalse);
  }
}

uint64_t sub_100149A90(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t *a5)
{
  uint64_t v13 = 0;
  CFTypeRef v14 = &v13;
  uint64_t v15 = 0x2000000000;
  uint64_t v16 = 0;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  v11[2] = sub_100149C30;
  v11[3] = &unk_100304378;
  char v12 = a4;
  void v11[6] = a3;
  v11[7] = a5;
  v11[4] = &v13;
  v11[5] = a2;
  v11[8] = a1;
  sub_10000CBA4(0, 1, 0, (uint64_t)a5, (uint64_t)v11);
  CFTypeRef v6 = sub_10000B070("SecServerKeychainCreateBackup");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (v14[3]) {
      long long v7 = "success";
    }
    else {
      long long v7 = "fail";
    }
    if (a5) {
      uint64_t v8 = *a5;
    }
    else {
      uint64_t v8 = 0;
    }
    *(_DWORD *)buf = 136315394;
    xpc_object_t v18 = v7;
    __int16 v19 = 2112;
    uint64_t v20 = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Backup result: %s (%@)", buf, 0x16u);
  }
  LKABackupReportEnd();
  uint64_t v9 = v14[3];
  _Block_object_dispose(&v13, 8);
  return v9;
}

BOOL sub_100149C30(uint64_t a1, uint64_t a2)
{
  LKABackupReportStart();
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_100149CF4;
  v7[3] = &unk_100304350;
  char v12 = *(unsigned char *)(a1 + 72);
  uint64_t v4 = *(void *)(a1 + 48);
  long long v8 = *(_OWORD *)(a1 + 32);
  uint64_t v9 = v4;
  uint64_t v10 = a2;
  int8x16_t v5 = *(int8x16_t *)(a1 + 56);
  int8x16_t v11 = vextq_s8(v5, v5, 8uLL);
  return sub_1001381F8(a2, 3, (CFTypeRef *)v5.i64[0], (uint64_t)v7);
}

BOOL sub_100149CF4(uint64_t a1)
{
  uint64_t v2 = sub_10000B070("SecServerKeychainCreateBackup");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    if (*(void *)(a1 + 40)) {
      int v3 = "provided";
    }
    else {
      int v3 = "device";
    }
    uint64_t v4 = ", EMCS mode";
    if (!*(unsigned char *)(a1 + 80)) {
      uint64_t v4 = "";
    }
    *(_DWORD *)buf = 136315394;
    *(void *)&uint8_t buf[4] = v3;
    __int16 v19 = 2080;
    uint64_t v20 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Performing backup from %s keybag%s", buf, 0x16u);
  }
  uint64_t v5 = *(void *)(a1 + 56);
  uint64_t v6 = *(void *)(a1 + 64);
  if (*(_OWORD *)(a1 + 40) == 0)
  {
    CFDataRef v7 = sub_100149FDC(*(void *)(a1 + 56), *(void *)(a1 + 64), 0, *(__CFString ***)(a1 + 72));
    goto LABEL_24;
  }
  int v8 = *(unsigned __int8 *)(a1 + 80);
  uint64_t v9 = *(CFTypeRef **)(a1 + 72);
  int v16 = -1431655766;
  kdebug_trace();
  *(void *)buf = 0;
  uint64_t v10 = MKBKeyBagCreateWithData();
  if (!v10)
  {
    if (v8)
    {
      char v12 = sub_10000B070("keychainbackup");
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v17 = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "skipping keybag unlock for EMCS", v17, 2u);
      }
    }
    else
    {
      uint64_t v13 = MKBKeyBagUnlock();
      if (v13)
      {
        uint64_t v14 = v13;
        CFRelease(*(CFTypeRef *)buf);
        if (sub_100029664(v14, v9, @"failed to unlock bag: %d", v14)) {
          goto LABEL_12;
        }
LABEL_18:
        kdebug_trace();
        CFDataRef v7 = 0;
        goto LABEL_24;
      }
    }
    int8x16_t v11 = *(const void **)buf;
    goto LABEL_20;
  }
  if (!sub_100029664(v10, v9, @"MKBKeyBagCreateWithData failed: %d", v10)) {
    goto LABEL_18;
  }
LABEL_12:
  int8x16_t v11 = 0;
LABEL_20:
  if (MKBKeyBagGetAKSHandle())
  {
    CFDataRef v7 = 0;
  }
  else
  {
    kdebug_trace();
    kdebug_trace();
    CFDataRef v7 = sub_100149FDC(v5, v6, &v16, (__CFString **)v9);
  }
  kdebug_trace();
  if (v11) {
    CFRelease(v11);
  }
LABEL_24:
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v7;
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

CFDataRef sub_100149FDC(uint64_t a1, uint64_t a2, int *a3, __CFString **a4)
{
  kdebug_trace();
  int v8 = sub_10013B9EC(a1, a2, a3, 2, a4);
  if (v8)
  {
    uint64_t v9 = v8;
    CFDataRef Data = CFPropertyListCreateData(kCFAllocatorDefault, v8, kCFPropertyListBinaryFormat_v1_0, 0, (CFErrorRef *)a4);
    CFRelease(v9);
  }
  else
  {
    CFDataRef Data = 0;
  }
  kdebug_trace();
  return Data;
}

uint64_t sub_10014A0AC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __CFString **a5)
{
  if (a1 && a3)
  {
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 0x40000000;
    v7[2] = sub_10014A16C;
    v7[3] = &unk_100304398;
    void v7[4] = a2;
    v7[5] = a1;
    v7[6] = a3;
    v7[7] = a4;
    v7[8] = a5;
    uint64_t result = sub_10000CBA4(1, 1, 0, (uint64_t)a5, (uint64_t)v7);
    if (result)
    {
      sub_10013F0C8();
      sub_10013F064();
      return 1;
    }
  }
  else
  {
    return sub_100012A40(-50, a5, @"backup or keybag missing");
  }
  return result;
}

uint64_t sub_10014A16C(void *a1, uint64_t a2)
{
  uint64_t v3 = a1[4];
  uint64_t v4 = a1[5];
  CFDataRef v6 = (const __CFData *)a1[6];
  CFDataRef v5 = (const __CFData *)a1[7];
  CFDataRef v7 = (CFTypeRef *)a1[8];
  int v25 = -1;
  *(void *)&long long v8 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v8 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v26[2] = v8;
  v26[3] = v8;
  v26[0] = v8;
  v26[1] = v8;
  uint64_t v9 = sub_10000B070("SecServerKeychainRestore");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Restoring keychain backup", (uint8_t *)&buf, 2u);
  }
  kdebug_trace();
  BytePtr = CFDataGetBytePtr(v6);
  CFIndex Length = CFDataGetLength(v6);
  if (v5)
  {
    char v12 = CFDataGetBytePtr(v5);
    CFIndex v13 = CFDataGetLength(v5);
  }
  else
  {
    char v12 = 0;
    CFIndex v13 = 0;
  }
  uint64_t v14 = sub_10001B6A8(BytePtr, Length, (uint64_t)v12, v13, &v25, v26);
  if (v14)
  {
    uint64_t v15 = v14;
    int v16 = sub_10000B070("SecWarning");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 67109120;
      DWORD1(buf) = v15;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "SecServerKeychainRestore: aks_kc_backup_open_keybag failed: %d", (uint8_t *)&buf, 8u);
    }
    if (v7) {
      sub_100029664(v15, v7, @"aks_kc_backup_open_keybag failed: %d", v15);
    }
    kdebug_trace();
LABEL_20:
    CFIndex v22 = sub_10000B070("SecWarning");
    BOOL v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (v23)
    {
      if (v7) {
        CFTypeRef v24 = *v7;
      }
      else {
        CFTypeRef v24 = 0;
      }
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v24;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "SecServerKeychainRestore: Restore failed with: %@", (uint8_t *)&buf, 0xCu);
      return 0;
    }
    return result;
  }
  uint64_t v17 = sub_10000B070("SecServerKeychainRestore");
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 67109120;
    DWORD1(buf) = v25;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "aks_kc_backup_open_keybag got backup_keybag:%d", (uint8_t *)&buf, 8u);
  }
  kdebug_trace();
  kdebug_trace();
  xpc_object_t v18 = v26;
  *(void *)&long long buf = _NSConcreteStackBlock;
  if (v25 != -1) {
    xpc_object_t v18 = 0;
  }
  *((void *)&buf + 1) = 0x40000000;
  CFBooleanRef v28 = sub_10014A534;
  uint64_t v29 = &unk_100304C38;
  uint64_t v30 = v4;
  id v31 = v7;
  uint64_t v32 = a2;
  uint64_t v33 = v3;
  uint64_t v34 = v18;
  int v35 = v25;
  int v36 = dword_10035D2B0;
  BOOL v19 = sub_1001381F8(a2, 2, v7, (uint64_t)&buf);
  kdebug_trace();
  if (!v19) {
    goto LABEL_20;
  }
  uint64_t v20 = sub_10000B070("SecServerKeychainRestore");
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Restore completed successfully", (uint8_t *)&buf, 2u);
  }
  return 1;
}

BOOL sub_10014A534(uint64_t a1)
{
  kdebug_trace();
  CFDictionaryRef v2 = (const __CFDictionary *)CFPropertyListCreateWithData(kCFAllocatorDefault, *(CFDataRef *)(a1 + 32), 0, 0, *(CFErrorRef **)(a1 + 40));
  if (v2)
  {
    CFDictionaryRef v3 = v2;
    CFTypeID v4 = CFGetTypeID(v2);
    if (v4 == CFDictionaryGetTypeID()) {
      BOOL v5 = sub_10013C868(*(void *)(a1 + 48), *(void *)(a1 + 56), *(_DWORD *)(a1 + 72), *(void *)(a1 + 64), *(_DWORD *)(a1 + 76), v3, 2, 0, *(__CFString ***)(a1 + 40));
    }
    else {
      BOOL v5 = sub_100012A40(-50, *(__CFString ***)(a1 + 40), @"import: keychain is not a dictionary");
    }
    BOOL v6 = v5;
    CFRelease(v3);
  }
  else
  {
    BOOL v6 = 0;
  }
  kdebug_trace();
  return v6;
}

const void *sub_10014A628(CFDataRef data, CFErrorRef *error)
{
  CFDictionaryRef v3 = (const __CFDictionary *)CFPropertyListCreateWithData(kCFAllocatorDefault, data, 0, 0, error);
  if (v3)
  {
    CFDictionaryRef v4 = v3;
    CFTypeID v5 = CFGetTypeID(v3);
    if (v5 == CFDictionaryGetTypeID())
    {
      CFStringRef Value = CFDictionaryGetValue(v4, @"keybag-uuid");
      if (Value)
      {
        CFDataRef v7 = Value;
        CFTypeID v8 = CFGetTypeID(Value);
        if (v8 == CFStringGetTypeID())
        {
          CFRetain(v7);
LABEL_9:
          CFRelease(v4);
          return v7;
        }
      }
      sub_100012A40(-26275, (__CFString **)error, @"Missing or invalid %@ in backup dictionary", @"keybag-uuid");
    }
    CFDataRef v7 = 0;
    goto LABEL_9;
  }
  return 0;
}

uint64_t sub_10014A708()
{
  v0 = _OctagonSignpostLogSystem();
  os_signpost_id_t v1 = _OctagonSignpostCreate();

  CFDictionaryRef v2 = _OctagonSignpostLogSystem();
  CFDictionaryRef v3 = v2;
  if (v1 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    LOWORD(v13) = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v3, OS_SIGNPOST_INTERVAL_BEGIN, v1, "SOSCCHandleUpdateMessage", " enableTelemetry=YES ", (uint8_t *)&v13, 2u);
  }

  CFDictionaryRef v4 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = 134217984;
    os_signpost_id_t v14 = v1;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCHandleUpdateMessage  enableTelemetry=YES ", (uint8_t *)&v13, 0xCu);
  }

  CFTypeID v5 = sub_10021C7D8();
  if (v5) {
    uint64_t updated = SOSCloudKeychainHandleUpdateMessage();
  }
  else {
    uint64_t updated = (uint64_t)CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  }
  uint64_t v7 = updated;
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  uint64_t v9 = _OctagonSignpostLogSystem();
  uint64_t v10 = v9;
  if (v1 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    int v13 = 67240192;
    LODWORD(v14) = v7 != 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v10, OS_SIGNPOST_INTERVAL_END, v1, "SOSCCHandleUpdateMessage", " SOSSignpostNameSOSCCHandleUpdateMessage=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCHandleUpdateMessage}d ", (uint8_t *)&v13, 8u);
  }

  int8x16_t v11 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = 134218496;
    os_signpost_id_t v14 = v1;
    __int16 v15 = 2048;
    double v16 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v17 = 1026;
    BOOL v18 = v7 != 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCHandleUpdateMessage  SOSSignpostNameSOSCCHandleUpdateMessage=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCHandleUpdateMessage}d ", (uint8_t *)&v13, 0x1Cu);
  }

  return v7;
}

uint64_t sub_10014A974(const void *a1, CFTypeRef cf, const void *a3, __CFString **a4)
{
  if (!cf)
  {
    CFTypeRef v36 = 0;
LABEL_57:
    sub_100012A40(-50, a4, @"keybag %@ not a data", v36);
    return 0;
  }
  CFTypeID v8 = CFGetTypeID(cf);
  if (v8 != CFDataGetTypeID())
  {
    CFTypeRef v36 = cf;
    goto LABEL_57;
  }
  if (a1)
  {
    CFTypeID v9 = CFGetTypeID(a1);
    if (v9 != CFDictionaryGetTypeID())
    {
      sub_100012A40(-50, a4, @"backup %@ not a dictionary", a1);
      return 0;
    }
  }
  if (a3)
  {
    CFTypeID v10 = CFGetTypeID(a3);
    if (v10 != CFDataGetTypeID())
    {
      sub_100012A40(-50, a4, @"password %@ not a data", a3);
      return 0;
    }
  }
  CFTypeRef cfa = 0;
  CFTypeRef v53 = 0;
  uint64_t v48 = 0;
  id v49 = &v48;
  uint64_t v50 = 0x2000000000;
  uint64_t v51 = 0;
  int v47 = -1431655766;
  if (!sub_100155410((const __CFData *)cf, (const __CFData *)a3, &v47, (CFTypeRef *)a4)) {
    goto LABEL_53;
  }
  uint64_t v11 = sub_10000CF0C(0);
  uint64_t v12 = sub_100134054(v11);
  sub_1000297D0(v12 != 0, (CFTypeRef *)a4, @"No datasource");
  if (v12)
  {
    uint64_t v13 = (*(uint64_t (**)(uint64_t, const CFStringRef, __CFString **))(v12 + 8))(v12, kSecAttrAccessibleWhenUnlocked, a4);
    if (v13)
    {
      uint64_t v14 = v13;
      if (a1)
      {
        MutableCFArrayRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, (CFDictionaryRef)a1);
        v49[3] = (uint64_t)MutableCopy;
        CFDictionaryRef v16 = (const __CFDictionary *)a1;
      }
      else
      {
        CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        v49[3] = (uint64_t)Mutable;
        CFDictionaryRef v16 = 0;
      }
      BOOL v18 = (const void *)sub_100134A3C(v16, (CFTypeRef *)a4);
      uint64_t v19 = *(void *)v14;
      if (-[OTSOSActualAdapter sosEnabled]_0())
      {
        CFStringRef v37 = 0;
        uint64_t v38 = (uint64_t)&v37;
        uint64_t v39 = 0x2020000000;
        unsigned __int8 v40 = 0;
        *(void *)&long long buf = _NSConcreteStackBlock;
        *((void *)&buf + 1) = 3221225472;
        v59 = sub_100104C7C;
        BOOL v60 = &unk_1002FA2D0;
        v61 = &v37;
        uint64_t v62 = v19;
        uint64_t v63 = 0;
        sub_100104CC0(v19, 0, &buf);
        uint64_t v20 = *(const void **)(v38 + 24);
        _Block_object_dispose(&v37, 8);
        if (v20) {
          goto LABEL_18;
        }
      }
      else
      {
        SOSCCSetSOSDisabledError();
      }
      uint64_t V0ViewSet = SOSViewsGetV0ViewSet();
      uint64_t v20 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t, __CFString **))(v14 + 24))(v14, V0ViewSet, a4);
      if (!v20)
      {
        BOOL v23 = (const void *)v49[3];
        if (v23)
        {
          v49[3] = 0;
          CFRelease(v23);
        }
        CFTypeRef v24 = sub_10000B070("SecError");
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          if (a4) {
            int v25 = *a4;
          }
          else {
            int v25 = 0;
          }
          LODWORD(buf) = 138412290;
          *(void *)((char *)&buf + 4) = v25;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "failed to obtain manifest for keychain: %@", (uint8_t *)&buf, 0xCu);
        }
        CFTypeRef v22 = 0;
        uint64_t v20 = 0;
LABEL_27:
        v46[0] = _NSConcreteStackBlock;
        v46[1] = 0x40000000;
        v46[2] = sub_10014AF48;
        v46[3] = &unk_100304C60;
        v46[4] = &v48;
        sub_100200E78((uint64_t)v22, (uint64_t)v46);
        CFArrayRef v26 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        CFStringRef v37 = _NSConcreteStackBlock;
        uint64_t v38 = 0x40000000;
        uint64_t v39 = (uint64_t)sub_10014B018;
        unsigned __int8 v40 = &unk_100304C88;
        int v45 = v47;
        uint64_t v43 = v14;
        CFStringRef v44 = a4;
        CFStringRef v41 = &v48;
        CFArrayRef v42 = v26;
        if (((*(uint64_t (**)(uint64_t, void, CFTypeRef, __CFString **, void ***))(v14 + 32))(v14, 0, cfa, a4, &v37) & 1) == 0)
        {
          CFStringRef v27 = (const void *)v49[3];
          if (v27)
          {
            v49[3] = 0;
            CFRelease(v27);
          }
        }
        if (!CFArrayGetCount(v26)) {
          goto LABEL_37;
        }
        if (-[OTSOSActualAdapter sosEnabled]_0())
        {
          uint64_t v54 = 0;
          char v55 = &v54;
          uint64_t v56 = 0x2020000000;
          char v57 = 1;
          *(void *)&long long buf = _NSConcreteStackBlock;
          *((void *)&buf + 1) = 3221225472;
          v59 = sub_100104E10;
          BOOL v60 = &unk_1002FA280;
          v61 = (void ***)&v54;
          uint64_t v62 = v19;
          uint64_t v63 = 0;
          CFArrayRef v64 = v26;
          v65 = a4;
          dispatch_sync(*(dispatch_queue_t *)(v19 + 112), &buf);
          int v28 = *((unsigned __int8 *)v55 + 24);
          _Block_object_dispose(&v54, 8);
          if (v28)
          {
LABEL_37:
            if (v26) {
              CFRelease(v26);
            }
            if (((*(uint64_t (**)(uint64_t, __CFString **))(v14 + 72))(v14, a4) & 1) == 0)
            {
              uint64_t v30 = (const void *)v49[3];
              if (v30)
              {
                v49[3] = 0;
                CFRelease(v30);
              }
            }
            if (v18) {
              CFRelease(v18);
            }
            if (v20) {
              CFRelease(v20);
            }
            goto LABEL_46;
          }
        }
        else
        {
          SOSCCSetSOSDisabledError();
        }
        uint64_t v29 = (const void *)v49[3];
        if (v29)
        {
          v49[3] = 0;
          CFRelease(v29);
        }
        goto LABEL_37;
      }
LABEL_18:
      sub_10020113C((uint64_t)v18, (uint64_t)v20, (uint64_t *)&v53, &cfa, (CFTypeRef *)a4);
      CFTypeRef v22 = v53;
      goto LABEL_27;
    }
  }
LABEL_46:
  if (cfa) {
    CFRelease(cfa);
  }
  if (v53) {
    CFRelease(v53);
  }
  BOOL v31 = sub_10015554C(v47, (CFTypeRef *)a4);
  uint64_t v32 = v49;
  if (v31) {
    goto LABEL_54;
  }
  uint64_t v33 = (const void *)v49[3];
  if (!v33) {
    goto LABEL_54;
  }
  v49[3] = 0;
  CFRelease(v33);
LABEL_53:
  uint64_t v32 = v49;
LABEL_54:
  uint64_t v34 = v32[3];
  _Block_object_dispose(&v48, 8);
  return v34;
}

void sub_10014AF30(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va, a2);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10014AF48(uint64_t a1, CFDataRef theData)
{
  CFIndex Length = CFDataGetLength(theData);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 2 * Length);
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex v7 = CFDataGetLength(theData);
  if (v7 >= 1)
  {
    CFIndex v8 = v7;
    do
    {
      unsigned int v9 = *BytePtr++;
      CFStringAppendFormat(Mutable, 0, @"%02X", v9);
      --v8;
    }
    while (v8);
  }
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), Mutable);

  CFRelease(Mutable);
}

void sub_10014B018(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  CFTypeRef cf = 0;
  if (!a3)
  {
    uint64_t v20 = *(__CFArray **)(a1 + 40);
    values = a2;
    CFArrayRef v21 = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
    CFArrayAppendValue(v20, v21);
    if (!v21) {
      return;
    }
    CFArrayRef v22 = v21;
    goto LABEL_22;
  }
  CFDataRef v8 = (const __CFData *)(*(uint64_t (**)(uint64_t, CFTypeRef *))(*(void *)(a1 + 48) + 112))(a3, &cf);
  if (!v8
    || (uint64_t v9 = (*(uint64_t (**)(uint64_t, void, CFTypeRef *))(*(void *)(a1 + 48) + 144))(a3, *(int *)(a1 + 64), &cf)) == 0)
  {
    if (SecErrorGetOSStatus() == -26275)
    {
      CFRelease(cf);
      __int16 v17 = *(__CFArray **)(a1 + 40);
      values = a2;
      CFArrayRef v18 = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
      CFArrayAppendValue(v17, v18);
      if (v18)
      {
        CFArrayRef v19 = v18;
LABEL_16:
        CFRelease(v19);
      }
    }
    else
    {
      *a4 = 1;
      **(void **)(a1 + 56) = cf;
      uint64_t v23 = *(void *)(*(void *)(a1 + 32) + 8);
      CFArrayRef v19 = *(CFArrayRef *)(v23 + 24);
      if (v19)
      {
        *(void *)(v23 + 24) = 0;
        goto LABEL_16;
      }
    }
    CFTypeID v10 = 0;
    goto LABEL_18;
  }
  CFTypeID v10 = (const void *)v9;
  CFIndex Length = CFDataGetLength(v8);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 2 * Length);
  BytePtr = CFDataGetBytePtr(v8);
  CFIndex v14 = CFDataGetLength(v8);
  if (v14 >= 1)
  {
    CFIndex v15 = v14;
    do
    {
      unsigned int v16 = *BytePtr++;
      CFStringAppendFormat(Mutable, 0, @"%02X", v16);
      --v15;
    }
    while (v15);
  }
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), Mutable, v10);
  if (Mutable) {
    CFRelease(Mutable);
  }
LABEL_18:
  if (v8) {
    CFRelease(v8);
  }
  if (v10)
  {
    CFArrayRef v22 = (CFArrayRef)v10;
LABEL_22:
    CFRelease(v22);
  }
}

BOOL sub_10014B254(const void *a1, CFTypeRef cf, const __CFData *a3, __CFString **a4)
{
  if (!cf)
  {
    CFTypeRef v19 = 0;
    return sub_100012A40(-50, a4, @"keybag %@ not a data", v19);
  }
  CFTypeID v8 = CFGetTypeID(cf);
  if (v8 != CFDataGetTypeID())
  {
    CFTypeRef v19 = cf;
    return sub_100012A40(-50, a4, @"keybag %@ not a data", v19);
  }
  if (!a1)
  {
    uint64_t v20 = 0;
    return sub_100012A40(-50, a4, @"backup %@ not a dictionary", v20);
  }
  CFTypeID v9 = CFGetTypeID(a1);
  if (v9 != CFDictionaryGetTypeID())
  {
    uint64_t v20 = a1;
    return sub_100012A40(-50, a4, @"backup %@ not a dictionary", v20);
  }
  if (a3 && (CFTypeID v10 = CFGetTypeID(a3), v10 != CFDataGetTypeID()))
  {
    return sub_100012A40(-50, a4, @"password not a data");
  }
  else
  {
    uint64_t v24 = 0;
    int v25 = &v24;
    uint64_t v26 = 0x2000000000;
    char v27 = 1;
    int v23 = -1431655766;
    if (sub_100155410((const __CFData *)cf, a3, &v23, (CFTypeRef *)a4))
    {
      uint64_t v11 = sub_100134A3C((const __CFDictionary *)a1, (CFTypeRef *)a4);
      if (v11)
      {
        uint64_t v12 = (const void *)v11;
        uint64_t v13 = sub_10000CF0C(0);
        uint64_t v14 = sub_100134054(v13);
        sub_1000297D0(v14 != 0, (CFTypeRef *)a4, @"No datasource");
        if (v14)
        {
          uint64_t v15 = (*(uint64_t (**)(uint64_t, const CFStringRef, __CFString **))(v14 + 8))(v14, kSecAttrAccessibleWhenUnlocked, a4);
          if (v15)
          {
            v21[0] = _NSConcreteStackBlock;
            v21[1] = 0x40000000;
            v21[2] = sub_10014B4C8;
            v21[3] = &unk_100304CD8;
            v21[6] = a4;
            v21[7] = v12;
            v21[8] = a1;
            int v22 = v23;
            v21[4] = &v24;
            v21[5] = v15;
            LOBYTE(v15) = (*(uint64_t (**)(uint64_t, __CFString **, void, void, void *))(v15 + 64))(v15, a4, 0, 0, v21);
          }
        }
        else
        {
          LOBYTE(v15) = 0;
        }
        *((unsigned char *)v25 + 24) &= v15;
        CFRelease(v12);
      }
      BOOL v17 = sub_10015554C(v23, (CFTypeRef *)a4);
      if (*((unsigned char *)v25 + 24)) {
        BOOL v16 = v17;
      }
      else {
        BOOL v16 = 0;
      }
      *((unsigned char *)v25 + 24) = v16;
    }
    else
    {
      BOOL v16 = 0;
    }
    _Block_object_dispose(&v24, 8);
    return v16;
  }
}

void sub_10014B4C8(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t V0BackupViewSet = SOSViewsGetV0BackupViewSet();
  BOOL v6 = (const void *)(*(uint64_t (**)(uint64_t, uint64_t, void))(v4 + 24))(v4, V0BackupViewSet, *(void *)(a1 + 48));
  uint64_t v17 = 0;
  CFArrayRef v18 = 0;
  sub_10020113C((uint64_t)v6, *(void *)(a1 + 56), (uint64_t *)&v18, (const void **)&v17, *(CFTypeRef **)(a1 + 48));
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000;
  v15[2] = sub_10014B600;
  v15[3] = &unk_100304CB0;
  uint64_t v7 = *(void *)(a1 + 64);
  uint64_t v8 = *(void *)(a1 + 32);
  v15[6] = *(void *)(a1 + 40);
  void v15[7] = a2;
  int v16 = *(_DWORD *)(a1 + 72);
  v15[4] = v8;
  v15[5] = v7;
  v15[8] = *(void *)(a1 + 48);
  sub_100200E78(v17, (uint64_t)v15);
  uint64_t v9 = *(void *)(a1 + 40);
  if (v9) {
    char v10 = (*(uint64_t (**)(uint64_t, void))(v9 + 72))(v9, *(void *)(a1 + 48));
  }
  else {
    char v10 = 1;
  }
  uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v11 + 24)) {
    char v12 = v10;
  }
  else {
    char v12 = 0;
  }
  *(unsigned char *)(v11 + 24) = v12;
  uint64_t v13 = v18;
  if (v18)
  {
    CFArrayRef v18 = 0;
    CFRelease(v13);
  }
  uint64_t v14 = (const void *)v17;
  if (v17)
  {
    uint64_t v17 = 0;
    CFRelease(v14);
  }
  if (v6) {
    CFRelease(v6);
  }
}

void sub_10014B600(uint64_t a1, CFDataRef theData, unsigned char *a3)
{
  CFIndex Length = CFDataGetLength(theData);
  CFMutableDictionaryRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 2 * Length);
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex v9 = CFDataGetLength(theData);
  if (v9 >= 1)
  {
    CFIndex v10 = v9;
    do
    {
      unsigned int v11 = *BytePtr++;
      CFStringAppendFormat(Mutable, 0, @"%02X", v11);
      --v10;
    }
    while (v10);
  }
  if (Mutable)
  {
    CFStringRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), Mutable);
    CFRelease(Mutable);
    if (Value)
    {
      CFTypeRef cf = 0;
      if (((*(uint64_t (**)(void, void, const void *, CFTypeRef *))(*(void *)(a1 + 48) + 104))(*(void *)(a1 + 56), *(int *)(a1 + 72), Value, &cf) & 1) == 0)
      {
        int OSStatus = SecErrorGetOSStatus();
        if (OSStatus != -26275)
        {
          if (OSStatus == -25308)
          {
            *a3 = 1;
          }
          else if (OSStatus == -25299)
          {
            uint64_t v14 = sub_10000B070("titc");
            if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_20;
            }
            *(_DWORD *)long long buf = 138477827;
            int v23 = Value;
            uint64_t v15 = "restore %{private}@ not replacing existing item";
            int v16 = v14;
            uint32_t v17 = 12;
            goto LABEL_14;
          }
          CFTypeRef v19 = sub_10000B070("SecError");
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138478083;
            int v23 = Value;
            __int16 v24 = 2112;
            CFTypeRef v25 = cf;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "restore %{private}@ failed %@", buf, 0x16u);
          }
          *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
          uint64_t v20 = *(CFTypeRef **)(a1 + 64);
          if (v20 && !*v20)
          {
            *uint64_t v20 = cf;
            return;
          }
          goto LABEL_20;
        }
        CFArrayRef v18 = sub_10000B070("titc");
        if (!os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_20;
        }
        *(_DWORD *)long long buf = 138478083;
        int v23 = Value;
        __int16 v24 = 2112;
        CFTypeRef v25 = cf;
        uint64_t v15 = "restore %{private}@ skipping corrupted item %@";
        int v16 = v18;
        uint32_t v17 = 22;
LABEL_14:
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v15, buf, v17);
LABEL_20:
        if (cf) {
          CFRelease(cf);
        }
      }
    }
  }
}

uint64_t sub_10014B894(char a1, uint64_t a2)
{
  return sub_10014B8A0(a1, 0, a2);
}

uint64_t sub_10014B8A0(char a1, uint64_t a2, uint64_t a3)
{
  int v11 = 0;
  int v6 = sub_10001BA9C(dword_10035D2B0, 0, &v11);
  uint64_t result = 0;
  if (!v6)
  {
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 0x40000000;
    v8[2] = sub_10014B96C;
    v8[3] = &unk_1003043B8;
    int v9 = v11 & 1;
    char v10 = a1;
    v8[4] = a2;
    v8[5] = a3;
    return sub_10000CBA4(1, 1, 0, a3, (uint64_t)v8);
  }
  return result;
}

BOOL sub_10014B96C(uint64_t a1, const void *a2)
{
  BOOL result = sub_10013DCE0(a2, *(_DWORD *)(a1 + 48));
  if (*(unsigned char *)(a1 + 52) && !result)
  {
    uint64_t v6 = *(void *)(a1 + 32);
    CFTypeID v5 = *(CFTypeRef **)(a1 + 40);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 0x40000000;
    v10[2] = sub_10013DFC4;
    v10[3] = &unk_1002FBD38;
    v10[4] = v5;
    v10[5] = a2;
    v10[6] = v6;
    if (!sub_100027B34((uint64_t)a2, 2, v5, (uint64_t)v10)) {
      goto LABEL_8;
    }
    uint64_t v7 = sub_10000B070("SecError");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v10[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Completed roll keys.", (uint8_t *)v10, 2u);
    }
    if (sub_10013DCE0(a2, *(_DWORD *)(a1 + 48)))
    {
      return 1;
    }
    else
    {
LABEL_8:
      uint64_t v8 = sub_10000B070("SecError");
      BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
      BOOL result = 0;
      if (v9)
      {
        LOWORD(v10[0]) = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Failed to roll keys.", (uint8_t *)v10, 2u);
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_10014BAC8(uint64_t a1, char a2, const __CFBoolean *a3, const __CFBoolean *a4, uint64_t a5, __CFString **a6)
{
  int v11 = (const void **)sub_10000C7F0(a5, 0, 0, 0, a6);
  if (!v11) {
    return 0;
  }
  char v12 = v11;
  *((_DWORD *)v11 + 12) = 3;
  v11[13] = (const void *)-1;
  *((_DWORD *)v11 + 30) = dword_10035D2B0;
  sub_10000DF34(kSecAttrAccessGroup, a3, (uint64_t)v11);
  sub_10000DF34(kSecAttrSynchronizable, kCFBooleanTrue, (uint64_t)v12);
  sub_10000DF34(kSecAttrTombstone, kCFBooleanFalse, (uint64_t)v12);
  if (a4) {
    sub_10000DF34(kSecAttrService, a4, (uint64_t)v12);
  }
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000;
  v15[2] = sub_10014BC44;
  v15[3] = &unk_100304D58;
  v15[4] = a6;
  v15[5] = v12;
  char v16 = a2;
  v15[6] = a1;
  uint64_t v13 = sub_10000CBA4(0, 1, 0, (uint64_t)a6, (uint64_t)v15);
  sub_10000C2C4(v12, 0);
  return v13;
}

BOOL sub_10014BC44(uint64_t a1, uint64_t a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_10014BCCC;
  void v5[3] = &unk_100304D38;
  CFDictionaryRef v2 = *(CFTypeRef **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 48);
  v5[4] = *(void *)(a1 + 40);
  void v5[5] = a2;
  char v6 = *(unsigned char *)(a1 + 56);
  v5[6] = v3;
  return sub_1001381F8(a2, 2, v2, (uint64_t)v5);
}

uint64_t sub_10014BCCC(uint64_t a1)
{
  CFTypeRef v9 = 0;
  CFDictionaryRef v2 = *(CFDictionaryRef **)(a1 + 32);
  uint64_t v1 = *(void *)(a1 + 40);
  v7.isa = _NSConcreteStackBlock;
  *(void *)&v7.flags = 0x40000000;
  v7.invoke = (void (*)(void *, ...))sub_10014BDB8;
  v7.descriptor = (Block_descriptor_1 *)&unk_100304CF8;
  uint64_t v8 = v2;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_10014BDE4;
  void v5[3] = &unk_100304D18;
  char v6 = *(unsigned char *)(a1 + 56);
  v5[4] = *(void *)(a1 + 48);
  sub_10011C750(v2, v1, &v9, 0, &v7, 0, 0, (uint64_t)v5);
  CFTypeRef v3 = v9;
  if (v9)
  {
    CFTypeRef v9 = 0;
    CFRelease(v3);
  }
  return 1;
}

BOOL sub_10014BDB8(uint64_t a1, const void **a2)
{
  return CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 32) + 8), *a2) != 0;
}

void sub_10014BDE4(uint64_t a1, uint64_t a2)
{
  CFTypeRef cf = 0;
  uint64_t v4 = sub_10000B070("InitialSyncItems");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long buf = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Copy item", buf, 2u);
  }
  CFTypeID v5 = sub_100118B3C((void *)a2, 0x10000, 0, (__CFString **)&cf);
  if (v5)
  {
    CFDictionaryRef v6 = v5;
    CFStringRef Value = CFDictionaryGetValue(v5, kSecAttrSyncViewHint);
    if (Value && (CFTypeID v8 = CFGetTypeID(Value), v8 == CFStringGetTypeID())) {
      int v9 = SOSViewInSOSSystem();
    }
    else {
      int v9 = 1;
    }
    if (*(unsigned char *)(a1 + 40))
    {
      int valuePtr = -1431655766;
      CFNumberRef v10 = (const __CFNumber *)CFDictionaryGetValue(v6, kSecAttrType);
      if (v10)
      {
        CFNumberRef v11 = v10;
        CFTypeID v12 = CFGetTypeID(v10);
        if (v12 == CFNumberGetTypeID())
        {
          if (!CFNumberGetValue(v11, kCFNumberSInt32Type, &valuePtr))
          {
LABEL_15:
            CFRelease(v6);
            goto LABEL_16;
          }
          int v9 = (BYTE2(valuePtr) & v9);
        }
      }
    }
    if (v9)
    {
      CFDictionaryAddValue(v6, kSecClass, **(const void ***)(a2 + 16));
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v6);
    }
    goto LABEL_15;
  }
LABEL_16:
  CFTypeRef v13 = cf;
  if (cf)
  {
    CFTypeRef cf = 0;
    CFRelease(v13);
  }
}

BOOL sub_10014BF74(uint64_t a1, uint64_t a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10014BFEC;
  v4[3] = &unk_1003043D8;
  CFDictionaryRef v2 = *(CFTypeRef **)(a1 + 32);
  void v4[4] = *(void *)(a1 + 40);
  void v4[5] = a2;
  return sub_1001381F8(a2, 2, v2, (uint64_t)v4);
}

uint64_t sub_10014BFEC(uint64_t a1)
{
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 32));
  CFTypeRef v3 = sub_10000B070("ImportInitialSyncItems");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)&uint8_t buf[4] = Count;
    _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "Importing %d items", buf, 8u);
  }
  if (Count >= 1)
  {
    for (CFIndex i = 0; Count != i; ++i)
    {
      CFTypeRef cf = 0;
      CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 32), i);
      if (!ValueAtIndex) {
        continue;
      }
      CFDictionaryRef v6 = ValueAtIndex;
      CFTypeID v7 = CFGetTypeID(ValueAtIndex);
      if (v7 != CFDictionaryGetTypeID()) {
        continue;
      }
      CFStringRef Value = CFDictionaryGetValue(v6, kSecClass);
      if (Value)
      {
        int v9 = Value;
        CFNumberRef v10 = sub_10000C614(Value);
        if (v10)
        {
          CFNumberRef v11 = (void **)sub_10011ACF4((uint64_t)v10, v6, dword_10035D2B0, (__CFString **)&cf);
          if (v11)
          {
            uint64_t v12 = (uint64_t)v11;
            CFTypeRef v13 = (void *)sub_100118974(v11[2], 11, (__CFString **)&cf);
            if (sub_1001196B4(v12, v13, kCFBooleanTrue, (__CFString **)&cf))
            {
              uint64_t v14 = *(void *)(a1 + 40);
              *(void *)long long buf = _NSConcreteStackBlock;
              *(void *)&uint8_t buf[8] = 0x40000000;
              *(void *)&uint8_t buf[16] = sub_10011DDE8;
              uint64_t v30 = &unk_1002FA9B0;
              uint64_t v31 = v12;
              __int16 v32 = 0;
              if ((sub_10011C214(v12, v14, (__CFString **)&cf, (uint64_t)buf) & 1) == 0)
              {
                uint64_t v15 = sub_10000B070("ImportInitialSyncItems");
                if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
                {
                  *(_DWORD *)long long buf = 138412547;
                  *(void *)&uint8_t buf[4] = cf;
                  *(_WORD *)&unsigned char buf[12] = 2113;
                  *(void *)&buf[14] = v12;
                  char v16 = v15;
                  uint32_t v17 = "Item store failed with: %@: %{private}@";
                  goto LABEL_31;
                }
                goto LABEL_24;
              }
            }
            else
            {
              CFTypeRef v25 = sub_10000B070("ImportInitialSyncItems");
              if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)long long buf = 138412547;
                *(void *)&uint8_t buf[4] = cf;
                *(_WORD *)&unsigned char buf[12] = 2113;
                *(void *)&buf[14] = v12;
                char v16 = v25;
                uint32_t v17 = "Failed to set sync=1: %@ for item %{private}@";
LABEL_31:
                _os_log_debug_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, v17, buf, 0x16u);
              }
LABEL_24:
              CFTypeRef v26 = cf;
              if (cf)
              {
                CFTypeRef cf = 0;
                CFRelease(v26);
              }
            }
            CFTypeRef v24 = (CFTypeRef)v12;
          }
          else
          {
            int v23 = sub_10000B070("ImportInitialSyncItems");
            if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138412290;
              *(void *)&uint8_t buf[4] = cf;
              _os_log_debug_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEBUG, "Item creation failed with: %@", buf, 0xCu);
            }
            CFTypeRef v24 = cf;
            if (!cf) {
              continue;
            }
            CFTypeRef cf = 0;
          }
          CFRelease(v24);
          continue;
        }
        int v22 = sub_10000B070("ImportInitialSyncItems");
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = v9;
          CFTypeRef v19 = v22;
          uint64_t v20 = "Item with unknown class: %@";
          uint32_t v21 = 12;
          goto LABEL_18;
        }
      }
      else
      {
        CFArrayRef v18 = sub_10000B070("ImportInitialSyncItems");
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          *(_WORD *)long long buf = 0;
          CFTypeRef v19 = v18;
          uint64_t v20 = "Item w/o class";
          uint32_t v21 = 2;
LABEL_18:
          _os_log_debug_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEBUG, v20, buf, v21);
        }
      }
    }
  }
  return 1;
}

uint64_t sub_10014C3C8(const __CFArray *a1, unsigned int a2, uint64_t a3, __CFString **a4)
{
  if (!*(unsigned char *)(a3 + 36)) {
    return 0;
  }
  kdebug_trace();
  CFTypeID v8 = sub_10000B070("syncbubble");
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    int v24 = 67109378;
    unsigned int v25 = a2;
    __int16 v26 = 2112;
    CFArrayRef v27 = a1;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "migration for uid %d for services %@", (uint8_t *)&v24, 0x12u);
  }
  int v9 = *(_DWORD *)(a3 + 40);
  v28.length = CFArrayGetCount(a1);
  v28.location = 0;
  int v10 = 1;
  if (!CFArrayContainsValue(a1, v28, @"com.apple.bird.usermanager.sync"))
  {
    v29.length = CFArrayGetCount(a1);
    v29.location = 0;
    if (!CFArrayContainsValue(a1, v29, @"com.apple.cloudphotod.sync"))
    {
      v30.length = CFArrayGetCount(a1);
      v30.location = 0;
      if (!CFArrayContainsValue(a1, v30, @"com.apple.cloudphotod.syncstakeholder"))
      {
        v31.length = CFArrayGetCount(a1);
        v31.location = 0;
        if (!CFArrayContainsValue(a1, v31, @"com.apple.cloudd.usermanager.sync")) {
          int v10 = 0;
        }
      }
    }
  }
  v32.length = CFArrayGetCount(a1);
  v32.location = 0;
  int v11 = CFArrayContainsValue(a1, v32, @"com.apple.nsurlsessiond.usermanager.sync");
  v33.length = CFArrayGetCount(a1);
  v33.location = 0;
  int v12 = CFArrayContainsValue(a1, v33, @"com.apple.syncdefaultsd.usermanager.sync");
  v34.length = CFArrayGetCount(a1);
  v34.location = 0;
  if (CFArrayContainsValue(a1, v34, @"com.apple.mailq.sync")
    || (v11 ? (int v13 = 1) : (int v13 = v10),
        v12 ? (int v14 = 1) : (int v14 = v13),
        v35.length = CFArrayGetCount(a1),
        v35.location = 0,
        CFArrayContainsValue(a1, v35, @"com.apple.mailq.sync.xpc")))
  {
    int v14 = 1;
    int v15 = 1;
    int v10 = 1;
  }
  else
  {
    int v15 = 0;
  }
  uint64_t v16 = sub_10000C75C(@"inet", &qword_10035D020, (uint64_t)&unk_10035D018);
  if (sub_10014C838(a3, a2, v9 != a2, v10, v16, (uint64_t)&off_10035BCD0, 1, a4)
    && (uint64_t v17 = sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008),
        sub_10014C838(a3, a2, v9 != a2, v10, v17, (uint64_t)&off_10035BCD0, 1, a4))
    && (uint64_t v18 = sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008),
        sub_10014C838(a3, a2, v9 != a2, v15, v18, (uint64_t)&off_10035BCE0, 16, a4))
    && (uint64_t v19 = sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008),
        sub_10014C838(a3, a2, v9 != a2, v14, v19, (uint64_t)&off_10035BDE0, 6, a4)))
  {
    uint64_t v20 = sub_10000C75C(@"inet", &qword_10035D020, (uint64_t)&unk_10035D018);
    uint64_t v21 = sub_10014C838(a3, a2, v9 != a2, v11 != 0, v20, (uint64_t)&off_10035BE40, 1, a4);
  }
  else
  {
    uint64_t v21 = 0;
  }
  int v22 = sub_10000B070("syncbubble");
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    int v24 = 67109120;
    unsigned int v25 = a2;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "migration for uid %d complete", (uint8_t *)&v24, 8u);
  }
  kdebug_trace();
  return v21;
}

uint64_t sub_10014C838(uint64_t a1, unsigned int a2, int a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7, __CFString **a8)
{
  *(void *)bytes = 0x114EC8A39FAB1A82;
  unsigned int v15 = bswap32(a2);
  int v41 = -397635414;
  unsigned int v42 = v15;
  CFDataRef v16 = CFDataCreate(0, bytes, 16);
  if (!v16) {
    return 0;
  }
  CFDataRef v17 = v16;
  *(void *)bytes = 0x104B57A5353A5AA7;
  int v41 = -1803342146;
  unsigned int v42 = v15;
  CFDataRef v18 = CFDataCreate(0, bytes, 16);
  if (!v18)
  {
    CFRelease(v17);
    return 0;
  }
  CFDataRef v19 = v18;
  if (!a3 || (a4 & 1) == 0)
  {
    CFDataRef cf = v17;
    uint64_t v20 = sub_10000B070("syncbubble");
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)bytes = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "cleaning out old items", bytes, 2u);
    }
    uint64_t v21 = sub_10000C7F0(a5, 0, 0, a1, a8);
    uint64_t v22 = (uint64_t)v21;
    if (!v21) {
      goto LABEL_31;
    }
    uint64_t v36 = a1;
    uint64_t v23 = a5;
    v21[13] = -1;
    *((_DWORD *)v21 + 30) = dword_10035D2B0;
    uint64_t v24 = a6;
    unsigned int v25 = (const __CFBoolean **)(a6 + 8);
    uint64_t v26 = a7;
    do
    {
      sub_10000DF34(*(v25 - 1), *v25, v22);
      v25 += 2;
      --v26;
    }
    while (v26);
    CFTypeRef v27 = CFRetain(cf);
    *(void *)(v22 + 128) = v27;
    if (!v27)
    {
LABEL_31:
      CFRange v33 = 0;
      uint64_t v34 = 0;
      CFDataRef v17 = cf;
      goto LABEL_24;
    }
    v39[0] = _NSConcreteStackBlock;
    v39[1] = 0x40000000;
    v39[2] = sub_10014CC64;
    v39[3] = &unk_100304D98;
    v39[4] = a8;
    v39[5] = v22;
    sub_10000CBA4(1, 1, 0, (uint64_t)a8, (uint64_t)v39);
    sub_10000C2C4((const void **)v22, 0);
    a6 = v24;
    a5 = v23;
    a1 = v36;
    CFDataRef v17 = cf;
  }
  CFRange v28 = sub_10000B070("syncbubble");
  BOOL v29 = os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT);
  if (!a4 || a3)
  {
    if (v29)
    {
      *(_WORD *)bytes = 0;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "skip migration of items", bytes, 2u);
    }
    CFRange v33 = 0;
    uint64_t v22 = 0;
    uint64_t v34 = 1;
    goto LABEL_24;
  }
  if (v29)
  {
    *(_WORD *)bytes = 0;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "migrating sync bubble items", bytes, 2u);
  }
  CFRange v30 = sub_10000C7F0(a5, 0, 0, a1, a8);
  uint64_t v22 = (uint64_t)v30;
  if (!v30)
  {
    CFRange v33 = 0;
LABEL_33:
    uint64_t v34 = 0;
    goto LABEL_24;
  }
  *((_DWORD *)v30 + 12) = 3;
  v30[13] = -1;
  *((_DWORD *)v30 + 30) = dword_10035D2B0;
  CFRange v31 = (const __CFData **)(a6 + 8);
  do
  {
    sub_100129340(*(v31 - 1), *v31, v22);
    v31 += 2;
    --a7;
  }
  while (a7);
  sub_100129340(@"musr", v19, v22);
  *(void *)(v22 + 128) = CFRetain(v19);
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFRange v33 = Mutable;
  if (!Mutable) {
    goto LABEL_33;
  }
  CFDictionarySetValue(Mutable, @"musr", v17);
  v38[0] = _NSConcreteStackBlock;
  v38[1] = 0x40000000;
  v38[2] = sub_10014CCE8;
  v38[3] = &unk_100304E18;
  v38[4] = a8;
  v38[5] = v22;
  v38[6] = v33;
  uint64_t v34 = 1;
  sub_10000CBA4(1, 1, 0, (uint64_t)a8, (uint64_t)v38);
LABEL_24:
  CFRelease(v17);
  CFRelease(v19);
  if (v33) {
    CFRelease(v33);
  }
  if (v22) {
    sub_10000C2C4((const void **)v22, 0);
  }
  return v34;
}

BOOL sub_10014CC64(int8x16_t *a1, uint64_t a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10014D09C;
  v4[3] = &unk_100304D78;
  void v4[4] = a2;
  int8x16_t v2 = a1[2];
  int8x16_t v5 = vextq_s8(v2, v2, 8uLL);
  return sub_1001381F8(a2, 2, (CFTypeRef *)v2.i64[0], (uint64_t)v4);
}

BOOL sub_10014CCE8(void *a1, uint64_t a2)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_10014CD68;
  void v5[3] = &unk_100304DF8;
  int8x16_t v2 = (CFTypeRef *)a1[4];
  uint64_t v3 = a1[6];
  v5[4] = a1[5];
  void v5[5] = a2;
  v5[6] = v3;
  return sub_1001381F8(a2, 2, v2, (uint64_t)v5);
}

uint64_t sub_10014CD68(uint64_t a1)
{
  CFTypeRef v9 = 0;
  uint64_t v1 = *(CFDictionaryRef **)(a1 + 32);
  v7.isa = _NSConcreteStackBlock;
  *(void *)&v7.flags = 0x40000000;
  v7.invoke = (void (*)(void *, ...))sub_10014CE54;
  v7.descriptor = (Block_descriptor_1 *)&unk_100304DB8;
  CFTypeID v8 = v1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_10014CE80;
  void v5[3] = &unk_100304DD8;
  int8x16_t v2 = *(int8x16_t *)(a1 + 40);
  int8x16_t v6 = vextq_s8(v2, v2, 8uLL);
  sub_10011C750(v1, v2.i64[0], &v9, 0, &v7, 0, 0, (uint64_t)v5);
  CFTypeRef v3 = v9;
  if (v9)
  {
    CFTypeRef v9 = 0;
    CFRelease(v3);
  }
  return 1;
}

BOOL sub_10014CE54(uint64_t a1, const void **a2)
{
  return CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 32) + 8), *a2) != 0;
}

void sub_10014CE80(uint64_t a1, uint64_t a2)
{
  int v10 = 0;
  uint64_t v4 = sub_10000B070("syncbubble");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long buf = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "migrating item", buf, 2u);
  }
  int8x16_t v5 = (__CFString *)sub_10011B3B4(a2, *(const __CFDictionary **)(a1 + 32), &v10);
  if (v5)
  {
    int8x16_t v6 = v5;
    sub_10011B874((uint64_t)v5, 0);
    if (!sub_10011A8B0((uint64_t)v6, dword_10035D2B0, 0)) {
      goto LABEL_13;
    }
    uint64_t v7 = *(void *)(a1 + 40);
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&uint8_t buf[16] = sub_10011DDE8;
    int v12 = &unk_1002FA9B0;
    int v13 = v6;
    __int16 v14 = 0;
    if ((sub_10011C214((uint64_t)v6, v7, &v10, (uint64_t)buf) & 1) == 0)
    {
      CFTypeID v8 = sub_10000B070("syncbubble");
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412547;
        *(void *)&uint8_t buf[4] = v10;
        *(_WORD *)&unsigned char buf[12] = 2113;
        *(void *)&buf[14] = v6;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "migration failed with %@ for item %{private}@", buf, 0x16u);
      }
    }
    CFRelease(v6);
  }
  else
  {
    CFTypeRef v9 = sub_10000B070("syncbubble");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "migration failed, no new_item %@", buf, 0xCu);
    }
  }
  int8x16_t v6 = v10;
  if (!v10) {
    return;
  }
  int v10 = 0;
LABEL_13:
  CFRelease(v6);
}

BOOL sub_10014D09C(uint64_t a1)
{
  return sub_100139FCC(*(void *)(a1 + 32), *(void *)(a1 + 40), 0, *(CFTypeRef **)(a1 + 48));
}

uint64_t sub_10014D0B0(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = 0;
  int v12 = &v11;
  uint64_t v13 = 0x2000000000;
  char v14 = 1;
  kdebug_trace();
  uint64_t v4 = sub_10000B070("transmogrify");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "begin", buf, 2u);
  }
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  v9[2] = sub_10014D2EC;
  v9[3] = &unk_100304590;
  v9[5] = a2;
  v9[6] = a1;
  v9[4] = &v11;
  sub_10000CBA4(1, 1, 0, a2, (uint64_t)v9);
  if (sub_10002B120())
  {
    if (qword_10035CC68 != -1) {
      dispatch_once(&qword_10035CC68, &stru_1002F7BD0);
    }
    if (!byte_10035CC60)
    {
      v8[0] = _NSConcreteStackBlock;
      v8[1] = 0x40000000;
      v8[2] = sub_10014D378;
      v8[3] = &unk_1003045E0;
      v8[4] = &v11;
      v8[5] = a2;
      void v8[6] = a1;
      sub_10000CBA4(1, 1, 0, a2, (uint64_t)v8);
    }
  }
  int8x16_t v5 = sub_10000B070("transmogrify");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "end", buf, 2u);
  }
  kdebug_trace();
  uint64_t v6 = *((unsigned __int8 *)v12 + 24);
  _Block_object_dispose(&v11, 8);
  return v6;
}

BOOL sub_10014D2EC(uint64_t a1, uint64_t a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10014D5F8;
  v4[3] = &unk_100304568;
  int8x16_t v2 = *(int8x16_t *)(a1 + 40);
  int8x16_t v5 = vextq_s8(v2, v2, 8uLL);
  void v4[4] = *(void *)(a1 + 32);
  uint64_t v6 = a2;
  return sub_1001381F8(a2, 2, (CFTypeRef *)v2.i64[0], (uint64_t)v4);
}

uint64_t sub_10014D378(uint64_t a1, uint64_t a2)
{
  if (sub_100141324(a2))
  {
    uint64_t v4 = sub_10000B070("transmogrify");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Unexpectedly already transcrypted??", buf, 2u);
    }
  }
  else
  {
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000;
    v9[2] = sub_10014D504;
    v9[3] = &unk_1003045B8;
    v9[4] = *(void *)(a1 + 32);
    v9[5] = a2;
    int8x16_t v5 = *(int8x16_t *)(a1 + 40);
    int8x16_t v10 = vextq_s8(v5, v5, 8uLL);
    sub_1001381F8(a2, 2, (CFTypeRef *)v5.i64[0], (uint64_t)v9);
    uint64_t v6 = sub_10000B070("transmogrify");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "transcrypted, setting flag to remember we've already done so", buf, 2u);
    }
    sub_1001413DC(a2);
    uint64_t v7 = sub_10000B070("transmogrify");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "transcrypted, using system keychain handle", buf, 2u);
    }
    dword_10035D2B0 = -6;
  }
  return 1;
}

uint64_t sub_10014D504(void *a1)
{
  int8x16_t v2 = sub_10000B070("transmogrify");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v10[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "must transcrypt, using default keybag", (uint8_t *)v10, 2u);
  }
  uint64_t v3 = a1[5];
  uint64_t v4 = a1[6];
  int8x16_t v5 = (CFTypeRef *)a1[7];
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = sub_100142FBC;
  v10[3] = &unk_1003049C0;
  v10[4] = v4;
  v10[5] = v5;
  v10[6] = v3;
  BOOL v6 = sub_1001381F8(v3, 2, v5, (uint64_t)v10);
  uint64_t v7 = *(void *)(a1[4] + 8);
  BOOL v8 = v6 && *(unsigned char *)(v7 + 24) != 0;
  *(unsigned char *)(v7 + 24) = v8;
  return 1;
}

uint64_t sub_10014D5F8(uint64_t a1)
{
  if (qword_10035CF48 != -1) {
    dispatch_once(&qword_10035CF48, &stru_1002FAF50);
  }
  uint64_t v2 = qword_10035CF50;
  uint64_t v3 = &off_1002FE3E8;
  uint64_t v4 = off_100300578;
  do
  {
    if (*((unsigned char *)v3 + 8))
    {
      if (qword_10035CF58 != -1) {
        dispatch_once(&qword_10035CF58, &stru_1002FAF90);
      }
      int8x16_t v5 = (CFDictionaryRef *)sub_10000C7F0((uint64_t)v3, (const void *)qword_10035CF60, 0, *(void *)(a1 + 40), *(__CFString ***)(a1 + 48));
      if (v5)
      {
        BOOL v6 = (const void **)v5;
        BOOL v8 = *(CFTypeRef **)(a1 + 48);
        uint64_t v7 = *(void *)(a1 + 56);
        v15[0] = _NSConcreteStackBlock;
        v15[1] = 0x40000000;
        v15[2] = sub_10014D7D4;
        v15[3] = &unk_1003044D8;
        v15[4] = v8;
        v14[0] = _NSConcreteStackBlock;
        v14[1] = 0x40000000;
        v14[2] = sub_10014D850;
        v14[3] = &unk_100304540;
        void v14[4] = *(void *)(a1 + 32);
        v14[5] = v2;
        v14[6] = v7;
        v14[7] = v8;
        BOOL v9 = sub_10011C750(v5, v7, v8, &stru_100304438, &stru_100304478, (uint64_t)&stru_1003044B8, (uint64_t)v15, (uint64_t)v14);
        uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 8);
        if (*(unsigned char *)(v10 + 24)) {
          BOOL v11 = v9;
        }
        else {
          BOOL v11 = 0;
        }
        *(unsigned char *)(v10 + 24) = v11;
        sub_10000C2C4(v6, 0);
      }
    }
    int v12 = *v4++;
    uint64_t v3 = v12;
  }
  while (v12);
  return 1;
}

uint64_t sub_10014D7D4(uint64_t a1, sqlite3_stmt *a2, uint64_t a3)
{
  if (qword_10035CF58 != -1) {
    dispatch_once(&qword_10035CF58, &stru_1002FAF90);
  }
  CFStringRef v6 = (const __CFString *)qword_10035CF60;
  uint64_t v7 = *(CFTypeRef **)(a1 + 32);

  return sub_10000E8B0(a2, a3, v6, v7);
}

void sub_10014D850(uint64_t a1, __CFString ***a2)
{
  CFTypeRef cf = 0;
  if ((sub_10011A9B8((uint64_t)a2, kSecAttrMultiUser, *(const __CFData **)(a1 + 40), (__CFString **)&cf) & 1) == 0)
  {
    uint64_t v4 = sub_10000B070("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138478083;
      BOOL v11 = a2;
      __int16 v12 = 2112;
      CFTypeRef v13 = cf;
      int8x16_t v5 = "item: %{private}@ update musr to system failed: %@";
      goto LABEL_7;
    }
LABEL_8:
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
    goto LABEL_9;
  }
  if (!sub_10011D784(a2, (CFStringRef **)a2, *(void *)(a1 + 48), &cf, (uint64_t)&stru_100304518))
  {
    uint64_t v4 = sub_10000B070("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138478083;
      BOOL v11 = a2;
      __int16 v12 = 2112;
      CFTypeRef v13 = cf;
      int8x16_t v5 = "item: %{private}@ insert during UPDATE: %@";
LABEL_7:
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, v5, buf, 0x16u);
      goto LABEL_8;
    }
    goto LABEL_8;
  }
LABEL_9:
  CFStringRef v6 = (void *)cf;
  uint64_t v7 = *(CFErrorRef **)(a1 + 56);
  if (cf && v7)
  {
    if (!*v7) {
      goto LABEL_19;
    }
    if (CFErrorGetCode(*v7) == -25330)
    {
      CFErrorRef v8 = *v7;
      if (!*v7) {
        goto LABEL_19;
      }
      *uint64_t v7 = 0;
      CFRelease(v8);
    }
  }
  else
  {
    if (!cf) {
      return;
    }
    if (!v7) {
      goto LABEL_18;
    }
  }
  if (*v7)
  {
LABEL_18:
    CFRelease(v6);
    return;
  }
LABEL_19:
  *uint64_t v7 = (CFErrorRef)v6;
}

BOOL sub_10014DA0C(id a1, __CFString *a2, BOOL *a3)
{
  CFStringAppendFormat(a2, 0, @"musr = ?");
  return 1;
}

BOOL sub_10014DA50(id a1, const SecDbAttr *a2)
{
  return 0;
}

BOOL sub_10014DA58(id a1, const SecDbAttr *a2)
{
  return (LOBYTE(a2->var2) >> 1) & 1;
}

BOOL sub_10014DA64(id a1, const SecDbAttr *a2)
{
  return a2->var1 == 8;
}

uint64_t sub_10014DA74(uint64_t a1, uint64_t a2)
{
  uint64_t v10 = 0;
  BOOL v11 = &v10;
  uint64_t v12 = 0x2000000000;
  char v13 = 0;
  kdebug_trace();
  uint64_t v4 = sub_10000B070("transcrypt");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "begin", buf, 2u);
  }
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  v8[2] = sub_10014DC08;
  v8[3] = &unk_100304608;
  v8[4] = &v10;
  v8[5] = a1;
  void v8[6] = a2;
  sub_10000CBA4(1, 1, 0, a2, (uint64_t)v8);
  int8x16_t v5 = sub_10000B070("transcrypt");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "end", buf, 2u);
  }
  kdebug_trace();
  uint64_t v6 = *((unsigned __int8 *)v11 + 24);
  _Block_object_dispose(&v10, 8);
  return v6;
}

uint64_t sub_10014DC08(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[5];
  uint64_t v3 = (CFTypeRef *)a1[6];
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = sub_100142FBC;
  v6[3] = &unk_1003049C0;
  void v6[4] = v4;
  v6[5] = v3;
  void v6[6] = a2;
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = sub_1001381F8(a2, 2, v3, (uint64_t)v6);
  return *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
}

uint64_t sub_10014DCA8(int a1, uint64_t a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_10014DD28;
  v3[3] = &unk_100304628;
  int v4 = a1;
  v3[4] = a2;
  return sub_10000CBA4(1, 1, 0, a2, (uint64_t)v3);
}

BOOL sub_10014DD28(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = *(_DWORD *)(a1 + 40);
  *(void *)bytes = 0x114EC8A39FAB1A82;
  int v13 = -397635414;
  unsigned int v14 = bswap32(v4);
  CFDataRef v5 = CFDataCreate(0, bytes, 16);
  if (!v5) {
    return 0;
  }
  CFDataRef v6 = v5;
  unsigned int v7 = *(_DWORD *)(a1 + 40);
  *(void *)bytes = 0x104B57A5353A5AA7;
  int v13 = -1803342146;
  unsigned int v14 = bswap32(v7);
  CFDataRef v8 = CFDataCreate(0, bytes, 16);
  if (v8)
  {
    CFDataRef v9 = v8;
    BOOL v10 = sub_10013ABB8(a2, (uint64_t)v6, 0, *(CFTypeRef **)(a1 + 32))
       && sub_10013ABB8(a2, (uint64_t)v9, 0, *(CFTypeRef **)(a1 + 32));
    CFRelease(v6);
  }
  else
  {
    BOOL v10 = 0;
    CFDataRef v9 = v6;
  }
  CFRelease(v9);
  return v10;
}

uint64_t sub_10014DE60(void *a1, uint64_t a2, __CFString **a3)
{
  keys[0] = (void *)kSecClass;
  keys[1] = (void *)kSecReturnData;
  keys[2] = (void *)kSecMatchLimit;
  keys[3] = (void *)kSecAttrSubject;
  keys[4] = (void *)kSecAttrSynchronizable;
  values[0] = (void *)kSecClassCertificate;
  values[1] = kCFBooleanTrue;
  values[2] = (void *)kSecMatchLimitAll;
  values[3] = a1;
  values[4] = (void *)kSecAttrSynchronizableAny;
  CFDictionaryRef v5 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 5, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  uint64_t v11 = 0;
  v7[0] = 0;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  v7[1] = a2;
  LOBYTE(v8) = 1;
  sub_10000BA20(v5, (uint64_t)v7, &v11, a3);
  CFRelease(v5);
  return v11;
}

BOOL sub_10014DFA4(void *a1, void *a2, uint64_t a3, __CFString **a4)
{
  keys[0] = (void *)kSecClass;
  keys[1] = (void *)kSecMatchLimit;
  keys[2] = (void *)kSecAttrIssuer;
  keys[3] = (void *)kSecAttrSerialNumber;
  keys[4] = (void *)kSecAttrSynchronizable;
  values[0] = (void *)kSecClassCertificate;
  values[1] = (void *)kSecMatchLimitOne;
  values[2] = a1;
  values[3] = a2;
  values[4] = (void *)kSecAttrSynchronizableAny;
  v9[0] = 0;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  v9[1] = a3;
  LOBYTE(v10) = 1;
  CFDictionaryRef v5 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 5, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFTypeRef cf = 0;
  BOOL v6 = sub_10000BA20(v5, (uint64_t)v9, (uint64_t *)&cf, a4);
  if (v5) {
    CFRelease(v5);
  }
  if (cf) {
    CFRelease(cf);
  }
  return v6;
}

void sub_10014E86C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10014E898(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  long long v8 = WeakRetained;
  if (!v6)
  {
    long long v12 = [WeakRetained deps];
    int v13 = [v12 ckks];
    [v13 receiveTLKUploadRecords:v5];

    uint64_t v11 = [v8 intendedState];
LABEL_7:
    unsigned int v14 = (void *)v11;
    [v8 setNextState:v11];

    goto LABEL_15;
  }
  if ([v6 isCuttlefishError:1033])
  {
    long long v9 = sub_10000B070("octagon-ckks");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      long long v10 = [v8 ckksConflictState];
      int v18 = 138412290;
      id v19 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "A CKKS key hierarchy is out of date; moving to '%@'",
        (uint8_t *)&v18,
        0xCu);
    }
    uint64_t v11 = [v8 ckksConflictState];
    goto LABEL_7;
  }
  if ([v6 isCuttlefishError:1037])
  {
    unsigned int v15 = sub_10000B070("octagon-ckks");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v18) = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Cuttlefish reports we no longer exist.", (uint8_t *)&v18, 2u);
    }

    CFDataRef v16 = [v8 peerMissingState];
    [v8 setNextState:v16];
  }
  else
  {
    CFDataRef v16 = sub_10000B070("SecError");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      int v18 = 138412290;
      id v19 = v6;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "octagon: Error calling tlk upload: %@", (uint8_t *)&v18, 0xCu);
    }
  }

  [v8 setError:v6];
LABEL_15:
  CFDataRef v17 = [v8 finishedOp];
  [v8 runBeforeGroupFinished:v17];
}

void sub_10014EE60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  objc_destroyWeak(v21);
  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10014EEC0(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = sub_10000B070("octagon");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = [WeakRetained error];
    unsigned int v4 = (void *)v3;
    CFStringRef v5 = @"no error";
    if (v3) {
      CFStringRef v5 = (const __CFString *)v3;
    }
    int v6 = 138412290;
    CFStringRef v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Finishing an update TLKs operation with %@", (uint8_t *)&v6, 0xCu);
  }
}

void sub_10014EFA4(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v2 = [*(id *)(a1 + 32) viewKeySets];
  uint64_t v3 = [*(id *)(a1 + 32) pendingTLKShares];
  [WeakRetained proceedWithKeys:v2 pendingTLKShares:v3];
}

void sub_10014FE7C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10014FF54(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1001501D0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100150318(id a1)
{
  qword_10035D120 = objc_alloc_init(SecMetrics);

  _objc_release_x1();
}

void sub_1001504C4(uint64_t a1)
{
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v2 = *(void *)(a1 + 32);
    int v3 = 138412290;
    uint64_t v4 = v2;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "metrics URL is: %@", (uint8_t *)&v3, 0xCu);
  }
}

void sub_100150614(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 24));
  _Unwind_Resume(a1);
}

void sub_100150630(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  long long v7 = 0u;
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  uint64_t v2 = [WeakRetained dependencies];
  id v3 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v8;
    do
    {
      int v6 = 0;
      do
      {
        if (*(void *)v8 != v5) {
          objc_enumerationMutation(v2);
        }
        [WeakRetained removeDependency:*(void *)(*((void *)&v7 + 1) + 8 * (void)v6)];
        int v6 = (char *)v6 + 1;
      }
      while (v4 != v6);
      id v4 = [v2 countByEnumeratingWithState:&v7 objects:v11 count:16];
    }
    while (v4);
  }
}

BOOL sub_100150C1C(id a1, id a2, unint64_t a3, BOOL *a4)
{
  return [a2 isFinished:a3, a4] ^ 1;
}

void sub_100150D9C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100150F54(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100152674(id a1)
{
  sub_10002BAD8(@"ckks_analytics_v2.db", (uint64_t)&stru_100304F10);
  sub_10002BAD8(@"ckks_analytics_v2.db-wal", (uint64_t)&stru_100304F30);

  sub_10002BAD8(@"ckks_analytics_v2.db-shm", (uint64_t)&stru_100304F50);
}

void sub_1001526D0(id a1, const char *a2)
{
}

void sub_1001526D8(id a1, const char *a2)
{
}

void sub_1001526E0(id a1, const char *a2)
{
}

void sub_100152904(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

uint64_t sub_100152928(uint64_t a1)
{
  unsigned int v2 = [*(id *)(a1 + 32) isCancelled];
  uint64_t v39 = a1;
  id v3 = [*(id *)(a1 + 32) viewState];
  id v4 = [v3 zoneID];
  uint64_t v5 = [v4 zoneName];
  int v6 = sub_1000CD884(@"ckkscurrent", v5);

  os_log_t log = v6;
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v7)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "CKKSDeleteCurrentItemPointersOperation cancelled, quitting", buf, 2u);
    }
    uint64_t v8 = 0;
  }
  else
  {
    if (v7)
    {
      long long v9 = [*(id *)(v39 + 32) identifiers];
      *(_DWORD *)long long buf = 134217984;
      id v51 = [v9 count];
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Deleting current item pointers (%lu)", buf, 0xCu);
    }
    os_log_t log = (os_log_t)objc_alloc_init((Class)NSMutableArray);
    long long v48 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v45 = 0u;
    id obj = [*(id *)(v39 + 32) identifiers];
    id v10 = [obj countByEnumeratingWithState:&v45 objects:v49 count:16];
    if (v10)
    {
      uint64_t v11 = *(void *)v46;
      do
      {
        for (CFIndex i = 0; i != v10; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v46 != v11) {
            objc_enumerationMutation(obj);
          }
          uint64_t v13 = *(void *)(*((void *)&v45 + 1) + 8 * i);
          unsigned int v14 = [*(id *)(v39 + 32) accessGroup];
          unsigned int v15 = +[NSString stringWithFormat:@"%@-%@", v14, v13];

          id v16 = objc_alloc((Class)CKRecordID);
          CFDataRef v17 = [*(id *)(v39 + 32) viewState];
          int v18 = [v17 zoneID];
          id v19 = [v16 initWithRecordName:v15 zoneID:v18];

          [log addObject:v19];
        }
        id v10 = [obj countByEnumeratingWithState:&v45 objects:v49 count:16];
      }
      while (v10);
    }

    id v20 = objc_alloc_init((Class)NSBlockOperation);
    [v20 setName:@"deleteCurrentItemPointers-modifyRecordsComplete"];
    [*(id *)(v39 + 32) dependOnBeforeGroupFinished:v20];
    id v21 = [objc_alloc((Class)CKModifyRecordsOperation) initWithRecordsToSave:0 recordIDsToDelete:log];
    [*(id *)(v39 + 32) setModifyRecordsOperation:v21];

    uint64_t v22 = [*(id *)(v39 + 32) modifyRecordsOperation];
    [v22 setAtomic:1];

    uint64_t v23 = [*(id *)(v39 + 32) modifyRecordsOperation];
    uint64_t v24 = [v23 configuration];
    [v24 setIsCloudKitSupportOperation:1];

    unsigned int v25 = [*(id *)(v39 + 32) modifyRecordsOperation];
    [v25 setQualityOfService:25];

    uint64_t v26 = [*(id *)(v39 + 32) ckoperationGroup];
    CFTypeRef v27 = [*(id *)(v39 + 32) modifyRecordsOperation];
    [v27 setGroup:v26];

    v43[0] = _NSConcreteStackBlock;
    v43[1] = 3221225472;
    v43[2] = sub_100152E9C;
    v43[3] = &unk_100304F78;
    objc_copyWeak(&v44, (id *)(v39 + 40));
    CFRange v28 = [*(id *)(v39 + 32) modifyRecordsOperation];
    [v28 setPerRecordDeleteBlock:v43];

    v40[0] = _NSConcreteStackBlock;
    v40[1] = 3221225472;
    v40[2] = sub_10015302C;
    v40[3] = &unk_100304FC8;
    objc_copyWeak(&v42, (id *)(v39 + 40));
    id v29 = v20;
    id v41 = v29;
    CFRange v30 = [*(id *)(v39 + 32) modifyRecordsOperation];
    [v30 setModifyRecordsCompletionBlock:v40];

    CFRange v31 = *(void **)(v39 + 32);
    CFRange v32 = [v31 modifyRecordsOperation];
    [v31 dependOnBeforeGroupFinished:v32];

    CFRange v33 = [*(id *)(v39 + 32) deps];
    uint64_t v34 = [v33 ckdatabase];
    CFRange v35 = [*(id *)(v39 + 32) modifyRecordsOperation];
    [v34 addOperation:v35];

    objc_destroyWeak(&v42);
    objc_destroyWeak(&v44);

    uint64_t v8 = 1;
  }

  return v8;
}

void sub_100152E6C(_Unwind_Exception *a1)
{
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_100152E9C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v8 = [WeakRetained viewState];
  long long v9 = [v8 zoneID];
  id v10 = [v9 zoneName];
  uint64_t v11 = sub_1000CD884(@"ckkscurrent", v10);

  if (v6)
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      int v13 = 138412546;
      id v14 = v6;
      __int16 v15 = 2112;
      id v16 = v5;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "error on row: %@ %@", (uint8_t *)&v13, 0x16u);
    }
  }
  else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    long long v12 = [v5 recordName];
    int v13 = 138412290;
    id v14 = v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Current pointer delete successful for %@", (uint8_t *)&v13, 0xCu);
  }
}

void sub_10015302C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v11 = [WeakRetained deps];
  long long v12 = [v11 databaseProvider];

  if (v9)
  {
    int v13 = [WeakRetained viewState];
    id v14 = [v13 zoneID];
    __int16 v15 = [v14 zoneName];
    id v16 = sub_1000CD884(@"ckkscurrent", v15);

    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v9;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "CloudKit returned an error: %@", (uint8_t *)&buf, 0xCu);
    }

    [WeakRetained setError:v9];
    CFDataRef v17 = [WeakRetained operationQueue];
    [v17 addOperation:*(void *)(a1 + 32)];
  }
  else
  {
    *(void *)&long long buf = 0;
    *((void *)&buf + 1) = &buf;
    uint64_t v24 = 0x3032000000;
    unsigned int v25 = sub_1001532C0;
    uint64_t v26 = sub_1001532D0;
    id v27 = 0;
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 3221225472;
    v19[2] = sub_1001532D8;
    v19[3] = &unk_100304FA0;
    id v20 = v8;
    id v21 = WeakRetained;
    p_long long buf = &buf;
    [v12 dispatchSyncWithSQLTransaction:v19];
    [WeakRetained setError:*(void *)(*((void *)&buf + 1) + 40)];
    int v18 = [WeakRetained operationQueue];
    [v18 addOperation:*(void *)(a1 + 32)];

    _Block_object_dispose(&buf, 8);
  }
}

void sub_1001532A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001532C0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1001532D0(uint64_t a1)
{
}

uint64_t sub_1001532D8(uint64_t a1)
{
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v24 objects:v32 count:16];
  if (v3)
  {
    id v5 = v3;
    uint64_t v6 = *(void *)v25;
    *(void *)&long long v4 = 138412546;
    long long v22 = v4;
    do
    {
      id v7 = 0;
      do
      {
        if (*(void *)v25 != v6) {
          objc_enumerationMutation(v2);
        }
        id v8 = *(void **)(*((void *)&v24 + 1) + 8 * (void)v7);
        id v9 = [*(id *)(a1 + 40) deps:v22];
        id v10 = [v9 contextID];
        uint64_t v11 = *(void *)(*(void *)(a1 + 48) + 8);
        id obj = *(id *)(v11 + 40);
        unsigned __int8 v12 = +[CKKSCurrentItemPointer intransactionRecordDeleted:v8 contextID:v10 resync:0 error:&obj];
        objc_storeStrong((id *)(v11 + 40), obj);

        if ((v12 & 1) == 0)
        {
          int v13 = [*(id *)(a1 + 40) viewState];
          id v14 = [v13 zoneID];
          __int16 v15 = [v14 zoneName];
          id v16 = sub_1000CD884(@"ckkscurrent", v15);

          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            CFDataRef v17 = [v8 recordName];
            uint64_t v18 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
            *(_DWORD *)long long buf = v22;
            id v29 = v17;
            __int16 v30 = 2112;
            uint64_t v31 = v18;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Couldn't delete current item pointer for %@ from database: %@", buf, 0x16u);
          }
          [*(id *)(a1 + 40) setError:*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40)];
        }
        id v19 = [*(id *)(a1 + 40) viewState];
        id v20 = [v19 notifyViewChangedScheduler];
        [v20 trigger];

        id v7 = (char *)v7 + 1;
      }
      while (v5 != v7);
      id v5 = [v2 countByEnumeratingWithState:&v24 objects:v32 count:16];
    }
    while (v5);
  }

  return 1;
}

uint64_t sub_100153C18(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
    return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
  }
  while (2)
  {
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0;
    while (1)
    {
      unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v7 == -1 || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v8 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
      v6 |= (unint64_t)(v8 & 0x7F) << v4;
      if ((v8 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v9 = v5++ >= 9;
      if (v9)
      {
        unint64_t v6 = 0;
        int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }
    *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0;
    }
LABEL_13:
    if (v10 || (v6 & 7) == 4) {
      return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    switch((v6 >> 3))
    {
      case 1u:
        uint64_t v12 = PBReaderReadString();
        uint64_t v13 = 24;
        goto LABEL_29;
      case 2u:
        char v15 = 0;
        unsigned int v16 = 0;
        uint64_t v17 = 0;
        *(unsigned char *)(a1 + 40) |= 1u;
        while (2)
        {
          unint64_t v18 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v18 == -1 || v18 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }
          else
          {
            char v19 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v18);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v18 + 1;
            v17 |= (unint64_t)(v19 & 0x7F) << v15;
            if (v19 < 0)
            {
              v15 += 7;
              BOOL v9 = v16++ >= 9;
              if (v9)
              {
                uint64_t v17 = 0;
                goto LABEL_36;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v17 = 0;
        }
LABEL_36:
        *(void *)(a1 + 8) = v17;
        goto LABEL_37;
      case 3u:
        uint64_t v12 = PBReaderReadString();
        uint64_t v13 = 16;
LABEL_29:
        id v20 = *(void **)(a1 + v13);
        *(void *)(a1 + v13) = v12;

        goto LABEL_37;
      case 4u:
        id v21 = objc_alloc_init(SECC2MPError);
        objc_storeStrong((id *)(a1 + 32), v21);
        if PBReaderPlaceMark() && (sub_100153C18(v21, a2))
        {
          PBReaderRecallMark();

LABEL_37:
          if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
          }
          continue;
        }

        return 0;
      default:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_37;
    }
  }
}

uint64_t sub_100154158(const void *a1, uint64_t a2, const void *a3, unsigned int a4, uint64_t a5, _DWORD *a6, __CFData *a7, uint64_t a8, uint64_t a9, __CFString **a10)
{
  uint64_t v17 = (void **)sub_100018BB8(0);
  uint64_t v54 = v17;
  theCFDataRef Data = 0;
  CFTypeRef v53 = 0;
  uint64_t v50 = 0;
  id v51 = 0;
  if (!v17)
  {
    return sub_100012A40(-108, a10, @"ks_crypt_diversify: failed to create aks_params");
  }
  unint64_t v18 = v17;
  sub_100018E2C(v17, 15, a8);
  sub_100018F28(v18, &v51, (size_t *)&v50);
  *(void *)long long v48 = 0;
  rsize_t __n = 0;
  if (CFEqual(a1, @"oe"))
  {
    uint64_t v19 = a2;
    int v20 = a2;
    id v21 = a3;
    uint64_t v22 = sub_100018F90(v20, (int)a3, 0, (uint64_t)v51, v50, &v53);
    if (v22 || (uint64_t v22 = sub_100019EF4((uint64_t *)v53, (uint64_t)v51, v50, a5), v22))
    {
      uint64_t v37 = v22;
      long long v24 = a10;
      goto LABEL_20;
    }
    CFTypeRef cf = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
    uint64_t v23 = (const UInt8 *)sub_10001A1FC((uint64_t *)v53, &cf);
    long long v24 = a10;
    if (v23)
    {
      if (!sub_100154600(*(UInt8 **)v48, __n, v23, (CFIndex)cf, a7))
      {
        if (v51) {
          free(v51);
        }
        sub_100018F2C(&v54);
        uint64_t v43 = a3;
        uint64_t v44 = v19;
        uint64_t v42 = (uint64_t)"encrypt";
        CFStringRef v38 = @"ks_crypt_diversify: failed to '%s' item (class %d, bag: %d) Item can't be encrypted due to merge failed, so drop the item.";
        goto LABEL_56;
      }
      *a6 = a3;
    }
  }
  else
  {
    uint64_t v19 = a2;
    if (!CFEqual(a1, @"od") && !CFEqual(a1, @"odel"))
    {
      uint64_t v37 = 3758097090;
      long long v24 = a10;
      id v21 = a3;
      goto LABEL_20;
    }
    CFIndex v26 = a4;
    long long v24 = a10;
    if ((sub_100154750(a2, a5, v26, (uint64_t *)&v53, (CFTypeRef *)&theData, a10) & 1) == 0)
    {
      if (v51) {
        free(v51);
      }
      sub_100018F2C(&v54);
      uint64_t v42 = a2;
      CFStringRef v38 = @"ks_crypt_diversify: failed to create ref key with blob because bad data (bag: %d)";
      goto LABEL_56;
    }
    id v21 = a3;
    long long v27 = (uint64_t *)v53;
    uint64_t v29 = v50;
    CFRange v28 = v51;
    BytePtr = CFDataGetBytePtr(theData);
    CFIndex Length = CFDataGetLength(theData);
    uint64_t v32 = sub_10001A078(v27, (uint64_t)v28, v29, (uint64_t)BytePtr, Length);
    if (v32)
    {
      uint64_t v37 = v32;
      goto LABEL_20;
    }
    CFTypeRef cf = 0;
    sub_10000F124(0, (int)&cf, (CFTypeRef *)a10, *(uint64_t *)v48, *(void *)v48 + __n);
    CFDataRef v33 = (const __CFData *)cf;
    CFTypeID v34 = CFGetTypeID(cf);
    if (v34 == CFDataGetTypeID())
    {
      CFDataSetLength(a7, 0);
      CFRange v35 = CFDataGetBytePtr(v33);
      CFIndex v36 = CFDataGetLength(v33);
      CFDataAppendBytes(a7, v35, v36);
    }
    if (v33) {
      CFRelease(v33);
    }
  }
  uint64_t v37 = 0;
LABEL_20:
  if (v51) {
    free(v51);
  }
  if (v54) {
    sub_100018F2C(&v54);
  }
  if (*(void *)v48) {
    sub_10001A240(*(void **)v48, __n);
  }
  if (v53) {
    sub_100019344((uint64_t *)&v53);
  }
  if (theData) {
    CFRelease(theData);
  }
  if ((int)v37 > -536870161)
  {
    if ((int)v37 > -536362975)
    {
      if (v37 != -536362974)
      {
        if (!v37) {
          return 1;
        }
        goto LABEL_58;
      }
      uint64_t v44 = (uint64_t)v21;
      uint64_t v45 = v19;
      uint64_t v42 = 3758604322;
      uint64_t v43 = a1;
      CFStringRef v38 = @"ks_crypt_diversify: %x failed to '%@' item (class %d, bag: %d) Persona doesn't exist, so drop the item.";
LABEL_56:
      int v41 = -26275;
      return sub_100012A40(v41, v24, v38, v42, v43, v44, v45);
    }
    if (v37 == -536870160)
    {
      uint64_t v44 = (uint64_t)v21;
      uint64_t v45 = v19;
      uint64_t v42 = 3758097136;
      uint64_t v43 = a1;
      CFStringRef v38 = @"ks_crypt_diversify: %x failed to '%@' item (class %d, bag: %d) No key available for class.";
LABEL_59:
      int v41 = -25291;
      return sub_100012A40(v41, v24, v38, v42, v43, v44, v45);
    }
    if (v37 != -536362989)
    {
LABEL_58:
      uint64_t v44 = (uint64_t)v21;
      uint64_t v45 = v19;
      uint64_t v42 = v37;
      uint64_t v43 = a1;
      CFStringRef v38 = @"ks_crypt_diversify: %x failed to '%@' item (class %d, bag: %d)";
      goto LABEL_59;
    }
LABEL_53:
    uint64_t v44 = (uint64_t)v21;
    uint64_t v45 = v19;
    uint64_t v42 = v37;
    uint64_t v43 = a1;
    CFStringRef v38 = @"ks_crypt_diversify: %x failed to '%@' item (class %d, bag: %d) Item can't be decrypted on this device, ever, so drop the item.";
    goto LABEL_56;
  }
  if (v37 == -536870212) {
    goto LABEL_53;
  }
  if (v37 != -536870207 && v37 != -536870174) {
    goto LABEL_58;
  }
  BOOL v39 = v21 == 10 || v21 == 7;
  unsigned __int8 v40 = "";
  if (v39) {
    unsigned __int8 v40 = " (hibernation?)";
  }
  return sub_100012A40(-25308, v24, @"ks_crypt_diversify: %x failed to '%@' item (class %d, bag: %d) Access to item attempted while keychain is locked%s.", v37, a1, v21, v19, v40);
}

BOOL sub_100154600(UInt8 *bytes, CFIndex length, const UInt8 *a3, CFIndex a4, __CFData *a5)
{
  CFDataRef v8 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, bytes, length, kCFAllocatorNull);
  CFDataRef v9 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, a3, a4, kCFAllocatorNull);
  CFDataRef v17 = v9;
  if (v8) {
    BOOL v18 = v9 == 0;
  }
  else {
    BOOL v18 = 1;
  }
  if (!v18)
  {
    CFStringRef v22 = (const __CFString *)sub_100139704(kCFAllocatorDefault, v10, v11, v12, v13, v14, v15, v16, @"d1", (uint64_t)v8);
    CFDataSetLength(a5, 0);
    CFIndex v26 = sub_1000298CC(v22, 0, v23, v24, v25);
    BOOL v19 = (BOOL)v26;
    if (v26)
    {
      BytePtr = CFDataGetBytePtr(v26);
      CFIndex v28 = CFDataGetLength((CFDataRef)v19);
      CFDataAppendBytes(a5, BytePtr, v28);
      CFRelease((CFTypeRef)v19);
      BOOL v19 = CFDataGetLength(a5) > 0;
    }
    CFRelease(v22);
LABEL_13:
    CFRelease(v8);
    BOOL v20 = v19;
    if (!v17) {
      return v20;
    }
    goto LABEL_8;
  }
  BOOL v19 = 0;
  BOOL v20 = 0;
  if (v8) {
    goto LABEL_13;
  }
  if (v9) {
LABEL_8:
  }
    CFRelease(v17);
  return v20;
}

uint64_t sub_100154750(uint64_t a1, uint64_t a2, CFIndex a3, uint64_t *a4, CFTypeRef *a5, __CFString **a6)
{
  CFTypeRef v26 = 0;
  CFTypeRef cf = 0;
  CFDataRef v25 = 0;
  int v11 = (const UInt8 *)(a2 + a3);
  uint64_t v12 = sub_10000F124(0, (int)&cf, 0, a2, a2 + a3);
  if (!v12 || (const UInt8 *)v12 != v11)
  {
    sub_100012A40(-26275, a6, @"encrypted_data_from_blob: NULL 'blob data'");
    CFDataRef v15 = 0;
    uint64_t v16 = 0;
    CFTypeRef v13 = cf;
    if (!cf) {
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  CFTypeRef v13 = cf;
  CFTypeID v14 = CFGetTypeID(cf);
  if (v14 != CFDictionaryGetTypeID())
  {
    CFTypeID v18 = CFGetTypeID(v13);
    CFStringRef v19 = CFCopyTypeIDDescription(v18);
    BOOL v20 = (__CFString *)CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"encrypted_data_from_blob: Bad object type %@ for 'blob data'", v19);
    sub_100012A40(-26276, a6, @"%@", v20);
    sub_10002BBA0(v20, 0x53C00002u);
    if (v19) {
      CFRelease(v19);
    }
    if (v20) {
      CFRelease(v20);
    }
    CFDataRef v15 = 0;
LABEL_18:
    uint64_t v16 = 0;
    if (!v13) {
      goto LABEL_8;
    }
LABEL_7:
    CFRelease(v13);
    goto LABEL_8;
  }
  if (sub_100154980((const __CFDictionary *)v13, (CFTypeRef *)&v25, &v26))
  {
    CFDataRef v15 = v25;
  }
  else
  {
    CFDataRef v15 = CFDataCreate(kCFAllocatorDefault, v11, a3);
    CFTypeRef v26 = CFRetain(v15);
  }
  if (!v15)
  {
    sub_100012A40(-26275, a6, @"encrypted_data_from_blob: failed to decode 'encrypted data'");
    goto LABEL_18;
  }
  CFDataRef v21 = (const __CFData *)v26;
  if (!v26)
  {
    sub_100012A40(-26275, a6, @"encrypted_data_from_blob: failed to decode 'key data'");
    goto LABEL_18;
  }
  BytePtr = CFDataGetBytePtr((CFDataRef)v26);
  size_t Length = CFDataGetLength(v21);
  uint64_t v24 = sub_1000193F8(a1, BytePtr, Length, a4);
  if (v24)
  {
    sub_100012A40(-26275, a6, @"aks_ref_key: failed to create ref key with blob: %x (bag: %d)", v24, a1);
    goto LABEL_18;
  }
  if (a5) {
    *a5 = CFRetain(v15);
  }
  uint64_t v16 = 1;
  if (v13) {
    goto LABEL_7;
  }
LABEL_8:
  if (v26) {
    CFRelease(v26);
  }
  if (v15) {
    CFRelease(v15);
  }
  return v16;
}

uint64_t sub_100154980(const __CFDictionary *a1, CFTypeRef *a2, CFTypeRef *a3)
{
  CFStringRef Value = CFDictionaryGetValue(a1, @"d1");
  unint64_t v7 = CFDictionaryGetValue(a1, @"d2");
  if (Value) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8) {
    return 0;
  }
  CFDataRef v9 = v7;
  CFTypeID TypeID = CFDataGetTypeID();
  if (TypeID != CFGetTypeID(Value)) {
    return 0;
  }
  CFTypeID v11 = CFDataGetTypeID();
  if (v11 != CFGetTypeID(v9)) {
    return 0;
  }
  *a2 = CFRetain(Value);
  *a3 = CFRetain(v9);
  return 1;
}

void sub_100154A3C(CFErrorRef *a1, uint64_t a2)
{
  if (a1)
  {
    char v4 = *a1;
    if (!v4) {
      goto LABEL_10;
    }
    if (CFErrorGetCode(v4) != -25330) {
      return;
    }
    if (*a1)
    {
      CFDictionaryRef v5 = CFErrorCopyUserInfo(*a1);
      MutableCFArrayRef Copy = CFDictionaryCreateMutableCopy(0, 0, v5);
      CFRelease(v5);
      CFErrorRef v7 = *a1;
      if (*a1)
      {
        *a1 = 0;
        CFRelease(v7);
      }
      if (a2) {
        goto LABEL_8;
      }
    }
    else
    {
LABEL_10:
      MutableCFArrayRef Copy = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (a2)
      {
LABEL_8:
        uint64_t valuePtr = -25330;
        CFNumberRef v8 = CFNumberCreate(0, kCFNumberCFIndexType, &valuePtr);
        CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(MutableCopy, v8);
        if (Value) {
          CFMutableArrayRef Mutable = CFArrayCreateMutableCopy(0, 0, Value);
        }
        else {
          CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
        }
        BOOL v20 = Mutable;
        CFArrayRef v21 = sub_100154BE0((uint64_t)Mutable, v11, v12, v13, v14, v15, v16, v17, a2);
        CFArrayAppendValue(v20, v21);
        CFRelease(v21);
        CFDictionarySetValue(MutableCopy, v8, v20);
        CFRelease(v8);
        CFRelease(v20);
        CFStringRef v18 = kCFErrorDomainOSStatus;
        CFDictionaryRef v19 = MutableCopy;
        goto LABEL_14;
      }
    }
    CFStringRef v18 = kCFErrorDomainOSStatus;
    CFDictionaryRef v19 = 0;
LABEL_14:
    *a1 = CFErrorCreate(0, v18, -25330, v19);
    if (MutableCopy) {
      CFRelease(MutableCopy);
    }
  }
}

CFArrayRef sub_100154BE0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  CFStringRef v18 = &a9;
  CFIndex v9 = -1;
  do
  {
    int v10 = v18++;
    ++v9;
  }
  while (*v10);
  CFDictionaryRef v19 = (const __CFNull **)&a9;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, v9, &kCFTypeArrayCallBacks);
  if (!Mutable) {
    return 0;
  }
  for (CFIndex i = Mutable; v9; --v9)
  {
    uint64_t v13 = v19++;
    CFNullRef v14 = *v13;
    if (v14) {
      CFNullRef v15 = v14;
    }
    else {
      CFNullRef v15 = kCFNull;
    }
    CFArrayAppendValue(i, v15);
  }
  CFArrayRef Copy = CFArrayCreateCopy(0, i);
  CFRelease(i);
  return Copy;
}

void sub_100154CB4(uint64_t a1, CFTypeRef cf1, uint64_t a3, uint64_t a4, uint64_t a5, const __CFData *a6, __CFString **a7)
{
  if (CFEqual(cf1, @"od"))
  {
    CFNullRef v14 = "decrypt";
  }
  else if (CFEqual(cf1, @"oe"))
  {
    CFNullRef v14 = "encrypt";
  }
  else
  {
    CFNullRef v14 = "";
  }
  int v15 = CFEqual(cf1, @"odel");
  uint64_t v16 = "delete";
  if (!v15) {
    uint64_t v16 = v14;
  }
  if ((int)a1 <= -536870161)
  {
    switch(a1)
    {
      case 0xE00002BC:
LABEL_19:
        sub_100012A40(-26275, a7, @"aks_ref_key: %x failed to '%s' item (class %d, bag: %d) Item can't be decrypted on this device, ever, so drop the item.", a1, v16, a4, a3);
        return;
      case 0xE00002CE:
        goto LABEL_20;
      case 0xE00002E2:
        sub_100012A40(-25308, a7, @"aks_ref_key: %x failed to '%s' item (class %d, bag: %d) Access to item attempted while keychain is locked.", 3758097122, v16, a4, a3);
        return;
    }
LABEL_28:
    sub_100012A40(-25291, a7, @"aks_ref_key: %x failed to '%s' item (class %d, bag: %d)", a1, v16, a4, a3);
    return;
  }
  if ((int)a1 > -536363000)
  {
    if (a1 == -536362999 || a1 == -536362989) {
      goto LABEL_19;
    }
    goto LABEL_28;
  }
  if (a1 == -536870160)
  {
    sub_100012A40(-25291, a7, @"ks_crypt: %x failed to '%@' item (class %d, bag: %d) No key available for class.", 3758097136, cf1, a4, a3);
    return;
  }
  if (a1 != -536363000) {
    goto LABEL_28;
  }
LABEL_20:
  if (a1 == -536870194)
  {
    if (a6)
    {
      BytePtr = (UInt8 *)CFDataGetBytePtr(a6);
      CFIndex Length = CFDataGetLength(a6);
      CFDictionaryRef v19 = ACMContextCreateWithExternalForm(BytePtr, Length);
      if (v19)
      {
        BOOL v20 = v19;
        ACMContextRemovePassphraseCredentialsByPurposeAndScope(v19, 0, 1);
        ACMContextDelete(v20, 0);
      }
    }
  }

  sub_100154A3C((CFErrorRef *)a7, a5);
}

uint64_t sub_100154F18(uint64_t *a1, const __CFData *a2, __CFData *a3, const __CFData *a4, CFDataRef theData, uint64_t a6, __CFString **a7)
{
  CFDataRef Length = theData;
  uint64_t v31 = 0;
  uint64_t v32 = 0;
  if (theData)
  {
    BytePtr = CFDataGetBytePtr(theData);
    CFDataRef Length = (const __CFData *)CFDataGetLength(Length);
  }
  else
  {
    BytePtr = 0;
  }
  uint64_t v29 = 0;
  uint64_t v30 = 0;
  CFNullRef v14 = (const void *)SecAccessControlCopyData();
  if (a4)
  {
    int v15 = CFDataGetBytePtr(a4);
    CFIndex v16 = CFDataGetLength(a4);
    sub_100018A78((uint64_t)BytePtr, (uint64_t)Length, 0, 0, (uint64_t)v15, v16, &v32, &v30);
    uint64_t v17 = v32;
    uint64_t v18 = v30;
    CFDictionaryRef v19 = (UInt8 *)CFDataGetBytePtr(a2);
    size_t v20 = CFDataGetLength(a2);
    uint64_t v21 = sub_1000194C0(a1, (uint64_t)v17, v18, v19, v20);
    if (v21)
    {
      sub_100154CB4(v21, @"od", 0, 0, (uint64_t)v14, a4, a7);
    }
    else if (v31)
    {
      CFTypeRef cf = 0;
      sub_10000F124((int)kCFAllocatorDefault, (int)&cf, 0, (uint64_t)v31, (uint64_t)v31 + v29);
      CFDataRef v22 = (const __CFData *)cf;
      if (cf)
      {
        CFTypeID v23 = CFGetTypeID(cf);
        if (v23 == CFDataGetTypeID())
        {
          CFDataSetLength(a3, 0);
          uint64_t v24 = CFDataGetBytePtr(v22);
          CFIndex v25 = CFDataGetLength(v22);
          CFDataAppendBytes(a3, v24, v25);
          CFRelease(v22);
          uint64_t v26 = 1;
          goto LABEL_13;
        }
        CFRelease(v22);
        sub_100012A40(-26275, a7, @"ks_crypt_acl: %x failed to '%s' item, Item can't be decrypted due to wrong data, so drop the item.", 0, "decrypt");
      }
      else
      {
        sub_100012A40(-26275, a7, @"ks_crypt_acl: %x failed to '%s' item, Item can't be decrypted due to failed decode der, so drop the item.", 0, "decrypt");
      }
    }
    else
    {
      sub_100012A40(-26275, a7, @"ks_crypt_acl: %x failed to '%s' item, Item can't be decrypted due to invalid der data, so drop the item.", 0, "decrypt");
    }
  }
  else
  {
    sub_100154A3C((CFErrorRef *)a7, 0);
  }
  uint64_t v26 = 0;
LABEL_13:
  if (v32) {
    free(v32);
  }
  if (v31) {
    free(v31);
  }
  if (v14) {
    CFRelease(v14);
  }
  return v26;
}

uint64_t sub_100155178(uint64_t *a1, const __CFData *a2, const __CFData *Length, uint64_t a4, CFErrorRef *a5)
{
  size_t v20 = 0;
  CFBooleanRef Constraint = (const __CFBoolean *)SecAccessControlGetConstraint();
  if (Constraint) {
    BOOL v10 = kCFBooleanTrue == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (v10)
  {
    if (Constraint != kCFBooleanTrue) {
      goto LABEL_9;
    }
LABEL_7:
    uint64_t v11 = 0;
LABEL_15:
    uint64_t v14 = 1;
    goto LABEL_16;
  }
  if (CFEqual(Constraint, kCFBooleanTrue)) {
    goto LABEL_7;
  }
LABEL_9:
  if (!a2)
  {
    sub_100154A3C(a5, 0);
    uint64_t v14 = 0;
    uint64_t v11 = 0;
    goto LABEL_16;
  }
  uint64_t v11 = (const void *)SecAccessControlCopyData();
  if (Length)
  {
    BytePtr = CFDataGetBytePtr(Length);
    CFDataRef Length = (const __CFData *)CFDataGetLength(Length);
  }
  else
  {
    BytePtr = 0;
  }
  uint64_t v19 = 0;
  int v15 = CFDataGetBytePtr(a2);
  CFIndex v16 = CFDataGetLength(a2);
  sub_100018A78((uint64_t)BytePtr, (uint64_t)Length, 0, 0, (uint64_t)v15, v16, &v20, &v19);
  uint64_t v17 = sub_100019754(a1, (uint64_t)v20);
  if (!v17) {
    goto LABEL_15;
  }
  sub_100154CB4(v17, @"odel", 0, 0, (uint64_t)v11, a2, (__CFString **)a5);
  uint64_t v14 = 0;
LABEL_16:
  if (v20) {
    free(v20);
  }
  if (v11) {
    CFRelease(v11);
  }
  return v14;
}

void sub_1001552F4(id a1)
{
  int v4 = -1;
  if (sub_10001B118(0, &v4))
  {
    int v1 = MKBGetDeviceLockState();
    id v2 = sub_10000B070("aks");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 67109120;
      int v6 = v1;
      _os_log_debug_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "AppleKeyStore lock state: %d", buf, 8u);
    }
  }
  byte_10035D138 = 1;
  id v3 = sub_10000B070("aks");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long buf = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "using hwaes key", buf, 2u);
  }
}

BOOL sub_100155410(const __CFData *cf, const __CFData *a2, int *a3, CFTypeRef *a4)
{
  if (cf && (CFTypeID v8 = CFGetTypeID(cf), v8 == CFDataGetTypeID()))
  {
    BytePtr = CFDataGetBytePtr(cf);
    int Length = CFDataGetLength(cf);
    int v11 = sub_10001AB64(BytePtr, Length, a3);
    if (v11)
    {
      return sub_100029664(v11, a4, @"aks_load_bag failed: %@", cf);
    }
    else if (a2 {
           && (int v13 = *a3,
    }
               uint64_t v14 = CFDataGetBytePtr(a2),
               int v15 = CFDataGetLength(a2),
               (int v16 = sub_10001AA64(v13, (uint64_t)v14, v15)) != 0))
    {
      int v17 = v16;
      sub_10001AC80(*a3);
      return sub_100029664(v17, a4, @"aks_unlock_bag failed");
    }
    else
    {
      return 1;
    }
  }
  else
  {
    if (a4) {
      sub_100012A40(-50, (__CFString **)a4, @"object %@ is not a data", cf);
    }
    return 0;
  }
}

BOOL sub_10015554C(int a1, CFTypeRef *a2)
{
  int v3 = sub_10001AC80(a1);
  if (!v3) {
    return 1;
  }

  return sub_100029664(v3, a2, @"aks_unload_bag failed");
}

CFMutableArrayRef sub_1001555A0()
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v1 = Mutable;
  if (qword_10035CB60)
  {
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = sub_100024D28;
    block[3] = &unk_1002F7290;
    block[4] = Mutable;
    if (qword_10035CB80 != -1) {
      dispatch_once(&qword_10035CB80, &stru_1002F7310);
    }
    dispatch_sync((dispatch_queue_t)qword_10035CB78, block);
  }
  return v1;
}

BOOL sub_100155674(const __CFString *a1, __CFString **a2)
{
  if (a1)
  {
    CFTypeID v4 = CFGetTypeID(a1);
    if (v4 == CFStringGetTypeID())
    {
      sub_10002577C(a1, 3);
      return 1;
    }
    CFTypeID v5 = CFGetTypeID(a1);
    if (v5 == CFDictionaryGetTypeID())
    {
      sub_1000250A8((const __CFDictionary *)a1, 3);
      return 1;
    }
  }

  return sub_100012A40(-50, a2, @"Unsupported CFType");
}

id sub_100155720(uint64_t a1, uint64_t a2)
{
  CFTypeID v4 = sub_10021C7D8();
  CFTypeID v5 = v4;
  if (v4)
  {
    id v6 = v4;
    CFErrorRef v7 = [v6 circle_transport];

    if (v7)
    {
      CFTypeID v8 = [v6 circle_transport];
      id v9 = [v8 kvssendDebugInfo:@"Scope" debug:a1 err:a2];
    }
    else
    {
      id v9 = 0;
    }
  }
  else
  {
    id v9 = 0;
  }

  return v9;
}

void sub_1001557C8(id a1, NSError *a2)
{
  id v2 = sub_10000B070("keychainitemupgrade");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "kicking off keychain item upgrade", v3, 2u);
  }
}

void sub_1001558D4(uint64_t a1)
{
  v17[0] = kCFUserNotificationAlertMessageKey;
  id v2 = +[NSNumber numberWithUnsignedLong:*(void *)(a1 + 32)];
  int v3 = +[NSNumber numberWithUnsignedLong:*(void *)(a1 + 40)];
  CFTypeID v4 = +[NSString stringWithFormat:@"AppleInternal only:\nYour account has %@ keychain devices, over the recommended performance limit of %@. Please see:\nhttps://at.apple.com/keychain-help", v2, v3];
  v18[0] = v4;
  v18[1] = @"UserSecrets: Keychain";
  v17[1] = kCFUserNotificationAlertHeaderKey;
  v17[2] = kCFUserNotificationAlertTopMostKey;
  v18[2] = &__kCFBooleanTrue;
  CFDictionaryRef v5 = +[NSDictionary dictionaryWithObjects:v18 forKeys:v17 count:3];

  int v6 = -250;
  while (1)
  {
    SInt32 error = 0;
    CFErrorRef v7 = CFUserNotificationCreate(0, 0.0, 3uLL, &error, v5);
    CFTypeID v8 = sub_10000B070("octagon");
    BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    if (!v7) {
      break;
    }
    if (v9)
    {
      *(_DWORD *)long long buf = 134218240;
      *(void *)int v15 = v7;
      *(_WORD *)&v15[8] = 1024;
      SInt32 v16 = error;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "popdialog: CFNotification %p %d", buf, 0x12u);
    }

    CFOptionFlags responseFlags = 0;
    SInt32 error = CFUserNotificationReceiveResponse(v7, 0.0, &responseFlags);
    BOOL v10 = sub_10000B070("octagon");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109376;
      *(_DWORD *)int v15 = error;
      *(_WORD *)&v15[4] = 1024;
      *(_DWORD *)&v15[6] = responseFlags;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "popdialog: user responded %d %d", buf, 0xEu);
    }

    CFRelease(v7);
    if (error || (responseFlags & 3) != 0)
    {
      sleep(5u);
      if (!__CFADD__(v6++, 1)) {
        continue;
      }
    }
    goto LABEL_15;
  }
  if (v9)
  {
    *(_DWORD *)long long buf = 67109120;
    *(_DWORD *)int v15 = error;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "popdialog: Failed to create notification %d\n", buf, 8u);
  }

LABEL_15:
}

void sub_100155C18(id a1)
{
  byte_10035BF10 = _os_feature_enabled_impl();
  CFMutableArrayRef v1 = sub_10000B070("octagon");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_10035BF10) {
      CFStringRef v2 = @"enabled";
    }
    else {
      CFStringRef v2 = @"disabled";
    }
    int v3 = 138412290;
    CFStringRef v4 = v2;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "popdialog: WarnTooManyPeers is %@ (via feature flags)", (uint8_t *)&v3, 0xCu);
  }
}

CFDictionaryRef sub_100155CF8(void *a1, const __CFSet *a2, void *a3)
{
  id v18 = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  uint64_t v7 = a1[2];
  CFTypeID v8 = *(const void ***)(v7 + 16);
  if (v8)
  {
    BOOL v9 = (const void ***)(v7 + 24);
    do
    {
      if (CFSetContainsValue(a2, *v8))
      {
        BOOL v10 = sub_100118CF8(a1, (uint64_t)v8, (__CFString **)&v18);
        if (!v10)
        {
          if (Mutable)
          {
            CFDictionaryRef v14 = 0;
LABEL_13:
            CFRelease(Mutable);
            if (v14) {
              goto LABEL_14;
            }
          }
LABEL_15:
          id v16 = v18;
          if (a3)
          {
            CFDictionaryRef v15 = 0;
            *a3 = v18;
            id v18 = 0;
          }
          else
          {
            if (v18)
            {
              id v18 = 0;
              CFRelease(v16);
            }
            CFDictionaryRef v15 = 0;
          }
          goto LABEL_20;
        }
        int v11 = v10;
        if (!CFEqual(kCFNull, v10)) {
          CFDictionarySetValue(Mutable, *v8, v11);
        }
      }
      uint64_t v12 = *v9++;
      CFTypeID v8 = v12;
    }
    while (v12);
  }
  CFDictionaryRef Copy = CFDictionaryCreateCopy(kCFAllocatorDefault, Mutable);
  CFDictionaryRef v14 = Copy;
  if (Mutable) {
    goto LABEL_13;
  }
  if (!Copy) {
    goto LABEL_15;
  }
LABEL_14:
  CFDictionaryRef v15 = v14;
LABEL_20:

  return v15;
}

uint64_t sub_100155E64(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  uint64_t v26 = 0;
  uint64_t v20 = 0;
  uint64_t v21 = &v20;
  uint64_t v22 = 0x3032000000;
  CFTypeID v23 = sub_100156030;
  uint64_t v24 = sub_100156040;
  id v25 = 0;
  uint64_t v16 = 0;
  int v17 = &v16;
  uint64_t v18 = 0x2020000000;
  char v19 = 1;
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_100156048;
  v12[3] = &unk_100305070;
  CFDictionaryRef v14 = &v16;
  id v8 = a4;
  id v13 = v8;
  CFDictionaryRef v15 = &v20;
  if ((sub_10002742C(a1, (uint64_t)v7, (CFTypeRef *)&v26, (uint64_t)v12) & 1) == 0)
  {
    BOOL v10 = v26;
    if (a3)
    {
      uint64_t v9 = 0;
      *a3 = v26;
      uint64_t v26 = 0;
      goto LABEL_11;
    }
    if (v26)
    {
      uint64_t v26 = 0;
      CFRelease(v10);
    }
LABEL_10:
    uint64_t v9 = 0;
    goto LABEL_11;
  }
  if (!*((unsigned char *)v17 + 24))
  {
    if (a3)
    {
      uint64_t v9 = 0;
      *a3 = (id) v21[5];
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v9 = 1;
LABEL_11:

  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(&v20, 8);

  return v9;
}

void sub_10015600C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100156030(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100156040(uint64_t a1)
{
}

void sub_100156048(void *a1)
{
  uint64_t v2 = a1[4];
  uint64_t v3 = *(void *)(a1[6] + 8);
  id obj = *(id *)(v3 + 40);
  char v4 = (*(uint64_t (**)(void))(v2 + 16))();
  objc_storeStrong((id *)(v3 + 40), obj);
  *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = v4;
}

uint64_t sub_1001560B8(sqlite3_stmt *a1, uint64_t a2, const __CFString *a3, void *a4)
{
  id v8 = 0;
  uint64_t v5 = sub_10000E8B0(a1, a2, a3, (CFTypeRef *)&v8);
  if ((v5 & 1) == 0)
  {
    id v6 = v8;
    if (a4)
    {
      *a4 = v8;
    }
    else if (v8)
    {
      id v8 = 0;
      CFRelease(v6);
    }
  }
  return v5;
}

uint64_t sub_100156118(uint64_t a1, sqlite3_stmt *a2, void *a3, void *a4)
{
  id v25 = 0;
  uint64_t v19 = 0;
  uint64_t v20 = &v19;
  uint64_t v21 = 0x3032000000;
  uint64_t v22 = sub_100156030;
  CFTypeID v23 = sub_100156040;
  id v24 = 0;
  uint64_t v15 = 0;
  uint64_t v16 = &v15;
  uint64_t v17 = 0x2020000000;
  char v18 = 1;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  v11[2] = sub_1001562D8;
  v11[3] = &unk_100305098;
  uint64_t v13 = &v15;
  id v7 = a4;
  id v12 = v7;
  CFDictionaryRef v14 = &v19;
  if ((sub_1000275B0(a1, a2, (CFTypeRef *)&v25, (uint64_t)v11) & 1) == 0)
  {
    uint64_t v9 = v25;
    if (a3)
    {
      uint64_t v8 = 0;
      *a3 = v25;
      id v25 = 0;
      goto LABEL_11;
    }
    if (v25)
    {
      id v25 = 0;
      CFRelease(v9);
    }
LABEL_10:
    uint64_t v8 = 0;
    goto LABEL_11;
  }
  if (!*((unsigned char *)v16 + 24))
  {
    if (a3)
    {
      uint64_t v8 = 0;
      *a3 = (id) v20[5];
      goto LABEL_11;
    }
    goto LABEL_10;
  }
  uint64_t v8 = 1;
LABEL_11:

  _Block_object_dispose(&v15, 8);
  _Block_object_dispose(&v19, 8);

  return v8;
}

void sub_1001562B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1001562D8(void *a1, unsigned char *a2)
{
  uint64_t v5 = a1[4];
  uint64_t v6 = *(void *)(a1[6] + 8);
  id obj = *(id *)(v6 + 40);
  char v7 = (*(uint64_t (**)(void))(v5 + 16))();
  objc_storeStrong((id *)(v6 + 40), obj);
  *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = v7;
  if (!*(unsigned char *)(*(void *)(a1[5] + 8) + 24)) {
    *a2 = 1;
  }
}

uint64_t sub_100156380(uint64_t a1, void *a2, void *a3)
{
  id v24 = 0;
  uint64_t v18 = 0;
  uint64_t v19 = &v18;
  uint64_t v20 = 0x3032000000;
  uint64_t v21 = sub_100156030;
  uint64_t v22 = sub_100156040;
  id v23 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = &v14;
  uint64_t v16 = 0x2020000000;
  char v17 = 1;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_100156534;
  v10[3] = &unk_1003050C0;
  uint64_t v12 = &v14;
  id v5 = a3;
  id v11 = v5;
  uint64_t v13 = &v18;
  BOOL v6 = sub_1001381F8(a1, 6, (CFTypeRef *)&v24, (uint64_t)v10);
  if (!*((unsigned char *)v15 + 24))
  {
    if (a2)
    {
      uint64_t v7 = 0;
      *a2 = (id) v19[5];
      goto LABEL_11;
    }
LABEL_10:
    uint64_t v7 = 0;
    goto LABEL_11;
  }
  if (!v6)
  {
    uint64_t v8 = v24;
    if (a2)
    {
      uint64_t v7 = 0;
      *a2 = v24;
      id v24 = 0;
      goto LABEL_11;
    }
    if (v24)
    {
      id v24 = 0;
      CFRelease(v8);
    }
    goto LABEL_10;
  }
  uint64_t v7 = 1;
LABEL_11:

  _Block_object_dispose(&v14, 8);
  _Block_object_dispose(&v18, 8);

  return v7;
}

void sub_100156510(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va1, a8);
  va_start(va, a8);
  uint64_t v9 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100156534(void *a1)
{
  uint64_t v2 = a1[4];
  uint64_t v3 = *(void *)(a1[6] + 8);
  id obj = *(id *)(v3 + 40);
  char v4 = (*(uint64_t (**)(void))(v2 + 16))();
  objc_storeStrong((id *)(v3 + 40), obj);
  *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = v4;
  return *(unsigned __int8 *)(*(void *)(a1[5] + 8) + 24);
}

void sub_10015C01C(id a1)
{
}

void sub_10015C0CC(id a1, __OpaqueSecDbConnection *a2, unint64_t a3, unint64_t a4, __CFArray *a5)
{
  if (!a3 || a4 != 1 || !objc_opt_class() || atomic_load_explicit(dword_10035CD18, memory_order_acquire) > 1) {
    return;
  }
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  BOOL v6 = a5;
  id v7 = [(__CFArray *)v6 countByEnumeratingWithState:&v30 objects:v38 count:16];
  if (!v7)
  {
LABEL_42:

    return;
  }
  id v9 = v7;
  char v10 = 0;
  uint64_t v11 = *(void *)v31;
  *(void *)&long long v8 = 138477827;
  long long v27 = v8;
  while (2)
  {
    for (CFIndex i = 0; i != v9; CFIndex i = (char *)i + 1)
    {
      if (*(void *)v31 != v11) {
        objc_enumerationMutation(v6);
      }
      CFArrayRef v13 = *(const __CFArray **)(*((void *)&v30 + 1) + 8 * i);
      CFArrayRef v28 = 0;
      CFArrayRef v29 = 0;
      sub_100029198(v13, (CFTypeID *)&v29, &v28);
      if (v29) {
        BOOL v14 = v28 == 0;
      }
      else {
        BOOL v14 = 1;
      }
      if (v14)
      {
        if (v29 || !v28)
        {
          if (!v29 || v28)
          {
            uint64_t v16 = +[NSAssertionHandler currentHandler];
            id v24 = +[NSString stringWithUTF8String:"void KCSharingRegisterForDatabaseEvents(SecDbRef)_block_invoke"];
            [v16 handleFailureInFunction:v24 file:@"KCSharingSupport.m" lineNumber:112 description:@"Database event should have old item, new item, or both"];

            goto LABEL_36;
          }
          id v23 = sub_10015C498(v29);

          if (!v23) {
            continue;
          }
          uint64_t v16 = KCSharingLogObject();
          if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
LABEL_34:
            char v10 = 1;
LABEL_36:

            continue;
          }
          *(_DWORD *)long long buf = v27;
          CFArrayRef v35 = v29;
          char v17 = v16;
          uint64_t v18 = "KCSharing-relevant delete for oldItem=%{private}@";
        }
        else
        {
          uint64_t v15 = sub_10015C498(v28);

          if (!v15) {
            continue;
          }
          uint64_t v16 = KCSharingLogObject();
          if (!os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_34;
          }
          *(_DWORD *)long long buf = v27;
          CFArrayRef v35 = v28;
          char v17 = v16;
          uint64_t v18 = "KCSharing-relevant insert for newItem=%{private}@";
        }
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v18, buf, 0xCu);
        goto LABEL_34;
      }
      uint64_t v19 = sub_10015C498(v29);
      uint64_t v20 = sub_10015C498(v28);
      uint64_t v21 = (void *)v20;
      if (v19 | v20)
      {
        if (!v19 || !v20 || ![(id)v19 isEqual:v20])
        {
          id v25 = +[NSAssertionHandler currentHandler];
          uint64_t v26 = +[NSString stringWithUTF8String:"void KCSharingRegisterForDatabaseEvents(SecDbRef)_block_invoke"];
          [v25 handleFailureInFunction:v26 file:@"KCSharingSupport.m" lineNumber:88 description:@"Sharing group shouldn't change in update event"];

          goto LABEL_42;
        }
        uint64_t v22 = KCSharingLogObject();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138478083;
          CFArrayRef v35 = v29;
          __int16 v36 = 2113;
          CFArrayRef v37 = v28;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "KCSharing-relevant update for oldItem=%{private}@ to newItem=%{private}@", buf, 0x16u);
        }

        char v10 = 1;
      }
    }
    id v9 = [(__CFArray *)v6 countByEnumeratingWithState:&v30 objects:v38 count:16];
    if (v9) {
      continue;
    }
    break;
  }

  if (v10)
  {
    BOOL v6 = +[KCSharingSyncController sharedInstance];
    [(__CFArray *)v6 processDatabaseModifications];
    goto LABEL_42;
  }
}

id sub_10015C498(void *a1)
{
  uint64_t v2 = kSecAttrSharingGroup;
  uint64_t v8 = kSecAttrSharingGroup;
  uint64_t v3 = +[NSArray arrayWithObjects:&v8 count:1];
  CFSetRef v4 = +[NSSet setWithArray:v3];
  id v5 = sub_100155CF8(a1, v4, 0);

  BOOL v6 = [v5 objectForKeyedSubscript:v2];

  return v6;
}

void sub_10015C590(id a1, NSError *a2)
{
  uint64_t v2 = a2;
  if (v2)
  {
    uint64_t v3 = KCSharingLogObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v4 = 138543362;
      id v5 = v2;
      _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Failed to preflight sync controller with error=%{public}@", (uint8_t *)&v4, 0xCu);
    }
  }
}

void sub_10015C64C(id a1, NSError *a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = KCSharingLogObject();
  int v4 = v3;
  if (v2)
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v5 = 138543362;
      BOOL v6 = v2;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to stage missed outgoing changes with error=%{public}@", (uint8_t *)&v5, 0xCu);
    }
  }
  else if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v5) = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Maintenance complete", (uint8_t *)&v5, 2u);
  }
}

void sub_10015C73C(id a1, BOOL a2, NSError *a3)
{
  BOOL v3 = a2;
  int v4 = a3;
  int v5 = KCSharingLogObject();
  BOOL v6 = v5;
  if (v3)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Scheduled resync complete ", (uint8_t *)&v7, 2u);
    }
  }
  else if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    int v7 = 138412290;
    uint64_t v8 = v4;
    _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Unable to complete scheduled resync: %@", (uint8_t *)&v7, 0xCu);
  }
}

uint64_t sub_10015CDE4(uint64_t a1, uint64_t a2)
{
  while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0;
    while (1)
    {
      unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v7 == -1 || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v8 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
      v6 |= (unint64_t)(v8 & 0x7F) << v4;
      if ((v8 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v9 = v5++ >= 9;
      if (v9)
      {
        unint64_t v6 = 0;
        int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }
    *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0;
    }
LABEL_13:
    if (v10 || (v6 & 7) == 4) {
      return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    unint64_t v12 = v6 >> 3;
    if ((int)(v6 >> 3) > 100)
    {
      if (v12 == 101)
      {
        char v21 = 0;
        unsigned int v22 = 0;
        uint64_t v23 = 0;
        *(unsigned char *)(a1 + 36) |= 2u;
        while (1)
        {
          unint64_t v24 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v24 == -1 || v24 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            break;
          }
          char v25 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v24);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v24 + 1;
          v23 |= (unint64_t)(v25 & 0x7F) << v21;
          if ((v25 & 0x80) == 0) {
            goto LABEL_46;
          }
          v21 += 7;
          BOOL v9 = v22++ >= 9;
          if (v9)
          {
            uint64_t v23 = 0;
            goto LABEL_48;
          }
        }
        *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_46:
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v23 = 0;
        }
LABEL_48:
        *(unsigned char *)(a1 + 32) = v23 != 0;
      }
      else
      {
        if (v12 != 201)
        {
LABEL_39:
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
          continue;
        }
        char v15 = 0;
        unsigned int v16 = 0;
        uint64_t v17 = 0;
        *(unsigned char *)(a1 + 36) |= 1u;
        while (1)
        {
          unint64_t v18 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v18 == -1 || v18 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            break;
          }
          char v19 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v18);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v18 + 1;
          v17 |= (unint64_t)(v19 & 0x7F) << v15;
          if ((v19 & 0x80) == 0) {
            goto LABEL_42;
          }
          v15 += 7;
          BOOL v9 = v16++ >= 9;
          if (v9)
          {
            LODWORD(v17) = 0;
            goto LABEL_44;
          }
        }
        *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_42:
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v17) = 0;
        }
LABEL_44:
        *(_DWORD *)(a1 + 8) = v17;
      }
    }
    else
    {
      if (v12 == 1)
      {
        uint64_t v13 = PBReaderReadString();
        uint64_t v14 = 16;
      }
      else
      {
        if (v12 != 2) {
          goto LABEL_39;
        }
        uint64_t v13 = PBReaderReadString();
        uint64_t v14 = 24;
      }
      uint64_t v20 = *(void **)(a1 + v14);
      *(void *)(a1 + v14) = v13;
    }
  }
  return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

void sub_10015D8F4(_Unwind_Exception *a1)
{
  objc_destroyWeak((id *)(v1 - 120));
  _Unwind_Resume(a1);
}

void sub_10015D924(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v11 = WeakRetained;
  if (v9)
  {
    unint64_t v12 = sub_10000B070("SecError");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = 138412290;
      id v16 = v9;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "octagon: Error preparing voucher: %@", (uint8_t *)&v15, 0xCu);
    }

    [v11 setError:v9];
  }
  else
  {
    [WeakRetained setVoucher:v7];
    [v11 setVoucherSig:v8];
    uint64_t v13 = [v11 intendedState];
    [v11 setNextState:v13];
  }
  uint64_t v14 = [v11 finishedOp];
  [v11 runBeforeGroupFinished:v14];
}

void sub_10015DD68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
  objc_destroyWeak(v19);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10015DD94(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v2 = [*(id *)(a1 + 32) error];
  BOOL v3 = v2 == 0;

  uint64_t v4 = *(void *)(a1 + 40);
  unsigned int v5 = [*(id *)(a1 + 32) error];
  +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v4 success:v3 error:v5];

  unint64_t v6 = [*(id *)(a1 + 32) viewKeySets];
  [WeakRetained proceedWithKeys:v6];
}

uint64_t sub_10015E338(uint64_t a1)
{
  uint64_t v1 = (id *)(a1 + 32);
  uint64_t v2 = [*(id *)(a1 + 32) zoneID];
  BOOL v3 = [*v1 contextID];
  id v42 = 0;
  long long v30 = +[CKKSCurrentItemPointer allInZone:v2 contextID:v3 error:&v42];
  id v31 = v42;

  if (v31)
  {
    uint64_t v4 = [*(id *)(a1 + 32) zoneID:v30];
    unsigned int v5 = [v4 zoneName];
    unint64_t v6 = sub_1000CD884(@"ckksfixup", v5);

    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v31;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Couldn't fetch current item pointers: %@", buf, 0xCu);
    }
    uint64_t v7 = 0;
  }
  else
  {
    long long v33 = +[NSMutableSet set];
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    id obj = v30;
    id v8 = [obj countByEnumeratingWithState:&v38 objects:v46 count:16];
    if (v8)
    {
      uint64_t v9 = *(void *)v39;
      do
      {
        for (CFIndex i = 0; i != v8; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v39 != v9) {
            objc_enumerationMutation(obj);
          }
          uint64_t v11 = *(void **)(*((void *)&v38 + 1) + 8 * i);
          unint64_t v12 = [v11 storedCKRecord:v30];
          uint64_t v13 = [v12 recordID];

          uint64_t v14 = [*(id *)(a1 + 32) zoneID];
          int v15 = [v14 zoneName];
          id v16 = sub_1000CD884(@"ckksfixup", v15);

          if (v13)
          {
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 138412546;
              *(void *)&uint8_t buf[4] = v13;
              __int16 v44 = 2112;
              uint64_t v45 = v11;
              _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Re-fetching %@ for %@", buf, 0x16u);
            }

            [v33 addObject:v13];
          }
          else
          {
            if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 138412290;
              *(void *)&uint8_t buf[4] = v11;
              _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "No record ID for stored %@", buf, 0xCu);
            }
          }
        }
        id v8 = [obj countByEnumeratingWithState:&v38 objects:v46 count:16];
      }
      while (v8);
    }

    if (![v33 count])
    {
      uint64_t v17 = [*(id *)(a1 + 32) zoneID];
      unint64_t v18 = [v17 zoneName];
      char v19 = sub_1000CD884(@"ckksfixup", v18);

      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "No existing CIPs; fixup complete", buf, 2u);
      }
    }
    *(void *)long long buf = 0xAAAAAAAAAAAAAAAALL;
    objc_initWeak((id *)buf, *(id *)(a1 + 40));
    uint64_t v20 = +[NSBlockOperation named:@"fetch-records-operation-complete" withBlock:&stru_100305208];
    char v21 = [*(id *)(a1 + 40) deps];
    unsigned int v22 = [v21 cloudKitClassDependencies];
    id v23 = [[objc_msgSend(v22, "fetchRecordsOperationClass") alloc];
    unint64_t v24 = [v33 allObjects];
    id v25 = [v23 initWithRecordIDs:v24];

    v35[0] = _NSConcreteStackBlock;
    v35[1] = 3221225472;
    v35[2] = sub_10015E8D8;
    v35[3] = &unk_100305420;
    objc_copyWeak(&v37, (id *)buf);
    v35[4] = *(void *)(a1 + 32);
    id v26 = v20;
    id v36 = v26;
    [v25 setFetchRecordsCompletionBlock:v35];
    long long v27 = [*(id *)(a1 + 40) deps];
    CFArrayRef v28 = [v27 ckdatabase];
    [v28 addOperation:v25];

    [*(id *)(a1 + 40) dependOnBeforeGroupFinished:v25];
    [*(id *)(a1 + 40) dependOnBeforeGroupFinished:v26];

    objc_destroyWeak(&v37);
    objc_destroyWeak((id *)buf);
    uint64_t v7 = 1;
    unint64_t v6 = v33;
  }

  return v7;
}

void sub_10015E898(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,id location)
{
  objc_destroyWeak(v35);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10015E8D8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v8 = [WeakRetained deps];
  uint64_t v9 = [v8 databaseProvider];
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_10015E9E8;
  v14[3] = &unk_100305230;
  uint64_t v10 = *(void *)(a1 + 32);
  uint64_t v11 = *(void **)(a1 + 40);
  id v15 = v6;
  uint64_t v16 = v10;
  id v17 = WeakRetained;
  id v18 = v5;
  id v19 = v11;
  id v12 = v5;
  id v13 = v6;
  [v9 dispatchSyncWithSQLTransaction:v14];
}

uint64_t sub_10015E9E8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  BOOL v3 = [*(id *)(a1 + 40) zoneID];
  uint64_t v4 = [v3 zoneName];
  id v5 = sub_1000CD884(@"ckksfixup", v4);

  if (v2)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      id v6 = *(void **)(a1 + 32);
      *(_DWORD *)long long buf = 138412290;
      uint64_t v63 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Finished record fetch with error: %@", buf, 0xCu);
    }

    uint64_t v7 = [*(id *)(a1 + 32) userInfo];
    id v5 = [v7 objectForKeyedSubscript:CKPartialErrorsByItemIDKey];

    id v8 = [*(id *)(a1 + 32) domain];
    if (objc_msgSend(v8, "isEqualToString:") && objc_msgSend(*(id *)(a1 + 32), "code") == (id)2)
    {

      if (v5)
      {
        long long v59 = 0u;
        long long v60 = 0u;
        long long v57 = 0u;
        long long v58 = 0u;
        id obj = [v5 keyEnumerator];
        id v9 = [obj countByEnumeratingWithState:&v57 objects:v66 count:16];
        if (!v9) {
          goto LABEL_24;
        }
        id v11 = v9;
        uint64_t v12 = *(void *)v58;
        *(void *)&long long v10 = 138412290;
        long long v49 = v10;
        while (1)
        {
          for (CFIndex i = 0; i != v11; CFIndex i = (char *)i + 1)
          {
            if (*(void *)v58 != v12) {
              objc_enumerationMutation(obj);
            }
            uint64_t v14 = *(void **)(*((void *)&v57 + 1) + 8 * i);
            id v15 = -[NSObject objectForKeyedSubscript:](v5, "objectForKeyedSubscript:", v14, v49);
            uint64_t v16 = v15;
            if (v15)
            {
              id v17 = [v15 domain];
              if ([v17 isEqualToString:CKErrorDomain])
              {
                id v18 = [v16 code];

                if (v18 == (id)11)
                {
                  id v19 = [*(id *)(a1 + 40) zoneID];
                  uint64_t v20 = [v19 zoneName];
                  char v21 = sub_1000CD884(@"ckksfixup", v20);

                  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)long long buf = v49;
                    uint64_t v63 = v14;
                    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "CloudKit believes %@ no longer exists", buf, 0xCu);
                  }

                  unsigned int v22 = [*(id *)(a1 + 48) deps];
                  [v22 intransactionCKRecordDeleted:v14 recordType:@"currentitem" resync:1];

                  goto LABEL_22;
                }
              }
              else
              {
              }
            }
            id v23 = [*(id *)(a1 + 40) zoneID];
            unint64_t v24 = [v23 zoneName];
            id v25 = sub_1000CD884(@"ckksfixup", v24);

            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
            {
              id v26 = *(void **)(a1 + 32);
              *(_DWORD *)long long buf = 138412546;
              uint64_t v63 = v14;
              __int16 v64 = 2112;
              id v65 = v26;
              _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Unknown error for %@: %@", buf, 0x16u);
            }

            [*(id *)(a1 + 48) setError:*(void *)(a1 + 32)];
LABEL_22:
          }
          id v11 = [obj countByEnumeratingWithState:&v57 objects:v66 count:16];
          if (!v11)
          {
LABEL_24:

            goto LABEL_29;
          }
        }
      }
    }
    else
    {
    }
    [*(id *)(a1 + 48) setError:*(void *)(a1 + 32)];
  }
  else if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Finished record fetch successfully", buf, 2u);
  }
LABEL_29:

  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  id v27 = *(id *)(a1 + 56);
  id v28 = [v27 countByEnumeratingWithState:&v53 objects:v61 count:16];
  if (v28)
  {
    id v29 = v28;
    uint64_t v30 = *(void *)v54;
    do
    {
      for (j = 0; j != v29; j = (char *)j + 1)
      {
        if (*(void *)v54 != v30) {
          objc_enumerationMutation(v27);
        }
        long long v32 = [*(id *)(a1 + 56) objectForKeyedSubscript:*(void *)(*((void *)&v53 + 1) + 8 * (void)j)];
        long long v33 = [*(id *)(a1 + 40) zoneID];
        CFTypeID v34 = [v33 zoneName];
        CFArrayRef v35 = sub_1000CD884(@"ckksfixup", v34);

        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          uint64_t v63 = v32;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "Recieved record %@", buf, 0xCu);
        }

        id v36 = [*(id *)(a1 + 48) deps];
        [v36 intransactionCKRecordChanged:v32 resync:1];
      }
      id v29 = [v27 countByEnumeratingWithState:&v53 objects:v61 count:16];
    }
    while (v29);
  }

  id v37 = [*(id *)(a1 + 48) error];

  if (!v37)
  {
    long long v38 = [*(id *)(a1 + 48) deps];
    long long v39 = [v38 contextID];
    long long v40 = [*(id *)(a1 + 40) zoneID];
    long long v41 = [v40 zoneName];
    id v52 = 0;
    id v42 = +[CKKSZoneStateEntry fromDatabase:v39 zoneName:v41 error:&v52];
    id v43 = v52;

    [v42 setLastFixup:1];
    id v51 = v43;
    [v42 saveToDatabase:&v51];
    id v44 = v51;

    uint64_t v45 = [*(id *)(a1 + 40) zoneID];
    long long v46 = [v45 zoneName];
    long long v47 = sub_1000CD884(@"ckksfixup", v46);

    if (v44)
    {
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412546;
        uint64_t v63 = v42;
        __int16 v64 = 2112;
        id v65 = v44;
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "Couldn't save CKKSZoneStateEntry(%@): %@", buf, 0x16u);
      }
    }
    else
    {
      if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "Updated zone fixup state to CKKSFixupRefetchCurrentItemPointers", buf, 2u);
      }

      long long v47 = [*(id *)(a1 + 48) intendedState];
      [*(id *)(a1 + 48) setNextState:v47];
    }
  }
  [*(id *)(a1 + 48) runBeforeGroupFinished:*(void *)(a1 + 64)];
  return 1;
}

uint64_t sub_10015F4DC(uint64_t a1)
{
  id location = (id)0xAAAAAAAAAAAAAAAALL;
  objc_initWeak(&location, *(id *)(a1 + 32));
  uint64_t v2 = +[NSBlockOperation named:@"fetch-records-operation-complete" withBlock:&stru_100305250];
  BOOL v3 = +[NSPredicate predicateWithValue:1];
  id v4 = [objc_alloc((Class)CKQuery) initWithRecordType:@"tlkshare" predicate:v3];
  id v5 = [*(id *)(a1 + 32) deps];
  id v6 = [v5 cloudKitClassDependencies];
  id v7 = [[[objc_msgSend(objc_msgSend(objc_msgSend(v6, "queryOperationClass")), "alloc") initWithQuery:v4];

  id v8 = [*(id *)(a1 + 40) zoneID];
  [v7 setZoneID:v8];

  [v7 setDesiredKeys:0];
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472;
  v20[2] = sub_10015F790;
  v20[3] = &unk_100305278;
  objc_copyWeak(&v21, &location);
  v20[4] = *(void *)(a1 + 40);
  [v7 setRecordFetchedBlock:v20];
  id v13 = _NSConcreteStackBlock;
  uint64_t v14 = 3221225472;
  id v15 = sub_10015F870;
  uint64_t v16 = &unk_1003052C8;
  objc_copyWeak(&v19, &location);
  uint64_t v17 = *(void *)(a1 + 40);
  id v9 = v2;
  id v18 = v9;
  [v7 setQueryCompletionBlock:&v13];
  long long v10 = [*(id *)(a1 + 32) deps:v13, v14, v15, v16, v17];
  id v11 = [v10 ckdatabase];
  [v11 addOperation:v7];

  [*(id *)(a1 + 32) dependOnBeforeGroupFinished:v7];
  [*(id *)(a1 + 32) dependOnBeforeGroupFinished:v9];

  objc_destroyWeak(&v19);
  objc_destroyWeak(&v21);

  objc_destroyWeak(&location);
  return 1;
}

void sub_10015F74C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id location)
{
  objc_destroyWeak(v23);
  objc_destroyWeak(v22);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10015F790(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v5 = [WeakRetained deps];
  id v6 = [v5 databaseProvider];
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_10015FC70;
  v8[3] = &unk_1003053A8;
  v8[4] = *(void *)(a1 + 32);
  id v9 = v3;
  id v10 = WeakRetained;
  id v7 = v3;
  [v6 dispatchSyncWithSQLTransaction:v8];
}

void sub_10015F870(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v8 = [WeakRetained deps];
  id v9 = [v8 databaseProvider];
  id v13 = _NSConcreteStackBlock;
  uint64_t v14 = 3221225472;
  id v15 = sub_10015F97C;
  uint64_t v16 = &unk_1003052A0;
  uint64_t v10 = *(void *)(a1 + 32);
  id v17 = v6;
  uint64_t v18 = v10;
  id v19 = WeakRetained;
  id v20 = v5;
  id v11 = v5;
  id v12 = v6;
  [v9 dispatchSyncWithSQLTransaction:&v13];

  [WeakRetained runBeforeGroupFinished:*(void *)(a1 + 40), v13, v14, v15, v16];
}

uint64_t sub_10015F97C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = [*(id *)(a1 + 40) zoneID];
  id v4 = [v3 zoneName];
  id v5 = sub_1000CD884(@"ckksfixup", v4);

  if (v2)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      id v6 = *(void **)(a1 + 32);
      *(_DWORD *)long long buf = 138412290;
      unsigned int v22 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Couldn't fetch all TLKShare records: %@", buf, 0xCu);
    }

    [*(id *)(a1 + 48) setError:*(void *)(a1 + 32)];
    return 0;
  }
  else
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      id v8 = *(void **)(a1 + 56);
      *(_DWORD *)long long buf = 138412290;
      unsigned int v22 = v8;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Successfully fetched TLKShare records (%@)", buf, 0xCu);
    }

    id v9 = [*(id *)(a1 + 48) deps];
    uint64_t v10 = [v9 contextID];
    id v11 = [*(id *)(a1 + 40) zoneID];
    id v12 = [v11 zoneName];
    id v20 = 0;
    id v13 = +[CKKSZoneStateEntry fromDatabase:v10 zoneName:v12 error:&v20];
    id v14 = v20;

    [v13 setLastFixup:2];
    id v19 = v14;
    [v13 saveToDatabase:&v19];
    id v15 = v19;

    uint64_t v16 = [*(id *)(a1 + 40) zoneID];
    id v17 = [v16 zoneName];
    uint64_t v18 = sub_1000CD884(@"ckksfixup", v17);

    if (v15)
    {
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412546;
        unsigned int v22 = v13;
        __int16 v23 = 2112;
        id v24 = v15;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Couldn't save CKKSZoneStateEntry(%@): %@", buf, 0x16u);
      }
    }
    else
    {
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Updated zone fixup state to CKKSFixupFetchTLKShares", buf, 2u);
      }

      uint64_t v18 = [*(id *)(a1 + 48) intendedState];
      [*(id *)(a1 + 48) setNextState:v18];
    }

    return 1;
  }
}

uint64_t sub_10015FC70(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) zoneID];
  id v3 = [v2 zoneName];
  id v4 = sub_1000CD884(@"ckksfixup", v3);

  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 40);
    int v8 = 138412290;
    uint64_t v9 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Recieved tlk share record from query: %@", (uint8_t *)&v8, 0xCu);
  }

  id v6 = [*(id *)(a1 + 48) deps];
  [v6 intransactionCKRecordChanged:*(void *)(a1 + 40) resync:1];

  return 1;
}

void sub_100160114(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_10016013C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v3 = [*(id *)(a1 + 32) error];

  if (v3)
  {
    id v4 = sub_1000CD884(@"ckksfixup", 0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = [*(id *)(a1 + 32) error];
      *(_DWORD *)long long buf = 138412290;
      uint64_t v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Couldn't perform a reload: %@", buf, 0xCu);
    }
    id v6 = [*(id *)(a1 + 32) error];
    [WeakRetained setError:v6];
  }
  else
  {
    id v6 = [WeakRetained deps];
    id v7 = [v6 databaseProvider];
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472;
    v8[2] = sub_1001602C4;
    v8[3] = &unk_100306A88;
    v8[4] = WeakRetained;
    [v7 dispatchSyncWithSQLTransaction:v8];
  }
}

uint64_t sub_1001602C4(uint64_t a1)
{
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  uint64_t v1 = [*(id *)(a1 + 32) deps];
  uint64_t v2 = [v1 activeManagedViews];

  id obj = v2;
  id v24 = [v2 countByEnumeratingWithState:&v28 objects:v36 count:16];
  if (v24)
  {
    uint64_t v23 = *(void *)v29;
    *(void *)&long long v3 = 138412546;
    long long v21 = v3;
    do
    {
      for (CFIndex i = 0; i != v24; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v29 != v23) {
          objc_enumerationMutation(obj);
        }
        uint64_t v5 = *(void **)(*((void *)&v28 + 1) + 8 * i);
        id v6 = [v5 zoneID:v21];
        id v7 = [v6 zoneName];
        int v8 = sub_1000CD884(@"ckksfixup", v7);

        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v9 = [*(id *)(a1 + 32) fixupNumber];
          *(_DWORD *)long long buf = 67109120;
          LODWORD(v33) = v9;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Successfully performed a reload fixup. New fixup number is %d", buf, 8u);
        }

        uint64_t v10 = [*(id *)(a1 + 32) deps];
        id v11 = [v10 contextID];
        id v12 = [v5 zoneID];
        id v13 = [v12 zoneName];
        id v27 = 0;
        id v14 = +[CKKSZoneStateEntry fromDatabase:v11 zoneName:v13 error:&v27];
        id v15 = v27;

        [v14 setLastFixup:[*(id *)(a1 + 32) fixupNumber]];
        id v26 = v15;
        [v14 saveToDatabase:&v26];
        id v16 = v26;

        id v17 = [v5 zoneID];
        uint64_t v18 = [v17 zoneName];
        id v19 = sub_1000CD884(@"ckksfixup", v18);

        if (v16)
        {
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = v21;
            long long v33 = v14;
            __int16 v34 = 2112;
            id v35 = v16;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "Couldn't save CKKSZoneStateEntry(%@): %@", buf, 0x16u);
          }
        }
        else
        {
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Updated zone fixup state to CKKSFixupLocalReload", buf, 2u);
          }

          id v19 = [*(id *)(a1 + 32) intendedState];
          [*(id *)(a1 + 32) setNextState:v19];
        }
      }
      id v24 = [obj countByEnumeratingWithState:&v28 objects:v36 count:16];
    }
    while (v24);
  }

  return 1;
}

uint64_t sub_100160A14(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) zoneID];
  id v46 = 0;
  long long v3 = +[CKKSDeviceStateEntry allInZone:v2 error:&v46];
  id v4 = v46;

  if (v4)
  {
    uint64_t v5 = [*(id *)(a1 + 32) zoneID];
    id v6 = [v5 zoneName];
    id v7 = sub_1000CD884(@"ckksfixup", v6);

    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      id v48 = v4;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Unable to fetch all CDSEs: %@", buf, 0xCu);
    }

    [*(id *)(a1 + 40) setError:v4];
    uint64_t v8 = 0;
  }
  else
  {
    long long v44 = 0u;
    long long v45 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v38 = v3;
    id v9 = v3;
    id v10 = [v9 countByEnumeratingWithState:&v42 objects:v51 count:16];
    if (v10)
    {
      id v11 = v10;
      uint64_t v12 = *(void *)v43;
      while (2)
      {
        for (CFIndex i = 0; i != v11; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v43 != v12) {
            objc_enumerationMutation(v9);
          }
          id v14 = *(void **)(*((void *)&v42 + 1) + 8 * i);
          id v15 = [v14 storedCKRecord];
          if (v15)
          {
            [v14 setFromCKRecord:v15];
            id v41 = 0;
            [v14 saveToDatabase:&v41];
            id v16 = v41;
            if (v16)
            {
              id v4 = v16;
              long long v32 = [*(id *)(a1 + 32) zoneID];
              long long v33 = [v32 zoneName];
              __int16 v34 = sub_1000CD884(@"ckksfixup", v33);

              if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 138412290;
                id v48 = v4;
                _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "Unable to save CDSE: %@", buf, 0xCu);
              }

              [*(id *)(a1 + 40) setError:v4];
              uint64_t v8 = 0;
              long long v3 = v38;
              goto LABEL_31;
            }
          }
          else
          {
            id v17 = [*(id *)(a1 + 32) zoneID];
            uint64_t v18 = [v17 zoneName];
            id v19 = sub_1000CD884(@"ckksfixup", v18);

            if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 138412290;
              id v48 = v14;
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Saved CDSE has no stored record: %@", buf, 0xCu);
            }
          }
        }
        id v11 = [v9 countByEnumeratingWithState:&v42 objects:v51 count:16];
        if (v11) {
          continue;
        }
        break;
      }
    }

    id v20 = [*(id *)(a1 + 32) zoneID];
    long long v21 = [v20 zoneName];
    unsigned int v22 = sub_1000CD884(@"ckksfixup", v21);

    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Successfully performed a ResaveDeviceState fixup", buf, 2u);
    }

    uint64_t v23 = [*(id *)(a1 + 40) deps];
    id v24 = [v23 contextID];
    id v25 = [*(id *)(a1 + 32) zoneID];
    id v26 = [v25 zoneName];
    id v40 = 0;
    id v27 = +[CKKSZoneStateEntry fromDatabase:v24 zoneName:v26 error:&v40];
    id v28 = v40;

    [v27 setLastFixup:4];
    id v39 = v28;
    [v27 saveToDatabase:&v39];
    id v4 = v39;

    long long v29 = [*(id *)(a1 + 32) zoneID];
    long long v30 = [v29 zoneName];
    long long v31 = sub_1000CD884(@"ckksfixup", v30);

    if (v4)
    {
      long long v3 = v38;
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412546;
        id v48 = v27;
        __int16 v49 = 2112;
        id v50 = v4;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "Couldn't save CKKSZoneStateEntry(%@): %@", buf, 0x16u);
      }

      [*(id *)(a1 + 40) setError:v4];
      uint64_t v8 = 0;
    }
    else
    {
      long long v3 = v38;
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Updated zone fixup state to CKKSFixupResaveDeviceStateEntries", buf, 2u);
      }

      id v36 = [*(id *)(a1 + 40) intendedState];
      [*(id *)(a1 + 40) setNextState:v36];

      uint64_t v8 = 1;
    }
  }
LABEL_31:

  return v8;
}

void sub_100161124(id a1)
{
  uint64_t v1 = +[NSMutableSet set];
  [v1 addObject:@"idms_level"];
  [v1 addObject:@"preapproved"];
  [v1 addObject:@"tlk_upload_needed"];
  [v1 addObject:@"policy_check_needed"];
  [v1 addObject:@"ckks_views_changed"];
  [v1 addObject:@"recd_push"];
  [v1 addObject:@"account_available"];
  [v1 addObject:@"cdp_enabled"];
  [v1 addObject:@"attempt_sos_upgrade"];
  [v1 addObject:@"attempt_machine_id_list"];
  [v1 addObject:@"unlocked"];
  [v1 addObject:@"attempt_sos_update_preapprovals"];
  [v1 addObject:@"attempt_sos_consistency"];
  [v1 addObject:@"se_id_changed"];
  [v1 addObject:@"attempt_ucv_upgrade"];
  [v1 addObject:@"check_on_rtc_metrics"];
  [v1 addObject:@"pending_network_availablility"];
  [v1 addObject:@"check_trust_state"];
  [v1 addObject:@"apple_account_signed_out"];
  uint64_t v2 = (void *)qword_10035D1C8;
  qword_10035D1C8 = (uint64_t)v1;
}

void sub_10016133C(uint64_t a1)
{
  id v4 = [*(id *)(a1 + 32) OctagonStateMap];
  uint64_t v1 = [v4 allKeys];
  uint64_t v2 = +[NSSet setWithArray:v1];
  long long v3 = (void *)qword_10035D1B8;
  qword_10035D1B8 = v2;
}

void sub_100161410(id a1)
{
  uint64_t v1 = +[NSMutableSet set];
  [v1 addObject:@"Ready"];
  [v1 addObject:@"ReadyUpdated"];
  uint64_t v2 = (void *)qword_10035D1A8;
  qword_10035D1A8 = (uint64_t)v1;
}

void sub_1001614CC(id a1)
{
  uint64_t v1 = +[NSMutableSet set];
  [v1 addObject:@"NoAccount"];
  [v1 addObject:@"NoAccountDoReset"];
  [v1 addObject:@"Initializing"];
  [v1 addObject:@"DetermineiCloudAccountState"];
  [v1 addObject:@"WaitingForCloudKitAccount"];
  [v1 addObject:@"CloudKitNewlyAvailable"];
  [v1 addObject:@"WaitForCDPCapableSecurityLevel"];
  [v1 addObject:@"WaitForCDP"];
  [v1 addObject:@"Untrusted"];
  uint64_t v2 = (void *)qword_10035D198;
  qword_10035D198 = (uint64_t)v1;
}

void sub_1001615F8(id a1)
{
  uint64_t v1 = +[NSMutableSet set];
  [v1 addObject:@"Ready"];
  [v1 addObject:@"Error"];
  [v1 addObject:@"Untrusted"];
  [v1 addObject:@"WaitForCDPCapableSecurityLevel"];
  [v1 addObject:@"WaitForUnlock"];
  [v1 addObject:@"WaitForCDP"];
  uint64_t v2 = (void *)qword_10035D188;
  qword_10035D188 = (uint64_t)v1;
}

void sub_100161740(uint64_t a1)
{
  uint64_t v1 = [*(id *)(a1 + 32) OctagonStateMap];
  uint64_t v2 = [v1 allKeys];
  long long v3 = +[NSMutableSet setWithArray:v2];

  [v3 removeObject:@"NoAccount"];
  [v3 removeObject:@"NoAccountDoReset"];
  [v3 removeObject:@"Initializing"];
  [v3 removeObject:@"DetermineiCloudAccountState"];
  [v3 removeObject:@"WaitingForCloudKitAccount"];
  [v3 removeObject:@"CloudKitNewlyAvailable"];
  [v3 removeObject:@"WaitForCDPCapableSecurityLevel"];
  [v3 removeObject:@"LocalReset"];
  [v3 removeObject:@"LocalResetClearLocalContextState"];
  [v3 removeObject:@"WaitForClassCUnlock"];
  id v4 = (void *)qword_10035D178;
  qword_10035D178 = (uint64_t)v3;
}

void sub_100161900(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)NSMutableDictionary);
  uint64_t v14 = a1;
  long long v3 = [*(id *)(a1 + 32) stateInit];
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  id v4 = [v3 countByEnumeratingWithState:&v15 objects:v19 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v16;
    do
    {
      for (CFIndex i = 0; i != v5; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v16 != v6) {
          objc_enumerationMutation(v3);
        }
        uint64_t v8 = *(void **)(*((void *)&v15 + 1) + 8 * i);
        id v9 = [v8 objectAtIndexedSubscript:0];
        id v10 = [v8 objectAtIndexedSubscript:1];
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          id v11 = +[NSAssertionHandler currentHandler];
          [v11 handleFailureInMethod:*(void *)(v14 + 40) object:*(void *)(v14 + 32) file:@"OTStates.m" lineNumber:321 description:@"stateName should be string"];
        }
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          uint64_t v12 = +[NSAssertionHandler currentHandler];
          [v12 handleFailureInMethod:*(void *)(v14 + 40) object:*(void *)(v14 + 32) file:@"OTStates.m" lineNumber:322 description:@"stateNum should be number"];
        }
        [v2 setObject:v9 forKeyedSubscript:v10];
      }
      id v5 = [v3 countByEnumeratingWithState:&v15 objects:v19 count:16];
    }
    while (v5);
  }
  id v13 = (void *)qword_10035D168;
  qword_10035D168 = (uint64_t)v2;
}

void sub_100161BB8(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)NSMutableDictionary);
  uint64_t v14 = a1;
  long long v3 = [*(id *)(a1 + 32) stateInit];
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  id v4 = [v3 countByEnumeratingWithState:&v15 objects:v19 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v16;
    do
    {
      for (CFIndex i = 0; i != v5; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v16 != v6) {
          objc_enumerationMutation(v3);
        }
        uint64_t v8 = *(void **)(*((void *)&v15 + 1) + 8 * i);
        id v9 = [v8 objectAtIndexedSubscript:0];
        id v10 = [v8 objectAtIndexedSubscript:1];
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          id v11 = +[NSAssertionHandler currentHandler];
          [v11 handleFailureInMethod:*(void *)(v14 + 40) object:*(void *)(v14 + 32) file:@"OTStates.m" lineNumber:302 description:@"stateName should be string"];
        }
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          uint64_t v12 = +[NSAssertionHandler currentHandler];
          [v12 handleFailureInMethod:*(void *)(v14 + 40) object:*(void *)(v14 + 32) file:@"OTStates.m" lineNumber:303 description:@"stateNum should be number"];
        }
        [v2 setObject:v10 forKeyedSubscript:v9];
      }
      id v5 = [v3 countByEnumeratingWithState:&v15 objects:v19 count:16];
    }
    while (v5);
  }
  id v13 = (void *)qword_10035D158;
  qword_10035D158 = (uint64_t)v2;
}

void sub_1001634F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100163520(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v5 = sub_10000B070("octagon");
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v6)
    {
      id v7 = [WeakRetained deps];
      uint64_t v8 = [v7 containerName];
      id v9 = [WeakRetained deps];
      id v10 = [v9 contextID];
      int v12 = 138412802;
      id v13 = v8;
      __int16 v14 = 2112;
      long long v15 = v10;
      __int16 v16 = 2112;
      id v17 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Unable to remove peers for (%@,%@): %@", (uint8_t *)&v12, 0x20u);
    }
    [WeakRetained setError:v3];
  }
  else
  {
    if (v6)
    {
      LOWORD(v12) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Successfully removed peers", (uint8_t *)&v12, 2u);
    }
  }
  id v11 = [WeakRetained finishedOp];
  [WeakRetained runBeforeGroupFinished:v11];
}

CFMutableDataRef sub_1001637D4(const __CFData *a1, uint64_t a2)
{
  uint64_t v4 = sub_10000CF0C(0);
  uint64_t v5 = sub_100134054(v4);
  id v6 = 0;
  if (!a1 || !v5) {
    goto LABEL_20;
  }
  id v7 = sub_10021C7D8();
  if (!v7)
  {
    id v6 = 0;
    goto LABEL_20;
  }
  id v6 = v7;
  if (![v6 peerPublicKey])
  {
    SOSErrorCreate();

    goto LABEL_20;
  }
  [v6 peerPublicKey];
  uint64_t v8 = (const void *)SecKeyCopyMatchingPrivateKey();

  if (!v8)
  {
LABEL_20:

    return 0;
  }
  uint64_t v9 = SecOTRFullIdentityCreateFromSecKeyRefSOS();
  if (!v9)
  {

    CFRelease(v8);
    return 0;
  }
  id v10 = (const void *)v9;
  CFRelease(v8);
  CFStringRef v11 = CFStringCreateFromExternalRepresentation(kCFAllocatorDefault, a1, 0x8000100u);
  if (v11)
  {
    CFStringRef v12 = v11;
    id v13 = sub_10021C7D8();
    __int16 v14 = v13;
    if (v13)
    {
      long long v15 = [v13 trust];
      id v16 = [v15 copyPublicKeyForPeer:v12 err:a2];

      id v17 = (const void *)SecOTRPublicIdentityCreateFromSecKeyRef();
      if (v17)
      {
        if (v16) {
          CFRelease(v16);
        }
        id v16 = (id)SecOTRSessionCreateFromID();
        CFMutableDataRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
        SecOTRSAppendSerialization();
        if (v16)
        {
          CFRelease(v16);
          id v16 = 0;
        }
        goto LABEL_14;
      }
    }
    else
    {
      id v17 = 0;
      id v16 = 0;
    }
    CFMutableDataRef Mutable = 0;
LABEL_14:
    CFRelease(v12);

    if (v16) {
      CFRelease(v16);
    }
    if (v17) {
      CFRelease(v17);
    }
    goto LABEL_18;
  }

  CFMutableDataRef Mutable = 0;
LABEL_18:
  CFRelease(v10);
  return Mutable;
}

BOOL sub_1001639D0(uint64_t a1, uint64_t a2, CFMutableDataRef *a3, CFMutableDataRef *a4, unsigned char *a5)
{
  uint64_t v9 = (const void *)SecOTRSessionCreateFromData();
  if (v9)
  {
    CFMutableDataRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
    if (a2) {
      SecOTRSProcessPacket();
    }
    else {
      SecOTRSAppendStartPacket();
    }
    CFMutableDataRef v11 = CFDataCreateMutable(kCFAllocatorDefault, 0);
    SecOTRSAppendSerialization();
    *a3 = v11;
    *a4 = Mutable;
    *a5 = SecOTRSGetIsReadyForMessages();
    CFRelease(v9);
  }
  return v9 != 0;
}

uint64_t sub_100165D48(unsigned char *a1, uint64_t a2)
{
  while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0;
    while (1)
    {
      unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v7 == -1 || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v8 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
      v6 |= (unint64_t)(v8 & 0x7F) << v4;
      if ((v8 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v9 = v5++ >= 9;
      if (v9)
      {
        unint64_t v6 = 0;
        int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }
    *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0;
    }
LABEL_13:
    if (v10 || (v6 & 7) == 4) {
      return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    unint64_t v12 = v6 >> 3;
    if ((int)(v6 >> 3) <= 300)
    {
      if ((int)v12 <= 200)
      {
        if (v12 == 102)
        {
          uint64_t v27 = PBReaderReadString();
          uint64_t v28 = 56;
        }
        else
        {
          if (v12 != 103)
          {
LABEL_77:
            uint64_t result = PBReaderSkipValueWithTag();
            if (!result) {
              return result;
            }
            continue;
          }
          uint64_t v27 = PBReaderReadString();
          uint64_t v28 = 40;
        }
        goto LABEL_76;
      }
      if (v12 == 201)
      {
        uint64_t v27 = PBReaderReadString();
        uint64_t v28 = 64;
LABEL_76:
        long long v38 = *(void **)&a1[v28];
        *(void *)&a1[v28] = v27;

        continue;
      }
      if (v12 == 202)
      {
        uint64_t v27 = PBReaderReadString();
        uint64_t v28 = 72;
        goto LABEL_76;
      }
      if (v12 != 203) {
        goto LABEL_77;
      }
      char v18 = 0;
      unsigned int v19 = 0;
      uint64_t v20 = 0;
      a1[92] |= 0x10u;
      while (1)
      {
        unint64_t v21 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v21 == -1 || v21 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
          break;
        }
        char v22 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v21);
        *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v21 + 1;
        v20 |= (unint64_t)(v22 & 0x7F) << v18;
        if ((v22 & 0x80) == 0) {
          goto LABEL_84;
        }
        v18 += 7;
        BOOL v9 = v19++ >= 9;
        if (v9)
        {
          uint64_t v20 = 0;
          goto LABEL_86;
        }
      }
      *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_84:
      if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        uint64_t v20 = 0;
      }
LABEL_86:
      a1[88] = v20 != 0;
    }
    else
    {
      if ((int)v12 > 400)
      {
        if (v12 != 401)
        {
          if (v12 == 402)
          {
            char v34 = 0;
            unsigned int v35 = 0;
            uint64_t v15 = 0;
            a1[92] |= 1u;
            while (1)
            {
              unint64_t v36 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
              if (v36 == -1 || v36 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
                break;
              }
              char v37 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v36);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v36 + 1;
              v15 |= (unint64_t)(v37 & 0x7F) << v34;
              if ((v37 & 0x80) == 0) {
                goto LABEL_96;
              }
              v34 += 7;
              BOOL v9 = v35++ >= 9;
              if (v9)
              {
                uint64_t v15 = 0;
                goto LABEL_98;
              }
            }
            *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_96:
            if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
              uint64_t v15 = 0;
            }
LABEL_98:
            uint64_t v40 = 8;
          }
          else
          {
            if (v12 != 403) {
              goto LABEL_77;
            }
            char v23 = 0;
            unsigned int v24 = 0;
            uint64_t v15 = 0;
            a1[92] |= 2u;
            while (1)
            {
              unint64_t v25 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
              if (v25 == -1 || v25 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
                break;
              }
              char v26 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v25);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v25 + 1;
              v15 |= (unint64_t)(v26 & 0x7F) << v23;
              if ((v26 & 0x80) == 0) {
                goto LABEL_88;
              }
              v23 += 7;
              BOOL v9 = v24++ >= 9;
              if (v9)
              {
                uint64_t v15 = 0;
                goto LABEL_90;
              }
            }
            *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_88:
            if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
              uint64_t v15 = 0;
            }
LABEL_90:
            uint64_t v40 = 16;
          }
          goto LABEL_99;
        }
        long long v29 = objc_alloc_init(SECC2MPCloudKitOperationInfo);
        [a1 addClientOperation:v29];
        if (!PBReaderPlaceMark() || (sub_10015CDE4((uint64_t)v29, a2) & 1) == 0)
        {
LABEL_102:

          return 0;
        }
      }
      else
      {
        if (v12 != 301)
        {
          if (v12 == 302)
          {
            char v30 = 0;
            unsigned int v31 = 0;
            uint64_t v15 = 0;
            a1[92] |= 4u;
            while (1)
            {
              unint64_t v32 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
              if (v32 == -1 || v32 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
                break;
              }
              char v33 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v32);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v32 + 1;
              v15 |= (unint64_t)(v33 & 0x7F) << v30;
              if ((v33 & 0x80) == 0) {
                goto LABEL_92;
              }
              v30 += 7;
              BOOL v9 = v31++ >= 9;
              if (v9)
              {
                uint64_t v15 = 0;
                goto LABEL_94;
              }
            }
            *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_92:
            if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
              uint64_t v15 = 0;
            }
LABEL_94:
            uint64_t v40 = 24;
          }
          else
          {
            if (v12 != 303) {
              goto LABEL_77;
            }
            char v13 = 0;
            unsigned int v14 = 0;
            uint64_t v15 = 0;
            a1[92] |= 8u;
            while (1)
            {
              unint64_t v16 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
              if (v16 == -1 || v16 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
                break;
              }
              char v17 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v16);
              *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v16 + 1;
              v15 |= (unint64_t)(v17 & 0x7F) << v13;
              if ((v17 & 0x80) == 0) {
                goto LABEL_80;
              }
              v13 += 7;
              BOOL v9 = v14++ >= 9;
              if (v9)
              {
                uint64_t v15 = 0;
                goto LABEL_82;
              }
            }
            *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_80:
            if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
              uint64_t v15 = 0;
            }
LABEL_82:
            uint64_t v40 = 32;
          }
LABEL_99:
          *(void *)&a1[v40] = v15;
          continue;
        }
        long long v29 = objc_alloc_init(SECC2MPCloudKitOperationGroupInfo);
        [a1 addOperationGroup:v29];
        if (!PBReaderPlaceMark() || (sub_1001CC89C((uint64_t)v29, a2) & 1) == 0) {
          goto LABEL_102;
        }
      }
      PBReaderRecallMark();
    }
  }
  return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

void sub_1001671AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va1, a10);
  va_start(va, a10);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001671E8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1001671F8(uint64_t a1)
{
}

uint64_t sub_100167200(uint64_t a1, uint64_t a2)
{
  char v26 = 0;
  uint64_t v4 = sub_10000C3CC(*(const __CFDictionary **)(a1 + 32), 0, 1, 0, &v26);
  if (v26) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = v4 == 0;
  }
  if (v5)
  {
    unint64_t v6 = [*(id *)(a1 + 40) viewState];
    unint64_t v7 = [v6 zoneID];
    char v8 = [v7 zoneName];
    BOOL v9 = sub_1000CD884(@"ckkscurrent", v8);

    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v28 = v26;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "couldn't create query for item persistentRef: %@", buf, 0xCu);
    }

    int v10 = v26;
    CFStringRef v11 = @"couldn't create query for new item pref";
  }
  else
  {
    unint64_t v12 = (const void **)v4;
    v25[0] = _NSConcreteStackBlock;
    v25[1] = 3221225472;
    v25[2] = sub_100167570;
    v25[3] = &unk_100305448;
    v25[4] = *(void *)(a1 + 56);
    if (sub_100138F00(v4, 0, a2, &v26, (uint64_t)v25))
    {
      if (sub_10000C2C4(v12, (CFErrorRef *)&v26)) {
        return 1;
      }
      uint64_t v18 = [*(id *)(a1 + 40) viewState];
      unsigned int v19 = [v18 zoneID];
      uint64_t v20 = [v19 zoneName];
      unint64_t v21 = sub_1000CD884(@"ckkscurrent", v20);

      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        uint64_t v28 = v26;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "couldn't destroy query for item pref: %@", buf, 0xCu);
      }

      int v10 = v26;
      CFStringRef v11 = @"couldn't destroy query for item pref";
    }
    else
    {
      sub_10000C2C4(v12, 0);
      uint64_t v14 = [*(id *)(a1 + 40) viewState];
      uint64_t v15 = [v14 zoneID];
      uint64_t v16 = [v15 zoneName];
      uint64_t v17 = sub_1000CD884(@"ckkscurrent", v16);

      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        uint64_t v28 = v26;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "couldn't run query for item pref: %@", buf, 0xCu);
      }

      int v10 = v26;
      CFStringRef v11 = @"couldn't run query for new item pref";
    }
  }
  uint64_t v22 = +[NSError errorWithDomain:@"CKKSErrorDomain" code:-50 description:v11 underlying:v10];
  uint64_t v23 = *(void *)(*(void *)(a1 + 48) + 8);
  unsigned int v24 = *(void **)(v23 + 40);
  *(void *)(v23 + 40) = v22;

  return 0;
}

CFTypeRef sub_100167570(CFTypeRef result, CFTypeRef cf)
{
  uint64_t v3 = (uint64_t)result;
  if (cf) {
    uint64_t result = CFRetain(cf);
  }
  *(void *)(*(void *)(*(void *)(v3 + 32) + 8) + 24) = cf;
  return result;
}

void sub_100167AE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100167B1C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  char v8 = [WeakRetained deps];
  BOOL v9 = [v8 databaseProvider];

  if (v6)
  {
    int v10 = [WeakRetained viewState];
    CFStringRef v11 = [v10 zoneID];
    unint64_t v12 = [v11 zoneName];
    uint64_t v13 = sub_1000CD884(@"ckkscurrent", v12);

    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      id v21 = v6;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "fetch returned an error: %@", buf, 0xCu);
    }

    uint64_t v14 = [WeakRetained operationQueue];
    [v14 addOperation:*(void *)(a1 + 32)];
  }
  else
  {
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 3221225472;
    v16[2] = sub_100167D20;
    v16[3] = &unk_1003053A8;
    id v17 = v5;
    id v18 = *(id *)(a1 + 40);
    id v19 = WeakRetained;
    [v9 dispatchSyncWithSQLTransaction:v16];
    uint64_t v15 = [WeakRetained operationQueue];
    [v15 addOperation:*(void *)(a1 + 32)];

    uint64_t v14 = v17;
  }
}

uint64_t sub_100167D20(id *a1)
{
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  id obj = a1[4];
  id v2 = [obj countByEnumeratingWithState:&v25 objects:v33 count:16];
  if (v2)
  {
    id v4 = v2;
    uint64_t v5 = *(void *)v26;
    *(void *)&long long v3 = 138412546;
    long long v21 = v3;
    do
    {
      id v6 = 0;
      id v22 = v4;
      do
      {
        if (*(void *)v26 != v5) {
          objc_enumerationMutation(obj);
        }
        unint64_t v7 = [a1[4] objectForKeyedSubscript:*(void *)(*((void *)&v25 + 1) + 8 * (void)v6) v21];
        if ([a1[5] matchesCKRecord:v7 checkServerFields:0])
        {
          uint64_t v8 = v5;
          [a1[5] setFromCKRecord:v7];
          id v9 = a1[5];
          id v24 = 0;
          unsigned int v10 = [v9 saveToDatabase:&v24];
          CFStringRef v11 = v24;
          unint64_t v12 = [a1[6] viewState];
          uint64_t v13 = [v12 zoneID];
          uint64_t v14 = [v13 zoneName];
          uint64_t v15 = sub_1000CD884(@"ckkscurrent", v14);

          if (!v10 || v11)
          {
            if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = v21;
              char v30 = v7;
              __int16 v31 = 2112;
              unint64_t v32 = v11;
              _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "couldn't save updated CKRecord to database: %@ %@", buf, 0x16u);
            }
          }
          else
          {
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
            {
              id v19 = a1[5];
              *(_DWORD *)long long buf = 138412290;
              char v30 = v19;
              _os_log_debug_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "CKKSMirrorEntry updated: %@", buf, 0xCu);
            }
            CFStringRef v11 = v15;
          }
          uint64_t v5 = v8;
          id v4 = v22;
        }
        else
        {
          uint64_t v16 = [a1[6] viewState];
          id v17 = [v16 zoneID];
          id v18 = [v17 zoneName];
          CFStringRef v11 = sub_1000CD884(@"ckkscurrent", v18);

          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138412290;
            char v30 = v7;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "fetched non-matching record %@", buf, 0xCu);
          }
        }

        id v6 = (char *)v6 + 1;
      }
      while (v4 != v6);
      id v4 = [obj countByEnumeratingWithState:&v25 objects:v33 count:16];
    }
    while (v4);
  }

  return 1;
}

void sub_100168108(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

uint64_t sub_10016812C(uint64_t a1)
{
  if (![*(id *)(a1 + 32) isCancelled])
  {
    v196 = 0;
    id v6 = *(void **)(a1 + 32);
    unint64_t v7 = [v6 newerItemPersistentRef];
    uint64_t v8 = [*(id *)(a1 + 32) accessGroup];
    id v195 = 0;
    id v9 = [v6 _onqueueFindSecDbItem:v7 accessGroup:v8 error:&v195];
    uint64_t v5 = v195;
    [*(id *)(a1 + 32) setNewItem:v9];

    id v10 = [*(id *)(a1 + 32) newItem];
    CFStringRef v11 = *(void **)(a1 + 32);
    if (!v10 || v5)
    {
      unsigned int v35 = [v11 viewState];
      unint64_t v36 = [v35 zoneID];
      char v37 = [v36 zoneName];
      long long v38 = sub_1000CD884(@"ckkscurrent", v37);

      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        v198 = (__CFString *)v5;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "Couldn't fetch new item, quitting: %@", buf, 0xCu);
      }

      [*(id *)(a1 + 32) setError:v5];
      goto LABEL_25;
    }
    unint64_t v12 = (void **)[v11 newItem];
    uint64_t v13 = sub_100118974(v12[2], 7, &v196);
    uint64_t v14 = (__CFString *)sub_100118CF8(v12, v13, &v196);
    uint64_t v15 = v14;
    if (!v14
      || (CFRetain(v14), v196)
      || ([*(id *)(a1 + 32) newerItemSHA1],
          uint64_t v16 = objc_claimAutoreleasedReturnValue(),
          unsigned __int8 v17 = [(__CFString *)v15 isEqual:v16],
          v16,
          (v17 & 1) == 0))
    {
      uint64_t v40 = [*(id *)(a1 + 32) viewState];
      id v41 = [v40 zoneID];
      long long v42 = [v41 zoneName];
      long long v43 = sub_1000CD884(@"ckkscurrent", v42);

      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        long long v44 = [*(id *)(a1 + 32) newerItemSHA1];
        *(_DWORD *)long long buf = 138412546;
        v198 = v15;
        __int16 v199 = 2112;
        v200 = v44;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "Hash mismatch for new item: %@ vs %@", buf, 0x16u);
      }
      id v19 = v196;
      +[NSError errorWithDomain:code:description:underlying:](NSError, "errorWithDomain:code:description:underlying:", @"CKKSErrorDomain", 14, @"New item has changed; hashes mismatch. Refetch and try again.",
      long long v45 = v196);
      [*(id *)(a1 + 32) setError:v45];

      goto LABEL_29;
    }
    id v18 = (__CFString *)sub_100118CF8([*(id *)(a1 + 32) newItem], (uint64_t)&off_100305790, &v196);
    id v19 = v18;
    if (v18)
    {
      CFRetain(v18);
      uint64_t v20 = *(void **)(a1 + 32);
      if (!v196)
      {
        long long v21 = [v20 oldItemPersistentRef];

        if (v21)
        {
          id v22 = *(void **)(a1 + 32);
          uint64_t v23 = [v22 oldItemPersistentRef];
          id v24 = [*(id *)(a1 + 32) accessGroup];
          id v194 = 0;
          id v25 = [v22 _onqueueFindSecDbItem:v23 accessGroup:v24 error:&v194];
          uint64_t v5 = v194;
          [*(id *)(a1 + 32) setOldItem:v25];

          id v26 = [*(id *)(a1 + 32) oldItem];
          long long v27 = *(void **)(a1 + 32);
          if (!v26 || v5)
          {
            v68 = [v27 viewState];
            v69 = [v68 zoneID];
            CFStringRef v70 = [v69 zoneName];
            CFStringRef v71 = sub_1000CD884(@"ckkscurrent", v70);

            if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 138412290;
              v198 = (__CFString *)v5;
              _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "Couldn't fetch old item, quitting: %@", buf, 0xCu);
            }

            [*(id *)(a1 + 32) setError:v5];
            goto LABEL_30;
          }
          CFTypeRef cf = (__CFString *)sub_10011BD18((void **)[v27 oldItem], &v196);
          if (!cf
            || (CFRetain(cf), v196)
            || ([*(id *)(a1 + 32) oldItemSHA1],
                long long v28 = objc_claimAutoreleasedReturnValue(),
                unsigned __int8 v29 = [(__CFString *)cf isEqual:v28],
                v28,
                (v29 & 1) == 0))
          {
            CFDataRef v72 = [*(id *)(a1 + 32) viewState];
            CFNumberRef v73 = [v72 zoneID];
            CFNumberRef v74 = [v73 zoneName];
            v75 = sub_1000CD884(@"ckkscurrent", v74);

            if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
            {
              v76 = [*(id *)(a1 + 32) oldItemSHA1];
              *(_DWORD *)long long buf = 138412546;
              v198 = cf;
              __int16 v199 = 2112;
              v200 = v76;
              _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "Hash mismatch for old item: %@ vs %@", buf, 0x16u);
            }
            uint64_t v77 = v196;
            +[NSError errorWithDomain:code:description:underlying:](NSError, "errorWithDomain:code:description:underlying:", @"CKKSErrorDomain", 14, @"Old item has changed; hashes mismatch. Refetch and try again.",
            v78 = v196);
            [*(id *)(a1 + 32) setError:v78];

            goto LABEL_29;
          }
          v177 = (__CFString *)sub_100118CF8([*(id *)(a1 + 32) oldItem], (uint64_t)&off_100305790, &v196);
          if (!v177 || (CFRetain(v177), v196))
          {
            char v30 = [*(id *)(a1 + 32) viewState];
            __int16 v31 = [v30 zoneID];
            unint64_t v32 = [v31 zoneName];
            char v33 = sub_1000CD884(@"ckkscurrent", v32);

            if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 138412290;
              v198 = v196;
              _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "Error fetching UUID for old item: %@", buf, 0xCu);
            }

            char v34 = v196;
            [*(id *)(a1 + 32) setError:v196];

LABEL_29:
            uint64_t v5 = 0;
LABEL_30:
            uint64_t v39 = 0;
LABEL_31:

            goto LABEL_32;
          }
        }
        else
        {
          v177 = 0;
          CFTypeRef cf = 0;
        }
        id v52 = [*(id *)(a1 + 32) viewState];
        long long v53 = [v52 zoneID];
        long long v54 = [v53 zoneName];
        long long v55 = sub_1000CD884(@"ckkscurrent", v54);

        if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
        {
          long long v56 = [*(id *)(a1 + 32) currentPointerIdentifier];
          *(_DWORD *)long long buf = 138412802;
          v198 = v56;
          __int16 v199 = 2112;
          v200 = v19;
          __int16 v201 = 2112;
          v202 = v177;
          _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "Setting current pointer for %@ to %@ (from %@)", buf, 0x20u);
        }
        long long v57 = [*(id *)(a1 + 32) currentPointerIdentifier];
        long long v58 = [*(id *)(a1 + 32) viewState];
        long long v59 = [v58 contextID];
        long long v60 = [*(id *)(a1 + 32) viewState];
        v61 = [v60 zoneID];
        id v193 = 0;
        v176 = +[CKKSCurrentItemPointer tryFromDatabase:v57 contextID:v59 state:@"remote" zoneID:v61 error:&v193];
        uint64_t v5 = v193;

        if (v176)
        {
          uint64_t v62 = +[NSString stringWithFormat:@"Update to current item pointer is pending."];
          uint64_t v63 = +[NSError errorWithDomain:@"CKKSErrorDomain" code:12 description:v62];
          [*(id *)(a1 + 32) setError:v63];

          __int16 v64 = [*(id *)(a1 + 32) viewState];
          id v65 = [v64 zoneID];
          v66 = [v65 zoneName];
          osos_log_t log = sub_1000CD884(@"ckkscurrent", v66);

          if (os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR))
          {
            BOOL v67 = [*(id *)(a1 + 32) error];
            *(_DWORD *)long long buf = 138412290;
            v198 = v67;
            _os_log_impl((void *)&_mh_execute_header, oslog, OS_LOG_TYPE_ERROR, "Attempt to set a new current item pointer when one exists: %@", buf, 0xCu);
          }
          uint64_t v39 = 0;
          goto LABEL_97;
        }
        v172 = [*(id *)(a1 + 32) currentPointerIdentifier];
        v79 = [*(id *)(a1 + 32) viewState];
        v80 = [v79 contextID];
        v81 = [*(id *)(a1 + 32) viewState];
        uint64_t v82 = [v81 zoneID];
        v192 = v5;
        osos_log_t log = +[CKKSCurrentItemPointer tryFromDatabase:v172 contextID:v80 state:@"local" zoneID:v82 error:&v192];
        v174 = v192;

        if (oslog)
        {
          if (v177)
          {
            CFStringRef v83 = [oslog currentItemUUID];
            unsigned __int8 v84 = [v83 isEqualToString:v177];

            if ((v84 & 1) == 0)
            {
              unsigned int v85 = [*(id *)(a1 + 32) viewState];
              v86 = [v85 zoneID];
              v87 = [v86 zoneName];
              v88 = sub_1000CD884(@"ckkscurrent", v87);

              if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)long long buf = 138412546;
                v198 = (__CFString *)oslog;
                __int16 v199 = 2112;
                v200 = v177;
                _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "current item pointer(%@) doesn't match user-supplied UUID (%@); rejecting change of current",
                  buf,
                  0x16u);
              }

              v173 = +[NSString stringWithFormat:@"Current pointer(%@) does not match user-supplied %@, aborting", oslog, v177];
              v89 = +[NSError errorWithDomain:@"CKKSErrorDomain" code:14 description:v173];
              [*(id *)(a1 + 32) setError:v89];

LABEL_64:
              uint64_t v39 = 0;
LABEL_96:

              uint64_t v5 = v174;
LABEL_97:

              goto LABEL_31;
            }
          }
          else
          {
            long long v95 = *(void **)(a1 + 32);
            long long v96 = [oslog currentItemUUID];
            long long v97 = [*(id *)(a1 + 32) accessGroup];
            id v98 = [v95 _onqueueFindSecDbItemWithUUID:v96 accessGroup:v97 error:0];

            if (v98)
            {
              CFRelease(v98);
              v99 = [*(id *)(a1 + 32) viewState];
              __int16 v100 = [v99 zoneID];
              v101 = [v100 zoneName];
              v102 = sub_1000CD884(@"ckkscurrent", v101);

              if (os_log_type_enabled(v102, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)long long buf = 138412290;
                v198 = (__CFString *)oslog;
                _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_DEFAULT, "no user-supplied UUID and current item pointer(%@) is not dangling; rejecting change of current",
                  buf,
                  0xCu);
              }

              v173 = +[NSString stringWithFormat:@"No user-supplied UUID and current pointer(%@) is not dangling, aborting", oslog];
              v103 = +[NSError errorWithDomain:@"CKKSErrorDomain" code:14 description:v173];
              [*(id *)(a1 + 32) setError:v103];

              goto LABEL_64;
            }
          }
          [oslog setCurrentItemUUID:v19];
        }
        else
        {
          if (v177)
          {
            v90 = [*(id *)(a1 + 32) viewState];
            long long v91 = [v90 zoneID];
            long long v92 = [v91 zoneName];
            long long v93 = sub_1000CD884(@"ckkscurrent", v92);

            if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT))
            {
              long long v94 = [*(id *)(a1 + 32) currentPointerIdentifier];
              *(_DWORD *)long long buf = 138412290;
              v198 = v94;
              _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_DEFAULT, "Requested to update a current item pointer but one doesn't exist at %@; rejecting change of current",
                buf,
                0xCu);
            }
            osos_log_t log = +[NSString stringWithFormat:@"Current pointer(%@) does not match given value of '%@', aborting", 0, v177];
            v173 = +[NSError errorWithDomain:@"CKKSErrorDomain" code:14 description:oslog];
            [*(id *)(a1 + 32) setError:v173];
            goto LABEL_64;
          }
          osloga = [CKKSCurrentItemPointer alloc];
          v104 = [*(id *)(a1 + 32) currentPointerIdentifier];
          v105 = [*(id *)(a1 + 32) viewState];
          v106 = [v105 contextID];
          v107 = [*(id *)(a1 + 32) viewState];
          v108 = [v107 zoneID];
          osos_log_t log = [(CKKSCurrentItemPointer *)osloga initForIdentifier:v104 contextID:v106 currentItemUUID:v19 state:@"local" zoneID:v108 encodedCKRecord:0];

          v109 = [*(id *)(a1 + 32) viewState];
          v110 = [v109 zoneID];
          v111 = [v110 zoneName];
          v112 = sub_1000CD884(@"ckkscurrent", v111);

          if (os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138412290;
            v198 = (__CFString *)oslog;
            _os_log_impl((void *)&_mh_execute_header, v112, OS_LOG_TYPE_DEFAULT, "Creating a new current item pointer: %@", buf, 0xCu);
          }
        }
        v113 = [*(id *)(a1 + 32) deps];
        v114 = [v113 contextID];
        v115 = [*(id *)(a1 + 32) viewState];
        v116 = [v115 zoneID];
        v191 = v174;
        v173 = +[CKKSSQLDatabaseObject allUUIDsWithContextID:v114 zoneID:v116 error:&v191];
        v170 = v191;

        v117 = [*(id *)(a1 + 32) deps];
        v118 = [v117 contextID];
        v119 = [*(id *)(a1 + 32) viewState];
        v120 = [v119 zoneID];
        v190 = v170;
        v169 = +[CKKSSQLDatabaseObject allUUIDsWithContextID:v118 zoneID:v120 error:&v190];
        v121 = v190;

        if (([v173 containsObject:v19] & 1) != 0
          || [v169 containsObject:v19])
        {
          +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"New item(%@) is being synced; can't set current pointer.",
          v122 = v19);
          uint64_t v123 = +[NSError errorWithDomain:@"CKKSErrorDomain" code:13 description:v122];
        }
        else
        {
          uint64_t v123 = (uint64_t)v121;
        }
        if (v177)
        {
          v124 = (void *)v123;
          if ((objc_msgSend(v173, "containsObject:") & 1) != 0
            || [v169 containsObject:v177])
          {
            +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Old item(%@) is being synced; can't set current pointer.",
            v125 = v177);
            uint64_t v123 = +[NSError errorWithDomain:@"CKKSErrorDomain" code:13 description:v125];
          }
        }
        if (v123)
        {
          v174 = v123;
          v126 = [*(id *)(a1 + 32) viewState];
          v127 = [v126 zoneID];
          v128 = [v127 zoneName];
          v129 = sub_1000CD884(@"ckkscurrent", v128);

          if (os_log_type_enabled(v129, OS_LOG_TYPE_ERROR))
          {
            v130 = [*(id *)(a1 + 32) currentPointerIdentifier];
            *(_DWORD *)long long buf = 138412546;
            v198 = v130;
            __int16 v199 = 2112;
            v200 = (__CFString *)v174;
            _os_log_impl((void *)&_mh_execute_header, v129, OS_LOG_TYPE_ERROR, "Error attempting to update current item pointer %@: %@", buf, 0x16u);
          }
          [*(id *)(a1 + 32) setError:v174];
          uint64_t v39 = 0;
        }
        else
        {
          v131 = [oslog currentItemUUID];
          v132 = [*(id *)(a1 + 32) deps];
          v133 = [v132 contextID];
          v134 = [*(id *)(a1 + 32) viewState];
          v135 = [v134 zoneID];
          id v189 = 0;
          v171 = +[CKKSMirrorEntry fromDatabase:v131 contextID:v133 zoneID:v135 error:&v189];
          id v168 = v189;

          if (v171) {
            BOOL v136 = v168 == 0;
          }
          else {
            BOOL v136 = 0;
          }
          int v137 = !v136;
          v138 = [*(id *)(a1 + 32) viewState];
          v139 = [v138 zoneID];
          v140 = [v139 zoneName];
          v141 = sub_1000CD884(@"ckkscurrent", v140);

          if (v137)
          {
            if (os_log_type_enabled(v141, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 138412546;
              v198 = (__CFString *)oslog;
              __int16 v199 = 2112;
              v200 = v171;
              _os_log_impl((void *)&_mh_execute_header, v141, OS_LOG_TYPE_ERROR, "Error attempting to set a current item pointer to an item that isn't synced: %@ %@", buf, 0x16u);
            }

            v142 = [oslog currentItemUUID];
            +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"No synced item matching (%@); can't set current pointer.",
            v143 = v142);
            v174 = +[NSError errorWithDomain:@"CKKSErrorDomain" code:-25300 description:v143 underlying:v168];

            [*(id *)(a1 + 32) setError:v174];
            uint64_t v39 = 0;
          }
          else
          {
            if (os_log_type_enabled(v141, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 138412290;
              v198 = (__CFString *)oslog;
              _os_log_impl((void *)&_mh_execute_header, v141, OS_LOG_TYPE_DEFAULT, "Saving new current item pointer %@", buf, 0xCu);
            }

            id v144 = objc_alloc_init((Class)NSMutableDictionary);
            v145 = [*(id *)(a1 + 32) viewState];
            v146 = [v145 zoneID];
            v175 = [oslog CKRecordWithZoneID:v146];

            v147 = [v175 recordID];
            [v144 setObject:v175 forKeyedSubscript:v147];

            id v148 = objc_alloc_init((Class)NSBlockOperation);
            [v148 setName:@"updateCurrentItemPointer-modifyRecordsComplete"];
            [*(id *)(a1 + 32) dependOnBeforeGroupFinished:v148];
            id v149 = objc_alloc((Class)CKModifyRecordsOperation);
            v150 = [v144 allValues];
            id v151 = [v149 initWithRecordsToSave:v150 recordIDsToDelete:0];
            [*(id *)(a1 + 32) setModifyRecordsOperation:v151];

            v152 = [*(id *)(a1 + 32) modifyRecordsOperation];
            [v152 setAtomic:1];

            v153 = [*(id *)(a1 + 32) modifyRecordsOperation];
            v154 = [v153 configuration];
            [v154 setIsCloudKitSupportOperation:1];

            v155 = [*(id *)(a1 + 32) modifyRecordsOperation];
            [v155 setQualityOfService:25];

            v156 = [*(id *)(a1 + 32) modifyRecordsOperation];
            [v156 setSavePolicy:0];

            v157 = [*(id *)(a1 + 32) ckoperationGroup];
            v158 = [*(id *)(a1 + 32) modifyRecordsOperation];
            [v158 setGroup:v157];

            v187[0] = _NSConcreteStackBlock;
            v187[1] = 3221225472;
            v187[2] = sub_1001699F4;
            v187[3] = &unk_100305380;
            objc_copyWeak(&v188, (id *)(a1 + 40));
            v159 = [*(id *)(a1 + 32) modifyRecordsOperation];
            [v159 setPerRecordSaveBlock:v187];

            v181[0] = _NSConcreteStackBlock;
            v181[1] = 3221225472;
            v181[2] = sub_100169BA0;
            v181[3] = &unk_100306BB0;
            objc_copyWeak(&v186, (id *)(a1 + 40));
            id v160 = v144;
            id v182 = v160;
            id v161 = v148;
            id v183 = v161;
            v184 = oslog;
            v185 = v171;
            v162 = [*(id *)(a1 + 32) modifyRecordsOperation];
            [v162 setModifyRecordsCompletionBlock:v181];

            v163 = *(void **)(a1 + 32);
            v164 = [v163 modifyRecordsOperation];
            [v163 dependOnBeforeGroupFinished:v164];

            v165 = [*(id *)(a1 + 32) deps];
            v166 = [v165 ckdatabase];
            v167 = [*(id *)(a1 + 32) modifyRecordsOperation];
            [v166 addOperation:v167];

            objc_destroyWeak(&v186);
            objc_destroyWeak(&v188);

            v174 = 0;
            uint64_t v39 = 1;
          }
        }
        goto LABEL_96;
      }
    }
    else
    {
      uint64_t v20 = *(void **)(a1 + 32);
    }
    long long v47 = [v20 viewState];
    id v48 = [v47 zoneID];
    __int16 v49 = [v48 zoneName];
    id v50 = sub_1000CD884(@"ckkscurrent", v49);

    if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      v198 = v196;
      _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "Error fetching UUID for new item: %@", buf, 0xCu);
    }

    id v51 = v196;
    [*(id *)(a1 + 32) setError:v196];

    goto LABEL_29;
  }
  uint64_t v2 = [*(id *)(a1 + 32) viewState];
  long long v3 = [v2 zoneID];
  id v4 = [v3 zoneName];
  uint64_t v5 = sub_1000CD884(@"ckkscurrent", v4);

  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "CKKSUpdateCurrentItemPointerOperation cancelled, quitting", buf, 2u);
  }
LABEL_25:
  uint64_t v39 = 0;
LABEL_32:

  return v39;
}

void sub_1001699C4(_Unwind_Exception *a1)
{
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_1001699F4(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  CFStringRef v11 = [WeakRetained viewState];
  unint64_t v12 = [v11 zoneID];
  uint64_t v13 = [v12 zoneName];
  uint64_t v14 = sub_1000CD884(@"ckkscurrent", v13);

  if (v9)
  {
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      int v16 = 138412546;
      id v17 = v9;
      __int16 v18 = 2112;
      id v19 = v7;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "error on row: %@ %@", (uint8_t *)&v16, 0x16u);
    }
  }
  else if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = [v7 recordName];
    int v16 = 138412546;
    id v17 = v15;
    __int16 v18 = 2112;
    id v19 = v8;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Current pointer upload successful for %@: %@", (uint8_t *)&v16, 0x16u);
  }
}

void sub_100169BA0(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 64));
  CFStringRef v11 = [WeakRetained deps];
  unint64_t v12 = [v11 databaseProvider];

  if (v9)
  {
    uint64_t v13 = [WeakRetained viewState];
    uint64_t v14 = [v13 zoneID];
    uint64_t v15 = [v14 zoneName];
    int v16 = sub_1000CD884(@"ckkscurrent", v15);

    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v9;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "CloudKit returned an error: %@", (uint8_t *)&buf, 0xCu);
    }

    [WeakRetained setError:v9];
    v26[0] = _NSConcreteStackBlock;
    v26[1] = 3221225472;
    v26[2] = sub_100169EE0;
    v26[3] = &unk_1003053A8;
    _OWORD v26[4] = WeakRetained;
    id v27 = v9;
    id v28 = *(id *)(a1 + 32);
    [v12 dispatchSyncWithSQLTransaction:v26];
    id v17 = [WeakRetained operationQueue];
    [v17 addOperation:*(void *)(a1 + 40)];
  }
  else
  {
    *(void *)&long long buf = 0;
    *((void *)&buf + 1) = &buf;
    uint64_t v30 = 0x3032000000;
    __int16 v31 = sub_1001671E8;
    unint64_t v32 = sub_1001671F8;
    id v33 = 0;
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 3221225472;
    v21[2] = sub_100169F24;
    v21[3] = &unk_1003053D0;
    id v22 = v7;
    id v18 = *(id *)(a1 + 48);
    id v24 = WeakRetained;
    p_long long buf = &buf;
    id v23 = v18;
    [v12 dispatchSyncWithSQLTransaction:v21];
    uint64_t v19 = *(void *)(*((void *)&buf + 1) + 40);
    if (!v19)
    {
      [WeakRetained _fetchAndUpdateMirrorEntry:*(void *)(a1 + 56)];
      uint64_t v19 = *(void *)(*((void *)&buf + 1) + 40);
    }
    [WeakRetained setError:v19];
    uint64_t v20 = [WeakRetained operationQueue];
    [v20 addOperation:*(void *)(a1 + 40)];

    _Block_object_dispose(&buf, 8);
  }
}

void sub_100169EC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_100169EE0(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) deps];
  id v3 = [v2 intransactionCKWriteFailed:*(void *)(a1 + 40) attemptedRecordsChanged:*(void *)(a1 + 48)];

  return v3;
}

uint64_t sub_100169F24(uint64_t a1)
{
  long long v30 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v30 objects:v38 count:16];
  if (v3)
  {
    id v5 = v3;
    uint64_t v6 = *(void *)v31;
    *(void *)&long long v4 = 138412290;
    long long v28 = v4;
    do
    {
      for (CFIndex i = 0; i != v5; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v31 != v6) {
          objc_enumerationMutation(v2);
        }
        id v8 = *(void **)(*((void *)&v30 + 1) + 8 * i);
        id v9 = [v8 recordType:v28];
        unsigned int v10 = [v9 isEqualToString:@"currentitem"];

        if (v10)
        {
          if ([*(id *)(a1 + 40) matchesCKRecord:v8])
          {
            [*(id *)(a1 + 40) setStoredCKRecord:v8];
            CFStringRef v11 = *(void **)(a1 + 40);
            uint64_t v12 = *(void *)(*(void *)(a1 + 56) + 8);
            id obj = *(id *)(v12 + 40);
            [v11 saveToDatabase:&obj];
            objc_storeStrong((id *)(v12 + 40), obj);
            if (!*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40)) {
              goto LABEL_15;
            }
            uint64_t v13 = [*(id *)(a1 + 48) viewState];
            uint64_t v14 = [v13 zoneID];
            uint64_t v15 = [v14 zoneName];
            int v16 = sub_1000CD884(@"ckkscurrent", v15);

            if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            {
              id v17 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
              *(_DWORD *)long long buf = v28;
              unsigned int v35 = v17;
              id v18 = v16;
              uint64_t v19 = "Couldn't save new current pointer to database: %@";
              uint32_t v20 = 12;
              goto LABEL_13;
            }
          }
          else
          {
            long long v21 = [*(id *)(a1 + 48) viewState];
            id v22 = [v21 zoneID];
            id v23 = [v22 zoneName];
            int v16 = sub_1000CD884(@"ckkscurrent", v23);

            if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            {
              uint64_t v24 = *(void *)(a1 + 40);
              *(_DWORD *)long long buf = 138412546;
              unsigned int v35 = v8;
              __int16 v36 = 2112;
              uint64_t v37 = v24;
              id v18 = v16;
              uint64_t v19 = "CloudKit record does not match saved record, ignoring: %@ %@";
              uint32_t v20 = 22;
LABEL_13:
              _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, v19, buf, v20);
            }
          }
        }
LABEL_15:
        id v25 = [*(id *)(a1 + 48) viewState];
        id v26 = [v25 notifyViewChangedScheduler];
        [v26 trigger];
      }
      id v5 = [v2 countByEnumeratingWithState:&v30 objects:v38 count:16];
    }
    while (v5);
  }

  return 1;
}

void sub_10016A968(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
}

void sub_10016A9A0(uint64_t a1)
{
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  uint64_t v1 = [*(id *)(a1 + 32) deps];
  id v2 = [v1 activeManagedViews];

  id obj = v2;
  id v3 = [v2 countByEnumeratingWithState:&v28 objects:v34 count:16];
  if (v3)
  {
    id v5 = v3;
    uint64_t v6 = *(void *)v29;
    *(void *)&long long v4 = 138412290;
    long long v25 = v4;
    do
    {
      for (CFIndex i = 0; i != v5; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v29 != v6) {
          objc_enumerationMutation(obj);
        }
        id v8 = *(void **)(*((void *)&v28 + 1) + 8 * i);
        id v9 = [v8 zoneID:v25];
        unsigned int v10 = [v8 contextID];
        CFStringRef v11 = +[CKKSCurrentKeySet loadForZone:v9 contextID:v10];

        uint64_t v12 = [v11 currentTLKPointer];

        if (v12)
        {
          uint64_t v13 = *(void **)(a1 + 40);
          uint64_t v14 = [v8 zoneID];
          [v13 setObject:v11 forKeyedSubscript:v14];
        }
        else
        {
          uint64_t v15 = [*(id *)(a1 + 32) previousPendingKeySets];
          int v16 = [v8 zoneID];
          uint64_t v14 = [v15 objectForKeyedSubscript:v16];

          if (v14
            && ([v14 zoneID],
                id v17 = objc_claimAutoreleasedReturnValue(),
                [v8 zoneID],
                id v18 = objc_claimAutoreleasedReturnValue(),
                unsigned int v19 = [v17 isEqual:v18],
                v18,
                v17,
                v19))
          {
            uint32_t v20 = [v8 zoneID];
            long long v21 = [v20 zoneName];
            id v22 = sub_1000CD884(@"ckkstlk", v21);

            if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = v25;
              long long v33 = v14;
              _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Using prevously-generated proposed keyset: %@", buf, 0xCu);
            }

            id v23 = *(void **)(a1 + 40);
            uint64_t v24 = [v8 zoneID];
            [v23 setObject:v14 forKeyedSubscript:v24];
          }
          else
          {
            [*(id *)(a1 + 48) addObject:v8];
          }
        }
      }
      id v5 = [obj countByEnumeratingWithState:&v28 objects:v34 count:16];
    }
    while (v5);
  }
}

uint64_t sub_10016AC9C(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) zoneID];
  id v3 = [v2 zoneName];
  long long v4 = sub_1000CD884(@"ckkstlk", v3);

  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long buf = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Generating new TLK", buf, 2u);
  }

  id v5 = [*(id *)(a1 + 32) contextID];
  uint64_t v6 = [*(id *)(a1 + 32) zoneID];
  id v183 = 0;
  id v7 = +[CKKSKey currentKeyForClass:@"tlk" contextID:v5 zoneID:v6 error:&v183];
  id v8 = (CKKSCurrentKeySet *)v183;

  if (v8)
  {
    id v9 = [*(id *)(a1 + 32) zoneID];
    unsigned int v10 = [v9 zoneName];
    CFStringRef v11 = sub_1000CD884(@"ckkstlk", v10);

    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      v187 = v8;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "couldn't load the current TLK: %@", buf, 0xCu);
    }
  }
  uint64_t v12 = [*(id *)(a1 + 32) contextID];
  id v182 = 0;
  id v13 = [(CKKSCurrentKeySet *)v7 ensureKeyLoadedForContextID:v12 cache:0 error:&v182];
  uint64_t v14 = (CKKSCurrentKeySet *)v182;

  uint64_t v15 = [*(id *)(a1 + 32) zoneID];
  int v16 = [v15 zoneName];
  id v17 = sub_1000CD884(@"ckkstlk", v16);

  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412546;
    v187 = v7;
    __int16 v188 = 2112;
    id v189 = v14;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Old TLK is: %@ %@", buf, 0x16u);
  }

  if (!v14)
  {
    id v181 = 0;
    id v27 = +[CKKSAESSIVKey randomKey:&v181];
    id v28 = v181;
    long long v29 = [CKKSKey alloc];
    long long v30 = [*(id *)(a1 + 32) contextID];
    long long v31 = +[NSUUID UUID];
    long long v32 = [v31 UUIDString];
    uint64_t v159 = a1;
    long long v33 = [*(id *)(a1 + 32) zoneID];
    char v34 = [(CKKSKey *)v29 initSelfWrappedWithAESKey:v27 contextID:v30 uuid:v32 keyclass:@"tlk" state:@"local" zoneID:v33 encodedCKRecord:0 currentkey:1];

    unsigned int v35 = v34;
    id v180 = v28;
    id v160 = [(CKKSCurrentKeySet *)v34 getKeychainBackedKey:&v180];
    id v26 = (CKKSCurrentKeySet *)v180;

    if (!v34 || !v27 || !v160 || v26)
    {
      long long v45 = [*(id *)(v159 + 32) zoneID];
      id v46 = [v45 zoneName];
      long long v47 = sub_1000CD884(@"ckkstlk", v46);

      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        v187 = v26;
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "Couldn't create new TLK: %@", buf, 0xCu);
      }

      [*(id *)(v159 + 40) setNextState:@"error"];
      [*(id *)(v159 + 40) setError:v26];
      uint64_t v44 = 0;
      goto LABEL_50;
    }
    v154 = v8;
    id v179 = 0;
    __int16 v36 = +[CKKSKey randomKeyWrappedByParent:v34 keyclass:@"classA" error:&v179];
    id v37 = v179;
    id v178 = v37;
    long long v38 = +[CKKSKey randomKeyWrappedByParent:v34 keyclass:@"classC" error:&v178];
    uint64_t v39 = (CKKSCurrentKeySet *)v178;

    if (v39)
    {
      uint64_t v40 = v39;
      id v41 = [*(id *)(v159 + 32) zoneID];
      long long v42 = [v41 zoneName];
      long long v43 = sub_1000CD884(@"ckkstlk", v42);

      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        v187 = v40;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "couldn't make new key hierarchy: %@", buf, 0xCu);
      }

      [*(id *)(v159 + 40) setError:v40];
      [*(id *)(v159 + 40) setNextState:@"error"];

      id v26 = v40;
      uint64_t v44 = 0;
      id v8 = v154;
      goto LABEL_50;
    }
    v147 = v27;
    id v48 = v36;
    __int16 v49 = v38;
    uint64_t v50 = v159;
    id v51 = [*(id *)(v159 + 32) contextID];
    v155 = v35;
    id v52 = [(CKKSCurrentKeySet *)v35 uuid];
    long long v53 = [*(id *)(v159 + 32) zoneID];
    id v177 = 0;
    v150 = +[CKKSCurrentKeyPointer forKeyClass:@"tlk" contextID:v51 withKeyUUID:v52 zoneID:v53 error:&v177];
    id v54 = v177;

    long long v55 = [*(id *)(v159 + 32) contextID];
    v152 = v48;
    long long v56 = [v48 uuid];
    long long v57 = [*(id *)(v159 + 32) zoneID];
    id v176 = v54;
    id v149 = +[CKKSCurrentKeyPointer forKeyClass:@"classA" contextID:v55 withKeyUUID:v56 zoneID:v57 error:&v176];
    id v58 = v176;

    long long v59 = [*(id *)(v159 + 32) contextID];
    id v151 = v49;
    long long v60 = [v49 uuid];
    v61 = [*(id *)(v159 + 32) zoneID];
    id v175 = v58;
    uint64_t v62 = +[CKKSCurrentKeyPointer forKeyClass:@"classC" contextID:v59 withKeyUUID:v60 zoneID:v61 error:&v175];
    uint64_t v63 = (CKKSCurrentKeySet *)v175;

    id v26 = v63;
    id v148 = (void *)v62;
    if (v63)
    {
      __int16 v64 = [*(id *)(v159 + 32) zoneID];
      id v65 = [v64 zoneName];
      v66 = sub_1000CD884(@"ckkstlk", v65);

      if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        v187 = v26;
        _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_ERROR, "couldn't make current key records: %@", buf, 0xCu);
      }

      [*(id *)(v159 + 40) setNextState:@"error"];
      [*(id *)(v159 + 40) setError:v26];
      uint64_t v44 = 0;
      id v27 = v147;
      unsigned int v35 = v155;
      goto LABEL_48;
    }
    id v67 = [(CKKSCurrentKeySet *)v7 copy];
    unsigned int v35 = v155;
    if (v67)
    {
      v68 = [(CKKSCurrentKeySet *)v7 contextID];
      id v174 = 0;
      id v69 = [v67 ensureKeyLoadedForContextID:v68 cache:0 error:&v174];
      CFStringRef v70 = (CKKSCurrentKeySet *)v174;

      if (v70)
      {
        CFStringRef v71 = v67;
        CFDataRef v72 = [*(id *)(v159 + 40) deps];
        CFNumberRef v73 = [v72 lockStateTracker];
        unsigned int v74 = [v73 isLockedError:v70];

        v75 = [*(id *)(v159 + 32) zoneID];
        v76 = [v75 zoneName];
        uint64_t v77 = sub_1000CD884(@"ckkstlk", v76);

        BOOL v78 = os_log_type_enabled(v77, OS_LOG_TYPE_ERROR);
        id v26 = v70;
        if (v74)
        {
          if (v78)
          {
            *(_DWORD *)long long buf = 138412290;
            v187 = v70;
            _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_ERROR, "Couldn't unwrap TLK due to lock state. Entering a waiting state; %@",
              buf,
              0xCu);
          }

          *(unsigned char *)(*(void *)(*(void *)(v159 + 64) + 8) + 24) = 1;
        }
        else
        {
          if (v78)
          {
            *(_DWORD *)long long buf = 138412290;
            v187 = v70;
            _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_ERROR, "couldn't unwrap TLK, aborting new TLK operation: %@", buf, 0xCu);
          }

          [*(id *)(v159 + 40) setNextState:@"error"];
        }
        [*(id *)(v159 + 40) setError:v70];

LABEL_47:
        uint64_t v44 = 0;
        id v27 = v147;
LABEL_48:
        unsigned int v85 = v151;
        unsigned __int8 v84 = v152;
LABEL_49:

LABEL_50:
        goto LABEL_51;
      }
      id v173 = 0;
      [v67 wrapUnder:v155 error:&v173];
      v79 = (CKKSCurrentKeySet *)v173;
      if (v79)
      {
        id v26 = v79;
        v80 = v67;
        v81 = [*(id *)(v159 + 32) zoneID];
        uint64_t v82 = [v81 zoneName];
        CFStringRef v83 = sub_1000CD884(@"ckkstlk", v82);

        if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138412290;
          v187 = v26;
          _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_ERROR, "couldn't wrap oldTLK, aborting new TLK operation: %@", buf, 0xCu);
        }

        [*(id *)(v159 + 40) setNextState:@"error"];
        [*(id *)(v159 + 40) setError:v26];

        goto LABEL_47;
      }
      [v67 setCurrentkey:0];
      uint64_t v62 = (uint64_t)v148;
    }
    v141 = v67;
    v87 = [CKKSCurrentKeySet alloc];
    v88 = [(CKKSCurrentKeySet *)v155 zoneID];
    v89 = [(CKKSCurrentKeySet *)v155 contextID];
    v90 = [(CKKSCurrentKeySet *)v87 initWithZoneID:v88 contextID:v89];

    [(CKKSCurrentKeySet *)v90 setTlk:v155];
    [(CKKSCurrentKeySet *)v90 setClassA:v48];
    [(CKKSCurrentKeySet *)v90 setClassC:v151];
    [(CKKSCurrentKeySet *)v90 setCurrentTLKPointer:v150];
    [(CKKSCurrentKeySet *)v90 setCurrentClassAPointer:v149];
    [(CKKSCurrentKeySet *)v90 setCurrentClassCPointer:v62];
    [(CKKSCurrentKeySet *)v90 setProposed:1];
    long long v91 = [*(id *)(v159 + 32) zoneID];
    long long v92 = [v91 zoneName];
    long long v93 = sub_1000CD884(@"ckkstlk", v92);

    if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      v187 = v90;
      _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_DEFAULT, "Saving new keys %@ to keychain", buf, 0xCu);
    }

    id v172 = 0;
    [(CKKSCurrentKeySet *)v155 saveKeyMaterialToKeychain:&v172];
    id v94 = v172;
    id v171 = v94;
    [v48 saveKeyMaterialToKeychain:&v171];
    id v95 = v171;

    id v170 = v95;
    [v151 saveKeyMaterialToKeychain:&v170];
    long long v96 = (CKKSCurrentKeySet *)v170;

    v142 = v90;
    if (v96)
    {
      long long v97 = [*(id *)(v159 + 40) deps];
      id v98 = [v97 lockStateTracker];
      unsigned int v99 = [v98 isLockedError:v96];

      __int16 v100 = [*(id *)(v159 + 32) zoneID];
      v101 = [v100 zoneName];
      v102 = sub_1000CD884(@"ckkstlk", v101);

      BOOL v103 = os_log_type_enabled(v102, OS_LOG_TYPE_ERROR);
      id v26 = v96;
      if (v99)
      {
        if (v103)
        {
          *(_DWORD *)long long buf = 138412290;
          v187 = v96;
          _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_ERROR, "Couldn't save new key material to keychain due to lock state. Entering a waiting state; %@",
            buf,
            0xCu);
        }

        *(unsigned char *)(*(void *)(*(void *)(v159 + 64) + 8) + 24) = 1;
      }
      else
      {
        if (v103)
        {
          *(_DWORD *)long long buf = 138412290;
          v187 = v96;
          _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_ERROR, "couldn't save new key material to keychain; aborting new TLK operation: %@",
            buf,
            0xCu);
        }

        [*(id *)(v159 + 40) setNextState:@"error"];
      }
      [*(id *)(v159 + 40) setError:v96];
      uint64_t v44 = 0;
LABEL_100:
      id v27 = v147;
      unsigned int v85 = v151;
      unsigned __int8 v84 = v152;

      goto LABEL_49;
    }
    v104 = +[NSMutableSet set];
    long long v166 = 0u;
    long long v167 = 0u;
    long long v168 = 0u;
    long long v169 = 0u;
    id obj = *(id *)(v159 + 48);
    id v146 = [obj countByEnumeratingWithState:&v166 objects:v185 count:16];
    id v26 = 0;
    if (!v146)
    {
LABEL_91:

      BOOL v136 = [v104 allObjects];
      [(CKKSCurrentKeySet *)v142 setPendingTLKShares:v136];

      int v137 = *(void **)(v50 + 56);
      v138 = [(CKKSCurrentKeySet *)v35 zoneID];
      [v137 setObject:v142 forKeyedSubscript:v138];
      uint64_t v44 = 1;
LABEL_99:

      goto LABEL_100;
    }
    uint64_t v145 = *(void *)v167;
    id v144 = v7;
    v158 = v104;
LABEL_62:
    id v105 = 0;
    while (1)
    {
      if (*(void *)v167 != v145) {
        objc_enumerationMutation(obj);
      }
      v106 = v26;
      v153 = (char *)v105;
      v107 = *(CKKSCurrentKeySet **)(*((void *)&v166 + 1) + 8 * (void)v105);
      v108 = [(CKKSCurrentKeySet *)v107 currentSelfPeers];
      uint64_t v109 = [v108 currentSelf];
      if (!v109) {
        break;
      }
      v110 = (void *)v109;
      v111 = [(CKKSCurrentKeySet *)v107 currentSelfPeersError];

      if (v111) {
        goto LABEL_82;
      }
      long long v164 = 0u;
      long long v165 = 0u;
      long long v162 = 0u;
      long long v163 = 0u;
      v157 = v107;
      v156 = [(CKKSCurrentKeySet *)v107 currentTrustedPeers];
      id v112 = [v156 countByEnumeratingWithState:&v162 objects:v184 count:16];
      if (v112)
      {
        id v113 = v112;
        uint64_t v114 = *(void *)v163;
        do
        {
          for (CFIndex i = 0; i != v113; CFIndex i = (char *)i + 1)
          {
            if (*(void *)v163 != v114) {
              objc_enumerationMutation(v156);
            }
            v116 = *(CKKSCurrentKeySet **)(*((void *)&v162 + 1) + 8 * i);
            v117 = [(CKKSCurrentKeySet *)v116 publicEncryptionKey];

            v118 = [*(id *)(v50 + 32) zoneID];
            v119 = [v118 zoneName];
            v120 = sub_1000CD884(@"ckkstlk", v119);

            BOOL v121 = os_log_type_enabled(v120, OS_LOG_TYPE_DEFAULT);
            if (v117)
            {
              if (v121)
              {
                *(_DWORD *)long long buf = 138412546;
                v187 = v155;
                __int16 v188 = 2112;
                id v189 = v116;
                _os_log_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_DEFAULT, "Generating TLK(%@) share for %@", buf, 0x16u);
              }

              v122 = [*(id *)(v50 + 32) contextID];
              uint64_t v123 = [(CKKSCurrentKeySet *)v157 currentSelfPeers];
              v124 = [v123 currentSelf];
              id v161 = v106;
              v120 = +[CKKSTLKShareRecord share:v160 contextID:v122 as:v124 to:v116 epoch:-1 poisoned:0 error:&v161];
              v125 = v161;

              uint64_t v50 = v159;
              [v158 addObject:v120];
              v106 = v125;
            }
            else if (v121)
            {
              *(_DWORD *)long long buf = 138412290;
              v187 = v116;
              _os_log_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_DEFAULT, "No need to make TLK for %@; they don't have any encryption keys",
                buf,
                0xCu);
            }
          }
          id v113 = [v156 countByEnumeratingWithState:&v162 objects:v184 count:16];
        }
        while (v113);
        id v7 = v144;
        v126 = v153;
        id v8 = v154;
        id v26 = v106;
        v104 = v158;
        unsigned int v35 = v155;
        v127 = v156;
        goto LABEL_87;
      }
      id v26 = v106;
      v104 = v158;
      v126 = v153;
      v127 = v156;
LABEL_86:
      id v7 = v144;
LABEL_87:

      id v105 = v126 + 1;
      if (v105 == v146)
      {
        id v135 = [obj countByEnumeratingWithState:&v166 objects:v185 count:16];
        id v146 = v135;
        if (v135) {
          goto LABEL_62;
        }
        goto LABEL_91;
      }
    }

LABEL_82:
    v128 = v107;
    unsigned int v129 = [(CKKSCurrentKeySet *)v107 essential];
    v130 = [*(id *)(v50 + 32) zoneID];
    v131 = [v130 zoneName];
    v132 = sub_1000CD884(@"ckkstlk", v131);

    v133 = v132;
    BOOL v134 = os_log_type_enabled(v132, OS_LOG_TYPE_DEFAULT);
    v126 = v153;
    if (v129)
    {
      unsigned int v35 = v155;
      id v26 = v106;
      v104 = v158;
      if (v134)
      {
        v139 = [(CKKSCurrentKeySet *)v128 currentSelfPeersError];
        *(_DWORD *)long long buf = 138412546;
        v187 = v155;
        __int16 v188 = 2112;
        id v189 = v139;
        _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "Fatal error: unable to generate TLK shares for (%@): %@", buf, 0x16u);
      }
      v140 = [(CKKSCurrentKeySet *)v128 currentSelfPeersError];
      [*(id *)(v50 + 40) setError:v140];

      [*(id *)(v50 + 40) setNextState:@"error"];
      uint64_t v44 = 0;
      v138 = obj;
      id v7 = v144;
      goto LABEL_99;
    }
    unsigned int v35 = v155;
    id v26 = v106;
    v104 = v158;
    if (v134)
    {
      *(_DWORD *)long long buf = 138412546;
      v187 = v155;
      __int16 v188 = 2112;
      id v189 = v128;
      v127 = v133;
      _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "Unable to generate TLK shares for (%@): %@", buf, 0x16u);
    }
    else
    {
      v127 = v133;
    }
    goto LABEL_86;
  }
  id v18 = [*(id *)(a1 + 40) deps];
  unsigned int v19 = [v18 lockStateTracker];
  uint32_t v20 = v14;
  unsigned int v21 = [v19 isLockedError:v14];

  id v22 = [*(id *)(a1 + 32) zoneID];
  id v23 = [v22 zoneName];
  uint64_t v24 = sub_1000CD884(@"ckkstlk", v23);

  BOOL v25 = os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
  id v26 = v20;
  if (v21)
  {
    if (v25)
    {
      *(_DWORD *)long long buf = 138412290;
      v187 = v20;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Couldn't fetch and unwrap old TLK due to lock state. Entering a waiting state; %@",
        buf,
        0xCu);
    }

    *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = 1;
  }
  else
  {
    if (v25)
    {
      *(_DWORD *)long long buf = 138412290;
      v187 = v20;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Couldn't fetch and unwrap old TLK: %@", buf, 0xCu);
    }

    [*(id *)(a1 + 40) setNextState:@"error"];
  }
  [*(id *)(a1 + 40) setError:v20];
  unsigned int v35 = 0;
  uint64_t v44 = 0;
LABEL_51:

  return v44;
}

id sub_10016CA44(uint64_t a1, void *a2)
{
  id v3 = a2;
  long long v4 = v3;
  if (*(unsigned char *)(a1 + 40)) {
    uint64_t v5 = 2;
  }
  else {
    uint64_t v5 = 1;
  }
  [v3 setIcloudAccountState:v5];
  [v4 setAltDSID:*(void *)(a1 + 32)];

  return v4;
}

OTAccountMetadataClassC *__cdecl sub_10016CAA0(id a1, OTAccountMetadataClassC *a2)
{
  id v2 = a2;
  [(OTAccountMetadataClassC *)v2 setIcloudAccountState:1];
  [(OTAccountMetadataClassC *)v2 setAltDSID:0];

  return v2;
}

id sub_10016D8EC(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 setTrustState:[*(id *)(a1 + 32) trustState]];
  long long v4 = [*(id *)(a1 + 32) peerID];
  [v3 setPeerID:v4];

  return v3;
}

void sub_10016DAA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10016DAC8(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  CFStringRef v11 = WeakRetained;
  if (v8 && v7 && !v9)
  {
    [WeakRetained afterTPHTrustState:v7 trustedPeers:v8];
  }
  else
  {
    uint64_t v12 = sub_10000B070("SecError");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = 138412290;
      id v15 = v9;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "octagon: TPH was unable to determine current peer state: %@", (uint8_t *)&v14, 0xCu);
    }

    [v11 setError:v9];
    [v11 setNextState:@"Error"];
    id v13 = [v11 finishedOp];
    [v11 runBeforeGroupFinished:v13];
  }
}

uint64_t sub_10016F048(uint64_t a1, uint64_t a2)
{
  while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      break;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0;
    while (1)
    {
      uint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      unint64_t v8 = v7 + 1;
      if (v7 == -1 || v8 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v9 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v8;
      v6 |= (unint64_t)(v9 & 0x7F) << v4;
      if ((v9 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v10 = v5++ >= 9;
      if (v10)
      {
        unint64_t v6 = 0;
        int v11 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }
    *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v11 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0;
    }
LABEL_13:
    if (v11 || (v6 & 7) == 4) {
      break;
    }
    switch((v6 >> 3))
    {
      case 1u:
        uint64_t v13 = PBReaderReadString();
        uint64_t v14 = 32;
        goto LABEL_53;
      case 2u:
        *(unsigned char *)(a1 + 184) |= 2u;
        unint64_t v18 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v18 <= 0xFFFFFFFFFFFFFFF7 && v18 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          uint64_t v19 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v18);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v18 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          uint64_t v19 = 0;
        }
        uint64_t v28 = 24;
        goto LABEL_64;
      case 3u:
        *(unsigned char *)(a1 + 184) |= 1u;
        unint64_t v20 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v20 <= 0xFFFFFFFFFFFFFFF7 && v20 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          uint64_t v19 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v20);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v20 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          uint64_t v19 = 0;
        }
        uint64_t v28 = 16;
LABEL_64:
        *(void *)(a1 + v28) = v19;
        continue;
      case 4u:
        uint64_t v13 = PBReaderReadString();
        uint64_t v14 = 48;
        goto LABEL_53;
      case 5u:
        uint64_t v13 = PBReaderReadString();
        uint64_t v14 = 152;
        goto LABEL_53;
      case 6u:
        uint64_t v13 = PBReaderReadString();
        uint64_t v14 = 168;
        goto LABEL_53;
      case 7u:
        char v21 = 0;
        unsigned int v22 = 0;
        uint64_t v23 = 0;
        *(unsigned char *)(a1 + 184) |= 4u;
        break;
      case 8u:
        uint64_t v13 = PBReaderReadString();
        uint64_t v14 = 56;
        goto LABEL_53;
      case 9u:
        uint64_t v13 = PBReaderReadData();
        uint64_t v14 = 104;
        goto LABEL_53;
      case 0xAu:
        uint64_t v13 = PBReaderReadString();
        uint64_t v14 = 136;
        goto LABEL_53;
      case 0xBu:
        uint64_t v13 = PBReaderReadString();
        uint64_t v14 = 96;
        goto LABEL_53;
      case 0xCu:
        uint64_t v13 = PBReaderReadString();
        uint64_t v14 = 120;
        goto LABEL_53;
      case 0xDu:
        uint64_t v13 = PBReaderReadString();
        uint64_t v14 = 40;
        goto LABEL_53;
      case 0xEu:
        uint64_t v13 = PBReaderReadString();
        uint64_t v14 = 176;
        goto LABEL_53;
      case 0xFu:
        uint64_t v13 = PBReaderReadString();
        uint64_t v14 = 160;
        goto LABEL_53;
      case 0x10u:
        uint64_t v13 = PBReaderReadData();
        uint64_t v14 = 128;
        goto LABEL_53;
      case 0x11u:
        uint64_t v13 = PBReaderReadData();
        uint64_t v14 = 112;
        goto LABEL_53;
      case 0x12u:
        uint64_t v13 = PBReaderReadData();
        uint64_t v14 = 64;
        goto LABEL_53;
      case 0x13u:
        uint64_t v13 = PBReaderReadData();
        uint64_t v14 = 72;
        goto LABEL_53;
      case 0x14u:
        uint64_t v13 = PBReaderReadData();
        uint64_t v14 = 80;
        goto LABEL_53;
      case 0x15u:
        uint64_t v13 = PBReaderReadData();
        uint64_t v14 = 88;
LABEL_53:
        id v27 = *(void **)(a1 + v14);
        *(void *)(a1 + v14) = v13;

        continue;
      default:
        if (!*(void *)(a1 + 8))
        {
          id v15 = objc_alloc_init((Class)PBUnknownFields);
          int v16 = *(void **)(a1 + 8);
          *(void *)(a1 + 8) = v15;
        }
        uint64_t result = PBUnknownFieldAdd();
        if (!result) {
          return result;
        }
        continue;
    }
    while (1)
    {
      uint64_t v24 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      unint64_t v25 = v24 + 1;
      if (v24 == -1 || v25 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v26 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v24);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v25;
      v23 |= (unint64_t)(v26 & 0x7F) << v21;
      if ((v26 & 0x80) == 0) {
        goto LABEL_57;
      }
      v21 += 7;
      BOOL v10 = v22++ >= 9;
      if (v10)
      {
        LODWORD(v23) = 0;
        goto LABEL_59;
      }
    }
    *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_57:
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      LODWORD(v23) = 0;
    }
LABEL_59:
    *(_DWORD *)(a1 + 144) = v23;
  }
  return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

void sub_100171914(uint64_t a1)
{
  [*(id *)(*(void *)(a1 + 32) + 48) addObject:*(void *)(a1 + 40)];
  char v2 = [*(id *)(a1 + 32) queueIsLocked] ^ 1;
  id v3 = dispatch_get_global_queue(21, 0);
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_1001719DC;
  v4[3] = &unk_1003055B0;
  id v5 = *(id *)(a1 + 40);
  char v6 = v2;
  dispatch_async(v3, v4);
}

id sub_1001719DC(uint64_t a1)
{
  return [*(id *)(a1 + 32) lockStateChangeNotification:*(unsigned __int8 *)(a1 + 40)];
}

id sub_100171A90(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) queueIsLocked];
  if ((result & 1) == 0)
  {
    id v3 = *(void **)(a1 + 32);
    return [v3 _onqueueRecheck];
  }
  return result;
}

id sub_100171CA0(uint64_t a1)
{
  return [*(id *)(a1 + 32) _onqueueRecheck];
}

id sub_100171F20(uint64_t a1)
{
  return [*(id *)(a1 + 32) lockStateChangeNotification:*(unsigned __int8 *)(a1 + 40)];
}

void sub_100171FF4(id a1)
{
  uint64_t v1 = sub_1000CD884(@"ckks", 0);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)char v2 = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "Keybag unlocked", v2, 2u);
  }
}

void sub_100172224(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10017223C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10017224C(uint64_t a1)
{
}

id sub_100172254(uint64_t a1)
{
  if ([*(id *)(a1 + 32) queueIsLocked])
  {
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = [*(id *)(a1 + 32) lastUnlockedTime];
    return (id)_objc_release_x1();
  }
  else
  {
    uint64_t v2 = +[NSDate date];
    uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
    char v4 = *(void **)(v3 + 40);
    *(void *)(v3 + 40) = v2;

    id v5 = *(void **)(a1 + 32);
    uint64_t v6 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    return [v5 setLastUnlockedTime:v6];
  }
}

uint64_t sub_1001723A8(uint64_t result)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 40) + 8) + 24) = *(unsigned char *)(*(void *)(result + 32) + 8);
  return result;
}

void sub_100172610(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10017262C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained _onqueueRecheck];
}

void sub_10017266C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained _onqueueRecheck];
}

void sub_100172700(id a1)
{
  uint64_t v1 = [CKKSLockStateTracker alloc];
  char v4 = objc_alloc_init(CKKSActualLockStateProvider);
  uint64_t v2 = [(CKKSLockStateTracker *)v1 initWithProvider:v4];
  uint64_t v3 = (void *)qword_10035D1E0;
  qword_10035D1E0 = (uint64_t)v2;
}

void sub_100172904(id a1)
{
  id v3 = +[NSUUID UUID];
  uint64_t v1 = [v3 UUIDString];
  uint64_t v2 = (void *)qword_10035D208;
  qword_10035D208 = v1;
}

id sub_1001729B8()
{
  if (qword_10035D200 != -1) {
    dispatch_once(&qword_10035D200, &stru_1003055F0);
  }
  v0 = (void *)qword_10035D1F8;

  return v0;
}

void sub_100172A0C(id a1)
{
  id v3 = +[NSBundle mainBundle];
  uint64_t v1 = [v3 infoDictionary];
  uint64_t v2 = (void *)qword_10035D1F8;
  qword_10035D1F8 = v1;
}

id sub_100172ACC(void *a1)
{
  uint64_t v1 = qword_10035D218;
  id v2 = a1;
  if (v1 != -1) {
    dispatch_once(&qword_10035D218, &stru_100305630);
  }
  id v3 = [(id)qword_10035D1F0 objectForKeyedSubscript:v2];

  return v3;
}

void sub_100172B48(id a1)
{
  id v1 = [objc_alloc((Class)NSMutableDictionary) initWithCapacity:0];
  id v2 = (void *)qword_10035D1F0;
  qword_10035D1F0 = (uint64_t)v1;

  long long v12 = 0u;
  long long v13 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  *(void *)&long long buf = @"UniqueDeviceID";
  *((void *)&buf + 1) = @"BuildVersion";
  CFStringRef v16 = @"ProductName";
  CFStringRef v17 = @"ProductType";
  CFStringRef v18 = @"ProductVersion";
  id v3 = +[NSArray arrayWithObjects:&buf count:5];
  id v4 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v11;
    do
    {
      for (CFIndex i = 0; i != v5; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v11 != v6) {
          objc_enumerationMutation(v3);
        }
        uint64_t v8 = *(void *)(*((void *)&v10 + 1) + 8 * i);
        char v9 = (void *)MGCopyAnswer();
        if (v9)
        {
          [(id)qword_10035D1F0 setObject:v9 forKeyedSubscript:v8];
        }
        else if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 138412290;
          *(void *)((char *)&buf + 4) = v8;
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_DEFAULT, "Error getting %@ from MobileGestalt", (uint8_t *)&buf, 0xCu);
        }
      }
      id v5 = [v3 countByEnumeratingWithState:&v10 objects:v14 count:16];
    }
    while (v5);
  }
}

void sub_100176700(uint64_t a1, void *a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = [a2 description];
  [v2 addObject:v3];
}

void sub_100176758(uint64_t a1, void *a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = [a2 description];
  [v2 addObject:v3];
}

void sub_100176A78(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100176AA0(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v3 = +[NSMutableArray array];
  id v4 = (void *)v3;
  if (!*(unsigned char *)(a1 + 56))
  {
    id v113 = (void *)v3;
    id v5 = [WeakRetained accountTracker];
    uint64_t v6 = [v5 ckdeviceIDInitialized];
    [v6 wait:1000000000];

    uint64_t v7 = [WeakRetained accountTracker];
    uint64_t v8 = [v7 ckdeviceID];

    char v9 = [WeakRetained accountTracker];
    long long v10 = [v9 ckdeviceIDError];

    long long v11 = +[CKKSAnalytics logger];
    v104 = [v11 datePropertyForKey:@"lastCKKSPush"];

    long long v12 = +[NSMutableArray array];
    long long v13 = [WeakRetained operationQueue];
    uint64_t v14 = [v13 operations];
    id v15 = [v14 copy];

    long long v120 = 0u;
    long long v121 = 0u;
    long long v118 = 0u;
    long long v119 = 0u;
    id v16 = v15;
    id v17 = [v16 countByEnumeratingWithState:&v118 objects:v124 count:16];
    if (v17)
    {
      id v18 = v17;
      uint64_t v19 = *(void *)v119;
      do
      {
        for (CFIndex i = 0; i != v18; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v119 != v19) {
            objc_enumerationMutation(v16);
          }
          char v21 = [*(id *)(*((void *)&v118 + 1) + 8 * i) description];
          [v12 addObject:v21];
        }
        id v18 = [v16 countByEnumeratingWithState:&v118 objects:v124 count:16];
      }
      while (v18);
    }

    v123[0] = @"global";
    v122[0] = @"view";
    v122[1] = @"reachability";
    id v112 = [WeakRetained reachabilityTracker];
    unsigned int v22 = [v112 currentReachability];
    CFStringRef v23 = @"no-network";
    if (v22) {
      CFStringRef v23 = @"network";
    }
    v123[1] = v23;
    v122[2] = @"activeAccount";
    uint64_t v24 = [WeakRetained operationDependencies];
    unint64_t v25 = [v24 activeAccount];
    char v26 = [v25 description];

    if (v26)
    {
      id v27 = v26;
    }
    else
    {
      id v27 = +[NSNull null];
    }
    id v28 = v27;

    v123[2] = v28;
    v122[3] = @"ckdeviceID";
    id v29 = v8;
    long long v30 = v29;
    if (v29)
    {
      id v31 = v29;
    }
    else
    {
      id v31 = +[NSNull null];
    }
    id v32 = v31;

    v123[3] = v32;
    v122[4] = @"ckdeviceIDError";
    id v33 = v10;
    char v34 = v33;
    v111 = v30;
    if (v33)
    {
      id v35 = v33;
    }
    else
    {
      id v35 = +[NSNull null];
    }
    id v36 = v35;
    uint64_t v109 = v34;

    v107 = v36;
    v123[4] = v36;
    v122[5] = @"lockstatetracker";
    id v37 = [WeakRetained lockStateTracker];
    long long v38 = [v37 description];

    v108 = v32;
    if (v38)
    {
      id v39 = v38;
    }
    else
    {
      id v39 = +[NSNull null];
    }
    id v40 = v39;

    v106 = v40;
    v123[5] = v40;
    v122[6] = @"cloudkitRetryAfter";
    id v41 = [WeakRetained operationDependencies];
    long long v42 = [v41 cloudkitRetryAfter];
    long long v43 = [v42 description];

    if (v43)
    {
      id v44 = v43;
    }
    else
    {
      id v44 = +[NSNull null];
    }
    id v45 = v44;

    v123[6] = v45;
    v122[7] = @"lastCKKSPush";
    id v46 = v104;
    long long v47 = v46;
    v110 = v28;
    if (v46)
    {
      id v48 = v46;
    }
    else
    {
      id v48 = +[NSNull null];
    }
    id v49 = v48;
    id v105 = v47;

    v102 = v49;
    v123[7] = v49;
    v122[8] = @"policy";
    uint64_t v50 = [WeakRetained syncingPolicy];
    id v51 = [v50 description];

    if (v51)
    {
      id v52 = v51;
    }
    else
    {
      id v52 = +[NSNull null];
    }
    id v53 = v52;

    v123[8] = v53;
    v123[9] = @"yes";
    v122[9] = @"viewsFromPolicy";
    v122[10] = @"ckaccountstatus";
    v101 = v53;
    if ([WeakRetained accountStatus])
    {
      if ([WeakRetained accountStatus] == (id)1)
      {
        CFStringRef v54 = @"logged in";
      }
      else if ([WeakRetained accountStatus] == (id)2)
      {
        CFStringRef v54 = @"restricted";
      }
      else
      {
        id v55 = [WeakRetained accountStatus];
        CFStringRef v54 = @"unknown";
        if (v55 == (id)3) {
          CFStringRef v54 = @"logged out";
        }
      }
    }
    else
    {
      CFStringRef v54 = @"could not determine";
    }
    v123[10] = v54;
    v122[11] = @"accounttracker";
    long long v56 = [WeakRetained accountTracker];
    long long v57 = [v56 description];

    if (v57)
    {
      id v58 = v57;
    }
    else
    {
      id v58 = +[NSNull null];
    }
    id v59 = v58;

    __int16 v100 = v59;
    v123[11] = v59;
    v122[12] = @"fetcher";
    long long v60 = [WeakRetained zoneChangeFetcher];
    v61 = [v60 description];

    if (v61)
    {
      id v62 = v61;
    }
    else
    {
      id v62 = +[NSNull null];
    }
    id v63 = v62;

    unsigned int v99 = v63;
    v123[12] = v63;
    v122[13] = @"ckksstate";
    __int16 v64 = [WeakRetained stateMachine];
    id v65 = [v64 currentState];

    if (v65)
    {
      id v66 = v65;
    }
    else
    {
      id v66 = +[NSNull null];
    }
    id v67 = v66;

    id v98 = v67;
    v123[13] = v67;
    v122[14] = @"lastIncomingQueueOperation";
    v68 = [WeakRetained lastIncomingQueueOperation];
    id v69 = [v68 description];

    if (v69)
    {
      id v70 = v69;
    }
    else
    {
      id v70 = +[NSNull null];
    }
    id v71 = v70;

    long long v97 = v71;
    v123[14] = v71;
    v122[15] = @"lastNewTLKOperation";
    CFDataRef v72 = [WeakRetained lastNewTLKOperation];
    CFNumberRef v73 = [v72 description];

    if (v73)
    {
      id v74 = v73;
    }
    else
    {
      id v74 = +[NSNull null];
    }
    id v75 = v74;

    long long v96 = v75;
    v123[15] = v75;
    v122[16] = @"lastOutgoingQueueOperation";
    v76 = [WeakRetained lastOutgoingQueueOperation];
    uint64_t v77 = [v76 description];

    if (v77)
    {
      id v78 = v77;
    }
    else
    {
      id v78 = +[NSNull null];
    }
    v79 = v78;

    v123[16] = v79;
    v122[17] = @"lastProcessReceivedKeysOperation";
    v80 = [WeakRetained lastProcessReceivedKeysOperation];
    v81 = [v80 description];

    BOOL v103 = v45;
    if (v81)
    {
      id v82 = v81;
    }
    else
    {
      id v82 = +[NSNull null];
    }
    CFStringRef v83 = v82;

    v123[17] = v83;
    v122[18] = @"lastReencryptOutgoingItemsOperation";
    unsigned __int8 v84 = [WeakRetained lastReencryptOutgoingItemsOperation];
    unsigned int v85 = [v84 description];

    if (v85)
    {
      id v86 = v85;
    }
    else
    {
      id v86 = +[NSNull null];
    }
    v87 = v86;

    v123[18] = v87;
    v122[19] = @"launchSequence";
    v88 = [WeakRetained operationDependencies];
    v89 = [v88 overallLaunch];
    v90 = [v89 eventsByTime];

    if (v90)
    {
      id v91 = v90;
    }
    else
    {
      id v91 = +[NSNull null];
    }
    long long v92 = v91;

    v122[20] = @"operationQueue";
    v123[19] = v92;
    v123[20] = v12;
    long long v93 = +[NSDictionary dictionaryWithObjects:v123 forKeys:v122 count:21];

    id v4 = v113;
    [v113 addObject:v93];
  }
  v114[0] = _NSConcreteStackBlock;
  v114[1] = 3221225472;
  v114[2] = sub_10017747C;
  v114[3] = &unk_100305A60;
  v114[4] = WeakRetained;
  id v94 = *(id *)(a1 + 32);
  char v117 = *(unsigned char *)(a1 + 56);
  id v115 = v94;
  id v116 = v4;
  id v95 = v4;
  [WeakRetained dispatchSyncWithReadOnlySQLTransaction:v114];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_10017747C(uint64_t a1)
{
  id v2 = +[NSMutableArray array];
  long long v39 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  uint64_t v3 = [*(id *)(a1 + 32) operationDependencies];
  id v4 = [v3 allViews];

  id v5 = [v4 countByEnumeratingWithState:&v39 objects:v47 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v40;
    do
    {
      for (CFIndex i = 0; i != v6; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v40 != v7) {
          objc_enumerationMutation(v4);
        }
        uint64_t v9 = *(void *)(*((void *)&v39 + 1) + 8 * i);
        long long v10 = *(void **)(a1 + 40);
        if (v10)
        {
          long long v11 = [*(id *)(*((void *)&v39 + 1) + 8 * i) zoneName];
          unsigned int v12 = [v10 isEqualToString:v11];

          if (!v12) {
            continue;
          }
        }
        [v2 addObject:v9];
      }
      id v6 = [v4 countByEnumeratingWithState:&v39 objects:v47 count:16];
    }
    while (v6);
  }

  long long v13 = +[NSSortDescriptor sortDescriptorWithKey:@"zoneName" ascending:1];
  id v46 = v13;
  uint64_t v14 = +[NSArray arrayWithObjects:&v46 count:1];
  id v32 = v2;
  id v15 = [v2 sortedArrayUsingDescriptors:v14];

  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  id obj = v15;
  id v16 = [obj countByEnumeratingWithState:&v35 objects:v45 count:16];
  if (v16)
  {
    id v17 = v16;
    uint64_t v34 = *(void *)v36;
    do
    {
      for (j = 0; j != v17; j = (char *)j + 1)
      {
        if (*(void *)v36 != v34) {
          objc_enumerationMutation(obj);
        }
        uint64_t v19 = *(void **)(*((void *)&v35 + 1) + 8 * (void)j);
        unint64_t v20 = [v19 zoneID];
        char v21 = [v20 zoneName];
        unsigned int v22 = sub_1000CD884(@"ckks", v21);

        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          id v44 = v19;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Building status for %@", buf, 0xCu);
        }

        CFStringRef v23 = [*(id *)(a1 + 32) operationDependencies];
        uint64_t v24 = [v23 contextID];
        unint64_t v25 = [v19 zoneName];
        char v26 = +[CKKSZoneStateEntry contextID:v24 zoneName:v25];

        id v27 = [*(id *)(a1 + 32) fastStatus:v19 zoneStateEntry:v26];
        if (!*(unsigned char *)(a1 + 56))
        {
          id v28 = [*(id *)(a1 + 32) intransactionSlowStatus:v19];
          id v29 = [v27 mutableCopy];
          [v29 addEntriesFromDictionary:v28];

          id v27 = v29;
        }
        long long v30 = [v19 zoneName];
        id v31 = sub_1000CD884(@"ckks", v30);

        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138412290;
          id v44 = v27;
          _os_log_debug_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEBUG, "Status is %@", buf, 0xCu);
        }

        if (v27) {
          [*(id *)(a1 + 48) addObject:v27];
        }
      }
      id v17 = [obj countByEnumeratingWithState:&v35 objects:v45 count:16];
    }
    while (v17);
  }
}

void sub_100177A4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100177A70(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100177A80(uint64_t a1)
{
}

void sub_100177A88(uint64_t a1)
{
  long long v37 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  id v2 = [*(id *)(a1 + 32) operationDependencies];
  uint64_t v3 = [v2 allViews];

  uint64_t v4 = a1;
  id v5 = [v3 countByEnumeratingWithState:&v37 objects:v43 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v38;
    p_cache = OTDetermineCDPCapableAccountStatusOperation.cache;
    uint64_t v33 = *(void *)v38;
    uint64_t v34 = v3;
    do
    {
      uint64_t v9 = 0;
      id v35 = v6;
      do
      {
        if (*(void *)v38 != v7) {
          objc_enumerationMutation(v3);
        }
        long long v10 = *(void **)(*((void *)&v37 + 1) + 8 * (void)v9);
        long long v11 = [v10 zoneID];
        unsigned int v12 = [v10 contextID];
        long long v13 = [p_cache + 413 loadForZone:v11 contextID:v12];

        uint64_t v14 = [v13 error];

        if (v14)
        {
          id v15 = [v10 zoneID];
          id v16 = [v15 zoneName];
          id v17 = sub_1000CD884(@"ckks", v16);

          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            id v18 = [v13 error];
            *(_DWORD *)long long buf = 138412290;
            long long v42 = v18;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "error loading keyset: %@", buf, 0xCu);
          }
          uint64_t v19 = [v13 error];
          uint64_t v20 = *(void *)(*(void *)(v4 + 48) + 8);
          char v21 = *(void **)(v20 + 40);
          *(void *)(v20 + 40) = v19;
        }
        else
        {
          unsigned int v22 = [v13 currentTLKPointer];
          CFStringRef v23 = [v22 currentKeyUUID];

          if (!v23) {
            goto LABEL_17;
          }
          uint64_t v24 = *(void *)(v4 + 40);
          unint64_t v25 = [v10 contextID];
          char v26 = [v13 currentTLKPointer];
          id v27 = [v26 currentKeyUUID];
          id v28 = [v10 zoneID];
          uint64_t v29 = v4;
          uint64_t v30 = *(void *)(*(void *)(v4 + 48) + 8);
          id obj = *(id *)(v30 + 40);
          char v21 = +[CKKSTLKShareRecord allFor:v24 contextID:v25 keyUUID:v27 zoneID:v28 error:&obj];
          objc_storeStrong((id *)(v30 + 40), obj);

          if (v21)
          {
            uint64_t v4 = v29;
            if (!*(void *)(*(void *)(*(void *)(v29 + 48) + 8) + 40))
            {
              id v31 = *(void **)(*(void *)(*(void *)(v29 + 56) + 8) + 40);
              id v32 = [v10 zoneName];
              [v31 addObject:v32];

              uint64_t v4 = v29;
            }
          }
          else
          {
            uint64_t v4 = v29;
          }
          uint64_t v7 = v33;
          uint64_t v3 = v34;
          p_cache = (void **)(OTDetermineCDPCapableAccountStatusOperation + 16);
          id v6 = v35;
        }

LABEL_17:
        uint64_t v9 = (char *)v9 + 1;
      }
      while (v6 != v9);
      id v6 = [v3 countByEnumeratingWithState:&v37 objects:v43 count:16];
    }
    while (v6);
  }
}

void sub_1001783F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100178410(uint64_t a1)
{
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  id v2 = [*(id *)(a1 + 32) operationDependencies];
  uint64_t v3 = [v2 allCKKSManagedViews];

  id v4 = [v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v13;
    while (2)
    {
      for (CFIndex i = 0; i != v5; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v13 != v6) {
          objc_enumerationMutation(v3);
        }
        uint64_t v8 = *(void **)(*((void *)&v12 + 1) + 8 * i);
        uint64_t v9 = [v8 zoneID];
        long long v10 = [v9 zoneName];
        unsigned int v11 = [v10 isEqualToString:*(void *)(a1 + 40)];

        if (v11)
        {
          objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), v8);
          goto LABEL_11;
        }
      }
      id v5 = [v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
      if (v5) {
        continue;
      }
      break;
    }
  }
LABEL_11:
}

id sub_100178960(uint64_t a1)
{
  return [*(id *)(a1 + 32) setHalted:1];
}

void sub_100178AF0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100179178(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100179190(uint64_t a1)
{
  id v2 = +[CKKSSQLDatabaseObject all:*(void *)(a1 + 40)];
  if (v2)
  {
    id v5 = v2;
    BOOL v3 = [v2 count] == 0;
    id v2 = v5;
    char v4 = v3;
  }
  else
  {
    char v4 = 0;
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v4;
}

uint64_t sub_100179918(uint64_t a1)
{
  uint64_t v1 = a1;
  if (([*(id *)(a1 + 32) _onQueueZoneIsReadyForFetching:*(void *)(a1 + 40)] & 1) == 0)
  {
    id v5 = [*(id *)(v1 + 40) zoneName];
    BOOL v3 = sub_1000CD884(@"ckksfetch", v5);

    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      char v4 = "Zone is inactive; cancelling fetch";
      goto LABEL_7;
    }
LABEL_8:
    uint64_t v6 = 0;
    goto LABEL_111;
  }
  if ([*(id *)(v1 + 32) halted])
  {
    id v2 = [*(id *)(v1 + 40) zoneName];
    BOOL v3 = sub_1000CD884(@"ckksfetch", v2);

    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      char v4 = "Dropping fetch due to halted operation";
LABEL_7:
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, v4, buf, 2u);
      goto LABEL_8;
    }
    goto LABEL_8;
  }
  long long v159 = 0u;
  long long v160 = 0u;
  long long v157 = 0u;
  long long v158 = 0u;
  id v7 = *(id *)(v1 + 48);
  id v8 = [v7 countByEnumeratingWithState:&v157 objects:v176 count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v158;
    do
    {
      for (CFIndex i = 0; i != v9; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v158 != v10) {
          objc_enumerationMutation(v7);
        }
        uint64_t v12 = *(void *)(*((void *)&v157 + 1) + 8 * i);
        long long v13 = [*(id *)(v1 + 32) operationDependencies];
        [v13 intransactionCKRecordChanged:v12 resync:*(unsigned __int8 *)(v1 + 72)];
      }
      id v9 = [v7 countByEnumeratingWithState:&v157 objects:v176 count:16];
    }
    while (v9);
  }

  long long v155 = 0u;
  long long v156 = 0u;
  long long v153 = 0u;
  long long v154 = 0u;
  id v14 = *(id *)(v1 + 56);
  id v15 = [v14 countByEnumeratingWithState:&v153 objects:v175 count:16];
  if (v15)
  {
    id v16 = v15;
    uint64_t v17 = *(void *)v154;
    do
    {
      for (j = 0; j != v16; j = (char *)j + 1)
      {
        if (*(void *)v154 != v17) {
          objc_enumerationMutation(v14);
        }
        uint64_t v19 = *(void **)(*((void *)&v153 + 1) + 8 * (void)j);
        uint64_t v20 = [*(id *)(v1 + 32) operationDependencies];
        char v21 = [v19 recordID];
        unsigned int v22 = [v19 recordType];
        [v20 intransactionCKRecordDeleted:v21 recordType:v22 resync:*(unsigned __int8 *)(v1 + 72)];
      }
      id v16 = [v14 countByEnumeratingWithState:&v153 objects:v175 count:16];
    }
    while (v16);
  }

  uint64_t v129 = v1;
  if (!*(unsigned char *)(v1 + 72))
  {
    id v39 = 0;
    goto LABEL_64;
  }
  CFStringRef v23 = [*(id *)(v1 + 32) resyncRecordsSeen];

  if (!v23)
  {
    uint64_t v24 = +[NSMutableSet set];
    [*(id *)(v1 + 32) setResyncRecordsSeen:v24];
  }
  long long v151 = 0u;
  long long v152 = 0u;
  long long v149 = 0u;
  long long v150 = 0u;
  id v25 = *(id *)(v1 + 48);
  id v26 = [v25 countByEnumeratingWithState:&v149 objects:v174 count:16];
  if (v26)
  {
    id v27 = v26;
    uint64_t v28 = *(void *)v150;
    do
    {
      for (k = 0; k != v27; k = (char *)k + 1)
      {
        if (*(void *)v150 != v28) {
          objc_enumerationMutation(v25);
        }
        uint64_t v30 = *(void **)(*((void *)&v149 + 1) + 8 * (void)k);
        id v31 = [*(id *)(v1 + 32) resyncRecordsSeen];
        id v32 = [v30 recordID];
        uint64_t v33 = [v32 recordName];
        [v31 addObject:v33];
      }
      id v27 = [v25 countByEnumeratingWithState:&v149 objects:v174 count:16];
    }
    while (v27);
  }

  int v34 = *(unsigned __int8 *)(v1 + 73);
  id v35 = [*(id *)(v1 + 40) zoneName];
  long long v36 = sub_1000CD884(@"ckksresync", v35);

  BOOL v37 = os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT);
  if (v34)
  {
    if (v37)
    {
      *(_WORD *)long long buf = 0;
      long long v38 = v36;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "In a resync, but there's More Coming. Waiting to scan for extra items.", buf, 2u);
      id v39 = 0;
    }
    else
    {
      id v39 = 0;
      long long v38 = v36;
    }
    goto LABEL_63;
  }
  if (v37)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "Comparing local UUIDs against the CloudKit list", buf, 2u);
  }

  long long v40 = [*(id *)(v1 + 32) operationDependencies];
  long long v41 = [v40 contextID];
  uint64_t v42 = *(void *)(v1 + 40);
  id v148 = 0;
  long long v43 = +[CKKSSQLDatabaseObject allUUIDsWithContextID:v41 zoneID:v42 error:&v148];
  id v39 = v148;
  id v44 = [v43 mutableCopy];

  long long v146 = 0u;
  long long v147 = 0u;
  long long v144 = 0u;
  long long v145 = 0u;
  long long v38 = v44;
  id v45 = [v38 countByEnumeratingWithState:&v144 objects:v173 count:16];
  if (v45)
  {
    id v46 = v45;
    uint64_t v47 = *(void *)v145;
    id obj = v38;
    uint64_t v130 = *(void *)v145;
    do
    {
      id v48 = 0;
      id v131 = v46;
      do
      {
        id v49 = v39;
        if (*(void *)v145 != v47) {
          objc_enumerationMutation(v38);
        }
        uint64_t v50 = *(NSObject **)(*((void *)&v144 + 1) + 8 * (void)v48);
        id v51 = [*(id *)(v129 + 32) resyncRecordsSeen];
        unsigned int v52 = [v51 containsObject:v50];

        if (!v52)
        {
          id v55 = [*(id *)(v129 + 32) operationDependencies];
          long long v56 = [v55 contextID];
          uint64_t v57 = *(void *)(v129 + 40);
          id v143 = v49;
          CFStringRef v54 = +[CKKSMirrorEntry tryFromDatabase:v50 contextID:v56 zoneID:v57 error:&v143];
          id v39 = v143;

          if (v39)
          {
            id v58 = [*(id *)(v129 + 40) zoneName];
            id v59 = sub_1000CD884(@"ckksresync", v58);

            if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 138412546;
              long long v162 = v50;
              __int16 v163 = 2112;
              id v164 = v39;
              long long v60 = v59;
              v61 = "Couldn't read an item from the database, but it used to be there: %@ %@";
              uint32_t v62 = 22;
              goto LABEL_51;
            }
          }
          else
          {
            id v63 = [*(id *)(v129 + 40) zoneName];
            id v59 = sub_1000CD884(@"ckksresync", v63);

            BOOL v64 = os_log_type_enabled(v59, OS_LOG_TYPE_ERROR);
            if (v54)
            {
              if (v64)
              {
                *(_DWORD *)long long buf = 138412290;
                long long v162 = v50;
                _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_ERROR, "BUG: Local item %@ not found in CloudKit, deleting", buf, 0xCu);
              }

              id v59 = [*(id *)(v129 + 32) operationDependencies];
              v126 = [v54 item];
              id v65 = [v126 storedCKRecord];
              id v66 = [v65 recordID];
              id v67 = [v54 item];
              v68 = [v67 storedCKRecord];
              id v69 = [v68 recordType];
              [v59 intransactionCKRecordDeleted:v66 recordType:v69 resync:*(unsigned __int8 *)(v129 + 72)];

              long long v38 = obj;
            }
            else if (v64)
            {
              *(_DWORD *)long long buf = 138412290;
              long long v162 = v50;
              long long v60 = v59;
              v61 = "Couldn't read ckme(%@) from database; continuing";
              uint32_t v62 = 12;
LABEL_51:
              _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, v61, buf, v62);
            }
          }
          uint64_t v47 = v130;

          uint64_t v1 = v129;
          id v46 = v131;
          goto LABEL_59;
        }
        id v53 = [*(id *)(v129 + 40) zoneName];
        CFStringRef v54 = sub_1000CD884(@"ckksresync", v53);

        if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          long long v162 = v50;
          _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "UUID %@ is still in CloudKit; carry on.",
            buf,
            0xCu);
        }
        id v39 = v49;
        uint64_t v1 = v129;
LABEL_59:

        id v48 = (char *)v48 + 1;
      }
      while (v46 != v48);
      id v46 = [v38 countByEnumeratingWithState:&v144 objects:v173 count:16];
    }
    while (v46);
  }

  [*(id *)(v1 + 32) setResyncRecordsSeen:0];
LABEL_63:

LABEL_64:
  id v70 = [*(id *)(v1 + 32) operationDependencies];
  id v71 = [v70 contextID];
  CFDataRef v72 = [*(id *)(v1 + 40) zoneName];
  CFNumberRef v73 = +[CKKSZoneStateEntry contextID:v71 zoneName:v72];

  id v74 = +[NSDate date];
  [v73 setLastFetchTime:v74];

  [v73 setChangeToken:*(void *)(v1 + 64)];
  [v73 setMoreRecordsInCloudKit:*(unsigned __int8 *)(v1 + 73)];
  id v142 = v39;
  v122 = v73;
  [v73 saveToDatabase:&v142];
  BOOL v3 = v142;

  if (v3)
  {
    id v75 = [*(id *)(v1 + 40) zoneName];
    v76 = sub_1000CD884(@"ckksfetch", v75);

    if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      long long v162 = v3;
      _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_ERROR, "Couldn't save new server change token: %@", buf, 0xCu);
    }
  }
  if (![*(id *)(v1 + 48) count] && !objc_msgSend(*(id *)(v1 + 56), "count"))
  {
    if (*(unsigned char *)(v1 + 73)) {
      goto LABEL_108;
    }
    if (!*(unsigned char *)(v1 + 72))
    {
      long long v119 = [*(id *)(v1 + 40) zoneName];
      long long v120 = sub_1000CD884(@"ckksfetch", v119);

      obja = v120;
      if (os_log_type_enabled(v120, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)long long buf = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_DEBUG, "No record changes in this fetch", buf, 2u);
      }
LABEL_107:

      goto LABEL_108;
    }
LABEL_71:
    uint64_t v77 = [*(id *)(v1 + 32) zoneName];
    id v78 = sub_1000CD884(@"ckksfetch", v77);

    if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
    {
      v79 = *(NSObject **)(v1 + 40);
      *(_DWORD *)long long buf = 138412290;
      long long v162 = v79;
      _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "Requesting incoming processing for %@", buf, 0xCu);
    }

    long long v140 = 0u;
    long long v141 = 0u;
    long long v138 = 0u;
    long long v139 = 0u;
    v80 = [*(id *)(v1 + 32) operationDependencies];
    v81 = [v80 readyAndSyncingViews];

    obja = v81;
    id v127 = [v81 countByEnumeratingWithState:&v138 objects:v172 count:16];
    if (v127)
    {
      long long v121 = v3;
      uint64_t v125 = *(void *)v139;
      do
      {
        for (m = 0; m != v127; m = (char *)m + 1)
        {
          if (*(void *)v139 != v125) {
            objc_enumerationMutation(obja);
          }
          CFStringRef v83 = *(void **)(*((void *)&v138 + 1) + 8 * (void)m);
          unsigned __int8 v84 = [*(id *)(v129 + 32) operationDependencies];
          unsigned int v85 = [v84 contextID];
          id v86 = [v83 zoneID];
          v87 = +[CKKSIncomingQueueEntry countNewEntriesByKeyWithContextID:v85 zoneID:v86 error:0];

          long long v136 = 0u;
          long long v137 = 0u;
          long long v134 = 0u;
          long long v135 = 0u;
          id v132 = v87;
          id v88 = [v132 countByEnumeratingWithState:&v134 objects:v171 count:16];
          if (v88)
          {
            id v89 = v88;
            v128 = m;
            uint64_t v90 = *(void *)v135;
            while (2)
            {
              for (n = 0; n != v89; n = (char *)n + 1)
              {
                if (*(void *)v135 != v90) {
                  objc_enumerationMutation(v132);
                }
                long long v92 = *(NSObject **)(*((void *)&v134 + 1) + 8 * (void)n);
                long long v93 = [v83 contextID];
                id v94 = [v83 zoneID];
                id v133 = 0;
                id v95 = +[CKKSKey fromDatabase:v92 contextID:v93 zoneID:v94 error:&v133];
                id v96 = v133;

                if (v95) {
                  BOOL v97 = v96 == 0;
                }
                else {
                  BOOL v97 = 0;
                }
                if (v97)
                {
                  v101 = [v95 keyclass];
                  unsigned int v102 = [v101 isEqualToString:@"classC"];

                  if (v102)
                  {

                    int v103 = 1;
                    goto LABEL_95;
                  }
                }
                else
                {
                  id v98 = [v83 zoneID];
                  unsigned int v99 = [v98 zoneName];
                  __int16 v100 = sub_1000CD884(@"ckksfetch", v99);

                  if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)long long buf = 138412546;
                    long long v162 = v92;
                    __int16 v163 = 2112;
                    id v164 = v96;
                    _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_ERROR, "Unable to load key for %@: %@", buf, 0x16u);
                  }
                }
              }
              id v89 = [v132 countByEnumeratingWithState:&v134 objects:v171 count:16];
              if (v89) {
                continue;
              }
              break;
            }
            int v103 = 0;
LABEL_95:
            m = v128;
          }
          else
          {
            int v103 = 0;
          }

          v104 = [*(id *)(v129 + 32) lockStateTracker];
          unsigned int v105 = [v104 isLocked];

          if (v105)
          {
            if (v103)
            {
              uint64_t v1 = v129;
              v106 = [*(id *)(v129 + 32) stateMachine];
              [(OctagonPendingFlag *)v106 _onqueueHandleFlag:@"process_incoming_queue"];
            }
            else
            {
              v107 = [v83 zoneID];
              v108 = [v107 zoneName];
              uint64_t v109 = sub_1000CD884(@"ckksfetch", v108);

              if (os_log_type_enabled(v109, OS_LOG_TYPE_DEFAULT))
              {
                *(_WORD *)long long buf = 0;
                _os_log_impl((void *)&_mh_execute_header, v109, OS_LOG_TYPE_DEFAULT, "Have incoming classA items needing processing, but device is locked", buf, 2u);
              }

              v106 = [[OctagonPendingFlag alloc] initWithFlag:@"process_incoming_queue" conditions:1];
              uint64_t v1 = v129;
              v110 = [*(id *)(v129 + 32) stateMachine];
              [v110 _onqueueHandlePendingFlagLater:v106];
            }
          }
          else
          {
            v106 = [*(id *)(v129 + 32) stateMachine];
            [(OctagonPendingFlag *)v106 _onqueueHandleFlag:@"process_incoming_queue"];
            uint64_t v1 = v129;
          }
        }
        id v127 = [obja countByEnumeratingWithState:&v138 objects:v172 count:16];
      }
      while (v127);
      BOOL v3 = v121;
    }
    goto LABEL_107;
  }
  if (!*(unsigned char *)(v1 + 73)) {
    goto LABEL_71;
  }
LABEL_108:
  v111 = [*(id *)(v1 + 40) zoneName];
  id v112 = sub_1000CD884(@"ckksfetch", v111);

  if (os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT))
  {
    id v113 = [*(id *)(v1 + 48) count];
    id v114 = [*(id *)(v1 + 56) count];
    uint64_t v115 = *(unsigned __int8 *)(v1 + 73);
    int v116 = *(unsigned __int8 *)(v1 + 72);
    uint64_t v117 = *(void *)(v1 + 64);
    *(_DWORD *)long long buf = 134219010;
    long long v162 = v113;
    __int16 v163 = 2048;
    id v164 = v114;
    __int16 v165 = 2048;
    uint64_t v166 = v115;
    __int16 v167 = 1024;
    int v168 = v116;
    __int16 v169 = 2112;
    uint64_t v170 = v117;
    _os_log_impl((void *)&_mh_execute_header, v112, OS_LOG_TYPE_DEFAULT, "Finished processing changes: changed=%lu deleted=%lu moreComing=%lu resync=%u changeToken=%@", buf, 0x30u);
  }

  uint64_t v6 = 1;
LABEL_111:

  return v6;
}

void sub_10017AA50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10017AA68(uint64_t a1)
{
  if ([*(id *)(a1 + 32) _onQueueZoneIsReadyForFetching:*(void *)(a1 + 40)])
  {
    [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setParticipateInFetch:1];
    id v2 = [*(id *)(a1 + 32) operationDependencies];
    BOOL v3 = [v2 contextID];
    char v4 = [*(id *)(a1 + 40) zoneName];
    id v5 = +[CKKSZoneStateEntry contextID:v3 zoneName:v4];

    if (v5)
    {
      uint64_t v6 = [v5 getChangeToken];
      [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) setChangeToken:v6];
    }
    else
    {
      id v9 = [*(id *)(a1 + 32) zoneName];
      uint64_t v10 = sub_1000CD884(@"ckksfetch", v9);

      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        unsigned int v11 = [*(id *)(a1 + 40) zoneName];
        int v12 = 138412290;
        long long v13 = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "couldn't fetch zone change token for %@", (uint8_t *)&v12, 0xCu);
      }
      id v5 = 0;
    }
  }
  else
  {
    id v7 = [*(id *)(a1 + 32) zoneName];
    id v5 = sub_1000CD884(@"ckksfetch", v7);

    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      id v8 = *(void **)(a1 + 40);
      int v12 = 138412290;
      long long v13 = v8;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "skipping fetch for %@; zone is not ready",
        (uint8_t *)&v12,
        0xCu);
    }
  }
}

void sub_10017B0A0(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

id sub_10017B0B8(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) _onQueueZoneIsReadyForFetching:*(void *)(a1 + 40)];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = (_BYTE)result;
  return result;
}

void sub_10017B70C(_Unwind_Exception *a1)
{
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v3 - 104));
  _Unwind_Resume(a1);
}

void sub_10017B748(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v2 = [WeakRetained cloudKitClassDependencies];
  id v3 = [v2 notifierClass];
  char v4 = +[NSString stringWithFormat:@"com.apple.security.view-change.%@", *(void *)(a1 + 32)];
  [v3 post:v4];

  id v5 = [WeakRetained cloudKitClassDependencies];
  id v6 = [v5 notifierClass];
  id v7 = +[NSString stringWithUTF8String:"com.apple.security.keychainchanged"];
  [v6 post:v7];

  if (([*(id *)(a1 + 32) isEqualToString:@"Manatee"] & 1) != 0
    || ([*(id *)(a1 + 32) isEqualToString:@"Engram"] & 1) != 0
    || ([*(id *)(a1 + 32) isEqualToString:@"ApplePay"] & 1) != 0
    || ([*(id *)(a1 + 32) isEqualToString:@"Home"] & 1) != 0
    || [*(id *)(a1 + 32) isEqualToString:@"LimitedPeersAllowed"])
  {
    id v8 = [WeakRetained cloudKitClassDependencies];
    [objc_msgSend(v8, "notifierClass") post:@"com.apple.security.view-change.PCS"];
  }
}

void sub_10017B8B8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v3 = [WeakRetained cloudKitClassDependencies];
  char v4 = [objc_msgSend(objc_msgSend(v3, "nsdistributednotificationCenterClass"), "defaultCenter");

  CFStringRef v5 = @"unknown";
  if (*(void *)(a1 + 32)) {
    CFStringRef v5 = *(const __CFString **)(a1 + 32);
  }
  CFStringRef v10 = @"view";
  CFStringRef v11 = v5;
  id v6 = +[NSDictionary dictionaryWithObjects:&v11 forKeys:&v10 count:1];
  [v4 postNotificationName:@"com.apple.security.view-become-ready" object:0 userInfo:v6 options:0];

  id v7 = [WeakRetained cloudKitClassDependencies];
  id v8 = [v7 notifierClass];
  id v9 = +[NSString stringWithFormat:@"com.apple.security.view-ready.%@", *(void *)(a1 + 32)];
  [v8 post:v9];
}

void sub_10017C39C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
}

void sub_10017C3C8(uint64_t a1)
{
  uint64_t v1 = a1;
  id v2 = [*(id *)(a1 + 32) operationDependencies];
  id v88 = [v2 syncingPolicy];

  id v3 = [*(id *)(v1 + 32) operationDependencies];
  char v4 = [v3 allViews];
  id v5 = [v4 mutableCopy];

  id v86 = +[NSMutableSet set];
  long long v106 = 0u;
  long long v107 = 0u;
  long long v108 = 0u;
  long long v109 = 0u;
  id obj = v5;
  id v6 = [obj countByEnumeratingWithState:&v106 objects:v121 count:16];
  uint64_t v93 = v1;
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v107;
    do
    {
      for (CFIndex i = 0; i != v7; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v107 != v8) {
          objc_enumerationMutation(obj);
        }
        CFStringRef v10 = *(void **)(*((void *)&v106 + 1) + 8 * i);
        CFStringRef v11 = *(void **)(v1 + 40);
        int v12 = [v10 zoneID];
        long long v13 = [v12 zoneName];
        LODWORD(v11) = [v11 containsObject:v13];

        if (v11)
        {
          id v14 = [v10 zoneID];
          id v15 = [v14 zoneName];
          unsigned int v16 = [v88 isSyncingEnabledForView:v15];

          uint64_t v17 = *(void **)(v1 + 48);
          id v18 = [v10 zoneID];
          uint64_t v19 = [v18 zoneName];
          unsigned int v20 = [v17 isSyncingEnabledForView:v19];

          char v21 = [v10 zoneID];
          unsigned int v22 = [v21 zoneName];
          CFStringRef v23 = sub_1000CD884(@"ckks", v22);

          uint64_t v1 = v93;
          if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v24 = [v10 zoneID];
            uint64_t v25 = [v24 zoneName];
            id v26 = (void *)v25;
            uint64_t v27 = *(void *)(v93 + 48);
            CFStringRef v28 = @"paused";
            if (v20) {
              CFStringRef v29 = @"enabled";
            }
            else {
              CFStringRef v29 = @"paused";
            }
            *(_DWORD *)long long buf = 138413058;
            if (v16) {
              CFStringRef v28 = @"enabled";
            }
            uint64_t v114 = v25;
            __int16 v115 = 2112;
            CFStringRef v116 = v29;
            __int16 v117 = 2112;
            CFStringRef v118 = v28;
            __int16 v119 = 2112;
            uint64_t v120 = v27;
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Syncing for %@ is now %@ (used to be %@) (policy: %@)", buf, 0x2Au);
          }
        }
        else
        {
          uint64_t v30 = *(void **)(v1 + 56);
          id v31 = [v10 zoneID];
          id v32 = [v31 zoneName];
          LOBYTE(v30) = [v30 containsObject:v32];

          if ((v30 & 1) == 0)
          {
            uint64_t v33 = sub_1000CD884(@"ckks-policy", 0);
            if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
            {
              int v34 = [v10 zoneID];
              id v35 = [v34 zoneName];
              *(_DWORD *)long long buf = 138412290;
              uint64_t v114 = (uint64_t)v35;
              _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "Stopping old view %@", buf, 0xCu);
            }
            [v86 addObject:v10];
            *(unsigned char *)(*(void *)(*(void *)(v1 + 64) + 8) + 24) = 1;
          }
        }
      }
      id v7 = [obj countByEnumeratingWithState:&v106 objects:v121 count:16];
    }
    while (v7);
  }
  long long v36 = obj;

  [obj minusSet:v86];
  [*(id *)(v1 + 40) setByAddingObjectsFromSet:*(void *)(v1 + 56)];
  long long v102 = 0u;
  long long v103 = 0u;
  long long v104 = 0u;
  long long v105 = 0u;
  id v89 = (id)objc_claimAutoreleasedReturnValue();
  id v91 = [v89 countByEnumeratingWithState:&v102 objects:v112 count:16];
  if (!v91)
  {
    id v75 = [*(id *)(v1 + 32) operationDependencies];
    [v75 applyNewSyncingPolicy:*(void *)(v1 + 48) viewStates:obj];

    CFDataRef v72 = [*(id *)(v1 + 32) stateMachine];
    CFNumberRef v73 = v72;
    CFStringRef v74 = @"check_queues";
    goto LABEL_61;
  }
  char v87 = 0;
  uint64_t v90 = *(void *)v103;
  do
  {
    for (j = 0; j != v91; j = (char *)j + 1)
    {
      if (*(void *)v103 != v90) {
        objc_enumerationMutation(v89);
      }
      uint64_t v38 = *(void *)(*((void *)&v102 + 1) + 8 * (void)j);
      long long v98 = 0u;
      long long v99 = 0u;
      long long v100 = 0u;
      long long v101 = 0u;
      id v39 = v36;
      id v40 = [v39 countByEnumeratingWithState:&v98 objects:v111 count:16];
      if (v40)
      {
        id v41 = v40;
        uint64_t v42 = *(void *)v99;
LABEL_28:
        uint64_t v43 = 0;
        while (1)
        {
          if (*(void *)v99 != v42) {
            objc_enumerationMutation(v39);
          }
          id v44 = *(void **)(*((void *)&v98 + 1) + 8 * v43);
          id v45 = [v44 zoneID];
          id v46 = [v45 zoneName];
          unsigned __int8 v47 = [v46 isEqualToString:v38];

          if (v47) {
            break;
          }
          if (v41 == (id)++v43)
          {
            id v41 = [v39 countByEnumeratingWithState:&v98 objects:v111 count:16];
            if (v41) {
              goto LABEL_28;
            }
            goto LABEL_34;
          }
        }
        id v48 = v44;

        if (!v48) {
          goto LABEL_37;
        }
        long long v36 = obj;
        uint64_t v1 = v93;
      }
      else
      {
LABEL_34:

LABEL_37:
        id v49 = [*(id *)(v93 + 32) operationDependencies];
        uint64_t v50 = [v49 contextID];
        id v51 = +[CKKSZoneStateEntry contextID:v50 zoneName:v38];

        id v52 = [*(id *)(v93 + 40) containsObject:v38];
        id v53 = [v51 getChangeToken];

        CFStringRef v54 = [*(id *)(v93 + 48) priorityViews];
        id v55 = [v54 containsObject:v38];

        long long v56 = *(void **)(v93 + 32);
        uint64_t v57 = [v51 contextID];
        [v56 createViewState:v38 contextID:v57 zoneIsNew:v53 == 0 priorityView:v55 ckksManagedView:v52];
        id v48 = (__CFString *)objc_claimAutoreleasedReturnValue();

        [v39 addObject:v48];
        id v58 = [(__CFString *)v48 zoneID];
        id v59 = [v58 zoneName];
        long long v60 = sub_1000CD884(@"ckks", v59);

        if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
        {
          CFStringRef v61 = @"normal";
          if (v55) {
            CFStringRef v61 = @"priority";
          }
          *(_DWORD *)long long buf = 138412802;
          uint64_t v114 = (uint64_t)v61;
          CFStringRef v62 = @"externally-managed";
          if (v52) {
            CFStringRef v62 = @"CKKS";
          }
          __int16 v115 = 2112;
          CFStringRef v116 = v62;
          __int16 v117 = 2112;
          CFStringRef v118 = v48;
          _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "Created %@ %@ view %@", buf, 0x20u);
        }

        if (v53) {
          int v63 = 0;
        }
        else {
          int v63 = (int)v55;
        }
        long long v36 = obj;
        uint64_t v1 = v93;
        if (v63 == 1)
        {
          BOOL v64 = [(__CFString *)v48 zoneID];
          id v65 = [v64 zoneName];
          id v66 = sub_1000CD884(@"ckks", v65);

          if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "Initializing a priority view for the first time", buf, 2u);
          }

          char v87 = 1;
        }
        if (v55 && [v51 moreRecordsInCloudKit])
        {
          id v67 = [(__CFString *)v48 zoneID];
          v68 = [v67 zoneName];
          id v69 = sub_1000CD884(@"ckks", v68);

          if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "A priority view has more records in CloudKit; treating as new",
              buf,
              2u);
          }

          char v87 = 1;
        }
        *(unsigned char *)(*(void *)(*(void *)(v93 + 72) + 8) + 24) = 1;
      }
    }
    id v91 = [v89 countByEnumeratingWithState:&v102 objects:v112 count:16];
  }
  while (v91);
  id v70 = [*(id *)(v1 + 32) operationDependencies];
  [v70 applyNewSyncingPolicy:*(void *)(v1 + 48) viewStates:v36];

  id v71 = [*(id *)(v1 + 32) stateMachine];
  [v71 _onqueueHandleFlag:@"check_queues"];

  if (v87)
  {
    [*(id *)(v1 + 32) onqueueCreatePriorityViewsProcessedWatcher];
    CFDataRef v72 = [*(id *)(v1 + 32) stateMachine];
    CFNumberRef v73 = v72;
    CFStringRef v74 = @"new_priority_views";
LABEL_61:
    [v72 _onqueueHandleFlag:v74];
  }
  if (*(unsigned char *)(*(void *)(*(void *)(v1 + 72) + 8) + 24) && *(unsigned char *)(v1 + 80))
  {
    v76 = [*(id *)(v1 + 32) stateMachine];
    [v76 _onqueueHandleFlag:@"key_process_requested"];
  }
  long long v96 = 0u;
  long long v97 = 0u;
  long long v94 = 0u;
  long long v95 = 0u;
  id v77 = v36;
  id v78 = [v77 countByEnumeratingWithState:&v94 objects:v110 count:16];
  if (v78)
  {
    id v79 = v78;
    uint64_t v80 = *(void *)v95;
    do
    {
      for (k = 0; k != v79; k = (char *)k + 1)
      {
        if (*(void *)v95 != v80) {
          objc_enumerationMutation(v77);
        }
        id v82 = *(void **)(*((void *)&v94 + 1) + 8 * (void)k);
        CFStringRef v83 = [*(id *)(v1 + 32) zoneChangeFetcher];
        uint64_t v84 = *(void *)(v1 + 32);
        unsigned int v85 = [v82 zoneID];
        [v83 registerClient:v84 zoneID:v85];
      }
      id v79 = [v77 countByEnumeratingWithState:&v94 objects:v110 count:16];
    }
    while (v79);
  }
}

void sub_10017CF88(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) zoneName];
  id v3 = sub_1000CD884(@"ckkstrust", v2);

  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v9 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Ending trusted operation", v9, 2u);
  }

  char v4 = [*(id *)(a1 + 32) operationDependencies];
  [v4 setPeerProviders:&__NSArray0__struct];

  [*(id *)(a1 + 32) setSuggestTLKUpload:0];
  [*(id *)(a1 + 32) setTrustStatus:3];
  id v5 = [*(id *)(a1 + 32) trustStatusKnown];
  [v5 fulfill];

  id v6 = [*(id *)(a1 + 32) stateMachine];
  [v6 _onqueueHandleFlag:@"trusted_operation_end"];

  id v7 = [*(id *)(a1 + 32) operationDependencies];
  uint64_t v8 = [v7 overallLaunch];
  [v8 addEvent:@"trust-loss"];
}

void sub_10017D3AC(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) zoneName];
  id v3 = sub_1000CD884(@"ckkstrust", v2);

  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Beginning trusted operation", buf, 2u);
  }

  uint64_t v4 = *(void *)(a1 + 40);
  id v5 = [*(id *)(a1 + 32) operationDependencies];
  [v5 setPeerProviders:v4];

  uint64_t v6 = *(void *)(a1 + 48);
  id v7 = [*(id *)(a1 + 32) operationDependencies];
  [v7 setRequestPolicyCheck:v6];

  id v8 = [*(id *)(a1 + 32) trustStatus];
  [*(id *)(a1 + 32) setSuggestTLKUpload:*(void *)(a1 + 56)];
  [*(id *)(a1 + 32) setTrustStatus:1];
  id v9 = [*(id *)(a1 + 32) trustStatusKnown];
  [v9 fulfill];

  CFStringRef v10 = [*(id *)(a1 + 32) stateMachine];
  [v10 _onqueueHandleFlag:@"trusted_operation_begin"];

  CFStringRef v11 = [*(id *)(a1 + 32) stateMachine];
  [v11 _onqueueHandleFlag:@"key_process_requested"];

  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  int v12 = [*(id *)(a1 + 32) operationDependencies];
  long long v13 = [v12 allCKKSManagedViews];

  id v14 = [v13 countByEnumeratingWithState:&v25 objects:v30 count:16];
  if (v14)
  {
    id v15 = v14;
    uint64_t v16 = *(void *)v26;
    do
    {
      uint64_t v17 = 0;
      do
      {
        if (*(void *)v26 != v16) {
          objc_enumerationMutation(v13);
        }
        id v18 = [*(id *)(*((void *)&v25 + 1) + 8 * (void)v17) launch];
        [v18 addEvent:@"trust"];

        uint64_t v17 = (char *)v17 + 1;
      }
      while (v15 != v17);
      id v15 = [v13 countByEnumeratingWithState:&v25 objects:v30 count:16];
    }
    while (v15);
  }

  uint64_t v19 = [*(id *)(a1 + 32) operationDependencies];
  unsigned int v20 = [v19 overallLaunch];
  [v20 addEvent:@"trust"];

  if (v8 == (id)3)
  {
    char v21 = [*(id *)(a1 + 32) zoneName];
    unsigned int v22 = sub_1000CD884(@"ckkstrust", v21);

    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Moving from an untrusted status; we need to process incoming queue and scan for any new items",
        buf,
        2u);
    }

    CFStringRef v23 = [*(id *)(a1 + 32) stateMachine];
    [v23 _onqueueHandleFlag:@"process_incoming_queue"];

    uint64_t v24 = [*(id *)(a1 + 32) stateMachine];
    [v24 _onqueueHandleFlag:@"dropped_items"];

    [*(id *)(a1 + 32) onqueueCreatePriorityViewsProcessedWatcher];
  }
}

void sub_10017D7E0(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) zoneName];
  id v3 = sub_1000CD884(@"ckkszone", v2);

  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)id v8 = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "received a notification of CK logout", v8, 2u);
  }

  [*(id *)(a1 + 32) setAccountStatus:3];
  uint64_t v4 = [CKKSCondition alloc];
  id v5 = [*(id *)(a1 + 32) loggedIn];
  id v6 = [(CKKSCondition *)v4 initToChain:v5];
  [*(id *)(a1 + 32) setLoggedIn:v6];

  id v7 = [*(id *)(a1 + 32) loggedOut];
  [v7 fulfill];
}

void sub_10017DB80(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) zoneName];
  id v3 = sub_1000CD884(@"ckkszone", v2);

  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)id v8 = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEBUG, "received a notification of CK login", v8, 2u);
  }

  [*(id *)(a1 + 32) setAccountStatus:1];
  uint64_t v4 = [CKKSCondition alloc];
  id v5 = [*(id *)(a1 + 32) loggedOut];
  id v6 = [(CKKSCondition *)v4 initToChain:v5];
  [*(id *)(a1 + 32) setLoggedOut:v6];

  id v7 = [*(id *)(a1 + 32) loggedIn];
  [v7 fulfill];
}

void sub_10017E188(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_10017E1A8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v3 = [WeakRetained zoneName];
  uint64_t v4 = sub_1000CD884(@"ckkszone", v3);

  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = 138412290;
    uint64_t v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%@", (uint8_t *)&v6, 0xCu);
  }
}

void sub_10017EA84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10017EAA4(id *a1)
{
  id WeakRetained = objc_loadWeakRetained(a1 + 6);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_10017EB54;
  v3[3] = &unk_100307280;
  id v4 = a1[4];
  id v5 = a1[5];
  [WeakRetained dispatchSyncWithReadOnlySQLTransaction:v3];
}

void sub_10017EB54(uint64_t a1)
{
  id v2 = objc_alloc_init((Class)NSMutableDictionary);
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  id obj = *(id *)(a1 + 32);
  id v3 = [obj countByEnumeratingWithState:&v15 objects:v23 count:16];
  if (v3)
  {
    id v4 = v3;
    id v5 = 0;
    uint64_t v6 = *(void *)v16;
    while (2)
    {
      uint64_t v7 = 0;
      id v8 = v5;
      do
      {
        if (*(void *)v16 != v6) {
          objc_enumerationMutation(obj);
        }
        uint64_t v9 = *(void *)(*((void *)&v15 + 1) + 8 * (void)v7);
        CFStringRef v10 = [*(id *)(a1 + 32) objectForKeyedSubscript:v9];
        id v14 = v8;
        CFStringRef v11 = +[CKKSMirrorEntry pcsMirrorKeysForService:v9 matchingKeys:v10 error:&v14];
        id v5 = v14;

        if (!v11)
        {
          int v12 = sub_1000CD884(@"ckks", 0);
          if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138412546;
            uint64_t v20 = v9;
            __int16 v21 = 2112;
            id v22 = v5;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Error getting PCS key hash for service %@: %@", buf, 0x16u);
          }

          id v2 = 0;
          goto LABEL_14;
        }
        [v2 setObject:v11 forKeyedSubscript:v9];

        uint64_t v7 = (char *)v7 + 1;
        id v8 = v5;
      }
      while (v4 != v7);
      id v4 = [obj countByEnumeratingWithState:&v15 objects:v23 count:16];
      if (v4) {
        continue;
      }
      break;
    }
  }
  else
  {
    id v5 = 0;
  }
LABEL_14:

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_10017EE54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10017EE6C(uint64_t a1)
{
  [*(id *)(a1 + 32) setHavoc:([*(id *)(a1 + 32) havoc] ^ 1)];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = [*(id *)(a1 + 32) havoc];
  id v2 = sub_1000CD884(@"havoc", 0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v3 = [*(id *)(a1 + 32) havoc];
    CFStringRef v4 = @"OFF";
    if (v3) {
      CFStringRef v4 = @"ON";
    }
    int v5 = 138412290;
    CFStringRef v6 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Havoc is now %@", (uint8_t *)&v5, 0xCu);
  }
}

void sub_10017F220(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10017F238(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) accountStatus];
  unsigned int v3 = *(void **)(a1 + 32);
  if (v2 == (id)1)
  {
    CFStringRef v4 = [v3 operationDependencies];
    int v5 = [v4 syncingPolicy];

    if (v5)
    {
      if ([*(id *)(a1 + 32) trustStatus] == (id)1) {
        goto LABEL_11;
      }
      CFStringRef v6 = @"No iCloud Keychain Trust";
      uint64_t v7 = 52;
    }
    else
    {
      CFStringRef v6 = @"Syncing policy not yet loaded";
      uint64_t v7 = 56;
    }
  }
  else if ([v3 accountStatus])
  {
    CFStringRef v6 = @"User is not signed into iCloud.";
    uint64_t v7 = 10;
  }
  else
  {
    CFStringRef v6 = @"iCloud account status unknown.";
    uint64_t v7 = 64;
  }
  id v8 = +[NSError errorWithDomain:@"CKKSErrorDomain" code:v7 description:v6];
  if (v8)
  {
    v28[0] = _NSConcreteStackBlock;
    v28[1] = 3221225472;
    v28[2] = sub_10017F5E0;
    v28[3] = &unk_1003056C0;
    id v29 = v8;
    uint64_t v9 = v8;
    uint64_t v10 = +[CKKSResultOperation named:@"rpcWaitForPriorityViewProcessing-fail" withBlockTakingSelf:v28];
    uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8);
    int v12 = *(void **)(v11 + 40);
    *(void *)(v11 + 40) = v10;

    long long v13 = [*(id *)(a1 + 32) operationQueue];
    [v13 addOperation:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40)];

    goto LABEL_21;
  }
LABEL_11:
  id v14 = [*(id *)(a1 + 32) priorityViewsProcessed];
  long long v15 = [v14 result];
  long long v16 = [v15 error];

  if (v16)
  {
    long long v17 = sub_1000CD884(@"ckksrpc", 0);
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "priorityViewsProcessed already ran and hit an error, re-setting up priority views watcher", buf, 2u);
    }

    [*(id *)(a1 + 32) onqueueCreatePriorityViewsProcessedWatcher];
  }
  long long v18 = [*(id *)(a1 + 32) priorityViewsProcessed];
  uint64_t v19 = [v18 result];
  uint64_t v20 = *(void *)(*(void *)(a1 + 40) + 8);
  __int16 v21 = *(void **)(v20 + 40);
  *(void *)(v20 + 40) = v19;

  uint64_t v22 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
  uint64_t v9 = sub_1000CD884(@"ckksrpc", 0);
  BOOL v23 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if (v22)
  {
    if (v23)
    {
      uint64_t v24 = [*(id *)(a1 + 32) priorityViewsProcessed];
      *(_DWORD *)long long buf = 138412290;
      id v31 = v24;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "waitForPriorityViews pending on %@", buf, 0xCu);
    }
  }
  else
  {
    if (v23)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Returning success for waitForPriorityViews", buf, 2u);
    }

    uint64_t v25 = +[CKKSResultOperation named:@"waitForPriority-succeed" withBlock:&stru_100305998];
    uint64_t v26 = *(void *)(*(void *)(a1 + 40) + 8);
    long long v27 = *(void **)(v26 + 40);
    *(void *)(v26 + 40) = v25;

    uint64_t v9 = [*(id *)(a1 + 32) operationQueue];
    [v9 addOperation:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40)];
  }
LABEL_21:
}

void sub_10017F5E0(uint64_t a1, void *a2)
{
  id v3 = a2;
  CFStringRef v4 = sub_1000CD884(@"ckksrpc", 0);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = 138412290;
    uint64_t v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Returning failure for waitForPriorityViews: %@", (uint8_t *)&v6, 0xCu);
  }

  [v3 setError:*(void *)(a1 + 32)];
}

void sub_10017FF3C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id location)
{
  objc_destroyWeak(v22);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

id sub_10017FF64(uint64_t a1, void *a2)
{
  return [a2 setError:*(void *)(a1 + 32)];
}

void sub_10017FF70(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) operationDependencies];
  id v3 = [v2 currentFetchReasons];
  [v3 addObject:*(void *)(a1 + 40)];

  id v4 = [*(id *)(a1 + 32) stateMachine];
  [v4 _onqueueHandleFlag:@"fetch_requested"];
}

void sub_10017FFFC(id *a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained(a1 + 6);
  uint64_t v5 = [a1[4] result];
  int v6 = [v5 error];

  if (v6)
  {
    uint64_t v7 = sub_1000CD884(@"ckksrpc", 0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      long long v13 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "rpcFetchAndProcess failed: %@", buf, 0xCu);
    }

    [v3 setError:v6];
  }
  else
  {
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472;
    v8[2] = sub_100180184;
    v8[3] = &unk_100305720;
    id v9 = a1[5];
    id v10 = WeakRetained;
    id v11 = v3;
    [WeakRetained dispatchSyncWithReadOnlySQLTransaction:v8];
  }
}

void sub_100180184(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  if (v2)
  {
    id v3 = v2;
  }
  else
  {
    id v3 = [*(id *)(a1 + 40) viewList];
  }
  long long v20 = 0u;
  long long v21 = 0u;
  long long v18 = 0u;
  long long v19 = 0u;
  id v4 = v3;
  id v5 = [v4 countByEnumeratingWithState:&v18 objects:v24 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v19;
    while (2)
    {
      for (CFIndex i = 0; i != v6; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v19 != v7) {
          objc_enumerationMutation(v4);
        }
        id v9 = [*(id *)(a1 + 40) viewStateForName:*(void *)(*((void *)&v18 + 1) + 8 * i)];
        id v10 = [v9 zoneID];
        id v11 = [v9 contextID];
        int v12 = +[CKKSCurrentKeySet loadForZone:v10 contextID:v11];

        long long v13 = [v12 tlk];

        if (!v13)
        {
          id v14 = [*(id *)(a1 + 40) zoneName];
          long long v15 = sub_1000CD884(@"ckks", v14);

          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138412290;
            BOOL v23 = v9;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "No local TLKs for %@; failing a fetch rpc",
              buf,
              0xCu);
          }

          +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"No local keys for %@; processing queue will fail",
          long long v16 = v9);
          long long v17 = +[NSError errorWithDomain:@"CKKSErrorDomain" code:53 description:v16];
          [*(id *)(a1 + 48) setError:v17];

          goto LABEL_16;
        }
      }
      id v6 = [v4 countByEnumeratingWithState:&v18 objects:v24 count:16];
      if (v6) {
        continue;
      }
      break;
    }
  }
LABEL_16:
}

id sub_1001808C0(uint64_t a1, void *a2)
{
  return [a2 setError:*(void *)(a1 + 32)];
}

void sub_1001808CC(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) operationDependencies];
  id v3 = [v2 currentFetchReasons];
  [v3 addObject:*(void *)(a1 + 40)];

  id v4 = [*(id *)(a1 + 32) stateMachine];
  [v4 _onqueueHandleFlag:@"fetch_requested"];
}

void sub_100180958(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [*(id *)(a1 + 32) result];
  id v5 = [v4 error];

  id v6 = sub_1000CD884(@"ckksrpc", 0);
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (v7)
    {
      int v8 = 138412290;
      id v9 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "rpcFetch failed: %@", (uint8_t *)&v8, 0xCu);
    }

    [v3 setError:v5];
  }
  else
  {
    if (v7)
    {
      LOWORD(v8) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "rpcFetch succeeded", (uint8_t *)&v8, 2u);
    }
  }
}

void sub_100181060(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10018108C(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) stateMachine];
  id v3 = [v2 currentState];
  unsigned int v4 = [v3 isEqualToString:@"loggedout"];

  if (v4)
  {
    uint64_t v5 = +[CKKSResultOperation named:@"fail" withBlockTakingSelf:&stru_1003058C8];
    uint64_t v6 = *(void *)(*(void *)(a1 + 48) + 8);
    BOOL v7 = *(void **)(v6 + 40);
    *(void *)(v6 + 40) = v5;
  }
  int v8 = *(void **)(a1 + 40);
  if (v8)
  {
    id v9 = v8;
  }
  else
  {
    id v9 = [*(id *)(a1 + 32) viewList];
  }
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  id v10 = v9;
  id v11 = [v10 countByEnumeratingWithState:&v29 objects:v33 count:16];
  if (!v11) {
    goto LABEL_22;
  }
  id v12 = v11;
  uint64_t v13 = *(void *)v30;
  while (2)
  {
    for (CFIndex i = 0; i != v12; CFIndex i = (char *)i + 1)
    {
      if (*(void *)v30 != v13) {
        objc_enumerationMutation(v10);
      }
      id v15 = [*(id *)(a1 + 32) viewStateForName:*(void *)(*((void *)&v29 + 1) + 8 * i)];
      long long v16 = [v15 viewKeyHierarchyState];
      unsigned int v17 = [v16 isEqualToString:@"waitfortlk"];

      if (v17)
      {
        long long v20 = &stru_1003058E8;
LABEL_19:
        uint64_t v21 = +[CKKSResultOperation named:@"fail" withBlockTakingSelf:v20];
        uint64_t v22 = *(void *)(*(void *)(a1 + 48) + 8);
        BOOL v23 = *(void **)(v22 + 40);
        *(void *)(v22 + 40) = v21;
LABEL_21:

        goto LABEL_22;
      }
      long long v18 = [v15 viewKeyHierarchyState];
      unsigned int v19 = [v18 isEqualToString:@"waitfortrust"];

      if (v19)
      {
        long long v20 = &stru_100305908;
        goto LABEL_19;
      }
      if (([v15 ckksManagedView] & 1) == 0)
      {
        v27[0] = _NSConcreteStackBlock;
        v27[1] = 3221225472;
        v27[2] = sub_100181378;
        v27[3] = &unk_1003056C0;
        id v15 = v15;
        id v28 = v15;
        uint64_t v24 = +[CKKSResultOperation named:@"fail" withBlockTakingSelf:v27];
        uint64_t v25 = *(void *)(*(void *)(a1 + 48) + 8);
        uint64_t v26 = *(void **)(v25 + 40);
        *(void *)(v25 + 40) = v24;

        BOOL v23 = v28;
        goto LABEL_21;
      }
    }
    id v12 = [v10 countByEnumeratingWithState:&v29 objects:v33 count:16];
    if (v12) {
      continue;
    }
    break;
  }
LABEL_22:
}

id sub_100181368(uint64_t a1)
{
  return [*(id *)(a1 + 32) _onqueueProcessOutgoingQueue:*(void *)(a1 + 40) priorityRush:0];
}

void sub_100181378(uint64_t a1, void *a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = a2;
  id v6 = [v2 zoneName];
  +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Cannot push view %@; is externally managed",
  unsigned int v4 = v6);
  uint64_t v5 = +[NSError errorWithDomain:@"CKKSErrorDomain" code:63 description:v4];
  [v3 setError:v5];
}

void sub_100181434(id a1, CKKSResultOperation *a2)
{
  id v2 = a2;
  id v3 = +[NSError errorWithDomain:@"CKKSErrorDomain" code:52 description:@"No trust; push will not succeed."];
  [(CKKSResultOperation *)v2 setError:v3];
}

void sub_1001814B0(id a1, CKKSResultOperation *a2)
{
  id v2 = a2;
  id v3 = +[NSError errorWithDomain:@"CKKSErrorDomain" code:53 description:@"No TLKs for this view; push will not succeed."];
  [(CKKSResultOperation *)v2 setError:v3];
}

void sub_10018152C(id a1, CKKSResultOperation *a2)
{
  id v2 = a2;
  id v3 = +[NSError errorWithDomain:@"CKKSErrorDomain" code:10 description:@"No CloudKit account; push will not succeed."];
  [(CKKSResultOperation *)v2 setError:v3];
}

void sub_100181700(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100181830(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100181848(uint64_t a1)
{
  id v5 = [*(id *)(a1 + 32) operationDependencies];
  uint64_t v2 = [v5 viewsInState:@"waitfortlkcreation"];
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  unsigned int v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

uint64_t sub_100181A0C(uint64_t a1)
{
  long long v11 = 0u;
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v12;
    do
    {
      id v6 = 0;
      do
      {
        if (*(void *)v12 != v5) {
          objc_enumerationMutation(v2);
        }
        uint64_t v7 = *(void *)(*((void *)&v11 + 1) + 8 * (void)v6);
        int v8 = [*(id *)(a1 + 40) operationDependencies:v11];
        [v8 intransactionCKRecordChanged:v7 resync:0];

        id v6 = (char *)v6 + 1;
      }
      while (v4 != v6);
      id v4 = [v2 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }
    while (v4);
  }

  id v9 = [*(id *)(a1 + 40) stateMachine];
  [v9 _onqueueHandleFlag:@"key_process_requested"];

  return 1;
}

void sub_100181CA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100181CB8(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) operationDependencies];
  id v3 = [v2 currentFetchReasons];
  [v3 addObject:@"keyset"];

  id v4 = [*(id *)(a1 + 32) stateMachine];
  [v4 _onqueueHandleFlag:@"fetch_requested"];
}

void sub_100181D48(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = [v2 operationDependencies];
  id v4 = [v3 keysetProviderOperations];
  uint64_t v5 = [v2 findFirstPendingOperation:v4];
  uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = v5;

  if (!*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40))
  {
    int v8 = +[NSMutableSet set];
    long long v57 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v60 = 0u;
    id v9 = [*(id *)(a1 + 32) operationDependencies];
    id v10 = [v9 allCKKSManagedViews];

    id v11 = [v10 countByEnumeratingWithState:&v57 objects:v66 count:16];
    if (v11)
    {
      id v12 = v11;
      uint64_t v13 = *(void *)v58;
      do
      {
        for (CFIndex i = 0; i != v12; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v58 != v13) {
            objc_enumerationMutation(v10);
          }
          id v15 = [*(id *)(*((void *)&v57 + 1) + 8 * i) zoneID];
          [v8 addObject:v15];
        }
        id v12 = [v10 countByEnumeratingWithState:&v57 objects:v66 count:16];
      }
      while (v12);
    }

    long long v16 = [[CKKSProvideKeySetOperation alloc] initWithIntendedZoneIDs:v8];
    uint64_t v17 = *(void *)(*(void *)(a1 + 40) + 8);
    long long v18 = *(void **)(v17 + 40);
    *(void *)(v17 + 40) = v16;

    unsigned int v19 = [*(id *)(a1 + 32) operationDependencies];
    long long v20 = [v19 keysetProviderOperations];
    [v20 addObject:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40)];

    [*(id *)(a1 + 32) scheduleOperationWithoutDependencies:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40)];
  }
  uint64_t v21 = +[NSMutableDictionary dictionary];
  long long v53 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  uint64_t v49 = a1;
  uint64_t v22 = [*(id *)(a1 + 32) operationDependencies];
  BOOL v23 = [v22 allCKKSManagedViews];

  id obj = v23;
  id v52 = [v23 countByEnumeratingWithState:&v53 objects:v65 count:16];
  if (v52)
  {
    uint64_t v24 = *(void *)v54;
LABEL_12:
    uint64_t v25 = 0;
    while (1)
    {
      if (*(void *)v54 != v24) {
        objc_enumerationMutation(obj);
      }
      uint64_t v26 = *(void **)(*((void *)&v53 + 1) + 8 * v25);
      long long v27 = [v26 zoneID];
      id v28 = [v26 contextID];
      long long v29 = +[CKKSCurrentKeySet loadForZone:v27 contextID:v28];

      long long v30 = [v29 currentTLKPointer];
      uint64_t v31 = [v30 currentKeyUUID];
      if (!v31)
      {

LABEL_29:
        id v44 = [v26 zoneID];
        id v45 = [v44 zoneName];
        id v46 = sub_1000CD884(@"ckks", v45);

        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
        {
          unsigned __int8 v47 = [v26 zoneID];
          *(_DWORD *)long long buf = 138412546;
          CFStringRef v62 = v47;
          __int16 v63 = 2112;
          BOOL v64 = v29;
          _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "No current keyset for %@ (%@)", buf, 0x16u);
        }
        id v48 = [*(id *)(v49 + 32) stateMachine];
        [v48 _onqueueHandleFlag:@"key_set"];

        goto LABEL_32;
      }
      long long v32 = (void *)v31;
      uint64_t v33 = [v29 tlk];
      int v34 = [v33 uuid];
      if (!v34)
      {
        uint64_t v35 = v24;
        long long v36 = v21;
        BOOL v37 = [v26 viewKeyHierarchyState];
        if (([v37 isEqualToString:@"waitfortrust"] & 1) == 0)
        {
          uint64_t v42 = [v26 viewKeyHierarchyState];
          unsigned __int8 v50 = [v42 isEqualToString:@"waitfortlk"];

          uint64_t v21 = v36;
          uint64_t v24 = v35;
          if ((v50 & 1) == 0) {
            goto LABEL_29;
          }
          goto LABEL_20;
        }

        uint64_t v21 = v36;
        uint64_t v24 = v35;
      }

LABEL_20:
      uint64_t v38 = [v26 zoneID];
      id v39 = [v38 zoneName];
      id v40 = sub_1000CD884(@"ckks", v39);

      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        CFStringRef v62 = v29;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "Already have keyset %@", buf, 0xCu);
      }

      id v41 = [v26 zoneID];
      [v21 setObject:v29 forKeyedSubscript:v41];

      if (v52 == (id)++v25)
      {
        id v43 = [obj countByEnumeratingWithState:&v53 objects:v65 count:16];
        id v52 = v43;
        if (v43) {
          goto LABEL_12;
        }
        break;
      }
    }
  }

  [*(id *)(*(void *)(*(void *)(v49 + 40) + 8) + 40) provideKeySets:v21];
LABEL_32:
}

void sub_100183CA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,id location)
{
  objc_destroyWeak(v33);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100183CD0(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (!v9)
  {
    uint64_t v43 = a1;
    id v45 = v7;
    id v12 = objc_alloc_init(CKKSMemoryKeyCache);
    uint64_t v13 = [WeakRetained operationDependencies];
    long long v14 = [v13 contextID];
    [(CKKSMemoryKeyCache *)v12 populateWithRecords:v8 contextID:v14];

    unsigned __int8 v47 = +[NSMutableSet set];
    id v15 = v12;
    id v46 = +[NSMutableSet set];
    long long v57 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v60 = 0u;
    id v44 = v8;
    id obj = v8;
    id v16 = [obj countByEnumeratingWithState:&v57 objects:v61 count:16];
    id v48 = v12;
    if (!v16) {
      goto LABEL_23;
    }
    id v17 = v16;
    uint64_t v18 = *(void *)v58;
    while (1)
    {
      unsigned int v19 = 0;
      do
      {
        if (*(void *)v58 != v18) {
          objc_enumerationMutation(obj);
        }
        uint64_t v20 = *(void *)(*((void *)&v57 + 1) + 8 * (void)v19);
        uint64_t v21 = [CKKSKey alloc];
        uint64_t v22 = [WeakRetained operationDependencies];
        BOOL v23 = [v22 contextID];
        uint64_t v24 = [(CKKSCKRecordHolder *)v21 initWithCKRecord:v20 contextID:v23];

        uint64_t v25 = [WeakRetained operationDependencies];
        uint64_t v26 = [v25 contextID];
        id v56 = 0;
        long long v27 = [(CKKSKey *)v24 ensureKeyLoadedForContextID:v26 cache:v15 error:&v56];
        id v28 = v56;

        if (!v27)
        {
          if (v28)
          {
            long long v29 = sub_1000CD884(@"ckks-oob", 0);
            if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138412290;
              id v63 = v28;
              _os_log_debug_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEBUG, "Could not find key material in keychain: %@", buf, 0xCu);
            }
          }
          long long v30 = [(CKKSKey *)v24 keyclass];
          if ([v30 isEqual:@"tlk"])
          {
            uint64_t v31 = [(CKKSKey *)v24 parentKeyUUID];
            long long v32 = [(CKKSKey *)v24 uuid];
            unsigned __int8 v33 = [v31 isEqualToString:v32];

            int v34 = v46;
            if (v33) {
              goto LABEL_20;
            }
          }
          else
          {
          }
          int v34 = v47;
LABEL_20:
          [v34 addObject:v24];
          id v15 = v48;
        }

        unsigned int v19 = (char *)v19 + 1;
      }
      while (v17 != v19);
      id v17 = [obj countByEnumeratingWithState:&v57 objects:v61 count:16];
      if (!v17)
      {
LABEL_23:

        if ([v46 count])
        {
          uint64_t v35 = [WeakRetained cuttlefishAdapter];
          uint64_t v36 = *(void *)(v43 + 32);
          BOOL v37 = [WeakRetained accountTracker];
          uint64_t v38 = [v37 octagonPeerID];
          id v39 = [WeakRetained operationDependencies];
          id v40 = [v39 contextID];
          v50[0] = _NSConcreteStackBlock;
          v50[1] = 3221225472;
          v50[2] = sub_10018421C;
          v50[3] = &unk_100305860;
          id v55 = *(id *)(v43 + 40);
          v50[4] = WeakRetained;
          id v51 = v48;
          id v52 = v46;
          id v41 = v46;
          uint64_t v42 = v47;
          id v53 = v47;
          id v7 = v45;
          id v54 = v45;
          [v35 fetchRecoverableTLKShares:v36 peerID:v38 contextID:v40 reply:v50];

          id v15 = v48;
          id v9 = 0;
        }
        else
        {
          id v7 = v45;
          [WeakRetained decryptPCSIdentities:v45 cache:v15 complete:*(void *)(v43 + 40)];
          id v9 = 0;
          id v41 = v46;
          uint64_t v42 = v47;
        }

        id v8 = v44;
        goto LABEL_27;
      }
    }
  }
  id v11 = sub_1000CD884(@"ckks-oob", 0);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 138412290;
    id v63 = v9;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "error getting pcs identities: %@", buf, 0xCu);
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
LABEL_27:
}

void sub_10018421C(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = v5;
  if (a2 && !v5)
  {
    id v7 = *(void **)(a1 + 32);
    uint64_t v8 = *(void *)(a1 + 40);
    uint64_t v9 = *(void *)(a1 + 48);
    id v22 = 0;
    unsigned int v10 = [v7 unwrapTLKAndSaveToCache:v8 tlks:v9 tlkShares:a2 error:&v22];
    id v11 = v22;
    id v12 = v11;
    if (!v10 || v11)
    {
      unsigned int v19 = sub_1000CD884(@"ckks-oob", 0);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        uint64_t v24 = v12;
        uint64_t v20 = "Errored unwrapping TLK Shares, quitting: %@";
LABEL_15:
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, v20, buf, 0xCu);
      }
    }
    else
    {
      uint64_t v13 = *(void **)(a1 + 32);
      uint64_t v14 = *(void *)(a1 + 40);
      uint64_t v15 = *(void *)(a1 + 56);
      id v21 = 0;
      unsigned int v16 = [v13 unwrapKeysAndSaveToCache:v14 syncKeys:v15 error:&v21];
      id v17 = v21;
      id v12 = v17;
      if (v16 && !v17)
      {
        [*(id *)(a1 + 32) decryptPCSIdentities:*(void *)(a1 + 64) cache:*(void *)(a1 + 40) complete:*(void *)(a1 + 72)];
        goto LABEL_17;
      }
      unsigned int v19 = sub_1000CD884(@"ckks-oob", 0);
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        uint64_t v24 = v12;
        uint64_t v20 = "Errored unwrapping sync keys, quitting: %@";
        goto LABEL_15;
      }
    }

    (*(void (**)(void))(*(void *)(a1 + 72) + 16))();
    goto LABEL_17;
  }
  uint64_t v18 = sub_1000CD884(@"ckks-oob", 0);
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 138412290;
    uint64_t v24 = v6;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Errored fetching TLK shares: %@", buf, 0xCu);
  }

  (*(void (**)(void))(*(void *)(a1 + 72) + 16))();
LABEL_17:
}

void sub_100184C04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,id location)
{
  objc_destroyWeak(v33);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100184C30(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (!v9)
  {
    uint64_t v43 = a1;
    id v45 = v7;
    id v12 = objc_alloc_init(CKKSMemoryKeyCache);
    uint64_t v13 = [WeakRetained operationDependencies];
    uint64_t v14 = [v13 contextID];
    [(CKKSMemoryKeyCache *)v12 populateWithRecords:v8 contextID:v14];

    unsigned __int8 v47 = +[NSMutableSet set];
    uint64_t v15 = v12;
    id v46 = +[NSMutableSet set];
    long long v57 = 0u;
    long long v58 = 0u;
    long long v59 = 0u;
    long long v60 = 0u;
    id v44 = v8;
    id obj = v8;
    id v16 = [obj countByEnumeratingWithState:&v57 objects:v61 count:16];
    id v48 = v12;
    if (!v16) {
      goto LABEL_23;
    }
    id v17 = v16;
    uint64_t v18 = *(void *)v58;
    while (1)
    {
      unsigned int v19 = 0;
      do
      {
        if (*(void *)v58 != v18) {
          objc_enumerationMutation(obj);
        }
        uint64_t v20 = *(void *)(*((void *)&v57 + 1) + 8 * (void)v19);
        id v21 = [CKKSKey alloc];
        id v22 = [WeakRetained operationDependencies];
        BOOL v23 = [v22 contextID];
        uint64_t v24 = [(CKKSCKRecordHolder *)v21 initWithCKRecord:v20 contextID:v23];

        uint64_t v25 = [WeakRetained operationDependencies];
        uint64_t v26 = [v25 contextID];
        id v56 = 0;
        long long v27 = [(CKKSKey *)v24 ensureKeyLoadedForContextID:v26 cache:v15 error:&v56];
        id v28 = v56;

        if (!v27)
        {
          if (v28)
          {
            long long v29 = sub_1000CD884(@"ckks-oob", 0);
            if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138412290;
              id v63 = v28;
              _os_log_debug_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEBUG, "Could not find key material in keychain: %@", buf, 0xCu);
            }
          }
          long long v30 = [(CKKSKey *)v24 keyclass];
          if ([v30 isEqual:@"tlk"])
          {
            uint64_t v31 = [(CKKSKey *)v24 parentKeyUUID];
            long long v32 = [(CKKSKey *)v24 uuid];
            unsigned __int8 v33 = [v31 isEqualToString:v32];

            int v34 = v46;
            if (v33) {
              goto LABEL_20;
            }
          }
          else
          {
          }
          int v34 = v47;
LABEL_20:
          [v34 addObject:v24];
          uint64_t v15 = v48;
        }

        unsigned int v19 = (char *)v19 + 1;
      }
      while (v17 != v19);
      id v17 = [obj countByEnumeratingWithState:&v57 objects:v61 count:16];
      if (!v17)
      {
LABEL_23:

        if ([v46 count])
        {
          uint64_t v35 = [WeakRetained cuttlefishAdapter];
          uint64_t v36 = *(void *)(v43 + 32);
          BOOL v37 = [WeakRetained accountTracker];
          uint64_t v38 = [v37 octagonPeerID];
          id v39 = [WeakRetained operationDependencies];
          id v40 = [v39 contextID];
          v50[0] = _NSConcreteStackBlock;
          v50[1] = 3221225472;
          v50[2] = sub_10018517C;
          v50[3] = &unk_100305860;
          id v55 = *(id *)(v43 + 40);
          v50[4] = WeakRetained;
          id v51 = v48;
          id v52 = v46;
          id v41 = v46;
          uint64_t v42 = v47;
          id v53 = v47;
          id v7 = v45;
          id v54 = v45;
          [v35 fetchRecoverableTLKShares:v36 peerID:v38 contextID:v40 reply:v50];

          uint64_t v15 = v48;
          id v9 = 0;
        }
        else
        {
          id v7 = v45;
          [WeakRetained decryptCurrentItems:v45 cache:v15 complete:*(void *)(v43 + 40)];
          id v9 = 0;
          id v41 = v46;
          uint64_t v42 = v47;
        }

        id v8 = v44;
        goto LABEL_27;
      }
    }
  }
  id v11 = sub_1000CD884(@"ckks-oob", 0);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 138412290;
    id v63 = v9;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "error getting current items: %@", buf, 0xCu);
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
LABEL_27:
}

void sub_10018517C(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = v5;
  if (a2 && !v5)
  {
    id v7 = *(void **)(a1 + 32);
    uint64_t v8 = *(void *)(a1 + 40);
    uint64_t v9 = *(void *)(a1 + 48);
    id v20 = 0;
    [v7 unwrapTLKAndSaveToCache:v8 tlks:v9 tlkShares:a2 error:&v20];
    id v10 = v20;
    if (v10)
    {
      id v11 = v10;
      id v12 = sub_1000CD884(@"ckks-oob", 0);
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
LABEL_13:

        (*(void (**)(void))(*(void *)(a1 + 72) + 16))();
        goto LABEL_14;
      }
      *(_DWORD *)long long buf = 138412290;
      id v22 = v11;
      uint64_t v13 = "Errored unwrapping TLK Shares, quitting: %@";
    }
    else
    {
      uint64_t v15 = *(void **)(a1 + 32);
      uint64_t v16 = *(void *)(a1 + 40);
      uint64_t v17 = *(void *)(a1 + 56);
      id v19 = 0;
      [v15 unwrapKeysAndSaveToCache:v16 syncKeys:v17 error:&v19];
      id v18 = v19;
      if (!v18)
      {
        [*(id *)(a1 + 32) decryptCurrentItems:*(void *)(a1 + 64) cache:*(void *)(a1 + 40) complete:*(void *)(a1 + 72)];
        goto LABEL_14;
      }
      id v11 = v18;
      id v12 = sub_1000CD884(@"ckks-oob", 0);
      if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
        goto LABEL_13;
      }
      *(_DWORD *)long long buf = 138412290;
      id v22 = v11;
      uint64_t v13 = "Errored unwrapping sync keys, quitting: %@";
    }
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, v13, buf, 0xCu);
    goto LABEL_13;
  }
  uint64_t v14 = sub_1000CD884(@"ckks-oob", 0);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 138412290;
    id v22 = v6;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Errored fetching TLK shares, unable to decrypt identities: %@", buf, 0xCu);
  }

  (*(void (**)(void))(*(void *)(a1 + 72) + 16))();
LABEL_14:
}

void sub_100185828(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id *location, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,id a25)
{
}

void sub_100185850(id *a1)
{
  id v2 = [a1[4] error];

  if (v2)
  {
    id v3 = [a1[5] zoneName];
    id v4 = sub_1000CD884(@"ckkscurrent", v3);

    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      id v5 = [a1[4] error];
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Rejecting current item pointer get since fetch failed: %@", (uint8_t *)&buf, 0xCu);
    }
    uint64_t v6 = (void (**)(id, void, void *))a1[10];
    id WeakRetained = [a1[4] error];
    v6[2](v6, 0, WeakRetained);
  }
  else
  {
    id WeakRetained = objc_loadWeakRetained(a1 + 11);
    *(void *)&long long buf = 0;
    *((void *)&buf + 1) = &buf;
    uint64_t v17 = 0x2020000000;
    char v18 = 0;
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472;
    v8[2] = sub_100185AC8;
    v8[3] = &unk_100305838;
    id v9 = a1[6];
    id v10 = a1[7];
    id v11 = WeakRetained;
    id v12 = a1[8];
    id v13 = a1[9];
    id v14 = a1[10];
    p_long long buf = &buf;
    [WeakRetained dispatchSyncWithReadOnlySQLTransaction:v8];
    if (*(unsigned char *)(*((void *)&buf + 1) + 24)
      && ([WeakRetained firstManateeKeyFetched] & 1) == 0
      && [a1[8] isEqualToString:kSecAttrViewHintManatee])
    {
      [WeakRetained setFirstManateeKeyFetched:1];
      [WeakRetained sendMetricForFirstManateeAccess];
    }

    _Block_object_dispose(&buf, 8);
  }
}

void sub_100185AA8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_100185AC8(uint64_t a1)
{
  id v2 = +[NSString stringWithFormat:@"%@-%@", *(void *)(a1 + 32), *(void *)(a1 + 40)];
  if (qword_10035D098 != -1) {
    dispatch_once(&qword_10035D098, &stru_100303AB8);
  }
  if (byte_10035D090)
  {
    id v3 = sub_10000B070("ckkspersona");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      id v4 = [*(id *)(a1 + 48) personaAdapter];
      id v5 = [v4 currentThreadPersonaUniqueString];
      uint64_t v6 = [*(id *)(a1 + 48) operationDependencies];
      id v7 = [v6 activeAccount];
      uint64_t v8 = [v7 personaUniqueString];
      uint64_t v9 = *(void *)(a1 + 56);
      *(_DWORD *)long long buf = 138413058;
      int v34 = v5;
      __int16 v35 = 2112;
      uint64_t v36 = v8;
      __int16 v37 = 2112;
      uint64_t v38 = v2;
      __int16 v39 = 2112;
      uint64_t v40 = v9;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "getCurrentItemForAccessGroup: thread persona [%@/%@] this currentIdentifier [%@] viewhint [%@]", buf, 0x2Au);
    }
  }
  id v10 = [*(id *)(a1 + 48) operationDependencies];
  id v11 = [v10 contextID];
  uint64_t v12 = *(void *)(a1 + 64);
  id v32 = 0;
  id v13 = +[CKKSCurrentItemPointer fromDatabase:v2 contextID:v11 state:@"local" zoneID:v12 error:&v32];
  id v14 = v32;

  if (!v13 || v14)
  {
    uint64_t v24 = [v14 domain];
    if ([v24 isEqualToString:@"securityd"])
    {
      id v25 = [v14 code];

      if (v25 == (id)-25300)
      {
        uint64_t v26 = [*(id *)(a1 + 48) zoneName];
        long long v27 = sub_1000CD884(@"ckkscurrent", v26);

        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 138412290;
          int v34 = v2;
          _os_log_debug_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEBUG, "No current item pointer for %@", buf, 0xCu);
        }

        id v28 = +[NSString stringWithFormat:@"No current item pointer found for %@", v2];
        uint64_t v29 = +[NSError errorWithDomain:@"securityd" code:-25300 description:v28];

        id v14 = (id)v29;
LABEL_21:

        (*(void (**)(void))(*(void *)(a1 + 72) + 16))();
        goto LABEL_26;
      }
    }
    else
    {
    }
    long long v30 = [*(id *)(a1 + 48) zoneName];
    id v28 = sub_1000CD884(@"ckkscurrent", v30);

    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      int v34 = v2;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "No current item pointer for %@", buf, 0xCu);
    }
    goto LABEL_21;
  }
  uint64_t v15 = [v13 currentItemUUID];

  uint64_t v16 = [*(id *)(a1 + 48) zoneName];
  uint64_t v17 = sub_1000CD884(@"ckkscurrent", v16);

  if (v15)
  {
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      int v34 = v13;
      _os_log_debug_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "Retrieved current item pointer: %@", buf, 0xCu);
    }

    *(unsigned char *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) = 1;
    char v18 = [CKKSCurrentItemData alloc];
    id v19 = [v13 currentItemUUID];
    id v20 = [(CKKSCurrentItemData *)v18 initWithUUID:v19];

    id v21 = [v13 storedCKRecord];
    id v22 = [v21 modificationDate];
    [(CKKSCurrentItemData *)v20 setModificationDate:v22];

    BOOL v23 = *(void (**)(void))(*(void *)(a1 + 72) + 16);
  }
  else
  {
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      int v34 = v13;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Current item pointer is empty %@", buf, 0xCu);
    }

    uint64_t v31 = *(void *)(a1 + 72);
    id v20 = +[NSError errorWithDomain:@"CKKSErrorDomain" code:-67671 description:@"Current item pointer is empty"];
    BOOL v23 = *(void (**)(void))(v31 + 16);
  }
  v23();

  id v14 = 0;
LABEL_26:
}

void sub_1001866A0(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) error];

  id v3 = [*(id *)(a1 + 40) zoneID];
  id v4 = [v3 zoneName];
  id v5 = sub_1000CD884(@"ckkscurrent", v4);

  if (v2)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = [*(id *)(a1 + 32) error];
      int v9 = 138412290;
      id v10 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed deleting current item pointers: %@", (uint8_t *)&v9, 0xCu);
    }
  }
  else if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v9) = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Finished deleting current item pointers", (uint8_t *)&v9, 2u);
  }

  uint64_t v7 = *(void *)(a1 + 48);
  uint64_t v8 = [*(id *)(a1 + 32) error];
  (*(void (**)(uint64_t, void *))(v7 + 16))(v7, v8);
}

void sub_100186D04(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) error];

  id v3 = [*(id *)(a1 + 40) zoneID];
  id v4 = [v3 zoneName];
  id v5 = sub_1000CD884(@"ckkscurrent", v4);

  if (v2)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = [*(id *)(a1 + 32) currentPointerIdentifier];
      uint64_t v7 = [*(id *)(a1 + 32) error];
      int v10 = 138412546;
      id v11 = v6;
      __int16 v12 = 2112;
      id v13 = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed setting a current item pointer for %@ with %@", (uint8_t *)&v10, 0x16u);

LABEL_6:
    }
  }
  else if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = [*(id *)(a1 + 32) currentPointerIdentifier];
    int v10 = 138412290;
    id v11 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Finished setting a current item pointer for %@", (uint8_t *)&v10, 0xCu);
    goto LABEL_6;
  }

  uint64_t v8 = *(void *)(a1 + 48);
  int v9 = [*(id *)(a1 + 32) error];
  (*(void (**)(uint64_t, void *))(v8 + 16))(v8, v9);
}

void sub_100187B00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
}

void sub_100187B5C(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) operationDependencies];
  id v3 = [v2 syncingPolicy];

  if (v3)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
  }
  else
  {
    id v4 = sub_1000CD884(@"ckks", 0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = *(void *)(a1 + 48);
      int v6 = 138477827;
      uint64_t v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "No policy configured. Skipping item: %{private}@", (uint8_t *)&v6, 0xCu);
    }

    [*(id *)(a1 + 32) setItemModificationsBeforePolicyLoaded:1];
  }
}

uint64_t sub_100187C60(uint64_t a1)
{
  uint64_t v1 = [*(id *)(a1 + 32) notifyViewChangedScheduler];
  [v1 trigger];

  if ([*(id *)(a1 + 40) accountStatus] != (id)3)
  {
    __int16 v117 = objc_alloc_init(CKKSMemoryKeyCache);
    *(void *)long long buf = 0;
    long long v152 = buf;
    uint64_t v153 = 0x3032000000;
    long long v154 = sub_100177A70;
    long long v155 = sub_100177A80;
    id v156 = 0;
    if (*(unsigned char *)(a1 + 96))
    {
      int v9 = [*(id *)(a1 + 40) personaAdapter];
      int v10 = v145;
      v145[0] = _NSConcreteStackBlock;
      v145[1] = 3221225472;
      v145[2] = sub_100188D64;
      v145[3] = &unk_1003057C0;
      uint64_t v11 = *(void *)(a1 + 64);
      id v148 = buf;
      uint64_t v150 = v11;
      *(_OWORD *)CFStringRef v118 = *(_OWORD *)(a1 + 32);
      id v12 = v118[0];
      int8x16_t v146 = vextq_s8(*(int8x16_t *)v118, *(int8x16_t *)v118, 8uLL);
      id v13 = v117;
      uint64_t v14 = *(void *)(a1 + 56);
      long long v147 = v13;
      uint64_t v149 = v14;
      [v9 performBlockWithPersonaIdentifier:0 block:v145];
    }
    else if (*(unsigned char *)(a1 + 97))
    {
      int v9 = [*(id *)(a1 + 40) personaAdapter];
      int v10 = v139;
      v139[0] = _NSConcreteStackBlock;
      v139[1] = 3221225472;
      v139[2] = sub_100188E44;
      v139[3] = &unk_1003057C0;
      uint64_t v15 = *(void *)(a1 + 72);
      id v142 = buf;
      uint64_t v144 = v15;
      *(_OWORD *)__int16 v119 = *(_OWORD *)(a1 + 32);
      id v16 = v119[0];
      int8x16_t v140 = vextq_s8(*(int8x16_t *)v119, *(int8x16_t *)v119, 8uLL);
      uint64_t v17 = v117;
      uint64_t v18 = *(void *)(a1 + 56);
      long long v141 = v17;
      uint64_t v143 = v18;
      [v9 performBlockWithPersonaIdentifier:0 block:v139];
    }
    else
    {
      if (!*(unsigned char *)(a1 + 98))
      {
        long long v101 = [*(id *)(a1 + 32) zoneID];
        long long v102 = [v101 zoneName];
        id v63 = sub_1000CD884(@"ckks", v102);

        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
        {
          long long v103 = *(void **)(a1 + 64);
          long long v104 = *(void **)(a1 + 72);
          *(_DWORD *)long long v157 = 138478083;
          long long v158 = v103;
          __int16 v159 = 2113;
          long long v160 = v104;
          _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "processKeychainEventItemAdded given garbage: %{private}@ %{private}@", v157, 0x16u);
        }
        goto LABEL_43;
      }
      int v9 = [*(id *)(a1 + 40) personaAdapter];
      int v10 = v133;
      v133[0] = _NSConcreteStackBlock;
      v133[1] = 3221225472;
      v133[2] = sub_100188F24;
      v133[3] = &unk_1003057C0;
      uint64_t v19 = *(void *)(a1 + 64);
      long long v136 = buf;
      uint64_t v138 = v19;
      *(_OWORD *)uint64_t v120 = *(_OWORD *)(a1 + 32);
      id v20 = v120[0];
      int8x16_t v134 = vextq_s8(*(int8x16_t *)v120, *(int8x16_t *)v120, 8uLL);
      id v21 = v117;
      uint64_t v22 = *(void *)(a1 + 56);
      long long v135 = v21;
      uint64_t v137 = v22;
      [v9 performBlockWithPersonaIdentifier:0 block:v133];
    }

    BOOL v23 = [*(id *)(a1 + 40) operationDependencies];
    uint64_t v24 = [v23 syncingPolicy];
    id v25 = [*(id *)(a1 + 32) zoneID];
    uint64_t v26 = [v25 zoneName];
    unsigned __int8 v27 = [v24 isSyncingEnabledForView:v26];

    if ((v27 & 1) == 0)
    {
      id v28 = +[CKKSViewManager manager];
      uint64_t v29 = [*((id *)v152 + 5) uuid];
      long long v30 = [v28 claimCallbackForUUID:v29];

      if (v30)
      {
        uint64_t v31 = +[NSError errorWithDomain:@"CKKSErrorDomain" code:55 description:@"View is paused; item is not expected to sync"];
        ((void (**)(void, void, void *))v30)[2](v30, 0, v31);
      }
    }
    uint64_t v32 = a1;
    if (*(void *)(a1 + 80)) {
      CFStringRef v33 = @"keychain-api-use";
    }
    else {
      CFStringRef v33 = @"sos-incoming-item";
    }
    uint64_t v34 = +[CKOperationGroup CKKSGroupWithName:v33];
    uint64_t v35 = *(void *)(*(void *)(a1 + 56) + 8);
    CFStringRef v116 = v34;
    if (*(void *)(v35 + 40))
    {
      uint64_t v36 = [*(id *)(a1 + 32) zoneID];
      __int16 v37 = [v36 zoneName];
      uint64_t v38 = sub_1000CD884(@"ckks", v37);

      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
      {
        __int16 v39 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
        *(_DWORD *)long long v157 = 138412290;
        long long v158 = v39;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "Couldn't create outgoing queue entry: %@", v157, 0xCu);
      }

      uint64_t v40 = [*(id *)(a1 + 40) stateMachine];
      [v40 _onqueueHandleFlag:@"dropped_items"];

      id v41 = [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) domain];
      if ([v41 isEqualToString:@"CKKSErrorDomain"])
      {
        BOOL v42 = [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) code] == (id)-25300;

        if (!v42)
        {
LABEL_42:
          id v63 = v116;
LABEL_43:

          _Block_object_dispose(buf, 8);
          goto LABEL_44;
        }
        uint64_t v43 = [*(id *)(a1 + 40) stateMachine];
        [v43 _onqueueHandleFlag:@"key_process_requested"];
        id v44 = v43;
LABEL_41:

        goto LABEL_42;
      }
LABEL_40:
      id v44 = v41;
      goto LABEL_41;
    }
    id v45 = (void *)*((void *)v152 + 5);
    if (!v45)
    {
      id v54 = [*(id *)(a1 + 32) zoneID];
      id v55 = [v54 zoneName];
      id v41 = sub_1000CD884(@"ckks", v55);

      if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
        goto LABEL_40;
      }
      id v56 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
      *(_DWORD *)long long v157 = 138412290;
      long long v158 = v56;
      long long v57 = "Decided that no operation needs to occur for %@";
LABEL_39:
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, v57, v157, 0xCu);
      goto LABEL_40;
    }
    id v46 = *(void **)(a1 + 48);
    if (v46)
    {
      unsigned __int8 v47 = +[NSDate date];
      id v132 = 0;
      signed int v48 = [v46 judge:v45 at:v47 limitTime:&v132];
      id v49 = v132;

      if (v49)
      {
        [*((id *)v152 + 5) setWaitUntil:v49];
        v165[0] = @"ratelimit";
        unsigned __int8 v50 = +[NSNumber numberWithInteger:v48];
        v165[1] = @"accessgroup";
        v166[0] = v50;
        id v51 = [*((id *)v152 + 5) accessgroup];
        v166[1] = v51;
        id v52 = +[NSDictionary dictionaryWithObjects:v166 forKeys:v165 count:2];
        sub_100029560(@"CKKSSyncing", v52);
      }
      id v45 = (void *)*((void *)v152 + 5);
      uint64_t v32 = a1;
      uint64_t v35 = *(void *)(*(void *)(a1 + 56) + 8);
      id v53 = *(void **)(v35 + 40);
    }
    else
    {
      id v53 = 0;
    }
    uint64_t v58 = *(void *)(v32 + 88);
    id obj = v53;
    [v45 saveToDatabaseWithConnection:v58 error:&obj];
    objc_storeStrong((id *)(v35 + 40), obj);
    long long v59 = *(void **)(a1 + 32);
    if (*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40))
    {
      long long v60 = [v59 zoneID];
      CFStringRef v61 = [v60 zoneName];
      id v41 = sub_1000CD884(@"ckks", v61);

      if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
        goto LABEL_40;
      }
      CFStringRef v62 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
      *(_DWORD *)long long v157 = 138412290;
      long long v158 = v62;
      long long v57 = "Couldn't save outgoing queue entry to database: %@";
      goto LABEL_39;
    }
    id v65 = [v59 zoneID];
    id v66 = [v65 zoneName];
    id v67 = sub_1000CD884(@"ckks", v66);

    if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
    {
      v68 = (void *)*((void *)v152 + 5);
      *(_DWORD *)long long v157 = 138412290;
      long long v158 = v68;
      _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "Saved %@ to outgoing queue", v157, 0xCu);
    }

    id v69 = [*((id *)v152 + 5) uuid];
    v164[0] = @"reencrypt";
    v164[1] = @"error";
    id v70 = +[NSArray arrayWithObjects:v164 count:2];
    id v71 = [*(id *)(a1 + 40) operationDependencies];
    CFDataRef v72 = [v71 contextID];
    CFNumberRef v73 = [*(id *)(a1 + 32) zoneID];
    uint64_t v74 = *(void *)(*(void *)(a1 + 56) + 8);
    id v130 = *(id *)(v74 + 40);
    id v75 = +[CKKSOutgoingQueueEntry allWithUUID:v69 states:v70 contextID:v72 zoneID:v73 error:&v130];
    objc_storeStrong((id *)(v74 + 40), v130);

    if (*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40))
    {
      v76 = [*(id *)(a1 + 32) zoneID];
      id v77 = [v76 zoneName];
      id v78 = sub_1000CD884(@"ckks", v77);

      if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
      {
        id v79 = (void *)*((void *)v152 + 5);
        uint64_t v80 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
        *(_DWORD *)long long v157 = 138412546;
        long long v158 = v79;
        __int16 v159 = 2112;
        long long v160 = v80;
        _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_ERROR, "Couldn't load OQE siblings for %@: %@", v157, 0x16u);
      }
    }
    long long v128 = 0u;
    long long v129 = 0u;
    long long v126 = 0u;
    long long v127 = 0u;
    long long v121 = v75;
    id v81 = [v121 countByEnumeratingWithState:&v126 objects:v163 count:16];
    if (v81)
    {
      uint64_t v82 = *(void *)v127;
      do
      {
        for (CFIndex i = 0; i != v81; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v127 != v82) {
            objc_enumerationMutation(v121);
          }
          uint64_t v84 = *(void **)(*((void *)&v126 + 1) + 8 * i);
          id v125 = 0;
          [v84 deleteFromDatabase:&v125];
          id v85 = v125;
          if (v85)
          {
            id v86 = [*(id *)(a1 + 32) zoneID];
            char v87 = [v86 zoneName];
            id v88 = sub_1000CD884(@"ckks", v87);

            if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
            {
              id v89 = [*((id *)v152 + 5) uuid];
              *(_DWORD *)long long v157 = 138412802;
              long long v158 = v84;
              __int16 v159 = 2112;
              long long v160 = v89;
              __int16 v161 = 2112;
              id v162 = v85;
              _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_ERROR, "Couldn't delete OQE sibling(%@) for %@: %@", v157, 0x20u);
            }
          }
        }
        id v81 = [v121 countByEnumeratingWithState:&v126 objects:v163 count:16];
      }
      while (v81);
    }

    uint64_t v90 = [*((id *)v152 + 5) uuid];
    id v91 = [*(id *)(a1 + 40) operationDependencies];
    long long v92 = [v91 contextID];
    uint64_t v93 = [*(id *)(a1 + 32) zoneID];
    id v124 = 0;
    long long v94 = +[CKKSIncomingQueueEntry tryFromDatabase:v90 contextID:v92 zoneID:v93 error:&v124];
    id v95 = v124;

    if (v95)
    {
      long long v96 = [*(id *)(a1 + 32) zoneID];
      long long v97 = [v96 zoneName];
      long long v98 = sub_1000CD884(@"ckks", v97);

      if (os_log_type_enabled(v98, OS_LOG_TYPE_ERROR))
      {
        long long v99 = [*((id *)v152 + 5) uuid];
        long long v100 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
        *(_DWORD *)long long v157 = 138412546;
        long long v158 = v99;
        __int16 v159 = 2112;
        long long v160 = v100;
        _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_ERROR, "Couldn't find IQE matching %@: %@", v157, 0x16u);
      }
    }
    else
    {
      if (!v94)
      {
        id v95 = 0;
LABEL_76:
        id v113 = +[CKKSViewManager manager];
        uint64_t v114 = [*((id *)v152 + 5) uuid];
        id v115 = [v113 peekCallbackForUUID:v114];

        [*(id *)(a1 + 40) _onqueueProcessOutgoingQueue:v116 priorityRush:v115];
        id v44 = v121;
        goto LABEL_41;
      }
      id v123 = 0;
      [v94 deleteFromDatabase:&v123];
      id v95 = v123;
      long long v105 = *(void **)(a1 + 32);
      if (v95)
      {
        long long v106 = [v105 zoneID];
        long long v107 = [v106 zoneName];
        long long v98 = sub_1000CD884(@"ckks", v107);

        if (os_log_type_enabled(v98, OS_LOG_TYPE_ERROR))
        {
          long long v108 = [*((id *)v152 + 5) uuid];
          long long v109 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
          *(_DWORD *)long long v157 = 138412546;
          long long v158 = v108;
          __int16 v159 = 2112;
          long long v160 = v109;
          _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_ERROR, "Couldn't delete IQE matching %@: %@", v157, 0x16u);
        }
      }
      else
      {
        v110 = [v105 zoneID];
        v111 = [v110 zoneName];
        long long v98 = sub_1000CD884(@"ckks", v111);

        if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
        {
          id v112 = [*((id *)v152 + 5) uuid];
          *(_DWORD *)long long v157 = 138412290;
          long long v158 = v112;
          _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_DEFAULT, "Deleted IQE matching changed item %@", v157, 0xCu);
        }
        id v95 = 0;
      }
    }

    goto LABEL_76;
  }
  id v2 = [*(id *)(a1 + 40) stateMachine];
  [v2 _onqueueHandleFlag:@"dropped_items"];

  id v3 = [*(id *)(a1 + 32) zoneID];
  id v4 = [v3 zoneName];
  uint64_t v5 = sub_1000CD884(@"ckks", v4);

  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Dropping sync item modification due to CK account state; will scan to find changes later",
      buf,
      2u);
  }

  int v6 = *(const void **)(a1 + 64);
  if (!v6) {
    int v6 = *(const void **)(a1 + 72);
  }
  sub_100118CF8(v6, (uint64_t)&off_100305790, 0);
  __int16 v117 = (CKKSMemoryKeyCache *)objc_claimAutoreleasedReturnValue();
  uint64_t v7 = +[CKKSViewManager manager];
  uint64_t v8 = [v7 claimCallbackForUUID:v117];

  if (v8) {
    +[CKKSViewManager callSyncCallbackWithErrorNoAccount:v8];
  }

LABEL_44:
  return 1;
}

void sub_100188CE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
}

void sub_100188D64(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 72);
  id v3 = [*(id *)(a1 + 32) operationDependencies];
  id v4 = [v3 contextID];
  uint64_t v5 = [*(id *)(a1 + 40) zoneID];
  uint64_t v6 = *(void *)(a1 + 48);
  uint64_t v7 = *(void *)(*(void *)(a1 + 64) + 8);
  id obj = *(id *)(v7 + 40);
  uint64_t v8 = +[CKKSOutgoingQueueEntry withItem:v2 action:@"add" contextID:v4 zoneID:v5 keyCache:v6 error:&obj];
  objc_storeStrong((id *)(v7 + 40), obj);
  uint64_t v9 = *(void *)(*(void *)(a1 + 56) + 8);
  int v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v8;
}

void sub_100188E44(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 72);
  id v3 = [*(id *)(a1 + 32) operationDependencies];
  id v4 = [v3 contextID];
  uint64_t v5 = [*(id *)(a1 + 40) zoneID];
  uint64_t v6 = *(void *)(a1 + 48);
  uint64_t v7 = *(void *)(*(void *)(a1 + 64) + 8);
  id obj = *(id *)(v7 + 40);
  uint64_t v8 = +[CKKSOutgoingQueueEntry withItem:v2 action:@"delete" contextID:v4 zoneID:v5 keyCache:v6 error:&obj];
  objc_storeStrong((id *)(v7 + 40), obj);
  uint64_t v9 = *(void *)(*(void *)(a1 + 56) + 8);
  int v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v8;
}

void sub_100188F24(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 72);
  id v3 = [*(id *)(a1 + 32) operationDependencies];
  id v4 = [v3 contextID];
  uint64_t v5 = [*(id *)(a1 + 40) zoneID];
  uint64_t v6 = *(void *)(a1 + 48);
  uint64_t v7 = *(void *)(*(void *)(a1 + 64) + 8);
  id obj = *(id *)(v7 + 40);
  uint64_t v8 = +[CKKSOutgoingQueueEntry withItem:v2 action:@"modify" contextID:v4 zoneID:v5 keyCache:v6 error:&obj];
  objc_storeStrong((id *)(v7 + 40), obj);
  uint64_t v9 = *(void *)(*(void *)(a1 + 56) + 8);
  int v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v8;
}

void sub_100189EA4(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_100189EC0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v5 = [WeakRetained operationDependencies];
  uint64_t v6 = [v5 currentTrustStates];

  uint64_t v7 = +[NSMutableSet set];
  uint64_t v8 = [WeakRetained operationDependencies];
  uint64_t v9 = [v8 databaseProvider];
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  v15[2] = sub_10018A0C0;
  v15[3] = &unk_100305720;
  v15[4] = WeakRetained;
  id v10 = v6;
  id v16 = v10;
  id v11 = v7;
  id v17 = v11;
  [v9 dispatchSyncWithReadOnlySQLTransaction:v15];

  if ([v11 count])
  {
    id v12 = sub_1000CD884(@"ckkskey", 0);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v19 = v11;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Resetting zones due to missing TLKs: %@", buf, 0xCu);
    }

    id v13 = [WeakRetained operationDependencies];
    [v13 operateOnSelectViews:v11];

    uint64_t v14 = off_1003056E0;
  }
  else
  {
    uint64_t v14 = (__CFString **)(a1 + 32);
  }
  [v3 setNextState:*v14];
}

void sub_10018A0C0(uint64_t a1)
{
  long long v30 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  uint64_t v1 = [*(id *)(a1 + 32) operationDependencies];
  uint64_t v2 = [v1 activeManagedViews];

  id v3 = [v2 countByEnumeratingWithState:&v30 objects:v36 count:16];
  if (v3)
  {
    id v4 = v3;
    uint64_t v5 = *(void *)v31;
    do
    {
      uint64_t v6 = 0;
      do
      {
        if (*(void *)v31 != v5) {
          objc_enumerationMutation(v2);
        }
        uint64_t v7 = *(void **)(*((void *)&v30 + 1) + 8 * (void)v6);
        uint64_t v8 = [v7 viewKeyHierarchyState];
        unsigned int v9 = [v8 isEqualToString:@"tlkmissing"];

        if (v9)
        {
          id v10 = [v7 zoneID];
          id v11 = [v7 contextID];
          id v12 = +[CKKSCurrentKeySet loadForZone:v10 contextID:v11];

          id v13 = [v12 error];

          if (v13)
          {
            uint64_t v14 = [v7 zoneID];
            uint64_t v15 = [v14 zoneName];
            id v16 = sub_1000CD884(@"ckkskey", v15);

            if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            {
              id v17 = [v12 error];
              *(_DWORD *)long long buf = 138412290;
              uint64_t v35 = v17;
              _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Unable to load keyset: %@", buf, 0xCu);
            }
            CFStringRef v18 = @"error";
          }
          else
          {
            id v19 = [v12 currentTLKPointer];
            id v20 = [v19 currentKeyUUID];

            if (v20)
            {
              if ([*(id *)(a1 + 32) trustStatus] == (id)1)
              {
                unsigned __int8 v21 = [*(id *)(a1 + 32) _onqueueOtherDevicesReportHavingTLKs:v12 trustStates:*(void *)(a1 + 40)];
                CFStringRef v18 = @"waitfortlk";
                if ((v21 & 1) == 0)
                {
                  uint64_t v22 = [v7 zoneID:@"waitfortlk"];
                  BOOL v23 = [v22 zoneName];
                  uint64_t v24 = sub_1000CD884(@"ckkskey", v23);

                  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_WORD *)long long buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "No other devices claim to have the TLK. Resetting zone...", buf, 2u);
                  }

                  [*(id *)(a1 + 48) addObject:v7];
                  CFStringRef v18 = @"resetzone";
                }
              }
              else
              {
                id v25 = [v7 zoneID];
                uint64_t v26 = [v25 zoneName];
                unsigned __int8 v27 = sub_1000CD884(@"ckkskey", v26);

                if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)long long buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "TLK is missing, but no trust is present.", buf, 2u);
                }

                CFStringRef v18 = @"waitfortrust";
              }
            }
            else
            {
              CFStringRef v18 = @"waitfortlkcreation";
            }
          }
          [v7 setViewKeyHierarchyState:v18];
        }
        uint64_t v6 = (char *)v6 + 1;
      }
      while (v4 != v6);
      id v28 = [v2 countByEnumeratingWithState:&v30 objects:v36 count:16];
      id v4 = v28;
    }
    while (v28);
  }
}

void sub_10018AE2C(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_10018AE48(uint64_t a1, void *a2)
{
  id v17 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if ([WeakRetained trustStatus] == (id)1)
  {
    [WeakRetained setTrustStatus:0];
    id v3 = objc_alloc_init(CKKSCondition);
    [WeakRetained setTrustStatusKnown:v3];
  }
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  id v4 = [WeakRetained operationDependencies:a1, v17];
  uint64_t v5 = [v4 views];

  id v6 = [v5 countByEnumeratingWithState:&v19 objects:v23 count:16];
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v20;
    do
    {
      for (CFIndex i = 0; i != v7; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v20 != v8) {
          objc_enumerationMutation(v5);
        }
        id v10 = *(void **)(*((void *)&v19 + 1) + 8 * i);
        id v11 = [v10 viewKeyHierarchyState];
        unsigned int v12 = [v11 isEqualToString:@"ready"];

        if (v12) {
          [v10 setViewKeyHierarchyState:@"waitfortrust"];
        }
      }
      id v7 = [v5 countByEnumeratingWithState:&v19 objects:v23 count:16];
    }
    while (v7);
  }

  id v13 = [WeakRetained priorityViewsProcessed];
  uint64_t v14 = +[NSError errorWithDomain:@"CKKSErrorDomain" code:52 description:@"Trust not present"];
  [v13 completeWithErrorIfPending:v14];

  [v18 setNextState:*(void *)(v16 + 32)];
}

void sub_10018B158(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_10018B174(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472;
  v20[2] = sub_10018B3E4;
  v20[3] = &unk_100305720;
  v20[4] = WeakRetained;
  id v5 = v3;
  id v21 = v5;
  id v22 = *(id *)(a1 + 32);
  [WeakRetained dispatchSyncWithReadOnlySQLTransaction:v20];
  id v6 = [WeakRetained operationDependencies];
  if ([v6 sendMetric])
  {

    id v7 = +[OTManager manager];
    id v8 = objc_alloc((Class)OTControlArguments);
    unsigned int v9 = [WeakRetained operationDependencies];
    id v10 = [v9 activeAccount];
    id v11 = [v10 altDSID];
    id v12 = [v8 initWithAltDSID:v11];
    id v19 = 0;
    unsigned int v13 = [v7 persistSendingMetricsPermitted:v12 sendingMetricsPermitted:0 error:&v19];
    id v6 = v19;

    if (!v13 || v6)
    {
      uint64_t v14 = sub_1000CD884(@"ckks", 0);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        id v24 = v6;
        uint64_t v15 = "Error persisting sendingMetricsPermitted value: %@";
        uint64_t v16 = v14;
        os_log_type_t v17 = OS_LOG_TYPE_ERROR;
        uint32_t v18 = 12;
        goto LABEL_8;
      }
    }
    else
    {
      uint64_t v14 = sub_10000B070("ckks");
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        uint64_t v15 = "Successfully persisted state to disable metrics";
        uint64_t v16 = v14;
        os_log_type_t v17 = OS_LOG_TYPE_DEFAULT;
        uint32_t v18 = 2;
LABEL_8:
        _os_log_impl((void *)&_mh_execute_header, v16, v17, v15, buf, v18);
      }
    }
  }
}

void sub_10018B3E4(uint64_t a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = [*(id *)(a1 + 32) operationDependencies];
  id v3 = [v2 readyAndSyncingViews];

  long long v337 = 0u;
  long long v338 = 0u;
  long long v335 = 0u;
  long long v336 = 0u;
  id v4 = [*(id *)(v1 + 32) operationDependencies];
  id v5 = [v4 views];

  id v6 = v5;
  id v7 = [v5 countByEnumeratingWithState:&v335 objects:v352 count:16];
  uint64_t v291 = v1;
  v287 = v3;
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v336;
    do
    {
      for (CFIndex i = 0; i != v8; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v336 != v9) {
          objc_enumerationMutation(v6);
        }
        id v11 = *(NSObject **)(*((void *)&v335 + 1) + 8 * i);
        id v12 = [*(id *)(v1 + 32) operationDependencies];
        unsigned int v13 = [v12 contextID];
        uint64_t v14 = [v11 zoneName];
        uint64_t v15 = +[CKKSZoneStateEntry contextID:v13 zoneName:v14];

        if (![(__CFString *)v15 ckzonecreated]
          || ([(__CFString *)v15 ckzonesubscribed] & 1) == 0)
        {
          id v63 = [v11 zoneID];
          BOOL v64 = [v63 zoneName];
          id v65 = sub_1000CD884(@"ckkszone", v64);

          if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138412546;
            v349 = v11;
            __int16 v350 = 2112;
            CFStringRef v351 = v15;
            _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "Zone does not yet exist: %@ %@", buf, 0x16u);
          }

          [*(id *)(v291 + 40) setNextState:@"initializing"];
          id v3 = v287;
          goto LABEL_54;
        }

        uint64_t v1 = v291;
      }
      id v8 = [v6 countByEnumeratingWithState:&v335 objects:v352 count:16];
      id v3 = v287;
    }
    while (v8);
  }

  long long v333 = 0u;
  long long v334 = 0u;
  long long v331 = 0u;
  long long v332 = 0u;
  uint64_t v16 = v3;
  id v17 = [v16 countByEnumeratingWithState:&v331 objects:v347 count:16];
  if (v17)
  {
    p_cache = OTDetermineCDPCapableAccountStatusOperation.cache;
    uint64_t v19 = *(void *)v332;
    v278 = v16;
    uint64_t v268 = *(void *)v332;
    do
    {
      uint64_t v20 = 0;
      id v270 = v17;
      do
      {
        if (*(void *)v332 != v19) {
          objc_enumerationMutation(v16);
        }
        uint64_t v275 = v20;
        id v21 = *(void **)(*((void *)&v331 + 1) + 8 * v20);
        id v22 = [*(id *)(v1 + 32) operationDependencies];
        BOOL v23 = [v22 contextID];
        id v24 = [v21 zoneID];
        id v330 = 0;
        id v25 = [p_cache + 288 countNewEntriesByKeyWithContextID:v23 zoneID:v24 error:&v330];
        id v281 = v330;

        if ([v25 count])
        {
          uint64_t v26 = [v21 zoneID];
          unsigned __int8 v27 = [v26 zoneName];
          id v28 = sub_1000CD884(@"ckksincoming", v27);

          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138412290;
            v349 = v25;
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Incoming Queue item counts: %@", buf, 0xCu);
          }
        }
        long long v328 = 0u;
        long long v329 = 0u;
        long long v326 = 0u;
        long long v327 = 0u;
        uint64_t v29 = v25;
        id v30 = [v29 countByEnumeratingWithState:&v326 objects:v346 count:16];
        if (v30)
        {
          id v31 = v30;
          uint64_t v32 = *(void *)v327;
          id obj = v29;
          do
          {
            for (j = 0; j != v31; j = (char *)j + 1)
            {
              if (*(void *)v327 != v32) {
                objc_enumerationMutation(obj);
              }
              uint64_t v34 = *(NSObject **)(*((void *)&v326 + 1) + 8 * (void)j);
              uint64_t v35 = [v21 contextID];
              uint64_t v36 = [v21 zoneID];
              id v325 = 0;
              __int16 v37 = +[CKKSKey fromDatabase:v34 contextID:v35 zoneID:v36 error:&v325];
              uint64_t v38 = (__CFString *)v325;

              if (v37) {
                BOOL v39 = v38 == 0;
              }
              else {
                BOOL v39 = 0;
              }
              if (v39)
              {
                uint64_t v43 = [v37 keyclass];
                if (([v43 isEqualToString:@"classA"] & 1) == 0)
                {

LABEL_52:
                  [*(id *)(v291 + 40) setNextState:@"process_incoming_queue"];

                  id v3 = v287;
                  uint64_t v29 = obj;
                  id v53 = obj;
                  id v6 = v278;
LABEL_53:

                  goto LABEL_54;
                }
                id v44 = [*(id *)(v291 + 32) lockStateTracker];
                unsigned int v45 = [v44 isLocked];

                if (!v45) {
                  goto LABEL_52;
                }
                id v46 = [v21 zoneID];
                unsigned __int8 v47 = [v46 zoneName];
                signed int v48 = sub_1000CD884(@"ckksincoming", v47);

                if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
                {
                  *(_WORD *)long long buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "Have pending classA items for view, but device is locked", buf, 2u);
                }

                BOOL v42 = [[OctagonPendingFlag alloc] initWithFlag:@"check_queues" conditions:1];
                id v49 = [*(id *)(v291 + 32) stateMachine];
                [v49 _onqueueHandlePendingFlagLater:v42];
              }
              else
              {
                uint64_t v40 = [v21 zoneID];
                id v41 = [v40 zoneName];
                sub_1000CD884(@"ckksincoming", v41);
                BOOL v42 = (OctagonPendingFlag *)objc_claimAutoreleasedReturnValue();

                if (os_log_type_enabled(&v42->super, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)long long buf = 138412546;
                  v349 = v34;
                  __int16 v350 = 2112;
                  CFStringRef v351 = v38;
                  _os_log_impl((void *)&_mh_execute_header, &v42->super, OS_LOG_TYPE_ERROR, "Unable to load key for %@: %@", buf, 0x16u);
                }
              }
            }
            uint64_t v29 = obj;
            id v31 = [obj countByEnumeratingWithState:&v326 objects:v346 count:16];
          }
          while (v31);
        }

        unsigned __int8 v50 = [v21 contextID];
        id v51 = [v21 zoneID];
        id v324 = 0;
        uint64_t v52 = +[CKKSCurrentItemPointer countByState:@"new" contextID:v50 zone:v51 error:&v324];
        id v53 = v324;

        if (v52 >= 1)
        {
          id v178 = [v21 zoneID];
          id v179 = [v178 zoneName];
          id v180 = sub_1000CD884(@"ckksincoming", v179);

          id v3 = v287;
          id v6 = v278;
          if (os_log_type_enabled(v180, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            LODWORD(v349) = v52;
            _os_log_impl((void *)&_mh_execute_header, v180, OS_LOG_TYPE_DEFAULT, "Incoming Queue CIP count: %d", buf, 8u);
          }

          [*(id *)(v291 + 40) setNextState:@"process_incoming_queue"];
          goto LABEL_53;
        }
        id v54 = v29;
        id v3 = v287;
        uint64_t v1 = v291;
        uint64_t v16 = v278;
        if (v53)
        {
          id v55 = [v21 zoneID];
          id v56 = [v55 zoneName];
          long long v57 = sub_1000CD884(@"ckksincoming", v56);

          if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138412290;
            v349 = v53;
            _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_ERROR, "Unable to count CIPs: %@", buf, 0xCu);
          }
        }
        uint64_t v20 = v275 + 1;
        p_cache = (void **)(OTDetermineCDPCapableAccountStatusOperation + 16);
        uint64_t v19 = v268;
      }
      while ((id)(v275 + 1) != v270);
      id v17 = [v278 countByEnumeratingWithState:&v331 objects:v347 count:16];
    }
    while (v17);
  }

  uint64_t v58 = [*(id *)(v1 + 32) operationDependencies];
  long long v59 = [v58 allViews];
  id v6 = [v59 mutableCopy];

  long long v60 = [*(id *)(v1 + 32) operationDependencies];
  CFStringRef v61 = [v60 views];
  [v6 minusSet:v61];

  if ([v6 count])
  {
    CFStringRef v62 = sub_1000CD884(@"ckkszone", 0);
    if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      v349 = v6;
      _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "Beginning again to include these views: %@", buf, 0xCu);
    }

    [*(id *)(v1 + 40) setNextState:@"handle_all_views"];
    goto LABEL_54;
  }
  v264 = v6;
  id v66 = objc_alloc((Class)AAFAnalyticsEventSecurity);
  id v67 = [*(id *)(v1 + 32) operationDependencies];
  v68 = [v67 activeAccount];
  id v69 = [v68 altDSID];
  uint64_t v70 = kSecurityRTCEventNameLocalSyncFinish;
  id v71 = v16;
  uint64_t v72 = kSecurityRTCEventCategoryAccountDataAccessRecovery;
  CFNumberRef v73 = [*(id *)(v291 + 32) operationDependencies];
  id v74 = [v73 sendMetric];
  uint64_t v75 = v70;
  uint64_t v76 = v291;
  uint64_t v263 = v72;
  id v77 = [v66 initWithCKKSMetrics:&__NSDictionary0__struct altDSID:v69 eventName:v75 testsAreEnabled:0 category:v72 sendMetric:v74];

  v265 = v77;
  +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v77 success:1 error:0];
  long long v322 = 0u;
  long long v323 = 0u;
  long long v320 = 0u;
  long long v321 = 0u;
  id v78 = v71;
  id v271 = [v78 countByEnumeratingWithState:&v320 objects:v345 count:16];
  v266 = v78;
  if (v271)
  {
    uint64_t v273 = *(void *)v321;
    do
    {
      uint64_t v79 = 0;
      do
      {
        if (*(void *)v321 != v273) {
          objc_enumerationMutation(v78);
        }
        uint64_t v276 = v79;
        uint64_t v80 = *(NSObject **)(*((void *)&v320 + 1) + 8 * v79);
        id v81 = [*(id *)(v76 + 32) operationDependencies];
        uint64_t v82 = [v81 contextID];
        CFStringRef v83 = [v80 zoneID];
        id v319 = 0;
        v279 = +[CKKSOutgoingQueueEntry allInState:@"reencrypt" contextID:v82 zoneID:v83 error:&v319];
        uint64_t v84 = v319;

        v282 = v84;
        if (v84)
        {
          id v85 = [v80 zoneID];
          id v86 = [v85 zoneName];
          char v87 = sub_1000CD884(@"ckks", v86);

          if (os_log_type_enabled(v87, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138412290;
            v349 = v282;
            _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_ERROR, "Couldn't count reencrypt OQEs, bad behavior ahead: %@", buf, 0xCu);
          }
        }
        id v88 = [v80 viewKeyHierarchyState];
        unsigned __int8 v89 = [v88 isEqualToString:@"ready"];

        if (v89)
        {
          uint64_t v90 = [*(id *)(v291 + 32) operationDependencies];
          id v91 = [v90 syncingPolicy];
          long long v92 = [v80 zoneID];
          uint64_t v93 = [v92 zoneName];
          unsigned __int8 v94 = [v91 isSyncingEnabledForView:v93];

          if (v94)
          {
            id v95 = v279;
            uint64_t v76 = v291;
            if (![v279 count]) {
              goto LABEL_94;
            }
            long long v317 = 0u;
            long long v318 = 0u;
            long long v315 = 0u;
            long long v316 = 0u;
            obja = v279;
            id v96 = [obja countByEnumeratingWithState:&v315 objects:v344 count:16];
            if (v96)
            {
              id v97 = v96;
              uint64_t v283 = *(void *)v316;
              while (1)
              {
                for (k = 0; k != v97; k = (char *)k + 1)
                {
                  if (*(void *)v316 != v283) {
                    objc_enumerationMutation(obja);
                  }
                  long long v99 = *(void **)(*((void *)&v315 + 1) + 8 * (void)k);
                  long long v100 = [v99 item];
                  long long v101 = [v100 parentKeyUUID];
                  long long v102 = [v80 contextID];
                  long long v103 = [v80 zoneID];
                  id v314 = 0;
                  long long v104 = +[CKKSKey fromDatabase:v101 contextID:v102 zoneID:v103 error:&v314];
                  long long v105 = (__CFString *)v314;

                  long long v106 = v104;
                  if (v104) {
                    BOOL v107 = v105 == 0;
                  }
                  else {
                    BOOL v107 = 0;
                  }
                  if (v107)
                  {
                    id v113 = [(__CFString *)v104 keyclass];
                    if (([v113 isEqualToString:@"classA"] & 1) == 0)
                    {

LABEL_113:
                      [*(id *)(v291 + 40) setNextState:@"reencrypt_outgoing_items"];
                      id v3 = v287;
                      uint64_t v150 = obja;
                      id v142 = obja;
                      id v6 = v264;
                      long long v151 = v266;
                      goto LABEL_210;
                    }
                    uint64_t v114 = [*(id *)(v291 + 32) lockStateTracker];
                    unsigned int v115 = [v114 isLocked];

                    if (!v115) {
                      goto LABEL_113;
                    }
                    CFStringRef v116 = [v80 zoneID];
                    __int16 v117 = [v116 zoneName];
                    CFStringRef v118 = sub_1000CD884(@"ckksoutgoing", v117);

                    if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_WORD *)long long buf = 0;
                      _os_log_impl((void *)&_mh_execute_header, v118, OS_LOG_TYPE_DEFAULT, "Have items needing re-encryption, but device is locked", buf, 2u);
                    }

                    v110 = [[OctagonPendingFlag alloc] initWithFlag:@"item_reencryption_needed" conditions:1];
                    v111 = [*(id *)(v291 + 32) stateMachine];
                    [v111 _onqueueHandlePendingFlagLater:v110];
                  }
                  else
                  {
                    long long v108 = [v80 zoneID];
                    long long v109 = [v108 zoneName];
                    sub_1000CD884(@"ckksoutgoing", v109);
                    v110 = (OctagonPendingFlag *)objc_claimAutoreleasedReturnValue();

                    if (!os_log_type_enabled(&v110->super, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_84;
                    }
                    v111 = [v99 item];
                    id v112 = [v111 parentKeyUUID];
                    *(_DWORD *)long long buf = 138412546;
                    v349 = v112;
                    __int16 v350 = 2112;
                    CFStringRef v351 = v105;
                    _os_log_impl((void *)&_mh_execute_header, &v110->super, OS_LOG_TYPE_ERROR, "Unable to load key for %@: %@", buf, 0x16u);
                  }
LABEL_84:
                }
                id v97 = [obja countByEnumeratingWithState:&v315 objects:v344 count:16];
                if (!v97)
                {
                  __int16 v119 = obja;
                  uint64_t v76 = v291;
                  id v78 = v266;
                  goto LABEL_89;
                }
              }
            }
            __int16 v119 = obja;
          }
          else
          {
            v122 = [v80 zoneID];
            id v123 = [v122 zoneName];
            __int16 v119 = sub_1000CD884(@"ckksincoming", v123);

            id v95 = v279;
            if (os_log_type_enabled(v119, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 138412290;
              v349 = v80;
              _os_log_impl((void *)&_mh_execute_header, v119, OS_LOG_TYPE_DEFAULT, "Syncing disabled for (%@): skipping incoming queue processing", buf, 0xCu);
            }
            uint64_t v76 = v291;
          }
        }
        else
        {
          uint64_t v120 = [v80 zoneID];
          long long v121 = [v120 zoneName];
          __int16 v119 = sub_1000CD884(@"ckksincoming", v121);

          uint64_t v76 = v291;
          if (os_log_type_enabled(v119, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138412290;
            v349 = v80;
            _os_log_impl((void *)&_mh_execute_header, v119, OS_LOG_TYPE_DEFAULT, "Zone not ready (%@): skipping reencryption", buf, 0xCu);
          }
LABEL_89:
          id v95 = v279;
        }

LABEL_94:
        uint64_t v79 = v276 + 1;
      }
      while ((id)(v276 + 1) != v271);
      id v124 = [v78 countByEnumeratingWithState:&v320 objects:v345 count:16];
      id v3 = v287;
      id v271 = v124;
    }
    while (v124);
  }

  uint64_t v125 = +[NSDate date];
  long long v126 = objc_alloc_init((Class)NSDateComponents);
  [v126 setHour:-24];
  long long v127 = +[NSCalendar currentCalendar];
  v282 = v126;
  v262 = (void *)v125;
  uint64_t v269 = [v127 dateByAddingComponents:v126 toDate:v125 options:0];

  long long v312 = 0u;
  long long v313 = 0u;
  long long v310 = 0u;
  long long v311 = 0u;
  long long v128 = [*(id *)(v76 + 32) operationDependencies];
  long long v129 = [v128 views];

  v272 = v129;
  id v130 = [v129 countByEnumeratingWithState:&v310 objects:v343 count:16];
  if (v130)
  {
    id v131 = v130;
    id v132 = v3;
    id v133 = 0;
    int8x16_t v134 = 0;
    uint64_t v284 = *(void *)v311;
    do
    {
      for (m = 0; m != v131; m = (char *)m + 1)
      {
        objb = v133;
        if (*(void *)v311 != v284) {
          objc_enumerationMutation(v272);
        }
        long long v136 = *(void **)(*((void *)&v310 + 1) + 8 * (void)m);
        uint64_t v137 = [*(id *)(v76 + 32) operationDependencies];
        uint64_t v138 = [v137 contextID];
        long long v139 = [v136 zoneName];
        int8x16_t v140 = +[CKKSZoneStateEntry contextID:v138 zoneName:v139];

        uint64_t v141 = [(__CFString *)v140 lastFetchTime];
        id v142 = (void *)v269;
        if (!v141) {
          goto LABEL_138;
        }
        uint64_t v143 = (void *)v141;
        uint64_t v144 = [(__CFString *)v140 lastFetchTime];
        if ([v144 compare:v269] == (id)-1)
        {

LABEL_138:
          id v181 = [(__CFString *)v140 lastFetchTime];

          v267 = v140;
          if (v181)
          {
            unsigned int v182 = [(__CFString *)v140 moreRecordsInCloudKit];
            uint64_t v183 = v291;
            v184 = [*(id *)(v291 + 32) operationDependencies];
            v185 = [v184 currentFetchReasons];
            id v186 = &off_100306E40;
            if (v182) {
              id v186 = off_100306E38;
            }
          }
          else
          {
            uint64_t v183 = v291;
            v184 = [*(id *)(v291 + 32) operationDependencies];
            v185 = [v184 currentFetchReasons];
            id v186 = off_100306E30;
          }
          long long v151 = v262;
          id v3 = v132;
          [v185 addObject:*v186];

          v187 = [v136 zoneID];
          __int16 v188 = [v187 zoneName];
          id v189 = sub_1000CD884(@"ckksfetch", v188);

          if (os_log_type_enabled(v189, OS_LOG_TYPE_DEFAULT))
          {
            v190 = [(__CFString *)v267 lastFetchTime];
            unsigned int v191 = [(__CFString *)v267 moreRecordsInCloudKit];
            CFStringRef v192 = @"complete";
            if (v191) {
              CFStringRef v192 = @"more coming";
            }
            *(_DWORD *)long long buf = 138412546;
            v349 = v190;
            __int16 v350 = 2112;
            CFStringRef v351 = v192;
            _os_log_impl((void *)&_mh_execute_header, v189, OS_LOG_TYPE_DEFAULT, "Fetch last occurred at %@ (%@); beginning a new one",
              buf,
              0x16u);
          }
          [*(id *)(v183 + 40) setNextState:@"begin_fetch"];
          id v6 = v264;
          long long v106 = v134;
          goto LABEL_209;
        }
        unsigned int v145 = [(__CFString *)v140 moreRecordsInCloudKit];

        if (v145) {
          goto LABEL_138;
        }
        if (!objb
          || ([(__CFString *)v140 lastFetchTime],
              int8x16_t v146 = objc_claimAutoreleasedReturnValue(),
              id v147 = [objb compare:v146],
              v146,
              v147 == (id)1))
        {
          uint64_t v148 = [(__CFString *)v140 lastFetchTime];

          uint64_t v149 = v136;
          objb = v148;
          int8x16_t v134 = v149;
        }
        uint64_t v76 = v291;

        id v133 = objb;
      }
      id v131 = [v272 countByEnumeratingWithState:&v310 objects:v343 count:16];
    }
    while (v131);
  }
  else
  {
    id v133 = 0;
    int8x16_t v134 = 0;
  }
  objb = v133;

  long long v152 = sub_1000CD884(@"ckksfetch", 0);
  if (os_log_type_enabled(v152, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412546;
    v349 = objb;
    __int16 v350 = 2112;
    CFStringRef v351 = v134;
    _os_log_impl((void *)&_mh_execute_header, v152, OS_LOG_TYPE_DEFAULT, "Fetch last occurred at %@ (for %@)", buf, 0x16u);
  }
  v261 = v134;

  long long v308 = 0u;
  long long v309 = 0u;
  long long v306 = 0u;
  long long v307 = 0u;
  id v153 = v266;
  id v154 = [v153 countByEnumeratingWithState:&v306 objects:v342 count:16];
  if (!v154)
  {
    v272 = 0;
    v267 = 0;
    goto LABEL_149;
  }
  id v155 = v154;
  v272 = 0;
  v267 = 0;
  uint64_t v156 = *(void *)v307;
LABEL_119:
  long long v157 = 0;
  while (1)
  {
    if (*(void *)v307 != v156) {
      objc_enumerationMutation(v153);
    }
    long long v158 = *(void **)(*((void *)&v306 + 1) + 8 * (void)v157);
    __int16 v159 = [*(id *)(v76 + 32) operationDependencies];
    long long v160 = [v159 contextID];
    __int16 v161 = [v158 zoneName];
    id v162 = +[CKKSZoneStateEntry contextID:v160 zoneName:v161];

    uint64_t v163 = [v162 lastLocalKeychainScanTime];
    if (!v163) {
      break;
    }
    id v164 = (void *)v163;
    __int16 v165 = [v162 lastLocalKeychainScanTime];
    id v166 = [v165 compare:v269];

    if (v166 == (id)-1) {
      break;
    }
    __int16 v167 = v272;
    if (!v272
      || ([v162 lastLocalKeychainScanTime],
          int v168 = objc_claimAutoreleasedReturnValue(),
          id v169 = [v272 compare:v168],
          v168,
          BOOL v39 = v169 == (id)1,
          __int16 v167 = v272,
          v39))
    {
      uint64_t v170 = [v162 lastLocalKeychainScanTime];

      id v171 = v158;
      v272 = v170;
      v267 = v171;
    }

    long long v157 = (char *)v157 + 1;
    uint64_t v76 = v291;
    if (v155 == v157)
    {
      id v155 = [v153 countByEnumeratingWithState:&v306 objects:v342 count:16];
      if (!v155)
      {
LABEL_149:

        id v193 = sub_1000CD884(@"ckksscan", 0);
        if (os_log_type_enabled(v193, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412546;
          v349 = v272;
          __int16 v350 = 2112;
          CFStringRef v351 = v267;
          _os_log_impl((void *)&_mh_execute_header, v193, OS_LOG_TYPE_DEFAULT, "CKKS scan last occurred at %@ (for %@)", buf, 0x16u);
        }

        long long v304 = 0u;
        long long v305 = 0u;
        long long v302 = 0u;
        long long v303 = 0u;
        id v285 = v153;
        id v194 = [v285 countByEnumeratingWithState:&v302 objects:v341 count:16];
        if (v194)
        {
          id v195 = v194;
          uint64_t v196 = *(void *)v303;
          do
          {
            v197 = 0;
            do
            {
              if (*(void *)v303 != v196) {
                objc_enumerationMutation(v285);
              }
              v198 = *(void **)(*((void *)&v302 + 1) + 8 * (void)v197);
              __int16 v199 = [*(id *)(v76 + 32) operationDependencies];
              v200 = [v199 contextID];
              __int16 v201 = [v198 zoneID];
              id v301 = 0;
              uint64_t v202 = +[CKKSOutgoingQueueEntry countByState:@"new" contextID:v200 zoneID:v201 error:&v301];
              v203 = v301;

              if (v202 >= 1)
              {
                v204 = [v198 zoneID];
                v205 = [v204 zoneName];
                v206 = sub_1000CD884(@"ckksoutgoing", v205);

                if (os_log_type_enabled(v206, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)long long buf = 67109120;
                  LODWORD(v349) = v202;
                  _os_log_impl((void *)&_mh_execute_header, v206, OS_LOG_TYPE_DEFAULT, "Have %d outgoing items; scheduling upload",
                    buf,
                    8u);
                }

                v207 = [[OctagonPendingFlag alloc] initWithFlag:@"process_outgoing_queue" conditions:2];
                uint64_t v76 = v291;
                v208 = [*(id *)(v291 + 32) stateMachine];
                [v208 _onqueueHandlePendingFlagLater:v207];

                v209 = [*(id *)(v291 + 32) outgoingQueueOperationScheduler];
                [v209 trigger];

LABEL_160:
                goto LABEL_161;
              }
              uint64_t v76 = v291;
              if (v203)
              {
                v210 = [v198 zoneID];
                v211 = [v210 zoneName];
                sub_1000CD884(@"ckksoutgoing", v211);
                v207 = (OctagonPendingFlag *)objc_claimAutoreleasedReturnValue();

                if (os_log_type_enabled(&v207->super, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)long long buf = 138412290;
                  v349 = v203;
                  _os_log_impl((void *)&_mh_execute_header, &v207->super, OS_LOG_TYPE_DEFAULT, "Error checking outgoing queue: %@", buf, 0xCu);
                }
                goto LABEL_160;
              }
LABEL_161:

              v197 = (char *)v197 + 1;
            }
            while (v195 != v197);
            id v212 = [v285 countByEnumeratingWithState:&v302 objects:v341 count:16];
            id v195 = v212;
          }
          while (v212);
        }

        long long v299 = 0u;
        long long v300 = 0u;
        long long v297 = 0u;
        long long v298 = 0u;
        v213 = [*(id *)(v76 + 32) operationDependencies];
        v214 = [v213 allCKKSManagedViews];

        id v215 = [v214 countByEnumeratingWithState:&v297 objects:v340 count:16];
        if (v215)
        {
          id v216 = v215;
          id v153 = 0;
          int64_t v217 = 0;
          uint64_t v218 = *(void *)v298;
          v277 = v214;
          uint64_t v274 = *(void *)v298;
          do
          {
            v219 = 0;
            id v286 = v216;
            do
            {
              if (*(void *)v298 != v218) {
                objc_enumerationMutation(v214);
              }
              v220 = *(void **)(*((void *)&v297 + 1) + 8 * (void)v219);
              v221 = [v220 launch];
              unsigned __int8 v222 = [v221 launched];

              if ((v222 & 1) == 0)
              {
                if (!v153)
                {
                  v223 = [*(id *)(v291 + 32) operationDependencies];
                  v224 = [v223 contextID];
                  id v296 = 0;
                  id v153 = +[CKKSMirrorEntry countsByZoneNameWithContextID:v224 error:&v296];
                  v225 = v296;

                  if (v225)
                  {
                    v226 = [v220 zoneID];
                    v227 = [v226 zoneName];
                    v228 = sub_1000CD884(@"launch", v227);

                    if (os_log_type_enabled(v228, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)long long buf = 138412290;
                      v349 = v225;
                      _os_log_impl((void *)&_mh_execute_header, v228, OS_LOG_TYPE_ERROR, "Unable to count mirror entries: %@", buf, 0xCu);
                    }
                  }
                  v280 = v225;
                  long long v294 = 0u;
                  long long v295 = 0u;
                  long long v292 = 0u;
                  long long v293 = 0u;
                  v229 = [v153 allKeys];
                  id v230 = [v229 countByEnumeratingWithState:&v292 objects:v339 count:16];
                  if (v230)
                  {
                    id v231 = v230;
                    uint64_t v232 = *(void *)v293;
                    do
                    {
                      for (n = 0; n != v231; n = (char *)n + 1)
                      {
                        if (*(void *)v293 != v232) {
                          objc_enumerationMutation(v229);
                        }
                        v234 = [v153 objectForKeyedSubscript:*(void *)(*((void *)&v292 + 1) + 8 * (void)n)];
                        v217 += (int64_t)[v234 longValue];
                      }
                      id v231 = [v229 countByEnumeratingWithState:&v292 objects:v339 count:16];
                    }
                    while (v231);
                  }

                  v214 = v277;
                  uint64_t v218 = v274;
                }
                v235 = [v220 zoneName];
                v236 = [v153 objectForKeyedSubscript:v235];

                if (v236)
                {
                  int64_t v237 = (int64_t)[v236 longValue];
                  uint64_t v238 = 1;
                  if (v237 >= 11)
                  {
                    unint64_t v239 = v237;
                    do
                    {
                      int64_t v237 = v239 / 0xA;
                      v238 *= 10;
                      BOOL v240 = v239 > 0x6D;
                      v239 /= 0xAuLL;
                    }
                    while (v240);
                  }
                  v241 = +[NSNumber numberWithLongLong:v238 * v237];

                  v242 = [v220 launch];
                  [v242 addAttribute:@"zonesize" value:v241];

                  v243 = [v220 launch];
                  if (v217 < 11)
                  {
                    unint64_t v246 = v217;
                    uint64_t v244 = 1;
                    id v216 = v286;
                  }
                  else
                  {
                    uint64_t v244 = 1;
                    unint64_t v245 = v217;
                    id v216 = v286;
                    do
                    {
                      unint64_t v246 = v245 / 0xA;
                      v244 *= 10;
                      BOOL v240 = v245 > 0x6D;
                      v245 /= 0xAuLL;
                    }
                    while (v240);
                  }
                  v247 = +[NSNumber numberWithLongLong:v244 * v246];
                  [v243 addAttribute:@"totalsize" value:v247];
                }
                else
                {
                  id v216 = v286;
                }
              }
              v219 = (char *)v219 + 1;
            }
            while (v219 != v216);
            id v216 = [v214 countByEnumeratingWithState:&v297 objects:v340 count:16];
          }
          while (v216);

          if (v153)
          {
            uint64_t v76 = v291;
            v214 = [*(id *)(v291 + 32) operationDependencies];
            v248 = [v214 overallLaunch];
            v249 = &SecPolicyXPCArrayCopyArray_ptr;
            uint64_t v250 = 1;
            if (v217 >= 11)
            {
              unint64_t v251 = v217;
              do
              {
                int64_t v217 = v251 / 0xA;
                v250 *= 10;
                BOOL v240 = v251 > 0x6D;
                v251 /= 0xAuLL;
              }
              while (v240);
            }
            v252 = +[NSNumber numberWithLongLong:v250 * v217];
            [v248 addAttribute:@"totalsize" value:v252];

LABEL_205:
            id v3 = v287;
          }
          else
          {
            id v3 = v287;
            uint64_t v76 = v291;
            v249 = &SecPolicyXPCArrayCopyArray_ptr;
          }
          id v253 = objc_alloc((Class)v249[430]);
          v254 = [*(id *)(v76 + 32) operationDependencies];
          v255 = [v254 activeAccount];
          v256 = [v255 altDSID];
          uint64_t v257 = kSecurityRTCEventNameContentSyncFinish;
          v258 = [*(id *)(v291 + 32) operationDependencies];
          id v259 = [v258 sendMetric];
          uint64_t v260 = v257;
          uint64_t v177 = v291;
          id v162 = [v253 initWithCKKSMetrics:&__NSDictionary0__struct altDSID:v256 eventName:v260 testsAreEnabled:0 category:v263 sendMetric:v259];

          +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v162 success:1 error:0];
          id v176 = (__CFString **)(v291 + 48);
          goto LABEL_208;
        }
        id v153 = 0;
        v249 = &SecPolicyXPCArrayCopyArray_ptr;
        goto LABEL_205;
      }
      goto LABEL_119;
    }
  }
  id v172 = [v158 zoneID];
  id v173 = [v172 zoneName];
  id v174 = sub_1000CD884(@"ckksscan", v173);

  if (os_log_type_enabled(v174, OS_LOG_TYPE_DEFAULT))
  {
    id v175 = [v162 lastLocalKeychainScanTime];
    *(_DWORD *)long long buf = 138412290;
    v349 = v175;
    _os_log_impl((void *)&_mh_execute_header, v174, OS_LOG_TYPE_DEFAULT, "CKKS scan last occurred at %@; beginning a new one",
      buf,
      0xCu);
  }
  id v176 = &off_100305710;
  id v3 = v287;
  uint64_t v177 = v291;
LABEL_208:
  id v6 = v264;
  long long v151 = v262;
  [*(id *)(v177 + 40) setNextState:*v176];

  long long v106 = v261;
  id v142 = (void *)v269;
LABEL_209:

  uint64_t v150 = objb;
LABEL_210:

LABEL_54:
}

void sub_100190090(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)&STACK[0x220]);
  _Unwind_Resume(a1);
}

void sub_100190114(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = [WeakRetained operationDependencies];
  [v2 operateOnAllViews];

  id v3 = sub_1000CD884(@"ckksview", 0);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    id v4 = [WeakRetained operationDependencies];
    id v5 = [v4 views];
    *(_DWORD *)long long buf = 138412290;
    id v21 = v5;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Now operating on these views: %@", buf, 0xCu);
  }
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  id v6 = [WeakRetained operationDependencies];
  id v7 = [v6 allViews];

  id v8 = [v7 countByEnumeratingWithState:&v15 objects:v19 count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v16;
    do
    {
      id v11 = 0;
      do
      {
        if (*(void *)v16 != v10) {
          objc_enumerationMutation(v7);
        }
        id v12 = [*(id *)(*((void *)&v15 + 1) + 8 * (void)v11) launch];
        [v12 addEvent:@"priority-complete"];

        id v11 = (char *)v11 + 1;
      }
      while (v9 != v11);
      id v9 = [v7 countByEnumeratingWithState:&v15 objects:v19 count:16];
    }
    while (v9);
  }

  unsigned int v13 = [WeakRetained operationDependencies];
  uint64_t v14 = [v13 overallLaunch];
  [v14 addEvent:@"priority-complete"];
}

void sub_100190310(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v1 = [WeakRetained stateMachine];
  [v1 handleFlag:@"fetch_complete"];
}

void sub_100190370(uint64_t a1, void *a2)
{
  uint64_t v2 = (id *)(a1 + 32);
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained(v2);
  id v5 = [WeakRetained operationDependencies];
  [v5 operateOnAllViews];

  id v6 = sub_1000CD884(@"ckksview", 0);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    id v7 = [WeakRetained operationDependencies];
    id v8 = [v7 views];
    int v10 = 138412290;
    id v11 = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "After trust failure, operating on these views: %@", (uint8_t *)&v10, 0xCu);
  }
  id v9 = [v3 intendedState];
  [v3 setNextState:v9];
}

void sub_100190A40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id *location, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id a23)
{
}

id sub_100190A7C(uint64_t a1, void *a2)
{
  return [a2 setError:*(void *)(a1 + 32)];
}

void sub_100190A88(uint64_t a1, void *a2)
{
  id v3 = (id *)(a1 + 40);
  id v4 = a2;
  id WeakRetained = objc_loadWeakRetained(v3);
  id v6 = WeakRetained;
  if (*(void *)(a1 + 32))
  {
    id v7 = [WeakRetained zoneName];
    id v8 = sub_1000CD884(@"ckksreset", v7);

    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      id v9 = *(void **)(a1 + 32);
      int v20 = 138412290;
      id v21 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Restricting cloudkit zone reset to a view subset %@", (uint8_t *)&v20, 0xCu);
    }

    int v10 = [v6 operationDependencies];
    id v11 = [v10 viewStatesByNames:*(void *)(a1 + 32)];
  }
  else
  {
    id v12 = [WeakRetained operationDependencies];
    id v11 = [v12 activeManagedViews];

    unsigned int v13 = [v6 zoneName];
    int v10 = sub_1000CD884(@"ckksreset", v13);

    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v20 = 138412290;
      id v21 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Restricting cloudkit zone reset to active CKKS-managed subset %@", (uint8_t *)&v20, 0xCu);
    }
  }

  uint64_t v14 = [v6 operationDependencies];
  [v14 operateOnSelectViews:v11];

  long long v15 = [v6 zoneName];
  long long v16 = sub_1000CD884(@"ckksreset", v15);

  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    long long v17 = [v6 operationDependencies];
    long long v18 = [v17 views];
    int v20 = 138412290;
    id v21 = v18;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Beginning cloudkit zone reset for %@", (uint8_t *)&v20, 0xCu);
  }
  uint64_t v19 = [v4 intendedState];
  [v4 setNextState:v19];
}

void sub_10019108C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id *location, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,id a21)
{
}

void sub_1001910C8(uint64_t a1, void *a2)
{
  id v3 = (id *)(a1 + 40);
  id v4 = a2;
  id WeakRetained = objc_loadWeakRetained(v3);
  id v6 = WeakRetained;
  if (*(void *)(a1 + 32))
  {
    id v7 = [WeakRetained zoneName];
    id v8 = sub_1000CD884(@"ckksreset", v7);

    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      id v9 = *(void **)(a1 + 32);
      int v18 = 138412290;
      uint64_t v19 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Restricting local data reset to a view subset %@", (uint8_t *)&v18, 0xCu);
    }

    int v10 = [v6 operationDependencies];
    id v11 = [v10 viewStatesByNames:*(void *)(a1 + 32)];

    id v12 = [v6 operationDependencies];
    [v12 operateOnSelectViews:v11];
  }
  unsigned int v13 = [v6 zoneName];
  uint64_t v14 = sub_1000CD884(@"ckksreset", v13);

  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    long long v15 = [v6 operationDependencies];
    long long v16 = [v15 views];
    int v18 = 138412290;
    uint64_t v19 = v16;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Beginning local data reset for %@", (uint8_t *)&v18, 0xCu);
  }
  long long v17 = [v4 intendedState];
  [v4 setNextState:v17];
}

void sub_1001913AC(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 24));
  _Unwind_Resume(a1);
}

void sub_1001913C8(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_100191470;
  v6[3] = &unk_100305670;
  void v6[4] = WeakRetained;
  id v7 = v3;
  id v5 = v3;
  [WeakRetained dispatchSyncWithSQLTransaction:v6];
}

uint64_t sub_100191470(uint64_t a1)
{
  uint64_t v2 = +[NSMutableArray array];
  long long v111 = 0u;
  long long v112 = 0u;
  long long v113 = 0u;
  long long v114 = 0u;
  uint64_t v97 = a1;
  id v3 = [*(id *)(a1 + 32) operationDependencies];
  id v4 = [v3 views];

  id v5 = [v4 countByEnumeratingWithState:&v111 objects:v120 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v112;
    do
    {
      for (CFIndex i = 0; i != v6; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v112 != v7) {
          objc_enumerationMutation(v4);
        }
        id v9 = *(void **)(*((void *)&v111 + 1) + 8 * i);
        int v10 = [*(id *)(v97 + 32) operationDependencies];
        id v11 = [v10 contextID];
        id v12 = [v9 zoneID];
        unsigned int v13 = [v12 zoneName];
        uint64_t v14 = +[CKKSZoneStateEntry contextID:v11 zoneName:v13];

        [v2 addObject:v14];
      }
      id v6 = [v4 countByEnumeratingWithState:&v111 objects:v120 count:16];
    }
    while (v6);
  }

  long long v109 = 0u;
  long long v110 = 0u;
  long long v107 = 0u;
  long long v108 = 0u;
  id v15 = v2;
  id v16 = [v15 countByEnumeratingWithState:&v107 objects:v119 count:16];
  if (v16)
  {
    id v17 = v16;
    char v18 = 0;
    int v94 = 0;
    uint64_t v19 = *(void *)v108;
    do
    {
      for (j = 0; j != v17; j = (char *)j + 1)
      {
        if (*(void *)v108 != v19) {
          objc_enumerationMutation(v15);
        }
        id v21 = *(void **)(*((void *)&v107 + 1) + 8 * (void)j);
        if (([v21 ckzonecreated] & 1) == 0)
        {
          long long v33 = [*(id *)(v97 + 32) zoneName];
          uint64_t v34 = sub_1000CD884(@"ckks", v33);

          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138412290;
            id v118 = v21;
            _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Zone does not exist(%@); going to restart operation",
              buf,
              0xCu);
          }

          [*(id *)(v97 + 40) setNextState:@"initializing"];
          goto LABEL_83;
        }
        id v22 = [v21 getChangeToken];
        BOOL v23 = v22 == 0;

        if ([v21 moreRecordsInCloudKit])
        {
          id v24 = v15;
          id v25 = [*(id *)(v97 + 32) zoneName];
          uint64_t v26 = sub_1000CD884(@"ckks", v25);

          if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "CloudKit reports there's more records to fetch!", buf, 2u);
          }

          int v94 = 1;
          id v15 = v24;
        }
        v18 |= v23;
      }
      id v17 = [v15 countByEnumeratingWithState:&v107 objects:v119 count:16];
    }
    while (v17);

    if (v18)
    {
      unsigned __int8 v27 = +[CKOperationGroup CKKSGroupWithName:@"initial-setup"];
      id v28 = [*(id *)(v97 + 32) operationDependencies];
      [v28 setCkoperationGroup:v27];

      uint64_t v29 = [*(id *)(v97 + 32) zoneName];
      id v30 = sub_1000CD884(@"ckks", v29);

      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "No existing change token; going to try to match local items with CloudKit ones.",
          buf,
          2u);
      }

      id v31 = [*(id *)(v97 + 32) operationDependencies];
      uint64_t v32 = [v31 currentFetchReasons];
      [v32 addObject:@"initialfetch"];

      [*(id *)(v97 + 40) setNextState:@"begin_fetch"];
      goto LABEL_83;
    }
  }
  else
  {

    int v94 = 0;
  }
  long long v105 = 0u;
  long long v106 = 0u;
  long long v103 = 0u;
  long long v104 = 0u;
  id v35 = v15;
  id v36 = [v35 countByEnumeratingWithState:&v103 objects:v116 count:16];
  if (v36)
  {
    id v37 = v36;
    uint64_t v38 = *(void *)v104;
    unint64_t v39 = 5;
    do
    {
      for (k = 0; k != v37; k = (char *)k + 1)
      {
        if (*(void *)v104 != v38) {
          objc_enumerationMutation(v35);
        }
        id v41 = *(void **)(*((void *)&v103 + 1) + 8 * (void)k);
        if ((unint64_t)[v41 lastFixup] < v39) {
          unint64_t v39 = (unint64_t)[v41 lastFixup];
        }
      }
      id v37 = [v35 countByEnumeratingWithState:&v103 objects:v116 count:16];
    }
    while (v37);
  }
  else
  {
    unint64_t v39 = 5;
  }

  BOOL v42 = +[CKKSFixups fixupOperation:v39];
  uint64_t v43 = *(void **)(v97 + 32);
  if (v42)
  {
    id v44 = [v43 zoneName];
    unsigned int v45 = sub_1000CD884(@"ckksfixup", v44);

    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
    {
      id v46 = [*(id *)(v97 + 32) lastFixupOperation];
      *(_DWORD *)long long buf = 138412290;
      id v118 = v46;
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "We have a fixup to perform: %@", buf, 0xCu);
    }
    [*(id *)(v97 + 40) setNextState:v42];
    goto LABEL_82;
  }
  id v102 = 0;
  [v43 _onqueueResetAllInflightOQE:&v102];
  id v47 = v102;
  if (v47)
  {
    signed int v48 = [*(id *)(v97 + 32) zoneName];
    id v49 = sub_1000CD884(@"ckks", v48);

    if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      id v118 = v47;
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, "Couldn't reset in-flight OQEs, bad behavior ahead: %@", buf, 0xCu);
    }
  }
  id v92 = v47;
  id v93 = v15;
  unsigned __int8 v50 = +[CKOperationGroup CKKSGroupWithName:@"restart-setup"];
  id v51 = [*(id *)(v97 + 32) operationDependencies];
  [v51 setCkoperationGroup:v50];

  uint64_t v52 = +[CKOperationGroup CKKSGroupWithName:@"restart-setup"];
  id v53 = [*(id *)(v97 + 32) operationDependencies];
  [v53 setCurrentOutgoingQueueOperationGroup:v52];

  long long v100 = 0u;
  long long v101 = 0u;
  long long v98 = 0u;
  long long v99 = 0u;
  id v54 = [*(id *)(v97 + 32) operationDependencies];
  id v55 = [v54 activeManagedViews];

  id v95 = v55;
  id v56 = [v55 countByEnumeratingWithState:&v98 objects:v115 count:16];
  if (!v56)
  {
    LODWORD(v58) = 0;
    goto LABEL_74;
  }
  id v57 = v56;
  uint64_t v58 = 0;
  id obj = *(id *)v99;
  do
  {
    for (m = 0; m != v57; m = (char *)m + 1)
    {
      if (*(id *)v99 != obj) {
        objc_enumerationMutation(v95);
      }
      long long v60 = *(void **)(*((void *)&v98 + 1) + 8 * (void)m);
      CFStringRef v61 = [v60 zoneID];
      CFStringRef v62 = [v60 contextID];
      id v63 = +[CKKSCurrentKeySet loadForZone:v61 contextID:v62];

      uint64_t v64 = [v63 error];
      if (v64)
      {
        id v65 = (void *)v64;
        id v66 = [v63 error];
        id v67 = [v66 domain];
        if ([v67 isEqual:@"securityd"])
        {
          [v63 error];
          id v69 = v68 = v58;
          id v70 = [v69 code];

          uint64_t v58 = v68;
          if (v70 == (id)-25300) {
            goto LABEL_60;
          }
        }
        else
        {
        }
        id v71 = [*(id *)(v97 + 32) zoneName];
        uint64_t v72 = sub_1000CD884(@"ckkskey", v71);

        if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
        {
          CFNumberRef v73 = [v63 error];
          *(_DWORD *)long long buf = 138412290;
          id v118 = v73;
          _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_ERROR, "Error examining existing key hierarchy: %@", buf, 0xCu);
        }
      }
LABEL_60:
      uint64_t v74 = [v63 tlk];
      if (v74)
      {
        uint64_t v75 = (void *)v74;
        uint64_t v76 = [v63 classA];
        if (v76)
        {
          id v77 = (void *)v76;
          uint64_t v78 = [v63 classC];
          if (v78)
          {
            uint64_t v79 = (void *)v78;
            uint64_t v80 = [v63 error];

            if (!v80) {
              goto LABEL_70;
            }
            goto LABEL_67;
          }
        }
      }
LABEL_67:
      id v81 = [v60 zoneID];
      uint64_t v82 = [v81 zoneName];
      CFStringRef v83 = sub_1000CD884(@"ckkskey", v82);

      if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v84 = [v60 zoneID];
        *(_DWORD *)long long buf = 138412290;
        id v118 = v84;
        _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_DEFAULT, "No existing key hierarchy for %@. Check if there's one in CloudKit...", buf, 0xCu);
      }
      uint64_t v58 = 1;
LABEL_70:
    }
    id v57 = [v95 countByEnumeratingWithState:&v98 objects:v115 count:16];
  }
  while (v57);
LABEL_74:

  if ((v58 | v94))
  {
    BOOL v42 = 0;
    id v15 = v93;
    id v85 = v92;
    if (v94)
    {
      id v86 = [*(id *)(v97 + 32) operationDependencies];
      char v87 = [v86 currentFetchReasons];
      [v87 addObject:@"more-coming"];
    }
    if (v58)
    {
      id v88 = [*(id *)(v97 + 32) operationDependencies];
      unsigned __int8 v89 = [v88 currentFetchReasons];
      [v89 addObject:@"periodic"];
    }
    uint64_t v90 = off_100305658;
  }
  else
  {
    uint64_t v90 = &off_100305660;
    BOOL v42 = 0;
    id v15 = v93;
    id v85 = v92;
  }
  [*(id *)(v97 + 40) setNextState:*v90];

LABEL_82:
LABEL_83:

  return 1;
}

void sub_100192A38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,id *location)
{
  objc_destroyWeak(v25);
  objc_destroyWeak(location);
  objc_destroyWeak((id *)(v26 - 128));
  _Unwind_Resume(a1);
}

void sub_100192A7C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v1 = [WeakRetained stateMachine];
  [v1 handleFlag:@"oqo_token"];
}

void sub_100192ADC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v1 = [WeakRetained stateMachine];
  [v1 handleFlag:@"oqo_token"];
}

void sub_100192DB8(id a1)
{
  v4[0] = @"payload";
  v4[1] = @"type";
  uint64_t v1 = +[NSArray arrayWithObjects:v4 count:2];
  uint64_t v2 = +[NSSet setWithArray:v1];
  id v3 = (void *)qword_10035D220;
  qword_10035D220 = v2;
}

void sub_1001930F4(id a1)
{
  v4[0] = kSecAttrUUID;
  v4[1] = @"zone";
  void v4[2] = @"ownr";
  v4[3] = @"type";
  void v4[4] = @"deln";
  void v4[5] = kSecAttrModificationDate;
  void v4[6] = kSecValueData;
  void v4[7] = @"pkkp";
  v4[8] = @"pkvp";
  v4[9] = @"ipkp";
  v4[10] = @"ipvp";
  uint64_t v1 = +[NSArray arrayWithObjects:v4 count:11];
  uint64_t v2 = +[NSSet setWithArray:v1];
  id v3 = (void *)qword_10035D230;
  qword_10035D230 = v2;
}

void sub_100193330(void *a1, const char *a2, CFDataRef theData, __CFString **a4)
{
  if (theData)
  {
    if (CFDataGetLength(theData) < 0)
    {
      sub_100012A40(-50, a4, @"no data for key %s", a2);
    }
    else
    {
      BytePtr = CFDataGetBytePtr(theData);
      size_t Length = CFDataGetLength(theData);
      xpc_dictionary_set_data(a1, a2, BytePtr, Length);
    }
  }
  else
  {
    sub_100012A40(-50, a4, @"data for key %s is NULL", a2);
  }
}

void sub_1001933EC(uint64_t a1, const __CFString *a2, __CFString **a3)
{
  if (a2)
  {
    v4[0] = 0;
    v4[1] = v4;
    void v4[2] = 0x2000000000;
    char v5 = 1;
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 0x40000000;
    v3[2] = sub_100193500;
    v3[3] = &unk_100305B28;
    void v3[4] = v4;
    void v3[5] = a1;
    v3[6] = "status";
    v3[7] = a3;
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    v6[2] = sub_10000B880;
    v6[3] = &unk_1002F7408;
    void v6[4] = v3;
    sub_10000EB80(a2, (uint64_t)v6);
    _Block_object_dispose(v4, 8);
  }
  else
  {
    sub_100012A40(-50, a3, @"string for key %s is NULL", "status");
  }
}

void sub_100193500(uint64_t a1, char *string)
{
  id v3 = *(const char **)(a1 + 48);
  if (string)
  {
    id v4 = *(void **)(a1 + 40);
    xpc_dictionary_set_string(v4, v3, string);
  }
  else
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = sub_100012A40(-50, *(__CFString ***)(a1 + 56), @"failed to convert string for key %s to utf8", *(void *)(a1 + 48));
  }
}

uint64_t sub_100193580(void *a1)
{
  uint64_t v1 = xpc_dictionary_dup_fd(a1, "fileDescriptor");
  if ((v1 & 0x80000000) != 0) {
    sub_100012A40(-50, 0, @"missing fd for key %s", "fileDescriptor");
  }
  return v1;
}

const void *sub_1001935D8(void *a1, const char *a2, __CFString **a3)
{
  CFTypeRef v5 = sub_10000B2D4(a1, a2, a3);
  id v6 = v5;
  if (v5 && (CFTypeID v7 = CFGetTypeID(v5), v7 == CFSetGetTypeID()))
  {
    CFRetain(v6);
    id v8 = v6;
  }
  else
  {
    if (a3) {
      sub_100012A40(-50, a3, @"object %@ is not a set", v6);
    }
    if (!v6) {
      return 0;
    }
    CFTypeID v9 = CFGetTypeID(v6);
    CFStringRef v10 = CFCopyTypeIDDescription(v9);
    sub_100012A40(-50, a3, @"object for key %s not set but %@", a2, v10);
    if (v10) {
      CFRelease(v10);
    }
    id v8 = 0;
  }
  CFRelease(v6);
  return v8;
}

const void *sub_1001936AC(void *a1, const char *a2, __CFString **a3)
{
  CFTypeRef v5 = sub_10000B2D4(a1, a2, a3);
  id v6 = v5;
  if (v5)
  {
    CFTypeID v7 = CFGetTypeID(v5);
    if (v7 != CFArrayGetTypeID())
    {
      CFStringRef v8 = CFCopyTypeIDDescription(v7);
      sub_100012A40(-50, a3, @"object for key %s not array but %@", a2, v8);
      if (v8) {
        CFRelease(v8);
      }
      CFRelease(v6);
      return 0;
    }
  }
  return v6;
}

CFDataRef sub_100193744(void *a1, const char *a2, __CFString **a3)
{
  size_t length = 0;
  data = (const UInt8 *)xpc_dictionary_get_data(a1, a2, &length);
  if (data)
  {
    if ((length & 0x8000000000000000) != 0)
    {
      sub_100012A40(-50, a3, @"too large data for key %s", a2);
    }
    else
    {
      CFDataRef result = CFDataCreate(kCFAllocatorDefault, data, length);
      if (result) {
        return result;
      }
      sub_100012A40(-50, a3, @"failed to create data for key %s", a2);
    }
  }
  else
  {
    sub_100012A40(-50, a3, @"no data for key %s", a2);
  }
  return 0;
}

BOOL sub_1001937D4(void *a1, const char *a2, void *a3, __CFString **a4)
{
  size_t length = 0;
  data = (void *)xpc_dictionary_get_data(a1, a2, &length);
  if (data)
  {
    data = sub_100193744(a1, a2, a4);
    BOOL v9 = data != 0;
  }
  else
  {
    BOOL v9 = 1;
  }
  *a3 = data;
  return v9;
}

BOOL sub_100193848(void *a1, void *a2, __CFString **a3)
{
  value = xpc_dictionary_get_value(a1, "backup");
  if (value)
  {
    value = (void *)sub_10000B23C(a1, "backup", a3);
    BOOL v7 = value != 0;
  }
  else
  {
    BOOL v7 = 1;
  }
  *a2 = value;
  return v7;
}

CFStringRef sub_1001938B4(void *a1, const char *a2, __CFString **a3)
{
  string = xpc_dictionary_get_string(a1, a2);
  if (string)
  {
    id v6 = string;
    CFStringRef result = CFStringCreateWithCString(kCFAllocatorDefault, string, 0x8000100u);
    if (result) {
      return result;
    }
    sub_100012A40(-108, a3, @"object for key %s failed to convert %s to CFString", a2, v6);
  }
  else
  {
    sub_100012A40(-50, a3, @"object for key %s not string", a2);
  }
  return 0;
}

BOOL sub_100193944(void *a1, const char *a2, void *a3, __CFString **a4)
{
  value = xpc_dictionary_get_value(a1, a2);
  if (value)
  {
    value = (void *)sub_1001938B4(a1, a2, a4);
    BOOL v9 = value != 0;
  }
  else
  {
    BOOL v9 = 1;
  }
  *a3 = value;
  return v9;
}

void sub_100194164(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1001941D0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100196D80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
  _Block_object_dispose(&a63, 8);
  _Block_object_dispose(&a67, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100196DF0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100196E00(uint64_t a1)
{
}

uint64_t sub_100196E08(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) deps];
  id v3 = [v2 contextID];
  id v4 = [*(id *)(a1 + 40) zoneID];
  id v57 = 0;
  CFTypeRef v5 = +[CKKSKey remoteKeysForContextID:v3 zoneID:v4 error:&v57];
  id v6 = v57;

  if (v5) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7)
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) += [v5 count];
    if ([v5 count])
    {
      uint64_t v14 = *(void **)(a1 + 32);
      uint64_t v15 = *(void *)(a1 + 40);
      uint64_t v16 = *(void *)(a1 + 56);
      uint64_t v17 = *(void *)(*(void *)(a1 + 88) + 8);
      id obj = *(id *)(v17 + 40);
      uint64_t v18 = [v14 processRemoteKeys:v5 viewState:v15 currentTrustStates:v16 error:&obj];
      objc_storeStrong((id *)(v17 + 40), obj);
      uint64_t v19 = *(void *)(*(void *)(a1 + 80) + 8);
      int v20 = *(void **)(v19 + 40);
      *(void *)(v19 + 40) = v18;

      id v21 = [*(id *)(a1 + 40) zoneID];
      id v22 = [v21 zoneName];
      BOOL v23 = sub_1000CD884(@"ckkskey", v22);

      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        id v24 = *(void **)(*(void *)(*(void *)(a1 + 80) + 8) + 40);
        uint64_t v25 = *(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 40);
        *(_DWORD *)long long buf = 138412546;
        id v61 = v24;
        __int16 v62 = 2112;
        uint64_t v63 = v25;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "After remote key processing, Key hierarchy is '%@' (error: %@)", buf, 0x16u);
      }

      if (![*(id *)(*(void *)(*(void *)(a1 + 80) + 8) + 40) isEqualToString:@"ready"])
      {
        uint64_t v13 = 1;
        goto LABEL_29;
      }
    }
    uint64_t v26 = [*(id *)(a1 + 32) deps];
    unsigned __int8 v27 = [v26 contextID];
    id v28 = [*(id *)(a1 + 40) zoneID];
    id v55 = 0;
    unsigned __int8 v29 = +[CKKSIncomingQueueEntry allIQEsHaveValidUnwrappingKeysInContextID:v27 zoneID:v28 error:&v55];
    id v30 = v55;

    if (v30)
    {
      id v31 = [*(id *)(a1 + 40) zoneID];
      uint64_t v32 = [v31 zoneName];
      long long v33 = sub_1000CD884(@"ckkskey", v32);

      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        id v61 = v30;
        uint64_t v34 = "Unable to determine if all IQEs have parent keys: %@";
        id v35 = v33;
        os_log_type_t v36 = OS_LOG_TYPE_ERROR;
        uint32_t v37 = 12;
LABEL_15:
        _os_log_impl((void *)&_mh_execute_header, v35, v36, v34, buf, v37);
      }
    }
    else
    {
      if (v29)
      {
LABEL_25:
        id v46 = [*(id *)(a1 + 40) zoneID];
        id v47 = [*(id *)(a1 + 32) deps];
        signed int v48 = [v47 contextID];
        uint64_t v49 = +[CKKSCurrentKeySet loadForZone:v46 contextID:v48];
        uint64_t v50 = *(void *)(*(void *)(a1 + 96) + 8);
        id v51 = *(void **)(v50 + 40);
        *(void *)(v50 + 40) = v49;

        if ([*(id *)(*(void *)(*(void *)(a1 + 80) + 8) + 40) isEqualToString:@"error"])
        {
          uint64_t v52 = *(void **)(a1 + 48);
          id v53 = [*(id *)(a1 + 32) error];
          [v52 populateUnderlyingErrorsStartingWithRootError:v53];

          uint64_t v13 = 0;
          *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = 0;
        }
        else
        {
          uint64_t v13 = 1;
        }

        goto LABEL_29;
      }
      unsigned int v38 = [*(id *)(a1 + 32) allowFullRefetchResult];
      unint64_t v39 = [*(id *)(a1 + 40) zoneID];
      uint64_t v40 = [v39 zoneName];
      long long v33 = sub_1000CD884(@"ckkskey", v40);

      BOOL v41 = os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT);
      if (v38)
      {
        if (v41)
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "We have some item that encrypts to a non-existent key. This is exceptional; requesting full refetch",
            buf,
            2u);
        }

        BOOL v42 = *(void **)(a1 + 48);
        uint64_t v58 = kSecurityRTCFieldFullRefetchNeeded;
        long long v59 = &__kCFBooleanTrue;
        uint64_t v43 = +[NSDictionary dictionaryWithObjects:&v59 forKeys:&v58 count:1];
        [v42 addMetrics:v43];

        uint64_t v44 = *(void *)(*(void *)(a1 + 80) + 8);
        unsigned int v45 = @"needrefetch";
        long long v33 = *(NSObject **)(v44 + 40);
        *(void *)(v44 + 40) = @"needrefetch";
        goto LABEL_24;
      }
      if (v41)
      {
        *(_WORD *)long long buf = 0;
        uint64_t v34 = "We have some item that encrypts to a non-existent key, but we cannot request a refetch! Possible inifinite-loop ahead";
        id v35 = v33;
        os_log_type_t v36 = OS_LOG_TYPE_DEFAULT;
        uint32_t v37 = 2;
        goto LABEL_15;
      }
    }
LABEL_24:

    goto LABEL_25;
  }
  CFStringRef v8 = [*(id *)(a1 + 40) zoneID];
  BOOL v9 = [v8 zoneName];
  CFStringRef v10 = sub_1000CD884(@"ckkskey", v9);

  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 138412290;
    id v61 = v6;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "couldn't fetch list of remote keys: %@", buf, 0xCu);
  }

  [*(id *)(a1 + 32) setError:v6];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = 0;
  id v11 = *(void **)(a1 + 48);
  id v12 = [*(id *)(a1 + 32) error];
  [v11 populateUnderlyingErrorsStartingWithRootError:v12];

  [*(id *)(a1 + 40) setViewKeyHierarchyState:@"error"];
  uint64_t v13 = 0;
LABEL_29:

  return v13;
}

void sub_10019920C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100199230(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100199240(uint64_t a1)
{
}

void sub_100199248(uint64_t a1, void *a2)
{
  id v6 = [a2 objectForKeyedSubscript:@"count(rowid)"];
  uint64_t v3 = [v6 asNSNumberInteger];
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  CFTypeRef v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;
}

id sub_10019ACA0(uint64_t a1)
{
  return [*(id *)(a1 + 32) setReadyNotificationArmed:1];
}

void sub_10019AD4C(uint64_t a1)
{
  if ([*(id *)(a1 + 32) readyNotificationArmed])
  {
    [*(id *)(a1 + 32) setReadyNotificationArmed:0];
    id v2 = [*(id *)(a1 + 32) notifyViewReadyScheduler];
    [v2 trigger];
  }
}

void sub_10019AEC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10019AEE0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10019AEF0(uint64_t a1)
{
}

void sub_10019AEF8(uint64_t a1)
{
  id v5 = [*(id *)(a1 + 32) mutableStateConditions];
  id v2 = [v5 copy];
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void sub_10019B018(uint64_t a1)
{
  if (([*(id *)(a1 + 32) isEqualToString:*(void *)(*(void *)(a1 + 40) + 16)] & 1) == 0)
  {
    id v2 = *(void **)(a1 + 40);
    if (v2[2])
    {
      uint64_t v3 = objc_alloc_init(CKKSCondition);
      uint64_t v4 = [*(id *)(a1 + 40) mutableStateConditions];
      [v4 setObject:v3 forKeyedSubscript:*(void *)(*(void *)(a1 + 40) + 16)];

      id v2 = *(void **)(a1 + 40);
    }
    id v5 = [v2 allowableStates];
    unsigned __int8 v6 = [v5 containsObject:*(void *)(a1 + 32)];

    if ((v6 & 1) == 0)
    {
      uint64_t v18 = +[NSAssertionHandler currentHandler];
      [v18 handleFailureInMethod:*(void *)(a1 + 48), *(void *)(a1 + 40), @"CKKSKeychainViewState.m", 123, @"state machine tried to enter unknown state %@", *(void *)(a1 + 32) object file lineNumber description];
    }
    objc_storeStrong((id *)(*(void *)(a1 + 40) + 16), *(id *)(a1 + 32));
    BOOL v7 = [*(id *)(a1 + 40) zoneID];
    CFStringRef v8 = [v7 zoneName];
    BOOL v9 = sub_1000CD884(@"ckks-view-state", v8);

    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = *(void *)(a1 + 32);
      *(_DWORD *)long long buf = 138412290;
      uint64_t v20 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Zone is entering %@", buf, 0xCu);
    }

    id v11 = [*(id *)(a1 + 40) launch];
    [v11 addEvent:*(void *)(a1 + 32)];

    if (*(void *)(a1 + 32))
    {
      id v12 = [*(id *)(a1 + 40) mutableStateConditions];
      uint64_t v13 = [v12 objectForKeyedSubscript:*(void *)(a1 + 32)];
      [v13 fulfill];

      if ([*(id *)(a1 + 32) isEqualToString:@"ready"])
      {
        uint64_t v14 = +[CKKSAnalytics logger];
        uint64_t v15 = +[NSDate date];
        uint64_t v16 = [*(id *)(a1 + 40) zoneID];
        uint64_t v17 = [v16 zoneName];
        [v14 setDateProperty:v15 forKey:@"lastKSR" zoneName:v17];
      }
    }
  }
}

void sub_10019B870(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v5 = objc_alloc_init(CKKSCondition);
  uint64_t v4 = [*(id *)(a1 + 32) mutableStateConditions];
  [v4 setObject:v5 forKeyedSubscript:v3];
}

id sub_10019B9A0(id a1, SecDbItem *a2, id *a3)
{
  id v11 = 0;
  id v5 = [(KCSharingOutgoingRow *)[KCSharingOutgoingEntry alloc] initWithOutgoingDatabaseItem:a2 error:&v11];
  id v6 = v11;
  BOOL v7 = v6;
  if (v5)
  {
    CFStringRef v8 = v5;
LABEL_5:
    BOOL v9 = v8;
    goto LABEL_6;
  }
  if (sub_10004700C(v6))
  {
    CFStringRef v8 = [(KCSharingOutgoingRow *)[KCSharingOutgoingDeletion alloc] initWithOutgoingDatabaseItem:a2 error:a3];
    goto LABEL_5;
  }
  BOOL v9 = 0;
  if (a3) {
    *a3 = v7;
  }
LABEL_6:

  return v9;
}

id sub_10019BAC4(id a1, SecDbItem *a2, id *a3)
{
  id v11 = 0;
  id v5 = [(KCSharingIncomingRow *)[KCSharingIncomingEntry alloc] initWithIncomingDatabaseItem:a2 error:&v11];
  id v6 = v11;
  BOOL v7 = v6;
  if (v5)
  {
    CFStringRef v8 = v5;
LABEL_5:
    BOOL v9 = v8;
    goto LABEL_6;
  }
  if (sub_10004700C(v6))
  {
    CFStringRef v8 = [(KCSharingIncomingRow *)[KCSharingIncomingDeletion alloc] initWithIncomingDatabaseItem:a2 error:a3];
    goto LABEL_5;
  }
  BOOL v9 = 0;
  if (a3) {
    *a3 = v7;
  }
LABEL_6:

  return v9;
}

id sub_10019BBE8(id a1, SecDbItem *a2, id *a3)
{
  id v3 = [[KCSharingMirrorEntry alloc] initWithMirrorDatabaseItem:a2 error:a3];

  return v3;
}

uint64_t sub_10019BEF8(id *a1, uint64_t a2, void *a3)
{
  id v6 = [[KCSharingRowMapper alloc] initWithModel:a1[6]];
  BOOL v7 = [(KCSharingRowMapper *)v6 columnNamesWithTableName:0];
  CFStringRef v8 = [v7 componentsJoinedByString:@", "];
  BOOL v9 = [a1[6] databaseItemClass];
  if (a1[4]) {
    CFStringRef v10 = @"AND zone = ?2";
  }
  else {
    CFStringRef v10 = &stru_10030AA90;
  }
  id v11 = +[NSString stringWithFormat:@"SELECT %1$@ FROM %2$@ WHERE uuid = ?1 %3$@", v8, *v9, v10];

  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472;
  v16[2] = sub_10019C078;
  v16[3] = &unk_100306290;
  id v12 = a1[4];
  uint64_t v20 = a2;
  id v17 = v12;
  uint64_t v18 = v6;
  id v19 = a1[5];
  uint64_t v13 = v6;
  uint64_t v14 = sub_100155E64(a2, v11, a3, v16);

  return v14;
}

uint64_t sub_10019C078(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  if (!sub_1001560B8(a2, 1, (const __CFString *)CKRecordNameZoneWideShare, a3)) {
    return 0;
  }
  uint64_t v6 = *(void *)(a1 + 32);
  if (v6)
  {
    BOOL v7 = +[NSString stringWithFormat:@"%@%@", @"group-", v6];
    int v8 = sub_1001560B8(a2, 2, v7, a3);

    if (!v8) {
      return 0;
    }
  }
  uint64_t v9 = *(void *)(a1 + 56);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_10019C1C0;
  v12[3] = &unk_100306268;
  id v13 = *(id *)(a1 + 40);
  uint64_t v15 = a2;
  id v14 = *(id *)(a1 + 48);
  uint64_t v10 = sub_100156118(v9, a2, a3, v12);

  return v10;
}

uint64_t sub_10019C1C0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = [*(id *)(a1 + 32) mapResultRow:*(void *)(a1 + 48) startingAt:0 error:a3];
  if (v5)
  {
    uint64_t v6 = [[KCSharingMirrorEntry alloc] initWithMirrorDatabaseItem:v5 error:a3];
    BOOL v7 = v6;
    if (v6
      && ([(KCSharingMirrorEntry *)v6 record],
          int v8 = objc_claimAutoreleasedReturnValue(),
          objc_opt_class(),
          char isKindOfClass = objc_opt_isKindOfClass(),
          v8,
          (isKindOfClass & 1) != 0))
    {
      uint64_t v10 = *(void **)(a1 + 40);
      id v11 = [(KCSharingMirrorEntry *)v7 record];
      [v10 addObject:v11];

      uint64_t v12 = 1;
    }
    else
    {
      uint64_t v12 = 0;
    }
  }
  else
  {
    uint64_t v12 = 0;
  }

  return v12;
}

uint64_t sub_10019C3AC(id *a1, uint64_t a2, void *a3)
{
  uint64_t v6 = [[KCSharingRowMapper alloc] initWithModel:a1[6]];
  BOOL v7 = [(KCSharingRowMapper *)v6 columnNamesWithTableName:0];
  int v8 = [v7 componentsJoinedByString:@", "];
  uint64_t v9 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"SELECT %@ FROM %@", v8, *(void *)[a1[6] databaseItemClass]);

  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_10019C510;
  v13[3] = &unk_100306868;
  uint64_t v17 = a2;
  id v14 = v6;
  id v16 = a1[5];
  id v15 = a1[4];
  uint64_t v10 = v6;
  uint64_t v11 = sub_100155E64(a2, v9, a3, v13);

  return v11;
}

uint64_t sub_10019C510(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  uint64_t v6 = *(void *)(a1 + 56);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  void v9[2] = sub_10019C5EC;
  v9[3] = &unk_100306840;
  id v10 = *(id *)(a1 + 32);
  id v13 = a2;
  id v12 = *(id *)(a1 + 48);
  id v11 = *(id *)(a1 + 40);
  uint64_t v7 = sub_100156118(v6, a2, a3, v9);

  return v7;
}

BOOL sub_10019C5EC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = [*(id *)(a1 + 32) mapResultRow:*(void *)(a1 + 56) startingAt:0 error:a3];
  if (v4)
  {
    id v5 = (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    BOOL v6 = v5 != 0;
    if (v5) {
      [*(id *)(a1 + 40) addObject:v5];
    }
  }
  else
  {
    BOOL v6 = 0;
  }

  return v6;
}

void sub_10019C968(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v15 - 112), 8);
  _Unwind_Resume(a1);
}

BOOL sub_10019C990(uint64_t a1, uint64_t a2)
{
  return (*(unsigned char *)(a2 + 16) & 2) != 0
      && CFDictionaryContainsKey(*(CFDictionaryRef *)(*(void *)(a1 + 32) + 8), *(const void **)a2) != 0;
}

BOOL sub_10019C9CC(void *a1, CFStringRef **a2, unsigned char *a3)
{
  BOOL result = sub_10011E5A4(a2, a1[6], (CFTypeRef *)(*(void *)(a1[4] + 8) + 24), (uint64_t)&stru_1003067F0);
  if (!result)
  {
    *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = 0;
    *a3 = 1;
  }
  return result;
}

BOOL sub_10019CA2C(id a1, const SecDbAttr *a2)
{
  return a2->var1 == 8;
}

BOOL sub_10019CA3C(id a1, const SecDbAttr *a2)
{
  return a2->var1 == 8;
}

uint64_t sub_10019CC40(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  BOOL v6 = [*(id *)(a1 + 32) accessGroups];
  uint64_t v7 = [v6 entryAccessGroup];
  int v8 = sub_1001560B8(a2, 1, v7, a3);

  if (!v8) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 40);

  return sub_100156118(v9, a2, a3, &stru_100306770);
}

BOOL sub_10019CCF4(id a1, BOOL *a2, id *a3)
{
  return 1;
}

uint64_t sub_10019CDDC(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  return sub_100156118(*(void *)(a1 + 32), a2, a3, &stru_100306750);
}

BOOL sub_10019CDEC(id a1, BOOL *a2, id *a3)
{
  return 1;
}

uint64_t sub_10019CED4(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  return sub_100156118(*(void *)(a1 + 32), a2, a3, &stru_100306710);
}

BOOL sub_10019CEE4(id a1, BOOL *a2, id *a3)
{
  return 1;
}

uint64_t sub_10019D01C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10019D02C(uint64_t a1)
{
}

void sub_10019D034(void *a1)
{
  id v2 = (void *)a1[4];
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_10019D0E8;
  v6[3] = &unk_100306118;
  void v6[4] = v2;
  uint64_t v3 = *(void *)(a1[6] + 8);
  id obj = *(id *)(v3 + 40);
  unsigned __int8 v4 = [v2 withConnection:v6 error:&obj];
  objc_storeStrong((id *)(v3 + 40), obj);
  *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = v4;
}

uint64_t sub_10019D0E8(uint64_t a1, uint64_t a2, void *a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_10019D17C;
  void v5[3] = &unk_1003060F0;
  void v5[4] = *(void *)(a1 + 32);
  void v5[5] = a2;
  uint64_t v3 = sub_100156380(a2, a3, v5);
  if (v3) {
    sub_10013F064();
  }
  return v3;
}

uint64_t sub_10019D17C(uint64_t a1, void *a2)
{
  unsigned __int8 v4 = *(void **)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 40);
  id v37 = 0;
  unsigned __int8 v6 = [v4 wipeLocalPrivateKeysInTransaction:v5 error:&v37];
  id v11 = v37;
  if ((v6 & 1) == 0)
  {
    uint64_t v32 = @"Wiping private keys";
LABEL_7:
    sub_100047078(a2, 32, v11, v32, v7, v8, v9, v10, (uint64_t)v34);
    uint64_t v31 = 0;
    goto LABEL_12;
  }
  id v12 = *(void **)(a1 + 32);
  uint64_t v13 = *(void *)(a1 + 40);
  id v36 = v11;
  unsigned __int8 v14 = [v12 wipeLocalPasswordsInTransaction:v13 error:&v36];
  id v15 = v36;

  if ((v14 & 1) == 0)
  {
    sub_100047078(a2, 32, v15, @"Wiping passwords", v16, v17, v18, v19, (uint64_t)v34);
    uint64_t v31 = 0;
    id v11 = v15;
    goto LABEL_12;
  }
  uint64_t v20 = *(void **)(a1 + 32);
  uint64_t v21 = *(void *)(a1 + 40);
  id v35 = v15;
  unsigned __int8 v22 = [v20 resetSyncTablesInTransaction:v21 error:&v35];
  id v11 = v35;

  if ((v22 & 1) == 0)
  {
    uint64_t v32 = @"Resetting sync tables";
    goto LABEL_7;
  }
  BOOL v23 = *(void **)(a1 + 32);
  uint64_t v24 = *(void *)(a1 + 40);
  id v34 = v11;
  unsigned __int8 v25 = [v23 resetMetadataInTransaction:v24 error:&v34];
  id v26 = v34;

  if (v25)
  {
    uint64_t v31 = 1;
  }
  else
  {
    sub_100047078(a2, 32, v26, @"Resetting metadata", v27, v28, v29, v30, (uint64_t)v34);
    uint64_t v31 = 0;
  }
  id v11 = v26;
LABEL_12:

  return v31;
}

void sub_10019D408(void *a1)
{
  id v2 = (void *)a1[4];
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_10019D4BC;
  v6[3] = &unk_100306118;
  void v6[4] = v2;
  uint64_t v3 = *(void *)(a1[6] + 8);
  id obj = *(id *)(v3 + 40);
  unsigned __int8 v4 = [v2 withConnection:v6 error:&obj];
  objc_storeStrong((id *)(v3 + 40), obj);
  *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = v4;
}

uint64_t sub_10019D4BC(uint64_t a1, uint64_t a2, void *a3)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  void v4[2] = sub_10019D538;
  void v4[3] = &unk_1003060F0;
  void v4[4] = *(void *)(a1 + 32);
  void v4[5] = a2;
  return sub_100156380(a2, a3, v4);
}

uint64_t sub_10019D538(uint64_t a1, void *a2)
{
  unsigned __int8 v4 = *(void **)(a1 + 32);
  uint64_t v5 = *(void *)(a1 + 40);
  id v23 = 0;
  unsigned __int8 v6 = [v4 resetSyncTablesInTransaction:v5 error:&v23];
  id v11 = v23;
  if (v6)
  {
    id v12 = *(void **)(a1 + 32);
    uint64_t v13 = *(void *)(a1 + 40);
    id v22 = v11;
    unsigned __int8 v14 = [v12 resetMetadataInTransaction:v13 error:&v22];
    id v15 = v22;

    if (v14)
    {
      uint64_t v20 = 1;
    }
    else
    {
      sub_100047078(a2, 31, v15, @"Resetting metadata", v16, v17, v18, v19, (uint64_t)v22);
      uint64_t v20 = 0;
    }
    id v11 = v15;
  }
  else
  {
    sub_100047078(a2, 31, v11, @"Resetting sync tables", v7, v8, v9, v10, (uint64_t)v22);
    uint64_t v20 = 0;
  }

  return v20;
}

uint64_t sub_10019D72C(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  unsigned __int8 v6 = [*(id *)(a1 + 32) accessGroups];
  uint64_t v7 = [v6 entryAccessGroup];
  if ((sub_1001560B8(a2, 1, v7, a3) & 1) == 0) {
    goto LABEL_8;
  }
  uint64_t v8 = [*(id *)(a1 + 40) zoneID];
  uint64_t v9 = [v8 ownerName];
  if (!sub_1001560B8(a2, 2, v9, a3))
  {
LABEL_7:

LABEL_8:
    return 0;
  }
  uint64_t v10 = [*(id *)(a1 + 40) zoneID];
  id v11 = [v10 zoneName];
  if (!sub_1001560B8(a2, 3, v11, a3))
  {

    goto LABEL_7;
  }
  id v12 = [*(id *)(a1 + 40) recordName];
  int v16 = sub_1001560B8(a2, 4, v12, a3);

  if (!v16) {
    return 0;
  }
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472;
  v17[2] = sub_10019D8FC;
  void v17[3] = &unk_100306510;
  uint64_t v19 = a2;
  uint64_t v13 = *(void *)(a1 + 56);
  id v18 = *(id *)(a1 + 48);
  uint64_t v14 = sub_100156118(v13, a2, a3, v17);

  return v14;
}

BOOL sub_10019D8FC(uint64_t a1, uint64_t a2, void *a3)
{
  sqlite3_int64 v5 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  unsigned __int8 v6 = objc_opt_class();
  uint64_t v7 = sub_10019D988(v6, v5, a3);
  if (v7)
  {
    uint64_t v8 = [*(id *)(a1 + 32) itemsToDelete];
    [v8 addObject:v7];
  }
  return v7 != 0;
}

id sub_10019D988(void *a1, uint64_t a2, void *a3)
{
  id v11 = 0;
  id v5 = [a1 databaseItemClass];
  unsigned __int8 v6 = (void **)sub_10011ACF4((uint64_t)v5, (const __CFDictionary *)&__NSDictionary0__struct, dword_10035D2B0, (__CFString **)&v11);
  uint64_t v7 = v6;
  if (v6 && (sub_10011B7D4(v6, a2, (__CFString **)&v11) & 1) != 0)
  {
    id v8 = v7;
  }
  else
  {
    id v9 = v11;
    if (a3)
    {
      id v8 = 0;
      *a3 = v11;
      id v11 = 0;
    }
    else
    {
      if (v11)
      {
        id v11 = 0;
        CFRelease(v9);
      }
      id v8 = 0;
    }
  }

  return v8;
}

uint64_t sub_10019DAF4(uint64_t a1, uint64_t a2, void *a3)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_10019DB94;
  v8[3] = &unk_100306330;
  id v5 = *(void **)(a1 + 40);
  void v8[4] = *(void *)(a1 + 32);
  id v9 = v5;
  uint64_t v10 = a2;
  uint64_t v6 = sub_100156380(a2, a3, v8);

  return v6;
}

id sub_10019DB94(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) dropOutgoingChangeForRecordID:*(void *)(a1 + 40) inTransaction:*(void *)(a1 + 48) error:a2];
}

void sub_10019DF20(uint64_t a1, uint64_t a2)
{
  id v3 = [*(id *)(a1 + 32) itemsToDelete];
  [v3 addObject:a2];
}

void sub_10019DF74(uint64_t a1, uint64_t a2)
{
  id v3 = [*(id *)(a1 + 32) itemsToDelete];
  [v3 addObject:a2];
}

void sub_10019DFC8(uint64_t a1, uint64_t a2)
{
  id v3 = [*(id *)(a1 + 32) itemsToDelete];
  [v3 addObject:a2];
}

void sub_10019E01C(uint64_t a1, uint64_t a2)
{
  id v3 = [*(id *)(a1 + 32) itemsToDelete];
  [v3 addObject:a2];
}

uint64_t sub_10019E11C(uint64_t a1, uint64_t a2, void *a3)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_10019E1BC;
  v8[3] = &unk_100306330;
  id v5 = *(void **)(a1 + 40);
  void v8[4] = *(void *)(a1 + 32);
  id v9 = v5;
  uint64_t v10 = a2;
  uint64_t v6 = sub_100156380(a2, a3, v8);

  return v6;
}

id sub_10019E1BC(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) updateMirrorWithDeletedZoneIDs:*(void *)(a1 + 40) inTransaction:*(void *)(a1 + 48) error:a2];
}

uint64_t sub_10019E2A0(uint64_t a1, uint64_t a2, void *a3)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  void v9[2] = sub_10019E364;
  v9[3] = &unk_100306380;
  uint64_t v6 = *(void **)(a1 + 40);
  void v9[4] = *(void *)(a1 + 32);
  id v10 = v6;
  uint64_t v12 = a2;
  id v11 = *(id *)(a1 + 48);
  uint64_t v7 = sub_100156380(a2, a3, v9);

  return v7;
}

id sub_10019E364(uint64_t a1, void *a2)
{
  unsigned int v45 = [*(id *)(a1 + 32) plan];
  long long v56 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  id obj = *(id *)(a1 + 40);
  id v3 = [obj countByEnumeratingWithState:&v56 objects:v61 count:16];
  if (v3)
  {
    id v4 = v3;
    id v5 = 0;
    uint64_t v44 = *(void *)v57;
    while (2)
    {
      uint64_t v6 = 0;
      uint64_t v7 = v5;
      do
      {
        if (*(void *)v57 != v44) {
          objc_enumerationMutation(obj);
        }
        uint64_t v8 = *(void *)(*((void *)&v56 + 1) + 8 * (void)v6);
        v49[0] = _NSConcreteStackBlock;
        v49[1] = 3221225472;
        uint64_t v50 = sub_10019E68C;
        id v51 = &unk_100306380;
        uint64_t v52 = *(void *)(a1 + 32);
        uint64_t v53 = v8;
        uint64_t v55 = *(void *)(a1 + 56);
        id v54 = v45;
        id v9 = v49;
        id v60 = 0;
        int v11 = ((uint64_t (*)(void *, id *))v50)(v9, &v60);
        id v12 = v60;
        id v13 = v7;
        if ((v11 & 1) == 0) {
          id v13 = v12;
        }

        id v5 = v13;
        if (!v11)
        {

          id v18 = @"Moving saved records to mirror";
          goto LABEL_20;
        }
        uint64_t v6 = (char *)v6 + 1;
        uint64_t v7 = v5;
      }
      while (v4 != v6);
      id v4 = [obj countByEnumeratingWithState:&v56 objects:v61 count:16];
      if (v4) {
        continue;
      }
      break;
    }
  }
  else
  {
    id v5 = 0;
  }
  uint64_t v19 = v5;

  uint64_t v20 = *(void *)(a1 + 56);
  uint64_t v21 = [*(id *)(a1 + 32) accessGroups];
  id v48 = v19;
  unsigned __int8 v22 = [v45 applyInTransaction:v20 withAccessGroups:v21 error:&v48];
  id v5 = v48;

  if (v22)
  {
    id v23 = *(void **)(a1 + 32);
    uint64_t v24 = *(void *)(a1 + 48);
    uint64_t v25 = *(void *)(a1 + 56);
    id v47 = 0;
    unsigned __int8 v26 = [v23 dropDeletionsForRecordIDs:v24 inTransaction:v25 error:&v47];
    id v31 = v47;
    if (v26)
    {
      uint64_t v32 = *(void **)(a1 + 32);
      uint64_t v33 = *(void *)(a1 + 56);
      id v46 = 0;
      id v34 = [v32 resolveConflictingPrimaryKeysInTransaction:v33 error:&v46];
      id v39 = v46;
      if ((v34 & 1) == 0) {
        sub_100047078(a2, 30, v39, @"Resolving primary key conflicts", v35, v36, v37, v38, v41);
      }
    }
    else
    {
      sub_100047078(a2, 30, v31, @"Dropping entries for deleted records from mirror", v27, v28, v29, v30, v41);
      id v34 = 0;
    }
  }
  else
  {
    id v18 = @"Moving entries for saved records to mirror";
LABEL_20:
    sub_100047078(a2, 30, v5, v18, v14, v15, v16, v17, v41);
    id v34 = 0;
  }

  return v34;
}

BOOL sub_10019E68C(uint64_t a1, uint64_t a2)
{
  id v4 = *(void **)(a1 + 32);
  id v5 = [*(id *)(a1 + 40) recordID];
  uint64_t v6 = [v4 fetchOutgoingDatabaseItemWithRecordID:v5 inTransaction:*(void *)(a1 + 56) error:a2];

  if (v6)
  {
    uint64_t v7 = [(KCSharingOutgoingRow *)[KCSharingOutgoingEntry alloc] initWithOutgoingDatabaseItem:v6 error:a2];
    uint64_t v8 = v7;
    BOOL v9 = v7 != 0;
    if (!v7)
    {
LABEL_16:

      goto LABEL_17;
    }
    id v10 = [(KCSharingOutgoingEntry *)v7 type];
    if ((unint64_t)(v10 - 1) >= 2)
    {
      if (v10)
      {
        if (v10 == (char *)3)
        {
          int v11 = [*(id *)(a1 + 32) accessGroups];
          uint64_t v12 = [(KCSharingOutgoingEntry *)v8 shareWithAccessGroups:v11 error:0];
LABEL_9:
          id v13 = (void *)v12;

          if ([v13 isFullyDecoded]) {
            uint64_t v14 = 0;
          }
          else {
            uint64_t v14 = 2;
          }

          goto LABEL_15;
        }
        uint64_t v14 = 0;
      }
      else
      {
        uint64_t v14 = 2;
      }
LABEL_15:
      uint64_t v15 = [[KCSharingMirrorEntry alloc] initWithSavedRecord:*(void *)(a1 + 40) forOutgoingEntry:v8 flags:v14];
      uint64_t v16 = [*(id *)(a1 + 48) insertIntoMirror];
      [v16 addObject:v15];

      uint64_t v17 = [*(id *)(a1 + 48) itemsToDelete];
      [v17 addObject:v6];

      goto LABEL_16;
    }
    int v11 = [*(id *)(a1 + 32) accessGroups];
    uint64_t v12 = [(KCSharingOutgoingEntry *)v8 remoteItemWithAccessGroups:v11 error:0];
    goto LABEL_9;
  }
  BOOL v9 = 0;
LABEL_17:

  return v9;
}

void sub_10019EB60(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 176), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10019EB7C(uint64_t a1, sqlite3_stmt *a2, void *a3, void *a4)
{
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  id obj = a3;
  id v6 = [obj countByEnumeratingWithState:&v21 objects:v25 count:16];
  if (v6)
  {
    id v7 = v6;
    uint64_t v19 = *(void *)v22;
    uint64_t v8 = 1;
    while (2)
    {
      for (CFIndex i = 0; i != v7; CFIndex i = (char *)i + 1)
      {
        uint64_t v10 = v8;
        if (*(void *)v22 != v19) {
          objc_enumerationMutation(obj);
        }
        int v11 = *(void **)(*((void *)&v21 + 1) + 8 * i);
        uint64_t v12 = [*(id *)(a1 + 32) keyset];
        id v13 = [v12 objectForKeyedSubscript:v11];

        uint64_t v14 = [v11 ownerName];
        if (!sub_1001560B8(a2, v10, v14, a4)) {
          goto LABEL_14;
        }
        uint64_t v15 = [v11 zoneName];
        if ((sub_1001560B8(a2, (v10 + 1), v15, a4) & 1) == 0)
        {

LABEL_14:
LABEL_15:

          uint64_t v8 = 0xFFFFFFFFLL;
          goto LABEL_16;
        }
        char v16 = sub_1001560B8(a2, (v10 + 2), v13, a4);

        if ((v16 & 1) == 0) {
          goto LABEL_15;
        }

        uint64_t v8 = (v10 + 3);
      }
      uint64_t v8 = (v10 + 3);
      id v7 = [obj countByEnumeratingWithState:&v21 objects:v25 count:16];
      if (v7) {
        continue;
      }
      break;
    }
  }
  else
  {
    uint64_t v8 = 1;
  }
LABEL_16:

  return v8;
}

BOOL sub_10019ED68(uint64_t a1, uint64_t a2, unsigned char *a3, void *a4)
{
  id v7 = [*(id *)(a1 + 32) mapResultRow:a2 startingAt:0 error:a4];
  if (v7)
  {
    id v36 = 0;
    uint64_t v8 = [(KCSharingOutgoingRow *)[KCSharingOutgoingEntry alloc] initWithOutgoingDatabaseItem:v7 error:&v36];
    id v9 = v36;
    uint64_t v10 = v9;
    if (v8)
    {
      int v11 = [(KCSharingOutgoingEntry *)v8 record];
      uint64_t v12 = (char *)[v11 size];

      unint64_t v13 = *(void *)(a1 + 72);
      uint64_t v14 = *(void *)(*(void *)(a1 + 64) + 8);
      uint64_t v15 = &v12[*(void *)(v14 + 24)];
      if ((v13 & 0x8000000000000000) != 0 || (unint64_t)v15 <= v13)
      {
        *(void *)(v14 + 24) = v15;
        unsigned __int8 v26 = *(void **)(a1 + 56);
        uint64_t v27 = [(KCSharingOutgoingEntry *)v8 record];
        [v26 addObject:v27];

        uint64_t v28 = [(KCSharingOutgoingEntry *)v8 record];
        uint64_t v29 = [v28 recordID];
        uint64_t v30 = [v29 recordName];
        id v31 = *(void **)(a1 + 48);
        uint64_t v32 = [(KCSharingOutgoingEntry *)v8 record];
        uint64_t v33 = [v32 recordID];
        id v34 = [v33 zoneID];
        [v31 setObject:v30 forKeyedSubscript:v34];

        BOOL v16 = 1;
      }
      else
      {
        BOOL v16 = 1;
        *a3 = 1;
      }
    }
    else if (sub_10004700C(v9))
    {
      uint64_t v17 = [(KCSharingOutgoingRow *)[KCSharingOutgoingDeletion alloc] initWithOutgoingDatabaseItem:v7 error:a4];
      id v18 = v17;
      BOOL v16 = v17 != 0;
      if (v17)
      {
        uint64_t v19 = *(void **)(a1 + 40);
        uint64_t v20 = [(KCSharingOutgoingDeletion *)v17 recordID];
        [v19 addObject:v20];

        long long v21 = [(KCSharingOutgoingDeletion *)v18 recordID];
        long long v22 = [v21 recordName];
        long long v23 = *(void **)(a1 + 48);
        long long v24 = [(KCSharingOutgoingDeletion *)v18 recordID];
        uint64_t v25 = [v24 zoneID];
        [v23 setObject:v22 forKeyedSubscript:v25];
      }
    }
    else
    {
      BOOL v16 = 0;
      if (a4) {
        *a4 = v10;
      }
    }
  }
  else
  {
    BOOL v16 = 0;
  }

  return v16;
}

uint64_t sub_10019EFE8(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v101 = 0;
  id v102 = &v101;
  uint64_t v103 = 0x2020000000;
  char v104 = 1;
  uint64_t v95 = 0;
  id v96 = (id *)&v95;
  uint64_t v97 = 0x3032000000;
  long long v98 = sub_10019D01C;
  long long v99 = sub_10019D02C;
  id v100 = 0;
  id v6 = [*(id *)(a1 + 32) fetchBehavior];
  if (v6 == (id)1)
  {
    long long v23 = [*(id *)(a1 + 32) keyset];
    long long v22 = [v23 allKeys];

    id v24 = [v22 count];
    uint64_t v25 = *(void **)(a1 + 32);
    if (v24)
    {
      unsigned __int8 v26 = [v25 keyset];
      uint64_t v27 = [v26 allKeys];
      int v28 = sqlite3_limit(*(sqlite3 **)(a2 + 64), 9, -1);
      v74[0] = _NSConcreteStackBlock;
      v74[1] = 3221225472;
      uint64_t v75 = sub_10019F8F0;
      uint64_t v76 = &unk_1003066C8;
      id v77 = *(id *)(a1 + 32);
      id v78 = *(id *)(a1 + 40);
      uint64_t v82 = &v101;
      uint64_t v29 = *(void **)(a1 + 64);
      uint64_t v84 = *(void *)(a1 + 72);
      uint64_t v85 = a2;
      CFStringRef v83 = &v95;
      id v30 = v29;
      id v31 = *(void **)(a1 + 56);
      uint64_t v79 = *(void *)(a1 + 48);
      id v80 = v30;
      id v32 = v31;
      uint64_t v33 = *(void *)(a1 + 80);
      id v81 = v32;
      uint64_t v86 = v33;
      id v34 = v27;
      uint64_t v35 = v74;
      id v36 = [v34 count];
      unint64_t v37 = (v28 & ~(v28 >> 31)) - 2;
      if (v37 >= 3 && v36)
      {
        char v105 = 0;
        unint64_t v38 = (unint64_t)[v34 count];
        if (v38 >= v37 / 3) {
          unint64_t v39 = v37 / 3;
        }
        else {
          unint64_t v39 = v38;
        }
        uint64_t v40 = [v34 subarrayWithRange:0, v39];
        v75((uint64_t)v35, v40, &v105);
      }
      uint64_t v41 = v77;
    }
    else
    {
      id v42 = [v25 databaseScope];
      if (v42 == (id)2)
      {
        uint64_t v49 = [*(id *)(a1 + 40) columnNamesWithTableName:@"o"];
        uint64_t v50 = [v49 componentsJoinedByString:@", "];
        uint64_t v41 = +[NSString stringWithFormat:@"SELECT %1$@                                   FROM sharingOutgoingQueue o                                   WHERE (o.agrp, o.ownr) = (?1, ?2)                                   ORDER BY o.zone, o.uuid                                   LIMIT %2$ld", v50, *(void *)(a1 + 72)];

        id v51 = v96;
        id v52 = v96[5];
        uint64_t v93 = a2;
        id v94 = v52;
        v91[0] = _NSConcreteStackBlock;
        v91[1] = 3221225472;
        v91[2] = sub_10019F6A8;
        v91[3] = &unk_100306308;
        uint64_t v53 = *(void **)(a1 + 56);
        v91[4] = *(void *)(a1 + 48);
        id v92 = v53;
        char v54 = sub_100155E64(a2, v41, &v94, v91);
        objc_storeStrong(v51 + 5, v94);
        *((unsigned char *)v102 + 24) = v54;
        id v48 = v92;
      }
      else
      {
        if (v42 != (id)3)
        {
          long long v57 = +[NSAssertionHandler currentHandler];
          uint64_t v58 = *(void *)(a1 + 80);
          uint64_t v59 = *(void *)(a1 + 48);
          [*(id *)(a1 + 32) databaseScope];
          id v60 = CKDatabaseScopeString();
          [v57 handleFailureInMethod:v58, v59, @"KCSharingStore.m", 2361, @"Can't fetch initial batch of outgoing changes in all zones for database with %@ scope", v60 object file lineNumber description];

          goto LABEL_26;
        }
        uint64_t v43 = [*(id *)(a1 + 40) columnNamesWithTableName:@"o"];
        uint64_t v44 = [v43 componentsJoinedByString:@", "];
        uint64_t v41 = +[NSString stringWithFormat:@"SELECT %1$@                                   FROM sharingOutgoingQueue o                                   WHERE o.agrp = ?1 AND                                         o.ownr <> ?2                                   ORDER BY o.ownr, o.zone, o.uuid                                   LIMIT %2$ld", v44, *(void *)(a1 + 72)];

        unsigned int v45 = v96;
        id v90 = v96[5];
        v87[0] = _NSConcreteStackBlock;
        v87[1] = 3221225472;
        v87[2] = sub_10019F7CC;
        v87[3] = &unk_100306308;
        id v46 = *(void **)(a1 + 56);
        v87[4] = *(void *)(a1 + 48);
        uint64_t v89 = a2;
        id v88 = v46;
        char v47 = sub_100155E64(a2, v41, &v90, v87);
        objc_storeStrong(v45 + 5, v90);
        *((unsigned char *)v102 + 24) = v47;
        id v48 = v88;
      }
    }
  }
  else
  {
    if (v6 != (id)2) {
      goto LABEL_25;
    }
    id v7 = [*(id *)(a1 + 32) keyset];
    uint64_t v8 = [v7 allKeys];
    int v9 = sqlite3_limit(*(sqlite3 **)(a2 + 64), 9, -1);
    v61[0] = _NSConcreteStackBlock;
    v61[1] = 3221225472;
    __int16 v62 = sub_10019FD18;
    uint64_t v63 = &unk_1003066C8;
    id v64 = *(id *)(a1 + 32);
    id v65 = *(id *)(a1 + 40);
    id v69 = &v101;
    uint64_t v10 = *(void **)(a1 + 64);
    uint64_t v71 = *(void *)(a1 + 72);
    uint64_t v72 = a2;
    id v70 = &v95;
    id v11 = v10;
    uint64_t v12 = *(void **)(a1 + 56);
    uint64_t v66 = *(void *)(a1 + 48);
    id v67 = v11;
    id v13 = v12;
    uint64_t v14 = *(void *)(a1 + 80);
    id v68 = v13;
    uint64_t v73 = v14;
    id v15 = v8;
    BOOL v16 = v61;
    id v17 = [v15 count];
    unint64_t v18 = (v9 & ~(v9 >> 31)) - 2;
    if (v18 >= 3 && v17)
    {
      char v105 = 0;
      unint64_t v19 = (unint64_t)[v15 count];
      if (v19 >= v18 / 3) {
        unint64_t v20 = v18 / 3;
      }
      else {
        unint64_t v20 = v19;
      }
      long long v21 = [v15 subarrayWithRange:0, v20];
      v62((uint64_t)v16, v21, &v105);
    }
    long long v22 = v64;
  }

LABEL_25:
  if (*((unsigned char *)v102 + 24))
  {
LABEL_26:
    uint64_t v55 = 1;
    goto LABEL_29;
  }
  uint64_t v55 = 0;
  if (a3) {
    *a3 = v96[5];
  }
LABEL_29:
  _Block_object_dispose(&v95, 8);

  _Block_object_dispose(&v101, 8);
  return v55;
}

void sub_10019F670(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 168), 8);
  _Block_object_dispose((const void *)(v1 - 120), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10019F6A8(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  id v6 = [*(id *)(a1 + 32) accessGroups];
  id v7 = [v6 entryAccessGroup];
  if (!sub_1001560B8(a2, 1, v7, a3))
  {

    return 0;
  }
  char v8 = sub_1001560B8(a2, 2, (const __CFString *)CKCurrentUserDefaultName, a3);

  if ((v8 & 1) == 0) {
    return 0;
  }
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1001A06DC;
  v12[3] = &unk_1003062E0;
  uint64_t v9 = *(void *)(a1 + 48);
  id v13 = *(id *)(a1 + 40);
  uint64_t v14 = a2;
  uint64_t v10 = sub_100156118(v9, a2, a3, v12);

  return v10;
}

uint64_t sub_10019F7CC(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  id v6 = [*(id *)(a1 + 32) accessGroups];
  id v7 = [v6 entryAccessGroup];
  if (!sub_1001560B8(a2, 1, v7, a3))
  {

    return 0;
  }
  char v8 = sub_1001560B8(a2, 2, (const __CFString *)CKCurrentUserDefaultName, a3);

  if ((v8 & 1) == 0) {
    return 0;
  }
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1001A06C0;
  v12[3] = &unk_1003062E0;
  uint64_t v9 = *(void *)(a1 + 48);
  id v13 = *(id *)(a1 + 40);
  uint64_t v14 = a2;
  uint64_t v10 = sub_100156118(v9, a2, a3, v12);

  return v10;
}

void sub_10019F8F0(uint64_t a1, void *a2, unsigned char *a3)
{
  id v5 = a2;
  id v6 = [*(id *)(a1 + 32) databaseScope];
  if (v6 == (id)3)
  {
    uint64_t v25 = (char *)[v5 count];
    for (CFIndex i = +[NSMutableArray arrayWithCapacity:v25];
      [i addObject:@"(?, ?, ?)"];
    id v27 = [i copy];

    int v28 = [v27 componentsJoinedByString:@", "];
    uint64_t v29 = [*(id *)(a1 + 40) columnNamesWithTableName:@"o"];
    id v30 = [v29 componentsJoinedByString:@", "];
    id v13 = +[NSString stringWithFormat:@"WITH keyset(ownr, zone, uuid) AS (VALUES %1$@)                                   SELECT %2$@                                   FROM sharingOutgoingQueue o                                   LEFT JOIN keyset k ON (k.ownr, k.zone) = (o.ownr, o.zone)                                   WHERE o.agrp = ? AND                                         o.ownr <> ? AND                                         (k.uuid IS NULL OR o.uuid > k.uuid)                                   ORDER BY o.ownr, o.zone, o.uuid                                   LIMIT %3$ld", v28, v30, *(void *)(a1 + 88)];

    uint64_t v31 = *(void *)(*(void *)(a1 + 80) + 8);
    id v32 = *(void **)(v31 + 40);
    id v15 = (void **)(v31 + 40);
    uint64_t v33 = *(void *)(a1 + 96);
    id v46 = v32;
    v42[0] = _NSConcreteStackBlock;
    v42[1] = 3221225472;
    v42[2] = sub_1001A0544;
    v42[3] = &unk_1003066A0;
    unint64_t v18 = &v44;
    id v44 = *(id *)(a1 + 56);
    unint64_t v19 = (id *)v43;
    id v34 = v5;
    uint64_t v35 = *(void *)(a1 + 48);
    v43[0] = v34;
    v43[1] = v35;
    v45[1] = *(void *)(a1 + 96);
    long long v22 = (id *)v45;
    v45[0] = *(id *)(a1 + 64);
    char v23 = sub_100155E64(v33, v13, &v46, v42);
    id v24 = v46;
  }
  else
  {
    if (v6 != (id)2)
    {
      unint64_t v38 = +[NSAssertionHandler currentHandler];
      uint64_t v39 = *(void *)(a1 + 104);
      uint64_t v40 = *(void *)(a1 + 48);
      [*(id *)(a1 + 32) databaseScope];
      uint64_t v41 = CKDatabaseScopeString();
      [v38 handleFailureInMethod:v39, v40, @"KCSharingStore.m", 2445, @"Can't fetch next batch of outgoing changes in all zones for database with %@ scope", v41 object file lineNumber description];

LABEL_12:
      *a3 = 1;
      goto LABEL_13;
    }
    id v7 = (char *)[v5 count];
    for (j = +[NSMutableArray arrayWithCapacity:v7];
      [j addObject:@"(?, ?, ?)"];
    id v9 = [j copy];

    uint64_t v10 = [v9 componentsJoinedByString:@", "];
    id v11 = [*(id *)(a1 + 40) columnNamesWithTableName:@"o"];
    uint64_t v12 = [v11 componentsJoinedByString:@", "];
    id v13 = +[NSString stringWithFormat:@"WITH keyset(ownr, zone, uuid) AS (VALUES %1$@)                                   SELECT %2$@                                   FROM sharingOutgoingQueue o                                   LEFT JOIN keyset k ON (k.ownr, k.zone) = (o.ownr, o.zone)                                   WHERE (o.agrp, o.ownr) = (?, ?) AND                                         (k.uuid IS NULL OR o.uuid > k.uuid)                                   ORDER BY o.zone, o.uuid                                   LIMIT %3$ld", v10, v12, *(void *)(a1 + 88)];

    uint64_t v14 = *(void *)(*(void *)(a1 + 80) + 8);
    BOOL v16 = *(void **)(v14 + 40);
    id v15 = (void **)(v14 + 40);
    uint64_t v17 = *(void *)(a1 + 96);
    id v51 = v16;
    v47[0] = _NSConcreteStackBlock;
    v47[1] = 3221225472;
    v47[2] = sub_1001A0400;
    v47[3] = &unk_1003066A0;
    unint64_t v18 = &v49;
    id v49 = *(id *)(a1 + 56);
    unint64_t v19 = (id *)v48;
    id v20 = v5;
    uint64_t v21 = *(void *)(a1 + 48);
    v48[0] = v20;
    v48[1] = v21;
    v50[1] = *(void *)(a1 + 96);
    long long v22 = (id *)v50;
    v50[0] = *(id *)(a1 + 64);
    char v23 = sub_100155E64(v17, v13, &v51, v47);
    id v24 = v51;
  }
  id v36 = v24;
  unint64_t v37 = *v15;
  *id v15 = v36;

  *(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) = v23;
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 8) + 24)) {
    goto LABEL_12;
  }
LABEL_13:
}

void sub_10019FD18(uint64_t a1, void *a2, unsigned char *a3)
{
  id v5 = a2;
  id v6 = [*(id *)(a1 + 32) databaseScope];
  if (v6 == (id)3)
  {
    uint64_t v25 = (char *)[v5 count];
    for (CFIndex i = +[NSMutableArray arrayWithCapacity:v25];
      [i addObject:@"(?, ?, ?)"];
    id v27 = [i copy];

    int v28 = [v27 componentsJoinedByString:@", "];
    uint64_t v29 = [*(id *)(a1 + 40) columnNamesWithTableName:@"o"];
    id v30 = [v29 componentsJoinedByString:@", "];
    id v13 = +[NSString stringWithFormat:@"WITH keyset(ownr, zone, uuid) AS (VALUES %1$@)                                   SELECT %2$@                                   FROM sharingOutgoingQueue o                                   JOIN keyset k ON (k.ownr, k.zone) = (o.ownr, o.zone) AND                                                    o.uuid > k.uuid                                   WHERE o.agrp = ? AND                                         o.ownr <> ?                                   ORDER BY o.ownr, o.zone, o.uuid                                   LIMIT %3$ld", v28, v30, *(void *)(a1 + 88)];

    uint64_t v31 = *(void *)(*(void *)(a1 + 80) + 8);
    id v32 = *(void **)(v31 + 40);
    id v15 = (void **)(v31 + 40);
    uint64_t v33 = *(void *)(a1 + 96);
    id v46 = v32;
    v42[0] = _NSConcreteStackBlock;
    v42[1] = 3221225472;
    v42[2] = sub_1001A0284;
    v42[3] = &unk_1003066A0;
    unint64_t v18 = &v44;
    id v44 = *(id *)(a1 + 56);
    unint64_t v19 = (id *)v43;
    id v34 = v5;
    uint64_t v35 = *(void *)(a1 + 48);
    v43[0] = v34;
    v43[1] = v35;
    v45[1] = *(void *)(a1 + 96);
    long long v22 = (id *)v45;
    v45[0] = *(id *)(a1 + 64);
    char v23 = sub_100155E64(v33, v13, &v46, v42);
    id v24 = v46;
  }
  else
  {
    if (v6 != (id)2)
    {
      unint64_t v38 = +[NSAssertionHandler currentHandler];
      uint64_t v39 = *(void *)(a1 + 104);
      uint64_t v40 = *(void *)(a1 + 48);
      [*(id *)(a1 + 32) databaseScope];
      uint64_t v41 = CKDatabaseScopeString();
      [v38 handleFailureInMethod:v39, v40, @"KCSharingStore.m", 2525, @"Can't fetch batch of outgoing changes in desired zones for database with %@ scope", v41 object file lineNumber description];

LABEL_12:
      *a3 = 1;
      goto LABEL_13;
    }
    id v7 = (char *)[v5 count];
    for (j = +[NSMutableArray arrayWithCapacity:v7];
      [j addObject:@"(?, ?, ?)"];
    id v9 = [j copy];

    uint64_t v10 = [v9 componentsJoinedByString:@", "];
    id v11 = [*(id *)(a1 + 40) columnNamesWithTableName:@"o"];
    uint64_t v12 = [v11 componentsJoinedByString:@", "];
    id v13 = +[NSString stringWithFormat:@"WITH keyset(ownr, zone, uuid) AS (VALUES %1$@)                                   SELECT %2$@                                   FROM sharingOutgoingQueue o                                   JOIN keyset k ON (k.ownr, k.zone) = (o.ownr, o.zone) AND                                                    o.uuid > k.uuid                                   WHERE (o.agrp, o.ownr) = (?, ?)                                   ORDER BY o.zone, o.uuid                                   LIMIT %3$ld", v10, v12, *(void *)(a1 + 88)];

    uint64_t v14 = *(void *)(*(void *)(a1 + 80) + 8);
    BOOL v16 = *(void **)(v14 + 40);
    id v15 = (void **)(v14 + 40);
    uint64_t v17 = *(void *)(a1 + 96);
    id v51 = v16;
    v47[0] = _NSConcreteStackBlock;
    v47[1] = 3221225472;
    v47[2] = sub_1001A0140;
    v47[3] = &unk_1003066A0;
    unint64_t v18 = &v49;
    id v49 = *(id *)(a1 + 56);
    unint64_t v19 = (id *)v48;
    id v20 = v5;
    uint64_t v21 = *(void *)(a1 + 48);
    v48[0] = v20;
    v48[1] = v21;
    v50[1] = *(void *)(a1 + 96);
    long long v22 = (id *)v50;
    v50[0] = *(id *)(a1 + 64);
    char v23 = sub_100155E64(v17, v13, &v51, v47);
    id v24 = v51;
  }
  id v36 = v24;
  unint64_t v37 = *v15;
  *id v15 = v36;

  *(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) = v23;
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 8) + 24)) {
    goto LABEL_12;
  }
LABEL_13:
}

uint64_t sub_1001A0140(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 48) + 16))();
  if ((v6 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v7 = v6;
  char v8 = [*(id *)(a1 + 40) accessGroups];
  id v9 = [v8 entryAccessGroup];
  if (!sub_1001560B8(a2, v7, v9, a3))
  {

    return 0;
  }
  char v10 = sub_1001560B8(a2, (v7 + 1), (const __CFString *)CKCurrentUserDefaultName, a3);

  if ((v10 & 1) == 0) {
    return 0;
  }
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_1001A03E4;
  v14[3] = &unk_1003062E0;
  uint64_t v11 = *(void *)(a1 + 64);
  id v15 = *(id *)(a1 + 56);
  BOOL v16 = a2;
  uint64_t v12 = sub_100156118(v11, a2, a3, v14);

  return v12;
}

uint64_t sub_1001A0284(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 48) + 16))();
  if ((v6 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v7 = v6;
  char v8 = [*(id *)(a1 + 40) accessGroups];
  id v9 = [v8 entryAccessGroup];
  if (!sub_1001560B8(a2, v7, v9, a3))
  {

    return 0;
  }
  char v10 = sub_1001560B8(a2, (v7 + 1), (const __CFString *)CKCurrentUserDefaultName, a3);

  if ((v10 & 1) == 0) {
    return 0;
  }
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_1001A03C8;
  v14[3] = &unk_1003062E0;
  uint64_t v11 = *(void *)(a1 + 64);
  id v15 = *(id *)(a1 + 56);
  BOOL v16 = a2;
  uint64_t v12 = sub_100156118(v11, a2, a3, v14);

  return v12;
}

uint64_t sub_1001A03C8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, void, uint64_t, uint64_t))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40), a2, a3);
}

uint64_t sub_1001A03E4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, void, uint64_t, uint64_t))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40), a2, a3);
}

uint64_t sub_1001A0400(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 48) + 16))();
  if ((v6 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v7 = v6;
  char v8 = [*(id *)(a1 + 40) accessGroups];
  id v9 = [v8 entryAccessGroup];
  if (!sub_1001560B8(a2, v7, v9, a3))
  {

    return 0;
  }
  char v10 = sub_1001560B8(a2, (v7 + 1), (const __CFString *)CKCurrentUserDefaultName, a3);

  if ((v10 & 1) == 0) {
    return 0;
  }
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_1001A06A4;
  v14[3] = &unk_1003062E0;
  uint64_t v11 = *(void *)(a1 + 64);
  id v15 = *(id *)(a1 + 56);
  BOOL v16 = a2;
  uint64_t v12 = sub_100156118(v11, a2, a3, v14);

  return v12;
}

uint64_t sub_1001A0544(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 48) + 16))();
  if ((v6 & 0x80000000) != 0) {
    return 0;
  }
  uint64_t v7 = v6;
  char v8 = [*(id *)(a1 + 40) accessGroups];
  id v9 = [v8 entryAccessGroup];
  if (!sub_1001560B8(a2, v7, v9, a3))
  {

    return 0;
  }
  char v10 = sub_1001560B8(a2, (v7 + 1), (const __CFString *)CKCurrentUserDefaultName, a3);

  if ((v10 & 1) == 0) {
    return 0;
  }
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_1001A0688;
  v14[3] = &unk_1003062E0;
  uint64_t v11 = *(void *)(a1 + 64);
  id v15 = *(id *)(a1 + 56);
  BOOL v16 = a2;
  uint64_t v12 = sub_100156118(v11, a2, a3, v14);

  return v12;
}

uint64_t sub_1001A0688(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, void, uint64_t, uint64_t))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40), a2, a3);
}

uint64_t sub_1001A06A4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, void, uint64_t, uint64_t))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40), a2, a3);
}

uint64_t sub_1001A06C0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, void, uint64_t, uint64_t))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40), a2, a3);
}

uint64_t sub_1001A06DC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(void, void, uint64_t, uint64_t))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40), a2, a3);
}

void sub_1001A0820(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_1001A0838(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = [*(id *)(a1 + 32) fetchOutgoingDatabaseItemWithRecordID:*(void *)(a1 + 40) inTransaction:a2 error:a3];
  if (v5)
  {
    uint64_t v6 = [(KCSharingOutgoingRow *)[KCSharingOutgoingEntry alloc] initWithOutgoingDatabaseItem:v5 error:a3];
    uint64_t v7 = v6;
    BOOL v8 = v6 != 0;
    if (v6)
    {
      uint64_t v9 = [(KCSharingOutgoingEntry *)v6 record];
      uint64_t v10 = *(void *)(*(void *)(a1 + 48) + 8);
      uint64_t v11 = *(void **)(v10 + 40);
      *(void *)(v10 + 40) = v9;
    }
  }
  else
  {
    BOOL v8 = 0;
  }

  return v8;
}

uint64_t sub_1001A09E4(void *a1, uint64_t a2, void *a3)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  void v9[2] = sub_1001A0A98;
  v9[3] = &unk_100306168;
  id v5 = (void *)a1[4];
  uint64_t v6 = (void *)a1[6];
  void v9[4] = a1[5];
  uint64_t v11 = a2;
  id v10 = v6;
  uint64_t v7 = sub_100155E64(a2, v5, a3, v9);

  return v7;
}

uint64_t sub_1001A0A98(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  uint64_t v6 = [*(id *)(a1 + 32) accessGroups];
  uint64_t v7 = [v6 entryAccessGroup];
  if (!sub_1001560B8(a2, 1, v7, a3)
    || !sub_1001560B8(a2, 2, (const __CFString *)CKCurrentUserDefaultName, a3))
  {

    return 0;
  }
  char v8 = sub_1001560B8(a2, 3, (const __CFString *)CKRecordNameZoneWideShare, a3);

  if ((v8 & 1) == 0) {
    return 0;
  }
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1001A0BE0;
  v12[3] = &unk_100306510;
  uint64_t v14 = a2;
  uint64_t v9 = *(void *)(a1 + 48);
  id v13 = *(id *)(a1 + 40);
  uint64_t v10 = sub_100156118(v9, a2, a3, v12);

  return v10;
}

uint64_t sub_1001A0BE0(uint64_t a1)
{
  id v2 = +[NSString stringWithUTF8String:sqlite3_column_text(*(sqlite3_stmt **)(a1 + 40), 0)];
  id v3 = [objc_alloc((Class)CKRecordZoneID) initWithZoneName:v2 ownerName:CKCurrentUserDefaultName];
  [*(id *)(a1 + 32) addObject:v3];

  return 1;
}

uint64_t sub_1001A0D70(void *a1, uint64_t a2, void *a3)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  void v9[2] = sub_1001A0E24;
  v9[3] = &unk_100306168;
  id v5 = (void *)a1[4];
  uint64_t v6 = (void *)a1[6];
  void v9[4] = a1[5];
  uint64_t v11 = a2;
  id v10 = v6;
  uint64_t v7 = sub_100155E64(a2, v5, a3, v9);

  return v7;
}

uint64_t sub_1001A0E24(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  uint64_t v6 = [*(id *)(a1 + 32) accessGroups];
  uint64_t v7 = [v6 entryAccessGroup];
  if (!sub_1001560B8(a2, 1, v7, a3)
    || !sub_1001560B8(a2, 2, (const __CFString *)CKCurrentUserDefaultName, a3))
  {

    return 0;
  }
  char v8 = sub_1001560B8(a2, 3, (const __CFString *)CKRecordNameZoneWideShare, a3);

  if ((v8 & 1) == 0) {
    return 0;
  }
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1001A0F6C;
  v12[3] = &unk_100306510;
  uint64_t v14 = a2;
  uint64_t v9 = *(void *)(a1 + 48);
  id v13 = *(id *)(a1 + 40);
  uint64_t v10 = sub_100156118(v9, a2, a3, v12);

  return v10;
}

uint64_t sub_1001A0F6C(uint64_t a1)
{
  id v2 = +[NSString stringWithUTF8String:sqlite3_column_text(*(sqlite3_stmt **)(a1 + 40), 0)];
  id v3 = [objc_alloc((Class)CKRecordZoneID) initWithZoneName:v2 ownerName:CKCurrentUserDefaultName];
  id v4 = [objc_alloc((Class)CKRecordZone) initWithZoneID:v3];
  [v4 setCapabilities:8];
  [*(id *)(a1 + 32) addObject:v4];

  return 1;
}

void sub_1001A1200(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va1, a10);
  va_start(va, a10);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1001A1228(void *a1, void *a2, unsigned char *a3)
{
  id v26 = a2;
  id v4 = (char *)[v26 count];
  for (CFIndex i = +[NSMutableArray arrayWithCapacity:v4];
    [i addObject:@"(?, ?, ?)"];
  id v6 = [i copy];

  uint64_t v7 = [v6 componentsJoinedByString:@", "];
  uint64_t v8 = +[NSString stringWithFormat:@"WITH recordIDs(ownr, zone, uuid) AS (VALUES %1$@)               DELETE FROM sharingOutgoingQueue               WHERE rowid IN(                  SELECT o.rowid FROM sharingOutgoingQueue o                   JOIN recordIDs d ON (d.ownr, d.zone, d.uuid) = (o.ownr, o.zone, o.uuid)                   WHERE o.agrp = ?              )", v7];

  uint64_t v9 = (char *)[v26 count];
  for (j = +[NSMutableArray arrayWithCapacity:v9];
    [j addObject:@"(?, ?, ?)"];
  id v11 = [j copy];

  uint64_t v12 = [v11 componentsJoinedByString:@", "];
  uint64_t v13 = +[NSString stringWithFormat:@"WITH recordIDs(ownr, zone, uuid) AS (VALUES %1$@)               DELETE FROM sharingMirror               WHERE rowid IN(                  SELECT m.rowid FROM sharingMirror m                   JOIN recordIDs d ON (d.ownr, d.zone, d.uuid) = (m.ownr, m.zone, m.uuid)                   WHERE m.agrp = ?              )", v12];

  long long v34 = 0u;
  long long v35 = 0u;
  long long v32 = 0u;
  long long v33 = 0u;
  uint64_t v25 = (void *)v8;
  v36[0] = v8;
  v36[1] = v13;
  uint64_t v14 = +[NSArray arrayWithObjects:v36 count:2];
  id v15 = [v14 countByEnumeratingWithState:&v32 objects:v37 count:16];
  if (v15)
  {
    id v16 = v15;
    uint64_t v17 = *(void *)v33;
LABEL_7:
    uint64_t v18 = 0;
    while (1)
    {
      if (*(void *)v33 != v17) {
        objc_enumerationMutation(v14);
      }
      unint64_t v19 = *(void **)(*((void *)&v32 + 1) + 8 * v18);
      uint64_t v20 = a1[7];
      uint64_t v21 = *(void *)(a1[6] + 8);
      id obj = *(id *)(v21 + 40);
      v27[0] = _NSConcreteStackBlock;
      v27[1] = 3221225472;
      v27[2] = sub_1001A1560;
      v27[3] = &unk_100306168;
      id v22 = v26;
      uint64_t v23 = a1[4];
      id v28 = v22;
      uint64_t v29 = v23;
      uint64_t v30 = a1[7];
      LOBYTE(v19) = sub_100155E64(v20, v19, &obj, v27);
      objc_storeStrong((id *)(v21 + 40), obj);
      *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = (_BYTE)v19;
      LODWORD(v19) = *(unsigned __int8 *)(*(void *)(a1[5] + 8) + 24);

      if (!v19) {
        break;
      }
      if (v16 == (id)++v18)
      {
        id v16 = [v14 countByEnumeratingWithState:&v32 objects:v37 count:16];
        if (v16) {
          goto LABEL_7;
        }
        break;
      }
    }
  }

  if (!*(unsigned char *)(*(void *)(a1[5] + 8) + 24)) {
    *a3 = 1;
  }
}

uint64_t sub_1001A1560(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  uint64_t v5 = a1;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  id obj = *(id *)(a1 + 32);
  id v31 = [obj countByEnumeratingWithState:&v33 objects:v37 count:16];
  if (v31)
  {
    uint64_t v32 = *(void *)v34;
    uint64_t v6 = 1;
    uint64_t v28 = v5;
    while (2)
    {
      uint64_t v7 = 0;
      do
      {
        uint64_t v8 = v6;
        if (*(void *)v34 != v32) {
          objc_enumerationMutation(obj);
        }
        uint64_t v9 = *(void **)(*((void *)&v33 + 1) + 8 * (void)v7);
        uint64_t v10 = [v9 zoneID];
        id v11 = [v10 ownerName];
        if (!sub_1001560B8(a2, v8, v11, a3)) {
          goto LABEL_16;
        }
        uint64_t v12 = [v9 zoneID];
        uint64_t v13 = [v12 zoneName];
        int v14 = v8 + 1;
        if (!sub_1001560B8(a2, (v8 + 1), v13, a3))
        {

LABEL_16:
LABEL_17:

          return 0;
        }
        int v30 = v8;
        uint64_t v15 = [v9 recordName];
        id v16 = a3;
        uint64_t v17 = (__CFString *)v15;
        int v18 = v8 + 2;
        unint64_t v19 = a2;
        uint64_t v20 = a2;
        uint64_t v21 = v16;
        int v22 = sub_1001560B8(v20, (v14 + 1), v17, v16);

        if (!v22) {
          goto LABEL_17;
        }
        uint64_t v7 = (char *)v7 + 1;
        uint64_t v6 = (v18 + 1);
        a3 = v21;
        a2 = v19;
      }
      while (v31 != v7);
      uint64_t v6 = (v30 + 3);
      uint64_t v5 = v28;
      id v31 = [obj countByEnumeratingWithState:&v33 objects:v37 count:16];
      if (v31) {
        continue;
      }
      break;
    }
  }
  else
  {
    uint64_t v6 = 1;
  }

  uint64_t v23 = [*(id *)(v5 + 40) accessGroups];
  id v24 = [v23 entryAccessGroup];
  uint64_t v25 = a3;
  int v26 = sub_1001560B8(a2, v6, v24, a3);

  if (v26) {
    return sub_100156118(*(void *)(v5 + 48), a2, v25, &stru_1003065D8);
  }
  else {
    return 0;
  }
}

BOOL sub_1001A17D8(id a1, BOOL *a2, id *a3)
{
  return 1;
}

void sub_1001A19DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001A19F4(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  uint64_t v6 = [*(id *)(a1 + 32) accessGroups];
  uint64_t v7 = [v6 entryAccessGroup];
  if ((sub_1001560B8(a2, 1, v7, a3) & 1) == 0) {
    goto LABEL_8;
  }
  uint64_t v8 = [*(id *)(a1 + 40) zoneID];
  uint64_t v9 = [v8 ownerName];
  if (!sub_1001560B8(a2, 2, v9, a3))
  {
LABEL_7:

LABEL_8:
    return 0;
  }
  uint64_t v10 = [*(id *)(a1 + 40) zoneID];
  id v11 = [v10 zoneName];
  if (!sub_1001560B8(a2, 3, v11, a3))
  {

    goto LABEL_7;
  }
  uint64_t v12 = [*(id *)(a1 + 40) recordName];
  int v17 = sub_1001560B8(a2, 4, v12, a3);

  if (!v17) {
    return 0;
  }
  uint64_t v13 = *(void *)(a1 + 64);
  v19[0] = _NSConcreteStackBlock;
  v19[1] = 3221225472;
  v19[2] = sub_1001A1BD4;
  v19[3] = &unk_100306590;
  long long v18 = *(_OWORD *)(a1 + 48);
  id v14 = (id)v18;
  long long v20 = v18;
  uint64_t v21 = a2;
  uint64_t v15 = sub_100156118(v13, a2, a3, v19);

  return v15;
}

BOOL sub_1001A1BD4(uint64_t a1, unsigned char *a2, uint64_t a3)
{
  uint64_t v5 = [*(id *)(a1 + 32) mapResultRow:*(void *)(a1 + 48) startingAt:0 error:a3];
  uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = v5;

  uint64_t v8 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
  if (v8) {
    *a2 = 1;
  }
  return v8 != 0;
}

uint64_t sub_1001A1CC4(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  uint64_t v6 = [*(id *)(a1 + 32) accessGroups];
  uint64_t v7 = [v6 entryAccessGroup];
  int v8 = sub_1001560B8(a2, 1, v7, a3);

  if (!v8) {
    return 0;
  }
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1001A1DB0;
  v12[3] = &unk_100306540;
  uint64_t v9 = *(void *)(a1 + 40);
  uint64_t v10 = *(void *)(a1 + 56);
  void v12[4] = *(void *)(a1 + 48);
  v12[5] = a2;
  v12[6] = v10;
  return sub_100156118(v9, a2, a3, v12);
}

uint64_t sub_1001A1DB0(uint64_t a1)
{
  if (*(void *)(a1 + 32)) {
    **(unsigned char **)(a1 + 32) = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 40), 0) == 1;
  }
  if (*(void *)(a1 + 48)) {
    **(unsigned char **)(a1 + 48) = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 40), 1) == 1;
  }
  return 1;
}

uint64_t sub_1001A1EC8(uint64_t a1, uint64_t a2, void *a3)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1001A1F6C;
  v8[3] = &unk_100306330;
  uint64_t v5 = *(void **)(a1 + 40);
  void v8[4] = *(void *)(a1 + 32);
  uint64_t v10 = a2;
  id v9 = v5;
  uint64_t v6 = sub_100156380(a2, a3, v8);

  return v6;
}

uint64_t sub_1001A1F6C(void *a1, void *a2)
{
  id v4 = (void *)a1[4];
  uint64_t v5 = a1[6];
  id v53 = 0;
  unsigned __int8 v6 = [v4 restageUnappliedMirrorEntriesInTransaction:v5 error:&v53];
  id v11 = v53;
  if (v6)
  {
    __int16 v52 = 0;
    uint64_t v12 = (void *)a1[4];
    uint64_t v13 = a1[6];
    id v51 = 0;
    unsigned __int8 v14 = [v12 hasIncomingEntries:(char *)&v52 + 1 deletions:&v52 inTransaction:v13 error:&v51];
    id v19 = v51;
    if ((v14 & 1) == 0)
    {
      sub_100047078(a2, 28, v19, @"Checking for incoming rows", v15, v16, v17, v18, v44);
      uint64_t v20 = 0;
      goto LABEL_18;
    }
    if (!v52)
    {
      uint64_t v20 = 1;
LABEL_18:

      goto LABEL_19;
    }
    uint64_t v21 = (void *)a1[4];
    if ((_BYTE)v52)
    {
      v46[0] = _NSConcreteStackBlock;
      v46[1] = 3221225472;
      v46[2] = sub_1001A21D8;
      v46[3] = &unk_100306330;
      v46[4] = v21;
      long long v45 = *(_OWORD *)(a1 + 5);
      id v22 = (id)v45;
      long long v47 = v45;
      uint64_t v20 = (uint64_t)[v21 withLocalFingerprintsTable:v46 inTransaction:a1[6] error:a2];

      goto LABEL_18;
    }
    uint64_t v23 = a1[6];
    id v50 = 0;
    unsigned __int8 v24 = [v21 resolveMergeConflictsInTransaction:v23 error:&v50];
    id v29 = v50;
    if (v24)
    {
      uint64_t v31 = a1[5];
      uint64_t v30 = a1[6];
      uint64_t v32 = (void *)a1[4];
      id v49 = v29;
      unsigned __int8 v33 = [v32 applyIncomingEntriesInTransaction:v30 updateInfos:v31 error:&v49];
      id v34 = v49;

      if ((v33 & 1) == 0)
      {
        sub_100047078(a2, 28, v34, @"Applying incoming entries", v35, v36, v37, v38, v44);
        uint64_t v20 = 0;
        id v29 = v34;
        goto LABEL_17;
      }
      uint64_t v39 = (void *)a1[4];
      uint64_t v40 = a1[6];
      id v48 = v34;
      unsigned __int8 v41 = [v39 resolveConflictingPrimaryKeysInTransaction:v40 error:&v48];
      id v29 = v48;

      if (v41)
      {
        uint64_t v20 = 1;
LABEL_17:

        goto LABEL_18;
      }
      id v42 = @"Resolving primary key conflicts";
    }
    else
    {
      id v42 = @"Resolving merge conflicts";
    }
    sub_100047078(a2, 28, v29, v42, v25, v26, v27, v28, v44);
    uint64_t v20 = 0;
    goto LABEL_17;
  }
  sub_100047078(a2, 28, v11, @"Restaging unapplied mirror entries", v7, v8, v9, v10, v44);
  uint64_t v20 = 0;
LABEL_19:

  return v20;
}

uint64_t sub_1001A21D8(void *a1, void *a2)
{
  uint64_t v4 = a1[6];
  uint64_t v5 = (void *)a1[4];
  uint64_t v6 = a1[5];
  id v40 = 0;
  unsigned __int8 v7 = [v5 applyIncomingShareDeletionsInTransaction:v4 updateInfos:v6 error:&v40];
  id v12 = v40;
  if ((v7 & 1) == 0)
  {
    uint64_t v32 = @"Applying incoming share deletions";
LABEL_8:
    sub_100047078(a2, 28, v12, v32, v8, v9, v10, v11, v35);
    uint64_t v31 = 0;
    goto LABEL_11;
  }
  uint64_t v13 = (void *)a1[4];
  uint64_t v14 = a1[6];
  id v39 = v12;
  unsigned __int8 v15 = [v13 resolveMergeConflictsInTransaction:v14 error:&v39];
  id v16 = v39;

  if ((v15 & 1) == 0)
  {
    unsigned __int8 v33 = @"Resolving merge conflicts";
LABEL_10:
    sub_100047078(a2, 28, v16, v33, v17, v18, v19, v20, v35);
    uint64_t v31 = 0;
    id v12 = v16;
    goto LABEL_11;
  }
  uint64_t v21 = (void *)a1[4];
  uint64_t v22 = a1[6];
  id v38 = v16;
  unsigned __int8 v23 = [v21 applyIncomingDeletionsInTransaction:v22 error:&v38];
  id v12 = v38;

  if ((v23 & 1) == 0)
  {
    uint64_t v32 = @"Applying incoming deletions";
    goto LABEL_8;
  }
  uint64_t v25 = a1[5];
  uint64_t v24 = a1[6];
  uint64_t v26 = (void *)a1[4];
  id v37 = v12;
  unsigned __int8 v27 = [v26 applyIncomingEntriesInTransaction:v24 updateInfos:v25 error:&v37];
  id v16 = v37;

  if ((v27 & 1) == 0)
  {
    unsigned __int8 v33 = @"Applying incoming entries";
    goto LABEL_10;
  }
  uint64_t v28 = (void *)a1[4];
  uint64_t v29 = a1[6];
  id v36 = v16;
  unsigned __int8 v30 = [v28 resolveConflictingPrimaryKeysInTransaction:v29 error:&v36];
  id v12 = v36;

  if ((v30 & 1) == 0)
  {
    uint64_t v32 = @"Resolving primary key conflicts";
    goto LABEL_8;
  }
  uint64_t v31 = 1;
LABEL_11:

  return v31;
}

uint64_t sub_1001A253C(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  uint64_t v6 = [*(id *)(a1 + 32) accessGroups];
  unsigned __int8 v7 = [v6 entryAccessGroup];
  int v8 = sub_1001560B8(a2, 1, v7, a3);

  if (!v8) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 56);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1001A2654;
  v12[3] = &unk_100306268;
  id v13 = *(id *)(a1 + 40);
  unsigned __int8 v15 = a2;
  id v14 = *(id *)(a1 + 48);
  uint64_t v10 = sub_100156118(v9, a2, a3, v12);

  return v10;
}

BOOL sub_1001A2654(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = *(void **)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 48);
  id v23 = 0;
  unsigned __int8 v7 = [v5 mapResultRow:v6 startingAt:0 error:&v23];
  id v12 = v23;
  if (v7)
  {
    id v22 = v12;
    id v13 = [[KCSharingMirrorEntry alloc] initWithMirrorDatabaseItem:v7 error:&v22];
    id v14 = v22;

    BOOL v19 = v13 != 0;
    if (v13)
    {
      uint64_t v20 = [*(id *)(a1 + 40) reinsertIntoLocal];
      [v20 addObject:v13];
    }
    else
    {
      sub_100047078(a3, 26, v14, @"Creating unapplied mirror entry", v15, v16, v17, v18, (uint64_t)v22);
    }
  }
  else
  {
    sub_100047078(a3, 25, v12, @"Creating database item for unapplied mirror entry", v8, v9, v10, v11, (uint64_t)v22);
    BOOL v19 = 0;
    id v14 = v12;
  }

  return v19;
}

uint64_t sub_1001A2B00(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  uint64_t v6 = [*(id *)(a1 + 32) accessGroups];
  unsigned __int8 v7 = [v6 entryAccessGroup];
  int v8 = sub_1001560B8(a2, 1, v7, a3);

  if (!v8) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 56);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1001A2DF8;
  v12[3] = &unk_100306268;
  id v13 = *(id *)(a1 + 40);
  uint64_t v15 = a2;
  id v14 = *(id *)(a1 + 48);
  uint64_t v10 = sub_100156118(v9, a2, a3, v12);

  return v10;
}

uint64_t sub_1001A2C18(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  uint64_t v6 = [*(id *)(a1 + 32) accessGroups];
  unsigned __int8 v7 = [v6 entryAccessGroup];
  int v8 = sub_1001560B8(a2, 1, v7, a3);

  if (!v8) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 56);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1001A2D30;
  v12[3] = &unk_100306268;
  id v13 = *(id *)(a1 + 40);
  uint64_t v15 = a2;
  id v14 = *(id *)(a1 + 48);
  uint64_t v10 = sub_100156118(v9, a2, a3, v12);

  return v10;
}

BOOL sub_1001A2D30(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = [*(id *)(a1 + 32) mapResultRow:*(void *)(a1 + 48) startingAt:0 error:a3];
  if (v5)
  {
    uint64_t v6 = [[KCSharingMirrorEntry alloc] initWithMirrorDatabaseItem:v5 error:a3];
    BOOL v7 = v6 != 0;
    if (v6)
    {
      int v8 = [[KCSharingMirrorEntry alloc] initWithMirrorEntry:v6 flags:4];
      uint64_t v9 = [*(id *)(a1 + 40) insertIntoMirror];
      [v9 addObject:v8];
    }
  }
  else
  {
    BOOL v7 = 0;
  }

  return v7;
}

BOOL sub_1001A2DF8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = [*(id *)(a1 + 32) mapResultRow:*(void *)(a1 + 48) startingAt:0 error:a3];
  if (v5)
  {
    uint64_t v6 = [[KCSharingMirrorEntry alloc] initWithMirrorDatabaseItem:v5 error:a3];
    BOOL v7 = v6 != 0;
    if (v6)
    {
      int v8 = [*(id *)(a1 + 40) reinsertIntoLocal];
      [v8 addObject:v6];
    }
  }
  else
  {
    BOOL v7 = 0;
  }

  return v7;
}

uint64_t sub_1001A30D8(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  uint64_t v6 = [*(id *)(a1 + 32) accessGroups];
  BOOL v7 = [v6 entryAccessGroup];
  if (!sub_1001560B8(a2, 1, v7, a3))
  {

    return 0;
  }
  char v8 = sub_1001560B8(a2, 2, (const __CFString *)CKRecordNameZoneWideShare, a3);

  if ((v8 & 1) == 0) {
    return 0;
  }
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1001A3390;
  v12[3] = &unk_100306510;
  id v14 = a2;
  uint64_t v9 = *(void *)(a1 + 48);
  id v13 = *(id *)(a1 + 40);
  uint64_t v10 = sub_100156118(v9, a2, a3, v12);

  return v10;
}

uint64_t sub_1001A3200(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  uint64_t v6 = [*(id *)(a1 + 32) accessGroups];
  BOOL v7 = [v6 entryAccessGroup];
  int v8 = sub_1001560B8(a2, 1, v7, a3);

  if (!v8) {
    return 0;
  }
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1001A3300;
  v12[3] = &unk_100306510;
  id v14 = a2;
  uint64_t v9 = *(void *)(a1 + 48);
  id v13 = *(id *)(a1 + 40);
  uint64_t v10 = sub_100156118(v9, a2, a3, v12);

  return v10;
}

BOOL sub_1001A3300(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = objc_opt_class();
  sqlite3_int64 v6 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  BOOL v7 = sub_10019D988(v5, v6, a3);
  if (v7)
  {
    int v8 = [*(id *)(a1 + 32) itemsToDelete];
    [v8 addObject:v7];
  }
  return v7 != 0;
}

uint64_t sub_1001A3390(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = objc_opt_class();
  sqlite3_int64 v6 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  BOOL v7 = sub_10019D988(v5, v6, a3);
  if (v7)
  {
    int v8 = [*(id *)(a1 + 32) itemsToDelete];
    [v8 addObject:v7];

    uint64_t v9 = objc_opt_class();
    sqlite3_int64 v10 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 1);
    uint64_t v11 = sub_10019D988(v9, v10, a3);
    if (v11)
    {
      id v12 = [*(id *)(a1 + 32) itemsToDelete];
      [v12 addObject:v11];

      sqlite3_int64 v13 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 2);
      if (v13 == 2)
      {
        sqlite3_int64 v21 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 4);
        id v22 = objc_opt_class();
        uint64_t v23 = sub_10019D988(v22, v21, a3);
        if (v23)
        {
          uint64_t v17 = (void *)v23;
          uint64_t v18 = KCSharingLogObject();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            int v26 = 134217984;
            sqlite3_int64 v27 = v21;
            BOOL v19 = "Preparing to delete inet rowid=%lli because of an incoming item deletion";
            goto LABEL_12;
          }
LABEL_13:

          uint64_t v24 = [*(id *)(a1 + 32) itemsToDelete];
          [v24 addObject:v17];

          goto LABEL_14;
        }
      }
      else
      {
        if (v13 != 1)
        {
LABEL_14:
          uint64_t v20 = 1;
LABEL_16:

          goto LABEL_17;
        }
        sqlite3_int64 v14 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 3);
        uint64_t v15 = objc_opt_class();
        uint64_t v16 = sub_10019D988(v15, v14, a3);
        if (v16)
        {
          uint64_t v17 = (void *)v16;
          uint64_t v18 = KCSharingLogObject();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            int v26 = 134217984;
            sqlite3_int64 v27 = v14;
            BOOL v19 = "Preparing to delete keys rowid=%lli because of an incoming item deletion";
LABEL_12:
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v19, (uint8_t *)&v26, 0xCu);
            goto LABEL_13;
          }
          goto LABEL_13;
        }
      }
    }
    uint64_t v20 = 0;
    goto LABEL_16;
  }
  uint64_t v20 = 0;
LABEL_17:

  return v20;
}

uint64_t sub_1001A37BC(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  sqlite3_int64 v6 = [*(id *)(a1 + 32) accessGroups];
  BOOL v7 = [v6 entryAccessGroup];
  if (!sub_1001560B8(a2, 1, v7, a3))
  {

    return 0;
  }
  char v8 = sub_1001560B8(a2, 2, (const __CFString *)CKRecordNameZoneWideShare, a3);

  if ((v8 & 1) == 0) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 56);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1001A38FC;
  v12[3] = &unk_100306268;
  id v13 = *(id *)(a1 + 40);
  uint64_t v15 = a2;
  id v14 = *(id *)(a1 + 48);
  uint64_t v10 = sub_100156118(v9, a2, a3, v12);

  return v10;
}

BOOL sub_1001A38FC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = [*(id *)(a1 + 32) mapResultRow:*(void *)(a1 + 48) startingAt:0 error:a3];
  if (v5)
  {
    sqlite3_int64 v6 = [(KCSharingIncomingRow *)[KCSharingIncomingEntry alloc] initWithIncomingDatabaseItem:v5 error:a3];
    BOOL v7 = v6 != 0;
    if (v6)
    {
      char v8 = [*(id *)(a1 + 40) insertIntoLocalAndMirror];
      [v8 addObject:v6];

      uint64_t v9 = [*(id *)(a1 + 40) itemsToDelete];
      [v9 addObject:v5];
    }
  }
  else
  {
    BOOL v7 = 0;
  }

  return v7;
}

uint64_t sub_1001A3E00(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  sqlite3_int64 v6 = [*(id *)(a1 + 32) accessGroups];
  BOOL v7 = [v6 entryAccessGroup];
  int v8 = sub_1001560B8(a2, 1, v7, a3);

  if (!v8) {
    return 0;
  }
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  v11[2] = sub_1001A478C;
  v11[3] = &unk_1003064C0;
  uint64_t v9 = *(void *)(a1 + 40);
  void v11[4] = *(void *)(a1 + 32);
  v11[5] = a2;
  void v11[6] = v9;
  return sub_100156118(v9, a2, a3, v11);
}

uint64_t sub_1001A3EE8(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  sqlite3_int64 v6 = [*(id *)(a1 + 32) accessGroups];
  BOOL v7 = [v6 entryAccessGroup];
  if (!sub_1001560B8(a2, 1, v7, a3))
  {

    return 0;
  }
  char v8 = sub_1001560B8(a2, 2, (const __CFString *)CKRecordNameZoneWideShare, a3);

  if ((v8 & 1) == 0) {
    return 0;
  }
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  v15[2] = sub_1001A4540;
  v15[3] = &unk_100306140;
  uint64_t v9 = *(void *)(a1 + 48);
  id v10 = *(id *)(a1 + 40);
  uint64_t v11 = *(void *)(a1 + 32);
  id v16 = v10;
  uint64_t v17 = v11;
  uint64_t v12 = *(void *)(a1 + 48);
  uint64_t v18 = a2;
  uint64_t v19 = v12;
  uint64_t v13 = sub_100156118(v9, a2, a3, v15);

  return v13;
}

uint64_t sub_1001A4018(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  sqlite3_int64 v6 = [*(id *)(a1 + 32) accessGroups];
  BOOL v7 = [v6 entryAccessGroup];
  if (sub_1001560B8(a2, 1, v7, a3))
  {
    char v8 = sub_1001560B8(a2, 2, (const __CFString *)CKRecordNameZoneWideShare, a3);

    if (v8)
    {
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 3221225472;
      v11[2] = sub_1001A43A4;
      v11[3] = &unk_1003064C0;
      uint64_t v9 = *(void *)(a1 + 40);
      void v11[4] = *(void *)(a1 + 32);
      v11[5] = a2;
      void v11[6] = v9;
      return sub_100156118(v9, a2, a3, v11);
    }
  }
  else
  {
  }
  return 0;
}

uint64_t sub_1001A4128(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  sqlite3_int64 v6 = [*(id *)(a1 + 32) accessGroups];
  BOOL v7 = [v6 entryAccessGroup];
  if (!sub_1001560B8(a2, 1, v7, a3))
  {

    return 0;
  }
  char v8 = sub_1001560B8(a2, 2, (const __CFString *)CKRecordNameZoneWideShare, a3);

  if ((v8 & 1) == 0) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 56);
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_1001A4274;
  v14[3] = &unk_1003064E8;
  id v15 = *(id *)(a1 + 40);
  uint64_t v18 = a2;
  id v10 = *(id *)(a1 + 48);
  uint64_t v11 = *(void *)(a1 + 32);
  id v16 = v10;
  uint64_t v17 = v11;
  uint64_t v19 = *(void *)(a1 + 56);
  uint64_t v12 = sub_100156118(v9, a2, a3, v14);

  return v12;
}

id sub_1001A4274(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = [*(id *)(a1 + 32) mapResultRow:*(void *)(a1 + 56) startingAt:0 error:a3];
  if (v5)
  {
    sqlite3_int64 v6 = [*(id *)(a1 + 40) mapResultRow:*(void *)(a1 + 56) startingAt:[*(id *)(a1 + 32) columnCount] error:a3];
    if (v6)
    {
      BOOL v7 = [[KCSharingMergeConflict alloc] initWithRemotelyChangedIncomingDatabaseItem:v5 locallyChangedOutgoingDatabaseItem:v6];
      char v8 = [*(id *)(a1 + 48) accessGroups];
      uint64_t v9 = [(KCSharingMergeConflict *)v7 resolveWithAccessGroups:v8 error:a3];

      if (v9)
      {
        uint64_t v10 = *(void *)(a1 + 64);
        uint64_t v11 = [*(id *)(a1 + 48) accessGroups];
        id v12 = [v9 applyInTransaction:v10 withAccessGroups:v11 error:a3];
      }
      else
      {
        id v12 = 0;
      }
    }
    else
    {
      id v12 = 0;
    }
  }
  else
  {
    id v12 = 0;
  }

  return v12;
}

id sub_1001A43A4(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = objc_opt_class();
  sqlite3_int64 v6 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  BOOL v7 = sub_10019D988(v5, v6, a3);
  if (v7)
  {
    char v8 = objc_opt_class();
    sqlite3_int64 v9 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 1);
    uint64_t v10 = sub_10019D988(v8, v9, a3);
    if (v10)
    {
      uint64_t v11 = objc_opt_class();
      sqlite3_int64 v12 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 2);
      uint64_t v13 = sub_10019D988(v11, v12, a3);
      if (v13)
      {
        id v14 = [[KCSharingMergeConflict alloc] initWithRemotelyDeletedIncomingDatabaseItem:v7 locallyChangedOutgoingDatabaseItem:v10 mirrorDatabaseItem:v13];
        id v15 = [*(id *)(a1 + 32) accessGroups];
        id v16 = [(KCSharingMergeConflict *)v14 resolveWithAccessGroups:v15 error:a3];

        if (v16)
        {
          uint64_t v17 = *(void *)(a1 + 48);
          uint64_t v18 = [*(id *)(a1 + 32) accessGroups];
          id v19 = [v16 applyInTransaction:v17 withAccessGroups:v18 error:a3];
        }
        else
        {
          id v19 = 0;
        }
      }
      else
      {
        id v19 = 0;
      }
    }
    else
    {
      id v19 = 0;
    }
  }
  else
  {
    id v19 = 0;
  }

  return v19;
}

id sub_1001A4540(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = [*(id *)(a1 + 32) mapResultRow:*(void *)(a1 + 48) startingAt:0 error:a3];
  if (v5)
  {
    sqlite3_int64 v6 = sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 48), [*(id *)(a1 + 32) columnCount] + 1);
    BOOL v7 = +[NSData dataWithBytes:length:](NSData, "dataWithBytes:length:", v6, sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 48), [*(id *)(a1 + 32) columnCount] + 1));
    char v8 = objc_opt_class();
    sqlite3_int64 v9 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 48), (int)[*(id *)(a1 + 32) columnCount]);
    CFDataRef v10 = v7;
    id v24 = 0;
    id v11 = [v8 databaseItemClass];
    sqlite3_int64 v12 = (void **)sub_10011ACF4((uint64_t)v11, (const __CFDictionary *)&__NSDictionary0__struct, dword_10035D2B0, (__CFString **)&v24);
    uint64_t v13 = v12;
    if (v12
      && (sub_10011B7D4(v12, v9, (__CFString **)&v24) & 1) != 0
      && (id v14 = (void *)sub_100118974([v8 databaseItemClass], 9, (__CFString **)&v24)) != 0
      && (sub_1001196B4((uint64_t)v13, v14, v10, (__CFString **)&v24) & 1) != 0)
    {
      id v15 = v13;
    }
    else
    {
      id v16 = v24;
      if (a3)
      {
        id v15 = 0;
        *a3 = v24;
        id v24 = 0;
      }
      else
      {
        if (v24)
        {
          id v24 = 0;
          CFRelease(v16);
        }
        id v15 = 0;
      }
    }

    if (v15)
    {
      uint64_t v18 = [[KCSharingMergeConflict alloc] initWithRemotelyChangedIncomingDatabaseItem:v5 locallyDeletedOutgoingDatabaseItem:v15];
      id v19 = [*(id *)(a1 + 40) accessGroups];
      uint64_t v20 = [(KCSharingMergeConflict *)v18 resolveWithAccessGroups:v19 error:a3];

      if (v20)
      {
        uint64_t v21 = *(void *)(a1 + 56);
        id v22 = [*(id *)(a1 + 40) accessGroups];
        id v17 = [v20 applyInTransaction:v21 withAccessGroups:v22 error:a3];
      }
      else
      {
        id v17 = 0;
      }
    }
    else
    {
      id v17 = 0;
    }
  }
  else
  {
    id v17 = 0;
  }

  return v17;
}

id sub_1001A478C(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = objc_opt_class();
  sqlite3_int64 v6 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  BOOL v7 = sub_10019D988(v5, v6, a3);
  if (v7)
  {
    char v8 = objc_opt_class();
    sqlite3_int64 v9 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 1);
    CFDataRef v10 = sub_10019D988(v8, v9, a3);
    if (v10)
    {
      id v11 = objc_opt_class();
      sqlite3_int64 v12 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 2);
      uint64_t v13 = sub_10019D988(v11, v12, a3);
      if (v13)
      {
        id v14 = [[KCSharingMergeConflict alloc] initWithRemotelyDeletedIncomingDatabaseItem:v7 locallyDeletedOutgoingDatabaseItem:v10 mirrorDatabaseItem:v13];
        id v15 = [*(id *)(a1 + 32) accessGroups];
        id v16 = [(KCSharingMergeConflict *)v14 resolveWithAccessGroups:v15 error:a3];

        if (v16)
        {
          uint64_t v17 = *(void *)(a1 + 48);
          uint64_t v18 = [*(id *)(a1 + 32) accessGroups];
          id v19 = [v16 applyInTransaction:v17 withAccessGroups:v18 error:a3];
        }
        else
        {
          id v19 = 0;
        }
      }
      else
      {
        id v19 = 0;
      }
    }
    else
    {
      id v19 = 0;
    }
  }
  else
  {
    id v19 = 0;
  }

  return v19;
}

void sub_1001A4C18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_1001A4C58(uint64_t a1, void *a2, unsigned char *a3)
{
  id v5 = a2;
  sqlite3_int64 v6 = (char *)[v5 count];
  for (CFIndex i = +[NSMutableArray arrayWithCapacity:v6];
    [i addObject:@"?"];
  id v8 = [i copy];

  sqlite3_int64 v9 = [v8 componentsJoinedByString:@", "];
  CFDataRef v10 = +[NSString stringWithFormat:@"SELECT lpk.rowid               FROM keys lpk               WHERE lpk.ggrp IN (%1$@)", v9];

  uint64_t v11 = *(void *)(a1 + 56);
  uint64_t v12 = *(void *)(*(void *)(a1 + 48) + 8);
  v33[0] = *(id *)(v12 + 40);
  v29[0] = _NSConcreteStackBlock;
  v29[1] = 3221225472;
  v29[2] = sub_1001A4F6C;
  v29[3] = &unk_100306308;
  id v13 = v5;
  uint64_t v14 = *(void *)(a1 + 56);
  id v30 = v13;
  uint64_t v32 = v14;
  id v31 = *(id *)(a1 + 32);
  LOBYTE(v11) = sub_100155E64(v11, v10, v33, v29);
  objc_storeStrong((id *)(v12 + 40), v33[0]);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v11;
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
  {
    id v15 = (char *)[v13 count];
    for (j = +[NSMutableArray arrayWithCapacity:v15];
      [j addObject:@"?"];
    id v17 = [j copy];

    uint64_t v18 = [v17 componentsJoinedByString:@", "];
    id v19 = +[NSString stringWithFormat:@"SELECT lip.rowid               FROM inet lip               WHERE lip.ggrp IN (%1$@)", v18];

    uint64_t v20 = *(void *)(a1 + 56);
    uint64_t v21 = *(void *)(*(void *)(a1 + 48) + 8);
    id obj = *(id *)(v21 + 40);
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 3221225472;
    v24[2] = sub_1001A510C;
    v24[3] = &unk_100306308;
    id v22 = v13;
    uint64_t v23 = *(void *)(a1 + 56);
    id v25 = v22;
    uint64_t v27 = v23;
    id v26 = *(id *)(a1 + 32);
    LOBYTE(v20) = sub_100155E64(v20, v19, &obj, v24);
    objc_storeStrong((id *)(v21 + 40), obj);
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v20;
    if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
      *a3 = 1;
    }
  }
  else
  {
    *a3 = 1;
  }
}

uint64_t sub_1001A4F6C(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  id v6 = *(id *)(a1 + 32);
  id v7 = [v6 countByEnumeratingWithState:&v18 objects:v22 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v19;
    uint64_t v10 = 1;
    while (2)
    {
      uint64_t v11 = 0;
      do
      {
        if (*(void *)v19 != v9) {
          objc_enumerationMutation(v6);
        }
        if (!sub_1001560B8(a2, (uint64_t)v11 + v10, *(const __CFString **)(*((void *)&v18 + 1) + 8 * (void)v11), a3))
        {
          uint64_t v13 = 0;
          goto LABEL_11;
        }
        uint64_t v11 = (char *)v11 + 1;
      }
      while (v8 != v11);
      uint64_t v10 = (v10 + v11);
      id v8 = [v6 countByEnumeratingWithState:&v18 objects:v22 count:16];
      if (v8) {
        continue;
      }
      break;
    }
  }

  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  v15[2] = sub_1001A53BC;
  v15[3] = &unk_1003062E0;
  id v17 = a2;
  uint64_t v12 = *(void *)(a1 + 48);
  id v16 = *(id *)(a1 + 40);
  uint64_t v13 = sub_100156118(v12, a2, a3, v15);
  id v6 = v16;
LABEL_11:

  return v13;
}

uint64_t sub_1001A510C(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  id v6 = *(id *)(a1 + 32);
  id v7 = [v6 countByEnumeratingWithState:&v18 objects:v22 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v19;
    uint64_t v10 = 1;
    while (2)
    {
      uint64_t v11 = 0;
      do
      {
        if (*(void *)v19 != v9) {
          objc_enumerationMutation(v6);
        }
        if (!sub_1001560B8(a2, (uint64_t)v11 + v10, *(const __CFString **)(*((void *)&v18 + 1) + 8 * (void)v11), a3))
        {
          uint64_t v13 = 0;
          goto LABEL_11;
        }
        uint64_t v11 = (char *)v11 + 1;
      }
      while (v8 != v11);
      uint64_t v10 = (v10 + v11);
      id v8 = [v6 countByEnumeratingWithState:&v18 objects:v22 count:16];
      if (v8) {
        continue;
      }
      break;
    }
  }

  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  v15[2] = sub_1001A52AC;
  v15[3] = &unk_1003062E0;
  id v17 = a2;
  uint64_t v12 = *(void *)(a1 + 48);
  id v16 = *(id *)(a1 + 40);
  uint64_t v13 = sub_100156118(v12, a2, a3, v15);
  id v6 = v16;
LABEL_11:

  return v13;
}

BOOL sub_1001A52AC(uint64_t a1, uint64_t a2, void *a3)
{
  sqlite3_int64 v5 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  id v6 = objc_opt_class();
  id v7 = sub_10019D988(v6, v5, a3);
  if (v7)
  {
    id v8 = KCSharingLogObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 134217984;
      sqlite3_int64 v11 = v5;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Preparing to delete inet rowid=%lli because we deleted its ggrp", (uint8_t *)&v10, 0xCu);
    }

    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }

  return v7 != 0;
}

BOOL sub_1001A53BC(uint64_t a1, uint64_t a2, void *a3)
{
  sqlite3_int64 v5 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  id v6 = objc_opt_class();
  id v7 = sub_10019D988(v6, v5, a3);
  if (v7)
  {
    id v8 = KCSharingLogObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 134217984;
      sqlite3_int64 v11 = v5;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Preparing to delete keys rowid=%lli because we deleted its ggrp", (uint8_t *)&v10, 0xCu);
    }

    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }

  return v7 != 0;
}

void sub_1001A56E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v13 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_1001A570C(uint64_t a1, void *a2, unsigned char *a3)
{
  sqlite3_int64 v5 = (char *)[a2 count];
  for (CFIndex i = +[NSMutableArray arrayWithCapacity:v5];
    [i addObject:@"(?, ?)"];
  id v7 = [i copy];

  id v8 = [v7 componentsJoinedByString:@", "];
  uint64_t v9 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"WITH zoneIDs(ownr, zone) AS (VALUES %1$@)               SELECT r.rowid               FROM %2$@ r               JOIN zoneIDs d ON (d.ownr, d.zone) = (r.ownr, r.zone)               WHERE r.agrp = ?", v8, *(void *)[*(id *)(a1 + 72) databaseItemClass]);

  uint64_t v10 = *(void *)(a1 + 80);
  uint64_t v11 = *(void *)(*(void *)(a1 + 64) + 8);
  id v20 = *(id *)(v11 + 40);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  v15[2] = sub_1001A58C4;
  v15[3] = &unk_100306448;
  id v12 = *(id *)(a1 + 32);
  uint64_t v13 = *(void *)(a1 + 40);
  uint64_t v14 = *(void **)(a1 + 48);
  id v16 = v12;
  uint64_t v17 = v13;
  int8x16_t v19 = vextq_s8(*(int8x16_t *)(a1 + 72), *(int8x16_t *)(a1 + 72), 8uLL);
  id v18 = v14;
  LOBYTE(v10) = sub_100155E64(v10, v9, &v20, v15);
  objc_storeStrong((id *)(v11 + 40), v20);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = v10;
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24)) {
    *a3 = 1;
  }
}

uint64_t sub_1001A58C4(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  uint64_t v5 = a1;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  id obj = *(id *)(a1 + 32);
  id v6 = [obj countByEnumeratingWithState:&v29 objects:v33 count:16];
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v30;
    uint64_t v9 = 1;
    uint64_t v23 = v5;
    while (2)
    {
      for (CFIndex i = 0; i != v7; CFIndex i = (char *)i + 1)
      {
        uint64_t v11 = v9;
        if (*(void *)v30 != v8) {
          objc_enumerationMutation(obj);
        }
        id v12 = *(void **)(*((void *)&v29 + 1) + 8 * i);
        uint64_t v13 = [v12 ownerName];
        if ((sub_1001560B8(a2, v11, v13, a3) & 1) == 0)
        {

LABEL_15:
          uint64_t v21 = 0;

          return v21;
        }
        uint64_t v14 = [v12 zoneName];
        int v15 = sub_1001560B8(a2, (v11 + 1), v14, a3);

        if (!v15) {
          goto LABEL_15;
        }
        uint64_t v9 = (v11 + 2);
      }
      uint64_t v9 = (v11 + 2);
      id v7 = [obj countByEnumeratingWithState:&v29 objects:v33 count:16];
      uint64_t v5 = v23;
      if (v7) {
        continue;
      }
      break;
    }
  }
  else
  {
    uint64_t v9 = 1;
  }

  id v16 = [*(id *)(v5 + 40) accessGroups];
  uint64_t v17 = [v16 entryAccessGroup];
  int v18 = sub_1001560B8(a2, v9, v17, a3);

  if (!v18) {
    return 0;
  }
  v25[0] = _NSConcreteStackBlock;
  v25[1] = 3221225472;
  v25[2] = sub_1001A5B24;
  v25[3] = &unk_1003063F8;
  uint64_t v20 = *(void *)(v5 + 56);
  uint64_t v19 = *(void *)(v5 + 64);
  uint64_t v27 = a2;
  uint64_t v28 = v19;
  id v26 = *(id *)(v5 + 48);
  uint64_t v21 = sub_100156118(v20, a2, a3, v25);

  return v21;
}

BOOL sub_1001A5B24(uint64_t a1, uint64_t a2, void *a3)
{
  sqlite3_int64 v5 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  id v6 = sub_10019D988(*(void **)(a1 + 48), v5, a3);
  if (v6) {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }

  return v6 != 0;
}

uint64_t sub_1001A5D14(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  id v6 = [*(id *)(a1 + 32) accessGroups];
  id v7 = [v6 entryAccessGroup];
  if (!sub_1001560B8(a2, 1, v7, a3)
    || !sub_1001560B8(a2, 2, (const __CFString *)CKRecordNameZoneWideShare, a3))
  {

    return 0;
  }
  char v8 = sub_1001560B8(a2, 3, @"group-", a3);

  if ((v8 & 1) == 0) {
    return 0;
  }
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1001A6020;
  v12[3] = &unk_1003062E0;
  uint64_t v14 = a2;
  uint64_t v9 = *(void *)(a1 + 48);
  id v13 = *(id *)(a1 + 40);
  uint64_t v10 = sub_100156118(v9, a2, a3, v12);

  return v10;
}

uint64_t sub_1001A5E58(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  id v6 = [*(id *)(a1 + 32) accessGroups];
  id v7 = [v6 entryAccessGroup];
  if (!sub_1001560B8(a2, 1, v7, a3)
    || !sub_1001560B8(a2, 2, (const __CFString *)CKRecordNameZoneWideShare, a3))
  {

    return 0;
  }
  char v8 = sub_1001560B8(a2, 3, @"group-", a3);

  if ((v8 & 1) == 0) {
    return 0;
  }
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1001A5F9C;
  v12[3] = &unk_1003062E0;
  uint64_t v14 = a2;
  uint64_t v9 = *(void *)(a1 + 48);
  id v13 = *(id *)(a1 + 40);
  uint64_t v10 = sub_100156118(v9, a2, a3, v12);

  return v10;
}

BOOL sub_1001A5F9C(uint64_t a1, uint64_t a2, void *a3)
{
  sqlite3_int64 v5 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  id v6 = objc_opt_class();
  id v7 = sub_10019D988(v6, v5, a3);
  if (v7) {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }

  return v7 != 0;
}

BOOL sub_1001A6020(uint64_t a1, uint64_t a2, void *a3)
{
  sqlite3_int64 v5 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  id v6 = objc_opt_class();
  id v7 = sub_10019D988(v6, v5, a3);
  if (v7) {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }

  return v7 != 0;
}

uint64_t sub_1001A61A0(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  id v6 = [*(id *)(a1 + 32) accessGroups];
  id v7 = [v6 entryAccessGroup];
  if (!sub_1001560B8(a2, 1, v7, a3))
  {

    return 0;
  }
  char v8 = sub_1001560B8(a2, 2, (const __CFString *)CKRecordNameZoneWideShare, a3);

  if ((v8 & 1) == 0) {
    return 0;
  }
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_1001A62CC;
  v13[3] = &unk_1003063F8;
  uint64_t v10 = *(void *)(a1 + 48);
  uint64_t v9 = *(void *)(a1 + 56);
  int v15 = a2;
  uint64_t v16 = v9;
  id v14 = *(id *)(a1 + 40);
  uint64_t v11 = sub_100156118(v10, a2, a3, v13);

  return v11;
}

uint64_t sub_1001A62CC(uint64_t a1, uint64_t a2, void *a3)
{
  sqlite3_int64 v5 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  CFDataRef v6 = +[NSString stringWithUTF8String:sqlite3_column_text(*(sqlite3_stmt **)(a1 + 40), 1)];
  CFDataRef v7 = +[NSString stringWithUTF8String:sqlite3_column_text(*(sqlite3_stmt **)(a1 + 40), 2)];
  char v8 = sub_10019D988(*(void **)(a1 + 48), v5, a3);
  if (!v8) {
    goto LABEL_13;
  }
  id v9 = [*(id *)(a1 + 48) databaseItemClass];
  if (v9 == (id)sub_10000C75C(@"sharingIncomingQueue", &qword_10035D050, (uint64_t)&unk_10035D048))
  {
    id v13 = 0;
    if (sub_10011A9B8((uint64_t)v8, @"zone", v6, (__CFString **)&v13))
    {
      if ((sub_10011A9B8((uint64_t)v8, kSecAttrUUID, v7, (__CFString **)&v13) & 1) != 0
        && (sub_10011A9B8((uint64_t)v8, @"deln", (const __CFData *)&off_100326770, (__CFString **)&v13) & 1) != 0)
      {
        goto LABEL_3;
      }
      id v11 = v13;
      if (a3)
      {
        *a3 = v13;
LABEL_13:
        uint64_t v10 = 0;
        goto LABEL_14;
      }
    }
    else
    {
      id v11 = v13;
      if (a3)
      {
        *a3 = v13;
        id v13 = 0;
        goto LABEL_13;
      }
    }
    if (v11)
    {
      id v13 = 0;
      CFRelease(v11);
    }
    goto LABEL_13;
  }
LABEL_3:
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  uint64_t v10 = 1;
LABEL_14:

  return v10;
}

void sub_1001A6748(uint64_t a1, uint64_t a2)
{
  id v3 = [*(id *)(a1 + 32) itemsToDelete];
  [v3 addObject:a2];
}

void sub_1001A679C(uint64_t a1, uint64_t a2)
{
  id v3 = [*(id *)(a1 + 32) itemsToDelete];
  [v3 addObject:a2];
}

void sub_1001A67F0(uint64_t a1, uint64_t a2)
{
  id v3 = [*(id *)(a1 + 32) itemsToDelete];
  [v3 addObject:a2];
}

uint64_t sub_1001A6914(uint64_t a1, uint64_t a2, void *a3)
{
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  void v9[2] = sub_1001A69D4;
  v9[3] = &unk_100306380;
  CFDataRef v6 = *(void **)(a1 + 40);
  void v9[4] = *(void *)(a1 + 32);
  id v10 = v6;
  id v11 = *(id *)(a1 + 48);
  uint64_t v12 = a2;
  uint64_t v7 = sub_100156380(a2, a3, v9);

  return v7;
}

id sub_1001A69D4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = [*(id *)(a1 + 32) plan];
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  id v5 = *(id *)(a1 + 40);
  id v6 = [v5 countByEnumeratingWithState:&v29 objects:v34 count:16];
  if (v6)
  {
    id v7 = v6;
    uint64_t v8 = *(void *)v30;
    do
    {
      id v9 = 0;
      do
      {
        if (*(void *)v30 != v8) {
          objc_enumerationMutation(v5);
        }
        id v10 = [[KCSharingOutgoingEntry alloc] initWithShare:*(void *)(*((void *)&v29 + 1) + 8 * (void)v9)];
        id v11 = [v4 insertIntoOutgoing];
        [v11 addObject:v10];

        id v9 = (char *)v9 + 1;
      }
      while (v7 != v9);
      id v7 = [v5 countByEnumeratingWithState:&v29 objects:v34 count:16];
    }
    while (v7);
  }

  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  id v12 = *(id *)(a1 + 48);
  id v13 = [v12 countByEnumeratingWithState:&v25 objects:v33 count:16];
  if (v13)
  {
    id v14 = v13;
    uint64_t v15 = *(void *)v26;
    do
    {
      uint64_t v16 = 0;
      do
      {
        if (*(void *)v26 != v15) {
          objc_enumerationMutation(v12);
        }
        uint64_t v17 = *(void *)(*((void *)&v25 + 1) + 8 * (void)v16);
        int v18 = [KCSharingOutgoingDeletion alloc];
        uint64_t v19 = -[KCSharingOutgoingDeletion initWithDeletedRecord:](v18, "initWithDeletedRecord:", v17, (void)v25);
        uint64_t v20 = [v4 insertIntoOutgoing];
        [v20 addObject:v19];

        uint64_t v16 = (char *)v16 + 1;
      }
      while (v14 != v16);
      id v14 = [v12 countByEnumeratingWithState:&v25 objects:v33 count:16];
    }
    while (v14);
  }

  uint64_t v21 = *(void *)(a1 + 56);
  id v22 = [*(id *)(a1 + 32) accessGroups];
  id v23 = [v4 applyInTransaction:v21 withAccessGroups:v22 error:a2];

  return v23;
}

uint64_t sub_1001A6DA0(uint64_t a1, uint64_t a2, void *a3)
{
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1001A6E40;
  v8[3] = &unk_100306330;
  id v5 = *(void **)(a1 + 40);
  void v8[4] = *(void *)(a1 + 32);
  id v9 = v5;
  uint64_t v10 = a2;
  uint64_t v6 = sub_100156380(a2, a3, v8);

  return v6;
}

id sub_1001A6E40(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = [*(id *)(a1 + 32) plan];
  id v5 = [v4 insertIntoIncoming];
  [v5 addObject:*(void *)(a1 + 40)];

  uint64_t v6 = *(void *)(a1 + 48);
  id v7 = [*(id *)(a1 + 32) accessGroups];
  id v8 = [v4 applyInTransaction:v6 withAccessGroups:v7 error:a2];

  return v8;
}

BOOL sub_1001A70C4(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = *(void **)(a1 + 32);
  id v23 = 0;
  uint64_t v6 = [v5 mapResultRow:a2 startingAt:0 error:&v23];
  id v11 = v23;
  if (v6)
  {
    id v22 = v11;
    id v12 = [[KCSharingMirrorEntry alloc] initWithMirrorDatabaseItem:v6 error:&v22];
    id v13 = v22;

    BOOL v18 = v12 != 0;
    if (v12)
    {
      uint64_t v19 = [[KCSharingOutgoingDeletion alloc] initWithDeletedLocalItemForMirrorEntry:v12];
      uint64_t v20 = [*(id *)(a1 + 40) insertIntoOutgoing];
      [v20 addObject:v19];
    }
    else
    {
      sub_100047078(a3, 26, v13, @"Creating mirror entry for outgoing deletion", v14, v15, v16, v17, (uint64_t)v22);
    }
  }
  else
  {
    sub_100047078(a3, 25, v11, @"Creating mirror database item for outgoing deletion", v7, v8, v9, v10, (uint64_t)v22);
    BOOL v18 = 0;
    id v13 = v11;
  }

  return v18;
}

uint64_t sub_1001A71FC(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  uint64_t v6 = [*(id *)(a1 + 32) accessGroups];
  uint64_t v7 = [v6 entryAccessGroup];
  int v8 = sub_1001560B8(a2, 1, v7, a3);

  if (!v8) {
    return 0;
  }
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1001A72F8;
  v12[3] = &unk_1003062E0;
  uint64_t v9 = *(void *)(a1 + 48);
  id v13 = *(id *)(a1 + 40);
  uint64_t v14 = a2;
  uint64_t v10 = sub_100156118(v9, a2, a3, v12);

  return v10;
}

uint64_t sub_1001A72F8(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40));
}

uint64_t sub_1001A7484(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  uint64_t v6 = [*(id *)(a1 + 32) accessGroups];
  uint64_t v7 = [v6 entryAccessGroup];
  if (!sub_1001560B8(a2, 1, v7, a3)
    || !sub_1001560B8(a2, 2, (const __CFString *)CKRecordNameZoneWideShare, a3))
  {

    return 0;
  }
  char v8 = sub_1001560B8(a2, 3, @"group-", a3);

  if ((v8 & 1) == 0) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 56);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1001A75E0;
  v12[3] = &unk_100306268;
  uint64_t v15 = a2;
  id v13 = *(id *)(a1 + 40);
  id v14 = *(id *)(a1 + 48);
  uint64_t v10 = sub_100156118(v9, a2, a3, v12);

  return v10;
}

uint64_t sub_1001A75E0(uint64_t a1)
{
  id v2 = +[NSString stringWithUTF8String:sqlite3_column_text(*(sqlite3_stmt **)(a1 + 48), 0)];
  id v3 = +[NSString stringWithUTF8String:sqlite3_column_text(*(sqlite3_stmt **)(a1 + 48), 1)];
  id v4 = [objc_alloc((Class)CKRecordZoneID) initWithZoneName:v3 ownerName:v2];
  id v5 = *(void **)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 48);
  id v15 = 0;
  uint64_t v7 = [v5 mapResultRow:v6 startingAt:2 error:&v15];
  id v8 = v15;
  if (v7)
  {
    id v14 = v8;
    uint64_t v9 = [[KCSharingLocalItem alloc] initPasswordWithInternetPasswordDatabaseItem:v7 error:&v14];
    id v10 = v14;

    if (v9)
    {
      id v11 = [[KCSharingOutgoingEntry alloc] initWithNewLocalItem:v9 zoneID:v4];
      id v12 = [*(id *)(a1 + 40) insertIntoOutgoing];
      [v12 addObject:v11];
    }
    else
    {
      KCSharingLogObject();
      id v11 = (KCSharingOutgoingEntry *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(&v11->super.super, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138478083;
        id v17 = v7;
        __int16 v18 = 2112;
        id v19 = v10;
        _os_log_error_impl((void *)&_mh_execute_header, &v11->super.super, OS_LOG_TYPE_ERROR, "Failed to create local item from databaseItem=%{private}@ for outgoing new password with error=%@", buf, 0x16u);
      }
    }
  }
  else
  {
    uint64_t v9 = KCSharingLogObject();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      id v17 = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to create password database item for outgoing new password with error=%@", buf, 0xCu);
    }
    id v10 = v8;
  }

  return 1;
}

uint64_t sub_1001A7A40(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  uint64_t v6 = [*(id *)(a1 + 32) accessGroups];
  uint64_t v7 = [v6 entryAccessGroup];
  int v8 = sub_1001560B8(a2, 1, v7, a3);

  if (!v8) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 64);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1001A7B6C;
  v12[3] = &unk_100306218;
  id v13 = *(id *)(a1 + 40);
  uint64_t v16 = a2;
  id v14 = *(id *)(a1 + 48);
  id v15 = *(id *)(a1 + 56);
  uint64_t v10 = sub_100156118(v9, a2, a3, v12);

  return v10;
}

uint64_t sub_1001A7B6C(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 56);
  id v22 = 0;
  id v4 = [v2 mapResultRow:v3 startingAt:0 error:&v22];
  id v5 = v22;
  if (v4)
  {
    uint64_t v21 = v5;
    uint64_t v6 = [[KCSharingMirrorEntry alloc] initWithMirrorDatabaseItem:v4 error:&v21];
    uint64_t v7 = v21;

    if (v6)
    {
      uint64_t v8 = *(void *)(a1 + 56);
      uint64_t v9 = *(void **)(a1 + 40);
      id v10 = [*(id *)(a1 + 32) columnCount];
      uint64_t v20 = v7;
      id v11 = [v9 mapResultRow:v8 startingAt:v10 error:&v20];
      p_super = v20;

      if (v11)
      {
        id v19 = p_super;
        id v13 = [[KCSharingLocalItem alloc] initPasswordWithInternetPasswordDatabaseItem:v11 error:&v19];
        id v14 = v19;

        if (v13)
        {
          __int16 v18 = v14;
          id v15 = [[KCSharingOutgoingEntry alloc] initWithUpdatedLocalItem:v13 forMirrorEntry:v6 error:&v18];
          p_super = v18;

          if (v15)
          {
            uint64_t v16 = [*(id *)(a1 + 48) insertIntoOutgoing];
            [v16 addObject:v15];
          }
          else
          {
            uint64_t v16 = KCSharingLogObject();
            if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 138412802;
              id v24 = v13;
              __int16 v25 = 2112;
              long long v26 = v6;
              __int16 v27 = 2112;
              long long v28 = p_super;
              _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Failed to create outgoing entry with localItem=%@ and mirrorEntry=%@ for outgoing changed password with error=%@", buf, 0x20u);
            }
          }
        }
        else
        {
          KCSharingLogObject();
          id v15 = (KCSharingOutgoingEntry *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(&v15->super.super, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138478083;
            id v24 = v11;
            __int16 v25 = 2112;
            long long v26 = v14;
            _os_log_error_impl((void *)&_mh_execute_header, &v15->super.super, OS_LOG_TYPE_ERROR, "Failed to create local item from databaseItem=%{private}@ for outgoing changed password with error=%@", buf, 0x16u);
          }
          p_super = &v14->super;
        }
      }
      else
      {
        id v13 = KCSharingLogObject();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138412290;
          id v24 = p_super;
          _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Failed to create password database item for outgoing changed password with error=%@", buf, 0xCu);
        }
      }

      uint64_t v7 = (KCSharingMirrorEntry *)p_super;
    }
    else
    {
      id v11 = KCSharingLogObject();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138478083;
        id v24 = v4;
        __int16 v25 = 2112;
        long long v26 = v7;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Failed to create mirror entry from databaseItem=%{private}@ for outgoing changed password with error=%@", buf, 0x16u);
      }
    }

    id v5 = &v7->super;
  }
  else
  {
    KCSharingLogObject();
    uint64_t v6 = (KCSharingMirrorEntry *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(&v6->super, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      id v24 = v5;
      _os_log_error_impl((void *)&_mh_execute_header, &v6->super, OS_LOG_TYPE_ERROR, "Failed to create mirror database item for outgoing changed password with error=%@", buf, 0xCu);
    }
  }

  return 1;
}

uint64_t sub_1001A8090(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  uint64_t v6 = [*(id *)(a1 + 32) accessGroups];
  uint64_t v7 = [v6 entryAccessGroup];
  if (!sub_1001560B8(a2, 1, v7, a3)
    || !sub_1001560B8(a2, 2, (const __CFString *)CKRecordNameZoneWideShare, a3))
  {

    return 0;
  }
  char v8 = sub_1001560B8(a2, 3, @"group-", a3);

  if ((v8 & 1) == 0) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 56);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1001A81EC;
  v12[3] = &unk_100306268;
  id v15 = a2;
  id v13 = *(id *)(a1 + 40);
  id v14 = *(id *)(a1 + 48);
  uint64_t v10 = sub_100156118(v9, a2, a3, v12);

  return v10;
}

uint64_t sub_1001A81EC(uint64_t a1)
{
  id v2 = +[NSString stringWithUTF8String:sqlite3_column_text(*(sqlite3_stmt **)(a1 + 48), 0)];
  uint64_t v3 = +[NSString stringWithUTF8String:sqlite3_column_text(*(sqlite3_stmt **)(a1 + 48), 1)];
  id v4 = [objc_alloc((Class)CKRecordZoneID) initWithZoneName:v3 ownerName:v2];
  id v5 = *(void **)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 48);
  id v15 = 0;
  uint64_t v7 = [v5 mapResultRow:v6 startingAt:2 error:&v15];
  id v8 = v15;
  if (v7)
  {
    id v14 = v8;
    uint64_t v9 = [[KCSharingLocalItem alloc] initPasskeyWithPrivateKeyDatabaseItem:v7 error:&v14];
    id v10 = v14;

    if (v9)
    {
      id v11 = [[KCSharingOutgoingEntry alloc] initWithNewLocalItem:v9 zoneID:v4];
      id v12 = [*(id *)(a1 + 40) insertIntoOutgoing];
      [v12 addObject:v11];
    }
    else
    {
      KCSharingLogObject();
      id v11 = (KCSharingOutgoingEntry *)objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(&v11->super.super, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138478083;
        id v17 = v7;
        __int16 v18 = 2112;
        id v19 = v10;
        _os_log_error_impl((void *)&_mh_execute_header, &v11->super.super, OS_LOG_TYPE_ERROR, "Failed to create local item from databaseItem=%{private}@ for outgoing new passkey with error=%@", buf, 0x16u);
      }
    }
  }
  else
  {
    uint64_t v9 = KCSharingLogObject();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      id v17 = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to create private key database item for outgoing new passkey with error=%@", buf, 0xCu);
    }
    id v10 = v8;
  }

  return 1;
}

uint64_t sub_1001A8648(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  uint64_t v6 = [*(id *)(a1 + 32) accessGroups];
  uint64_t v7 = [v6 entryAccessGroup];
  int v8 = sub_1001560B8(a2, 1, v7, a3);

  if (!v8) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 64);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1001A8774;
  v12[3] = &unk_100306218;
  id v13 = *(id *)(a1 + 40);
  uint64_t v16 = a2;
  id v14 = *(id *)(a1 + 48);
  id v15 = *(id *)(a1 + 56);
  uint64_t v10 = sub_100156118(v9, a2, a3, v12);

  return v10;
}

uint64_t sub_1001A8774(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 56);
  id v22 = 0;
  id v4 = [v2 mapResultRow:v3 startingAt:0 error:&v22];
  id v5 = v22;
  if (v4)
  {
    uint64_t v21 = v5;
    uint64_t v6 = [[KCSharingMirrorEntry alloc] initWithMirrorDatabaseItem:v4 error:&v21];
    uint64_t v7 = v21;

    if (v6)
    {
      uint64_t v8 = *(void *)(a1 + 56);
      uint64_t v9 = *(void **)(a1 + 40);
      id v10 = [*(id *)(a1 + 32) columnCount];
      uint64_t v20 = v7;
      id v11 = [v9 mapResultRow:v8 startingAt:v10 error:&v20];
      p_super = v20;

      if (v11)
      {
        id v19 = p_super;
        id v13 = [[KCSharingLocalItem alloc] initPasskeyWithPrivateKeyDatabaseItem:v11 error:&v19];
        id v14 = v19;

        if (v13)
        {
          __int16 v18 = v14;
          id v15 = [[KCSharingOutgoingEntry alloc] initWithUpdatedLocalItem:v13 forMirrorEntry:v6 error:&v18];
          p_super = v18;

          if (v15)
          {
            uint64_t v16 = [*(id *)(a1 + 48) insertIntoOutgoing];
            [v16 addObject:v15];
          }
          else
          {
            uint64_t v16 = KCSharingLogObject();
            if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 138412802;
              id v24 = v13;
              __int16 v25 = 2112;
              long long v26 = v6;
              __int16 v27 = 2112;
              long long v28 = p_super;
              _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Failed to create outgoing entry with localItem=%@ and mirrorEntry=%@ for outgoing changed passkey with error=%@", buf, 0x20u);
            }
          }
        }
        else
        {
          KCSharingLogObject();
          id v15 = (KCSharingOutgoingEntry *)objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(&v15->super.super, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138478083;
            id v24 = v11;
            __int16 v25 = 2112;
            long long v26 = v14;
            _os_log_error_impl((void *)&_mh_execute_header, &v15->super.super, OS_LOG_TYPE_ERROR, "Failed to create local item from databaseItem=%{private}@ for outgoing changed passkey with error=%@", buf, 0x16u);
          }
          p_super = &v14->super;
        }
      }
      else
      {
        id v13 = KCSharingLogObject();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138412290;
          id v24 = p_super;
          _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Failed to create private key database item for outgoing changed passkey with error=%@", buf, 0xCu);
        }
      }

      uint64_t v7 = (KCSharingMirrorEntry *)p_super;
    }
    else
    {
      id v11 = KCSharingLogObject();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138478083;
        id v24 = v4;
        __int16 v25 = 2112;
        long long v26 = v7;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Failed to create mirror entry from databaseItem=%{private}@ for outgoing changed passkey with error=%@", buf, 0x16u);
      }
    }

    id v5 = &v7->super;
  }
  else
  {
    KCSharingLogObject();
    uint64_t v6 = (KCSharingMirrorEntry *)objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(&v6->super, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      id v24 = v5;
      _os_log_error_impl((void *)&_mh_execute_header, &v6->super, OS_LOG_TYPE_ERROR, "Failed to create mirror database item for outgoing changed passkey with error=%@", buf, 0xCu);
    }
  }

  return 1;
}

uint64_t sub_1001A8B94(uint64_t a1, void *a2)
{
  v71[0] = _NSConcreteStackBlock;
  v71[1] = 3221225472;
  uint64_t v72 = sub_1001A8FC8;
  uint64_t v73 = &unk_1003060F0;
  long long v74 = *(_OWORD *)(a1 + 32);
  id v4 = v71;
  v75[0] = 0;
  char v6 = (uint64_t)v72((uint64_t)v4, (uint64_t)v75);
  id v7 = v75[0];
  id v8 = 0;
  if ((v6 & 1) == 0) {
    id v8 = v7;
  }

  id v13 = v8;
  if (v6)
  {
    v67[0] = _NSConcreteStackBlock;
    v67[1] = 3221225472;
    id v68 = sub_1001A904C;
    id v69 = &unk_1003060F0;
    long long v70 = *(_OWORD *)(a1 + 32);
    id v14 = v67;
    v75[0] = 0;
    char v16 = (uint64_t)v68((uint64_t)v14, (uint64_t)v75);
    id v17 = v75[0];
    id v18 = 0;
    if ((v16 & 1) == 0) {
      id v18 = v17;
    }

    id v23 = v18;
    if (v16)
    {
      v63[0] = _NSConcreteStackBlock;
      v63[1] = 3221225472;
      id v64 = sub_1001A90D0;
      id v65 = &unk_1003060F0;
      long long v66 = *(_OWORD *)(a1 + 32);
      id v24 = v63;
      v75[0] = 0;
      char v26 = (uint64_t)v64((uint64_t)v24, (uint64_t)v75);
      id v27 = v75[0];
      id v28 = 0;
      if ((v26 & 1) == 0) {
        id v28 = v27;
      }

      id v33 = v28;
      if (v26)
      {
        v59[0] = _NSConcreteStackBlock;
        v59[1] = 3221225472;
        id v60 = sub_1001A9154;
        id v61 = &unk_1003060F0;
        long long v62 = *(_OWORD *)(a1 + 32);
        id v34 = v59;
        v75[0] = 0;
        char v36 = (uint64_t)v60((uint64_t)v34, (uint64_t)v75);
        id v37 = v75[0];
        id v38 = 0;
        if ((v36 & 1) == 0) {
          id v38 = v37;
        }

        id v43 = v38;
        if (v36)
        {
          v55[0] = (uint64_t)_NSConcreteStackBlock;
          v55[1] = 3221225472;
          long long v56 = sub_1001A91D8;
          long long v57 = &unk_1003060F0;
          long long v58 = *(_OWORD *)(a1 + 32);
          uint64_t v44 = v55;
          v75[0] = 0;
          uint64_t v46 = (uint64_t)v56((uint64_t)v44, (uint64_t)v75);
          id v47 = v75[0];
          id v48 = 0;
          if ((v46 & 1) == 0) {
            id v48 = v47;
          }

          id v53 = v48;
          if ((v46 & 1) == 0) {
            sub_100047078(a2, 29, v53, @"Staging outgoing deletions", v49, v50, v51, v52, v55[0]);
          }
        }
        else
        {
          sub_100047078(a2, 29, v43, @"Staging outgoing entries for all new passwords", v39, v40, v41, v42, v55[0]);
          uint64_t v46 = 0;
        }
      }
      else
      {
        sub_100047078(a2, 29, v33, @"Staging outgoing entries for all changed passwords", v29, v30, v31, v32, v55[0]);
        uint64_t v46 = 0;
      }
    }
    else
    {
      sub_100047078(a2, 29, v23, @"Staging outgoing entries for all new passkeys", v19, v20, v21, v22, v55[0]);
      uint64_t v46 = 0;
    }
  }
  else
  {
    sub_100047078(a2, 29, v13, @"Staging outgoing entries for all changed passkeys", v9, v10, v11, v12, v55[0]);
    uint64_t v46 = 0;
  }

  return v46;
}

id sub_1001A8FC8(uint64_t a1, uint64_t a2)
{
  id v4 = [*(id *)(a1 + 32) stageAllOutgoingChangedPrivateKeysInTransaction:*(void *)(a1 + 40) error:a2];
  if (v4)
  {
    uint64_t v5 = *(void *)(a1 + 40);
    char v6 = [*(id *)(a1 + 32) accessGroups];
    id v7 = [v4 applyInTransaction:v5 withAccessGroups:v6 error:a2];
  }
  else
  {
    id v7 = 0;
  }

  return v7;
}

id sub_1001A904C(uint64_t a1, uint64_t a2)
{
  id v4 = [*(id *)(a1 + 32) stageAllOutgoingNewPrivateKeysInTransaction:*(void *)(a1 + 40) error:a2];
  if (v4)
  {
    uint64_t v5 = *(void *)(a1 + 40);
    char v6 = [*(id *)(a1 + 32) accessGroups];
    id v7 = [v4 applyInTransaction:v5 withAccessGroups:v6 error:a2];
  }
  else
  {
    id v7 = 0;
  }

  return v7;
}

id sub_1001A90D0(uint64_t a1, uint64_t a2)
{
  id v4 = [*(id *)(a1 + 32) stageAllOutgoingChangedPasswordsInTransaction:*(void *)(a1 + 40) error:a2];
  if (v4)
  {
    uint64_t v5 = *(void *)(a1 + 40);
    char v6 = [*(id *)(a1 + 32) accessGroups];
    id v7 = [v4 applyInTransaction:v5 withAccessGroups:v6 error:a2];
  }
  else
  {
    id v7 = 0;
  }

  return v7;
}

id sub_1001A9154(uint64_t a1, uint64_t a2)
{
  id v4 = [*(id *)(a1 + 32) stageAllOutgoingNewPasswordsInTransaction:*(void *)(a1 + 40) error:a2];
  if (v4)
  {
    uint64_t v5 = *(void *)(a1 + 40);
    char v6 = [*(id *)(a1 + 32) accessGroups];
    id v7 = [v4 applyInTransaction:v5 withAccessGroups:v6 error:a2];
  }
  else
  {
    id v7 = 0;
  }

  return v7;
}

id sub_1001A91D8(uint64_t a1, uint64_t a2)
{
  id v4 = [*(id *)(a1 + 32) stageAllOutgoingDeletionsInTransaction:*(void *)(a1 + 40) error:a2];
  if (v4)
  {
    uint64_t v5 = *(void *)(a1 + 40);
    char v6 = [*(id *)(a1 + 32) accessGroups];
    id v7 = [v4 applyInTransaction:v5 withAccessGroups:v6 error:a2];
  }
  else
  {
    id v7 = 0;
  }

  return v7;
}

uint64_t sub_1001A9394(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  char v6 = [*(id *)(a1 + 32) keyprint];
  if ((sub_1001560B8(a2, 1, v6, a3) & 1) == 0)
  {

    return 0;
  }
  id v7 = [*(id *)(a1 + 32) valueprint];
  int v8 = sub_1001560B8(a2, 2, v7, a3);

  if (!v8) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 40);

  return sub_100156118(v9, a2, a3, &stru_1003061F0);
}

BOOL sub_1001A9468(id a1, BOOL *a2, id *a3)
{
  return 1;
}

uint64_t sub_1001A95B8(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  uint64_t v6 = *(void *)(a1 + 48);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1001A9670;
  v12[3] = &unk_100306140;
  id v7 = *(id *)(a1 + 32);
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v9 = *(void *)(a1 + 48);
  id v13 = v7;
  uint64_t v14 = v8;
  id v15 = a2;
  uint64_t v16 = v9;
  uint64_t v10 = sub_100156118(v6, a2, a3, v12);

  return v10;
}

uint64_t sub_1001A9670(void *a1, uint64_t a2, void *a3)
{
  uint64_t v5 = (void *)a1[4];
  uint64_t v6 = a1[6];
  id v24 = 0;
  id v7 = [v5 mapResultRow:v6 startingAt:0 error:&v24];
  id v12 = v24;
  if (v7)
  {
    id v13 = (void *)a1[5];
    uint64_t v14 = a1[7];
    id v23 = v12;
    unsigned __int8 v15 = [v13 fingerprintPasswordDatabaseItem:v7 inTransaction:v14 error:&v23];
    id v16 = v23;

    if (v15)
    {
      uint64_t v21 = 1;
    }
    else
    {
      sub_100047078(a3, 25, v16, @"Fingerprinting password", v17, v18, v19, v20, (uint64_t)v23);
      uint64_t v21 = 0;
    }
    id v12 = v16;
  }
  else
  {
    sub_100047078(a3, 25, v12, @"Creating password database item for fingerprinting", v8, v9, v10, v11, (uint64_t)v23);
    uint64_t v21 = 0;
  }

  return v21;
}

uint64_t sub_1001A9898(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  uint64_t v6 = [*(id *)(a1 + 32) keyprint];
  if ((sub_1001560B8(a2, 1, v6, a3) & 1) == 0)
  {

    return 0;
  }
  id v7 = [*(id *)(a1 + 32) valueprint];
  int v8 = sub_1001560B8(a2, 2, v7, a3);

  if (!v8) {
    return 0;
  }
  uint64_t v9 = *(void *)(a1 + 40);

  return sub_100156118(v9, a2, a3, &stru_1003061A8);
}

BOOL sub_1001A996C(id a1, BOOL *a2, id *a3)
{
  return 1;
}

uint64_t sub_1001A9ABC(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  uint64_t v6 = *(void *)(a1 + 48);
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1001A9B74;
  v12[3] = &unk_100306140;
  id v7 = *(id *)(a1 + 32);
  uint64_t v8 = *(void *)(a1 + 40);
  uint64_t v9 = *(void *)(a1 + 48);
  id v13 = v7;
  uint64_t v14 = v8;
  unsigned __int8 v15 = a2;
  uint64_t v16 = v9;
  uint64_t v10 = sub_100156118(v6, a2, a3, v12);

  return v10;
}

uint64_t sub_1001A9B74(void *a1, uint64_t a2, void *a3)
{
  uint64_t v5 = (void *)a1[4];
  uint64_t v6 = a1[6];
  id v24 = 0;
  id v7 = [v5 mapResultRow:v6 startingAt:0 error:&v24];
  id v12 = v24;
  if (v7)
  {
    id v13 = (void *)a1[5];
    uint64_t v14 = a1[7];
    id v23 = v12;
    unsigned __int8 v15 = [v13 fingerprintPrivateKeyDatabaseItem:v7 inTransaction:v14 error:&v23];
    id v16 = v23;

    if (v15)
    {
      uint64_t v21 = 1;
    }
    else
    {
      sub_100047078(a3, 27, v16, @"Fingerprinting private key", v17, v18, v19, v20, (uint64_t)v23);
      uint64_t v21 = 0;
    }
    id v12 = v16;
  }
  else
  {
    sub_100047078(a3, 25, v12, @"Creating private key database item for fingerprinting", v8, v9, v10, v11, (uint64_t)v23);
    uint64_t v21 = 0;
  }

  return v21;
}

uint64_t sub_1001A9E60(uint64_t a1, uint64_t a2, void *a3)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  void v4[2] = sub_1001A9EDC;
  void v4[3] = &unk_1003060F0;
  void v4[4] = *(void *)(a1 + 32);
  void v4[5] = a2;
  return sub_100156380(a2, a3, v4);
}

id sub_1001A9EDC(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) stageAllOutgoingChangesInTransaction:*(void *)(a1 + 40) error:a2];
}

void sub_1001A9FAC(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001A9FC4(uint64_t *a1, uint64_t a2, void *a3)
{
  uint64_t v4 = a1[6];
  if (v4 == 2)
  {
    uint64_t v5 = @"SELECT EXISTS(                            SELECT 1 FROM sharingOutgoingQueue o                             WHERE (o.agrp, o.ownr) = (?1, ?2)                        )";
    goto LABEL_5;
  }
  if (v4 == 3)
  {
    uint64_t v5 = @"SELECT EXISTS(                            SELECT 1 FROM sharingOutgoingQueue o                             WHERE o.agrp = ?1 AND                                   o.ownr <> ?2                        )";
LABEL_5:
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    v11[2] = sub_1001AA0E8;
    v11[3] = &unk_1003060A0;
    uint64_t v13 = a2;
    long long v12 = *((_OWORD *)a1 + 2);
    return sub_100155E64(a2, v5, a3, v11);
  }
  id v7 = +[NSAssertionHandler currentHandler];
  uint64_t v8 = a1[4];
  uint64_t v9 = a1[7];
  uint64_t v10 = CKDatabaseScopeString();
  [v7 handleFailureInMethod:v9, v8, @"KCSharingStore.m", 302, @"Can't determine outgoing changes in database with %@ (%li) scope", v10, a1[6] object file lineNumber description];

  return 1;
}

uint64_t sub_1001AA0E8(uint64_t a1, sqlite3_stmt *a2, void *a3)
{
  uint64_t v6 = [*(id *)(a1 + 32) accessGroups];
  id v7 = [v6 entryAccessGroup];
  if (sub_1001560B8(a2, 1, v7, a3))
  {
    char v8 = sub_1001560B8(a2, 2, (const __CFString *)CKCurrentUserDefaultName, a3);

    if (v8)
    {
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 3221225472;
      v11[2] = sub_1001AA1F4;
      v11[3] = &unk_100306078;
      uint64_t v9 = *(void *)(a1 + 48);
      void v11[4] = *(void *)(a1 + 40);
      v11[5] = a2;
      return sub_100156118(v9, a2, a3, v11);
    }
  }
  else
  {
  }
  return 0;
}

uint64_t sub_1001AA1F4(uint64_t a1)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 40), 0) != 0;
  return 1;
}

void sub_1001AA844(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 80), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001AA86C(void *a1)
{
  uint64_t v2 = a1[4];
  uint64_t v3 = *(void *)(a1[6] + 8);
  id obj = *(id *)(v3 + 40);
  char v4 = (*(uint64_t (**)(void))(v2 + 16))();
  objc_storeStrong((id *)(v3 + 40), obj);
  *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = v4;
  return 1;
}

void sub_1001AC0B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id *location, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,id a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a65, 8);
  _Block_object_dispose(&STACK[0x3B0], 8);
  _Block_object_dispose(&STACK[0x270], 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001AC188(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1001AC198(uint64_t a1)
{
}

void sub_1001AC1A0(uint64_t a1)
{
  id v6 = [*(id *)(a1 + 32) zoneID];
  uint64_t v2 = [*(id *)(a1 + 32) contextID];
  uint64_t v3 = +[CKKSCurrentKeySet loadForZone:v6 contextID:v2];
  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;
}

char *sub_1001AC238(uint64_t a1)
{
  BOOL result = (char *)[*(id *)(a1 + 32) count];
  if ((unint64_t)&result[-*(void *)(a1 + 56)] <= 0x3E8)
  {
    uint64_t v3 = *(void *)(a1 + 40);
    uint64_t v4 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
    return (char *)+[SecurityAnalyticsReporterRTC sendMetricWithEvent:v3 success:v4 error:0];
  }
  return result;
}

void sub_1001AC2A4(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6 = a2;
  id v7 = a4;
  char v8 = [*(id *)(a1 + 32) zoneID];
  uint64_t v9 = [v8 zoneName];
  uint64_t v10 = sub_1000CD884(@"ckksshare", v9);

  if (v7)
  {
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      int v12 = 138412546;
      id v13 = v6;
      __int16 v14 = 2112;
      id v15 = v7;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "error on row: %@ %@", (uint8_t *)&v12, 0x16u);
    }
  }
  else if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = [v6 recordName];
    int v12 = 138412290;
    id v13 = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Successfully completed upload for record %@", (uint8_t *)&v12, 0xCu);
  }
}

void sub_1001AC410(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6 = a2;
  id v7 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 80));
  uint64_t v9 = [WeakRetained deps];
  uint64_t v10 = [v9 databaseProvider];
  __int16 v14 = _NSConcreteStackBlock;
  uint64_t v15 = 3221225472;
  id v16 = sub_1001AC56C;
  uint64_t v17 = &unk_1003069E8;
  id v18 = v7;
  id v19 = *(id *)(a1 + 32);
  id v20 = v6;
  id v21 = WeakRetained;
  long long v24 = *(_OWORD *)(a1 + 64);
  id v22 = *(id *)(a1 + 40);
  id v23 = *(id *)(a1 + 48);
  id v11 = v6;
  id v12 = v7;
  [v10 dispatchSyncWithSQLTransaction:&v14];

  id v13 = [WeakRetained operationQueue:v14, v15, v16, v17];
  [v13 addOperation:*(void *)(a1 + 56)];
}

uint64_t sub_1001AC56C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = [*(id *)(a1 + 40) zoneID];
  uint64_t v4 = [v3 zoneName];
  uint64_t v5 = sub_1000CD884(@"ckksshare", v4);

  if (v2)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      id v6 = *(CKKSTLKShareRecord **)(a1 + 32);
      *(_DWORD *)long long buf = 138412290;
      uint64_t v31 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Completed TLK Share heal operation with error: %@", buf, 0xCu);
    }

    [*(id *)(a1 + 64) populateUnderlyingErrorsStartingWithRootError:*(void *)(a1 + 32)];
    id v7 = [*(id *)(a1 + 56) deps];
    [v7 intransactionCKWriteFailed:*(void *)(a1 + 32) attemptedRecordsChanged:*(void *)(a1 + 72)];

    [*(id *)(a1 + 56) setCloudkitWriteFailures:1];
  }
  else
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Completed TLK Share heal operation with success", buf, 2u);
    }

    *(_DWORD *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) += [*(id *)(a1 + 48) count];
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    id obj = *(id *)(a1 + 48);
    id v8 = [obj countByEnumeratingWithState:&v26 objects:v32 count:16];
    if (v8)
    {
      id v9 = v8;
      uint64_t v10 = *(void *)v27;
      while (2)
      {
        for (CFIndex i = 0; i != v9; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v27 != v10) {
            objc_enumerationMutation(obj);
          }
          uint64_t v12 = *(void *)(*((void *)&v26 + 1) + 8 * i);
          id v13 = [CKKSTLKShareRecord alloc];
          __int16 v14 = [*(id *)(a1 + 56) deps];
          uint64_t v15 = [v14 contextID];
          id v16 = [(CKKSCKRecordHolder *)v13 initWithCKRecord:v12 contextID:v15];

          id v25 = 0;
          LODWORD(v15) = [(CKKSSQLDatabaseObject *)v16 saveToDatabase:&v25];
          uint64_t v17 = (CKKSTLKShareRecord *)v25;
          id v18 = [*(id *)(a1 + 40) zoneID];
          id v19 = [v18 zoneName];
          id v20 = sub_1000CD884(@"ckksshare", v19);

          if (v15) {
            BOOL v21 = v17 == 0;
          }
          else {
            BOOL v21 = 0;
          }
          if (!v21)
          {
            if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 138412290;
              uint64_t v31 = v17;
              _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Couldn't save new TLKShare record to database: %@", buf, 0xCu);
            }

            [*(id *)(a1 + 40) setViewKeyHierarchyState:@"error"];
            *(unsigned char *)(*(void *)(*(void *)(a1 + 88) + 8) + 24) = 0;
            [*(id *)(a1 + 64) populateUnderlyingErrorsStartingWithRootError:v17];

            goto LABEL_25;
          }
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138412290;
            uint64_t v31 = v16;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Successfully completed upload for %@", buf, 0xCu);
          }
        }
        id v9 = [obj countByEnumeratingWithState:&v26 objects:v32 count:16];
        if (v9) {
          continue;
        }
        break;
      }
    }
    uint64_t v17 = 0;
LABEL_25:
  }
  return 1;
}

void sub_1001ACE18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id *location, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,id a30)
{
}

void sub_1001ACE70(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v3 = [WeakRetained deps];
  uint64_t v4 = [v3 overallLaunch];
  [v4 addEvent:@"heal-tlk-shares-complete"];

  if ([WeakRetained failedDueToEssentialTrustState])
  {
    CFStringRef v5 = @"lose_trust";
LABEL_7:
    [WeakRetained setNextState:v5];
    goto LABEL_8;
  }
  if ([WeakRetained cloudkitWriteFailures])
  {
    id v6 = sub_1000CD884(@"ckksheal", 0);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v12 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Due to write failures, we'll retry later", v12, 2u);
    }

    CFStringRef v5 = @"healtlksharesfailed";
    goto LABEL_7;
  }
  id v9 = [WeakRetained intendedState];
  [WeakRetained setNextState:v9];

  if (![WeakRetained failedDueToLockState])
  {
    uint64_t v7 = *(void *)(a1 + 32);
    uint64_t v8 = 1;
    goto LABEL_9;
  }
  uint64_t v10 = *(void **)(a1 + 32);
  uint64_t v13 = kSecurityRTCFieldIsLocked;
  __int16 v14 = &__kCFBooleanFalse;
  id v11 = +[NSDictionary dictionaryWithObjects:&v14 forKeys:&v13 count:1];
  [v10 addMetrics:v11];

LABEL_8:
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v8 = 0;
LABEL_9:
  +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v7 success:v8 error:0];
}

void sub_1001AE4AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57)
{
}

void sub_1001AE520(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) peerID];
  uint64_t v3 = [*(id *)(a1 + 40) tlk];
  uint64_t v4 = [v3 contextID];
  CFStringRef v5 = [*(id *)(a1 + 40) tlk];
  id v6 = [v5 uuid];
  uint64_t v7 = [*(id *)(a1 + 40) tlk];
  uint64_t v8 = [v7 zoneID];
  uint64_t v9 = *(void *)(*(void *)(a1 + 56) + 8);
  id obj = *(id *)(v9 + 40);
  uint64_t v10 = +[CKKSTLKShareRecord allFor:v2 contextID:v4 keyUUID:v6 zoneID:v8 error:&obj];
  objc_storeStrong((id *)(v9 + 40), obj);
  uint64_t v11 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v12 = *(void **)(v11 + 40);
  *(void *)(v11 + 40) = v10;
}

void sub_1001AF2FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1001AF31C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1001AF6B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1001AF6D0(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1001AFC90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001AFCAC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1001AFCBC(uint64_t a1)
{
}

void sub_1001AFCC4(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = [a3 userInfo];
  id obj = [v4 objectForKeyedSubscript:@"CKRetryAfter"];

  CFStringRef v5 = obj;
  if (obj)
  {
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
    if (*(void *)(v6 + 40))
    {
      [obj doubleValue];
      double v8 = v7;
      [*(id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) doubleValue];
      CFStringRef v5 = obj;
      if (v8 >= v9) {
        goto LABEL_6;
      }
      uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
    }
    objc_storeStrong((id *)(v6 + 40), obj);
    CFStringRef v5 = obj;
  }
LABEL_6:
}

uint64_t sub_1001B057C(uint64_t a1)
{
  uint64_t v1 = a1;
  if ([*(id *)(a1 + 32) isCancelled])
  {
    uint64_t v2 = sub_1000CD884(@"ckksreencrypt", 0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "CKKSReencryptOutgoingItemsOperation cancelled, quitting", buf, 2u);
    }
LABEL_87:
    uint64_t v116 = 0;
    goto LABEL_88;
  }
  long long v155 = 0u;
  long long v156 = 0u;
  long long v153 = 0u;
  long long v154 = 0u;
  uint64_t v3 = [*(id *)(v1 + 32) deps];
  uint64_t v4 = [v3 activeManagedViews];

  id obj = v4;
  id v124 = [v4 countByEnumeratingWithState:&v153 objects:v164 count:16];
  if (!v124) {
    goto LABEL_82;
  }
  char v121 = 0;
  uint64_t v123 = *(void *)v154;
  uint64_t v137 = v1;
  do
  {
    uint64_t v5 = 0;
    do
    {
      if (*(void *)v154 != v123) {
        objc_enumerationMutation(obj);
      }
      uint64_t v6 = *(CKKSOutgoingQueueEntry **)(*((void *)&v153 + 1) + 8 * v5);
      double v7 = [(CKKSOutgoingQueueEntry *)v6 viewKeyHierarchyState];
      unsigned __int8 v8 = [v7 isEqualToString:@"ready"];

      if ((v8 & 1) == 0)
      {
        double v9 = [(CKKSOutgoingQueueEntry *)v6 zoneID];
        uint64_t v10 = [v9 zoneName];
        uint64_t v11 = sub_1000CD884(@"ckksreencrypt", v10);

        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          long long v158 = v6;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "View is %@; reencryption will likely fail",
            buf,
            0xCu);
        }
      }
      uint64_t v12 = [*(id *)(v1 + 32) deps];
      uint64_t v13 = [v12 contextID];
      __int16 v14 = [(CKKSOutgoingQueueEntry *)v6 zoneID];
      id v152 = 0;
      uint64_t v15 = +[CKKSOutgoingQueueEntry allInState:@"reencrypt" contextID:v13 zoneID:v14 error:&v152];
      uint64_t v2 = v152;

      if (v2)
      {
        __int16 v117 = [(CKKSOutgoingQueueEntry *)v6 zoneID];
        id v118 = [v117 zoneName];
        __int16 v119 = sub_1000CD884(@"ckksreencrypt", v118);

        if (os_log_type_enabled(v119, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138412290;
          long long v158 = (CKKSOutgoingQueueEntry *)v2;
          _os_log_impl((void *)&_mh_execute_header, v119, OS_LOG_TYPE_ERROR, "Error fetching oqes from database: %@", buf, 0xCu);
        }

        [*(id *)(v1 + 32) setError:v2];
        goto LABEL_87;
      }
      uint64_t v126 = v5;
      id v16 = [(CKKSOutgoingQueueEntry *)v6 zoneID];
      uint64_t v17 = [v16 zoneName];
      +[CKKSPowerCollection CKKSPowerEvent:zone:count:](CKKSPowerCollection, "CKKSPowerEvent:zone:count:", @"reencryptOutgoing", v17, [v15 count]);

      id v133 = objc_alloc_init(CKKSMemoryKeyCache);
      long long v148 = 0u;
      long long v149 = 0u;
      long long v150 = 0u;
      long long v151 = 0u;
      id v134 = v15;
      id v136 = [v134 countByEnumeratingWithState:&v148 objects:v163 count:16];
      if (v136)
      {
        uint64_t v135 = *(void *)v149;
        id v130 = v6;
        do
        {
          id v18 = 0;
          do
          {
            id v19 = v6;
            if (*(void *)v149 != v135) {
              objc_enumerationMutation(v134);
            }
            id v20 = *(CKKSOutgoingQueueEntry **)(*((void *)&v148 + 1) + 8 * (void)v18);
            BOOL v21 = [(CKKSOutgoingQueueEntry *)v20 uuid];
            id v22 = [*(id *)(v1 + 32) deps];
            id v23 = [v22 contextID];
            long long v24 = [(CKKSOutgoingQueueEntry *)v20 item];
            id v25 = [v24 zoneID];
            id v147 = 0;
            long long v26 = +[CKKSOutgoingQueueEntry tryFromDatabase:v21 state:@"new" contextID:v23 zoneID:v25 error:&v147];
            long long v27 = (CKKSOutgoingQueueEntry *)v147;

            uint64_t v6 = v19;
            if (v27)
            {
              long long v28 = [(CKKSOutgoingQueueEntry *)v19 zoneID];
              long long v29 = [v28 zoneName];
              uint64_t v30 = sub_1000CD884(@"ckksreencrypt", v29);

              if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 138412290;
                long long v158 = v27;
                _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "Couldn't load 'new' OQE to determine status: %@", buf, 0xCu);
              }

              uint64_t v1 = v137;
              goto LABEL_23;
            }
            uint64_t v31 = [(CKKSOutgoingQueueEntry *)v19 zoneID];
            uint64_t v32 = [v31 zoneName];
            id v33 = sub_1000CD884(@"ckksreencrypt", v32);

            BOOL v34 = os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT);
            if (!v26)
            {
              if (v34)
              {
                *(_DWORD *)long long buf = 138412290;
                long long v158 = v20;
                _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "Reencrypting item %@", buf, 0xCu);
              }

              uint64_t v39 = [(CKKSOutgoingQueueEntry *)v20 item];
              id v145 = 0;
              long long v27 = +[CKKSItemEncrypter decryptItemToDictionary:v39 keyCache:v133 error:&v145];
              uint64_t v40 = (CKKSOutgoingQueueEntry *)v145;

              if (v40)
              {
                uint64_t v41 = [(CKKSOutgoingQueueEntry *)v40 domain];
                if ([v41 isEqualToString:@"securityd"])
                {
                  uint64_t v42 = v40;
                  id v43 = [(CKKSOutgoingQueueEntry *)v40 code];

                  uint64_t v6 = v19;
                  if (v43 == (id)-25300)
                  {
                    uint64_t v44 = [(CKKSOutgoingQueueEntry *)v19 zoneID];
                    long long v45 = [v44 zoneName];
                    uint64_t v46 = sub_1000CD884(@"ckksreencrypt", v45);

                    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)long long buf = 138412290;
                      long long v158 = v42;
                      _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "Couldn't find key in keychain; asking for reset: %@",
                        buf,
                        0xCu);
                    }

                    uint64_t v1 = v137;
                    id v47 = [*(id *)(v137 + 32) deps];
                    id v48 = [v47 flagHandler];
                    [v48 _onqueueHandleFlag:@"key_process_requested"];

                    [*(id *)(v137 + 32) setNextState:@"unhealthy"];
                    long long v26 = 0;
                    uint64_t v49 = v42;
                    goto LABEL_50;
                  }
                }
                else
                {
                  uint64_t v42 = v40;

                  uint64_t v6 = v19;
                }
                id v61 = [(CKKSOutgoingQueueEntry *)v6 zoneID];
                long long v62 = [v61 zoneName];
                uint64_t v63 = sub_1000CD884(@"ckksreencrypt", v62);

                uint64_t v49 = v42;
                if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)long long buf = 138412546;
                  long long v158 = v20;
                  __int16 v159 = 2112;
                  long long v160 = v42;
                  _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "Couldn't decrypt item %@: %@", buf, 0x16u);
                }

                uint64_t v1 = v137;
                long long v26 = 0;
LABEL_50:
                [*(id *)(v1 + 32) setError:v49];
              }
              else
              {
                id v131 = [(CKKSOutgoingQueueEntry *)v20 item];
                uint64_t v50 = [v131 parentKeyUUID];
                uint64_t v51 = [*(id *)(v137 + 32) deps];
                uint64_t v52 = [v51 contextID];
                id v53 = [(CKKSOutgoingQueueEntry *)v19 zoneID];
                id v144 = 0;
                char v54 = [(CKKSMemoryKeyCache *)v133 loadKeyForUUID:v50 contextID:v52 zoneID:v53 error:&v144];
                uint64_t v55 = (CKKSOutgoingQueueEntry *)v144;

                if (v55)
                {
                  uint64_t v49 = v54;
                  uint64_t v6 = v130;
                  long long v56 = [(CKKSOutgoingQueueEntry *)v130 zoneID];
                  long long v57 = [v56 zoneName];
                  long long v58 = sub_1000CD884(@"ckksreencrypt", v57);

                  if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
                  {
                    uint64_t v59 = [(CKKSOutgoingQueueEntry *)v20 item];
                    id v60 = [v59 parentKeyUUID];
                    *(_DWORD *)long long buf = 138412802;
                    long long v158 = v60;
                    __int16 v159 = 2112;
                    long long v160 = v20;
                    __int16 v161 = 2112;
                    id v162 = v55;
                    _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_ERROR, "Couldn't fetch key (%@) for item %@: %@", buf, 0x20u);
                  }
                  uint64_t v1 = v137;
                  [*(id *)(v137 + 32) setError:v55];
                  long long v26 = 0;
                }
                else
                {
                  id v132 = v54;
                  long long v128 = [(CKKSOutgoingQueueEntry *)v54 keyclass];
                  id v64 = [*(id *)(v137 + 32) deps];
                  id v65 = [v64 contextID];
                  long long v66 = [(CKKSOutgoingQueueEntry *)v130 zoneID];
                  id v143 = 0;
                  id v67 = [(CKKSMemoryKeyCache *)v133 currentKeyForClass:v128 contextID:v65 zoneID:v66 error:&v143];
                  id v68 = v143;

                  uint64_t v55 = v67;
                  id v69 = [(CKKSOutgoingQueueEntry *)v130 contextID];
                  id v142 = v68;
                  id v70 = [(CKKSOutgoingQueueEntry *)v67 ensureKeyLoadedForContextID:v69 cache:v133 error:&v142];
                  uint64_t v71 = (CKKSOutgoingQueueEntry *)v142;

                  if (v71)
                  {
                    uint64_t v6 = v130;
                    uint64_t v72 = [(CKKSOutgoingQueueEntry *)v130 zoneID];
                    uint64_t v73 = [v72 zoneName];
                    long long v74 = sub_1000CD884(@"ckksreencrypt", v73);

                    if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
                    {
                      uint64_t v75 = [(CKKSOutgoingQueueEntry *)v132 keyclass];
                      *(_DWORD *)long long buf = 138412546;
                      long long v158 = v75;
                      __int16 v159 = 2112;
                      long long v160 = v71;
                      _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_ERROR, "Couldn't fetch the current key for class %@: %@", buf, 0x16u);
                    }
                    uint64_t v1 = v137;
                    [*(id *)(v137 + 32) setError:v71];
                    uint64_t v76 = v71;
                    long long v26 = 0;
                    uint64_t v49 = v132;
                  }
                  else
                  {
                    long long v127 = v55;
                    id v77 = [(CKKSOutgoingQueueEntry *)v20 item];
                    id v78 = [v77 uuid];
                    uint64_t v79 = [*(id *)(v137 + 32) deps];
                    id v80 = [v79 contextID];
                    id v81 = [(CKKSOutgoingQueueEntry *)v130 zoneID];
                    id v141 = 0;
                    long long v129 = +[CKKSMirrorEntry tryFromDatabase:v78 contextID:v80 zoneID:v81 error:&v141];
                    uint64_t v82 = (CKKSOutgoingQueueEntry *)v141;

                    if (v82)
                    {
                      uint64_t v6 = v130;
                      CFStringRef v83 = [(CKKSOutgoingQueueEntry *)v130 zoneID];
                      uint64_t v84 = [v83 zoneName];
                      uint64_t v85 = sub_1000CD884(@"ckksreencrypt", v84);

                      if (os_log_type_enabled(v85, OS_LOG_TYPE_ERROR))
                      {
                        uint64_t v86 = [(CKKSOutgoingQueueEntry *)v20 item];
                        char v87 = [v86 parentKeyUUID];
                        *(_DWORD *)long long buf = 138412802;
                        long long v158 = v87;
                        __int16 v159 = 2112;
                        long long v160 = v20;
                        __int16 v161 = 2112;
                        id v162 = v82;
                        _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_ERROR, "Couldn't fetch ckme (%@) for item %@: %@", buf, 0x20u);
                      }
                      uint64_t v1 = v137;
                      id v88 = v82;
                      [*(id *)(v137 + 32) setError:v82];
                      long long v26 = 0;
                      uint64_t v49 = v132;
                      uint64_t v55 = v127;
                    }
                    else
                    {
                      uint64_t v89 = [(CKKSOutgoingQueueEntry *)v20 item];
                      id v90 = [(CKKSOutgoingQueueEntry *)v129 item];
                      id v140 = 0;
                      uint64_t v91 = +[CKKSItemEncrypter encryptCKKSItem:v89 dataDictionary:v27 updatingCKKSItem:v90 parentkey:v127 keyCache:v133 error:&v140];
                      id v92 = (CKKSOutgoingQueueEntry *)v140;

                      if (v92)
                      {
                        uint64_t v93 = (CKKSOutgoingQueueEntry *)v91;
                        uint64_t v6 = v19;
                        id v94 = [(CKKSOutgoingQueueEntry *)v19 zoneID];
                        uint64_t v95 = [v94 zoneName];
                        id v96 = sub_1000CD884(@"ckksreencrypt", v95);

                        uint64_t v55 = v127;
                        if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
                        {
                          *(_DWORD *)long long buf = 138412546;
                          long long v158 = v127;
                          __int16 v159 = 2112;
                          long long v160 = v92;
                          _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_ERROR, "Couldn't encrypt under the new key %@: %@", buf, 0x16u);
                        }

                        uint64_t v1 = v137;
                        [*(id *)(v137 + 32) setError:v92];
                        uint64_t v97 = v92;
                        long long v26 = 0;
                        uint64_t v49 = v132;
                        id v88 = v93;
                      }
                      else
                      {
                        long long v98 = [CKKSOutgoingQueueEntry alloc];
                        long long v99 = [(CKKSOutgoingQueueEntry *)v20 action];
                        id v100 = [(CKKSOutgoingQueueEntry *)v20 accessgroup];
                        uint64_t v125 = (CKKSOutgoingQueueEntry *)v91;
                        uint64_t v101 = [(CKKSOutgoingQueueEntry *)v98 initWithCKKSItem:v91 action:v99 state:@"new" waitUntil:0 accessGroup:v100];

                        id v139 = 0;
                        [(CKKSSQLDatabaseObject *)v20 deleteFromDatabase:&v139];
                        id v102 = v139;
                        id v138 = v102;
                        [(CKKSSQLDatabaseObject *)v101 saveToDatabase:&v138];
                        uint64_t v103 = (CKKSOutgoingQueueEntry *)v138;

                        uint64_t v6 = v19;
                        if (v103)
                        {
                          char v104 = [(CKKSOutgoingQueueEntry *)v19 zoneID];
                          char v105 = [v104 zoneName];
                          long long v106 = sub_1000CD884(@"ckksreencrypt", v105);

                          uint64_t v55 = v127;
                          if (os_log_type_enabled(v106, OS_LOG_TYPE_ERROR))
                          {
                            *(_DWORD *)long long buf = 138412546;
                            long long v158 = v101;
                            __int16 v159 = 2112;
                            long long v160 = v103;
                            _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_ERROR, "Couldn't save newly-encrypted oqe %@: %@", buf, 0x16u);
                          }

                          uint64_t v1 = v137;
                          [*(id *)(v137 + 32) setError:v103];

                          uint64_t v97 = v101;
                          long long v26 = 0;
                          uint64_t v49 = v132;
                        }
                        else
                        {
                          char v121 = 1;
                          uint64_t v1 = v137;
                          uint64_t v97 = v101;
                          long long v26 = 0;
                          uint64_t v49 = v132;
                          uint64_t v55 = v127;
                        }
                        id v88 = v125;
                      }
                    }
                    uint64_t v76 = v129;
                  }
                }
              }

              goto LABEL_24;
            }
            uint64_t v1 = v137;
            if (v34)
            {
              *(_DWORD *)long long buf = 138412546;
              long long v158 = v20;
              __int16 v159 = 2112;
              long long v160 = v26;
              _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "Have a new OQE superceding %@ (%@), skipping", buf, 0x16u);
            }

            id v146 = 0;
            [(CKKSSQLDatabaseObject *)v20 deleteFromDatabase:&v146];
            uint64_t v35 = (CKKSOutgoingQueueEntry *)v146;
            if (v35)
            {
              long long v27 = v35;
              char v36 = [(CKKSOutgoingQueueEntry *)v19 zoneID];
              id v37 = [v36 zoneName];
              id v38 = sub_1000CD884(@"ckksreencrypt", v37);

              if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 138412546;
                long long v158 = v20;
                __int16 v159 = 2112;
                long long v160 = v27;
                _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "Couldn't delete reencrypting OQE(%@) from database: %@", buf, 0x16u);
              }

LABEL_23:
              [*(id *)(v1 + 32) setError:v27];
LABEL_24:
            }
            id v18 = (char *)v18 + 1;
          }
          while (v136 != v18);
          id v107 = [v134 countByEnumeratingWithState:&v148 objects:v163 count:16];
          id v136 = v107;
        }
        while (v107);
      }

      long long v108 = +[CKKSAnalytics logger];
      long long v109 = [*(id *)(v1 + 32) error];

      long long v110 = [(CKKSOutgoingQueueEntry *)v6 zoneID];
      long long v111 = [v110 zoneName];
      if (v109) {
        [v108 logRecoverableError:0 forEvent:@"CKKSEventProcessReencryption" zoneName:v111 withAttributes:0];
      }
      else {
        [v108 logSuccessForEvent:@"CKKSEventProcessReencryption" zoneName:v111];
      }

      uint64_t v5 = v126 + 1;
    }
    while ((id)(v126 + 1) != v124);
    id v124 = [obj countByEnumeratingWithState:&v153 objects:v164 count:16];
  }
  while (v124);

  if (v121)
  {
    long long v112 = [*(id *)(v1 + 32) deps];
    long long v113 = [v112 ckoperationGroup];
    long long v114 = [*(id *)(v1 + 32) deps];
    [v114 setCurrentOutgoingQueueOperationGroup:v113];

    id obj = [*(id *)(v1 + 32) deps];
    unsigned int v115 = [obj flagHandler];
    [v115 _onqueueHandleFlag:@"process_outgoing_queue"];

LABEL_82:
  }
  uint64_t v2 = [*(id *)(v1 + 32) intendedState];
  [*(id *)(v1 + 32) setNextState:v2];
  uint64_t v116 = 1;
LABEL_88:

  return v116;
}

uint64_t sub_1001B4A54(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
    return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
  }
  uint64_t v4 = &OBJC_IVAR___OTVouchWithBottleOperation__voucherSig;
  uint64_t v5 = &OBJC_IVAR___OTVouchWithBottleOperation__voucherSig;
  uint64_t v6 = &OBJC_IVAR___OTVouchWithBottleOperation__voucherSig;
  while (1)
  {
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    char v7 = 0;
    unsigned int v8 = 0;
    unint64_t v9 = 0;
    while (1)
    {
      unint64_t v10 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v10 == -1 || v10 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v11 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v10);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v10 + 1;
      v9 |= (unint64_t)(v11 & 0x7F) << v7;
      if ((v11 & 0x80) == 0) {
        goto LABEL_12;
      }
      v7 += 7;
      BOOL v12 = v8++ >= 9;
      if (v12)
      {
        unint64_t v9 = 0;
        int v13 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_14;
      }
    }
    *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_12:
    int v13 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v9 = 0;
    }
LABEL_14:
    if (v13 || (v9 & 7) == 4) {
      return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    unint64_t v15 = v9 >> 3;
    if ((int)(v9 >> 3) > 100) {
      break;
    }
    switch(v15)
    {
      case 1:
        char v27 = 0;
        unsigned int v28 = 0;
        uint64_t v18 = 0;
        *(_DWORD *)(a1 + v4[954]) |= 0x20000u;
        while (1)
        {
          unint64_t v29 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v29 == -1 || v29 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            break;
          }
          char v30 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v29);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v29 + 1;
          v18 |= (unint64_t)(v30 & 0x7F) << v27;
          if ((v30 & 0x80) == 0) {
            goto LABEL_63;
          }
          v27 += 7;
          BOOL v12 = v28++ >= 9;
          if (v12)
          {
            uint64_t v18 = 0;
            goto LABEL_65;
          }
        }
        *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_63:
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v18 = 0;
        }
LABEL_65:
        uint64_t v36 = v5[955];
        break;
      case 2:
        char v31 = 0;
        unsigned int v32 = 0;
        uint64_t v18 = 0;
        *(_DWORD *)(a1 + v4[954]) |= 8u;
        while (1)
        {
          unint64_t v33 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v33 == -1 || v33 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            break;
          }
          char v34 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v33);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v33 + 1;
          v18 |= (unint64_t)(v34 & 0x7F) << v31;
          if ((v34 & 0x80) == 0) {
            goto LABEL_67;
          }
          v31 += 7;
          BOOL v12 = v32++ >= 9;
          if (v12)
          {
            uint64_t v18 = 0;
            goto LABEL_69;
          }
        }
        *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_67:
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v18 = 0;
        }
LABEL_69:
        uint64_t v36 = v6[956];
        break;
      case 3:
        char v21 = 0;
        unsigned int v22 = 0;
        uint64_t v18 = 0;
        *(_DWORD *)(a1 + v4[954]) |= 0x10u;
        while (1)
        {
          unint64_t v23 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v23 == -1 || v23 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            break;
          }
          char v24 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v23);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v23 + 1;
          v18 |= (unint64_t)(v24 & 0x7F) << v21;
          if ((v24 & 0x80) == 0) {
            goto LABEL_59;
          }
          v21 += 7;
          BOOL v12 = v22++ >= 9;
          if (v12)
          {
            uint64_t v18 = 0;
            goto LABEL_61;
          }
        }
        *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_59:
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v18 = 0;
        }
LABEL_61:
        uint64_t v36 = 40;
        break;
      default:
LABEL_56:
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
        goto LABEL_71;
    }
LABEL_70:
    *(void *)(a1 + v36) = v18;
LABEL_71:
    if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
      return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
  }
  if ((v9 >> 3) > 0x64)
  {
    switch((int)v15)
    {
      case 201:
        char v16 = 0;
        unsigned int v17 = 0;
        uint64_t v18 = 0;
        *(_DWORD *)(a1 + v4[954]) |= 0x20u;
        while (2)
        {
          unint64_t v19 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v19 == -1 || v19 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }
          else
          {
            char v20 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v19);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v19 + 1;
            v18 |= (unint64_t)(v20 & 0x7F) << v16;
            if (v20 < 0)
            {
              v16 += 7;
              BOOL v12 = v17++ >= 9;
              if (v12)
              {
                uint64_t v18 = 0;
                goto LABEL_270;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v18 = 0;
        }
LABEL_270:
        uint64_t v36 = 48;
        goto LABEL_70;
      case 202:
        char v37 = 0;
        unsigned int v38 = 0;
        uint64_t v18 = 0;
        *(_DWORD *)(a1 + v4[954]) |= 0x80u;
        while (2)
        {
          unint64_t v39 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v39 == -1 || v39 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }
          else
          {
            char v40 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v39);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v39 + 1;
            v18 |= (unint64_t)(v40 & 0x7F) << v37;
            if (v40 < 0)
            {
              v37 += 7;
              BOOL v12 = v38++ >= 9;
              if (v12)
              {
                uint64_t v18 = 0;
                goto LABEL_274;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v18 = 0;
        }
LABEL_274:
        uint64_t v36 = 64;
        goto LABEL_70;
      case 203:
        char v41 = 0;
        unsigned int v42 = 0;
        uint64_t v18 = 0;
        *(_DWORD *)(a1 + v4[954]) |= 0x40u;
        while (2)
        {
          unint64_t v43 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v43 == -1 || v43 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }
          else
          {
            char v44 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v43);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v43 + 1;
            v18 |= (unint64_t)(v44 & 0x7F) << v41;
            if (v44 < 0)
            {
              v41 += 7;
              BOOL v12 = v42++ >= 9;
              if (v12)
              {
                uint64_t v18 = 0;
                goto LABEL_278;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v18 = 0;
        }
LABEL_278:
        uint64_t v36 = 56;
        goto LABEL_70;
      case 204:
        char v45 = 0;
        unsigned int v46 = 0;
        uint64_t v18 = 0;
        *(_DWORD *)(a1 + v4[954]) |= 0x200u;
        while (2)
        {
          unint64_t v47 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v47 == -1 || v47 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }
          else
          {
            char v48 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v47);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v47 + 1;
            v18 |= (unint64_t)(v48 & 0x7F) << v45;
            if (v48 < 0)
            {
              v45 += 7;
              BOOL v12 = v46++ >= 9;
              if (v12)
              {
                uint64_t v18 = 0;
                goto LABEL_282;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v18 = 0;
        }
LABEL_282:
        uint64_t v36 = 80;
        goto LABEL_70;
      case 205:
        char v49 = 0;
        unsigned int v50 = 0;
        uint64_t v18 = 0;
        *(_DWORD *)(a1 + v4[954]) |= 0x100u;
        while (2)
        {
          unint64_t v51 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v51 == -1 || v51 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }
          else
          {
            char v52 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v51);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v51 + 1;
            v18 |= (unint64_t)(v52 & 0x7F) << v49;
            if (v52 < 0)
            {
              v49 += 7;
              BOOL v12 = v50++ >= 9;
              if (v12)
              {
                uint64_t v18 = 0;
                goto LABEL_286;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v18 = 0;
        }
LABEL_286:
        uint64_t v36 = 72;
        goto LABEL_70;
      case 206:
        char v53 = 0;
        unsigned int v54 = 0;
        uint64_t v18 = 0;
        *(_DWORD *)(a1 + v4[954]) |= 0x10000u;
        while (2)
        {
          unint64_t v55 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v55 == -1 || v55 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }
          else
          {
            char v56 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v55);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v55 + 1;
            v18 |= (unint64_t)(v56 & 0x7F) << v53;
            if (v56 < 0)
            {
              v53 += 7;
              BOOL v12 = v54++ >= 9;
              if (v12)
              {
                uint64_t v18 = 0;
                goto LABEL_290;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v18 = 0;
        }
LABEL_290:
        uint64_t v36 = 136;
        goto LABEL_70;
      case 207:
        char v57 = 0;
        unsigned int v58 = 0;
        uint64_t v18 = 0;
        *(_DWORD *)(a1 + v4[954]) |= 0x8000u;
        while (2)
        {
          unint64_t v59 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v59 == -1 || v59 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }
          else
          {
            char v60 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v59);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v59 + 1;
            v18 |= (unint64_t)(v60 & 0x7F) << v57;
            if (v60 < 0)
            {
              v57 += 7;
              BOOL v12 = v58++ >= 9;
              if (v12)
              {
                uint64_t v18 = 0;
                goto LABEL_294;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v18 = 0;
        }
LABEL_294:
        uint64_t v36 = 128;
        goto LABEL_70;
      case 208:
        char v61 = 0;
        unsigned int v62 = 0;
        uint64_t v18 = 0;
        *(_DWORD *)(a1 + v4[954]) |= 0x4000u;
        while (2)
        {
          unint64_t v63 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v63 == -1 || v63 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }
          else
          {
            char v64 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v63);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v63 + 1;
            v18 |= (unint64_t)(v64 & 0x7F) << v61;
            if (v64 < 0)
            {
              v61 += 7;
              BOOL v12 = v62++ >= 9;
              if (v12)
              {
                uint64_t v18 = 0;
                goto LABEL_298;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v18 = 0;
        }
LABEL_298:
        uint64_t v36 = 120;
        goto LABEL_70;
      case 209:
        char v65 = 0;
        unsigned int v66 = 0;
        uint64_t v18 = 0;
        *(_DWORD *)(a1 + v4[954]) |= 0x800u;
        while (2)
        {
          unint64_t v67 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v67 == -1 || v67 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }
          else
          {
            char v68 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v67);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v67 + 1;
            v18 |= (unint64_t)(v68 & 0x7F) << v65;
            if (v68 < 0)
            {
              v65 += 7;
              BOOL v12 = v66++ >= 9;
              if (v12)
              {
                uint64_t v18 = 0;
                goto LABEL_302;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v18 = 0;
        }
LABEL_302:
        uint64_t v36 = 96;
        goto LABEL_70;
      case 210:
        char v69 = 0;
        unsigned int v70 = 0;
        uint64_t v18 = 0;
        *(_DWORD *)(a1 + v4[954]) |= 0x400u;
        while (2)
        {
          unint64_t v71 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v71 == -1 || v71 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }
          else
          {
            char v72 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v71);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v71 + 1;
            v18 |= (unint64_t)(v72 & 0x7F) << v69;
            if (v72 < 0)
            {
              v69 += 7;
              BOOL v12 = v70++ >= 9;
              if (v12)
              {
                uint64_t v18 = 0;
                goto LABEL_306;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v18 = 0;
        }
LABEL_306:
        uint64_t v36 = 88;
        goto LABEL_70;
      case 211:
        char v73 = 0;
        unsigned int v74 = 0;
        uint64_t v18 = 0;
        *(_DWORD *)(a1 + v4[954]) |= 0x2000u;
        while (2)
        {
          unint64_t v75 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v75 == -1 || v75 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }
          else
          {
            char v76 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v75);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v75 + 1;
            v18 |= (unint64_t)(v76 & 0x7F) << v73;
            if (v76 < 0)
            {
              v73 += 7;
              BOOL v12 = v74++ >= 9;
              if (v12)
              {
                uint64_t v18 = 0;
                goto LABEL_310;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v18 = 0;
        }
LABEL_310:
        uint64_t v36 = 112;
        goto LABEL_70;
      case 212:
        char v77 = 0;
        unsigned int v78 = 0;
        uint64_t v18 = 0;
        *(_DWORD *)(a1 + v4[954]) |= 0x1000u;
        while (2)
        {
          unint64_t v79 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v79 == -1 || v79 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }
          else
          {
            char v80 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v79);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v79 + 1;
            v18 |= (unint64_t)(v80 & 0x7F) << v77;
            if (v80 < 0)
            {
              v77 += 7;
              BOOL v12 = v78++ >= 9;
              if (v12)
              {
                uint64_t v18 = 0;
                goto LABEL_314;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v18 = 0;
        }
LABEL_314:
        uint64_t v36 = 104;
        goto LABEL_70;
      default:
        switch((int)v15)
        {
          case 301:
            uint64_t v25 = PBReaderReadString();
            uint64_t v26 = 240;
            goto LABEL_252;
          case 302:
            char v115 = 0;
            unsigned int v116 = 0;
            uint64_t v117 = 0;
            *(_DWORD *)(a1 + v4[954]) |= 0x8000000u;
            while (2)
            {
              unint64_t v118 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
              if (v118 == -1 || v118 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
              {
                *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
              }
              else
              {
                char v119 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v118);
                *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v118 + 1;
                v117 |= (unint64_t)(v119 & 0x7F) << v115;
                if (v119 < 0)
                {
                  v115 += 7;
                  BOOL v12 = v116++ >= 9;
                  if (v12)
                  {
                    uint64_t v117 = 0;
                    goto LABEL_346;
                  }
                  continue;
                }
              }
              break;
            }
            if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
              uint64_t v117 = 0;
            }
LABEL_346:
            BOOL v154 = v117 != 0;
            uint64_t v155 = 276;
            goto LABEL_376;
          case 303:
            char v120 = 0;
            unsigned int v121 = 0;
            uint64_t v122 = 0;
            *(_DWORD *)(a1 + v4[954]) |= 0x10000000u;
            while (2)
            {
              unint64_t v123 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
              if (v123 == -1 || v123 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
              {
                *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
              }
              else
              {
                char v124 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v123);
                *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v123 + 1;
                v122 |= (unint64_t)(v124 & 0x7F) << v120;
                if (v124 < 0)
                {
                  v120 += 7;
                  BOOL v12 = v121++ >= 9;
                  if (v12)
                  {
                    uint64_t v122 = 0;
                    goto LABEL_350;
                  }
                  continue;
                }
              }
              break;
            }
            if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
              uint64_t v122 = 0;
            }
LABEL_350:
            BOOL v154 = v122 != 0;
            uint64_t v155 = 277;
            goto LABEL_376;
          case 304:
            char v125 = 0;
            unsigned int v126 = 0;
            uint64_t v127 = 0;
            *(_DWORD *)(a1 + v4[954]) |= 0x1000000u;
            while (2)
            {
              unint64_t v128 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
              if (v128 == -1 || v128 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
              {
                *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
              }
              else
              {
                char v129 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v128);
                *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v128 + 1;
                v127 |= (unint64_t)(v129 & 0x7F) << v125;
                if (v129 < 0)
                {
                  v125 += 7;
                  BOOL v12 = v126++ >= 9;
                  if (v12)
                  {
                    uint64_t v127 = 0;
                    goto LABEL_354;
                  }
                  continue;
                }
              }
              break;
            }
            if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
              uint64_t v127 = 0;
            }
LABEL_354:
            BOOL v154 = v127 != 0;
            uint64_t v155 = 273;
            goto LABEL_376;
          case 305:
            char v130 = 0;
            unsigned int v131 = 0;
            uint64_t v132 = 0;
            *(_DWORD *)(a1 + v4[954]) |= 0x2000000u;
            while (2)
            {
              unint64_t v133 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
              if (v133 == -1 || v133 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
              {
                *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
              }
              else
              {
                char v134 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v133);
                *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v133 + 1;
                v132 |= (unint64_t)(v134 & 0x7F) << v130;
                if (v134 < 0)
                {
                  v130 += 7;
                  BOOL v12 = v131++ >= 9;
                  if (v12)
                  {
                    uint64_t v132 = 0;
                    goto LABEL_358;
                  }
                  continue;
                }
              }
              break;
            }
            if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
              uint64_t v132 = 0;
            }
LABEL_358:
            BOOL v154 = v132 != 0;
            uint64_t v155 = 274;
            goto LABEL_376;
          case 306:
            char v135 = 0;
            unsigned int v136 = 0;
            uint64_t v88 = 0;
            *(_DWORD *)(a1 + v4[954]) |= 0x200000u;
            while (2)
            {
              unint64_t v137 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
              if (v137 == -1 || v137 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
              {
                *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
              }
              else
              {
                char v138 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v137);
                *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v137 + 1;
                v88 |= (unint64_t)(v138 & 0x7F) << v135;
                if (v138 < 0)
                {
                  v135 += 7;
                  BOOL v12 = v136++ >= 9;
                  if (v12)
                  {
                    LODWORD(v8_Block_object_dispose(&STACK[0x290], 8) = 0;
                    goto LABEL_362;
                  }
                  continue;
                }
              }
              break;
            }
            if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
              LODWORD(v8_Block_object_dispose(&STACK[0x290], 8) = 0;
            }
LABEL_362:
            uint64_t v156 = 264;
            goto LABEL_367;
          case 307:
            char v139 = 0;
            unsigned int v140 = 0;
            uint64_t v88 = 0;
            *(_DWORD *)(a1 + v4[954]) |= 0x400000u;
            while (2)
            {
              unint64_t v141 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
              if (v141 == -1 || v141 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
              {
                *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
              }
              else
              {
                char v142 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v141);
                *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v141 + 1;
                v88 |= (unint64_t)(v142 & 0x7F) << v139;
                if (v142 < 0)
                {
                  v139 += 7;
                  BOOL v12 = v140++ >= 9;
                  if (v12)
                  {
                    LODWORD(v8_Block_object_dispose(&STACK[0x290], 8) = 0;
                    goto LABEL_366;
                  }
                  continue;
                }
              }
              break;
            }
            if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
              LODWORD(v8_Block_object_dispose(&STACK[0x290], 8) = 0;
            }
LABEL_366:
            uint64_t v156 = 268;
            goto LABEL_367;
          case 308:
            uint64_t v25 = PBReaderReadString();
            uint64_t v26 = 248;
            goto LABEL_252;
          case 309:
            uint64_t v25 = PBReaderReadString();
            uint64_t v26 = 256;
            goto LABEL_252;
          case 310:
            char v144 = 0;
            unsigned int v145 = 0;
            uint64_t v146 = 0;
            *(_DWORD *)(a1 + v4[954]) |= 0x4000000u;
            while (2)
            {
              unint64_t v147 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
              if (v147 == -1 || v147 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
              {
                *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
              }
              else
              {
                char v148 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v147);
                *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v147 + 1;
                v146 |= (unint64_t)(v148 & 0x7F) << v144;
                if (v148 < 0)
                {
                  v144 += 7;
                  BOOL v12 = v145++ >= 9;
                  if (v12)
                  {
                    uint64_t v146 = 0;
                    goto LABEL_371;
                  }
                  continue;
                }
              }
              break;
            }
            if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
              uint64_t v146 = 0;
            }
LABEL_371:
            BOOL v154 = v146 != 0;
            uint64_t v155 = 275;
            goto LABEL_376;
          case 311:
            char v149 = 0;
            unsigned int v150 = 0;
            uint64_t v151 = 0;
            *(_DWORD *)(a1 + v4[954]) |= 0x20000000u;
            break;
          default:
            goto LABEL_56;
        }
        break;
    }
    while (1)
    {
      unint64_t v152 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v152 == -1 || v152 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v153 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v152);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v152 + 1;
      v151 |= (unint64_t)(v153 & 0x7F) << v149;
      if ((v153 & 0x80) == 0) {
        goto LABEL_373;
      }
      v149 += 7;
      BOOL v12 = v150++ >= 9;
      if (v12)
      {
        uint64_t v151 = 0;
        goto LABEL_375;
      }
    }
    *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_373:
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      uint64_t v151 = 0;
    }
LABEL_375:
    BOOL v154 = v151 != 0;
    uint64_t v155 = 278;
LABEL_376:
    *(unsigned char *)(a1 + v155) = v154;
    goto LABEL_71;
  }
  switch((int)v15)
  {
    case 'e':
      uint64_t v25 = PBReaderReadString();
      uint64_t v26 = 232;
      goto LABEL_252;
    case 'f':
      uint64_t v25 = PBReaderReadString();
      uint64_t v26 = 168;
      goto LABEL_252;
    case 'g':
      uint64_t v25 = PBReaderReadString();
      uint64_t v26 = 200;
      goto LABEL_252;
    case 'h':
      uint64_t v25 = PBReaderReadString();
      uint64_t v26 = 152;
      goto LABEL_252;
    case 'i':
      char v81 = 0;
      unsigned int v82 = 0;
      uint64_t v83 = 0;
      *(_DWORD *)(a1 + v4[954]) |= 0x800000u;
      while (2)
      {
        unint64_t v84 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v84 == -1 || v84 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
        }
        else
        {
          char v85 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v84);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v84 + 1;
          v83 |= (unint64_t)(v85 & 0x7F) << v81;
          if (v85 < 0)
          {
            v81 += 7;
            BOOL v12 = v82++ >= 9;
            if (v12)
            {
              uint64_t v83 = 0;
              goto LABEL_318;
            }
            continue;
          }
        }
        break;
      }
      if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        uint64_t v83 = 0;
      }
LABEL_318:
      BOOL v154 = v83 != 0;
      uint64_t v155 = 272;
      goto LABEL_376;
    case 'j':
      uint64_t v25 = PBReaderReadString();
      uint64_t v26 = 176;
      goto LABEL_252;
    case 'k':
      uint64_t v25 = PBReaderReadString();
      uint64_t v26 = 192;
      goto LABEL_252;
    case 'l':
      char v86 = 0;
      unsigned int v87 = 0;
      uint64_t v88 = 0;
      *(_DWORD *)(a1 + v4[954]) |= 0x80000u;
      while (2)
      {
        unint64_t v89 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v89 == -1 || v89 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
        }
        else
        {
          char v90 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v89);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v89 + 1;
          v88 |= (unint64_t)(v90 & 0x7F) << v86;
          if (v90 < 0)
          {
            v86 += 7;
            BOOL v12 = v87++ >= 9;
            if (v12)
            {
              LODWORD(v8_Block_object_dispose(&STACK[0x290], 8) = 0;
              goto LABEL_322;
            }
            continue;
          }
        }
        break;
      }
      if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        LODWORD(v8_Block_object_dispose(&STACK[0x290], 8) = 0;
      }
LABEL_322:
      uint64_t v156 = 208;
      goto LABEL_367;
    case 'm':
      char v91 = 0;
      unsigned int v92 = 0;
      uint64_t v18 = 0;
      *(_DWORD *)(a1 + v4[954]) |= 1u;
      while (2)
      {
        unint64_t v93 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v93 == -1 || v93 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
        }
        else
        {
          char v94 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v93);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v93 + 1;
          v18 |= (unint64_t)(v94 & 0x7F) << v91;
          if (v94 < 0)
          {
            v91 += 7;
            BOOL v12 = v92++ >= 9;
            if (v12)
            {
              uint64_t v18 = 0;
              goto LABEL_326;
            }
            continue;
          }
        }
        break;
      }
      if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        uint64_t v18 = 0;
      }
LABEL_326:
      uint64_t v36 = 8;
      goto LABEL_70;
    case 'n':
      char v95 = 0;
      unsigned int v96 = 0;
      uint64_t v88 = 0;
      *(_DWORD *)(a1 + v4[954]) |= 0x100000u;
      while (2)
      {
        unint64_t v97 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v97 == -1 || v97 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
        }
        else
        {
          char v98 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v97);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v97 + 1;
          v88 |= (unint64_t)(v98 & 0x7F) << v95;
          if (v98 < 0)
          {
            v95 += 7;
            BOOL v12 = v96++ >= 9;
            if (v12)
            {
              LODWORD(v8_Block_object_dispose(&STACK[0x290], 8) = 0;
              goto LABEL_330;
            }
            continue;
          }
        }
        break;
      }
      if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        LODWORD(v8_Block_object_dispose(&STACK[0x290], 8) = 0;
      }
LABEL_330:
      uint64_t v156 = 224;
      goto LABEL_367;
    case 'o':
      char v99 = 0;
      unsigned int v100 = 0;
      uint64_t v18 = 0;
      *(_DWORD *)(a1 + v4[954]) |= 2u;
      while (2)
      {
        unint64_t v101 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v101 == -1 || v101 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
        }
        else
        {
          char v102 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v101);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v101 + 1;
          v18 |= (unint64_t)(v102 & 0x7F) << v99;
          if (v102 < 0)
          {
            v99 += 7;
            BOOL v12 = v100++ >= 9;
            if (v12)
            {
              uint64_t v18 = 0;
              goto LABEL_334;
            }
            continue;
          }
        }
        break;
      }
      if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        uint64_t v18 = 0;
      }
LABEL_334:
      uint64_t v36 = 16;
      goto LABEL_70;
    case 'p':
      char v103 = 0;
      unsigned int v104 = 0;
      uint64_t v88 = 0;
      *(_DWORD *)(a1 + v4[954]) |= 0x40000u;
      while (2)
      {
        unint64_t v105 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v105 == -1 || v105 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
        }
        else
        {
          char v106 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v105);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v105 + 1;
          v88 |= (unint64_t)(v106 & 0x7F) << v103;
          if (v106 < 0)
          {
            v103 += 7;
            BOOL v12 = v104++ >= 9;
            if (v12)
            {
              LODWORD(v8_Block_object_dispose(&STACK[0x290], 8) = 0;
              goto LABEL_338;
            }
            continue;
          }
        }
        break;
      }
      if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        LODWORD(v8_Block_object_dispose(&STACK[0x290], 8) = 0;
      }
LABEL_338:
      uint64_t v156 = 184;
LABEL_367:
      *(_DWORD *)(a1 + v156) = v88;
      goto LABEL_71;
    case 'q':
      id v107 = v4;
      long long v108 = v6;
      long long v109 = v5;
      long long v110 = objc_alloc_init(SECC2MPError);
      objc_storeStrong((id *)(a1 + 160), v110);
      if PBReaderPlaceMark() && (sub_100153C18((uint64_t)v110, a2))
      {
        PBReaderRecallMark();

        uint64_t v5 = v109;
        uint64_t v6 = v108;
        uint64_t v4 = v107;
        goto LABEL_71;
      }

      return 0;
    case 'r':
      char v111 = 0;
      unsigned int v112 = 0;
      uint64_t v18 = 0;
      *(_DWORD *)(a1 + v4[954]) |= 4u;
      while (2)
      {
        unint64_t v113 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v113 == -1 || v113 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
        }
        else
        {
          char v114 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v113);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v113 + 1;
          v18 |= (unint64_t)(v114 & 0x7F) << v111;
          if (v114 < 0)
          {
            v111 += 7;
            BOOL v12 = v112++ >= 9;
            if (v12)
            {
              uint64_t v18 = 0;
              goto LABEL_342;
            }
            continue;
          }
        }
        break;
      }
      if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        uint64_t v18 = 0;
      }
LABEL_342:
      uint64_t v36 = 24;
      goto LABEL_70;
    case 's':
      uint64_t v25 = PBReaderReadString();
      uint64_t v26 = 216;
LABEL_252:
      id v143 = *(void **)(a1 + v26);
      *(void *)(a1 + v26) = v25;

      goto LABEL_71;
    default:
      JUMPOUT(0);
  }
}

void sub_1001B83D4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1001B875C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
}

void sub_1001B8770(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 64));
  uint64_t v3 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v4 = [WeakRetained octagonContainerMap];
    [v4 setObject:*(void *)(a1 + 32) forKey:*(void *)(a1 + 40)];

    uint64_t v5 = [v3 undeliveredCuttlefishUpdates];
    unsigned int v6 = [v5 containsObject:*(void *)(a1 + 40)];

    if (v6)
    {
      char v7 = [v3 undeliveredCuttlefishUpdates];
      [v7 removeObject:*(void *)(a1 + 40)];

      unsigned int v8 = sub_1000CD884(@"octagonpush", 0);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        uint64_t v10 = *(void *)(a1 + 40);
        uint64_t v9 = *(void *)(a1 + 48);
        uint64_t v11 = *(void *)(a1 + 32);
        int v13 = 138412802;
        uint64_t v14 = v9;
        __int16 v15 = 2112;
        uint64_t v16 = v10;
        __int16 v17 = 2112;
        uint64_t v18 = v11;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "sending fake push to newly-registered cuttlefish receiver(%@-%@): %@", (uint8_t *)&v13, 0x20u);
      }

      [*(id *)(a1 + 32) notifyContainerChange:0];
    }
    [*(id *)(a1 + 56) fulfill];
  }
  else
  {
    BOOL v12 = sub_1000CD884(@"octagonpush", 0);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v13) = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "received registration for released OctagonAPSReceiver", (uint8_t *)&v13, 2u);
    }
  }
}

void sub_1001B8A74(_Unwind_Exception *a1)
{
  objc_destroyWeak((id *)(v1 - 56));
  _Unwind_Resume(a1);
}

void sub_1001B8A88(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  uint64_t v3 = sub_1000CD884(@"octagonpush", 0);
  uint64_t v4 = v3;
  if (WeakRetained)
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 32);
      *(_DWORD *)long long buf = 138412290;
      uint64_t v26 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Registering new CKKS push receiver: %@", buf, 0xCu);
    }

    uint64_t v6 = *(void *)(a1 + 32);
    char v7 = [WeakRetained zoneUpdateReceiverDictionary];
    [v7 setObject:v6 forKeyedSubscript:*(void *)(a1 + 40)];

    unsigned int v8 = [WeakRetained undeliveredUpdates];
    uint64_t v9 = [v8 copy];

    id v20 = WeakRetained;
    uint64_t v10 = [WeakRetained undeliveredUpdates];
    [v10 removeAllObjects];

    long long v23 = 0u;
    long long v24 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    unint64_t v19 = v9;
    uint64_t v11 = [v9 allObjects];
    id v12 = [v11 countByEnumeratingWithState:&v21 objects:v29 count:16];
    if (v12)
    {
      id v13 = v12;
      uint64_t v14 = *(void *)v22;
      do
      {
        for (CFIndex i = 0; i != v13; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v22 != v14) {
            objc_enumerationMutation(v11);
          }
          uint64_t v16 = *(void *)(*((void *)&v21 + 1) + 8 * i);
          __int16 v17 = sub_1000CD884(@"octagonpush", 0);
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            uint64_t v18 = *(void *)(a1 + 32);
            *(_DWORD *)long long buf = 138412546;
            uint64_t v26 = v16;
            __int16 v27 = 2112;
            uint64_t v28 = v18;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "sending stored push(%@) to newly-registered receiver: %@", buf, 0x16u);
          }

          [*(id *)(a1 + 32) notifyZoneChange:v16];
        }
        id v13 = [v11 countByEnumeratingWithState:&v21 objects:v29 count:16];
      }
      while (v13);
    }

    [*(id *)(a1 + 48) fulfill];
    uint64_t v4 = v19;
    id WeakRetained = v20;
  }
  else if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "received registration for released OctagonAPSReceiver", buf, 2u);
  }
}

void sub_1001B9098(_Unwind_Exception *a1)
{
  objc_destroyWeak((id *)(v1 - 40));
  _Unwind_Resume(a1);
}

void sub_1001B90AC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    id v13 = WeakRetained;
    uint64_t v3 = [WeakRetained environmentMap];
    id v4 = [v3 objectForKeyedSubscript:*(void *)(a1 + 32)];

    if (!v4)
    {
      id v5 = [[objc_msgSend(v13, "apsConnectionClass") alloc];
      uint64_t v6 = *(void *)(a1 + 32);
      char v7 = [v13 namedDelegatePort];
      unsigned int v8 = +[OctagonAPSReceiver apsDeliveryQueue];
      id v4 = [v5 initWithEnvironmentName:v6 namedDelegatePort:v7 queue:v8];

      uint64_t v9 = [v13 environmentMap];
      [v9 setObject:v4 forKeyedSubscript:*(void *)(a1 + 32)];

      [v4 setDelegate:v13];
      uint64_t v10 = [@"com.apple.icloud-container." stringByAppendingString:@"com.apple.securityd"];
      uint64_t v11 = [v13 cuttlefishPushTopics];
      id v12 = [v11 arrayByAddingObject:v10];
      [v4 setEnabledTopics:v12];
    }
    id WeakRetained = v13;
  }
}

void sub_1001B93D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1001B93F0(uint64_t a1)
{
  uint64_t v2 = +[OctagonAPSReceiver apsDeliveryQueue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1001B94A0;
  block[3] = &unk_1003077A0;
  objc_copyWeak(&v4, (id *)(a1 + 32));
  dispatch_async(v2, block);

  objc_destroyWeak(&v4);
}

void sub_1001B94A0(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v5 = WeakRetained;
    uint64_t v2 = [WeakRetained undeliveredUpdates];
    uint64_t v3 = +[NSMutableSet set];
    [v5 setUndeliveredUpdates:v3];

    id v4 = [v5 undeliveredCuttlefishUpdates];
    [v4 removeAllObjects];

    [v5 reportDroppedPushes:v2];
    id WeakRetained = v5;
  }
}

void sub_1001B96E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1001B96FC(uint64_t a1)
{
  id v3 = [*(id *)(a1 + 32) undeliveredUpdates];
  if ([v3 count])
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
  }
  else
  {
    uint64_t v2 = [*(id *)(a1 + 32) undeliveredCuttlefishUpdates];
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = [v2 count] != 0;
  }
}

void sub_1001B989C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001B98B4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1001B98C4(uint64_t a1)
{
}

void sub_1001B98CC(uint64_t a1)
{
  id v5 = [*(id *)(a1 + 32) environmentMap];
  uint64_t v2 = [v5 allKeys];
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void sub_1001B9988(id a1)
{
  uint64_t v3 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t v1 = dispatch_queue_create("aps-callback-queue", v3);
  uint64_t v2 = (void *)qword_10035D248;
  qword_10035D248 = (uint64_t)v1;
}

void sub_1001B9AB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_1001B9B8C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1001B9ED4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
  objc_destroyWeak(v19);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1001B9EFC(id *a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained(a1 + 7);
  id v5 = [WeakRetained databaseProvider];
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  void v7[2] = sub_1001BA034;
  v7[3] = &unk_100306CB8;
  id v8 = a1[4];
  id v6 = v3;
  id v9 = v6;
  id v10 = a1[5];
  id v11 = a1[6];
  objc_copyWeak(&v13, a1 + 7);
  id v12 = WeakRetained;
  [v5 dispatchSyncWithReadOnlySQLTransaction:v7];

  objc_destroyWeak(&v13);
}

void sub_1001BA020(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_1001BA034(id *a1)
{
  dispatch_queue_t v1 = a1 + 4;
  uint64_t v2 = [a1[4] contextID];
  id v3 = [*v1 zoneID];
  id v117 = 0;
  char v91 = +[CKKSCurrentKeyPointer tryFromDatabase:@"tlk" contextID:v2 zoneID:v3 error:&v117];
  id v87 = v117;

  if (v91
    && (([v91 currentKeyUUID], (id v4 = objc_claimAutoreleasedReturnValue()) != 0)
      ? (BOOL v5 = v87 == 0)
      : (BOOL v5 = 0),
        v5 ? (int v6 = 0) : (int v6 = 1),
        v4,
        !v6))
  {
    char v90 = +[NSMutableArray array];
    long long v115 = 0u;
    long long v116 = 0u;
    long long v113 = 0u;
    long long v114 = 0u;
    id obj = a1[6];
    id v10 = [obj countByEnumeratingWithState:&v113 objects:v123 count:16];
    if (v10)
    {
      uint64_t v11 = *(void *)v114;
      while (2)
      {
        for (CFIndex i = 0; i != v10; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v114 != v11) {
            objc_enumerationMutation(obj);
          }
          id v13 = *(void **)(*((void *)&v113 + 1) + 8 * i);
          uint64_t v14 = [a1[4] zoneID];
          __int16 v15 = [a1[4] contextID];
          uint64_t v16 = [v13 makeTLKShareRecord:v14 contextID:v15];

          __int16 v17 = [v16 tlkUUID];
          uint64_t v18 = [v91 currentKeyUUID];
          unsigned __int8 v19 = [v17 isEqualToString:v18];

          id v20 = [a1[4] zoneID];
          long long v21 = v20;
          if ((v19 & 1) == 0)
          {
            unsigned int v74 = [v20 zoneName];
            unint64_t v75 = sub_1000CD884(@"ckks-se", v74);

            if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
            {
              char v76 = [v91 currentKeyUUID];
              *(_DWORD *)long long buf = 138412546;
              *(void *)uint64_t v122 = v76;
              *(_WORD *)&v122[8] = 2112;
              *(void *)&v122[10] = v13;
              _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_ERROR, "TLKShare is not for the current TLK(%@): %@", buf, 0x16u);
            }
            char v77 = [v91 currentKeyUUID];
            unsigned int v78 = +[NSString stringWithFormat:@"TLKShare is not for current TLK %@", v77];
            unint64_t v79 = +[NSError errorWithDomain:@"CKKSErrorDomain" code:61 description:v78];
            [a1[5] setError:v79];

            goto LABEL_66;
          }
          long long v22 = [v16 CKRecordWithZoneID:v20];
          [v90 addObject:v22];
        }
        id v10 = [obj countByEnumeratingWithState:&v113 objects:v123 count:16];
        if (v10) {
          continue;
        }
        break;
      }
    }

    id obj = +[NSMutableArray array];
    long long v111 = 0u;
    long long v112 = 0u;
    long long v109 = 0u;
    long long v110 = 0u;
    unint64_t v84 = a1[7];
    id v86 = [v84 countByEnumeratingWithState:&v109 objects:v120 count:16];
    if (v86)
    {
      uint64_t v85 = *(void *)v110;
      while (2)
      {
        uint64_t v23 = 0;
        do
        {
          if (*(void *)v110 != v85)
          {
            uint64_t v24 = v23;
            objc_enumerationMutation(v84);
            uint64_t v23 = v24;
          }
          uint64_t v88 = v23;
          unint64_t v89 = *(void **)(*((void *)&v109 + 1) + 8 * v23);
          uint64_t v25 = [a1[4] zoneID];
          uint64_t v26 = [a1[4] contextID];
          unint64_t v93 = [v89 makeTLKShareRecord:v25 contextID:v26];

          __int16 v27 = [v93 tlkUUID];
          uint64_t v28 = [a1[4] contextID];
          unint64_t v29 = [v93 share];
          char v30 = [v29 receiverPeerID];
          char v31 = [v93 share];
          unsigned int v32 = [v31 senderPeerID];
          unint64_t v33 = [a1[4] zoneID];
          id v108 = 0;
          char v34 = +[CKKSTLKShareRecord fromDatabase:v27 contextID:v28 receiverPeerID:v30 senderPeerID:v32 zoneID:v33 error:&v108];
          id v35 = v108;

          if (v34) {
            BOOL v36 = v35 == 0;
          }
          else {
            BOOL v36 = 0;
          }
          char v37 = v36;
          unsigned int v38 = [a1[4] zoneID];
          unint64_t v39 = v38;
          if ((v37 & 1) == 0)
          {
            char v80 = [v38 zoneName];
            char v81 = sub_1000CD884(@"ckks-se", v80);

            if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 138412546;
              *(void *)uint64_t v122 = v89;
              *(_WORD *)&v122[8] = 2112;
              *(void *)&v122[10] = v35;
              _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_ERROR, "Unable to load TLKShare (to delete): %@ %@", buf, 0x16u);
            }

            [a1[5] setError:v35];
            goto LABEL_65;
          }
          char v40 = [v34 CKRecordWithZoneID:v38];

          char v41 = [v40 recordID];
          [obj addObject:v41];

          uint64_t v23 = v88 + 1;
        }
        while (v86 != (id)(v88 + 1));
        id v86 = [v84 countByEnumeratingWithState:&v109 objects:v120 count:16];
        if (v86) {
          continue;
        }
        break;
      }
    }

    if ([v90 count] || objc_msgSend(obj, "count"))
    {
      unint64_t v84 = [objc_alloc((Class)CKModifyRecordsOperation) initWithRecordsToSave:v90 recordIDsToDelete:obj];
      [v84 setAtomic:1];
      unsigned int v42 = [v84 configuration];
      [v42 setIsCloudKitSupportOperation:1];

      [v84 setSavePolicy:0];
      unint64_t v43 = [a1[4] zoneID];
      char v44 = [v43 zoneName];
      char v45 = sub_1000CD884(@"ckks-se", v44);

      if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v46 = [v84 qualityOfService];
        unint64_t v47 = [v84 group];
        *(_DWORD *)long long buf = 67109378;
        *(_DWORD *)uint64_t v122 = v46;
        *(_WORD *)&v122[4] = 2112;
        *(void *)&v122[6] = v47;
        _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "QoS: %d; operation group is %@",
          buf,
          0x12u);
      }
      char v48 = [a1[4] zoneID];
      char v49 = [v48 zoneName];
      unsigned int v50 = sub_1000CD884(@"ckks-se", v49);

      if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v51 = [v90 count];
        unsigned int v52 = [obj count];
        *(_DWORD *)long long buf = 67109376;
        *(_DWORD *)uint64_t v122 = v51;
        *(_WORD *)&v122[4] = 1024;
        *(_DWORD *)&v122[6] = v52;
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "Beginning upload for %d records, deleting %d records", buf, 0xEu);
      }

      long long v106 = 0u;
      long long v107 = 0u;
      long long v104 = 0u;
      long long v105 = 0u;
      id v53 = v90;
      id v54 = [v53 countByEnumeratingWithState:&v104 objects:v119 count:16];
      if (v54)
      {
        uint64_t v55 = *(void *)v105;
        do
        {
          for (j = 0; j != v54; j = (char *)j + 1)
          {
            if (*(void *)v105 != v55) {
              objc_enumerationMutation(v53);
            }
            char v57 = *(void **)(*((void *)&v104 + 1) + 8 * (void)j);
            unsigned int v58 = [v57 recordID];
            unint64_t v59 = [v58 zoneID];
            char v60 = [v59 zoneName];
            char v61 = sub_1000CD884(@"ckks-se", v60);

            if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
            {
              unsigned int v62 = [v57 recordID];
              *(_DWORD *)long long buf = 138412290;
              *(void *)uint64_t v122 = v62;
              _os_log_debug_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEBUG, "Record to save: %@", buf, 0xCu);
            }
          }
          id v54 = [v53 countByEnumeratingWithState:&v104 objects:v119 count:16];
        }
        while (v54);
      }

      long long v102 = 0u;
      long long v103 = 0u;
      long long v100 = 0u;
      long long v101 = 0u;
      id obj = obj;
      id v63 = [obj countByEnumeratingWithState:&v100 objects:v118 count:16];
      if (v63)
      {
        uint64_t v64 = *(void *)v101;
        do
        {
          for (k = 0; k != v63; k = (char *)k + 1)
          {
            if (*(void *)v101 != v64) {
              objc_enumerationMutation(obj);
            }
            unsigned int v66 = *(void **)(*((void *)&v100 + 1) + 8 * (void)k);
            unint64_t v67 = [v66 zoneID];
            char v68 = [v67 zoneName];
            char v69 = sub_1000CD884(@"ckks-se", v68);

            if (os_log_type_enabled(v69, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)long long buf = 138412290;
              *(void *)uint64_t v122 = v66;
              _os_log_debug_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEBUG, "Record to delete: %@", buf, 0xCu);
            }
          }
          id v63 = [obj countByEnumeratingWithState:&v100 objects:v118 count:16];
        }
        while (v63);
      }

      [v84 setPerRecordSaveBlock:&stru_100306C48];
      unsigned int v70 = +[CKKSResultOperation named:@"wait-until-write-finished" withBlock:&stru_100306C68];
      [a1[5] dependOnBeforeGroupFinished:v70];
      v95[0] = _NSConcreteStackBlock;
      v95[1] = 3221225472;
      v95[2] = sub_1001BAD68;
      v95[3] = &unk_100306C90;
      objc_copyWeak(&v99, a1 + 9);
      id v96 = a1[4];
      id v97 = a1[5];
      id v71 = v70;
      id v98 = v71;
      [v84 setModifyRecordsCompletionBlock:v95];
      char v72 = [a1[8] operationDependencies];
      char v73 = [v72 ckdatabase];
      [v73 addOperation:v84];

      objc_destroyWeak(&v99);
LABEL_65:
      uint64_t v16 = v84;
    }
    else
    {
      unsigned int v82 = [a1[4] zoneID];
      uint64_t v83 = [v82 zoneName];
      uint64_t v16 = sub_1000CD884(@"ckks-se", v83);

      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Requested modifications are a no-op; claiming success",
          buf,
          2u);
      }
    }
LABEL_66:
  }
  else
  {
    char v7 = [a1[4] zoneID];
    id v8 = [v7 zoneName];
    id v9 = sub_1000CD884(@"ckks-se", v8);

    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)uint64_t v122 = v87;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Unable to load currentTLK: %@", buf, 0xCu);
    }

    [a1[5] setError:v87];
  }
}

void sub_1001BAD48(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_1001BAD68(id *a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained(a1 + 7);
  uint64_t v11 = [WeakRetained databaseProvider];
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  v15[2] = sub_1001BAEB0;
  v15[3] = &unk_100306B88;
  id v16 = v9;
  id v17 = a1[4];
  id v18 = a1[5];
  id v19 = a1[6];
  id v20 = v7;
  id v21 = WeakRetained;
  id v22 = v8;
  id v12 = v8;
  id v13 = v7;
  id v14 = v9;
  [v11 dispatchSyncWithSQLTransaction:v15];
}

uint64_t sub_1001BAEB0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = [*(id *)(a1 + 40) zoneID];
  id v4 = [v3 zoneName];
  BOOL v5 = sub_1000CD884(@"ckks-se", v4);

  if (v2)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = *(void *)(a1 + 32);
      *(_DWORD *)long long buf = 138412290;
      uint64_t v33 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "error proposing new TLK: %@", buf, 0xCu);
    }

    [*(id *)(a1 + 48) setError:*(void *)(a1 + 32)];
  }
  else
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Completed modifying TLK share records!", buf, 2u);
    }

    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    id v7 = *(id *)(a1 + 64);
    id v8 = [v7 countByEnumeratingWithState:&v26 objects:v31 count:16];
    if (v8)
    {
      id v9 = v8;
      uint64_t v10 = *(void *)v27;
      do
      {
        for (CFIndex i = 0; i != v9; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v27 != v10) {
            objc_enumerationMutation(v7);
          }
          uint64_t v12 = *(void *)(*((void *)&v26 + 1) + 8 * i);
          id v13 = [*(id *)(a1 + 72) operationDependencies];
          [v13 intransactionCKRecordChanged:v12 resync:0];
        }
        id v9 = [v7 countByEnumeratingWithState:&v26 objects:v31 count:16];
      }
      while (v9);
    }

    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    id v14 = *(id *)(a1 + 80);
    id v15 = [v14 countByEnumeratingWithState:&v22 objects:v30 count:16];
    if (v15)
    {
      id v16 = v15;
      uint64_t v17 = *(void *)v23;
      do
      {
        for (j = 0; j != v16; j = (char *)j + 1)
        {
          if (*(void *)v23 != v17) {
            objc_enumerationMutation(v14);
          }
          uint64_t v19 = *(void *)(*((void *)&v22 + 1) + 8 * (void)j);
          id v20 = [*(id *)(a1 + 72) operationDependencies:v22];
          [v20 intransactionCKRecordDeleted:v19 recordType:@"tlkshare" resync:0];
        }
        id v16 = [v14 countByEnumeratingWithState:&v22 objects:v30 count:16];
      }
      while (v16);
    }
  }
  [*(id *)(a1 + 48) runBeforeGroupFinished:*(void *)(a1 + 56) v22];
  return 1;
}

void sub_1001BB164(id a1, CKRecordID *a2, CKRecord *a3, NSError *a4)
{
  uint64_t v6 = a2;
  id v7 = a3;
  id v8 = a4;
  id v9 = [(CKRecordID *)v6 zoneID];
  uint64_t v10 = [v9 zoneName];
  uint64_t v11 = sub_1000CD884(@"ckks-se", v10);

  if (v8)
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      int v14 = 138412546;
      id v15 = v8;
      __int16 v16 = 2112;
      uint64_t v17 = v7;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "error on row: %@ %@", (uint8_t *)&v14, 0x16u);
    }
  }
  else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = [(CKRecordID *)v6 recordName];
    id v13 = [(CKRecord *)v7 recordChangeTag];
    int v14 = 138412546;
    id v15 = v12;
    __int16 v16 = 2112;
    uint64_t v17 = v13;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Record upload successful for %@ (%@)", (uint8_t *)&v14, 0x16u);
  }
}

void sub_1001BB3D0(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) contextID];
  id v3 = [*(id *)(a1 + 32) zoneName];
  id v4 = +[CKKSZoneStateEntry contextID:v2 zoneName:v3];

  BOOL v5 = [v4 getChangeToken];

  if (v5)
  {
    uint64_t v6 = [*(id *)(a1 + 32) contextID];
    id v7 = [*(id *)(a1 + 32) zoneID];
    id v61 = 0;
    id v8 = +[CKKSCurrentKeyPointer tryFromDatabase:@"tlk" contextID:v6 zoneID:v7 error:&v61];
    id v9 = v61;

    if (v9)
    {
      uint64_t v10 = [*(id *)(a1 + 32) zoneID];
      uint64_t v11 = [v10 zoneName];
      uint64_t v12 = sub_1000CD884(@"ckks-se", v11);

      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        id v64 = v9;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Error loading TLK pointer for this zone: %@", buf, 0xCu);
      }

      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    }
    else if (v8)
    {
      __int16 v16 = [v8 currentKeyUUID];
      uint64_t v17 = [*(id *)(a1 + 32) contextID];
      id v18 = [*(id *)(a1 + 32) zoneID];
      id v60 = 0;
      uint64_t v19 = +[CKKSKey fromDatabaseAnyState:v16 contextID:v17 zoneID:v18 error:&v60];
      id v9 = v60;

      if (!v19 || v9)
      {
        unint64_t v43 = [*(id *)(a1 + 32) zoneID];
        char v44 = [v43 zoneName];
        char v45 = sub_1000CD884(@"ckks-se", v44);

        if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "No TLK for this zone", buf, 2u);
        }

        (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
      }
      else
      {
        id v20 = objc_alloc((Class)CKKSExternalKey);
        id v21 = [*(id *)(a1 + 32) zoneID];
        long long v22 = [v21 zoneName];
        id v53 = [v20 initWithViewName:v22 tlk:v19];

        long long v23 = [v8 currentKeyUUID];
        long long v24 = [*(id *)(a1 + 32) contextID];
        long long v25 = [*(id *)(a1 + 32) zoneID];
        id v59 = 0;
        long long v26 = +[CKKSTLKShareRecord allForUUID:v23 contextID:v24 zoneID:v25 error:&v59];
        id v9 = v59;

        if (!v26 || v9)
        {
          unsigned int v46 = [*(id *)(a1 + 32) zoneID];
          unint64_t v47 = [v46 zoneName];
          char v48 = sub_1000CD884(@"ckks-se", v47);

          if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138412290;
            id v64 = v9;
            _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "Unable to load TLKShares for zone: %@", buf, 0xCu);
          }

          (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
          unint64_t v39 = v53;
        }
        else
        {
          unsigned int v50 = v19;
          unsigned int v51 = v8;
          unsigned int v52 = v4;
          uint64_t v27 = a1;
          long long v28 = +[NSMutableArray array];
          long long v55 = 0u;
          long long v56 = 0u;
          long long v57 = 0u;
          long long v58 = 0u;
          char v49 = v26;
          id obj = v26;
          id v29 = [obj countByEnumeratingWithState:&v55 objects:v62 count:16];
          if (v29)
          {
            id v30 = v29;
            uint64_t v31 = *(void *)v56;
            do
            {
              for (CFIndex i = 0; i != v30; CFIndex i = (char *)i + 1)
              {
                if (*(void *)v56 != v31) {
                  objc_enumerationMutation(obj);
                }
                uint64_t v33 = *(void **)(*((void *)&v55 + 1) + 8 * i);
                id v34 = objc_alloc((Class)CKKSExternalTLKShare);
                id v35 = [*(id *)(v27 + 32) zoneID];
                BOOL v36 = [v35 zoneName];
                char v37 = [v33 share];
                id v38 = [v34 initWithViewName:v36 tlkShare:v37];

                [v28 addObject:v38];
              }
              id v30 = [obj countByEnumeratingWithState:&v55 objects:v62 count:16];
            }
            while (v30);
          }

          unint64_t v39 = v53;
          (*(void (**)(void))(*(void *)(v27 + 40) + 16))();

          id v8 = v51;
          id v4 = v52;
          uint64_t v19 = v50;
          id v9 = 0;
          long long v26 = v49;
        }
      }
    }
    else
    {
      char v40 = [*(id *)(a1 + 32) zoneID];
      char v41 = [v40 zoneName];
      unsigned int v42 = sub_1000CD884(@"ckks-se", v41);

      if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "No TLK pointer for this zone", buf, 2u);
      }

      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
      id v9 = 0;
    }
  }
  else
  {
    id v9 = +[NSError errorWithDomain:@"CKKSErrorDomain" code:66 description:@"Initial fetch results not present; cannot provide accurate answer about TLK state"];
    id v13 = [*(id *)(a1 + 32) zoneID];
    int v14 = [v13 zoneName];
    id v15 = sub_1000CD884(@"ckks-se", v14);

    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      id v64 = v9;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Haven't successfully completed a fetch for this zone; returning %@",
        buf,
        0xCu);
    }

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

void sub_1001BBC80(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 56));
  _Unwind_Resume(a1);
}

void sub_1001BBCA0(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  id v3 = [*(id *)(a1 + 32) error];

  if (v3)
  {
    id v4 = [*(id *)(a1 + 40) zoneID];
    BOOL v5 = [v4 zoneName];
    uint64_t v6 = sub_1000CD884(@"ckks-se", v5);

    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      id v7 = [*(id *)(a1 + 32) error];
      int v10 = 138412290;
      uint64_t v11 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Error loading TLK pointer for this zone: %@", (uint8_t *)&v10, 0xCu);
    }
    uint64_t v8 = *(void *)(a1 + 48);
    id v9 = [*(id *)(a1 + 32) error];
    (*(void (**)(uint64_t, void, void, void, void *))(v8 + 16))(v8, 0, 0, 0, v9);
  }
  else
  {
    [WeakRetained loadKeys:*(void *)(a1 + 40) reply:*(void *)(a1 + 48)];
  }
}

void sub_1001BC244(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id location)
{
  objc_destroyWeak(v23);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1001BC26C(id *a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained(a1 + 9);
  BOOL v5 = [WeakRetained databaseProvider];
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  void v7[2] = sub_1001BC3CC;
  v7[3] = &unk_100306BD8;
  id v8 = a1[4];
  id v9 = a1[5];
  id v6 = v3;
  id v10 = v6;
  id v11 = a1[6];
  id v14 = a1[8];
  id v12 = a1[7];
  objc_copyWeak(&v15, a1 + 9);
  id v13 = WeakRetained;
  [v5 dispatchSyncWithReadOnlySQLTransaction:v7];

  objc_destroyWeak(&v15);
}

void sub_1001BC3B8(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_1001BC3CC(uint64_t a1)
{
  uint64_t v2 = (id *)(a1 + 40);
  id v3 = *(void **)(a1 + 32);
  id v4 = [*(id *)(a1 + 40) zoneID];
  BOOL v5 = [*v2 contextID];
  id v161 = 0;
  uint64_t v127 = [v3 makeCKKSKey:v4 contextID:v5 error:&v161];
  id v128 = v161;

  if (v127 && !v128)
  {
    id v6 = *(void **)(a1 + 32);
    id v7 = [*(id *)(a1 + 40) contextID];
    id v8 = [*(id *)(a1 + 40) zoneID];
    id v160 = 0;
    unsigned int v126 = [v6 makeFakeCKKSClassKey:@"classA" contextID:v7 zoneiD:v8 error:&v160];
    id v9 = v160;

    id v10 = *(void **)(a1 + 32);
    id v11 = [*(id *)(a1 + 40) contextID];
    id v12 = [*(id *)(a1 + 40) zoneID];
    id v159 = v9;
    char v125 = [v10 makeFakeCKKSClassKey:@"classC" contextID:v11 zoneiD:v12 error:&v159];
    id v128 = v159;

    if (!v126 || !v125)
    {
      long long v25 = [*(id *)(a1 + 40) zoneID];
      long long v26 = [v25 zoneName];
      uint64_t v27 = sub_1000CD884(@"ckks-se", v26);

      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        *(void *)id v164 = v128;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "Unable to make fake class keys: %@", buf, 0xCu);
      }

      [*(id *)(a1 + 48) setError:v128];
      goto LABEL_80;
    }
    id v13 = *(void **)(a1 + 56);
    if (v13)
    {
      id v14 = [v13 uuid];
      id v15 = [*(id *)(a1 + 40) contextID];
      __int16 v16 = [*(id *)(a1 + 40) zoneID];
      id v158 = 0;
      unsigned int v131 = +[CKKSKey fromDatabase:v14 contextID:v15 zoneID:v16 error:&v158];
      id v124 = v158;

      if (!v131 || v124)
      {
        long long v107 = [*(id *)(a1 + 40) zoneID];
        id v108 = [v107 zoneName];
        long long v109 = sub_1000CD884(@"ckks-se", v108);

        if (os_log_type_enabled(v109, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138412290;
          *(void *)id v164 = v124;
          _os_log_impl((void *)&_mh_execute_header, v109, OS_LOG_TYPE_ERROR, "Unable to load old TLK: %@", buf, 0xCu);
        }

        (*(void (**)(void))(*(void *)(a1 + 80) + 16))();
        goto LABEL_79;
      }
      uint64_t v17 = *(void **)(a1 + 56);
      id v18 = [*(id *)(a1 + 40) zoneID];
      uint64_t v19 = [*(id *)(a1 + 40) contextID];
      id v157 = 0;
      id v124 = [v17 makeCKKSKey:v18 contextID:v19 error:&v157];
      id v20 = v157;

      if (!v124 || v20)
      {
        long long v113 = [*(id *)(a1 + 40) zoneID];
        long long v114 = [v113 zoneName];
        long long v115 = sub_1000CD884(@"ckks-se", v114);

        if (os_log_type_enabled(v115, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138412290;
          *(void *)id v164 = v20;
          _os_log_impl((void *)&_mh_execute_header, v115, OS_LOG_TYPE_ERROR, "Unable to convert old TLK: %@", buf, 0xCu);
        }

        [*(id *)(a1 + 48) setError:v20];
        goto LABEL_79;
      }
      id v21 = [v131 storedCKRecord];
      [v124 setStoredCKRecord:v21];
    }
    else
    {
      id v124 = 0;
    }
    unsigned int v131 = +[NSMutableArray array];
    long long v155 = 0u;
    long long v156 = 0u;
    long long v153 = 0u;
    long long v154 = 0u;
    id v28 = *(id *)(a1 + 64);
    id v29 = [v28 countByEnumeratingWithState:&v153 objects:v167 count:16];
    if (v29)
    {
      uint64_t v30 = *(void *)v154;
      do
      {
        for (CFIndex i = 0; i != v29; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v154 != v30) {
            objc_enumerationMutation(v28);
          }
          unsigned int v32 = *(void **)(*((void *)&v153 + 1) + 8 * i);
          uint64_t v33 = [*(id *)(a1 + 40) zoneID];
          id v34 = [*(id *)(a1 + 40) contextID];
          id v35 = [v32 makeTLKShareRecord:v33 contextID:v34];

          [v131 addObject:v35];
        }
        id v29 = [v28 countByEnumeratingWithState:&v153 objects:v167 count:16];
      }
      while (v29);
    }

    BOOL v36 = [*(id *)(a1 + 40) zoneID];
    char v37 = [v36 zoneName];
    id v38 = sub_1000CD884(@"ckks-se", v37);

    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)id v164 = v127;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "Trying to set TLK %@", buf, 0xCu);
    }

    unint64_t v39 = [*(id *)(a1 + 40) zoneID];
    char v40 = [v39 zoneName];
    char v41 = sub_1000CD884(@"ckks-se", v40);

    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)id v164 = v124;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Wrapped old TLK: %@", buf, 0xCu);
    }

    unsigned int v42 = [*(id *)(a1 + 40) zoneID];
    unint64_t v43 = [v42 zoneName];
    char v44 = sub_1000CD884(@"ckks-se", v43);

    if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)id v164 = v131;
      _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "TLKShares: %@", buf, 0xCu);
    }

    char v45 = [*(id *)(a1 + 40) contextID];
    unsigned int v46 = [v127 uuid];
    unint64_t v47 = [*(id *)(a1 + 40) zoneID];
    id v152 = 0;
    uint64_t v122 = +[CKKSCurrentKeyPointer forKeyClass:@"tlk" contextID:v45 withKeyUUID:v46 zoneID:v47 error:&v152];
    id v123 = v152;

    if (!v122 || v123)
    {
      long long v110 = [*(id *)(a1 + 40) zoneID];
      long long v111 = [v110 zoneName];
      long long v112 = sub_1000CD884(@"ckks-se", v111);

      if (os_log_type_enabled(v112, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        *(void *)id v164 = v123;
        _os_log_impl((void *)&_mh_execute_header, v112, OS_LOG_TYPE_ERROR, "Unable to create CKP: %@", buf, 0xCu);
      }

      [*(id *)(a1 + 48) setError:v123];
    }
    else
    {
      char v48 = [*(id *)(a1 + 40) contextID];
      char v49 = [v126 uuid];
      unsigned int v50 = [*(id *)(a1 + 40) zoneID];
      id v151 = 0;
      char v120 = +[CKKSCurrentKeyPointer forKeyClass:@"classA" contextID:v48 withKeyUUID:v49 zoneID:v50 error:&v151];
      id v51 = v151;

      unsigned int v52 = [*(id *)(a1 + 40) contextID];
      id v53 = [v125 uuid];
      id v54 = [*(id *)(a1 + 40) zoneID];
      id v150 = v51;
      char v119 = +[CKKSCurrentKeyPointer forKeyClass:@"classC" contextID:v52 withKeyUUID:v53 zoneID:v54 error:&v150];
      id v123 = v150;

      if (v120 && v119)
      {
        long long v55 = +[NSMutableArray array];
        long long v56 = [*(id *)(a1 + 40) zoneID];
        long long v57 = [v127 CKRecordWithZoneID:v56];
        [v55 addObject:v57];

        long long v58 = [*(id *)(a1 + 40) zoneID];
        id v59 = [v126 CKRecordWithZoneID:v58];
        [v55 addObject:v59];

        id v60 = [*(id *)(a1 + 40) zoneID];
        id v61 = [v125 CKRecordWithZoneID:v60];
        [v55 addObject:v61];

        unsigned int v62 = [*(id *)(a1 + 40) zoneID];
        id v63 = [v122 CKRecordWithZoneID:v62];
        [v55 addObject:v63];

        id v64 = [*(id *)(a1 + 40) zoneID];
        char v65 = [v120 CKRecordWithZoneID:v64];
        [v55 addObject:v65];

        unsigned int v66 = [*(id *)(a1 + 40) zoneID];
        unint64_t v67 = [v119 CKRecordWithZoneID:v66];
        [v55 addObject:v67];

        if (v124)
        {
          char v68 = [*(id *)(a1 + 40) zoneID];
          char v69 = [v124 CKRecordWithZoneID:v68];
          [v55 addObject:v69];
        }
        long long v148 = 0u;
        long long v149 = 0u;
        long long v146 = 0u;
        long long v147 = 0u;
        id v70 = v131;
        id v71 = [v70 countByEnumeratingWithState:&v146 objects:v166 count:16];
        if (v71)
        {
          uint64_t v72 = *(void *)v147;
          do
          {
            for (j = 0; j != v71; j = (char *)j + 1)
            {
              if (*(void *)v147 != v72) {
                objc_enumerationMutation(v70);
              }
              unsigned int v74 = *(void **)(*((void *)&v146 + 1) + 8 * (void)j);
              unint64_t v75 = [*(id *)(a1 + 40) zoneID:v119];
              char v76 = [v74 CKRecordWithZoneID:v75];
              [v55 addObject:v76];
            }
            id v71 = [v70 countByEnumeratingWithState:&v146 objects:v166 count:16];
          }
          while (v71);
        }

        char v130 = +[NSMutableDictionary dictionary];
        long long v144 = 0u;
        long long v145 = 0u;
        long long v142 = 0u;
        long long v143 = 0u;
        id v77 = v55;
        id v78 = [v77 countByEnumeratingWithState:&v142 objects:v165 count:16];
        if (v78)
        {
          uint64_t v79 = *(void *)v143;
          do
          {
            for (k = 0; k != v78; k = (char *)k + 1)
            {
              if (*(void *)v143 != v79) {
                objc_enumerationMutation(v77);
              }
              char v81 = *(void **)(*((void *)&v142 + 1) + 8 * (void)k);
              unsigned int v82 = [v81 recordID:v119];
              [v130 setObject:v81 forKeyedSubscript:v82];
            }
            id v78 = [v77 countByEnumeratingWithState:&v142 objects:v165 count:16];
          }
          while (v78);
        }

        id v121 = [objc_alloc((Class)CKModifyRecordsOperation) initWithRecordsToSave:v77 recordIDsToDelete:&__NSArray0__struct];
        [v121 setAtomic:1];
        uint64_t v83 = [v121 configuration];
        [v83 setIsCloudKitSupportOperation:1];

        [v121 setSavePolicy:0];
        unint64_t v84 = [*(id *)(a1 + 40) zoneID];
        uint64_t v85 = [v84 zoneName];
        id v86 = sub_1000CD884(@"ckks-se", v85);

        if (os_log_type_enabled(v86, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v87 = [v121 qualityOfService];
          uint64_t v88 = [v121 group];
          *(_DWORD *)long long buf = 67109378;
          *(_DWORD *)id v164 = v87;
          *(_WORD *)&v164[4] = 2112;
          *(void *)&v164[6] = v88;
          _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEFAULT, "QoS: %d; operation group is %@",
            buf,
            0x12u);
        }
        unint64_t v89 = [*(id *)(a1 + 40) zoneID];
        char v90 = [v89 zoneName];
        char v91 = sub_1000CD884(@"ckks-se", v90);

        if (os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v92 = [v77 count];
          *(_DWORD *)long long buf = 67109120;
          *(_DWORD *)id v164 = v92;
          _os_log_impl((void *)&_mh_execute_header, v91, OS_LOG_TYPE_DEFAULT, "Beginning upload for %d records", buf, 8u);
        }

        long long v140 = 0u;
        long long v141 = 0u;
        long long v138 = 0u;
        long long v139 = 0u;
        id obj = v77;
        id v93 = [obj countByEnumeratingWithState:&v138 objects:v162 count:16];
        if (v93)
        {
          uint64_t v94 = *(void *)v139;
          do
          {
            for (m = 0; m != v93; m = (char *)m + 1)
            {
              if (*(void *)v139 != v94) {
                objc_enumerationMutation(obj);
              }
              id v96 = *(void **)(*((void *)&v138 + 1) + 8 * (void)m);
              id v97 = [v96 recordID:v119];
              id v98 = [v97 zoneID];
              id v99 = [v98 zoneName];
              long long v100 = sub_1000CD884(@"ckks-se", v99);

              if (os_log_type_enabled(v100, OS_LOG_TYPE_DEBUG))
              {
                long long v101 = [v96 recordID];
                *(_DWORD *)long long buf = 138412290;
                *(void *)id v164 = v101;
                _os_log_debug_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_DEBUG, "Record to save: %@", buf, 0xCu);
              }
            }
            id v93 = [obj countByEnumeratingWithState:&v138 objects:v162 count:16];
          }
          while (v93);
        }

        [v121 setPerRecordSaveBlock:&stru_100306B40];
        long long v102 = +[CKKSResultOperation named:@"wait-until-write-finished" withBlock:&stru_100306B60];
        [*(id *)(a1 + 48) dependOnBeforeGroupFinished:v102];
        v132[0] = _NSConcreteStackBlock;
        v132[1] = 3221225472;
        v132[2] = sub_1001BD63C;
        v132[3] = &unk_100306BB0;
        objc_copyWeak(&v137, (id *)(a1 + 88));
        id v133 = *(id *)(a1 + 40);
        id v103 = v130;
        id v134 = v103;
        id v135 = *(id *)(a1 + 48);
        id v104 = v102;
        id v136 = v104;
        [v121 setModifyRecordsCompletionBlock:v132];
        long long v105 = [*(id *)(a1 + 72) operationDependencies];
        long long v106 = [v105 ckdatabase];
        [v106 addOperation:v121];

        objc_destroyWeak(&v137);
      }
      else
      {
        long long v116 = [*(id *)(a1 + 40) zoneID:v119];
        id v117 = [v116 zoneName];
        unint64_t v118 = sub_1000CD884(@"ckks-se", v117);

        if (os_log_type_enabled(v118, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138412290;
          *(void *)id v164 = v123;
          _os_log_impl((void *)&_mh_execute_header, v118, OS_LOG_TYPE_ERROR, "Unable to create class CKP: %@", buf, 0xCu);
        }

        [*(id *)(a1 + 48) setError:v123];
      }
    }
LABEL_79:

LABEL_80:
    goto LABEL_81;
  }
  long long v22 = [*(id *)(a1 + 40) zoneID];
  long long v23 = [v22 zoneName];
  long long v24 = sub_1000CD884(@"ckks-se", v23);

  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 138412290;
    *(void *)id v164 = v128;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Unable to make TLK: %@", buf, 0xCu);
  }

  [*(id *)(a1 + 48) setError:v128];
LABEL_81:
}

void sub_1001BD61C(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_1001BD63C(id *a1, void *a2, uint64_t a3, void *a4)
{
  id v6 = a2;
  id v7 = a4;
  id WeakRetained = objc_loadWeakRetained(a1 + 8);
  id v9 = [WeakRetained databaseProvider];
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1001BD774;
  v12[3] = &unk_100306B88;
  id v13 = v7;
  id v14 = a1[4];
  id v15 = WeakRetained;
  id v16 = a1[5];
  id v17 = a1[6];
  id v18 = a1[7];
  id v19 = v6;
  id v10 = v6;
  id v11 = v7;
  [v9 dispatchSyncWithSQLTransaction:v12];
}

uint64_t sub_1001BD774(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = [*(id *)(a1 + 40) zoneID];
  id v4 = [v3 zoneName];
  BOOL v5 = sub_1000CD884(@"ckks-se", v4);

  if (v2)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = *(void *)(a1 + 32);
      *(_DWORD *)long long buf = 138412290;
      uint64_t v22 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "error proposing new TLK: %@", buf, 0xCu);
    }

    id v7 = [*(id *)(a1 + 48) operationDependencies];
    [v7 intransactionCKWriteFailed:*(void *)(a1 + 32) attemptedRecordsChanged:*(void *)(a1 + 56)];

    [*(id *)(a1 + 64) setError:*(void *)(a1 + 32)];
  }
  else
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Completed uploading new TLK!", buf, 2u);
    }

    long long v18 = 0u;
    long long v19 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    id v8 = *(id *)(a1 + 80);
    id v9 = [v8 countByEnumeratingWithState:&v16 objects:v20 count:16];
    if (v9)
    {
      id v10 = v9;
      uint64_t v11 = *(void *)v17;
      do
      {
        for (CFIndex i = 0; i != v10; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v17 != v11) {
            objc_enumerationMutation(v8);
          }
          uint64_t v13 = *(void *)(*((void *)&v16 + 1) + 8 * i);
          id v14 = [*(id *)(a1 + 48) operationDependencies:v16];
          [v14 intransactionCKRecordChanged:v13 resync:0];
        }
        id v10 = [v8 countByEnumeratingWithState:&v16 objects:v20 count:16];
      }
      while (v10);
    }
  }
  [*(id *)(a1 + 64) runBeforeGroupFinished:*(void *)(a1 + 72) v16];
  return 1;
}

void sub_1001BD98C(id a1, CKRecordID *a2, CKRecord *a3, NSError *a4)
{
  uint64_t v6 = a2;
  id v7 = a3;
  id v8 = a4;
  id v9 = [(CKRecordID *)v6 zoneID];
  id v10 = [v9 zoneName];
  uint64_t v11 = sub_1000CD884(@"ckks-se", v10);

  if (v8)
  {
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      int v14 = 138412546;
      id v15 = v8;
      __int16 v16 = 2112;
      long long v17 = v6;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "error on row: %@ %@", (uint8_t *)&v14, 0x16u);
    }
  }
  else if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    id v12 = [(CKRecordID *)v6 recordName];
    uint64_t v13 = [(CKRecord *)v7 recordChangeTag];
    int v14 = 138412546;
    id v15 = v12;
    __int16 v16 = 2112;
    long long v17 = v13;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Record upload successful for %@ (%@)", (uint8_t *)&v14, 0x16u);
  }
}

void sub_1001C4944(id a1)
{
  v4[0] = kSecAttrAccessGroup;
  v4[1] = kSecAttrSharingGroup;
  void v4[2] = kSecAttrAccount;
  void v4[3] = kSecAttrProtocol;
  void v4[4] = kSecAttrServer;
  void v4[5] = kSecAttrPort;
  void v4[6] = kSecAttrPath;
  void v4[7] = kSecAttrAuthenticationType;
  v4[8] = kSecValueData;
  v4[9] = kSecAttrCreationDate;
  v4[10] = kSecAttrModificationDate;
  void v4[11] = kSecAttrComment;
  v4[12] = kSecAttrLabel;
  v4[13] = kSecAttrAccessible;
  v4[14] = kSecAttrSyncViewHint;
  v4[15] = kSecAttrSecurityDomain;
  uint8_t v4[16] = kSecDataInetExtraNotes;
  v4[17] = kSecDataInetExtraHistory;
  v4[18] = kSecDataInetExtraClientDefined0;
  v4[19] = kSecDataInetExtraClientDefined1;
  v4[20] = kSecDataInetExtraClientDefined2;
  v4[21] = kSecDataInetExtraClientDefined3;
  dispatch_queue_t v1 = +[NSArray arrayWithObjects:v4 count:22];
  uint64_t v2 = +[NSSet setWithArray:v1];
  id v3 = (void *)qword_10035D258;
  qword_10035D258 = v2;
}

void sub_1001C4B2C(id a1)
{
  dispatch_queue_t v1 = sub_10000B070("engine");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Performing keychain backup after unlock because backing up while locked failed", buf, 2u);
  }

  uint64_t v2 = sub_10021C7D8();
  id v3 = v2;
  if (v2)
  {
    [v2 performTransaction:&stru_100306D68];
  }
  else
  {
    id v4 = sub_10000B070("ckks");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)BOOL v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Failed to get account object", v5, 2u);
    }
  }
}

void sub_1001C4C10(id a1, SOSAccountTransaction *a2)
{
  CFTypeRef cf = 0;
  CFMutableSetRef v2 = sub_1001ED2C8(a2, (uint64_t)&cf);
  if (v2)
  {
    id v3 = sub_10000B070("engine");
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_7;
    }
    *(_DWORD *)long long buf = 138412290;
    CFTypeRef v8 = v2;
    id v4 = "SOSEnsureBackup: SOS made a backup of views: %@";
  }
  else
  {
    id v3 = sub_10000B070("SecError");
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_7;
    }
    *(_DWORD *)long long buf = 138412290;
    CFTypeRef v8 = cf;
    id v4 = "engine: SOSEnsureBackup: encountered an error while making backup (%@)";
  }
  _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, v4, buf, 0xCu);
LABEL_7:

  CFTypeRef v5 = cf;
  if (cf)
  {
    CFTypeRef cf = 0;
    CFRelease(v5);
  }
}

void sub_1001C4D2C(id a1)
{
  uint64_t v1 = objc_opt_new();
  CFMutableSetRef v2 = (void *)qword_10035D270;
  qword_10035D270 = v1;

  qword_10035D278 = +[CKKSLockStateTracker globalTracker];

  _objc_release_x1();
}

void sub_1001C4ED4(uint64_t a1)
{
  CFMutableSetRef v2 = KCSharingLogObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    id v10 = [*(id *)(a1 + 32) clientConnections];
    *(_DWORD *)long long buf = 138543362;
    long long v17 = v10;
    _os_log_debug_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "calling accountChanged to connections %{public}@", buf, 0xCu);
  }
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  id v3 = [*(id *)(a1 + 32) clientConnections];
  id v4 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v12;
    do
    {
      id v7 = 0;
      do
      {
        if (*(void *)v12 != v6) {
          objc_enumerationMutation(v3);
        }
        CFTypeRef v8 = [*(id *)(*((void *)&v11 + 1) + 8 * (void)v7) connection];
        id v9 = [v8 remoteObjectProxy];
        [v9 accountChanged];

        id v7 = (char *)v7 + 1;
      }
      while (v5 != v7);
      id v5 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }
    while (v5);
  }
}

void sub_1001C50E8(uint64_t a1)
{
  CFMutableSetRef v2 = KCSharingLogObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    id v10 = [*(id *)(a1 + 32) clientConnections];
    *(_DWORD *)long long buf = 138412290;
    long long v17 = v10;
    _os_log_debug_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "calling groupsUpdated to connections %@", buf, 0xCu);
  }
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  id v3 = [*(id *)(a1 + 32) clientConnections];
  id v4 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v12;
    do
    {
      id v7 = 0;
      do
      {
        if (*(void *)v12 != v6) {
          objc_enumerationMutation(v3);
        }
        CFTypeRef v8 = [*(id *)(*((void *)&v11 + 1) + 8 * (void)v7) connection];
        id v9 = [v8 remoteObjectProxy];
        [v9 groupsUpdated];

        id v7 = (char *)v7 + 1;
      }
      while (v5 != v7);
      id v5 = [v3 countByEnumeratingWithState:&v11 objects:v15 count:16];
    }
    while (v5);
  }
}

id sub_1001C53B4(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) isEqual:a2];
}

void sub_1001C5474(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v2 = objc_loadWeakRetained((id *)(a1 + 40));
  [WeakRetained connectionWasInterrupted:v2];
}

void sub_1001C54D8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v2 = objc_loadWeakRetained((id *)(a1 + 40));
  [WeakRetained connectionWasInvalidated:v2];
}

void sub_1001C5804(id a1)
{
  if (objc_opt_class())
  {
    id v2 = objc_alloc_init(KCSharingXPCListenerDelegate);
    id v3 = (void *)qword_10035D288;
    qword_10035D288 = (uint64_t)v2;

    uint64_t v4 = qword_10035D288;
    id v5 = +[KCSharingSyncController sharedInstance];
    [v5 setXpcListenerDelegate:v4];

    uint64_t v6 = qword_10035D288;
    id v7 = +[KCSharingDaemonGroupManager sharedInstance];
    [v7 setXpcListenerDelegate:v6];
  }
  else
  {
    CFTypeRef v8 = KCSharingLogObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v9 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "KCSharing is unavailable, you don't get an xpc delegate", v9, 2u);
    }
  }
}

void sub_1001C8168(id a1)
{
  uint64_t v1 = CKAcceptableValueClasses();
  uint64_t v2 = +[NSMutableSet setWithSet:v1];
  id v3 = (void *)qword_10035D290;
  qword_10035D290 = v2;

  uint64_t v4 = (void *)qword_10035D290;
  id v5 = +[SecXPCHelper safeErrorClasses];
  [v4 unionSet:v5];
}

uint64_t sub_1001CB794(unsigned char *a1, uint64_t a2)
{
  if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    uint64_t v4 = &OBJC_IVAR___KCSharingInternetPasswordCredential__accessGroup;
    id v5 = &OBJC_IVAR___KCSharingInternetPasswordCredential__accessGroup;
    uint64_t v6 = &OBJC_IVAR___KCSharingInternetPasswordCredential__accessGroup;
    while (1)
    {
      if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
      }
      char v7 = 0;
      unsigned int v8 = 0;
      unint64_t v9 = 0;
      while (1)
      {
        unint64_t v10 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v10 == -1 || v10 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
          break;
        }
        char v11 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v10);
        *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v10 + 1;
        v9 |= (unint64_t)(v11 & 0x7F) << v7;
        if ((v11 & 0x80) == 0) {
          goto LABEL_12;
        }
        v7 += 7;
        BOOL v12 = v8++ >= 9;
        if (v12)
        {
          unint64_t v9 = 0;
          int v13 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
          goto LABEL_14;
        }
      }
      *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_12:
      int v13 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
      if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        unint64_t v9 = 0;
      }
LABEL_14:
      if (v13 || (v9 & 7) == 4) {
        return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
      }
      unint64_t v15 = v9 >> 3;
      if ((int)(v9 >> 3) <= 200)
      {
        switch((int)v15)
        {
          case 'e':
            uint64_t v16 = PBReaderReadString();
            uint64_t v17 = v4[89];
            goto LABEL_44;
          case 'f':
            uint64_t v16 = PBReaderReadString();
            uint64_t v17 = v5[90];
            goto LABEL_44;
          case 'g':
            uint64_t v16 = PBReaderReadString();
            uint64_t v17 = v6[91];
            goto LABEL_44;
          case 'h':
            uint64_t v16 = PBReaderReadString();
            uint64_t v17 = 40;
            goto LABEL_44;
          case 'i':
            char v22 = 0;
            unsigned int v23 = 0;
            uint64_t v24 = 0;
            a1[84] |= 1u;
            break;
          default:
            goto LABEL_47;
        }
        while (1)
        {
          unint64_t v25 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v25 == -1 || v25 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            break;
          }
          char v26 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v25);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v25 + 1;
          v24 |= (unint64_t)(v26 & 0x7F) << v22;
          if ((v26 & 0x80) == 0) {
            goto LABEL_50;
          }
          v22 += 7;
          BOOL v12 = v23++ >= 9;
          if (v12)
          {
            uint64_t v24 = 0;
            goto LABEL_52;
          }
        }
        *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_50:
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v24 = 0;
        }
LABEL_52:
        a1[80] = v24 != 0;
        goto LABEL_45;
      }
      if ((int)v15 <= 202) {
        break;
      }
      if (v15 == 203)
      {
        uint64_t v16 = PBReaderReadString();
        uint64_t v17 = 24;
        goto LABEL_44;
      }
      if (v15 == 301)
      {
        uint64_t v16 = PBReaderReadString();
        uint64_t v17 = 72;
        goto LABEL_44;
      }
      if (v15 != 302) {
        goto LABEL_47;
      }
      long long v18 = v6;
      long long v19 = v5;
      id v20 = v4;
      id v21 = objc_alloc_init(SECC2MPInternalTestConfig);
      [a1 addInternalTestConfig:v21];
      if (!PBReaderPlaceMark() || !sub_1000F800C((uint64_t)v21, a2))
      {

        return 0;
      }
      PBReaderRecallMark();

      uint64_t v4 = v20;
      id v5 = v19;
      uint64_t v6 = v18;
LABEL_45:
      if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
      }
    }
    if (v15 == 201)
    {
      uint64_t v16 = PBReaderReadString();
      uint64_t v17 = 16;
      goto LABEL_44;
    }
    if (v15 == 202)
    {
      uint64_t v16 = PBReaderReadString();
      uint64_t v17 = 32;
LABEL_44:
      uint64_t v27 = *(void **)&a1[v17];
      *(void *)&a1[v17] = v16;

      goto LABEL_45;
    }
LABEL_47:
    uint64_t result = PBReaderSkipValueWithTag();
    if (!result) {
      return result;
    }
    goto LABEL_45;
  }
  return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

void sub_1001CC1C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1001CC1E8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = [WeakRetained operationDependencies];
  id v3 = [v2 ckks];
  uint64_t v4 = [v3 zoneChangeFetcher];
  id v5 = [v4 inflightFetch];
  [WeakRetained addNullableSuccessDependency:v5];

  uint64_t v6 = sub_10000B070("octagon-ckks");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    char v7 = [WeakRetained operationDependencies];
    unsigned int v8 = [v7 ckks];
    int v12 = 138412290;
    int v13 = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Waiting for CKKS Priority view download for %@", (uint8_t *)&v12, 0xCu);
  }
  unint64_t v9 = [WeakRetained operationDependencies];
  unint64_t v10 = [v9 ckks];
  char v11 = [v10 rpcProcessIncomingQueue:0 errorOnClassAFailure:0];
  [WeakRetained addSuccessDependency:v11];
}

uint64_t sub_1001CC89C(uint64_t a1, uint64_t a2)
{
  while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0;
    while (1)
    {
      unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v7 == -1 || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v8 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
      v6 |= (unint64_t)(v8 & 0x7F) << v4;
      if ((v8 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v9 = v5++ >= 9;
      if (v9)
      {
        unint64_t v6 = 0;
        int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }
    *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0;
    }
LABEL_13:
    if (v10 || (v6 & 7) == 4) {
      return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    unint64_t v12 = v6 >> 3;
    if ((v6 >> 3) == 101)
    {
      char v15 = 0;
      unsigned int v16 = 0;
      uint64_t v17 = 0;
      *(unsigned char *)(a1 + 28) |= 1u;
      while (1)
      {
        unint64_t v18 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v18 == -1 || v18 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
          break;
        }
        char v19 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v18);
        *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v18 + 1;
        v17 |= (unint64_t)(v19 & 0x7F) << v15;
        if ((v19 & 0x80) == 0) {
          goto LABEL_33;
        }
        v15 += 7;
        BOOL v9 = v16++ >= 9;
        if (v9)
        {
          uint64_t v17 = 0;
          goto LABEL_35;
        }
      }
      *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_33:
      if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        uint64_t v17 = 0;
      }
LABEL_35:
      *(unsigned char *)(a1 + 24) = v17 != 0;
    }
    else
    {
      if (v12 == 2)
      {
        uint64_t v13 = PBReaderReadString();
        uint64_t v14 = 16;
      }
      else
      {
        if (v12 != 1)
        {
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
          continue;
        }
        uint64_t v13 = PBReaderReadString();
        uint64_t v14 = 8;
      }
      id v20 = *(void **)(a1 + v14);
      *(void *)(a1 + v14) = v13;
    }
  }
  return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

id sub_1001CD1DC(uint64_t a1)
{
  return [*(id *)(a1 + 32) setHalted:1];
}

void sub_1001CD808(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id location)
{
}

void sub_1001CD85C(id *a1)
{
  id WeakRetained = objc_loadWeakRetained(a1 + 7);
  if (WeakRetained)
  {
    id v3 = [a1[4] error];

    if (v3)
    {
      char v4 = sub_1000CD884(@"ckksfetcher", 0);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        unsigned int v5 = [a1[4] error];
        *(_DWORD *)long long buf = 138412290;
        uint64_t v31 = v5;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Interrogating clients about fetch error: %@", buf, 0xCu);
      }
      id v19 = WeakRetained;
      unint64_t v6 = [WeakRetained strongClientMap];
      long long v25 = 0u;
      long long v26 = 0u;
      long long v27 = 0u;
      long long v28 = 0u;
      unint64_t v7 = [a1[4] fetchedZoneIDs];
      id v8 = [v7 countByEnumeratingWithState:&v25 objects:v29 count:16];
      if (v8)
      {
        id v9 = v8;
        char v10 = 0;
        uint64_t v11 = *(void *)v26;
        do
        {
          for (CFIndex i = 0; i != v9; CFIndex i = (char *)i + 1)
          {
            if (*(void *)v26 != v11) {
              objc_enumerationMutation(v7);
            }
            uint64_t v13 = *(void *)(*((void *)&v25 + 1) + 8 * i);
            uint64_t v14 = [v6 objectForKey:v13];
            if (v14)
            {
              char v15 = [a1[4] error];
              char v10 = v10 & 1 | [v14 shouldRetryAfterFetchError:v15 zoneID:v13];
            }
          }
          id v9 = [v7 countByEnumeratingWithState:&v25 objects:v29 count:16];
        }
        while (v9);
      }
      else
      {
        char v10 = 0;
      }

      char v17 = v10 & 1;
      id WeakRetained = v19;
    }
    else
    {
      char v17 = 0;
    }
    unint64_t v18 = [WeakRetained queue];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1001CDB70;
    block[3] = &unk_100306E78;
    void block[4] = WeakRetained;
    id v21 = a1[4];
    char v24 = v17;
    id v22 = a1[5];
    id v23 = a1[6];
    dispatch_sync(v18, block);
  }
  else
  {
    unsigned int v16 = sub_1000CD884(@"ckksfetcher", 0);
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Received a null self pointer; strange.",
        buf,
        2u);
    }
  }
}

void sub_1001CDB70(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 40) error];
  [*(id *)(a1 + 32) setLastCKFetchError:v2];

  id v3 = [*(id *)(a1 + 40) error];

  if (v3)
  {
    if (!*(unsigned char *)(a1 + 64))
    {
      unint64_t v18 = sub_1000CD884(@"ckksfetcher", 0);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        id v19 = [*(id *)(a1 + 40) error];
        *(_DWORD *)long long buf = 138412290;
        double v34 = *(double *)&v19;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "All clients thought %@ is a fatal error. Not restarting fetch.", buf, 0xCu);
      }
      goto LABEL_25;
    }
    char v4 = [*(id *)(a1 + 40) error];
    CKRetryAfterSecondsForError();
    double v6 = v5;

    unint64_t v7 = sub_1000CD884(@"ckksfetcher", 0);
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    if (v6 == 0.0)
    {
      if (v8)
      {
        id v20 = [*(id *)(a1 + 40) error];
        *(_DWORD *)long long buf = 138412290;
        double v34 = *(double *)&v20;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Fetch failed with error, restarting soon: %@", buf, 0xCu);
      }
    }
    else
    {
      if (v8)
      {
        id v9 = [*(id *)(a1 + 40) error];
        *(_DWORD *)long long buf = 134218242;
        double v34 = v6;
        __int16 v35 = 2112;
        BOOL v36 = v9;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Fetch failed with rate-limiting error, restarting in %.1f seconds: %@", buf, 0x16u);
      }
      unint64_t v7 = [*(id *)(a1 + 32) fetchScheduler];
      [v7 waitUntil:(unint64_t)(v6 * 1000000000.0)];
    }

    id v21 = [*(id *)(a1 + 32) currentFetchReasons];
    [v21 unionSet:*(void *)(a1 + 48)];

    id v22 = [*(id *)(a1 + 32) apnsPushes];
    [v22 unionSet:*(void *)(a1 + 56)];

    id v23 = [*(id *)(a1 + 32) reachabilityTracker];
    char v24 = [*(id *)(a1 + 40) error];
    unsigned int v25 = [v23 isNetworkError:v24];

    long long v26 = [*(id *)(a1 + 32) currentFetchReasons];
    long long v27 = v26;
    if (v25) {
      CFStringRef v28 = @"network";
    }
    else {
      CFStringRef v28 = @"fetchfailed";
    }
    [v26 addObject:v28];

    [*(id *)(a1 + 32) setNewRequests:1];
LABEL_24:
    unint64_t v18 = [*(id *)(a1 + 32) fetchScheduler];
    [v18 trigger];
LABEL_25:

    return;
  }
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  char v10 = [*(id *)(a1 + 32) inflightFetchDependencies];
  id v11 = [v10 countByEnumeratingWithState:&v29 objects:v37 count:16];
  if (v11)
  {
    id v12 = v11;
    uint64_t v13 = *(void *)v30;
    do
    {
      for (CFIndex i = 0; i != v12; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v30 != v13) {
          objc_enumerationMutation(v10);
        }
        uint64_t v15 = *(void *)(*((void *)&v29 + 1) + 8 * i);
        unsigned int v16 = [*(id *)(a1 + 32) operationQueue];
        [v16 addOperation:v15];
      }
      id v12 = [v10 countByEnumeratingWithState:&v29 objects:v37 count:16];
    }
    while (v12);
  }

  char v17 = [*(id *)(a1 + 32) inflightFetchDependencies];
  [v17 removeAllObjects];

  [*(id *)(a1 + 32) setCurrentFetch:0];
  if ([*(id *)(a1 + 32) newRequests]) {
    goto LABEL_24;
  }
}

id sub_1001CDFD4(uint64_t a1)
{
  return [*(id *)(a1 + 32) maybeCreateNewFetchOnQueue];
}

void sub_1001CE280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001CE298(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1001CE2A8(uint64_t a1)
{
}

uint64_t sub_1001CE2B0(uint64_t a1)
{
  if (([*(id *)(a1 + 32) newRequests] & 1) != 0
    || ([*(id *)(a1 + 32) inflightFetchDependency],
        uint64_t v2 = objc_claimAutoreleasedReturnValue(),
        v2,
        !v2))
  {
    uint64_t v3 = [*(id *)(a1 + 32) successfulFetchDependency];
  }
  else
  {
    uint64_t v3 = [*(id *)(a1 + 32) inflightFetchDependency];
  }
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = v3;

  return _objc_release_x1();
}

void sub_1001CE45C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1001CE474(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) successfulFetchDependency];
  uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8);
  char v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  [*(id *)(a1 + 32) setNewRequests:1];
  double v5 = [*(id *)(a1 + 32) currentFetchReasons];
  [v5 unionSet:*(void *)(a1 + 40)];

  id v6 = [*(id *)(a1 + 32) fetchScheduler];
  [v6 trigger];
}

void sub_1001CE7AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_1001CE7DC(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    uint64_t v2 = [*(id *)(a1 + 40) apnsPushes];
    [v2 addObject:*(void *)(a1 + 32)];

    if ([*(id *)(a1 + 32) ckksPushTracingEnabled])
    {
      uint64_t v3 = sub_1000CD884(@"ckksfetch", 0);
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v4 = *(void *)(a1 + 32);
        int v15 = 138412290;
        uint64_t v16 = v4;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Submitting initial CKEventMetric due to notification %@", (uint8_t *)&v15, 0xCu);
      }

      id v5 = [objc_alloc((Class)CKEventMetric) initWithEventName:@"APNSPushMetrics"];
      [v5 setIsPushTriggerFired:1];
      id v6 = [*(id *)(a1 + 32) ckksPushTracingUUID];
      [v5 setObject:v6 forKeyedSubscript:@"push_token_uuid"];

      unint64_t v7 = [*(id *)(a1 + 32) ckksPushReceivedDate];
      [v5 setObject:v7 forKeyedSubscript:@"push_received_date"];

      [v5 setObject:@"CKKS APNS Push Received" forKeyedSubscript:@"push_event_name"];
      if (*(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24)) {
        CFStringRef v8 = @"not-ready";
      }
      else {
        CFStringRef v8 = @"ready";
      }
      [v5 setObject:v8 forKeyedSubscript:@"zones_status"];
      id v9 = [*(id *)(a1 + 40) container];
      [v9 submitEventMetric:v5];

      char v10 = [[SecEventMetric alloc] initWithEventName:@"APNSPushMetrics"];
      id v11 = [*(id *)(a1 + 32) ckksPushTracingUUID];
      [(SecEventMetric *)v10 setObject:v11 forKeyedSubscript:@"push_token_uuid"];

      id v12 = [*(id *)(a1 + 32) ckksPushReceivedDate];
      [(SecEventMetric *)v10 setObject:v12 forKeyedSubscript:@"push_received_date"];

      [(SecEventMetric *)v10 setObject:@"CKKS APNS Push Received-webtunnel" forKeyedSubscript:@"push_event_name"];
      if (*(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24)) {
        CFStringRef v13 = @"not-ready";
      }
      else {
        CFStringRef v13 = @"ready";
      }
      [v5 setObject:v13 forKeyedSubscript:@"zones_status"];
      uint64_t v14 = +[SecMetrics managerObject];
      [v14 submitEvent:v10];
    }
  }
}

void sub_1001CED68(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1001CEE2C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1001CF24C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1001CF270(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained maybeCreateNewFetch];
}

void sub_1001CFDBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1001CFDE8(uint64_t a1)
{
  uint64_t v2 = sub_10000B070("upgr-phase3");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "CKKSNFS triggered!", v6, 2u);
  }

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v4 = [[OctagonPendingFlag alloc] initWithFlag:@"schedule_pref_upgrade" conditions:1];
  id v5 = [WeakRetained stateMachine];
  [v5 handlePendingFlag:v4];
}

void sub_1001D02AC(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 72));
  _Unwind_Resume(a1);
}

void sub_1001D02D0(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6 = a4;
  id v7 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v9 = [v7 walrus];
  char v10 = [v7 webAccess];

  id v11 = [WeakRetained settings];
  id v12 = [v11 walrus];
  if (!v12)
  {

    goto LABEL_6;
  }
  CFStringRef v13 = v12;
  if (v9)
  {
    unsigned int v14 = [v9 value];
    int v15 = [WeakRetained settings];
    uint64_t v16 = [v15 walrus];
    id v17 = v6;
    unsigned int v18 = [v16 enabled];

    BOOL v19 = v14 == v18;
    id v6 = v17;
    if (!v19) {
      goto LABEL_8;
    }
LABEL_6:
    id v20 = 0;
    goto LABEL_19;
  }

LABEL_8:
  id v21 = sub_10000B070("SecError");
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    id v22 = [WeakRetained settings];
    id v23 = [v22 walrus];
    if ([v23 enabled]) {
      CFStringRef v24 = @"ON";
    }
    else {
      CFStringRef v24 = @"OFF";
    }
    if (v9)
    {
      if ([v9 value]) {
        CFStringRef v25 = @"ON";
      }
      else {
        CFStringRef v25 = @"OFF";
      }
    }
    else
    {
      CFStringRef v25 = @"none";
    }
    *(_DWORD *)long long buf = 138412802;
    CFStringRef v53 = v24;
    __int16 v54 = 2112;
    CFStringRef v55 = v25;
    __int16 v56 = 2112;
    id v57 = v6;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "octagon: error setting walrus: Intended value: %@, final value: %@, error: %@", buf, 0x20u);
  }
  id v20 = +[NSError errorWithDomain:@"com.apple.security.octagon" code:51 description:@"Failed to set walrus setting" underlying:v6];
LABEL_19:
  long long v26 = [WeakRetained settings];
  long long v27 = [v26 webAccess];
  if (!v27)
  {

    if (v20)
    {
LABEL_25:
      __int16 v35 = 0;
LABEL_40:
      [WeakRetained setError:v20];
      unint64_t v47 = [WeakRetained finishOp];
      [WeakRetained runBeforeGroupFinished:v47];

      goto LABEL_44;
    }
LABEL_43:
    char v49 = [WeakRetained intendedState];
    [WeakRetained setNextState:v49];

    id v20 = [WeakRetained finishOp];
    [WeakRetained runBeforeGroupFinished:v20];
    goto LABEL_44;
  }
  CFStringRef v28 = v27;
  if (v10)
  {
    unsigned int v50 = [v10 value];
    long long v29 = [WeakRetained settings];
    [v29 webAccess];
    long long v30 = v9;
    long long v31 = v10;
    v33 = id v32 = v6;
    unsigned int v34 = [v33 enabled];

    id v6 = v32;
    char v10 = v31;
    id v9 = v30;

    if (v50 == v34)
    {
      if (!v20) {
        goto LABEL_43;
      }
      goto LABEL_25;
    }
  }
  else
  {
  }
  id v51 = v9;
  BOOL v36 = v10;
  char v37 = sub_10000B070("SecError");
  if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
  {
    id v38 = [WeakRetained settings];
    unint64_t v39 = [v38 webAccess];
    id v40 = v6;
    if ([v39 enabled]) {
      CFStringRef v41 = @"ON";
    }
    else {
      CFStringRef v41 = @"OFF";
    }
    unsigned int v42 = [v36 value];
    *(_DWORD *)long long buf = 138412802;
    if (v42) {
      CFStringRef v43 = @"ON";
    }
    else {
      CFStringRef v43 = @"OFF";
    }
    CFStringRef v53 = v41;
    id v6 = v40;
    __int16 v54 = 2112;
    CFStringRef v55 = v43;
    __int16 v56 = 2112;
    id v57 = v40;
    _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "octagon: Error setting web access: Intended value: %@, final value: %@, error: %@", buf, 0x20u);
  }
  uint64_t v44 = +[NSError errorWithDomain:@"com.apple.security.octagon" code:52 description:@"Failed to set web access setting" underlying:v6];
  __int16 v35 = (void *)v44;
  if (!v20 || !v44)
  {
    char v10 = v36;
    if (v20)
    {
      id v9 = v51;
      goto LABEL_40;
    }
    id v9 = v51;
    if (v44)
    {
      [WeakRetained setError:v44];
      char v48 = [WeakRetained finishOp];
      [WeakRetained runBeforeGroupFinished:v48];

      id v20 = v35;
      goto LABEL_44;
    }
    goto LABEL_43;
  }
  uint64_t v45 = +[NSError errorWithDomain:@"com.apple.security.octagon" code:51 description:@"Failed to set walrus setting" underlying:v44];

  [WeakRetained setError:v45];
  unsigned int v46 = [WeakRetained finishOp];
  [WeakRetained runBeforeGroupFinished:v46];

  id v20 = (void *)v45;
  char v10 = v36;
  id v9 = v51;
LABEL_44:
}

uint64_t sub_1001D097C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1001D098C(uint64_t a1)
{
}

BOOL sub_1001D0994(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(unsigned int *)(a1 + 64);
  uint64_t v5 = *(unsigned int *)(a1 + 68);
  id v6 = *(void **)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 40);
  uint64_t v8 = *(unsigned __int8 *)(a1 + 72);
  uint64_t v9 = *(void *)(*(void *)(a1 + 56) + 8);
  id obj = *(id *)(v9 + 40);
  uint64_t v10 = [v6 fetchKeyForClass:v4 fromDb:a2 keybag:v5 specifier:v7 allowWrites:v8 error:&obj];
  objc_storeStrong((id *)(v9 + 40), obj);
  uint64_t v11 = *(void *)(*(void *)(a1 + 48) + 8);
  id v12 = *(void **)(v11 + 40);
  *(void *)(v11 + 40) = v10;

  if (!*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40))
  {
    CFStringRef v13 = [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) domain];
    if ([v13 isEqualToString:kCFErrorDomainOSStatus])
    {
      id v14 = [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) code];

      if (v14 == (id)-25308)
      {
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_1001D0EB0;
        block[3] = &unk_100308068;
        void block[4] = *(void *)(a1 + 56);
        if (qword_10035D2C0 != -1) {
          dispatch_once(&qword_10035D2C0, block);
        }
        dispatch_source_merge_data((dispatch_source_t)qword_10035D2B8, 1uLL);
        return *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) != 0;
      }
    }
    else
    {
    }
  }
  if (*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40))
  {
LABEL_9:
    uint64_t v15 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
    if (v15)
    {
      if (*(unsigned char *)(a1 + 73))
      {
        uint64_t v16 = *(void **)(*(void *)(a1 + 32) + 24);
        id v17 = +[NSNumber numberWithInt:*(unsigned int *)(a1 + 64)];
        [v16 setObject:v15 forKeyedSubscript:v17];
      }
    }
    else
    {
      __int16 v35 = sub_10000B070("SecError");
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v36 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
        *(_DWORD *)long long buf = 138412290;
        v51[0] = v36;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "SecDbMetadataKeyStore: scary error encountered: %@", buf, 0xCu);
      }
    }
    return *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) != 0;
  }
  if (*(unsigned char *)(a1 + 72))
  {
    unsigned int v18 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
    if (v18)
    {
      BOOL v19 = [v18 domain];
      if (([v19 isEqualToString:NSOSStatusErrorDomain] & 1) == 0)
      {

        goto LABEL_9;
      }
      id v20 = [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) code];

      if (v20 != (id)-26275) {
        goto LABEL_9;
      }
    }
    id v21 = sub_10000B070("SecWarning");
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      id v22 = [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) code];
      *(_DWORD *)long long buf = 134217984;
      v51[0] = v22;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "SecDbMetadataKeyStore: unable to use key (%ld), will attempt to create new one", buf, 0xCu);
    }

    uint64_t v23 = *(void *)(*(void *)(a1 + 56) + 8);
    CFStringRef v24 = *(void **)(v23 + 40);
    *(void *)(v23 + 40) = 0;

    uint64_t v25 = *(unsigned int *)(a1 + 64);
    uint64_t v26 = *(unsigned int *)(a1 + 68);
    long long v27 = *(void **)(a1 + 32);
    uint64_t v28 = *(void *)(a1 + 40);
    uint64_t v29 = *(void *)(*(void *)(a1 + 56) + 8);
    id v45 = *(id *)(v29 + 40);
    id v30 = [v27 newKeyForKeyclass:v25 withKeybag:v26 keySpecifier:v28 database:a2 error:&v45];
    objc_storeStrong((id *)(v29 + 40), v45);
    uint64_t v31 = *(void *)(*(void *)(a1 + 48) + 8);
    id v32 = *(void **)(v31 + 40);
    *(void *)(v31 + 40) = v30;

    if (*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40)) {
      return *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) != 0;
    }
    uint64_t v33 = sub_10000B070("SecError");
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v34 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
      *(_DWORD *)long long buf = 138412290;
      v51[0] = v34;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "SecDbMetadataKeyStore: unable to create or save new key: %@", buf, 0xCu);
    }
  }
  else
  {
    id v38 = sub_10000B070("SecWarning");
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      int v39 = *(_DWORD *)(a1 + 64);
      uint64_t v40 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
      *(_DWORD *)long long buf = 67109378;
      LODWORD(v51[0]) = v39;
      WORD2(v51[0]) = 2112;
      *(void *)((char *)v51 + 6) = v40;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "SecDbMetadataKeyStore: Unable to load metadatakey for class %d from disk (%@) and not allowed to create new one", buf, 0x12u);
    }

    if (!*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40))
    {
      NSErrorUserInfoKey v48 = NSLocalizedDescriptionKey;
      CFStringRef v49 = @"Unable to find a suitable metadata key and not permitted to create one";
      CFStringRef v41 = +[NSDictionary dictionaryWithObjects:&v49 forKeys:&v48 count:1];
      uint64_t v42 = +[NSError errorWithDomain:kCFErrorDomainOSStatus code:-26275 userInfo:v41];
      uint64_t v43 = *(void *)(*(void *)(a1 + 56) + 8);
      uint64_t v44 = *(void **)(v43 + 40);
      *(void *)(v43 + 40) = v42;
    }
  }
  return 0;
}

void sub_1001D0EB0(uint64_t a1)
{
  uint64_t v2 = sub_100029A10("keychainlockedlogmessage", 1);
  uint64_t v3 = (void *)qword_10035D2B8;
  qword_10035D2B8 = (uint64_t)v2;

  uint64_t v4 = qword_10035D2B8;
  aBlock[0] = _NSConcreteStackBlock;
  aBlock[1] = 3221225472;
  aBlock[2] = sub_1001D0F68;
  aBlock[3] = &unk_100308068;
  aBlock[4] = *(void *)(a1 + 32);
  long long context = dispatch_get_context((dispatch_object_t)qword_10035D2B8);
  context[2] = _Block_copy(aBlock);
  dispatch_activate(v4);
}

void sub_1001D0F68(uint64_t a1)
{
  uint64_t v2 = sub_10000B070("SecError");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) code];
    int v4 = 134217984;
    id v5 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SecDbKeychainItemV7: cannot decrypt metadata key because the keychain is locked (%ld)", (uint8_t *)&v4, 0xCu);
  }
}

void sub_1001D1444(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va1, a13);
  va_start(va, a13);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  uint64_t v19 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v13 - 128), 8);
  _Block_object_dispose((const void *)(v13 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001D1480(uint64_t a1, sqlite3_stmt *a2)
{
  char v4 = sub_10000E8B0(a2, 1, (const __CFString *)+[NSNumber numberWithInt:*(unsigned int *)(a1 + 80)], (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v5 + 24)) {
    char v6 = v4;
  }
  else {
    char v6 = 0;
  }
  *(unsigned char *)(v5 + 24) = v6;
  uint64_t v7 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_1001D1574;
  v13[3] = &unk_100306F88;
  uint64_t v8 = *(void *)(a1 + 64);
  uint64_t v9 = *(void *)(a1 + 72);
  uint64_t v15 = a2;
  uint64_t v16 = v9;
  long long v14 = *(_OWORD *)(a1 + 48);
  uint64_t result = sub_1000275B0(v8, a2, v7, (uint64_t)v13);
  uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v11 + 24)) {
    char v12 = result;
  }
  else {
    char v12 = 0;
  }
  *(unsigned char *)(v11 + 24) = v12;
  return result;
}

uint64_t sub_1001D1574(uint64_t a1)
{
  id v2 = objc_alloc((Class)NSData);
  id v3 = sqlite3_column_blob(*(sqlite3_stmt **)(a1 + 48), 0);
  id v4 = [v2 initWithBytes:v3 length:sqlite3_column_bytes(*(sqlite3_stmt **)(a1 + 48), 0)];
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
  char v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;

  uint64_t result = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 48), 1);
  **(_DWORD **)(a1 + 56) = result;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
  return result;
}

void sub_1001D1958(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v13 - 144), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001D1984(uint64_t a1, sqlite3_stmt *a2)
{
  char v4 = sub_10000E8B0(a2, 1, (const __CFString *)+[NSNumber numberWithInt:*(unsigned int *)(a1 + 64)], (CFTypeRef *)(*(void *)(*(void *)(a1 + 48) + 8) + 24));
  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  if (*(unsigned char *)(v5 + 24)) {
    char v6 = v4;
  }
  else {
    char v6 = 0;
  }
  *(unsigned char *)(v5 + 24) = v6;
  char v7 = sub_10000E8B0(a2, 2, (const __CFString *)+[NSNumber numberWithInt:*(unsigned int *)(a1 + 68)], (CFTypeRef *)(*(void *)(*(void *)(a1 + 48) + 8) + 24));
  uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8);
  if (*(unsigned char *)(v8 + 24)) {
    char v9 = v7;
  }
  else {
    char v9 = 0;
  }
  *(unsigned char *)(v8 + 24) = v9;
  BOOL v10 = sub_10000EE7C(a2, 3, [*(id *)(a1 + 32) bytes], (unint64_t)[*(id *)(a1 + 32) length], (CFTypeRef *)(*(void *)(*(void *)(a1 + 48) + 8) + 24));
  uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8);
  if (*(unsigned char *)(v11 + 24)) {
    BOOL v12 = v10;
  }
  else {
    BOOL v12 = 0;
  }
  *(unsigned char *)(v11 + 24) = v12;
  uint64_t result = sub_1000275B0(*(void *)(a1 + 56), a2, (CFTypeRef *)(*(void *)(*(void *)(a1 + 48) + 8) + 24), 0);
  uint64_t v14 = *(void *)(*(void *)(a1 + 40) + 8);
  if (*(unsigned char *)(v14 + 24)) {
    char v15 = result;
  }
  else {
    char v15 = 0;
  }
  *(unsigned char *)(v14 + 24) = v15;
  return result;
}

id sub_1001D1FAC(uint64_t a1)
{
  return [*(id *)(a1 + 32) _onQueueDropAllKeys];
}

id sub_1001D20E0(uint64_t a1)
{
  return [*(id *)(a1 + 32) _onQueueDropClassAKeys];
}

void sub_1001D2284(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1001D22A0(uint64_t a1)
{
  CFTypeRef cf = 0;
  *(_DWORD *)long long buf = -1431655766;
  uint64_t v2 = sub_10001AE90(dword_10035D2B0, buf);
  if (sub_100029664(v2, &cf, @"aks_get_lock_state failed: %x", v2))
  {
    if ((buf[0] & 1) == 0) {
      return;
    }
  }
  else
  {
    id v3 = sub_10000B070("SecError");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      CFTypeRef v8 = cf;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "SecDbKeychainMetadataKeyStore: error getting lock state: %@", buf, 0xCu);
    }

    CFTypeRef v4 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v4);
    }
  }
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained _onQueueDropClassAKeys];
}

void sub_1001D23B4(id a1)
{
  qword_10035D2A8 = (uint64_t)dispatch_queue_create("metadata_store", 0);

  _objc_release_x1();
}

void sub_1001D2450(id a1)
{
  uint64_t v1 = (void *)qword_10035D2A0;
  if (qword_10035D2A0)
  {
    [(id)qword_10035D2A0 dropAllKeys];
    uint64_t v1 = (void *)qword_10035D2A0;
  }
  qword_10035D2A0 = 0;
}

void sub_1001D2924(uint64_t a1, void *a2, void *a3)
{
  id v15 = a3;
  id v5 = a2;
  char v6 = objc_alloc_init(SECC2MPGenericEventMetric);
  [(SECC2MPGenericEventMetric *)v6 setKey:v5];

  char v7 = objc_alloc_init(SECC2MPGenericEventMetricValue);
  [(SECC2MPGenericEventMetric *)v6 setValue:v7];

  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    CFTypeRef v8 = [*(id *)(a1 + 32) generateError:v15];
    char v9 = [(SECC2MPGenericEventMetric *)v6 value];
    [v9 setErrorValue:v8];
  }
  else
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      BOOL v10 = *(void **)(a1 + 32);
      [v15 timeIntervalSinceReferenceDate];
      id v11 = [v10 convertTimeIntervalToServerTime:];
      CFTypeRef v8 = [(SECC2MPGenericEventMetric *)v6 value];
      [v8 setDateValue:v11];
    }
    else
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        [v15 doubleValue];
        double v13 = v12;
        CFTypeRef v8 = [(SECC2MPGenericEventMetric *)v6 value];
        [v8 setDoubleValue:v13];
      }
      else
      {
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0) {
          goto LABEL_11;
        }
        CFTypeRef v8 = [(SECC2MPGenericEventMetric *)v6 value];
        [v8 setStringValue:v15];
      }
    }
  }

  uint64_t v14 = [(SECC2MPGenericEventMetric *)v6 value];

  if (v14) {
    [*(id *)(a1 + 40) addMetric:v6];
  }
LABEL_11:
}

void sub_1001D2D08(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1001D2FCC(id a1)
{
  v4[0] = objc_opt_class();
  v4[1] = objc_opt_class();
  void v4[2] = objc_opt_class();
  void v4[3] = objc_opt_class();
  uint64_t v1 = +[NSArray arrayWithObjects:v4 count:4];
  uint64_t v2 = +[NSSet setWithArray:v1];
  id v3 = (void *)qword_10035D2D0;
  qword_10035D2D0 = v2;
}

void sub_1001D5748(_Unwind_Exception *a1)
{
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v3 - 72));
  _Unwind_Resume(a1);
}

void sub_1001D5780(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = KCSharingLogObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    uint64_t v3 = WeakRetained[1];
    int v4 = 138412290;
    uint64_t v5 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Connection was interrupted: %@", (uint8_t *)&v4, 0xCu);
  }

  *((unsigned char *)WeakRetained + 16) = 0;
}

void sub_1001D5840(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = KCSharingLogObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    uint64_t v3 = WeakRetained[1];
    int v4 = 138412290;
    uint64_t v5 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_INFO, "Connection was invalidated: %@", (uint8_t *)&v4, 0xCu);
  }

  *((unsigned char *)WeakRetained + 16) = 0;
}

void sub_1001D599C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, long long a9)
{
  if (a2 == 1)
  {
    id v9 = objc_begin_catch(exception_object);
    BOOL v10 = KCSharingLogObject();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      LODWORD(a9) = 138412290;
      *(void *)((char *)&a9 + 4) = v9;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Error performing selector on remote object: %@", (uint8_t *)&a9, 0xCu);
    }

    objc_end_catch();
    JUMPOUT(0x1001D5968);
  }
  _Unwind_Resume(exception_object);
}

void sub_1001D5A3C(id a1, NSError *a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = KCSharingLogObject();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    int v4 = 138412290;
    uint64_t v5 = v2;
    _os_log_error_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Error talking to AuthenticationServices: %@", (uint8_t *)&v4, 0xCu);
  }
}

void sub_1001D5B80(id a1)
{
  qword_10035D2E8 = objc_alloc_init(KCSharingGroupNotificationConnection);

  _objc_release_x1();
}

void sub_1001D5DD0(_Unwind_Exception *a1)
{
  objc_destroyWeak((id *)(v1 - 40));
  _Unwind_Resume(a1);
}

void sub_1001D5DE4(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  long long v8 = 0u;
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  uint64_t v3 = [WeakRetained monitors];
  id v4 = [v3 countByEnumeratingWithState:&v8 objects:v12 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v9;
    do
    {
      char v7 = 0;
      do
      {
        if (*(void *)v9 != v6) {
          objc_enumerationMutation(v3);
        }
        [*(id *)(*((void *)&v8 + 1) + 8 * (void)v7) accountStateUpdated:*(void *)(a1 + 32) from:*(void *)(a1 + 40)];
        char v7 = (char *)v7 + 1;
      }
      while (v5 != v7);
      id v5 = [v3 countByEnumeratingWithState:&v8 objects:v12 count:16];
    }
    while (v5);
  }
}

id sub_1001D611C(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 setSendingMetricsPermitted:*(unsigned int *)(a1 + 32)];

  return v3;
}

id sub_1001D6260(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 setAttemptedJoin:*(unsigned int *)(a1 + 32)];

  return v3;
}

id sub_1001D6350(uint64_t a1, void *a2)
{
  id v3 = a2;
  [*(id *)(a1 + 32) timeIntervalSince1970];
  [v3 setLastHealthCheckup:(unint64_t)(v4 * 1000.0)];

  return v3;
}

void sub_1001D65D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Block_object_dispose(&a19, 8);
  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a29, 8);
  _Block_object_dispose((const void *)(v29 - 128), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001D660C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1001D661C(uint64_t a1)
{
}

void sub_1001D6624(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(*(void *)(a1 + 56) + 8);
  id obj = *(id *)(v3 + 40);
  uint64_t v4 = [v2 _onqueueLoadOrCreateAccountMetadata:&obj];
  objc_storeStrong((id *)(v3 + 40), obj);
  uint64_t v5 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;

  char v7 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
  if (v7)
  {
    uint64_t v8 = *(void *)(a1 + 40);
    id v9 = [v7 copy];
    uint64_t v10 = (*(void (**)(uint64_t, id))(v8 + 16))(v8, v9);
    uint64_t v11 = *(void *)(*(void *)(a1 + 64) + 8);
    double v12 = *(void **)(v11 + 40);
    *(void *)(v11 + 40) = v10;

    double v13 = *(void **)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
    if (v13)
    {
      uint64_t v14 = [*(id *)(a1 + 32) containerName];
      id v15 = [*(id *)(a1 + 32) contextID];
      uint64_t v16 = [*(id *)(a1 + 32) personaAdapter];
      uint64_t v17 = [*(id *)(a1 + 32) activeAccount];
      uint64_t v18 = [v17 personaUniqueString];
      uint64_t v19 = *(void *)(*(void *)(a1 + 56) + 8);
      id v24 = *(id *)(v19 + 40);
      unsigned int v20 = [v13 saveToKeychainForContainer:v14 contextID:v15 personaAdapter:v16 personaUniqueString:v18 error:&v24];
      objc_storeStrong((id *)(v19 + 40), v24);

      uint64_t v21 = *(void *)(*(void *)(a1 + 72) + 8);
      if (!v20)
      {
        *(unsigned char *)(v21 + 24) = 0;
        uint64_t v22 = *(void *)(*(void *)(a1 + 64) + 8);
        uint64_t v23 = *(void **)(v22 + 40);
        *(void *)(v22 + 40) = 0;

        return;
      }
    }
    else
    {
      uint64_t v21 = *(void *)(*(void *)(a1 + 72) + 8);
    }
    *(unsigned char *)(v21 + 24) = 1;
  }
}

id sub_1001D6844(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 setTrustState:*(unsigned int *)(a1 + 32)];

  return v3;
}

id sub_1001D6934(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 setPeerID:*(void *)(a1 + 32)];

  return v3;
}

void sub_1001D6E54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_1001D6E78(void *a1)
{
  uint64_t v2 = (void *)a1[4];
  uint64_t v3 = *(void *)(a1[6] + 8);
  id obj = *(id *)(v3 + 40);
  uint64_t v4 = [v2 _onqueueLoadOrCreateAccountMetadata:&obj];
  objc_storeStrong((id *)(v3 + 40), obj);
  uint64_t v5 = *(void *)(a1[5] + 8);
  uint64_t v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;
}

BOOL sub_1001D7B80(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    while (1)
    {
      if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
      }
      char v4 = 0;
      unsigned int v5 = 0;
      unint64_t v6 = 0;
      while (1)
      {
        unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v7 == -1 || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
          break;
        }
        char v8 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
        *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
        v6 |= (unint64_t)(v8 & 0x7F) << v4;
        if ((v8 & 0x80) == 0) {
          goto LABEL_11;
        }
        v4 += 7;
        if (v5++ >= 9)
        {
          unint64_t v6 = 0;
          int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
          goto LABEL_13;
        }
      }
      *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
      int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
      if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        unint64_t v6 = 0;
      }
LABEL_13:
      if (v10 || (v6 & 7) == 4) {
        return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
      }
      switch((v6 >> 3))
      {
        case 'f':
          uint64_t v12 = PBReaderReadString();
          uint64_t v13 = 32;
          goto LABEL_24;
        case 'g':
          uint64_t v12 = PBReaderReadString();
          uint64_t v13 = 8;
          goto LABEL_24;
        case 'h':
          uint64_t v12 = PBReaderReadString();
          uint64_t v13 = 16;
          goto LABEL_24;
        case 'i':
          uint64_t v12 = PBReaderReadString();
          uint64_t v13 = 24;
LABEL_24:
          uint64_t v14 = *(void **)(a1 + v13);
          *(void *)(a1 + v13) = v12;

          goto LABEL_25;
        default:
          if ((PBReaderSkipValueWithTag() & 1) == 0) {
            return 0;
          }
LABEL_25:
          if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
          }
          break;
      }
    }
  }
  return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

xpc_object_t sub_1001D7F5C(xpc_object_t message, CFTypeRef *a2)
{
  if (qword_10035D2F0 != -1) {
    dispatch_once(&qword_10035D2F0, &stru_1003071A0);
  }
  char v4 = 0;
  unsigned int v5 = (_xpc_connection_s *)qword_10035D2F8;
  char v6 = 1;
  int v7 = -3;
  do
  {
    if ((v6 & 1) == 0) {
      xpc_release(v4);
    }
    xpc_object_t v8 = xpc_connection_send_message_with_reply_sync(v5, message);
    char v6 = 0;
    BOOL v9 = v8 != &_xpc_error_connection_interrupted || v7++ == 0;
    char v4 = &_xpc_error_connection_interrupted;
  }
  while (!v9);
  if (xpc_get_type(v8) == (xpc_type_t)&_xpc_type_error)
  {
    if (v8 == &_xpc_error_connection_invalid || v8 == &_xpc_error_connection_interrupted) {
      CFIndex v11 = 3;
    }
    else {
      CFIndex v11 = 4;
    }
    uint64_t v12 = xpc_copy_description(v5);
    string = xpc_dictionary_get_string(v8, _xpc_error_key_description);
    sub_1000297A0(v11, @"com.apple.security.swcagent", 0, a2, v14, @"%s: %s", v12, string);
    free(v12);
    xpc_release(v8);
    return 0;
  }
  return v8;
}

void sub_1001D8098(id a1)
{
  mach_service = xpc_connection_create_mach_service("com.apple.security.swcagent", 0, 0);
  xpc_connection_set_event_handler(mach_service, &stru_1003071E0);
  xpc_connection_resume(mach_service);
  qword_10035D2F8 = (uint64_t)mach_service;
}

void sub_1001D80E8(id a1, void *a2)
{
  string = xpc_dictionary_get_string(a2, _xpc_error_key_description);
  uint64_t v3 = sub_10000B070("xpc");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136315138;
    unsigned int v5 = string;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "got event: %s", (uint8_t *)&v4, 0xCu);
  }
}

xpc_object_t sub_1001D81A0(unsigned int a1, CFTypeRef *a2)
{
  xpc_object_t v4 = xpc_dictionary_create(0, 0, 0);
  xpc_object_t v6 = v4;
  if (v4) {
    xpc_dictionary_set_uint64(v4, "operation", a1);
  }
  else {
    sub_1000297A0(3, @"com.apple.security.swcagent", 0, a2, v5, @"xpc_dictionary_create returned NULL");
  }
  return v6;
}

uint64_t sub_1001D8220(void *a1, __CFString **a2)
{
  int valuePtr = -1;
  xpc_object_t value = xpc_dictionary_get_value(a1, "error");
  uint64_t v5 = value;
  if (a2 && value)
  {
    size_t length = 0;
    if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary)
    {
      sub_1000297A0(1, @"com.apple.security.xpc", 0, (CFTypeRef *)&length, v6, @"Remote error not dictionary!: %@", v5);
      size_t v7 = length;
LABEL_21:
      *a2 = (__CFString *)v7;
      return valuePtr;
    }
    string = xpc_dictionary_get_string(v5, "domain");
    if (string)
    {
      CFStringRef v13 = CFStringCreateWithCString(kCFAllocatorDefault, string, 0x8000100u);
    }
    else
    {
      CFStringRef v13 = @"com.apple.security.xpc";
      CFRetain(@"com.apple.security.xpc");
    }
    int64_t int64 = xpc_dictionary_get_int64(v5, "code");
    size_t v21 = 0;
    CFTypeRef cf = 0;
    data = xpc_dictionary_get_data(v5, "userinfo", &v21);
    if (data)
    {
      size_t v16 = (size_t)data + v21;
      uint64_t v17 = sub_10000F124((int)kCFAllocatorDefault, (int)&cf, 0, (uint64_t)data, (uint64_t)data + v21);
      CFTypeRef v18 = cf;
      if (v17 == v16)
      {
        size_t v7 = (size_t)CFErrorCreate(0, v13, int64, (CFDictionaryRef)cf);
        if (v18) {
          CFRelease(v18);
        }
        goto LABEL_19;
      }
      if (cf) {
        CFRelease(cf);
      }
    }
    size_t v7 = (size_t)CFErrorCreate(0, v13, int64, 0);
LABEL_19:
    if (v13) {
      CFRelease(v13);
    }
    goto LABEL_21;
  }
  if (!value)
  {
    size_t length = 0;
    if (xpc_dictionary_get_data(a1, "status", &length))
    {
      CFTypeRef v8 = sub_10000B2D4(a1, "status", a2);
      if (v8)
      {
        BOOL v9 = v8;
        CFTypeID v10 = CFGetTypeID(v8);
        if (v10 == CFBooleanGetTypeID())
        {
          int v11 = CFEqual(v9, kCFBooleanTrue) != 0;
        }
        else
        {
          if (v10 != CFNumberGetTypeID() || CFNumberGetValue((CFNumberRef)v9, kCFNumberSInt32Type, &valuePtr)) {
            goto LABEL_27;
          }
          int v11 = -1;
        }
        int valuePtr = v11;
LABEL_27:
        CFRelease(v9);
      }
    }
  }
  return valuePtr;
}

BOOL sub_1001D8470(unsigned int a1, const void *a2, const __CFDictionary *a3, CFTypeRef *a4, uint64_t a5)
{
  xpc_object_t v9 = sub_1001D81A0(a1, a4);
  if (!v9) {
    return 0;
  }
  CFTypeID v10 = v9;
  xpc_dictionary_set_data(v9, "client", a2, 0x20uLL);
  BOOL v11 = 0;
  if (sub_10000B890(v10, "query", (const __CFString *)a3, 0, (__CFString **)a4))
  {
    xpc_object_t v12 = sub_1001D7F5C(v10, a4);
    if (v12)
    {
      CFStringRef v13 = v12;
      uint64_t v14 = sub_1001D8220(v12, (__CFString **)a4);
      BOOL v11 = v14 == 1;
      if (a5 && !v14)
      {
        CFArrayRef Value = CFDictionaryGetValue(a3, @"srvr");
        (*(void (**)(uint64_t, const void *))(a5 + 16))(a5, Value);
      }
      xpc_release(v13);
    }
    else
    {
      BOOL v11 = 0;
    }
  }
  xpc_release(v10);
  return v11;
}

void sub_1001D8820(_Unwind_Exception *a1)
{
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v3 - 64));
  _Unwind_Resume(a1);
}

void sub_1001D8850(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = sub_10000B070("octagon-ckks");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = [WeakRetained error];
    xpc_object_t v4 = (void *)v3;
    CFStringRef v5 = @"no error";
    if (v3) {
      CFStringRef v5 = (const __CFString *)v3;
    }
    int v6 = 138412290;
    CFStringRef v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Finishing a ckks-local-reset operation with %@", (uint8_t *)&v6, 0xCu);
  }
}

void sub_1001D8934(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  CFStringRef v5 = sub_10000B070("octagon-ckks");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = [WeakRetained error];
    CFStringRef v7 = (void *)v6;
    CFStringRef v8 = @"no error";
    if (v6) {
      CFStringRef v8 = (const __CFString *)v6;
    }
    int v11 = 138412290;
    CFStringRef v12 = v8;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Finished ckks-local-reset with %@", (uint8_t *)&v11, 0xCu);
  }
  if (v3)
  {
    [WeakRetained setError:v3];
  }
  else
  {
    xpc_object_t v9 = [WeakRetained intendedState];
    [WeakRetained setNextState:v9];
  }
  CFTypeID v10 = [WeakRetained finishedOp];
  [WeakRetained runBeforeGroupFinished:v10];
}

void sub_1001D9B84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id location)
{
  objc_destroyWeak(v23);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1001D9BB0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  CFStringRef v5 = +[CKKSAnalytics logger];
  [v5 logResultForEvent:@"OctagonEventReset" hardFailure:1 result:v3];

  uint64_t v6 = sub_10000B070("octagon");
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (!v3)
  {
    if (v7)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Successfully reset Octagon", buf, 2u);
    }

    CFTypeID v10 = [WeakRetained deps];
    int v11 = [v10 stateHolder];
    id v20 = 0;
    [v11 persistAccountChanges:&stru_100307230 error:&v20];
    id v12 = v20;

    CFStringRef v13 = sub_10000B070("octagon");
    BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
    if (v12)
    {
      if (v14)
      {
        *(_DWORD *)long long buf = 138412290;
        id v22 = v12;
        id v15 = "Error resetting local account metadata state: %@";
        size_t v16 = v13;
        uint32_t v17 = 12;
LABEL_12:
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v15, buf, v17);
      }
    }
    else if (v14)
    {
      *(_WORD *)long long buf = 0;
      id v15 = "Successfully reset local account metadata state";
      size_t v16 = v13;
      uint32_t v17 = 2;
      goto LABEL_12;
    }

    CFTypeRef v18 = [WeakRetained intendedState];
    [WeakRetained setNextState:v18];

    goto LABEL_14;
  }
  if (v7)
  {
    CFStringRef v8 = [WeakRetained containerName];
    xpc_object_t v9 = [WeakRetained contextID];
    *(_DWORD *)long long buf = 138412802;
    id v22 = v8;
    __int16 v23 = 2112;
    id v24 = v9;
    __int16 v25 = 2112;
    id v26 = v3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Unable to reset for (%@,%@): %@", buf, 0x20u);
  }
  [WeakRetained setError:v3];
LABEL_14:
  uint64_t v19 = [WeakRetained finishedOp];
  [WeakRetained runBeforeGroupFinished:v19];
}

OTAccountMetadataClassC *__cdecl sub_1001D9E44(id a1, OTAccountMetadataClassC *a2)
{
  uint64_t v2 = a2;
  [(OTAccountMetadataClassC *)v2 setTrustState:0];
  [(OTAccountMetadataClassC *)v2 setPeerID:0];
  [(OTAccountMetadataClassC *)v2 setSyncingPolicy:0];
  [(OTAccountMetadataClassC *)v2 setVoucher:0];
  [(OTAccountMetadataClassC *)v2 setVoucherSignature:0];
  [(OTAccountMetadataClassC *)v2 setTlkSharesForVouchedIdentitys:0];
  [(OTAccountMetadataClassC *)v2 setIsInheritedAccount:0];
  [(OTAccountMetadataClassC *)v2 setWarmedEscrowCache:0];
  [(OTAccountMetadataClassC *)v2 setWarnedTooManyPeers:0];

  return v2;
}

void -[SOSAccount setWaitForInitialSync_blocks:](SOSAccount *self, SEL a2, id a3)
{
}

NSMutableDictionary *__cdecl -[SOSAccount waitForInitialSync_blocks](SOSAccount *self, SEL a2)
{
  return self->_waitForInitialSync_blocks;
}

void -[SOSAccount setChange_blocks:](SOSAccount *self, SEL a2, id a3)
{
}

NSMutableArray *__cdecl -[SOSAccount change_blocks](SOSAccount *self, SEL a2)
{
  return self->_change_blocks;
}

void sub_1001DA7EC(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 24));
  _Unwind_Resume(a1);
}

void sub_1001DA808(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v24 = 0;
  __int16 v25 = &v24;
  uint64_t v26 = 0x2020000000;
  char v27 = 0;
  uint64_t v20 = 0;
  size_t v21 = &v20;
  uint64_t v22 = 0x2020000000;
  uint64_t v23 = 0;
  v18[0] = 0;
  v18[1] = v18;
  v18[2] = 0x2020000000;
  char v19 = 0;
  CFStringRef v5 = [WeakRetained accountConfiguration];
  uint64_t v6 = [v5 storage];

  [v6 setRingUpdateFlag:0];
  BOOL v7 = [WeakRetained accountConfiguration];
  [v7 setStorage:v6];

  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472;
  v17[2] = sub_1001DAB44;
  void v17[3] = &unk_100307818;
  void v17[4] = WeakRetained;
  v17[5] = &v24;
  v17[6] = v18;
  v17[7] = &v20;
  [WeakRetained performTransaction:v17];
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472;
  v16[2] = sub_1001DADB4;
  v16[3] = &unk_100309B28;
  void v16[4] = WeakRetained;
  [WeakRetained performTransaction:v16];
  CFStringRef v8 = v21;
  if (*((unsigned char *)v25 + 24))
  {
    CFSetRef v9 = (const __CFSet *)v21[3];
    if (v9)
    {
      CFIndex Count = CFSetGetCount(v9);
      CFStringRef v8 = v21;
      if (Count)
      {
        CFSetRef v11 = (const __CFSet *)v21[3];
        context[0] = _NSConcreteStackBlock;
        context[1] = 3221225472;
        context[2] = sub_1001DADC0;
        context[3] = &unk_100307868;
        context[4] = WeakRetained;
        context[5] = v18;
        CFSetApplyFunction(v11, (CFSetApplierFunction)sub_1001DB1A8, context);
        CFStringRef v8 = v21;
      }
    }
  }
  id v12 = (const void *)v8[3];
  if (v12)
  {
    v8[3] = 0;
    CFRelease(v12);
  }
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_1001DAE70;
  v14[3] = &unk_100309B28;
  void v14[4] = WeakRetained;
  [WeakRetained performTransaction:v14];
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_1001DAE7C;
  v13[3] = &unk_100309B28;
  void v13[4] = WeakRetained;
  [WeakRetained performTransaction:v13];
  if ([WeakRetained forceSyncForRecoveryRing])
  {
    [WeakRetained performTransaction:&stru_100307888];
    [WeakRetained setForceSyncForRecoveryRing:0];
  }
  [v3 setNextState:@"ready"];

  _Block_object_dispose(v18, 8);
  _Block_object_dispose(&v20, 8);
  _Block_object_dispose(&v24, 8);
}

void sub_1001DAB10(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Block_object_dispose((const void *)(v1 - 128), 8);
  _Block_object_dispose((const void *)(v1 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_1001DAB44(uint64_t a1)
{
  if (![*(id *)(a1 + 32) accountKeyIsTrusted]
    || ![*(id *)(a1 + 32) isInCircle:0])
  {
    return;
  }
  [*(id *)(a1 + 32) _onQueueRecordRetiredPeersInCircle];
  sub_100202FC4(*(void **)(a1 + 32));
  cf[1] = 0;
  id v2 = *(id *)(a1 + 32);
  if (![v2 isInCircle:0]
    || (objc_msgSend(v2, "backup_key"), (uint64_t v3 = objc_claimAutoreleasedReturnValue()) == 0))
  {
    LOBYTE(v6) = 0;
    goto LABEL_10;
  }
  xpc_object_t v4 = (void *)v3;
  CFStringRef v5 = [v2 backup_key];
  int v6 = SOSBSKBIsGoodBackupPublic();

  if (!v6) {
    goto LABEL_10;
  }
  [v2 peerInfo];
  BOOL v7 = (const void *)SOSPeerInfoCopyBackupKey();
  CFStringRef v8 = [v2 backup_key];
  CFSetRef v9 = v8;
  if (v7 && v8)
  {
    LOBYTE(v6) = CFEqual(v7, v8) != 0;
  }
  else
  {
    LOBYTE(v6) = v7 == v8;

    if (!v7) {
      goto LABEL_10;
    }
  }
  CFRelease(v7);
LABEL_10:

  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v6;
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
  {
    cf[0] = 0;
    CFDictionaryRef v18 = sub_1001E9524(v10, v11, v12, v13, v14, v15, v16, v17);
    uint64_t v19 = SecItemDelete(v18);
    if (v18) {
      CFRelease(v18);
    }
    if (v19 == -25300) {
      int v20 = 0;
    }
    else {
      int v20 = v19;
    }
    if (sub_100012A40(v20, (__CFString **)cf, @"Deleting V0 Keybag failed - %d", v19))
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
    }
    else
    {
      size_t v21 = sub_10000B070("SecError");
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        CFTypeRef v26 = cf[0];
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Failed to delete v0 keybag: %@", buf, 0xCu);
      }
    }
    CFTypeRef v22 = cf[0];
    if (cf[0])
    {
      cf[0] = 0;
      CFRelease(v22);
    }
    if ([*(id *)(a1 + 32) peerInfo])
    {
      [*(id *)(a1 + 32) peerInfo];
      CFSetRef PermittedViews = (const __CFSet *)SOSPeerInfoGetPermittedViews();
      *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = CFSetCreateMutableCopy(kCFAllocatorDefault, 0, PermittedViews);
    }
  }
}

id sub_1001DADB4(uint64_t a1)
{
  return [*(id *)(a1 + 32) setConsolidateKeyInterest:1];
}

id sub_1001DADC0(uint64_t a1, CFTypeRef cf)
{
  if (!cf || (v3 = cf, CFTypeID v4 = CFGetTypeID(cf), v4 != CFStringGetTypeID())) {
    CFTypeRef v3 = 0;
  }
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_1001DB1C0;
  v6[3] = &unk_100307840;
  void v6[6] = v3;
  return [*(id *)(a1 + 32) performTransaction:v6];
}

id sub_1001DAE70(uint64_t a1)
{
  return [*(id *)(a1 + 32) setConsolidateKeyInterest:0];
}

void sub_1001DAE7C(uint64_t a1, void *a2)
{
  id v3 = a2;
  CFTypeRef cf = 0;
  CFTypeID v4 = sub_10000B070("rings");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Flushing Rings to KVS", buf, 2u);
  }

  CFStringRef v5 = [*(id *)(a1 + 32) circle_transport];
  unsigned __int8 v6 = [v5 flushChanges:&cf];

  if ((v6 & 1) == 0)
  {
    int v13 = sub_10000B070("circleOps");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      CFTypeRef v17 = cf;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "flush circles/rings failed %@", buf, 0xCu);
    }
    goto LABEL_10;
  }
  BOOL v7 = [v3 account];
  [v7 setNeed_backup_peers_created_after_backup_key_set:1];

  CFStringRef v8 = [v3 account];
  int v9 = [v8 getPublicKeyStatusForKey:2 error:0];

  if (v9 >= 1)
  {
    uint64_t v10 = [v3 account];
    [v10 setPublicKeyStatus:3 forKey:2];
  }
  int v11 = [v3 account];
  int v12 = [v11 getPublicKeyStatusForKey:1 error:0];

  if (v12 >= 1)
  {
    int v13 = [v3 account];
    [v13 setPublicKeyStatus:3 forKey:1];
LABEL_10:
  }
  CFTypeRef v14 = cf;
  if (cf)
  {
    CFTypeRef cf = 0;
    CFRelease(v14);
  }
  sub_1001F55B8(*(void **)(a1 + 32));
}

void sub_1001DB080(id a1, SOSAccountTransaction *a2)
{
  uint64_t v5 = 0;
  CFMutableSetRef v2 = sub_1001ED2C8(a2, (uint64_t)&v5);
  if (v5)
  {
    id v3 = sub_10000B070("SecError");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "sos-register-recovery-public-key: Couldn't process sync with backup peers: %@", buf, 0xCu);
    }
  }
  else
  {
    CFTypeID v4 = sub_10000B070("sos-register-recovery-public-key");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "telling CloudServices about recovery key change", buf, 2u);
    }

    notify_post("com.apple.security.itembackup");
  }
}

uint64_t sub_1001DB1A8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

id sub_1001DB1C0(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) _onQueueEnsureInBackupRings:*(void *)(a1 + 48)];
  if (result) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
  }
  return result;
}

void sub_1001DB2E4(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 24));
  _Unwind_Resume(a1);
}

void sub_1001DB300(uint64_t a1, void *a2)
{
  uint64_t v2 = (id *)(a1 + 32);
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained(v2);
  uint64_t v5 = [WeakRetained accountConfiguration];
  unsigned __int8 v6 = [v5 storage];

  uint64_t v7 = sub_10000B070("sos-sm");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v8 = [v6 pendingBackupPeers];
    LODWORD(v13) = 138412290;
    *(void *)((char *)&v13 + 4) = v8;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "performing backup for %@", (uint8_t *)&v13, 0xCu);
  }
  int v9 = [v6 pendingBackupPeers];
  id v10 = [v9 count];

  if (v10)
  {
    int v11 = [v6 pendingBackupPeers];
    *(void *)&long long v13 = _NSConcreteStackBlock;
    *((void *)&v13 + 1) = 3221225472;
    CFTypeRef v14 = sub_10022802C;
    int v15 = &unk_1003093A8;
    int v16 = v11;
    _os_activity_initiate((void *)&_mh_execute_header, "CloudCircle SOSCCRequestSyncWithBackupPeerList", OS_ACTIVITY_FLAG_DEFAULT, &v13);

    [v6 clearPendingBackupPeers];
  }
  int v12 = [WeakRetained accountConfiguration];
  [v12 setStorage:v6];

  [v3 setNextState:@"ready"];
}

void sub_1001DB5A0(_Unwind_Exception *a1)
{
  objc_destroyWeak((id *)(v1 - 24));
  _Unwind_Resume(a1);
}

void sub_1001DB5B4(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = [WeakRetained accountConfiguration];
  id v3 = [v2 storage];

  [v3 setRingUpdateFlag:1];
  CFTypeID v4 = [WeakRetained accountConfiguration];
  [v4 setStorage:v3];

  uint64_t v5 = [WeakRetained performRingUpdates];
  [v5 trigger];

  unsigned __int8 v6 = sub_10000B070("sos-sm");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = [WeakRetained performRingUpdates];
    CFStringRef v8 = [v7 nextFireTime];
    int v9 = 138412290;
    id v10 = v8;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "trigger ring update at %@", (uint8_t *)&v9, 0xCu);
  }
}

void sub_1001DBA4C(_Unwind_Exception *a1)
{
  objc_destroyWeak((id *)(v1 - 40));
  _Unwind_Resume(a1);
}

void sub_1001DBA60(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v3 = [WeakRetained accountConfiguration];
  CFTypeID v4 = [v3 storage];

  uint64_t v5 = [v4 pendingBackupPeers];

  if (v5)
  {
    unsigned __int8 v6 = *(void **)(a1 + 32);
    uint64_t v7 = [v4 pendingBackupPeers];
    [v6 addObjectsFromArray:v7];
  }
  CFStringRef v8 = [*(id *)(a1 + 32) allObjects];
  id v9 = [v8 mutableCopy];
  [v4 setPendingBackupPeers:v9];

  id v10 = [WeakRetained accountConfiguration];
  [v10 setStorage:v4];

  int v11 = [WeakRetained performBackups];
  [v11 trigger];

  int v12 = sub_10000B070("sos-sm");
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = *(void *)(a1 + 40);
    CFTypeRef v14 = [WeakRetained performBackups];
    int v15 = [v14 nextFireTime];
    int v16 = 138412546;
    uint64_t v17 = v13;
    __int16 v18 = 2112;
    uint64_t v19 = v15;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "trigger backup for peers: %@ at %@", (uint8_t *)&v16, 0x16u);
  }
}

void sub_1001DC0F4(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 72));
  _Unwind_Resume(a1);
}

void sub_1001DC130(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained addBackupFlag];
}

void sub_1001DC170(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained addRingUpdateFlag];
}

void sub_1001DC1B0(id a1)
{
  v4[0] = @"trigger_backup";
  v4[1] = @"trigger_ring_update";
  uint64_t v1 = +[NSArray arrayWithObjects:v4 count:2];
  uint64_t v2 = +[NSSet setWithArray:v1];
  id v3 = (void *)qword_10035D320;
  qword_10035D320 = v2;
}

void sub_1001DC25C(id a1)
{
  v3[0] = @"ready";
  v3[1] = @"error";
  v4[0] = &off_100326860;
  v4[1] = &off_100326878;
  v3[2] = @"perform_backup";
  v3[3] = @"perform_ring_update";
  void v4[2] = &off_100326890;
  void v4[3] = &off_1003268A8;
  uint64_t v1 = +[NSDictionary dictionaryWithObjects:v4 forKeys:v3 count:4];
  uint64_t v2 = (void *)qword_10035D310;
  qword_10035D310 = v1;
}

void sub_1001DC444(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001DC45C(uint64_t a1, uint64_t a2)
{
  uint64_t v9 = 0;
  id v10 = &v9;
  uint64_t v11 = 0x2020000000;
  char v12 = 0;
  CFSetRef v4 = [*(id *)(a1 + 32) retirees];
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1001DC554;
  v8[3] = &unk_100307630;
  uint64_t v5 = *(void *)(a1 + 48);
  void v8[4] = *(void *)(a1 + 40);
  void v8[5] = &v9;
  void v8[6] = v5;
  void v8[7] = a2;
  CFSetApplyFunction(v4, (CFSetApplierFunction)sub_1001DB1A8, v8);

  uint64_t v6 = *((unsigned __int8 *)v10 + 24);
  _Block_object_dispose(&v9, 8);
  return v6;
}

void sub_1001DC53C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1001DC554(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == SOSPeerInfoGetTypeID())
    {
      if (SOSCircleUpdatePeerInfo())
      {
        *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
        uint64_t v5 = sub_10000B070("retirement");
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v6 = *(const void **)(a1 + 56);
          *(_DWORD *)long long buf = 138412546;
          CFTypeRef v14 = cf;
          __int16 v15 = 2112;
          CFTypeRef v16 = v6;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Updated retired peer %@ in %@", buf, 0x16u);
        }

        CFTypeRef cfa = 0;
        uint64_t v7 = [*(id *)(a1 + 32) trust];
        CFStringRef v8 = [*(id *)(a1 + 32) kvs_message_transport];
        uint64_t v9 = [*(id *)(a1 + 32) circle_transport];
        unsigned __int8 v10 = [v7 cleanupAfterPeer:v8 circleTransport:v9 seconds:86400 circle:*(void *)(a1 + 56) cleanupPeer:cf err:&cfa];

        if ((v10 & 1) == 0)
        {
          uint64_t v11 = sub_10000B070("SecError");
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138412546;
            CFTypeRef v14 = cf;
            __int16 v15 = 2112;
            CFTypeRef v16 = cfa;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Error cleanup up after peer (%@): %@", buf, 0x16u);
          }
        }
        if (cfa) {
          CFRelease(cfa);
        }
        *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
      }
    }
  }
}

id sub_1001DCC24(void *a1, uint64_t a2)
{
  id v3 = [a1 trust];
  CFTypeID v4 = [v3 expansion];

  if (v4)
  {
    uint64_t v5 = [v3 expansion];
    id v6 = [v5 objectForKey:a2];
  }
  else
  {
    id v6 = 0;
  }

  return v6;
}

void *sub_1001DCFE0(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  CFTypeID v4 = sub_1001E9E58(*(void **)(a1 + 32), *(const void **)(a1 + 40), a3);
  uint64_t v5 = sub_10000B070("backup");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = "success";
    uint64_t v7 = *(void *)(a1 + 40);
    if (!v4) {
      id v6 = "failed";
    }
    int v9 = 138412546;
    uint64_t v10 = v7;
    __int16 v11 = 2080;
    char v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Reset backup ring %@ %s", (uint8_t *)&v9, 0x16u);
  }

  return v4;
}

void sub_1001DD8FC(uint64_t a1, void *a2)
{
  id v3 = [a2 account];
  CFTypeRef cf = 0;
  CFArrayRef v4 = sub_1001F112C(v3, (uint64_t)&cf, &stru_100307D20);
  CFArrayRef v5 = v4;
  CFTypeRef v6 = cf;
  if (cf) {
    CFTypeRef cf = 0;
  }
  if (v4)
  {
    if (CFArrayGetCount(v4))
    {
      sub_1001E6414(v3, v5, (uint64_t)&cf);
      CFTypeRef v7 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        if (!v6 || (CFRelease(v6), (CFTypeRef v8 = cf) == 0))
        {
          CFTypeRef v6 = v7;
          goto LABEL_14;
        }
        CFTypeRef cf = 0;
        CFTypeRef v6 = v7;
        goto LABEL_12;
      }
    }
    else
    {
      CFTypeRef v8 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
LABEL_12:
        CFRelease(v8);
      }
    }
LABEL_14:
    CFRelease(v5);
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  if (v6) {
    CFRelease(v6);
  }
}

void sub_1001DDFBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1001DDFEC(uint64_t a1)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_1001DE080;
  v3[3] = &unk_100307500;
  uint64_t v2 = *(void **)(a1 + 32);
  id v4 = *(id *)(a1 + 40);
  long long v5 = *(_OWORD *)(a1 + 48);
  [v2 performTransaction:v3];
}

void sub_1001DE080(uint64_t a1, void *a2)
{
  id v7 = a2;
  if ([*(id *)(a1 + 32) count])
  {
    CFSetRef v3 = +[NSSet setWithArray:*(void *)(a1 + 32)];
    CFSetRef v4 = sub_1001ECEF0(v7, v3, *(void *)(*(void *)(a1 + 40) + 8) + 24);
    if (v4)
    {
      CFSetRef v5 = v4;
      id Count = (id)CFSetGetCount(v4);
      if (Count == [(__CFSet *)v3 count]) {
        *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
      }
      CFRelease(v5);
    }
  }
  else
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = sub_1001ED3A0(v7, *(void *)(*(void *)(a1 + 40)+ 8)+ 24);
  }
}

void sub_1001DE7E0()
{
  uint64_t v4 = 0;
  CFSetRef v5 = &v4;
  uint64_t v6 = 0x2020000000;
  v0 = (void (*)(void))off_10035D300;
  id v7 = off_10035D300;
  if (!off_10035D300)
  {
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_1001DE918;
    v3[3] = &unk_100308068;
    void v3[4] = &v4;
    sub_1001DE918(v3);
    v0 = (void (*)(void))v5[3];
  }
  _Block_object_dispose(&v4, 8);
  if (v0)
  {
    v0();
  }
  else
  {
    uint64_t v1 = +[NSAssertionHandler currentHandler];
    uint64_t v2 = +[NSString stringWithUTF8String:"BOOL soft_MetricsOverrideTestsAreEnabled(void)"];
    [v1 handleFailureInFunction:v2 file:@"SOSAccount.m" lineNumber:94 description:@"%s", dlerror()];

    __break(1u);
  }
}

void sub_1001DE900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *sub_1001DE918(void *a1)
{
  v5[0] = 0;
  if (!qword_10035D308)
  {
    v5[1] = _NSConcreteStackBlock;
    v5[2] = (void *)3221225472;
    void v5[3] = sub_1001DEA9C;
    void v5[4] = &unk_1003093A8;
    void v5[5] = v5;
    long long v6 = off_1003078A8;
    uint64_t v7 = 0;
    qword_10035D308 = _sl_dlopen();
  }
  uint64_t v2 = (void *)qword_10035D308;
  if (!qword_10035D308)
  {
    a1 = +[NSAssertionHandler currentHandler];
    uint64_t v2 = +[NSString stringWithUTF8String:"void *KeychainCircleLibrary(void)"];
    [a1 handleFailureInFunction:v2 file:@"SOSAccount.m" lineNumber:91 description:@"%s" v5[0]];

    __break(1u);
    goto LABEL_7;
  }
  CFSetRef v3 = v5[0];
  if (v5[0]) {
LABEL_7:
  }
    free(v3);
  id result = dlsym(v2, "MetricsOverrideTestsAreEnabled");
  *(void *)(*(void *)(a1[4] + 8) + 24) = result;
  off_10035D300 = *(_UNKNOWN **)(*(void *)(a1[4] + 8) + 24);
  return result;
}

uint64_t sub_1001DEA9C()
{
  uint64_t result = _sl_dlopen();
  qword_10035D308 = result;
  return result;
}

void sub_1001DEF1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

void sub_1001DEF54(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc((Class)AAFAnalyticsEventSecurity);
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 40);
  uint64_t v7 = *(void *)(a1 + 48);
  uint64_t v8 = kSecurityRTCEventNameInitiatorJoinsSOS;
  sub_1001DE7E0();
  LOBYTE(v11) = *(unsigned char *)(a1 + 84);
  id v12 = [v4 initWithKeychainCircleMetrics:0 altDSID:v5 flowID:v6 deviceSessionID:v7 eventName:v8 testsAreEnabled:v9 canSendMetrics:v11 category:kSecurityRTCEventCategoryAccountDataAccessRecovery];
  uint64_t v10 = [v3 account];

  *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = sub_1001DF080(v10, *(const void **)(a1 + 56), *(_DWORD *)(a1 + 80), (void *)(*(void *)(*(void *)(a1 + 72) + 8)+ 24));
  +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v12 success:*(void *)(a1 + 56) != 0 error:*(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24)];
}

id sub_1001DF080(void *a1, const void *a2, int a3, void *a4)
{
  id v7 = a1;
  uint64_t v8 = [v7 trust];
  CFTypeRef v34 = 0;
  CFTypeRef cf = 0;
  CFTypeRef v33 = 0;
  char v32 = 0;
  uint64_t v9 = sub_10000B070("circleOps");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Joining circles through piggyback (SOSAccountCopyCircleJoiningBlob)", buf, 2u);
  }

  if (!a2 || (CFTypeID v10 = CFGetTypeID(a2), v10 != CFDataGetTypeID()))
  {
    uint64_t v14 = sub_10000B070("circleOps");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      __int16 v15 = "Bad data blob: piggyback (SOSAccountCopyCircleJoiningBlob)";
      CFTypeRef v16 = v14;
      uint32_t v17 = 2;
LABEL_15:
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v15, buf, v17);
      goto LABEL_16;
    }
    goto LABEL_16;
  }
  id v11 = sub_1001EE508(v7);
  if (!v11)
  {
    uint64_t v14 = sub_10000B070("circleOps");
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_17;
    }
    uint64_t v18 = *a4;
    *(_DWORD *)long long buf = 138412290;
    uint64_t v37 = v18;
    __int16 v15 = "Failed - no private credential %@: piggyback (SOSAccountCopyCircleJoiningBlob)";
    goto LABEL_14;
  }
  if ((SOSPiggyBackBlobCreateFromData() & 1) == 0)
  {
    uint64_t v14 = sub_10000B070("circleOps");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = *a4;
      *(_DWORD *)long long buf = 138412290;
      uint64_t v37 = v19;
      __int16 v15 = "Failed - decoding blob %@: piggyback (SOSAccountCopyCircleJoiningBlob)";
LABEL_14:
      CFTypeRef v16 = v14;
      uint32_t v17 = 12;
      goto LABEL_15;
    }
LABEL_16:
    id v11 = 0;
    goto LABEL_17;
  }
  id v12 = sub_10000B070("circleOps");
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "clearing flag in account for piggyback v0", buf, 2u);
  }

  sub_1001FF378(v7, @"initialsynctimeout", 0);
  sub_1001F6D70(v7);
  sub_1001DF450(@"Joining", v7, (uint64_t)cf, (uint64_t)v33, (uint64_t)v34, a3);
  size_t v21 = [v7 circle_transport];
  v25[0] = _NSConcreteStackBlock;
  v25[1] = 3221225472;
  v25[2] = sub_1001DF64C;
  v25[3] = &unk_1003076E8;
  id v27 = v11;
  CFTypeRef v28 = cf;
  CFTypeRef v29 = v33;
  CFTypeRef v30 = v34;
  CFTypeRef v26 = v8;
  uint64_t v31 = a4;
  id v11 = [v26 modifyCircle:v21 err:a4 action:v25];

  CFTypeRef v22 = cf;
  if (cf)
  {
    CFTypeRef cf = 0;
    CFRelease(v22);
  }
  CFTypeRef v23 = v33;
  if (v33)
  {
    CFTypeRef v33 = 0;
    CFRelease(v23);
  }
  CFTypeRef v24 = v34;
  if (v34)
  {
    CFTypeRef v34 = 0;
    CFRelease(v24);
  }
  uint64_t v14 = v26;
LABEL_17:

  return v11;
}

void sub_1001DF450(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  id v8 = a2;
  CFDictionaryRef Copy = (const void *)SOSCopyIDOfKey();
  if (!Copy) {
    CFDictionaryRef Copy = CFStringCreateCopy(kCFAllocatorDefault, @"Unknown");
  }
  CFTypeID v10 = (const void *)SOSCopyIDOfDataBuffer();
  if (!v10) {
    CFTypeID v10 = CFStringCreateCopy(kCFAllocatorDefault, @"No Signature");
  }
  CFStringRef v11 = (const __CFString *)sub_1001DCC24(v8, @"AccountName");
  id v12 = [v8 trust];

  [v12 trustedCircle];
  uint64_t v13 = (const void *)SOSCircleCopyHashString();

  uint64_t v14 = (const void *)SOSGenerationCountCopyDescription();
  __int16 v15 = sub_10000B070("circleOps");
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v16 = @"Unavailable";
    int v17 = 138413826;
    if (v11) {
      CFStringRef v16 = v11;
    }
    uint64_t v18 = a1;
    __int16 v19 = 2112;
    CFStringRef v20 = v16;
    __int16 v21 = 1024;
    int v22 = a6;
    __int16 v23 = 2112;
    CFTypeRef v24 = v14;
    __int16 v25 = 2112;
    CFTypeRef v26 = Copy;
    __int16 v27 = 2112;
    CFTypeRef v28 = v10;
    __int16 v29 = 2112;
    CFTypeRef v30 = v13;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%@: Joining blob for account: %@ for piggyback (V%d) gencount: %@  pubkey: %@ signatureID: %@  starting circle hash: %@", (uint8_t *)&v17, 0x44u);
  }

  if (Copy) {
    CFRelease(Copy);
  }
  if (v10) {
    CFRelease(v10);
  }
  if (v13) {
    CFRelease(v13);
  }
  if (v14) {
    CFRelease(v14);
  }
}

uint64_t sub_1001DF64C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = *(void *)(a1 + 56);
  uint64_t v6 = *(void *)(a1 + 64);
  uint64_t v7 = *(void *)(a1 + 40);
  id v8 = [*(id *)(a1 + 32) fullPeerInfo];
  uint64_t v9 = *(void *)(a1 + 72);

  return _SOSCircleAcceptPeerFromHSA2(a2, v7, v4, v5, v6, v8, v9);
}

void sub_1001DF988(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v15 - 112), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001DF9B8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1001DF9C8(uint64_t a1)
{
}

void sub_1001DF9D0(uint64_t a1)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_1001DFA9C;
  v3[3] = &unk_100307488;
  uint64_t v7 = *(void *)(a1 + 64);
  uint64_t v2 = *(void **)(a1 + 32);
  id v4 = *(id *)(a1 + 40);
  id v5 = *(id *)(a1 + 48);
  id v6 = *(id *)(a1 + 56);
  char v9 = *(unsigned char *)(a1 + 88);
  long long v8 = *(_OWORD *)(a1 + 72);
  [v2 performTransaction:v3];
}

void sub_1001DFA9C(uint64_t a1, void *a2)
{
  id v6 = [a2 account];
  uint64_t v3 = sub_1001DFB18(v6, *(void **)(a1 + 32), *(void **)(a1 + 40), *(void **)(a1 + 48), *(unsigned char *)(a1 + 80), *(void *)(a1 + 72), (uint64_t *)(*(void *)(*(void *)(a1 + 64) + 8) + 24));
  uint64_t v4 = *(void *)(*(void *)(a1 + 56) + 8);
  id v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;
}

uint64_t sub_1001DFB18(void *a1, void *a2, void *a3, void *a4, char a5, uint64_t a6, uint64_t *a7)
{
  id v13 = a1;
  id v14 = a2;
  id v15 = a3;
  id v16 = a4;
  int v17 = sub_10000B070("circleOps");
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Making circle joining piggyback blob as sponsor (SOSAccountCopyCircleJoiningBlob)", buf, 2u);
  }

  if (![v13 getCircleStatus:a7])
  {
    if (sub_1001EEC4C(v13))
    {
      if (a6)
      {
        id v23 = objc_alloc((Class)AAFAnalyticsEventSecurity);
        uint64_t v24 = kSecurityRTCEventNameVerifySOSApplication;
        sub_1001DE7E0();
        LOBYTE(v3_Block_object_dispose(&STACK[0x290], 8) = a5;
        id v20 = [v23 initWithKeychainCircleMetrics:0 altDSID:v14 flowID:v15 deviceSessionID:v16 eventName:v24 testsAreEnabled:v25 canSendMetrics:v38 category:kSecurityRTCEventCategoryAccountDataAccessRecovery];
        if ((SOSPeerInfoApplicationVerify() & 1) == 0)
        {
          id v40 = v14;
          CFTypeRef v34 = sub_10000B070("circleOps");
          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Peer application wasn't signed with the correct userKey", buf, 2u);
          }

          __int16 v27 = 0;
          GenSignatureWithPeerAdded = 0;
          char v32 = 0;
          uint64_t v31 = 0;
          uint64_t v21 = 0;
          if (!a7) {
            goto LABEL_26;
          }
          goto LABEL_18;
        }
        +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v20 success:1 error:0];
        [v13 fullPeerInfo];
        uint64_t v26 = SOSFullPeerInfoCopyDeviceKey();
        if (v26)
        {
          __int16 v27 = (const void *)v26;
          id v40 = v14;
          CFTypeRef v28 = [v13 trust];
          id v29 = [v28 getCircle:a7];

          if (!v29 || (uint64_t v30 = SOSCircleCopyCircle()) == 0)
          {
            uint64_t v21 = 0;
            id v14 = v40;
            goto LABEL_33;
          }
          uint64_t v31 = (const void *)v30;
          if (!SOSCirclePreGenerationSign())
          {
            uint64_t v21 = 0;
            char v32 = 0;
            GenSignatureWithPeerAdded = 0;
            goto LABEL_27;
          }
          SOSCircleGetGeneration();
          char v32 = (const void *)SOSGenerationIncrementAndCreate();
          GenSignatureWithPeerAdded = (const void *)SOSCircleCopyNextGenSignatureWithPeerAdded();
          if (!GenSignatureWithPeerAdded)
          {
            uint64_t v21 = 0;
            goto LABEL_27;
          }
          sub_1001DF450(@"Accepting", v13, (uint64_t)v32, (uint64_t)v27, (uint64_t)GenSignatureWithPeerAdded, 1);
          uint64_t v21 = SOSPiggyBackBlobCopyEncodedData();
          if (!a7)
          {
LABEL_26:
            +[NSError errorWithDomain:kSOSErrorDomain code:12 description:@"Peer application wasn't signed with the correct userKey"];
            id v39 = v16;
            uint64_t v36 = v35 = v15;
            +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v20 success:0 error:v36];

            id v15 = v35;
            id v16 = v39;
            if (!v31) {
              goto LABEL_28;
            }
            goto LABEL_27;
          }
LABEL_18:
          if (*a7)
          {
            +[SecurityAnalyticsReporterRTC sendMetricWithEvent:success:error:](SecurityAnalyticsReporterRTC, "sendMetricWithEvent:success:error:", v20, 0);
            if (!v31)
            {
LABEL_28:
              if (v32) {
                CFRelease(v32);
              }
              id v14 = v40;
              if (GenSignatureWithPeerAdded) {
                CFRelease(GenSignatureWithPeerAdded);
              }
              if (!v27)
              {
LABEL_34:
                if (!a7) {
                  goto LABEL_8;
                }
LABEL_40:
                if (v21) {
                  goto LABEL_8;
                }
                uint64_t v18 = sub_10000B070("circleOps");
                if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v37 = *a7;
                  *(_DWORD *)long long buf = 138412290;
                  uint64_t v42 = v37;
                  _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Failed to make circle joining piggyback blob as sponsor %@", buf, 0xCu);
                }
                goto LABEL_7;
              }
LABEL_33:
              CFRelease(v27);
              goto LABEL_34;
            }
LABEL_27:
            CFRelease(v31);
            goto LABEL_28;
          }
          goto LABEL_26;
        }
LABEL_39:
        uint64_t v21 = 0;
        if (!a7) {
          goto LABEL_8;
        }
        goto LABEL_40;
      }
      SOSCreateError();
    }
    id v20 = 0;
    goto LABEL_39;
  }
  uint64_t v18 = sub_10000B070("circleOps");
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v19 = SOSCCGetStatusDescription();
    *(_DWORD *)long long buf = 138412290;
    uint64_t v42 = v19;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Invalid circle status: %@ to accept piggyback as sponsor (SOSAccountCopyCircleJoiningBlob)", buf, 0xCu);
  }
  id v20 = 0;
LABEL_7:

  uint64_t v21 = 0;
LABEL_8:

  return v21;
}

CFStringRef sub_1001E0490(void *a1)
{
  id v1 = a1;
  id v2 = [v1 accountKey];
  unsigned int v3 = [v1 accountKeyIsTrusted];
  id v4 = [v1 accountPrivateKey];
  int v19 = SOSVisibleKeychainNotAllowed();
  unsigned int v5 = [v1 getCircleStatus:0];
  if ([v1 accountKey])
  {
    [v1 accountKey];
    CFDictionaryRef Copy = (const void *)SOSCopyIDOfKeyWithLength();
    CFAllocatorRef v7 = kCFAllocatorDefault;
  }
  else
  {
    CFAllocatorRef v7 = kCFAllocatorDefault;
    CFDictionaryRef Copy = CFStringCreateCopy(kCFAllocatorDefault, @"*No Key*");
  }
  if (v2) {
    uint64_t v8 = 85;
  }
  else {
    uint64_t v8 = 117;
  }
  if (v3) {
    uint64_t v9 = 84;
  }
  else {
    uint64_t v9 = 116;
  }
  if (v4) {
    uint64_t v10 = 73;
  }
  else {
    uint64_t v10 = 105;
  }
  if (v5 + 1 > 4) {
    CFStringRef v11 = @"kSOSCCError";
  }
  else {
    CFStringRef v11 = off_1003079C8[v5 + 1];
  }
  uint64_t v12 = getuid();
  uint64_t v13 = geteuid();
  uint64_t v14 = [v1 SOSMonitorModeSOSIsActiveDescription];
  id v15 = (void *)v14;
  id v16 = "Unrestricted User Visible Views";
  if (v19) {
    id v16 = "User Visible Keychain Disallowed by Profile";
  }
  CFStringRef v17 = CFStringCreateWithFormat(v7, 0, @"ACCOUNT: [keyStatus: %c%c%c hpub %@] [SOSCCStatus: %@] [UID: %d  EUID: %d] %@ %s", v8, v9, v10, Copy, v11, v12, v13, v14, v16);

  if (Copy) {
    CFRelease(Copy);
  }

  return v17;
}

void sub_1001E063C(uint64_t a1)
{
  id v1 = *(void **)(a1 + 32);
  [*(id *)(a1 + 40) accountKey];
  id v2 = (id)SOSCirclePeerInfoCopyStateString();
  [v1 addObject:v2];
}

void sub_1001E06B4(uint64_t a1)
{
  id v1 = *(void **)(a1 + 32);
  [*(id *)(a1 + 40) accountKey];
  id v2 = (id)SOSCirclePeerInfoCopyStateString();
  [v1 addObject:v2];
}

void sub_1001E072C(uint64_t a1)
{
  id v1 = *(void **)(a1 + 32);
  [*(id *)(a1 + 40) accountKey];
  id v2 = (id)SOSCirclePeerInfoCopyStateString();
  [v1 addObject:v2];
}

void sub_1001E07A4(uint64_t a1)
{
  id v1 = *(void **)(a1 + 32);
  [*(id *)(a1 + 40) accountKey];
  id v2 = (id)SOSPeerInfoCopyStateString();
  [v1 addObject:v2];
}

void sub_1001E0818(uint64_t a1)
{
  id v1 = *(void **)(a1 + 32);
  [*(id *)(a1 + 40) accountKey];
  id v2 = (id)SOSPeerInfoCopyStateString();
  [v1 addObject:v2];
}

void sub_1001E0920(uint64_t a1, uint64_t a2)
{
  id v7 = 0;
  unsigned int v3 = +[NSJSONSerialization dataWithJSONObject:a2 options:3 error:&v7];
  id v4 = v7;
  if (!v3)
  {
    unsigned int v5 = sub_10000B070("iCloudIdentity");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      id v6 = [v4 localizedDescription];
      *(_DWORD *)long long buf = 138412290;
      uint64_t v9 = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Error during iCloudIdentityStatus JSONification: %@", buf, 0xCu);
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1001E0F90(uint64_t a1)
{
  CFStringRef PeerID = (const __CFString *)SOSPeerInfoGetPeerID();
  CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, PeerID);
  if (Copy) {
    [*(id *)(a1 + 32) addObject:Copy];
  }

  return _objc_release_x1();
}

void sub_1001E1004(uint64_t a1)
{
  uint64_t v2 = SOSCopyIDOfKey();
  if (v2)
  {
    unsigned int v3 = v2;
    [*(id *)(a1 + 32) addObject:v2];
  }
  else
  {
    unsigned int v3 = sub_10000B070("iCloudIdentity");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "couldn't make ID from key (%@)", buf, 0xCu);
    }
  }
}

void sub_1001E151C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1001E1540(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [[SOSAuthKitHelpers alloc] initWithActiveMIDS:v3];

  if (v4)
  {
    id v7 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    void v9[2] = sub_1001E1648;
    v9[3] = &unk_100307398;
    uint64_t v8 = *(void *)(a1 + 56);
    void v9[4] = *(void *)(a1 + 32);
    uint64_t v11 = v8;
    uint64_t v10 = v4;
    int v12 = *(_DWORD *)(a1 + 64);
    sub_10002AF90(0, v7, (uint64_t)v9);
  }
  (*(void (**)(void, void, void, uint64_t, uint64_t))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 56) + 8) + 24), 0, v5, v6);
}

void sub_1001E1648(uint64_t a1)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_1001E16E8;
  v6[3] = &unk_100307370;
  id v3 = *(void **)(a1 + 32);
  uint64_t v2 = *(void **)(a1 + 40);
  uint64_t v9 = *(void *)(a1 + 48);
  id v4 = v2;
  int v10 = *(_DWORD *)(a1 + 56);
  uint64_t v5 = *(void *)(a1 + 32);
  id v7 = v4;
  uint64_t v8 = v5;
  [v3 performTransaction:v6];
}

id sub_1001E16E8(uint64_t a1, void *a2)
{
  id v3 = [a2 account];
  id v4 = *(void **)(a1 + 32);
  int v5 = *(_DWORD *)(a1 + 56);
  id v6 = v3;
  id v7 = v4;
  uint64_t v49 = 0;
  unsigned int v50 = &v49;
  uint64_t v51 = 0x2020000000;
  char v52 = 0;
  uint64_t v45 = 0;
  unsigned int v46 = &v45;
  uint64_t v47 = 0x2020000000;
  char v48 = 0;
  uint64_t v40 = 0;
  CFStringRef v41 = &v40;
  uint64_t v42 = 0x2020000000;
  uint64_t v43 = 9999;
  CFTypeRef cf = 0;
  uint64_t v8 = objc_opt_new();
  uint64_t v9 = [v6 trust];
  [v9 trustedCircle];
  int v10 = SOSCircleCountPeers();

  if ((v5 & 0x10) != 0 && [v6 isInCircle:0])
  {
    uint64_t v11 = sub_10000B070("ghostBust");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v2_Block_object_dispose(&STACK[0x290], 8) = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Callout to cleanup icloud identities", (uint8_t *)&v28, 2u);
    }

    id v12 = v6;
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&uint8_t buf[16] = 0x2020000000;
    uint64_t v54 = 0;
    CFTypeRef v28 = _NSConcreteStackBlock;
    uint64_t v29 = 3221225472;
    uint64_t v30 = sub_100209CE0;
    uint64_t v31 = &unk_100308978;
    char v32 = buf;
    [v12 iCloudIdentityStatus_internal:&v28];
    uint64_t v13 = *(void *)(*(void *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);

    v41[3] = v13;
    if (v13)
    {
      uint64_t v14 = +[NSNumber numberWithUnsignedInteger:v13];
      [v8 setObject:v14 forKeyedSubscript:@"iCloudPrivKeysBusted"];

      id v15 = +[SOSAnalytics logger];
      [v15 logSoftFailureForEventNamed:@"GhostBust" withAttributes:v8];

      *((unsigned char *)v50 + 24) = 1;
    }
    *((unsigned char *)v46 + 24) = 1;
  }
  if ((v5 & 0xFFFFFFEF) != 0 && [v7 isUseful])
  {
    unsigned int v16 = [v6 isInCircle:0];
    unsigned int v17 = v10 > 1 ? v16 : 0;
    if (v17 == 1)
    {
      uint64_t v18 = [v6 trust];
      int v19 = [v6 circle_transport];
      CFTypeRef v28 = _NSConcreteStackBlock;
      uint64_t v29 = 3221225472;
      uint64_t v30 = sub_10020A18C;
      uint64_t v31 = &unk_1003088B8;
      int v38 = v5;
      id v35 = &v40;
      char v32 = v6;
      id v33 = v7;
      id v34 = v8;
      uint64_t v36 = &v45;
      int v39 = v10;
      uint64_t v37 = &v49;
      [v18 modifyCircle:v19 err:&cf action:&v28];

      id v20 = sub_10000B070("circleOps");
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v21 = @"Performed";
        if (!*((unsigned char *)v50 + 24)) {
          CFStringRef v21 = @"Not Performed";
        }
        *(_DWORD *)long long buf = 138412546;
        *(void *)&uint8_t buf[4] = v21;
        *(_WORD *)&unsigned char buf[12] = 2112;
        *(void *)&buf[14] = cf;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Ghostbusting %@ (%@)", buf, 0x16u);
      }

      CFTypeRef v22 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        CFRelease(v22);
      }
    }
  }
  id v23 = v50;
  if (*((unsigned char *)v46 + 24))
  {
    if (*((unsigned char *)v50 + 24))
    {
      uint64_t v24 = +[SOSAnalytics logger];
      [v24 logSoftFailureForEventNamed:@"GhostBust" withAttributes:v8];
    }
    else if (v41[3])
    {
      uint64_t v24 = +[SOSAnalytics logger];
      [v24 logHardFailureForEventNamed:@"GhostBust" withAttributes:0];
    }
    else
    {
      uint64_t v24 = +[SOSAnalytics logger];
      [v24 logSuccessForEventNamed:@"GhostBust"];
    }

    id v23 = v50;
  }
  char v25 = *((unsigned char *)v23 + 24);

  _Block_object_dispose(&v40, 8);
  _Block_object_dispose(&v45, 8);
  _Block_object_dispose(&v49, 8);

  *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = v25;
  uint64_t v26 = *(void **)(a1 + 40);

  return [v26 ghostBustFollowup];
}

void sub_1001E1BD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

void sub_1001E1F34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_1001E1F50(uint64_t a1)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_1001E1FC4;
  v3[3] = &unk_100309840;
  id v1 = *(void **)(a1 + 32);
  void v3[4] = *(void *)(a1 + 40);
  return [v1 performTransaction:v3];
}

void sub_1001E1FC4(uint64_t a1, void *a2)
{
  id v7 = [a2 account];
  id v3 = [v7 trust];
  [v3 trustedCircle];
  uint64_t v4 = SOSCircleCopyHashString();
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;
}

void sub_1001E223C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_1001E2264(uint64_t a1, void *a2)
{
  id v3 = [a2 account];
  uint64_t v4 = (const void *)sub_1001E2310(v3, *(void *)(*(void *)(a1 + 32) + 8) + 24);

  if (v4)
  {
    uint64_t v5 = SOSPeerInfoCopyEncodedData();
    uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
    id v7 = *(void **)(v6 + 40);
    *(void *)(v6 + 40) = v5;

    CFRelease(v4);
  }
}

uint64_t sub_1001E2310(void *a1, uint64_t a2)
{
  id v3 = a1;
  uint64_t v4 = [v3 trust];
  if (sub_1001EE508(v3)
    && [v4 ensureFullPeerAvailable:v3 err:a2]
    && ([v4 fullPeerInfo], SOSFullPeerInfoPromoteToApplication()))
  {
    [v4 peerInfo];
    uint64_t Copy = SOSPeerInfoCreateCopy();
  }
  else
  {
    uint64_t Copy = 0;
  }

  return Copy;
}

uint64_t sub_1001E25C0(uint64_t a1)
{
  unsigned int v16 = 0;
  if ([*(id *)(a1 + 32) syncWaitAndFlush:*(void *)(a1 + 40) flowID:*(void *)(a1 + 48) deviceSessionID:*(void *)(a1 + 56) canSendMetrics:*(unsigned __int8 *)(a1 + 80) error:&v16])
  {
    uint64_t v12 = 0;
    uint64_t v13 = &v12;
    uint64_t v14 = 0x2020000000;
    char v15 = 0;
    sleep(1u);
    uint64_t v2 = *(void **)(a1 + 32);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    void v7[2] = sub_1001E27CC;
    v7[3] = &unk_1003072F8;
    id v8 = *(id *)(a1 + 64);
    id v3 = *(id *)(a1 + 72);
    uint64_t v9 = *(void *)(a1 + 32);
    id v10 = v3;
    uint64_t v11 = &v12;
    [v2 performTransaction:v7];
    if (*((unsigned char *)v13 + 24) && !sub_1001E2B4C())
    {
      uint64_t v4 = sub_10000B070("pairing");
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        uint64_t v18 = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "failed final flush: %@", buf, 0xCu);
      }
    }
    _Block_object_dispose(&v12, 8);
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 72) + 16))();
    uint64_t v5 = v16;
    if (v16)
    {
      unsigned int v16 = 0;
      CFRelease(v5);
    }
  }
  return 1;
}

void sub_1001E27A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1001E27CC(uint64_t a1)
{
  CFErrorRef error = 0;
  v16[0] = kSecAttrKeyClass;
  v16[1] = kSecAttrKeyType;
  v17[0] = kSecAttrKeyClassPrivate;
  v17[1] = kSecAttrKeyTypeEC;
  CFDictionaryRef v2 = +[NSDictionary dictionaryWithObjects:v17 forKeys:v16 count:2];
  SecKeyRef v3 = SecKeyCreateWithData(*(CFDataRef *)(a1 + 32), v2, &error);
  if (!v3)
  {
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    uint64_t v9 = sub_10000B070("pairing");
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_17;
    }
    *(_DWORD *)long long buf = 138412290;
    CFErrorRef v15 = error;
    id v10 = "SecKeyCreateWithData failed: %@";
    goto LABEL_16;
  }
  SecKeyRef v4 = v3;
  id v5 = *(id *)(a1 + 40);
  if (sub_1001EECBC(v5, (uint64_t)v4, &error))
  {
    sub_1001EEF80(v5, 0, (uint64_t)v4, (int)[v5 accountKeyIsTrusted]);
    sub_1001EE79C(v5);
    uint64_t v6 = sub_10000B070("circleop");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Setting account.key_interests_need_updating to true in SOSAccountTryUserPrivateKey", buf, 2u);
    }

    [v5 setKey_interests_need_updating:1];
    id v7 = sub_10000B070("circleOps");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Accepted provided user_private as credential", buf, 2u);
    }

    *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 1;
    id v8 = sub_10000B070("pairing");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "SOSAccountTryUserPrivateKey succeeded", buf, 2u);
    }

    CFRelease(v4);
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    goto LABEL_19;
  }
  uint64_t v11 = sub_10000B070("circleOps");
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Failed to accept provided user_private as credential", buf, 2u);
  }

  CFRelease(v4);
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  uint64_t v9 = sub_10000B070("pairing");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    CFErrorRef v15 = error;
    id v10 = "SOSAccountTryUserPrivateKey failed: %@";
LABEL_16:
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v10, buf, 0xCu);
  }
LABEL_17:

  CFErrorRef v12 = error;
  if (error)
  {
    CFErrorRef error = 0;
    CFRelease(v12);
  }
LABEL_19:
}

BOOL sub_1001E2B4C()
{
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2020000000;
  char v11 = 0;
  dispatch_semaphore_t v0 = dispatch_semaphore_create(0);
  id v1 = sub_10000B070("flush");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Starting", buf, 2u);
  }

  CFDictionaryRef v2 = dispatch_get_global_queue(-2, 0);
  SecKeyRef v3 = v0;
  SOSCloudKeychainFlush();

  dispatch_semaphore_wait(v3, 0xFFFFFFFFFFFFFFFFLL);
  SecKeyRef v4 = sub_10000B070("flush");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*((unsigned char *)v9 + 24)) {
      id v5 = "Success";
    }
    else {
      id v5 = "Failure";
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v13 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Returned %s", buf, 0xCu);
  }

  BOOL v6 = *((unsigned char *)v9 + 24) != 0;
  _Block_object_dispose(&v8, 8);
  return v6;
}

void sub_1001E2D44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

intptr_t sub_1001E2D64(void *a1, int a2, CFTypeRef cf)
{
  SecKeyRef v4 = (CFTypeRef *)a1[6];
  *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = cf == 0;
  if (v4)
  {
    CFTypeRef v6 = *v4;
    if (*v4 != cf)
    {
      if (!cf || (CFRetain(cf), (CFTypeRef v6 = *v4) != 0)) {
        CFRelease(v6);
      }
      *SecKeyRef v4 = cf;
    }
  }
  id v7 = a1[4];

  return dispatch_semaphore_signal(v7);
}

void sub_1001E2F5C(uint64_t a1)
{
  id v2 = objc_alloc((Class)AAFAnalyticsEventSecurity);
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(a1 + 48);
  uint64_t v6 = kSecurityRTCEventNameValidatedStashedAccountCredential;
  sub_1001DE7E0();
  LOBYTE(v20) = *(unsigned char *)(a1 + 72);
  id v8 = [v2 initWithKeychainCircleMetrics:0 altDSID:v3 flowID:v4 deviceSessionID:v5 eventName:v6 testsAreEnabled:v7 canSendMetrics:v20 category:kSecurityRTCEventCategoryAccountDataAccessRecovery];
  CFErrorRef error = 0;
  uint64_t v9 = sub_1001EEA9C((__CFString **)&error);
  if (v9)
  {
    uint64_t v10 = v9;
    SecKeyRef v11 = SecKeyCopyPublicKey(v9);
    if (v11)
    {
      SecKeyRef v12 = v11;
      uint64_t v13 = sub_10000B070("pairing");
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        SecKeyRef v25 = v12;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "returning stash credential: %@", buf, 0xCu);
      }

      CFRelease(v12);
    }
    CFDataRef v14 = SecKeyCopyExternalRepresentation(v10, &error);
    CFRelease(v10);
    (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
    CFErrorRef v15 = error;
    if (error)
    {
      CFErrorRef error = 0;
      CFRelease(v15);
    }
    uint64_t v22 = kSecurityRTCFieldNumberOfKeychainItemsCollected;
    id v23 = &off_100326848;
    unsigned int v16 = +[NSDictionary dictionaryWithObjects:&v23 forKeys:&v22 count:1];
    [v8 addMetrics:v16];

    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v8 success:1 error:0];
  }
  else
  {
    unsigned int v17 = sub_10000B070("pairing");
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "no stashed credential", buf, 2u);
    }

    uint64_t v26 = kSecurityRTCFieldNumberOfKeychainItemsCollected;
    __int16 v27 = &off_100326830;
    uint64_t v18 = +[NSDictionary dictionaryWithObjects:&v27 forKeys:&v26 count:1];
    [v8 addMetrics:v18];

    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v8 success:0 error:error];
    (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
    CFErrorRef v19 = error;
    if (error)
    {
      CFErrorRef error = 0;
      CFRelease(v19);
    }
  }
}

void sub_1001E3660(uint64_t a1)
{
  id v2 = dispatch_get_global_queue(-2, 0);
  long long v7 = *(_OWORD *)(a1 + 32);
  id v3 = (id)v7;
  SOSCloudKeychainSynchronizeAndWait();

  dispatch_semaphore_wait(*(dispatch_semaphore_t *)(a1 + 32), 0xFFFFFFFFFFFFFFFFLL);
  uint64_t v4 = sub_10000B070("fresh");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void **)(a1 + 48);
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
      uint64_t v6 = "success";
    }
    else {
      uint64_t v6 = "failure";
    }
    if (v5) {
      uint64_t v5 = (void *)*v5;
    }
    *(_DWORD *)long long buf = 136315394;
    uint64_t v9 = v6;
    __int16 v10 = 2112;
    SecKeyRef v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "EFP complete: %s %@", buf, 0x16u);
  }
}

intptr_t sub_1001E37E0(uint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t v5 = sub_10000B070("fresh");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 138412290;
    __int16 v10 = a3;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "EFP returned, callback error: %@", (uint8_t *)&v9, 0xCu);
  }

  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = a3 == 0;
  uint64_t v6 = *(const void ***)(a1 + 48);
  if (v6)
  {
    long long v7 = *v6;
    if (*v6 != a3)
    {
      if (!a3 || (CFRetain(a3), (long long v7 = *v6) != 0)) {
        CFRelease(v7);
      }
      const char *v6 = a3;
    }
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_1001E3998(uint64_t a1)
{
  CFTypeRef cf = 0;
  sub_1001EEE6C(*(void **)(a1 + 32), (__CFString **)&cf);
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  CFTypeRef v2 = cf;
  if (cf)
  {
    CFTypeRef cf = 0;
    CFRelease(v2);
  }
}

void sub_1001E3AAC(uint64_t a1)
{
  CFTypeRef cf = 0;
  SecKeyRef v2 = sub_1001EEA9C((__CFString **)&cf);
  if (v2)
  {
    SecKeyRef v3 = v2;
    uint64_t v4 = (void *)SecKeyCopySubjectPublicKeyInfo();
    CFRelease(v3);
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    CFTypeRef v5 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v5);
    }
  }
}

uint64_t sub_1001E3CA0(uint64_t a1)
{
  [*(id *)(a1 + 32) setAccountInBypassMode:*(unsigned __int8 *)(a1 + 48)];
  SecKeyRef v2 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16);

  return v2();
}

uint64_t sub_1001E3D9C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1001E3E60(uint64_t a1)
{
  if ([*(id *)(a1 + 32) accountKeyIsTrusted]
    && [*(id *)(a1 + 32) accountKey])
  {
    [*(id *)(a1 + 32) accountKey];
    uint64_t v2 = SecKeyCopySubjectPublicKeyInfo();
    if (v2)
    {
      SecKeyRef v3 = (void *)v2;
      (*(void (**)(void, id, uint64_t, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), [*(id *)(a1 + 32) accountKeyIsTrusted], v2, 0);
    }
    else
    {
      CFStringRef v11 = kCFErrorDescriptionKey;
      CFStringRef v12 = @"User public not available";
      long long v7 = +[NSDictionary dictionaryWithObjects:&v12 forKeys:&v11 count:1];
      uint64_t v8 = *(void *)(a1 + 40);
      id v9 = [*(id *)(a1 + 32) accountKeyIsTrusted];
      __int16 v10 = +[NSError errorWithDomain:kSOSErrorDomain code:2 userInfo:v7];
      (*(void (**)(uint64_t, id, void, void *))(v8 + 16))(v8, v9, 0, v10);

      SecKeyRef v3 = 0;
    }
  }
  else
  {
    CFStringRef v13 = kCFErrorDescriptionKey;
    CFStringRef v14 = @"User public key not trusted";
    SecKeyRef v3 = +[NSDictionary dictionaryWithObjects:&v14 forKeys:&v13 count:1];
    uint64_t v4 = *(void *)(a1 + 40);
    id v5 = [*(id *)(a1 + 32) accountKeyIsTrusted];
    uint64_t v6 = +[NSError errorWithDomain:kSOSErrorDomain code:2 userInfo:v3];
    (*(void (**)(uint64_t, id, void, void *))(v4 + 16))(v4, v5, 0, v6);
  }
}

CFStringRef sub_1001E4B34(void *a1)
{
  CFStringRef result = (const __CFString *)sub_1001DCC24(a1, kSOSDSIDKey);
  if (result)
  {
    CFStringRef v2 = result;
    CFTypeID v3 = CFGetTypeID(result);
    if (v3 == CFStringGetTypeID() && !CFEqual(v2, kCFNull))
    {
      if (CFStringCompare(v2, &stru_10030AA90, 0)) {
        return v2;
      }
      else {
        return 0;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_1001E4BB8(void *a1, uint64_t a2)
{
  id v3 = a1;
  CFStringRef v4 = sub_1001E4B34(v3);
  if (!v4)
  {
    long long v7 = sub_10000B070("updates");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 138412290;
      uint64_t v10 = a2;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Setting dsid, current dsid is empty for this account: %@", (uint8_t *)&v9, 0xCu);
    }

    sub_1001E4D44(v3, a2);
    goto LABEL_10;
  }
  if (!a2) {
    goto LABEL_11;
  }
  CFStringRef v5 = v4;
  if (CFEqual((CFStringRef)a2, v4))
  {
LABEL_10:
    a2 = 0;
    goto LABEL_11;
  }
  uint64_t v6 = sub_10000B070("updates");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 138412546;
    uint64_t v10 = (uint64_t)v5;
    __int16 v11 = 2112;
    uint64_t v12 = a2;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Changing DSID from: %@ to %@", (uint8_t *)&v9, 0x16u);
  }

  sub_10002BBA0(@"DSID Change is unexpected", 0x53C00011u);
  sub_1001E4DD0(v3);
  sub_1001E4D44(v3, a2);
  a2 = 1;
LABEL_11:

  return a2;
}

void sub_1001E4D44(void *a1, uint64_t a2)
{
  uint64_t v3 = kSOSDSIDKey;
  id v4 = a1;
  sub_1001FF4C0(v4, v3, a2, 0);
  [v4 circle_transport];
  id v5 = (id)objc_claimAutoreleasedReturnValue();

  [v5 kvsSendOfficialDSID:a2 err:0];
}

void sub_1001E4DD0(void *a1)
{
  id v1 = a1;
  CFStringRef v2 = sub_10000B070("accountChange");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Setting Account to New", buf, 2u);
  }

  CFDictionaryRef v10 = sub_100139704(kCFAllocatorDefault, v3, v4, v5, v6, v7, v8, v9, (uint64_t)kSecClass, (uint64_t)kSecClassGenericPassword);
  sub_1001E52AC(v10);
  if (v10) {
    CFRelease(v10);
  }
  CFDictionaryRef v18 = sub_100139704(kCFAllocatorDefault, v11, v12, v13, v14, v15, v16, v17, (uint64_t)kSecClass, (uint64_t)kSecClassKey);
  sub_1001E52AC(v18);
  if (v18) {
    CFRelease(v18);
  }
  CFDictionaryRef v26 = sub_100139704(kCFAllocatorDefault, v19, v20, v21, v22, v23, v24, v25, (uint64_t)kSecClass, (uint64_t)kSecClassGenericPassword);
  sub_1001E52AC(v26);
  if (v26) {
    CFRelease(v26);
  }
  CFDictionaryRef v34 = sub_100139704(kCFAllocatorDefault, v27, v28, v29, v30, v31, v32, v33, (uint64_t)kSecClass, (uint64_t)kSecClassGenericPassword);
  sub_1001E52AC(v34);
  if (v34) {
    CFRelease(v34);
  }
  id v35 = [v1 user_private_timer];

  if (v35)
  {
    uint64_t v36 = [v1 user_private_timer];
    dispatch_source_cancel(v36);

    [v1 setUser_private_timer:0];
    xpc_transaction_end();
  }
  if (objc_msgSend(v1, "lock_notification_token") != -1)
  {
    notify_cancel((int)[v1 lock_notification_token]);
    [v1 setLock_notification_token:0xFFFFFFFFLL];
  }
  uint64_t v37 = [v1 key_transport];
  sub_10020CA18(v37);

  int v38 = [v1 kvs_message_transport];
  sub_10020C89C(v38);

  int v39 = [v1 circle_transport];
  sub_10020C97C(v39);

  [v1 setCircle_transport:0];
  [v1 setKvs_message_transport:0];
  [v1 set_password_tmp:0];
  [v1 setCircle_rings_retirements_need_attention:1];
  [v1 setEngine_peer_state_needs_repair:1];
  [v1 setKey_interests_need_updating:1];
  [v1 setNeed_backup_peers_created_after_backup_key_set:1];
  [v1 setAccountKeyIsTrusted:0];
  [v1 setAccountKeyDerivationParameters:0];
  [v1 setAccountPrivateKey:0];
  [v1 setAccountKey:0];
  [v1 setPreviousAccountKey:0];
  [v1 setPeerPublicKey:0];
  [v1 setBackup_key:0];
  [v1 setNotifyCircleChangeOnExit:1];
  [v1 setNotifyViewChangeOnExit:1];
  [v1 setNotifyBackupOnExit:1];
  [v1 setOctagonSigningFullKeyRef:0];
  [v1 setOctagonEncryptionFullKeyRef:0];
  [v1 setTrust:0];
  uint64_t v40 = [SOSAccountTrustClassic alloc];
  CFStringRef v41 = +[NSMutableSet set];
  uint64_t v42 = +[NSMutableDictionary dictionary];
  uint64_t v43 = [(SOSAccountTrustClassic *)v40 initWithRetirees:v41 fpi:0 circle:0 departureCode:0 peerExpansion:v42];
  [v1 setTrust:v43];

  [v1 ensureFactoryCircles];
  CFStringRef v44 = sub_1001FF568(v1);
  if (v44) {
    CFRelease(v44);
  }
  uint64_t v45 = sub_10000B070("circleop");
  if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unsigned int v46 = 0;
    _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "Setting account.key_interests_need_updating to true in SOSAccountSetToNew", v46, 2u);
  }

  [v1 setKey_interests_need_updating:1];
}

void sub_1001E52AC(const __CFDictionary *a1)
{
  OSStatus v1 = SecItemDelete(a1);
  if (v1)
  {
    OSStatus v2 = v1;
    int v3 = sub_10000B070("SecError");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      v4[0] = 67109120;
      v4[1] = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "SecItemDelete: %d", (uint8_t *)v4, 8u);
    }
  }
}

SOSAccount *sub_1001E5360(uint64_t a1, uint64_t a2)
{
  OSStatus v2 = [[SOSAccount alloc] initWithGestalt:a1 factory:a2];
  int v3 = [(SOSAccount *)v2 queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1001E5430;
  block[3] = &unk_100308558;
  int v4 = v2;
  int v7 = v4;
  dispatch_sync(v3, block);

  return v4;
}

id sub_1001E5430(uint64_t a1)
{
  OSStatus v2 = sub_10000B070("circleop");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Setting account.key_interests_need_updating to true in SOSAccountCreate", v4, 2u);
  }

  return [*(id *)(a1 + 32) setKey_interests_need_updating:1];
}

void sub_1001E54B0(uint64_t a1, const void *a2)
{
  OSStatus v2 = a2;
  CFSetSetValue(*(CFMutableSetRef *)(a1 + 32), a2);
  CFTypeRef cf = 0;
  int v4 = [*(id *)(a1 + 40) trust];
  int v5 = [*(id *)(a1 + 40) kvs_message_transport];
  int v6 = [*(id *)(a1 + 40) circle_transport];
  LOBYTE(v2) = [v4 cleanupAfterPeer:v5 circleTransport:v6 seconds:86400 circle:*(void *)(a1 + 48) cleanupPeer:v2 err:&cf];

  if ((v2 & 1) == 0)
  {
    int v7 = sub_10000B070("retirement");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      CFTypeRef v10 = cf;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Error cleaning up after peer, probably orphaned some stuff in KVS: (%@)  moving on", buf, 0xCu);
    }
  }
  if (cf) {
    CFRelease(cf);
  }
}

uint64_t sub_1001E55F4(uint64_t result, CFTypeRef cf)
{
  if (cf)
  {
    uint64_t v2 = result;
    CFTypeID v3 = CFGetTypeID(cf);
    CFStringRef result = SOSPeerInfoGetTypeID();
    if (v3 == result)
    {
      CFStringRef result = SOSCircleUpdatePeerInfo();
      *(unsigned char *)(*(void *)(*(void *)(v2 + 32) + 8) + 24) = 1;
    }
  }
  return result;
}

void sub_1001E565C(void *a1, void *a2)
{
  id v3 = a1;
  id v6 = objc_retainBlock(a2);
  int v4 = [v3 change_blocks];

  id v5 = objc_retainBlock(v6);
  [v4 addObject:v5];
}

BOOL sub_1001E56E0(void *a1, uint64_t a2)
{
  id v3 = a1;
  int v4 = [v3 trust];
  id v5 = [v4 fullPeerInfo];
  id v6 = [v4 retirees];
  if (v5)
  {
    v23[1] = 0;
    int v7 = (const void *)SOSFullPeerInfoPromoteToRetiredAndCopy();
    if (v7)
    {
      if (SOSCircleHasApplicant())
      {
        SOSCircleWithdrawRequest();
      }
      else if (SOSCircleHasPeer() && SOSCircleUpdatePeerInfo())
      {
        v23[0] = 0;
        int v9 = [v3 trust];
        CFTypeRef v10 = [v3 kvs_message_transport];
        int v11 = [v3 circle_transport];
        unsigned __int8 v12 = [v9 cleanupAfterPeer:v10 circleTransport:v11 seconds:86400 circle:a2 cleanupPeer:v7 err:v23];

        if ((v12 & 1) == 0)
        {
          int v13 = sub_10000B070("SecError");
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138412546;
            CFTypeRef v25 = v7;
            __int16 v26 = 2112;
            CFTypeRef v27 = v23[0];
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Error cleanup up after peer (%@): %@", buf, 0x16u);
          }
        }
        if (v23[0]) {
          CFRelease(v23[0]);
        }
      }
      CFSetAddValue(v6, v7);
      [v4 setRetirees:v6];
      v23[0] = 0;
      int v14 = [v3 circle_transport];
      unsigned __int8 v15 = [v14 postRetirement:SOSCircleGetName() peer:v7 err:v23];

      if ((v15 & 1) == 0)
      {
        int v16 = sub_10000B070("SecWarning");
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          CFTypeRef v25 = v23[0];
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Couldn't post retirement (%@)", buf, 0xCu);
        }
      }
      int v17 = [v3 circle_transport];
      unsigned __int8 v18 = [v17 flushChanges:v23];

      if ((v18 & 1) == 0)
      {
        int v19 = sub_10000B070("SecWarning");
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          CFTypeRef v25 = v23[0];
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Couldn't flush retirement data (%@)", buf, 0xCu);
        }
      }
      CFTypeRef v20 = v23[0];
      if (v23[0])
      {
        v23[0] = 0;
        CFRelease(v20);
      }
    }
    else
    {
      int v8 = sub_10000B070("SecError");
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412546;
        CFTypeRef v25 = v5;
        __int16 v26 = 2112;
        CFTypeRef v27 = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Create ticket failed for peer %@: %@", buf, 0x16u);
      }
    }
    int v21 = [v3 trust];
    [v21 purgeIdentity];

    if (v7) {
      CFRelease(v7);
    }
  }

  return v5 != 0;
}

void sub_1001E5B30(uint64_t a1, const void *a2)
{
  if (SOSPeerInfoIsCloudIdentity())
  {
    CloudIdentity = (const void *)SOSFullPeerInfoCreateCloudIdentity();
    if (CloudIdentity)
    {
      CFRelease(CloudIdentity);
    }
    else
    {
      id v5 = *(__CFSet **)(a1 + 32);
      CFSetAddValue(v5, a2);
    }
  }
}

uint64_t sub_1001E5BBC(void *a1, int a2, uint64_t a3)
{
  id v5 = a1;
  id v6 = [v5 account];
  int v7 = [v6 trust];
  id v8 = sub_1001EE508(v6);
  if (!v8) {
    goto LABEL_45;
  }
  id v9 = v8;
  if ([v7 trustedCircle] && (objc_msgSend(v7, "trustedCircle"), SOSCircleCountPeers()))
  {
    if (([v6 accountInScriptBypassMode] & 1) == 0)
    {
      [v7 trustedCircle];
      CFTypeRef v10 = [v6 peerID];
      int HasPeerWithID = SOSCircleHasPeerWithID();

      if (HasPeerWithID)
      {
        unsigned __int8 v12 = sub_10000B070("circleops");
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "attempt to join a circle we're in - continuing.", buf, 2u);
        }

        goto LABEL_43;
      }
    }
    [v7 trustedCircle];
    [v6 accountKey];
    if (SOSCircleVerify())
    {
      if (([v6 accountInScriptBypassMode] & 1) == 0 && objc_msgSend(v7, "fullPeerInfo"))
      {
        [v7 peerInfo];
        [v7 trustedCircle];
        if (SOSCircleHasPeer())
        {
LABEL_43:
          uint64_t v15 = 1;
          goto LABEL_44;
        }
        [v7 trustedCircle];
        SOSCircleRemoveRejectedPeer();
        [v7 trustedCircle];
        if ((SOSCircleHasApplicant() & 1) == 0)
        {
          int v16 = sub_10000B070("SecError");
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t PeerID = SOSPeerInfoGetPeerID();
            [v7 trustedCircle];
            *(_DWORD *)long long buf = 138412546;
            *(void *)&uint8_t buf[4] = PeerID;
            *(_WORD *)&unsigned char buf[12] = 2112;
            *(void *)&buf[14] = SOSCircleGetName();
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Resetting my peer (ID: %@) for circle '%@' during application", buf, 0x16u);
          }

          [v7 setFullPeerInfo:0];
        }
      }
      id v34 = v5;
      unsigned __int8 v18 = [v34 account];
      int v19 = [v18 trust];
      uint64_t v39 = 0;
      uint64_t v40 = &v39;
      uint64_t v41 = 0x2020000000;
      char v42 = 0;
      uint64_t v35 = 0;
      uint64_t v36 = &v35;
      uint64_t v37 = 0x2020000000;
      uint64_t v38 = 0;
      if ([v19 trustedCircle])
      {
        CFTypeRef v20 = [v18 trust];
        unsigned int v21 = [v20 ensureFullPeerAvailable:v18 err:a3];

        if (v21)
        {
          if ([v18 accountInScriptBypassMode])
          {
            int v22 = [v18 trust];
            [v22 setFullPeerInfo:0];

            int v23 = [v18 trust];
            [v23 ensureFullPeerAvailable:v18 err:a3];
          }
          id v33 = [v19 fullPeerInfo];
          [v19 trustedCircle];
          if (SOSCircleCountPeers()
            && (([v18 accountInScriptBypassMode] & 1) != 0
             || !sub_1002096CC(v18)))
          {
            sub_1001F6D70(v18);
            if (a2)
            {
              [v19 trustedCircle];
              v36[3] = SOSCircleCopyiCloudFullPeerInfoRef();
            }
            CFTypeRef v27 = [v18 trust];
            int v28 = [v18 circle_transport];
            *(void *)long long buf = _NSConcreteStackBlock;
            *(void *)&uint8_t buf[8] = 3221225472;
            *(void *)&uint8_t buf[16] = sub_1001E6248;
            CFStringRef v44 = &unk_1003078C8;
            uint64_t v47 = &v39;
            id v45 = v18;
            id v49 = v33;
            uint64_t v50 = a3;
            id v51 = v9;
            id v46 = v19;
            char v48 = &v35;
            [v27 modifyCircle:v28 err:a3 action:buf];

            if (a2)
            {
              AllCFAbsoluteTime Current = (const __CFSet *)SOSViewsGetAllCurrent();
              sub_1001F74C8(v34, AllCurrent);
            }

            CFTypeRef v25 = v45;
          }
          else
          {
            int v24 = sub_10000B070("resetToOffering");
            if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Resetting circle to offering since there are no peers", buf, 2u);
            }

            CFTypeRef v25 = [v18 trust];
            unsigned __int8 v26 = [v25 resetCircleToOffering:v34 userKey:v9 err:a3];
            *((unsigned char *)v40 + 24) = v26;
          }
        }
      }
      else
      {
        SOSCreateErrorWithFormat();
      }
      int v30 = (const void *)v36[3];
      if (v30)
      {
        v36[3] = 0;
        CFRelease(v30);
      }
      BOOL v31 = *((unsigned char *)v40 + 24) == 0;
      _Block_object_dispose(&v35, 8);
      _Block_object_dispose(&v39, 8);

      if (!v31)
      {
        [v7 setDepartureCode:1];
        goto LABEL_43;
      }
LABEL_45:
      uint64_t v15 = 0;
      goto LABEL_44;
    }
    int v13 = sub_10000B070("resetToOffering");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Resetting circle to offering since we are new and it doesn't verify with current userKey", buf, 2u);
    }
  }
  else
  {
    int v13 = sub_10000B070("resetToOffering");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Resetting circle to offering because it's empty and we're joining", buf, 2u);
    }
  }

  int v14 = [v6 trust];
  uint64_t v15 = (uint64_t)[v14 resetCircleToOffering:v5 userKey:v9 err:a3];

LABEL_44:
  return v15;
}

void sub_1001E6218(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va1, a3);
  va_start(va, a3);
  uint64_t v4 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  uint64_t v8 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

BOOL sub_1001E6248(uint64_t a1)
{
  sub_1001DCC24(*(void **)(a1 + 32), @"EscrowRecord");
  *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = SOSFullPeerInfoReplaceEscrowRecords();
  char v2 = SOSCircleRequestAdmission();
  uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8);
  if (*(unsigned char *)(v3 + 24)) {
    char v4 = v2;
  }
  else {
    char v4 = 0;
  }
  *(unsigned char *)(v3 + 24) = v4;
  [*(id *)(a1 + 40) setDepartureCode:1];
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24)) {
    return 0;
  }
  if (!*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24)) {
    return 1;
  }
  SOSFullPeerInfoGetPeerInfo();
  if (SOSPeerInfoGetPeerID())
  {
    if (SOSCircleHasActivePeerWithID())
    {
      SOSFullPeerInfoGetPeerInfo();
      SOSCircleAcceptRequest();
    }
  }
  return *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) != 0;
}

uint64_t sub_1001E6414(void *a1, const __CFArray *a2, uint64_t a3)
{
  id v5 = a1;
  sub_10002595C(a2, @"[", @"]", (uint64_t)&stru_100307548);
  id v6 = sub_1001EE508(v5);
  if (!v6)
  {
    int v17 = sub_10000B070("circleOps");
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Can't remove without userKey", buf, 2u);
    }

    goto LABEL_14;
  }
  id v7 = v6;
  id v8 = [v5 fullPeerInfo];
  id v9 = [v5 peerInfo];
  if (!v8 || (CFTypeRef v10 = v9) == 0)
  {
    unsigned __int8 v18 = sub_10000B070("circleOps");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Can't remove without being active peer", buf, 2u);
    }

    SOSErrorCreate();
LABEL_14:
    uint64_t v16 = 0;
    goto LABEL_15;
  }
  CFSetRef MutableForSOSPeerInfosByIDWithArray = (const __CFSet *)CFSetCreateMutableForSOSPeerInfosByIDWithArray();
  if (MutableForSOSPeerInfosByIDWithArray)
  {
    unsigned __int8 v12 = MutableForSOSPeerInfosByIDWithArray;
    BOOL v13 = CFSetContainsValue(MutableForSOSPeerInfosByIDWithArray, v10) != 0;
    CFSetRemoveValue(v12, v10);
    int v14 = [v5 trust];
    uint64_t v15 = [v5 circle_transport];
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 3221225472;
    v21[2] = sub_1001E66C0;
    v21[3] = &unk_100307570;
    int v23 = v12;
    id v24 = v7;
    id v25 = v8;
    uint64_t v26 = a3;
    id v22 = v5;
    BOOL v27 = v13;
    uint64_t v16 = (uint64_t)[v14 modifyCircle:v15 err:a3 action:v21];

    if (v16) {
      sub_100025B70(v12, (uint64_t)&stru_100307590);
    }
    CFRelease(v12);
  }
  else
  {
    CFTypeRef v20 = sub_10000B070("circleOps");
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "No peerSet to remove", buf, 2u);
    }

    uint64_t v16 = 1;
  }
LABEL_15:

  return v16;
}

uint64_t sub_1001E66C0(uint64_t a1, uint64_t a2)
{
  if (!CFSetGetCount(*(CFSetRef *)(a1 + 40))
    || (uint64_t result = SOSCircleRemovePeers(), result)
    && (uint64_t result = sub_1001EE498(*(void **)(a1 + 32)), result))
  {
    if (*(unsigned char *)(a1 + 72))
    {
      id v5 = sub_10000B070("circleOps");
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)id v6 = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Leaving circle by client request (SOSAccountRemovePeersFromCircle)", v6, 2u);
      }

      return sub_1001E56E0(*(void **)(a1 + 32), a2);
    }
    else
    {
      return 1;
    }
  }
  return result;
}

void sub_1001E6790(id a1, __CFString *a2)
{
  uint64_t v3 = sub_10000B070("circleOps");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    id v5 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Removed Peers from circle %@", (uint8_t *)&v4, 0xCu);
  }
}

void sub_1001E683C(id a1, __CFString *a2)
{
  uint64_t v3 = sub_10000B070("circleOps");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    id v5 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Attempting to remove peer set %@", (uint8_t *)&v4, 0xCu);
  }
}

void sub_1001E68E8(uint64_t a1)
{
  char v2 = *(void **)(a1 + 32);
  uint64_t v3 = [*(id *)(a1 + 40) circle_transport];
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  void v7[2] = sub_1001E699C;
  v7[3] = &unk_100308CF0;
  uint64_t v4 = *(void *)(a1 + 48);
  id v5 = *(id *)(a1 + 40);
  uint64_t v6 = *(void *)(a1 + 48);
  id v8 = v5;
  uint64_t v9 = v6;
  [v2 modifyCircle:v3 err:v4 action:v7];
}

BOOL sub_1001E699C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_10000B070("circleOps");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Leaving circle by client request (Bail)", v6, 2u);
  }

  return sub_1001E56E0(*(void **)(a1 + 32), a2);
}

uint64_t sub_1001E6A28(uint64_t a1)
{
  uint64_t result = SOSCircleAcceptRequest();
  if (result) {
    ++*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  return result;
}

void sub_1001E6A70(void *a1, uint64_t a2, void *a3)
{
  id v5 = a1;
  id v6 = a3;
  id v7 = [v5 trust];
  id v8 = [v7 peerInfo];
  CFTypeRef cf = 0;
  if ([v7 trustedCircle] && v8)
  {
    [v7 trustedCircle];
    if (SOSCircleHasPeer())
    {
      uint64_t v9 = [v5 trust];
      CFTypeRef v10 = [v5 circle_transport];
      v12[0] = _NSConcreteStackBlock;
      v12[1] = 3221225472;
      v12[2] = sub_1001E6C4C;
      v12[3] = &unk_100307918;
      uint64_t v15 = a2;
      id v14 = v6;
      id v13 = v7;
      [v9 modifyCircle:v10 err:0 action:v12];
    }
    if (cf)
    {
      int v11 = sub_10000B070("SecError");
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        CFTypeRef v18 = cf;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Got error in SOSCircleHasPeer: %@", buf, 0xCu);
      }

      if (cf) {
        CFRelease(cf);
      }
    }
  }
}

uint64_t sub_1001E6C4C(uint64_t a1, uint64_t a2)
{
  uint64_t v12 = 0;
  id v13 = &v12;
  uint64_t v14 = 0x2020000000;
  char v15 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  void v7[2] = sub_1001E6D70;
  v7[3] = &unk_1003078F0;
  uint64_t v11 = a2;
  CFArrayRef v3 = *(const __CFArray **)(a1 + 48);
  id v9 = *(id *)(a1 + 40);
  id v8 = *(id *)(a1 + 32);
  CFTypeRef v10 = &v12;
  uint64_t v4 = v7;
  v16.size_t length = CFArrayGetCount(v3);
  v16.id location = 0;
  CFArrayApplyFunction(v3, v16, (CFArrayApplierFunction)sub_1001DB1A8, v4);

  uint64_t v5 = *((unsigned __int8 *)v13 + 24);
  _Block_object_dispose(&v12, 8);
  return v5;
}

void sub_1001E6D58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001E6D70(uint64_t result, CFTypeRef cf)
{
  if (cf)
  {
    uint64_t v3 = result;
    CFTypeID v4 = CFGetTypeID(cf);
    uint64_t result = SOSPeerInfoGetTypeID();
    if (v4 == result)
    {
      uint64_t result = SOSCircleHasApplicant();
      if (result)
      {
        uint64_t result = (*(uint64_t (**)(void, void, id, CFTypeRef))(*(void *)(v3 + 40) + 16))(*(void *)(v3 + 40), *(void *)(v3 + 56), [*(id *)(v3 + 32) fullPeerInfo], cf);
        if (result) {
          *(unsigned char *)(*(void *)(*(void *)(v3 + 48) + 8) + 24) = 1;
        }
      }
    }
  }
  return result;
}

uint64_t sub_1001E6E0C(uint64_t a1)
{
  uint64_t v2 = SOSCircleRejectRequest();
  if (v2)
  {
    uint64_t v3 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    uint64_t v4 = (int)SOSCircleCountPeers();
    if (v3 > v4) {
      uint64_t v4 = v3;
    }
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v4;
  }
  else
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
  }
  return v2;
}

void sub_1001E6E98(void *a1)
{
  id v1 = a1;
  uint64_t v2 = [v1 trust];
  uint64_t v3 = sub_10000B070("updates");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Ensuring peer registration.", buf, 2u);
  }

  if (!v2)
  {
    uint64_t v4 = sub_10000B070("updates");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Failed to get trust object in Ensuring peer registration.", buf, 2u);
    }
    goto LABEL_11;
  }
  if (![v1 getCircleStatus:0])
  {
    uint64_t v4 = [v1 trust];
    [v4 fullPeerInfo];
    [v4 trustedCircle];
    if (!SOSFullPeerInfoGetPeerInfo())
    {
LABEL_11:

      goto LABEL_12;
    }
    int HasActivePeer = SOSCircleHasActivePeer();

    if (HasActivePeer && [v1 SOSMonitorModeSOSIsActive])
    {
      [v2 peerInfo];
      SOSPeerInfoGetPeerID();
      [v2 trustedCircle];
      [v1 accountKey];
      id v6 = v1;
      id v7 = v2;
      SOSCircleForEachValidSyncingPeer();

      uint64_t v4 = v6;
      goto LABEL_11;
    }
  }
LABEL_12:
}

void sub_1001E708C(uint64_t a1, uint64_t a2)
{
  if ((SOSPeerInfoPeerIDEqual() & 1) == 0)
  {
    CFTypeRef cf = 0;
    uint64_t v4 = [*(id *)(a1 + 32) kvs_message_transport];
    id v5 = [v4 SOSTransportMessageGetEngine];
    id v6 = [*(id *)(a1 + 40) fullPeerInfo];
    if (-[OTSOSActualAdapter sosEnabled]_0())
    {
      uint64_t v14 = 0;
      char v15 = &v14;
      uint64_t v16 = 0x2020000000;
      char v17 = 1;
      uint64_t PeerID = SOSPeerInfoGetPeerID();
      *(void *)long long buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 3221225472;
      *(void *)&uint8_t buf[16] = sub_1000FC074;
      CFTypeRef v19 = &unk_1002FA118;
      CFTypeRef v20 = &v14;
      id v21 = v5;
      uint64_t v22 = PeerID;
      id v23 = v6;
      uint64_t v24 = a2;
      p_CFTypeRef cf = &cf;
      char v8 = sub_1000FC5B8((uint64_t)v5, PeerID, (uint64_t)&cf, buf);
      char v9 = *((unsigned char *)v15 + 24) ? v8 : 0;
      *((unsigned char *)v15 + 24) = v9;
      _Block_object_dispose(&v14, 8);
    }
    else
    {
      SOSCCSetSOSDisabledError();
    }

    if (cf)
    {
      CFTypeRef v10 = sub_10000B070("updates");
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        id v11 = [*(id *)(a1 + 40) fullPeerInfo];
        *(_DWORD *)long long buf = 138412802;
        *(void *)&uint8_t buf[4] = a2;
        *(_WORD *)&unsigned char buf[12] = 2112;
        *(void *)&buf[14] = v11;
        *(_WORD *)&buf[22] = 2112;
        CFTypeRef v19 = cf;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "can't initialize transport for peer %@ with %@ (%@)", buf, 0x20u);
      }

      CFTypeRef v12 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        CFRelease(v12);
      }
    }
  }
}

void sub_1001E7280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

intptr_t sub_1001E72A0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    id v5 = sub_10000B070("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 138412290;
      uint64_t v8 = a3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "SOSCloudKeychainPutObjectsInCloud returned error: %@", (uint8_t *)&v7, 0xCu);
    }
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_1001E7364(void *a1, uint64_t *a2)
{
  id v42 = a1;
  dispatch_get_global_queue(-2, 0);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  uint64_t v47 = 0;
  uint64_t v48 = (uint64_t)&v47;
  uint64_t v49 = 0x2020000000;
  uint64_t v50 = 0;
  dispatch_semaphore_t v4 = dispatch_semaphore_create(0);
  dispatch_time_t v5 = dispatch_time(0, 30000000000);
  uint64_t v43 = 0;
  CFStringRef v44 = &v43;
  uint64_t v45 = 0x2020000000;
  uint64_t v46 = 0;
  *(void *)long long context = _NSConcreteStackBlock;
  *(void *)&context[8] = 3221225472;
  *(void *)&context[16] = sub_1001E7B54;
  CFStringRef v53 = &unk_100307940;
  CFStringRef v55 = &v43;
  __int16 v56 = &v47;
  id v6 = v4;
  id v54 = v6;
  int v7 = objc_retainBlock(context);
  SOSCloudKeychainGetAllObjectsFromCloud();
  dispatch_semaphore_wait(v6, v5);
  uint64_t v8 = v44;
  char v9 = (const void *)v44[3];
  if (v9)
  {
    if (!a2 || (CFRetain((CFTypeRef)v44[3]), *a2 = (uint64_t)v9, uint64_t v8 = v44, (v9 = (const void *)v44[3]) != 0))
    {
      v8[3] = 0;
      CFRelease(v9);
    }
  }
  CFDictionaryRef v10 = *(const __CFDictionary **)(v48 + 24);

  _Block_object_dispose(&v43, 8);
  _Block_object_dispose(&v47, 8);

  if (v10)
  {
    id v11 = v42;
    CFMutableSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
    id v13 = [v11 trust];
    [v13 trustedCircle];
    sub_1001EEC4C(v11);

    *(void *)long long context = _NSConcreteStackBlock;
    *(void *)&context[8] = 3221225472;
    *(void *)&context[16] = sub_1001E7C90;
    CFStringRef v53 = &unk_1003085A8;
    id v54 = Mutable;
    SOSCircleForEachActiveValidPeer();

    id v14 = v11;
    CFMutableSetRef v15 = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
    uint64_t v16 = [v14 trust];

    [v16 trustedCircle];
    *(void *)long long context = _NSConcreteStackBlock;
    *(void *)&context[8] = 3221225472;
    *(void *)&context[16] = sub_1001E7CD0;
    CFStringRef v53 = &unk_1003085A8;
    id v54 = v15;
    SOSCircleForEachRetiredPeer();

    char v17 = +[NSMutableArray array];
    CFTypeRef v18 = v17;
    if (Mutable && v15)
    {
      *(void *)long long context = _NSConcreteStackBlock;
      *(void *)&context[8] = 3221225472;
      *(void *)&context[16] = sub_1001E7EA0;
      CFStringRef v53 = &unk_100307680;
      CFStringRef v55 = v15;
      __int16 v56 = (void ***)Mutable;
      id v54 = v17;
      CFDictionaryApplyFunction(v10, (CFDictionaryApplierFunction)sub_1001E7FEC, context);
    }
    else if (!Mutable)
    {
LABEL_16:
      if (v15) {
        CFRelease(v15);
      }
      uint64_t v22 = sub_10000B070("key-cleanup");
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        CFIndex Count = CFDictionaryGetCount(v10);
        id v24 = [v18 count];
        *(_DWORD *)long long context = 134218240;
        *(void *)&context[4] = Count;
        *(_WORD *)&context[12] = 2048;
        *(void *)&context[14] = v24;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "total keys: %lu, cleaning up %lu", context, 0x16u);
      }

      id v25 = sub_10000B070("key-cleanup");
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long context = 138412290;
        *(void *)&context[4] = v18;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "message keys that we should remove! %@", context, 0xCu);
      }

      CFTypeRef v20 = v18;
      id v26 = v3;
      CFStringRef v27 = sub_1001FF568(v14);
      dispatch_semaphore_t v28 = dispatch_semaphore_create(0);
      dispatch_time_t v29 = dispatch_time(0, 30000000000);
      *(void *)long long context = _NSConcreteStackBlock;
      *(void *)&context[8] = 3221225472;
      *(void *)&context[16] = sub_1001E7D10;
      CFStringRef v53 = &unk_100308B28;
      int v30 = v28;
      id v54 = v30;
      BOOL v31 = objc_retainBlock(context);
      SOSCloudKeychainRemoveKeys();

      dispatch_semaphore_wait(v30, v29);
      if (v27) {
        CFRelease(v27);
      }

      id v32 = v14;
      id v33 = +[NSDate date];
      id v34 = [v32 settings];

      [v34 setObject:v33 forKey:@"lastKVSCleanup"];
      uint64_t v35 = +[NSMutableDictionary dictionary];
      Mutableuint64_t Copy = CFStringCreateMutableCopy(kCFAllocatorDefault, 0, @"[");
      double Current = CFAbsoluteTimeGetCurrent();
      *(void *)long long context = _NSConcreteStackBlock;
      *(void *)&context[8] = 3221225472;
      *(void *)&context[16] = sub_1001E7DD4;
      CFStringRef v53 = &unk_100308FD8;
      id v54 = MutableCopy;
      sub_100026140((uint64_t)context, Current);
      CFStringAppend(MutableCopy, @"]");
      [v35 setObject:MutableCopy forKey:kSOSKVSLastCleanupTimestampKey];
      if (MutableCopy) {
        CFRelease(MutableCopy);
      }
      dispatch_semaphore_t v38 = dispatch_semaphore_create(0);
      dispatch_time_t v39 = dispatch_time(0, 30000000000);
      uint64_t v47 = _NSConcreteStackBlock;
      uint64_t v48 = 3221225472;
      uint64_t v49 = (uint64_t)sub_1001E7DDC;
      uint64_t v50 = &unk_100308B28;
      dispatch_semaphore_t v51 = v38;
      uint64_t v40 = v38;
      uint64_t v41 = objc_retainBlock(&v47);
      SOSCloudKeychainPutObjectsInCloud();
      dispatch_semaphore_wait(v40, v39);

      CFRelease(v10);
LABEL_27:

      goto LABEL_28;
    }
    CFRelease(Mutable);
    goto LABEL_16;
  }
  CFTypeRef v19 = sub_10000B070("key-cleanup");
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long context = 0;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "KVS data returned is nil, cleanup complete", context, 2u);
  }

  if (a2)
  {
    CFTypeRef v20 = sub_10000B070("SecError");
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = *a2;
      *(_DWORD *)long long context = 138412290;
      *(void *)&context[4] = v21;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "key-cleanup: SOSAccountCopyObjectsFromCloud hit an error: %@", context, 0xCu);
    }
    goto LABEL_27;
  }
LABEL_28:
}

void sub_1001E7B20(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_start(va1, a2);
  va_start(va, a2);
  uint64_t v3 = va_arg(va1, void);
  uint64_t v5 = va_arg(va1, void);
  uint64_t v6 = va_arg(va1, void);
  uint64_t v7 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

intptr_t sub_1001E7B54(uint64_t a1, CFTypeRef cf, const void *a3)
{
  if (a3)
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 138412290;
      CFTypeRef v12 = a3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "SOSCloudKeychainGetObjectsFromCloud returned error: %@", (uint8_t *)&v11, 0xCu);
    }

    CFRetain(a3);
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = a3;
  }
  if (!cf) {
    goto LABEL_8;
  }
  CFTypeID v7 = CFGetTypeID(cf);
  if (v7 == CFNullGetTypeID())
  {
    CFRelease(cf);
LABEL_8:
    *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
    return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
  }
  uint64_t v8 = *(void *)(*(void *)(a1 + 48) + 8);
  if (*(CFTypeRef *)(v8 + 24) != cf)
  {
    CFRetain(cf);
    char v9 = *(const void **)(v8 + 24);
    if (v9) {
      CFRelease(v9);
    }
    *(void *)(v8 + 24) = cf;
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_1001E7C90(uint64_t a1)
{
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID();
  uint64_t v3 = *(__CFSet **)(a1 + 32);

  CFSetAddValue(v3, PeerID);
}

void sub_1001E7CD0(uint64_t a1)
{
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID();
  uint64_t v3 = *(__CFSet **)(a1 + 32);

  CFSetAddValue(v3, PeerID);
}

intptr_t sub_1001E7D10(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v5 = sub_10000B070("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 138412290;
      uint64_t v8 = a3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "SOSCloudKeychainRemoveKeys returned error: %@", (uint8_t *)&v7, 0xCu);
    }
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_1001E7DD4(uint64_t a1, const __CFString *a2)
{
}

intptr_t sub_1001E7DDC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v5 = sub_10000B070("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 138412290;
      uint64_t v8 = a3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "SOSCloudKeychainPutObjectsInCloud returned error: %@", (uint8_t *)&v7, 0xCu);
    }
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_1001E7EA0(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID())
    {
      int KeyType = SOSKVSKeyGetKeyType();
      if (KeyType == 1)
      {
        SOSKVSKeyParse();
        [*(id *)(a1 + 32) addObject:cf];
        if (cfa) {
          CFRelease(cfa);
        }
      }
      else if (KeyType == 4)
      {
        SOSKVSKeyParse();
        [*(id *)(a1 + 32) addObject:cf];
      }
    }
  }
}

uint64_t sub_1001E7FEC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void sub_1001E8008(void *a1, void *a2, uint64_t a3)
{
  id v5 = a1;
  id v6 = a2;
  int v7 = +[CKKSViewManager manager];
  id v41 = 0;
  uint64_t v8 = [v7 currentTLKsFilteredByPolicy:a3 error:&v41];
  id v9 = v41;

  if (v9)
  {
    CFDictionaryRef v10 = sub_10000B070("piggy");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v54 = v9;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "unable to fetch TLKs: %@", buf, 0xCu);
    }
  }
  else
  {
    BOOL v31 = 0;
    id v34 = v5;
    id v37 = v5;
    id v32 = v8;
    id v11 = v8;
    id v33 = v6;
    id v36 = v6;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    id obj = v11;
    id v12 = [v11 countByEnumeratingWithState:&v43 objects:buf count:16];
    if (v12)
    {
      id v13 = v12;
      uint64_t v14 = *(void *)v44;
      CFMutableSetRef v15 = "piggy";
      uint64_t v35 = *(void *)v44;
      do
      {
        uint64_t v16 = 0;
        id v38 = v13;
        do
        {
          if (*(void *)v44 != v14) {
            objc_enumerationMutation(obj);
          }
          char v17 = *(void **)(*((void *)&v43 + 1) + 8 * (void)v16);
          id v42 = 0;
          CFTypeRef v18 = [v17 ensureKeyLoadedFromKeychain:&v42 keychain:v31];
          id v19 = v42;
          CFTypeRef v20 = v19;
          if (v18) {
            BOOL v21 = v19 == 0;
          }
          else {
            BOOL v21 = 0;
          }
          if (v21)
          {
            id v40 = v19;
            v47[0] = kSecValueData;
            id v23 = [v18 keyMaterial];
            v48[0] = v23;
            v47[1] = kSecAttrServer;
            id v24 = [v17 zoneID];
            id v25 = [v24 zoneName];
            v48[1] = v25;
            v47[2] = kSecAttrAccount;
            [v17 uuid];
            CFStringRef v27 = v26 = v15;
            void v48[2] = v27;
            dispatch_semaphore_t v28 = +[NSDictionary dictionaryWithObjects:v48 forKeys:v47 count:3];
            uint64_t v22 = [v28 mutableCopy];

            CFMutableSetRef v15 = v26;
            [v22 setObject:&__kCFBooleanTrue forKeyedSubscript:@"auth"];
            dispatch_time_t v29 = sub_10000B070(v26);
            if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)uint64_t v49 = 138412290;
              uint64_t v50 = v17;
              _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "sending TLK %@", v49, 0xCu);
            }

            [v37 addObject:v22];
            int v30 = [v17 uuid];
            [v36 addObject:v30];

            uint64_t v14 = v35;
            id v13 = v38;
            CFTypeRef v20 = v40;
          }
          else
          {
            uint64_t v22 = sub_10000B070(v15);
            if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)uint64_t v49 = 138412546;
              uint64_t v50 = v17;
              __int16 v51 = 2112;
              char v52 = v20;
              _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Failed to load TLK %@: %@", v49, 0x16u);
            }
          }

          uint64_t v16 = (char *)v16 + 1;
        }
        while (v13 != v16);
        id v13 = [obj countByEnumeratingWithState:&v43 objects:buf count:16];
      }
      while (v13);
    }

    id v6 = v33;
    id v5 = v34;
    id v9 = v31;
    uint64_t v8 = v32;
  }
}

void sub_1001E8448(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_1001E850C;
  v8[3] = &unk_100307968;
  char v11 = 0;
  id v9 = a3;
  id v10 = v5;
  id v6 = v5;
  id v7 = v9;
  [a2 enumerateObjectsUsingBlock:v8];
}

void sub_1001E850C(uint64_t a1, void *a2)
{
  id v3 = a2;
  CFTypeID v4 = [v3 objectForKeyedSubscript:kSecAttrPath];
  id v5 = [v3 objectForKeyedSubscript:kSecAttrAccount];
  uint64_t v6 = [v3 objectForKey:kSecAttrServer];
  id v7 = (void *)v6;
  if (v4) {
    BOOL v8 = v5 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  BOOL v9 = v8 || v6 == 0;
  if (!v9
    && (([v4 isEqualToString:v5] & 1) != 0 || *(unsigned char *)(a1 + 48))
    && ([*(id *)(a1 + 32) containsObject:v5] & 1) == 0)
  {
    id v10 = [v3 objectForKey:kSecValueData];
    id v11 = [objc_alloc((Class)NSData) initWithBase64EncodedData:v10 options:0];
    if (v11)
    {
      id v12 = v11;
      uint64_t v16 = v10;
      id v13 = sub_10000B070("piggy");
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412546;
        CFTypeRef v20 = v7;
        __int16 v21 = 2112;
        uint64_t v22 = v5;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "fetched TLK %@ with name %@", buf, 0x16u);
      }

      v17[0] = kSecValueData;
      v17[1] = kSecAttrServer;
      v18[0] = v12;
      v18[1] = v7;
      void v17[2] = kSecAttrAccount;
      v18[2] = v5;
      uint64_t v14 = +[NSDictionary dictionaryWithObjects:v18 forKeys:v17 count:3];
      id v15 = [v14 mutableCopy];

      if (*(unsigned char *)(a1 + 48)) {
        [v15 setObject:&__kCFBooleanTrue forKeyedSubscript:@"auth"];
      }
      [*(id *)(a1 + 40) addObject:v15];
      [*(id *)(a1 + 32) addObject:v5];
    }
    else
    {
    }
  }
}

int64_t sub_1001E875C(id a1, NSDictionary *a2, NSDictionary *a3)
{
  CFTypeID v4 = a3;
  id v5 = a2;
  uint64_t v6 = [(NSDictionary *)v5 objectForKeyedSubscript:kSecAttrServer];
  unsigned int v7 = sub_1001E8854(v6);

  BOOL v8 = [(NSDictionary *)v5 objectForKeyedSubscript:@"auth"];

  if (v8) {
    v7 |= 0x3E8u;
  }
  BOOL v9 = [(NSDictionary *)v4 objectForKeyedSubscript:kSecAttrServer];
  unsigned int v10 = sub_1001E8854(v9);

  id v11 = [(NSDictionary *)v4 objectForKeyedSubscript:@"auth"];

  unsigned int v12 = v10 | 0x3E8;
  if (!v11) {
    unsigned int v12 = v10;
  }
  BOOL v13 = v7 > v12;
  int64_t v14 = v7 < v12;
  if (v13) {
    return -1;
  }
  else {
    return v14;
  }
}

uint64_t sub_1001E8854(void *a1)
{
  id v1 = a1;
  if ([v1 isEqualToString:@"Manatee"])
  {
    uint64_t v2 = 5;
  }
  else if ([v1 isEqualToString:@"Engram"])
  {
    uint64_t v2 = 4;
  }
  else if ([v1 isEqualToString:@"AutoUnlock"])
  {
    uint64_t v2 = 3;
  }
  else if ([v1 isEqualToString:@"Health"])
  {
    uint64_t v2 = 2;
  }
  else
  {
    uint64_t v2 = 0;
  }

  return v2;
}

uint64_t sub_1001E88EC(void *a1)
{
  id v1 = a1;
  if ([v1 isEqualToString:@"Manatee"])
  {
    uint64_t v2 = 1;
  }
  else if ([v1 isEqualToString:@"Engram"])
  {
    uint64_t v2 = 2;
  }
  else if ([v1 isEqualToString:@"AutoUnlock"])
  {
    uint64_t v2 = 3;
  }
  else if ([v1 isEqualToString:@"Health"])
  {
    uint64_t v2 = 4;
  }
  else
  {
    uint64_t v2 = 0;
  }

  return v2;
}

uint64_t sub_1001E8984(void *a1)
{
  id v1 = a1;
  [v1 length];
  [v1 length];
  id v2 = v1;
  [v2 bytes];

  ccder_encode_body();

  return ccder_encode_tl();
}

uint64_t sub_1001E8A20(void *a1)
{
  long long v9 = 0u;
  long long v10 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  id v1 = a1;
  id v2 = [v1 countByEnumeratingWithState:&v9 objects:v13 count:16];
  if (v2)
  {
    id v3 = v2;
    uint64_t v4 = *(void *)v10;
    while (2)
    {
      for (CFIndex i = 0; i != v3; CFIndex i = (char *)i + 1)
      {
        if (*(void *)v10 != v4) {
          objc_enumerationMutation(v1);
        }
        uint64_t v6 = *(void **)(*((void *)&v9 + 1) + 8 * i);
        [v6 length];
        [v6 bytes];
        if (!ccder_encode_body())
        {

          uint64_t v7 = 0;
          goto LABEL_11;
        }
      }
      id v3 = [v1 countByEnumeratingWithState:&v9 objects:v13 count:16];
      if (v3) {
        continue;
      }
      break;
    }
  }

  uint64_t v7 = ccder_encode_constructed_tl();
LABEL_11:

  return v7;
}

void sub_1001E8B8C(uint64_t a1, const void *a2)
{
  if (SOSPeerInfoIsCloudIdentity())
  {
    uint64_t v4 = *(__CFArray **)(a1 + 32);
    CFArrayAppendValue(v4, a2);
  }
}

void sub_1001E8BE0(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_10000B070("accountLogState");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (*(unsigned char *)(a1 + 32)) {
      int v5 = 73;
    }
    else {
      int v5 = 105;
    }
    BOOL v6 = *(unsigned char *)(a1 + 33) == 0;
    v8[0] = 67109634;
    if (v6) {
      int v7 = 98;
    }
    else {
      int v7 = 66;
    }
    v8[1] = v5;
    __int16 v9 = 1024;
    int v10 = v7;
    __int16 v11 = 2112;
    uint64_t v12 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Sync: %c%c PeerViews: %@", (uint8_t *)v8, 0x18u);
  }
}

void sub_1001E8CD8(id a1, __CFString *a2)
{
  id v3 = sub_10000B070("accountLogState");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    int v5 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "outstanding views: %@", (uint8_t *)&v4, 0xCu);
  }
}

void sub_1001E8D84(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int IsSessionInAwaitingState = SecOTRSessionIsSessionInAwaitingState();
  int v7 = sub_10000B070("otrtimer");
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  if (IsSessionInAwaitingState)
  {
    if (v8)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "coder is in awaiting state, restarting coder", buf, 2u);
    }

    long long v46 = 0;
    sub_1001FFEA0(a3);
    if (sub_1001FFC14(a3, &v46) == 3)
    {
      __int16 v9 = sub_10000B070("SecError");
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        CFTypeRef v49 = v46;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Attempt to recover coder failed to restart: %@", buf, 0xCu);
      }
    }
    else
    {
      int v10 = sub_10000B070("otrtimer");
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "coder restarted!", buf, 2u);
      }

      uint64_t v11 = *(void *)(a1 + 40);
      if (-[OTSOSActualAdapter sosEnabled]_0()) {
        *(unsigned char *)(v11 + 105) = 1;
      }
      *(unsigned char *)(a2 + 4_Block_object_dispose(&STACK[0x290], 8) = 1;
      sub_100227F7C(*(void *)(a2 + 16), v12, v13, v14, v15, v16, v17, v18);
    }
    id v19 = *(void **)(a1 + 32);
    id v20 = *(id *)(a2 + 16);
    id v21 = v19;
    uint64_t v22 = sub_1001DCC24(v21, @"NegotiationRetryCount");
    if (!v22)
    {
      uint64_t v22 = +[NSMutableDictionary dictionary];
    }
    [v22 objectForKey:v20, v46];
    id v23 = (id)objc_claimAutoreleasedReturnValue();
    id v24 = objc_alloc((Class)NSNumber);
    if (v23)
    {
      id v25 = [v24 initWithInt:[v23 intValue] + 1];
      [v22 setObject:v25 forKey:v20];
      id v26 = sub_10000B070("otr");
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v27 = [v25 intValue];
        *(_DWORD *)long long buf = 67109120;
        LODWORD(v49) = v27;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "OTR negotiation retry count: %d", buf, 8u);
      }
    }
    else
    {
      id v23 = [v24 initWithInt:1];
      [v22 setObject:v23 forKey:v20];
    }
    sub_1001FF4C0(v21, @"NegotiationRetryCount", (uint64_t)v22, 0);

    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a2 + 104), *(const void **)(a2 + 16));
    dispatch_semaphore_t v28 = *(void **)(a2 + 16);
    id v29 = *(id *)(a1 + 32);
    id v30 = v28;
    CFTypeRef cf = 0;
    BOOL v31 = (__CFDictionary *)sub_1001DCC24(v29, @"PeerNegotiationTimeouts");
    if (!v31 || (id v32 = v31, v33 = CFGetTypeID(v31), v33 != CFDictionaryGetTypeID()))
    {
      id v34 = sub_10000B070("otrtimer");
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_33;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v35 = "timeout dictionary doesn't exist";
      id v36 = v34;
      uint32_t v37 = 2;
      goto LABEL_32;
    }
    if (CFDictionaryGetValue(v32, v30))
    {
      CFDictionaryRemoveValue(v32, v30);
      sub_1001FF4C0(v29, @"PeerNegotiationTimeouts", (uint64_t)v32, &cf);
      if (!cf)
      {
LABEL_35:

        dispatch_time_t v39 = *(void **)(a1 + 32);
        id v40 = *(void **)(a2 + 16);
        id v41 = v39;
        id v42 = v40;
        long long v43 = sub_1001DCC24(v41, @"kSOSAccountPeerLastSentTimestamp");
        long long v44 = v43;
        if (v43)
        {
          long long v45 = [v43 objectForKey:v42];
          if (v45)
          {
            [v44 removeObjectForKey:v42];
            sub_1001FF4C0(v41, @"kSOSAccountPeerLastSentTimestamp", (uint64_t)v44, 0);
          }
        }
        return;
      }
      id v34 = sub_10000B070("otrtimer");
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        CFTypeRef v49 = cf;
        uint64_t v35 = "SOSAccountSetValue threw an error for key kSOSAccountPeerNegotiationTimeouts: %@";
LABEL_29:
        id v36 = v34;
        uint32_t v37 = 12;
LABEL_32:
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, v35, buf, v37);
      }
    }
    else
    {
      id v34 = sub_10000B070("otrtimer");
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        CFTypeRef v49 = v30;
        uint64_t v35 = "timeout for peerid: %@, doesn't exist";
        goto LABEL_29;
      }
    }
LABEL_33:

    CFTypeRef v38 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v38);
    }
    goto LABEL_35;
  }
  if (v8)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "time fired but out of negotiation! Not restarting coder", buf, 2u);
  }
}

void sub_1001E92CC(uint64_t a1, uint64_t a2)
{
  id v4 = *(id *)(a2 + 16);
  id v5 = *(id *)(a2 + 96);
  uint64_t v18 = 0;
  BOOL v6 = [v5 accessGroupToNextMessageToSend];
  int v7 = [v6 objectForKey:*(void *)(a1 + 32)];

  if (v7)
  {
    BOOL v8 = sub_10000B070("ratelimit");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412546;
      id v20 = v7;
      __int16 v21 = 2112;
      id v22 = v4;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "SOSPeerRateLimiter timer went off! sending:%@ \n to peer:%@", buf, 0x16u);
    }

    __int16 v9 = [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) kvs_message_transport];
    int v10 = [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) kvs_message_transport];
    unsigned int v11 = [v9 SOSTransportMessageSendMessage:v10 id:v4 messageToSend:v7 err:&v18];

    if (v11) {
      BOOL v12 = v18 == 0;
    }
    else {
      BOOL v12 = 0;
    }
    if (!v12)
    {
      uint64_t v13 = sub_10000B070("ratelimit");
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v20 = v18;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "could not send message: %@", buf, 0xCu);
      }
    }
  }
  uint64_t v14 = [v5 accessGroupRateLimitState];
  id v15 = [objc_alloc((Class)NSNumber) initWithLong:1];
  [v14 setObject:v15 forKey:*(void *)(a1 + 32)];

  uint64_t v16 = [v5 accessGroupToTimer];
  [v16 removeObjectForKey:*(void *)(a1 + 32)];

  uint64_t v17 = [v5 accessGroupToNextMessageToSend];
  [v17 removeObjectForKey:*(void *)(a1 + 32)];
}

CFDictionaryRef sub_1001E9524(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  return sub_100139704(kCFAllocatorDefault, a2, a3, a4, a5, a6, a7, a8, (uint64_t)kSecClass, (uint64_t)kSecClassGenericPassword);
}

uint64_t sub_1001E95F0(void *a1, uint64_t a2, const void **a3, void *a4)
{
  id v7 = a1;
  id v8 = a4;
  CFStringRef v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@-tomb", a2);
  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_1001E96F0;
  v13[3] = &unk_1003085F8;
  id v10 = v7;
  id v14 = v10;
  uint64_t v11 = sub_1001F2BCC(v10, (uint64_t)v9, a3, v13, v8);

  if (v9) {
    CFRelease(v9);
  }

  return v11;
}

uint64_t sub_1001E96F0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = [*(id *)(a1 + 32) peerID];
  uint64_t v6 = sub_100201E3C(a2, (uint64_t)v5, 1u, a3);

  return v6;
}

uint64_t sub_1001E974C(void *a1)
{
  id v1 = a1;
  uint64_t MutableForSOSPeerInfosByID = CFSetCreateMutableForSOSPeerInfosByID();
  id v3 = [v1 trust];
  id v4 = [v3 getCircle:0];

  if (v4)
  {
    [v1 accountKey];
    SOSCircleForEachValidPeer();
  }

  return MutableForSOSPeerInfosByID;
}

void sub_1001E982C(uint64_t a1, const void *a2)
{
  if (sub_1001E9884((int)a2, *(CFTypeRef *)(a1 + 32)))
  {
    id v4 = *(__CFSet **)(a1 + 40);
    CFSetAddValue(v4, a2);
  }
}

uint64_t sub_1001E9884(int a1, CFTypeRef cf2)
{
  if (!cf2 || !kSOSViewKeychainV0)
  {
    if ((CFTypeRef)kSOSViewKeychainV0 != cf2) {
      goto LABEL_6;
    }
    return 0;
  }
  if (CFEqual(kSOSViewKeychainV0, cf2)) {
    return 0;
  }
LABEL_6:
  if (!SOSPeerInfoHasBackupKey()) {
    return 0;
  }

  return SOSPeerInfoIsViewPermitted();
}

uint64_t sub_1001E9908(void *a1, const void *a2, uint64_t a3, const void **a4)
{
  id v7 = a1;
  CFMutableSetRef Mutable = CFSetCreateMutable(0, 0, &kCFTypeSetCallBacks);
  if (sub_100029834((uint64_t)Mutable, a4, @"No backup view set created"))
  {
    CFSetAddValue(Mutable, a2);
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 3221225472;
    v19[2] = sub_1001E9BA8;
    v19[3] = &unk_100307B38;
    id v20 = v7;
    __int16 v21 = a2;
    id v22 = Mutable;
    uint64_t v23 = a3;
    uint64_t v9 = sub_1001E95F0(v20, (uint64_t)a2, a4, v19);
    uint64_t v10 = v9;
    if (a4 && v9 && *a4)
    {
      uint64_t v11 = sub_10000B070("SecError");
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        BOOL v12 = *a4;
        *(_DWORD *)long long buf = 138412290;
        id v25 = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Got Success and Error (dropping error): %@", buf, 0xCu);
      }

      uint64_t v13 = *a4;
      if (*a4)
      {
        *a4 = 0;
        CFRelease(v13);
      }
    }
    if ((v10 & 1) == 0)
    {
      id v14 = sub_10000B070("backupring");
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        if (a4) {
          CFStringRef v15 = (const __CFString *)*a4;
        }
        else {
          CFStringRef v15 = @"No error space.";
        }
        *(_DWORD *)long long buf = 138412546;
        id v25 = a2;
        __int16 v26 = 2112;
        CFStringRef v27 = v15;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Got error setting keybag for backup view '%@': %@", buf, 0x16u);
      }
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
    uint64_t v16 = v20;
  }
  else
  {
    uint64_t v16 = sub_10000B070("backupring");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      if (a4) {
        CFStringRef v17 = (const __CFString *)*a4;
      }
      else {
        CFStringRef v17 = @"No error space.";
      }
      *(_DWORD *)long long buf = 138412546;
      id v25 = a2;
      __int16 v26 = 2112;
      CFStringRef v27 = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Got error setting keybag for backup view '%@': %@", buf, 0x16u);
    }
    uint64_t v10 = 0;
  }

  return v10;
}

void *sub_1001E9BA8(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v6 = [*(id *)(a1 + 32) trust];
  CFSetRef v7 = (const __CFSet *)[v6 copyPeerSetForView:*(void *)(a1 + 40)];

  CFMutableSetRef Mutable = CFSetCreateMutable(0, 0, &kCFTypeSetCallBacks);
  sub_10022F8A0((uint64_t)a2, Mutable);
  context[0] = _NSConcreteStackBlock;
  context[1] = 0x40000000;
  context[2] = sub_10022F9D4;
  context[3] = &unk_100309A40;
  context[4] = a2;
  CFSetApplyFunction(v7, (CFSetApplierFunction)sub_10022F454, context);
  int v9 = sub_1002021DC(a2, (uint64_t)[*(id *)(a1 + 32) fullPeerInfo], *(const void **)(a1 + 48), *(void *)(a1 + 56), a3);
  uint64_t v10 = 0;
  if (a2 && v9)
  {
    CFRetain(a2);
    uint64_t v10 = a2;
  }
  if (v7) {
    CFRelease(v7);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v10;
}

uint64_t sub_1001E9CE0(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_1001E9CF8(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID())
    {
      CFStringRef v5 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@-tomb", cf);
      (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
      if (v5)
      {
        CFRelease(v5);
      }
    }
  }
}

void sub_1001E9DAC(void *a1, void *a2)
{
  id context = a2;
  if ([a1 peerInfo])
  {
    CFSetRef PermittedViews = (const __CFSet *)SOSPeerInfoGetPermittedViews();
    Mutableuint64_t Copy = CFSetCreateMutableCopy(kCFAllocatorDefault, 0, PermittedViews);
    CFSetRemoveValue(MutableCopy, kSOSViewKeychainV0);
    CFSetApplyFunction(MutableCopy, (CFSetApplierFunction)sub_1001E9CE0, context);
    if (MutableCopy) {
      CFRelease(MutableCopy);
    }
  }
}

void *sub_1001E9E58(void *a1, const void *a2, CFTypeRef *a3)
{
  id v5 = a1;
  uint64_t v6 = v5;
  CFSetRef v7 = 0;
  if (v5)
  {
    if (a2)
    {
      id v8 = [v5 trust];
      CFSetRef v7 = [v8 peerInfo];

      if (v7)
      {
        if (SOSPeerInfoHasBackupKey()
          && SOSPeerInfoIsEnabledView()
          && (CFStringRef v9 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@-tomb", a2)) != 0)
        {
          CFStringRef v10 = v9;
          uint64_t v11 = [v6 peerID];
          CFSetRef v7 = (void *)sub_100201E3C((uint64_t)v10, (uint64_t)v11, 1u, (uint64_t)a3);

          CFRelease(v10);
          CFMutableSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
          uint64_t MutableForSOSPeerInfosByID = (const void *)CFSetCreateMutableForSOSPeerInfosByID();
          id v14 = [v6 trust];
          [v14 trustedCircle];
          [v6 accountKey];
          SOSCircleForEachBackupCapablePeerForView();

          CFStringRef v15 = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
          CFSetAddValue(v15, a2);
          CFDataRef v16 = sub_1002024D8(kCFAllocatorDefault, v6, 0);
          if (v16)
          {
            CFStringRef v17 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            CFDictionaryAddValue(v17, bskbRkbgPrefix, v16);
            uint64_t v18 = (const void *)SOSBackupSliceKeyBagCreateWithAdditionalKeys();
            if (v17) {
              CFRelease(v17);
            }
          }
          else
          {
            uint64_t v18 = (const void *)SOSBackupSliceKeyBagCreate();
          }
          if (v18)
          {
            sub_10022F8A0((uint64_t)v7, Mutable);
            sub_1002021DC(v7, (uint64_t)[v6 fullPeerInfo], v15, (uint64_t)v18, (uint64_t)a3);
            sub_1001EBEAC((uint64_t)v7, (uint64_t)[v6 fullPeerInfo], v15, a3);
          }
          else if (v7)
          {
            CFRelease(v7);
            CFSetRef v7 = 0;
          }
          if (v15) {
            CFRelease(v15);
          }
          if (Mutable) {
            CFRelease(Mutable);
          }
          if (MutableForSOSPeerInfosByID) {
            CFRelease(MutableForSOSPeerInfosByID);
          }
          if (v18) {
            CFRelease(v18);
          }
          if (v16) {
            CFRelease(v16);
          }
        }
        else
        {
          CFSetRef v7 = 0;
        }
      }
    }
  }

  return v7;
}

void sub_1001EA14C(uint64_t a1, const void *a2)
{
  CFTypeID v4 = *(__CFSet **)(a1 + 32);
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID();
  CFSetAddValue(v4, PeerID);
  uint64_t v6 = *(__CFSet **)(a1 + 40);

  CFSetAddValue(v6, a2);
}

void sub_1001EA1A8(void *a1)
{
  id v1 = a1;
  id v2 = sub_10000B070("backup");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Updating Backup Rings", buf, 2u);
  }

  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  _DWORD v4[2] = sub_1001EA2A0;
  void v4[3] = &unk_100307A70;
  id v5 = v1;
  id v3 = v1;
  sub_1001E9DAC(v3, v4);
  [v3 setPublicKeyStatus:2 forKey:1];
  [v3 setCircle_rings_retirements_need_attention:1];
}

void sub_1001EA2A0(uint64_t a1, uint64_t a2)
{
  CFTypeRef cf = 0;
  id v3 = *(void **)(a1 + 32);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_1001EA3D4;
  v6[3] = &unk_100307A48;
  id v7 = v3;
  uint64_t v8 = a2;
  sub_1001E95F0(v7, a2, &cf, v6);
  if (cf)
  {
    CFTypeID v4 = sub_10000B070("ring");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      CFTypeRef v11 = cf;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Error during SOSAccountProcessBackupRings (%@)", buf, 0xCu);
    }

    CFTypeRef v5 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v5);
    }
  }
}

void *sub_1001EA3D4(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  return sub_1001E9E58(*(void **)(a1 + 32), *(const void **)(a1 + 40), a3);
}

void sub_1001EA3E0(uint64_t a1, const void *a2)
{
  CFTypeID v4 = *(__CFSet **)(a1 + 32);
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID();
  CFSetAddValue(v4, PeerID);
  uint64_t v6 = *(__CFSet **)(a1 + 40);

  CFSetAddValue(v6, a2);
}

uint64_t sub_1001EA43C(void *a1, const __CFData *a2, uint64_t a3)
{
  id v5 = a1;
  uint64_t v13 = 0;
  id v14 = &v13;
  uint64_t v15 = 0x3032000000;
  CFDataRef v16 = sub_1001EA61C;
  CFStringRef v17 = sub_1001EA62C;
  id v18 = (id)0xAAAAAAAAAAAAAAAALL;
  id v18 = [v5 account];
  if (a2)
  {
    CFDataRef Copy = CFDataCreateCopy(kCFAllocatorDefault, a2);
    [v14[5] setBackup_key:Copy];
  }
  else
  {
    [v14[5] setBackup_key:0];
  }
  id v7 = (void *)v14[5];
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 3221225472;
  v12[2] = sub_1001EA634;
  v12[3] = &unk_100307A98;
  void v12[4] = &v13;
  v12[5] = a2;
  uint64_t v8 = sub_1001F0E0C(v7, @"Backup public key", a3, v12);
  if (v8)
  {
    [(id)v14[5] setPublicKeyStatus:1 forKey:1];
    CFStringRef v9 = sub_10000B070("devRecovery");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CFTypeRef v11 = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Processing backup rings since we got a BackupKey", v11, 2u);
    }

    sub_1001EA1A8((void *)v14[5]);
  }
  _Block_object_dispose(&v13, 8);

  return v8;
}

void sub_1001EA600(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001EA61C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1001EA62C(uint64_t a1)
{
}

uint64_t sub_1001EA634(uint64_t a1)
{
  id v1 = [[*(id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) backup_key];

  if (v1)
  {
    id v2 = (const void *)SOSCopyIDOfDataBufferWithLength();
    id v3 = sub_10000B070("backup");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 138412290;
      uint64_t v8 = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Setting peerInfo backupKey to %@", (uint8_t *)&v7, 0xCu);
    }

    if (v2) {
      CFRelease(v2);
    }
    SOSPeerInfoV2DictionarySetValue();
  }
  else
  {
    CFTypeID v4 = sub_10000B070("backup");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Setting peerInfo backupKey to NULL", (uint8_t *)&v7, 2u);
    }

    SOSPeerInfoV2DictionaryRemoveValue();
  }
  id v5 = sub_10000B070("backup");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v7) = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Changed BackupKey for PeerInfo", (uint8_t *)&v7, 2u);
  }

  return 1;
}

void sub_1001EA7F8(uint64_t a1, const void *a2, const void *a3)
{
}

uint64_t sub_1001EA800(uint64_t a1, const void *a2)
{
  uint64_t result = sub_1001E9908(*(void **)(a1 + 32), a2, *(void *)(a1 + 48), *(const void ***)(a1 + 56));
  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8);
  if (*(unsigned char *)(v4 + 24)) {
    char v5 = result;
  }
  else {
    char v5 = 0;
  }
  *(unsigned char *)(v4 + 24) = v5;
  return result;
}

uint64_t sub_1001EA844(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void sub_1001EA860(uint64_t a1, const void *a2)
{
  if (sub_1001E9884(*(void *)(a1 + 48), a2))
  {
    CFSetRef v4 = (const __CFSet *)sub_1001E974C(*(void **)(a1 + 32));
    char v5 = *(uint64_t **)(a1 + 56);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    id context = _NSConcreteStackBlock;
    uint64_t v21 = 3221225472;
    id v22 = (void (*)(void ***, const void *))sub_1001EAAD8;
    uint64_t v23 = &unk_100308DB0;
    id v24 = v5;
    CFMutableArrayRef v25 = Mutable;
    CFSetApplyFunction(v4, (CFSetApplierFunction)sub_1001E9CE0, &context);
    int v7 = *(void **)(a1 + 32);
    uint64_t v8 = *(const void ***)(a1 + 64);
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472;
    CFDataRef v16 = sub_1001EAB74;
    CFStringRef v17 = &unk_1003079F8;
    id v18 = v7;
    id v19 = a2;
    id v9 = v18;
    CFStringRef v10 = v15;
    uint64_t v27 = 0;
    dispatch_semaphore_t v28 = &v27;
    uint64_t v29 = 0x2020000000;
    uint64_t v30 = 0;
    id context = _NSConcreteStackBlock;
    uint64_t v21 = 3221225472;
    id v22 = (void (*)(void ***, const void *))sub_1001EAB88;
    uint64_t v23 = &unk_100307B10;
    id v24 = &v27;
    CFMutableArrayRef v25 = Mutable;
    __int16 v26 = v8;
    CFTypeRef v11 = &context;
    BOOL v12 = (const void *)sub_1001E974C(v9);
    v22(v11, v12);

    if (v12) {
      CFRelease(v12);
    }
    uint64_t v13 = v28[3];
    if (v13)
    {
      v16((uint64_t)v10, v28[3], v8);
      id v14 = (const void *)v28[3];
      if (v14)
      {
        v28[3] = 0;
        CFRelease(v14);
      }
    }
    _Block_object_dispose(&v27, 8);

    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v13 != 0;
    if (Mutable) {
      CFRelease(Mutable);
    }
    if (v4) {
      CFRelease(v4);
    }
  }
}

void sub_1001EAABC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1001EAAD8(uint64_t a1, uint64_t a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  _DWORD v4[2] = sub_1001EADFC;
  void v4[3] = &unk_100308DB0;
  CFArrayRef v3 = *(const __CFArray **)(a1 + 32);
  uint64_t v2 = *(void *)(a1 + 40);
  void v4[4] = a2;
  void v4[5] = v2;
  v5.size_t length = CFArrayGetCount(v3);
  v5.id location = 0;
  CFArrayApplyFunction(v3, v5, (CFArrayApplierFunction)sub_1001E9CE0, v4);
}

uint64_t sub_1001EAB74(uint64_t a1, uint64_t a2, const void **a3)
{
  return sub_1001E9908(*(void **)(a1 + 32), *(const void **)(a1 + 40), a2, a3);
}

void sub_1001EAB88(uint64_t a1, CFSetRef theSet)
{
  CFIndex Count = CFSetGetCount(theSet);
  MutableCFDataRef Copy = CFSetCreateMutableCopy(kCFAllocatorDefault, Count, theSet);
  CFArrayRef v6 = *(const __CFArray **)(a1 + 40);
  context[0] = _NSConcreteStackBlock;
  context[1] = 3221225472;
  context[2] = sub_1001EAC84;
  context[3] = &unk_100309D30;
  context[4] = MutableCopy;
  v8.size_t length = CFArrayGetCount(v6);
  v8.id location = 0;
  CFArrayApplyFunction(v6, v8, (CFArrayApplierFunction)sub_1001E9CE0, context);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = SOSBackupSliceKeyBagCreate();
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
}

void sub_1001EAC84(uint64_t a1, CFTypeRef cf)
{
  if (cf && (CFTypeID v3 = CFGetTypeID(cf), v3 == SOSPeerInfoGetTypeID()))
  {
    uint64_t PeerID = SOSPeerInfoGetPeerID();
    CFSetRef v5 = *(const __CFSet **)(a1 + 32);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    void v7[2] = sub_1001EAD94;
    v7[3] = &unk_100308DB0;
    void v7[4] = PeerID;
    v7[5] = v5;
    CFSetApplyFunction(v5, (CFSetApplierFunction)sub_1001E9CE0, v7);
  }
  else
  {
    CFArrayRef v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Peer list contains a non-peerInfo element", buf, 2u);
    }
  }
}

void sub_1001EAD94(uint64_t a1, const void *a2)
{
  CFStringRef PeerID = (const __CFString *)SOSPeerInfoGetPeerID();
  if (PeerID)
  {
    CFStringRef v5 = *(const __CFString **)(a1 + 32);
    if (v5)
    {
      if (CFEqual(PeerID, v5))
      {
        CFArrayRef v6 = *(__CFSet **)(a1 + 40);
        CFSetRemoveValue(v6, a2);
      }
    }
  }
}

void sub_1001EADFC(uint64_t a1)
{
  CFStringRef PeerID = (const __CFString *)SOSPeerInfoGetPeerID();
  CFStringRef v3 = (const __CFString *)SOSPeerInfoGetPeerID();
  if (PeerID && v3 && CFEqual(v3, PeerID))
  {
    CFStringRef v5 = *(const void **)(a1 + 32);
    CFSetRef v4 = *(__CFArray **)(a1 + 40);
    CFArrayAppendValue(v4, v5);
  }
}

void sub_1001EAE68(void *a1)
{
  id v1 = a1;
  uint64_t v2 = [v1 account];
  if (([v2 isInCircle:0] & 1) == 0)
  {
    uint64_t v15 = sub_10000B070("backup");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CFDataRef v16 = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Not currently in circle", v16, 2u);
    }

    goto LABEL_22;
  }
  [v2 peerInfo];
  CFStringRef v3 = (const void *)SOSPeerInfoCopyBackupKey();
  CFSetRef v4 = [v2 backup_key];

  if (!v4)
  {
    if (!v3) {
      goto LABEL_22;
    }
    sub_1001EA43C(v1, 0, 0);
    goto LABEL_21;
  }
  CFStringRef v5 = [v2 backup_key];
  char v6 = SOSBSKBIsGoodBackupPublic();

  if (v6)
  {
    int v7 = [v2 backup_key];
    CFRange v8 = v7;
    if (!v3 || !v7)
    {

      if (v3 == v8) {
        goto LABEL_20;
      }
      goto LABEL_14;
    }
    int v9 = CFEqual(v3, v7);

    if (!v9)
    {
LABEL_14:
      CFTypeRef v11 = sub_10000B070("backupkey");
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)CFDataRef v16 = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Account backup key and peerinforef backup key don't match.  Using account backup key.", v16, 2u);
      }

      [v2 backup_key];
      CFDataRef v12 = (const __CFData *)objc_claimAutoreleasedReturnValue();
      char v13 = sub_1001EA43C(v1, v12, 0);

      if ((v13 & 1) == 0)
      {
        id v14 = sub_10000B070("backupkey");
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)CFDataRef v16 = 138412290;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Failed to setup backup public key in peerInfo from account: %@", v16, 0xCu);
        }
      }
      goto LABEL_20;
    }
LABEL_21:
    CFRelease(v3);
    goto LABEL_22;
  }
  CFStringRef v10 = sub_10000B070("backupkey");
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)CFDataRef v16 = 138412290;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "account backup key isn't valid: %@", v16, 0xCu);
  }

  sub_1001EA43C(v1, 0, 0);
LABEL_20:
  if (v3) {
    goto LABEL_21;
  }
LABEL_22:
}

void sub_1001EB124(uint64_t a1, CFDataRef theData)
{
  CFDataRef v2 = theData;
  if (theData)
  {
    uint64_t v22 = 0;
    uint64_t v23 = &v22;
    uint64_t v24 = 0x2020000000;
    uint64_t v25 = 0;
    id v20 = 0;
    uint64_t v21 = 0;
    uint64_t v18 = 0;
    uint64_t v19 = 0;
    BytePtr = CFDataGetBytePtr(theData);
    CFStringRef v5 = &BytePtr[CFDataGetLength(v2)];
    if ((const UInt8 *)sub_1001EB424(&v21, (uint64_t *)&v20, &v19, &v18) == v5)
    {
      char v6 = v20;
      *(void *)long long buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 3221225472;
      *(void *)&uint8_t buf[16] = sub_1001EB568;
      uint64_t v27 = &unk_100307B60;
      dispatch_semaphore_t v28 = &v22;
      uint64_t v29 = v19;
      uint64_t v30 = v18;
      int v7 = buf;
      CFDataRef v8 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, v6, 4, kCFAllocatorNull);
      int v9 = v7;
      CFStringRef v10 = v9;
      if (v8)
      {
        CFIndex Length = CFDataGetLength(v8);
        CFMutableArrayRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 2 * Length);
        char v13 = CFDataGetBytePtr(v8);
        CFIndex v14 = CFDataGetLength(v8);
        if (v14 >= 1)
        {
          do
          {
            unsigned int v15 = *v13++;
            CFStringAppendFormat(Mutable, 0, @"%02X", v15);
            --v14;
          }
          while (v14);
        }
        (*(void (**)(void *, __CFString *))&buf[16])(v10, Mutable);
        CFRelease(Mutable);

        CFRelease(v8);
      }
      else
      {
        (*(void (**)(unsigned char *, const __CFString *))&buf[16])(v9, @"(null)");
        CFRelease(@"(null)");
      }
      CFDataRef v2 = (const __CFData *)v23[3];
    }
    else
    {
      CFDataRef v2 = 0;
    }
    _Block_object_dispose(&v22, 8);
  }
  CFDataRef v16 = sub_10000B070("circleOps");
  BOOL v17 = os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v17)
    {
      *(_DWORD *)long long buf = 138412546;
      *(void *)&uint8_t buf[4] = a1;
      *(_WORD *)&unsigned char buf[12] = 2112;
      *(void *)&buf[14] = v2;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%@ %@]", buf, 0x16u);
    }

    CFRelease(v2);
  }
  else
  {
    if (v17)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "failed to decode pbkdf2 params", buf, 2u);
    }
  }
}

void sub_1001EB3FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

size_t sub_1001EB424(void *a1, uint64_t *a2, void *a3, void *a4)
{
  ccder_decode_constructed_tl();
  uint64_t v8 = ccder_decode_tl();
  ccder_decode_uint64();
  ccder_decode_uint64();
  int v9 = (const void *)ccder_decode_tl();
  if (CSSMOID_PKCS5_HMAC_SHA1.Length) {
    return 0;
  }
  CFStringRef v10 = v9;
  if (memcmp(CSSMOID_PKCS5_HMAC_SHA1.Data, v9, CSSMOID_PKCS5_HMAC_SHA1.Length) || !v10) {
    return 0;
  }
  if (a2) {
    *a2 = v8;
  }
  if (a1) {
    *a1 = 0;
  }
  size_t result = (size_t)v10 + CSSMOID_PKCS5_HMAC_SHA1.Length;
  if (a3) {
    *a3 = 0;
  }
  if (a4) {
    *a4 = 0;
  }
  return result;
}

CFStringRef sub_1001EB568(void *a1, uint64_t a2)
{
  CFStringRef result = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"<Params: iter: %zd, size: %zd, salt: %@>", a1[5], a1[6], a2);
  *(void *)(*(void *)(a1[4] + 8) + 24) = result;
  return result;
}

uint64_t sub_1001EB5C4(const __CFData *a1, CFDataRef theData)
{
  uint64_t v15 = 0;
  unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
  unint64_t v13 = 0;
  unint64_t v14 = 0;
  CFDataGetBytePtr(theData);
  CFDataGetLength(theData);
  if (!sub_1001EB424(&v16, &v15, &v14, &v13))
  {
    *(void *)&long long v11 = theData;
LABEL_7:
    SOSCreateErrorWithFormat();
    return 0;
  }
  unint64_t v4 = v13;
  if (v13 != 256 || (unint64_t v4 = v16, v16 <= 3) || (unint64_t v4 = v14, v14 >> 4 <= 0xC34))
  {
    *(void *)&long long v11 = v4;
    goto LABEL_7;
  }
  CFDataGetBytePtr(a1);
  CFDataGetLength(a1);
  ccec_get_cp();
  __chkstk_darwin();
  unint64_t v7 = 0;
  do
  {
    uint64_t v8 = (void *)((char *)&v12[v7 / 4] - v6);
    void *v8 = 0xAAAAAAAAAAAAAAAALL;
    v8[1] = 0xAAAAAAAAAAAAAAAALL;
    v7 += 16;
  }
  while (v6 != v7);
  sub_1001EB124(@"SOSUserKeygen generating key for:", theData);
  __chkstk_darwin();
  *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  *(_OWORD *)&v12[-8] = v9;
  long long v11 = v9;
  *(_OWORD *)&v12[-16] = v9;
  *(_OWORD *)&v12[-12] = v9;
  *(_OWORD *)&v12[-24] = v9;
  *(_OWORD *)&v12[-20] = v9;
  *(_OWORD *)&v12[-32] = v9;
  *(_OWORD *)&v12[-28] = v9;
  ccsha256_di();
  ccpbkdf2_hmac();
  v12[1] = 0;
  if (ccrng())
  {
    int key_deterministic = ccec_generate_key_deterministic();
    cc_clear();
    if (!key_deterministic) {
      return sub_1001EB844();
    }
  }
  SOSCreateError();
  return 0;
}

uint64_t sub_1001EB844()
{
  unint64_t v0 = 3 * ((unint64_t)(cczp_bitlen() + 7) >> 3) + 1;
  __chkstk_darwin();
  CFDataRef v2 = (const UInt8 *)&v14 - v1;
  memset((char *)&v14 - v1, 170, v0);
  ccec_x963_export();
  CFDataRef v3 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, v2, v0, kCFAllocatorNull);
  CFDictionaryRef v11 = sub_100139704(kCFAllocatorDefault, v4, v5, v6, v7, v8, v9, v10, (uint64_t)kSecValueData, (uint64_t)v3);
  uint64_t v12 = SecKeyCreateFromAttributeDictionary();
  CFRelease(v11);
  CFRelease(v3);
  cc_clear();
  return v12;
}

uint64_t sub_1001EB9C0(uint64_t a1, const __CFSet *a2, uint64_t a3, uint64_t a4, uint64_t a5, const void *a6, uint64_t a7, uint64_t a8)
{
  if (a6)
  {
    if (sub_10022F6B4(*(const __CFDictionary **)(a4 + 24), a3))
    {
      SOSCreateError();
      return 1;
    }
    else if (sub_10023000C(a4))
    {
      return 0;
    }
    else
    {
      if (a1)
      {
        SOSFullPeerInfoGetPeerInfo();
        CFStringRef PeerID = (const void *)SOSPeerInfoGetPeerID();
        CFSetRef v16 = (const __CFSet *)sub_10022F800(a4);
        uint64_t v33 = 0;
        id v34 = &v33;
        uint64_t v35 = 0x2020000000;
        LOBYTE(v36) = 1;
        id context = _NSConcreteStackBlock;
        uint64_t v25 = 3221225472;
        __int16 v26 = sub_1001EBD28;
        uint64_t v27 = &unk_1003087F0;
        dispatch_semaphore_t v28 = &v33;
        uint64_t PermittedViews = SOSPeerInfoGetPermittedViews();
        CFSetApplyFunction(v16, (CFSetApplierFunction)sub_1001EBE48, &context);
        BOOL v17 = *((unsigned char *)v34 + 24) != 0;
        _Block_object_dispose(&v33, 8);
        BOOL v18 = sub_10022F8E8(a4, PeerID);
      }
      else
      {
        BOOL v18 = 0;
        BOOL v17 = 0;
      }
      if (v17 || !v18) {
        int v19 = 0;
      }
      else {
        int v19 = 11;
      }
      if (!v17 || v18) {
        int v20 = v19;
      }
      else {
        int v20 = 10;
      }
      if (v20 == 11)
      {
        SOSCreateError();
        return 11;
      }
      else if (v20 == 10)
      {
        SOSCreateError();
        return 10;
      }
      else
      {
        uint64_t v21 = sub_10022F800(a4);
        if (!v21) {
          return 9;
        }
        uint64_t v33 = 0;
        id v34 = &v33;
        uint64_t v35 = 0x2020000000;
        LOBYTE(v36) = 1;
        id context = _NSConcreteStackBlock;
        uint64_t v25 = 3221225472;
        __int16 v26 = sub_1001EBD60;
        uint64_t v27 = &unk_100307B60;
        uint64_t PermittedViews = (uint64_t)a2;
        uint64_t v30 = v21;
        dispatch_semaphore_t v28 = &v33;
        sub_10022FAE4(a4, (uint64_t)&context);
        int v22 = *((unsigned __int8 *)v34 + 24);
        _Block_object_dispose(&v33, 8);
        if (v22)
        {
          uint64_t v33 = 0;
          id v34 = &v33;
          uint64_t v35 = 0x2000000000;
          int v36 = 4;
          id context = _NSConcreteStackBlock;
          uint64_t v25 = 0x40000000;
          __int16 v26 = sub_10020AEF8;
          uint64_t v27 = &unk_100308A10;
          uint64_t v30 = a6;
          uint64_t v31 = a8;
          uint64_t v32 = a7;
          dispatch_semaphore_t v28 = &v33;
          uint64_t PermittedViews = a4;
          CFSetApplyFunction(a2, (CFSetApplierFunction)sub_10020B060, &context);
          uint64_t v14 = *((unsigned int *)v34 + 6);
          _Block_object_dispose(&v33, 8);
        }
        else
        {
          return 9;
        }
      }
    }
  }
  else
  {
    SOSCreateError();
    return 3;
  }
  return v14;
}

void sub_1001EBD10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001EBD28(uint64_t a1, const void *a2)
{
  uint64_t result = CFSetContainsValue(*(CFSetRef *)(a1 + 40), a2);
  if (!result) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
  }
  return result;
}

void sub_1001EBD60(uint64_t a1)
{
  uint64_t v2 = SOSPeerInfoSetFindByID();
  if (v2)
  {
    CFSetRef v3 = *(const __CFSet **)(a1 + 48);
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472;
    _DWORD v4[2] = sub_1001EBE10;
    void v4[3] = &unk_1003087F0;
    void v4[4] = *(void *)(a1 + 32);
    void v4[5] = v2;
    CFSetApplyFunction(v3, (CFSetApplierFunction)sub_1001EBE48, v4);
  }
  else
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
  }
}

uint64_t sub_1001EBE10(uint64_t a1)
{
  uint64_t result = SOSPeerInfoIsViewPermitted();
  if ((result & 1) == 0) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
  }
  return result;
}

uint64_t sub_1001EBE48(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_1001EBE60(const void *a1, const void *a2)
{
  uint64_t v3 = sub_10022FBC4(a1, 1);
  uint64_t v4 = v3;
  if (v3 && a2) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v3 + 16), @"LastModifier", a2);
  }
  return v4;
}

void sub_1001EBEAC(uint64_t a1, uint64_t a2, const void *a3, CFTypeRef *a4)
{
  SOSFullPeerInfoGetPeerInfo();
  CFStringRef PeerID = (const void *)SOSPeerInfoGetPeerID();
  uint64_t v8 = SOSFullPeerInfoCopyDeviceKey();
  int v9 = (__SecKey *)v8;
  if (v8 && PeerID)
  {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), @"LastModifier", PeerID);
    if (sub_10022F858(a1, a3)) {
      sub_10023041C(a1, v9, a4);
    }
  }
  else if (!v8)
  {
    return;
  }

  CFRelease(v9);
}

void sub_1001EBF74(void *a1, uint64_t a2)
{
  CFDictionaryRef v3 = (const __CFDictionary *)sub_1001DCC24(a1, @"PeerNegotiationTimeouts");
  if (!v3 || (CFDictionaryRef v4 = v3, v5 = CFGetTypeID(v3), v5 != CFDictionaryGetTypeID()))
  {
    int v7 = sub_10000B070("otrtimer");
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
LABEL_10:

      int64_t v9 = 0;
      goto LABEL_11;
    }
    *(_WORD *)long long buf = 0;
LABEL_9:
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "deadline value not available yet", buf, 2u);
    goto LABEL_10;
  }
  CFArrayRef Value = (void *)CFDictionaryGetValue(v4, *(const void **)(a2 + 16));
  int v7 = sub_10000B070("otrtimer");
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  if (!Value)
  {
    if (!v8) {
      goto LABEL_10;
    }
    *(_WORD *)long long buf = 0;
    goto LABEL_9;
  }
  if (v8)
  {
    *(_DWORD *)long long buf = 67109120;
    LODWORD(v20) = [Value intValue];
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "decided to wait %d before restarting negotiation", buf, 8u);
  }

  int64_t v9 = 1000000000 * (int)[Value intValue];
LABEL_11:
  uint64_t v10 = *(void *)(a2 + 16);
  if (v10) {
    CFRetain(*(CFTypeRef *)(a2 + 16));
  }
  CFDictionaryRef v11 = sub_10000B070("otrtimer");
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    uint64_t v20 = a2;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "setting timer for peer: %@", buf, 0xCu);
  }

  uint64_t v12 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, (dispatch_queue_t)&_dispatch_main_q);
  dispatch_time_t v13 = dispatch_time(0, v9);
  dispatch_source_set_timer(v12, v13, 0xFFFFFFFFFFFFFFFFLL, 0);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 3221225472;
  handler[2] = sub_1001EC284;
  handler[3] = &unk_1003093A8;
  handler[4] = v10;
  dispatch_source_set_event_handler(v12, handler);
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472;
  void v17[2] = sub_1001EC3E0;
  void v17[3] = &unk_1003093A8;
  void v17[4] = v10;
  dispatch_source_set_cancel_handler(v12, v17);
  dispatch_resume(v12);
  uint64_t v14 = v12;
  id v15 = *(id *)(a2 + 104);
  if (!v15) {
    id v15 = objc_alloc_init((Class)NSMutableDictionary);
  }
  [v15 setObject:v14 forKey:*(void *)(a2 + 16)];
  id v16 = v15;
  *(void *)(a2 + 104) = v16;
}

void sub_1001EC284(uint64_t a1)
{
  uint64_t v2 = sub_10000B070("otrtimer");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v4[0]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "otrTimerFired fired", (uint8_t *)v4, 2u);
  }

  void v4[4] = *(void *)(a1 + 32);
  CFTypeRef v5 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  _DWORD v4[2] = sub_10022CE6C;
  void v4[3] = &unk_100309158;
  sub_100220170(&v5, v4);
  if (v5)
  {
    CFDictionaryRef v3 = sub_10000B070("SecError");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      CFTypeRef v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "error resetting otr negotation: %@", buf, 0xCu);
    }
  }
}

void sub_1001EC3E0(uint64_t a1)
{
  uint64_t v1 = *(const void **)(a1 + 32);
  if (v1) {
    CFRelease(v1);
  }
}

uint64_t sub_1001EC3F0(void *a1, uint64_t a2)
{
  id v3 = a1;
  id v4 = [v3 accountKey];
  CFTypeRef v5 = [v3 accountKeyDerivationParameters];
  sub_1001ED5D4((uint64_t)v4);
  der_sizeof_data_or_null();
  CFIndex v6 = ccder_sizeof();

  CFMutableArrayRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
  CFDataSetLength(Mutable, v6);
  id v8 = [v3 accountKey];
  int64_t v9 = [v3 accountKeyDerivationParameters];
  CFDataGetMutableBytePtr(Mutable);
  CFDataGetMutableBytePtr(Mutable);
  CFDataGetLength(Mutable);
  der_encode_data_or_null();
  sub_1001ED630((uint64_t)v8);
  uint64_t v10 = ccder_encode_constructed_tl();

  if (v10)
  {
    CFDictionaryRef v11 = [v3 key_transport];
    uint64_t v12 = [v3 key_transport];
    unsigned __int8 v13 = [v11 SOSTransportKeyParameterPublishCloudParameters:v12 data:Mutable err:a2];

    if (v13)
    {
      uint64_t v14 = 1;
      if (!Mutable) {
        goto LABEL_9;
      }
      goto LABEL_8;
    }
    SOSCreateErrorWithFormat();
  }
  else
  {
    SOSCreateError();
  }
  uint64_t v14 = 0;
  if (Mutable) {
LABEL_8:
  }
    CFRelease(Mutable);
LABEL_9:

  return v14;
}

BOOL sub_1001EC5D4(int a1, CFDataRef theData)
{
  CFDataGetBytePtr(theData);
  CFDataGetBytePtr(theData);
  CFDataGetLength(theData);
  ccder_decode_sequence_tl();
  sub_1001ED6A4();
  uint64_t v3 = der_decode_data_or_null();
  BytePtr = CFDataGetBytePtr(theData);
  return v3 == (void)&BytePtr[CFDataGetLength(theData)];
}

void sub_1001EC6B8(void *a1)
{
  if (dword_10035D330 > 0)
  {
    --dword_10035D330;
    return;
  }
  id v12 = [a1 account];
  if (sub_1001EC934(v12, 0))
  {
    uint64_t v1 = [v12 kvs_message_transport];
    id v2 = [v1 SOSTransportMessageGetEngine];

    if (!-[OTSOSActualAdapter sosEnabled]_0())
    {
LABEL_17:
      dword_10035D330 = 20;
      goto LABEL_18;
    }
    CFTypeRef cf = 0;
    uint64_t v3 = sub_10000B070("engineLogState");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Start", buf, 2u);
    }

    if (v2)
    {
      uint64_t v4 = sub_100105650((uint64_t)v2, (uint64_t)&cf);
      if (v4)
      {
        CFTypeRef v5 = (const void *)v4;
        SOSCCForEachEngineStateAsStringFromArray();
LABEL_10:
        CFTypeRef v6 = cf;
        if (cf)
        {
          CFTypeRef cf = 0;
          CFRelease(v6);
        }
        if (v5) {
          CFRelease(v5);
        }
        CFTypeRef v7 = sub_10000B070("engineLogState");
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Finish", buf, 2u);
        }

        goto LABEL_17;
      }
      id v8 = sub_10000B070("engineLogState");
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        CFTypeRef v15 = cf;
        int64_t v9 = "No engine peers: %@\n";
        uint64_t v10 = v8;
        uint32_t v11 = 12;
        goto LABEL_25;
      }
    }
    else
    {
      id v8 = sub_10000B070("engineLogState");
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        int64_t v9 = "No Engine Available";
        uint64_t v10 = v8;
        uint32_t v11 = 2;
LABEL_25:
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v9, buf, v11);
      }
    }

    CFTypeRef v5 = 0;
    goto LABEL_10;
  }
LABEL_18:
}

id sub_1001EC934(void *a1, uint64_t a2)
{
  id v2 = [a1 isInCircle:a2];
  if ((v2 & 1) == 0)
  {
    uint64_t v3 = sub_10000B070("account-sync");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CFTypeRef v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Not performing requested sync operation: not in circle yet", v5, 2u);
    }
  }
  return v2;
}

CFMutableSetRef sub_1001EC9B8(void *a1, const __CFSet *a2)
{
  id v3 = a1;
  CFMutableSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  CFTypeRef v5 = [v3 account];
  unsigned int v6 = sub_1001EC934(v5, 0);

  if (v6)
  {
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472;
    _DWORD v8[2] = sub_1001ECAB4;
    v8[3] = &unk_100307F98;
    id v9 = v3;
    CFMutableSetRef v10 = Mutable;
    CFSetApplyFunction(a2, (CFSetApplierFunction)sub_1001ECED8, v8);
  }
  return Mutable;
}

void sub_1001ECAB4(uint64_t a1, CFTypeRef cf)
{
  if (!cf || (v2 = cf, CFTypeID v4 = CFGetTypeID(cf), v4 != CFStringGetTypeID()))
  {
    CFTypeRef v2 = 0;
    CFTypeRef cfa = 0;
    goto LABEL_10;
  }
  CFTypeRef cfa = 0;
  id v5 = *(id *)(a1 + 32);
  CFTypeRef v24 = 0;
  unsigned int v6 = [v5 account];
  if ((sub_1001EC934(v6, (uint64_t)&cfa) & 1) == 0)
  {

    goto LABEL_10;
  }
  CFTypeRef v7 = sub_10000B070("account-sync");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = v2;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Syncing with KVS capable peer: %@", buf, 0xCu);
  }

  CFMutableSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  CFSetAddValue(Mutable, v2);
  id v9 = [v5 account];
  *(void *)long long buf = 0;
  if (!sub_1001EC934(v9, (uint64_t)&v24)) {
    goto LABEL_30;
  }
  CFMutableSetRef v10 = [v9 kvs_message_transport];
  uint32_t v11 = [v9 kvs_message_transport];
  unsigned __int8 v12 = [v10 SOSTransportMessageSyncWithPeers:v11 p:Mutable err:buf];

  if (v12)
  {
    LODWORD(v13) = 1;
    goto LABEL_31;
  }
  unsigned __int8 v13 = *(__CFError **)buf;
  if (!*(void *)buf) {
    goto LABEL_31;
  }
  if (CFErrorGetCode(*(CFErrorRef *)buf) == 1032)
  {
    CFErrorDomain Domain = CFErrorGetDomain(v13);
    if (Domain && kSOSErrorDomain)
    {
      if (!CFEqual(Domain, kSOSErrorDomain)) {
        goto LABEL_27;
      }
LABEL_24:
      uint64_t v20 = sub_10000B070("account-sync");
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v25 = 0;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Arming account to update SOSEngine with current trusted peers", v25, 2u);
      }

      [v9 setEngine_peer_state_needs_repair:1];
      goto LABEL_27;
    }
    if (Domain == (CFErrorDomain)kSOSErrorDomain) {
      goto LABEL_24;
    }
  }
LABEL_27:
  if (!*(void *)buf)
  {
LABEL_30:
    LODWORD(v13) = 0;
    goto LABEL_31;
  }
  if (v24)
  {
    CFRelease(*(CFTypeRef *)buf);
    goto LABEL_30;
  }
  LODWORD(v13) = 0;
  CFTypeRef v24 = *(CFTypeRef *)buf;
LABEL_31:

  uint64_t v21 = sub_10000B070("account-sync");
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    int v22 = "failed";
    if (v13) {
      int v22 = "succeeded";
    }
    *(_DWORD *)long long buf = 136315394;
    *(void *)&uint8_t buf[4] = v22;
    __int16 v27 = 2112;
    CFTypeRef v28 = v24;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "KVS sync %s. (%@)", buf, 0x16u);
  }

  if (Mutable) {
    CFRelease(Mutable);
  }
  if (!v24)
  {

    if (v13) {
      goto LABEL_44;
    }
LABEL_10:
    uint64_t v14 = sub_10000B070("account-sync");
    if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_13;
    }
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = v2;
    __int16 v27 = 2112;
    CFTypeRef v28 = cfa;
    CFTypeRef v15 = "failed to sync with peer: %@ error: %@";
    id v16 = v14;
    uint32_t v17 = 22;
    goto LABEL_12;
  }
  if (cfa) {
    CFRelease(v24);
  }
  else {
    CFTypeRef cfa = v24;
  }

  if ((v13 & 1) == 0) {
    goto LABEL_10;
  }
LABEL_44:
  CFSetAddValue(*(CFMutableSetRef *)(a1 + 40), v2);
  uint64_t v14 = sub_10000B070("account-sync");
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = v2;
    CFTypeRef v15 = "synced with peer: %@";
    id v16 = v14;
    uint32_t v17 = 12;
LABEL_12:
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, v15, buf, v17);
  }
LABEL_13:

  CFTypeRef v18 = cfa;
  if (cfa)
  {
    CFTypeRef cfa = 0;
    CFRelease(v18);
  }
}

uint64_t sub_1001ECED8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

CFMutableSetRef sub_1001ECEF0(void *a1, const __CFSet *a2, uint64_t a3)
{
  id v5 = a1;
  unsigned int v6 = [v5 account];
  if (sub_1001EC934(v6, a3))
  {
    CFMutableSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
    CFSetRef v8 = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
    if ([v6 peerInfo])
    {
      CFStringRef PeerID = (const void *)SOSPeerInfoGetPeerID();
      MutableCFDataRef Copy = CFSetCreateMutableCopy(kCFAllocatorDefault, 0, a2);
      CFSetRemoveValue(MutableCopy, PeerID);
      v13[0] = _NSConcreteStackBlock;
      v13[1] = 3221225472;
      v13[2] = sub_1001ED0FC;
      v13[3] = &unk_100309CA8;
      id v14 = v6;
      CFSetRef v15 = v8;
      CFMutableSetRef v16 = Mutable;
      CFSetApplyFunction(MutableCopy, (CFSetApplierFunction)sub_1001ECED8, v13);
      CFSetRef v11 = sub_1001EC9B8(v5, v8);
      context[0] = _NSConcreteStackBlock;
      context[1] = 3221225472;
      context[2] = sub_1001ED2C0;
      context[3] = &unk_100309D30;
      context[4] = Mutable;
      CFSetApplyFunction(v11, (CFSetApplierFunction)sub_1001ECED8, context);
      if (v11) {
        CFRelease(v11);
      }
      sub_1001EC6B8(v5);
      if (MutableCopy) {
        CFRelease(MutableCopy);
      }
      if (v8) {
        CFRelease(v8);
      }
    }
    else if (v8)
    {
      CFRelease(v8);
    }
  }
  else
  {
    CFMutableSetRef Mutable = CFSetCreateMutableCopy(kCFAllocatorDefault, 0, a2);
  }

  return Mutable;
}

void sub_1001ED0FC(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v2 = cf;
  CFTypeRef cfa = 0;
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 != CFStringGetTypeID())
    {
      sub_100012A40(-50, (__CFString **)&cfa, @"object %@ is not a string", v2);
      CFTypeRef v2 = 0;
    }
  }
  else
  {
    sub_100012A40(-50, (__CFString **)&cfa, @"object %@ is not a string", 0);
  }
  id v5 = [*(id *)(a1 + 32) trust];
  [v5 trustedCircle];
  if (v2)
  {
    uint64_t v6 = SOSCircleCopyPeerWithID();
    if (v6)
    {
      CFTypeRef v7 = (const void *)v6;
      [*(id *)(a1 + 32) accountKey];
      int HasValidSyncingPeer = SOSCircleHasValidSyncingPeer();
      uint64_t v9 = 48;
      if (HasValidSyncingPeer) {
        uint64_t v9 = 40;
      }
      CFSetAddValue(*(CFMutableSetRef *)(a1 + v9), v2);
      CFRelease(v7);
    }
    else
    {
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 48), v2);
    }
  }
  if (cfa)
  {
    CFMutableSetRef v10 = sub_10000B070("account-sync");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412546;
      CFTypeRef v14 = v2;
      __int16 v15 = 2112;
      CFTypeRef v16 = cfa;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Skipped peer ID: %@ due to %@", buf, 0x16u);
    }

    CFTypeRef v11 = cfa;
    if (cfa)
    {
      CFTypeRef cfa = 0;
      CFRelease(v11);
    }
  }
}

void sub_1001ED2C0(uint64_t a1, const void *a2)
{
}

CFMutableSetRef sub_1001ED2C8(void *a1, uint64_t a2)
{
  id v3 = a1;
  CFTypeID v4 = [v3 account];
  if (sub_1001EC934(v4, a2))
  {
    id v5 = [v3 account];
    uint64_t v6 = [v5 kvs_message_transport];
    id v7 = [v6 SOSTransportMessageGetEngine];

    CFSetRef v8 = (void *)sub_1001052A4((uint64_t)v7);
    id v9 = [objc_alloc((Class)NSSet) initWithArray:v8];
    CFMutableSetRef v10 = sub_1001033EC((uint64_t)v7, (uint64_t)v9, 1, a2);
  }
  else
  {
    CFMutableSetRef v10 = 0;
  }

  return v10;
}

id sub_1001ED3A0(void *a1, uint64_t a2)
{
  id v3 = a1;
  CFTypeID v4 = [v3 account];
  id v5 = [v4 trust];
  id v6 = sub_1001EC934(v4, a2);
  if (v6)
  {
    id v7 = +[NSMutableSet set];
    [v5 trustedCircle];
    [v4 accountKey];
    CFMutableSetRef v10 = v7;
    id v8 = v7;
    SOSCircleForEachValidSyncingPeer();
    [v3 requestSyncWithPeers:v8];
  }
  return v6;
}

id sub_1001ED4C8(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  uint64_t PeerID = SOSPeerInfoGetPeerID();

  return [v1 addObject:PeerID];
}

uint64_t sub_1001ED508(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = ccder_decode_tag();
  uint64_t result = 0;
  if (v4)
  {
    if (a1)
    {
      *a1 = SOSFullPeerInfoCreateFromDER();
      return a3;
    }
  }
  return result;
}

uint64_t sub_1001ED5D4(uint64_t a1)
{
  if (a1) {
    SecKeyCopyPublicBytes();
  }
  return der_sizeof_data_or_null();
}

uint64_t sub_1001ED630(uint64_t a1)
{
  if (a1) {
    SecKeyCopyPublicBytes();
  }
  return der_encode_data_or_null();
}

uint64_t sub_1001ED6A4()
{
  return der_decode_data_or_null();
}

uint64_t sub_1001EE1E8(const void *a1, const void *a2)
{
  uint64_t v3 = sub_10022FBC4(a1, 5);
  uint64_t v4 = v3;
  if (v3 && a2) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v3 + 16), @"LastModifier", a2);
  }
  return v4;
}

uint64_t sub_1001EE234(void *a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  sub_1001EE2BC(a1);
  if (!sub_1001EE444(a1)) {
    return 0;
  }
  id v8 = sub_10020F204(a3, a4);
  if (!v8) {
    return 0;
  }
  id v9 = v8;
  uint64_t v10 = sub_100201F6C(a1, (uint64_t)v8, a2, (uint64_t)a4);
  CFRelease(v9);
  return v10;
}

void sub_1001EE2BC(void *a1)
{
  if (!a1)
  {
    uint64_t v1 = sub_10000B070("SecError");
    if (!os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_18;
    }
    __int16 v8 = 0;
    CFTypeRef v2 = "no ring passed in";
    uint64_t v3 = (uint8_t *)&v8;
LABEL_17:
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, v2, v3, 2u);
    goto LABEL_18;
  }
  if (!a1[2])
  {
    uint64_t v1 = sub_10000B070("SecError");
    if (!os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_18;
    }
    __int16 v7 = 0;
    CFTypeRef v2 = "ring has no unSignedInformation";
    uint64_t v3 = (uint8_t *)&v7;
    goto LABEL_17;
  }
  if (!a1[3])
  {
    uint64_t v1 = sub_10000B070("SecError");
    if (!os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_18;
    }
    __int16 v6 = 0;
    CFTypeRef v2 = "ring has no signedInformation";
    uint64_t v3 = (uint8_t *)&v6;
    goto LABEL_17;
  }
  if (!a1[4])
  {
    uint64_t v1 = sub_10000B070("SecError");
    if (!os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_18;
    }
    __int16 v5 = 0;
    CFTypeRef v2 = "ring has no signatures";
    uint64_t v3 = (uint8_t *)&v5;
    goto LABEL_17;
  }
  if (!a1[5])
  {
    uint64_t v1 = sub_10000B070("SecError");
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v4 = 0;
      CFTypeRef v2 = "ring has no data";
      uint64_t v3 = (uint8_t *)&v4;
      goto LABEL_17;
    }
LABEL_18:
  }
}

BOOL sub_1001EE444(void *a1)
{
  int v1 = sub_10022F62C(a1);
  if (v1 != 5) {
    SOSCreateError();
  }
  return v1 == 5;
}

BOOL sub_1001EE498(void *a1)
{
  id v1 = a1;
  id v2 = sub_1001EE508(v1);
  if (v2)
  {
    uint64_t v3 = [v1 trust];
    [v3 generationSignatureUpdateWith:v1 key:v2];
  }
  return v2 != 0;
}

id sub_1001EE508(void *a1)
{
  id v1 = a1;
  if (![v1 accountPrivateKey]) {
    SOSCreateError();
  }
  id v2 = [v1 accountPrivateKey];

  return v2;
}

void sub_1001EE564(void *a1)
{
  id v1 = a1;
  id v2 = sub_10000B070("circleOps");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int16 v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Purging private account credential", v6, 2u);
  }

  if ([v1 accountPrivateKey]) {
    [v1 setAccountPrivateKey:0];
  }
  uint64_t v3 = [v1 _password_tmp];

  if (v3) {
    [v1 set_password_tmp:0];
  }
  __int16 v4 = [v1 user_private_timer];

  if (v4)
  {
    __int16 v5 = [v1 user_private_timer];
    dispatch_source_cancel(v5);

    [v1 setUser_private_timer:0];
    xpc_transaction_end();
  }
  if (objc_msgSend(v1, "lock_notification_token") != -1)
  {
    notify_cancel([v1 lock_notification_token]);
    [v1 setLock_notification_token:0xFFFFFFFFLL];
  }
}

void sub_1001EE684(void *a1)
{
  id v1 = a1;
  id v2 = [v1 user_private_timer];

  if (v2)
  {
    dispatch_time_t v3 = dispatch_time(0, 600000000000);
    __int16 v4 = sub_10000B070("keygen");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 134217984;
      uint64_t v7 = 10;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Setting private credential purge time to %lld minutes", (uint8_t *)&v6, 0xCu);
    }

    __int16 v5 = [v1 user_private_timer];
    dispatch_source_set_timer(v5, v3, 0xFFFFFFFFFFFFFFFFLL, 0x12A05F200uLL);
  }
}

void sub_1001EE79C(void *a1)
{
  CFDataRef v1 = SecKeyCopyExternalRepresentation((SecKeyRef)[a1 accountPrivateKey], 0);
  CFDataRef v2 = v1;
  if (v1)
  {
    v20[0] = kSecClass;
    v20[1] = kSecAttrAccount;
    v21[0] = kSecClassInternetPassword;
    v21[1] = @"SOSUserCredential";
    v20[2] = kSecAttrIsInvisible;
    v20[3] = kSecAttrAccessible;
    v21[2] = &__kCFBooleanTrue;
    v21[3] = kSecAttrAccessibleWhenUnlocked;
    uint64_t v3 = kSecAttrSysBound;
    v20[4] = kSecAttrAccessGroup;
    void v20[5] = kSecAttrSysBound;
    void v21[4] = @"com.apple.security.sos-usercredential";
    v21[5] = &off_1003268C0;
    v20[6] = kSecValueData;
    v21[6] = v1;
    CFDictionaryRef v4 = +[NSDictionary dictionaryWithObjects:v21 forKeys:v20 count:7];
    OSStatus v5 = SecItemAdd(v4, 0);
    if (v5)
    {
      OSStatus v6 = v5;
      if (v5 != -25299)
      {
        uint64_t v10 = sub_10000B070("circleOps");
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          int v14 = 67109120;
          OSStatus v15 = v6;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Failed to add user private key to keychain: %d", (uint8_t *)&v14, 8u);
        }
        CFDictionaryRef v7 = v4;
        goto LABEL_14;
      }
      v18[0] = kSecClass;
      v18[1] = kSecAttrAccount;
      v19[0] = kSecClassInternetPassword;
      v19[1] = @"SOSUserCredential";
      v18[2] = kSecAttrAccessGroup;
      void v18[3] = kSecUseDataProtectionKeychain;
      v19[2] = @"com.apple.security.sos-usercredential";
      v19[3] = &__kCFBooleanTrue;
      CFDictionaryRef v7 = +[NSDictionary dictionaryWithObjects:v19 forKeys:v18 count:4];

      v16[0] = kSecValueData;
      v16[1] = v3;
      v17[0] = v2;
      v17[1] = &off_1003268C0;
      OSStatus v8 = SecItemUpdate(v7, (CFDictionaryRef)+[NSDictionary dictionaryWithObjects:v17 forKeys:v16 count:2]);
      if (v8)
      {
        OSStatus v9 = v8;
        uint64_t v10 = sub_10000B070("circleOps");
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          int v14 = 67109120;
          OSStatus v15 = v9;
          CFTypeRef v11 = "Failed to update user private key to keychain: %d";
          unsigned __int8 v12 = v10;
          uint32_t v13 = 8;
LABEL_10:
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v11, (uint8_t *)&v14, v13);
          goto LABEL_14;
        }
        goto LABEL_14;
      }
    }
    else
    {
      CFDictionaryRef v7 = v4;
    }
    uint64_t v10 = sub_10000B070("circleOps");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v14) = 0;
      CFTypeRef v11 = "Stored user private key stashed local keychain";
      unsigned __int8 v12 = v10;
      uint32_t v13 = 2;
      goto LABEL_10;
    }
LABEL_14:
  }
}

SecKeyRef sub_1001EEA9C(__CFString **a1)
{
  CFTypeRef result = 0;
  v11[0] = kSecClass;
  v11[1] = kSecAttrAccount;
  v12[0] = kSecClassInternetPassword;
  v12[1] = @"SOSUserCredential";
  v11[2] = kSecAttrAccessGroup;
  v11[3] = kSecReturnData;
  _DWORD v12[2] = @"com.apple.security.sos-usercredential";
  v12[3] = &__kCFBooleanTrue;
  void v11[4] = kSecMatchLimit;
  void v12[4] = kSecMatchLimitOne;
  CFDictionaryRef v2 = +[NSDictionary dictionaryWithObjects:v12 forKeys:v11 count:5];
  uint64_t v3 = SecItemCopyMatching(v2, &result);
  if (v3)
  {
    sub_100012A40(v3, a1, @"Failed fetching account credential: %d", v3);
    SecKeyRef v4 = 0;
  }
  else
  {
    v9[0] = kSecAttrKeyClass;
    v9[1] = kSecAttrKeyType;
    v10[0] = kSecAttrKeyClassPrivate;
    v10[1] = kSecAttrKeyTypeEC;
    CFDictionaryRef v5 = +[NSDictionary dictionaryWithObjects:v10 forKeys:v9 count:2];
    SecKeyRef v4 = SecKeyCreateWithData((CFDataRef)result, v5, (CFErrorRef *)a1);
    CFTypeRef v6 = result;
    if (result)
    {
      CFTypeRef result = 0;
      CFRelease(v6);
    }
  }
  return v4;
}

id sub_1001EEC4C(void *a1)
{
  id v1 = a1;
  if ([v1 accountKey] && (objc_msgSend(v1, "accountKeyIsTrusted") & 1) != 0)
  {
    id v2 = [v1 accountKey];
  }
  else
  {
    SOSCreateError();
    id v2 = 0;
  }

  return v2;
}

uint64_t sub_1001EECBC(void *a1, uint64_t a2, void *a3)
{
  id v4 = a1;
  id PublicFromPrivate = (id)SecKeyCreatePublicFromPrivate();
  id v6 = [v4 accountKey];
  if (PublicFromPrivate && v6)
  {
    if (CFEqual(v6, PublicFromPrivate))
    {
      uint64_t v7 = 1;
LABEL_17:
      CFRelease(PublicFromPrivate);
      goto LABEL_18;
    }
  }
  else if (v6 == PublicFromPrivate)
  {
    uint64_t v7 = 1;
    if (!PublicFromPrivate) {
      goto LABEL_18;
    }
    goto LABEL_17;
  }
  [v4 accountKey];
  OSStatus v8 = (const void *)SOSCopyIDOfKey();
  OSStatus v9 = (const void *)SOSCopyIDOfKey();
  SOSCreateErrorWithFormat();
  uint64_t v10 = sub_10000B070("circleop");
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412546;
    uint32_t v13 = v9;
    __int16 v14 = 2112;
    OSStatus v15 = v8;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Password generated pubkey doesn't match - candidate: %@  known: %@", buf, 0x16u);
  }

  if (a3) {
    *a3 = 0;
  }
  if (v8) {
    CFRelease(v8);
  }
  if (v9) {
    CFRelease(v9);
  }
  uint64_t v7 = 0;
  if (PublicFromPrivate) {
    goto LABEL_17;
  }
LABEL_18:

  return v7;
}

uint64_t sub_1001EEE6C(void *a1, __CFString **a2)
{
  id v3 = a1;
  if (![v3 accountKey] || (objc_msgSend(v3, "accountKeyIsTrusted") & 1) == 0)
  {
    SOSCreateError();
LABEL_12:
    uint64_t v6 = 0;
    goto LABEL_7;
  }
  SecKeyRef v4 = sub_1001EEA9C(a2);
  if (!v4)
  {
    OSStatus v8 = sub_10000B070("circleOps");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)OSStatus v9 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Looked for a stashed private key, didn't find one", v9, 2u);
    }

    goto LABEL_12;
  }
  SecKeyRef v5 = v4;
  uint64_t v6 = sub_1001EECBC(v3, (uint64_t)v4, a2);
  if (v6) {
    sub_1001EEF80(v3, 0, (uint64_t)v5, 1);
  }
  CFRelease(v5);
LABEL_7:

  return v6;
}

void sub_1001EEF80(void *a1, uint64_t a2, uint64_t a3, int a4)
{
  id v7 = a1;
  if ((sub_1001F0B4C(v7) & 1) == 0)
  {
    OSStatus v8 = [v7 trust];
    if ([v8 fullPeerInfo]) {
      SOSFullPeerInfoUpgradeSignatures();
    }
  }
  id v9 = v7;
  id PublicFromPrivate = (const void *)SecKeyCreatePublicFromPrivate();
  if ([v9 accountKey]
    && [v9 accountKeyIsTrusted]
    && CFEqual(PublicFromPrivate, [v9 accountKey]))
  {
    if (PublicFromPrivate) {
      CFRelease(PublicFromPrivate);
    }
  }
  else
  {
    if (a4 && [v9 accountKey]) {
      [v9 setPreviousAccountKey:[v9 accountKey]];
    }
    [v9 setAccountKey:PublicFromPrivate];
    [v9 setAccountKeyIsTrusted:1];
    if (![v9 previousAccountKey]) {
      [v9 setPreviousAccountKey:[v9 accountKey]];
    }
    if (PublicFromPrivate) {
      CFRelease(PublicFromPrivate);
    }
    [v9 accountKey];
    CFTypeRef v11 = (const void *)SOSCopyIDOfKeyWithLength();
    unsigned __int8 v12 = sub_10000B070("circleOps");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = 138412290;
      __int16 v14 = v11;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "trusting new public key: %@", (uint8_t *)&v13, 0xCu);
    }

    if (v11) {
      CFRelease(v11);
    }
    notify_post("com.apple.security.publickeyavailable");
  }

  sub_1001EF18C(v9, a3, a2);
  sub_1001F8090(v9);
}

void sub_1001EF18C(void *a1, uint64_t a2, uint64_t a3)
{
  id v5 = a1;
  if (a2)
  {
    uint64_t v6 = sub_10000B070("circleOps");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "setting new private userKey", buf, 2u);
    }

    [v5 setAccountPrivateKey:a2];
    if (!a3)
    {
      id v7 = sub_10000B070("circleOps");
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "no userKey password to save", buf, 2u);
      }

      [v5 set_password_tmp:0];
      goto LABEL_14;
    }
  }
  else
  {
    OSStatus v8 = sub_10000B070("circleOps");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Purging private entities for userKey", buf, 2u);
    }

    sub_1001EE564(v5);
    if (!a3)
    {
      CFTypeRef v18 = sub_10000B070("circleOps");
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "SOSAccountSetPrivateCredential nothing to save", buf, 2u);
      }
      goto LABEL_17;
    }
  }
  id v9 = sub_10000B070("circleOps");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "temporarily caching userKey password", buf, 2u);
  }

  id v10 = [objc_alloc((Class)NSData) initWithData:a3];
  [v5 set_password_tmp:v10];

LABEL_14:
  CFTypeRef v11 = [v5 user_private_timer];

  if (!v11)
  {
    xpc_transaction_begin();
    unsigned __int8 v12 = [v5 queue];
    dispatch_source_t v13 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v12);
    [v5 setUser_private_timer:v13];

    __int16 v14 = [v5 user_private_timer];
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472;
    handler[2] = sub_1001EF530;
    handler[3] = &unk_100308558;
    id v15 = v5;
    id v23 = v15;
    dispatch_source_set_event_handler(v14, handler);

    *(_DWORD *)long long buf = -1431655766;
    CFTypeRef v16 = [v15 queue];
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 3221225472;
    v19[2] = sub_1001EF5AC;
    v19[3] = &unk_100307B88;
    id v17 = v15;
    id v20 = v17;
    notify_register_dispatch("com.apple.mobile.keybagd.lock_status", (int *)buf, v16, v19);

    [v17 setLock_notification_token:*(unsigned int *)buf];
    sub_1001EE684(v17);
    CFTypeRef v18 = [v17 user_private_timer];
    dispatch_resume(v18);
LABEL_17:

    goto LABEL_18;
  }
  sub_1001EE684(v5);
LABEL_18:
}

void sub_1001EF530(uint64_t a1)
{
  id v2 = sub_10000B070("keygen");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Timing out, purging private account credential", v3, 2u);
  }

  sub_1001EE564(*(void **)(a1 + 32));
}

void sub_1001EF5AC(uint64_t a1)
{
  CFTypeRef v4 = 0;
  *(_DWORD *)long long buf = -1431655766;
  uint64_t v2 = sub_10001AE90(0, buf);
  if (sub_100029664(v2, &v4, @"aks_get_lock_state failed: %x", v2))
  {
    if (buf[0]) {
      sub_1001EE564(*(void **)(a1 + 32));
    }
  }
  else
  {
    id v3 = sub_10000B070("SecError");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      CFTypeRef v6 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Checking for locked after change failed: %@", buf, 0xCu);
    }
  }
}

uint64_t sub_1001EF6A0(void *a1, const __CFData *a2, CFTypeRef *a3)
{
  id v5 = a1;
  if ([v5 accountKey])
  {
    CFTypeRef v6 = [v5 accountKeyDerivationParameters];

    if (v6)
    {
      CFDataRef v7 = [v5 accountKeyDerivationParameters];
      OSStatus v8 = (const void *)sub_1001EB5C4(a2, v7);

      if (v8)
      {
        if (sub_1001EECBC(v5, (uint64_t)v8, a3))
        {

          sub_1001EEF80(v5, (uint64_t)a2, (uint64_t)v8, (int)[v5 accountKeyIsTrusted]);
          CFRelease(v8);
          uint64_t v9 = 1;
          goto LABEL_21;
        }
        CFRelease(v8);
      }
    }
  }

  id v10 = [v5 accountKeyDerivationParameters];

  if (v10)
  {
    CFTypeRef cf = 0;
    CFDataRef v11 = [v5 accountKeyDerivationParameters];
    BOOL v12 = sub_1001EC5D4((int)&cf, v11);

    if (v12)
    {
      sub_1001EB124(@"sosAccountValidatePasswordOrFail", 0);
    }
    else
    {
      dispatch_source_t v13 = sub_10000B070("circleOps");
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        uint64_t v19 = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Failed to retrieve cloud parameters - %@", buf, 0xCu);
      }

      if (a3)
      {
        if (*a3) {
          CFRelease(*a3);
        }
        *a3 = 0;
      }
    }
    CFTypeRef v14 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v14);
    }
  }
  SOSCreateError();
  id v15 = sub_10000B070("circleOps");
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Failed to create correct key with password.  Caching for use with KeyParam refreshes", buf, 2u);
  }

  sub_1001EF18C(v5, 0, (uint64_t)a2);
  uint64_t v9 = 0;
LABEL_21:

  return v9;
}

uint64_t sub_1001EF92C(void *a1, uint64_t a2, const __CFData *a3, CFTypeRef *a4)
{
  id v7 = a1;
  uint64_t v8 = sub_1001EF6A0(v7, a3, a4);
  if (v8)
  {
    sub_1001EE79C(v7);
    sub_1001FF4C0(v7, @"AccountName", a2, 0);
  }
  uint64_t v9 = sub_10000B070("circleop");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CFDataRef v11 = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Setting account.key_interests_need_updating to true in SOSAccountTryUserCredentials", v11, 2u);
  }

  [v7 setKey_interests_need_updating:1];
  return v8;
}

const void *sub_1001EFA00(void *a1)
{
  sub_10022EE8C(a1);
  CFDictionaryRef v2 = (const __CFDictionary *)a1[3];

  return CFDictionaryGetValue(v2, @"Payload");
}

uint64_t sub_1001EFA40(uint64_t a1, __SecKey *a2, const void *a3, uint64_t a4, CFTypeRef *a5)
{
  SOSFullPeerInfoGetPeerInfo();
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID();
  id v10 = (__SecKey *)SOSFullPeerInfoCopyDeviceKey();
  uint64_t v11 = 0;
  if (v10 && PeerID)
  {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), @"LastModifier", PeerID);
    sub_10022EE8C((void *)a1);
    if (!a3)
    {
      uint64_t v11 = 0;
      if (!a2) {
        goto LABEL_8;
      }
      goto LABEL_6;
    }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), @"Payload", a3);
    uint64_t v11 = sub_10023041C(a1, v10, a5);
  }
  if (!a2) {
    goto LABEL_8;
  }
LABEL_6:
  if (a1) {
    sub_100230504(a1, a2, a5);
  }
LABEL_8:
  if (v10) {
    CFRelease(v10);
  }
  return v11;
}

uint64_t sub_1001EFB30(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  SOSFullPeerInfoGetPeerInfo();
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID();
  uint64_t v6 = SOSFullPeerInfoCopyDeviceKey();
  id v7 = (__SecKey *)v6;
  if (v6) {
    BOOL v8 = PeerID == 0;
  }
  else {
    BOOL v8 = 1;
  }
  uint64_t v9 = !v8;
  if (v8)
  {
    if (!v6) {
      return 0;
    }
  }
  else
  {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), @"LastModifier", PeerID);
    sub_100230504(a1, v7, a3);
  }
  CFRelease(v7);
  return v9;
}

uint64_t sub_1001EFBD8(uint64_t a1, __SecKey *a2, uint64_t a3, CFTypeRef *a4)
{
  SOSFullPeerInfoGetPeerInfo();
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID();
  BOOL v8 = (__SecKey *)SOSFullPeerInfoCopyDeviceKey();
  uint64_t v9 = 0;
  if (v8 && PeerID)
  {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), @"LastModifier", PeerID);
    uint64_t v9 = sub_10023041C(a1, v8, a4);
  }
  if (a2 && a1) {
    sub_100230504(a1, a2, a4);
  }
  if (v8) {
    CFRelease(v8);
  }
  return v9;
}

uint64_t sub_1001EFC90(uint64_t a1, __SecKey *a2, uint64_t a3, CFTypeRef *a4)
{
  SOSFullPeerInfoGetPeerInfo();
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID();
  if (sub_10022F8E8(a1, PeerID))
  {
    sub_10022EE8C((void *)a1);
    CFArrayRef Value = (__CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"PeerIDs");
    if (!Value || (v9 = Value, CFTypeID v10 = CFGetTypeID(Value), v10 != CFSetGetTypeID())) {
      uint64_t v9 = 0;
    }
    uint64_t v11 = v9;
LABEL_8:
    CFSetRemoveValue(v11, PeerID);
    if (!PeerID) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  if (sub_10022F714(a1, PeerID))
  {
    sub_10022EE8C((void *)a1);
    uint64_t v11 = (__CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"Applicants");
    goto LABEL_8;
  }
  if (!sub_10022F764(a1, PeerID))
  {
    SOSCreateError();
    return 0;
  }
  sub_10022F7B4(a1, PeerID);
  if (PeerID) {
LABEL_9:
  }
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), @"LastModifier", PeerID);
LABEL_10:
  BOOL v12 = (__SecKey *)SOSFullPeerInfoCopyDeviceKey();
  sub_10023041C(a1, v12, a4);
  if (a2 && a1) {
    sub_100230504(a1, a2, a4);
  }
  if (v12) {
    CFRelease(v12);
  }
  return 1;
}

uint64_t sub_1001EFE08(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  SOSFullPeerInfoGetPeerInfo();
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID();
  id v7 = (__SecKey *)SOSFullPeerInfoCopyDeviceKey();
  if (sub_1001EFF18(a1, PeerID) != 1)
  {
    uint64_t v9 = sub_10000B070("ring");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v11 = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Already associated with ring", v11, 2u);
    }

LABEL_8:
    uint64_t v8 = 0;
    uint64_t result = 0;
    if (!v7) {
      return result;
    }
    goto LABEL_9;
  }
  if (!v7 || !PeerID) {
    goto LABEL_8;
  }
  sub_10022FA6C(a1, PeerID);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), @"LastModifier", PeerID);
  uint64_t v8 = sub_10023041C(a1, v7, a4);
LABEL_9:
  CFRelease(v7);
  return v8;
}

uint64_t sub_1001EFF18(uint64_t a1, const void *a2)
{
  if (sub_10022F8E8(a1, a2)) {
    return 0;
  }
  if (sub_10022F714(a1, a2)) {
    return 2;
  }
  if (sub_10022F764(a1, a2)) {
    return 3;
  }
  return 1;
}

uint64_t sub_1001EFF7C(uint64_t a1, __SecKey *a2, uint64_t a3, CFTypeRef *a4)
{
  SOSFullPeerInfoGetPeerInfo();
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID();
  uint64_t v8 = (__SecKey *)SOSFullPeerInfoCopyDeviceKey();
  uint64_t v9 = 0;
  if (v8 && PeerID)
  {
    sub_100230070(a1);
    sub_10022FA6C(a1, PeerID);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), @"LastModifier", PeerID);
    uint64_t v9 = sub_10023041C(a1, v8, a4);
  }
  if (a2 && a1) {
    sub_100230504(a1, a2, a4);
  }
  if (v8) {
    CFRelease(v8);
  }
  return v9;
}

BOOL sub_1001F0048(uint64_t a1, const void *a2)
{
  if (a2) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 16), @"LastModifier", a2);
  }
  return a2 != 0;
}

uint64_t sub_1001F0090(const void *a1, const void *a2)
{
  uint64_t v3 = sub_10022FBC4(a1, 0);
  uint64_t v4 = v3;
  if (v3 && a2) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(v3 + 16), @"LastModifier", a2);
  }
  return v4;
}

void sub_1001F05A0(uint64_t a1, const void *a2)
{
  if (a2
    && (!SOSPeerInfoIsRetirementTicket()
     || SOSPeerInfoRetireRetirementTicket() && (SOSCircleHasActivePeer() & 1) == 0))
  {
    uint64_t v4 = *(__CFSet **)(a1 + 48);
    CFSetAddValue(v4, a2);
  }
}

void sub_1001F061C(uint64_t a1, const void *a2)
{
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 40), a2);
  uint64_t v4 = [*(id *)(a1 + 32) retirees];
  CFSetRemoveValue(v4, a2);
}

uint64_t sub_1001F067C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

SecKeyRef sub_1001F0694(int a1, uint64_t a2, uint64_t a3, uint64_t a4, CFErrorRef *a5)
{
  int valuePtr = a1;
  SecKeyRef privateKey = 0;
  CFNumberRef v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
  CFDictionaryRef v14 = sub_100139704(kCFAllocatorDefault, v7, v8, v9, v10, v11, v12, v13, (uint64_t)kSecAttrIsPermanent, (uint64_t)kCFBooleanTrue);
  CFDictionaryRef v22 = sub_100139704(kCFAllocatorDefault, v15, v16, v17, v18, v19, v20, v21, (uint64_t)kSecAttrKeyType, (uint64_t)kSecAttrKeyTypeEC);
  if (v14) {
    CFRelease(v14);
  }
  if (v6) {
    CFRelease(v6);
  }
  OSStatus v23 = SecKeyGeneratePair(v22, 0, &privateKey);
  if (v22) {
    CFRelease(v22);
  }
  if (v23)
  {
    CFTypeRef v24 = sub_10000B070("SecError");
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      uint64_t v29 = v23;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "status: %ld", buf, 0xCu);
    }

    if (a5 && !*a5) {
      *a5 = CFErrorCreate(kCFAllocatorDefault, kCFErrorDomainOSStatus, v23, 0);
    }
  }
  return privateKey;
}

void sub_1001F08D8(uint64_t a1, CFDictionaryRef theDict)
{
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(theDict, kSecAttrLabel);
  if (Value)
  {
    CFStringRef v4 = Value;
    if (CFStringHasPrefix(Value, @"Cloud Identity"))
    {
      CFTypeRef result = 0;
      CFDictionaryRef v10 = sub_100139704(kCFAllocatorDefault, (int)kSecReturnRef, (int)kCFBooleanTrue, v5, v6, v7, v8, v9, (uint64_t)kSecMatchLimit, (uint64_t)kSecMatchLimitOne);
      OSStatus v11 = SecItemCopyMatching(v10, &result);
      if (v11)
      {
        OSStatus v12 = v11;
        int v13 = sub_10000B070("iCloudIdentity");
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 67109378;
          LODWORD(v17[0]) = v12;
          WORD2(v17[0]) = 2112;
          *(void *)((char *)v17 + 6) = v4;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Failed query(%d) for %@", buf, 0x12u);
        }
        CFTypeRef v14 = 0;
      }
      else
      {
        CFTypeRef v14 = result;
        int v13 = sub_10000B070("iCloudIdentity");
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          v17[0] = v4;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Got key for label (%@)", buf, 0xCu);
        }
      }

      if (v10) {
        CFRelease(v10);
      }
      if (v14)
      {
        (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
        CFRelease(v14);
      }
    }
  }
}

uint64_t sub_1001F0B34(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_1001F0B4C(void *a1)
{
  id v1 = [a1 trust];
  if ([v1 fullPeerInfo])
  {
    id PublicFromPrivate = (const void *)SecKeyCreatePublicFromPrivate();
    SOSFullPeerInfoGetPeerInfo();
    uint64_t v3 = SOSPeerInfoApplicationVerify();
    if (PublicFromPrivate) {
      CFRelease(PublicFromPrivate);
    }
  }
  else
  {
    uint64_t v3 = 0;
  }

  return v3;
}

uint64_t sub_1001F0BCC(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7 = a1;
  int v8 = a4;
  if (![v7 hasPeerInfo]) {
    goto LABEL_7;
  }
  if (!v8[2](v8, [v7 fullPeerInfo], a3))
  {
    uint64_t v12 = 0;
    goto LABEL_8;
  }
  int v9 = [v7 trust];
  if (![v9 trustedCircle])
  {
    SOSCreateErrorWithFormat();

LABEL_7:
    uint64_t v12 = 1;
    goto LABEL_8;
  }

  CFDictionaryRef v10 = [v7 trust];
  OSStatus v11 = [v7 circle_transport];
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_1001F0D3C;
  v14[3] = &unk_100308CF0;
  uint64_t v16 = a2;
  id v15 = v7;
  uint64_t v12 = (uint64_t)[v10 modifyCircle:v11 err:a3 action:v14];

LABEL_8:
  return v12;
}

uint64_t sub_1001F0D3C(uint64_t a1)
{
  CFDictionaryRef v2 = sub_10000B070("circleChange");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 40);
    int v5 = 138412290;
    uint64_t v6 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Calling SOSCircleUpdatePeerInfo for %@", (uint8_t *)&v5, 0xCu);
  }

  [*(id *)(a1 + 32) peerInfo];
  return SOSCircleUpdatePeerInfo();
}

uint64_t sub_1001F0E0C(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  void v10[2] = sub_1001F0EC0;
  v10[3] = &unk_100307C20;
  id v11 = a4;
  uint64_t v12 = a3;
  id v7 = v11;
  uint64_t v8 = sub_1001F0BCC(a1, a2, a3, v10);

  return v8;
}

uint64_t sub_1001F0EC0(uint64_t a1)
{
  id v3 = *(id *)(a1 + 32);
  uint64_t v1 = SOSFullPeerInfoUpdate();

  return v1;
}

const void *sub_1001F0F6C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFDataRef Copy = (const void *)SOSPeerInfoCreateCopy();
  int v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  if (a3 && v6 && SOSPeerInfoSign())
  {
    id v7 = sub_10000B070("circleOp");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Signed Peerinfo to update", buf, 2u);
    }
  }
  else
  {
    uint64_t v8 = sub_10000B070("circleOp");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CFDictionaryRef v10 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Failed updating PeerInfo", v10, 2u);
    }

    if (Copy)
    {
      CFRelease(Copy);
      return 0;
    }
  }
  return Copy;
}

void sub_1001F109C(uint64_t a1)
{
  id v1 = *(id *)(a1 + 32);
  SOSCircleForEachPeer();
}

CFMutableArrayRef sub_1001F112C(void *a1, uint64_t a2, void *a3)
{
  id v4 = a1;
  int v5 = a3;
  if (sub_1001EEC4C(v4))
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    id v7 = [v4 trust];
    v5[2](v5, [v7 trustedCircle], Mutable);
    CFArrayOfSOSPeerInfosSortByID();
  }
  else
  {
    CFMutableArrayRef Mutable = 0;
  }

  return Mutable;
}

void sub_1001F11E4(uint64_t a1)
{
  [*(id *)(a1 + 32) accountKey];
  if ((SOSPeerInfoApplicationVerify() & 1) == 0)
  {
    CFDictionaryRef v2 = *(__CFArray **)(a1 + 40);
    sub_1001F1248(v2);
  }
}

void sub_1001F1248(__CFArray *a1)
{
  CFDataRef Copy = (const void *)SOSPeerInfoCreateCopy();
  CFArrayAppendValue(a1, Copy);

  CFRelease(Copy);
}

void sub_1001F12A0(uint64_t a1)
{
  id v1 = *(id *)(a1 + 32);
  SOSCircleForEachPeer();
}

void sub_1001F1330(uint64_t a1)
{
  [*(id *)(a1 + 32) accountKey];
  if (SOSPeerInfoApplicationVerify())
  {
    CFDictionaryRef v2 = *(__CFArray **)(a1 + 40);
    sub_1001F1248(v2);
  }
}

void sub_1001F1394(uint64_t a1)
{
  long long v2 = *(_OWORD *)(a1 + 32);
  id v1 = (id)v2;
  SOSCircleForEachPeer();
}

void sub_1001F1434(uint64_t a1, const void *a2)
{
  id v4 = *(const void **)(a1 + 40);
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID();
  if (v4) {
    BOOL v6 = PeerID == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    if (v4 == PeerID) {
      return;
    }
  }
  else if (CFEqual(v4, PeerID))
  {
    return;
  }
  [*(id *)(a1 + 32) accountKey];
  if (SOSPeerInfoApplicationVerify() && (SOSPeerInfoIsRetirementTicket() & 1) == 0)
  {
    uint64_t v8 = *(__CFArray **)(a1 + 48);
    CFArrayAppendValue(v8, a2);
  }
}

void sub_1001F14E4(id a1, __OpaqueSOSCircle *a2, __CFArray *a3)
{
}

void sub_1001F1554(uint64_t a1)
{
}

void sub_1001F155C(id a1, __OpaqueSOSCircle *a2, __CFArray *a3)
{
}

void sub_1001F15CC(uint64_t a1)
{
  if ((SOSPeerInfoVersionHasV2Data() & 1) == 0)
  {
    long long v2 = *(__CFArray **)(a1 + 32);
    sub_1001F1248(v2);
  }
}

void sub_1001F1620(uint64_t a1)
{
  id v1 = *(id *)(a1 + 32);
  SOSCircleForEachPeer();
}

void sub_1001F16B0(uint64_t a1)
{
  if ((SOSPeerInfoVersionHasV2Data() & 1) == 0)
  {
    [*(id *)(a1 + 32) accountKey];
    if (SOSPeerInfoApplicationVerify())
    {
      long long v2 = *(__CFArray **)(a1 + 40);
      sub_1001F1248(v2);
    }
  }
}

void sub_1001F1720(id a1, __OpaqueSOSCircle *a2, __CFArray *a3)
{
}

void sub_1001F1790(uint64_t a1)
{
}

void sub_1001F1798(id a1, __OpaqueSOSCircle *a2, __CFArray *a3)
{
}

void sub_1001F1808(uint64_t a1)
{
}

void sub_1001F1810(id a1, __OpaqueSOSCircle *a2, __CFArray *a3)
{
}

void sub_1001F1820(uint64_t a1)
{
  [*(id *)(a1 + 32) accountKey];
  if (SOSPeerInfoApplicationVerify())
  {
    CFSetRef v2 = (const __CFSet *)SOSPeerInfoCopyEnabledViews();
    uint64_t v3 = *(void *)(a1 + 40);
    context[0] = _NSConcreteStackBlock;
    context[1] = 3221225472;
    context[2] = sub_1001F18E4;
    context[3] = &unk_100309D30;
    context[4] = v3;
    CFSetApplyFunction(v2, (CFSetApplierFunction)sub_1001F18EC, context);
    if (v2) {
      CFRelease(v2);
    }
  }
}

void sub_1001F18E4(uint64_t a1, const void *a2)
{
}

uint64_t sub_1001F18EC(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

id sub_1001F19D4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  BOOL v6 = [*(id *)(a1 + 32) trust];
  id v7 = [v6 encodeToDER:*(void *)(a1 + 32) err:*(void *)(a1 + 40) start:a3 end:a3 + a2];

  return v7;
}

void sub_1001F278C(uint64_t a1, int a2, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFDataGetTypeID())
    {
      int v5 = (const void *)SOSPeerInfoCreateFromData();
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 32), v5);
      if (v5)
      {
        CFRelease(v5);
      }
    }
  }
}

void sub_1001F2824(uint64_t a1, CFTypeRef cf)
{
  if (!cf) {
    return;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 == CFDataGetTypeID())
  {
    int v5 = 0;
  }
  else
  {
    CFTypeID v10 = CFGetTypeID(cf);
    if (v10 != CFArrayGetTypeID()) {
      return;
    }
    CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)cf, 0);
    int v5 = CFArrayGetValueAtIndex((CFArrayRef)cf, 1);
    if (CFArrayGetCount((CFArrayRef)cf) != 2) {
      return;
    }
    if (!ValueAtIndex) {
      return;
    }
    CFTypeID v12 = CFGetTypeID(ValueAtIndex);
    if (v12 != CFDataGetTypeID()) {
      return;
    }
    if (!v5) {
      return;
    }
    CFTypeID v13 = CFGetTypeID(v5);
    if (v13 != CFDataGetTypeID()) {
      return;
    }
  }
  uint64_t v6 = SOSCircleCreateFromData();
  if (!v6) {
    return;
  }
  id v7 = (const void *)v6;
  uint64_t v8 = *(const void **)(a1 + 48);
  Name = (const void *)SOSCircleGetName();
  if (v8 && Name)
  {
    if (!CFEqual(v8, Name)) {
      goto LABEL_19;
    }
LABEL_17:
    [*(id *)(a1 + 32) setTrustedCircle:v7];
    CFRelease(v7);
    if (!v5) {
      return;
    }
    id v7 = (const void *)SOSFullPeerInfoCreateFromData();
    [*(id *)(a1 + 32) setFullPeerInfo:v7];
    if (!v7) {
      return;
    }
    goto LABEL_19;
  }
  if (v8 == Name) {
    goto LABEL_17;
  }
LABEL_19:

  CFRelease(v7);
}

id sub_1001F29B4(uint64_t a1)
{
  sub_100202FC4(*(void **)(a1 + 32));
  CFSetRef v2 = sub_10000B070("circleop");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CFTypeID v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Setting account.key_interests_need_updating to true in SOSAccountCreateFromDER", v4, 2u);
  }

  return [*(id *)(a1 + 32) setKey_interests_need_updating:1];
}

uint64_t sub_1001F2A3C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_1001F2A54(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

id sub_1001F2A70(void *a1, const void *a2)
{
  id v3 = a1;
  id v4 = [v3 trust];

  if (v4)
  {
    int v5 = [v3 trust];
    id v4 = [v5 copyRing:a2 err:0];

    if (v4)
    {
      CFTypeID v6 = CFGetTypeID(v4);
      if (v6 != sub_10022E9CC())
      {
        id v7 = sub_10000B070("SecError");
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          int v11 = 138412290;
          id v12 = v4;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Non ring in ring table: %@, purging!", (uint8_t *)&v11, 0xCu);
        }

        uint64_t v8 = [v3 trust];
        int v9 = (__CFDictionary *)[v8 getRings:0];

        if (v9) {
          CFDictionaryRemoveValue(v9, a2);
        }
        CFRelease(v4);
        id v4 = 0;
      }
    }
  }

  return v4;
}

uint64_t sub_1001F2BCC(void *a1, uint64_t a2, const void **a3, void *a4, void *a5)
{
  id v9 = a1;
  CFTypeID v10 = a4;
  int v11 = a5;
  if (([v9 isInCircle:0] & 1) == 0)
  {
    SOSErrorCreate();
LABEL_12:
    uint64_t v18 = 0;
    goto LABEL_13;
  }
  id v12 = [v9 trust];
  id v13 = [v12 copyRing:a2 err:a3];

  if (!v13)
  {
    id v13 = (id)v10[2](v10, a2, a3);
    if (!v13) {
      goto LABEL_12;
    }
  }
  uint64_t v14 = v11[2](v11, v13, a3);
  if (!v14)
  {
    CFRelease(v13);
    goto LABEL_12;
  }
  id v15 = (const void *)v14;
  uint64_t v16 = [v9 trust];
  int v17 = [v9 circle_transport];
  uint64_t v18 = (uint64_t)[v16 handleUpdateRing:v9 prospectiveRing:v15 transport:v17 userPublicKey:[v9 accountKey] writeUpdate:1 err:a3];

  CFRelease(v13);
  CFRelease(v15);
  if (a3 && v18)
  {
    int v19 = *a3;
    if (*a3)
    {
      *a3 = 0;
      CFRelease(v19);
    }
    uint64_t v18 = 1;
  }
LABEL_13:

  return v18;
}

void sub_1001F431C(uint64_t a1, uint64_t a2)
{
  id v4 = sub_10000B070("acct-txn");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uid_t v5 = getuid();
    if ([*(id *)(a1 + 32) initialInCircle]) {
      CFTypeID v6 = "member";
    }
    else {
      CFTypeID v6 = "non-member";
    }
    id v7 = [*(id *)(a1 + 32) account];
    uint64_t v8 = [v7 SOSMonitorModeSOSIsActiveDescription];
    v9[0] = 67109890;
    v9[1] = v5;
    __int16 v10 = 2080;
    int v11 = v6;
    __int16 v12 = 2112;
    id v13 = v8;
    __int16 v14 = 2112;
    uint64_t v15 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "UID: %d - Finished as:%s %@ v:%@", (uint8_t *)v9, 0x26u);
  }
}

void sub_1001F4448(void *a1)
{
  id v1 = a1;
  CFSetRef v2 = v1;
  if (v1 && [v1 peerInfo])
  {
    [v2 peerInfo];
    CFSetRef v3 = (const __CFSet *)SOSPeerInfoCopyEnabledViews();
    if (sub_1001F7170(v2))
    {
      MutableCFDataRef Copy = v3;
    }
    else
    {
      CFSetRef v5 = (const __CFSet *)sub_1001DCC24(v2, @"pendingEnableViews");
      if (!v5 || (v6 = v5, CFTypeID v7 = CFGetTypeID(v5), v7 != CFSetGetTypeID())) {
        CFSetRef v6 = 0;
      }
      CFSetRef v8 = (const __CFSet *)sub_1001DCC24(v2, @"pendingDisableViews");
      if (!v8 || (v9 = v8, CFTypeID v10 = CFGetTypeID(v8), v10 != CFSetGetTypeID())) {
        CFSetRef v9 = 0;
      }
      MutableCFDataRef Copy = CFSetCreateMutableCopy(kCFAllocatorDefault, 0, v3);
      id context = _NSConcreteStackBlock;
      p_id context = 3221225472;
      uint64_t v14 = (uint64_t)sub_1001F71D0;
      uint64_t v15 = &unk_100309D30;
      CFMutableSetRef v16 = MutableCopy;
      CFSetApplyFunction(v6, (CFSetApplierFunction)sub_1001F7118, &context);
      id context = _NSConcreteStackBlock;
      p_id context = 3221225472;
      uint64_t v14 = (uint64_t)sub_1001F71D8;
      uint64_t v15 = &unk_100309D30;
      CFMutableSetRef v16 = MutableCopy;
      CFSetApplyFunction(v9, (CFSetApplierFunction)sub_1001F7118, &context);
      if (v3) {
        CFRelease(v3);
      }
      if (v6) {
        CFRelease(v6);
      }
      if (v9) {
        CFRelease(v9);
      }
    }
  }
  else
  {
    MutableCFDataRef Copy = 0;
  }

  id context = 0;
  p_id context = (uint64_t)&context;
  uint64_t v14 = 0x2020000000;
  uint64_t v15 = (void *)0xAAAAAAAAAAAAAAAALL;
  if ([v2 getCircleStatus:0] || !MutableCopy)
  {
    uint64_t v15 = 0;
    if (!MutableCopy) {
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v15 = (void *)SOSViewBitmaskFromSet();
  }
  CFRelease(MutableCopy);
LABEL_11:
  if (*(void *)(p_context + 24) != qword_10035D350)
  {
    qword_10035D350 = *(void *)(p_context + 24);
    [v2 setNotifyViewChangeOnExit:1];
  }
  if ([v2 notifyViewChangeOnExit])
  {
    id v11 = v2;
    SOSCachedNotificationOperation();
  }
  _Block_object_dispose(&context, 8);
}

void sub_1001F4734(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001F4750(uint64_t a1, int token, uint64_t a3)
{
  if (a3 && !notify_set_state(token, *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)))
  {
    notify_post(kSOSCCViewMembershipChangedNotification);
    [*(id *)(a1 + 32) setNotifyViewChangeOnExit:0];
  }
  return a3;
}

void sub_1001F4AD0(uint64_t a1, uint64_t a2)
{
  id v4 = sub_10000B070("acct-txn");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uid_t v5 = getuid();
    if ([*(id *)(a1 + 32) initialInCircle]) {
      CFSetRef v6 = "member";
    }
    else {
      CFSetRef v6 = "non-member";
    }
    CFTypeID v7 = [*(id *)(a1 + 32) account];
    CFSetRef v8 = [v7 SOSMonitorModeSOSIsActiveDescription];
    v9[0] = 67109890;
    v9[1] = v5;
    __int16 v10 = 2080;
    id v11 = v6;
    __int16 v12 = 2112;
    id v13 = v8;
    __int16 v14 = 2112;
    uint64_t v15 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "UID: %d - Starting as:%s %@ v:%@", (uint8_t *)v9, 0x26u);
  }
}

uint64_t sub_1001F4EDC(uint64_t a1, int token, uint64_t a3)
{
  if (a3 && !notify_set_state(token, *(void *)(a1 + 40)))
  {
    [*(id *)(*(void *)(a1 + 32) + 16) setNotifyCircleChangeOnExit:0];
    uid_t v5 = sub_10000B070("sosnotify");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CFTypeID v7 = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "posting kSOSCCCircleChangedNotification", v7, 2u);
    }

    notify_post(kSOSCCCircleChangedNotification);
  }
  return a3;
}

void sub_1001F4F90(id a1)
{
  SOSCachedNotificationOperation();
  id v1 = sub_10000B070("sosnotify");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    v2[0] = 67109120;
    v2[1] = qword_10035D338;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "initial last circle status is: %d", (uint8_t *)v2, 8u);
  }
}

BOOL sub_1001F5058(id a1, int a2, BOOL a3)
{
  uint64_t state64 = 0xAAAAAAAAAAAAAAAALL;
  if (!notify_get_state(a2, &state64) && (state64 & 0x8000000000000000) != 0) {
    qword_10035D338 = state64;
  }
  return 1;
}

id sub_1001F5244()
{
  off_10035CAA8();
  id v1 = v0;
  unsigned char *v0 = 1;
  id result = [*(id *)(v2 + 32) performTransaction_Locked:*(unsigned __int8 *)(v2 + 48) action:*(void *)(v2 + 40)];
  *id v1 = 0;
  return result;
}

uint64_t sub_1001F5494(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1001F54A4(void *a1)
{
  id v1 = a1;
  uint64_t v5 = 0;
  CFSetRef v6 = &v5;
  uint64_t v7 = 0x2020000000;
  char v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  _DWORD v4[2] = sub_1001F556C;
  void v4[3] = &unk_100307ED0;
  void v4[4] = &v5;
  sub_100212E90(v1, v4);
  uint64_t v2 = *((unsigned __int8 *)v6 + 24);
  _Block_object_dispose(&v5, 8);

  return v2;
}

void sub_1001F5554(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001F556C(uint64_t a1)
{
  uint64_t result = SOSPeerInfoIsEnabledView();
  if (result) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
  return result;
}

void sub_1001F55B8(void *a1)
{
  id v1 = a1;
  uint64_t v2 = [v1 queue];
  dispatch_assert_queue_V2(v2);

  CFSetRef v3 = [v1 trust];
  [v3 fullPeerInfo];
  [v3 trustedCircle];
  SOSFullPeerInfoGetPeerInfo();
  uint64_t PeerID = SOSPeerInfoGetPeerID();
  if (!PeerID) {
    goto LABEL_4;
  }
  CFDictionaryRef v5 = (const __CFDictionary *)PeerID;
  [v1 accountKey];
  CFMutableArrayRef v6 = 0;
  CFMutableArrayRef Mutable = 0;
  CFDictionaryRef v8 = 0;
  if (SOSPeerInfoApplicationVerify())
  {
    if (SOSPeerInfoIsRetirementTicket())
    {
LABEL_4:
      CFMutableArrayRef v6 = 0;
      CFMutableArrayRef Mutable = 0;
      CFDictionaryRef v8 = 0;
      goto LABEL_5;
    }
    CFMutableArrayRef v6 = 0;
    CFMutableArrayRef Mutable = 0;
    CFDictionaryRef v8 = 0;
    if (!SOSCircleHasPeer()) {
      goto LABEL_5;
    }
    CFSetRef v18 = (const __CFSet *)SOSPeerInfoCopyEnabledViews();
    uint64_t v51 = 0;
    char v52 = &v51;
    uint64_t v53 = 0x2020000000;
    char v54 = -86;
    char v54 = sub_1001F54A4(v1);
    int v19 = SOSPeerInfoSupportsCKKSForAll();
    int v20 = sub_10000B070("engine-notify");
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v21 = @"doesn't support";
      if (v19) {
        CFStringRef v21 = @"supports";
      }
      *(_DWORD *)block = 138412546;
      *(void *)&void block[4] = v5;
      *(_WORD *)&block[12] = 2112;
      *(void *)&block[14] = v21;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Self peer(%@) %@ CKKS For All", block, 0x16u);
    }

    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    CFMutableArrayRef v6 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    v29[0] = _NSConcreteStackBlock;
    v29[1] = 3221225472;
    v29[2] = sub_1001F5D1C;
    v29[3] = &unk_100307EF8;
    id v22 = v1;
    CFMutableArrayRef v32 = Mutable;
    CFMutableArrayRef v33 = v6;
    CFSetRef v34 = v18;
    id v30 = v22;
    uint64_t v31 = &v51;
    char v35 = v19;
    sub_100212E90(v22, v29);
    id v23 = v22;
    if ([v23 getCircleStatus:0]) {
      goto LABEL_42;
    }
    if (sub_1001F7170(v23))
    {
      [v23 peerInfo];
      if (SOSPeerInfoV2DictionaryHasData())
      {
        CFDictionaryRef v24 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        *(void *)block = _NSConcreteStackBlock;
        *(void *)&block[8] = 3221225472;
        *(void *)&block[16] = sub_1001F5FEC;
        long long v58 = &unk_100307F98;
        uint64_t v25 = v23;
        id v59 = v25;
        uint64_t v60 = (uint64_t)v24;
        CFSetApplyFunction(v18, (CFSetApplierFunction)sub_1001F67A0, block);
        id context = _NSConcreteStackBlock;
        uint64_t v37 = 3221225472;
        CFTypeRef v38 = sub_1001F6200;
        dispatch_time_t v39 = &unk_100309C30;
        id v40 = v25;
        id v41 = Mutable;
        CFDictionaryApplyFunction(v24, (CFDictionaryApplierFunction)sub_1001F6508, &context);
        if (v24) {
          CFRelease(v24);
        }

        __int16 v26 = v59;
        goto LABEL_41;
      }
      __int16 v26 = sub_10000B070("backup");
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)block = 0;
        __int16 v27 = "No key to backup to, we don't enable individual view backups";
        goto LABEL_40;
      }
    }
    else
    {
      __int16 v26 = sub_10000B070("backup");
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)block = 0;
        __int16 v27 = "Haven't finished initial backup syncing, not registering backup metas with engine";
LABEL_40:
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, v27, block, 2u);
      }
    }
LABEL_41:

LABEL_42:
    if (*((unsigned char *)v52 + 24)) {
      CFSetAddValue(v18, kSOSViewKeychainV0);
    }
    v28[0] = _NSConcreteStackBlock;
    v28[1] = 3221225472;
    v28[2] = sub_1001F6440;
    v28[3] = &unk_100308FD8;
    void v28[4] = v5;
    sub_100025B70(v18, (uint64_t)v28);
    CFDictionaryRef v8 = sub_100204420(v5, (uint64_t)v18, 0);
    if (v18) {
      CFRelease(v18);
    }

    _Block_object_dispose(&v51, 8);
  }
LABEL_5:
  CFSetRef v9 = (uint64_t (**)(id, uint64_t, void))[v1 factory];
  uint64_t Name = SOSCircleGetName();
  if (v9)
  {
    uint64_t v11 = v9[1](v9, Name, 0);
    if (v11)
    {
      uint64_t v12 = *(void *)v11;
      (*(void (**)(uint64_t, void))(v11 + 72))(v11, 0);
      if (v12)
      {
        if (-[OTSOSActualAdapter sosEnabled]_0())
        {
          uint64_t v51 = 0;
          char v52 = &v51;
          uint64_t v53 = 0x2020000000;
          char v54 = 0;
          *(void *)block = _NSConcreteStackBlock;
          *(void *)&block[8] = 3221225472;
          *(void *)&block[16] = sub_100104B58;
          long long v58 = &unk_1002FA280;
          id v59 = &v51;
          uint64_t v60 = v12;
          CFDictionaryRef v61 = v8;
          CFMutableArrayRef v62 = Mutable;
          CFMutableArrayRef v63 = v6;
          dispatch_sync(*(dispatch_queue_t *)(v12 + 112), block);
          uint64_t v47 = 0;
          uint64_t v48 = &v47;
          uint64_t v49 = 0x2020000000;
          char v50 = 1;
          uint64_t v43 = 0;
          long long v44 = &v43;
          uint64_t v45 = 0x2020000000;
          uint64_t v46 = 0;
          id context = _NSConcreteStackBlock;
          uint64_t v37 = 3221225472;
          CFTypeRef v38 = sub_100104C34;
          dispatch_time_t v39 = &unk_1002FA2A8;
          id v41 = &v43;
          uint64_t v42 = v12;
          id v40 = &v47;
          char v13 = sub_1000FC9E4(v12, (uint64_t)&v46, &context);
          if (*((unsigned char *)v48 + 24)) {
            char v14 = v13;
          }
          else {
            char v14 = 0;
          }
          *((unsigned char *)v48 + 24) = v14;
          if ((v14 & 1) == 0)
          {
            uint64_t v15 = sub_10000B070("SecError");
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v16 = v44[3];
              *(_DWORD *)long long buf = 138412290;
              uint64_t v56 = v16;
              _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "failed to save engine state: %@", buf, 0xCu);
            }

            int v17 = (const void *)v44[3];
            if (v17) {
              CFRelease(v17);
            }
          }
          _Block_object_dispose(&v43, 8);
          _Block_object_dispose(&v47, 8);
          _Block_object_dispose(&v51, 8);
        }
      }
    }
  }
  if (v8) {
    CFRelease(v8);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v6) {
    CFRelease(v6);
  }
}

void sub_1001F5CD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
}

void sub_1001F5D1C(uint64_t a1, uint64_t a2)
{
  [*(id *)(a1 + 32) accountKey];
  if (SOSPeerInfoApplicationVerify())
  {
    int IsRetirementTicket = SOSPeerInfoIsRetirementTicket();
    uint64_t v5 = 48;
    if (IsRetirementTicket) {
      uint64_t v5 = 56;
    }
    CFMutableArrayRef v6 = (__CFArray **)(a1 + v5);
  }
  else
  {
    CFMutableArrayRef v6 = (__CFArray **)(a1 + 56);
  }
  uint64_t v7 = *v6;
  CFSetRef v8 = (const __CFSet *)SOSPeerInfoCopyEnabledViews();
  uint64_t v9 = *(void *)(a1 + 64);
  uint64_t v16 = 0;
  int v17 = &v16;
  uint64_t v18 = 0x2020000000;
  CFMutableSetRef Mutable = (CFMutableSetRef)0xAAAAAAAAAAAAAAAALL;
  CFMutableSetRef Mutable = CFSetCreateMutable(0, 0, &kCFTypeSetCallBacks);
  if (v8 && v9)
  {
    *(void *)&long long context = _NSConcreteStackBlock;
    *((void *)&context + 1) = 3221225472;
    CFStringRef v21 = sub_1001F67B8;
    id v22 = &unk_1003087F0;
    id v23 = &v16;
    uint64_t v24 = v9;
    CFSetApplyFunction(v8, (CFSetApplierFunction)sub_1001F67A0, &context);
  }
  __int16 v10 = (__CFSet *)v17[3];
  _Block_object_dispose(&v16, 8);
  if (v8) {
    CFRelease(v8);
  }
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
    CFSetAddValue(v10, kSOSViewKeychainV0);
  }
  if (*(unsigned char *)(a1 + 72) && SOSPeerInfoSupportsCKKSForAll())
  {
    uint64_t v11 = sub_10000B070("engine-notify");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t PeerID = SOSPeerInfoGetPeerID();
      LODWORD(context) = 138412290;
      *(void *)((char *)&context + 4) = PeerID;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Peer %@ supports CKKS For All; ignoring in SOS syncing",
        (uint8_t *)&context,
        0xCu);
    }

    CFSetRemoveAllValues(v10);
  }
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  void v15[2] = sub_1001F6814;
  v15[3] = &unk_100308FD8;
  void v15[4] = a2;
  sub_100025B70(v10, (uint64_t)v15);
  CFDictionaryRef v13 = (const __CFDictionary *)SOSPeerInfoGetPeerID();
  CFDictionaryRef v14 = sub_100204420(v13, (uint64_t)v10, 0);
  if (v10) {
    CFRelease(v10);
  }
  CFArrayAppendValue(v7, v14);
  if (v14) {
    CFRelease(v14);
  }
}

void sub_1001F5FCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1001F5FEC(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID() && (!kSOSViewKeychainV0 || !CFEqual(cf, kSOSViewKeychainV0)))
    {
      CFStringRef v5 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@-tomb", cf);
      CFMutableArrayRef v6 = [*(id *)(a1 + 32) trust];
      uint64_t v7 = [v6 copyRing:v5 err:0];

      if (v7 && (CFTypeID v8 = CFGetTypeID(v7), v8 == sub_10022E9CC()) && sub_10022F62C(v7) == 1)
      {
        CFStringRef Value = (__CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), v7);
        if (Value && (__int16 v10 = Value, v11 = CFGetTypeID(Value), v11 == CFSetGetTypeID()))
        {
          CFSetAddValue(v10, v5);
        }
        else
        {
          CFMutableSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
          CFSetAddValue(Mutable, v5);
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), v7, Mutable);
          if (Mutable) {
            CFRelease(Mutable);
          }
        }
      }
      else
      {
        uint64_t v12 = sub_10000B070("SecWarning");
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412802;
          CFStringRef v15 = v5;
          __int16 v16 = 2112;
          CFStringRef v17 = v5;
          __int16 v18 = 2112;
          int v19 = v7;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "View '%@' not being backed up  ring %@:%@ not backup ring.", buf, 0x20u);
        }
      }
      if (v5) {
        CFRelease(v5);
      }
      if (v7) {
        CFRelease(v7);
      }
    }
  }
}

void sub_1001F6200(uint64_t a1, const __CFDictionary **a2, const __CFSet *cf)
{
  if (!cf || (v5 = cf, CFTypeID v6 = CFGetTypeID(cf), v6 != CFSetGetTypeID())) {
    CFSetRef v5 = 0;
  }
  if (a2)
  {
    CFTypeID v7 = CFGetTypeID(a2);
    uint64_t v8 = sub_10022E9CC();
    if (v5)
    {
      if (v7 == v8)
      {
        if (sub_1001F7130(*(void **)(a1 + 32), v5))
        {
          v20[0] = _NSConcreteStackBlock;
          v20[1] = 3221225472;
          v20[2] = sub_1001F6524;
          v20[3] = &unk_100308FD8;
          v20[4] = a2;
          sub_100025B70(v5, (uint64_t)v20);
          return;
        }
        CFTypeRef v19 = 0;
        uint64_t v9 = (const void *)sub_100202028(a2, 0);
        if (v9 && (uint64_t v10 = (uint64_t)v9, v11 = CFGetTypeID(v9), v11 == CFDataGetTypeID()))
        {
          uint64_t v12 = (const void *)SOSBackupSliceKeyBagCreateFromData();
          if (v12)
          {
            CFDictionaryRef v13 = (const __CFDictionary *)sub_10022F02C(a2[3]);
            CFDictionaryRef v14 = sub_100204420(v13, (uint64_t)v5, v10);
            if (sub_100029834((uint64_t)v14, &v19, @"Didn't make peer meta for: %@", a2))
            {
              CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 40), v14);
              CFStringRef v15 = v18;
              v18[0] = _NSConcreteStackBlock;
              v18[1] = 3221225472;
              v18[2] = sub_1001F65F4;
              void v18[3] = &unk_100307FB8;
              void v18[4] = a2;
              v18[5] = v10;
LABEL_14:
              sub_100025B70(v5, (uint64_t)v15);
              if (v14) {
                CFRelease(v14);
              }
              if (v12) {
                CFRelease(v12);
              }
              CFTypeRef v16 = v19;
              if (v19)
              {
                CFTypeRef v19 = 0;
                CFRelease(v16);
              }
              return;
            }
LABEL_23:
            CFStringRef v15 = v17;
            v17[0] = _NSConcreteStackBlock;
            v17[1] = 3221225472;
            void v17[2] = sub_1001F66D0;
            void v17[3] = &unk_100307FB8;
            void v17[4] = a2;
            void v17[5] = v19;
            goto LABEL_14;
          }
        }
        else
        {
          uint64_t v12 = 0;
        }
        CFDictionaryRef v14 = 0;
        goto LABEL_23;
      }
    }
  }
}

void sub_1001F6440(uint64_t a1, uint64_t a2)
{
  CFTypeID v4 = sub_10000B070("engine-notify");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = 138412546;
    uint64_t v7 = v5;
    __int16 v8 = 2112;
    uint64_t v9 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "My Meta: %@: %@", (uint8_t *)&v6, 0x16u);
  }
}

uint64_t sub_1001F6508(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void sub_1001F6524(uint64_t a1, uint64_t a2)
{
  CFTypeID v4 = sub_10000B070("engine-notify");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = sub_10022F02C(*(const __CFDictionary **)(*(void *)(a1 + 32) + 24));
    int v6 = 138412546;
    uint64_t v7 = v5;
    __int16 v8 = 2112;
    uint64_t v9 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Not ready, no peer meta: R: %@ Vs: %@", (uint8_t *)&v6, 0x16u);
  }
}

void sub_1001F65F4(uint64_t a1, uint64_t a2)
{
  CFTypeID v4 = sub_10000B070("engine-notify");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = sub_10022F02C(*(const __CFDictionary **)(*(void *)(a1 + 32) + 24));
    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = 138412802;
    __int16 v8 = v5;
    __int16 v9 = 2112;
    uint64_t v10 = a2;
    __int16 v11 = 2112;
    uint64_t v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Backup peer meta: R: %@ Vs: %@ VD: %@", (uint8_t *)&v7, 0x20u);
  }
}

void sub_1001F66D0(uint64_t a1, uint64_t a2)
{
  CFTypeID v4 = sub_10000B070("SecError");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = *(void *)(a1 + 40);
    int v7 = 138412802;
    uint64_t v8 = v5;
    __int16 v9 = 2112;
    uint64_t v10 = a2;
    __int16 v11 = 2112;
    uint64_t v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Failed to register backup meta from %@ for views %@. Error (%@)", (uint8_t *)&v7, 0x20u);
  }
}

uint64_t sub_1001F67A0(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_1001F67B8(uint64_t a1, const void *a2)
{
  if (CFSetContainsValue(*(CFSetRef *)(a1 + 40), a2))
  {
    CFTypeID v4 = *(__CFSet **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    CFSetAddValue(v4, a2);
  }
}

void sub_1001F6814(uint64_t a1, uint64_t a2)
{
  CFSetRef v3 = sub_10000B070("engine-notify");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412546;
    uint64_t PeerID = SOSPeerInfoGetPeerID();
    __int16 v6 = 2112;
    uint64_t v7 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Meta: %@: %@", (uint8_t *)&v4, 0x16u);
  }
}

void sub_1001F68E0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFSetRef v6 = *(const __CFSet **)(a1 + 40);
  CFSetRef v7 = *(const __CFSet **)(a1 + 48);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  void v10[2] = sub_1001F6B10;
  v10[3] = &unk_100307F48;
  id v8 = *(id *)(a1 + 32);
  uint64_t v9 = *(void *)(a1 + 56);
  id v11 = v8;
  uint64_t v12 = v9;
  uint64_t v13 = a2;
  uint64_t v14 = a3;
  sub_1001F6994(v6, v7, v10);
}

void sub_1001F6994(const __CFSet *a1, const __CFSet *a2, void *a3)
{
  uint64_t v5 = a3;
  MutableCFDataRef Copy = CFSetCreateMutableCopy(kCFAllocatorDefault, 0, a2);
  CFMutableSetRef v7 = CFSetCreateMutableCopy(kCFAllocatorDefault, 0, a1);
  context[0] = _NSConcreteStackBlock;
  context[1] = 3221225472;
  context[2] = sub_1001F6B00;
  context[3] = &unk_100309D30;
  context[4] = MutableCopy;
  CFSetApplyFunction(a1, (CFSetApplierFunction)sub_1001F67A0, context);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  _DWORD v8[2] = sub_1001F6B08;
  v8[3] = &unk_100309D30;
  void v8[4] = v7;
  CFSetApplyFunction(a2, (CFSetApplierFunction)sub_1001F67A0, v8);
  v5[2](v5, MutableCopy, v7);

  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  if (v7) {
    CFRelease(v7);
  }
}

void sub_1001F6B00(uint64_t a1, const void *a2)
{
}

void sub_1001F6B08(uint64_t a1, const void *a2)
{
}

void sub_1001F6B10(uint64_t a1, uint64_t a2, uint64_t a3)
{
  [*(id *)(a1 + 32) change_blocks];
  CFArrayRef v6 = (const __CFArray *)objc_claimAutoreleasedReturnValue();
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  void v7[2] = sub_1001F6BF4;
  v7[3] = &unk_100307F20;
  id v8 = *(id *)(a1 + 32);
  long long v9 = *(_OWORD *)(a1 + 40);
  uint64_t v10 = *(void *)(a1 + 56);
  uint64_t v11 = a2;
  uint64_t v12 = a3;
  v13.size_t length = CFArrayGetCount(v6);
  v13.id location = 0;
  CFArrayApplyFunction(v6, v13, (CFArrayApplierFunction)sub_1001F67A0, v7);
}

uint64_t sub_1001F6BF4(void *a1, uint64_t a2)
{
  int v4 = sub_10000B070("updates");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CFArrayRef v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "calling change block", v6, 2u);
  }

  return (*(uint64_t (**)(uint64_t, void, void, void, void, void, void))(a2 + 16))(a2, a1[4], a1[5], a1[6], a1[7], a1[8], a1[9]);
}

void sub_1001F6C90(uint64_t a1, const void *a2, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v5 = CFGetTypeID(cf);
    if (v5 == CFDataGetTypeID())
    {
      uint64_t v6 = SOSPeerInfoCreateFromData();
      if (v6)
      {
        CFMutableSetRef v7 = (const void *)v6;
        uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID();
        if (CFEqual(a2, PeerID) && SOSPeerInfoInspectRetirementTicket())
        {
          long long v9 = [*(id *)(a1 + 32) retirees];
          [v9 addObject:v7];

          [*(id *)(a1 + 40) setCircle_rings_retirements_need_attention:1];
          CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 56), a2);
        }
        CFRelease(v7);
      }
    }
  }
}

void sub_1001F6D70(void *a1)
{
  id v1 = a1;
  if (v1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = &v5;
    uint64_t v7 = 0x2020000000;
    char v8 = 1;
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1001F6E70;
    block[3] = &unk_100308068;
    void block[4] = &v5;
    if (qword_10035D358 != -1) {
      dispatch_once(&qword_10035D358, block);
    }
    int v2 = *((unsigned __int8 *)v6 + 24);
    _Block_object_dispose(&v5, 8);
    CFSetRef v3 = (uint64_t *)&kCFBooleanFalse;
    if (v2) {
      CFSetRef v3 = (uint64_t *)&kCFBooleanTrue;
    }
    sub_1001FF4C0(v1, @"unsynced", *v3, 0);
  }
}

void sub_1001F6E70(uint64_t a1)
{
  CFSetRef v2 = (const __CFSet *)SOSViewCopyViewSet();
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CFSetGetCount(v2) > 0;
  if (v2)
  {
    CFRelease(v2);
  }
}

CFMutableSetRef sub_1001F6ED8(void *a1)
{
  id v1 = a1;
  CFSetRef v2 = (const __CFSet *)SOSViewCopyViewSet();
  CFMutableSetRef v3 = sub_1001F6F34(v1, v2);

  if (v2) {
    CFRelease(v2);
  }
  return v3;
}

CFMutableSetRef sub_1001F6F34(void *a1, const __CFSet *a2)
{
  id v3 = a1;
  id v4 = sub_1001DCC24(v3, @"unsynced");
  unsigned int v5 = [v3 getCircleStatus:0];

  if (v5)
  {
    CFAllocatorRef v7 = kCFAllocatorDefault;
    return CFSetCreateMutableCopy(v7, 0, a2);
  }
  if (v4)
  {
    CFTypeID v6 = CFGetTypeID(v4);
    if (v6 == CFBooleanGetTypeID())
    {
      CFAllocatorRef v7 = kCFAllocatorDefault;
      if (CFBooleanGetValue((CFBooleanRef)v4)) {
        return CFSetCreateMutableCopy(v7, 0, a2);
      }
      goto LABEL_10;
    }
    CFTypeID v8 = CFGetTypeID(v4);
    if (v8 == CFSetGetTypeID())
    {
      CFAllocatorRef v7 = kCFAllocatorDefault;
      MutableCFDataRef Copy = CFSetCreateMutableCopy(kCFAllocatorDefault, 0, (CFSetRef)v4);
      CFSetRemoveAllValues(MutableCopy);
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 3221225472;
      v11[2] = sub_1001F70C4;
      v11[3] = &unk_100308DB0;
      void v11[4] = a2;
      void v11[5] = MutableCopy;
      CFSetApplyFunction((CFSetRef)v4, (CFSetApplierFunction)sub_1001F7118, v11);
      if (!MutableCopy) {
        return CFSetCreateMutableCopy(v7, 0, a2);
      }
      return MutableCopy;
    }
  }
  CFAllocatorRef v7 = kCFAllocatorDefault;
LABEL_10:
  MutableCFDataRef Copy = CFSetCreateMutable(v7, 0, &kCFTypeSetCallBacks);
  if (!MutableCopy) {
    return CFSetCreateMutableCopy(v7, 0, a2);
  }
  return MutableCopy;
}

void sub_1001F70C4(uint64_t a1, const void *a2)
{
  if (CFSetContainsValue(*(CFSetRef *)(a1 + 32), a2))
  {
    id v4 = *(__CFSet **)(a1 + 40);
    CFSetAddValue(v4, a2);
  }
}

uint64_t sub_1001F7118(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

BOOL sub_1001F7130(void *a1, const __CFSet *a2)
{
  CFSetRef v2 = sub_1001F6F34(a1, a2);
  CFIndex Count = CFSetGetCount(v2);
  if (v2) {
    CFRelease(v2);
  }
  return Count != 0;
}

BOOL sub_1001F7170(void *a1)
{
  id v1 = a1;
  CFSetRef v2 = (const __CFSet *)SOSViewCopyViewSet();
  BOOL v3 = sub_1001F7130(v1, v2);

  if (v2) {
    CFRelease(v2);
  }
  return !v3;
}

void sub_1001F71D0(uint64_t a1, const void *a2)
{
}

void sub_1001F71D8(uint64_t a1, const void *a2)
{
}

BOOL sub_1001F71E0(uint64_t a1, BOOL a2, BOOL a3)
{
  CFSetRef v5 = (const __CFSet *)SOSViewCopyViewSet();
  CFSetRef v6 = v5;
  if (!a2)
  {
    if (!v5) {
      return a2;
    }
    goto LABEL_10;
  }
  uint64_t v15 = 0;
  CFTypeRef v16 = &v15;
  uint64_t v17 = 0x2020000000;
  char v18 = 1;
  if (v5)
  {
    long long v9 = _NSConcreteStackBlock;
    uint64_t v10 = 3221225472;
    uint64_t v11 = sub_1001F7484;
    uint64_t v12 = &unk_1003087F0;
    CFRange v13 = &v15;
    BOOL v14 = a2;
    CFSetApplyFunction(v5, (CFSetApplierFunction)sub_1001F7118, &v9);
    int v7 = *((unsigned __int8 *)v16 + 24);
    _Block_object_dispose(&v15, 8);
    if (v7)
    {
      a2 = 0;
    }
    else
    {
      a2 = 1;
      if (a3)
      {
        uint64_t v15 = 0;
        CFTypeRef v16 = &v15;
        uint64_t v17 = 0x2020000000;
        char v18 = 1;
        long long v9 = _NSConcreteStackBlock;
        uint64_t v10 = 3221225472;
        uint64_t v11 = sub_1001F7484;
        uint64_t v12 = &unk_1003087F0;
        CFRange v13 = &v15;
        BOOL v14 = a3;
        CFSetApplyFunction(v6, (CFSetApplierFunction)sub_1001F7118, &v9);
        a2 = *((unsigned char *)v16 + 24) != 0;
        _Block_object_dispose(&v15, 8);
      }
    }
LABEL_10:
    CFRelease(v6);
    return a2;
  }
  _Block_object_dispose(&v15, 8);
  return 0;
}

void sub_1001F737C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001F7398(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFSetRef v6 = sub_10000B070("updates");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 138412290;
    uint64_t v9 = a2;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "calling in sync block [%@]", (uint8_t *)&v8, 0xCu);
  }

  return (*(uint64_t (**)(uint64_t, void))(a3 + 16))(a3, *(void *)(a1 + 32));
}

uint64_t sub_1001F7468(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t sub_1001F7484(uint64_t a1, const void *a2)
{
  uint64_t result = CFSetContainsValue(*(CFSetRef *)(a1 + 40), a2);
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  if (result) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = *(unsigned char *)(v4 + 24) == 0;
  }
  char v6 = !v5;
  *(unsigned char *)(v4 + 24) = v6;
  return result;
}

void sub_1001F74C8(void *a1, const __CFSet *a2)
{
  id v3 = a1;
  uint64_t v4 = [v3 account];
  unsigned int v5 = [v4 getCircleStatus:0];
  CFSetRef v6 = (const __CFSet *)sub_1001DCC24(v4, @"unsynced");
  CFSetRef v7 = v6;
  if (v6) {
    CFRetain(v6);
  }
  sub_1001F7A44(a2, &stru_100307FD8);
  if (!v5)
  {
    if (v7 == kCFBooleanTrue)
    {
      CFSetRef v8 = (const __CFSet *)SOSViewCopyViewSet();
      CFAllocatorRef v11 = kCFAllocatorDefault;
      CFSetRef Copy = CFSetCreateCopy(kCFAllocatorDefault, v8);
      if (v7) {
        CFRelease(v7);
      }
      BOOL v14 = sub_10000B070("initial-sync");
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Pending views setting to all we can expect.", buf, 2u);
      }

      if (!v8)
      {
        MutableCFSetRef Copy = 0;
        CFSetRef v7 = Copy;
        goto LABEL_35;
      }
      CFSetRef v7 = Copy;
    }
    else
    {
      if (!v7 || (CFTypeID v10 = CFGetTypeID(v7), v10 != CFSetGetTypeID()))
      {
        CFSetRef v8 = 0;
        MutableCFSetRef Copy = 0;
LABEL_35:
        sub_1001F7A44(MutableCopy, &stru_100307FF8);
        goto LABEL_36;
      }
      CFRetain(v7);
      CFAllocatorRef v11 = kCFAllocatorDefault;
      CFSetRef v8 = v7;
    }
    id v15 = v4;
    CFTypeRef cf = 0;
    p_CFTypeRef cf = &cf;
    uint64_t v23 = 0x2020000000;
    CFMutableSetRef Mutable = (CFMutableSetRef)0xAAAAAAAAAAAAAAAALL;
    CFMutableSetRef Mutable = CFSetCreateMutable(v11, 0, &kCFTypeSetCallBacks);
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 3221225472;
    *(void *)&uint8_t buf[16] = sub_1001F7AF8;
    __int16 v26 = &unk_100308370;
    __int16 v27 = &cf;
    sub_100212E90(v15, buf);
    CFTypeRef v16 = (CFTypeRef *)p_cf[3];
    _Block_object_dispose(&cf, 8);

    MutableCFSetRef Copy = CFSetCreateMutableCopy(v11, 0, v8);
    CFSetRemoveAllValues(MutableCopy);
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 3221225472;
    *(void *)&uint8_t buf[16] = sub_1001F70C4;
    __int16 v26 = &unk_100308DB0;
    __int16 v27 = v16;
    CFSetRef v28 = MutableCopy;
    CFSetApplyFunction(v8, (CFSetApplierFunction)sub_1001F7118, buf);
    if (a2)
    {
      *(void *)long long buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 3221225472;
      *(void *)&uint8_t buf[16] = sub_1001F71D8;
      __int16 v26 = &unk_100309D30;
      __int16 v27 = (CFTypeRef *)MutableCopy;
      CFSetApplyFunction(a2, (CFSetApplierFunction)sub_1001F7118, buf);
    }
    if (v7 == MutableCopy)
    {
      CFSetRef v17 = v7;
    }
    else
    {
      if (!MutableCopy)
      {
        CFRelease(v7);
        CFSetRef v17 = 0;
        if (!v16) {
          goto LABEL_33;
        }
        goto LABEL_32;
      }
      CFRetain(MutableCopy);
      CFSetRef v17 = MutableCopy;
      if (v7)
      {
        CFRelease(v7);
        CFSetRef v17 = MutableCopy;
        if (!v16) {
          goto LABEL_33;
        }
        goto LABEL_32;
      }
    }
    if (!v16)
    {
LABEL_33:
      CFSetRef v7 = v17;
      goto LABEL_35;
    }
LABEL_32:
    CFRelease(v16);
    goto LABEL_33;
  }
  if (v5 != 2)
  {
    if (!v7)
    {
      CFSetRef v8 = 0;
      MutableCFSetRef Copy = 0;
      goto LABEL_39;
    }
    uint64_t v12 = sub_10000B070("initial-sync");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "not in circle nor applying: clearing pending", buf, 2u);
    }
    CFSetRef v8 = 0;
    MutableCFSetRef Copy = 0;
LABEL_14:

    CFRelease(v7);
    CFSetRef v7 = 0;
    goto LABEL_39;
  }
  CFSetRef v8 = 0;
  MutableCFSetRef Copy = 0;
LABEL_36:
  if (v7)
  {
    CFTypeID v18 = CFGetTypeID(v7);
    if (v18 == CFSetGetTypeID() && !CFSetGetCount(v7))
    {
      uint64_t v12 = sub_10000B070("initial-sync");
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Empty set, using NULL instead", buf, 2u);
      }
      goto LABEL_14;
    }
  }
LABEL_39:
  CFTypeRef cf = 0;
  if (!sub_1001FF4C0(v4, @"unsynced", (uint64_t)v7, &cf))
  {
    CFTypeRef v19 = sub_10000B070("initial-sync");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412546;
      *(void *)&uint8_t buf[4] = cf;
      *(_WORD *)&unsigned char buf[12] = 2112;
      *(void *)&buf[14] = v7;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Failure saving new unsynced value: %@ value: %@", buf, 0x16u);
    }
  }
  CFTypeRef v20 = cf;
  if (cf)
  {
    CFTypeRef cf = 0;
    CFRelease(v20);
  }
  if (v7) {
    CFRelease(v7);
  }
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  if (v8) {
    CFRelease(v8);
  }
}

void sub_1001F7A24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void sub_1001F7A44(const __CFSet *a1, void *a2)
{
  unsigned int v5 = a2;
  if (a1 && (CFTypeID v3 = CFGetTypeID(a1), v3 == CFSetGetTypeID()))
  {
    sub_100025B70(a1, (uint64_t)v5);
  }
  else
  {
    CFStringRef v4 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@", a1);
    v5[2](v5, v4);
    if (v4) {
      CFRelease(v4);
    }
  }
}

uint64_t sub_1001F7AF8()
{
  return SOSPeerInfoWithEnabledViewSet();
}

void sub_1001F7B70(id a1, __CFString *a2)
{
  CFTypeID v3 = sub_10000B070("initial-sync");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    unsigned int v5 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Unsynced: %@", (uint8_t *)&v4, 0xCu);
  }
}

void sub_1001F7C1C(uint64_t a1, CFSetRef theSet)
{
  uint64_t v2 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  context[0] = _NSConcreteStackBlock;
  context[1] = 3221225472;
  context[2] = sub_1001F71D0;
  context[3] = &unk_100309D30;
  context[4] = v2;
  CFSetApplyFunction(theSet, (CFSetApplierFunction)sub_1001F7118, context);
}

void sub_1001F7CA8(id a1, __CFString *a2)
{
  CFTypeID v3 = sub_10000B070("initial-sync");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    unsigned int v5 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Views in sync: %@", (uint8_t *)&v4, 0xCu);
  }
}

void sub_1001F7D54(void *a1)
{
  id v1 = a1;
  if (([v1 isListeningForSync] & 1) == 0)
  {
    uint64_t v2 = [v1 trust];
    id v3 = [v2 getDataSourceEngine:[v1 factory]];

    if (v3)
    {
      int v4 = sub_10000B070("initial-sync");
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Setting up notifications to monitor in-sync", buf, 2u);
      }

      unsigned int v5 = [v1 queue];
      sub_1001026AC((uint64_t)v3, v5);

      v8[0] = _NSConcreteStackBlock;
      v8[1] = 3221225472;
      _DWORD v8[2] = sub_1001F7EEC;
      v8[3] = &unk_100308040;
      CFSetRef v6 = v1;
      uint64_t v9 = v6;
      sub_1001025C8((uint64_t)v3, v8);
      [v6 setIsListeningForSync:1];
      CFSetRef v7 = v9;
    }
    else
    {
      CFSetRef v7 = sub_10000B070("SecError");
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Couldn't find engine to setup notifications!!!", buf, 2u);
      }
    }
  }
}

id sub_1001F7EEC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v3 = *(void **)(a1 + 32);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_1001F7F5C;
  void v5[3] = &unk_100308018;
  void v5[4] = a2;
  void v5[5] = a3;
  return [v3 performTransaction_Locked:v5];
}

void sub_1001F7F5C(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void *)(a1 + 32);
  CFSetRef v2 = *(const __CFSet **)(a1 + 40);
  id v4 = a2;
  unsigned int v5 = [v4 account];
  CFSetRef v6 = sub_10000B070("initial-sync");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 138412546;
    uint64_t v9 = v3;
    __int16 v10 = 2112;
    CFSetRef v11 = v2;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Peer %@ synced views: %@", (uint8_t *)&v8, 0x16u);
  }

  CFSetRef v7 = [v5 trust];
  if ([v7 trustedCircle]
    && [v5 isInCircle:0]
    && SOSCircleHasActivePeerWithID())
  {
    sub_1001F74C8(v4, v2);
  }
}

void sub_1001F8090(void *a1)
{
  id v1 = a1;
  if ([v1 peerInfo] && objc_msgSend(v1, "isInCircle:", 0) && sub_1001F7170(v1))
  {
    CFSetRef v2 = (const void *)SOSViewCopyViewSet();
    if ((SOSPeerInfoVersionIsCurrent() & 1) == 0)
    {
      CFSetRef v3 = (const __CFSet *)SOSViewCopyViewSet();
      context[0] = _NSConcreteStackBlock;
      context[1] = 3221225472;
      context[2] = sub_1001F71D0;
      context[3] = &unk_100309D30;
      context[4] = v2;
      CFSetApplyFunction(v3, (CFSetApplierFunction)sub_1001F7118, context);
      if (v3) {
        CFRelease(v3);
      }
    }
    id v4 = [v1 trust];
    [v4 updateFullPeerInfo:v1 minimum:v2 excluded:SOSViewsGetV0ViewSet()];

    if (v2) {
      CFRelease(v2);
    }
  }
}

void sub_1001F9C4C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 192), 8);
  _Unwind_Resume(a1);
}

void sub_1001F9C9C(uint64_t a1, const void *a2)
{
  id v4 = *(__CFSet **)(a1 + 32);
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID();
  CFSetAddValue(v4, PeerID);
  CFSetRef v6 = *(__CFSet **)(a1 + 40);

  CFSetAddValue(v6, a2);
}

void sub_1001F9CF8(uint64_t a1, const void *a2)
{
  id v4 = *(__CFSet **)(a1 + 32);
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID();
  CFSetAddValue(v4, PeerID);
  CFSetRef v6 = *(__CFSet **)(a1 + 40);

  CFSetAddValue(v6, a2);
}

void sub_1001F9F04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001F9F1C(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v3 + 24) && (!a3 || !a3[2] || !a3[3] || !a3[4] || !a3[5]))
  {
    *(unsigned char *)(v3 + 24) = 0;
    unsigned int v5 = sub_10000B070("ring");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 138412290;
      uint64_t v8 = a2;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Ring %@ not stable", (uint8_t *)&v7, 0xCu);
    }
  }
  return 0;
}

void sub_1001FA31C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001FA340(uint64_t a1)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = SOSCircleResetToEmpty();
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

void sub_1001FA510(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001FA52C(uint64_t a1, const void *a2)
{
  return 0;
}

id sub_1001FA54C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 48) + 8);
  if (*(unsigned char *)(v2 + 24))
  {
    id result = [*(id *)(a1 + 32) resetRing:*(void *)(a1 + 40) ringName:a2 err:*(void *)(a1 + 56)];
    uint64_t v2 = *(void *)(*(void *)(a1 + 48) + 8);
  }
  else
  {
    id result = 0;
  }
  *(unsigned char *)(v2 + 24) = (_BYTE)result;
  return result;
}

uint64_t sub_1001FA5A4(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_1001FA7C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Block_object_dispose(&a21, 8);
  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a29, 8);
  _Block_object_dispose((const void *)(v29 - 144), 8);
  _Block_object_dispose((const void *)(v29 - 112), 8);
  _Block_object_dispose((const void *)(v29 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_1001FA828(uint64_t a1, const void *a2, CFDataRef theData)
{
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = a2;
  *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = CFDataCreateCopy(kCFAllocatorDefault, theData);
  CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 88), a2, *(const void **)(*(void *)(*(void *)(a1 + 48) + 8) + 24));
  *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = sub_1001FF110(0, *(CFDataRef *)(*(void *)(*(void *)(a1 + 48) + 8)+ 24));
  *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  unsigned int v5 = *(const __CFDictionary ***)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
  if (v5)
  {
    *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) = sub_1001FEE20(v5, 0);
    CFDictionaryReplaceValue(*(CFMutableDictionaryRef *)(a1 + 88), a2, *(const void **)(*(void *)(*(void *)(a1 + 72) + 8) + 24));
    uint64_t v6 = *(void *)(*(void *)(a1 + 72) + 8);
    int v7 = *(const void **)(v6 + 24);
    if (v7)
    {
      *(void *)(v6 + 24) = 0;
      CFRelease(v7);
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) = 1;
  }
  uint64_t v8 = *(void *)(*(void *)(a1 + 56) + 8);
  uint64_t v9 = *(const void **)(v8 + 24);
  if (v9)
  {
    *(void *)(v8 + 24) = 0;
    CFRelease(v9);
  }
  uint64_t v10 = *(void *)(*(void *)(a1 + 48) + 8);
  CFSetRef v11 = *(const void **)(v10 + 24);
  if (v11)
  {
    *(void *)(v10 + 24) = 0;
    CFRelease(v11);
  }
  uint64_t v12 = *(void *)(*(void *)(a1 + 64) + 8);
  CFRange v13 = *(const void **)(v12 + 24);
  if (v13)
  {
    *(void *)(v12 + 24) = 0;
    CFRelease(v13);
  }
}

uint64_t sub_1001FA9A4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t sub_1001FAACC(uint64_t a1)
{
  uint64_t v2 = sub_10000B070("circleChange");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Calling SOSCircleUpdatePeerInfo for gestalt change", v4, 2u);
  }

  [*(id *)(a1 + 32) peerInfo];
  return SOSCircleUpdatePeerInfo();
}

void sub_1001FAD24(uint64_t a1, const void *a2)
{
}

void sub_1001FAE34(uint64_t a1, const void *a2)
{
}

uint64_t sub_1001FB090(uint64_t a1)
{
  CFDataRef v1 = *(const __CFData **)(a1 + 32);
  if (v1)
  {
    CFDataGetLength(*(CFDataRef *)(a1 + 32));
    CFDataGetBytePtr(v1);
    ccder_encode_raw_octet_string();
  }

  return ccder_encode_constructed_tl();
}

BOOL sub_1001FB114(FILE *a1, __CFString **a2, size_t capacity, uint64_t a4)
{
  CFMutableSetRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, capacity);
  CFDataSetLength(Mutable, capacity);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  uint64_t v10 = (*(uint64_t (**)(uint64_t, UInt8 *, UInt8 *))(a4 + 16))(a4, MutableBytePtr, &MutableBytePtr[capacity]);
  if (!v10)
  {
LABEL_7:
    BOOL v17 = 0;
    if (!Mutable) {
      return v17;
    }
    goto LABEL_4;
  }
  if (MutableBytePtr != (UInt8 *)v10)
  {
    sub_100012A40(-1, a2, @"size mismatch der_end - der: %td", v10 - (void)MutableBytePtr);
    goto LABEL_7;
  }
  BOOL v11 = fwrite(MutableBytePtr, capacity, 1uLL, a1) != 1;
  BOOL v17 = sub_1000296CC(v11, (CFTypeRef *)a2, @"fwrite SOSBackupEventWrite", v12, v13, v14, v15, v16, v19);
  if (Mutable) {
LABEL_4:
  }
    CFRelease(Mutable);
  return v17;
}

BOOL sub_1001FB210(FILE *a1, CFDataRef theData, __CFString **a3)
{
  CFDataGetLength(theData);
  size_t v6 = ccder_sizeof_raw_octet_string();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  _DWORD v8[2] = sub_1001FB2B0;
  v8[3] = &unk_1003081E8;
  void v8[4] = theData;
  void v8[5] = a3;
  return sub_1001FB114(a1, a3, v6, (uint64_t)v8);
}

uint64_t sub_1001FB2B0(uint64_t a1)
{
  CFDataRef v1 = *(const __CFData **)(a1 + 32);
  CFDataGetLength(v1);
  CFDataGetBytePtr(v1);

  return ccder_encode_raw_octet_string();
}

BOOL sub_1001FB314(FILE *a1, const __CFDictionary *a2, __CFString **a3)
{
  size_t v6 = sub_10000B67C(a2, 0);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  _DWORD v8[2] = sub_1001FB3B4;
  v8[3] = &unk_100308208;
  void v8[4] = a2;
  void v8[5] = a3;
  return sub_1001FB114(a1, a3, v6, (uint64_t)v8);
}

uint64_t sub_1001FB3B4(uint64_t a1)
{
  return sub_10000B6E8(*(const __CFDictionary **)(a1 + 32), *(CFTypeRef **)(a1 + 40), 0);
}

BOOL sub_1001FB3CC(FILE *a1, uint64_t a2, __CFString **a3)
{
  size_t v6 = ccder_sizeof_uint64();
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  _DWORD v9[2] = sub_1001FB478;
  v9[3] = &unk_100308228;
  void v9[4] = a2;
  void v9[5] = a3;
  BOOL v7 = sub_1001FB114(a1, a3, v6, (uint64_t)v9);
  fflush(a1);
  return v7;
}

uint64_t sub_1001FB478()
{
  return ccder_encode_uint64();
}

uint64_t sub_1001FB6C8(uint64_t a1)
{
  uint64_t v2 = sub_10000B070("circleChange");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Calling SOSCircleUpdatePeerInfo for gestalt change", v4, 2u);
  }

  [*(id *)(a1 + 32) peerInfo];
  return SOSCircleUpdatePeerInfo();
}

void sub_1001FB868(uint64_t a1, const void *a2)
{
  if (SOSPeerInfoIsCloudIdentity())
  {
    CloudIdentity = (const void *)SOSFullPeerInfoCreateCloudIdentity();
    if (CloudIdentity)
    {
      CFRelease(CloudIdentity);
    }
    else
    {
      unsigned int v5 = *(__CFSet **)(a1 + 32);
      CFSetAddValue(v5, a2);
    }
  }
}

void sub_1001FBAEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001FBB04(uint64_t a1)
{
  uint64_t result = SOSPeerInfoIsEnabledView();
  if (result) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
  return result;
}

id sub_1001FBC58(uint64_t a1)
{
  CFDataRef v1 = *(void **)(a1 + 32);
  uint64_t PeerID = SOSPeerInfoGetPeerID();

  return [v1 addObject:PeerID];
}

void sub_1001FBEAC(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef cfa = 0;
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID())
    {
      [*(id *)(a1 + 32) trustedCircle];
      uint64_t v5 = SOSCircleCopyPeerWithID();
      if (v5)
      {
        size_t v6 = (const void *)v5;
        [*(id *)(a1 + 32) trustedCircle];
        [*(id *)(a1 + 40) accountKey];
        int HasValidSyncingPeer = SOSCircleHasValidSyncingPeer();
        uint64_t v8 = 56;
        if (HasValidSyncingPeer) {
          uint64_t v8 = 48;
        }
        CFSetAddValue(*(CFMutableSetRef *)(a1 + v8), cf);
        CFRelease(v6);
      }
      else
      {
        BOOL v11 = *(__CFSet **)(a1 + 56);
        CFSetAddValue(v11, cf);
      }
      return;
    }
    sub_100012A40(-50, (__CFString **)&cfa, @"object %@ is not a string", cf);
  }
  else
  {
    sub_100012A40(-50, (__CFString **)&cfa, @"object %@ is not a string", 0);
  }
  if (cfa)
  {
    uint64_t v9 = sub_10000B070("sync-with-peers");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412546;
      uint64_t v14 = 0;
      __int16 v15 = 2112;
      CFTypeRef v16 = cfa;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Skipped peer ID: %@ due to %@", buf, 0x16u);
    }

    CFTypeRef v10 = cfa;
    if (cfa)
    {
      CFTypeRef cfa = 0;
      CFRelease(v10);
    }
  }
}

void sub_1001FC0B0(uint64_t a1, const void *a2)
{
}

uint64_t sub_1001FC0B8(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_1001FCB18(uint64_t a1, const void *a2)
{
  if ((SOSPeerInfoApplicationVerify() & 1) == 0)
  {
    CFTypeID v4 = *(__CFSet **)(a1 + 40);
    CFSetAddValue(v4, a2);
  }
}

uint64_t sub_1001FCB74()
{
  return SOSCircleWithdrawRequest();
}

uint64_t sub_1001FCC90(uint64_t a1)
{
  uint64_t v2 = sub_10000B070("circleChange");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 40);
    int v5 = 138412290;
    uint64_t v6 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Calling SOSCircleUpdatePeerInfo for %@", (uint8_t *)&v5, 0xCu);
  }

  [*(id *)(a1 + 32) peerInfo];
  return SOSCircleUpdatePeerInfo();
}

uint64_t sub_1001FCE64()
{
  return SOSCircleForEachPeer();
}

void sub_1001FCEE0(uint64_t a1, const void *a2)
{
  CFTypeID v4 = *(const void **)(a1 + 32);
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID();
  if (v4) {
    BOOL v6 = PeerID == 0;
  }
  else {
    BOOL v6 = 1;
  }
  if (v6)
  {
    if (v4 == PeerID) {
      return;
    }
  }
  else if (CFEqual(v4, PeerID))
  {
    return;
  }
  if (SOSPeerInfoApplicationVerify() && (SOSPeerInfoIsRetirementTicket() & 1) == 0)
  {
    uint64_t v8 = *(__CFArray **)(a1 + 48);
    CFArrayAppendValue(v8, a2);
  }
}

void sub_1001FD054(uint64_t a1, const void *a2)
{
  if ((*(unsigned int (**)(void))(*(void *)(a1 + 32) + 16))())
  {
    CFTypeID v4 = *(__CFSet **)(a1 + 40);
    CFSetAddValue(v4, a2);
  }
}

void sub_1001FD2A0(uint64_t a1, const void *a2)
{
  CFSetRef PermittedViews = (const __CFSet *)SOSPeerInfoGetPermittedViews();
  if (CFSetContainsValue(PermittedViews, *(const void **)(a1 + 32)))
  {
    int v5 = *(__CFSet **)(a1 + 40);
    CFSetAddValue(v5, a2);
  }
}

void sub_1001FD470(uint64_t a1, uint64_t a2, uint64_t a3, const __CFSet *a4, const __CFSet *a5)
{
  uint64_t Name = (const void *)SOSCircleGetName();
  uint64_t v9 = *(const void **)(a1 + 48);
  if (Name && v9)
  {
    if (!CFEqual(Name, v9)) {
      return;
    }
  }
  else if (Name != v9)
  {
    return;
  }
  id v10 = [*(id *)(a1 + 32) peerInfo];
  if (v10) {
    uint64_t PeerID = SOSPeerInfoGetPeerID();
  }
  else {
    uint64_t PeerID = 0;
  }
  CFArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v13 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v14 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (SOSCircleHasPeer())
  {
    void context[6] = _NSConcreteStackBlock;
    void context[7] = 3221225472;
    context[8] = sub_1001FD6D4;
    context[9] = &unk_100308DD0;
    context[10] = Mutable;
    context[11] = PeerID;
    SOSCircleForEachPeer();
    context[0] = _NSConcreteStackBlock;
    context[1] = 3221225472;
    context[2] = sub_1001FD754;
    context[3] = &unk_100308DB0;
    context[4] = v13;
    void context[5] = PeerID;
    CFSetApplyFunction(a4, (CFSetApplierFunction)sub_1001FC0B8, context);
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472;
    void v15[2] = sub_1001FD7D4;
    v15[3] = &unk_100308DB0;
    void v15[4] = v14;
    void v15[5] = PeerID;
    CFSetApplyFunction(a5, (CFSetApplierFunction)sub_1001FC0B8, v15);
  }
  if (CFArrayGetCount(Mutable) || CFSetContainsValue(a5, v10)) {
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v13) {
    CFRelease(v13);
  }
  if (v14) {
    CFRelease(v14);
  }
}

void sub_1001FD6D4(uint64_t a1)
{
  uint64_t v2 = *(__CFArray **)(a1 + 32);
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID();
  CFTypeID v4 = PeerID;
  int v5 = *(const void **)(a1 + 40);
  if (PeerID && v5)
  {
    if (CFEqual(PeerID, v5)) {
      return;
    }
  }
  else if (PeerID == v5)
  {
    return;
  }

  CFArrayAppendValue(v2, v4);
}

void sub_1001FD754(uint64_t a1)
{
  uint64_t v2 = *(__CFArray **)(a1 + 32);
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID();
  CFTypeID v4 = PeerID;
  int v5 = *(const void **)(a1 + 40);
  if (PeerID && v5)
  {
    if (CFEqual(PeerID, v5)) {
      return;
    }
  }
  else if (PeerID == v5)
  {
    return;
  }

  CFArrayAppendValue(v2, v4);
}

void sub_1001FD7D4(uint64_t a1)
{
  uint64_t v2 = *(__CFArray **)(a1 + 32);
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID();
  CFTypeID v4 = PeerID;
  int v5 = *(const void **)(a1 + 40);
  if (PeerID && v5)
  {
    if (CFEqual(PeerID, v5)) {
      return;
    }
  }
  else if (PeerID == v5)
  {
    return;
  }

  CFArrayAppendValue(v2, v4);
}

void sub_1001FDD34(uint64_t a1, const __CFSet *a2)
{
  if (a2)
  {
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472;
    _DWORD v4[2] = sub_1001FE0C0;
    void v4[3] = &unk_100308FD8;
    void v4[4] = a1;
    sub_100025B70(a2, (uint64_t)v4);
  }
  else
  {
    uint64_t v3 = sub_10000B070("circleChange");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v6 = a1;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "No %@ list provided.", buf, 0xCu);
    }
  }
}

BOOL sub_1001FDE40(void *a1, __CFSet *a2, int a3)
{
  id v5 = a1;
  if (a2)
  {
    uint64_t v6 = (const void *)kSOSViewKeychainV0;
    BOOL v7 = 1;
    if (CFSetContainsValue(a2, kSOSViewKeychainV0))
    {
      if (sub_1001F54A4(v5)) {
        int v8 = 2;
      }
      else {
        int v8 = 1;
      }
      BOOL v7 = v8 == a3;
      CFSetRemoveValue(a2, v6);
    }
  }
  else
  {
    BOOL v7 = 1;
  }

  return v7;
}

uint64_t sub_1001FDED4(uint64_t a1)
{
  uint64_t v2 = sub_10000B070("circleChange");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CFTypeID v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Calling SOSCircleUpdatePeerInfo for views or peerInfo change", v4, 2u);
  }

  [*(id *)(a1 + 32) peerInfo];
  return SOSCircleUpdatePeerInfo();
}

void sub_1001FDF68(id a1, __CFString *a2)
{
  uint64_t v3 = sub_10000B070("viewChange");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    id v5 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Disabling %@", (uint8_t *)&v4, 0xCu);
  }
}

void sub_1001FE014(id a1, __CFString *a2)
{
  uint64_t v3 = sub_10000B070("viewChange");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    id v5 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Enabling %@", (uint8_t *)&v4, 0xCu);
  }
}

void sub_1001FE0C0(uint64_t a1, uint64_t a2)
{
  int v4 = sub_10000B070("circleChange");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = 138412546;
    uint64_t v7 = v5;
    __int16 v8 = 2112;
    uint64_t v9 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%@ list: %@", (uint8_t *)&v6, 0x16u);
  }
}

void sub_1001FE38C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 80), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001FE3B0(uint64_t a1)
{
  [*(id *)(a1 + 32) peerInfo];
  uint64_t result = SOSPeerInfoViewStatus();
  uint64_t v3 = 40;
  if (result == 1) {
    uint64_t v3 = 48;
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + v3) + 8) + 24) = 1;
  return result;
}

uint64_t sub_1001FE994(uint64_t a1)
{
  uint64_t v2 = sub_10000B070("circleChange");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Calling SOSCircleUpdatePeerInfo for views change", v4, 2u);
  }

  [*(id *)(a1 + 32) peerInfo];
  return SOSCircleUpdatePeerInfo();
}

uint64_t sub_1001FEB80(uint64_t a1)
{
  uint64_t v2 = sub_10000B070("circleChange");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Calling SOSCircleUpdatePeerInfo for gestalt change", v4, 2u);
  }

  [*(id *)(a1 + 32) peerInfo];
  return SOSCircleUpdatePeerInfo();
}

uint64_t sub_1001FEE20(const __CFDictionary **a1, CFTypeRef *a2)
{
  if (!a1[2])
  {
    int v6 = sub_10000B070("SecError");
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_5;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v7 = "ring has no unSignedInformation";
LABEL_20:
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v7, buf, 2u);
    goto LABEL_5;
  }
  if (!a1[3])
  {
    int v6 = sub_10000B070("SecError");
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_5;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v7 = "ring has no signedInformation";
    goto LABEL_20;
  }
  if (!a1[4])
  {
    int v6 = sub_10000B070("SecError");
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_5;
    }
    *(_WORD *)long long buf = 0;
    uint64_t v7 = "ring has no signatures";
    goto LABEL_20;
  }
  if (!a1[5])
  {
    int v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      uint64_t v7 = "ring has no data";
      goto LABEL_20;
    }
  }
LABEL_5:
  if (sub_10000B67C(a1[2], (uint64_t)a2)
    && sub_10000B67C(a1[3], (uint64_t)a2)
    && sub_10000B67C(a1[4], (uint64_t)a2)
    && sub_10000B67C(a1[5], (uint64_t)a2))
  {
    ccder_sizeof();
  }
  else
  {
    sub_1000297A0(-1, @"com.apple.security.cfder.error", 0, a2, v4, @"don't know how to encode");
  }
  return CFDataCreateWithDER();
}

uint64_t sub_1001FF050(uint64_t a1)
{
  CFDataRef v1 = *(const __CFDictionary ***)(a1 + 32);
  uint64_t v2 = *(CFTypeRef **)(a1 + 40);
  CFDictionaryRef v3 = v1[2];
  CFDictionaryRef v4 = v1[3];
  CFDictionaryRef v5 = v1[4];
  sub_10000B6E8(v1[5], v2, 0);
  sub_10000B6E8(v5, v2, 0);
  sub_10000B6E8(v4, v2, 0);
  sub_10000B6E8(v3, v2, 0);

  return ccder_encode_constructed_tl();
}

void *sub_1001FF110(CFTypeRef *a1, CFDataRef theData)
{
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  sub_10022E9CC();
  uint64_t Instance = _CFRuntimeCreateInstance();
  CFDictionaryRef theDict = 0;
  uint64_t v23 = 0xAAAAAAAAAAAAAAAALL;
  CFDictionaryRef v20 = 0;
  CFDictionaryRef v21 = 0;
  CFDictionaryRef v19 = 0;
  if (!Instance)
  {
    CFTypeRef v16 = sub_10000B070("ring");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CFTypeID v18 = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Unable to allocate ring", v18, 2u);
    }
    CFMutableArrayRef v14 = 0;
    goto LABEL_25;
  }
  uint64_t v7 = (void *)Instance;
  __int16 v8 = &BytePtr[Length];
  uint64_t v9 = ccder_decode_constructed_tl();
  uint64_t v10 = sub_10000EEF8(0, &theDict, a1, v9, v23);
  uint64_t v11 = sub_10000EEF8(0, &v21, a1, v10, v23);
  uint64_t v12 = sub_10000EEF8(0, &v20, a1, v11, v23);
  uint64_t v13 = sub_10000EEF8(0, &v19, a1, v12, v23);
  if (v13)
  {
    if ((const UInt8 *)v13 == v8)
    {
      void v7[2] = CFDictionaryCreateMutableCopy(0, 0, theDict);
      v7[3] = CFDictionaryCreateMutableCopy(0, 0, v21);
      void v7[4] = CFDictionaryCreateMutableCopy(0, 0, v20);
      CFMutableArrayRef v14 = 0;
      v7[5] = CFDictionaryCreateMutableCopy(0, 0, v19);
      goto LABEL_5;
    }
    BOOL v17 = sub_10000B070("ring");
    if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_24;
    }
    *(_WORD *)CFTypeID v18 = 0;
    goto LABEL_23;
  }
  BOOL v17 = sub_10000B070("ring");
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CFTypeID v18 = 0;
LABEL_23:
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Unable to decode DER", v18, 2u);
  }
LABEL_24:
  CFMutableArrayRef v14 = v7;
LABEL_25:
  uint64_t v7 = 0;
LABEL_5:
  if (theDict) {
    CFRelease(theDict);
  }
  if (v21) {
    CFRelease(v21);
  }
  if (v20) {
    CFRelease(v20);
  }
  if (v19) {
    CFRelease(v19);
  }
  if (v14) {
    CFRelease(v14);
  }
  return v7;
}

BOOL sub_1001FF378(void *a1, uint64_t a2, CFTypeRef *a3)
{
  id v5 = a1;
  BOOL v6 = sub_1001FF3F8(v5, a3);
  if (v6)
  {
    uint64_t v7 = [v5 trust];
    __int16 v8 = [v7 expansion];
    [v8 removeObjectForKey:a2];
  }
  return v6;
}

BOOL sub_1001FF3F8(void *a1, CFTypeRef *a2)
{
  id v3 = a1;
  CFDictionaryRef v4 = [v3 trust];
  id v5 = [v4 expansion];

  if (!v5)
  {
    BOOL v6 = +[NSMutableDictionary dictionary];
    uint64_t v7 = [v3 trust];
    [v7 setExpansion:v6];
  }
  __int16 v8 = [v3 trust];
  uint64_t v9 = [v8 expansion];
  BOOL v10 = sub_100029834((uint64_t)v9, a2, @"Can't Alloc Account Expansion dictionary");

  return v10;
}

BOOL sub_1001FF4C0(void *a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  id v7 = a1;
  __int16 v8 = v7;
  if (a3)
  {
    if (sub_1001FF3F8(v7, a4))
    {
      uint64_t v9 = [v8 trust];
      BOOL v10 = [v9 expansion];
      [v10 setObject:a3 forKey:a2];

      BOOL v11 = 1;
    }
    else
    {
      BOOL v11 = 0;
    }
  }
  else
  {
    BOOL v11 = sub_1001FF378(v7, a2, a4);
  }

  return v11;
}

CFStringRef sub_1001FF568(void *a1)
{
  id v1 = a1;
  CFStringRef v2 = (const __CFString *)sub_1001DCC24(v1, @"UUID");
  if (v2 && (v3 = v2, CFTypeID v4 = CFGetTypeID(v2), v4 == CFStringGetTypeID()))
  {
    CFRetain(v3);
  }
  else
  {
    CFUUIDRef v5 = CFUUIDCreate(kCFAllocatorDefault);
    CFStringRef v3 = CFUUIDCreateString(kCFAllocatorDefault, v5);
    CFTypeRef cf = 0;
    if (!sub_1001FF4C0(v1, @"UUID", (uint64_t)v3, &cf))
    {
      BOOL v6 = sub_10000B070("SecError");
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412546;
        CFStringRef v11 = v3;
        __int16 v12 = 2112;
        CFTypeRef v13 = cf;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Failed to set UUID: %@ (%@)", buf, 0x16u);
      }
    }
    CFTypeRef v7 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v7);
    }
    if (v5) {
      CFRelease(v5);
    }
  }

  return v3;
}

uint64_t sub_1001FF7C8()
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_1001FF860;
  block[3] = &unk_100308410;
  void block[4] = &qword_10035D370;
  if (qword_10035D368 != -1) {
    dispatch_once(&qword_10035D368, block);
  }
  return qword_10035D370;
}

uint64_t sub_1001FF860(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

CFStringRef sub_1001FF894(uint64_t a1)
{
  sub_100025824();

  return sub_1001FF8CC(a1);
}

CFStringRef sub_1001FF8CC(uint64_t a1)
{
  if (!a1) {
    return @"NULL";
  }
  uint64_t v15 = 0;
  CFTypeRef v16 = &v15;
  uint64_t v17 = 0x2000000000;
  uint64_t v18 = 0;
  CFDataRef v1 = *(const __CFData **)(a1 + 48);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  CFStringRef v11 = sub_1001FFA20;
  __int16 v12 = &unk_100308438;
  CFTypeRef v13 = &v15;
  uint64_t v14 = a1;
  if (v1)
  {
    CFIndex Length = CFDataGetLength(v1);
    CFArrayRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 2 * Length);
    BytePtr = CFDataGetBytePtr(v1);
    CFIndex v5 = CFDataGetLength(v1);
    if (v5 >= 1)
    {
      CFIndex v6 = v5;
      do
      {
        unsigned int v7 = *BytePtr++;
        CFStringAppendFormat(Mutable, 0, @"%02X", v7);
        --v6;
      }
      while (v6);
    }
  }
  else
  {
    CFArrayRef Mutable = @"(null)";
  }
  v11((uint64_t)v10, (uint64_t)Mutable);
  CFRelease(Mutable);
  uint64_t v8 = v16[3];
  _Block_object_dispose(&v15, 8);
  return (const __CFString *)v8;
}

CFStringRef sub_1001FFA20(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 40);
  uint64_t v4 = *(void *)(v3 + 24);
  CFIndex v5 = "W";
  if (!*(unsigned char *)(v3 + 32)) {
    CFIndex v5 = "w";
  }
  if (*(unsigned char *)(v3 + 56)) {
    CFIndex v6 = "O";
  }
  else {
    CFIndex v6 = "o";
  }
  CFStringRef result = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"<Coder %@ %@ %s%s>", v4, a2, v5, v6);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

BOOL sub_1001FFAB8(uint64_t a1, uint64_t a2)
{
  return CFEqual(*(CFStringRef *)(a1 + 16), *(CFStringRef *)(a2 + 16));
}

void sub_1001FFAE4(void *a1)
{
  if (a1)
  {
    CFStringRef v2 = (const void *)a1[3];
    if (v2)
    {
      a1[3] = 0;
      CFRelease(v2);
    }
    uint64_t v3 = (const void *)a1[5];
    if (v3)
    {
      a1[5] = 0;
      CFRelease(v3);
    }
    uint64_t v4 = (const void *)a1[6];
    if (v4)
    {
      a1[6] = 0;
      CFRelease(v4);
    }
  }
}

CFMutableDataRef sub_1001FFB50(uint64_t a1)
{
  if (!*(void *)(a1 + 24))
  {
    SOSCreateErrorWithFormat();
    return 0;
  }
  CFMutableDataRef Mutable = CFDataCreateMutable(0, 0);
  if (!Mutable)
  {
    SOSCreateErrorWithFormat();
    return Mutable;
  }
  if (SecOTRSAppendSerialization())
  {
    SOSCreateErrorWithFormat();
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t sub_1001FFC14(uint64_t a1, void *a2)
{
  CFMutableDataRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  CFIndex v5 = *(const void **)(a1 + 24);
  if (!v5)
  {
    CFStringAppend(Mutable, @"*** no otr session ***");
    CFMutableDataRef v7 = 0;
    CFStringRef v6 = 0;
    goto LABEL_13;
  }
  CFStringRef v6 = CFCopyDescription(v5);
  if (*(unsigned char *)(a1 + 32))
  {
    CFStringRef v15 = @"waiting for peer to send first data packet";
LABEL_29:
    CFStringAppend(Mutable, v15);
    CFMutableDataRef v7 = 0;
    goto LABEL_12;
  }
  if (SecOTRSGetIsReadyForMessages())
  {
    CFStringAppend(Mutable, @"otr session ready");
    uint64_t v9 = 0;
    CFMutableDataRef v7 = 0;
    goto LABEL_17;
  }
  if ((SecOTRSGetIsIdle() & 1) == 0)
  {
    CFStringRef v15 = @"otr negotiating already";
    goto LABEL_29;
  }
  CFMutableDataRef v7 = CFDataCreateMutable(kCFAllocatorDefault, 0);
  if (v7)
  {
    if (SecOTRSAppendStartPacket())
    {
      SOSCreateErrorWithFormat();
      goto LABEL_13;
    }
    if (*(CFMutableDataRef *)(a1 + 40) != v7)
    {
      CFRetain(v7);
      uint64_t v8 = *(const void **)(a1 + 40);
      if (v8) {
        CFRelease(v8);
      }
      *(void *)(a1 + 40) = v7;
    }
LABEL_12:
    uint64_t v9 = 1;
    goto LABEL_17;
  }
  SOSCreateError();
LABEL_13:
  if (a2 && *a2) {
    CFStringAppendFormat(Mutable, 0, @" %@", *a2);
  }
  uint64_t v9 = 3;
LABEL_17:
  BOOL v10 = sub_10000B070("coder");
  if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
  {
    if (!v7) {
      goto LABEL_20;
    }
    goto LABEL_19;
  }
  uint64_t v12 = SecOTRPacketTypeString();
  uint64_t v13 = *(void *)(a1 + 24);
  uint64_t v14 = off_100308488[v9];
  *(_DWORD *)long long buf = 138413314;
  CFStringRef v17 = v6;
  __int16 v18 = 2080;
  uint64_t v19 = v12;
  __int16 v20 = 2112;
  CFDictionaryRef v21 = Mutable;
  __int16 v22 = 2112;
  uint64_t v23 = v13;
  __int16 v24 = 2080;
  uint64_t v25 = v14;
  _os_log_debug_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "%@ %s %@ %@ returned %s", buf, 0x34u);
  if (v7) {
LABEL_19:
  }
    CFRelease(v7);
LABEL_20:
  if (v6) {
    CFRelease(v6);
  }
  CFRelease(Mutable);
  return v9;
}

void sub_1001FFEA0(uint64_t a1)
{
  SecOTRSessionReset();
  *(unsigned char *)(a1 + 32) = 0;
  CFStringRef v2 = *(const void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 40) = 0;
    CFRelease(v2);
  }
  *(unsigned char *)(a1 + 56) = 0;
  uint64_t v3 = *(const void **)(a1 + 48);
  if (v3)
  {
    *(void *)(a1 + 4_Block_object_dispose(&a9, 8) = 0;
    CFRelease(v3);
  }
  CFIndex v4 = *(void *)ccsha1_di();
  CFMutableDataRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
  CFDataSetLength(Mutable, v4);
  *(void *)(a1 + 4_Block_object_dispose(&a9, 8) = Mutable;
}

uint64_t sub_1001FFF28(uint64_t a1)
{
  if (!*(void *)(a1 + 24)) {
    return 0;
  }
  CFMutableDataRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
  if (SecOTRSAppendRestartPacket())
  {
    uint64_t v5 = 3;
    if (!Mutable) {
      return v5;
    }
    goto LABEL_11;
  }
  uint64_t v3 = sub_10000B070("coder");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 138412290;
    CFMutableDataRef v8 = Mutable;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Resending OTR Start %@", (uint8_t *)&v7, 0xCu);
  }
  CFMutableDataRef v4 = *(CFMutableDataRef *)(a1 + 40);
  if (v4 != Mutable)
  {
    if (!Mutable || (CFRetain(Mutable), (CFMutableDataRef v4 = *(CFMutableDataRef *)(a1 + 40)) != 0)) {
      CFRelease(v4);
    }
    *(void *)(a1 + 40) = Mutable;
  }
  uint64_t v5 = 1;
  if (Mutable) {
LABEL_11:
  }
    CFRelease(Mutable);
  return v5;
}

void sub_100200054(char **a1, long long *a2)
{
  if (a2)
  {
    CFMutableDataRef v4 = a1[1];
    uint64_t v5 = (unint64_t *)(a1 + 1);
    unint64_t v6 = (unint64_t)(v4 + 1);
    if (a1[2] >= v4 + 1)
    {
      uint64_t v9 = *a1;
    }
    else
    {
      if (v6 > 0x100000)
      {
        int v7 = sub_10000B070("manifest");
        if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        int v15 = 134217984;
        unint64_t v16 = v6;
        CFMutableDataRef v8 = "Requesting too much space for digest vectors: %ld";
LABEL_14:
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v15, 0xCu);
        return;
      }
      uint64_t v10 = 1048476;
      if (v6 < 0xFFF9C) {
        uint64_t v10 = v6;
      }
      uint64_t v11 = v10 + 100;
      size_t v12 = 20 * (v10 + 100);
      uint64_t v9 = (char *)reallocf(*a1, v12);
      *a1 = v9;
      if (!v9)
      {
        unint64_t *v5 = 0;
        v5[1] = 0;
        int v7 = sub_10000B070("manifest");
        if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        int v15 = 134217984;
        unint64_t v16 = v12;
        CFMutableDataRef v8 = "reallocf failed requesting space for digest vectors: %ld (bytes)";
        goto LABEL_14;
      }
      a1[2] = (char *)v11;
      CFMutableDataRef v4 = a1[1];
      unint64_t v6 = (unint64_t)(v4 + 1);
    }
    unint64_t *v5 = v6;
    uint64_t v13 = &v9[20 * (void)v4];
    long long v14 = *a2;
    *((_DWORD *)v13 + 4) = *((_DWORD *)a2 + 4);
    *(_OWORD *)uint64_t v13 = v14;
  }
}

void sub_1002001D4(char **a1)
{
  if (*((unsigned char *)a1 + 24))
  {
    CFStringRef v2 = *a1;
    if (v2)
    {
      qsort(v2, (size_t)a1[1], 0x14uLL, (int (__cdecl *)(const void *, const void *))sub_100200394);
      *((unsigned char *)a1 + 24) = 0;
      uint64_t v3 = (uint64_t)a1[1];
      if ((unint64_t)v3 >= 2)
      {
        CFMutableDataRef v4 = *a1;
        if (*a1)
        {
          uint64_t v5 = v4 + 20;
          unint64_t v6 = (unint64_t)&v4[20 * v3];
          if (v3 >= 2)
          {
            int v7 = v4 + 20;
            CFMutableDataRef v8 = v4 + 20;
            while (1)
            {
              if (v4)
              {
                unint64_t v9 = bswap64(*(void *)v4);
                unint64_t v10 = bswap64(*(void *)v5);
                if (v9 == v10)
                {
                  unint64_t v9 = bswap64(*((void *)v4 + 1));
                  unint64_t v10 = bswap64(*((void *)v5 + 1));
                  if (v9 == v10)
                  {
                    unint64_t v9 = bswap32(*((_DWORD *)v4 + 4));
                    unint64_t v10 = bswap32(*((_DWORD *)v5 + 4));
                    if (v9 == v10)
                    {
                      int v11 = 0;
LABEL_17:
                      if (!v11)
                      {
                        size_t v12 = v4 + 20;
                        uint64_t v13 = v4 + 20 - v7;
                        if (v8 != v7) {
                          memmove(v8, v7, v4 + 20 - v7);
                        }
                        v8 += v13;
                        long long v14 = v5 + 20;
                        do
                        {
                          int v7 = (char *)v14;
                          if ((unint64_t)v14 >= v6) {
                            break;
                          }
                          BOOL v15 = *(void *)v12 == *v14 && *((void *)v12 + 1) == v14[1];
                          BOOL v16 = v15 && *((_DWORD *)v12 + 4) == (unint64_t)*((unsigned int *)v14 + 4);
                          long long v14 = (void *)((char *)v14 + 20);
                        }
                        while (v16);
                        uint64_t v5 = v7;
                        CFMutableDataRef v4 = v7;
                      }
                      goto LABEL_30;
                    }
                  }
                }
                if (v9 < v10) {
                  int v11 = -1;
                }
                else {
                  int v11 = 1;
                }
                if ((v11 & 0x80000000) == 0) {
                  goto LABEL_17;
                }
                CFMutableDataRef v4 = v5;
              }
LABEL_30:
              v5 += 20;
              if ((unint64_t)v5 >= v6) {
                goto LABEL_33;
              }
            }
          }
          CFMutableDataRef v8 = v4 + 20;
          int v7 = v4 + 20;
LABEL_33:
          if ((unint64_t)v7 < v6)
          {
            uint64_t v17 = v4 - v7;
            uint64_t v18 = v17 + 20;
            if (v8 != v7) {
              memmove(v8, v7, v17 + 20);
            }
            v8 += v18;
          }
          a1[1] = (char *)((v8 - *a1) / 0x14uLL);
        }
      }
    }
  }
}

uint64_t sub_100200394(uint64_t a1, uint64_t a2)
{
  if (a1 && a2)
  {
    unint64_t v2 = bswap64(*(void *)a1);
    unint64_t v3 = bswap64(*(void *)a2);
    if (v2 == v3
      && (v2 = bswap64(*(void *)(a1 + 8)), unint64_t v3 = bswap64(*(void *)(a2 + 8)), v2 == v3)
      && (v2 = bswap32(*(_DWORD *)(a1 + 16)), unint64_t v3 = bswap32(*(_DWORD *)(a2 + 16)), v2 == v3))
    {
      return 0;
    }
    else if (v2 < v3)
    {
      return 0xFFFFFFFFLL;
    }
    else
    {
      return 1;
    }
  }
  else if (a1)
  {
    return 0xFFFFFFFFLL;
  }
  else
  {
    return a2 != 0;
  }
}

unint64_t sub_100200410(unint64_t result, unint64_t a2, uint64_t a3)
{
  if (a2)
  {
    uint64_t v5 = (char **)result;
    unint64_t v6 = 0;
    for (CFIndex i = (long long *)a3; ; CFIndex i = (long long *)(a3 + 20 * result))
    {
      sub_100200054(v5, i);
      CFStringRef result = sub_100200488(a3, a2, v6);
      if (result >= a2) {
        break;
      }
      unint64_t v6 = result;
    }
  }
  return result;
}

unint64_t sub_100200488(uint64_t a1, unint64_t a2, unint64_t a3)
{
  if (a1 && a3 < a2)
  {
    uint64_t v3 = a1 + 20 * a3;
    uint64_t v4 = v3 + 20;
    while (a2 - 1 != a3)
    {
      ++a3;
      BOOL v6 = *(void *)v3 == *(void *)v4
        && *(void *)(v3 + 8) == *(void *)(v4 + 8)
        && *(_DWORD *)(v3 + 16) == (unint64_t)*(unsigned int *)(v4 + 16);
      v4 += 20;
      if (!v6) {
        return a3;
      }
    }
    return a2;
  }
  return a3;
}

unint64_t sub_1002004E4(uint64_t *a1, uint64_t a2, char **a3)
{
  unint64_t v6 = a1[1];
  if (v6 && *(void *)(a2 + 8))
  {
    unint64_t v7 = 0;
    unint64_t v8 = 0;
    while (1)
    {
      uint64_t v9 = *a1 + 20 * v7;
      uint64_t v10 = *(void *)a2;
      uint64_t v11 = *(void *)a2 + 20 * v8;
      if (*a1) {
        BOOL v12 = v10 == 0;
      }
      else {
        BOOL v12 = 1;
      }
      if (v12)
      {
        int v13 = v10 != 0;
        if (*a1) {
          goto LABEL_21;
        }
      }
      else
      {
        unint64_t v14 = bswap64(*(void *)v9);
        unint64_t v15 = bswap64(*(void *)v11);
        if (v14 == v15
          && (v14 = bswap64(*(void *)(v9 + 8)), unint64_t v15 = bswap64(*(void *)(v11 + 8)), v14 == v15)
          && (v14 = bswap32(*(_DWORD *)(v9 + 16)), unint64_t v15 = bswap32(*(_DWORD *)(v11 + 16)), v14 == v15))
        {
          int v13 = 0;
        }
        else if (v14 < v15)
        {
          int v13 = -1;
        }
        else
        {
          int v13 = 1;
        }
      }
      if (v13)
      {
        if ((v13 & 0x80000000) == 0)
        {
          sub_100200054(a3, (long long *)(*(void *)a2 + 20 * v8));
          unint64_t v8 = sub_100200488(*(void *)a2, *(void *)(a2 + 8), v8);
          unint64_t v6 = a1[1];
          goto LABEL_23;
        }
LABEL_21:
        sub_100200054(a3, (long long *)v9);
        unint64_t v6 = a1[1];
        unint64_t v7 = sub_100200488(*a1, v6, v7);
        goto LABEL_23;
      }
      sub_100200054(a3, (long long *)v9);
      unint64_t v6 = a1[1];
      unint64_t v7 = sub_100200488(*a1, v6, v7);
      unint64_t v8 = sub_100200488(*(void *)a2, *(void *)(a2 + 8), v8);
LABEL_23:
      if (v7 >= v6 || v8 >= *(void *)(a2 + 8)) {
        goto LABEL_27;
      }
    }
  }
  unint64_t v7 = 0;
  unint64_t v8 = 0;
LABEL_27:
  sub_100200410((unint64_t)a3, v6 - v7, *a1 + 20 * v7);
  unint64_t v16 = *(void *)(a2 + 8) - v8;
  uint64_t v17 = *(void *)a2 + 20 * v8;

  return sub_100200410((unint64_t)a3, v16, v17);
}

unint64_t sub_100200698(unint64_t result, unint64_t *a2, unint64_t a3, uint64_t *a4, char **a5)
{
  unint64_t v8 = a2[1];
  if (v8 > result)
  {
    unint64_t v10 = result;
    unint64_t v11 = a4[1];
    do
    {
      if (a3 >= v11) {
        break;
      }
      CFStringRef result = *a2;
      if (!*a2) {
        break;
      }
      uint64_t v12 = *a4;
      if (!*a4) {
        return result;
      }
      unint64_t v13 = result + 20 * v10;
      unint64_t v14 = v12 + 20 * a3;
      unint64_t v15 = bswap64(*(void *)v13);
      unint64_t v16 = bswap64(*(void *)v14);
      if (v15 != v16) {
        goto LABEL_10;
      }
      unint64_t v15 = bswap64(*(void *)(v13 + 8));
      unint64_t v16 = bswap64(*(void *)(v14 + 8));
      if (v15 == v16 && (unint64_t v15 = bswap32(*(_DWORD *)(v13 + 16)), v16 = bswap32(*(_DWORD *)(v14 + 16)), v15 == v16))
      {
        unint64_t v10 = sub_100200488(result, v8, v10);
        CFStringRef result = sub_100200488(v12, v11, a3);
        a3 = result;
      }
      else
      {
LABEL_10:
        int v17 = v15 < v16 ? -1 : 1;
        if (v17 < 0)
        {
          CFStringRef result = sub_100200488(result, v8, v10);
          unint64_t v10 = result;
        }
        else
        {
          sub_100200054(a5, (long long *)v14);
          unint64_t v11 = a4[1];
          CFStringRef result = sub_100200488(*a4, v11, a3);
          a3 = result;
          unint64_t v8 = a2[1];
        }
      }
    }
    while (v10 < v8);
  }
  if (*a4)
  {
    unint64_t v18 = a4[1] - a3;
    uint64_t v19 = *a4 + 20 * a3;
    return sub_100200410((unint64_t)a5, v18, v19);
  }
  return result;
}

unint64_t sub_10020082C(uint64_t *a1, unint64_t *a2, uint64_t a3, char **a4)
{
  uint64_t v5 = a2;
  unint64_t v6 = a1;
  if (!a1[1])
  {
    unint64_t v9 = 0;
    unint64_t v8 = 0;
    unint64_t v7 = 0;
    goto LABEL_52;
  }
  unint64_t v7 = 0;
  unint64_t v8 = 0;
  unint64_t v9 = 0;
  do
  {
    if (v8 >= *(void *)(a3 + 8)) {
      break;
    }
    uint64_t v10 = *v6 + 20 * v9;
    uint64_t v11 = *(void *)a3;
    uint64_t v12 = *(void *)a3 + 20 * v8;
    if (*v6) {
      BOOL v13 = v11 == 0;
    }
    else {
      BOOL v13 = 1;
    }
    if (v13)
    {
      int v14 = v11 != 0;
      if (!*v6) {
        goto LABEL_20;
      }
      int v14 = -1;
    }
    else
    {
      unint64_t v15 = bswap64(*(void *)v10);
      unint64_t v16 = bswap64(*(void *)v12);
      if (v15 == v16)
      {
        unint64_t v15 = bswap64(*(void *)(v10 + 8));
        unint64_t v16 = bswap64(*(void *)(v12 + 8));
        if (v15 == v16)
        {
          unint64_t v15 = bswap32(*(_DWORD *)(v10 + 16));
          unint64_t v16 = bswap32(*(_DWORD *)(v12 + 16));
          if (v15 == v16)
          {
            int v14 = 0;
LABEL_20:
            int v30 = 0;
            goto LABEL_21;
          }
        }
      }
      if (v15 < v16) {
        int v14 = -1;
      }
      else {
        int v14 = 1;
      }
      if ((v14 & 0x80000000) == 0) {
        goto LABEL_20;
      }
    }
    int v30 = 1;
    uint64_t v12 = *v6 + 20 * v9;
LABEL_21:
    unint64_t v17 = v5[1];
    if (v7 >= v17) {
      goto LABEL_42;
    }
    uint64_t v18 = *v5;
    if (v12) {
      BOOL v19 = v18 == 0;
    }
    else {
      BOOL v19 = 1;
    }
    char v20 = !v19;
    while ((v20 & 1) != 0)
    {
      unint64_t v21 = v18 + 20 * v7;
      unint64_t v22 = bswap64(*(void *)v21);
      unint64_t v23 = bswap64(*(void *)v12);
      if (v22 == v23)
      {
        unint64_t v22 = bswap64(*(void *)(v21 + 8));
        unint64_t v23 = bswap64(*(void *)(v12 + 8));
        if (v22 == v23)
        {
          unint64_t v22 = bswap32(*(_DWORD *)(v21 + 16));
          unint64_t v23 = bswap32(*(_DWORD *)(v12 + 16));
          if (v22 == v23)
          {
            int v24 = 0;
            goto LABEL_41;
          }
        }
      }
      if (v22 < v23) {
        int v24 = -1;
      }
      else {
        int v24 = 1;
      }
      if ((v24 & 0x80000000) == 0) {
        goto LABEL_41;
      }
LABEL_39:
      unint64_t v7 = sub_100200488(v18, v17, v7);
      if (v7 >= v17) {
        goto LABEL_43;
      }
    }
    if (v18) {
      goto LABEL_39;
    }
    int v24 = v12 != 0;
LABEL_41:
    if (!v24)
    {
      unint64_t v7 = sub_100200488(v18, v17, v7);
      if (v14) {
        goto LABEL_44;
      }
LABEL_48:
      unint64_t v6 = a1;
      unint64_t v25 = a1[1];
      unint64_t v9 = sub_100200488(*a1, v25, v9);
      unint64_t v8 = sub_100200488(*(void *)a3, *(void *)(a3 + 8), v8);
      uint64_t v5 = a2;
      continue;
    }
LABEL_42:
    sub_100200054(a4, (long long *)v12);
LABEL_43:
    if (!v14) {
      goto LABEL_48;
    }
LABEL_44:
    uint64_t v5 = a2;
    if (v30)
    {
      unint64_t v6 = a1;
      unint64_t v25 = a1[1];
      unint64_t v9 = sub_100200488(*a1, v25, v9);
    }
    else
    {
      unint64_t v8 = sub_100200488(*(void *)a3, *(void *)(a3 + 8), v8);
      unint64_t v6 = a1;
      unint64_t v25 = a1[1];
    }
  }
  while (v9 < v25);
LABEL_52:
  sub_100200698(v7, v5, v9, v6, a4);

  return sub_100200698(v7, v5, v8, (uint64_t *)a3, a4);
}

uint64_t sub_100200AFC()
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100200B94;
  block[3] = &unk_100308508;
  void block[4] = &qword_10035D380;
  if (qword_10035D378 != -1) {
    dispatch_once(&qword_10035D378, block);
  }
  return qword_10035D380;
}

uint64_t sub_100200B94(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

__CFString *sub_100200BC8(CFDataRef *a1)
{
  sub_100025824();

  return sub_100200C00(a1);
}

__CFString *sub_100200C00(CFDataRef *a1)
{
  CFMutableDataRef Mutable = CFStringCreateMutable(0, 0);
  if (!a1)
  {
    unint64_t v6 = 0;
LABEL_6:
    CFStringAppendFormat(Mutable, 0, @"<[%zu]", v6);
    goto LABEL_7;
  }
  if ((unint64_t)CFDataGetLength(a1[3]) < 0xA0)
  {
    unint64_t v6 = CFDataGetLength(a1[3]) / 0x14uLL;
    goto LABEL_6;
  }
  uint64_t v3 = sub_100200D6C((__CFData *)a1);
  BytePtr = CFDataGetBytePtr(v3);
  unint64_t Length = CFDataGetLength(a1[3]);
  CFStringAppendFormat(Mutable, 0, @"<[%zu:%02X%02X%02X%02X]", Length / 0x14, *BytePtr, BytePtr[1], BytePtr[2], BytePtr[3]);
LABEL_7:
  v9[0] = 0;
  v9[1] = v9;
  _DWORD v9[2] = 0x2000000000;
  v9[3] = 8;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  _DWORD v8[2] = sub_100200DE4;
  v8[3] = &unk_100308530;
  void v8[4] = v9;
  void v8[5] = Mutable;
  sub_100200E78((uint64_t)a1, (uint64_t)v8);
  CFStringAppend(Mutable, @">");
  _Block_object_dispose(v9, 8);
  return Mutable;
}

__CFData *sub_100200D6C(__CFData *result)
{
  if (result)
  {
    CFDataRef v1 = result;
    uint64_t result = (__CFData *)*((void *)result + 2);
    if (!result)
    {
      CFDataGetLength(*((CFDataRef *)v1 + 3));
      CFDataGetBytePtr(*((CFDataRef *)v1 + 3));
      unint64_t v2 = (CFIndex *)ccsha1_di();
      uint64_t result = sub_100029BEC(kCFAllocatorDefault, v2);
      *((void *)v1 + 2) = result;
    }
  }
  return result;
}

void sub_100200DE4(uint64_t a1, CFDataRef theData, unsigned char *a3)
{
  BytePtr = CFDataGetBytePtr(theData);
  CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 40), 0, @" %02X%02X%02X%02X", *BytePtr, BytePtr[1], BytePtr[2], BytePtr[3]);
  uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v7 = *(void *)(v6 + 24) - 1;
  *(void *)(v6 + 24) = v7;
  if (!v7)
  {
    CFStringAppend(*(CFMutableStringRef *)(a1 + 40), @"...");
    *a3 = 1;
  }
}

void sub_100200E78(uint64_t a1, uint64_t a2)
{
  char v11 = 0;
  if (a1)
  {
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 24));
    CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 24));
    if (Length >= 20)
    {
      uint64_t v6 = &BytePtr[Length];
      do
      {
        CFDataRef v7 = CFDataCreate(kCFAllocatorDefault, BytePtr, 20);
        if (v7)
        {
          CFDataRef v8 = v7;
          (*(void (**)(uint64_t, CFDataRef, char *))(a2 + 16))(a2, v7, &v11);
          CFRelease(v8);
        }
        unint64_t v9 = BytePtr + 40;
        BytePtr += 20;
        if (v11) {
          BOOL v10 = 1;
        }
        else {
          BOOL v10 = v9 > v6;
        }
      }
      while (!v10);
    }
  }
}

BOOL sub_100200F38(__CFData *a1, __CFData *a2)
{
  uint64_t v3 = sub_100200D6C(a1);
  uint64_t v4 = sub_100200D6C(a2);
  if (v3 && v4) {
    return CFEqual(v3, v4) != 0;
  }
  else {
    return v3 == v4;
  }
}

void sub_100200F90(uint64_t a1)
{
  unint64_t v2 = *(const void **)(a1 + 16);
  if (v2) {
    CFRelease(v2);
  }
  uint64_t v3 = *(const void **)(a1 + 24);
  if (v3)
  {
    CFRelease(v3);
  }
}

uint64_t sub_100200FE0(const __CFData *a1, CFTypeRef *a2)
{
  sub_100200AFC();
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (Instance)
  {
    if (a1) {
      CFDataRef Copy = CFDataCreateCopy(kCFAllocatorDefault, a1);
    }
    else {
      CFDataRef Copy = CFDataCreate(kCFAllocatorDefault, 0, 0);
    }
    *(void *)(Instance + 24) = Copy;
  }
  else
  {
    sub_1000297A0(2, @"com.apple.security.sos.manifest.error", 0, a2, v4, @"Failed to create manifest");
  }
  return Instance;
}

uint64_t sub_100201084(UInt8 *bytes, CFIndex length, CFTypeRef *a3)
{
  CFDataRef v4 = CFDataCreate(kCFAllocatorDefault, bytes, length);
  uint64_t v5 = sub_100200FE0(v4, a3);
  if (v4) {
    CFRelease(v4);
  }
  return v5;
}

void *sub_1002010DC(uint64_t a1)
{
  if (!a1) {
    return &unk_10035D388;
  }
  unint64_t Length = CFDataGetLength(*(CFDataRef *)(a1 + 24));
  *(void *)(a1 + 40) = Length / 0x14;
  *(void *)(a1 + 4_Block_object_dispose(&a9, 8) = Length / 0x14;
  *(void *)(a1 + 32) = CFDataGetBytePtr(*(CFDataRef *)(a1 + 24));
  uint64_t v3 = a1 + 32;
  *(unsigned char *)(v3 + 24) = 0;
  return (void *)v3;
}

uint64_t sub_10020113C(uint64_t a1, uint64_t a2, uint64_t *a3, const void **a4, CFTypeRef *a5)
{
  if (a1 && (unint64_t)CFDataGetLength(*(CFDataRef *)(a1 + 24)) > 0x13)
  {
    if (!a2 || (unint64_t)CFDataGetLength(*(CFDataRef *)(a2 + 24)) <= 0x13)
    {
      BOOL v10 = (const void *)sub_100201084(0, 0, a5);
      if (a3)
      {
        CFRetain((CFTypeRef)a1);
        *a3 = a1;
      }
      if (a4)
      {
        unint64_t v15 = *a4;
        if (*a4 != v10)
        {
          if (!v10 || (CFRetain(v10), (unint64_t v15 = *a4) != 0)) {
            CFRelease(v15);
          }
          *a4 = v10;
        }
      }
      goto LABEL_16;
    }
    *(_OWORD *)CFSetRef v34 = 0u;
    long long v35 = 0u;
    *(_OWORD *)CFMutableArrayRef v32 = 0u;
    long long v33 = 0u;
    unint64_t Length = CFDataGetLength(*(CFDataRef *)(a1 + 24));
    *(void *)(a1 + 40) = Length / 0x14;
    *(void *)(a1 + 4_Block_object_dispose(&a9, 8) = Length / 0x14;
    *(void *)(a1 + 32) = CFDataGetBytePtr(*(CFDataRef *)(a1 + 24));
    *(unsigned char *)(a1 + 56) = 0;
    unint64_t v17 = CFDataGetLength(*(CFDataRef *)(a2 + 24));
    *(void *)(a2 + 40) = v17 / 0x14;
    *(void *)(a2 + 4_Block_object_dispose(&a9, 8) = v17 / 0x14;
    *(void *)(a2 + 32) = CFDataGetBytePtr(*(CFDataRef *)(a2 + 24));
    *(unsigned char *)(a2 + 56) = 0;
    unint64_t v18 = *(void *)(a1 + 40);
    if (v18)
    {
      unint64_t v19 = 0;
      unint64_t v20 = 0;
      while (1)
      {
        unint64_t v21 = *(void *)(a2 + 40);
        if (v19 >= v21) {
          goto LABEL_55;
        }
        uint64_t v22 = *(void *)(a1 + 32);
        unint64_t v23 = v22 + 20 * v20;
        uint64_t v24 = *(void *)(a2 + 32);
        unint64_t v25 = v24 + 20 * v19;
        if (v22) {
          BOOL v26 = v24 == 0;
        }
        else {
          BOOL v26 = 1;
        }
        if (v26)
        {
          int v27 = v24 != 0;
          if (v22) {
            goto LABEL_50;
          }
        }
        else
        {
          unint64_t v28 = bswap64(*(void *)v23);
          unint64_t v29 = bswap64(*(void *)v25);
          if (v28 == v29
            && (unint64_t v28 = bswap64(*(void *)(v23 + 8)), v29 = bswap64(*(void *)(v25 + 8)), v28 == v29)
            && (unint64_t v28 = bswap32(*(_DWORD *)(v23 + 16)), v29 = bswap32(*(_DWORD *)(v25 + 16)), v28 == v29))
          {
            int v27 = 0;
          }
          else if (v28 < v29)
          {
            int v27 = -1;
          }
          else
          {
            int v27 = 1;
          }
        }
        if (!v27)
        {
          unint64_t v20 = sub_100200488(v22, v18, v20);
          unint64_t v19 = sub_100200488(v24, v21, v19);
          goto LABEL_52;
        }
        if (v27 < 0)
        {
LABEL_50:
          sub_100200054((char **)v34, (long long *)v23);
          unint64_t v18 = *(void *)(a1 + 40);
          unint64_t v20 = sub_100200488(*(void *)(a1 + 32), v18, v20);
          goto LABEL_52;
        }
        sub_100200054((char **)v32, (long long *)(v24 + 20 * v19));
        unint64_t v19 = sub_100200488(*(void *)(a2 + 32), *(void *)(a2 + 40), v19);
        unint64_t v18 = *(void *)(a1 + 40);
LABEL_52:
        if (v20 >= v18) {
          goto LABEL_55;
        }
      }
    }
    unint64_t v20 = 0;
    unint64_t v19 = 0;
LABEL_55:
    sub_100200410((unint64_t)v34, v18 - v20, *(void *)(a1 + 32) + 20 * v20);
    sub_100200410((unint64_t)v32, *(void *)(a2 + 40) - v19, *(void *)(a2 + 32) + 20 * v19);
    if (a3)
    {
      uint64_t v30 = sub_100201498((uint64_t)v34, a5);
      *a3 = v30;
      uint64_t v13 = v30 != 0;
      if (a4) {
        goto LABEL_57;
      }
    }
    else
    {
      uint64_t v13 = 1;
      if (a4)
      {
LABEL_57:
        uint64_t v31 = sub_100201498((uint64_t)v32, a5);
        *a4 = (const void *)v31;
        if (v31) {
          uint64_t v13 = v13;
        }
        else {
          uint64_t v13 = 0;
        }
      }
    }
    free(v34[0]);
    v34[0] = 0;
    v34[1] = 0;
    BYTE8(v35) = 0;
    *(void *)&long long v35 = 0;
    free(v32[0]);
    return v13;
  }
  BOOL v10 = (const void *)sub_100201084(0, 0, a5);
  if (a3)
  {
    char v11 = (const void *)*a3;
    if ((const void *)*a3 != v10)
    {
      if (!v10 || (CFRetain(v10), (char v11 = (const void *)*a3) != 0)) {
        CFRelease(v11);
      }
      *a3 = (uint64_t)v10;
    }
  }
  if (a4)
  {
    if (a2) {
      uint64_t v12 = (const void *)a2;
    }
    else {
      uint64_t v12 = v10;
    }
    if (v12) {
      CFRetain(v12);
    }
    *a4 = v12;
  }
LABEL_16:
  if (v10) {
    CFRelease(v10);
  }
  return 1;
}

uint64_t sub_100201498(uint64_t result, CFTypeRef *a2)
{
  if (result)
  {
    uint64_t v3 = result;
    if (*(unsigned char *)(result + 24)) {
      sub_1002001D4((char **)result);
    }
    CFDataRef v4 = *(UInt8 **)v3;
    CFIndex v5 = 20 * *(void *)(v3 + 8);
    return sub_100201084(v4, v5, a2);
  }
  return result;
}

uint64_t sub_1002014F4(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  *(_OWORD *)uint64_t v12 = 0u;
  long long v13 = 0u;
  CFDataRef v7 = (uint64_t *)sub_1002010DC(a1);
  CFDataRef v8 = (unint64_t *)sub_1002010DC(a2);
  unint64_t v9 = sub_1002010DC(a3);
  sub_10020082C(v7, v8, (uint64_t)v9, (char **)v12);
  uint64_t v10 = sub_100201498((uint64_t)v12, a4);
  free(v12[0]);
  return v10;
}

CFTypeRef sub_100201580(uint64_t a1, CFTypeRef cf, CFTypeRef *a3)
{
  if (a1 && (unint64_t)CFDataGetLength(*(CFDataRef *)(a1 + 24)) > 0x13)
  {
    *(_OWORD *)uint64_t v10 = 0u;
    long long v11 = 0u;
    unint64_t Length = CFDataGetLength(*(CFDataRef *)(a1 + 24));
    *(void *)(a1 + 40) = Length / 0x14;
    *(void *)(a1 + 4_Block_object_dispose(&a9, 8) = Length / 0x14;
    *(void *)(a1 + 32) = CFDataGetBytePtr(*(CFDataRef *)(a1 + 24));
    uint64_t v7 = a1 + 32;
    *(unsigned char *)(v7 + 24) = 0;
    CFDataRef v8 = (uint64_t *)sub_1002010DC((uint64_t)cf);
    sub_100200698(0, (unint64_t *)v7, 0, v8, (char **)v10);
    CFTypeRef cf = (CFTypeRef)sub_100201498((uint64_t)v10, a3);
    free(v10[0]);
    return cf;
  }
  if (cf)
  {
    CFRetain(cf);
    return cf;
  }

  return (CFTypeRef)sub_100201084(0, 0, a3);
}

uint64_t sub_10020167C(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  *(_OWORD *)unint64_t v23 = 0u;
  long long v24 = 0u;
  CFIndex v5 = (uint64_t *)sub_1002010DC(a1);
  uint64_t v6 = (uint64_t *)sub_1002010DC(a2);
  unint64_t v7 = v5[1];
  if (v7)
  {
    CFDataRef v8 = v6;
    unint64_t v9 = 0;
    unint64_t v10 = 0;
    unint64_t v11 = v6[1];
    do
    {
      if (v9 >= v11) {
        break;
      }
      uint64_t v12 = *v5;
      uint64_t v13 = *v5 + 20 * v10;
      uint64_t v14 = *v8;
      if (*v5) {
        BOOL v15 = v14 == 0;
      }
      else {
        BOOL v15 = 1;
      }
      if (v15)
      {
        int v16 = v14 != 0;
        if (v12) {
          goto LABEL_21;
        }
      }
      else
      {
        unint64_t v17 = v14 + 20 * v9;
        unint64_t v18 = bswap64(*(void *)v13);
        unint64_t v19 = bswap64(*(void *)v17);
        if (v18 == v19
          && (unint64_t v18 = bswap64(*(void *)(v13 + 8)), v19 = bswap64(*(void *)(v17 + 8)), v18 == v19)
          && (unint64_t v18 = bswap32(*(_DWORD *)(v13 + 16)), v19 = bswap32(*(_DWORD *)(v17 + 16)), v18 == v19))
        {
          int v16 = 0;
        }
        else if (v18 < v19)
        {
          int v16 = -1;
        }
        else
        {
          int v16 = 1;
        }
      }
      if (!v16)
      {
        sub_100200054((char **)v23, (long long *)v13);
        unint64_t v7 = v5[1];
        unint64_t v10 = sub_100200488(*v5, v7, v10);
        uint64_t v20 = *v8;
        unint64_t v11 = v8[1];
        goto LABEL_23;
      }
      if ((v16 & 0x80000000) == 0)
      {
        uint64_t v20 = *v8;
LABEL_23:
        unint64_t v9 = sub_100200488(v20, v11, v9);
        continue;
      }
LABEL_21:
      unint64_t v10 = sub_100200488(v12, v7, v10);
    }
    while (v10 < v7);
  }
  uint64_t v21 = sub_100201498((uint64_t)v23, a3);
  free(v23[0]);
  return v21;
}

CFDataRef *sub_100201804(uint64_t a1, CFDataRef *cf, CFTypeRef *a3)
{
  if (a1)
  {
    uint64_t v5 = a1;
    if ((unint64_t)CFDataGetLength(*(CFDataRef *)(a1 + 24)) > 0x13)
    {
      if (cf && (unint64_t)CFDataGetLength(cf[3]) > 0x13)
      {
        *(_OWORD *)unint64_t v11 = 0u;
        long long v12 = 0u;
        unint64_t Length = CFDataGetLength(*(CFDataRef *)(v5 + 24));
        *(void *)(v5 + 40) = Length / 0x14;
        *(void *)(v5 + 4_Block_object_dispose(&a9, 8) = Length / 0x14;
        *(void *)(v5 + 32) = CFDataGetBytePtr(*(CFDataRef *)(v5 + 24));
        uint64_t v8 = v5 + 32;
        *(unsigned char *)(v8 + 24) = 0;
        unint64_t v9 = CFDataGetLength(cf[3]);
        cf[5] = (CFDataRef)(v9 / 0x14);
        cf[6] = (CFDataRef)(v9 / 0x14);
        cf[4] = (CFDataRef)CFDataGetBytePtr(cf[3]);
        unint64_t v10 = (char *)(cf + 4);
        v10[24] = 0;
        sub_1002004E4((uint64_t *)v8, (uint64_t)v10, (char **)v11);
        uint64_t v5 = sub_100201498((uint64_t)v11, a3);
        free(v11[0]);
      }
      else
      {
        CFRetain((CFTypeRef)v5);
      }
      return (CFDataRef *)v5;
    }
  }
  if (cf)
  {
    CFRetain(cf);
    return cf;
  }

  return (CFDataRef *)sub_100201084(0, 0, a3);
}

id sub_1002019E0(uint64_t a1)
{
  return [*(id *)(a1 + 32) onqueueFreeHashBuff];
}

void sub_100201ABC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

unsigned __int8 *sub_100201AD4(const __CFDictionary *a1)
{
  CFDataRef v1 = (unsigned __int8 *)a1;
  if (a1)
  {
    CFTypeRef v11 = 0;
    uint64_t v2 = sub_10000B67C(a1, (uint64_t)&v11);
    if (v2)
    {
      size_t v3 = v2;
      CFDataRef v4 = (char *)&v10 - ((__chkstk_darwin() + 15) & 0xFFFFFFFFFFFFFFF0);
      memset(v4, 170, v3);
      if (sub_10000B6E8((const __CFDictionary *)v1, &v11, 0))
      {
        CFDataRef v1 = (unsigned __int8 *)malloc_type_malloc(0x20uLL, 0x504AE331uLL);
        CC_SHA256(v4, v3, v1);
      }
      else
      {
        unint64_t v7 = sub_10000B070("key-interests");
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          CFTypeRef v13 = v11;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Failed to DER encode dictionary - %@", buf, 0xCu);
        }

        CFTypeRef v8 = v11;
        if (v11)
        {
          CFTypeRef v11 = 0;
          CFRelease(v8);
        }
        return 0;
      }
    }
    else
    {
      uint64_t v5 = sub_10000B070("key-interests");
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        CFTypeRef v13 = v11;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Failed to get size of dictionary - %@", buf, 0xCu);
      }

      CFTypeRef v6 = v11;
      if (v11)
      {
        CFTypeRef v11 = 0;
        CFRelease(v6);
      }
      return 0;
    }
  }
  return v1;
}

void sub_100201CB8(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  size_t v3 = (uint64_t *)v2[1];
  CFDataRef v4 = *(void **)(a1 + 48);
  if (v3)
  {
    if (!v4) {
      goto LABEL_16;
    }
    uint64_t v5 = *v3;
    uint64_t v6 = v3[1];
    uint64_t v8 = v3[2];
    uint64_t v7 = v3[3];
    BOOL v9 = *v4 == v5 && v4[1] == v6;
    BOOL v10 = v9 && v4[2] == v8;
    if (!v10 || v4[3] != v7) {
      goto LABEL_16;
    }
    free(*(void **)(a1 + 48));
    LOBYTE(v4) = 0;
  }
  else if (v4)
  {
LABEL_16:
    [v2 onqueueFreeHashBuff];
    *(void *)(*(void *)(a1 + 32) + _Block_object_dispose(&a9, 8) = *(void *)(a1 + 48);
    LOBYTE(v4) = 1;
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = (_BYTE)v4;
}

uint64_t sub_100201E3C(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  if (a3 <= 5 && (unint64_t)a3 - 5 < 0xFFFFFFFFFFFFFFFDLL && (CFDataRef v4 = off_100308578[a3][2]) != 0)
  {
    return ((uint64_t (*)(uint64_t, uint64_t, uint64_t))v4)(a1, a2, a4);
  }
  else
  {
    SOSCreateError();
    return 0;
  }
}

uint64_t sub_100201EB0(void *a1, uint64_t a2, uint64_t a3)
{
  sub_1001EE2BC(a1);
  unsigned int v6 = sub_10022F62C(a1);
  if (v6 > 5 || (unint64_t)v6 - 5 >= 0xFFFFFFFFFFFFFFFDLL)
  {
    SOSCreateError();
    return 0;
  }
  else
  {
    uint64_t v7 = off_100308578[v6][8];
    if (v7)
    {
      return ((uint64_t (*)(void *, void, uint64_t, uint64_t))v7)(a1, 0, a2, a3);
    }
    else
    {
      return 1;
    }
  }
}

uint64_t sub_100201F6C(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  sub_1001EE2BC(a1);
  unsigned int v8 = sub_10022F62C(a1);
  if (v8 <= 5 && (unint64_t)v8 - 5 < 0xFFFFFFFFFFFFFFFDLL && (BOOL v9 = off_100308578[v8][13]) != 0)
  {
    return ((uint64_t (*)(void *, void, uint64_t, uint64_t, uint64_t))v9)(a1, 0, a2, a3, a4);
  }
  else
  {
    SOSCreateError();
    return 0;
  }
}

uint64_t sub_100202028(void *a1, uint64_t a2)
{
  sub_1001EE2BC(a1);
  unsigned int v4 = sub_10022F62C(a1);
  if (v4 <= 5 && (unint64_t)v4 - 5 < 0xFFFFFFFFFFFFFFFDLL && (uint64_t v5 = off_100308578[v4][14]) != 0)
  {
    return ((uint64_t (*)(void *, uint64_t))v5)(a1, a2);
  }
  else
  {
    SOSCreateError();
    return 0;
  }
}

const void *sub_1002020D4(void *a1)
{
  sub_1001EE2BC(a1);
  if (sub_10022F62C(a1) == 1)
  {
    return sub_10022F800((uint64_t)a1);
  }
  else
  {
    SOSCreateError();
    return 0;
  }
}

uint64_t sub_100202144(uint64_t result, CFTypeRef cf)
{
  CFTypeRef v2 = cf;
  uint64_t v3 = result;
  unsigned int v4 = *(__CFString ***)(result + 40);
  if (!cf || (v5 = CFGetTypeID(cf), uint64_t result = CFStringGetTypeID(), v5 != result))
  {
    if (v4) {
      uint64_t result = sub_100012A40(-50, v4, @"object %@ is not a string", v2);
    }
    CFTypeRef v2 = 0;
  }
  *(void *)(*(void *)(*(void *)(v3 + 32) + 8) + 24) = v2;
  return result;
}

uint64_t sub_1002021C4(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_1002021DC(void *a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5)
{
  sub_1001EE2BC(a1);
  if (!sub_100202288(a1)) {
    return 0;
  }
  uint64_t v9 = SOSBSKBCopyEncoded();
  if (!v9) {
    return 0;
  }
  BOOL v10 = (const void *)v9;
  if (sub_10022F858((uint64_t)a1, a3)) {
    uint64_t v11 = sub_100201F6C(a1, (uint64_t)v10, a2, a5);
  }
  else {
    uint64_t v11 = 0;
  }
  CFRelease(v10);
  return v11;
}

BOOL sub_100202288(void *a1)
{
  int v1 = sub_10022F62C(a1);
  if (v1 != 1) {
    SOSCreateError();
  }
  return v1 == 1;
}

uint64_t sub_1002022D8(void *a1)
{
  sub_1001EE2BC(a1);
  if (!sub_100202288(a1) || !sub_100202028(a1, 0)) {
    return 0;
  }

  return SOSBackupSliceKeyBagCreateFromData();
}

void sub_100202350(void *a1, uint64_t a2, CFTypeRef *a3)
{
  id v11 = a1;
  if (!a2) {
    goto LABEL_11;
  }
  CFTypeID v5 = *(const void **)(a2 + 40);
  unsigned int v6 = (const void *)SOSRKNullKey();
  if (v5) {
    BOOL v7 = v6 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7)
  {
    if (v5 == v6)
    {
LABEL_11:
      sub_1001FF378(v11, @"recoveryKeyBag", a3);
      goto LABEL_12;
    }
  }
  else if (CFEqual(v5, v6))
  {
    goto LABEL_11;
  }
  unsigned int v8 = sub_10020F204(a2, a3);
  uint64_t v9 = v11;
  if (!v8) {
    goto LABEL_13;
  }
  sub_1001FF4C0(v11, @"recoveryKeyBag", (uint64_t)v8, a3);
  CFRelease(v8);
LABEL_12:
  uint64_t v9 = v11;
LABEL_13:
}

uint64_t sub_100202420(const __CFAllocator *a1, void *a2, CFTypeRef *a3)
{
  CFDataRef v5 = (const __CFData *)sub_1001DCC24(a2, @"recoveryKeyBag");
  CFDataRef v6 = v5;
  if (v5 && (CFTypeID v7 = CFGetTypeID(v5), v7 == CFDataGetTypeID()))
  {
    return sub_10020F384(a1, v6, a3);
  }
  else
  {
    if (a3) {
      sub_100012A40(-50, (__CFString **)a3, @"object %@ is not a data", v6);
    }
    return 0;
  }
}

CFDataRef sub_1002024D8(const __CFAllocator *a1, void *a2, CFTypeRef *a3)
{
  uint64_t v4 = sub_100202420(a1, a2, a3);
  if (!v4)
  {
    CFDataRef Copy = 0;
    if (!a3) {
      return Copy;
    }
    goto LABEL_7;
  }
  CFDataRef v5 = (const void *)v4;
  CFDataRef Copy = *(const __CFData **)(v4 + 40);
  if (Copy)
  {
    CFTypeID v7 = (const void *)SOSRKNullKey();
    if (v7 && CFEqual(Copy, v7)) {
      CFDataRef Copy = 0;
    }
    else {
      CFDataRef Copy = CFDataCreateCopy(kCFAllocatorDefault, Copy);
    }
  }
  CFRelease(v5);
  if (a3)
  {
LABEL_7:
    if (!Copy && !*a3) {
      SOSErrorCreate();
    }
  }
  return Copy;
}

BOOL sub_10020258C(void *a1, const __CFData *a2, void *a3)
{
  id v5 = a1;
  uint64_t v33 = 0;
  CFSetRef v34 = &v33;
  uint64_t v35 = 0x2020000000;
  char v36 = 0;
  uint64_t v29 = 0;
  uint64_t v30 = &v29;
  uint64_t v31 = 0x2020000000;
  uint64_t v32 = 0;
  if ([v5 isInCircle:a3])
  {
    CFDataRef v6 = sub_1002024D8(kCFAllocatorDefault, v5, 0);
    v28[0] = _NSConcreteStackBlock;
    v28[1] = 3221225472;
    v28[2] = sub_100202954;
    v28[3] = &unk_100308FD8;
    void v28[4] = v6;
    sub_1002029C4(a2, v28);
    if (v6) {
      CFRelease(v6);
    }
    CFTypeID v7 = (const void *)sub_10020EFC4(kCFAllocatorDefault, v5, a2, 0);
    sub_100202350(v5, (uint64_t)v7, 0);
    uint64_t v27 = 0;
    unint64_t v19 = _NSConcreteStackBlock;
    uint64_t v20 = 3221225472;
    uint64_t v21 = sub_100202AA8;
    uint64_t v22 = &unk_1003085D0;
    id v23 = v5;
    long long v24 = &v29;
    unint64_t v25 = &v33;
    BOOL v26 = v7;
    id v8 = v23;
    *(void *)&long long buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 3221225472;
    CFTypeRef v38 = sub_100202E60;
    dispatch_time_t v39 = &unk_1003085F8;
    id v9 = v8;
    id v40 = v9;
    if (sub_1001F2BCC(v9, @"RecoveryRing", (const void **)&v27, &buf, &v19))
    {
      [v9 setPublicKeyStatus:2 forKey:2, v19, v20, v21, v22, v23, v24, v25, v26];
    }
    else
    {

      id v11 = v30;
      long long v12 = (const void *)v30[3];
      if (v12)
      {
        v30[3] = 0;
        CFRelease(v12);
        id v11 = v30;
      }
      v11[3] = v27;
      *((unsigned char *)v34 + 24) = 0;
    }

    if (v7) {
      CFRelease(v7);
    }
    CFTypeRef v13 = [v9 trust:v19, v20, v21, v22];
    [v13 peerInfo];
    int HasBackupKey = SOSPeerInfoHasBackupKey();

    if (HasBackupKey) {
      sub_1001EA1A8(v9);
    }
    if (!*((unsigned char *)v34 + 24))
    {
      if (!v30[3]) {
        SOSErrorCreate();
      }
      BOOL v15 = sub_10000B070("recovery");
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v16 = v30[3];
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = v16;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "SetRecoveryPublic Failed: %@", (uint8_t *)&buf, 0xCu);
      }

      unint64_t v17 = (const void *)v30[3];
      if (a3)
      {
        *a3 = v17;
      }
      else if (v17)
      {
        v30[3] = 0;
        CFRelease(v17);
      }
    }
    BOOL v10 = *((unsigned char *)v34 + 24) != 0;
  }
  else
  {
    BOOL v10 = 0;
  }
  _Block_object_dispose(&v29, 8);
  _Block_object_dispose(&v33, 8);

  return v10;
}

void sub_100202914(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_100202954(uint64_t a1, uint64_t a2)
{
  CFDataRef v2 = *(const __CFData **)(a1 + 32);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100202EFC;
  v3[3] = &unk_100308FD8;
  void v3[4] = a2;
  sub_1002029C4(v2, v3);
}

void sub_1002029C4(const __CFData *a1, void *a2)
{
  id v9 = a2;
  if (a1)
  {
    CFIndex Length = CFDataGetLength(a1);
    CFMutableDataRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 2 * Length);
    BytePtr = CFDataGetBytePtr(a1);
    CFIndex v6 = CFDataGetLength(a1);
    if (v6 >= 1)
    {
      CFIndex v7 = v6;
      do
      {
        unsigned int v8 = *BytePtr++;
        CFStringAppendFormat(Mutable, 0, @"%02X", v8);
        --v7;
      }
      while (v7);
    }
  }
  else
  {
    CFMutableDataRef Mutable = @"(null)";
  }
  v9[2](v9, Mutable);
  CFRelease(Mutable);
}

void *sub_100202AA8(uint64_t a1, void *a2)
{
  CFMutableSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  id v5 = [*(id *)(a1 + 32) trust];
  [v5 trustedCircle];
  [*(id *)(a1 + 32) accountKey];
  SOSCircleForEachValidSyncingPeer();

  sub_10022F8A0((uint64_t)a2, Mutable);
  if (Mutable) {
    CFRelease(Mutable);
  }
  CFIndex v6 = *(void **)(a1 + 32);
  if (*(void *)(a1 + 56))
  {
    if (sub_1001EE234(a2, (uint64_t)[*(id *)(a1 + 32) fullPeerInfo], *(void *)(a1 + 56), (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)))
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
      goto LABEL_19;
    }
    BOOL v10 = sub_10000B070("SecError");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
      *(_DWORD *)long long buf = 138412290;
      uint64_t v22 = v11;
      long long v12 = "SetRecoveryKey failed at SOSRingSetRecoveryKeyBag #1: %@";
LABEL_13:
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v12, buf, 0xCu);
      goto LABEL_14;
    }
    goto LABEL_14;
  }
  CFDataRef v7 = (const __CFData *)SOSRKNullKey();
  uint64_t v8 = sub_10020EFC4(kCFAllocatorDefault, v6, v7, (uint64_t *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
  if (!v8)
  {
    BOOL v10 = sub_10000B070("SecError");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
      *(_DWORD *)long long buf = 138412290;
      uint64_t v22 = v13;
      long long v12 = "SetRecoveryKey failed at SOSRecoveryKeyBagCreateForAccount: %@";
      goto LABEL_13;
    }
LABEL_14:

    goto LABEL_19;
  }
  id v9 = (const void *)v8;
  if (sub_1001EE234(a2, (uint64_t)[*(id *)(a1 + 32) fullPeerInfo], v8, (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)))
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
  }
  else
  {
    uint64_t v14 = sub_10000B070("SecError");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
      *(_DWORD *)long long buf = 138412290;
      uint64_t v22 = v15;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "SetRecoveryKey failed at SOSRingSetRecoveryKeyBag #2: %@", buf, 0xCu);
    }
  }
  CFRelease(v9);
LABEL_19:
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24))
  {
    uint64_t v16 = [*(id *)(a1 + 32) trust];
    char v17 = sub_100201EB0(a2, (uint64_t)[v16 fullPeerInfo], *(void *)(*(void *)(a1 + 40) + 8) + 24);

    if ((v17 & 1) == 0)
    {
      unint64_t v18 = sub_10000B070("SecError");
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v19 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
        *(_DWORD *)long long buf = 138412290;
        uint64_t v22 = v19;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "SetRecoveryKey failed at SOSRingGenerationSign: %@", buf, 0xCu);
      }

      *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
    }
  }
  if (a2) {
    CFRetain(a2);
  }
  return a2;
}

uint64_t sub_100202E60(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = [*(id *)(a1 + 32) peerID];
  uint64_t v6 = sub_100201E3C(a2, (uint64_t)v5, 5u, a3);

  return v6;
}

void sub_100202EBC(uint64_t a1)
{
  int v1 = *(__CFSet **)(a1 + 32);
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID();

  CFSetAddValue(v1, PeerID);
}

void sub_100202EFC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_10000B070("recovery");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = 138412546;
    uint64_t v7 = v5;
    __int16 v8 = 2112;
    uint64_t v9 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "SetRecoveryPublic: %@ from %@", (uint8_t *)&v6, 0x16u);
  }
}

void sub_100202FC4(void *a1)
{
  id v1 = a1;
  CFDataRef v2 = [v1 queue];
  dispatch_assert_queue_V2(v2);

  uint64_t v3 = (const void *)sub_100202420(kCFAllocatorDefault, v1, 0);
  uint64_t v4 = qword_10035D3A8;
  if (v3) {
    BOOL v5 = qword_10035D3A8 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  if (v5)
  {
    if (v3 == (const void *)qword_10035D3A8) {
      goto LABEL_17;
    }
    goto LABEL_10;
  }
  if (!CFEqual(v3, (CFTypeRef)qword_10035D3A8))
  {
    uint64_t v4 = qword_10035D3A8;
LABEL_10:
    uint64_t v7 = sub_10000B070("recovery");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 138412546;
      uint64_t v10 = v4;
      __int16 v11 = 2112;
      long long v12 = v3;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Recovery Key changed: old %@ new %@", (uint8_t *)&v9, 0x16u);
    }

    notify_post(kSOSCCRecoveryKeyChanged);
    __int16 v8 = (const void *)qword_10035D3A8;
    if ((const void *)qword_10035D3A8 != v3)
    {
      if (!v3 || (CFRetain(v3), (__int16 v8 = (const void *)qword_10035D3A8) != 0)) {
        CFRelease(v8);
      }
      qword_10035D3A8 = (uint64_t)v3;
    }
LABEL_17:
    if (!v3) {
      return;
    }
  }
  CFRelease(v3);
}

uint64_t sub_100203134()
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_1002031CC;
  block[3] = &unk_100308678;
  void block[4] = &qword_10035D3B8;
  if (qword_10035D3B0 != -1) {
    dispatch_once(&qword_10035D3B0, block);
  }
  return qword_10035D3B8;
}

uint64_t sub_1002031CC(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

CFStringRef sub_100203200(uint64_t a1)
{
  sub_100025824();

  return sub_100203238(a1);
}

CFStringRef sub_100203238(uint64_t a1)
{
  CFDataRef v2 = *(const __CFData **)(a1 + 40);
  if (v2) {
    BytePtr = CFDataGetBytePtr(v2);
  }
  else {
    BytePtr = (const UInt8 *)&byte_1002656B9;
  }
  CFDataRef v4 = *(const __CFData **)(a1 + 48);
  if (v4) {
    BOOL v5 = CFDataGetBytePtr(v4);
  }
  else {
    BOOL v5 = (const UInt8 *)&byte_1002656B9;
  }
  CFDataRef v6 = *(const __CFData **)(a1 + 56);
  if (v6) {
    uint64_t v7 = CFDataGetBytePtr(v6);
  }
  else {
    uint64_t v7 = (const UInt8 *)&byte_1002656B9;
  }
  CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)a1);
  CFDateRef v9 = CFDateCreate(v8, *(CFAbsoluteTime *)(a1 + 104));
  CFMutableSetRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  uint64_t v11 = sub_10000CF0C(0);
  uint64_t v12 = sub_100134054(v11);
  if (v12
    && (uint64_t v13 = (*(uint64_t (**)(uint64_t, const CFStringRef, void))(v12 + 8))(v12, kSecAttrAccessibleWhenUnlocked, 0)) != 0)
  {
    uint64_t v14 = v13;
    v47[0] = 0;
    v47[1] = v47;
    v47[2] = 0x2000000000;
    void v47[3] = 16;
    CFIndex v15 = sub_100203668(a1);
    CFStringAppendFormat(Mutable, 0, @"{[%zu]", v15);
    v46[0] = _NSConcreteStackBlock;
    v46[1] = 0x40000000;
    v46[2] = sub_100203768;
    v46[3] = &unk_1003086F0;
    void v46[5] = v14;
    v46[6] = Mutable;
    v46[4] = v47;
    v48[0] = _NSConcreteStackBlock;
    v48[1] = 0x40000000;
    void v48[2] = sub_100203824;
    void v48[3] = &unk_1003086C8;
    v48[5] = 0;
    v48[6] = v14;
    v48[4] = v46;
    sub_100203900(a1, 0, (uint64_t)v48);
    CFStringAppend(Mutable, @"}");
    _Block_object_dispose(v47, 8);
  }
  else
  {
    CFStringAppend(Mutable, @"{NO DATASOURCE}");
  }
  if (*(void *)(a1 + 112))
  {
    CFAllocatorRef v16 = CFGetAllocator((CFTypeRef)a1);
    char v17 = "J";
    uint64_t v19 = *(void *)(a1 + 88);
    uint64_t v18 = *(void *)(a1 + 96);
    uint64_t v20 = *BytePtr;
    uint64_t v21 = BytePtr[1];
    uint64_t v22 = "P";
    if ((v19 & 1) == 0) {
      char v17 = "j";
    }
    uint64_t v23 = BytePtr[2];
    uint64_t v24 = BytePtr[3];
    unint64_t v25 = "D";
    uint64_t v26 = *v5;
    uint64_t v27 = v5[1];
    if ((v19 & 2) == 0) {
      uint64_t v22 = "p";
    }
    uint64_t v28 = v5[2];
    uint64_t v29 = v5[3];
    uint64_t v30 = *v7;
    uint64_t v31 = v7[1];
    uint64_t v32 = v7[2];
    uint64_t v33 = v7[3];
    uint64_t v35 = *(void *)(a1 + 64);
    uint64_t v34 = *(void *)(a1 + 72);
    if ((v19 & 3) == 0) {
      unint64_t v25 = "d";
    }
    char v36 = "k";
    if ((v19 & 4) != 0) {
      char v36 = "K";
    }
    uint64_t v37 = "z";
    if ((v19 & 5) != 0) {
      uint64_t v37 = "Z";
    }
    if ((v19 & 6) != 0) {
      CFTypeRef v38 = "H";
    }
    else {
      CFTypeRef v38 = "h";
    }
    CFStringRef v39 = CFStringCreateWithFormat(v16, 0, @"<MSG %llu %@ %02X%02X%02X%02X %02X%02X%02X%02X %02X%02X%02X%02X %@ %@ %@ %s%s%s%s%s%s%s>", v18, v9, v20, v21, v23, v24, v26, v27, v28, v29, v30, v31, v32, v33, v35, v34,
            Mutable,
            "g",
            v17,
            v22,
            v25,
            v36,
            v37,
            v38);
  }
  else
  {
    switch(sub_1002039D8((void *)a1))
    {
      case 1:
        CFAllocatorRef v43 = CFGetAllocator((CFTypeRef)a1);
        CFStringRef v39 = CFStringCreateWithFormat(v43, 0, @"<MSGDigest %llu %02X%02X%02X%02X>", *(void *)(a1 + 96), *BytePtr, BytePtr[1], BytePtr[2], BytePtr[3]);
        break;
      case 2:
        CFAllocatorRef v44 = CFGetAllocator((CFTypeRef)a1);
        CFStringRef v39 = CFStringCreateWithFormat(v44, 0, @"<MSGManifest %llu %@>", *(void *)(a1 + 96), *(void *)(a1 + 72));
        break;
      case 3:
        CFAllocatorRef v45 = CFGetAllocator((CFTypeRef)a1);
        CFStringRef v39 = CFStringCreateWithFormat(v45, 0, @"<MSGObjects %llu %02X%02X%02X%02X %@ %@ %@", *(void *)(a1 + 96), *v5, v5[1], v5[2], v5[3], *(void *)(a1 + 64), *(void *)(a1 + 72), Mutable);
        break;
      default:
        CFAllocatorRef v42 = CFGetAllocator((CFTypeRef)a1);
        CFStringRef v39 = CFStringCreateWithFormat(v42, 0, @"<MSGInvalid %llu >", *(void *)(a1 + 96));
        break;
    }
  }
  CFStringRef v40 = v39;
  if (v9) {
    CFRelease(v9);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v40;
}

CFIndex sub_100203668(uint64_t a1)
{
  CFArrayRef v2 = *(const __CFArray **)(a1 + 80);
  if (v2)
  {
    return CFArrayGetCount(v2);
  }
  else
  {
    if (!*(void *)(a1 + 24)) {
      return 0;
    }
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 16));
    BOOL v5 = &BytePtr[CFDataGetLength(*(CFDataRef *)(a1 + 16))];
    uint64_t v10 = 0;
    uint64_t v11 = &v10;
    uint64_t v12 = 0x2000000000;
    uint64_t v13 = 0;
    uint64_t v7 = *(const UInt8 **)(a1 + 24);
    uint64_t v6 = *(void *)(a1 + 32);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000;
    _DWORD v9[2] = sub_100203C9C;
    v9[3] = &unk_1003086A0;
    void v9[4] = &v10;
    sub_100203A6C(v6, v7, v5, 0, (uint64_t)v9);
    uint64_t v8 = v11[3];
    _Block_object_dispose(&v10, 8);
    return v8;
  }
}

void sub_100203768(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  CFDataRef v5 = (const __CFData *)(*(uint64_t (**)(uint64_t, void))(*(void *)(a1 + 40) + 112))(a2, 0);
  BytePtr = CFDataGetBytePtr(v5);
  CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 48), 0, @" %02X%02X%02X%02X", *BytePtr, BytePtr[1], BytePtr[2], BytePtr[3]);
  if (v5) {
    CFRelease(v5);
  }
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
  uint64_t v8 = *(void *)(v7 + 24) - 1;
  *(void *)(v7 + 24) = v8;
  if (!v8)
  {
    CFStringAppend(*(CFMutableStringRef *)(a1 + 48), @"...");
    *a3 = 1;
  }
}

void sub_100203824(uint64_t a1, CFDataRef theData)
{
  CFTypeRef cf = 0;
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  uint64_t v6 = sub_10000EEF8(kCFAllocatorDefault, &cf, *(CFTypeRef **)(a1 + 40), (uint64_t)BytePtr, (uint64_t)&BytePtr[Length]);
  CFTypeRef v7 = cf;
  if (v6)
  {
    uint64_t v8 = (const void *)(*(uint64_t (**)(CFTypeRef, void))(*(void *)(a1 + 48) + 128))(cf, *(void *)(a1 + 40));
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
    if (v8) {
      CFRelease(v8);
    }
  }
  if (v7)
  {
    CFRelease(v7);
  }
}

BOOL sub_100203900(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFArrayRef v5 = *(const __CFArray **)(a1 + 80);
  if (v5)
  {
    CFIndex Count = CFArrayGetCount(v5);
    CFIndex v7 = Count - 1;
    if (Count >= 1)
    {
      CFIndex v8 = 0;
      do
      {
        CFDictionaryRef ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), v8);
        char v15 = 0;
        (*(void (**)(uint64_t, const void *, char *))(a3 + 16))(a3, ValueAtIndex, &v15);
        if (v15) {
          BOOL v10 = 1;
        }
        else {
          BOOL v10 = v7 == v8;
        }
        ++v8;
      }
      while (!v10);
    }
  }
  else if (*(void *)(a1 + 24))
  {
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(a1 + 16));
    CFIndex Length = CFDataGetLength(*(CFDataRef *)(a1 + 16));
    return sub_100203A6C(*(void *)(a1 + 32), *(const UInt8 **)(a1 + 24), &BytePtr[Length], a2, a3) != 0;
  }
  return 1;
}

uint64_t sub_1002039D8(void *a1)
{
  if (a1[6])
  {
    uint64_t v2 = a1[8];
    if (v2 && (unint64_t)CFDataGetLength(*(CFDataRef *)(v2 + 24)) > 0x13) {
      return 3;
    }
    uint64_t v3 = a1[9];
    if (v3 && (unint64_t)CFDataGetLength(*(CFDataRef *)(v3 + 24)) > 0x13)
    {
      return 3;
    }
    else if (sub_100203668((uint64_t)a1))
    {
      return 3;
    }
    else
    {
      return 1;
    }
  }
  else if (a1[9])
  {
    return 2;
  }
  else
  {
    return a1[5] != 0;
  }
}

const UInt8 *sub_100203A6C(uint64_t a1, const UInt8 *a2, const UInt8 *a3, uint64_t a4, uint64_t a5)
{
  char v12 = 0;
  do
  {
    if (!ccder_decode_tag()) {
      break;
    }
    *(void *)long long buf = 0;
    if (!ccder_decode_constructed_tl())
    {
      SOSErrorCreate();
      return 0;
    }
    if (a5)
    {
      CFDataRef v9 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, a2, *(void *)buf - (void)a2, kCFAllocatorNull);
      (*(void (**)(uint64_t, CFDataRef, char *))(a5 + 16))(a5, v9, &v12);
      if (v9) {
        CFRelease(v9);
      }
    }
    a2 = *(const UInt8 **)buf;
  }
  while (!v12);
  if (a1 == -1) {
    a2 = (const UInt8 *)ccder_decode_tl();
  }
  if (!v12 && a2 != a3)
  {
    BOOL v10 = sub_10000B070("SecWarning");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = a3 - a2;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%td trailing bytes after objects DER", buf, 0xCu);
    }
  }
  return a2;
}

uint64_t sub_100203C9C(uint64_t result)
{
  return result;
}

uint64_t sub_100203CB4(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a1 + 88) != *(void *)(a2 + 88)
    || *(void *)(a1 + 96) != *(void *)(a2 + 96)
    || *(double *)(a1 + 104) != *(double *)(a2 + 104))
  {
    return 0;
  }
  CFArrayRef v5 = *(const void **)(a1 + 40);
  uint64_t v6 = *(const void **)(a2 + 40);
  if (v5 && v6)
  {
    uint64_t result = CFEqual(v5, v6);
    if (!result) {
      return result;
    }
  }
  else if (v5 != v6)
  {
    return 0;
  }
  CFIndex v7 = *(const void **)(a1 + 48);
  CFIndex v8 = *(const void **)(a2 + 48);
  if (v7 && v8)
  {
    uint64_t result = CFEqual(v7, v8);
    if (!result) {
      return result;
    }
  }
  else if (v7 != v8)
  {
    return 0;
  }
  CFDataRef v9 = *(const void **)(a1 + 56);
  BOOL v10 = *(const void **)(a2 + 56);
  if (v9 && v10)
  {
    uint64_t result = CFEqual(v9, v10);
    if (!result) {
      return result;
    }
  }
  else if (v9 != v10)
  {
    return 0;
  }
  uint64_t v11 = *(const void **)(a1 + 64);
  char v12 = *(const void **)(a2 + 64);
  if (v11 && v12)
  {
    uint64_t result = CFEqual(v11, v12);
    if (!result) {
      return result;
    }
    goto LABEL_25;
  }
  if (v11 != v12) {
    return 0;
  }
LABEL_25:
  uint64_t v13 = *(const void **)(a1 + 72);
  uint64_t v14 = *(const void **)(a2 + 72);
  if (v13 && v14) {
    return CFEqual(v13, v14) != 0;
  }
  else {
    return v13 == v14;
  }
}

void sub_100203DC8(void *a1)
{
  uint64_t v2 = (const void *)a1[2];
  if (v2)
  {
    a1[2] = 0;
    CFRelease(v2);
  }
  uint64_t v3 = (const void *)a1[5];
  if (v3)
  {
    a1[5] = 0;
    CFRelease(v3);
  }
  CFDataRef v4 = (const void *)a1[6];
  if (v4)
  {
    a1[6] = 0;
    CFRelease(v4);
  }
  CFArrayRef v5 = (const void *)a1[7];
  if (v5)
  {
    a1[7] = 0;
    CFRelease(v5);
  }
  uint64_t v6 = (const void *)a1[9];
  if (v6)
  {
    a1[9] = 0;
    CFRelease(v6);
  }
  CFIndex v7 = (const void *)a1[8];
  if (v7)
  {
    a1[8] = 0;
    CFRelease(v7);
  }
  CFIndex v8 = (const void *)a1[10];
  if (v8)
  {
    a1[10] = 0;
    CFRelease(v8);
  }
}

CFArrayRef sub_100203E70(uint64_t a1)
{
  CFArrayRef result = *(const __CFArray **)(a1 + 80);
  if (result)
  {
    CFIndex Count = CFArrayGetCount(result);
    if (Count < 1)
    {
      uint64_t v6 = 0;
    }
    else
    {
      CFIndex v4 = Count;
      CFIndex v5 = 0;
      uint64_t v6 = 0;
      do
      {
        CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), v5);
        v6 += CFDataGetLength(ValueAtIndex);
        ++v5;
      }
      while (v4 != v5);
    }
  }
  else
  {
    uint64_t v6 = 0;
    if (*(void *)(a1 + 112)) {
      return result;
    }
  }
  if (*(unsigned char *)(a1 + 120)) {
    return (const __CFArray *)(v6 + 4);
  }

  return (const __CFArray *)ccder_sizeof();
}

uint64_t sub_100203F28(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFArrayRef v4 = *(const __CFArray **)(a1 + 80);
  if (!v4 && *(void *)(a1 + 112)) {
    return a3;
  }
  if (!*(unsigned char *)(a1 + 120))
  {
    if (!v4) {
      goto LABEL_10;
    }
LABEL_8:
    CFIndex Count = CFArrayGetCount(v4);
    CFIndex v7 = Count - 1;
    if (Count >= 1)
    {
      do
      {
        CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 80), v7);
        CFDataGetLength(ValueAtIndex);
        CFDataGetBytePtr(ValueAtIndex);
        ccder_encode_body();
        --v7;
      }
      while (v7 != -1);
    }
    goto LABEL_10;
  }
  ccder_encode_tl();
  CFArrayRef v4 = *(const __CFArray **)(a1 + 80);
  if (v4) {
    goto LABEL_8;
  }
LABEL_10:
  if (*(unsigned char *)(a1 + 120))
  {
    ccder_encode_len();
    return ccder_encode_tag();
  }
  else
  {
    return ccder_encode_constructed_tl();
  }
}

uint64_t sub_1002040A0(uint64_t a1, CFDataRef theData, uint64_t a3, uint64_t a4)
{
  if (!theData) {
    return a4;
  }
  CFIndex Length = CFDataGetLength(theData);
  BytePtr = CFDataGetBytePtr(theData);

  return _ccder_encode_implicit_raw_octet_string(a1, Length, BytePtr, a3, a4);
}

const UInt8 *sub_100204130(uint64_t a1, CFDataRef *a2)
{
  uint64_t v3 = (const UInt8 *)ccder_decode_tl();
  CFArrayRef v4 = v3;
  if (a2)
  {
    if (v3)
    {
      CFDataRef v5 = CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, v3, 0, kCFAllocatorNull);
      *a2 = v5;
      if (!v5) {
        return 0;
      }
    }
  }
  return v4;
}

const UInt8 *sub_1002041B0(uint64_t a1, CFTypeRef *a2)
{
  CFTypeRef v8 = 0;
  CFTypeRef cf = 0;
  sub_100204130(4, (CFDataRef *)&cf);
  CFArrayRef v4 = sub_100204130(4, (CFDataRef *)&v8);
  if (v4)
  {
    *(void *)(a1 + 64) = sub_100200FE0((const __CFData *)cf, a2);
    CFDataRef v5 = (const void *)sub_100200FE0((const __CFData *)v8, a2);
    *(void *)(a1 + 72) = v5;
    uint64_t v6 = *(const void **)(a1 + 64);
    if (!v6 || !v5)
    {
      if (v6)
      {
        *(void *)(a1 + 64) = 0;
        CFRelease(v6);
        CFDataRef v5 = *(const void **)(a1 + 72);
      }
      if (v5)
      {
        *(void *)(a1 + 72) = 0;
        CFRelease(v5);
      }
      CFArrayRef v4 = 0;
    }
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v8) {
    CFRelease(v8);
  }
  return v4;
}

CFDictionaryRef sub_100204420(CFDictionaryRef result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    CFDictionaryRef v5 = result;
    CFTypeID v6 = CFGetTypeID(result);
    if (v6 == CFStringGetTypeID())
    {
      if (a2)
      {
        keys[0] = @"peer-id";
        keys[1] = @"views";
        if (a3)
        {
          keys[2] = @"keybag";
          values = v5;
          uint64_t v10 = a2;
          uint64_t v11 = a3;
          CFAllocatorRef v7 = kCFAllocatorDefault;
          CFIndex v8 = 3;
        }
        else
        {
          values = v5;
          uint64_t v10 = a2;
          CFAllocatorRef v7 = kCFAllocatorDefault;
          CFIndex v8 = 2;
        }
        return CFDictionaryCreate(v7, (const void **)keys, (const void **)&values, v8, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      }
      else
      {
        return (CFDictionaryRef)CFRetain(v5);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

CFTypeRef sub_100204574(CFTypeRef cf, uint64_t *a2, void *a3, __CFString **a4)
{
  if (!cf || (CFTypeID v8 = CFGetTypeID(cf), v8 != CFDictionaryGetTypeID()))
  {
    if (a2) {
      *a2 = SOSViewsGetV0ViewSet();
    }
    if (cf)
    {
      CFTypeID v18 = CFGetTypeID(cf);
      if (v18 == CFStringGetTypeID()) {
        return cf;
      }
    }
    if (a4) {
      sub_100012A40(-50, a4, @"object %@ is not a string", cf);
    }
    return 0;
  }
  CFStringRef Value = CFDictionaryGetValue((CFDictionaryRef)cf, @"peer-id");
  uint64_t v10 = Value;
  if (!Value || (CFTypeID v11 = CFGetTypeID(Value), v11 != CFStringGetTypeID()))
  {
    if (a4) {
      sub_100012A40(-50, a4, @"object %@ is not a string", v10);
    }
    uint64_t v10 = 0;
  }
  char v12 = CFDictionaryGetValue((CFDictionaryRef)cf, @"views");
  uint64_t v13 = v12;
  if (!v12 || (CFTypeID v14 = CFGetTypeID(v12), v14 != CFSetGetTypeID()))
  {
    if (a4) {
      sub_100012A40(-50, a4, @"object %@ is not a set", v13);
    }
    return 0;
  }
  char v15 = CFDictionaryGetValue((CFDictionaryRef)cf, @"keybag");
  CFAllocatorRef v16 = v15;
  if (v15)
  {
    CFTypeID v17 = CFGetTypeID(v15);
    if (v17 != CFDataGetTypeID())
    {
      if (a4) {
        sub_100012A40(-50, a4, @"object %@ is not an data", v16);
      }
      return 0;
    }
  }
  if (a3) {
    *a3 = v16;
  }
  if (a2) {
    *a2 = (uint64_t)v13;
  }
  return v10;
}

CFDictionaryRef sub_10020471C(__CFDictionary *cf, const void *a2, const void *a3, int a4, int a5, int a6, int a7, int a8)
{
  MutableCFDataRef Copy = cf;
  if (a2)
  {
    if (!cf) {
      return sub_100139704(kCFAllocatorDefault, (int)a2, (int)a3, a4, a5, a6, a7, a8, @"views", (uint64_t)a2);
    }
  }
  else
  {
    sub_10002BBA0(@"Execution has encountered an unexpected state", 0x53C0000Eu);
    if (!MutableCopy) {
      return sub_100139704(kCFAllocatorDefault, (int)a2, (int)a3, a4, a5, a6, a7, a8, @"views", (uint64_t)a2);
    }
  }
  CFTypeID v11 = CFGetTypeID(MutableCopy);
  if (v11 != sub_100204858())
  {
    CFTypeID v12 = CFGetTypeID(MutableCopy);
    if (v12 == CFDictionaryGetTypeID())
    {
      MutableCFDataRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, MutableCopy);
      CFDictionarySetValue(MutableCopy, @"views", a2);
      if (a3) {
        CFDictionarySetValue(MutableCopy, @"keybag", a3);
      }
      else {
        CFDictionaryRemoveValue(MutableCopy, @"keybag");
      }
      return MutableCopy;
    }
    return sub_100139704(kCFAllocatorDefault, (int)a2, (int)a3, a4, a5, a6, a7, a8, @"views", (uint64_t)a2);
  }
  sub_1002048F0((uint64_t)MutableCopy, (CFSetRef)a2);
  sub_100204A08((uint64_t)MutableCopy, a3);
  CFRetain(MutableCopy);
  return MutableCopy;
}

uint64_t sub_100204858()
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1002054C4;
  block[3] = &unk_1003093A8;
  void block[4] = &qword_10035D3C8;
  if (qword_10035D3C0 != -1) {
    dispatch_once(&qword_10035D3C0, block);
  }
  return qword_10035D3C8;
}

void sub_1002048F0(uint64_t a1, CFSetRef theSet)
{
  uint64_t v4 = *(void *)(a1 + 24);
  if (v4)
  {
    uint64_t v8 = 0;
    CFDataRef v9 = &v8;
    uint64_t v10 = 0x2020000000;
    char v11 = 1;
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 3221225472;
    void v7[2] = sub_100205474;
    v7[3] = &unk_1003087F0;
    void v7[4] = &v8;
    v7[5] = v4;
    CFSetApplyFunction(theSet, (CFSetApplierFunction)sub_1002054AC, v7);
    int v5 = *((unsigned __int8 *)v9 + 24);
    _Block_object_dispose(&v8, 8);
    if (!v5) {
      *(unsigned char *)(a1 + 50) = 0;
    }
  }
  CFSetRef v6 = *(CFSetRef *)(a1 + 24);
  if (v6 != theSet)
  {
    if (!theSet || (CFRetain(theSet), (CFSetRef v6 = *(CFSetRef *)(a1 + 24)) != 0)) {
      CFRelease(v6);
    }
    *(void *)(a1 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = theSet;
  }
}

void sub_1002049F0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100204A08(uint64_t a1, CFTypeRef cf1)
{
  CFTypeRef v4 = *(CFTypeRef *)(a1 + 112);
  BOOL v5 = v4 == 0;
  if (cf1 && v4)
  {
    if (CFEqual(cf1, v4)) {
      return;
    }
    BOOL v5 = *(void *)(a1 + 112) == 0;
LABEL_7:
    CFSetRef v6 = sub_10000B070("backup");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 16);
      int v12 = 138412546;
      uint64_t v13 = v7;
      __int16 v14 = 2112;
      CFTypeRef v15 = cf1;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%@ backup bag: %@", (uint8_t *)&v12, 0x16u);
    }

    if (*(CFTypeRef *)(a1 + 112) != cf1)
    {
      CFRetain(cf1);
      uint64_t v8 = *(const void **)(a1 + 112);
      if (v8) {
        CFRelease(v8);
      }
      *(void *)(a1 + 112) = cf1;
    }
    goto LABEL_13;
  }
  if (v4 == cf1) {
    return;
  }
  if (cf1) {
    goto LABEL_7;
  }
  CFDataRef v9 = sub_10000B070("SecWarning");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = *(void *)(a1 + 16);
    int v12 = 138412290;
    uint64_t v13 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%@ keybag for backup unset", (uint8_t *)&v12, 0xCu);
  }

  char v11 = *(const void **)(a1 + 112);
  if (!v11)
  {
LABEL_13:
    if (v5) {
      return;
    }
    goto LABEL_14;
  }
  CFRelease(v11);
  *(void *)(a1 + 112) = 0;
  if (!v4) {
    return;
  }
LABEL_14:
  sub_100204BB4(a1);
}

void sub_100204BB4(uint64_t a1)
{
  *(unsigned char *)(a1 + 49) = 0;
  if (*(void *)(a1 + 112))
  {
    sub_100204FC8(a1, 0);
    uint64_t v2 = *(void *)(a1 + 16);
    uint64_t v3 = sub_10000B070("syncwith");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "SOSCCAccountTriggerSyncWithBackupPeer_server: %@", (uint8_t *)&buf, 0xCu);
    }

    if (v2)
    {
      CFTypeRef v4 = sub_10021A4D0(1);
      if ([v4 SOSMonitorModeSOSIsActive])
      {
        *(void *)&long long buf = v2;
        BOOL v5 = +[NSArray arrayWithObjects:&buf count:1];
        [v4 triggerBackupForPeers:v5];
      }
    }
  }
  else
  {
    uint64_t v8 = 0;
    CFDataRef v9 = &v8;
    uint64_t v10 = 0x2020000000;
    char v11 = 1;
    *(void *)&long long buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 3221225472;
    uint64_t v13 = sub_100204D88;
    __int16 v14 = &unk_100308818;
    CFTypeRef v15 = &v8;
    uint64_t v16 = a1;
    uint64_t v17 = 0;
    BOOL v6 = sub_100204E84(a1, 0, &buf);
    if (*((unsigned char *)v9 + 24)) {
      BOOL v7 = v6;
    }
    else {
      BOOL v7 = 0;
    }
    *((unsigned char *)v9 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v7;
    _Block_object_dispose(&v8, 8);
  }
}

void sub_100204D68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

BOOL sub_100204D88(uint64_t a1, const char *a2)
{
  CFTypeRef v4 = sub_10000B070("backup");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 138412546;
    uint64_t v16 = v5;
    __int16 v17 = 2080;
    CFTypeID v18 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%@ unlinking journal file %s", buf, 0x16u);
  }

  int v6 = unlink(a2);
  BOOL result = sub_1000296CC(v6, *(CFTypeRef **)(a1 + 48), @"unlink %s", v7, v8, v9, v10, v11, (char)a2);
  uint64_t v13 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v13 + 24)) {
    BOOL v14 = result;
  }
  else {
    BOOL v14 = 0;
  }
  *(unsigned char *)(v13 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v14;
  return result;
}

BOOL sub_100204E84(uint64_t a1, CFTypeRef *a2, void *a3)
{
  id v5 = a3;
  memset(__b, 170, sizeof(__b));
  if (confstr(65537, __b, 0x401uLL))
  {
    CFStringRef v11 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%s/SOSBackup-%@", __b, *(void *)(a1 + 16));
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 0x40000000;
    void v15[2] = sub_10000B880;
    v15[3] = &unk_1002F7408;
    void v15[4] = v5;
    sub_10000EB80(v11, (uint64_t)v15);
    if (v11) {
      CFRelease(v11);
    }
    BOOL v12 = 1;
  }
  else
  {
    BOOL v12 = sub_1000296CC(-1, a2, @"confstr on _CS_DARWIN_USER_TEMP_DIR returned an error.", v6, v7, v8, v9, v10, v14);
  }

  return v12;
}

uint64_t sub_100204FC8(uint64_t a1, void *a2)
{
  uint64_t v24 = 0;
  unint64_t v25 = &v24;
  uint64_t v26 = 0x2020000000;
  char v27 = 1;
  uint64_t v20 = 0;
  uint64_t v21 = &v20;
  uint64_t v22 = 0x2020000000;
  CFTypeRef v23 = 0;
  v19[0] = _NSConcreteStackBlock;
  v19[1] = 3221225472;
  v19[2] = sub_1002052A8;
  v19[3] = &unk_100308840;
  v19[5] = &v20;
  v19[6] = a1;
  void v19[4] = &v24;
  CFTypeRef v4 = v19;
  *(void *)long long buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 3221225472;
  *(void *)&uint8_t buf[16] = sub_1002053BC;
  uint64_t v29 = &unk_100308868;
  id v30 = v4;
  uint64_t v31 = &v23;
  id v5 = v4;
  BOOL v6 = sub_100204E84(a1, &v23, buf);

  if (*((unsigned char *)v25 + 24)) {
    BOOL v7 = v6;
  }
  else {
    BOOL v7 = 0;
  }
  *((unsigned char *)v25 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v7;
  if (v7)
  {
    uint64_t v8 = sub_10000B070("backup-peer");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(a1 + 16);
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%@ Wrote reset.", buf, 0xCu);
    }
  }
  else
  {
    uint64_t v10 = sub_10000B070("SecWarning");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = *(void *)(a1 + 16);
      uint64_t v12 = v21[3];
      *(_DWORD *)long long buf = 138412546;
      *(void *)&uint8_t buf[4] = v11;
      *(_WORD *)&unsigned char buf[12] = 2112;
      *(void *)&buf[14] = v12;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%@ failed to write reset to backup journal: %@", buf, 0x16u);
    }

    uint64_t v13 = (const void *)v21[3];
    if (v13)
    {
      if (a2 && !*a2) {
        *a2 = v13;
      }
      else {
        CFRelease(v13);
      }
    }
  }
  char v14 = *(const void **)(a1 + 72);
  if (v14)
  {
    CFRelease(v14);
    *(void *)(a1 + 72) = 0;
  }
  CFTypeRef v15 = *(const void **)(a1 + 80);
  if (v15)
  {
    *(void *)(a1 + 80) = 0;
    CFRelease(v15);
  }
  uint64_t v16 = v25;
  *(unsigned char *)(a1 + 4_Block_object_dispose(&a9, 8) = *((unsigned char *)v25 + 24) ^ 1;
  uint64_t v17 = *((unsigned __int8 *)v16 + 24);
  _Block_object_dispose(&v20, 8);
  _Block_object_dispose(&v24, 8);
  return v17;
}

void sub_10020527C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

BOOL sub_1002052A8(void *a1, FILE *a2)
{
  uint64_t v4 = *(void *)(a1[6] + 112);
  id v5 = (__CFString **)(*(void *)(a1[5] + 8) + 24);
  if (v4)
  {
    CFDataGetLength(*(CFDataRef *)(a1[6] + 112));
    ccder_sizeof_raw_octet_string();
  }
  size_t v6 = ccder_sizeof();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 0x40000000;
  _DWORD v8[2] = sub_1001FB090;
  v8[3] = &unk_1003081C8;
  void v8[4] = v4;
  void v8[5] = v5;
  BOOL result = sub_1001FB114(a2, v5, v6, (uint64_t)v8);
  *(unsigned char *)(*(void *)(a1[4] + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = result;
  if (*(unsigned char *)(*(void *)(a1[4] + 8) + 24))
  {
    if (!*(void *)(a1[6] + 112))
    {
      BOOL result = sub_1001FB3CC(a2, 999, (__CFString **)(*(void *)(a1[5] + 8) + 24));
      *(unsigned char *)(*(void *)(a1[4] + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = result;
    }
  }
  return result;
}

uint64_t sub_1002053BC(uint64_t a1, char *__filename)
{
  char v2 = (char)__filename;
  uint64_t v4 = *(CFTypeRef **)(a1 + 40);
  id v5 = fopen(__filename, "w");
  uint64_t result = sub_1000296CC(v5 == 0, v4, @"fopen %s,%s", v6, v7, v8, v9, v10, v2);
  if (v5)
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
    return fclose(v5);
  }
  return result;
}

uint64_t sub_100205474(uint64_t a1, const void *a2)
{
  uint64_t result = CFSetContainsValue(*(CFSetRef *)(a1 + 40), a2);
  if (!result) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
  }
  return result;
}

uint64_t sub_1002054AC(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_1002054C4(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

CFStringRef sub_1002054F8(uint64_t a1)
{
  sub_100025824();

  return sub_100205530(a1);
}

CFStringRef sub_100205530(uint64_t a1)
{
  if (!a1) {
    return @"NULL";
  }
  uint64_t v2 = *(void *)(a1 + 56);
  if (v2) {
    CFStringRef v3 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @" %@%@", @"O", v2);
  }
  else {
    CFStringRef v3 = @" -  ";
  }
  uint64_t v5 = *(void *)(a1 + 64);
  if (v5) {
    CFStringRef v6 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @" %@%@", @"U", v5);
  }
  else {
    CFStringRef v6 = @" -  ";
  }
  uint64_t v7 = *(void *)(a1 + 72);
  if (v7) {
    CFStringRef v8 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @" %@%@", @"C", v7);
  }
  else {
    CFStringRef v8 = @" -  ";
  }
  CFStringRef v9 = sub_100205720(*(const __CFArray **)(a1 + 80), @"P");
  CFStringRef v10 = sub_100205720(*(const __CFArray **)(a1 + 88), @"L");
  CFStringRef v11 = v10;
  if (*(unsigned char *)(a1 + 48)) {
    uint64_t v12 = "F";
  }
  else {
    uint64_t v12 = "f";
  }
  uint64_t v13 = "S";
  if (!*(unsigned char *)(a1 + 49)) {
    uint64_t v13 = "s";
  }
  if (*(unsigned char *)(a1 + 50)) {
    uint64_t v14 = "K";
  }
  else {
    uint64_t v14 = "k";
  }
  CFStringRef v4 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"<%@ %s%s%s%@%@%@%@%@>", *(void *)(a1 + 16), v12, v13, v14, v3, v6, v8, v9, v10);
  if (v11) {
    CFRelease(v11);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v8) {
    CFRelease(v8);
  }
  if (v6) {
    CFRelease(v6);
  }
  if (v3) {
    CFRelease(v3);
  }
  return v4;
}

CFStringRef sub_100205720(const __CFArray *a1, uint64_t a2)
{
  if (!a1) {
    return @" -  ";
  }
  CFIndex Count = CFArrayGetCount(a1);
  if (!Count) {
    return @" -  ";
  }
  CFIndex v5 = Count;
  CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(a1, 0);
  return CFStringCreateWithFormat(kCFAllocatorDefault, 0, @" %@[%ld]%@", a2, v5, ValueAtIndex);
}

BOOL sub_1002057A4(uint64_t a1, uint64_t a2)
{
  return CFEqual(*(CFStringRef *)(a1 + 16), *(CFStringRef *)(a2 + 16));
}

void sub_1002057D0(void *a1)
{
  uint64_t v2 = (const void *)a1[2];
  if (v2)
  {
    a1[2] = 0;
    CFRelease(v2);
  }
  CFStringRef v3 = (const void *)a1[3];
  if (v3)
  {
    a1[3] = 0;
    CFRelease(v3);
  }
  CFStringRef v4 = (const void *)a1[7];
  if (v4)
  {
    a1[7] = 0;
    CFRelease(v4);
  }
  CFIndex v5 = (const void *)a1[8];
  if (v5)
  {
    a1[8] = 0;
    CFRelease(v5);
  }
  CFStringRef v6 = (const void *)a1[9];
  if (v6)
  {
    a1[9] = 0;
    CFRelease(v6);
  }
  uint64_t v7 = (const void *)a1[10];
  if (v7)
  {
    a1[10] = 0;
    CFRelease(v7);
  }
  CFStringRef v8 = (const void *)a1[11];
  if (v8)
  {
    a1[11] = 0;
    CFRelease(v8);
  }
  CFStringRef v9 = (const void *)a1[13];
  if (v9)
  {
    a1[13] = 0;
    CFRelease(v9);
  }
  CFStringRef v10 = (const void *)a1[12];
  if (v10)
  {
    a1[12] = 0;
    CFRelease(v10);
  }
  CFStringRef v11 = (const void *)a1[14];
  if (v11)
  {
    a1[14] = 0;
    CFRelease(v11);
  }
}

__CFDictionary *sub_1002058A8(uint64_t a1)
{
  CFMutableSetRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  uint64_t valuePtr = *(void *)(a1 + 40);
  CFNumberRef v3 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt64Type, &valuePtr);
  CFDictionarySetValue(Mutable, @"sequence-number", v3);
  if (v3) {
    CFRelease(v3);
  }
  if (*(void *)(a1 + 32))
  {
    uint64_t valuePtr = *(void *)(a1 + 32);
    CFNumberRef v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
    CFDictionarySetValue(Mutable, @"vers", v4);
    if (v4) {
      CFRelease(v4);
    }
  }
  if (*(unsigned char *)(a1 + 48)) {
    CFBooleanRef v5 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v5 = kCFBooleanFalse;
  }
  CFDictionarySetValue(Mutable, @"must-send", v5);
  if (*(unsigned char *)(a1 + 49)) {
    CFBooleanRef v6 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v6 = kCFBooleanFalse;
  }
  CFDictionarySetValue(Mutable, @"send-objects", v6);
  if (*(unsigned char *)(a1 + 50)) {
    CFBooleanRef v7 = kCFBooleanTrue;
  }
  else {
    CFBooleanRef v7 = kCFBooleanFalse;
  }
  CFDictionarySetValue(Mutable, @"has-been-in-sync", v7);
  CFStringRef v8 = *(const void **)(a1 + 24);
  if (v8) {
    CFDictionarySetValue(Mutable, @"views", v8);
  }
  CFStringRef v9 = *(const void **)(a1 + 112);
  if (v9 && !CFEqual(*(CFTypeRef *)(a1 + 16), kSOSViewKeychainV0_tomb)) {
    CFDictionarySetValue(Mutable, @"keybag", v9);
  }
  if (!sub_100205AC4(Mutable, @"pending-objects", *(__CFData **)(a1 + 56))
    || !sub_100205AC4(Mutable, @"unwanted-manifest", *(__CFData **)(a1 + 64))
    || !sub_100205AC4(Mutable, @"confirmed-manifest", *(__CFData **)(a1 + 72))
    || !sub_100205B18(Mutable, @"pending-manifest", *(const __CFArray **)(a1 + 80))
    || !sub_100205B18(Mutable, @"local-manifest", *(const __CFArray **)(a1 + 88)))
  {
    if (Mutable)
    {
      CFRelease(Mutable);
      return 0;
    }
  }
  return Mutable;
}

uint64_t sub_100205AC4(__CFDictionary *a1, const void *a2, __CFData *a3)
{
  if (!a3) {
    return 1;
  }
  uint64_t result = (uint64_t)sub_100200D6C(a3);
  if (result)
  {
    CFDictionarySetValue(a1, a2, (const void *)result);
    return 1;
  }
  return result;
}

BOOL sub_100205B18(__CFDictionary *a1, const void *a2, const __CFArray *a3)
{
  CFMutableSetRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (a3)
  {
    CFIndex Count = CFArrayGetCount(a3);
    if (Count >= 1)
    {
      CFIndex v8 = Count;
      for (CFIndex i = 0; i != v8; ++i)
      {
        CFDataRef ValueAtIndex = (__CFData *)CFArrayGetValueAtIndex(a3, i);
        CFStringRef v11 = sub_100200D6C(ValueAtIndex);
        if (v11)
        {
          if (Mutable) {
            CFArrayAppendValue(Mutable, v11);
          }
        }
        else if (Mutable)
        {
          CFRelease(Mutable);
          CFMutableSetRef Mutable = 0;
        }
      }
    }
  }
  if (Mutable)
  {
    CFDictionarySetValue(a1, a2, Mutable);
    CFRelease(Mutable);
  }
  return Mutable != 0;
}

CFDictionaryRef sub_100205BF4(const __CFDictionary *result)
{
  if (result)
  {
    CFDictionaryRef v1 = result;
    CFTypeID v2 = CFGetTypeID(result);
    if (v2 == sub_100204858()) {
      BOOL v3 = *((void *)v1 + 14) == 0;
    }
    else {
      BOOL v3 = CFDictionaryContainsKey(v1, @"keybag") == 0;
    }
    return (const __CFDictionary *)!v3;
  }
  return result;
}

void sub_100205C54(uint64_t a1, char *a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = open(a2, 0x1000000);
  if (sub_1000296CC(*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) >> 31, *(CFTypeRef **)(a1 + 40), @"open %s", v4, v5, v6, v7, v8, (char)a2))
  {
    int v9 = unlink(a2);
    if (sub_1000296CC(v9, *(CFTypeRef **)(a1 + 40), @"unlink %s", v10, v11, v12, v13, v14, (char)a2))
    {
      CFTypeRef v15 = sub_10000B070("backup");
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        int v16 = *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
        v17.tv_sec = 0xAAAAAAAAAAAAAAAALL;
        v17.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
        *(timespec *)&v21.st_blksize = v17;
        *(timespec *)v21.st_qspare = v17;
        v21.st_birthtimespec = v17;
        *(timespec *)&v21.st_size = v17;
        v21.st_mtimespec = v17;
        v21.st_ctimespec = v17;
        *(timespec *)&v21.st_uid = v17;
        v21.st_atimespec = v17;
        *(timespec *)&v21.st_dev = v17;
        fstat(v16, &v21);
        v21.st_dev = 136315394;
        *(void *)&v21.st_mode = a2;
        WORD2(v21.st_ino) = 2048;
        *(__darwin_ino64_t *)((char *)&v21.st_ino + 6) = v21.st_size;
        CFTypeID v18 = "Handing off file %s of size %llu";
LABEL_13:
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v18, (uint8_t *)&v21, 0x16u);
      }
    }
    else
    {
      close(*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = -1;
      CFTypeRef v15 = sub_10000B070("backup");
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v20 = *(void **)(a1 + 40);
        if (v20) {
          uint64_t v20 = (void *)*v20;
        }
        v21.st_dev = 136315394;
        *(void *)&v21.st_mode = a2;
        WORD2(v21.st_ino) = 2112;
        *(__darwin_ino64_t *)((char *)&v21.st_ino + 6) = (__darwin_ino64_t)v20;
        CFTypeID v18 = "Unable to unlink file %s: %@";
        goto LABEL_13;
      }
    }
  }
  else
  {
    CFTypeRef v15 = sub_10000B070("backup");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = *(void **)(a1 + 40);
      if (v19) {
        uint64_t v19 = (void *)*v19;
      }
      v21.st_dev = 136315394;
      *(void *)&v21.st_mode = a2;
      WORD2(v21.st_ino) = 2112;
      *(__darwin_ino64_t *)((char *)&v21.st_ino + 6) = (__darwin_ino64_t)v19;
      CFTypeID v18 = "Handing off file %s failed, %@";
      goto LABEL_13;
    }
  }
}

BOOL sub_100205E7C(uint64_t a1, CFTypeRef *a2, void *a3)
{
  uint64_t v12 = 0;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2020000000;
  char v15 = 1;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  void v7[2] = sub_100205F80;
  v7[3] = &unk_1003087A0;
  uint64_t v10 = a2;
  uint64_t v11 = a1;
  int v9 = &v12;
  id v3 = a3;
  id v8 = v3;
  BOOL v4 = sub_100204E84(v11, v10, v7);
  if (*((unsigned char *)v13 + 24)) {
    BOOL v5 = v4;
  }
  else {
    BOOL v5 = 0;
  }
  *((unsigned char *)v13 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v5;

  _Block_object_dispose(&v12, 8);
  return v5;
}

void sub_100205F68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100205F80(uint64_t a1, char *__filename)
{
  char v2 = (char)__filename;
  BOOL v4 = *(CFTypeRef **)(a1 + 48);
  BOOL v5 = fopen(__filename, "a");
  uint64_t result = sub_1000296CC(v5 == 0, v4, @"fopen %s,%s", v6, v7, v8, v9, v10, v2);
  if (v5)
  {
    int v20 = -1;
    uint64_t v12 = *(void *)(a1 + 56);
    if (CFEqual(*(CFTypeRef *)(v12 + 16), kSOSViewKeychainV0_tomb))
    {
      CFDataRef v13 = *(const __CFData **)(v12 + 112);
      if (v13) {
        CFRetain(*(CFTypeRef *)(v12 + 112));
      }
    }
    else
    {
      uint64_t v14 = SOSBackupSliceKeyBagCreateFromData();
      if (v14)
      {
        char v15 = (const void *)v14;
        CFDataRef v13 = (const __CFData *)SOSBSKBCopyAKSBag();
        CFRelease(v15);
      }
      else
      {
        CFDataRef v13 = 0;
      }
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v13 != 0;
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
    {
      BOOL v16 = sub_100155410(v13, 0, &v20, *(CFTypeRef **)(a1 + 48));
      *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v16;
      if (v16)
      {
        (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
        if (v20 != -1)
        {
          BOOL v17 = sub_10015554C(v20, *(CFTypeRef **)(a1 + 48));
          uint64_t v18 = *(void *)(*(void *)(a1 + 40) + 8);
          if (*(unsigned char *)(v18 + 24)) {
            BOOL v19 = v17;
          }
          else {
            BOOL v19 = 0;
          }
          *(unsigned char *)(v18 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v19;
        }
      }
    }
    if (v13) {
      CFRelease(v13);
    }
    return fclose(v5);
  }
  return result;
}

BOOL sub_10020610C(uint64_t a1, uint64_t a2, CFDictionaryRef theDict, __CFArray *a4)
{
  if (!theDict) {
    return 1;
  }
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(theDict, @"vers");
  if (Value) {
    CFNumberGetValue(Value, kCFNumberCFIndexType, (void *)(a1 + 32));
  }
  *(void *)id v30 = 0;
  CFNumberRef v9 = (const __CFNumber *)CFDictionaryGetValue(theDict, @"sequence-number");
  if (v9)
  {
    CFNumberGetValue(v9, kCFNumberSInt64Type, v30);
    uint64_t v10 = *(void *)v30;
  }
  else
  {
    uint64_t v10 = 0;
  }
  *(void *)(a1 + 40) = v10;
  *(unsigned char *)(a1 + 4_Block_object_dispose(&a9, 8) = sub_1002063E0(theDict, @"must-send");
  *(unsigned char *)(a1 + 49) = sub_1002063E0(theDict, @"send-objects");
  *(unsigned char *)(a1 + 50) = sub_1002063E0(theDict, @"has-been-in-sync");
  uint64_t V0ViewSet = CFDictionaryGetValue(theDict, @"views");
  if (!V0ViewSet)
  {
    uint64_t V0ViewSet = (const void *)SOSViewsGetV0ViewSet();
    CFDataRef v13 = sub_10000B070("peer");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = *(void *)(a1 + 16);
      *(_DWORD *)id v30 = 138412546;
      *(void *)&v30[4] = v14;
      __int16 v31 = 2112;
      uint64_t v32 = V0ViewSet;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%@ had no views, inferring: %@", v30, 0x16u);
    }
  }
  char v15 = *(const void **)(a1 + 24);
  if (v15 != V0ViewSet)
  {
    if (!V0ViewSet || (CFRetain(V0ViewSet), (char v15 = *(const void **)(a1 + 24)) != 0)) {
      CFRelease(v15);
    }
    *(void *)(a1 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = V0ViewSet;
  }
  BOOL v16 = CFDictionaryGetValue(theDict, @"keybag");
  if (!v16 || (v17 = v16, CFTypeID v18 = CFGetTypeID(v16), v18 != CFDataGetTypeID())) {
    BOOL v17 = 0;
  }
  sub_100204A08(a1, v17);
  BOOL v19 = sub_1000FBE94(a2, theDict, @"pending-objects");
  int v20 = *(const void **)(a1 + 56);
  if (v20) {
    CFRelease(v20);
  }
  *(void *)(a1 + 56) = v19;
  stat v21 = sub_1000FBE94(a2, theDict, @"unwanted-manifest");
  uint64_t v22 = *(const void **)(a1 + 64);
  if (v22) {
    CFRelease(v22);
  }
  *(void *)(a1 + 64) = v21;
  CFTypeRef v23 = sub_1000FBE94(a2, theDict, @"confirmed-manifest");
  uint64_t v24 = *(const void **)(a1 + 72);
  if (v24) {
    CFRelease(v24);
  }
  *(void *)(a1 + 72) = v23;
  CFMutableArrayRef v25 = sub_1000FBF20(a2, theDict, @"pending-manifest", a4);
  uint64_t v26 = *(const void **)(a1 + 80);
  if (v26) {
    CFRelease(v26);
  }
  *(void *)(a1 + 80) = v25;
  CFMutableArrayRef v27 = sub_1000FBF20(a2, theDict, @"local-manifest", a4);
  uint64_t v28 = *(const void **)(a1 + 88);
  if (v28) {
    CFRelease(v28);
  }
  *(void *)(a1 + 8_Block_object_dispose(&a9, 8) = v27;
  if (v25) {
    BOOL v29 = v27 == 0;
  }
  else {
    BOOL v29 = 1;
  }
  return !v29;
}

CFBooleanRef sub_1002063E0(const __CFDictionary *a1, const void *a2)
{
  CFBooleanRef result = (const __CFBoolean *)CFDictionaryGetValue(a1, a2);
  if (result) {
    return (const __CFBoolean *)(CFBooleanGetValue(result) != 0);
  }
  return result;
}

void *sub_100206408(uint64_t a1, const void *a2, const __CFDictionary *a3, __CFArray *a4)
{
  sub_100204858();
  uint64_t Instance = (void *)_CFRuntimeCreateInstance();
  if (a2) {
    CFRetain(a2);
  }
  Instance[2] = a2;
  Instance[4] = 0;
  CFDictionaryRef v9 = 0;
  Instance[13] = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!a3)
  {
    CFDictionaryRef v9 = CFDictionaryCreate(kCFAllocatorDefault, 0, 0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    a3 = v9;
  }
  if (!sub_10020610C((uint64_t)Instance, a1, a3, a4))
  {
    CFRelease(Instance);
    uint64_t Instance = 0;
  }
  if (v9) {
    CFRelease(v9);
  }
  return Instance;
}

void sub_100206508(__CFArray **a1, const void *a2)
{
  id v3 = *a1;
  if (a2)
  {
    if (v3)
    {
      CFArrayRemoveAllValues(v3);
      CFMutableSetRef Mutable = *a1;
    }
    else
    {
      CFMutableSetRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      *a1 = Mutable;
    }
    CFArrayAppendValue(Mutable, a2);
  }
  else if (v3)
  {
    *a1 = 0;
    CFRelease(v3);
  }
}

const void *sub_1002065A8(uint64_t a1)
{
  CFArrayRef v2 = *(const __CFArray **)(a1 + 80);
  if (!v2 || !CFArrayGetCount(v2)) {
    return 0;
  }
  CFArrayRef v3 = *(const __CFArray **)(a1 + 80);

  return CFArrayGetValueAtIndex(v3, 0);
}

void sub_100206600(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 72);
  if (v3 != cf)
  {
    if (!cf || (CFRetain(cf), (CFTypeRef v3 = *(CFTypeRef *)(a1 + 72)) != 0)) {
      CFRelease(v3);
    }
    *(void *)(a1 + 72) = cf;
  }
}

void sub_10020664C(CFArrayRef *a1, const void *a2)
{
  CFArrayRef v3 = *a1;
  if (*a1)
  {
    if (a2)
    {
      uint64_t Count = CFArrayGetCount(*a1);
      v9.id location = 0;
      v9.size_t length = Count;
      FirstIndexOfCFNumberRef Value = CFArrayGetFirstIndexOfValue(v3, v9, a2);
      if (FirstIndexOfValue)
      {
        if (FirstIndexOfValue == -1)
        {
          if (Count >= 4)
          {
            unint64_t v6 = Count + 1;
            do
            {
              CFArrayRemoveValueAtIndex(v3, v6 - 2);
              --v6;
            }
            while (v6 > 4);
          }
        }
        else
        {
          CFArrayRemoveValueAtIndex(v3, FirstIndexOfValue);
        }
        CFArrayInsertValueAtIndex(v3, 0, a2);
      }
    }
    else
    {
      uint64_t v7 = *a1;
      CFArrayRemoveAllValues(v7);
    }
  }
  else
  {
    sub_100206508(a1, a2);
  }
}

BOOL sub_100206754(void *key, CFDictionaryRef theDict)
{
  CFArrayRef v2 = CFDictionaryGetValue(theDict, key);
  BOOL v3 = v2 != 0;

  return v3;
}

__CFData *sub_100206794(__CFData **a1, const void *a2)
{
  if (!a2) {
    return 0;
  }
  CFArrayRef v4 = a1[10];
  if (v4)
  {
    CFIndex Count = CFArrayGetCount(v4);
    if (Count >= 1)
    {
      CFIndex v6 = Count;
      CFIndex v7 = 0;
      do
      {
        CFDataRef ValueAtIndex = (__CFData *)CFArrayGetValueAtIndex(a1[10], v7);
        CFRange v9 = sub_100200D6C(ValueAtIndex);
        if (CFEqual(a2, v9)) {
          goto LABEL_15;
        }
      }
      while (v6 != ++v7);
    }
  }
  CFArrayRef v10 = a1[11];
  if (v10)
  {
    CFIndex v11 = CFArrayGetCount(v10);
    if (v11 >= 1)
    {
      CFIndex v12 = v11;
      CFIndex v13 = 0;
      do
      {
        CFDataRef ValueAtIndex = (__CFData *)CFArrayGetValueAtIndex(a1[11], v13);
        uint64_t v14 = sub_100200D6C(ValueAtIndex);
        if (CFEqual(a2, v14)) {
          goto LABEL_15;
        }
      }
      while (v12 != ++v13);
    }
  }
  char v15 = a1[9];
  if (!v15) {
    return 0;
  }
  BOOL v16 = sub_100200D6C(v15);
  if (!CFEqual(a2, v16)) {
    return 0;
  }
  CFDataRef ValueAtIndex = a1[9];
LABEL_15:
  if (ValueAtIndex) {
    CFRetain(ValueAtIndex);
  }
  return ValueAtIndex;
}

void sub_10020689C(__CFDictionary *a1, __CFData *a2)
{
  CFArrayRef v4 = sub_100200D6C(a2);
  if (a2)
  {
    if (v4)
    {
      BOOL v5 = (const void *)*((void *)a2 + 3);
      if (v5)
      {
        CFDictionarySetValue(a1, v4, v5);
      }
    }
  }
}

void sub_1002068FC(__CFDictionary *a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFArrayGetTypeID())
    {
      CFIndex Count = CFArrayGetCount((CFArrayRef)cf);
      if (Count >= 1)
      {
        CFIndex v6 = Count;
        for (CFIndex i = 0; i != v6; ++i)
        {
          CFDataRef ValueAtIndex = (__CFData *)CFArrayGetValueAtIndex((CFArrayRef)cf, i);
          sub_10020689C(a1, ValueAtIndex);
        }
      }
    }
  }
}

void sub_100206984(void *a1, uint64_t a2, uint64_t a3, CFDataRef *a4, CFTypeRef *a5)
{
  if ((a2 | 2) == 3 && a4 && (unint64_t)CFDataGetLength(a4[3]) >= 0x14)
  {
    CFArrayRef v10 = (CFDataRef *)sub_100201580(a1[9], a4, a5);
    if (!a3) {
      goto LABEL_8;
    }
LABEL_7:
    if ((unint64_t)CFDataGetLength(*(CFDataRef *)(a3 + 24)) > 0x13) {
      goto LABEL_10;
    }
    goto LABEL_8;
  }
  CFArrayRef v10 = 0;
  if (a3) {
    goto LABEL_7;
  }
LABEL_8:
  if (!v10) {
    return;
  }
  if ((unint64_t)CFDataGetLength(v10[3]) < 0x14) {
    goto LABEL_18;
  }
LABEL_10:
  uint64_t v11 = sub_1002014F4(a1[7], a3, (uint64_t)v10, a5);
  CFTypeRef v23 = 0;
  CFTypeRef cf = 0;
  sub_10020113C(a1[7], v11, (uint64_t *)&cf, &v23, a5);
  CFIndex v12 = sub_10000B070("peer");
  if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG)) {
    goto LABEL_11;
  }
  uint64_t v14 = a1[2];
  char v15 = "sos";
  if (a2 == 3) {
    char v15 = "ckks";
  }
  if (a2 == 1) {
    char v15 = "api";
  }
  uint64_t v22 = v15;
  if (cf && (unint64_t)CFDataGetLength(*((CFDataRef *)cf + 3)) > 0x13) {
    BOOL v16 = "-";
  }
  else {
    BOOL v16 = "";
  }
  BOOL v17 = (CFDataRef *)cf;
  if (!cf
    || (unint64_t Length = CFDataGetLength(*((CFDataRef *)cf + 3)),
        BOOL v17 = (CFDataRef *)cf,
        CFStringRef v19 = (const __CFString *)cf,
        Length <= 0x13))
  {
    CFStringRef v19 = &stru_10030AA90;
  }
  if (!v23) {
    goto LABEL_34;
  }
  if ((unint64_t)CFDataGetLength(*((CFDataRef *)v23 + 3)) <= 0x13)
  {
    BOOL v17 = (CFDataRef *)cf;
LABEL_34:
    int v20 = "=";
    if (v17 && (unint64_t)CFDataGetLength(v17[3]) >= 0x14) {
      int v20 = "";
    }
    goto LABEL_39;
  }
  int v20 = "+";
LABEL_39:
  if (v23 && (unint64_t)CFDataGetLength(*((CFDataRef *)v23 + 3)) > 0x13) {
    CFStringRef v21 = (const __CFString *)v23;
  }
  else {
    CFStringRef v21 = &stru_10030AA90;
  }
  *(_DWORD *)long long buf = 138414338;
  uint64_t v26 = v14;
  __int16 v27 = 2112;
  uint64_t v28 = a3;
  __int16 v29 = 2112;
  id v30 = a4;
  __int16 v31 = 2112;
  uint64_t v32 = v10;
  __int16 v33 = 2080;
  uint64_t v34 = v22;
  __int16 v35 = 2080;
  char v36 = v16;
  __int16 v37 = 2112;
  CFStringRef v38 = v19;
  __int16 v39 = 2080;
  CFStringRef v40 = v20;
  __int16 v41 = 2112;
  CFStringRef v42 = v21;
  _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "%@: willCommit R:%@ A:%@ UA:%@ %s O%s%@%s%@", buf, 0x5Cu);
LABEL_11:

  if (cf) {
    CFRelease(cf);
  }
  if (v23) {
    CFRelease(v23);
  }
  CFIndex v13 = (const void *)a1[7];
  if (v13) {
    CFRelease(v13);
  }
  a1[7] = v11;
  if (v10) {
LABEL_18:
  }
    CFRelease(v10);
}

void sub_100206C78(uint64_t a1, FILE *a2, int a3)
{
  *(_OWORD *)uint64_t v32 = 0u;
  long long v33 = 0u;
  *(_OWORD *)id v30 = 0u;
  long long v31 = 0u;
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 40));
  if (Count >= 1)
  {
    CFIndex v7 = Count;
    CFIndex v8 = 0;
    uint64_t v28 = a3;
    do
    {
      CFArrayRef ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 40), v8);
      CFArrayRef v10 = ValueAtIndex;
      CFTypeRef cf = 0;
      uint64_t v11 = *(void *)(a1 + 48);
      if (ValueAtIndex)
      {
        CFTypeID v12 = CFGetTypeID(ValueAtIndex);
        if (v12 == CFArrayGetTypeID())
        {
          if (CFArrayGetCount(v10) != 1)
          {
            CFIndex v20 = CFArrayGetCount(v10);
            sub_100012A40(-26275, (__CFString **)&cf, @"change array count: %ld", v20);
            BOOL v17 = 0;
            CFDataRef v16 = 0;
            CFIndex v13 = 0;
            goto LABEL_16;
          }
          CFIndex v13 = CFArrayGetValueAtIndex(v10, 0);
          int v14 = 1;
          if (!v13) {
            goto LABEL_12;
          }
        }
        else
        {
          int v14 = 0;
          CFIndex v13 = v10;
        }
        CFTypeID v15 = CFGetTypeID(v13);
        if (v15 == CFDataGetTypeID())
        {
          CFDataRef v16 = (const __CFData *)CFRetain(v13);
          CFIndex v13 = 0;
          goto LABEL_13;
        }
      }
      else
      {
        int v14 = 0;
        CFIndex v13 = 0;
      }
LABEL_12:
      CFDataRef v16 = (const __CFData *)(*(uint64_t (**)(const void *, CFTypeRef *))(v11 + 112))(v13, &cf);
LABEL_13:
      BOOL v17 = v16 != 0;
      if (v14)
      {
        BOOL v18 = sub_1001FB210(a2, v16, (__CFString **)&cf);
        CFStringRef v19 = v32;
        goto LABEL_20;
      }
LABEL_16:
      CFDictionaryRef v21 = (const __CFDictionary *)(*(uint64_t (**)(const void *, uint64_t, CFTypeRef *))(*(void *)(a1 + 48)
                                                                                                  + 144))(v13, v28, &cf);
      if (v21)
      {
        CFDictionaryRef v22 = v21;
        BOOL v18 = sub_1001FB314(a2, v21, (__CFString **)&cf);
        CFRelease(v22);
      }
      else
      {
        BOOL v18 = 0;
      }
      CFStringRef v19 = v30;
LABEL_20:
      BytePtr = (long long *)CFDataGetBytePtr(v16);
      sub_100200054((char **)v19, BytePtr);
      *((unsigned char *)v19 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
      if (v17 && v18) {
        goto LABEL_25;
      }
      uint64_t v24 = sub_10000B070("SecError");
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412546;
        *(void *)&uint8_t buf[4] = v10;
        *(_WORD *)&unsigned char buf[12] = 2112;
        *(void *)&buf[14] = cf;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "bad change %@: %@", buf, 0x16u);
      }

      if (v17) {
LABEL_25:
      }
        CFRelease(v16);
      if (cf) {
        CFRelease(cf);
      }
      ++v8;
    }
    while (v7 != v8);
  }
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    memset(buf, 0, sizeof(buf));
    sub_1002001D4((char **)v32);
    sub_1002001D4((char **)v30);
    CFMutableArrayRef v25 = sub_1002065A8(*(void *)(a1 + 56));
    uint64_t v26 = (uint64_t *)sub_1002010DC((uint64_t)v25);
    sub_10020082C(v26, (unint64_t *)v32, (uint64_t)v30, (char **)buf);
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    __int16 v27 = (const void *)sub_100201498((uint64_t)buf, *(CFTypeRef **)(a1 + 64));
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v27 != 0;
    sub_100206508((__CFArray **)(*(void *)(a1 + 56) + 80), v27);
    if (v27) {
      CFRelease(v27);
    }
    free(*(void **)buf);
  }
  free(v32[0]);
  free(v30[0]);
  if (*(unsigned char *)(*(void *)(a1 + 56) + 49)) {
    sub_1001FB3CC(a2, 799, *(__CFString ***)(a1 + 64));
  }
}

uint64_t sub_100206FF0(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, CFTypeRef *a6, void *a7, const void *a8, SOSEnginePeerMessageCallBackInfo **a9, CFTypeRef *a10)
{
  id v15 = a1;
  if (a5)
  {
    uint64_t v243 = a2;
    unint64_t v245 = v15;
    CFDataRef v16 = sub_10000B070("transport");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = a5;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "coder state: %@", buf, 0xCu);
    }

    if (!*(void *)(a5 + 24) || !SecOTRSGetIsReadyForMessages() || *(unsigned char *)(a5 + 32))
    {
      CFDataRef v17 = *(const __CFData **)(a5 + 40);
      if (v17) {
        CFDataRef Copy = CFDataCreateCopy(kCFAllocatorDefault, v17);
      }
      else {
        CFDataRef Copy = 0;
      }
      *a6 = Copy;
      if (-[OTSOSActualAdapter sosEnabled]_0()) {
        *(unsigned char *)(a2 + 105) = 1;
      }
      CFDictionaryRef v22 = sub_10000B070("transport");
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      {
        CFStringRef v54 = @"sending negotiation message.";
        if (!*a6) {
          CFStringRef v54 = @"waiting for negotiation message.";
        }
        *(_DWORD *)long long buf = 138412546;
        *(void *)&uint8_t buf[4] = a7;
        *(_WORD *)&unsigned char buf[12] = 2112;
        *(void *)&buf[14] = v54;
        _os_log_debug_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEBUG, "%@ negotiating, %@", buf, 0x16u);
      }

      CFTypeRef v23 = objc_opt_new();
      [v23 setCallbackBlock:0];
      [v23 setCoder:a5];
      *(void *)long long buf = 0xAAAAAAAAAAAAAAAALL;
      objc_initWeak((id *)buf, v23);
      v246[0] = _NSConcreteStackBlock;
      v246[1] = 3221225472;
      v246[2] = sub_1002095B0;
      v246[3] = &unk_100308890;
      objc_copyWeak(&v247, (id *)buf);
      id v24 = v23;
      CFMutableArrayRef v25 = v246;
      BOOL v26 = !-[OTSOSActualAdapter sosEnabled]_0();
      if (!v24) {
        LOBYTE(v26) = 1;
      }
      if (!v26) {
        [v24 setCallbackBlock:v25];
      }

      __int16 v27 = (SOSEnginePeerMessageCallBackInfo *)v24;
      *a9 = v27;
      objc_destroyWeak(&v247);
      objc_destroyWeak((id *)buf);

      uint64_t v28 = 1;
      goto LABEL_21;
    }
    __int16 v41 = sub_10000B070("transport");
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = a7;
      _os_log_debug_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEBUG, "%@ Coder can wrap, getting message from engine", buf, 0xCu);
    }

    if (!-[OTSOSActualAdapter sosEnabled]_0())
    {
      SOSCCSetSOSDisabledError();
      goto LABEL_373;
    }
    CFStringRef v42 = (CFDataRef *)sub_100100424(a2, a4);
    uint64_t v262 = 0;
    uint64_t v263 = &v262;
    uint64_t v264 = 0x2020000000;
    unint64_t v265 = 0xAAAAAAAAAAAAAAAALL;
    uint64_t v43 = *(void *)(a4 + 32);
    sub_100203134();
    uint64_t Instance = _CFRuntimeCreateInstance();
    *(void *)(Instance + 112) = v43;
    unint64_t v265 = Instance;
    uint64_t v46 = *(void **)(a4 + 64);
    uint64_t v45 = *(void *)(a4 + 72);
    CFTypeRef cf = 0;
    CFTypeRef v261 = 0;
    CFTypeRef v258 = 0;
    CFTypeRef v259 = 0;
    CFTypeRef v256 = 0;
    CFTypeRef v257 = 0;
    uint64_t v47 = *(CFDataRef **)(a4 + 56);
    uint64_t v238 = v42;
    cf1 = (CFDataRef *)v45;
    sub_10020113C(v45, (uint64_t)v42, (uint64_t *)&v261, &cf, a10);
    sub_10020113C((uint64_t)cf, (uint64_t)v47, (uint64_t *)&v259, &v258, a10);
    if (v258 && (unint64_t)CFDataGetLength(*((CFDataRef *)v258 + 3)) >= 0x14)
    {
      uint64_t v48 = sub_10000B070("SecError");
      if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412546;
        *(void *)&uint8_t buf[4] = a4;
        *(_WORD *)&unsigned char buf[12] = 2112;
        *(void *)&buf[14] = v258;
        _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "%@ ASSERTION FAILURE purging excess pendingObjects: %@", buf, 0x16u);
      }

      CFTypeRef v49 = sub_100201580((uint64_t)v258, v47, a10);
      CFTypeRef v50 = *(CFTypeRef *)(a4 + 56);
      if (v50 != v49)
      {
        if (!v49 || (CFRetain(v49), (CFTypeRef v50 = *(CFTypeRef *)(a4 + 56)) != 0)) {
          CFRelease(v50);
        }
        *(void *)(a4 + 56) = v49;
      }
      if (v49)
      {
        CFRelease(v49);
        uint64_t v47 = *(CFDataRef **)(a4 + 56);
      }
      else
      {
        uint64_t v47 = 0;
      }
    }
    v235 = v47;
    sub_10020113C((uint64_t)v261, (uint64_t)v46, (uint64_t *)&v257, &v256, a10);
    if (v256 && (unint64_t)CFDataGetLength(*((CFDataRef *)v256 + 3)) >= 0x14)
    {
      CFStringRef v55 = sub_10000B070("SecError");
      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412546;
        *(void *)&uint8_t buf[4] = a4;
        *(_WORD *)&unsigned char buf[12] = 2112;
        *(void *)&buf[14] = v256;
        _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "%@ ASSERTION FAILURE purging excess unwanted: %@", buf, 0x16u);
      }

      CFTypeRef v56 = sub_100201580((uint64_t)v256, v46, a10);
      CFTypeRef v57 = *(CFTypeRef *)(a4 + 64);
      if (v57 != v56)
      {
        if (!v56 || (CFRetain(v56), (CFTypeRef v57 = *(CFTypeRef *)(a4 + 64)) != 0)) {
          CFRelease(v57);
        }
        *(void *)(a4 + 64) = v56;
      }
      if (v56)
      {
        CFRelease(v56);
        uint64_t v46 = *(void **)(a4 + 64);
      }
      else
      {
        uint64_t v46 = 0;
      }
    }
    CFTypeRef v58 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v58);
    }
    CFTypeRef v59 = v258;
    if (v258)
    {
      CFTypeRef v258 = 0;
      CFRelease(v59);
    }
    CFTypeRef v60 = v261;
    if (v261)
    {
      CFTypeRef v261 = 0;
      CFRelease(v60);
    }
    CFTypeRef v61 = v256;
    if (v256)
    {
      CFTypeRef v256 = 0;
      CFRelease(v61);
    }
    CFMutableArrayRef v62 = sub_10000B070("engine");
    if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
    {
      dispatch_queue_t queue = *(dispatch_queue_t *)(a4 + 16);
      CFMutableArrayRef v63 = "L";
      if (!v42) {
        CFMutableArrayRef v63 = "l";
      }
      uint64_t v229 = *(void *)(v243 + 24);
      id v230 = v63;
      if (cf1) {
        id v64 = "C";
      }
      else {
        id v64 = "0";
      }
      char v65 = "P";
      if (!v47) {
        char v65 = "0";
      }
      v226 = v65;
      v227 = v64;
      if (*(unsigned char *)(a4 + 49)) {
        unsigned int v66 = "O";
      }
      else {
        unsigned int v66 = "o";
      }
      if (*(unsigned char *)(a4 + 48)) {
        unint64_t v67 = "S";
      }
      else {
        unint64_t v67 = "s";
      }
      v224 = v67;
      v225 = v66;
      if (v42) {
        unint64_t v223 = CFDataGetLength(v42[3]) / 0x14uLL;
      }
      else {
        unint64_t v223 = 0;
      }
      if (cf1) {
        unint64_t v222 = CFDataGetLength(cf1[3]) / 0x14uLL;
      }
      else {
        unint64_t v222 = 0;
      }
      if (v47) {
        unint64_t v221 = CFDataGetLength(v47[3]) / 0x14uLL;
      }
      else {
        unint64_t v221 = 0;
      }
      char v68 = (CFDataRef *)v46;
      if (v259) {
        unint64_t v69 = CFDataGetLength(*((CFDataRef *)v259 + 3)) / 0x14uLL;
      }
      else {
        unint64_t v69 = 0;
      }
      if (v257) {
        unint64_t v70 = CFDataGetLength(*((CFDataRef *)v257 + 3)) / 0x14uLL;
      }
      else {
        unint64_t v70 = 0;
      }
      if (v68) {
        unint64_t v71 = CFDataGetLength(v68[3]) / 0x14uLL;
      }
      else {
        unint64_t v71 = 0;
      }
      *(_DWORD *)long long buf = 138415362;
      *(void *)&uint8_t buf[4] = v229;
      *(_WORD *)&unsigned char buf[12] = 2112;
      *(void *)&buf[14] = queue;
      *(_WORD *)&buf[22] = 2080;
      id v271 = v230;
      LOWORD(v272[0]) = 2080;
      *(void *)((char *)v272 + 2) = v227;
      WORD5(v272[0]) = 2080;
      *(void *)((char *)v272 + 12) = v226;
      WORD2(v272[1]) = 2080;
      *(void *)((char *)&v272[1] + 6) = v225;
      HIWORD(v272[1]) = 2080;
      uint64_t v273 = v224;
      __int16 v274 = 2048;
      unint64_t v275 = v223;
      __int16 v276 = 2048;
      unint64_t v277 = v222;
      __int16 v278 = 2048;
      unint64_t v279 = v221;
      __int16 v280 = 2048;
      unint64_t v281 = v69;
      __int16 v282 = 2048;
      unint64_t v283 = v70;
      __int16 v284 = 2048;
      unint64_t v285 = v71;
      _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "%@:%@: send state for peer [%s%s%s][%s%s] local:%zu confirmed:%zu pending:%zu, extra:%zu, missing:%zu unwanted:%zu", buf, 0x84u);
      CFStringRef v42 = v238;
    }

    if (!cf1)
    {
      if (v235) {
        CFRetain(v235);
      }
      if (v257 && (unint64_t)CFDataGetLength(*((CFDataRef *)v257 + 3)) > 0x13)
      {
        unint64_t v239 = 0;
      }
      else
      {
        unint64_t v78 = (unint64_t)v259;
        if (v259) {
          unint64_t v78 = CFDataGetLength(*((CFDataRef *)v259 + 3)) / 0x14uLL;
        }
        unint64_t v239 = 0;
        if (!v78)
        {
          uint64_t v79 = 0;
          char v80 = 0;
          char v81 = v235;
          if (!v235)
          {
LABEL_206:
            v236 = (CFDataRef *)v79;
            uint64_t v98 = *(void *)(a4 + 56);
            if (!v98 || (id v99 = v42, (unint64_t)CFDataGetLength(*(CFDataRef *)(v98 + 24)) <= 0x13))
            {
              if (!v259 || (id v99 = v42, (unint64_t)CFDataGetLength(*((CFDataRef *)v259 + 3)) <= 0x13))
              {
                if (!v257 || (id v99 = v42, (unint64_t)CFDataGetLength(*((CFDataRef *)v257 + 3)) <= 0x13))
                {
                  uint64_t v100 = *(void *)(a4 + 64);
                  id v99 = v42;
                  if (v100)
                  {
                    id v99 = v42;
                    if ((unint64_t)CFDataGetLength(*(CFDataRef *)(v100 + 24)) >= 0x14)
                    {
                      long long v101 = sub_10000B070("engine");
                      if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
                      {
                        uint64_t v102 = *(void *)(a4 + 16);
                        uint64_t v103 = *(void *)(v243 + 24);
                        *(_DWORD *)long long buf = 138412546;
                        *(void *)&uint8_t buf[4] = v103;
                        *(_WORD *)&unsigned char buf[12] = 2112;
                        *(void *)&buf[14] = v102;
                        _os_log_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_DEFAULT, "%@:%@: only have differences in unwanted set; lying to peer to stop sync",
                          buf,
                          0x16u);
                      }

                      id v99 = cf1;
                    }
                  }
                }
              }
            }
            id v104 = (void *)v263[3];
            if (v104)
            {
              long long v105 = sub_100200D6C((__CFData *)cf1);
              long long v106 = v105;
              if (v105) {
                CFRetain(v105);
              }
              v104[6] = v106;
              long long v107 = sub_10000B070("engine");
              if (os_log_type_enabled(v107, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v161 = v104[6];
                unint64_t v162 = (unint64_t)cf1;
                if (cf1) {
                  unint64_t v162 = CFDataGetLength(cf1[3]) / 0x14uLL;
                }
                *(_DWORD *)long long buf = 138412546;
                *(void *)&uint8_t buf[4] = v161;
                *(_WORD *)&unsigned char buf[12] = 2048;
                *(void *)&buf[14] = v162;
                _os_log_debug_impl((void *)&_mh_execute_header, v107, OS_LOG_TYPE_DEBUG, "SOSMessageSetManifests: setting base digest to %@ %zu", buf, 0x16u);
              }
              id v108 = sub_100200D6C((__CFData *)v236);
              long long v109 = v108;
              if (v108) {
                CFRetain(v108);
              }
              v104[7] = v109;
              long long v110 = sub_10000B070("engine");
              if (os_log_type_enabled(v110, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v163 = v104[7];
                unint64_t v164 = (unint64_t)v236;
                if (v236) {
                  unint64_t v164 = CFDataGetLength(v236[3]) / 0x14uLL;
                }
                *(_DWORD *)long long buf = 138412546;
                *(void *)&uint8_t buf[4] = v163;
                *(_WORD *)&unsigned char buf[12] = 2048;
                *(void *)&buf[14] = v164;
                _os_log_debug_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEBUG, "SOSMessageSetManifests: setting proposed digest to %@ %zu", buf, 0x16u);
              }
              long long v111 = sub_100200D6C((__CFData *)v99);
              long long v112 = v111;
              if (v111) {
                CFRetain(v111);
              }
              v104[5] = v112;
              long long v113 = sub_10000B070("engine");
              if (os_log_type_enabled(v113, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v165 = v104[5];
                if (v99) {
                  unint64_t v166 = CFDataGetLength(v99[3]) / 0x14uLL;
                }
                else {
                  unint64_t v166 = 0;
                }
                *(_DWORD *)long long buf = 138412546;
                *(void *)&uint8_t buf[4] = v165;
                *(_WORD *)&unsigned char buf[12] = 2048;
                *(void *)&buf[14] = v166;
                _os_log_debug_impl((void *)&_mh_execute_header, v113, OS_LOG_TYPE_DEBUG, "SOSMessageSetManifests: setting sender digest to %@ %zu", buf, 0x16u);
              }
              if (v236)
              {
                *(void *)long long buf = 0;
                char v114 = sub_10020113C((uint64_t)cf1, (uint64_t)v236, v104 + 8, (const void **)buf, a10);
                if (v104[14])
                {
                  v104[9] = sub_100201580((uint64_t)v239, *(CFTypeRef *)buf, a10);
                  if (*(void *)buf) {
                    CFRelease(*(CFTypeRef *)buf);
                  }
                }
                else
                {
                  v104[9] = *(void *)buf;
                }
                if ((v114 & 1) == 0)
                {
                  long long v115 = sub_10000B070("engine");
                  if (os_log_type_enabled(v115, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v116 = *(void *)(a4 + 16);
                    uint64_t v117 = *(void *)(v243 + 24);
                    *(_DWORD *)long long buf = 138412546;
                    *(void *)&uint8_t buf[4] = v117;
                    *(_WORD *)&unsigned char buf[12] = 2112;
                    *(void *)&buf[14] = v116;
                    _os_log_impl((void *)&_mh_execute_header, v115, OS_LOG_TYPE_DEFAULT, "%@:%@: failed to set message manifests", buf, 0x16u);
                  }

                  unint64_t v118 = (const void *)v263[3];
                  if (v118)
                  {
                    v263[3] = 0;
                    CFRelease(v118);
                  }
                }
              }
            }
            if (v80) {
              CFRelease(v80);
            }
            uint64_t v119 = v263[3];
            BOOL v240 = v42;
            if (!v119) {
              goto LABEL_272;
            }
            uint64_t v120 = *(void *)(a4 + 40) + 1;
            *(void *)(a4 + 40) = v120;
            *(void *)(v119 + 96) = v120;
            if (!*(void *)(v119 + 112))
            {
              *(unsigned char *)(v119 + 120) = 0;
              uint64_t v125 = v243;
              unsigned int v126 = v236;
              CFDataRef v93 = 0;
              switch(sub_1002039D8((void *)v119))
              {
                case 1:
                  CFDataRef v127 = *(const __CFData **)(v119 + 40);
                  if (v127 && CFDataGetLength(v127) == 20)
                  {
                    uint64_t v128 = 1;
                    ccder_sizeof_uint64();
                    ccder_sizeof_raw_octet_string();
                    CFIndex v129 = ccder_sizeof();
                  }
                  else
                  {
                    SOSErrorCreate();
                    CFIndex v129 = 0;
                    uint64_t v128 = 1;
                  }
                  goto LABEL_265;
                case 2:
                  uint64_t v155 = *(void *)(v119 + 72);
                  if (v155)
                  {
                    ccder_sizeof_uint64();
                    CFDataRef v156 = *(const __CFData **)(v155 + 24);
                    if (v156)
                    {
                      CFDataGetLength(v156);
                      ccder_sizeof_implicit_raw_octet_string();
                    }
                    CFIndex v129 = ccder_sizeof();
                    uint64_t v128 = 2;
                  }
                  else
                  {
                    SOSErrorCreate();
                    CFIndex v129 = 0;
                    uint64_t v128 = 2;
                  }
                  goto LABEL_265;
                case 3:
                  CFDataRef v157 = *(const __CFData **)(v119 + 48);
                  if (v157 && CFDataGetLength(v157) == 20)
                  {
                    ccder_sizeof_uint64();
                    ccder_sizeof_raw_octet_string();
                    uint64_t v158 = *(void *)(v119 + 64);
                    if (v158)
                    {
                      CFDataRef v159 = *(const __CFData **)(v158 + 24);
                      if (v159)
                      {
                        CFDataGetLength(v159);
                        ccder_sizeof_implicit_raw_octet_string();
                      }
                    }
                    uint64_t v209 = *(void *)(v119 + 72);
                    if (v209)
                    {
                      CFDataRef v210 = *(const __CFData **)(v209 + 24);
                      if (v210)
                      {
                        CFDataGetLength(v210);
                        ccder_sizeof_implicit_raw_octet_string();
                      }
                    }
                    sub_100203E70(v119);
                    ccder_sizeof();
                    CFIndex v129 = ccder_sizeof();
                    uint64_t v128 = 3;
                  }
                  else
                  {
                    SOSErrorCreate();
                    CFIndex v129 = 0;
                    uint64_t v128 = 3;
                  }
                  goto LABEL_265;
                default:
                  goto LABEL_340;
              }
              goto LABEL_340;
            }
            *(double *)(v119 + 104) = floor(CFAbsoluteTimeGetCurrent());
            if (*(void *)(v119 + 40))
            {
              *(void *)long long buf = *(void *)(v119 + 88);
              sub_100010344();
              ccder_sizeof();
              ccder_sizeof_uint64();
              ccn_bitlen();
              ccder_sizeof();
              CFDataRef v121 = *(const __CFData **)(v119 + 40);
              if (v121)
              {
                CFDataGetLength(v121);
                ccder_sizeof_implicit_raw_octet_string();
              }
              CFDataRef v122 = *(const __CFData **)(v119 + 48);
              if (v122)
              {
                CFDataGetLength(v122);
                ccder_sizeof_implicit_raw_octet_string();
              }
              CFDataRef v123 = *(const __CFData **)(v119 + 56);
              if (v123)
              {
                CFDataGetLength(v123);
                ccder_sizeof_implicit_raw_octet_string();
              }
              uint64_t v124 = ccder_sizeof();
            }
            else
            {
              uint64_t v124 = 0;
            }
            uint64_t v130 = *(void *)(v119 + 64);
            uint64_t v131 = *(void *)(v119 + 72);
            if (*(_OWORD *)(v119 + 64) == 0)
            {
              uint64_t v132 = 0;
            }
            else
            {
              uint64_t v133 = *(void *)(v119 + 112);
              if (v130)
              {
                CFDataGetLength(*(CFDataRef *)(v130 + 24));
                uint64_t v131 = *(void *)(v119 + 72);
              }
              uint64_t v134 = ccder_sizeof();
              if (v131) {
                CFDataGetLength(*(CFDataRef *)(v131 + 24));
              }
              uint64_t v132 = ccder_sizeof() + v134;
              if (v133) {
                uint64_t v132 = ccder_sizeof();
              }
            }
            id v135 = (char *)sub_100203E70(v119) + v132 + v124;
            if (*(unsigned char *)(v119 + 120))
            {
              uint64_t v128 = 0;
              CFIndex v129 = (CFIndex)(v135 + 4);
            }
            else
            {
              CFIndex v129 = ccder_sizeof();
              uint64_t v128 = 0;
            }
LABEL_265:
            CFMutableSetRef Mutable = CFDataCreateMutable(0, v129);
            if (Mutable)
            {
              id v137 = Mutable;
              CFDataSetLength(Mutable, v129);
              id v231 = v137;
              MutableBytePtr = CFDataGetMutableBytePtr(v137);
              dispatch_queue_t queuea = (dispatch_queue_t)MutableBytePtr;
              uint64_t v139 = (uint64_t)&MutableBytePtr[v129];
              switch(v128)
              {
                case 1:
                  long long v147 = sub_10000B070("engine");
                  uint64_t v141 = v243;
                  long long v142 = v236;
                  if (os_log_type_enabled(v147, OS_LOG_TYPE_DEBUG))
                  {
                    uint64_t v211 = *(void *)(v119 + 40);
                    *(_DWORD *)long long buf = 138412290;
                    *(void *)&uint8_t buf[4] = v211;
                    _os_log_debug_impl((void *)&_mh_execute_header, v147, OS_LOG_TYPE_DEBUG, "der_encode_manifest_digest_message: encoded sender digest as %@", buf, 0xCu);
                  }
                  CFDataGetBytePtr(*(CFDataRef *)(v119 + 40));
                  dispatch_queue_t v148 = queuea;
                  ccder_encode_raw_octet_string();
                  goto LABEL_310;
                case 2:
                  long long v149 = sub_10000B070("engine");
                  uint64_t v141 = v243;
                  long long v142 = v236;
                  if (os_log_type_enabled(v149, OS_LOG_TYPE_DEBUG))
                  {
                    uint64_t v212 = *(void *)(v119 + 72);
                    if (v212)
                    {
                      unint64_t v214 = CFDataGetLength(*(CFDataRef *)(v212 + 24)) / 0x14uLL;
                      v213 = *(__CFData **)(v119 + 72);
                    }
                    else
                    {
                      v213 = 0;
                      unint64_t v214 = 0;
                    }
                    id v216 = sub_100200D6C(v213);
                    *(_DWORD *)long long buf = 134218242;
                    *(void *)&uint8_t buf[4] = v214;
                    *(_WORD *)&unsigned char buf[12] = 2112;
                    *(void *)&buf[14] = v216;
                    _os_log_debug_impl((void *)&_mh_execute_header, v149, OS_LOG_TYPE_DEBUG, "der_encode_manifest_message: encoded message additions as (%zu, %@)", buf, 0x16u);
                  }
                  uint64_t v150 = *(void *)(v119 + 72);
                  if (v150) {
                    CFDataRef v151 = *(const __CFData **)(v150 + 24);
                  }
                  else {
                    CFDataRef v151 = 0;
                  }
                  dispatch_queue_t v148 = queuea;
                  sub_1002040A0(4, v151, (uint64_t)queuea, v139);
LABEL_310:
                  ccder_encode_uint64();
                  goto LABEL_311;
                case 3:
                  id v152 = sub_10000B070("engine");
                  if (os_log_type_enabled(v152, OS_LOG_TYPE_DEBUG))
                  {
                    uint64_t v215 = *(void *)(v119 + 48);
                    *(_DWORD *)long long buf = 138412290;
                    *(void *)&uint8_t buf[4] = v215;
                    _os_log_debug_impl((void *)&_mh_execute_header, v152, OS_LOG_TYPE_DEBUG, "der_encode_manifest_and_objects_message: encoded base digest as %@", buf, 0xCu);
                  }
                  CFDataGetBytePtr(*(CFDataRef *)(v119 + 48));
                  uint64_t v153 = *(void *)(v119 + 64);
                  if (v153) {
                    CFDataRef v154 = *(const __CFData **)(v153 + 24);
                  }
                  else {
                    CFDataRef v154 = 0;
                  }
                  uint64_t v168 = *(void *)(v119 + 72);
                  if (v168) {
                    CFDataRef v169 = *(const __CFData **)(v168 + 24);
                  }
                  else {
                    CFDataRef v169 = 0;
                  }
                  uint64_t v170 = v119;
                  dispatch_queue_t v148 = queuea;
                  uint64_t v171 = sub_100203F28(v170, (uint64_t)queuea, v139);
                  uint64_t v172 = sub_1002040A0(4, v169, (uint64_t)queuea, v171);
                  sub_1002040A0(4, v154, (uint64_t)queuea, v172);
                  ccder_encode_raw_octet_string();
                  ccder_encode_constructed_tl();
                  ccder_encode_uint64();
                  uint64_t v173 = ccder_encode_constructed_tl();
                  uint64_t v141 = v243;
                  long long v142 = v236;
                  goto LABEL_335;
                default:
                  uint64_t v140 = (uint64_t)&MutableBytePtr[v129];
                  uint64_t v141 = v243;
                  long long v142 = v236;
                  if (*(unsigned char *)(v119 + 120)) {
                    uint64_t v140 = ccder_encode_tl();
                  }
                  uint64_t v143 = sub_100203F28(v119, (uint64_t)queuea, v140);
                  uint64_t v145 = *(void *)(v119 + 64);
                  uint64_t v144 = *(void *)(v119 + 72);
                  if (*(_OWORD *)(v119 + 64) != 0)
                  {
                    CFDataRef v146 = v145 ? *(const __CFData **)(v145 + 24) : 0;
                    uint64_t v228 = *(void *)(v119 + 112);
                    CFDataRef v174 = v144 ? *(const __CFData **)(v144 + 24) : 0;
                    uint64_t v175 = sub_1002040A0(4, v174, (uint64_t)queuea, v143);
                    uint64_t v143 = sub_1002040A0(4, v146, (uint64_t)queuea, v175);
                    if (v228) {
                      uint64_t v143 = ccder_encode_constructed_tl();
                    }
                  }
                  CFDataRef v176 = *(const __CFData **)(v119 + 40);
                  if (v176)
                  {
                    *(void *)long long buf = *(void *)(v119 + 88);
                    double v177 = *(double *)(v119 + 104);
                    CFDataRef v178 = *(const __CFData **)(v119 + 48);
                    uint64_t v179 = sub_1002040A0(0x8000000000000001, *(CFDataRef *)(v119 + 56), (uint64_t)queuea, v143);
                    uint64_t v180 = sub_1002040A0(0x8000000000000000, v178, (uint64_t)queuea, v179);
                    sub_1002040A0(4, v176, (uint64_t)queuea, v180);
                    ccn_bitlen();
                    if (ccder_encode_body_nocopy()) {
                      ccn_write_uint_padded();
                    }
                    ccder_encode_tl();
                    unint64_t v181 = ccder_encode_uint64();
                    sub_100012404(a10, 0, (uint64_t)queuea, v181, v177);
                    if (!ccder_encode_constructed_tl()) {
                      sub_1000297A0(-7, @"com.apple.security.cfder.error", 0, a10, v182, @"ccder failed to encode");
                    }
                    ccder_encode_constructed_tl();
                    uint64_t v141 = v243;
                    long long v142 = v236;
                  }
                  if (*(unsigned char *)(v119 + 120))
                  {
                    dispatch_queue_t v148 = queuea;
                    ccder_encode_len();
                    uint64_t v167 = ccder_encode_tag();
                  }
                  else
                  {
                    dispatch_queue_t v148 = queuea;
LABEL_311:
                    uint64_t v167 = ccder_encode_constructed_tl();
                  }
                  uint64_t v173 = v167;
LABEL_335:
                  if (v148 != (dispatch_queue_t)v173)
                  {
                    uint64_t v183 = sub_10000B070("SecWarning");
                    if (os_log_type_enabled(v183, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)long long buf = 134217984;
                      *(void *)&uint8_t buf[4] = v173 - (void)queuea;
                      _os_log_impl((void *)&_mh_execute_header, v183, OS_LOG_TYPE_DEFAULT, "internal error %td bytes unused in der buffer", buf, 0xCu);
                    }
                  }
                  v184 = [SOSEnginePeerMessageCallBackInfo alloc];
                  v185 = [(SOSEnginePeerMessageCallBackInfo *)v184 initWithEngine:v141 peer:a4 localManifest:v240 proposedManifest:v142 confirmedManifest:cf1 andMessage:v263[3]];
                  v248[0] = _NSConcreteStackBlock;
                  v248[1] = 3221225472;
                  v248[2] = sub_1001030DC;
                  v248[3] = &unk_1002FA208;
                  id v186 = [(SOSEnginePeerMessageCallBackInfo *)v185 copy];
                  id v249 = v186;
                  [(SOSEnginePeerMessageCallBackInfo *)v185 setCallbackBlock:v248];
                  CFDataRef v93 = v231;
                  v187 = v185;
                  *a9 = v187;

                  break;
              }
            }
            else
            {
LABEL_272:
              CFDataRef v93 = 0;
            }
            uint64_t v125 = v243;
            unsigned int v126 = v236;
LABEL_340:
            if (v240) {
              CFRelease(v240);
            }
            CFTypeRef v188 = v259;
            if (v259)
            {
              CFTypeRef v259 = 0;
              CFRelease(v188);
            }
            CFTypeRef v189 = v257;
            if (v257)
            {
              CFTypeRef v257 = 0;
              CFRelease(v189);
            }
            v190 = (const void *)v263[3];
            if (v190)
            {
              v263[3] = 0;
              CFRelease(v190);
            }
            if (v126) {
              CFRelease(v126);
            }
            if (a10 && *a10)
            {
              unsigned int v191 = sub_10000B070("SecError");
              if (os_log_type_enabled(v191, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v192 = *(void *)(a4 + 16);
                uint64_t v193 = *(void *)(v125 + 24);
                id v194 = (const char *)*a10;
                *(_DWORD *)long long buf = 138412802;
                *(void *)&uint8_t buf[4] = v193;
                *(_WORD *)&unsigned char buf[12] = 2112;
                *(void *)&buf[14] = v192;
                *(_WORD *)&buf[22] = 2112;
                id v271 = v194;
                _os_log_impl((void *)&_mh_execute_header, v191, OS_LOG_TYPE_DEFAULT, "%@:%@ error in send: %@", buf, 0x20u);
              }
            }
            goto LABEL_355;
          }
LABEL_202:
          id v97 = sub_100201804((uint64_t)v259, v81, a10);
          uint64_t v79 = sub_1002014F4((uint64_t)cf1, (uint64_t)v257, (uint64_t)v97, a10);
          if (v97) {
            CFRelease(v97);
          }
          char v80 = v81;
          goto LABEL_206;
        }
      }
      char v81 = v235;
      goto LABEL_202;
    }
    if ((!v235 || (unint64_t)CFDataGetLength(v235[3]) <= 0x13)
      && (!v259 || (unint64_t)CFDataGetLength(*((CFDataRef *)v259 + 3)) <= 0x13))
    {
      *(unsigned char *)(a4 + 49) = 0;
    }
    if (v257 && (unint64_t)CFDataGetLength(*((CFDataRef *)v257 + 3)) <= 0x13)
    {
      id v72 = objc_retainBlock(*(id *)(v243 + 136));
      if (v72 && *(void *)(v243 + 128))
      {
        uint64_t v73 = *(void *)(a4 + 16);
        if (v73) {
          CFRetain(*(CFTypeRef *)(a4 + 16));
        }
        uint64_t v74 = *(void *)(a4 + 24);
        if (v74) {
          CFRetain(*(CFTypeRef *)(a4 + 24));
        }
        id v75 = [v72 copy];
        queueb = *(NSObject **)(v243 + 128);
        *(void *)long long buf = _NSConcreteStackBlock;
        *(void *)&uint8_t buf[8] = 3221225472;
        *(void *)&uint8_t buf[16] = sub_100102758;
        id v271 = (const char *)&unk_1002FA538;
        *(void *)&v272[0] = v75;
        *((void *)&v272[0] + 1) = v73;
        *(void *)&v272[1] = v74;
        id v76 = v75;
        dispatch_async(queueb, buf);
      }
      *(unsigned char *)(a4 + 50) = 1;
    }
    id v77 = (CFDataRef *)sub_1002065A8(a4);
    if (v42 && v77)
    {
      if (!CFEqual(v42, v77)) {
        goto LABEL_162;
      }
    }
    else if (v42 != v77)
    {
      goto LABEL_162;
    }
    if (*(unsigned char *)(a4 + 48)) {
      goto LABEL_162;
    }
    if (CFEqual(cf1, v42))
    {
      uint64_t v88 = sub_10000B070("engine");
      if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v89 = *(void *)(v243 + 24);
        *(_DWORD *)long long buf = 138412546;
        *(void *)&uint8_t buf[4] = v89;
        *(_WORD *)&unsigned char buf[12] = 2112;
        *(void *)&buf[14] = a4;
        _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "synced <No MSG> %@:%@", buf, 0x16u);
      }
      CFStringRef v42 = v238;
    }
    else
    {
      char v81 = v235;
      CFStringRef v42 = v238;
      if (v235 && (unint64_t)CFDataGetLength(v235[3]) > 0x13) {
        goto LABEL_163;
      }
      if (v257 && (unint64_t)CFDataGetLength(*((CFDataRef *)v257 + 3)) > 0x13)
      {
LABEL_162:
        char v81 = v235;
        if (!v235)
        {
LABEL_165:
          unint64_t v239 = 0;
          goto LABEL_202;
        }
LABEL_163:
        unint64_t Length = CFDataGetLength(v81[3]);
        uint64_t v83 = v243;
        if (Length >= 0x14)
        {
          v255[0] = 0;
          v255[1] = v255;
          v255[2] = 0x2020000000;
          v255[3] = 0;
          *(void *)long long buf = 0;
          *(void *)&uint8_t buf[8] = buf;
          *(void *)&uint8_t buf[16] = 0x4010000000;
          id v271 = "";
          memset(v272, 0, sizeof(v272));
          CFMutableArrayRef v84 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
          uint64_t v251 = 0;
          v252 = &v251;
          uint64_t v253 = 0x2020000000;
          uint64_t v254 = 0;
          uint64_t v85 = *(void *)(v243 + 16);
          v250[1] = _NSConcreteStackBlock;
          v250[2] = (CFTypeRef)3221225472;
          v250[3] = sub_1001027BC;
          v250[4] = &unk_1002FA1E0;
          v250[9] = (CFTypeRef)v243;
          v250[10] = (CFTypeRef)a4;
          v250[11] = v84;
          v250[12] = a10;
          v250[5] = &v251;
          v250[6] = &v262;
          v250[13] = a8;
          v250[7] = buf;
          v250[8] = v255;
          if (((*(uint64_t (**)(void))(v85 + 32))() & 1) == 0)
          {
            id v86 = (const void *)v263[3];
            if (v86)
            {
              v263[3] = 0;
              CFRelease(v86);
            }
          }
          if (*(void *)(*(void *)&buf[8] + 40)) {
            uint64_t v87 = sub_100201498(*(void *)&buf[8] + 32, a10);
          }
          else {
            uint64_t v87 = 0;
          }
          if (CFArrayGetCount(v84))
          {
            v250[0] = 0;
            if ((sub_100100734(v243, 0, 2, 0, v84, v250) & 1) == 0)
            {
              uint64_t v94 = sub_10000B070("SecError");
              if (os_log_type_enabled(v94, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)v266 = 138412546;
                CFMutableArrayRef v267 = v84;
                __int16 v268 = 2112;
                CFTypeRef v269 = v250[0];
                _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, "SOSEngineUpdateChanges_locked: %@ failed: %@", v266, 0x16u);
              }

              uint64_t v83 = v243;
            }
            if (v250[0]) {
              CFRelease(v250[0]);
            }
            CFStringRef v42 = (CFDataRef *)sub_100100424(v83, a4);
            if (v238) {
              CFRelease(v238);
            }
          }
          else
          {
            CFStringRef v42 = v238;
          }
          char v81 = (CFDataRef *)v87;
          if (v84) {
            CFRelease(v84);
          }
          uint64_t v95 = *(void *)&buf[8];
          free(*(void **)(*(void *)&buf[8] + 32));
          *(void *)(v95 + 32) = 0;
          *(void *)(v95 + 40) = 0;
          *(unsigned char *)(v95 + 56) = 0;
          *(void *)(v95 + 4_Block_object_dispose(&a9, 8) = 0;
          id v96 = (const void *)v252[3];
          if (v96)
          {
            v252[3] = 0;
            CFRelease(v96);
          }
          _Block_object_dispose(&v251, 8);
          _Block_object_dispose(buf, 8);
          _Block_object_dispose(v255, 8);
          unint64_t v239 = v81;
          goto LABEL_202;
        }
        char v81 = 0;
        goto LABEL_165;
      }
      uint64_t v88 = sub_10000B070("engine");
      if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v160 = *(void *)(v243 + 24);
        *(_DWORD *)long long buf = 138412802;
        *(void *)&uint8_t buf[4] = v160;
        *(_WORD *)&unsigned char buf[12] = 2112;
        *(void *)&buf[14] = a4;
        *(_WORD *)&buf[22] = 2112;
        id v271 = (const char *)v259;
        _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "waiting <MSG not resent> %@:%@ extra: %@", buf, 0x20u);
      }
    }

    if (v42) {
      CFRelease(v42);
    }
    char v90 = (const void *)v263[3];
    if (v90)
    {
      v263[3] = 0;
      CFRelease(v90);
    }
    CFTypeRef v91 = v259;
    if (v259)
    {
      CFTypeRef v259 = 0;
      CFRelease(v91);
    }
    CFTypeRef v92 = v257;
    if (v257)
    {
      CFTypeRef v257 = 0;
      CFRelease(v92);
    }
    CFDataRef v93 = CFDataCreate(kCFAllocatorDefault, 0, 0);
LABEL_355:
    _Block_object_dispose(&v262, 8);
    if (v93)
    {
      if (!CFDataGetLength(v93) && !*(unsigned char *)(a4 + 48))
      {
        uint64_t v28 = 1;
LABEL_386:
        CFRelease(v93);
        goto LABEL_21;
      }
      cf1a = CFStringCreateMutable(kCFAllocatorDefault, 0);
      id v195 = *(const void **)(a5 + 24);
      if (!v195)
      {
        CFStringAppend(cf1a, @"*** using null coder ***");
        CFIndex v217 = CFDataGetLength(v93);
        CFDataRef v200 = v93;
        MutableCFDataRef Copy = CFDataCreateMutableCopy(0, v217, v93);
        uint64_t v237 = 0;
        CFStringRef v196 = 0;
        goto LABEL_364;
      }
      CFStringRef v196 = CFCopyDescription(v195);
      if (SecOTRSGetIsReadyForMessages())
      {
        if (!*(unsigned char *)(a5 + 32))
        {
          CFMutableDataRef v197 = CFDataCreateMutable(kCFAllocatorDefault, 0);
          if (v197)
          {
            MutableCFDataRef Copy = v197;
            uint64_t v199 = SecOTRSSignAndProtectMessage();
            CFDataRef v200 = v93;
            if (!v199)
            {
              uint64_t v237 = 0;
LABEL_364:
              uint64_t v28 = 1;
              goto LABEL_365;
            }
            v219 = a7;
            uint64_t v220 = v199;
            SOSCreateErrorWithFormat();
            CFRelease(MutableCopy);
          }
          else
          {
            CFDataRef v200 = v93;
            v219 = a7;
            SOSCreateErrorWithFormat();
          }
          if (a10 && *a10) {
            CFStringAppendFormat(cf1a, 0, @" %@", *a10);
          }
          MutableCFDataRef Copy = 0;
          uint64_t v28 = 0;
          uint64_t v237 = 3;
LABEL_365:
          __int16 v201 = sub_10000B070("coder");
          if (os_log_type_enabled(v201, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v206 = SecOTRPacketTypeString();
            uint64_t v207 = *(void *)(a5 + 24);
            v208 = off_100308488[v237];
            *(_DWORD *)long long buf = 138413570;
            *(void *)&uint8_t buf[4] = a7;
            *(_WORD *)&unsigned char buf[12] = 2112;
            *(void *)&buf[14] = v196;
            *(_WORD *)&buf[22] = 2080;
            id v271 = (const char *)v206;
            LOWORD(v272[0]) = 2112;
            *(void *)((char *)v272 + 2) = cf1a;
            WORD5(v272[0]) = 2112;
            *(void *)((char *)v272 + 12) = v207;
            WORD2(v272[1]) = 2080;
            *(void *)((char *)&v272[1] + 6) = v208;
            _os_log_debug_impl((void *)&_mh_execute_header, v201, OS_LOG_TYPE_DEBUG, "%@ %@ %s %@ %@ returned %s", buf, 0x3Eu);
            if (!v196) {
              goto LABEL_368;
            }
          }
          else if (!v196)
          {
LABEL_368:
            CFRelease(cf1a);
            CFDataRef v93 = v200;
            if (v28)
            {
              if (*a6 != MutableCopy)
              {
                if (!MutableCopy || (CFRetain(MutableCopy), *a6)) {
                  CFRelease(*a6);
                }
                *a6 = MutableCopy;
              }
              if (-[OTSOSActualAdapter sosEnabled]_0()) {
                *(unsigned char *)(v243 + 105) = 1;
              }
            }
            else
            {
              v204 = sub_10000B070("transport");
              if (os_log_type_enabled(v204, OS_LOG_TYPE_DEFAULT))
              {
                CFTypeRef v205 = *a10;
                *(_DWORD *)long long buf = 138412546;
                *(void *)&uint8_t buf[4] = a7;
                *(_WORD *)&unsigned char buf[12] = 2112;
                *(void *)&buf[14] = v205;
                _os_log_impl((void *)&_mh_execute_header, v204, OS_LOG_TYPE_DEFAULT, "%@ SOSCoderWrap failed: %@", buf, 0x16u);
              }
            }
            if (MutableCopy) {
              CFRelease(MutableCopy);
            }
            goto LABEL_386;
          }
          CFRelease(v196);
          goto LABEL_368;
        }
        CFDataRef v200 = v93;
        CFStringRef v218 = @"waiting for peer to send data packet first";
      }
      else
      {
        CFDataRef v200 = v93;
        CFStringRef v218 = @"not ready";
      }
      CFStringAppend(cf1a, v218);
      MutableCFDataRef Copy = 0;
      uint64_t v28 = 0;
      uint64_t v237 = 1;
      goto LABEL_365;
    }
LABEL_373:
    uint64_t v202 = sub_10000B070("transport");
    if (os_log_type_enabled(v202, OS_LOG_TYPE_DEFAULT))
    {
      CFTypeRef v203 = *a10;
      *(_DWORD *)long long buf = 138412546;
      *(void *)&uint8_t buf[4] = a7;
      *(_WORD *)&unsigned char buf[12] = 2112;
      *(void *)&buf[14] = v203;
      _os_log_impl((void *)&_mh_execute_header, v202, OS_LOG_TYPE_DEFAULT, "%@ SOSEngineCreateMessage_locked failed: %@", buf, 0x16u);
    }

    uint64_t v28 = 0;
LABEL_21:
    BOOL v29 = sub_1001F7170(v245);
    if (*a6) {
      char v30 = v29;
    }
    else {
      char v30 = 1;
    }
    if (v30) {
      goto LABEL_65;
    }
    id v31 = a7;
    uint64_t v32 = sub_1001DCC24(v245, @"NegotiationRetryCount");
    if (!v32)
    {
      uint64_t v32 = +[NSMutableDictionary dictionary];
    }
    long long v33 = [v32 objectForKey:v31, v219, v220];
    uint64_t v34 = v33;
    if (v33)
    {
      BOOL v35 = (int)[v33 intValue] > 6;

      if (v35) {
        goto LABEL_65;
      }
    }
    else
    {
    }
    if (!SecOTRSessionIsSessionInAwaitingState()
      || sub_100206754(*(void **)(a4 + 16), *(CFDictionaryRef *)(a4 + 104)))
    {
LABEL_57:
      if (SecOTRSessionIsSessionInAwaitingState())
      {
        if (!sub_100206754(*(void **)(a4 + 16), *(CFDictionaryRef *)(a4 + 104)))
        {
LABEL_65:
          CFStringRef v19 = v245;
          goto LABEL_66;
        }
        char v52 = sub_10000B070("otrtimer");
        if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = a5;
          _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "timer for coder already set: %@", buf, 0xCu);
        }
      }
      else
      {
        char v52 = sub_10000B070("otrtimer");
        if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = a5;
          _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "coder not in awaiting state: %@", buf, 0xCu);
        }
      }

      goto LABEL_65;
    }
    id v36 = v31;
    CFDictionaryRef v37 = (const __CFDictionary *)sub_1001DCC24(v245, @"PeerNegotiationTimeouts");
    CFDictionaryRef v38 = v37;
    if (v37 && (CFTypeID v39 = CFGetTypeID(v37), v39 == CFDictionaryGetTypeID()))
    {
      if (CFDictionaryGetValue(v38, v36))
      {

        CFStringRef v40 = sub_10000B070("otrtimer");
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "coder is in awaiting state", buf, 2u);
        }

        sub_1001EBF74(v245, a4);
        goto LABEL_65;
      }
      uint64_t v51 = sub_10000B070("otrtimer");
      if (!os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_56;
      }
      *(_WORD *)long long buf = 0;
    }
    else
    {
      uint64_t v51 = sub_10000B070("otrtimer");
      if (!os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
      {
LABEL_56:

        goto LABEL_57;
      }
      *(_WORD *)long long buf = 0;
    }
    _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "do not have an rtt yet", buf, 2u);
    goto LABEL_56;
  }
  CFStringRef v19 = v15;
  [v15 setEngine_peer_state_needs_repair:1];
  CFIndex v20 = sub_10000B070("transport");
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    if (a10) {
      CFTypeRef v21 = *a10;
    }
    else {
      CFTypeRef v21 = 0;
    }
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = a7;
    *(_WORD *)&unsigned char buf[12] = 2112;
    *(void *)&buf[14] = v21;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%@ getCoder: %@", buf, 0x16u);
  }

  uint64_t v28 = 0;
LABEL_66:

  return v28;
}

void sub_1002094AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a53, 8);
  _Block_object_dispose((const void *)(v67 - 256), 8);
  _Block_object_dispose(&a57, 8);
  _Block_object_dispose(&a67, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1002095B0(uint64_t a1, int a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v4 = WeakRetained;
  if (a2)
  {
    id v8 = WeakRetained;
    BOOL v5 = [WeakRetained coder];
    id v4 = v8;
    CFIndex v6 = v5;
    id WeakRetained = (id)v5[5];
    if (WeakRetained)
    {
      void v6[5] = 0;
      CFRelease(WeakRetained);
      id v4 = v8;
    }
  }

  return _objc_release_x1(WeakRetained, v4);
}

void sub_100209620(uint64_t a1)
{
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID();
  if (CFEqual(*(CFTypeRef *)(a1 + 32), PeerID)) {
    return;
  }
  BOOL v3 = (const void *)SOSPeerInfoCopySerialNumber();
  id v4 = *(const void **)(a1 + 40);
  if (!v3 || !v4)
  {
    if (v4 != v3) {
      goto LABEL_9;
    }
    goto LABEL_8;
  }
  if (CFEqual(v4, v3))
  {
LABEL_8:
    CFSetAddValue(*(CFMutableSetRef *)(a1 + 48), PeerID);
LABEL_9:
    if (!v3) {
      return;
    }
  }

  CFRelease(v3);
}

uint64_t sub_1002096CC(void *a1)
{
  id v1 = a1;
  uint64_t v2 = [v1 peerID];
  if (v2)
  {
    BOOL v3 = [v1 trust];
    id v4 = [v3 trustedCircle];

    if (v4)
    {
      BOOL v5 = [v1 trust];
      [v5 trustedCircle];
      uint64_t v2 = SOSCircleCopyCircle();

      if (v2)
      {
        if ([v1 peerInfo])
        {
          unsigned int Class = SOSPeerInfoGetClass();
          if (Class <= 5 && ((1 << Class) & 0x34) != 0)
          {
            if (SOSPeerInfoSerialNumberIsSet())
            {
              uint64_t v7 = SOSPeerInfoCopySerialNumber();
              if (v7)
              {
                id v8 = (void *)v7;
                uint64_t PeerID = (void (*)(uint64_t))SOSPeerInfoGetPeerID();
                CFMutableSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
                if (Mutable)
                {
                  CFSetRef v11 = Mutable;
                  CFTypeRef v21 = _NSConcreteStackBlock;
                  uint64_t v22 = 3221225472;
                  uint64_t v23 = (uint64_t)sub_100209620;
                  id v24 = (uint64_t (*)(uint64_t, uint64_t))&unk_1003088D8;
                  CFMutableArrayRef v25 = PeerID;
                  id v26 = v8;
                  CFMutableSetRef v27 = Mutable;
                  SOSCircleForEachPeer();
                  CFRelease(v8);
                  if (CFSetGetCount(v11)) {
                    SOSCircleRemovePeersByIDUnsigned();
                  }
                  CFSetRef v12 = v11;
                }
                else
                {
                  CFSetRef v12 = (const __CFSet *)v8;
                }
                CFRelease(v12);
              }
            }
          }
        }
        SOSCircleRemoveRetired();
        CFMutableArrayRef v25 = (void (*)(uint64_t))objc_alloc_init((Class)NSMutableSet);
        CFIndex v13 = v25;
        SOSCircleForEachiCloudIdentityPeer();
        SOSCircleRemovePeersByIDUnsigned();

        CFMutableArrayRef v25 = (void (*)(uint64_t))objc_alloc_init((Class)NSMutableSet);
        int v14 = v25;
        SOSCircleForEachActivePeer();
        SOSCircleRemovePeersByIDUnsigned();

        CFTypeRef v21 = 0;
        uint64_t v22 = (uint64_t)&v21;
        uint64_t v23 = 0x3032000000;
        id v24 = sub_100209BC8;
        CFMutableArrayRef v25 = sub_100209BD8;
        id v26 = 0;
        if (+[SOSAuthKitHelpers accountIsCDPCapable])
        {
          v20[0] = _NSConcreteStackBlock;
          v20[1] = 3221225472;
          v20[2] = sub_100209BE0;
          v20[3] = &unk_100308928;
          v20[4] = &v21;
          +[SOSAuthKitHelpers activeMIDs:v20];
        }
        id v15 = objc_alloc_init((Class)NSMutableSet);
        CFDataRef v16 = v15;
        if (*(void *)(v22 + 40))
        {
          id v19 = v15;
          SOSCircleForEachActivePeer();
          SOSCircleRemovePeersByIDUnsigned();
        }
        _Block_object_dispose(&v21, 8);

        int v17 = SOSCircleCountPeers();
        CFRelease((CFTypeRef)v2);
        uint64_t v2 = v17 == 0;
      }
    }
    else
    {
      uint64_t v2 = 0;
    }
  }

  return v2;
}

void sub_100209AD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va, a12);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100209AF0(uint64_t a1)
{
  SOSPeerInfoGetPeerID();
  id v2 = (id)objc_claimAutoreleasedReturnValue();
  [*(id *)(a1 + 32) addObject:v2];
}

void sub_100209B48(uint64_t a1)
{
  SOSPeerInfoGetPeerDeviceType();
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  if ([v3 hasPrefix:@"Windows"])
  {
    id v2 = SOSPeerInfoGetPeerID();
    [*(id *)(a1 + 32) addObject:v2];
  }
}

uint64_t sub_100209BC8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100209BD8(uint64_t a1)
{
}

void sub_100209BE0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [[SOSAuthKitHelpers alloc] initWithActiveMIDS:v3];

  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
  CFIndex v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;
}

void sub_100209C50(uint64_t a1)
{
  id v3 = (id)SOSPeerInfoV2DictionaryCopyString();
  if ((objc_msgSend(*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), "midIsValidInList:") & 1) == 0)
  {
    id v2 = SOSPeerInfoGetPeerID();
    [*(id *)(a1 + 32) addObject:v2];
  }
}

void sub_100209CE0(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  if (!v4)
  {
    CFIndex v6 = sub_10000B070("ghostBust");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v43 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Couldn't work on iCloud Identities (%@)", buf, 0xCu);
    }
  }
  uint64_t v7 = [v4 objectForKeyedSubscript:@"keyOnly"];
  id v8 = [v7 count];

  if (v8)
  {
    CFRange v9 = [v4 objectForKeyedSubscript:@"completeIdentity"];
    id v10 = [v9 count];

    if (v10)
    {
      id v33 = v8;
      id v34 = v5;
      long long v40 = 0u;
      long long v41 = 0u;
      long long v38 = 0u;
      long long v39 = 0u;
      id v35 = v4;
      id obj = [v4 objectForKeyedSubscript:@"keyOnly"];
      id v11 = [obj countByEnumeratingWithState:&v38 objects:v46 count:16];
      if (!v11) {
        goto LABEL_26;
      }
      id v12 = v11;
      uint64_t v13 = *(void *)v39;
      while (1)
      {
        int v14 = 0;
        do
        {
          if (*(void *)v39 != v13) {
            objc_enumerationMutation(obj);
          }
          id v15 = *(void **)(*((void *)&v38 + 1) + 8 * (void)v14);
          CFStringRef v16 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"Cloud Identity - '%@'", v15);
          if (v16)
          {
            CFStringRef v24 = v16;
            CFDictionaryRef v25 = sub_100139704(kCFAllocatorDefault, v17, v18, v19, v20, v21, v22, v23, (uint64_t)kSecClass, (uint64_t)kSecClassKey);
            OSStatus v26 = SecItemDelete(v25);
            if (v26)
            {
              OSStatus v27 = v26;
              uint64_t v28 = sub_10000B070("ghostbust");
              if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)long long buf = 138412546;
                id v43 = v15;
                __int16 v44 = 1024;
                LODWORD(v45) = v27;
                _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Delete for %@ returned %d", buf, 0x12u);
              }

              if (v25) {
                goto LABEL_17;
              }
            }
            else
            {
              BOOL v29 = sub_10000B070("ghostBust");
              if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)long long buf = 138412290;
                id v43 = v15;
                _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "removed %@", buf, 0xCu);
              }

              ++*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
              if (v25) {
LABEL_17:
              }
                CFRelease(v25);
            }
            CFRelease(v24);
          }
          int v14 = (char *)v14 + 1;
        }
        while (v12 != v14);
        id v30 = [obj countByEnumeratingWithState:&v38 objects:v46 count:16];
        id v12 = v30;
        if (!v30)
        {
LABEL_26:

          id v31 = sub_10000B070("ghostBust");
          if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v32 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
            *(_DWORD *)long long buf = 134218240;
            id v43 = v32;
            __int16 v44 = 2048;
            id v45 = v33;
            _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Removed %zu of %zu deserted icloud private keys", buf, 0x16u);
          }
          id v5 = v34;
          id v4 = v35;
          goto LABEL_31;
        }
      }
    }
    id v31 = sub_10000B070("ghostBust");
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "No iCloud Identity FPI, can't remove iCloudIdentity extra keys", buf, 2u);
    }
LABEL_31:
  }
}

uint64_t sub_10020A18C(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 80);
  if ((v2 & 3) != 0)
  {
    id v3 = [*(id *)(a1 + 32) peerID];
    int v4 = *(_DWORD *)(a1 + 80);
    id v5 = *(void **)(a1 + 40);
    CFIndex v6 = *(void **)(a1 + 48);
    id v7 = v3;
    id v8 = v5;
    id v9 = v6;
    *(void *)&long long v63 = 0;
    *((void *)&v63 + 1) = &v63;
    uint64_t v64 = 0x2020000000;
    int v65 = 0;
    uint64_t v50 = 0;
    uint64_t v51 = &v50;
    uint64_t v52 = 0x2020000000;
    int v53 = 0;
    id v10 = objc_alloc_init((Class)NSMutableSet);
    *(void *)&long long buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 3221225472;
    CFStringRef v55 = sub_10020A8F0;
    CFTypeRef v56 = &unk_1003089A0;
    id v11 = (__CFArray *)v7;
    CFMutableArrayRef v57 = v11;
    int v62 = v4;
    id v12 = v8;
    id v58 = v12;
    id v13 = v10;
    id v59 = v13;
    CFTypeRef v60 = &v63;
    CFTypeRef v61 = &v50;
    SOSCircleForEachPeer();
    SOSCircleRemovePeersByIDUnsigned();
    int v14 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(*((void *)&v63 + 1) + 24)];
    [v9 setObject:v14 forKeyedSubscript:@"byMID"];

    id v15 = +[NSNumber numberWithUnsignedInt:*((unsigned int *)v51 + 6)];
    [v9 setObject:v15 forKeyedSubscript:@"bySerial"];

    id v16 = [v13 count];
    _Block_object_dispose(&v50, 8);
    _Block_object_dispose(&v63, 8);

    *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v16;
    int v17 = sub_10000B070("ghostbust");
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
      LODWORD(buf) = 134217984;
      *(void *)((char *)&buf + 4) = v18;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Removed %lu ghosts from circle by midlist && serialNumber", (uint8_t *)&buf, 0xCu);
    }

    *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    int v2 = *(_DWORD *)(a1 + 80);
  }
  if ((v2 & 4) != 0)
  {
    int v19 = [*(id *)(a1 + 32) peerID];
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    *(void *)&long long buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 3221225472;
    CFStringRef v55 = sub_10020AAD4;
    CFTypeRef v56 = &unk_1003089C0;
    CFMutableArrayRef v57 = Mutable;
    SOSCircleForEachPeer();
    v66.size_t length = CFArrayGetCount(Mutable);
    v66.id location = 0;
    CFArraySortValues(Mutable, v66, (CFComparatorFunction)&SOSPeerInfoCompareByApplicationDate, 0);
    id v21 = objc_alloc_init((Class)NSMutableDictionary);
    id v22 = objc_alloc_init((Class)NSMutableSet);
    CFIndex Count = CFArrayGetCount(Mutable);
    if (Count >= 1)
    {
      unint64_t v25 = Count + 1;
      *(void *)&long long v24 = 138412290;
      long long v49 = v24;
      do
      {
        CFArrayRef ValueAtIndex = CFArrayGetValueAtIndex(Mutable, v25 - 2);
        OSStatus v27 = SOSPeerInfoGetPeerID();
        unsigned __int8 v28 = [v27 isEqualToString:v19];
        if (ValueAtIndex) {
          char v29 = v28;
        }
        else {
          char v29 = 1;
        }
        if (v29) {
          goto LABEL_24;
        }
        unsigned int Class = SOSPeerInfoGetClass();
        if (Class > 5 || ((1 << Class) & 0x34) == 0) {
          goto LABEL_24;
        }
        id v31 = (void *)SOSPeerInfoV2DictionaryCopyString();
        if (v31)
        {
          uint64_t v32 = [v21 objectForKey:v31];
          BOOL v33 = v32 == 0;

          if (v33)
          {
            [v21 setObject:v27 forKey:v31];
            goto LABEL_23;
          }
          id v34 = sub_10000B070("ghostBust");
          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t SPID = SOSPeerInfoGetSPID();
            LODWORD(v63) = v49;
            *(void *)((char *)&v63 + 4) = SPID;
            _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "There is a more recent peer than %@ for this serial number", (uint8_t *)&v63, 0xCu);
          }
        }
        else
        {
          id v34 = sub_10000B070("ghostBust");
          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v36 = SOSPeerInfoGetSPID();
            LODWORD(v63) = v49;
            *(void *)((char *)&v63 + 4) = v36;
            _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Removing peerID (%@) with no serial number", (uint8_t *)&v63, 0xCu);
          }
        }

        [v22 addObject:v27];
LABEL_23:

LABEL_24:
        --v25;
      }
      while (v25 > 1);
    }
    id v37 = [v22 count:v49];
    if (v37) {
      SOSCircleRemovePeersByIDUnsigned();
    }
    if (Mutable) {
      CFRelease(Mutable);
    }

    *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) += v37;
    long long v38 = +[NSNumber numberWithUnsignedInteger:v37];
    [*(id *)(a1 + 48) setObject:v38 forKeyedSubscript:@"byAge"];

    *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  }
  int64_t v39 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
  uint64_t v40 = 1;
  if (v39 >= 11)
  {
    unint64_t v41 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
    do
    {
      int64_t v39 = v41 / 0xA;
      v40 *= 10;
      BOOL v42 = v41 > 0x6D;
      v41 /= 0xAuLL;
    }
    while (v42);
  }
  id v43 = +[NSNumber numberWithLongLong:v40 * v39];
  [*(id *)(a1 + 48) setObject:v43 forKeyedSubscript:@"total"];

  unint64_t v44 = *(int *)(a1 + 84);
  uint64_t v45 = 1;
  if ((int)v44 >= 11)
  {
    unint64_t v46 = *(int *)(a1 + 84);
    do
    {
      unint64_t v44 = v46 / 0xA;
      v45 *= 10;
      BOOL v42 = v46 > 0x6D;
      v46 /= 0xAuLL;
    }
    while (v42);
  }
  uint64_t v47 = +[NSNumber numberWithLongLong:v45 * v44];
  [*(id *)(a1 + 48) setObject:v47 forKeyedSubscript:@"startCircleSize"];

  *(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) != 0;
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 8) + 24))
  {
    sub_1001EE684(*(void **)(a1 + 32));
    if (sub_1001EE508(*(void **)(a1 + 32)) || sub_1001EEE6C(*(void **)(a1 + 32), 0))
    {
      sub_1001EE508(*(void **)(a1 + 32));
      [*(id *)(a1 + 32) fullPeerInfo];
      *(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = SOSCircleGenerationSign();
    }
    else
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
    }
  }
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 72) + 8) + 24);
}

void sub_10020A8C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v5 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_10020A8F0(uint64_t a1)
{
  int v2 = SOSPeerInfoGetPeerID();
  if (([v2 isEqualToString:*(void *)(a1 + 32)] & 1) == 0)
  {
    int v3 = *(_DWORD *)(a1 + 72);
    if ((v3 & 2) != 0)
    {
      int v4 = (void *)SOSPeerInfoV2DictionaryCopyString();
      if (([*(id *)(a1 + 40) midIsValidInList:v4] & 1) == 0)
      {
        id v7 = sub_10000B070("ghostBust");
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          int v8 = 138412290;
          uint64_t SPID = SOSPeerInfoGetSPID();
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Removing peerInfo %@ - mid is not in list", (uint8_t *)&v8, 0xCu);
        }

        [*(id *)(a1 + 48) addObject:v2];
        uint64_t v6 = *(void *)(a1 + 56);
        goto LABEL_13;
      }

      int v3 = *(_DWORD *)(a1 + 72);
    }
    if (v3)
    {
      int v4 = (void *)SOSPeerInfoV2DictionaryCopyString();
      if ([*(id *)(a1 + 40) serialIsValidInList:v4])
      {
LABEL_14:

        goto LABEL_15;
      }
      uint64_t v5 = sub_10000B070("ghostBust");
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        int v8 = 138412290;
        uint64_t SPID = SOSPeerInfoGetSPID();
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Removing peerInfo %@ - serial# is not in list", (uint8_t *)&v8, 0xCu);
      }

      [*(id *)(a1 + 48) addObject:v2];
      uint64_t v6 = *(void *)(a1 + 64);
LABEL_13:
      ++*(_DWORD *)(*(void *)(v6 + 8) + 24);
      goto LABEL_14;
    }
  }
LABEL_15:
}

void sub_10020AAD4(uint64_t a1, const void *a2)
{
}

uint64_t sub_10020AADC(const __CFSet *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  CFDictionaryRef v11 = sub_10020ABC8(a1);
  uint64_t v15 = 0;
  id v16 = &v15;
  uint64_t v17 = 0x2000000000;
  int v18 = 4;
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 0x40000000;
  v14[2] = sub_10020AD04;
  v14[3] = &unk_1003089E8;
  v14[6] = a3;
  v14[7] = a4;
  void v14[8] = a6;
  v14[9] = a5;
  void v14[4] = &v15;
  void v14[5] = v11;
  sub_10022FAE4(a2, (uint64_t)v14);
  if (v11) {
    CFRelease(v11);
  }
  uint64_t v12 = *((unsigned int *)v16 + 6);
  _Block_object_dispose(&v15, 8);
  return v12;
}

CFDictionaryRef sub_10020ABC8(const __CFSet *a1)
{
  CFIndex Count = CFSetGetCount(a1);
  size_t v3 = 8 * Count;
  unint64_t v4 = (8 * Count + 15) & 0xFFFFFFFFFFFFFFF0;
  uint64_t v5 = (const void **)&v10[-v4];
  if (((uint64_t (*)(void))__chkstk_darwin)())
  {
    uint64_t v6 = memset(&v10[-v4], 170, v3);
    __chkstk_darwin(v6);
    id v7 = &v10[-v4];
    memset(v7, 170, v3);
    CFSetGetValues(a1, v5);
    uint64_t v8 = 0;
    do
      *(void *)&v7[8 * v8++] = SOSPeerInfoGetPeerID();
    while (Count != v8);
  }
  else
  {
    CFSetGetValues(a1, (const void **)&v10[-v4]);
    id v7 = v10;
  }
  return CFDictionaryCreate(0, (const void **)v7, v5, Count, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
}

void sub_10020AD04(uint64_t a1, const void *a2)
{
  if (CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), a2)
    && (uint64_t v4 = *(void *)(a1 + 48), v5 = *(CFTypeRef **)(a1 + 64), (v6 = SOSPeerInfoCopyPubKey()) != 0))
  {
    id v7 = (__SecKey *)v6;
    if (sub_10022F8E8(v4, a2) && SOSPeerInfoApplicationVerify())
    {
      if (sub_100230158(v4))
      {
        if (sub_1002301F0(v4, v7, v5)) {
          int v8 = 0;
        }
        else {
          int v8 = 6;
        }
      }
      else
      {
        int v8 = 7;
      }
    }
    else
    {
      int v8 = 4;
    }
    CFRelease(v7);
  }
  else
  {
    int v8 = 4;
  }
  id v9 = sub_10000B070("ring");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v17 = 138412546;
    int v18 = a2;
    __int16 v19 = 1024;
    int v20 = v8;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "concordance-signer-status: %@ -> %d", (uint8_t *)&v17, 0x12u);
  }
  if (v8 == 7)
  {
    uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID();
    CFDictionaryRef v11 = *(const void **)(a1 + 72);
    if (PeerID && v11)
    {
      if (!CFEqual(PeerID, v11))
      {
LABEL_18:
        if (!SOSPeerInfoIsCloudIdentity())
        {
          int v8 = 7;
          goto LABEL_21;
        }
      }
    }
    else if (PeerID != v11)
    {
      goto LABEL_18;
    }
    int v8 = 4;
  }
LABEL_21:
  int v12 = 0;
  uint64_t v13 = *(void *)(*(void *)(a1 + 32) + 8);
  if (v8)
  {
    int v14 = *(_DWORD *)(v13 + 24);
    if (v14)
    {
      int v12 = 6;
      if (v8 != 6)
      {
        if (v14 == 7 || v8 == 7) {
          int v16 = 7;
        }
        else {
          int v16 = *(_DWORD *)(v13 + 24);
        }
        if (v14 == 6) {
          int v12 = 6;
        }
        else {
          int v12 = v16;
        }
      }
    }
  }
  *(_DWORD *)(v13 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v12;
}

void sub_10020AEF8(void *a1, uint64_t a2)
{
  uint64_t PeerID = (const void *)SOSPeerInfoGetPeerID();
  if (!sub_10022F8E8(a1[5], PeerID)) {
    return;
  }
  if (!a2) {
    goto LABEL_32;
  }
  uint64_t v5 = a1[5];
  uint64_t v6 = (CFTypeRef *)a1[7];
  uint64_t v7 = SOSPeerInfoCopyPubKey();
  if (!v7) {
    goto LABEL_32;
  }
  int v8 = (void *)v7;
  if (!sub_10022F8E8(v5, PeerID) || !SOSPeerInfoApplicationVerify())
  {
    int v9 = 4;
LABEL_10:
    CFRelease(v8);
    goto LABEL_11;
  }
  if (sub_100230158(v5))
  {
    if (sub_1002301F0(v5, (__SecKey *)v8, v6)) {
      int v9 = 0;
    }
    else {
      int v9 = 6;
    }
    goto LABEL_10;
  }
  CFRelease(v8);
  uint64_t v15 = (const void *)SOSPeerInfoGetPeerID();
  int v16 = (const void *)a1[8];
  if (!v15 || !v16)
  {
    if (v15 != v16) {
      goto LABEL_31;
    }
LABEL_32:
    int v9 = 4;
    goto LABEL_11;
  }
  if (CFEqual(v15, v16)) {
    goto LABEL_32;
  }
LABEL_31:
  if (SOSPeerInfoIsCloudIdentity()) {
    goto LABEL_32;
  }
  int v9 = 7;
LABEL_11:
  int v10 = 0;
  uint64_t v11 = *(void *)(a1[4] + 8);
  if (v9)
  {
    int v12 = *(_DWORD *)(v11 + 24);
    if (v12)
    {
      int v10 = 6;
      if (v9 != 6)
      {
        if (v12 == 7 || v9 == 7) {
          int v14 = 7;
        }
        else {
          int v14 = *(_DWORD *)(v11 + 24);
        }
        if (v12 == 6) {
          int v10 = 6;
        }
        else {
          int v10 = v14;
        }
      }
    }
  }
  *(_DWORD *)(v11 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v10;
}

uint64_t sub_10020B060(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_10020B078(uint64_t a1, const __CFSet *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a6)
  {
    if (sub_10023000C(a4))
    {
      int v14 = sub_10000B070("ring");
      BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
      uint64_t result = 0;
      if (v15)
      {
        *(_WORD *)unint64_t v25 = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "ring empty -> trusted", v25, 2u);
        return 0;
      }
    }
    else
    {
      if (sub_10023000C(a3)) {
        goto LABEL_12;
      }
      sub_10022EE8C((void *)a4);
      sub_10022EE8C((void *)a4);
      CFSetRef Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a4 + 24), @"PeerIDs");
      if (!Value || (CFSetRef v18 = Value, v19 = CFGetTypeID(Value), v19 != CFSetGetTypeID())) {
        CFSetRef v18 = 0;
      }
      if (CFSetGetCount(v18) == 1)
      {
LABEL_12:
        CFSetRef v20 = a2;
        uint64_t v21 = a4;
        uint64_t v22 = a4;
        uint64_t v23 = a6;
        uint64_t v24 = 0;
      }
      else
      {
        if (sub_10022F6B4(*(const __CFDictionary **)(a4 + 24), a3))
        {
          SOSCreateError();
          return 1;
        }
        CFSetRef v20 = a2;
        uint64_t v21 = a3;
        uint64_t v22 = a4;
        uint64_t v23 = a6;
        uint64_t v24 = a7;
      }
      return sub_10020AADC(v20, v21, v22, v23, v24, a8);
    }
  }
  else
  {
    SOSCreateError();
    return 3;
  }
  return result;
}

id sub_10020B8D4()
{
  if (objc_opt_class() && objc_opt_class())
  {
    unint64_t v0 = +[ACAccountStore defaultStore];
    if (v0)
    {
      id v1 = v0;
      int v2 = [v0 aa_primaryAppleAccount];
      goto LABEL_11;
    }
    size_t v3 = sub_10000B070("sosauthkit");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "can't get store", v5, 2u);
    }

    id v1 = 0;
  }
  else
  {
    id v1 = sub_10000B070("sosauthkit");
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "ACAccount not available", buf, 2u);
    }
  }
  int v2 = 0;
LABEL_11:

  return v2;
}

uint64_t sub_10020BB80(uint64_t a1)
{
  int HasString = SOSPeerInfoV2DictionaryHasString();
  if ((HasString & 1) == 0)
  {
    size_t v3 = sub_10000B070("sosauthkit");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v4 = *(void *)(a1 + 32);
      int v6 = 138412290;
      uint64_t v7 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Setting PeerInfo MID to %@", (uint8_t *)&v6, 0xCu);
    }

    SOSPeerInfoV2DictionarySetValue();
  }
  return HasString ^ 1u;
}

void sub_10020C0D4(uint64_t a1, void *a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v4 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
    v4();
  }
  else
  {
    uint64_t v5 = [a2 deviceList];
    int v6 = objc_opt_new();
    long long v18 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    id v7 = v5;
    id v8 = [v7 countByEnumeratingWithState:&v18 objects:v22 count:16];
    if (v8)
    {
      id v9 = v8;
      uint64_t v10 = *(void *)v19;
      do
      {
        for (CFIndex i = 0; i != v9; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v19 != v10) {
            objc_enumerationMutation(v7);
          }
          int v12 = *(void **)(*((void *)&v18 + 1) + 8 * i);
          uint64_t v13 = objc_opt_new();
          int v14 = [v12 machineId];
          [v13 setMachineID:v14];

          BOOL v15 = [v12 serialNumber];
          [v13 setSerialNumber:v15];

          [v6 addObject:v13];
        }
        id v9 = [v7 countByEnumeratingWithState:&v18 objects:v22 count:16];
      }
      while (v9);
    }

    if (![v6 count])
    {
      int v16 = sub_10000B070("sosauthkit");
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int v17 = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "found no devices in account", v17, 2u);
      }

      int v6 = 0;
    }
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

uint64_t sub_10020C5FC(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_10020C614()
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10020C6AC;
  block[3] = &unk_1003093A8;
  void block[4] = &qword_10035D3D8;
  if (qword_10035D3D0 != -1) {
    dispatch_once(&qword_10035D3D0, block);
  }
  return qword_10035D3D8;
}

CFMutableArrayRef sub_10020C6AC(uint64_t a1)
{
  CFMutableArrayRef result = CFArrayCreateMutable(kCFAllocatorDefault, 0, 0);
  **(void **)(a1 + 32) = result;
  return result;
}

uint64_t sub_10020C6EC()
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10020C784;
  block[3] = &unk_1003093A8;
  void block[4] = &qword_10035D3E8;
  if (qword_10035D3E0 != -1) {
    dispatch_once(&qword_10035D3E0, block);
  }
  return qword_10035D3E8;
}

CFMutableArrayRef sub_10020C784(uint64_t a1)
{
  CFMutableArrayRef result = CFArrayCreateMutable(kCFAllocatorDefault, 0, 0);
  **(void **)(a1 + 32) = result;
  return result;
}

uint64_t sub_10020C7C4()
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10020C85C;
  block[3] = &unk_1003093A8;
  void block[4] = &qword_10035D3F8;
  if (qword_10035D3F0 != -1) {
    dispatch_once(&qword_10035D3F0, block);
  }
  return qword_10035D3F8;
}

CFMutableArrayRef sub_10020C85C(uint64_t a1)
{
  CFMutableArrayRef result = CFArrayCreateMutable(kCFAllocatorDefault, 0, 0);
  **(void **)(a1 + 32) = result;
  return result;
}

void sub_10020C89C(void *a1)
{
  id value = a1;
  CFArrayRef v1 = (const __CFArray *)sub_10020C614();
  v6.size_t length = CFArrayGetCount(v1);
  v6.id location = 0;
  FirstIndexOfCFSetRef Value = CFArrayGetFirstIndexOfValue(v1, v6, value);
  if (FirstIndexOfValue != -1)
  {
    for (CFIndex i = FirstIndexOfValue; i != -1; CFIndex i = CFArrayGetFirstIndexOfValue(v1, v7, value))
    {
      CFArrayRemoveValueAtIndex(v1, i);
      v7.size_t length = CFArrayGetCount(v1);
      v7.id location = 0;
    }
  }
}

void sub_10020C938(void *a1)
{
  id value = a1;
  CFArrayRef v1 = (__CFArray *)sub_10020C7C4();
  CFArrayAppendValue(v1, value);
}

void sub_10020C97C(void *a1)
{
  id value = a1;
  CFArrayRef v1 = (const __CFArray *)sub_10020C7C4();
  v6.size_t length = CFArrayGetCount(v1);
  v6.id location = 0;
  FirstIndexOfCFSetRef Value = CFArrayGetFirstIndexOfValue(v1, v6, value);
  if (FirstIndexOfValue != -1)
  {
    for (CFIndex i = FirstIndexOfValue; i != -1; CFIndex i = CFArrayGetFirstIndexOfValue(v1, v7, value))
    {
      CFArrayRemoveValueAtIndex(v1, i);
      v7.size_t length = CFArrayGetCount(v1);
      v7.id location = 0;
    }
  }
}

void sub_10020CA18(void *a1)
{
  id value = a1;
  CFArrayRef v1 = (const __CFArray *)sub_10020C6EC();
  v6.size_t length = CFArrayGetCount(v1);
  v6.id location = 0;
  FirstIndexOfCFSetRef Value = CFArrayGetFirstIndexOfValue(v1, v6, value);
  if (FirstIndexOfValue != -1)
  {
    for (CFIndex i = FirstIndexOfValue; i != -1; CFIndex i = CFArrayGetFirstIndexOfValue(v1, v7, value))
    {
      CFArrayRemoveValueAtIndex(v1, i);
      v7.size_t length = CFArrayGetCount(v1);
      v7.id location = 0;
    }
  }
}

void sub_10020CAB4(void *a1)
{
  id v1 = a1;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v3 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v4 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  uint64_t v5 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (qword_10035D408 != -1) {
    dispatch_once(&qword_10035D408, &stru_100308AB0);
  }
  CFRange v6 = sub_10020C6EC();
  v82[0] = _NSConcreteStackBlock;
  v82[1] = 3221225472;
  v82[2] = sub_10020D4DC;
  v82[3] = &unk_100308AD8;
  id v7 = v1;
  id v83 = v7;
  CFMutableArrayRef v84 = Mutable;
  CFMutableArrayRef v85 = v3;
  CFMutableArrayRef v86 = v4;
  uint64_t v47 = v6;
  [v6 enumerateObjectsUsingBlock:v82];
  id v8 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDictionarySetValue(v8, @"AlwaysKeys", Mutable);
  CFDictionarySetValue(v8, @"FirstUnlockKeys", v3);
  CFDictionarySetValue(v8, @"UnlockedKeys", v4);
  unint64_t v46 = v8;
  CFDictionarySetValue(v5, @"KeyParameter", v8);
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v3) {
    CFRelease(v3);
  }
  if (v4) {
    CFRelease(v4);
  }
  CFMutableArrayRef v9 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v10 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v11 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  CFArrayRef v12 = (const __CFArray *)sub_10020C7C4();
  context[0] = _NSConcreteStackBlock;
  context[1] = 3221225472;
  context[2] = sub_10020D61C;
  context[3] = &unk_100308B00;
  id v13 = v7;
  id v78 = v13;
  CFMutableArrayRef v79 = v9;
  CFMutableArrayRef v80 = v10;
  CFMutableArrayRef v81 = v11;
  v98.size_t length = CFArrayGetCount(v12);
  v98.id location = 0;
  CFArrayApplyFunction(v12, v98, (CFArrayApplierFunction)sub_10020C5FC, context);
  int v14 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDictionarySetValue(v14, @"AlwaysKeys", v9);
  CFDictionarySetValue(v14, @"FirstUnlockKeys", v10);
  CFDictionarySetValue(v14, @"UnlockedKeys", v11);
  CFDictionarySetValue(v5, @"Circle", v14);
  if (v9) {
    CFRelease(v9);
  }
  if (v10) {
    CFRelease(v10);
  }
  if (v11) {
    CFRelease(v11);
  }
  CFMutableArrayRef v15 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v16 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  CFMutableArrayRef v17 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  CFArrayRef v18 = (const __CFArray *)sub_10020C614();
  v72[0] = _NSConcreteStackBlock;
  v72[1] = 3221225472;
  v72[2] = sub_10020D81C;
  v72[3] = &unk_100308B00;
  id v19 = v13;
  id v73 = v19;
  CFMutableArrayRef v74 = v15;
  CFMutableArrayRef v75 = v16;
  CFMutableArrayRef v76 = v17;
  v99.size_t length = CFArrayGetCount(v18);
  v99.id location = 0;
  CFArrayApplyFunction(v18, v99, (CFArrayApplierFunction)sub_10020C5FC, v72);
  long long v20 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFMutableArrayRef cf = v15;
  CFDictionarySetValue(v20, @"AlwaysKeys", v15);
  CFMutableArrayRef v44 = v16;
  CFDictionarySetValue(v20, @"FirstUnlockKeys", v16);
  CFMutableArrayRef v45 = v17;
  CFDictionarySetValue(v20, @"UnlockedKeys", v17);
  BOOL v42 = v20;
  CFDictionarySetValue(v5, @"Message", v20);
  unsigned int v21 = [(id)qword_10035D400 hasChanged:v5];
  uint64_t v22 = sub_10000B070("key-interests");
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v23 = "No Change, Ignoring";
    if (v21) {
      uint64_t v23 = "Registering with CKP";
    }
    *(_DWORD *)long long buf = 136315138;
    uint64_t v88 = v23;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Calculating interests done: %s", buf, 0xCu);
  }

  if (v21)
  {
    long long v70 = 0u;
    long long v71 = 0u;
    long long v68 = 0u;
    long long v69 = 0u;
    v96[0] = @"Message";
    v96[1] = @"Circle";
    v96[2] = @"KeyParameter";
    id obj = +[NSArray arrayWithObjects:v96 count:3];
    int v53 = v5;
    id v50 = [obj countByEnumeratingWithState:&v68 objects:v97 count:16];
    uint64_t v24 = 0;
    if (v50)
    {
      uint64_t v49 = *(void *)v69;
      do
      {
        uint64_t v25 = 0;
        do
        {
          if (*(void *)v69 != v49) {
            objc_enumerationMutation(obj);
          }
          uint64_t v51 = v25;
          OSStatus v26 = *(const char **)(*((void *)&v68 + 1) + 8 * v25);
          OSStatus v27 = sub_10000B070("key-interests");
          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138412290;
            uint64_t v88 = v26;
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Updating interests: %@", buf, 0xCu);
          }

          long long v66 = 0u;
          long long v67 = 0u;
          long long v64 = 0u;
          long long v65 = 0u;
          v94[0] = @"AlwaysKeys";
          v94[1] = @"FirstUnlockKeys";
          v94[2] = @"UnlockedKeys";
          id v52 = +[NSArray arrayWithObjects:v94 count:3];
          id v55 = [v52 countByEnumeratingWithState:&v64 objects:v95 count:16];
          if (v55)
          {
            uint64_t v54 = *(void *)v65;
            do
            {
              uint64_t v28 = 0;
              do
              {
                id v58 = v24;
                if (*(void *)v65 != v54) {
                  objc_enumerationMutation(v52);
                }
                uint64_t v57 = v28;
                uint64_t v29 = *(void *)(*((void *)&v64 + 1) + 8 * v28);
                id v30 = [(__CFDictionary *)v5 objectForKeyedSubscript:v26];
                id v31 = [v30 objectForKeyedSubscript:v29];

                id v56 = [v31 count];
                long long v60 = 0u;
                long long v61 = 0u;
                long long v62 = 0u;
                long long v63 = 0u;
                id v32 = v31;
                id v33 = [v32 countByEnumeratingWithState:&v60 objects:v93 count:16];
                if (v33)
                {
                  id v34 = v33;
                  uint64_t v35 = *(void *)v61;
                  do
                  {
                    for (CFIndex i = 0; i != v34; CFIndex i = (char *)i + 1)
                    {
                      if (*(void *)v61 != v35) {
                        objc_enumerationMutation(v32);
                      }
                      uint64_t v37 = *(void *)(*((void *)&v60 + 1) + 8 * i);
                      long long v38 = sub_10000B070("key-interests");
                      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)long long buf = 138412802;
                        uint64_t v88 = v26;
                        __int16 v89 = 2112;
                        uint64_t v90 = v29;
                        __int16 v91 = 2112;
                        uint64_t v92 = v37;
                        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, " key-intrest: %@->%@: %@", buf, 0x20u);
                      }
                    }
                    id v34 = [v32 countByEnumeratingWithState:&v60 objects:v93 count:16];
                  }
                  while (v34);
                }
                uint64_t v24 = &v58[(void)v56];

                uint64_t v28 = v57 + 1;
                uint64_t v5 = v53;
              }
              while ((id)(v57 + 1) != v55);
              id v55 = [v52 countByEnumeratingWithState:&v64 objects:v95 count:16];
            }
            while (v55);
          }

          uint64_t v25 = v51 + 1;
        }
        while ((id)(v51 + 1) != v50);
        id v50 = [obj countByEnumeratingWithState:&v68 objects:v97 count:16];
      }
      while (v50);
    }

    int64_t v39 = sub_10000B070("key-interests");
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      uint64_t v88 = v24;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "Pushing %lu interests to CKP", buf, 0xCu);
    }

    CFStringRef v40 = sub_1001FF568(v19);
    unint64_t v41 = dispatch_get_global_queue(-2, 0);
    id v59 = v19;
    SOSCloudKeychainUpdateKeys();

    if (v40) {
      CFRelease(v40);
    }

    uint64_t v5 = v53;
  }
  else
  {
    [v19 setKey_interests_need_updating:0];
  }
  if (cf) {
    CFRelease(cf);
  }
  if (v44) {
    CFRelease(v44);
  }
  if (v45) {
    CFRelease(v45);
  }
  if (v46) {
    CFRelease(v46);
  }
  if (v14) {
    CFRelease(v14);
  }
  if (v42) {
    CFRelease(v42);
  }
  if (v5) {
    CFRelease(v5);
  }
}

void sub_10020D4DC(void *a1, void *a2)
{
  id v3 = a2;
  CFMutableArrayRef v4 = [v3 SOSTransportKeyParameterGetAccount:v3];
  uint64_t v5 = v4;
  if (v4 == (void *)a1[4])
  {
    id v6 = [v3 SOSTransportKeyParameterGetTransportType:v3 err:0];

    if (v6 == (id)1)
    {
      CFTypeRef cf = 0;
      if (([v3 SOSTransportKeyParameterKVSAppendKeyInterests:v3 ak:a1[5] firstUnLock:a1[6] unlocked:a1[7] err:&cf] & 1) == 0)
      {
        id v7 = sub_10000B070("key-interests");
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          CFTypeRef v11 = cf;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Error getting key parameters interests %@", buf, 0xCu);
        }
      }
      CFTypeRef v8 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        CFRelease(v8);
      }
    }
  }
  else
  {
  }
}

void sub_10020D61C(void *a1, void *a2)
{
  id v3 = a2;
  CFMutableArrayRef v4 = [v3 getAccount];
  unsigned int v5 = [v4 isEqual:a1[4]];

  if (v5)
  {
    id v6 = v3;
    CFTypeRef cf = 0;
    if (([v6 kvsAppendKeyInterest:a1[5] firstUnlock:a1[6] unlocked:a1[7] err:&cf] & 1) == 0)
    {
      id v7 = sub_10000B070("key-interests");
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        CFTypeRef v13 = cf;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Error getting circle interests %@", buf, 0xCu);
      }
    }
    if (([v6 kvsAppendRingKeyInterest:a1[5] firstUnlock:a1[6] unlocked:a1[7] err:&cf] & 1) == 0)
    {
      CFTypeRef v8 = sub_10000B070("key-interests");
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        CFTypeRef v13 = cf;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Error getting ring interests %@", buf, 0xCu);
      }
    }
    if (([v6 kvsAppendDebugKeyInterest:a1[5] firstUnlock:a1[6] unlocked:a1[7] err:&cf] & 1) == 0)
    {
      CFMutableArrayRef v9 = sub_10000B070("key-interests");
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        CFTypeRef v13 = cf;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Error getting debug key interests %@", buf, 0xCu);
      }
    }
    CFTypeRef v10 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v10);
    }
  }
}

void sub_10020D81C(void *a1, void *a2)
{
  id v3 = a2;
  CFMutableArrayRef v4 = [v3 SOSTransportMessageGetAccount];
  unsigned int v5 = v4;
  if (v4 == (void *)a1[4])
  {
    id v6 = [v3 SOSTransportMessageGetTransportType];

    if (v6 == (id)1)
    {
      CFTypeRef cf = 0;
      if (([v3 SOSTransportMessageKVSAppendKeyInterest:v3 ak:a1[5] firstUnlock:a1[6] unlocked:a1[7] err:&cf] & 1) == 0)
      {
        id v7 = sub_10000B070("key-interests");
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          CFTypeRef v11 = cf;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Error getting message interests %@", buf, 0xCu);
        }
      }
      CFTypeRef v8 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        CFRelease(v8);
      }
    }
  }
  else
  {
  }
}

id sub_10020D948(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    unsigned int v5 = sub_10000B070("key-interests");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      uint64_t v9 = a3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Error updating keys: %@", (uint8_t *)&v8, 0xCu);
    }

    [*(id *)(a1 + 32) setKey_interests_need_updating:1];
    return [(id)qword_10035D400 reset];
  }
  else
  {
    id v7 = *(void **)(a1 + 32);
    return [v7 setKey_interests_need_updating:0];
  }
}

void sub_10020DA60(id a1)
{
  qword_10035D400 = objc_opt_new();

  _objc_release_x1();
}

uint64_t sub_10020DA9C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10020DAAC(uint64_t a1)
{
}

void sub_10020DAB4(uint64_t a1, CFTypeRef cf, const void *a3)
{
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFStringGetTypeID())
    {
      switch(SOSKVSKeyGetKeyTypeAndParse())
      {
        case 0u:
          int v8 = *(__CFDictionary **)(a1 + 48);
          break;
        case 1u:
          if (!*(unsigned char *)(a1 + 96)) {
            goto LABEL_25;
          }
          CFDictionaryRef v9 = *(const __CFDictionary **)(a1 + 56);
          goto LABEL_17;
        case 2u:
          if (a3)
          {
            CFTypeID v10 = CFGetTypeID(a3);
            if (v10 == CFDataGetTypeID())
            {
              CFRetain(a3);
              *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a3;
            }
          }
          goto LABEL_25;
        case 3u:
          if (*(unsigned char *)(a1 + 96)) {
            *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
          }
          goto LABEL_25;
        case 4u:
          if (!*(unsigned char *)(a1 + 96)) {
            goto LABEL_25;
          }
          CFDictionaryRef v9 = *(const __CFDictionary **)(a1 + 64);
LABEL_17:
          CFSetRef Value = (__CFDictionary *)CFDictionaryGetValue(v9, 0);
          if (!Value || (Mutable = Value, CFTypeID v13 = CFGetTypeID(Value), v13 != CFDictionaryGetTypeID()))
          {
            CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            CFDictionarySetValue(v9, 0, Mutable);
            if (Mutable) {
              CFRelease(Mutable);
            }
          }
          int v8 = Mutable;
          break;
        case 5u:
        case 8u:
        case 9u:
        case 0xAu:
          id v7 = sub_10000B070("updates");
          if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138412290;
            CFTypeRef v18 = cf;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Unknown key '%@', ignoring", buf, 0xCu);
          }

          goto LABEL_25;
        case 6u:
          if (!*(unsigned char *)(a1 + 96)) {
            goto LABEL_25;
          }
          int v8 = *(__CFDictionary **)(a1 + 80);
          break;
        default:
          goto LABEL_25;
      }
      CFDictionarySetValue(v8, 0, a3);
    }
  }
LABEL_25:
  int v14 = *(void **)(a1 + 88);
  if (v14 && *v14)
  {
    CFMutableArrayRef v15 = sub_10000B070("SecError");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = **(void **)(a1 + 88);
      *(_DWORD *)long long buf = 138412802;
      CFTypeRef v18 = cf;
      __int16 v19 = 2112;
      long long v20 = a3;
      __int16 v21 = 2112;
      uint64_t v22 = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Peer message processing error for: %@ -> %@ (%@)", buf, 0x20u);
    }
  }
}

void sub_10020DE50(uint64_t a1, void *a2)
{
  id v3 = a2;
  CFMutableArrayRef v4 = [v3 SOSTransportKeyParameterGetAccount:v3];
  unsigned int v5 = [v4 isEqual:*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)];

  if (v5
    && ([v3 SOSTransportKeyParameterHandleKeyParameterChanges:v3 data:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) err:0] & 1) == 0)
  {
    CFTypeID v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 138412290;
      uint64_t v8 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Transport failed to handle new key parameters: %@", (uint8_t *)&v7, 0xCu);
    }
  }
}

void sub_10020DF5C(void *a1, void *a2)
{
  id v3 = a2;
  CFMutableArrayRef v4 = [v3 getAccount];
  unsigned int v5 = [v4 isEqual:*(void *)(*(void *)(a1[4] + 8) + 40)];

  if (v5)
  {
    CFDictionaryRef v6 = (const __CFDictionary *)[v3 handleRetirementMessages:a1[5] err:a1[6]];
    if (v6)
    {
      CFDictionaryRef v7 = v6;
      context[0] = _NSConcreteStackBlock;
      context[1] = 3221225472;
      context[2] = sub_10020EB8C;
      context[3] = &unk_100308F10;
      void context[4] = a1[7];
      CFDictionaryApplyFunction(v6, (CFDictionaryApplierFunction)sub_10020EC88, context);
      CFRelease(v7);
    }
    else
    {
      uint64_t v8 = sub_10000B070("SecError");
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        uint64_t v11 = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Transport failed to handle retirement messages: %@", buf, 0xCu);
      }
    }
  }
}

void sub_10020E0C8(void *a1, void *a2)
{
  id v3 = a2;
  CFTypeRef cf = 0;
  CFTypeRef v22 = 0;
  CFMutableArrayRef v4 = [v3 SOSTransportMessageGetAccount];
  unsigned int v5 = [v4 isEqual:*(void *)(*(void *)(a1[4] + 8) + 40)];

  if (v5)
  {
    CFDictionaryRef v6 = (const __CFDictionary *)[v3 SOSTransportMessageHandlePeerMessageReturnsHandledCopy:v3 peerMessages:a1[5] err:&v22];
    if (v6)
    {
      CFDictionaryRef v7 = v6;
      CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(v6, [v3 SOSTransportMessageGetCircleName]);
      if (Value)
      {
        CFArrayRef v9 = Value;
        CFTypeID v10 = CFGetTypeID(Value);
        if (v10 == CFArrayGetTypeID())
        {
          context[0] = _NSConcreteStackBlock;
          context[1] = 3221225472;
          context[2] = sub_10020EAE0;
          context[3] = &unk_100309C58;
          id v11 = v3;
          uint64_t v12 = a1[4];
          id v18 = v11;
          uint64_t v19 = v12;
          uint64_t v20 = a1[6];
          v25.size_t length = CFArrayGetCount(v9);
          v25.id location = 0;
          CFArrayApplyFunction(v9, v25, (CFArrayApplierFunction)sub_10020C5FC, context);
        }
      }
      if (([v3 SOSTransportMessageFlushChanges:v3 err:&cf] & 1) == 0)
      {
        CFTypeID v13 = sub_10000B070("msg");
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          CFTypeRef v24 = cf;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Flush failed: %@", buf, 0xCu);
        }
      }
      CFTypeRef v14 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        CFRelease(v14);
      }
      CFRelease(v7);
    }
    else
    {
      CFMutableArrayRef v15 = sub_10000B070("msg");
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        CFTypeRef v24 = v22;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "No messages handled: %@", buf, 0xCu);
      }
    }
    CFTypeRef v16 = v22;
    if (v22)
    {
      CFTypeRef v22 = 0;
      CFRelease(v16);
    }
  }
}

void sub_10020E334(uint64_t a1, void *a2)
{
  id v3 = a2;
  CFMutableArrayRef v4 = [v3 getAccount];
  unsigned int v5 = [v4 isEqual:*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40)];

  if (v5)
  {
    CFArrayRef v6 = (const __CFArray *)[v3 handleCircleMessagesAndReturnHandledCopy:*(void *)(a1 + 40) err:*(void *)(a1 + 48)];
    if (v6)
    {
      CFArrayRef v7 = v6;
      if (CFArrayGetCount(v6))
      {
        v13[0] = _NSConcreteStackBlock;
        v13[1] = 3221225472;
        v13[2] = sub_10020EA7C;
        v13[3] = &unk_100308DB0;
        long long v14 = *(_OWORD *)(a1 + 48);
        v21.size_t length = CFArrayGetCount(v7);
        v21.id location = 0;
        CFArrayApplyFunction(v7, v21, (CFArrayApplierFunction)sub_10020C5FC, v13);
      }
      else if (CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 40)))
      {
        CFArrayRef v9 = sub_10000B070("SecError");
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          CFIndex Count = CFArrayGetCount(v7);
          CFIndex v11 = CFDictionaryGetCount(*(CFDictionaryRef *)(a1 + 40));
          *(_DWORD *)long long buf = 134218498;
          CFIndex v16 = Count;
          __int16 v17 = 2048;
          CFIndex v18 = v11;
          __int16 v19 = 2112;
          uint64_t v20 = 0;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Transport failed to process all circle messages: (%ld/%ld) %@", buf, 0x20u);
        }
      }
      else
      {
        uint64_t v12 = sub_10000B070("circle");
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Transport handled no circle messages", buf, 2u);
        }
      }
      CFRelease(v7);
    }
    else
    {
      uint64_t v8 = sub_10000B070("SecError");
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        CFIndex v16 = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Transport failed to handle circle messages: %@", buf, 0xCu);
      }
    }
  }
}

void sub_10020E5A8(void *a1, void *a2)
{
  id v3 = [a2 getAccount];
  unsigned int v4 = [v3 isEqual:*(void *)(*(void *)(a1[4] + 8) + 40)];

  if (v4)
  {
    CFArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    context[0] = _NSConcreteStackBlock;
    context[1] = 3221225472;
    context[2] = sub_10020E87C;
    context[3] = &unk_100308BF0;
    CFDictionaryRef v6 = (const __CFDictionary *)a1[5];
    uint64_t v7 = a1[6];
    void context[4] = a1[4];
    void context[5] = v7;
    void context[6] = Mutable;
    CFDictionaryApplyFunction(v6, (CFDictionaryApplierFunction)sub_10020EC88, context);
    if (CFArrayGetCount(Mutable))
    {
      v9[0] = _NSConcreteStackBlock;
      v9[1] = 3221225472;
      _DWORD v9[2] = sub_10020EA20;
      v9[3] = &unk_100309D30;
      void v9[4] = a1[7];
      v13.size_t length = CFArrayGetCount(Mutable);
      v13.id location = 0;
      CFArrayApplyFunction(Mutable, v13, (CFArrayApplierFunction)sub_10020C5FC, v9);
      if (!Mutable) {
        return;
      }
      goto LABEL_4;
    }
    uint64_t v8 = sub_10000B070("SecError");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v12 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Transport failed to handle ring messages: %@", buf, 0xCu);
    }

    if (Mutable) {
LABEL_4:
    }
      CFRelease(Mutable);
  }
}

void sub_10020E7AC(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID()) {
      CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 32), 0, @"%@ ", cf);
    }
  }
}

void sub_10020E814(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID()) {
      CFStringAppendFormat(*(CFMutableStringRef *)(a1 + 32), 0, @"%@ ", cf);
    }
  }
}

void sub_10020E87C(uint64_t a1, const void *a2, const __CFData *cf)
{
  if (!cf || (v5 = cf, CFTypeID v6 = CFGetTypeID(cf), v6 != CFDataGetTypeID())) {
    CFDataRef v5 = 0;
  }
  uint64_t v7 = sub_1001FF110(*(CFTypeRef **)(a1 + 40), v5);
  uint64_t v8 = *(void *)(a1 + 40);
  id v9 = *(id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  CFTypeID v10 = v9;
  if (v9)
  {
    if ([v9 accountIsChanging])
    {
      CFIndex v11 = sub_10000B070("circleOps");
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)CFMutableArrayRef v15 = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "SOSAccountUpdateRingFromRemote called before signing in to new account", v15, 2u);
      }

LABEL_12:
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 48), a2);
      goto LABEL_13;
    }
    id v9 = v10;
  }
  if (!sub_1001EEC4C(v9))
  {

    if (!v7) {
      return;
    }
    goto LABEL_14;
  }
  uint64_t v12 = [v10 trust];
  CFRange v13 = [v10 circle_transport];
  unsigned int v14 = [v12 handleUpdateRing:v10 prospectiveRing:v7 transport:v13 userPublicKey:[v10 accountKey] writeUpdate:0 err:v8];

  if (v14) {
    goto LABEL_12;
  }
LABEL_13:
  if (!v7) {
    return;
  }
LABEL_14:

  CFRelease(v7);
}

void sub_10020EA20(uint64_t a1)
{
  int v2 = (const void *)SOSRingKeyCreateWithRingName();
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v2);
  if (v2)
  {
    CFRelease(v2);
  }
}

void sub_10020EA7C(uint64_t a1)
{
  int v2 = (const void *)SOSCircleKeyCreateWithName();
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 40), v2);
  if (v2)
  {
    CFRelease(v2);
  }
}

void sub_10020EAE0(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v3 = CFGetTypeID(cf);
    if (v3 == CFStringGetTypeID())
    {
      CFTypeID v4 = [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) peerID];
      CFDataRef v5 = (const void *)SOSMessageKeyCreateFromPeerToTransport();

      if (v5)
      {
        CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 48), v5);
        CFRelease(v5);
      }
    }
  }
}

void sub_10020EB8C(uint64_t a1, uint64_t a2, CFArrayRef theArray)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_10020EC2C;
  void v5[3] = &unk_100308DB0;
  uint64_t v4 = *(void *)(a1 + 32);
  void v5[4] = a2;
  void v5[5] = v4;
  v6.size_t length = CFArrayGetCount(theArray);
  v6.id location = 0;
  CFArrayApplyFunction(theArray, v6, (CFArrayApplierFunction)sub_10020C5FC, v5);
}

void sub_10020EC2C(uint64_t a1)
{
  int v2 = (const void *)SOSRetirementKeyCreateWithCircleNameAndPeer();
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 40), v2);
  if (v2)
  {
    CFRelease(v2);
  }
}

uint64_t sub_10020EC88(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t sub_10020ECA4(const void *a1)
{
  if (CFEqual(a1, @"iCloudIdentity-tomb")) {
    return 1;
  }
  if (CFEqual(a1, @"PCS-MasterKey-tomb")) {
    return 1;
  }
  uint64_t result = CFEqual(a1, @"RecoveryRing");
  if (result) {
    return 1;
  }
  return result;
}

uint64_t sub_10020ED00()
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10020ED98;
  block[3] = &unk_1003093A8;
  void block[4] = &qword_10035D418;
  if (qword_10035D410 != -1) {
    dispatch_once(&qword_10035D410, block);
  }
  return qword_10035D418;
}

uint64_t sub_10020ED98(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

__CFString *sub_10020EDCC(uint64_t a1)
{
  sub_100025824();

  return sub_10020EE04(a1);
}

__CFString *sub_10020EE04(uint64_t a1)
{
  int v2 = (const void *)SOSGenerationCountCopyDescription();
  CFTypeID v3 = (const void *)SOSCopyIDOfDataBufferWithLength();
  CFArrayRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  CFStringAppendFormat(Mutable, 0, @"<SOSRecoveryKeyBag@%p DSID: %@ version: %d  gencount: %@  RecoveryKeyID: %@ ", a1, *(void *)(a1 + 16), *(void *)(a1 + 32), v2, v3);
  CFStringAppend(Mutable, @">");
  if (v2) {
    CFRelease(v2);
  }
  if (v3) {
    CFRelease(v3);
  }
  return Mutable;
}

void sub_10020EEBC(void *a1)
{
  int v2 = (const void *)a1[2];
  if (v2)
  {
    a1[2] = 0;
    CFRelease(v2);
  }
  CFTypeID v3 = (const void *)a1[3];
  if (v3)
  {
    a1[3] = 0;
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)a1[5];
  if (v4)
  {
    a1[5] = 0;
    CFRelease(v4);
  }
}

BOOL sub_10020EF24(void *a1)
{
  uint64_t v2 = a1[5];
  BOOL v3 = v2 != 0;
  if (!v2) {
    SOSCreateError();
  }
  if (!a1[2])
  {
    SOSCreateError();
    BOOL v3 = 0;
  }
  if (!a1[3])
  {
    SOSCreateError();
    return 0;
  }
  return v3;
}

uint64_t sub_10020EFC4(const __CFAllocator *a1, void *a2, const __CFData *a3, uint64_t *a4)
{
  CFDataRef v5 = a2;
  if (!a2) {
    goto LABEL_20;
  }
  uint64_t v8 = (__CFString *)sub_1001E4B34(a2);
  if (!v8)
  {
    id v9 = +[ACAccountStore defaultStore];
    CFTypeID v10 = [v9 aa_primaryAppleAccount];
    [v10 aa_personID];
    uint64_t v8 = (__CFString *)objc_claimAutoreleasedReturnValue();

    sub_1001FF4C0(v5, kSOSDSIDKey, (uint64_t)v8, 0);
    if (!v8)
    {
      SOSCreateError();
      CFDataRef v5 = 0;
      goto LABEL_22;
    }
  }
  uint64_t v11 = SOSGenerationCreate();
  CFDataRef v5 = (void *)v11;
  if (!a3 || !v11)
  {
LABEL_20:
    SOSCreateError();
LABEL_22:
    uint64_t v13 = 0;
    goto LABEL_12;
  }
  sub_10020ED00();
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v13 = Instance;
  if (Instance)
  {
    *(void *)(Instance + 32) = 1;
    *(void *)(Instance + 16) = CFStringCreateCopy(a1, v8);
    if (*(void **)(v13 + 24) != v5)
    {
      CFRetain(v5);
      unsigned int v14 = *(const void **)(v13 + 24);
      if (v14) {
        CFRelease(v14);
      }
      *(void *)(v13 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v5;
    }
    *(void *)(v13 + 40) = CFDataCreateCopy(a1, a3);
  }
  else
  {
    SOSCreateError();
  }
LABEL_12:
  if (a4 && *a4)
  {
    CFMutableArrayRef v15 = sub_10000B070("recovery");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = *a4;
      int v18 = 138412290;
      uint64_t v19 = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Error in SOSRecoveryKeyBagCreateForAccount - %@", (uint8_t *)&v18, 0xCu);
    }
  }
  if (v5) {
    CFRelease(v5);
  }
  return v13;
}

__CFData *sub_10020F204(uint64_t a1, CFTypeRef *a2)
{
  if (!a1) {
    return 0;
  }
  if (!sub_10020EF24((void *)a1)) {
    return 0;
  }
  sub_10000FBB4(*(const __CFString **)(a1 + 16));
  SOSGenCountGetDEREncodedSize();
  ccder_sizeof_uint64();
  CFDataGetLength(*(CFDataRef *)(a1 + 40));
  ccder_sizeof_raw_octet_string();
  uint64_t v4 = ccder_sizeof();
  if (!v4) {
    return 0;
  }
  CFIndex v5 = v4;
  CFArrayRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
  CFDataSetLength(Mutable, v5);
  if (!sub_100029834((uint64_t)Mutable, a2, @"Failed to create scratch")
    || (MutableBytePtr = CFDataGetMutableBytePtr(Mutable), CFDataGetLength(Mutable), MutableBytePtr)
    && (!sub_10020EF24((void *)a1)
     || (CFStringRef v8 = *(const __CFString **)(a1 + 16),
         sub_100010510(*(const __CFData **)(a1 + 40), a2),
         ccder_encode_uint64(),
         uint64_t v9 = SOSGenCountEncodeToDER(),
         sub_10000FC34(v8, a2, MutableBytePtr, v9, v10),
         (UInt8 *)ccder_encode_constructed_tl() != MutableBytePtr)))
  {
    if (Mutable)
    {
      CFRelease(Mutable);
      return 0;
    }
  }
  return Mutable;
}

uint64_t sub_10020F384(const __CFAllocator *a1, CFDataRef theData, CFTypeRef *a3)
{
  BytePtr = CFDataGetBytePtr(theData);
  uint64_t v7 = &BytePtr[CFDataGetLength(theData)];
  if (!BytePtr) {
    goto LABEL_8;
  }
  sub_10020ED00();
  uint64_t Instance = _CFRuntimeCreateInstance();
  if (sub_100029834(Instance, a3, @"Recovery bag allocation failed"))
  {
    uint64_t v9 = ccder_decode_sequence_tl();
    if (!v7)
    {
      sub_10000F564(kCFAllocatorDefault, (CFStringRef *)(Instance + 16), a3, v9, 0);
      *(void *)(Instance + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = SOSGenCountCreateFromDER();
      uint64_t v10 = ccder_decode_uint64();
      uint64_t v12 = sub_100010258(a1, (CFDataRef *)(Instance + 40), a3, v10, 0);
      sub_1000297D0(v12 == 0, a3, @"Extra space in sequence");
      if (!v12) {
        goto LABEL_9;
      }
      goto LABEL_7;
    }
  }
  if (Instance)
  {
LABEL_7:
    CFRelease((CFTypeRef)Instance);
LABEL_8:
    uint64_t Instance = 0;
  }
LABEL_9:
  sub_1000297D0(v7 == 0, a3, @"Didn't consume all data supplied");
  if (v7 && Instance)
  {
    CFRelease((CFTypeRef)Instance);
    return 0;
  }
  return Instance;
}

void sub_10020FA5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v13 - 128), 8);
  _Block_object_dispose((const void *)(v13 - 96), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10020FA98(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10020FAA8(uint64_t a1)
{
}

BOOL sub_10020FAB0(uint64_t a1)
{
  uint64_t v2 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
  [*(id *)(a1 + 32) fullPeerInfo];
  sub_1001DCC24(v2, @"EscrowRecord");
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = SOSFullPeerInfoReplaceEscrowRecords();
  [*(id *)(a1 + 32) fullPeerInfo];
  char v3 = SOSCircleRequestAdmission();
  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8);
  if (*(unsigned char *)(v4 + 24)) {
    char v5 = v3;
  }
  else {
    char v5 = 0;
  }
  *(unsigned char *)(v4 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v5;
  [*(id *)(a1 + 32) setDepartureCode:1];
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
    return 0;
  }
  if (!*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24)) {
    return 1;
  }
  SOSFullPeerInfoGetPeerInfo();
  if (SOSPeerInfoGetPeerID())
  {
    if (SOSCircleHasActivePeerWithID())
    {
      [*(id *)(a1 + 32) peerInfo];
      SOSCircleAcceptRequest();
    }
  }
  return *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) != 0;
}

uint64_t sub_10020FE00(uint64_t a1, uint64_t a2)
{
  [*(id *)(a1 + 32) fullPeerInfo];
  if (SOSCircleResetToOffering()
    && ([*(id *)(a1 + 32) setDepartureCode:1],
        objc_msgSend(*(id *)(a1 + 32), "addEscrowToPeerInfo:err:", objc_msgSend(*(id *)(a1 + 32), "fullPeerInfo"), *(void *)(a1 + 56)))&& objc_msgSend(*(id *)(a1 + 32), "addiCloudIdentity:key:err:", a2, *(void *)(a1 + 48), *(void *)(a1 + 56)))
  {
    sub_1001EC3F0(*(void **)(a1 + 40), 0);
    uint64_t v4 = 1;
    [*(id *)(a1 + 40) setNotifyBackupOnExit:1];
  }
  else
  {
    CFRange v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412546;
      uint64_t v8 = a2;
      __int16 v9 = 2112;
      uint64_t v10 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "error resetting circle (%@) to offering: %@", buf, 0x16u);
    }

    return 0;
  }
  return v4;
}

BOOL sub_100210174(uint64_t a1, uint64_t a2)
{
  return sub_1001E56E0(*(void **)(a1 + 32), a2);
}

BOOL sub_1002102A0(uint64_t a1, uint64_t a2)
{
  return sub_1001E56E0(*(void **)(a1 + 32), a2);
}

uint64_t sub_100210394(uint64_t a1)
{
  uint64_t result = SOSPeerInfoGetPeerID();
  if (result)
  {
    uint64_t result = (uint64_t)[*(id *)(a1 + 32) isEqualToString:result];
    if ((result & 1) == 0)
    {
      char v3 = *(uint64_t (**)(void))(*(void *)(a1 + 40) + 16);
      return v3();
    }
  }
  return result;
}

uint64_t sub_100210594(uint64_t a1, uint64_t a2)
{
  [*(id *)(a1 + 32) peerInfo];
  int HasPeer = SOSCircleHasPeer();
  uint64_t updated = SOSCircleUpdatePeerInfo();
  if (HasPeer)
  {
    [*(id *)(a1 + 32) accountKey];
    char v6 = SOSCircleVerify();
    uint64_t v7 = *(void **)(a1 + 40);
    if (v6)
    {
      uint64_t updated = updated | [v7 fixICloudIdentities:*(void *)(a1 + 32) circle:a2];
    }
    else
    {
      unsigned int v8 = [v7 upgradeiCloudIdentity:a2 privKey:*(void *)(a1 + 48)];
      [*(id *)(a1 + 40) removeInvalidApplications:a2 userPublic:[*(id *)(a1 + 32) accountKey]];
      [*(id *)(a1 + 40) fullPeerInfo];
      uint64_t updated = updated | v8 | SOSCircleGenerationSign();
      [*(id *)(a1 + 40) setDepartureCode:1];
    }
  }
  __int16 v9 = sub_10000B070("updatingGenSignature");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    v12[0] = 67109120;
    v12[1] = updated;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "we changed the circle? %{BOOL}d", (uint8_t *)v12, 8u);
  }

  uint64_t v10 = [*(id *)(a1 + 40) iCloudCheckEventHandle:*(void *)(a1 + 32)];
  [v10 followup];

  return updated;
}

void sub_100212380(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1002123E8(uint64_t a1, uint64_t a2)
{
  SOSPeerInfoGetPeerID();
  uint64_t v4 = (const void *)SOSCircleCopyPeerWithID();
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) |= sub_10021250C(a2, (uint64_t)v4);
  if (v4)
  {
    CFRelease(v4);
  }
}

void sub_10021247C(uint64_t a1, uint64_t a2)
{
  SOSPeerInfoGetPeerID();
  uint64_t v4 = (const void *)SOSCircleCopyPeerWithID();
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) |= sub_10021250C((uint64_t)v4, a2);
  if (v4)
  {
    CFRelease(v4);
  }
}

BOOL sub_10021250C(uint64_t a1, uint64_t a2)
{
  if (!a1) {
    return a2 != 0;
  }
  char v3 = (const void *)SOSPeerInfoCopyOctagonSigningPublicKey();
  uint64_t v4 = (const void *)SOSPeerInfoCopyOctagonEncryptionPublicKey();
  if (a2)
  {
    char v5 = (const void *)SOSPeerInfoCopyOctagonSigningPublicKey();
    char v6 = (const void *)SOSPeerInfoCopyOctagonEncryptionPublicKey();
  }
  else
  {
    char v5 = 0;
    char v6 = 0;
  }
  BOOL v8 = sub_100212850((uint64_t)v3, (uint64_t)v5);
  BOOL v9 = sub_100212850((uint64_t)v4, (uint64_t)v6);
  if (v3) {
    CFRelease(v3);
  }
  if (v4) {
    CFRelease(v4);
  }
  if (v5) {
    CFRelease(v5);
  }
  BOOL v7 = !v8 || !v9;
  if (v6) {
    CFRelease(v6);
  }
  return v7;
}

BOOL sub_100212850(uint64_t a1, uint64_t a2)
{
  if (!a1 || !a2) {
    return (a1 | a2) == 0;
  }
  uint64_t v2 = (void *)SecKeyCopySubjectPublicKeyInfo();
  char v3 = (void *)SecKeyCopySubjectPublicKeyInfo();
  id v4 = [v2 isEqual:v3];

  return (BOOL)v4;
}

void sub_100212E90(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = a1;
  id v5 = [v4 peerInfo];
  char v6 = [v4 trust];

  if ([v6 trustedCircle] && v5)
  {
    SOSPeerInfoGetPeerID();
    id v7 = v3;
    SOSCircleForEachPeer();
  }
}

uint64_t sub_100212F74(uint64_t a1)
{
  uint64_t result = SOSPeerInfoGetPeerID();
  if (result)
  {
    uint64_t result = CFEqual((CFTypeRef)result, *(CFTypeRef *)(a1 + 40));
    if (!result)
    {
      id v3 = *(uint64_t (**)(void))(*(void *)(a1 + 32) + 16);
      return v3();
    }
  }
  return result;
}

void sub_1002133C0()
{
  dispatch_get_global_queue(-2, 0);
  id v0 = (id)objc_claimAutoreleasedReturnValue();
  SOSCloudKeychainPutObjectsInCloud();
}

void sub_100213424(id a1, __CFDictionary *a2, __CFError *a3)
{
  if (a3)
  {
    id v4 = sub_10000B070("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 138412290;
      char v6 = a3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Error putting: %@", (uint8_t *)&v5, 0xCu);
    }
  }
}

void sub_1002136B0(uint64_t a1)
{
  uint64_t v2 = (const void *)SOSRingKeyCreateWithRingName();
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v2);
  if (v2)
  {
    CFRelease(v2);
  }
}

void sub_100213858(uint64_t a1)
{
  SOSPeerInfoGetPeerID();
  uint64_t v2 = (const void *)SOSRetirementKeyCreateWithCircleNameAndPeer();
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 40), v2);
  if (v2)
  {
    CFRelease(v2);
  }
}

void sub_100213980(uint64_t a1, CFTypeRef cf, const void *a3)
{
  if (!cf
    || (CFTypeID v6 = CFGetTypeID(cf), TypeID = CFStringGetTypeID(), !a3)
    || v6 != TypeID
    || (CFTypeID v8 = CFGetTypeID(a3), v8 != CFDataGetTypeID()))
  {
    BOOL v9 = sub_10000B070("SecError");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Error, Key-Value for CircleMessage was not CFString/CFData", buf, 2u);
    }
  }
  id v10 = [*(id *)(a1 + 32) account];
  uint64_t v11 = v10;
  CFErrorRef err = 0;
  if (v10 && [v10 accountIsChanging])
  {
    uint64_t v12 = sub_10000B070("circleOps");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "SOSAccountHandleCircleMessage called before signing in to new account", buf, 2u);
    }

LABEL_48:
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 40), cf);
    return;
  }
  if (!a3) {
    goto LABEL_17;
  }
  CFTypeID v13 = CFGetTypeID(a3);
  if (v13 != CFDataGetTypeID())
  {
    CFTypeID v14 = CFGetTypeID(a3);
    if (v14 != CFNullGetTypeID())
    {
      OSStatus v26 = sub_10000B070("circleOps");
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Value provided not appropriate for a circle", buf, 2u);
      }

      CFTypeID v27 = CFGetTypeID(a3);
      CFStringRef v28 = CFCopyTypeIDDescription(v27);
      SOSCreateErrorWithFormat();
      if (!v28) {
        goto LABEL_43;
      }
      CFStringRef v29 = v28;
      goto LABEL_42;
    }
  }
  CFTypeID v15 = CFGetTypeID(a3);
  if (v15 == CFNullGetTypeID())
  {
LABEL_17:
    uint64_t v16 = sub_10000B070("circleOps");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      CFTypeRef v37 = a3;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "No circle found in data: %@", buf, 0xCu);
    }

    goto LABEL_43;
  }
  uint64_t v17 = SOSCircleCreateFromData();
  if (!v17)
  {
    id v30 = sub_10000B070("circleOps");
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "SOSCircleCreateFromData returned NULL.", buf, 2u);
    }

    goto LABEL_43;
  }
  CFStringRef v18 = (const __CFString *)v17;
  CFTypeRef Name = (CFTypeRef)SOSCircleGetName();
  CFTypeRef v20 = Name;
  if (cf && Name)
  {
    if (CFEqual(Name, cf)) {
      goto LABEL_24;
    }
    goto LABEL_39;
  }
  if (Name != cf)
  {
LABEL_39:
    id v31 = sub_10000B070("circleOps");
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412546;
      CFTypeRef v37 = cf;
      __int16 v38 = 2112;
      int64_t v39 = v20;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Expected circle named %@, got %@", buf, 0x16u);
    }

    SOSCreateErrorWithFormat();
    CFStringRef v29 = v18;
LABEL_42:
    CFRelease(v29);
LABEL_43:
    id v32 = sub_10000B070("SecError");
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "NULL circle found, ignoring ...", buf, 2u);
    }

    CFErrorRef v24 = err;
    goto LABEL_46;
  }
LABEL_24:
  CFRange v21 = [v11 trust];
  CFTypeRef v22 = [v11 circle_transport];
  unsigned __int8 v23 = [v21 updateCircleFromRemote:v22 newCircle:v18 err:&err];

  CFRelease(v18);
  CFErrorRef v24 = err;
  if (v23)
  {
LABEL_46:
    if (v24)
    {
      CFErrorRef err = 0;
      CFRelease(v24);
    }
    goto LABEL_48;
  }
  if (err)
  {
    if (CFErrorGetCode(err) == 5)
    {
      CFErrorDomain Domain = CFErrorGetDomain(v24);
      if (Domain && kSOSErrorDomain)
      {
        if (!CFEqual(Domain, kSOSErrorDomain)) {
          goto LABEL_54;
        }
LABEL_51:
        id v33 = sub_10000B070("SecError");
        if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          CFTypeRef v37 = cf;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "Incompatible circle found, abandoning membership: %@", buf, 0xCu);
        }

        goto LABEL_54;
      }
      if (Domain == (CFErrorDomain)kSOSErrorDomain) {
        goto LABEL_51;
      }
    }
LABEL_54:
    CFErrorRef v24 = err;
  }

  id v34 = sub_10000B070("SecError");
  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412802;
    CFTypeRef v37 = cf;
    __int16 v38 = 2112;
    int64_t v39 = a3;
    __int16 v40 = 2112;
    CFErrorRef v41 = v24;
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Error handling circle message %@ (%@): %@", buf, 0x20u);
  }

  if (v24) {
    CFRelease(v24);
  }
}

uint64_t sub_100213F24(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void sub_100214284(uint64_t a1, CFTypeRef cf, const void *a3)
{
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    CFTypeID TypeID = CFStringGetTypeID();
    if (a3)
    {
      if (v6 == TypeID)
      {
        CFTypeID v8 = CFGetTypeID(a3);
        if (v8 == CFArrayGetTypeID())
        {
          v10[0] = _NSConcreteStackBlock;
          v10[1] = 3221225472;
          void v10[2] = sub_100214370;
          v10[3] = &unk_100308DB0;
          uint64_t v9 = *(void *)(a1 + 32);
          void v10[4] = cf;
          v10[5] = v9;
          v11.size_t length = CFArrayGetCount((CFArrayRef)a3);
          v11.id location = 0;
          CFArrayApplyFunction((CFArrayRef)a3, v11, (CFArrayApplierFunction)sub_100214408, v10);
        }
      }
    }
  }
}

void sub_100214370(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v3 = CFGetTypeID(cf);
    if (v3 == CFStringGetTypeID())
    {
      id v4 = (const void *)SOSRetirementKeyCreateWithCircleNameAndPeer();
      CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 40), v4, kCFNull);
      if (v4)
      {
        CFRelease(v4);
      }
    }
  }
}

uint64_t sub_100214408(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_1002149D0(uint64_t a1, const __CFString *a2)
{
}

void sub_1002149D8(id a1, __CFDictionary *a2, __CFError *a3)
{
  if (a3)
  {
    id v4 = sub_10000B070("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 138412290;
      CFTypeID v6 = a3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Error putting: %@", (uint8_t *)&v5, 0xCu);
    }
  }
}

void sub_100215754(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100215770(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned char *a6)
{
  CFArrayRef theArray = 0;
  CFTypeRef v50 = 0;
  id v10 = (id *)(a1 + 32);
  CFRange v11 = [*(id *)(a1 + 32) SOSTransportMessageGetAccount];
  id v12 = [*v10 engine];
  uint64_t v48 = 0;
  LOBYTE(v10) = sub_100206FF0(v11, (uint64_t)v12, a5, (uint64_t)a2, a3, &v50, *(void **)(a1 + 56), &theArray, &v48, *(CFTypeRef **)(a1 + 64));
  CFTypeID v13 = v48;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = (_BYTE)v10;

  CFTypeID v14 = sub_10000B070("ratelimit");
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = theArray;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "attribute list: %@", (uint8_t *)&buf, 0xCu);
  }

  if (!theArray)
  {
    CFArrayRef theArray = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    CFArrayAppendValue(theArray, @"NoAttribute");
  }
  if (*(unsigned char *)(a1 + 72))
  {
    int v15 = 1;
  }
  else
  {
    uint64_t v16 = sub_10000B070("ratelimit");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "not going to rate limit, currently in initial sync", (uint8_t *)&buf, 2u);
    }

    int v15 = *(unsigned __int8 *)(a1 + 72);
  }
  CFTypeRef v17 = v50;
  if (v15 && v50)
  {
    CFStringRef v18 = sub_10000B070("ratelimit");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "not in initial sync!", (uint8_t *)&buf, 2u);
    }

    CFArrayRef v19 = theArray;
    id v20 = *(id *)(a1 + 32);
    CFRange v21 = +[NSDate date];
    uint64_t v57 = 0;
    id v58 = &v57;
    uint64_t v59 = 0x2020000000;
    char v60 = 0;
    CFTypeRef v22 = sub_100215F70((uint64_t)a2);
    uint64_t v51 = 0;
    id v52 = &v51;
    uint64_t v53 = 0x3032000000;
    uint64_t v54 = sub_100215FDC;
    id v55 = sub_100215FEC;
    id v56 = 0;
    if (qword_10035D428 == -1)
    {
      if (v19)
      {
LABEL_16:
        unsigned __int8 v23 = sub_10000B070("ratelimit");
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          CFIndex Count = CFArrayGetCount(v19);
          LODWORD(buf) = 134217984;
          *(void *)((char *)&buf + 4) = Count;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "number of attributes to review: %lu", (uint8_t *)&buf, 0xCu);
        }

        *(void *)&long long buf = _NSConcreteStackBlock;
        *((void *)&buf + 1) = 3221225472;
        long long v64 = sub_100215FF4;
        long long v65 = &unk_100308EA8;
        id v66 = v22;
        id v67 = v21;
        long long v69 = &v51;
        id v25 = v20;
        long long v71 = a2;
        CFTypeRef v72 = v17;
        id v68 = v25;
        long long v70 = &v57;
        [(__CFArray *)v19 enumerateObjectsUsingBlock:&buf];

LABEL_25:
        if ([(id)v52[5] count])
        {
          v61[0] = @"timestamp";
          [v21 timeIntervalSince1970];
          CFStringRef v28 = +[NSNumber numberWithDouble:](NSNumber, "numberWithDouble:");
          v62[0] = v28;
          v61[1] = @"peerShouldSend";
          CFStringRef v29 = +[NSNumber numberWithBool:*((unsigned __int8 *)v58 + 24)];
          void v61[2] = @"attributeBadness";
          uint64_t v30 = v52[5];
          v62[1] = v29;
          v62[2] = v30;
          id v31 = +[NSDictionary dictionaryWithObjects:v62 forKeys:v61 count:3];
          sub_100029560(@"SOSKVSRateLimitingEvent", v31);
        }
        BOOL v32 = *((unsigned char *)v58 + 24) != 0;
        _Block_object_dispose(&v51, 8);

        _Block_object_dispose(&v57, 8);
        CFIndex v33 = CFArrayGetCount(theArray);
        v73.id location = 0;
        v73.size_t length = v33;
        if (CFArrayContainsValue(theArray, v73, @"com.apple.security.ckks")
          || (v74.id location = 0, v74.length = v33, CFArrayContainsValue(theArray, v74, @"com.apple.sbd"))
          || (v75.id location = 0, v75.length = v33,
                                  CFArrayContainsValue(theArray, v75, @"com.apple.securebackupd")))
        {
          BOOL v32 = 1;
        }
        id v34 = sub_10000B070("ratelimit");
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 67109120;
          DWORD1(buf) = v32;
          _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "should send? : %{BOOL}d", (uint8_t *)&buf, 8u);
        }

        if (!v32)
        {
          BOOL v42 = sub_10000B070("ratelimit");
          if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v43 = *(void *)(a1 + 56);
            LODWORD(buf) = 138412290;
            *(void *)((char *)&buf + 4) = v43;
            _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "peer is rate limited: %@", (uint8_t *)&buf, 0xCu);
          }

          goto LABEL_43;
        }
LABEL_34:
        CFArrayRef v35 = theArray;
        id v36 = *(id *)(a1 + 32);
        CFTypeRef v37 = sub_100215F70((uint64_t)a2);
        *(void *)&long long buf = _NSConcreteStackBlock;
        *((void *)&buf + 1) = 3221225472;
        long long v64 = sub_10021661C;
        long long v65 = &unk_100308EF0;
        id v66 = v37;
        id v67 = v36;
        id v68 = a2;
        id v38 = v37;
        id v39 = v36;
        [(__CFArray *)v35 enumerateObjectsUsingBlock:&buf];

        uint64_t v40 = *(void *)(*(void *)(a1 + 48) + 8);
        if (*(unsigned char *)(v40 + 24))
        {
          unsigned __int8 v41 = [*(id *)(a1 + 32) SOSTransportMessageSendMessage:*(void *)(a1 + 32) id:*(void *)(a1 + 56) messageToSend:v17 err:*(void *)(a1 + 64)];
          uint64_t v40 = *(void *)(*(void *)(a1 + 48) + 8);
        }
        else
        {
          unsigned __int8 v41 = 0;
        }
        *(unsigned char *)(v40 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v41;
        int v44 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
        CFMutableArrayRef v45 = v13;
        if (-[OTSOSActualAdapter sosEnabled]_0()) {
          [(SOSEnginePeerMessageCallBackInfo *)v45 callCallback:v44 != 0];
        }

        [*(id *)(a1 + 32) SOSTransportMessageUpdateLastMessageSentTimetstamp:*(void *)(a1 + 40) peer:a2];
LABEL_43:

        CFRelease(v17);
        goto LABEL_44;
      }
    }
    else
    {
      dispatch_once(&qword_10035D428, &stru_100308E80);
      if (v19) {
        goto LABEL_16;
      }
    }
    *((unsigned char *)v58 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    goto LABEL_25;
  }
  if (v50) {
    goto LABEL_34;
  }
  OSStatus v26 = sub_10000B070("transport");
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v27 = *(void *)(a1 + 56);
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = v27;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "no message to send to peer: %@", (uint8_t *)&buf, 0xCu);
  }

LABEL_44:
  CFArrayRef v46 = theArray;
  if (theArray)
  {
    CFArrayRef theArray = 0;
    CFRelease(v46);
  }
  *a6 = *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
}

void sub_100215F38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

PeerRateLimiter *sub_100215F70(uint64_t a1)
{
  uint64_t v2 = (PeerRateLimiter *)*(id *)(a1 + 96);
  if (!v2)
  {
    CFTypeID v3 = [[PeerRateLimiter alloc] initWithPeer:a1];
    uint64_t v2 = v3;
    if (v3) {
      CFRetain(v3);
    }
    *(void *)(a1 + 96) = v2;
  }

  return v2;
}

uint64_t sub_100215FDC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100215FEC(uint64_t a1)
{
}

void sub_100215FF4(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v4 = [*(id *)(a1 + 32) stateForAccessGroup:v3];
  if (v4 == 2)
  {
    uint64_t v9 = sub_10000B070("ratelimit");
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_30;
    }
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = v3;
    id v38 = "access group: %@ is being rate limited";
LABEL_27:
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v38, buf, 0xCu);
    goto LABEL_30;
  }
  if (v4 != 1)
  {
    uint64_t v9 = sub_10000B070("ratelimit");
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_30;
    }
    uint64_t v39 = *(void *)(a1 + 72);
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = v39;
    id v38 = "no state for limiter for peer: %@";
    goto LABEL_27;
  }
  int v5 = [[KeychainItem alloc] initWithAccessGroup:v3];
  CFTypeID v6 = *(void **)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 40);
  id v43 = 0;
  id v8 = [v6 judge:v5 at:v7 limitTime:&v43];
  uint64_t v9 = v43;
  uint64_t v10 = sub_10000B070("ratelimit");
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(void *)&buf[14] = v8;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "accessGroup: %@, judged: %lu", buf, 0x16u);
  }

  uint64_t v11 = [(id)qword_10035D420 objectForKeyedSubscript:v3];
  uint64_t v12 = +[NSNumber numberWithInteger:v8];
  if (([v11 isEqual:v12] & 1) == 0)
  {
    [(id)qword_10035D420 setObject:v12 forKeyedSubscript:v3];
    uint64_t v13 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
    if (!v13)
    {
      id v14 = objc_alloc_init((Class)NSMutableDictionary);
      uint64_t v15 = *(void *)(*(void *)(a1 + 56) + 8);
      uint64_t v16 = *(void **)(v15 + 40);
      *(void *)(v15 + 40) = v14;

      uint64_t v13 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
    }
    [v13 setObject:v12 forKeyedSubscript:v3];
  }
  [v9 timeIntervalSinceDate:*(void *)(a1 + 40)];
  if (v17 <= 0.0)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  }
  else
  {
    double v18 = v17;
    BOOL v42 = v5;
    CFArrayRef v19 = [*(id *)(a1 + 48) SOSTransportMessageGetAccount];
    id v20 = *(void **)(a1 + 32);
    *(void *)long long buf = 0;
    id v21 = v3;
    id v22 = v20;
    sub_1001DCC24(v19, @"RateLimitCounters");
    id v23 = (id)objc_claimAutoreleasedReturnValue();
    if (!v23) {
      id v23 = objc_alloc_init((Class)NSMutableDictionary);
    }
    CFErrorRef v24 = [v22 diagnostics];
    [v23 setObject:v24 forKey:v21];

    sub_1001FF4C0(v19, @"RateLimitCounters", (uint64_t)v23, (CFTypeRef *)buf);
    id v25 = sub_10000B070("ratelimit");
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v9;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "setting a timer for next sync: %@", buf, 0xCu);
    }
    unsigned __int8 v41 = v11;

    uint64_t v26 = *(void *)(a1 + 80);
    uint64_t v40 = *(void *)(a1 + 72);
    id v27 = *(id *)(a1 + 32);
    id v28 = v21;
    CFStringRef v29 = sub_10000B070("ratelimit");
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = (int)v18;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "SOSPeerSetNextTimeToSend next time: %d", buf, 8u);
    }

    uint64_t v30 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, (dispatch_queue_t)&_dispatch_main_q);
    dispatch_time_t v31 = dispatch_time(0, 1000000000 * (int)v18);
    dispatch_source_set_timer(v30, v31, 0xFFFFFFFFFFFFFFFFLL, 0);
    BOOL v32 = sub_10000B070("ratelimit");
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = 1000000000 * (int)v18;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "SOSPeerSetNextTimeToSend next time to sync: %llu", buf, 0xCu);
    }

    CFIndex v33 = [v27 accessGroupToNextMessageToSend];
    [v33 setObject:v26 forKey:v28];

    uint64_t v34 = *(void *)(v40 + 16);
    if (v34) {
      CFRetain(*(CFTypeRef *)(v40 + 16));
    }
    uint64_t v11 = v41;
    if (v28) {
      CFRetain(v28);
    }
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 3221225472;
    *(void *)&uint8_t buf[16] = sub_100216834;
    CFArrayRef v46 = &unk_100308EC8;
    uint64_t v47 = v34;
    id v48 = v28;
    dispatch_source_set_event_handler(v30, buf);
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 3221225472;
    handler[2] = sub_100216944;
    handler[3] = &unk_100308EC8;
    void handler[4] = v34;
    void handler[5] = v28;
    dispatch_source_set_cancel_handler(v30, handler);
    dispatch_resume(v30);
    CFArrayRef v35 = [v27 accessGroupToTimer];
    [v35 setObject:v30 forKey:v28];

    id v36 = [*(id *)(a1 + 32) accessGroupRateLimitState];
    id v37 = [objc_alloc((Class)NSNumber) initWithLong:2];
    [v36 setObject:v37 forKey:v28];

    int v5 = v42;
  }

LABEL_30:
}

void sub_10021661C(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v4 = [*(id *)(a1 + 32) accessGroupToNextMessageToSend];
  int v5 = [v4 objectForKey:v3];

  if (!v5) {
    goto LABEL_14;
  }
  id v20 = 0;
  unsigned int v6 = [*(id *)(a1 + 40) SOSTransportMessageSendMessage:*(void *)(a1 + 40) id:*(void *)(*(void *)(a1 + 48) + 16) messageToSend:v5 err:&v20];
  uint64_t v7 = v20;
  id v8 = sub_10000B070("ratelimit");
  BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (v6) {
    BOOL v10 = v7 == 0;
  }
  else {
    BOOL v10 = 0;
  }
  if (v10)
  {
    if (v9)
    {
      *(_DWORD *)long long buf = 138412546;
      id v22 = v5;
      __int16 v23 = 2112;
      id v24 = v3;
      uint64_t v11 = "SOSTransportSendPendingMessage: sent pending message: %@ for access group: %@";
      uint64_t v12 = v8;
      uint32_t v13 = 22;
      goto LABEL_10;
    }
  }
  else if (v9)
  {
    *(_DWORD *)long long buf = 138412290;
    id v22 = v20;
    uint64_t v11 = "SOSTransportSendPendingMessage: could not send message: %@";
    uint64_t v12 = v8;
    uint32_t v13 = 12;
LABEL_10:
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v11, buf, v13);
  }

  id v14 = [*(id *)(a1 + 32) accessGroupToNextMessageToSend];
  [v14 removeObjectForKey:v3];

  uint64_t v15 = [*(id *)(a1 + 32) accessGroupToTimer];
  uint64_t v16 = [v15 objectForKey:v3];

  if (v16) {
    dispatch_source_cancel(v16);
  }
  double v17 = [*(id *)(a1 + 32) accessGroupToTimer];
  [v17 removeObjectForKey:v3];

  double v18 = [*(id *)(a1 + 32) accessGroupRateLimitState];
  id v19 = [objc_alloc((Class)NSNumber) initWithLong:1];
  [v18 setObject:v19 forKey:v3];

LABEL_14:
}

void sub_100216834(uint64_t a1)
{
  CFTypeRef v4 = 0;
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  _DWORD v2[2] = sub_10022D0B8;
  v2[3] = &unk_100308FF8;
  long long v3 = *(_OWORD *)(a1 + 32);
  sub_100220170(&v4, v2);
  if (v4)
  {
    id v1 = sub_10000B070("SecError");
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      CFTypeRef v6 = v4;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "error sending next message: %@", buf, 0xCu);
    }
  }
}

void sub_100216944(uint64_t a1)
{
  uint64_t v2 = *(const void **)(a1 + 32);
  if (v2) {
    CFRelease(v2);
  }
  long long v3 = *(const void **)(a1 + 40);
  if (v3)
  {
    CFRelease(v3);
  }
}

void sub_100216994(id a1)
{
  id v1 = objc_alloc_init((Class)NSMutableDictionary);
  uint64_t v2 = qword_10035D420;
  qword_10035D420 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_100216CD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v13 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_100216CFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned char *a6)
{
  uint64_t v7 = *(void *)(a1 + 56);
  id v8 = *(__CFString ***)(a1 + 72);
  if (a3)
  {
    CFDataRef v10 = *(const __CFData **)(a1 + 64);
    unint64_t v181 = 0;
    if (v10)
    {
      if (*(void *)(a3 + 24))
      {
        CFArrayRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
        CFStringRef cf = CFCopyDescription(*(CFTypeRef *)(a3 + 24));
        int v12 = SecOTRSGetMessageKind();
        if (v12 != 1)
        {
          if (v12)
          {
            uint64_t v26 = sub_10000B070("SecError");
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(buf[0]) = 138412546;
              *(void *)((char *)buf + 4) = v7;
              WORD2(buf[1]) = 2112;
              *(void *)((char *)&buf[1] + 6) = v10;
              _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%@ Unknown packet type: %@", (uint8_t *)buf, 0x16u);
            }
            SOSCreateError();
          }
          else
          {
            CFMutableDataRef v13 = CFDataCreateMutable(kCFAllocatorDefault, 0);
            if (v13)
            {
              CFMutableDataRef v14 = v13;
              int v15 = SecOTRSProcessPacket();
              if (v15 == -26275)
              {
                CFStringAppend(Mutable, @"resending dh");
                LODWORD(v1_Block_object_dispose(&a9, 8) = sub_1001FFF28(a3);
              }
              else if (v15)
              {
                uint64_t v144 = v7;
                uint64_t v145 = v15;
                SOSCreateErrorWithFormat();
                LODWORD(v1_Block_object_dispose(&a9, 8) = 3;
              }
              else if (CFDataGetLength(v14) < 2)
              {
                if (SecOTRSGetIsReadyForMessages())
                {
                  CFStringAppend(Mutable, @"completed negotiation");
                  *(unsigned char *)(a3 + 32) = 0;
                  LODWORD(v1_Block_object_dispose(&a9, 8) = 2;
                }
                else
                {
                  CFStringAppend(Mutable, @"stuck?");
                  LODWORD(v1_Block_object_dispose(&a9, 8) = 1;
                }
              }
              else
              {
                uint64_t v16 = SecOTRPacketTypeString();
                CFStringAppendFormat(Mutable, 0, @"Sending OTR Response %s", v16);
                if (*(CFMutableDataRef *)(a3 + 40) != v14)
                {
                  CFRetain(v14);
                  double v17 = *(const void **)(a3 + 40);
                  if (v17) {
                    CFRelease(v17);
                  }
                  *(void *)(a3 + 40) = v14;
                }
                LODWORD(v1_Block_object_dispose(&a9, 8) = 1;
                if (SecOTRSGetIsReadyForMessages())
                {
                  CFStringAppend(Mutable, @" begin waiting for data packet");
                  *(unsigned char *)(a3 + 32) = 1;
                }
              }
              CFRelease(v14);
              MutableCFDataRef Copy = 0;
              goto LABEL_61;
            }
            uint64_t v144 = v7;
            SOSCreateErrorWithFormat();
          }
          MutableCFDataRef Copy = 0;
          LODWORD(v1_Block_object_dispose(&a9, 8) = 3;
LABEL_61:
          if (v8 && v18 == 3 && *v8) {
            CFStringAppendFormat(Mutable, 0, @" %@", *v8);
          }
          BOOL v32 = sub_10000B070("coder");
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v33 = SecOTRPacketTypeString();
            uint64_t v34 = *(void *)(a3 + 24);
            if (v18 > 5) {
              CFArrayRef v35 = "StatusUnknown";
            }
            else {
              CFArrayRef v35 = off_100308458[v18];
            }
            LODWORD(buf[0]) = 138413570;
            *(void *)((char *)buf + 4) = v7;
            WORD2(buf[1]) = 2112;
            *(void *)((char *)&buf[1] + 6) = cf;
            HIWORD(buf[2]) = 2080;
            v190 = (void *)v33;
            LOWORD(v191[0]) = 2112;
            *(void *)((char *)v191 + 2) = Mutable;
            WORD1(v191[1]) = 2112;
            *(void *)((char *)&v191[1] + 4) = v34;
            WORD2(v191[2]) = 2080;
            *(void *)((char *)&v191[2] + 6) = v35;
            _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "%@ %@ %s %@ %@ returned %s", (uint8_t *)buf, 0x3Eu);
          }
          if (cf) {
            CFRelease(cf);
          }
          CFRelease(Mutable);
          goto LABEL_73;
        }
        theString = Mutable;
        id v152 = v8;
        uint64_t v21 = v7;
        id v22 = *(const void **)(a3 + 48);
        __int16 v23 = (CFIndex *)ccsha1_di();
        CFDataGetBytePtr(v10);
        CFDataGetLength(v10);
        CFIndex v24 = *v23;
        if (*v23 < 0)
        {
          id v25 = 0;
        }
        else
        {
          id v25 = CFDataCreateMutable(kCFAllocatorDefault, 0);
          CFDataSetLength(v25, v24);
          CFDataGetMutableBytePtr(v25);
          ccdigest();
        }
        *(void *)(a3 + 4_Block_object_dispose(&a9, 8) = v25;
        int v27 = *(unsigned __int8 *)(a3 + 56);
        *(unsigned char *)(a3 + 56) = 0;
        uint64_t v7 = v21;
        id v28 = v22;
        if ((SecOTRSGetIsReadyForMessages() & 1) == 0)
        {
          CFArrayRef Mutable = theString;
          CFStringAppend(theString, @"not ready for data; resending DH packet");
          LODWORD(v1_Block_object_dispose(&a9, 8) = sub_1001FFF28(a3);
          MutableCFDataRef Copy = 0;
          id v8 = v152;
          goto LABEL_59;
        }
        CFArrayRef Mutable = theString;
        if (*(unsigned char *)(a3 + 32))
        {
          CFStringAppend(theString, @"got data packet we were waiting for ");
          *(unsigned char *)(a3 + 32) = 0;
        }
        MutableCFDataRef Copy = CFDataCreateMutable(0, 0);
        uint64_t v18 = SecOTRSVerifyAndExposeMessage();
        CFStringAppend(theString, @"verify and expose message");
        id v8 = v152;
        if (v18 == -25329)
        {
          CFStringAppend(theString, @" too new");
          LODWORD(v1_Block_object_dispose(&a9, 8) = 5;
          goto LABEL_57;
        }
        if (v18 != -25328)
        {
          if (!v18)
          {
            CFStringAppend(theString, @"decoded OTR protected packet");
            goto LABEL_59;
          }
          sub_100012A40(v18, v152, @"%@ Cannot expose message: %d", v7, v18);
          uint64_t v30 = sub_10000B070("SecError");
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
          {
            if (v152) {
              dispatch_time_t v31 = *v152;
            }
            else {
              dispatch_time_t v31 = 0;
            }
            LODWORD(buf[0]) = 138412546;
            *(void *)((char *)buf + 4) = v7;
            WORD2(buf[1]) = 2112;
            *(void *)((char *)&buf[1] + 6) = v31;
            _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "%@ Decode OTR Protected Packet: %@", (uint8_t *)buf, 0x16u);
          }
          LODWORD(v1_Block_object_dispose(&a9, 8) = 3;
          if (!MutableCopy) {
            goto LABEL_59;
          }
LABEL_58:
          CFRelease(MutableCopy);
          MutableCFDataRef Copy = 0;
LABEL_59:
          if (v28) {
            CFRelease(v28);
          }
          goto LABEL_61;
        }
        CFStringRef v29 = *(const void **)(a3 + 48);
        if (v28 && v29)
        {
          if (CFEqual(v28, v29))
          {
LABEL_41:
            CFStringAppend(theString, @" repeated");
            LODWORD(v1_Block_object_dispose(&a9, 8) = 4;
            goto LABEL_57;
          }
        }
        else if (v28 == v29)
        {
          goto LABEL_41;
        }
        *(unsigned char *)(a3 + 56) = 1;
        if (v27)
        {
          CFStringAppend(theString, @" too old, repeated renegotiating");
          LODWORD(v1_Block_object_dispose(&a9, 8) = 3;
        }
        else
        {
          CFStringAppend(theString, @" too old, forcing message");
          LODWORD(v1_Block_object_dispose(&a9, 8) = 6;
        }
LABEL_57:
        if (!MutableCopy) {
          goto LABEL_59;
        }
        goto LABEL_58;
      }
      CFIndex Length = CFDataGetLength(v10);
      MutableCFDataRef Copy = CFDataCreateMutableCopy(0, Length, v10);
    }
    else
    {
      MutableCFDataRef Copy = 0;
    }
    LODWORD(v1_Block_object_dispose(&a9, 8) = 0;
LABEL_73:
    id v36 = CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 104), *(const void **)(a2 + 16));
    if (v36)
    {
      id v37 = sub_10000B070("otrtimer");
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf[0]) = 138412290;
        *(void *)((char *)buf + 4) = a2;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "removing timer for peer: %@", (uint8_t *)buf, 0xCu);
      }

      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a2 + 104), *(const void **)(a2 + 16));
      dispatch_source_cancel(v36);
    }
    int v38 = 1;
    switch((int)v18)
    {
      case 0:
        goto LABEL_101;
      case 1:
        uint64_t v39 = sub_10000B070("engine");
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf[0]) = 138412290;
          *(void *)((char *)buf + 4) = v7;
          _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "%@ engine negotiating", (uint8_t *)buf, 0xCu);
        }
        goto LABEL_89;
      case 2:
        *(unsigned char *)(a2 + 4_Block_object_dispose(&a9, 8) = 1;
        sub_100206508((__CFArray **)(a2 + 80), *(const void **)(a2 + 72));
        *a6 = 1;
        uint64_t v39 = sub_10000B070("engine");
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf[0]) = 138412290;
          *(void *)((char *)buf + 4) = v7;
          _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "%@ engine negotiation complete", (uint8_t *)buf, 0xCu);
        }
        goto LABEL_89;
      case 3:
        unsigned __int8 v41 = sub_10000B070("engine");
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          if (v8) {
            BOOL v42 = *v8;
          }
          else {
            BOOL v42 = 0;
          }
          LODWORD(buf[0]) = 138412546;
          *(void *)((char *)buf + 4) = v7;
          WORD2(buf[1]) = 2112;
          *(void *)((char *)&buf[1] + 6) = v42;
          _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "%@ engine failed handling message %@", (uint8_t *)buf, 0x16u);
        }

        sub_1001FFEA0(a3);
        if (sub_1001FFC14(a3, &v181) != 3) {
          goto LABEL_109;
        }
        int v44 = sub_10000B070("SecError");
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf[0]) = 138412290;
          *(void *)((char *)buf + 4) = v181;
          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "Attempt to recover coder failed to restart: %@", (uint8_t *)buf, 0xCu);
        }
        goto LABEL_108;
      case 4:
        uint64_t v39 = sub_10000B070("engine");
        if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
        {
          LODWORD(buf[0]) = 138412290;
          *(void *)((char *)buf + 4) = v7;
          _os_log_debug_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEBUG, "%@ engine stale event ignored", (uint8_t *)buf, 0xCu);
        }
LABEL_89:

        goto LABEL_100;
      case 5:
        id v43 = sub_10000B070("engine");
        if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf[0]) = 138412290;
          *(void *)((char *)buf + 4) = v7;
          _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "%@ engine received a message too soon, time to restart", (uint8_t *)buf, 0xCu);
        }

        sub_1001FFEA0(a3);
        if (sub_1001FFC14(a3, &v181) != 3) {
          goto LABEL_109;
        }
        int v44 = sub_10000B070("SecError");
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf[0]) = 138412290;
          *(void *)((char *)buf + 4) = v181;
          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "Attempt to recover coder failed to restart: %@", (uint8_t *)buf, 0xCu);
        }
LABEL_108:

        goto LABEL_109;
      case 6:
        *(unsigned char *)(a2 + 4_Block_object_dispose(&a9, 8) = 1;
LABEL_100:
        int v38 = 2;
LABEL_101:
        if (!MutableCopy) {
          goto LABEL_111;
        }
        goto LABEL_110;
      default:
        uint64_t v40 = sub_10000B070("engine");
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf[0]) = 138412546;
          *(void *)((char *)buf + 4) = v7;
          WORD2(buf[1]) = 1024;
          *(_DWORD *)((char *)&buf[1] + 6) = v18;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "%@ engine unknown coder state: %d", (uint8_t *)buf, 0x12u);
        }

        sub_10002BBA0(@"Execution has encountered an unexpected state", 0x53C0000Eu);
LABEL_109:
        int v38 = 0;
        if (MutableCopy)
        {
LABEL_110:
          CFRetain(MutableCopy);
          CFRelease(MutableCopy);
        }
LABEL_111:

        CFMutableArrayRef v45 = v181;
        if (v181)
        {
          unint64_t v181 = 0;
          CFRelease(v45);
        }
        break;
    }
    goto LABEL_113;
  }
  long long v138 = sub_10000B070("SecError");
  if (os_log_type_enabled(v138, OS_LOG_TYPE_DEFAULT))
  {
    if (v8) {
      uint64_t v139 = *v8;
    }
    else {
      uint64_t v139 = 0;
    }
    LODWORD(buf[0]) = 138412546;
    *(void *)((char *)buf + 4) = v7;
    WORD2(buf[1]) = 2112;
    *(void *)((char *)&buf[1] + 6) = v139;
    _os_log_impl((void *)&_mh_execute_header, v138, OS_LOG_TYPE_DEFAULT, "%@ getCoder: %@", (uint8_t *)buf, 0x16u);
  }

  MutableCFDataRef Copy = 0;
  int v38 = 0;
LABEL_113:
  uint64_t v46 = sub_1001DCC24(*(void **)(a1 + 32), @"NegotiationRetryCount");
  uint64_t v47 = (void *)v46;
  if (a3)
  {
    if (v46)
    {
      if ((SecOTRSessionIsSessionInAwaitingState() & 1) == 0)
      {
        id v48 = [v47 objectForKey:*(void *)(a1 + 56)];
        BOOL v49 = v48 == 0;

        if (!v49)
        {
          CFTypeRef v50 = sub_10000B070("otrtimer");
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "otr negotiation completed! clearing max retry counter", (uint8_t *)buf, 2u);
          }

          uint64_t v51 = *(void **)(a1 + 56);
          id v52 = *(id *)(a1 + 32);
          id v53 = v51;
          uint64_t v54 = sub_10000B070("otrtimer");
          if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
          {
            LOWORD(buf[0]) = 0;
            _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "negotiation finished! clearing max retry counter", (uint8_t *)buf, 2u);
          }

          id v55 = sub_1001DCC24(v52, @"NegotiationRetryCount");
          if (!v55)
          {
            id v55 = +[NSMutableDictionary dictionary];
          }
          [v55 removeObjectForKey:v53, v144, v145];
          sub_1001FF4C0(v52, @"NegotiationRetryCount", (uint64_t)v55, 0);
        }
      }
    }
  }
  if (v38 == 2)
  {
    long long v61 = sub_10000B070("engine");
    if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "coder handled a negotiation message", (uint8_t *)buf, 2u);
    }

    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    if (MutableCopy) {
      goto LABEL_180;
    }
  }
  else if (v38 == 1)
  {
    if (MutableCopy && CFDataGetLength(MutableCopy))
    {
      id v56 = *(void **)(a1 + 72);
      sub_100203134();
      uint64_t Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        uint64_t v58 = Instance;
        CFRetain(MutableCopy);
        *(void *)(v58 + 16) = MutableCopy;
        BytePtr = CFDataGetBytePtr(MutableCopy);
        char v60 = &BytePtr[CFDataGetLength(MutableCopy)];
        uint64_t v165 = 0;
        uint64_t v171 = 0;
        ccder_decode_tag();
        if (BytePtr && !v60)
        {
LABEL_144:
          char v162 = 1;
          long long v65 = *(const void **)(a1 + 56);
          uint64_t v66 = *(void *)(*(void *)(a1 + 48) + 8);
          id v67 = *(__CFArray **)(a1 + 72);
          CFTypeRef cfa = *(void **)(a1 + 80);
          if (-[OTSOSActualAdapter sosEnabled]_0())
          {
            id v68 = sub_1000FCB54((uint64_t)cfa, v65, v67);
            if (v68)
            {
              uint64_t v160 = v58;
              v187 = 0;
              CFTypeRef v188 = 0;
              unint64_t v181 = 0;
              uint64_t v182 = (char **)&v181;
              uint64_t v183 = 0x4010000000;
              v184 = "";
              long long v185 = 0u;
              long long v186 = 0u;
              uint64_t v175 = 0;
              CFDataRef v176 = &v175;
              uint64_t v177 = 0x4010000000;
              CFDataRef v178 = "";
              long long v179 = 0u;
              long long v180 = 0u;
              uint64_t v171 = 0;
              uint64_t v172 = &v171;
              uint64_t v173 = 0x2020000000;
              char v174 = 1;
              CFArrayRef v69 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
              CFStringRef v147 = CFCopyDescription(v68);
              char v70 = *((unsigned char *)v68 + 50);
              uint64_t v165 = _NSConcreteStackBlock;
              uint64_t v166 = 3221225472;
              uint64_t v167 = sub_100102230;
              uint64_t v168 = &unk_1002FA168;
              CFDataRef v169 = &v171;
              uint64_t v170 = v67;
              if (*((unsigned char *)v172 + 24))
              {
                uint64_t v71 = cfa[2];
                buf[0] = _NSConcreteStackBlock;
                buf[1] = 3221225472;
                buf[2] = sub_100102280;
                v190 = &unk_1002FA190;
                v191[4] = v67;
                v191[5] = &v162;
                v191[6] = v68;
                v191[7] = a5;
                v191[0] = &v181;
                v191[1] = &v171;
                v191[2] = &v175;
                v191[3] = cfa;
                v191[8] = v66 + 24;
                v191[9] = v69;
                char v192 = v70;
                v193[0] = _NSConcreteStackBlock;
                v193[1] = 0x40000000;
                v193[2] = sub_100203824;
                id v194 = &unk_1003086C8;
                v195[1] = v67;
                v195[2] = v71;
                v195[0] = buf;
                BOOL v72 = sub_100203900(v58, (uint64_t)v67, (uint64_t)v193);
                if (*((unsigned char *)v172 + 24)) {
                  BOOL v73 = v72;
                }
                else {
                  BOOL v73 = 0;
                }
                *((unsigned char *)v172 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v73;
                if (!v73)
                {
                  long long v149 = 0;
                  theStringa = 0;
                  long long v112 = 0;
                  dispatch_queue_t v148 = 0;
                  CFTypeRef v153 = 0;
LABEL_239:
                  CFIndex v129 = sub_10000B070("engine");
                  if (os_log_type_enabled(v129, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v130 = v68[2];
                    uint64_t v131 = cfa[3];
                    LODWORD(v193[0]) = 138412802;
                    *(void *)((char *)v193 + 4) = v131;
                    WORD2(v193[1]) = 2112;
                    *(void *)((char *)&v193[1] + 6) = v130;
                    HIWORD(v193[2]) = 2112;
                    id v194 = (void *)v58;
                    _os_log_impl((void *)&_mh_execute_header, v129, OS_LOG_TYPE_DEFAULT, "recv %@:%@ %@", (uint8_t *)v193, 0x20u);
                  }

                  uint64_t v132 = sub_10000B070("peer");
                  if (os_log_type_enabled(v132, OS_LOG_TYPE_DEFAULT))
                  {
                    LODWORD(v193[0]) = 138412546;
                    *(void *)((char *)v193 + 4) = v147;
                    WORD2(v193[1]) = 2112;
                    *(void *)((char *)&v193[1] + 6) = v68;
                    _os_log_impl((void *)&_mh_execute_header, v132, OS_LOG_TYPE_DEFAULT, "recv %@ -> %@", (uint8_t *)v193, 0x16u);
                  }

                  if (v149) {
                    CFRelease(v149);
                  }
                  if (v112) {
                    CFRelease(v112);
                  }
                  if (v153) {
                    CFRelease(v153);
                  }
                  if (v147) {
                    CFRelease(v147);
                  }
                  if (v148) {
                    CFRelease(v148);
                  }
                  if (theStringa) {
                    CFRelease(theStringa);
                  }
                  if (v188) {
                    CFRelease(v188);
                  }
                  if (v187) {
                    CFRelease(v187);
                  }
                  CFRelease(v68);
                  BOOL v90 = *((unsigned char *)v172 + 24) != 0;
                  _Block_object_dispose(&v171, 8);
                  _Block_object_dispose(&v175, 8);
                  _Block_object_dispose(&v181, 8);
                  goto LABEL_260;
                }
                *(_OWORD *)uint64_t v163 = 0u;
                long long v164 = 0u;
                sub_1002001D4(v182 + 4);
                CFRange v74 = (uint64_t *)sub_1002010DC(*(void *)(v58 + 72));
                sub_1002004E4(v74, (uint64_t)(v182 + 4), (char **)v163);
                dispatch_queue_t v148 = (CFDataRef *)sub_100201498((uint64_t)v163, (CFTypeRef *)v67);
                CFRange v75 = v182;
                free(v182[4]);
                v75[4] = 0;
                v75[5] = 0;
                *((unsigned char *)v75 + 56) = 0;
                v75[6] = 0;
                free(v163[0]);
                v163[0] = 0;
                v163[1] = 0;
                BYTE8(v164) = 0;
                *(void *)&long long v164 = 0;
                theStringa = (CFDataRef *)sub_100201498((uint64_t)(v176 + 4), (CFTypeRef *)v67);
                CFMutableArrayRef v76 = v176;
                free((void *)v176[4]);
                v76[4] = 0;
                v76[5] = 0;
                *((unsigned char *)v76 + 56) = 0;
                v76[6] = 0;
                if (CFArrayGetCount(v69)) {
                  sub_100100734((uint64_t)cfa, a5, 2, 0, v69, (CFTypeRef *)v67);
                }
                if (v69) {
                  CFRelease(v69);
                }
                CFTypeRef v153 = sub_100100424((uint64_t)cfa, (uint64_t)v68);
                *((unsigned char *)v172 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v153 != 0;
                if (v153)
                {
                  *(void *)&long long v146 = *(void *)(v58 + 56);
                  *((void *)&v146 + 1) = *(void *)(v58 + 48);
                  long long v149 = (CFDataRef *)sub_100206794((__CFData **)v68, *((const void **)&v146 + 1));
                  CFDataRef v157 = (CFDataRef *)sub_100206794((__CFData **)v68, *(const void **)(v58 + 40));
                  if (v157)
                  {
                    id v77 = sub_10000B070("engine");
                    if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v78 = v68[2];
                      unint64_t v79 = CFDataGetLength(v157[3]);
                      CFMutableArrayRef v80 = *(void **)(v58 + 40);
                      LODWORD(v193[0]) = 138412802;
                      *(void *)((char *)v193 + 4) = v78;
                      WORD2(v193[1]) = 2048;
                      *(void *)((char *)&v193[1] + 6) = v79 / 0x14;
                      HIWORD(v193[2]) = 2112;
                      id v194 = v80;
                      _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "SOSEngineHandleMessage_locked (%@): got a confirmed manifest by digest: (%zu, %@)", (uint8_t *)v193, 0x20u);
                    }
                  }
                  else
                  {
                    uint64_t v91 = *(void *)(v58 + 64);
                    if (v91 && (unint64_t)CFDataGetLength(*(CFDataRef *)(v91 + 24)) > 0x13
                      || v148 && (unint64_t)CFDataGetLength(v148[3]) >= 0x14)
                    {
                      if (!v149 && *((void *)&v146 + 1)) {
                        goto LABEL_283;
                      }
                      id v136 = sub_10000B070("engine");
                      if (os_log_type_enabled(v136, OS_LOG_TYPE_DEFAULT))
                      {
                        CFTypeRef v158 = (CFTypeRef)v68[2];
                        if (v149) {
                          unint64_t v137 = CFDataGetLength(v149[3]) / 0x14uLL;
                        }
                        else {
                          unint64_t v137 = 0;
                        }
                        uint64_t v140 = sub_100200D6C((__CFData *)v149);
                        if (v148) {
                          unint64_t v141 = CFDataGetLength(v148[3]) / 0x14uLL;
                        }
                        else {
                          unint64_t v141 = 0;
                        }
                        unint64_t v142 = *(void *)(v58 + 64);
                        if (v142) {
                          unint64_t v142 = CFDataGetLength(*(CFDataRef *)(v142 + 24)) / 0x14uLL;
                        }
                        LODWORD(v193[0]) = 138413314;
                        *(void *)((char *)v193 + 4) = v158;
                        WORD2(v193[1]) = 2048;
                        *(void *)((char *)&v193[1] + 6) = v137;
                        HIWORD(v193[2]) = 2112;
                        id v194 = v140;
                        LOWORD(v195[0]) = 2048;
                        *(void *)((char *)v195 + 2) = v141;
                        WORD1(v195[1]) = 2048;
                        *(void *)((char *)&v195[1] + 4) = v142;
                        _os_log_impl((void *)&_mh_execute_header, v136, OS_LOG_TYPE_DEFAULT, "SOSEngineHandleMessage_locked (%@): creating a confirmed manifest via a patch (base %zu %@, +%zu, -%zu)", (uint8_t *)v193, 0x34u);
                      }

                      CFDataRef v157 = (CFDataRef *)sub_1002014F4((uint64_t)v149, *(void *)(v58 + 64), (uint64_t)v148, (CFTypeRef *)v67);
                      if (!v157)
                      {
LABEL_283:
                        uint64_t v143 = *(CFDataRef **)(v58 + 64);
                        if (v143) {
                          CFRetain(*(CFTypeRef *)(v58 + 64));
                        }
                        CFTypeRef v188 = v143;
                        if (v148) {
                          CFRetain(v148);
                        }
                        CFDataRef v157 = 0;
                        v187 = v148;
                      }
                    }
                    else if (*((void *)&v146 + 1))
                    {
                      if (v149) {
                        CFRetain(v149);
                      }
                      uint64_t v92 = sub_10000B070("SecError");
                      if (os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT))
                      {
                        uint64_t v93 = cfa[3];
                        LODWORD(v193[0]) = 138412802;
                        *(void *)((char *)v193 + 4) = v93;
                        WORD2(v193[1]) = 2112;
                        *(void *)((char *)&v193[1] + 6) = v65;
                        HIWORD(v193[2]) = 2112;
                        id v194 = v149;
                        _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_DEFAULT, "%@:%@ Protocol error send L00 - figure out later base: %@", (uint8_t *)v193, 0x20u);
                      }

                      CFDataRef v157 = v149;
                    }
                    else
                    {
                      CFDataRef v157 = 0;
                    }
                  }
                  CFMutableArrayRef v81 = sub_10000B070("engine");
                  if (os_log_type_enabled(v81, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v82 = cfa[3];
                    LODWORD(v193[0]) = 138413058;
                    *(void *)((char *)v193 + 4) = v82;
                    WORD2(v193[1]) = 2112;
                    *(void *)((char *)&v193[1] + 6) = v65;
                    HIWORD(v193[2]) = 2112;
                    id v194 = v157;
                    LOWORD(v195[0]) = 2112;
                    *(void *)((char *)v195 + 2) = v149;
                    _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_DEFAULT, "%@:%@ confirmed: %@ base: %@", (uint8_t *)v193, 0x2Au);
                  }

                  if (v157
                    && ((char v83 = sub_10020113C(v68[9], (uint64_t)v157, (uint64_t *)&v188, (const void **)&v187, (CFTypeRef *)v67), *((unsigned char *)v172 + 24))? (v84 = v83): (v84 = 0), *((unsigned char *)v172 + 24) = v84, (v85 = *(void *)(v58 + 64)) != 0))
                  {
                    unint64_t v86 = CFDataGetLength(*(CFDataRef *)(v85 + 24));
                    uint64_t v87 = v188;
                    if (v86 >= 0x14)
                    {
                      uint64_t v87 = sub_100201804((uint64_t)v188, *(CFDataRef **)(v58 + 64), (CFTypeRef *)v67);
                      if (v188) {
                        CFRelease(v188);
                      }
                      CFTypeRef v188 = v87;
                    }
                  }
                  else
                  {
                    uint64_t v87 = v188;
                  }
                  if ((!v87 || (unint64_t)CFDataGetLength(v87[3]) <= 0x13)
                    && (!v187 || (unint64_t)CFDataGetLength(v187[3]) <= 0x13)
                    && (!theStringa || (unint64_t)CFDataGetLength(theStringa[3]) < 0x14))
                  {
LABEL_224:
                    long long v111 = (CFDataRef *)v68[9];
                    long long v112 = v157;
                    if (!v157)
                    {
                      if (v111)
                      {
                        CFDataRef v123 = sub_10000B070("engine");
                        if (os_log_type_enabled(v123, OS_LOG_TYPE_DEFAULT))
                        {
                          uint64_t v124 = cfa[3];
                          LODWORD(v193[0]) = 138412802;
                          *(void *)((char *)v193 + 4) = v124;
                          WORD2(v193[1]) = 2112;
                          *(void *)((char *)&v193[1] + 6) = v68;
                          HIWORD(v193[2]) = 2112;
                          id v194 = (void *)v58;
                          _os_log_impl((void *)&_mh_execute_header, v123, OS_LOG_TYPE_DEFAULT, "%@:%@ unable to find confirmed in %@, sync protocol reset", (uint8_t *)v193, 0x20u);
                        }

                        uint64_t v125 = (const void *)v68[9];
                        long long v112 = 0;
                        if (v125)
                        {
                          CFRelease(v125);
                          v68[9] = 0;
                          long long v112 = 0;
                          uint64_t v58 = v160;
                        }
                      }
                      goto LABEL_237;
                    }
                    long long v113 = sub_10000B070("engine");
                    BOOL v114 = os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT);
                    if (v111)
                    {
                      if (v114)
                      {
                        uint64_t v115 = v68[2];
                        unint64_t v116 = CFDataGetLength(v157[3]) / 0x14uLL;
                        uint64_t v117 = sub_100200D6C((__CFData *)v157);
                        unint64_t v118 = CFDataGetLength(v111[3]) / 0x14uLL;
                        uint64_t v119 = sub_100200D6C((__CFData *)v111);
                        LODWORD(v193[0]) = 138413314;
                        *(void *)((char *)v193 + 4) = v115;
                        uint64_t v58 = v160;
                        WORD2(v193[1]) = 2048;
                        *(void *)((char *)&v193[1] + 6) = v116;
                        HIWORD(v193[2]) = 2112;
                        id v194 = v117;
                        LOWORD(v195[0]) = 2048;
                        *(void *)((char *)v195 + 2) = v118;
                        WORD1(v195[1]) = 2112;
                        *(void *)((char *)&v195[1] + 4) = v119;
                        uint64_t v120 = "SOSEngineHandleMessage_locked (%@): new confirmed manifest (%zu, %@) will replace existin"
                               "g confirmed manifest (%zu, %@)";
                        CFDataRef v121 = v113;
                        uint32_t v122 = 52;
LABEL_235:
                        _os_log_impl((void *)&_mh_execute_header, v121, OS_LOG_TYPE_DEFAULT, v120, (uint8_t *)v193, v122);
                      }
                    }
                    else if (v114)
                    {
                      uint64_t v126 = v68[2];
                      unint64_t v127 = CFDataGetLength(v157[3]) / 0x14uLL;
                      uint64_t v128 = sub_100200D6C((__CFData *)v157);
                      LODWORD(v193[0]) = 138412802;
                      *(void *)((char *)v193 + 4) = v126;
                      WORD2(v193[1]) = 2048;
                      *(void *)((char *)&v193[1] + 6) = v127;
                      uint64_t v58 = v160;
                      HIWORD(v193[2]) = 2112;
                      id v194 = v128;
                      uint64_t v120 = "SOSEngineHandleMessage_locked (%@): new confirmed manifest (%zu, %@) is first manifest for peer";
                      CFDataRef v121 = v113;
                      uint32_t v122 = 32;
                      goto LABEL_235;
                    }

                    long long v112 = v157;
                    sub_100206600((uint64_t)v68, v157);
LABEL_237:
                    if (v146 == 0) {
                      *((unsigned char *)v68 + 49) = 1;
                    }
                    goto LABEL_239;
                  }
                  uint64_t v95 = v187;
                  uint64_t v94 = v188;
                  uint64_t v96 = sub_10020167C((uint64_t)v188, (uint64_t)v153, (CFTypeRef *)v67);
                  id v97 = (const void *)v96;
                  if (v96)
                  {
                    CFTypeRef v98 = sub_100201580(v96, v94, (CFTypeRef *)v67);
                    if (v98)
                    {
                      CFRange v99 = (const void *)sub_10020167C((uint64_t)v95, (uint64_t)v153, (CFTypeRef *)v67);
                      BOOL v100 = v99 != 0;
LABEL_206:
                      long long v101 = sub_10000B070("peer");
                      if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
                      {
                        LODWORD(v193[0]) = 138413314;
                        *(void *)((char *)v193 + 4) = v68;
                        WORD2(v193[1]) = 2112;
                        *(void *)((char *)&v193[1] + 6) = v97;
                        HIWORD(v193[2]) = 2112;
                        id v194 = (void *)v98;
                        LOWORD(v195[0]) = 2112;
                        *(void *)((char *)v195 + 2) = v99;
                        WORD1(v195[1]) = 2112;
                        *(void *)((char *)&v195[1] + 4) = theStringa;
                        _os_log_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_DEFAULT, "%@ RM:%@ SR:%@ SA:%@ UR:%@", (uint8_t *)v193, 0x34u);
                      }

                      uint64_t v102 = sub_1002014F4(v68[7], (uint64_t)v99, (uint64_t)v97, (CFTypeRef *)v67);
                      uint64_t v103 = sub_1002014F4(v68[8], (uint64_t)v98, (uint64_t)theStringa, (CFTypeRef *)v67);
                      id v104 = (const void *)v68[7];
                      if (v104) {
                        CFRelease(v104);
                      }
                      v68[7] = v102;
                      long long v105 = (const void *)v68[8];
                      if (v105) {
                        CFRelease(v105);
                      }
                      v68[8] = v103;
                      if (v97) {
                        CFRelease(v97);
                      }
                      if (v98) {
                        CFRelease(v98);
                      }
                      if (v99) {
                        CFRelease(v99);
                      }
                      long long v106 = sub_10000B070("peer");
                      if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
                      {
                        id v108 = (void *)v68[8];
                        uint64_t v107 = v68[9];
                        uint64_t v109 = v68[7];
                        LODWORD(v193[0]) = 138413058;
                        *(void *)((char *)v193 + 4) = v68;
                        WORD2(v193[1]) = 2112;
                        *(void *)((char *)&v193[1] + 6) = v107;
                        HIWORD(v193[2]) = 2112;
                        id v194 = v108;
                        LOWORD(v195[0]) = 2112;
                        *(void *)((char *)v195 + 2) = v109;
                        _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_DEFAULT, "%@ C:%@ U:%@ O:%@", (uint8_t *)v193, 0x2Au);
                      }

                      uint64_t v58 = v160;
                      if (*((unsigned char *)v172 + 24)) {
                        BOOL v110 = v100;
                      }
                      else {
                        BOOL v110 = 0;
                      }
                      *((unsigned char *)v172 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v110;
                      goto LABEL_224;
                    }
                  }
                  else
                  {
                    CFTypeRef v98 = 0;
                  }
                  CFRange v99 = 0;
                  BOOL v100 = 0;
                  goto LABEL_206;
                }
                long long v149 = 0;
                long long v112 = 0;
              }
              else
              {
                long long v149 = 0;
                theStringa = 0;
                long long v112 = 0;
                dispatch_queue_t v148 = 0;
              }
              CFTypeRef v153 = 0;
              goto LABEL_239;
            }
          }
          else
          {
            SOSCCSetSOSDisabledError();
          }
          BOOL v90 = 0;
LABEL_260:
          *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v90;
          CFRelease((CFTypeRef)v58);
          if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
          {
            uint64_t v133 = sub_10000B070("engine");
            if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v134 = *(void *)(a1 + 56);
              id v135 = *(void **)(a1 + 72);
              if (v135) {
                id v135 = (void *)*v135;
              }
              LODWORD(buf[0]) = 138412546;
              *(void *)((char *)buf + 4) = v134;
              WORD2(buf[1]) = 2112;
              *(void *)((char *)&buf[1] + 6) = v135;
              _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "Failed to handle message from peer %@: %@", (uint8_t *)buf, 0x16u);
            }
          }
LABEL_180:
          CFRelease(MutableCopy);
          goto LABEL_181;
        }
        if (v56 && !*v56) {
          SOSErrorCreate();
        }
        CFRelease((CFTypeRef)v58);
      }
      else
      {
        unsigned int v64 = SOSErrorCreate();
        if (v64)
        {
          uint64_t v58 = v64;
          goto LABEL_144;
        }
      }
    }
    uint64_t v88 = sub_10000B070("engine");
    if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v89 = *(void **)(a1 + 72);
      if (v89) {
        __int16 v89 = (void *)*v89;
      }
      LODWORD(buf[0]) = 138412290;
      *(void *)((char *)buf + 4) = v89;
      _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "Failed to turn a data gram into an SOSMessage: %@", (uint8_t *)buf, 0xCu);
    }

    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = SOSErrorCreate();
    if (MutableCopy) {
      goto LABEL_180;
    }
  }
  else
  {
    long long v62 = sub_10000B070("engine");
    if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
    {
      long long v63 = *(void **)(a1 + 72);
      if (v63) {
        long long v63 = (void *)*v63;
      }
      LODWORD(buf[0]) = 67109378;
      HIDWORD(buf[0]) = v38;
      LOWORD(buf[1]) = 2112;
      *(void *)((char *)&buf[1] + 2) = v63;
      _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "coder handled a error message: %d (error: %@)", (uint8_t *)buf, 0x12u);
    }

    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
    if (MutableCopy) {
      goto LABEL_180;
    }
  }
LABEL_181:
}

void sub_100219418(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
}

os_state_data_s *__cdecl sub_100219BE4(id a1, os_state_hints_s *a2)
{
  if (a2->var2 != 3) {
    return 0;
  }
  CFDataRef v8 = (const __CFData *)sub_100219C98((uint64_t)a1, (int)a2, v2, v3, v4, v5, v6, v7);
  if (!v8) {
    return 0;
  }
  CFDataRef v9 = v8;
  size_t Length = CFDataGetLength(v8);
  uint64_t v11 = (os_state_data_s *)malloc_type_calloc(1uLL, Length + 200, 0xDFB1CB89uLL);
  int v12 = v11;
  if (v11)
  {
    v11->var0 = 2;
    BytePtr = CFDataGetBytePtr(v9);
    memcpy(v12->var4, BytePtr, Length);
    v12->var1.var1 = Length;
    __strlcpy_chk();
  }
  CFRelease(v9);
  return v12;
}

uint64_t sub_100219C98(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  CFTypeRef cf = 0;
  CFDictionaryRef v8 = sub_100219E68(1, a2, a3, a4, a5, a6, a7, a8);
  *(void *)uint64_t result = 0;
  OSStatus v9 = SecItemCopyMatching(v8, (CFTypeRef *)result);
  if (v8) {
    CFRelease(v8);
  }
  if (v9)
  {
    sub_100012A40(v9, (__CFString **)&cf, @"Error %@ reading for service '%@'", *(void *)result, @"iCloud Keychain Account Meta-data");
  }
  else
  {
    if (*(void *)result)
    {
      CFTypeID v10 = CFGetTypeID(*(CFTypeRef *)result);
      if (v10 == CFDataGetTypeID())
      {
        uint64_t v11 = *(void *)result;
        if (*(void *)result) {
          goto LABEL_17;
        }
        goto LABEL_12;
      }
    }
    SOSCreateErrorWithFormat();
  }
  int v12 = *(const void **)result;
  if (*(void *)result)
  {
    *(void *)uint64_t result = 0;
    CFRelease(v12);
  }
LABEL_12:
  CFMutableDataRef v13 = sub_10000B070("account");
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t result = 138412290;
    *(void *)&result[4] = cf;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Failed to load account: %@", result, 0xCu);
  }

  CFMutableDataRef v14 = sub_10000B070("SecError");
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t result = 138412290;
    *(void *)&result[4] = cf;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Failed to load account: %@", result, 0xCu);
  }

  uint64_t v11 = 0;
LABEL_17:
  CFTypeRef v15 = cf;
  if (cf)
  {
    CFTypeRef cf = 0;
    CFRelease(v15);
  }
  return v11;
}

CFDictionaryRef sub_100219E68(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  return sub_100139704(kCFAllocatorDefault, a2, a3, a4, a5, a6, a7, a8, (uint64_t)kSecClass, (uint64_t)kSecClassGenericPassword);
}

void sub_100219F18(uint64_t a1, const void *a2, const void *a3)
{
}

uint64_t sub_100219F20(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void sub_100219F3C(id a1)
{
  if (!qword_10035D430)
  {
    CFDictionaryRef v1 = (const __CFDictionary *)_CFCopySystemVersionDictionary();
    if (v1)
    {
      CFDictionaryRef v2 = v1;
      CFArrayRef Value = CFDictionaryGetValue(v1, _kCFSystemVersionBuildVersionKey);
      if (Value)
      {
        int v4 = Value;
        CFTypeID v5 = CFGetTypeID(Value);
        if (v5 == CFStringGetTypeID())
        {
          CFRetain(v4);
          qword_10035D430 = (uint64_t)v4;
        }
      }
      CFRelease(v2);
    }
    if (!qword_10035D430) {
      qword_10035D430 = @"Unknown model";
    }
  }
}

id sub_10021A4D0(int a1)
{
  if (qword_10035D088 != -1) {
    dispatch_once(&qword_10035D088, &stru_100303A98);
  }
  if (byte_10035BC68)
  {
    if (a1)
    {
      [(id)qword_10035D460 setSosCompatibilityMode:-[OTSOSActualAdapter sosEnabled]_0()];
    }
    else if (qword_10035D468 != -1)
    {
      dispatch_once(&qword_10035D468, &stru_1003095D8);
    }
    id v2 = (id)qword_10035D460;
  }
  else
  {
    id v2 = 0;
  }

  return v2;
}

void sub_10021A588(id a1)
{
  dispatch_get_global_queue(-2, 0);
  CFDictionaryRef v1 = (id)objc_claimAutoreleasedReturnValue();
  if (qword_10035D088 != -1) {
    dispatch_once(&qword_10035D088, &stru_100303A98);
  }
  if (!byte_10035BC68)
  {

    goto LABEL_16;
  }
  memset(&context, 0, sizeof(context));
  id v2 = SCDynamicStoreCreate(0, @"com.apple.securityd.cloudcircleserver", (SCDynamicStoreCallBack)sub_10021C65C, &context);
  ComputerCFTypeRef Name = (void *)SCDynamicStoreKeyCreateComputerName(0);
  values = ComputerName;
  if (v2 && ComputerName)
  {
    CFArrayRef v4 = CFArrayCreate(0, (const void **)&values, 1, &kCFTypeArrayCallBacks);
    if (v4)
    {
      CFDictionaryRef v5 = sub_10021A834(v2);
      SCDynamicStoreSetNotificationKeys(v2, v4, 0);
      SCDynamicStoreSetDispatchQueue(v2, v1);
    }
    else
    {
      CFDictionaryRef v5 = 0;
    }
  }
  else
  {
    CFDictionaryRef v5 = 0;
    CFArrayRef v4 = 0;
    CFDictionaryRef v6 = 0;
    CFArrayRef v7 = 0;
    if (!v2)
    {
      if (!ComputerName) {
        goto LABEL_12;
      }
      goto LABEL_11;
    }
  }
  CFRelease(v2);
  ComputerCFTypeRef Name = values;
  CFDictionaryRef v6 = v5;
  CFArrayRef v7 = v4;
  if (values) {
LABEL_11:
  }
    CFRelease(ComputerName);
LABEL_12:
  if (v7) {
    CFRelease(v7);
  }

  if (v6)
  {
    uint64_t v15 = sub_10021A9A4((uint64_t)v6, v8, v9, v10, v11, v12, v13, v14);
    uint64_t v16 = (void *)qword_10035D470;
    qword_10035D470 = v15;

    sub_1001E565C((void *)qword_10035D470, &stru_100309618);
    SOSCloudKeychainSetItemsChangedBlock();
    CFRelease(v6);
    goto LABEL_19;
  }
LABEL_16:
  double v17 = sub_10000B070("SecError");
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(context.version) = 0;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Didn't get machine gestalt! This is going to be ugly.", (uint8_t *)&context, 2u);
  }

  uint64_t v25 = sub_10021A9A4(0, v18, v19, v20, v21, v22, v23, v24);
  uint64_t v26 = (void *)qword_10035D470;
  qword_10035D470 = v25;

  sub_1001E565C((void *)qword_10035D470, &stru_100309618);
  SOSCloudKeychainSetItemsChangedBlock();
LABEL_19:
  [(id)qword_10035D470 setSaveBlock:&stru_1003096C0];
  SOSCloudKeychainRequestEnsurePeerRegistration();

  int v27 = dispatch_get_global_queue(0, 0);
  os_state_add_handler();

  [(id)qword_10035D470 ghostBustSchedule];
  [(id)qword_10035D470 setSosCompatibilityMode:-[OTSOSActualAdapter sosEnabled]_0()];
  objc_storeStrong((id *)&qword_10035D460, (id)qword_10035D470);
}

CFDictionaryRef sub_10021A834(const __SCDynamicStore *a1)
{
  if (qword_10035D478 != -1) {
    dispatch_once(&qword_10035D478, &stru_100309700);
  }
  CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, (CFStringRef)qword_10035D438);
  CFStringRef v3 = SCDynamicStoreCopyComputerName(a1, 0);
  if (v3) {
    CFStringRef v4 = v3;
  }
  else {
    CFStringRef v4 = @"Unknown name";
  }
  if (qword_10035D440 != -1) {
    dispatch_once(&qword_10035D440, &stru_100308F30);
  }
  CFDictionaryRef v5 = (const void *)qword_10035D430;
  if (qword_10035D430) {
    CFRetain((CFTypeRef)qword_10035D430);
  }
  int valuePtr = 0;
  CFNumberRef v6 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
  CFDictionaryRef v14 = sub_100139704(kCFAllocatorDefault, v7, v8, v9, v10, v11, v12, v13, kPIUserDefinedDeviceNameKey, (uint64_t)v4);
  if (v5) {
    CFRelease(v5);
  }
  if (Copy) {
    CFRelease(Copy);
  }
  CFRelease(v4);
  if (v6) {
    CFRelease(v6);
  }
  return v14;
}

id sub_10021A9A4(uint64_t a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8)
{
  int v9 = (const void *)sub_100219C98(a1, a2, a3, a4, a5, a6, a7, a8);
  uint64_t v10 = sub_10000CF0C(0);
  uint64_t v11 = sub_100134054(v10);
  if (v11)
  {
    uint64_t v12 = v11;
    if (v9)
    {
      id v19 = 0;
      int v13 = +[SOSAccount accountFromData:v9 factory:v11 error:&v19];
      id v14 = v19;
      if (v13)
      {
        uint64_t v15 = [v13 trust];
        [v15 updateGestalt:v13 newGestalt:a1];

        CFRelease(v9);
LABEL_12:
        [v13 sosEvaluateIfNeeded];
        [v13 startStateMachine];
        goto LABEL_13;
      }
      uint64_t v16 = sub_10000B070("account");
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v21 = v14;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Got error inflating account: %@", buf, 0xCu);
      }

      CFRelease(v9);
    }
    int v13 = sub_1001E5360(a1, v12);
    if (!v13)
    {
      double v17 = sub_10000B070("account");
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Got NULL creating account", buf, 2u);
      }

      int v13 = 0;
    }
    goto LABEL_12;
  }
  if (v9) {
    CFRelease(v9);
  }
  int v13 = 0;
LABEL_13:

  return v13;
}

void sub_10021AB90(id a1, __CFData *a2, __CFError *a3)
{
  if (a2)
  {
    CFTypeRef cf = 0;
    if (!qword_10035D480 || !CFEqual((CFTypeRef)qword_10035D480, a2))
    {
      uint64_t v9 = kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate;
      CFDictionaryRef v10 = sub_100219E68(0, (int)a2, (int)a3, v3, v4, v5, v6, v7);
      uint64_t v25 = v9;
      CFDictionaryRef v18 = sub_100139704(kCFAllocatorDefault, v11, v12, v13, v14, v15, v16, v17, (uint64_t)kSecValueData, (uint64_t)a2);
      OSStatus v19 = SecItemUpdate(v10, v18);
      if (v19 == -25300)
      {
        MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v10);
        *(void *)&long long context = _NSConcreteStackBlock;
        *((void *)&context + 1) = 3221225472;
        id v28 = sub_100219F18;
        CFStringRef v29 = &unk_100308F10;
        CFDictionaryRef v30 = MutableCopy;
        CFDictionaryApplyFunction(v18, (CFDictionaryApplierFunction)sub_100219F20, &context);
        OSStatus v19 = SecItemAdd(MutableCopy, 0);
        if (MutableCopy) {
          CFRelease(MutableCopy);
        }
      }
      if (v10) {
        CFRelease(v10);
      }
      if (v18) {
        CFRelease(v18);
      }
      if (sub_100012A40(v19, (__CFString **)&cf, @"Error saving %@ to service '%@'", a2, @"iCloud Keychain Account Meta-data", kSecAttrAccessible, v25, 0))
      {
        CFRetain(a2);
        if (qword_10035D480) {
          CFRelease((CFTypeRef)qword_10035D480);
        }
        qword_10035D480 = (uint64_t)a2;
      }
      else
      {
        int v23 = sub_10000B070("SecError");
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(context) = 138412290;
          *(void *)((char *)&context + 4) = cf;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Can't save account: %@", (uint8_t *)&context, 0xCu);
        }
      }
    }
    CFTypeRef v24 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v24);
    }
  }
  else
  {
    int v22 = sub_10000B070("SecError");
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(context) = 138412290;
      *(void *)((char *)&context + 4) = a3;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Failed to transform account into data, error: %@", (uint8_t *)&context, 0xCu);
    }
  }
}

__CFArray *__cdecl sub_10021AE3C(id a1, __CFDictionary *a2)
{
  if (a2) {
    CFRetain(a2);
  }
  uint64_t v6 = 0;
  int v7 = &v6;
  uint64_t v8 = 0x2020000000;
  uint64_t v9 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_10021AF18;
  void v5[3] = &unk_100309680;
  void v5[4] = &v6;
  void v5[5] = a2;
  sub_10021BA54(v5);
  if (a2) {
    CFRelease(a2);
  }
  int v3 = (__CFArray *)v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_10021AEFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10021AF18(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = (const void *)SOSItemsChangedCopyDescription();
  if (v4) {
    CFRelease(v4);
  }
  CFTypeRef v46 = 0;
  CFDictionaryRef theDict = *(const __CFDictionary **)(a1 + 40);
  uint64_t v61 = 0;
  long long v62 = &v61;
  uint64_t v63 = 0x3032000000;
  unsigned int v64 = sub_10020DA9C;
  long long v65 = sub_10020DAAC;
  id v66 = (id)0xAAAAAAAAAAAAAAAALL;
  id v45 = v3;
  id v66 = [v45 account];
  if (-[OTSOSActualAdapter sosEnabled]_0())
  {
    CFArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    id value = 0;
    uint64_t v6 = (const void *)kSOSKVSAccountChangedKey;
    if (CFDictionaryGetValueIfPresent(theDict, kSOSKVSAccountChangedKey, (const void **)&value))
    {
      int v7 = sub_10000B070("accountChange");
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "SOSTransportDispatchMessages received kSOSKVSAccountChangedKey", (uint8_t *)&buf, 2u);
      }

      if (value)
      {
        CFTypeID v8 = CFGetTypeID(value);
        if (v8 == CFBooleanGetTypeID())
        {
          if (CFBooleanGetValue((CFBooleanRef)value))
          {
            uint64_t v9 = [v45 account];
            sub_1001E4DD0(v9);

            CFDictionaryRef v10 = [v45 account];
            [v10 setAccountIsChanging:1];

            int v11 = [v45 account];
            [v11 setKey_interests_need_updating:1];
          }
        }
      }
      CFArrayAppendValue(Mutable, v6);
    }
    CFDictionaryRef v12 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionaryRef v13 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionaryRef v14 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionaryRef v15 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionaryRef v16 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFMutableDictionaryRef cf = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    uint64_t v56 = 0;
    uint64_t v57 = &v56;
    uint64_t v58 = 0x2020000000;
    uint64_t v59 = 0;
    uint64_t v52 = 0;
    id v53 = &v52;
    uint64_t v54 = 0x2020000000;
    char v55 = 0;
    unsigned __int8 v17 = [(id)v62[5] SOSMonitorModeSOSIsActive];
    *(void *)&long long buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 3221225472;
    char v70 = sub_10020DAB4;
    uint64_t v71 = &unk_100308B50;
    unsigned __int8 v80 = v17;
    BOOL v72 = &v52;
    BOOL v73 = &v56;
    CFDictionaryRef v74 = v13;
    CFDictionaryRef v75 = v12;
    CFDictionaryRef v76 = v14;
    CFDictionaryRef v77 = v15;
    CFDictionaryRef v78 = v16;
    unint64_t v79 = &v46;
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)sub_10020EC88, &buf);
    if (v57[3])
    {
      CFArrayRef v18 = (const __CFArray *)sub_10020C6EC();
      v51[0] = _NSConcreteStackBlock;
      v51[1] = 3221225472;
      void v51[2] = sub_10020DE50;
      v51[3] = &unk_100308B78;
      v51[4] = &v61;
      v51[5] = &v56;
      OSStatus v19 = v51;
      v85.size_t length = CFArrayGetCount(v18);
      v85.id location = 0;
      CFArrayApplyFunction(v18, v85, (CFArrayApplierFunction)sub_10020C5FC, v19);

      CFArrayAppendValue(Mutable, kSOSKVSKeyParametersKey);
      int v20 = (const void *)v57[3];
      if (v20)
      {
        v57[3] = 0;
        CFRelease(v20);
      }
    }
    if (*((unsigned char *)v53 + 24)) {
      CFArrayAppendValue(Mutable, kSOSKVSInitialSyncKey);
    }
    if (CFDictionaryGetCount(v16))
    {
      CFStringRef v21 = (const __CFString *)CFDictionaryGetValue(v16, @"Scope");
      CFStringRef v22 = v21;
      if (v21)
      {
        CFTypeID v23 = CFGetTypeID(v21);
        if (v23 == CFStringGetTypeID())
        {
          sub_10002577C(v22, 4);
        }
        else
        {
          CFTypeID v25 = CFGetTypeID(v22);
          if (v25 == CFDictionaryGetTypeID()) {
            sub_1000250A8((const __CFDictionary *)v22, 4);
          }
        }
      }
      uint64_t v26 = (const void *)SOSDebugInfoKeyCreateWithTypeName();
      CFArrayAppendValue(Mutable, v26);
      if (v26) {
        CFRelease(v26);
      }
    }
    if (CFDictionaryGetCount(v14))
    {
      CFArrayRef v27 = (const __CFArray *)sub_10020C7C4();
      v50[0] = _NSConcreteStackBlock;
      v50[1] = 3221225472;
      void v50[2] = sub_10020DF5C;
      v50[3] = &unk_100308BA0;
      v50[4] = &v61;
      void v50[5] = v14;
      v50[6] = &v46;
      v50[7] = Mutable;
      id v28 = v50;
      v86.size_t length = CFArrayGetCount(v27);
      v86.id location = 0;
      CFArrayApplyFunction(v27, v86, (CFArrayApplierFunction)sub_10020C5FC, v28);
    }
    if (CFDictionaryGetCount(v12))
    {
      CFArrayRef v29 = (const __CFArray *)sub_10020C614();
      v49[0] = _NSConcreteStackBlock;
      v49[1] = 3221225472;
      void v49[2] = sub_10020E0C8;
      v49[3] = &unk_100308BC8;
      uint8_t v49[4] = &v61;
      v49[5] = v12;
      v49[6] = Mutable;
      CFDictionaryRef v30 = v49;
      v87.size_t length = CFArrayGetCount(v29);
      v87.id location = 0;
      CFArrayApplyFunction(v29, v87, (CFArrayApplierFunction)sub_10020C5FC, v30);
    }
    if (CFDictionaryGetCount(v13))
    {
      CFArrayRef v31 = (const __CFArray *)sub_10020C7C4();
      v48[0] = _NSConcreteStackBlock;
      v48[1] = 3221225472;
      void v48[2] = sub_10020E334;
      void v48[3] = &unk_100308BA0;
      v48[4] = &v61;
      v48[5] = v13;
      v48[6] = &v46;
      void v48[7] = Mutable;
      BOOL v32 = v48;
      v88.size_t length = CFArrayGetCount(v31);
      v88.id location = 0;
      CFArrayApplyFunction(v31, v88, (CFArrayApplierFunction)sub_10020C5FC, v32);
    }
    if (CFDictionaryGetCount(v15))
    {
      CFArrayRef v33 = (const __CFArray *)sub_10020C7C4();
      v47[0] = _NSConcreteStackBlock;
      v47[1] = 3221225472;
      v47[2] = sub_10020E5A8;
      void v47[3] = &unk_100308BA0;
      void v47[4] = &v61;
      v47[5] = v15;
      v47[6] = &v46;
      v47[7] = Mutable;
      uint64_t v34 = v47;
      v89.size_t length = CFArrayGetCount(v33);
      v89.id location = 0;
      CFArrayApplyFunction(v33, v89, (CFArrayApplierFunction)sub_10020C5FC, v34);
    }
    if (v14) {
      CFRelease(v14);
    }
    if (v13) {
      CFRelease(v13);
    }
    if (v12) {
      CFRelease(v12);
    }
    if (v16) {
      CFRelease(v16);
    }
    if (v15) {
      CFRelease(v15);
    }
    if (cf) {
      CFRelease(cf);
    }
    CFMutableStringRef v35 = CFStringCreateMutable(kCFAllocatorDefault, 0);
    CFMutableStringRef v36 = CFStringCreateMutable(kCFAllocatorDefault, 0);
    context[0] = _NSConcreteStackBlock;
    context[1] = 3221225472;
    context[2] = sub_10020E7AC;
    context[3] = &unk_100308F10;
    void context[4] = v35;
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)sub_10020EC88, context);
    v67[0] = _NSConcreteStackBlock;
    v67[1] = 3221225472;
    void v67[2] = sub_10020E814;
    v67[3] = &unk_100309D30;
    v67[4] = v36;
    v90.size_t length = CFArrayGetCount(Mutable);
    v90.id location = 0;
    CFArrayApplyFunction(Mutable, v90, (CFArrayApplierFunction)sub_10020C5FC, v67);
    id v37 = sub_10000B070("updates");
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
    {
      CFIndex Count = CFDictionaryGetCount(theDict);
      *(_DWORD *)CFMutableArrayRef v81 = 134218242;
      CFIndex v82 = Count;
      __int16 v83 = 2112;
      CFMutableStringRef v84 = v35;
      _os_log_debug_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEBUG, "Updates [%ld]: %@", v81, 0x16u);
    }

    int v38 = sub_10000B070("updates");
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
    {
      CFIndex v42 = CFArrayGetCount(Mutable);
      *(_DWORD *)CFMutableArrayRef v81 = 134218242;
      CFIndex v82 = v42;
      __int16 v83 = 2112;
      CFMutableStringRef v84 = v36;
      _os_log_debug_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEBUG, "Handled [%ld]: %@", v81, 0x16u);
    }

    if (v35) {
      CFRelease(v35);
    }
    if (v36) {
      CFRelease(v36);
    }
    _Block_object_dispose(&v52, 8);
    _Block_object_dispose(&v56, 8);
  }
  else
  {
    CFTypeRef v24 = sub_10000B070("nosos");
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "transport received a message for sos but the system is off", (uint8_t *)&buf, 2u);
    }

    CFArrayRef Mutable = 0;
  }
  _Block_object_dispose(&v61, 8);

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = Mutable;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) || v46)
  {
    uint64_t v39 = sub_10000B070("SecError");
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v46;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "Error handling updates: %@", (uint8_t *)&buf, 0xCu);
    }

    CFTypeRef v40 = v46;
    if (v46)
    {
      CFTypeRef v46 = 0;
      CFRelease(v40);
    }
  }
}

void sub_10021B9C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59)
{
}

void sub_10021BA54(void *a1)
{
  id v1 = a1;
  id v3 = sub_10021A4D0(0);
  if (v3)
  {
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472;
    _DWORD v4[2] = sub_10021BB14;
    void v4[3] = &unk_1003097A0;
    id v5 = v1;
    [v3 performTransaction:v4];
  }
}

uint64_t sub_10021BB14(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10021BB24(id a1, SOSAccount *a2, __OpaqueSOSCircle *a3, __CFSet *a4, __CFSet *a5, __CFSet *a6, __CFSet *a7)
{
  int v11 = a2;
  CFDictionaryRef v12 = [(SOSAccount *)v11 peerInfo];
  if (!v12)
  {
    unsigned __int8 v17 = sub_10000B070("circleOps");
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)long long buf = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "Change block called with no peerInfo", buf, 2u);
    }
    goto LABEL_9;
  }
  CFDictionaryRef v13 = v12;
  if ((SOSCircleHasPeer() & 1) == 0)
  {
    unsigned __int8 v17 = sub_10000B070("circleOps");
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)long long buf = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, "Change block called while not in circle", buf, 2u);
    }
LABEL_9:

    goto LABEL_35;
  }
  CFIndex Count = CFSetGetCount(a4);
  CFDictionaryRef v15 = sub_10000B070("updates");
  CFDictionaryRef v16 = v15;
  if (Count)
  {
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Requesting Ensure Peer Registration.", buf, 2u);
    }

    CFDictionaryRef v16 = dispatch_get_global_queue(-2, 0);
    SOSCloudKeychainRequestEnsurePeerRegistration();
  }
  else if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)long long buf = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "Not requesting Ensure Peer Registration, since it's not needed", buf, 2u);
  }

  if (CFSetContainsValue(a4, v13))
  {
    CFArrayRef v18 = (__CFSet *)SOSCircleCopyPeers();
    CFSetRemoveValue(v18, v13);
    if (CFSetGetCount(v18)) {
      sub_10021C018(v18);
    }
    if (v18) {
      CFRelease(v18);
    }
  }
  if (CFSetGetCount(a4) || CFSetGetCount(a5) || CFSetGetCount(a6) || CFSetGetCount(a7))
  {
    if (CFSetGetCount(a5))
    {
      CFTypeRef cf = 0;
      CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      v27[0] = _NSConcreteStackBlock;
      v27[1] = 3221225472;
      v27[2] = sub_10021C134;
      v27[3] = &unk_100309D30;
      void v27[4] = Mutable;
      CFSetApplyFunction(a5, (CFSetApplierFunction)sub_10021C13C, v27);
      int v20 = v11;
      v29[0] = 0;
      v29[1] = v29;
      v29[2] = 0x2020000000;
      char v30 = 1;
      [(SOSAccount *)v20 fullPeerInfo];
      uint64_t PeerInfo = SOSFullPeerInfoGetPeerInfo();
      CFSetRef PermittedViews = (const __CFSet *)SOSPeerInfoGetPermittedViews();
      *(void *)long long buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 3221225472;
      *(void *)&uint8_t buf[16] = sub_1001EA860;
      BOOL v32 = &unk_100307AE8;
      uint64_t v35 = PeerInfo;
      CFTypeID v23 = v20;
      CFArrayRef v33 = v23;
      uint64_t v34 = v29;
      CFMutableArrayRef v36 = Mutable;
      p_CFTypeRef cf = &cf;
      CFSetApplyFunction(PermittedViews, (CFSetApplierFunction)sub_1001E9CE0, buf);

      _Block_object_dispose(v29, 8);
      if (cf)
      {
        CFTypeRef v24 = sub_10000B070("SecError");
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412546;
          *(void *)&uint8_t buf[4] = Mutable;
          *(_WORD *)&unsigned char buf[12] = 2112;
          *(void *)&buf[14] = cf;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Had trouble removing: %@, error: %@", buf, 0x16u);
        }

        CFTypeRef v25 = cf;
        if (cf)
        {
          CFTypeRef cf = 0;
          CFRelease(v25);
        }
      }
      if (Mutable) {
        CFRelease(Mutable);
      }
    }
    uint64_t v26 = sub_10000B070("circleOps");
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "peer counts changed, posting kSOSCCCircleChangedNotification", buf, 2u);
    }

    [(SOSAccount *)v11 setNotifyCircleChangeOnExit:1];
  }
LABEL_35:
}

void sub_10021BFF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10021C018(const __CFSet *a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_10021C154;
  v3[3] = &unk_100309D30;
  void v3[4] = Mutable;
  CFSetApplyFunction(a1, (CFSetApplierFunction)sub_10021C13C, v3);
  activity_block[0] = _NSConcreteStackBlock;
  activity_block[1] = 3221225472;
  activity_block[2] = sub_10021C2D0;
  activity_block[3] = &unk_1003093A8;
  activity_void block[4] = Mutable;
  _os_activity_initiate((void *)&_mh_execute_header, "CloudCircle RequestSyncWithPeersList", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  if (Mutable) {
    CFRelease(Mutable);
  }
}

void sub_10021C134(uint64_t a1, const void *a2)
{
}

uint64_t sub_10021C13C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_10021C154(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID())
    {
      id v5 = *(__CFArray **)(a1 + 32);
      CFTypeRef PeerID = cf;
LABEL_6:
      CFArrayAppendValue(v5, PeerID);
      return;
    }
    CFTypeID v7 = CFGetTypeID(cf);
    if (v7 == SOSPeerInfoGetTypeID())
    {
      CFGetTypeID(cf);
      SOSPeerInfoGetTypeID();
      CFTypeID v8 = *(__CFArray **)(a1 + 32);
      CFTypeRef PeerID = (CFTypeRef)SOSPeerInfoGetPeerID();
      id v5 = v8;
      goto LABEL_6;
    }
  }
  uint64_t v9 = sub_10000B070("SecError");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = 138412290;
    CFTypeRef v11 = cf;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Bad element, skipping: %@", (uint8_t *)&v10, 0xCu);
  }
}

void sub_10021C2D0(uint64_t a1)
{
  id v2 = _OctagonSignpostLogSystem();
  os_signpost_id_t v3 = _OctagonSignpostCreate();

  CFTypeID v4 = _OctagonSignpostLogSystem();
  id v5 = v4;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v4))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "SOSCCRequestSyncWithPeersList", " enableTelemetry=YES ", buf, 2u);
  }

  uint64_t v6 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v21 = v3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCRequestSyncWithPeersList  enableTelemetry=YES ", buf, 0xCu);
  }

  CFArrayRef v14 = sub_100146438(kCFAllocatorDefault, v7, v8, v9, v10, v11, v12, v13, 0);
  sub_10002595C(*(const __CFArray **)(a1 + 32), @"[", @"]", (uint64_t)&stru_100309388);
  CFDictionaryRef v15 = dispatch_get_global_queue(-32768, 0);
  SOSCloudKeychainRequestSyncWithPeers();

  if (v14) {
    CFRelease(v14);
  }
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  unsigned __int8 v17 = _OctagonSignpostLogSystem();
  CFArrayRef v18 = v17;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v17))
  {
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v21) = 1;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v18, OS_SIGNPOST_INTERVAL_END, v3, "SOSCCRequestSyncWithPeersList", " SOSSignpostNameSOSCCRequestSyncWithPeersList=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCRequestSyncWithPeersList}d ", buf, 8u);
  }

  OSStatus v19 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218496;
    os_signpost_id_t v21 = v3;
    __int16 v22 = 2048;
    double v23 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v24 = 1026;
    int v25 = 1;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCRequestSyncWithPeersList  SOSSignpostNameSOSCCRequestSyncWithPeersList=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCRequestSyncWithPeersList}d ", buf, 0x1Cu);
  }
}

void sub_10021C564(id a1, __CFString *a2)
{
  os_signpost_id_t v3 = sub_10000B070("syncwith");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    id v5 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Request Sync With: %@", (uint8_t *)&v4, 0xCu);
  }
}

void sub_10021C610(id a1)
{
  if (!qword_10035D438)
  {
    uint64_t v1 = MGCopyAnswer();
    CFStringRef v2 = @"Unknown model";
    if (v1) {
      CFStringRef v2 = (const __CFString *)v1;
    }
    qword_10035D438 = (uint64_t)v2;
  }
}

void sub_10021C65C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_10021C6CC;
  v3[3] = &unk_1003096E0;
  void v3[4] = a1;
  void v3[5] = a2;
  v3[6] = a3;
  sub_10021BA54(v3);
}

void sub_10021C6CC(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = [v3 account];

  if (v4)
  {
    CFDictionaryRef v5 = sub_10021A834(*(const __SCDynamicStore **)(a1 + 32));
    uint64_t v6 = [v3 account];
    uint64_t v7 = [v6 trust];
    uint64_t v8 = [v3 account];
    unsigned int v9 = [v7 updateGestalt:v8 newGestalt:v5];

    if (v9)
    {
      uint64_t v10 = sub_10000B070("circleOps");
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)uint64_t v11 = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Changed our peer's gestalt information.  This is not a circle change.", v11, 2u);
      }
    }
    if (v5) {
      CFRelease(v5);
    }
  }
}

void *sub_10021C7D8()
{
  id v0 = sub_10021A4D0(1);
  if (!v0)
  {
    uint64_t v1 = sub_10000B070("secAccount");
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v3 = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Failed request for account object", v3, 2u);
    }
  }
  return v0;
}

uint64_t sub_10021C864()
{
  id v0 = sub_10000B070("SOSMonitorMode");
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_DEFAULT, "Checking OT View Handling to match", buf, 2u);
  }

  uint64_t v1 = +[OTManager manager];
  uint64_t v21 = 0;
  __int16 v22 = &v21;
  uint64_t v23 = 0x2020000000;
  int v24 = -1;
  if (v1)
  {
    dispatch_semaphore_t v2 = dispatch_semaphore_create(0);
    id v3 = objc_alloc_init((Class)OTControlArguments);
    *(void *)long long buf = _NSConcreteStackBlock;
    uint64_t v16 = 3221225472;
    unsigned __int8 v17 = sub_10021CBB4;
    CFArrayRef v18 = &unk_100309728;
    int v20 = &v21;
    int v4 = v2;
    OSStatus v19 = v4;
    [v1 fetchUserControllableViewsSyncStatus:v3 reply:buf];

    dispatch_time_t v5 = dispatch_time(0, 10000000000);
    if (dispatch_semaphore_wait(v4, v5))
    {
      uint64_t v6 = sub_10000B070("SOSMonitorMode");
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)CFArrayRef v14 = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Timed out waiting for OTM", v14, 2u);
      }

      *((_DWORD *)v22 + 6) = -1;
    }

    int v7 = *((_DWORD *)v22 + 6);
  }
  else
  {
    uint64_t v8 = sub_10000B070("SOSMonitorMode");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Can't get OTManager to check view status", buf, 2u);
    }

    int v7 = -1;
    *((_DWORD *)v22 + 6) = -1;
  }
  _Block_object_dispose(&v21, 8);

  if (v7 == -1)
  {
    unsigned int v9 = sub_10000B070("SOSMonitorMode");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Failed to get OT view status", buf, 2u);
    }
    uint64_t v10 = 0;
  }
  else
  {
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472;
    _DWORD v12[2] = sub_10021CCEC;
    v12[3] = &unk_100308F90;
    int v13 = v7;
    if (!sub_10021CD84(0, v12)) {
      return 1;
    }
    unsigned int v9 = sub_10000B070("SOSMonitorMode");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Changed User Visible View status", buf, 2u);
    }
    uint64_t v10 = 1;
  }

  return v10;
}

void sub_10021CB9C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_10021CBB4(uint64_t a1, int a2, void *a3)
{
  dispatch_time_t v5 = a3;
  uint64_t v6 = sub_10000B070("SOSMonitorMode");
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (v7)
    {
      int v9 = 138412290;
      CFStringRef v10 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "fetching user-controllable-sync status errored: %@", (uint8_t *)&v9, 0xCu);
    }

    a2 = -1;
  }
  else
  {
    if (v7)
    {
      CFStringRef v8 = @"paused";
      if (a2) {
        CFStringRef v8 = @"enabled";
      }
      int v9 = 138412290;
      CFStringRef v10 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "fetched OT user-controllable-sync status as : %@", (uint8_t *)&v9, 0xCu);
    }
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

id sub_10021CCEC(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v6 = [v5 account];
  BOOL v7 = [v6 trust];
  CFStringRef v8 = [v5 account];

  id v9 = [v7 matchOTUserViewSettings:v8 userViewsEnabled:*(_DWORD *)(a1 + 32) != 0 err:a3];
  return v9;
}

BOOL sub_10021CD84(CFTypeRef *a1, void *a2)
{
  uint64_t v14 = 0;
  CFDictionaryRef v15 = &v14;
  uint64_t v16 = 0x2020000000;
  char v17 = 0;
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  id v9 = sub_10021CEE4;
  CFStringRef v10 = &unk_100309778;
  uint64_t v12 = &v14;
  id v3 = a2;
  id v11 = v3;
  int v13 = a1;
  int v4 = v8;
  int v18 = -1431655766;
  uint64_t v5 = sub_10001AE90(0, &v18);
  if (sub_100029664(v5, a1, @"aks_get_lock_state failed: %x", v5))
  {
    if ((v18 & 4) != 0)
    {
      v9((uint64_t)v4);

      BOOL v6 = *((unsigned char *)v15 + 24) != 0;
      goto LABEL_5;
    }
    SOSCreateErrorWithFormat();
  }

  BOOL v6 = 0;
LABEL_5:

  _Block_object_dispose(&v14, 8);
  return v6;
}

void sub_10021CECC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10021CEE4(uint64_t a1)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  _DWORD v4[2] = sub_10021CF80;
  void v4[3] = &unk_100309750;
  long long v3 = *(_OWORD *)(a1 + 32);
  id v2 = (id)v3;
  long long v5 = v3;
  uint64_t v6 = *(void *)(a1 + 48);
  sub_10021BA54(v4);
}

uint64_t sub_10021CF80(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = result;
  return result;
}

uint64_t sub_10021CFC0(uint64_t a1, int a2, CFTypeRef *a3)
{
  uint64_t v10 = 0;
  id v11 = &v10;
  uint64_t v12 = 0x2020000000;
  int v13 = 0;
  sub_10021C864();
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  void v8[2] = sub_10021D0A0;
  v8[3] = &unk_100308FB8;
  int v9 = a2;
  void v8[4] = &v10;
  void v8[5] = a1;
  void v8[6] = a3;
  sub_10021CD84(a3, v8);
  uint64_t v6 = *((unsigned int *)v11 + 6);
  _Block_object_dispose(&v10, 8);
  return v6;
}

void sub_10021D088(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10021D0A0(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = [v3 account];
  unsigned int v5 = [v4 SOSMonitorModeSOSIsActive];

  if (!v5)
  {
LABEL_11:
    uint64_t v11 = 0;
    goto LABEL_12;
  }
  int v6 = *(_DWORD *)(a1 + 56);
  if (v6 == 1 || v6 == 2)
  {
    BOOL v7 = [v3 account];
    CFStringRef v8 = [v7 trust];
    int v9 = [v3 account];
    unsigned int v10 = [v8 updateView:v9 name:*(void *)(a1 + 40) code:*(unsigned int *)(a1 + 56) err:*(void *)(a1 + 48)];
    goto LABEL_7;
  }
  if (v6 != 3)
  {
    uint64_t v12 = sub_10000B070("views");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = *(_DWORD *)(a1 + 56);
      v15[0] = 67109120;
      v15[1] = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Bad SOSViewActionCode - %d", (uint8_t *)v15, 8u);
    }

    goto LABEL_11;
  }
  BOOL v7 = [v3 account];
  CFStringRef v8 = [v7 trust];
  int v9 = [v3 account];
  unsigned int v10 = [v8 viewStatus:v9 name:*(void *)(a1 + 40) err:*(void *)(a1 + 48)];
LABEL_7:
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v10;

  uint64_t v11 = 1;
LABEL_12:

  return v11;
}

BOOL sub_10021D24C(uint64_t a1, uint64_t a2)
{
  int v4 = _OctagonSignpostLogSystem();
  os_signpost_id_t v5 = _OctagonSignpostCreate();

  int v6 = _OctagonSignpostLogSystem();
  BOOL v7 = v6;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v6))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_INTERVAL_BEGIN, v5, "SOSCCViewSet", " enableTelemetry=YES ", buf, 2u);
  }

  CFStringRef v8 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v17 = v5;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCViewSet  enableTelemetry=YES ", buf, 0xCu);
  }

  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  _DWORD v15[2] = sub_10021D4C4;
  v15[3] = &unk_100308FF8;
  void v15[4] = a1;
  void v15[5] = a2;
  BOOL v9 = sub_10021CD84(0, v15);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  uint64_t v11 = _OctagonSignpostLogSystem();
  uint64_t v12 = v11;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
  {
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v17) = v9;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v12, OS_SIGNPOST_INTERVAL_END, v5, "SOSCCViewSet", " SOSSignpostNameSOSCCViewSet=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCViewSet}d ", buf, 8u);
  }

  int v13 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218496;
    os_signpost_id_t v17 = v5;
    __int16 v18 = 2048;
    double v19 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v20 = 1026;
    BOOL v21 = v9;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCViewSet  SOSSignpostNameSOSCCViewSet=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCViewSet}d ", buf, 0x1Cu);
  }

  return v9;
}

id sub_10021D4C4(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (SOSVisibleKeychainNotAllowed()
    && (CFSetRef v4 = *(const __CFSet **)(a1 + 32)) != 0
    && CFSetGetCount(v4)
    && SOSViewSetIntersectsV0())
  {
    os_signpost_id_t v5 = sub_10000B070("views");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Cannot enable visible keychain views due to profile restrictions", buf, 2u);
    }
    id v6 = 0;
  }
  else
  {
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    v11[2] = sub_10021D620;
    v11[3] = &unk_100308FD8;
    CFSetRef v7 = *(const __CFSet **)(a1 + 32);
    void v11[4] = *(void *)(a1 + 40);
    sub_100025B70(v7, (uint64_t)v11);
    os_signpost_id_t v5 = [v3 account];
    CFStringRef v8 = [v5 trust];
    BOOL v9 = [v3 account];
    id v6 = [v8 updateViewSets:v9 enabled:*(void *)(a1 + 32) disabled:*(void *)(a1 + 40)];
  }
  return v6;
}

void sub_10021D620(uint64_t a1, uint64_t a2)
{
  CFSetRef v2 = *(const __CFSet **)(a1 + 32);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_10021D690;
  v3[3] = &unk_100308FD8;
  void v3[4] = a2;
  sub_100025B70(v2, (uint64_t)v3);
}

void sub_10021D690(uint64_t a1, uint64_t a2)
{
  CFSetRef v4 = sub_10000B070("viewChange");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    int v6 = 138412546;
    uint64_t v7 = v5;
    __int16 v8 = 2112;
    uint64_t v9 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Calling updateViewSets to enable %@ and disable %@", (uint8_t *)&v6, 0x16u);
  }
}

void sub_10021D758(char a1)
{
  CFSetRef v2 = _OctagonSignpostLogSystem();
  os_signpost_id_t v3 = _OctagonSignpostCreate();

  CFSetRef v4 = _OctagonSignpostLogSystem();
  uint64_t v5 = v4;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v4))
  {
    LOWORD(buf) = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "SyncTheLastDataToKVS", " enableTelemetry=YES ", (uint8_t *)&buf, 2u);
  }

  int v6 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SyncTheLastDataToKVS  enableTelemetry=YES ", (uint8_t *)&buf, 0xCu);
  }

  *(void *)&long long buf = 0;
  *((void *)&buf + 1) = &buf;
  uint64_t v25 = 0x2020000000;
  uint64_t v26 = 0;
  dispatch_semaphore_t v7 = dispatch_semaphore_create(0);
  __int16 v8 = sub_10000B070("force-push");
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)__int16 v18 = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "calling SOSCloudKeychainSynchronizeAndWait", v18, 2u);
  }

  uint64_t v9 = dispatch_get_global_queue(-2, 0);
  unsigned int v10 = v7;
  os_signpost_id_t v17 = v10;
  SOSCloudKeychainSynchronizeAndWait();

  if (a1) {
    dispatch_time_t v11 = -1;
  }
  else {
    dispatch_time_t v11 = dispatch_time(0, 60000000000);
  }
  dispatch_semaphore_wait(v10, v11);

  uint64_t v12 = *(void *)(*((void *)&buf + 1) + 24);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  uint64_t v14 = _OctagonSignpostLogSystem();
  CFDictionaryRef v15 = v14;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v14))
  {
    *(_DWORD *)__int16 v18 = 67240192;
    LODWORD(v19) = v12 == 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_INTERVAL_END, v3, "SyncTheLastDataToKVS", " SOSSignpostNameSyncTheLastDataToKVS=%{public,signpost.telemetry:number1,name=SOSSignpostNameSyncTheLastDataToKVS}d ", v18, 8u);
  }

  uint64_t v16 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int16 v18 = 134218496;
    os_signpost_id_t v19 = v3;
    __int16 v20 = 2048;
    double v21 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v22 = 1026;
    BOOL v23 = v12 == 0;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SyncTheLastDataToKVS  SOSSignpostNameSyncTheLastDataToKVS=%{public,signpost.telemetry:number1,name=SOSSignpostNameSyncTheLastDataToKVS}d ", v18, 0x1Cu);
  }

  _Block_object_dispose(&buf, 8);
}

void sub_10021DAB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

intptr_t sub_10021DAE4(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3)
  {
    uint64_t v5 = sub_10000B070("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 138412290;
      uint64_t v10 = a3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "SOSCloudKeychainSynchronizeAndWait: %@", (uint8_t *)&v9, 0xCu);
    }

    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a3;
  }
  else
  {
    dispatch_semaphore_t v7 = sub_10000B070("force-push");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 138412290;
      uint64_t v10 = a2;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "returned from call; in callback to SOSCloudKeychainSynchronizeAndWait: results: %@",
        (uint8_t *)&v9,
        0xCu);
    }
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

uint64_t sub_10021DC14(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = sub_10000B070("updates");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412546;
    uint64_t v8 = a3;
    __int16 v9 = 2112;
    uint64_t v10 = a1;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Trying credentials and dsid (%@) for %@", buf, 0x16u);
  }

  return SOSDoWithCredentialsWhileUnlocked();
}

uint64_t sub_10021DD40(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = 0;
  uint64_t v25 = &v24;
  uint64_t v26 = 0x2020000000;
  char v27 = 0;
  CFSetRef v4 = _OctagonSignpostLogSystem();
  os_signpost_id_t v5 = _OctagonSignpostCreate();

  int v6 = _OctagonSignpostLogSystem();
  dispatch_semaphore_t v7 = v6;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v6))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_INTERVAL_BEGIN, v5, "SOSCCTryUserCredentials", " enableTelemetry=YES ", buf, 2u);
  }

  uint64_t v8 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v29 = v5;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCTryUserCredentials  enableTelemetry=YES ", buf, 0xCu);
  }

  v21[0] = _NSConcreteStackBlock;
  v21[1] = 3221225472;
  v21[2] = sub_10021E124;
  v21[3] = &unk_100309048;
  void v21[4] = &v24;
  long long v22 = *(_OWORD *)(a1 + 32);
  uint64_t v23 = *(void *)(a1 + 48);
  sub_10021BA54(v21);
  if (!*((unsigned char *)v25 + 24))
  {
    __int16 v9 = sub_10000B070("updates");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "SOSCCTryUserCredentials_Server: Trying again with EFRESH", buf, 2u);
    }

    if (sub_10021E2F4(a2) && sub_10021E654())
    {
      sleep(1u);
      v18[0] = _NSConcreteStackBlock;
      v18[1] = 3221225472;
      v18[2] = sub_10021EA50;
      void v18[3] = &unk_100309048;
      uint8_t v18[4] = &v24;
      long long v19 = *(_OWORD *)(a1 + 40);
      uint64_t v20 = a2;
      sub_10021BA54(v18);
    }
  }
  sub_10021E654();
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  dispatch_time_t v11 = _OctagonSignpostLogSystem();
  uint64_t v12 = v11;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
  {
    int v13 = *((unsigned __int8 *)v25 + 24);
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v29) = v13;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v12, OS_SIGNPOST_INTERVAL_END, v5, "SOSCCTryUserCredentials", " SOSSignpostNameSOSCCTryUserCredentials=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCTryUserCredentials}d ", buf, 8u);
  }

  uint64_t v14 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218496;
    int v15 = *((unsigned __int8 *)v25 + 24);
    os_signpost_id_t v29 = v5;
    __int16 v30 = 2048;
    double v31 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v32 = 1026;
    int v33 = v15;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCTryUserCredentials  SOSSignpostNameSOSCCTryUserCredentials=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCTryUserCredentials}d ", buf, 0x1Cu);
  }

  uint64_t v16 = *((unsigned __int8 *)v25 + 24);
  _Block_object_dispose(&v24, 8);
  return v16;
}

void sub_10021E0EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10021E124(uint64_t a1, void *a2)
{
  id v3 = a2;
  CFStringRef v4 = *(const __CFString **)(a1 + 40);
  if (v4 && CFStringCompare(v4, &stru_10030AA90, 0))
  {
    os_signpost_id_t v5 = [v3 account];
    sub_1001E4BB8(v5, *(void *)(a1 + 40));
  }
  int v6 = [v3 account];
  dispatch_semaphore_t v7 = [v6 accountKeyDerivationParameters];

  if (v7)
  {
    CFTypeRef cf = 0;
    uint64_t v8 = [v3 account];
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = sub_1001EF92C(v8, *(void *)(a1 + 48), *(const __CFData **)(a1 + 56), &cf);

    CFTypeRef v9 = cf;
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
      BOOL v10 = 1;
    }
    else {
      BOOL v10 = cf == 0;
    }
    if (!v10)
    {
      dispatch_time_t v11 = sub_10000B070("updates");
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        CFTypeRef v15 = cf;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Failed with SOSAccountTryUserCredentials() with initial known parameters %@", buf, 0xCu);
      }

      CFTypeRef v9 = cf;
    }
    if (v9)
    {
      CFTypeRef cf = 0;
      CFRelease(v9);
    }
  }
  else
  {
    uint64_t v12 = sub_10000B070("updates");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "SOSCCTryUserCredentials_Server: No known parameters", buf, 2u);
    }
  }
}

BOOL sub_10021E2F4(uint64_t a1)
{
  CFSetRef v2 = _OctagonSignpostLogSystem();
  os_signpost_id_t v3 = _OctagonSignpostCreate();

  CFStringRef v4 = _OctagonSignpostLogSystem();
  os_signpost_id_t v5 = v4;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v4))
  {
    LOWORD(buf) = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "SyncKVSAndWait", " enableTelemetry=YES ", (uint8_t *)&buf, 2u);
  }

  int v6 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SyncKVSAndWait  enableTelemetry=YES ", (uint8_t *)&buf, 0xCu);
  }

  dispatch_semaphore_t v7 = dispatch_semaphore_create(0);
  *(void *)&long long buf = 0;
  *((void *)&buf + 1) = &buf;
  uint64_t v29 = 0x2020000000;
  char v30 = 0;
  uint64_t v8 = sub_10000B070("fresh");
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long v22 = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "EFP calling SOSCloudKeychainSynchronizeAndWait", v22, 2u);
  }

  activity_block[0] = _NSConcreteStackBlock;
  activity_block[1] = 3221225472;
  activity_block[2] = sub_10021EBD4;
  activity_block[3] = &unk_1003097F0;
  p_long long buf = &buf;
  uint64_t v21 = a1;
  CFTypeRef v9 = v7;
  long long v19 = v9;
  _os_activity_initiate((void *)&_mh_execute_header, "CloudCircle EFRESH", OS_ACTIVITY_FLAG_DEFAULT, activity_block);

  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  dispatch_time_t v11 = _OctagonSignpostLogSystem();
  uint64_t v12 = v11;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
  {
    int v13 = *(unsigned __int8 *)(*((void *)&buf + 1) + 24);
    *(_DWORD *)long long v22 = 67240192;
    LODWORD(v23) = v13;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v12, OS_SIGNPOST_INTERVAL_END, v3, "SyncKVSAndWait", " SOSSignpostNameSyncKVSAndWait=%{public,signpost.telemetry:number1,name=SOSSignpostNameSyncKVSAndWait}d ", v22, 8u);
  }

  uint64_t v14 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long v22 = 134218496;
    int v15 = *(unsigned __int8 *)(*((void *)&buf + 1) + 24);
    os_signpost_id_t v23 = v3;
    __int16 v24 = 2048;
    double v25 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v26 = 1026;
    int v27 = v15;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SyncKVSAndWait  SOSSignpostNameSyncKVSAndWait=%{public,signpost.telemetry:number1,name=SOSSignpostNameSyncKVSAndWait}d ", v22, 0x1Cu);
  }

  BOOL v16 = *(unsigned char *)(*((void *)&buf + 1) + 24) != 0;
  _Block_object_dispose(&buf, 8);

  return v16;
}

void sub_10021E62C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_10021E654()
{
  uint64_t v19 = 0;
  uint64_t v20 = &v19;
  uint64_t v21 = 0x2020000000;
  char v22 = 0;
  id v0 = _OctagonSignpostLogSystem();
  os_signpost_id_t v1 = _OctagonSignpostCreate();

  CFSetRef v2 = _OctagonSignpostLogSystem();
  os_signpost_id_t v3 = v2;
  if (v1 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v2))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v3, OS_SIGNPOST_INTERVAL_BEGIN, v1, "Flush", " enableTelemetry=YES ", buf, 2u);
  }

  CFStringRef v4 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v24 = v1;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: Flush  enableTelemetry=YES ", buf, 0xCu);
  }

  dispatch_semaphore_t v5 = dispatch_semaphore_create(0);
  int v6 = sub_10000B070("flush");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Starting", buf, 2u);
  }

  dispatch_semaphore_t v7 = dispatch_get_global_queue(-2, 0);
  uint64_t v8 = v5;
  SOSCloudKeychainFlush();

  dispatch_semaphore_wait(v8, 0xFFFFFFFFFFFFFFFFLL);
  CFTypeRef v9 = sub_10000B070("flush");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if (*((unsigned char *)v20 + 24)) {
      BOOL v10 = "Success";
    }
    else {
      BOOL v10 = "Failure";
    }
    *(_DWORD *)long long buf = 136315138;
    os_signpost_id_t v24 = (os_signpost_id_t)v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Returned %s", buf, 0xCu);
  }

  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  uint64_t v12 = _OctagonSignpostLogSystem();
  int v13 = v12;
  if (v1 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v12))
  {
    int v14 = *((unsigned __int8 *)v20 + 24);
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v14;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v13, OS_SIGNPOST_INTERVAL_END, v1, "Flush", " SOSSignpostNameFlush=%{public,signpost.telemetry:number1,name=SOSSignpostNameFlush}d ", buf, 8u);
  }

  int v15 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218496;
    int v16 = *((unsigned __int8 *)v20 + 24);
    os_signpost_id_t v24 = v1;
    __int16 v25 = 2048;
    double v26 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v27 = 1026;
    int v28 = v16;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: Flush  SOSSignpostNameFlush=%{public,signpost.telemetry:number1,name=SOSSignpostNameFlush}d ", buf, 0x1Cu);
  }

  BOOL v17 = *((unsigned char *)v20 + 24) != 0;
  _Block_object_dispose(&v19, 8);
  return v17;
}

void sub_10021EA18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10021EA50(uint64_t a1, void *a2)
{
  os_signpost_id_t v3 = [a2 account];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = sub_1001EF92C(v3, *(void *)(a1 + 40), *(const __CFData **)(a1 + 48), *(CFTypeRef **)(a1 + 56));

  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    CFStringRef v4 = *(void **)(a1 + 56);
    if (v4)
    {
      if (*v4)
      {
        dispatch_semaphore_t v5 = sub_10000B070("updates");
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v6 = **(void **)(a1 + 56);
          int v7 = 138412290;
          uint64_t v8 = v6;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Failed with SOSAccountTryUserCredentials() %@", (uint8_t *)&v7, 0xCu);
        }
      }
    }
  }
}

intptr_t sub_10021EB54(void *a1, int a2, CFTypeRef cf)
{
  CFStringRef v4 = (CFTypeRef *)a1[6];
  *(unsigned char *)(*(void *)(a1[5] + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = cf == 0;
  if (v4)
  {
    CFTypeRef v6 = *v4;
    if (*v4 != cf)
    {
      if (!cf || (CFRetain(cf), (CFTypeRef v6 = *v4) != 0)) {
        CFRelease(v6);
      }
      *CFStringRef v4 = cf;
    }
  }
  int v7 = a1[4];

  return dispatch_semaphore_signal(v7);
}

void sub_10021EBD4(uint64_t a1)
{
  CFSetRef v2 = dispatch_get_global_queue(-2, 0);
  long long v7 = *(_OWORD *)(a1 + 32);
  id v3 = (id)v7;
  SOSCloudKeychainSynchronizeAndWait();

  dispatch_semaphore_wait(*(dispatch_semaphore_t *)(a1 + 32), 0xFFFFFFFFFFFFFFFFLL);
  CFStringRef v4 = sub_10000B070("fresh");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    dispatch_semaphore_t v5 = *(void **)(a1 + 48);
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
      CFTypeRef v6 = "success";
    }
    else {
      CFTypeRef v6 = "failure";
    }
    if (v5) {
      dispatch_semaphore_t v5 = (void *)*v5;
    }
    *(_DWORD *)long long buf = 136315394;
    CFTypeRef v9 = v6;
    __int16 v10 = 2112;
    dispatch_time_t v11 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "EFP complete: %s %@", buf, 0x16u);
  }
}

intptr_t sub_10021ED54(uint64_t a1, uint64_t a2, const void *a3)
{
  dispatch_semaphore_t v5 = sub_10000B070("fresh");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 138412290;
    __int16 v10 = a3;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "EFP returned, callback error: %@", (uint8_t *)&v9, 0xCu);
  }

  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a3 == 0;
  CFTypeRef v6 = *(const void ***)(a1 + 48);
  if (v6)
  {
    long long v7 = *v6;
    if (*v6 != a3)
    {
      if (!a3 || (CFRetain(a3), (long long v7 = *v6) != 0)) {
        CFRelease(v7);
      }
      const char *v6 = a3;
    }
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

uint64_t sub_10021EE5C(uint64_t a1, uint64_t a2, os_signpost_id_t a3, uint64_t *a4)
{
  long long v7 = sub_10000B070("updates");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412802;
    os_signpost_id_t v22 = a3;
    __int16 v23 = 2112;
    double v24 = *(double *)&a1;
    __int16 v25 = 1024;
    uid_t v26 = getuid();
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Setting credentials and dsid (%@) for %@.  UID is %d", buf, 0x1Cu);
  }

  uint64_t v8 = _OctagonSignpostLogSystem();
  os_signpost_id_t v9 = _OctagonSignpostCreate();

  __int16 v10 = _OctagonSignpostLogSystem();
  dispatch_time_t v11 = v10;
  if (v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v10))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v11, OS_SIGNPOST_INTERVAL_BEGIN, v9, "AssertUserCredentialsAndOptionalDSID", " enableTelemetry=YES ", buf, 2u);
  }

  uint64_t v12 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v22 = v9;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: AssertUserCredentialsAndOptionalDSID  enableTelemetry=YES ", buf, 0xCu);
  }

  uint64_t v13 = SOSDoWithCredentialsWhileUnlocked();
  int v14 = sub_10000B070("updates");
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    if (a4) {
      uint64_t v15 = *a4;
    }
    else {
      uint64_t v15 = 0;
    }
    *(_DWORD *)long long buf = 138413058;
    os_signpost_id_t v22 = a3;
    __int16 v23 = 2112;
    double v24 = *(double *)&a1;
    __int16 v25 = 1024;
    uid_t v26 = v13;
    __int16 v27 = 2112;
    uint64_t v28 = v15;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Complete credentials and dsid (%@) for %@: %d %@", buf, 0x26u);
  }

  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  BOOL v17 = _OctagonSignpostLogSystem();
  __int16 v18 = v17;
  if (v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v17))
  {
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v22) = v13;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v18, OS_SIGNPOST_INTERVAL_END, v9, "AssertUserCredentialsAndOptionalDSID", " SOSSignpostNameAssertUserCredentialsAndOptionalDSID=%{public,signpost.telemetry:number1,name=SOSSignpostNameAssertUserCredentialsAndOptionalDSID}d ", buf, 8u);
  }

  uint64_t v19 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218496;
    os_signpost_id_t v22 = v9;
    __int16 v23 = 2048;
    double v24 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v25 = 1026;
    uid_t v26 = v13;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: AssertUserCredentialsAndOptionalDSID  SOSSignpostNameAssertUserCredentialsAndOptionalDSID=%{public,signpost.telemetry:number1,name=SOSSignpostNameAssertUserCredentialsAndOptionalDSID}d ", buf, 0x1Cu);
  }

  return v13;
}

BOOL sub_10021F1E4(uint64_t a1, uint64_t a2)
{
  v18[0] = 0;
  v18[1] = v18;
  v18[2] = 0x2020000000;
  char v19 = 0;
  uint64_t v14 = 0;
  uint64_t v15 = &v14;
  uint64_t v16 = 0x2020000000;
  char v17 = 0;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  void v10[2] = sub_10021F3E8;
  v10[3] = &unk_100309818;
  void v10[4] = v18;
  v10[5] = &v14;
  long long v11 = *(_OWORD *)(a1 + 32);
  uint64_t v12 = *(void *)(a1 + 48);
  uint64_t v13 = a2;
  sub_10021BA54(v10);
  if (*((unsigned char *)v15 + 24))
  {
    BOOL v4 = 1;
  }
  else
  {
    if (sub_10021E2F4(0) && sub_10021E654())
    {
      sleep(1u);
      v7[0] = _NSConcreteStackBlock;
      v7[1] = 3221225472;
      void v7[2] = sub_10021F4E4;
      v7[3] = &unk_100309048;
      void v7[4] = &v14;
      long long v8 = *(_OWORD *)(a1 + 40);
      uint64_t v9 = a2;
      sub_10021BA54(v7);
    }
    if (*((unsigned char *)v15 + 24) && sub_10021E654())
    {
      v6[0] = _NSConcreteStackBlock;
      v6[1] = 3221225472;
      v6[2] = sub_10021F8EC;
      v6[3] = &unk_100309840;
      void v6[4] = &v14;
      sub_10021BA54(v6);
    }
    BOOL v4 = *((unsigned char *)v15 + 24) != 0;
  }
  _Block_object_dispose(&v14, 8);
  _Block_object_dispose(v18, 8);
  return v4;
}

void sub_10021F3C4(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Block_object_dispose((const void *)(v1 - 80), 8);
  _Unwind_Resume(a1);
}

void sub_10021F3E8(uint64_t a1, void *a2)
{
  id v9 = a2;
  id v3 = [v9 account];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = sub_1001E4BB8(v3, *(void *)(a1 + 48));

  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    BOOL v4 = [v9 account];
    uint64_t v5 = [v4 accountKeyDerivationParameters];
    if (v5)
    {
      CFTypeRef v6 = (void *)v5;
      long long v7 = [v9 account];
      unsigned int v8 = [v7 accountKeyIsTrusted];

      if (!v8) {
        goto LABEL_6;
      }
      BOOL v4 = [v9 account];
      *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = sub_1001EF92C(v4, *(void *)(a1 + 56), *(const __CFData **)(a1 + 64), *(CFTypeRef **)(a1 + 72));
    }
  }
LABEL_6:
}

void sub_10021F4E4(void *a1, void *a2)
{
  id v3 = [a2 account];
  uint64_t v4 = a1[5];
  CFDataRef v5 = (const __CFData *)a1[6];
  CFTypeRef v6 = (CFTypeRef *)a1[7];
  id v16 = v3;
  int v7 = [v16 accountKeyIsTrusted];
  [v16 setAccountKeyIsTrusted:0];
  if (sub_1001EF6A0(v16, v5, v6))
  {
    __int16 v10 = 0;
    CFMutableArrayRef Mutable = 0;
    goto LABEL_16;
  }
  if (CFDataGetLength(v5) >= 21)
  {
    unsigned int v8 = sub_10000B070("SecWarning");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Long password (>20 byte utf8) being used to derive account key  this may be a PET by mistake!!", buf, 2u);
    }
  }
  memset(buf, 170, 16);
  if (SecRandomCopyBytes(0, 0x10uLL, buf))
  {
    SOSCreateError();
LABEL_8:
    CFMutableArrayRef Mutable = 0;
    goto LABEL_9;
  }
  CFMutableArrayRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
  ccder_sizeof_raw_octet_string();
  ccder_sizeof_uint64();
  ccder_sizeof_uint64();
  ccder_sizeof();
  CFIndex v15 = ccder_sizeof();
  CFDataSetLength(Mutable, v15);
  CFDataGetBytePtr(Mutable);
  CFDataGetMutableBytePtr(Mutable);
  CFDataGetLength(Mutable);
  ccder_encode_body();
  ccder_encode_tl();
  ccder_encode_uint64();
  ccder_encode_uint64();
  ccder_encode_raw_octet_string();
  if (ccder_encode_constructed_tl())
  {
    if (Mutable) {
      sub_1001EB124(@"SOSUserKeyCreateGenerateParameters created new parameters:", Mutable);
    }
    goto LABEL_9;
  }
  if (Mutable)
  {
    CFRelease(Mutable);
    goto LABEL_8;
  }
LABEL_9:
  __int16 v10 = (const void *)sub_1001EB5C4(v5, Mutable);
  if (!v10) {
    goto LABEL_17;
  }
  [v16 setAccountKeyDerivationParameters:Mutable];
  sub_1001EEF80(v16, (uint64_t)v5, (uint64_t)v10, v7);
  CFTypeRef cf = 0;
  if ((sub_1001EC3F0(v16, (uint64_t)&cf) & 1) == 0)
  {
    long long v11 = sub_10000B070("SecError");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = cf;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Failed to publish new cloud parameters: %@", buf, 0xCu);
    }
  }
  CFTypeRef v12 = cf;
  if (cf)
  {
    CFTypeRef cf = 0;
    CFRelease(v12);
  }
LABEL_16:
  sub_1001EE79C(v16);
  sub_1001FF4C0(v16, @"AccountName", v4, 0);
LABEL_17:
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v10) {
    CFRelease(v10);
  }
  uint64_t v13 = sub_10000B070("circleop");
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Setting account.key_interests_need_updating to true in SOSAccountAssertUserCredentials", buf, 2u);
  }

  [v16 setKey_interests_need_updating:1];
  unsigned __int8 v14 = [v16 accountKeyIsTrusted];

  *(unsigned char *)(*(void *)(a1[4] + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v14;
}

void sub_10021F8EC(uint64_t a1, void *a2)
{
  id v3 = [a2 account];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = sub_1001EE498(v3);
}

uint64_t sub_10021F94C(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  return sub_10021EE5C(a1, a2, 0, a3);
}

BOOL sub_10021F958(CFTypeRef *a1)
{
  CFSetRef v2 = _OctagonSignpostLogSystem();
  os_signpost_id_t v3 = _OctagonSignpostCreate();

  uint64_t v4 = _OctagonSignpostLogSystem();
  CFDataRef v5 = v4;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v4))
  {
    LOWORD(v15) = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "SOSCCCanAuthenticate", " enableTelemetry=YES ", (uint8_t *)&v15, 2u);
  }

  CFTypeRef v6 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v15 = 134217984;
    os_signpost_id_t v16 = v3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCCanAuthenticate  enableTelemetry=YES ", (uint8_t *)&v15, 0xCu);
  }

  BOOL v7 = sub_10021CD84(a1, &stru_1003090A8);
  BOOL v8 = v7;
  if (a1)
  {
    if (!v7)
    {
      if (*a1)
      {
        if (CFErrorGetDomain((CFErrorRef)*a1) == (CFErrorDomain)kSOSErrorDomain
          && (unint64_t)(CFErrorGetCode((CFErrorRef)*a1) - 1) <= 1)
        {
          CFTypeRef v9 = *a1;
          if (*a1)
          {
            *a1 = 0;
            CFRelease(v9);
          }
        }
      }
    }
  }
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  long long v11 = _OctagonSignpostLogSystem();
  CFTypeRef v12 = v11;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
  {
    int v15 = 67240192;
    LODWORD(v16) = v8;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v12, OS_SIGNPOST_INTERVAL_END, v3, "SOSCCCanAuthenticate", " SOSSignpostNameSOSCCCanAuthenticate=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCanAuthenticate}d ", (uint8_t *)&v15, 8u);
  }

  uint64_t v13 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    int v15 = 134218496;
    os_signpost_id_t v16 = v3;
    __int16 v17 = 2048;
    double v18 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v19 = 1026;
    BOOL v20 = v8;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCCanAuthenticate  SOSSignpostNameSOSCCCanAuthenticate=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCanAuthenticate}d ", (uint8_t *)&v15, 0x1Cu);
  }

  return v8;
}

BOOL sub_10021FBD4(id a1, SOSAccountTransaction *a2, __CFError **a3)
{
  os_signpost_id_t v3 = a2;
  uint64_t v4 = [(SOSAccountTransaction *)v3 account];
  sub_1001EE684(v4);

  CFDataRef v5 = [(SOSAccountTransaction *)v3 account];

  BOOL v6 = sub_1001EE508(v5) != 0;
  return v6;
}

BOOL sub_10021FC48(CFTypeRef *a1)
{
  return sub_10021CD84(a1, &stru_1003090C8);
}

BOOL sub_10021FC54(id a1, SOSAccountTransaction *a2, __CFError **a3)
{
  os_signpost_id_t v3 = [(SOSAccountTransaction *)a2 account];
  sub_1001EE564(v3);

  return 1;
}

uint64_t sub_10021FC8C(CFTypeRef *a1)
{
  uint64_t v5 = 0;
  BOOL v6 = &v5;
  uint64_t v7 = 0x2020000000;
  int v8 = -1;
  if ((byte_10035D44C & 1) == 0 && sub_10021C864()) {
    byte_10035D44C = 1;
  }
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  _DWORD v4[2] = sub_10021FD88;
  void v4[3] = &unk_1003090F0;
  void v4[4] = &v5;
  if (sub_10021CD84(a1, v4)) {
    uint64_t v2 = *((unsigned int *)v6 + 6);
  }
  else {
    uint64_t v2 = 0xFFFFFFFFLL;
  }
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_10021FD6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10021FD88(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v5 = [a2 account];
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = [v5 getCircleStatus:a3];

  return 1;
}

BOOL sub_10021FDE0(CFTypeRef *a1)
{
  v14[0] = 0;
  v14[1] = v14;
  v14[2] = 0x2020000000;
  char v15 = 1;
  uint64_t v2 = _OctagonSignpostLogSystem();
  os_signpost_id_t v3 = _OctagonSignpostCreate();

  uint64_t v4 = _OctagonSignpostLogSystem();
  uint64_t v5 = v4;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v4))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "SOSCCRequestToJoinCircle", " enableTelemetry=YES ", buf, 2u);
  }

  BOOL v6 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v17 = v3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCRequestToJoinCircle  enableTelemetry=YES ", buf, 0xCu);
  }

  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_1002200B8;
  v13[3] = &unk_1003090F0;
  void v13[4] = v14;
  BOOL v7 = sub_100220170(a1, v13);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  CFTypeRef v9 = _OctagonSignpostLogSystem();
  __int16 v10 = v9;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v17) = v7;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v10, OS_SIGNPOST_INTERVAL_END, v3, "SOSCCRequestToJoinCircle", " SOSSignpostNameSOSCCRequestToJoinCircle=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCRequestToJoinCircle}d ", buf, 8u);
  }

  long long v11 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218496;
    os_signpost_id_t v17 = v3;
    __int16 v18 = 2048;
    double v19 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v20 = 1026;
    BOOL v21 = v7;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCRequestToJoinCircle  SOSSignpostNameSOSCCRequestToJoinCircle=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCRequestToJoinCircle}d ", buf, 0x1Cu);
  }

  _Block_object_dispose(v14, 8);
  return v7;
}

void sub_100220080(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1002200B8(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  BOOL v6 = sub_10000B070("circleOps");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CFTypeRef v9 = 0;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Normal path circle join (SOSAccountJoinCircles)", v9, 2u);
  }

  char v7 = sub_1001E5BBC(v5, 0, a3);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v7;
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

BOOL sub_100220170(CFTypeRef *a1, void *a2)
{
  CFTypeRef v48 = 0;
  uint64_t v44 = 0;
  id v45 = &v44;
  uint64_t v46 = 0x2020000000;
  char v47 = 0;
  uint64_t v40 = 0;
  unsigned __int8 v41 = &v40;
  uint64_t v42 = 0x2020000000;
  char v43 = 0;
  uint64_t v36 = 0;
  id v37 = &v36;
  uint64_t v38 = 0x2020000000;
  CFTypeRef v39 = 0;
  v31[0] = _NSConcreteStackBlock;
  v31[1] = 3221225472;
  v31[2] = sub_1002206E4;
  v31[3] = &unk_100309930;
  int v33 = &v40;
  uint64_t v34 = &v44;
  id v3 = a2;
  id v32 = v3;
  uint64_t v35 = a1;
  BOOL v4 = sub_10002AF90(0, &v39, (uint64_t)v31);
  if (v4) {
    goto LABEL_18;
  }
  id v5 = (__CFError *)v37[3];
  if (CFErrorGetCode(v5) != -536870174) {
    goto LABEL_18;
  }
  CFStringRef Domain = CFErrorGetDomain(v5);
  if (!Domain || !kCFErrorDomainMach)
  {
    if (Domain == kCFErrorDomainMach) {
      goto LABEL_6;
    }
LABEL_18:
    if (a1)
    {
      if (!*a1)
      {
        __int16 v10 = (const void *)v37[3];
        if (v10)
        {
          v37[3] = 0;
          if (*a1) {
            CFRelease(*a1);
          }
          *a1 = v10;
        }
      }
    }
    long long v11 = (const void *)v37[3];
    if (v11)
    {
      v37[3] = 0;
      CFRelease(v11);
    }
    CFTypeRef v12 = v48;
    if (v48)
    {
      CFTypeRef v48 = 0;
      CFRelease(v12);
    }
    if (!v4) {
      goto LABEL_64;
    }
    BOOL v13 = *((unsigned char *)v45 + 24) != 0;
    goto LABEL_65;
  }
  if (!CFEqual(Domain, kCFErrorDomainMach)) {
    goto LABEL_18;
  }
LABEL_6:
  if (*((unsigned char *)v41 + 24))
  {
    if (a1)
    {
      if (!*a1)
      {
        char v7 = (const void *)v37[3];
        if (v7)
        {
          v37[3] = 0;
          if (*a1) {
            CFRelease(*a1);
          }
          *a1 = v7;
        }
      }
    }
    int v8 = (const void *)v37[3];
    if (v8)
    {
      v37[3] = 0;
      CFRelease(v8);
    }
    CFTypeRef v9 = v48;
    if (!v48) {
      goto LABEL_64;
    }
    goto LABEL_63;
  }
  *(_DWORD *)long long buf = -1431655766;
  uint64_t v14 = sub_10001AE90(0, buf);
  if (!sub_100029664(v14, &v48, @"aks_get_lock_state failed: %x", v14) || (buf[0] & 1) != 0)
  {
    __int16 v23 = sub_10000B070("while-unlocked-hack");
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      CFTypeRef v50 = (const char *)v48;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Not trying action, aks bag locked (%@)", buf, 0xCu);
    }

    if (a1)
    {
      if (!*a1)
      {
        double v24 = (const void *)v37[3];
        if (v24)
        {
          v37[3] = 0;
          if (*a1) {
            CFRelease(*a1);
          }
          *a1 = v24;
        }
      }
    }
    __int16 v25 = (const void *)v37[3];
    if (v25)
    {
      v37[3] = 0;
      CFRelease(v25);
    }
    CFTypeRef v9 = v48;
    if (!v48) {
      goto LABEL_64;
    }
LABEL_63:
    CFTypeRef v48 = 0;
    CFRelease(v9);
LABEL_64:
    BOOL v13 = 0;
    goto LABEL_65;
  }
  char v15 = (const void *)v37[3];
  if (v15)
  {
    v37[3] = 0;
    CFRelease(v15);
  }
  os_signpost_id_t v16 = sub_10000B070("while-unlocked-hack");
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Trying action while unlocked without assertion", buf, 2u);
  }

  v27[0] = _NSConcreteStackBlock;
  v27[1] = 3221225472;
  v27[2] = sub_100220874;
  v27[3] = &unk_100309958;
  uint64_t v29 = &v44;
  id v28 = v3;
  char v30 = &v36;
  sub_10021BA54(v27);
  os_signpost_id_t v17 = sub_10000B070("while-unlocked-hack");
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    if (*((unsigned char *)v45 + 24)) {
      __int16 v18 = "succeeded";
    }
    else {
      __int16 v18 = "failed";
    }
    uint64_t v19 = v37[3];
    *(_DWORD *)long long buf = 136315394;
    CFTypeRef v50 = v18;
    __int16 v51 = 2112;
    uint64_t v52 = v19;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Action %s (%@)", buf, 0x16u);
  }

  if (a1)
  {
    if (!*a1)
    {
      __int16 v20 = (const void *)v37[3];
      if (v20)
      {
        v37[3] = 0;
        if (*a1) {
          CFRelease(*a1);
        }
        *a1 = v20;
      }
    }
  }
  BOOL v21 = (const void *)v37[3];
  if (v21)
  {
    v37[3] = 0;
    CFRelease(v21);
  }
  CFTypeRef v22 = v48;
  if (v48)
  {
    CFTypeRef v48 = 0;
    CFRelease(v22);
  }
  BOOL v13 = *((unsigned char *)v45 + 24) != 0;

LABEL_65:
  _Block_object_dispose(&v36, 8);
  _Block_object_dispose(&v40, 8);
  _Block_object_dispose(&v44, 8);

  return v13;
}

void sub_100220674(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  _Block_object_dispose(&a26, 8);
  _Block_object_dispose(&a30, 8);
  _Block_object_dispose((const void *)(v30 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_1002206E4(uint64_t a1)
{
  uint64_t v18 = 0;
  uint64_t v19 = &v18;
  uint64_t v20 = 0x2020000000;
  char v21 = 0;
  uint64_t v14 = 0;
  char v15 = &v14;
  uint64_t v16 = 0x2020000000;
  int v17 = 0;
  if (!SOSCCThisDeviceIsInCircle())
  {
    uint64_t v2 = sub_10021A4D0(1);
    id v3 = [v2 settings];

    if (v3)
    {
      unsigned int v4 = [v2 ghostBustCheckDate];
      *((unsigned char *)v19 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v4;
      if (!v4) {
        goto LABEL_7;
      }
    }
    else if (!*((unsigned char *)v19 + 24))
    {
LABEL_7:

      goto LABEL_8;
    }
    unsigned int v5 = +[SOSAccount ghostBustGetRampSettings];
    *((_DWORD *)v15 + 6) = v5 + 16;
    goto LABEL_7;
  }
LABEL_8:
  sub_10021BA54(&stru_100309880);
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  void v8[2] = sub_1002208BC;
  v8[3] = &unk_100309908;
  __int16 v10 = &v18;
  long long v11 = &v14;
  long long v12 = *(_OWORD *)(a1 + 40);
  id v6 = *(id *)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 56);
  id v9 = v6;
  uint64_t v13 = v7;
  sub_10021BA54(v8);

  _Block_object_dispose(&v14, 8);
  _Block_object_dispose(&v18, 8);
}

void sub_10022084C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 64), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100220874(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = result;
  return result;
}

void sub_1002208BC(void *a1, void *a2)
{
  id v4 = a2;
  id v3 = [v4 account];
  if ([v3 isInCircle:0]
    && +[SOSAuthKitHelpers accountIsCDPCapable]
    && !+[SOSAuthKitHelpers peerinfoHasMID:v3])
  {
    +[SOSAuthKitHelpers updateMIDInPeerInfo:v3];
  }
  if (*(unsigned char *)(*(void *)(a1[5] + 8) + 24))
  {
    [v3 ghostBustPeriodic:*(unsigned int *)(*(void *)(a1[6] + 8) + 24) complete:&stru_1003098C0];
    [v3 removeV0Peers:&stru_1003098E0];
  }
  *(unsigned char *)(*(void *)(a1[7] + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  *(unsigned char *)(*(void *)(a1[8] + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = (*(uint64_t (**)(void))(a1[4] + 16))();
}

void sub_1002209C0(id a1, BOOL a2, NSError *a3)
{
  id v4 = a3;
  unsigned int v5 = sub_10000B070("removeV0Peers");
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4 || !a2)
  {
    if (v6)
    {
      int v10 = 138412290;
      uint64_t v11 = v4;
      uint64_t v7 = "Did not remove any v0 peers, error: %@";
      int v8 = v5;
      uint32_t v9 = 12;
      goto LABEL_7;
    }
  }
  else if (v6)
  {
    LOWORD(v10) = 0;
    uint64_t v7 = "Removed v0 Peers";
    int v8 = v5;
    uint32_t v9 = 2;
LABEL_7:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v10, v9);
  }
}

void sub_100220AB4(id a1, BOOL a2, NSError *a3)
{
  BOOL v3 = a2;
  id v4 = sub_10000B070("ghostbust");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5[0] = 67109120;
    v5[1] = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "GhostBusting: %{BOOL}d", (uint8_t *)v5, 8u);
  }
}

void sub_100220B60(id a1, SOSAccountTransaction *a2)
{
  uint64_t v2 = a2;
  if (SOSVisibleKeychainNotAllowed())
  {
    BOOL v3 = [(SOSAccountTransaction *)v2 account];
    if ([v3 isInCircle:0])
    {
      id v4 = [(SOSAccountTransaction *)v2 account];
      [v4 peerInfo];
      int HasUserVisibleViewsEnabled = SOSPeerInfoHasUserVisibleViewsEnabled();

      if (HasUserVisibleViewsEnabled)
      {
        BOOL v6 = sub_10000B070("views");
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int v10 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Cannot have visible keychain views due to profile restrictions", v10, 2u);
        }

        uint64_t v7 = [(SOSAccountTransaction *)v2 account];
        int v8 = [v7 trust];
        uint32_t v9 = [(SOSAccountTransaction *)v2 account];
        [v8 updateViewSets:v9 enabled:0 disabled:SOSViewsGetV0ViewSet()];
      }
    }
  }
}

BOOL sub_100220C88(CFTypeRef *a1)
{
  v10[0] = 0;
  v10[1] = v10;
  void v10[2] = 0x2020000000;
  char v11 = 1;
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2020000000;
  uint64_t v9 = 0;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  _DWORD v5[2] = sub_100220D84;
  void v5[3] = &unk_100309118;
  void v5[4] = v10;
  void v5[5] = &v6;
  BOOL v2 = sub_100220170(a1, v5);
  if (a1)
  {
    BOOL v3 = (const void *)v7[3];
    if (v3) {
      *a1 = v3;
    }
  }
  _Block_object_dispose(&v6, 8);
  _Block_object_dispose(v10, 8);
  return v2;
}

void sub_100220D60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v7 - 48), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100220D84(uint64_t a1, void *a2)
{
  BOOL v3 = [a2 account];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = sub_1001EEC4C(v3) != 0;

  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

BOOL sub_100220DE8(CFTypeRef *a1)
{
  uint64_t v16 = 0;
  int v17 = &v16;
  uint64_t v18 = 0x2020000000;
  char v19 = 1;
  BOOL v2 = _OctagonSignpostLogSystem();
  os_signpost_id_t v3 = _OctagonSignpostCreate();

  id v4 = _OctagonSignpostLogSystem();
  unsigned int v5 = v4;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v4))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "SOSCCRequestToJoinCircleAfterRestore", " enableTelemetry=YES ", buf, 2u);
  }

  uint64_t v6 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v21 = v3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCRequestToJoinCircleAfterRestore  enableTelemetry=YES ", buf, 0xCu);
  }

  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  _DWORD v15[2] = sub_1002210D0;
  v15[3] = &unk_1003090F0;
  void v15[4] = &v16;
  BOOL v7 = sub_100220170(a1, v15);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  uint64_t v9 = _OctagonSignpostLogSystem();
  int v10 = v9;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    int v11 = *((unsigned __int8 *)v17 + 24);
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v21) = v11;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v10, OS_SIGNPOST_INTERVAL_END, v3, "SOSCCRequestToJoinCircleAfterRestore", " SOSSignpostNameSOSCCRequestToJoinCircleAfterRestore=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCRequestToJoinCircleAfterRestore}d ", buf, 8u);
  }

  long long v12 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218496;
    int v13 = *((unsigned __int8 *)v17 + 24);
    os_signpost_id_t v21 = v3;
    __int16 v22 = 2048;
    double v23 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v24 = 1026;
    int v25 = v13;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCRequestToJoinCircleAfterRestore  SOSSignpostNameSOSCCRequestToJoinCircleAfterRestore=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCRequestToJoinCircleAfterRestore}d ", buf, 0x1Cu);
  }

  _Block_object_dispose(&v16, 8);
  return v7;
}

void sub_100221098(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1002210D0(uint64_t a1, void *a2, id *a3)
{
  id v5 = a2;
  uint64_t v6 = [v5 account];
  sub_1001E6E98(v6);

  if (a3 && *a3)
  {
    id v7 = *a3;
    uint64_t v8 = sub_10000B070("SecError");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "ensure peer registration error: %@", buf, 0xCu);
    }
  }
  *(void *)long long buf = 0;
  id v9 = v5;
  int v10 = sub_10000B070("circleOps");
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v37 = 0;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Joining after restore (SOSAccountJoinCirclesAfterRestore)", v37, 2u);
  }

  char v11 = sub_1001E5BBC(v9, 1, (uint64_t)buf);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v11;
  if (a3)
  {
    long long v12 = *(void **)buf;
    if (*(void *)buf)
    {
      CFRetain(*(CFTypeRef *)buf);
      *a3 = v12;
    }
  }
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    if (qword_10035D0A8 != -1) {
      dispatch_once(&qword_10035D0A8, &stru_100303AD8);
    }
    if (byte_10035D0A0)
    {
      int v13 = sub_10000B070("join-after-restore");
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)id v37 = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "posting kSOSCCCircleOctagonKeysChangedNotification", v37, 2u);
      }

      notify_post(kSOSCCCircleOctagonKeysChangedNotification);
      uint64_t v14 = [v9 account];
      char v15 = [v14 trust];
      unsigned int v16 = [v15 isInCircleOnly:0];

      if (*(void *)buf)
      {
        int v17 = [(id)objc_opt_class() logger];
        uint64_t v18 = *(void *)buf;
        v38[0] = @"SOSEnabled";
        BOOL v19 = -[OTSOSActualAdapter sosEnabled]_0();
        CFStringRef v20 = @"compat_disabled";
        if (v19) {
          CFStringRef v20 = @"compat_enabled";
        }
        v39[0] = v20;
        v39[1] = @"Restore";
        v38[1] = @"SOSJoinMethod";
        v38[2] = @"JoiningSOSResult";
        CFStringRef v21 = @"not_in_circle";
        if (v16) {
          CFStringRef v21 = @"in_circle";
        }
        v39[2] = v21;
        v38[3] = @"CircleContainsLegacy";
        __int16 v22 = [v9 account];
        double v23 = [v22 trust];
        [v23 trustedCircle];
        __int16 v24 = [v9 account];
        [v24 accountKey];
        int IsLegacy = SOSCircleIsLegacy();
        CFStringRef v26 = @"does_not_contain_legacy";
        if (IsLegacy) {
          CFStringRef v26 = @"contains_legacy";
        }
        v39[3] = v26;
        __int16 v27 = +[NSDictionary dictionaryWithObjects:v39 forKeys:v38 count:4];
        [v17 logResultForEvent:@"SOSDeferralEventJoinCircleAfterRestore" hardFailure:0 result:v18 withAttributes:v27];
      }
      else
      {
        if (-[OTSOSActualAdapter sosEnabled]_0()) {
          CFStringRef v28 = @"compat_enabled";
        }
        else {
          CFStringRef v28 = @"compat_disabled";
        }
        if (v16) {
          CFStringRef v29 = @"in_circle";
        }
        else {
          CFStringRef v29 = @"not_in_circle";
        }
        uint64_t v30 = [v9 account];
        double v31 = [v30 trust];
        [v31 trustedCircle];
        id v32 = [v9 account];
        [v32 accountKey];
        int v33 = SOSCircleIsLegacy();
        CFStringRef v34 = @"does_not_contain_legacy";
        if (v33) {
          CFStringRef v34 = @"contains_legacy";
        }
        int v17 = +[NSString stringWithFormat:@"%@-%@-%@-%@", v28, @"Restore", v29, v34];

        __int16 v22 = [(id)objc_opt_class() logger];
        [v22 logSuccessForEventNamed:v17];
      }
    }
  }
  uint64_t v35 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);

  return v35;
}

BOOL sub_100221580(CFTypeRef *a1)
{
  return sub_10021CD84(a1, &stru_100309138);
}

BOOL sub_10022158C(id a1, SOSAccountTransaction *a2, __CFError **a3)
{
  os_signpost_id_t v3 = [(SOSAccountTransaction *)a2 account];
  sub_1001E4DD0(v3);

  return 1;
}

BOOL sub_1002215C4(CFTypeRef *a1)
{
  BOOL v2 = _OctagonSignpostLogSystem();
  os_signpost_id_t v3 = _OctagonSignpostCreate();

  id v4 = _OctagonSignpostLogSystem();
  id v5 = v4;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v4))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "SOSCCResetToOffering", " enableTelemetry=YES ", buf, 2u);
  }

  uint64_t v6 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v15 = v3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCResetToOffering  enableTelemetry=YES ", buf, 0xCu);
  }

  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_100221838;
  v13[3] = &unk_100309158;
  void v13[4] = a1;
  BOOL v7 = sub_100220170(a1, v13);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  id v9 = _OctagonSignpostLogSystem();
  int v10 = v9;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v15) = v7;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v10, OS_SIGNPOST_INTERVAL_END, v3, "SOSCCResetToOffering", " SOSSignpostNameSOSCCResetToOffering=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCResetToOffering}d ", buf, 8u);
  }

  char v11 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218496;
    os_signpost_id_t v15 = v3;
    __int16 v16 = 2048;
    double v17 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v18 = 1026;
    BOOL v19 = v7;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCResetToOffering  SOSSignpostNameSOSCCResetToOffering=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCResetToOffering}d ", buf, 0x1Cu);
  }

  return v7;
}

id sub_100221838(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = [v4 account];
  id v6 = sub_1001EE508(v5);

  if (v6)
  {
    BOOL v7 = [v4 account];
    uint64_t v8 = [v7 trust];
    [v8 trustedCircle];
    id v9 = [v4 account];
    [v9 accountKey];
    int IsLegacy = SOSCircleIsLegacy();

    CFTypeRef cf = 0;
    char v11 = [v4 account];
    long long v12 = [v11 trust];
    id v6 = [v12 resetToOffering:v4 key:v6 err:&cf];

    if (a3)
    {
      CFTypeRef v13 = cf;
      if (cf)
      {
        CFRetain(cf);
        *a3 = v13;
      }
    }
    if (v6)
    {
      if (qword_10035D0A8 != -1) {
        dispatch_once(&qword_10035D0A8, &stru_100303AD8);
      }
      if (byte_10035D0A0)
      {
        uint64_t v14 = sub_10000B070("reset-to-offering");
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "posting kSOSCCCircleOctagonKeysChangedNotification", buf, 2u);
        }

        notify_post(kSOSCCCircleOctagonKeysChangedNotification);
        os_signpost_id_t v15 = [v4 account];
        __int16 v16 = [v15 trust];
        unsigned int v17 = [v16 isInCircleOnly:0];

        if (cf)
        {
          __int16 v18 = [(id)objc_opt_class() logger];
          CFTypeRef v19 = cf;
          v32[0] = @"SOSEnabled";
          BOOL v20 = -[OTSOSActualAdapter sosEnabled]_0();
          CFStringRef v21 = @"compat_disabled";
          if (v20) {
            CFStringRef v21 = @"compat_enabled";
          }
          v33[0] = v21;
          v33[1] = @"ResetToOffering";
          v32[1] = @"SOSJoinMethod";
          v32[2] = @"JoiningSOSResult";
          CFStringRef v22 = @"in_circle";
          if (!v17) {
            CFStringRef v22 = @"not_in_circle";
          }
          v32[3] = @"CircleContainsLegacy";
          CFStringRef v23 = @"does_not_contain_legacy";
          if (IsLegacy) {
            CFStringRef v23 = @"contains_legacy";
          }
          id v33[2] = v22;
          v33[3] = v23;
          __int16 v24 = +[NSDictionary dictionaryWithObjects:v33 forKeys:v32 count:4];
          [v18 logResultForEvent:@"SOSDeferralEventResetToOffering" hardFailure:0 result:v19 withAttributes:v24];
        }
        else
        {
          BOOL v25 = -[OTSOSActualAdapter sosEnabled]_0();
          CFStringRef v26 = @"compat_disabled";
          if (v25) {
            CFStringRef v26 = @"compat_enabled";
          }
          CFStringRef v27 = @"not_in_circle";
          if (v17) {
            CFStringRef v27 = @"in_circle";
          }
          CFStringRef v28 = @"does_not_contain_legacy";
          if (IsLegacy) {
            CFStringRef v28 = @"contains_legacy";
          }
          __int16 v18 = +[NSString stringWithFormat:@"%@-%@-%@-%@", v26, @"ResetToOffering", v27, v28];
          __int16 v24 = [(id)objc_opt_class() logger];
          [v24 logSuccessForEventNamed:v18];
        }
      }
    }
  }

  return v6;
}

BOOL sub_100221BD4(CFTypeRef *a1)
{
  BOOL v2 = _OctagonSignpostLogSystem();
  os_signpost_id_t v3 = _OctagonSignpostCreate();

  id v4 = _OctagonSignpostLogSystem();
  id v5 = v4;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v4))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "SOSCCResetToEmpty", " enableTelemetry=YES ", buf, 2u);
  }

  id v6 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v15 = v3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCResetToEmpty  enableTelemetry=YES ", buf, 0xCu);
  }

  v13[0] = _NSConcreteStackBlock;
  v13[1] = 3221225472;
  v13[2] = sub_100221E48;
  v13[3] = &unk_100309158;
  void v13[4] = a1;
  BOOL v7 = sub_100220170(a1, v13);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  id v9 = _OctagonSignpostLogSystem();
  int v10 = v9;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v15) = v7;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v10, OS_SIGNPOST_INTERVAL_END, v3, "SOSCCResetToEmpty", " SOSSignpostNameSOSCCResetToEmpty=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCResetToEmpty}d ", buf, 8u);
  }

  char v11 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218496;
    os_signpost_id_t v15 = v3;
    __int16 v16 = 2048;
    double v17 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v18 = 1026;
    BOOL v19 = v7;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCResetToEmpty  SOSSignpostNameSOSCCResetToEmpty=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCResetToEmpty}d ", buf, 0x1Cu);
  }

  return v7;
}

id sub_100221E48(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = [v4 account];
  id v6 = sub_1001EEC4C(v5);

  if (v6)
  {
    BOOL v7 = [v4 account];
    uint64_t v8 = [v7 trust];
    [v8 trustedCircle];
    id v9 = [v4 account];
    [v9 accountKey];
    int IsLegacy = SOSCircleIsLegacy();

    CFTypeRef cf = 0;
    char v11 = [v4 account];
    long long v12 = [v11 trust];
    CFTypeRef v13 = [v4 account];
    uint64_t v14 = [v4 account];
    os_signpost_id_t v15 = [v14 circle_transport];
    id v6 = [v12 resetAccountToEmpty:v13 transport:v15 err:&cf];

    CFTypeRef v16 = cf;
    if (a3 && cf)
    {
      CFRetain(cf);
      *a3 = v16;
      CFTypeRef v16 = cf;
    }
    if (v16)
    {
      double v17 = [(id)objc_opt_class() logger];
      CFTypeRef v18 = cf;
      v28[0] = @"SOSEnabled";
      BOOL v19 = -[OTSOSActualAdapter sosEnabled]_0();
      CFStringRef v20 = @"compat_disabled";
      if (v19) {
        CFStringRef v20 = @"compat_enabled";
      }
      v29[0] = v20;
      v29[1] = @"Reset";
      CFStringRef v21 = @"does_not_contain_legacy";
      v28[1] = @"SOSJoinMethod";
      v28[2] = @"CircleContainsLegacy";
      if (IsLegacy) {
        CFStringRef v21 = @"contains_legacy";
      }
      v29[2] = v21;
      CFStringRef v22 = +[NSDictionary dictionaryWithObjects:v29 forKeys:v28 count:3];
      [v17 logResultForEvent:@"SOSDeferralEventReset" hardFailure:0 result:v18 withAttributes:v22];
    }
    else
    {
      BOOL v23 = -[OTSOSActualAdapter sosEnabled]_0();
      CFStringRef v24 = @"compat_disabled";
      if (v23) {
        CFStringRef v24 = @"compat_enabled";
      }
      if (IsLegacy) {
        CFStringRef v25 = @"contains_legacy";
      }
      else {
        CFStringRef v25 = @"does_not_contain_legacy";
      }
      double v17 = +[NSString stringWithFormat:@"%@-%@-%@", v24, @"Reset", v25];
      CFStringRef v22 = [(id)objc_opt_class() logger];
      [v22 logSuccessForEventNamed:v17];
    }
  }
  return v6;
}

BOOL sub_100222128(CFTypeRef *a1)
{
  BOOL v2 = _OctagonSignpostLogSystem();
  os_signpost_id_t v3 = _OctagonSignpostCreate();

  id v4 = _OctagonSignpostLogSystem();
  id v5 = v4;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v4))
  {
    LOWORD(v13) = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "SOSCCRemoveThisDeviceFromCircle", " enableTelemetry=YES ", (uint8_t *)&v13, 2u);
  }

  id v6 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = 134217984;
    os_signpost_id_t v14 = v3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCRemoveThisDeviceFromCircle  enableTelemetry=YES ", (uint8_t *)&v13, 0xCu);
  }

  BOOL v7 = sub_100220170(a1, &stru_100309178);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  id v9 = _OctagonSignpostLogSystem();
  int v10 = v9;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    int v13 = 67240192;
    LODWORD(v14) = v7;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v10, OS_SIGNPOST_INTERVAL_END, v3, "SOSCCRemoveThisDeviceFromCircle", " SOSSignpostNameSOSCCRemoveThisDeviceFromCircle=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCRemoveThisDeviceFromCircle}d ", (uint8_t *)&v13, 8u);
  }

  char v11 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = 134218496;
    os_signpost_id_t v14 = v3;
    __int16 v15 = 2048;
    double v16 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v17 = 1026;
    BOOL v18 = v7;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCRemoveThisDeviceFromCircle  SOSSignpostNameSOSCCRemoveThisDeviceFromCircle=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCRemoveThisDeviceFromCircle}d ", (uint8_t *)&v13, 0x1Cu);
  }

  return v7;
}

BOOL sub_100222358(id a1, SOSAccountTransaction *a2, __CFError **a3)
{
  id v4 = a2;
  id v5 = [(SOSAccountTransaction *)v4 account];
  id v6 = [v5 trust];
  BOOL v7 = [(SOSAccountTransaction *)v4 account];

  LOBYTE(a3) = [v6 leaveCircle:v7 err:a3];
  return (char)a3;
}

BOOL sub_1002223E0(uint64_t a1, CFTypeRef *a2)
{
  id v4 = _OctagonSignpostLogSystem();
  os_signpost_id_t v5 = _OctagonSignpostCreate();

  id v6 = _OctagonSignpostLogSystem();
  BOOL v7 = v6;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v6))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_INTERVAL_BEGIN, v5, "SOSCCRemovePeersFromCircle", " enableTelemetry=YES ", buf, 2u);
  }

  uint64_t v8 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v17 = v5;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCRemovePeersFromCircle  enableTelemetry=YES ", buf, 0xCu);
  }

  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  _DWORD v15[2] = sub_100222658;
  v15[3] = &unk_100309158;
  void v15[4] = a1;
  BOOL v9 = sub_100220170(a2, v15);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  char v11 = _OctagonSignpostLogSystem();
  long long v12 = v11;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
  {
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v17) = v9;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v12, OS_SIGNPOST_INTERVAL_END, v5, "SOSCCRemovePeersFromCircle", " SOSSignpostNameSOSCCRemovePeersFromCircle=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCRemovePeersFromCircle}d ", buf, 8u);
  }

  int v13 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218496;
    os_signpost_id_t v17 = v5;
    __int16 v18 = 2048;
    double v19 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v20 = 1026;
    BOOL v21 = v9;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCRemovePeersFromCircle  SOSSignpostNameSOSCCRemovePeersFromCircle=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCRemovePeersFromCircle}d ", buf, 0x1Cu);
  }

  return v9;
}

uint64_t sub_100222658(uint64_t a1, void *a2, uint64_t a3)
{
  os_signpost_id_t v5 = [a2 account];
  uint64_t v6 = sub_1001E6414(v5, *(const __CFArray **)(a1 + 32), a3);

  return v6;
}

void sub_1002226AC()
{
  id v0 = SOSCCCredentialQueue();
  dispatch_async(v0, &stru_100309198);
}

void sub_1002226F4(id a1)
{
  CFTypeRef cf = 0;
  if (!sub_100220170(&cf, &stru_1003091B8) || cf != 0)
  {
    BOOL v2 = sub_10000B070("SecError");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      CFTypeRef v6 = cf;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "circleOps: error delivering account-sign-in notification: %@", buf, 0xCu);
    }

    CFTypeRef v3 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v3);
    }
  }
}

BOOL sub_1002227D4(id a1, SOSAccountTransaction *a2, __CFError **a3)
{
  CFTypeRef v3 = a2;
  id v4 = sub_10000B070("circleOps");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)BOOL v7 = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Signed into account!", v7, 2u);
  }

  os_signpost_id_t v5 = [(SOSAccountTransaction *)v3 account];

  [v5 setAccountIsChanging:0];
  return 1;
}

BOOL sub_100222878(CFTypeRef *a1)
{
  BOOL v2 = _OctagonSignpostLogSystem();
  os_signpost_id_t v3 = _OctagonSignpostCreate();

  id v4 = _OctagonSignpostLogSystem();
  os_signpost_id_t v5 = v4;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v4))
  {
    LOWORD(v13) = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "SOSCCLoggedOutOfAccount", " enableTelemetry=YES ", (uint8_t *)&v13, 2u);
  }

  CFTypeRef v6 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = 134217984;
    os_signpost_id_t v14 = v3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCLoggedOutOfAccount  enableTelemetry=YES ", (uint8_t *)&v13, 0xCu);
  }

  BOOL v7 = sub_100220170(a1, &stru_1003091D8);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  BOOL v9 = _OctagonSignpostLogSystem();
  int v10 = v9;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    int v13 = 67240192;
    LODWORD(v14) = v7;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v10, OS_SIGNPOST_INTERVAL_END, v3, "SOSCCLoggedOutOfAccount", " SOSSignpostNameSOSCCLoggedOutOfAccount=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCLoggedOutOfAccount}d ", (uint8_t *)&v13, 8u);
  }

  char v11 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = 134218496;
    os_signpost_id_t v14 = v3;
    __int16 v15 = 2048;
    double v16 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v17 = 1026;
    BOOL v18 = v7;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCLoggedOutOfAccount  SOSSignpostNameSOSCCLoggedOutOfAccount=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCLoggedOutOfAccount}d ", (uint8_t *)&v13, 0x1Cu);
  }

  return v7;
}

BOOL sub_100222AA8(id a1, SOSAccountTransaction *a2, __CFError **a3)
{
  id v4 = a2;
  os_signpost_id_t v5 = sub_10000B070("circleOps");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)os_signpost_id_t v14 = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Signed out of account!", v14, 2u);
  }

  CFTypeRef v6 = [(SOSAccountTransaction *)v4 account];
  BOOL v7 = [v6 trust];
  uint64_t v8 = [(SOSAccountTransaction *)v4 account];
  unsigned __int8 v9 = [v7 leaveCircle:v8 err:a3];

  [(SOSAccountTransaction *)v4 restart];
  int v10 = [(SOSAccountTransaction *)v4 account];
  sub_10021D758(1);

  char v11 = [(SOSAccountTransaction *)v4 account];
  sub_1001E4DD0(v11);

  long long v12 = [(SOSAccountTransaction *)v4 account];

  [v12 setAccountIsChanging:1];
  return v9;
}

BOOL sub_100222BE4(uint64_t a1, CFTypeRef *a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100222C58;
  v3[3] = &unk_100309158;
  void v3[4] = a1;
  return sub_100220170(a2, v3);
}

uint64_t sub_100222C58(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  CFTypeRef v6 = [v5 account];
  uint64_t v7 = *(void *)(a1 + 32);
  id v8 = v6;
  unsigned __int8 v9 = dispatch_get_global_queue(-2, 0);
  int v10 = dispatch_group_create();
  char v11 = [v8 trust];
  long long v12 = sub_10000B070("circle");
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(v1_Block_object_dispose(&a9, 8) = 134217984;
    *(void *)((char *)&v18 + 4) = v7;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Attempting to leave circle - best effort - in %llu seconds\n", (uint8_t *)&v18, 0xCu);
  }

  *(void *)&long long v18 = _NSConcreteStackBlock;
  *((void *)&v18 + 1) = 3221225472;
  double v19 = sub_1001E68E8;
  __int16 v20 = &unk_1003075B8;
  id v21 = v11;
  id v22 = v8;
  uint64_t v23 = a3;
  id v13 = v8;
  id v14 = v11;
  dispatch_group_async(v10, v9, &v18);
  dispatch_time_t v15 = dispatch_time(0, 1000000000 * v7);
  dispatch_group_wait(v10, v15);
  [v14 setDepartureCode:2];

  [v5 restart];
  double v16 = [v5 account];

  sub_10021D758(0);
  return 0;
}

uint64_t sub_100222E50(CFTypeRef *a1)
{
  uint64_t v16 = 0;
  __int16 v17 = &v16;
  uint64_t v18 = 0x2020000000;
  uint64_t v19 = 0;
  BOOL v2 = _OctagonSignpostLogSystem();
  os_signpost_id_t v3 = _OctagonSignpostCreate();

  id v4 = _OctagonSignpostLogSystem();
  id v5 = v4;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v4))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "SOSCCCopyApplicantPeerInfo", " enableTelemetry=YES ", buf, 2u);
  }

  CFTypeRef v6 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v21 = v3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCCopyApplicantPeerInfo  enableTelemetry=YES ", buf, 0xCu);
  }

  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  _DWORD v15[2] = sub_100223148;
  v15[3] = &unk_1003090F0;
  void v15[4] = &v16;
  sub_10021CD84(a1, v15);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  id v8 = _OctagonSignpostLogSystem();
  unsigned __int8 v9 = v8;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v8))
  {
    BOOL v10 = v17[3] != 0;
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v21) = v10;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v9, OS_SIGNPOST_INTERVAL_END, v3, "SOSCCCopyApplicantPeerInfo", " SOSSignpostNameSOSCCCopyApplicantPeerInfo=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCopyApplicantPeerInfo}d ", buf, 8u);
  }

  char v11 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = v17[3];
    *(_DWORD *)long long buf = 134218496;
    os_signpost_id_t v21 = v3;
    __int16 v22 = 2048;
    double v23 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v24 = 1026;
    BOOL v25 = v12 != 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCCopyApplicantPeerInfo  SOSSignpostNameSOSCCCopyApplicantPeerInfo=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCopyApplicantPeerInfo}d ", buf, 0x1Cu);
  }

  uint64_t v13 = v17[3];
  _Block_object_dispose(&v16, 8);
  return v13;
}

void sub_100223110(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_100223148(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = [a2 account];
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = sub_1001F112C(v5, a3, &stru_100307D40);

  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

uint64_t sub_1002231B8(CFTypeRef *a1)
{
  uint64_t v4 = 0;
  id v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100223274;
  v3[3] = &unk_1003090F0;
  void v3[4] = &v4;
  sub_10021CD84(a1, v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_10022325C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_100223274(uint64_t a1, void *a2)
{
  id v3 = [a2 account];
  uint64_t v4 = [v3 trust];
  id v5 = sub_1001EEC4C(v3);

  if (!v5) {
    goto LABEL_6;
  }
  if (![v4 trustedCircle])
  {
    SOSErrorCreate();
LABEL_6:
    CFArrayRef v14 = 0;
    goto LABEL_4;
  }
  [v4 trustedCircle];
  uint64_t Generation = SOSCircleGetGeneration();
  CFArrayRef v14 = sub_100146438(kCFAllocatorDefault, v7, v8, v9, v10, v11, v12, v13, Generation);
LABEL_4:

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v14;
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

uint64_t sub_100223364(CFTypeRef *a1)
{
  uint64_t v17 = 0;
  uint64_t v18 = &v17;
  uint64_t v19 = 0x2020000000;
  uint64_t v20 = 0;
  BOOL v2 = _OctagonSignpostLogSystem();
  os_signpost_id_t v3 = _OctagonSignpostCreate();

  uint64_t v4 = _OctagonSignpostLogSystem();
  id v5 = v4;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v4))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "SOSCCCopyValidPeerPeerInfo", " enableTelemetry=YES ", buf, 2u);
  }

  uint64_t v6 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v22 = v3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCCopyValidPeerPeerInfo  enableTelemetry=YES ", buf, 0xCu);
  }

  v16[0] = _NSConcreteStackBlock;
  v16[1] = 3221225472;
  void v16[2] = sub_10022366C;
  v16[3] = &unk_1003090F0;
  void v16[4] = &v17;
  sub_10021CD84(a1, v16);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  uint64_t v9 = _OctagonSignpostLogSystem();
  uint64_t v10 = v9;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
  {
    BOOL v11 = v18[3] != 0;
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v22) = v11;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v10, OS_SIGNPOST_INTERVAL_END, v3, "SOSCCCopyValidPeerPeerInfo", " SOSSignpostNameSOSCCCopyValidPeerPeerInfo=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCopyValidPeerPeerInfo}d ", buf, 8u);
  }

  uint64_t v12 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = v18[3];
    *(_DWORD *)long long buf = 134218496;
    os_signpost_id_t v22 = v3;
    __int16 v23 = 2048;
    double v24 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v25 = 1026;
    BOOL v26 = v13 != 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCCopyValidPeerPeerInfo  SOSSignpostNameSOSCCCopyValidPeerPeerInfo=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCopyValidPeerPeerInfo}d ", buf, 0x1Cu);
  }

  uint64_t v14 = v18[3];
  _Block_object_dispose(&v17, 8);
  return v14;
}

void sub_100223634(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_10022366C(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  [v5 account];
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  v11[2] = sub_1001F12A0;
  v11[3] = &unk_100307C70;
  id v12 = (id)objc_claimAutoreleasedReturnValue();
  id v7 = v12;
  CFMutableArrayRef v8 = sub_1001F112C(v7, a3, v11);

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v8;
  BOOL v9 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;

  return v9;
}

uint64_t sub_100223768(CFTypeRef *a1)
{
  uint64_t v16 = 0;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x2020000000;
  char v19 = 0;
  BOOL v2 = _OctagonSignpostLogSystem();
  os_signpost_id_t v3 = _OctagonSignpostCreate();

  uint64_t v4 = _OctagonSignpostLogSystem();
  id v5 = v4;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v4))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "SOSCCValidateUserPublic", " enableTelemetry=YES ", buf, 2u);
  }

  uint64_t v6 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v21 = v3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCValidateUserPublic  enableTelemetry=YES ", buf, 0xCu);
  }

  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  _DWORD v15[2] = sub_100223A50;
  v15[3] = &unk_1003090F0;
  void v15[4] = &v16;
  sub_10021CD84(a1, v15);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  CFMutableArrayRef v8 = _OctagonSignpostLogSystem();
  BOOL v9 = v8;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v8))
  {
    int v10 = *((unsigned __int8 *)v17 + 24);
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v21) = v10;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v9, OS_SIGNPOST_INTERVAL_END, v3, "SOSCCValidateUserPublic", " SOSSignpostNameSOSCCValidateUserPublic=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCValidateUserPublic}d ", buf, 8u);
  }

  BOOL v11 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218496;
    int v12 = *((unsigned __int8 *)v17 + 24);
    os_signpost_id_t v21 = v3;
    __int16 v22 = 2048;
    double v23 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v24 = 1026;
    int v25 = v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCValidateUserPublic  SOSSignpostNameSOSCCValidateUserPublic=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCValidateUserPublic}d ", buf, 0x1Cu);
  }

  uint64_t v13 = *((unsigned __int8 *)v17 + 24);
  _Block_object_dispose(&v16, 8);
  return v13;
}

void sub_100223A18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100223A50(uint64_t a1, void *a2)
{
  id v3 = [a2 account];
  if (sub_1001EEC4C(v3)) {
    unsigned __int8 v4 = [v3 accountKeyIsTrusted];
  }
  else {
    unsigned __int8 v4 = 0;
  }

  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v4;
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

uint64_t sub_100223AD0(CFTypeRef *a1)
{
  uint64_t v4 = 0;
  id v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100223B8C;
  v3[3] = &unk_1003090F0;
  void v3[4] = &v4;
  sub_10021CD84(a1, v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_100223B74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_100223B8C(uint64_t a1, void *a2, uint64_t a3)
{
  [a2 account];
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  void v8[2] = sub_1001F109C;
  v8[3] = &unk_100307C70;
  id v9 = (id)objc_claimAutoreleasedReturnValue();
  id v5 = v9;
  CFMutableArrayRef v6 = sub_1001F112C(v5, a3, v8);

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v6;
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

uint64_t sub_100223C60(CFTypeRef *a1)
{
  uint64_t v4 = 0;
  id v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100223D1C;
  v3[3] = &unk_1003090F0;
  void v3[4] = &v4;
  sub_10021CD84(a1, v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_100223D04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_100223D1C(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = [a2 account];
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = sub_1001F112C(v5, a3, &stru_100307D00);

  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

uint64_t sub_100223D8C(CFTypeRef *a1)
{
  uint64_t v16 = 0;
  uint64_t v17 = &v16;
  uint64_t v18 = 0x2020000000;
  uint64_t v19 = 0;
  BOOL v2 = _OctagonSignpostLogSystem();
  os_signpost_id_t v3 = _OctagonSignpostCreate();

  uint64_t v4 = _OctagonSignpostLogSystem();
  id v5 = v4;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v4))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "SOSCCCopyViewUnawarePeerInfo", " enableTelemetry=YES ", buf, 2u);
  }

  uint64_t v6 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v21 = v3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCCopyViewUnawarePeerInfo  enableTelemetry=YES ", buf, 0xCu);
  }

  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  _DWORD v15[2] = sub_100224084;
  v15[3] = &unk_1003090F0;
  void v15[4] = &v16;
  sub_10021CD84(a1, v15);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  CFMutableArrayRef v8 = _OctagonSignpostLogSystem();
  id v9 = v8;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v8))
  {
    BOOL v10 = v17[3] != 0;
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v21) = v10;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v9, OS_SIGNPOST_INTERVAL_END, v3, "SOSCCCopyViewUnawarePeerInfo", " SOSSignpostNameSOSCCCopyViewUnawarePeerInfo=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCopyViewUnawarePeerInfo}d ", buf, 8u);
  }

  BOOL v11 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = v17[3];
    *(_DWORD *)long long buf = 134218496;
    os_signpost_id_t v21 = v3;
    __int16 v22 = 2048;
    double v23 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v24 = 1026;
    BOOL v25 = v12 != 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCCopyViewUnawarePeerInfo  SOSSignpostNameSOSCCCopyViewUnawarePeerInfo=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCopyViewUnawarePeerInfo}d ", buf, 0x1Cu);
  }

  uint64_t v13 = v17[3];
  _Block_object_dispose(&v16, 8);
  return v13;
}

void sub_10022404C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_100224084(uint64_t a1, void *a2, uint64_t a3)
{
  [a2 account];
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  void v8[2] = sub_1001F1620;
  v8[3] = &unk_100307C70;
  id v9 = (id)objc_claimAutoreleasedReturnValue();
  id v5 = v9;
  CFMutableArrayRef v6 = sub_1001F112C(v5, a3, v8);

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v6;
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

uint64_t sub_100224158(CFTypeRef *a1)
{
  uint64_t v2 = sub_10000CF0C(0);
  uint64_t v3 = sub_100134054(v2);
  sub_1000297D0(v3 != 0, a1, @"No datasource");
  if (!v3) {
    return 0;
  }
  uint64_t v4 = (uint64_t *)(*(uint64_t (**)(uint64_t, const CFStringRef, CFTypeRef *))(v3 + 8))(v3, kSecAttrAccessibleWhenUnlocked, a1);
  if (!v4) {
    return 0;
  }
  id v5 = v4;
  uint64_t v6 = sub_100105650(*v4, (uint64_t)a1);
  ((void (*)(uint64_t *, CFTypeRef *))v5[9])(v5, a1);
  return v6;
}

BOOL sub_1002241FC(CFTypeRef *a1)
{
  uint64_t v50 = 0;
  __int16 v51 = &v50;
  uint64_t v52 = 0x3032000000;
  id v53 = sub_100224988;
  uint64_t v54 = sub_100224998;
  id v55 = 0;
  v48[0] = 0;
  v48[1] = v48;
  void v48[2] = 0x2020000000;
  char v49 = 0;
  uint64_t v44 = 0;
  id v45 = &v44;
  uint64_t v46 = 0x2020000000;
  uint64_t v47 = 0;
  uint64_t v40 = 0;
  unsigned __int8 v41 = &v40;
  uint64_t v42 = 0x2020000000;
  unint64_t v43 = 0xAAAAAAAAAAAAAAAALL;
  v39[0] = 0;
  v39[1] = v39;
  v39[2] = 0x2020000000;
  v39[3] = kCFBooleanFalse;
  uint64_t v35 = 0;
  uint64_t v36 = &v35;
  uint64_t v37 = 0x2020000000;
  char v38 = 0;
  if (sub_1002249A0())
  {
    uint64_t v2 = _OctagonSignpostLogSystem();
    os_signpost_id_t v3 = _OctagonSignpostCreate();

    uint64_t v4 = _OctagonSignpostLogSystem();
    id v5 = v4;
    if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v4))
    {
      *(_WORD *)long long buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "SOSCCWaitForInitialSync", " enableTelemetry=YES ", buf, 2u);
    }

    uint64_t v6 = _OctagonSignpostLogSystem();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      *(void *)&uint8_t buf[4] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCWaitForInitialSync  enableTelemetry=YES ", buf, 0xCu);
    }

    uint64_t v7 = sub_10000B070("initial sync");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Wait for initial sync start!", buf, 2u);
    }

    v34[0] = _NSConcreteStackBlock;
    v34[1] = 3221225472;
    v34[2] = sub_100224A5C;
    v34[3] = &unk_100309228;
    v34[4] = v39;
    v34[5] = &v35;
    v34[6] = &v40;
    v34[7] = &v50;
    v34[8] = &v44;
    v34[9] = v48;
    v34[10] = a1;
    BOOL v8 = sub_10021CD84(a1, v34);
    if (v8)
    {
      if (v51[5])
      {
        if (*((unsigned char *)v36 + 24))
        {
          id v9 = sub_10000B070("piggy");
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "setting initial sync timeout to 5 minutes", buf, 2u);
          }

          BOOL v10 = v51[5];
          int64_t v11 = 300000000000;
        }
        else
        {
          *(void *)long long buf = 10;
          CFNumberRef v12 = (const __CFNumber *)CFPreferencesCopyValue(@"InitialSync.WaitPeriod", @"com.apple.security", kCFPreferencesAnyUser, kCFPreferencesCurrentHost);
          CFNumberRef v13 = v12;
          if (v12)
          {
            CFTypeID v14 = CFGetTypeID(v12);
            if (v14 == CFNumberGetTypeID()) {
              CFNumberGetValue(v13, kCFNumberSInt64Type, buf);
            }
            CFRelease(v13);
            uint64_t v15 = *(void *)buf;
          }
          else
          {
            uint64_t v15 = 10;
          }
          uint64_t v16 = sub_10000B070("piggy");
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 134217984;
            *(void *)&uint8_t buf[4] = v15;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "setting initial sync timeout to %llu seconds", buf, 0xCu);
          }

          BOOL v10 = v51[5];
          int64_t v11 = 1000000000 * v15;
        }
        dispatch_time_t v17 = dispatch_time(0, v11);
        if (dispatch_semaphore_wait(v10, v17) && *((unsigned char *)v36 + 24))
        {
          v33[0] = _NSConcreteStackBlock;
          v33[1] = 3221225472;
          id v33[2] = sub_100224D4C;
          v33[3] = &unk_100309250;
          void v33[4] = &v44;
          v33[5] = &v50;
          sub_10021BA54(v33);
        }
      }
      uint64_t v61 = SecCoreAnalyticsValue;
      uint64_t v18 = v41[3];
      time_t v19 = time(0);
      unint64_t v20 = v19 - v18;
      uint64_t v21 = 1;
      if (v19 - v18 >= 11)
      {
        unint64_t v22 = v19 - v18;
        do
        {
          unint64_t v20 = v22 / 0xA;
          v21 *= 10;
          BOOL v23 = v22 > 0x6D;
          v22 /= 0xAuLL;
        }
        while (v23);
      }
      __int16 v24 = +[NSNumber numberWithLong:v21 * v20];
      long long v62 = v24;
      BOOL v25 = +[NSDictionary dictionaryWithObjects:&v62 forKeys:&v61 count:1];
      +[SecCoreAnalytics sendEvent:@"com.apple.security.sos.synccompletion" event:v25];

      BOOL v26 = sub_10000B070("initial sync");
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)&uint8_t buf[4] = 1;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Finished!: %d", buf, 8u);
      }
    }
    CFStringRef v27 = (const void *)v45[3];
    if (v27)
    {
      v45[3] = 0;
      CFRelease(v27);
    }
    uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
    CFStringRef v29 = _OctagonSignpostLogSystem();
    uint64_t v30 = v29;
    if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v29))
    {
      *(_DWORD *)long long buf = 67240192;
      *(_DWORD *)&uint8_t buf[4] = v8;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v30, OS_SIGNPOST_INTERVAL_END, v3, "SOSCCWaitForInitialSync", " SOSSignpostNameSOSCCWaitForInitialSync=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCWaitForInitialSync}d ", buf, 8u);
    }

    double v31 = _OctagonSignpostLogSystem();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134218496;
      *(void *)&uint8_t buf[4] = v3;
      __int16 v57 = 2048;
      double v58 = (double)(unint64_t)Nanoseconds / 1000000000.0;
      __int16 v59 = 1026;
      BOOL v60 = v8;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCWaitForInitialSync  SOSSignpostNameSOSCCWaitForInitialSync=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCWaitForInitialSync}d ", buf, 0x1Cu);
    }
  }
  else
  {
    BOOL v8 = 1;
  }
  _Block_object_dispose(&v35, 8);
  _Block_object_dispose(v39, 8);
  _Block_object_dispose(&v40, 8);
  _Block_object_dispose(&v44, 8);
  _Block_object_dispose(v48, 8);
  _Block_object_dispose(&v50, 8);

  return v8;
}

void sub_100224908(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  _Block_object_dispose(&a27, 8);
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a35, 8);
  _Block_object_dispose(&a39, 8);
  _Block_object_dispose((const void *)(v39 - 240), 8);
  _Block_object_dispose((const void *)(v39 - 208), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100224988(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100224998(uint64_t a1)
{
}

uint64_t sub_1002249A0()
{
  uint64_t v3 = 0;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2020000000;
  char v6 = 0;
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  _DWORD v2[2] = sub_100224E60;
  v2[3] = &unk_100309840;
  void v2[4] = &v3;
  sub_10021BA54(v2);
  uint64_t v0 = *((unsigned __int8 *)v4 + 24);
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_100224A44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100224A5C(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [v3 account];
  *(void *)(*(void *)(a1[4] + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = sub_1001DCC24(v4, @"initialsynctimeout");

  CFBooleanRef v5 = *(const __CFBoolean **)(*(void *)(a1[4] + 8) + 24);
  if (v5) {
    *(unsigned char *)(*(void *)(a1[5] + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = CFBooleanGetValue(v5) != 0;
  }
  char v6 = [v3 account];
  BOOL v7 = sub_1001F7170(v6);

  if (v7)
  {
    *(unsigned char *)(*(void *)(a1[9] + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  }
  else
  {
    *(void *)(*(void *)(a1[6] + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = time(0);
    dispatch_semaphore_t v8 = dispatch_semaphore_create(0);
    uint64_t v9 = *(void *)(a1[7] + 8);
    BOOL v10 = *(void **)(v9 + 40);
    *(void *)(v9 + 40) = v8;

    int64_t v11 = [v3 account];
    __int16 v24 = _NSConcreteStackBlock;
    uint64_t v25 = 3221225472;
    BOOL v26 = sub_100224E24;
    CFStringRef v27 = &unk_100309200;
    uint64_t v12 = a1[7];
    uint64_t v28 = a1[9];
    uint64_t v29 = v12;
    id v13 = v11;
    CFTypeID v14 = &v24;
    if (sub_1001DCC24(v13, @"unsynced"))
    {
      CFUUIDRef v15 = CFUUIDCreate(kCFAllocatorDefault);
      CFStringRef v16 = CFUUIDCreateString(kCFAllocatorDefault, v15);
      if (v15) {
        CFRelease(v15);
      }
      dispatch_time_t v17 = sub_10000B070("initial-sync");
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        CFStringRef v31 = v16;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "adding sync block [%@] to array!", buf, 0xCu);
      }

      uint64_t v18 = objc_retainBlock(v14);
      time_t v19 = [v13 waitForInitialSync_blocks:v24, v25];

      if (!v19)
      {
        unint64_t v20 = +[NSMutableDictionary dictionary];
        [v13 setWaitForInitialSync_blocks:v20];
      }
      uint64_t v21 = [v13 waitForInitialSync_blocks];
      unint64_t v22 = objc_retainBlock(v18);
      [v21 setObject:v22 forKey:v16];
    }
    else
    {
      ((void (*)(void ***, id))v26)(v14, v13);
      CFStringRef v16 = 0;
    }

    *(void *)(*(void *)(a1[8] + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v16;
  }

  return 1;
}

void sub_100224D4C(uint64_t a1, void *a2)
{
  id v3 = [a2 account];
  uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  id v9 = v3;
  CFBooleanRef v5 = [v9 waitForInitialSync_blocks];

  if (v5)
  {
    char v6 = [v9 waitForInitialSync_blocks];
    [v6 removeObjectForKey:v4];

    uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
    dispatch_semaphore_t v8 = *(void **)(v7 + 40);
    if (!v8) {
      return;
    }
    *(void *)(v7 + 40) = 0;
  }
  else
  {

    dispatch_semaphore_t v8 = v9;
  }
}

uint64_t sub_100224E24(uint64_t a1)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  uint64_t v1 = *(NSObject **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
  if (v1) {
    dispatch_semaphore_signal(v1);
  }
  return 1;
}

void sub_100224E60(uint64_t a1, void *a2)
{
  id v3 = [a2 account];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = [v3 SOSMonitorModeSOSIsActive];
}

BOOL sub_100224EBC(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v4 = _OctagonSignpostLogSystem();
  os_signpost_id_t v5 = _OctagonSignpostCreate();

  char v6 = _OctagonSignpostLogSystem();
  uint64_t v7 = v6;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v6))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_INTERVAL_BEGIN, v5, "SOSCCAcceptApplicants", " enableTelemetry=YES ", buf, 2u);
  }

  dispatch_semaphore_t v8 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v17 = v5;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCAcceptApplicants  enableTelemetry=YES ", buf, 0xCu);
  }

  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  _DWORD v15[2] = sub_100225134;
  v15[3] = &unk_100309158;
  void v15[4] = a1;
  BOOL v9 = sub_100220170(a2, v15);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  int64_t v11 = _OctagonSignpostLogSystem();
  uint64_t v12 = v11;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
  {
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v17) = v9;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v12, OS_SIGNPOST_INTERVAL_END, v5, "SOSCCAcceptApplicants", " SOSSignpostNameSOSCCAcceptApplicants=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCAcceptApplicants}d ", buf, 8u);
  }

  id v13 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218496;
    os_signpost_id_t v17 = v5;
    __int16 v18 = 2048;
    double v19 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v20 = 1026;
    BOOL v21 = v9;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCAcceptApplicants  SOSSignpostNameSOSCCAcceptApplicants=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCAcceptApplicants}d ", buf, 0x1Cu);
  }

  return v9;
}

BOOL sub_100225134(uint64_t a1, void *a2, uint64_t a3)
{
  os_signpost_id_t v5 = [a2 account];
  CFArrayRef v6 = *(const __CFArray **)(a1 + 32);
  id v7 = v5;
  id v8 = sub_1001EE508(v7);
  if (v8)
  {
    uint64_t v13 = 0;
    CFTypeID v14 = &v13;
    uint64_t v15 = 0x2020000000;
    uint64_t v16 = 0;
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472;
    _DWORD v12[2] = sub_1001E6A28;
    v12[3] = &unk_1003075E0;
    void v12[5] = v8;
    void v12[6] = a3;
    void v12[4] = &v13;
    sub_1001E6A70(v7, (uint64_t)v6, v12);
    uint64_t v9 = v14[3];
    BOOL v10 = v9 == CFArrayGetCount(v6);
    _Block_object_dispose(&v13, 8);
  }
  else
  {
    BOOL v10 = 0;
  }

  return v10;
}

void sub_100225238(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_100225250(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v4 = _OctagonSignpostLogSystem();
  os_signpost_id_t v5 = _OctagonSignpostCreate();

  CFArrayRef v6 = _OctagonSignpostLogSystem();
  id v7 = v6;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v6))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_INTERVAL_BEGIN, v5, "SOSCCAcceptApplicants", " enableTelemetry=YES ", buf, 2u);
  }

  id v8 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v17 = v5;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCAcceptApplicants  enableTelemetry=YES ", buf, 0xCu);
  }

  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  _DWORD v15[2] = sub_1002254C8;
  v15[3] = &unk_100309158;
  void v15[4] = a1;
  BOOL v9 = sub_100220170(a2, v15);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  int64_t v11 = _OctagonSignpostLogSystem();
  uint64_t v12 = v11;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
  {
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v17) = v9;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v12, OS_SIGNPOST_INTERVAL_END, v5, "SOSCCAcceptApplicants", " SOSSignpostNameSOSCCAcceptApplicants=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCAcceptApplicants}d ", buf, 8u);
  }

  uint64_t v13 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218496;
    os_signpost_id_t v17 = v5;
    __int16 v18 = 2048;
    double v19 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v20 = 1026;
    BOOL v21 = v9;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCAcceptApplicants  SOSSignpostNameSOSCCAcceptApplicants=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCAcceptApplicants}d ", buf, 0x1Cu);
  }

  return v9;
}

uint64_t sub_1002254C8(uint64_t a1, void *a2, uint64_t a3)
{
  os_signpost_id_t v5 = [a2 account];
  uint64_t v6 = *(void *)(a1 + 32);
  id v7 = v5;
  uint64_t v12 = 0;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2020000000;
  char v15 = 1;
  v11[0] = 0;
  v11[1] = v11;
  v11[2] = 0x2020000000;
  v11[3] = 0;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  void v10[2] = sub_1001E6E0C;
  void v10[3] = &unk_100307608;
  v10[5] = v11;
  void v10[6] = a3;
  void v10[4] = &v12;
  sub_1001E6A70(v7, v6, v10);
  uint64_t v8 = *((unsigned __int8 *)v13 + 24);
  _Block_object_dispose(v11, 8);
  _Block_object_dispose(&v12, 8);

  return v8;
}

void sub_1002255C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1002255E8(CFTypeRef *a1)
{
  uint64_t v4 = 0;
  os_signpost_id_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_1002256A4;
  v3[3] = &unk_1003090F0;
  void v3[4] = &v4;
  sub_10021CD84(a1, v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_10022568C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_1002256A4(uint64_t a1, void *a2, uint64_t a3)
{
  os_signpost_id_t v5 = [a2 account];
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = sub_1001F112C(v5, a3, &stru_100307D60);

  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

uint64_t sub_100225714(CFTypeRef *a1)
{
  uint64_t v16 = 0;
  os_signpost_id_t v17 = &v16;
  uint64_t v18 = 0x2020000000;
  uint64_t v19 = 0;
  uint64_t v2 = _OctagonSignpostLogSystem();
  os_signpost_id_t v3 = _OctagonSignpostCreate();

  uint64_t v4 = _OctagonSignpostLogSystem();
  os_signpost_id_t v5 = v4;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v4))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "SOSCCCopyConcurringPeerPeerInfo", " enableTelemetry=YES ", buf, 2u);
  }

  uint64_t v6 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v21 = v3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCCopyConcurringPeerPeerInfo  enableTelemetry=YES ", buf, 0xCu);
  }

  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  _DWORD v15[2] = sub_100225A0C;
  v15[3] = &unk_1003090F0;
  void v15[4] = &v16;
  sub_10021CD84(a1, v15);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  uint64_t v8 = _OctagonSignpostLogSystem();
  uint64_t v9 = v8;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v8))
  {
    BOOL v10 = v17[3] != 0;
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v21) = v10;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v9, OS_SIGNPOST_INTERVAL_END, v3, "SOSCCCopyConcurringPeerPeerInfo", " SOSSignpostNameSOSCCCopyConcurringPeerPeerInfo=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCopyConcurringPeerPeerInfo}d ", buf, 8u);
  }

  int64_t v11 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = v17[3];
    *(_DWORD *)long long buf = 134218496;
    os_signpost_id_t v21 = v3;
    __int16 v22 = 2048;
    double v23 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v24 = 1026;
    BOOL v25 = v12 != 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCCopyConcurringPeerPeerInfo  SOSSignpostNameSOSCCCopyConcurringPeerPeerInfo=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCopyConcurringPeerPeerInfo}d ", buf, 0x1Cu);
  }

  uint64_t v13 = v17[3];
  _Block_object_dispose(&v16, 8);
  return v13;
}

void sub_1002259D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_100225A0C(uint64_t a1, void *a2, uint64_t a3)
{
  os_signpost_id_t v5 = [a2 account];
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = sub_1001F112C(v5, a3, &stru_100307D80);

  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

uint64_t sub_100225A7C(CFTypeRef *a1)
{
  uint64_t v4 = 0;
  os_signpost_id_t v5 = &v4;
  uint64_t v6 = 0x2020000000;
  uint64_t v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100225B38;
  v3[3] = &unk_1003090F0;
  void v3[4] = &v4;
  sub_10021CD84(a1, v3);
  uint64_t v1 = v5[3];
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_100225B20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_100225B38(uint64_t a1, void *a2)
{
  os_signpost_id_t v3 = [a2 account];
  [v3 peerInfo];
  CFStringRef PeerID = (const __CFString *)SOSPeerInfoGetPeerID();

  if (PeerID) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = CFStringCreateCopy(kCFAllocatorDefault, PeerID);
  }
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

uint64_t sub_100225BB8(CFTypeRef *a1)
{
  uint64_t v16 = 0;
  os_signpost_id_t v17 = &v16;
  uint64_t v18 = 0x2020000000;
  uint64_t v19 = 0;
  uint64_t v2 = _OctagonSignpostLogSystem();
  os_signpost_id_t v3 = _OctagonSignpostCreate();

  uint64_t v4 = _OctagonSignpostLogSystem();
  os_signpost_id_t v5 = v4;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v4))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "SOSCCCopyMyPeerInfo", " enableTelemetry=YES ", buf, 2u);
  }

  uint64_t v6 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v21 = v3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCCopyMyPeerInfo  enableTelemetry=YES ", buf, 0xCu);
  }

  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  _DWORD v15[2] = sub_100225EB0;
  v15[3] = &unk_1003090F0;
  void v15[4] = &v16;
  sub_10021CD84(a1, v15);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  uint64_t v8 = _OctagonSignpostLogSystem();
  uint64_t v9 = v8;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v8))
  {
    BOOL v10 = v17[3] != 0;
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v21) = v10;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v9, OS_SIGNPOST_INTERVAL_END, v3, "SOSCCCopyMyPeerInfo", " SOSSignpostNameSOSCCCopyMyPeerInfo=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCopyMyPeerInfo}d ", buf, 8u);
  }

  int64_t v11 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = v17[3];
    *(_DWORD *)long long buf = 134218496;
    os_signpost_id_t v21 = v3;
    __int16 v22 = 2048;
    double v23 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v24 = 1026;
    BOOL v25 = v12 != 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCCopyMyPeerInfo  SOSSignpostNameSOSCCCopyMyPeerInfo=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCopyMyPeerInfo}d ", buf, 0x1Cu);
  }

  uint64_t v13 = v17[3];
  _Block_object_dispose(&v16, 8);
  return v13;
}

void sub_100225E78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_100225EB0(uint64_t a1, void *a2)
{
  os_signpost_id_t v3 = [a2 account];
  [v3 peerInfo];
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = SOSPeerInfoCreateCopy();

  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

uint64_t sub_100225F30(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v19 = 0;
  __int16 v20 = &v19;
  uint64_t v21 = 0x2020000000;
  uint64_t v22 = 0;
  uint64_t v4 = _OctagonSignpostLogSystem();
  os_signpost_id_t v5 = _OctagonSignpostCreate();

  uint64_t v6 = _OctagonSignpostLogSystem();
  uint64_t v7 = v6;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v6))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_INTERVAL_BEGIN, v5, "SOSCCSetNewPublicBackupKey", " enableTelemetry=YES ", buf, 2u);
  }

  uint64_t v8 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v24 = v5;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCSetNewPublicBackupKey  enableTelemetry=YES ", buf, 0xCu);
  }

  uint64_t v9 = sub_10000B070("devRecovery");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "SOSCCSetNewPublicBackupKey_Server acquiring account lock", buf, 2u);
  }

  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472;
  v18[2] = sub_10022627C;
  void v18[3] = &unk_100309278;
  void v18[5] = a1;
  void v18[6] = a2;
  uint8_t v18[4] = &v19;
  sub_100220170(a2, v18);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  int64_t v11 = _OctagonSignpostLogSystem();
  uint64_t v12 = v11;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
  {
    BOOL v13 = v20[3] != 0;
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v13;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v12, OS_SIGNPOST_INTERVAL_END, v5, "SOSCCSetNewPublicBackupKey", " SOSSignpostNameSOSCCSetNewPublicBackupKey=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCSetNewPublicBackupKey}d ", buf, 8u);
  }

  uint64_t v14 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v15 = v20[3];
    *(_DWORD *)long long buf = 134218496;
    os_signpost_id_t v24 = v5;
    __int16 v25 = 2048;
    double v26 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v27 = 1026;
    BOOL v28 = v15 != 0;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCSetNewPublicBackupKey  SOSSignpostNameSOSCCSetNewPublicBackupKey=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCSetNewPublicBackupKey}d ", buf, 0x1Cu);
  }

  uint64_t v16 = v20[3];
  _Block_object_dispose(&v19, 8);
  return v16;
}

void sub_100226244(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_10022627C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = sub_10000B070("devRecovery");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "SOSCCSetNewPublicBackupKey_Server acquired account lock", buf, 2u);
  }

  int v5 = sub_1001EA43C(v3, *(const __CFData **)(a1 + 40), *(void *)(a1 + 48));
  uint64_t v6 = sub_10000B070("devRecovery");
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (v7)
    {
      *(_WORD *)uint64_t v15 = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "SOSCCSetNewPublicBackupKey_Server, new public backup is set in account", v15, 2u);
    }

    [v3 restart];
    uint64_t v8 = [v3 account];
    [v8 peerInfo];
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = SOSPeerInfoCreateCopy();

    uint64_t v6 = sub_10000B070("devRecovery");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v14 = 0;
      uint64_t v9 = "SOSCCSetNewPublicBackupKey_Server, new public backup is set and pushed";
      BOOL v10 = (uint8_t *)&v14;
LABEL_10:
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v9, v10, 2u);
    }
  }
  else if (v7)
  {
    __int16 v13 = 0;
    uint64_t v9 = "SOSCCSetNewPublicBackupKey_Server, could not set new public backup";
    BOOL v10 = (uint8_t *)&v13;
    goto LABEL_10;
  }

  BOOL v11 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
  return v11;
}

BOOL sub_10022643C(uint64_t a1, char a2, CFTypeRef *a3)
{
  uint64_t v6 = _OctagonSignpostLogSystem();
  os_signpost_id_t v7 = _OctagonSignpostCreate();

  uint64_t v8 = _OctagonSignpostLogSystem();
  uint64_t v9 = v8;
  if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v8))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v9, OS_SIGNPOST_INTERVAL_BEGIN, v7, "SOSCCRegisterSingleRecoverySecret", " enableTelemetry=YES ", buf, 2u);
  }

  BOOL v10 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v20 = v7;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCRegisterSingleRecoverySecret  enableTelemetry=YES ", buf, 0xCu);
  }

  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472;
  void v17[2] = sub_1002266C4;
  void v17[3] = &unk_100309298;
  char v18 = a2;
  void v17[4] = a1;
  void v17[5] = a3;
  BOOL v11 = sub_100220170(a3, v17);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  __int16 v13 = _OctagonSignpostLogSystem();
  __int16 v14 = v13;
  if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v13))
  {
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v20) = v11;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v14, OS_SIGNPOST_INTERVAL_END, v7, "SOSCCRegisterSingleRecoverySecret", " SOSSignpostNameSOSCCRegisterSingleRecoverySecret=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCRegisterSingleRecoverySecret}d ", buf, 8u);
  }

  uint64_t v15 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218496;
    os_signpost_id_t v20 = v7;
    __int16 v21 = 2048;
    double v22 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v23 = 1026;
    BOOL v24 = v11;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCRegisterSingleRecoverySecret  SOSSignpostNameSOSCCRegisterSingleRecoverySecret=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCRegisterSingleRecoverySecret}d ", buf, 0x1Cu);
  }

  return v11;
}

BOOL sub_1002266C4(uint64_t a1, void *a2)
{
  id v3 = [a2 account];
  int v4 = *(unsigned __int8 *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 32);
  int v5 = *(__CFString ***)(a1 + 40);
  id v7 = v3;
  uint64_t v33 = 0;
  CFStringRef v34 = &v33;
  uint64_t v35 = 0x2020000000;
  char v36 = 0;
  uint64_t v8 = (uint64_t)[v7 isInCircle:v5];
  if (v8)
  {
    if (v4)
    {
      CFDictionaryRef v16 = sub_1001E9524(v8, v9, v10, v11, v12, v13, v14, v15);
      CFDictionaryRef v24 = sub_100139704(kCFAllocatorDefault, v17, v18, v19, v20, v21, v22, v23, (uint64_t)kSecValueData, v6);
      OSStatus v25 = SecItemUpdate(v16, v24);
      if (v25 == -25300)
      {
        MutableCFStringRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, v16);
        *(void *)&long long context = _NSConcreteStackBlock;
        *((void *)&context + 1) = 3221225472;
        char v38 = sub_1001EA7F8;
        uint64_t v39 = &unk_100308F10;
        CFMutableDictionaryRef v40 = MutableCopy;
        CFDictionaryApplyFunction(v24, (CFDictionaryApplierFunction)sub_1001EA844, &context);
        OSStatus v25 = SecItemAdd(MutableCopy, 0);
        if (MutableCopy) {
          CFRelease(MutableCopy);
        }
      }
      BOOL v27 = sub_100012A40(v25, v5, @"Error saving %@", v16);
      if (v16) {
        CFRelease(v16);
      }
      if (v24) {
        CFRelease(v24);
      }
      *((unsigned char *)v34 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v27;
      if (!v27)
      {
        BOOL v28 = sub_10000B070("keybag");
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v29 = *v5;
          LODWORD(context) = 138412290;
          *(void *)((char *)&context + 4) = v29;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "failed to set V0 keybag (%@)", (uint8_t *)&context, 0xCu);
        }
      }
    }
    else
    {
      *((unsigned char *)v34 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
      Direct = (const void *)SOSBackupSliceKeyBagCreateDirect();
      *(void *)&long long context = _NSConcreteStackBlock;
      *((void *)&context + 1) = 3221225472;
      char v38 = sub_1001EA800;
      uint64_t v39 = &unk_100307AC0;
      unsigned __int8 v41 = &v33;
      CFMutableDictionaryRef v40 = (CFMutableDictionaryRef)v7;
      uint64_t v42 = Direct;
      unint64_t v43 = v5;
      sub_1001E9DAC(v40, &context);

      if (Direct) {
        CFRelease(Direct);
      }
    }
  }
  BOOL v31 = *((unsigned char *)v34 + 24) != 0;
  _Block_object_dispose(&v33, 8);

  return v31;
}

void sub_1002269B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_start(va, a5);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1002269D8(CFTypeRef *a1)
{
  uint64_t v4 = 0;
  int v5 = &v4;
  uint64_t v6 = 0x2020000000;
  int v7 = 0;
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100226A94;
  v3[3] = &unk_1003090F0;
  void v3[4] = &v4;
  sub_10021CD84(a1, v3);
  uint64_t v1 = *((unsigned int *)v5 + 6);
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_100226A7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_100226A94(uint64_t a1, void *a2)
{
  id v3 = [a2 account];
  uint64_t v4 = [v3 trust];
  unsigned int v5 = [v4 departureCode];

  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v5;
  return *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

BOOL sub_100226B08(int a1, CFTypeRef *a2)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100226B7C;
  v3[3] = &unk_100308F90;
  int v4 = a1;
  return sub_10021CD84(a2, v3);
}

uint64_t sub_100226B7C(uint64_t a1, void *a2)
{
  id v3 = [a2 account];
  uint64_t v4 = *(unsigned int *)(a1 + 32);
  unsigned int v5 = [v3 trust];
  [v5 setDepartureCode:v4];

  return 1;
}

BOOL sub_100226BD8(CFTypeRef *a1)
{
  uint64_t v2 = sub_10000B070("updates");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v14) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Request for registering peers", (uint8_t *)&v14, 2u);
  }

  id v3 = _OctagonSignpostLogSystem();
  os_signpost_id_t v4 = _OctagonSignpostCreate();

  unsigned int v5 = _OctagonSignpostLogSystem();
  uint64_t v6 = v5;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v5))
  {
    LOWORD(v14) = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v6, OS_SIGNPOST_INTERVAL_BEGIN, v4, "SOSCCProcessEnsurePeerRegistration", " enableTelemetry=YES ", (uint8_t *)&v14, 2u);
  }

  int v7 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = 134217984;
    os_signpost_id_t v15 = v4;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCProcessEnsurePeerRegistration  enableTelemetry=YES ", (uint8_t *)&v14, 0xCu);
  }

  BOOL v8 = sub_100220170(a1, &stru_1003092B8);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  int v10 = _OctagonSignpostLogSystem();
  int v11 = v10;
  if (v4 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v10))
  {
    int v14 = 67240192;
    LODWORD(v15) = v8;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v11, OS_SIGNPOST_INTERVAL_END, v4, "SOSCCProcessEnsurePeerRegistration", " SOSSignpostNameSOSCCProcessEnsurePeerRegistration=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCProcessEnsurePeerRegistration}d ", (uint8_t *)&v14, 8u);
  }

  int v12 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = 134218496;
    os_signpost_id_t v15 = v4;
    __int16 v16 = 2048;
    double v17 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v18 = 1026;
    BOOL v19 = v8;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCProcessEnsurePeerRegistration  SOSSignpostNameSOSCCProcessEnsurePeerRegistration=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCProcessEnsurePeerRegistration}d ", (uint8_t *)&v14, 0x1Cu);
  }

  return v8;
}

BOOL sub_100226E54(id a1, SOSAccountTransaction *a2, __CFError **a3)
{
  id v3 = a2;
  os_signpost_id_t v4 = [(SOSAccountTransaction *)v3 account];
  unsigned int v5 = [v4 SOSMonitorModeSOSIsActive];

  if (v5)
  {
    uint64_t v6 = [(SOSAccountTransaction *)v3 account];
    sub_1001E6E98(v6);
  }
  return 1;
}

uint64_t sub_100226EBC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!sub_1002249A0()) {
    return 0;
  }
  if (qword_10035D458 != -1) {
    dispatch_once(&qword_10035D458, &stru_1003092D8);
  }
  uint64_t v13 = 0;
  int v14 = &v13;
  uint64_t v15 = 0x2020000000;
  CFMutableSetRef Mutable = (CFMutableSetRef)0xAAAAAAAAAAAAAAAALL;
  CFMutableSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  uint64_t v9 = 0;
  int v10 = &v9;
  uint64_t v11 = 0x2020000000;
  CFMutableSetRef v12 = (CFMutableSetRef)0xAAAAAAAAAAAAAAAALL;
  CFMutableSetRef v12 = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  if (!a1)
  {
    a1 = v10[3];
    if (a2) {
      goto LABEL_6;
    }
LABEL_10:
    a2 = v10[3];
    goto LABEL_6;
  }
  if (!a2) {
    goto LABEL_10;
  }
LABEL_6:
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100227068;
  block[3] = &unk_100309328;
  block[6] = a1;
  block[7] = a2;
  block[8] = a3;
  void block[4] = &v13;
  void block[5] = &v9;
  dispatch_sync((dispatch_queue_t)qword_10035D450, block);
  uint64_t v6 = v14[3];
  _Block_object_dispose(&v9, 8);
  _Block_object_dispose(&v13, 8);
  return v6;
}

void sub_100227050(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 96), 8);
  _Unwind_Resume(a1);
}

void sub_100227068(uint64_t a1)
{
  uint64_t v2 = _OctagonSignpostLogSystem();
  os_signpost_id_t v3 = _OctagonSignpostCreate();

  os_signpost_id_t v4 = _OctagonSignpostLogSystem();
  unsigned int v5 = v4;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v4))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "SOSCCProcessSyncWithPeers", " enableTelemetry=YES ", buf, 2u);
  }

  uint64_t v6 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCProcessSyncWithPeers  enableTelemetry=YES ", buf, 0xCu);
  }

  CFIndex Count = CFSetGetCount(*(CFSetRef *)(a1 + 48));
  if (CFSetGetCount(*(CFSetRef *)(a1 + 56)) + Count > 6)
  {
    CFSetRef v10 = *(const __CFSet **)(a1 + 56);
    if (v10 && CFSetGetCount(v10))
    {
      CFSetRef v11 = *(const __CFSet **)(a1 + 56);
      uint64_t v12 = *(void *)(a1 + 64);
      v28[0] = _NSConcreteStackBlock;
      v28[1] = 3221225472;
      v28[2] = sub_10022779C;
      void v28[3] = &unk_100309300;
      int8x16_t v29 = vextq_s8(*(int8x16_t *)(a1 + 32), *(int8x16_t *)(a1 + 32), 8uLL);
      sub_100227824(v11, v12, v28);
    }
    CFSetRef v13 = *(const __CFSet **)(a1 + 48);
    if (v13 && CFSetGetCount(v13))
    {
      CFSetRef v14 = *(const __CFSet **)(a1 + 48);
      uint64_t v15 = *(void *)(a1 + 64);
      v26[0] = _NSConcreteStackBlock;
      v26[1] = 3221225472;
      v26[2] = sub_100227A04;
      v26[3] = &unk_100309300;
      int8x16_t v27 = vextq_s8(*(int8x16_t *)(a1 + 32), *(int8x16_t *)(a1 + 32), 8uLL);
      sub_100227824(v14, v15, v26);
    }
  }
  else
  {
    uint64_t v8 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    uint64_t v9 = *(CFTypeRef **)(a1 + 64);
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 3221225472;
    *(void *)&uint8_t buf[16] = sub_100227464;
    BOOL v31 = &unk_100309978;
    long long v32 = *(_OWORD *)(a1 + 48);
    uint64_t v33 = v8;
    sub_100220170(v9, buf);
  }
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  double v17 = _OctagonSignpostLogSystem();
  __int16 v18 = v17;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v17))
  {
    CFIndex v19 = CFSetGetCount(*(CFSetRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
    *(_DWORD *)long long buf = 67240192;
    *(_DWORD *)&uint8_t buf[4] = v19 != 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v18, OS_SIGNPOST_INTERVAL_END, v3, "SOSCCProcessSyncWithPeers", " SOSSignpostNameSOSCCProcessSyncWithPeers=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCProcessSyncWithPeers}d ", buf, 8u);
  }

  int v20 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    CFIndex v21 = CFSetGetCount(*(CFSetRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
    *(_DWORD *)long long buf = 134218496;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(double *)&buf[14] = (double)(unint64_t)Nanoseconds / 1000000000.0;
    *(_WORD *)&buf[22] = 1026;
    LODWORD(v31) = v21 != 0;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCProcessSyncWithPeers  SOSSignpostNameSOSCCProcessSyncWithPeers=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCProcessSyncWithPeers}d ", buf, 0x1Cu);
  }

  if (!CFSetGetCount(*(CFSetRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)))
  {
    uint64_t v22 = *(void *)(*(void *)(a1 + 32) + 8);
    int v23 = *(const void **)(v22 + 24);
    if (v23)
    {
      *(void *)(v22 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
      CFRelease(v23);
    }
  }
  uint64_t v24 = *(void *)(*(void *)(a1 + 40) + 8);
  OSStatus v25 = *(const void **)(v24 + 24);
  if (v25)
  {
    *(void *)(v24 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
    CFRelease(v25);
  }
}

uint64_t sub_100227464(void *a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  uint64_t v6 = [v5 account];
  unsigned int v7 = [v6 SOSMonitorModeSOSIsActive];

  if (v7)
  {
    CFSetRef v8 = (const __CFSet *)a1[4];
    uint64_t v9 = a1[5];
    id v10 = v5;
    CFTypeRef cf = 0;
    CFSetRef v11 = [v10 account];
    if (sub_1001EC934(v11, a3))
    {
      CFSetRef Mutable = sub_1001ECEF0(v10, v8, (uint64_t)&cf);
      if (!Mutable)
      {
        CFSetRef v13 = sub_10000B070("account-sync");
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 138412290;
          *(void *)((char *)&buf + 4) = cf;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Peer Sync failed: %@", (uint8_t *)&buf, 0xCu);
        }

        CFSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
      }
      CFTypeRef v14 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        CFRelease(v14);
      }
      uint64_t v15 = [v11 kvs_message_transport];
      id v16 = [v15 SOSTransportMessageGetEngine];

      CFSetRef v17 = sub_1001033EC((uint64_t)v16, v9, 0, a3);
      CFSetRef v18 = v17;
      if (v17)
      {
        *(void *)&long long buf = _NSConcreteStackBlock;
        *((void *)&buf + 1) = 3221225472;
        double v26 = sub_1001ED2C0;
        int8x16_t v27 = &unk_100309D30;
        CFSetRef v28 = Mutable;
        CFSetApplyFunction(v17, (CFSetApplierFunction)sub_1001ECED8, &buf);
      }
      else
      {
        CFIndex v19 = sub_10000B070("account-sync");
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 138412290;
          *(void *)((char *)&buf + 4) = cf;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Engine Backup Sync failed: %@", (uint8_t *)&buf, 0xCu);
        }
      }
      CFTypeRef v20 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        CFRelease(v20);
      }
      if (v18) {
        CFRelease(v18);
      }
    }
    else
    {
      CFSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
    }

    CFSetRef v21 = (const __CFSet *)a1[6];
    *(void *)&long long buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 3221225472;
    double v26 = sub_100227B50;
    int8x16_t v27 = &unk_100309D30;
    CFSetRef v28 = v21;
    CFSetApplyFunction(Mutable, (CFSetApplierFunction)sub_10021C13C, &buf);
    if (!Mutable)
    {
      uint64_t v22 = 0;
      goto LABEL_22;
    }
    CFRelease(Mutable);
  }
  uint64_t v22 = 1;
LABEL_22:

  return v22;
}

BOOL sub_10022779C(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v3 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_100227464;
  v6[3] = &unk_100309978;
  void v6[4] = v3;
  void v6[5] = a2;
  void v6[6] = v4;
  return sub_100220170(a3, v6);
}

void sub_100227824(const __CFSet *a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  uint64_t v22 = 0;
  int v23 = &v22;
  uint64_t v24 = 0x2020000000;
  char v25 = 1;
  v21[0] = 0;
  v21[1] = v21;
  v21[2] = 0x2020000000;
  v21[3] = 0;
  uint64_t v17 = 0;
  CFSetRef v18 = &v17;
  uint64_t v19 = 0x2020000000;
  CFMutableSetRef Mutable = (CFMutableSetRef)0xAAAAAAAAAAAAAAAALL;
  CFMutableSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  void v10[2] = sub_100227A8C;
  void v10[3] = &unk_1003099A0;
  uint64_t v12 = &v17;
  CFSetRef v13 = v21;
  CFTypeRef v14 = &v22;
  uint64_t v15 = 7;
  id v6 = v5;
  id v11 = v6;
  uint64_t v16 = a2;
  CFSetApplyFunction(a1, (CFSetApplierFunction)sub_10021C13C, v10);
  if (CFSetGetCount((CFSetRef)v18[3]))
  {
    char v7 = (*((uint64_t (**)(id, uint64_t, uint64_t))v6 + 2))(v6, v18[3], a2);
    if (*((unsigned char *)v23 + 24)) {
      char v8 = v7;
    }
    else {
      char v8 = 0;
    }
    *((unsigned char *)v23 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v8;
  }
  uint64_t v9 = (const void *)v18[3];
  if (v9)
  {
    void v18[3] = 0;
    CFRelease(v9);
  }

  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(v21, 8);
  _Block_object_dispose(&v22, 8);
}

void sub_1002279C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose((const void *)(v11 - 80), 8);
  _Unwind_Resume(a1);
}

BOOL sub_100227A04(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  uint64_t v3 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  uint64_t v4 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_100227464;
  v6[3] = &unk_100309978;
  void v6[4] = a2;
  void v6[5] = v3;
  void v6[6] = v4;
  return sub_100220170(a3, v6);
}

void sub_100227A8C(void *a1, const void *a2)
{
  CFSetAddValue(*(CFMutableSetRef *)(*(void *)(a1[5] + 8) + 24), a2);
  if (++*(void *)(*(void *)(a1[6] + 8) + 24) >= a1[8])
  {
    char v3 = (*(uint64_t (**)(void))(a1[4] + 16))();
    uint64_t v4 = *(void *)(a1[7] + 8);
    if (*(unsigned char *)(v4 + 24)) {
      char v5 = v3;
    }
    else {
      char v5 = 0;
    }
    *(unsigned char *)(v4 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v5;
    *(void *)(*(void *)(a1[6] + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
    id v6 = *(__CFSet **)(*(void *)(a1[5] + 8) + 24);
    CFSetRemoveAllValues(v6);
  }
}

void sub_100227B50(uint64_t a1, const void *a2)
{
}

void sub_100227B58(id a1)
{
  dispatch_queue_t v1 = dispatch_queue_create("syncWithPeers", 0);
  uint64_t v2 = qword_10035D450;
  qword_10035D450 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

uint64_t sub_100227B98(CFErrorRef *a1)
{
  uint64_t v2 = _OctagonSignpostLogSystem();
  os_signpost_id_t v3 = _OctagonSignpostCreate();

  uint64_t v4 = _OctagonSignpostLogSystem();
  char v5 = v4;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v4))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "SOSCCProcessSyncWithAllPeers", " enableTelemetry=YES ", buf, 2u);
  }

  id v6 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v20 = v3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCProcessSyncWithAllPeers  enableTelemetry=YES ", buf, 0xCu);
  }

  CFTypeRef cf = 0;
  if (sub_100220170(&cf, &stru_100309348) || !cf)
  {
    uint64_t v9 = 1;
  }
  else
  {
    if (SecErrorGetOSStatus() == -25308)
    {
      char v7 = sub_10000B070("updates");
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "SOSAccountSyncWithAllKVSPeers failed because device is locked; letting CloudKeychainProxy know",
          buf,
          2u);
      }

      CFTypeRef v8 = cf;
      if (!cf)
      {
        uint64_t v9 = 2;
        goto LABEL_14;
      }
      CFTypeRef cf = 0;
      CFRelease(v8);
      uint64_t v9 = 2;
    }
    else
    {
      uint64_t v15 = sub_10000B070("SecError");
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        os_signpost_id_t v20 = (os_signpost_id_t)cf;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Unexpected error: %@", buf, 0xCu);
      }

      uint64_t v9 = 1;
    }
    uint64_t v16 = (__CFError *)cf;
    if (a1 && cf)
    {
      if (!*a1) {
        goto LABEL_33;
      }
      if (CFErrorGetCode(*a1) == -25330)
      {
        CFErrorRef v17 = *a1;
        if (!*a1) {
          goto LABEL_33;
        }
        *a1 = 0;
        CFRelease(v17);
      }
LABEL_31:
      if (*a1) {
        goto LABEL_32;
      }
LABEL_33:
      *a1 = v16;
      goto LABEL_14;
    }
    if (cf)
    {
      if (!a1)
      {
LABEL_32:
        CFRelease(v16);
        goto LABEL_14;
      }
      goto LABEL_31;
    }
  }
LABEL_14:
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  uint64_t v11 = _OctagonSignpostLogSystem();
  uint64_t v12 = v11;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
  {
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v20) = v9;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v12, OS_SIGNPOST_INTERVAL_END, v3, "SOSCCProcessSyncWithAllPeers", " SOSSignpostNameSOSCCProcessSyncWithAllPeers=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCProcessSyncWithAllPeers}d ", buf, 8u);
  }

  uint64_t v13 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218496;
    os_signpost_id_t v20 = v3;
    __int16 v21 = 2048;
    double v22 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v23 = 1026;
    int v24 = v9;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCProcessSyncWithAllPeers  SOSSignpostNameSOSCCProcessSyncWithAllPeers=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCProcessSyncWithAllPeers}d ", buf, 0x1Cu);
  }

  return v9;
}

BOOL sub_100227F10(id a1, SOSAccountTransaction *a2, __CFError **a3)
{
  uint64_t v4 = a2;
  char v5 = [(SOSAccountTransaction *)v4 account];
  unsigned int v6 = [v5 SOSMonitorModeSOSIsActive];

  if (v6) {
    unsigned __int8 v7 = sub_1001ED3A0(v4, (uint64_t)a3);
  }
  else {
    unsigned __int8 v7 = 0;
  }

  return v7;
}

void sub_100227F7C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFArrayRef v8 = sub_100146438(kCFAllocatorDefault, a2, a3, a4, a5, a6, a7, a8, a1);
  activity_block[0] = _NSConcreteStackBlock;
  activity_block[1] = 3221225472;
  activity_block[2] = sub_10021C2D0;
  activity_block[3] = &unk_1003093A8;
  activity_void block[4] = v8;
  _os_activity_initiate((void *)&_mh_execute_header, "CloudCircle RequestSyncWithPeersList", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
  if (v8) {
    CFRelease(v8);
  }
}

void sub_10022802C(uint64_t a1)
{
  uint64_t v2 = _OctagonSignpostLogSystem();
  os_signpost_id_t v3 = _OctagonSignpostCreate();

  uint64_t v4 = _OctagonSignpostLogSystem();
  char v5 = v4;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v4))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "SOSCCRequestSyncWithBackupPeerList", " enableTelemetry=YES ", buf, 2u);
  }

  unsigned int v6 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v21 = v3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCRequestSyncWithBackupPeerList  enableTelemetry=YES ", buf, 0xCu);
  }

  CFArrayRef v14 = sub_100146438(kCFAllocatorDefault, v7, v8, v9, v10, v11, v12, v13, 0);
  sub_10002595C(*(const __CFArray **)(a1 + 32), @"[", @"]", (uint64_t)&stru_1003093C8);
  uint64_t v15 = dispatch_get_global_queue(-32768, 0);
  SOSCloudKeychainRequestSyncWithPeers();

  if (v14) {
    CFRelease(v14);
  }
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  CFErrorRef v17 = _OctagonSignpostLogSystem();
  CFSetRef v18 = v17;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v17))
  {
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v21) = 1;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v18, OS_SIGNPOST_INTERVAL_END, v3, "SOSCCRequestSyncWithBackupPeerList", " SOSSignpostNameSOSCCRequestSyncWithBackupPeerList=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCRequestSyncWithBackupPeerList}d ", buf, 8u);
  }

  uint64_t v19 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218496;
    os_signpost_id_t v21 = v3;
    __int16 v22 = 2048;
    double v23 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v24 = 1026;
    int v25 = 1;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCRequestSyncWithBackupPeerList  SOSSignpostNameSOSCCRequestSyncWithBackupPeerList=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCRequestSyncWithBackupPeerList}d ", buf, 0x1Cu);
  }
}

void sub_1002282C0(id a1, __CFString *a2)
{
  os_signpost_id_t v3 = sub_10000B070("syncwith");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    char v5 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Request backup sync With: %@", (uint8_t *)&v4, 0xCu);
  }
}

void sub_10022836C(id a1)
{
  dispatch_queue_t v1 = _OctagonSignpostLogSystem();
  os_signpost_id_t v2 = _OctagonSignpostCreate();

  os_signpost_id_t v3 = _OctagonSignpostLogSystem();
  int v4 = v3;
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v3))
  {
    LOWORD(v11) = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_INTERVAL_BEGIN, v2, "SOSCCEnsurePeerRegistration", " enableTelemetry=YES ", (uint8_t *)&v11, 2u);
  }

  char v5 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = 134217984;
    os_signpost_id_t v12 = v2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCEnsurePeerRegistration  enableTelemetry=YES ", (uint8_t *)&v11, 0xCu);
  }

  unsigned int v6 = dispatch_get_global_queue(-32768, 0);
  SOSCloudKeychainRequestEnsurePeerRegistration();

  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  uint64_t v8 = _OctagonSignpostLogSystem();
  uint64_t v9 = v8;
  if (v2 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v8))
  {
    int v11 = 67240192;
    LODWORD(v12) = 1;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v9, OS_SIGNPOST_INTERVAL_END, v2, "SOSCCEnsurePeerRegistration", " SOSSignpostNameSOSCCEnsurePeerRegistration=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCEnsurePeerRegistration}d ", (uint8_t *)&v11, 8u);
  }

  uint64_t v10 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = 134218496;
    os_signpost_id_t v12 = v2;
    __int16 v13 = 2048;
    double v14 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v15 = 1026;
    int v16 = 1;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCEnsurePeerRegistration  SOSSignpostNameSOSCCEnsurePeerRegistration=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCEnsurePeerRegistration}d ", (uint8_t *)&v11, 0x1Cu);
  }
}

uint64_t sub_1002285A0(CFTypeRef *a1)
{
  uint64_t v16 = 0;
  CFErrorRef v17 = &v16;
  uint64_t v18 = 0x2020000000;
  uint64_t v19 = 0;
  os_signpost_id_t v2 = _OctagonSignpostLogSystem();
  os_signpost_id_t v3 = _OctagonSignpostCreate();

  int v4 = _OctagonSignpostLogSystem();
  char v5 = v4;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v4))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "SOSCCCopyApplication", " enableTelemetry=YES ", buf, 2u);
  }

  unsigned int v6 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v21 = v3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCCopyApplication  enableTelemetry=YES ", buf, 0xCu);
  }

  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  _DWORD v15[2] = sub_100228898;
  v15[3] = &unk_1003090F0;
  void v15[4] = &v16;
  sub_100220170(a1, v15);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  uint64_t v8 = _OctagonSignpostLogSystem();
  uint64_t v9 = v8;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v8))
  {
    BOOL v10 = v17[3] != 0;
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v21) = v10;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v9, OS_SIGNPOST_INTERVAL_END, v3, "SOSCCCopyApplication", " SOSSignpostNameSOSCCCopyApplication=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCopyApplication}d ", buf, 8u);
  }

  int v11 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = v17[3];
    *(_DWORD *)long long buf = 134218496;
    os_signpost_id_t v21 = v3;
    __int16 v22 = 2048;
    double v23 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v24 = 1026;
    BOOL v25 = v12 != 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCCopyApplication  SOSSignpostNameSOSCCCopyApplication=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCopyApplication}d ", buf, 0x1Cu);
  }

  uint64_t v13 = v17[3];
  _Block_object_dispose(&v16, 8);
  return v13;
}

void sub_100228860(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_100228898(uint64_t a1, void *a2, uint64_t a3)
{
  char v5 = [a2 account];
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = sub_1001E2310(v5, a3);

  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

BOOL sub_100228900(CFTypeRef *a1)
{
  BOOL v2 = sub_100220170(a1, &stru_100309408);
  BOOL v3 = v2;
  if (a1)
  {
    if (v2)
    {
      CFTypeRef v4 = *a1;
      if (*a1)
      {
        *a1 = 0;
        CFRelease(v4);
      }
    }
  }
  return v3;
}

BOOL sub_10022894C(id a1, SOSAccountTransaction *a2, __CFError **a3)
{
  CFTypeRef v4 = [(SOSAccountTransaction *)a2 account];
  sub_1001E7364(v4, (uint64_t *)a3);

  return 1;
}

uint64_t sub_10022898C(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v18 = 0;
  uint64_t v19 = &v18;
  uint64_t v20 = 0x2020000000;
  uint64_t v21 = 0;
  CFTypeRef v4 = _OctagonSignpostLogSystem();
  os_signpost_id_t v5 = _OctagonSignpostCreate();

  unsigned int v6 = _OctagonSignpostLogSystem();
  uint64_t v7 = v6;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v6))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_INTERVAL_BEGIN, v5, "SOSCCCopyCircleJoiningBlob", " enableTelemetry=YES ", buf, 2u);
  }

  uint64_t v8 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v23 = v5;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCCopyCircleJoiningBlob  enableTelemetry=YES ", buf, 0xCu);
  }

  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472;
  void v17[2] = sub_100228C88;
  void v17[3] = &unk_100309430;
  void v17[4] = &v18;
  void v17[5] = a1;
  sub_100220170(a2, v17);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  BOOL v10 = _OctagonSignpostLogSystem();
  int v11 = v10;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v10))
  {
    BOOL v12 = v19[3] != 0;
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v23) = v12;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v11, OS_SIGNPOST_INTERVAL_END, v5, "SOSCCCopyCircleJoiningBlob", " SOSSignpostNameSOSCCCopyCircleJoiningBlob=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCopyCircleJoiningBlob}d ", buf, 8u);
  }

  uint64_t v13 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = v19[3];
    *(_DWORD *)long long buf = 134218496;
    os_signpost_id_t v23 = v5;
    __int16 v24 = 2048;
    double v25 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v26 = 1026;
    BOOL v27 = v14 != 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCCopyCircleJoiningBlob  SOSSignpostNameSOSCCCopyCircleJoiningBlob=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCopyCircleJoiningBlob}d ", buf, 0x1Cu);
  }

  uint64_t v15 = v19[3];
  _Block_object_dispose(&v18, 8);
  return v15;
}

void sub_100228C50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_100228C88(uint64_t a1, void *a2, uint64_t *a3)
{
  os_signpost_id_t v5 = [a2 account];
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = sub_1001DFB18(v5, 0, 0, 0, 0, *(void *)(a1 + 40), a3);

  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

uint64_t sub_100228D04(int a1, CFTypeRef *a2)
{
  uint64_t v19 = 0;
  uint64_t v20 = &v19;
  uint64_t v21 = 0x2020000000;
  uint64_t v22 = 0;
  CFTypeRef v4 = _OctagonSignpostLogSystem();
  os_signpost_id_t v5 = _OctagonSignpostCreate();

  unsigned int v6 = _OctagonSignpostLogSystem();
  uint64_t v7 = v6;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v6))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_INTERVAL_BEGIN, v5, "SOSCCCopyInitialSyncData", " enableTelemetry=YES ", buf, 2u);
  }

  uint64_t v8 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v24 = v5;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCCopyInitialSyncData  enableTelemetry=YES ", buf, 0xCu);
  }

  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472;
  void v17[2] = sub_100229004;
  void v17[3] = &unk_100309458;
  void v17[4] = &v19;
  int v18 = a1;
  sub_100220170(a2, v17);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  BOOL v10 = _OctagonSignpostLogSystem();
  int v11 = v10;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v10))
  {
    BOOL v12 = v20[3] != 0;
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v12;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v11, OS_SIGNPOST_INTERVAL_END, v5, "SOSCCCopyInitialSyncData", " SOSSignpostNameSOSCCCopyInitialSyncData=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCopyInitialSyncData}d ", buf, 8u);
  }

  uint64_t v13 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = v20[3];
    *(_DWORD *)long long buf = 134218496;
    os_signpost_id_t v24 = v5;
    __int16 v25 = 2048;
    double v26 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v27 = 1026;
    BOOL v28 = v14 != 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCCopyInitialSyncData  SOSSignpostNameSOSCCCopyInitialSyncData=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCopyInitialSyncData}d ", buf, 0x1Cu);
  }

  uint64_t v15 = v20[3];
  _Block_object_dispose(&v19, 8);
  return v15;
}

void sub_100228FCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_100229004(uint64_t a1, void *a2)
{
  BOOL v3 = [a2 account];
  uint64_t v79 = a1;
  int v4 = *(_DWORD *)(a1 + 40);
  id v80 = v3;
  os_signpost_id_t v5 = +[NSMutableArray array];
  if ((v4 & 4) != 0)
  {
    uint64_t v14 = +[NSMutableArray array];
    uint64_t v15 = +[NSMutableSet set];
    sub_1001E8008(v14, v15, 1);
  }
  else
  {
    if ((v4 & 2) != 0)
    {
      id v6 = v80;
      CFArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      uint64_t v8 = [v6 trust];

      [v8 trustedCircle];
      *(void *)&long long buf = _NSConcreteStackBlock;
      *((void *)&buf + 1) = 3221225472;
      id v104 = sub_1001E8B8C;
      CFStringRef v105 = (const __CFString *)&unk_1003085A8;
      CFBooleanRef v106 = Mutable;
      SOSCircleForEachActivePeer();

      uint64_t v9 = sub_10000B070("piggy");
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = Mutable;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "identities: %@", (uint8_t *)&buf, 0xCu);
      }

      CFIndex Count = CFArrayGetCount(Mutable);
      if (Count >= 1)
      {
        CFIndex v11 = Count;
        for (CFIndex i = 0; i != v11; ++i)
        {
          CFArrayGetValueAtIndex(Mutable, i);
          uint64_t v13 = (void *)SOSPeerInfoCopyData();
          if (v13) {
            [v5 addObject:v13];
          }
        }
      }
      CFRelease(Mutable);
    }
    if (v4)
    {
      result[0] = 0;
      uint64_t v14 = +[NSMutableArray array];
      CFRange v86 = +[NSMutableSet set];
      sub_1001E8008(v14, v86, 0);
      *(void *)uint64_t v92 = kSecClass;
      *(void *)&v92[8] = kSecUseDataProtectionKeychain;
      *(void *)&long long buf = kSecClassInternetPassword;
      *((void *)&buf + 1) = &__kCFBooleanTrue;
      *(void *)&long long v93 = kSecAttrAccessGroup;
      *((void *)&v93 + 1) = kSecAttrDescription;
      id v104 = (void (*)(uint64_t, const void *))@"com.apple.security.ckks";
      CFStringRef v105 = @"tlk";
      *(void *)&long long v94 = kSecAttrSynchronizable;
      *((void *)&v94 + 1) = kSecMatchLimit;
      CFBooleanRef v106 = kCFBooleanTrue;
      CFStringRef v107 = kSecMatchLimitAll;
      unsigned long long v95 = __PAIR128__((unint64_t)kSecReturnData, (unint64_t)kSecReturnAttributes);
      id v108 = &__kCFBooleanTrue;
      uint64_t v109 = &__kCFBooleanTrue;
      CFDictionaryRef v16 = +[NSDictionary dictionaryWithObjects:&buf forKeys:v92 count:8];
      if (!SecItemCopyMatching(v16, result)) {
        sub_1001E8448(v14, (void *)result[0], v86);
      }
      CFTypeRef v17 = result[0];
      if (result[0])
      {
        result[0] = 0;
        CFRelease(v17);
      }
      *(void *)&long long v96 = kSecClass;
      *((void *)&v96 + 1) = kSecUseDataProtectionKeychain;
      *(void *)BOOL v100 = kSecClassInternetPassword;
      *(void *)&long long v97 = kSecAttrAccessGroup;
      *((void *)&v97 + 1) = kSecAttrDescription;
      *(void *)&v100[8] = &__kCFBooleanTrue;
      *(void *)&v100[16] = @"com.apple.security.ckks";
      *(void *)&v100[24] = @"tlk-piggy";
      *(void *)&long long v98 = kSecAttrSynchronizable;
      *((void *)&v98 + 1) = kSecMatchLimit;
      *(void *)&long long v101 = kSecAttrSynchronizableAny;
      *((void *)&v101 + 1) = kSecMatchLimitAll;
      unsigned long long v99 = __PAIR128__((unint64_t)kSecReturnData, (unint64_t)kSecReturnAttributes);
      *(void *)&long long v102 = &__kCFBooleanTrue;
      *((void *)&v102 + 1) = &__kCFBooleanTrue;
      CFDictionaryRef v18 = +[NSDictionary dictionaryWithObjects:v100 forKeys:&v96 count:8];

      if (!SecItemCopyMatching(v18, result)) {
        sub_1001E8448(v14, (void *)result[0], v86);
      }
      CFTypeRef v19 = result[0];
      if (result[0])
      {
        result[0] = 0;
        CFRelease(v19);
      }
      uint64_t v20 = sub_10000B070("piggy");
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)CFRange v89 = 67109120;
        unsigned int v90 = [v14 count];
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Found %d TLKs", v89, 8u);
      }
    }
    else
    {
      uint64_t v14 = 0;
    }
  }
  id v21 = v5;
  id v22 = v14;
  id v77 = v21;
  os_signpost_id_t v23 = +[NSMutableArray array];
  CFDictionaryRef v78 = v22;
  id v24 = [v22 mutableCopy];
  [v24 sortUsingComparator:&stru_1003076C0];
  long long v94 = 0u;
  unsigned long long v95 = 0u;
  *(_OWORD *)uint64_t v92 = 0u;
  long long v93 = 0u;
  id v25 = v24;
  id v87 = [v25 countByEnumeratingWithState:v92 objects:&buf count:16];
  if (v87)
  {
    uint64_t v84 = *(void *)v93;
    id obj = v25;
    while (2)
    {
      for (j = 0; j != v87; j = (char *)j + 1)
      {
        if (*(void *)v93 != v84) {
          objc_enumerationMutation(obj);
        }
        __int16 v27 = *(void **)(*(void *)&v92[8] + 8 * (void)j);
        BOOL v28 = [v27 objectForKeyedSubscript:kSecValueData];
        int8x16_t v29 = [v27 objectForKeyedSubscript:kSecAttrServer];
        id v30 = [v27 objectForKeyedSubscript:kSecAttrAccount];
        id v31 = [objc_alloc((Class)NSUUID) initWithUUIDString:v30];

        memset(v100, 170, 16);
        [v31 getUUIDBytes:v100];
        long long v32 = +[NSData dataWithBytes:v100 length:16];

        int v33 = sub_1001E88EC(v29);
        CFStringRef v34 = v29;
        id v35 = v32;
        [v28 length];
        [v35 length];

        if (v33) {
          ccder_sizeof_uint64();
        }
        else {
          sub_10000FBB4(v34);
        }
        ccder_sizeof();
        ccder_sizeof();
        uint64_t v36 = ccder_sizeof();

        id v37 = +[NSMutableData dataWithLength:v36];
        char v38 = (UInt8 *)[v37 mutableBytes];
        uint64_t v39 = (char *)[v37 length] + (void)v38;
        if (sub_1001E88EC(v34))
        {
          id v40 = v28;
          id v41 = v35;
          ccder_encode_uint64();
        }
        else
        {
          id v42 = v28;
          id v43 = v35;
          sub_10000FC34(v34, 0, v38, (uint64_t)v39, v44);
        }
        sub_1001E8984(v35);

        sub_1001E8984(v28);
        if (!ccder_encode_constructed_tl())
        {

          id v25 = obj;
          id v82 = 0;
          goto LABEL_43;
        }
        id v45 = sub_10000B070("piggy");
        if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)BOOL v100 = 138412546;
          *(void *)&v100[4] = v34;
          *(_WORD *)&v100[12] = 2112;
          *(void *)&v100[14] = v30;
          _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "preparing TLK in order: %@: %@", v100, 0x16u);
        }

        [v23 addObject:v37];
      }
      id v25 = obj;
      id v87 = [obj countByEnumeratingWithState:v92 objects:&buf count:16];
      if (v87) {
        continue;
      }
      break;
    }
  }

  id v82 = v23;
LABEL_43:

  id v46 = v77;
  uint64_t v47 = +[NSMutableArray array];
  *(_OWORD *)uint64_t v92 = 0u;
  long long v93 = 0u;
  long long v94 = 0u;
  unsigned long long v95 = 0u;
  id v48 = v46;
  id v49 = [v48 countByEnumeratingWithState:v92 objects:&buf count:16];
  if (v49)
  {
    id v50 = v49;
    uint64_t v51 = *(void *)v93;
    do
    {
      for (k = 0; k != v50; k = (char *)k + 1)
      {
        if (*(void *)v93 != v51) {
          objc_enumerationMutation(v48);
        }
        id v53 = *(void **)(*(void *)&v92[8] + 8 * (void)k);
        [v53 length];
        id v54 = +[NSMutableData dataWithLength:ccder_sizeof_raw_octet_string()];
        [v54 mutableBytes];
        [v54 length];
        [v53 length];
        [v53 bytes];
        ccder_encode_raw_octet_string();
        [v47 addObject:v54];
      }
      id v50 = [v48 countByEnumeratingWithState:v92 objects:&buf count:16];
    }
    while (v50);
  }

  CFRange v88 = +[NSMutableArray array];
  CFRange v85 = +[NSMutableArray array];
  memset(v100, 0, sizeof(v100));
  long long v101 = 0u;
  long long v102 = 0u;
  id v83 = v82;
  id v55 = [v83 countByEnumeratingWithState:v100 objects:&buf count:16];
  if (v55)
  {
    id v56 = v55;
    uint64_t v57 = 0;
    uint64_t v58 = **(void **)&v100[16];
LABEL_52:
    uint64_t v59 = 0;
    while (1)
    {
      if (**(void **)&v100[16] != v58) {
        objc_enumerationMutation(v83);
      }
      BOOL v60 = *(void **)(*(void *)&v100[8] + 8 * v59);
      if (500 - v57 < (unint64_t)[v60 length]) {
        break;
      }
      [v88 addObject:v60];
      v57 += (uint64_t)[v60 length];
      if (v56 == (id)++v59)
      {
        id v56 = [v83 countByEnumeratingWithState:v100 objects:&buf count:16];
        if (v56) {
          goto LABEL_52;
        }
        break;
      }
    }
  }

  uint64_t v61 = sub_10000B070("piggy");
  if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v62 = [v88 count];
    *(_DWORD *)uint64_t v92 = 67109120;
    *(_DWORD *)&v92[4] = v62;
    _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "sending %d tlks", v92, 8u);
  }

  long long v98 = 0u;
  unsigned long long v99 = 0u;
  long long v96 = 0u;
  long long v97 = 0u;
  id v63 = v47;
  id v64 = [v63 countByEnumeratingWithState:&v96 objects:v92 count:16];
  if (v64)
  {
    id v65 = v64;
    uint64_t v66 = 0;
    uint64_t v67 = *(void *)v97;
LABEL_62:
    uint64_t v68 = 0;
    while (1)
    {
      if (*(void *)v97 != v67) {
        objc_enumerationMutation(v63);
      }
      CFArrayRef v69 = *(void **)(*((void *)&v96 + 1) + 8 * v68);
      if (120 - v66 < (unint64_t)[v69 length]) {
        break;
      }
      [v85 addObject:v69];
      v66 += (uint64_t)[v69 length];
      if (v65 == (id)++v68)
      {
        id v65 = [v63 countByEnumeratingWithState:&v96 objects:v92 count:16];
        if (v65) {
          goto LABEL_62;
        }
        break;
      }
    }
  }

  char v70 = sub_10000B070("piggy");
  if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v71 = [v85 count];
    LODWORD(result[0]) = 67109120;
    HIDWORD(result[0]) = v71;
    _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "sending %d identities", (uint8_t *)result, 8u);
  }

  ccder_sizeof();
  ccder_sizeof();
  id v72 = +[NSMutableData dataWithLength:ccder_sizeof()];
  [v72 mutableBytes];
  [v72 length];
  sub_1001E8A20(v88);
  sub_1001E8A20(v85);
  id v73 = (id)ccder_encode_constructed_tl();
  id v74 = v72;
  if (v73 == [v74 mutableBytes]) {
    id v75 = v74;
  }
  else {
    id v75 = 0;
  }

  *(void *)(*(void *)(*(void *)(v79 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v75;
  return *(void *)(*(void *)(*(void *)(v79 + 32) + 8) + 24) != 0;
}

BOOL sub_100229D2C(uint64_t a1, int a2, CFTypeRef *a3)
{
  id v6 = _OctagonSignpostLogSystem();
  os_signpost_id_t v7 = _OctagonSignpostCreate();

  uint64_t v8 = _OctagonSignpostLogSystem();
  uint64_t v9 = v8;
  if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v8))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v9, OS_SIGNPOST_INTERVAL_BEGIN, v7, "SOSCCJoinWithCircleJoiningBlob", " enableTelemetry=YES ", buf, 2u);
  }

  BOOL v10 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v20 = v7;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCJoinWithCircleJoiningBlob  enableTelemetry=YES ", buf, 0xCu);
  }

  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472;
  void v17[2] = sub_100229FB4;
  void v17[3] = &unk_100309478;
  void v17[4] = a1;
  int v18 = a2;
  BOOL v11 = sub_100220170(a3, v17);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  uint64_t v13 = _OctagonSignpostLogSystem();
  uint64_t v14 = v13;
  if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v13))
  {
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v20) = v11;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v14, OS_SIGNPOST_INTERVAL_END, v7, "SOSCCJoinWithCircleJoiningBlob", " SOSSignpostNameSOSCCJoinWithCircleJoiningBlob=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCJoinWithCircleJoiningBlob}d ", buf, 8u);
  }

  uint64_t v15 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218496;
    os_signpost_id_t v20 = v7;
    __int16 v21 = 2048;
    double v22 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v23 = 1026;
    BOOL v24 = v11;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCJoinWithCircleJoiningBlob  SOSSignpostNameSOSCCJoinWithCircleJoiningBlob=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCJoinWithCircleJoiningBlob}d ", buf, 0x1Cu);
  }

  return v11;
}

id sub_100229FB4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  CFTypeRef cf = 0;
  id v6 = [v5 account];
  id v7 = sub_1001DF080(v6, *(const void **)(a1 + 32), *(_DWORD *)(a1 + 40), &cf);

  if (a3)
  {
    CFTypeRef v8 = cf;
    if (cf)
    {
      CFRetain(cf);
      *a3 = v8;
    }
  }
  uint64_t v9 = [v5 account];
  BOOL v10 = [v9 trust];
  unsigned int v11 = [v10 isInCircleOnly:0];

  if (cf)
  {
    BOOL v12 = [(id)objc_opt_class() logger];
    CFTypeRef v13 = cf;
    v32[0] = @"SOSEnabled";
    BOOL v14 = -[OTSOSActualAdapter sosEnabled]_0();
    CFStringRef v15 = @"compat_disabled";
    if (v14) {
      CFStringRef v15 = @"compat_enabled";
    }
    v33[0] = v15;
    v33[1] = @"Piggybacking";
    v32[1] = @"SOSJoinMethod";
    v32[2] = @"JoiningSOSResult";
    CFStringRef v16 = @"not_in_circle";
    if (v11) {
      CFStringRef v16 = @"in_circle";
    }
    id v33[2] = v16;
    v32[3] = @"CircleContainsLegacy";
    CFTypeRef v17 = [v5 account];
    int v18 = [v17 trust];
    [v18 trustedCircle];
    CFTypeRef v19 = [v5 account];
    [v19 accountKey];
    int IsLegacy = SOSCircleIsLegacy();
    CFStringRef v21 = @"does_not_contain_legacy";
    if (IsLegacy) {
      CFStringRef v21 = @"contains_legacy";
    }
    v33[3] = v21;
    double v22 = +[NSDictionary dictionaryWithObjects:v33 forKeys:v32 count:4];
    [v12 logResultForEvent:@"SOSDeferralEventPiggybacking" hardFailure:0 result:v13 withAttributes:v22];
  }
  else
  {
    if (-[OTSOSActualAdapter sosEnabled]_0()) {
      CFStringRef v23 = @"compat_enabled";
    }
    else {
      CFStringRef v23 = @"compat_disabled";
    }
    if (v11) {
      CFStringRef v24 = @"in_circle";
    }
    else {
      CFStringRef v24 = @"not_in_circle";
    }
    id v25 = [v5 account];
    double v26 = [v25 trust];
    [v26 trustedCircle];
    __int16 v27 = [v5 account];
    [v27 accountKey];
    int v28 = SOSCircleIsLegacy();
    CFStringRef v29 = @"does_not_contain_legacy";
    if (v28) {
      CFStringRef v29 = @"contains_legacy";
    }
    BOOL v12 = +[NSString stringWithFormat:@"%@-%@-%@-%@", v23, @"Piggybacking", v24, v29];

    CFTypeRef v17 = [(id)objc_opt_class() logger];
    [v17 logSuccessForEventNamed:v12];
  }

  return v7;
}

uint64_t sub_10022A2E0(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v5 = 0;
  id v6 = &v5;
  uint64_t v7 = 0x2020000000;
  uint64_t v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  _DWORD v4[2] = sub_10022A3A4;
  void v4[3] = &unk_100309430;
  void v4[4] = &v5;
  void v4[5] = a1;
  sub_10021CD84(a2, v4);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_10022A38C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_10022A3A4(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  id v6 = _OctagonSignpostLogSystem();
  os_signpost_id_t v7 = _OctagonSignpostCreate();

  uint64_t v8 = _OctagonSignpostLogSystem();
  uint64_t v9 = v8;
  if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v8))
  {
    *(_WORD *)id v30 = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v9, OS_SIGNPOST_INTERVAL_BEGIN, v7, "SOSCCPeersHaveViewsEnabled", " enableTelemetry=YES ", v30, 2u);
  }

  BOOL v10 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)id v30 = 134217984;
    *(void *)&v30[4] = v7;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCPeersHaveViewsEnabled  enableTelemetry=YES ", v30, 0xCu);
  }

  unsigned int v11 = [v5 account];

  CFArrayRef v12 = *(const __CFArray **)(a1 + 40);
  id v13 = v11;
  if ([v13 isInCircle:a3])
  {
    unint64_t Count = CFArrayGetCount(v12);
    if (Count >> 61)
    {
      MutableCFStringRef Copy = CFSetCreateMutableCopy(kCFAllocatorDefault, 0, 0);
    }
    else
    {
      CFIndex v17 = Count;
      int v18 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
      v34.id location = 0;
      v34.size_t length = v17;
      CFArrayGetValues(v12, v34, v18);
      CFAllocatorRef v19 = CFGetAllocator(v12);
      CFSetRef v20 = CFSetCreate(v19, v18, v17, &kCFTypeSetCallBacks);
      free(v18);
      MutableCFStringRef Copy = CFSetCreateMutableCopy(kCFAllocatorDefault, 0, v20);
      if (v20) {
        CFRelease(v20);
      }
    }
    *(void *)id v30 = _NSConcreteStackBlock;
    *(void *)&v30[8] = 3221225472;
    *(void *)&v30[16] = sub_1001F1820;
    id v31 = &unk_100307C48;
    id v32 = v13;
    CFSetRef v33 = MutableCopy;
    sub_100212E90(v32, v30);
    CFIndex v21 = CFSetGetCount(MutableCopy);
    double v22 = &kCFBooleanTrue;
    if (v21) {
      double v22 = &kCFBooleanFalse;
    }
    CFBooleanRef v16 = *v22;
    if (MutableCopy) {
      CFRelease(MutableCopy);
    }
  }
  else
  {
    CFBooleanRef v16 = 0;
  }

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v16;
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  CFStringRef v24 = _OctagonSignpostLogSystem();
  id v25 = v24;
  if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v24))
  {
    BOOL v26 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
    *(_DWORD *)id v30 = 67240192;
    *(_DWORD *)&v30[4] = v26;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v25, OS_SIGNPOST_INTERVAL_END, v7, "SOSCCPeersHaveViewsEnabled", " SOSSignpostNameSOSCCPeersHaveViewsEnabled=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCPeersHaveViewsEnabled}d ", v30, 8u);
  }

  __int16 v27 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v28 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    *(_DWORD *)id v30 = 134218496;
    *(void *)&v30[4] = v7;
    *(_WORD *)&unsigned char v30[12] = 2048;
    *(double *)&v30[14] = (double)(unint64_t)Nanoseconds / 1000000000.0;
    *(_WORD *)&v30[22] = 1026;
    LODWORD(v31) = v28 != 0;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCPeersHaveViewsEnabled  SOSSignpostNameSOSCCPeersHaveViewsEnabled=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCPeersHaveViewsEnabled}d ", v30, 0x1Cu);
  }

  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

uint64_t sub_10022A794(uint64_t a1, CFTypeRef *a2)
{
  int v4 = _OctagonSignpostLogSystem();
  os_signpost_id_t v5 = _OctagonSignpostCreate();

  id v6 = _OctagonSignpostLogSystem();
  os_signpost_id_t v7 = v6;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v6))
  {
    LOWORD(buf) = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_INTERVAL_BEGIN, v5, "SOSCCRegisterRecoveryPublicKey", " enableTelemetry=YES ", (uint8_t *)&buf, 2u);
  }

  uint64_t v8 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v5;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCRegisterRecoveryPublicKey  enableTelemetry=YES ", (uint8_t *)&buf, 0xCu);
  }

  v26[0] = _NSConcreteStackBlock;
  v26[1] = 3221225472;
  v26[2] = sub_10022AC90;
  v26[3] = &unk_100309158;
  void v26[4] = a1;
  if (!sub_10021CD84(a2, v26))
  {
    uint64_t v9 = sub_10000B070("SecError");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "register-recovery-public-key: Failed to register recovery key", (uint8_t *)&buf, 2u);
    }
    goto LABEL_34;
  }
  uint64_t v9 = sub_10021C7D8();
  if (!v9)
  {
    CFIndex v21 = sub_10000B070("SecError");
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "register-recovery-public-key: Failed to get account object", (uint8_t *)&buf, 2u);
    }

    if (a2)
    {
      uint64_t v9 = 0;
      uint64_t v16 = 0;
      *a2 = CFErrorCreate(kCFAllocatorDefault, kSOSErrorDomain, 1048, 0);
      goto LABEL_35;
    }
    uint64_t v9 = 0;
LABEL_34:
    uint64_t v16 = 0;
    goto LABEL_35;
  }
  dispatch_semaphore_t v10 = dispatch_semaphore_create(0);
  *(void *)&long long buf = 0;
  *((void *)&buf + 1) = &buf;
  uint64_t v34 = 0x3032000000;
  id v35 = sub_100224988;
  uint64_t v36 = sub_100224998;
  id v37 = 0;
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 3221225472;
  CFTypeRef v23[2] = sub_10022AF48;
  v23[3] = &unk_1003094A0;
  p_long long buf = &buf;
  unsigned int v11 = v10;
  CFStringRef v24 = v11;
  [v9 triggerRingUpdateNow:v23];
  dispatch_time_t v12 = dispatch_time(0, 60000000000);
  if (dispatch_semaphore_wait(v11, v12))
  {
    id v13 = sub_10000B070("SecError");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int16 v27 = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "timed out waiting for ring update", v27, 2u);
    }
  }
  BOOL v14 = *(void **)(*((void *)&buf + 1) + 40);
  if (a2) {
    BOOL v15 = v14 == 0;
  }
  else {
    BOOL v15 = 1;
  }
  uint64_t v16 = v15;
  if (v15)
  {
    uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
    int v18 = _OctagonSignpostLogSystem();
    CFAllocatorRef v19 = v18;
    if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v18))
    {
      *(_DWORD *)__int16 v27 = 67240192;
      LODWORD(v2_Block_object_dispose(&a9, 8) = 1;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v19, OS_SIGNPOST_INTERVAL_END, v5, "SOSCCRegisterRecoveryPublicKey", " SOSSignpostNameSOSCCRegisterRecoveryPublicKey=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCRegisterRecoveryPublicKey}d ", v27, 8u);
    }

    CFSetRef v20 = _OctagonSignpostLogSystem();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int16 v27 = 134218496;
      os_signpost_id_t v28 = v5;
      __int16 v29 = 2048;
      double v30 = (double)(unint64_t)Nanoseconds / 1000000000.0;
      __int16 v31 = 1026;
      int v32 = 1;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCRegisterRecoveryPublicKey  SOSSignpostNameSOSCCRegisterRecoveryPublicKey=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCRegisterRecoveryPublicKey}d ", v27, 0x1Cu);
    }
  }
  else
  {
    *a2 = v14;
  }

  _Block_object_dispose(&buf, 8);
LABEL_35:

  return v16;
}

void sub_10022AC64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_10022AC90(uint64_t a1, void *a2, const void **a3)
{
  id v5 = a2;
  CFDataRef v6 = *(const __CFData **)(a1 + 32);
  if (v6 && CFDataGetLength(v6))
  {
    CFDataRef v7 = *(const __CFData **)(a1 + 32);
    id v8 = v5;
    uint64_t v9 = [v8 account];
    BOOL v10 = sub_10020258C(v9, v7, a3);

    unsigned int v11 = sub_10000B070("recovery");
    BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
    if (v10)
    {
      if (v12)
      {
        LOWORD(v30) = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "successfully registered recovery public key", (uint8_t *)&v30, 2u);
      }

      id v13 = [v8 account];

      BOOL v14 = 1;
      [v13 setPublicKeyStatus:1 forKey:2];

      if (a3)
      {
        BOOL v15 = *a3;
        if (*a3)
        {
          *a3 = 0;
          CFRelease(v15);
        }
      }
    }
    else
    {
      if (v12)
      {
        __int16 v27 = *a3;
        int v30 = 138412290;
        __int16 v31 = v27;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "could not register recovery public key: %@", (uint8_t *)&v30, 0xCu);
      }

      os_signpost_id_t v28 = [v8 account];

      [v28 setPublicKeyStatus:0 forKey:2];
      BOOL v14 = 0;
    }
    goto LABEL_24;
  }
  id v16 = v5;
  CFIndex v17 = [v16 account];
  BOOL v14 = sub_10020258C(v17, 0, a3);

  int v18 = sub_10000B070("recovery");
  BOOL v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
  if (v14)
  {
    if (v19)
    {
      LOWORD(v30) = 0;
      CFSetRef v20 = "RK Cleared";
      CFIndex v21 = v18;
      uint32_t v22 = 2;
LABEL_14:
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, v20, (uint8_t *)&v30, v22);
    }
  }
  else if (v19)
  {
    CFStringRef v23 = *a3;
    int v30 = 138412290;
    __int16 v31 = v23;
    CFSetRef v20 = "Couldn't clear RK(%@)";
    CFIndex v21 = v18;
    uint32_t v22 = 12;
    goto LABEL_14;
  }

  CFStringRef v24 = [v16 account];

  [v24 setPublicKeyStatus:0 forKey:2];
  char v25 = !v14;
  if (!a3) {
    char v25 = 1;
  }
  if ((v25 & 1) == 0)
  {
    BOOL v26 = *a3;
    if (*a3)
    {
      *a3 = 0;
      CFRelease(v26);
    }
    BOOL v14 = 1;
  }
LABEL_24:

  return v14;
}

void sub_10022AF48(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (v4)
  {
    id v5 = sub_10000B070("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 138412290;
      id v7 = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "trigger ring update error: %@", (uint8_t *)&v6, 0xCu);
    }

    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

uint64_t sub_10022B02C(CFTypeRef *a1)
{
  uint64_t v16 = 0;
  CFIndex v17 = &v16;
  uint64_t v18 = 0x2020000000;
  uint64_t v19 = 0;
  uint64_t v2 = _OctagonSignpostLogSystem();
  os_signpost_id_t v3 = _OctagonSignpostCreate();

  id v4 = _OctagonSignpostLogSystem();
  id v5 = v4;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v4))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "SOSCCCopyRecoveryPublicKey", " enableTelemetry=YES ", buf, 2u);
  }

  int v6 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v21 = v3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCCopyRecoveryPublicKey  enableTelemetry=YES ", buf, 0xCu);
  }

  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  _DWORD v15[2] = sub_10022B324;
  v15[3] = &unk_1003090F0;
  void v15[4] = &v16;
  sub_10021CD84(a1, v15);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  id v8 = _OctagonSignpostLogSystem();
  uint64_t v9 = v8;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v8))
  {
    BOOL v10 = v17[3] != 0;
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v21) = v10;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v9, OS_SIGNPOST_INTERVAL_END, v3, "SOSCCCopyRecoveryPublicKey", " SOSSignpostNameSOSCCCopyRecoveryPublicKey=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCopyRecoveryPublicKey}d ", buf, 8u);
  }

  unsigned int v11 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = v17[3];
    *(_DWORD *)long long buf = 134218496;
    os_signpost_id_t v21 = v3;
    __int16 v22 = 2048;
    double v23 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v24 = 1026;
    BOOL v25 = v12 != 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCCopyRecoveryPublicKey  SOSSignpostNameSOSCCCopyRecoveryPublicKey=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCCopyRecoveryPublicKey}d ", buf, 0x1Cu);
  }

  uint64_t v13 = v17[3];
  _Block_object_dispose(&v16, 8);
  return v13;
}

void sub_10022B2EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_10022B324(uint64_t a1, void *a2, CFTypeRef *a3)
{
  id v5 = [a2 account];
  CFDataRef v6 = sub_1002024D8(kCFAllocatorDefault, v5, a3);

  if (!v6)
  {
    uint64_t v9 = sub_10000B070("recovery");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      CFTypeRef v10 = *a3;
      int v12 = 138412290;
      CFTypeRef v13 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Could not retrieve the recovery public key from the ring: %@", (uint8_t *)&v12, 0xCu);
    }

    goto LABEL_10;
  }
  CFTypeID v7 = CFGetTypeID(v6);
  if (v7 != CFDataGetTypeID())
  {
    CFRelease(v6);
LABEL_10:
    CFDataRef v6 = 0;
    goto LABEL_11;
  }
  if (a3)
  {
    CFTypeRef v8 = *a3;
    if (*a3)
    {
      *a3 = 0;
      CFRelease(v8);
    }
  }
LABEL_11:
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v6;
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

BOOL sub_10022B478(uint64_t a1, CFTypeRef *a2)
{
  id v4 = _OctagonSignpostLogSystem();
  os_signpost_id_t v5 = _OctagonSignpostCreate();

  CFDataRef v6 = _OctagonSignpostLogSystem();
  CFTypeID v7 = v6;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v6))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_INTERVAL_BEGIN, v5, "SOSCCMessageFromPeerIsPending", " enableTelemetry=YES ", buf, 2u);
  }

  CFTypeRef v8 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v17 = v5;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCMessageFromPeerIsPending  enableTelemetry=YES ", buf, 0xCu);
  }

  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  _DWORD v15[2] = sub_10022B6F0;
  v15[3] = &unk_100309158;
  void v15[4] = a1;
  BOOL v9 = sub_10021CD84(a2, v15);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  unsigned int v11 = _OctagonSignpostLogSystem();
  int v12 = v11;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
  {
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v17) = v9;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v12, OS_SIGNPOST_INTERVAL_END, v5, "SOSCCMessageFromPeerIsPending", " SOSSignpostNameSOSCCMessageFromPeerIsPending=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCMessageFromPeerIsPending}d ", buf, 8u);
  }

  CFTypeRef v13 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218496;
    os_signpost_id_t v17 = v5;
    __int16 v18 = 2048;
    double v19 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v20 = 1026;
    BOOL v21 = v9;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCMessageFromPeerIsPending  SOSSignpostNameSOSCCMessageFromPeerIsPending=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCMessageFromPeerIsPending}d ", buf, 0x1Cu);
  }

  return v9;
}

uint64_t sub_10022B6F0(uint64_t a1, void *a2, uint64_t a3)
{
  id v4 = a2;
  os_signpost_id_t v5 = [v4 account];
  unsigned int v6 = [v5 SOSMonitorModeSOSIsActive];

  if (v6)
  {
    CFTypeID v7 = [v4 account];
    if (sub_1001EC934(v7, a3))
    {
      CFTypeRef v8 = [v7 kvs_message_transport];
      BOOL v9 = [v7 peerID];
      SOSPeerInfoGetPeerID();
      CFTypeRef v10 = (const void *)SOSMessageKeyCreateFromPeerToTransport();

      uint64_t HasPendingKey = SOSCloudKeychainHasPendingKey();
      if (v10) {
        CFRelease(v10);
      }
    }
    else
    {
      uint64_t HasPendingKey = 0;
    }
  }
  else
  {
    uint64_t HasPendingKey = 0;
  }

  return HasPendingKey;
}

BOOL sub_10022B7E4(uint64_t a1, CFTypeRef *a2)
{
  id v4 = _OctagonSignpostLogSystem();
  os_signpost_id_t v5 = _OctagonSignpostCreate();

  unsigned int v6 = _OctagonSignpostLogSystem();
  CFTypeID v7 = v6;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v6))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_INTERVAL_BEGIN, v5, "SOSCCSendToPeerIsPending", " enableTelemetry=YES ", buf, 2u);
  }

  CFTypeRef v8 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v17 = v5;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCSendToPeerIsPending  enableTelemetry=YES ", buf, 0xCu);
  }

  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  _DWORD v15[2] = sub_10022BA5C;
  v15[3] = &unk_100309158;
  void v15[4] = a1;
  BOOL v9 = sub_10021CD84(a2, v15);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  unsigned int v11 = _OctagonSignpostLogSystem();
  int v12 = v11;
  if (v5 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v11))
  {
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v17) = v9;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v12, OS_SIGNPOST_INTERVAL_END, v5, "SOSCCSendToPeerIsPending", " SOSSignpostNameSOSCCSendToPeerIsPending=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCSendToPeerIsPending}d ", buf, 8u);
  }

  CFTypeRef v13 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218496;
    os_signpost_id_t v17 = v5;
    __int16 v18 = 2048;
    double v19 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v20 = 1026;
    BOOL v21 = v9;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCSendToPeerIsPending  SOSSignpostNameSOSCCSendToPeerIsPending=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCSendToPeerIsPending}d ", buf, 0x1Cu);
  }

  return v9;
}

uint64_t sub_10022BA5C(uint64_t a1, void *a2, uint64_t a3)
{
  id v4 = a2;
  os_signpost_id_t v5 = [v4 account];
  unsigned int v6 = [v5 SOSMonitorModeSOSIsActive];

  if (v6)
  {
    CFTypeID v7 = [v4 account];
    if (sub_1001EC934(v7, a3)) {
      SOSPeerInfoGetPeerID();
    }
  }
  return 0;
}

BOOL sub_10022BAE8(int a1, CFTypeRef *a2)
{
  id v4 = [(id)objc_opt_class() logger];
  os_signpost_id_t v5 = [v4 startLogSystemMetricsForActivityNamed:@"SOSDeferralActivitySetCompatibilityMode"];

  unsigned int v6 = _OctagonSignpostLogSystem();
  os_signpost_id_t v7 = _OctagonSignpostCreate();

  CFTypeRef v8 = _OctagonSignpostLogSystem();
  BOOL v9 = v8;
  if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v8))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v9, OS_SIGNPOST_INTERVAL_BEGIN, v7, "SOSCCSetCompatibilityMode", " enableTelemetry=YES ", buf, 2u);
  }

  CFTypeRef v10 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    os_signpost_id_t v23 = v7;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCSetCompatibilityMode  enableTelemetry=YES ", buf, 0xCu);
  }

  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472;
  v20[2] = sub_10022BE0C;
  v20[3] = &unk_1003094C0;
  char v21 = a1;
  BOOL v11 = sub_10021CD84(a2, v20);
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  CFTypeRef v13 = _OctagonSignpostLogSystem();
  BOOL v14 = v13;
  if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v13))
  {
    *(_DWORD *)long long buf = 67240192;
    LODWORD(v23) = v11;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v14, OS_SIGNPOST_INTERVAL_END, v7, "SOSCCSetCompatibilityMode", " SOSSignpostNameSOSCCSetCompatibilityMode=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCSetCompatibilityMode}d ", buf, 8u);
  }

  BOOL v15 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218496;
    os_signpost_id_t v23 = v7;
    __int16 v24 = 2048;
    double v25 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v26 = 1026;
    BOOL v27 = v11;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCSetCompatibilityMode  SOSSignpostNameSOSCCSetCompatibilityMode=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCSetCompatibilityMode}d ", buf, 0x1Cu);
  }

  if (a2)
  {
    if (*a2) {
      a2 = (id)*a2;
    }
    else {
      a2 = 0;
    }
  }
  [v5 stopWithEvent:@"SOSDeferralActivitySetCompatibilityMode" result:a2];
  uint64_t v16 = [(id)objc_opt_class() logger];
  os_signpost_id_t v17 = v16;
  if (a1) {
    CFStringRef v18 = @"SOSDeferralEventCompatibilityModeEnabled";
  }
  else {
    CFStringRef v18 = @"SOSDeferralEventCompatibilityModeDisabled";
  }
  [v16 logSuccessForEventNamed:v18];

  return v11;
}

BOOL sub_10022BE0C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  if (qword_10035D0A8 != -1) {
    dispatch_once(&qword_10035D0A8, &stru_100303AD8);
  }
  if (byte_10035D0A0)
  {
    uint64_t v6 = *(unsigned __int8 *)(a1 + 32);
    os_signpost_id_t v7 = [v5 account];
    [v7 setSosCompatibilityMode:v6];

    if (*(unsigned char *)(a1 + 32))
    {
      dword_10035D448 = 2;
      CFTypeRef v8 = sub_10000B070("sos-compatibility-mode");
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Alerting SOS of account sign in", buf, 2u);
      }

      BOOL v9 = [v5 account];
      [v9 setAccountIsChanging:0];

      uint64_t v10 = sub_10000CF0C(0);
      uint64_t v11 = sub_100134054(v10);
      int v12 = [v5 account];
      [v12 setFactory:v11];

      CFTypeRef v13 = [v5 account];
      [v13 SOSMonitorModeEnableSOS];

      BOOL v14 = [v5 account];
      [v14 ensureFactoryCircles];

      BOOL v15 = [v5 account];
      [v15 setKey_interests_need_updating:1];

      uint64_t v16 = [v5 account];
      [v16 setConsolidateKeyInterest:0];

      [v5 restart];
    }
    else
    {
      CFStringRef v18 = sub_10000B070("sos-compatibility-mode");
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Alerting SOS of account sign out", buf, 2u);
      }

      uint64_t v38 = 0;
      double v19 = [v5 account];
      __int16 v20 = [v19 trust];
      char v21 = [v5 account];
      unsigned int v22 = [v20 leaveCircle:v21 err:&v38];

      if (!v22 || v38)
      {
        os_signpost_id_t v23 = sub_10000B070("SecError");
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          uint64_t v44 = v38;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "sos-compatibility-mode: failed to leave circle, error: %@", buf, 0xCu);
        }
      }
      [v5 restart];
      __int16 v24 = [v5 account];
      sub_10021D758(0);

      double v25 = [v5 account];
      sub_1001E4DD0(v25);

      __int16 v26 = [v5 account];
      [v26 setAccountIsChanging:1];

      BOOL v27 = [v5 account];
      [v27 SOSMonitorModeDisableSOS];

      notify_post(kSOSCCSOSIsNowOFF);
      dword_10035D448 = 1;
    }
    v41[0] = kSecClass;
    v41[1] = kSecUseDataProtectionKeychain;
    v42[0] = kSecClassGenericPassword;
    v42[1] = &__kCFBooleanTrue;
    v41[2] = kSecAttrSynchronizable;
    v41[3] = kSecAttrAccessGroup;
    v42[2] = &__kCFBooleanFalse;
    v42[3] = @"com.apple.security.sos";
    v41[4] = kSecAttrAccount;
    v41[5] = kSecAttrAccessible;
    void v42[4] = @"sos-compatibility-mode";
    v42[5] = kSecAttrAccessibleAfterFirstUnlock;
    v41[6] = kSecAttrSysBound;
    v42[6] = &off_1003268D8;
    os_signpost_id_t v28 = +[NSDictionary dictionaryWithObjects:v42 forKeys:v41 count:7];
    if (*(unsigned char *)(a1 + 32)) {
      __int16 v29 = @"enabled";
    }
    else {
      __int16 v29 = @"disabled";
    }
    int v30 = v29;
    __int16 v31 = [(__CFString *)v30 dataUsingEncoding:134217984];
    CFStringRef v39 = kSecValueData;
    id v40 = v31;
    CFDictionaryRef v32 = +[NSDictionary dictionaryWithObjects:&v40 forKeys:&v39 count:1];

    id v33 = [v28 mutableCopy];
    [v33 addEntriesFromDictionary:v32];
    OSStatus v34 = SecItemAdd((CFDictionaryRef)v33, 0);
    if (v34 == -25299) {
      OSStatus v34 = SecItemUpdate((CFDictionaryRef)v28, v32);
    }
    BOOL v17 = v34 == 0;
    if (v34)
    {
      Error = (const void *)SecCopyLastError();
      uint64_t v36 = Error;
      if (a3)
      {
        if (Error) {
          CFRetain(Error);
        }
        *a3 = v36;
      }
      if (v36) {
        CFRelease(v36);
      }
    }
  }
  else
  {
    BOOL v17 = 1;
  }

  return v17;
}

BOOL sub_10022C34C()
{
  BOOL v0 = -[OTSOSActualAdapter sosEnabled]_0();
  dispatch_queue_t v1 = sub_10000B070("sos-compatibility-mode-cached");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v2 = @"disabled";
    if (v0) {
      CFStringRef v2 = @"enabled";
    }
    int v4 = 138412290;
    CFStringRef v5 = v2;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Cached SOS Compatibility Mode is %@", (uint8_t *)&v4, 0xCu);
  }

  return v0;
}

uint64_t sub_10022C418(CFTypeRef *a1)
{
  CFStringRef v2 = _OctagonSignpostLogSystem();
  os_signpost_id_t v3 = _OctagonSignpostCreate();

  int v4 = _OctagonSignpostLogSystem();
  CFStringRef v5 = v4;
  unint64_t v6 = v3 - 1;
  if (v3 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v4))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_BEGIN, v3, "SOSCCFetchCompatibilityMode", " enableTelemetry=YES ", buf, 2u);
  }

  os_signpost_id_t v7 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v3;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "BEGIN [%lld]: SOSCCFetchCompatibilityMode  enableTelemetry=YES ", buf, 0xCu);
  }

  if (qword_10035D0A8 != -1) {
    dispatch_once(&qword_10035D0A8, &stru_100303AD8);
  }
  if (byte_10035D0A0)
  {
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&uint8_t buf[16] = 0x2020000000;
    LOBYTE(v29) = 0;
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 3221225472;
    v21[2] = sub_10022C8E8;
    v21[3] = &unk_1003090F0;
    void v21[4] = buf;
    sub_10021CD84(a1, v21);
    if (*(unsigned char *)(*(void *)&buf[8] + 24))
    {
      CFTypeRef v8 = sub_10000B070("sos-compatibility-mode");
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)unsigned int v22 = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Device is in circle, SOS Compatibility Mode is enabled", v22, 2u);
      }

      uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
      uint64_t v10 = _OctagonSignpostLogSystem();
      uint64_t v11 = v10;
      if (v6 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v10))
      {
        *(_DWORD *)unsigned int v22 = 67240192;
        LODWORD(v23) = 1;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v11, OS_SIGNPOST_INTERVAL_END, v3, "SOSCCFetchCompatibilityMode", " SOSSignpostNameSOSCCFetchCompatibilityMode=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCFetchCompatibilityMode}d ", v22, 8u);
      }

      int v12 = _OctagonSignpostLogSystem();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)unsigned int v22 = 134218496;
        os_signpost_id_t v23 = v3;
        __int16 v24 = 2048;
        double v25 = (double)(unint64_t)Nanoseconds / 1000000000.0;
        __int16 v26 = 1026;
        int v27 = 1;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCFetchCompatibilityMode  SOSSignpostNameSOSCCFetchCompatibilityMode=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCFetchCompatibilityMode}d ", v22, 0x1Cu);
      }

      _Block_object_dispose(buf, 8);
      return 1;
    }
    _Block_object_dispose(buf, 8);
  }
  BOOL v13 = -[OTSOSActualAdapter sosEnabled]_0();
  BOOL v14 = sub_10000B070("sos-compatibility-mode");
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v15 = @"disabled";
    if (v13) {
      CFStringRef v15 = @"enabled";
    }
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = v15;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "SOS Compatibility Mode is %@", buf, 0xCu);
  }

  uint64_t v16 = _OctagonSignpostGetNanoseconds();
  BOOL v17 = _OctagonSignpostLogSystem();
  CFStringRef v18 = v17;
  if (v6 < 0xFFFFFFFFFFFFFFFELL && os_signpost_enabled(v17))
  {
    *(_DWORD *)long long buf = 67240192;
    *(_DWORD *)&uint8_t buf[4] = v13;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v18, OS_SIGNPOST_INTERVAL_END, v3, "SOSCCFetchCompatibilityMode", " SOSSignpostNameSOSCCFetchCompatibilityMode=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCFetchCompatibilityMode}d ", buf, 8u);
  }

  double v19 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218496;
    *(void *)&uint8_t buf[4] = v3;
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(double *)&buf[14] = (double)(unint64_t)v16 / 1000000000.0;
    *(_WORD *)&buf[22] = 1026;
    BOOL v29 = v13;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: SOSCCFetchCompatibilityMode  SOSSignpostNameSOSCCFetchCompatibilityMode=%{public,signpost.telemetry:number1,name=SOSSignpostNameSOSCCFetchCompatibilityMode}d ", buf, 0x1Cu);
  }

  return v13;
}

void sub_10022C8BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10022C8E8(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = [v3 account];
  unsigned int v5 = [v4 getCircleStatus:0];

  if (!v5 && dword_10035D448 != 2)
  {
    dword_10035D448 = 2;
    unint64_t v6 = [v3 account];
    [v6 setSosCompatibilityMode:1];

    os_signpost_id_t v7 = [v3 account];
    [v7 setAccountIsChanging:0];

    uint64_t v8 = sub_10000CF0C(0);
    uint64_t v9 = sub_100134054(v8);
    uint64_t v10 = [v3 account];
    [v10 setFactory:v9];

    uint64_t v11 = [v3 account];
    [v11 SOSMonitorModeEnableSOS];

    int v12 = [v3 account];
    [v12 ensureFactoryCircles];

    BOOL v13 = [v3 account];
    [v13 setKey_interests_need_updating:1];

    BOOL v14 = [v3 account];
    [v14 setConsolidateKeyInterest:0];

    [v3 restart];
    CFStringRef v15 = [(id)objc_opt_class() logger];
    [v15 logSuccessForEventNamed:@"SOSDeferralEventCompatibilityModeEnabled"];

LABEL_5:
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    goto LABEL_6;
  }
  if (!v5) {
    goto LABEL_5;
  }
LABEL_6:
  BOOL v16 = v5 == 0;
  BOOL v17 = [v3 account];
  [v17 setSosCompatibilityMode:v16];

  return 1;
}

void sub_10022CA98(void *a1)
{
  CFTypeRef v3 = 0;
  sub_100220170(&v3, &stru_1003094E0);
  if (v3)
  {
    CFStringRef v2 = sub_10000B070("SecError");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      CFTypeRef v5 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SOSCCPushResetCircle_Server: error writing reset circle to kvs: %@", buf, 0xCu);
    }

    if (a1) {
      *a1 = v3;
    }
  }
}

BOOL sub_10022CB70(id a1, SOSAccountTransaction *a2, __CFError **a3)
{
  id v3 = [(SOSAccountTransaction *)a2 account];
  int v4 = +[NSMutableDictionary dictionary];
  CFTypeRef v5 = [v3 trust];

  [v5 trustedCircle];
  SOSCircleGetName();

  unint64_t v6 = (void *)SOSCircleKeyCreateWithName();
  if (v6)
  {
    os_signpost_id_t v7 = (const void *)SOSCircleCreate();
    if (v7)
    {
      uint64_t v10 = (void *)SOSCircleCopyEncodedData();
      CFRelease(v7);
      [v4 setObject:v10 forKeyedSubscript:v6];

      dispatch_semaphore_t v11 = dispatch_semaphore_create(0);
      dispatch_time_t v12 = dispatch_time(0, 30000000000);
      BOOL v13 = dispatch_get_global_queue(-2, 0);
      *(void *)&long long buf = _NSConcreteStackBlock;
      *((void *)&buf + 1) = 3221225472;
      CFStringRef v18 = sub_1001E72A0;
      double v19 = &unk_100308B28;
      dispatch_semaphore_t v20 = v11;
      BOOL v14 = v11;
      CFStringRef v15 = objc_retainBlock(&buf);
      SOSCloudKeychainPutObjectsInCloud();
      dispatch_semaphore_wait(v14, v12);
    }
    else
    {
      uint64_t v8 = sub_10000B070("SecError");
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "SOSAccountWriteEmptyCircleToKVS failed to create circle key: %@", (uint8_t *)&buf, 0xCu);
      }
    }
  }
  else
  {
    uint64_t v9 = sub_10000B070("SecError");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "SOSAccountWriteEmptyCircleToKVS failed to create circle key: %@", (uint8_t *)&buf, 0xCu);
    }
  }
  return 1;
}

uint64_t sub_10022CE6C(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = [v3 account];
  unsigned int v5 = [v4 SOSMonitorModeSOSIsActive];

  if (v5)
  {
    unint64_t v6 = [v3 account];
    uint64_t v7 = *(void *)(a1 + 32);
    id v8 = v6;
    uint64_t v9 = sub_10000B070("otrtimer");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v18[0]) = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "timer fired!", (uint8_t *)v18, 2u);
    }

    CFTypeRef cf = 0;
    uint64_t v10 = (uint64_t (**)(id, uint64_t, void))[v8 factory];
    dispatch_semaphore_t v11 = [v8 trust];
    [v11 trustedCircle];
    uint64_t Name = SOSCircleGetName();
    if (v10)
    {
      uint64_t v13 = v10[1](v10, Name, 0);
      if (v13)
      {
        uint64_t v10 = *(uint64_t (***)(id, uint64_t, void))v13;
        (*(void (**)(uint64_t, void))(v13 + 72))(v13, 0);
      }
      else
      {
        uint64_t v10 = 0;
      }
    }

    v18[0] = _NSConcreteStackBlock;
    v18[1] = 3221225472;
    v18[2] = sub_1001E8D84;
    void v18[3] = &unk_100307750;
    dispatch_semaphore_t v20 = v10;
    id v14 = v8;
    id v19 = v14;
    sub_1000FC5B8((uint64_t)v10, v7, (uint64_t)&cf, v18);
    if (cf)
    {
      CFStringRef v15 = sub_10000B070("otrtimer");
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412546;
        uint64_t v23 = v7;
        __int16 v24 = 2112;
        CFTypeRef v25 = cf;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "error grabbing engine for peer id: %@, error:%@", buf, 0x16u);
      }

      CFTypeRef v16 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        CFRelease(v16);
      }
    }
  }
  return 1;
}

uint64_t sub_10022D0B8(uint64_t a1, void *a2)
{
  id v3 = a2;
  int v4 = [v3 account];
  unsigned int v5 = [v4 SOSMonitorModeSOSIsActive];

  if (v5)
  {
    unint64_t v6 = *(void **)(a1 + 32);
    uint64_t v7 = *(void **)(a1 + 40);
    id v8 = v3;
    id v9 = v6;
    id v10 = v7;
    uint64_t v24 = 0;
    CFTypeRef v25 = &v24;
    uint64_t v26 = 0x3032000000;
    int v27 = sub_1001DF9B8;
    os_signpost_id_t v28 = sub_1001DF9C8;
    id v29 = (id)0xAAAAAAAAAAAAAAAALL;
    id v29 = [v8 account];
    CFTypeRef cf = 0;
    dispatch_semaphore_t v11 = [v8 account];
    dispatch_time_t v12 = (uint64_t (**)(id, uint64_t, void))[v11 factory];
    uint64_t v13 = [(id)v25[5] trust];
    [v13 trustedCircle];
    uint64_t Name = SOSCircleGetName();
    if (v12)
    {
      uint64_t v15 = v12[1](v12, Name, 0);
      if (v15)
      {
        dispatch_time_t v12 = *(uint64_t (***)(id, uint64_t, void))v15;
        (*(void (**)(uint64_t, void))(v15 + 72))(v15, 0);
      }
      else
      {
        dispatch_time_t v12 = 0;
      }
    }

    v20[0] = _NSConcreteStackBlock;
    v20[1] = 3221225472;
    v20[2] = sub_1001E92CC;
    v20[3] = &unk_100307778;
    id v16 = v10;
    id v21 = v16;
    unsigned int v22 = &v24;
    sub_1000FC5B8((uint64_t)v12, (uint64_t)v9, (uint64_t)&cf, v20);
    if (cf)
    {
      BOOL v17 = sub_10000B070("otrtimer");
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412546;
        id v31 = v9;
        __int16 v32 = 2112;
        CFTypeRef v33 = cf;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "error grabbing engine for peer id: %@, error:%@", buf, 0x16u);
      }

      CFTypeRef v18 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        CFRelease(v18);
      }
    }

    _Block_object_dispose(&v24, 8);
  }

  return 1;
}

void sub_10022D344(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10022D368(uint64_t a1, void *a2, const void **a3)
{
  if (a3) {
    int v4 = *a3;
  }
  else {
    int v4 = 0;
  }
  CFTypeRef cf = v4;
  unsigned int v5 = [a2 account];
  unint64_t v6 = [v5 trust];
  id v7 = [v6 fullPeerInfo];

  if (v7)
  {
    id v8 = (const void *)SOSFullPeerInfoCopyOctagonSigningKey();
    if (!v8 || cf)
    {
      dispatch_time_t v12 = sub_10000B070("SecError");
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        CFTypeRef v16 = cf;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "SOSCCPerformWithAllOctagonKeys signing key error: %@", buf, 0xCu);
      }
    }
    else
    {
      id v9 = (const void *)SOSFullPeerInfoCopyOctagonEncryptionKey();
      if (v9)
      {
        (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
        CFRelease(v8);
        CFRelease(v9);
        return 1;
      }
      uint64_t v13 = sub_10000B070("SecError");
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        CFTypeRef v16 = 0;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "SOSCCPerformWithAllOctagonKeys encryption key error: %@", buf, 0xCu);
      }
    }
  }
  else
  {
    dispatch_semaphore_t v11 = sub_10000B070("SecError");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "device does not have a peer", buf, 2u);
    }

    SOSCreateError();
    id v8 = 0;
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  if (cf) {
    CFRelease(cf);
  }
  if (v8) {
    CFRelease(v8);
  }
  return 1;
}

void sub_10022D5F4(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v5 = a1;
  PrivateAttributeDictionary = (void *)SecKeyGeneratePrivateAttributeDictionary();
  id v7 = [PrivateAttributeDictionary mutableCopy];

  [v7 setObject:v5 forKeyedSubscript:kSecAttrLabel];
  [v7 setObject:&__kCFBooleanTrue forKeyedSubscript:kSecUseDataProtectionKeychain];
  [v7 setObject:kCFBooleanFalse forKeyedSubscript:kSecAttrSynchronizable];
  [v7 setObject:kSOSInternalAccessGroup forKeyedSubscript:kSecAttrAccessGroup];
  CFTypeRef result = 0;
  uint64_t v8 = SecItemAdd((CFDictionaryRef)v7, &result);
  if (v8)
  {
    if (v8 == -25299)
    {
      id v9 = objc_alloc_init((Class)NSMutableDictionary);
      id v10 = [v7 objectForKeyedSubscript:kSecClass];
      [v9 setObject:v10 forKeyedSubscript:kSecClass];

      dispatch_semaphore_t v11 = [v7 objectForKeyedSubscript:kSecAttrKeyTypeEC];
      [v9 setObject:v11 forKeyedSubscript:kSecAttrKeyType];

      dispatch_time_t v12 = [v7 objectForKeyedSubscript:kSecAttrKeyClassPrivate];
      [v9 setObject:v12 forKeyedSubscript:kSecAttrKeyClass];

      uint64_t v13 = [v7 objectForKeyedSubscript:kSecAttrAccessGroup];
      [v9 setObject:v13 forKeyedSubscript:kSecAttrAccessGroup];

      id v14 = [v7 objectForKeyedSubscript:kSecAttrLabel];
      [v9 setObject:v14 forKeyedSubscript:kSecAttrLabel];

      uint64_t v15 = [v7 objectForKeyedSubscript:kSecAttrApplicationLabel];
      [v9 setObject:v15 forKeyedSubscript:kSecAttrApplicationLabel];

      CFTypeRef v16 = [v7 objectForKeyedSubscript:kSecUseDataProtectionKeychain];
      [v9 setObject:v16 forKeyedSubscript:kSecUseDataProtectionKeychain];

      id v17 = [v7 mutableCopy];
      [v17 setObject:0 forKeyedSubscript:kSecClass];
      uint64_t v18 = SecItemUpdate((CFDictionaryRef)v9, (CFDictionaryRef)v17);
      if (v18)
      {
        uint64_t v19 = (int)v18;
        dispatch_semaphore_t v20 = +[NSString stringWithFormat:@"SecItemUpdate: %d", v18];
        id v21 = +[NSError errorWithDomain:NSOSStatusErrorDomain code:v19 description:v20];
      }
      else
      {
        id v21 = 0;
      }
    }
    else
    {
      uint64_t v22 = (int)v8;
      id v9 = +[NSString stringWithFormat:@"SecItemAdd: %d", v8];
      id v21 = +[NSError errorWithDomain:NSOSStatusErrorDomain code:v22 description:v9];
    }

    if (a4 && v21) {
      *a4 = v21;
    }
  }
}

void sub_10022D980(uint64_t a1, void *a2)
{
  id v3 = @"sync";
  id v4 = a2;
  id v5 = (void *)SecKeyCopyPublicKeyHash();
  v17[0] = kSecClass;
  v17[1] = kSecAttrSynchronizable;
  v18[0] = kSecClassKey;
  v18[1] = kSecAttrSynchronizableAny;
  void v17[2] = kSecAttrApplicationLabel;
  void v17[3] = kSecAttrAccessGroup;
  v18[2] = v5;
  void v18[3] = @"sync";
  CFDictionaryRef v6 = +[NSDictionary dictionaryWithObjects:v18 forKeys:v17 count:4];
  CFStringRef v15 = kSecAttrAccessGroup;
  id v16 = v4;
  OSStatus v7 = SecItemUpdate(v6, (CFDictionaryRef)+[NSDictionary dictionaryWithObjects:&v16 forKeys:&v15 count:1]);
  uint64_t v8 = sub_10000B070("octagon");
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 138412802;
    id v10 = v4;
    __int16 v11 = 2112;
    CFStringRef v12 = @"sync";
    __int16 v13 = 1024;
    OSStatus v14 = v7;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Ensuring key agrp ('%@' from '%@') status: %d", (uint8_t *)&v9, 0x1Cu);
  }
}

uint64_t sub_10022DB30(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v16 = 0;
  id v4 = [v3 account];
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  long long v9 = *(_OWORD *)(a1 + 32);
  long long v13 = *(_OWORD *)(a1 + 48);
  void v10[2] = sub_10022DC2C;
  void v10[3] = &unk_100309530;
  id v11 = v3;
  uint64_t v14 = *(void *)(a1 + 64);
  id v5 = (id)v9;
  long long v12 = v9;
  long long v15 = *(_OWORD *)(a1 + 72);
  id v6 = v3;
  uint64_t v7 = sub_1001F0E0C(v4, @"Updating Octagon Keys in SOS", (uint64_t)&v16, v10);

  return v7;
}

uint64_t sub_10022DC2C(uint64_t a1, uint64_t a2)
{
  id v4 = [*(id *)(a1 + 32) account];
  id v5 = sub_10022DF5C(v4, *(void **)(a1 + 48), *(void **)(a1 + 56), *(void *)(a1 + 64), *(void *)(a1 + 72));

  if (v5)
  {
    id v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v21 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: failed to save Octagon keys to the keychain: %@", buf, 0xCu);
    }

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
LABEL_5:
    uint64_t v7 = 0;
    goto LABEL_6;
  }
  if (!a2)
  {
    long long v9 = sub_10000B070("octagon");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "No peer info to update?", buf, 2u);
    }

    uint64_t v10 = kSOSErrorDomain;
    NSErrorUserInfoKey v18 = NSLocalizedDescriptionKey;
    CFStringRef v19 = @"Device has no full peer info";
    id v11 = +[NSDictionary dictionaryWithObjects:&v19 forKeys:&v18 count:1];
    long long v12 = +[NSError errorWithDomain:v10 code:1032 userInfo:v11];

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    goto LABEL_5;
  }
  SOSPeerInfoSetOctagonKeysInDescription();
  uint64_t v13 = *(void *)(a1 + 80);
  if (v13) {
    CFRetain(*(CFTypeRef *)(a1 + 80));
  }
  uint64_t v14 = [*(id *)(a1 + 32) account];
  [v14 setOctagonSigningFullKeyRef:v13];

  uint64_t v15 = *(void *)(a1 + 88);
  if (v15) {
    CFRetain(*(CFTypeRef *)(a1 + 88));
  }
  uint64_t v16 = [*(id *)(a1 + 32) account];
  [v16 setOctagonEncryptionFullKeyRef:v15];

  id v17 = sub_10000B070("octagon");
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Success! Updated Octagon keys in SOS!", buf, 2u);
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  uint64_t v7 = 1;
LABEL_6:

  return v7;
}

id sub_10022DF5C(void *a1, void *a2, void *a3, uint64_t a4, uint64_t a5)
{
  id v9 = a3;
  id v10 = a2;
  id v11 = a1;
  long long v12 = [v11 trust];
  [v12 trustedCircle];
  uint64_t v13 = SOSCircleGetName();

  uint64_t v14 = [v11 gestalt];
  uint64_t v15 = sub_10022E180((uint64_t)v14, v13, @"Octagon Peer Signing ");

  uint64_t v16 = [v11 gestalt];

  id v17 = sub_10022E180((uint64_t)v16, v13, @"Octagon Peer Encryption ");

  id v24 = 0;
  sub_10022D5F4(v15, (uint64_t)v10, a4, &v24);

  id v18 = v24;
  if (v18)
  {
    id v19 = v18;
    dispatch_semaphore_t v20 = sub_10000B070("SecError");
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v26 = v19;
      id v21 = "octagon: could not save signing key: %@";
LABEL_7:
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, v21, buf, 0xCu);
    }
  }
  else
  {
    id v23 = 0;
    sub_10022D5F4(v17, (uint64_t)v9, a5, &v23);
    id v19 = v23;
    if (!v19) {
      goto LABEL_9;
    }
    dispatch_semaphore_t v20 = sub_10000B070("SecError");
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v26 = v19;
      id v21 = "octagon: could not save encryption key: %@";
      goto LABEL_7;
    }
  }

LABEL_9:

  return v19;
}

id sub_10022E180(uint64_t a1, void *a2, void *a3)
{
  id v4 = a3;
  id v5 = a2;
  id v6 = +[NSString stringWithFormat:@"ID for %@-%@", SOSPeerGestaltGetName(), v5];

  uint64_t v7 = [v4 stringByAppendingString:v6];

  return v7;
}

uint64_t sub_10022E224(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [v3 account];
  id v5 = sub_10022DF5C(v4, *(void **)(a1 + 40), *(void **)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 64));

  if (v5)
  {
    id v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v22 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon-preload-keys: failed to save Octagon keys to the keychain: %@", buf, 0xCu);
    }

    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
LABEL_5:
    uint64_t v7 = 0;
    goto LABEL_14;
  }
  uint64_t v8 = [v3 account];

  if (!v8)
  {
    uint64_t v15 = sub_10000B070("octagon-preload-keys");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "No SOSAccount to update?", buf, 2u);
    }

    uint64_t v16 = kSOSErrorDomain;
    NSErrorUserInfoKey v19 = NSLocalizedDescriptionKey;
    CFStringRef v20 = @"Device has no SOSAccount";
    id v17 = +[NSDictionary dictionaryWithObjects:&v20 forKeys:&v19 count:1];
    id v18 = +[NSError errorWithDomain:v16 code:1048 userInfo:v17];

    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
    goto LABEL_5;
  }
  uint64_t v9 = *(void *)(a1 + 72);
  if (v9) {
    CFRetain(*(CFTypeRef *)(a1 + 72));
  }
  id v10 = [v3 account];
  [v10 setOctagonSigningFullKeyRef:v9];

  uint64_t v11 = *(void *)(a1 + 80);
  if (v11) {
    CFRetain(*(CFTypeRef *)(a1 + 80));
  }
  long long v12 = [v3 account];
  [v12 setOctagonEncryptionFullKeyRef:v11];

  uint64_t v13 = sub_10000B070("octagon-preload-keys");
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Success! Octagon Keys Preloaded!", buf, 2u);
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  uint64_t v7 = 1;
LABEL_14:

  return v7;
}

uint64_t sub_10022E4E0(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = [a2 account];
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  void v7[2] = sub_10022E58C;
  v7[3] = &unk_100309578;
  char v8 = *(unsigned char *)(a1 + 32);
  sub_1001F0BCC(v5, @"CKKS4All update", a3, v7);

  return 1;
}

uint64_t sub_10022E58C(uint64_t a1, uint64_t a2)
{
  return _SOSFullPeerInfoSetCKKS4AllSupport(a2, *(unsigned __int8 *)(a1 + 32));
}

uint64_t sub_10022E59C(uint64_t a1, void *a2)
{
  id v3 = [a2 account];
  id v4 = [v3 trust];
  id v5 = [v4 copyPeerSetMatching:&stru_1003095B8];

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  if (v5) {
    CFRelease(v5);
  }
  return 1;
}

BOOL sub_10022E638(id a1, __OpaqueSOSPeerInfo *a2)
{
  return 1;
}

uint64_t sub_10022E9CC()
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_10022EA64;
  block[3] = &unk_100309A20;
  void block[4] = &qword_10035D490;
  if (qword_10035D488 != -1) {
    dispatch_once(&qword_10035D488, block);
  }
  return qword_10035D490;
}

uint64_t sub_10022EA64(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

__CFString *sub_10022EA98(uint64_t a1)
{
  CFDictionaryRef v2 = (const __CFDictionary *)sub_100025824();

  return sub_10022EAD4(a1, v2);
}

__CFString *sub_10022EAD4(uint64_t a1, const __CFDictionary *a2)
{
  sub_10022EE8C((void *)a1);
  sub_10022EE8C((void *)a1);
  CFSetRef Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"PeerIDs");
  if (!Value || (v5 = Value, CFTypeID v6 = CFGetTypeID(Value), v6 != CFSetGetTypeID())) {
    CFSetRef v5 = 0;
  }
  CFMutableStringRef v7 = sub_10022F180(v5);
  sub_10022EE8C((void *)a1);
  CFSetRef v8 = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"Applicants");
  CFMutableStringRef v9 = sub_10022F180(v8);
  sub_10022EE8C((void *)a1);
  CFSetRef v10 = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"Rejections");
  CFMutableStringRef v11 = sub_10022F180(v10);
  CFDictionaryRef v19 = sub_10022F290((uint64_t)v11, v12, v13, v14, v15, v16, v17, v18, @"MEMBER", (uint64_t)v7);
  if (v7) {
    CFRelease(v7);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v11) {
    CFRelease(v11);
  }
  v34[0] = 0;
  v34[1] = v34;
  v34[2] = 0x2000000000;
  char v35 = 0;
  CFMutableStringRef Mutable = CFStringCreateMutable(0, 0);
  CFDictionaryRef v21 = *(const __CFDictionary **)(a1 + 32);
  context[0] = _NSConcreteStackBlock;
  context[1] = 0x40000000;
  context[2] = sub_10022F0B0;
  context[3] = &unk_100309A90;
  void context[4] = v34;
  void context[5] = Mutable;
  CFDictionaryApplyFunction(v21, (CFDictionaryApplierFunction)sub_10022F164, context);
  _Block_object_dispose(v34, 8);
  CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"Generation");
  uint64_t v22 = (const void *)SOSGenerationCountCopyDescription();
  id v23 = CFStringCreateMutable(kCFAllocatorDefault, 0);
  id v24 = sub_10022F02C(*(const __CFDictionary **)(a1 + 24));
  CFStringAppendFormat(v23, a2, @"<SOSRing: '%@'", v24);
  CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"Generation");
  SOSGenerationCountWithDescription();
  CFStringRef v25 = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"LastModifier");
  if (v25)
  {
    CFStringRef v26 = v25;
    if (CFStringGetLength(v25) > 8)
    {
      v36.id location = 0;
      v36.size_t length = 8;
      CFStringRef Copy = CFStringCreateWithSubstring(kCFAllocatorDefault, v26, v36);
    }
    else
    {
      CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, v26);
    }
    CFStringRef v28 = Copy;
    CFStringAppendFormat(v23, a2, @"Mod: %@, ", Copy);
    if (v28) {
      CFRelease(v28);
    }
  }
  else
  {
    CFStringAppendFormat(v23, a2, @"Mod: %@, ", 0);
  }
  id v29 = CFDictionaryGetValue(v19, @"MEMBER");
  CFStringAppendFormat(v23, a2, @"P: [%@], ", v29);
  int v30 = CFDictionaryGetValue(v19, @"APPLICANTS");
  CFStringAppendFormat(v23, a2, @"A: [%@], ", v30);
  id v31 = CFDictionaryGetValue(v19, @"REJECTS");
  CFStringAppendFormat(v23, a2, @"R: [%@], ", v31);
  CFStringAppendFormat(v23, a2, @"S: [%@]>", Mutable);
  if (v22) {
    CFRelease(v22);
  }
  if (v19) {
    CFRelease(v19);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  return v23;
}

uint64_t sub_10022EE8C(void *a1)
{
  if (!a1)
  {
    CFDictionaryRef v2 = sub_10000B070("SecError");
    BOOL v3 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v3) {
      return result;
    }
    __int16 v14 = 0;
    id v4 = "no ring passed in";
    CFSetRef v5 = (uint8_t *)&v14;
    goto LABEL_18;
  }
  if (!a1[2])
  {
    CFDictionaryRef v2 = sub_10000B070("SecError");
    BOOL v6 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v6) {
      return result;
    }
    __int16 v13 = 0;
    id v4 = "ring has no unSignedInformation";
    CFSetRef v5 = (uint8_t *)&v13;
    goto LABEL_18;
  }
  if (!a1[3])
  {
    CFDictionaryRef v2 = sub_10000B070("SecError");
    BOOL v7 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v7) {
      return result;
    }
    __int16 v12 = 0;
    id v4 = "ring has no signedInformation";
    CFSetRef v5 = (uint8_t *)&v12;
    goto LABEL_18;
  }
  if (!a1[4])
  {
    CFDictionaryRef v2 = sub_10000B070("SecError");
    BOOL v8 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v8) {
      return result;
    }
    __int16 v11 = 0;
    id v4 = "ring has no signatures";
    CFSetRef v5 = (uint8_t *)&v11;
LABEL_18:
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, v4, v5, 2u);
    return 0;
  }
  if (a1[5]) {
    return 1;
  }
  CFDictionaryRef v2 = sub_10000B070("SecError");
  BOOL v9 = os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v9)
  {
    __int16 v10 = 0;
    id v4 = "ring has no data";
    CFSetRef v5 = (uint8_t *)&v10;
    goto LABEL_18;
  }
  return result;
}

const void *sub_10022F02C(const __CFDictionary *a1)
{
  CFSetRef Value = CFDictionaryGetValue(a1, @"RingName");
  if (!Value) {
    return 0;
  }
  CFDictionaryRef v2 = Value;
  CFTypeID v3 = CFGetTypeID(Value);
  if (v3 != CFStringGetTypeID()) {
    return 0;
  }
  return v2;
}

void sub_10022F078(uint64_t a1, uint64_t a2)
{
}

void sub_10022F0B0(uint64_t a1, CFStringRef theString)
{
  CFStringRef v2 = theString;
  if (theString)
  {
    if (CFStringGetLength(theString) > 8)
    {
      v5.id location = 0;
      v5.size_t length = 8;
      CFStringRef Copy = CFStringCreateWithSubstring(kCFAllocatorDefault, v2, v5);
    }
    else
    {
      CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, v2);
    }
    CFStringRef v2 = Copy;
  }
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    CFStringAppendCString(*(CFMutableStringRef *)(a1 + 40), ", ", 0x8000100u);
  }
  CFStringAppend(*(CFMutableStringRef *)(a1 + 40), v2);
  if (v2) {
    CFRelease(v2);
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
}

uint64_t sub_10022F164(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

CFMutableStringRef sub_10022F180(const __CFSet *a1)
{
  CFMutableStringRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  CFMutableStringRef v3 = Mutable;
  v6[0] = 0;
  v6[1] = v6;
  v6[2] = 0x2000000000;
  char v7 = 0;
  if (a1)
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 0x40000000;
    _DWORD v5[2] = sub_10022F380;
    void v5[3] = &unk_100309AB8;
    void v5[4] = v6;
    void v5[5] = Mutable;
    context[0] = _NSConcreteStackBlock;
    context[1] = 0x40000000;
    context[2] = sub_10022F444;
    context[3] = &unk_100309AE0;
    void context[4] = v5;
    CFSetApplyFunction(a1, (CFSetApplierFunction)sub_10022F454, context);
  }
  _Block_object_dispose(v6, 8);
  return v3;
}

CFDictionaryRef sub_10022F290(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10)
{
  CFDictionaryRef v21 = &a10;
  unint64_t v10 = 0;
  if (a9)
  {
    do
    {
      v10 += 2;
      __int16 v11 = v21;
      v21 += 2;
    }
    while (v11[1]);
  }
  unint64_t v12 = v10 >> 1;
  uint64_t v22 = (const void **)&a9;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, v10 >> 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable) {
    return 0;
  }
  __int16 v14 = Mutable;
  if (v10)
  {
    do
    {
      uint64_t v15 = v22;
      uint64_t v16 = *v22;
      v22 += 2;
      CFNullRef v17 = (const __CFNull *)v15[1];
      if (v17) {
        CFNullRef v18 = v17;
      }
      else {
        CFNullRef v18 = kCFNull;
      }
      CFDictionarySetValue(v14, v16, v18);
      --v12;
    }
    while (v12);
  }
  CFDictionaryRef Copy = CFDictionaryCreateCopy(0, v14);
  CFRelease(v14);
  return Copy;
}

void sub_10022F380(uint64_t a1, CFStringRef theString)
{
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    CFStringAppendCString(*(CFMutableStringRef *)(a1 + 40), ", ", 0x8000100u);
  }
  if (theString)
  {
    if (CFStringGetLength(theString) > 8)
    {
      v6.id location = 0;
      v6.size_t length = 8;
      CFStringRef Copy = CFStringCreateWithSubstring(kCFAllocatorDefault, theString, v6);
    }
    else
    {
      CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, theString);
    }
    CFStringRef v5 = Copy;
    CFStringAppend(*(CFMutableStringRef *)(a1 + 40), Copy);
    if (v5) {
      CFRelease(v5);
    }
  }
  else
  {
    CFStringAppend(*(CFMutableStringRef *)(a1 + 40), 0);
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
}

uint64_t sub_10022F444(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_10022F454(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_10022F46C(void *a1, void *a2)
{
  CFMutableStringRef v3 = a1;
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != sub_10022E9CC()) {
    return 0;
  }
  CFTypeID v5 = CFGetTypeID(a2);
  if (v5 != sub_10022E9CC()) {
    return 0;
  }
  CFTypeID v6 = CFGetTypeID(v3);
  if (v6 == sub_10022E9CC()) {
    sub_10022EE8C(v3);
  }
  else {
    CFMutableStringRef v3 = 0;
  }
  CFTypeID v7 = CFGetTypeID(a2);
  if (v7 != sub_10022E9CC()) {
    return 0;
  }
  sub_10022EE8C(a2);
  uint64_t result = 0;
  if (!a2 || !v3) {
    return result;
  }
  BOOL v9 = (const void *)v3[2];
  unint64_t v10 = (const void *)a2[2];
  if (v9 && v10)
  {
    uint64_t result = CFEqual(v9, v10);
    if (!result) {
      return result;
    }
  }
  else if (v9 != v10)
  {
    return 0;
  }
  __int16 v11 = (const void *)v3[3];
  unint64_t v12 = (const void *)a2[3];
  if (v11 && v12)
  {
    uint64_t result = CFEqual(v11, v12);
    if (!result) {
      return result;
    }
  }
  else if (v11 != v12)
  {
    return 0;
  }
  __int16 v13 = (const void *)v3[5];
  __int16 v14 = (const void *)a2[5];
  if (v13 && v14)
  {
    uint64_t result = CFEqual(v13, v14);
    if (!result) {
      return result;
    }
    goto LABEL_26;
  }
  if (v13 != v14) {
    return 0;
  }
LABEL_26:
  uint64_t v15 = (const void *)v3[4];
  uint64_t v16 = (const void *)a2[4];
  if (v15 && v16) {
    return CFEqual(v15, v16) != 0;
  }
  else {
    return v15 == v16;
  }
}

void sub_10022F5B4(void *a1)
{
  CFStringRef v2 = (const void *)a1[2];
  if (v2)
  {
    a1[2] = 0;
    CFRelease(v2);
  }
  CFMutableStringRef v3 = (const void *)a1[3];
  if (v3)
  {
    a1[3] = 0;
    CFRelease(v3);
  }
  CFTypeID v4 = (const void *)a1[5];
  if (v4)
  {
    a1[5] = 0;
    CFRelease(v4);
  }
  CFTypeID v5 = (const void *)a1[4];
  if (v5)
  {
    a1[4] = 0;
    CFRelease(v5);
  }
}

uint64_t sub_10022F62C(void *a1)
{
  uint64_t v2 = 64429;
  unsigned int valuePtr = 64429;
  if (sub_10022EE8C(a1))
  {
    CFDictionaryRef v3 = (const __CFDictionary *)a1[3];
    if (v3)
    {
      CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v3, @"RingType");
      if (Value)
      {
        CFNumberRef v5 = Value;
        CFTypeID v6 = CFGetTypeID(Value);
        if (v6 == CFNumberGetTypeID())
        {
          CFNumberGetValue(v5, kCFNumberSInt32Type, &valuePtr);
          return valuePtr;
        }
        else
        {
          return 64429;
        }
      }
    }
  }
  return v2;
}

uint64_t sub_10022F6B4(const __CFDictionary *a1, uint64_t a2)
{
  CFNumberRef Value = CFDictionaryGetValue(a1, @"Generation");
  CFTypeID v4 = CFDictionaryGetValue(*(CFDictionaryRef *)(a2 + 24), @"Generation");

  return _SOSGenerationIsOlder(Value, v4);
}

BOOL sub_10022F714(uint64_t a1, const void *a2)
{
  sub_10022EE8C((void *)a1);
  sub_10022EE8C((void *)a1);
  CFSetRef Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"Applicants");
  return CFSetContainsValue(Value, a2) != 0;
}

BOOL sub_10022F764(uint64_t a1, const void *a2)
{
  sub_10022EE8C((void *)a1);
  sub_10022EE8C((void *)a1);
  CFSetRef Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"Rejections");
  return CFSetContainsValue(Value, a2) != 0;
}

void sub_10022F7B4(uint64_t a1, const void *a2)
{
  sub_10022EE8C((void *)a1);
  CFSetRef Value = (__CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"Rejections");

  CFSetRemoveValue(Value, a2);
}

const void *sub_10022F800(uint64_t a1)
{
  sub_10022EE8C((void *)a1);
  CFSetRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"BackupViews");
  if (!Value) {
    return 0;
  }
  CFDictionaryRef v3 = Value;
  CFTypeID v4 = CFGetTypeID(Value);
  if (v4 != CFSetGetTypeID()) {
    return 0;
  }
  return v3;
}

BOOL sub_10022F858(uint64_t a1, const void *a2)
{
  if (a2) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), @"BackupViews", a2);
  }
  return a2 != 0;
}

BOOL sub_10022F8A0(uint64_t a1, const void *a2)
{
  if (a2) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), @"PeerIDs", a2);
  }
  return a2 != 0;
}

BOOL sub_10022F8E8(uint64_t a1, const void *a2)
{
  sub_10022EE8C((void *)a1);
  sub_10022EE8C((void *)a1);
  CFSetRef Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"PeerIDs");
  if (!Value || (v5 = Value, CFTypeID v6 = CFGetTypeID(Value), v6 != CFSetGetTypeID())) {
    CFSetRef v5 = 0;
  }
  return CFSetContainsValue(v5, a2) != 0;
}

CFMutableSetRef sub_10022F964(uint64_t a1)
{
  sub_10022EE8C((void *)a1);
  CFSetRef Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"PeerIDs");
  if (!Value || (v3 = Value, CFTypeID v4 = CFGetTypeID(Value), v4 != CFSetGetTypeID())) {
    CFSetRef v3 = 0;
  }

  return CFSetCreateMutableCopy(0, 0, v3);
}

void sub_10022F9D4(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeRef PeerID = cf;
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 != SOSPeerInfoGetTypeID() || (CFTypeRef PeerID = (CFTypeRef)SOSPeerInfoGetPeerID()) != 0)
    {
      CFTypeID v5 = CFGetTypeID(PeerID);
      if (v5 == CFStringGetTypeID())
      {
        uint64_t v6 = *(void *)(a1 + 32);
        sub_10022FA6C(v6, PeerID);
      }
    }
  }
}

void sub_10022FA6C(uint64_t a1, const void *a2)
{
  sub_10022EE8C((void *)a1);
  CFSetRef Value = (__CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"PeerIDs");
  if (!Value || (v5 = Value, CFTypeID v6 = CFGetTypeID(Value), v6 != CFSetGetTypeID())) {
    CFTypeID v5 = 0;
  }

  CFSetAddValue(v5, a2);
}

void sub_10022FAE4(uint64_t a1, uint64_t a2)
{
  sub_10022EE8C((void *)a1);
  sub_10022EE8C((void *)a1);
  CFSetRef Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"PeerIDs");
  if (Value)
  {
    CFSetRef v5 = Value;
    CFTypeID v6 = CFGetTypeID(Value);
    if (v6 == CFSetGetTypeID())
    {
      context[0] = _NSConcreteStackBlock;
      context[1] = 0x40000000;
      context[2] = sub_10022FBB4;
      context[3] = &unk_100309A68;
      void context[4] = a2;
      CFSetApplyFunction(v5, (CFSetApplierFunction)sub_10022F454, context);
    }
  }
}

uint64_t sub_10022FBB4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_10022FBC4(const void *a1, int a2)
{
  sub_10022E9CC();
  uint64_t Instance = _CFRuntimeCreateInstance();
  CFSetRef v5 = (const void *)SOSGenerationCreate();
  if (!a1)
  {
    SOSCreateError();
    if (v5) {
LABEL_26:
    }
      CFRelease(v5);
LABEL_27:
    uint64_t v20 = 0;
    uint64_t result = 0;
    CFMutableSetRef v19 = (CFMutableSetRef)Instance;
    if (!Instance) {
      return result;
    }
    goto LABEL_28;
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  *(void *)(Instance + 16) = Mutable;
  if (!Mutable) {
    goto LABEL_17;
  }
  CFMutableDictionaryRef v7 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  *(void *)(Instance + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v7;
  if (!v7) {
    goto LABEL_17;
  }
  CFMutableDictionaryRef v8 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  *(void *)(Instance + 32) = v8;
  if (!v8
    || (CFMutableDictionaryRef v9 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks),
        (*(void *)(Instance + 40) = v9) == 0)
    || (CFDictionarySetValue(*(CFMutableDictionaryRef *)(Instance + 24), @"RingName", a1),
        int valuePtr = a2,
        sub_10022EE8C((void *)Instance),
        (CFNumberRef v10 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr)) == 0))
  {
LABEL_17:
    SOSCreateError();
    uint64_t v22 = *(const void **)(Instance + 16);
    if (v22)
    {
      *(void *)(Instance + 16) = 0;
      CFRelease(v22);
    }
    id v23 = *(const void **)(Instance + 24);
    if (v23)
    {
      *(void *)(Instance + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 0;
      CFRelease(v23);
    }
    id v24 = *(const void **)(Instance + 32);
    if (v24)
    {
      *(void *)(Instance + 32) = 0;
      CFRelease(v24);
    }
    CFStringRef v25 = *(const void **)(Instance + 40);
    if (v25)
    {
      *(void *)(Instance + 40) = 0;
      CFRelease(v25);
    }
    if (v5) {
      goto LABEL_26;
    }
    goto LABEL_27;
  }
  CFNumberRef v11 = v10;
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(Instance + 24), @"RingType", v10);
  CFRelease(v11);
  int v30 = 1;
  CFNumberRef v12 = CFNumberCreate(0, kCFNumberSInt32Type, &v30);
  if (!v12)
  {
    CFStringRef v26 = sub_10000B070("ring");
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Could not create version number", buf, 2u);
    }
    goto LABEL_17;
  }
  CFNumberRef v13 = v12;
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(Instance + 24), @"RingVersion", v12);
  CFRelease(v13);
  CFUUIDRef v14 = CFUUIDCreate(0);
  if (!v14)
  {
    int v27 = sub_10000B070("ring");
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v31 = 0;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Could not create ring identifier", v31, 2u);
    }
    goto LABEL_17;
  }
  CFUUIDRef v15 = v14;
  CFStringRef v16 = CFUUIDCreateString(0, v14);
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(Instance + 24), @"Identifier", v16);
  CFRelease(v15);
  if (v16) {
    CFRelease(v16);
  }
  CFMutableSetRef v17 = CFSetCreateMutable(0, 0, &kCFTypeSetCallBacks);
  sub_10022EE8C((void *)Instance);
  if (!v17) {
    goto LABEL_17;
  }
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(Instance + 16), @"Applicants", v17);
  CFRelease(v17);
  CFMutableSetRef v18 = CFSetCreateMutable(0, 0, &kCFTypeSetCallBacks);
  sub_10022EE8C((void *)Instance);
  if (!v18) {
    goto LABEL_17;
  }
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(Instance + 16), @"Rejections", v18);
  CFRelease(v18);
  if (!v5) {
    goto LABEL_17;
  }
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(Instance + 24), @"Generation", v5);
  CFMutableSetRef v19 = CFSetCreateMutable(0, 0, &kCFTypeSetCallBacks);
  if (!sub_10022F8A0(Instance, v19)) {
    goto LABEL_17;
  }
  CFRelease(v5);
  uint64_t v20 = Instance;
  uint64_t result = Instance;
  if (!v19) {
    return result;
  }
LABEL_28:
  CFRelease(v19);
  return v20;
}

BOOL sub_10023000C(uint64_t a1)
{
  sub_10022EE8C((void *)a1);
  CFSetRef Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"PeerIDs");
  if (!Value || (v3 = Value, CFTypeID v4 = CFGetTypeID(Value), v4 != CFSetGetTypeID())) {
    CFSetRef v3 = 0;
  }
  return CFSetGetCount(v3) == 0;
}

void sub_100230070(uint64_t a1)
{
  sub_10022EE8C((void *)a1);
  CFSetRef Value = (__CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"Applicants");
  CFSetRemoveAllValues(Value);
  sub_10022EE8C((void *)a1);
  CFSetRef v3 = (__CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 16), @"Rejections");
  CFSetRemoveAllValues(v3);
  sub_10022EE8C((void *)a1);
  CFTypeID v4 = (__CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"PeerIDs");
  if (!v4 || (v5 = v4, CFTypeID v6 = CFGetTypeID(v4), v6 != CFSetGetTypeID())) {
    CFSetRef v5 = 0;
  }
  CFSetRemoveAllValues(v5);
  CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 32));
  CFMutableDictionaryRef v7 = (const void *)SOSGenerationCreate();
  if (v7)
  {
    CFMutableDictionaryRef v8 = v7;
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), @"Generation", v7);
    CFRelease(v8);
  }
}

BOOL sub_100230158(uint64_t a1)
{
  uint64_t v2 = (const void *)SOSCopyIDOfKey();
  CFSetRef v3 = v2;
  if (a1 && v2)
  {
    CFSetRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), v2);
    CFSetRef v5 = Value;
    if (Value)
    {
      CFTypeID v6 = CFGetTypeID(Value);
      if (v6 != CFDataGetTypeID()) {
        CFSetRef v5 = 0;
      }
    }
    goto LABEL_8;
  }
  CFSetRef v5 = 0;
  CFMutableDictionaryRef v7 = 0;
  if (v2)
  {
LABEL_8:
    CFRelease(v3);
    CFMutableDictionaryRef v7 = v5;
  }
  return v7 != 0;
}

BOOL sub_1002301F0(uint64_t a1, __SecKey *a2, CFTypeRef *a3)
{
  CFDataRef v6 = (const __CFData *)SOSCopyIDOfKey();
  CFDataRef v7 = v6;
  if (a1 && v6)
  {
    CFDataRef Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), v6);
    if (Value && (v9 = Value, CFTypeID v10 = CFGetTypeID(Value), v10 == CFDataGetTypeID()))
    {
      CFRelease(v7);
      CFNumberRef v11 = (CFIndex *)ccsha256_di();
      CFDataRef v7 = sub_1002302F4(v11, a1, a3);
      BytePtr = CFDataGetBytePtr(v7);
      size_t Length = CFDataGetLength(v7);
      CFUUIDRef v14 = CFDataGetBytePtr(v9);
      size_t v15 = CFDataGetLength(v9);
      BOOL v16 = SecKeyRawVerify(a2, 0, BytePtr, Length, v14, v15) == 0;
      if (!v7) {
        return v16;
      }
    }
    else
    {
      BOOL v16 = 0;
    }
  }
  else
  {
    BOOL v16 = 0;
    if (!v6) {
      return v16;
    }
  }
  CFRelease(v7);
  return v16;
}

CFDataRef sub_1002302F4(CFIndex *a1, uint64_t a2, CFTypeRef *a3)
{
  __chkstk_darwin();
  CFDataRef v9 = (const UInt8 *)&v13 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (v6) {
    memset((char *)&v13 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0), 170, v6);
  }
  CFDataRef result = (CFDataRef)sub_10000FE8C(*(const __CFString **)(a2 + 24), a3, v6, v7, v8);
  if (result)
  {
    CFDataRef v11 = result;
    CFDataRef result = (CFDataRef)malloc_type_malloc((size_t)result, 0x88877CA1uLL);
    if (result)
    {
      CFDataRef v12 = result;
      if (sub_10000F7B0(*(const __CFString **)(a2 + 24), a3, 0, (UInt8 *)v12, (unint64_t)v11 + (void)v12))
      {
        ccdigest();
        free(v12);
        return CFDataCreate(0, v9, *a1);
      }
      else
      {
        free(v12);
        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_10023041C(uint64_t a1, __SecKey *a2, CFTypeRef *a3)
{
  if (a1) {
    BOOL v3 = a2 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  uint64_t v4 = !v3;
  if (!v3)
  {
    CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 24), @"Generation");
    uint64_t v8 = (const void *)SOSGenerationIncrementAndCreate();
    if (v8)
    {
      CFDataRef v9 = v8;
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 24), @"Generation", v8);
      CFRelease(v9);
    }
    CFTypeID v10 = sub_10000B070("Development");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)CFDataRef v12 = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "SOSRingEnsureRingConsistency requires ring membership and generation count consistency check", v12, 2u);
    }
    CFDictionaryRemoveAllValues(*(CFMutableDictionaryRef *)(a1 + 32));
    sub_100230504(a1, a2, a3);
  }
  return v4;
}

void sub_100230504(uint64_t a1, __SecKey *a2, CFTypeRef *a3)
{
  size_t v6 = (CFIndex *)ccsha256_di();
  CFDataRef v7 = sub_1002302F4(v6, a1, a3);
  CFDataRef v8 = sub_1002305D8(a2, v7);
  id PublicFromPrivate = (const void *)SecKeyCreatePublicFromPrivate();
  CFTypeID v10 = (const void *)SOSCopyIDOfKey();
  if (v10) {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), v10, v8);
  }
  if (PublicFromPrivate) {
    CFRelease(PublicFromPrivate);
  }
  if (v10) {
    CFRelease(v10);
  }
  CFRelease(v8);
  if (v7)
  {
    CFRelease(v7);
  }
}

CFDataRef sub_1002305D8(__SecKey *a1, const __CFData *a2)
{
  size_t sigLen = SecKeyGetSize() + 16;
  __chkstk_darwin();
  size_t v6 = (UInt8 *)&sigLen - v5;
  if (v4) {
    memset((char *)&sigLen - v5, 170, v4);
  }
  BytePtr = CFDataGetBytePtr(a2);
  size_t Length = CFDataGetLength(a2);
  if (SecKeyRawSign(a1, 0, BytePtr, Length, v6, &sigLen)) {
    return 0;
  }
  else {
    return CFDataCreate(0, v6, sigLen);
  }
}

void sub_100230A98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

intptr_t sub_100230AB0(uint64_t a1, char a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a2;
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_100230B78(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) account];
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100230C18;
  v3[3] = &unk_100309B50;
  id v4 = *(id *)(a1 + 40);
  [v2 SOSMonitorModeSOSIsActiveWithCallback:v3];
}

uint64_t sub_100230C18(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100230CB0(uint64_t a1)
{
  id v1 = [*(id *)(a1 + 32) account];
  [v1 SOSMonitorModeEnableSOS];
}

void sub_100230D7C(uint64_t a1)
{
  id v1 = [*(id *)(a1 + 32) account];
  [v1 SOSMonitorModeDisableSOS];
}

void sub_100231F34(id a1)
{
  uint64_t v2 = objc_opt_new();
  BOOL v3 = (void *)qword_10035D4A8;
  qword_10035D4A8 = v2;

  id v4 = [objc_alloc((Class)NSXPCListener) initWithMachServiceName:@"com.apple.securityd.sos"];
  uint64_t v5 = (void *)qword_10035D4A0;
  qword_10035D4A0 = (uint64_t)v4;

  [(id)qword_10035D4A0 setDelegate:qword_10035D4A8];
  [(id)qword_10035D4A0 resume];
}

void sub_1002320CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1002320E4(uint64_t a1, CFTypeRef cf, const void *a3)
{
  if (!cf || (v5 = cf, CFTypeID v6 = CFGetTypeID(cf), v6 != CFStringGetTypeID())) {
    CFTypeRef v5 = 0;
  }
  if (a3)
  {
    CFTypeID v7 = CFGetTypeID(a3);
    CFTypeID TypeID = CFDataGetTypeID();
    if (v5)
    {
      if (v7 == TypeID)
      {
        CFDataRef v9 = *(void **)(a1 + 32);
        id v24 = [v9 circleName];
        id v10 = v9;
        CFDataRef v11 = [v10 SOSTransportMessageGetAccount];
        sub_1001E4B34(v11);
        CFDataRef v12 = [v11 peerID];
        uint64_t v13 = (const void *)SOSMessageKeyCreateFromTransportToPeer();

        CFDictionaryRef v22 = sub_10022F290(v14, v15, v16, v17, v18, v19, v20, v21, (uint64_t)v13, (uint64_t)a3);
        id v23 = dispatch_get_global_queue(-2, 0);
        SOSCloudKeychainPutObjectsInCloud();

        if (v22) {
          CFRelease(v22);
        }
        if (v13) {
          CFRelease(v13);
        }
      }
    }
  }
}

uint64_t sub_100232264(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void sub_100232280(id a1, __CFDictionary *a2, __CFError *a3)
{
  if (a3)
  {
    id v4 = sub_10000B070("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 138412290;
      CFTypeID v6 = a3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Error putting: %@", (uint8_t *)&v5, 0xCu);
    }
  }
}

void sub_10023241C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100232434(void *a1, CFTypeRef cf)
{
  if (!cf || (v3 = cf, CFTypeID v4 = CFGetTypeID(cf), v4 != CFStringGetTypeID())) {
    CFTypeRef v3 = 0;
  }
  CFTypeRef cfa = 0;
  int v5 = (void *)a1[4];
  CFTypeID v6 = [v5 circleName];
  unsigned __int8 v7 = [v5 SOSTransportMessageSendMessageIfNeeded:v5 circleName:v6 pID:v3 err:&cfa];
  uint64_t v8 = *(void *)(a1[5] + 8);
  if (*(unsigned char *)(v8 + 24)) {
    unsigned __int8 v9 = v7;
  }
  else {
    unsigned __int8 v9 = 0;
  }
  *(unsigned char *)(v8 + ++*(void *)(*(void *)(*(void *)(result + 32) + 8) + 24) = v9;

  if (!*(unsigned char *)(*(void *)(a1[5] + 8) + 24))
  {
    CFDataRef v11 = (void *)a1[6];
    if (v11)
    {
      CFTypeRef v10 = cfa;
      if (*v11 || !cfa) {
        goto LABEL_9;
      }
      *(void *)a1[6] = CFRetain(cfa);
    }
  }
  CFTypeRef v10 = cfa;
LABEL_9:
  if (v10)
  {
    CFTypeRef cfa = 0;
    CFRelease(v10);
  }
}

uint64_t sub_10023251C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_100232688(uint64_t a1, CFTypeRef cf, const void *a3)
{
  if (!cf || (v6 = CFGetTypeID(cf), CFTypeRef v7 = cf, v6 != CFStringGetTypeID())) {
    CFTypeRef v7 = 0;
  }
  if (a3 && (CFTypeID v8 = CFGetTypeID(a3), v8 == CFDataGetTypeID()))
  {
    CFTypeRef cfa = 0;
    if (v7
      && [*(id *)(a1 + 32) SOSTransportMessageHandlePeerMessage:*(void *)(a1 + 32) id:v7 cm:a3 err:&cfa])
    {
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 40), cf);
      goto LABEL_13;
    }
  }
  else
  {
    CFTypeRef cfa = 0;
  }
  unsigned __int8 v9 = sub_10000B070("transport");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412546;
    CFTypeRef v13 = v7;
    __int16 v14 = 2112;
    CFTypeRef v15 = cfa;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%@ KVSTransport handle message failed: %@", buf, 0x16u);
  }

LABEL_13:
  CFTypeRef v10 = cfa;
  if (cfa)
  {
    CFTypeRef cfa = 0;
    CFRelease(v10);
  }
}

void sub_1002328D4(uint64_t a1, CFTypeRef cf, const void *a3)
{
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    CFTypeID TypeID = CFStringGetTypeID();
    if (a3)
    {
      if (v6 == TypeID)
      {
        CFTypeID v8 = CFGetTypeID(a3);
        if (v8 == CFArrayGetTypeID())
        {
          context[0] = _NSConcreteStackBlock;
          context[1] = 3221225472;
          context[2] = sub_1002329DC;
          context[3] = &unk_100309CA8;
          CFTypeRef v13 = cf;
          long long v10 = *(_OWORD *)(a1 + 32);
          id v9 = (id)v10;
          long long v12 = v10;
          v14.size_t length = CFArrayGetCount((CFArrayRef)a3);
          v14.id location = 0;
          CFArrayApplyFunction((CFArrayRef)a3, v14, (CFArrayApplierFunction)sub_10023251C, context);
        }
      }
    }
  }
}

void sub_1002329DC(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID())
    {
      CFArrayRef v5 = *(const __CFArray **)(a1 + 40);
      if (v5)
      {
        context[0] = _NSConcreteStackBlock;
        context[1] = 3221225472;
        context[2] = sub_100232AC4;
        context[3] = &unk_100309CA8;
        uint64_t v8 = *(void *)(a1 + 48);
        CFTypeRef v9 = cf;
        id v7 = *(id *)(a1 + 32);
        v10.size_t length = CFArrayGetCount(v5);
        v10.id location = 0;
        CFArrayApplyFunction(v5, v10, (CFArrayApplierFunction)sub_10023251C, context);
      }
    }
  }
}

void sub_100232AC4(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v3 = CFGetTypeID(cf);
    if (v3 == CFStringGetTypeID())
    {
      CFTypeID v4 = (const void *)SOSMessageKeyCreateWithCircleNameAndPeerNames();
      sub_100232B78(*(void **)(a1 + 32), v4);
      if (v4) {
        CFRelease(v4);
      }
      CFArrayRef v5 = (const void *)SOSMessageKeyCreateWithCircleNameAndPeerNames();
      sub_100232B78(*(void **)(a1 + 32), v5);
      if (v5)
      {
        CFRelease(v5);
      }
    }
  }
}

void sub_100232B78(void *a1, const void *a2)
{
  id v3 = a1;
  if (!objc_msgSend(v3, "pending_changes")) {
    [v3 setPending_changes:CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks)];
  }
  [objc_msgSend(v3, "pending_changes") setValue:kCFNull forKey:a2];
}

void sub_100232DF0(uint64_t a1)
{
  SOSPeerInfoGetPeerID();
  uint64_t v2 = (const void *)SOSMessageKeyCreateFromPeerToTransport();
  if (v2)
  {
    id v3 = v2;
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 48), v2);
    CFRelease(v3);
  }
}

void sub_100233924(uint64_t a1, const void *a2)
{
}

uint64_t sub_10023392C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_100234248(uint64_t a1)
{
  [*(id *)(a1 + 32) fullPeerInfo];
  SOSFullPeerInfoGetPeerInfo();

  return SOSCircleUpdatePeerInfo();
}

uint64_t sub_100234668(uint64_t a1)
{
  uint64_t v2 = sub_10000B070("circleChange");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CFTypeID v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Calling SOSCircleUpdatePeerInfo for gestalt change", v4, 2u);
  }

  [*(id *)(a1 + 32) peerInfo];
  return SOSCircleUpdatePeerInfo();
}

CCCryptorStatus CCCrypt(CCOperation op, CCAlgorithm alg, CCOptions options, const void *key, size_t keyLength, const void *iv, const void *dataIn, size_t dataInLength, void *dataOut, size_t dataOutAvailable, size_t *dataOutMoved)
{
  return _CCCrypt(op, alg, options, key, keyLength, iv, dataIn, dataInLength, dataOut, dataOutAvailable, dataOutMoved);
}

uint64_t CCCryptorGCM()
{
  return _CCCryptorGCM();
}

uint64_t CCDigest()
{
  return _CCDigest();
}

CCRNGStatus CCRandomGenerateBytes(void *bytes, size_t count)
{
  return _CCRandomGenerateBytes(bytes, count);
}

unsigned __int8 *__cdecl CC_SHA256(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return _CC_SHA256(data, len, md);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  return _CFAbsoluteTimeGetCurrent();
}

void CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange)
{
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

void CFArrayApplyFunction(CFArrayRef theArray, CFRange range, CFArrayApplierFunction applier, void *context)
{
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return _CFArrayContainsValue(theArray, range, value);
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return _CFArrayCreate(allocator, values, numValues, callBacks);
}

CFArrayRef CFArrayCreateCopy(CFAllocatorRef allocator, CFArrayRef theArray)
{
  return _CFArrayCreateCopy(allocator, theArray);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return _CFArrayCreateMutable(allocator, capacity, callBacks);
}

CFMutableArrayRef CFArrayCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFArrayRef theArray)
{
  return _CFArrayCreateMutableCopy(allocator, capacity, theArray);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return _CFArrayGetCount(theArray);
}

CFIndex CFArrayGetCountOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return _CFArrayGetCountOfValue(theArray, range, value);
}

CFIndex CFArrayGetFirstIndexOfValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return _CFArrayGetFirstIndexOfValue(theArray, range, value);
}

CFTypeID CFArrayGetTypeID(void)
{
  return _CFArrayGetTypeID();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return _CFArrayGetValueAtIndex(theArray, idx);
}

void CFArrayGetValues(CFArrayRef theArray, CFRange range, const void **values)
{
}

void CFArrayInsertValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
}

uint64_t CFArrayOfSOSPeerInfosSortByID()
{
  return _CFArrayOfSOSPeerInfosSortByID();
}

void CFArrayRemoveAllValues(CFMutableArrayRef theArray)
{
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
}

void CFArraySetValueAtIndex(CFMutableArrayRef theArray, CFIndex idx, const void *value)
{
}

void CFArraySortValues(CFMutableArrayRef theArray, CFRange range, CFComparatorFunction comparator, void *context)
{
}

CFTypeID CFBooleanGetTypeID(void)
{
  return _CFBooleanGetTypeID();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return _CFBooleanGetValue(BOOLean);
}

CFBundleRef CFBundleCreate(CFAllocatorRef allocator, CFURLRef bundleURL)
{
  return _CFBundleCreate(allocator, bundleURL);
}

void *__cdecl CFBundleGetFunctionPointerForName(CFBundleRef bundle, CFStringRef functionName)
{
  return _CFBundleGetFunctionPointerForName(bundle, functionName);
}

Boolean CFCalendarComposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime *at, const char *componentDesc, ...)
{
  return _CFCalendarComposeAbsoluteTime(calendar, at, componentDesc);
}

CFCalendarRef CFCalendarCreateWithIdentifier(CFAllocatorRef allocator, CFCalendarIdentifier identifier)
{
  return _CFCalendarCreateWithIdentifier(allocator, identifier);
}

Boolean CFCalendarDecomposeAbsoluteTime(CFCalendarRef calendar, CFAbsoluteTime at, const char *componentDesc, ...)
{
  va_start(va, componentDesc);
  id v3 = va_arg(va, const char *);
  return _CFCalendarDecomposeAbsoluteTime(calendar, at, v3);
}

void CFCalendarSetTimeZone(CFCalendarRef calendar, CFTimeZoneRef tz)
{
}

CFCharacterSetRef CFCharacterSetCreateWithCharactersInRange(CFAllocatorRef alloc, CFRange theRange)
{
  return _CFCharacterSetCreateWithCharactersInRange(alloc, theRange);
}

Boolean CFCharacterSetIsCharacterMember(CFCharacterSetRef theSet, UniChar theChar)
{
  return _CFCharacterSetIsCharacterMember(theSet, theChar);
}

CFStringRef CFCopyDescription(CFTypeRef cf)
{
  return _CFCopyDescription(cf);
}

CFURLRef CFCopyHomeDirectoryURL(void)
{
  return _CFCopyHomeDirectoryURL();
}

CFStringRef CFCopyTypeIDDescription(CFTypeID type_id)
{
  return _CFCopyTypeIDDescription(type_id);
}

void CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length)
{
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return _CFDataCreate(allocator, bytes, length);
}

CFDataRef CFDataCreateCopy(CFAllocatorRef allocator, CFDataRef theData)
{
  return _CFDataCreateCopy(allocator, theData);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return _CFDataCreateMutable(allocator, capacity);
}

CFMutableDataRef CFDataCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDataRef theData)
{
  return _CFDataCreateMutableCopy(allocator, capacity, theData);
}

CFDataRef CFDataCreateWithBytesNoCopy(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length, CFAllocatorRef bytesDeallocator)
{
  return _CFDataCreateWithBytesNoCopy(allocator, bytes, length, bytesDeallocator);
}

uint64_t CFDataCreateWithDER()
{
  return _CFDataCreateWithDER();
}

void CFDataDeleteBytes(CFMutableDataRef theData, CFRange range)
{
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return _CFDataGetBytePtr(theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return _CFDataGetLength(theData);
}

UInt8 *__cdecl CFDataGetMutableBytePtr(CFMutableDataRef theData)
{
  return _CFDataGetMutableBytePtr(theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return _CFDataGetTypeID();
}

void CFDataSetLength(CFMutableDataRef theData, CFIndex length)
{
}

CFComparisonResult CFDateCompare(CFDateRef theDate, CFDateRef otherDate, void *context)
{
  return _CFDateCompare(theDate, otherDate, context);
}

CFDateRef CFDateCreate(CFAllocatorRef allocator, CFAbsoluteTime at)
{
  return _CFDateCreate(allocator, at);
}

CFDateFormatterRef CFDateFormatterCreate(CFAllocatorRef allocator, CFLocaleRef locale, CFDateFormatterStyle dateStyle, CFDateFormatterStyle timeStyle)
{
  return _CFDateFormatterCreate(allocator, locale, dateStyle, timeStyle);
}

CFStringRef CFDateFormatterCreateStringWithAbsoluteTime(CFAllocatorRef allocator, CFDateFormatterRef formatter, CFAbsoluteTime at)
{
  return _CFDateFormatterCreateStringWithAbsoluteTime(allocator, formatter, at);
}

void CFDateFormatterSetFormat(CFDateFormatterRef formatter, CFStringRef formatString)
{
}

CFAbsoluteTime CFDateGetAbsoluteTime(CFDateRef theDate)
{
  return _CFDateGetAbsoluteTime(theDate);
}

CFTypeID CFDateGetTypeID(void)
{
  return _CFDateGetTypeID();
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

void CFDictionaryApplyFunction(CFDictionaryRef theDict, CFDictionaryApplierFunction applier, void *context)
{
}

Boolean CFDictionaryContainsKey(CFDictionaryRef theDict, const void *key)
{
  return _CFDictionaryContainsKey(theDict, key);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return _CFDictionaryCreate(allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFDictionaryRef CFDictionaryCreateCopy(CFAllocatorRef allocator, CFDictionaryRef theDict)
{
  return _CFDictionaryCreateCopy(allocator, theDict);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return _CFDictionaryCreateMutable(allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return _CFDictionaryCreateMutableCopy(allocator, capacity, theDict);
}

CFIndex CFDictionaryGetCount(CFDictionaryRef theDict)
{
  return _CFDictionaryGetCount(theDict);
}

CFIndex CFDictionaryGetCountOfKey(CFDictionaryRef theDict, const void *key)
{
  return _CFDictionaryGetCountOfKey(theDict, key);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return _CFDictionaryGetTypeID();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return _CFDictionaryGetValue(theDict, key);
}

Boolean CFDictionaryGetValueIfPresent(CFDictionaryRef theDict, const void *key, const void **value)
{
  return _CFDictionaryGetValueIfPresent(theDict, key, value);
}

void CFDictionaryRemoveAllValues(CFMutableDictionaryRef theDict)
{
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
}

void CFDictionaryReplaceValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

Boolean CFEqual(CFTypeRef cf1, CFTypeRef cf2)
{
  return _CFEqual(cf1, cf2);
}

CFStringRef CFErrorCopyDescription(CFErrorRef err)
{
  return _CFErrorCopyDescription(err);
}

CFDictionaryRef CFErrorCopyUserInfo(CFErrorRef err)
{
  return _CFErrorCopyUserInfo(err);
}

CFErrorRef CFErrorCreate(CFAllocatorRef allocator, CFErrorDomain domain, CFIndex code, CFDictionaryRef userInfo)
{
  return _CFErrorCreate(allocator, domain, code, userInfo);
}

CFIndex CFErrorGetCode(CFErrorRef err)
{
  return _CFErrorGetCode(err);
}

CFErrorDomain CFErrorGetDomain(CFErrorRef err)
{
  return _CFErrorGetDomain(err);
}

CFAllocatorRef CFGetAllocator(CFTypeRef cf)
{
  return _CFGetAllocator(cf);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return _CFGetTypeID(cf);
}

CFLocaleRef CFLocaleCopyCurrent(void)
{
  return _CFLocaleCopyCurrent();
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  return _CFNotificationCenterGetDarwinNotifyCenter();
}

CFNotificationCenterRef CFNotificationCenterGetDistributedCenter(void)
{
  return _CFNotificationCenterGetDistributedCenter();
}

void CFNotificationCenterPostNotificationWithOptions(CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, CFOptionFlags options)
{
}

CFTypeID CFNullGetTypeID(void)
{
  return _CFNullGetTypeID();
}

CFComparisonResult CFNumberCompare(CFNumberRef number, CFNumberRef otherNumber, void *context)
{
  return _CFNumberCompare(number, otherNumber, context);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return _CFNumberCreate(allocator, theType, valuePtr);
}

CFTypeID CFNumberGetTypeID(void)
{
  return _CFNumberGetTypeID();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return _CFNumberGetValue(number, theType, valuePtr);
}

Boolean CFNumberIsFloatType(CFNumberRef number)
{
  return _CFNumberIsFloatType(number);
}

CFPropertyListRef CFPreferencesCopyValue(CFStringRef key, CFStringRef applicationID, CFStringRef userName, CFStringRef hostName)
{
  return _CFPreferencesCopyValue(key, applicationID, userName, hostName);
}

CFDataRef CFPropertyListCreateData(CFAllocatorRef allocator, CFPropertyListRef propertyList, CFPropertyListFormat format, CFOptionFlags options, CFErrorRef *error)
{
  return _CFPropertyListCreateData(allocator, propertyList, format, options, error);
}

CFPropertyListRef CFPropertyListCreateWithData(CFAllocatorRef allocator, CFDataRef data, CFOptionFlags options, CFPropertyListFormat *format, CFErrorRef *error)
{
  return _CFPropertyListCreateWithData(allocator, data, options, format, error);
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return _CFRetain(cf);
}

void CFRunLoopRun(void)
{
}

void CFSetAddValue(CFMutableSetRef theSet, const void *value)
{
}

void CFSetApplyFunction(CFSetRef theSet, CFSetApplierFunction applier, void *context)
{
}

Boolean CFSetContainsValue(CFSetRef theSet, const void *value)
{
  return _CFSetContainsValue(theSet, value);
}

CFSetRef CFSetCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFSetCallBacks *callBacks)
{
  return _CFSetCreate(allocator, values, numValues, callBacks);
}

CFSetRef CFSetCreateCopy(CFAllocatorRef allocator, CFSetRef theSet)
{
  return _CFSetCreateCopy(allocator, theSet);
}

CFMutableSetRef CFSetCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFSetCallBacks *callBacks)
{
  return _CFSetCreateMutable(allocator, capacity, callBacks);
}

CFMutableSetRef CFSetCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFSetRef theSet)
{
  return _CFSetCreateMutableCopy(allocator, capacity, theSet);
}

uint64_t CFSetCreateMutableForSOSPeerInfosByID()
{
  return _CFSetCreateMutableForSOSPeerInfosByID();
}

uint64_t CFSetCreateMutableForSOSPeerInfosByIDWithArray()
{
  return _CFSetCreateMutableForSOSPeerInfosByIDWithArray();
}

CFIndex CFSetGetCount(CFSetRef theSet)
{
  return _CFSetGetCount(theSet);
}

CFTypeID CFSetGetTypeID(void)
{
  return _CFSetGetTypeID();
}

const void *__cdecl CFSetGetValue(CFSetRef theSet, const void *value)
{
  return _CFSetGetValue(theSet, value);
}

void CFSetGetValues(CFSetRef theSet, const void **values)
{
}

void CFSetRemoveAllValues(CFMutableSetRef theSet)
{
}

void CFSetRemoveValue(CFMutableSetRef theSet, const void *value)
{
}

void CFSetSetValue(CFMutableSetRef theSet, const void *value)
{
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
}

void CFStringAppendCString(CFMutableStringRef theString, const char *cStr, CFStringEncoding encoding)
{
}

void CFStringAppendFormat(CFMutableStringRef theString, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return _CFStringCompare(theString1, theString2, compareOptions);
}

CFArrayRef CFStringCreateArrayBySeparatingStrings(CFAllocatorRef alloc, CFStringRef theString, CFStringRef separatorString)
{
  return _CFStringCreateArrayBySeparatingStrings(alloc, theString, separatorString);
}

CFStringRef CFStringCreateByCombiningStrings(CFAllocatorRef alloc, CFArrayRef theArray, CFStringRef separatorString)
{
  return _CFStringCreateByCombiningStrings(alloc, theArray, separatorString);
}

CFStringRef CFStringCreateCopy(CFAllocatorRef alloc, CFStringRef theString)
{
  return _CFStringCreateCopy(alloc, theString);
}

CFDataRef CFStringCreateExternalRepresentation(CFAllocatorRef alloc, CFStringRef theString, CFStringEncoding encoding, UInt8 lossByte)
{
  return _CFStringCreateExternalRepresentation(alloc, theString, encoding, lossByte);
}

CFStringRef CFStringCreateFromExternalRepresentation(CFAllocatorRef alloc, CFDataRef data, CFStringEncoding encoding)
{
  return _CFStringCreateFromExternalRepresentation(alloc, data, encoding);
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return _CFStringCreateMutable(alloc, maxLength);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return _CFStringCreateMutableCopy(alloc, maxLength, theString);
}

CFStringRef CFStringCreateWithBytes(CFAllocatorRef alloc, const UInt8 *bytes, CFIndex numBytes, CFStringEncoding encoding, Boolean isExternalRepresentation)
{
  return _CFStringCreateWithBytes(alloc, bytes, numBytes, encoding, isExternalRepresentation);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return _CFStringCreateWithCString(alloc, cStr, encoding);
}

CFStringRef CFStringCreateWithFormat(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, ...)
{
  return _CFStringCreateWithFormat(alloc, formatOptions, format);
}

CFStringRef CFStringCreateWithFormatAndArguments(CFAllocatorRef alloc, CFDictionaryRef formatOptions, CFStringRef format, va_list arguments)
{
  return _CFStringCreateWithFormatAndArguments(alloc, formatOptions, format, arguments);
}

CFStringRef CFStringCreateWithSubstring(CFAllocatorRef alloc, CFStringRef str, CFRange range)
{
  return _CFStringCreateWithSubstring(alloc, str, range);
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  return _CFStringGetBytes(theString, range, encoding, lossByte, isExternalRepresentation, buffer, maxBufLen, usedBufLen);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return _CFStringGetCString(theString, buffer, bufferSize, encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return _CFStringGetCStringPtr(theString, encoding);
}

UniChar CFStringGetCharacterAtIndex(CFStringRef theString, CFIndex idx)
{
  return _CFStringGetCharacterAtIndex(theString, idx);
}

void CFStringGetCharacters(CFStringRef theString, CFRange range, UniChar *buffer)
{
}

const UniChar *__cdecl CFStringGetCharactersPtr(CFStringRef theString)
{
  return _CFStringGetCharactersPtr(theString);
}

SInt32 CFStringGetIntValue(CFStringRef str)
{
  return _CFStringGetIntValue(str);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return _CFStringGetLength(theString);
}

CFIndex CFStringGetMaximumSizeForEncoding(CFIndex length, CFStringEncoding encoding)
{
  return _CFStringGetMaximumSizeForEncoding(length, encoding);
}

CFTypeID CFStringGetTypeID(void)
{
  return _CFStringGetTypeID();
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return _CFStringHasPrefix(theString, prefix);
}

Boolean CFStringHasSuffix(CFStringRef theString, CFStringRef suffix)
{
  return _CFStringHasSuffix(theString, suffix);
}

void CFStringTrimWhitespace(CFMutableStringRef theString)
{
}

CFTimeZoneRef CFTimeZoneCreateWithTimeIntervalFromGMT(CFAllocatorRef allocator, CFTimeInterval ti)
{
  return _CFTimeZoneCreateWithTimeIntervalFromGMT(allocator, ti);
}

CFStringRef CFURLCopyFileSystemPath(CFURLRef anURL, CFURLPathStyle pathStyle)
{
  return _CFURLCopyFileSystemPath(anURL, pathStyle);
}

CFURLRef CFURLCreateCopyAppendingPathComponent(CFAllocatorRef allocator, CFURLRef url, CFStringRef pathComponent, Boolean isDirectory)
{
  return _CFURLCreateCopyAppendingPathComponent(allocator, url, pathComponent, isDirectory);
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return _CFURLCreateWithFileSystemPath(allocator, filePath, pathStyle, isDirectory);
}

Boolean CFURLGetFileSystemRepresentation(CFURLRef url, Boolean resolveAgainstBase, UInt8 *buffer, CFIndex maxBufLen)
{
  return _CFURLGetFileSystemRepresentation(url, resolveAgainstBase, buffer, maxBufLen);
}

CFUUIDRef CFUUIDCreate(CFAllocatorRef alloc)
{
  return _CFUUIDCreate(alloc);
}

CFStringRef CFUUIDCreateString(CFAllocatorRef alloc, CFUUIDRef uuid)
{
  return _CFUUIDCreateString(alloc, uuid);
}

CFUUIDRef CFUUIDCreateWithBytes(CFAllocatorRef alloc, UInt8 byte0, UInt8 byte1, UInt8 byte2, UInt8 byte3, UInt8 byte4, UInt8 byte5, UInt8 byte6, UInt8 byte7, UInt8 byte8, UInt8 byte9, UInt8 byte10, UInt8 byte11, UInt8 byte12, UInt8 byte13, UInt8 byte14, UInt8 byte15)
{
  return _CFUUIDCreateWithBytes(alloc, byte0, byte1, byte2, byte3, byte4, byte5, byte6, byte7, byte8, byte9, byte10, byte11, byte12, byte13, byte14, byte15);
}

CFTypeID CFUUIDGetTypeID(void)
{
  return _CFUUIDGetTypeID();
}

CFUUIDBytes CFUUIDGetUUIDBytes(CFUUIDRef uuid)
{
  CFUUIDBytes v3 = _CFUUIDGetUUIDBytes(uuid);
  uint64_t v2 = *(void *)&v3.byte8;
  uint64_t v1 = *(void *)&v3.byte0;
  result.byte8 = v2;
  result.byte9 = BYTE1(v2);
  result.byte10 = BYTE2(v2);
  result.byte11 = BYTE3(v2);
  result.byte12 = BYTE4(v2);
  result.byte13 = BYTE5(v2);
  result.byte14 = BYTE6(v2);
  result.byte15 = HIBYTE(v2);
  result.byte0 = v1;
  result.byte1 = BYTE1(v1);
  result.byte2 = BYTE2(v1);
  result.byte3 = BYTE3(v1);
  result.byte4 = BYTE4(v1);
  result.byte5 = BYTE5(v1);
  result.byte6 = BYTE6(v1);
  result.byte7 = HIBYTE(v1);
  return result;
}

CFUserNotificationRef CFUserNotificationCreate(CFAllocatorRef allocator, CFTimeInterval timeout, CFOptionFlags flags, SInt32 *error, CFDictionaryRef dictionary)
{
  return _CFUserNotificationCreate(allocator, timeout, flags, error, dictionary);
}

SInt32 CFUserNotificationReceiveResponse(CFUserNotificationRef userNotification, CFTimeInterval timeout, CFOptionFlags *responseFlags)
{
  return _CFUserNotificationReceiveResponse(userNotification, timeout, responseFlags);
}

uint64_t CKAcceptableValueClasses()
{
  return _CKAcceptableValueClasses();
}

uint64_t CKDatabaseScopeString()
{
  return _CKDatabaseScopeString();
}

uint64_t CKErrorIsCode()
{
  return _CKErrorIsCode();
}

uint64_t CKKSSetupControlProtocol()
{
  return _CKKSSetupControlProtocol();
}

uint64_t CKRetryAfterSecondsForError()
{
  return _CKRetryAfterSecondsForError();
}

uint64_t CKXPCSuitableError()
{
  return _CKXPCSuitableError();
}

uint64_t CNCRC()
{
  return _CNCRC();
}

uint64_t CreateArrayOfPeerInfoWithXPCObject()
{
  return _CreateArrayOfPeerInfoWithXPCObject();
}

uint64_t CreateXPCObjectWithArrayOfPeerInfo()
{
  return _CreateXPCObjectWithArrayOfPeerInfo();
}

kern_return_t IOConnectCallMethod(mach_port_t connection, uint32_t selector, const uint64_t *input, uint32_t inputCnt, const void *inputStruct, size_t inputStructCnt, uint64_t *output, uint32_t *outputCnt, void *outputStruct, size_t *outputStructCnt)
{
  return _IOConnectCallMethod(connection, selector, input, inputCnt, inputStruct, inputStructCnt, output, outputCnt, outputStruct, outputStructCnt);
}

kern_return_t IOConnectCallScalarMethod(mach_port_t connection, uint32_t selector, const uint64_t *input, uint32_t inputCnt, uint64_t *output, uint32_t *outputCnt)
{
  return _IOConnectCallScalarMethod(connection, selector, input, inputCnt, output, outputCnt);
}

kern_return_t IOConnectCallStructMethod(mach_port_t connection, uint32_t selector, const void *inputStruct, size_t inputStructCnt, void *outputStruct, size_t *outputStructCnt)
{
  return _IOConnectCallStructMethod(connection, selector, inputStruct, inputStructCnt, outputStruct, outputStructCnt);
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return _IOObjectRelease(object);
}

CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return _IORegistryEntryCreateCFProperty(entry, key, allocator, options);
}

io_registry_entry_t IORegistryEntryFromPath(mach_port_t mainPort, const io_string_t path)
{
  return _IORegistryEntryFromPath(mainPort, path);
}

kern_return_t IOServiceClose(io_connect_t connect)
{
  return _IOServiceClose(connect);
}

io_service_t IOServiceGetMatchingService(mach_port_t mainPort, CFDictionaryRef matching)
{
  return _IOServiceGetMatchingService(mainPort, matching);
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return _IOServiceMatching(name);
}

kern_return_t IOServiceOpen(io_service_t service, task_port_t owningTask, uint32_t type, io_connect_t *connect)
{
  return _IOServiceOpen(service, owningTask, type, connect);
}

uint64_t KCSharingLogObject()
{
  return _KCSharingLogObject();
}

uint64_t KCSharingSetupInvitationNotificationProtocol()
{
  return _KCSharingSetupInvitationNotificationProtocol();
}

uint64_t KCSharingSetupServerProtocol()
{
  return _KCSharingSetupServerProtocol();
}

uint64_t LKABackupReportEnd()
{
  return _LKABackupReportEnd();
}

uint64_t LKABackupReportStart()
{
  return _LKABackupReportStart();
}

uint64_t LKAReportKeychainUpgradeOutcomeWithError()
{
  return _LKAReportKeychainUpgradeOutcomeWithError();
}

uint64_t MGCopyAnswer()
{
  return _MGCopyAnswer();
}

uint64_t MGCopyAnswerWithError()
{
  return _MGCopyAnswerWithError();
}

uint64_t MKBForegroundUserSessionID()
{
  return _MKBForegroundUserSessionID();
}

uint64_t MKBGetDeviceLockState()
{
  return _MKBGetDeviceLockState();
}

uint64_t MKBKeyBagCreateWithData()
{
  return _MKBKeyBagCreateWithData();
}

uint64_t MKBKeyBagGetAKSHandle()
{
  return _MKBKeyBagGetAKSHandle();
}

uint64_t MKBKeyBagUnlock()
{
  return _MKBKeyBagUnlock();
}

uint64_t MKBUserTypeDeviceMode()
{
  return _MKBUserTypeDeviceMode();
}

Class NSClassFromString(NSString *aClassName)
{
  return _NSClassFromString(aClassName);
}

void NSLog(NSString *format, ...)
{
}

SEL NSSelectorFromString(NSString *aSelectorName)
{
  return _NSSelectorFromString(aSelectorName);
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return _NSStringFromClass(aClass);
}

NSString *__cdecl NSStringFromProtocol(Protocol *proto)
{
  return _NSStringFromProtocol(proto);
}

NSString *__cdecl NSStringFromSelector(SEL aSelector)
{
  return _NSStringFromSelector(aSelector);
}

uint64_t OTCDPStatusToString()
{
  return _OTCDPStatusToString();
}

uint64_t OTCliqueStatusFromString()
{
  return _OTCliqueStatusFromString();
}

uint64_t OTCliqueStatusToString()
{
  return _OTCliqueStatusToString();
}

uint64_t PBDataWriterWriteBOOLField()
{
  return _PBDataWriterWriteBOOLField();
}

uint64_t PBDataWriterWriteDataField()
{
  return _PBDataWriterWriteDataField();
}

uint64_t PBDataWriterWriteDoubleField()
{
  return _PBDataWriterWriteDoubleField();
}

uint64_t PBDataWriterWriteInt32Field()
{
  return _PBDataWriterWriteInt32Field();
}

uint64_t PBDataWriterWriteInt64Field()
{
  return _PBDataWriterWriteInt64Field();
}

uint64_t PBDataWriterWriteStringField()
{
  return _PBDataWriterWriteStringField();
}

uint64_t PBDataWriterWriteSubmessage()
{
  return _PBDataWriterWriteSubmessage();
}

uint64_t PBDataWriterWriteUint32Field()
{
  return _PBDataWriterWriteUint32Field();
}

uint64_t PBDataWriterWriteUint64Field()
{
  return _PBDataWriterWriteUint64Field();
}

uint64_t PBReaderPlaceMark()
{
  return _PBReaderPlaceMark();
}

uint64_t PBReaderReadData()
{
  return _PBReaderReadData();
}

uint64_t PBReaderReadString()
{
  return _PBReaderReadString();
}

uint64_t PBReaderRecallMark()
{
  return _PBReaderRecallMark();
}

uint64_t PBReaderSkipValueWithTag()
{
  return _PBReaderSkipValueWithTag();
}

uint64_t PBUnknownFieldAdd()
{
  return _PBUnknownFieldAdd();
}

CFStringRef SCDynamicStoreCopyComputerName(SCDynamicStoreRef store, CFStringEncoding *nameEncoding)
{
  return _SCDynamicStoreCopyComputerName(store, nameEncoding);
}

SCDynamicStoreRef SCDynamicStoreCreate(CFAllocatorRef allocator, CFStringRef name, SCDynamicStoreCallBack callout, SCDynamicStoreContext *context)
{
  return _SCDynamicStoreCreate(allocator, name, callout, context);
}

CFStringRef SCDynamicStoreKeyCreateComputerName(CFAllocatorRef allocator)
{
  return _SCDynamicStoreKeyCreateComputerName(allocator);
}

Boolean SCDynamicStoreSetDispatchQueue(SCDynamicStoreRef store, dispatch_queue_t queue)
{
  return _SCDynamicStoreSetDispatchQueue(store, queue);
}

Boolean SCDynamicStoreSetNotificationKeys(SCDynamicStoreRef store, CFArrayRef keys, CFArrayRef patterns)
{
  return _SCDynamicStoreSetNotificationKeys(store, keys, patterns);
}

uint64_t SOSBKSBPeerBackupKeyIsInKeyBag()
{
  return _SOSBKSBPeerBackupKeyIsInKeyBag();
}

uint64_t SOSBKSBPrefixedKeyIsInKeyBag()
{
  return _SOSBKSBPrefixedKeyIsInKeyBag();
}

uint64_t SOSBSKBAllPeersBackupKeysAreInKeyBag()
{
  return _SOSBSKBAllPeersBackupKeysAreInKeyBag();
}

uint64_t SOSBSKBCopyAKSBag()
{
  return _SOSBSKBCopyAKSBag();
}

uint64_t SOSBSKBCopyEncoded()
{
  return _SOSBSKBCopyEncoded();
}

uint64_t SOSBSKBHasThisRecoveryKey()
{
  return _SOSBSKBHasThisRecoveryKey();
}

uint64_t SOSBSKBIsDirect()
{
  return _SOSBSKBIsDirect();
}

uint64_t SOSBSKBIsGoodBackupPublic()
{
  return _SOSBSKBIsGoodBackupPublic();
}

uint64_t SOSBSKBLoadAndUnlockWithDirectSecret()
{
  return _SOSBSKBLoadAndUnlockWithDirectSecret();
}

uint64_t SOSBSKBLoadAndUnlockWithPeerIDAndSecret()
{
  return _SOSBSKBLoadAndUnlockWithPeerIDAndSecret();
}

uint64_t SOSBSKBLoadAndUnlockWithWrappingSecret()
{
  return _SOSBSKBLoadAndUnlockWithWrappingSecret();
}

uint64_t SOSBackupSliceKeyBagCreate()
{
  return _SOSBackupSliceKeyBagCreate();
}

uint64_t SOSBackupSliceKeyBagCreateDirect()
{
  return _SOSBackupSliceKeyBagCreateDirect();
}

uint64_t SOSBackupSliceKeyBagCreateFromData()
{
  return _SOSBackupSliceKeyBagCreateFromData();
}

uint64_t SOSBackupSliceKeyBagCreateWithAdditionalKeys()
{
  return _SOSBackupSliceKeyBagCreateWithAdditionalKeys();
}

uint64_t SOSCCCopyRecoveryPublicKey()
{
  return _SOSCCCopyRecoveryPublicKey();
}

uint64_t SOSCCCredentialQueue()
{
  return _SOSCCCredentialQueue();
}

uint64_t SOSCCForEachEngineStateAsStringFromArray()
{
  return _SOSCCForEachEngineStateAsStringFromArray();
}

uint64_t SOSCCGetStatusDescription()
{
  return _SOSCCGetStatusDescription();
}

uint64_t SOSCCRequestToJoinCircleAfterRestore()
{
  return _SOSCCRequestToJoinCircleAfterRestore();
}

uint64_t SOSCCResetToOffering()
{
  return _SOSCCResetToOffering();
}

uint64_t SOSCCSetSOSDisabledError()
{
  return _SOSCCSetSOSDisabledError();
}

uint64_t SOSCCThisDeviceIsInCircle()
{
  return _SOSCCThisDeviceIsInCircle();
}

uint64_t SOSCCView()
{
  return _SOSCCView();
}

uint64_t SOSCachedNotificationOperation()
{
  return _SOSCachedNotificationOperation();
}

uint64_t SOSCircleAcceptRequest()
{
  return _SOSCircleAcceptRequest();
}

uint64_t SOSCircleConcordanceSign()
{
  return _SOSCircleConcordanceSign();
}

uint64_t SOSCircleConcordanceTrust()
{
  return _SOSCircleConcordanceTrust();
}

uint64_t SOSCircleCopyAllSignatures()
{
  return _SOSCircleCopyAllSignatures();
}

uint64_t SOSCircleCopyApplicants()
{
  return _SOSCircleCopyApplicants();
}

uint64_t SOSCircleCopyCircle()
{
  return _SOSCircleCopyCircle();
}

uint64_t SOSCircleCopyEncodedData()
{
  return _SOSCircleCopyEncodedData();
}

uint64_t SOSCircleCopyHashString()
{
  return _SOSCircleCopyHashString();
}

uint64_t SOSCircleCopyNextGenSignatureWithPeerAdded()
{
  return _SOSCircleCopyNextGenSignatureWithPeerAdded();
}

uint64_t SOSCircleCopyPeerWithID()
{
  return _SOSCircleCopyPeerWithID();
}

uint64_t SOSCircleCopyPeers()
{
  return _SOSCircleCopyPeers();
}

uint64_t SOSCircleCopyRejectedApplicant()
{
  return _SOSCircleCopyRejectedApplicant();
}

uint64_t SOSCircleCopyStateString()
{
  return _SOSCircleCopyStateString();
}

uint64_t SOSCircleCopyiCloudFullPeerInfoRef()
{
  return _SOSCircleCopyiCloudFullPeerInfoRef();
}

uint64_t SOSCircleCountPeers()
{
  return _SOSCircleCountPeers();
}

uint64_t SOSCircleCreate()
{
  return _SOSCircleCreate();
}

uint64_t SOSCircleCreateFromDER()
{
  return _SOSCircleCreateFromDER();
}

uint64_t SOSCircleCreateFromData()
{
  return _SOSCircleCreateFromData();
}

uint64_t SOSCircleEncodeToDER()
{
  return _SOSCircleEncodeToDER();
}

uint64_t SOSCircleForEachActivePeer()
{
  return _SOSCircleForEachActivePeer();
}

uint64_t SOSCircleForEachActiveValidPeer()
{
  return _SOSCircleForEachActiveValidPeer();
}

uint64_t SOSCircleForEachApplicant()
{
  return _SOSCircleForEachApplicant();
}

uint64_t SOSCircleForEachBackupCapablePeerForView()
{
  return _SOSCircleForEachBackupCapablePeerForView();
}

uint64_t SOSCircleForEachPeer()
{
  return _SOSCircleForEachPeer();
}

uint64_t SOSCircleForEachRejectedApplicant()
{
  return _SOSCircleForEachRejectedApplicant();
}

uint64_t SOSCircleForEachRetiredPeer()
{
  return _SOSCircleForEachRetiredPeer();
}

uint64_t SOSCircleForEachValidPeer()
{
  return _SOSCircleForEachValidPeer();
}

uint64_t SOSCircleForEachValidSyncingPeer()
{
  return _SOSCircleForEachValidSyncingPeer();
}

uint64_t SOSCircleForEachiCloudIdentityPeer()
{
  return _SOSCircleForEachiCloudIdentityPeer();
}

uint64_t SOSCircleGenerationSign()
{
  return _SOSCircleGenerationSign();
}

uint64_t SOSCircleGetDEREncodedSize()
{
  return _SOSCircleGetDEREncodedSize();
}

uint64_t SOSCircleGetGeneration()
{
  return _SOSCircleGetGeneration();
}

uint64_t SOSCircleGetName()
{
  return _SOSCircleGetName();
}

uint64_t SOSCircleGetTypeID()
{
  return _SOSCircleGetTypeID();
}

uint64_t SOSCircleHasActivePeer()
{
  return _SOSCircleHasActivePeer();
}

uint64_t SOSCircleHasActivePeerWithID()
{
  return _SOSCircleHasActivePeerWithID();
}

uint64_t SOSCircleHasApplicant()
{
  return _SOSCircleHasApplicant();
}

uint64_t SOSCircleHasPeer()
{
  return _SOSCircleHasPeer();
}

uint64_t SOSCircleHasPeerWithID()
{
  return _SOSCircleHasPeerWithID();
}

uint64_t SOSCircleHasRejectedApplicant()
{
  return _SOSCircleHasRejectedApplicant();
}

uint64_t SOSCircleHasValidSyncingPeer()
{
  return _SOSCircleHasValidSyncingPeer();
}

uint64_t SOSCircleIsLegacy()
{
  return _SOSCircleIsLegacy();
}

uint64_t SOSCircleIsOlderGeneration()
{
  return _SOSCircleIsOlderGeneration();
}

uint64_t SOSCircleKeyCreateWithName()
{
  return _SOSCircleKeyCreateWithName();
}

uint64_t SOSCircleLogState()
{
  return _SOSCircleLogState();
}

uint64_t SOSCirclePeerInfoCopyStateString()
{
  return _SOSCirclePeerInfoCopyStateString();
}

uint64_t SOSCirclePreGenerationSign()
{
  return _SOSCirclePreGenerationSign();
}

uint64_t SOSCircleRejectRequest()
{
  return _SOSCircleRejectRequest();
}

uint64_t SOSCircleRemovePeers()
{
  return _SOSCircleRemovePeers();
}

uint64_t SOSCircleRemovePeersByIDUnsigned()
{
  return _SOSCircleRemovePeersByIDUnsigned();
}

uint64_t SOSCircleRemoveRejectedPeer()
{
  return _SOSCircleRemoveRejectedPeer();
}

uint64_t SOSCircleRemoveRetired()
{
  return _SOSCircleRemoveRetired();
}

uint64_t SOSCircleRequestAdmission()
{
  return _SOSCircleRequestAdmission();
}

uint64_t SOSCircleRequestReadmission()
{
  return _SOSCircleRequestReadmission();
}

uint64_t SOSCircleResetToEmpty()
{
  return _SOSCircleResetToEmpty();
}

uint64_t SOSCircleResetToOffering()
{
  return _SOSCircleResetToOffering();
}

uint64_t SOSCircleUpdatePeerInfo()
{
  return _SOSCircleUpdatePeerInfo();
}

uint64_t SOSCircleVerify()
{
  return _SOSCircleVerify();
}

uint64_t SOSCircleVerifyPeerSigned()
{
  return _SOSCircleVerifyPeerSigned();
}

uint64_t SOSCircleWithdrawRequest()
{
  return _SOSCircleWithdrawRequest();
}

uint64_t SOSCloudKeychainFlush()
{
  return _SOSCloudKeychainFlush();
}

uint64_t SOSCloudKeychainGetAllObjectsFromCloud()
{
  return _SOSCloudKeychainGetAllObjectsFromCloud();
}

uint64_t SOSCloudKeychainHandleUpdateMessage()
{
  return _SOSCloudKeychainHandleUpdateMessage();
}

uint64_t SOSCloudKeychainHasPendingKey()
{
  return _SOSCloudKeychainHasPendingKey();
}

uint64_t SOSCloudKeychainPutObjectsInCloud()
{
  return _SOSCloudKeychainPutObjectsInCloud();
}

uint64_t SOSCloudKeychainRemoveKeys()
{
  return _SOSCloudKeychainRemoveKeys();
}

uint64_t SOSCloudKeychainRequestEnsurePeerRegistration()
{
  return _SOSCloudKeychainRequestEnsurePeerRegistration();
}

uint64_t SOSCloudKeychainRequestPerfCounters()
{
  return _SOSCloudKeychainRequestPerfCounters();
}

uint64_t SOSCloudKeychainRequestSyncWithPeers()
{
  return _SOSCloudKeychainRequestSyncWithPeers();
}

uint64_t SOSCloudKeychainSetItemsChangedBlock()
{
  return _SOSCloudKeychainSetItemsChangedBlock();
}

uint64_t SOSCloudKeychainSynchronizeAndWait()
{
  return _SOSCloudKeychainSynchronizeAndWait();
}

uint64_t SOSCloudKeychainUpdateKeys()
{
  return _SOSCloudKeychainUpdateKeys();
}

uint64_t SOSCopyIDOfDataBuffer()
{
  return _SOSCopyIDOfDataBuffer();
}

uint64_t SOSCopyIDOfDataBufferWithLength()
{
  return _SOSCopyIDOfDataBufferWithLength();
}

uint64_t SOSCopyIDOfKey()
{
  return _SOSCopyIDOfKey();
}

uint64_t SOSCopyIDOfKeyWithLength()
{
  return _SOSCopyIDOfKeyWithLength();
}

uint64_t SOSCreateError()
{
  return _SOSCreateError();
}

uint64_t SOSCreateErrorWithFormat()
{
  return _SOSCreateErrorWithFormat();
}

uint64_t SOSCreateRandomDateBetweenNowPlus()
{
  return _SOSCreateRandomDateBetweenNowPlus();
}

uint64_t SOSDebugInfoKeyCreateWithTypeName()
{
  return _SOSDebugInfoKeyCreateWithTypeName();
}

uint64_t SOSDoWithCredentialsWhileUnlocked()
{
  return _SOSDoWithCredentialsWhileUnlocked();
}

uint64_t SOSErrorCreate()
{
  return _SOSErrorCreate();
}

uint64_t SOSFullPeerInfoCopyDeviceKey()
{
  return _SOSFullPeerInfoCopyDeviceKey();
}

uint64_t SOSFullPeerInfoCopyOctagonEncryptionKey()
{
  return _SOSFullPeerInfoCopyOctagonEncryptionKey();
}

uint64_t SOSFullPeerInfoCopyOctagonPublicEncryptionKey()
{
  return _SOSFullPeerInfoCopyOctagonPublicEncryptionKey();
}

uint64_t SOSFullPeerInfoCopyOctagonPublicSigningKey()
{
  return _SOSFullPeerInfoCopyOctagonPublicSigningKey();
}

uint64_t SOSFullPeerInfoCopyOctagonSigningKey()
{
  return _SOSFullPeerInfoCopyOctagonSigningKey();
}

uint64_t SOSFullPeerInfoCopyPubKey()
{
  return _SOSFullPeerInfoCopyPubKey();
}

uint64_t SOSFullPeerInfoCreateCloudIdentity()
{
  return _SOSFullPeerInfoCreateCloudIdentity();
}

uint64_t SOSFullPeerInfoCreateFromDER()
{
  return _SOSFullPeerInfoCreateFromDER();
}

uint64_t SOSFullPeerInfoCreateFromData()
{
  return _SOSFullPeerInfoCreateFromData();
}

uint64_t SOSFullPeerInfoCreateWithViews()
{
  return _SOSFullPeerInfoCreateWithViews();
}

uint64_t SOSFullPeerInfoEncodeToDER()
{
  return _SOSFullPeerInfoEncodeToDER();
}

uint64_t SOSFullPeerInfoGetDEREncodedSize()
{
  return _SOSFullPeerInfoGetDEREncodedSize();
}

uint64_t SOSFullPeerInfoGetPeerInfo()
{
  return _SOSFullPeerInfoGetPeerInfo();
}

uint64_t SOSFullPeerInfoPing()
{
  return _SOSFullPeerInfoPing();
}

uint64_t SOSFullPeerInfoPrivKeyExists()
{
  return _SOSFullPeerInfoPrivKeyExists();
}

uint64_t SOSFullPeerInfoPromoteToApplication()
{
  return _SOSFullPeerInfoPromoteToApplication();
}

uint64_t SOSFullPeerInfoPromoteToRetiredAndCopy()
{
  return _SOSFullPeerInfoPromoteToRetiredAndCopy();
}

uint64_t SOSFullPeerInfoPurgePersistentKey()
{
  return _SOSFullPeerInfoPurgePersistentKey();
}

uint64_t SOSFullPeerInfoReplaceEscrowRecords()
{
  return _SOSFullPeerInfoReplaceEscrowRecords();
}

uint64_t SOSFullPeerInfoUpdate()
{
  return _SOSFullPeerInfoUpdate();
}

uint64_t SOSFullPeerInfoUpdateGestalt()
{
  return _SOSFullPeerInfoUpdateGestalt();
}

uint64_t SOSFullPeerInfoUpdateOctagonEncryptionKey()
{
  return _SOSFullPeerInfoUpdateOctagonEncryptionKey();
}

uint64_t SOSFullPeerInfoUpdateOctagonSigningKey()
{
  return _SOSFullPeerInfoUpdateOctagonSigningKey();
}

uint64_t SOSFullPeerInfoUpdateToCurrent()
{
  return _SOSFullPeerInfoUpdateToCurrent();
}

uint64_t SOSFullPeerInfoUpdateToThisPeer()
{
  return _SOSFullPeerInfoUpdateToThisPeer();
}

uint64_t SOSFullPeerInfoUpdateV2Dictionary()
{
  return _SOSFullPeerInfoUpdateV2Dictionary();
}

uint64_t SOSFullPeerInfoUpdateViews()
{
  return _SOSFullPeerInfoUpdateViews();
}

uint64_t SOSFullPeerInfoUpgradeSignatures()
{
  return _SOSFullPeerInfoUpgradeSignatures();
}

uint64_t SOSFullPeerInfoViewStatus()
{
  return _SOSFullPeerInfoViewStatus();
}

uint64_t SOSGenCountCreateFromDER()
{
  return _SOSGenCountCreateFromDER();
}

uint64_t SOSGenCountEncodeToDER()
{
  return _SOSGenCountEncodeToDER();
}

uint64_t SOSGenCountGetDEREncodedSize()
{
  return _SOSGenCountGetDEREncodedSize();
}

uint64_t SOSGenerationCountCopyDescription()
{
  return _SOSGenerationCountCopyDescription();
}

uint64_t SOSGenerationCountWithDescription()
{
  return _SOSGenerationCountWithDescription();
}

uint64_t SOSGenerationCreate()
{
  return _SOSGenerationCreate();
}

uint64_t SOSGenerationCreateWithBaseline()
{
  return _SOSGenerationCreateWithBaseline();
}

uint64_t SOSGenerationIncrementAndCreate()
{
  return _SOSGenerationIncrementAndCreate();
}

uint64_t SOSItemsChangedCopyDescription()
{
  return _SOSItemsChangedCopyDescription();
}

uint64_t SOSKVSKeyGetKeyType()
{
  return _SOSKVSKeyGetKeyType();
}

uint64_t SOSKVSKeyGetKeyTypeAndParse()
{
  return _SOSKVSKeyGetKeyTypeAndParse();
}

uint64_t SOSKVSKeyParse()
{
  return _SOSKVSKeyParse();
}

uint64_t SOSLastKeyParametersPushedKeyCreateWithAccountGestalt()
{
  return _SOSLastKeyParametersPushedKeyCreateWithAccountGestalt();
}

uint64_t SOSLastKeyParametersPushedKeyCreateWithPeerID()
{
  return _SOSLastKeyParametersPushedKeyCreateWithPeerID();
}

uint64_t SOSMessageKeyCreateFromPeerToTransport()
{
  return _SOSMessageKeyCreateFromPeerToTransport();
}

uint64_t SOSMessageKeyCreateFromTransportToPeer()
{
  return _SOSMessageKeyCreateFromTransportToPeer();
}

uint64_t SOSMessageKeyCreateWithCircleNameAndPeerNames()
{
  return _SOSMessageKeyCreateWithCircleNameAndPeerNames();
}

uint64_t SOSPeerGestaltGetName()
{
  return _SOSPeerGestaltGetName();
}

uint64_t SOSPeerInfoApplicationVerify()
{
  return _SOSPeerInfoApplicationVerify();
}

uint64_t SOSPeerInfoCopyBackupKey()
{
  return _SOSPeerInfoCopyBackupKey();
}

uint64_t SOSPeerInfoCopyData()
{
  return _SOSPeerInfoCopyData();
}

uint64_t SOSPeerInfoCopyEnabledViews()
{
  return _SOSPeerInfoCopyEnabledViews();
}

uint64_t SOSPeerInfoCopyEncodedData()
{
  return _SOSPeerInfoCopyEncodedData();
}

uint64_t SOSPeerInfoCopyOctagonEncryptionPublicKey()
{
  return _SOSPeerInfoCopyOctagonEncryptionPublicKey();
}

uint64_t SOSPeerInfoCopyOctagonSigningPublicKey()
{
  return _SOSPeerInfoCopyOctagonSigningPublicKey();
}

uint64_t SOSPeerInfoCopyPubKey()
{
  return _SOSPeerInfoCopyPubKey();
}

uint64_t SOSPeerInfoCopySerialNumber()
{
  return _SOSPeerInfoCopySerialNumber();
}

uint64_t SOSPeerInfoCopyStateString()
{
  return _SOSPeerInfoCopyStateString();
}

uint64_t SOSPeerInfoCreateCloudIdentity()
{
  return _SOSPeerInfoCreateCloudIdentity();
}

uint64_t SOSPeerInfoCreateCopy()
{
  return _SOSPeerInfoCreateCopy();
}

uint64_t SOSPeerInfoCreateFromDER()
{
  return _SOSPeerInfoCreateFromDER();
}

uint64_t SOSPeerInfoCreateFromData()
{
  return _SOSPeerInfoCreateFromData();
}

uint64_t SOSPeerInfoGetClass()
{
  return _SOSPeerInfoGetClass();
}

uint64_t SOSPeerInfoGetPeerDeviceType()
{
  return _SOSPeerInfoGetPeerDeviceType();
}

uint64_t SOSPeerInfoGetPeerID()
{
  return _SOSPeerInfoGetPeerID();
}

uint64_t SOSPeerInfoGetPermittedViews()
{
  return _SOSPeerInfoGetPermittedViews();
}

uint64_t SOSPeerInfoGetSPID()
{
  return _SOSPeerInfoGetSPID();
}

uint64_t SOSPeerInfoGetTypeID()
{
  return _SOSPeerInfoGetTypeID();
}

uint64_t SOSPeerInfoHasBackupKey()
{
  return _SOSPeerInfoHasBackupKey();
}

uint64_t SOSPeerInfoHasUserVisibleViewsEnabled()
{
  return _SOSPeerInfoHasUserVisibleViewsEnabled();
}

uint64_t SOSPeerInfoInspectRetirementTicket()
{
  return _SOSPeerInfoInspectRetirementTicket();
}

uint64_t SOSPeerInfoIsCloudIdentity()
{
  return _SOSPeerInfoIsCloudIdentity();
}

uint64_t SOSPeerInfoIsEnabledView()
{
  return _SOSPeerInfoIsEnabledView();
}

uint64_t SOSPeerInfoIsRetirementTicket()
{
  return _SOSPeerInfoIsRetirementTicket();
}

uint64_t SOSPeerInfoIsViewPermitted()
{
  return _SOSPeerInfoIsViewPermitted();
}

uint64_t SOSPeerInfoPeerIDEqual()
{
  return _SOSPeerInfoPeerIDEqual();
}

uint64_t SOSPeerInfoRetireRetirementTicket()
{
  return _SOSPeerInfoRetireRetirementTicket();
}

uint64_t SOSPeerInfoSerialNumberIsSet()
{
  return _SOSPeerInfoSerialNumberIsSet();
}

uint64_t SOSPeerInfoSetCreateFromArrayDER()
{
  return _SOSPeerInfoSetCreateFromArrayDER();
}

uint64_t SOSPeerInfoSetEncodeToArrayDER()
{
  return _SOSPeerInfoSetEncodeToArrayDER();
}

uint64_t SOSPeerInfoSetFindByID()
{
  return _SOSPeerInfoSetFindByID();
}

uint64_t SOSPeerInfoSetGetDEREncodedArraySize()
{
  return _SOSPeerInfoSetGetDEREncodedArraySize();
}

uint64_t SOSPeerInfoSetOctagonKeysInDescription()
{
  return _SOSPeerInfoSetOctagonKeysInDescription();
}

uint64_t SOSPeerInfoSign()
{
  return _SOSPeerInfoSign();
}

uint64_t SOSPeerInfoSupportsCKKSForAll()
{
  return _SOSPeerInfoSupportsCKKSForAll();
}

uint64_t SOSPeerInfoUpdateToV2()
{
  return _SOSPeerInfoUpdateToV2();
}

uint64_t SOSPeerInfoV2DictionaryCopyString()
{
  return _SOSPeerInfoV2DictionaryCopyString();
}

uint64_t SOSPeerInfoV2DictionaryHasData()
{
  return _SOSPeerInfoV2DictionaryHasData();
}

uint64_t SOSPeerInfoV2DictionaryHasString()
{
  return _SOSPeerInfoV2DictionaryHasString();
}

uint64_t SOSPeerInfoV2DictionaryRemoveValue()
{
  return _SOSPeerInfoV2DictionaryRemoveValue();
}

uint64_t SOSPeerInfoV2DictionarySetValue()
{
  return _SOSPeerInfoV2DictionarySetValue();
}

uint64_t SOSPeerInfoVersionHasV2Data()
{
  return _SOSPeerInfoVersionHasV2Data();
}

uint64_t SOSPeerInfoVersionIsCurrent()
{
  return _SOSPeerInfoVersionIsCurrent();
}

uint64_t SOSPeerInfoViewStatus()
{
  return _SOSPeerInfoViewStatus();
}

uint64_t SOSPeerInfoWithEnabledViewSet()
{
  return _SOSPeerInfoWithEnabledViewSet();
}

uint64_t SOSPiggyBackBlobCopyEncodedData()
{
  return _SOSPiggyBackBlobCopyEncodedData();
}

uint64_t SOSPiggyBackBlobCreateFromData()
{
  return _SOSPiggyBackBlobCreateFromData();
}

uint64_t SOSRKNullKey()
{
  return _SOSRKNullKey();
}

uint64_t SOSRetirementKeyCreateWithCircleNameAndPeer()
{
  return _SOSRetirementKeyCreateWithCircleNameAndPeer();
}

uint64_t SOSRingKeyCreateWithName()
{
  return _SOSRingKeyCreateWithName();
}

uint64_t SOSRingKeyCreateWithRingName()
{
  return _SOSRingKeyCreateWithRingName();
}

uint64_t SOSViewBitmaskFromSet()
{
  return _SOSViewBitmaskFromSet();
}

uint64_t SOSViewCopyViewSet()
{
  return _SOSViewCopyViewSet();
}

uint64_t SOSViewHintInCKKSSystem()
{
  return _SOSViewHintInCKKSSystem();
}

uint64_t SOSViewInSOSSystem()
{
  return _SOSViewInSOSSystem();
}

uint64_t SOSViewSetDisable()
{
  return _SOSViewSetDisable();
}

uint64_t SOSViewSetEnable()
{
  return _SOSViewSetEnable();
}

uint64_t SOSViewSetIntersectsV0()
{
  return _SOSViewSetIntersectsV0();
}

uint64_t SOSViewsGetAllCurrent()
{
  return _SOSViewsGetAllCurrent();
}

uint64_t SOSViewsGetUserVisibleSet()
{
  return _SOSViewsGetUserVisibleSet();
}

uint64_t SOSViewsGetV0BackupBagViewSet()
{
  return _SOSViewsGetV0BackupBagViewSet();
}

uint64_t SOSViewsGetV0BackupViewSet()
{
  return _SOSViewsGetV0BackupViewSet();
}

uint64_t SOSViewsGetV0ViewSet()
{
  return _SOSViewsGetV0ViewSet();
}

uint64_t SOSViewsIsV0Subview()
{
  return _SOSViewsIsV0Subview();
}

uint64_t SOSVisibleKeychainNotAllowed()
{
  return _SOSVisibleKeychainNotAllowed();
}

uint64_t SecABCTrigger()
{
  return _SecABCTrigger();
}

uint64_t SecAccessControlAddConstraintForOperation()
{
  return _SecAccessControlAddConstraintForOperation();
}

uint64_t SecAccessControlCopyData()
{
  return _SecAccessControlCopyData();
}

uint64_t SecAccessControlCreate()
{
  return _SecAccessControlCreate();
}

uint64_t SecAccessControlCreateFromData()
{
  return _SecAccessControlCreateFromData();
}

uint64_t SecAccessControlGetConstraint()
{
  return _SecAccessControlGetConstraint();
}

uint64_t SecAccessControlGetConstraints()
{
  return _SecAccessControlGetConstraints();
}

uint64_t SecAccessControlGetProtection()
{
  return _SecAccessControlGetProtection();
}

uint64_t SecAccessControlIsBound()
{
  return _SecAccessControlIsBound();
}

uint64_t SecAccessControlSetConstraints()
{
  return _SecAccessControlSetConstraints();
}

uint64_t SecAccessControlSetProtection()
{
  return _SecAccessControlSetProtection();
}

uint64_t SecCFAllocatorZeroize()
{
  return _SecCFAllocatorZeroize();
}

OSStatus SecCertificateCopyEmailAddresses(SecCertificateRef certificate, CFArrayRef *emailAddresses)
{
  return _SecCertificateCopyEmailAddresses(certificate, emailAddresses);
}

SecCertificateRef SecCertificateCreateWithData(CFAllocatorRef allocator, CFDataRef data)
{
  return _SecCertificateCreateWithData(allocator, data);
}

uint64_t SecCertificateNotValidAfter()
{
  return _SecCertificateNotValidAfter();
}

uint64_t SecCertificateNotValidBefore()
{
  return _SecCertificateNotValidBefore();
}

uint64_t SecCopyLastError()
{
  return _SecCopyLastError();
}

uint64_t SecCoreAnalyticsSendValue()
{
  return _SecCoreAnalyticsSendValue();
}

uint64_t SecDistinguishedNameCopyNormalizedContent()
{
  return _SecDistinguishedNameCopyNormalizedContent();
}

uint64_t SecErrorGetOSStatus()
{
  return _SecErrorGetOSStatus();
}

uint64_t SecEscrowRequestSetupControlProtocol()
{
  return _SecEscrowRequestSetupControlProtocol();
}

uint64_t SecIsInternalRelease()
{
  return _SecIsInternalRelease();
}

OSStatus SecItemAdd(CFDictionaryRef attributes, CFTypeRef *result)
{
  return _SecItemAdd(attributes, result);
}

OSStatus SecItemCopyMatching(CFDictionaryRef query, CFTypeRef *result)
{
  return _SecItemCopyMatching(query, result);
}

OSStatus SecItemDelete(CFDictionaryRef query)
{
  return _SecItemDelete(query);
}

OSStatus SecItemUpdate(CFDictionaryRef query, CFDictionaryRef attributesToUpdate)
{
  return _SecItemUpdate(query, attributesToUpdate);
}

CFDataRef SecKeyCopyExternalRepresentation(SecKeyRef key, CFErrorRef *error)
{
  return _SecKeyCopyExternalRepresentation(key, error);
}

uint64_t SecKeyCopyMatchingPrivateKey()
{
  return _SecKeyCopyMatchingPrivateKey();
}

uint64_t SecKeyCopyPersistentRef()
{
  return _SecKeyCopyPersistentRef();
}

uint64_t SecKeyCopyPublicBytes()
{
  return _SecKeyCopyPublicBytes();
}

SecKeyRef SecKeyCopyPublicKey(SecKeyRef key)
{
  return _SecKeyCopyPublicKey(key);
}

uint64_t SecKeyCopyPublicKeyHash()
{
  return _SecKeyCopyPublicKeyHash();
}

uint64_t SecKeyCopySubjectPublicKeyInfo()
{
  return _SecKeyCopySubjectPublicKeyInfo();
}

uint64_t SecKeyCreateFromAttributeDictionary()
{
  return _SecKeyCreateFromAttributeDictionary();
}

uint64_t SecKeyCreateFromPublicData()
{
  return _SecKeyCreateFromPublicData();
}

uint64_t SecKeyCreatePublicFromPrivate()
{
  return _SecKeyCreatePublicFromPrivate();
}

SecKeyRef SecKeyCreateWithData(CFDataRef keyData, CFDictionaryRef attributes, CFErrorRef *error)
{
  return _SecKeyCreateWithData(keyData, attributes, error);
}

OSStatus SecKeyGeneratePair(CFDictionaryRef parameters, SecKeyRef *publicKey, SecKeyRef *privateKey)
{
  return _SecKeyGeneratePair(parameters, publicKey, privateKey);
}

uint64_t SecKeyGeneratePrivateAttributeDictionary()
{
  return _SecKeyGeneratePrivateAttributeDictionary();
}

uint64_t SecKeyGetSize()
{
  return _SecKeyGetSize();
}

OSStatus SecKeyRawSign(SecKeyRef key, SecPadding padding, const uint8_t *dataToSign, size_t dataToSignLen, uint8_t *sig, size_t *sigLen)
{
  return _SecKeyRawSign(key, padding, dataToSign, dataToSignLen, sig, sigLen);
}

OSStatus SecKeyRawVerify(SecKeyRef key, SecPadding padding, const uint8_t *signedData, size_t signedDataLen, const uint8_t *sig, size_t sigLen)
{
  return _SecKeyRawVerify(key, padding, signedData, signedDataLen, sig, sigLen);
}

uint64_t SecOTRFullIdentityCreateFromSecKeyRefSOS()
{
  return _SecOTRFullIdentityCreateFromSecKeyRefSOS();
}

uint64_t SecOTRPacketTypeString()
{
  return _SecOTRPacketTypeString();
}

uint64_t SecOTRPublicIdentityCreateFromSecKeyRef()
{
  return _SecOTRPublicIdentityCreateFromSecKeyRef();
}

uint64_t SecOTRSAppendRestartPacket()
{
  return _SecOTRSAppendRestartPacket();
}

uint64_t SecOTRSAppendSerialization()
{
  return _SecOTRSAppendSerialization();
}

uint64_t SecOTRSAppendStartPacket()
{
  return _SecOTRSAppendStartPacket();
}

uint64_t SecOTRSGetIsIdle()
{
  return _SecOTRSGetIsIdle();
}

uint64_t SecOTRSGetIsReadyForMessages()
{
  return _SecOTRSGetIsReadyForMessages();
}

uint64_t SecOTRSGetMessageKind()
{
  return _SecOTRSGetMessageKind();
}

uint64_t SecOTRSIsForKeys()
{
  return _SecOTRSIsForKeys();
}

uint64_t SecOTRSProcessPacket()
{
  return _SecOTRSProcessPacket();
}

uint64_t SecOTRSSignAndProtectMessage()
{
  return _SecOTRSSignAndProtectMessage();
}

uint64_t SecOTRSVerifyAndExposeMessage()
{
  return _SecOTRSVerifyAndExposeMessage();
}

uint64_t SecOTRSessionCreateFromData()
{
  return _SecOTRSessionCreateFromData();
}

uint64_t SecOTRSessionCreateFromID()
{
  return _SecOTRSessionCreateFromID();
}

uint64_t SecOTRSessionCreateFromIDAndFlags()
{
  return _SecOTRSessionCreateFromIDAndFlags();
}

uint64_t SecOTRSessionIsSessionInAwaitingState()
{
  return _SecOTRSessionIsSessionInAwaitingState();
}

uint64_t SecOTRSessionReset()
{
  return _SecOTRSessionReset();
}

uint64_t SecPasswordGenerate()
{
  return _SecPasswordGenerate();
}

uint64_t SecPasswordValidatePasswordFormat()
{
  return _SecPasswordValidatePasswordFormat();
}

CFDictionaryRef SecPolicyCopyProperties(SecPolicyRef policyRef)
{
  return _SecPolicyCopyProperties(policyRef);
}

SecPolicyRef SecPolicyCreateBasicX509(void)
{
  return _SecPolicyCreateBasicX509();
}

CFTypeID SecPolicyGetTypeID(void)
{
  return _SecPolicyGetTypeID();
}

uint64_t SecPolicyXPCArrayCopyArray()
{
  return _SecPolicyXPCArrayCopyArray();
}

int SecRandomCopyBytes(SecRandomRef rnd, size_t count, void *bytes)
{
  return _SecRandomCopyBytes(rnd, count, bytes);
}

uint64_t SecSecurityClientGet()
{
  return _SecSecurityClientGet();
}

uint64_t SecSecurityFixUpClientWithPersona()
{
  return _SecSecurityFixUpClientWithPersona();
}

CFStringRef SecTaskCopySigningIdentifier(SecTaskRef task, CFErrorRef *error)
{
  return _SecTaskCopySigningIdentifier(task, error);
}

CFTypeRef SecTaskCopyValueForEntitlement(SecTaskRef task, CFStringRef entitlement, CFErrorRef *error)
{
  return _SecTaskCopyValueForEntitlement(task, entitlement, error);
}

SecTaskRef SecTaskCreateWithAuditToken(CFAllocatorRef allocator, audit_token_t *token)
{
  return _SecTaskCreateWithAuditToken(allocator, token);
}

uint32_t SecTaskGetCodeSignStatus(SecTaskRef task)
{
  return _SecTaskGetCodeSignStatus(task);
}

uint64_t SecTokenItemValueCopy()
{
  return _SecTokenItemValueCopy();
}

OSStatus SecTrustCreateWithCertificates(CFTypeRef certificates, CFTypeRef policies, SecTrustRef *trust)
{
  return _SecTrustCreateWithCertificates(certificates, policies, trust);
}

OSStatus SecTrustEvaluate(SecTrustRef trust, SecTrustResultType *result)
{
  return _SecTrustEvaluate(trust, result);
}

uint64_t SecTrustEvaluateLeafOnly()
{
  return _SecTrustEvaluateLeafOnly();
}

OSStatus SecTrustSetVerifyDate(SecTrustRef trust, CFDateRef verifyDate)
{
  return _SecTrustSetVerifyDate(trust, verifyDate);
}

uint64_t TPPeerStatusToString()
{
  return _TPPeerStatusToString();
}

void *__cdecl _Block_copy(const void *aBlock)
{
  return __Block_copy(aBlock);
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

void _Block_release(const void *aBlock)
{
}

uint64_t _CFCopySystemVersionDictionary()
{
  return __CFCopySystemVersionDictionary();
}

uint64_t _CFRuntimeCreateInstance()
{
  return __CFRuntimeCreateInstance();
}

uint64_t _CFRuntimeRegisterClass()
{
  return __CFRuntimeRegisterClass();
}

uint64_t _CFXPCCreateXPCObjectFromCFObject()
{
  return __CFXPCCreateXPCObjectFromCFObject();
}

uint64_t _NSIsNSData()
{
  return __NSIsNSData();
}

uint64_t _NSIsNSDate()
{
  return __NSIsNSDate();
}

uint64_t _NSIsNSNumber()
{
  return __NSIsNSNumber();
}

uint64_t _NSIsNSString()
{
  return __NSIsNSString();
}

uint64_t _OctagonSignpostCreate()
{
  return __OctagonSignpostCreate();
}

uint64_t _OctagonSignpostGetNanoseconds()
{
  return __OctagonSignpostGetNanoseconds();
}

uint64_t _OctagonSignpostLogSystem()
{
  return __OctagonSignpostLogSystem();
}

uint64_t _SOSControlSetupInterface()
{
  return __SOSControlSetupInterface();
}

uint64_t _SecItemCreatePersistentRef()
{
  return __SecItemCreatePersistentRef();
}

uint64_t _SecItemCreateUUIDBasedPersistentRef()
{
  return __SecItemCreateUUIDBasedPersistentRef();
}

uint64_t _SecItemParsePersistentRef()
{
  return __SecItemParsePersistentRef();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

uint64_t __dtoa()
{
  return ___dtoa();
}

int *__error(void)
{
  return ___error();
}

uint64_t __freedtoa()
{
  return ___freedtoa();
}

uint64_t __strlcpy_chk()
{
  return ___strlcpy_chk();
}

void _os_activity_initiate(void *dso, const char *description, os_activity_flag_t flags, os_block_t activity_block)
{
}

uint64_t _os_assert_log()
{
  return __os_assert_log();
}

uint64_t _os_assumes_log()
{
  return __os_assumes_log();
}

uint64_t _os_crash()
{
  return __os_crash();
}

uint64_t _os_feature_enabled_impl()
{
  return __os_feature_enabled_impl();
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_signpost_emit_with_name_impl(void *dso, os_log_t log, os_signpost_type_t type, os_signpost_id_t spid, const char *name, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _sl_dlopen()
{
  return __sl_dlopen();
}

void abort(void)
{
}

uint64_t abort_report_np()
{
  return _abort_report_np();
}

uint32_t arc4random_uniform(uint32_t __upper_bound)
{
  return _arc4random_uniform(__upper_bound);
}

int asprintf(char **a1, const char *a2, ...)
{
  return _asprintf(a1, a2);
}

void bzero(void *a1, size_t a2)
{
}

void *__cdecl calloc(size_t __count, size_t __size)
{
  return _calloc(__count, __size);
}

uint64_t cc_clear()
{
  return _cc_clear();
}

uint64_t ccaes_cbc_decrypt_mode()
{
  return _ccaes_cbc_decrypt_mode();
}

uint64_t ccaes_siv_decrypt_mode()
{
  return _ccaes_siv_decrypt_mode();
}

uint64_t ccaes_siv_encrypt_mode()
{
  return _ccaes_siv_encrypt_mode();
}

uint64_t cccbc_clear_iv()
{
  return _cccbc_clear_iv();
}

uint64_t cccbc_init()
{
  return _cccbc_init();
}

uint64_t cccurve25519_make_pub()
{
  return _cccurve25519_make_pub();
}

uint64_t ccder_blob_decode_len()
{
  return _ccder_blob_decode_len();
}

uint64_t ccder_blob_decode_range()
{
  return _ccder_blob_decode_range();
}

uint64_t ccder_blob_decode_sequence_tl()
{
  return _ccder_blob_decode_sequence_tl();
}

uint64_t ccder_blob_decode_tag()
{
  return _ccder_blob_decode_tag();
}

uint64_t ccder_blob_decode_tl()
{
  return _ccder_blob_decode_tl();
}

uint64_t ccder_blob_encode_body()
{
  return _ccder_blob_encode_body();
}

uint64_t ccder_blob_encode_tl()
{
  return _ccder_blob_encode_tl();
}

uint64_t ccder_decode_constructed_tl()
{
  return _ccder_decode_constructed_tl();
}

uint64_t ccder_decode_len()
{
  return _ccder_decode_len();
}

uint64_t ccder_decode_sequence_tl()
{
  return _ccder_decode_sequence_tl();
}

uint64_t ccder_decode_tag()
{
  return _ccder_decode_tag();
}

uint64_t ccder_decode_tl()
{
  return _ccder_decode_tl();
}

uint64_t ccder_decode_uint64()
{
  return _ccder_decode_uint64();
}

uint64_t ccder_encode_body()
{
  return _ccder_encode_body();
}

uint64_t ccder_encode_body_nocopy()
{
  return _ccder_encode_body_nocopy();
}

uint64_t ccder_encode_constructed_tl()
{
  return _ccder_encode_constructed_tl();
}

uint64_t ccder_encode_len()
{
  return _ccder_encode_len();
}

uint64_t ccder_encode_raw_octet_string()
{
  return _ccder_encode_raw_octet_string();
}

uint64_t ccder_encode_tag()
{
  return _ccder_encode_tag();
}

uint64_t ccder_encode_tl()
{
  return _ccder_encode_tl();
}

uint64_t ccder_encode_uint64()
{
  return _ccder_encode_uint64();
}

uint64_t ccder_sizeof()
{
  return _ccder_sizeof();
}

uint64_t ccder_sizeof_implicit_raw_octet_string()
{
  return _ccder_sizeof_implicit_raw_octet_string();
}

uint64_t ccder_sizeof_raw_octet_string()
{
  return _ccder_sizeof_raw_octet_string();
}

uint64_t ccder_sizeof_uint64()
{
  return _ccder_sizeof_uint64();
}

uint64_t ccdigest()
{
  return _ccdigest();
}

uint64_t ccec_compact_import_pub()
{
  return _ccec_compact_import_pub();
}

uint64_t ccec_cp_256()
{
  return _ccec_cp_256();
}

uint64_t ccec_cp_384()
{
  return _ccec_cp_384();
}

uint64_t ccec_export_pub()
{
  return _ccec_export_pub();
}

uint64_t ccec_generate_key_deterministic()
{
  return _ccec_generate_key_deterministic();
}

uint64_t ccec_get_cp()
{
  return _ccec_get_cp();
}

uint64_t ccec_x963_export()
{
  return _ccec_x963_export();
}

uint64_t ccn_bitlen()
{
  return _ccn_bitlen();
}

uint64_t ccn_read_uint()
{
  return _ccn_read_uint();
}

uint64_t ccn_write_uint_padded()
{
  return _ccn_write_uint_padded();
}

uint64_t ccpbkdf2_hmac()
{
  return _ccpbkdf2_hmac();
}

uint64_t ccrng()
{
  return _ccrng();
}

uint64_t ccsha1_di()
{
  return _ccsha1_di();
}

uint64_t ccsha256_di()
{
  return _ccsha256_di();
}

uint64_t ccsiv_aad()
{
  return _ccsiv_aad();
}

uint64_t ccsiv_ciphertext_size()
{
  return _ccsiv_ciphertext_size();
}

uint64_t ccsiv_crypt()
{
  return _ccsiv_crypt();
}

uint64_t ccsiv_init()
{
  return _ccsiv_init();
}

uint64_t ccsiv_plaintext_size()
{
  return _ccsiv_plaintext_size();
}

uint64_t ccsiv_set_nonce()
{
  return _ccsiv_set_nonce();
}

uint64_t cczp_bitlen()
{
  return _cczp_bitlen();
}

int chmod(const char *a1, mode_t a2)
{
  return _chmod(a1, a2);
}

int close(int a1)
{
  return _close(a1);
}

size_t confstr(int a1, char *a2, size_t a3)
{
  return _confstr(a1, a2, a3);
}

uint64_t csr_check()
{
  return _csr_check();
}

uint64_t debugDumpCircle()
{
  return _debugDumpCircle();
}

int deflate(z_streamp strm, int flush)
{
  return _deflate(strm, flush);
}

int deflateEnd(z_streamp strm)
{
  return _deflateEnd(strm);
}

int deflateInit2_(z_streamp strm, int level, int method, int windowBits, int memLevel, int strategy, const char *version, int stream_size)
{
  return _deflateInit2_(strm, level, method, windowBits, memLevel, strategy, version, stream_size);
}

uint64_t der_decode_data_or_null()
{
  return _der_decode_data_or_null();
}

uint64_t der_encode_data_or_null()
{
  return _der_encode_data_or_null();
}

uint64_t der_sizeof_data_or_null()
{
  return _der_sizeof_data_or_null();
}

char *__cdecl dirname(char *a1)
{
  return _dirname(a1);
}

void dispatch_activate(dispatch_object_t object)
{
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_after_f(dispatch_time_t when, dispatch_queue_t queue, void *context, dispatch_function_t work)
{
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_barrier_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

void *__cdecl dispatch_get_context(dispatch_object_t object)
{
  return _dispatch_get_context(object);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return _dispatch_get_global_queue(identifier, flags);
}

void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_group_t dispatch_group_create(void)
{
  return _dispatch_group_create();
}

void dispatch_group_enter(dispatch_group_t group)
{
}

void dispatch_group_leave(dispatch_group_t group)
{
}

void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return _dispatch_group_wait(group, timeout);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return _dispatch_queue_attr_make_with_autorelease_frequency(attr, frequency);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return _dispatch_queue_attr_make_with_qos_class(attr, qos_class, relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return _dispatch_queue_create(label, attr);
}

void dispatch_release(dispatch_object_t object)
{
}

void dispatch_resume(dispatch_object_t object)
{
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return _dispatch_semaphore_create(value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return _dispatch_semaphore_signal(dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return _dispatch_semaphore_wait(dsema, timeout);
}

void dispatch_set_context(dispatch_object_t object, void *context)
{
}

void dispatch_set_finalizer_f(dispatch_object_t object, dispatch_function_t finalizer)
{
}

void dispatch_source_cancel(dispatch_source_t source)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return _dispatch_source_create(type, handle, mask, queue);
}

void dispatch_source_merge_data(dispatch_source_t source, uintptr_t value)
{
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_event_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
}

intptr_t dispatch_source_testcancel(dispatch_source_t source)
{
  return _dispatch_source_testcancel(source);
}

void dispatch_suspend(dispatch_object_t object)
{
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return _dispatch_time(when, delta);
}

dispatch_time_t dispatch_walltime(const timespec *when, int64_t delta)
{
  return _dispatch_walltime(when, delta);
}

char *dlerror(void)
{
  return _dlerror();
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return _dlsym(__handle, __symbol);
}

void exit(int a1)
{
}

int fclose(FILE *a1)
{
  return _fclose(a1);
}

int fflush(FILE *a1)
{
  return _fflush(a1);
}

long double fmod(long double __x, long double __y)
{
  return _fmod(__x, __y);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return _fopen(__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return _fprintf(a1, a2);
}

void free(void *a1)
{
}

int fstat(int a1, stat *a2)
{
  return _fstat(a1, a2);
}

off_t ftello(FILE *__stream)
{
  return _ftello(__stream);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return _fwrite(__ptr, __size, __nitems, __stream);
}

char *__cdecl getenv(const char *a1)
{
  return _getenv(a1);
}

uid_t geteuid(void)
{
  return _geteuid();
}

pid_t getpid(void)
{
  return _getpid();
}

int gettimeofday(timeval *a1, void *a2)
{
  return _gettimeofday(a1, a2);
}

uid_t getuid(void)
{
  return _getuid();
}

uint64_t kdebug_trace()
{
  return _kdebug_trace();
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return _mach_timebase_info(info);
}

malloc_zone_t *__cdecl malloc_create_zone(vm_size_t start_size, unsigned int flags)
{
  return _malloc_create_zone(start_size, flags);
}

void malloc_set_zone_name(malloc_zone_t *zone, const char *name)
{
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_calloc(count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_malloc(size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return _memcmp(__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return _memcpy(__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return _memmove(__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return _memset(__b, __c, __len);
}

errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
{
  return _memset_s(__s, __smax, __c, __n);
}

int mkpath_np(const char *path, mode_t omode)
{
  return _mkpath_np(path, omode);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return _mmap(a1, a2, a3, a4, a5, a6);
}

int munmap(void *a1, size_t a2)
{
  return _munmap(a1, a2);
}

uint32_t notify_cancel(int token)
{
  return _notify_cancel(token);
}

uint32_t notify_get_state(int token, uint64_t *state64)
{
  return _notify_get_state(token, state64);
}

uint32_t notify_post(const char *name)
{
  return _notify_post(name);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return _notify_register_dispatch(name, out_token, queue, handler);
}

uint32_t notify_set_state(int token, uint64_t state64)
{
  return _notify_set_state(token, state64);
}

nw_path_status_t nw_path_get_status(nw_path_t path)
{
  return _nw_path_get_status(path);
}

nw_path_monitor_t nw_path_monitor_create(void)
{
  return _nw_path_monitor_create();
}

void nw_path_monitor_set_queue(nw_path_monitor_t monitor, dispatch_queue_t queue)
{
}

void nw_path_monitor_set_update_handler(nw_path_monitor_t monitor, nw_path_monitor_update_handler_t update_handler)
{
}

void nw_path_monitor_start(nw_path_monitor_t monitor)
{
}

id objc_alloc(Class a1)
{
  return _[a1 alloc];
}

uint64_t objc_alloc_init()
{
  return _objc_alloc_init();
}

id objc_autorelease(id a1)
{
  return _objc_autorelease(a1);
}

{
}

{
}

id objc_autoreleaseReturnValue(id a1)
{
  return _objc_autoreleaseReturnValue(a1);
}

id objc_begin_catch(void *exc_buf)
{
  return _objc_begin_catch(exc_buf);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return _objc_claimAutoreleasedReturnValue();
}

void objc_copyWeak(id *to, id *from)
{
}

void objc_destroyWeak(id *location)
{
}

void objc_end_catch(void)
{
}

void objc_enumerationMutation(id obj)
{
}

void objc_exception_throw(id exception)
{
}

id objc_getAssociatedObject(id object, const void *key)
{
  return _objc_getAssociatedObject(object, key);
}

Class objc_getClass(const char *name)
{
  return _objc_getClass(name);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return _objc_getProperty(self, _cmd, offset, atomic);
}

id objc_initWeak(id *location, id val)
{
  return _objc_initWeak(location, val);
}

id objc_loadWeakRetained(id *location)
{
  return _objc_loadWeakRetained(location);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return [super a2];
}

uint64_t objc_opt_class()
{
  return _objc_opt_class();
}

uint64_t objc_opt_isKindOfClass()
{
  return _objc_opt_isKindOfClass();
}

uint64_t objc_opt_new()
{
  return _objc_opt_new();
}

uint64_t objc_opt_respondsToSelector()
{
  return _objc_opt_respondsToSelector();
}

uint64_t self
{
  return _self;
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return _objc_retain(a1);
}

id objc_retainAutorelease(id a1)
{
  return _a1;
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return _a1;
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return _a1;
}

id objc_retainBlock(id a1)
{
  return _objc_retainBlock(a1);
}

void objc_setAssociatedObject(id object, const void *key, id value, void *policy)
{
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_atomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_storeStrong(id *location, id obj)
{
}

id objc_storeWeak(id *location, id obj)
{
  return _objc_storeWeak(location, obj);
}

int objc_sync_enter(id obj)
{
  return _objc_sync_enter(obj);
}

int objc_sync_exit(id obj)
{
  return _objc_sync_exit(obj);
}

id objc_unsafeClaimAutoreleasedReturnValue(id a1)
{
  return _objc_unsafeClaimAutoreleasedReturnValue(a1);
}

int open(const char *a1, int a2, ...)
{
  return _open(a1, a2);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return _os_log_create(subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return _os_log_type_enabled(oslog, type);
}

BOOL os_signpost_enabled(os_log_t log)
{
  return _os_signpost_enabled(log);
}

uint64_t os_state_add_handler()
{
  return _os_state_add_handler();
}

uint64_t os_transaction_create()
{
  return _os_transaction_create();
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

uint64_t os_unfair_lock_lock_with_options()
{
  return _os_unfair_lock_lock_with_options();
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

uint64_t os_variant_is_recovery()
{
  return _os_variant_is_recovery();
}

int printf(const char *a1, ...)
{
  return _printf(a1);
}

int proc_pid_rusage(int pid, int flavor, rusage_info_t *buffer)
{
  return _proc_pid_rusage(pid, flavor, buffer);
}

objc_method_description protocol_getMethodDescription(Protocol *p, SEL aSel, BOOL isRequiredMethod, BOOL isInstanceMethod)
{
  objc_method_description MethodDescription = _protocol_getMethodDescription(p, aSel, isRequiredMethod, isInstanceMethod);
  types = MethodDescription.types;
  name = MethodDescription.name;
  result.types = types;
  result.name = name;
  return result;
}

BOOL protocol_isEqual(Protocol *proto, Protocol *other)
{
  return _protocol_isEqual(proto, other);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return _pthread_mutex_destroy(a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return _pthread_mutex_init(a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return _pthread_mutex_lock(a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return _pthread_mutex_unlock(a1);
}

int pthread_mutexattr_destroy(pthread_mutexattr_t *a1)
{
  return _pthread_mutexattr_destroy(a1);
}

int pthread_mutexattr_init(pthread_mutexattr_t *a1)
{
  return _pthread_mutexattr_init(a1);
}

int pthread_mutexattr_setpolicy_np(pthread_mutexattr_t *a1, int a2)
{
  return _pthread_mutexattr_setpolicy_np(a1, a2);
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
}

void *__cdecl reallocf(void *__ptr, size_t __size)
{
  return _reallocf(__ptr, __size);
}

BOOL remove(const std::__fs::filesystem::path *__p, std::error_code *__ec)
{
  return _remove(__p, __ec);
}

BOOL sel_isEqual(SEL lhs, SEL rhs)
{
  return _sel_isEqual(lhs, rhs);
}

void (__cdecl *__cdecl signal(int a1, void (__cdecl *a2)(int)))(int)
{
  return _signal(a1, a2);
}

unsigned int sleep(unsigned int a1)
{
  return _sleep(a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return _snprintf(__str, __size, __format);
}

int sqlite3_bind_blob(sqlite3_stmt *a1, int a2, const void *a3, int n, void (__cdecl *a5)(void *))
{
  return _sqlite3_bind_blob(a1, a2, a3, n, a5);
}

int sqlite3_bind_double(sqlite3_stmt *a1, int a2, double a3)
{
  return _sqlite3_bind_double(a1, a2, a3);
}

int sqlite3_bind_int(sqlite3_stmt *a1, int a2, int a3)
{
  return _sqlite3_bind_int(a1, a2, a3);
}

int sqlite3_bind_int64(sqlite3_stmt *a1, int a2, sqlite3_int64 a3)
{
  return _sqlite3_bind_int64(a1, a2, a3);
}

int sqlite3_bind_text(sqlite3_stmt *a1, int a2, const char *a3, int a4, void (__cdecl *a5)(void *))
{
  return _sqlite3_bind_text(a1, a2, a3, a4, a5);
}

int sqlite3_busy_timeout(sqlite3 *a1, int ms)
{
  return _sqlite3_busy_timeout(a1, ms);
}

int sqlite3_close(sqlite3 *a1)
{
  return _sqlite3_close(a1);
}

const void *__cdecl sqlite3_column_blob(sqlite3_stmt *a1, int iCol)
{
  return _sqlite3_column_blob(a1, iCol);
}

int sqlite3_column_bytes(sqlite3_stmt *a1, int iCol)
{
  return _sqlite3_column_bytes(a1, iCol);
}

int sqlite3_column_count(sqlite3_stmt *pStmt)
{
  return _sqlite3_column_count(pStmt);
}

double sqlite3_column_double(sqlite3_stmt *a1, int iCol)
{
  return _sqlite3_column_double(a1, iCol);
}

int sqlite3_column_int(sqlite3_stmt *a1, int iCol)
{
  return _sqlite3_column_int(a1, iCol);
}

sqlite3_int64 sqlite3_column_int64(sqlite3_stmt *a1, int iCol)
{
  return _sqlite3_column_int64(a1, iCol);
}

const unsigned __int8 *__cdecl sqlite3_column_text(sqlite3_stmt *a1, int iCol)
{
  return _sqlite3_column_text(a1, iCol);
}

int sqlite3_column_type(sqlite3_stmt *a1, int iCol)
{
  return _sqlite3_column_type(a1, iCol);
}

int sqlite3_config(int a1, ...)
{
  return _sqlite3_config(a1);
}

sqlite3 *__cdecl sqlite3_db_handle(sqlite3_stmt *a1)
{
  return _sqlite3_db_handle(a1);
}

const char *__cdecl sqlite3_errmsg(sqlite3 *a1)
{
  return _sqlite3_errmsg(a1);
}

int sqlite3_exec(sqlite3 *a1, const char *sql, int (__cdecl *callback)(void *, int, char **, char **), void *a4, char **errmsg)
{
  return _sqlite3_exec(a1, sql, callback, a4, errmsg);
}

int sqlite3_extended_errcode(sqlite3 *db)
{
  return _sqlite3_extended_errcode(db);
}

int sqlite3_finalize(sqlite3_stmt *pStmt)
{
  return _sqlite3_finalize(pStmt);
}

void sqlite3_free(void *a1)
{
}

int sqlite3_get_autocommit(sqlite3 *a1)
{
  return _sqlite3_get_autocommit(a1);
}

sqlite3_int64 sqlite3_last_insert_rowid(sqlite3 *a1)
{
  return _sqlite3_last_insert_rowid(a1);
}

int sqlite3_limit(sqlite3 *a1, int id, int newVal)
{
  return _sqlite3_limit(a1, id, newVal);
}

char *sqlite3_mprintf(const char *a1, ...)
{
  return _sqlite3_mprintf(a1);
}

int sqlite3_open_v2(const char *filename, sqlite3 **ppDb, int flags, const char *zVfs)
{
  return _sqlite3_open_v2(filename, ppDb, flags, zVfs);
}

int sqlite3_prepare_v2(sqlite3 *db, const char *zSql, int nByte, sqlite3_stmt **ppStmt, const char **pzTail)
{
  return _sqlite3_prepare_v2(db, zSql, nByte, ppStmt, pzTail);
}

int sqlite3_reset(sqlite3_stmt *pStmt)
{
  return _sqlite3_reset(pStmt);
}

int sqlite3_sleep(int a1)
{
  return _sqlite3_sleep(a1);
}

const char *__cdecl sqlite3_sql(sqlite3_stmt *pStmt)
{
  return _sqlite3_sql(pStmt);
}

int sqlite3_step(sqlite3_stmt *a1)
{
  return _sqlite3_step(a1);
}

int sqlite3_stmt_readonly(sqlite3_stmt *pStmt)
{
  return _sqlite3_stmt_readonly(pStmt);
}

int sqlite3_system_errno(sqlite3 *a1)
{
  return _sqlite3_system_errno(a1);
}

int sqlite3_trace_v2(sqlite3 *a1, unsigned int uMask, int (__cdecl *xCallback)(unsigned int, void *, void *, void *), void *pCtx)
{
  return _sqlite3_trace_v2(a1, uMask, xCallback, pCtx);
}

int sqlite3_wal_checkpoint_v2(sqlite3 *db, const char *zDb, int eMode, int *pnLog, int *pnCkpt)
{
  return _sqlite3_wal_checkpoint_v2(db, zDb, eMode, pnLog, pnCkpt);
}

int stat(const char *a1, stat *a2)
{
  return _stat(a1, a2);
}

char *__cdecl strerror(int __errnum)
{
  return _strerror(__errnum);
}

size_t strlen(const char *__s)
{
  return _strlen(__s);
}

int strncasecmp(const char *a1, const char *a2, size_t a3)
{
  return _strncasecmp(a1, a2, a3);
}

char *__cdecl strnstr(const char *__big, const char *__little, size_t __len)
{
  return _strnstr(__big, __little, __len);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return _sysctlbyname(a1, a2, a3, a4, a5);
}

void syslog(int a1, const char *a2, ...)
{
}

time_t time(time_t *a1)
{
  return _time(a1);
}

int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len)
{
  return _timingsafe_bcmp(__b1, __b2, __len);
}

uint64_t u_setMemoryFunctions()
{
  return _u_setMemoryFunctions();
}

int uname(utsname *a1)
{
  return _uname(a1);
}

int unlink(const char *a1)
{
  return _unlink(a1);
}

int uuid_compare(const uuid_t uu1, const uuid_t uu2)
{
  return _uuid_compare(uu1, uu2);
}

void uuid_copy(uuid_t dst, const uuid_t src)
{
}

int uuid_parse(const uuid_string_t in, uuid_t uu)
{
  return _uuid_parse(in, uu);
}

void uuid_unparse_lower(const uuid_t uu, uuid_string_t out)
{
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return _write(__fd, __buf, __nbyte);
}

xpc_activity_state_t xpc_activity_get_state(xpc_activity_t activity)
{
  return _xpc_activity_get_state(activity);
}

void xpc_activity_register(const char *identifier, xpc_object_t criteria, xpc_activity_handler_t handler)
{
}

uint64_t xpc_activity_set_completion_status()
{
  return _xpc_activity_set_completion_status();
}

BOOL xpc_activity_set_state(xpc_activity_t activity, xpc_activity_state_t state)
{
  return _xpc_activity_set_state(activity, state);
}

void xpc_activity_unregister(const char *identifier)
{
}

xpc_connection_t xpc_connection_create_mach_service(const char *name, dispatch_queue_t targetq, uint64_t flags)
{
  return _xpc_connection_create_mach_service(name, targetq, flags);
}

uint64_t xpc_connection_get_audit_token()
{
  return _xpc_connection_get_audit_token();
}

uid_t xpc_connection_get_euid(xpc_connection_t connection)
{
  return _xpc_connection_get_euid(connection);
}

void xpc_connection_resume(xpc_connection_t connection)
{
}

void xpc_connection_send_message(xpc_connection_t connection, xpc_object_t message)
{
}

xpc_object_t xpc_connection_send_message_with_reply_sync(xpc_connection_t connection, xpc_object_t message)
{
  return _xpc_connection_send_message_with_reply_sync(connection, message);
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
}

char *__cdecl xpc_copy_description(xpc_object_t object)
{
  return _xpc_copy_description(object);
}

uint64_t xpc_create_reply_with_format()
{
  return _xpc_create_reply_with_format();
}

const void *__cdecl xpc_data_get_bytes_ptr(xpc_object_t xdata)
{
  return _xpc_data_get_bytes_ptr(xdata);
}

size_t xpc_data_get_length(xpc_object_t xdata)
{
  return _xpc_data_get_length(xdata);
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return _xpc_dictionary_create(keys, values, count);
}

xpc_object_t xpc_dictionary_create_empty(void)
{
  return _xpc_dictionary_create_empty();
}

xpc_object_t xpc_dictionary_create_reply(xpc_object_t original)
{
  return _xpc_dictionary_create_reply(original);
}

int xpc_dictionary_dup_fd(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_dup_fd(xdict, key);
}

BOOL xpc_dictionary_get_BOOL(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_BOOL(xdict, key);
}

const void *__cdecl xpc_dictionary_get_data(xpc_object_t xdict, const char *key, size_t *length)
{
  return _xpc_dictionary_get_data(xdict, key, length);
}

int64_t xpc_dictionary_get_int64(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_int64(xdict, key);
}

const char *__cdecl xpc_dictionary_get_string(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_string(xdict, key);
}

uint64_t xpc_dictionary_get_uint64(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_uint64(xdict, key);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_value(xdict, key);
}

void xpc_dictionary_set_BOOL(xpc_object_t xdict, const char *key, BOOL value)
{
}

void xpc_dictionary_set_data(xpc_object_t xdict, const char *key, const void *bytes, size_t length)
{
}

void xpc_dictionary_set_fd(xpc_object_t xdict, const char *key, int fd)
{
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
}

void xpc_dictionary_set_uint64(xpc_object_t xdict, const char *key, uint64_t value)
{
}

void xpc_dictionary_set_value(xpc_object_t xdict, const char *key, xpc_object_t value)
{
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return _xpc_get_type(object);
}

void xpc_release(xpc_object_t object)
{
}

void xpc_transaction_begin(void)
{
}

void xpc_transaction_end(void)
{
}

uint64_t xpc_transaction_exit_clean()
{
  return _xpc_transaction_exit_clean();
}

id objc_msgSend_AllOctagonFlags(void *a1, const char *a2, ...)
{
  return [a1 AllOctagonFlags];
}

id objc_msgSend_CKPropertiesDescription(void *a1, const char *a2, ...)
{
  return [a1 CKPropertiesDescription];
}

id objc_msgSend_CKRecordName(void *a1, const char *a2, ...)
{
  return [a1 CKRecordName];
}

id objc_msgSend_OctagonAllStates(void *a1, const char *a2, ...)
{
  return [a1 OctagonAllStates];
}

id objc_msgSend_OctagonHealthSourceStates(void *a1, const char *a2, ...)
{
  return [a1 OctagonHealthSourceStates];
}

id objc_msgSend_OctagonInAccountStates(void *a1, const char *a2, ...)
{
  return [a1 OctagonInAccountStates];
}

id objc_msgSend_OctagonNotInCliqueStates(void *a1, const char *a2, ...)
{
  return [a1 OctagonNotInCliqueStates];
}

id objc_msgSend_OctagonReadyStates(void *a1, const char *a2, ...)
{
  return [a1 OctagonReadyStates];
}

id objc_msgSend_OctagonStateMap(void *a1, const char *a2, ...)
{
  return [a1 OctagonStateMap];
}

id objc_msgSend_PCSPublicKey(void *a1, const char *a2, ...)
{
  return [a1 PCSPublicKey];
}

id objc_msgSend_PCSServiceID(void *a1, const char *a2, ...)
{
  return [a1 PCSServiceID];
}

id objc_msgSend_SOSMonitorModeDisableSOS(void *a1, const char *a2, ...)
{
  return [a1 SOSMonitorModeDisableSOS];
}

id objc_msgSend_SOSMonitorModeEnableSOS(void *a1, const char *a2, ...)
{
  return [a1 SOSMonitorModeEnableSOS];
}

id objc_msgSend_SOSMonitorModeSOSIsActive(void *a1, const char *a2, ...)
{
  return [a1 SOSMonitorModeSOSIsActive];
}

id objc_msgSend_SOSMonitorModeSOSIsActiveDescription(void *a1, const char *a2, ...)
{
  return [a1 SOSMonitorModeSOSIsActiveDescription];
}

id objc_msgSend_SOSTransportMessageGetAccount(void *a1, const char *a2, ...)
{
  return [a1 SOSTransportMessageGetAccount];
}

id objc_msgSend_SOSTransportMessageGetCircleName(void *a1, const char *a2, ...)
{
  return [a1 SOSTransportMessageGetCircleName];
}

id objc_msgSend_SOSTransportMessageGetEngine(void *a1, const char *a2, ...)
{
  return [a1 SOSTransportMessageGetEngine];
}

id objc_msgSend_SOSTransportMessageGetTransportType(void *a1, const char *a2, ...)
{
  return [a1 SOSTransportMessageGetTransportType];
}

id objc_msgSend_URL(void *a1, const char *a2, ...)
{
  return [a1 URL];
}

id objc_msgSend_URLSession(void *a1, const char *a2, ...)
{
  return [a1 URLSession];
}

id objc_msgSend_UTF8String(void *a1, const char *a2, ...)
{
  return [a1 UTF8String];
}

id objc_msgSend_UUID(void *a1, const char *a2, ...)
{
  return [a1 UUID];
}

id objc_msgSend_UUIDString(void *a1, const char *a2, ...)
{
  return [a1 UUIDString];
}

id objc_msgSend__appearsToBeEmail(void *a1, const char *a2, ...)
{
  return [a1 _appearsToBeEmail];
}

id objc_msgSend__appearsToBePhoneNumber(void *a1, const char *a2, ...)
{
  return [a1 _appearsToBePhoneNumber];
}

id objc_msgSend__endpoint(void *a1, const char *a2, ...)
{
  return [a1 _endpoint];
}

id objc_msgSend__init(void *a1, const char *a2, ...)
{
  return [a1 _init];
}

id objc_msgSend__isCKServerInternalError(void *a1, const char *a2, ...)
{
  return [a1 _isCKServerInternalError];
}

id objc_msgSend__isRetryableNSURLError(void *a1, const char *a2, ...)
{
  return [a1 _isRetryableNSURLError];
}

id objc_msgSend__onQueueDropClassAKeys(void *a1, const char *a2, ...)
{
  return [a1 _onQueueDropClassAKeys];
}

id objc_msgSend__onQueueRecordRetiredPeersInCircle(void *a1, const char *a2, ...)
{
  return [a1 _onQueueRecordRetiredPeersInCircle];
}

id objc_msgSend__onQueueResetReachabilityDependency(void *a1, const char *a2, ...)
{
  return [a1 _onQueueResetReachabilityDependency];
}

id objc_msgSend__onQueueRunReachabilityDependency(void *a1, const char *a2, ...)
{
  return [a1 _onQueueRunReachabilityDependency];
}

id objc_msgSend__onqueueNextStateMachineTransition(void *a1, const char *a2, ...)
{
  return [a1 _onqueueNextStateMachineTransition];
}

id objc_msgSend__onqueuePokeStateMachine(void *a1, const char *a2, ...)
{
  return [a1 _onqueuePokeStateMachine];
}

id objc_msgSend__onqueuePrioritizePriorityViews(void *a1, const char *a2, ...)
{
  return [a1 _onqueuePrioritizePriorityViews];
}

id objc_msgSend__onqueueRecheck(void *a1, const char *a2, ...)
{
  return [a1 _onqueueRecheck];
}

id objc_msgSend__onqueueRecheckConditions(void *a1, const char *a2, ...)
{
  return [a1 _onqueueRecheckConditions];
}

id objc_msgSend__onqueueSendAnyPendingFlags(void *a1, const char *a2, ...)
{
  return [a1 _onqueueSendAnyPendingFlags];
}

id objc_msgSend__onqueueStart(void *a1, const char *a2, ...)
{
  return [a1 _onqueueStart];
}

id objc_msgSend__onqueueTimeoutError(void *a1, const char *a2, ...)
{
  return [a1 _onqueueTimeoutError];
}

id objc_msgSend__onqueueTimerTick(void *a1, const char *a2, ...)
{
  return [a1 _onqueueTimerTick];
}

id objc_msgSend__secKey(void *a1, const char *a2, ...)
{
  return [a1 _secKey];
}

id objc_msgSend_acceptanceStatus(void *a1, const char *a2, ...)
{
  return [a1 acceptanceStatus];
}

id objc_msgSend_accessGroup(void *a1, const char *a2, ...)
{
  return [a1 accessGroup];
}

id objc_msgSend_accessGroupRateLimitState(void *a1, const char *a2, ...)
{
  return [a1 accessGroupRateLimitState];
}

id objc_msgSend_accessGroupToNextMessageToSend(void *a1, const char *a2, ...)
{
  return [a1 accessGroupToNextMessageToSend];
}

id objc_msgSend_accessGroupToTimer(void *a1, const char *a2, ...)
{
  return [a1 accessGroupToTimer];
}

id objc_msgSend_accessGroups(void *a1, const char *a2, ...)
{
  return [a1 accessGroups];
}

id objc_msgSend_accessgroup(void *a1, const char *a2, ...)
{
  return [a1 accessgroup];
}

id objc_msgSend_accessibility(void *a1, const char *a2, ...)
{
  return [a1 accessibility];
}

id objc_msgSend_account(void *a1, const char *a2, ...)
{
  return [a1 account];
}

id objc_msgSend_accountChanged(void *a1, const char *a2, ...)
{
  return [a1 accountChanged];
}

id objc_msgSend_accountCirclePeerID(void *a1, const char *a2, ...)
{
  return [a1 accountCirclePeerID];
}

id objc_msgSend_accountCirclePeerIDInitialized(void *a1, const char *a2, ...)
{
  return [a1 accountCirclePeerIDInitialized];
}

id objc_msgSend_accountConfiguration(void *a1, const char *a2, ...)
{
  return [a1 accountConfiguration];
}

id objc_msgSend_accountInScriptBypassMode(void *a1, const char *a2, ...)
{
  return [a1 accountInScriptBypassMode];
}

id objc_msgSend_accountIsCDPCapable(void *a1, const char *a2, ...)
{
  return [a1 accountIsCDPCapable];
}

id objc_msgSend_accountIsChanging(void *a1, const char *a2, ...)
{
  return [a1 accountIsChanging];
}

id objc_msgSend_accountKey(void *a1, const char *a2, ...)
{
  return [a1 accountKey];
}

id objc_msgSend_accountKeyDerivationParameters(void *a1, const char *a2, ...)
{
  return [a1 accountKeyDerivationParameters];
}

id objc_msgSend_accountKeyIsTrusted(void *a1, const char *a2, ...)
{
  return [a1 accountKeyIsTrusted];
}

id objc_msgSend_accountLoggedInDependency(void *a1, const char *a2, ...)
{
  return [a1 accountLoggedInDependency];
}

id objc_msgSend_accountMetadataStore(void *a1, const char *a2, ...)
{
  return [a1 accountMetadataStore];
}

id objc_msgSend_accountNoLongerAvailable(void *a1, const char *a2, ...)
{
  return [a1 accountNoLongerAvailable];
}

id objc_msgSend_accountOverrideInfo(void *a1, const char *a2, ...)
{
  return [a1 accountOverrideInfo];
}

id objc_msgSend_accountPrivateKey(void *a1, const char *a2, ...)
{
  return [a1 accountPrivateKey];
}

id objc_msgSend_accountSettings(void *a1, const char *a2, ...)
{
  return [a1 accountSettings];
}

id objc_msgSend_accountStateKnown(void *a1, const char *a2, ...)
{
  return [a1 accountStateKnown];
}

id objc_msgSend_accountStateTracker(void *a1, const char *a2, ...)
{
  return [a1 accountStateTracker];
}

id objc_msgSend_accountStatus(void *a1, const char *a2, ...)
{
  return [a1 accountStatus];
}

id objc_msgSend_accountStatusInternal(void *a1, const char *a2, ...)
{
  return [a1 accountStatusInternal];
}

id objc_msgSend_accountTracker(void *a1, const char *a2, ...)
{
  return [a1 accountTracker];
}

id objc_msgSend_accountType(void *a1, const char *a2, ...)
{
  return [a1 accountType];
}

id objc_msgSend_accountWide(void *a1, const char *a2, ...)
{
  return [a1 accountWide];
}

id objc_msgSend_accountsAdapter(void *a1, const char *a2, ...)
{
  return [a1 accountsAdapter];
}

id objc_msgSend_action(void *a1, const char *a2, ...)
{
  return [a1 action];
}

id objc_msgSend_activate(void *a1, const char *a2, ...)
{
  return [a1 activate];
}

id objc_msgSend_activateTimer(void *a1, const char *a2, ...)
{
  return [a1 activateTimer];
}

id objc_msgSend_active(void *a1, const char *a2, ...)
{
  return [a1 active];
}

id objc_msgSend_activeAccount(void *a1, const char *a2, ...)
{
  return [a1 activeAccount];
}

id objc_msgSend_activeManagedViews(void *a1, const char *a2, ...)
{
  return [a1 activeManagedViews];
}

id objc_msgSend_addBackupFlag(void *a1, const char *a2, ...)
{
  return [a1 addBackupFlag];
}

id objc_msgSend_addRingDictionary(void *a1, const char *a2, ...)
{
  return [a1 addRingDictionary];
}

id objc_msgSend_addRingUpdateFlag(void *a1, const char *a2, ...)
{
  return [a1 addRingUpdateFlag];
}

id objc_msgSend_aessivkey(void *a1, const char *a2, ...)
{
  return [a1 aessivkey];
}

id objc_msgSend_afterOperation(void *a1, const char *a2, ...)
{
  return [a1 afterOperation];
}

id objc_msgSend_afterPreflight(void *a1, const char *a2, ...)
{
  return [a1 afterPreflight];
}

id objc_msgSend_afterPrepare(void *a1, const char *a2, ...)
{
  return [a1 afterPrepare];
}

id objc_msgSend_afterSuccessfulAllowList(void *a1, const char *a2, ...)
{
  return [a1 afterSuccessfulAllowList];
}

id objc_msgSend_afterUpdate(void *a1, const char *a2, ...)
{
  return [a1 afterUpdate];
}

id objc_msgSend_allCKKSManagedViews(void *a1, const char *a2, ...)
{
  return [a1 allCKKSManagedViews];
}

id objc_msgSend_allClientOptions(void *a1, const char *a2, ...)
{
  return [a1 allClientOptions];
}

id objc_msgSend_allDependentsSuccessful(void *a1, const char *a2, ...)
{
  return [a1 allDependentsSuccessful];
}

id objc_msgSend_allExternalManagedViews(void *a1, const char *a2, ...)
{
  return [a1 allExternalManagedViews];
}

id objc_msgSend_allKeys(void *a1, const char *a2, ...)
{
  return [a1 allKeys];
}

id objc_msgSend_allObjects(void *a1, const char *a2, ...)
{
  return [a1 allObjects];
}

id objc_msgSend_allPriorityViews(void *a1, const char *a2, ...)
{
  return [a1 allPriorityViews];
}

id objc_msgSend_allSelves(void *a1, const char *a2, ...)
{
  return [a1 allSelves];
}

id objc_msgSend_allValues(void *a1, const char *a2, ...)
{
  return [a1 allValues];
}

id objc_msgSend_allViews(void *a1, const char *a2, ...)
{
  return [a1 allViews];
}

id objc_msgSend_allZoneCreationsSucceeded(void *a1, const char *a2, ...)
{
  return [a1 allZoneCreationsSucceeded];
}

id objc_msgSend_allZoneSubscriptionsSucceeded(void *a1, const char *a2, ...)
{
  return [a1 allZoneSubscriptionsSucceeded];
}

id objc_msgSend_alloc(void *a1, const char *a2, ...)
{
  return [a1 alloc];
}

id objc_msgSend_allowFullRefetchResult(void *a1, const char *a2, ...)
{
  return [a1 allowFullRefetchResult];
}

id objc_msgSend_allowPendingFlags(void *a1, const char *a2, ...)
{
  return [a1 allowPendingFlags];
}

id objc_msgSend_allowableFlags(void *a1, const char *a2, ...)
{
  return [a1 allowableFlags];
}

id objc_msgSend_allowableStates(void *a1, const char *a2, ...)
{
  return [a1 allowableStates];
}

id objc_msgSend_allowedProtocol(void *a1, const char *a2, ...)
{
  return [a1 allowedProtocol];
}

id objc_msgSend_altDSID(void *a1, const char *a2, ...)
{
  return [a1 altDSID];
}

id objc_msgSend_andsCount(void *a1, const char *a2, ...)
{
  return [a1 andsCount];
}

id objc_msgSend_anonymousListener(void *a1, const char *a2, ...)
{
  return [a1 anonymousListener];
}

id objc_msgSend_apnsPushes(void *a1, const char *a2, ...)
{
  return [a1 apnsPushes];
}

id objc_msgSend_appleAccountID(void *a1, const char *a2, ...)
{
  return [a1 appleAccountID];
}

id objc_msgSend_appleAccountSignOutOperation(void *a1, const char *a2, ...)
{
  return [a1 appleAccountSignOutOperation];
}

id objc_msgSend_applicationLabel(void *a1, const char *a2, ...)
{
  return [a1 applicationLabel];
}

id objc_msgSend_applicationTag(void *a1, const char *a2, ...)
{
  return [a1 applicationTag];
}

id objc_msgSend_apsConnectionClass(void *a1, const char *a2, ...)
{
  return [a1 apsConnectionClass];
}

id objc_msgSend_apsDeliveryQueue(void *a1, const char *a2, ...)
{
  return [a1 apsDeliveryQueue];
}

id objc_msgSend_apsRateLimiter(void *a1, const char *a2, ...)
{
  return [a1 apsRateLimiter];
}

id objc_msgSend_apsReceiver(void *a1, const char *a2, ...)
{
  return [a1 apsReceiver];
}

id objc_msgSend_armReadyNotification(void *a1, const char *a2, ...)
{
  return [a1 armReadyNotification];
}

id objc_msgSend_array(void *a1, const char *a2, ...)
{
  return [a1 array];
}

id objc_msgSend_asBOOL(void *a1, const char *a2, ...)
{
  return [a1 asBOOL];
}

id objc_msgSend_asBase64DecodedData(void *a1, const char *a2, ...)
{
  return [a1 asBase64DecodedData];
}

id objc_msgSend_asISO8601Date(void *a1, const char *a2, ...)
{
  return [a1 asISO8601Date];
}

id objc_msgSend_asNSInteger(void *a1, const char *a2, ...)
{
  return [a1 asNSInteger];
}

id objc_msgSend_asNSNumberInteger(void *a1, const char *a2, ...)
{
  return [a1 asNSNumberInteger];
}

id objc_msgSend_asPathStep(void *a1, const char *a2, ...)
{
  return [a1 asPathStep];
}

id objc_msgSend_asString(void *a1, const char *a2, ...)
{
  return [a1 asString];
}

id objc_msgSend_assetType(void *a1, const char *a2, ...)
{
  return [a1 assetType];
}

id objc_msgSend_attemptedJoin(void *a1, const char *a2, ...)
{
  return [a1 attemptedJoin];
}

id objc_msgSend_attributes(void *a1, const char *a2, ...)
{
  return [a1 attributes];
}

id objc_msgSend_auditToken(void *a1, const char *a2, ...)
{
  return [a1 auditToken];
}

id objc_msgSend_authKitAdapter(void *a1, const char *a2, ...)
{
  return [a1 authKitAdapter];
}

id objc_msgSend_authenticationType(void *a1, const char *a2, ...)
{
  return [a1 authenticationType];
}

id objc_msgSend_backoff(void *a1, const char *a2, ...)
{
  return [a1 backoff];
}

id objc_msgSend_base64Item(void *a1, const char *a2, ...)
{
  return [a1 base64Item];
}

id objc_msgSend_base64WrappedKey(void *a1, const char *a2, ...)
{
  return [a1 base64WrappedKey];
}

id objc_msgSend_becomeInheritedOperation(void *a1, const char *a2, ...)
{
  return [a1 becomeInheritedOperation];
}

id objc_msgSend_becomeReadyOperation(void *a1, const char *a2, ...)
{
  return [a1 becomeReadyOperation];
}

id objc_msgSend_beginCloudKitOperation(void *a1, const char *a2, ...)
{
  return [a1 beginCloudKitOperation];
}

id objc_msgSend_BOOLValue(void *a1, const char *a2, ...)
{
  return [a1 BOOLValue];
}

id objc_msgSend_bottleID(void *a1, const char *a2, ...)
{
  return [a1 bottleID];
}

id objc_msgSend_bottleId(void *a1, const char *a2, ...)
{
  return [a1 bottleId];
}

id objc_msgSend_bottleSalt(void *a1, const char *a2, ...)
{
  return [a1 bottleSalt];
}

id objc_msgSend_buckets(void *a1, const char *a2, ...)
{
  return [a1 buckets];
}

id objc_msgSend_buildVersion(void *a1, const char *a2, ...)
{
  return [a1 buildVersion];
}

id objc_msgSend_bytes(void *a1, const char *a2, ...)
{
  return [a1 bytes];
}

id objc_msgSend_c2MetricsEndpoint(void *a1, const char *a2, ...)
{
  return [a1 c2MetricsEndpoint];
}

id objc_msgSend_cachedFeatureAllowed(void *a1, const char *a2, ...)
{
  return [a1 cachedFeatureAllowed];
}

id objc_msgSend_cachedOctagonEncryptionKey(void *a1, const char *a2, ...)
{
  return [a1 cachedOctagonEncryptionKey];
}

id objc_msgSend_cachedOctagonSigningKey(void *a1, const char *a2, ...)
{
  return [a1 cachedOctagonSigningKey];
}

id objc_msgSend_cachingEnabled(void *a1, const char *a2, ...)
{
  return [a1 cachingEnabled];
}

id objc_msgSend_cancel(void *a1, const char *a2, ...)
{
  return [a1 cancel];
}

id objc_msgSend_cancelAllOperations(void *a1, const char *a2, ...)
{
  return [a1 cancelAllOperations];
}

id objc_msgSend_cancelPendingOperations(void *a1, const char *a2, ...)
{
  return [a1 cancelPendingOperations];
}

id objc_msgSend_cdpCapableiCloudAccountInitialized(void *a1, const char *a2, ...)
{
  return [a1 cdpCapableiCloudAccountInitialized];
}

id objc_msgSend_cdpCapableiCloudAccountStatus(void *a1, const char *a2, ...)
{
  return [a1 cdpCapableiCloudAccountStatus];
}

id objc_msgSend_cdpContextTypes(void *a1, const char *a2, ...)
{
  return [a1 cdpContextTypes];
}

id objc_msgSend_cdpState(void *a1, const char *a2, ...)
{
  return [a1 cdpState];
}

id objc_msgSend_cdpd(void *a1, const char *a2, ...)
{
  return [a1 cdpd];
}

id objc_msgSend_cert(void *a1, const char *a2, ...)
{
  return [a1 cert];
}

id objc_msgSend_certCached(void *a1, const char *a2, ...)
{
  return [a1 certCached];
}

id objc_msgSend_chain(void *a1, const char *a2, ...)
{
  return [a1 chain];
}

id objc_msgSend_changeToken(void *a1, const char *a2, ...)
{
  return [a1 changeToken];
}

id objc_msgSend_changeTokens(void *a1, const char *a2, ...)
{
  return [a1 changeTokens];
}

id objc_msgSend_checkDate(void *a1, const char *a2, ...)
{
  return [a1 checkDate];
}

id objc_msgSend_checkIfPasscodeIsSetForDevice(void *a1, const char *a2, ...)
{
  return [a1 checkIfPasscodeIsSetForDevice];
}

id objc_msgSend_checkMetricsTrigger(void *a1, const char *a2, ...)
{
  return [a1 checkMetricsTrigger];
}

id objc_msgSend_checkReachabilityOperation(void *a1, const char *a2, ...)
{
  return [a1 checkReachabilityOperation];
}

id objc_msgSend_checkUnlockOperation(void *a1, const char *a2, ...)
{
  return [a1 checkUnlockOperation];
}

id objc_msgSend_ciphertext(void *a1, const char *a2, ...)
{
  return [a1 ciphertext];
}

id objc_msgSend_circleName(void *a1, const char *a2, ...)
{
  return [a1 circleName];
}

id objc_msgSend_circlePeerID(void *a1, const char *a2, ...)
{
  return [a1 circlePeerID];
}

id objc_msgSend_circleStatus(void *a1, const char *a2, ...)
{
  return [a1 circleStatus];
}

id objc_msgSend_ckAccountInfoInitialized(void *a1, const char *a2, ...)
{
  return [a1 ckAccountInfoInitialized];
}

id objc_msgSend_ckChangeListeners(void *a1, const char *a2, ...)
{
  return [a1 ckChangeListeners];
}

id objc_msgSend_ckErrorState(void *a1, const char *a2, ...)
{
  return [a1 ckErrorState];
}

id objc_msgSend_ckOperations(void *a1, const char *a2, ...)
{
  return [a1 ckOperations];
}

id objc_msgSend_ckRecordType(void *a1, const char *a2, ...)
{
  return [a1 ckRecordType];
}

id objc_msgSend_ckdatabase(void *a1, const char *a2, ...)
{
  return [a1 ckdatabase];
}

id objc_msgSend_ckdeviceID(void *a1, const char *a2, ...)
{
  return [a1 ckdeviceID];
}

id objc_msgSend_ckdeviceIDError(void *a1, const char *a2, ...)
{
  return [a1 ckdeviceIDError];
}

id objc_msgSend_ckdeviceIDInitialized(void *a1, const char *a2, ...)
{
  return [a1 ckdeviceIDInitialized];
}

id objc_msgSend_ckks(void *a1, const char *a2, ...)
{
  return [a1 ckks];
}

id objc_msgSend_ckksConflictState(void *a1, const char *a2, ...)
{
  return [a1 ckksConflictState];
}

id objc_msgSend_ckksManagedView(void *a1, const char *a2, ...)
{
  return [a1 ckksManagedView];
}

id objc_msgSend_ckksPushReceivedDate(void *a1, const char *a2, ...)
{
  return [a1 ckksPushReceivedDate];
}

id objc_msgSend_ckksPushTracingEnabled(void *a1, const char *a2, ...)
{
  return [a1 ckksPushTracingEnabled];
}

id objc_msgSend_ckksPushTracingUUID(void *a1, const char *a2, ...)
{
  return [a1 ckksPushTracingUUID];
}

id objc_msgSend_ckoperationGroup(void *a1, const char *a2, ...)
{
  return [a1 ckoperationGroup];
}

id objc_msgSend_ckzone(void *a1, const char *a2, ...)
{
  return [a1 ckzone];
}

id objc_msgSend_ckzonecreated(void *a1, const char *a2, ...)
{
  return [a1 ckzonecreated];
}

id objc_msgSend_ckzonesubscribed(void *a1, const char *a2, ...)
{
  return [a1 ckzonesubscribed];
}

id objc_msgSend_claimTokenData(void *a1, const char *a2, ...)
{
  return [a1 claimTokenData];
}

id objc_msgSend_classA(void *a1, const char *a2, ...)
{
  return [a1 classA];
}

id objc_msgSend_classC(void *a1, const char *a2, ...)
{
  return [a1 classC];
}

id objc_msgSend_clearClientOperations(void *a1, const char *a2, ...)
{
  return [a1 clearClientOperations];
}

id objc_msgSend_clearContextState(void *a1, const char *a2, ...)
{
  return [a1 clearContextState];
}

id objc_msgSend_clearInternalTestConfigs(void *a1, const char *a2, ...)
{
  return [a1 clearInternalTestConfigs];
}

id objc_msgSend_clearMetrics(void *a1, const char *a2, ...)
{
  return [a1 clearMetrics];
}

id objc_msgSend_clearOperationGroups(void *a1, const char *a2, ...)
{
  return [a1 clearOperationGroups];
}

id objc_msgSend_clearPairingUUID(void *a1, const char *a2, ...)
{
  return [a1 clearPairingUUID];
}

id objc_msgSend_clearPendingBackupPeers(void *a1, const char *a2, ...)
{
  return [a1 clearPendingBackupPeers];
}

id objc_msgSend_clearStalePushNotifications(void *a1, const char *a2, ...)
{
  return [a1 clearStalePushNotifications];
}

id objc_msgSend_clearTlkSharesForVouchedIdentitys(void *a1, const char *a2, ...)
{
  return [a1 clearTlkSharesForVouchedIdentitys];
}

id objc_msgSend_clientConnections(void *a1, const char *a2, ...)
{
  return [a1 clientConnections];
}

id objc_msgSend_clientDefined0(void *a1, const char *a2, ...)
{
  return [a1 clientDefined0];
}

id objc_msgSend_clientDefined1(void *a1, const char *a2, ...)
{
  return [a1 clientDefined1];
}

id objc_msgSend_clientDefined2(void *a1, const char *a2, ...)
{
  return [a1 clientDefined2];
}

id objc_msgSend_clientDefined3(void *a1, const char *a2, ...)
{
  return [a1 clientDefined3];
}

id objc_msgSend_clientMap(void *a1, const char *a2, ...)
{
  return [a1 clientMap];
}

id objc_msgSend_clientOperationsCount(void *a1, const char *a2, ...)
{
  return [a1 clientOperationsCount];
}

id objc_msgSend_cloudKitAccountInfo(void *a1, const char *a2, ...)
{
  return [a1 cloudKitAccountInfo];
}

id objc_msgSend_cloudKitAccountStateKnown(void *a1, const char *a2, ...)
{
  return [a1 cloudKitAccountStateKnown];
}

id objc_msgSend_cloudKitClassDependencies(void *a1, const char *a2, ...)
{
  return [a1 cloudKitClassDependencies];
}

id objc_msgSend_cloudKitContainer(void *a1, const char *a2, ...)
{
  return [a1 cloudKitContainer];
}

id objc_msgSend_cloudKitRecord(void *a1, const char *a2, ...)
{
  return [a1 cloudKitRecord];
}

id objc_msgSend_cloudkitContainerName(void *a1, const char *a2, ...)
{
  return [a1 cloudkitContainerName];
}

id objc_msgSend_cloudkitRetryAfter(void *a1, const char *a2, ...)
{
  return [a1 cloudkitRetryAfter];
}

id objc_msgSend_cloudkitWriteFailures(void *a1, const char *a2, ...)
{
  return [a1 cloudkitWriteFailures];
}

id objc_msgSend_code(void *a1, const char *a2, ...)
{
  return [a1 code];
}

id objc_msgSend_coder(void *a1, const char *a2, ...)
{
  return [a1 coder];
}

id objc_msgSend_collectableEscrowRecords(void *a1, const char *a2, ...)
{
  return [a1 collectableEscrowRecords];
}

id objc_msgSend_collectableTlkShares(void *a1, const char *a2, ...)
{
  return [a1 collectableTlkShares];
}

id objc_msgSend_collectedEscrowRecords(void *a1, const char *a2, ...)
{
  return [a1 collectedEscrowRecords];
}

id objc_msgSend_collectedTlkShares(void *a1, const char *a2, ...)
{
  return [a1 collectedTlkShares];
}

id objc_msgSend_columnCount(void *a1, const char *a2, ...)
{
  return [a1 columnCount];
}

id objc_msgSend_columnName(void *a1, const char *a2, ...)
{
  return [a1 columnName];
}

id objc_msgSend_comment(void *a1, const char *a2, ...)
{
  return [a1 comment];
}

id objc_msgSend_commit(void *a1, const char *a2, ...)
{
  return [a1 commit];
}

id objc_msgSend_completeOperation(void *a1, const char *a2, ...)
{
  return [a1 completeOperation];
}

id objc_msgSend_completed(void *a1, const char *a2, ...)
{
  return [a1 completed];
}

id objc_msgSend_completedSecCKKSInitialize(void *a1, const char *a2, ...)
{
  return [a1 completedSecCKKSInitialize];
}

id objc_msgSend_completionHandlerDidRunCondition(void *a1, const char *a2, ...)
{
  return [a1 completionHandlerDidRunCondition];
}

id objc_msgSend_conditionChecksInFlight(void *a1, const char *a2, ...)
{
  return [a1 conditionChecksInFlight];
}

id objc_msgSend_conditions(void *a1, const char *a2, ...)
{
  return [a1 conditions];
}

id objc_msgSend_config(void *a1, const char *a2, ...)
{
  return [a1 config];
}

id objc_msgSend_configuration(void *a1, const char *a2, ...)
{
  return [a1 configuration];
}

id objc_msgSend_confirmed(void *a1, const char *a2, ...)
{
  return [a1 confirmed];
}

id objc_msgSend_connection(void *a1, const char *a2, ...)
{
  return [a1 connection];
}

id objc_msgSend_connectionQueue(void *a1, const char *a2, ...)
{
  return [a1 connectionQueue];
}

id objc_msgSend_consolidateKeyInterest(void *a1, const char *a2, ...)
{
  return [a1 consolidateKeyInterest];
}

id objc_msgSend_container(void *a1, const char *a2, ...)
{
  return [a1 container];
}

id objc_msgSend_containerIdentifier(void *a1, const char *a2, ...)
{
  return [a1 containerIdentifier];
}

id objc_msgSend_containerName(void *a1, const char *a2, ...)
{
  return [a1 containerName];
}

id objc_msgSend_contents(void *a1, const char *a2, ...)
{
  return [a1 contents];
}

id objc_msgSend_contentsAsString(void *a1, const char *a2, ...)
{
  return [a1 contentsAsString];
}

id objc_msgSend_contextForConfirmExistingSecret(void *a1, const char *a2, ...)
{
  return [a1 contextForConfirmExistingSecret];
}

id objc_msgSend_contextForPrimaryAccount(void *a1, const char *a2, ...)
{
  return [a1 contextForPrimaryAccount];
}

id objc_msgSend_contextForRecoveryKeyRepair(void *a1, const char *a2, ...)
{
  return [a1 contextForRecoveryKeyRepair];
}

id objc_msgSend_contextForSecureTerms(void *a1, const char *a2, ...)
{
  return [a1 contextForSecureTerms];
}

id objc_msgSend_contextForStateRepair(void *a1, const char *a2, ...)
{
  return [a1 contextForStateRepair];
}

id objc_msgSend_contextID(void *a1, const char *a2, ...)
{
  return [a1 contextID];
}

id objc_msgSend_contexts(void *a1, const char *a2, ...)
{
  return [a1 contexts];
}

id objc_msgSend_controller(void *a1, const char *a2, ...)
{
  return [a1 controller];
}

id objc_msgSend_copy(void *a1, const char *a2, ...)
{
  return [a1 copy];
}

id objc_msgSend_count(void *a1, const char *a2, ...)
{
  return [a1 count];
}

id objc_msgSend_createSuccessfulFetchDependency(void *a1, const char *a2, ...)
{
  return [a1 createSuccessfulFetchDependency];
}

id objc_msgSend_creationDate(void *a1, const char *a2, ...)
{
  return [a1 creationDate];
}

id objc_msgSend_crk(void *a1, const char *a2, ...)
{
  return [a1 crk];
}

id objc_msgSend_currentCKAccountInfo(void *a1, const char *a2, ...)
{
  return [a1 currentCKAccountInfo];
}

id objc_msgSend_currentCalendar(void *a1, const char *a2, ...)
{
  return [a1 currentCalendar];
}

id objc_msgSend_currentCircleStatus(void *a1, const char *a2, ...)
{
  return [a1 currentCircleStatus];
}

id objc_msgSend_currentClassAPointer(void *a1, const char *a2, ...)
{
  return [a1 currentClassAPointer];
}

id objc_msgSend_currentClassAUUID(void *a1, const char *a2, ...)
{
  return [a1 currentClassAUUID];
}

id objc_msgSend_currentClassCPointer(void *a1, const char *a2, ...)
{
  return [a1 currentClassCPointer];
}

id objc_msgSend_currentClassCUUID(void *a1, const char *a2, ...)
{
  return [a1 currentClassCUUID];
}

id objc_msgSend_currentConditions(void *a1, const char *a2, ...)
{
  return [a1 currentConditions];
}

id objc_msgSend_currentDelay(void *a1, const char *a2, ...)
{
  return [a1 currentDelay];
}

id objc_msgSend_currentFetch(void *a1, const char *a2, ...)
{
  return [a1 currentFetch];
}

id objc_msgSend_currentFetchReasons(void *a1, const char *a2, ...)
{
  return [a1 currentFetchReasons];
}

id objc_msgSend_currentFlags(void *a1, const char *a2, ...)
{
  return [a1 currentFlags];
}

id objc_msgSend_currentHandler(void *a1, const char *a2, ...)
{
  return [a1 currentHandler];
}

id objc_msgSend_currentItemUUID(void *a1, const char *a2, ...)
{
  return [a1 currentItemUUID];
}

id objc_msgSend_currentKeyUUID(void *a1, const char *a2, ...)
{
  return [a1 currentKeyUUID];
}

id objc_msgSend_currentMemoizedLastHealthCheck(void *a1, const char *a2, ...)
{
  return [a1 currentMemoizedLastHealthCheck];
}

id objc_msgSend_currentOutgoingQueueOperationGroup(void *a1, const char *a2, ...)
{
  return [a1 currentOutgoingQueueOperationGroup];
}

id objc_msgSend_currentPersona(void *a1, const char *a2, ...)
{
  return [a1 currentPersona];
}

id objc_msgSend_currentPointerIdentifier(void *a1, const char *a2, ...)
{
  return [a1 currentPointerIdentifier];
}

id objc_msgSend_currentProcessResult(void *a1, const char *a2, ...)
{
  return [a1 currentProcessResult];
}

id objc_msgSend_currentReachability(void *a1, const char *a2, ...)
{
  return [a1 currentReachability];
}

id objc_msgSend_currentSelf(void *a1, const char *a2, ...)
{
  return [a1 currentSelf];
}

id objc_msgSend_currentSelfPeers(void *a1, const char *a2, ...)
{
  return [a1 currentSelfPeers];
}

id objc_msgSend_currentSelfPeersError(void *a1, const char *a2, ...)
{
  return [a1 currentSelfPeersError];
}

id objc_msgSend_currentState(void *a1, const char *a2, ...)
{
  return [a1 currentState];
}

id objc_msgSend_currentTLKPointer(void *a1, const char *a2, ...)
{
  return [a1 currentTLKPointer];
}

id objc_msgSend_currentTLKUUID(void *a1, const char *a2, ...)
{
  return [a1 currentTLKUUID];
}

id objc_msgSend_currentThreadIsForPrimaryiCloudAccount(void *a1, const char *a2, ...)
{
  return [a1 currentThreadIsForPrimaryiCloudAccount];
}

id objc_msgSend_currentThreadPersonaUniqueString(void *a1, const char *a2, ...)
{
  return [a1 currentThreadPersonaUniqueString];
}

id objc_msgSend_currentTrustBitmask(void *a1, const char *a2, ...)
{
  return [a1 currentTrustBitmask];
}

id objc_msgSend_currentTrustStates(void *a1, const char *a2, ...)
{
  return [a1 currentTrustStates];
}

id objc_msgSend_currentTrustedPeerIDs(void *a1, const char *a2, ...)
{
  return [a1 currentTrustedPeerIDs];
}

id objc_msgSend_currentTrustedPeers(void *a1, const char *a2, ...)
{
  return [a1 currentTrustedPeers];
}

id objc_msgSend_currentTrustedPeersError(void *a1, const char *a2, ...)
{
  return [a1 currentTrustedPeersError];
}

id objc_msgSend_currentUserMetadata(void *a1, const char *a2, ...)
{
  return [a1 currentUserMetadata];
}

id objc_msgSend_currentUserMetadataFeatureUsage(void *a1, const char *a2, ...)
{
  return [a1 currentUserMetadataFeatureUsage];
}

id objc_msgSend_currentUserParticipant(void *a1, const char *a2, ...)
{
  return [a1 currentUserParticipant];
}

id objc_msgSend_currentkey(void *a1, const char *a2, ...)
{
  return [a1 currentkey];
}

id objc_msgSend_cursor(void *a1, const char *a2, ...)
{
  return [a1 cursor];
}

id objc_msgSend_curve(void *a1, const char *a2, ...)
{
  return [a1 curve];
}

id objc_msgSend_custodianRecoveryKey(void *a1, const char *a2, ...)
{
  return [a1 custodianRecoveryKey];
}

id objc_msgSend_cuttlefishAdapter(void *a1, const char *a2, ...)
{
  return [a1 cuttlefishAdapter];
}

id objc_msgSend_cuttlefishPushTopics(void *a1, const char *a2, ...)
{
  return [a1 cuttlefishPushTopics];
}

id objc_msgSend_cuttlefishRetryAfter(void *a1, const char *a2, ...)
{
  return [a1 cuttlefishRetryAfter];
}

id objc_msgSend_cuttlefishTrustEvaluation(void *a1, const char *a2, ...)
{
  return [a1 cuttlefishTrustEvaluation];
}

id objc_msgSend_cuttlefishXPCConnection(void *a1, const char *a2, ...)
{
  return [a1 cuttlefishXPCConnection];
}

id objc_msgSend_cuttlefishXPCWrapper(void *a1, const char *a2, ...)
{
  return [a1 cuttlefishXPCWrapper];
}

id objc_msgSend_data(void *a1, const char *a2, ...)
{
  return [a1 data];
}

id objc_msgSend_database(void *a1, const char *a2, ...)
{
  return [a1 database];
}

id objc_msgSend_databaseItemClass(void *a1, const char *a2, ...)
{
  return [a1 databaseItemClass];
}

id objc_msgSend_databaseProvider(void *a1, const char *a2, ...)
{
  return [a1 databaseProvider];
}

id objc_msgSend_databaseScope(void *a1, const char *a2, ...)
{
  return [a1 databaseScope];
}

id objc_msgSend_date(void *a1, const char *a2, ...)
{
  return [a1 date];
}

id objc_msgSend_decryptionOperation(void *a1, const char *a2, ...)
{
  return [a1 decryptionOperation];
}

id objc_msgSend_defaultCenter(void *a1, const char *a2, ...)
{
  return [a1 defaultCenter];
}

id objc_msgSend_defaultOverCommitManager(void *a1, const char *a2, ...)
{
  return [a1 defaultOverCommitManager];
}

id objc_msgSend_defaultStore(void *a1, const char *a2, ...)
{
  return [a1 defaultStore];
}

id objc_msgSend_defaultViewError(void *a1, const char *a2, ...)
{
  return [a1 defaultViewError];
}

id objc_msgSend_deletedDeviceHash(void *a1, const char *a2, ...)
{
  return [a1 deletedDeviceHash];
}

id objc_msgSend_deletedDeviceList(void *a1, const char *a2, ...)
{
  return [a1 deletedDeviceList];
}

id objc_msgSend_deletions(void *a1, const char *a2, ...)
{
  return [a1 deletions];
}

id objc_msgSend_departureCode(void *a1, const char *a2, ...)
{
  return [a1 departureCode];
}

id objc_msgSend_dependencies(void *a1, const char *a2, ...)
{
  return [a1 dependencies];
}

id objc_msgSend_dependenciesDescriptionError(void *a1, const char *a2, ...)
{
  return [a1 dependenciesDescriptionError];
}

id objc_msgSend_deps(void *a1, const char *a2, ...)
{
  return [a1 deps];
}

id objc_msgSend_description(void *a1, const char *a2, ...)
{
  return [a1 description];
}

id objc_msgSend_descriptionError(void *a1, const char *a2, ...)
{
  return [a1 descriptionError];
}

id objc_msgSend_descriptionErrorCode(void *a1, const char *a2, ...)
{
  return [a1 descriptionErrorCode];
}

id objc_msgSend_descriptionUnderlyingError(void *a1, const char *a2, ...)
{
  return [a1 descriptionUnderlyingError];
}

id objc_msgSend_desiredTimeout(void *a1, const char *a2, ...)
{
  return [a1 desiredTimeout];
}

id objc_msgSend_determineCDPState(void *a1, const char *a2, ...)
{
  return [a1 determineCDPState];
}

id objc_msgSend_device(void *a1, const char *a2, ...)
{
  return [a1 device];
}

id objc_msgSend_deviceAdapter(void *a1, const char *a2, ...)
{
  return [a1 deviceAdapter];
}

id objc_msgSend_deviceDidLock(void *a1, const char *a2, ...)
{
  return [a1 deviceDidLock];
}

id objc_msgSend_deviceInfo(void *a1, const char *a2, ...)
{
  return [a1 deviceInfo];
}

id objc_msgSend_deviceInformationAdapter(void *a1, const char *a2, ...)
{
  return [a1 deviceInformationAdapter];
}

id objc_msgSend_deviceList(void *a1, const char *a2, ...)
{
  return [a1 deviceList];
}

id objc_msgSend_deviceListVersion(void *a1, const char *a2, ...)
{
  return [a1 deviceListVersion];
}

id objc_msgSend_deviceName(void *a1, const char *a2, ...)
{
  return [a1 deviceName];
}

id objc_msgSend_deviceNameUpdateListeners(void *a1, const char *a2, ...)
{
  return [a1 deviceNameUpdateListeners];
}

id objc_msgSend_deviceSessionID(void *a1, const char *a2, ...)
{
  return [a1 deviceSessionID];
}

id objc_msgSend_diagnostics(void *a1, const char *a2, ...)
{
  return [a1 diagnostics];
}

id objc_msgSend_dictionary(void *a1, const char *a2, ...)
{
  return [a1 dictionary];
}

id objc_msgSend_dictionaryRepresentation(void *a1, const char *a2, ...)
{
  return [a1 dictionaryRepresentation];
}

id objc_msgSend_disablePendingFlags(void *a1, const char *a2, ...)
{
  return [a1 disablePendingFlags];
}

id objc_msgSend_displayName(void *a1, const char *a2, ...)
{
  return [a1 displayName];
}

id objc_msgSend_distantPast(void *a1, const char *a2, ...)
{
  return [a1 distantPast];
}

id objc_msgSend_domain(void *a1, const char *a2, ...)
{
  return [a1 domain];
}

id objc_msgSend_domainHost(void *a1, const char *a2, ...)
{
  return [a1 domainHost];
}

id objc_msgSend_domainPort(void *a1, const char *a2, ...)
{
  return [a1 domainPort];
}

id objc_msgSend_doubleValue(void *a1, const char *a2, ...)
{
  return [a1 doubleValue];
}

id objc_msgSend_dropAllActors(void *a1, const char *a2, ...)
{
  return [a1 dropAllActors];
}

id objc_msgSend_dropAllKeys(void *a1, const char *a2, ...)
{
  return [a1 dropAllKeys];
}

id objc_msgSend_dumpFlags(void *a1, const char *a2, ...)
{
  return [a1 dumpFlags];
}

id objc_msgSend_dumpPendingFlags(void *a1, const char *a2, ...)
{
  return [a1 dumpPendingFlags];
}

id objc_msgSend_earliestFetchTime(void *a1, const char *a2, ...)
{
  return [a1 earliestFetchTime];
}

id objc_msgSend_effectiveKeySize(void *a1, const char *a2, ...)
{
  return [a1 effectiveKeySize];
}

id objc_msgSend_effectiveUserIdentifier(void *a1, const char *a2, ...)
{
  return [a1 effectiveUserIdentifier];
}

id objc_msgSend_egoPeerID(void *a1, const char *a2, ...)
{
  return [a1 egoPeerID];
}

id objc_msgSend_egoPeerMachineID(void *a1, const char *a2, ...)
{
  return [a1 egoPeerMachineID];
}

id objc_msgSend_egoStatus(void *a1, const char *a2, ...)
{
  return [a1 egoStatus];
}

id objc_msgSend_emailAddress(void *a1, const char *a2, ...)
{
  return [a1 emailAddress];
}

id objc_msgSend_enabled(void *a1, const char *a2, ...)
{
  return [a1 enabled];
}

id objc_msgSend_encitem(void *a1, const char *a2, ...)
{
  return [a1 encitem];
}

id objc_msgSend_encodeSubjectPublicKeyInfo(void *a1, const char *a2, ...)
{
  return [a1 encodeSubjectPublicKeyInfo];
}

id objc_msgSend_encodedCKRecord(void *a1, const char *a2, ...)
{
  return [a1 encodedCKRecord];
}

id objc_msgSend_encodedChangeToken(void *a1, const char *a2, ...)
{
  return [a1 encodedChangeToken];
}

id objc_msgSend_encodedData(void *a1, const char *a2, ...)
{
  return [a1 encodedData];
}

id objc_msgSend_encodedRateLimiter(void *a1, const char *a2, ...)
{
  return [a1 encodedRateLimiter];
}

id objc_msgSend_encryptedMetadata(void *a1, const char *a2, ...)
{
  return [a1 encryptedMetadata];
}

id objc_msgSend_encryptedMetadataBlob(void *a1, const char *a2, ...)
{
  return [a1 encryptedMetadataBlob];
}

id objc_msgSend_encryptedSecretData(void *a1, const char *a2, ...)
{
  return [a1 encryptedSecretData];
}

id objc_msgSend_encryptedSecretDataBlob(void *a1, const char *a2, ...)
{
  return [a1 encryptedSecretDataBlob];
}

id objc_msgSend_encryptedValues(void *a1, const char *a2, ...)
{
  return [a1 encryptedValues];
}

id objc_msgSend_encryptionIdentity(void *a1, const char *a2, ...)
{
  return [a1 encryptionIdentity];
}

id objc_msgSend_encryptionKey(void *a1, const char *a2, ...)
{
  return [a1 encryptionKey];
}

id objc_msgSend_encryptionOperation(void *a1, const char *a2, ...)
{
  return [a1 encryptionOperation];
}

id objc_msgSend_encryptionSPKI(void *a1, const char *a2, ...)
{
  return [a1 encryptionSPKI];
}

id objc_msgSend_encver(void *a1, const char *a2, ...)
{
  return [a1 encver];
}

id objc_msgSend_endTrustedOperation(void *a1, const char *a2, ...)
{
  return [a1 endTrustedOperation];
}

id objc_msgSend_endpoint(void *a1, const char *a2, ...)
{
  return [a1 endpoint];
}

id objc_msgSend_enforceRateLimiting(void *a1, const char *a2, ...)
{
  return [a1 enforceRateLimiting];
}

id objc_msgSend_engine(void *a1, const char *a2, ...)
{
  return [a1 engine];
}

id objc_msgSend_ensureFactoryCircles(void *a1, const char *a2, ...)
{
  return [a1 ensureFactoryCircles];
}

id objc_msgSend_ensureOctagonPeerKeys(void *a1, const char *a2, ...)
{
  return [a1 ensureOctagonPeerKeys];
}

id objc_msgSend_ensureRampsInitialized(void *a1, const char *a2, ...)
{
  return [a1 ensureRampsInitialized];
}

id objc_msgSend_entitlementBearer(void *a1, const char *a2, ...)
{
  return [a1 entitlementBearer];
}

id objc_msgSend_entropy(void *a1, const char *a2, ...)
{
  return [a1 entropy];
}

id objc_msgSend_entryAccessGroup(void *a1, const char *a2, ...)
{
  return [a1 entryAccessGroup];
}

id objc_msgSend_entrySchemaVersion(void *a1, const char *a2, ...)
{
  return [a1 entrySchemaVersion];
}

id objc_msgSend_environmentMap(void *a1, const char *a2, ...)
{
  return [a1 environmentMap];
}

id objc_msgSend_ephemeralSessionConfiguration(void *a1, const char *a2, ...)
{
  return [a1 ephemeralSessionConfiguration];
}

id objc_msgSend_epoch(void *a1, const char *a2, ...)
{
  return [a1 epoch];
}

id objc_msgSend_error(void *a1, const char *a2, ...)
{
  return [a1 error];
}

id objc_msgSend_errorItemsProcessed(void *a1, const char *a2, ...)
{
  return [a1 errorItemsProcessed];
}

id objc_msgSend_escrowInformationMetadata(void *a1, const char *a2, ...)
{
  return [a1 escrowInformationMetadata];
}

id objc_msgSend_escrowRecordGarbageCollectionEnabled(void *a1, const char *a2, ...)
{
  return [a1 escrowRecordGarbageCollectionEnabled];
}

id objc_msgSend_escrowRequestClass(void *a1, const char *a2, ...)
{
  return [a1 escrowRequestClass];
}

id objc_msgSend_essential(void *a1, const char *a2, ...)
{
  return [a1 essential];
}

id objc_msgSend_establishStatePathDictionary(void *a1, const char *a2, ...)
{
  return [a1 establishStatePathDictionary];
}

id objc_msgSend_evaluateSecdOctagonTrust(void *a1, const char *a2, ...)
{
  return [a1 evaluateSecdOctagonTrust];
}

id objc_msgSend_evaluateTPHOctagonTrust(void *a1, const char *a2, ...)
{
  return [a1 evaluateTPHOctagonTrust];
}

id objc_msgSend_eventName(void *a1, const char *a2, ...)
{
  return [a1 eventName];
}

id objc_msgSend_eventS(void *a1, const char *a2, ...)
{
  return [a1 eventS];
}

id objc_msgSend_eventsByTime(void *a1, const char *a2, ...)
{
  return [a1 eventsByTime];
}

id objc_msgSend_expansion(void *a1, const char *a2, ...)
{
  return [a1 expansion];
}

id objc_msgSend_exportedInterface(void *a1, const char *a2, ...)
{
  return [a1 exportedInterface];
}

id objc_msgSend_factory(void *a1, const char *a2, ...)
{
  return [a1 factory];
}

id objc_msgSend_failStates(void *a1, const char *a2, ...)
{
  return [a1 failStates];
}

id objc_msgSend_failedDueToEssentialTrustState(void *a1, const char *a2, ...)
{
  return [a1 failedDueToEssentialTrustState];
}

id objc_msgSend_failedDueToLockState(void *a1, const char *a2, ...)
{
  return [a1 failedDueToLockState];
}

id objc_msgSend_fakeEntitlements(void *a1, const char *a2, ...)
{
  return [a1 fakeEntitlements];
}

id objc_msgSend_fetchAllRecordZonesOperation(void *a1, const char *a2, ...)
{
  return [a1 fetchAllRecordZonesOperation];
}

id objc_msgSend_fetchBeforeGettingKeyset(void *a1, const char *a2, ...)
{
  return [a1 fetchBeforeGettingKeyset];
}

id objc_msgSend_fetchBehavior(void *a1, const char *a2, ...)
{
  return [a1 fetchBehavior];
}

id objc_msgSend_fetchCKAccountStatusScheduler(void *a1, const char *a2, ...)
{
  return [a1 fetchCKAccountStatusScheduler];
}

id objc_msgSend_fetchCompletedOperation(void *a1, const char *a2, ...)
{
  return [a1 fetchCompletedOperation];
}

id objc_msgSend_fetchReasons(void *a1, const char *a2, ...)
{
  return [a1 fetchReasons];
}

id objc_msgSend_fetchRecordRecordsOperationClass(void *a1, const char *a2, ...)
{
  return [a1 fetchRecordRecordsOperationClass];
}

id objc_msgSend_fetchRecordZoneChangesOperation(void *a1, const char *a2, ...)
{
  return [a1 fetchRecordZoneChangesOperation];
}

id objc_msgSend_fetchRecordZoneChangesOperationClass(void *a1, const char *a2, ...)
{
  return [a1 fetchRecordZoneChangesOperationClass];
}

id objc_msgSend_fetchRecordsOperation(void *a1, const char *a2, ...)
{
  return [a1 fetchRecordsOperation];
}

id objc_msgSend_fetchRecordsOperationClass(void *a1, const char *a2, ...)
{
  return [a1 fetchRecordsOperationClass];
}

id objc_msgSend_fetchScheduler(void *a1, const char *a2, ...)
{
  return [a1 fetchScheduler];
}

id objc_msgSend_fetchedItems(void *a1, const char *a2, ...)
{
  return [a1 fetchedItems];
}

id objc_msgSend_fetchedZoneIDs(void *a1, const char *a2, ...)
{
  return [a1 fetchedZoneIDs];
}

id objc_msgSend_fieldName(void *a1, const char *a2, ...)
{
  return [a1 fieldName];
}

id objc_msgSend_fillInError(void *a1, const char *a2, ...)
{
  return [a1 fillInError];
}

id objc_msgSend_finish(void *a1, const char *a2, ...)
{
  return [a1 finish];
}

id objc_msgSend_finishDate(void *a1, const char *a2, ...)
{
  return [a1 finishDate];
}

id objc_msgSend_finishDecoding(void *a1, const char *a2, ...)
{
  return [a1 finishDecoding];
}

id objc_msgSend_finishOp(void *a1, const char *a2, ...)
{
  return [a1 finishOp];
}

id objc_msgSend_finishOperation(void *a1, const char *a2, ...)
{
  return [a1 finishOperation];
}

id objc_msgSend_finishedInitialDispatches(void *a1, const char *a2, ...)
{
  return [a1 finishedInitialDispatches];
}

id objc_msgSend_finishedOp(void *a1, const char *a2, ...)
{
  return [a1 finishedOp];
}

id objc_msgSend_finishingBlock(void *a1, const char *a2, ...)
{
  return [a1 finishingBlock];
}

id objc_msgSend_fireTime(void *a1, const char *a2, ...)
{
  return [a1 fireTime];
}

id objc_msgSend_firstCKAccountFetch(void *a1, const char *a2, ...)
{
  return [a1 firstCKAccountFetch];
}

id objc_msgSend_firstManateeKeyFetched(void *a1, const char *a2, ...)
{
  return [a1 firstManateeKeyFetched];
}

id objc_msgSend_firstObject(void *a1, const char *a2, ...)
{
  return [a1 firstObject];
}

id objc_msgSend_fixupNumber(void *a1, const char *a2, ...)
{
  return [a1 fixupNumber];
}

id objc_msgSend_flag(void *a1, const char *a2, ...)
{
  return [a1 flag];
}

id objc_msgSend_flagConditions(void *a1, const char *a2, ...)
{
  return [a1 flagConditions];
}

id objc_msgSend_flagHandler(void *a1, const char *a2, ...)
{
  return [a1 flagHandler];
}

id objc_msgSend_flags(void *a1, const char *a2, ...)
{
  return [a1 flags];
}

id objc_msgSend_flattenToSaveBlock(void *a1, const char *a2, ...)
{
  return [a1 flattenToSaveBlock];
}

id objc_msgSend_flowID(void *a1, const char *a2, ...)
{
  return [a1 flowID];
}

id objc_msgSend_followStates(void *a1, const char *a2, ...)
{
  return [a1 followStates];
}

id objc_msgSend_followup(void *a1, const char *a2, ...)
{
  return [a1 followup];
}

id objc_msgSend_followupHandler(void *a1, const char *a2, ...)
{
  return [a1 followupHandler];
}

id objc_msgSend_forLiveCloudKit(void *a1, const char *a2, ...)
{
  return [a1 forLiveCloudKit];
}

id objc_msgSend_forceFetch(void *a1, const char *a2, ...)
{
  return [a1 forceFetch];
}

id objc_msgSend_forceIgnoreCloudServicesRateLimiting(void *a1, const char *a2, ...)
{
  return [a1 forceIgnoreCloudServicesRateLimiting];
}

id objc_msgSend_forceRefetch(void *a1, const char *a2, ...)
{
  return [a1 forceRefetch];
}

id objc_msgSend_forceResync(void *a1, const char *a2, ...)
{
  return [a1 forceResync];
}

id objc_msgSend_forceSyncForRecoveryRing(void *a1, const char *a2, ...)
{
  return [a1 forceSyncForRecoveryRing];
}

id objc_msgSend_fulfill(void *a1, const char *a2, ...)
{
  return [a1 fulfill];
}

id objc_msgSend_fullPeerInfo(void *a1, const char *a2, ...)
{
  return [a1 fullPeerInfo];
}

id objc_msgSend_futureBlock(void *a1, const char *a2, ...)
{
  return [a1 futureBlock];
}

id objc_msgSend_gbAgeRamp(void *a1, const char *a2, ...)
{
  return [a1 gbAgeRamp];
}

id objc_msgSend_gbmidRamp(void *a1, const char *a2, ...)
{
  return [a1 gbmidRamp];
}

id objc_msgSend_gbserialRamp(void *a1, const char *a2, ...)
{
  return [a1 gbserialRamp];
}

id objc_msgSend_generateDeviceInfo(void *a1, const char *a2, ...)
{
  return [a1 generateDeviceInfo];
}

id objc_msgSend_generationCount(void *a1, const char *a2, ...)
{
  return [a1 generationCount];
}

id objc_msgSend_genericEvent(void *a1, const char *a2, ...)
{
  return [a1 genericEvent];
}

id objc_msgSend_gestalt(void *a1, const char *a2, ...)
{
  return [a1 gestalt];
}

id objc_msgSend_getAccount(void *a1, const char *a2, ...)
{
  return [a1 getAccount];
}

id objc_msgSend_getChangeToken(void *a1, const char *a2, ...)
{
  return [a1 getChangeToken];
}

id objc_msgSend_getCircleStatus(void *a1, const char *a2, ...)
{
  return [a1 getCircleStatus];
}

id objc_msgSend_getDate(void *a1, const char *a2, ...)
{
  return [a1 getDate];
}

id objc_msgSend_getLimit(void *a1, const char *a2, ...)
{
  return [a1 getLimit];
}

id objc_msgSend_getOverriddenMachineID(void *a1, const char *a2, ...)
{
  return [a1 getOverriddenMachineID];
}

id objc_msgSend_getTLKSharesPairedWithVoucher(void *a1, const char *a2, ...)
{
  return [a1 getTLKSharesPairedWithVoucher];
}

id objc_msgSend_getTPSyncingPolicy(void *a1, const char *a2, ...)
{
  return [a1 getTPSyncingPolicy];
}

id objc_msgSend_ghostBustCheckDate(void *a1, const char *a2, ...)
{
  return [a1 ghostBustCheckDate];
}

id objc_msgSend_ghostBustFollowup(void *a1, const char *a2, ...)
{
  return [a1 ghostBustFollowup];
}

id objc_msgSend_ghostBustGetDate(void *a1, const char *a2, ...)
{
  return [a1 ghostBustGetDate];
}

id objc_msgSend_ghostBustGetRampSettings(void *a1, const char *a2, ...)
{
  return [a1 ghostBustGetRampSettings];
}

id objc_msgSend_ghostBustSchedule(void *a1, const char *a2, ...)
{
  return [a1 ghostBustSchedule];
}

id objc_msgSend_ghostbustByAgeEnabled(void *a1, const char *a2, ...)
{
  return [a1 ghostbustByAgeEnabled];
}

id objc_msgSend_ghostbustByMidEnabled(void *a1, const char *a2, ...)
{
  return [a1 ghostbustByMidEnabled];
}

id objc_msgSend_ghostbustBySerialEnabled(void *a1, const char *a2, ...)
{
  return [a1 ghostbustBySerialEnabled];
}

id objc_msgSend_globalRateLimiter(void *a1, const char *a2, ...)
{
  return [a1 globalRateLimiter];
}

id objc_msgSend_globalTracker(void *a1, const char *a2, ...)
{
  return [a1 globalTracker];
}

id objc_msgSend_group(void *a1, const char *a2, ...)
{
  return [a1 group];
}

id objc_msgSend_groupID(void *a1, const char *a2, ...)
{
  return [a1 groupID];
}

id objc_msgSend_groupManager(void *a1, const char *a2, ...)
{
  return [a1 groupManager];
}

id objc_msgSend_groupStart(void *a1, const char *a2, ...)
{
  return [a1 groupStart];
}

id objc_msgSend_groups(void *a1, const char *a2, ...)
{
  return [a1 groups];
}

id objc_msgSend_groupsUpdated(void *a1, const char *a2, ...)
{
  return [a1 groupsUpdated];
}

id objc_msgSend_halt(void *a1, const char *a2, ...)
{
  return [a1 halt];
}

id objc_msgSend_haltAll(void *a1, const char *a2, ...)
{
  return [a1 haltAll];
}

id objc_msgSend_haltOperation(void *a1, const char *a2, ...)
{
  return [a1 haltOperation];
}

id objc_msgSend_halted(void *a1, const char *a2, ...)
{
  return [a1 halted];
}

id objc_msgSend_handle(void *a1, const char *a2, ...)
{
  return [a1 handle];
}

id objc_msgSend_handleCKLogin(void *a1, const char *a2, ...)
{
  return [a1 handleCKLogin];
}

id objc_msgSend_handleCKLogout(void *a1, const char *a2, ...)
{
  return [a1 handleCKLogout];
}

id objc_msgSend_handleMismatchedViewItems(void *a1, const char *a2, ...)
{
  return [a1 handleMismatchedViewItems];
}

id objc_msgSend_hasAltDSID(void *a1, const char *a2, ...)
{
  return [a1 hasAltDSID];
}

id objc_msgSend_hasAttemptedJoin(void *a1, const char *a2, ...)
{
  return [a1 hasAttemptedJoin];
}

id objc_msgSend_hasCertCached(void *a1, const char *a2, ...)
{
  return [a1 hasCertCached];
}

id objc_msgSend_hasExists(void *a1, const char *a2, ...)
{
  return [a1 hasExists];
}

id objc_msgSend_hasLastCloudServicesTriggerTime(void *a1, const char *a2, ...)
{
  return [a1 hasLastCloudServicesTriggerTime];
}

id objc_msgSend_hasLastEscrowAttemptTime(void *a1, const char *a2, ...)
{
  return [a1 hasLastEscrowAttemptTime];
}

id objc_msgSend_hasLeft(void *a1, const char *a2, ...)
{
  return [a1 hasLeft];
}

id objc_msgSend_hasMatch(void *a1, const char *a2, ...)
{
  return [a1 hasMatch];
}

id objc_msgSend_hasMatchingRule(void *a1, const char *a2, ...)
{
  return [a1 hasMatchingRule];
}

id objc_msgSend_hasNot(void *a1, const char *a2, ...)
{
  return [a1 hasNot];
}

id objc_msgSend_hasPeerInfo(void *a1, const char *a2, ...)
{
  return [a1 hasPeerInfo];
}

id objc_msgSend_hasSerializedPrerecord(void *a1, const char *a2, ...)
{
  return [a1 hasSerializedPrerecord];
}

id objc_msgSend_hasSyncingPolicy(void *a1, const char *a2, ...)
{
  return [a1 hasSyncingPolicy];
}

id objc_msgSend_hasUploadCompleted(void *a1, const char *a2, ...)
{
  return [a1 hasUploadCompleted];
}

id objc_msgSend_hasValidCredentials(void *a1, const char *a2, ...)
{
  return [a1 hasValidCredentials];
}

id objc_msgSend_hasWalrus(void *a1, const char *a2, ...)
{
  return [a1 hasWalrus];
}

id objc_msgSend_hasWebAccess(void *a1, const char *a2, ...)
{
  return [a1 hasWebAccess];
}

id objc_msgSend_hash(void *a1, const char *a2, ...)
{
  return [a1 hash];
}

id objc_msgSend_hasiCloudAccount(void *a1, const char *a2, ...)
{
  return [a1 hasiCloudAccount];
}

id objc_msgSend_haveConfirmedOctagonKeys(void *a1, const char *a2, ...)
{
  return [a1 haveConfirmedOctagonKeys];
}

id objc_msgSend_haveNetwork(void *a1, const char *a2, ...)
{
  return [a1 haveNetwork];
}

id objc_msgSend_haveRecordedDate(void *a1, const char *a2, ...)
{
  return [a1 haveRecordedDate];
}

id objc_msgSend_havoc(void *a1, const char *a2, ...)
{
  return [a1 havoc];
}

id objc_msgSend_history(void *a1, const char *a2, ...)
{
  return [a1 history];
}

id objc_msgSend_holdIncomingQueueOperation(void *a1, const char *a2, ...)
{
  return [a1 holdIncomingQueueOperation];
}

id objc_msgSend_holdLocalSynchronizeOperation(void *a1, const char *a2, ...)
{
  return [a1 holdLocalSynchronizeOperation];
}

id objc_msgSend_holdOperation(void *a1, const char *a2, ...)
{
  return [a1 holdOperation];
}

id objc_msgSend_holdOutgoingQueueOperation(void *a1, const char *a2, ...)
{
  return [a1 holdOutgoingQueueOperation];
}

id objc_msgSend_holdStateMachineOperation(void *a1, const char *a2, ...)
{
  return [a1 holdStateMachineOperation];
}

id objc_msgSend_icloudAccountState(void *a1, const char *a2, ...)
{
  return [a1 icloudAccountState];
}

id objc_msgSend_identifier(void *a1, const char *a2, ...)
{
  return [a1 identifier];
}

id objc_msgSend_identifiers(void *a1, const char *a2, ...)
{
  return [a1 identifiers];
}

id objc_msgSend_identityIsPreapproved(void *a1, const char *a2, ...)
{
  return [a1 identityIsPreapproved];
}

id objc_msgSend_idmsCuttlefishPassword(void *a1, const char *a2, ...)
{
  return [a1 idmsCuttlefishPassword];
}

id objc_msgSend_idmsTargetContext(void *a1, const char *a2, ...)
{
  return [a1 idmsTargetContext];
}

id objc_msgSend_ik(void *a1, const char *a2, ...)
{
  return [a1 ik];
}

id objc_msgSend_immutableData(void *a1, const char *a2, ...)
{
  return [a1 immutableData];
}

id objc_msgSend_incomingDatabaseItem(void *a1, const char *a2, ...)
{
  return [a1 incomingDatabaseItem];
}

id objc_msgSend_incompleteKeySets(void *a1, const char *a2, ...)
{
  return [a1 incompleteKeySets];
}

id objc_msgSend_inflightFetch(void *a1, const char *a2, ...)
{
  return [a1 inflightFetch];
}

id objc_msgSend_inflightFetchDependencies(void *a1, const char *a2, ...)
{
  return [a1 inflightFetchDependencies];
}

id objc_msgSend_inflightFetchDependency(void *a1, const char *a2, ...)
{
  return [a1 inflightFetchDependency];
}

id objc_msgSend_infoDictionary(void *a1, const char *a2, ...)
{
  return [a1 infoDictionary];
}

id objc_msgSend_inheritanceKey(void *a1, const char *a2, ...)
{
  return [a1 inheritanceKey];
}

id objc_msgSend_init(void *a1, const char *a2, ...)
{
  return [a1 init];
}

id objc_msgSend_initAsSuccess(void *a1, const char *a2, ...)
{
  return [a1 initAsSuccess];
}

id objc_msgSend_initialBecomeUntrustedPosted(void *a1, const char *a2, ...)
{
  return [a1 initialBecomeUntrustedPosted];
}

id objc_msgSend_initialDelay(void *a1, const char *a2, ...)
{
  return [a1 initialDelay];
}

id objc_msgSend_initialID(void *a1, const char *a2, ...)
{
  return [a1 initialID];
}

id objc_msgSend_initialInCircle(void *a1, const char *a2, ...)
{
  return [a1 initialInCircle];
}

id objc_msgSend_initialKeyParameters(void *a1, const char *a2, ...)
{
  return [a1 initialKeyParameters];
}

id objc_msgSend_initialState(void *a1, const char *a2, ...)
{
  return [a1 initialState];
}

id objc_msgSend_initialTrusted(void *a1, const char *a2, ...)
{
  return [a1 initialTrusted];
}

id objc_msgSend_initialUnsyncedViews(void *a1, const char *a2, ...)
{
  return [a1 initialUnsyncedViews];
}

id objc_msgSend_initialViews(void *a1, const char *a2, ...)
{
  return [a1 initialViews];
}

id objc_msgSend_initializeOctagon(void *a1, const char *a2, ...)
{
  return [a1 initializeOctagon];
}

id objc_msgSend_initializingOperation(void *a1, const char *a2, ...)
{
  return [a1 initializingOperation];
}

id objc_msgSend_insertIntoIncoming(void *a1, const char *a2, ...)
{
  return [a1 insertIntoIncoming];
}

id objc_msgSend_insertIntoLocalAndMirror(void *a1, const char *a2, ...)
{
  return [a1 insertIntoLocalAndMirror];
}

id objc_msgSend_insertIntoMirror(void *a1, const char *a2, ...)
{
  return [a1 insertIntoMirror];
}

id objc_msgSend_insertIntoOutgoing(void *a1, const char *a2, ...)
{
  return [a1 insertIntoOutgoing];
}

id objc_msgSend_insideSQLTransaction(void *a1, const char *a2, ...)
{
  return [a1 insideSQLTransaction];
}

id objc_msgSend_intValue(void *a1, const char *a2, ...)
{
  return [a1 intValue];
}

id objc_msgSend_integerValue(void *a1, const char *a2, ...)
{
  return [a1 integerValue];
}

id objc_msgSend_intendedFederation(void *a1, const char *a2, ...)
{
  return [a1 intendedFederation];
}

id objc_msgSend_intendedPath(void *a1, const char *a2, ...)
{
  return [a1 intendedPath];
}

id objc_msgSend_intendedState(void *a1, const char *a2, ...)
{
  return [a1 intendedState];
}

id objc_msgSend_intendedViewStatus(void *a1, const char *a2, ...)
{
  return [a1 intendedViewStatus];
}

id objc_msgSend_intendedZoneIDs(void *a1, const char *a2, ...)
{
  return [a1 intendedZoneIDs];
}

id objc_msgSend_internalSuccesses(void *a1, const char *a2, ...)
{
  return [a1 internalSuccesses];
}

id objc_msgSend_internalTestConfigsCount(void *a1, const char *a2, ...)
{
  return [a1 internalTestConfigsCount];
}

id objc_msgSend_internetPassword(void *a1, const char *a2, ...)
{
  return [a1 internetPassword];
}

id objc_msgSend_internetPasswordFingerprint(void *a1, const char *a2, ...)
{
  return [a1 internetPasswordFingerprint];
}

id objc_msgSend_invalidate(void *a1, const char *a2, ...)
{
  return [a1 invalidate];
}

id objc_msgSend_invalidateTimeout(void *a1, const char *a2, ...)
{
  return [a1 invalidateTimeout];
}

id objc_msgSend_invitationToken(void *a1, const char *a2, ...)
{
  return [a1 invitationToken];
}

id objc_msgSend_inviteStatus(void *a1, const char *a2, ...)
{
  return [a1 inviteStatus];
}

id objc_msgSend_inviteToken(void *a1, const char *a2, ...)
{
  return [a1 inviteToken];
}

id objc_msgSend_invoke(void *a1, const char *a2, ...)
{
  return [a1 invoke];
}

id objc_msgSend_isAppleInternal(void *a1, const char *a2, ...)
{
  return [a1 isAppleInternal];
}

id objc_msgSend_isAppleTV(void *a1, const char *a2, ...)
{
  return [a1 isAppleTV];
}

id objc_msgSend_isCKInternalServerHTTPError(void *a1, const char *a2, ...)
{
  return [a1 isCKInternalServerHTTPError];
}

id objc_msgSend_isCancelled(void *a1, const char *a2, ...)
{
  return [a1 isCancelled];
}

id objc_msgSend_isCurrentUser(void *a1, const char *a2, ...)
{
  return [a1 isCurrentUser];
}

id objc_msgSend_isCurrentUserIdentifierAvailable(void *a1, const char *a2, ...)
{
  return [a1 isCurrentUserIdentifierAvailable];
}

id objc_msgSend_isCurrentUserProvisioned(void *a1, const char *a2, ...)
{
  return [a1 isCurrentUserProvisioned];
}

id objc_msgSend_isEmpty(void *a1, const char *a2, ...)
{
  return [a1 isEmpty];
}

id objc_msgSend_isExcluded(void *a1, const char *a2, ...)
{
  return [a1 isExcluded];
}

id objc_msgSend_isExecuting(void *a1, const char *a2, ...)
{
  return [a1 isExecuting];
}

id objc_msgSend_isFinished(void *a1, const char *a2, ...)
{
  return [a1 isFinished];
}

id objc_msgSend_isFullPeer(void *a1, const char *a2, ...)
{
  return [a1 isFullPeer];
}

id objc_msgSend_isFullyDecoded(void *a1, const char *a2, ...)
{
  return [a1 isFullyDecoded];
}

id objc_msgSend_isGuitarfish(void *a1, const char *a2, ...)
{
  return [a1 isGuitarfish];
}

id objc_msgSend_isHomePod(void *a1, const char *a2, ...)
{
  return [a1 isHomePod];
}

id objc_msgSend_isInheritedAccount(void *a1, const char *a2, ...)
{
  return [a1 isInheritedAccount];
}

id objc_msgSend_isListeningForSync(void *a1, const char *a2, ...)
{
  return [a1 isListeningForSync];
}

id objc_msgSend_isLocked(void *a1, const char *a2, ...)
{
  return [a1 isLocked];
}

id objc_msgSend_isMachineIDOverridden(void *a1, const char *a2, ...)
{
  return [a1 isMachineIDOverridden];
}

id objc_msgSend_isPaused(void *a1, const char *a2, ...)
{
  return [a1 isPaused];
}

id objc_msgSend_isPending(void *a1, const char *a2, ...)
{
  return [a1 isPending];
}

id objc_msgSend_isPrimaryAccount(void *a1, const char *a2, ...)
{
  return [a1 isPrimaryAccount];
}

id objc_msgSend_isReady(void *a1, const char *a2, ...)
{
  return [a1 isReady];
}

id objc_msgSend_isRetryable(void *a1, const char *a2, ...)
{
  return [a1 isRetryable];
}

id objc_msgSend_isSyncingV0(void *a1, const char *a2, ...)
{
  return [a1 isSyncingV0];
}

id objc_msgSend_isTracingEnabled(void *a1, const char *a2, ...)
{
  return [a1 isTracingEnabled];
}

id objc_msgSend_isUseful(void *a1, const char *a2, ...)
{
  return [a1 isUseful];
}

id objc_msgSend_isWatch(void *a1, const char *a2, ...)
{
  return [a1 isWatch];
}

id objc_msgSend_item(void *a1, const char *a2, ...)
{
  return [a1 item];
}

id objc_msgSend_itemModificationsBeforePolicyLoaded(void *a1, const char *a2, ...)
{
  return [a1 itemModificationsBeforePolicyLoaded];
}

id objc_msgSend_itemPtr(void *a1, const char *a2, ...)
{
  return [a1 itemPtr];
}

id objc_msgSend_itemPtrName(void *a1, const char *a2, ...)
{
  return [a1 itemPtrName];
}

id objc_msgSend_itemsToDelete(void *a1, const char *a2, ...)
{
  return [a1 itemsToDelete];
}

id objc_msgSend_joinStatePathDictionary(void *a1, const char *a2, ...)
{
  return [a1 joinStatePathDictionary];
}

id objc_msgSend_keepProcessAlive(void *a1, const char *a2, ...)
{
  return [a1 keepProcessAlive];
}