CFDataRef sub_100004024(const void *a1)
{
  CFTypeID v2;
  CFUUIDBytes v4;
  uint64_t vars8;

  v2 = CFGetTypeID(a1);
  if (v2 == CFDataGetTypeID())
  {
    if ((CFDataGetLength((CFDataRef)a1) & 0xFFFFFFFFFFFFFFEFLL) == 0)
    {
      return CFDataCreateCopy(0, (CFDataRef)a1);
    }
    return 0;
  }
  if (v2 != CFNullGetTypeID())
  {
    if (v2 == CFUUIDGetTypeID())
    {
      v4 = CFUUIDGetUUIDBytes((CFUUIDRef)a1);
      return CFDataCreate(0, &v4.byte0, 16);
    }
    return 0;
  }

  return CFDataCreate(0, 0, 0);
}

void sub_100004188(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  sub_100006558(a2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v3);
}

id sub_100004268(void *a1, uint64_t a2)
{
  uint64_t v2 = [a1 valueForEntitlement:a2];
  if (v2 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    id v3 = [v2 BOOLValue];
  }
  else {
    id v3 = 0;
  }

  return v3;
}

void sub_1000042D0(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = a2;
  sub_100006558(a3);
  id v6 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id, id))(v4 + 16))(v4, v5, v6);
}

CFDataRef sub_100004398(const void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 != CFDataGetTypeID() || CFDataGetLength((CFDataRef)a1) != 20) {
    return 0;
  }
  CFAllocatorRef v3 = CFGetAllocator(a1);

  return CFDataCreateCopy(v3, (CFDataRef)a1);
}

void sub_100004408(void *a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = *(id *)(*(void *)(a1[5] + 8) + 40);
    objc_sync_enter(v4);
    [*(id *)(*(void *)(a1[5] + 8) + 40) addObject:v3];
    objc_sync_exit(v4);
  }
  else
  {
    id v5 = (void *)a1[4];
    id v8 = 0;
    unsigned __int8 v6 = [v5 updateCurrentUserMetadataForKey:@"pv" toValue:&__kCFBooleanTrue withError:&v8];
    id v4 = v8;
    if ((v6 & 1) == 0)
    {
      id v7 = *(id *)(*(void *)(a1[5] + 8) + 40);
      objc_sync_enter(v7);
      [*(id *)(*(void *)(a1[5] + 8) + 40) addObject:v4];
      objc_sync_exit(v7);
    }
  }

  dispatch_group_leave(*(dispatch_group_t *)(*(void *)(a1[6] + 8) + 40));
}

void sub_100004500(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000046CC(uint64_t a1, void *a2, void *a3)
{
  id v7 = a2;
  id v5 = a3;
  if (v5)
  {
    id v6 = *(id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
    objc_sync_enter(v6);
    [*(id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) addObject:v5];
    objc_sync_exit(v6);
  }
  dispatch_group_leave(*(dispatch_group_t *)(*(void *)(*(void *)(a1 + 40) + 8) + 40));
}

void sub_100004774(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100004788(void *a1)
{
  if (*(void *)(*(void *)(a1[5] + 8) + 40))
  {
LABEL_2:
    CFTypeID v2 = KCSharingLogObject();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = *(void *)(*(void *)(a1[5] + 8) + 40);
      int v10 = 138543362;
      uint64_t v11 = v9;
      _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "Failed to provision user: %{public}@", (uint8_t *)&v10, 0xCu);
    }
    goto LABEL_4;
  }
  if ([*(id *)(*(void *)(a1[6] + 8) + 40) count])
  {
    if (!*(void *)(*(void *)(a1[5] + 8) + 40))
    {
      NSErrorUserInfoKey v12 = NSMultipleUnderlyingErrorsKey;
      id v4 = [*(id *)(*(void *)(a1[6] + 8) + 40) copy];
      id v13 = v4;
      id v5 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      uint64_t v6 = +[NSError errorWithDomain:@"KCSharingErrorDomain" code:33 userInfo:v5];
      uint64_t v7 = *(void *)(a1[5] + 8);
      id v8 = *(void **)(v7 + 40);
      *(void *)(v7 + 40) = v6;
    }
    goto LABEL_2;
  }
  CFTypeID v2 = KCSharingLogObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v10) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Provisioned user.", (uint8_t *)&v10, 2u);
  }
LABEL_4:

  return (*(uint64_t (**)(void))(a1[4] + 16))();
}

void sub_100004AC4(id a1, void *a2)
{
  if (xpc_get_type(a2) == (xpc_type_t)&_xpc_type_connection)
  {
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 0x40000000;
    handler[2] = sub_100005450;
    handler[3] = &unk_1002F6E58;
    handler[4] = a2;
    xpc_connection_set_event_handler((xpc_connection_t)a2, handler);
    xpc_connection_resume((xpc_connection_t)a2);
  }
}

id sub_100004BC8(id a1, NSError *a2, NSString *a3)
{
  id v4 = a2;
  if ([(NSString *)a3 isEqualToString:NSLocalizedDescriptionKey])
  {
    id v5 = v4;
    uint64_t v6 = [(NSError *)v5 domain];
    unsigned int v7 = [v6 isEqualToString:@"KCSharingErrorDomain"];

    if (v7)
    {
      id v8 = 0;
      switch([(NSError *)v5 code])
      {
        case 1:
          uint64_t v9 = [(NSError *)v5 userInfo];
          int v10 = [v9 objectForKeyedSubscript:@"KCSharingInvalidAttribute"];
          +[NSString stringWithFormat:@"Item has invalid attributes: %@", v10];
          goto LABEL_26;
        case 2:
          uint64_t v9 = [(NSError *)v5 userInfo];
          int v10 = [v9 objectForKeyedSubscript:@"KCSharingErrorRecordType"];
          +[NSString stringWithFormat:@"Unknown record type '%@'", v10];
          goto LABEL_26;
        case 3:
          id v8 = @"Failed to decode local entry data blob";
          break;
        case 4:
          id v8 = @"Failed to decode remote item blob";
          break;
        case 5:
          id v8 = @"Credential and sidecar sharing groups don't match";
          break;
        case 7:
          id v8 = @"Can't parse sharing group from record ID";
          break;
        case 8:
          id v8 = @"Can't create entry from deletion";
          break;
        case 9:
          id v8 = @"Entry doesn't exist";
          break;
        case 0xDLL:
          id v8 = @"Can't decode item from share entry";
          break;
        case 0xELL:
          uint64_t v9 = [(NSError *)v5 userInfo];
          int v10 = [v9 objectForKeyedSubscript:NSMultipleUnderlyingErrorsKey];
          +[NSString stringWithFormat:@"Group sharing sync failed for reasons: %@", v10];
          goto LABEL_26;
        case 0xFLL:
          id v8 = @"Operation not allowed";
          break;
        case 0x12:
          uint64_t v9 = [(NSError *)v5 userInfo];
          int v10 = [v9 objectForKeyedSubscript:@"underlyingErrors"];
          +[NSString stringWithFormat:@"Operation failed for reasons: %@", v10];
          goto LABEL_26;
        case 0x13:
          id v8 = @"Failed to decode shared passkey user entity";
          break;
        case 0x14:
          id v8 = @"The requested functionality is not fully implemented yet";
          break;
        case 0x15:
          id v8 = @"Can't decode share from item entry";
          break;
        case 0x16:
          uint64_t v9 = [(NSError *)v5 userInfo];
          int v10 = [v9 objectForKeyedSubscript:@"KCSharingMissingAttribute"];
          +[NSString stringWithFormat:@"Item is missing attribute '%@'", v10];
LABEL_26:
          id v8 = (__CFString *)objc_claimAutoreleasedReturnValue();

          break;
        case 0x22:
          id v8 = @"Local and remote shared groups are out of sync";
          break;
        case 0x23:
          id v8 = @"Can't complete operation because the keychain is locked";
          break;
        case 0x24:
          id v8 = @"The Internet connection appears to be offline.";
          break;
        case 0x25:
          id v8 = @"An operation of this type is already enqueued";
          break;
        default:
          break;
      }
    }
    else
    {
      id v8 = 0;
    }
  }
  else
  {
    id v8 = 0;
  }

  return v8;
}

void sub_100005410(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Unwind_Resume(a1);
}

void sub_100005450(uint64_t a1, xpc_object_t object)
{
  if (xpc_get_type(object) == (xpc_type_t)&_xpc_type_dictionary)
  {
    id v4 = *(_xpc_connection_s **)(a1 + 32);
    sub_1000084F0(v4, object);
  }
}

uint64_t sub_1000054B0(uint64_t a1, CFCalendarRef calendar)
{
  uint64_t result = CFCalendarDecomposeAbsoluteTime(calendar, *(CFAbsoluteTime *)(a1 + 40), "yMdHms", *(void *)(a1 + 48), *(void *)(a1 + 56), *(void *)(a1 + 64), *(void *)(a1 + 72), *(void *)(a1 + 80), *(void *)(a1 + 88));
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result != 0;
  return result;
}

uint64_t sub_100005764(uint64_t a1, CFCalendarRef calendar)
{
  uint64_t result = CFCalendarComposeAbsoluteTime(calendar, (CFAbsoluteTime *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), "yMdHms", *(unsigned int *)(a1 + 48), *(unsigned int *)(a1 + 52), *(unsigned int *)(a1 + 56), *(unsigned int *)(a1 + 60), *(unsigned int *)(a1 + 64), *(unsigned int *)(a1 + 68));
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result != 0;
  return result;
}

void *sub_1000057D8(const void *a1, const void *a2, uint64_t a3)
{
  if (!CFEqual(a1, kSecClass)) {
    return (void *)sub_100012A40(-50, (__CFString **)(a3 + 40), @"add_class: key %@ is not %@", a1, kSecClass);
  }

  return sub_10000B978((void *)a3, a2, (__CFString **)(a3 + 40));
}

void sub_100005874(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  unsigned int v7 = KCSharingLogObject();
  id v8 = v7;
  if (v6)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v9 = 138543362;
      id v10 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to fetch current current identifier from CloudKit: %{public}@", (uint8_t *)&v9, 0xCu);
    }
  }
  else if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = 138543362;
    id v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Fetched current user identifier from CloudKit: %{public}@", (uint8_t *)&v9, 0xCu);
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000059A4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  id v6 = [a2 recordName];
  if (v6)
  {
    unsigned int v7 = *(void **)(a1 + 32);
    id v11 = 0;
    unsigned __int8 v8 = [v7 updateCurrentUserMetadataForKey:@"currentUserIdentifier" toValue:v6 withError:&v11];
    id v9 = v11;
    if ((v8 & 1) == 0)
    {
      id v10 = KCSharingLogObject();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138543362;
        id v13 = v9;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Failed to update currentUserMetadata after fetching current user identifier: %{public}@", buf, 0xCu);
      }
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_100005AD8(uint64_t a1)
{
  CFTypeID v2 = [*(id *)(a1 + 32) privateSyncEngine];

  if (v2)
  {
    id v3 = KCSharingLogObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Provisioning user.", buf, 2u);
    }

    if (([*(id *)(a1 + 32) isCurrentUserProvisioned] & 1) == 0)
    {
      id v4 = KCSharingLogObject();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Provisioning user's Manatee identity.", buf, 2u);
      }

      dispatch_group_enter(*(dispatch_group_t *)(*(void *)(*(void *)(a1 + 48) + 8) + 40));
      id v5 = [objc_alloc((Class)CKRecordZone) initWithZoneName:@"pv"];
      id v6 = [*(id *)(a1 + 32) privateSyncEngine];
      id v27 = v5;
      unsigned int v7 = +[NSArray arrayWithObjects:&v27 count:1];
      [v6 addRecordZonesToSave:v7 recordZoneIDsToDelete:0];

      unsigned __int8 v8 = [*(id *)(a1 + 32) privateSyncEngine];
      id v9 = [v5 zoneID];
      v26 = v9;
      id v10 = +[NSArray arrayWithObjects:&v26 count:1];
      v23[0] = _NSConcreteStackBlock;
      v23[1] = 3221225472;
      v23[2] = sub_100004408;
      v23[3] = &unk_1002F9830;
      v23[4] = *(void *)(a1 + 32);
      int8x16_t v24 = vextq_s8(*(int8x16_t *)(a1 + 48), *(int8x16_t *)(a1 + 48), 8uLL);
      [v8 modifyPendingChangesInZoneIDs:v10 completionHandler:v23];
    }
    if (([*(id *)(a1 + 32) isCurrentUserIdentifierAvailable] & 1) == 0)
    {
      id v11 = KCSharingLogObject();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Fetching current user identifier.", buf, 2u);
      }

      dispatch_group_enter(*(dispatch_group_t *)(*(void *)(*(void *)(a1 + 48) + 8) + 40));
      NSErrorUserInfoKey v12 = *(void **)(a1 + 32);
      v21[0] = _NSConcreteStackBlock;
      v21[1] = 3221225472;
      v21[2] = sub_1000046CC;
      v21[3] = &unk_1002F9F18;
      int8x16_t v22 = vextq_s8(*(int8x16_t *)(a1 + 48), *(int8x16_t *)(a1 + 48), 8uLL);
      [v12 fetchCurrentUserIdentifierWithReply:v21];
    }
  }
  else
  {
    uint64_t v13 = +[NSError errorWithDomain:@"KCSharingErrorDomain" code:35 userInfo:0];
    uint64_t v14 = *(void *)(*(void *)(a1 + 40) + 8);
    v15 = *(void **)(v14 + 40);
    *(void *)(v14 + 40) = v13;

    uint64_t v16 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    NSErrorUserInfoKey v28 = NSUnderlyingErrorKey;
    uint64_t v29 = v16;
    v17 = +[NSDictionary dictionaryWithObjects:&v29 forKeys:&v28 count:1];
    uint64_t v18 = +[NSError errorWithDomain:@"KCSharingErrorDomain" code:33 userInfo:v17];
    uint64_t v19 = *(void *)(*(void *)(a1 + 40) + 8);
    v20 = *(void **)(v19 + 40);
    *(void *)(v19 + 40) = v18;
  }
}

void sub_1000062C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id location,id a23)
{
  objc_destroyWeak(v26);
  objc_destroyWeak(v25);
  objc_destroyWeak(v24);
  objc_destroyWeak(v23);
  objc_destroyWeak(&location);
  objc_destroyWeak(&a23);
  _Unwind_Resume(a1);
}

id sub_100006558(void *a1)
{
  id v1 = a1;
  CFTypeID v2 = v1;
  if (v1)
  {
    id v3 = [v1 userInfo];
    id v4 = [v3 objectForKeyedSubscript:NSMultipleUnderlyingErrorsKey];

    if (v4)
    {
      id v5 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [v4 count]);
      long long v19 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      long long v22 = 0u;
      id v6 = v4;
      id v7 = [v6 countByEnumeratingWithState:&v19 objects:v23 count:16];
      if (v7)
      {
        id v8 = v7;
        uint64_t v9 = *(void *)v20;
        do
        {
          for (i = 0; i != v8; i = (char *)i + 1)
          {
            if (*(void *)v20 != v9) {
              objc_enumerationMutation(v6);
            }
            id v11 = sub_100006558(*(void *)(*((void *)&v19 + 1) + 8 * i));
            [v5 addObject:v11];
          }
          id v8 = [v6 countByEnumeratingWithState:&v19 objects:v23 count:16];
        }
        while (v8);
      }

      NSErrorUserInfoKey v12 = [v2 userInfo];
      id v13 = [v12 mutableCopy];

      id v14 = [v5 copy];
      [v13 setObject:v14 forKeyedSubscript:NSMultipleUnderlyingErrorsKey];

      v15 = [v2 domain];
      uint64_t v16 = +[NSError errorWithDomain:code:userInfo:](NSError, "errorWithDomain:code:userInfo:", v15, [v2 code], v13);

      v17 = CKXPCSuitableError();
    }
    else
    {
      v17 = CKXPCSuitableError();
    }
  }
  else
  {
    v17 = 0;
  }

  return v17;
}

void sub_10000679C(CFTypeRef cf2, const void *a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a3 + 16) - 1;
  *(void *)(a3 + 16) = v6;
  uint64_t v7 = a3 + 16 * v6;
  *(void *)(v7 + 264) = cf2;
  *(void *)(v7 + 272) = a2;
  if (!CFEqual(kSecMatchLimit, cf2))
  {
    if (CFEqual(kSecMatchIssuers, cf2))
    {
      CFTypeID v9 = CFGetTypeID(a2);
      if (v9 == CFArrayGetTypeID())
      {
        CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        if (!Mutable) {
          return;
        }
        id v11 = Mutable;
        CFIndex Count = CFArrayGetCount((CFArrayRef)a2);
        if (Count >= 1)
        {
          CFIndex v13 = Count;
          for (CFIndex i = 0; i != v13; ++i)
          {
            ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a2, i);
            CFTypeID TypeID = CFDataGetTypeID();
            if (TypeID == CFGetTypeID(ValueAtIndex))
            {
              v17 = (const void *)SecDistinguishedNameCopyNormalizedContent();
              if (v17)
              {
                uint64_t v18 = v17;
                CFArrayAppendValue(v11, v17);
                CFRelease(v18);
              }
            }
          }
        }
        if (CFArrayGetCount(v11) >= 1)
        {
          *(void *)(a3 + 176) = v11;
          return;
        }
        goto LABEL_25;
      }
    }
    if (CFEqual(kSecMatchPolicy, cf2))
    {
      CFTypeID v20 = CFGetTypeID(a2);
      if (v20 == CFArrayGetTypeID())
      {
        uint64_t v21 = _CFXPCCreateXPCObjectFromCFObject();
        if (v21)
        {
          long long v22 = (void *)v21;
          id v11 = (__CFArray *)SecPolicyXPCArrayCopyArray();
          xpc_release(v22);
          if (!v11) {
            return;
          }
          if (CFArrayGetCount(v11) == 1)
          {
            v23 = CFArrayGetValueAtIndex(v11, 0);
            CFTypeID v24 = CFGetTypeID(v23);
            if (v24 == SecPolicyGetTypeID())
            {
              v25 = CFArrayGetValueAtIndex(v11, 0);
              sub_100129F50(a3, v25);
LABEL_25:
              v26 = v11;
LABEL_32:
              CFRelease(v26);
              return;
            }
          }
          CFRelease(v11);
          CFStringRef v31 = @"unsupported array of policies";
        }
        else
        {
          CFStringRef v31 = @"unsupported kSecMatchPolicy object in query";
        }
        v30 = (__CFString **)(a3 + 40);
      }
      else
      {
        v30 = (__CFString **)(a3 + 40);
        CFStringRef v31 = @"unsupported value for kSecMatchPolicy attribute";
      }
    }
    else if (CFEqual(kSecMatchValidOnDate, cf2))
    {
      CFTypeID v27 = CFGetTypeID(a2);
      if (v27 == CFNullGetTypeID())
      {
        CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
        CFDateRef v29 = CFDateCreate(kCFAllocatorDefault, Current);
        sub_100129F9C(a3, v29);
        v26 = v29;
        goto LABEL_32;
      }
      CFTypeID v33 = CFGetTypeID(a2);
      if (v33 == CFDateGetTypeID())
      {
        sub_100129F9C(a3, a2);
        return;
      }
      v30 = (__CFString **)(a3 + 40);
      CFStringRef v31 = @"unsupported value for kSecMatchValidOnDate attribute";
    }
    else if (CFEqual(kSecMatchTrustedOnly, cf2))
    {
      CFTypeID v32 = CFGetTypeID(a2);
      if (v32 == CFBooleanGetTypeID())
      {
        sub_100129FE8(a3, a2);
        return;
      }
      v30 = (__CFString **)(a3 + 40);
      CFStringRef v31 = @"unsupported value for kSecMatchTrustedOnly attribute";
    }
    else if (CFEqual(kSecMatchHostOrSubdomainOfHost, cf2))
    {
      CFTypeID v34 = CFGetTypeID(a2);
      if (v34 == CFStringGetTypeID())
      {
        sub_10012A030(a3, a2);
        return;
      }
      v30 = (__CFString **)(a3 + 40);
      CFStringRef v31 = @"unsupported value for kSecMatchHostOrSubdomainOfHost attribute";
    }
    else
    {
      if (!CFEqual(kSecMatchEmailAddressIfPresent, cf2)) {
        return;
      }
      CFTypeID v35 = CFGetTypeID(a2);
      if (v35 == CFStringGetTypeID())
      {
        sub_10012A078(a3, a2);
        return;
      }
      v30 = (__CFString **)(a3 + 40);
      CFStringRef v31 = @"unsupported value for kSecMatchEmailAddressIfPresent attribute";
    }
    sub_100012A40(-50, v30, v31);
    return;
  }
  CFTypeID v8 = CFGetTypeID(a2);
  if (v8 != CFNumberGetTypeID())
  {
    if (CFEqual(kSecMatchLimitAll, a2))
    {
      uint64_t v19 = -1;
    }
    else
    {
      if (!CFEqual(kSecMatchLimitOne, a2))
      {
        sub_100012A40(-50, (__CFString **)(a3 + 40), @"unsupported match limit %@", a2);
        return;
      }
      uint64_t v19 = 1;
    }
    *(void *)(a3 + 104) = v19;
    return;
  }
  if (!CFNumberGetValue((CFNumberRef)a2, kCFNumberCFIndexType, (void *)(a3 + 104))) {
    sub_100012A40(-50, (__CFString **)(a3 + 40), @"failed to convert match limit %@ to CFIndex", a2);
  }
}

void sub_100007068(uint64_t a1)
{
  if (*(unsigned char *)(*(void *)(a1 + 32) + 48))
  {
    CFTypeID v2 = sub_10000B070("SecWarning");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v20) = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "SecDbConnectionRelease: IO failure reported in connection, throwing away currently idle caches", (uint8_t *)&v20, 2u);
    }
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(*(void *)(a1 + 40) + 40));
    CFArrayRemoveAllValues(*(CFMutableArrayRef *)(*(void *)(a1 + 40) + 48));
  }
  else
  {
    CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 40) + 48));
    CFIndex v4 = CFArrayGetCount(*(CFArrayRef *)(*(void *)(a1 + 40) + 40)) + Count;
    uint64_t v5 = 48;
    if (!*(unsigned char *)(a1 + 48)) {
      uint64_t v5 = 40;
    }
    CFArrayRef v6 = *(const __CFArray **)(*(void *)(a1 + 40) + v5);
    unint64_t v7 = CFArrayGetCount(v6);
    if (*(unsigned char *)(a1 + 48)) {
      unint64_t v8 = 5;
    }
    else {
      unint64_t v8 = 1;
    }
    CFIndex v9 = *(unsigned __int8 *)(*(void *)(a1 + 40) + 166);
    if (v7 >= v8 || v4 >= v9)
    {
      if (v9 < 6)
      {
        v17 = sub_10000B070("dbconn");
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        uint64_t v18 = "ro";
        if (!*(unsigned char *)(a1 + 48)) {
          uint64_t v18 = "rw";
        }
        int v19 = *(unsigned __int8 *)(*(void *)(a1 + 40) + 166);
        int v20 = 136315394;
        uint64_t v21 = v18;
        __int16 v22 = 1024;
        int v23 = v19;
        CFIndex v13 = "releasing %s connection rather than storing in size %d cache";
        id v14 = v17;
        uint32_t v15 = 18;
      }
      else
      {
        id v11 = sub_10000B070("SecError");
        if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        if (*(unsigned char *)(a1 + 48)) {
          NSErrorUserInfoKey v12 = "ro";
        }
        else {
          NSErrorUserInfoKey v12 = "rw";
        }
        int v20 = 136315138;
        uint64_t v21 = v12;
        CFIndex v13 = "dbconn: did not expect to run out of room in the %s cache when releasing connection";
        id v14 = v11;
        uint32_t v15 = 12;
      }
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v13, (uint8_t *)&v20, v15);
      return;
    }
    uint64_t v16 = *(const void **)(a1 + 32);
    CFArrayAppendValue(v6, v16);
  }
}

void sub_1000072D0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 64);
  if (*(unsigned char *)(v2 + 128)) {
    goto LABEL_22;
  }
  CFIndex v4 = *(uint64_t **)(a1 + 72);
  id v3 = *(CFTypeRef **)(a1 + 80);
  CFStringRef v5 = *(const __CFString **)(v2 + 16);
  CFTypeRef v33 = 0;
  CFTypeID v34 = &v33;
  uint64_t v35 = 0x2000000000;
  char v36 = 1;
  cf[0] = _NSConcreteStackBlock;
  cf[1] = (CFTypeRef)0x40000000;
  cf[2] = sub_100028CB0;
  cf[3] = &unk_1002F7958;
  cf[4] = &v33;
  *(void *)&long long buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 0x40000000;
  v38 = sub_10000B880;
  v39 = &unk_1002F7408;
  v40 = cf;
  sub_10000EB80(v5, (uint64_t)&buf);
  int v6 = *((unsigned __int8 *)v34 + 24);
  _Block_object_dispose(&v33, 8);
  if (v6)
  {
    unsigned __int8 v31 = 0;
    uint64_t v7 = sub_1000281CC(v2, 0);
    if (v7)
    {
      uint64_t v8 = v7;
      cf[0] = 0;
      if (sub_1000282E0(v7, (uint64_t)&v31, (uint64_t)cf))
      {
        CFTypeRef v9 = cf[0];
        if (cf[0])
        {
          cf[0] = 0;
          CFRelease(v9);
        }
        if (v4) {
          *CFIndex v4 = v8;
        }
        id v10 = sub_10000B070("#SecDB");
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          LOWORD(buf) = 0;
          _os_log_debug_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "#SecDB starting maintenance", (uint8_t *)&buf, 2u);
        }
        if (*(unsigned char *)(v8 + 40)) {
          goto LABEL_12;
        }
        uint64_t v26 = *(void *)(v8 + 16);
        uint64_t v27 = *(void *)(v26 + 136);
        if (v27)
        {
          CFTypeRef v33 = 0;
          *(unsigned char *)(v26 + 144) = 0;
          int v11 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, void, uint64_t, CFTypeRef *))(v27 + 16))(v27, v26, v8, v31, v26 + 144, &v33);
          *(unsigned char *)(v2 + 128) = v11;
          if ((v11 & 1) == 0)
          {
            NSErrorUserInfoKey v28 = sub_10000B070("SecError");
            if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
            {
              LODWORD(buf) = 138412290;
              *(void *)((char *)&buf + 4) = v33;
              _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "opened block failed: %@", (uint8_t *)&buf, 0xCu);
            }
          }
          if (!v3 || *(unsigned char *)(v8 + 40) || *v3)
          {
            if (v33)
            {
              CFDateRef v29 = sub_10000B070("SecError");
              if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
              {
                LODWORD(buf) = 138412290;
                *(void *)((char *)&buf + 4) = v33;
                _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "opened block failed: error (%@) is being released and lost", (uint8_t *)&buf, 0xCu);
              }
              CFTypeRef v30 = v33;
              if (v33)
              {
                CFTypeRef v33 = 0;
                CFRelease(v30);
              }
            }
          }
          else
          {
            *id v3 = v33;
          }
          if (*(unsigned char *)(v8 + 40)) {
LABEL_12:
          }
            int v11 = sub_100027270(v8, 0, v3);
        }
        else
        {
          int v11 = 0;
        }
        NSErrorUserInfoKey v12 = sub_10000B070("#SecDB");
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          LOWORD(buf) = 0;
          _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "#SecDB ending maintenance", (uint8_t *)&buf, 2u);
          if (!v11)
          {
LABEL_16:
            CFRelease((CFTypeRef)v8);
            if (v4) {
              *CFIndex v4 = 0;
            }
            goto LABEL_20;
          }
        }
        else if (!v11)
        {
          goto LABEL_16;
        }
        CFArrayAppendValue(*(CFMutableArrayRef *)(v2 + 40), (const void *)v8);
        goto LABEL_16;
      }
      uint64_t v21 = sub_10000B070("SecError");
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(CFTypeRef *)((char *)&buf + 4) = cf[0];
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Unable to create database: %@", (uint8_t *)&buf, 0xCu);
      }
      if (cf[0])
      {
        CFErrorDomain Domain = CFErrorGetDomain((CFErrorRef)cf[0]);
        if (CFEqual(Domain, @"com.apple.utilities.sqlite3"))
        {
          int Code = CFErrorGetCode((CFErrorRef)cf[0]);
          BOOL v25 = Code == 11 || Code == 26;
          *(unsigned char *)(v8 + 40) = v25;
        }
      }
      LOBYTE(v11) = 0;
      if (!v3 || *(unsigned char *)(v8 + 40)) {
        goto LABEL_20;
      }
      if (!*v3)
      {
        LOBYTE(v11) = 0;
        *id v3 = cf[0];
        goto LABEL_20;
      }
    }
  }
  else
  {
    CFIndex v13 = *__error();
    id v14 = __error();
    sub_1000297A0(v13, kCFErrorDomainPOSIX, 0, v3, v15, @"Unable to process corruption marker: %{darwin.errno}d", *v14);
  }
  LOBYTE(v11) = 0;
LABEL_20:
  *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = v11;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v11;
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
    return;
  }
  uint64_t v2 = *(void *)(a1 + 64);
LABEL_22:
  uint64_t v16 = 48;
  if (!*(unsigned char *)(a1 + 88)) {
    uint64_t v16 = 40;
  }
  CFArrayRef v17 = *(const __CFArray **)(v2 + v16);
  if (CFArrayGetCount(v17) && !*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24))
  {
    uint64_t v18 = *(void *)(a1 + 32);
    ValueAtIndex = CFArrayGetValueAtIndex(v17, 0);
    if ((*(unsigned int (**)(uint64_t, const void *))(v18 + 16))(v18, ValueAtIndex))
    {
      int v20 = *(const void **)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
      if (v20) {
        CFRetain(v20);
      }
    }
    CFArrayRemoveValueAtIndex(v17, 0);
  }
}

BOOL sub_1000077F4(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2) {
    *uint64_t v2 = a2;
  }
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) != 0;
}

void sub_100007D0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

uint64_t sub_100008010(uint64_t result, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)a3)
  {
    uint64_t result = sub_10000FB18(result, a2, *(void *)(a3 + 16));
    if (result) {
      *(void *)(a3 + 8) += result;
    }
    else {
      *(unsigned char *)a3 = 0;
    }
  }
  return result;
}

uint64_t sub_100008058(const void *a1, CFTypeRef cf, uint64_t a3)
{
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 != CFBooleanGetTypeID()) {
    return sub_100012A40(-50, (__CFString **)(a3 + 40), @"add_return: value %@ is not CFBoolean", cf);
  }
  int v7 = CFEqual(cf, kCFBooleanTrue);
  uint64_t result = CFEqual(a1, kSecReturnData);
  if (result)
  {
    int v9 = 1;
  }
  else
  {
    uint64_t result = CFEqual(a1, kSecReturnAttributes);
    if (result)
    {
      int v9 = 2;
    }
    else
    {
      uint64_t result = CFEqual(a1, kSecReturnRef);
      if (result)
      {
        int v9 = 4;
      }
      else
      {
        uint64_t result = CFEqual(a1, kSecReturnPersistentRef);
        if (!result) {
          return sub_100012A40(-50, (__CFString **)(a3 + 40), @"add_return: unknown key %@", a1);
        }
        int v9 = 8;
      }
    }
  }
  int v10 = *(_DWORD *)(a3 + 48);
  if ((v10 & v9) != 0 && !v7)
  {
    int v11 = v10 ^ v9;
LABEL_17:
    *(_DWORD *)(a3 + 48) = v11;
    return result;
  }
  if ((v10 & v9) == 0 && v7)
  {
    int v11 = v10 | v9;
    goto LABEL_17;
  }
  return result;
}

void sub_100008194(const __CFString *cf, const __CFString *a2, uint64_t a3)
{
  id v3 = (__CFString **)(a3 + 40);
  if (*(void *)(a3 + 40)) {
    return;
  }
  if (cf)
  {
    if (!a2)
    {
      sub_100012A40(-50, v3, @"applier: key %@ has NULL value", cf);
      return;
    }
    CFTypeID v7 = CFGetTypeID(cf);
    if (v7 == CFStringGetTypeID())
    {
      CFIndex Length = CFStringGetLength(cf);
      if (Length != 4)
      {
        if (Length < 2)
        {
          sub_100012A40(-50, v3, @"applier: key %@ invalid length", cf);
        }
        else
        {
          int CharacterAtIndex = CFStringGetCharacterAtIndex(cf, 0);
          switch(CharacterAtIndex)
          {
            case 'm':
              sub_10000679C(cf, a2, a3);
              break;
            case 'n':
            case 'o':
            case 'p':
            case 'q':
            case 's':
            case 't':
              goto LABEL_27;
            case 'r':
              sub_100008058(cf, a2, a3);
              break;
            case 'u':
              sub_1001299C0(cf, a2, a3);
              break;
            case 'v':
              sub_100129D18(cf, a2, a3);
              break;
            default:
              if (CharacterAtIndex != 102)
              {
                if (CharacterAtIndex == 99)
                {
                  sub_1000057D8(cf, a2, a3);
                }
                else
                {
LABEL_27:
                  sub_100012A40(-50, v3, @"applier: key %@ invalid", cf);
                }
              }
              break;
          }
        }
        return;
      }
    }
    else if (v7 != CFNumberGetTypeID())
    {
      sub_100012A40(-50, v3, @"applier: key %@ neither string nor number", cf);
      return;
    }
    sub_10000DF34(cf, (const __CFBoolean *)a2, a3);
  }
  else
  {
    sub_100012A40(-50, v3, @"applier: NULL key");
  }
}

uint64_t sub_100008428(const __CFData *a1, const __CFData *a2)
{
  CFIndex Length = CFDataGetLength(a1);
  CFIndex v5 = CFDataGetLength(a2);
  unint64_t v6 = v5;
  if (Length < 0 || v5 < 0)
  {
    if (Length >= v5) {
      uint64_t v12 = 0;
    }
    else {
      uint64_t v12 = -1;
    }
    if (Length <= v5) {
      return v12;
    }
    else {
      return 1;
    }
  }
  else
  {
    if (Length >= v5) {
      size_t v7 = v5;
    }
    else {
      size_t v7 = Length;
    }
    BytePtr = CFDataGetBytePtr(a1);
    int v9 = CFDataGetBytePtr(a2);
    int v10 = memcmp(BytePtr, v9, v7);
    if (v10 <= 0 && (v10 || Length <= v6))
    {
      LODWORD(v13) = v10 == 0;
      if (Length >= v6) {
        LODWORD(v13) = 0;
      }
      if (v10 < 0) {
        uint64_t v13 = 1;
      }
      else {
        uint64_t v13 = v13;
      }
      return v13 << 63 >> 63;
    }
    else
    {
      return 1;
    }
  }
}

void sub_1000084F0(_xpc_connection_s *a1, xpc_object_t object)
{
  xpc_type_t type = xpc_get_type(object);
  uint64_t v209 = 0;
  v210 = (CFTypeRef *)&v209;
  uint64_t v211 = 0x2000000000;
  uint64_t v212 = 0;
  long long v207 = 0u;
  *(_OWORD *)v208 = 0u;
  *(_OWORD *)cf = 0u;
  *(_OWORD *)v206 = 0u;
  HIDWORD(v206[0]) = xpc_connection_get_euid(a1);
  BYTE12(v207) = 0;
  BYTE1(v208[1]) = 0;
  if (type != (xpc_type_t)&_xpc_type_dictionary)
  {
    sub_1000297A0(1, @"com.apple.security.xpc", 0, v210 + 3, v5, @"Messages expect to be xpc dictionary, got: %@", object);
    unint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      CFTypeRef v7 = v210[3];
      *(_DWORD *)long long buf = 138412546;
      *(CFTypeRef *)&uint8_t buf[4] = cf[0];
      *(_WORD *)&buf[12] = 2112;
      *(void *)&buf[14] = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%@: returning error: %@", buf, 0x16u);
    }
    xpc_object_t v8 = sub_10000B504((__CFError *)v210[3]);
    reply_with_format = (void *)xpc_create_reply_with_format();
    CFDataRef v10 = 0;
    int v11 = 0;
LABEL_5:
    if (!reply_with_format) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  reply_with_format = xpc_dictionary_create_reply(object);
  uint64_t uint64 = xpc_dictionary_get_uint64(object, "operation");
  memset(buf, 0, 32);
  xpc_connection_get_audit_token();
  CFDataRef v10 = CFDataCreate(kCFAllocatorDefault, buf, 32);
  uid_t euid = xpc_connection_get_euid(a1);
  *(_OWORD *)bytes = *(_OWORD *)buf;
  *(_OWORD *)&bytes[16] = *(_OWORD *)&buf[16];
  if (sub_10000D278((uint64_t)cf, euid, bytes))
  {
    if (uint64 == 30) {
      int v11 = sub_10000DCB0((__SecTask *)cf[0], @"com.apple.developer.associated-domains");
    }
    else {
      int v11 = 0;
    }
    uint64_t v16 = sub_10000B070("serverxpc");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      if (uint64 > 0x87) {
        CFStringRef v20 = @"Unknown xpc operation";
      }
      else {
        CFStringRef v20 = off_100305B48[uint64];
      }
      *(_DWORD *)bytes = 138412802;
      *(CFTypeRef *)&bytes[4] = cf[0];
      *(_WORD *)&bytes[12] = 2112;
      *(void *)&bytes[14] = v20;
      *(_WORD *)&bytes[22] = 2048;
      *(void *)&bytes[24] = uint64;
      _os_log_debug_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "XPC [%@] operation: %@ (%llu)", bytes, 0x20u);
    }
    switch(uint64)
    {
      case 0uLL:
        if (sub_10000B468(0, (__SecTask *)cf[0], (__CFString **)v210 + 3))
        {
          CFDictionaryRef v21 = (const __CFDictionary *)sub_10000B23C(object, "query", (__CFString **)v210 + 3);
          if (v21)
          {
            CFDictionaryRef Mutable = v21;
            if ((CFDictionaryGetValue(v21, kSecAttrDeriveSyncIDFromItemAttributes)
               || CFDictionaryGetValue(Mutable, kSecAttrPCSPlaintextServiceIdentifier)
               || CFDictionaryGetValue(Mutable, kSecAttrPCSPlaintextPublicKey)
               || CFDictionaryGetValue(Mutable, kSecAttrPCSPlaintextPublicIdentity))
              && !sub_100020570(0, (__SecTask *)cf[0], @"com.apple.private.ckks.plaintextfields", (__CFString **)v210 + 3)|| (CFDictionaryGetValue(Mutable, kSecDataInetExtraNotes)|| CFDictionaryGetValue(Mutable, kSecDataInetExtraHistory)|| CFDictionaryGetValue(Mutable, kSecDataInetExtraClientDefined0)|| CFDictionaryGetValue(Mutable, kSecDataInetExtraClientDefined1)|| CFDictionaryGetValue(Mutable, kSecDataInetExtraClientDefined2)|| CFDictionaryGetValue(Mutable, kSecDataInetExtraClientDefined3))&& !sub_100020570(0, (__SecTask *)cf[0], @"com.apple.private.keychain.inet_expansion_fields", (__CFString **)v210 + 3))
            {
              *(void *)bytes = 0;
              goto LABEL_407;
            }
            if (CFDictionaryGetValue(Mutable, kSecAttrSysBound))
            {
              BOOL v23 = sub_100020570(0, (__SecTask *)cf[0], @"com.apple.private.keychain.sysbound", (__CFString **)v210 + 3);
              *(void *)bytes = 0;
              if (!v23) {
                goto LABEL_407;
              }
            }
            else
            {
              *(void *)bytes = 0;
            }
            if (sub_100145928(Mutable, (uint64_t)cf, (uint64_t)bytes, (__CFString **)v210 + 3))
            {
              CFStringRef v25 = *(const __CFString **)bytes;
              if (*(void *)bytes)
              {
                uint64_t v26 = (__CFString **)(v210 + 3);
                uint64_t v27 = reply_with_format;
                uint64_t v28 = 0;
                goto LABEL_61;
              }
            }
            goto LABEL_407;
          }
        }
        goto LABEL_409;
      case 1uLL:
        if (sub_10000B468(0, (__SecTask *)cf[0], (__CFString **)v210 + 3))
        {
          CFDictionaryRef v24 = (const __CFDictionary *)sub_10000B23C(object, "query", (__CFString **)v210 + 3);
          if (v24)
          {
            CFDictionaryRef Mutable = v24;
            *(void *)bytes = 0;
            if (sub_10000BA20(v24, (uint64_t)cf, (uint64_t *)bytes, (__CFString **)v210 + 3))
            {
              CFStringRef v25 = *(const __CFString **)bytes;
              if (*(void *)bytes)
              {
                uint64_t v26 = (__CFString **)(v210 + 3);
                uint64_t v27 = reply_with_format;
                uint64_t v28 = 1;
LABEL_61:
                sub_10000B890(v27, "status", v25, v28, v26);
                CFStringRef v29 = *(const __CFString **)bytes;
                if (*(void *)bytes)
                {
                  *(void *)bytes = 0;
                  goto LABEL_406;
                }
              }
            }
            goto LABEL_407;
          }
        }
        goto LABEL_409;
      case 2uLL:
        if (sub_10000B468(2u, (__SecTask *)cf[0], (__CFString **)v210 + 3))
        {
          CFDictionaryRef v30 = (const __CFDictionary *)sub_10000B23C(object, "query", (__CFString **)v210 + 3);
          if (v30)
          {
            CFDictionaryRef v31 = v30;
            CFDictionaryRef v32 = (const __CFDictionary *)sub_10000B23C(object, "attributesToUpdate", (__CFString **)v210 + 3);
            if (!v32) {
              goto LABEL_462;
            }
            CFDictionaryRef v33 = v32;
            if ((!CFDictionaryGetValue(v31, kSecAttrDeriveSyncIDFromItemAttributes)
               && !CFDictionaryGetValue(v33, kSecAttrPCSPlaintextServiceIdentifier)
               && !CFDictionaryGetValue(v33, kSecAttrPCSPlaintextPublicKey)
               && !CFDictionaryGetValue(v33, kSecAttrPCSPlaintextPublicIdentity)
               || sub_100020570(2u, (__SecTask *)cf[0], @"com.apple.private.ckks.plaintextfields", (__CFString **)v210 + 3))&& (!CFDictionaryGetValue(v33, kSecDataInetExtraNotes)&& !CFDictionaryGetValue(v33, kSecDataInetExtraHistory)&& !CFDictionaryGetValue(v33, kSecDataInetExtraClientDefined0)&& !CFDictionaryGetValue(v33, kSecDataInetExtraClientDefined1)&& !CFDictionaryGetValue(v33, kSecDataInetExtraClientDefined2)&& !CFDictionaryGetValue(v33, kSecDataInetExtraClientDefined3)|| sub_100020570(2u, (__SecTask *)cf[0], @"com.apple.private.keychain.inet_expansion_fields", (__CFString **)v210 + 3))&& (!CFDictionaryGetValue(v31, kSecAttrSysBound)|| sub_100020570(2u, (__SecTask *)cf[0],
                    @"com.apple.private.keychain.sysbound",
                    (__CFString **)v210 + 3)))
            {
              BOOL v34 = sub_10014712C(v31, v33, (uint64_t)cf, (__CFString **)v210 + 3);
              xpc_dictionary_set_BOOL(reply_with_format, "status", v34);
            }
            goto LABEL_368;
          }
        }
        goto LABEL_409;
      case 3uLL:
        if (sub_10000B468(0, (__SecTask *)cf[0], (__CFString **)v210 + 3))
        {
          CFDictionaryRef v35 = (const __CFDictionary *)sub_10000B23C(object, "query", (__CFString **)v210 + 3);
          if (v35)
          {
            CFDictionaryRef Mutable = v35;
            char v36 = sub_1001479D0(v35, (uint64_t)cf, (__CFString **)v210 + 3);
            goto LABEL_343;
          }
        }
        goto LABEL_409;
      case 7uLL:
        v37 = sub_10000DD54((__SecTask *)cf[0]);
        if (!v37 || (v38 = v37, int v39 = CFEqual(v37, @"com.apple.purplebuddy"), CFRelease(v38), !v39))
        {
          if (!sub_100020570(7u, (__SecTask *)cf[0], @"com.apple.private.security.delete.all", (__CFString **)v210 + 3))goto LABEL_377; {
        }
          }
        char v40 = sub_10014824C((uint64_t)(v210 + 3));
        goto LABEL_318;
      case 9uLL:
        if (!sub_100020570(9u, (__SecTask *)cf[0], @"restore-keychain", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        *(void *)bytes = 0;
        CFTypeRef v204 = 0;
        if (!sub_1001937D4(object, "keybag", bytes, (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        if (sub_1001937D4(object, "password", &v204, (__CFString **)v210 + 3))
        {
          char v41 = xpc_dictionary_get_BOOL(object, "emcsbackup");
          CFDictionaryRef v31 = *(const __CFDictionary **)bytes;
          CFTypeRef v42 = v204;
          uint64_t v43 = sub_100149A90((uint64_t)cf, *(uint64_t *)bytes, (uint64_t)v204, v41, (uint64_t *)v210 + 3);
          if (v43)
          {
            CFDataRef v44 = (const __CFData *)v43;
            int v45 = sub_100193580(object);
            if (v45 < 0)
            {
              sub_100193330(reply_with_format, "status", v44, (__CFString **)v210 + 3);
            }
            else
            {
              int v46 = v45;
              BOOL v193 = sub_100020608(v45, v44);
              if (close(v46)) {
                BOOL v47 = 0;
              }
              else {
                BOOL v47 = v193;
              }
              if (!v47)
              {
                v194 = (__CFString **)(v210 + 3);
                v48 = __error();
                sub_100012A40(-36, v194, @"Failed to write backup file: %d", *v48);
              }
              xpc_dictionary_set_BOOL(reply_with_format, "status", v47);
            }
            CFRelease(v44);
          }
          if (v42) {
            CFRelease(v42);
          }
        }
        else
        {
          CFDictionaryRef v31 = *(const __CFDictionary **)bytes;
        }
        goto LABEL_461;
      case 0xAuLL:
        if (!sub_100020570(0xAu, (__SecTask *)cf[0], @"restore-keychain", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        *(void *)bytes = 0;
        CFTypeRef v204 = 0;
        int v49 = sub_100193580(object);
        int v50 = v49;
        if (v49 == -1) {
          CFDataRef v51 = sub_100193744(object, "backup", (__CFString **)v210 + 3);
        }
        else {
          CFDataRef v51 = sub_10002067C(v49, (const UInt8 **)bytes, (CFIndex *)&v204);
        }
        CFDataRef v187 = v51;
        if (v51)
        {
          CFDataRef v188 = sub_100193744(object, "keybag", (__CFString **)v210 + 3);
          if (v188)
          {
            CFDataRef v189 = v188;
            CFDataRef theData = 0;
            if (sub_1001937D4(object, "password", &theData, (__CFString **)v210 + 3))
            {
              CFDataRef v190 = theData;
              char v191 = sub_10014A0AC((uint64_t)v187, (uint64_t)cf, (uint64_t)v189, (uint64_t)theData, (__CFString **)v210 + 3);
              xpc_dictionary_set_BOOL(reply_with_format, "status", v191);
              if (v190) {
                CFRelease(v190);
              }
            }
            CFRelease(v189);
          }
          CFRelease(v187);
        }
        if (v50 == -1) {
          goto LABEL_449;
        }
        int v192 = v50;
        goto LABEL_448;
      case 0xBuLL:
        if (!sub_100020570(0xBu, (__SecTask *)cf[0], @"restore-keychain", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        *(void *)bytes = 0;
        if (!sub_100193848(object, bytes, (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        CFDataRef v52 = sub_100193744(object, "keybag", (__CFString **)v210 + 3);
        if (!v52) {
          goto LABEL_137;
        }
        CFDataRef v53 = v52;
        CFTypeRef v204 = 0;
        if (sub_1001937D4(object, "password", &v204, (__CFString **)v210 + 3))
        {
          CFTypeRef v54 = v204;
          CFStringRef v55 = (const __CFString *)sub_10014A974(*(const void **)bytes, v53, v204, (__CFString **)v210 + 3);
          if (v55)
          {
            CFStringRef v56 = v55;
            sub_10000B890(reply_with_format, "status", v55, 0, (__CFString **)v210 + 3);
            CFRelease(v56);
          }
          if (v54) {
            CFRelease(v54);
          }
        }
        CFDataRef v57 = v53;
        goto LABEL_136;
      case 0xCuLL:
        if (!sub_100020570(0xCu, (__SecTask *)cf[0], @"restore-keychain", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        CFDictionaryRef v58 = (const __CFDictionary *)sub_10000B23C(object, "backup", (__CFString **)v210 + 3);
        if (!v58) {
          goto LABEL_409;
        }
        CFDictionaryRef v31 = v58;
        CFDataRef v59 = sub_100193744(object, "keybag", (__CFString **)v210 + 3);
        if (!v59) {
          goto LABEL_462;
        }
        CFDataRef v60 = v59;
        *(void *)bytes = 0;
        if (sub_1001937D4(object, "password", bytes, (__CFString **)v210 + 3))
        {
          v61 = *(const void **)bytes;
          BOOL v62 = sub_10014B254(v31, v60, *(const __CFData **)bytes, (__CFString **)v210 + 3);
          xpc_dictionary_set_BOOL(reply_with_format, "status", v62);
          if (v61) {
            CFRelease(v61);
          }
        }
        CFDictionaryRef v63 = v60;
        goto LABEL_369;
      case 0xDuLL:
        if (!sub_100020570(0xDu, (__SecTask *)cf[0], @"restore-keychain", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        CFStringRef v64 = (const __CFString *)sub_10012CC00(v210 + 3);
        if (!v64) {
          goto LABEL_409;
        }
        goto LABEL_167;
      case 0xEuLL:
        if (!sub_100020570(0xEu, (__SecTask *)cf[0], @"restore-keychain", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        *(void *)bytes = 0;
        BOOL v65 = sub_100193944(object, "cfstring", bytes, (__CFString **)v210 + 3);
        CFDictionaryRef Mutable = *(const __CFDictionary **)bytes;
        if (!v65) {
          goto LABEL_384;
        }
        CFStringRef v66 = (const __CFString *)sub_10012CCF4(*(uint64_t *)bytes, v210 + 3);
        sub_1001933EC((uint64_t)reply_with_format, v66, (__CFString **)v210 + 3);
        if (!v66) {
          goto LABEL_384;
        }
        goto LABEL_382;
      case 0xFuLL:
        if (sub_100020570(0xFu, (__SecTask *)cf[0], @"restore-keychain", (__CFString **)v210 + 3))
        {
          CFStringRef v67 = sub_1001938B4(object, "backup", (__CFString **)v210 + 3);
          if (v67)
          {
            CFStringRef v68 = v67;
            int v69 = sub_10012C73C((uint64_t)v67, v210 + 3);
            CFRelease(v68);
            xpc_dictionary_set_fd(reply_with_format, "status", v69);
            if (v69 != -1) {
              close(v69);
            }
          }
          else
          {
            xpc_dictionary_set_fd(reply_with_format, "status", -1);
          }
        }
        goto LABEL_409;
      case 0x10uLL:
        if (!sub_100020570(0x10u, (__SecTask *)cf[0], @"restore-keychain", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        *(void *)bytes = 0;
        if (!sub_1001937D4(object, "keybag", bytes, (__CFString **)v210 + 3)) {
          goto LABEL_137;
        }
        CFTypeRef v204 = 0;
        if (!sub_1001937D4(object, "data", &v204, (__CFString **)v210 + 3)) {
          goto LABEL_137;
        }
        CFStringRef v70 = sub_1001938B4(object, "backup", (__CFString **)v210 + 3);
        CFDataRef v71 = (const __CFData *)v204;
        if (v70)
        {
          CFStringRef v72 = v70;
          char v73 = sub_10012CA1C((uint64_t)v70, *(uint64_t *)bytes, (uint64_t)v204, v210 + 3);
          CFRelease(v72);
          xpc_dictionary_set_BOOL(reply_with_format, "status", v73);
        }
        if (!v71) {
          goto LABEL_137;
        }
        CFDataRef v57 = v71;
LABEL_136:
        CFRelease(v57);
LABEL_137:
        v74 = *(const void **)bytes;
        if (!*(void *)bytes) {
          goto LABEL_409;
        }
        goto LABEL_408;
      case 0x11uLL:
        if (!sub_100020570(0x11u, (__SecTask *)cf[0], @"restore-keychain", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        CFStringRef v75 = sub_1001938B4(object, "backup", (__CFString **)v210 + 3);
        if (!v75) {
          goto LABEL_374;
        }
        CFStringRef v76 = v75;
        *(void *)bytes = 0;
        if (sub_100193944(object, "digest", bytes, (__CFString **)v210 + 3))
        {
          CFDataRef v77 = sub_100193744(object, "keybag", (__CFString **)v210 + 3);
          if (v77)
          {
            CFDataRef v78 = v77;
            CFDataRef v195 = sub_100193744(object, "password", (__CFString **)v210 + 3);
            if (v195)
            {
              CFDataRef v79 = sub_100193744(object, "data", (__CFString **)v210 + 3);
              if (v79)
              {
                CFDataRef v80 = v79;
                char v81 = sub_10012CEF8((int)v79, *(uint64_t *)bytes, (int)v78, v195, (uint64_t)v79, v210 + 3);
                CFRelease(v80);
              }
              else
              {
                char v81 = 0;
              }
              CFRelease(v195);
            }
            else
            {
              char v81 = 0;
            }
            CFRelease(v78);
          }
          else
          {
            char v81 = 0;
          }
          if (*(void *)bytes) {
            CFRelease(*(CFTypeRef *)bytes);
          }
        }
        else
        {
          char v81 = 0;
        }
        goto LABEL_468;
      case 0x12uLL:
        if (!-[OTSOSActualAdapter sosEnabled]_0())
        {
          CFDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
          sub_10000B890(reply_with_format, "status", (const __CFString *)Mutable, 0, (__CFString **)v210 + 3);
          goto LABEL_384;
        }
        CFDictionaryRef v82 = (const __CFDictionary *)sub_10000B23C(object, "query", (__CFString **)v210 + 3);
        if (!v82) {
          goto LABEL_409;
        }
        CFDictionaryRef Mutable = v82;
        CFStringRef v83 = (const __CFString *)sub_10014A708();
        sub_10000B890(reply_with_format, "status", v83, 0, (__CFString **)v210 + 3);
LABEL_404:
        if (v83)
        {
LABEL_405:
          CFStringRef v29 = v83;
LABEL_406:
          CFRelease(v29);
        }
        goto LABEL_407;
      case 0x15uLL:
        *(void *)bytes = 0;
        if (!sub_1001937D4(object, "publicPeerId", bytes, (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        CFDictionaryRef Mutable = *(const __CFDictionary **)bytes;
        CFDataRef v84 = sub_1001637D4(*(const __CFData **)bytes, (uint64_t)(v210 + 3));
        if (!v84) {
          goto LABEL_384;
        }
        CFStringRef v66 = (const __CFString *)v84;
        sub_100193330(reply_with_format, "status", v84, (__CFString **)v210 + 3);
        goto LABEL_382;
      case 0x16uLL:
        *(void *)bytes = 0;
        CFDataRef theData = 0;
        CFTypeRef v204 = 0;
        CFDataRef v202 = 0;
        BOOL value = 0;
        if (!sub_1001937D4(object, "otrsess", bytes, (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        BOOL v85 = sub_1001937D4(object, "data", &v204, (__CFString **)v210 + 3);
        CFDictionaryRef Mutable = *(const __CFDictionary **)bytes;
        if (!v85) {
          goto LABEL_384;
        }
        CFStringRef v66 = (const __CFString *)v204;
        BOOL v86 = sub_1001639D0(*(uint64_t *)bytes, (uint64_t)v204, &theData, &v202, &value);
        if (v86)
        {
          CFDataRef v196 = theData;
          sub_100193330(reply_with_format, "otrsess", theData, (__CFString **)v210 + 3);
          CFDataRef v87 = v202;
          sub_100193330(reply_with_format, "data", v202, (__CFString **)v210 + 3);
          xpc_dictionary_set_BOOL(reply_with_format, "otrrdy", value);
          if (v196)
          {
            CFDataRef theData = 0;
            CFRelease(v196);
          }
          if (v87)
          {
            CFDataRef v202 = 0;
            CFRelease(v87);
          }
        }
        v88 = reply_with_format;
        BOOL v89 = v86;
        goto LABEL_200;
      case 0x1CuLL:
        if (!sub_100020570(0x1Cu, (__SecTask *)cf[0], @"keychain-sync-updates", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        unsigned int v90 = sub_100227B98((CFErrorRef *)v210 + 3);
        goto LABEL_234;
      case 0x1DuLL:
        char v91 = xpc_dictionary_get_BOOL(object, "force");
        char v40 = sub_10014B8A0(v91, (uint64_t)cf, (uint64_t)(v210 + 3));
        goto LABEL_318;
      case 0x1EuLL:
        CFDictionaryRef v92 = (const __CFDictionary *)sub_10000B23C(object, "query", (__CFString **)v210 + 3);
        if (!v92) {
          goto LABEL_409;
        }
        CFDictionaryRef Mutable = v92;
        *(void *)bytes = 0;
        if (cf[0]) {
          CFStringRef v83 = (const __CFString *)sub_10000DD54((__SecTask *)cf[0]);
        }
        else {
          CFStringRef v83 = 0;
        }
        if (sub_100148D64(Mutable, (uint64_t)cf, buf, (uint64_t)v83, (uint64_t)v11, (uint64_t *)bytes, (__CFString **)v210 + 3))
        {
          if (*(void *)bytes)
          {
            sub_10000B890(reply_with_format, "status", *(const __CFString **)bytes, 0, (__CFString **)v210 + 3);
            v178 = *(const void **)bytes;
            if (*(void *)bytes)
            {
              *(void *)bytes = 0;
              CFRelease(v178);
            }
          }
        }
        goto LABEL_404;
      case 0x1FuLL:
        CFStringRef v64 = (const __CFString *)sub_1001555A0();
        if (!v64) {
          goto LABEL_409;
        }
LABEL_167:
        CFDictionaryRef Mutable = (const __CFDictionary *)v64;
        sub_10000B890(reply_with_format, "status", v64, 0, (__CFString **)v210 + 3);
        goto LABEL_407;
      case 0x20uLL:
        CFStringRef v93 = (const __CFString *)sub_10000B2D4(object, "query", (__CFString **)v210 + 3);
        if (!v93) {
          goto LABEL_300;
        }
        CFDictionaryRef Mutable = (const __CFDictionary *)v93;
        sub_100155674(v93, (__CFString **)v210 + 3);
        goto LABEL_172;
      case 0x21uLL:
        CFDictionaryRef v94 = (const __CFDictionary *)sub_10000B2D4(object, "query", (__CFString **)v210 + 3);
        if (!v94) {
          goto LABEL_300;
        }
        CFDictionaryRef Mutable = v94;
        sub_100155720((uint64_t)v94, (uint64_t)(v210 + 3));
LABEL_172:
        v95 = reply_with_format;
        BOOL v96 = 1;
        goto LABEL_345;
      case 0x22uLL:
        if (!sub_100020570(0x22u, (__SecTask *)cf[0], @"keychain-sync-updates", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        char v40 = sub_100226BD8(v210 + 3);
        goto LABEL_318;
      case 0x23uLL:
      case 0x24uLL:
      case 0x25uLL:
      case 0x27uLL:
      case 0x28uLL:
      case 0x29uLL:
      case 0x2AuLL:
      case 0x2BuLL:
        CFArrayRef v17 = "error";
        uint64_t v18 = reply_with_format;
        int64_t v19 = -4;
        goto LABEL_34;
      case 0x2CuLL:
        if (!sub_100020570(0x2Cu, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        v200[0] = _NSConcreteStackBlock;
        v200[1] = 0x40000000;
        v200[2] = sub_100020728;
        v200[3] = &unk_1002F6E80;
        v200[4] = &v209;
        v200[5] = reply_with_format;
        v97 = v200;
        goto LABEL_181;
      case 0x2DuLL:
        if (sub_100020570(0x2Du, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3))
        {
          v199[0] = _NSConcreteStackBlock;
          v199[1] = 0x40000000;
          v199[2] = sub_100020848;
          v199[3] = &unk_1002F6EA8;
          v199[4] = &v209;
          v199[5] = reply_with_format;
          sub_1000208A0(object, (uint64_t)v199);
        }
        goto LABEL_409;
      case 0x2EuLL:
        if (!sub_100020570(0x2Eu, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        v198[0] = _NSConcreteStackBlock;
        v198[1] = 0x40000000;
        v198[2] = sub_100020944;
        v198[3] = &unk_1002F6ED0;
        v198[4] = &v209;
        v198[5] = reply_with_format;
        v97 = v198;
LABEL_181:
        sub_100020784(object, (uint64_t)v97);
        goto LABEL_409;
      case 0x2FuLL:
        if (!sub_100020570(0x2Fu, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        char v40 = sub_10021F958(v210 + 3);
        goto LABEL_318;
      case 0x30uLL:
        if (!sub_100020570(0x30u, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        v98 = v210 + 3;
        v99 = &stru_1003090C8;
        goto LABEL_250;
      case 0x31uLL:
        if (!sub_100020570(0x31u, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        int64_t v19 = (int)sub_10021FC8C(v210 + 3);
        goto LABEL_235;
      case 0x32uLL:
        if (!sub_100020570(0x32u, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        char v40 = sub_10021FDE0(v210 + 3);
        goto LABEL_318;
      case 0x33uLL:
        if (!sub_100020570(0x33u, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        char v40 = sub_100220DE8(v210 + 3);
        goto LABEL_318;
      case 0x34uLL:
        if (!sub_100020570(0x34u, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        char v40 = sub_1002215C4(v210 + 3);
        goto LABEL_318;
      case 0x35uLL:
        if (!sub_100020570(0x35u, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        char v40 = sub_100221BD4(v210 + 3);
        goto LABEL_318;
      case 0x36uLL:
        if (sub_100020570(0x36u, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3))
        {
          v197[0] = _NSConcreteStackBlock;
          v197[1] = 0x40000000;
          v197[2] = sub_1000209A0;
          v197[3] = &unk_1002F6EF8;
          v197[4] = &v209;
          v197[5] = reply_with_format;
          sub_1000209F8(object, (uint64_t)v197);
        }
        goto LABEL_409;
      case 0x37uLL:
        if (!sub_100020570(0x37u, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        CFStringRef v66 = (const __CFString *)sub_100020A84(object, "enabledViews");
        CFDictionaryRef Mutable = (const __CFDictionary *)sub_100020A84(object, "disabledViews");
        BOOL v89 = sub_10021D24C((uint64_t)v66, (uint64_t)Mutable);
        v88 = reply_with_format;
LABEL_200:
        xpc_dictionary_set_BOOL(v88, "status", v89);
        if (!v66) {
          goto LABEL_384;
        }
        goto LABEL_382;
      case 0x38uLL:
        if (!sub_100020570(0x38u, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        char v40 = sub_100222128(v210 + 3);
        goto LABEL_318;
      case 0x39uLL:
        if (!sub_100020570(0x39u, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        xpc_dictionary_get_value(object, "peer-infos");
        CFDictionaryRef Mutable = (const __CFDictionary *)CreateArrayOfPeerInfoWithXPCObject();
        BOOL v100 = sub_1002223E0((uint64_t)Mutable, v210 + 3);
        v101 = reply_with_format;
        goto LABEL_379;
      case 0x3AuLL:
        if (!sub_100020570(0x3Au, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        sub_1002226AC();
        goto LABEL_300;
      case 0x3BuLL:
        if (!sub_100020570(0x3Bu, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        char v40 = sub_100222878(v210 + 3);
        goto LABEL_318;
      case 0x3DuLL:
        if (!sub_100020570(0x3Du, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        xpc_dictionary_get_value(object, "peer-infos");
        uint64_t ArrayOfPeerInfoWithXPCObject = CreateArrayOfPeerInfoWithXPCObject();
        if (!ArrayOfPeerInfoWithXPCObject) {
          goto LABEL_358;
        }
        CFDictionaryRef Mutable = (const __CFDictionary *)ArrayOfPeerInfoWithXPCObject;
        char v36 = sub_100224EBC(ArrayOfPeerInfoWithXPCObject, v210 + 3);
        goto LABEL_343;
      case 0x3EuLL:
        if (!sub_100020570(0x3Eu, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        xpc_dictionary_get_value(object, "peer-infos");
        uint64_t v103 = CreateArrayOfPeerInfoWithXPCObject();
        if (!v103) {
          goto LABEL_358;
        }
        CFDictionaryRef Mutable = (const __CFDictionary *)v103;
        char v36 = sub_100225250(v103, v210 + 3);
        goto LABEL_343;
      case 0x3FuLL:
        if (!sub_100020570(0x3Fu, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        v104 = (const void *)sub_100222E50(v210 + 3);
        goto LABEL_240;
      case 0x40uLL:
        if (!sub_100020570(0x40u, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        v104 = (const void *)sub_100223364(v210 + 3);
        goto LABEL_240;
      case 0x41uLL:
        if (!sub_100020570(0x41u, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        char v40 = sub_100223768(v210 + 3);
        goto LABEL_318;
      case 0x42uLL:
        if (!sub_100020570(0x42u, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        v104 = (const void *)sub_100223AD0(v210 + 3);
        goto LABEL_240;
      case 0x43uLL:
        if (!sub_100020570(0x43u, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        v104 = (const void *)sub_1002255E8(v210 + 3);
        goto LABEL_240;
      case 0x44uLL:
        if (!sub_100020570(0x44u, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        v104 = (const void *)sub_100225714(v210 + 3);
        goto LABEL_240;
      case 0x45uLL:
        if (sub_100020570(0x45u, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3))
        {
          v105 = (const void *)sub_1002231B8(v210 + 3);
          sub_100020BF4(reply_with_format, v105);
        }
        goto LABEL_409;
      case 0x46uLL:
        if (!sub_100020570(0x46u, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        unsigned int v90 = sub_1002269D8(v210 + 3);
        goto LABEL_234;
      case 0x47uLL:
        if (!sub_100020570(0x47u, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        int int64 = xpc_dictionary_get_int64(object, "reason");
        unsigned int v90 = sub_100226B08(int64, v210 + 3);
LABEL_234:
        int64_t v19 = v90;
LABEL_235:
        CFArrayRef v17 = "status";
        uint64_t v18 = reply_with_format;
LABEL_34:
        xpc_dictionary_set_int64(v18, v17, v19);
        goto LABEL_409;
      case 0x48uLL:
        if (!sub_100020570(0x48u, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        v104 = (const void *)sub_100223C60(v210 + 3);
        goto LABEL_240;
      case 0x49uLL:
        if (!sub_100020570(0x49u, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        v104 = (const void *)sub_100223D8C(v210 + 3);
LABEL_240:
        sub_100020B7C(reply_with_format, v104);
        goto LABEL_409;
      case 0x4AuLL:
        if (!sub_100020570(0x4Au, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        CFStringRef v107 = (const __CFString *)sub_100224158(v210 + 3);
        if (!v107) {
          goto LABEL_409;
        }
        CFDictionaryRef Mutable = (const __CFDictionary *)v107;
        v111 = sub_1000298CC(v107, v210 + 3, v108, v109, v110);
        if (!v111) {
          goto LABEL_407;
        }
        CFStringRef v83 = (const __CFString *)v111;
        BytePtr = CFDataGetBytePtr(v111);
        size_t Length = CFDataGetLength((CFDataRef)v83);
        xpc_dictionary_set_data(reply_with_format, "status", BytePtr, Length);
        goto LABEL_405;
      case 0x4BuLL:
        if (!sub_100020570(0x4Bu, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        uint64_t v114 = sub_100225BB8(v210 + 3);
        if (!v114) {
          goto LABEL_409;
        }
        goto LABEL_263;
      case 0x4CuLL:
        if (!sub_100020570(0x4Cu, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        v98 = v210 + 3;
        v99 = &stru_100309138;
LABEL_250:
        char v40 = sub_10021CD84(v98, v99);
        goto LABEL_318;
      case 0x4DuLL:
        if (!sub_100020570(0x4Du, (__SecTask *)cf[0], @"restore-keychain", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        CFDataRef v115 = sub_100193744(object, "newPublicBackupKey", (__CFString **)v210 + 3);
        if (!v115) {
          goto LABEL_409;
        }
        CFDictionaryRef Mutable = v115;
        uint64_t v116 = sub_100225F30((uint64_t)v115, v210 + 3);
        if (!v116) {
          goto LABEL_407;
        }
        v117 = (const void *)v116;
        CFStringRef v83 = (const __CFString *)SOSPeerInfoCopyEncodedData();
        CFRelease(v117);
        if (!v83) {
          goto LABEL_407;
        }
        v118 = (void *)_CFXPCCreateXPCObjectFromCFObject();
        xpc_dictionary_set_value(reply_with_format, "status", v118);
        xpc_release(v118);
        goto LABEL_405;
      case 0x4EuLL:
        if (!sub_100020570(0x4Eu, (__SecTask *)cf[0], @"restore-keychain", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        CFDictionaryRef v31 = sub_100193744(object, "keybag", (__CFString **)v210 + 3);
        char v119 = xpc_dictionary_get_BOOL(object, "includeV0");
        if (!v31) {
          goto LABEL_358;
        }
        BOOL v120 = sub_10022643C((uint64_t)v31, v119, v210 + 3);
        goto LABEL_273;
      case 0x4FuLL:
        if (!sub_100020570(0x4Fu, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        char v40 = sub_1002241FC(v210 + 3);
        goto LABEL_318;
      case 0x51uLL:
        if (!sub_100020570(0x51u, (__SecTask *)cf[0], @"com.apple.private.keychain.circle.join", (__CFString **)v210 + 3))goto LABEL_409; {
        uint64_t v114 = sub_1002285A0(v210 + 3);
        }
        if (!v114) {
          goto LABEL_409;
        }
LABEL_263:
        v121 = (const void *)v114;
        CFDictionaryRef Mutable = (const __CFDictionary *)SOSPeerInfoCopyEncodedData();
        CFRelease(v121);
        if (!Mutable) {
          goto LABEL_409;
        }
        goto LABEL_291;
      case 0x52uLL:
        if (!sub_100020570(0x52u, (__SecTask *)cf[0], @"com.apple.private.keychain.circle.join", (__CFString **)v210 + 3))goto LABEL_409; {
        CFDataRef v122 = sub_100020C64(object);
        }
        if (!v122) {
          goto LABEL_409;
        }
        CFDictionaryRef Mutable = v122;
        uint64_t v123 = SOSPeerInfoCreateFromData();
        if (!v123) {
          goto LABEL_407;
        }
        CFStringRef v83 = (const __CFString *)v123;
        uint64_t v124 = sub_10022898C(v123, v210 + 3);
        if (v124)
        {
          v125 = (const void *)v124;
          v126 = (void *)_CFXPCCreateXPCObjectFromCFObject();
          xpc_dictionary_set_value(reply_with_format, "status", v126);
          xpc_release(v126);
          CFRelease(v125);
        }
        goto LABEL_405;
      case 0x53uLL:
        if (!sub_100020570(0x53u, (__SecTask *)cf[0], @"com.apple.private.keychain.circle.join", (__CFString **)v210 + 3))goto LABEL_409; {
        CFDictionaryRef v31 = sub_100020C64(object);
        }
        int v127 = xpc_dictionary_get_uint64(object, "version");
        if (!v31) {
          goto LABEL_409;
        }
        BOOL v120 = sub_100229D2C((uint64_t)v31, v127, v210 + 3);
LABEL_273:
        xpc_dictionary_set_BOOL(reply_with_format, "status", v120);
        goto LABEL_462;
      case 0x54uLL:
        if (!sub_100020570(0x54u, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        char v40 = sub_100228900(v210 + 3);
        goto LABEL_318;
      case 0x55uLL:
        if (!sub_100020570(0x55u, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        char v40 = sub_100220C88(v210 + 3);
        goto LABEL_318;
      case 0x57uLL:
        if (!sub_100020570(0x57u, (__SecTask *)cf[0], @"restore-keychain", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        CFDataRef v128 = sub_100193744(object, "RecoveryPublicKey", (__CFString **)v210 + 3);
        if (!v128) {
          goto LABEL_409;
        }
        CFDictionaryRef Mutable = v128;
        bytes[0] = 0;
        CFDataRef v129 = CFDataCreate(kCFAllocatorDefault, bytes, 1);
        if (CFEqual(Mutable, v129))
        {
          CFRelease(Mutable);
          CFDictionaryRef Mutable = 0;
        }
        if (v129) {
          CFRelease(v129);
        }
        char v130 = sub_10022A794((uint64_t)Mutable, v210 + 3);
        xpc_dictionary_set_BOOL(reply_with_format, "status", v130);
        goto LABEL_384;
      case 0x58uLL:
        if (!sub_100020570(0x58u, (__SecTask *)cf[0], @"restore-keychain", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        uint64_t v131 = SOSCCCopyRecoveryPublicKey();
        if (!v131) {
          goto LABEL_409;
        }
        goto LABEL_290;
      case 0x59uLL:
        if (!sub_100020570(0x59u, (__SecTask *)cf[0], @"com.apple.private.keychain.circle.join", (__CFString **)v210 + 3))goto LABEL_409; {
        int v132 = xpc_dictionary_get_uint64(object, "flags");
        }
        uint64_t v131 = sub_100228D04(v132, v210 + 3);
        if (!v131) {
          goto LABEL_409;
        }
LABEL_290:
        CFDictionaryRef Mutable = (const __CFDictionary *)v131;
LABEL_291:
        v133 = (void *)_CFXPCCreateXPCObjectFromCFObject();
        xpc_dictionary_set_value(reply_with_format, "status", v133);
        xpc_release(v133);
        goto LABEL_407;
      case 0x5AuLL:
        BOOL v134 = xpc_dictionary_get_BOOL(object, "sosCompatibilityMode");
        char v40 = sub_10022BAE8(v134, v210 + 3);
        goto LABEL_318;
      case 0x5BuLL:
        char v40 = sub_10022C418(v210 + 3);
        goto LABEL_318;
      case 0x5CuLL:
        char v40 = sub_10022C34C();
        goto LABEL_318;
      case 0x5DuLL:
        if (!sub_100020570(0x5Du, (__SecTask *)cf[0], @"keychain-cloud-circle", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        sub_10022CA98(v210 + 3);
        goto LABEL_300;
      case 0x5EuLL:
        if (v206[1])
        {
          v135 = CFDataGetBytePtr((CFDataRef)v206[1]);
          size_t v136 = CFDataGetLength((CFDataRef)v206[1]);
          xpc_dictionary_set_data(reply_with_format, "musr", v135, v136);
        }
        xpc_dictionary_set_BOOL(reply_with_format, "system-keychain", (BOOL)v206[0]);
        xpc_dictionary_set_BOOL(reply_with_format, "syncbubble-keychain", SBYTE1(v206[0]));
        xpc_dictionary_set_BOOL(reply_with_format, "network-extension", SBYTE2(v206[0]));
        goto LABEL_300;
      case 0x5FuLL:
        if (!sub_100020570(0x5Fu, (__SecTask *)cf[0], @"com.apple.private.syncbubble-keychain", (__CFString **)v210 + 3))goto LABEL_409; {
        unsigned int v139 = xpc_dictionary_get_int64(object, "uid");
        }
        CFArrayRef v140 = (const __CFArray *)sub_1001936AC(object, "services", (__CFString **)v210 + 3);
        CFDictionaryRef Mutable = v140;
        if (v139 && v140)
        {
          char v36 = sub_10014C3C8(v140, v139, (uint64_t)cf, (__CFString **)v210 + 3);
LABEL_343:
          BOOL v96 = v36;
LABEL_344:
          v95 = reply_with_format;
LABEL_345:
          xpc_dictionary_set_BOOL(v95, "status", v96);
          goto LABEL_407;
        }
        v101 = reply_with_format;
        BOOL v100 = 0;
LABEL_379:
        xpc_dictionary_set_BOOL(v101, "status", v100);
        if (Mutable) {
          goto LABEL_407;
        }
        goto LABEL_409;
      case 0x60uLL:
        if (!sub_100020570(0x60u, (__SecTask *)cf[0], @"com.apple.private.migrate-musr-system-keychain", (__CFString **)v210 + 3))goto LABEL_409; {
        char v40 = sub_10014D0B0((uint64_t)cf, (uint64_t)(v210 + 3));
        }
        goto LABEL_318;
      case 0x61uLL:
        if (!sub_100020570(0x61u, (__SecTask *)cf[0], @"com.apple.private.migrate-musr-system-keychain", (__CFString **)v210 + 3))goto LABEL_409; {
        char v40 = sub_10014DA74((uint64_t)cf, (uint64_t)(v210 + 3));
        }
        goto LABEL_318;
      case 0x62uLL:
        if (!sub_10000B468(0x62u, (__SecTask *)cf[0], (__CFString **)v210 + 3)
          || !sub_100020570(0x62u, (__SecTask *)cf[0], @"com.apple.private.keychain.allow-update-tokens", (__CFString **)v210 + 3))
        {
          goto LABEL_409;
        }
        CFStringRef v141 = sub_1001938B4(object, "cfstring", (__CFString **)v210 + 3);
        CFStringRef v142 = (const __CFString *)sub_1001936AC(object, "cfarray", (__CFString **)v210 + 3);
        CFDictionaryRef Mutable = (const __CFDictionary *)sub_1001936AC(object, "query", (__CFString **)v210 + 3);
        if (v141)
        {
          char v143 = sub_100147E48((uint64_t)v141, (uint64_t)v142, (uint64_t)Mutable, (uint64_t)cf, (__CFString **)v210 + 3);
          xpc_dictionary_set_BOOL(reply_with_format, "status", v143);
          CFRelease(v141);
        }
        if (!v142) {
          goto LABEL_384;
        }
        CFStringRef v144 = v142;
        goto LABEL_383;
      case 0x63uLL:
        if (!sub_100020570(0x63u, (__SecTask *)cf[0], @"com.apple.private.migrate-musr-system-keychain", (__CFString **)v210 + 3))goto LABEL_409; {
        int v145 = xpc_dictionary_get_int64(object, "uid");
        }
        if (v145)
        {
          char v40 = sub_10014DCA8(v145, (uint64_t)(v210 + 3));
LABEL_318:
          BOOL v138 = v40;
        }
        else
        {
LABEL_377:
          BOOL v138 = 0;
        }
        v137 = reply_with_format;
        goto LABEL_320;
      case 0x67uLL:
        if (sub_100020570(0x67u, (__SecTask *)cf[0], @"com.apple.private.uninstall.deletion", (__CFString **)v210 + 3)&& (CFStringRef v146 = (const __CFString *)sub_1001936AC(object, "accessGroups", (__CFString **)v210 + 3)) != 0)
        {
          CFStringRef v76 = v146;
          char v81 = sub_1001487FC(v146, (uint64_t)cf, v210 + 3);
LABEL_468:
          CFRelease(v76);
        }
        else
        {
LABEL_374:
          char v81 = 0;
        }
        v137 = reply_with_format;
        BOOL v138 = v81;
        goto LABEL_320;
      case 0x68uLL:
        if (!sub_100020570(0x68u, (__SecTask *)cf[0], @"restore-keychain", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        *(void *)bytes = 0;
        CFTypeRef v204 = 0;
        int v147 = sub_100193580(object);
        if (v147 == -1) {
          goto LABEL_409;
        }
        int v148 = v147;
        CFDataRef v149 = sub_10002067C(v147, (const UInt8 **)bytes, (CFIndex *)&v204);
        if (v149)
        {
          CFDataRef v150 = v149;
          CFDictionaryRef v31 = (const __CFDictionary *)sub_10014A628(v149, (CFErrorRef *)v210 + 3);
          if (v31) {
            sub_1001933EC((uint64_t)reply_with_format, (const __CFString *)v31, (__CFString **)v210 + 3);
          }
          CFRelease(v150);
          close(v148);
          if (*(void *)bytes) {
            munmap(*(void **)bytes, (size_t)v204);
          }
LABEL_461:
          if (v31)
          {
LABEL_462:
            v74 = v31;
            goto LABEL_408;
          }
        }
        else
        {
          int v192 = v148;
LABEL_448:
          close(v192);
LABEL_449:
          if (*(void *)bytes) {
            munmap(*(void **)bytes, (size_t)v204);
          }
        }
        goto LABEL_409;
      case 0x69uLL:
        CFDictionaryRef v151 = (const __CFDictionary *)sub_1001936AC(object, "cfarray", (__CFString **)v210 + 3);
        if (!v151) {
          goto LABEL_409;
        }
        CFDictionaryRef Mutable = v151;
        CFBooleanRef v152 = (CFBooleanRef)sub_10022A2E0((uint64_t)v151, v210 + 3);
        if (!v152) {
          goto LABEL_407;
        }
        BOOL v96 = v152 != kCFBooleanFalse;
        goto LABEL_344;
      case 0x6AuLL:
        if (!sub_100020570(0x6Au, (__SecTask *)cf[0], @"keychain-sync-updates", (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        CFStringRef v66 = (const __CFString *)sub_1001935D8(object, "cfset", (__CFString **)v210 + 3);
        CFDictionaryRef v153 = (const __CFDictionary *)sub_1001935D8(object, "cfset2", (__CFString **)v210 + 3);
        CFDictionaryRef Mutable = v153;
        if (v66 && v153)
        {
          CFStringRef v154 = (const __CFString *)sub_100226EBC((uint64_t)v66, (uint64_t)v153, (uint64_t)(v210 + 3));
          if (v154)
          {
            CFStringRef v155 = v154;
            sub_10000B890(reply_with_format, "status", v154, 0, (__CFString **)v210 + 3);
            CFRelease(v155);
          }
        }
        else if (!v66)
        {
          goto LABEL_384;
        }
LABEL_382:
        CFStringRef v144 = v66;
LABEL_383:
        CFRelease(v144);
LABEL_384:
        if (!Mutable) {
          goto LABEL_409;
        }
LABEL_407:
        v74 = Mutable;
        goto LABEL_408;
      case 0x6BuLL:
        uint64_t v156 = sub_100020CE4(object, v210 + 3);
        if (!v156) {
          goto LABEL_409;
        }
        CFDictionaryRef Mutable = (const __CFDictionary *)v156;
        char v36 = sub_10022B478(v156, v210 + 3);
        goto LABEL_343;
      case 0x6CuLL:
        uint64_t v157 = sub_100020CE4(object, v210 + 3);
        if (!v157) {
          goto LABEL_409;
        }
        CFDictionaryRef Mutable = (const __CFDictionary *)v157;
        char v36 = sub_10022B7E4(v157, v210 + 3);
        goto LABEL_343;
      case 0x6DuLL:
        if (!sub_100020570(0x6Du, (__SecTask *)cf[0], @"com.apple.private.keychain.certificates", (__CFString **)v210 + 3))goto LABEL_409; {
        CFDataRef v158 = sub_100193744(object, "normIssuer", (__CFString **)v210 + 3);
        }
        v159 = sub_1001936AC(object, "accessGroups", (__CFString **)v210 + 3);
        v160 = v159;
        if (v158 && v159)
        {
          uint64_t v161 = sub_10014DE60(v158, (uint64_t)v159, (__CFString **)v210 + 3);
        }
        else
        {
          uint64_t v161 = 0;
          CFStringRef v177 = 0;
          if (!v158) {
            goto LABEL_388;
          }
        }
        CFRelease(v158);
        CFStringRef v177 = (const __CFString *)v161;
LABEL_388:
        if (v160) {
          CFRelease(v160);
        }
        if (v177)
        {
          sub_10000B890(reply_with_format, "status", v177, 0, (__CFString **)v210 + 3);
          v74 = v177;
LABEL_408:
          CFRelease(v74);
        }
        goto LABEL_409;
      case 0x6EuLL:
        if (!sub_100020570(0x6Eu, (__SecTask *)cf[0], @"com.apple.private.keychain.certificates", (__CFString **)v210 + 3))
        {
          BOOL v176 = 0;
          goto LABEL_398;
        }
        CFDataRef v162 = sub_100193744(object, "normIssuer", (__CFString **)v210 + 3);
        CFDataRef v163 = sub_100193744(object, "serialNum", (__CFString **)v210 + 3);
        v164 = sub_1001936AC(object, "accessGroups", (__CFString **)v210 + 3);
        v165 = v164;
        if (v162 && v163 && v164)
        {
          BOOL v166 = sub_10014DFA4(v162, v163, (uint64_t)v164, (__CFString **)v210 + 3);
        }
        else
        {
          BOOL v166 = 0;
          BOOL v176 = 0;
          if (!v162) {
            goto LABEL_394;
          }
        }
        BOOL v176 = v166;
        CFRelease(v162);
LABEL_394:
        if (v163) {
          CFRelease(v163);
        }
        if (v165) {
          CFRelease(v165);
        }
LABEL_398:
        v137 = reply_with_format;
        BOOL v138 = v176;
        goto LABEL_320;
      case 0x6FuLL:
        v167 = (__SecTask *)cf[0];
        v168 = (__CFString **)(v210 + 3);
        unsigned int v169 = 111;
        goto LABEL_357;
      case 0x70uLL:
        v167 = (__SecTask *)cf[0];
        v168 = (__CFString **)(v210 + 3);
        unsigned int v169 = 112;
LABEL_357:
        if (sub_100020570(v169, v167, @"com.apple.private.keychain.backuptableops", v168)) {
          goto LABEL_358;
        }
        goto LABEL_409;
      case 0x72uLL:
        if (!sub_100020570(0x72u, (__SecTask *)cf[0], @"com.apple.private.keychain.keychaincontrol", (__CFString **)v210 + 3))goto LABEL_409; {
        v170 = (void *)sub_100074E1C();
        }
        if (v170)
        {
          v171 = v170;
          xpc_dictionary_set_value(reply_with_format, "endpoint", v170);
          xpc_dictionary_set_BOOL(reply_with_format, "status", 1);
          xpc_release(v171);
        }
        else
        {
LABEL_358:
          v137 = reply_with_format;
          BOOL v138 = 0;
LABEL_320:
          xpc_dictionary_set_BOOL(v137, "status", v138);
        }
LABEL_409:
        if (!v210[3])
        {
          xpc_object_t v8 = 0;
          goto LABEL_5;
        }
        if (SecErrorGetOSStatus() == -25300) {
          goto LABEL_431;
        }
        v179 = (__CFError *)v210[3];
        if (!v179 || CFErrorGetCode((CFErrorRef)v210[3]) != 2) {
          goto LABEL_419;
        }
        CFErrorDomain Domain = CFErrorGetDomain(v179);
        if (Domain && kSOSErrorDomain)
        {
          if (CFEqual(Domain, kSOSErrorDomain)) {
            goto LABEL_431;
          }
        }
        else if (Domain == (CFErrorDomain)kSOSErrorDomain)
        {
          goto LABEL_431;
        }
LABEL_419:
        if (SecErrorGetOSStatus() == -25330)
        {
          v181 = sub_10000B070("SecWarning");
          if (!os_log_type_enabled(v181, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_431;
          }
          if (uint64 > 0x87) {
            CFStringRef v182 = @"Unknown xpc operation";
          }
          else {
            CFStringRef v182 = off_100305B48[uint64];
          }
          CFTypeRef v184 = v210[3];
          *(_DWORD *)bytes = 138412802;
          *(CFTypeRef *)&bytes[4] = cf[0];
          *(_WORD *)&bytes[12] = 2112;
          *(void *)&bytes[14] = v182;
          *(_WORD *)&bytes[22] = 2112;
          *(void *)&bytes[24] = v184;
          v185 = "Authentication is needed %@ %@ %@";
        }
        else
        {
          v181 = sub_10000B070("SecError");
          if (!os_log_type_enabled(v181, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_431;
          }
          if (uint64 > 0x87) {
            CFStringRef v183 = @"Unknown xpc operation";
          }
          else {
            CFStringRef v183 = off_100305B48[uint64];
          }
          CFTypeRef v186 = v210[3];
          *(_DWORD *)bytes = 138412802;
          *(CFTypeRef *)&bytes[4] = cf[0];
          *(_WORD *)&bytes[12] = 2112;
          *(void *)&bytes[14] = v183;
          *(_WORD *)&bytes[22] = 2112;
          *(void *)&bytes[24] = v186;
          v185 = "%@ %@ %@";
        }
        _os_log_impl((void *)&_mh_execute_header, v181, OS_LOG_TYPE_DEFAULT, v185, bytes, 0x20u);
LABEL_431:
        xpc_object_t v8 = sub_10000B504((__CFError *)v210[3]);
        if (!reply_with_format) {
          goto LABEL_5;
        }
        xpc_dictionary_set_value(reply_with_format, "error", v8);
        break;
      case 0x83uLL:
        if (!sub_10000B468(0x83u, (__SecTask *)cf[0], (__CFString **)v210 + 3)) {
          goto LABEL_409;
        }
        if (!BYTE1(v208[1])) {
          goto LABEL_409;
        }
        CFDictionaryRef v172 = (const __CFDictionary *)sub_10000B23C(object, "query", (__CFString **)v210 + 3);
        if (!v172) {
          goto LABEL_409;
        }
        CFDictionaryRef v31 = v172;
        CFStringRef v173 = sub_1001938B4(object, "sharingGroup", (__CFString **)v210 + 3);
        if (v173)
        {
          CFDictionaryRef v33 = (const __CFDictionary *)v173;
          CFStringRef v174 = (const __CFString *)sub_100145F88(v31, v173, (uint64_t)cf, (__CFString **)v210 + 3);
          if (v174)
          {
            CFStringRef v175 = v174;
            sub_10000B890(reply_with_format, "status", v174, 0, (__CFString **)v210 + 3);
            CFRelease(v175);
          }
LABEL_368:
          CFDictionaryRef v63 = v33;
LABEL_369:
          CFRelease(v63);
        }
        goto LABEL_462;
      case 0x84uLL:
        if (!sub_10000B468(0x84u, (__SecTask *)cf[0], (__CFString **)v210 + 3)
          || !sub_100020570(0x84u, (__SecTask *)cf[0], @"com.apple.private.keychain.allow-delete-on-sign-out", (__CFString **)v210 + 3)|| !sub_100146B48((uint64_t)cf, (uint64_t)(v210 + 3)))
        {
          goto LABEL_409;
        }
LABEL_300:
        v137 = reply_with_format;
        BOOL v138 = 1;
        goto LABEL_320;
      default:
        goto LABEL_409;
    }
LABEL_6:
    xpc_connection_send_message(a1, reply_with_format);
    xpc_release(reply_with_format);
LABEL_7:
    if (v8) {
      xpc_release(v8);
    }
    CFTypeRef v12 = v210[3];
    if (v12) {
      CFRelease(v12);
    }
    if (cf[1]) {
      CFRelease(cf[1]);
    }
    if (v206[1]) {
      CFRelease(v206[1]);
    }
    if (cf[0]) {
      CFRelease(cf[0]);
    }
    CFTypeRef v13 = v208[0];
    if (v208[0])
    {
      v208[0] = 0;
      CFRelease(v13);
    }
    if (v11) {
      CFRelease(v11);
    }
    if (v10) {
      CFRelease(v10);
    }
    goto LABEL_29;
  }
  if (v10) {
    CFRelease(v10);
  }
  xpc_connection_send_message(a1, reply_with_format);
  xpc_release(reply_with_format);
LABEL_29:
  _Block_object_dispose(&v209, 8);
}

const void *sub_10000B070(const char *a1)
{
  pthread_mutex_lock(&stru_10035AE88);
  pthread_mutex_unlock(&stru_10035AE88);
  if (a1)
  {
    CFStringRef v2 = CFStringCreateWithCString(kCFAllocatorDefault, a1, 0x600u);
    id v3 = sub_10000B100(v2);
    if (v2) {
      CFRelease(v2);
    }
    return v3;
  }
  else
  {
    return sub_10000B100(0);
  }
}

const void *sub_10000B100(const __CFString *a1)
{
  if (a1) {
    CFStringRef v1 = a1;
  }
  else {
    CFStringRef v1 = @"logging";
  }
  os_unfair_lock_lock_with_options();
  CFDictionaryRef Mutable = (const __CFDictionary *)qword_10035CB70;
  if (!qword_10035CB70)
  {
    CFDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, 0);
    qword_10035CB70 = (uint64_t)Mutable;
  }
  Value = CFDictionaryGetValue(Mutable, v1);
  if (!Value)
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 0x40000000;
    v5[2] = sub_1000257D4;
    v5[3] = &unk_1002F72D0;
    v5[4] = v1;
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    v6[2] = sub_10000B880;
    v6[3] = &unk_1002F7408;
    v6[4] = v5;
    sub_10000EB80(v1, (uint64_t)v6);
    Value = CFDictionaryGetValue((CFDictionaryRef)qword_10035CB70, v1);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_10035CB68);
  return Value;
}

const void *sub_10000B23C(void *a1, const char *a2, __CFString **a3)
{
  CFTypeRef v5 = sub_10000B2D4(a1, a2, a3);
  unint64_t v6 = v5;
  if (v5)
  {
    CFTypeID v7 = CFGetTypeID(v5);
    if (v7 != CFDictionaryGetTypeID())
    {
      CFStringRef v8 = CFCopyTypeIDDescription(v7);
      sub_100012A40(-50, a3, @"object for key %s not dictionary but %@", a2, v8);
      if (v8) {
        CFRelease(v8);
      }
      CFRelease(v6);
      return 0;
    }
  }
  return v6;
}

CFTypeRef sub_10000B2D4(void *a1, const char *a2, __CFString **a3)
{
  size_t length = 0;
  CFTypeRef cf = 0;
  data = xpc_dictionary_get_data(a1, a2, &length);
  if (data)
  {
    uint64_t v6 = (uint64_t)data;
    uint64_t v7 = (uint64_t)data + length;
    int v8 = SecCFAllocatorZeroize();
    if (sub_10000F124(v8, (int)&cf, (CFTypeRef *)a3, v6, v7) == v7)
    {
      CFTypeRef v12 = cf;
    }
    else
    {
      int v9 = (__CFString *)CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"trailing garbage after der decoded object for key %s", a2);
      sub_100012A40(-50, a3, @"%@", v9);
      if (a3)
      {
        CFDataRef v10 = sub_10000B070("SecError");
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          int v11 = *a3;
          *(_DWORD *)long long buf = 138412290;
          CFArrayRef v17 = v11;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "xpc: %@", buf, 0xCu);
        }
      }
      sub_10002BBA0(v9, 0x53C00002u);
      if (v9) {
        CFRelease(v9);
      }
      if (cf) {
        CFRelease(cf);
      }
      CFTypeRef v12 = 0;
    }
    cc_clear();
  }
  else
  {
    sub_100012A40(-50, a3, @"no object for key %s", a2);
    return 0;
  }
  return v12;
}

BOOL sub_10000B468(unsigned int a1, __SecTask *a2, __CFString **a3)
{
  BOOL v6 = sub_10000DC40(a2, @"com.apple.private.keychain.deny");
  if (v6)
  {
    if (a1 > 0x87) {
      CFStringRef v7 = @"Unknown xpc operation";
    }
    else {
      CFStringRef v7 = off_100305B48[a1];
    }
    sub_100012A40(-25291, a3, @"%@: %@ has entitlement %@", v7, a2, @"com.apple.private.keychain.deny");
  }
  return !v6;
}

xpc_object_t sub_10000B504(__CFError *a1)
{
  xpc_object_t v2 = xpc_dictionary_create(0, 0, 0);
  CFStringRef Domain = CFErrorGetDomain(a1);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000;
  v15[2] = sub_10000B870;
  v15[3] = &unk_1002F7D38;
  v15[4] = v2;
  v15[5] = "domain";
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 0x40000000;
  v16[2] = sub_10000B880;
  v16[3] = &unk_1002F7408;
  v16[4] = v15;
  sub_10000EB80(Domain, (uint64_t)v16);
  int64_t Code = CFErrorGetCode(a1);
  xpc_dictionary_set_int64(v2, "code", Code);
  CFStringRef v5 = (const __CFString *)CFErrorCopyUserInfo(a1);
  size_t v9 = sub_10000FE8C(v5, 0, v6, v7, v8);
  if (v9)
  {
    size_t v10 = v9;
    int v11 = (UInt8 *)malloc_type_malloc(v9, 0x4ABABCFuLL);
    unint64_t v12 = (unint64_t)&v11[v10];
    CFTypeRef v13 = (const void *)sub_10000F7B0(v5, 0, 0, v11, v12);
    if (v13) {
      xpc_dictionary_set_data(v2, "userinfo", v13, v12 - (void)v13);
    }
    free(v11);
  }
  CFRelease(v5);
  return v2;
}

uint64_t sub_10000B67C(const __CFDictionary *a1, uint64_t a2)
{
  long long v3 = xmmword_100265540;
  LOBYTE(v3) = 1;
  uint64_t v4 = a2;
  CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)sub_100008010, &v3);
  if ((_BYTE)v3) {
    return ccder_sizeof();
  }
  else {
    return 0;
  }
}

uint64_t sub_10000B6E8(const __CFDictionary *a1, CFTypeRef *a2, char a3)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  v12[0] = 0xAAAAAAAAAAAAAA01;
  v12[1] = a2;
  BYTE1(v12[0]) = a3;
  v12[2] = Mutable;
  v12[3] = 0;
  CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)sub_10000F65C, v12);
  if (!LOBYTE(v12[0]))
  {
    if (Mutable) {
      CFRelease(Mutable);
    }
    return 0;
  }
  v13.size_t length = CFArrayGetCount(Mutable);
  v13.location = 0;
  CFArraySortValues(Mutable, v13, (CFComparatorFunction)sub_100008428, 0);
  CFIndex Count = CFArrayGetCount(Mutable);
  if (Count >= 1)
  {
    unint64_t v8 = Count + 1;
    do
    {
      CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(Mutable, v8 - 2);
      CFDataGetLength(ValueAtIndex);
      CFDataGetBytePtr(ValueAtIndex);
      ccder_encode_body();
      --v8;
    }
    while (v8 > 1);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  uint64_t result = ccder_encode_constructed_tl();
  if (!result)
  {
    sub_1000297A0(-7, @"com.apple.security.cfder.error", 0, a2, v11, @"ccder failed to encode");
    return 0;
  }
  return result;
}

void sub_10000B870(uint64_t a1, char *string)
{
}

uint64_t sub_10000B880(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

size_t sub_10000B890(void *a1, const char *a2, const __CFString *a3, uint64_t a4, __CFString **a5)
{
  if (!a3) {
    return sub_100012A40(-50, a5, @"object for key %s is NULL", a2);
  }
  size_t result = sub_10000FE8C(a3, (CFTypeRef *)a5, (uint64_t)a3, a4, (uint64_t)a5);
  if (result)
  {
    size_t v11 = result;
    unint64_t v12 = (UInt8 *)malloc_type_malloc(result, 0x91A96E61uLL);
    unint64_t v13 = (unint64_t)&v12[v11];
    id v14 = (const void *)sub_10000F7B0(a3, (CFTypeRef *)a5, a4, v12, v13);
    if (v14 && v13 > (unint64_t)v14)
    {
      xpc_dictionary_set_data(a1, a2, v14, v13 - (void)v14);
      free(v12);
      return 1;
    }
    else
    {
      free(v12);
      return 0;
    }
  }
  return result;
}

void *sub_10000B978(void *result, CFTypeRef cf, __CFString **a3)
{
  if (cf
    && (CFStringRef v5 = result, v6 = CFGetTypeID(cf), result = (void *)CFStringGetTypeID(), (void *)v6 == result)
    && (size_t result = sub_10000C614(cf)) != 0
    && (!*v5 || (void *)*v5 == result))
  {
    *CFStringRef v5 = result;
  }
  else if (a3 && !*a3)
  {
    if (cf) {
      int v7 = -25306;
    }
    else {
      int v7 = -50;
    }
    return (void *)sub_100012A40(v7, a3, @"can find class named: %@", cf);
  }
  return result;
}

BOOL sub_10000BA20(const __CFDictionary *a1, uint64_t a2, uint64_t *a3, __CFString **a4)
{
  if (!sub_10000CAEC(a1, 1, a4)) {
    return 0;
  }
  CFArrayRef v8 = *(const __CFArray **)(a2 + 8);
  if (!v8) {
    return sub_100012A40(-34018, a4, @"Client has neither %@ entitlements", @"application-identifier nor keychain-access-groups");
  }
  CFRetain(*(CFTypeRef *)(a2 + 8));
  CFIndex Count = CFArrayGetCount(v8);
  if (!Count)
  {
    CFRelease(v8);
    return sub_100012A40(-34018, a4, @"Client has neither %@ entitlements", @"application-identifier nor keychain-access-groups");
  }
  CFIndex v10 = Count;
  kdebug_trace();
  if (*(unsigned char *)(a2 + 19)
    && CFDictionaryGetValue(a1, kSecValuePersistentRef)
    && _SecItemParsePersistentRef())
  {
    uint64_t v38 = 0;
    int v39 = &v38;
    uint64_t v40 = 0x2000000000;
    v36[0] = 0;
    v36[1] = v36;
    v36[2] = 0x2000000000;
    uint64_t v37 = 0;
    uint64_t v41 = 0;
    values = _NSConcreteStackBlock;
    uint64_t v43 = 0x40000000;
    CFDataRef v44 = sub_100145324;
    int v45 = &unk_100304B70;
    CFArrayRef v48 = 0;
    int v49 = 0;
    int v46 = v36;
    BOOL v47 = &v38;
    char v12 = sub_10000CBA4(0, 1, 0, (uint64_t)&v37, (uint64_t)&values);
    CFStringRef v13 = (const __CFString *)v39[3];
    if ((v12 & 1) == 0 && v13)
    {
      v39[3] = 0;
      CFRelease(v13);
      CFStringRef v13 = 0;
    }
    _Block_object_dispose(v36, 8);
    _Block_object_dispose(&v38, 8);
    if (v13)
    {
      if (CFStringHasSuffix(v13, kSecNetworkExtensionAccessGroupSuffix))
      {
        v50.location = 0;
        v50.size_t length = v10;
        if (!CFArrayContainsValue(v8, v50, v13))
        {
          MutableCopy = CFArrayCreateMutableCopy(0, 0, v8);
          CFArrayAppendValue(MutableCopy, v13);
          CFRelease(v8);
          CFArrayRef v8 = MutableCopy;
        }
      }
      CFRelease(v13);
    }
  }
  v51.location = 0;
  v51.size_t length = v10;
  if (CFArrayContainsValue(v8, v51, @"*") && v8)
  {
    CFRelease(v8);
    CFArrayRef v8 = 0;
  }
  uint64_t v15 = sub_10000C3CC(a1, *(const void **)(a2 + 24), 1, a2, a4);
  if (!v15)
  {
    uint64_t v22 = 0;
    if (!v8) {
      goto LABEL_71;
    }
    goto LABEL_70;
  }
  uint64_t v16 = v15;
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(v15 + 8), kSecAttrAccessGroup);
  if (!Value)
  {
LABEL_27:
    unsigned int v19 = *(_DWORD *)(v16 + 196);
    if (v19)
    {
      if (*(unsigned char *)(a2 + 36))
      {
        CFStringRef v20 = *(const void **)(v16 + 128);
        if (v20)
        {
          *(void *)(v16 + 128) = 0;
          CFRelease(v20);
          unsigned int v19 = *(_DWORD *)(v16 + 196);
        }
        values = (void *)0x114EC8A39FAB1A82;
        unsigned int v21 = bswap32(v19);
        LODWORD(v43) = -397635414;
LABEL_43:
        HIDWORD(v43) = v21;
        CFDataRef v25 = CFDataCreate(0, (const UInt8 *)&values, 16);
LABEL_49:
        *(void *)(v16 + 128) = v25;
LABEL_51:
        sub_10000C278(v16, v8);
        if (*(unsigned char *)(a2 + 44) && (sub_100145440(a2) & 1) == 0)
        {
          int v30 = sub_100012A40(-34020, a4, @"App clips are not permitted to use access groups other than application identifier");
        }
        else
        {
          if (*(_DWORD *)(v16 + 192))
          {
            if (!*(unsigned char *)(a2 + 16))
            {
              CFStringRef v29 = @"client doesn't have entitlement for system keychain";
              goto LABEL_66;
            }
            if (*(_DWORD *)(v16 + 196))
            {
              if (*(unsigned char *)(a2 + 17))
              {
                CFStringRef v29 = @"can't do both system and syncbubble keychain";
LABEL_66:
                int v31 = -34018;
                goto LABEL_67;
              }
LABEL_65:
              CFStringRef v29 = @"client doesn't have entitlement for syncbubble keychain";
              goto LABEL_66;
            }
          }
          else if (*(_DWORD *)(v16 + 196) && !*(unsigned char *)(a2 + 17))
          {
            goto LABEL_65;
          }
          if (*(void *)(v16 + 88))
          {
            CFStringRef v29 = @"use item list unsupported";
LABEL_63:
            int v31 = -50;
LABEL_67:
            int v30 = sub_100012A40(v31, a4, v29);
            goto LABEL_68;
          }
          if (*(void *)(v16 + 176))
          {
            CFDictionaryRef v33 = *(__CFString ***)v16;
            if (v33 != (__CFString **)sub_10000C75C(@"cert", &qword_10035D030, (uint64_t)&unk_10035D028)
              && *(__CFString ***)v16 != &off_1002FFC58)
            {
              CFStringRef v29 = @"unsupported match attribute";
LABEL_86:
              int v31 = -4;
              goto LABEL_67;
            }
          }
          if (*(void *)(v16 + 248))
          {
            BOOL v34 = *(__CFString ***)v16;
            if (v34 != (__CFString **)sub_10000C75C(@"inet", &qword_10035D020, (uint64_t)&unk_10035D018))
            {
              CFStringRef v29 = @"unsupported kSecMatchHostOrSubdomainOfHost attribute";
              goto LABEL_86;
            }
          }
          if (*(void *)(v16 + 208))
          {
            CFDictionaryRef v35 = *(__CFString ***)v16;
            if (v35 != (__CFString **)sub_10000C75C(@"cert", &qword_10035D030, (uint64_t)&unk_10035D028)
              && *(__CFString ***)v16 != &off_1002FFC58)
            {
              CFStringRef v29 = @"unsupported kSecMatchPolicy attribute";
              goto LABEL_86;
            }
          }
          if (!a3 && *(_DWORD *)(v16 + 48))
          {
            CFStringRef v29 = @"missing pointer";
            goto LABEL_63;
          }
          if (*(unsigned char *)(v16 + 116) && CFDictionaryContainsKey(*(CFDictionaryRef *)(v16 + 8), kSecAttrSharingGroup))
          {
            CFStringRef v29 = @"can't copy shared items without Keychain Sharing client entitlement";
            goto LABEL_66;
          }
          if (*(void *)(v16 + 40))
          {
            int v32 = 0;
LABEL_69:
            uint64_t v22 = sub_10000C2C4((const void **)v16, (CFErrorRef *)a4) & v32;
            if (!v8)
            {
LABEL_71:
              kdebug_trace();
              return v22;
            }
LABEL_70:
            CFRelease(v8);
            goto LABEL_71;
          }
          values = _NSConcreteStackBlock;
          uint64_t v43 = 0x40000000;
          CFDataRef v44 = sub_10000CFBC;
          int v45 = &unk_100304A80;
          int v46 = (void *)v16;
          BOOL v47 = a3;
          CFArrayRef v48 = v8;
          int v49 = a4;
          int v30 = sub_10000CBA4(0, 1, 0, (uint64_t)a4, (uint64_t)&values);
        }
LABEL_68:
        int v32 = v30;
        goto LABEL_69;
      }
    }
    else if (*(unsigned char *)(a2 + 36))
    {
      if (*(unsigned char *)(a2 + 18))
      {
        BOOL v23 = *(const void **)(v16 + 128);
        if (v23)
        {
          *(void *)(v16 + 128) = 0;
          CFRelease(v23);
        }
        unsigned int v24 = *(_DWORD *)(a2 + 20);
        values = (void *)0x9A460A992EBEC436;
        unsigned int v21 = bswap32(v24);
        LODWORD(v43) = -1542878804;
        goto LABEL_43;
      }
      uint64_t v26 = (_DWORD *)(v16 + 192);
      int v27 = *(_DWORD *)(v16 + 192);
      if (v27 == 1)
      {
LABEL_46:
        uint64_t v28 = *(const void **)(v16 + 128);
        if (v28)
        {
          *(void *)(v16 + 128) = 0;
          CFRelease(v28);
        }
        CFDataRef v25 = CFDataCreateWithBytesNoCopy(0, byte_10026568C, 16, kCFAllocatorNull);
        goto LABEL_49;
      }
LABEL_45:
      if (v27 != 2)
      {
        _DWORD *v26 = 0;
        goto LABEL_51;
      }
      goto LABEL_46;
    }
    uint64_t v26 = (_DWORD *)(v16 + 192);
    int v27 = *(_DWORD *)(v16 + 192);
    goto LABEL_45;
  }
  uint64_t v18 = (__CFString *)Value;
  if (sub_10000C1A8(v8, Value, a2))
  {
    values = v18;
    if (v8) {
      CFRelease(v8);
    }
    CFArrayRef v8 = CFArrayCreate(0, (const void **)&values, 1, &kCFTypeArrayCallBacks);
    goto LABEL_27;
  }
  sub_100012A40(-34018, a4, @"Client explicitly specifies access group %@ but is only entitled for %@", v18, v8);
  if (v8) {
    CFRelease(v8);
  }
  sub_10000C2C4((const void **)v16, 0);
  return 0;
}

uint64_t sub_10000C1A8(const __CFArray *a1, const __CFString *cf, uint64_t a3)
{
  if (!a1) {
    return 1;
  }
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFStringGetTypeID())
    {
      CFIndex Count = CFArrayGetCount(a1);
      if (Count)
      {
        CFIndex v8 = Count;
        v10.location = 0;
        v10.size_t length = Count;
        if (CFArrayContainsValue(a1, v10, cf)) {
          return 1;
        }
        v11.location = 0;
        v11.size_t length = v8;
        if (CFArrayContainsValue(a1, v11, @"*")
          || a3 && *(unsigned char *)(a3 + 19) && CFStringHasSuffix(cf, kSecNetworkExtensionAccessGroupSuffix))
        {
          return 1;
        }
      }
    }
  }
  return 0;
}

void sub_10000C278(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 184);
  if (v3 != cf)
  {
    if (!cf || (CFRetain(cf), (CFTypeRef v3 = *(CFTypeRef *)(a1 + 184)) != 0)) {
      CFRelease(v3);
    }
    *(void *)(a1 + 184) = cf;
  }
}

uint64_t sub_10000C2C4(const void **a1, CFErrorRef *a2)
{
  uint64_t v3 = sub_10000C588((uint64_t)a1, a2);
  uint64_t v4 = (uint64_t)a1[4];
  if (v4 >= 1)
  {
    CFStringRef v5 = a1 + 34;
    do
    {
      int v7 = *v5;
      v5 += 2;
      CFTypeID v6 = v7;
      if (v7) {
        CFRelease(v6);
      }
      --v4;
    }
    while (v4);
  }
  CFIndex v8 = a1[1];
  if (v8) {
    CFRelease(v8);
  }
  size_t v9 = a1[16];
  if (v9) {
    CFRelease(v9);
  }
  CFRange v10 = a1[21];
  if (v10) {
    CFRelease(v10);
  }
  CFRange v11 = a1[22];
  if (v11) {
    CFRelease(v11);
  }
  char v12 = a1[17];
  if (v12) {
    CFRelease(v12);
  }
  CFStringRef v13 = a1[18];
  if (v13) {
    CFRelease(v13);
  }
  id v14 = a1[23];
  if (v14) {
    CFRelease(v14);
  }
  uint64_t v15 = a1[26];
  if (v15) {
    CFRelease(v15);
  }
  uint64_t v16 = a1[27];
  if (v16) {
    CFRelease(v16);
  }
  CFArrayRef v17 = a1[29];
  if (v17) {
    CFRelease(v17);
  }
  uint64_t v18 = a1[30];
  if (v18) {
    CFRelease(v18);
  }
  unsigned int v19 = a1[10];
  if (v19) {
    CFRelease(v19);
  }
  CFStringRef v20 = a1[31];
  if (v20) {
    CFRelease(v20);
  }
  unsigned int v21 = a1[28];
  if (v21) {
    CFRelease(v21);
  }
  free(a1);
  return v3;
}

uint64_t sub_10000C3CC(const __CFDictionary *a1, const void *a2, uint64_t a3, uint64_t a4, __CFString **a5)
{
  CFStringRef Value = CFDictionaryGetValue(a1, kSecClass);
  if (Value && (CFRange v11 = Value, v12 = CFGetTypeID(Value), v12 == CFStringGetTypeID()))
  {
    uint64_t v15 = sub_10000C614(v11);
    if (v15) {
      goto LABEL_10;
    }
    sub_100012A40(-25306, a5, @"can't find class named: %@", v11);
  }
  else
  {
    CFStringRef v13 = CFDictionaryGetValue(a1, kSecValuePersistentRef);
    if (v13)
    {
      CFTypeID v14 = CFGetTypeID(v13);
      if (v14 == CFDataGetTypeID()) {
        _SecItemParsePersistentRef();
      }
    }
    sub_100012A40(-50, a5, @"query missing class name");
  }
  uint64_t v15 = 0;
LABEL_10:
  uint64_t v16 = sub_10000C7F0((uint64_t)v15, a2, a1, a4, a5);
  uint64_t v17 = (uint64_t)v16;
  if (v16)
  {
    v16[13] = a3;
    CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)sub_100008194, v16);
    if (sub_10000C588(v17, (CFErrorRef *)a5))
    {
      if (!*(unsigned char *)(v17 + 112) && !*(void *)(v17 + 72) && !*(void *)(v17 + 80) && !*(void *)(v17 + 240)) {
        sub_10000DF34(kSecAttrSynchronizable, kCFBooleanFalse, v17);
      }
    }
    else
    {
      sub_10000C2C4((const void **)v17, (CFErrorRef *)a5);
      return 0;
    }
  }
  return v17;
}

uint64_t sub_10000C588(uint64_t a1, CFErrorRef *a2)
{
  uint64_t v3 = *(__CFError **)(a1 + 40);
  *(void *)(a1 + 40) = 0;
  if (a2 && v3)
  {
    if (*a2)
    {
      if (CFErrorGetCode(*a2) != -25330) {
        goto LABEL_9;
      }
      CFErrorRef v4 = *a2;
      if (*a2)
      {
        *a2 = 0;
        CFRelease(v4);
LABEL_9:
        if (*a2) {
          goto LABEL_10;
        }
      }
    }
    uint64_t result = 0;
    *a2 = v3;
    return result;
  }
  if (v3)
  {
    if (!a2)
    {
LABEL_10:
      CFRelease(v3);
      return 0;
    }
    goto LABEL_9;
  }
  return 1;
}

__CFString **sub_10000C614(const void *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 != CFStringGetTypeID()) {
    return 0;
  }
  if (CFEqual(a1, kSecClassGenericPassword))
  {
    CFStringRef v3 = @"genp";
    CFErrorRef v4 = (dispatch_once_t *)&unk_10035D010;
    CFStringRef v5 = &unk_10035D008;
  }
  else if (CFEqual(a1, kSecClassInternetPassword))
  {
    CFStringRef v3 = @"inet";
    CFErrorRef v4 = (dispatch_once_t *)&unk_10035D020;
    CFStringRef v5 = &unk_10035D018;
  }
  else if (CFEqual(a1, kSecClassCertificate))
  {
    CFStringRef v3 = @"cert";
    CFErrorRef v4 = (dispatch_once_t *)&unk_10035D030;
    CFStringRef v5 = &unk_10035D028;
  }
  else
  {
    if (!CFEqual(a1, kSecClassKey))
    {
      if (CFEqual(a1, kSecClassIdentity)) {
        return &off_1002FFC58;
      }
      else {
        return 0;
      }
    }
    CFStringRef v3 = @"keys";
    CFErrorRef v4 = (dispatch_once_t *)&unk_10035D040;
    CFStringRef v5 = &unk_10035D038;
  }

  return (__CFString **)sub_10000C75C((uint64_t)v3, v4, (uint64_t)v5);
}

uint64_t sub_10000C75C(uint64_t a1, dispatch_once_t *predicate, uint64_t a3)
{
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_10013E280;
  v5[3] = &unk_100303A58;
  v5[4] = a3;
  void v5[5] = a1;
  if (*predicate != -1) {
    dispatch_once(predicate, v5);
  }
  return *(void *)a3;
}

void *sub_10000C7F0(uint64_t a1, const void *a2, CFDictionaryRef theDict, uint64_t a4, __CFString **a5)
{
  if (!a1)
  {
    if (a5 && !*a5) {
      sub_100012A40(-50, a5, @"Missing class");
    }
    return 0;
  }
  CFIndex v8 = a2;
  if (!a2)
  {
    if (qword_10035CF58 != -1) {
      dispatch_once(&qword_10035CF58, &stru_1002FAF90);
    }
    CFIndex v8 = (const void *)qword_10035CF60;
  }
  if (!*(void *)(a1 + 16)) {
    goto LABEL_10;
  }
  uint64_t v10 = 0;
  while (*(void *)(a1 + 24 + 8 * v10++))
    ;
  if (!v10)
  {
LABEL_10:
    uint64_t v12 = sub_10000C75C(@"cert", &qword_10035D030, (uint64_t)&unk_10035D028);
    if (*(void *)(v12 + 16))
    {
      uint64_t v13 = 0;
      do
        uint64_t v14 = v13 + 1;
      while (*(void *)(v12 + 24 + 8 * v13++));
    }
    else
    {
      uint64_t v14 = 0;
    }
    uint64_t v16 = sub_10000C75C(@"keys", &qword_10035D040, (uint64_t)&unk_10035D038);
    if (*(void *)(v16 + 16))
    {
      uint64_t v17 = 0;
      do
        uint64_t v18 = v17 + 1;
      while (*(void *)(v16 + 24 + 8 * v17++));
    }
    else
    {
      uint64_t v18 = 0;
    }
    uint64_t v10 = v18 + v14;
  }
  if (theDict)
  {
    v10 += CFDictionaryGetCount(theDict);
    CFStringRef v20 = *(const void ***)(a1 + 16);
    if (v20)
    {
      unsigned int v21 = (const void ***)(a1 + 24);
      do
      {
        v10 -= CFDictionaryContainsKey(theDict, *v20) != 0;
        uint64_t v22 = *v21++;
        CFStringRef v20 = v22;
      }
      while (v22);
    }
  }
  if (v10 >= 129)
  {
    if (a5 && !*a5)
    {
      BOOL v23 = sub_10000B070("SecError");
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        int v28 = 134218240;
        uint64_t v29 = v10;
        __int16 v30 = 1024;
        int v31 = 128;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "key_count: %ld, QUERY_KEY_LIMIT: %d", (uint8_t *)&v28, 0x12u);
      }
      sub_100012A40(-50, a5, @"Past query key limit");
    }
    return 0;
  }
  uint64_t v26 = malloc_type_calloc(1uLL, 16 * v10 + 264, 0x2301482uLL);
  if (!v26)
  {
    if (a5 && !*a5) {
      sub_100012A40(-108, a5, @"Out of memory");
    }
    return 0;
  }
  unsigned int v24 = v26;
  v26[32] = v10;
  v26[16] = CFRetain(v8);
  *((unsigned char *)v24 + 154) = 0;
  *((_DWORD *)v24 + 30) = dword_10035D2B0;
  *unsigned int v24 = a1;
  v24[2] = v10;
  v24[3] = v10;
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  v24[1] = Mutable;
  if (a4)
  {
    if (*(unsigned char *)(a4 + 44)) {
      CFDictionaryAddValue(Mutable, @"clip", kCFBooleanTrue);
    }
    *((unsigned char *)v24 + 116) = *(unsigned char *)(a4 + 57) ^ 1;
  }
  return v24;
}

BOOL sub_10000CAEC(const __CFDictionary *a1, uint64_t a2, __CFString **a3)
{
  if (!CFDictionaryContainsKey(a1, @"clip"))
  {
    if (CFDictionaryContainsKey(a1, kSecAttrSharingGroup))
    {
      if (sub_100145814(a1))
      {
        CFStringRef v6 = @"Can't query the synced keychain with a sharing group";
        goto LABEL_3;
      }
      if (a2 == 2)
      {
        CFStringRef v6 = @"Can't update an item's sharing group";
        goto LABEL_3;
      }
    }
    return 1;
  }
  CFStringRef v6 = @"Non-API attributes present in query";
LABEL_3:

  return sub_100012A40(-50, a3, v6);
}

uint64_t sub_10000CBA4(int a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6 = a4;
  if (a3 && sub_10000CF0C(a4) != a3)
  {
    uint64_t v28 = 0;
    uint64_t v29 = &v28;
    uint64_t v30 = 0x2000000000;
    char v31 = 0;
    if (a1)
    {
      v23[0] = _NSConcreteStackBlock;
      v23[1] = 0x40000000;
      unsigned int v24 = sub_100144518;
      CFDataRef v25 = &unk_100303F18;
      uint64_t v26 = a5;
      int v27 = &v28;
      uint64_t v32 = 0;
      sub_10000CFD0(a3, 0, &v32, v6);
      uint64_t v10 = v32;
      if (v32)
      {
        ((void (*)(void *, uint64_t))v24)(v23, v32);
LABEL_18:
        sub_10000CE08(v10);
      }
    }
    else
    {
      v18[0] = _NSConcreteStackBlock;
      v18[1] = 0x40000000;
      unsigned int v19 = sub_100144554;
      CFStringRef v20 = &unk_100303F40;
      uint64_t v21 = a5;
      uint64_t v22 = &v28;
      uint64_t v32 = 0;
      sub_10000CFD0(a3, 1, &v32, v6);
      uint64_t v10 = v32;
      if (v32)
      {
        ((void (*)(void *, uint64_t))v19)(v18, v32);
        goto LABEL_18;
      }
    }
    uint64_t v6 = *((unsigned char *)v29 + 24) != 0;
    _Block_object_dispose(&v28, 8);
    return v6;
  }
  off_10035CA60();
  if (!*v11)
  {
    uint64_t v14 = v11;
    int v15 = a1 ^ 1;
    if ((v15 & 1) == 0 && a2)
    {
      uint64_t v16 = sub_10000CF0C(0);
      sub_100134054(v16);
    }
    uint64_t v17 = sub_10000CF0C(v6);
    if (v17)
    {
      if (sub_10000CFD0(v17, v15, v14, v6))
      {
        uint64_t v6 = (*(uint64_t (**)(uint64_t, uint64_t))(a5 + 16))(a5, *v14);
        sub_10000CE08(*v14);
        *uint64_t v14 = 0;
        return v6;
      }
    }
    else
    {
      if (!v6) {
        return v6;
      }
      if (!*(void *)v6) {
        sub_100012A40(-25316, (__CFString **)v6, @"failed to get a db handle");
      }
    }
    return 0;
  }
  uint64_t v12 = *(uint64_t (**)(uint64_t))(a5 + 16);

  return v12(a5);
}

void sub_10000CE08(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 16);
    int v3 = *(unsigned __int8 *)(a1 + 24);
    CFErrorRef v4 = *(NSObject **)(v2 + 24);
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = sub_100007068;
    block[3] = &unk_1002F77A0;
    block[4] = a1;
    block[5] = v2;
    char v7 = v3;
    dispatch_sync(v4, block);
    if (v3) {
      dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v2 + 120));
    }
    else {
      pthread_mutex_unlock((pthread_mutex_t *)(v2 + 56));
    }
    CFRelease((CFTypeRef)a1);
    CFRelease((CFTypeRef)v2);
  }
  else
  {
    CFStringRef v5 = sub_10000B070("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "SecDbConnectionRelease called with NULL dbconn", buf, 2u);
    }
  }
}

uint64_t sub_10000CF0C(uint64_t a1)
{
  if (qword_10035D0F8 != -1) {
    dispatch_once(&qword_10035D0F8, &stru_100304A00);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100017E70;
  block[3] = &unk_100304A60;
  block[4] = a1;
  dispatch_sync((dispatch_queue_t)qword_10035D100, block);
  return qword_10035D0E0;
}

BOOL sub_10000CFBC(uint64_t a1, uint64_t a2)
{
  return sub_10000DE00(a2, *(void *)(a1 + 32), *(CFTypeRef **)(a1 + 40), *(void *)(a1 + 48), *(__CFString ***)(a1 + 56));
}

BOOL sub_10000CFD0(uint64_t a1, int a2, void *a3, uint64_t a4)
{
  CFRetain((CFTypeRef)a1);
  if (a2) {
    dispatch_semaphore_wait(*(dispatch_semaphore_t *)(a1 + 120), 0xFFFFFFFFFFFFFFFFLL);
  }
  else {
    pthread_mutex_lock((pthread_mutex_t *)(a1 + 56));
  }
  uint64_t v36 = 0;
  uint64_t v37 = &v36;
  uint64_t v38 = 0x2000000000;
  uint64_t v39 = 0;
  uint64_t v32 = 0;
  CFDictionaryRef v33 = &v32;
  uint64_t v34 = 0x2000000000;
  char v35 = 1;
  uint64_t v28 = 0;
  uint64_t v29 = &v28;
  uint64_t v30 = 0x2000000000;
  char v31 = 0;
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 0x40000000;
  unsigned int v24 = sub_1000077F4;
  CFDataRef v25 = &unk_1002F7730;
  uint64_t v26 = &v36;
  int v27 = a3;
  CFIndex v8 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_1000072D0;
  block[3] = &unk_1002F7758;
  block[8] = a1;
  block[9] = a3;
  block[10] = a4;
  char v22 = a2;
  void block[6] = &v28;
  block[7] = &v36;
  block[4] = v23;
  void block[5] = &v32;
  dispatch_sync(v8, block);
  size_t v9 = v37;
  if (*((unsigned char *)v33 + 24))
  {
    if (!v37[3])
    {
      char v20 = 0;
      uint64_t v10 = sub_1000281CC(a1, a2);
      int v11 = ((uint64_t (*)(void *, uint64_t))v24)(v23, v10);
      size_t v9 = v37;
      if (v11)
      {
        char v12 = sub_1000282E0(v37[3], (uint64_t)&v20, a4);
        size_t v9 = v37;
        if ((v12 & 1) == 0)
        {
          uint64_t v13 = (const void *)v37[3];
          if (v13)
          {
            v37[3] = 0;
            CFRelease(v13);
            size_t v9 = v37;
          }
        }
      }
    }
  }
  uint64_t v14 = v9[3];
  if (v14 && !*((unsigned char *)v29 + 24) && *(void *)(*(void *)(v14 + 16) + 136) && !*(unsigned char *)(v14 + 24))
  {
    uint64_t v16 = *(NSObject **)(a1 + 24);
    v19[0] = _NSConcreteStackBlock;
    v19[1] = 0x40000000;
    v19[2] = sub_1000283D8;
    v19[3] = &unk_1002F7780;
    v19[4] = &v36;
    v19[5] = a1;
    v19[6] = a4;
    dispatch_sync(v16, v19);
    size_t v9 = v37;
  }
  if (a3) {
    *a3 = v9[3];
  }
  uint64_t v15 = v9[3];
  if (!v15)
  {
    if (a2) {
      dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 120));
    }
    else {
      pthread_mutex_unlock((pthread_mutex_t *)(a1 + 56));
    }
    CFRelease((CFTypeRef)a1);
    uint64_t v15 = v37[3];
  }
  BOOL v17 = v15 != 0;
  _Block_object_dispose(&v28, 8);
  _Block_object_dispose(&v32, 8);
  _Block_object_dispose(&v36, 8);
  return v17;
}

uint64_t sub_10000D278(uint64_t a1, int a2, _OWORD *a3)
{
  uint64_t v3 = a1;
  if (a1)
  {
    *(_DWORD *)(v3 + 20) = a2;
    *(void *)(v3 + 24) = 0;
    if (qword_10035CB40 != -1) {
      dispatch_once(&qword_10035CB40, &stru_1002F7018);
    }
    if (byte_10035CB48 == 1)
    {
      *(void *)&long long buf = 0;
      *(unsigned char *)(v3 + 36) = byte_10035CB48;
      int v7 = MKBForegroundUserSessionID();
      *(_DWORD *)(v3 + 40) = v7;
      if ((v7 + 1) <= 1)
      {
        sub_10002BBA0(@"Execution has encountered an unexpected state", 0x53C0000Eu);
        int v7 = 0;
        *(_DWORD *)(v3 + 40) = 0;
      }
      unsigned int v8 = *(_DWORD *)(v3 + 20);
      size_t v9 = sub_10000B070("serverxpc");
      BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG);
      if (v8 < 0x1F6 || v7 == v8)
      {
        if (v10)
        {
          LOWORD(bytes.val[0]) = 0;
          _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "securityd client: active user", (uint8_t *)&bytes, 2u);
        }

        unsigned int v12 = *(_DWORD *)(v3 + 40);
        *(void *)bytes.val = 0x104B57A5353A5AA7;
        bytes.val[2] = -1803342146;
        bytes.val[3] = bswap32(v12);
        *(void *)(v3 + 24) = CFDataCreate(0, (const UInt8 *)&bytes, 16);
        *(_DWORD *)(v3 + 20) = *(_DWORD *)(v3 + 40);
      }
      else
      {
        if (v10)
        {
          LOWORD(bytes.val[0]) = 0;
          _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "securityd client: sync bubble user", (uint8_t *)&bytes, 2u);
        }

        unsigned int v11 = *(_DWORD *)(v3 + 20);
        *(void *)bytes.val = 0x114EC8A39FAB1A82;
        bytes.val[2] = -397635414;
        bytes.val[3] = bswap32(v11);
        *(void *)(v3 + 24) = CFDataCreate(0, (const UInt8 *)&bytes, 16);
      }
      *(_DWORD *)(v3 + 32) = dword_10035D2B0;
    }
    else
    {
      sub_1000118D4(v3);
    }
    long long v13 = a3[1];
    *(_OWORD *)bytes.val = *a3;
    *(_OWORD *)&bytes.val[4] = v13;
    uint64_t v14 = SecTaskCreateWithAuditToken(kCFAllocatorDefault, &bytes);
    *(void *)uint64_t v3 = v14;
    BOOL v15 = sub_10000DC40(v14, @"com.apple.developer.on-demand-install-capable");
    CFArrayRef v16 = (const __CFArray *)sub_10000DCB0(v14, @"keychain-access-groups");
    CFArrayRef v17 = (const __CFArray *)sub_10000DCB0(v14, @"com.apple.security.application-groups");
    uint64_t v18 = sub_10000DD54(v14);
    CFArrayRef v19 = (const __CFArray *)sub_10000DCB0(v14, @"com.apple.developer.associated-application-identifier");
    CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
    if (v16)
    {
      v58.size_t length = CFArrayGetCount(v16);
      v58.location = 0;
      CFArrayAppendArray(Mutable, v16, v58);
    }
    if (v19)
    {
      v59.size_t length = CFArrayGetCount(v19);
      v59.location = 0;
      CFArrayAppendArray(Mutable, v19, v59);
    }
    if (v18) {
      CFArrayAppendValue(Mutable, v18);
    }
    if (v17)
    {
      if (v15)
      {
        uint64_t v21 = sub_10000B070("entitlements");
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          bytes.val[0] = 138412290;
          *(void *)&bytes.val[1] = @"com.apple.security.application-groups";
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Ignoring \"%@\" because client is API-restricted", (uint8_t *)&bytes, 0xCu);
        }
      }
      else
      {
        v60.size_t length = CFArrayGetCount(v17);
        v60.location = 0;
        CFArrayAppendArray(Mutable, v17, v60);
      }
    }
    v55.size_t length = CFArrayGetCount(Mutable);
    v55.location = 0;
    FirstIndexOfCFStringRef Value = CFArrayGetFirstIndexOfValue(Mutable, v55, kSecAttrAccessGroupToken);
    if (FirstIndexOfValue != -1)
    {
      CFIndex v23 = FirstIndexOfValue;
      if (!_os_feature_enabled_impl())
      {
        uint64_t v34 = sub_10000B070("SecWarning");
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(bytes.val[0]) = 0;
          _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Keychain access group com.apple.token ignored, feature not available", (uint8_t *)&bytes, 2u);
        }
        CFArrayRemoveValueAtIndex(Mutable, v23);
        if (!v19)
        {
LABEL_33:
          if (v18) {
            CFRelease(v18);
          }
          if (v16) {
            CFRelease(v16);
          }
          if (v17) {
            CFRelease(v17);
          }
          *(void *)(v3 + 8) = Mutable;
          *(void *)(v3 + 48) = sub_10000DD54(*(__SecTask **)v3);
          BOOL v24 = sub_10000DC40(*(__SecTask **)v3, @"com.apple.developer.on-demand-install-capable");
          *(unsigned char *)(v3 + 44) = v24;
          if (v24)
          {
            CFDataRef v25 = sub_10000B070("serverxpc");
            if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
            {
              LOWORD(bytes.val[0]) = 0;
              _os_log_debug_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEBUG, "securityd client: app clip (API restricted)", (uint8_t *)&bytes, 2u);
            }
          }
          *(unsigned char *)(v3 + 57) = sub_10000DC40(*(__SecTask **)v3, @"com.apple.private.keychain.kcsharing.client");
          *(unsigned char *)(v3 + 16) = sub_10000DC40(*(__SecTask **)v3, @"com.apple.private.system-keychain");
          *(unsigned char *)(v3 + 18) = sub_10000DC40(*(__SecTask **)v3, @"com.apple.developer.networking.networkextension");
          *(unsigned char *)(v3 + 19) = sub_10000DC40(*(__SecTask **)v3, @"com.apple.networkextension.keychain");
          if (*(unsigned char *)(v3 + 36)) {
            *(unsigned char *)(v3 + 17) = sub_10000DC40(*(__SecTask **)v3, @"com.apple.private.syncbubble-keychain");
          }
          CFArrayRef v26 = *(const __CFArray **)(v3 + 8);
          if (!v26) {
            goto LABEL_91;
          }
          v56.size_t length = CFArrayGetCount(v26);
          v56.location = 0;
          if (!CFArrayContainsValue(*(CFArrayRef *)(v3 + 8), v56, @"*")) {
            goto LABEL_91;
          }
          int v27 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
          if (SecIsInternalRelease()) {
            CFArrayAppendValue(v27, @"com.apple.security-cli");
          }
          uint64_t v28 = *(__SecTask **)v3;
          if (*(void *)v3)
          {
            uint32_t CodeSignStatus = SecTaskGetCodeSignStatus(*(SecTaskRef *)v3);
            if ((CodeSignStatus & 0xC000001) == 0x4000001)
            {
LABEL_51:
              CFStringRef v30 = SecTaskCopySigningIdentifier(v28, 0);
              CFStringRef v31 = v30;
              if (!v27)
              {
                uint64_t v43 = sub_10000B070("serverxpc");
                if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
                {
                  LODWORD(buf) = 138412290;
                  *(void *)((char *)&buf + 4) = v31;
                  _os_log_debug_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEBUG, "Client %@ is valid platform binary", (uint8_t *)&buf, 0xCu);
                }

                if (v31) {
                  CFRelease(v31);
                }
                goto LABEL_91;
              }
              if (v30)
              {
                *(void *)&long long buf = 0;
                *((void *)&buf + 1) = &buf;
                uint64_t v53 = 0x2020000000;
                char v54 = 0;
                *(void *)bytes.val = _NSConcreteStackBlock;
                *(void *)&bytes.val[2] = 3221225472;
                *(void *)&bytes.val[4] = sub_100020F0C;
                *(void *)&bytes.val[6] = &unk_1003087F0;
                p_long long buf = &buf;
                CFStringRef v51 = v30;
                uint64_t v32 = &bytes;
                v57.size_t length = CFArrayGetCount(v27);
                v57.location = 0;
                CFArrayApplyFunction(v27, v57, (CFArrayApplierFunction)sub_100020F50, v32);

                if (*(unsigned char *)(*((void *)&buf + 1) + 24))
                {
                  CFDictionaryRef v33 = sub_10000B070("serverxpc");
                  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
                  {
                    int v47 = 138412290;
                    CFStringRef v48 = v31;
                    _os_log_debug_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEBUG, "client %@ is eligible platform binary", (uint8_t *)&v47, 0xCu);
                  }
                }
                else
                {
                  CFDictionaryRef v33 = sub_10000B070("SecError");
                  if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
                  {
                    int v47 = 138412290;
                    CFStringRef v48 = v31;
                    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "serverxpc: client %@ is not eligible", (uint8_t *)&v47, 0xCu);
                  }
                }

                CFRelease(v31);
                BOOL v45 = *(unsigned char *)(*((void *)&buf + 1) + 24) == 0;
                _Block_object_dispose(&buf, 8);
                CFRelease(v27);
                if (!v45)
                {
LABEL_91:
                  uint64_t v3 = 1;
LABEL_92:
                  return v3;
                }
LABEL_72:
                uint64_t v39 = *(__SecTask **)v3;
                if (*(void *)v3)
                {
                  *(void *)uint64_t v3 = 0;
                  CFRelease(v39);
                }
                uint64_t v40 = *(const void **)(v3 + 8);
                if (v40)
                {
                  *(void *)(v3 + 8) = 0;
                  CFRelease(v40);
                }
                uint64_t v41 = *(const void **)(v3 + 24);
                if (v41)
                {
                  *(void *)(v3 + 24) = 0;
                  CFRelease(v41);
                }
                CFTypeRef v42 = *(const void **)(v3 + 48);
                if (v42)
                {
                  *(void *)(v3 + 48) = 0;
                  CFRelease(v42);
                }
                uint64_t v3 = 0;
                goto LABEL_92;
              }
              CFDataRef v44 = sub_10000B070("SecError");
              if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
              {
                LOWORD(buf) = 0;
                _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "serverxpc: client has no codesign identifier", (uint8_t *)&buf, 2u);
              }

LABEL_71:
              CFRelease(v27);
              goto LABEL_72;
            }
            if (SecIsInternalRelease())
            {
              if ((CodeSignStatus & 0x1C000000) == 0x14000000) {
                goto LABEL_51;
              }
              char v35 = sub_10000B070("SecError");
              if (!os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
              {
LABEL_70:

                if (!v27) {
                  goto LABEL_72;
                }
                goto LABEL_71;
              }
              LODWORD(buf) = 67109120;
              DWORD1(buf) = CodeSignStatus;
              uint64_t v36 = "serverxpc: client is not a platform binary: 0x%08x";
            }
            else
            {
              char v35 = sub_10000B070("SecError");
              if (!os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT)) {
                goto LABEL_70;
              }
              LODWORD(buf) = 67109120;
              DWORD1(buf) = CodeSignStatus;
              uint64_t v36 = "serverxpc: client is not a platform binary: 0x%08x";
            }
            uint64_t v37 = v35;
            uint32_t v38 = 8;
          }
          else
          {
            char v35 = sub_10000B070("SecError");
            if (!os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_70;
            }
            LOWORD(buf) = 0;
            uint64_t v36 = "serverxpc: Client task is null, cannot verify platformness";
            uint64_t v37 = v35;
            uint32_t v38 = 2;
          }
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, v36, (uint8_t *)&buf, v38);
          goto LABEL_70;
        }
LABEL_32:
        CFRelease(v19);
        goto LABEL_33;
      }
      CFArrayRemoveValueAtIndex(Mutable, v23);
      CFArrayAppendValue(Mutable, kSecAttrAccessGroupToken);
    }
    if (!v19) {
      goto LABEL_33;
    }
    goto LABEL_32;
  }
  return v3;
}

void sub_10000DC1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_10000DC40(__SecTask *a1, const __CFString *a2)
{
  CFTypeRef v2 = SecTaskCopyValueForEntitlement(a1, a2, 0);
  if (!v2) {
    return 0;
  }
  uint64_t v3 = v2;
  CFTypeID TypeID = CFBooleanGetTypeID();
  BOOL v5 = TypeID == CFGetTypeID(v3) && CFBooleanGetValue((CFBooleanRef)v3) != 0;
  CFRelease(v3);
  return v5;
}

const void *sub_10000DCB0(__SecTask *a1, const __CFString *a2)
{
  CFTypeRef v2 = SecTaskCopyValueForEntitlement(a1, a2, 0);
  uint64_t v3 = v2;
  if (v2)
  {
    CFTypeID v4 = CFGetTypeID(v2);
    if (v4 != CFArrayGetTypeID())
    {
LABEL_8:
      CFRelease(v3);
      return 0;
    }
    CFIndex Count = CFArrayGetCount((CFArrayRef)v3);
    if (Count >= 1)
    {
      CFIndex v6 = Count;
      CFIndex v7 = 0;
      while (1)
      {
        CFDataRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v3, v7);
        CFTypeID v9 = CFGetTypeID(ValueAtIndex);
        if (v9 != CFStringGetTypeID()) {
          break;
        }
        if (v6 == ++v7) {
          return v3;
        }
      }
      goto LABEL_8;
    }
  }
  return v3;
}

const void *sub_10000DD54(__SecTask *a1)
{
  uint64_t result = sub_10000DDAC(a1, @"application-identifier");
  if (!result)
  {
    return sub_10000DDAC(a1, @"com.apple.application-identifier");
  }
  return result;
}

const void *sub_10000DDAC(__SecTask *a1, const __CFString *a2)
{
  CFTypeRef v2 = SecTaskCopyValueForEntitlement(a1, a2, 0);
  uint64_t v3 = v2;
  if (v2)
  {
    CFTypeID v4 = CFGetTypeID(v2);
    if (v4 != CFStringGetTypeID())
    {
      CFRelease(v3);
      return 0;
    }
  }
  return v3;
}

BOOL sub_10000DE00(uint64_t a1, uint64_t a2, CFTypeRef *a3, uint64_t a4, __CFString **a5)
{
  v13[0] = a2;
  v13[1] = a4;
  v13[2] = a1;
  CFTypeRef cf = 0;
  CFDataRef v8 = *(const __CFData **)(a2 + 80);
  if (v8 && CFDataGetLength(v8) == 16 && *(void *)(a2 + 32))
  {
    CFStringRef v9 = @"attributes to query illegal; both persistent ref and other attributes can't be searched at the same time";
LABEL_16:
    return sub_100012A40(-50, a5, v9);
  }
  if (*(void *)(a2 + 240) && *(void *)(a2 + 32) != 1)
  {
    CFStringRef v9 = @"attributes to query illegal; both token persistent ref and other attributes can't be searched at the same time";
    goto LABEL_16;
  }
  BOOL v10 = (const void *)kSecAttrTombstone;
  if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(a2 + 8), kSecAttrTombstone)) {
    sub_10000DF34(v10, kCFBooleanFalse, a2);
  }
  unint64_t v15 = 0xAAAAAAAA00000000;
  BOOL v11 = sub_100010A40((uint64_t)sub_100012EE0, (uint64_t)v13, a5);
  if (a3 && v11)
  {
    *a3 = cf;
    return 1;
  }
  else if (cf)
  {
    CFRelease(cf);
  }
  return v11;
}

void sub_10000DF34(const void *a1, const __CFBoolean *a2, uint64_t a3)
{
  if (CFEqual(a1, kSecAttrDeriveSyncIDFromItemAttributes))
  {
    *(unsigned char *)(a3 + 154) = CFBooleanGetValue(a2) != 0;
  }
  else if (CFEqual(a1, @"persistref"))
  {
    if (a2) {
      CFRetain(a2);
    }
    *(void *)(a3 + 80) = a2;
  }
  else
  {
    CFIndex v6 = sub_10000FD40(*(__CFString ***)a3, a1, (__CFString **)(a3 + 40));
    if (v6)
    {
      CFIndex v7 = v6;
      sub_10000E0A8(v6, a2, a3);
      int v8 = *((_DWORD *)v7 + 2);
      if (v8 == 15)
      {
        if (CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 8), *v7))
        {
          CFStringRef v9 = (const void *)SecAccessControlCreateFromData();
          if (v9)
          {
            BOOL v10 = v9;
            sub_100012D84(a3, v9);
            CFRelease(v10);
          }
        }
        int v8 = *((_DWORD *)v7 + 2);
      }
      if (v8 == 14)
      {
        uint64_t v11 = SecAccessControlCreate();
        if (v11)
        {
          unsigned int v12 = (const void *)v11;
          if (CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 8), *v7) && SecAccessControlSetProtection()) {
            sub_100012D84(a3, v12);
          }
          CFRelease(v12);
        }
      }
    }
  }
}

void sub_10000E0A8(void *a1, const __CFData *a2, uint64_t a3)
{
  if (!CFEqual((CFTypeRef)*a1, kSecAttrSynchronizable)
    || (*(unsigned char *)(a3 + 112) = 1, !CFEqual(a2, kSecAttrSynchronizableAny)))
  {
    switch(*((_DWORD *)a1 + 2))
    {
      case 0:
      case 0xF:
        CFIndex v6 = (__CFString *)sub_10000E4C0(a2);
        goto LABEL_11;
      case 1:
        CFIndex v6 = (__CFString *)sub_10000E3E0((const __CFString *)a2);
        goto LABEL_11;
      case 2:
      case 0xE:
        CFIndex v6 = (__CFString *)sub_10000E568((const __CFString *)a2);
        goto LABEL_11;
      case 3:
      case 0xB:
      case 0xC:
        CFIndex v6 = (__CFString *)sub_10000E2F0(a2);
        goto LABEL_11;
      case 4:
      case 5:
      case 6:
        CFIndex v6 = (__CFString *)sub_100017DBC(a2);
        goto LABEL_11;
      case 7:
        CFIndex v6 = (__CFString *)sub_100004398(a2);
        goto LABEL_11;
      case 0x10:
        CFIndex v6 = (__CFString *)sub_100004024(a2);
LABEL_11:
        CFMutableArrayRef Mutable = v6;
        if (!v6) {
          goto LABEL_21;
        }
        int v8 = *(__CFDictionary **)(a3 + 8);
        if (v8 && *((_DWORD *)a1 + 2) != 7) {
          CFDictionarySetValue(v8, (const void *)*a1, Mutable);
        }
        if ((a1[2] & 8) == 0) {
          goto LABEL_18;
        }
        CFDataRef v9 = sub_10000E3E0(Mutable);
        CFRelease(Mutable);
        if (!v9)
        {
          sub_100012A40(-26276, (__CFString **)(a3 + 40), @"failed to get attribute %@ data", *a1);
          return;
        }
        CFMutableArrayRef Mutable = (__CFString *)CFDataCreateMutable(0, 20);
        CFDataSetLength((CFMutableDataRef)Mutable, 20);
        CFDataGetBytePtr(v9);
        CFDataGetLength(v9);
        CFDataGetMutableBytePtr((CFMutableDataRef)Mutable);
        CCDigest();
        CFRelease(v9);
LABEL_18:
        if (*((_DWORD *)a1 + 2) == 15)
        {
          if (!Mutable) {
            return;
          }
LABEL_25:
          CFRelease(Mutable);
          return;
        }
        uint64_t v10 = *(void *)(a3 + 32);
        if (v10 + 1 < *(void *)(a3 + 256))
        {
          uint64_t v11 = (const void *)*a1;
          *(void *)(a3 + 32) = v10 + 1;
          uint64_t v12 = a3 + 16 * v10;
          *(void *)(v12 + 264) = v11;
          *(void *)(v12 + 272) = Mutable;
          return;
        }
        sub_100012A40(-26276, (__CFString **)(a3 + 40), @"q_pairs overflow");
        if (Mutable) {
          goto LABEL_25;
        }
        break;
      default:
LABEL_21:
        sub_100012A40(-50, (__CFString **)(a3 + 40), @"attribute %@: value: %@ failed to convert", *a1, a2);
        return;
    }
  }
}

CFNumberRef sub_10000E2F0(const __CFBoolean *a1)
{
  CFBooleanRef v1 = a1;
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 != CFNumberGetTypeID())
  {
    if (v2 == CFBooleanGetTypeID())
    {
      HIDWORD(valuePtr) = CFBooleanGetValue(v1);
      p_uint64_t valuePtr = (char *)&valuePtr + 4;
    }
    else
    {
      if (v2 != CFStringGetTypeID()) {
        return 0;
      }
      LODWORD(valuePtr) = CFStringGetIntValue((CFStringRef)v1);
      CFStringRef v4 = CFStringCreateWithFormat(0, 0, @"%ld", (int)valuePtr, valuePtr);
      int v5 = CFEqual(v4, v1);
      CFRelease(v4);
      if (!v5) {
        return (CFNumberRef)CFStringCreateCopy(0, (CFStringRef)v1);
      }
      p_uint64_t valuePtr = (char *)&valuePtr;
    }
    return CFNumberCreate(0, kCFNumberSInt32Type, p_valuePtr);
  }
  CFRetain(v1);
  return v1;
}

CFDataRef sub_10000E3E0(const __CFString *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == CFDataGetTypeID())
  {
    return CFDataCreateCopy(0, (CFDataRef)a1);
  }
  else if (v2 == CFStringGetTypeID())
  {
    return CFStringCreateExternalRepresentation(0, a1, 0x8000100u, 0);
  }
  else if (v2 == CFNumberGetTypeID())
  {
    int valuePtr = -1431655766;
    CFNumberGetValue((CFNumberRef)a1, kCFNumberSInt32Type, &valuePtr);
    return CFDataCreate(0, (const UInt8 *)&valuePtr, 4);
  }
  else
  {
    return 0;
  }
}

CFStringRef sub_10000E4C0(const __CFData *a1)
{
  CFDataRef v1 = a1;
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == CFDataGetTypeID())
  {
    return (CFStringRef)CFDataCreateCopy(0, v1);
  }
  else if (v2 == CFStringGetTypeID())
  {
    return CFStringCreateCopy(0, (CFStringRef)v1);
  }
  else
  {
    if (v2 != CFNumberGetTypeID()) {
      return 0;
    }
    CFRetain(v1);
    return (CFStringRef)v1;
  }
}

CFStringRef sub_10000E568(const __CFString *a1)
{
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 == CFStringGetTypeID())
  {
    return CFStringCreateCopy(0, a1);
  }
  else if (v2 == CFDataGetTypeID())
  {
    return CFStringCreateFromExternalRepresentation(0, (CFDataRef)a1, 0x8000100u);
  }
  else if (v2 == CFUUIDGetTypeID())
  {
    return CFUUIDCreateString(0, (CFUUIDRef)a1);
  }
  else
  {
    return 0;
  }
}

uint64_t sub_10000E62C(sqlite3_stmt *a1, uint64_t a2, const __CFArray *a3, _DWORD *a4, CFTypeRef *a5)
{
  uint64_t v10 = *a4;
  uint64_t v11 = *(void *)(a2 + 32);
  if (v11 >= 1)
  {
    uint64_t v12 = (const __CFString **)(a2 + 272);
    do
    {
      uint64_t v13 = v10;
      uint64_t v10 = (v10 + 1);
      CFStringRef v14 = *v12;
      v12 += 2;
      if ((sub_10000E8B0(a1, v13, v14, a5) & 1) == 0) {
        goto LABEL_20;
      }
    }
    while (--v11);
  }
  unsigned int v25 = -1431655766;
  if (!sub_1000114F8(*(const __CFData **)(a2 + 128), &v25))
  {
    if (sub_100011498(*(CFTypeRef *)(a2 + 128)))
    {
      *(_DWORD *)audit_token_t bytes = v10;
      goto LABEL_25;
    }
    CFArrayRef v19 = *(const void **)(a2 + 128);
    if (v19)
    {
      CFTypeID v20 = CFGetTypeID(v19);
      if (v20 == CFNullGetTypeID())
      {
        if (qword_10035CF58 != -1) {
          dispatch_once(&qword_10035CF58, &stru_1002FAF90);
        }
        CFStringRef v21 = (const __CFString *)qword_10035CF60;
      }
      else
      {
        CFStringRef v21 = *(const __CFString **)(a2 + 128);
      }
    }
    else
    {
      CFStringRef v21 = 0;
    }
    LODWORD(v15) = v10 + 1;
    char v23 = sub_10000E8B0(a1, v10, v21, a5);
    *(_DWORD *)audit_token_t bytes = v10 + 1;
    if (v23)
    {
      uint64_t v10 = (v10 + 1);
      goto LABEL_25;
    }
LABEL_29:
    uint64_t result = 0;
    LODWORD(v10) = v15;
    goto LABEL_30;
  }
  if (qword_10035CF48 != -1) {
    dispatch_once(&qword_10035CF48, &stru_1002FAF50);
  }
  uint64_t v15 = (v10 + 1);
  if ((sub_10000E8B0(a1, v10, (const __CFString *)qword_10035CF50, a5) & 1) == 0) {
    goto LABEL_29;
  }
  *(void *)audit_token_t bytes = 0x104B57A5353A5AA7;
  int v27 = -1803342146;
  unsigned int v28 = bswap32(v25);
  CFStringRef v16 = (const __CFString *)CFDataCreate(0, bytes, 16);
  uint64_t v10 = (v10 + 2);
  int v17 = sub_10000E8B0(a1, v15, v16, a5);
  char v18 = v17;
  if (v16)
  {
    CFRelease(v16);
    *(_DWORD *)audit_token_t bytes = v10;
    if (v18) {
      goto LABEL_25;
    }
LABEL_20:
    uint64_t result = 0;
    goto LABEL_30;
  }
  *(_DWORD *)audit_token_t bytes = v10;
  if (!v17) {
    goto LABEL_20;
  }
LABEL_25:
  CFDataRef v24 = *(const __CFData **)(a2 + 80);
  if (v24
    && CFDataGetLength(v24) == 16
    && (uint64_t result = sub_10000E8B0(a1, v10, *(const __CFString **)(a2 + 80), a5), *(_DWORD *)bytes = v10 + 1,
                                                                              !result))
  {
    LODWORD(v10) = v10 + 1;
  }
  else
  {
    uint64_t result = sub_100010978(a1, a3, (int *)bytes, a5);
    LODWORD(v10) = *(_DWORD *)bytes;
  }
LABEL_30:
  *a4 = v10;
  return result;
}

uint64_t sub_10000E8B0(sqlite3_stmt *a1, uint64_t a2, const __CFString *cf, CFTypeRef *a4)
{
  CFStringRef v4 = &v26;
  uint64_t v26 = 0;
  int v27 = &v26;
  uint64_t v28 = 0x2000000000;
  char v29 = 0;
  if (!cf) {
    goto LABEL_4;
  }
  CFTypeID v9 = CFGetTypeID(cf);
  if (v9 == CFNullGetTypeID())
  {
    CFStringRef v4 = v27;
LABEL_4:
    *((unsigned char *)v4 + 24) = 1;
    goto LABEL_5;
  }
  if (v9 == CFStringGetTypeID())
  {
    v24[0] = _NSConcreteStackBlock;
    v24[1] = 0x40000000;
    v24[2] = sub_10000ECA4;
    v24[3] = &unk_1002F77F0;
    v24[4] = &v26;
    v24[5] = a1;
    int v25 = a2;
    v24[6] = a4;
    sub_10000EB80(cf, (uint64_t)v24);
    goto LABEL_5;
  }
  if (v9 == CFDataGetTypeID())
  {
    CFIndex Length = CFDataGetLength((CFDataRef)cf);
    if (Length)
    {
      unint64_t v13 = Length;
      BytePtr = CFDataGetBytePtr((CFDataRef)cf);
      BOOL v15 = sub_10000EE7C(a1, a2, BytePtr, v13, a4);
    }
    else
    {
      uint64_t v19 = sqlite3_bind_text(a1, a2, "", 0, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
      BOOL v15 = sub_10000ED34(v19, a1, a4, @"bind_text[%d]", a2);
    }
    goto LABEL_16;
  }
  if (v9 == CFDateGetTypeID())
  {
    double AbsoluteTime = CFDateGetAbsoluteTime((CFDateRef)cf);
    uint64_t v17 = sqlite3_bind_double(a1, a2, AbsoluteTime);
    BOOL v15 = sub_10000ED34(v17, a1, a4, @"bind_double[%d]", a2);
LABEL_16:
    *((unsigned char *)v27 + 24) = v15;
    goto LABEL_5;
  }
  if (v9 == CFBooleanGetTypeID())
  {
    int Value = CFBooleanGetValue((CFBooleanRef)cf);
    BOOL v15 = sub_100028FD0(a1, a2, Value, a4);
    goto LABEL_16;
  }
  if (v9 == CFNumberGetTypeID())
  {
    if (CFNumberIsFloatType((CFNumberRef)cf))
    {
      double valuePtr = NAN;
      int v20 = CFNumberGetValue((CFNumberRef)cf, kCFNumberDoubleType, &valuePtr);
      BOOL v21 = sub_100028F7C(a1, a2, a4, valuePtr);
    }
    else
    {
      double valuePtr = -3.72066208e-103;
      int v20 = CFNumberGetValue((CFNumberRef)cf, kCFNumberSInt64Type, &valuePtr);
      if (!v20) {
        goto LABEL_26;
      }
      BOOL v21 = sub_10000EE28(a1, a2, *(sqlite3_int64 *)&valuePtr, a4);
    }
    *((unsigned char *)v27 + 24) = v21;
LABEL_26:
    if (!v20)
    {
      sub_1000263CC(2, a4, @"bind CFNumberGetValue failed for %@", cf);
      *((unsigned char *)v27 + 24) = 0;
    }
    goto LABEL_5;
  }
  if (a4)
  {
    CFStringRef v22 = CFCopyTypeIDDescription(v9);
    sub_1000263CC(20, a4, @"bind unsupported type %@", v22);
    if (v22) {
      CFRelease(v22);
    }
  }
LABEL_5:
  uint64_t v10 = *((unsigned __int8 *)v27 + 24);
  _Block_object_dispose(&v26, 8);
  return v10;
}

void sub_10000EB80(const __CFString *a1, uint64_t a2)
{
  CStringPtr = CFStringGetCStringPtr(a1, 0x8000100u);
  if (CStringPtr)
  {
    int v5 = CStringPtr;
    size_t v6 = strlen(CStringPtr);
    CFIndex v7 = *(void (**)(uint64_t, const char *, size_t))(a2 + 16);
    v7(a2, v5, v6);
  }
  else
  {
    CFIndex usedBufLen = 0;
    CFIndex Length = CFStringGetLength(a1);
    v12.location = 0;
    v12.size_t length = Length;
    CFStringGetBytes(a1, v12, 0x8000100u, 0, 0, 0, 0, &usedBufLen);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000;
    v9[2] = sub_100010738;
    v9[3] = &unk_1002F73E0;
    v9[6] = 0;
    v9[7] = Length;
    v9[8] = usedBufLen;
    v9[4] = a2;
    v9[5] = a1;
    sub_1000105B0(usedBufLen + 1, (uint64_t)v9);
  }
}

BOOL sub_10000ECA4(uint64_t a1, char *a2, unint64_t a3)
{
  uint64_t v4 = *(unsigned int *)(a1 + 56);
  size_t v6 = *(sqlite3_stmt **)(a1 + 40);
  int v5 = *(CFTypeRef **)(a1 + 48);
  if (a3 >> 31)
  {
    BOOL result = sub_10000ED34(18, v6, v5, @"bind_text[%d]: text bigger than INT_MAX", *(unsigned int *)(a1 + 56));
  }
  else
  {
    uint64_t v8 = sqlite3_bind_text(*(sqlite3_stmt **)(a1 + 40), v4, a2, a3, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
    BOOL result = sub_10000ED34(v8, v6, v5, @"bind_text[%d]", v4);
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

BOOL sub_10000ED34(uint64_t a1, sqlite3_stmt *a2, CFTypeRef *a3, CFStringRef format, ...)
{
  va_start(va, format);
  if (a1 && a3)
  {
    CFStringRef v7 = CFStringCreateWithFormatAndArguments(kCFAllocatorDefault, 0, format, va);
    uint64_t v8 = sqlite3_db_handle(a2);
    CFTypeID v9 = sqlite3_sql(a2);
    uint64_t v10 = sqlite3_extended_errcode(v8);
    uint64_t v11 = sqlite3_errmsg(v8);
    if (v10 == a1) {
      sub_1000263CC(a1, a3, @"%@: [%d] %s sql: %s", v7, a1, v11, v9, v13, va);
    }
    else {
      sub_1000263CC(a1, a3, @"%@: [%d->%d] %s sql: %s", v7, a1, v10, v11, v9, va);
    }
    if (v7) {
      CFRelease(v7);
    }
  }
  return a1 == 0;
}

BOOL sub_10000EE28(sqlite3_stmt *a1, uint64_t a2, sqlite3_int64 a3, CFTypeRef *a4)
{
  uint64_t v7 = sqlite3_bind_int64(a1, a2, a3);
  return sub_10000ED34(v7, a1, a4, @"bind_int64[%d]", a2);
}

BOOL sub_10000EE7C(sqlite3_stmt *a1, uint64_t a2, const void *a3, unint64_t a4, CFTypeRef *a5)
{
  if (a4 >> 31) {
    return sub_10000ED34(18, a1, a5, @"bind_blob[%d]: blob bigger than INT_MAX", a2);
  }
  uint64_t v9 = sqlite3_bind_blob(a1, a2, a3, a4, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
  return sub_10000ED34(v9, a1, a5, @"bind_blob[%d]", a2);
}

uint64_t sub_10000EEF8(const __CFAllocator *a1, void *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5)
{
  if (a4)
  {
    uint64_t v9 = ccder_decode_constructed_tl();
    if (v9)
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      if (Mutable)
      {
        CFRelease(Mutable);
      }
      else
      {
        sub_1000297A0(-3, @"com.apple.security.cfder.error", 0, a3, v10, @"Failed to create dictionary");
        uint64_t v9 = 0;
        *a2 = 0;
      }
    }
    else
    {
      sub_1000297A0(-1, @"com.apple.security.cfder.error", 0, a3, v8, @"Unknown data encoding, expected CCDER_CONSTRUCTED_SET");
    }
  }
  else
  {
    sub_1000297A0(-6, @"com.apple.security.cfder.error", 0, a3, a5, @"null input");
    return 0;
  }
  return v9;
}

uint64_t sub_10000F124(int a1, int a2, CFTypeRef *a3, uint64_t a4, uint64_t a5)
{
  if (a4)
  {
    if (ccder_decode_tag()) {
      sub_1000297A0(-2, @"com.apple.security.cfder.error", 0, a3, v6, @"Unsupported DER Type", 0xAAAAAAAAAAAAAAAALL);
    }
    else {
      sub_1000297A0(-1, @"com.apple.security.cfder.error", 0, a3, v6, @"invalid tag", 0xAAAAAAAAAAAAAAAALL);
    }
  }
  else
  {
    sub_1000297A0(-6, @"com.apple.security.cfder.error", 0, a3, a5, @"null input");
  }
  return 0;
}

const UInt8 *sub_10000F564(const __CFAllocator *a1, CFStringRef *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5)
{
  if (a4)
  {
    uint64_t v9 = (const UInt8 *)ccder_decode_tl();
    if (v9 && (uint64_t v11 = v9, a5 - (uint64_t)v9 >= 0))
    {
      CFStringRef v13 = CFStringCreateWithBytes(a1, v9, 0, 0x8000100u, 0);
      *a2 = v13;
      if (v13) {
        return v11;
      }
      sub_1000297A0(-3, @"com.apple.security.cfder.error", 0, a3, v14, @"String allocation failed");
    }
    else
    {
      sub_1000297A0(-1, @"com.apple.security.cfder.error", 0, a3, v10, @"Unknown string encoding");
    }
  }
  else
  {
    sub_1000297A0(-6, @"com.apple.security.cfder.error", 0, a3, a5, @"null input");
  }
  return 0;
}

void sub_10000F65C(const __CFString *a1, const __CFString *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(unsigned char *)a3)
  {
    CFIndex v8 = sub_10000FB18(a1, a2, *(CFTypeRef **)(a3 + 8), a4, a5);
    if (!v8)
    {
      *(unsigned char *)a3 = 0;
      return;
    }
    CFIndex v9 = v8;
    CFMutableDictionaryRef Mutable = CFDataCreateMutable(*(CFAllocatorRef *)(a3 + 24), v8);
    CFDataSetLength(Mutable, v9);
    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    CFRange v12 = &MutableBytePtr[v9];
    CFStringRef v13 = *(CFTypeRef **)(a3 + 8);
    uint64_t v14 = *(unsigned __int8 *)(a3 + 1);
    uint64_t v15 = sub_10000F7B0(a2, v13, v14, MutableBytePtr, v12);
    sub_10000F7B0(a1, v13, v14, MutableBytePtr, v15);
    uint64_t v16 = ccder_encode_constructed_tl();
    if (v16)
    {
      v19.size_t length = v16 - (void)MutableBytePtr;
      v19.location = 0;
      CFDataDeleteBytes(Mutable, v19);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a3 + 16), Mutable);
      if (!Mutable) {
        return;
      }
    }
    else
    {
      sub_1000297A0(-7, @"com.apple.security.cfder.error", 0, v13, v17, @"ccder failed to encode");
      *(unsigned char *)a3 = 0;
      if (!Mutable) {
        return;
      }
    }
    CFRelease(Mutable);
  }
}

uint64_t sub_10000F7B0(const __CFString *a1, CFTypeRef *a2, uint64_t a3, UInt8 *a4, unint64_t a5)
{
  if (!a1)
  {
    sub_1000297A0(-5, @"com.apple.security.cfder.error", 0, a2, a5, @"Null CFType");
    return 0;
  }
  CFTypeID v10 = CFGetTypeID(a1);
  if (CFArrayGetTypeID() == v10)
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
    if (Count >= 1)
    {
      unint64_t v12 = Count + 1;
      uint64_t v13 = a5;
      do
      {
        CFDataRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, v12 - 2);
        uint64_t v13 = sub_10000F7B0(ValueAtIndex, a2, a3, a4, v13);
        --v12;
      }
      while (v12 > 1);
    }
    goto LABEL_6;
  }
  if (CFBooleanGetTypeID() == v10)
  {
    CFBooleanGetValue((CFBooleanRef)a1);
    ccder_encode_body();
    uint64_t v15 = ccder_encode_tl();
LABEL_11:
    uint64_t v17 = v15;
    if (!v15) {
      sub_1000297A0(-7, @"com.apple.security.cfder.error", 0, a2, v16, @"ccder failed to encode");
    }
    return v17;
  }
  if (CFDataGetTypeID() == v10)
  {
    return sub_100010510((const __CFData *)a1, a2);
  }
  if (CFDateGetTypeID() == v10)
  {
    double AbsoluteTime = CFDateGetAbsoluteTime((CFDateRef)a1);
    sub_100012404(a2, a3, (uint64_t)a4, a5, AbsoluteTime);
LABEL_6:
    uint64_t v15 = ccder_encode_constructed_tl();
    goto LABEL_11;
  }
  if (CFDictionaryGetTypeID() == v10)
  {
    return sub_10000B6E8((const __CFDictionary *)a1, a2, a3);
  }
  if (CFSetGetTypeID() == v10)
  {
    return sub_10002A854((const __CFSet *)a1, a2, a3);
  }
  if (CFStringGetTypeID() == v10)
  {
    return sub_10000FC34(a1, a2, a4, a5, v20);
  }
  if (CFNumberGetTypeID() == v10)
  {
    return sub_1000103B8((const __CFNumber *)a1, a2, (uint64_t)a4, a5);
  }
  if (CFNullGetTypeID() != v10)
  {
    sub_1000297A0(-5, @"com.apple.security.cfder.error", 0, a2, v21, @"Unsupported CFType");
    return 0;
  }

  return sub_10002A5C4(a2);
}

uint64_t sub_10000FB18(const __CFString *a1, const __CFString *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5)
{
  if (sub_10000FE8C(a1, a3, (uint64_t)a3, a4, a5) && sub_10000FE8C(a2, a3, v7, v8, v9))
  {
    return ccder_sizeof();
  }
  else
  {
    sub_1000297A0(-6, @"com.apple.security.cfder.error", 0, a3, v9, @"null input");
    return 0;
  }
}

uint64_t sub_10000FBB4(const __CFString *a1)
{
  CFIndex Length = CFStringGetLength(a1);
  CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  CFIndex usedBufLen = 0;
  v6.location = 0;
  v6.size_t length = Length;
  CFStringGetBytes(a1, v6, 0x8000100u, 0, 0, 0, MaximumSizeForEncoding, &usedBufLen);
  return ccder_sizeof();
}

uint64_t sub_10000FC34(const __CFString *a1, CFTypeRef *a2, UInt8 *a3, uint64_t a4, uint64_t a5)
{
  if (a4)
  {
    CFIndex Length = CFStringGetLength(a1);
    CFIndex usedBufLen = 0;
    v14.location = 0;
    v14.size_t length = Length;
    if (CFStringGetBytes(a1, v14, 0x8000100u, 0, 0, a3, a4 - (void)a3, &usedBufLen) == Length)
    {
      ccder_encode_body();
      uint64_t result = ccder_encode_tl();
      if (result) {
        return result;
      }
      sub_1000297A0(-7, @"com.apple.security.cfder.error", 0, a2, v12, @"ccder failed to encode");
    }
    else
    {
      sub_1000297A0(-5, @"com.apple.security.cfder.error", 0, a2, v10, @"String extraction failed");
    }
  }
  else
  {
    sub_1000297A0(-6, @"com.apple.security.cfder.error", 0, a2, a5, @"null input");
  }
  return 0;
}

CFTypeRef *sub_10000FD40(__CFString **a1, const void *a2, __CFString **a3)
{
  while (a1 == &off_1002FFC58)
  {
    uint64_t v5 = sub_10000C75C(@"cert", &qword_10035D030, (uint64_t)&unk_10035D028);
    uint64_t v6 = sub_10000FD40(v5, a2, 0);
    if (v6) {
      return (CFTypeRef *)v6;
    }
    a1 = (__CFString **)sub_10000C75C(@"keys", &qword_10035D040, (uint64_t)&unk_10035D038);
  }
  if (!a2) {
    goto LABEL_11;
  }
  CFTypeID v7 = CFGetTypeID(a2);
  if (v7 != CFStringGetTypeID()) {
    goto LABEL_11;
  }
  uint64_t v8 = (CFTypeRef *)a1[2];
  if (!v8)
  {
LABEL_10:
    if (CFEqual(kSecUseDataProtectionKeychain, a2)) {
      return 0;
    }
LABEL_11:
    sub_100012A40(-25303, a3, @"attribute %@ not found in class %@", a2, *a1);
    return 0;
  }
  uint64_t v9 = (CFTypeRef **)(a1 + 3);
  while (!CFEqual(*v8, a2))
  {
    uint64_t v10 = *v9++;
    uint64_t v8 = v10;
    if (!v10) {
      goto LABEL_10;
    }
  }
  return v8;
}

uint64_t sub_10000FE8C(const __CFString *a1, CFTypeRef *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (!a1)
  {
    sub_1000297A0(-5, @"com.apple.security.cfder.error", 0, a2, a5, @"Null CFType");
    return 0;
  }
  CFTypeID v7 = CFGetTypeID(a1);
  if (CFArrayGetTypeID() == v7)
  {
    CFIndex Count = CFArrayGetCount((CFArrayRef)a1);
    if (Count >= 1)
    {
      uint64_t v9 = 0;
      unint64_t v10 = Count + 1;
      do
      {
        CFDataRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)a1, v10 - 2);
        v9 += sub_10000FE8C(ValueAtIndex, a2);
        --v10;
      }
      while (v10 > 1);
    }
    goto LABEL_14;
  }
  if (CFBooleanGetTypeID() == v7)
  {
LABEL_14:
    return ccder_sizeof();
  }
  if (CFDataGetTypeID() == v7)
  {
    CFDataGetLength((CFDataRef)a1);
    return ccder_sizeof_raw_octet_string();
  }
  if (CFDateGetTypeID() == v7)
  {
    CFDateGetAbsoluteTime((CFDateRef)a1);
    sub_100010344();
    goto LABEL_14;
  }
  if (CFDictionaryGetTypeID() == v7)
  {
    return sub_10000B67C((const __CFDictionary *)a1, (uint64_t)a2);
  }
  if (CFSetGetTypeID() == v7)
  {
    return sub_10002A7A0((const __CFSet *)a1, (uint64_t)a2);
  }
  if (CFStringGetTypeID() == v7)
  {
    return sub_10000FBB4(a1);
  }
  if (CFNumberGetTypeID() != v7)
  {
    if (CFNullGetTypeID() == v7) {
      goto LABEL_14;
    }
    sub_1000297A0(-5, @"com.apple.security.cfder.error", 0, a2, v13, @"Unsupported CFType");
    return 0;
  }

  return sub_1000100CC((const __CFNumber *)a1, a2);
}

uint64_t sub_1000100CC(const __CFNumber *a1, CFTypeRef *a2)
{
  uint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
  if (CFNumberGetValue(a1, kCFNumberLongLongType, &valuePtr))
  {
    if ((HIBYTE(valuePtr) + 1) <= 1u)
    {
      uint64_t v4 = 9;
      uint64_t v5 = 48;
      do
      {
        if ((unint64_t)(v4 - 2) < 2) {
          break;
        }
        uint64_t v6 = valuePtr >> v5;
        --v4;
        v5 -= 8;
      }
      while (HIBYTE(valuePtr) == v6);
    }
    return ccder_sizeof();
  }
  else
  {
    sub_1000297A0(-4, @"com.apple.security.cfder.error", 0, a2, v3, @"Unable to get number from data");
    return 0;
  }
}

uint64_t sub_1000101AC(uint64_t a1, CFTypeRef *a2)
{
  ccder_decode_tl();
  sub_1000297A0(-1, @"com.apple.security.cfder.error", 0, a2, v3, @"Unknown BOOLean encoding");
  return 0;
}

const UInt8 *sub_100010258(const __CFAllocator *a1, CFDataRef *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5)
{
  if (a4)
  {
    uint64_t v9 = (const UInt8 *)ccder_decode_tl();
    if (v9 && (uint64_t v11 = v9, a5 - (uint64_t)v9 >= 0))
    {
      CFDataRef v13 = CFDataCreate(a1, v9, 0);
      *a2 = v13;
      if (v13) {
        return v11;
      }
      sub_1000297A0(-3, @"com.apple.security.cfder.error", 0, a3, v14, @"Failed to create data");
    }
    else
    {
      sub_1000297A0(-1, @"com.apple.security.cfder.error", 0, a3, v10, @"Unknown data encoding");
    }
  }
  else
  {
    sub_1000297A0(-6, @"com.apple.security.cfder.error", 0, a3, a5, @"null input");
  }
  return 0;
}

uint64_t sub_100010344()
{
  int64_t v0 = 0xAAAAAAAAAAAAAAAALL - __dtoa();
  __freedtoa();
  int64_t v1 = v0 + 1431655766;
  if (v0 < -1431655766) {
    int64_t v1 = 0;
  }
  if (v1) {
    return v1 + 16;
  }
  else {
    return 15;
  }
}

uint64_t sub_1000103B8(const __CFNumber *a1, CFTypeRef *a2, uint64_t a3, uint64_t a4)
{
  uint64_t valuePtr = 0xAAAAAAAAAAAAAAAALL;
  if (!CFNumberGetValue(a1, kCFNumberLongLongType, &valuePtr))
  {
    sub_1000297A0(-4, @"com.apple.security.cfder.error", 0, a2, v7, @"Unable to get number from data");
    return 0;
  }
  uint64_t v8 = valuePtr;
  unint64_t v9 = HIBYTE(valuePtr);
  if ((HIBYTE(valuePtr) + 1) > 1u)
  {
    unint64_t v14 = 8;
    if (!a4) {
      goto LABEL_22;
    }
  }
  else
  {
    uint64_t v10 = 9;
    uint64_t v11 = 48;
    uint64_t v12 = 1;
    while ((unint64_t)(v10 - 2) >= 2)
    {
      uint64_t v13 = valuePtr >> v11;
      --v10;
      v11 -= 8;
      if (v9 != v13)
      {
        uint64_t v12 = v10 - 1;
        goto LABEL_11;
      }
    }
    uint64_t v10 = 2;
LABEL_11:
    if ((((valuePtr >> (8 * v12 - 8)) ^ v9) & 0x80) != 0) {
      unint64_t v14 = v10;
    }
    else {
      unint64_t v14 = v12;
    }
    if (!a4) {
      goto LABEL_22;
    }
  }
  if (a4 - a3 < (uint64_t)v14)
  {
LABEL_22:
    sub_1000297A0(-3, @"com.apple.security.cfder.error", 0, a2, v7, @"Unknown size");
    return 0;
  }
  if (v14 <= 1) {
    uint64_t v15 = 1;
  }
  else {
    uint64_t v15 = v14;
  }
  do
  {
    *(unsigned char *)--a4 = v8;
    v8 >>= 8;
    --v15;
  }
  while (v15);
  uint64_t valuePtr = v8;
  uint64_t result = ccder_encode_tl();
  if (!result)
  {
    sub_1000297A0(-7, @"com.apple.security.cfder.error", 0, a2, v17, @"ccder failed to encode");
    return 0;
  }
  return result;
}

uint64_t sub_100010510(const __CFData *a1, CFTypeRef *a2)
{
  CFDataGetLength(a1);
  CFDataGetBytePtr(a1);
  ccder_encode_body();
  uint64_t v5 = ccder_encode_tl();
  if (!v5) {
    sub_1000297A0(-7, @"com.apple.security.cfder.error", 0, a2, v4, @"ccder failed to encode");
  }
  return v5;
}

void sub_1000105B0(size_t size, uint64_t a2)
{
  if (size)
  {
    if (size > 0x800)
    {
      uint64_t v5 = malloc_type_malloc(size, 0x9C1A2F70uLL);
      (*(void (**)(uint64_t, size_t, void *))(a2 + 16))(a2, size, v5);
      if (v5)
      {
        free(v5);
      }
    }
    else
    {
      __chkstk_darwin();
      memset((char *)&v6 - ((size + 15) & 0xFFFFFFFFFFFFFFF0), 170, size);
      (*(void (**)(uint64_t, size_t, char *))(a2 + 16))(a2, size, (char *)&v6 - ((size + 15) & 0xFFFFFFFFFFFFFFF0));
    }
  }
  else
  {
    uint64_t v4 = *(void (**)(uint64_t, void, void))(a2 + 16);
    v4(a2, 0, 0);
  }
}

uint64_t sub_100010738(uint64_t result, int a2, UInt8 *buffer)
{
  if (buffer)
  {
    uint64_t v4 = result;
    CFStringRef v5 = *(const __CFString **)(result + 40);
    CFRange v8 = *(CFRange *)(v4 + 48);
    CFIndex v6 = *(void *)(v4 + 64);
    CFIndex usedBufLen = 0xAAAAAAAAAAAAAAAALL;
    CFStringGetBytes(v5, v8, 0x8000100u, 0, 0, buffer, v6, &usedBufLen);
    buffer[usedBufLen] = 0;
    return (*(uint64_t (**)(void))(*(void *)(v4 + 32) + 16))();
  }
  return result;
}

uint64_t sub_1000107B8(const __CFAllocator *a1, CFNumberRef *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v16 = 0;
  uint64_t v9 = ccder_decode_tl();
  if (!v9 || (uint64_t v11 = v9, a5 - v9 < v16))
  {
    sub_1000297A0(-1, @"com.apple.security.cfder.error", 0, a3, v10, @"Unknown number encoding", v15);
    return 0;
  }
  uint64_t v15 = 0;
  CFNumberRef v13 = CFNumberCreate(a1, kCFNumberLongLongType, &v15);
  *a2 = v13;
  if (!v13)
  {
    sub_1000297A0(-3, @"com.apple.security.cfder.error", 0, a3, v14, @"Number allocation failed", v15);
    return 0;
  }
  return v11 + v16;
}

BOOL sub_100010978(sqlite3_stmt *a1, CFArrayRef theArray, int *a3, CFTypeRef *a4)
{
  int v5 = *a3;
  if (theArray && (CFIndex Count = CFArrayGetCount(theArray), Count >= 1))
  {
    CFIndex v10 = Count;
    BOOL v11 = 0;
    CFIndex v12 = 0;
    do
    {
      CFIndex v13 = v12;
      uint64_t v14 = (v5 + v12);
      CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v12);
      if ((sub_10000E8B0(a1, v14, ValueAtIndex, a4) & 1) == 0) {
        break;
      }
      CFIndex v12 = v13 + 1;
      BOOL v11 = v13 + 1 >= v10;
    }
    while (v10 != v13 + 1);
    v5 += v13 + 1;
  }
  else
  {
    BOOL v11 = 1;
  }
  *a3 = v5;
  return v11;
}

BOOL sub_100010A40(uint64_t a1, uint64_t a2, __CFString **a3)
{
  uint64_t v4 = *(void *)a2;
  if (*(void *)(*(void *)a2 + 64))
  {
    return sub_100012A40(-50, a3, @"value ref not supported by queries");
  }
  else
  {
    CFArrayRef v9 = *(const __CFArray **)(a2 + 8);
    uint64_t v8 = *(void *)(a2 + 16);
    if (*(void *)(v4 + 104) == 1) {
      CFMutableArrayRef Mutable = 0;
    }
    else {
      CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
    }
    *(void *)(a2 + 24) = Mutable;
    BOOL v11 = sub_100010BE4(v4, v9);
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 0x40000000;
    v14[2] = sub_100010EF0;
    v14[3] = &unk_1002FBD78;
    v14[4] = v4;
    v14[5] = v9;
    v14[6] = a3;
    v14[7] = v8;
    v14[8] = a1;
    v14[9] = a2;
    v14[10] = a2;
    int v12 = sub_100010DE0(v8, v11, (CFTypeRef *)a3, (uint64_t)v14);
    CFRelease(v11);
    BOOL v13 = 0;
    if (sub_10000C588(v4, (CFErrorRef *)a3) && v12)
    {
      if (*(_DWORD *)(a2 + 32))
      {
        return 1;
      }
      else
      {
        BOOL v13 = sub_100012A40(-25300, a3, @"no matching items found");
        if (*(unsigned char *)(v4 + 200)) {
          sub_10002C040(@"ItemNotFound", 0x53C00008u);
        }
      }
    }
    return v13;
  }
}

__CFString *sub_100010BE4(uint64_t a1, const __CFArray *a2)
{
  CFMutableArrayRef Mutable = CFStringCreateMutable(0, 0);
  CFDataRef v5 = *(const __CFData **)(a1 + 80);
  if (*(__CFString ***)a1 == &off_1002FFC58)
  {
    if (v5 && CFDataGetLength(v5) == 16) {
      CFStringRef v7 = CFSTR("SELECT crowid, certdata, certpersistref, rowid, data, persistref FROM (SELECT cert.rowid AS crowid, cert.labl AS labl, cert.issr AS issr, cert.slnr AS slnr, cert.skid AS skid, cert.tkid AS tkid, keys.*,cert.data AS certdata, cert.persistref AS certpersistref FROM keys, cert WHERE keys.priv == 1 AND cert.pkhh == keys.klbl");
    }
    else {
      CFStringRef v7 = CFSTR("SELECT crowid, certdata, rowid, data FROM (SELECT cert.rowid AS crowid, cert.labl AS labl, cert.issr AS issr, cert.slnr AS slnr, cert.skid AS skid, cert.tkid AS tkid, keys.*,cert.data AS certdata FROM keys, cert WHERE keys.priv == 1 AND cert.pkhh == keys.klbl");
    }
    CFStringAppend(Mutable, v7);
    sub_100011814(Mutable, @"cert.agrp", a2, 0);
    sub_100011658(Mutable, @"crowid", *(void *)(a1 + 72), 0);
    CFStringAppend(Mutable, @""));
    char v10 = 1;
    sub_1000116BC(Mutable, a1, &v10);
    sub_10001140C(Mutable, a1, &v10);
    CFDataRef v8 = *(const __CFData **)(a1 + 80);
    if (v8 && CFDataGetLength(v8) == 16)
    {
      sub_100011764(Mutable, &v10);
      CFStringAppend(Mutable, @"certpersistref = ?");
    }
    sub_100011814(Mutable, @"agrp", a2, &v10);
    sub_1000117C4(Mutable, *(unsigned char *)(a1 + 153), &v10);
  }
  else
  {
    if (v5 && CFDataGetLength(v5) == 16)
    {
      CFStringRef v6 = @"SELECT rowid, data, agrp, persistref FROM ";
    }
    else if ((*(unsigned char *)(a1 + 48) & 8) != 0)
    {
      CFStringRef v6 = @"SELECT rowid, data, agrp, persistref FROM ";
    }
    else
    {
      CFStringRef v6 = @"SELECT rowid, data, agrp FROM ";
    }
    CFStringAppend(Mutable, v6);
    CFStringAppend(Mutable, **(CFStringRef **)a1);
    sub_10001158C(Mutable, a1, a2);
  }
  if (!*(void *)(a1 + 176)
    && !*(void *)(a1 + 208)
    && !*(void *)(a1 + 216)
    && !*(void *)(a1 + 232)
    && !*(void *)(a1 + 240)
    && *(void *)(a1 + 104) != -1)
  {
    CFStringAppendFormat(Mutable, 0, @" LIMIT %ld", *(void *)(a1 + 104));
  }
  return Mutable;
}

uint64_t sub_100010DE0(uint64_t a1, const __CFString *cf, CFTypeRef *a3, uint64_t a4)
{
  CFStringRef v6 = cf;
  CFRetain(cf);
  if (!v6) {
    return 1;
  }
  LOBYTE(v8) = 1;
  do
  {
    CFStringRef v11 = 0;
    if (v8)
    {
      CFDataRef v8 = sub_1000111CC(a1, v6, &v11, a3);
      if (v8)
      {
        if (a4) {
          int v9 = (*(uint64_t (**)(uint64_t, sqlite3_stmt *))(a4 + 16))(a4, v8);
        }
        else {
          int v9 = sub_100012A40(-50, (__CFString **)a3, @"SecDbWithSQL perform block missing");
        }
        CFDataRef v8 = (sqlite3_stmt *)(v9 & sub_100011164(v8, a3));
      }
    }
    else
    {
      sub_1000263CC(1, a3, @"Error with unexecuted sql remaining %@", v6);
      CFDataRef v8 = 0;
    }
    CFRelease(v6);
    CFStringRef v6 = v11;
  }
  while (v11);
  return (uint64_t)v8;
}

uint64_t sub_100010EF0(uint64_t a1, sqlite3_stmt *a2)
{
  int v11 = 1;
  uint64_t v4 = *(__CFString ****)(a1 + 32);
  if (*v4 == &off_1002FFC58)
  {
    uint64_t result = sub_100010978(a2, *(CFArrayRef *)(a1 + 40), &v11, *(CFTypeRef **)(a1 + 48));
    if (!result) {
      return result;
    }
    uint64_t v4 = *(__CFString ****)(a1 + 32);
  }
  uint64_t result = sub_10000E62C(a2, (uint64_t)v4, *(const __CFArray **)(a1 + 40), &v11, *(CFTypeRef **)(a1 + 48));
  if (result)
  {
    CFStringRef v7 = *(CFTypeRef **)(a1 + 48);
    uint64_t v6 = *(void *)(a1 + 56);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 0x40000000;
    v10[2] = sub_100012E34;
    v10[3] = &unk_1002FBD58;
    uint64_t v8 = *(void *)(a1 + 72);
    v10[4] = *(void *)(a1 + 64);
    v10[5] = a2;
    uint64_t v9 = *(void *)(a1 + 32);
    v10[6] = v8;
    v10[7] = v9;
    v10[8] = *(void *)(a1 + 80);
    sub_100010FD8(v6, a2, v7, (uint64_t)v10);
    return 1;
  }
  return result;
}

uint64_t sub_100010FD8(uint64_t a1, sqlite3_stmt *pStmt, CFTypeRef *a3, uint64_t a4)
{
  for (uint64_t i = 0; ; uint64_t i = (i + 1))
  {
    if (*(unsigned char *)(a1 + 24) && !sqlite3_stmt_readonly(pStmt))
    {
      uint64_t v9 = sub_10000B070("SecError");
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        char v10 = sqlite3_sql(pStmt);
        *(_DWORD *)long long buf = 136315138;
        uint64_t v15 = v10;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "SecDbForEach: SecDbConnection is readonly but we're about to write: %s", buf, 0xCu);
      }
    }
    uint64_t v11 = sqlite3_step(pStmt);
    if (v11 != 100) {
      break;
    }
    if (a4)
    {
      if (((*(uint64_t (**)(uint64_t, uint64_t))(a4 + 16))(a4, i) & 1) == 0) {
        return 0;
      }
    }
    else
    {
      int v12 = sqlite3_sql(pStmt);
      sub_1000263CC(100, a3, @"step[%d]: %s returned SQLITE_ROW with NULL row block", i, v12);
    }
  }
  if (v11 == 101) {
    return 1;
  }
  sub_100026D0C(a1, v11, a3, @"SecDbForEach step[%d]", i);
  return 0;
}

BOOL sub_100011164(sqlite3_stmt *a1, CFTypeRef *a2)
{
  uint64_t v4 = sqlite3_db_handle(a1);
  uint64_t v5 = sqlite3_finalize(a1);
  return !v5 || sub_10002641C(v5, v4, a2, @"finalize: %p", a1);
}

sqlite3_stmt *sub_1000111CC(uint64_t a1, const __CFString *a2, CFStringRef *a3, CFTypeRef *a4)
{
  v12.location = 0;
  v12.size_t length = 0;
  uint64_t v14 = 0;
  uint64_t v15 = &v14;
  uint64_t v16 = 0x2000000000;
  uint64_t v17 = 0;
  if (a2)
  {
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    v13[2] = sub_10001130C;
    void v13[3] = &unk_1002F7A08;
    v13[4] = &v14;
    v13[5] = a1;
    v13[6] = a4;
    v13[7] = &v12;
    sub_10000EB80(a2, (uint64_t)v13);
    CFStringRef v7 = (sqlite3_stmt *)v15[3];
  }
  else
  {
    CFStringRef v7 = 0;
  }
  _Block_object_dispose(&v14, 8);
  if (v12.length >= 1)
  {
    CFAllocatorRef v8 = CFGetAllocator(a2);
    CFStringRef v9 = CFStringCreateWithSubstring(v8, a2, v12);
    CFStringRef v10 = v9;
    if (a3)
    {
      *a3 = v9;
    }
    else
    {
      sub_1000263CC(2, a4, @"prepare_v2: %@ unused sql: %@", a2, v9);
      if (v10) {
        CFRelease(v10);
      }
      sub_100011164(v7, a4);
      return 0;
    }
  }
  return v7;
}

uint64_t sub_10001130C(void *a1, char *zSql, unint64_t nByte)
{
  uint64_t v15 = 0;
  uint64_t v7 = a1[5];
  uint64_t v6 = (CFTypeRef *)a1[6];
  CFAllocatorRef v8 = *(sqlite3 **)(v7 + 64);
  if (nByte >> 31)
  {
    uint64_t result = sub_10002641C(18, *(sqlite3 **)(v7 + 64), v6, @"prepare_v2: sql bigger than INT_MAX");
LABEL_3:
    CFStringRef v10 = 0;
  }
  else
  {
    for (int i = 0; ; ++i)
    {
      ppStmt = 0;
      uint64_t result = sqlite3_prepare_v2(v8, zSql, nByte, &ppStmt, (const char **)&v15);
      if (!result) {
        break;
      }
      uint64_t result = sub_100026B54(v7, result, @"preparev2", i, v6);
      if ((result & 1) == 0) {
        goto LABEL_3;
      }
    }
    CFStringRef v10 = ppStmt;
  }
  *(void *)(*(void *)(a1[4] + 8) + 24) = v10;
  CFRange v12 = (void *)a1[7];
  if (v12)
  {
    uint64_t v13 = v15 - zSql;
    if (v15 > zSql && v15 < &zSql[nByte])
    {
      *CFRange v12 = v13;
      v12[1] = nByte - v13;
    }
  }
  return result;
}

void sub_10001140C(__CFString *a1, uint64_t a2, unsigned char *a3)
{
  sub_100011764(a1, a3);
  if (sub_1000114F8(*(const __CFData **)(a2 + 128), 0))
  {
    CFStringRef v5 = @"(musr = ? OR musr = ?)";
  }
  else
  {
    if (sub_100011498(*(CFTypeRef *)(a2 + 128))) {
      return;
    }
    uint64_t v6 = *(const void **)(a2 + 128);
    if (v6)
    {
      CFGetTypeID(v6);
      CFNullGetTypeID();
    }
    CFStringRef v5 = @"musr = ?";
  }

  CFStringAppend(a1, v5);
}

BOOL sub_100011498(CFTypeRef cf1)
{
  if (qword_10035CF68 != -1) {
    dispatch_once(&qword_10035CF68, &stru_1002FAFD0);
  }
  return CFEqual(cf1, (CFTypeRef)qword_10035CF70) != 0;
}

uint64_t sub_1000114F8(const __CFData *a1, _DWORD *a2)
{
  if (CFDataGetLength(a1) != 16) {
    return 0;
  }
  BytePtr = CFDataGetBytePtr(a1);
  BOOL v5 = (*(void *)BytePtr ^ 0x9A460A992EBEC436 | *((unsigned int *)BytePtr + 2) ^ 0xA40989ACLL) == 0;
  if (a2 && !(*(void *)BytePtr ^ 0x9A460A992EBEC436 | *((unsigned int *)BytePtr + 2) ^ 0xA40989ACLL))
  {
    *a2 = bswap32(*((_DWORD *)BytePtr + 3));
    return 1;
  }
  return v5;
}

void sub_10001158C(__CFString *a1, uint64_t a2, const __CFArray *a3)
{
  char v7 = 1;
  sub_100011658(a1, @"ROWID", *(void *)(a2 + 72), &v7);
  sub_1000116BC(a1, a2, &v7);
  sub_10001140C(a1, a2, &v7);
  CFDataRef v6 = *(const __CFData **)(a2 + 80);
  if (v6 && CFDataGetLength(v6) == 16)
  {
    sub_100011764(a1, &v7);
    CFStringAppend(a1, @"persistref = ?");
  }
  sub_100011814(a1, @"agrp", a3, &v7);
  sub_1000117C4(a1, *(unsigned char *)(a2 + 153), &v7);
}

void sub_100011658(__CFString *a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  if (a3 >= 1)
  {
    sub_100011764(a1, a4);
    CFStringAppendFormat(a1, 0, @"%@=%lld", a2, a3);
  }
}

void sub_1000116BC(__CFString *a1, uint64_t a2, unsigned char *a3)
{
  uint64_t v3 = *(void *)(a2 + 32);
  if (v3 >= 1)
  {
    CFDataRef v6 = (const __CFString **)(a2 + 264);
    do
    {
      CFStringRef v7 = *v6;
      v6 += 2;
      sub_100011710(a1, v7, a3);
      --v3;
    }
    while (v3);
  }
}

void sub_100011710(__CFString *a1, const __CFString *a2, unsigned char *a3)
{
  sub_100011764(a1, a3);
  CFStringAppend(a1, a2);

  CFStringAppend(a1, @"=?");
}

void sub_100011764(__CFString *a1, unsigned char *a2)
{
  if (a2 && *a2)
  {
    CFStringAppend(a1, @" WHERE ");
    *a2 = 0;
  }
  else
  {
    CFStringAppend(a1, @" AND ");
  }
}

void sub_1000117C4(__CFString *a1, char a2, unsigned char *a3)
{
  if (a2)
  {
    sub_100011764(a1, a3);
    CFStringAppend(a1, @"clip = 0");
  }
}

void sub_100011814(__CFString *a1, const __CFString *a2, CFArrayRef theArray, unsigned char *a4)
{
  if (theArray)
  {
    CFIndex Count = CFArrayGetCount(theArray);
    if (Count)
    {
      uint64_t v8 = Count;
      sub_100011764(a1, a4);
      CFStringAppend(a1, a2);
      CFStringAppend(a1, @" IN (?");
      if (v8 >= 2)
      {
        uint64_t v9 = v8 - 1;
        do
        {
          CFStringAppend(a1, @",?");
          --v9;
        }
        while (v9);
      }
      CFStringAppend(a1, @""));
    }
  }
}

uint64_t sub_1000118D4(uint64_t a1)
{
  if (a1)
  {
    if (!*(unsigned char *)(a1 + 56))
    {
      uint64_t v3 = *(const void **)(a1 + 24);
      if (v3)
      {
        *(void *)(a1 + 24) = 0;
        CFRelease(v3);
      }
    }
    uint64_t v4 = +[UMUserManager sharedManager];
    BOOL v5 = [v4 currentPersona];

    if (v5 && [v5 userPersonaType] == (id)2)
    {
      CFDataRef v6 = sub_10000B070("serverxpc");
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v15 = [v5 userPersonaNickName];
        *(_DWORD *)long long buf = 134218242;
        uint64_t v18 = a1;
        __int16 v19 = 2112;
        uint64_t v20 = v15;
        _os_log_debug_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "securityd client(%p): persona user %@", buf, 0x16u);
      }
      CFStringRef v7 = sub_10000B070("serverxpc");
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = [v5 userPersonaUniqueString];
        *(_DWORD *)long long buf = 134218242;
        uint64_t v18 = a1;
        __int16 v19 = 2112;
        uint64_t v20 = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "securityd client(%p): persona uuid %@", buf, 0x16u);
      }
      [v5 userPersonaUniqueString];
      id v9 = objc_claimAutoreleasedReturnValue();
      int v10 = uuid_parse((const char *)[v9 UTF8String], (unsigned __int8 *)&v16);

      if (v10)
      {
        uint64_t v11 = sub_10000B070("serverxpc");
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          CFRange v12 = [v5 userPersonaUniqueString];
          *(_DWORD *)long long buf = 134218242;
          uint64_t v18 = a1;
          __int16 v19 = 2112;
          uint64_t v20 = v12;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "securityd client(%p):  uuid %@ didn't parse setting to null", buf, 0x16u);
        }
        uint64_t v13 = 0;
        *(void *)(a1 + 24) = 0;
        goto LABEL_18;
      }
      *(void *)(a1 + 24) = CFDataCreate(0, (const UInt8 *)&v16, 16);
    }
    uint64_t v13 = 1;
LABEL_18:

    return v13;
  }
  return 0;
}

unint64_t sub_100011B70(const __CFAllocator *a1, CFDateRef *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5)
{
  *(void *)uint64_t v15 = a5;
  uint64_t v8 = ccder_decode_constructed_tl();
  CFAbsoluteTime at = 0.0;
  unint64_t v10 = sub_100011C1C(&at, a3, v8, *(unint64_t *)v15, v9);
  if (v10)
  {
    CFDateRef v11 = CFDateCreate(a1, at);
    *a2 = v11;
    if (!v11)
    {
      sub_1000297A0(-3, @"com.apple.security.cfder.error", 0, a3, v12, @"Failed to create date");
      return 0;
    }
  }
  return v10;
}

unint64_t sub_100011C1C(double *a1, CFTypeRef *a2, uint64_t a3, unint64_t a4, uint64_t a5)
{
  *(void *)uint64_t v20 = a3;
  int v8 = sub_10001219C((unsigned __int8 **)v20, a4, a2, a4, a5);
  int v11 = sub_10001219C((unsigned __int8 **)v20, a4, a2, v9, v10) + 10 * v8;
  int v14 = sub_10001219C((unsigned __int8 **)v20, a4, a2, v12, v13);
  unsigned int v17 = sub_10001219C((unsigned __int8 **)v20, a4, a2, v15, v16) + 10 * v14 + 100 * v11;
  uint64_t v18 = *(unsigned __int8 **)v20;

  return sub_100011CE4(a1, a2, v17, v18, a4);
}

unint64_t sub_100011CE4(double *a1, CFTypeRef *a2, unsigned int a3, unsigned __int8 *a4, unint64_t a5)
{
  unint64_t v5 = a5;
  int v69 = a4;
  int v66 = sub_10001219C(&v69, a5, a2, (uint64_t)a4, a5);
  int v65 = sub_10001219C(&v69, v5, a2, v7, v8);
  int v64 = sub_10001219C(&v69, v5, a2, v9, v10);
  int v13 = sub_10001219C(&v69, v5, a2, v11, v12);
  int v16 = sub_10001219C(&v69, v5, a2, v14, v15);
  int v19 = sub_10001219C(&v69, v5, a2, v17, v18);
  int v22 = sub_10001219C(&v69, v5, a2, v20, v21);
  int v25 = sub_10001219C(&v69, v5, a2, v23, v24);
  int v28 = sub_10001219C(&v69, v5, a2, v26, v27);
  int v33 = sub_10001219C(&v69, v5, a2, v29, v30);
  uint64_t v34 = 0;
  char v35 = v69;
  double v36 = NAN;
  if (v69 && (unint64_t)v69 < v5)
  {
    int v37 = *v69;
    if (v37 == 46)
    {
      uint32_t v38 = v69 + 1;
      if ((unint64_t)(v69 + 1) < v5)
      {
        int v37 = *v38;
        if ((v37 - 58) < 0xFFFFFFF6)
        {
          CFStringRef v39 = @"fraction without digits";
LABEL_14:
          CFIndex v41 = -1;
LABEL_23:
          sub_1000297A0(v41, @"com.apple.security.cfder.error", 0, a2, v32, v39);
          uint64_t v34 = 0;
          goto LABEL_24;
        }
        uint64_t v42 = 0;
        uint64_t v43 = v5 - (void)v69 - 2;
        unint64_t v44 = 1;
        while (v43)
        {
          int v45 = v37;
          if (v44 < 0x1999999999999999)
          {
            v44 *= 10;
            uint64_t v42 = (v37 - 48) + 10 * v42;
          }
          int v46 = *++v38;
          int v37 = v46;
          --v43;
          if ((v46 - 58) < 0xFFFFFFF6)
          {
            if (v45 == 48)
            {
              CFStringRef v39 = @"fraction ends in 0";
              goto LABEL_14;
            }
            double v36 = (double)(unint64_t)v42 / (double)v44;
            char v35 = v38;
            goto LABEL_8;
          }
        }
      }
      CFStringRef v39 = @"overflow";
      CFIndex v41 = -8;
      goto LABEL_23;
    }
    double v36 = 0.0;
LABEL_8:
    if ((unint64_t)v35 < v5)
    {
      uint64_t v34 = v35 + 1;
      int v69 = v35 + 1;
      switch(v37)
      {
        case 'Z':
          double v47 = 0.0;
          goto LABEL_25;
        case '-':
          int v40 = -60;
          break;
        case '+':
          int v40 = 60;
          break;
        default:
          goto LABEL_24;
      }
      int v63 = v40;
      int v54 = sub_10001219C(&v69, v5, a2, v31, v32);
      int v62 = sub_10001219C(&v69, v5, a2, v55, v56) + 10 * v54;
      int v59 = sub_10001219C(&v69, v5, a2, v57, v58);
      double v47 = (double)(int)((sub_10001219C(&v69, v5, a2, v60, v61) + 10 * v59 + 60 * v62) * v63);
      uint64_t v34 = v69;
      if (!v69) {
        return 0;
      }
      goto LABEL_25;
    }
    CFStringRef v39 = @"Unexpected end of datetime";
    goto LABEL_14;
  }
LABEL_24:
  sub_1000297A0(-1, @"com.apple.security.cfder.error", 0, a2, v32, @"Invalid datetime character");
  double v47 = NAN;
  if (!v34) {
    return 0;
  }
LABEL_25:
  if (v34 != (unsigned __int8 *)v5)
  {
    sub_1000297A0(-1, @"com.apple.security.cfder.error", 0, a2, v32, @"trailing garbage at end of datetime");
    return 0;
  }
  uint64_t v49 = (v13 + 10 * v64);
  uint64_t v50 = (v19 + 10 * v16);
  uint64_t v51 = (v25 + 10 * v22);
  v85[0] = 0;
  if (sub_100012244(a3, (v65 + 10 * v66), v49, v50, v51, (v33 + 10 * v28), v85, (__CFString **)a2))
  {
    uint64_t v81 = 0;
    CFDictionaryRef v82 = &v81;
    uint64_t v83 = 0x2000000000;
    char v84 = 0;
    int v77 = 0;
    CFDataRef v78 = (double *)((char *)&v76 + 4);
    uint64_t v79 = 0x2000000000;
    uint64_t v80 = 0;
    v70[0] = _NSConcreteStackBlock;
    v70[1] = 0x40000000;
    v70[2] = sub_100005764;
    v70[3] = &unk_1002F7568;
    v70[4] = &v81;
    v70[5] = (char *)&v76 + 4;
    unsigned int v71 = a3;
    int v72 = v65 + 10 * v66;
    int v73 = v49;
    int v74 = v50;
    int v75 = v51;
    uint64_t v76 = (v33 + 10 * v28);
    sub_10001235C((uint64_t)v70);
    if (*((unsigned char *)v82 + 24))
    {
      double v53 = v78[3] - v47;
    }
    else
    {
      sub_1000297A0(-1, @"com.apple.security.cfder.error", 0, a2, v52, @"Failed to encode date from components");
      double v53 = NAN;
    }
    _Block_object_dispose((char *)&v76 + 4, 8);
    _Block_object_dispose(&v81, 8);
    *a1 = v53;
    *a1 = v36 + v53;
  }
  else
  {
    unint64_t v5 = 0;
    *a1 = NAN;
  }
  return v5;
}

uint64_t sub_10001219C(unsigned __int8 **a1, unint64_t a2, CFTypeRef *a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7 = *a1;
  if (*a1)
  {
    if ((unint64_t)v7 >= a2)
    {
      sub_1000297A0(-1, @"com.apple.security.cfder.error", 0, a3, a5, @"Unexpected end of datetime");
      *a1 = 0;
    }
    else
    {
      int v9 = *v7;
      int v8 = v9;
      *a1 = v7 + 1;
      if (((v9 << 24) - 956301313) > 0xF6FFFFFE) {
        return (v8 - 48);
      }
    }
  }
  sub_1000297A0(-1, @"com.apple.security.cfder.error", 0, a3, a5, @"Not a decimal digit");
  *a1 = 0;
  return 0xFFFFFFFFLL;
}

uint64_t sub_100012244(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, _DWORD *a7, __CFString **a8)
{
  if ((a1 & 3) != 0)
  {
    BOOL v8 = 0;
  }
  else
  {
    HIDWORD(v9) = -1030792151 * a1 + 85899344;
    LODWORD(v9) = HIDWORD(v9);
    if ((v9 >> 2) <= 0x28F5C28)
    {
      HIDWORD(v10) = -1030792151 * a1 + 85899344;
      LODWORD(v10) = HIDWORD(v10);
      BOOL v8 = (v10 >> 4) < 0xA3D70B;
    }
    else
    {
      BOOL v8 = 1;
    }
  }
  if (a7) {
    *a7 = v8;
  }
  if ((int)a6 <= 61
    && (int)a5 <= 59
    && (int)a4 <= 23
    && (a2 - 13) >= 0xFFFFFFF4
    && (a3 - 32) >= 0xFFFFFFE1
    && (a2 != 2 || (v8 | 0x1C) >= a3)
    && (a2 == 2 || dword_1002655D0[a2] - dword_1002655D0[(a2 - 1)] >= (int)a3))
  {
    return 1;
  }
  sub_100012A40(-1, a8, @"Invalid date: %i, %i, %i, %i, %i, %i, %i", a1, a2, a3, a4, a5, a6, v8);
  return 0;
}

void sub_10001235C(uint64_t a1)
{
  if (qword_10035CBB8 != -1) {
    dispatch_once(&qword_10035CBB8, &stru_1002F74D8);
  }
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100017E04;
  block[3] = &unk_1002F73B8;
  block[4] = a1;
  dispatch_sync((dispatch_queue_t)qword_10035CBC0, block);
}

unint64_t sub_100012404(CFTypeRef *a1, int a2, uint64_t a3, unint64_t a4, double a5)
{
  uint64_t v44 = 0;
  uint64_t v45 = 0;
  uint64_t v43 = 0;
  CFErrorRef err = 0;
  p_CFErrorRef err = &err;
  uint64_t v48 = 0x2000000000;
  char v49 = -86;
  *(void *)long long buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 0x40000000;
  *(void *)&uint8_t buf[16] = sub_1000054B0;
  double v53 = &unk_1002F7590;
  int v54 = &err;
  double v55 = a5;
  uint64_t v56 = (char *)&v45 + 4;
  uint64_t v57 = &v45;
  uint64_t v58 = (char *)&v44 + 4;
  int v59 = &v44;
  uint64_t v60 = (char *)&v43 + 4;
  uint64_t v61 = &v43;
  sub_10001235C((uint64_t)buf);
  if (*((unsigned char *)p_err + 24))
  {
    _Block_object_dispose(&err, 8);
  }
  else
  {
    sub_1000297A0(-1, @"com.apple.security.cfder.error", 0, a1, v10, @"Failed to encode date.");
    int v11 = *((unsigned __int8 *)p_err + 24);
    _Block_object_dispose(&err, 8);
    if (!v11)
    {
      uint64_t v34 = sub_10000B070("SecError");
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        if (a1) {
          CFTypeRef v35 = *a1;
        }
        else {
          CFTypeRef v35 = 0;
        }
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v35;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "der: unable to encode date: %@", buf, 0xCu);
      }
      return 0;
    }
  }
  CFErrorRef err = 0;
  if ((sub_100012244(HIDWORD(v45), v45, HIDWORD(v44), v44, HIDWORD(v43), v43, 0, (__CFString **)&err) & 1) == 0)
  {
    uint64_t v12 = (__CFString *)CFErrorCopyDescription(err);
    sub_10002BBA0(v12, 0x53C00002u);
    if (v12) {
      CFRelease(v12);
    }
    int v13 = sub_10000B070("SecError");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = "continuing";
      if (a2) {
        uint64_t v14 = "setting default value";
      }
      *(_DWORD *)long long buf = 138412546;
      *(void *)&uint8_t buf[4] = err;
      *(_WORD *)&buf[12] = 2080;
      *(void *)&buf[14] = v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "der: invalid date: %@; %s", buf, 0x16u);
    }
    CFErrorRef v15 = err;
    if (err)
    {
      CFErrorRef err = 0;
      CFRelease(v15);
    }
    if (a2)
    {
      uint64_t v45 = 0x7D100000001;
      HIDWORD(v44) = 1;
      HIDWORD(v43) = 1;
    }
  }
  if (a3 + 1 <= a4)
  {
    *(unsigned char *)(a4 - 1) = 90;
    unint64_t v16 = a4 - 1;
  }
  else
  {
    unint64_t v16 = 0;
  }
  int v18 = v45;
  int v17 = HIDWORD(v45);
  int v19 = HIDWORD(v44);
  int v42 = v44;
  int v20 = v43;
  int v21 = HIDWORD(v43);
  int v50 = -1431655766;
  int v51 = -1431655766;
  *(void *)long long buf = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v22 = __dtoa();
  int v23 = v51;
  uint64_t v24 = *(void *)buf;
  if (a5 < 0.0)
  {
    unint64_t v25 = v22 + (v51 & ~(v51 >> 31));
    if (v25 < *(void *)buf)
    {
      uint64_t v26 = (unsigned char *)(*(void *)buf - 1);
      for (unsigned char *v26 = 106 - *(unsigned char *)(*(void *)buf - 1); (unint64_t)v26 > v25; unsigned char *v26 = 105 - v27)
        char v27 = *--v26;
    }
    int v23 = v51;
    uint64_t v24 = *(void *)buf;
  }
  if (v24 - v22 > v23)
  {
    if ((v23 & 0x80000000) == 0)
    {
      unint64_t v16 = ccder_encode_body();
LABEL_31:
      if (a3 + 1 <= v16) {
        *(unsigned char *)--unint64_t v16 = 46;
      }
      else {
        unint64_t v16 = 0;
      }
      goto LABEL_38;
    }
    int v41 = v19;
    int v28 = a1;
    int v29 = v18;
    int v30 = v17;
    ccder_encode_body();
    size_t v31 = -(uint64_t)v51;
    uint64_t v32 = (void *)ccder_encode_body_nocopy();
    unint64_t v16 = (unint64_t)v32;
    if (v32)
    {
      if (a5 >= 0.0) {
        int v33 = 48;
      }
      else {
        int v33 = 57;
      }
      memset(v32, v33, v31);
      int v17 = v30;
      int v18 = v29;
      a1 = v28;
      int v19 = v41;
      goto LABEL_31;
    }
    int v17 = v30;
    int v18 = v29;
    a1 = v28;
    int v19 = v41;
  }
LABEL_38:
  __freedtoa();
  if (v16)
  {
    unint64_t v37 = a3 + 2;
    if (a3 + 2 <= v16)
    {
      *(unsigned char *)(v16 - 2) = v20 / 10 + 48;
      *(unsigned char *)(v16 - 1) = v20 % 10 + 48;
      if (v37 <= v16 - 2)
      {
        *(unsigned char *)(v16 - 4) = v21 / 10 + 48;
        *(unsigned char *)(v16 - 3) = v21 % 10 + 48;
        if (v37 <= v16 - 4)
        {
          *(unsigned char *)(v16 - 6) = v42 / 10 + 48;
          *(unsigned char *)(v16 - 5) = v42 % 10 + 48;
          if (v37 <= v16 - 6)
          {
            *(unsigned char *)(v16 - 8) = v19 / 10 + 48;
            *(unsigned char *)(v16 - 7) = v19 % 10 + 48;
            if (v37 <= v16 - 8)
            {
              *(unsigned char *)(v16 - 10) = v18 / 10 + 48;
              *(unsigned char *)(v16 - 9) = v18 % 10 + 48;
              if (v37 <= v16 - 10)
              {
                unsigned int v38 = (((103 * (v17 % 100)) >> 15) & 1) + ((103 * (v17 % 100)) >> 10);
                *(unsigned char *)(v16 - 12) = v38 + 48;
                *(unsigned char *)(v16 - 11) = v17 % 100 - 10 * v38 + 48;
                if (v37 <= v16 - 12)
                {
                  *(unsigned char *)(v16 - 14) = v17 / 1000 + 48;
                  unint64_t v39 = v16 - 14;
                  *(unsigned char *)(v39 + 1) = v17 / 100 % 10 + 48;
                  return v39;
                }
              }
            }
          }
        }
      }
    }
  }
  sub_1000297A0(-7, @"com.apple.security.cfder.error", 0, a1, v36, @"ccder failed to encode");
  return 0;
}

BOOL sub_100012A40(int a1, __CFString **a2, CFStringRef format, ...)
{
  va_start(va, format);
  if (a1)
  {
    CFTypeRef cf = 0;
    if (a2)
    {
      sub_100012AD4(a1, kCFErrorDomainOSStatus, *a2, &cf, format, va);
      *a2 = (__CFString *)cf;
    }
    else
    {
      sub_100012AD4(a1, kCFErrorDomainOSStatus, 0, &cf, format, va);
      CFTypeRef v5 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        CFRelease(v5);
      }
    }
  }
  return a1 == 0;
}

void sub_100012AD4(CFIndex a1, const __CFString *a2, __CFString *cf, CFTypeRef *a4, CFStringRef format, va_list arguments)
{
  if (!a4) {
    return;
  }
  if (*a4)
  {
    if (cf && *a4 != cf)
    {
      CFRelease(cf);
    }
    return;
  }
  CFStringRef v10 = CFStringCreateWithFormatAndArguments(0, 0, format, arguments);
  uint64_t v28 = 0;
  if (!cf) {
    goto LABEL_30;
  }
  CFDictionaryRef v11 = CFErrorCopyUserInfo((CFErrorRef)cf);
  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v11, kCFErrorDescriptionKey);
  if (Value)
  {
    BOOL v13 = CFEqual(v10, Value);
    if (!v11) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
  BOOL v13 = 0;
  if (v11) {
LABEL_11:
  }
    CFRelease(v11);
LABEL_12:
  CFIndex Code = CFErrorGetCode((CFErrorRef)cf);
  CFStringRef Domain = CFErrorGetDomain((CFErrorRef)cf);
  CFComparisonResult v16 = CFStringCompare(a2, Domain, 0);
  BOOL v18 = Code == a1 && v16 == kCFCompareEqualTo && v13;
  int v19 = cf;
  if (v18) {
    goto LABEL_19;
  }
  CFDictionaryRef v21 = CFErrorCopyUserInfo((CFErrorRef)cf);
  if (v21)
  {
    CFDictionaryRef v22 = v21;
    int v23 = (const void *)kSOSCountKey;
    if (CFDictionaryContainsKey(v21, kSOSCountKey) == 1)
    {
      CFNumberRef v24 = (const __CFNumber *)CFDictionaryGetValue(v22, v23);
      if (v24)
      {
        uint64_t valuePtr = 0;
        CFNumberGetValue(v24, kCFNumberLongType, &valuePtr);
        if (valuePtr > 199)
        {
          CFRelease(v22);
          int v19 = cf;
LABEL_19:
          CFRetain(v19);
          *a4 = cf;
          CFRelease(cf);
          if (!v10) {
            return;
          }
          CFStringRef v20 = v10;
          goto LABEL_44;
        }
        uint64_t v28 = valuePtr + 1;
      }
    }
    CFRelease(v22);
  }
LABEL_30:
  CFNumberRef v25 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongType, &v28);
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  char v27 = Mutable;
  if (cf) {
    CFDictionaryAddValue(Mutable, kCFErrorUnderlyingErrorKey, cf);
  }
  if (v25) {
    CFDictionaryAddValue(v27, kSOSCountKey, v25);
  }
  if (v10) {
    CFDictionaryAddValue(v27, kCFErrorDescriptionKey, v10);
  }
  *a4 = CFErrorCreate(kCFAllocatorDefault, a2, a1, v27);
  if (v25) {
    CFRelease(v25);
  }
  if (v10) {
    CFRelease(v10);
  }
  if (v27) {
    CFRelease(v27);
  }
  if (cf)
  {
    CFStringRef v20 = cf;
LABEL_44:
    CFRelease(v20);
  }
}

void sub_100012D84(uint64_t a1, CFTypeRef cf)
{
  uint64_t v3 = *(const void **)(a1 + 136);
  if (v3)
  {
    if (CFEqual(v3, cf)) {
      return;
    }
    uint64_t v7 = (__CFString **)(a1 + 40);
    CFStringRef v8 = @"conflicting kSecAccess and kSecAccessControl attributes";
    goto LABEL_10;
  }
  *(void *)(a1 + 136) = CFRetain(cf);
  uint64_t Protection = SecAccessControlGetProtection();
  if (!Protection)
  {
    uint64_t v7 = (__CFString **)(a1 + 40);
    CFStringRef v8 = @"kSecAccessControl missing protection";
LABEL_10:
    sub_100012A40(-50, v7, v8);
    return;
  }
  CFTypeRef v5 = (const void *)Protection;
  CFDataRef v6 = *(__CFDictionary **)(a1 + 8);

  CFDictionarySetValue(v6, kSecAttrAccessible, v5);
}

uint64_t sub_100012E34(uint64_t a1)
{
  (*(void (**)(void, void))(a1 + 32))(*(void *)(a1 + 40), *(void *)(a1 + 48));
  uint64_t v2 = *(void *)(a1 + 56);
  uint64_t v3 = *(__CFError **)(v2 + 40);
  if (v3)
  {
    CFIndex Code = CFErrorGetCode(v3);
    BOOL v5 = Code == -25330;
    uint64_t v2 = *(void *)(a1 + 56);
    if (*(unsigned char *)(v2 + 152)) {
      BOOL v6 = Code == -25330;
    }
    else {
      BOOL v6 = 0;
    }
    if (v6)
    {
      uint64_t v7 = *(const void **)(v2 + 40);
      if (v7)
      {
        *(void *)(v2 + 40) = 0;
        CFRelease(v7);
        uint64_t v2 = *(void *)(a1 + 56);
      }
      BOOL v5 = 1;
    }
  }
  else
  {
    BOOL v5 = 0;
  }
  uint64_t v8 = *(void *)(v2 + 104);
  if (v8 != -1 && v8 <= *(int *)(*(void *)(a1 + 64) + 32)) {
    return 0;
  }
  if (*(void *)(v2 + 40)) {
    return v5;
  }
  return 1;
}

void sub_100012EE0(sqlite3_stmt *a1, uint64_t a2)
{
  uint64_t v4 = *(const void ****)a2;
  int v5 = *(_DWORD *)(*(void *)a2 + 48);
  sqlite3_int64 v6 = sqlite3_column_int64(a1, 0);
  CFDictionaryRef theDict = 0;
  uint64_t v7 = (CFDictionaryRef *)(v4 + 5);
  while ((sub_1000139C0(a1, (uint64_t)v4, 1, *(const __CFArray **)(a2 + 8), &theDict, 0, 0, (__CFString **)v4 + 5) & 1) != 0)
  {
    if (!theDict)
    {
      *((_DWORD *)v4 + 12) = v5;
      return;
    }
    if (!CFDictionaryContainsKey(theDict, kSecAttrTokenID) || (int v8 = *((_DWORD *)v4 + 12), (v8 & 1) != 0))
    {
      CFStringRef v10 = v4[30];
      if (v10)
      {
        CFStringRef Value = CFDictionaryGetValue(theDict, kSecValueData);
        if (!sub_100139330(v10, (uint64_t)Value)) {
          goto LABEL_99;
        }
      }
      if (*v4 != (const void **)&off_1002FFC58) {
        goto LABEL_45;
      }
      *(void *)long long buf = 0;
      CFDataRef v12 = (const __CFData *)v4[10];
      if (v12 && CFDataGetLength(v12) == 16)
      {
        CFArrayRef v13 = *(const __CFArray **)(a2 + 8);
        uint64_t v14 = a1;
        uint64_t v15 = (uint64_t)v4;
        int v16 = 4;
      }
      else
      {
        CFArrayRef v13 = *(const __CFArray **)(a2 + 8);
        uint64_t v14 = a1;
        uint64_t v15 = (uint64_t)v4;
        int v16 = 3;
      }
      if (!sub_1000139C0(v14, v15, v16, v13, (CFDictionaryRef *)buf, 0, 0, (__CFString **)v4 + 5)
        || !*(void *)buf)
      {
        goto LABEL_99;
      }
      size_t v31 = CFDictionaryGetValue(theDict, kSecValueData);
      if (v31)
      {
        CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, @"certdata", v31);
        CFDictionaryRemoveValue(theDict, kSecValueData);
      }
      uint64_t v32 = CFDictionaryGetValue(theDict, kSecAttrTokenID);
      if (v32)
      {
        CFDictionarySetValue(*(CFMutableDictionaryRef *)buf, @"certtkid", v32);
        CFDictionaryRemoveValue(theDict, kSecAttrTokenID);
      }
      CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)sub_1001393AC, *(void **)buf);
      CFRelease(theDict);
      CFDictionaryRef theDict = *(CFDictionaryRef *)buf;
LABEL_45:
      if (*((unsigned char *)v4 + 116))
      {
        CFStringRef v33 = (const __CFString *)CFDictionaryGetValue(theDict, kSecAttrSharingGroup);
        if (v33)
        {
          CFStringRef v34 = v33;
          CFTypeID v35 = CFGetTypeID(v33);
          if (v35 == CFStringGetTypeID())
          {
            if (CFStringCompare(v34, kSecAttrSharingGroupNone, 0)) {
              goto LABEL_99;
            }
          }
        }
      }
      if (!sub_100013CBC(*(void *)(a2 + 16), (uint64_t)v4, *(void *)(a2 + 8), theDict)) {
        goto LABEL_99;
      }
      CFDataRef v36 = (const __CFData *)CFDictionaryGetValue(theDict, kSecAttrPersistentReference);
      unint64_t v37 = theDict;
      unsigned int v38 = (void *)CFDictionaryGetValue(theDict, kSecValueData);
      int v39 = *((_DWORD *)v4 + 12);
      if ((v39 & 8) != 0)
      {
        if (v36 && CFDataGetLength(v36) == 16)
        {
          uint64_t UUIDBasedPersistentRef = _SecItemCreateUUIDBasedPersistentRef();
        }
        else
        {
          int v50 = sub_10000B070("pref");
          if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 134217984;
            *(void *)&uint8_t buf[4] = v6;
            _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "handle_result: Creating old persistent ref for %llu", buf, 0xCu);
          }
          uint64_t UUIDBasedPersistentRef = _SecItemCreatePersistentRef();
        }
        int v40 = (const void *)UUIDBasedPersistentRef;
        int v39 = *((_DWORD *)v4 + 12);
      }
      else
      {
        int v40 = 0;
      }
      switch(v39)
      {
        case 8:
          if (v36 && CFDataGetLength(v36) == 16)
          {
            uint64_t PersistentRef = _SecItemCreateUUIDBasedPersistentRef();
          }
          else
          {
            uint64_t v52 = sub_10000B070("pref");
            if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 134217984;
              *(void *)&uint8_t buf[4] = v6;
              _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "handle_result: Creating old persistent ref for %llu", buf, 0xCu);
            }
            uint64_t PersistentRef = _SecItemCreatePersistentRef();
          }
          break;
        case 1:
          if (v38)
          {
            CFRetain(v38);
            unint64_t v37 = (__CFDictionary *)v38;
            if (v40) {
              goto LABEL_88;
            }
            goto LABEL_89;
          }
          uint64_t PersistentRef = (uint64_t)CFDataCreate(kCFAllocatorDefault, 0, 0);
          break;
        case 0:
          unint64_t v37 = kCFNull;
          if (!v40) {
            goto LABEL_89;
          }
LABEL_88:
          CFRelease(v40);
          goto LABEL_89;
        default:
          if ((v39 & 4) != 0)
          {
            CFDictionarySetValue(v37, kSecClass, **v4);
            goto LABEL_140;
          }
          if ((v39 & 2) == 0)
          {
            if (v38) {
              CFRetain(v38);
            }
            CFDictionaryRemoveAllValues(v37);
            if (v38 && (v4[6] & 1) != 0)
            {
              CFDictionarySetValue(v37, kSecValueData, v38);
              goto LABEL_139;
            }
            if (v38) {
LABEL_139:
            }
              CFRelease(v38);
LABEL_140:
            if (((_BYTE)v4[6] & 8) != 0 && v40) {
              CFDictionarySetValue(v37, kSecValuePersistentRef, v40);
            }
            CFRetain(v37);
            if (v40) {
              goto LABEL_88;
            }
LABEL_89:
            if (v37)
            {
              if (v37 != kCFNull)
              {
                if (v4[13] == (const void **)1)
                {
                  *(void *)(a2 + 24) = v37;
                  goto LABEL_95;
                }
                CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 24), v37);
              }
              CFRelease(v37);
LABEL_95:
              ++*(_DWORD *)(a2 + 32);
            }
            if (CFDictionaryContainsKey(theDict, kSecAttrPersistentReference) && ((_BYTE)v4[6] & 2) != 0) {
              CFDictionaryRemoveValue(theDict, kSecAttrPersistentReference);
            }
LABEL_99:
            CFDictionaryRef v53 = theDict;
            *((_DWORD *)v4 + 12) = v5;
            if (v53) {
LABEL_100:
            }
              CFRelease(v53);
            return;
          }
          if ((v39 & 1) == 0) {
            CFDictionaryRemoveValue(v37, kSecValueData);
          }
          uint64_t v56 = (uint64_t (**)(const void *, const void *, unsigned char *))(*v4)[2];
          if (!v56)
          {
LABEL_137:
            CFDictionaryRemoveValue(v37, kSecAttrUUID);
            goto LABEL_140;
          }
          uint64_t v57 = 0;
          uint64_t v58 = *v4 + 3;
          while (2)
          {
            if (((_BYTE)v56[2] & 0x10) != 0 && !CFDictionaryGetValue(v37, *v56) && v56[3])
            {
              uint64_t v60 = 0;
              *(void *)long long buf = 0;
              if (!v57)
              {
                uint64_t v57 = sub_10011ACF4((uint64_t)*v4, v37, dword_10035D2B0, (__CFString **)buf);
                uint64_t v60 = *(const void **)buf;
              }
              if (v60 || !v57) {
                goto LABEL_133;
              }
              if (*((_DWORD *)v56 + 2) != 7 || ((_BYTE)v4[6] & 1) != 0)
              {
                uint64_t v61 = (const void *)v56[3](v57, v56, buf);
                uint64_t v60 = *(const void **)buf;
                if (!*(void *)buf && v61)
                {
                  CFDictionarySetValue(v37, *v56, v61);
                  goto LABEL_132;
                }
                if (v61)
                {
LABEL_132:
                  CFRelease(v61);
                  uint64_t v60 = *(const void **)buf;
                }
LABEL_133:
                if (v60)
                {
                  *(void *)long long buf = 0;
                  CFRelease(v60);
                }
              }
            }
            int v59 = (uint64_t (**)(const void *, const void *, unsigned char *))*v58++;
            uint64_t v56 = v59;
            if (!v59)
            {
              if (v57) {
                CFRelease(v57);
              }
              goto LABEL_137;
            }
            continue;
          }
      }
      unint64_t v37 = (__CFDictionary *)PersistentRef;
      if (!v40) {
        goto LABEL_89;
      }
      goto LABEL_88;
    }
    *((_DWORD *)v4 + 12) = v8 | 1;
    CFDictionaryRef v9 = theDict;
    if (theDict)
    {
      CFDictionaryRef theDict = 0;
      CFRelease(v9);
    }
  }
  int OSStatus = SecErrorGetOSStatus();
  int v18 = OSStatus;
  if (OSStatus > -25331)
  {
    if (OSStatus == -25330)
    {
      int v42 = sub_10000B070("SecWarning");
      if (!os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      uint64_t v43 = **v4;
      uint64_t v44 = v4[5];
      *(_DWORD *)long long buf = 138413058;
      *(void *)&uint8_t buf[4] = v43;
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v6;
      *(_WORD *)&buf[22] = 1024;
      LODWORD(v64) = -25330;
      WORD2(v64) = 2112;
      *(void *)((char *)&v64 + 6) = v44;
      uint64_t v45 = "Authentication is needed for %@,rowid=%lld (%d): %@";
      int v46 = v42;
      goto LABEL_59;
    }
    if (OSStatus == -25308)
    {
      if (qword_10035CFF8 != -1) {
        dispatch_once(&qword_10035CFF8, &stru_1002FBDB8);
      }
      dispatch_source_merge_data((dispatch_source_t)qword_10035D000, 1uLL);
      return;
    }
LABEL_57:
    double v47 = sub_10000B070("SecError");
    if (!os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    uint64_t v48 = **v4;
    char v49 = v4[5];
    *(_DWORD *)long long buf = 138413058;
    *(void *)&uint8_t buf[4] = v48;
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = v6;
    *(_WORD *)&buf[22] = 1024;
    LODWORD(v64) = v18;
    WORD2(v64) = 2112;
    *(void *)((char *)&v64 + 6) = v49;
    uint64_t v45 = "decode %@,rowid=%lld failed (%d): %@";
    int v46 = v47;
LABEL_59:
    _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, v45, buf, 0x26u);
    return;
  }
  if (OSStatus == -34018) {
    goto LABEL_111;
  }
  if (OSStatus != -26275) {
    goto LABEL_57;
  }
  int v19 = sub_10000B070("SecWarning");
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v20 = **v4;
    CFDictionaryRef v21 = v4[5];
    *(_DWORD *)long long buf = 138412802;
    *(void *)&uint8_t buf[4] = v20;
    *(_WORD *)&buf[12] = 2048;
    *(void *)&buf[14] = v6;
    *(_WORD *)&buf[22] = 2112;
    *(void *)&long long v64 = v21;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "ignoring corrupt %@,rowid=%lld %@", buf, 0x20u);
  }
  CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, (CFStringRef)**v4);
  int v23 = (const void *)sub_10000CF0C(0);
  if (v23)
  {
    CFNumberRef v24 = v23;
    CFRetain(v23);
    CFRetain(Copy);
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&uint8_t buf[16] = sub_100144EB0;
    *(void *)&long long v64 = &unk_100303FB0;
    *((void *)&v64 + 1) = v24;
    CFStringRef v65 = Copy;
    sqlite3_int64 v66 = v6;
    if (qword_10035D108 != -1) {
      dispatch_once(&qword_10035D108, &stru_100304A40);
    }
    dispatch_async((dispatch_queue_t)qword_10035D110, buf);
  }
  if (Copy) {
    CFRelease(Copy);
  }
  CFDataRef v25 = sub_100013C54(a1, 1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  if (Mutable)
  {
    BytePtr = CFDataGetBytePtr(v25);
    CFIndex Length = CFDataGetLength(v25);
    if ((Length & 0x8000000000000000) == 0)
    {
      unint64_t v29 = Length;
      CFStringAppendFormat(Mutable, 0, @"%04lx:", Length);
      if (v29 > 8)
      {
        *(void *)long long buf = 0;
        CNCRC();
        for (uint64_t i = 0; i != 8; ++i)
          CFStringAppendFormat(Mutable, 0, @"%02X", BytePtr[i]);
        CFStringAppendFormat(Mutable, 0, @"...|%08llx", *(void *)buf);
      }
      else
      {
        for (; v29; --v29)
        {
          unsigned int v30 = *BytePtr++;
          CFStringAppendFormat(Mutable, 0, @"%02X", v30);
        }
      }
    }
    double v55 = sub_10000B070("item");
    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = Mutable;
      _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "corrupted edata=%@", buf, 0xCu);
    }
  }
  if (v25) {
    CFRelease(v25);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
LABEL_111:
  CFDictionaryRef v53 = *v7;
  if (*v7)
  {
    *uint64_t v7 = 0;
    goto LABEL_100;
  }
}

uint64_t sub_1000139C0(sqlite3_stmt *a1, uint64_t a2, int a3, const __CFArray *a4, CFDictionaryRef *a5, void *a6, _DWORD *a7, __CFString **a8)
{
  CFDataRef v14 = sub_100013C54(a1, a3);
  if (!v14) {
    return 0;
  }
  CFDataRef v15 = v14;
  CFTypeRef cf = 0;
  unsigned int v27 = 0;
  if ((*(unsigned char *)(a2 + 48) & 5) != 0
    || *(void *)(a2 + 208)
    || *(void *)(a2 + 216)
    || (uint64_t v16 = *(void *)(a2 + 232)) != 0)
  {
    LOBYTE(v16) = 1;
  }
  if (sub_100015484(*(unsigned int *)(a2 + 120), 0, @"od", &cf, *(const __CFData **)(a2 + 144), v14, *(void *)a2, *(const __CFString **)(a2 + 184), (const void **)a5, &v27, v16, a7, a8))
  {
    if (v27 > 1)
    {
      int v18 = (const void *)SecAccessControlCopyData();
      CFStringRef Value = (const __CFString *)CFDictionaryGetValue(*a5, kSecAttrAccessGroup);
      if (sub_10000C1A8(a4, Value, 0))
      {
        if (v27 >= 4) {
          CFDictionarySetValue(*a5, kSecAttrAccessControl, v18);
        }
        uint64_t v17 = 1;
      }
      else
      {
        CFStringRef v20 = sub_10000B070("SecError");
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          CFDictionaryRef v21 = CFDictionaryGetValue(*a5, kSecAttrAccessGroup);
          *(_DWORD *)long long buf = 138412546;
          unsigned int v30 = v21;
          __int16 v31 = 2112;
          CFArrayRef v32 = a4;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "item's accessGroup '%@' not in %@", buf, 0x16u);
        }

        CFDictionaryRef v22 = CFDictionaryGetValue(*a5, kSecAttrAccessGroup);
        sub_100012A40(-34018, a8, @"item's access group '%@' not in %@", v22, a4);
        CFDictionaryRef v23 = *a5;
        if (*a5)
        {
          *a5 = 0;
          CFRelease(v23);
        }
        uint64_t v17 = 0;
      }
      goto LABEL_20;
    }
    sub_100012A40(-26275, a8, @"version is unexpected: %d", v27);
  }
  uint64_t v17 = 0;
  int v18 = 0;
LABEL_20:
  CFTypeRef v24 = cf;
  if (a6)
  {
    if (cf)
    {
      CFRetain(cf);
      CFTypeRef v25 = cf;
    }
    else
    {
      CFTypeRef v25 = 0;
    }
    *a6 = v24;
    CFTypeRef v24 = v25;
  }
  if (v24) {
    CFRelease(v24);
  }
  if (v18) {
    CFRelease(v18);
  }
  CFRelease(v15);
  return v17;
}

CFDataRef sub_100013C54(sqlite3_stmt *a1, int a2)
{
  uint64_t v4 = (const UInt8 *)sqlite3_column_blob(a1, a2);
  CFIndex v5 = sqlite3_column_bytes(a1, a2);

  return CFDataCreateWithBytesNoCopy(0, v4, v5, kCFAllocatorNull);
}

unint64_t sub_100013CBC(uint64_t a1, uint64_t a2, uint64_t a3, CFDictionaryRef theDict)
{
  if (*(void *)(a2 + 176))
  {
    CFStringRef Value = CFDictionaryGetValue(theDict, kSecAttrIssuer);
    if (!sub_1001449F0(a1, a3, *(const void **)(a2 + 128), Value, *(const __CFArray **)(a2 + 176), 10)) {
      return 0;
    }
  }
  if (!*(void *)(a2 + 208)) {
    goto LABEL_6;
  }
  if (*(__CFString ***)a2 == &off_1002FFC58)
  {
    CFDictionaryRef v11 = &off_1002FFC58;
  }
  else
  {
    CFDictionaryRef v9 = *(__CFString ***)a2;
    if (v9 != (__CFString **)sub_10000C75C(@"cert", &qword_10035D030, (uint64_t)&unk_10035D028))
    {
LABEL_6:
      SecCertificateRef v10 = 0;
      goto LABEL_36;
    }
    CFDictionaryRef v11 = *(__CFString ***)a2;
  }
  SecCertificateRef v12 = sub_100144C84(v11, theDict);
  if (!v12) {
    return 0;
  }
  SecCertificateRef v10 = v12;
  CFArrayRef v13 = *(void **)(a2 + 208);
  CFDataRef v14 = *(const void **)(a2 + 216);
  SecTrustRef trust = 0;
  values[0] = v12;
  if (!v13) {
    goto LABEL_108;
  }
  SecTrustResultType result = -1431655766;
  CFArrayRef v15 = CFArrayCreate(0, (const void **)values, 1, &kCFTypeArrayCallBacks);
  if (SecTrustCreateWithCertificates(v15, v13, &trust)
    || v14 && (CFTypeID v16 = CFGetTypeID(v14), v16 == CFDateGetTypeID()) && SecTrustSetVerifyDate(trust, (CFDateRef)v14))
  {
    BOOL v21 = 0;
    goto LABEL_30;
  }
  CFDictionaryRef v17 = SecPolicyCopyProperties((SecPolicyRef)v13);
  CFDictionaryRef v18 = v17;
  if (v17)
  {
    int v19 = CFDictionaryGetValue(v17, kSecPolicyOid);
    if (v19)
    {
      CFStringRef v20 = v19;
      if (CFEqual(v19, kSecPolicyAppleX509Basic) || CFEqual(v20, kSecPolicyAppleRevocation))
      {
        if (SecTrustEvaluate(trust, &result))
        {
          BOOL v21 = 0;
LABEL_29:
          CFRelease(v18);
          goto LABEL_30;
        }
        goto LABEL_22;
      }
    }
  }
  if (!SecTrustEvaluateLeafOnly())
  {
LABEL_22:
    BOOL v21 = result == kSecTrustResultUnspecified || result == kSecTrustResultProceed;
    if (v18) {
      goto LABEL_29;
    }
    goto LABEL_30;
  }
  BOOL v21 = 0;
  if (v18) {
    goto LABEL_29;
  }
LABEL_30:
  if (v15) {
    CFRelease(v15);
  }
  if (trust)
  {
    CFRelease(trust);
    if (!v21) {
      goto LABEL_108;
    }
  }
  else if (!v21)
  {
    goto LABEL_108;
  }
LABEL_36:
  if (*(void *)(a2 + 216))
  {
    if (*(__CFString ***)a2 == &off_1002FFC58
      || (CFDictionaryRef v23 = *(__CFString ***)a2,
          v23 == (__CFString **)sub_10000C75C(@"cert", &qword_10035D030, (uint64_t)&unk_10035D028)))
    {
      if (!v10)
      {
        SecCertificateRef v10 = sub_100144C84(*(__CFString ***)a2, theDict);
        if (!v10) {
          return 0;
        }
      }
      CFDateRef v40 = *(const __CFDate **)(a2 + 216);
      if (!v40) {
        goto LABEL_108;
      }
      double AbsoluteTime = CFDateGetAbsoluteTime(v40);
      SecCertificateNotValidBefore();
      double v43 = v42;
      SecCertificateNotValidAfter();
      if (v43 == 0.0 || v44 == 0.0 || v43 == v44)
      {
        uint64_t v45 = sub_10000B070("FilterWithDate");
        if (!os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_108;
        }
        LOWORD(values[0]) = 0;
        int v46 = "certificate cannot operate";
      }
      else if (AbsoluteTime >= v43)
      {
        if (AbsoluteTime <= v44) {
          goto LABEL_39;
        }
        uint64_t v45 = sub_10000B070("FilterWithDate");
        if (!os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_108;
        }
        LOWORD(values[0]) = 0;
        int v46 = "certificate expired";
      }
      else
      {
        uint64_t v45 = sub_10000B070("FilterWithDate");
        if (!os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_108;
        }
        LOWORD(values[0]) = 0;
        int v46 = "certificate is not valid yet";
      }
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, v46, (uint8_t *)values, 2u);
      goto LABEL_108;
    }
  }
LABEL_39:
  if (*(void *)(a2 + 232))
  {
    if (*(__CFString ***)a2 == &off_1002FFC58
      || (CFTypeRef v24 = *(__CFString ***)a2,
          v24 == (__CFString **)sub_10000C75C(@"cert", &qword_10035D030, (uint64_t)&unk_10035D028)))
    {
      if (!v10)
      {
        SecCertificateRef v10 = sub_100144C84(*(__CFString ***)a2, theDict);
        if (!v10) {
          return 0;
        }
      }
      int v25 = CFBooleanGetValue(*(CFBooleanRef *)(a2 + 232));
      values[0] = v10;
      if (v25)
      {
        CFArrayRef v26 = CFArrayCreate(0, (const void **)values, 1, &kCFTypeArrayCallBacks);
        SecTrustRef trust = 0;
        SecPolicyRef BasicX509 = SecPolicyCreateBasicX509();
        BOOL v29 = BasicX509
           && !SecTrustCreateWithCertificates(v26, BasicX509, &trust)
           && (SecTrustResultType result = -1431655766, !SecTrustEvaluate(trust, &result))
           && (result == kSecTrustResultUnspecified || result == kSecTrustResultProceed);
        if (trust) {
          CFRelease(trust);
        }
        if (BasicX509) {
          CFRelease(BasicX509);
        }
        if (v26) {
          CFRelease(v26);
        }
        if (!v29) {
          goto LABEL_108;
        }
      }
    }
  }
  if (*(void *)(a2 + 224))
  {
    if (*(__CFString ***)a2 == &off_1002FFC58
      || (unsigned int v30 = *(__CFString ***)a2,
          v30 == (__CFString **)sub_10000C75C(@"cert", &qword_10035D030, (uint64_t)&unk_10035D028)))
    {
      if (v10 || (SecCertificateRef v10 = sub_100144C84(*(__CFString ***)a2, theDict)) != 0)
      {
        CFStringRef v31 = *(const __CFString **)(a2 + 224);
        if (v31)
        {
          CFTypeID v32 = CFGetTypeID(*(CFTypeRef *)(a2 + 224));
          if (v32 == CFStringGetTypeID())
          {
            values[0] = 0;
            if (!SecCertificateCopyEmailAddresses(v10, (CFArrayRef *)values))
            {
              if (values[0])
              {
                CFIndex Count = CFArrayGetCount((CFArrayRef)values[0]);
                if (Count >= 1)
                {
                  CFIndex v34 = Count;
                  CFIndex v35 = 0;
                  BOOL v36 = 1;
                  do
                  {
                    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex((CFArrayRef)values[0], v35);
                    if (ValueAtIndex && CFStringCompare(v31, ValueAtIndex, 1uLL) == kCFCompareEqualTo) {
                      break;
                    }
                    BOOL v36 = ++v35 < v34;
                  }
                  while (v34 != v35);
                  if (values[0])
                  {
                    CFRelease(values[0]);
                    if (v36) {
                      goto LABEL_77;
                    }
                  }
                  else if (v36)
                  {
                    goto LABEL_77;
                  }
                  unint64_t HasSuffix = 0;
LABEL_80:
                  if (!v10) {
                    return HasSuffix;
                  }
                  goto LABEL_109;
                }
                if (values[0]) {
                  CFRelease(values[0]);
                }
              }
            }
          }
        }
LABEL_108:
        unint64_t HasSuffix = 0;
LABEL_109:
        CFRelease(v10);
        return HasSuffix;
      }
      return 0;
    }
  }
LABEL_77:
  if (!*(void *)(a2 + 248)
    || (unsigned int v38 = *(__CFString ***)a2,
        v38 != (__CFString **)sub_10000C75C(@"inet", &qword_10035D020, (uint64_t)&unk_10035D018)))
  {
LABEL_79:
    unint64_t HasSuffix = 1;
    goto LABEL_80;
  }
  CFStringRef v47 = (const __CFString *)CFDictionaryGetValue(theDict, kSecAttrServer);
  if (!v47) {
    return 0;
  }
  CFStringRef v48 = v47;
  CFTypeID v49 = CFGetTypeID(v47);
  if (v49 != CFStringGetTypeID()) {
    return 0;
  }
  unint64_t HasSuffix = *(void *)(a2 + 248);
  if (HasSuffix)
  {
    if (CFEqual(v48, (CFTypeRef)HasSuffix)) {
      goto LABEL_79;
    }
    CFMutableStringRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
    CFStringAppend(Mutable, @".");
    CFStringAppend(Mutable, (CFStringRef)HasSuffix);
    unint64_t HasSuffix = CFStringHasSuffix(v48, Mutable);
    if (Mutable) {
      CFRelease(Mutable);
    }
    if (HasSuffix) {
      goto LABEL_79;
    }
  }
  return HasSuffix;
}

BOOL sub_100014458(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, const void *a6, _DWORD *a7, CFDataRef theData, char a9, __CFString **a10)
{
  int v18 = CFDataGetLength(theData);
  length[0] = v18;
  if (CFEqual(a1, @"oe"))
  {
    MutableBytePtr = CFDataGetMutableBytePtr(theData);
    if (a9)
    {
      size_t v34 = v18;
      uint64_t v20 = sub_10001B444(a2, a6, a5, MutableBytePtr, &v34);
      if (v20)
      {
        BOOL v21 = sub_10000B070("SecError");
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          length[1] = 67109120;
          length[2] = v20;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "ks_crypt: aks_kc_backup_wrap_key returned %d", (uint8_t *)&length[1], 8u);
        }
      }
      else
      {
        length[0] = v34;
        if (a7) {
          *a7 = a4;
        }
      }
      goto LABEL_20;
    }
    uint64_t v24 = sub_10001AFAC(a6, a5, a4, a2, MutableBytePtr, length, a7);
LABEL_19:
    uint64_t v20 = v24;
    goto LABEL_20;
  }
  if (!CFEqual(a1, @"od"))
  {
    if (!CFEqual(a1, @"odel"))
    {
      uint64_t v20 = 3758097090;
      goto LABEL_37;
    }
    int v25 = CFDataGetMutableBytePtr(theData);
    CFArrayRef v26 = a6;
    int v27 = a5;
    int v28 = a4;
    int v29 = a2;
    goto LABEL_18;
  }
  CFDictionaryRef v22 = CFDataGetMutableBytePtr(theData);
  if (!a3)
  {
    CFArrayRef v26 = a6;
    int v27 = a5;
    int v28 = a4;
    int v29 = a2;
    int v25 = v22;
LABEL_18:
    uint64_t v24 = sub_100014860(v26, v27, v28, v29, v25, length);
    goto LABEL_19;
  }
  size_t v34 = v18;
  CFDictionaryRef v23 = sub_10000B070("ks_crypt");
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(length[1]) = 0;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "have a backup_keypair, attempting to use", (uint8_t *)&length[1], 2u);
  }
  uint64_t v20 = sub_10001B328(a3, a6, a5, v22, &v34);
  if (!v20) {
    length[0] = v34;
  }
LABEL_20:
  if ((int)v20 > -536870161)
  {
    switch(v20)
    {
      case 0xE00002F0:
        return sub_100012A40(-25291, a10, @"ks_crypt: %x failed to '%@' item (class %d, bag: %d) No key available for class.", 3758097136, a1, a4, a2);
      case 0xE007C013:
        return sub_100012A40(-26275, a10, @"ks_crypt: %x failed to '%@' item (class %d, bag: %d) Item can't be decrypted on this device, ever, so drop the item.", v20, a1, a4, a2);
      case 0:
        CFDataSetLength(theData, length[0]);
        return 1;
    }
    goto LABEL_37;
  }
  if (v20 == -536870212) {
    return sub_100012A40(-26275, a10, @"ks_crypt: %x failed to '%@' item (class %d, bag: %d) Item can't be decrypted on this device, ever, so drop the item.", v20, a1, a4, a2);
  }
  if (v20 != -536870207 && v20 != -536870174)
  {
LABEL_37:
    if (!CFEqual(a1, @"od") && !CFEqual(a1, @"odel")) {
      return sub_100012A40(-25291, a10, @"ks_crypt: %x failed to '%@' item (class %d, bag: %d)", v20, a1, a4, a2);
    }
    size_t v34 = 0;
    *(void *)&length[1] = 0;
    int v33 = sub_100154750(a2, (uint64_t)a6, a5, (uint64_t *)&v34, (CFTypeRef *)&length[1], a10);
    if (*(void *)&length[1]) {
      CFRelease(*(CFTypeRef *)&length[1]);
    }
    sub_100019344((uint64_t *)&v34);
    if (!v33) {
      return sub_100012A40(-25291, a10, @"ks_crypt: %x failed to '%@' item (class %d, bag: %d)", v20, a1, a4, a2);
    }
    return sub_100012A40(-26275, a10, @"ks_crypt: %x failed to '%@' item (class %d, bag: %d) Item can't be decrypted on this device, ever, so drop the item.", v20, a1, a4, a2);
  }
  BOOL v30 = a4 == 10 || a4 == 7;
  CFStringRef v31 = "";
  if (v30) {
    CFStringRef v31 = " (hibernation?)";
  }
  return sub_100012A40(-25308, a10, @"ks_crypt: %x failed to '%@' item (class %d, bag: %d) Access to item attempted while keychain is locked%s.", v20, a1, a4, a2, v31);
}

uint64_t sub_100014860(const void *a1, int a2, int a3, int a4, void *a5, int *a6)
{
  uint64_t v12 = 3758097084;
  mach_port_t v13 = sub_1000149A8();
  if (v13)
  {
    uint64_t v12 = 3758097090;
    if (a1)
    {
      if (a5)
      {
        if (a6)
        {
          input[0] = a4;
          input[1] = a3;
          size_t v15 = *a6;
          uint64_t v12 = IOConnectCallMethod(v13, 0xBu, input, 2u, a1, a2, 0, 0, a5, &v15);
          if (!v12) {
            *a6 = v15;
          }
        }
      }
    }
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_unwrap_key", ":", 877, "", 0, "", "");
  }
  return v12;
}

uint64_t sub_1000149A8()
{
  if (qword_10035CAE8 != -1) {
    dispatch_once(&qword_10035CAE8, &stru_1002F6D30);
  }
  dispatch_sync((dispatch_queue_t)qword_10035CAF0, &stru_1002F6CF0);
  uint64_t result = dword_10035CAE0;
  if (!dword_10035CAE0)
  {
    syslog(3, "failed to open connection to %s\n", "AppleKeyStore");
    return dword_10035CAE0;
  }
  return result;
}

id sub_100014E70(const __CFData *a1)
{
  int64_t v1 = (void *)sub_100014ED0(0, a1, 0);
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    uint64_t v2 = v1;
  }
  else {
    uint64_t v2 = 0;
  }
  id v3 = v2;

  return v3;
}

CFTypeRef sub_100014ED0(int a1, CFDataRef theData, CFTypeRef *a3)
{
  CFTypeRef cf = 0;
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  int v8 = &BytePtr[Length];
  uint64_t v9 = sub_10000F124(a1, (int)&cf, a3, (uint64_t)BytePtr, (uint64_t)&BytePtr[Length]);
  if (!v9 || (const UInt8 *)v9 == v8) {
    return cf;
  }
  sub_1000297A0(-1, @"com.apple.security.cfder.error", 0, a3, v10, @"trailing garbage after plist item");
  CFTypeRef result = cf;
  if (cf)
  {
    CFRelease(cf);
    return 0;
  }
  return result;
}

uint64_t sub_100015484(uint64_t a1, uint64_t a2, char *a3, void *a4, const __CFData *a5, const __CFData *a6, uint64_t a7, const __CFString *a8, const void **a9, unsigned int *a10, char a11, _DWORD *a12, __CFString **a13)
{
  CFStringRef v106 = a8;
  CFDataRef v105 = a5;
  uint64_t v110 = a4;
  CFStringRef v107 = a3;
  int v18 = a9;
  CFDictionaryRef v17 = a10;
  CFMutableStringRef Mutable = CFDataCreateMutable(0, 32);
  CFDataSetLength(Mutable, 32);
  if (a9) {
    *a9 = 0;
  }
  if (a10) {
    *a10 = 0;
  }
  CFDataRef v119 = 0;
  BOOL v120 = 0;
  v118 = 0;
  unint64_t Length = CFDataGetLength(a6);
  BytePtr = CFDataGetBytePtr(a6);
  if (Length <= 3)
  {
    uint64_t v22 = sub_100012A40(-26275, a13, @"ks_decrypt_data: Check for underflow (length)");
    CFDictionaryRef v23 = 0;
    uint64_t v24 = 0;
    CFTypeRef v111 = 0;
    int v25 = 0;
    unsigned int v26 = 0;
    goto LABEL_83;
  }
  int v27 = BytePtr;
  uint64_t v109 = a13;
  v104 = a9;
  uint64_t v103 = a10;
  int v28 = (unsigned int *)(BytePtr + 4);
  int v29 = *(_DWORD *)BytePtr;
  unsigned int v30 = *(_DWORD *)BytePtr & 0x7FFFFFFF;
  if (*(int *)BytePtr < 0) {
    CFStringRef v31 = &unk_100265680;
  }
  else {
    CFStringRef v31 = 0;
  }
  if (v29 < 0) {
    uint64_t v32 = 12;
  }
  else {
    uint64_t v32 = 0;
  }
  unint64_t v33 = Length - 4;
  uint64_t v108 = *(_DWORD *)BytePtr & 0x7FFFFFFF;
  if (v30 >= 7)
  {
    size_t v34 = +[NSData dataWithBytes:v28 length:v33];
    id v117 = 0;
    CFIndex v35 = [[SecDbKeychainItemV7 alloc] initWithData:v34 decryptionKeybag:a1 error:&v117];
    id v36 = v117;
    if (a12) {
      *a12 = [(SecDbKeychainItemV7 *)v35 keyclass];
    }
    id v116 = v36;
    unint64_t v37 = [(SecDbKeychainItemV7 *)v35 metadataAttributesWithError:&v116];
    id v38 = v116;

    id v39 = [v37 mutableCopy];
    unsigned int v40 = 0;
    uint64_t v24 = 0;
    int v18 = v104;
    int v41 = 0;
    if (!v39 || v38) {
      goto LABEL_78;
    }
    double v42 = [v39 objectForKeyedSubscript:@"SecAccessControl"];
    int v41 = (const void *)SecAccessControlCreateFromData();
    [v39 removeObjectForKey:@"SecAccessControl"];
    if (CFEqual(@"odel", v107))
    {
      id v115 = 0;
      unsigned int v40 = [(SecDbKeychainItemV7 *)v35 deleteWithAcmContext:v105 accessControl:v41 callerAccessGroups:v106 keyDiversify:v108 != 7 error:&v115];
      id v38 = v115;
      if (!v40)
      {
LABEL_62:
        uint64_t v24 = 0;
LABEL_77:

LABEL_78:
        CFTypeRef v111 = v41;
        if (v109 && !v40) {
          *uint64_t v109 = (__CFString *)v38;
        }

        CFDictionaryRef v23 = 0;
        int v25 = 0;
        uint64_t v22 = v40 != 0;
        CFDictionaryRef v17 = v103;
        goto LABEL_82;
      }
    }
    else if ((a11 & 1) != 0 || SecAccessControlGetConstraints())
    {
      id v114 = 0;
      double v55 = [(SecDbKeychainItemV7 *)v35 secretAttributesWithAcmContext:v105 accessControl:v41 callerAccessGroups:v106 keyDiversify:v108 != 7 error:&v114];
      id v56 = v114;
      id v38 = v56;
      if (v55)
      {
        if (a11) {
          [v39 addEntriesFromDictionary:v55];
        }
        unsigned int v40 = 1;
      }
      else
      {
        id v63 = [v56 code];
        unsigned int v40 = 0;
        if (v108 == 8 && v63 == (id)-26275)
        {
          long long v64 = sub_10000B070("SecError");
          if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 67109120;
            *(_DWORD *)&uint8_t buf[4] = 8;
            _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "ks_decrypt_data failed to decrypt secretdata: version %u mismatch with content", buf, 8u);
          }

          unsigned int v40 = 0;
        }
      }

      int v18 = v104;
      if (!v40) {
        goto LABEL_62;
      }
    }
    else
    {
      id v38 = 0;
    }
    uint64_t v24 = (__CFDictionary *)v39;
    unsigned int v40 = 1;
    goto LABEL_77;
  }
  if (v30 - 4 > 2)
  {
    if (v33 <= 3)
    {
      CFStringRef v43 = @"ks_decrypt_data: Check for underflow (keyclass)";
      goto LABEL_28;
    }
    unsigned int v101 = *v28;
    unsigned int v47 = (v101 & 0x1F) - 6;
    if (v47 <= 6 && *(void *)*(&off_1002FAE38 + v47))
    {
      LODWORD(dataOutAvailable) = v30 - 4;
      uint64_t v99 = v32;
      BOOL v100 = v31;
      CFStringRef v48 = (const void *)SecAccessControlCreate();
      if (v48)
      {
        CFTypeRef v111 = v48;
        if (SecAccessControlSetProtection())
        {
          uint64_t v22 = (uint64_t)(v27 + 8);
          unint64_t v45 = Length - 8;
          CFDictionaryRef v17 = v103;
          goto LABEL_38;
        }
        BOOL v81 = sub_100012A40(-26275, v109, @"ks_decrypt_data: SecAccessControlSetProtection failed");
LABEL_117:
        uint64_t v22 = v81;
        CFDictionaryRef v23 = 0;
        uint64_t v24 = 0;
        goto LABEL_30;
      }
      CFStringRef v43 = @"ks_decrypt_data: SecAccessControlCreate failed";
    }
    else
    {
      CFStringRef v43 = @"ks_decrypt_data: invalid keyclass detected";
    }
    int v46 = v109;
    goto LABEL_29;
  }
  if (v33 <= 3)
  {
    CFStringRef v43 = @"ks_decrypt_data: Check for underflow (prot_length)";
LABEL_28:
    int v46 = v109;
LABEL_29:
    uint64_t v22 = sub_100012A40(-26275, v46, v43);
    CFDictionaryRef v23 = 0;
    uint64_t v24 = 0;
    CFTypeRef v111 = 0;
LABEL_30:
    int v25 = 0;
LABEL_31:
    CFDictionaryRef v17 = v103;
LABEL_32:
    int v18 = v104;
LABEL_82:
    unsigned int v26 = v108;
    goto LABEL_83;
  }
  unint64_t v44 = *v28;
  unint64_t v45 = Length - 8 - v44;
  if (Length - 8 < v44)
  {
    CFStringRef v43 = @"ks_decrypt_data: Check for underflow (prot)";
    goto LABEL_28;
  }
  LODWORD(dataOutAvailable) = v30 - 4;
  uint64_t v99 = v32;
  BOOL v100 = v31;
  uint64_t v57 = &BytePtr[v44 + 8];
  *(void *)long long buf = 0;
  sub_10000F124(0, (int)buf, 0, (uint64_t)(BytePtr + 8), (uint64_t)v57);
  CFDictionaryRef v23 = *(__CFData **)buf;
  CFDictionaryRef v17 = v103;
  if (!*(void *)buf)
  {
    uint64_t v22 = sub_100012A40(-26275, v109, @"ks_decrypt_data: invalid ACL");
    uint64_t v24 = 0;
    CFTypeRef v111 = 0;
LABEL_115:
    int v25 = 0;
    goto LABEL_32;
  }
  uint64_t v98 = (uint64_t)v57;
  uint64_t v58 = SecAccessControlCreate();
  if (!v58)
  {
    CFDictionaryRef v23 = 0;
    uint64_t v24 = 0;
    CFTypeRef v111 = 0;
    int v25 = 0;
    uint64_t v22 = 1;
    goto LABEL_31;
  }
  int v59 = (const void *)v58;
  char v60 = SecAccessControlSetProtection();
  CFRelease(v23);
  CFTypeRef v111 = v59;
  if ((v60 & 1) == 0)
  {
    sub_100012A40(-26275, v109, @"ks_decrypt_data: invalid ACL");
    CFDictionaryRef v23 = 0;
    uint64_t v24 = 0;
    int v25 = 0;
    goto LABEL_74;
  }
  uint64_t Protection = (const void *)SecAccessControlGetProtection();
  unsigned int v62 = sub_1001243B8(Protection, v109);
  if (!v62)
  {
    BOOL v81 = sub_100012A40(-26275, v109, @"ks_decrypt_data: invalid ACL");
    goto LABEL_117;
  }
  unsigned int v101 = v62;
  CFDictionaryRef v17 = v103;
  uint64_t v22 = v98;
LABEL_38:
  unsigned int v52 = dataOutAvailable;
  uint64_t v113 = 0;
  if ((v108 - 2) >= 5)
  {
    if (!v108)
    {
      unint64_t v65 = CFDataGetLength(Mutable) + 8;
      unint64_t v68 = v45 - v65;
      if (v45 >= v65)
      {
        int v69 = v109;
LABEL_119:
        if (v68 > 0xF)
        {
          if ((v68 & 0xF) == 0)
          {
            dataOutAvailable = (char *)v68;
            uint64_t v98 = v22;
            LODWORD(v22) = 1;
            goto LABEL_126;
          }
          CFStringRef v54 = @"ks_decrypt_data: invalid length on CBC data";
        }
        else
        {
          CFStringRef v54 = @"ks_decrypt_data: Check for underflow (CBC check)";
        }
        uint64_t v80 = v69;
        goto LABEL_114;
      }
LABEL_112:
      CFStringRef v54 = @"ks_decrypt_data: Check for underflow (wrapped_key/taglen)";
      goto LABEL_113;
    }
    uint64_t v53 = 0;
    if (v108 != 1)
    {
      uint64_t v22 = sub_100012A40(-26275, v109, @"ks_decrypt_data: invalid version %d", v108);
      CFDictionaryRef v23 = 0;
      uint64_t v24 = 0;
      int v25 = 0;
      unsigned int v26 = 0;
      goto LABEL_140;
    }
  }
  else
  {
    uint64_t v53 = 16;
    uint64_t v113 = 16;
  }
  if (v45 <= 3)
  {
    CFStringRef v54 = @"ks_decrypt_data: Check for underflow (wrapped_key_size)";
LABEL_113:
    uint64_t v80 = v109;
LABEL_114:
    uint64_t v22 = sub_100012A40(-26275, v80, v54);
    CFDictionaryRef v23 = 0;
    uint64_t v24 = 0;
    goto LABEL_115;
  }
  unsigned int v66 = *(_DWORD *)v22;
  v22 += 4;
  unint64_t v65 = v66;
  unint64_t v67 = v53 + v66;
  unint64_t v68 = v45 - 4 - v67;
  if (v45 - 4 < v67) {
    goto LABEL_112;
  }
  int v69 = v109;
  if (v108 <= 1) {
    goto LABEL_119;
  }
  uint64_t v98 = v22;
  dataOutAvailable = (char *)v68;
  if (v52 > 2)
  {
    LODWORD(v22) = 0;
LABEL_126:
    CFDictionaryRef v82 = v107;
    CFStringRef v107 = (char *)v65;
    CFDictionaryRef v23 = 0;
    if (!sub_100014458(v82, a1, a2, v101, v65, (const void *)v98, 0, Mutable, 0, v69))
    {
      uint64_t v22 = 0;
      uint64_t v24 = 0;
      int v25 = 0;
      goto LABEL_32;
    }
    unsigned int v26 = v108;
    goto LABEL_132;
  }
  if (v106)
  {
    unint64_t v70 = v65;
    unsigned int v71 = sub_100124954(v106, (CFTypeRef *)v109, v49, v50, v51);
    unint64_t v65 = v70;
    CFDictionaryRef v23 = v71;
    int v72 = v107;
    if (!v71)
    {
      uint64_t v24 = 0;
      int v25 = 0;
      uint64_t v22 = 0;
      goto LABEL_32;
    }
  }
  else
  {
    CFDictionaryRef v23 = 0;
    int v72 = v107;
  }
  uint64_t v83 = a1;
  CFStringRef v107 = (char *)v65;
  unsigned int v26 = v108;
  if (!sub_1001249F0(v83, a7, (const UInt8 *)v98, v65, (uint64_t)v111, v108, &v120, &v118, (CFTypeRef *)&v119, v109))
  {
    uint64_t v24 = 0;
    int v25 = 0;
    uint64_t v22 = 0;
    goto LABEL_140;
  }
  if (CFEqual(v72, @"od"))
  {
    uint64_t v22 = 0;
    if (sub_100154F18(v118, v119, Mutable, v105, v23, (uint64_t)v111, v109))
    {
LABEL_132:
      if (v29 < 0) {
        char v84 = (char *)(v98 - (void)CFDataGetBytePtr(a6));
      }
      else {
        char v84 = 0;
      }
      BOOL v85 = CFDataCreateMutable(0, (CFIndex)dataOutAvailable);
      int v25 = v85;
      if (v85)
      {
        BOOL v86 = &v107[v98];
        CFDataSetLength(v85, (CFIndex)dataOutAvailable);
        if (v113)
        {
          CFStringRef v106 = (const __CFString *)&v97;
          __chkstk_darwin();
          v88 = (char *)&v97 - ((v87 + 15) & 0xFFFFFFFFFFFFFFF0);
          memset(v88, 170, v87);
          CFDataGetBytePtr(Mutable);
          CFStringRef v107 = v84;
          CFDataGetLength(Mutable);
          CFDataGetMutableBytePtr(v25);
          uint64_t v89 = CCCryptorGCM();
          if (v89)
          {
            uint64_t v22 = sub_100012A40(-26275, v109, @"ks_decrypt_data: CCCryptorGCM failed: %d", v89);
            CFDictionaryRef v17 = v103;
            int v18 = v104;
            unsigned int v26 = v108;
LABEL_153:
            uint64_t v24 = 0;
            goto LABEL_83;
          }
          int v18 = v104;
          unsigned int v26 = v108;
          if (v113 != 16)
          {
            uint64_t v22 = sub_100012A40(-26276, v109, @"ks_decrypt_data: CCCryptorGCM expected: 16 got: %ld byte tag", v113);
            CFDictionaryRef v17 = v103;
            goto LABEL_153;
          }
          if (timingsafe_bcmp(v88, &dataOutAvailable[(void)v86], 0x10uLL))
          {
            uint64_t v22 = sub_100012A40(-26275, v109, @"ks_decrypt_data: CCCryptorGCM computed tag not same as tag in blob");
            CFDictionaryRef v17 = v103;
            goto LABEL_153;
          }
        }
        else
        {
          *(void *)long long buf = 0xAAAAAAAAAAAAAAAALL;
          unsigned int v90 = CFDataGetBytePtr(Mutable);
          size_t v91 = CFDataGetLength(Mutable);
          dataOut = CFDataGetMutableBytePtr(v25);
          uint64_t v93 = CCCrypt(1u, 0, 1u, v90, v91, 0, v86, (size_t)dataOutAvailable, dataOut, (size_t)dataOutAvailable, (size_t *)buf);
          int v18 = v104;
          if (v93)
          {
            uint64_t v22 = sub_100012A40(-26275, v109, @"ks_decrypt_data: CCCrypt failed: %d", v93);
            uint64_t v24 = 0;
            CFDictionaryRef v17 = v103;
            goto LABEL_83;
          }
          CFDataSetLength(v25, *(CFIndex *)buf);
        }
        CFDictionaryRef v17 = v103;
        if (v22)
        {
          uint64_t v24 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          CFDictionaryAddValue(v24, @"v_Data", v25);
        }
        else
        {
          if (v26 == 2) {
            CFDictionaryRef v94 = (__CFDictionary *)sub_100124D90(v25, (CFErrorRef *)v109);
          }
          else {
            CFDictionaryRef v94 = (__CFDictionary *)sub_100124DDC(v25, (CFTypeRef *)v109);
          }
          uint64_t v24 = v94;
        }
        if (v24)
        {
          uint64_t v22 = 1;
          if (v26 >= 4 && v120)
          {
            context[0] = _NSConcreteStackBlock;
            context[1] = 3221225472;
            context[2] = sub_100124EF0;
            context[3] = &unk_100308F10;
            context[4] = v24;
            CFDictionaryApplyFunction(v120, (CFDictionaryApplierFunction)sub_100124518, context);
          }
          goto LABEL_83;
        }
        v95 = sub_10000B070("SecError");
        if (os_log_type_enabled(v95, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v96 = (__CFString *)v109;
          if (v109) {
            BOOL v96 = *v109;
          }
          *(_DWORD *)long long buf = 67109378;
          *(_DWORD *)&uint8_t buf[4] = v108;
          __int16 v122 = 2112;
          uint64_t v123 = v96;
          _os_log_impl((void *)&_mh_execute_header, v95, OS_LOG_TYPE_DEFAULT, "decode v%d failed: %@", buf, 0x12u);
        }

        uint64_t v24 = 0;
LABEL_74:
        uint64_t v22 = 0;
        goto LABEL_31;
      }
      uint64_t v22 = sub_100012A40(-26275, v109, @"ks_decrypt_data: failed to allocate data for plain text");
      uint64_t v24 = 0;
LABEL_140:
      int v18 = v104;
      goto LABEL_83;
    }
LABEL_155:
    uint64_t v24 = 0;
    int v25 = 0;
    goto LABEL_140;
  }
  if (!CFEqual(v72, @"odel"))
  {
    uint64_t v22 = sub_100012A40(-26276, v109, @"ks_decrypt_data: invalid operation");
    goto LABEL_155;
  }
  int v18 = v104;
  if (sub_100155178(v118, v105, v23, (uint64_t)v111, (CFErrorRef *)v109))
  {
    uint64_t v24 = v120;
    if (v120) {
      CFRetain(v120);
    }
    int v25 = 0;
    uint64_t v22 = 1;
  }
  else
  {
    uint64_t v24 = 0;
    int v25 = 0;
    uint64_t v22 = 0;
  }
LABEL_83:
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  rsize_t v74 = CFDataGetLength(Mutable);
  rsize_t v75 = CFDataGetLength(Mutable);
  memset_s(MutableBytePtr, v74, 0, v75);
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v25) {
    CFRelease(v25);
  }
  if (v110)
  {
    *uint64_t v110 = v111;
  }
  else if (v111)
  {
    CFRelease(v111);
  }
  if (v22)
  {
    if (v18)
    {
      uint64_t v76 = *v18;
      if (*v18 != v24)
      {
        if (!v24 || (CFRetain(v24), (uint64_t v76 = *v18) != 0)) {
          CFRelease(v76);
        }
        *int v18 = v24;
      }
    }
    if (v17) {
      unsigned int *v17 = v26;
    }
  }
  if (v24) {
    CFRelease(v24);
  }
  int v77 = v120;
  if (v120)
  {
    BOOL v120 = 0;
    CFRelease(v77);
  }
  if (v23) {
    CFRelease(v23);
  }
  CFDataRef v78 = v119;
  if (v119)
  {
    CFDataRef v119 = 0;
    CFRelease(v78);
  }
  if (v118) {
    sub_100019344((uint64_t *)&v118);
  }
  return v22;
}

void sub_1000163B8(uint64_t a1)
{
  unsigned int v3 = +[SecDbKeychainMetadataKeyStore cachingEnabled];
  if (v3)
  {
    uint64_t v4 = *(void **)(*(void *)(a1 + 32) + 24);
    int64_t v1 = +[NSNumber numberWithInt:*(unsigned int *)(a1 + 80)];
    CFIndex v5 = [v4 objectForKeyedSubscript:v1];
  }
  else
  {
    CFIndex v5 = 0;
  }
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), v5);
  if (v3)
  {
  }
  uint64_t v6 = *(void *)(a1 + 48);
  if (!*(void *)(*(void *)(v6 + 8) + 40))
  {
    uint64_t v7 = *(void *)(*(void *)(a1 + 64) + 8) + 24;
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 3221225472;
    int v15[2] = sub_1001D0994;
    v15[3] = &unk_100306FD8;
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v9 = *(void **)(a1 + 40);
    uint64_t v17 = v6;
    v15[4] = v8;
    uint64_t v19 = *(void *)(a1 + 80);
    id v10 = v9;
    char v20 = *(unsigned char *)(a1 + 88);
    uint64_t v11 = *(void *)(a1 + 72);
    id v16 = v10;
    uint64_t v18 = v11;
    char v21 = v3;
    char v12 = sub_10000CBA4(1, 0, 0, v7, (uint64_t)v15);
    uint64_t v13 = *(void *)(*(void *)(a1 + 56) + 8);
    if (*(unsigned char *)(v13 + 24)) {
      char v14 = v12;
    }
    else {
      char v14 = 0;
    }
    *(unsigned char *)(v13 + 24) = v14;
  }
}

void sub_100016C8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a29, 8);
  _Block_object_dispose(&a33, 8);
  _Block_object_dispose((const void *)(v33 - 144), 8);
  _Unwind_Resume(a1);
}

CFDataRef sub_100017CB4(const __CFData *result)
{
  if (result)
  {
    CFDataRef v1 = result;
    if (CFDataGetLength(result) != 16) {
      return 0;
    }
    BytePtr = CFDataGetBytePtr(v1);
    if (*(void *)BytePtr == 0xAC4C81CC5CAE23F6 && *((void *)BytePtr + 1) == 0x1135313F01F0D48ALL) {
      return 0;
    }
    if (*(void *)BytePtr == 0x104B57A5353A5AA7 && *((_DWORD *)BytePtr + 2) == -1803342146) {
      return 0;
    }
    return (const __CFData *)((*(void *)BytePtr != 0x114EC8A39FAB1A82 || *((_DWORD *)BytePtr + 2) != -397635414)
                           && (*(void *)BytePtr != 0x9A460A992EBEC436 || *((_DWORD *)BytePtr + 2) != -1542878804));
  }
  return result;
}

const void *sub_100017DBC(const void *a1)
{
  CFDataRef v1 = a1;
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 != CFDateGetTypeID()) {
    return 0;
  }
  CFRetain(v1);
  return v1;
}

uint64_t sub_100017E04(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (qword_10035CBC8 != -1) {
    dispatch_once(&qword_10035CBC8, &stru_1002F7518);
  }
  uint64_t v2 = qword_10035CBD0;
  unsigned int v3 = *(uint64_t (**)(uint64_t, uint64_t))(v1 + 16);

  return v3(v1, v2);
}

void sub_100017E70(uint64_t a1)
{
  if (!qword_10035D0E0)
  {
    if (qword_10035CBD8 != -1) {
      dispatch_once(&qword_10035CBD8, &stru_1002F75D0);
    }
    uint64_t v2 = *(void **)(a1 + 32);
    unsigned int v3 = (const void *)qword_10035D0E0;
    qword_10035D0E0 = 0;
    if (os_variant_is_recovery())
    {
      CFStringRef v4 = @"keychain-recovery-2.db";
      int v5 = 1;
    }
    else
    {
      if (qword_10035D140 != -1) {
        dispatch_once(&qword_10035D140, &stru_100305008);
      }
      if (byte_10035D138) {
        CFStringRef v6 = @"keychain-2.db";
      }
      else {
        CFStringRef v6 = @"keychain-2-debug.db";
      }
      if (qword_10035CC68 != -1) {
        dispatch_once(&qword_10035CC68, &stru_1002F7BD0);
      }
      BOOL v7 = byte_10035CC60 == 0;
      syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", byte_10035CC60);
      int v5 = v7;
      CFStringRef v4 = v6;
    }
    CFURLRef v8 = sub_10002B9E8(v5, (uint64_t)v4);
    CFURLRef v9 = v8;
    if (v8)
    {
      CFStringRef v10 = CFURLCopyFileSystemPath(v8, kCFURLPOSIXPathStyle);
      CFRelease(v9);
    }
    else
    {
      CFStringRef v10 = 0;
    }
    uint64_t v11 = sub_10000B070("__SecKeychainCopyPath");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      if (v10)
      {
        CStringPtr = CFStringGetCStringPtr(v10, 0x8000100u);
        uint64_t v13 = "<unknown>";
        if (CStringPtr) {
          uint64_t v13 = CStringPtr;
        }
      }
      else
      {
        uint64_t v13 = "<null>";
      }
      *(_DWORD *)long long buf = 136315138;
      *(void *)&uint8_t buf[4] = v13;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "path: %s", buf, 0xCu);
    }
    if (v10)
    {
      uint64_t v28 = 0;
      int v29 = &v28;
      uint64_t v30 = 0x2000000000;
      uint64_t v31 = 0;
      aBlock = _NSConcreteStackBlock;
      uint64_t v24 = 0x40000000;
      int v25 = sub_100140618;
      unsigned int v26 = &unk_100303DE0;
      int v27 = &v28;
      *(void *)long long buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 0x40000000;
      *(void *)&uint8_t buf[16] = sub_100026600;
      id v36 = &unk_1002F7650;
      unint64_t v37 = &qword_10035CBE8;
      if (qword_10035CBE0 != -1) {
        dispatch_once(&qword_10035CBE0, buf);
      }
      uint64_t Instance = _CFRuntimeCreateInstance();
      if (Instance)
      {
        if (getenv("__OSINSTALL_ENVIRONMENT"))
        {
          size_t v15 = sub_10000B070("#SecDB");
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)long long buf = 0;
            _os_log_debug_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEBUG, "SecDB: running from installer", buf, 2u);
          }
          CFStringRef Copy = @"file::memory:?cache=shared";
        }
        else
        {
          CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, v10);
        }
        *(void *)(Instance + 16) = Copy;
        v33[0] = _NSConcreteStackBlock;
        v33[1] = 0x40000000;
        v33[2] = sub_100026814;
        v33[3] = &unk_1002F7670;
        v33[4] = Instance;
        *(void *)long long buf = _NSConcreteStackBlock;
        *(void *)&uint8_t buf[8] = 0x40000000;
        *(void *)&uint8_t buf[16] = sub_10000B880;
        id v36 = &unk_1002F7408;
        unint64_t v37 = v33;
        sub_10000EB80(v10, (uint64_t)buf);
        CFStringRef v18 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@-commit", v10, aBlock, v24, v25, v26, v27, v28);
        v32[0] = _NSConcreteStackBlock;
        v32[1] = 0x40000000;
        v32[2] = sub_100026848;
        v32[3] = &unk_1002F7690;
        v32[4] = Instance;
        *(void *)long long buf = _NSConcreteStackBlock;
        *(void *)&uint8_t buf[8] = 0x40000000;
        *(void *)&uint8_t buf[16] = sub_10000B880;
        id v36 = &unk_1002F7408;
        unint64_t v37 = v32;
        sub_10000EB80(v18, (uint64_t)buf);
        if (v18) {
          CFRelease(v18);
        }
        *(void *)(Instance + 40) = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        *(void *)(Instance + 48) = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        v34.__sig = 0xAAAAAAAAAAAAAAAALL;
        *(void *)v34.__opaque = 0xAAAAAAAAAAAAAAAALL;
        if (pthread_mutexattr_init(&v34) || (uint64_t v19 = &v34, pthread_mutexattr_setpolicy_np(&v34, 1)))
        {
          char v20 = sub_10000B070("SecCritical");
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "SecDb: SecDbCreate failed to create attributes for the write mutex; fairness properties are no longer present",
              buf,
              2u);
          }
          uint64_t v19 = 0;
        }
        if (pthread_mutex_init((pthread_mutex_t *)(Instance + 56), v19))
        {
          char v21 = sub_10000B070("SecCritical");
          if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "SecDb: SecDbCreate failed to init the write mutex, this will end badly", buf, 2u);
          }
        }
        pthread_mutexattr_destroy(&v34);
        *(void *)(Instance + 120) = dispatch_semaphore_create(5);
        *(unsigned char *)(Instance + 128) = 0;
        *(void *)(Instance + 136) = _Block_copy(&aBlock);
        *(unsigned char *)(Instance + 144) = 0;
        *(_DWORD *)(Instance + 148) = 0;
        *(void *)(Instance + 152) = 0;
        *(_WORD *)(Instance + 160) = 384;
        *(_DWORD *)(Instance + 162) = 16843009;
        *(unsigned char *)(Instance + 166) = 6;
        *(void *)(Instance + 168) = 0;
        *(void *)(Instance + 168) = _Block_copy(&stru_100303E20);
      }
      if (v2) {
        *uint64_t v2 = v29[3];
      }
      _Block_object_dispose(&v28, 8);
      qword_10035D0E0 = Instance;
      CFRelease(v10);
    }
    else
    {
      uint64_t v17 = sub_10000B070("SecError");
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "no keychain path available", buf, 2u);
      }
    }
    if (v3)
    {
      uint64_t v22 = sub_10000B070("SecError");
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412546;
        *(void *)&uint8_t buf[4] = v3;
        *(_WORD *)&buf[12] = 2112;
        *(void *)&buf[14] = qword_10035D0E0;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "replaced %@ with %@", buf, 0x16u);
      }
      CFRelease(v3);
    }
  }
}

void sub_10001856C(uint64_t a1)
{
  uint64_t v2 = (void *)qword_10035D2A0;
  if (!qword_10035D2A0)
  {
    id v3 = [objc_alloc(*(Class *)(a1 + 40)) _init];
    CFStringRef v4 = (void *)qword_10035D2A0;
    qword_10035D2A0 = (uint64_t)v3;

    uint64_t v2 = (void *)qword_10035D2A0;
  }
  int v5 = (id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);

  objc_storeStrong(v5, v2);
}

void sub_1000185E8(id a1)
{
  if (!dword_10035CAE0) {
    dword_10035CAE0 = sub_10001A2AC("IOService:/IOResources/AppleKeyStore", "AppleKeyStore");
  }
}

uint64_t sub_1000186A4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(void, void *, unint64_t *, unint64_t *, uint64_t), void *a5, unint64_t a6, void *a7, void *a8)
{
  unint64_t v45 = a5;
  uint64_t v43 = a1;
  memset(__s, 0, sizeof(__s));
  uint64_t v14 = ccaes_cbc_decrypt_mode();
  __chkstk_darwin();
  uint64_t v46 = (uint64_t)&v37 - v15;
  bzero((char *)&v37 - v15, v15);
  __chkstk_darwin();
  uint64_t v17 = (char *)&v37 - v16;
  bzero((char *)&v37 - v16, v16);
  uint64_t v18 = 0xFFFFFFFFLL;
  if (HIDWORD(a6)) {
    goto LABEL_33;
  }
  uint64_t v39 = a3;
  unsigned int v19 = a6 >> 3;
  if ((a6 >> 3) - 6 < 0xFFFFFFFC) {
    goto LABEL_33;
  }
  unsigned int v40 = &v37;
  int v41 = a8;
  id v38 = a7;
  unint64_t v44 = a6;
  if (!a4)
  {
    BOOL v20 = (a2 & 0xFFFFFFFFFFFFFFF7) == 0x10 || a2 == 32;
    if (!v20 || !a8 || *a8 < a6 - 8)
    {
      memset_s(__s, 0x40uLL, 0, 0x40uLL);
      goto LABEL_34;
    }
    cccbc_init();
    goto LABEL_15;
  }
  if (a8 && *v41 >= v44 - 8)
  {
LABEL_15:
    *(void *)&__s[0] = *v45;
    uint64_t v21 = v19 - 1;
    if (v19 != 1)
    {
      uint64_t v22 = (void *)__s + 1;
      CFDictionaryRef v23 = v45 + 1;
      uint64_t v24 = v19 - 1;
      do
      {
        uint64_t v25 = *v23++;
        *uint64_t v22 = v25;
        v22 += 2;
        --v24;
      }
      while (v24);
    }
    int v26 = 6 * v19 - 6;
    LODWORD(v43) = 1 - v19;
    int v27 = 5;
    double v42 = (unint64_t *)&__s[v19 - 2];
    do
    {
      LODWORD(v45) = v27;
      if (v44 >= 0x10)
      {
        uint64_t v28 = v42;
        int v29 = v21;
        unsigned int v30 = v26;
        do
        {
          *uint64_t v28 = *(void *)&__s[v29 % v21] ^ bswap64(v30);
          if (a4)
          {
            if ((a4(0, &unk_10035D4B0, v28, v28, 16) & 1) == 0) {
              goto LABEL_6;
            }
          }
          else
          {
            cccbc_clear_iv();
            sub_10001BE10(v14, v46, (uint64_t)v17, 0x10uLL);
          }
          --v30;
          v28 -= 2;
          BOOL v31 = __OFSUB__(v29--, 1);
        }
        while (!((v29 < 0) ^ v31 | (v29 == 0)));
      }
      int v27 = v45 - 1;
      v26 += v43;
    }
    while (v45);
    if (*(void *)&__s[0] == v39)
    {
      uint64_t v32 = v38;
      if (v21)
      {
        uint64_t v33 = (uint64_t *)__s + 1;
        uint64_t v34 = v21;
        do
        {
          uint64_t v35 = *v33;
          v33 += 2;
          *v32++ = v35;
          --v34;
        }
        while (v34);
      }
      uint64_t v18 = 0;
      *int v41 = (8 * v21);
    }
    else
    {
      uint64_t v18 = 0xFFFFFFFFLL;
    }
LABEL_33:
    memset_s(__s, 0x40uLL, 0, 0x40uLL);
    if (a4) {
      return v18;
    }
LABEL_34:
    cc_clear();
    return v18;
  }
LABEL_6:
  memset_s(__s, 0x40uLL, 0, 0x40uLL);
  return 0xFFFFFFFFLL;
}

uint64_t sub_100018A0C(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t (*a4)(void, void *, unint64_t *, unint64_t *, uint64_t), void *a5, unsigned int a6, void *a7, _DWORD *a8)
{
  uint64_t v11 = *a8;
  uint64_t v9 = sub_1000186A4(a1, a2, a3, a4, a5, a6, a7, &v11);
  sub_10001BD78(HIDWORD(v11) == 0, 261, "/Library/Caches/com.apple.xbs/Sources/AppleKeyStore_libs/aeskeywrap.c");
  *a8 = v11;
  return v9;
}

uint64_t sub_100018A78(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, void *a8)
{
  unsigned int v19 = 0;
  if (a1
    && (uint64_t v14 = a1 + a2, sub_10001BF70(a1) == a2)
    && sub_10001C880(&v19, (uint64_t)off_10035A978, a1, v14)
    || a3 && sub_10001BF70(a3) == a4 && sub_10001C880(&v19, (uint64_t)off_10035A960, a3, a3 + a4)
    || a5 && sub_10001CA00(&v19, (uint64_t)off_10035A970, a5)
    || (v17 = 0, size_t v18 = 0, sub_10001C6B0(&v19, &v17, &v18)))
  {
    uint64_t v15 = 0xFFFFFFFFLL;
  }
  else
  {
    uint64_t v15 = 0;
    *a7 = v17;
    *a8 = v18;
  }
  sub_10001C268(&v19);
  return v15;
}

void *sub_100018BB8(uint64_t a1)
{
  uint64_t v2 = calloc(8uLL, 1uLL);
  id v3 = v2;
  if (v2)
  {
    *uint64_t v2 = 0;
    if (a1)
    {
      if (sub_10001C598((uint64_t)v2))
      {
        memset_s(v3, 8uLL, 0, 8uLL);
        free(v3);
        return 0;
      }
    }
  }
  return v3;
}

void *sub_100018C3C(int a1, int a2)
{
  switch(a1)
  {
    case 1:
      uint64_t v2 = (void **)&off_10035A978;
      goto LABEL_28;
    case 2:
      uint64_t v2 = (void **)&off_10035A960;
      goto LABEL_28;
    case 3:
      uint64_t v2 = (void **)&off_10035A970;
      goto LABEL_28;
    case 4:
      uint64_t v2 = (void **)&off_10035A980;
      goto LABEL_28;
    case 5:
      uint64_t v2 = (void **)&off_10035A948;
      goto LABEL_28;
    case 6:
      uint64_t v2 = (void **)&off_10035AA90;
      goto LABEL_28;
    case 7:
      uint64_t v2 = (void **)&off_10035AA88;
      goto LABEL_28;
    case 8:
      CFStringRef v4 = (void **)&off_10035AAA0;
      goto LABEL_30;
    case 9:
      CFStringRef v4 = (void **)&off_10035AAA8;
      goto LABEL_30;
    case 10:
      uint64_t v2 = (void **)&off_10035AAB8;
      goto LABEL_28;
    case 11:
      uint64_t v2 = (void **)&off_10035AAC0;
      goto LABEL_28;
    case 12:
      uint64_t v2 = (void **)&off_10035AAC8;
      goto LABEL_28;
    case 13:
      uint64_t v2 = (void **)&off_10035AAD0;
      goto LABEL_28;
    case 14:
      uint64_t v2 = (void **)&off_10035AAD8;
      goto LABEL_28;
    case 15:
      uint64_t v2 = (void **)&off_10035AA98;
      goto LABEL_28;
    case 16:
      CFStringRef v4 = (void **)&off_10035A9E0;
      goto LABEL_30;
    case 17:
      uint64_t v2 = (void **)&off_10035A9F0;
      goto LABEL_28;
    case 18:
      CFStringRef v4 = (void **)&off_10035A9F8;
      goto LABEL_30;
    case 19:
      int v5 = off_10035AA08;
      BOOL v6 = a2 == 3;
      goto LABEL_31;
    case 20:
      CFStringRef v4 = (void **)&off_10035AA10;
      goto LABEL_30;
    case 21:
      uint64_t v2 = (void **)&off_10035AA18;
      goto LABEL_28;
    case 22:
      CFStringRef v4 = (void **)&off_10035AA00;
      goto LABEL_30;
    case 23:
      CFStringRef v4 = (void **)&off_10035A9E8;
      goto LABEL_30;
    case 24:
      uint64_t v2 = (void **)&off_10035AAE0;
      goto LABEL_28;
    case 25:
      uint64_t v2 = (void **)&off_10035AAF0;
LABEL_28:
      int v5 = *v2;
      BOOL v6 = a2 == 2;
      goto LABEL_31;
    case 26:
      CFStringRef v4 = (void **)&off_10035AAB0;
LABEL_30:
      int v5 = *v4;
      BOOL v6 = a2 == 1;
LABEL_31:
      if (v6) {
        CFTypeRef result = v5;
      }
      else {
        CFTypeRef result = 0;
      }
      break;
    default:
      CFTypeRef result = 0;
      break;
  }
  return result;
}

uint64_t sub_100018E2C(void *a1, int a2, uint64_t a3)
{
  uint64_t v6 = 3758097090;
  BOOL v7 = (unsigned __int8 *)sub_100018C3C(a2, 2);
  if (v7)
  {
    uint64_t v8 = (uint64_t)v7;
    if (!sub_10001C2E8(a1, v7))
    {
      if (a3)
      {
        if (a2 == 1 || a2 == 2)
        {
          ccder_blob_decode_tag();
          return v6;
        }
        if (sub_10001CA00(a1, v8, a3)) {
          return v6;
        }
      }
      return 0;
    }
  }
  return v6;
}

uint64_t sub_100018F2C(void ***a1)
{
  uint64_t result = 3758097090;
  if (a1)
  {
    id v3 = *a1;
    if (*a1)
    {
      *a1 = 0;
      sub_10001C268(v3);
      memset_s(v3, 8uLL, 0, 8uLL);
      free(v3);
      return 0;
    }
  }
  return result;
}

uint64_t sub_100018F90(int a1, int a2, unsigned int a3, uint64_t a4, uint64_t a5, void ***a6)
{
  uint64_t v11 = 3758097090;
  char v12 = off_10035A9C0;
  uint64_t v13 = (void **)calloc(8uLL, 1uLL);
  *uint64_t v13 = 0;
  sub_10001C9F0(v13, (uint64_t)off_10035A930, (uint64_t)v12);
  uint64_t v25 = 0;
  size_t v26 = 0;
  CFDictionaryRef v23 = 0;
  rsize_t v24 = 0;
  if (!a6) {
    goto LABEL_14;
  }
  uint64_t v14 = calloc(0x50uLL, 1uLL);
  uint64_t v22 = v14;
  if (!v14)
  {
    uint64_t v11 = 3758604298;
    goto LABEL_14;
  }
  uint64_t v15 = (void **)v14;
  memset_s(v14, 0x50uLL, 0, 0x50uLL);
  if (a4 && sub_10001C598((uint64_t)v13)
    || sub_10001CB70(v13, (uint64_t)off_10035A940, a2)
    || sub_10001CB70(v13, (uint64_t)off_10035A990, a3)
    || sub_10001C6B0(v13, &v25, &v26))
  {
LABEL_17:
    sub_100019344((uint64_t *)&v22);
    goto LABEL_14;
  }
  uint64_t v16 = sub_1000198B0();
  if (v16)
  {
    uint64_t v11 = v16;
    goto LABEL_17;
  }
  uint64_t v17 = (char *)v23;
  rsize_t v18 = v24;
  NSObject *v15 = v23;
  v15[1] = (void *)v18;
  *((_DWORD *)v15 + 10) = a1;
  int v15[2] = &v17[v18];
  BOOL v20 = 0;
  uint64_t v21 = 0;
  if (sub_10001C0B0((uint64_t)off_10035A9A0, &v20, &v21)) {
    v15[4] = v20;
  }
  if (sub_10001C0B0((uint64_t)off_10035A960, &v20, &v21)) {
    v15[3] = v20;
  }
  uint64_t v11 = 0;
  *a6 = v15;
  CFDictionaryRef v23 = 0;
  rsize_t v24 = 0;
LABEL_14:
  sub_10001C268(v13);
  memset_s(v13, 8uLL, 0, 8uLL);
  free(v13);
  memset_s(v25, v26, 0, v26);
  free(v25);
  memset_s(v23, v24, 0, v24);
  free(v23);
  return v11;
}

uint64_t sub_1000191C0(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = 3758097090;
  uint64_t v8 = off_10035A9A8;
  uint64_t v9 = (void **)calloc(8uLL, 1uLL);
  *uint64_t v9 = 0;
  sub_10001C9F0(v9, (uint64_t)off_10035A930, (uint64_t)v8);
  __s = 0;
  rsize_t __n = 0;
  if (!sub_100019BC8((uint64_t)a1, v9, a2))
  {
    sub_10001C2E8(v9, (unsigned __int8 *)off_10035A948);
    sub_10001C2E8(v9, (unsigned __int8 *)off_10035A9A0);
    if (!sub_10001CA00(v9, (uint64_t)off_10035A948, a4)
      && !sub_10001C880(v9, (uint64_t)off_10035A9A0, *a1, a1[2])
      && !sub_10001C6B0(v9, &__s, &__n))
    {
      uint64_t v7 = sub_1000198B0();
    }
  }
  sub_10001C268(v9);
  memset_s(v9, 8uLL, 0, 8uLL);
  free(v9);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v7;
}

uint64_t sub_100019344(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (!*a1) {
    return 3758097090;
  }
  *a1 = 0;
  if (*(void *)v1)
  {
    memset_s(*(void **)v1, *(void *)(v1 + 8), 0, *(void *)(v1 + 8));
    free(*(void **)v1);
  }
  uint64_t v2 = *(void **)(v1 + 48);
  if (v2)
  {
    memset_s(v2, *(void *)(v1 + 56), 0, *(void *)(v1 + 56));
    free(*(void **)(v1 + 48));
  }
  id v3 = *(void **)(v1 + 64);
  if (v3)
  {
    memset_s(v3, *(void *)(v1 + 72), 0, *(void *)(v1 + 72));
    free(*(void **)(v1 + 64));
  }
  memset_s((void *)v1, 0x50uLL, 0, 0x50uLL);
  free((void *)v1);
  return 0;
}

uint64_t sub_1000193F8(int a1, const void *a2, size_t a3, uint64_t *a4)
{
  uint64_t v4 = 3758097090;
  if (a2)
  {
    if (a3)
    {
      if (sub_10001BF70((uint64_t)a2) == a3)
      {
        uint64_t v4 = 3758604298;
        uint64_t v9 = calloc(0x50uLL, 1uLL);
        char v12 = v9;
        if (v9)
        {
          uint64_t v10 = (uint64_t)v9;
          memset_s(v9, 0x50uLL, 0, 0x50uLL);
          *(_DWORD *)(v10 + 40) = a1;
          if (sub_100019A90(v10, a2, a3))
          {
            sub_100019344((uint64_t *)&v12);
          }
          else
          {
            uint64_t v4 = 0;
            *a4 = v10;
          }
        }
      }
    }
  }
  return v4;
}

uint64_t sub_1000194C0(uint64_t *a1, uint64_t a2, uint64_t a3, void *a4, size_t a5)
{
  uint64_t v9 = 3758097090;
  uint64_t v10 = off_10035A9B0;
  uint64_t v11 = (void **)calloc(8uLL, 1uLL);
  *uint64_t v11 = 0;
  sub_10001C9F0(v11, (uint64_t)off_10035A930, (uint64_t)v10);
  __s = 0;
  rsize_t __n = 0;
  uint64_t v15 = a4;
  size_t v16 = a5;
  if (a4)
  {
    if (a5)
    {
      uint64_t v12 = (uint64_t)a4 + a5;
      if (sub_10001BF70((uint64_t)a4) == a5)
      {
        int v13 = sub_100019C54((uint64_t)a1);
        if (!v13)
        {
          uint64_t v22 = 0;
          CFDictionaryRef v23 = 0;
          uint64_t v20 = 0;
          uint64_t v21 = 0;
          uint64_t v19 = 0;
          if (!sub_10001C0B0((uint64_t)off_10035A968, &v19, &v20)
            || !sub_10001C0B0((uint64_t)off_10035A958, &v21, &v22)
            || sub_10001C880(&v23, (uint64_t)off_10035A948, v21, v12)
            || sub_10001C880(&v23, (uint64_t)off_10035A968, v19, v12)
            || sub_10001C6B0(&v23, &v15, &v16))
          {
            sub_10001C268(&v23);
            goto LABEL_19;
          }
          sub_10001C268(&v23);
        }
        if (!sub_100019BC8((uint64_t)a1, v11, a2))
        {
          sub_10001C2E8(v11, (unsigned __int8 *)off_10035A948);
          sub_10001C2E8(v11, (unsigned __int8 *)off_10035A9A0);
          if (!sub_10001C880(v11, (uint64_t)off_10035A948, (uint64_t)v15, (uint64_t)v15 + v16)
            && !sub_10001C880(v11, (uint64_t)off_10035A9A0, *a1, a1[2])
            && !sub_10001C6B0(v11, &__s, &__n))
          {
            uint64_t v9 = sub_1000198B0();
          }
        }
        if (!v13)
        {
          memset_s(v15, v16, 0, v16);
          free(v15);
        }
      }
    }
  }
LABEL_19:
  sub_10001C268(v11);
  memset_s(v11, 8uLL, 0, 8uLL);
  free(v11);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v9;
}

uint64_t sub_100019754(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = 3758097090;
  int v5 = off_10035A9B8;
  uint64_t v6 = (void **)calloc(8uLL, 1uLL);
  *uint64_t v6 = 0;
  sub_10001C9F0(v6, (uint64_t)off_10035A930, (uint64_t)v5);
  __s = 0;
  rsize_t __n = 0;
  if (!sub_100019BC8((uint64_t)a1, v6, a2))
  {
    sub_10001C2E8(v6, (unsigned __int8 *)off_10035A9A0);
    if (!sub_10001C880(v6, (uint64_t)off_10035A9A0, *a1, a1[2])
      && !sub_10001C6B0(v6, &__s, &__n))
    {
      uint64_t v4 = sub_1000198B0();
    }
  }
  sub_10001C268(v6);
  memset_s(v6, 8uLL, 0, 8uLL);
  free(v6);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v4;
}

uint64_t sub_1000198B0()
{
  int v0 = __chkstk_darwin();
  uint64_t v2 = v1;
  uint64_t v4 = v3;
  size_t v6 = v5;
  uint64_t v8 = v7;
  int v9 = v0;
  mach_port_t v10 = sub_1000149A8();
  if (v10)
  {
    if (v8)
    {
      mach_port_t v11 = v10;
      uint64_t v12 = 3758097090;
      if (sub_10001BF70((uint64_t)v8) == v6)
      {
        bzero(__src, 0x8000uLL);
        size_t __count = 0x8000;
        uint64_t input = v9;
        uint64_t v12 = IOConnectCallMethod(v11, 0x2Bu, &input, 1u, v8, v6, 0, 0, __src, &__count);
        if (!v12 && v4 && v2)
        {
          int v13 = calloc(__count, 1uLL);
          *uint64_t v4 = v13;
          if (v13)
          {
            memcpy(v13, __src, __count);
            uint64_t v12 = 0;
            *uint64_t v2 = __count;
          }
          else
          {
            uint64_t v12 = 3758097085;
          }
        }
      }
    }
    else
    {
      uint64_t v12 = 3758097090;
    }
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "_aks_operation", ":", 457, "", 0, "", "");
    uint64_t v12 = 3758097084;
  }
  memset_s(__src, 0x8000uLL, 0, 0x8000uLL);
  return v12;
}

uint64_t sub_100019A90(uint64_t a1, const void *a2, size_t a3)
{
  uint64_t v8 = 0;
  uint64_t v9 = 0;
  if (!sub_10001C0B0((uint64_t)off_10035A9A0, &v8, &v9)) {
    return 3758097090;
  }
  if (*(void *)a1)
  {
    memset_s(*(void **)a1, *(void *)(a1 + 8), 0, *(void *)(a1 + 8));
    free(*(void **)a1);
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = 0;
  }
  size_t v6 = calloc(a3, 1uLL);
  *(void *)a1 = v6;
  *(void *)(a1 + 8) = a3;
  if (!v6) {
    return 3758604298;
  }
  memcpy(v6, a2, a3);
  *(void *)(a1 + 16) = *(void *)a1 + *(void *)(a1 + 8);
  if (sub_10001C0B0((uint64_t)off_10035A9A0, &v8, &v9)) {
    *(void *)(a1 + 32) = v8;
  }
  if ((sub_10001C0B0((uint64_t)off_10035A960, &v8, &v9) & 1) != 0
    || (uint64_t result = sub_10001C0B0((uint64_t)off_10035A950, &v8, &v9), result))
  {
    uint64_t result = 0;
    *(void *)(a1 + 24) = v8;
  }
  return result;
}

uint64_t sub_100019BC8(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v3 = 3758604298;
  if (a1
    && (!*(void *)(a1 + 48) || !sub_10001C598((uint64_t)a2))
    && (!a3 || !sub_10001C598((uint64_t)a2)))
  {
    sub_10001C2E8(a2, (unsigned __int8 *)off_10035A960);
    return 0;
  }
  return v3;
}

uint64_t sub_100019C54(uint64_t a1)
{
  if (!*(void *)(a1 + 32)) {
    return 0;
  }
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  uint64_t result = sub_10001C0B0((uint64_t)off_10035A998, &v2, &v3);
  if (result) {
    return sub_10001C18C();
  }
  return result;
}

uint64_t sub_100019CBC(uint64_t a1)
{
  if (!*(void *)(a1 + 32)) {
    return 0;
  }
  uint64_t v2 = 0;
  uint64_t v3 = 0;
  uint64_t result = sub_10001C0B0((uint64_t)off_10035A990, &v2, &v3);
  if (result) {
    return sub_10001C18C();
  }
  return result;
}

uint64_t sub_100019D1C(void *a1, void *a2)
{
  unsigned int v16 = 0;
  uint64_t v15 = 0;
  if (!a1[4]) {
    return 0;
  }
  uint64_t v13 = 0;
  uint64_t v14 = 0;
  if (sub_10001C0B0((uint64_t)off_10035A988, &v13, &v14))
  {
    *(void *)&long long v12 = v13;
    *((void *)&v12 + 1) = v13 + v14;
    sub_10001C1F8(&v12, 4, &v16, &v15);
  }
  int v4 = sub_100019CBC((uint64_t)a1);
  if ((v4 - 7) < 2)
  {
    uint64_t v5 = ccec_cp_384();
    goto LABEL_9;
  }
  if ((v4 - 4) <= 1)
  {
    uint64_t v5 = ccec_cp_256();
LABEL_9:
    if (v5 && v16 == (unint64_t)(j__cczp_bitlen() + 7) >> 3)
    {
      if (v15 && !a1[8])
      {
        __chkstk_darwin();
        bzero((char *)&v11 - v7, v7);
        ccec_compact_import_pub();
        size_t v8 = (2 * sub_10001BDEC()) | 1;
        uint64_t v9 = calloc(v8, 1uLL);
        a1[8] = v9;
        a1[9] = v8;
        if (v9) {
          ccec_export_pub();
        }
        cc_clear();
      }
      uint64_t v10 = a1[9];
      uint64_t v15 = a1[8];
      unsigned int v16 = v10;
    }
  }
  *a2 = v16;
  return v15;
}

uint64_t sub_100019EF4(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7 = 3758097090;
  size_t v8 = off_10035A9C8;
  uint64_t v9 = (void **)calloc(8uLL, 1uLL);
  *uint64_t v9 = 0;
  sub_10001C9F0(v9, (uint64_t)off_10035A930, (uint64_t)v8);
  __s = 0;
  rsize_t __n = 0;
  if (!sub_100019BC8((uint64_t)a1, v9, a2))
  {
    sub_10001C2E8(v9, (unsigned __int8 *)off_10035A948);
    sub_10001C2E8(v9, (unsigned __int8 *)off_10035A9A0);
    if (!sub_10001CA00(v9, (uint64_t)off_10035A948, a4)
      && !sub_10001C880(v9, (uint64_t)off_10035A9A0, *a1, a1[2])
      && !sub_10001C6B0(v9, &__s, &__n))
    {
      uint64_t v7 = sub_1000198B0();
    }
  }
  sub_10001C268(v9);
  memset_s(v9, 8uLL, 0, 8uLL);
  free(v9);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v7;
}

uint64_t sub_10001A078(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v9 = 3758097090;
  uint64_t v10 = off_10035A9D0;
  uint64_t v11 = (void **)calloc(8uLL, 1uLL);
  *uint64_t v11 = 0;
  sub_10001C9F0(v11, (uint64_t)off_10035A930, (uint64_t)v10);
  __s = 0;
  rsize_t __n = 0;
  if (!sub_100019BC8((uint64_t)a1, v11, a2))
  {
    sub_10001C2E8(v11, (unsigned __int8 *)off_10035A948);
    sub_10001C2E8(v11, (unsigned __int8 *)off_10035A9A0);
    if (!sub_10001C880(v11, (uint64_t)off_10035A948, a4, a4 + a5)
      && !sub_10001C880(v11, (uint64_t)off_10035A9A0, *a1, a1[2])
      && !sub_10001C6B0(v11, &__s, &__n))
    {
      uint64_t v9 = sub_1000198B0();
    }
  }
  sub_10001C268(v11);
  memset_s(v11, 8uLL, 0, 8uLL);
  free(v11);
  if (__s)
  {
    memset_s(__s, __n, 0, __n);
    free(__s);
  }
  return v9;
}

uint64_t sub_10001A1FC(uint64_t *a1, void *a2)
{
  uint64_t result = *a1;
  *a2 = a1[1];
  return result;
}

uint64_t sub_10001A208(uint64_t a1, uint64_t *a2)
{
  *a2 = sub_10001BF70(*(void *)(a1 + 24));
  return *(void *)(a1 + 24);
}

void sub_10001A240(void *a1, rsize_t __n)
{
  memset_s(a1, __n, 0, __n);

  free(a1);
}

void sub_10001A280(id a1)
{
  qword_10035CAF0 = (uint64_t)dispatch_queue_create("aks-client-queue", 0);
}

uint64_t sub_10001A2AC(char *path, const char *a2)
{
  kern_return_t v5;
  CFDictionaryRef v6;
  io_service_t MatchingService;
  io_object_t v8;
  uint64_t result;
  kern_return_t v10;
  io_connect_t connect;

  connect = 0;
  io_service_t v3 = IORegistryEntryFromPath(kIOMasterPortDefault, path);
  if (!v3 || (io_object_t v4 = v3, v5 = IOServiceOpen(v3, mach_task_self_, 0, &connect), IOObjectRelease(v4), v5))
  {
    size_t v6 = IOServiceMatching(a2);
    MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v6);
    if (MatchingService)
    {
      size_t v8 = MatchingService;
      IOServiceOpen(MatchingService, mach_task_self_, 0, &connect);
      IOObjectRelease(v8);
    }
  }
  uint64_t result = connect;
  if (connect)
  {
    uint64_t v10 = IOConnectCallMethod(connect, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    uint64_t result = connect;
    if (v10)
    {
      IOServiceClose(connect);
      return 0;
    }
  }
  return result;
}

uint64_t sub_10001A3A4(uint64_t a1, uint64_t a2, void *a3)
{
  *(void *)&long long v6 = a1;
  *((void *)&v6 + 1) = a1 + a2;
  if (!ccder_blob_decode_range()
    || !sub_10001CFF8(&v6, 0x8000000000000000, a3)
    || !sub_10001C408(&v6, 0x8000000000000001, (uint64_t)(a3 + 1), 16)
    || !sub_10001C408(&v6, 0x8000000000000002, (uint64_t)(a3 + 3), 40)
    || !sub_10001C408(&v6, 0x8000000000000003, (uint64_t)(a3 + 8), 16))
  {
    return 4294967277;
  }
  int v4 = sub_10001CFF8(&v6, 0x8000000000000004, a3 + 10);
  uint64_t result = 4294967277;
  if (v4)
  {
    if ((void)v6 == *((void *)&v6 + 1)) {
      return 0;
    }
    else {
      return 4294967277;
    }
  }
  return result;
}

uint64_t sub_10001A484(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  memset(__s, 0, sizeof(__s));
  int v9 = 32;
  if (*(void *)a1)
  {
    uint64_t v7 = 4294967284;
  }
  else
  {
    ccsha256_di();
    if (j__ccpbkdf2_hmac()) {
      goto LABEL_9;
    }
    uint64_t v6 = sub_100018A0C((uint64_t)__s, 0x20u, 0xA6A6A6A6A6A6A6A6, 0, (void *)(a1 + 24), 0x28u, (void *)a4, &v9);
    if (v6)
    {
      uint64_t v7 = v6;
      goto LABEL_8;
    }
    if (v9 != 32)
    {
LABEL_9:
      uint64_t v7 = 4294967286;
    }
    else
    {
      cccurve25519_make_pub();
      if (uuid_compare((const unsigned __int8 *)(a1 + 8), (const unsigned __int8 *)(a4 + 32))) {
        uint64_t v7 = 4294967272;
      }
      else {
        uint64_t v7 = 0;
      }
    }
  }
LABEL_8:
  memset_s(__s, 0x20uLL, 0, 0x20uLL);
  return v7;
}

uint64_t sub_10001A5C0(void **a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*(_DWORD *)a1 != 1634431856) {
    return 0xFFFFFFFFLL;
  }
  free(a1[1]);
  free(a1);
  return 0;
}

uint64_t sub_10001A620(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  if (*a1 != 1634431856 || !a2 && a3) {
    return 0xFFFFFFFFLL;
  }
  uint64_t result = 0xFFFFFFFFLL;
  if (a4 && (a1[6] - 4) >= 0xFFFFFFFD)
  {
    ccsha256_di();
    if (ccpbkdf2_hmac()) {
      return 0xFFFFFFFFLL;
    }
    else {
      return 0;
    }
  }
  return result;
}

uint64_t sub_10001A6C8()
{
  int v0 = __chkstk_darwin();
  if (!v1) {
    return 0;
  }
  uint64_t v2 = v1;
  int v3 = v0;
  uint64_t result = (uint64_t)calloc(0x20uLL, 1uLL);
  if (!result) {
    return result;
  }
  uint64_t v5 = result;
  *(_DWORD *)uint64_t result = 1634431856;
  mach_port_t v6 = sub_1000149A8();
  if (!v6)
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "_get_prederived_configuration", ":", 384, "", 0, "", "");
LABEL_16:
    sub_10001A5C0((void **)v5);
    return 0;
  }
  mach_port_t v7 = v6;
  bzero(outputStruct, 0x8000uLL);
  v13[0] = 0x8000;
  uint64_t input = v3;
  if (IOConnectCallMethod(v7, 0x1Fu, &input, 1u, 0, 0, 0, 0, outputStruct, v13) || v13[0] > 0x8000) {
    goto LABEL_16;
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  long long v15 = 0u;
  long long v17 = 0u;
  uint64_t v18 = 0;
  long long v14 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  v13[1] = (size_t)off_10035AA68;
  long long v16 = (unint64_t)off_10035AA70;
  uint64_t v19 = off_10035AA78;
  sub_10001BFD8();
  uint64_t v9 = ccder_decode_tl();
  if (v9)
  {
    uint64_t v10 = (const void *)v9;
    uint64_t v11 = calloc(*(void *)(v5 + 16), 1uLL);
    *(void *)(v5 + 8) = v11;
    if (!v11)
    {
      int v12 = 0;
      if (!Mutable) {
        goto LABEL_11;
      }
      goto LABEL_10;
    }
    memcpy(v11, v10, *(void *)(v5 + 16));
    *(_DWORD *)(v5 + 4) = sub_10001C18C();
    *(_DWORD *)(v5 + 24) = sub_10001C18C();
  }
  int v12 = 1;
  if (Mutable) {
LABEL_10:
  }
    CFRelease(Mutable);
LABEL_11:
  if (!v12 || !*(void *)(v5 + 16)) {
    goto LABEL_16;
  }
  *uint64_t v2 = v5;
  return 1;
}

uint64_t sub_10001A998(int a1, uint64_t a2, int a3, _DWORD *a4)
{
  memset(v9, 0, sizeof(v9));
  if (a3) {
    BOOL v4 = a2 == 0;
  }
  else {
    BOOL v4 = 0;
  }
  BOOL v5 = v4 || a4 == 0;
  if (v5 || *a4 != 1634431856 || sub_10001A620(a4, a2, a3, (uint64_t)v9)) {
    uint64_t v7 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v7 = sub_10001AA64(a1, (uint64_t)v9, 32);
  }
  memset_s(v9, 0x20uLL, 0, 0x20uLL);
  return v7;
}

uint64_t sub_10001AA64(int a1, uint64_t a2, int a3)
{
  mach_port_t v6 = sub_1000149A8();
  if (v6)
  {
    input[0] = a1;
    input[1] = a2;
    uint64_t input[2] = a3;
    return IOConnectCallMethod(v6, 0xCu, input, 3u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_unlock_bag", ":", 807, "", 0, "", "");
    return 3758097084;
  }
}

uint64_t sub_10001AB64(const void *a1, int a2, _DWORD *a3)
{
  uint64_t v6 = 3758097084;
  mach_port_t v7 = sub_1000149A8();
  if (v7)
  {
    uint64_t v6 = 3758097090;
    if (a1)
    {
      if (a3)
      {
        uint64_t output = 0;
        uint32_t outputCnt = 1;
        uint64_t v6 = IOConnectCallMethod(v7, 6u, 0, 0, a1, a2, &output, &outputCnt, 0, 0);
        if (!v6) {
          *a3 = output;
        }
      }
    }
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_load_bag", ":", 574, "", 0, "", "");
  }
  return v6;
}

uint64_t sub_10001AC80(int a1)
{
  mach_port_t v2 = sub_1000149A8();
  if (v2)
  {
    uint64_t input = a1;
    return IOConnectCallMethod(v2, 4u, &input, 1u, 0, 0, 0, 0, 0, 0);
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_unload_bag", ":", 612, "", 0, "", "");
    return 3758097084;
  }
}

uint64_t sub_10001AD68(int a1, _OWORD *a2)
{
  uint64_t v4 = 3758097084;
  size_t v7 = 16;
  mach_port_t v5 = sub_1000149A8();
  if (v5)
  {
    if (a2)
    {
      long long outputStruct = 0uLL;
      uint64_t input = a1;
      uint64_t v4 = IOConnectCallMethod(v5, 0x17u, &input, 1u, 0, 0, 0, 0, &outputStruct, &v7);
      if (!v4) {
        *a2 = outputStruct;
      }
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_get_bag_uuid", ":", 729, "", 0, "", "");
  }
  return v4;
}

uint64_t sub_10001AE90(int a1, _DWORD *a2)
{
  uint64_t v4 = 3758097084;
  mach_port_t v5 = sub_1000149A8();
  if (v5)
  {
    if (a2)
    {
      uint64_t output = 0;
      uint64_t input = a1;
      uint32_t outputCnt = 1;
      uint64_t v4 = IOConnectCallMethod(v5, 7u, &input, 1u, 0, 0, &output, &outputCnt, 0, 0);
      if (!v4) {
        *a2 = output;
      }
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_get_lock_state", ":", 824, "", 0, "", "");
  }
  return v4;
}

uint64_t sub_10001AFAC(const void *a1, int a2, int a3, int a4, void *a5, int *a6, _DWORD *a7)
{
  uint64_t v14 = 3758097084;
  mach_port_t v15 = sub_1000149A8();
  if (v15)
  {
    uint64_t v14 = 3758097090;
    if (a1 && a5 && a6)
    {
      input[0] = a4;
      input[1] = a3;
      uint64_t output = 0;
      uint32_t outputCnt = 1;
      size_t v18 = *a6;
      uint64_t v16 = IOConnectCallMethod(v15, 0xAu, input, 2u, a1, a2, &output, &outputCnt, a5, &v18);
      if (v16)
      {
        return v16;
      }
      else
      {
        *a6 = v18;
        uint64_t v14 = 0;
        if (a7) {
          *a7 = output;
        }
      }
    }
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_wrap_key", ":", 848, "", 0, "", "");
  }
  return v14;
}

uint64_t sub_10001B118(int a1, _DWORD *a2)
{
  uint64_t v4 = 3758097084;
  mach_port_t v5 = sub_1000149A8();
  if (v5)
  {
    if (a2)
    {
      uint64_t output = 0;
      uint64_t input = a1;
      uint32_t outputCnt = 1;
      uint64_t v4 = IOConnectCallMethod(v5, 0xEu, &input, a1 != 0, 0, 0, &output, &outputCnt, 0, 0);
      if (!v4) {
        *a2 = output;
      }
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_get_system", ":", 922, "", 0, "", "");
  }
  return v4;
}

uint64_t sub_10001B238(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _OWORD *a5)
{
  long long v17 = 0u;
  long long v18 = 0u;
  long long __s = 0u;
  long long v16 = 0u;
  uint64_t v14 = 0;
  memset(v13, 0, sizeof(v13));
  uint64_t v8 = sub_10001A3A4(a1, a2, v13);
  if (v8)
  {
    uint64_t v9 = v8;
  }
  else
  {
    uint64_t v9 = sub_10001A484((uint64_t)v13, a3, a4, (uint64_t)&__s);
    if (!v9)
    {
      long long v10 = v16;
      *a5 = __s;
      a5[1] = v10;
      long long v11 = v18;
      a5[2] = v17;
      a5[3] = v11;
    }
  }
  memset_s(v13, 0x58uLL, 0, 0x58uLL);
  memset_s(&__s, 0x40uLL, 0, 0x40uLL);
  return sub_10001BD5C(v9);
}

uint64_t sub_10001B328(uint64_t a1, const void *a2, size_t a3, void *a4, size_t *a5)
{
  uint64_t v10 = 3758097084;
  mach_port_t v11 = sub_1000149A8();
  if (v11)
  {
    uint64_t v10 = 3758097090;
    if (a2 && a4)
    {
      input[0] = a1;
      input[1] = 64;
      return IOConnectCallMethod(v11, 0x82u, input, 2u, a2, a3, 0, 0, a4, a5);
    }
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_kc_backup_unwrap_key", ":", 1193, "", 0, "", "");
  }
  return v10;
}

uint64_t sub_10001B444(int a1, const void *a2, size_t a3, void *a4, size_t *a5)
{
  uint64_t v10 = 3758097084;
  mach_port_t v11 = sub_1000149A8();
  if (v11)
  {
    uint64_t v10 = 3758097090;
    if (a2 && a4)
    {
      uint64_t input = a1;
      return IOConnectCallMethod(v11, 0x81u, &input, 1u, a2, a3, 0, 0, a4, a5);
    }
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_kc_backup_wrap_key", ":", 1212, "", 0, "", "");
  }
  return v10;
}

uint64_t sub_10001B560(int a1, unsigned __int8 *a2)
{
  uint64_t v4 = 3758097084;
  mach_port_t v5 = sub_1000149A8();
  if (v5)
  {
    if (a2)
    {
      uint64_t v10 = 0;
      uint64_t input = a1;
      size_t v8 = 16;
      *(void *)src = 0;
      uint64_t v6 = IOConnectCallMethod(v5, 0x84u, &input, 1u, 0, 0, 0, 0, src, &v8);
      if (v6)
      {
        return v6;
      }
      else if (v8 == 16)
      {
        uuid_copy(a2, src);
        return 0;
      }
      else
      {
        return 3758604298;
      }
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_kc_backup_get_uuid", ":", 1253, "", 0, "", "");
  }
  return v4;
}

uint64_t sub_10001B6A8(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, int *a5, _OWORD *a6)
{
  if (a5)
  {
    int v7 = a4;
    int v9 = a2;
    *a5 = -1;
    int v11 = sub_10001B238((uint64_t)a1, a2, a3, a4, a6);
    if (!v11)
    {
      fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s Unwrapped DER backup bag%s\n", "aks", "", "", "", "aks_kc_backup_open_keybag", ":", 1302, "", 0, "", "");
      uint64_t v15 = 0;
      goto LABEL_9;
    }
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s Failed to unwrap backup bag as DER: 0x%08x%s\n", "aks", "", "", "", "aks_kc_backup_open_keybag", ":", 1290, "", 0, "", v11, "");
    uint64_t v12 = sub_10001AB64(a1, v9, a5);
    if (v12)
    {
      uint64_t v15 = v12;
      fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s Failed to load in-kernel backup bag: 0x%08x%s\n", "aks", "", "", "", "aks_kc_backup_open_keybag", ":", 1292, "", 0, "", v12, "");
    }
    else
    {
      int v13 = sub_10001A6C8();
      int v14 = *a5;
      if (v13)
      {
        uint64_t v15 = sub_10001A998(v14, a3, v7, 0);
        if (!v15) {
          goto LABEL_9;
        }
        fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s Failed to unlock in-kernel backup bag with prederived secret: 0x%08x%s\n", "aks", "", "", "", "aks_kc_backup_open_keybag", ":");
      }
      else
      {
        uint64_t v15 = sub_10001AA64(v14, a3, v7);
        if (!v15) {
          goto LABEL_9;
        }
        fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s Failed to unlock in-kernel backup bag: 0x%08x%s\n", "aks", "", "", "", "aks_kc_backup_open_keybag", ":");
      }
    }
  }
  else
  {
    uint64_t v15 = 3758097090;
  }
  if (*a5 != -1)
  {
    sub_10001AC80(*a5);
    *a5 = -1;
  }
LABEL_9:
  sub_10001A5C0(0);
  return v15;
}

uint64_t sub_10001B8D8(int a1, unsigned int a2, uint64_t a3)
{
  input[0] = a2;
  input[1] = a3;
  uint64_t input[2] = a1;
  mach_port_t v3 = sub_1000149A8();
  if (v3) {
    return IOConnectCallMethod(v3, 0x1Au, input, 3u, 0, 0, 0, 0, 0, 0);
  }
  fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_assert_hold", ":", 1654, "", 0, "", "");
  return 3758097084;
}

uint64_t sub_10001B9BC(int a1, unsigned int a2)
{
  input[0] = a2;
  input[1] = a1;
  mach_port_t v2 = sub_1000149A8();
  if (v2) {
    return IOConnectCallMethod(v2, 0x1Bu, input, 2u, 0, 0, 0, 0, 0, 0);
  }
  fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_assert_drop", ":", 1672, "", 0, "", "");
  return 3758097084;
}

uint64_t sub_10001BA9C(int a1, unsigned int a2, _DWORD *a3)
{
  mach_port_t v6 = sub_1000149A8();
  if (v6)
  {
    input[0] = a1;
    input[1] = a2;
    uint64_t output = 0;
    uint32_t outputCnt = 1;
    uint64_t result = IOConnectCallMethod(v6, 0x28u, input, 2u, 0, 0, &output, &outputCnt, 0, 0);
    if (a3)
    {
      if (!result) {
        *a3 = output;
      }
    }
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "aks_generation", ":", 1781, "", 0, "", "");
    return 3758097084;
  }
  return result;
}

uint64_t sub_10001BBB4()
{
  return sub_10001BBC0();
}

uint64_t sub_10001BBC0()
{
  int v0 = __chkstk_darwin();
  uint64_t v2 = v1;
  uint32_t v4 = v3;
  uint64_t input = v0;
  *(void *)uint64_t v12 = 4096;
  uint64_t v5 = 3758097084;
  int v18 = 0;
  long long v16 = 0u;
  long long v17 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long __s = 0u;
  mach_port_t v6 = sub_1000149A8();
  if (v6)
  {
    if (v2)
    {
      mach_port_t v7 = v6;
      bzero(outputStruct, 0x1000uLL);
      uint64_t v8 = IOConnectCallMethod(v7, v4, &input, 1u, 0, 0, 0, 0, outputStruct, (size_t *)v12);
      if (v8)
      {
        return v8;
      }
      else
      {
        uint64_t v5 = 0;
        if (!sub_10001CD88((uint64_t)outputStruct, v12[0], (char *)&__s))
        {
          long long v9 = v16;
          *(_OWORD *)(v2 + 32) = v15;
          *(_OWORD *)(v2 + 48) = v9;
          *(_WORD *)(v2 + 64) = v17;
          long long v10 = v14;
          *(_OWORD *)uint64_t v2 = __s;
          *(_OWORD *)(v2 + 16) = v10;
        }
      }
    }
    else
    {
      return 3758097090;
    }
  }
  else
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s aks connection failed%s\n", "aks", "", "", "", "_get_device_state", ":", 2224, "", 0, "", "");
  }
  return v5;
}

uint64_t sub_10001BD5C(uint64_t result)
{
  if (result == 0 || result >= 0xFFFFFFDA) {
    return dword_100265230[(int)result + 38];
  }
  return result;
}

uint64_t sub_10001BD78(uint64_t result, int a2, const char *a3)
{
  if ((result & 1) == 0)
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s failed REQUIRE condition (%s:%d)\n%s\n", "aks", "", "", "", "REQUIRE_func", ":", 1047, "", 0, "", a3, a2, "");
    abort();
  }
  return result;
}

unint64_t sub_10001BDEC()
{
  return (unint64_t)(cczp_bitlen() + 7) >> 3;
}

uint64_t sub_10001BE10(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  return _cccbc_update(a1, a2, a3, a4 >> 4);
}

uint64_t sub_10001BE1C(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(void *)(a5 + 8) >= *(void *)a5)
  {
    char v13 = 0;
  }
  else
  {
    uint64_t v9 = 0;
    unint64_t v10 = 0;
    while (1)
    {
      BOOL v11 = sub_10001BF04(*(const void **)(*(void *)(a5 + 24) + v9), *(void *)(*(void *)(a5 + 24) + v9)+ *(unsigned __int8 *)(*(void *)(*(void *)(a5 + 24) + v9) + 1)+ 2, a1);
      if (v11) {
        break;
      }
      ++v10;
      v9 += 40;
      if (v10 >= *(void *)a5) {
        goto LABEL_10;
      }
    }
    long long v14 = (void *)(*(void *)(a5 + 24) + v9);
    if (v14[1])
    {
      char v12 = 0;
      *(unsigned char *)(a5 + 16) = 1;
    }
    else
    {
      ++*(void *)(a5 + 8);
      v14[1] = a3;
      v14[2] = a3 + a4;
      v14[3] = a3;
      v14[4] = a3 + a4;
      char v12 = 1;
    }
LABEL_10:
    char v13 = v12 | !v11;
  }
  return v13 & 1;
}

BOOL sub_10001BF04(const void *a1, uint64_t a2, const void *a3)
{
  size_t v5 = sub_10001BF70((uint64_t)a1);
  return v5 == sub_10001BF70((uint64_t)a3) && memcmp(a1, a3, v5) == 0;
}

uint64_t sub_10001BF70(uint64_t a1)
{
  if (ccder_blob_decode_tag() && ccder_blob_decode_len()) {
    return a1 - a1;
  }
  else {
    return 0;
  }
}

uint64_t sub_10001BFD8()
{
  uint64_t result = ccder_blob_decode_range();
  if (result)
  {
    if (ccder_blob_decode_sequence_tl())
    {
      uint64_t result = ccder_blob_decode_tl();
      if (result) {
        return 0;
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t sub_10001C0B0(uint64_t a1, void *a2, void *a3)
{
  if (a1)
  {
    sub_10001BFD8();
    if (a2)
    {
      if (a3)
      {
        *a2 = 0;
        *a3 = 0;
      }
    }
  }
  return 0;
}

BOOL sub_10001C128(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  BOOL v8 = sub_10001BF04(*(const void **)a5, *(void *)a5 + *(unsigned __int8 *)(*(void *)a5 + 1) + 2, a1);
  if (v8)
  {
    *(unsigned char *)(a5 + 24) = 1;
    *(void *)(a5 + 8) = a3;
    *(void *)(a5 + 16) = a3 + a4;
  }
  return !v8;
}

uint64_t sub_10001C18C()
{
  return 0;
}

double sub_10001C1F8(long long *a1, uint64_t a2, _DWORD *a3, void *a4)
{
  long long v8 = *a1;
  if (ccder_blob_decode_range())
  {
    *a4 = 0;
    *a3 = 0;
    double result = *(double *)&v8;
    *a1 = v8;
  }
  return result;
}

uint64_t sub_10001C268(void **a1)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  while (1)
  {
    uint64_t v2 = *a1;
    if (!*a1) {
      break;
    }
    uint32_t v3 = (void *)*((void *)v2 + 1);
    *a1 = *(void **)v2;
    if (v3)
    {
      memset_s(v3, *((void *)v2 + 2), 0, *((void *)v2 + 2));
      free(*((void **)v2 + 1));
    }
    memset_s(v2, 0x18uLL, 0, 0x18uLL);
    free(v2);
  }
  return 0;
}

uint64_t sub_10001C2E8(void *a1, unsigned __int8 *a2)
{
  if (!a1) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v2 = (void **)a1;
  uint64_t result = (uint64_t)sub_10001C384(a1, a2);
  if (result)
  {
    uint64_t v4 = result;
    for (uint64_t i = *v2; i != (void *)result; uint64_t i = (void *)*i)
      uint64_t v2 = (void **)i;
    *uint64_t v2 = *(void **)result;
    mach_port_t v6 = *(void **)(result + 8);
    if (v6)
    {
      memset_s(v6, *(void *)(v4 + 16), 0, *(void *)(v4 + 16));
      free(*(void **)(v4 + 8));
    }
    memset_s((void *)v4, 0x18uLL, 0, 0x18uLL);
    free((void *)v4);
    return 0;
  }
  return result;
}

void *sub_10001C384(void *a1, unsigned __int8 *a2)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = (void *)*a1;
  if (*a1)
  {
    do
    {
      size_t v5 = (const void *)v2[1];
      if (ccder_blob_decode_sequence_tl() && sub_10001BF04(a2, (uint64_t)&a2[a2[1] + 2], v5)) {
        break;
      }
      uint64_t v2 = (void *)*v2;
    }
    while (v2);
  }
  return v2;
}

uint64_t sub_10001C408(long long *a1, uint64_t a2, uint64_t a3, int a4)
{
  long long v8 = *a1;
  if ((ccder_blob_decode_range() & 1) == 0 || a3 && a4) {
    return 0;
  }
  *a1 = v8;
  return 1;
}

uint64_t sub_10001C498(uint64_t a1)
{
  if ((ccder_blob_decode_tl() & 1) == 0)
  {
    fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s bad 1%s\n", "aks", "", "", "", "der_key_validate");
    return 0;
  }
  return a1;
}

uint64_t sub_10001C598(uint64_t a1)
{
  if (a1) {
    return sub_10001BFD8() - 1;
  }
  else {
    return 4294967285;
  }
}

uint64_t sub_10001C5E0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  long long v8 = (unsigned __int8 *)sub_10001C498(a1);
  if (v8)
  {
    uint64_t v9 = (uint64_t)v8;
    if (!sub_10001C2E8(a5, v8) && !sub_10001C880(a5, v9, a3, a3 + a4)) {
      return 1;
    }
  }
  fprintf(__stdoutp, "%s%s:%s%s%s%s%u:%s%u:%s fail%s\n", "aks", "", "", "", "_merge_dict_cb", ":", 647, "", 0, "", "");
  return 0;
}

uint64_t sub_10001C6B0(void *a1, void *a2, size_t *a3)
{
  uint64_t v3 = 0xFFFFFFFFLL;
  if (a1)
  {
    if (a2)
    {
      if (a3)
      {
        mach_port_t v7 = (void *)*a1;
        if (*a1)
        {
          unint64_t v8 = 0;
          uint64_t v9 = 0;
          uint64_t v10 = 0;
          do
          {
            v10 += v7[2];
            mach_port_t v7 = (void *)*v7;
            v9 -= 16;
            --v8;
          }
          while (v7);
          if (v8 >= 0xF000000000000001 && (rsize_t v11 = -v9, (v12 = calloc(-v9, 1uLL)) != 0))
          {
            char v13 = v12;
            long long v14 = (void *)*a1;
            if (*a1)
            {
              long long v15 = v12;
              do
              {
                *v15++ = *(_OWORD *)(v14 + 1);
                long long v14 = (void *)*v14;
              }
              while (v14);
            }
            qsort(v12, -(uint64_t)v8, 0x10uLL, (int (__cdecl *)(const void *, const void *))sub_10001D084);
            size_t v16 = ccder_sizeof();
            long long v17 = (char *)calloc(v16, 1uLL);
            int v18 = v17;
            if (v17)
            {
              uint64_t v25 = v17;
              size_t v26 = &v17[v16];
              unint64_t v19 = v8 - 1;
              uint64_t v20 = (uint64_t)v13 - v9 - 8;
              while (!__CFADD__(v19++, 1))
              {
                uint64_t v22 = v20 - 16;
                char v23 = ccder_blob_encode_body();
                uint64_t v20 = v22;
                if ((v23 & 1) == 0) {
                  goto LABEL_16;
                }
              }
              if (!ccder_blob_encode_tl() || v25 != v26)
              {
LABEL_16:
                uint64_t v3 = 0xFFFFFFFFLL;
                goto LABEL_20;
              }
              uint64_t v3 = 0;
              *a2 = v18;
              *a3 = v16;
              int v18 = 0;
            }
            else
            {
              uint64_t v3 = 4294967279;
            }
LABEL_20:
            memset_s(v13, v11, 0, v11);
            free(v13);
            if (v18)
            {
              memset_s(v18, v16, 0, v16);
              free(v18);
            }
          }
          else
          {
            return 0xFFFFFFFFLL;
          }
        }
      }
    }
  }
  return v3;
}

uint64_t sub_10001C880(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 && a3 && a4)
  {
    if (sub_10001BF70(a3) <= (unint64_t)(a4 - a3))
    {
      size_t v6 = ccder_sizeof();
      mach_port_t v7 = (char *)calloc(v6, 1uLL);
      if (!v7) {
        return 4294967279;
      }
      unint64_t v8 = v7;
      size_t v16 = &v7[v6];
      if (ccder_blob_encode_body())
      {
        int v9 = ccder_blob_encode_body();
        uint64_t v10 = v16;
        if (!v9) {
          uint64_t v10 = 0;
        }
        long long v17 = v10;
        int v11 = ccder_blob_encode_tl();
        char v12 = v17;
        if (!v11) {
          char v12 = 0;
        }
        if (v12 && v12 == v8)
        {
          long long v14 = calloc(0x18uLL, 1uLL);
          if (v14)
          {
            long long v15 = v14;
            uint64_t result = 0;
            v15[1] = v8;
            int v15[2] = v6;
            void *v15 = *a1;
            *a1 = v15;
            return result;
          }
        }
      }
      memset_s(v8, v6, 0, v6);
      free(v8);
    }
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t sub_10001C9F0(void *a1, uint64_t a2, uint64_t a3)
{
  return sub_10001C880(a1, a2, a3, a3 + *(unsigned __int8 *)(a3 + 1) + 2);
}

uint64_t sub_10001CA00(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2 && a3)
  {
    ccder_sizeof();
    size_t v5 = ccder_sizeof();
    size_t v6 = (char *)calloc(v5, 1uLL);
    if (v6)
    {
      mach_port_t v7 = v6;
      long long v15 = &v6[v5];
      if (!ccder_blob_encode_body() || !ccder_blob_encode_tl()) {
        goto LABEL_19;
      }
      int v8 = ccder_blob_encode_body();
      int v9 = v15;
      if (!v8) {
        int v9 = 0;
      }
      size_t v16 = v9;
      int v10 = ccder_blob_encode_tl();
      int v11 = v16;
      if (!v10) {
        int v11 = 0;
      }
      BOOL v12 = v11 && v11 == v7;
      if (v12 && (char v13 = calloc(0x18uLL, 1uLL)) != 0)
      {
        long long v14 = v13;
        uint64_t result = 0;
        v14[1] = v7;
        v14[2] = v5;
        *long long v14 = *a1;
        *a1 = v14;
      }
      else
      {
LABEL_19:
        memset_s(v7, v5, 0, v5);
        free(v7);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      return 4294967279;
    }
  }
  return result;
}

uint64_t sub_10001CB70(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3 = a3;
  unint64_t v5 = HIBYTE(a3);
  if ((HIBYTE(a3) + 1) > 1u)
  {
    uint64_t v10 = 8;
  }
  else
  {
    uint64_t v6 = 9;
    uint64_t v7 = 48;
    uint64_t v8 = 1;
    while ((unint64_t)(v6 - 2) >= 2)
    {
      uint64_t v9 = a3 >> v7;
      --v6;
      v7 -= 8;
      if (v5 != v9)
      {
        uint64_t v8 = v6 - 1;
        goto LABEL_8;
      }
    }
    uint64_t v6 = 2;
LABEL_8:
    if ((((a3 >> (8 * v8 - 8)) ^ v5) & 0x80) != 0) {
      uint64_t v10 = v6;
    }
    else {
      uint64_t v10 = v8;
    }
  }
  uint64_t v25 = 0;
  uint64_t result = 0xFFFFFFFFLL;
  if (a1 && a2)
  {
    ccder_sizeof();
    size_t v12 = ccder_sizeof();
    char v13 = (char *)calloc(v12, 1uLL);
    if (v13)
    {
      long long v14 = v13;
      uint64_t v15 = v10;
      do
      {
        *((unsigned char *)&v25 + v15 - 1) = v3;
        v3 >>= 8;
        --v15;
      }
      while (v15);
      char v23 = &v13[v12];
      if ((ccder_blob_encode_body() & 1) == 0 || !ccder_blob_encode_tl()) {
        goto LABEL_30;
      }
      int v16 = ccder_blob_encode_body();
      long long v17 = v23;
      if (!v16) {
        long long v17 = 0;
      }
      rsize_t v24 = v17;
      int v18 = ccder_blob_encode_tl();
      unint64_t v19 = v24;
      if (!v18) {
        unint64_t v19 = 0;
      }
      BOOL v20 = v19 && v19 == v14;
      if (v20 && (long long v21 = calloc(0x18uLL, 1uLL)) != 0)
      {
        uint64_t v22 = v21;
        uint64_t result = 0;
        v22[1] = v14;
        v22[2] = v12;
        *uint64_t v22 = *a1;
        *a1 = v22;
      }
      else
      {
LABEL_30:
        memset_s(v14, v12, 0, v12);
        free(v14);
        return 0xFFFFFFFFLL;
      }
    }
    else
    {
      return 4294967279;
    }
  }
  return result;
}

uint64_t sub_10001CD88(uint64_t a1, int a2, char *__s)
{
  uint64_t result = 0xFFFFFFFFLL;
  if (a2 && a1)
  {
    if (__s)
    {
      memset_s(__s, 0x54uLL, 0, 0x54uLL);
      bzero(v7, 0x228uLL);
      v7[4] = off_10035AA28;
      v7[9] = off_10035AA30;
      v7[14] = off_10035AA38;
      v7[19] = off_10035AA40;
      v7[24] = off_10035AA48;
      v7[29] = off_10035AA50;
      v7[34] = off_10035AA58;
      v7[39] = off_10035AA60;
      v7[44] = off_10035A938;
      v7[49] = off_10035A9D8;
      v7[54] = off_10035AA80;
      uint64_t v9 = off_10035AAE8;
      uint64_t v10 = off_10035AAF8;
      sub_10001BFD8();
      *(_DWORD *)long long __s = sub_10001C18C();
      *((_DWORD *)__s + 1) = sub_10001C18C();
      *((void *)__s + 1) = sub_10001C18C();
      *((_DWORD *)__s + 4) = sub_10001C18C();
      *((_DWORD *)__s + 5) = sub_10001C18C();
      *(void *)(__s + 26) = sub_10001C18C();
      *(void *)(__s + 34) = sub_10001C18C();
      *(_DWORD *)(__s + 42) = sub_10001C18C();
      *(_DWORD *)(__s + 46) = sub_10001C18C();
      sub_10001C408(&v8, 4, (uint64_t)(__s + 50), 16);
      __s[66] = sub_10001C18C();
      __s[67] = sub_10001C18C();
      *(void *)(__s + 68) = sub_10001C18C();
      uint64_t v6 = sub_10001C18C();
      uint64_t result = 0;
      *(void *)(__s + 76) = v6;
    }
  }
  return result;
}

uint64_t sub_10001CFF8(long long *a1, uint64_t a2, void *a3)
{
  if (a3) {
    *a3 = 0;
  }
  long long v6 = *a1;
  uint64_t result = ccder_blob_decode_range();
  if (result)
  {
    if (ccn_read_uint())
    {
      return 0;
    }
    else
    {
      *a1 = v6;
      if (a3) {
        *a3 = 0;
      }
      return 1;
    }
  }
  return result;
}

uint64_t sub_10001D084(const void **a1, void **a2)
{
  unint64_t v5 = *a1;
  __s2 = *a2;
  if (!ccder_blob_decode_sequence_tl()
    || !ccder_blob_decode_sequence_tl()
    || !ccder_blob_decode_tag()
    || !ccder_blob_decode_len()
    || !v5
    || !ccder_blob_decode_tag()
    || !ccder_blob_decode_len()
    || !__s2)
  {
    return 4294967293;
  }
  int v2 = memcmp(v5, __s2, 0);
  if (v2 > 0) {
    return 1;
  }
  else {
    return ((v2 < 0) << 31 >> 31);
  }
}

void *acm_mem_alloc_data(size_t size)
{
  uint64_t result = malloc_type_calloc(1uLL, size, 0xCB62F0E9uLL);
  if (result) {
    qword_10035CB00 += size;
  }
  return result;
}

void acm_mem_free_data(void *a1, rsize_t __n)
{
  if (a1)
  {
    memset_s(a1, __n, 0, __n);
    free(a1);
    uint64_t v4 = qword_10035CB00 - __n;
    if (qword_10035CB00 < __n) {
      uint64_t v4 = 0;
    }
    qword_10035CB00 = v4;
  }
}

void *acm_mem_alloc(size_t size)
{
  uint64_t result = malloc_type_calloc(1uLL, size, 0xDB9956F0uLL);
  if (result) {
    qword_10035CB08 += size;
  }
  return result;
}

void acm_mem_free(void *a1, rsize_t __n)
{
  if (a1)
  {
    memset_s(a1, __n, 0, __n);
    free(a1);
    uint64_t v4 = qword_10035CB08 - __n;
    if (qword_10035CB08 < __n) {
      uint64_t v4 = 0;
    }
    qword_10035CB08 = v4;
  }
}

const char *acm_mem_alloc_info(const char *result, const void *a2, uint64_t a3, const char *a4, int a5, const char *a6)
{
  if (a2) {
    qword_10035CAF8 += a3;
  }
  if (gACMLoggingLevel <= 0x1Eu)
  {
    long long v6 = "NULL";
    if (result) {
      uint64_t v7 = result;
    }
    else {
      uint64_t v7 = "NULL";
    }
    if (a4) {
      long long v8 = a4;
    }
    else {
      long long v8 = "NULL";
    }
    if (a6) {
      long long v6 = a6;
    }
    return (const char *)printf("%s: %s: mem: type=%s ptr=%p size=%u (total=%u raw=%u data=%u types=%u) %s:%d (%s).\n", "ACM", "acm_mem_alloc_info", v7, a2, a3, qword_10035CAF8, 0, qword_10035CB00, qword_10035CB08, v8, a5, v6);
  }
  return result;
}

const char *acm_mem_free_info(const char *result, const void *a2, unint64_t a3, const char *a4, int a5, const char *a6)
{
  if (a2)
  {
    uint64_t v6 = qword_10035CAF8 - a3;
    if (qword_10035CAF8 < a3) {
      uint64_t v6 = 0;
    }
    qword_10035CAF8 = v6;
  }
  if (gACMLoggingLevel <= 0x1Eu)
  {
    uint64_t v7 = "NULL";
    if (result) {
      long long v8 = result;
    }
    else {
      long long v8 = "NULL";
    }
    if (a4) {
      uint64_t v9 = a4;
    }
    else {
      uint64_t v9 = "NULL";
    }
    if (a6) {
      uint64_t v7 = a6;
    }
    return (const char *)printf("%s: %s: mem: type=%s ptr=%p size=%u (total=%u raw=%u data=%u types=%u) %s:%d (%s).\n", "ACM", "acm_mem_free_info", v8, a2, a3, qword_10035CAF8, 0, qword_10035CB00, qword_10035CB08, v9, a5, v7);
  }
  return result;
}

uint64_t sub_10001D444(uint64_t *a1, int a2, char a3, const void *a4, size_t a5, void *a6, size_t *a7)
{
  if (byte_10035AB01 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v18 = 136315394;
    unint64_t v19 = "ACMLib";
    __int16 v20 = 2080;
    long long v21 = "ioKitTransport";
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: called.\n", (uint8_t *)&v18, 0x16u);
  }
  if (a1)
  {
    uint64_t v14 = sub_10001DA8C();
    unsigned int v15 = 70;
    if (v14)
    {
      uint64_t v16 = v14;
    }
    else
    {
      uint64_t v16 = sub_10001DC70(*a1, a2, a3, a4, a5, a6, a7);
      if (v16) {
        unsigned int v15 = 70;
      }
      else {
        unsigned int v15 = 10;
      }
    }
  }
  else
  {
    unsigned int v15 = 70;
    uint64_t v16 = 4294967293;
  }
  if (v15 >= byte_10035AB01 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v18 = 136315650;
    unint64_t v19 = "ACMLib";
    __int16 v20 = 2080;
    long long v21 = "ioKitTransport";
    __int16 v22 = 2048;
    uint64_t v23 = (int)v16;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: returning, CFErrorRef err = %ld.\n", (uint8_t *)&v18, 0x20u);
  }
  return v16;
}

_DWORD *ACMContextCreateWithExternalForm(_OWORD *a1, uint64_t a2)
{
  if (byte_10035AB01 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 136315394;
    uint64_t v10 = "ACMLib";
    __int16 v11 = 2080;
    size_t v12 = "ACMContextCreateWithExternalForm";
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: called.\n", buf, 0x16u);
  }
  uint64_t v8 = 0;
  uint64_t v4 = LibCall_ACMContextCreateWithExternalForm((uint64_t (*)(uint64_t, uint64_t, void, _OWORD *, uint64_t, void *, uint64_t *))sub_10001D444, (uint64_t)&v8, a1, a2, &byte_10035AB01, 1);
  if (v4)
  {
    if (byte_10035AB01 <= 0x28u && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
    {
      int v5 = v4[4];
      *(_DWORD *)long long buf = 136315650;
      uint64_t v10 = "ACMLib";
      __int16 v11 = 2080;
      size_t v12 = "ACMContextCreateWithExternalForm";
      __int16 v13 = 1024;
      LODWORD(v14) = v5;
      _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: CS[%u] acquired.\n", buf, 0x1Cu);
    }
    unsigned int v6 = 30;
  }
  else
  {
    sub_10001E250();
    unsigned int v6 = 70;
  }
  if (v6 >= byte_10035AB01 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 136315650;
    uint64_t v10 = "ACMLib";
    __int16 v11 = 2080;
    size_t v12 = "ACMContextCreateWithExternalForm";
    __int16 v13 = 2048;
    uint64_t v14 = v4;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: returning, -> ctx = %p.\n", buf, 0x20u);
  }
  return v4;
}

uint64_t ACMContextDelete(_DWORD *a1, int a2)
{
  unsigned int v4 = byte_10035AB01;
  if (byte_10035AB01 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 136315394;
    size_t v12 = "ACMLib";
    __int16 v13 = 2080;
    uint64_t v14 = "ACMContextDelete";
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: called.\n", buf, 0x16u);
    unsigned int v4 = byte_10035AB01;
  }
  if (a1 && v4 <= 0x28 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v5 = a1[4];
    unsigned int v6 = "deleted";
    *(_DWORD *)long long buf = 136315906;
    size_t v12 = "ACMLib";
    uint64_t v14 = "ACMContextDelete";
    __int16 v13 = 2080;
    if (a2) {
      unsigned int v6 = "destroyed";
    }
    __int16 v15 = 1024;
    LODWORD(v16[0]) = v5;
    WORD2(v16[0]) = 2080;
    *(void *)((char *)v16 + 6) = v6;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: CS[%u] %s.\n", buf, 0x26u);
  }
  uint64_t v10 = a1;
  uint64_t v7 = LibCall_ACMContextDelete((void (*)(uint64_t, uint64_t, void, void *, uint64_t, void, void))sub_10001D444, (uint64_t)&v10, a1, a2);
  if (v7) {
    unsigned int v8 = 70;
  }
  else {
    unsigned int v8 = 10;
  }
  if (v8 >= byte_10035AB01 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 136315650;
    size_t v12 = "ACMLib";
    __int16 v13 = 2080;
    uint64_t v14 = "ACMContextDelete";
    __int16 v15 = 2048;
    v16[0] = (int)v7;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: returning, CFErrorRef err = %ld.\n", buf, 0x20u);
  }
  return v7;
}

uint64_t sub_10001DA8C()
{
  if (byte_10035AB01 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v6 = 136315394;
    uint64_t v7 = "ACMLib";
    __int16 v8 = 2080;
    uint64_t v9 = "init";
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: called.\n", (uint8_t *)&v6, 0x16u);
  }
  if (byte_10035CB14)
  {
    uint64_t v0 = 0;
  }
  else
  {
    CFDictionaryRef v1 = IOServiceMatching("AppleCredentialManager");
    io_service_t MatchingService = IOServiceGetMatchingService(kIOMasterPortDefault, v1);
    if (!MatchingService)
    {
      unsigned int v4 = 70;
      uint64_t v0 = 4294967291;
      goto LABEL_10;
    }
    io_object_t v3 = MatchingService;
    uint64_t v0 = IOServiceOpen(MatchingService, mach_task_self_, 0, (io_connect_t *)&dword_10035CB10);
    if (v0)
    {
      unsigned int v4 = 70;
      goto LABEL_10;
    }
    IOObjectRelease(v3);
    byte_10035CB14 = 1;
  }
  unsigned int v4 = 10;
LABEL_10:
  if (v4 >= byte_10035AB01 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v6 = 136315650;
    uint64_t v7 = "ACMLib";
    __int16 v8 = 2080;
    uint64_t v9 = "init";
    __int16 v10 = 2048;
    uint64_t v11 = (int)v0;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: returning, CFErrorRef err = %ld.\n", (uint8_t *)&v6, 0x20u);
  }
  return v0;
}

uint64_t sub_10001DC70(uint64_t a1, int a2, char a3, const void *a4, size_t a5, void *a6, size_t *a7)
{
  if (byte_10035AB01 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 136315394;
    uint64_t v25 = "ACMLib";
    __int16 v26 = 2080;
    int v27 = "performCommand";
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: called.\n", buf, 0x16u);
  }
  size_t inputStructCnt = 0;
  uint64_t v14 = LibCall_BuildCommand(a2, 0, a3, a4, a5, &inputStructCnt);
  if (v14)
  {
    __int16 v15 = v14;
    if (!a6 && a7)
    {
      uint64_t v18 = 4294967293;
    }
    else
    {
      if (a7) {
        size_t v16 = *a7;
      }
      else {
        size_t v16 = 0;
      }
      size_t v22 = v16;
      uint64_t v17 = IOConnectCallStructMethod(dword_10035CB10, 0, v14, inputStructCnt, a6, &v22);
      uint64_t v18 = v17;
      if (a1) {
        LODWORD(a1) = *(_DWORD *)(a1 + 16);
      }
      if (v17)
      {
        if (byte_10035AB01 <= 0x46u
          && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)long long buf = 136316418;
          uint64_t v25 = "ACMLib";
          __int16 v26 = 2080;
          int v27 = "performCommand";
          __int16 v28 = 1024;
          *(_DWORD *)int v29 = a2;
          *(_WORD *)&v29[4] = 1024;
          *(_DWORD *)&v29[6] = a1;
          __int16 v30 = 1024;
          int v31 = v18;
          __int16 v32 = 1024;
          int v33 = v18;
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: cmd(%u) on CS[%u] -> err 0x%x (%d).\n", buf, 0x2Eu);
        }
      }
      else
      {
        if (byte_10035AB01 <= 0x28u
          && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)long long buf = 136315906;
          uint64_t v25 = "ACMLib";
          __int16 v26 = 2080;
          int v27 = "performCommand";
          __int16 v28 = 1024;
          *(_DWORD *)int v29 = a2;
          *(_WORD *)&v29[4] = 1024;
          *(_DWORD *)&v29[6] = a1;
          _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: cmd(%u) on CS[%u] -> ok.\n", buf, 0x22u);
        }
        uint64_t v18 = 0;
        if (a7) {
          *a7 = v22;
        }
      }
    }
    rsize_t v19 = inputStructCnt;
    acm_mem_free_info("<data>", v15, inputStructCnt, "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c", 134, "performCommand");
    acm_mem_free_data(v15, v19);
    if (v18) {
      unsigned int v20 = 70;
    }
    else {
      unsigned int v20 = 10;
    }
  }
  else
  {
    unsigned int v20 = 70;
    uint64_t v18 = 4294967291;
  }
  if (v20 >= byte_10035AB01 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 136315650;
    uint64_t v25 = "ACMLib";
    __int16 v26 = 2080;
    int v27 = "performCommand";
    __int16 v28 = 2048;
    *(void *)int v29 = (int)v18;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: returning, CFErrorRef err = %ld.\n", buf, 0x20u);
  }
  return v18;
}

uint64_t ACMContextRemovePassphraseCredentialsByPurposeAndScope(_OWORD *a1, int a2, int a3)
{
  if (byte_10035AB01 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v11 = 136315394;
    size_t v12 = "ACMLib";
    __int16 v13 = 2080;
    uint64_t v14 = "ACMContextRemovePassphraseCredentialsByPurposeAndScope";
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: called.\n", (uint8_t *)&v11, 0x16u);
  }
  if (a1 || a3 == 2)
  {
    uint64_t v6 = sub_10001DA8C();
    if (v6)
    {
      uint64_t v8 = v6;
      unsigned int v9 = 70;
    }
    else
    {
      uint64_t v7 = acm_mem_alloc_data(0x18uLL);
      acm_mem_alloc_info("<data>", v7, 24, "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c", 492, "ACMContextRemovePassphraseCredentialsByPurposeAndScope");
      if (v7)
      {
        if (a1)
        {
          *uint64_t v7 = *a1;
        }
        else
        {
          *(void *)uint64_t v7 = 0;
          *((void *)v7 + 1) = 0;
        }
        *((_DWORD *)v7 + 4) = a2;
        *((_DWORD *)v7 + 5) = a3;
        uint64_t v8 = sub_10001DC70((uint64_t)a1, 16, 0, v7, 0x18uLL, 0, 0);
        acm_mem_free_info("<data>", v7, 0x18uLL, "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/ACMLib/ACMLib.c", 513, "ACMContextRemovePassphraseCredentialsByPurposeAndScope");
        acm_mem_free_data(v7, 0x18uLL);
        if (v8) {
          unsigned int v9 = 70;
        }
        else {
          unsigned int v9 = 10;
        }
      }
      else
      {
        unsigned int v9 = 70;
        uint64_t v8 = 4294967292;
      }
    }
  }
  else
  {
    unsigned int v9 = 70;
    uint64_t v8 = 4294967293;
  }
  if (v9 >= byte_10035AB01 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    int v11 = 136315650;
    size_t v12 = "ACMLib";
    __int16 v13 = 2080;
    uint64_t v14 = "ACMContextRemovePassphraseCredentialsByPurposeAndScope";
    __int16 v15 = 2048;
    uint64_t v16 = (int)v8;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: returning, CFErrorRef err = %ld.\n", (uint8_t *)&v11, 0x20u);
  }
  return v8;
}

void sub_10001E250()
{
  if (byte_10035AB01 <= 0xAu && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 136315394;
    int v5 = "ACMLib";
    __int16 v6 = 2080;
    uint64_t v7 = "updateLogLevelFromKext";
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: called.\n", buf, 0x16u);
  }
  uint64_t output = 0;
  uint32_t outputCnt = 1;
  if (IOConnectCallScalarMethod(dword_10035CB10, 2u, 0, 0, &output, &outputCnt)) {
    goto LABEL_8;
  }
  unsigned __int8 v0 = output;
  unsigned int v1 = output;
  byte_10035AB01 = output;
  if (output <= 0x1EuLL && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 136315650;
    int v5 = "ACMLib";
    __int16 v6 = 2080;
    uint64_t v7 = "updateLogLevelFromKext";
    __int16 v8 = 1024;
    int v9 = v0;
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: log level set to %d.\n", buf, 0x1Cu);
LABEL_8:
    unsigned int v1 = byte_10035AB01;
  }
  if (v1 <= 0xA && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 136315394;
    int v5 = "ACMLib";
    __int16 v6 = 2080;
    uint64_t v7 = "updateLogLevelFromKext";
    _os_log_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_INFO, "%s: %s: returning.\n", buf, 0x16u);
  }
}

unsigned char *LibCall_BuildCommand(char a1, char a2, char a3, const void *a4, size_t a5, void *a6)
{
  if (gACMLoggingLevel <= 0xAu) {
    printf("%s: %s: called.\n", "ACM", "LibCall_BuildCommand");
  }
  size_t v12 = 0;
  if (a5) {
    BOOL v13 = a4 == 0;
  }
  else {
    BOOL v13 = 0;
  }
  if (!v13 && a6)
  {
    if (a5 >= 0xFFFFFFFFFFFFFFF8)
    {
      size_t v12 = 0;
    }
    else
    {
      size_t v12 = acm_mem_alloc_data(a5 + 8);
      acm_mem_alloc_info("<data>", v12, a5 + 8, "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c", 22, "LibCall_BuildCommand");
      if (v12)
      {
        *a6 = a5 + 8;
        *(_DWORD *)size_t v12 = 1396920900;
        void v12[4] = a1;
        v12[5] = a2;
        v12[6] = a3;
        if (a5) {
          memcpy(v12 + 8, a4, a5);
        }
      }
    }
  }
  if (gACMLoggingLevel <= 0xAu) {
    printf("%s: %s: returning.\n", "ACM", "LibCall_BuildCommand");
  }
  return v12;
}

_DWORD *LibCall_ACMContextCreateWithExternalForm(uint64_t (*a1)(uint64_t, uint64_t, void, _OWORD *, uint64_t, void *, uint64_t *), uint64_t a2, _OWORD *a3, uint64_t a4, unsigned char *a5, int a6)
{
  if (gACMLoggingLevel <= 0xAu) {
    printf("%s: %s: called.\n", "ACM", "LibCall_ACMContextCreateWithExternalForm");
  }
  size_t v12 = 0;
  unsigned int v13 = 70;
  int v14 = -3;
  if (a1 && a3 && a4 == 16)
  {
    memset(v21, 0, 9);
    if (a6)
    {
      uint64_t v20 = 9;
      int v15 = a1(a2, 37, 0, a3, 16, v21, &v20);
      if (!v15)
      {
        if (v20 == 9)
        {
          int v14 = 0;
          goto LABEL_19;
        }
        int v14 = -5;
        goto LABEL_28;
      }
      int v14 = v15;
      if (v15 != -3) {
        goto LABEL_28;
      }
    }
    uint64_t v20 = 5;
    int v16 = a1(a2, 18, 0, a3, 16, v21, &v20);
    if (v20 == 5) {
      int v17 = 0;
    }
    else {
      int v17 = -5;
    }
    if (v16) {
      int v14 = v16;
    }
    else {
      int v14 = v17;
    }
    if (!v16 && v20 == 5)
    {
LABEL_19:
      if (LODWORD(v21[0]))
      {
        size_t v12 = acm_mem_alloc(0x14uLL);
        acm_mem_alloc_info("ACMHandleWithPayload", v12, 20, "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c", 128, "LibCall_ACMContextCreateWithExternalForm");
        if (!v12)
        {
          unsigned int v13 = 70;
          int v14 = -4;
          goto LABEL_31;
        }
        int v18 = *(_DWORD *)((char *)v21 + 5);
        *(_OWORD *)size_t v12 = *a3;
        void v12[4] = v18;
        if (a5) {
          *a5 = BYTE4(v21[0]);
        }
        if (v14)
        {
          acm_mem_free_info("ACMHandleWithPayload", v12, 0x14uLL, "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c", 147, "LibCall_ACMContextCreateWithExternalForm");
          acm_mem_free(v12, 0x14uLL);
LABEL_29:
          unsigned int v13 = 70;
          goto LABEL_31;
        }
      }
      else
      {
        size_t v12 = 0;
      }
      goto LABEL_30;
    }
LABEL_28:
    size_t v12 = 0;
    if (v14) {
      goto LABEL_29;
    }
LABEL_30:
    int v14 = 0;
    unsigned int v13 = 10;
  }
LABEL_31:
  if (v13 >= gACMLoggingLevel) {
    printf("%s: %s: returning, CFErrorRef err = %ld.\n", "ACM", "LibCall_ACMContextCreateWithExternalForm", v14);
  }
  return v12;
}

uint64_t LibCall_ACMContextDelete(void (*a1)(uint64_t, uint64_t, void, void *, uint64_t, void, void), uint64_t a2, void *a3, int a4)
{
  if (gACMLoggingLevel <= 0xAu) {
    printf("%s: %s: called.\n", "ACM", "LibCall_ACMContextDelete");
  }
  if (a1 && a3)
  {
    if (a4) {
      a1(a2, 2, 0, a3, 16, 0, 0);
    }
    goto LABEL_7;
  }
  if (a3)
  {
LABEL_7:
    acm_mem_free_info("ACMHandleWithPayload", a3, 0x14uLL, "/Library/Caches/com.apple.xbs/Sources/AppleCredentialManager_ClientLibs/common/LibCall.c", 172, "LibCall_ACMContextDelete");
    acm_mem_free(a3, 0x14uLL);
    uint64_t v8 = 0;
    unsigned int v9 = 10;
    goto LABEL_8;
  }
  unsigned int v9 = 70;
  uint64_t v8 = 4294967293;
LABEL_8:
  if (v9 >= gACMLoggingLevel) {
    printf("%s: %s: returning, CFErrorRef err = %ld.\n", "ACM", "LibCall_ACMContextDelete", (int)v8);
  }
  return v8;
}

BOOL sub_10001E904(id a1, __OpaqueSecDbConnection *a2)
{
  int v2 = sub_10000B070("keychain");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unsigned int v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Keychain initialized!", v4, 2u);
  }
  return 1;
}

void sub_10001EB90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  objc_sync_exit(v17);
  _Unwind_Resume(a1);
}

void sub_10001EBBC(uint64_t a1, void *a2, void *a3)
{
  id v7 = a2;
  id v5 = a3;
  WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    if ([v7 isEqualToString:@"allowed-runtime"]
      && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    {
      WeakRetained[4] = [v5 longValue];
    }
    else if ([v7 isEqualToString:@"reset-period"] {
           && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    }
    {
      WeakRetained[5] = [v5 longValue];
    }
    else if ([v7 isEqualToString:@"check-period"] {
           && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    }
    {
      WeakRetained[6] = [v5 longValue];
    }
    else if ([v7 isEqualToString:@"graceful-exit-time"] {
           && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    }
    {
      WeakRetained[8] = [v5 longValue];
    }
    else
    {
      [*(id *)(a1 + 32) addObject:v7];
    }
  }
}

void sub_10001EE88(_Unwind_Exception *exception_object)
{
}

void sub_10001F074(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10001F090(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v2 = WeakRetained;
    [WeakRetained runWatchdog];
    id WeakRetained = v2;
  }
}

void sub_10001F380(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10001F3A0(id a1)
{
  unsigned int v1 = sub_10000B070("SecCritical");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "SecWatchdog: watchdog has failed to exit securityd/secd gracefully - exiting ungracefully", v2, 2u);
  }

  exit(1);
}

void sub_10001F478(id a1)
{
  mach_timebase_info info = (mach_timebase_info)0xAAAAAAAAAAAAAAAALL;
  if (mach_timebase_info(&info))
  {
    _os_assumes_log();
    uint64_t v1 = 1;
  }
  else
  {
    uint64_t v1 = info.numer / info.denom;
  }
  qword_10035CB30 = v1;
}

uint64_t sub_10001F624(uint64_t a1)
{
  qword_10035CB18 = (uint64_t)objc_alloc_init(*(Class *)(a1 + 32));

  return _objc_release_x1();
}

uint64_t start()
{
  zone = malloc_create_zone(0, 0);
  malloc_set_zone_name(zone, "ICU");
  LODWORD(cf[0]) = 0;
  u_setMemoryFunctions();
  +[NSError _setFileNameLocalizationEnabled:0];
  if (!sub_10002B120()) {
    goto LABEL_11;
  }
  if (qword_10035CC68 != -1) {
    dispatch_once(&qword_10035CC68, &stru_1002F7BD0);
  }
  if (byte_10035CC60) {
    goto LABEL_11;
  }
  if (qword_10035CC58 != -1) {
    dispatch_once(&qword_10035CC58, &stru_1002F7B90);
  }
  if (byte_10035CC54 == 1)
  {
    uint64_t v1 = sub_10000B070("keychain_handle");
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "using system keychain handle", (uint8_t *)&buf, 2u);
    }
    dword_10035D2B0 = -6;
  }
  else
  {
LABEL_11:
    id v2 = sub_10000B070("keychain_handle");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "using normal handle", (uint8_t *)&buf, 2u);
    }
  }
  if (qword_10035CC68 != -1) {
    dispatch_once(&qword_10035CC68, &stru_1002F7BD0);
  }
  if (byte_10035CC60)
  {
    uint64_t v22 = 0;
    uint64_t v23 = &v22;
    uint64_t v24 = 0x2020000000;
    int v25 = -67585;
    id v3 = [objc_alloc((Class)NSXPCConnection) initWithServiceName:@"com.apple.security.KeychainDBMover"];
    unsigned int v4 = sub_10000B070("SecKeychainMoveUserDb");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "moverCxn: %@", (uint8_t *)&buf, 0xCu);
    }

    id v5 = +[NSXPCInterface interfaceWithProtocol:&OBJC_PROTOCOL___KeychainDBMoverProtocol];
    [v3 setRemoteObjectInterface:v5];

    [v3 resume];
    *(void *)&long long buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 3221225472;
    int v29 = sub_100024568;
    __int16 v30 = &unk_1002F7210;
    int v31 = &v22;
    __int16 v6 = [v3 synchronousRemoteObjectProxyWithErrorHandler:&buf];
    cf[0] = _NSConcreteStackBlock;
    cf[1] = (CFTypeRef)3221225472;
    CFTypeRef cf[2] = sub_10002463C;
    cf[3] = &unk_1002F7210;
    cf[4] = &v22;
    [v6 moveUserDbWithReply:cf];

    [v3 invalidate];
    id v7 = sub_10000B070("SecKeychainMoveUserDb");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = *((_DWORD *)v23 + 6);
      *(_DWORD *)__int16 v26 = 67109120;
      int v27 = v8;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "returning %d", v26, 8u);
    }

    _Block_object_dispose(&v22, 8);
  }
  signal(15, (void (__cdecl *)(int))1);
  global_queue = dispatch_get_global_queue(25, 0);
  qword_10035CB38 = (uint64_t)dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_signal, 0xFuLL, 0, global_queue);
  dispatch_source_set_event_handler((dispatch_source_t)qword_10035CB38, &stru_1002F6DF8);
  dispatch_activate((dispatch_object_t)qword_10035CB38);
  byte_10035CE78 = 1;
  byte_10035CFD8 = 1;
  byte_10035CE10 = 1;
  if (qword_10035D150 != -1) {
    dispatch_once(&qword_10035D150, &stru_1003050E0);
  }
  if (qword_10035CBD8 != -1) {
    dispatch_once(&qword_10035CBD8, &stru_1002F75D0);
  }
  gSecurityd = off_10035AB08;
  qword_10035ADB0 = (uint64_t)sub_10001E900;
  qword_10035ADC0 = [[LocalSecuritydXPCServer alloc] initWithSecurityClient:SecSecurityClientGet() fakeEntitlements:&__NSDictionary0__struct];
  qword_10035ADB8 = (uint64_t)sub_1000118D4;
  cf[0] = 0;
  if (!sub_10000CBA4(0, 1, 0, (uint64_t)cf, (uint64_t)&stru_1002F6D70) || cf[0])
  {
    __int16 v10 = sub_10000B070("SecError");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(CFTypeRef *)((char *)&buf + 4) = cf[0];
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Couldn't bring up keychain: %@", (uint8_t *)&buf, 0xCu);
    }
    CFTypeRef v11 = cf[0];
    if (cf[0])
    {
      cf[0] = 0;
      CFRelease(v11);
    }
  }
  id v12 = +[SecdWatchdog watchdog];
  mach_service = xpc_connection_create_mach_service("com.apple.securityd", 0, 1uLL);
  if (!mach_service)
  {
    uint64_t v20 = sub_10000B070("SecCritical");
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 136315138;
      *(void *)((char *)&buf + 4) = "com.apple.securityd";
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "security failed to register xpc listener for %s, exiting", (uint8_t *)&buf, 0xCu);
    }
    abort();
  }
  int v14 = mach_service;
  xpc_connection_set_event_handler(mach_service, &stru_1002F6E38);
  xpc_connection_resume(v14);
  xpc_activity_register("com.apple.securityd.daily", XPC_ACTIVITY_CHECK_IN, &stru_1002F6F38);
  xpc_activity_register("com.apple.securityd.entropyhealth", XPC_ACTIVITY_CHECK_IN, &stru_1002F6F78);
  xpc_activity_register("com.apple.securityd.prng", XPC_ACTIVITY_CHECK_IN, &stru_1002F6FB8);
  xpc_activity_register("com.apple.securityd.kcsharing.resync", XPC_ACTIVITY_CHECK_IN, &stru_1002F6FF8);
  if (qword_10035CB58 != -1) {
    dispatch_once(&qword_10035CB58, &stru_1002F7230);
  }
  if (qword_10035D498 != -1) {
    dispatch_once(&qword_10035D498, &stru_100309BE0);
  }
  if (qword_10035CDA8 != -1) {
    dispatch_once(&qword_10035CDA8, &stru_1002F8CD8);
  }
  if (qword_10035CFE0 != -1) {
    dispatch_once(&qword_10035CFE0, &stru_1002FB8A0);
  }
  if (qword_10035CD70 != -1) {
    dispatch_once(&qword_10035CD70, &stru_1002F88B0);
  }
  int v15 = sub_10000B070("keychainitemupgrade");
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(buf) = 0;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "performing KeychainItemUpgradeRequestServerInitialize", (uint8_t *)&buf, 2u);
  }

  int v16 = +[KeychainItemUpgradeRequestServer server];
  int v17 = [v16 controller];
  [v17 triggerKeychainItemUpdateRPC:&stru_100305028];

  id v18 = +[KCSharingXPCListenerDelegate sharedInstance];
  CFRunLoopRun();
  return 0;
}

void sub_10001FEB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10001FED0(id a1, _xpc_activity_s *a2)
{
  if (xpc_activity_get_state(a2) == 2
    && objc_opt_class()
    && atomic_load_explicit(dword_10035CD18, memory_order_acquire) <= 1)
  {
    id v2 = KCSharingLogObject();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)unsigned int v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Requesting resync", v4, 2u);
    }

    id v3 = +[KCSharingSyncController sharedInstance];
    [v3 resyncFromRPC:0 completion:&stru_1003051C0];
  }
}

void sub_10001FF9C(id a1, _xpc_activity_s *a2)
{
  if (xpc_activity_get_state(a2) != 2) {
    return;
  }
  int v17 = 0;
  int v2 = open("/dev/random", 1);
  if (v2 == -1)
  {
    id v5 = sub_10000B070("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = *__error();
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v19) = v7;
      __int16 v6 = "failed to open /dev/random (%d)";
      goto LABEL_8;
    }
  }
  else
  {
    int v3 = sub_100018F90(-1, 13, 4u, 0, 0, &v17);
    if (!v3)
    {
      size_t __nbyte = 0;
      __int16 v10 = (char *)sub_100019D1C(v17, &__nbyte);
      size_t v11 = __nbyte;
      ccec_cp_256();
      if (v11 > (((unint64_t)(cczp_bitlen() + 7) >> 2) | 1))
      {
        id v12 = sub_10000B070("SecError");
        if (!os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_10;
        }
        *(_DWORD *)long long buf = 134217984;
        size_t v19 = __nbyte;
        __int16 v6 = "invalid pub key (%zu)";
        int v8 = v12;
        uint32_t v9 = 12;
        goto LABEL_9;
      }
      size_t v13 = __nbyte;
      if (!__nbyte) {
        goto LABEL_10;
      }
      while (1)
      {
        ssize_t v14 = write(v2, v10, v13);
        if (v14 == -1) {
          break;
        }
        v10 += v14;
        size_t v13 = __nbyte - v14;
        __nbyte -= v14;
        if (!__nbyte) {
          goto LABEL_10;
        }
      }
      id v5 = sub_10000B070("SecError");
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_10;
      }
      int v15 = *__error();
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v19) = v15;
      __int16 v6 = "failed to write /dev/random (%d)";
LABEL_8:
      int v8 = v5;
      uint32_t v9 = 8;
LABEL_9:
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v6, buf, v9);
      goto LABEL_10;
    }
    int v4 = v3;
    id v5 = sub_10000B070("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      LODWORD(v19) = v4;
      __int16 v6 = "failed to create refkey (%d)";
      goto LABEL_8;
    }
  }
LABEL_10:
  if (v17) {
    sub_100019344((uint64_t *)&v17);
  }
  if ((v2 & 0x80000000) == 0) {
    close(v2);
  }
}

void sub_100020200(id a1, _xpc_activity_s *a2)
{
  if (xpc_activity_get_state(a2) == 2)
  {
    _SecCoreAnalyticsSendKernEntropyAnalytics();
  }
}

void sub_10002023C(id a1, _xpc_activity_s *a2)
{
  if (xpc_activity_get_state(a2) == 2)
  {
    int v3 = +[CKKSViewManager manager];
    [v3 xpc24HrNotification];

    id v5 = +[OTManager manager];
    [v5 xpc24HrNotification];

    if (objc_opt_class())
    {
      if (atomic_load_explicit(dword_10035CD18, memory_order_acquire) <= 1)
      {
        __int16 v6 = KCSharingLogObject();
        if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)int v8 = 0;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Requesting maintenance", v8, 2u);
        }

        int v7 = +[KCSharingSyncController sharedInstance];
        [v7 performMaintenanceWithCompletion:&stru_1003051A0];
      }
    }
  }
}

BOOL sub_100020570(unsigned int a1, __SecTask *a2, const __CFString *a3, __CFString **a4)
{
  BOOL v8 = sub_10000DC40(a2, a3);
  if (!v8)
  {
    if (a1 > 0x87) {
      CFStringRef v9 = @"Unknown xpc operation";
    }
    else {
      CFStringRef v9 = off_100305B48[a1];
    }
    sub_100012A40(-34018, a4, @"%@: %@ lacks entitlement %@", v9, a2, a3);
  }
  return v8;
}

BOOL sub_100020608(int a1, CFDataRef theData)
{
  size_t Length = CFDataGetLength(theData);
  BytePtr = CFDataGetBytePtr(theData);
  do
  {
    size_t v6 = Length;
    if (!Length) {
      break;
    }
    ssize_t v7 = write(a1, BytePtr, Length);
    Length -= v7;
    BytePtr += v7;
  }
  while (v7 > 0);
  return v6 == 0;
}

CFDataRef sub_10002067C(int a1, const UInt8 **a2, CFIndex *a3)
{
  v6.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  v6.tv_nsec = 0xAAAAAAAAAAAAAAAALL;
  *(timespec *)&v10.st_blksize = v6;
  *(timespec *)v10.st_qspare = v6;
  v10.st_birthtimespec = v6;
  *(timespec *)&v10.off_t st_size = v6;
  v10.st_mtimespec = v6;
  v10.st_ctimespec = v6;
  *(timespec *)&v10.st_uid = v6;
  v10.st_atimespec = v6;
  *(timespec *)&v10.st_dev = v6;
  if (fstat(a1, &v10) < 0) {
    return 0;
  }
  off_t st_size = v10.st_size;
  *a3 = v10.st_size;
  BOOL v8 = (const UInt8 *)mmap(0, st_size, 1, 1, a1, 0);
  *a2 = v8;
  if (v8 == (const UInt8 *)-1) {
    return 0;
  }
  else {
    return CFDataCreateWithBytesNoCopy(0, v8, *a3, kCFAllocatorNull);
  }
}

void sub_100020728(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  int v4 = *(void **)(a1 + 40);
  char v5 = sub_10021DC14(a2, a3, a4);

  xpc_dictionary_set_BOOL(v4, "status", v5);
}

void sub_100020784(void *a1, uint64_t a2)
{
  int v4 = sub_100020D7C(a1, "userlabel");
  char v5 = sub_100020DC8(a1);
  timespec v6 = sub_100020D7C(a1, "dsid");
  if (v4 && v5)
  {
    (*(void (**)(uint64_t, const char *, const UInt8 *, const char *))(a2 + 16))(a2, v4, v5, v6);
  }
  else if (!v4)
  {
    goto LABEL_6;
  }
  CFRelease(v4);
LABEL_6:
  if (v5) {
    CFRelease(v5);
  }
  if (v6)
  {
    CFRelease(v6);
  }
}

void sub_100020848(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3 = *(void **)(a1 + 40);
  char v4 = sub_10021EE5C(a2, a3, 0, (uint64_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));

  xpc_dictionary_set_BOOL(v3, "status", v4);
}

void sub_1000208A0(void *a1, uint64_t a2)
{
  char v4 = sub_100020D7C(a1, "userlabel");
  char v5 = sub_100020DC8(a1);
  timespec v6 = v5;
  if (v4) {
    BOOL v7 = v5 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    (*(void (**)(uint64_t, const char *, const UInt8 *))(a2 + 16))(a2, v4, v5);
    goto LABEL_11;
  }
  if (v4)
  {
LABEL_11:
    CFRelease(v4);
    if (!v6) {
      return;
    }
    goto LABEL_8;
  }
  if (!v5) {
    return;
  }
LABEL_8:

  CFRelease(v6);
}

void sub_100020944(uint64_t a1, uint64_t a2, uint64_t a3, os_signpost_id_t a4)
{
  char v4 = *(void **)(a1 + 40);
  char v5 = sub_10021EE5C(a2, a3, a4, (uint64_t *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));

  xpc_dictionary_set_BOOL(v4, "status", v5);
}

void sub_1000209A0(uint64_t a1, uint64_t a2, int a3)
{
  int v3 = *(void **)(a1 + 40);
  int64_t v4 = (int)sub_10021CFC0(a2, a3, (CFTypeRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));

  xpc_dictionary_set_int64(v3, "status", v4);
}

void sub_1000209F8(void *a1, uint64_t a2)
{
  int64_t v4 = sub_100020D7C(a1, "viewname");
  int64_t int64 = xpc_dictionary_get_int64(a1, "viewactioncode");
  if (v4)
  {
    (*(void (**)(uint64_t, const char *, int64_t))(a2 + 16))(a2, v4, int64);
    CFRelease(v4);
  }
}

void *sub_100020A84(void *a1, const char *a2)
{
  CFTypeRef v9 = 0;
  xpc_object_t value = xpc_dictionary_get_value(a1, a2);
  int v3 = value;
  if (!value) {
    return v3;
  }
  CFTypeRef cf = 0;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_data)
  {
    sub_1000297A0(1, @"com.apple.security.xpc", 0, &v9, v4, @"xpcSetDER not data, got %@", v3);
LABEL_6:
    int v3 = 0;
    goto LABEL_8;
  }
  bytes_ptr = (char *)xpc_data_get_bytes_ptr(v3);
  size_t length = xpc_data_get_length(v3);
  if ((char *)sub_10002A624(kCFAllocatorDefault, &cf, &v9, (uint64_t)bytes_ptr, (uint64_t)&bytes_ptr[length]) != &bytes_ptr[length])
  {
    sub_100012A40(-26275, (__CFString **)&v9, @"trailing garbage at end of SecAccessControl data");
    if (cf) {
      CFRelease(cf);
    }
    goto LABEL_6;
  }
  int v3 = (void *)cf;
LABEL_8:
  CFTypeRef v7 = v9;
  if (v9)
  {
    CFTypeRef v9 = 0;
    CFRelease(v7);
  }
  return v3;
}

void sub_100020B7C(void *a1, const void *a2)
{
  if (a2)
  {
    XPCObjectWithArrayOfPeerInfo = (void *)CreateXPCObjectWithArrayOfPeerInfo();
    if (XPCObjectWithArrayOfPeerInfo)
    {
      char v5 = XPCObjectWithArrayOfPeerInfo;
      xpc_dictionary_set_value(a1, "status", XPCObjectWithArrayOfPeerInfo);
      xpc_release(v5);
    }
    CFRelease(a2);
  }
}

void sub_100020BF4(void *a1, const void *a2)
{
  if (a2)
  {
    uint64_t v4 = (void *)_CFXPCCreateXPCObjectFromCFObject();
    xpc_dictionary_set_value(a1, "status", v4);
    xpc_release(v4);
    CFRelease(a2);
  }
}

CFDataRef sub_100020C64(void *a1)
{
  size_t length = 0;
  data = (const UInt8 *)xpc_dictionary_get_data(a1, "data", &length);
  if (!data || (CFDataRef result = CFDataCreate(0, data, length)) == 0)
  {
    SOSCreateError();
    return 0;
  }
  return result;
}

uint64_t sub_100020CE4(void *a1, CFTypeRef *a2)
{
  size_t length = 0;
  data = xpc_dictionary_get_data(a1, "peer-info", &length);
  sub_1000297D0(data != 0, a2, @"No data for key %s", "peer-info");
  if (data) {
    return SOSPeerInfoCreateFromDER();
  }
  else {
    return 0;
  }
}

const char *sub_100020D7C(void *a1, const char *a2)
{
  CFDataRef result = xpc_dictionary_get_string(a1, a2);
  if (result)
  {
    return (const char *)CFStringCreateWithCString(kCFAllocatorDefault, result, 0x8000100u);
  }
  return result;
}

const UInt8 *sub_100020DC8(void *a1)
{
  size_t length = 0;
  CFDataRef result = (const UInt8 *)xpc_dictionary_get_data(a1, "password", &length);
  if (result) {
    return (const UInt8 *)CFDataCreateWithBytesNoCopy(kCFAllocatorDefault, result, length, kCFAllocatorNull);
  }
  return result;
}

void sub_100020E20(id a1)
{
  uint64_t v1 = sub_10000B070("signal");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "SIGTERM, exiting when clean ", v2, 2u);
  }
  xpc_transaction_exit_clean();
}

void sub_100020E8C(id a1)
{
  CFDictionaryRef v1 = (const __CFDictionary *)MKBUserTypeDeviceMode();
  xpc_object_t value = 0;
  if (v1)
  {
    CFDictionaryRef v2 = v1;
    if (CFDictionaryGetValueIfPresent(v1, kMKBDeviceModeKey, (const void **)&value))
    {
      if (CFEqual(value, kMKBDeviceModeMultiUser)) {
        byte_10035CB48 = 1;
      }
    }
    CFRelease(v2);
  }
}

uint64_t sub_100020F0C(uint64_t a1, CFTypeRef cf1)
{
  uint64_t result = CFEqual(cf1, *(CFTypeRef *)(a1 + 40));
  if (result) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
  return result;
}

uint64_t sub_100020F50(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

BOOL sub_100021194(id a1, __OpaqueSecDbConnection *a2)
{
  return 1;
}

void sub_100021790(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_1000217B4(uint64_t a1, uint64_t a2)
{
  int v3 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  uint64_t v4 = sqlite3_wal_checkpoint_v2(*(sqlite3 **)(a2 + 64), 0, 1, 0, 0);

  return sub_100026D0C(a2, v4, v3, @"wal_checkpoint(FULL)");
}

void sub_100021A94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_100021ABC(uint64_t a1, uint64_t a2)
{
  return sub_10013ABB8(a2, *(void *)(a1 + 32), 0, (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
}

void sub_100021FB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32)
{
}

BOOL sub_10002200C(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8);
  int v3 = (__CFString **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  CFTypeRef cf = 0;
  unint64_t v10 = 0xAAAAAAAA00000000;
  long long v7 = *(_OWORD *)(a1 + 48);
  uint64_t v8 = a2;
  uint64_t v4 = v7;
  *(void *)(v7 + 104) = -1;
  sub_10000DF34(kSecAttrTombstone, kCFBooleanFalse, v4);
  BOOL v5 = sub_100010A40((uint64_t)sub_1001394C8, (uint64_t)&v7, v3);
  if (v5)
  {
    *(void *)(v2 + 24) = cf;
  }
  else if (cf)
  {
    CFRelease(cf);
  }
  return v5;
}

void sub_100022400(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = a2;
  CKXPCSuitableError();
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id, id))(v2 + 16))(v2, v3, v4);
}

void sub_100022808(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = a2;
  CKXPCSuitableError();
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id, id))(v2 + 16))(v2, v3, v4);
}

void sub_100022884(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  long long v7 = v6;
  if (!v5 || v6)
  {
    CFTypeRef v9 = sub_10000B070("ckkscurrent");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = a1[4];
      int v13 = 138412546;
      uint64_t v14 = v10;
      __int16 v15 = 2112;
      int v16 = v7;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "CKKS didn't find a PCS Identity for (%@): %@", (uint8_t *)&v13, 0x16u);
    }

    uint64_t v8 = *(void (**)(void))(a1[5] + 16);
  }
  else
  {
    uint64_t v8 = *(void (**)(void))(a1[5] + 16);
  }
  v8();
  if (qword_10035D098 != -1) {
    dispatch_once(&qword_10035D098, &stru_100303AB8);
  }
  if (byte_10035D090)
  {
    size_t v11 = (void *)a1[6];
    id v12 = (const void *)v11[3];
    if (v12)
    {
      v11[3] = 0;
      CFRelease(v12);
      size_t v11 = (void *)a1[6];
    }
    free(v11);
  }
}

void sub_100022DA8(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = a2;
  CKXPCSuitableError();
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id, id))(v2 + 16))(v2, v3, v4);
}

void sub_100022E24(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  long long v7 = v6;
  if (!v5 || v6)
  {
    CFTypeRef v9 = sub_10000B070("ckkscurrent");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = a1[4];
      int v13 = 138412546;
      uint64_t v14 = v10;
      __int16 v15 = 2112;
      int v16 = v7;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "CKKS didn't find a current item for (%@): %@", (uint8_t *)&v13, 0x16u);
    }

    uint64_t v8 = *(void (**)(void))(a1[5] + 16);
  }
  else
  {
    uint64_t v8 = *(void (**)(void))(a1[5] + 16);
  }
  v8();
  if (qword_10035D098 != -1) {
    dispatch_once(&qword_10035D098, &stru_100303AB8);
  }
  if (byte_10035D090)
  {
    size_t v11 = (void *)a1[6];
    id v12 = (const void *)v11[3];
    if (v12)
    {
      v11[3] = 0;
      CFRelease(v12);
      size_t v11 = (void *)a1[6];
    }
    free(v11);
  }
}

void sub_10002332C(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = a3;
  id v6 = a2;
  CKXPCSuitableError();
  id v7 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id, id, id))(v4 + 16))(v4, v6, v5, v7);
}

void sub_1000233BC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = sub_10000B070("ckkscurrent");
  uint64_t v8 = v7;
  if (!v5 || v6)
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = *(void *)(a1 + 32);
      uint64_t v16 = *(void *)(a1 + 40);
      int v17 = [v5 uuid];
      *(_DWORD *)long long buf = 138413058;
      uint64_t v28 = v15;
      __int16 v29 = 2112;
      uint64_t v30 = v16;
      __int16 v31 = 2112;
      __int16 v32 = v17;
      __int16 v33 = 2112;
      id v34 = v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "CKKS didn't find a current item for (%@,%@): %@ %@", buf, 0x2Au);
    }
    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
    if (qword_10035D098 != -1) {
      dispatch_once(&qword_10035D098, &stru_100303AB8);
    }
    if (byte_10035D090)
    {
      id v18 = *(void **)(a1 + 64);
      size_t v19 = (const void *)v18[3];
      if (v19)
      {
        v18[3] = 0;
        CFRelease(v19);
        id v18 = *(void **)(a1 + 64);
      }
      free(v18);
    }
  }
  else
  {
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v20 = *(void *)(a1 + 32);
      uint64_t v21 = *(void *)(a1 + 40);
      uint64_t v22 = [v5 uuid];
      *(_DWORD *)long long buf = 138412802;
      uint64_t v28 = v20;
      __int16 v29 = 2112;
      uint64_t v30 = v21;
      __int16 v31 = 2112;
      __int16 v32 = v22;
      _os_log_debug_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "CKKS believes current item UUID for (%@,%@) is %@. Looking up persistent ref...", buf, 0x20u);
    }
    CFTypeRef v9 = *(void **)(a1 + 48);
    uint64_t v10 = [v5 uuid];
    size_t v11 = +[NSString stringWithFormat:@"%@,%@", *(void *)(a1 + 32), *(void *)(a1 + 40)];
    v23[0] = _NSConcreteStackBlock;
    v23[1] = 3221225472;
    void v23[2] = sub_100023690;
    v23[3] = &unk_1002F70B8;
    uint64_t v12 = *(void *)(a1 + 64);
    id v25 = *(id *)(a1 + 56);
    id v13 = v5;
    uint64_t v14 = *(void *)(a1 + 64);
    id v24 = v13;
    uint64_t v26 = v14;
    [v9 findItemPersistentRefByUUID:v10 extraLoggingString:v11 client:v12 complete:v23];
  }
}

void sub_100023690(void *a1, void *a2, void *a3)
{
  id v6 = (void *)a1[4];
  uint64_t v5 = a1[5];
  id v7 = a3;
  id v8 = a2;
  CFTypeRef v9 = [v6 modificationDate];
  (*(void (**)(uint64_t, id, void *, id))(v5 + 16))(v5, v8, v9, v7);

  if (qword_10035D098 != -1) {
    dispatch_once(&qword_10035D098, &stru_100303AB8);
  }
  if (byte_10035D090)
  {
    uint64_t v10 = (void *)a1[6];
    size_t v11 = (const void *)v10[3];
    if (v11)
    {
      v10[3] = 0;
      CFRelease(v11);
      uint64_t v10 = (void *)a1[6];
    }
    free(v10);
  }
}

void sub_100023A74(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  CKXPCSuitableError();
  id v2 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id))(v1 + 16))(v1, v2);
}

void sub_100023EC8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  CKXPCSuitableError();
  id v2 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id))(v1 + 16))(v1, v2);
}

void sub_10002446C(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = a3;
  id v6 = a2;
  CKXPCSuitableError();
  id v7 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id, id, id))(v4 + 16))(v4, v6, v5, v7);
}

id sub_1000244FC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void **)(a1 + 32);
  id v5 = CKXPCSuitableError();
  [v4 callCallback:a2 error:v5];

  id v6 = *(void **)(a1 + 40);

  return [v6 setTransaction:0];
}

void sub_100024568(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = sub_10000B070("SecError");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 138412290;
    id v6 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "SecKeychainMoveUserDb: remote object failed with error: %@", (uint8_t *)&v5, 0xCu);
  }

  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = [v3 code];
}

void sub_10002463C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (v3)
  {
    int v5 = sub_10000B070("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 138412290;
      id v7 = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "SecKeychainMoveUserDb: replied with error: %@", (uint8_t *)&v6, 0xCu);
    }

    LODWORD(v3) = [v4 code];
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v3;
}

void sub_100024C8C(id a1)
{
  id v2 = objc_alloc_init(SecuritydXPCServerListener);
  id v3 = (void *)qword_10035CB50;
  qword_10035CB50 = (uint64_t)v2;
}

void sub_100024CE0(id a1)
{
  qword_10035CB78 = (uint64_t)dispatch_queue_create("security scope control", (dispatch_queue_attr_t)&_dispatch_queue_attr_concurrent);
}

uint64_t sub_100024D10(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_100024D28(uint64_t a1)
{
  CFArrayRef v1 = (const __CFArray *)qword_10035CB60;
  context[0] = _NSConcreteStackBlock;
  context[1] = 0x40000000;
  context[2] = sub_100024DCC;
  context[3] = &unk_1002F7270;
  context[4] = *(void *)(a1 + 32);
  v3.size_t length = CFArrayGetCount((CFArrayRef)qword_10035CB60);
  v3.location = 0;
  CFArrayApplyFunction(v1, v3, (CFArrayApplierFunction)sub_100024D10, context);
}

void sub_100024DCC(uint64_t a1, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFSetGetTypeID())
    {
      CFMutableArrayRef v5 = sub_100024F44((const __CFSet *)cf);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v5);
      if (v5)
      {
        CFRelease(v5);
      }
      return;
    }
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFDictionaryGetTypeID())
    {
      CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      context[0] = _NSConcreteStackBlock;
      context[1] = 0x40000000;
      context[2] = sub_100024FF4;
      context[3] = &unk_1002F7250;
      context[4] = Mutable;
      CFDictionaryApplyFunction((CFDictionaryRef)cf, (CFDictionaryApplierFunction)sub_100025084, context);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), Mutable);
      return;
    }
  }
  id v8 = *(__CFArray **)(a1 + 32);

  CFArrayAppendValue(v8, kCFNull);
}

CFMutableArrayRef sub_100024F44(const __CFSet *a1)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  context[0] = _NSConcreteStackBlock;
  context[1] = 0x40000000;
  context[2] = sub_1000250A0;
  context[3] = &unk_1002F7330;
  context[4] = Mutable;
  CFSetApplyFunction(a1, (CFSetApplierFunction)sub_100024D10, context);
  return Mutable;
}

void sub_100024FF4(uint64_t a1, const void *a2, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFSetGetTypeID())
    {
      CFMutableArrayRef v7 = sub_100024F44((const __CFSet *)cf);
      CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, v7);
      if (v7)
      {
        CFRelease(v7);
      }
    }
  }
}

uint64_t sub_100025084(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void sub_1000250A0(uint64_t a1, const void *a2)
{
}

void sub_1000250A8(const __CFDictionary *a1, int a2)
{
  CFDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  context[0] = _NSConcreteStackBlock;
  context[1] = 0x40000000;
  context[2] = sub_100025190;
  context[3] = &unk_1002F72B0;
  context[4] = Mutable;
  CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)sub_100025084, context);
  if (CFDictionaryGetCount(Mutable) >= 1) {
    sub_100025384(a2, (uint64_t)Mutable);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
}

void sub_100025190(uint64_t a1, const __CFNumber *cf, const __CFString *a3)
{
  CFNumberRef v4 = cf;
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFStringGetTypeID())
    {
      if (CFEqual(v4, @"Emergency"))
      {
        int v7 = 0;
LABEL_22:
        int valuePtr = v7;
        CFNumberRef v4 = CFNumberCreate(kCFAllocatorDefault, kCFNumberIntType, &valuePtr);
        goto LABEL_23;
      }
      if (CFEqual(v4, @"Alert"))
      {
        int v7 = 1;
        goto LABEL_22;
      }
      if (CFEqual(v4, @"Critical"))
      {
        int v7 = 2;
        goto LABEL_22;
      }
      if (CFEqual(v4, @"Error"))
      {
        int v7 = 3;
        goto LABEL_22;
      }
      if (CFEqual(v4, @"Warning"))
      {
        int v7 = 4;
        goto LABEL_22;
      }
      if (CFEqual(v4, @"Notice"))
      {
        int v7 = 5;
        goto LABEL_22;
      }
      if (CFEqual(v4, @"Info"))
      {
        int v7 = 6;
        goto LABEL_22;
      }
      if (CFEqual(v4, @"Debug"))
      {
        int v7 = 7;
        goto LABEL_22;
      }
    }
    else
    {
      CFTypeID v8 = CFGetTypeID(v4);
      if (v8 == CFNumberGetTypeID())
      {
        CFRetain(v4);
        if (a3) {
          goto LABEL_24;
        }
        goto LABEL_29;
      }
    }
    CFNumberRef v4 = 0;
    if (a3) {
      goto LABEL_24;
    }
LABEL_29:
    if (!v4) {
      return;
    }
    goto LABEL_30;
  }
LABEL_23:
  if (!a3) {
    goto LABEL_29;
  }
LABEL_24:
  CFTypeID v9 = CFGetTypeID(a3);
  if (v9 != CFStringGetTypeID()) {
    goto LABEL_29;
  }
  uint64_t v10 = sub_10002552C(a3);
  size_t v11 = v10;
  if (v4 && v10)
  {
    CFDictionaryAddValue(*(CFMutableDictionaryRef *)(a1 + 32), v4, v10);
    CFRelease(v4);
    CFNumberRef v4 = v11;
LABEL_30:
    CFRelease(v4);
    return;
  }
  if (v4) {
    CFRelease(v4);
  }
  CFNumberRef v4 = v11;
  if (v11) {
    goto LABEL_30;
  }
}

void sub_100025384(int a1, uint64_t a2)
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 0x40000000;
  v2[2] = sub_100025424;
  v2[3] = &unk_1002F7370;
  int v3 = a1;
  v2[4] = a2;
  if (qword_10035CB80 != -1) {
    dispatch_once(&qword_10035CB80, &stru_1002F7310);
  }
  dispatch_barrier_sync((dispatch_queue_t)qword_10035CB78, v2);
}

void sub_100025424(uint64_t a1)
{
  CFDictionaryRef Mutable = (__CFArray *)qword_10035CB60;
  if (qword_10035CB60)
  {
    CFNullRef v3 = kCFNull;
  }
  else
  {
    CFDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 4, &kCFTypeArrayCallBacks);
    CFNullRef v3 = kCFNull;
    int v4 = 5;
    do
    {
      CFArrayAppendValue(Mutable, kCFNull);
      --v4;
    }
    while (v4);
    qword_10035CB60 = (uint64_t)Mutable;
  }
  CFArraySetValueAtIndex(Mutable, *(int *)(a1 + 40), *(const void **)(a1 + 32));
  CFArrayRef v5 = (const __CFArray *)qword_10035CB60;
  v9.size_t length = CFArrayGetCount((CFArrayRef)qword_10035CB60);
  v9.location = 0;
  CountOfCFStringRef Value = CFArrayGetCountOfValue(v5, v9, v3);
  if (CountOfValue == CFArrayGetCount(v5))
  {
    int v7 = (const void *)qword_10035CB60;
    if (qword_10035CB60)
    {
      qword_10035CB60 = 0;
      CFRelease(v7);
    }
  }
}

__CFSet *sub_10002552C(const __CFString *a1)
{
  CFDictionaryRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  int HasPrefix = CFStringHasPrefix(a1, @"-");
  if (HasPrefix)
  {
    CFIndex Length = CFStringGetLength(@"-");
    v11.size_t length = CFStringGetLength(a1) - 1;
    v11.location = Length;
    CFStringRef v5 = CFStringCreateWithSubstring(kCFAllocatorDefault, a1, v11);
    a1 = v5;
  }
  else
  {
    CFStringRef v5 = 0;
  }
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings(kCFAllocatorDefault, a1, @",");
  CFArrayRef v7 = ArrayBySeparatingStrings;
  if (ArrayBySeparatingStrings)
  {
    context[0] = _NSConcreteStackBlock;
    context[1] = 0x40000000;
    context[2] = sub_1000256E0;
    context[3] = &unk_1002F7350;
    context[4] = Mutable;
    v10.size_t length = CFArrayGetCount(ArrayBySeparatingStrings);
    v10.location = 0;
    CFArrayApplyFunction(v7, v10, (CFArrayApplierFunction)sub_100024D10, context);
  }
  CFSetRemoveValue(Mutable, @"none");
  CFSetRemoveValue(Mutable, &stru_10030AA90);
  if (CFSetContainsValue(Mutable, @"all"))
  {
    CFSetRemoveAllValues(Mutable);
    if (HasPrefix) {
      goto LABEL_11;
    }
  }
  else if (!HasPrefix)
  {
    goto LABEL_11;
  }
  CFSetSetValue(Mutable, @"-");
LABEL_11:
  if (v7) {
    CFRelease(v7);
  }
  if (v5) {
    CFRelease(v5);
  }
  return Mutable;
}

void sub_1000256E0(uint64_t a1, const __CFString *cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID())
    {
      MutableCFStringRef Copy = CFStringCreateMutableCopy(kCFAllocatorDefault, 0, cf);
      CFStringTrimWhitespace(MutableCopy);
      CFSetSetValue(*(CFMutableSetRef *)(a1 + 32), MutableCopy);
      if (MutableCopy)
      {
        CFRelease(MutableCopy);
      }
    }
  }
}

void sub_10002577C(const __CFString *a1, int a2)
{
  CFNullRef v3 = sub_10002552C(a1);
  sub_100025384(a2, (uint64_t)v3);
  if (v3)
  {
    CFRelease(v3);
  }
}

void sub_1000257D4(uint64_t a1, const char *a2)
{
  id v2 = (__CFDictionary *)qword_10035CB70;
  CFNullRef v3 = *(const void **)(a1 + 32);
  os_log_t v4 = os_log_create("com.apple.securityd", a2);

  CFDictionaryAddValue(v2, v3, v4);
}

uint64_t sub_100025824()
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_1000258BC;
  block[3] = &unk_1002F7390;
  block[4] = &qword_10035CB90;
  if (qword_10035CB88 != -1) {
    dispatch_once(&qword_10035CB88, block);
  }
  return qword_10035CB90;
}

CFDictionaryRef sub_1000258BC(uint64_t a1)
{
  values = kCFBooleanTrue;
  keys = @"debug";
  CFDictionaryRef result = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&keys, (const void **)&values, 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  **(void **)(a1 + 32) = result;
  return result;
}

void sub_10002595C(const __CFArray *a1, CFStringRef theString, const __CFString *a3, uint64_t a4)
{
  if (a1)
  {
    uint64_t v11 = 0;
    uint64_t v12 = &v11;
    uint64_t v13 = 0x2000000000;
    MutableCFStringRef Copy = (CFMutableStringRef)0xAAAAAAAAAAAAAAAALL;
    MutableCFStringRef Copy = CFStringCreateMutableCopy(kCFAllocatorDefault, 0, theString);
    v10[0] = 0;
    v10[1] = v10;
    v10[2] = 0x2000000000;
    v10[3] = &stru_10030AA90;
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000;
    _OWORD v9[2] = sub_100025AF4;
    v9[3] = &unk_1002F7498;
    v9[4] = &v11;
    v9[5] = v10;
    v16.size_t length = CFArrayGetCount(a1);
    v16.location = 0;
    CFArrayApplyFunction(a1, v16, (CFArrayApplierFunction)sub_100025B58, v9);
    CFStringAppend((CFMutableStringRef)v12[3], a3);
    (*(void (**)(uint64_t, uint64_t))(a4 + 16))(a4, v12[3]);
    CFArrayRef v7 = (const void *)v12[3];
    if (v7)
    {
      v12[3] = 0;
      CFRelease(v7);
    }
    _Block_object_dispose(v10, 8);
    _Block_object_dispose(&v11, 8);
  }
  else
  {
    CFTypeID v8 = *(void (**)(uint64_t, const __CFString *))(a4 + 16);
    v8(a4, @"null");
  }
}

void sub_100025AF4(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = @", ";
}

uint64_t sub_100025B58(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_100025B70(const __CFSet *a1, uint64_t a2)
{
  if (a1)
  {
    CFIndex Count = CFSetGetCount(a1);
    CFMutableArrayRef Mutable = CFArrayCreateMutable(0, Count, &kCFTypeArrayCallBacks);
    CFSetApplyFunction(a1, (CFSetApplierFunction)sub_100025C7C, Mutable);
    v8.size_t length = CFArrayGetCount(Mutable);
    v8.location = 0;
    CFArraySortValues(Mutable, v8, (CFComparatorFunction)&_CFStringCompare, 0);
    sub_10002595C(Mutable, @"{("), CFSTR(")}", a2);
    if (Mutable)
    {
      CFRelease(Mutable);
    }
  }
  else
  {
    CFTypeID v6 = *(void (**)(uint64_t, const __CFString *))(a2 + 16);
    v6(a2, @"null");
  }
}

void sub_100025C7C(const __CFString *a1, __CFArray *a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == CFStringGetTypeID())
  {
    CFStringRef v5 = a2;
    CFStringRef v6 = a1;
LABEL_8:
    CFArrayAppendValue(v5, v6);
    return;
  }
  CFStringRef v7 = CFCopyDescription(a1);
  if (!v7)
  {
    CFStringRef v6 = @"null";
    CFStringRef v5 = a2;
    goto LABEL_8;
  }
  CFStringRef v8 = v7;
  CFArrayAppendValue(a2, v7);

  CFRelease(v8);
}

void sub_100025D24(id a1)
{
  qword_10035CBD0 = (uint64_t)CFCalendarCreateWithIdentifier(kCFAllocatorDefault, kCFGregorianCalendar);
  CFTimeZoneRef v1 = CFTimeZoneCreateWithTimeIntervalFromGMT(kCFAllocatorDefault, 0.0);
  CFCalendarSetTimeZone((CFCalendarRef)qword_10035CBD0, v1);
  if (v1)
  {
    CFRelease(v1);
  }
}

void sub_100025DA8(id a1)
{
  qword_10035CBC0 = (uint64_t)dispatch_queue_create("ZuluCalendar", 0);
}

CFStringRef sub_100025DD4(const __CFString *a1, const __CFCharacterSet *a2)
{
  CFIndex Length = CFStringGetLength(a1);
  CFStringRef theString = a1;
  uint64_t v37 = 0;
  CFIndex v38 = Length;
  CharactersPtr = CFStringGetCharactersPtr(a1);
  CStringPtr = 0;
  uint64_t v35 = CharactersPtr;
  if (!CharactersPtr) {
    CStringPtr = CFStringGetCStringPtr(a1, 0x600u);
  }
  CFIndex v39 = 0;
  CFIndex v40 = 0;
  id v36 = CStringPtr;
  if (Length < 1) {
    return &stru_10030AA90;
  }
  uint64_t v7 = 0;
  CFIndex v8 = 0;
  *(void *)&long long v9 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v9 + 1) = 0xAAAAAAAAAAAAAAAALL;
  v33[6] = v9;
  v33[7] = v9;
  v33[4] = v9;
  void v33[5] = v9;
  v33[2] = v9;
  v33[3] = v9;
  uint64_t v10 = 64;
  CFStringRef v11 = &stru_10030AA90;
  v33[0] = v9;
  v33[1] = v9;
  while (1)
  {
    uint64_t v12 = (unint64_t)v8 >= 4 ? 4 : v8;
    CFIndex v13 = v38;
    if (v38 <= v8)
    {
      UniChar v14 = 0;
    }
    else if (v35)
    {
      UniChar v14 = v35[v8 + v37];
    }
    else if (v36)
    {
      UniChar v14 = v36[v37 + v8];
    }
    else
    {
      CFIndex v15 = v39;
      if (v40 <= v8 || v39 > v8)
      {
        uint64_t v17 = v12 + v7;
        uint64_t v18 = v10 - v12;
        CFIndex v19 = v8 - v12;
        CFIndex v20 = v19 + 64;
        if (v19 + 64 >= v38) {
          CFIndex v20 = v38;
        }
        CFIndex v39 = v19;
        CFIndex v40 = v20;
        if (v38 >= v18) {
          CFIndex v13 = v18;
        }
        v41.size_t length = v13 + v17;
        v41.location = v19 + v37;
        CFStringGetCharacters(theString, v41, (UniChar *)v33);
        CFIndex v15 = v39;
      }
      UniChar v14 = *((_WORD *)v33 + v8 - v15);
    }
    if (!CFCharacterSetIsCharacterMember(a2, v14)) {
      break;
    }
    ++v8;
    --v7;
    ++v10;
    if (Length == v8) {
      return v11;
    }
  }
  CFIndex v21 = -Length;
  CFIndex v22 = Length + 64;
  uint64_t v23 = 1;
  while (1)
  {
    uint64_t v24 = (unint64_t)Length >= 5 ? 5 : Length;
    if (Length < 2) {
      break;
    }
    CFIndex v25 = v38;
    if (v38 >= Length)
    {
      if (v35)
      {
        UniChar v26 = v35[Length - 1 + v37];
      }
      else if (v36)
      {
        UniChar v26 = v36[v37 - 1 + Length];
      }
      else
      {
        if (v40 < Length || (CFIndex v27 = v39, v39 >= Length))
        {
          uint64_t v28 = v24 + v21;
          CFIndex v29 = v22 - v24;
          CFIndex v30 = Length - v24;
          CFIndex v31 = v30 + 64;
          if (v30 + 64 >= v38) {
            CFIndex v31 = v38;
          }
          CFIndex v39 = v30;
          CFIndex v40 = v31;
          if (v38 >= v29) {
            CFIndex v25 = v29;
          }
          v42.size_t length = v25 + v28;
          v42.location = v30 + v37;
          CFStringGetCharacters(theString, v42, (UniChar *)v33);
          CFIndex v27 = v39;
        }
        UniChar v26 = *((_WORD *)&v33[-1] + Length - v27 + 7);
      }
    }
    else
    {
      UniChar v26 = 0;
    }
    ++v21;
    --v22;
    --Length;
    if (!CFCharacterSetIsCharacterMember(a2, v26))
    {
      uint64_t v23 = Length + 1;
      break;
    }
  }
  v43.size_t length = v23 - v8;
  v43.location = v8;
  return CFStringCreateWithSubstring(0, a1, v43);
}

void sub_100026084(uint64_t a1)
{
  CFLocaleRef v2 = CFLocaleCopyCurrent();
  **(void **)(a1 + 32) = CFDateFormatterCreate(kCFAllocatorDefault, v2, kCFDateFormatterNoStyle, kCFDateFormatterNoStyle);
  CFDateFormatterSetFormat(**(CFDateFormatterRef **)(a1 + 32), @"yyyy-MM-dd HH:mm");
  if (v2)
  {
    CFRelease(v2);
  }
}

dispatch_queue_t sub_100026108(uint64_t a1)
{
  dispatch_queue_t result = dispatch_queue_create("Date Formatting", 0);
  **(void **)(a1 + 32) = result;
  return result;
}

void sub_100026140(uint64_t a1, double a2)
{
  uint64_t v5 = 0;
  CFStringRef v6 = &v5;
  uint64_t v7 = 0x2000000000;
  uint64_t v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_1000262CC;
  v4[3] = &unk_1002F7470;
  v4[4] = &v5;
  *(double *)&v4[5] = a2;
  block = _NSConcreteStackBlock;
  uint64_t v10 = 0x40000000;
  CFStringRef v11 = sub_100026108;
  uint64_t v12 = &unk_1002F7448;
  CFIndex v13 = &qword_10035CBB0;
  if (qword_10035CBA8 != -1) {
    dispatch_once(&qword_10035CBA8, &block);
  }
  block = _NSConcreteStackBlock;
  uint64_t v10 = 0x40000000;
  CFStringRef v11 = sub_10002630C;
  uint64_t v12 = &unk_1002F7540;
  CFIndex v13 = v4;
  dispatch_sync((dispatch_queue_t)qword_10035CBB0, &block);
  (*(void (**)(uint64_t, uint64_t))(a1 + 16))(a1, v6[3]);
  CFNullRef v3 = (const void *)v6[3];
  if (v3)
  {
    v6[3] = 0;
    CFRelease(v3);
  }
  _Block_object_dispose(&v5, 8);
}

CFStringRef sub_1000262CC(uint64_t a1, __CFDateFormatter *a2)
{
  CFStringRef result = CFDateFormatterCreateStringWithAbsoluteTime(kCFAllocatorDefault, a2, *(CFAbsoluteTime *)(a1 + 40));
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t sub_10002630C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100026084;
  block[3] = &unk_1002F7428;
  block[4] = &qword_10035CBA0;
  if (qword_10035CB98 != -1) {
    dispatch_once(&qword_10035CB98, block);
  }
  uint64_t v2 = qword_10035CBA0;
  CFNullRef v3 = *(uint64_t (**)(uint64_t, uint64_t))(v1 + 16);

  return v3(v1, v2);
}

void sub_1000263CC(int a1, CFTypeRef *a2, CFStringRef format, ...)
{
  va_start(va, format);
  if (a2)
  {
    CFTypeID v4 = (__CFString *)*a2;
    *a2 = 0;
    sub_100012AD4(a1, @"com.apple.utilities.sqlite3", v4, a2, format, va);
  }
}

BOOL sub_10002641C(uint64_t a1, sqlite3 *a2, CFTypeRef *a3, CFStringRef format, ...)
{
  va_start(va, format);
  if (a1 && a3)
  {
    CFStringRef v7 = CFStringCreateWithFormatAndArguments(kCFAllocatorDefault, 0, format, va);
    if (a1 == 14)
    {
      uint64_t v8 = sqlite3_system_errno(a2);
      long long v9 = (void *)CFStringCreateWithFormat(0, 0, @"%d", v8);
    }
    else
    {
      long long v9 = (void *)CFRetain(&stru_10030AA90);
    }
    uint64_t v10 = v9;
    uint64_t v11 = sqlite3_extended_errcode(a2);
    uint64_t v12 = sqlite3_errmsg(a2);
    if (v11 == a1) {
      sub_1000263CC(a1, a3, @"%@: [%d]%@ %s", v7, a1, v10, v12, v14, va);
    }
    else {
      sub_1000263CC(a1, a3, @"%@: [%d->%d]%@ %s", v7, a1, v11, v10, v12, va);
    }
    if (v7) {
      CFRelease(v7);
    }
    if (v10) {
      CFRelease(v10);
    }
  }
  return a1 == 0;
}

void sub_100026540(id a1)
{
  int v1 = sqlite3_config(16, nullsub_25, 0);
  if (v1)
  {
    int v2 = v1;
    CFNullRef v3 = sub_10000B070("SecWarning");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      int v5 = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Could not set up sqlite global error logging to syslog: %d", buf, 8u);
    }
  }
}

uint64_t sub_100026600(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

CFStringRef sub_100026634(uint64_t a1)
{
  return CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"<SecDb path:%@ connections: %@>", *(void *)(a1 + 16), *(void *)(a1 + 48));
}

CFStringRef sub_100026688(uint64_t a1)
{
  return CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"<SecDb path:%@ connections: %@>", *(void *)(a1 + 16), *(void *)(a1 + 48));
}

void sub_1000266D0(uint64_t a1)
{
  int v2 = *(const void **)(a1 + 16);
  if (v2)
  {
    *(void *)(a1 + 16) = 0;
    CFRelease(v2);
  }
  CFNullRef v3 = *(NSObject **)(a1 + 24);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_1000267B4;
  block[3] = &unk_1002F7890;
  block[4] = a1;
  dispatch_sync(v3, block);
  CFTypeID v4 = *(NSObject **)(a1 + 24);
  if (v4)
  {
    dispatch_release(v4);
    *(void *)(a1 + 24) = 0;
  }
  int v5 = *(NSObject **)(a1 + 32);
  if (v5)
  {
    dispatch_release(v5);
    *(void *)(a1 + 32) = 0;
  }
  pthread_mutex_destroy((pthread_mutex_t *)(a1 + 56));
  CFStringRef v6 = *(NSObject **)(a1 + 120);
  if (v6)
  {
    dispatch_release(v6);
    *(void *)(a1 + 120) = 0;
  }
  CFStringRef v7 = *(const void **)(a1 + 136);
  if (v7)
  {
    _Block_release(v7);
    *(void *)(a1 + 136) = 0;
  }
  uint64_t v8 = *(const void **)(a1 + 152);
  if (v8)
  {
    *(void *)(a1 + 152) = 0;
    CFRelease(v8);
  }
}

void sub_1000267B4(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  CFNullRef v3 = *(const void **)(v2 + 40);
  if (v3)
  {
    *(void *)(v2 + 40) = 0;
    CFRelease(v3);
    uint64_t v2 = *(void *)(a1 + 32);
  }
  CFTypeID v4 = *(const void **)(v2 + 48);
  if (v4)
  {
    *(void *)(v2 + 48) = 0;
    CFRelease(v4);
  }
}

dispatch_queue_t sub_100026814(uint64_t a1, char *label)
{
  dispatch_queue_t result = dispatch_queue_create(label, 0);
  *(void *)(*(void *)(a1 + 32) + 24) = result;
  return result;
}

dispatch_queue_t sub_100026848(uint64_t a1, char *label)
{
  dispatch_queue_t result = dispatch_queue_create(label, (dispatch_queue_attr_t)&_dispatch_queue_attr_concurrent);
  *(void *)(*(void *)(a1 + 32) + 32) = result;
  return result;
}

void sub_100026884(uint64_t a1, const void *a2)
{
  CFTypeID v4 = (os_unfair_lock_s *)(a1 + 148);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 148));
  int v5 = _Block_copy(a2);
  CFMutableArrayRef Mutable = *(__CFArray **)(a1 + 152);
  if (!Mutable)
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
    *(void *)(a1 + 152) = Mutable;
  }
  CFArrayAppendValue(Mutable, v5);
  _Block_release(v5);

  os_unfair_lock_unlock(v4);
}

uint64_t sub_100026908(uint64_t a1, const __CFString *cf, CFTypeRef *a3)
{
  CFStringRef v4 = cf;
  CFRetain(cf);
  if (!v4) {
    return 1;
  }
  LOBYTE(v6) = 1;
  do
  {
    CFStringRef v9 = 0;
    if (v6)
    {
      CFStringRef v6 = sub_1000111CC(a1, v4, &v9, a3);
      if (v6)
      {
        do
          int v7 = sub_1000269F8(a1, v6, (int)a3);
        while (v7 == 1);
        CFStringRef v6 = (sqlite3_stmt *)((v7 != 0) & sub_100011164(v6, a3));
      }
    }
    else
    {
      sub_1000263CC(1, a3, @"Error with unexecuted sql remaining %@", v4);
      CFStringRef v6 = 0;
    }
    CFRelease(v4);
    CFStringRef v4 = v9;
  }
  while (v9);
  return (uint64_t)v6;
}

uint64_t sub_1000269F8(uint64_t a1, sqlite3_stmt *pStmt, int a3)
{
  int v6 = 0;
  while (1)
  {
    if (*(unsigned char *)(a1 + 24) && !sqlite3_stmt_readonly(pStmt))
    {
      int v7 = sub_10000B070("SecError");
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v8 = sqlite3_sql(pStmt);
        *(_DWORD *)long long buf = 136315138;
        CFIndex v13 = v8;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "_SecDbStep: SecDbConnection is readonly but we're about to write: %s", buf, 0xCu);
      }
    }
    int v9 = sqlite3_step(pStmt);
    if (v9 == 100) {
      return 1;
    }
    if (v9 == 101) {
      break;
    }
    char v10 = sub_100026B54(a1, v9, (int)@"step", v6++, a3);
    if ((v10 & 1) == 0) {
      return 0;
    }
  }
  sqlite3_reset(pStmt);
  return 2;
}

BOOL sub_100026B54(uint64_t a1, uint64_t a2, uint64_t a3, int a4, CFTypeRef *a5)
{
  if (a2 - 5 > 1) {
    return sub_100026D0C(a1, a2, a5, @"%@", a3);
  }
  if (a4 > 4)
  {
    int v10 = 250;
    int v11 = 250 * a4 - 820;
  }
  else
  {
    int v10 = dword_100265604[a4];
    int v11 = dword_100265618[a4];
  }
  uint64_t v12 = sub_10000B070("#SecDB");
  BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG);
  if (v11 > 299999)
  {
    if (v13)
    {
      *(_DWORD *)long long buf = 67109120;
      int v16 = v11;
      _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "sqlite busy/locked: too long: %d ms, giving up", buf, 8u);
    }
    return sub_100026D0C(a1, a2, a5, @"%@", a3);
  }
  if (v13)
  {
    *(_DWORD *)long long buf = 67109632;
    int v16 = a2;
    __int16 v17 = 1024;
    int v18 = a4;
    __int16 v19 = 1024;
    int v20 = v11;
    _os_log_debug_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, "sqlite busy/locked: %d ntries: %d totaltimeout: %d", buf, 0x14u);
  }
  j__sqlite3_sleep(v10);
  return 1;
}

BOOL sub_100026D0C(uint64_t a1, uint64_t a2, CFTypeRef *a3, CFStringRef format, ...)
{
  va_start(va, format);
  if (!a2 || a2 == 101) {
    return !a2 || a2 == 101;
  }
  if (a3)
  {
    va_copy((va_list)buf, va);
    CFStringRef v7 = CFStringCreateWithFormatAndArguments(kCFAllocatorDefault, 0, format, va);
    sub_10002641C(a2, *(sqlite3 **)(a1 + 64), a3, @"%@", v7);
    CFRelease(v7);
  }
  *(unsigned char *)(a1 + 48) |= a2 == 10;
  if (*(unsigned char *)(a1 + 40))
  {
    uint64_t v8 = (__CFString *)CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"SQL DB %@ is corrupted already. Corruption error was: %d (previously %d)", format, *(void *)(*(void *)(a1 + 16) + 16), a2, *(unsigned int *)(a1 + 44));
    int v9 = sub_10000B070("SecError");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v8;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%@", (uint8_t *)&buf, 0xCu);
    }
    if (CFEqual(*(CFTypeRef *)(*(void *)(a1 + 16) + 16), @"/Library/Keychains/keychain-2.db"))
    {
      unsigned int v10 = 1405092101;
    }
    else if (CFEqual(*(CFTypeRef *)(*(void *)(a1 + 16) + 16), @"/Library/Keychains/ocspcache.sqlite3"))
    {
      unsigned int v10 = 1405092357;
    }
    else if (CFEqual(*(CFTypeRef *)(*(void *)(a1 + 16) + 16), @"/Library/Keychains/TrustStore.sqlite3"))
    {
      unsigned int v10 = 1405092613;
    }
    else if (CFEqual(*(CFTypeRef *)(*(void *)(a1 + 16) + 16), @"/Library/Keychains/caissuercache.sqlite3"))
    {
      unsigned int v10 = 1405092869;
    }
    else
    {
      unsigned int v10 = 1405091845;
    }
    sub_10002BBA0(v8, v10);
    if (v8) {
      CFRelease(v8);
    }
    if (a2 == 26 || a2 == 11)
    {
      CFIndex v31 = sub_10000B070("SecError");
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(buf) = 0;
        uint64_t v28 = "SecDbConnectionCheckCode detected corruption twice: going to handle corrupt DB";
        CFIndex v29 = v31;
        uint32_t v30 = 2;
        goto LABEL_49;
      }
      goto LABEL_50;
    }
    return !a2 || a2 == 101;
  }
  BOOL v11 = a2 == 11;
  if (a2 == 26) {
    BOOL v11 = 1;
  }
  *(unsigned char *)(a1 + 40) = v11;
  if (a2 != 26 && a2 != 11) {
    return !a2 || a2 == 101;
  }
  *(_DWORD *)(a1 + 44) = a2;
  uint64_t v42 = 0;
  CFRange v43 = &v42;
  uint64_t v44 = 0x2000000000;
  char v45 = 0;
  uint64_t v38 = 0;
  CFIndex v39 = &v38;
  uint64_t v40 = 0x2000000000;
  char v41 = 0;
  uint64_t v34 = 0;
  uint64_t v35 = &v34;
  uint64_t v36 = 0x2000000000;
  CFTypeRef v37 = 0;
  *(void *)&long long buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 0x40000000;
  uint64_t v49 = sub_1000273A4;
  uint64_t v50 = &unk_1002F7930;
  uint64_t v51 = &v34;
  unsigned int v52 = &v38;
  uint64_t v53 = &v42;
  uint64_t v54 = a1;
  sub_10002742C(a1, @"PRAGMA integrity_check", &v37, (uint64_t)&buf);
  if (!*((unsigned char *)v43 + 24))
  {
    uint64_t v12 = (__CFError *)v35[3];
    if (!v12)
    {
      *((unsigned char *)v39 + 24) = 1;
      __int16 v19 = sub_10000B070("#SecDB");
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_26;
      }
      *(_WORD *)uint64_t v46 = 0;
      int v16 = "#SecDB warning: failed to run integrity check due to corruption";
      __int16 v17 = v19;
      uint32_t v18 = 2;
      goto LABEL_58;
    }
    CFIndex Code = CFErrorGetCode(v12);
    if (Code == 26 || Code == 11) {
      *((unsigned char *)v39 + 24) = 1;
    }
    uint64_t v14 = sub_10000B070("#SecDB");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v15 = v35[3];
      *(_DWORD *)uint64_t v46 = 138543362;
      uint64_t v47 = v15;
      int v16 = "#SecDB warning error %{public}@ when running integrity check";
      __int16 v17 = v14;
      uint32_t v18 = 12;
LABEL_58:
      _os_log_debug_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEBUG, v16, v46, v18);
    }
  }
LABEL_26:
  if (*((unsigned char *)v39 + 24))
  {
    int v20 = *((unsigned __int8 *)v43 + 24);
    CFIndex v21 = sub_10000B070("SecError");
    BOOL v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
    if (v20)
    {
      if (v22)
      {
        *(_WORD *)uint64_t v46 = 0;
        uint64_t v23 = "SecDBCheckCorrupted ran integrity_check, and that didn't return ok";
LABEL_32:
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, v23, v46, 2u);
      }
    }
    else if (v22)
    {
      *(_WORD *)uint64_t v46 = 0;
      uint64_t v23 = "SecDBCheckCorrupted failed to run integrity check";
      goto LABEL_32;
    }
  }
  uint64_t v24 = (const void *)v35[3];
  if (v24)
  {
    v35[3] = 0;
    CFRelease(v24);
  }
  int v25 = *((unsigned __int8 *)v39 + 24);
  _Block_object_dispose(&v34, 8);
  _Block_object_dispose(&v38, 8);
  _Block_object_dispose(&v42, 8);
  *(unsigned char *)(a1 + 40) = v25;
  UniChar v26 = sub_10000B070("SecError");
  BOOL v27 = os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT);
  if (v25)
  {
    if (v27)
    {
      LODWORD(buf) = 67109120;
      DWORD1(buf) = a2;
      uint64_t v28 = "operation returned code: %d integrity check=fail";
      CFIndex v29 = v26;
      uint32_t v30 = 8;
LABEL_49:
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, v28, (uint8_t *)&buf, v30);
    }
LABEL_50:
    sub_100027270(a1, a2, a3);
    return !a2 || a2 == 101;
  }
  if (v27)
  {
    LODWORD(buf) = 67109120;
    DWORD1(buf) = a2;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "operation returned code: %d: integrity check=pass", (uint8_t *)&buf, 8u);
  }
  return !a2 || a2 == 101;
}

uint64_t sub_100027270(uint64_t a1, uint64_t __errnum, CFTypeRef *a3)
{
  uint64_t v3 = *(void *)(a1 + 16);
  if (*(unsigned char *)(v3 + 163))
  {
    CFStringRef v11 = *(const __CFString **)(v3 + 16);
    *(void *)long long buf = _NSConcreteStackBlock;
    uint64_t v14 = 0x40000000;
    uint64_t v15 = sub_10000B880;
    int v16 = &unk_1002F7408;
    __int16 v17 = &stru_1002F79E0;
    sub_10000EB80(v11, (uint64_t)buf);
    uint64_t v12 = sub_10000B070("SecWarning");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "SecDbHandleCorrupt: killing self so that successor might cleanly delete corrupt db", buf, 2u);
    }
    exit(1);
  }
  CFIndex v7 = (int)__errnum;
  uint64_t v8 = strerror(__errnum);
  sub_1000297A0(v7, kCFErrorDomainPOSIX, 0, a3, v9, @"SecDbHandleCorrupt not allowed to repair, handled error: [%d] %s", __errnum, v8);
  *(unsigned char *)(a1 + 40) = 0;
  return 0;
}

uint64_t sub_1000273A4(uint64_t a1, sqlite3_stmt *a2)
{
  uint64_t v2 = *(void *)(a1 + 56);
  uint64_t v3 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  v5[2] = sub_1000274A8;
  v5[3] = &unk_1002F7908;
  CFIndex v7 = a2;
  long long v6 = *(_OWORD *)(a1 + 40);
  return sub_1000275B0(v2, a2, v3, (uint64_t)v5);
}

uint64_t sub_10002742C(uint64_t a1, uint64_t a2, CFTypeRef *a3, uint64_t a4)
{
  uint64_t result = sub_1000111CC(a1, a2, 0, a3);
  if (result)
  {
    CFIndex v7 = (sqlite3_stmt *)result;
    (*(void (**)(uint64_t, uint64_t))(a4 + 16))(a4, result);
    return sub_100011164(v7, a3);
  }
  return result;
}

void sub_1000274A8(uint64_t a1)
{
  uint64_t v2 = sqlite3_column_text(*(sqlite3_stmt **)(a1 + 48), 0);
  uint64_t v3 = v2;
  if (!v2 || strncasecmp((const char *)v2, "ok", 3uLL))
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
    CFStringRef v4 = sub_10000B070("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = "NULL";
      if (v3) {
        int v5 = (const char *)v3;
      }
      int v6 = 136315138;
      CFIndex v7 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "SecDBCheckCorrupted integrity_check returned %s", (uint8_t *)&v6, 0xCu);
    }
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
}

uint64_t sub_1000275B0(uint64_t a1, sqlite3_stmt *pStmt, CFTypeRef *a3, uint64_t a4)
{
  while (1)
  {
    while (1)
    {
      uint64_t result = sub_1000269F8(a1, pStmt, (int)a3);
      if (result == 1) {
        break;
      }
      if (!result) {
        return result;
      }
      if (result == 2) {
        return 1;
      }
    }
    if (!a4) {
      break;
    }
    uint64_t v16 = 0;
    __int16 v17 = &v16;
    uint64_t v18 = 0x2000000000;
    char v19 = 0;
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 0x40000000;
    uint64_t v12 = sub_1000276F8;
    BOOL v13 = &unk_1002F7708;
    uint64_t v14 = a4;
    uint64_t v15 = &v16;
    uint64_t v9 = v11;
    v12((uint64_t)v9);

    LODWORD(v9) = *((unsigned __int8 *)v17 + 24);
    _Block_object_dispose(&v16, 8);
    if (v9) {
      return 1;
    }
  }
  sub_1000263CC(1, a3, @"SecDbStep SQLITE_ROW returned without a row handler");
  return 0;
}

uint64_t sub_1000276F8(uint64_t a1)
{
  return (*(uint64_t (**)(void, uint64_t))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(*(void *)(a1 + 40) + 8) + 24);
}

void sub_100027714(id a1, const char *a2)
{
  memset(__b, 170, sizeof(__b));
  snprintf(__b, 0x401uLL, "%s-iscorrupt", a2);
  memset(&v7, 0, sizeof(v7));
  if (!stat(__b, &v7))
  {
    uint64_t v3 = sub_10000B070("SecError");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)uint64_t v9 = __b;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "SecDbHandleCorrupt: Tried to write corruption marker %s but one already exists", buf, 0xCu);
    }
  }
  CFStringRef v4 = fopen(__b, "w");
  if (v4)
  {
    fclose(v4);
  }
  else
  {
    int v5 = sub_10000B070("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *__error();
      *(_DWORD *)long long buf = 67109378;
      *(_DWORD *)uint64_t v9 = v6;
      *(_WORD *)&v9[4] = 2082;
      *(void *)&void v9[6] = __b;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "SecDbHandleCorrupt: Unable (%{darwin.errno}d) to create corruption marker %{public}s", buf, 0x12u);
    }
  }
}

uint64_t sub_10002789C(uint64_t a1, const __CFString *a2, int a3)
{
  uint64_t v20 = 0;
  CFIndex v21 = &v20;
  uint64_t v22 = 0x2000000000;
  char v23 = 1;
  uint64_t v16 = 0;
  __int16 v17 = &v16;
  uint64_t v18 = 0x2000000000;
  int v19 = a3;
  uint64_t v12 = 0;
  BOOL v13 = &v12;
  uint64_t v14 = 0x2000000000;
  CFTypeRef v15 = 0;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  void v11[2] = sub_100027A48;
  v11[3] = &unk_1002F76E0;
  v11[4] = &v20;
  v11[5] = &v12;
  v11[6] = &v16;
  v11[7] = a1;
  char v4 = sub_100010DE0(a1, a2, &v15, (uint64_t)v11);
  if (*((unsigned char *)v21 + 24)) {
    char v5 = v4;
  }
  else {
    char v5 = 0;
  }
  *((unsigned char *)v21 + 24) = v5;
  if ((v5 & 1) == 0)
  {
    int v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = v13[3];
      *(_DWORD *)long long buf = 138412546;
      CFStringRef v25 = a2;
      __int16 v26 = 2112;
      uint64_t v27 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "SecDBGetInteger [%@] failed: %@", buf, 0x16u);
    }
  }
  uint64_t v8 = (const void *)v13[3];
  if (v8)
  {
    void v13[3] = 0;
    CFRelease(v8);
  }
  uint64_t v9 = *((unsigned int *)v17 + 6);
  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(&v20, 8);
  return v9;
}

uint64_t sub_100027A48(void *a1, sqlite3_stmt *a2)
{
  uint64_t v3 = a1[7];
  char v4 = (CFTypeRef *)(*(void *)(a1[5] + 8) + 24);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 0x40000000;
  _OWORD v9[2] = sub_100027AF0;
  v9[3] = &unk_1002F76B8;
  v9[4] = a1[6];
  v9[5] = a2;
  char v5 = sub_1000275B0(v3, a2, v4, (uint64_t)v9);
  uint64_t v6 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v6 + 24)) {
    char v7 = v5;
  }
  else {
    char v7 = 0;
  }
  *(unsigned char *)(v6 + 24) = v7;
  return 1;
}

uint64_t sub_100027AF0(uint64_t a1, unsigned char *a2)
{
  uint64_t result = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 40), 0);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  *a2 = 1;
  return result;
}

BOOL sub_100027B34(uint64_t a1, uint64_t a2, CFTypeRef *a3, uint64_t a4)
{
  char v13 = 1;
  if (*(unsigned char *)(a1 + 25))
  {
    (*(void (**)(uint64_t, char *))(a4 + 16))(a4, &v13);
    if (!v13)
    {
      char v5 = sub_10000B070("#SecDB");
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        *(_WORD *)long long buf = 0;
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "#SecDB nested transaction asked to not be committed", buf, 2u);
      }
    }
    BOOL v6 = 1;
  }
  else
  {
    CFStringRef v9 = @"BEGIN EXCLUSIVE";
    switch(a2)
    {
      case 2:
        goto LABEL_13;
      case 3:
        CFStringRef v9 = @"BEGIN";
        goto LABEL_13;
      case 4:
        *(void *)(a1 + 32) = 0;
        goto LABEL_13;
      case 5:
        uint64_t v10 = 3;
        goto LABEL_12;
      case 6:
        uint64_t v10 = 4;
LABEL_12:
        *(void *)(a1 + 32) = v10;
LABEL_13:
        if (sqlite3_get_autocommit(*(sqlite3 **)(a1 + 64)) && (sub_100026908(a1, v9, a3) & 1) == 0) {
          goto LABEL_17;
        }
        *(unsigned char *)(a1 + 25) = 1;
        (*(void (**)(uint64_t, char *))(a4 + 16))(a4, &v13);
        uint64_t v26 = 0;
        uint64_t v27 = &v26;
        uint64_t v28 = 0x2000000000;
        char v29 = 1;
        v24[0] = 0;
        v24[1] = v24;
        v24[2] = 0x2000000000;
        char v25 = 0;
        *(void *)long long buf = _NSConcreteStackBlock;
        uint64_t v16 = 0x40000000;
        __int16 v17 = sub_100027DD8;
        uint64_t v18 = &unk_1002F78B8;
        char v23 = v13;
        int v19 = v24;
        uint64_t v20 = &v26;
        uint64_t v21 = a1;
        uint64_t v22 = a3;
        if (*(unsigned char *)(a1 + 24))
        {
          sub_100027DD8((uint64_t)buf);
        }
        else
        {
          CFStringRef v11 = *(NSObject **)(*(void *)(a1 + 16) + 32);
          block[0] = _NSConcreteStackBlock;
          block[1] = 0x40000000;
          block[2] = sub_10002802C;
          block[3] = &unk_1002F78E0;
          block[4] = buf;
          dispatch_barrier_sync(v11, block);
        }
        BOOL v6 = *((unsigned char *)v27 + 24) != 0;
        _Block_object_dispose(v24, 8);
        _Block_object_dispose(&v26, 8);
        break;
      default:
        sub_1000263CC(1, a3, @"invalid transaction type %d", a2);
LABEL_17:
        BOOL v6 = 0;
        break;
    }
  }
  return v13 && v6;
}

void sub_100027DD8(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 64);
  uint64_t v3 = *(void *)(a1 + 48);
  if (v2)
  {
    if (!*(unsigned char *)(v3 + 24))
    {
      sub_10002803C(v3, 1);
      uint64_t v3 = *(void *)(a1 + 48);
    }
    char v4 = sub_100026908(v3, @"END", *(CFTypeRef **)(a1 + 56));
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v4;
  }
  else
  {
    char v5 = sub_100026908(v3, @"ROLLBACK", *(CFTypeRef **)(a1 + 56));
    char v4 = 0;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v5;
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v4;
  uint64_t v6 = *(void *)(a1 + 48);
  *(unsigned char *)(v6 + 25) = 0;
  if (!*(unsigned char *)(v6 + 24))
  {
    sub_10002803C(v6, 2 * *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
    uint64_t v6 = *(void *)(a1 + 48);
  }
  *(void *)(v6 + 32) = 1;
  if (*(unsigned char *)(a1 + 64))
  {
    if (*(unsigned char *)(*(void *)(v6 + 16) + 165))
    {
      if (!*(unsigned char *)(v6 + 24))
      {
        int v7 = sub_10002789C(v6, @"pragma page_count", -1);
        if (v7 >= 1)
        {
          int v8 = v7;
          int v9 = sub_10002789C(v6, @"pragma freelist_count", -1);
          if ((v9 & 0x80000000) == 0)
          {
            LODWORD(v10) = v9;
            double v11 = (double)(v8 - (uint64_t)v9) / (double)v8;
            if (v9 >> 13 || v11 <= 0.85)
            {
              if (v11 >= 0.4) {
                uint64_t v10 = (uint64_t)((double)v9 * 0.2);
              }
              sql = 0;
              asprintf(&sql, "pragma incremental_vacuum(%d)", v10);
              if (sql)
              {
                errmsg = 0;
                int v12 = sqlite3_exec(*(sqlite3 **)(v6 + 64), sql, 0, 0, &errmsg);
                if (v12)
                {
                  int v13 = v12;
                  uint64_t v14 = sub_10000B070("SecError");
                  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)long long buf = 67109378;
                    int v18 = v13;
                    __int16 v19 = 2082;
                    uint64_t v20 = errmsg;
                    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "incremental_vacuum failed with: (%d) %{public}s", buf, 0x12u);
                  }
                }
                sqlite3_free(errmsg);
                free(sql);
              }
            }
          }
        }
      }
    }
  }
}

uint64_t sub_10002802C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10002803C(uint64_t a1, uint64_t a2)
{
  char v4 = *(const void **)(a1 + 72);
  if (CFArrayGetCount((CFArrayRef)v4))
  {
    uint64_t v5 = *(void *)(a1 + 16);
    uint64_t v6 = (os_unfair_lock_s *)(v5 + 148);
    os_unfair_lock_lock((os_unfair_lock_t)(v5 + 148));
    CFArrayRef v7 = *(const __CFArray **)(v5 + 152);
    if (v7)
    {
      CFArrayRef Copy = CFArrayCreateCopy(kCFAllocatorDefault, v7);
      os_unfair_lock_unlock(v6);
      if (Copy)
      {
        *(void *)(a1 + 72) = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        context[0] = _NSConcreteStackBlock;
        context[1] = 0x40000000;
        context[2] = sub_100028194;
        context[3] = &unk_1002F7A28;
        context[4] = a1;
        void context[5] = a2;
        context[6] = v4;
        v11.size_t length = CFArrayGetCount(Copy);
        v11.location = 0;
        CFArrayApplyFunction(Copy, v11, (CFArrayApplierFunction)sub_1000281B4, context);
        if (v4) {
          CFRelease(v4);
        }
        CFRelease(Copy);
      }
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)(v5 + 148));
    }
  }
}

uint64_t sub_100028194(void *a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, void, void, void, void))(a2 + 16))(a2, a1[4], a1[5], *(void *)(a1[4] + 32), a1[6]);
}

uint64_t sub_1000281B4(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_1000281CC(uint64_t a1, char a2)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100028A28;
  block[3] = &unk_1002F7870;
  block[4] = &qword_10035CBF8;
  if (qword_10035CBF0 != -1) {
    dispatch_once(&qword_10035CBF0, block);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  uint64_t v5 = Instance;
  if (Instance)
  {
    *(void *)(Instance + 16) = a1;
    *(unsigned char *)(Instance + 24) = a2;
    *(unsigned char *)(Instance + 25) = 0;
    *(void *)(Instance + 32) = 2;
    *(unsigned char *)(Instance + 40) = 0;
    *(_DWORD *)(Instance + 44) = 0;
    *(unsigned char *)(Instance + 48) = 0;
    *(void *)(Instance + 56) = 0;
    *(void *)(Instance + 64) = 0;
    *(void *)(Instance + 72) = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  }
  return v5;
}

uint64_t sub_1000282E0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = 0;
  int v8 = &v7;
  uint64_t v9 = 0x2000000000;
  char v10 = 1;
  CFStringRef v3 = *(const __CFString **)(*(void *)(a1 + 16) + 16);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  v6[2] = sub_100028498;
  v6[3] = &unk_1002F7980;
  v6[4] = &v7;
  void v6[5] = a1;
  v6[6] = a2;
  v6[7] = a3;
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 0x40000000;
  void v11[2] = sub_10000B880;
  v11[3] = &unk_1002F7408;
  v11[4] = v6;
  sub_10000EB80(v3, (uint64_t)v11);
  uint64_t v4 = *((unsigned __int8 *)v8 + 24);
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_1000283D8(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) + 16);
  if (*(unsigned char *)(v1 + 144))
  {
    *(unsigned char *)(v1 + 144) = 0;
    if (((*(uint64_t (**)(void))(*(void *)(*(void *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)
                                                       + 16)
                                           + 136)
                               + 16))() & 1) == 0)
    {
      uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8);
      uint64_t v4 = *(unsigned char **)(v3 + 24);
      if (!v4[40]
        || (sub_100027270((uint64_t)v4, 0, *(CFTypeRef **)(a1 + 48)) & 1) == 0
        && (uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8), (v4 = *(unsigned char **)(v3 + 24)) != 0))
      {
        *(void *)(v3 + 24) = 0;
        CFRelease(v4);
      }
    }
  }
}

void sub_100028498(uint64_t a1, char *filename)
{
  uint64_t v4 = *(void *)(a1 + 40);
  if (*(unsigned char *)(*(void *)(v4 + 16) + 162))
  {
    if (*(unsigned char *)(v4 + 24)) {
      uint64_t v5 = 4194305;
    }
    else {
      uint64_t v5 = 4194306;
    }
  }
  else
  {
    uint64_t v5 = 4194305;
  }
  if (*(void *)(a1 + 48)) {
    BOOL v6 = sub_1000286D4(v4, filename, v5, 0);
  }
  else {
    BOOL v6 = 0;
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v6;
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
  if (!*(unsigned char *)(v7 + 24))
  {
    *(unsigned char *)(v7 + 24) = 1;
    if (*(void *)(a1 + 48))
    {
      CFRange v11 = dirname(filename);
      if (v11)
      {
        int v12 = v11;
        unsigned int v13 = *(unsigned __int16 *)(*(void *)(*(void *)(a1 + 40) + 16) + 160);
        uint64_t v14 = mkpath_np(v11, (v13 >> 2) & 0x49 | v13);
        if (v14 && v14 != 17)
        {
          uint64_t v16 = v14;
          CFIndex v17 = (int)v14;
          int v18 = *(CFTypeRef **)(a1 + 56);
          __int16 v19 = strerror(v14);
          sub_1000297A0(v17, kCFErrorDomainPOSIX, 0, v18, v20, @"mkpath_np %s: [%d] %s", v12, v16, v19);
          *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
        }
      }
    }
    uint64_t v21 = *(void *)(*(void *)(a1 + 32) + 8);
    if (*(unsigned char *)(v21 + 24))
    {
      BOOL v22 = sub_1000286D4(*(void *)(a1 + 40), filename, 4194310, *(CFTypeRef **)(a1 + 56));
      uint64_t v21 = *(void *)(*(void *)(a1 + 32) + 8);
    }
    else
    {
      BOOL v22 = 0;
    }
    *(unsigned char *)(v21 + 24) = v22;
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
    {
      chmod(filename, *(_WORD *)(*(void *)(*(void *)(a1 + 40) + 16) + 160));
      char v23 = *(unsigned char **)(a1 + 48);
      if (v23) {
        unsigned char *v23 = 1;
      }
    }
  }
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    if (qword_10035CC00 != -1) {
      dispatch_once(&qword_10035CC00, &stru_1002F79C0);
    }
    unsigned int v8 = dword_10035CC08;
    if (dword_10035CC08)
    {
      uint64_t v9 = *(void **)(a1 + 40);
      char v10 = (sqlite3 *)v9[8];
      sqlite3_trace_v2(v10, v8, (int (__cdecl *)(unsigned int, void *, void *, void *))sub_10002885C, v9);
    }
  }
}

BOOL sub_1000286D4(uint64_t a1, char *filename, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v8 = *(void *)(a1 + 16);
  int v9 = *(unsigned __int8 *)(v8 + 164);
  int v10 = *(unsigned __int8 *)(v8 + 165);
  ppDb = 0;
  uint64_t v11 = sqlite3_open_v2(filename, &ppDb, a3, 0);
  if (v11)
  {
    if (ppDb)
    {
      sub_10002641C(v11, ppDb, a4, @"open_v2 \"%s\" 0x%X", filename, a3);
      sqlite3_close(ppDb);
      ppDb = 0;
    }
    else
    {
      sub_1000263CC(v11, a4, @"open_v2 \"%s\" 0x%X", filename, a3);
    }
    goto LABEL_16;
  }
  if ((a3 & 2) == 0) {
    goto LABEL_16;
  }
  if (v10)
  {
    ppStmt = 0;
    if (!sqlite3_prepare_v2(ppDb, "PRAGMA auto_vacuum", -1, &ppStmt, 0))
    {
      if (sqlite3_step(ppStmt) == 100)
      {
        int v12 = sqlite3_column_int(ppStmt, 0);
        sqlite3_finalize(ppStmt);
        if (v12 == 2) {
          goto LABEL_13;
        }
      }
      else
      {
        sqlite3_finalize(ppStmt);
      }
    }
    sqlite3_exec(ppDb, "PRAGMA auto_vacuum = incremental", 0, 0, 0);
    sqlite3_exec(ppDb, "VACUUM", 0, 0, 0);
  }
LABEL_13:
  if (v9) {
    sqlite3_exec(ppDb, "PRAGMA journal_mode = WAL", 0, 0, 0);
  }
  sqlite3_busy_timeout(ppDb, 5000);
LABEL_16:
  unsigned int v13 = ppDb;
  *(void *)(a1 + 64) = ppDb;
  return v13 != 0;
}

uint64_t sub_10002885C()
{
  return 0;
}

void sub_100028864(id a1)
{
  if (sub_10002894C()) {
    dword_10035CC08 = 2;
  }
  if (sub_10002894C()) {
    dword_10035CC08 = 1;
  }
  if (sub_10002894C()) {
    dword_10035CC08 = 4;
  }
  uint64_t v1 = sub_10000B070("#SecDB");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
  {
    v2[0] = 67109120;
    v2[1] = dword_10035CC08;
    _os_log_debug_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEBUG, "sqlDb: sql trace mask: 0x%08x", (uint8_t *)v2, 8u);
  }
}

uint64_t sub_10002894C()
{
  if (!csr_check())
  {
    CFBooleanRef v1 = (const __CFBoolean *)CFPreferencesCopyValue(@"SQLProfile", @"com.apple.security", kCFPreferencesAnyUser, kCFPreferencesAnyHost);
    if (v1)
    {
      CFBooleanRef v2 = v1;
      CFTypeID v3 = CFGetTypeID(v1);
      if (v3 == CFBooleanGetTypeID())
      {
        BOOL v4 = CFBooleanGetValue(v2) == 0;
      }
      else
      {
        CFTypeID v5 = CFGetTypeID(v2);
        if (v5 != CFNumberGetTypeID())
        {
          uint64_t v0 = 0;
LABEL_12:
          CFRelease(v2);
          return v0;
        }
        int valuePtr = 0;
        CFNumberGetValue(v2, kCFNumberSInt32Type, &valuePtr);
        BOOL v4 = valuePtr == 0;
      }
      uint64_t v0 = !v4;
      goto LABEL_12;
    }
  }
  return 0;
}

uint64_t sub_100028A28(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

CFStringRef sub_100028A5C(uint64_t a1)
{
  sub_100025824();
  CFBooleanRef v2 = "ro";
  if (!*(unsigned char *)(a1 + 24)) {
    CFBooleanRef v2 = "rw";
  }
  if (*(void *)(a1 + 64)) {
    CFTypeID v3 = "open";
  }
  else {
    CFTypeID v3 = "closed";
  }
  return CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"<SecDbConnection %s %s>", v2, v3);
}

CFStringRef sub_100028AE0(uint64_t a1)
{
  CFBooleanRef v1 = "ro";
  if (!*(unsigned char *)(a1 + 24)) {
    CFBooleanRef v1 = "rw";
  }
  if (*(void *)(a1 + 64)) {
    CFBooleanRef v2 = "open";
  }
  else {
    CFBooleanRef v2 = "closed";
  }
  return CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"<SecDbConnection %s %s>", v1, v2);
}

void sub_100028B58(uint64_t a1)
{
  CFBooleanRef v2 = *(sqlite3 **)(a1 + 64);
  if (v2 && (int v3 = sqlite3_close(v2)) != 0)
  {
    int v9 = v3;
    BOOL v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(*(void *)(a1 + 16) + 16);
      uint64_t v8 = sqlite3_errmsg(*(sqlite3 **)(a1 + 64));
      *(_DWORD *)long long buf = 67109634;
      int v11 = v9;
      __int16 v12 = 2112;
      uint64_t v13 = v7;
      __int16 v14 = 2080;
      CFTypeRef v15 = v8;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "failed to close database connection (%d) for %@: %s", buf, 0x1Cu);
    }
    _os_assert_log();
    _os_crash();
    __break(1u);
  }
  else
  {
    *(void *)(a1 + 16) = 0;
    BOOL v4 = *(const void **)(a1 + 72);
    if (v4)
    {
      *(void *)(a1 + 72) = 0;
      CFRelease(v4);
    }
    CFTypeID v5 = *(const void **)(a1 + 56);
    if (v5)
    {
      *(void *)(a1 + 56) = 0;
      CFRelease(v5);
    }
  }
}

void sub_100028CB0(uint64_t a1, const std::__fs::filesystem::path *a2)
{
  memset(__b, 170, sizeof(__b));
  snprintf(__b, 0x401uLL, "%s-iscorrupt", (const char *)a2);
  memset(&v20, 0, sizeof(v20));
  if (!stat(__b, &v20))
  {
    int v9 = sub_10000B070("SecWarning");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      *(void *)BOOL v22 = __b;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "SecDbSecDbProcessCorruptionMarker: found corruption marker %s", buf, 0xCu);
    }
    if (remove((const std::__fs::filesystem::path *)__b, v10))
    {
      __int16 v12 = sub_10000B070("SecError");
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        int v13 = *__error();
        *(_DWORD *)long long buf = 67109120;
        *(_DWORD *)BOOL v22 = v13;
        __int16 v14 = "SecDbSecDbProcessCorruptionMarker: Unable (%{darwin.errno}d) to delete corruption marker";
        CFTypeRef v15 = v12;
        uint32_t v16 = 8;
LABEL_10:
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, v14, buf, v16);
      }
    }
    else
    {
      if (!remove(a2, v11) || *__error() == 2)
      {
        CFIndex v17 = sub_10000B070("SecWarning");
        if (!os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)BOOL v22 = a2;
        BOOL v6 = "SecDbSecDbProcessCorruptionMarker: deleted corrupt db %{public}s";
        uint64_t v7 = v17;
        uint32_t v8 = 12;
        goto LABEL_16;
      }
      int v18 = sub_10000B070("SecError");
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        int v19 = *__error();
        *(_DWORD *)long long buf = 67109378;
        *(_DWORD *)BOOL v22 = v19;
        *(_WORD *)&v22[4] = 2082;
        *(void *)&v22[6] = a2;
        __int16 v14 = "SecDbSecDbProcessCorruptionMarker: Unable (%{darwin.errno}d) to delete db %{public}s";
        CFTypeRef v15 = v18;
        uint32_t v16 = 18;
        goto LABEL_10;
      }
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
    return;
  }
  if (*__error() != 2)
  {
    BOOL v4 = sub_10000B070("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *__error();
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)BOOL v22 = v5;
      BOOL v6 = "SecDbSecDbProcessCorruptionMarker: Unable to check for corruption marker: %{darwin.errno}d";
      uint64_t v7 = v4;
      uint32_t v8 = 8;
LABEL_16:
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v6, buf, v8);
    }
  }
}

uint64_t sub_100028F6C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

BOOL sub_100028F7C(sqlite3_stmt *a1, uint64_t a2, CFTypeRef *a3, double a4)
{
  uint64_t v7 = sqlite3_bind_double(a1, a2, a4);
  return sub_10000ED34(v7, a1, a3, @"bind_double[%d]", a2);
}

BOOL sub_100028FD0(sqlite3_stmt *a1, uint64_t a2, int a3, CFTypeRef *a4)
{
  uint64_t v7 = sqlite3_bind_int(a1, a2, a3);
  return sub_10000ED34(v7, a1, a4, @"bind_int[%d]", a2);
}

void sub_100029024(uint64_t a1, uint64_t a2, CFArrayRef a3)
{
  uint64_t v6 = *(void *)(a1 + 16);
  uint64_t v7 = (os_unfair_lock_s *)(v6 + 148);
  os_unfair_lock_lock((os_unfair_lock_t)(v6 + 148));
  uint64_t v8 = *(void *)(v6 + 152);
  os_unfair_lock_unlock(v7);
  if (!v8) {
    return;
  }
  if (a2 && a3)
  {
    *(void *)&long long v12 = a2;
    *((void *)&v12 + 1) = a3;
    CFAllocatorRef v9 = kCFAllocatorDefault;
    CFIndex v10 = 2;
  }
  else
  {
    if (!a2)
    {
      if (!a3) {
        return;
      }
      CFRetain(a3);
      goto LABEL_8;
    }
    *(void *)&long long v12 = a2;
    CFAllocatorRef v9 = kCFAllocatorDefault;
    CFIndex v10 = 1;
  }
  a3 = CFArrayCreate(v9, (const void **)&v12, v10, &kCFTypeArrayCallBacks);
  if (!a3) {
    return;
  }
LABEL_8:
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 72), a3);
  CFRelease(a3);
  if (!*(unsigned char *)(a1 + 25))
  {
    int v11 = sub_10000B070("SecError");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v12) = 138412290;
      *(void *)((char *)&v12 + 4) = a1;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "db %@ changed outside txn", (uint8_t *)&v12, 0xCu);
    }
    sub_10002803C(a1, 2);
  }
}

CFTypeID sub_100029198(const __CFArray *a1, CFTypeID *a2, const __CFArray **a3)
{
  CFArrayRef v5 = a1;
  CFTypeID v6 = CFGetTypeID(a1);
  CFTypeID result = CFArrayGetTypeID();
  if (v6 == result)
  {
    CFTypeID result = CFArrayGetCount(v5);
    if (result == 2)
    {
      if (a2)
      {
        CFTypeID result = (CFTypeID)CFArrayGetValueAtIndex(v5, 0);
        *a2 = result;
      }
      if (a3)
      {
        CFTypeID result = (CFTypeID)CFArrayGetValueAtIndex(v5, 1);
        CFArrayRef v5 = (const __CFArray *)result;
LABEL_18:
        *a3 = v5;
      }
    }
    else
    {
      if (result == 1)
      {
        if (a2)
        {
          CFTypeID result = (CFTypeID)CFArrayGetValueAtIndex(v5, 0);
          *a2 = result;
        }
      }
      else if (a2)
      {
        *a2 = 0;
      }
      if (a3)
      {
        CFArrayRef v5 = 0;
        goto LABEL_18;
      }
    }
  }
  else
  {
    if (a2) {
      *a2 = 0;
    }
    if (a3) {
      goto LABEL_18;
    }
  }
  return result;
}

BOOL sub_10002925C()
{
  uint64_t v0 = @"SecItem";
  BOOL v1 = sub_1000292C4() && off_10035CC10(77, @"SecItem") != 0;

  return v1;
}

BOOL sub_1000292C4()
{
  if (qword_10035CC28 != -1) {
    dispatch_once(&qword_10035CC28, &stru_1002F7A48);
  }
  dispatch_source_merge_data((dispatch_source_t)qword_10035CC30, 1uLL);
  return qword_10035CC38 != 0;
}

void sub_100029320(id a1)
{
  BOOL v1 = sub_100029A10("PowerLog enabled", 86400);
  CFBooleanRef v2 = (void *)qword_10035CC30;
  qword_10035CC30 = (uint64_t)v1;

  int v3 = qword_10035CC30;
  context = dispatch_get_context((dispatch_object_t)qword_10035CC30);
  context[2] = _Block_copy(&stru_1002F7A68);
  dispatch_activate(v3);
  CFArrayRef v5 = sub_10000B070("PLsetup");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CFAllocatorRef v9 = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Setting up PowerLog", v9, 2u);
  }

  CFURLRef v6 = CFURLCreateWithFileSystemPath(kCFAllocatorDefault, @"/System/Library/PrivateFrameworks/PowerLog.framework", kCFURLPOSIXPathStyle, 1u);
  if (v6)
  {
    CFURLRef v7 = v6;
    qword_10035CC38 = (uint64_t)CFBundleCreate(kCFAllocatorDefault, v6);
    CFRelease(v7);
    if (qword_10035CC38)
    {
      off_10035CC10 = (uint64_t (*)(void, void))CFBundleGetFunctionPointerForName((CFBundleRef)qword_10035CC38, @"PLShouldLogRegisteredEvent");
      off_10035CC18 = (uint64_t (*)(void, void, void, void))CFBundleGetFunctionPointerForName((CFBundleRef)qword_10035CC38, @"PLLogRegisteredEvent");
      FunctionPointerForName = CFBundleGetFunctionPointerForName((CFBundleRef)qword_10035CC38, @"PLLogTimeSensitiveRegisteredEvent");
      qword_10035CC20 = (uint64_t)FunctionPointerForName;
      if (!off_10035CC10 || !off_10035CC18 || !FunctionPointerForName)
      {
        CFRelease((CFTypeRef)qword_10035CC38);
        qword_10035CC38 = 0;
      }
    }
  }
}

void sub_100029498(id a1)
{
  BOOL v1 = sub_10000B070("PLsetup");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    if (qword_10035CC38) {
      CFBooleanRef v2 = "enabled";
    }
    else {
      CFBooleanRef v2 = "fault";
    }
    int v3 = 136315138;
    BOOL v4 = v2;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "PowerLog %s", (uint8_t *)&v3, 0xCu);
  }
}

void sub_100029560(void *a1, void *a2)
{
  id v4 = a1;
  id v3 = a2;
  if (sub_1000292C4()) {
    off_10035CC18(77, v4, v3, 0);
  }
}

uint64_t sub_1000295D4(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  uint64_t result = ccder_decode_tl();
  if (result) {
    return 0;
  }
  return result;
}

BOOL sub_100029664(int a1, CFTypeRef *a2, CFStringRef format, ...)
{
  va_start(va, format);
  if (a1 && a2)
  {
    CFArrayRef v5 = (__CFString *)*a2;
    *a2 = 0;
    sub_100012AD4(a1, kCFErrorDomainMach, v5, a2, format, va);
  }
  return a1 == 0;
}

BOOL sub_1000296CC(int a1, CFTypeRef *a2, const __CFString *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  if (a1)
  {
    if (a2)
    {
      CFIndex v12 = *__error();
      int v13 = (__CFString *)*a2;
      *a2 = 0;
      CFStringRef v14 = CFStringCreateWithFormatAndArguments(kCFAllocatorDefault, 0, a3, &a9);
      CFTypeRef v15 = strerror(v12);
      sub_1000297A0(v12, kCFErrorDomainPOSIX, v13, a2, v16, @"%@: [%d] %s", v14, v12, v15, &a9);
      if (v14) {
        CFRelease(v14);
      }
    }
  }
  return a1 == 0;
}

void sub_1000297A0(CFIndex a1, const __CFString *a2, __CFString *a3, CFTypeRef *a4, uint64_t a5, CFStringRef format, ...)
{
  va_start(va, format);
  sub_100012AD4(a1, a2, a3, a4, format, va);
}

uint64_t sub_1000297D0(uint64_t a1, CFTypeRef *a2, CFStringRef format, ...)
{
  va_start(va, format);
  if (a2 && (a1 & 1) == 0)
  {
    CFArrayRef v5 = (__CFString *)*a2;
    *a2 = 0;
    sub_100012AD4(-50, kCFErrorDomainOSStatus, v5, a2, format, va);
  }
  return a1;
}

BOOL sub_100029834(uint64_t a1, CFTypeRef *a2, CFStringRef format, ...)
{
  va_start(va, format);
  if (!a1 && a2)
  {
    CFArrayRef v5 = (__CFString *)*a2;
    *a2 = 0;
    sub_100012AD4(-108, kCFErrorDomainOSStatus, v5, a2, format, va);
  }
  return a1 != 0;
}

__CFData *sub_1000298CC(const __CFString *a1, CFTypeRef *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  CFIndex v7 = sub_10000FE8C(a1, a2, a3, a4, a5);
  CFMutableArrayRef Mutable = CFDataCreateMutable(0, v7);
  CFDataSetLength(Mutable, v7);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  if (!sub_10000F7B0(a1, a2, 0, MutableBytePtr, (unint64_t)&MutableBytePtr[v7]) && Mutable)
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

void sub_100029950(uint64_t a1)
{
  dispatch_release(*(dispatch_object_t *)a1);
  CFBooleanRef v2 = *(const void **)(a1 + 16);
  if (v2) {
    _Block_release(v2);
  }

  free((void *)a1);
}

void sub_100029998(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2) {
    (*(void (**)(void))(v2 + 16))();
  }
  dispatch_suspend(*(dispatch_object_t *)(a1 + 8));
  dispatch_time_t v3 = dispatch_time(0, 1000000000 * *(void *)(a1 + 24));
  id v4 = *(NSObject **)a1;
  CFArrayRef v5 = *(void **)(a1 + 8);

  dispatch_after_f(v3, v4, v5, (dispatch_function_t)&_dispatch_resume);
}

NSObject *sub_100029A10(const char *a1, uint64_t a2)
{
  dispatch_time_t v3 = dispatch_queue_create(a1, 0);
  id v4 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_data_add, 0, 0, v3);
  CFArrayRef v5 = malloc_type_malloc(0x20uLL, 0x10A0040A7A12BA5uLL);
  *CFArrayRef v5 = v3;
  v5[1] = v4;
  v5[2] = 0;
  v5[3] = a2;
  dispatch_set_context(v4, v5);
  dispatch_source_set_event_handler_f(v4, (dispatch_function_t)sub_100029998);
  dispatch_set_finalizer_f(v4, (dispatch_function_t)sub_100029950);
  return v4;
}

unint64_t sub_100029AC0(const __CFAllocator *a1, CFMutableArrayRef *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5)
{
  if (!a4)
  {
    sub_1000297A0(-6, @"com.apple.security.cfder.error", 0, a3, a5, @"null input");
    return 0;
  }
  int v7 = (int)a1;
  CFMutableArrayRef Mutable = CFArrayCreateMutable(a1, 0, &kCFTypeArrayCallBacks);
  unint64_t v16 = 0xAAAAAAAAAAAAAAAALL;
  uint64_t v9 = ccder_decode_sequence_tl();
  if (!v9)
  {
    sub_1000297A0(-1, @"com.apple.security.cfder.error", 0, a3, v10, @"tag/length decode failed");
LABEL_11:
    if (Mutable) {
      CFRelease(Mutable);
    }
    return 0;
  }
  unint64_t v11 = v9;
  while (v11 < v16)
  {
    xpc_object_t value = 0;
    uint64_t v12 = sub_10000F124(v7, (int)&value, (int)a3);
    if (!v12) {
      goto LABEL_11;
    }
    unint64_t v11 = v12;
    int v13 = value;
    CFArrayAppendValue(Mutable, value);
    if (v13) {
      CFRelease(v13);
    }
  }
  *a2 = Mutable;
  return v11;
}

__CFData *sub_100029BEC(const __CFAllocator *a1, CFIndex *a2)
{
  CFMutableArrayRef Mutable = CFDataCreateMutable(a1, *a2);
  CFDataSetLength(Mutable, *a2);
  CFDataGetMutableBytePtr(Mutable);
  ccdigest();
  return Mutable;
}

__CFData *sub_100029C50(const __CFData *a1)
{
  CFDataGetLength(a1);
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFDataGetBytePtr(a1);
  dispatch_time_t v3 = (CFIndex *)ccsha1_di();

  return sub_100029BEC(v2, v3);
}

__CFData *sub_100029CBC(const __CFData *a1)
{
  CFDataGetLength(a1);
  CFAllocatorRef v2 = CFGetAllocator(a1);
  CFDataGetBytePtr(a1);
  dispatch_time_t v3 = (CFIndex *)ccsha256_di();

  return sub_100029BEC(v2, v3);
}

void sub_100029EC0(uint64_t a1, void *a2)
{
  id v7 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v3 = v7;
  }
  else
  {
    id v3 = [v7 description];
  }
  id v4 = v3;
  unint64_t v5 = *(void *)(a1 + 40);
  if (v5 && v5 < (unint64_t)[v3 length])
  {
    uint64_t v6 = [v4 substringToIndex:*(void *)(a1 + 40)];

    id v4 = (void *)v6;
  }
  [*(id *)(a1 + 32) insertObject:v4 atIndex:0];
}

void sub_10002A064(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_10002A07C(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  id result = [*(id *)(a1 + 32) containsObject:a2];
  if ((result & 1) == 0)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
    *a3 = 1;
  }
  return result;
}

void sub_10002A218(uint64_t a1, void *a2, void *a3)
{
  unint64_t v5 = *(void **)(a1 + 32);
  id v6 = a3;
  id v7 = [a2 stringByAppendingString:@":"];
  [v5 addObject:v7];

  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();
  uint64_t v9 = *(void **)(a1 + 32);
  if (isKindOfClass) {
    [v6 componentsJoinedByString:@" "];
  }
  else {
  id v10 = +[NSString stringWithFormat:@"%@", v6];
  }

  [v9 addObject:v10];
}

uint64_t sub_10002A544(CFNullRef *a1, CFTypeRef *a2)
{
  uint64_t result = ccder_decode_tl();
  if (result)
  {
    *a1 = kCFNull;
  }
  else
  {
    sub_1000297A0(-1, @"com.apple.security.cfder.error", 0, a2, v5, @"Unknown null encoding");
    return 0;
  }
  return result;
}

uint64_t sub_10002A5C4(CFTypeRef *a1)
{
  uint64_t v3 = ccder_encode_tl();
  if (!v3) {
    sub_1000297A0(-7, @"com.apple.security.cfder.error", 0, a1, v2, @"ccder failed to encode");
  }
  return v3;
}

uint64_t sub_10002A624(const __CFAllocator *a1, CFTypeRef *a2, CFTypeRef *a3, uint64_t a4, uint64_t a5)
{
  if (a4)
  {
    uint64_t v13 = 0;
    uint64_t v9 = ccder_decode_constructed_tl();
    if (v9)
    {
      CFMutableSetRef Mutable = CFSetCreateMutable(a1, 0, &kCFTypeSetCallBacks);
      if (Mutable)
      {
        CFRelease(Mutable);
      }
      else
      {
        sub_1000297A0(-3, @"com.apple.security.cfder.error", 0, a3, v10, @"Failed to create set");
        uint64_t v9 = 0;
        if (*a2) {
          CFRelease(*a2);
        }
        *a2 = Mutable;
      }
    }
    else
    {
      sub_1000297A0(-1, @"com.apple.security.cfder.error", 0, a3, v8, @"Unknown data encoding, expected CCDER_CONSTRUCTED_CFSET");
    }
  }
  else
  {
    sub_1000297A0(-6, @"com.apple.security.cfder.error", 0, a3, a5, @"null input");
    return 0;
  }
  return v9;
}

uint64_t sub_10002A7A0(const __CFSet *a1, uint64_t a2)
{
  long long v3 = xmmword_100265540;
  LOBYTE(v3) = 1;
  uint64_t v4 = a2;
  CFSetApplyFunction(a1, (CFSetApplierFunction)sub_10002A80C, &v3);
  if ((_BYTE)v3) {
    return ccder_sizeof();
  }
  else {
    return 0;
  }
}

uint64_t sub_10002A80C(uint64_t result, uint64_t a2)
{
  if (*(unsigned char *)a2)
  {
    uint64_t result = sub_10000FE8C(result, *(void *)(a2 + 16));
    if (result) {
      *(void *)(a2 + 8) += result;
    }
    else {
      *(unsigned char *)a2 = 0;
    }
  }
  return result;
}

uint64_t sub_10002A854(const __CFSet *a1, CFTypeRef *a2, char a3)
{
  CFMutableArrayRef Mutable = CFArrayCreateMutable(0, 0, &kCFTypeArrayCallBacks);
  v12[0] = 0xAAAAAAAAAAAAAA01;
  v12[1] = a2;
  BYTE1(v12[0]) = a3;
  int v12[2] = Mutable;
  v12[3] = 0;
  CFSetApplyFunction(a1, (CFSetApplierFunction)sub_10002AAA4, v12);
  if (!LOBYTE(v12[0]))
  {
    if (Mutable) {
      CFRelease(Mutable);
    }
    return 0;
  }
  v13.size_t length = CFArrayGetCount(Mutable);
  v13.location = 0;
  CFArraySortValues(Mutable, v13, (CFComparatorFunction)sub_10002A9DC, 0);
  CFIndex Count = CFArrayGetCount(Mutable);
  if (Count >= 1)
  {
    unint64_t v8 = Count + 1;
    do
    {
      CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex(Mutable, v8 - 2);
      CFDataGetLength(ValueAtIndex);
      CFDataGetBytePtr(ValueAtIndex);
      ccder_encode_body();
      --v8;
    }
    while (v8 > 1);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  uint64_t result = ccder_encode_constructed_tl();
  if (!result)
  {
    sub_1000297A0(-7, @"com.apple.security.cfder.error", 0, a2, v11, @"ccder failed to encode");
    return 0;
  }
  return result;
}

uint64_t sub_10002A9DC(const __CFData *a1, const __CFData *a2)
{
  CFIndex Length = CFDataGetLength(a1);
  CFIndex v5 = CFDataGetLength(a2);
  unint64_t v6 = v5;
  if (Length < 0 || v5 < 0)
  {
    if (Length >= v5) {
      uint64_t v12 = 0;
    }
    else {
      uint64_t v12 = -1;
    }
    if (Length <= v5) {
      return v12;
    }
    else {
      return 1;
    }
  }
  else
  {
    if (Length >= v5) {
      size_t v7 = v5;
    }
    else {
      size_t v7 = Length;
    }
    BytePtr = CFDataGetBytePtr(a1);
    uint64_t v9 = CFDataGetBytePtr(a2);
    int v10 = memcmp(BytePtr, v9, v7);
    if (v10 <= 0 && (v10 || Length <= v6))
    {
      LODWORD(v13) = v10 == 0;
      if (Length >= v6) {
        LODWORD(v13) = 0;
      }
      if (v10 < 0) {
        uint64_t v13 = 1;
      }
      else {
        uint64_t v13 = v13;
      }
      return v13 << 63 >> 63;
    }
    else
    {
      return 1;
    }
  }
}

void sub_10002AAA4(const __CFString *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (*(unsigned char *)a2)
  {
    CFIndex v7 = sub_10000FE8C(a1, *(CFTypeRef **)(a2 + 8), a3, a4, a5);
    if (!v7)
    {
      *(unsigned char *)a2 = 0;
      return;
    }
    CFIndex v8 = v7;
    CFMutableArrayRef Mutable = CFDataCreateMutable(*(CFAllocatorRef *)(a2 + 24), v7);
    CFDataSetLength(Mutable, v8);
    MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
    uint64_t v11 = sub_10000F7B0(a1, *(void *)(a2 + 8), *(unsigned __int8 *)(a2 + 1), MutableBytePtr, &MutableBytePtr[v8]);
    if (v11)
    {
      v13.size_t length = v11 - (void)MutableBytePtr;
      v13.location = 0;
      CFDataDeleteBytes(Mutable, v13);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 16), Mutable);
      if (!Mutable) {
        return;
      }
    }
    else
    {
      *(unsigned char *)a2 = 0;
      if (!Mutable) {
        return;
      }
    }
    CFRelease(Mutable);
  }
}

uint64_t sub_10002AB8C()
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_10002AC24;
  block[3] = &unk_1002F7B00;
  block[4] = &qword_10035CC48;
  if (qword_10035CC40 != -1) {
    dispatch_once(&qword_10035CC40, block);
  }
  return qword_10035CC48;
}

dispatch_queue_t sub_10002AC24(uint64_t a1)
{
  dispatch_queue_t result = dispatch_queue_create("AKS Lock Assertion Queue", 0);
  **(void **)(a1 + 32) = result;
  return result;
}

BOOL sub_10002AC5C(int a1, CFTypeRef *a2)
{
  uint64_t v9 = 0;
  int v10 = &v9;
  uint64_t v11 = 0x2000000000;
  int v12 = 0;
  uint64_t v4 = sub_10002AB8C();
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_10002AD30;
  block[3] = &unk_1002F7B28;
  block[4] = &v9;
  void block[5] = 60;
  int v8 = a1;
  dispatch_sync(v4, block);
  BOOL v5 = sub_100029664(*((_DWORD *)v10 + 6), a2, @"Kern return error");
  _Block_object_dispose(&v9, 8);
  return v5;
}

uint64_t sub_10002AD30(uint64_t result)
{
  uint64_t v1 = result;
  if (!dword_10035CC50)
  {
    uint64_t v2 = sub_10000B070("lockassertions");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v3 = *(void *)(v1 + 40);
      int v4 = 134217984;
      uint64_t v5 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Requesting lock assertion for %lld seconds", (uint8_t *)&v4, 0xCu);
    }
    dispatch_queue_t result = sub_10001B8D8(*(_DWORD *)(v1 + 48), 0, *(void *)(v1 + 40));
    *(_DWORD *)(*(void *)(*(void *)(v1 + 32) + 8) + 24) = result;
  }
  if (!*(_DWORD *)(*(void *)(*(void *)(v1 + 32) + 8) + 24)) {
    ++dword_10035CC50;
  }
  return result;
}

BOOL sub_10002AE24(int a1, CFTypeRef *a2)
{
  uint64_t v9 = 0;
  int v10 = &v9;
  uint64_t v11 = 0x2000000000;
  int v12 = 0;
  int v4 = sub_10002AB8C();
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_10002AEF4;
  v7[3] = &unk_1002F7B50;
  v7[4] = &v9;
  int v8 = a1;
  dispatch_sync(v4, v7);
  BOOL v5 = sub_100029664(*((_DWORD *)v10 + 6), a2, @"Kern return error");
  _Block_object_dispose(&v9, 8);
  return v5;
}

uint64_t sub_10002AEF4(uint64_t result)
{
  int v1 = dword_10035CC50;
  if (dword_10035CC50)
  {
    --dword_10035CC50;
    if (v1 == 1)
    {
      uint64_t v2 = result;
      uint64_t v3 = sub_10000B070("lockassertions");
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)int v4 = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Dropping lock assertion", v4, 2u);
      }
      dispatch_queue_t result = sub_10001B9BC(*(_DWORD *)(v2 + 40), 0);
      *(_DWORD *)(*(void *)(*(void *)(v2 + 32) + 8) + 24) = result;
    }
  }
  return result;
}

BOOL sub_10002AF90(int a1, CFTypeRef *a2, uint64_t a3)
{
  BOOL result = sub_10002AC5C(a1, a2);
  if (result)
  {
    (*(void (**)(uint64_t))(a3 + 16))(a3);
    return sub_10002AE24(a1, a2);
  }
  return result;
}

void sub_10002B000(int a1, uint64_t a2)
{
  CFTypeRef cf = 0;
  if (sub_10002AC5C(a1, &cf))
  {
    (*(void (**)(uint64_t))(a2 + 16))(a2);
    sub_10002AE24(a1, &cf);
    CFTypeRef v4 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v4);
    }
  }
  else
  {
    BOOL v5 = sub_10000B070("secaks");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109378;
      int v9 = a1;
      __int16 v10 = 2112;
      CFTypeRef v11 = cf;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "SecAKSDoWithKeybagLockAssertionSoftly: failed to get assertion for %d proceeding bravely: %@", buf, 0x12u);
    }
    CFTypeRef v6 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v6);
    }
    (*(void (**)(uint64_t))(a2 + 16))(a2);
  }
}

uint64_t sub_10002B120()
{
  if (qword_10035CC78 != -1) {
    dispatch_once(&qword_10035CC78, &stru_1002F7C10);
  }
  if (byte_10035CC70) {
    return 1;
  }
  if (qword_10035CC88 != -1) {
    dispatch_once(&qword_10035CC88, &stru_1002F7C50);
  }
  return byte_10035CC80;
}

void sub_10002B1A0(id a1)
{
  size_t __len = 1023;
  bzero(__big, 0x400uLL);
  if (!sysctlbyname("kern.bootargs", __big, &__len, 0, 0) && strnstr(__big, "-apfs_shared_datavolume", __len)) {
    byte_10035CC80 = 1;
  }
  int v1 = sub_10000B070("eapfs");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 67109120;
    int v4 = byte_10035CC80;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "eapfs boot-arg set to %{BOOL}d", buf, 8u);
  }
}

void sub_10002B2A0(id a1)
{
  io_registry_entry_t v1 = IORegistryEntryFromPath(kIOMainPortDefault, "IODeviceTree:/filesystems");
  if (v1)
  {
    io_object_t v2 = v1;
    CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(v1, @"e-apfs", kCFAllocatorDefault, 0);
    if (CFProperty)
    {
      CFRelease(CFProperty);
      byte_10035CC70 = 1;
    }
    IOObjectRelease(v2);
  }
  int v4 = sub_10000B070("eapfs");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    v5[0] = 67109120;
    v5[1] = byte_10035CC70;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "eapfs IODT set to %{BOOL}d", (uint8_t *)v5, 8u);
  }
}

void sub_10002B3A0(id a1)
{
  uint64_t v19 = 0;
  stat v20 = &v19;
  uint64_t v21 = 0x2000000000;
  io_registry_entry_t v1 = off_10035CC90;
  BOOL v22 = off_10035CC90;
  if (!off_10035CC90)
  {
    *(void *)long long buf = _NSConcreteStackBlock;
    uint64_t v15 = 0x40000000;
    unint64_t v16 = sub_10002B69C;
    CFIndex v17 = &unk_1002F7C78;
    int v18 = &v19;
    io_object_t v2 = (void *)sub_10002B6EC();
    v20[3] = (uint64_t)dlsym(v2, "MKBUserTypeDeviceMode");
    off_10035CC90 = *(_UNKNOWN **)(v18[1] + 24);
    io_registry_entry_t v1 = (void *)v20[3];
  }
  _Block_object_dispose(&v19, 8);
  if (!v1)
  {
LABEL_18:
    dlerror();
    uint64_t v12 = abort_report_np();
    sub_10002B69C(v12);
    return;
  }
  uint64_t v3 = ((uint64_t (*)(void, void))v1)(0, 0);
  if (v3)
  {
    int v4 = (const void *)v3;
    xpc_object_t value = 0;
    uint64_t v19 = 0;
    stat v20 = &v19;
    uint64_t v21 = 0x2000000000;
    BOOL v5 = (const void **)qword_10035CCA0;
    BOOL v22 = (void *)qword_10035CCA0;
    if (!qword_10035CCA0)
    {
      *(void *)long long buf = _NSConcreteStackBlock;
      uint64_t v15 = 0x40000000;
      unint64_t v16 = sub_10002B7FC;
      CFIndex v17 = &unk_1002F7CD8;
      int v18 = &v19;
      CFTypeRef v6 = (void *)sub_10002B6EC();
      v20[3] = (uint64_t)dlsym(v6, "kMKBDeviceModeKey");
      qword_10035CCA0 = *(void *)(v18[1] + 24);
      BOOL v5 = (const void **)v20[3];
    }
    _Block_object_dispose(&v19, 8);
    if (v5)
    {
      if (!CFDictionaryGetValueIfPresent((CFDictionaryRef)v4, *v5, (const void **)&value))
      {
LABEL_14:
        CFRelease(v4);
        return;
      }
      CFIndex v7 = value;
      uint64_t v19 = 0;
      stat v20 = &v19;
      uint64_t v21 = 0x2000000000;
      int v8 = (CFTypeRef *)qword_10035CCA8;
      BOOL v22 = (void *)qword_10035CCA8;
      if (!qword_10035CCA8)
      {
        *(void *)long long buf = _NSConcreteStackBlock;
        uint64_t v15 = 0x40000000;
        unint64_t v16 = sub_10002B84C;
        CFIndex v17 = &unk_1002F7D00;
        int v18 = &v19;
        int v9 = (void *)sub_10002B6EC();
        __int16 v10 = dlsym(v9, "kMKBDeviceModeSharedIPad");
        *(void *)(v18[1] + 24) = v10;
        qword_10035CCA8 = *(void *)(v18[1] + 24);
        int v8 = (CFTypeRef *)v20[3];
      }
      _Block_object_dispose(&v19, 8);
      if (v8)
      {
        if (CFEqual(v7, *v8)) {
          byte_10035CC54 = 1;
        }
        goto LABEL_14;
      }
    }
    goto LABEL_18;
  }
  CFTypeRef v11 = sub_10000B070("edumode");
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Cannot determine because deviceMode is NULL", buf, 2u);
  }
}

void *sub_10002B69C(uint64_t a1)
{
  io_object_t v2 = (void *)sub_10002B6EC();
  BOOL result = dlsym(v2, "MKBUserTypeDeviceMode");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_10035CC90 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t sub_10002B6EC()
{
  v3[0] = 0;
  if (!qword_10035CC98)
  {
    v3[1] = _NSConcreteStackBlock;
    v3[2] = 0x40000000;
    v3[3] = sub_10002B89C;
    v3[4] = &unk_1002F7CB0;
    v3[5] = v3;
    long long v4 = off_1002F7C98;
    uint64_t v5 = 0;
    qword_10035CC98 = _sl_dlopen();
    io_registry_entry_t v1 = (void *)v3[0];
    uint64_t v0 = qword_10035CC98;
    if (qword_10035CC98)
    {
      if (!v3[0]) {
        return v0;
      }
    }
    else
    {
      io_registry_entry_t v1 = (void *)abort_report_np();
    }
    free(v1);
    return v0;
  }
  return qword_10035CC98;
}

void *sub_10002B7FC(uint64_t a1)
{
  io_object_t v2 = (void *)sub_10002B6EC();
  BOOL result = dlsym(v2, "kMKBDeviceModeKey");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  qword_10035CCA0 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *sub_10002B84C(uint64_t a1)
{
  io_object_t v2 = (void *)sub_10002B6EC();
  BOOL result = dlsym(v2, "kMKBDeviceModeSharedIPad");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  qword_10035CCA8 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t sub_10002B89C()
{
  uint64_t result = _sl_dlopen();
  qword_10035CC98 = result;
  return result;
}

void sub_10002B910(id a1)
{
  byte_10035CC60 = _os_feature_enabled_impl();
  io_registry_entry_t v1 = sub_10000B070("keychain");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_10035CC60) {
      io_object_t v2 = "enabled";
    }
    else {
      io_object_t v2 = "disabled";
    }
    int v3 = 136315138;
    long long v4 = v2;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "SeparateUserKeychain set via feature flag to %s", (uint8_t *)&v3, 0xCu);
  }
}

CFURLRef sub_10002B9E8(int a1, uint64_t a2)
{
  if (a1) {
    CFURLRef v3 = CFURLCreateWithFileSystemPath(0, @"/", kCFURLPOSIXPathStyle, 1u);
  }
  else {
    CFURLRef v3 = CFCopyHomeDirectoryURL();
  }
  CFURLRef v4 = v3;
  if (a2) {
    CFStringRef Copy = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@/%@", @"Library/Keychains", a2);
  }
  else {
    CFStringRef Copy = CFStringCreateCopy(kCFAllocatorDefault, @"Library/Keychains");
  }
  CFStringRef v6 = Copy;
  if (v4 && Copy)
  {
    CFURLRef v7 = CFURLCreateCopyAppendingPathComponent(kCFAllocatorDefault, v4, Copy, a2 == 0);
    CFRelease(v6);
LABEL_13:
    CFRelease(v4);
    return v7;
  }
  if (Copy) {
    CFRelease(Copy);
  }
  CFURLRef v7 = 0;
  if (v4) {
    goto LABEL_13;
  }
  return v7;
}

void sub_10002BAD8(uint64_t a1, uint64_t a2)
{
  syslog(5, "SecCopyURLForFileInParameterizedKeychainDirectory: forceUserScope:%d", 0);
  CFURLRef v4 = sub_10002B9E8(1, a1);
  if (v4)
  {
    CFURLRef v5 = v4;
    memset(__b, 170, sizeof(__b));
    CFURLGetFileSystemRepresentation(v5, 0, __b, 1024);
    (*(void (**)(uint64_t, UInt8 *))(a2 + 16))(a2, __b);
    CFRelease(v5);
  }
}

void sub_10002BBA0(void *a1, unsigned int a2)
{
  CFURLRef v4 = sub_10000B070("SecError");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = a1;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Simulating crash, reason: %@, code=%08x", buf, 0x12u);
  }

  int v5 = dword_10035AEC8;
  if (dword_10035AEC8 != -1) {
    goto LABEL_4;
  }
  if (!sub_10002BDFC())
  {
    int v5 = dword_10035AEC8;
LABEL_4:
    dword_10035AEC8 = v5 + 1;
    return;
  }
  uint64_t v6 = getpid();
  id v7 = a1;
  uint64_t v13 = 0;
  CFStringRef v14 = &v13;
  uint64_t v15 = 0x2020000000;
  int v8 = (void (*)(uint64_t, void, id))off_10035CCB8;
  unint64_t v16 = off_10035CCB8;
  if (!off_10035CCB8)
  {
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 3221225472;
    *(void *)&uint8_t buf[16] = sub_10002BECC;
    int v18 = &unk_100308068;
    uint64_t v19 = &v13;
    int v9 = sub_10002BF1C();
    __int16 v10 = dlsym(v9, "SimulateCrash");
    *(void *)(v19[1] + 24) = v10;
    off_10035CCB8 = *(_UNKNOWN **)(v19[1] + 24);
    int v8 = (void (*)(uint64_t, void, id))v14[3];
  }
  _Block_object_dispose(&v13, 8);
  if (!v8)
  {
    CFTypeRef v11 = +[NSAssertionHandler currentHandler];
    uint64_t v12 = +[NSString stringWithUTF8String:"BOOL soft_SimulateCrash(pid_t, mach_exception_data_type_t, NSString *__strong)"];
    [v11 handleFailureInFunction:v12 file:@"simulate_crash.m" lineNumber:22 description:@"%s", dlerror()];

    __break(1u);
  }
  v8(v6, a2, v7);
}

void sub_10002BDDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10002BDFC()
{
  if (!qword_10035CCB0) {
    qword_10035CCB0 = _sl_dlopen();
  }
  return qword_10035CCB0;
}

void *sub_10002BECC(uint64_t a1)
{
  io_object_t v2 = sub_10002BF1C();
  uint64_t result = dlsym(v2, "SimulateCrash");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_10035CCB8 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *sub_10002BF1C()
{
  uint64_t v0 = sub_10002BDFC();
  if (v0) {
    return (void *)v0;
  }
  io_registry_entry_t v1 = +[NSAssertionHandler currentHandler];
  CFURLRef v3 = +[NSString stringWithUTF8String:"void *CrashReporterSupportLibrary(void)"];
  [v1 handleFailureInFunction:v3 file:@"simulate_crash.m" lineNumber:18 description:@"%s"];

  __break(1u);
  free(v4);
  return v1;
}

uint64_t sub_10002BFCC()
{
  uint64_t result = _sl_dlopen();
  qword_10035CCB0 = result;
  return result;
}

void sub_10002C040(void *a1, unsigned int a2)
{
  CFURLRef v4 = sub_10000B070("SecError");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = a1;
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "stackshot report, reason: %@, code=%08x", buf, 0x12u);
  }

  if ((dword_10035AEC8 == -1 || !sub_10002BDFC()) && sub_10002BDFC())
  {
    id v5 = a1;
    uint64_t v11 = 0;
    uint64_t v12 = &v11;
    uint64_t v13 = 0x2020000000;
    uint64_t v6 = (void (*)(id, void))off_10035CCC0;
    CFStringRef v14 = off_10035CCC0;
    if (!off_10035CCC0)
    {
      *(void *)long long buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 3221225472;
      *(void *)&uint8_t buf[16] = sub_10002C280;
      unint64_t v16 = &unk_100308068;
      CFIndex v17 = &v11;
      id v7 = sub_10002BF1C();
      int v8 = dlsym(v7, "WriteStackshotReport");
      *(void *)(v17[1] + 24) = v8;
      off_10035CCC0 = *(_UNKNOWN **)(v17[1] + 24);
      uint64_t v6 = (void (*)(id, void))v12[3];
    }
    _Block_object_dispose(&v11, 8);
    if (!v6)
    {
      int v9 = +[NSAssertionHandler currentHandler];
      __int16 v10 = +[NSString stringWithUTF8String:"BOOL soft_WriteStackshotReport(NSString *__strong, mach_exception_data_type_t)"];
      [v9 handleFailureInFunction:v10 file:@"simulate_crash.m" lineNumber:25 description:@"%s", dlerror()];

      __break(1u);
    }
    v6(v5, a2);
  }
}

void sub_10002C260(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_start(va, a3);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void *sub_10002C280(uint64_t a1)
{
  io_object_t v2 = sub_10002BF1C();
  uint64_t result = dlsym(v2, "WriteStackshotReport");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_10035CCC0 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_10002D1C0(id a1)
{
  io_registry_entry_t v1 = [KeychainItemUpgradeRequestServer alloc];
  id v4 = +[CKKSLockStateTracker globalTracker];
  io_object_t v2 = [(KeychainItemUpgradeRequestServer *)v1 initWithLockStateTracker:v4];
  CFURLRef v3 = (void *)qword_10035CCC8;
  qword_10035CCC8 = (uint64_t)v2;
}

void sub_10002D3D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10002D3F8(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper performCKServerUnreadableDataRemovalWithSpecificUser:isGuitarfish:internalAccount:demo"
           "Account:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper performCKServerUnreadableDataRemovalWithSpecificUser:isGuitarfish:internalAccount:demo"
           "Account:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_10002D730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10002D754(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper fetchPCSIdentityByPublicKeyWithSpecificUser:pcsservices:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper fetchPCSIdentityByPublicKeyWithSpecificUser:pcsservices:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_10002DA94(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10002DAB8(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper fetchCurrentItemWithSpecificUser:items:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper fetchCurrentItemWithSpecificUser:items:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_10002DDE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10002DE04(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper octagonContainsDistrustedRecoveryKeysWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper octagonContainsDistrustedRecoveryKeysWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_10002E128(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10002E14C(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper fetchTrustedPeerCountWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper fetchTrustedPeerCountWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_10002E4A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10002E4C4(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper preflightRecoverOctagonUsingRecoveryKey:recoveryKey:salt:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper preflightRecoverOctagonUsingRecoveryKey:recoveryKey:salt:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_10002E8A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10002E8C8(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper performATOPRVActionsWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper performATOPRVActionsWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_10002EBE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10002EC0C(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper removeRecoveryKey:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper removeRecoveryKey:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_10002EF30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10002EF54(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper isRecoveryKeySet:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper isRecoveryKeySet:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_10002F2A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10002F2CC(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper recoverTLKSharesForInheritorWithSpecificUser:crk:tlkShares:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper recoverTLKSharesForInheritorWithSpecificUser:crk:tlkShares:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_10002F760(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 168), 8);
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_10002F784(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      *(_DWORD *)long long buf = 136315650;
      int v8 = "-[CuttlefishXPCWrapper prepareInheritancePeerWithSpecificUser:epoch:machineID:bottleSalt:bottleID:modelID:dev"
           "iceName:serialNumber:osVersion:policyVersion:policySecrets:syncUserControllableViews:secureElementIdentity:si"
           "gningPrivKeyPersistentRef:encPrivKeyPersistentRef:crk:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", buf, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315394;
      int v8 = "-[CuttlefishXPCWrapper prepareInheritancePeerWithSpecificUser:epoch:machineID:bottleSalt:bottleID:modelID:dev"
           "iceName:serialNumber:osVersion:policyVersion:policySecrets:syncUserControllableViews:secureElementIdentity:si"
           "gningPrivKeyPersistentRef:encPrivKeyPersistentRef:crk:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", buf, 0x16u);
    }

    (*(void (**)(void, void))(a1[5] + 16))(a1[5], 0);
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_10002FACC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10002FAF0(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper fetchAccountSettingsWithSpecificUser:forceFetch:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper fetchAccountSettingsWithSpecificUser:forceFetch:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_10002FE2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10002FE50(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper fetchRecoverableTLKSharesWithSpecificUser:peerID:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper fetchRecoverableTLKSharesWithSpecificUser:peerID:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_1000301C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va1, a12);
  va_start(va, a12);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1000301E4(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper resetAccountCDPContentsWithSpecificUser:idmsTargetContext:idmsCuttlefishPassword:notif"
           "yIdMS:internalAccount:demoAccount:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper resetAccountCDPContentsWithSpecificUser:idmsTargetContext:idmsCuttlefishPassword:notif"
           "yIdMS:internalAccount:demoAccount:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100030504(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100030528(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper removeEscrowCacheWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper removeEscrowCacheWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100030854(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100030878(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper fetchViableEscrowRecordsWithSpecificUser:source:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper fetchViableEscrowRecordsWithSpecificUser:source:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100030B9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100030BC0(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper getSupportAppInfoWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper getSupportAppInfoWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100030F3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va1, a12);
  va_start(va, a12);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100030F60(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper requestHealthCheckWithSpecificUser:requiresEscrowCheck:repair:knownFederations:flowID:"
           "deviceSessionID:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper requestHealthCheckWithSpecificUser:requiresEscrowCheck:repair:knownFederations:flowID:"
           "deviceSessionID:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_10003129C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1000312C0(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper findCustodianRecoveryKeyWithSpecificUser:uuid:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper findCustodianRecoveryKeyWithSpecificUser:uuid:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_1000315FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100031620(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper removeCustodianRecoveryKeyWithSpecificUser:uuid:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper removeCustodianRecoveryKeyWithSpecificUser:uuid:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_1000319A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, ...)
{
  va_start(va1, a12);
  va_start(va, a12);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1000319C8(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper createCustodianRecoveryKeyWithSpecificUser:recoveryKey:salt:ckksKeys:uuid:kind:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper createCustodianRecoveryKeyWithSpecificUser:recoveryKey:salt:ckksKeys:uuid:kind:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100031D34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100031D58(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper setRecoveryKeyWithSpecificUser:recoveryKey:salt:ckksKeys:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper setRecoveryKeyWithSpecificUser:recoveryKey:salt:ckksKeys:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_10003207C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1000320A0(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper fetchTrustStateWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper fetchTrustStateWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_1000323EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100032410(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper fetchCurrentPolicyWithSpecificUser:modelIDOverride:isInheritedAccount:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper fetchCurrentPolicyWithSpecificUser:modelIDOverride:isInheritedAccount:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100032750(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100032774(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper fetchPolicyDocumentsWithSpecificUser:versions:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper fetchPolicyDocumentsWithSpecificUser:versions:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100032A98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100032ABC(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper fetchEscrowContentsWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper fetchEscrowContentsWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100032E20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100032E44(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper fetchViableBottlesWithSpecificUser:source:flowID:deviceSessionID:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper fetchViableBottlesWithSpecificUser:source:flowID:deviceSessionID:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_10003319C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1000331C0(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper updateTLKsWithSpecificUser:ckksKeys:tlkShares:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper updateTLKsWithSpecificUser:ckksKeys:tlkShares:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_1000334FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100033520(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper setPreapprovedKeysWithSpecificUser:preapprovedKeys:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper setPreapprovedKeysWithSpecificUser:preapprovedKeys:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100033918(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 168), 8);
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_10003393C(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper updateWithSpecificUser:forceRefetch:deviceName:serialNumber:osVersion:policyVersion:po"
           "licySecrets:syncUserControllableViews:secureElementIdentity:walrusSetting:webAccess:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper updateWithSpecificUser:forceRefetch:deviceName:serialNumber:osVersion:policyVersion:po"
           "licySecrets:syncUserControllableViews:secureElementIdentity:walrusSetting:webAccess:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100033CA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100033CCC(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper attemptPreapprovedJoinWithSpecificUser:ckksKeys:tlkShares:preapprovedKeys:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper attemptPreapprovedJoinWithSpecificUser:ckksKeys:tlkShares:preapprovedKeys:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100034010(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100034034(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper preflightPreapprovedJoinWithSpecificUser:preapprovedKeys:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper preflightPreapprovedJoinWithSpecificUser:preapprovedKeys:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100034400(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
  _Block_object_dispose(&a26, 8);
  _Block_object_dispose((const void *)(v26 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_100034424(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper joinWithSpecificUser:voucherData:voucherSig:ckksKeys:tlkShares:preapprovedKeys:flowID:"
           "deviceSessionID:canSendMetrics:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper joinWithSpecificUser:voucherData:voucherSig:ckksKeys:tlkShares:preapprovedKeys:flowID:"
           "deviceSessionID:canSendMetrics:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100034780(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1000347A4(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper vouchWithRerollWithSpecificUser:oldPeerID:tlkShares:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper vouchWithRerollWithSpecificUser:oldPeerID:tlkShares:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100034B04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100034B28(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper vouchWithCustodianRecoveryKeyWithSpecificUser:crk:tlkShares:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper vouchWithCustodianRecoveryKeyWithSpecificUser:crk:tlkShares:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100034E9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100034EC0(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper vouchWithRecoveryKeyWithSpecificUser:recoveryKey:salt:tlkShares:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper vouchWithRecoveryKeyWithSpecificUser:recoveryKey:salt:tlkShares:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100035208(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10003522C(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper preflightVouchWithCustodianRecoveryKeyWithSpecificUser:crk:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper preflightVouchWithCustodianRecoveryKeyWithSpecificUser:crk:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100035584(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1000355A8(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper preflightVouchWithRecoveryKeyWithSpecificUser:recoveryKey:salt:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper preflightVouchWithRecoveryKeyWithSpecificUser:recoveryKey:salt:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_10003592C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va1, a10);
  va_start(va, a10);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100035950(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper vouchWithBottleWithSpecificUser:bottleID:entropy:bottleSalt:tlkShares:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper vouchWithBottleWithSpecificUser:bottleID:entropy:bottleSalt:tlkShares:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100035C98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100035CBC(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper preflightVouchWithBottleWithSpecificUser:bottleID:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper preflightVouchWithBottleWithSpecificUser:bottleID:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_1000360B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  _Block_object_dispose(&a30, 8);
  _Block_object_dispose((const void *)(v30 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_1000360D4(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper vouchWithSpecificUser:peerID:permanentInfo:permanentInfoSig:stableInfo:stableInfoSig:c"
           "kksKeys:flowID:deviceSessionID:canSendMetrics:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper vouchWithSpecificUser:peerID:permanentInfo:permanentInfoSig:stableInfo:stableInfoSig:c"
           "kksKeys:flowID:deviceSessionID:canSendMetrics:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100036440(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100036464(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper establishWithSpecificUser:ckksKeys:tlkShares:preapprovedKeys:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper establishWithSpecificUser:ckksKeys:tlkShares:preapprovedKeys:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_1000368FC(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 168), 8);
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_100036920(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper prepareWithSpecificUser:epoch:machineID:bottleSalt:bottleID:modelID:deviceName:serialN"
           "umber:osVersion:policyVersion:policySecrets:syncUserControllableViews:secureElementIdentity:setting:signingPr"
           "ivKeyPersistentRef:encPrivKeyPersistentRef:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper prepareWithSpecificUser:epoch:machineID:bottleSalt:bottleID:modelID:deviceName:serialN"
           "umber:osVersion:policyVersion:policySecrets:syncUserControllableViews:secureElementIdentity:setting:signingPr"
           "ivKeyPersistentRef:encPrivKeyPersistentRef:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100036C58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100036C7C(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper fetchEgoEpochWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper fetchEgoEpochWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100036FA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100036FC4(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper fetchAllowedMachineIDsWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper fetchAllowedMachineIDsWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100037300(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100037324(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper handleRemovedMachineIDsDueToUnknownReasonsWithSpecificUser:machineIDs:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper handleRemovedMachineIDsDueToUnknownReasonsWithSpecificUser:machineIDs:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_10003765C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100037680(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper handleEvictedMachineIDsWithSpecificUser:machineIDs:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper handleEvictedMachineIDsWithSpecificUser:machineIDs:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_1000379A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1000379C4(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper markTrustedDeviceListFetchFailed:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper markTrustedDeviceListFetchFailed:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100037E10(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 168), 8);
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_100037E34(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper setAllowedMachineIDsWithSpecificUser:allowedMachineIDs:userInitiatedRemovals:evictedRe"
           "movals:unknownReasonRemovals:honorIDMSListChanges:version:flowID:deviceSessionID:canSendMetrics:altDSID:trust"
           "edDeviceHash:deletedDeviceHash:trustedDevicesUpdateTimestamp:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper setAllowedMachineIDsWithSpecificUser:allowedMachineIDs:userInitiatedRemovals:evictedRe"
           "movals:unknownReasonRemovals:honorIDMSListChanges:version:flowID:deviceSessionID:canSendMetrics:altDSID:trust"
           "edDeviceHash:deletedDeviceHash:trustedDevicesUpdateTimestamp:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100038158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10003817C(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper localResetWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper localResetWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_1000384F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_start(va, a16);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v16 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_10003851C(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper resetWithSpecificUser:resetReason:idmsTargetContext:idmsCuttlefishPassword:notifyIdMS:"
           "internalAccount:demoAccount:isGuitarfish:accountType:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper resetWithSpecificUser:resetReason:idmsTargetContext:idmsCuttlefishPassword:notifyIdMS:"
           "internalAccount:demoAccount:isGuitarfish:accountType:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_10003883C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100038860(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper trustStatusWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper trustStatusWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100038C58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100038C7C(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper distrustPeerIDsWithSpecificUser:peerIDs:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper distrustPeerIDsWithSpecificUser:peerIDs:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100038F9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100038FC0(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper departByDistrustingSelfWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper departByDistrustingSelfWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_1000392E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100039304(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper trustedDeviceNamesByPeerIDWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper trustedDeviceNamesByPeerIDWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100039640(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100039664(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper octagonPeerIDGivenBottleIDWithSpecificUser:bottleID:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper octagonPeerIDGivenBottleIDWithSpecificUser:bottleID:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100039988(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_1000399AC(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper honorIDMSListChangesForSpecificUser:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper honorIDMSListChangesForSpecificUser:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100039CD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_100039CF4(void *a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(a1[6] + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(a1[6] + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper dumpWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper dumpWithSpecificUser:reply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }

    (*(void (**)(void))(a1[5] + 16))();
  }
  ++*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
}

void sub_100039FE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10003A008(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (*(int *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) <= 4
    && [(id)objc_opt_class() retryable:v3])
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
      int v7 = 136315650;
      int v8 = "-[CuttlefishXPCWrapper pingWithReply:]_block_invoke";
      __int16 v9 = 1024;
      LODWORD(v10[0]) = v5;
      WORD2(v10[0]) = 2112;
      *(void *)((char *)v10 + 6) = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "retrying cuttlefish XPC %s, (%d, %@)", (uint8_t *)&v7, 0x1Cu);
    }

    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
  }
  else
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136315394;
      int v8 = "-[CuttlefishXPCWrapper pingWithReply:]_block_invoke";
      __int16 v9 = 2112;
      v10[0] = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Can't talk with TrustedPeersHelper %s: %@", (uint8_t *)&v7, 0x16u);
    }
  }
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
}

void sub_10003A5B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
}

void sub_10003A5E0(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (v8 && !v9)
  {
    uint64_t v11 = sub_10000B070("octagon-ckks");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = [v8 viewList];
      *(_DWORD *)long long buf = 138412546;
      id v38 = v8;
      __int16 v39 = 2112;
      uint64_t v40 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Received syncing policy %@ with view list: %@", buf, 0x16u);
    }
    uint64_t v13 = [WeakRetained deps];
    uint64_t v14 = [v13 stateHolder];
    v35[0] = _NSConcreteStackBlock;
    v35[1] = 3221225472;
    v35[2] = sub_10003AA74;
    v35[3] = &unk_100307118;
    id v15 = v8;
    id v36 = v15;
    id v34 = 0;
    [v14 persistAccountChanges:v35 error:&v34];
    id v16 = v34;

    if (v16)
    {
      uint64_t v17 = sub_10000B070("SecError");
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v38 = v16;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "octagon: failed to save policy+views: %@", buf, 0xCu);
      }

      [WeakRetained setError:v16];
    }
    else
    {
      char v29 = [WeakRetained deps];
      uint64_t v30 = [v29 ckks];
      [v30 setCurrentSyncingPolicy:v15];

      CFIndex v31 = [WeakRetained deps];
      id v32 = [v31 notifierClass];
      [v32 post:OTUserControllableViewStatusChanged];

      __int16 v33 = [WeakRetained intendedState];
      [WeakRetained setNextState:v33];
    }
LABEL_21:

    goto LABEL_22;
  }
  int v18 = sub_10000B070("SecError");
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    id v38 = v9;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "octagon-ckks: setting user-controllable views status errored: %@", buf, 0xCu);
  }

  [WeakRetained setError:v9];
  uint64_t v19 = [WeakRetained deps];
  stat v20 = [v19 lockStateTracker];
  uint64_t v21 = [WeakRetained error];
  unsigned int v22 = [v20 isLockedError:v21];

  if (v22)
  {
    char v23 = sub_10000B070("octagon-ckks");
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v24 = [WeakRetained error];
      *(_DWORD *)long long buf = 138412290;
      id v38 = v24;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Updating user-controllable view status failed because of lock state, will retry once unlocked: %@", buf, 0xCu);
    }
    char v25 = [[OctagonPendingFlag alloc] initWithFlag:@"attempt_ucv_upgrade" conditions:1];
    uint64_t v26 = [WeakRetained deps];
    uint64_t v27 = [v26 flagHandler];
    [v27 handlePendingFlag:v25];
  }
  if (((unint64_t)[v7 peerStatus] & 0x24) != 0)
  {
    uint64_t v28 = sub_10000B070("octagon-ckks");
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Updating user-controllable view status failed because our self peer is excluded or missing", buf, 2u);
    }

    id v16 = [WeakRetained peerMissingState];
    [WeakRetained setNextState:v16];
    goto LABEL_21;
  }
LABEL_22:
}

id sub_10003AA74(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 setTPSyncingPolicy:*(void *)(a1 + 32)];

  return v3;
}

void sub_10003AED0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void sub_10003AF08(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v6 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v8 = sub_10000B070("octagon-ckks");
  BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    if (v9)
    {
      *(_DWORD *)long long buf = 138412290;
      id v12 = v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Determining peers' user-controllable views policy failed: %@", buf, 0xCu);
    }

    [WeakRetained setError:v6];
  }
  else
  {
    if (v9)
    {
      if (a3 >= 4)
      {
        uint64_t v10 = +[NSString stringWithFormat:@"(unknown: %i)", a3];
      }
      else
      {
        uint64_t v10 = *(&off_1002F7DA0 + a3);
      }
      *(_DWORD *)long long buf = 138412290;
      id v12 = v10;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Retrieved peers' user-controllable views policy as: %@", buf, 0xCu);
    }
    [WeakRetained performWithStatus:a3];
  }
}

void sub_10003F6CC(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 96));
  _Unwind_Resume(a1);
}

void sub_10003F700(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  unsigned int v62 = +[NSMutableArray array];
  uint64_t v61 = +[NSMutableArray array];
  id v3 = +[NSMutableArray array];
  id v56 = +[NSMutableSet set];
  long long v83 = 0u;
  long long v84 = 0u;
  long long v85 = 0u;
  long long v86 = 0u;
  id obj = *(id *)(a1 + 32);
  long long v64 = WeakRetained;
  id v60 = [obj countByEnumeratingWithState:&v83 objects:v94 count:16];
  if (v60)
  {
    uint64_t v59 = *(void *)v84;
    do
    {
      for (uint64_t i = 0; i != v60; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v84 != v59) {
          objc_enumerationMutation(obj);
        }
        int v5 = *(void **)(*((void *)&v83 + 1) + 8 * i);
        id v6 = [v5 error];

        unsigned int v66 = v5;
        if (!v6)
        {
          long long v81 = 0u;
          long long v82 = 0u;
          long long v79 = 0u;
          long long v80 = 0u;
          uint64_t v14 = [v5 keysets];
          id v15 = [v14 allKeys];

          id v63 = v15;
          id v67 = [v15 countByEnumeratingWithState:&v79 objects:v93 count:16];
          if (!v67) {
            goto LABEL_51;
          }
          uint64_t v57 = i;
          uint64_t v65 = *(void *)v80;
          while (1)
          {
            uint64_t v16 = 0;
            do
            {
              if (*(void *)v80 != v65) {
                objc_enumerationMutation(v63);
              }
              uint64_t v68 = v16;
              uint64_t v17 = *(void *)(*((void *)&v79 + 1) + 8 * v16);
              int v18 = [v5 keysets];
              uint64_t v19 = [v18 objectForKeyedSubscript:v17];

              stat v20 = [WeakRetained viewFilter];

              if (!v20)
              {
LABEL_29:
                id v74 = 0;
                __int16 v33 = [v19 asKeychainBackedSet:&v74];
                id v32 = v74;
                if (v33)
                {
                  id v34 = sub_10000B070("octagon-ckks");
                  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)long long buf = 138412290;
                    *(void *)v88 = v19;
                    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Have proposed keys: %@", buf, 0xCu);
                  }

                  uint64_t v35 = v62;
                  id v36 = v33;
                  goto LABEL_37;
                }
                if (v19)
                {
                  CFTypeRef v37 = sub_10000B070("octagon-ckks");
                  if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)long long buf = 138412546;
                    *(void *)v88 = v19;
                    *(_WORD *)&v88[8] = 2112;
                    uint64_t v89 = v32;
                    _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "Unable to convert proposed keys: %@ %@", buf, 0x16u);
                  }

                  uint64_t v35 = v61;
                  id v36 = v19;
LABEL_37:
                  [v35 addObject:v36];
                }
                long long v72 = 0u;
                long long v73 = 0u;
                long long v70 = 0u;
                long long v71 = 0u;
                id v38 = [v19 pendingTLKShares];
                id v39 = [v38 countByEnumeratingWithState:&v70 objects:v91 count:16];
                if (v39)
                {
                  id v40 = v39;
                  uint64_t v41 = *(void *)v71;
                  do
                  {
                    for (j = 0; j != v40; j = (char *)j + 1)
                    {
                      if (*(void *)v71 != v41) {
                        objc_enumerationMutation(v38);
                      }
                      CFRange v43 = [*(id *)(*((void *)&v70 + 1) + 8 * (void)j) share];
                      [v3 addObject:v43];
                    }
                    id v40 = [v38 countByEnumeratingWithState:&v70 objects:v91 count:16];
                  }
                  while (v40);
                }

                uint64_t v44 = sub_10000B070("octagon-ckks");
                if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
                {
                  char v45 = [v19 pendingTLKShares];
                  unsigned int v46 = [v45 count];
                  *(_DWORD *)long long buf = 67109120;
                  *(_DWORD *)v88 = v46;
                  _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "Have %u pending tlk shares", buf, 8u);
                }
                goto LABEL_48;
              }
              long long v77 = 0u;
              long long v78 = 0u;
              long long v75 = 0u;
              long long v76 = 0u;
              id v69 = [WeakRetained viewFilter];
              id v21 = [v69 countByEnumeratingWithState:&v75 objects:v92 count:16];
              if (v21)
              {
                id v22 = v21;
                uint64_t v23 = *(void *)v76;
                while (2)
                {
                  for (k = 0; k != v22; k = (char *)k + 1)
                  {
                    if (*(void *)v76 != v23) {
                      objc_enumerationMutation(v69);
                    }
                    char v25 = *(void **)(*((void *)&v75 + 1) + 8 * (void)k);
                    uint64_t v26 = v19;
                    uint64_t v27 = [v19 zoneID];
                    uint64_t v28 = [v27 zoneName];
                    char v29 = [v25 zoneID];
                    uint64_t v30 = [v29 zoneName];
                    unsigned __int8 v31 = [v28 isEqualToString:v30];

                    if (v31)
                    {

                      uint64_t v19 = v26;
                      goto LABEL_29;
                    }
                    uint64_t v19 = v26;
                  }
                  id v22 = [v69 countByEnumeratingWithState:&v75 objects:v92 count:16];
                  if (v22) {
                    continue;
                  }
                  break;
                }
              }

              id v32 = sub_10000B070("octagon-ckks");
              if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)long long buf = 138412290;
                *(void *)v88 = v19;
                _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "Skipping keys: %@", buf, 0xCu);
              }
LABEL_48:
              id WeakRetained = v64;

              uint64_t v16 = v68 + 1;
              int v5 = v66;
            }
            while ((id)(v68 + 1) != v67);
            id v67 = [v63 countByEnumeratingWithState:&v79 objects:v93 count:16];
            if (!v67)
            {
              uint64_t i = v57;
LABEL_51:
              uint64_t v10 = v63;
LABEL_53:

              goto LABEL_54;
            }
          }
        }
        id v7 = sub_10000B070("octagon-ckks");
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
        {
          id v8 = [v5 intendedZoneIDs];
          BOOL v9 = [v5 error];
          *(_DWORD *)long long buf = 138412546;
          *(void *)v88 = v8;
          *(_WORD *)&v88[8] = 2112;
          uint64_t v89 = v9;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "No keys for %@: %@", buf, 0x16u);
        }
        uint64_t v10 = [v5 error];
        uint64_t v11 = [v10 domain];
        if (([v11 isEqualToString:@"CKKSResultOperationError"] & 1) == 0)
        {

          goto LABEL_53;
        }
        id v12 = [v5 error];
        id v13 = [v12 code];

        if (v13 == (id)3)
        {
          uint64_t v10 = [v5 intendedZoneIDs];
          [v56 unionSet:v10];
          goto LABEL_53;
        }
LABEL_54:
        ;
      }
      id v60 = [obj countByEnumeratingWithState:&v83 objects:v94 count:16];
    }
    while (v60);
  }

  [WeakRetained setViewKeySets:v62];
  [WeakRetained setIncompleteKeySets:v61];
  [WeakRetained setPendingTLKShares:v3];
  [WeakRetained setZonesTimedOutWithoutKeysets:v56];
  uint64_t v47 = sub_10000B070("octagon-ckks");
  if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v48 = [WeakRetained viewKeySets];
    unsigned int v49 = [v48 count];
    uint64_t v50 = [WeakRetained incompleteKeySets];
    unsigned int v51 = [v50 count];
    unsigned int v52 = [v64 pendingTLKShares];
    unsigned int v53 = [v52 count];
    uint64_t v54 = [v64 zonesTimedOutWithoutKeysets];
    unsigned int v55 = [v54 count];
    *(_DWORD *)long long buf = 67109888;
    *(_DWORD *)v88 = v49;
    *(_WORD *)&v88[4] = 1024;
    *(_DWORD *)&v88[6] = v51;
    id WeakRetained = v64;
    LOWORD(v89) = 1024;
    *(_DWORD *)((char *)&v89 + 2) = v53;
    HIWORD(v89) = 1024;
    unsigned int v90 = v55;
    _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "Fetched %d key sets, %d broken key sets, %d pendingTLKShares, and %d views timing out", buf, 0x1Au);
  }
}

void sub_10004036C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100040390(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  int v5 = sub_10000B070("octagon");
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v6)
    {
      id v7 = [WeakRetained deps];
      id v8 = [v7 containerName];
      BOOL v9 = [WeakRetained deps];
      uint64_t v10 = [v9 contextID];
      *(_DWORD *)long long buf = 138412802;
      id v19 = v8;
      __int16 v20 = 2112;
      id v21 = v10;
      __int16 v22 = 2112;
      id v23 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Unable to reset local cuttlefish for (%@,%@): %@", buf, 0x20u);
    }
    [WeakRetained setError:v3];
  }
  else
  {
    if (v6)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Successfully reset local cuttlefish", buf, 2u);
    }

    uint64_t v11 = [WeakRetained deps];
    id v12 = [v11 stateHolder];
    id v17 = 0;
    [v12 persistAccountChanges:&stru_1002F7E40 error:&v17];
    id v13 = v17;

    uint64_t v14 = sub_10000B070("octagon");
    BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
    if (v13)
    {
      if (v15)
      {
        *(_DWORD *)long long buf = 138412290;
        id v19 = v13;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Error resetting local account state: %@", buf, 0xCu);
      }
    }
    else
    {
      if (v15)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Successfully reset local account state", buf, 2u);
      }

      uint64_t v14 = [WeakRetained intendedState];
      [WeakRetained setNextState:v14];
    }
  }
  uint64_t v16 = [WeakRetained finishedOp];
  [WeakRetained runBeforeGroupFinished:v16];
}

OTAccountMetadataClassC *__cdecl sub_100040624(id a1, OTAccountMetadataClassC *a2)
{
  uint64_t v2 = a2;
  [(OTAccountMetadataClassC *)v2 setTrustState:0];
  [(OTAccountMetadataClassC *)v2 setPeerID:0];
  [(OTAccountMetadataClassC *)v2 setSyncingPolicy:0];
  [(OTAccountMetadataClassC *)v2 setVoucher:0];
  [(OTAccountMetadataClassC *)v2 setVoucherSignature:0];
  [(OTAccountMetadataClassC *)v2 setTlkSharesForVouchedIdentitys:0];
  [(OTAccountMetadataClassC *)v2 setIsInheritedAccount:0];
  [(OTAccountMetadataClassC *)v2 setWarmedEscrowCache:0];
  [(OTAccountMetadataClassC *)v2 setWarnedTooManyPeers:0];

  return v2;
}

void sub_100041838(id a1)
{
  v3[0] = @"ready";
  v3[1] = @"error";
  v4[0] = &off_100325648;
  v4[1] = &off_100325660;
  v3[2] = @"initializing";
  v3[3] = @"initialized";
  v4[2] = &off_100325678;
  v4[3] = &off_100325690;
  v3[4] = @"fetchcomplete";
  v3[5] = @"unhealthy";
  v4[4] = &off_1003256A8;
  v4[5] = &off_1003256C0;
  void v3[6] = @"needrefetch";
  v3[7] = @"fetching";
  void v4[6] = &off_1003256D8;
  v4[7] = &off_1003256F0;
  v3[8] = @"resetzone";
  v3[9] = @"resetlocal";
  v4[8] = &off_100325708;
  v4[9] = &off_100325720;
  v3[10] = @"loggedout";
  v3[11] = @"zonecreationfailed";
  v4[10] = &off_100325738;
  v4[11] = &off_100325750;
  v3[12] = @"waitfortrust";
  v3[13] = @"process_key_hierarchy";
  v4[12] = &off_100325768;
  v4[13] = &off_100325780;
  v3[14] = @"check_zone_hierarchies";
  v3[15] = @"become_ready";
  v4[14] = &off_100325798;
  v4[15] = &off_1003257B0;
  v3[16] = @"lose_trust";
  v3[17] = @"tlkmissing";
  uint8_t v4[16] = &off_1003257C8;
  v4[17] = &off_1003257E0;
  v3[18] = @"wait_for_ck_account_status";
  v3[19] = @"begin_fetch";
  v4[18] = &off_1003257F8;
  v4[19] = &off_100325810;
  v3[20] = @"fixup_fetch_cip";
  v3[21] = @"fixup_fetch_tlkshares";
  v4[20] = &off_100325828;
  v4[21] = &off_100325840;
  v3[22] = @"fixup_local_reload";
  v3[23] = @"fixup_resave_cdse";
  v4[22] = &off_100325858;
  v4[23] = &off_100325870;
  v3[24] = @"fixup_delete_tombstones";
  v3[25] = @"heal_tlk_shares";
  v4[24] = &off_100325888;
  v4[25] = &off_1003258A0;
  v3[26] = @"healtlksharesfailed";
  v3[27] = @"provide_key_hieararchy";
  v4[26] = &off_1003258B8;
  v4[27] = &off_1003258D0;
  v3[28] = @"provide_key_hieararchy_untrusted";
  v3[29] = @"process_incoming_queue";
  v4[28] = &off_1003258E8;
  v4[29] = &off_100325900;
  v3[30] = @"class_a_incoming_items_remaining";
  v3[31] = @"scan_local_items";
  v4[30] = &off_100325918;
  v4[31] = &off_100325930;
  v3[32] = @"reencrypt_outgoing_items";
  v3[33] = @"process_outgoing_queue";
  v4[32] = &off_100325948;
  v4[33] = &off_100325960;
  v3[34] = @"process_outgoing_queue_failed";
  v3[35] = @"handle_all_views";
  v4[34] = &off_100325978;
  v4[35] = &off_100325990;
  v3[36] = @"zone_creation_failed_due_to_network_error";
  v3[37] = @"zone_deletion_failed_due_to_network_error";
  v4[36] = &off_1003259A8;
  v4[37] = &off_1003259C0;
  uint64_t v1 = +[NSDictionary dictionaryWithObjects:v4 forKeys:v3 count:38];
  uint64_t v2 = (void *)qword_10035CCD8;
  qword_10035CCD8 = v1;
}

void sub_100041BC4(id a1)
{
  v4[0] = @"fetch_requested";
  v4[1] = @"key_process_requested";
  v4[2] = @"trusted_peers_changed";
  v4[3] = @"dropped_items";
  v4[4] = @"ck_account_logged_in";
  v4[5] = @"ck_account_logged_out";
  void v4[6] = @"ck_zone_missing";
  v4[7] = @"ck_change_token_expired";
  v4[8] = @"process_incoming_queue";
  v4[9] = @"process_outgoing_queue";
  v4[10] = @"item_reencryption_needed";
  v4[11] = @"trusted_operation_begin";
  v4[12] = @"trusted_operation_end";
  v4[13] = @"device_unlocked";
  v4[14] = @"fetch_complete";
  v4[15] = @"24_hr_notification";
  uint8_t v4[16] = @"key_set";
  v4[17] = @"check_queues";
  v4[18] = @"policy_fresh";
  v4[19] = @"oqo_token";
  v4[20] = @"new_priority_views";
  v4[21] = @"zone_creation";
  v4[22] = @"zone_deletion";
  uint64_t v1 = +[NSArray arrayWithObjects:v4 count:23];
  uint64_t v2 = +[NSSet setWithArray:v1];
  id v3 = (void *)qword_10035CCE8;
  qword_10035CCE8 = v2;
}

void sub_100042A24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100042A3C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100042A4C(uint64_t a1)
{
}

void sub_100042A54(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  id v4 = [*(id *)(a1 + 40) fromDatabaseRow:a2];
  id v3 = [v4 memoizeOriginalSelfWhereClause];
  [v2 addObject:v3];
}

void sub_100042C50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100042C68(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  id v4 = [*(id *)(a1 + 40) fromDatabaseRow:a2];
  id v3 = [v4 memoizeOriginalSelfWhereClause];
  [v2 addObject:v3];
}

void sub_100042E40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100042E58(uint64_t a1, uint64_t a2)
{
  id v6 = [*(id *)(a1 + 40) fromDatabaseRow:a2];
  uint64_t v3 = [v6 memoizeOriginalSelfWhereClause];
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  int v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;
}

BOOL sub_100043230(uint64_t a1, uint64_t a2)
{
  CFTypeRef cf = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_100043374;
  v7[3] = &unk_1002F8110;
  id v8 = *(id *)(a1 + 32);
  BOOL v3 = sub_1001381F8(a2, 5, &cf, (uint64_t)v7);
  if (cf)
  {
    uint64_t v4 = sub_1000CD884(@"ckkssql", 0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      CFTypeRef v11 = cf;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "error performing database transaction, major problems ahead: %@", buf, 0xCu);
    }

    CFTypeRef v5 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v5);
    }
  }

  return v3;
}

BOOL sub_100043374()
{
  off_10035CA00();
  uint64_t v1 = v0;
  *uint64_t v0 = 1;
  off_10035CA18();
  BOOL v3 = v2;
  *uint64_t v2 = v4;
  int v6 = (*(uint64_t (**)(void))(*(void *)(v5 + 32) + 16))();
  *BOOL v3 = 0;
  unsigned char *v1 = 0;
  return v6 == 1;
}

void sub_100043590(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000435A8(uint64_t a1, uint64_t a2)
{
  char v4 = [*(id *)(a1 + 80) quotedString:*(void *)(a1 + 32)];
  uint64_t v5 = [*(id *)(a1 + 80) quotedString:*(void *)(a1 + 40)];
  int v6 = +[NSMutableArray array];
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  id v7 = *(id *)(a1 + 48);
  id v8 = [v7 countByEnumeratingWithState:&v28 objects:v32 count:16];
  if (v8)
  {
    id v9 = v8;
    uint64_t v10 = *(void *)v29;
    do
    {
      CFTypeRef v11 = 0;
      do
      {
        if (*(void *)v29 != v10) {
          objc_enumerationMutation(v7);
        }
        id v12 = [*(id *)(a1 + 80) quotedString:*(void *)(*((void *)&v28 + 1) + 8 * (void)v11)];
        [v6 addObject:v12];

        CFTypeRef v11 = (char *)v11 + 1;
      }
      while (v9 != v11);
      id v9 = [v7 countByEnumeratingWithState:&v28 objects:v32 count:16];
    }
    while (v9);
  }

  id v13 = [v6 componentsJoinedByString:@", "];
  uint64_t v14 = [v13 stringByAppendingFormat:@", %@", v4];

  BOOL v15 = +[CKKSSQLDatabaseObject makeWhereClause:*(void *)(a1 + 56)];
  id v16 = [objc_alloc((Class)NSString) initWithFormat:@"SELECT %@ FROM %@%@", v14, v5, v15];
  id v17 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 72) + 8) + 24);
  v21[0] = _NSConcreteStackBlock;
  v21[1] = 3221225472;
  void v21[2] = sub_100043844;
  v21[3] = &unk_1002F8098;
  uint64_t v26 = *(void *)(a1 + 80);
  id v18 = *(id *)(a1 + 56);
  uint64_t v19 = *(void *)(a1 + 72);
  id v22 = v18;
  uint64_t v25 = v19;
  uint64_t v27 = a2;
  id v23 = *(id *)(a1 + 48);
  id v24 = *(id *)(a1 + 64);
  sub_10002742C(a2, (uint64_t)v16, v17, (uint64_t)v21);

  return 1;
}

void sub_100043844(uint64_t a1, sqlite3_stmt *a2)
{
  [*(id *)(a1 + 64) bindWhereClause:a2 whereDict:*(void *)(a1 + 32) cferror:*(void *)(*(void *)(a1 + 56) + 8) + 24];
  uint64_t v4 = *(void *)(a1 + 72);
  uint64_t v5 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_100043928;
  v6[3] = &unk_1002F8070;
  id v7 = *(id *)(a1 + 40);
  id v9 = a2;
  id v8 = *(id *)(a1 + 48);
  sub_1000275B0(v4, a2, v5, (uint64_t)v6);
}

void sub_100043928(void *a1)
{
  v5[0] = 0;
  v5[1] = v5;
  _DWORD v5[2] = 0x3032000000;
  v5[3] = sub_100042A3C;
  void v5[4] = sub_100042A4C;
  id v6 = (id)0xAAAAAAAAAAAAAAAALL;
  id v6 = objc_alloc_init((Class)NSMutableDictionary);
  uint64_t v2 = (void *)a1[4];
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_100043A3C;
  v4[3] = &unk_1002F8048;
  uint64_t v3 = a1[6];
  v4[4] = v5;
  v4[5] = v3;
  [v2 enumerateObjectsUsingBlock:v4];
  (*(void (**)(void))(a1[5] + 16))();
  _Block_object_dispose(v5, 8);
}

void sub_100043A24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100043A3C(uint64_t a1, void *a2, int a3)
{
  uint64_t v5 = *(sqlite3_stmt **)(a1 + 40);
  id v6 = a2;
  id v7 = sqlite3_column_text(v5, a3);
  id v8 = [CKKSSQLResult alloc];
  if (v7)
  {
    uint64_t v9 = +[NSString stringWithUTF8String:v7];
  }
  else
  {
    uint64_t v9 = 0;
  }
  id v11 = (id)v9;
  id v10 = [(CKKSSQLResult *)v8 init:v9];
  [*(id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) setObject:v10 forKeyedSubscript:v6];

  if (v7)
  {
  }
}

uint64_t sub_100043DA4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = [*(id *)(a1 + 32) componentsJoinedByString:@", "];
  uint64_t v5 = +[CKKSSQLDatabaseObject makeWhereClause:*(void *)(a1 + 40)];
  id v6 = +[CKKSSQLDatabaseObject groupByClause:*(void *)(a1 + 48)];
  id v7 = +[CKKSSQLDatabaseObject orderByClause:*(void *)(a1 + 56)];
  if (*(uint64_t *)(a1 + 88) < 1)
  {
    id v8 = &stru_10030AA90;
  }
  else
  {
    id v8 = +[NSString stringWithFormat:@" LIMIT %lu", *(void *)(a1 + 88)];
  }
  id v9 = [[objc_alloc((Class)NSString) initWithFormat:@"SELECT %@ FROM %@%@%@%@%@;",
         v4,
         *(void *)(a1 + 64),
         v5,
         v6,
         v7,
         v8);
  id v10 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 80) + 8) + 24);
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_100043F78;
  v14[3] = &unk_1002F8098;
  uint64_t v19 = *(void *)(a1 + 96);
  id v11 = *(id *)(a1 + 40);
  uint64_t v12 = *(void *)(a1 + 80);
  id v15 = v11;
  uint64_t v18 = v12;
  uint64_t v20 = a2;
  id v16 = *(id *)(a1 + 32);
  id v17 = *(id *)(a1 + 72);
  sub_10002742C(a2, (uint64_t)v9, v10, (uint64_t)v14);

  return 1;
}

void sub_100043F78(uint64_t a1, sqlite3_stmt *a2)
{
  [*(id *)(a1 + 64) bindWhereClause:a2 whereDict:*(void *)(a1 + 32) cferror:*(void *)(*(void *)(a1 + 56) + 8) + 24];
  uint64_t v4 = *(void *)(a1 + 72);
  uint64_t v5 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_10004405C;
  v6[3] = &unk_1002F8070;
  id v7 = *(id *)(a1 + 40);
  id v9 = a2;
  id v8 = *(id *)(a1 + 48);
  sub_1000275B0(v4, a2, v5, (uint64_t)v6);
}

void sub_10004405C(void *a1)
{
  v5[0] = 0;
  v5[1] = v5;
  _DWORD v5[2] = 0x3032000000;
  v5[3] = sub_100042A3C;
  void v5[4] = sub_100042A4C;
  id v6 = (id)0xAAAAAAAAAAAAAAAALL;
  id v6 = objc_alloc_init((Class)NSMutableDictionary);
  uint64_t v2 = (void *)a1[4];
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_100044170;
  v4[3] = &unk_1002F8048;
  uint64_t v3 = a1[6];
  v4[4] = v5;
  v4[5] = v3;
  [v2 enumerateObjectsUsingBlock:v4];
  (*(void (**)(void))(a1[5] + 16))();
  _Block_object_dispose(v5, 8);
}

void sub_100044158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100044170(uint64_t a1, void *a2, int a3)
{
  uint64_t v5 = *(sqlite3_stmt **)(a1 + 40);
  id v6 = a2;
  id v7 = sqlite3_column_text(v5, a3);
  id v8 = [CKKSSQLResult alloc];
  if (v7)
  {
    uint64_t v9 = +[NSString stringWithUTF8String:v7];
  }
  else
  {
    uint64_t v9 = 0;
  }
  id v11 = (id)v9;
  id v10 = [(CKKSSQLResult *)v8 init:v9];
  [*(id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) setObject:v10 forKeyedSubscript:v6];

  if (v7)
  {
  }
}

void sub_1000443C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000443DC(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = +[CKKSSQLDatabaseObject makeWhereClause:*(void *)(a1 + 32)];
  id v5 = [objc_alloc((Class)NSString) initWithFormat:@"DELETE FROM %@%@;",
         *(void *)(a1 + 40),
         v4);
  id v6 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_1000444E8;
  void v10[3] = &unk_1002F7FF8;
  uint64_t v13 = *(void *)(a1 + 56);
  id v7 = *(id *)(a1 + 32);
  uint64_t v8 = *(void *)(a1 + 48);
  id v11 = v7;
  uint64_t v12 = v8;
  uint64_t v14 = a2;
  sub_10002742C(a2, (uint64_t)v5, v6, (uint64_t)v10);

  return 1;
}

uint64_t sub_1000444E8(uint64_t a1, sqlite3_stmt *a2)
{
  [*(id *)(a1 + 48) bindWhereClause:a2 whereDict:*(void *)(a1 + 32) cferror:*(void *)(*(void *)(a1 + 40) + 8) + 24];
  uint64_t v4 = *(void *)(a1 + 56);
  id v5 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);

  return sub_1000275B0(v4, a2, v5, (uint64_t)&stru_1002F7FD0);
}

void sub_10004463C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100044654(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [*(id *)(a1 + 32) objectForKeyedSubscript:v3];
  uint64_t v5 = objc_opt_class();
  if (v5 == objc_opt_class())
  {

    goto LABEL_15;
  }
  id v6 = [*(id *)(a1 + 32) objectForKeyedSubscript:v3];
  uint64_t v7 = objc_opt_class();
  uint64_t v8 = objc_opt_class();

  if (v7 == v8)
  {
LABEL_15:
    id v17 = [*(id *)(a1 + 32) objectForKeyedSubscript:v3];
    id v23 = *(sqlite3_stmt **)(a1 + 48);
    uint64_t v24 = *(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    uint64_t v25 = [v17 value];
    sub_10000E8B0(v23, v24, v25, *(CFTypeRef **)(a1 + 56));

    ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
LABEL_16:

    goto LABEL_17;
  }
  uint64_t v9 = [*(id *)(a1 + 32) objectForKeyedSubscript:v3];
  uint64_t v10 = objc_opt_class();
  uint64_t v11 = objc_opt_class();

  if (v10 != v11)
  {
    uint64_t v12 = [*(id *)(a1 + 32) objectForKeyedSubscript:v3];
    uint64_t v13 = objc_opt_class();
    uint64_t v14 = objc_opt_class();

    if (v13 != v14)
    {
      id v15 = [*(id *)(a1 + 32) objectForKeyedSubscript:v3];
      unsigned int v16 = [v15 isMemberOfClass:objc_opt_class()];

      if (!v16)
      {
        uint64_t v26 = *(sqlite3_stmt **)(a1 + 48);
        uint64_t v27 = *(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
        long long v28 = [*(id *)(a1 + 32) objectForKeyedSubscript:v3];
        sub_10000E8B0(v26, v27, v28, *(CFTypeRef **)(a1 + 56));

        ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
        goto LABEL_17;
      }
      id v17 = [*(id *)(a1 + 32) objectForKeyedSubscript:v3];
      long long v29 = 0u;
      long long v30 = 0u;
      long long v31 = 0u;
      long long v32 = 0u;
      uint64_t v18 = [v17 values];
      id v19 = [v18 countByEnumeratingWithState:&v29 objects:v33 count:16];
      if (v19)
      {
        id v20 = v19;
        uint64_t v21 = *(void *)v30;
        do
        {
          id v22 = 0;
          do
          {
            if (*(void *)v30 != v21) {
              objc_enumerationMutation(v18);
            }
            sub_10000E8B0(*(sqlite3_stmt **)(a1 + 48), *(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), *(const __CFString **)(*((void *)&v29 + 1) + 8 * (void)v22), *(CFTypeRef **)(a1 + 56));
            ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
            id v22 = (char *)v22 + 1;
          }
          while (v20 != v22);
          id v20 = [v18 countByEnumeratingWithState:&v29 objects:v33 count:16];
        }
        while (v20);
      }

      goto LABEL_16;
    }
  }
LABEL_17:
}

void sub_100044A50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100044A68(uint64_t a1, void *a2)
{
  id v3 = *(void **)(a1 + 32);
  int v4 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  id v5 = a2;
  if (v4) {
    CFStringRef v6 = @", ";
  }
  else {
    CFStringRef v6 = @" ORDER BY ";
  }
  [v3 appendFormat:v6];
  [*(id *)(a1 + 32) appendFormat:@"%@", v5];

  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
}

void sub_100044BE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100044BF8(uint64_t a1, void *a2)
{
  id v3 = *(void **)(a1 + 32);
  int v4 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  id v5 = a2;
  if (v4) {
    CFStringRef v6 = @", ";
  }
  else {
    CFStringRef v6 = @" GROUP BY ";
  }
  [v3 appendFormat:v6];
  [*(id *)(a1 + 32) appendFormat:@"%@", v5];

  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
}

void sub_100044D70(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100044D88(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
    CFStringRef v7 = @" AND ";
  }
  else {
    CFStringRef v7 = @" WHERE ";
  }
  [*(id *)(a1 + 32) appendFormat:v7];
  uint64_t v8 = objc_opt_class();
  if (v8 == objc_opt_class())
  {
    uint64_t v11 = *(void **)(a1 + 32);
    uint64_t v12 = (char *)[v6 sqlOp];
    if ((unint64_t)(v12 - 2) > 2) {
      CFStringRef v13 = @"=";
    }
    else {
      CFStringRef v13 = off_1002F8180[(void)(v12 - 2)];
    }
    long long v30 = v5;
    CFStringRef v32 = v13;
    CFStringRef v18 = @"%@%@(?)";
    goto LABEL_32;
  }
  uint64_t v9 = objc_opt_class();
  if (v9 == objc_opt_class())
  {
    id v14 = v6;
    id v15 = *(void **)(a1 + 32);
    unint64_t v16 = (unint64_t)[v14 sqlOp] - 2;
    if (v16 > 2) {
      CFStringRef v17 = @"=";
    }
    else {
      CFStringRef v17 = off_1002F8180[v16];
    }
    id v28 = [v14 columnName];
    CFStringRef v29 = @"parentKeyUUID";
    if (v28 == (id)1) {
      CFStringRef v29 = @"uuid";
    }
    [v15 appendFormat:@"%@%@%@", v5, v17, v29];
LABEL_29:

    goto LABEL_33;
  }
  uint64_t v10 = objc_opt_class();
  if (v10 == objc_opt_class())
  {
    uint64_t v11 = *(void **)(a1 + 32);
    id v19 = (char *)[v6 sqlOp];
    if ((unint64_t)(v19 - 2) > 2) {
      CFStringRef v20 = @"=";
    }
    else {
      CFStringRef v20 = off_1002F8180[(void)(v19 - 2)];
    }
    __int16 v33 = v5;
    CFStringRef v34 = v20;
    long long v30 = v5;
    CFStringRef v32 = v5;
    CFStringRef v18 = @"(%@ is NULL OR (%@ IS NOT NULL AND %@%@(?)))";
LABEL_32:
    [v11 appendFormat:v18, v30, v32, v33, v34];
    goto LABEL_33;
  }
  if (![v6 isMemberOfClass:objc_opt_class()])
  {
    if (![v6 isMemberOfClass:objc_opt_class()])
    {
      [*(id *)(a1 + 32) appendFormat:@"%@=(?)", v5, v31, v33, v34];
      goto LABEL_33;
    }
    id v14 = v6;
    uint64_t v21 = [v14 values];
    id v22 = +[NSMutableArray arrayWithCapacity:](NSMutableArray, "arrayWithCapacity:", [v21 count]);

    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    id v23 = [v14 values];
    uint64_t v24 = (char *)[v23 countByEnumeratingWithState:&v35 objects:v39 count:16];
    if (v24)
    {
      uint64_t v25 = v24;
      uint64_t v26 = *(void *)v36;
      while (1)
      {
        if (*(void *)v36 != v26) {
          objc_enumerationMutation(v23);
        }
        [v22 addObject:@"?"];
        if (!--v25)
        {
          uint64_t v25 = (char *)[v23 countByEnumeratingWithState:&v35 objects:v39 count:16];
          if (!v25) {
            break;
          }
        }
      }
    }

    uint64_t v27 = [v22 componentsJoinedByString:@", "];
    [*(id *)(a1 + 32) appendFormat:@"%@ IN (%@)", v5, v27];

    goto LABEL_29;
  }
  [*(id *)(a1 + 32) appendFormat:@"%@ is NULL", v5, v31, v33, v34];
LABEL_33:
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
}

void sub_100045270(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10004528C(uint64_t a1, uint64_t a2)
{
  int v4 = [*(id *)(a1 + 32) allKeys];
  id v5 = [v4 componentsJoinedByString:@", "];

  id v6 = objc_alloc_init((Class)NSMutableString);
  CFStringRef v7 = [*(id *)(a1 + 32) allKeys];
  id v8 = [v7 count];

  if (v8)
  {
    unint64_t v9 = 0;
    do
    {
      if (v9) {
        CFStringRef v10 = @",?";
      }
      else {
        CFStringRef v10 = @"?";
      }
      [v6 appendString:v10];
      ++v9;
      uint64_t v11 = [*(id *)(a1 + 32) allKeys];
      id v12 = [v11 count];
    }
    while (v9 < (unint64_t)v12);
  }
  id v13 = [[objc_alloc((Class)NSString) initWithFormat:@"INSERT OR REPLACE into %@ (%@) VALUES (%@);",
          *(void *)(a1 + 40),
          v5,
          v6);
  id v14 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472;
  void v18[2] = sub_100045434;
  v18[3] = &unk_1002F7F10;
  id v15 = *(id *)(a1 + 32);
  uint64_t v16 = *(void *)(a1 + 48);
  id v19 = v15;
  uint64_t v20 = v16;
  uint64_t v21 = a2;
  sub_10002742C(a2, (uint64_t)v13, v14, (uint64_t)v18);

  return 1;
}

void sub_100045434(uint64_t a1, sqlite3_stmt *a2)
{
  int v4 = [*(id *)(a1 + 32) allKeys];
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_100045504;
  v7[3] = &unk_1002F7EA8;
  CFStringRef v10 = a2;
  id v5 = *(id *)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 40);
  id v8 = v5;
  uint64_t v9 = v6;
  [v4 enumerateObjectsUsingBlock:v7];

  sub_1000275B0(*(void *)(a1 + 48), a2, (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), (uint64_t)&stru_1002F7EE8);
}

void sub_100045504(uint64_t a1, uint64_t a2, int a3)
{
  int v4 = *(sqlite3_stmt **)(a1 + 48);
  uint64_t v5 = (a3 + 1);
  uint64_t v6 = [*(id *)(a1 + 32) objectForKeyedSubscript:a2];
  sub_10000E8B0(v4, v5, v6, (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
}

BOOL sub_10004581C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a3;
  if ([a2 hasPrefix:@"G:"])
  {
    [*(id *)(a1 + 32) timeIntervalSinceDate:v5];
    BOOL v7 = v6 > 0.0;
  }
  else
  {
    BOOL v7 = 0;
  }

  return v7;
}

BOOL sub_100045D60(uint64_t a1)
{
  [*(id *)(a1 + 32) timeIntervalSinceDate:];
  return v2 > (double)*(int *)(a1 + 40);
}

id sub_10004695C(void *a1)
{
  id v1 = a1;
  double v2 = [v1 zoneName];
  unsigned int v3 = [v2 hasPrefix:@"group-"];

  if (v3)
  {
    int v4 = [v1 zoneName];
    id v5 = [v4 substringFromIndex:[@"group-" length]];
  }
  else
  {
    id v5 = 0;
  }

  return v5;
}

void sub_100046A00(void *a1, void *a2)
{
  id v3 = a1;
  id v5 = [a2 displayName];
  int v4 = [v3 encryptedValues];

  [v4 setObject:v5 forKeyedSubscript:@"displayName"];
}

id sub_100046A80(void *a1)
{
  id v1 = a1;
  double v2 = [v1 userIdentity];
  id v3 = [v2 lookupInfo];

  id v17 = objc_alloc((Class)KCSharingParticipant);
  int v4 = [v1 userIdentity];
  id v5 = [v4 userRecordID];
  double v6 = [v5 recordName];
  BOOL v7 = sub_100046C24(v3);
  id v8 = v1;
  if ([v8 role] == (id)1) {
    uint64_t v9 = 2;
  }
  else {
    uint64_t v9 = [[v8 role] == (id)2 || [v8 permission] == (id)3];
  }

  id v10 = [v8 isCurrentUser];
  unint64_t v11 = (unint64_t)[v8 acceptanceStatus] - 1;
  if (v11 > 3) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = qword_100265660[v11];
  }
  id v13 = [v8 invitationToken];

  id v14 = [v13 sharingInvitationData];
  id v15 = [v17 initWithParticipantID:v6 handle:v7 permissionLevel:v9 isCurrentUser:v10 inviteStatus:v12 sharingInvitationData:v14];

  return v15;
}

id sub_100046C24(void *a1)
{
  id v1 = a1;
  double v2 = v1;
  if (v1)
  {
    id v3 = [v1 emailAddress];
    int v4 = v3;
    if (v3)
    {
      id v5 = v3;
    }
    else
    {
      id v6 = [v2 phoneNumber];
      BOOL v7 = v6;
      if (v6)
      {
        if ([v6 hasPrefix:@"+"])
        {
          id v8 = v7;
        }
        else
        {
          id v8 = [@"+" stringByAppendingString:v7];
        }
        id v5 = v8;
      }
      else
      {
        id v5 = 0;
      }
    }
  }
  else
  {
    id v5 = 0;
  }

  return v5;
}

id sub_100046CF4(void *a1)
{
  id v1 = a1;
  if (v1)
  {
    double v2 = +[NSMutableArray array];
    long long v20 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    id v3 = [v1 participants];
    id v4 = [v3 countByEnumeratingWithState:&v20 objects:v26 count:16];
    if (v4)
    {
      id v5 = v4;
      uint64_t v6 = *(void *)v21;
      do
      {
        for (uint64_t i = 0; i != v5; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v21 != v6) {
            objc_enumerationMutation(v3);
          }
          id v8 = sub_100046A80(*(void **)(*((void *)&v20 + 1) + 8 * i));
          [v2 addObject:v8];
        }
        id v5 = [v3 countByEnumeratingWithState:&v20 objects:v26 count:16];
      }
      while (v5);
    }

    uint64_t v9 = [v1 recordID];
    id v10 = [v9 zoneID];
    unint64_t v11 = sub_10004695C(v10);

    if (v11)
    {
      id v12 = objc_alloc((Class)KCSharingGroup);
      id v13 = [v1 encryptedValues];
      id v14 = [v13 objectForKeyedSubscript:@"displayName"];
      id v15 = [v1 URL];
      id v16 = [v12 initWithGroupID:v11 participants:v2 displayName:v14 shareURL:v15];
    }
    else
    {
      id v13 = KCSharingLogObject();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v18 = [v1 recordID];
        id v19 = [v18 zoneID];
        *(_DWORD *)long long buf = 138412290;
        uint64_t v25 = v19;
        _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Zone ID \"%@\" did not contain KCSharingGroupID", buf, 0xCu);
      }
      id v16 = 0;
    }
  }
  else
  {
    double v2 = KCSharingLogObject();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "Can't create a KCSharingGroup without a CKShare", buf, 2u);
    }
    id v16 = 0;
  }

  return v16;
}

void *sub_100046FBC(void *result, uint64_t a2, uint64_t a3)
{
  if (result)
  {
    id v3 = result;
    uint64_t result = +[NSError errorWithDomain:@"KCSharingErrorDomain" code:a2 userInfo:a3];
    *id v3 = result;
  }
  return result;
}

BOOL sub_10004700C(void *a1)
{
  id v1 = a1;
  double v2 = [v1 domain];
  if ([v2 isEqualToString:@"KCSharingErrorDomain"]) {
    BOOL v3 = [v1 code] == (id)8;
  }
  else {
    BOOL v3 = 0;
  }

  return v3;
}

void sub_100047078(void *a1, uint64_t a2, void *a3, void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  if (a1)
  {
    NSErrorUserInfoKey v17 = NSLocalizedDescriptionKey;
    id v12 = a4;
    id v13 = a3;
    id v14 = [objc_alloc((Class)NSString) initWithFormat:v12 arguments:&a9];

    id v18 = v14;
    id v15 = +[NSDictionary dictionaryWithObjects:&v18 forKeys:&v17 count:1];
    id v16 = [v15 mutableCopy];

    [v16 setObject:v13 forKeyedSubscript:NSUnderlyingErrorKey];
    *a1 = +[NSError errorWithDomain:@"KCSharingErrorDomain" code:a2 userInfo:v16];
  }
}

void sub_1000473C0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = sub_10000B070("escrowrequest");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v5 = [*(id *)(a1 + 32) numberOfRecordsUploaded];
    v6[0] = 67109378;
    v6[1] = v5;
    __int16 v7 = 2112;
    id v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Uploaded %d records with error %@", (uint8_t *)v6, 0x12u);
  }

  (*(void (**)(void, id, id))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), [*(id *)(a1 + 32) numberOfRecordsUploaded], v3);
}

void sub_1000486F0(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = sub_10000B070("octagon");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Notified that the device name has changed", v6, 2u);
  }

  unsigned int v5 = [a3 deviceNameUpdateListeners];
  [v5 iterateListeners:&stru_1002F8200];
}

void sub_100048784(id a1, OTDeviceInformationNameUpdateListener *a2)
{
}

void sub_100048930(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000489D8(id a1)
{
  memset(&__b, 170, sizeof(__b));
  uname(&__b);
  uint64_t v1 = +[NSString stringWithCString:__b.machine encoding:4];
  double v2 = (void *)qword_10035CCF8;
  qword_10035CCF8 = v1;
}

void sub_100049148(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22)
{
  objc_destroyWeak(v22);
  _Block_object_dispose(&a22, 8);
  objc_destroyWeak((id *)(v23 - 56));
  _Unwind_Resume(a1);
}

uint64_t sub_10004917C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10004918C(uint64_t a1)
{
}

uint64_t sub_100049194(uint64_t a1)
{
  double v2 = [CKKSCondition alloc];
  id v3 = [*(id *)(a1 + 32) octagonInformationInitialized];
  id v4 = [(CKKSCondition *)v2 initToChain:v3];
  [*(id *)(a1 + 32) setOctagonInformationInitialized:v4];

  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = [*(id *)(a1 + 32) octagonInformationInitialized];

  return _objc_release_x1();
}

void sub_10004922C(uint64_t a1, uint64_t a2, void *a3, uint64_t a4, uint64_t a5, void *a6)
{
  id v9 = a3;
  id v10 = a6;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v12 = [WeakRetained queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100049324;
  block[3] = &unk_1002F8278;
  id v17 = v10;
  id v18 = WeakRetained;
  uint64_t v13 = *(void *)(a1 + 32);
  id v19 = v9;
  uint64_t v20 = v13;
  uint64_t v21 = a2;
  id v14 = v9;
  id v15 = v10;
  dispatch_sync(v12, block);
}

id sub_100049324(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = sub_1000CD884(@"ckksaccount", 0);
  id v4 = v3;
  if (v2)
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      unsigned int v5 = *(void **)(a1 + 32);
      int v12 = 138412290;
      uint64_t v13 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "error getting octagon status: %@", (uint8_t *)&v12, 0xCu);
    }

    uint64_t v6 = [OTCliqueStatusWrapper alloc];
    uint64_t v7 = -1;
  }
  else
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      id v8 = OTCliqueStatusToString();
      uint64_t v9 = *(void *)(a1 + 48);
      int v12 = 138412546;
      uint64_t v13 = v8;
      __int16 v14 = 2112;
      uint64_t v15 = v9;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Caching octagon status as (%@, %@)", (uint8_t *)&v12, 0x16u);
    }
    uint64_t v6 = [OTCliqueStatusWrapper alloc];
    uint64_t v7 = *(void *)(a1 + 64);
  }
  id v10 = [(OTCliqueStatusWrapper *)v6 initWithStatus:v7];
  [*(id *)(a1 + 40) setOctagonStatus:v10];

  [*(id *)(a1 + 40) setOctagonPeerID:*(void *)(a1 + 48)];
  return [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) fulfill];
}

void sub_100049708(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) ckChangeListeners];
  id v3 = [v2 keyEnumerator];

  uint64_t v4 = [v3 nextObject];
  if (v4)
  {
    uint64_t v6 = v4;
    *(void *)&long long v5 = 138412290;
    long long v12 = v5;
    do
    {
      uint64_t v7 = [*(id *)(a1 + 32) ckChangeListeners:v12];
      id v8 = [v7 objectForKey:v6];

      uint64_t v9 = sub_1000CD884(@"ckksaccountblock", 0);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)location = v12;
        *(void *)&location[4] = v8;
        _os_log_debug_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEBUG, "Starting blocking for listener %@", location, 0xCu);
      }

      *(void *)location = 0xAAAAAAAAAAAAAAAALL;
      objc_initWeak((id *)location, v8);
      id v10 = *(NSObject **)(a1 + 40);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_1000498F8;
      block[3] = &unk_1003077A0;
      objc_copyWeak(&v14, (id *)location);
      dispatch_group_async(v10, v6, block);
      objc_destroyWeak(&v14);
      objc_destroyWeak((id *)location);

      uint64_t v11 = [v3 nextObject];

      uint64_t v6 = v11;
    }
    while (v11);
  }
}

void sub_1000498F8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = sub_1000CD884(@"ckksaccountblock", 0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    int v3 = 138412290;
    id v4 = WeakRetained;
    _os_log_debug_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Done blocking for listener %@", (uint8_t *)&v3, 0xCu);
  }
}

void sub_100049BC8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = [*(id *)(a1 + 40) currentCKAccountInfo];
  [WeakRetained cloudkitAccountStateChange:v2 to:v3];
}

intptr_t sub_10004A170(uint64_t a1)
{
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_10004A328(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10004A354(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = (id *)(a1 + 32);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v9 = WeakRetained;
  if (WeakRetained)
  {
    id v10 = [WeakRetained queue];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10004A4B0;
    block[3] = &unk_1003077C8;
    objc_copyWeak(&v15, v7);
    id v13 = v5;
    id v14 = v6;
    dispatch_async(v10, block);

    objc_destroyWeak(&v15);
  }
  else
  {
    uint64_t v11 = sub_1000CD884(@"ckks-sos", 0);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Received fetchCirclePeerID callback with null AccountStateTracker", buf, 2u);
    }
  }
}

void sub_10004A4B0(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v3 = [WeakRetained currentCircleStatus];
  if (v3
    && (id v4 = (void *)v3,
        [WeakRetained currentCircleStatus],
        id v5 = objc_claimAutoreleasedReturnValue(),
        unsigned int v6 = [v5 status],
        v5,
        v4,
        !v6))
  {
    id v8 = sub_1000CD884(@"ckks-sos", 0);
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(a1 + 32);
      uint64_t v10 = *(void *)(a1 + 40);
      int v12 = 138412546;
      uint64_t v13 = v9;
      __int16 v14 = 2112;
      uint64_t v15 = v10;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Circle peerID is: %@ %@", (uint8_t *)&v12, 0x16u);
    }

    [WeakRetained setAccountCirclePeerID:*(void *)(a1 + 32)];
    [WeakRetained setAccountCirclePeerIDError:*(void *)(a1 + 40)];
    uint64_t v11 = [WeakRetained accountCirclePeerIDInitialized];
    [v11 fulfill];
  }
  else
  {
    uint64_t v7 = sub_1000CD884(@"ckks-sos", 0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v12) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Out of circle but still received a fetchCirclePeerID callback", (uint8_t *)&v12, 2u);
    }

    [WeakRetained setAccountCirclePeerID:0];
    [WeakRetained setAccountCirclePeerIDError:0];
  }
}

intptr_t sub_10004A754(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) currentCircleStatus];
  if (!v2
    || (uint64_t v3 = (void *)v2,
        [*(id *)(a1 + 32) currentCircleStatus],
        id v4 = objc_claimAutoreleasedReturnValue(),
        unsigned __int8 v5 = [v4 isEqual:*(void *)(a1 + 40)],
        v4,
        v3,
        (v5 & 1) == 0))
  {
    unsigned int v6 = sub_1000CD884(@"ckks-sos", 0);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 40);
      int v11 = 138412290;
      uint64_t v12 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "moving to circle status: %@", (uint8_t *)&v11, 0xCu);
    }

    [*(id *)(a1 + 32) setCurrentCircleStatus:*(void *)(a1 + 40)];
    if (![*(id *)(a1 + 40) status])
    {
      id v8 = +[CKKSAnalytics logger];
      uint64_t v9 = +[NSDate date];
      [v8 setDateProperty:v9 forKey:@"lastInCircle"];
    }
    [*(id *)(a1 + 32) _onqueueUpdateCirclePeerID:*(void *)(a1 + 40)];
  }
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 48));
}

void sub_10004A9EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10004AA10(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = (id *)(a1 + 32);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v9 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v10 = [WeakRetained queue];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10004AB6C;
    block[3] = &unk_1003077C8;
    objc_copyWeak(&v15, v7);
    id v13 = v5;
    id v14 = v6;
    dispatch_async(v10, block);

    objc_destroyWeak(&v15);
  }
  else
  {
    int v11 = sub_1000CD884(@"ckksaccount", 0);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Received fetchCurrentDeviceIDWithCompletionHandler callback with null AccountStateTracker", buf, 2u);
    }
  }
}

void sub_10004AB6C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v3 = [WeakRetained currentCKAccountInfo];
  id v4 = [v3 accountStatus];

  id v5 = sub_1000CD884(@"ckksaccount", 0);
  id v6 = v5;
  if (v4 == (id)1)
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = [WeakRetained container];
      id v8 = [v7 options];
      uint64_t v9 = [v8 accountOverrideInfo];
      uint64_t v10 = [v9 altDSID];
      uint64_t v11 = *(void *)(a1 + 32);
      uint64_t v12 = *(void *)(a1 + 40);
      int v14 = 138412802;
      id v15 = v10;
      __int16 v16 = 2112;
      uint64_t v17 = v11;
      __int16 v18 = 2112;
      uint64_t v19 = v12;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "CloudKit deviceID is(altDSID: %@): %@ %@", (uint8_t *)&v14, 0x20u);
    }
    [WeakRetained setCkdeviceID:*(void *)(a1 + 32)];
    [WeakRetained setCkdeviceIDError:*(void *)(a1 + 40)];
    id v13 = [WeakRetained ckdeviceIDInitialized];
    [v13 fulfill];
  }
  else
  {
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v14) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "Logged back out but still received a fetchCurrentDeviceIDWithCompletionHandler callback", (uint8_t *)&v14, 2u);
    }

    [WeakRetained setCkdeviceID:0];
    [WeakRetained setCkdeviceIDError:0];
  }
}

void sub_10004AE6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10004AE88(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v8 = WeakRetained;
  if (v6)
  {
    uint64_t v9 = sub_1000CD884(@"ckksaccount", 0);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = [v8 container];
      uint64_t v11 = [v10 options];
      uint64_t v12 = [v11 accountOverrideInfo];
      id v13 = [v12 altDSID];
      *(_DWORD *)long long buf = 138412546;
      uint64_t v20 = v13;
      __int16 v21 = 2112;
      id v22 = v6;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "error getting account info(altDSID: %@): %@", buf, 0x16u);
    }
    int v14 = [v8 fetchCKAccountStatusScheduler];
    [v14 trigger];

    dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
  }
  else
  {
    id v15 = [WeakRetained queue];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10004B088;
    block[3] = &unk_100305720;
    void block[4] = v8;
    id v17 = v5;
    id v18 = *(id *)(a1 + 32);
    dispatch_sync(v15, block);
  }
}

id sub_10004B088(uint64_t a1)
{
  [*(id *)(a1 + 32) setFirstCKAccountFetch:1];
  uint64_t v2 = sub_1000CD884(@"ckksaccount", 0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = [*(id *)(a1 + 32) container];
    id v4 = [v3 options];
    id v5 = [v4 accountOverrideInfo];
    id v6 = [v5 altDSID];
    uint64_t v7 = *(void *)(a1 + 40);
    int v9 = 138412546;
    uint64_t v10 = v6;
    __int16 v11 = 2112;
    uint64_t v12 = v7;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "received CK Account info(altDSID: %@): %@", (uint8_t *)&v9, 0x16u);
  }
  return [*(id *)(a1 + 32) _onqueueUpdateAccountState:*(void *)(a1 + 40) deliveredSemaphore:*(void *)(a1 + 48)];
}

void sub_10004B29C(id *a1)
{
  uint64_t v2 = [a1[4] ckChangeListeners];
  uint64_t v3 = [v2 objectEnumerator];

  uint64_t v4 = [v3 nextObject];
  if (v4)
  {
    id v5 = (id)v4;
    char v6 = 0;
    do
    {
      v6 |= v5 == a1[5];
      uint64_t v7 = [v3 nextObject];

      id v5 = (id)v7;
    }
    while (v7);
  }
  else
  {
    char v6 = 0;
  }
  if (a1[5] && (v6 & 1) == 0)
  {
    id v8 = +[NSString stringWithFormat:@"ck-account-state-%@", a1[5]];
    int v9 = (const char *)[v8 UTF8String];
    uint64_t v10 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
    dispatch_queue_t v11 = dispatch_queue_create(v9, v10);

    uint64_t v12 = [a1[4] ckChangeListeners];
    [v12 setObject:a1[5] forKey:v11];

    id v13 = sub_1000CD884(@"ckksaccount-ck", 0);
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      id v19 = a1[5];
      *(_DWORD *)long long buf = 138412290;
      id v25 = v19;
      _os_log_debug_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "adding a new listener: %@", buf, 0xCu);
    }

    if ([a1[4] firstCKAccountFetch])
    {
      int v14 = sub_1000CD884(@"ckksaccount-ck", 0);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
      {
        id v20 = a1[5];
        __int16 v21 = [a1[4] currentCKAccountInfo];
        *(_DWORD *)long long buf = 138412546;
        id v25 = v20;
        __int16 v26 = 2112;
        uint64_t v27 = v21;
        _os_log_debug_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "notifying new listener %@ of current state %@", buf, 0x16u);
      }
      dispatch_group_t v15 = dispatch_group_create();
      if (v15)
      {
        __int16 v16 = v15;
        [a1[4] _onqueueDeliverCurrentCloudKitState:a1[5] listenerQueue:v11 oldStatus:0 group:v15];
        id v17 = [a1[4] queue];
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_10004B5F8;
        block[3] = &unk_100308558;
        id v23 = a1[6];
        dispatch_group_notify(v16, v17, block);

LABEL_20:
        goto LABEL_21;
      }
      id v18 = sub_1000CD884(@"ckksaccount-ck", 0);
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Unable to get dispatch group.", buf, 2u);
      }
    }
    dispatch_semaphore_signal((dispatch_semaphore_t)a1[6]);
    goto LABEL_20;
  }
  dispatch_semaphore_signal((dispatch_semaphore_t)a1[6]);
LABEL_21:
}

intptr_t sub_10004B5F8(uint64_t a1)
{
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_10004BC90(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 128));
  _Unwind_Resume(a1);
}

void sub_10004BCCC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v1 = [WeakRetained notifyCircleChange:0];
}

void sub_10004BD18(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    [WeakRetained performInitialDispatches];
  }
}

void sub_10004BD78(uint64_t a1)
{
  uint64_t v2 = sub_1000CD884(@"ckksaccount", 0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)id v5 = 0;
    _os_log_debug_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEBUG, "Retrying CK account state fetch", v5, 2u);
  }

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v4 = [WeakRetained notifyCKAccountStatusChange:0];
}

void sub_10004C250(uint64_t a1)
{
  CFTypeRef v5 = 0;
  uint64_t v2 = (void *)sub_100225A7C(&v5);
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = (void *)v5;
  (*(void (**)(void))(v3 + 16))();
}

NSDictionary *__cdecl sub_10004C338(id a1)
{
  id v1 = +[NSMutableDictionary dictionary];
  uint64_t v2 = +[CKKSAnalytics logger];
  uint64_t v3 = [v2 datePropertyForKey:@"ERSPending"];

  if (v3)
  {
    id v4 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", +[CKKSAnalytics fuzzyDaysSinceDate:v3]);
    [v1 setObject:v4 forKeyedSubscript:@"ERSPending"];
  }

  return (NSDictionary *)v1;
}

void sub_10004D86C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

intptr_t sub_10004D884(uint64_t a1, char a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = a2;
  return dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_10004DB88(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

uint64_t sub_10004DBC0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10004DBD0(uint64_t a1)
{
}

void sub_10004DBD8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
  id v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v5;
  id v11 = v5;

  uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v6;
}

void sub_10004DDAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v7 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_10004DDD0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
  id v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v5;
  id v11 = v5;

  uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v6;
}

void sub_10004DFB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10004DFCC(uint64_t a1, void *a2)
{
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
  id v4 = a2;
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_10004E114(id a1)
{
  id v1 = [EscrowRequestServer alloc];
  uint64_t v2 = +[CKKSLockStateTracker globalTracker];
  uint64_t v3 = [(EscrowRequestServer *)v1 initWithLockStateTracker:v2];
  id v4 = (void *)qword_10035CD08;
  qword_10035CD08 = (uint64_t)v3;

  id v5 = (void *)qword_10035CD08;

  [v5 setupAnalytics];
}

void sub_10004EF08(id a1, NSError *a2)
{
  uint64_t v2 = a2;
  uint64_t v3 = sub_10000B070("octagon");
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      int v8 = 138412290;
      uint64_t v9 = v2;
      id v5 = "Created TTR with error: %@";
      id v6 = v3;
      uint32_t v7 = 12;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v5, (uint8_t *)&v8, v7);
    }
  }
  else if (v4)
  {
    LOWORD(v8) = 0;
    id v5 = "Created TTR successfully";
    id v6 = v3;
    uint32_t v7 = 2;
    goto LABEL_6;
  }
}

void sub_10004F148(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    uint32_t v7 = sub_1000CD884(@"ckks-cuttlefish", 0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      id v25 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "error fetching tlk shares: %@", buf, 0xCu);
    }

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    int v8 = +[NSMutableArray array];
    long long v19 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    id v18 = v5;
    id v9 = v5;
    id v10 = [v9 countByEnumeratingWithState:&v19 objects:v23 count:16];
    if (v10)
    {
      id v11 = v10;
      uint64_t v12 = *(void *)v20;
      do
      {
        for (uint64_t i = 0; i != v11; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v20 != v12) {
            objc_enumerationMutation(v9);
          }
          int v14 = *(void **)(*((void *)&v19 + 1) + 8 * i);
          dispatch_group_t v15 = [v14 recordType];
          unsigned int v16 = [v15 isEqual:@"tlkshare"];

          if (v16)
          {
            id v17 = [(CKKSCKRecordHolder *)[CKKSTLKShareRecord alloc] initWithCKRecord:v14 contextID:*(void *)(a1 + 32)];
            [v8 addObject:v17];
          }
        }
        id v11 = [v9 countByEnumeratingWithState:&v19 objects:v23 count:16];
      }
      while (v11);
    }

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    id v6 = 0;
    id v5 = v18;
  }
}

void sub_10004F458(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = sub_1000CD884(@"ckks-cuttlefish", 0);
  id v11 = v10;
  if (v9)
  {
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      int v13 = 138412290;
      id v14 = v9;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "error fetching pcs identity: %@", (uint8_t *)&v13, 0xCu);
    }
  }
  else if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = *(void **)(a1 + 32);
    int v13 = 138412290;
    id v14 = v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "fetched pcs identities for the following services: %@", (uint8_t *)&v13, 0xCu);
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_10004F6B4(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id v10 = sub_1000CD884(@"ckks-cuttlefish", 0);
  id v11 = v10;
  if (v9)
  {
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      int v13 = 138412290;
      id v14 = v9;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "error fetching current item: %@", (uint8_t *)&v13, 0xCu);
    }
  }
  else if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = *(void **)(a1 + 32);
    int v13 = 138412290;
    id v14 = v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "fetched current items for CIPs: %@", (uint8_t *)&v13, 0xCu);
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_10004FE18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10004FE30(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10004FE40(uint64_t a1)
{
}

uint64_t sub_10004FE48(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) = +[CKKSPeerProviderState createFromProvider:*(void *)(a1 + 32)];

  return _objc_release_x1();
}

void sub_10004FF58(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) peerChangeListeners];
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_10004FFE8;
  v3[3] = &unk_1002F8AA0;
  v3[4] = *(void *)(a1 + 32);
  [v2 iterateListeners:v3];
}

id sub_10004FFE8(uint64_t a1, void *a2)
{
  return [a2 trustedPeerSetChanged:*(void *)(a1 + 32)];
}

void sub_1000500B0(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) peerChangeListeners];
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_100050140;
  v3[3] = &unk_1002F8AA0;
  v3[4] = *(void *)(a1 + 32);
  [v2 iterateListeners:v3];
}

id sub_100050140(uint64_t a1, void *a2)
{
  return [a2 selfPeerChanged:*(void *)(a1 + 32)];
}

void sub_100050230(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) peerChangeListeners];
  [v2 registerListener:*(void *)(a1 + 40)];
}

void sub_1000503C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000503E0(uint64_t a1)
{
  uint64_t v9 = 0;
  id v10 = &v9;
  uint64_t v11 = 0x3032000000;
  uint64_t v12 = sub_10004FE30;
  int v13 = sub_10004FE40;
  id v14 = 0;
  id location = (id)0xAAAAAAAAAAAAAAAALL;
  objc_initWeak(&location, *(id *)(a1 + 32));
  id v2 = [*(id *)(a1 + 32) cuttlefishXPCWrapper];
  uint64_t v3 = [*(id *)(a1 + 32) specificUser];
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  _DWORD v6[2] = sub_10005056C;
  v6[3] = &unk_1002F8370;
  objc_copyWeak(&v7, &location);
  uint64_t v4 = *(void *)(a1 + 40);
  void v6[4] = &v9;
  void v6[5] = v4;
  [v2 fetchTrustStateWithSpecificUser:v3 reply:v6];

  if (*(void *)(a1 + 48))
  {
    id v5 = (void *)v10[5];
    if (v5) {
      **(void **)(a1 + 48) = v5;
    }
  }
  objc_destroyWeak(&v7);
  objc_destroyWeak(&location);
  _Block_object_dispose(&v9, 8);
}

void sub_10005053C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location, char a17)
{
  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Block_object_dispose(&a17, 8);
  _Unwind_Resume(a1);
}

void sub_10005056C(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (v7)
  {
    uint64_t v9 = sub_10000B070("octagon");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      id v10 = [WeakRetained specificUser];
      *(_DWORD *)long long buf = 138412546;
      uint64_t v41 = v10;
      __int16 v42 = 2112;
      id v43 = v7;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Unable to fetch trusted peers for (%@): %@", buf, 0x16u);
    }
    uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 8);
    id v12 = v7;
    id v13 = *(id *)(v11 + 40);
    *(void *)(v11 + 40) = v12;
  }
  else
  {
    uint64_t v14 = +[NSMutableSet set];
    uint64_t v15 = *(void *)(*(void *)(a1 + 40) + 8);
    unsigned int v16 = *(void **)(v15 + 40);
    *(void *)(v15 + 40) = v14;

    long long v37 = 0u;
    long long v38 = 0u;
    long long v35 = 0u;
    long long v36 = 0u;
    id v13 = v6;
    id v17 = [v13 countByEnumeratingWithState:&v35 objects:v39 count:16];
    if (v17)
    {
      id v18 = v17;
      id v31 = WeakRetained;
      CFStringRef v32 = 0;
      id v33 = v6;
      id obj = v13;
      uint64_t v19 = *(void *)v36;
      do
      {
        for (uint64_t i = 0; i != v18; uint64_t i = (char *)i + 1)
        {
          uint64_t v21 = a1;
          if (*(void *)v36 != v19) {
            objc_enumerationMutation(obj);
          }
          long long v22 = *(void **)(*((void *)&v35 + 1) + 8 * i);
          id v23 = [v22 signingSPKI:v31, v32, v33];
          uint64_t v24 = +[_SFECPublicKey keyWithSubjectPublicKeyInfo:v23];

          id v25 = [v22 encryptionSPKI];
          __int16 v26 = +[_SFECPublicKey keyWithSubjectPublicKeyInfo:v25];

          uint64_t v27 = [CKKSActualPeer alloc];
          id v28 = [v22 peerID];
          CFStringRef v29 = [v22 viewList];
          long long v30 = [(CKKSActualPeer *)v27 initWithPeerID:v28 encryptionPublicKey:v26 signingPublicKey:v24 viewList:v29];

          a1 = v21;
          [*(id *)(*(void *)(*(void *)(v21 + 40) + 8) + 40) addObject:v30];
        }
        id v13 = obj;
        id v18 = [obj countByEnumeratingWithState:&v35 objects:v39 count:16];
      }
      while (v18);
      id v7 = v32;
      id v6 = v33;
      id WeakRetained = v31;
    }
  }
}

void sub_10005097C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100050994(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) peerID];

  if (v2)
  {
    uint64_t v3 = *(void **)(a1 + 32);
    uint64_t v4 = [v3 peerID];
    id v5 = +[NSString stringWithFormat:@"signing-key %@", v4];
    id v24 = 0;
    id v6 = [v3 fetchIdentity:v5 error:&v24];
    id v7 = v24;

    if (v6) {
      BOOL v8 = v7 == 0;
    }
    else {
      BOOL v8 = 0;
    }
    if (v8)
    {
      id v10 = *(void **)(a1 + 32);
      uint64_t v11 = [v10 peerID];
      id v12 = +[NSString stringWithFormat:@"encryption-key %@", v11];
      id v23 = 0;
      id v13 = [v10 fetchIdentity:v12 error:&v23];
      id v7 = v23;

      if (!v13 || v7)
      {
        if (*(void *)(a1 + 48)) {
          **(void **)(a1 + 48) = v7;
        }
      }
      else
      {
        uint64_t v14 = [OctagonSelfPeer alloc];
        uint64_t v15 = [*(id *)(a1 + 32) peerID];
        unsigned int v16 = [(OctagonSelfPeer *)v14 initWithPeerID:v15 signingIdentity:v6 encryptionIdentity:v13];

        id v17 = [CKKSSelves alloc];
        id v18 = +[NSSet set];
        uint64_t v19 = [(CKKSSelves *)v17 initWithCurrent:v16 allSelves:v18];
        uint64_t v20 = *(void *)(*(void *)(a1 + 40) + 8);
        uint64_t v21 = *(void **)(v20 + 40);
        *(void *)(v20 + 40) = v19;
      }
    }
    else if (*(void *)(a1 + 48))
    {
      id v7 = v7;
      **(void **)(a1 + 48) = v7;
    }
  }
  else
  {
    uint64_t v9 = sub_10000B070("octagon-ckks");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "No peer ID; therefore no identity", buf, 2u);
    }

    if (*(void *)(a1 + 48))
    {
      **(void **)(a1 + 48) = +[NSError errorWithDomain:@"com.apple.security.octagon" code:5 description:@"no peer ID present"];
    }
  }
}

void sub_100050D8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100050DA4(uint64_t a1)
{
  id v2 = +[_SFKeychainManager defaultOverCommitManager];
  uint64_t v3 = [v2 identityForIdentifier:*(void *)(a1 + 32)];
  uint64_t v4 = (char *)[v3 resultType];
  if ((unint64_t)(v4 - 1) >= 2)
  {
    if (!v4)
    {
      uint64_t v10 = [v3 value];
      uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8);
      id v12 = *(void **)(v11 + 40);
      *(void *)(v11 + 40) = v10;
    }
    id v9 = 0;
  }
  else
  {
    id v5 = sub_10000B070("octagon-ckks");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(void *)(a1 + 32);
      id v7 = [v3 error];
      int v13 = 138412546;
      uint64_t v14 = v6;
      __int16 v15 = 2112;
      unsigned int v16 = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Unable to fetch identity '%@' from keychain: %@", (uint8_t *)&v13, 0x16u);
    }
    BOOL v8 = [v3 error];
    id v9 = v8;
    if (*(void *)(a1 + 48) && v8)
    {
      id v9 = v8;
      **(void **)(a1 + 48) = v9;
    }
  }
}

void sub_100051C18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id location)
{
  objc_destroyWeak(v23);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100051C44(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (v6)
  {
    BOOL v8 = sub_10000B070("SecError");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 138412290;
      id v12 = v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon-health: error: %@", (uint8_t *)&v11, 0xCu);
    }

    [WeakRetained setError:v6];
    id v9 = [WeakRetained finishOp];
    [WeakRetained runBeforeGroupFinished:v9];
  }
  else
  {
    uint64_t v10 = sub_10000B070("octagon-health");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 138412290;
      id v12 = v5;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "cuttlefish came back with these suggestions: %@", (uint8_t *)&v11, 0xCu);
    }

    [WeakRetained handleRepairSuggestions:v5];
  }
}

void sub_100052CE0(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void **)(a1 + 32);
  id v4 = a2;
  [v3 stopWithEvent:@"OctagonEventReroll" result:v4];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_100053418(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  if (v5 || (a2 & 1) == 0)
  {
    id v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 138412290;
      id v11 = v5;
      id v7 = "octagon-remove-recovery-key: failed to remove recovery key: %@";
      BOOL v8 = v6;
      uint32_t v9 = 12;
      goto LABEL_7;
    }
  }
  else
  {
    id v6 = sub_10000B070("octagon-remove-recovery-key");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v10) = 0;
      id v7 = "removed recovery key";
      BOOL v8 = v6;
      uint32_t v9 = 2;
LABEL_7:
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v10, v9);
    }
  }

  (*(void (**)(void, id))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), v5);
}

void sub_1000536E8(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = sub_10000B070("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 138412290;
      id v6 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "octagon-recover-with-recovery-key: failed to join with recovery key: %@", (uint8_t *)&v5, 0xCu);
    }
  }
  else
  {
    id v4 = sub_10000B070("octagon-recover-with-recovery-key");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v5) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "successfully joined with recovery key", (uint8_t *)&v5, 2u);
    }
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100054460(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = sub_10000B070("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 138412290;
      id v6 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "octagon-reset-account-cdp-contents: error resetting account cdp contents: %@", (uint8_t *)&v5, 0xCu);
    }
  }
  else
  {
    id v4 = sub_10000B070("octagon-reset-account-cdp-contents");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v5) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "successfully reset account cdp contents", (uint8_t *)&v5, 2u);
    }
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100054730(uint64_t a1, int a2, void *a3)
{
  int v5 = a3;
  if (v5)
  {
    id v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 138412290;
      CFStringRef v11 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon-user-controllable-views: error fetching status: %@", (uint8_t *)&v10, 0xCu);
    }

    id v7 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
  }
  else
  {
    BOOL v8 = sub_10000B070("octagon-user-controllable-views");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v9 = @"paused";
      if (a2) {
        CFStringRef v9 = @"enabled";
      }
      int v10 = 138412290;
      CFStringRef v11 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "successfully fetched status as: %@", (uint8_t *)&v10, 0xCu);
    }

    id v7 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
  }
  v7();
}

void sub_100054A38(uint64_t a1, int a2, void *a3)
{
  int v5 = a3;
  if (v5)
  {
    id v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 138412290;
      CFStringRef v11 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon-user-controllable-views: error setting status: %@", (uint8_t *)&v10, 0xCu);
    }

    id v7 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
  }
  else
  {
    BOOL v8 = sub_10000B070("octagon-user-controllable-views");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v9 = @"paused";
      if (a2) {
        CFStringRef v9 = @"enabled";
      }
      int v10 = 138412290;
      CFStringRef v11 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "successfully set status to: %@", (uint8_t *)&v10, 0xCu);
    }

    id v7 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
  }
  v7();
}

void sub_100054D80(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = sub_10000B070("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 138412290;
      id v6 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "octagon-remove-escrow-cache: error invalidating escrow cache: %@", (uint8_t *)&v5, 0xCu);
    }
  }
  else
  {
    id v4 = sub_10000B070("octagon-remove-escrow-caches");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v5) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "successfully invalidated escrow cache", (uint8_t *)&v5, 2u);
    }
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000550A4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    id v7 = sub_10000B070("SecError");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      id v9 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "octagon-fetch-escrow-records: error fetching records: %@", (uint8_t *)&v8, 0xCu);
    }
  }
  else
  {
    id v7 = sub_10000B070("octagon-fetch-escrow-records");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v8) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "successfully fetched records", (uint8_t *)&v8, 2u);
    }
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100055758(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = sub_10000B070("octagon-ckks");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    CFStringRef v5 = @"no error";
    if (v3) {
      CFStringRef v5 = v3;
    }
    int v6 = 138412290;
    CFStringRef v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "refetch-ckks-policy result: %@", (uint8_t *)&v6, 0xCu);
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100055C74(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100055E6C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100056728(id a1, TrustedPeersHelperHealthCheckResult *a2, NSError *a3)
{
  id v3 = a3;
  if (v3)
  {
    id v4 = sub_10000B070("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      id v9 = v3;
      CFStringRef v5 = "octagon: error attempting to check octagon health: %@";
      int v6 = v4;
      uint32_t v7 = 12;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v5, (uint8_t *)&v8, v7);
    }
  }
  else
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v8) = 0;
      CFStringRef v5 = "health check success";
      int v6 = v4;
      uint32_t v7 = 2;
      goto LABEL_6;
    }
  }
}

void sub_100056B98(uint64_t a1, void *a2, void *a3)
{
  CFStringRef v5 = *(void **)(a1 + 32);
  id v6 = a3;
  id v7 = a2;
  [v5 stopWithEvent:@"OctagonActivityRecreateInheritanceKey" result:v6];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_100056F80(uint64_t a1, void *a2, void *a3)
{
  CFStringRef v5 = *(void **)(a1 + 32);
  id v6 = a3;
  id v7 = a2;
  [v5 stopWithEvent:@"OctagonEventRecreateInheritanceKey" result:v6];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_1000572A8(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = *(void **)(a1 + 32);
  id v5 = a3;
  [v4 stopWithEvent:@"OctagonEventCheckInheritanceKey" result:v5];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_1000576F0(uint64_t a1, void *a2)
{
  id v3 = *(void **)(a1 + 32);
  id v4 = a2;
  [v3 stopWithEvent:@"OctagonEventRemoveInheritanceKey" result:v4];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_100057A0C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = sub_10000B070("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      id v9 = v3;
      id v5 = "octagon, preflight join with inheritance key failed: %@";
      id v6 = v4;
      uint32_t v7 = 12;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v5, (uint8_t *)&v8, v7);
    }
  }
  else
  {
    id v4 = sub_10000B070("octagon-inheritance");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v8) = 0;
      id v5 = "preflight join with inheritance key succeeded";
      id v6 = v4;
      uint32_t v7 = 2;
      goto LABEL_6;
    }
  }

  [*(id *)(a1 + 32) stopWithEvent:@"OctagonEventPreflightInheritanceKey" result:v3];
  (*(void (**)(void, id))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), v3);
}

void sub_100057DEC(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = sub_10000B070("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      id v9 = v3;
      id v5 = "octagon, join with inheritance key failed: %@";
      id v6 = v4;
      uint32_t v7 = 12;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v5, (uint8_t *)&v8, v7);
    }
  }
  else
  {
    id v4 = sub_10000B070("octagon-inheritance");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v8) = 0;
      id v5 = "join with inheritance key succeeded";
      id v6 = v4;
      uint32_t v7 = 2;
      goto LABEL_6;
    }
  }

  [*(id *)(a1 + 32) stopWithEvent:@"OctagonEventJoinInheritanceKey" result:v3];
  (*(void (**)(void, id))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), v3);
}

void sub_100058258(uint64_t a1, void *a2)
{
  id v3 = *(void **)(a1 + 32);
  id v4 = a2;
  [v3 stopWithEvent:@"OctagonEventStoreInheritanceKey" result:v4];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_100058608(uint64_t a1, void *a2, void *a3)
{
  id v5 = *(void **)(a1 + 32);
  id v6 = a3;
  id v7 = a2;
  [v5 stopWithEvent:@"OctagonEventGenerateInheritanceKey" result:v6];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_1000589D4(uint64_t a1, void *a2, void *a3)
{
  id v5 = *(void **)(a1 + 32);
  id v6 = a3;
  id v7 = a2;
  [v5 stopWithEvent:@"OctagonEventCreateInheritanceKey" result:v6];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_100058CFC(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = *(void **)(a1 + 32);
  id v5 = a3;
  [v4 stopWithEvent:@"OctagonEventCheckCustodianRecoveryKey" result:v5];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_100059144(uint64_t a1, void *a2)
{
  id v3 = *(void **)(a1 + 32);
  id v4 = a2;
  [v3 stopWithEvent:@"OctagonEventRemoveCustodianRecoveryKey" result:v4];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_100059444(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = sub_10000B070("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      id v9 = v3;
      id v5 = "octagon, preflight join with custodian recovery key failed: %@";
      id v6 = v4;
      uint32_t v7 = 12;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v5, (uint8_t *)&v8, v7);
    }
  }
  else
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v8) = 0;
      id v5 = "preflight join with custodian recovery key succeeded";
      id v6 = v4;
      uint32_t v7 = 2;
      goto LABEL_6;
    }
  }

  [*(id *)(a1 + 32) stopWithEvent:@"OctagonEventPreflightCustodianRecoveryKey" result:v3];
  (*(void (**)(void, id))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), v3);
}

void sub_100059808(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = sub_10000B070("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      id v9 = v3;
      id v5 = "octagon, join with custodian recovery key failed: %@";
      id v6 = v4;
      uint32_t v7 = 12;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v5, (uint8_t *)&v8, v7);
    }
  }
  else
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v8) = 0;
      id v5 = "join with custodian recovery key succeeded";
      id v6 = v4;
      uint32_t v7 = 2;
      goto LABEL_6;
    }
  }

  [*(id *)(a1 + 32) stopWithEvent:@"OctagonEventJoinCustodianRecoveryKey" result:v3];
  (*(void (**)(void, id))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), v3);
}

void sub_100059C7C(uint64_t a1, void *a2, void *a3)
{
  id v5 = *(void **)(a1 + 32);
  id v6 = a3;
  id v7 = a2;
  [v5 stopWithEvent:@"OctagonEventCreateCustodianRecoveryKey2" result:v6];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_10005A098(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (!v3)
  {
    id v17 = sub_10000B070("octagon");
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "join with recovery key succeeded", buf, 2u);
    }

    [*(id *)(a1 + 40) stopWithEvent:@"OctagonEventJoinRecoveryKey" result:0];
    id v18 = *(void (**)(void))(*(void *)(a1 + 72) + 16);
    goto LABEL_19;
  }
  if ([v3 code] != (id)34 && objc_msgSend(v4, "code") != (id)32
    || ([v4 domain],
        id v5 = objc_claimAutoreleasedReturnValue(),
        unsigned int v6 = [v5 isEqualToString:@"com.apple.security.trustedpeers.container"],
        v5,
        !v6))
  {
    uint64_t v14 = sub_10000B070("SecError");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      __int16 v26 = v4;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "octagon, join with recovery key failed: %@", buf, 0xCu);
    }

    __int16 v15 = *(void **)(a1 + 40);
    CFStringRef v16 = @"OctagonEventJoinRecoveryKeyFailed";
    goto LABEL_18;
  }
  unsigned __int8 v7 = [*(id *)(a1 + 32) isFullPeer];
  int v8 = sub_10000B070("SecError");
  BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if ((v7 & 1) == 0)
  {
    if (v9)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: recovery key is not enrolled in octagon, and current device can't set recovery keys", buf, 2u);
    }

    __int16 v15 = *(void **)(a1 + 40);
    CFStringRef v16 = @"OctagonEventJoinRecoveryKeyCircleResetFailed";
LABEL_18:
    [v15 stopWithEvent:v16 result:v4];
    id v18 = *(void (**)(void))(*(void *)(a1 + 72) + 16);
LABEL_19:
    v18();
    goto LABEL_20;
  }
  if (v9)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon, recovery key is not enrolled in octagon, resetting octagon circle", buf, 2u);
  }

  int v10 = [objc_msgSend(*(id *)(a1 + 32), "loggerClass") logger];
  [v10 logResultForEvent:@"OctagonEventJoinRecoveryKeyCircleReset" hardFailure:0 result:v4];

  v19[0] = _NSConcreteStackBlock;
  v19[1] = 3221225472;
  v19[2] = sub_10005A3CC;
  v19[3] = &unk_1002F94C8;
  CFStringRef v11 = *(void **)(a1 + 48);
  id v20 = *(id *)(a1 + 40);
  id v12 = *(id *)(a1 + 72);
  uint64_t v13 = *(void *)(a1 + 32);
  id v24 = v12;
  uint64_t v21 = v13;
  id v22 = *(id *)(a1 + 56);
  id v23 = *(id *)(a1 + 64);
  [v11 rpcResetAndEstablish:5 idmsTargetContext:0 idmsCuttlefishPassword:0 notifyIdMS:0 accountSettings:0 isGuitarfish:0 reply:v19];

LABEL_20:
}

void sub_10005A3CC(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = sub_10000B070("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "octagon, failed to reset octagon", buf, 2u);
    }

    [*(id *)(a1 + 32) stopWithEvent:@"OctagonEventJoinRecoveryKeyCircleResetFailed" result:v3];
    (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
  }
  else
  {
    id v5 = sub_10000B070("octagon");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "attempting enrolling recovery key", buf, 2u);
    }

    unsigned int v6 = *(void **)(a1 + 40);
    uint64_t v7 = *(void *)(a1 + 48);
    uint64_t v8 = *(void *)(a1 + 56);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    _OWORD v9[2] = sub_10005A560;
    v9[3] = &unk_1002FA768;
    id v10 = *(id *)(a1 + 32);
    id v11 = *(id *)(a1 + 64);
    [v6 createRecoveryKey:v7 recoveryKey:v8 reply:v9];
  }
}

void sub_10005A560(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = sub_10000B070("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 138412290;
      id v8 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "octagon, failed to enroll new recovery key: %@", (uint8_t *)&v7, 0xCu);
    }

    [*(id *)(a1 + 32) stopWithEvent:@"OctagonEventJoinRecoveryKeyEnrollFailed" result:v3];
    id v5 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
  }
  else
  {
    unsigned int v6 = sub_10000B070("octagon");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7) = 0;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "successfully enrolled recovery key", (uint8_t *)&v7, 2u);
    }

    [*(id *)(a1 + 32) stopWithEvent:@"OctagonEventRecoveryKey" result:0];
    id v5 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
  }
  v5();
}

void sub_10005AAFC(uint64_t a1, void *a2)
{
  id v3 = *(void **)(a1 + 32);
  id v4 = a2;
  [v3 stopWithEvent:@"OctagonEventRecoveryKey" result:v4];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_10005AC20(id a1)
{
  v3[0] = OTCliqueCDPContextTypeNone;
  v3[1] = OTCliqueCDPContextTypeSignIn;
  v3[2] = OTCliqueCDPContextTypeRepair;
  v3[3] = OTCliqueCDPContextTypeFinishPasscodeChange;
  v3[4] = OTCliqueCDPContextTypeRecoveryKeyGenerate;
  void v3[5] = OTCliqueCDPContextTypeRecoveryKeyNew;
  void v3[6] = OTCliqueCDPContextTypeUpdatePasscode;
  v3[7] = OTCliqueCDPContextTypeConfirmPasscodeCyrus;
  uint64_t v1 = +[NSArray arrayWithObjects:v3 count:8];
  id v2 = (void *)qword_10035CD28;
  qword_10035CD28 = v1;
}

void sub_10005AE68(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 56));
  _Unwind_Resume(a1);
}

id sub_10005AE90(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  CFDataRef v105 = [WeakRetained contextForContainerName:@"com.apple.security.keychain" contextID:@"defaultContext"];
  uint64_t v1 = sub_10000B070("octagon-analytics");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = @"com.apple.security.keychain";
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = @"defaultContext";
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Reporting analytics for container: %@, context: %@", buf, 0x16u);
  }

  id v109 = +[NSMutableDictionary dictionary];
  uint64_t v2 = [WeakRetained sosAdapter];
  id v128 = 0;
  id v3 = [v2 circleStatus:&v128];
  id v103 = v128;

  if (v103)
  {
    id v4 = sub_10000B070("octagon-analytics");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v103;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Error fetching SOS status: %@", buf, 0xCu);
    }
  }
  id v5 = +[NSNumber numberWithInt:v3];
  [v109 setObject:v5 forKeyedSubscript:@"OASOSStatus"];

  unsigned int v6 = +[CKKSAnalytics logger];
  unsigned int v101 = [v6 datePropertyForKey:@"OctagonEventUpgradePreflightPreapprovedJoin"];

  int v7 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", +[CKKSAnalytics fuzzyDaysSinceDate:v101]);
  [v109 setObject:v7 forKeyedSubscript:@"OALastPPJ"];

  id v8 = +[OTStates OctagonStateMap];
  BOOL v9 = [v105 stateMachine];
  id v10 = [v9 currentState];
  id v11 = [v8 objectForKeyedSubscript:v10];
  [v109 setObject:v11 forKeyedSubscript:@"OASMState"];

  id v12 = [v105 accountMetadataStore];
  id v127 = 0;
  CFStringRef v106 = [v12 loadOrCreateAccountMetadata:&v127];
  id v102 = v127;

  if (v106 && !v102) {
    goto LABEL_12;
  }
  uint64_t v13 = sub_10000B070("octagon-analytics");
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = v102;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Error fetching Octagon metadata: %@", buf, 0xCu);
  }

  if (v106)
  {
LABEL_12:
    uint64_t v14 = +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", [v106 icloudAccountState]);
    [v109 setObject:v14 forKeyedSubscript:@"OAiC"];

    __int16 v15 = +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", [v106 cdpState]);
    [v109 setObject:v15 forKeyedSubscript:@"OACDPStatus"];

    CFStringRef v16 = +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", [v106 trustState]);
    [v109 setObject:v16 forKeyedSubscript:@"OATrust"];
  }
  else
  {
    [v109 setObject:0 forKeyedSubscript:@"OAiC"];
    [v109 setObject:0 forKeyedSubscript:@"OACDPStatus"];
    [v109 setObject:0 forKeyedSubscript:@"OATrust"];
  }
  id v17 = [v106 getTPSyncingPolicy];
  BOOL v100 = v17;
  if (v17)
  {
    id v18 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", [v17 syncUserControllableViewsAsBoolean]);
    [v109 setObject:v18 forKeyedSubscript:@"OAUserViewsSyncing"];
  }
  else
  {
    [v109 setObject:0 forKeyedSubscript:@"OAUserViewsSyncing"];
  }
  uint64_t v99 = [v105 currentMemoizedLastHealthCheck];
  uint64_t v19 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", +[CKKSAnalytics fuzzyDaysSinceDate:v99]);
  [v109 setObject:v19 forKeyedSubscript:@"OAHealthCheck"];

  id v20 = +[CKKSAnalytics logger];
  uint64_t v98 = [v20 datePropertyForKey:@"OALastKSR"];

  uint64_t v21 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", +[CKKSAnalytics fuzzyDaysSinceDate:v98]);
  [v109 setObject:v21 forKeyedSubscript:@"OALastKSR"];

  if (v106 && [v106 icloudAccountState] == 2)
  {
    id v22 = +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", [v106 attemptedJoin]);
    [v109 setObject:v22 forKeyedSubscript:@"OAAttemptedJoin"];

    id v23 = [v105 authKitAdapter];
    id v126 = 0;
    id v24 = [v23 machineID:0 flowID:0 deviceSessionID:0 canSendMetrics:0 error:&v126];
    id v25 = v126;

    if (v25)
    {
      __int16 v26 = sub_10000B070("octagon-analytics");
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v102;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Error fetching machine ID: %@", buf, 0xCu);
      }
    }
    uint64_t v27 = +[NSNumber numberWithInt:v24 != 0];
    [v109 setObject:v27 forKeyedSubscript:@"OAMIDPresent"];

    if (v24)
    {
      id v125 = 0;
      id v28 = [v105 machineIDOnMemoizedList:v24 error:&v125];
      id v29 = v125;
      if (v29)
      {
        long long v30 = sub_10000B070("octagon-analytics");
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = v29;
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Error fetching 'mid on list': %@", buf, 0xCu);
        }
      }
      else
      {
        long long v30 = +[NSNumber numberWithBool:v28];
        [v109 setObject:v30 forKeyedSubscript:@"OAMIDOnList"];
      }

      id v124 = 0;
      id v31 = [v105 egoPeerStatus:&v124];
      id v32 = v124;
      id obj = v32;
      if (!v31 || v32)
      {
        uint64_t v58 = sub_10000B070("octagon-analytics");
        if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = obj;
          _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "Error fetching how many peers have our MID: %@", buf, 0xCu);
        }
      }
      else
      {
        id v33 = [v31 peerCountsByMachineID];
        uint64_t v34 = [v33 objectForKeyedSubscript:v24];
        long long v35 = (void *)v34;
        long long v36 = &off_100325B40;
        if (v34) {
          long long v36 = (_UNKNOWN **)v34;
        }
        BOOL v96 = v36;

        long long v37 = sub_10000B070("octagon-metrics");
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412546;
          *(void *)&uint8_t buf[4] = v24;
          *(_WORD *)&buf[12] = 2112;
          *(void *)&buf[14] = v96;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "Number of peers with machineID (%@): %@", buf, 0x16u);
        }

        [v109 setObject:v96 forKeyedSubscript:@"OAPeersWithMID"];
        long long v38 = [v31 egoPeerMachineID];
        id v39 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", [v24 isEqualToString:v38]);
        [v109 setObject:v39 forKeyedSubscript:@"OAMIDMatchesCurrentMID"];

        id v40 = sub_10000B070("octagon-metrics");
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v41 = [v109 objectForKeyedSubscript:@"OAMIDMatchesCurrentMID"];
          __int16 v42 = [v31 egoPeerMachineID];
          *(_DWORD *)long long buf = 138412802;
          *(void *)&uint8_t buf[4] = v41;
          *(_WORD *)&buf[12] = 2112;
          *(void *)&buf[14] = v24;
          *(_WORD *)&buf[22] = 2112;
          v137 = v42;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "MID match (current vs Octagon peer): %@, %@, %@", buf, 0x20u);
        }
        long long v122 = 0u;
        long long v123 = 0u;
        long long v120 = 0u;
        long long v121 = 0u;
        id v43 = [v31 peerCountsByMachineID];
        uint64_t v44 = [v43 allValues];

        uint64_t v45 = 0;
        id v46 = [v44 countByEnumeratingWithState:&v120 objects:v135 count:16];
        if (v46)
        {
          uint64_t v47 = *(void *)v121;
          do
          {
            for (uint64_t i = 0; i != v46; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v121 != v47) {
                objc_enumerationMutation(v44);
              }
              v45 += (uint64_t)[*(id *)(*((void *)&v120 + 1) + 8 * i) longValue];
            }
            id v46 = [v44 countByEnumeratingWithState:&v120 objects:v135 count:16];
          }
          while (v46);
        }

        long long v118 = 0u;
        long long v119 = 0u;
        long long v116 = 0u;
        long long v117 = 0u;
        unsigned int v49 = [v31 viablePeerCountsByModelID];
        uint64_t v50 = [v49 allValues];

        uint64_t v51 = 0;
        id v52 = [v50 countByEnumeratingWithState:&v116 objects:v134 count:16];
        if (v52)
        {
          uint64_t v53 = *(void *)v117;
          do
          {
            for (j = 0; j != v52; j = (char *)j + 1)
            {
              if (*(void *)v117 != v53) {
                objc_enumerationMutation(v50);
              }
              v51 += (uint64_t)[*(id *)(*((void *)&v116 + 1) + 8 * (void)j) longValue];
            }
            id v52 = [v50 countByEnumeratingWithState:&v116 objects:v134 count:16];
          }
          while (v52);
        }

        unsigned int v55 = sub_10000B070("octagon-metrics");
        if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 134218240;
          *(void *)&uint8_t buf[4] = v45;
          *(_WORD *)&buf[12] = 2048;
          *(void *)&buf[14] = v51;
          _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "Peers: %zu, viable peers %zu", buf, 0x16u);
        }

        id v56 = +[NSNumber numberWithUnsignedLong:v45];
        [v109 setObject:v56 forKeyedSubscript:@"OAnPeers"];

        uint64_t v57 = +[NSNumber numberWithUnsignedLong:v51];
        [v109 setObject:v57 forKeyedSubscript:@"OAnViablePeers"];

        uint64_t v58 = v96;
      }
    }
  }
  uint64_t v59 = +[CKKSAnalytics logger];
  uint64_t v97 = [v59 datePropertyForKey:@"OALastCFU"];

  id v60 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", +[CKKSAnalytics fuzzyDaysSinceDate:v97]);
  [v109 setObject:v60 forKeyedSubscript:@"OALastCFU"];

  long long v114 = 0u;
  long long v115 = 0u;
  long long v112 = 0u;
  long long v113 = 0u;
  id obja = [WeakRetained cdpContextTypes];
  id v61 = [obja countByEnumeratingWithState:&v112 objects:v133 count:16];
  if (v61)
  {
    uint64_t v62 = *(void *)v113;
    do
    {
      for (k = 0; k != v61; k = (char *)k + 1)
      {
        if (*(void *)v113 != v62) {
          objc_enumerationMutation(obja);
        }
        uint64_t v64 = *(void *)(*((void *)&v112 + 1) + 8 * (void)k);
        uint64_t v65 = +[NSString stringWithFormat:@"%@%@", @"OACDPStateRun", v64];
        unsigned int v66 = +[NSString stringWithFormat:@"%@%@Tries", @"OACDPStateRun", v64];
        id v67 = +[CKKSAnalytics logger];
        uint64_t v68 = [v67 datePropertyForKey:v65];

        if (v68)
        {
          id v69 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", +[CKKSAnalytics fuzzyDaysSinceDate:v68]);
          [v109 setObject:v69 forKeyedSubscript:v65];

          long long v70 = +[CKKSAnalytics logger];
          long long v71 = [v70 numberPropertyForKey:v66];
          [v109 setObject:v71 forKeyedSubscript:v66];
        }
      }
      id v61 = [obja countByEnumeratingWithState:&v112 objects:v133 count:16];
    }
    while (v61);
  }

  id v111 = v103;
  long long v72 = [[[WeakRetained escrowRequestClass] request:&v111];
  id v73 = v111;

  if (v72)
  {
    id v110 = v73;
    id v74 = [v72 pendingEscrowUpload:&v110];
    id v75 = v110;

    long long v76 = +[NSNumber numberWithBool:v74];
    [v109 setObject:v76 forKeyedSubscript:@"OAPrerecordPending"];

    if (!v75) {
      goto LABEL_74;
    }
    long long v77 = sub_10000B070("octagon-analytics");
    if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v75;
      _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "Error fetching pendingEscrowUpload status: %@", buf, 0xCu);
    }
  }
  else
  {
    long long v77 = sub_10000B070("octagon-analytics");
    if (os_log_type_enabled(v77, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v73;
      _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "Error fetching escrowRequestClass: %@", buf, 0xCu);
    }
    id v75 = v73;
  }

LABEL_74:
  long long v78 = +[ACAccountStore defaultStore];
  long long v79 = [v78 aa_primaryAppleAccount];
  long long v80 = v79;
  if (v79)
  {
    uint64_t v81 = ACAccountDataclassKeyValue;
    long long v82 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", [v79 isProvisionedForDataclass:ACAccountDataclassKeyValue]);
    [v109 setObject:v82 forKeyedSubscript:@"OADCKVSProvisioned"];

    long long v83 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", [v80 isEnabledForDataclass:v81]);
    [v109 setObject:v83 forKeyedSubscript:@"OADCKVSEnabled"];

    uint64_t v84 = ACAccountDataclassKeychainSync;
    long long v85 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", [v80 isProvisionedForDataclass:ACAccountDataclassKeychainSync]);
    [v109 setObject:v85 forKeyedSubscript:@"OADCKCSProvisioned"];

    long long v86 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", [v80 isEnabledForDataclass:v84]);
    [v109 setObject:v86 forKeyedSubscript:@"OADCKCSEnabled"];

    uint64_t v87 = ACAccountDataclassCKDatabaseService;
    v88 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", [v80 isProvisionedForDataclass:ACAccountDataclassCKDatabaseService]);
    [v109 setObject:v88 forKeyedSubscript:@"OADCCKProvisioned"];

    uint64_t v89 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", [v80 isEnabledForDataclass:v87]);
    [v109 setObject:v89 forKeyedSubscript:@"OADCCKEnabled"];

    unsigned int v90 = [v80 aa_altDSID];
    if (v90)
    {
      uint64_t v129 = 0;
      char v130 = &v129;
      uint64_t v131 = 0x2050000000;
      size_t v91 = (void *)qword_10035CD50;
      uint64_t v132 = qword_10035CD50;
      if (!qword_10035CD50)
      {
        *(void *)long long buf = _NSConcreteStackBlock;
        *(void *)&uint8_t buf[8] = 3221225472;
        *(void *)&uint8_t buf[16] = sub_10005C1AC;
        v137 = &unk_100308068;
        BOOL v138 = &v129;
        sub_10005C1AC((uint64_t)buf);
        size_t v91 = (void *)v130[3];
      }
      id v92 = v91;
      _Block_object_dispose(&v129, 8);
      uint64_t v93 = [v92 getAcceptedTermsForAltDSID:v90 withError:0];
      CFDictionaryRef v94 = +[NSNumber numberWithInt:v93 != 0];
      [v109 setObject:v94 forKeyedSubscript:@"OASecureBackupTermsAccepted"];
    }
  }

  return v109;
}

void sub_10005C114(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
}

id sub_10005C134(uint64_t a1)
{
  uint64_t v1 = [*(id *)(a1 + 32) contextForContainerName:@"com.apple.security.keychain" contextID:@"defaultContext"];
  uint64_t v2 = [v1 followupHandler];
  id v3 = [v2 sfaStatus];

  return v3;
}

Class sub_10005C1AC(uint64_t a1)
{
  v6[0] = 0;
  if (!qword_10035CD58)
  {
    v6[1] = _NSConcreteStackBlock;
    _DWORD v6[2] = (void *)3221225472;
    v6[3] = sub_10005C398;
    void v6[4] = &unk_1003093A8;
    void v6[5] = v6;
    long long v7 = off_1002F8638;
    uint64_t v8 = 0;
    qword_10035CD58 = _sl_dlopen();
  }
  if (!qword_10035CD58)
  {
    id v3 = +[NSAssertionHandler currentHandler];
    id v4 = +[NSString stringWithUTF8String:"void *CloudServicesLibrary(void)"];
    [v3 handleFailureInFunction:v4 file:@"OTManager.m" lineNumber:118 description:@"%s" v6[0]];

    goto LABEL_10;
  }
  if (v6[0]) {
    free(v6[0]);
  }
  Class result = objc_getClass("SecureBackup");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    id v3 = +[NSAssertionHandler currentHandler];
    id v5 = +[NSString stringWithUTF8String:"Class getSecureBackupClass(void)_block_invoke"];
    [v3 handleFailureInFunction:v5 file:@"OTManager.m" lineNumber:119 description:@"Unable to find class %s", "SecureBackup"];

LABEL_10:
    __break(1u);
  }
  qword_10035CD50 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t sub_10005C398()
{
  uint64_t result = _sl_dlopen();
  qword_10035CD58 = result;
  return result;
}

void sub_10005C9F4(uint64_t a1, void *a2)
{
  id v3 = *(void **)(a1 + 32);
  id v4 = a2;
  [v3 stopWithEvent:@"OctagonEventBottledPeerRestore" result:v4];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_10005D220(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10005D250()
{
  if (!qword_10035CD38) {
    qword_10035CD38 = _sl_dlopen();
  }
  return qword_10035CD38;
}

void *sub_10005D320(uint64_t a1)
{
  uint64_t v2 = sub_10005D370();
  uint64_t result = dlsym(v2, "KCPairingIntent_Capability_FullPeer");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  qword_10035CD40 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *sub_10005D370()
{
  uint64_t v0 = sub_10005D250();
  if (v0) {
    return (void *)v0;
  }
  uint64_t v1 = +[NSAssertionHandler currentHandler];
  id v3 = +[NSString stringWithUTF8String:"void *KeychainCircleLibrary(void)"];
  [v1 handleFailureInFunction:v3 file:@"OTManager.m" lineNumber:110 description:@"%s"];

  __break(1u);
  free(v4);
  return v1;
}

void *sub_10005D420(uint64_t a1)
{
  uint64_t v2 = sub_10005D370();
  uint64_t result = dlsym(v2, "KCPairingIntent_Capability_LimitedPeer");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  qword_10035CD48 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_10005D470(void *a1, void *a2, void *a3, void *a4)
{
  if (!a4) {
    *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = 1;
  }
  long long v7 = (void *)a1[4];
  id v8 = a4;
  id v9 = a3;
  id v10 = a2;
  [v7 setSessionMetrics:0];
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  id v12 = _OctagonSignpostLogSystem();
  uint64_t v13 = v12;
  os_signpost_id_t v14 = a1[7];
  if (v14 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v12))
  {
    int v15 = *(unsigned __int8 *)(*(void *)(a1[6] + 8) + 24);
    int v18 = 67240192;
    LODWORD(v19) = v15;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v13, OS_SIGNPOST_INTERVAL_END, v14, "PairingChannelAcceptorVoucher", " OctagonSignpostNamePairingChannelAcceptorVoucher=%{public,signpost.telemetry:number1,name=OctagonSignpostNamePairingChannelAcceptorVoucher}d ", (uint8_t *)&v18, 8u);
  }

  CFStringRef v16 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    int v18 = 134218496;
    int v17 = *(unsigned __int8 *)(*(void *)(a1[6] + 8) + 24);
    uint64_t v19 = a1[7];
    __int16 v20 = 2048;
    double v21 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v22 = 1026;
    int v23 = v17;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: PairingChannelAcceptorVoucher  OctagonSignpostNamePairingChannelAcceptorVoucher=%{public,signpost.telemetry:number1,name=OctagonSignpostNamePairingChannelAcceptorVoucher}d ", (uint8_t *)&v18, 0x1Cu);
  }

  (*(void (**)(void))(a1[5] + 16))();
}

uint64_t sub_10005D650()
{
  uint64_t result = _sl_dlopen();
  qword_10035CD38 = result;
  return result;
}

void sub_10005D9EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10005DA0C(void *a1, uint64_t a2, void *a3)
{
  if (!a3) {
    *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = 1;
  }
  id v4 = (void *)a1[4];
  id v5 = a3;
  [v4 setSessionMetrics:0];
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  long long v7 = _OctagonSignpostLogSystem();
  id v8 = v7;
  os_signpost_id_t v9 = a1[7];
  if (v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v7))
  {
    int v10 = *(unsigned __int8 *)(*(void *)(a1[6] + 8) + 24);
    int v13 = 67240192;
    LODWORD(v14) = v10;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v8, OS_SIGNPOST_INTERVAL_END, v9, "PairingChannelAcceptorEpoch", " OctagonSignpostNamePairingChannelAcceptorEpoch=%{public,signpost.telemetry:number1,name=OctagonSignpostNamePairingChannelAcceptorEpoch}d ", (uint8_t *)&v13, 8u);
  }

  id v11 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = 134218496;
    int v12 = *(unsigned __int8 *)(*(void *)(a1[6] + 8) + 24);
    uint64_t v14 = a1[7];
    __int16 v15 = 2048;
    double v16 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v17 = 1026;
    int v18 = v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: PairingChannelAcceptorEpoch  OctagonSignpostNamePairingChannelAcceptorEpoch=%{public,signpost.telemetry:number1,name=OctagonSignpostNamePairingChannelAcceptorEpoch}d ", (uint8_t *)&v13, 0x1Cu);
  }

  (*(void (**)(void))(a1[5] + 16))();
}

void sub_10005DF40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10005DF60(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (!v3)
  {
    [*(id *)(a1 + 32) clearPairingUUID];
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
  }
  [*(id *)(a1 + 32) setSessionMetrics:0];
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  id v5 = _OctagonSignpostLogSystem();
  unsigned int v6 = v5;
  os_signpost_id_t v7 = *(void *)(a1 + 56);
  if (v7 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v5))
  {
    int v8 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
    int v11 = 67240192;
    LODWORD(v12) = v8;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v6, OS_SIGNPOST_INTERVAL_END, v7, "PairingChannelInitiatorJoinOctagon", " OctagonSignpostNamePairingChannelInitiatorJoinOctagon=%{public,signpost.telemetry:number1,name=OctagonSignpostNamePairingChannelInitiatorJoinOctagon}d ", (uint8_t *)&v11, 8u);
  }

  os_signpost_id_t v9 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = 134218496;
    int v10 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
    uint64_t v12 = *(void *)(a1 + 56);
    __int16 v13 = 2048;
    double v14 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v15 = 1026;
    int v16 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: PairingChannelInitiatorJoinOctagon  OctagonSignpostNamePairingChannelInitiatorJoinOctagon=%{public,signpost.telemetry:number1,name=OctagonSignpostNamePairingChannelInitiatorJoinOctagon}d ", (uint8_t *)&v11, 0x1Cu);
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_10005E478(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10005E498(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7)
{
  if (!a7) {
    *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = 1;
  }
  __int16 v13 = (void *)a1[4];
  id v14 = a7;
  id v15 = a6;
  id v16 = a5;
  id v17 = a4;
  id v18 = a3;
  id v19 = a2;
  [v13 setSessionMetrics:0];
  uint64_t Nanoseconds = _OctagonSignpostGetNanoseconds();
  double v21 = _OctagonSignpostLogSystem();
  __int16 v22 = v21;
  os_signpost_id_t v23 = a1[7];
  if (v23 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v21))
  {
    int v24 = *(unsigned __int8 *)(*(void *)(a1[6] + 8) + 24);
    int v27 = 67240192;
    LODWORD(v28) = v24;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v22, OS_SIGNPOST_INTERVAL_END, v23, "PairingChannelInitiatorPrepare", " OctagonSignpostNamePairingChannelInitiatorPrepare=%{public,signpost.telemetry:number1,name=OctagonSignpostNamePairingChannelInitiatorPrepare}d ", (uint8_t *)&v27, 8u);
  }

  id v25 = _OctagonSignpostLogSystem();
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    int v27 = 134218496;
    int v26 = *(unsigned __int8 *)(*(void *)(a1[6] + 8) + 24);
    uint64_t v28 = a1[7];
    __int16 v29 = 2048;
    double v30 = (double)(unint64_t)Nanoseconds / 1000000000.0;
    __int16 v31 = 1026;
    int v32 = v26;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "END [%lld] %fs: PairingChannelInitiatorPrepare  OctagonSignpostNamePairingChannelInitiatorPrepare=%{public,signpost.telemetry:number1,name=OctagonSignpostNamePairingChannelInitiatorPrepare}d ", (uint8_t *)&v27, 0x1Cu);
  }

  (*(void (**)(void))(a1[5] + 16))();
}

void sub_10005E9E4(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  os_signpost_id_t v9 = *(void **)(a1 + 32);
  id v10 = a5;
  id v11 = a4;
  id v12 = a3;
  id v13 = a2;
  [v9 stopWithEvent:@"OctagonEventFetchEscrowContents" result:v10];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_10005EC90(uint64_t a1, void *a2, void *a3, void *a4)
{
  os_signpost_id_t v7 = *(void **)(a1 + 32);
  id v8 = a4;
  id v9 = a3;
  id v10 = a2;
  [v7 stopWithEvent:@"OctagonEventFetchAllBottles" result:v8];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_10005F078(uint64_t a1, void *a2)
{
  id v3 = *(void **)(a1 + 32);
  id v4 = a2;
  [v3 stopWithEvent:@"OctagonEventRemoveFriendsInClique" result:v4];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_10005F2C8(uint64_t a1, void *a2)
{
  id v3 = *(void **)(a1 + 32);
  id v4 = a2;
  [v3 stopWithEvent:@"OctagonEventLeaveClique" result:v4];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_10005F530(uint64_t a1, void *a2)
{
  id v3 = *(void **)(a1 + 32);
  id v4 = a2;
  [v3 stopWithEvent:@"OctagonEventEstablish" result:v4];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

uint64_t sub_10005F758(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10005FB14(uint64_t a1, void *a2)
{
  id v3 = *(void **)(a1 + 32);
  id v4 = a2;
  [v3 stopWithEvent:@"OctagonEventResetAndEstablish" result:v4];
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

uint64_t sub_1000600A0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000602BC(uint64_t a1, uint64_t a2, void *a3, void *a4, uint64_t a5, uint64_t a6, void *a7)
{
  id v12 = a3;
  id v13 = a7;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  id v14 = [a4 allValues];
  id v15 = [v14 countByEnumeratingWithState:&v22 objects:v26 count:16];
  if (v15)
  {
    id v16 = v15;
    uint64_t v17 = 0;
    uint64_t v18 = *(void *)v23;
    do
    {
      for (uint64_t i = 0; i != v16; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v23 != v18) {
          objc_enumerationMutation(v14);
        }
        v17 += (uint64_t)[*(id *)(*((void *)&v22 + 1) + 8 * i) longValue];
      }
      id v16 = [v14 countByEnumeratingWithState:&v22 objects:v26 count:16];
    }
    while (v16);
  }
  else
  {
    uint64_t v17 = 0;
  }

  uint64_t v20 = *(void *)(a1 + 32);
  double v21 = +[NSNumber numberWithLong:v17];
  (*(void (**)(uint64_t, uint64_t, id, void *, uint64_t, id))(v20 + 16))(v20, a2, v12, v21, a5, v13);
}

void sub_100060614(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = a2;
  CKXPCSuitableError();
  id v4 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id, id))(v2 + 16))(v2, v3, v4);
}

void sub_100060730(uint64_t a1)
{
  id v1 = [*(id *)(a1 + 32) contexts];
  [v1 removeAllObjects];
}

void sub_1000616D0(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000616E8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1000616F8(uint64_t a1)
{
}

void sub_100061700(uint64_t a1)
{
  uint64_t v2 = (id *)(a1 + 40);
  id v52 = +[NSString stringWithFormat:@"%@-%@", *(void *)(a1 + 32), *(void *)(a1 + 40)];
  id v3 = [*(id *)(a1 + 48) contexts];
  uint64_t v4 = [v3 objectForKeyedSubscript:v52];
  uint64_t v5 = *(void *)(*(void *)(a1 + 120) + 8);
  unsigned int v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;

  if (!*(void *)(*(void *)(*(void *)(a1 + 120) + 8) + 40) && *(unsigned char *)(a1 + 128))
  {
    os_signpost_id_t v7 = [CKKSCuttlefishAdapter alloc];
    id v8 = [*(id *)(a1 + 48) cuttlefishXPCConnection];
    id v9 = [(CKKSCuttlefishAdapter *)v7 initWithConnection:v8];

    id v10 = *(void **)(a1 + 56);
    if (v10)
    {
      uint64_t v11 = [v10 makeCKContainer];
      id v12 = [CKKSAccountStateTracker alloc];
      id v13 = [*(id *)(a1 + 48) cloudKitClassDependencies];
      id v14 = -[CKKSAccountStateTracker init:nsnotificationCenterClass:](v12, "init:nsnotificationCenterClass:", v11, [v13 nsnotificationCenterClass]);
    }
    else
    {
      id v14 = [*(id *)(a1 + 48) accountStateTracker];
      uint64_t v11 = [*(id *)(a1 + 48) cloudKitContainer];
    }
    uint64_t v51 = v9;
    if (qword_10035D098 != -1) {
      dispatch_once(&qword_10035D098, &stru_100303AB8);
    }
    unsigned int v49 = (void *)v11;
    uint64_t v50 = v14;
    if (byte_10035D090
      || [*(id *)(a1 + 32) isEqualToString:@"com.apple.security.keychain"]
      && [*v2 isEqualToString:@"defaultContext"])
    {
      unsigned int v15 = [*(id *)(a1 + 40) isEqualToString:@"defaultContext"];
      id v16 = (id *)off_100305650;
      if (!v15) {
        id v16 = (id *)(a1 + 40);
      }
      id v17 = *v16;
      uint64_t v47 = [CKKSKeychainView alloc];
      uint64_t v18 = *(void *)(a1 + 56);
      id v19 = [*(id *)(a1 + 48) lockStateTracker];
      uint64_t v20 = [*(id *)(a1 + 48) reachabilityTracker];
      double v21 = [*(id *)(a1 + 48) savedTLKNotifier];
      long long v22 = [*(id *)(a1 + 48) cloudKitClassDependencies];
      long long v23 = [*(id *)(a1 + 48) personaAdapter];
      id v39 = [(CKKSKeychainView *)v47 initWithContainer:v11 contextID:v17 activeAccount:v18 accountTracker:v14 lockStateTracker:v19 reachabilityTracker:v20 savedTLKNotifier:v21 cloudKitClassDependencies:v22 personaAdapter:v23 accountsAdapter:*(void *)(a1 + 64) cuttlefishAdapter:v51];
    }
    else
    {
      id v39 = 0;
    }
    long long v24 = [OTCuttlefishContext alloc];
    uint64_t v46 = *(void *)(a1 + 32);
    CFStringRef v48 = v24;
    uint64_t v45 = *(void *)(a1 + 40);
    uint64_t v44 = *(void *)(a1 + 56);
    long long v25 = [*(id *)(a1 + 48) cuttlefishXPCConnection];
    uint64_t v42 = *(void *)(a1 + 64);
    uint64_t v43 = *(void *)(a1 + 72);
    uint64_t v41 = *(void *)(a1 + 80);
    int v26 = [*(id *)(a1 + 48) personaAdapter];
    long long v40 = *(_OWORD *)(a1 + 88);
    uint64_t v27 = *(void *)(a1 + 104);
    uint64_t v28 = [*(id *)(a1 + 48) reachabilityTracker];
    uint64_t v29 = *(void *)(a1 + 112);
    id v30 = [*(id *)(a1 + 48) apsConnectionClass];
    id v31 = [*(id *)(a1 + 48) escrowRequestClass];
    id v32 = [*(id *)(a1 + 48) notifierClass];
    id v33 = [*(id *)(a1 + 48) cdpd];
    uint64_t v34 = -[OTCuttlefishContext initWithContainerName:contextID:activeAccount:cuttlefish:ckksAccountSync:sosAdapter:accountsAdapter:authKitAdapter:personaAdapter:tooManyPeersAdapter:tapToRadarAdapter:lockStateTracker:reachabilityTracker:accountStateTracker:deviceInformationAdapter:apsConnectionClass:escrowRequestClass:notifierClass:cdpd:](v48, "initWithContainerName:contextID:activeAccount:cuttlefish:ckksAccountSync:sosAdapter:accountsAdapter:authKitAdapter:personaAdapter:tooManyPeersAdapter:tapToRadarAdapter:lockStateTracker:reachabilityTracker:accountStateTracker:deviceInformationAdapter:apsConnectionClass:escrowRequestClass:notifierClass:cdpd:", v46, v45, v44, v25, v39, v43, v42, v41, v26, v40, v27, v28, v50, v29, v30,
            v31,
            v32,
            v33);
    uint64_t v35 = *(void *)(*(void *)(a1 + 120) + 8);
    long long v36 = *(void **)(v35 + 40);
    *(void *)(v35 + 40) = v34;

    uint64_t v37 = *(void *)(*(void *)(*(void *)(a1 + 120) + 8) + 40);
    long long v38 = [*(id *)(a1 + 48) contexts];
    [v38 setObject:v37 forKeyedSubscript:v52];
  }
}

void sub_100061D8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100061DB0(uint64_t a1)
{
  uint64_t v1 = a1;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  uint64_t v2 = [*(id *)(a1 + 32) contexts];
  id v3 = [v2 allValues];

  id obj = v3;
  id v4 = [v3 countByEnumeratingWithState:&v23 objects:v27 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v24;
    do
    {
      os_signpost_id_t v7 = 0;
      id v19 = v5;
      do
      {
        if (*(void *)v24 != v6) {
          objc_enumerationMutation(obj);
        }
        id v8 = *(void **)(*((void *)&v23 + 1) + 8 * (void)v7);
        id v9 = [v8 ckks];
        id v10 = [v9 container];
        uint64_t v11 = [*(id *)(v1 + 40) container];
        if ([v10 isEqual:v11])
        {
          id v18 = v8;
          long long v22 = [v8 ckks];
          id v12 = [v22 operationDependencies];
          id v13 = [v12 contextID];
          [*(id *)(v1 + 40) operationDependencies];
          v15 = uint64_t v14 = v1;
          [v15 contextID];
          v17 = uint64_t v16 = v6;
          unsigned int v21 = [v13 isEqualToString:v17];

          uint64_t v6 = v16;
          uint64_t v1 = v14;
          id v5 = v19;

          if (v21)
          {
            objc_storeStrong((id *)(*(void *)(*(void *)(v1 + 48) + 8) + 40), v18);
            goto LABEL_12;
          }
        }
        else
        {
        }
        os_signpost_id_t v7 = (char *)v7 + 1;
      }
      while (v5 != v7);
      id v5 = [obj countByEnumeratingWithState:&v23 objects:v27 count:16];
    }
    while (v5);
  }
LABEL_12:
}

void sub_100062330(uint64_t a1)
{
  id v7 = +[NSString stringWithFormat:@"%@-%@", *(void *)(a1 + 32), *(void *)(a1 + 40)];
  uint64_t v2 = [*(id *)(a1 + 48) contexts];
  id v3 = [v2 objectForKeyedSubscript:v7];

  if (v3)
  {
    id v4 = [v3 stateMachine];
    [v4 haltOperation];

    id v5 = [v3 ckks];
    [v5 halt];
  }
  uint64_t v6 = [*(id *)(a1 + 48) contexts];
  [v6 setObject:0 forKeyedSubscript:v7];
}

void sub_1000632E0(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,long long buf)
{
  if (a2 == 1)
  {
    id v35 = objc_begin_catch(a1);
    long long v36 = sub_10000B070("SecError");
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v35;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "TrustedPeersHelperSetupProtocol failed, continuing, but you might crash later: %@", (uint8_t *)&buf, 0xCu);
    }

    objc_exception_throw(v35);
  }
  _Unwind_Resume(a1);
}

void sub_1000639F8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

void sub_100063A28(uint64_t a1)
{
  id v5 = [*(id *)(a1 + 32) contexts];
  uint64_t v2 = [v5 allValues];
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void sub_100064054(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_100064070(uint64_t a1)
{
  uint64_t v2 = sub_10000B070("octagon");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v5 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "circle changed notification called, checking trust state", v5, 2u);
  }

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v4 = objc_alloc_init((Class)OTControlArguments);
  [WeakRetained moveToCheckTrustedStateForArguments:v4];
}

void sub_1000648F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10006491C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v1 = [WeakRetained viewManager];
  [v1 notifyNewTLKsInKeychain];
}

void sub_100064DB8(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 112));
  _Unwind_Resume(a1);
}

void sub_100064DE0(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v1 = [WeakRetained viewManager];
  [v1 notifyNewTLKsInKeychain];
}

void sub_100065194(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100065540(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100065738(uint64_t a1)
{
  if ([*(id *)(a1 + 32) fillInError])
  {
    uint64_t v2 = *(void **)(a1 + 32);
    uint64_t v3 = [v2 internalSuccesses];
    [v2 allSuccessful:v3];
  }
  *(unsigned char *)(*(void *)(a1 + 32) + 80) = 0;
  *(unsigned char *)(*(void *)(a1 + 32) + 81) = 1;
}

uint64_t sub_100065C24(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 32) + 81) = 1;
  return result;
}

uint64_t sub_100065C3C(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 32) + 80) = 1;
  return result;
}

void sub_100065D14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100065D2C(uint64_t result)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 40) + 8) + 24) = *(unsigned char *)(*(void *)(result + 32) + 81);
  return result;
}

void sub_100065E08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100065E20(uint64_t result)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 40) + 8) + 24) = *(unsigned char *)(*(void *)(result + 32) + 80);
  return result;
}

void sub_100066770(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  objc_destroyWeak(v21);
  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000667AC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = WeakRetained;
  if (WeakRetained)
  {
    if ([WeakRetained allDependentsSuccessful])
    {
      [v2 groupStart];
    }
    else
    {
      id v4 = sub_1000CD884(@"ckksgroup", 0);
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        id v5 = [v2 error];
        int v6 = 138412290;
        id v7 = v5;
        _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Not running due to some failed dependent: %@", (uint8_t *)&v6, 0xCu);
      }
      [v2 cancel];
    }
  }
  else
  {
    uint64_t v3 = sub_1000CD884(@"ckks", 0);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v6) = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "received callback for released object", (uint8_t *)&v6, 2u);
    }
  }
}

void sub_100066900(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = WeakRetained;
  if (WeakRetained)
  {
    [WeakRetained completeOperation];
  }
  else
  {
    uint64_t v3 = sub_1000CD884(@"ckks", 0);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)id v4 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "received callback for released object", v4, 2u);
    }
  }
}

void sub_100066ACC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100066AEC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10006AF7C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10006AFA4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10006AFB4(uint64_t a1)
{
}

void sub_10006AFBC(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  id v4 = [a2 objectForKeyedSubscript:@"parentKeyUUID"];
  uint64_t v3 = [v4 asString];
  [v2 addObject:v3];
}

void sub_10006B288(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10006B2B0(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  id v4 = [a2 objectForKeyedSubscript:@"UUID"];
  uint64_t v3 = [v4 asString];
  [v2 addObject:v3];
}

void sub_10006B620(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

void sub_10006B650(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  id v4 = [a2 objectForKeyedSubscript:@"UUID"];
  uint64_t v3 = [v4 asString];
  [v2 addObject:v3];
}

void sub_10006CFB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,id location)
{
  objc_destroyWeak(v35);
  objc_destroyWeak(&location);
  _Block_object_dispose(&a29, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10006D030(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10006D040(uint64_t a1)
{
}

void sub_10006D048(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  id v6 = a3;
  id v7 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (v7)
  {
    id v9 = sub_1000CD884(@"ckkszonemodifier", 0);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      id v26 = v7;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Zone modification failed: %@", buf, 0xCu);
    }

    id v10 = [WeakRetained deps];
    [v10 inspectErrorForRetryAfter:v7];

    uint64_t v11 = [WeakRetained deps];
    id v12 = [v11 reachabilityTracker];
    unsigned int v13 = [v12 isNetworkError:v7];

    if (v13)
    {
      uint64_t v14 = sub_1000CD884(@"ckkszonemodifier", 0);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Waiting for reachability before issuing zone deletion", buf, 2u);
      }

      [WeakRetained setNetworkError:1];
    }
  }
  unsigned int v15 = sub_1000CD884(@"ckkszonemodifier", 0);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    id v26 = v6;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "deleted zones: %@", buf, 0xCu);
  }

  uint64_t v16 = [WeakRetained deps];
  id v17 = [v16 databaseProvider];
  v21[0] = _NSConcreteStackBlock;
  v21[1] = 3221225472;
  void v21[2] = sub_10006D414;
  v21[3] = &unk_1003053D0;
  uint64_t v18 = *(void *)(a1 + 32);
  void v21[4] = WeakRetained;
  id v22 = v6;
  id v23 = v7;
  uint64_t v24 = v18;
  id v19 = v7;
  id v20 = v6;
  [v17 dispatchSyncWithSQLTransaction:v21];
}

void sub_10006D2E8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = sub_1000CD884(@"ckkszonemodifier", 0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Finished deleting zones", buf, 2u);
  }

  if ([WeakRetained networkError])
  {
    [WeakRetained setNextState:@"zone_deletion_failed_due_to_network_error"];
  }
  else
  {
    uint64_t v3 = [WeakRetained error];

    if (!v3)
    {
      id v4 = [WeakRetained intendedState];
      [WeakRetained setNextState:v4];

      id v5 = sub_1000CD884(@"ckkszonemodifier", 0);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)id v6 = 0;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "no fatal errors discovered!", v6, 2u);
      }
    }
  }
}

uint64_t sub_10006D414(uint64_t a1)
{
  uint64_t v1 = a1;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v78 = 0u;
  long long v79 = 0u;
  uint64_t v2 = [*(id *)(a1 + 32) deps];
  uint64_t v3 = [v2 views];

  id v63 = [v3 countByEnumeratingWithState:&v76 objects:v86 count:16];
  if (v63)
  {
    uint64_t v4 = *(void *)v77;
    uint64_t v65 = v1;
    uint64_t v60 = *(void *)v77;
    id v61 = v3;
    do
    {
      for (uint64_t i = 0; i != v63; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v77 != v4) {
          objc_enumerationMutation(v3);
        }
        id v6 = *(void **)(*((void *)&v76 + 1) + 8 * i);
        long long v72 = 0u;
        long long v73 = 0u;
        long long v74 = 0u;
        long long v75 = 0u;
        id v7 = *(id *)(*(void *)(*(void *)(v1 + 56) + 8) + 40);
        id v8 = [v7 countByEnumeratingWithState:&v72 objects:v85 count:16];
        if (!v8) {
          goto LABEL_56;
        }
        id v9 = v8;
        uint64_t v64 = i;
        uint64_t v10 = *(void *)v73;
LABEL_8:
        uint64_t v11 = 0;
        while (1)
        {
          if (*(void *)v73 != v10) {
            objc_enumerationMutation(v7);
          }
          id v12 = *(void **)(*((void *)&v72 + 1) + 8 * v11);
          unsigned int v13 = [v6 zoneID:v60, v61];
          unsigned __int8 v14 = [v12 isEqual:v13];

          if (v14) {
            break;
          }
          if (v9 == (id)++v11)
          {
            id v9 = [v7 countByEnumeratingWithState:&v72 objects:v85 count:16];
            if (!v9)
            {
              uint64_t v1 = v65;
              uint64_t i = v64;
              goto LABEL_56;
            }
            goto LABEL_8;
          }
        }
        id v15 = v12;

        uint64_t v1 = v65;
        uint64_t i = v64;
        if (v15)
        {
          uint64_t v16 = *(void **)(v65 + 40);
          id v17 = [v6 zoneID];
          LOBYTE(v16) = [v16 containsObject:v17];

          if ((v16 & 1) == 0)
          {
            uint64_t v18 = *(void **)(v65 + 48);
            if (v18)
            {
              id v19 = [v18 userInfo];
              id v66 = [v19 objectForKeyedSubscript:CKPartialErrorsByItemIDKey];

              id v20 = [*(id *)(v65 + 48) domain];
              if ([v20 isEqualToString:CKErrorDomain]
                && [*(id *)(v65 + 48) code] == (id)2)
              {

                if (v66)
                {
                  id v62 = v15;
                  long long v70 = 0u;
                  long long v71 = 0u;
                  long long v68 = 0u;
                  long long v69 = 0u;
                  unsigned int v21 = v66;
                  id v22 = [v66 allKeys];
                  id v23 = [v22 countByEnumeratingWithState:&v68 objects:v84 count:16];
                  if (!v23) {
                    goto LABEL_39;
                  }
                  id v24 = v23;
                  uint64_t v25 = *(void *)v69;
                  while (1)
                  {
                    for (j = 0; j != v24; j = (char *)j + 1)
                    {
                      if (*(void *)v69 != v25) {
                        objc_enumerationMutation(v22);
                      }
                      uint64_t v27 = *(void **)(*((void *)&v68 + 1) + 8 * (void)j);
                      uint64_t v28 = [v21 objectForKeyedSubscript:v27];
                      uint64_t v29 = v28;
                      if (!v28) {
                        goto LABEL_31;
                      }
                      id v30 = [v28 domain];
                      if (([v30 isEqualToString:CKErrorDomain] & 1) == 0)
                      {

LABEL_31:
                        [*(id *)(v1 + 32) setError:*(void *)(v1 + 48)];
                        goto LABEL_37;
                      }
                      if ([v29 code] == (id)26)
                      {
                      }
                      else
                      {
                        id v31 = [v29 code];

                        BOOL v32 = v31 == (id)28;
                        unsigned int v21 = v66;
                        if (!v32) {
                          goto LABEL_31;
                        }
                      }
                      id v33 = [v6 zoneID];
                      uint64_t v34 = [v33 zoneName];
                      id v35 = sub_1000CD884(@"ckkszone", v34);

                      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)long long buf = 138412546;
                        uint64_t v81 = v27;
                        __int16 v82 = 2112;
                        id v83 = v29;
                        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "Attempted to delete zone %@, but it's already missing. This is okay: %@", buf, 0x16u);
                      }

                      uint64_t v1 = v65;
                      unsigned int v21 = v66;
LABEL_37:
                    }
                    id v24 = [v22 countByEnumeratingWithState:&v68 objects:v84 count:16];
                    if (!v24)
                    {
LABEL_39:

                      uint64_t v4 = v60;
                      uint64_t v3 = v61;
                      uint64_t i = v64;
                      id v15 = v62;
                      goto LABEL_42;
                    }
                  }
                }
              }
              else
              {
              }
              [*(id *)(v65 + 32) setError:*(void *)(v65 + 48)];
LABEL_42:
              long long v36 = [v6 zoneID];
              uint64_t v37 = [v36 zoneName];
              long long v38 = sub_1000CD884(@"ckkszone", v37);

              uint64_t v1 = v65;
              if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
              {
                id v39 = [v6 zoneID];
                long long v40 = *(void **)(v65 + 48);
                *(_DWORD *)long long buf = 138412546;
                uint64_t v81 = v39;
                __int16 v82 = 2112;
                id v83 = v40;
                _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "deletion of record zone %@ completed with error: %@", buf, 0x16u);
              }
              uint64_t v41 = [*(id *)(v65 + 32) error];

              if (v41)
              {
                uint64_t v42 = [v6 zoneID];
                uint64_t v43 = [v42 zoneName];
                uint64_t v44 = sub_1000CD884(@"ckkszone", v43);

                if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
                {
                  *(_WORD *)long long buf = 0;
                  _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "we hit a fatal error!!!", buf, 2u);
                }
LABEL_55:
                uint64_t v1 = v65;

                id v7 = v15;
LABEL_56:

                continue;
              }
            }
          }
          uint64_t v45 = [v6 zoneID];
          uint64_t v46 = [v45 zoneName];
          uint64_t v47 = sub_1000CD884(@"ckkszone", v46);

          if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
          {
            CFStringRef v48 = [v6 zoneID];
            *(_DWORD *)long long buf = 138412290;
            uint64_t v81 = v48;
            _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "deletion of record zone %@ completed successfully", buf, 0xCu);
          }
          unsigned int v49 = [*(id *)(v1 + 32) deps];
          uint64_t v50 = [v49 contextID];
          uint64_t v51 = [v6 zoneID];
          id v52 = [v51 zoneName];
          uint64_t v44 = +[CKKSZoneStateEntry contextID:v50 zoneName:v52];

          [v44 setCkzonecreated:0];
          [v44 setCkzonesubscribed:0];
          id v67 = 0;
          [v44 saveToDatabase:&v67];
          id v66 = v67;
          if (v66)
          {
            uint64_t v53 = [v6 zoneID];
            uint64_t v54 = [v53 zoneName];
            unsigned int v55 = sub_1000CD884(@"ckks", v54);

            if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
            {
              id v56 = [v6 zoneID];
              *(_DWORD *)long long buf = 138412546;
              uint64_t v81 = v56;
              __int16 v82 = 2112;
              id v83 = v66;
              _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, "couldn't save zone deletion status for %@: %@", buf, 0x16u);
            }
          }
          else
          {
            id v66 = 0;
          }
          goto LABEL_55;
        }
      }
      id v63 = [v3 countByEnumeratingWithState:&v76 objects:v86 count:16];
    }
    while (v63);
  }

  uint64_t v57 = [*(id *)(v1 + 32) operationQueue];
  uint64_t v58 = [*(id *)(v1 + 32) setResultStateOperation];
  [v57 addOperation:v58];

  return 1;
}

void sub_10006E764(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id location,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  objc_destroyWeak(v27);
  objc_destroyWeak(&location);
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

void sub_10006E7B0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v8 = sub_10000B070("octagon-cdp-status");
  BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    if (v9)
    {
      *(_DWORD *)long long buf = 138412290;
      id v34 = v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Unable to talk with TPH; leaving CDP status as 'unknown': %@",
        buf,
        0xCu);
    }

    [WeakRetained setError:v6];
    uint64_t v10 = [WeakRetained deps];
    uint64_t v11 = [v10 reachabilityTracker];
    unsigned int v12 = [v11 isNetworkError:v6];

    if (v12)
    {
      unsigned int v13 = [[OctagonPendingFlag alloc] initWithFlag:@"pending_network_availablility" conditions:2 delayInSeconds:0.2];
      unsigned __int8 v14 = [WeakRetained deps];
      id v15 = [v14 flagHandler];
      [v15 handlePendingFlag:v13];
    }
    goto LABEL_23;
  }
  if (v9)
  {
    *(_DWORD *)long long buf = 67109120;
    LODWORD(v34) = [v5 numberOfPeersInOctagon];
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Octagon reports %d peers", buf, 8u);
  }

  if ([v5 numberOfPeersInOctagon])
  {
    uint64_t v16 = *(void *)(*(void *)(a1 + 32) + 8);
    int v17 = 2;
LABEL_22:
    *(_DWORD *)(v16 + 24) = v17;
    goto LABEL_23;
  }
  uint64_t v18 = [WeakRetained deps];
  id v19 = [v18 sosAdapter];
  unsigned int v20 = [v19 sosEnabled];

  unsigned int v21 = sub_10000B070("octagon-cdp-status");
  BOOL v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
  if (!v20)
  {
    if (v22)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "No SOS. CDP bit is off.", buf, 2u);
    }

    uint64_t v16 = *(void *)(*(void *)(a1 + 32) + 8);
    int v17 = 1;
    goto LABEL_22;
  }
  if (v22)
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Requesting SOS status...", buf, 2u);
  }

  id v23 = [WeakRetained deps];
  id v24 = [v23 sosAdapter];
  id v32 = 0;
  unsigned int v25 = [v24 circleStatus:&v32];
  id v26 = v32;

  if (v26 || v25 == -1)
  {
    id v31 = sub_10000B070("octagon-cdp-status");
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v34 = v26;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Error fetching circle status. Leaving CDP status as 'unknown': %@", buf, 0xCu);
    }
  }
  else
  {
    uint64_t v27 = sub_10000B070("octagon-cdp-status");
    BOOL v28 = os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT);
    if (v25 == 3)
    {
      if (v28)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "SOS reports circle absent. Setting CDP to 'disabled'", buf, 2u);
      }

      uint64_t v29 = *(void *)(*(void *)(a1 + 32) + 8);
      int v30 = 1;
    }
    else
    {
      if (v28)
      {
        *(_DWORD *)long long buf = 67109120;
        LODWORD(v34) = v25;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "SOS reports some existing circle (%d). Setting CDP to 'enabled'", buf, 8u);
      }

      uint64_t v29 = *(void *)(*(void *)(a1 + 32) + 8);
      int v30 = 2;
    }
    *(_DWORD *)(v29 + 24) = v30;
  }

LABEL_23:
}

id sub_10006EBBC(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v4 = [v3 cdpState];
  id v5 = sub_10000B070("octagon-cdp-status");
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v4 == 2)
  {
    if (v6)
    {
      uint64_t v7 = *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      if (v7 >= 3)
      {
        id v8 = +[NSString stringWithFormat:@"(unknown: %i)", *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)];
      }
      else
      {
        id v8 = *(&off_1002F86C0 + v7);
      }
      *(_DWORD *)long long buf = 138412290;
      unsigned __int8 v14 = v8;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "CDP bit is enabled on-disk, not modifying (would have been %@)", buf, 0xCu);
    }
    id v11 = 0;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 2;
  }
  else
  {
    if (v6)
    {
      uint64_t v9 = *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      if (v9 >= 3)
      {
        uint64_t v10 = +[NSString stringWithFormat:@"(unknown: %i)", *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)];
      }
      else
      {
        uint64_t v10 = *(&off_1002F86C0 + v9);
      }
      *(_DWORD *)long long buf = 138412290;
      unsigned __int8 v14 = v10;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Writing CDP bit as %@", buf, 0xCu);
    }
    [v3 setCdpState:*(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)];
    id v11 = v3;
  }

  return v11;
}

void sub_100070198(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000701C0(uint64_t a1, void *a2)
{
  id v3 = [a2 objectForKeyedSubscript:@"count(*)"];
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = [v3 asNSInteger];
}

void sub_10007042C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v8 = [v3 objectForKeyedSubscript:@"count(rowid)"];
  unsigned int v4 = [v8 asNSNumberInteger];
  id v5 = *(void **)(a1 + 32);
  BOOL v6 = [v3 objectForKeyedSubscript:@"state"];

  uint64_t v7 = [v6 asString];
  [v5 setObject:v4 forKeyedSubscript:v7];
}

void sub_1000733EC(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v8 = [v3 objectForKeyedSubscript:@"count(rowid)"];
  unsigned int v4 = [v8 asNSNumberInteger];
  id v5 = *(void **)(a1 + 32);
  BOOL v6 = [v3 objectForKeyedSubscript:@"parentKeyUUID"];

  uint64_t v7 = [v6 asString];
  [v5 setObject:v4 forKeyedSubscript:v7];
}

void sub_1000736C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000736F0(uint64_t a1, void *a2)
{
  id v3 = [a2 objectForKeyedSubscript:@"count(*)"];
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = [v3 asNSInteger];
}

void sub_10007395C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v8 = [v3 objectForKeyedSubscript:@"count(rowid)"];
  unsigned int v4 = [v8 asNSNumberInteger];
  id v5 = *(void **)(a1 + 32);
  BOOL v6 = [v3 objectForKeyedSubscript:@"state"];

  uint64_t v7 = [v6 asString];
  [v5 setObject:v4 forKeyedSubscript:v7];
}

void sub_100074920(uint64_t a1, const __CFArray *a2, void *a3)
{
  id v4 = a3;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    CFIndex Count = CFArrayGetCount(a2);
    NSLog(@"scanning %d %@", Count, v4);
    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    CFArrayRef obj = a2;
    id v6 = [(__CFArray *)obj countByEnumeratingWithState:&v15 objects:v21 count:16];
    if (v6)
    {
      id v7 = v6;
      uint64_t v8 = *(void *)v16;
      do
      {
        uint64_t v9 = 0;
        do
        {
          if (*(void *)v16 != v8) {
            objc_enumerationMutation(obj);
          }
          uint64_t v10 = *(void *)(*((void *)&v15 + 1) + 8 * (void)v9);
          v19[0] = kSecClass;
          v19[1] = kSecValuePersistentRef;
          v20[0] = v4;
          v20[1] = v10;
          v19[2] = kSecReturnAttributes;
          v19[3] = kSecUseDataProtectionKeychain;
          int v20[2] = &__kCFBooleanTrue;
          v20[3] = &__kCFBooleanTrue;
          CFDictionaryRef v11 = +[NSDictionary dictionaryWithObjects:v20 forKeys:v19 count:4];
          CFTypeRef result = 0;
          if (SecItemCopyMatching(v11, &result) && *(_DWORD *)(a1 + 40) != -25308) {
            [*(id *)(a1 + 32) addObject:v11];
          }

          uint64_t v9 = (char *)v9 + 1;
        }
        while (v7 != v9);
        id v7 = [(__CFArray *)obj countByEnumeratingWithState:&v15 objects:v21 count:16];
      }
      while (v7);
    }
  }
}

void sub_100074DDC(id a1)
{
  qword_10035CD60 = [[SFKeychainControlManager alloc] _init];

  _objc_release_x1();
}

uint64_t sub_100074E1C()
{
  uint64_t v0 = +[SFKeychainControlManager sharedManager];
  uint64_t v1 = [v0 xpcControlEndpoint];

  return v1;
}

void sub_100075788(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_1000757CC(uint64_t a1, uint64_t a2)
{
  return sub_100139FCC(a2, *(void *)(a1 + 40), 0, (CFTypeRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
}

void sub_100076568(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47)
{
  _Block_object_dispose((const void *)(v47 - 176), 8);
  _Block_object_dispose(&a27, 8);
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a41, 8);
  _Block_object_dispose(&a47, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100076604(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100076614(uint64_t a1)
{
}

uint64_t sub_10007661C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = *(void *)(a1 + 104);
  id v5 = (__CFString **)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 3221225472;
  int v15[2] = sub_10007675C;
  v15[3] = &unk_1002F8778;
  id v16 = *(id *)(a1 + 32);
  id v6 = *(id *)(a1 + 40);
  uint64_t v7 = *(void *)(a1 + 104);
  char v24 = *(unsigned char *)(a1 + 112);
  uint64_t v8 = *(void *)(a1 + 72);
  uint64_t v23 = v7;
  uint64_t v20 = v8;
  uint64_t v9 = *(void *)(a1 + 48);
  uint64_t v10 = *(void **)(a1 + 56);
  id v17 = v6;
  uint64_t v18 = v9;
  id v19 = v10;
  long long v21 = *(_OWORD *)(a1 + 80);
  uint64_t v22 = *(void *)(a1 + 96);
  if ((sub_10011C214(v4, a2, v5, (uint64_t)v15) & 1) == 0)
  {
    if (!sub_10011C1B8(*(__CFError **)(*(void *)(*(void *)(a1 + 64) + 8) + 24)))
    {
      uint64_t v13 = 0;
      goto LABEL_7;
    }
    uint64_t v11 = *(void *)(*(void *)(a1 + 64) + 8);
    unsigned int v12 = *(const void **)(v11 + 24);
    if (v12)
    {
      *(void *)(v11 + 24) = 0;
      CFRelease(v12);
    }
  }
  uint64_t v13 = 1;
LABEL_7:

  return v13;
}

void sub_10007675C(uint64_t a1, CFDictionaryRef *a2, uint64_t *a3)
{
  uint64_t v90 = SecCoreAnalyticsValue;
  size_t v91 = &off_100325B58;
  id v6 = +[NSDictionary dictionaryWithObjects:&v91 forKeys:&v90 count:1];
  +[SecCoreAnalytics sendEvent:@"com.apple.security.ckks.pkconflict" event:v6];

  uint64_t v7 = (const void *)kSecAttrUUID;
  if (CFDictionaryContainsKey(a2[6], kSecAttrUUID))
  {
    if (*(unsigned char *)(a1 + 104))
    {
      CFStringRef Value = (const __CFString *)CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 96) + 48), v7);
      CFStringRef v9 = (const __CFString *)CFDictionaryGetValue(a2[6], v7);
      uint64_t v10 = [*(id *)(a1 + 48) deps];
      uint64_t v11 = [v10 contextID];
      unsigned int v12 = [*(id *)(a1 + 32) zoneID];
      id v81 = 0;
      uint64_t v13 = +[CKKSMirrorEntry tryFromDatabase:v9 contextID:v11 zoneID:v12 error:&v81];
      unint64_t v14 = (unint64_t)v81;

      if (v14)
      {
        long long v15 = [*(id *)(a1 + 32) zoneID];
        id v16 = [v15 zoneName];
        id v17 = sub_1000CD884(@"ckksincoming", v16);

        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412546;
          CFTypeRef v83 = a2;
          __int16 v84 = 2112;
          CFStringRef v85 = (const __CFString *)v14;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Unable to fetch ckme for old item %@: %@", buf, 0x16u);
        }
      }
      CFComparisonResult v18 = CFStringCompare(Value, v9, 0);
      long long v72 = (void *)v13;
      long long v73 = (void *)v14;
      BOOL v19 = (v13 | v14) != 0;
      uint64_t v20 = [*(id *)(a1 + 32) zoneID];
      long long v21 = [v20 zoneName];
      uint64_t v22 = sub_1000CD884(@"ckksincoming", v21);

      BOOL v23 = os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT);
      if (v18 == kCFCompareGreaterThan && v19)
      {
        if (v23)
        {
          CFStringRef v24 = *(const __CFString **)(a1 + 96);
          *(_DWORD *)long long buf = 138413059;
          CFTypeRef v83 = Value;
          __int16 v84 = 2113;
          CFStringRef v85 = v24;
          __int16 v86 = 2112;
          CFStringRef v87 = v9;
          __int16 v88 = 2113;
          uint64_t v89 = a2;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Primary key conflict; deleting incoming CK item (%@)%{private}@in favor of old item (%@)%{private}@",
            buf,
            0x2Au);
        }

        uint64_t v25 = *(void *)(a1 + 96);
        id v26 = [*(id *)(a1 + 48) deps];
        uint64_t v27 = [v26 contextID];
        BOOL v28 = [*(id *)(a1 + 32) zoneID];
        uint64_t v29 = *(void *)(a1 + 56);
        uint64_t v30 = *(void *)(*(void *)(a1 + 72) + 8);
        id obj = *(id *)(v30 + 40);
        id v31 = +[CKKSOutgoingQueueEntry withItem:v25 action:@"delete" contextID:v27 zoneID:v28 keyCache:v29 error:&obj];
        objc_storeStrong((id *)(v30 + 40), obj);

        uint64_t v32 = *(void *)(*(void *)(a1 + 72) + 8);
        id v79 = *(id *)(v32 + 40);
        [v31 saveToDatabase:&v79];
        objc_storeStrong((id *)(v32 + 40), v79);
        [*(id *)(a1 + 48) setNewOutgoingEntries:1];
        uint64_t v33 = *(void *)(*(void *)(a1 + 80) + 8);
        id v34 = *(void **)(v33 + 40);
        *(void *)(v33 + 40) = 0;

        id v35 = [*(id *)(a1 + 48) deps];
        long long v36 = [v35 contextID];
        uint64_t v37 = [*(id *)(a1 + 32) zoneID];
        uint64_t v38 = *(void *)(a1 + 56);
        uint64_t v39 = *(void *)(*(void *)(a1 + 72) + 8);
        id v78 = *(id *)(v39 + 40);
        long long v40 = +[CKKSOutgoingQueueEntry withItem:a2 action:@"add" contextID:v36 zoneID:v37 keyCache:v38 error:&v78];
        objc_storeStrong((id *)(v39 + 40), v78);

        uint64_t v41 = *(void *)(*(void *)(a1 + 72) + 8);
        id v77 = *(id *)(v41 + 40);
        [v40 saveToDatabase:&v77];
        objc_storeStrong((id *)(v41 + 40), v77);
        *(unsigned char *)(*(void *)(*(void *)(a1 + 88) + 8) + 24) = 1;

        uint64_t v42 = v72;
      }
      else
      {
        uint64_t v42 = v72;
        if (v23)
        {
          CFStringRef v52 = &stru_10030AA90;
          if (!v72) {
            CFStringRef v52 = @"non-onboarded";
          }
          *(_DWORD *)long long buf = 138412290;
          CFTypeRef v83 = v52;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Primary key conflict; replacing %@ with CK item",
            buf,
            0xCu);
        }

        if (a3)
        {
          uint64_t v53 = *(void *)(a1 + 96);
          if (v53) {
            CFRetain(*(CFTypeRef *)(a1 + 96));
          }
          *a3 = v53;
          uint64_t v54 = CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 96) + 48), kSecAttrModificationDate);
          uint64_t v55 = *(void *)(*(void *)(a1 + 80) + 8);
          id v56 = *(void **)(v55 + 40);
          *(void *)(v55 + 40) = v54;
        }
        if (v18 == kCFCompareEqualTo)
        {
LABEL_34:
          sub_100119CB8(a2, kSecAttrPersistentReference);
          CFDataRef v66 = (const __CFData *)objc_claimAutoreleasedReturnValue();
          CFDataRef v67 = v66;
          if (a3)
          {
            if (*a3)
            {
LABEL_36:
              if (v67)
              {
                if ([(__CFData *)v67 length] == (id)16)
                {
                  CFTypeRef cf = 0;
                  sub_10011B6B0(*a3, v67, (__CFString **)&cf);
                  if (cf)
                  {
                    long long v68 = [*(id *)(a1 + 32) zoneID];
                    long long v69 = [v68 zoneName];
                    long long v70 = sub_1000CD884(@"ckksincoming", v69);

                    if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)long long buf = 138412290;
                      CFTypeRef v83 = cf;
                      _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "error setting uuid persistent ref: %@", buf, 0xCu);
                    }

                    CFTypeRef v71 = cf;
                    if (cf)
                    {
                      CFTypeRef cf = 0;
                      CFRelease(v71);
                    }
                  }
                }
              }
              goto LABEL_48;
            }
            if (v66 && [(__CFData *)v66 length] == (id)16)
            {
              if (*a3) {
                goto LABEL_36;
              }
            }
            else
            {
              [*(id *)(a1 + 48) _onqueueGenerateNewUUIDPersistentRefOnSecItem:a2 viewState:*(void *)(a1 + 32) v72 v73];
              CFRetain(a2);
              *a3 = (uint64_t)a2;
            }
          }
LABEL_48:

          return;
        }
        uint64_t v57 = [*(id *)(a1 + 32) zoneID];
        uint64_t v58 = [v57 zoneName];
        uint64_t v59 = sub_1000CD884(@"ckksincoming", v58);

        if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412803;
          CFTypeRef v83 = v9;
          __int16 v84 = 2112;
          CFStringRef v85 = Value;
          __int16 v86 = 2113;
          CFStringRef v87 = (const __CFString *)a2;
          _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "UUID of olditem (%@) is higher than UUID of incoming item (%@), issuing deletion of olditem: %{private}@", buf, 0x20u);
        }

        uint64_t v60 = [*(id *)(a1 + 48) deps];
        id v61 = [v60 contextID];
        id v62 = [*(id *)(a1 + 32) zoneID];
        uint64_t v63 = *(void *)(a1 + 56);
        uint64_t v64 = *(void *)(*(void *)(a1 + 72) + 8);
        id v76 = *(id *)(v64 + 40);
        id v31 = +[CKKSOutgoingQueueEntry withItem:a2 action:@"delete" contextID:v61 zoneID:v62 keyCache:v63 error:&v76];
        objc_storeStrong((id *)(v64 + 40), v76);

        uint64_t v65 = *(void *)(*(void *)(a1 + 72) + 8);
        id v75 = *(id *)(v65 + 40);
        [v31 saveToDatabase:&v75];
        objc_storeStrong((id *)(v65 + 40), v75);
        [*(id *)(a1 + 48) setNewOutgoingEntries:1];
      }

      goto LABEL_34;
    }
    CFStringRef v48 = [*(id *)(a1 + 32) zoneID];
    unsigned int v49 = [v48 zoneName];
    uint64_t v50 = sub_1000CD884(@"ckksincoming", v49);

    if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v51 = *(const void **)(a1 + 96);
      *(_DWORD *)long long buf = 138477827;
      CFTypeRef v83 = v51;
      _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "Primary key conflict; dropping CK item (arriving from wrong view) %{private}@",
        buf,
        0xCu);
    }

    *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = 1;
  }
  else
  {
    uint64_t v43 = [*(id *)(a1 + 32) zoneID];
    uint64_t v44 = [v43 zoneName];
    uint64_t v45 = sub_1000CD884(@"ckksincoming", v44);

    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v46 = [*(id *)(a1 + 40) uuid];
      *(_DWORD *)long long buf = 138412290;
      CFTypeRef v83 = v46;
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "Replacing item (it doesn't have a UUID) for %@", buf, 0xCu);
    }
    if (a3)
    {
      uint64_t v47 = *(const void **)(a1 + 96);
      if (v47) {
        CFRetain(v47);
      }
      *a3 = (uint64_t)v47;
    }
  }
}

void sub_100077780(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  _Block_object_dispose(&a21, 8);
  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a29, 8);
  _Block_object_dispose((const void *)(v29 - 160), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000777C8(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
  id v3 = [*(id *)(a1 + 32) deps];
  uint64_t v4 = [v3 contextID];
  id v5 = [*(id *)(a1 + 40) zoneID];
  id v35 = 0;
  id v6 = +[CKKSIncomingQueueEntry fetch:50 startingAtUUID:v2 state:@"mismatched_view" action:0 contextID:v4 zoneID:v5 error:&v35];
  id v7 = v35;

  if (!v7)
  {
    *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = [v6 count];
    id v11 = [v6 count];
    unsigned int v12 = [*(id *)(a1 + 40) zoneName];
    uint64_t v13 = sub_1000CD884(@"ckksincoming", v12);

    BOOL v14 = os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT);
    if (v11)
    {
      if (v14)
      {
        id v15 = [v6 count];
        *(_DWORD *)long long buf = 134217984;
        id v38 = v15;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Inspecting %lu mismatched items", buf, 0xCu);
      }

      *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) += [v6 count];
      if (([*(id *)(a1 + 32) intransaction:*(void *)(a1 + 40) processQueueEntries:v6] & 1) == 0)
      {
        uint64_t v29 = [*(id *)(a1 + 40) zoneName];
        uint64_t v30 = sub_1000CD884(@"ckksincoming", v29);

        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "processQueueEntries didn't complete successfully", buf, 2u);
        }

        goto LABEL_5;
      }
      long long v33 = 0u;
      long long v34 = 0u;
      long long v31 = 0u;
      long long v32 = 0u;
      uint64_t v13 = v6;
      id v16 = [v13 countByEnumeratingWithState:&v31 objects:v36 count:16];
      if (v16)
      {
        id v17 = v16;
        uint64_t v18 = *(void *)v32;
        do
        {
          for (uint64_t i = 0; i != v17; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v32 != v18) {
              objc_enumerationMutation(v13);
            }
            uint64_t v20 = *(void **)(*((void *)&v31 + 1) + 8 * i);
            long long v21 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
            uint64_t v22 = [v20 uuid];
            if ([v21 compare:v22] == (id)1)
            {
              uint64_t v23 = *(void *)(*(void *)(a1 + 48) + 8);
              id v24 = *(id *)(v23 + 40);
              uint64_t v25 = *(void **)(v23 + 40);
              *(void *)(v23 + 40) = v24;
            }
            else
            {
              uint64_t v26 = [v20 uuid];
              uint64_t v27 = *(void *)(*(void *)(a1 + 48) + 8);
              uint64_t v25 = *(void **)(v27 + 40);
              *(void *)(v27 + 40) = v26;
            }
          }
          id v17 = [v13 countByEnumeratingWithState:&v31 objects:v36 count:16];
        }
        while (v17);
      }
    }
    else if (v14)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "No mismatched view items", buf, 2u);
    }

    uint64_t v10 = 1;
    goto LABEL_24;
  }
  uint64_t v8 = [*(id *)(a1 + 40) zoneName];
  CFStringRef v9 = sub_1000CD884(@"ckksincoming", v8);

  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Cannot fetch mismatched view items", buf, 2u);
  }

  [*(id *)(a1 + 32) setError:v7];
LABEL_5:
  uint64_t v10 = 0;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 1;
LABEL_24:

  return v10;
}

void sub_100077E8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  _Block_object_dispose(&a26, 8);
  _Block_object_dispose(&a30, 8);
  _Block_object_dispose((const void *)(v30 - 168), 8);
  _Block_object_dispose((const void *)(v30 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100077ED4(uint64_t a1)
{
  if (![*(id *)(a1 + 32) isCancelled])
  {
    uint64_t v5 = *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
    uint64_t v6 = *(void *)(a1 + 48);
    id v7 = [*(id *)(a1 + 32) deps];
    uint64_t v8 = [v7 contextID];
    CFStringRef v9 = [*(id *)(a1 + 40) zoneID];
    id v38 = 0;
    uint64_t v10 = +[CKKSIncomingQueueEntry fetch:50 startingAtUUID:v5 state:@"new" action:v6 contextID:v8 zoneID:v9 error:&v38];
    id v11 = v38;

    if (v11)
    {
      unsigned int v12 = [*(id *)(a1 + 40) zoneName];
      uint64_t v13 = sub_1000CD884(@"ckksincoming", v12);

      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        id v41 = v11;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Error fetching incoming queue records: %@", buf, 0xCu);
      }

      [*(id *)(a1 + 32) setError:v11];
      uint64_t v4 = 0;
    }
    else
    {
      *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) = [v10 count];
      *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) += [v10 count];
      if ([v10 count])
      {
        BOOL v14 = [*(id *)(a1 + 40) zoneID];
        id v15 = [v14 zoneName];
        +[CKKSPowerCollection CKKSPowerEvent:zone:count:](CKKSPowerCollection, "CKKSPowerEvent:zone:count:", @"processIncomingQueue", v15, [v10 count]);

        if (([*(id *)(a1 + 32) intransaction:*(void *)(a1 + 40) processQueueEntries:v10] & 1) == 0)
        {
          uint64_t v30 = [*(id *)(a1 + 40) zoneName];
          long long v31 = sub_1000CD884(@"ckksincoming", v30);

          if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "processQueueEntries didn't complete successfully", buf, 2u);
          }

          uint64_t v4 = 0;
          *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 1;
          goto LABEL_28;
        }
        long long v36 = 0u;
        long long v37 = 0u;
        long long v34 = 0u;
        long long v35 = 0u;
        id v16 = v10;
        id v17 = [v16 countByEnumeratingWithState:&v34 objects:v39 count:16];
        if (v17)
        {
          id v18 = v17;
          uint64_t v19 = *(void *)v35;
          do
          {
            for (uint64_t i = 0; i != v18; uint64_t i = (char *)i + 1)
            {
              if (*(void *)v35 != v19) {
                objc_enumerationMutation(v16);
              }
              long long v21 = *(void **)(*((void *)&v34 + 1) + 8 * i);
              uint64_t v22 = *(void **)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
              uint64_t v23 = [v21 uuid];
              if ([v22 compare:v23] == (id)1)
              {
                uint64_t v24 = *(void *)(*(void *)(a1 + 64) + 8);
                id v25 = *(id *)(v24 + 40);
                uint64_t v26 = *(void **)(v24 + 40);
                *(void *)(v24 + 40) = v25;
              }
              else
              {
                uint64_t v27 = [v21 uuid];
                uint64_t v28 = *(void *)(*(void *)(a1 + 64) + 8);
                uint64_t v26 = *(void **)(v28 + 40);
                *(void *)(v28 + 40) = v27;
              }
            }
            id v18 = [v16 countByEnumeratingWithState:&v34 objects:v39 count:16];
          }
          while (v18);
        }
      }
      else
      {
        uint64_t v29 = [*(id *)(a1 + 40) zoneName];
        id v16 = sub_1000CD884(@"ckksincoming", v29);

        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          long long v33 = *(void **)(a1 + 48);
          *(_DWORD *)long long buf = 138412290;
          id v41 = v33;
          _os_log_debug_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "Nothing in incoming queue to process (filter: %@)", buf, 0xCu);
        }
      }

      uint64_t v4 = 1;
    }
LABEL_28:

    return v4;
  }
  uint64_t v2 = [*(id *)(a1 + 40) zoneName];
  id v3 = sub_1000CD884(@"ckksincoming", v2);

  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "CKKSIncomingQueueOperation cancelled, quitting", buf, 2u);
  }

  uint64_t v4 = 0;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 1;
  return v4;
}

uint64_t sub_100079364(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) zoneID];
  id v3 = [*(id *)(a1 + 32) contextID];
  id v17 = 0;
  uint64_t v4 = +[CKKSCurrentItemPointer remoteItemPointers:v2 contextID:v3 error:&v17];
  id v5 = v17;

  if (v5) {
    BOOL v6 = 1;
  }
  else {
    BOOL v6 = v4 == 0;
  }
  if (v6)
  {
    id v7 = [*(id *)(a1 + 32) zoneName];
    uint64_t v8 = sub_1000CD884(@"ckksincoming", v7);

    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      id v19 = v5;
      CFStringRef v9 = "Could not load remote item pointers: %@";
      uint64_t v10 = v8;
      os_log_type_t v11 = OS_LOG_TYPE_ERROR;
LABEL_12:
      _os_log_impl((void *)&_mh_execute_header, v10, v11, v9, buf, 0xCu);
    }
LABEL_13:

    goto LABEL_14;
  }
  if (![*(id *)(a1 + 40) processNewCurrentItemPointers:v4 viewState:*(void *)(a1 + 32)])
  {
    uint64_t v15 = 0;
    goto LABEL_16;
  }
  if ([v4 count])
  {
    uint64_t v13 = [*(id *)(a1 + 32) zoneName];
    uint64_t v8 = sub_1000CD884(@"ckksincoming", v13);

    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      id v14 = [v4 count];
      *(_DWORD *)long long buf = 134217984;
      id v19 = v14;
      CFStringRef v9 = "Processed %lu items in CIP queue";
      uint64_t v10 = v8;
      os_log_type_t v11 = OS_LOG_TYPE_DEFAULT;
      goto LABEL_12;
    }
    goto LABEL_13;
  }
LABEL_14:
  uint64_t v15 = 1;
LABEL_16:

  return v15;
}

uint64_t sub_10007C6E4(uint64_t a1)
{
  uint64_t v1 = a1;
  if (!*(void *)(a1 + 32))
  {
    long long v221 = 0u;
    long long v222 = 0u;
    long long v219 = 0u;
    long long v220 = 0u;
    id v19 = *(id *)(a1 + 80);
    id v20 = [v19 countByEnumeratingWithState:&v219 objects:v233 count:16];
    if (v20)
    {
      id v21 = v20;
      uint64_t v22 = *(void *)v220;
      do
      {
        for (uint64_t i = 0; i != v21; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v220 != v22) {
            objc_enumerationMutation(v19);
          }
          uint64_t v24 = *(void **)(*((void *)&v219 + 1) + 8 * i);
          id v25 = [*(id *)(a1 + 40) zoneID];
          uint64_t v26 = [v25 zoneName];
          uint64_t v27 = sub_1000CD884(@"ckksoutgoing", v26);

          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v28 = [v24 recordName];
            *(_DWORD *)long long buf = 138412290;
            *(void *)v235 = v28;
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Record deletion successful for %@", buf, 0xCu);
          }
        }
        id v21 = [v19 countByEnumeratingWithState:&v219 objects:v233 count:16];
      }
      while (v21);
    }

    uint64_t v29 = [*(id *)(a1 + 40) zoneID];
    uint64_t v30 = [v29 zoneName];
    long long v31 = sub_1000CD884(@"ckksoutgoing", v30);

    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v32 = [*(id *)(a1 + 88) count];
      unsigned int v33 = [*(id *)(a1 + 80) count];
      *(_DWORD *)long long buf = 67109376;
      *(_DWORD *)v235 = v32;
      *(_WORD *)&v235[4] = 1024;
      *(_DWORD *)&v235[6] = v33;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Completed processing outgoing queue (%d modifications, %d deletions)", buf, 0xEu);
    }

    CFDataRef v196 = objc_alloc_init(CKKSPowerCollection);
    id v34 = objc_alloc((Class)AAFAnalyticsEventSecurity);
    uint64_t v231 = kSecurityRTCFieldTotalCKRecords;
    long long v35 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [*(id *)(a1 + 88) count]);
    v232 = v35;
    long long v36 = +[NSDictionary dictionaryWithObjects:&v232 forKeys:&v231 count:1];
    long long v37 = [*(id *)(a1 + 56) deps];
    id v38 = [v37 activeAccount];
    uint64_t v39 = [v38 altDSID];
    uint64_t v40 = kSecurityRTCEventNameSaveCKMirrorEntries;
    uint64_t v41 = kSecurityRTCEventCategoryAccountDataAccessRecovery;
    uint64_t v42 = [*(id *)(a1 + 56) deps];
    id v186 = [v34 initWithCKKSMetrics:v36 altDSID:v39 eventName:v40 testsAreEnabled:0 category:v41 sendMetric:objc_msgSend(v42, "sendMetric")];

    uint64_t v43 = (id *)a1;
    long long v217 = 0u;
    long long v218 = 0u;
    long long v215 = 0u;
    long long v216 = 0u;
    id obj = *(id *)(a1 + 88);
    id v191 = [obj countByEnumeratingWithState:&v215 objects:v230 count:16];
    id v44 = 0;
    uint64_t v45 = 0;
    if (!v191)
    {
LABEL_51:
      v199 = v45;

      long long v208 = 0u;
      long long v209 = 0u;
      long long v206 = 0u;
      long long v207 = 0u;
      id obja = v43[10];
      id v195 = [obja countByEnumeratingWithState:&v206 objects:v229 count:16];
      id v102 = 0;
      if (v195)
      {
        uint64_t v192 = *(void *)v207;
        do
        {
          for (j = 0; j != v195; j = (char *)j + 1)
          {
            if (*(void *)v207 != v192) {
              objc_enumerationMutation(obja);
            }
            v104 = *(void **)(*((void *)&v206 + 1) + 8 * (void)j);
            CFDataRef v105 = [v104 recordName];
            CFStringRef v106 = [v43[7] deps];
            CFStringRef v107 = [v106 contextID];
            uint64_t v108 = [*(id *)(a1 + 40) zoneID];
            id v205 = v102;
            id v109 = +[CKKSOutgoingQueueEntry fromDatabase:v105 state:@"inflight" contextID:v107 zoneID:v108 error:&v205];
            id v110 = v205;

            id v111 = (id *)a1;
            uint64_t v112 = *(void *)(a1 + 40);
            id v204 = v110;
            [v109 intransactionMoveToState:@"deleted" viewState:v112 error:&v204];
            id v113 = v204;

            if (v113)
            {
              long long v114 = [*(id *)(a1 + 40) zoneID];
              long long v115 = [v114 zoneName];
              long long v116 = sub_1000CD884(@"ckksoutgoing", v115);

              if (os_log_type_enabled(v116, OS_LOG_TYPE_ERROR))
              {
                long long v117 = [v104 recordName];
                *(_DWORD *)long long buf = 138412546;
                *(void *)v235 = v117;
                *(_WORD *)&v235[8] = 2112;
                id v236 = v113;
                _os_log_impl((void *)&_mh_execute_header, v116, OS_LOG_TYPE_ERROR, "Couldn't delete %@ from outgoingqueue: %@", buf, 0x16u);
              }
              id v118 = v113;

              id v111 = (id *)a1;
              [*(id *)(a1 + 56) setError:v118];
              v199 = v118;
            }

            long long v119 = [v104 recordName];
            long long v120 = [v111[7] deps];
            long long v121 = [v120 contextID];
            long long v122 = [v111[5] zoneID];
            id v203 = 0;
            long long v123 = +[CKKSMirrorEntry tryFromDatabase:v119 contextID:v121 zoneID:v122 error:&v203];
            id v124 = v203;

            id v202 = v124;
            [v123 deleteFromDatabase:&v202];
            id v102 = v202;

            if (v102)
            {
              id v125 = [v111[5] zoneID];
              id v126 = [v125 zoneName];
              id v127 = sub_1000CD884(@"ckksoutgoing", v126);

              if (os_log_type_enabled(v127, OS_LOG_TYPE_ERROR))
              {
                id v128 = [v104 recordName];
                *(_DWORD *)long long buf = 138412546;
                *(void *)v235 = v128;
                *(_WORD *)&v235[8] = 2112;
                id v236 = v102;
                _os_log_impl((void *)&_mh_execute_header, v127, OS_LOG_TYPE_ERROR, "Couldn't delete %@ from ckmirror: %@", buf, 0x16u);
              }
              id v129 = v102;

              uint64_t v43 = (id *)a1;
              [*(id *)(a1 + 56) setError:v129];
              v199 = v129;
            }
            else
            {
              uint64_t v43 = v111;
            }
            [(CKKSPowerCollection *)v196 deletedOQE:v109];
          }
          id v195 = [obja countByEnumeratingWithState:&v206 objects:v229 count:16];
        }
        while (v195);
      }

      char v130 = [v43[7] error];
      uint64_t v131 = [v43[7] error];
      +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v186 success:v130 == 0 error:v131];

      [(CKKSPowerCollection *)v196 commit];
      uint64_t v132 = [*(id *)(a1 + 56) deps];
      v133 = [v132 overallLaunch];
      [v133 addEvent:@"process-outgoing-queue-complete"];

      if (v199)
      {
        BOOL v134 = [*(id *)(a1 + 40) zoneID];
        v135 = [v134 zoneName];
        size_t v136 = sub_1000CD884(@"ckksoutgoing", v135);

        if (os_log_type_enabled(v136, OS_LOG_TYPE_ERROR))
        {
          v137 = [*(id *)(a1 + 56) error];
          *(_DWORD *)long long buf = 138412290;
          *(void *)v235 = v137;
          _os_log_impl((void *)&_mh_execute_header, v136, OS_LOG_TYPE_ERROR, "Operation failed; rolling back: %@",
            buf,
            0xCu);
        }
        BOOL v138 = *(void **)(a1 + 48);
        unsigned int v139 = [*(id *)(a1 + 56) error];
        CFArrayRef v140 = [*(id *)(a1 + 40) zoneID];
        CFStringRef v141 = [v140 zoneName];
        [v138 logRecoverableError:v139 forEvent:@"CKKSEventProcessOutgoingQueue" zoneName:v141 withAttributes:0];

        uint64_t v142 = 0;
      }
      else
      {
        CFDictionaryRef v151 = *(void **)(a1 + 48);
        unsigned int v139 = [*(id *)(a1 + 40) zoneID];
        CFArrayRef v140 = [v139 zoneName];
        [v151 logSuccessForEvent:@"CKKSEventProcessOutgoingQueue" zoneName:v140];
        uint64_t v142 = 1;
      }

      return v142;
    }
    uint64_t v190 = *(void *)v216;
LABEL_22:
    uint64_t v46 = 0;
    while (1)
    {
      if (*(void *)v216 != v190) {
        objc_enumerationMutation(obj);
      }
      uint64_t v47 = *(void **)(*((void *)&v215 + 1) + 8 * v46);
      CFStringRef v48 = [v47 recordType];
      unsigned int v49 = [v48 isEqualToString:@"item"];

      if (v49)
      {
        v198 = v45;
        v194 = v47;
        uint64_t v50 = [v47 recordID];
        uint64_t v51 = [v50 recordName];
        CFStringRef v52 = [v43[7] deps];
        uint64_t v53 = [v52 contextID];
        uint64_t v54 = [v43[5] zoneID];
        id v214 = v44;
        uint64_t v55 = +[CKKSOutgoingQueueEntry fromDatabase:v51 state:@"inflight" contextID:v53 zoneID:v54 error:&v214];
        id v56 = v43;
        id v57 = v214;

        uint64_t v58 = v55;
        id v59 = v56[5];
        id v213 = v57;
        [v55 intransactionMoveToState:@"deleted" viewState:v59 error:&v213];
        id v60 = v213;

        if (v60)
        {
          id v61 = [v56[5] zoneID];
          id v62 = [v61 zoneName];
          uint64_t v63 = sub_1000CD884(@"ckksoutgoing", v62);

          uint64_t v43 = v56;
          if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
          {
            uint64_t v64 = [v194 recordID];
            uint64_t v65 = [v64 recordName];
            *(_DWORD *)long long buf = 138412546;
            *(void *)v235 = v65;
            *(_WORD *)&v235[8] = 2112;
            id v236 = v60;
            _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "Couldn't update %@ in outgoingqueue: %@", buf, 0x16u);
          }
          id v66 = v60;

          [v56[7] setError:v66];
          uint64_t v45 = v66;
        }
        else
        {
          uint64_t v43 = v56;
          uint64_t v45 = v198;
        }

        uint64_t v89 = [CKKSMirrorEntry alloc];
        uint64_t v90 = [v43[7] deps];
        size_t v91 = [v90 contextID];
        id v92 = [(CKKSMirrorEntry *)v89 initWithCKRecord:v194 contextID:v91];

        id v212 = 0;
        [(CKKSSQLDatabaseObject *)v92 saveToDatabase:&v212];
        id v44 = v212;
        if (v44)
        {
          uint64_t v93 = [v43[5] zoneID];
          CFDictionaryRef v94 = [v93 zoneName];
          v95 = sub_1000CD884(@"ckksoutgoing", v94);

          if (os_log_type_enabled(v95, OS_LOG_TYPE_ERROR))
          {
            BOOL v96 = [v194 recordID];
            uint64_t v97 = [v96 recordName];
            *(_DWORD *)long long buf = 138412546;
            *(void *)v235 = v97;
            *(_WORD *)&v235[8] = 2112;
            id v236 = v44;
            _os_log_impl((void *)&_mh_execute_header, v95, OS_LOG_TYPE_ERROR, "Couldn't save %@ to ckmirror: %@", buf, 0x16u);
          }
          id v98 = v44;

          [v43[7] setError:v98];
          uint64_t v45 = v98;
          uint64_t v58 = v55;
        }
        [(CKKSPowerCollection *)v196 storedOQE:v58];

        goto LABEL_49;
      }
      CFDataRef v67 = [v47 recordType];
      unsigned int v68 = [v67 isEqualToString:@"currentkey"];

      if (v68)
      {
        long long v69 = [CKKSCurrentKeyPointer alloc];
        long long v70 = [v43[7] deps];
        CFTypeRef v71 = [v70 contextID];
        long long v72 = v47;
        uint64_t v58 = [(CKKSCKRecordHolder *)v69 initWithCKRecord:v47 contextID:v71];

        id v211 = v44;
        [v58 saveToDatabase:&v211];
        id v73 = v211;

        if (!v73) {
          goto LABEL_46;
        }
        long long v74 = [v43[5] zoneID];
        id v75 = [v74 zoneName];
        id v76 = sub_1000CD884(@"ckksoutgoing", v75);

        if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
        {
          id v77 = [v72 recordID];
          id v78 = [v77 recordName];
          *(_DWORD *)long long buf = 138412546;
          *(void *)v235 = v78;
          *(_WORD *)&v235[8] = 2112;
          id v236 = v73;
          id v79 = v76;
          long long v80 = "Couldn't save %@ to currentkey: %@";
LABEL_38:
          _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_ERROR, v80, buf, 0x16u);
        }
      }
      else
      {
        id v81 = [v47 recordType];
        unsigned int v82 = [v81 isEqualToString:@"devicestate"];

        if (!v82)
        {
          uint64_t v99 = v47;
          BOOL v100 = [v43[5] zoneID];
          unsigned int v101 = [v100 zoneName];
          uint64_t v58 = sub_1000CD884(@"ckksoutgoing", v101);

          if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138412290;
            *(void *)v235 = v99;
            _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_ERROR, "unknown record type in results: %@", buf, 0xCu);
          }
          goto LABEL_49;
        }
        CFTypeRef v83 = [CKKSDeviceStateEntry alloc];
        __int16 v84 = [v43[7] deps];
        CFStringRef v85 = [v84 contextID];
        __int16 v86 = v47;
        uint64_t v58 = [(CKKSCKRecordHolder *)v83 initWithCKRecord:v47 contextID:v85];

        id v210 = v44;
        [v58 saveToDatabase:&v210];
        id v73 = v210;

        if (!v73)
        {
LABEL_46:
          id v44 = 0;
          goto LABEL_49;
        }
        CFStringRef v87 = [v43[5] zoneID];
        __int16 v88 = [v87 zoneName];
        id v76 = sub_1000CD884(@"ckksoutgoing", v88);

        if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
        {
          id v77 = [v86 recordID];
          id v78 = [v77 recordName];
          *(_DWORD *)long long buf = 138412546;
          *(void *)v235 = v78;
          *(_WORD *)&v235[8] = 2112;
          id v236 = v73;
          id v79 = v76;
          long long v80 = "Couldn't save %@ to ckdevicestate: %@";
          goto LABEL_38;
        }
      }

      id v44 = v73;
      [v43[7] setError:v44];
      uint64_t v45 = v44;
LABEL_49:

      if (v191 == (id)++v46)
      {
        id v191 = [obj countByEnumeratingWithState:&v215 objects:v230 count:16];
        if (!v191) {
          goto LABEL_51;
        }
        goto LABEL_22;
      }
    }
  }
  uint64_t v2 = [*(id *)(a1 + 40) zoneID];
  id v3 = [v2 zoneName];
  uint64_t v4 = sub_1000CD884(@"ckksoutgoing", v3);

  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    uint64_t v5 = *(void *)(v1 + 32);
    *(_DWORD *)long long buf = 138412290;
    *(void *)v235 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "error processing outgoing queue: %@", buf, 0xCu);
  }

  BOOL v6 = *(void **)(v1 + 48);
  uint64_t v7 = *(void *)(v1 + 32);
  uint64_t v8 = [*(id *)(v1 + 40) zoneID];
  CFStringRef v9 = [v8 zoneName];
  [v6 logRecoverableError:v7 forEvent:@"CKKSEventProcessOutgoingQueue" zoneName:v9 withAttributes:0];

  uint64_t v10 = [*(id *)(v1 + 56) deps];
  [v10 intransactionCKWriteFailed:*(void *)(v1 + 32) attemptedRecordsChanged:*(void *)(v1 + 64)];

  os_log_type_t v11 = [*(id *)(v1 + 32) domain];
  if ([v11 isEqualToString:CKErrorDomain])
  {
    id v12 = [*(id *)(v1 + 32) code];

    if (v12 == (id)2)
    {
      uint64_t v13 = [*(id *)(v1 + 32) userInfo];
      id v14 = [v13 objectForKeyedSubscript:CKPartialErrorsByItemIDKey];

      if ([*(id *)(v1 + 56) intransactionIsErrorBadEtagOnKeyPointersOnly:*(void *)(v1 + 32)])
      {
        uint64_t v15 = [*(id *)(v1 + 40) zoneID];
        id v16 = [v15 zoneName];
        id v17 = sub_1000CD884(@"ckksoutgoing", v16);

        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          id v18 = "Error is simply due to current key pointers changing; marking all records as 'needs reencrypt'";
LABEL_84:
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v18, buf, 2u);
          goto LABEL_85;
        }
        goto LABEL_85;
      }
      if ([*(id *)(v1 + 56) _onqueueIsErrorMissingSyncKey:*(void *)(v1 + 32)])
      {
        CFBooleanRef v152 = [*(id *)(v1 + 40) zoneID];
        CFDictionaryRef v153 = [v152 zoneName];
        id v17 = sub_1000CD884(@"ckksoutgoing", v153);

        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          id v18 = "Error is due to the key records missing. Marking all as 'needs reencrypt'";
          goto LABEL_84;
        }
LABEL_85:

        CFStringRef v154 = *(void **)(v1 + 56);
        CFStringRef v155 = [v14 allKeys];
        [v154 _onqueueModifyAllRecords:v155 as:@"reencrypt" viewState:*(void *)(v1 + 40)];

        goto LABEL_86;
      }
      long long v227 = 0u;
      long long v228 = 0u;
      long long v225 = 0u;
      long long v226 = 0u;
      id v149 = v14;
      id v200 = [v149 countByEnumeratingWithState:&v225 objects:v237 count:16];
      if (!v200) {
        goto LABEL_87;
      }
      id objb = v14;
      char v193 = 0;
      uint64_t v197 = *(void *)v226;
LABEL_92:
      uint64_t v158 = 0;
      while (1)
      {
        if (*(void *)v226 != v197) {
          objc_enumerationMutation(v149);
        }
        v159 = *(void **)(*((void *)&v225 + 1) + 8 * v158);
        v160 = [v149 objectForKeyedSubscript:v159];
        uint64_t v161 = [*(id *)(v1 + 40) zoneID];
        CFDataRef v162 = [v161 zoneName];
        CFDataRef v163 = sub_1000CD884(@"ckksoutgoing", v162);

        if (os_log_type_enabled(v163, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412546;
          *(void *)v235 = v159;
          *(_WORD *)&v235[8] = 2112;
          id v236 = v160;
          _os_log_impl((void *)&_mh_execute_header, v163, OS_LOG_TYPE_DEFAULT, "failed record: %@ %@", buf, 0x16u);
        }

        v164 = [v160 domain];
        if (![v164 isEqualToString:CKErrorDomain]) {
          break;
        }
        id v165 = [v160 code];

        if (v165 != (id)14) {
          goto LABEL_102;
        }
        BOOL v166 = [v159 recordName];
        if ([v166 isEqualToString:@"classA"])
        {
        }
        else
        {
          CFTypeRef v184 = [v159 recordName];
          unsigned __int8 v185 = [v184 isEqualToString:@"classC"];

          if ((v185 & 1) == 0) {
            goto LABEL_114;
          }
        }
        char v193 = 1;
LABEL_118:

        if (v200 == (id)++v158)
        {
          id v200 = [v149 countByEnumeratingWithState:&v225 objects:v237 count:16];
          if (!v200)
          {

            id v14 = objb;
            if ((v193 & 1) == 0) {
              goto LABEL_88;
            }
LABEL_86:
            id v149 = [*(id *)(v1 + 56) deps];
            uint64_t v156 = [v149 flagHandler];
            [v156 _onqueueHandleFlag:@"item_reencryption_needed"];

LABEL_87:
            id v149 = v14;
            goto LABEL_88;
          }
          goto LABEL_92;
        }
      }

LABEL_102:
      v167 = [v160 domain];
      if ([v167 isEqualToString:CKErrorDomain])
      {
        id v168 = [v160 code];

        if (v168 == (id)22)
        {
          if ([*(id *)(v1 + 72) containsObject:v159])
          {
            unsigned int v169 = [v159 recordName];
            v170 = [*(id *)(v1 + 56) deps];
            v171 = [v170 contextID];
            CFDictionaryRef v172 = [v159 zoneID];
            id v224 = 0;
            CFStringRef v173 = +[CKKSOutgoingQueueEntry tryFromDatabase:v169 state:@"inflight" contextID:v171 zoneID:v172 error:&v224];
            id v174 = v224;

            uint64_t v1 = a1;
            CFStringRef v175 = v173;
            uint64_t v176 = *(void *)(a1 + 40);
            id v223 = v174;
            [v173 intransactionMoveToState:@"new" viewState:v176 error:&v223];
            id v177 = v223;

            if (v177)
            {
              v178 = [*(id *)(a1 + 40) zoneID];
              v179 = [v178 zoneName];
              v180 = sub_1000CD884(@"ckksoutgoing", v179);

              if (os_log_type_enabled(v180, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)long long buf = 138412290;
                *(void *)v235 = v177;
                _os_log_impl((void *)&_mh_execute_header, v180, OS_LOG_TYPE_ERROR, "Couldn't clean up outgoing queue entry: %@", buf, 0xCu);
              }

              uint64_t v1 = a1;
            }
          }
          goto LABEL_118;
        }
      }
      else
      {
      }
      v181 = [*(id *)(v1 + 40) zoneID];
      CFStringRef v182 = [v181 zoneName];
      CFStringRef v183 = sub_1000CD884(@"ckksoutgoing", v182);

      if (os_log_type_enabled(v183, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412546;
        *(void *)v235 = v159;
        *(_WORD *)&v235[8] = 2112;
        id v236 = v160;
        _os_log_impl((void *)&_mh_execute_header, v183, OS_LOG_TYPE_ERROR, "Unknown error on row: %@ %@", buf, 0x16u);
      }

      uint64_t v1 = a1;
LABEL_114:
      if ([*(id *)(v1 + 72) containsObject:v159]) {
        [*(id *)(v1 + 56) _onqueueModifyRecordAsError:v159 recordError:v160 viewState:*(void *)(v1 + 40)];
      }
      goto LABEL_118;
    }
  }
  else
  {
  }
  unsigned int v143 = [*(id *)(v1 + 32) isCKInternalServerHTTPError];
  CFStringRef v144 = [*(id *)(v1 + 40) zoneID];
  int v145 = [v144 zoneName];
  CFStringRef v146 = sub_1000CD884(@"ckks", v145);

  BOOL v147 = os_log_type_enabled(v146, OS_LOG_TYPE_DEFAULT);
  if (v143)
  {
    if (v147)
    {
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)v235 = 1800;
      _os_log_impl((void *)&_mh_execute_header, v146, OS_LOG_TYPE_DEFAULT, "CloudKit is presumably down; scheduling upload after %d seconds",
        buf,
        8u);
    }

    int v148 = *(void **)(v1 + 56);
    id v149 = [*(id *)(v1 + 72) allObjects];
    [v148 _onqueueSaveRecordsWithDelay:v149 viewState:*(void *)(v1 + 40)];
  }
  else
  {
    if (v147)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v146, OS_LOG_TYPE_DEFAULT, "Error is scary: putting all inflight OQEs back into state 'new'", buf, 2u);
    }

    CFDataRef v150 = *(void **)(v1 + 56);
    id v149 = [*(id *)(v1 + 72) allObjects];
    [v150 _onqueueModifyAllRecords:v149 as:@"new" viewState:*(void *)(v1 + 40)];
  }
LABEL_88:

  [*(id *)(v1 + 56) setError:*(void *)(v1 + 32)];
  return 1;
}

void sub_10007E388(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,id location)
{
}

uint64_t sub_10007E3CC(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = [*(id *)(a1 + 40) deps];
  id v3 = [v2 contextID];
  id v276 = 0;
  id v213 = +[CKKSOutgoingQueueOperation ontransactionFetchEntries:v1 contextID:v3 error:&v276];
  id v4 = v276;

  if (!v213 || v4)
  {
    uint64_t v23 = [*(id *)(a1 + 32) zoneID];
    uint64_t v24 = [v23 zoneName];
    id v25 = sub_1000CD884(@"ckksoutgoing", v24);

    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v4;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "Error fetching outgoing queue records: %@", buf, 0xCu);
    }

    [*(id *)(a1 + 40) setError:v4];
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:*(void *)(a1 + 48) success:0 error:v4];
    uint64_t v22 = 0;
    goto LABEL_129;
  }
  id v212 = [v213 count];
  uint64_t v5 = *(void **)(a1 + 48);
  v289[0] = kSecurityRTCFieldNumKeychainItems;
  BOOL v6 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [v213 count]);
  v290[0] = v6;
  uint64_t v211 = kSecurityRTCFieldIsFullUpload;
  v289[1] = kSecurityRTCFieldIsFullUpload;
  uint64_t v7 = +[NSNumber numberWithBool:(unint64_t)v212 > 0x63];
  v290[1] = v7;
  uint64_t v8 = +[NSDictionary dictionaryWithObjects:v290 forKeys:v289 count:2];
  [v5 addMetrics:v8];

  CFStringRef v9 = [*(id *)(a1 + 32) zoneID];
  uint64_t v10 = [v9 zoneName];
  +[CKKSPowerCollection CKKSPowerEvent:zone:count:](CKKSPowerCollection, "CKKSPowerEvent:zone:count:", @"processOutgoingQueue", v10, [v213 count]);

  os_log_type_t v11 = [*(id *)(a1 + 32) zoneID];
  id v12 = [v11 zoneName];
  uint64_t v13 = sub_1000CD884(@"ckksoutgoing", v12);

  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = v213;
    _os_log_debug_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "processing outgoing queue: %@", buf, 0xCu);
  }

  id v232 = objc_alloc_init((Class)NSMutableDictionary);
  id v224 = objc_alloc_init((Class)NSMutableSet);
  id v223 = objc_alloc_init((Class)NSMutableSet);
  id v217 = objc_alloc_init((Class)NSMutableArray);
  id v14 = [*(id *)(a1 + 32) contextID];
  uint64_t v15 = [*(id *)(a1 + 32) zoneID];
  id v275 = 0;
  long long v225 = +[CKKSCurrentKeyPointer fromDatabase:@"classA" contextID:v14 zoneID:v15 error:&v275];
  id v16 = v275;

  id v17 = [*(id *)(a1 + 32) contextID];
  id v18 = [*(id *)(a1 + 32) zoneID];
  id v274 = v16;
  long long v222 = +[CKKSCurrentKeyPointer fromDatabase:@"classC" contextID:v17 zoneID:v18 error:&v274];
  id v4 = v274;

  id v221 = objc_alloc_init((Class)NSMutableDictionary);
  if (v4)
  {
    id v19 = [*(id *)(a1 + 32) zoneID];
    id v20 = [v19 zoneName];
    id v21 = sub_1000CD884(@"ckksoutgoing", v20);

    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v4;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "Couldn't load current class keys: %@", buf, 0xCu);
    }

    [*(id *)(a1 + 40) setError:v4];
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:*(void *)(a1 + 48) success:0 error:v4];
    uint64_t v22 = 0;
    goto LABEL_128;
  }
  long long v272 = 0u;
  long long v273 = 0u;
  long long v270 = 0u;
  long long v271 = 0u;
  id obj = v213;
  id v230 = [obj countByEnumeratingWithState:&v270 objects:v288 count:16];
  if (!v230)
  {
    id v4 = 0;
    uint64_t v122 = 0;
    goto LABEL_72;
  }
  char v214 = 0;
  id v4 = 0;
  uint64_t v228 = *(void *)v271;
  do
  {
    for (uint64_t i = 0; i != v230; uint64_t i = (char *)i + 1)
    {
      if (*(void *)v271 != v228) {
        objc_enumerationMutation(obj);
      }
      uint64_t v27 = *(void **)(*((void *)&v270 + 1) + 8 * i);
      uint64_t v28 = [v27 uuid];
      uint64_t v29 = [*(id *)(a1 + 40) deps];
      uint64_t v30 = [v29 contextID];
      long long v31 = [*(id *)(a1 + 32) zoneID];
      id v269 = v4;
      unsigned int v32 = +[CKKSOutgoingQueueEntry tryFromDatabase:v28 state:@"inflight" contextID:v30 zoneID:v31 error:&v269];
      id v33 = v269;

      if (!v33 && v32)
      {
        id v4 = 0;
        goto LABEL_65;
      }
      id v34 = [v27 action];
      unsigned __int8 v35 = [v34 isEqualToString:@"delete"];

      if ((v35 & 1) == 0)
      {
        long long v36 = [v27 item];
        long long v37 = [v36 parentKeyUUID];
        id v38 = [v225 currentKeyUUID];
        unsigned int v39 = [v37 isEqualToString:v38];

        if (v39)
        {
          [v221 setObject:v225 forKeyedSubscript:@"classA"];
        }
        else
        {
          uint64_t v40 = [v27 item];
          uint64_t v41 = [v40 parentKeyUUID];
          uint64_t v42 = [v222 currentKeyUUID];
          unsigned int v43 = [v41 isEqualToString:v42];

          if (!v43)
          {
            uint64_t v89 = [*(id *)(a1 + 32) zoneID];
            uint64_t v90 = [v89 zoneName];
            size_t v91 = sub_1000CD884(@"ckksoutgoing", v90);

            if (os_log_type_enabled(v91, OS_LOG_TYPE_DEFAULT))
            {
              id v92 = [v27 item];
              uint64_t v93 = [v92 parentKeyUUID];
              *(_DWORD *)long long buf = 138413058;
              *(void *)&uint8_t buf[4] = v27;
              *(_WORD *)&buf[12] = 2112;
              *(void *)&buf[14] = v93;
              *(_WORD *)&buf[22] = 2112;
              v285 = v225;
              __int16 v286 = 2112;
              v287 = v222;
              _os_log_impl((void *)&_mh_execute_header, v91, OS_LOG_TYPE_DEFAULT, "Item's encryption key (%@ %@) is neither %@ or %@", buf, 0x2Au);
            }
            uint64_t v94 = *(void *)(a1 + 32);
            id v268 = v33;
            [v27 intransactionMoveToState:@"reencrypt" viewState:v94 error:&v268];
            id v48 = v268;

            if (!v48)
            {
              id v4 = 0;
              char v214 = 1;
              goto LABEL_65;
            }
            v95 = [*(id *)(a1 + 32) zoneID];
            BOOL v96 = [v95 zoneName];
            uint64_t v97 = sub_1000CD884(@"ckksoutgoing", v96);

            if (os_log_type_enabled(v97, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 138412290;
              *(void *)&uint8_t buf[4] = v48;
              _os_log_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_ERROR, "couldn't save oqe to database: %@", buf, 0xCu);
            }

            [*(id *)(a1 + 40) setError:v48];
            goto LABEL_48;
          }
          [v221 setObject:v222 forKeyedSubscript:@"classC"];
        }
      }
      id v44 = [v27 action];
      unsigned int v45 = [v44 isEqualToString:@"add"];

      if (v45)
      {
        uint64_t v46 = [v27 item];
        uint64_t v47 = [*(id *)(a1 + 32) zoneID];
        id v48 = [v46 CKRecordWithZoneID:v47];

        unsigned int v49 = [v48 recordID];
        [v232 setObject:v48 forKeyedSubscript:v49];

        uint64_t v50 = [v48 recordID];
        [v224 addObject:v50];

        [v223 addObject:v27];
        uint64_t v51 = *(void *)(a1 + 32);
        id v267 = v33;
        [v27 intransactionMoveToState:@"inflight" viewState:v51 error:&v267];
        id v4 = v267;

        if (v4)
        {
          CFStringRef v52 = [*(id *)(a1 + 32) zoneID];
          uint64_t v53 = [v52 zoneName];
          uint64_t v54 = sub_1000CD884(@"ckksoutgoing", v53);

          if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138412290;
            *(void *)&uint8_t buf[4] = v4;
            _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, "couldn't save state for CKKSOutgoingQueueEntry: %@", buf, 0xCu);
          }

          [*(id *)(a1 + 40) setError:v4];
        }
        goto LABEL_64;
      }
      uint64_t v55 = [v27 action];
      unsigned int v56 = [v55 isEqualToString:@"delete"];

      if (v56)
      {
        id v57 = objc_alloc((Class)CKRecordID);
        uint64_t v58 = [v27 item];
        id v59 = [v58 uuid];
        id v60 = [*(id *)(a1 + 32) zoneID];
        id v48 = [v57 initWithRecordName:v59 zoneID:v60];

        [v217 addObject:v48];
        [v224 addObject:v48];
        [v223 addObject:v27];
        uint64_t v61 = *(void *)(a1 + 32);
        id v266 = v33;
        [v27 intransactionMoveToState:@"inflight" viewState:v61 error:&v266];
        id v4 = v266;

        if (v4)
        {
          id v62 = [*(id *)(a1 + 32) zoneID];
          uint64_t v63 = [v62 zoneName];
          uint64_t v64 = sub_1000CD884(@"ckksoutgoing", v63);

          if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138412290;
            *(void *)&uint8_t buf[4] = v4;
            _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_ERROR, "couldn't save state for CKKSOutgoingQueueEntry: %@", buf, 0xCu);
          }
        }
        goto LABEL_64;
      }
      uint64_t v65 = [v27 action];
      unsigned int v66 = [v65 isEqualToString:@"modify"];

      if (!v66)
      {
        id v4 = v33;
        goto LABEL_65;
      }
      CFDataRef v67 = [v27 item];
      unsigned int v68 = [v67 uuid];
      long long v69 = [*(id *)(a1 + 40) deps];
      long long v70 = [v69 contextID];
      CFTypeRef v71 = [*(id *)(a1 + 32) zoneID];
      id v265 = v33;
      id v48 = +[CKKSMirrorEntry tryFromDatabase:v68 contextID:v70 zoneID:v71 error:&v265];
      id v219 = v265;

      if (!v48)
      {
        id v98 = [*(id *)(a1 + 32) zoneID];
        uint64_t v99 = [v98 zoneName];
        BOOL v100 = sub_1000CD884(@"ckksoutgoing", v99);

        if (os_log_type_enabled(v100, OS_LOG_TYPE_ERROR))
        {
          unsigned int v101 = [v27 item];
          id v102 = [v101 uuid];
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = v102;
          _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_ERROR, "update to a record that doesn't exist? %@", buf, 0xCu);
        }
        id v103 = [v27 item];
        v104 = [*(id *)(a1 + 32) zoneID];
        id v82 = [v103 CKRecordWithZoneID:v104];

        CFDataRef v105 = [v82 recordID];
        [v232 setObject:v82 forKeyedSubscript:v105];

        CFStringRef v106 = [v82 recordID];
        [v224 addObject:v106];

        [v223 addObject:v27];
        uint64_t v107 = *(void *)(a1 + 32);
        id v264 = v219;
        [v27 intransactionMoveToState:@"inflight" viewState:v107 error:&v264];
        id v4 = v264;

        if (v4)
        {
          uint64_t v108 = [*(id *)(a1 + 32) zoneID];
          id v109 = [v108 zoneName];
          id v110 = sub_1000CD884(@"ckksoutgoing", v109);

          if (os_log_type_enabled(v110, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138412290;
            *(void *)&uint8_t buf[4] = v4;
            _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_ERROR, "couldn't save state for CKKSOutgoingQueueEntry: %@", buf, 0xCu);
          }

          [*(id *)(a1 + 40) setError:v4];
        }
        goto LABEL_63;
      }
      long long v215 = [v27 item];
      long long v72 = [v215 storedCKRecord];
      id v73 = [v72 recordChangeTag];
      long long v74 = [v48 item];
      id v75 = [v74 storedCKRecord];
      id v76 = [v75 recordChangeTag];
      unsigned __int8 v77 = [v73 isEqual:v76];

      if (v77)
      {
        id v78 = [v27 item];
        id v79 = [v48 item];
        long long v80 = [v79 storedCKRecord];
        id v81 = [*(id *)(a1 + 32) zoneID];
        id v82 = [v78 updateCKRecord:v80 zoneID:v81];

        CFTypeRef v83 = [v82 recordID];
        [v232 setObject:v82 forKeyedSubscript:v83];

        __int16 v84 = [v82 recordID];
        [v224 addObject:v84];

        [v223 addObject:v27];
        uint64_t v85 = *(void *)(a1 + 32);
        id v262 = v219;
        [v27 intransactionMoveToState:@"inflight" viewState:v85 error:&v262];
        id v4 = v262;

        if (v4)
        {
          __int16 v86 = [*(id *)(a1 + 32) zoneID];
          CFStringRef v87 = [v86 zoneName];
          __int16 v88 = sub_1000CD884(@"ckksoutgoing", v87);

          if (os_log_type_enabled(v88, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138412290;
            *(void *)&uint8_t buf[4] = v4;
            _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_ERROR, "couldn't save state for CKKSOutgoingQueueEntry: %@", buf, 0xCu);
          }
        }
LABEL_63:

        goto LABEL_64;
      }
      id v111 = [*(id *)(a1 + 32) zoneID];
      uint64_t v112 = [v111 zoneName];
      id v113 = sub_1000CD884(@"ckksoutgoing", v112);

      if (os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v27;
        _os_log_impl((void *)&_mh_execute_header, v113, OS_LOG_TYPE_DEFAULT, "Record (%@)'s change tag doesn't match ckmirror's change tag, reencrypting", buf, 0xCu);
      }

      uint64_t v114 = *(void *)(a1 + 32);
      id v263 = v219;
      [v27 intransactionMoveToState:@"reencrypt" viewState:v114 error:&v263];
      id v82 = v263;

      if (v82)
      {
        long long v115 = [*(id *)(a1 + 32) zoneID];
        long long v116 = [v115 zoneName];
        long long v117 = sub_1000CD884(@"ckksoutgoing", v116);

        if (os_log_type_enabled(v117, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = v82;
          _os_log_impl((void *)&_mh_execute_header, v117, OS_LOG_TYPE_ERROR, "couldn't save oqe to database: %@", buf, 0xCu);
        }

        [*(id *)(a1 + 40) setError:v82];
        id v4 = 0;
        char v214 = 1;
        goto LABEL_63;
      }
LABEL_48:
      id v4 = 0;
      char v214 = 1;
LABEL_64:

LABEL_65:
    }
    id v230 = [obj countByEnumeratingWithState:&v270 objects:v288 count:16];
  }
  while (v230);

  if (v214)
  {
    id v118 = [*(id *)(a1 + 32) zoneID];
    long long v119 = [v118 zoneName];
    long long v120 = sub_1000CD884(@"ckksoutgoing", v119);

    if (os_log_type_enabled(v120, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_DEFAULT, "An item needs reencryption!", buf, 2u);
    }

    id obj = [*(id *)(a1 + 40) deps];
    long long v121 = [obj flagHandler];
    [v121 _onqueueHandleFlag:@"item_reencryption_needed"];

    uint64_t v122 = 1;
LABEL_72:
  }
  else
  {
    uint64_t v122 = 0;
  }
  if ([v232 count] || objc_msgSend(v217, "count"))
  {
    [*(id *)(a1 + 40) setItemsProcessed:[v232 count]];
    long long v123 = [*(id *)(a1 + 32) zoneID];
    id v124 = [v123 zoneName];
    id v125 = sub_1000CD884(@"ckksoutgoing", v124);

    if (os_log_type_enabled(v125, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v221;
      _os_log_debug_impl((void *)&_mh_execute_header, v125, OS_LOG_TYPE_DEBUG, "Current keys to update: %@", buf, 0xCu);
    }

    long long v260 = 0u;
    long long v261 = 0u;
    long long v258 = 0u;
    long long v259 = 0u;
    id v126 = [v221 allValues];
    id v127 = [v126 countByEnumeratingWithState:&v258 objects:v281 count:16];
    if (v127)
    {
      uint64_t v128 = *(void *)v259;
      do
      {
        for (j = 0; j != v127; j = (char *)j + 1)
        {
          if (*(void *)v259 != v128) {
            objc_enumerationMutation(v126);
          }
          char v130 = *(void **)(*((void *)&v258 + 1) + 8 * (void)j);
          uint64_t v131 = [*(id *)(a1 + 32) zoneID];
          uint64_t v132 = [v130 CKRecordWithZoneID:v131];

          v133 = [v132 recordID];
          [v232 setObject:v132 forKeyedSubscript:v133];
        }
        id v127 = [v126 countByEnumeratingWithState:&v258 objects:v281 count:16];
      }
      while (v127);
    }

    uint64_t v134 = *(void *)(a1 + 32);
    v135 = [*(id *)(a1 + 40) deps];
    size_t v136 = [v135 accountStateTracker];
    v137 = [*(id *)(a1 + 40) deps];
    BOOL v138 = [v137 lockStateTracker];
    id v257 = 0;
    long long v220 = +[CKKSDeviceStateEntry intransactionCreateDeviceStateForView:v134 accountTracker:v136 lockStateTracker:v138 error:&v257];
    id obja = v257;

    unsigned int v139 = [*(id *)(a1 + 32) zoneID];
    long long v218 = [v220 CKRecordWithZoneID:v139];

    if (obja)
    {
      CFArrayRef v140 = [*(id *)(a1 + 32) zoneID];
      CFStringRef v141 = [v140 zoneName];
      uint64_t v142 = sub_1000CD884(@"ckksoutgoing", v141);

      if (os_log_type_enabled(v142, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = obja;
        unsigned int v143 = "Can't make current device state: %@";
        CFStringRef v144 = v142;
        uint32_t v145 = 12;
        goto LABEL_88;
      }
    }
    else
    {
      CFStringRef v146 = [*(id *)(a1 + 32) zoneID];
      BOOL v147 = [v146 zoneName];
      uint64_t v142 = sub_1000CD884(@"ckksoutgoing", v147);

      if (v218)
      {
        if (os_log_type_enabled(v142, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = v220;
          _os_log_impl((void *)&_mh_execute_header, v142, OS_LOG_TYPE_DEFAULT, "Updating device state: %@", buf, 0xCu);
        }

        uint64_t v142 = [v218 recordID];
        [v232 setObject:v218 forKeyedSubscript:v142];
      }
      else if (os_log_type_enabled(v142, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)long long buf = 0;
        unsigned int v143 = "Can't make current device state cloudkit record, but no reason why";
        CFStringRef v144 = v142;
        uint32_t v145 = 2;
LABEL_88:
        _os_log_impl((void *)&_mh_execute_header, v144, OS_LOG_TYPE_ERROR, v143, buf, v145);
      }
    }

    v160 = [*(id *)(a1 + 32) zoneID];
    uint64_t v161 = [v160 zoneName];
    CFDataRef v162 = sub_1000CD884(@"ckksoutgoing", v161);

    if (os_log_type_enabled(v162, OS_LOG_TYPE_DEBUG))
    {
      long long v208 = [*(id *)(a1 + 32) zoneID];
      *(_DWORD *)long long buf = 138412546;
      *(void *)&uint8_t buf[4] = v232;
      *(_WORD *)&buf[12] = 2112;
      *(void *)&buf[14] = v208;
      _os_log_debug_impl((void *)&_mh_execute_header, v162, OS_LOG_TYPE_DEBUG, "Saving records %@ to CloudKit zone %@", buf, 0x16u);
    }
    id v163 = objc_alloc((Class)AAFAnalyticsEventSecurity);
    v279[0] = kSecurityRTCFieldNeedsReencryption;
    v164 = +[NSNumber numberWithBool:v122];
    v280[0] = v164;
    v279[1] = v211;
    id v165 = +[NSNumber numberWithBool:(unint64_t)v212 > 0x63];
    v280[1] = v165;
    BOOL v166 = +[NSDictionary dictionaryWithObjects:v280 forKeys:v279 count:2];
    v167 = [*(id *)(a1 + 40) deps];
    id v168 = [v167 activeAccount];
    unsigned int v169 = [v168 altDSID];
    v170 = [*(id *)(a1 + 40) deps];
    id v171 = [v170 sendMetric];
    id v216 = [v163 initWithCKKSMetrics:v166 altDSID:v169 eventName:kSecurityRTCEventNameUploadOQEsToCK testsAreEnabled:0 category:kSecurityRTCEventCategoryAccountDataAccessRecovery sendMetric:v171];

    id v229 = objc_alloc_init((Class)NSBlockOperation);
    [v229 setName:@"modifyRecordsComplete"];
    [*(id *)(a1 + 40) dependOnBeforeGroupFinished:v229];
    id v172 = objc_alloc((Class)CKModifyRecordsOperation);
    CFStringRef v173 = [v232 allValues];
    id v231 = [v172 initWithRecordsToSave:v173 recordIDsToDelete:v217];

    [v231 setAtomic:1];
    [v231 linearDependencies:*(void *)(a1 + 56)];
    id v174 = [v231 configuration];
    [v174 setIsCloudKitSupportOperation:1];

    [v231 setSavePolicy:0];
    CFStringRef v175 = [*(id *)(a1 + 40) deps];
    uint64_t v176 = [v175 currentOutgoingQueueOperationGroup];
    [v231 setGroup:v176];

    id v177 = [*(id *)(a1 + 32) zoneID];
    v178 = [v177 zoneName];
    v179 = sub_1000CD884(@"ckksoutgoing", v178);

    if (os_log_type_enabled(v179, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v180 = [v231 qualityOfService];
      v181 = [v231 group];
      *(_DWORD *)long long buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v180;
      *(_WORD *)&uint8_t buf[8] = 2112;
      *(void *)&buf[10] = v181;
      _os_log_impl((void *)&_mh_execute_header, v179, OS_LOG_TYPE_DEFAULT, "QoS: %d; operation group is %@", buf, 0x12u);
    }
    CFStringRef v182 = [*(id *)(a1 + 32) zoneID];
    CFStringRef v183 = [v182 zoneName];
    CFTypeRef v184 = sub_1000CD884(@"ckksoutgoing", v183);

    if (os_log_type_enabled(v184, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v185 = [v232 count];
      unsigned int v186 = [v217 count];
      *(_DWORD *)long long buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v185;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v186;
      _os_log_impl((void *)&_mh_execute_header, v184, OS_LOG_TYPE_DEFAULT, "Beginning upload for %d records, deleting %d records", buf, 0xEu);
    }

    long long v255 = 0u;
    long long v256 = 0u;
    long long v253 = 0u;
    long long v254 = 0u;
    CFDataRef v187 = [v232 allKeys];
    id v188 = [v187 countByEnumeratingWithState:&v253 objects:v278 count:16];
    if (v188)
    {
      uint64_t v189 = *(void *)v254;
      do
      {
        for (k = 0; k != v188; k = (char *)k + 1)
        {
          if (*(void *)v254 != v189) {
            objc_enumerationMutation(v187);
          }
          id v191 = *(void **)(*((void *)&v253 + 1) + 8 * (void)k);
          uint64_t v192 = [v191 zoneID];
          char v193 = [v192 zoneName];
          v194 = sub_1000CD884(@"ckksoutgoing", v193);

          if (os_log_type_enabled(v194, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 138412290;
            *(void *)&uint8_t buf[4] = v191;
            _os_log_debug_impl((void *)&_mh_execute_header, v194, OS_LOG_TYPE_DEBUG, "Record to save: %@", buf, 0xCu);
          }
        }
        id v188 = [v187 countByEnumeratingWithState:&v253 objects:v278 count:16];
      }
      while (v188);
    }

    long long v251 = 0u;
    long long v252 = 0u;
    long long v249 = 0u;
    long long v250 = 0u;
    id v195 = v217;
    id v196 = [v195 countByEnumeratingWithState:&v249 objects:v277 count:16];
    if (v196)
    {
      uint64_t v197 = *(void *)v250;
      do
      {
        for (m = 0; m != v196; m = (char *)m + 1)
        {
          if (*(void *)v250 != v197) {
            objc_enumerationMutation(v195);
          }
          v199 = *(void **)(*((void *)&v249 + 1) + 8 * (void)m);
          id v200 = [v199 zoneID];
          v201 = [v200 zoneName];
          id v202 = sub_1000CD884(@"ckksoutgoing", v201);

          if (os_log_type_enabled(v202, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 138412290;
            *(void *)&uint8_t buf[4] = v199;
            _os_log_debug_impl((void *)&_mh_execute_header, v202, OS_LOG_TYPE_DEBUG, "Record to delete: %@", buf, 0xCu);
          }
        }
        id v196 = [v195 countByEnumeratingWithState:&v249 objects:v277 count:16];
      }
      while (v196);
    }

    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&uint8_t buf[16] = 0x2020000000;
    LODWORD(v285) = 0;
    v247[0] = 0;
    v247[1] = v247;
    v247[2] = 0x2020000000;
    int v248 = 0;
    v246[0] = _NSConcreteStackBlock;
    v246[1] = 3221225472;
    v246[2] = sub_100080684;
    v246[3] = &unk_1002F87F0;
    v246[4] = buf;
    v246[5] = v247;
    [v231 setPerRecordSaveBlock:v246];
    v235[0] = _NSConcreteStackBlock;
    v235[1] = 3221225472;
    v235[2] = sub_100080888;
    v235[3] = &unk_1002F8818;
    objc_copyWeak(&v244, (id *)(a1 + 64));
    v235[4] = *(void *)(a1 + 32);
    BOOL v245 = (unint64_t)v212 > 0x63;
    id v236 = v232;
    id v237 = v195;
    id v238 = v224;
    id v203 = v229;
    id v239 = v203;
    id v204 = v216;
    id v240 = v204;
    id v241 = *(id *)(a1 + 48);
    v242 = v247;
    v243 = buf;
    [v231 setModifyRecordsCompletionBlock:v235];
    [*(id *)(a1 + 40) dependOnBeforeGroupFinished:v231];
    id v205 = [*(id *)(a1 + 40) deps];
    long long v206 = [v205 ckdatabase];
    [v206 addOperation:v231];

    objc_destroyWeak(&v244);
    _Block_object_dispose(v247, 8);
    _Block_object_dispose(buf, 8);
  }
  else
  {
    int v148 = [*(id *)(a1 + 32) zoneID];
    id v149 = [v148 zoneName];
    CFDataRef v150 = sub_1000CD884(@"ckksoutgoing", v149);

    if (os_log_type_enabled(v150, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)long long buf = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEBUG, "Nothing in outgoing queue to process", buf, 2u);
    }

    CFDictionaryRef v151 = [*(id *)(a1 + 40) deps];
    CFBooleanRef v152 = [v151 currentOutgoingQueueOperationGroup];

    if (v152)
    {
      CFDictionaryRef v153 = [*(id *)(a1 + 32) zoneID];
      CFStringRef v154 = [v153 zoneName];
      CFStringRef v155 = sub_1000CD884(@"ckksoutgoing", v154);

      if (os_log_type_enabled(v155, OS_LOG_TYPE_DEBUG))
      {
        long long v209 = [*(id *)(a1 + 40) deps];
        id v210 = [v209 currentOutgoingQueueOperationGroup];
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v210;
        _os_log_debug_impl((void *)&_mh_execute_header, v155, OS_LOG_TYPE_DEBUG, "End of operation group: %@", buf, 0xCu);
      }
      uint64_t v156 = [*(id *)(a1 + 40) deps];
      [v156 setCurrentOutgoingQueueOperationGroup:0];
    }
    uint64_t v157 = *(void **)(a1 + 48);
    v282[0] = kSecurityRTCFieldItemsToAdd;
    v282[1] = kSecurityRTCFieldItemsToDelete;
    v283[0] = &off_100325B70;
    v283[1] = &off_100325B70;
    v282[2] = kSecurityRTCFieldItemsToModify;
    v282[3] = kSecurityRTCFieldErrorItemsProcessed;
    v283[2] = &off_100325B70;
    v283[3] = &off_100325B70;
    v282[4] = kSecurityRTCFieldSuccessfulItemsProcessed;
    v283[4] = &off_100325B70;
    uint64_t v158 = +[NSDictionary dictionaryWithObjects:v283 forKeys:v282 count:5];
    [v157 addMetrics:v158];

    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:*(void *)(a1 + 48) success:1 error:0];
    v159 = [*(id *)(a1 + 40) intendedState];
    [*(id *)(a1 + 40) setNextState:v159];
  }
  uint64_t v22 = 1;
LABEL_128:

LABEL_129:
  return v22;
}

void sub_100080638(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55)
{
  objc_destroyWeak(v55);
  _Block_object_dispose(&a55, 8);
  _Block_object_dispose(&STACK[0x4F0], 8);
  _Unwind_Resume(a1);
}

void sub_100080684(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (v9)
  {
    ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    uint64_t v10 = [v7 zoneID];
    os_log_type_t v11 = [v10 zoneName];
    id v12 = sub_1000CD884(@"ckksoutgoing", v11);

    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      int v17 = 138412546;
      id v18 = v9;
      __int16 v19 = 2112;
      id v20 = v7;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "error on row: %@ %@", (uint8_t *)&v17, 0x16u);
    }
  }
  else
  {
    ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    uint64_t v13 = [v7 zoneID];
    id v14 = [v13 zoneName];
    id v12 = sub_1000CD884(@"ckksoutgoing", v14);

    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = [v7 recordName];
      id v16 = [v8 recordChangeTag];
      int v17 = 138412546;
      id v18 = v15;
      __int16 v19 = 2112;
      id v20 = v16;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Record upload successful for %@ (%@)", (uint8_t *)&v17, 0x16u);
    }
  }
}

void sub_100080888(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = (id *)(a1 + 104);
  id v25 = a4;
  id v8 = a3;
  id v9 = a2;
  id WeakRetained = objc_loadWeakRetained(v7);
  [WeakRetained modifyRecordsCompleted:*(void *)(a1 + 32) fullUpload:*(unsigned __int8 *)(a1 + 112) recordsToSave:*(void *)(a1 + 40) recordIDsToDelete:*(void *)(a1 + 48) recordIDsModified:*(void *)(a1 + 56) modifyComplete:*(void *)(a1 + 64) savedRecords:v9 deletedRecordIDs:v8 ckerror:v25];

  uint64_t v10 = *(void **)(a1 + 72);
  uint64_t v11 = kSecurityRTCFieldItemsToAdd;
  v29[0] = kSecurityRTCFieldItemsToAdd;
  id v12 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [*(id *)(a1 + 40) count]);
  v30[0] = v12;
  uint64_t v13 = kSecurityRTCFieldItemsToDelete;
  v29[1] = kSecurityRTCFieldItemsToDelete;
  id v14 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [*(id *)(a1 + 48) count]);
  v30[1] = v14;
  uint64_t v15 = kSecurityRTCFieldItemsToModify;
  v29[2] = kSecurityRTCFieldItemsToModify;
  id v16 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [*(id *)(a1 + 56) count]);
  v30[2] = v16;
  int v17 = +[NSDictionary dictionaryWithObjects:v30 forKeys:v29 count:3];
  [v10 addMetrics:v17];

  +[SecurityAnalyticsReporterRTC sendMetricWithEvent:*(void *)(a1 + 72) success:v25 == 0 error:v25];
  uint64_t v24 = *(void **)(a1 + 80);
  v27[0] = v11;
  id v18 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [*(id *)(a1 + 40) count]);
  v28[0] = v18;
  v27[1] = v13;
  __int16 v19 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [*(id *)(a1 + 48) count]);
  v28[1] = v19;
  v27[2] = v15;
  id v20 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [*(id *)(a1 + 56) count]);
  v28[2] = v20;
  v27[3] = kSecurityRTCFieldErrorItemsProcessed;
  id v21 = +[NSNumber numberWithInt:*(unsigned int *)(*(void *)(*(void *)(a1 + 88) + 8) + 24)];
  v28[3] = v21;
  v27[4] = kSecurityRTCFieldSuccessfulItemsProcessed;
  uint64_t v22 = +[NSNumber numberWithInt:*(unsigned int *)(*(void *)(*(void *)(a1 + 96) + 8) + 24)];
  v28[4] = v22;
  uint64_t v23 = +[NSDictionary dictionaryWithObjects:v28 forKeys:v27 count:5];
  [v24 addMetrics:v23];

  +[SecurityAnalyticsReporterRTC sendMetricWithEvent:*(void *)(a1 + 80) success:v25 == 0 error:v25];
}

void sub_100081520(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100081544(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  int v17 = +[CKKSAnalytics logger];
  [v17 logResultForEvent:@"OctagonEventVoucherWithBottle" hardFailure:1 result:v15];

  if (v15)
  {
    id v18 = sub_10000B070("SecError");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v34 = v15;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "octagon: Error preparing voucher using bottle: %@", buf, 0xCu);
    }

    [WeakRetained setError:v15];
LABEL_16:
    id v23 = [WeakRetained finishedOp];
    [WeakRetained runBeforeGroupFinished:v23];
    goto LABEL_17;
  }
  __int16 v19 = +[CKKSAnalytics logger];
  [v19 recordRecoveredTLKMetrics:*(void *)(a1 + 32) tlkRecoveryResults:v14 uniqueTLKsRecoveredEvent:@"OABottledUniqueTLKsRecoveredCount" totalSharesRecoveredEvent:@"OABottledTotalTLKSharesRecoveredCount" totalRecoverableTLKSharesEvent:@"OABottledTotalTLKSharesCount" totalRecoverableTLKsEvent:@"OABottledUniqueTLKsWithSharesCount" totalViewsWithSharesEvent:@"OABottledTLKUniqueViewCount"];

  [WeakRetained setVoucher:v11];
  [WeakRetained setVoucherSig:v12];
  if (![WeakRetained saveVoucher])
  {
LABEL_13:
    uint64_t v26 = sub_10000B070("octagon");
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412546;
      id v34 = v11;
      __int16 v35 = 2112;
      id v36 = v12;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Successfully vouched with a bottle: %@, %@", buf, 0x16u);
    }

    uint64_t v27 = [WeakRetained intendedState];
    [WeakRetained setNextState:v27];

    goto LABEL_16;
  }
  id v20 = sub_10000B070("octagon");
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Saving voucher for later use...", buf, 2u);
  }

  id v21 = [WeakRetained deps];
  uint64_t v22 = [v21 stateHolder];
  v29[0] = _NSConcreteStackBlock;
  v29[1] = 3221225472;
  v29[2] = sub_10008195C;
  void v29[3] = &unk_1002F9FF0;
  id v30 = v11;
  id v31 = v12;
  id v32 = v13;
  id v28 = 0;
  [v22 persistAccountChanges:v29 error:&v28];
  id v23 = v28;

  if (!v23)
  {

    goto LABEL_13;
  }
  uint64_t v24 = sub_10000B070("octagon");
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    id v34 = v23;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "unable to save voucher: %@", buf, 0xCu);
  }

  id v25 = [WeakRetained finishedOp];
  [WeakRetained runBeforeGroupFinished:v25];

LABEL_17:
}

id sub_10008195C(void *a1, void *a2)
{
  id v3 = a2;
  [v3 setVoucher:a1[4]];
  [v3 setVoucherSignature:a1[5]];
  [v3 setTLKSharesPairedWithVoucher:a1[6]];

  return v3;
}

void sub_100081AD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100081AF4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v8 = WeakRetained;
  if (v6)
  {
    id v9 = sub_10000B070("SecError");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v32 = v6;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "octagon: Error fetching TLKShares to recover: %@", buf, 0xCu);
    }

    [v8 setError:v6];
    uint64_t v10 = [v8 finishedOp];
    [v8 runBeforeGroupFinished:v10];
  }
  else
  {
    id v25 = WeakRetained;
    uint64_t v10 = +[NSMutableArray array];
    long long v26 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    id v24 = v5;
    id v11 = v5;
    id v12 = [v11 countByEnumeratingWithState:&v26 objects:v30 count:16];
    if (v12)
    {
      id v13 = v12;
      uint64_t v14 = *(void *)v27;
      do
      {
        for (uint64_t i = 0; i != v13; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v27 != v14) {
            objc_enumerationMutation(v11);
          }
          id v16 = *(void **)(*((void *)&v26 + 1) + 8 * i);
          int v17 = [v16 recordType];
          unsigned int v18 = [v17 isEqual:@"tlkshare"];

          if (v18)
          {
            __int16 v19 = [CKKSTLKShareRecord alloc];
            id v20 = [v25 deps];
            id v21 = [v20 contextID];
            uint64_t v22 = [(CKKSCKRecordHolder *)v19 initWithCKRecord:v16 contextID:v21];

            id v23 = [(CKKSTLKShareRecord *)v22 share];
            [v10 addObject:v23];
          }
        }
        id v13 = [v11 countByEnumeratingWithState:&v26 objects:v30 count:16];
      }
      while (v13);
    }

    id v8 = v25;
    [v25 proceedWithFilteredTLKShares:v10];
    id v6 = 0;
    id v5 = v24;
  }
}

void sub_10008210C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100082138(uint64_t a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a5;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v13 = +[CKKSAnalytics logger];
  [v13 logResultForEvent:@"OctagonEventPreflightVouchWithBottle" hardFailure:1 result:v11];

  if (!v9 || v11)
  {
    unsigned int v18 = sub_10000B070("SecError");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      int v20 = 138412290;
      id v21 = v11;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "octagon: Error preflighting voucher using bottle: %@", (uint8_t *)&v20, 0xCu);
    }

    [WeakRetained setError:v11];
    __int16 v19 = [WeakRetained finishedOp];
    [WeakRetained runBeforeGroupFinished:v19];
  }
  else
  {
    uint64_t v14 = sub_10000B070("octagon");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      id v15 = [WeakRetained bottleID];
      int v20 = 138412546;
      id v21 = v15;
      __int16 v22 = 2112;
      id v23 = v9;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Bottle %@ is for peerID %@", (uint8_t *)&v20, 0x16u);
    }
    id v16 = [WeakRetained deps];
    int v17 = [v16 ckks];
    [v17 setCurrentSyncingPolicy:v10];

    [WeakRetained proceedWithPeerID:v9 refetchWasNeeded:a4];
  }
}

void sub_100082B44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100082B64(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained proceedAfterFetch];
}

BOOL sub_100085594(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    while (1)
    {
      if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
      }
      char v4 = 0;
      unsigned int v5 = 0;
      unint64_t v6 = 0;
      while (1)
      {
        unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v7 == -1 || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
          break;
        }
        char v8 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
        *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
        v6 |= (unint64_t)(v8 & 0x7F) << v4;
        if ((v8 & 0x80) == 0) {
          goto LABEL_11;
        }
        v4 += 7;
        if (v5++ >= 9)
        {
          unint64_t v6 = 0;
          int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
          goto LABEL_13;
        }
      }
      *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
      int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
      if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        unint64_t v6 = 0;
      }
LABEL_13:
      if (v10 || (v6 & 7) == 4) {
        return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
      }
      if ((v6 >> 3) == 201) {
        break;
      }
      if ((v6 >> 3) == 101)
      {
        uint64_t v12 = PBReaderReadString();
        id v13 = *(SECC2MPGenericEventMetricValue **)(a1 + 8);
        *(void *)(a1 + 8) = v12;
LABEL_23:

        goto LABEL_25;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0) {
        return 0;
      }
LABEL_25:
      if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
      }
    }
    id v13 = objc_alloc_init(SECC2MPGenericEventMetricValue);
    objc_storeStrong((id *)(a1 + 16), v13);
    if (!PBReaderPlaceMark() || (sub_100088D84((uint64_t)v13, a2) & 1) == 0)
    {

      return 0;
    }
    PBReaderRecallMark();
    goto LABEL_23;
  }
  return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

void sub_1000871B8(id a1)
{
  uint64_t v2 = objc_opt_new();
  id v3 = (void *)qword_10035CD78;
  qword_10035CD78 = v2;

  id v4 = [objc_alloc((Class)NSXPCListener) initWithMachServiceName:@"com.apple.security.escrow-update"];
  unsigned int v5 = (void *)qword_10035CD80;
  qword_10035CD80 = (uint64_t)v4;

  [(id)qword_10035CD80 setDelegate:qword_10035CD78];
  [(id)qword_10035CD80 resume];
}

void sub_1000876A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id *location)
{
  objc_destroyWeak(location);
  objc_destroyWeak((id *)(v22 - 96));
  _Unwind_Resume(a1);
}

void sub_1000876C4(uint64_t a1, int a2, void *a3)
{
  unsigned int v5 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if ([WeakRetained logForUpgrade])
  {
    unint64_t v7 = +[CKKSAnalytics logger];
    [v7 logResultForEvent:@"OctagonEventUpgradeSetAllowList" hardFailure:1 result:v5];
  }
  char v8 = sub_10000B070("octagon-authkit");
  BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (v9)
    {
      int v14 = 138412290;
      CFStringRef v15 = v5;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Unable to save machineID allow-list: %@", (uint8_t *)&v14, 0xCu);
    }

    [WeakRetained setError:v5];
  }
  else
  {
    if (v9)
    {
      CFStringRef v10 = @"no";
      uint64_t v11 = *(void *)(a1 + 32);
      if (a2) {
        CFStringRef v10 = @"some";
      }
      int v14 = 138412546;
      CFStringRef v15 = v10;
      __int16 v16 = 2112;
      uint64_t v17 = v11;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Successfully saved machineID allow-list (%@ change), version = %@", (uint8_t *)&v14, 0x16u);
    }

    if (a2) {
      [WeakRetained stateIfListUpdates];
    }
    else {
    uint64_t v12 = [WeakRetained intendedState];
    }
    [WeakRetained setNextState:v12];
  }
  id v13 = [WeakRetained finishedOp];
  [WeakRetained runBeforeGroupFinished:v13];
}

void sub_100087DB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id *location, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,id a26)
{
}

void sub_100087E0C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v3 = [WeakRetained error];

  if (v3)
  {
    id v4 = [WeakRetained retryFlag];

    if (!v4)
    {
      uint64_t v17 = sub_10000B070("SecError");
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v22) = 0;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "octagon-authkit: Received an error updating the trusted device list operation, but no retry flag present.", (uint8_t *)&v22, 2u);
      }

      uint64_t v18 = *(void *)(a1 + 32);
      int v14 = [WeakRetained error];
      +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v18 success:0 error:v14];
      goto LABEL_19;
    }
    unsigned int v5 = [WeakRetained deps];
    unint64_t v6 = [v5 lockStateTracker];
    unint64_t v7 = [WeakRetained error];
    unsigned int v8 = [v6 isLockedError:v7];

    BOOL v9 = sub_10000B070("octagon-authkit");
    BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
    if (v8)
    {
      if (v10)
      {
        uint64_t v11 = [WeakRetained error];
        int v22 = 138412290;
        id v23 = v11;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Setting the allowed device list failed due to lock state: %@", (uint8_t *)&v22, 0xCu);
      }
      [WeakRetained setNextState:@"WaitForUnlock"];
      uint64_t v12 = [OctagonPendingFlag alloc];
      id v13 = [WeakRetained retryFlag];
      int v14 = [(OctagonPendingFlag *)v12 initWithFlag:v13 conditions:1];

      if (!v14) {
        goto LABEL_18;
      }
      CFStringRef v15 = sub_10000B070("octagon-authkit");
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        int v22 = 138412290;
        id v23 = v14;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Machine ID list error is not fatal: requesting retry: %@", (uint8_t *)&v22, 0xCu);
      }

      BOOL v9 = [WeakRetained deps];
      __int16 v16 = [v9 flagHandler];
      [v16 handlePendingFlag:v14];
    }
    else
    {
      if (v10)
      {
        __int16 v19 = [WeakRetained error];
        int v22 = 138412290;
        id v23 = v19;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Error is currently unknown, will not retry: %@", (uint8_t *)&v22, 0xCu);
      }
      int v14 = 0;
    }

LABEL_18:
    uint64_t v20 = *(void *)(a1 + 32);
    id v21 = [WeakRetained error];
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v20 success:0 error:v21];

LABEL_19:
    goto LABEL_20;
  }
  +[SecurityAnalyticsReporterRTC sendMetricWithEvent:*(void *)(a1 + 32) success:1 error:0];
LABEL_20:
}

void sub_10008815C(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8, void *a9, void *a10)
{
  id v17 = a2;
  id v51 = a3;
  id v18 = a4;
  id v19 = a5;
  id v20 = a6;
  id v21 = a7;
  id v22 = a8;
  id v23 = a9;
  id v24 = a10;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  long long v26 = WeakRetained;
  if (v24)
  {
    id v48 = v21;
    id v49 = v23;
    id v47 = v22;
    id v27 = v17;
    long long v28 = sub_10000B070("SecError");
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v54 = v24;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "octagon-authkit: Unable to fetch machine ID list: %@", buf, 0xCu);
    }
    id v29 = v20;
    id v30 = v19;
    id v31 = v18;

    if ([v26 logForUpgrade])
    {
      id v32 = +[CKKSAnalytics logger];
      [v32 logRecoverableError:v24 forEvent:@"OctagonEventUpgradeFetchDeviceIDs" withAttributes:0];
    }
    [v26 setError:v24];
    id v33 = [v26 deps];
    id v34 = [v33 cuttlefishXPCWrapper];
    __int16 v35 = [v26 deps];
    id v36 = [v35 activeAccount];
    v52[0] = _NSConcreteStackBlock;
    v52[1] = 3221225472;
    v52[2] = sub_100088524;
    v52[3] = &unk_1002F9A20;
    v52[4] = v26;
    [v34 markTrustedDeviceListFetchFailed:v36 reply:v52];

    id v18 = v31;
    id v19 = v30;
    id v17 = v27;
    id v20 = v29;
    id v22 = v47;
    id v21 = v48;
    id v23 = v49;
    long long v37 = v51;
  }
  else if (v17)
  {
    if ([WeakRetained logForUpgrade])
    {
      +[CKKSAnalytics logger];
      id v50 = v23;
      id v38 = v20;
      id v39 = v17;
      id v40 = v19;
      v42 = id v41 = v18;
      [v42 logSuccessForEventNamed:@"OctagonEventUpgradeFetchDeviceIDs"];

      id v18 = v41;
      id v19 = v40;
      id v17 = v39;
      id v20 = v38;
      id v23 = v50;
    }
    LOBYTE(v46) = *(unsigned char *)(a1 + 40);
    long long v37 = v51;
    [v26 afterAuthKitFetch:v17 userInitiatedRemovals:v51 evictedRemovals:v18 unknownReasonRemovals:v19 trustedDeviceHash:v21 deletedDeviceHash:v22 trustedDevicesUpdateTimestamp:v23 accountIsDemo:v46 version:v20];
  }
  else
  {
    unsigned int v43 = sub_10000B070("SecError");
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "octagon-authkit: empty machine id list", buf, 2u);
    }

    if ([v26 logForUpgrade])
    {
      id v44 = +[CKKSAnalytics logger];
      [v44 logRecoverableError:0 forEvent:@"OctagonEventUpgradeFetchDeviceIDs" withAttributes:0];
    }
    [v26 setError:0];
    unsigned int v45 = [v26 finishedOp];
    [v26 runBeforeGroupFinished:v45];

    long long v37 = v51;
  }
}

void sub_100088524(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = sub_10000B070("octagon-authkit");
  BOOL v5 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v5)
    {
      int v8 = 138412290;
      id v9 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Unable to mark machineID list as out of date: %@", (uint8_t *)&v8, 0xCu);
    }

    [*(id *)(a1 + 32) setError:v3];
  }
  else
  {
    if (v5)
    {
      LOWORD(v8) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Successfully marked machineID list as out of date", (uint8_t *)&v8, 2u);
    }
  }
  unint64_t v6 = *(void **)(a1 + 32);
  unint64_t v7 = [v6 finishedOp];
  [v6 runBeforeGroupFinished:v7];
}

uint64_t sub_100088D84(uint64_t a1, uint64_t a2)
{
  while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0;
    while (1)
    {
      uint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      unint64_t v8 = v7 + 1;
      if (v7 == -1 || v8 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v9 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v8;
      v6 |= (unint64_t)(v9 & 0x7F) << v4;
      if ((v9 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v10 = v5++ >= 9;
      if (v10)
      {
        unint64_t v6 = 0;
        int v11 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }
    *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v11 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0;
    }
LABEL_13:
    if (v11 || (v6 & 7) == 4) {
      return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    unint64_t v13 = v6 >> 3;
    if ((int)(v6 >> 3) > 102)
    {
      if (v13 == 103)
      {
        char v19 = 0;
        unsigned int v20 = 0;
        uint64_t v21 = 0;
        *(unsigned char *)(a1 + 40) |= 1u;
        while (1)
        {
          uint64_t v22 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          unint64_t v23 = v22 + 1;
          if (v22 == -1 || v23 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            break;
          }
          char v24 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v22);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v23;
          v21 |= (unint64_t)(v24 & 0x7F) << v19;
          if ((v24 & 0x80) == 0) {
            goto LABEL_39;
          }
          v19 += 7;
          BOOL v10 = v20++ >= 9;
          if (v10)
          {
            uint64_t v21 = 0;
            goto LABEL_41;
          }
        }
        *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_39:
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v21 = 0;
        }
LABEL_41:
        *(void *)(a1 + 8) = v21;
      }
      else
      {
        if (v13 != 201)
        {
LABEL_36:
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
          continue;
        }
        __int16 v16 = objc_alloc_init(SECC2MPError);
        objc_storeStrong((id *)(a1 + 24), v16);
        if (!PBReaderPlaceMark() || (sub_100153C18((uint64_t)v16, a2) & 1) == 0)
        {

          return 0;
        }
        PBReaderRecallMark();
      }
    }
    else if (v13 == 101)
    {
      uint64_t v17 = PBReaderReadString();
      id v18 = *(void **)(a1 + 32);
      *(void *)(a1 + 32) = v17;
    }
    else
    {
      if (v13 != 102) {
        goto LABEL_36;
      }
      *(unsigned char *)(a1 + 40) |= 2u;
      unint64_t v14 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v14 <= 0xFFFFFFFFFFFFFFF7 && v14 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
      {
        uint64_t v15 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v14);
        *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v14 + 8;
      }
      else
      {
        *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
        uint64_t v15 = 0;
      }
      *(void *)(a1 + 16) = v15;
    }
  }
  return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

BOOL sub_10008A708(uint64_t a1)
{
  [*(id *)(a1 + 32) timeIntervalSinceDate:];
  return v2 > (double)*(int *)(a1 + 40);
}

void sub_10008B254(id a1)
{
  uint64_t v1 = sub_100029A10("ratelimiterdisabledlogevent", 60);
  double v2 = (void *)qword_10035CD90;
  qword_10035CD90 = (uint64_t)v1;

  id v3 = qword_10035CD90;
  context = dispatch_get_context((dispatch_object_t)qword_10035CD90);
  context[2] = _Block_copy(&stru_1002F8940);

  dispatch_activate(v3);
}

void sub_10008B2C4(id a1)
{
  uint64_t v1 = sub_1000CD884(@"ratelimit", 0);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)double v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "Rate limiting disabled, returning automatic all-clear", v2, 2u);
  }
}

void sub_10008BE4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id location,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
  objc_destroyWeak(v37);
  _Block_object_dispose((const void *)(v38 - 176), 8);
  objc_destroyWeak(&location);
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a37, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10008BEE8(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10008BEF8(uint64_t a1)
{
}

void sub_10008BF00(uint64_t a1)
{
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  double v2 = [*(id *)(a1 + 32) deps];
  id v3 = [v2 views];

  id obj = v3;
  id v26 = [v3 countByEnumeratingWithState:&v28 objects:v32 count:16];
  if (v26)
  {
    uint64_t v25 = *(void *)v29;
    do
    {
      char v4 = 0;
      do
      {
        if (*(void *)v29 != v25) {
          objc_enumerationMutation(obj);
        }
        unsigned int v5 = *(void **)(*((void *)&v28 + 1) + 8 * (void)v4);
        unint64_t v6 = [*(id *)(a1 + 32) deps];
        uint64_t v7 = [v6 contextID];
        unint64_t v8 = [v5 zoneID];
        char v9 = [v8 zoneName];
        BOOL v10 = +[CKKSZoneStateEntry contextID:v7 zoneName:v9];

        if ([v10 ckzonecreated] && objc_msgSend(v10, "ckzonesubscribed"))
        {
          int v11 = [v5 zoneID];
          uint64_t v12 = [v11 zoneName];
          unint64_t v13 = sub_1000CD884(@"ckkskey", v12);

          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
          {
            *(_WORD *)long long buf = 0;
            _os_log_debug_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "Zone is already created and subscribed", buf, 2u);
          }

          [v5 setViewKeyHierarchyState:@"initialized"];
        }
        else
        {
          id v14 = objc_alloc((Class)CKRecordZone);
          uint64_t v15 = [v5 zoneID];
          id v16 = [v14 initWithZoneID:v15];

          [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) addObject:v16];
          id v17 = objc_alloc((Class)CKRecordZoneSubscription);
          id v18 = [v16 zoneID];
          char v19 = [v16 zoneID];
          unsigned int v20 = [v19 zoneName];
          uint64_t v21 = [@"zone:" stringByAppendingString:v20];
          id v22 = [v17 initWithZoneID:v18 subscriptionID:v21];

          [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) addObject:v22];
          [v5 setViewKeyHierarchyState:@"initializing"];
          unint64_t v23 = [v5 launch];
          [v23 addEvent:@"zone-create"];
        }
        char v4 = (char *)v4 + 1;
      }
      while (v26 != v4);
      id v26 = [obj countByEnumeratingWithState:&v28 objects:v32 count:16];
    }
    while (v26);
  }
}

void sub_10008C24C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  if (v9)
  {
    int v11 = sub_1000CD884(@"ckkszonemodifier", 0);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      id v38 = v9;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Zone modification failed: %@", buf, 0xCu);
    }

    uint64_t v12 = [WeakRetained deps];
    [v12 inspectErrorForRetryAfter:v9];

    unint64_t v13 = [WeakRetained deps];
    id v14 = [v13 reachabilityTracker];
    unsigned int v15 = [v14 isNetworkError:v9];

    if (v15)
    {
      id v16 = sub_1000CD884(@"ckkszonemodifier", 0);
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Waiting for reachability before issuing zone creation", buf, 2u);
      }

      [WeakRetained setNetworkError:1];
    }
  }
  id v17 = sub_1000CD884(@"ckkszonemodifier", 0);
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    id v38 = v7;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "created zones: %@", buf, 0xCu);
  }

  [WeakRetained setZoneModificationError:v9];
  id v18 = [WeakRetained zoneModificationError];

  if (v18)
  {
    char v19 = [WeakRetained operationQueue];
    unsigned int v20 = [WeakRetained setResultStateOperation];
    [v19 addOperation:v20];
  }
  else
  {
    uint64_t v21 = sub_1000CD884(@"ckkszonemodifier", 0);
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      id v22 = *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
      *(_DWORD *)long long buf = 138412290;
      id v38 = v22;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Attempting to subscribe to zones %@", buf, 0xCu);
    }

    unint64_t v23 = [WeakRetained deps];
    char v24 = [v23 cloudKitClassDependencies];
    id v25 = [objc_msgSend(objc_msgSend(objc_msgSend(v24, "modifySubscriptionsOperationClass"), "alloc"), "initWithSubscriptionsToSave:subscriptionIDsToDelete:", *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), 0);
    uint64_t v26 = *(void *)(*(void *)(a1 + 40) + 8);
    id v27 = *(void **)(v26 + 40);
    *(void *)(v26 + 40) = v25;

    long long v28 = [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) configuration];
    [v28 setIsCloudKitSupportOperation:1];

    long long v29 = [WeakRetained deps];
    long long v30 = [v29 ckdatabase];
    [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) setDatabase:v30];

    [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) setName:@"zone-subscription-operation"];
    [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) setQualityOfService:25];
    v33[0] = _NSConcreteStackBlock;
    v33[1] = 3221225472;
    v33[2] = sub_10008C8BC;
    v33[3] = &unk_1002F8990;
    objc_copyWeak(&v36, (id *)(a1 + 56));
    uint64_t v35 = *(void *)(a1 + 48);
    id v34 = v7;
    [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) setModifySubscriptionsCompletionBlock:v33];
    long long v31 = [WeakRetained deps];
    id v32 = [v31 ckdatabase];
    [v32 addOperation:*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40)];

    objc_destroyWeak(&v36);
  }
}

void sub_10008C6C8(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_10008C6E8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v3 = sub_1000CD884(@"ckkszonemodifier", 0);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)BOOL v10 = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Finished creating & subscribing to zones", v10, 2u);
  }

  if ([WeakRetained networkError])
  {
    [WeakRetained setNextState:@"zone_creation_failed_due_to_network_error"];
    uint64_t v4 = [WeakRetained zoneModificationError];
    if (v4)
    {
      unsigned int v5 = (void *)v4;
      [WeakRetained setError:v4];
    }
    else
    {
      id v7 = [WeakRetained zoneSubscriptionError];
      [WeakRetained setError:v7];

      unsigned int v5 = 0;
    }
  }
  else if ([WeakRetained allZoneCreationsSucceeded] {
         && ([WeakRetained allZoneSubscriptionsSucceeded] & 1) != 0)
  }
  {
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:*(void *)(a1 + 32) success:1 error:0];
    unsigned int v5 = [WeakRetained intendedState];
    [WeakRetained setNextState:v5];
  }
  else
  {
    [WeakRetained setNextState:@"zonecreationfailed"];
    unint64_t v6 = [WeakRetained zoneModificationError];
    if (v6)
    {
      [WeakRetained setError:v6];
    }
    else
    {
      id v8 = [WeakRetained zoneSubscriptionError];
      [WeakRetained setError:v8];
    }
    uint64_t v9 = *(void *)(a1 + 32);
    unsigned int v5 = [WeakRetained error];
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v9 success:0 error:v5];
  }
}

void sub_10008C8BC(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6 = a2;
  id v7 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  [WeakRetained setZoneSubscriptionError:v7];
  if (v7)
  {
    uint64_t v9 = sub_1000CD884(@"ckkszonemodifier", 0);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      id v30 = v7;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Couldn't create cloudkit zone subscription; keychain syncing is severely degraded: %@",
        buf,
        0xCu);
    }

    BOOL v10 = [WeakRetained deps];
    [v10 inspectErrorForRetryAfter:v7];

    int v11 = [WeakRetained deps];
    uint64_t v12 = [v11 reachabilityTracker];
    unsigned int v13 = [v12 isNetworkError:v7];

    if (v13)
    {
      id v14 = sub_1000CD884(@"ckkszonemodifier", 0);
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Waiting for reachability before issuing zone subscription", buf, 2u);
      }

      [WeakRetained setNetworkError:1];
    }
  }
  unsigned int v15 = sub_1000CD884(@"ckkszonemodifier", 0);
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    id v30 = v6;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Successfully subscribed to %@", buf, 0xCu);
  }

  id v16 = [WeakRetained deps];
  id v17 = [v16 databaseProvider];
  v24[0] = _NSConcreteStackBlock;
  v24[1] = 3221225472;
  v24[2] = sub_10008CBAC;
  void v24[3] = &unk_100305498;
  char v19 = *(void **)(a1 + 32);
  uint64_t v18 = *(void *)(a1 + 40);
  v24[4] = WeakRetained;
  uint64_t v28 = v18;
  id v25 = v19;
  id v26 = v6;
  id v27 = v7;
  id v20 = v7;
  id v21 = v6;
  [v17 dispatchSyncWithSQLTransaction:v24];

  id v22 = [WeakRetained operationQueue];
  unint64_t v23 = [WeakRetained setResultStateOperation];
  [v22 addOperation:v23];
}

uint64_t sub_10008CBAC(id *a1)
{
  uint64_t v1 = a1;
  long long v106 = 0u;
  long long v107 = 0u;
  long long v108 = 0u;
  long long v109 = 0u;
  double v2 = [a1[4] deps];
  id v3 = [v2 views];

  id obj = v3;
  id v94 = [v3 countByEnumeratingWithState:&v106 objects:v116 count:16];
  if (v94)
  {
    uint64_t v92 = *(void *)v107;
    uint64_t v93 = v1;
    do
    {
      for (uint64_t i = 0; i != v94; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v107 != v92) {
          objc_enumerationMutation(obj);
        }
        unsigned int v5 = *(void **)(*((void *)&v106 + 1) + 8 * i);
        long long v102 = 0u;
        long long v103 = 0u;
        long long v104 = 0u;
        long long v105 = 0u;
        id v6 = *(id *)(*((void *)v1[8] + 1) + 40);
        id v7 = [v6 countByEnumeratingWithState:&v102 objects:v115 count:16];
        if (v7)
        {
          id v8 = v7;
          uint64_t v9 = *(void *)v103;
LABEL_8:
          uint64_t v10 = 0;
          while (1)
          {
            if (*(void *)v103 != v9) {
              objc_enumerationMutation(v6);
            }
            int v11 = *(void **)(*((void *)&v102 + 1) + 8 * v10);
            uint64_t v12 = [v11 zoneID];
            unsigned int v13 = [v5 zoneID];
            unsigned __int8 v14 = [v12 isEqual:v13];

            if (v14) {
              break;
            }
            if (v8 == (id)++v10)
            {
              id v8 = [v6 countByEnumeratingWithState:&v102 objects:v115 count:16];
              if (v8) {
                goto LABEL_8;
              }
              uint64_t v1 = v93;
              goto LABEL_84;
            }
          }
          id v15 = v11;

          uint64_t v1 = v93;
          if (!v15) {
            continue;
          }
          unsigned int v96 = [v93[5] containsObject:v15];
          id v91 = v15;
          if (v96)
          {
            id v16 = [v5 zoneID];
            id v17 = [v16 zoneName];
            uint64_t v18 = sub_1000CD884(@"ckkszone", v17);

            if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
            {
              id v59 = [v5 zoneID];
              *(_DWORD *)long long buf = 138412290;
              *(void *)id v111 = v59;
              _os_log_debug_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEBUG, "Successfully created '%@'", buf, 0xCu);
            }
            [v5 armReadyNotification];
            v95 = 0;
            goto LABEL_30;
          }
          uint64_t v19 = [v93[4] zoneModificationError];
          if (!v19) {
            goto LABEL_24;
          }
          id v20 = (void *)v19;
          id v21 = [v93[4] zoneModificationError];
          id v22 = [v21 domain];
          if ([v22 isEqualToString:CKErrorDomain])
          {
            unint64_t v23 = [v93[4] zoneModificationError];
            id v24 = [v23 code];

            if (v24 == (id)2)
            {
              id v20 = [v93[4] zoneModificationError];
              id v21 = [v20 userInfo];
              id v22 = [v21 objectForKeyedSubscript:CKPartialErrorsByItemIDKey];
              id v25 = [v5 zoneID];
              v95 = [v22 objectForKeyedSubscript:v25];

              goto LABEL_26;
            }
LABEL_24:
            v95 = 0;
          }
          else
          {
            v95 = 0;
LABEL_26:
          }
          id v26 = [v5 zoneID];
          id v27 = [v26 zoneName];
          uint64_t v28 = sub_1000CD884(@"ckkszone", v27);

          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
          {
            long long v29 = [v5 zoneID];
            *(_DWORD *)long long buf = 138412546;
            *(void *)id v111 = v29;
            *(_WORD *)&v111[8] = 2112;
            *(void *)&v111[10] = v95;
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "Failed to create '%@' with error %@", buf, 0x16u);
          }
LABEL_30:
          id v30 = [v5 zoneID];
          long long v31 = [v30 zoneName];
          id v32 = [@"zone:" stringByAppendingString:v31];

          long long v100 = 0u;
          long long v101 = 0u;
          long long v98 = 0u;
          long long v99 = 0u;
          id v33 = v93[6];
          id v34 = [v33 countByEnumeratingWithState:&v98 objects:v114 count:16];
          if (v34)
          {
            id v35 = v34;
            uint64_t v36 = *(void *)v99;
LABEL_32:
            uint64_t v37 = 0;
            while (1)
            {
              if (*(void *)v99 != v36) {
                objc_enumerationMutation(v33);
              }
              id v38 = [*(id *)(*((void *)&v98 + 1) + 8 * v37) subscriptionID];
              unsigned __int8 v39 = [v38 isEqual:v32];

              if (v39) {
                break;
              }
              if (v35 == (id)++v37)
              {
                id v35 = [v33 countByEnumeratingWithState:&v98 objects:v114 count:16];
                if (v35) {
                  goto LABEL_32;
                }
                goto LABEL_38;
              }
            }

            id v40 = v93[7];
            if (!v40) {
              goto LABEL_61;
            }
            int v41 = 1;
LABEL_42:
            uint64_t v42 = [v40 domain];
            if (([v42 isEqualToString:CKErrorDomain] & 1) == 0) {
              goto LABEL_60;
            }
            id v43 = [v93[7] code];

            if (v43 != (id)2)
            {
              if (v41) {
                goto LABEL_61;
              }
              goto LABEL_54;
            }
            id v44 = [v93[7] userInfo];
            unsigned int v45 = [v44 objectForKeyedSubscript:CKPartialErrorsByItemIDKey];
            uint64_t v42 = [v45 objectForKeyedSubscript:v32];

            uint64_t v46 = [v42 userInfo];
            id v47 = [v46 objectForKeyedSubscript:NSUnderlyingErrorKey];

            if (!v42) {
              goto LABEL_59;
            }
            id v48 = [v42 domain];
            if ([v48 isEqualToString:CKErrorDomain]
              && [v42 code] == (id)15
              && v47)
            {
              id v49 = [v47 domain];
              if ([v49 isEqualToString:CKErrorDomain])
              {
                id v50 = [v47 code];

                if (v50 == (id)2032)
                {
                  id v51 = [v5 zoneID];
                  CFStringRef v52 = [v51 zoneName];
                  uint64_t v53 = sub_1000CD884(@"ckks", v52);

                  if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
                  {
                    *(_WORD *)long long buf = 0;
                    _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, "zone subscription error appears to say that the zone subscription exists; this is okay!",
                      buf,
                      2u);
                  }

LABEL_61:
                  id v60 = [v5 zoneID];
                  uint64_t v61 = [v60 zoneName];
                  unsigned int v56 = sub_1000CD884(@"ckkszone", v61);

                  if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
                  {
                    __int16 v88 = [v5 zoneID];
                    *(_DWORD *)long long buf = 138412290;
                    *(void *)id v111 = v88;
                    _os_log_debug_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEBUG, "Successfully subscribed '%@'", buf, 0xCu);
                  }
                  uint64_t v58 = 1;
LABEL_64:

                  id v62 = [v5 zoneID];
                  uint64_t v63 = [v62 zoneName];
                  uint64_t v64 = sub_1000CD884(@"ckkszone", v63);

                  if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
                  {
                    id v65 = v93[7];
                    *(_DWORD *)long long buf = 67109890;
                    *(_DWORD *)id v111 = v96;
                    *(_WORD *)&v111[4] = 2112;
                    *(void *)&v111[6] = v95;
                    *(_WORD *)&v111[14] = 1024;
                    *(_DWORD *)&v111[16] = v58;
                    __int16 v112 = 2112;
                    id v113 = v65;
                    _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "Zone setup progress: created:%d %@ subscribed:%d %@", buf, 0x22u);
                  }

                  if ((v96 & v58) == 1) {
                    [v5 setViewKeyHierarchyState:@"initialized"];
                  }
                  unsigned int v66 = [v93[4] deps];
                  CFDataRef v67 = [v66 contextID];
                  unsigned int v68 = [v5 zoneID];
                  long long v69 = [v68 zoneName];
                  long long v70 = +[CKKSZoneStateEntry contextID:v67 zoneName:v69];

                  uint64_t v1 = v93;
                  [v70 setCkzonecreated:v96];
                  [v70 setCkzonesubscribed:v58];
                  id v71 = v93[7];
                  if (v71)
                  {
                    long long v72 = [v71 domain];
                    if (![v72 isEqualToString:CKErrorDomain]) {
                      goto LABEL_78;
                    }
                    id v73 = [v93[7] code];

                    if (v73 == (id)2)
                    {
                      long long v74 = [v93[7] userInfo];
                      id v75 = [v74 objectForKeyedSubscript:CKPartialErrorsByItemIDKey];
                      id v76 = [v5 zoneID];
                      long long v72 = [v75 objectForKeyedSubscript:v76];

                      if (v72)
                      {
                        unsigned __int8 v77 = [v72 domain];
                        if ([v77 isEqualToString:CKErrorDomain])
                        {
                          id v78 = [v72 code];

                          if (v78 == (id)26)
                          {
                            id v79 = [v5 zoneID];
                            long long v80 = [v79 zoneName];
                            id v81 = sub_1000CD884(@"ckks", v80);

                            if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
                            {
                              id v82 = v93[7];
                              *(_DWORD *)long long buf = 138412290;
                              *(void *)id v111 = v82;
                              _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_ERROR, "zone subscription error appears to say the zone doesn't exist, fixing status: %@", buf, 0xCu);
                            }

                            [v70 setCkzonecreated:0];
                          }
                        }
                        else
                        {
                        }
                      }
LABEL_78:
                    }
                  }
                  id v97 = 0;
                  [v70 saveToDatabase:&v97];
                  id v83 = v97;
                  if (v83)
                  {
                    __int16 v84 = [v5 zoneID];
                    uint64_t v85 = [v84 zoneName];
                    __int16 v86 = sub_1000CD884(@"ckks", v85);

                    if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
                    {
                      CFStringRef v87 = [v5 zoneID];
                      *(_DWORD *)long long buf = 138412546;
                      *(void *)id v111 = v87;
                      *(_WORD *)&v111[8] = 2112;
                      *(void *)&v111[10] = v83;
                      _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_ERROR, "couldn't save zone creation status for %@: %@", buf, 0x16u);
                    }
                  }
                  [v93[4] setAllZoneCreationsSucceeded:v96 & [v93[4] allZoneCreationsSucceeded]];
                  [v93[4] setAllZoneSubscriptionsSucceeded:v58 & [v93[4] allZoneSubscriptionsSucceeded]];

                  id v6 = v91;
                  goto LABEL_84;
                }
LABEL_59:

LABEL_60:
                if (v41) {
                  goto LABEL_61;
                }
LABEL_54:
                id v54 = [v5 zoneID];
                uint64_t v55 = [v54 zoneName];
                unsigned int v56 = sub_1000CD884(@"ckkszone", v55);

                if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
                {
                  id v57 = [v5 zoneID];
                  *(_DWORD *)long long buf = 138412290;
                  *(void *)id v111 = v57;
                  _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "Failed to subscribe to '%@'", buf, 0xCu);
                }
                uint64_t v58 = 0;
                goto LABEL_64;
              }
            }
            goto LABEL_59;
          }
LABEL_38:

          id v40 = v93[7];
          if (v40)
          {
            int v41 = 0;
            goto LABEL_42;
          }
          goto LABEL_54;
        }
LABEL_84:
      }
      id v94 = [obj countByEnumeratingWithState:&v106 objects:v116 count:16];
    }
    while (v94);
  }

  return 1;
}

void sub_10008DD78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10008DD90(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10008DDA0(uint64_t a1)
{
}

void sub_10008DDA8(uint64_t a1)
{
  double v2 = *(void **)(a1 + 32);
  id v14 = 0;
  id v3 = [v2 fetchSelfPeers:&v14];
  id v4 = v14;
  unsigned int v5 = *(void **)(a1 + 32);
  id v13 = 0;
  id v6 = [v5 fetchTrustedPeers:&v13];
  id v7 = v13;
  id v8 = [CKKSPeerProviderState alloc];
  uint64_t v9 = [*(id *)(a1 + 32) providerID];
  uint64_t v10 = -[CKKSPeerProviderState initWithPeerProviderID:essential:selfPeers:selfPeersError:trustedPeers:trustedPeersError:](v8, "initWithPeerProviderID:essential:selfPeers:selfPeersError:trustedPeers:trustedPeersError:", v9, [*(id *)(a1 + 32) essential], v3, v4, v6, v7);
  uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v12 = *(void **)(v11 + 40);
  *(void *)(v11 + 40) = v10;
}

id sub_10008DF28(uint64_t a1, void *a2)
{
  return [a2 trustedPeerSetChanged:*(void *)(a1 + 32)];
}

id sub_10008DFBC(uint64_t a1, void *a2)
{
  return [a2 selfPeerChanged:*(void *)(a1 + 32)];
}

void sub_10008E7C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59)
{
  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a35, 8);
  _Block_object_dispose(&a39, 8);
  _Block_object_dispose(&a43, 8);
  _Block_object_dispose(&a47, 8);
  _Block_object_dispose(&a51, 8);
  _Block_object_dispose(&a55, 8);
  _Block_object_dispose(&a59, 8);
  _Block_object_dispose((const void *)(v59 - 240), 8);
  _Unwind_Resume(a1);
}

void sub_10008E884(uint64_t a1, void *a2)
{
  [*(id *)(a1 + 32) stopWithEvent:@"OctagonSOSAdapterUpdateKeys" result:a2];
  if (a2)
  {
    id v4 = sub_10000B070("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      uint64_t v9 = a2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "octagon-sos: failed to update Octagon keys in SOS:%@", (uint8_t *)&v8, 0xCu);
    }

    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
    uint64_t v5 = *(void *)(*(void *)(a1 + 48) + 8);
    id v6 = a2;
    id v7 = *(NSObject **)(v5 + 40);
    *(void *)(v5 + 40) = v6;
  }
  else
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
    id v7 = sub_10000B070("octagon-sos");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v8) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "successfully updated Octagon keys in SOS!", (uint8_t *)&v8, 2u);
    }
  }

  CFRelease(*(CFTypeRef *)(*(void *)(*(void *)(a1 + 56) + 8) + 24));
  CFRelease(*(CFTypeRef *)(*(void *)(*(void *)(a1 + 64) + 8) + 24));
  CFRelease(*(CFTypeRef *)(*(void *)(*(void *)(a1 + 72) + 8) + 24));
  CFRelease(*(CFTypeRef *)(*(void *)(*(void *)(a1 + 80) + 8) + 24));
  CFRelease(*(CFTypeRef *)(*(void *)(*(void *)(a1 + 88) + 8) + 24));
  CFRelease(*(CFTypeRef *)(*(void *)(*(void *)(a1 + 96) + 8) + 24));
  CFRelease(*(CFTypeRef *)(*(void *)(*(void *)(a1 + 104) + 8) + 24));
  CFRelease(*(CFTypeRef *)(*(void *)(*(void *)(a1 + 112) + 8) + 24));
}

void sub_10008EF5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49)
{
  _Block_object_dispose(&a23, 8);
  _Block_object_dispose(&a29, 8);
  _Block_object_dispose(&a33, 8);
  _Block_object_dispose(&a37, 8);
  _Block_object_dispose(&a41, 8);
  _Block_object_dispose(&a45, 8);
  _Block_object_dispose(&a49, 8);
  _Block_object_dispose((const void *)(v49 - 240), 8);
  _Unwind_Resume(a1);
}

void sub_10008EFF8(uint64_t a1, void *a2)
{
  [*(id *)(a1 + 32) stopWithEvent:@"OctagonSOSAdapterUpdateKeys" result:a2];
  if (a2)
  {
    id v4 = sub_10000B070("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      uint64_t v9 = a2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "octagon-preload-keys: failed to preload Octagon keys in SOS:%@", (uint8_t *)&v8, 0xCu);
    }

    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
    uint64_t v5 = *(void *)(*(void *)(a1 + 48) + 8);
    id v6 = a2;
    id v7 = *(NSObject **)(v5 + 40);
    *(void *)(v5 + 40) = v6;
  }
  else
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
    id v7 = sub_10000B070("octagon-preload-keys");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v8) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "successfully preloaded Octagon keys in SOS!", (uint8_t *)&v8, 2u);
    }
  }

  CFRelease(*(CFTypeRef *)(*(void *)(*(void *)(a1 + 56) + 8) + 24));
  CFRelease(*(CFTypeRef *)(*(void *)(*(void *)(a1 + 64) + 8) + 24));
  CFRelease(*(CFTypeRef *)(*(void *)(*(void *)(a1 + 72) + 8) + 24));
  CFRelease(*(CFTypeRef *)(*(void *)(*(void *)(a1 + 80) + 8) + 24));
  CFRelease(*(CFTypeRef *)(*(void *)(*(void *)(a1 + 88) + 8) + 24));
  CFRelease(*(CFTypeRef *)(*(void *)(*(void *)(a1 + 96) + 8) + 24));
}

void sub_10008F3D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void sub_10008F3F4(uint64_t a1, CFSetRef theSet, void *a3)
{
  if (a3)
  {
    id v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v12 = a3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon-sos: Error fetching trusted peers: %@", buf, 0xCu);
    }

    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
    uint64_t v9 = *(void *)(v7 + 40);
    uint64_t v8 = (id *)(v7 + 40);
    if (v9) {
      objc_storeStrong(v8, a3);
    }
  }
  context[0] = _NSConcreteStackBlock;
  context[1] = 3221225472;
  context[2] = sub_10008F534;
  context[3] = &unk_100307A20;
  context[4] = *(void *)(a1 + 40);
  CFSetApplyFunction(theSet, (CFSetApplierFunction)sub_10008F7E4, context);
}

void sub_10008F534(uint64_t a1, uint64_t a2)
{
  if (!a2) {
    return;
  }
  uint64_t PeerID = SOSPeerInfoGetPeerID();
  uint64_t v5 = (const void *)SOSPeerInfoCopyOctagonSigningPublicKey();
  if (v5 && (uint64_t v6 = SOSPeerInfoCopyOctagonEncryptionPublicKey()) != 0)
  {
    uint64_t v7 = (const void *)v6;
    char v8 = 0;
  }
  else
  {
    uint64_t v9 = sub_10000B070("SecError");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412546;
      uint64_t v16 = a2;
      __int16 v17 = 2112;
      uint64_t v18 = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "octagon-sos: error fetching octagon keys for peer: %@ %@", buf, 0x16u);
    }

    uint64_t v7 = 0;
    id v10 = 0;
    id v11 = 0;
    char v8 = 1;
    if (!v5) {
      goto LABEL_11;
    }
  }
  id v11 = [objc_alloc((Class)_SFECPublicKey) initWithSecKey:v5];
  if (v8)
  {
    id v10 = 0;
    char v8 = 1;
  }
  else
  {
    id v10 = [objc_alloc((Class)_SFECPublicKey) initWithSecKey:v7];
    char v8 = 0;
  }
LABEL_11:
  uint64_t v12 = [CKKSSOSPeer alloc];
  uint64_t v13 = +[OTSOSActualAdapter sosCKKSViewList];
  uint64_t v14 = [(CKKSSOSPeer *)v12 initWithSOSPeerID:PeerID encryptionPublicKey:v10 signingPublicKey:v11 viewList:v13];

  [*(id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) addObject:v14];
  if (v5) {
    CFRelease(v5);
  }
  if ((v8 & 1) == 0) {
    CFRelease(v7);
  }
}

uint64_t sub_10008F7E4(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_10008FE4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
}

uint64_t sub_10008FE8C(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  if (a4)
  {
    uint64_t v5 = *(void *)(a1[4] + 8);
    *(void *)(v5 + 40) = a4;
  }
  else
  {
    if (a2 && a3)
    {
      id v7 = [objc_alloc((Class)_SFECKeyPair) initWithSecKey:a3];
      uint64_t v8 = *(void *)(a1[5] + 8);
      uint64_t v9 = *(void **)(v8 + 40);
      *(void *)(v8 + 40) = v7;

      id v10 = [objc_alloc((Class)_SFECKeyPair) initWithSecKey:a2];
      uint64_t v11 = a1[6];
    }
    else
    {
      id v10 = +[NSError errorWithDomain:@"CKKSErrorDomain" code:24 description:@"Not all SOS peer keys available, but no error returned"];
      uint64_t v11 = a1[4];
    }
    *(void *)(*(void *)(v11 + 8) + 40) = v10;
  }

  return _objc_release_x1();
}

id sub_100090184(uint64_t a1)
{
  double v2 = sub_10000B070("octagon-sos");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Received a notification that the SOS Octagon peer set changed", v4, 2u);
  }

  return [*(id *)(a1 + 32) sendTrustedPeerSetChangedUpdate];
}

void sub_100090258(id a1)
{
  qword_10035CD98 = SOSViewCopyViewSet();

  _objc_release_x1();
}

void sub_10009100C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100091040(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v14 = +[CKKSAnalytics logger];
  [v14 logResultForEvent:@"OctagonEventEstablishIdentity" hardFailure:1 result:v12];

  if (v12)
  {
    id v15 = sub_10000B070("SecError");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v36 = v12;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "octagon: Error calling establish: %@", buf, 0xCu);
    }

    if ([v12 isCuttlefishError:1033])
    {
      uint64_t v16 = sub_10000B070("octagon-ckks");
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v17 = [WeakRetained ckksConflictState];
        *(_DWORD *)long long buf = 138412290;
        id v36 = v17;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "A CKKS key hierarchy is out of date; moving to '%@'",
          buf,
          0xCu);
      }
      uint64_t v18 = [WeakRetained ckksConflictState];
      [WeakRetained setNextState:v18];
    }
    else
    {
      [WeakRetained setError:v12];
    }
    id v23 = [WeakRetained finishedOp];
    [WeakRetained runBeforeGroupFinished:v23];
  }
  else
  {
    [WeakRetained setPeerID:v9];
    uint64_t v19 = [WeakRetained operationDependencies];
    id v20 = [v19 stateHolder];
    v32[0] = _NSConcreteStackBlock;
    v32[1] = 3221225472;
    v32[2] = sub_10009141C;
    v32[3] = &unk_1002FAEE8;
    id v33 = v9;
    id v21 = v11;
    id v34 = v21;
    id v31 = 0;
    unsigned int v22 = [v20 persistAccountChanges:v32 error:&v31];
    id v23 = v31;

    if (!v22 || v23)
    {
      id v25 = sub_10000B070("octagon");
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v36 = v23;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "Couldn't persist results: %@", buf, 0xCu);
      }

      [WeakRetained setError:v23];
    }
    else
    {
      id v24 = [WeakRetained intendedState];
      [WeakRetained setNextState:v24];
    }
    id v26 = [WeakRetained operationDependencies];
    id v27 = [v26 ckks];
    [v27 setCurrentSyncingPolicy:v21];

    uint64_t v28 = [WeakRetained operationDependencies];
    long long v29 = [v28 ckks];
    [v29 receiveTLKUploadRecords:v10];

    id v30 = [WeakRetained finishedOp];
    [WeakRetained runBeforeGroupFinished:v30];
  }
}

id sub_10009141C(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 setTrustState:2];
  [v3 setPeerID:*(void *)(a1 + 32)];
  [v3 setTPSyncingPolicy:*(void *)(a1 + 40)];

  return v3;
}

void sub_1000916B4(_Unwind_Exception *a1)
{
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v3 - 80));
  _Unwind_Resume(a1);
}

void sub_1000916EC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  double v2 = sub_10000B070("octagon");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = [WeakRetained error];
    id v4 = (void *)v3;
    CFStringRef v5 = @"no error";
    if (v3) {
      CFStringRef v5 = (const __CFString *)v3;
    }
    int v6 = 138412290;
    CFStringRef v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Finishing an establish operation with %@", (uint8_t *)&v6, 0xCu);
  }
}

void sub_1000917D0(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  double v2 = [*(id *)(a1 + 32) viewKeySets];
  uint64_t v3 = [*(id *)(a1 + 32) pendingTLKShares];
  [WeakRetained proceedWithKeys:v2 pendingTLKShares:v3];
}

void sub_100092288(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36,uint64_t a37,uint64_t a38,uint64_t a39,id location)
{
  objc_destroyWeak(v40);
  _Block_object_dispose(&a30, 8);
  _Block_object_dispose(&a36, 8);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t sub_1000922F4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100092304(uint64_t a1)
{
}

uint64_t sub_10009230C(uint64_t a1)
{
  uint64_t v1 = [*(id *)(a1 + 32) zoneID];
  double v2 = [v1 zoneName];
  uint64_t v3 = sub_1000CD884(@"ckksheal", v2);

  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *(void *)(a1 + 32);
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Attempting to heal %@", buf, 0xCu);
  }

  CFStringRef v5 = [*(id *)(a1 + 32) zoneID];
  int v6 = [*(id *)(a1 + 32) contextID];
  v321 = +[CKKSCurrentKeySet loadForZone:v5 contextID:v6];

  CFStringRef v7 = [v321 error];

  if (v7)
  {
    uint64_t v8 = [v321 error];
    [*(id *)(a1 + 40) setError:v8];

    id v9 = [*(id *)(a1 + 32) zoneID];
    id v10 = [v9 zoneName];
    id v11 = sub_1000CD884(@"ckksheal", v10);

    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      id v12 = [v321 error];
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "couldn't load current key set, attempting to proceed: %@", buf, 0xCu);
    }
  }
  else
  {
    uint64_t v13 = [*(id *)(a1 + 32) zoneID];
    uint64_t v14 = [v13 zoneName];
    id v11 = sub_1000CD884(@"ckksheal", v14);

    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v321;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Key set is %@", buf, 0xCu);
    }
  }

  id v15 = [v321 currentTLKPointer];
  if (!v15) {
    goto LABEL_17;
  }
  uint64_t v16 = [v321 currentClassAPointer];
  if (!v16)
  {
LABEL_16:

    goto LABEL_17;
  }
  __int16 v17 = [v321 currentClassCPointer];
  if (!v17)
  {

    goto LABEL_16;
  }
  uint64_t v18 = [v321 tlk];
  if (v18)
  {
    uint64_t v19 = [v321 classA];
    if (v19)
    {
      id v20 = [v321 classC];
      BOOL v21 = v20 == 0;

      if (!v21) {
        goto LABEL_17;
      }
      goto LABEL_51;
    }
  }
LABEL_51:
  if ([*(id *)(a1 + 40) allowFullRefetchResult])
  {
    unsigned __int8 v77 = [*(id *)(a1 + 32) zoneID];
    id v78 = [v77 zoneName];
    id v79 = sub_1000CD884(@"ckksheal", v78);

    if (os_log_type_enabled(v79, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "Have current key pointers, but no keys. This is exceptional; requesting full refetch",
        buf,
        2u);
    }

    [*(id *)(a1 + 32) setViewKeyHierarchyState:@"needrefetch"];
    long long v80 = *(void **)(a1 + 48);
    uint64_t v397 = kSecurityRTCFieldFullRefetchNeeded;
    v398 = &__kCFBooleanTrue;
    id v316 = +[NSDictionary dictionaryWithObjects:&v398 forKeys:&v397 count:1];
    [v80 addMetrics:v316];
LABEL_55:
    id v81 = 0;
LABEL_56:
    uint64_t v82 = 1;
    goto LABEL_115;
  }
LABEL_17:
  unsigned int v22 = [*(id *)(a1 + 40) deps];
  id v23 = [v22 contextID];
  id v24 = [*(id *)(a1 + 32) zoneID];
  id v374 = 0;
  unsigned __int8 v25 = +[CKKSIncomingQueueEntry allIQEsHaveValidUnwrappingKeysInContextID:v23 zoneID:v24 error:&v374];
  id v316 = v374;

  if (v316)
  {
    id v26 = [*(id *)(a1 + 32) zoneID];
    id v27 = [v26 zoneName];
    uint64_t v28 = sub_1000CD884(@"ckksheal", v27);

    if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
LABEL_21:

      goto LABEL_23;
    }
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = v316;
    long long v29 = "Unable to determine if all IQEs have parent keys: %@";
    id v30 = v28;
    os_log_type_t v31 = OS_LOG_TYPE_ERROR;
    uint32_t v32 = 12;
LABEL_20:
    _os_log_impl((void *)&_mh_execute_header, v30, v31, v29, buf, v32);
    goto LABEL_21;
  }
  if ((v25 & 1) == 0)
  {
    unsigned int v71 = [*(id *)(a1 + 40) allowFullRefetchResult];
    long long v72 = [*(id *)(a1 + 32) zoneID];
    id v73 = [v72 zoneName];
    uint64_t v28 = sub_1000CD884(@"ckksheal", v73);

    BOOL v74 = os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT);
    if (v71)
    {
      if (v74)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "We have some item that encrypts to a non-existent key. This is exceptional; requesting full refetch",
          buf,
          2u);
      }

      id v75 = *(void **)(a1 + 48);
      uint64_t v395 = kSecurityRTCFieldFullRefetchNeeded;
      v396 = &__kCFBooleanTrue;
      id v76 = +[NSDictionary dictionaryWithObjects:&v396 forKeys:&v395 count:1];
      [v75 addMetrics:v76];

      [*(id *)(a1 + 32) setViewKeyHierarchyState:@"needrefetch"];
      id v316 = 0;
      goto LABEL_55;
    }
    if (!v74) {
      goto LABEL_21;
    }
    *(_WORD *)long long buf = 0;
    long long v29 = "We have some item that encrypts to a non-existent key, but we cannot request a refetch! Possible inifinite-loop ahead";
    id v30 = v28;
    os_log_type_t v31 = OS_LOG_TYPE_DEFAULT;
    uint32_t v32 = 2;
    goto LABEL_20;
  }
LABEL_23:
  id v33 = [v321 currentTLKPointer];
  BOOL v34 = v33 == 0;

  if (v34)
  {
    id v35 = [*(id *)(a1 + 32) zoneID];
    id v36 = [v35 zoneName];
    uint64_t v37 = sub_1000CD884(@"ckksheal", v36);

    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "No current TLK pointer?", buf, 2u);
    }

    id v38 = [CKKSCurrentKeyPointer alloc];
    unsigned __int8 v39 = [*(id *)(a1 + 32) contextID];
    id v40 = [*(id *)(a1 + 32) zoneID];
    id v41 = [(CKKSCurrentKeyPointer *)v38 initForClass:@"tlk" contextID:v39 currentKeyUUID:0 zoneID:v40 encodedCKRecord:0];
    [v321 setCurrentTLKPointer:v41];
  }
  uint64_t v42 = [v321 currentClassAPointer];
  BOOL v43 = v42 == 0;

  if (v43)
  {
    id v44 = [*(id *)(a1 + 32) zoneID];
    unsigned int v45 = [v44 zoneName];
    uint64_t v46 = sub_1000CD884(@"ckksheal", v45);

    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "No current ClassA pointer?", buf, 2u);
    }

    id v47 = [CKKSCurrentKeyPointer alloc];
    id v48 = [*(id *)(a1 + 32) contextID];
    uint64_t v49 = [*(id *)(a1 + 32) zoneID];
    id v50 = [(CKKSCurrentKeyPointer *)v47 initForClass:@"classA" contextID:v48 currentKeyUUID:0 zoneID:v49 encodedCKRecord:0];
    [v321 setCurrentClassAPointer:v50];
  }
  id v51 = [v321 currentClassCPointer];
  BOOL v52 = v51 == 0;

  if (v52)
  {
    uint64_t v53 = [*(id *)(a1 + 32) zoneID];
    id v54 = [v53 zoneName];
    uint64_t v55 = sub_1000CD884(@"ckksheal", v54);

    if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "No current ClassC pointer?", buf, 2u);
    }

    unsigned int v56 = [CKKSCurrentKeyPointer alloc];
    id v57 = [*(id *)(a1 + 32) contextID];
    uint64_t v58 = [*(id *)(a1 + 32) zoneID];
    id v59 = [(CKKSCurrentKeyPointer *)v56 initForClass:@"classC" contextID:v57 currentKeyUUID:0 zoneID:v58 encodedCKRecord:0];
    [v321 setCurrentClassCPointer:v59];
  }
  id v60 = [v321 currentTLKPointer];
  uint64_t v61 = [v60 currentKeyUUID];
  if (!v61) {
    goto LABEL_62;
  }
  id v62 = [v321 currentClassAPointer];
  uint64_t v63 = [v62 currentKeyUUID];
  if (!v63)
  {
LABEL_61:

LABEL_62:
    goto LABEL_63;
  }
  uint64_t v64 = [v321 currentClassCPointer];
  id v65 = [v64 currentKeyUUID];
  if (!v65)
  {
LABEL_60:

    goto LABEL_61;
  }
  unsigned int v66 = [v321 tlk];
  if (!v66)
  {
LABEL_59:

    goto LABEL_60;
  }
  CFDataRef v67 = [v321 classA];
  if (!v67)
  {
LABEL_58:

    goto LABEL_59;
  }
  id obj = [v321 classC];
  if (!obj)
  {

    goto LABEL_58;
  }
  to = [v321 classA];
  v309 = [to parentKeyUUID];
  v312 = [v321 tlk];
  v307 = [v312 uuid];
  if ([v309 isEqualToString:v307])
  {
    id v304 = [v321 classC];
    v301 = [v304 parentKeyUUID];
    unsigned int v68 = [v321 tlk];
    long long v69 = [v68 uuid];
    unsigned __int8 v299 = [v301 isEqualToString:v69];

    char v70 = v299 ^ 1;
  }
  else
  {
    char v70 = 1;
  }

  if ((v70 & 1) == 0)
  {
    uint32_t v145 = [v321 tlk];
    id v323 = 0;
    unsigned __int8 v146 = [v145 validTLK:&v323];
    id v81 = v323;

    if ((v146 & 1) == 0)
    {
      uint64_t v158 = +[NSError errorWithDomain:@"CKKSErrorDomain" code:34 description:@"Invalid TLK from CloudKit (during heal)" underlying:v81];
      v159 = [*(id *)(a1 + 32) zoneID];
      v160 = [v159 zoneName];
      uint64_t v161 = sub_1000CD884(@"ckkskey", v160);

      if (os_log_type_enabled(v161, OS_LOG_TYPE_ERROR))
      {
        CFDataRef v162 = [v321 tlk];
        *(_DWORD *)long long buf = 138412546;
        *(void *)&uint8_t buf[4] = v162;
        *(_WORD *)&buf[12] = 2112;
        *(void *)&buf[14] = v158;
        _os_log_impl((void *)&_mh_execute_header, v161, OS_LOG_TYPE_ERROR, "CKKS claims %@ is not a valid TLK: %@", buf, 0x16u);
      }
      [*(id *)(a1 + 32) setViewKeyHierarchyState:@"error"];
      [*(id *)(a1 + 48) populateUnderlyingErrorsStartingWithRootError:v81];
      *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = 0;

      goto LABEL_56;
    }
    BOOL v147 = [v321 tlk];
    int v148 = [*(id *)(a1 + 32) contextID];
    uint64_t v149 = *(void *)(a1 + 56);
    id v322 = v81;
    unsigned __int8 v150 = [v147 tlkMaterialPresentOrRecoverableViaTLKShareForContextID:v148 forTrustStates:v149 error:&v322];
    id v151 = v322;

    if (v150)
    {
      CFBooleanRef v152 = *(void **)(a1 + 40);
      CFDictionaryRef v153 = [v321 tlk];
      LOBYTE(v152) = [v152 ensureKeyPresent:v153 viewState:*(void *)(a1 + 32)];

      if ((v152 & 1) == 0) {
        goto LABEL_135;
      }
      CFStringRef v154 = *(void **)(a1 + 40);
      CFStringRef v155 = [v321 classA];
      LOBYTE(v154) = [v154 ensureKeyPresent:v155 viewState:*(void *)(a1 + 32)];

      if ((v154 & 1) == 0
        || (uint64_t v156 = *(void **)(a1 + 40),
            [v321 classC],
            uint64_t v157 = objc_claimAutoreleasedReturnValue(),
            LOBYTE(v156) = [v156 ensureKeyPresent:v157 viewState:*(void *)(a1 + 32)], v157, (v156 & 1) == 0))
      {
LABEL_135:
        uint64_t v82 = 0;
        *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = 0;
LABEL_141:
        id v81 = v151;
        goto LABEL_115;
      }
      [*(id *)(a1 + 32) setViewKeyHierarchyState:@"ready"];
    }
    else
    {
      uint64_t v168 = a1;
      if (!v151) {
        goto LABEL_136;
      }
      unsigned int v169 = [*(id *)(a1 + 40) deps];
      v170 = [v169 lockStateTracker];
      unsigned int v171 = [v170 isLockedError:v151];

      uint64_t v168 = a1;
      if (v171)
      {
        id v172 = [*(id *)(a1 + 32) zoneID];
        CFStringRef v173 = [v172 zoneName];
        id v174 = sub_1000CD884(@"ckkskey", v173);

        if (os_log_type_enabled(v174, OS_LOG_TYPE_DEFAULT))
        {
          CFStringRef v175 = [v321 tlk];
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = v175;
          _os_log_impl((void *)&_mh_execute_header, v174, OS_LOG_TYPE_DEFAULT, "Received a TLK(%@), but keybag appears to be locked. Entering a waiting state.", buf, 0xCu);
        }
        uint64_t v176 = off_100305FE8;
      }
      else
      {
LABEL_136:
        id v177 = [*(id *)(v168 + 32) zoneID];
        v178 = [v177 zoneName];
        id v174 = sub_1000CD884(@"ckkskey", v178);

        if (os_log_type_enabled(v174, OS_LOG_TYPE_DEFAULT))
        {
          v179 = [v321 tlk];
          *(_DWORD *)long long buf = 138412546;
          *(void *)&uint8_t buf[4] = v179;
          *(_WORD *)&buf[12] = 2112;
          *(void *)&buf[14] = v151;
          _os_log_impl((void *)&_mh_execute_header, v174, OS_LOG_TYPE_DEFAULT, "Received a TLK(%@) which we don't have in the local keychain: %@", buf, 0x16u);
        }
        uint64_t v176 = &off_100305FF0;
      }

      [*(id *)(a1 + 32) setViewKeyHierarchyState:*v176];
      [*(id *)(a1 + 48) populateUnderlyingErrorsStartingWithRootError:v151];
      *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = 0;
    }
    uint64_t v82 = 1;
    goto LABEL_141;
  }
LABEL_63:
  id v83 = objc_alloc((Class)AAFAnalyticsEventSecurity);
  __int16 v84 = [*(id *)(a1 + 40) deps];
  uint64_t v85 = [v84 activeAccount];
  __int16 v86 = [v85 altDSID];
  CFStringRef v87 = [*(id *)(a1 + 40) deps];
  [v87 sendMetric];
  uint64_t v302 = kSecurityRTCEventCategoryAccountDataAccessRecovery;
  id v313 = [v83 initWithCKKSMetrics:&__NSDictionary0__struct altDSID:v86 eventName:kSecurityRTCEventNameHealBrokenRecords testsAreEnabled:0 category:0 sendMetric:0];

  __int16 v88 = [*(id *)(a1 + 32) contextID];
  uint64_t v89 = [*(id *)(a1 + 32) zoneID];
  id v373 = 0;
  uint64_t v90 = +[CKKSKey allKeysForContextID:v88 zoneID:v89 error:&v373];
  id v81 = v373;

  id v308 = objc_alloc_init((Class)NSMutableArray);
  long long v371 = 0u;
  long long v372 = 0u;
  long long v369 = 0u;
  long long v370 = 0u;
  id obja = v90;
  id v91 = [obja countByEnumeratingWithState:&v369 objects:v394 count:16];
  if (!v91)
  {

LABEL_110:
    CFStringRef v141 = [*(id *)(a1 + 32) zoneID];
    uint64_t v142 = [v141 zoneName];
    unsigned int v143 = sub_1000CD884(@"ckksheal", v142);

    if (os_log_type_enabled(v143, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v143, OS_LOG_TYPE_ERROR, "No possible TLK found. Waiting for creation.", buf, 2u);
    }

    [*(id *)(a1 + 32) setViewKeyHierarchyState:@"waitfortlkcreation"];
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v313 success:0 error:0];
    id v92 = 0;
    goto LABEL_113;
  }
  id v92 = 0;
  uint64_t v93 = *(void *)v370;
  do
  {
    id v94 = 0;
    v95 = v81;
    do
    {
      if (*(void *)v370 != v93) {
        objc_enumerationMutation(obja);
      }
      unsigned int v96 = *(void **)(*((void *)&v369 + 1) + 8 * (void)v94);
      id v368 = v95;
      id v97 = [v96 topKeyInAnyState:&v368];
      id v81 = v368;

      if (v92)
      {
        long long v98 = [v92 uuid];
        long long v99 = [v97 uuid];
        unsigned __int8 v100 = [v98 isEqualToString:v99];

        if ((v100 & 1) == 0)
        {
          v133 = [*(id *)(a1 + 32) zoneID];
          uint64_t v134 = [v133 zoneName];
          v135 = sub_1000CD884(@"ckksheal", v134);

          if (os_log_type_enabled(v135, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v135, OS_LOG_TYPE_ERROR, "key hierarchy has split: there's two top keys. Currently we don't handle this situation.", buf, 2u);
          }

          v137 = +[NSString stringWithFormat:@"Key hierarchy has split: %@ and %@ are roots", v92, v97];
          BOOL v138 = +[NSError errorWithDomain:@"CKKSErrorDomain" code:32 description:v137];
          unsigned int v139 = *(void **)(a1 + 40);
          v318 = (id *)(a1 + 40);
          [v139 setError:v138];

          [*v318 setNextState:@"error"];
          CFArrayRef v140 = [*v318 error];
          +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v313 success:0 error:v140];

          goto LABEL_113;
        }
      }
      else
      {
        id v92 = v97;
      }

      id v94 = (char *)v94 + 1;
      v95 = v81;
    }
    while (v91 != v94);
    id v91 = [obja countByEnumeratingWithState:&v369 objects:v394 count:16];
  }
  while (v91);

  if (!v92) {
    goto LABEL_110;
  }
  id v367 = v81;
  unsigned __int8 v101 = [v92 validTLK:&v367];
  id v102 = v367;

  long long v103 = *(void **)(a1 + 32);
  if ((v101 & 1) == 0)
  {
    id v163 = [v103 zoneID];
    v164 = [v163 zoneName];
    id v165 = sub_1000CD884(@"ckkskey", v164);

    if (os_log_type_enabled(v165, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412546;
      *(void *)&uint8_t buf[4] = v92;
      *(_WORD *)&buf[12] = 2112;
      *(void *)&buf[14] = v102;
      _os_log_impl((void *)&_mh_execute_header, v165, OS_LOG_TYPE_ERROR, "CKKS claims %@ is not a valid TLK: %@", buf, 0x16u);
    }

    BOOL v166 = +[NSError errorWithDomain:@"CKKSErrorDomain" code:34 description:@"Invalid TLK from CloudKit (during heal)" underlying:v102];
    [*(id *)(a1 + 40) setError:v166];

    [*(id *)(a1 + 32) setViewKeyHierarchyState:@"error"];
    v167 = [*(id *)(a1 + 40) error];
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v313 success:0 error:v167];

    uint64_t v82 = 1;
    id v81 = v102;
    goto LABEL_114;
  }
  long long v104 = [v103 contextID];
  uint64_t v105 = *(void *)(a1 + 56);
  id v366 = v102;
  unsigned __int8 v106 = [v92 tlkMaterialPresentOrRecoverableViaTLKShareForContextID:v104 forTrustStates:v105 error:&v366];
  id v81 = v366;

  if ((v106 & 1) == 0)
  {
    if (v81
      && ([*(id *)(a1 + 40) deps],
          unsigned int v180 = objc_claimAutoreleasedReturnValue(),
          [v180 lockStateTracker],
          v181 = objc_claimAutoreleasedReturnValue(),
          unsigned int v182 = [v181 isLockedError:v81],
          v181,
          v180,
          v182))
    {
      CFStringRef v183 = [*(id *)(a1 + 32) zoneID];
      CFTypeRef v184 = [v183 zoneName];
      unsigned int v185 = sub_1000CD884(@"ckkskey", v184);

      if (os_log_type_enabled(v185, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v92;
        _os_log_impl((void *)&_mh_execute_header, v185, OS_LOG_TYPE_DEFAULT, "Received a TLK(%@), but keybag appears to be locked. Entering a waiting state.", buf, 0xCu);
      }

      uint64_t v392 = kSecurityRTCFieldIsLocked;
      v393 = &__kCFBooleanTrue;
      unsigned int v186 = +[NSDictionary dictionaryWithObjects:&v393 forKeys:&v392 count:1];
      [v313 addMetrics:v186];
      CFDataRef v187 = off_100305FE8;
    }
    else
    {
      id v188 = [*(id *)(a1 + 32) zoneID];
      uint64_t v189 = [v188 zoneName];
      unsigned int v186 = sub_1000CD884(@"ckkskey", v189);

      if (os_log_type_enabled(v186, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412546;
        *(void *)&uint8_t buf[4] = v92;
        *(_WORD *)&buf[12] = 2112;
        *(void *)&buf[14] = v81;
        _os_log_impl((void *)&_mh_execute_header, v186, OS_LOG_TYPE_DEFAULT, "Received a TLK(%@) which we don't have in the local keychain: %@", buf, 0x16u);
      }
      CFDataRef v187 = &off_100305FF0;
    }

    [*(id *)(a1 + 32) setViewKeyHierarchyState:*v187];
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v313 success:0 error:v81];
LABEL_113:
    uint64_t v82 = 1;
    goto LABEL_114;
  }
  long long v107 = [v321 currentTLKPointer];
  long long v108 = [v107 currentKeyUUID];
  long long v109 = [v92 uuid];
  unsigned __int8 v293 = [v108 isEqualToString:v109];

  if ((v293 & 1) == 0)
  {
    [v321 setTlk:v92];
    id v110 = [v92 uuid];
    id v111 = [v321 currentTLKPointer];
    [v111 setCurrentKeyUUID:v110];
  }
  long long v364 = 0u;
  long long v365 = 0u;
  long long v362 = 0u;
  long long v363 = 0u;
  id v305 = obja;
  toa = (id *)[v305 countByEnumeratingWithState:&v362 objects:v391 count:16];
  if (!toa)
  {
    char v298 = 0;
    char v300 = 0;
    goto LABEL_152;
  }
  char v298 = 0;
  char v300 = 0;
  uint64_t v310 = *(void *)v363;
  do
  {
    for (uint64_t i = 0; i != toa; uint64_t i = (id *)((char *)i + 1))
    {
      if (*(void *)v363 != v310) {
        objc_enumerationMutation(v305);
      }
      id v113 = *(void **)(*((void *)&v362 + 1) + 8 * i);
      uint64_t v114 = [v113 parentKeyUUID];
      long long v115 = [v92 uuid];
      unsigned int v116 = [v114 isEqualToString:v115];

      if (v116)
      {
        long long v117 = [v113 keyclass];
        if (![v117 isEqualToString:@"classA"]) {
          goto LABEL_93;
        }
        id v118 = [v321 currentClassAPointer];
        long long v119 = [v118 currentKeyUUID];
        if (v119)
        {
          long long v120 = [v321 classA];
          long long v121 = [v120 parentKeyUUID];
          uint64_t v122 = [v92 uuid];
          if ([v121 isEqualToString:v122])
          {
            long long v123 = [v321 classA];
            BOOL v295 = v123 == 0;

            if (v295)
            {
LABEL_92:
              [v321 setClassA:v113];
              long long v117 = [v113 uuid];
              id v124 = [v321 currentClassAPointer];
              [v124 setCurrentKeyUUID:v117];

              char v300 = 1;
LABEL_93:
            }
            id v125 = [v113 keyclass];
            if (![v125 isEqualToString:@"classC"]) {
              goto LABEL_102;
            }
            id v126 = [v321 currentClassCPointer];
            id v127 = [v126 currentKeyUUID];
            if (v127)
            {
              uint64_t v128 = [v321 classC];
              id v129 = [v128 parentKeyUUID];
              char v130 = [v92 uuid];
              if ([v129 isEqualToString:v130])
              {
                uint64_t v131 = [v321 classC];
                BOOL v296 = v131 == 0;

                if (!v296) {
                  continue;
                }
LABEL_101:
                [v321 setClassC:v113];
                id v125 = [v113 uuid];
                uint64_t v132 = [v321 currentClassCPointer];
                [v132 setCurrentKeyUUID:v125];

                char v298 = 1;
LABEL_102:

                continue;
              }
            }
            goto LABEL_101;
          }
        }
        goto LABEL_92;
      }
    }
    toa = (id *)[v305 countByEnumeratingWithState:&v362 objects:v391 count:16];
  }
  while (toa);
LABEL_152:

  uint64_t v190 = [v321 currentClassAPointer];
  id v191 = [v190 currentKeyUUID];
  BOOL v192 = v191 == 0;

  if (!v192)
  {
    v297 = 0;
    goto LABEL_154;
  }
  id v361 = v81;
  v297 = +[CKKSKey randomKeyWrappedByParent:v92 keyclass:@"classA" error:&v361];
  id v218 = v361;

  id v360 = v218;
  [v297 saveKeyMaterialToKeychain:&v360];
  id v81 = v360;

  if (v81)
  {
    id v219 = [*(id *)(a1 + 40) deps];
    long long v220 = [v219 lockStateTracker];
    unsigned int v221 = [v220 isLockedError:v81];

    long long v222 = [*(id *)(a1 + 32) zoneID];
    id v223 = [v222 zoneName];
    id v224 = sub_1000CD884(@"ckksheal", v223);

    if (v221)
    {
      if (os_log_type_enabled(v224, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v224, OS_LOG_TYPE_DEFAULT, "Couldn't create a new class A key, but keybag appears to be locked. Entering waitforunlock.", buf, 2u);
      }

      [*(id *)(a1 + 32) setViewKeyHierarchyState:@"waitforunlock"];
      uint64_t v389 = kSecurityRTCFieldIsLocked;
      v390 = &__kCFBooleanTrue;
      long long v225 = +[NSDictionary dictionaryWithObjects:&v390 forKeys:&v389 count:1];
      [v313 addMetrics:v225];

      +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v313 success:0 error:v81];
    }
    else
    {
      if (os_log_type_enabled(v224, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v81;
        _os_log_impl((void *)&_mh_execute_header, v224, OS_LOG_TYPE_ERROR, "couldn't create new classA key: %@", buf, 0xCu);
      }

      [*(id *)(a1 + 32) setViewKeyHierarchyState:@"error"];
      +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v313 success:0 error:v81];
    }
    goto LABEL_113;
  }
  [v321 setClassA:v297];
  v287 = [v297 uuid];
  v288 = [v321 currentClassAPointer];
  [v288 setCurrentKeyUUID:v287];

  id v81 = 0;
  char v300 = 1;
LABEL_154:
  char v193 = [v321 currentClassCPointer];
  v194 = [v193 currentKeyUUID];
  BOOL v195 = v194 == 0;

  if (v195)
  {
    id v359 = v81;
    v294 = +[CKKSKey randomKeyWrappedByParent:v92 keyclass:@"classC" error:&v359];
    id v226 = v359;

    id v358 = v226;
    [v294 saveKeyMaterialToKeychain:&v358];
    id v81 = v358;

    if (v81)
    {
      long long v227 = [*(id *)(a1 + 40) deps];
      uint64_t v228 = [v227 lockStateTracker];
      unsigned int v229 = [v228 isLockedError:v81];

      id v230 = [*(id *)(a1 + 32) zoneID];
      id v231 = [v230 zoneName];
      id v232 = sub_1000CD884(@"ckksheal", v231);

      if (v229)
      {
        if (os_log_type_enabled(v232, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v232, OS_LOG_TYPE_DEFAULT, "Couldn't create a new class C key, but keybag appears to be locked. Entering waitforunlock.", buf, 2u);
        }

        uint64_t v387 = kSecurityRTCFieldIsLocked;
        v388 = &__kCFBooleanTrue;
        v233 = +[NSDictionary dictionaryWithObjects:&v388 forKeys:&v387 count:1];
        [v313 addMetrics:v233];

        +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v313 success:0 error:v81];
        [*(id *)(a1 + 32) setViewKeyHierarchyState:@"waitforunlock"];
      }
      else
      {
        if (os_log_type_enabled(v232, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = v81;
          _os_log_impl((void *)&_mh_execute_header, v232, OS_LOG_TYPE_ERROR, "couldn't create new class C key: %@", buf, 0xCu);
        }

        [*(id *)(a1 + 32) setViewKeyHierarchyState:@"error"];
        +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v313 success:0 error:v81];
      }
      goto LABEL_113;
    }
    [v321 setClassC:v294];
    v289 = [v294 uuid];
    v290 = [v321 currentClassCPointer];
    [v290 setCurrentKeyUUID:v289];

    id v81 = 0;
    char v298 = 1;
  }
  else
  {
    v294 = 0;
  }
  id v196 = [*(id *)(a1 + 32) zoneID];
  uint64_t v197 = [v196 zoneName];
  v198 = sub_1000CD884(@"ckksheal", v197);

  if (os_log_type_enabled(v198, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    *(void *)&uint8_t buf[4] = v321;
    _os_log_impl((void *)&_mh_execute_header, v198, OS_LOG_TYPE_DEFAULT, "Attempting to move to new key hierarchy: %@", buf, 0xCu);
  }

  if (v297)
  {
    v199 = [*(id *)(a1 + 32) zoneID];
    id v200 = [v297 CKRecordWithZoneID:v199];
    [v308 addObject:v200];
  }
  if (v294)
  {
    v201 = [*(id *)(a1 + 32) zoneID];
    id v202 = [v294 CKRecordWithZoneID:v201];
    [v308 addObject:v202];
  }
  if ((v293 & 1) == 0)
  {
    id v203 = [v321 currentTLKPointer];
    id v204 = [*(id *)(a1 + 32) zoneID];
    id v205 = [v203 CKRecordWithZoneID:v204];
    [v308 addObject:v205];
  }
  if (v300)
  {
    long long v206 = [v321 currentClassAPointer];
    long long v207 = [*(id *)(a1 + 32) zoneID];
    long long v208 = [v206 CKRecordWithZoneID:v207];
    [v308 addObject:v208];
  }
  if (v298)
  {
    long long v209 = [v321 currentClassCPointer];
    id v210 = [*(id *)(a1 + 32) zoneID];
    uint64_t v211 = [v209 CKRecordWithZoneID:v210];
    [v308 addObject:v211];
  }
  uint64_t v212 = *(void *)(a1 + 56);
  id v357 = v81;
  v291 = +[CKKSHealTLKSharesOperation createMissingKeyShares:v321 trustStates:v212 databaseProvider:0 error:&v357];
  id v292 = v357;

  uint64_t v385 = kSecurityRTCFieldNewTLKShares;
  id v213 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [v291 count]);
  v386 = v213;
  char v214 = +[NSDictionary dictionaryWithObjects:&v386 forKeys:&v385 count:1];
  [v313 addMetrics:v214];

  if (v292)
  {
    long long v215 = [*(id *)(a1 + 32) zoneID];
    id v216 = [v215 zoneName];
    id v217 = sub_1000CD884(@"ckksshare", v216);

    if (os_log_type_enabled(v217, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v292;
      _os_log_impl((void *)&_mh_execute_header, v217, OS_LOG_TYPE_ERROR, "Unable to create TLK shares for new tlk: %@", buf, 0xCu);
    }

    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v313 success:0 error:v292];
    uint64_t v82 = 0;
  }
  else
  {
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v313 success:1 error:0];
    long long v355 = 0u;
    long long v356 = 0u;
    long long v353 = 0u;
    long long v354 = 0u;
    id v234 = v291;
    id v235 = [v234 countByEnumeratingWithState:&v353 objects:v384 count:16];
    if (v235)
    {
      uint64_t v236 = *(void *)v354;
      do
      {
        for (j = 0; j != v235; j = (char *)j + 1)
        {
          if (*(void *)v354 != v236) {
            objc_enumerationMutation(v234);
          }
          id v238 = *(void **)(*((void *)&v353 + 1) + 8 * (void)j);
          id v239 = [*(id *)(a1 + 32) zoneID];
          id v240 = [v238 CKRecordWithZoneID:v239];

          [v308 addObject:v240];
        }
        id v235 = [v234 countByEnumeratingWithState:&v353 objects:v384 count:16];
      }
      while (v235);
    }

    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&uint8_t buf[16] = 0x2020000000;
    char v383 = 1;
    id v241 = objc_alloc((Class)AAFAnalyticsEventSecurity);
    v380[0] = kSecurityRTCFieldTotalCKRecords;
    v242 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [v308 count]);
    uint64_t v243 = kSecurityRTCFieldIsPrioritized;
    v380[1] = kSecurityRTCFieldIsPrioritized;
    v381[0] = v242;
    v381[1] = &__kCFBooleanFalse;
    id v244 = +[NSDictionary dictionaryWithObjects:v381 forKeys:v380 count:2];
    BOOL v245 = [*(id *)(a1 + 40) deps];
    v246 = [v245 activeAccount];
    v247 = [v246 altDSID];
    int v248 = [*(id *)(a1 + 40) deps];
    id v249 = [v248 sendMetric];
    id v303 = [v241 initWithCKKSMetrics:v244 altDSID:v247 eventName:kSecurityRTCEventNameUploadHealedTLKShares testsAreEnabled:0 category:v302 sendMetric:v249];

    uint64_t v378 = v243;
    v379 = &__kCFBooleanTrue;
    long long v250 = +[NSDictionary dictionaryWithObjects:&v379 forKeys:&v378 count:1];
    [v303 addMetrics:v250];

    long long v251 = [*(id *)(a1 + 32) zoneID];
    long long v252 = [v251 zoneName];
    long long v253 = sub_1000CD884(@"ckksheal", v252);

    if (os_log_type_enabled(v253, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v376 = 138412290;
      id v377 = v308;
      _os_log_impl((void *)&_mh_execute_header, v253, OS_LOG_TYPE_DEFAULT, "Saving new records %@", v376, 0xCu);
    }

    for (k = 0; ; k = v306 + 1)
    {
      uint64_t v255 = 1000 * (void)k;
      if (1000 * (uint64_t)k >= (unint64_t)[v308 count]) {
        break;
      }
      v306 = k;
      long long v256 = [*(id *)(a1 + 32) zoneName];
      id v257 = +[NSString stringWithFormat:@"heal-cloudkit-modify-operation-finished-%@", v256];
      v346[0] = _NSConcreteStackBlock;
      v346[1] = 3221225472;
      v346[2] = sub_10009500C;
      v346[3] = &unk_1003057C0;
      id v258 = v308;
      id v347 = v258;
      uint64_t v352 = v255;
      id v311 = v303;
      id v348 = v311;
      v350 = buf;
      id v259 = *(id *)(a1 + 48);
      uint64_t v260 = *(void *)(a1 + 64);
      id v349 = v259;
      uint64_t v351 = v260;
      long long v261 = +[NSBlockOperation named:v257 withBlock:v346];

      [*(id *)(a1 + 40) dependOnBeforeGroupFinished:v261];
      id v262 = objc_alloc_init((Class)NSMutableDictionary);
      id v263 = (char *)[v258 count];
      if ((unint64_t)&v263[-v255] >= 0x3E8) {
        uint64_t v264 = 1000;
      }
      else {
        uint64_t v264 = (uint64_t)&v263[-v255];
      }
      id v265 = [v258 subarrayWithRange:v255, v264];
      long long v344 = 0u;
      long long v345 = 0u;
      long long v342 = 0u;
      long long v343 = 0u;
      id v266 = v265;
      id v267 = [v266 countByEnumeratingWithState:&v342 objects:v375 count:16];
      if (v267)
      {
        uint64_t v268 = *(void *)v343;
        do
        {
          for (m = 0; m != v267; m = (char *)m + 1)
          {
            if (*(void *)v343 != v268) {
              objc_enumerationMutation(v266);
            }
            long long v270 = *(void **)(*((void *)&v342 + 1) + 8 * (void)m);
            long long v271 = [v270 recordID];
            [v262 setObject:v270 forKeyedSubscript:v271];
          }
          id v267 = [v266 countByEnumeratingWithState:&v342 objects:v375 count:16];
        }
        while (v267);
      }

      id v272 = [objc_alloc((Class)CKModifyRecordsOperation) initWithRecordsToSave:v266 recordIDsToDelete:0];
      [v272 setAtomic:1];
      [v272 setLongLived:0];
      long long v273 = [v272 configuration];
      [v273 setIsCloudKitSupportOperation:1];

      [v272 setQualityOfService:25];
      id v274 = [*(id *)(a1 + 40) deps];
      id v275 = [v274 ckoperationGroup];
      [v272 setGroup:v275];

      id v276 = [*(id *)(a1 + 32) zoneID];
      v277 = [v276 zoneName];
      v278 = sub_1000CD884(@"ckksheal", v277);

      if (os_log_type_enabled(v278, OS_LOG_TYPE_DEFAULT))
      {
        v279 = [*(id *)(a1 + 40) deps];
        v280 = [v279 ckoperationGroup];
        *(_DWORD *)v376 = 138412290;
        id v377 = v280;
        _os_log_impl((void *)&_mh_execute_header, v278, OS_LOG_TYPE_DEFAULT, "Operation group is %@", v376, 0xCu);
      }
      v338[0] = _NSConcreteStackBlock;
      v338[1] = 3221225472;
      v338[2] = sub_100095098;
      v338[3] = &unk_1002F8AC8;
      id v339 = *(id *)(a1 + 32);
      v340 = buf;
      uint64_t v341 = *(void *)(a1 + 64);
      [v272 setPerRecordSaveBlock:v338];
      v324[0] = _NSConcreteStackBlock;
      v324[1] = 3221225472;
      v324[2] = sub_10009525C;
      v324[3] = &unk_1002F8B18;
      objc_copyWeak(&v337, (id *)(a1 + 80));
      id v325 = *(id *)(a1 + 32);
      id v326 = v92;
      id v327 = v297;
      id v328 = v294;
      id v329 = v321;
      id v330 = v234;
      id v281 = v313;
      uint64_t v282 = *(void *)(a1 + 64);
      id v331 = v281;
      uint64_t v335 = v282;
      v336 = buf;
      id v332 = v311;
      id v283 = v262;
      id v333 = v283;
      id v284 = v261;
      id v334 = v284;
      [v272 setModifyRecordsCompletionBlock:v324];
      v285 = [*(id *)(a1 + 40) setResultStateOperation];
      [v285 addDependency:v284];

      __int16 v286 = [*(id *)(a1 + 40) ckOperations];
      [v272 linearDependencies:v286];

      [*(id *)(*(void *)(*(void *)(a1 + 72) + 8) + 40) addObject:v272];
      objc_destroyWeak(&v337);
    }
    _Block_object_dispose(buf, 8);
    uint64_t v82 = 1;
  }

  id v81 = v292;
LABEL_114:

LABEL_115:
  return v82;
}

void sub_100094F9C(_Unwind_Exception *a1)
{
}

char *sub_10009500C(uint64_t a1)
{
  uint64_t result = (char *)[*(id *)(a1 + 32) count];
  if ((unint64_t)&result[-*(void *)(a1 + 72)] <= 0x3E8)
  {
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:*(void *)(a1 + 40) success:*(unsigned __int8 *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) error:0];
    uint64_t v3 = *(void *)(a1 + 48);
    uint64_t v4 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
    return (char *)+[SecurityAnalyticsReporterRTC sendMetricWithEvent:v3 success:v4 error:0];
  }
  return result;
}

void sub_100095098(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6 = a2;
  id v7 = a4;
  if (v7)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
    uint64_t v8 = [*(id *)(a1 + 32) zoneID];
    id v9 = [v8 zoneName];
    id v10 = sub_1000CD884(@"ckksheal", v9);

    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      int v14 = 138412546;
      id v15 = v7;
      __int16 v16 = 2112;
      id v17 = v6;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "error on row: %@ %@", (uint8_t *)&v14, 0x16u);
    }
  }
  else
  {
    id v11 = [*(id *)(a1 + 32) zoneID];
    id v12 = [v11 zoneName];
    id v10 = sub_1000CD884(@"ckksheal", v12);

    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = [v6 recordName];
      int v14 = 138412290;
      id v15 = v13;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Successfully completed upload for %@", (uint8_t *)&v14, 0xCu);
    }
  }
}

void sub_10009525C(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6 = a2;
  id v7 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 128));
  id v9 = [*(id *)(a1 + 32) zoneID];
  id v10 = [v9 zoneName];
  id v11 = sub_1000CD884(@"ckksheal", v10);

  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    id v35 = v7;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Completed Key Heal CloudKit operation with error: %@", buf, 0xCu);
  }

  id v12 = [WeakRetained deps];
  uint64_t v13 = [v12 databaseProvider];
  id v17 = _NSConcreteStackBlock;
  uint64_t v18 = 3221225472;
  uint64_t v19 = sub_1000954E8;
  id v20 = &unk_1002F8AF0;
  id v21 = v7;
  id v22 = *(id *)(a1 + 32);
  id v23 = v6;
  id v24 = *(id *)(a1 + 40);
  id v25 = *(id *)(a1 + 48);
  id v26 = *(id *)(a1 + 56);
  id v27 = *(id *)(a1 + 64);
  id v28 = *(id *)(a1 + 72);
  id v29 = *(id *)(a1 + 80);
  id v30 = WeakRetained;
  long long v33 = *(_OWORD *)(a1 + 112);
  id v31 = *(id *)(a1 + 88);
  id v32 = *(id *)(a1 + 96);
  id v14 = v6;
  id v15 = v7;
  [v13 dispatchSyncWithSQLTransaction:&v17];

  __int16 v16 = [WeakRetained operationQueue:v17, v18, v19, v20];
  [v16 addOperation:*(void *)(a1 + 104)];
}

uint64_t sub_1000954E8(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v3 = +[CKKSAnalytics logger];
  if (v2)
  {
    uint64_t v4 = *(void *)(a1 + 32);
    CFStringRef v5 = [*(id *)(a1 + 40) zoneID];
    id v6 = [v5 zoneName];
    [v3 logUnrecoverableError:v4 forEvent:@"CKKSEventProcessHealKeyHierarchy" zoneName:v6 withAttributes:0];

    id v7 = [*(id *)(a1 + 40) zoneID];
    uint64_t v8 = [v7 zoneName];
    id v9 = sub_1000CD884(@"ckksheal", v8);

    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      id v10 = *(void **)(a1 + 32);
      *(_DWORD *)long long buf = 138412290;
      id v75 = v10;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "couldn't save new key hierarchy to CloudKit: %@", buf, 0xCu);
    }

    *(unsigned char *)(*(void *)(*(void *)(a1 + 136) + 8) + 24) = 0;
    [*(id *)(a1 + 112) populateUnderlyingErrorsStartingWithRootError:*(void *)(a1 + 32)];
    *(unsigned char *)(*(void *)(*(void *)(a1 + 128) + 8) + 24) = 0;
    id v11 = [*(id *)(a1 + 104) deps];
    [v11 intransactionCKWriteFailed:*(void *)(a1 + 32) attemptedRecordsChanged:*(void *)(a1 + 120)];

    id v12 = *(void **)(a1 + 104);
    uint64_t v13 = 1;
    [v12 setCloudkitWriteFailures:1];
    return v13;
  }
  id v14 = [*(id *)(a1 + 40) zoneID];
  id v15 = [v14 zoneName];
  [v3 logSuccessForEvent:@"CKKSEventProcessHealKeyHierarchy" zoneName:v15];

  long long v72 = 0u;
  long long v73 = 0u;
  long long v71 = 0u;
  long long v70 = 0u;
  id v16 = *(id *)(a1 + 48);
  id v17 = [v16 countByEnumeratingWithState:&v70 objects:v77 count:16];
  if (!v17) {
    goto LABEL_27;
  }
  id v18 = v17;
  uint64_t v19 = *(void *)v71;
  do
  {
    id v20 = 0;
    do
    {
      if (*(void *)v71 != v19) {
        objc_enumerationMutation(v16);
      }
      uint64_t v21 = *(void *)(*((void *)&v70 + 1) + 8 * (void)v20);
      if ([*(id *)(a1 + 56) matchesCKRecord:v21])
      {
        id v22 = *(void **)(a1 + 56);
LABEL_16:
        [v22 setStoredCKRecord:v21];
        goto LABEL_17;
      }
      if ([*(id *)(a1 + 64) matchesCKRecord:v21])
      {
        id v22 = *(void **)(a1 + 64);
        goto LABEL_16;
      }
      if ([*(id *)(a1 + 72) matchesCKRecord:v21])
      {
        id v22 = *(void **)(a1 + 72);
        goto LABEL_16;
      }
      id v23 = [*(id *)(a1 + 80) currentTLKPointer];
      unsigned int v24 = [v23 matchesCKRecord:v21];

      id v25 = *(void **)(a1 + 80);
      if (v24)
      {
        id v26 = [v25 currentTLKPointer];
      }
      else
      {
        id v27 = [v25 currentClassAPointer];
        unsigned int v28 = [v27 matchesCKRecord:v21];

        id v29 = *(void **)(a1 + 80);
        if (v28)
        {
          id v26 = [v29 currentClassAPointer];
        }
        else
        {
          id v30 = [v29 currentClassCPointer];
          unsigned int v31 = [v30 matchesCKRecord:v21];

          if (!v31) {
            goto LABEL_17;
          }
          id v26 = [*(id *)(a1 + 80) currentClassCPointer];
        }
      }
      id v32 = v26;
      [v26 setStoredCKRecord:v21];

LABEL_17:
      id v20 = (char *)v20 + 1;
    }
    while (v18 != v20);
    id v33 = [v16 countByEnumeratingWithState:&v70 objects:v77 count:16];
    id v18 = v33;
  }
  while (v33);
LABEL_27:

  BOOL v34 = *(void **)(a1 + 56);
  id v69 = 0;
  [v34 saveToDatabaseAsOnlyCurrentKeyForClassAndState:&v69];
  id v35 = v69;
  id v36 = *(void **)(a1 + 64);
  id v68 = v35;
  [v36 saveToDatabaseAsOnlyCurrentKeyForClassAndState:&v68];
  id v37 = v68;

  id v38 = *(void **)(a1 + 72);
  id v67 = v37;
  [v38 saveToDatabaseAsOnlyCurrentKeyForClassAndState:&v67];
  id v39 = v67;

  id v40 = [*(id *)(a1 + 80) currentTLKPointer];
  id v66 = v39;
  [v40 saveToDatabase:&v66];
  id v41 = v66;

  uint64_t v42 = [*(id *)(a1 + 80) currentClassAPointer];
  id v65 = v41;
  [v42 saveToDatabase:&v65];
  id v43 = v65;

  id v44 = [*(id *)(a1 + 80) currentClassCPointer];
  id v64 = v43;
  [v44 saveToDatabase:&v64];
  id v45 = v64;

  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  id v46 = *(id *)(a1 + 88);
  id v47 = [v46 countByEnumeratingWithState:&v60 objects:v76 count:16];
  if (v47)
  {
    id v48 = v47;
    uint64_t v49 = *(void *)v61;
    do
    {
      id v50 = 0;
      id v51 = v45;
      do
      {
        if (*(void *)v61 != v49) {
          objc_enumerationMutation(v46);
        }
        BOOL v52 = *(void **)(*((void *)&v60 + 1) + 8 * (void)v50);
        id v59 = v51;
        [v52 saveToDatabase:&v59];
        id v45 = v59;

        id v50 = (char *)v50 + 1;
        id v51 = v45;
      }
      while (v48 != v50);
      id v48 = [v46 countByEnumeratingWithState:&v60 objects:v76 count:16];
    }
    while (v48);
  }

  uint64_t v53 = *(void **)(a1 + 40);
  if (v45)
  {
    id v54 = [v53 zoneID];
    uint64_t v55 = [v54 zoneName];
    unsigned int v56 = sub_1000CD884(@"ckksheal", v55);

    if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      id v75 = v45;
      _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "couldn't save new key hierarchy to database; this is very bad: %@",
        buf,
        0xCu);
    }

    [*(id *)(a1 + 96) populateUnderlyingErrorsStartingWithRootError:v45];
    [*(id *)(a1 + 40) setViewKeyHierarchyState:@"error"];
    *(unsigned char *)(*(void *)(*(void *)(a1 + 128) + 8) + 24) = 0;

    return 0;
  }
  else
  {
    [v53 setViewKeyHierarchyState:@"process_key_hierarchy"];
    id v57 = *(void **)(a1 + 104);
    uint64_t v13 = 1;
    [v57 setNewCloudKitRecordsWritten:1];
  }
  return v13;
}

void sub_100095DAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id *location, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,id a28)
{
}

void sub_100095DE4(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if ([WeakRetained cloudkitWriteFailures])
  {
    uint64_t v2 = sub_1000CD884(@"ckksheal", 0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Due to write failures, we'll try to fetch the current state", buf, 2u);
    }

    CFStringRef v3 = @"begin_fetch";
  }
  else
  {
    if (![WeakRetained newCloudKitRecordsWritten])
    {
      CFStringRef v5 = [WeakRetained intendedState];
      [WeakRetained setNextState:v5];

      goto LABEL_11;
    }
    uint64_t v4 = sub_1000CD884(@"ckksheal", 0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v6 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Some records were written! Process them", v6, 2u);
    }

    CFStringRef v3 = @"process_key_hierarchy";
  }
  [WeakRetained setNextState:v3];
LABEL_11:
}

void sub_100097830(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100097858(uint64_t a1, void *a2)
{
  id v3 = [a2 objectForKeyedSubscript:@"count(*)"];
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = [v3 asNSInteger];
}

void sub_10009B8A0(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 24));
  _Unwind_Resume(a1);
}

uint64_t sub_10009B8C4(id *a1)
{
  unsigned int v2 = [a1[4] isCancelled];
  id v3 = [a1[5] zoneName];
  uint64_t v4 = sub_1000CD884(@"ckksresync", v3);

  if (v2)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "CKKSSynchronizeOperation cancelled, quitting", buf, 2u);
    }
    uint64_t v5 = 0;
  }
  else
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      unsigned int v30 = [a1[4] restartCount];
      *(_DWORD *)long long buf = 67109120;
      unsigned int v37 = v30;
      _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Beginning local resynchronize (attempt %u)", buf, 8u);
    }

    uint64_t v31 = +[CKOperationGroup CKKSGroupWithName:@"ckks-resync-local"];
    id v6 = [CKKSOutgoingQueueOperation alloc];
    id v7 = [a1[5] operationDependencies];
    uint64_t v8 = [(CKKSOutgoingQueueOperation *)v6 initWithDependencies:v7 intending:@"ready" ckErrorState:@"process_outgoing_queue_failed" errorState:@"error"];

    id v9 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"resync-step%u-outgoing", 5 * [a1[4] restartCount] + 1);
    [(CKKSGroupOperation *)v8 setName:v9];

    [a1[4] runBeforeGroupFinished:v8];
    id v10 = [CKKSIncomingQueueOperation alloc];
    id v11 = [a1[5] operationDependencies];
    id v12 = [(CKKSIncomingQueueOperation *)v10 initWithDependencies:v11 intending:@"ready" pendingClassAItemsRemainingState:@"ready" errorState:@"unhealthy" handleMismatchedViewItems:0];

    uint64_t v13 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"resync-step%u-incoming", 5 * [a1[4] restartCount] + 2);
    [(CKKSIncomingQueueOperation *)v12 setName:v13];

    [(CKKSResultOperation *)v12 addSuccessDependency:v8];
    [a1[4] runBeforeGroupFinished:v12];
    id v14 = [CKKSReloadAllItemsOperation alloc];
    id v15 = [a1[5] operationDependencies];
    id v16 = [(CKKSReloadAllItemsOperation *)v14 initWithOperationDependencies:v15];

    id v17 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"resync-step%u-reload", 5 * [a1[4] restartCount] + 3);
    [(CKKSReloadAllItemsOperation *)v16 setName:v17];

    [a1[4] runBeforeGroupFinished:v16];
    id v18 = [CKKSIncomingQueueOperation alloc];
    uint64_t v19 = [a1[5] operationDependencies];
    id v20 = [(CKKSIncomingQueueOperation *)v18 initWithDependencies:v19 intending:@"ready" pendingClassAItemsRemainingState:@"ready" errorState:@"unhealthy" handleMismatchedViewItems:0];

    uint64_t v21 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"resync-step%u-incoming-again", 5 * [a1[4] restartCount] + 4);
    [(CKKSIncomingQueueOperation *)v20 setName:v21];

    [(CKKSResultOperation *)v20 addSuccessDependency:v16];
    [a1[4] runBeforeGroupFinished:v20];
    id v22 = [CKKSScanLocalItemsOperation alloc];
    id v23 = [a1[5] operationDependencies];
    unsigned int v24 = [(CKKSScanLocalItemsOperation *)v22 initWithDependencies:v23 intending:@"ready" errorState:@"error" ckoperationGroup:v31];

    id v25 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"resync-step%u-scan", 5 * [a1[4] restartCount] + 5);
    [(CKKSScanLocalItemsOperation *)v24 setName:v25];

    [(CKKSResultOperation *)v24 addSuccessDependency:v20];
    [a1[4] runBeforeGroupFinished:v24];
    id v26 = objc_alloc_init(CKKSResultOperation);
    id v27 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"resync-step%u-consider-restart", 5 * [a1[4] restartCount] + 6);
    [(CKKSResultOperation *)v26 setName:v27];

    v32[0] = _NSConcreteStackBlock;
    v32[1] = 3221225472;
    v32[2] = sub_10009BE70;
    v32[3] = &unk_1003077C8;
    objc_copyWeak(&v35, a1 + 6);
    id v33 = a1[5];
    unsigned int v28 = v24;
    BOOL v34 = v28;
    [(CKKSResultOperation *)v26 addExecutionBlock:v32];
    [(CKKSResultOperation *)v26 addSuccessDependency:v28];
    [a1[4] runBeforeGroupFinished:v26];

    objc_destroyWeak(&v35);
    uint64_t v5 = 1;
    uint64_t v4 = v31;
  }

  return v5;
}

void sub_10009BE50(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_10009BE70(id *a1)
{
  id WeakRetained = objc_loadWeakRetained(a1 + 6);
  if (WeakRetained)
  {
    id v3 = +[NSMutableSet set];
    long long v25 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    uint64_t v4 = [a1[4] operationDependencies];
    uint64_t v5 = [v4 activeManagedViews];

    id v6 = [v5 countByEnumeratingWithState:&v25 objects:v33 count:16];
    if (v6)
    {
      id v7 = v6;
      uint64_t v8 = *(void *)v26;
      do
      {
        for (uint64_t i = 0; i != v7; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v26 != v8) {
            objc_enumerationMutation(v5);
          }
          id v10 = [*(id *)(*((void *)&v25 + 1) + 8 * i) zoneID];
          [v3 addObject:v10];
        }
        id v7 = [v5 countByEnumeratingWithState:&v25 objects:v33 count:16];
      }
      while (v7);
    }

    id v11 = [a1[4] operationDependencies];
    id v12 = [v11 contextID];
    id v24 = 0;
    uint64_t v13 = +[CKKSSQLDatabaseObject allUUIDsWithContextID:v12 inZones:v3 error:&v24];
    id v14 = v24;

    if (v14)
    {
      id v15 = [a1[4] zoneName];
      id v16 = sub_1000CD884(@"ckksresync", v15);

      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        id v32 = v14;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Couldn't fetch IQEs: %@", buf, 0xCu);
      }
    }
    if ([a1[5] recordsFound] || objc_msgSend(v13, "count"))
    {
      if ((int)[WeakRetained restartCount] < 3)
      {
        [WeakRetained setRestartCount:[WeakRetained restartCount] + 1];
        id v22 = [a1[4] zoneName];
        id v23 = sub_1000CD884(@"ckksresync", v22);

        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "restarting synchronization operation due to new local items", buf, 2u);
        }

        [WeakRetained groupStart];
      }
      else
      {
        id v17 = [a1[4] zoneName];
        id v18 = sub_1000CD884(@"ckksresync", v17);

        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "restarted synchronization too often; Failing",
            buf,
            2u);
        }

        NSErrorUserInfoKey v29 = NSLocalizedDescriptionKey;
        CFStringRef v30 = @"resynchronization restarted too many times; churn in database?";
        uint64_t v19 = +[NSDictionary dictionaryWithObjects:&v30 forKeys:&v29 count:1];
        id v20 = +[NSError errorWithDomain:@"securityd" code:2 userInfo:v19];
        [WeakRetained setError:v20];
      }
    }
  }
  else
  {
    uint64_t v21 = [a1[4] zoneName];
    id v14 = sub_1000CD884(@"ckksresync", v21);

    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "received callback for released object", buf, 2u);
    }
  }
}

uint64_t sub_10009C458(uint64_t a1)
{
  unsigned int v2 = [*(id *)(a1 + 32) deps];
  id v3 = [v2 contextID];
  uint64_t v4 = [*(id *)(a1 + 40) zoneID];
  id v30 = 0;
  uint64_t v5 = +[CKKSSQLDatabaseObject allWithContextID:v3 zoneID:v4 error:&v30];
  id v6 = v30;

  if (v6)
  {
    id v7 = [*(id *)(a1 + 40) zoneID];
    uint64_t v8 = [v7 zoneName];
    id v9 = sub_1000CD884(@"ckksresync", v8);

    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      id v33 = v6;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Couldn't fetch mirror items: %@", buf, 0xCu);
    }

    [*(id *)(a1 + 32) setError:v6];
    uint64_t v10 = 0;
  }
  else
  {
    id v24 = 0;
    long long v25 = v5;
    long long v28 = 0u;
    long long v29 = 0u;
    long long v26 = 0u;
    long long v27 = 0u;
    id v11 = v5;
    id v12 = [v11 countByEnumeratingWithState:&v26 objects:v31 count:16];
    if (v12)
    {
      id v13 = v12;
      uint64_t v14 = *(void *)v27;
      do
      {
        for (uint64_t i = 0; i != v13; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v27 != v14) {
            objc_enumerationMutation(v11);
          }
          id v16 = *(void **)(*((void *)&v26 + 1) + 8 * i);
          id v17 = [v16 item:v24 :v25];
          id v18 = [*(id *)(a1 + 40) zoneID];
          uint64_t v19 = [v17 CKRecordWithZoneID:v18];

          if (v19)
          {
            id v20 = [*(id *)(a1 + 32) deps];
            [v20 intransactionCKRecordChanged:v19 resync:1];
          }
          else
          {
            uint64_t v21 = [*(id *)(a1 + 40) zoneID];
            id v22 = [v21 zoneName];
            id v20 = sub_1000CD884(@"ckksresync", v22);

            if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 138412290;
              id v33 = v16;
              _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "Couldn't make CKRecord for item: %@", buf, 0xCu);
            }
          }
        }
        id v13 = [v11 countByEnumeratingWithState:&v26 objects:v31 count:16];
      }
      while (v13);
    }

    uint64_t v10 = 1;
    id v6 = v24;
    uint64_t v5 = v25;
  }

  return v10;
}

void sub_10009D568(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,id *location)
{
  objc_destroyWeak((id *)(v21 - 200));
  _Unwind_Resume(a1);
}

uint64_t sub_10009D5C0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10009D5D0(uint64_t a1)
{
}

id sub_10009D5D8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [v3 parsedSecureElementIdentity];
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;

  [v3 setAttemptedJoin:2];

  return v3;
}

void sub_10009D63C(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8)
{
  id v15 = a2;
  id v16 = a3;
  id v17 = a4;
  id v18 = a5;
  id v45 = a6;
  id v19 = a7;
  id v20 = a8;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v22 = +[CKKSAnalytics logger];
  [v22 logResultForEvent:@"OctagonEventPrepareIdentity" hardFailure:1 result:v20];

  id v44 = v18;
  if (v20)
  {
    id v23 = sub_10000B070("SecError");
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v51 = v20;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "octagon: Error preparing identity: %@", buf, 0xCu);
    }

    [WeakRetained setError:v20];
    id v24 = [WeakRetained finishedOp];
    [WeakRetained runBeforeGroupFinished:v24];

    uint64_t v25 = *(void *)(a1 + 32);
    id v26 = [WeakRetained error];
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v25 success:0 error:v26];
  }
  else
  {
    long long v27 = sub_10000B070("octagon");
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412802;
      id v51 = v15;
      __int16 v52 = 2112;
      id v53 = v16;
      __int16 v54 = 2112;
      id v55 = v17;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Prepared: %@ %@ %@", buf, 0x20u);
    }

    [WeakRetained setPeerID:v15];
    id v43 = v16;
    [WeakRetained setPermanentInfo:v16];
    id v42 = v17;
    [WeakRetained setPermanentInfoSig:v17];
    [WeakRetained setStableInfo:v18];
    [WeakRetained setStableInfoSig:v45];
    long long v28 = sub_10000B070("octagon-ckks");
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      long long v29 = [v19 viewList];
      *(_DWORD *)long long buf = 138412546;
      id v51 = v19;
      __int16 v52 = 2112;
      id v53 = v29;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "New syncing policy: %@ views: %@", buf, 0x16u);
    }
    id v30 = [WeakRetained deps];
    uint64_t v31 = [v30 stateHolder];
    v47[0] = _NSConcreteStackBlock;
    v47[1] = 3221225472;
    v47[2] = sub_10009DB48;
    v47[3] = &unk_1002FAEE8;
    id v48 = v15;
    id v32 = v19;
    id v49 = v32;
    id v46 = 0;
    unsigned int v33 = [v31 persistAccountChanges:v47 error:&v46];
    id v26 = v46;

    if (!v33 || v26)
    {
      id v38 = sub_10000B070("octagon");
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v51 = v26;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "Couldn't persist metadata: %@", buf, 0xCu);
      }

      [WeakRetained setError:v26];
      id v39 = [WeakRetained finishedOp];
      [WeakRetained runBeforeGroupFinished:v39];

      uint64_t v40 = *(void *)(a1 + 32);
      id v41 = [WeakRetained error];
      +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v40 success:0 error:v41];
    }
    else
    {
      BOOL v34 = [WeakRetained deps];
      id v35 = [v34 ckks];
      [v35 setCurrentSyncingPolicy:v32];

      id v36 = [WeakRetained intendedState];
      [WeakRetained setNextState:v36];

      unsigned int v37 = [WeakRetained finishedOp];
      [WeakRetained runBeforeGroupFinished:v37];

      +[SecurityAnalyticsReporterRTC sendMetricWithEvent:*(void *)(a1 + 32) success:1 error:0];
    }

    id v17 = v42;
    id v16 = v43;
  }
}

id sub_10009DB48(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 setPeerID:*(void *)(a1 + 32)];
  [v3 setTPSyncingPolicy:*(void *)(a1 + 40)];

  return v3;
}

void sub_10009E088(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10009E0AC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v8 = [WeakRetained deps];
  id v9 = [v8 stateHolder];
  id v17 = 0;
  [v9 persistAccountChanges:&stru_1002F8C20 error:&v17];
  id v10 = v17;

  if (v10)
  {
    id v11 = v10;
  }
  else
  {
    if (!v6)
    {
      id v16 = [WeakRetained intendedState];
      [WeakRetained setNextState:v16];

      id v12 = [WeakRetained accountSettings];
      id v13 = v12;
      id v14 = v5;
      goto LABEL_6;
    }
    id v11 = v6;
  }
  [WeakRetained setError:v11];
  id v12 = [WeakRetained accountSettings];
  id v13 = v12;
  id v14 = 0;
LABEL_6:
  [v12 setAccountSettings:v14];

  id v15 = [WeakRetained finishedOp];
  [WeakRetained runBeforeGroupFinished:v15];
}

OTAccountMetadataClassC *__cdecl sub_10009E1E0(id a1, OTAccountMetadataClassC *a2)
{
  unsigned int v2 = a2;
  id v3 = [(OTAccountMetadataClassC *)v2 peerID];
  [(OTAccountMetadataClassC *)v2 setOldPeerID:v3];

  return v2;
}

void sub_10009E4EC(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    id v7 = sub_10000B070("octagon");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = a1[4];
      uint64_t v9 = a1[5];
      *(_DWORD *)long long buf = 138412802;
      uint64_t v23 = v8;
      __int16 v24 = 2112;
      uint64_t v25 = v9;
      __int16 v26 = 2112;
      id v27 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Unable to fetch account settings for (%@,%@): %@", buf, 0x20u);
    }

    (*(void (**)(void))(a1[6] + 16))();
  }
  else if (v5 && [v5 count])
  {
    id v10 = objc_alloc_init((Class)OTAccountSettings);
    id v11 = objc_alloc_init((Class)OTWalrus);
    id v12 = [v5 objectForKeyedSubscript:@"walrus"];

    if (v12)
    {
      id v13 = [v5 objectForKeyedSubscript:@"walrus"];
      [v11 setEnabled:[v13 value]];
    }
    [v10 setWalrus:v11];
    id v14 = objc_alloc_init((Class)OTWebAccess);
    id v15 = [v5 objectForKeyedSubscript:@"webAccess"];

    if (v15)
    {
      id v16 = [v5 objectForKeyedSubscript:@"webAccess"];
      [v14 setEnabled:[v16 value]];
    }
    [v10 setWebAccess:v14];
    (*(void (**)(void))(a1[6] + 16))();
  }
  else
  {
    uint64_t v17 = a1[6];
    NSErrorUserInfoKey v20 = NSLocalizedDescriptionKey;
    CFStringRef v21 = @"No account settings have been set";
    id v18 = +[NSDictionary dictionaryWithObjects:&v21 forKeys:&v20 count:1];
    id v19 = +[NSError errorWithDomain:@"com.apple.security.octagon" code:53 userInfo:v18];
    (*(void (**)(uint64_t, void, void *))(v17 + 16))(v17, 0, v19);
  }
}

void sub_10009E7A0(void *a1, void *a2, uint64_t a3, void *a4)
{
  id v6 = a2;
  id v7 = a4;
  if (v7)
  {
    uint64_t v8 = sub_10000B070("octagon");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = a1[4];
      uint64_t v10 = a1[5];
      int v18 = 138412802;
      uint64_t v19 = v9;
      __int16 v20 = 2112;
      uint64_t v21 = v10;
      __int16 v22 = 2112;
      id v23 = v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Unable to fetch account settings for (%@,%@): %@", (uint8_t *)&v18, 0x20u);
    }

    (*(void (**)(void))(a1[6] + 16))();
  }
  else
  {
    id v11 = objc_alloc_init((Class)OTAccountSettings);
    id v12 = objc_alloc_init((Class)OTWalrus);
    id v13 = [v6 walrus];
    if (v13)
    {
      id v14 = [v6 walrus];
      [v12 setEnabled:[v14 value]];
    }
    else
    {
      [v12 setEnabled:0];
    }

    [v11 setWalrus:v12];
    id v15 = objc_alloc_init((Class)OTWebAccess);
    id v16 = [v6 webAccess];
    if (v16)
    {
      uint64_t v17 = [v6 webAccess];
      [v15 setEnabled:[v17 value]];
    }
    else
    {
      [v15 setEnabled:1];
    }

    [v11 setWebAccess:v15];
    (*(void (**)(void))(a1[6] + 16))();
  }
}

void sub_10009F088(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10009F0A0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10009F0B0(uint64_t a1)
{
}

void sub_10009F0B8(uint64_t a1)
{
  v30[0] = kSecClass;
  v30[1] = kSecAttrAccessible;
  v31[0] = kSecClassInternetPassword;
  v31[1] = kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly;
  v30[2] = kSecUseDataProtectionKeychain;
  void v30[3] = kSecAttrAccessGroup;
  v31[2] = &__kCFBooleanTrue;
  v31[3] = @"com.apple.security.octagon";
  v30[4] = kSecAttrDescription;
  unsigned int v2 = +[NSString stringWithFormat:@"Octagon Account State (%@,%@)", *(void *)(a1 + 32), *(void *)(a1 + 40)];
  v31[4] = v2;
  v30[5] = kSecAttrServer;
  id v3 = +[NSString stringWithFormat:@"octagon-%@", *(void *)(a1 + 32)];
  v31[5] = v3;
  v30[6] = kSecAttrAccount;
  uint64_t v4 = +[NSString stringWithFormat:@"octagon-%@", *(void *)(a1 + 32)];
  v31[6] = v4;
  v30[7] = kSecAttrPath;
  id v5 = +[NSString stringWithFormat:@"octagon-%@", *(void *)(a1 + 40)];
  v31[7] = v5;
  v31[8] = &__kCFBooleanTrue;
  v30[8] = kSecAttrIsInvisible;
  v30[9] = kSecValueData;
  id v6 = [*(id *)(a1 + 48) data];
  v31[9] = v6;
  v31[10] = &__kCFBooleanFalse;
  v30[10] = kSecAttrSynchronizable;
  v30[11] = kSecAttrSysBound;
  v31[11] = &off_100325B88;
  id v7 = +[NSDictionary dictionaryWithObjects:v31 forKeys:v30 count:12];
  CFDictionaryRef v8 = (const __CFDictionary *)[v7 mutableCopy];

  CFTypeRef result = 0;
  uint64_t v9 = SecItemAdd(v8, &result);
  if (v9)
  {
    if (v9 == -25299)
    {
      id v10 = objc_alloc_init((Class)NSMutableDictionary);
      id v11 = [(__CFDictionary *)v8 objectForKeyedSubscript:kSecClass];
      [v10 setObject:v11 forKeyedSubscript:kSecClass];

      id v12 = [(__CFDictionary *)v8 objectForKeyedSubscript:kSecAttrSynchronizable];
      [v10 setObject:v12 forKeyedSubscript:kSecAttrSynchronizable];

      id v13 = [(__CFDictionary *)v8 objectForKeyedSubscript:kSecAttrSyncViewHint];
      [v10 setObject:v13 forKeyedSubscript:kSecAttrSyncViewHint];

      id v14 = [(__CFDictionary *)v8 objectForKeyedSubscript:kSecAttrAccessGroup];
      [v10 setObject:v14 forKeyedSubscript:kSecAttrAccessGroup];

      id v15 = [(__CFDictionary *)v8 objectForKeyedSubscript:kSecAttrAccount];
      [v10 setObject:v15 forKeyedSubscript:kSecAttrAccount];

      id v16 = [(__CFDictionary *)v8 objectForKeyedSubscript:kSecAttrServer];
      [v10 setObject:v16 forKeyedSubscript:kSecAttrServer];

      uint64_t v17 = [(__CFDictionary *)v8 objectForKeyedSubscript:kSecAttrPath];
      [v10 setObject:v17 forKeyedSubscript:kSecAttrPath];

      int v18 = [(__CFDictionary *)v8 objectForKeyedSubscript:kSecUseDataProtectionKeychain];
      [v10 setObject:v18 forKeyedSubscript:kSecUseDataProtectionKeychain];

      id v19 = [(__CFDictionary *)v8 mutableCopy];
      [v19 setObject:0 forKeyedSubscript:kSecClass];
      uint64_t v20 = SecItemUpdate((CFDictionaryRef)v10, (CFDictionaryRef)v19);
      if (v20)
      {
        uint64_t v21 = (int)v20;
        __int16 v22 = +[NSString stringWithFormat:@"SecItemUpdate: %d", v20];
        uint64_t v23 = +[NSError errorWithDomain:NSOSStatusErrorDomain code:v21 description:v22];
        uint64_t v24 = *(void *)(*(void *)(a1 + 56) + 8);
        uint64_t v25 = *(void **)(v24 + 40);
        *(void *)(v24 + 40) = v23;
      }
    }
    else
    {
      uint64_t v26 = (int)v9;
      id v10 = +[NSString stringWithFormat:@"SecItemUpdate: %d", v9];
      uint64_t v27 = +[NSError errorWithDomain:NSOSStatusErrorDomain code:v26 description:v10];
      uint64_t v28 = *(void *)(*(void *)(a1 + 56) + 8);
      id v19 = *(id *)(v28 + 40);
      *(void *)(v28 + 40) = v27;
    }
  }
}

void sub_10009F7A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 112), 8);
  _Unwind_Resume(a1);
}

void sub_10009F7CC(void *a1)
{
  v48[0] = kSecClass;
  v48[1] = kSecUseDataProtectionKeychain;
  v49[0] = kSecClassInternetPassword;
  v49[1] = &__kCFBooleanTrue;
  v49[2] = @"com.apple.security.octagon";
  v48[2] = kSecAttrAccessGroup;
  v48[3] = kSecAttrServer;
  unsigned int v2 = +[NSString stringWithFormat:@"octagon-%@", a1[4]];
  v49[3] = v2;
  v48[4] = kSecAttrAccount;
  id v3 = +[NSString stringWithFormat:@"octagon-%@", a1[4]];
  v49[4] = v3;
  v48[5] = kSecAttrPath;
  uint64_t v4 = +[NSString stringWithFormat:@"octagon-%@", a1[5]];
  v49[5] = v4;
  v49[6] = &__kCFBooleanFalse;
  v48[6] = kSecAttrSynchronizable;
  v48[7] = kSecReturnAttributes;
  v48[8] = kSecReturnData;
  v49[7] = &__kCFBooleanTrue;
  v49[8] = &__kCFBooleanTrue;
  id v5 = +[NSDictionary dictionaryWithObjects:v49 forKeys:v48 count:9];
  CFDictionaryRef v6 = (const __CFDictionary *)[v5 mutableCopy];

  CFTypeRef result = 0;
  uint64_t v7 = SecItemCopyMatching(v6, &result);
  CFDictionaryRef v8 = (void *)result;
  if (v7)
  {
    uint64_t v9 = v7;
    if (result)
    {
      CFTypeRef result = 0;
      CFRelease(v8);
    }
    uint64_t v10 = (int)v9;
    NSErrorUserInfoKey v46 = NSLocalizedDescriptionKey;
    CFDictionaryRef v8 = +[NSString stringWithFormat:@"SecItemCopyMatching: %d", v9];
    id v47 = v8;
    uint64_t v11 = +[NSDictionary dictionaryWithObjects:&v47 forKeys:&v46 count:1];
    uint64_t v12 = +[NSError errorWithDomain:NSOSStatusErrorDomain code:v10 userInfo:v11];
    uint64_t v13 = *(void *)(a1[8] + 8);
    id v14 = *(void **)(v13 + 40);
    *(void *)(v13 + 40) = v12;

    goto LABEL_14;
  }
  id v15 = [OTAccountMetadataClassC alloc];
  id v16 = [v8 objectForKeyedSubscript:kSecValueData];
  uint64_t v17 = [(OTAccountMetadataClassC *)v15 initWithData:v16];
  uint64_t v18 = *(void *)(a1[9] + 8);
  id v19 = *(void **)(v18 + 40);
  *(void *)(v18 + 40) = v17;

  if (!*(void *)(*(void *)(a1[9] + 8) + 40))
  {
    uint64_t v31 = +[NSError errorWithDomain:@"com.apple.security.octagon" code:10 description:@"couldn't deserialize account state"];
    uint64_t v32 = *(void *)(a1[8] + 8);
    unsigned int v33 = *(void **)(v32 + 40);
    *(void *)(v32 + 40) = v31;

    uint64_t v34 = a1[4];
    uint64_t v35 = a1[5];
    uint64_t v36 = a1[6];
    uint64_t v37 = a1[7];
    id v42 = 0;
    unsigned int v38 = +[OTAccountMetadataClassC deleteFromKeychainForContainer:v34 contextID:v35 personaAdapter:v36 personaUniqueString:v37 error:&v42];
    id v39 = v42;
    uint64_t v11 = v39;
    if (!v38 || v39)
    {
      uint64_t v40 = sub_10000B070("octagon");
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v45 = v11;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "failed to reset account metadata in keychain, %@", buf, 0xCu);
      }
    }
    goto LABEL_14;
  }
  uint64_t v20 = [v8 objectForKeyedSubscript:kSecAttrSysBound];
  if (!v20
    || (uint64_t v21 = (void *)v20,
        [v8 objectForKeyedSubscript:kSecAttrAccessible],
        __int16 v22 = objc_claimAutoreleasedReturnValue(),
        unsigned __int8 v23 = [v22 isEqualToString:kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly],
        v22,
        v21,
        (v23 & 1) == 0))
  {
    uint64_t v24 = *(void **)(*(void *)(a1[9] + 8) + 40);
    uint64_t v25 = a1[4];
    uint64_t v26 = a1[5];
    uint64_t v27 = a1[6];
    uint64_t v28 = a1[7];
    uint64_t v29 = *(void *)(a1[8] + 8);
    id v41 = *(id *)(v29 + 40);
    [v24 saveToKeychainForContainer:v25 contextID:v26 personaAdapter:v27 personaUniqueString:v28 error:&v41];
    id v30 = v41;
    uint64_t v11 = *(void **)(v29 + 40);
    *(void *)(v29 + 40) = v30;
LABEL_14:
  }
}

void sub_10009FE1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va, a10);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10009FE3C(void *a1)
{
  v8[0] = kSecClassInternetPassword;
  v8[1] = &__kCFBooleanTrue;
  v8[2] = @"com.apple.security.octagon";
  unsigned int v2 = +[NSString stringWithFormat:@"octagon-%@", a1[4], kSecClass, kSecUseDataProtectionKeychain, kSecAttrAccessGroup, kSecAttrServer];
  v8[3] = v2;
  void v7[4] = kSecAttrAccount;
  id v3 = +[NSString stringWithFormat:@"octagon-%@", a1[4]];
  v8[4] = v3;
  void v7[5] = kSecAttrPath;
  uint64_t v4 = +[NSString stringWithFormat:@"octagon-%@", a1[5]];
  v7[6] = kSecAttrSynchronizable;
  v8[5] = v4;
  v8[6] = &__kCFBooleanFalse;
  id v5 = +[NSDictionary dictionaryWithObjects:v8 forKeys:v7 count:7];
  CFDictionaryRef v6 = (const __CFDictionary *)[v5 mutableCopy];

  *(_DWORD *)(*(void *)(a1[6] + 8) + 24) = SecItemDelete(v6);
}

OTAccountMetadataClassC *__cdecl sub_1000A2A18(id a1, OTAccountMetadataClassC *a2)
{
  unsigned int v2 = a2;
  [(OTAccountMetadataClassC *)v2 setCdpState:2];

  return v2;
}

void sub_1000A4484(id a1)
{
  uint64_t v2 = objc_opt_new();
  id v3 = (void *)qword_10035CDB0;
  qword_10035CDB0 = v2;

  id v4 = [objc_alloc((Class)NSXPCListener) initWithMachServiceName:@"com.apple.securityd.ckks"];
  id v5 = (void *)qword_10035CDB8;
  qword_10035CDB8 = (uint64_t)v4;

  [(id)qword_10035CDB8 setDelegate:qword_10035CDB0];
  [(id)qword_10035CDB8 resume];
}

void sub_1000A4ADC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,id location)
{
}

uint64_t sub_1000A4B24(uint64_t a1)
{
  uint64_t v2 = (id *)(a1 + 40);
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = [*(id *)(a1 + 40) deps];
  id v5 = [v4 accountStateTracker];
  CFDictionaryRef v6 = [*v2 deps];
  uint64_t v7 = [v6 lockStateTracker];
  id v46 = 0;
  CFDictionaryRef v8 = +[CKKSDeviceStateEntry intransactionCreateDeviceStateForView:v3 accountTracker:v5 lockStateTracker:v7 error:&v46];
  id v9 = v46;

  if (v9 || !v8)
  {
    uint64_t v21 = [*(id *)(a1 + 32) zoneID];
    __int16 v22 = [v21 zoneName];
    unsigned __int8 v23 = sub_1000CD884(@"ckksdevice", v22);

    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      id v51 = v9;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "Error creating device state entry; quitting: %@",
        buf,
        0xCu);
    }

    [*(id *)(a1 + 40) setError:v9];
    goto LABEL_15;
  }
  if ([*(id *)(a1 + 40) rateLimit])
  {
    uint64_t v10 = [v8 storedCKRecord];
    uint64_t v11 = [v10 modificationDate];

    id v41 = +[NSDate date];
    id v12 = objc_alloc_init((Class)NSDateComponents);
    if (SecIsInternalRelease()) {
      uint64_t v13 = -23;
    }
    else {
      uint64_t v13 = -72;
    }
    [v12 setHour:v13];
    id v14 = +[NSCalendar currentCalendar];
    id v15 = [v14 dateByAddingComponents:v12 toDate:v41 options:0];

    if (v11 && [v11 compare:v15] != (id)-1)
    {
      id v16 = [*(id *)(a1 + 32) zoneID];
      uint64_t v17 = [v16 zoneName];
      uint64_t v18 = sub_1000CD884(@"ckksdevice", v17);

      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v51 = v11;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Last update is within 3 days (%@); rate-limiting this operation",
          buf,
          0xCu);
      }

      NSErrorUserInfoKey v48 = NSLocalizedDescriptionKey;
      CFStringRef v49 = @"Rate-limited the CKKSUpdateDeviceStateOperation";
      id v19 = +[NSDictionary dictionaryWithObjects:&v49 forKeys:&v48 count:1];
      uint64_t v20 = +[NSError errorWithDomain:@"CKKSErrorDomain" code:60 userInfo:v19];
      [*(id *)(a1 + 40) setError:v20];

LABEL_15:
      uint64_t v24 = 0;
      goto LABEL_22;
    }
    uint64_t v25 = [*(id *)(a1 + 32) zoneID];
    uint64_t v26 = [v25 zoneName];
    uint64_t v27 = sub_1000CD884(@"ckksdevice", v26);

    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412546;
      id v51 = v11;
      __int16 v52 = 2112;
      id v53 = v15;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Not rate-limiting: last updated %@ vs %@", buf, 0x16u);
    }
  }
  uint64_t v28 = [*(id *)(a1 + 32) zoneID];
  uint64_t v29 = [v28 zoneName];
  id v30 = sub_1000CD884(@"ckksdevice", v29);

  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    id v51 = v8;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Saving new device state %@", buf, 0xCu);
  }

  uint64_t v31 = [*(id *)(a1 + 32) zoneID];
  uint64_t v32 = [v8 CKRecordWithZoneID:v31];
  id v47 = v32;
  unsigned int v33 = +[NSArray arrayWithObjects:&v47 count:1];

  id v34 = objc_alloc_init((Class)NSBlockOperation);
  [v34 setName:@"updateDeviceState-modifyRecordsComplete"];
  [*(id *)(a1 + 40) dependOnBeforeGroupFinished:v34];
  id v35 = [objc_alloc((Class)CKModifyRecordsOperation) initWithRecordsToSave:v33 recordIDsToDelete:0];
  [v35 setAtomic:1];
  [v35 setQualityOfService:17];
  [v35 setSavePolicy:2];
  uint64_t v36 = [*(id *)(a1 + 40) group];
  [v35 setGroup:v36];

  v45[0] = _NSConcreteStackBlock;
  v45[1] = 3221225472;
  v45[2] = sub_1000A51EC;
  v45[3] = &unk_1003069C0;
  v45[4] = *(void *)(a1 + 32);
  [v35 setPerRecordSaveBlock:v45];
  v42[0] = _NSConcreteStackBlock;
  v42[1] = 3221225472;
  v42[2] = sub_1000A5374;
  v42[3] = &unk_1002F8D00;
  objc_copyWeak(&v44, (id *)(a1 + 56));
  v42[4] = *(void *)(a1 + 32);
  id v37 = v34;
  id v43 = v37;
  [v35 setModifyRecordsCompletionBlock:v42];
  [v35 linearDependencies:*(void *)(a1 + 48)];
  [*(id *)(a1 + 40) dependOnBeforeGroupFinished:v35];
  unsigned int v38 = [*(id *)(a1 + 40) deps];
  id v39 = [v38 ckdatabase];
  [v39 addOperation:v35];

  objc_destroyWeak(&v44);
  uint64_t v24 = 1;
LABEL_22:

  return v24;
}

void sub_1000A51CC(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_1000A51EC(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  uint64_t v10 = [*(id *)(a1 + 32) zoneID];
  uint64_t v11 = [v10 zoneName];
  id v12 = sub_1000CD884(@"ckksdevice", v11);

  if (v9)
  {
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      int v14 = 138412546;
      id v15 = v9;
      __int16 v16 = 2112;
      id v17 = v7;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "error on row: %@ %@", (uint8_t *)&v14, 0x16u);
    }
  }
  else if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v13 = [v7 recordName];
    int v14 = 138412546;
    id v15 = v13;
    __int16 v16 = 2112;
    id v17 = v8;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Device state record upload successful for %@: %@", (uint8_t *)&v14, 0x16u);
  }
}

void sub_1000A5374(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v11 = WeakRetained;
  if (v9)
  {
    id v12 = [*(id *)(a1 + 32) zoneID];
    uint64_t v13 = [v12 zoneName];
    int v14 = sub_1000CD884(@"ckksdevice", v13);

    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v9;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "CloudKit returned an error: %@", (uint8_t *)&buf, 0xCu);
    }

    [v11 setError:v9];
    [v11 runBeforeGroupFinished:*(void *)(a1 + 40)];
  }
  else
  {
    *(void *)&long long buf = 0;
    *((void *)&buf + 1) = &buf;
    uint64_t v26 = 0x3032000000;
    uint64_t v27 = sub_1000A55DC;
    uint64_t v28 = sub_1000A55EC;
    id v29 = 0;
    id v15 = [WeakRetained deps];
    __int16 v16 = [v15 databaseProvider];
    id v17 = _NSConcreteStackBlock;
    uint64_t v18 = 3221225472;
    id v19 = sub_1000A55F4;
    uint64_t v20 = &unk_1003053D0;
    id v21 = v7;
    __int16 v22 = v11;
    uint64_t v23 = *(void *)(a1 + 32);
    p_long long buf = &buf;
    [v16 dispatchSyncWithSQLTransaction:&v17];

    [v11 setError:*(void *)(*((void *)&buf + 1) + 40), v17, v18, v19, v20];
    [v11 runBeforeGroupFinished:*(void *)(a1 + 40)];

    _Block_object_dispose(&buf, 8);
  }
}

void sub_1000A55BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000A55DC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1000A55EC(uint64_t a1)
{
}

uint64_t sub_1000A55F4(uint64_t a1)
{
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  id v2 = *(id *)(a1 + 32);
  id v3 = [v2 countByEnumeratingWithState:&v23 objects:v31 count:16];
  if (v3)
  {
    id v5 = v3;
    uint64_t v6 = *(void *)v24;
    *(void *)&long long v4 = 138412546;
    long long v21 = v4;
    do
    {
      for (uint64_t i = 0; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v24 != v6) {
          objc_enumerationMutation(v2);
        }
        id v8 = *(void **)(*((void *)&v23 + 1) + 8 * i);
        id v9 = [v8 recordType:v21];
        unsigned int v10 = [v9 isEqualToString:@"devicestate"];

        if (v10)
        {
          uint64_t v11 = [CKKSDeviceStateEntry alloc];
          id v12 = [*(id *)(a1 + 40) deps];
          uint64_t v13 = [v12 contextID];
          int v14 = [(CKKSCKRecordHolder *)v11 initWithCKRecord:v8 contextID:v13];

          uint64_t v15 = *(void *)(*(void *)(a1 + 56) + 8);
          id obj = *(id *)(v15 + 40);
          [(CKKSSQLDatabaseObject *)v14 saveToDatabase:&obj];
          objc_storeStrong((id *)(v15 + 40), obj);
          if (*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40))
          {
            __int16 v16 = [*(id *)(a1 + 48) zoneID];
            id v17 = [v16 zoneName];
            uint64_t v18 = sub_1000CD884(@"ckksdevice", v17);

            if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
            {
              uint64_t v19 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
              *(_DWORD *)long long buf = v21;
              uint64_t v28 = v14;
              __int16 v29 = 2112;
              uint64_t v30 = v19;
              _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "Couldn't save new device state(%@) to database: %@", buf, 0x16u);
            }
          }
        }
      }
      id v5 = [v2 countByEnumeratingWithState:&v23 objects:v31 count:16];
    }
    while (v5);
  }

  return 1;
}

void sub_1000A6034(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) timer];
  if (v2)
  {
    id v3 = (void *)v2;
    long long v4 = [*(id *)(a1 + 32) timer];
    intptr_t v5 = dispatch_source_testcancel(v4);

    if (!v5)
    {
      uint64_t v6 = [*(id *)(a1 + 32) timer];
      dispatch_source_cancel(v6);
    }
  }
}

void sub_1000A6498(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void sub_1000A64C4(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained _onqueueTimerTick];
}

void sub_1000A65C4(_Unwind_Exception *a1)
{
  objc_destroyWeak((id *)(v1 - 24));
  _Unwind_Resume(a1);
}

void sub_1000A65D8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained setLiveRequest:1];
  uint64_t v1 = [WeakRetained liveRequestReceived];
  [v1 fulfill];

  [WeakRetained _onqueueTrigger:0 maximumDelay:-1];
}

void sub_1000A6968(_Unwind_Exception *a1)
{
  objc_destroyWeak((id *)(v1 - 40));
  _Unwind_Resume(a1);
}

void sub_1000A697C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained setLiveRequest:1];
  uint64_t v2 = [WeakRetained liveRequestReceived];
  [v2 fulfill];

  if (*(void *)(a1 + 40) == -1) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = *(void *)(a1 + 40);
  }
  [WeakRetained _onqueueTrigger:v3];
}

id sub_1000A6A8C(uint64_t a1)
{
  return [*(id *)(a1 + 32) _onqueueTrigger:*(void *)(a1 + 40) maximumDelay:-1];
}

id sub_1000A6D70(uint64_t a1)
{
  [*(id *)(a1 + 32) setInitialDelay:*(void *)(a1 + 40)];
  [*(id *)(a1 + 32) setCurrentDelay:[*(id *)(a1 + 32) initialDelay]];
  unint64_t v2 = *(void *)(a1 + 40);
  if (v2) {
    double v3 = (double)*(unint64_t *)(a1 + 48) / (double)v2;
  }
  else {
    double v3 = 1.0;
  }
  [*(id *)(a1 + 32) setBackoff:v3];
  uint64_t v4 = *(void *)(a1 + 48);
  intptr_t v5 = *(void **)(a1 + 32);

  return [v5 setMaximumDelay:v4];
}

void sub_1000A77FC(uint64_t a1, void *a2)
{
  double v3 = [a2 objectForKeyedSubscript:@"pcsk"];
  id v4 = [v3 asBase64DecodedData];

  if ([*(id *)(a1 + 32) containsObject:v4]) {
    [*(id *)(a1 + 40) addObject:v4];
  }
}

void sub_1000A7ABC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000A7AE4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1000A7AF4(uint64_t a1)
{
}

void sub_1000A7AFC(uint64_t a1, void *a2)
{
  id v6 = [a2 objectForKeyedSubscript:@"count(rowid)"];
  uint64_t v3 = [v6 asNSNumberInteger];
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  intptr_t v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;
}

void sub_1000A7D14(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v8 = [v3 objectForKeyedSubscript:@"count(rowid)"];
  uint64_t v4 = [v8 asNSNumberInteger];
  intptr_t v5 = *(void **)(a1 + 32);
  id v6 = [v3 objectForKeyedSubscript:@"ckzone"];

  id v7 = [v6 asString];
  [v5 setObject:v4 forKeyedSubscript:v7];
}

void sub_1000A7FD4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v8 = [v3 objectForKeyedSubscript:@"count(rowid)"];
  uint64_t v4 = [v8 asNSNumberInteger];
  intptr_t v5 = *(void **)(a1 + 32);
  id v6 = [v3 objectForKeyedSubscript:@"parentKeyUUID"];

  id v7 = [v6 asString];
  [v5 setObject:v4 forKeyedSubscript:v7];
}

id sub_1000A8960(uint64_t a1)
{
  return [*(id *)(a1 + 32) _onqueueSetFlag:*(void *)(a1 + 40)];
}

void sub_1000A8A98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000A8AB0(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1000A8AC0(uint64_t a1)
{
}

void sub_1000A8AC8(uint64_t a1)
{
  unint64_t v2 = [*(id *)(a1 + 32) flags];
  unsigned int v3 = [v2 containsObject:*(void *)(a1 + 40)];

  if (v3)
  {
    id v7 = [*(id *)(a1 + 32) flagConditions];
    uint64_t v4 = [v7 objectForKeyedSubscript:*(void *)(a1 + 40)];
    uint64_t v5 = *(void *)(*(void *)(a1 + 48) + 8);
    id v6 = *(void **)(v5 + 40);
    *(void *)(v5 + 40) = v4;
  }
}

void sub_1000A92A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000A92C8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v8 = +[CKKSAnalytics logger];
  [v8 logResultForEvent:@"OctagonEventSetRecoveryKey" hardFailure:1 result:v6];

  if (v6)
  {
    id v9 = sub_10000B070("SecError");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = 138412290;
      id v18 = v6;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "octagon: Error setting recovery key: %@", (uint8_t *)&v17, 0xCu);
    }

    [WeakRetained setError:v6];
  }
  else
  {
    unsigned int v10 = sub_10000B070("octagon");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v17) = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "successfully set recovery key", (uint8_t *)&v17, 2u);
    }

    uint64_t v11 = sub_10000B070("octagon-ckks");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      id v12 = [WeakRetained deps];
      uint64_t v13 = [v12 ckks];
      int v17 = 138412290;
      id v18 = v13;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Providing setRecoveryKey() records to %@", (uint8_t *)&v17, 0xCu);
    }
    int v14 = [WeakRetained deps];
    uint64_t v15 = [v14 ckks];
    [v15 receiveTLKUploadRecords:v5];
  }
  __int16 v16 = [WeakRetained finishOp];
  [WeakRetained runBeforeGroupFinished:v16];
}

void sub_1000A97E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000A9820(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  unint64_t v2 = [*(id *)(a1 + 32) viewKeySets];
  [WeakRetained proceedWithKeys:v2 salt:*(void *)(a1 + 40)];
}

void sub_1000A9C6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000A9C98(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v11 = +[CKKSAnalytics logger];
  [v11 logResultForEvent:@"OctagonEventCreateCustodianRecoveryKeyTPH" hardFailure:1 result:v9];

  if (v9)
  {
    id v12 = sub_10000B070("SecError");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v35 = v9;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "octagon: Error create custodian recovery key: %@", buf, 0xCu);
    }

    [WeakRetained setError:v9];
    id v13 = [WeakRetained finishOp];
    [WeakRetained runBeforeGroupFinished:v13];
    goto LABEL_19;
  }
  int v14 = sub_10000B070("octagon");
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "successfully created custodian recovery key", buf, 2u);
  }

  id v15 = objc_alloc((Class)NSUUID);
  __int16 v16 = [v8 uuid];
  id v17 = [v15 initWithUUIDString:v16];

  if (!v17)
  {
    uint64_t v28 = sub_10000B070("SecError");
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v29 = [v8 uuid];
      *(_DWORD *)long long buf = 138412290;
      id v35 = v29;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "octagon: failed to parse UUID from TPH: %@", buf, 0xCu);
    }
    uint64_t v30 = +[NSError errorWithDomain:@"com.apple.security.octagon" code:54 description:@"Failed to parse UUID from TPH"];
    [WeakRetained setError:v30];

    id v13 = [WeakRetained finishOp];
    [WeakRetained runBeforeGroupFinished:v13];
    goto LABEL_18;
  }
  id v18 = objc_alloc((Class)OTCustodianRecoveryKey);
  uint64_t v19 = *(void *)(a1 + 32);
  id v33 = 0;
  id v20 = [v18 initWithUUID:v17 recoveryString:v19 error:&v33];
  id v13 = v33;
  [WeakRetained setCrk:v20];

  long long v21 = [WeakRetained crk];

  if (!v21)
  {
    uint64_t v31 = sub_10000B070("SecError");
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v35 = v13;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "octagon: failed to create crk: %@", buf, 0xCu);
    }

    [WeakRetained setError:v13];
    uint64_t v32 = [WeakRetained finishOp];
    [WeakRetained runBeforeGroupFinished:v32];

LABEL_18:
    id v13 = v17;
    goto LABEL_19;
  }
  __int16 v22 = sub_10000B070("octagon-ckks");
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    long long v23 = [WeakRetained deps];
    long long v24 = [v23 ckks];
    *(_DWORD *)long long buf = 138412290;
    id v35 = v24;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Providing createCustodianRecoveryKey() records to %@", buf, 0xCu);
  }
  long long v25 = [WeakRetained deps];
  long long v26 = [v25 ckks];
  [v26 receiveTLKUploadRecords:v7];

  uint64_t v27 = [WeakRetained finishOp];
  [WeakRetained runBeforeGroupFinished:v27];

LABEL_19:
}

void sub_1000AA3DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000AA418(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  unint64_t v2 = [*(id *)(a1 + 32) viewKeySets];
  [WeakRetained proceedWithKeys:v2 salt:*(void *)(a1 + 40)];
}

void sub_1000AA8F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000AA924(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6 = a2;
  id v7 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v9 = +[CKKSAnalytics logger];
  [v9 logResultForEvent:@"OctagonEventCreateCustodianRecoveryKeyTPH" hardFailure:1 result:v7];

  if (v7)
  {
    unsigned int v10 = sub_10000B070("SecError");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v18 = 138412290;
      id v19 = v7;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "octagon: Error create inheritance key: %@", (uint8_t *)&v18, 0xCu);
    }

    [WeakRetained setError:v7];
  }
  else
  {
    uint64_t v11 = sub_10000B070("octagon");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v1_Block_object_dispose(&STACK[0x3F0], 8) = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "successfully created inheritance key", (uint8_t *)&v18, 2u);
    }

    id v12 = sub_10000B070("octagon-ckks");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      id v13 = [WeakRetained deps];
      int v14 = [v13 ckks];
      int v18 = 138412290;
      id v19 = v14;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Providing createCustodianRecoveryKey() records to %@", (uint8_t *)&v18, 0xCu);
    }
    id v15 = [WeakRetained deps];
    __int16 v16 = [v15 ckks];
    [v16 receiveTLKUploadRecords:v6];
  }
  id v17 = [WeakRetained finishOp];
  [WeakRetained runBeforeGroupFinished:v17];
}

void sub_1000AACF0(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_1000AAD18(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v2 = [*(id *)(a1 + 32) viewKeySets];
  [WeakRetained proceedWithKeys:v2 salt:*(void *)(a1 + 40)];
}

void sub_1000AB09C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000AB0C0(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6 = a2;
  id v7 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v9 = +[CKKSAnalytics logger];
  [v9 logResultForEvent:@"OctagonEventCreateCustodianRecoveryKeyTPH" hardFailure:1 result:v7];

  if (v7)
  {
    unsigned int v10 = sub_10000B070("SecError");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v18 = 138412290;
      id v19 = v7;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "octagon: Error store inheritance key: %@", (uint8_t *)&v18, 0xCu);
    }

    [WeakRetained setError:v7];
  }
  else
  {
    uint64_t v11 = sub_10000B070("octagon");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v1_Block_object_dispose(&STACK[0x3F0], 8) = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "successfully stored inheritance key", (uint8_t *)&v18, 2u);
    }

    id v12 = sub_10000B070("octagon-ckks");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      id v13 = [WeakRetained deps];
      int v14 = [v13 ckks];
      int v18 = 138412290;
      id v19 = v14;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Providing storeCustodianRecoveryKey() records to %@", (uint8_t *)&v18, 0xCu);
    }
    id v15 = [WeakRetained deps];
    __int16 v16 = [v15 ckks];
    [v16 receiveTLKUploadRecords:v6];
  }
  id v17 = [WeakRetained finishOp];
  [WeakRetained runBeforeGroupFinished:v17];
}

void sub_1000AB47C(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_1000AB4A4(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v2 = [*(id *)(a1 + 32) viewKeySets];
  [WeakRetained proceedWithKeys:v2];
}

void sub_1000AB9A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000AB9D8(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6 = a2;
  id v7 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v9 = +[CKKSAnalytics logger];
  [v9 logResultForEvent:@"OctagonEventCreateCustodianRecoveryKeyTPH" hardFailure:1 result:v7];

  if (v7)
  {
    unsigned int v10 = sub_10000B070("SecError");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v18 = 138412290;
      id v19 = v7;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "octagon: Error recreatint inheritance key: %@", (uint8_t *)&v18, 0xCu);
    }

    [WeakRetained setError:v7];
  }
  else
  {
    uint64_t v11 = sub_10000B070("octagon");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v1_Block_object_dispose(&STACK[0x3F0], 8) = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "successfully recreated inheritance key", (uint8_t *)&v18, 2u);
    }

    id v12 = sub_10000B070("octagon-ckks");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      id v13 = [WeakRetained deps];
      int v14 = [v13 ckks];
      int v18 = 138412290;
      id v19 = v14;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Providing createCustodianRecoveryKey() records to %@", (uint8_t *)&v18, 0xCu);
    }
    id v15 = [WeakRetained deps];
    __int16 v16 = [v15 ckks];
    [v16 receiveTLKUploadRecords:v6];
  }
  id v17 = [WeakRetained finishOp];
  [WeakRetained runBeforeGroupFinished:v17];
}

void sub_1000ABDA4(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_1000ABDCC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v2 = [*(id *)(a1 + 32) viewKeySets];
  [WeakRetained proceedWithKeys:v2 salt:*(void *)(a1 + 40)];
}

void sub_1000AC394(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000AC3C4(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6 = a2;
  id v7 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v9 = +[CKKSAnalytics logger];
  [v9 logResultForEvent:@"OctagonEventCreateCustodianRecoveryKeyTPH" hardFailure:1 result:v7];

  if (v7)
  {
    unsigned int v10 = sub_10000B070("SecError");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v18 = 138412290;
      id v19 = v7;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "octagon: Error creating inheritance w/claimtoken+wrappingkey key: %@", (uint8_t *)&v18, 0xCu);
    }

    [WeakRetained setError:v7];
  }
  else
  {
    uint64_t v11 = sub_10000B070("octagon");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v1_Block_object_dispose(&STACK[0x3F0], 8) = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "successfully created inheritance key w/claimtoken+wrappingkey", (uint8_t *)&v18, 2u);
    }

    id v12 = sub_10000B070("octagon-ckks");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      id v13 = [WeakRetained deps];
      int v14 = [v13 ckks];
      int v18 = 138412290;
      id v19 = v14;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Providing createCustodianRecoveryKey() records to %@", (uint8_t *)&v18, 0xCu);
    }
    id v15 = [WeakRetained deps];
    __int16 v16 = [v15 ckks];
    [v16 receiveTLKUploadRecords:v6];
  }
  id v17 = [WeakRetained finishOp];
  [WeakRetained runBeforeGroupFinished:v17];
}

void sub_1000AC790(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_1000AC7B8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v2 = [*(id *)(a1 + 32) viewKeySets];
  [WeakRetained proceedWithKeys:v2 salt:*(void *)(a1 + 40)];
}

void sub_1000ADBE0(id a1)
{
  v4[0] = @"type";
  v4[1] = kSecValueData;
  v4[2] = @"pkkp";
  v4[3] = @"pkvp";
  v4[4] = @"ipkp";
  v4[5] = @"ipvp";
  void v4[6] = @"flag";
  uint64_t v1 = +[NSArray arrayWithObjects:v4 count:7];
  uint64_t v2 = +[NSSet setWithArray:v1];
  unsigned int v3 = (void *)qword_10035CDC0;
  qword_10035CDC0 = v2;
}

uint64_t sub_1000B00E8(uint64_t a1, uint64_t a2)
{
  while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0;
    while (1)
    {
      unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      if (v7 == -1 || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v8 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
      v6 |= (unint64_t)(v8 & 0x7F) << v4;
      if ((v8 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v9 = v5++ >= 9;
      if (v9)
      {
        unint64_t v6 = 0;
        int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }
    *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0;
    }
LABEL_13:
    if (v10 || (v6 & 7) == 4) {
      return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
    }
    unint64_t v12 = v6 >> 3;
    if ((int)(v6 >> 3) <= 200)
    {
      if (v12 == 1)
      {
        char v25 = 0;
        unsigned int v26 = 0;
        uint64_t v27 = 0;
        *(unsigned char *)(a1 + 44) |= 4u;
        while (1)
        {
          unint64_t v28 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v28 == -1 || v28 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            break;
          }
          char v29 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v28);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v28 + 1;
          v27 |= (unint64_t)(v29 & 0x7F) << v25;
          if ((v29 & 0x80) == 0) {
            goto LABEL_60;
          }
          v25 += 7;
          BOOL v9 = v26++ >= 9;
          if (v9)
          {
            LODWORD(v27) = 0;
            goto LABEL_62;
          }
        }
        *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_60:
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          LODWORD(v27) = 0;
        }
LABEL_62:
        *(_DWORD *)(a1 + 40) = v27;
      }
      else
      {
        if (v12 != 101)
        {
LABEL_48:
          uint64_t result = PBReaderSkipValueWithTag();
          if (!result) {
            return result;
          }
          continue;
        }
        uint64_t v14 = PBReaderReadString();
        id v15 = *(void **)(a1 + 32);
        *(void *)(a1 + 32) = v14;
      }
    }
    else
    {
      if (v12 == 201)
      {
        char v16 = 0;
        unsigned int v17 = 0;
        uint64_t v18 = 0;
        *(unsigned char *)(a1 + 44) |= 2u;
        while (1)
        {
          unint64_t v19 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v19 == -1 || v19 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            break;
          }
          char v20 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v19);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v19 + 1;
          v18 |= (unint64_t)(v20 & 0x7F) << v16;
          if ((v20 & 0x80) == 0) {
            goto LABEL_51;
          }
          v16 += 7;
          BOOL v9 = v17++ >= 9;
          if (v9)
          {
            uint64_t v18 = 0;
            goto LABEL_53;
          }
        }
        *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_51:
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v18 = 0;
        }
LABEL_53:
        uint64_t v31 = 16;
        goto LABEL_58;
      }
      if (v12 == 202)
      {
        char v21 = 0;
        unsigned int v22 = 0;
        uint64_t v18 = 0;
        *(unsigned char *)(a1 + 44) |= 1u;
        while (1)
        {
          unint64_t v23 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          if (v23 == -1 || v23 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
            break;
          }
          char v24 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v23);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v23 + 1;
          v18 |= (unint64_t)(v24 & 0x7F) << v21;
          if ((v24 & 0x80) == 0) {
            goto LABEL_55;
          }
          v21 += 7;
          BOOL v9 = v22++ >= 9;
          if (v9)
          {
            uint64_t v18 = 0;
            goto LABEL_57;
          }
        }
        *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_55:
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v18 = 0;
        }
LABEL_57:
        uint64_t v31 = 8;
LABEL_58:
        *(void *)(a1 + v31) = v18;
        continue;
      }
      if (v12 != 301) {
        goto LABEL_48;
      }
      id v13 = objc_alloc_init(SECC2MPGenericEventMetric);
      [(id)a1 addMetric:v13];
      if (!PBReaderPlaceMark() || !sub_100085594((uint64_t)v13, a2))
      {

        return 0;
      }
      PBReaderRecallMark();
    }
  }
  return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

id sub_1000B0D6C()
{
  if (qword_10035CDD8 != -1) {
    dispatch_once(&qword_10035CDD8, &stru_1002F8E50);
  }
  uint64_t v0 = (void *)qword_10035CDD0;

  return v0;
}

void sub_1000B0DC0(id a1)
{
  v3[0] = @"ready";
  v3[1] = @"error";
  v4[0] = &off_100325BA0;
  v4[1] = &off_100325BB8;
  v3[2] = @"initializing";
  v3[3] = @"initialized";
  v4[2] = &off_100325BD0;
  v4[3] = &off_100325BE8;
  v3[4] = @"fetchcomplete";
  void v3[5] = @"waitfortlk";
  v4[4] = &off_100325C00;
  v4[5] = &off_100325C18;
  void v3[6] = @"waitforunlock";
  v3[7] = @"unhealthy";
  void v4[6] = &off_100325C30;
  void v4[7] = &off_100325C48;
  void v3[8] = @"badcurrentpointers";
  v3[9] = @"newtlksfailed";
  v4[8] = &off_100325C60;
  v4[9] = &off_100325C78;
  v3[10] = @"needrefetch";
  v3[11] = @"healtlkshares";
  v4[10] = &off_100325C90;
  v4[11] = &off_100325CA8;
  v3[12] = @"healtlksharesfailed";
  v3[13] = @"readypendingunlock";
  v4[12] = &off_100325CC0;
  v4[13] = &off_100325CD8;
  v3[14] = @"fetching";
  v3[15] = @"resetzone";
  v4[14] = &off_100325CF0;
  v4[15] = &off_100325D08;
  v3[16] = @"resetlocal";
  v3[17] = @"loggedout";
  uint8_t v4[16] = &off_100325D20;
  v4[17] = &off_100325D38;
  v3[18] = @"zonecreationfailed";
  v3[19] = @"waitfortrust";
  v4[18] = &off_100325D50;
  v4[19] = &off_100325D68;
  v3[20] = @"waitfortlkupload";
  v3[21] = @"waitfortlkcreation";
  v4[20] = &off_100325D80;
  v4[21] = &off_100325D98;
  v3[22] = @"process_key_hierarchy";
  v3[23] = @"become_ready";
  v4[22] = &off_100325DB0;
  void v4[23] = &off_100325DC8;
  v3[24] = @"lose_trust";
  v3[25] = @"tlkmissing";
  v4[24] = &off_100325DE0;
  v4[25] = &off_100325DF8;
  v3[26] = @"wait_for_ck_account_status";
  v3[27] = @"begin_fetch";
  v4[26] = &off_100325E10;
  v4[27] = &off_100325E28;
  v3[28] = @"fixup_fetch_cip";
  v3[29] = @"fixup_fetch_tlkshares";
  v4[28] = &off_100325E40;
  v4[29] = &off_100325E58;
  v3[30] = @"fixup_local_reload";
  v3[31] = @"fixup_resave_cdse";
  v4[30] = &off_100325E70;
  v4[31] = &off_100325E88;
  v3[32] = @"fixup_delete_tombstones";
  v3[33] = @"check_tlk_shares";
  v4[32] = &off_100325EA0;
  v4[33] = &off_100325EB8;
  uint64_t v1 = +[NSDictionary dictionaryWithObjects:v4 forKeys:v3 count:34];
  uint64_t v2 = (void *)qword_10035CDD0;
  qword_10035CDD0 = v1;
}

void sub_1000B10EC(id a1)
{
  sub_1000B0D6C();
  id v5 = (id)objc_claimAutoreleasedReturnValue();
  uint64_t v1 = [v5 allKeys];
  uint64_t v2 = [v5 allValues];
  uint64_t v3 = +[NSDictionary dictionaryWithObjects:v1 forKeys:v2];
  char v4 = (void *)qword_10035CDE0;
  qword_10035CDE0 = v3;
}

__CFString *sub_1000B1188(void *a1)
{
  if (a1)
  {
    id v1 = a1;
    if (qword_10035CDE8 != -1) {
      dispatch_once(&qword_10035CDE8, &stru_1002F8E70);
    }
    id v2 = (id)qword_10035CDE0;
    uint64_t v3 = [v2 objectForKeyedSubscript:v1];

    if (v3)
    {
      char v4 = v3;
    }
    else
    {
      char v4 = @"error";
      unint64_t v6 = @"error";
    }
  }
  else
  {
    char v4 = @"error";
    id v5 = @"error";
  }

  return v4;
}

void sub_1000B124C(id a1)
{
  v4[0] = @"loggedout";
  v4[1] = @"resetzone";
  v4[2] = @"resetlocal";
  v4[3] = @"initializing";
  v4[4] = @"initialized";
  v4[5] = @"zonecreationfailed";
  void v4[6] = @"ready";
  void v4[7] = @"fetching";
  v4[8] = @"process_key_hierarchy";
  v4[9] = @"needrefetch";
  v4[10] = @"tlkmissing";
  v4[11] = @"waitfortlk";
  v4[12] = @"waitfortlkcreation";
  v4[13] = @"waitforunlock";
  v4[14] = @"waitfortrust";
  v4[15] = @"unhealthy";
  uint8_t v4[16] = @"newtlksfailed";
  v4[17] = @"error";
  id v1 = +[NSArray arrayWithObjects:v4 count:18];
  uint64_t v2 = +[NSSet setWithArray:v1];
  uint64_t v3 = (void *)qword_10035CDF0;
  qword_10035CDF0 = v2;
}

id sub_1000B1398()
{
  if (qword_10035CE08 != -1) {
    dispatch_once(&qword_10035CE08, &stru_1002F8EB0);
  }
  uint64_t v0 = (void *)qword_10035CE00;

  return v0;
}

void sub_1000B13EC(id a1)
{
  v4[0] = @"ready";
  v4[1] = @"waitfortrust";
  v4[2] = @"waitfortlk";
  v4[3] = @"waitfortlkcreation";
  v4[4] = @"waitforunlock";
  v4[5] = @"error";
  void v4[6] = @"loggedout";
  void v4[7] = @"halted";
  id v1 = +[NSArray arrayWithObjects:v4 count:8];
  uint64_t v2 = +[NSSet setWithArray:v1];
  uint64_t v3 = (void *)qword_10035CE00;
  qword_10035CE00 = v2;
}

uint64_t sub_1000B14D4()
{
  if (objc_opt_class()) {
    return byte_10035CE10;
  }
  id v1 = sub_1000CD884(@"ckks", 0);
  if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)uint64_t v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "CloudKit.framework appears to not be linked. Cannot enable CKKS (on pain of crash).", v2, 2u);
  }

  return 0;
}

void sub_1000B1568(id a1)
{
  id v1 = [objc_alloc((Class)NSUserDefaults) initWithSuiteName:@"com.apple.security.ckks"];
  CFStringRef v8 = @"reduce-rate-limiting";
  uint64_t v2 = &__kCFBooleanTrue;
  if (!byte_10035CE20) {
    uint64_t v2 = &__kCFBooleanFalse;
  }
  BOOL v9 = v2;
  uint64_t v3 = +[NSDictionary dictionaryWithObjects:&v9 forKeys:&v8 count:1];
  [v1 registerDefaults:v3];

  byte_10035CE20 = [v1 BOOLForKey:@"reduce-rate-limiting"];
  char v4 = sub_1000CD884(@"ratelimit", 0);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_10035CE20) {
      CFStringRef v5 = @"on";
    }
    else {
      CFStringRef v5 = @"off";
    }
    int v6 = 138412290;
    CFStringRef v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "reduce-rate-limiting is %@", (uint8_t *)&v6, 0xCu);
  }
}

void sub_1000B16C8(id a1)
{
  id v1 = +[OctagonAPSReceiver receiverForNamedDelegatePort:@"com.apple.securityd.aps" apsConnectionClass:objc_opt_class()];
  [v1 registerForEnvironment:APSEnvironmentProduction];
}

void sub_1000B1740(id a1, __OpaqueSecDbConnection *a2, unint64_t a3, unint64_t a4, __CFArray *a5)
{
  if (a3)
  {
    if (a4 == 4)
    {
      CFStringRef v5 = sub_1000CD884(@"ckks", 0);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v8[0]) = 0;
        int v6 = "Ignoring kSecDbKCSharingTransaction notification";
        goto LABEL_11;
      }
LABEL_7:

      return;
    }
    if (a4 == 3)
    {
      CFStringRef v5 = sub_1000CD884(@"ckks", 0);
      if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
      {
        LOWORD(v8[0]) = 0;
        int v6 = "Ignoring kSecDbCKKSTransaction notification";
LABEL_11:
        _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, v6, (uint8_t *)v8, 2u);
        goto LABEL_7;
      }
      goto LABEL_7;
    }
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472;
    v8[2] = sub_1000B1888;
    v8[3] = &unk_1002F8F30;
    v8[4] = a2;
    v8[5] = a4;
    v9.size_t length = CFArrayGetCount(a5);
    v9.id location = 0;
    CFArrayApplyFunction(a5, v9, (CFArrayApplierFunction)sub_1000B19AC, v8);
  }
}

void sub_1000B1888(uint64_t a1, const __CFArray *a2)
{
  long long v8 = 0uLL;
  sub_100029198(a2, (CFTypeID *)&v8 + 1, (const __CFArray **)&v8);
  if (v8 == 0)
  {
    CFStringRef v7 = sub_1000CD884(@"ckks", 0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      CFArrayRef v10 = a2;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "SecDbEvent gave us garbage: %@", buf, 0xCu);
    }
  }
  else
  {
    int v6 = +[CKKSViewManager manager];
    [v6 handleKeychainEventDbConnection:*(void *)(a1 + 32) source:*(void *)(a1 + 40) added:v8];
  }
}

uint64_t sub_1000B19AC(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_1000B19C4(uint64_t a1, void *a2)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  _DWORD v6[2] = sub_1000B1A88;
  v6[3] = &unk_1002FB288;
  id v7 = a2;
  id v3 = v7;
  char v4 = objc_retainBlock(v6);
  CFStringRef v5 = +[CKKSViewManager manager];
  [v5 registerSyncStatusCallback:a1 callback:v4];
}

uint64_t sub_1000B1A88(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000B1A98(id a1, NSError *a2)
{
  uint64_t v2 = a2;
  id v3 = sub_1000CD884(@"reset", 0);
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      int v8 = 138412290;
      CFRange v9 = v2;
      CFStringRef v5 = "Local keychain reset resync finished with an error: %@";
      int v6 = v3;
      uint32_t v7 = 12;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v5, (uint8_t *)&v8, v7);
    }
  }
  else if (v4)
  {
    LOWORD(v_Block_object_dispose(&STACK[0x3F0], 8) = 0;
    CFStringRef v5 = "Local keychain reset resync finished successfully";
    int v6 = v3;
    uint32_t v7 = 2;
    goto LABEL_6;
  }
}

void sub_1000B2354(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,id location)
{
}

void sub_1000B23C4(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = a2;
  id v4 = [v2 rpcProcessIncomingQueue:0 errorOnClassAFailure:0];
  [v3 dependOnBeforeGroupFinished:v4];
}

void sub_1000B2430(id *a1)
{
  id WeakRetained = objc_loadWeakRetained(a1 + 6);
  if (WeakRetained)
  {
    if ([a1[5] recordsFound])
    {
      if ((int)[WeakRetained restartCount] < 3)
      {
        [WeakRetained setRestartCount:[WeakRetained restartCount] + 1];
        CFRange v9 = [a1[4] zoneName];
        CFArrayRef v10 = sub_1000CD884(@"ckksresync", v9);

        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t v11 = 0;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "restarting synchronization operation due to new local items", v11, 2u);
        }

        [WeakRetained groupStart];
      }
      else
      {
        id v3 = [a1[4] zoneName];
        id v4 = sub_1000CD884(@"ckksresync", v3);

        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)uint64_t v11 = 0;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "restarted synchronization too often; Failing",
            v11,
            2u);
        }

        NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
        CFStringRef v13 = @"resynchronization restarted too many times; churn in database?";
        CFStringRef v5 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
        int v6 = +[NSError errorWithDomain:@"securityd" code:2 userInfo:v5];
        [WeakRetained setError:v6];
      }
    }
  }
  else
  {
    uint32_t v7 = [a1[4] zoneName];
    int v8 = sub_1000CD884(@"ckksresync", v7);

    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)uint64_t v11 = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "received callback for released object", v11, 2u);
    }
  }
}

id sub_1000B2904(uint64_t a1, uint64_t a2)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  _DWORD v6[2] = sub_1000B29A0;
  v6[3] = &unk_1002F8FC8;
  id v3 = *(void **)(a1 + 32);
  id v7 = *(id *)(a1 + 40);
  id v4 = [v3 dispatchSyncWithConnection:a2 readWriteTxion:0 block:v6];

  return v4;
}

uint64_t sub_1000B29A0(uint64_t a1)
{
  return 1;
}

id sub_1000B2B34(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) dispatchSyncWithConnection:a2 readWriteTxion:1 block:*(void *)(a1 + 40)];
}

BOOL sub_1000B2CBC(uint64_t a1)
{
  uint64_t v13 = 0;
  uint64_t v14 = &v13;
  uint64_t v15 = 0x2020000000;
  char v16 = 0;
  off_10035CA00();
  id v3 = v2;
  *uint64_t v2 = 1;
  if (*(unsigned char *)(a1 + 48))
  {
    off_10035CA18();
    *id v4 = v5;
  }
  int v6 = [*(id *)(a1 + 32) queue];
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 3221225472;
  v10[2] = sub_1000B2E14;
  void v10[3] = &unk_1002F9940;
  NSErrorUserInfoKey v12 = &v13;
  id v11 = *(id *)(a1 + 40);
  dispatch_sync(v6, v10);

  if (*(unsigned char *)(a1 + 48))
  {
    off_10035CA18();
    *id v7 = 0;
  }
  *id v3 = 0;
  BOOL v8 = *((unsigned __int8 *)v14 + 24) == 1;

  _Block_object_dispose(&v13, 8);
  return v8;
}

void sub_1000B2DFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000B2E14(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = result;
  return result;
}

void sub_1000B3058(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) keysets];

  if (!v2)
  {
    [*(id *)(a1 + 32) setKeysets:*(void *)(a1 + 40)];
    id v3 = [*(id *)(a1 + 32) startDependency];

    if (v3)
    {
      id v5 = objc_alloc_init((Class)NSOperationQueue);
      id v4 = [*(id *)(a1 + 32) startDependency];
      [v5 addOperation:v4];

      [*(id *)(a1 + 32) setStartDependency:0];
    }
  }
}

uint64_t sub_1000B3DAC(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

CFStringRef sub_1000B3DE0(uint64_t a1)
{
  CFDictionaryRef v2 = (const __CFDictionary *)sub_100025824();

  return sub_1000B3E1C(a1, v2);
}

CFStringRef sub_1000B3E1C(uint64_t a1, const __CFDictionary *a2)
{
  CFStringRef v5 = *(const __CFString **)(a1 + 16);
  CFArrayRef v4 = *(const __CFArray **)(a1 + 24);
  if (v5) {
    CFStringRef v6 = v5;
  }
  else {
    CFStringRef v6 = @"NonConcrete";
  }
  CFIndex Count = CFArrayGetCount(v4);
  CFIndex v8 = CFArrayGetCount(*(CFArrayRef *)(a1 + 32));
  return CFStringCreateWithFormat(kCFAllocatorDefault, a2, @"<ChangeTracker %@ children %ld/%ld>", v6, Count, v8);
}

void sub_1000B3EA4(void *a1)
{
  CFDictionaryRef v2 = (const void *)a1[2];
  if (v2) {
    CFRelease(v2);
  }
  id v3 = (const void *)a1[3];
  if (v3) {
    CFRelease(v3);
  }
  CFArrayRef v4 = (const void *)a1[4];
  if (v4)
  {
    CFRelease(v4);
  }
}

void sub_1000B4694(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 144));
  _Unwind_Resume(a1);
}

void sub_1000B46B8(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  if ([WeakRetained checkFatalError:v5])
  {
    id v7 = sub_10000B070("SecError");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      CFIndex v8 = [*(id *)(a1 + 32) uuid];
      *(_DWORD *)long long buf = 138412546;
      id v24 = v8;
      __int16 v25 = 2112;
      id v26 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "escrowrequest: fatal error for record: %@, dropping: %@", buf, 0x16u);
    }
    CFRange v9 = *(void **)(a1 + 32);
    id v22 = 0;
    [v9 deleteFromKeychain:&v22];
    id v10 = v22;
    if (*(void *)(a1 + 40))
    {
      id v11 = sub_10000B070("SecError");
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v24 = v10;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "escrowrequest: unable to delete last escrow time: %@", buf, 0xCu);
      }
    }
    [WeakRetained setError:v5];
LABEL_20:
    uint64_t v18 = [WeakRetained operationQueue];
    [v18 addOperation:*(void *)(a1 + 48)];

    goto LABEL_24;
  }
  if (!v5 && (a2 & 1) != 0)
  {
    [WeakRetained setNumberOfRecordsUploaded:1];
    NSErrorUserInfoKey v12 = sub_10000B070("SecError");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = [*(id *)(a1 + 32) uuid];
      *(_DWORD *)long long buf = 138412290;
      id v24 = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "escrowrequest: prerecord %@ upload succeeded", buf, 0xCu);
    }
    [*(id *)(a1 + 32) setUploadCompleted:1];
    uint64_t v14 = *(void **)(a1 + 32);
    id v21 = 0;
    [v14 saveToKeychain:&v21];
    id v10 = v21;
    if (v10)
    {
      uint64_t v15 = sub_10000B070("SecError");
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v24 = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "escrowrequest: unable to save last escrow time: %@", buf, 0xCu);
      }

      char v16 = sub_10000B070("SecError");
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v17 = [*(id *)(a1 + 32) uuid];
        *(_DWORD *)long long buf = 138412290;
        id v24 = v17;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "escrowrequest: unable to save completion of prerecord %@ in keychain", buf, 0xCu);
      }
    }
    [WeakRetained setNextState:@"nothing_to_do"];
    goto LABEL_20;
  }
  unint64_t v19 = sub_10000B070("SecError");
  if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
  {
    char v20 = [*(id *)(a1 + 32) uuid];
    *(_DWORD *)long long buf = 138412546;
    id v24 = v20;
    __int16 v25 = 2112;
    id v26 = v5;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "escrowrequest: prerecord %@ upload failed: %@", buf, 0x16u);
  }
  [WeakRetained setError:v5];
  id v10 = [WeakRetained operationQueue];
  [v10 addOperation:*(void *)(a1 + 48)];
LABEL_24:
}

uint64_t sub_1000B4DA4(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000B60F0(uint64_t a1)
{
  uint64_t v70 = 0;
  long long v71 = &v70;
  uint64_t v72 = 0x3032000000;
  long long v73 = sub_1000B6E0C;
  BOOL v74 = sub_1000B6E1C;
  id v75 = 0;
  uint64_t v2 = *(void **)(a1 + 32);
  id v3 = [*(id *)(a1 + 40) deps];
  CFArrayRef v4 = [v3 contextID];
  uint64_t v5 = *(void *)(a1 + 48);
  id v69 = 0;
  CFStringRef v6 = +[CKKSSQLDatabaseObject allUUIDsWithContextID:v4 inZones:v5 error:&v69];
  id v57 = v69;
  [v2 unionSet:v6];

  if (v57)
  {
    id v7 = sub_1000CD884(@"ckksscan", 0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v57;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Unable to load CKMirrorEntries: %@", (uint8_t *)&buf, 0xCu);
    }
  }
  *(void *)&long long buf = 0;
  *((void *)&buf + 1) = &buf;
  uint64_t v89 = 0x3032000000;
  uint64_t v90 = sub_1000B6E0C;
  id v91 = sub_1000B6E1C;
  id v92 = (CKKSMemoryKeyCache *)0xAAAAAAAAAAAAAAAALL;
  id v92 = objc_alloc_init(CKKSMemoryKeyCache);
  id v8 = objc_alloc((Class)AAFAnalyticsEventSecurity);
  CFRange v9 = [*(id *)(a1 + 40) deps];
  id v10 = [v9 activeAccount];
  id v11 = [v10 altDSID];
  NSErrorUserInfoKey v12 = [*(id *)(a1 + 40) deps];
  id v13 = [v12 sendMetric];
  id v58 = [v8 initWithCKKSMetrics:&__NSDictionary0__struct altDSID:v11 eventName:kSecurityRTCEventNameQuerySyncableItems testsAreEnabled:0 category:kSecurityRTCEventCategoryAccountDataAccessRecovery sendMetric:v13];

  uint64_t v14 = &off_1002FE3E8;
  uint64_t v15 = kSecAttrTombstone;
  char v16 = off_100300578;
  do
  {
    if (*((unsigned char *)v14 + 8))
    {
      unsigned int v17 = *v14;
      v86[0] = kSecClass;
      v86[1] = kSecReturnRef;
      v87[0] = v17;
      v87[1] = &__kCFBooleanTrue;
      v87[2] = &__kCFBooleanTrue;
      v86[2] = kSecAttrSynchronizable;
      v86[3] = v15;
      v87[3] = &__kCFBooleanFalse;
      uint64_t v18 = +[NSDictionary dictionaryWithObjects:v87 forKeys:v86 count:4];
      id v19 = [v18 mutableCopy];

      char v20 = *(void **)(a1 + 40);
      id v21 = [v20 deps];
      id v22 = [v21 views];
      unint64_t v23 = [v20 queryPredicatesForViewMapping:v22];

      [v19 addEntriesFromDictionary:v23];
      id v24 = sub_1000CD884(@"ckksscan", 0);
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v25 = [*(id *)(a1 + 40) name];
        *(_DWORD *)long long v80 = 138412802;
        id v81 = v17;
        __int16 v82 = 2112;
        id v83 = v25;
        __int16 v84 = 2112;
        id v85 = v19;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Scanning all synchronizable %@ items(%@) for: %@", v80, 0x20u);
      }
      id v26 = *(void **)(a1 + 40);
      uint64_t v27 = (id *)(v71 + 5);
      id obj = (id)v71[5];
      v61[0] = _NSConcreteStackBlock;
      v61[1] = 3221225472;
      v61[2] = sub_1000B6E24;
      v61[3] = &unk_1002F91C8;
      v61[4] = v26;
      unint64_t v28 = v17;
      long long v62 = v28;
      id v66 = &v70;
      id v63 = *(id *)(a1 + 56);
      id v64 = *(id *)(a1 + 32);
      p_long long buf = &buf;
      id v65 = *(id *)(a1 + 64);
      [v26 executeQuery:v19 readWrite:0 error:&obj block:v61];
      objc_storeStrong(v27, obj);
    }
    char v29 = *v16++;
    uint64_t v14 = v29;
  }
  while (v29);
  if (![*(id *)(a1 + 32) count]) {
    goto LABEL_22;
  }
  uint64_t v30 = sub_1000CD884(@"ckksscan", 0);
  if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v31 = (__CFString *)[*(id *)(a1 + 32) count];
    *(_DWORD *)long long v80 = 134217984;
    id v81 = v31;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "keychain missing %lu items from mirror, proceeding with queue scanning", v80, 0xCu);
  }

  uint64_t v32 = *(void **)(a1 + 32);
  id v33 = [*(id *)(a1 + 40) deps];
  id v34 = [v33 contextID];
  uint64_t v35 = *(void *)(a1 + 48);
  uint64_t v36 = (id *)(v71 + 5);
  id v60 = (id)v71[5];
  id v37 = +[CKKSSQLDatabaseObject allUUIDsWithContextID:v34 inZones:v35 error:&v60];
  objc_storeStrong(v36, v60);
  [v32 minusSet:v37];

  if (v71[5])
  {
    unsigned int v38 = sub_1000CD884(@"ckksscan", 0);
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
    {
      id v39 = (__CFString *)v71[5];
      *(_DWORD *)long long v80 = 138412290;
      id v81 = v39;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "unable to inspect incoming queue: %@", v80, 0xCu);
    }

    [*(id *)(a1 + 40) setError:v71[5]];
    uint64_t v40 = [*(id *)(a1 + 40) error];
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v58 success:0 error:v40];
    goto LABEL_23;
  }
  id v41 = *(void **)(a1 + 32);
  id v42 = [*(id *)(a1 + 40) deps];
  id v43 = [v42 contextID];
  uint64_t v44 = *(void *)(a1 + 48);
  id v45 = (id *)(v71 + 5);
  id v59 = (id)v71[5];
  id v46 = +[CKKSSQLDatabaseObject allUUIDsWithContextID:v43 inZones:v44 error:&v59];
  objc_storeStrong(v45, v59);
  [v41 minusSet:v46];

  if (!v71[5])
  {
LABEL_22:
    CFStringRef v49 = *(void **)(a1 + 72);
    v78[0] = kSecurityRTCFieldItemsScanned;
    id v50 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [*(id *)(a1 + 40) processedItems]);
    v79[0] = v50;
    uint64_t v51 = kSecurityRTCFieldNewItemsScanned;
    v78[1] = kSecurityRTCFieldNewItemsScanned;
    __int16 v52 = +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", [*(id *)(a1 + 40) recordsFound]);
    v79[1] = v52;
    id v53 = +[NSDictionary dictionaryWithObjects:v79 forKeys:v78 count:2];
    [v49 addMetrics:v53];

    uint64_t v76 = v51;
    __int16 v54 = +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", [*(id *)(a1 + 40) recordsFound]);
    unsigned __int8 v77 = v54;
    id v55 = +[NSDictionary dictionaryWithObjects:&v77 forKeys:&v76 count:1];
    [v58 addMetrics:v55];

    uint64_t v40 = [*(id *)(a1 + 40) error];
    unsigned int v56 = [*(id *)(a1 + 40) error];
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v58 success:v40 != 0 error:v56];

    goto LABEL_23;
  }
  id v47 = sub_1000CD884(@"ckksscan", 0);
  if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
  {
    NSErrorUserInfoKey v48 = (__CFString *)v71[5];
    *(_DWORD *)long long v80 = 138412290;
    id v81 = v48;
    _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "unable to inspect outgoing queue: %@", v80, 0xCu);
  }

  [*(id *)(a1 + 40) setError:v71[5]];
  uint64_t v40 = [*(id *)(a1 + 40) error];
  +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v58 success:0 error:v40];
LABEL_23:

  _Block_object_dispose(&buf, 8);
  _Block_object_dispose(&v70, 8);
}

void sub_1000B6A18(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  _Block_object_dispose((const void *)(v31 - 176), 8);
  _Block_object_dispose(&a31, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000B6A64(uint64_t a1)
{
  long long v40 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v43 = 0u;
  id v1 = [*(id *)(a1 + 32) deps];
  uint64_t v2 = [v1 activeManagedViews];

  id obj = v2;
  id v3 = [v2 countByEnumeratingWithState:&v40 objects:v46 count:16];
  if (v3)
  {
    id v5 = v3;
    uint64_t v6 = *(void *)v41;
    CFStringRef v7 = @"ready";
    id v8 = @"ckksscan";
    *(void *)&long long v4 = 138412290;
    long long v35 = v4;
    uint64_t v36 = *(void *)v41;
    do
    {
      for (uint64_t i = 0; i != v5; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v41 != v6) {
          objc_enumerationMutation(obj);
        }
        id v10 = *(void **)(*((void *)&v40 + 1) + 8 * i);
        id v11 = [v10 viewKeyHierarchyState:v35];
        unsigned __int8 v12 = [v11 isEqualToString:v7];

        if (v12)
        {
          CFStringRef v13 = v7;
          uint64_t v14 = [v10 launch];
          [v14 addEvent:@"scan-local-items"];

          uint64_t v15 = [*(id *)(a1 + 32) deps];
          char v16 = [v15 contextID];
          [v10 zoneID];
          uint64_t v18 = v17 = v8;
          id v19 = [v18 zoneName];
          char v20 = +[CKKSZoneStateEntry contextID:v16 zoneName:v19];

          id v8 = v17;
          id v21 = +[NSDate now];
          [v20 setLastLocalKeychainScanTime:v21];

          id v39 = 0;
          [v20 saveToDatabase:&v39];
          id v22 = v39;
          unint64_t v23 = [v10 zoneID];
          id v24 = [v23 zoneName];
          __int16 v25 = sub_1000CD884(v17, v24);

          if (v22)
          {
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = v35;
              id v45 = v22;
              id v26 = v25;
              os_log_type_t v27 = OS_LOG_TYPE_ERROR;
              unint64_t v28 = "Unable to save 'scanned' bit: %@";
              uint32_t v29 = 12;
              goto LABEL_14;
            }
          }
          else if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            id v26 = v25;
            os_log_type_t v27 = OS_LOG_TYPE_DEFAULT;
            unint64_t v28 = "Saved scanned status.";
            uint32_t v29 = 2;
LABEL_14:
            _os_log_impl((void *)&_mh_execute_header, v26, v27, v28, buf, v29);
          }

          CFStringRef v7 = v13;
          uint64_t v6 = v36;
          goto LABEL_16;
        }
        uint64_t v30 = [v10 zoneID];
        uint64_t v31 = [v30 zoneName];
        char v20 = sub_1000CD884(v8, v31);

        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "View wasn't ready for scan", buf, 2u);
        }
LABEL_16:
      }
      id v5 = [obj countByEnumeratingWithState:&v40 objects:v46 count:16];
    }
    while (v5);
  }

  uint64_t v32 = [*(id *)(a1 + 32) deps];
  id v33 = [v32 overallLaunch];
  [v33 addEvent:@"scan-local-items"];

  return 1;
}

uint64_t sub_1000B6E0C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1000B6E1C(uint64_t a1)
{
}

void sub_1000B6E24(uint64_t a1, __CFString *a2)
{
  long long v4 = sub_1000CD884(@"ckksscan", 0);
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138477827;
    id v81 = a2;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "scanning item: %{private}@", buf, 0xCu);
  }

  [*(id *)(a1 + 32) setProcessedItems:((char *)[*(id *)(a1 + 32) processedItems] + 1)];
  if (sub_10011BAEC(a2))
  {
    id v5 = sub_1000CD884(@"ckksscan", 0);
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 138477827;
      id v81 = a2;
      _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "Skipping tombstone %{private}@", buf, 0xCu);
    }
    goto LABEL_69;
  }
  id v5 = sub_100119CB8(a2, kSecAttrAccessible);
  if (([v5 isEqualToString:kSecAttrAccessibleWhenUnlocked] & 1) == 0
    && ([v5 isEqualToString:kSecAttrAccessibleAfterFirstUnlock] & 1) == 0
    && ([v5 isEqualToString:kSecAttrAccessibleAlwaysPrivate] & 1) == 0)
  {
    CFStringRef v7 = sub_1000CD884(@"ckksscan", 0);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_68;
    }
    *(_DWORD *)long long buf = 138412290;
    id v81 = (__CFString *)v5;
    id v19 = "skipping sync of device-bound(%@) item";
    goto LABEL_40;
  }
  if (qword_10035D098 != -1) {
    dispatch_once(&qword_10035D098, &stru_100303AB8);
  }
  if (!byte_10035D090 && !sub_10011BA64(a2))
  {
    CFStringRef v7 = sub_1000CD884(@"ckksscan", 0);
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_68;
    }
    *(_DWORD *)long long buf = 138477827;
    id v81 = a2;
    id v19 = "Ignoring syncable keychain item for non-primary account: %{private}@";
LABEL_40:
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, v19, buf, 0xCu);
    goto LABEL_68;
  }
  uint64_t v6 = +[CKKSKey isItemKeyForKeychainView:a2];

  if (v6)
  {
    CFStringRef v7 = sub_1000CD884(@"ckksscan", 0);
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)long long buf = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEBUG, "Scanned item is a CKKS internal key, skipping", buf, 2u);
    }
    goto LABEL_68;
  }
  uint64_t v72 = v5;
  id v8 = [*(id *)(a1 + 32) deps];
  CFStringRef v7 = [v8 viewNameForItem:a2];

  long long v78 = 0u;
  long long v79 = 0u;
  long long v76 = 0u;
  long long v77 = 0u;
  uint64_t v71 = a1;
  CFRange v9 = [*(id *)(a1 + 32) deps];
  id v10 = [v9 activeManagedViews];

  id v11 = [v10 countByEnumeratingWithState:&v76 objects:v84 count:16];
  if (!v11) {
    goto LABEL_24;
  }
  id v12 = v11;
  uint64_t v13 = *(void *)v77;
  while (2)
  {
    for (uint64_t i = 0; i != v12; uint64_t i = (char *)i + 1)
    {
      if (*(void *)v77 != v13) {
        objc_enumerationMutation(v10);
      }
      uint64_t v15 = *(void **)(*((void *)&v76 + 1) + 8 * i);
      char v16 = [v15 zoneID];
      unsigned int v17 = [v16 zoneName];
      unsigned __int8 v18 = [v17 isEqualToString:v7];

      if (v18)
      {
        char v20 = v15;

        if (!v20) {
          goto LABEL_36;
        }
        id v75 = 0;
        id v21 = sub_100118CF8(a2, (uint64_t)&off_100305790, &v75);
        id v22 = (__CFString *)CFRetain(v21);
        id v5 = v72;
        if (!v22
          || (+[NSNull null],
              unint64_t v23 = objc_claimAutoreleasedReturnValue(),
              unsigned int v24 = [(__CFString *)v22 isEqual:v23],
              v23,
              v24))
        {
          __int16 v25 = [v20 zoneID];
          id v26 = [v25 zoneName];
          os_log_type_t v27 = sub_1000CD884(@"ckksscan", v26);

          if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138478083;
            id v81 = a2;
            __int16 v82 = 2112;
            id v83 = v75;
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "making new UUID for item %{private}@: %@", buf, 0x16u);
          }

          unint64_t v28 = sub_100118B3C(a2, 1, 0, &v75);
          id v29 = [(__CFDictionary *)v28 mutableCopy];

          [v29 setObject:*(void *)(v71 + 40) forKeyedSubscript:kSecClass];
          if (SecErrorGetOSStatus())
          {
            uint64_t v30 = [v20 zoneID];
            uint64_t v31 = [v30 zoneName];
            uint64_t v32 = sub_1000CD884(@"ckksscan", v31);

            if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 138412290;
              id v81 = v75;
              _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "couldn't copy UUID-less item's primary key: %@", buf, 0xCu);
            }

            uint64_t v33 = *(void *)(*(void *)(v71 + 72) + 8);
            id v34 = *(void **)(v33 + 40);
            *(void *)(v33 + 40) = v75;

            [*(id *)(v71 + 32) setError:*(void *)(*(void *)(*(void *)(v71 + 72) + 8) + 40)];
          }
          else
          {
            __int16 v52 = [*(id *)(v71 + 48) objectForKeyedSubscript:v20];
            if (!v52)
            {
              __int16 v52 = +[NSMutableSet set];
              [*(id *)(v71 + 48) setObject:v52 forKeyedSubscript:v20];
            }
            [v52 addObject:v29];
          }
          goto LABEL_66;
        }
        uint64_t v35 = v71;
        uint64_t v36 = [*(id *)(v71 + 32) deps];
        id v37 = [v36 contextID];
        uint64_t v38 = [v20 zoneID];
        id v39 = v22;
        long long v40 = (void *)v38;
        uint64_t v41 = *(void *)(*(void *)(v71 + 72) + 8);
        id obj = *(id *)(v41 + 40);
        long long v42 = v39;
        uint64_t v43 = +[CKKSMirrorEntry tryFromDatabase:contextID:zoneID:error:](CKKSMirrorEntry, "tryFromDatabase:contextID:zoneID:error:");
        uint64_t v44 = (id *)(v41 + 40);
        id v45 = (void *)v43;
        objc_storeStrong(v44, obj);

        if (v45)
        {
          id v46 = v45;
          id v22 = v42;
          [*(id *)(v71 + 56) removeObject:v42];
          id v47 = [v20 zoneID];
          NSErrorUserInfoKey v48 = [v47 zoneName];
          CFStringRef v49 = sub_1000CD884(@"ckksscan", v48);

          if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 138412290;
            id v81 = v42;
            _os_log_debug_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEBUG, "Existing mirror entry with UUID %@", buf, 0xCu);
          }

          id v50 = *(void **)(v71 + 32);
          uint64_t v51 = [v46 item];
          LOBYTE(v50) = [v50 areEquivalent:a2 ckksItem:v51 keyCache:*(void *)(*(void *)(*(void *)(v71 + 80) + 8) + 40)];

          if (v50)
          {
            id v29 = v46;
LABEL_66:

            goto LABEL_67;
          }
          uint64_t v35 = v71;
          id v53 = [v20 zoneID];
          __int16 v54 = [v53 zoneName];
          id v55 = sub_1000CD884(@"ckksscan", v54);

          if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138412290;
            id v81 = v42;
            _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "Existing mirror entry with UUID %@ does not match local item", buf, 0xCu);
          }

          id v45 = v46;
        }
        unsigned int v56 = [*(id *)(v35 + 32) deps:v45];
        [v56 contextID];
        v58 = uint64_t v57 = v35;
        id v59 = [v20 zoneID];
        uint64_t v60 = *(void *)(*(void *)(v57 + 72) + 8);
        id v73 = *(id *)(v60 + 40);
        long long v61 = +[CKKSOutgoingQueueEntry tryFromDatabase:v42 contextID:v58 zoneID:v59 error:&v73];
        objc_storeStrong((id *)(v60 + 40), v73);

        long long v62 = [v20 zoneID];
        id v63 = [v62 zoneName];
        id v64 = sub_1000CD884(@"ckksscan", v63);

        BOOL v65 = os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT);
        id v22 = v42;
        if (v61)
        {
          if (v65)
          {
            *(_DWORD *)long long buf = 138412290;
            id v81 = v42;
            _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "Existing outgoing queue entry with UUID %@", buf, 0xCu);
          }

          id v66 = [v61 state];
          unsigned int v67 = [v66 isEqualToString:@"new"];

          id v29 = v70;
          if (!v67) {
            goto LABEL_65;
          }
          id v68 = [*(id *)(v71 + 32) viewsWithNewCKKSEntries];
          [v68 addObject:v20];
        }
        else
        {
          if (v65)
          {
            *(_DWORD *)long long buf = 138412290;
            id v81 = v42;
            _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "Item(%@) is new; will attempt to add to CKKS",
              buf,
              0xCu);
          }

          [*(id *)(v71 + 32) setRecordsFound:((char *)[*(id *)(v71 + 32) recordsFound]) + 1];
          id v68 = [*(id *)(v71 + 64) objectForKeyedSubscript:v20];
          if (!v68)
          {
            id v68 = +[NSMutableDictionary dictionary];
            [*(id *)(v71 + 64) setObject:v68 forKeyedSubscript:v20];
          }
          id v69 = [v68 objectForKeyedSubscript:*(void *)(v71 + 40)];
          if (!v69)
          {
            id v69 = +[NSMutableSet set];
            [v68 setObject:v69 forKeyedSubscript:*(void *)(v71 + 40)];
          }
          [v69 addObject:v42];

          id v29 = v70;
        }

LABEL_65:
        goto LABEL_66;
      }
    }
    id v12 = [v10 countByEnumeratingWithState:&v76 objects:v84 count:16];
    if (v12) {
      continue;
    }
    break;
  }
LABEL_24:

LABEL_36:
  char v20 = sub_1000CD884(@"ckksscan", 0);
  id v5 = v72;
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 138412290;
    id v81 = (__CFString *)v7;
    _os_log_debug_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "Scanned item is for view %@, skipping", buf, 0xCu);
  }
LABEL_67:

LABEL_68:
LABEL_69:
}

uint64_t sub_1000B7A40(uint64_t a1)
{
  uint64_t v2 = sub_1000CD884(@"ckksscan", 0);
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    id v3 = [*(id *)(a1 + 32) count];
    long long v4 = *(void **)(a1 + 32);
    *(_DWORD *)long long buf = 134218242;
    id v46 = v3;
    __int16 v47 = 2112;
    id v48 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "BUG: keychain missing %lu items from mirror and/or queues: %@", buf, 0x16u);
  }

  [*(id *)(a1 + 40) setMissingLocalItemsFound:[*(id *)(a1 + 32) count]];
  id v5 = +[CKKSAnalytics logger];
  uint64_t v6 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [*(id *)(a1 + 32) count]);
  [v5 logMetric:v6 withName:@"CKKSEventMissingLocalItemsFound"];

  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  id obj = *(id *)(a1 + 32);
  id v33 = [obj countByEnumeratingWithState:&v39 objects:v44 count:16];
  id v8 = 0;
  if (v33)
  {
    uint64_t v9 = *(void *)v40;
    p_cache = OTDetermineCDPCapableAccountStatusOperation.cache;
    *(void *)&long long v7 = 138412546;
    long long v29 = v7;
    uint64_t v30 = *(void *)v40;
    do
    {
      id v11 = 0;
      id v12 = v8;
      do
      {
        if (*(void *)v40 != v9) {
          objc_enumerationMutation(obj);
        }
        uint64_t v13 = *(void **)(*((void *)&v39 + 1) + 8 * (void)v11);
        uint64_t v14 = [[*(id *)(a1 + 40) deps:v29];
        uint64_t v15 = [v14 contextID];
        id v38 = v12;
        char v16 = [p_cache + 463 allWithUUID:v13 contextID:v15 error:&v38];
        id v8 = v38;

        if (v16) {
          BOOL v17 = v8 == 0;
        }
        else {
          BOOL v17 = 0;
        }
        if (v17)
        {
          id v32 = v8;
          long long v36 = 0u;
          long long v37 = 0u;
          long long v34 = 0u;
          long long v35 = 0u;
          id v19 = v16;
          id v20 = [v19 countByEnumeratingWithState:&v34 objects:v43 count:16];
          if (v20)
          {
            id v21 = v20;
            uint64_t v22 = *(void *)v35;
            do
            {
              unint64_t v23 = 0;
              do
              {
                if (*(void *)v35 != v22) {
                  objc_enumerationMutation(v19);
                }
                unsigned int v24 = *(void **)(*((void *)&v34 + 1) + 8 * (void)v23);
                __int16 v25 = [*(id *)(a1 + 40) deps];
                id v26 = [v24 item];
                os_log_type_t v27 = [v26 storedCKRecord];
                [v25 intransactionCKRecordChanged:v27 resync:1];

                unint64_t v23 = (char *)v23 + 1;
              }
              while (v21 != v23);
              id v21 = [v19 countByEnumeratingWithState:&v34 objects:v43 count:16];
            }
            while (v21);
          }

          uint64_t v9 = v30;
          p_cache = (void **)(OTDetermineCDPCapableAccountStatusOperation + 16);
          id v8 = v32;
        }
        else
        {
          unsigned __int8 v18 = sub_1000CD884(@"ckksscan", 0);
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = v29;
            id v46 = v13;
            __int16 v47 = 2112;
            id v48 = v8;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "BUG: error fetching previously-extant CKME (uuid: %@) from database: %@", buf, 0x16u);
          }

          [*(id *)(a1 + 40) setError:v8];
        }

        id v11 = (char *)v11 + 1;
        id v12 = v8;
      }
      while (v11 != v33);
      id v33 = [obj countByEnumeratingWithState:&v39 objects:v44 count:16];
    }
    while (v33);
  }

  return 1;
}

uint64_t sub_1000B7FA8(id *a1)
{
  uint64_t v33 = 0;
  long long v34 = &v33;
  uint64_t v35 = 0x3032000000;
  long long v36 = sub_1000B6E0C;
  long long v37 = sub_1000B6E1C;
  id v38 = 0;
  v31[0] = 0;
  v31[1] = v31;
  v31[2] = 0x3032000000;
  v31[3] = sub_1000B6E0C;
  v31[4] = sub_1000B6E1C;
  id v32 = (CKKSMemoryKeyCache *)0xAAAAAAAAAAAAAAAALL;
  id v32 = objc_alloc_init(CKKSMemoryKeyCache);
  long long v27 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  id obj = a1[4];
  id v2 = [obj countByEnumeratingWithState:&v27 objects:v44 count:16];
  if (v2)
  {
    uint64_t v3 = *(void *)v28;
    while (2)
    {
      for (uint64_t i = 0; i != v2; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v28 != v3) {
          objc_enumerationMutation(obj);
        }
        uint64_t v5 = *(void *)(*((void *)&v27 + 1) + 8 * i);
        uint64_t v6 = [a1[5] zoneID];
        long long v7 = [v6 zoneName];
        id v8 = sub_1000CD884(@"ckksscan", v7);

        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 138412290;
          *(void *)((char *)&buf + 4) = v5;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Found item with no uuid: %@", (uint8_t *)&buf, 0xCu);
        }

        *(void *)&long long buf = 0;
        *((void *)&buf + 1) = &buf;
        uint64_t v42 = 0x2020000000;
        uint64_t v43 = 0;
        v21[0] = _NSConcreteStackBlock;
        v21[1] = 3221225472;
        void v21[2] = sub_1000B83F4;
        v21[3] = &unk_1002F91A0;
        void v21[4] = v5;
        p_long long buf = &buf;
        id v9 = a1[5];
        id v10 = a1[6];
        id v22 = v9;
        id v23 = v10;
        __int16 v25 = &v33;
        id v26 = v31;
        int v11 = sub_10000CBA4(1, 1, 0, (uint64_t)&v43, (uint64_t)v21);
        if (v11)
        {
          id v12 = *(const void **)(*((void *)&buf + 1) + 24);
          if (v12)
          {
            *(void *)(*((void *)&buf + 1) + 24) = 0;
            CFRelease(v12);
          }
        }
        else
        {
          uint64_t v13 = [a1[5] zoneID];
          uint64_t v14 = [v13 zoneName];
          uint64_t v15 = sub_1000CD884(@"ckksscan", v14);

          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            uint64_t v16 = *(void *)(*((void *)&buf + 1) + 24);
            *(_DWORD *)long long v39 = 138412290;
            uint64_t v40 = v16;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "couldn't execute query: %@", v39, 0xCu);
          }

          BOOL v17 = (void *)v34[5];
          v34[5] = *(void *)(*((void *)&buf + 1) + 24);

          [a1[6] setError:v34[5]];
        }

        _Block_object_dispose(&buf, 8);
        if (!v11)
        {
          uint64_t v18 = 0;
          goto LABEL_19;
        }
      }
      id v2 = [obj countByEnumeratingWithState:&v27 objects:v44 count:16];
      if (v2) {
        continue;
      }
      break;
    }
  }
  uint64_t v18 = 1;
LABEL_19:

  _Block_object_dispose(v31, 8);
  _Block_object_dispose(&v33, 8);

  return v18;
}

void sub_1000B8398(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37)
{
}

uint64_t sub_1000B83F4(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = sub_10000C3CC(*(const __CFDictionary **)(a1 + 32), 0, -1, 0, (__CFString **)(*(void *)(*(void *)(a1 + 56) + 8) + 24));
  if (v4
    && (uint64_t v5 = *(void *)(*(void *)(a1 + 56) + 8), v7 = *(void *)(v5 + 24), v6 = (__CFString **)(v5 + 24), !v7))
  {
    uint64_t v14 = v4;
    *(void *)&long long buf = 0;
    *((void *)&buf + 1) = &buf;
    uint64_t v28 = 0x2020000000;
    char v29 = 1;
    v20[0] = _NSConcreteStackBlock;
    v20[1] = 3221225472;
    int v20[2] = sub_1000B8634;
    v20[3] = &unk_1002F9178;
    id v21 = *(id *)(a1 + 40);
    long long v15 = *(_OWORD *)(a1 + 64);
    long long v22 = *(_OWORD *)(a1 + 48);
    uint64_t v25 = a2;
    uint64_t v26 = v14;
    long long v23 = v15;
    p_long long buf = &buf;
    BOOL v16 = sub_100138F00(v14, 0, a2, v6, (uint64_t)v20);
    if (*(unsigned char *)(*((void *)&buf + 1) + 24)) {
      int v17 = v16;
    }
    else {
      int v17 = 0;
    }
    *(unsigned char *)(*((void *)&buf + 1) + 24) = v17;
    char v18 = sub_100129708(v14, v17, (CFErrorRef *)(*(void *)(*(void *)(a1 + 56) + 8) + 24));
    if (*(unsigned char *)(*((void *)&buf + 1) + 24)) {
      char v19 = v18;
    }
    else {
      char v19 = 0;
    }
    *(unsigned char *)(*((void *)&buf + 1) + 24) = v19;

    _Block_object_dispose(&buf, 8);
    return 1;
  }
  else
  {
    id v8 = [*(id *)(a1 + 40) zoneID];
    id v9 = [v8 zoneName];
    id v10 = sub_1000CD884(@"ckksscan", v9);

    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      uint64_t v11 = *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "couldn't create query: %@", (uint8_t *)&buf, 0xCu);
    }

    uint64_t v12 = *(void *)(*(void *)(a1 + 56) + 8);
    uint64_t result = *(void *)(v12 + 24);
    if (result)
    {
      *(void *)(v12 + 24) = 0;
      CFRelease((CFTypeRef)result);
      return 0;
    }
  }
  return result;
}

void sub_1000B8634(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = +[NSUUID UUID];
  uint64_t v5 = [v4 UUIDString];

  uint64_t v39 = kSecAttrUUID;
  uint64_t v40 = v5;
  CFDictionaryRef v6 = +[NSDictionary dictionaryWithObjects:&v40 forKeys:&v39 count:1];
  uint64_t v7 = [*(id *)(a1 + 32) zoneID];
  id v8 = [v7 zoneName];
  id v9 = sub_1000CD884(@"ckksscan", v8);

  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412547;
    long long v36 = v5;
    __int16 v37 = 2113;
    uint64_t v38 = a2;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Assigning new UUID %@ for item %{private}@", buf, 0x16u);
  }

  id v10 = sub_10011B3B4(a2, v6, (__CFString **)(*(void *)(*(void *)(a1 + 48) + 8) + 24));
  if (v10)
  {
    uint64_t v11 = v10;
    uint64_t v12 = *(void *)(a1 + 48);
    uint64_t v13 = (CFTypeRef *)(*(void *)(v12 + 8) + 24);
    v33[0] = _NSConcreteStackBlock;
    v33[1] = 3221225472;
    v33[2] = sub_1000B89D0;
    v33[3] = &unk_1002F9150;
    void v33[5] = a2;
    v33[6] = v10;
    long long v34 = *(_OWORD *)(a1 + 80);
    void v33[4] = v12;
    BOOL v14 = sub_1001381F8(v34, 5, v13, (uint64_t)v33);
    if (v14)
    {
      uint64_t v16 = *(void *)(a1 + 32);
      long long v15 = *(void **)(a1 + 40);
      uint64_t v17 = *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
      uint64_t v18 = *(void *)(*(void *)(a1 + 56) + 8);
      id v32 = *(id *)(v18 + 40);
      [v15 onboardItemToCKKS:v11 viewState:v16 keyCache:v17 error:&v32];
      id v19 = v32;
      id v20 = *(NSObject **)(v18 + 40);
      *(void *)(v18 + 40) = v19;
    }
    else
    {
      long long v27 = [*(id *)(a1 + 32) zoneID];
      uint64_t v28 = [v27 zoneName];
      id v20 = sub_1000CD884(@"ckksscan", v28);

      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        char v29 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
        *(_DWORD *)long long buf = 138412290;
        long long v36 = v29;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Unable to update item with new UUID: %@", buf, 0xCu);
      }
    }

    uint64_t v30 = *(void *)(*(void *)(a1 + 72) + 8);
    if (*(unsigned char *)(v30 + 24)) {
      BOOL v31 = v14;
    }
    else {
      BOOL v31 = 0;
    }
    *(unsigned char *)(v30 + 24) = v31;
  }
  else
  {
    id v21 = [*(id *)(a1 + 32) zoneID];
    long long v22 = [v21 zoneName];
    long long v23 = sub_1000CD884(@"ckksscan", v22);

    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v24 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
      *(_DWORD *)long long buf = 138412290;
      long long v36 = v24;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Unable to copy item with new UUID: %@", buf, 0xCu);
    }

    uint64_t v25 = *(void *)(*(void *)(a1 + 56) + 8);
    uint64_t v26 = *(void **)(v25 + 40);
    *(void *)(v25 + 40) = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);

    [*(id *)(a1 + 40) setError:*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40)];
  }
}

uint64_t sub_1000B89D0(uint64_t a1)
{
  return sub_10011E680(*(void ***)(a1 + 40), *(void ***)(a1 + 48), *(void *)(a1 + 56), kCFBooleanFalse, *(unsigned __int8 *)(*(void *)(a1 + 64) + 154), (__CFString **)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
}

uint64_t sub_1000B8C4C(uint64_t a1)
{
  id v2 = objc_alloc_init(CKKSMemoryKeyCache);
  v32[0] = kSecClass;
  v32[1] = kSecReturnRef;
  uint64_t v3 = *(void *)(a1 + 40);
  v33[0] = *(void *)(a1 + 32);
  v33[1] = &__kCFBooleanTrue;
  v32[2] = kSecAttrSynchronizable;
  v32[3] = kSecAttrTombstone;
  v33[2] = &__kCFBooleanTrue;
  v33[3] = &__kCFBooleanFalse;
  void v32[4] = kSecAttrUUID;
  void v33[4] = v3;
  uint64_t v4 = +[NSDictionary dictionaryWithObjects:v33 forKeys:v32 count:5];
  uint64_t v5 = [*(id *)(a1 + 48) zoneID];
  CFDictionaryRef v6 = [v5 zoneName];
  uint64_t v7 = sub_1000CD884(@"ckksscan", v6);

  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v9 = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = v8;
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v9;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Onboarding %@ %@", buf, 0x16u);
  }

  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&uint8_t buf[16] = 0x3032000000;
  char v29 = sub_1000B6E0C;
  uint64_t v30 = sub_1000B6E1C;
  id v31 = 0;
  id v10 = *(void **)(a1 + 56);
  id obj = 0;
  v19[0] = _NSConcreteStackBlock;
  v19[1] = 3221225472;
  v19[2] = sub_1000B8FC4;
  v19[3] = &unk_1002F9128;
  void v19[4] = v10;
  id v20 = *(id *)(a1 + 48);
  uint64_t v11 = v2;
  id v21 = v11;
  long long v22 = buf;
  [v10 executeQuery:v4 readWrite:1 error:&obj block:v19];
  objc_storeStrong(&v31, obj);
  if (*(void *)(*(void *)&buf[8] + 40))
  {
    uint64_t v12 = [*(id *)(a1 + 48) zoneID];
    uint64_t v13 = [v12 zoneName];
    BOOL v14 = sub_1000CD884(@"ckksscan", v13);

    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      uint64_t v15 = *(void *)(a1 + 40);
      uint64_t v16 = *(void *)(*(void *)&buf[8] + 40);
      *(_DWORD *)unsigned int v24 = 138412546;
      uint64_t v25 = v15;
      __int16 v26 = 2112;
      uint64_t v27 = v16;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Need to upload %@, but can't save to database: %@", v24, 0x16u);
    }

    [*(id *)(a1 + 56) setError:*(void *)(*(void *)&buf[8] + 40)];
    uint64_t v17 = 0;
  }
  else
  {
    uint64_t v17 = 1;
  }

  _Block_object_dispose(buf, 8);
  return v17;
}

void sub_1000B8FA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000B8FC4(void *a1, uint64_t a2)
{
  uint64_t v3 = (void *)a1[4];
  uint64_t v2 = a1[5];
  uint64_t v4 = a1[6];
  uint64_t v5 = *(void *)(a1[7] + 8);
  id obj = *(id *)(v5 + 40);
  [v3 onboardItemToCKKS:a2 viewState:v2 keyCache:v4 error:&obj];
  objc_storeStrong((id *)(v5 + 40), obj);
}

void sub_1000B95E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_1000B9608(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 48);
  uint64_t v4 = (__CFString **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_1000B96BC;
  v7[3] = &unk_1002F90D8;
  id v8 = *(id *)(a1 + 32);
  BOOL v5 = sub_100138F00(v3, 0, a2, v4, (uint64_t)v7);

  return v5;
}

uint64_t sub_1000B96BC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000BA4BC(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 120));
  _Unwind_Resume(a1);
}

void sub_1000BA4EC(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  BOOL v14 = WeakRetained;
  if (!v12)
  {
    [WeakRetained setPeerID:v9];
    id v20 = +[CKKSAnalytics logger];
    [v20 logSuccessForEventNamed:@"OctagonEventJoinWithVoucher"];

    id v21 = [v14 deps];
    long long v22 = [v21 ckks];
    [v22 setCurrentSyncingPolicy:v11];

    long long v23 = [v14 deps];
    unsigned int v24 = [v23 stateHolder];
    v34[0] = _NSConcreteStackBlock;
    v34[1] = 3221225472;
    v34[2] = sub_1000BA980;
    v34[3] = &unk_1002FAEE8;
    id v35 = v9;
    id v36 = v11;
    id v33 = 0;
    unsigned int v25 = [v24 persistAccountChanges:v34 error:&v33];
    id v19 = v33;

    if (!v25 || v19)
    {
      char v29 = sub_10000B070("octagon");
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v38 = v19;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Couldn't persist results: %@", buf, 0xCu);
      }

      [v14 setError:v19];
    }
    else
    {
      __int16 v26 = sub_10000B070("SecError");
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "octagon: join successful", buf, 2u);
      }

      uint64_t v27 = [v14 intendedState];
      [v14 setNextState:v27];
    }
    uint64_t v30 = [v14 deps];
    id v31 = [v30 ckks];
    [v31 receiveTLKUploadRecords:v10];

    goto LABEL_22;
  }
  uint64_t v15 = sub_10000B070("SecError");
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    id v38 = v12;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "octagon: Error joining with voucher: %@", buf, 0xCu);
  }

  uint64_t v16 = +[CKKSAnalytics logger];
  [v16 logRecoverableError:v12 forEvent:@"OctagonEventJoinWithVoucher" withAttributes:0];

  if ([v12 isCuttlefishError:1033])
  {
    uint64_t v17 = sub_10000B070("octagon-ckks");
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = [v14 ckksConflictState];
      *(_DWORD *)long long buf = 138412290;
      id v38 = v18;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "A CKKS key hierarchy is out of date; going to state '%@'",
        buf,
        0xCu);
    }
    id v19 = [v14 ckksConflictState];
    [v14 setNextState:v19];
LABEL_22:

    goto LABEL_23;
  }
  if ([v12 isCuttlefishError:1007])
  {
    uint64_t v28 = sub_10000B070("octagon");
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "requesting cuttlefish health check", buf, 2u);
    }

    [v14 setNextState:@"CuttlefishTrustCheck"];
  }
  [v14 setError:v12];
LABEL_23:
  id v32 = [v14 finishedOp];
  [v14 runBeforeGroupFinished:v32];
}

id sub_1000BA980(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 setTrustState:2];
  [v3 setPeerID:*(void *)(a1 + 32)];
  [v3 setVoucher:0];
  [v3 setVoucherSignature:0];
  uint64_t v4 = [v3 tlkSharesForVouchedIdentitys];
  [v4 removeAllObjects];

  [v3 setTPSyncingPolicy:*(void *)(a1 + 40)];

  return v3;
}

uint64_t sub_1000BBCAC(uint64_t a1)
{
  return 1;
}

void sub_1000BC66C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = [v5 zoneID];
  unsigned int v8 = [v7 isEqual:*(void *)(a1 + 32)];

  if (v8)
  {
    id v9 = [*(id *)(a1 + 32) zoneName];
    id v10 = sub_1000CD884(@"ckksfetch", v9);

    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      int v11 = 138412546;
      id v12 = v5;
      __int16 v13 = 2112;
      id v14 = v6;
      _os_log_debug_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "Sorting record modification %@: %@", (uint8_t *)&v11, 0x16u);
    }

    [*(id *)(a1 + 40) addObject:v6];
  }
}

void sub_1000BC7A0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = [v5 zoneID];
  unsigned int v8 = [v7 isEqual:*(void *)(a1 + 32)];

  if (v8)
  {
    id v9 = [*(id *)(a1 + 32) zoneName];
    id v10 = sub_1000CD884(@"ckksfetch", v9);

    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      int v11 = 138412546;
      id v12 = v5;
      __int16 v13 = 2112;
      id v14 = v6;
      _os_log_debug_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEBUG, "Sorting record deletion %@: %@", (uint8_t *)&v11, 0x16u);
    }

    [*(id *)(a1 + 40) addObject:v6];
  }
}

void sub_1000BD310(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,id location)
{
}

void sub_1000BD3B0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v5 = sub_1000CD884(@"ckksfetch", 0);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    id v10 = [v3 recordType];
    int v11 = 138412546;
    id v12 = v10;
    __int16 v13 = 2112;
    id v14 = v3;
    _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "CloudKit notification: record changed(%@): %@", (uint8_t *)&v11, 0x16u);
  }
  id v6 = [WeakRetained modifications];
  uint64_t v7 = [v3 recordID];
  [v6 setObject:v3 forKeyedSubscript:v7];

  unsigned int v8 = [WeakRetained deletions];
  id v9 = [v3 recordID];
  [v8 removeObjectForKey:v9];

  [WeakRetained setFetchedItems:((char *)[WeakRetained fetchedItems]) + 1];
}

void sub_1000BD528(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  unsigned int v8 = sub_1000CD884(@"ckksfetch", 0);
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
  {
    int v12 = 138412546;
    id v13 = v6;
    __int16 v14 = 2112;
    id v15 = v5;
    _os_log_debug_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "CloudKit notification: deleted record(%@): %@", (uint8_t *)&v12, 0x16u);
  }

  id v9 = [WeakRetained modifications];
  [v9 removeObjectForKey:v5];

  id v10 = [[CKKSCloudKitDeletion alloc] initWithRecordID:v5 recordType:v6];
  int v11 = [WeakRetained deletions];
  [v11 setObject:v10 forKeyedSubscript:v5];

  [WeakRetained setFetchedItems:((char *)[WeakRetained fetchedItems]) + 1];
}

void sub_1000BD694(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  int v11 = sub_1000CD884(@"ckksfetch", 0);
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
  {
    int v13 = 138412802;
    id v14 = v7;
    __int16 v15 = 2112;
    id v16 = v8;
    __int16 v17 = 2112;
    id v18 = v9;
    _os_log_debug_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "Received a new server change token (via block) for %@: %@ %@", (uint8_t *)&v13, 0x20u);
  }

  int v12 = [WeakRetained changeTokens];
  [v12 setObject:v8 forKeyedSubscript:v7];
}

void sub_1000BD7C8(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5, void *a6)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a4;
  id v14 = a6;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v16 = sub_1000CD884(@"ckksfetch", 0);
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
  {
    int v28 = 138412802;
    id v29 = v11;
    __int16 v30 = 2112;
    id v31 = v12;
    __int16 v32 = 2112;
    v33[0] = v13;
    _os_log_debug_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "Received a new server change token for %@: %@ %@", (uint8_t *)&v28, 0x20u);
  }

  __int16 v17 = [WeakRetained changeTokens];
  [v17 setObject:v12 forKeyedSubscript:v11];

  id v18 = [WeakRetained allClientOptions];
  id v19 = [v18 objectForKeyedSubscript:v11];
  [v19 setPreviousServerChangeToken:v12];

  [WeakRetained setMoreComing:[WeakRetained moreComing] | a5];
  id v20 = *(void **)(a1 + 32);
  uint64_t v34 = kSecurityRTCFieldFullFetch;
  id v21 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", [WeakRetained moreComing]);
  id v35 = v21;
  long long v22 = +[NSDictionary dictionaryWithObjects:&v35 forKeys:&v34 count:1];
  [v20 addMetrics:v22];

  if (a5)
  {
    long long v23 = sub_1000CD884(@"ckksfetch", 0);
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v24 = [WeakRetained changeTokens];
      unsigned int v25 = [v24 objectForKeyedSubscript:v11];
      int v28 = 138412546;
      id v29 = v11;
      __int16 v30 = 2112;
      id v31 = v25;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "more changes pending for %@, will start a new fetch at change token %@", (uint8_t *)&v28, 0x16u);
    }
  }
  __int16 v26 = [v11 zoneName];
  uint64_t v27 = sub_1000CD884(@"ckksfetch", v26);

  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
  {
    int v28 = 138413058;
    id v29 = v12;
    __int16 v30 = 2112;
    id v31 = v13;
    __int16 v32 = 1024;
    LODWORD(v33[0]) = a5;
    WORD2(v33[0]) = 2112;
    *(void *)((char *)v33 + 6) = v14;
    _os_log_debug_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEBUG, "Record zone fetch complete: changeToken=%@ clientChangeTokenData=%@ moreComing=%{BOOL}d error=%@", (uint8_t *)&v28, 0x26u);
  }

  [WeakRetained sendChangesToClient:v11 moreComing:a5];
}

void sub_1000BDB10(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    id v5 = +[NSMutableDictionary dictionary];
    id v6 = [WeakRetained modifications];
    [WeakRetained setTotalModifications:([v6 count] + [WeakRetained totalModifications])];

    id v7 = [WeakRetained deletions];
    [WeakRetained setTotalDeletions:([v7 count] + [WeakRetained totalDeletions])];

    id v8 = [WeakRetained modifications];
    [v8 removeAllObjects];

    id v9 = [WeakRetained deletions];
    [v9 removeAllObjects];

    if ([WeakRetained moreComing])
    {
      if (!v3
        || +[CKKSReachabilityTracker isNetworkFailureError:v3])
      {
        id v10 = sub_1000CD884(@"ckksfetch", 0);
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          id v126 = v3;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Must issue another fetch (with potential error %@)", buf, 0xCu);
        }

        [WeakRetained setMoreComing:0];
        +[SecurityAnalyticsReporterRTC sendMetricWithEvent:*(void *)(a1 + 32) success:0 error:v3];
        [WeakRetained performFetch];
        goto LABEL_61;
      }
    }
    else if (!v3)
    {
      id v11 = &off_100325EE8;
      goto LABEL_13;
    }
    [WeakRetained setError:v3];
    id v11 = &off_100325ED0;
LABEL_13:
    __int16 v88 = v11;
    uint64_t v86 = a1;
    id v12 = sub_1000CD884(@"ckksfetcher", 0);
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v126 = v3;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Record zone changes fetch complete: error=%@", buf, 0xCu);
    }

    +[CKKSPowerCollection CKKSPowerEvent:count:](CKKSPowerCollection, "CKKSPowerEvent:count:", @"fetchAllChanges", [WeakRetained fetchedItems]);
    long long v116 = 0u;
    long long v117 = 0u;
    long long v114 = 0u;
    long long v115 = 0u;
    id v13 = [WeakRetained modifications];
    id v14 = [v13 countByEnumeratingWithState:&v114 objects:v124 count:16];
    if (v14)
    {
      id v15 = v14;
      uint64_t v16 = *(void *)v115;
      do
      {
        for (uint64_t i = 0; i != v15; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v115 != v16) {
            objc_enumerationMutation(v13);
          }
          id v18 = *(void **)(*((void *)&v114 + 1) + 8 * i);
          id v19 = [v18 zoneID];
          id v20 = [v5 objectForKeyedSubscript:v19];

          if (v20) {
            id v21 = (char *)[v20 unsignedLongValue];
          }
          else {
            id v21 = 0;
          }
          long long v22 = +[NSNumber numberWithUnsignedLong:v21 + 1];
          long long v23 = [v18 zoneID];
          [v5 setObject:v22 forKeyedSubscript:v23];
        }
        id v15 = [v13 countByEnumeratingWithState:&v114 objects:v124 count:16];
      }
      while (v15);
    }

    long long v112 = 0u;
    long long v113 = 0u;
    long long v110 = 0u;
    long long v111 = 0u;
    unsigned int v24 = [WeakRetained deletions];
    id v25 = [v24 countByEnumeratingWithState:&v110 objects:v123 count:16];
    if (v25)
    {
      id v26 = v25;
      uint64_t v27 = *(void *)v111;
      do
      {
        for (j = 0; j != v26; j = (char *)j + 1)
        {
          if (*(void *)v111 != v27) {
            objc_enumerationMutation(v24);
          }
          id v29 = *(void **)(*((void *)&v110 + 1) + 8 * (void)j);
          __int16 v30 = [v29 zoneID];
          id v31 = [v5 objectForKeyedSubscript:v30];

          if (v31) {
            __int16 v32 = (char *)[v31 unsignedLongValue];
          }
          else {
            __int16 v32 = 0;
          }
          id v33 = +[NSNumber numberWithUnsignedLong:v32 + 1];
          uint64_t v34 = [v29 zoneID];
          [v5 setObject:v33 forKeyedSubscript:v34];
        }
        id v26 = [v24 countByEnumeratingWithState:&v110 objects:v123 count:16];
      }
      while (v26);
    }

    long long v108 = 0u;
    long long v109 = 0u;
    long long v106 = 0u;
    long long v107 = 0u;
    id obj = [WeakRetained apnsPushes];
    id v35 = [obj countByEnumeratingWithState:&v106 objects:v122 count:16];
    if (v35)
    {
      id v36 = v35;
      uint64_t v37 = *(void *)v107;
      id v91 = v5;
      id v92 = v3;
      uint64_t v87 = *(void *)v107;
      do
      {
        id v38 = 0;
        id v89 = v36;
        do
        {
          if (*(void *)v107 != v37) {
            objc_enumerationMutation(obj);
          }
          uint64_t v39 = *(void **)(*((void *)&v106 + 1) + 8 * (void)v38);
          if ([v39 ckksPushTracingEnabled])
          {
            uint64_t v40 = sub_1000CD884(@"ckksfetch", 0);
            if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 138412290;
              id v126 = v39;
              _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "Submitting post-fetch CKEventMetric due to notification %@", buf, 0xCu);
            }

            id v41 = [objc_alloc((Class)CKEventMetric) initWithEventName:@"APNSPushMetrics"];
            [v41 setIsPushTriggerFired:1];
            uint64_t v42 = [v39 ckksPushTracingUUID];
            [v41 setObject:v42 forKeyedSubscript:@"push_token_uuid"];

            uint64_t v43 = [v39 ckksPushReceivedDate];
            [v41 setObject:v43 forKeyedSubscript:@"push_received_date"];

            [v41 setObject:@"CKKS Push" forKeyedSubscript:@"push_event_name"];
            [v41 setObject:v88 forKeyedSubscript:@"fetch_error"];
            uint64_t v44 = [v3 domain];
            [v41 setObject:v44 forKeyedSubscript:@"fetch_error_domain"];

            id v45 = +[NSNumber numberWithLong:](NSNumber, "numberWithLong:", [v3 code]);
            [v41 setObject:v45 forKeyedSubscript:@"fetch_error_code"];

            id v46 = +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", [WeakRetained totalModifications]);
            [v41 setObject:v46 forKeyedSubscript:@"total_modifications"];

            __int16 v47 = WeakRetained;
            id v48 = +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", [WeakRetained totalDeletions]);
            [v41 setObject:v48 forKeyedSubscript:@"total_deletions"];

            long long v104 = 0u;
            long long v105 = 0u;
            long long v102 = 0u;
            long long v103 = 0u;
            CFStringRef v49 = v91;
            id v50 = [v49 countByEnumeratingWithState:&v102 objects:v121 count:16];
            if (v50)
            {
              id v51 = v50;
              uint64_t v52 = *(void *)v103;
              do
              {
                for (k = 0; k != v51; k = (char *)k + 1)
                {
                  if (*(void *)v103 != v52) {
                    objc_enumerationMutation(v49);
                  }
                  __int16 v54 = *(void **)(*((void *)&v102 + 1) + 8 * (void)k);
                  id v55 = [v49 objectForKeyedSubscript:v54];
                  unsigned int v56 = [v54 zoneName];
                  [v41 setObject:v55 forKeyedSubscript:v56];
                }
                id v51 = [v49 countByEnumeratingWithState:&v102 objects:v121 count:16];
              }
              while (v51);
            }

            uint64_t v57 = [[SecEventMetric alloc] initWithEventName:@"APNSPushMetrics"];
            id v58 = [v39 ckksPushTracingUUID];
            [(SecEventMetric *)v57 setObject:v58 forKeyedSubscript:@"push_token_uuid"];

            id v59 = [v39 ckksPushReceivedDate];
            [(SecEventMetric *)v57 setObject:v59 forKeyedSubscript:@"push_received_date"];

            [(SecEventMetric *)v57 setObject:@"CKKS Push-webtunnel" forKeyedSubscript:@"push_event_name"];
            [(SecEventMetric *)v57 setObject:v92 forKeyedSubscript:@"fetch_error"];
            uint64_t v60 = +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", [v47 totalModifications]);
            [(SecEventMetric *)v57 setObject:v60 forKeyedSubscript:@"total_modifications"];

            long long v61 = +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", [v47 totalDeletions]);
            [(SecEventMetric *)v57 setObject:v61 forKeyedSubscript:@"total_deletions"];

            long long v100 = 0u;
            long long v101 = 0u;
            long long v98 = 0u;
            long long v99 = 0u;
            long long v62 = v49;
            id v63 = [v62 countByEnumeratingWithState:&v98 objects:v120 count:16];
            if (v63)
            {
              id v64 = v63;
              uint64_t v65 = *(void *)v99;
              do
              {
                for (m = 0; m != v64; m = (char *)m + 1)
                {
                  if (*(void *)v99 != v65) {
                    objc_enumerationMutation(v62);
                  }
                  unsigned int v67 = *(void **)(*((void *)&v98 + 1) + 8 * (void)m);
                  id v68 = [v62 objectForKeyedSubscript:v67];
                  id v69 = [v67 zoneName];
                  [(SecEventMetric *)v57 setObject:v68 forKeyedSubscript:v69];
                }
                id v64 = [v62 countByEnumeratingWithState:&v98 objects:v120 count:16];
              }
              while (v64);
            }

            id WeakRetained = v47;
            uint64_t v70 = [v47 container];
            uint64_t v71 = [v47 fetchRecordZoneChangesOperation];
            v93[0] = _NSConcreteStackBlock;
            v93[1] = 3221225472;
            v93[2] = sub_1000BE79C;
            v93[3] = &unk_1003059E8;
            id v94 = v41;
            id v95 = v71;
            id v96 = v70;
            id v97 = v57;
            uint64_t v72 = v57;
            id v73 = v70;
            id v74 = v71;
            id v75 = v41;
            long long v76 = +[CKKSResultOperation named:@"submit-metric" withBlock:v93];
            long long v77 = [v47 fetchCompletedOperation];
            [v76 addSuccessDependency:v77];

            long long v78 = [v47 operationQueue];
            [v78 addOperation:v76];

            id v5 = v91;
            id v3 = v92;
            id v36 = v89;
            uint64_t v37 = v87;
          }
          id v38 = (char *)v38 + 1;
        }
        while (v38 != v36);
        id v36 = [obj countByEnumeratingWithState:&v106 objects:v122 count:16];
      }
      while (v36);
    }

    long long v79 = [WeakRetained fetchCompletedOperation];
    [WeakRetained runBeforeGroupFinished:v79];

    [WeakRetained setClientMap:&__NSDictionary0__struct];
    long long v80 = *(void **)(v86 + 32);
    v118[0] = kSecurityRTCFieldNumKeychainItems;
    id v81 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [WeakRetained fetchedItems]);
    v119[0] = v81;
    v118[1] = kSecurityRTCFieldTotalCKRecords;
    __int16 v82 = +[NSNumber numberWithUnsignedLong:](NSNumber, "numberWithUnsignedLong:", (char *)[WeakRetained totalDeletions] + (void)objc_msgSend(WeakRetained, "totalModifications"));
    v119[1] = v82;
    id v83 = +[NSDictionary dictionaryWithObjects:v119 forKeys:v118 count:2];
    [v80 addMetrics:v83];

    uint64_t v84 = *(void *)(v86 + 32);
    id v85 = [WeakRetained error];
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v84 success:1 error:v85];

    goto LABEL_61;
  }
  id v5 = sub_1000CD884(@"ckksfetch", 0);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "received callback for released object", buf, 2u);
  }
LABEL_61:
}

void sub_1000BE79C(uint64_t a1)
{
  if (([*(id *)(a1 + 32) associateWithCompletedOperation:*(void *)(a1 + 40)] & 1) == 0)
  {
    uint64_t v2 = sub_1000CD884(@"ckksfetch", 0);
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      uint64_t v3 = *(void *)(a1 + 32);
      uint64_t v4 = *(void *)(a1 + 40);
      int v8 = 138412546;
      uint64_t v9 = v3;
      __int16 v10 = 2112;
      uint64_t v11 = v4;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "Couldn't associate metric with operation: %@ %@", (uint8_t *)&v8, 0x16u);
    }
  }
  [*(id *)(a1 + 48) submitEventMetric:*(void *)(a1 + 32)];
  id v5 = +[SecMetrics managerObject];
  [v5 submitEvent:*(void *)(a1 + 56)];

  id v6 = sub_1000CD884(@"ckksfetch", 0);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a1 + 32);
    int v8 = 138412290;
    uint64_t v9 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Metric submitted: %@", (uint8_t *)&v8, 0xCu);
  }
}

id sub_1000C04F8(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) completed];
  if ((result & 1) == 0)
  {
    uint64_t v3 = *(void **)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    return [v3 onqueueStartFinishOperation:v4];
  }
  return result;
}

void sub_1000C1334(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,char a45)
{
}

uint64_t sub_1000C1354(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1000C1364(uint64_t a1)
{
}

void sub_1000C136C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  __int16 v10 = KCSharingLogObject();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
  {
    int v19 = 138478339;
    id v20 = v7;
    __int16 v21 = 2113;
    id v22 = v8;
    __int16 v23 = 2114;
    id v24 = v9;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "fetch result for lookupInfo %{private}@: participant %{private}@ error %{public}@", (uint8_t *)&v19, 0x20u);
  }

  uint64_t v11 = sub_100046C24(v7);
  if (v11)
  {
    id v12 = [*(id *)(a1 + 32) objectForKeyedSubscript:v11];
    id v13 = v12;
    if (v8 && v12)
    {
      unint64_t v14 = (unint64_t)[v12 permissionLevel];
      if (v14 > 2) {
        uint64_t v15 = 0;
      }
      else {
        uint64_t v15 = qword_100265630[v14];
      }
      unint64_t v17 = (unint64_t)[v13 permissionLevel];
      if (v17 > 2) {
        uint64_t v18 = 0;
      }
      else {
        uint64_t v18 = qword_100265648[v17];
      }
      [v8 setRole:v15];
      [v8 setPermission:v18];
      [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) setObject:v8 forKeyedSubscript:v11];
    }
    else
    {
      uint64_t v16 = KCSharingLogObject();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        int v19 = 138478083;
        id v20 = v7;
        __int16 v21 = 2113;
        id v22 = v11;
        _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "could not find CKShareParticipant or KCSharingParticipant for lookupinfo %{private}@ handle %{private}@", (uint8_t *)&v19, 0x16u);
      }
    }
  }
  else
  {
    id v13 = KCSharingLogObject();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      int v19 = 138477827;
      id v20 = v7;
      _os_log_error_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "Could not find handle for lookupinfo %{private}@", (uint8_t *)&v19, 0xCu);
    }
  }
}

void sub_1000C15E8(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    uint64_t v4 = KCSharingLogObject();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v6 = 138543362;
      id v7 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to fetch share participants: %{public}@", (uint8_t *)&v6, 0xCu);
    }

    id v5 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
  }
  else
  {
    id v5 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
  }
  v5();
}

void sub_1000C1A0C(uint64_t a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  if (a3)
  {
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    int v6 = +[NSMutableDictionary dictionaryWithCapacity:](NSMutableDictionary, "dictionaryWithCapacity:", [*(id *)(a1 + 32) count]);
    long long v26 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    uint64_t v21 = a1;
    id obj = *(id *)(a1 + 32);
    id v25 = [obj countByEnumeratingWithState:&v26 objects:v32 count:16];
    if (v25)
    {
      uint64_t v7 = *(void *)v27;
      id v8 = NSMutableString_ptr;
      id v22 = v5;
      __int16 v23 = v6;
      do
      {
        for (uint64_t i = 0; i != v25; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v27 != v7) {
            objc_enumerationMutation(obj);
          }
          uint64_t v10 = *(void *)(*((void *)&v26 + 1) + 8 * i);
          uint64_t v11 = [v5 objectForKeyedSubscript:v10];
          id v12 = [v11 userIdentity];
          if ([v12 hasiCloudAccount])
          {
            id v13 = [v5 objectForKeyedSubscript:v10];
            unint64_t v14 = [v13 userIdentity];
            [v14 publicSharingKey];
            uint64_t v15 = v8;
            v17 = uint64_t v16 = v7;
            BOOL v18 = [v17 length] != 0;

            uint64_t v7 = v16;
            id v8 = v15;

            id v5 = v22;
            int v6 = v23;
          }
          else
          {
            BOOL v18 = 0;
          }

          int v19 = [v8[4] numberWithBool:v18];
          [v6 setObject:v19 forKeyedSubscript:v10];
        }
        id v25 = [obj countByEnumeratingWithState:&v26 objects:v32 count:16];
      }
      while (v25);
    }

    id v20 = KCSharingLogObject();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138477827;
      id v31 = v6;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "availability results: %{private}@", buf, 0xCu);
    }

    (*(void (**)(void))(*(void *)(v21 + 40) + 16))();
  }
}

void sub_1000C1E38(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    uint64_t v7 = KCSharingLogObject();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      long long v27 = [a1[4] groupID];
      *(_DWORD *)long long buf = 138412546;
      *(void *)&uint8_t buf[4] = v27;
      *(_WORD *)&buf[12] = 2114;
      *(void *)&buf[14] = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to fetch share metadata for group invite %@: %{public}@", buf, 0x16u);
    }
    if (CKErrorIsCode())
    {
      id v8 = [v6 userInfo];
      id v9 = [v8 objectForKeyedSubscript:CKPartialErrorsByItemIDKey];
      uint64_t v10 = [a1[4] shareURL];
      uint64_t v11 = [v9 objectForKeyedSubscript:v10];

      LODWORD(v9) = CKErrorIsCode();
      id v12 = KCSharingLogObject();
      BOOL v13 = os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT);
      if (v9)
      {
        if (v13)
        {
          unint64_t v14 = [a1[4] groupID];
          *(_DWORD *)long long buf = 138543362;
          *(void *)&uint8_t buf[4] = v14;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Unknown item error for invite %{public}@, will consider decline a success", buf, 0xCu);
        }
        id v15 = objc_alloc((Class)KCSharingGroup);
        uint64_t v16 = [a1[4] groupID];
        unint64_t v17 = [a1[4] displayName];
        BOOL v18 = [a1[4] shareURL];
        id v19 = [v15 initWithGroupID:v16 participants:&__NSArray0__struct displayName:v17 shareURL:v18];

        (*((void (**)(void))a1[6] + 2))();
      }
      else
      {
        if (v13)
        {
          long long v26 = [a1[4] groupID];
          *(_DWORD *)long long buf = 138543618;
          *(void *)&uint8_t buf[4] = v26;
          *(_WORD *)&buf[12] = 2114;
          *(void *)&buf[14] = v11;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Underlying failure for metadata fetch to decline %{public}@: %{public}@", buf, 0x16u);
        }
        (*((void (**)(void))a1[6] + 2))();
      }
    }
    else
    {
      (*((void (**)(void))a1[6] + 2))();
    }
  }
  else if ([v5 count] == (id)1)
  {
    id v20 = objc_alloc_init((Class)CKDeclineSharesOperation);
    [v20 setShareMetadatas:v5];
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&uint8_t buf[16] = 0x3032000000;
    id v36 = sub_1000C1354;
    uint64_t v37 = sub_1000C1364;
    id v38 = 0;
    v34[0] = _NSConcreteStackBlock;
    v34[1] = 3221225472;
    v34[2] = sub_1000C23A8;
    v34[3] = &unk_1002F9540;
    void v34[4] = buf;
    [v20 setPerShareCompletionBlock:v34];
    v29[0] = _NSConcreteStackBlock;
    v29[1] = 3221225472;
    v29[2] = sub_1000C23BC;
    void v29[3] = &unk_1002F9568;
    id v33 = buf;
    id v30 = a1[4];
    id v21 = a1[6];
    id v31 = a1[5];
    id v32 = v21;
    [v20 setDeclineSharesCompletionBlock:v29];
    id v22 = [a1[5] syncController];
    __int16 v23 = [v22 container];
    [v23 addOperation:v20];

    _Block_object_dispose(buf, 8);
  }
  else
  {
    id v24 = KCSharingLogObject();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      long long v28 = [a1[4] groupID];
      *(_DWORD *)long long buf = 138543362;
      *(void *)&uint8_t buf[4] = v28;
      _os_log_error_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "Expected share metadata not found for group invite %{public}@", buf, 0xCu);
    }
    id v25 = +[NSError errorWithDomain:@"KCSharingErrorDomain" code:9 userInfo:0];
    (*((void (**)(void))a1[6] + 2))();
  }
}

void sub_1000C2388(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000C23A8(uint64_t a1, int a2, id obj)
{
}

void sub_1000C23BC(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  id v5 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
  if (!v5) {
    id v5 = v3;
  }
  id v6 = v5;
  if (v6)
  {
    uint64_t v7 = KCSharingLogObject();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      uint64_t v11 = [*(id *)(a1 + 32) groupID];
      *(_DWORD *)long long buf = 138543618;
      unint64_t v17 = v11;
      __int16 v18 = 2114;
      id v19 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to decline shares for group invite %{public}@: %{public}@", buf, 0x16u);
    }
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  else
  {
    id v8 = [*(id *)(a1 + 40) messagingdConnection];
    id v9 = [*(id *)(a1 + 32) groupID];
    v12[0] = _NSConcreteStackBlock;
    v12[1] = 3221225472;
    int v12[2] = sub_1000C2590;
    v12[3] = &unk_1002F9400;
    id v13 = *(id *)(a1 + 32);
    id v10 = *(id *)(a1 + 48);
    uint64_t v14 = *(void *)(a1 + 40);
    id v15 = v10;
    [v8 didDeclineInviteForGroupID:v9 completion:v12];
  }
}

void sub_1000C2590(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    uint64_t v4 = KCSharingLogObject();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      id v10 = [*(id *)(a1 + 32) groupID];
      int v11 = 138543618;
      id v12 = v10;
      __int16 v13 = 2114;
      id v14 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to decline IDSInvite for %{public}@: %{public}@", (uint8_t *)&v11, 0x16u);
    }
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  else
  {
    id v5 = objc_alloc((Class)KCSharingGroup);
    id v6 = [*(id *)(a1 + 32) groupID];
    uint64_t v7 = [*(id *)(a1 + 32) displayName];
    id v8 = [*(id *)(a1 + 32) shareURL];
    id v9 = [v5 initWithGroupID:v6 participants:&__NSArray0__struct displayName:v7 shareURL:v8];

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  [*(id *)(a1 + 40) sendGroupsUpdatedNotifications];
}

void sub_1000C2888(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    uint64_t v7 = KCSharingLogObject();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v14 = 138543362;
      id v15 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to receive invite from keychainsharingmessagesd: %{public}@", (uint8_t *)&v14, 0xCu);
    }

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  else if (v5)
  {
    [*(id *)(a1 + 40) declineGroupInvite:v5 completion:*(void *)(a1 + 48)];
  }
  else
  {
    id v8 = KCSharingLogObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      __int16 v13 = *(void **)(a1 + 32);
      int v14 = 138543362;
      id v15 = v13;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "No error and no invite from ksmd for accepting for %{public}@. We raced the sender cancelling the invite?", (uint8_t *)&v14, 0xCu);
    }

    id v9 = objc_alloc((Class)KCSharingGroup);
    uint64_t v10 = *(void *)(a1 + 32);
    id v11 = objc_alloc_init((Class)NSURL);
    id v12 = [v9 initWithGroupID:v10 participants:&__NSArray0__struct displayName:@"unknown" shareURL:v11];

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
}

void sub_1000C2BF8(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    uint64_t v7 = KCSharingLogObject();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      id v19 = a1[4];
      id v20 = [v19 groupID];
      *(_DWORD *)long long buf = 138478339;
      *(void *)&uint8_t buf[4] = v19;
      *(_WORD *)&buf[12] = 2114;
      *(void *)&buf[14] = v20;
      *(_WORD *)&buf[22] = 2114;
      id v31 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to fetch share metadata for group invite %{private}@ for group %{public}@: %{public}@", buf, 0x20u);
    }
    if (CKErrorIsCode())
    {
      id v8 = [v6 userInfo];
      id v9 = [v8 objectForKeyedSubscript:CKPartialErrorsByItemIDKey];
      uint64_t v10 = [a1[4] shareURL];
      id v11 = [v9 objectForKeyedSubscript:v10];

      (*((void (**)(void))a1[6] + 2))();
    }
    else
    {
      (*((void (**)(void))a1[6] + 2))();
    }
  }
  else if ([v5 count] == (id)1)
  {
    id v12 = objc_alloc_init((Class)CKAcceptSharesOperation);
    [v12 setShareMetadatas:v5];
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&uint8_t buf[16] = 0x3032000000;
    id v31 = sub_1000C1354;
    id v32 = sub_1000C1364;
    id v33 = 0;
    v29[0] = _NSConcreteStackBlock;
    v29[1] = 3221225472;
    v29[2] = sub_1000C301C;
    void v29[3] = &unk_1002F94A0;
    void v29[4] = buf;
    [v12 setPerShareCompletionBlock:v29];
    v22[0] = _NSConcreteStackBlock;
    v22[1] = 3221225472;
    v22[2] = sub_1000C3030;
    v22[3] = &unk_1002F94F0;
    long long v28 = buf;
    id v23 = a1[4];
    id v13 = a1[6];
    id v14 = a1[5];
    id v27 = v13;
    id v24 = v14;
    id v25 = v5;
    id v26 = 0;
    [v12 setAcceptSharesCompletionBlock:v22];
    id v15 = [a1[5] syncController];
    uint64_t v16 = [v15 container];
    [v16 addOperation:v12];

    _Block_object_dispose(buf, 8);
  }
  else
  {
    unint64_t v17 = KCSharingLogObject();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      id v21 = [a1[4] groupID];
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v21;
      _os_log_error_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "Expected share metadata not found for invite for %@", buf, 0xCu);
    }
    __int16 v18 = +[NSError errorWithDomain:@"KCSharingErrorDomain" code:9 userInfo:0];
    (*((void (**)(void))a1[6] + 2))();
  }
}

void sub_1000C2FFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000C301C(uint64_t a1, int a2, int a3, id obj)
{
}

void sub_1000C3030(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  id v5 = *(void **)(*(void *)(*(void *)(a1 + 72) + 8) + 40);
  if (!v5) {
    id v5 = v3;
  }
  id v6 = v5;
  if (v6)
  {
    uint64_t v7 = KCSharingLogObject();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      id v13 = [*(id *)(a1 + 32) groupID];
      *(_DWORD *)long long buf = 138543618;
      id v21 = v13;
      __int16 v22 = 2114;
      id v23 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to accept shares for invite for group %{public}@: %{public}@", buf, 0x16u);
    }
    (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
  }
  else
  {
    id v8 = [*(id *)(a1 + 40) messagingdConnection];
    id v9 = [*(id *)(a1 + 32) groupID];
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 3221225472;
    v14[2] = sub_1000C3228;
    v14[3] = &unk_1002F94C8;
    id v10 = *(id *)(a1 + 32);
    uint64_t v11 = *(void *)(a1 + 40);
    id v12 = *(void **)(a1 + 48);
    id v15 = v10;
    uint64_t v16 = v11;
    id v17 = v12;
    id v18 = *(id *)(a1 + 56);
    id v19 = *(id *)(a1 + 64);
    [v8 didAcceptInviteForGroupID:v9 completion:v14];
  }
}

void sub_1000C3228(id *a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    uint64_t v4 = KCSharingLogObject();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      id v13 = [a1[4] groupID];
      *(_DWORD *)long long buf = 138543618;
      id v21 = v13;
      __int16 v22 = 2114;
      id v23 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to accept IDSInvite for %{public}@: %{public}@", buf, 0x16u);
    }
  }
  id v5 = [a1[5] syncController];
  id v6 = [a1[6] firstObject];
  uint64_t v7 = [v6 share];
  id v8 = [v7 recordID];
  id v9 = [v8 zoneID];
  id v19 = v9;
  id v10 = +[NSArray arrayWithObjects:&v19 count:1];
  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  v14[2] = sub_1000C3430;
  v14[3] = &unk_1002F9450;
  id v15 = a1[4];
  id v11 = a1[7];
  id v12 = a1[5];
  id v16 = v11;
  id v17 = v12;
  id v18 = a1[8];
  [v5 fetchRemoteChangesForZoneIDs:v10 completion:v14];
}

void sub_1000C3430(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    uint64_t v4 = KCSharingLogObject();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      id v10 = [*(id *)(a1 + 32) groupID];
      uint64_t v11 = *(void *)(a1 + 40);
      int v12 = 138543618;
      id v13 = v10;
      __int16 v14 = 2114;
      uint64_t v15 = v11;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to accept group invite for %{public}@: %{public}@", (uint8_t *)&v12, 0x16u);
    }
  }
  id v5 = *(void **)(a1 + 48);
  id v6 = [*(id *)(a1 + 32) groupID];
  uint64_t v7 = [v5 fetchLocalShareForGroupID:v6];
  id v8 = sub_100046CF4(v7);

  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
  [*(id *)(a1 + 48) sendGroupsUpdatedNotifications];
  id v9 = [*(id *)(a1 + 48) syncController];
  [v9 setFeatureInUse];
}

void sub_1000C36F8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    uint64_t v7 = KCSharingLogObject();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v12 = 138543362;
      id v13 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to receive invite from keychainsharingmessagesd: %{public}@", (uint8_t *)&v12, 0xCu);
    }

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  else if (v5)
  {
    [*(id *)(a1 + 40) acceptGroupInvite:v5 completion:*(void *)(a1 + 48)];
  }
  else
  {
    id v8 = KCSharingLogObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v11 = *(void **)(a1 + 32);
      int v12 = 138543362;
      id v13 = v11;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "No error and no invite from ksmd for declining for %{public}@. We raced the sender cancelling the invite?", (uint8_t *)&v12, 0xCu);
    }

    uint64_t v9 = *(void *)(a1 + 48);
    id v10 = +[NSError errorWithDomain:@"KCSharingErrorDomain" code:9 userInfo:0];
    (*(void (**)(uint64_t, void, void *))(v9 + 16))(v9, 0, v10);
  }
}

void sub_1000C401C(uint64_t a1, void *a2)
{
  id v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void **)(a1 + 40);
  id v5 = a2;
  id v6 = [v4 recordID];
  uint64_t v7 = [v6 zoneID];
  id v8 = [v3 translateSyncErrorForGroupRequest:v5 zoneID:v7];

  if (v8)
  {
    uint64_t v9 = KCSharingLogObject();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      id v13 = [*(id *)(a1 + 48) groupID];
      *(_DWORD *)long long buf = 138543618;
      id v19 = v13;
      __int16 v20 = 2114;
      id v21 = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to save staged outgoing changes for group delete request for %{public}@: %{public}@", buf, 0x16u);
    }
    (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
    [*(id *)(a1 + 32) sendGroupsUpdatedNotifications];
    if (*(void *)(a1 + 56))
    {
      id v10 = [*(id *)(a1 + 32) messagingdConnection];
      uint64_t v11 = *(void **)(a1 + 56);
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 3221225472;
      void v16[2] = sub_1000C4290;
      v16[3] = &unk_1002F9A20;
      id v17 = v11;
      [v10 cancelPendingInvitesForGroup:v17 participantHandles:0 completion:v16];
    }
    else
    {
      int v12 = KCSharingLogObject();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        __int16 v14 = [*(id *)(a1 + 40) recordID];
        uint64_t v15 = [v14 zoneID];
        *(_DWORD *)long long buf = 138543362;
        id v19 = v15;
        _os_log_error_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "Did not obtain group object for now-deleted group %{public}@, can't cancel pending invitations", buf, 0xCu);
      }
    }
  }
}

void sub_1000C4290(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = KCSharingLogObject();
  id v5 = v4;
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      id v6 = [*(id *)(a1 + 32) groupID];
      int v7 = 138543618;
      id v8 = v6;
      __int16 v9 = 2114;
      id v10 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to cancel (some) pending invitations for now-deleted group %{public}@: %{public}@", (uint8_t *)&v7, 0x16u);
LABEL_6:
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = [*(id *)(a1 + 32) groupID];
    int v7 = 138543362;
    id v8 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Canceled pending invitations for now-deleted group %{public}@", (uint8_t *)&v7, 0xCu);
    goto LABEL_6;
  }
}

void sub_1000C47E0(uint64_t a1, void *a2)
{
  id v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void **)(a1 + 40);
  id v5 = a2;
  id v6 = [v4 recordID];
  int v7 = [v6 zoneID];
  id v8 = [v3 translateSyncErrorForGroupRequest:v5 zoneID:v7];

  if (v8)
  {
    __int16 v9 = KCSharingLogObject();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      id v10 = [*(id *)(a1 + 48) groupID];
      int v11 = 138543618;
      int v12 = v10;
      __int16 v13 = 2114;
      __int16 v14 = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to save staged outgoing changes for group leave request for %{public}@: %{public}@", (uint8_t *)&v11, 0x16u);
    }
    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
    [*(id *)(a1 + 32) sendGroupsUpdatedNotifications];
  }
}

void sub_1000C4AF8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v69 = (id *)a1;
  if (v6)
  {
    int v7 = KCSharingLogObject();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      id v63 = [*(id *)(a1 + 32) groupID];
      *(_DWORD *)long long buf = 138543618;
      uint64_t v93 = v63;
      __int16 v94 = 2114;
      id v95 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to fetch share participants for group %{public}@: %{public}@", buf, 0x16u);
    }
    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
  }
  else
  {
    id v8 = [*(id *)(a1 + 32) participants];
    __int16 v9 = +[NSMutableDictionary dictionaryWithCapacity:](NSMutableDictionary, "dictionaryWithCapacity:", [v8 count]);

    long long v90 = 0u;
    long long v91 = 0u;
    long long v88 = 0u;
    long long v89 = 0u;
    id v10 = [*(id *)(a1 + 32) participants];
    id v11 = [v10 countByEnumeratingWithState:&v88 objects:v102 count:16];
    if (v11)
    {
      id v12 = v11;
      uint64_t v13 = *(void *)v89;
      do
      {
        for (uint64_t i = 0; i != v12; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v89 != v13) {
            objc_enumerationMutation(v10);
          }
          uint64_t v15 = *(void **)(*((void *)&v88 + 1) + 8 * i);
          id v16 = [v15 handle];
          [v9 setObject:v15 forKeyedSubscript:v16];
        }
        id v12 = [v10 countByEnumeratingWithState:&v88 objects:v102 count:16];
      }
      while (v12);
    }
    id v68 = v5;

    id v17 = [v69[5] participants];
    id v18 = +[NSMutableDictionary dictionaryWithCapacity:](NSMutableDictionary, "dictionaryWithCapacity:", [v17 count]);

    long long v86 = 0u;
    long long v87 = 0u;
    long long v84 = 0u;
    long long v85 = 0u;
    id v19 = [v69[5] participants];
    id v20 = [v19 countByEnumeratingWithState:&v84 objects:v101 count:16];
    if (v20)
    {
      id v21 = v20;
      uint64_t v22 = *(void *)v85;
      do
      {
        for (j = 0; j != v21; j = (char *)j + 1)
        {
          if (*(void *)v85 != v22) {
            objc_enumerationMutation(v19);
          }
          id v24 = *(void **)(*((void *)&v84 + 1) + 8 * (void)j);
          id v25 = [v24 userIdentity];
          id v26 = [v25 lookupInfo];
          id v27 = sub_100046C24(v26);

          if (v27) {
            [v18 setObject:v24 forKeyedSubscript:v27];
          }
        }
        id v21 = [v19 countByEnumeratingWithState:&v84 objects:v101 count:16];
      }
      while (v21);
    }

    long long v82 = 0u;
    long long v83 = 0u;
    long long v80 = 0u;
    long long v81 = 0u;
    id v28 = v9;
    id v29 = [v28 countByEnumeratingWithState:&v80 objects:v100 count:16];
    if (v29)
    {
      id v30 = v29;
      uint64_t v31 = *(void *)v81;
      do
      {
        for (k = 0; k != v30; k = (char *)k + 1)
        {
          if (*(void *)v81 != v31) {
            objc_enumerationMutation(v28);
          }
          uint64_t v33 = *(void *)(*((void *)&v80 + 1) + 8 * (void)k);
          uint64_t v34 = [v18 objectForKeyedSubscript:v33];

          if (!v34)
          {
            id v35 = [v68 objectForKeyedSubscript:v33];
            if (v35) {
              [v69[5] addParticipant:v35];
            }
          }
        }
        id v30 = [v28 countByEnumeratingWithState:&v80 objects:v100 count:16];
      }
      while (v30);
    }

    id v36 = +[NSMutableArray array];
    long long v76 = 0u;
    long long v77 = 0u;
    long long v78 = 0u;
    long long v79 = 0u;
    id v37 = v18;
    id v38 = [v37 countByEnumeratingWithState:&v76 objects:v99 count:16];
    if (v38)
    {
      id v39 = v38;
      uint64_t v40 = *(void *)v77;
      while (2)
      {
        for (m = 0; m != v39; m = (char *)m + 1)
        {
          if (*(void *)v77 != v40) {
            objc_enumerationMutation(v37);
          }
          uint64_t v42 = *(void *)(*((void *)&v76 + 1) + 8 * (void)m);
          uint64_t v43 = [v37 objectForKeyedSubscript:v42];
          uint64_t v44 = [v28 objectForKeyedSubscript:v42];
          id v45 = v44;
          if (v44)
          {
            unint64_t v46 = (unint64_t)[v44 permissionLevel];
            if (v46 > 2) {
              uint64_t v47 = 0;
            }
            else {
              uint64_t v47 = qword_100265630[v46];
            }
            [v43 setRole:v47];
            unint64_t v48 = (unint64_t)[v45 permissionLevel];
            if (v48 > 2) {
              uint64_t v49 = 0;
            }
            else {
              uint64_t v49 = qword_100265648[v48];
            }
            [v43 setPermission:v49];
          }
          else
          {
            if ([v43 isCurrentUser])
            {
              id v59 = v36;
              uint64_t v60 = KCSharingLogObject();
              if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
              {
                id v64 = [v69[4] groupID];
                *(_DWORD *)long long buf = 138543362;
                uint64_t v93 = v64;
                _os_log_error_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, "Rejected request to remove self from group %{public}@", buf, 0xCu);
              }
              long long v61 = (void (**)(id, void, void *))v69[7];
              long long v62 = +[NSError errorWithDomain:@"KCSharingErrorDomain" code:15 userInfo:0];
              v61[2](v61, 0, v62);

              id v53 = v37;
              goto LABEL_59;
            }
            [v69[5] removeParticipant:v43];
            [v36 addObject:v42];
          }
        }
        id v39 = [v37 countByEnumeratingWithState:&v76 objects:v99 count:16];
        if (v39) {
          continue;
        }
        break;
      }
    }

    id v50 = [v69[6] sharingStore];
    id v98 = v69[5];
    id v51 = +[NSArray arrayWithObjects:&v98 count:1];
    id v75 = 0;
    unsigned __int8 v52 = [v50 stageOutgoingShares:v51 deletionsForShares:0 error:&v75];
    id v53 = v75;

    __int16 v54 = KCSharingLogObject();
    id v55 = v54;
    if (v52)
    {
      if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v56 = [v69[4] groupID];
        *(_DWORD *)long long buf = 138543362;
        uint64_t v93 = v56;
        _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "Successfully created/updated and staged CKShare for group create/update request %{public}@", buf, 0xCu);
      }
      uint64_t v57 = [v69[6] syncController];
      v70[0] = _NSConcreteStackBlock;
      v70[1] = 3221225472;
      v70[2] = sub_1000C5370;
      v70[3] = &unk_1002F94C8;
      int8x16_t v67 = *(int8x16_t *)(v69 + 5);
      id v58 = (id)v67.i64[0];
      int8x16_t v71 = vextq_s8(v67, v67, 8uLL);
      id v72 = v69[4];
      id v74 = v69[7];
      id v73 = v36;
      [v57 saveStagedOutgoingChangesWithCompletion:v70];

      id v5 = v68;
    }
    else
    {
      id v59 = v36;
      if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
      {
        id v65 = v69[5];
        id v66 = [v69[4] groupID];
        *(_DWORD *)long long buf = 138478339;
        uint64_t v93 = v65;
        __int16 v94 = 2114;
        id v95 = v66;
        __int16 v96 = 2114;
        id v97 = v53;
        _os_log_error_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, "Failed to stage outgoing share %{private}@ for group %{public}@: %{public}@", buf, 0x20u);
      }
      (*((void (**)(void))v69[7] + 2))();
LABEL_59:
      id v5 = v68;
      id v36 = v59;
    }

    id v6 = 0;
  }
}

void sub_1000C5370(uint64_t a1, void *a2)
{
  id v3 = *(void **)(a1 + 32);
  uint64_t v4 = *(void **)(a1 + 40);
  id v5 = a2;
  id v6 = [v4 recordID];
  int v7 = [v6 zoneID];
  id v8 = [v3 translateSyncErrorForGroupRequest:v5 zoneID:v7];

  if (v8)
  {
    __int16 v9 = KCSharingLogObject();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      id v21 = [*(id *)(a1 + 48) groupID];
      *(_DWORD *)long long buf = 138543618;
      id v26 = v21;
      __int16 v27 = 2114;
      id v28 = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "Failed to save staged outgoing changes for group create/update request for %{public}@: %{public}@", buf, 0x16u);
    }
    (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
  }
  else
  {
    id v10 = [*(id *)(a1 + 32) sharingStore];
    id v11 = [*(id *)(a1 + 48) groupID];
    id v24 = 0;
    id v12 = [v10 fetchCKShareFromMirrorForGroupID:v11 error:&v24];
    id v13 = v24;

    __int16 v14 = sub_100046CF4(v12);
    uint64_t v15 = KCSharingLogObject();
    id v16 = v15;
    if (v13 || !v14)
    {
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        id v26 = v13;
        _os_log_error_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "Failed to fetch newly saved group from disk. This is a bug?! %{public}@", buf, 0xCu);
      }

      id v17 = sub_100046CF4(*(void **)(a1 + 40));
      (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
    }
    else
    {
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138477827;
        id v26 = v14;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Will return successfully saved group %{private}@", buf, 0xCu);
      }

      (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
    }
    [*(id *)(a1 + 32) sendGroupsUpdatedNotifications];
    if ([*(id *)(a1 + 56) count])
    {
      id v18 = [*(id *)(a1 + 32) messagingdConnection];
      id v19 = *(void **)(a1 + 48);
      uint64_t v20 = *(void *)(a1 + 56);
      v22[0] = _NSConcreteStackBlock;
      v22[1] = 3221225472;
      v22[2] = sub_1000C56B8;
      v22[3] = &unk_1002F9A20;
      id v23 = v19;
      [v18 cancelPendingInvitesForGroup:v23 participantHandles:v20 completion:v22];
    }
  }
}

void sub_1000C56B8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = KCSharingLogObject();
  id v5 = v4;
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      id v6 = [*(id *)(a1 + 32) groupID];
      int v7 = 138543618;
      id v8 = v6;
      __int16 v9 = 2114;
      id v10 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to cancel (some) pending invitations for participants removed from %{public}@: %{public}@", (uint8_t *)&v7, 0x16u);
LABEL_6:
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = [*(id *)(a1 + 32) groupID];
    int v7 = 138543362;
    id v8 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Canceled any pending invitations for participants removed from %{public}@", (uint8_t *)&v7, 0xCu);
    goto LABEL_6;
  }
}

void sub_1000C6054(id *a1, uint64_t a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  if (v8)
  {
    __int16 v9 = [a1[4] objectForKeyedSubscript:a2];
    id v10 = KCSharingLogObject();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543618;
      id v17 = v9;
      __int16 v18 = 2114;
      id v19 = v8;
      _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "CK failed to fetch metadata for %{public}@: %{public}@", buf, 0x16u);
    }

    if (CKErrorIsCode())
    {
      id v11 = KCSharingLogObject();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        id v17 = v9;
        _os_log_error_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "Metadata fetch error means the share for %{public}@ is no longer accessible to us, will attempt async to decline invitation", buf, 0xCu);
      }

      id v12 = [a1[5] messagingdConnection];
      v14[0] = _NSConcreteStackBlock;
      v14[1] = 3221225472;
      v14[2] = sub_1000C6478;
      v14[3] = &unk_1002F9A20;
      id v15 = v9;
      [v12 didDeclineInviteForGroupID:v15 completion:v14];
    }
  }
  else
  {
    id v13 = [v7 share];

    if (v13) {
      [a1[6] addObject:v7];
    }
  }
}

void sub_1000C6268(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    IsCFIndex Code = CKErrorIsCode();
    id v5 = KCSharingLogObject();
    BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
    if (IsCode)
    {
      if (v6)
      {
        id v8 = *(void **)(a1 + 32);
        __int16 v9 = [v8 count];
        int64_t v10 = v9 - (unsigned char *)[*(id *)(a1 + 40) count];
        id v11 = [*(id *)(a1 + 32) count];
        int v13 = 138478595;
        __int16 v14 = v8;
        __int16 v15 = 2048;
        int64_t v16 = v10;
        __int16 v17 = 2048;
        id v18 = v11;
        __int16 v19 = 2114;
        id v20 = v3;
        _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Share metadata fetch for invites %{private}@ partly failed (%ld/%ld): %{public}@", (uint8_t *)&v13, 0x2Au);
      }
    }
    else if (v6)
    {
      id v12 = *(void **)(a1 + 32);
      int v13 = 138478083;
      __int16 v14 = v12;
      __int16 v15 = 2114;
      int64_t v16 = (int64_t)v3;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to fetch metadata for invites: %{private}@: %{public}@", (uint8_t *)&v13, 0x16u);
    }
  }
  else
  {
    id v5 = KCSharingLogObject();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      id v7 = *(void **)(a1 + 32);
      int v13 = 138477827;
      __int16 v14 = v7;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Fetched share metadata for group invites: %{private}@", (uint8_t *)&v13, 0xCu);
    }
  }

  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

void sub_1000C6478(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = KCSharingLogObject();
  id v5 = v4;
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = *(void *)(a1 + 32);
      int v8 = 138543618;
      uint64_t v9 = v6;
      __int16 v10 = 2114;
      id v11 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to decline unusable invitation for groupID %{public}@: %{public}@", (uint8_t *)&v8, 0x16u);
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a1 + 32);
    int v8 = 138543362;
    uint64_t v9 = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Declined invitation for groupID %{public}@ we no longer have access to.", (uint8_t *)&v8, 0xCu);
  }
}

void sub_1000C666C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    uint64_t v7 = KCSharingLogObject();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      id v27 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to fetch received group invites: %{public}@", buf, 0xCu);
    }

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  else
  {
    id v8 = objc_alloc_init((Class)NSMutableArray);
    long long v21 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    long long v24 = 0u;
    id v18 = v5;
    id v9 = v5;
    id v10 = [v9 countByEnumeratingWithState:&v21 objects:v25 count:16];
    if (v10)
    {
      id v11 = v10;
      uint64_t v12 = *(void *)v22;
      do
      {
        for (uint64_t i = 0; i != v11; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v22 != v12) {
            objc_enumerationMutation(v9);
          }
          __int16 v14 = *(void **)(*((void *)&v21 + 1) + 8 * i);
          __int16 v15 = *(void **)(a1 + 32);
          int64_t v16 = [v14 groupID:v18];
          LOBYTE(v15) = [v15 containsObject:v16];

          if ((v15 & 1) == 0) {
            [v8 addObject:v14];
          }
        }
        id v11 = [v9 countByEnumeratingWithState:&v21 objects:v25 count:16];
      }
      while (v11);
    }

    if ([v8 count])
    {
      v19[0] = _NSConcreteStackBlock;
      v19[1] = 3221225472;
      v19[2] = sub_1000C68E4;
      v19[3] = &unk_1002FB260;
      __int16 v17 = *(void **)(a1 + 40);
      id v20 = *(id *)(a1 + 48);
      [v17 fetchCKShareMetadataForGroupInvites:v8 completion:v19];
    }
    else
    {
      (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    }

    id v5 = v18;
  }
}

void sub_1000C68E4(uint64_t a1, void *a2, void *a3)
{
  uint64_t v18 = a1;
  id v4 = a2;
  id v5 = a3;
  if (v5)
  {
    id v6 = KCSharingLogObject();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      id v26 = v5;
      _os_log_error_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "(Partial) error fetching share metadata for group invites: %{public}@", buf, 0xCu);
    }
  }
  __int16 v19 = v5;
  id v7 = objc_alloc_init((Class)NSMutableArray);
  long long v20 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v23 = 0u;
  id v8 = v4;
  id v9 = [v8 countByEnumeratingWithState:&v20 objects:v24 count:16];
  if (v9)
  {
    id v10 = v9;
    uint64_t v11 = *(void *)v21;
    do
    {
      for (uint64_t i = 0; i != v10; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v21 != v11) {
          objc_enumerationMutation(v8);
        }
        int v13 = *(void **)(*((void *)&v20 + 1) + 8 * i);
        __int16 v14 = [v13 share:v18 with:v19];
        __int16 v15 = sub_100046CF4(v14);

        if (v15)
        {
          [v7 addObject:v15];
        }
        else
        {
          int64_t v16 = KCSharingLogObject();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            __int16 v17 = [v13 share];
            *(_DWORD *)long long buf = 138543362;
            id v26 = v17;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Ignoring share for non-group zone: %{public}@", buf, 0xCu);
          }
        }
      }
      id v10 = [v8 countByEnumeratingWithState:&v20 objects:v24 count:16];
    }
    while (v10);
  }

  (*(void (**)(void))(*(void *)(v18 + 32) + 16))();
}

void sub_1000C6E30(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    id v7 = KCSharingLogObject();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v12 = 138543362;
      id v13 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to fetch pending groups: %{public}@", (uint8_t *)&v12, 0xCu);
    }
  }
  if ([v5 count]) {
    [*(id *)(a1 + 32) addObjectsFromArray:v5];
  }
  id v8 = KCSharingLogObject();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    id v9 = [*(id *)(a1 + 32) count];
    id v10 = [v5 count];
    uint64_t v11 = *(void *)(a1 + 32);
    int v12 = 134349571;
    id v13 = v9;
    __int16 v14 = 2050;
    id v15 = v10;
    __int16 v16 = 2113;
    uint64_t v17 = v11;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Fetched %{public}ld groups (%{public}ld of which pending): %{private}@", (uint8_t *)&v12, 0x20u);
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_1000C72D8(id a1)
{
  uint64_t v2 = [KCSharingDaemonGroupManager alloc];
  id v3 = +[KCSharingSyncController sharedInstance];
  id v4 = +[KCSharingMessagingdConnection sharedInstance];
  id v5 = [(KCSharingDaemonGroupManager *)v2 initWithSyncController:v3 messagingdConnection:v4];
  id v6 = (void *)qword_10035CE48;
  qword_10035CE48 = (uint64_t)v5;
}

void sub_1000C7690(uint64_t a1)
{
  uint64_t v2 = sub_10000B070("octagon-ckks");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    int v4 = 138412290;
    uint64_t v5 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Successfully reset %@", (uint8_t *)&v4, 0xCu);
  }
}

void sub_1000C7740(id a1, NSError *a2)
{
  uint64_t v2 = sub_10000B070("octagon-ckks");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)uint64_t v3 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "CKKS view reset complete", v3, 2u);
  }
}

void sub_1000C7CE8(_Unwind_Exception *a1)
{
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v3 - 80));
  _Unwind_Resume(a1);
}

void sub_1000C7D20(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = sub_10000B070("octagon");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = [WeakRetained error];
    int v4 = (void *)v3;
    CFStringRef v5 = @"no error";
    if (v3) {
      CFStringRef v5 = (const __CFString *)v3;
    }
    int v6 = 138412290;
    CFStringRef v7 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Finishing resetting CKKS missing TLKs operation with %@", (uint8_t *)&v6, 0xCu);
  }
}

void sub_1000C7E04(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v2 = [*(id *)(a1 + 32) viewKeySets];
  uint64_t v3 = [*(id *)(a1 + 32) incompleteKeySets];
  [WeakRetained proceedWithKeys:v2 incompleteKeySets:v3];
}

uint64_t sub_1000C8A68(uint64_t a1, uint64_t a2)
{
  while (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      break;
    }
    char v4 = 0;
    unsigned int v5 = 0;
    unint64_t v6 = 0;
    while (1)
    {
      uint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      unint64_t v8 = v7 + 1;
      if (v7 == -1 || v8 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v9 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v8;
      v6 |= (unint64_t)(v9 & 0x7F) << v4;
      if ((v9 & 0x80) == 0) {
        goto LABEL_11;
      }
      v4 += 7;
      BOOL v10 = v5++ >= 9;
      if (v10)
      {
        unint64_t v6 = 0;
        int v11 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
        goto LABEL_13;
      }
    }
    *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
    int v11 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      unint64_t v6 = 0;
    }
LABEL_13:
    if (v11 || (v6 & 7) == 4) {
      break;
    }
    switch((v6 >> 3))
    {
      case 1u:
        uint64_t v13 = PBReaderReadString();
        uint64_t v14 = 56;
        goto LABEL_34;
      case 2u:
        char v18 = 0;
        unsigned int v19 = 0;
        uint64_t v20 = 0;
        *(unsigned char *)(a1 + 96) |= 8u;
        while (2)
        {
          uint64_t v21 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          unint64_t v22 = v21 + 1;
          if (v21 == -1 || v22 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }
          else
          {
            char v23 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v21);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v22;
            v20 |= (unint64_t)(v23 & 0x7F) << v18;
            if (v23 < 0)
            {
              v18 += 7;
              BOOL v10 = v19++ >= 9;
              if (v10)
              {
                uint64_t v20 = 0;
                goto LABEL_58;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v20 = 0;
        }
LABEL_58:
        uint64_t v38 = 40;
        goto LABEL_67;
      case 3u:
        uint64_t v13 = PBReaderReadData();
        uint64_t v14 = 72;
        goto LABEL_34;
      case 4u:
        uint64_t v13 = PBReaderReadString();
        uint64_t v14 = 88;
        goto LABEL_34;
      case 5u:
        uint64_t v13 = PBReaderReadData();
        uint64_t v14 = 64;
        goto LABEL_34;
      case 6u:
        uint64_t v13 = PBReaderReadData();
        uint64_t v14 = 80;
LABEL_34:
        long long v24 = *(void **)(a1 + v14);
        *(void *)(a1 + v14) = v13;

        continue;
      case 7u:
        char v25 = 0;
        unsigned int v26 = 0;
        uint64_t v20 = 0;
        *(unsigned char *)(a1 + 96) |= 4u;
        while (2)
        {
          uint64_t v27 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
          unint64_t v28 = v27 + 1;
          if (v27 == -1 || v28 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
          {
            *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          }
          else
          {
            char v29 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v27);
            *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v28;
            v20 |= (unint64_t)(v29 & 0x7F) << v25;
            if (v29 < 0)
            {
              v25 += 7;
              BOOL v10 = v26++ >= 9;
              if (v10)
              {
                uint64_t v20 = 0;
                goto LABEL_62;
              }
              continue;
            }
          }
          break;
        }
        if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
          uint64_t v20 = 0;
        }
LABEL_62:
        uint64_t v38 = 32;
        goto LABEL_67;
      case 8u:
        char v30 = 0;
        unsigned int v31 = 0;
        uint64_t v20 = 0;
        *(unsigned char *)(a1 + 96) |= 2u;
        break;
      case 9u:
        *(unsigned char *)(a1 + 96) |= 1u;
        unint64_t v35 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v35 <= 0xFFFFFFFFFFFFFFF7 && v35 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          uint64_t v36 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v35);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v35 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          uint64_t v36 = 0;
        }
        uint64_t v39 = 16;
        goto LABEL_72;
      case 0xAu:
        *(unsigned char *)(a1 + 96) |= 0x10u;
        unint64_t v37 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v37 <= 0xFFFFFFFFFFFFFFF7 && v37 + 8 <= *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
        {
          uint64_t v36 = *(void *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v37);
          *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v37 + 8;
        }
        else
        {
          *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
          uint64_t v36 = 0;
        }
        uint64_t v39 = 48;
LABEL_72:
        *(void *)(a1 + v39) = v36;
        continue;
      default:
        if (!*(void *)(a1 + 8))
        {
          id v15 = objc_alloc_init((Class)PBUnknownFields);
          __int16 v16 = *(void **)(a1 + 8);
          *(void *)(a1 + _Block_object_dispose(&STACK[0x3F0], 8) = v15;
        }
        uint64_t result = PBUnknownFieldAdd();
        if (!result) {
          return result;
        }
        continue;
    }
    while (1)
    {
      uint64_t v32 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
      unint64_t v33 = v32 + 1;
      if (v32 == -1 || v33 > *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        break;
      }
      char v34 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v32);
      *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v33;
      v20 |= (unint64_t)(v34 & 0x7F) << v30;
      if ((v34 & 0x80) == 0) {
        goto LABEL_64;
      }
      v30 += 7;
      BOOL v10 = v31++ >= 9;
      if (v10)
      {
        uint64_t v20 = 0;
        goto LABEL_66;
      }
    }
    *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_64:
    if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
      uint64_t v20 = 0;
    }
LABEL_66:
    uint64_t v38 = 24;
LABEL_67:
    *(void *)(a1 + v3_Block_object_dispose(&STACK[0x3F0], 8) = v20;
  }
  return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

void sub_1000C97A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000C97CC(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  unsigned int v5 = +[CKKSAnalytics logger];
  [v5 logResultForEvent:@"OctagonEventRemoveCustodianRecoveryKeyTPH" hardFailure:1 result:v3];

  if (v3)
  {
    unint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 138412290;
      id v10 = v3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon: Error removing custodian recovery key: %@", (uint8_t *)&v9, 0xCu);
    }

    [WeakRetained setError:v3];
  }
  else
  {
    uint64_t v7 = sub_10000B070("octagon");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v9) = 0;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "successfully removed custodian recovery key", (uint8_t *)&v9, 2u);
    }
  }
  unint64_t v8 = [WeakRetained finishOp];
  [WeakRetained runBeforeGroupFinished:v8];
}

void sub_1000C9C44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000C9C68(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  unint64_t v8 = +[CKKSAnalytics logger];
  [v8 logResultForEvent:@"OctagonEventCheckCustodianRecoveryKeyTPH" hardFailure:1 result:v6];

  if (v6)
  {
    int v9 = sub_10000B070("SecError");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = 138412290;
      id v14 = v6;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "octagon: Error finding custodian recovery key: %@", (uint8_t *)&v13, 0xCu);
    }

    [WeakRetained setError:v6];
    id v10 = [WeakRetained finishOp];
    [WeakRetained runBeforeGroupFinished:v10];
  }
  else
  {
    int v11 = sub_10000B070("octagon");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v13) = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "successfully found custodian recovery key", (uint8_t *)&v13, 2u);
    }

    int v12 = [WeakRetained finishOp];
    [WeakRetained runBeforeGroupFinished:v12];

    [WeakRetained setCrk:v5];
  }
}

void sub_1000CA4B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id *location)
{
  objc_destroyWeak(v18);
  objc_destroyWeak(location);
  objc_destroyWeak((id *)(v19 - 136));
  _Unwind_Resume(a1);
}

void sub_1000CA4F8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = [WeakRetained error];

  if (v2)
  {
    id v3 = [WeakRetained retryFlag];

    if (!v3)
    {
      unint64_t v8 = sub_10000B070("SecError");
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v21) = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: Received an error updating TPH, but no retry flag present.", (uint8_t *)&v21, 2u);
      }
      goto LABEL_16;
    }
    char v4 = [WeakRetained deps];
    id v5 = [v4 lockStateTracker];
    id v6 = [WeakRetained error];
    unsigned int v7 = [v5 isLockedError:v6];

    unint64_t v8 = sub_10000B070("octagon");
    BOOL v9 = os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT);
    if (v7)
    {
      if (v9)
      {
        id v10 = [WeakRetained error];
        int v21 = 138412290;
        unint64_t v22 = v10;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Updating trust state failed because locked, retry once unlocked: %@", (uint8_t *)&v21, 0xCu);
      }
      [WeakRetained setNextState:@"WaitForUnlock"];
      int v11 = [OctagonPendingFlag alloc];
      int v12 = [WeakRetained retryFlag];
      unint64_t v8 = [(OctagonPendingFlag *)v11 initWithFlag:v12 conditions:1];

      if (!v8)
      {
        int v13 = [WeakRetained error];
        [v13 retryInterval];
        double v15 = v14;

        __int16 v16 = [OctagonPendingFlag alloc];
        uint64_t v17 = [WeakRetained retryFlag];
        unint64_t v8 = [(OctagonPendingFlag *)v16 initWithFlag:v17 delayInSeconds:v15];
      }
      char v18 = sub_10000B070("octagon");
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        int v21 = 138412290;
        unint64_t v22 = v8;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Updating trust state not fatal: requesting retry: %@", (uint8_t *)&v21, 0xCu);
      }

      uint64_t v19 = [WeakRetained deps];
      uint64_t v20 = [v19 flagHandler];
      [v20 handlePendingFlag:v8];
    }
    else
    {
      if (!v9)
      {
LABEL_16:

        goto LABEL_17;
      }
      uint64_t v19 = [WeakRetained error];
      int v21 = 138412290;
      unint64_t v22 = v19;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Error is currently unknown, aborting: %@", (uint8_t *)&v21, 0xCu);
    }

    goto LABEL_16;
  }
LABEL_17:
}

void sub_1000CA810(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  unint64_t v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (!v7 || v9)
  {
    unint64_t v22 = sub_10000B070("SecError");
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v60 = v9;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "octagon: update errored: %@", buf, 0xCu);
    }

    [WeakRetained setError:v9];
    if (![v9 isCuttlefishError:1037]) {
      goto LABEL_54;
    }
    char v23 = sub_10000B070("octagon-ckks");
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Cuttlefish reports we no longer exist.", buf, 2u);
    }

    long long v24 = [WeakRetained determineCDPState];

    if (v24)
    {
      uint64_t v25 = [WeakRetained determineCDPState];
    }
    else
    {
      if (!*(unsigned char *)(a1 + 40)
        || ([WeakRetained peerUnknownState],
            id v45 = objc_claimAutoreleasedReturnValue(),
            v45,
            !v45))
      {
        [WeakRetained setNextState:@"BecomeUntrusted"];
        goto LABEL_54;
      }
      uint64_t v25 = [WeakRetained peerUnknownState];
    }
    unsigned int v26 = (void *)v25;
    [WeakRetained setNextState:v25];

LABEL_54:
    id v16 = [WeakRetained finishedOp];
    [WeakRetained runBeforeGroupFinished:v16];
    goto LABEL_55;
  }
  int v11 = sub_10000B070("octagon");
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412546;
    id v60 = v7;
    __int16 v61 = 2112;
    CFStringRef v62 = v8;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "update complete: %@, %@", buf, 0x16u);
  }

  int v12 = [WeakRetained deps];
  int v13 = [v12 stateHolder];
  v57[0] = _NSConcreteStackBlock;
  v57[1] = 3221225472;
  v57[2] = sub_1000CB0C8;
  v57[3] = &unk_100307118;
  double v14 = v8;
  id v58 = v14;
  id v56 = 0;
  unsigned int v15 = [v13 persistAccountChanges:v57 error:&v56];
  id v16 = v56;

  if (!v15 || v16)
  {
    uint64_t v20 = sub_10000B070("SecError");
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v60 = v16;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "octagon: Unable to save new syncing state: %@", buf, 0xCu);
    }
  }
  else
  {
    uint64_t v17 = [WeakRetained deps];
    char v18 = [v17 ckks];
    unsigned int v19 = [v18 setCurrentSyncingPolicy:v14 policyIsFresh:1];

    if (!v19) {
      goto LABEL_20;
    }
    uint64_t v20 = [WeakRetained deps];
    int v21 = [v20 flagHandler];
    [v21 handleFlag:@"ckks_views_changed"];
  }
LABEL_20:
  if ([v7 identityIsPreapproved])
  {
    uint64_t v27 = sub_10000B070("octagon-sos");
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Self peer is now preapproved!", buf, 2u);
    }

    unint64_t v28 = [WeakRetained deps];
    char v29 = [v28 flagHandler];
    [v29 handleFlag:@"preapproved"];
  }
  if ([v7 memberChanges])
  {
    char v30 = sub_10000B070("octagon");
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "Member list changed", buf, 2u);
    }

    unsigned int v31 = [WeakRetained deps];
    uint64_t v32 = [v31 octagonAdapter];
    [v32 sendTrustedPeerSetChangedUpdate];
  }
  if ([v7 unknownMachineIDsPresent])
  {
    unint64_t v33 = sub_10000B070("octagon-authkit");
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "Unknown machine IDs are present; requesting fetch",
        buf,
        2u);
    }

    char v34 = [WeakRetained deps];
    unint64_t v35 = [v34 flagHandler];
    [v35 handleFlag:@"attempt_machine_id_list"];
  }
  if (([v7 peerStatus] & 4) != 0)
  {
    unint64_t v37 = sub_10000B070("octagon");
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v38 = [v7 peerID];
      *(_DWORD *)long long buf = 138412290;
      id v60 = v38;
      uint64_t v39 = "Self peer (%@) is excluded; moving to untrusted";
      uint64_t v40 = v37;
      uint32_t v41 = 12;
LABEL_37:
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, v39, buf, v41);
    }
  }
  else
  {
    if (([v7 peerStatus] & 0x20) == 0)
    {
      uint64_t v36 = [WeakRetained intendedState];
LABEL_51:
      id v50 = (void *)v36;
      [WeakRetained setNextState:v36];

      goto LABEL_52;
    }
    if ([v7 identityIsPreapproved])
    {
      uint64_t v43 = sub_10000B070("octagon");
      if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v44 = [v7 peerID];
        *(_DWORD *)long long buf = 138412290;
        id v60 = v44;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "Self peer (%@) is excluded but is preapproved, moving to sosuprade", buf, 0xCu);
      }
      CFStringRef v42 = @"AttemptSOSUpgrade";
      goto LABEL_39;
    }
    unint64_t v46 = [WeakRetained determineCDPState];

    if (v46)
    {
      uint64_t v47 = sub_10000B070("octagon");
      if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
      {
        unint64_t v48 = [v7 peerID];
        uint64_t v49 = [WeakRetained determineCDPState];
        *(_DWORD *)long long buf = 138412546;
        id v60 = v48;
        __int16 v61 = 2112;
        CFStringRef v62 = v49;
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "Self peer (%@) is unknown, but still figuring out cdp state; moving to '%@''",
          buf,
          0x16u);
      }
      uint64_t v36 = [WeakRetained determineCDPState];
      goto LABEL_51;
    }
    if (*(unsigned char *)(a1 + 40))
    {
      unsigned __int8 v52 = [WeakRetained peerUnknownState];

      if (v52)
      {
        id v53 = sub_10000B070("octagon");
        if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v54 = [v7 peerID];
          id v55 = [WeakRetained peerUnknownState];
          *(_DWORD *)long long buf = 138412546;
          id v60 = v54;
          __int16 v61 = 2112;
          CFStringRef v62 = v55;
          _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "Self peer (%@) is unknown and has attempted a join; moving to '%@''",
            buf,
            0x16u);
        }
        uint64_t v36 = [WeakRetained peerUnknownState];
        goto LABEL_51;
      }
    }
    unint64_t v37 = sub_10000B070("octagon");
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v38 = [v7 peerID];
      *(_DWORD *)long long buf = 138412546;
      id v60 = v38;
      __int16 v61 = 2112;
      CFStringRef v62 = @"BecomeUntrusted";
      uint64_t v39 = "Self peer (%@) is unknown and never attempted a join; moving to '%@''";
      uint64_t v40 = v37;
      uint32_t v41 = 22;
      goto LABEL_37;
    }
  }

  CFStringRef v42 = @"BecomeUntrusted";
LABEL_39:
  [WeakRetained setNextState:v42];
LABEL_52:
  id v51 = [WeakRetained finishedOp];
  [WeakRetained runBeforeGroupFinished:v51];

LABEL_55:
}

id sub_1000CB0C8(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 setTPSyncingPolicy:*(void *)(a1 + 32)];

  return v3;
}

CFTypeRef sub_1000CB710(uint64_t a1, const void *a2, void *a3)
{
  id v5 = *(void **)(a1 + 32);
  uint64_t v6 = v5[2];
  id v7 = *(uint64_t **)(v6 + 16);
  if (v7)
  {
    id v9 = (uint64_t **)(v6 + 24);
    do
    {
      if (CFEqual((CFTypeRef)*v7, @"persistref")) {
        sub_10011AA54(*(void *)(a1 + 32), a2, v7);
      }
      id v10 = *v9++;
      id v7 = v10;
    }
    while (v10);
    id v5 = *(void **)(a1 + 32);
  }
  CFTypeRef result = CFRetain(v5);
  *a3 = result;
  return result;
}

CFTypeRef sub_1000CB798(uint64_t a1, const void *a2, void *a3)
{
  id v5 = *(void **)(a1 + 32);
  uint64_t v6 = v5[2];
  id v7 = *(uint64_t **)(v6 + 16);
  if (v7)
  {
    id v9 = (uint64_t **)(v6 + 24);
    do
    {
      if (CFEqual((CFTypeRef)*v7, @"persistref")) {
        sub_10011AA54(*(void *)(a1 + 32), a2, v7);
      }
      id v10 = *v9++;
      id v7 = v10;
    }
    while (v10);
    id v5 = *(void **)(a1 + 32);
  }
  CFTypeRef result = CFRetain(v5);
  *a3 = result;
  return result;
}

CFTypeRef sub_1000CC580(uint64_t a1, uint64_t a2, void *a3)
{
  CFTypeRef result = CFRetain(*(CFTypeRef *)(a1 + 32));
  *a3 = result;
  return result;
}

CFTypeRef sub_1000CC5AC(uint64_t a1, uint64_t a2, void *a3)
{
  if ([*(id *)(a1 + 32) type] == (id)3 && *(void *)(a1 + 40))
  {
    uint64_t v6 = [*(id *)(a1 + 48) groupUpdateInfoFrom:a2 to:*(void *)(a1 + 32)];
    if (v6) {
      [*(id *)(a1 + 40) addObject:v6];
    }
  }
  CFTypeRef result = CFRetain(*(CFTypeRef *)(a1 + 56));
  *a3 = result;
  return result;
}

CFTypeRef sub_1000CC62C(uint64_t a1, uint64_t a2, void *a3)
{
  CFTypeRef result = CFRetain(*(CFTypeRef *)(a1 + 32));
  *a3 = result;
  return result;
}

BOOL sub_1000CC658(id a1, const SecDbAttr *a2)
{
  return a2->var1 == 8;
}

void sub_1000CCCA8(uint64_t a1, void *a2)
{
  sub_100046A80(a2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  if ([v3 inviteStatus] == (id)2) {
    [*(id *)(a1 + 32) addObject:v3];
  }
}

void sub_1000CD338(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  objc_destroyWeak(v21);
  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000CD388(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = [WeakRetained error];

  if (v2)
  {
    id v3 = [WeakRetained error];
    unsigned int v4 = [v3 isRetryable];

    if (v4)
    {
      id v5 = [WeakRetained error];
      [v5 retryInterval];
      double v7 = v6;

      unint64_t v8 = sub_10000B070("octagon-sos");
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        id v9 = [WeakRetained error];
        int v13 = 134218242;
        double v14 = v7;
        __int16 v15 = 2112;
        id v16 = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "SOS update preapproval error is not fatal: requesting retry in %0.2fs: %@", (uint8_t *)&v13, 0x16u);
      }
      id v10 = [WeakRetained deps];
      int v11 = [v10 flagHandler];
      int v12 = [[OctagonPendingFlag alloc] initWithFlag:@"attempt_sos_update_preapprovals" delayInSeconds:v7];
      [v11 handlePendingFlag:v12];
    }
    else
    {
      id v10 = sub_10000B070("octagon-sos");
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
LABEL_9:

        goto LABEL_10;
      }
      int v11 = [WeakRetained error];
      int v13 = 138412290;
      double v14 = *(double *)&v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "SOS update preapproval error is: %@, not retrying", (uint8_t *)&v13, 0xCu);
    }

    goto LABEL_9;
  }
LABEL_10:
}

void sub_1000CD57C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (v6)
  {
    unint64_t v8 = sub_10000B070("SecError");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = 138412290;
      id v16 = v6;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon-sos: unable to update preapproved keys: %@", (uint8_t *)&v15, 0xCu);
    }

    [WeakRetained setError:v6];
  }
  else
  {
    id v9 = sub_10000B070("octagon-sos");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v15) = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Updated SOS preapproved keys", (uint8_t *)&v15, 2u);
    }

    if ([v5 memberChanges])
    {
      id v10 = sub_10000B070("octagon");
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(v15) = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Member list changed", (uint8_t *)&v15, 2u);
      }

      int v11 = [WeakRetained deps];
      int v12 = [v11 octagonAdapter];
      [v12 sendTrustedPeerSetChangedUpdate];
    }
    int v13 = [WeakRetained intendedState];
    [WeakRetained setNextState:v13];
  }
  double v14 = [WeakRetained finishedOp];
  [WeakRetained runBeforeGroupFinished:v14];
}

id sub_1000CD884(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  uint64_t v15 = 0;
  id v16 = &v15;
  uint64_t v17 = 0x3032000000;
  char v18 = sub_1000CD9FC;
  unsigned int v19 = sub_1000CDA0C;
  id v5 = &_os_log_disabled;
  id v20 = &_os_log_disabled;
  if (qword_10035CE58 != -1) {
    dispatch_once(&qword_10035CE58, &stru_1002F9708);
  }
  id v6 = qword_10035CE50;
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000CDA14;
  block[3] = &unk_100306E50;
  id v12 = v4;
  id v13 = v3;
  double v14 = &v15;
  id v7 = v3;
  id v8 = v4;
  dispatch_sync(v6, block);
  id v9 = (id)v16[5];

  _Block_object_dispose(&v15, 8);

  return v9;
}

uint64_t sub_1000CD9FC(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1000CDA0C(uint64_t a1)
{
}

void sub_1000CDA14(void *a1)
{
  if (!qword_10035CE60)
  {
    uint64_t v2 = +[NSMutableDictionary dictionary];
    id v3 = (void *)qword_10035CE60;
    qword_10035CE60 = v2;
  }
  id v4 = (void *)a1[5];
  if (a1[4])
  {
    id v5 = [v4 stringByAppendingFormat:@"-%@", a1[4]];
  }
  else
  {
    id v5 = v4;
  }
  id v13 = v5;
  uint64_t v6 = [(id)qword_10035CE60 objectForKeyedSubscript:v5];
  uint64_t v7 = *(void *)(a1[6] + 8);
  id v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v6;

  if (!*(void *)(*(void *)(a1[6] + 8) + 40))
  {
    id v9 = v13;
    os_log_t v10 = os_log_create("com.apple.security.ckks", (const char *)[v9 cStringUsingEncoding:4]);
    uint64_t v11 = *(void *)(a1[6] + 8);
    id v12 = *(void **)(v11 + 40);
    *(void *)(v11 + 40) = v10;

    [(id)qword_10035CE60 setObject:*(void *)(*(void *)(a1[6] + 8) + 40) forKeyedSubscript:v9];
  }
}

void sub_1000CDB30(id a1)
{
  id v3 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t v1 = dispatch_queue_create("ckks-logger", v3);
  uint64_t v2 = (void *)qword_10035CE50;
  qword_10035CE50 = (uint64_t)v1;
}

void sub_1000CDEBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000CDEE0(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v17 = +[CKKSAnalytics logger];
  [v17 logResultForEvent:@"OctagonEventVoucherWithRecoveryKey" hardFailure:1 result:v15];

  if (v15)
  {
    char v18 = sub_10000B070("SecError");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v34 = v15;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "octagon: Error preparing voucher using recovery key: %@", buf, 0xCu);
    }

    [WeakRetained setError:v15];
LABEL_16:
    id v23 = [WeakRetained finishOp];
    [WeakRetained runBeforeGroupFinished:v23];
    goto LABEL_17;
  }
  unsigned int v19 = +[CKKSAnalytics logger];
  [v19 recordRecoveredTLKMetrics:*(void *)(a1 + 32) tlkRecoveryResults:v14 uniqueTLKsRecoveredEvent:@"OARKUniqueTLKsRecoveredCount" totalSharesRecoveredEvent:@"OARKTotalTLKSharesRecoveredCount" totalRecoverableTLKSharesEvent:@"OARKTotalTLKSharesCount" totalRecoverableTLKsEvent:@"OARKUniqueTLKsWithSharesCount" totalViewsWithSharesEvent:@"OARKTLKUniqueViewCount"];

  [WeakRetained setVoucher:v11];
  [WeakRetained setVoucherSig:v12];
  if (![WeakRetained saveVoucher])
  {
LABEL_13:
    unsigned int v26 = sub_10000B070("octagon");
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412546;
      id v34 = v11;
      __int16 v35 = 2112;
      id v36 = v12;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Successfully vouched with a recovery key: %@, %@", buf, 0x16u);
    }

    uint64_t v27 = [WeakRetained intendedState];
    [WeakRetained setNextState:v27];

    goto LABEL_16;
  }
  id v20 = sub_10000B070("octagon");
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Saving voucher for later use...", buf, 2u);
  }

  int v21 = [WeakRetained deps];
  unint64_t v22 = [v21 stateHolder];
  v29[0] = _NSConcreteStackBlock;
  v29[1] = 3221225472;
  v29[2] = sub_1000CE2F8;
  void v29[3] = &unk_1002F9FF0;
  id v30 = v11;
  id v31 = v12;
  id v32 = v13;
  id v28 = 0;
  [v22 persistAccountChanges:v29 error:&v28];
  id v23 = v28;

  if (!v23)
  {

    goto LABEL_13;
  }
  long long v24 = sub_10000B070("octagon");
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    id v34 = v23;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "unable to save voucher: %@", buf, 0xCu);
  }

  uint64_t v25 = [WeakRetained finishOp];
  [WeakRetained runBeforeGroupFinished:v25];

LABEL_17:
}

id sub_1000CE2F8(void *a1, void *a2)
{
  id v3 = a2;
  [v3 setVoucher:a1[4]];
  [v3 setVoucherSignature:a1[5]];
  [v3 setTLKSharesPairedWithVoucher:a1[6]];

  return v3;
}

void sub_1000CE46C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000CE490(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v8 = WeakRetained;
  if (v6)
  {
    id v9 = sub_10000B070("SecError");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v32 = v6;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "octagon: Error fetching TLKShares to recover: %@", buf, 0xCu);
    }

    [v8 setError:v6];
    os_log_t v10 = [v8 finishOp];
    [v8 runBeforeGroupFinished:v10];
  }
  else
  {
    uint64_t v25 = WeakRetained;
    os_log_t v10 = +[NSMutableArray array];
    long long v26 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    id v24 = v5;
    id v11 = v5;
    id v12 = [v11 countByEnumeratingWithState:&v26 objects:v30 count:16];
    if (v12)
    {
      id v13 = v12;
      uint64_t v14 = *(void *)v27;
      do
      {
        for (uint64_t i = 0; i != v13; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v27 != v14) {
            objc_enumerationMutation(v11);
          }
          id v16 = *(void **)(*((void *)&v26 + 1) + 8 * i);
          uint64_t v17 = [v16 recordType];
          unsigned int v18 = [v17 isEqual:@"tlkshare"];

          if (v18)
          {
            unsigned int v19 = [CKKSTLKShareRecord alloc];
            id v20 = [v25 deps];
            int v21 = [v20 contextID];
            unint64_t v22 = [(CKKSCKRecordHolder *)v19 initWithCKRecord:v16 contextID:v21];

            id v23 = [(CKKSTLKShareRecord *)v22 share];
            [v10 addObject:v23];
          }
        }
        id v13 = [v11 countByEnumeratingWithState:&v26 objects:v30 count:16];
      }
      while (v13);
    }

    id v8 = v25;
    [v25 proceedWithFilteredTLKShares:v10];
    id v6 = 0;
    id v5 = v24;
  }
}

void sub_1000CEA20(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000CEA4C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v11 = +[CKKSAnalytics logger];
  [v11 logResultForEvent:@"OctagonEventPreflightVouchWithRecoveryKey" hardFailure:1 result:v9];

  if (!v7 || v9)
  {
    id v15 = sub_10000B070("SecError");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = 138412290;
      id v18 = v9;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "octagon: Error preflighting voucher using recovery key: %@", (uint8_t *)&v17, 0xCu);
    }

    [WeakRetained setError:v9];
    id v16 = [WeakRetained finishOp];
    [WeakRetained runBeforeGroupFinished:v16];
  }
  else
  {
    id v12 = sub_10000B070("octagon");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = 138412290;
      id v18 = v7;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Recovery key ID %@ looks good to go", (uint8_t *)&v17, 0xCu);
    }

    id v13 = [WeakRetained deps];
    uint64_t v14 = [v13 ckks];
    [v14 setCurrentSyncingPolicy:v8];

    [WeakRetained proceedWithRecoveryKeyID:v7];
  }
}

void sub_1000CF088(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000CF0AC(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  int v17 = +[CKKSAnalytics logger];
  [v17 logResultForEvent:@"OctagonEventVoucherWithReroll" hardFailure:1 result:v15];

  if (v15)
  {
    id v18 = sub_10000B070("SecError");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v34 = v15;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "octagon: Error preparing voucher using reroll: %@", buf, 0xCu);
    }

    [WeakRetained setError:v15];
LABEL_16:
    id v23 = [WeakRetained finishOp];
    [WeakRetained runBeforeGroupFinished:v23];
    goto LABEL_17;
  }
  unsigned int v19 = +[CKKSAnalytics logger];
  [v19 recordRecoveredTLKMetrics:*(void *)(a1 + 32) tlkRecoveryResults:v14 uniqueTLKsRecoveredEvent:@"OARKUniqueTLKsRecoveredCount" totalSharesRecoveredEvent:@"OARKTotalTLKSharesRecoveredCount" totalRecoverableTLKSharesEvent:@"OARKTotalTLKSharesCount" totalRecoverableTLKsEvent:@"OARKUniqueTLKsWithSharesCount" totalViewsWithSharesEvent:@"OARKTLKUniqueViewCount"];

  [WeakRetained setVoucher:v11];
  [WeakRetained setVoucherSig:v12];
  if (![WeakRetained saveVoucher])
  {
LABEL_13:
    long long v26 = sub_10000B070("octagon");
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412546;
      id v34 = v11;
      __int16 v35 = 2112;
      id v36 = v12;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Successfully vouched with a reroll: %@, %@", buf, 0x16u);
    }

    long long v27 = [WeakRetained intendedState];
    [WeakRetained setNextState:v27];

    goto LABEL_16;
  }
  id v20 = sub_10000B070("octagon");
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Saving voucher for later use...", buf, 2u);
  }

  int v21 = [WeakRetained deps];
  unint64_t v22 = [v21 stateHolder];
  v29[0] = _NSConcreteStackBlock;
  v29[1] = 3221225472;
  v29[2] = sub_1000CF4C4;
  void v29[3] = &unk_1002F9FF0;
  id v30 = v11;
  id v31 = v12;
  id v32 = v13;
  id v28 = 0;
  [v22 persistAccountChanges:v29 error:&v28];
  id v23 = v28;

  if (!v23)
  {

    goto LABEL_13;
  }
  id v24 = sub_10000B070("octagon");
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    id v34 = v23;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "unable to save voucher: %@", buf, 0xCu);
  }

  uint64_t v25 = [WeakRetained finishOp];
  [WeakRetained runBeforeGroupFinished:v25];

LABEL_17:
}

id sub_1000CF4C4(void *a1, void *a2)
{
  id v3 = a2;
  [v3 setVoucher:a1[4]];
  [v3 setVoucherSignature:a1[5]];
  [v3 setTLKSharesPairedWithVoucher:a1[6]];

  return v3;
}

void sub_1000CF838(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000CF864(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (v6)
  {
    id v7 = sub_10000B070("SecError");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v30 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "octagon: Error fetching TLKShares to recover: %@", buf, 0xCu);
    }
  }
  id v8 = +[NSMutableArray array];
  long long v24 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v27 = 0u;
  id v9 = v5;
  id v10 = [v9 countByEnumeratingWithState:&v24 objects:v28 count:16];
  if (v10)
  {
    id v11 = v10;
    uint64_t v12 = *(void *)v25;
    do
    {
      for (uint64_t i = 0; i != v11; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v25 != v12) {
          objc_enumerationMutation(v9);
        }
        id v14 = *(void **)(*((void *)&v24 + 1) + 8 * i);
        id v15 = [v14 recordType];
        unsigned int v16 = [v15 isEqual:@"tlkshare"];

        if (v16)
        {
          int v17 = [CKKSTLKShareRecord alloc];
          id v18 = [WeakRetained deps];
          unsigned int v19 = [v18 contextID];
          id v20 = [(CKKSCKRecordHolder *)v17 initWithCKRecord:v14 contextID:v19];

          int v21 = [(CKKSTLKShareRecord *)v20 share];
          [v8 addObject:v21];
        }
      }
      id v11 = [v9 countByEnumeratingWithState:&v24 objects:v28 count:16];
    }
    while (v11);
  }

  [WeakRetained proceedWithFilteredTLKShares:v8];
}

void sub_1000D0638(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_1000D2F18(uint64_t a1)
{
  return [*(id *)(a1 + 32) deviceDidLock];
}

void sub_1000D372C(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 112));
  _Unwind_Resume(a1);
}

void sub_1000D3754(id *a1)
{
  uint64_t v2 = (void *)os_transaction_create();
  id v3 = [a1[4] queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000D39B0;
  block[3] = &unk_1003059C0;
  id v6 = v2;
  id v4 = v2;
  objc_copyWeak(&v8, a1 + 6);
  id v7 = a1[5];
  dispatch_sync(v3, block);

  objc_destroyWeak(&v8);
}

void sub_1000D3848(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 48));
  id v3 = WeakRetained;
  if (WeakRetained && [WeakRetained isPending])
  {
    id v4 = KCSharingLogObject();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v11 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Not setting up resync: have extant operation", v11, 2u);
    }

    uint64_t v5 = *(void *)(a1 + 48);
    id v6 = +[NSError errorWithDomain:@"KCSharingErrorDomain" code:37 userInfo:0];
    (*(void (**)(uint64_t, void, void *))(v5 + 16))(v5, 0, v6);
  }
  else
  {
    id v7 = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 32));
    id v6 = v7;
    if (*(unsigned char *)(a1 + 56)) {
      BOOL v8 = v7 == 0;
    }
    else {
      BOOL v8 = 1;
    }
    if (v8 || ![v7 isPending])
    {
      [*(id *)(a1 + 40) addNullableDependency:v6];
    }
    else
    {
      uint64_t v9 = *(void *)(a1 + 48);
      id v10 = +[NSError errorWithDomain:@"KCSharingErrorDomain" code:35 userInfo:0];
      (*(void (**)(uint64_t, void, void *))(v9 + 16))(v9, 0, v10);
    }
  }
}

void sub_1000D39B0(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v3 = WeakRetained;
  if (WeakRetained)
  {
    if (*((void *)WeakRetained + 10) && *((void *)WeakRetained + 11))
    {
      CFTypeRef cf = 0;
      if (!sub_10002AC5C(dword_10035D2B0, &cf))
      {
        id v4 = KCSharingLogObject();
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138412290;
          CFTypeRef v67 = cf;
          _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Unable to acquire AKS lock assertion: %@", buf, 0xCu);
        }
      }
      CFTypeRef v5 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        CFRelease(v5);
      }
      id v6 = KCSharingLogObject();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Starting resync operation with merge", buf, 2u);
      }

      id v7 = [v3 store];
      id v62 = 0;
      unsigned __int8 v8 = [v7 mergeWithError:&v62];
      id v9 = v62;

      if ((v8 & 1) == 0)
      {
        uint64_t v44 = KCSharingLogObject();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138412290;
          CFTypeRef v67 = v9;
          _os_log_error_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "Failed resync during merge: %@", buf, 0xCu);
        }

        (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
        id v14 = v9;
        goto LABEL_58;
      }
      id v10 = +[NSMutableDictionary dictionary];
      id v11 = +[NSMutableDictionary dictionary];
      uint64_t v12 = KCSharingLogObject();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Resync: obtaining list of groups from CloudKit", buf, 2u);
      }

      id v61 = v9;
      unsigned __int8 v13 = [v3 obtainAuthoritativeGroupsForPrivate:v10 shared:v11 error:&v61];
      id v14 = v61;

      if (v13)
      {
        if ([v10 count] || objc_msgSend(v11, "count"))
        {
          id v50 = v11;
          [v3 setCurrentUserMetadataFeatureUsage:2 v14];
          id v15 = KCSharingLogObject();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Resync: setting change tokens to nil", buf, 2u);
          }
          uint64_t v49 = a1;

          unsigned int v16 = [v3 privateSyncEngine];
          int v17 = [v16 state];
          [v17 setServerChangeTokenForDatabase:0];

          id v18 = [v3 sharedSyncEngine];
          unsigned int v19 = [v18 state];
          [v19 setServerChangeTokenForDatabase:0];

          long long v59 = 0u;
          long long v60 = 0u;
          long long v57 = 0u;
          long long v58 = 0u;
          id v20 = [v10 allKeys];
          id v21 = [v20 countByEnumeratingWithState:&v57 objects:v65 count:16];
          if (v21)
          {
            id v22 = v21;
            uint64_t v23 = *(void *)v58;
            do
            {
              for (uint64_t i = 0; i != v22; uint64_t i = (char *)i + 1)
              {
                if (*(void *)v58 != v23) {
                  objc_enumerationMutation(v20);
                }
                long long v25 = *(const void **)(*((void *)&v57 + 1) + 8 * i);
                long long v26 = KCSharingLogObject();
                if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)long long buf = 138412290;
                  CFTypeRef v67 = v25;
                  _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Setting private DB change token to nil for zoneID %@", buf, 0xCu);
                }

                long long v27 = [v3 privateSyncEngine];
                id v28 = [v27 state];
                [v28 setServerChangeToken:0 forZoneID:v25];
              }
              id v22 = [v20 countByEnumeratingWithState:&v57 objects:v65 count:16];
            }
            while (v22);
          }

          long long v55 = 0u;
          long long v56 = 0u;
          long long v53 = 0u;
          long long v54 = 0u;
          long long v29 = [v50 allKeys];
          id v30 = [v29 countByEnumeratingWithState:&v53 objects:v64 count:16];
          if (v30)
          {
            id v31 = v30;
            uint64_t v32 = *(void *)v54;
            do
            {
              for (j = 0; j != v31; j = (char *)j + 1)
              {
                if (*(void *)v54 != v32) {
                  objc_enumerationMutation(v29);
                }
                id v34 = *(const void **)(*((void *)&v53 + 1) + 8 * (void)j);
                __int16 v35 = KCSharingLogObject();
                if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)long long buf = 138412290;
                  CFTypeRef v67 = v34;
                  _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "Setting shared DB change token to nil for zoneID %@", buf, 0xCu);
                }

                id v36 = [v3 sharedSyncEngine];
                unint64_t v37 = [v36 state];
                [v37 setServerChangeToken:0 forZoneID:v34];
              }
              id v31 = [v29 countByEnumeratingWithState:&v53 objects:v64 count:16];
            }
            while (v31);
          }

          uint64_t v38 = KCSharingLogObject();
          if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "Resync: kicking off full CK fetch", buf, 2u);
          }

          v51[0] = _NSConcreteStackBlock;
          v51[1] = 3221225472;
          v51[2] = sub_1000D4244;
          v51[3] = &unk_1002FB1E8;
          id v52 = *(id *)(v49 + 40);
          [v3 _onQueueFetchRemoteChangesForZoneIDs:0 completion:v51];
          id v14 = v48;
          if (!sub_10002AE24(dword_10035D2B0, &cf))
          {
            uint64_t v39 = KCSharingLogObject();
            if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 138412290;
              CFTypeRef v67 = cf;
              _os_log_error_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "Failed to drop AKS lock assertion: %@", buf, 0xCu);
            }
          }
          CFTypeRef v40 = cf;
          id v11 = v50;
          if (cf)
          {
            CFTypeRef cf = 0;
            CFRelease(v40);
          }

          goto LABEL_57;
        }
        uint64_t v47 = KCSharingLogObject();
        if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "CloudKit reports no private and no shared groups, returning early from resync", buf, 2u);
        }

        [v3 setCurrentUserMetadataFeatureUsage:1];
        unint64_t v46 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
      }
      else
      {
        id v45 = KCSharingLogObject();
        if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138412290;
          CFTypeRef v67 = v14;
          _os_log_error_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "Cannot resync due to failure to fetch all CK groups: %@", buf, 0xCu);
        }

        unint64_t v46 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
      }
      v46();
LABEL_57:

LABEL_58:
      goto LABEL_59;
    }
    uint64_t v41 = *(void *)(a1 + 40);
    uint64_t v42 = 36;
  }
  else
  {
    uint64_t v41 = *(void *)(a1 + 40);
    uint64_t v42 = 14;
  }
  uint64_t v43 = +[NSError errorWithDomain:@"KCSharingErrorDomain" code:v42 userInfo:0];
  (*(void (**)(uint64_t, void, void *))(v41 + 16))(v41, 0, v43);

LABEL_59:
}

void sub_1000D4244(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = KCSharingLogObject();
  CFTypeRef v5 = v4;
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v6 = 138412290;
      id v7 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Resync failed: %@", (uint8_t *)&v6, 0xCu);
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v6) = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Resync complete", (uint8_t *)&v6, 2u);
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000D4F00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

uint64_t sub_1000D4F40(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1000D4F50(uint64_t a1)
{
}

void sub_1000D4F58(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  id v20 = v5;
  if (!v5)
  {
    long long v24 = 0u;
    long long v25 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    id v8 = [v4 countByEnumeratingWithState:&v22 objects:v26 count:16];
    if (!v8) {
      goto LABEL_21;
    }
    id v9 = v8;
    uint64_t v10 = *(void *)v23;
LABEL_7:
    uint64_t v11 = 0;
    while (1)
    {
      if (*(void *)v23 != v10) {
        objc_enumerationMutation(v4);
      }
      uint64_t v12 = *(void **)(*((void *)&v22 + 1) + 8 * v11);
      unsigned __int8 v13 = [v4 objectForKeyedSubscript:v12];
      id v14 = [v13 share];

      if (!v14) {
        break;
      }
      id v15 = [v12 zoneName];
      unsigned __int8 v16 = [v15 hasPrefix:@"group-"];

      if ((v16 & 1) == 0)
      {
        int v17 = KCSharingLogObject();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138543362;
          id v28 = v13;
          id v18 = v17;
          unsigned int v19 = "Ignoring Private DB CKRecordZone with non-group zoneID: %{public}@";
LABEL_17:
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, v19, buf, 0xCu);
        }
        goto LABEL_18;
      }
      [*(id *)(a1 + 40) setObject:v13 forKeyedSubscript:v12];
LABEL_19:

      if (v9 == (id)++v11)
      {
        id v9 = [v4 countByEnumeratingWithState:&v22 objects:v26 count:16];
        if (!v9) {
          goto LABEL_21;
        }
        goto LABEL_7;
      }
    }
    int v17 = KCSharingLogObject();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138543362;
      id v28 = v13;
      id v18 = v17;
      unsigned int v19 = "Ignoring Private DB CKRecordZone without a CKShare: %{public}@";
      goto LABEL_17;
    }
LABEL_18:

    goto LABEL_19;
  }
  id v6 = v5;
  id v7 = KCSharingLogObject();
  if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 138543362;
    id v28 = v6;
    _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to fetch record zones from Private DB: %{public}@", buf, 0xCu);
  }

  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), a3);
LABEL_21:
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_1000D521C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v18 = v6;
  if (v6)
  {
    id v7 = v6;
    id v8 = KCSharingLogObject();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138543362;
      long long v25 = v7;
      _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to fetch record zones from Shared DB: %{public}@", buf, 0xCu);
    }

    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), a3);
  }
  else
  {
    long long v21 = 0u;
    long long v22 = 0u;
    long long v19 = 0u;
    long long v20 = 0u;
    id v9 = [v5 countByEnumeratingWithState:&v19 objects:v23 count:16];
    if (v9)
    {
      id v10 = v9;
      uint64_t v11 = *(void *)v20;
      do
      {
        for (uint64_t i = 0; i != v10; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v20 != v11) {
            objc_enumerationMutation(v5);
          }
          unsigned __int8 v13 = *(void **)(*((void *)&v19 + 1) + 8 * i);
          id v14 = [v13 zoneName];
          unsigned __int8 v15 = [v14 hasPrefix:@"group-"];

          if (v15)
          {
            unsigned __int8 v16 = [v5 objectForKeyedSubscript:v13];
            [*(id *)(a1 + 40) setObject:v16 forKeyedSubscript:v13];
          }
          else
          {
            unsigned __int8 v16 = KCSharingLogObject();
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
            {
              int v17 = [v5 objectForKeyedSubscript:v13];
              *(_DWORD *)long long buf = 138543362;
              long long v25 = v17;
              _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Ignoring Shared DB CKRecordZone with non-group zoneID: %{public}@", buf, 0xCu);
            }
          }
        }
        id v10 = [v5 countByEnumeratingWithState:&v19 objects:v23 count:16];
      }
      while (v10);
    }
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_1000D5F98(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = KCSharingLogObject();
  id v5 = v4;
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = *(void *)(a1 + 32);
      int v8 = 138412546;
      uint64_t v9 = v6;
      __int16 v10 = 2112;
      id v11 = v3;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "ksmd errored sending new invites for group %@: %@", (uint8_t *)&v8, 0x16u);
    }
  }
  else if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a1 + 32);
    int v8 = 138412290;
    uint64_t v9 = v7;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "ksmd sent new invites if needed for group %@", (uint8_t *)&v8, 0xCu);
  }
}

void sub_1000D6558(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  _Block_object_dispose((const void *)(v33 - 160), 8);
  _Block_object_dispose(&a33, 8);
  _Unwind_Resume(a1);
}

void sub_1000D6590(uint64_t a1, void *a2)
{
  id v6 = a2;
  if (v6)
  {
    id v3 = *(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
    objc_sync_enter(v3);
    [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) addObject:v6];
    objc_sync_exit(v3);

    id v4 = *(void **)(a1 + 32);
    id v5 = [v4 privateSyncEngine];
    [v4 isLockedError:v6 duringFetchForEngine:v5];
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

void sub_1000D6648(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000D665C(uint64_t a1, void *a2)
{
  id v6 = a2;
  if (v6)
  {
    id v3 = *(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
    objc_sync_enter(v3);
    [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) addObject:v6];
    objc_sync_exit(v3);

    id v4 = *(void **)(a1 + 32);
    id v5 = [v4 sharedSyncEngine];
    [v4 isLockedError:v6 duringFetchForEngine:v5];
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 40));
}

void sub_1000D6714(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000D6728(void *a1)
{
  if (*(void *)(*(void *)(a1[5] + 8) + 40))
  {
LABEL_2:
    uint64_t v2 = KCSharingLogObject();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = *(void *)(*(void *)(a1[5] + 8) + 40);
      int v10 = 138543362;
      uint64_t v11 = v9;
      _os_log_error_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "Failed to force-fetch remote changes: %{public}@", (uint8_t *)&v10, 0xCu);
    }
    goto LABEL_4;
  }
  if ([*(id *)(*(void *)(a1[6] + 8) + 40) count])
  {
    if (!*(void *)(*(void *)(a1[5] + 8) + 40))
    {
      NSErrorUserInfoKey v12 = NSMultipleUnderlyingErrorsKey;
      id v4 = [*(id *)(*(void *)(a1[6] + 8) + 40) copy];
      id v13 = v4;
      id v5 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      uint64_t v6 = +[NSError errorWithDomain:@"KCSharingErrorDomain" code:14 userInfo:v5];
      uint64_t v7 = *(void *)(a1[5] + 8);
      int v8 = *(void **)(v7 + 40);
      *(void *)(v7 + 40) = v6;
    }
    goto LABEL_2;
  }
  uint64_t v2 = KCSharingLogObject();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v10) = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Force-fetch remote changes complete", (uint8_t *)&v10, 2u);
  }
LABEL_4:

  return (*(uint64_t (**)(void))(a1[4] + 16))();
}

id sub_1000D69E4(uint64_t a1)
{
  return [*(id *)(a1 + 32) _onQueueFetchRemoteChangesForZoneIDs:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];
}

void sub_1000D6C78(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 112), 8);
  _Unwind_Resume(a1);
}

void sub_1000D6C94(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (v4)
  {
    id v3 = *(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    objc_sync_enter(v3);
    [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) addObject:v4];
    objc_sync_exit(v3);
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_1000D6D1C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000D6D30(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (v4)
  {
    id v3 = *(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    objc_sync_enter(v3);
    [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) addObject:v4];
    objc_sync_exit(v3);
  }
  dispatch_group_leave(*(dispatch_group_t *)(a1 + 32));
}

void sub_1000D6DB8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000D6DCC(uint64_t a1)
{
  if ([*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) count])
  {
    NSErrorUserInfoKey v8 = NSMultipleUnderlyingErrorsKey;
    id v2 = [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) copy];
    id v9 = v2;
    id v3 = +[NSDictionary dictionaryWithObjects:&v9 forKeys:&v8 count:1];
    id v4 = +[NSError errorWithDomain:@"KCSharingErrorDomain" code:14 userInfo:v3];

    id v5 = KCSharingLogObject();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      int v6 = 138543362;
      uint64_t v7 = v4;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to save local changes: %{public}@", (uint8_t *)&v6, 0xCu);
    }
  }
  else
  {
    id v5 = KCSharingLogObject();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      LOWORD(v6) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_INFO, "Saved local changes", (uint8_t *)&v6, 2u);
    }
    id v4 = 0;
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000D70B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  objc_destroyWeak(v16);
  _Block_object_dispose(&a16, 8);
  objc_destroyWeak((id *)(v17 - 40));
  _Unwind_Resume(a1);
}

void sub_1000D70E0(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    id v3 = KCSharingLogObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_INFO))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_INFO, "Staging all outgoing changes", buf, 2u);
    }

    id v4 = [WeakRetained store];
    id v13 = 0;
    unsigned __int8 v5 = [v4 stageAllOutgoingChangesWithError:&v13];
    id v6 = v13;

    if (v5)
    {
      uint64_t v7 = KCSharingLogObject();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_INFO, "Triggering syncs for private and shared databases after staging changes", buf, 2u);
      }

      NSErrorUserInfoKey v8 = [WeakRetained privateSyncEngine];
      [v8 setHasPendingModifications];

      id v9 = [WeakRetained sharedSyncEngine];
      [v9 setHasPendingModifications];
    }
    else
    {
      [WeakRetained isLockedError:v6];
      int v10 = KCSharingLogObject();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138543362;
        id v15 = v6;
        _os_log_error_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "Failed to stage outgoing changes: %{public}@", buf, 0xCu);
      }

      uint64_t v11 = *(void *)(*(void *)(a1 + 32) + 8);
      id v12 = v6;
      id v9 = *(void **)(v11 + 40);
      *(void *)(v11 + 40) = v12;
    }
  }
}

void sub_1000D74B0(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 80));
  _Unwind_Resume(a1);
}

void sub_1000D74D0(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    id v3 = KCSharingLogObject();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Performing KCSharing maintenance now", buf, 2u);
    }

    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472;
    v4[2] = sub_1000D76D8;
    v4[3] = &unk_1002FA768;
    v4[4] = WeakRetained;
    id v5 = *(id *)(a1 + 32);
    [WeakRetained saveAllOutgoingChangesWithCompletion:v4];
  }
}

void sub_1000D75C8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 40));
  id v3 = WeakRetained;
  if (WeakRetained && [WeakRetained isPending])
  {
    id v4 = KCSharingLogObject();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)id v9 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Not setting up maintenance: have extant operation", v9, 2u);
    }

    uint64_t v5 = *(void *)(a1 + 48);
    id v6 = +[NSError errorWithDomain:@"KCSharingErrorDomain" code:37 userInfo:0];
    (*(void (**)(uint64_t, void *))(v5 + 16))(v5, v6);
  }
  else
  {
    objc_storeWeak((id *)(*(void *)(a1 + 32) + 40), *(id *)(a1 + 40));
    uint64_t v7 = *(void **)(a1 + 40);
    id v8 = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 32));
    [v7 addNullableDependency:v8];
  }
}

void sub_1000D76D8(uint64_t a1, void *a2)
{
  id v3 = a2;
  if ([*(id *)(a1 + 32) isLockedError:v3])
  {
    id v4 = KCSharingLogObject();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Failed to complete maintenance due to lockstate, rescheduling", v5, 2u);
    }

    [*(id *)(a1 + 32) performMaintenanceWithCompletion:*(void *)(a1 + 40)];
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

void sub_1000D7864(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_1000D7880(uint64_t a1, void *a2)
{
  id v7 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v4 = WeakRetained;
  if (v7)
  {
    uint64_t v5 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
LABEL_3:
    v5();
    goto LABEL_6;
  }
  uint64_t v6 = *(void *)(a1 + 32);
  if (!WeakRetained)
  {
    uint64_t v5 = *(void (**)(void))(v6 + 16);
    goto LABEL_3;
  }
  [WeakRetained saveStagedOutgoingChangesWithCompletion:v6];
LABEL_6:
}

void sub_1000D7998(id a1, NSError *a2)
{
  uint64_t v2 = a2;
  id v3 = KCSharingLogObject();
  id v4 = v3;
  if (v2)
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v5 = 138412290;
      uint64_t v6 = v2;
      _os_log_error_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "Failed to process KCSharing-relevant SecDb modifications: %@", (uint8_t *)&v5, 0xCu);
    }
  }
  else if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v5) = 0;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Processed KCSharing-relevant SecDb modifications", (uint8_t *)&v5, 2u);
  }
}

void sub_1000D7CB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000D7CD8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (WeakRetained)
  {
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_1000D7D94;
    v3[3] = &unk_1002F97E0;
    id v4 = *(id *)(a1 + 32);
    char v7 = *(unsigned char *)(a1 + 56);
    id v5 = *(id *)(a1 + 40);
    id v6 = WeakRetained;
    [WeakRetained ensureCurrentUserProvisionedWithCompletion:v3];
  }
}

void sub_1000D7D94(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = KCSharingLogObject();
  id v5 = v4;
  if (v3)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v8 = 138412290;
      uint64_t v9 = (uint64_t)v3;
      _os_log_error_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "Failed to provision current user with error=%@", (uint8_t *)&v8, 0xCu);
    }
    uint64_t v6 = 3;
  }
  else
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v_Block_object_dispose(&STACK[0x3F0], 8) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Successfully provisioned current user", (uint8_t *)&v8, 2u);
    }
    uint64_t v6 = 0;
  }

  if (!*(unsigned char *)(a1 + 56) && (xpc_activity_set_completion_status() & 1) == 0)
  {
    char v7 = KCSharingLogObject();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v8 = 134217984;
      uint64_t v9 = v6;
      _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Failed to set completion status=%ld for provisioning activity", (uint8_t *)&v8, 0xCu);
    }
  }
  [*(id *)(a1 + 48) unregisterProvisioningActivity];
  if (v3) {
    [*(id *)(a1 + 48) handleProvisioningActivity:*(void *)(a1 + 40) isRetry:1];
  }
}

id sub_1000D8030(uint64_t a1, uint64_t a2)
{
  return [*(id *)(a1 + 32) handleProvisioningActivity:a2 isRetry:0];
}

void sub_1000D81D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000D81F8(id *a1)
{
  uint64_t v2 = (void *)os_transaction_create();
  id v3 = [a1[4] queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000D82EC;
  block[3] = &unk_1003059C0;
  id v6 = v2;
  id v4 = v2;
  objc_copyWeak(&v8, a1 + 6);
  id v7 = a1[5];
  dispatch_async(v3, block);

  objc_destroyWeak(&v8);
}

void sub_1000D82EC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v3 = WeakRetained;
  if (WeakRetained)
  {
    uint64_t v4 = [WeakRetained privateSyncEngine];
    if (v4
      && (id v5 = (void *)v4,
          [v3 sharedSyncEngine],
          id v6 = objc_claimAutoreleasedReturnValue(),
          v6,
          v5,
          v6))
    {
      id v7 = KCSharingLogObject();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Starting preflight", buf, 2u);
      }

      CFTypeRef cf = 0;
      if (!sub_10002AC5C(dword_10035D2B0, &cf))
      {
        id v8 = KCSharingLogObject();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138412290;
          CFTypeRef v42 = cf;
          _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Unable to acquire AKS lock assertion: %@", buf, 0xCu);
        }

        CFTypeRef v9 = cf;
        if (cf)
        {
          CFTypeRef cf = 0;
          CFRelease(v9);
        }
      }
      int v10 = KCSharingLogObject();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_INFO, "Merging pending incoming changes during preflight", buf, 2u);
      }

      uint64_t v11 = [v3 store];
      id v39 = 0;
      unsigned __int8 v12 = [v11 mergeWithError:&v39];
      id v13 = v39;

      id v14 = KCSharingLogObject();
      id v15 = v14;
      if (v12)
      {
        if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_INFO, "Checking for pending outgoing changes during preflight", buf, 2u);
        }

        unsigned __int8 v16 = [v3 store];
        uint64_t v17 = [v3 privateSyncEngine];
        id v18 = [v17 database];
        unsigned int v19 = [v16 hasOutgoingChangesInDatabaseWithScope:[v18 databaseScope]];

        if (v19)
        {
          long long v20 = [v3 privateSyncEngine];
          [v20 setHasPendingModifications];
        }
        long long v21 = [v3 store];
        long long v22 = [v3 sharedSyncEngine];
        long long v23 = [v22 database];
        unsigned int v24 = [v21 hasOutgoingChangesInDatabaseWithScope:[v23 databaseScope]];

        if (v24)
        {
          long long v25 = [v3 sharedSyncEngine];
          [v25 setHasPendingModifications];
        }
        unsigned int v26 = [v3 isCurrentUserProvisioned];
        long long v27 = KCSharingLogObject();
        BOOL v28 = os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT);
        if (v26)
        {
          if (v28)
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Not registering provisioning activity; user already provisioned",
              buf,
              2u);
          }
        }
        else
        {
          if (v28)
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Registering provisioning activity", buf, 2u);
          }

          [v3 registerProvisioningActivity];
        }
        if (!sub_10002AE24(dword_10035D2B0, &cf))
        {
          id v36 = KCSharingLogObject();
          if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138412290;
            CFTypeRef v42 = cf;
            _os_log_error_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "Failed to drop AKS lock assertion: %@", buf, 0xCu);
          }

          CFTypeRef v37 = cf;
          if (cf)
          {
            CFTypeRef cf = 0;
            CFRelease(v37);
          }
        }
        uint64_t v38 = KCSharingLogObject();
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "Preflight complete", buf, 2u);
        }

        (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
      }
      else
      {
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138412290;
          CFTypeRef v42 = v13;
          _os_log_error_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "Preflight error during merge: %@", buf, 0xCu);
        }

        unsigned int v30 = [v3 isLockedError:v13];
        id v31 = KCSharingLogObject();
        BOOL v32 = os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT);
        if (v30)
        {
          if (v32)
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Rescheduling preflight for next unlock", buf, 2u);
          }

          uint64_t v33 = *(void *)(a1 + 40);
          id v34 = v3;
          uint64_t v35 = 0;
        }
        else
        {
          if (v32)
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Rescheduling preflight with delay", buf, 2u);
          }

          uint64_t v33 = *(void *)(a1 + 40);
          id v34 = v3;
          uint64_t v35 = 1;
        }
        [v34 preflightWithCompletion:v33 delay:v35];
      }
    }
    else
    {
      long long v29 = KCSharingLogObject();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Deferring preflight because engines aren't loaded", buf, 2u);
      }

      [v3 preflightWithCompletion:*(void *)(a1 + 40) delay:0];
    }
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

void sub_1000D8904(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v3 = WeakRetained;
  if (WeakRetained)
  {
    [WeakRetained deviceDidLock];
    uint64_t v4 = *(void **)(a1 + 32);
    if (v4)
    {
      [v4 cancelOperationsWithCompletionHandler:&stru_1002F9790];
      id v5 = [*(id *)(a1 + 32) database];
      id v6 = [v5 databaseScope];

      if (v6 == (id)3)
      {
        v3[9] = 1;
      }
      else if (v6 == (id)2)
      {
        void v3[8] = 1;
      }
      else
      {
        id v7 = KCSharingLogObject();
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        {
          id v8 = [*(id *)(a1 + 32) database];
          int v9 = 134217984;
          id v10 = [v8 databaseScope];
          _os_log_error_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "Very unusual database scope: %ld", (uint8_t *)&v9, 0xCu);
        }
      }
    }
  }
}

void sub_1000D8E50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000D8E78(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000D8F24;
  block[3] = &unk_1003077A0;
  objc_copyWeak(&v4, (id *)(a1 + 40));
  dispatch_sync(v2, block);

  objc_destroyWeak(&v4);
}

void sub_1000D8F24(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v2 = WeakRetained;
  if (WeakRetained)
  {
    if (WeakRetained[10] && WeakRetained[11])
    {
      id v3 = KCSharingLogObject();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Not reinitializing sync engines, they are already instantiated", buf, 2u);
      }
    }
    else
    {
      id v4 = KCSharingLogObject();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "(Re)initializing sync engines", buf, 2u);
      }

      id v5 = (void *)*((void *)v2 + 8);
      id v26 = 0;
      id v6 = [v5 fetchValueForMetadataKey:@"CKSyncEnginePrivateMetadata" error:&v26];
      id v7 = v26;
      if (v7)
      {
        id v3 = v7;
        id v8 = KCSharingLogObject();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 138543362;
          BOOL v28 = v3;
          _os_log_error_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "Failed to fetch private engine metadata: %{public}@", buf, 0xCu);
        }

        if (([v2 isLockedError:v3] & 1) == 0) {
          [v2 resetReinitOperationWithDelay:1];
        }
      }
      else
      {
        id v9 = objc_alloc((Class)CKSyncEngineConfiguration);
        id v10 = [*((id *)v2 + 9) privateCloudDatabase];
        id v11 = [v9 initWithDatabase:v10 dataSource:v2 metadata:v6];

        unsigned __int8 v12 = (void *)*((void *)v2 + 8);
        id v25 = 0;
        id v13 = [v12 fetchValueForMetadataKey:@"CKSyncEngineSharedMetadata" error:&v25];
        id v3 = v25;
        if (v3)
        {
          id v14 = KCSharingLogObject();
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 138543362;
            BOOL v28 = v3;
            _os_log_error_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "Failed to fetch shared engine metadata: %{public}@", buf, 0xCu);
          }

          if (([v2 isLockedError:v3] & 1) == 0) {
            [v2 resetReinitOperationWithDelay:1];
          }
        }
        else
        {
          id v15 = objc_alloc((Class)CKSyncEngineConfiguration);
          unsigned __int8 v16 = [*((id *)v2 + 9) sharedCloudDatabase];
          id v17 = [v15 initWithDatabase:v16 dataSource:v2 metadata:v13];

          [v11 setApsMachServiceName:@"com.apple.securityd.aps"];
          [v17 setApsMachServiceName:@"com.apple.securityd.aps"];
          xpc_object_t empty = xpc_dictionary_create_empty();
          xpc_dictionary_set_value(empty, XPC_ACTIVITY_REQUIRES_CLASS_A, &_xpc_BOOL_true);
          [v11 setXpcActivityCriteriaOverrides:empty];
          [v17 setXpcActivityCriteriaOverrides:empty];
          id v19 = [objc_alloc((Class)CKSyncEngine) initWithConfiguration:v11];
          long long v20 = (void *)*((void *)v2 + 10);
          *((void *)v2 + 10) = v19;

          id v21 = [objc_alloc((Class)CKSyncEngine) initWithConfiguration:v17];
          long long v22 = (void *)*((void *)v2 + 11);
          *((void *)v2 + 11) = v21;

          if (*((unsigned char *)v2 + 8))
          {
            long long v23 = KCSharingLogObject();
            if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "Sync engine reinit: private engine needs to fetch changes", buf, 2u);
            }

            [*((id *)v2 + 10) setNeedsToFetchChanges];
            *((unsigned char *)v2 + _Block_object_dispose(&STACK[0x3F0], 8) = 0;
          }
          if (*((unsigned char *)v2 + 9))
          {
            unsigned int v24 = KCSharingLogObject();
            if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Sync engine reinit: shared engine needs to fetch changes", buf, 2u);
            }

            [*((id *)v2 + 11) setNeedsToFetchChanges];
            *((unsigned char *)v2 + 9) = 0;
          }
        }
      }
    }
  }
}

void sub_1000D9714(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id location)
{
  objc_destroyWeak(v24);
  objc_destroyWeak(v23);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000D9750(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v2 = WeakRetained;
  if (WeakRetained)
  {
    id v3 = [WeakRetained queue];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000D9970;
    block[3] = &unk_100308558;
    id v5 = v2;
    dispatch_async(v3, block);
  }
}

void sub_1000D97FC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v2 = WeakRetained;
  if (WeakRetained)
  {
    id v3 = [WeakRetained queue];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000D98A8;
    block[3] = &unk_100308558;
    id v5 = v2;
    dispatch_async(v3, block);
  }
}

void sub_1000D98A8(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 88);
  id v3 = KCSharingLogObject();
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      *(_WORD *)id v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Received shared DB push while engine is online, ignoring", v5, 2u);
    }
  }
  else
  {
    if (v4)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Received shared DB push while engine was offline, making note of this.", buf, 2u);
    }

    *(unsigned char *)(*(void *)(a1 + 32) + 9) = 1;
  }
}

void sub_1000D9970(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 80);
  id v3 = KCSharingLogObject();
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      *(_WORD *)id v5 = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "CKNotificationListener received private DB push while engine is online, ignoring", v5, 2u);
    }
  }
  else
  {
    if (v4)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "CKNotificationListener received private DB push while engine was offline, making note of this.", buf, 2u);
    }

    *(unsigned char *)(*(void *)(a1 + 32) + _Block_object_dispose(&STACK[0x3F0], 8) = 1;
  }
}

void sub_1000D9BB4(id a1)
{
  qword_10035CE70 = objc_alloc_init(KCSharingSyncController);

  _objc_release_x1();
}

void sub_1000DA964(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    BOOL v4 = sub_10000B070("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 138412290;
      id v6 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "octagon: failed to reset cdp account contents: %@", (uint8_t *)&v5, 0xCu);
    }
  }
  else
  {
    BOOL v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v5) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "successfully reset cdp account contents", (uint8_t *)&v5, 2u);
    }
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000DACE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va1, a7);
  va_start(va, a7);
  uint64_t v8 = va_arg(va1, void);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000DAD14(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1000DAD24(uint64_t a1)
{
}

void sub_1000DAD2C(uint64_t a1, void *a2, void *a3)
{
  id v6 = a2;
  id v7 = a3;
  if (v7)
  {
    uint64_t v8 = sub_10000B070("octagon-metrics");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 138412290;
      id v11 = v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Unable to fetch trust status: %@", (uint8_t *)&v10, 0xCu);
    }

    uint64_t v9 = a1 + 32;
  }
  else
  {
    uint64_t v9 = a1 + 40;
    a3 = a2;
  }
  objc_storeStrong((id *)(*(void *)(*(void *)v9 + 8) + 40), a3);
}

void sub_1000DAFA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v7 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1000DAFCC(uint64_t a1, void *a2, void *a3)
{
  id v6 = a3;
  if (v6)
  {
    uint64_t v7 = sub_10000B070("octagon");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      id v9 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Unable to get honorIDMSListChanges: %@", (uint8_t *)&v8, 0xCu);
    }

    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), a3);
  }
  else if ([a2 isEqualToString:@"YES"])
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
  }
}

void sub_1000DB318(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000DB344(void *a1, void *a2, void *a3)
{
  id v5 = a3;
  if (v5)
  {
    id v6 = sub_10000B070("octagon-metrics");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = 138412290;
      id v13 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Failed to fetch allowed machineIDs: %@", (uint8_t *)&v12, 0xCu);
    }

    uint64_t v7 = *(void *)(a1[5] + 8);
    id v8 = v5;
    id v9 = *(NSObject **)(v7 + 40);
    *(void *)(v7 + 40) = v8;
  }
  else
  {
    if ([a2 containsObject:a1[4]]) {
      *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = 1;
    }
    id v9 = sub_10000B070("octagon-metrics");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = (void *)a1[4];
      int v11 = *(unsigned __int8 *)(*(void *)(a1[6] + 8) + 24);
      int v12 = 138412546;
      id v13 = v10;
      __int16 v14 = 1024;
      int v15 = v11;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "MID (%@) on list: %{BOOL}d", (uint8_t *)&v12, 0x12u);
    }
  }
}

void sub_1000DC14C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id location)
{
  objc_destroyWeak(v23);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000DC17C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = (char *)objc_loadWeakRetained((id *)(a1 + 40));
  *(_WORD *)(WeakRetained + 57) = 0;
  WeakRetained[59] = 0;
  if (v3)
  {
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  else
  {
    id v5 = sub_10000B070("octagon-health");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v7 = *((void *)WeakRetained + 8);
      int v8 = 138412290;
      uint64_t v9 = v7;
      _os_log_debug_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEBUG, "results=%@", (uint8_t *)&v8, 0xCu);
    }

    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
    id v6 = (void *)*((void *)WeakRetained + 8);
    *((void *)WeakRetained + _Block_object_dispose(&STACK[0x3F0], 8) = 0;
  }
}

uint64_t sub_1000DD4EC(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000DD67C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    uint64_t v7 = sub_10000B070("SecError");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v15 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "octagon-tlk-recoverability: failed assessing tlk recoverability using the octagon identity, error: %@", buf, 0xCu);
    }
LABEL_4:

    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
    goto LABEL_13;
  }
  if (v5 && [v5 count])
  {
    uint64_t v7 = sub_10000B070("octagon-tlk-recoverability");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v15 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "found views using octagon peer matching record! views: %@", buf, 0xCu);
    }
    goto LABEL_4;
  }
  int v8 = sub_10000B070("SecError");
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon-tlk-recoverability: failed to find views", buf, 2u);
  }

  uint64_t v9 = *(void *)(a1 + 32);
  NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
  CFStringRef v13 = @"Record cannot recover any views";
  uint64_t v10 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
  int v11 = +[NSError errorWithDomain:@"com.apple.security.octagon" code:58 userInfo:v10];
  (*(void (**)(uint64_t, void, void *))(v9 + 16))(v9, 0, v11);

LABEL_13:
}

void sub_1000DD990(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (v9)
  {
    uint64_t v10 = sub_10000B070("SecError");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v29 = v9;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "octagon-tlk-recoverability: fetching bottles failed: %@", buf, 0xCu);
    }

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  else
  {
    id v11 = [objc_alloc((Class)OTEscrowRecord) initWithData:*(void *)(a1 + 32)];
    NSErrorUserInfoKey v12 = [v11 escrowInformationMetadata];
    CFStringRef v13 = [v12 bottleId];

    if (([v7 containsObject:v13] & 1) != 0
      || ([v8 containsObject:v13] & 1) != 0)
    {
      __int16 v14 = *(void **)(a1 + 40);
      id v15 = [v11 escrowInformationMetadata];
      unsigned __int8 v16 = [v15 bottleId];
      v22[0] = _NSConcreteStackBlock;
      v22[1] = 3221225472;
      v22[2] = sub_1000DDC78;
      v22[3] = &unk_1002F9E50;
      id v23 = v11;
      id v17 = *(id *)(a1 + 48);
      uint64_t v24 = *(void *)(a1 + 40);
      id v25 = v17;
      [v14 octagonPeerIDGivenBottleID:v16 reply:v22];

      id v18 = v23;
    }
    else
    {
      id v19 = sub_10000B070("octagon-tlk-recoverability");
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "record's bottleID is not valid in cuttlefish", buf, 2u);
      }

      uint64_t v20 = *(void *)(a1 + 48);
      NSErrorUserInfoKey v26 = NSLocalizedDescriptionKey;
      CFStringRef v27 = @"Record's bottleID is not valid in cuttlefish";
      id v18 = +[NSDictionary dictionaryWithObjects:&v27 forKeys:&v26 count:1];
      id v21 = +[NSError errorWithDomain:@"com.apple.security.octagon" code:58 userInfo:v18];
      (*(void (**)(uint64_t, void, void *))(v20 + 16))(v20, 0, v21);
    }
  }
}

void sub_1000DDC78(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v5)
  {
    id v7 = [*(id *)(a1 + 40) ckks];
    id v13 = 0;
    id v8 = [v7 viewsForPeerID:v5 error:&v13];
    id v9 = v13;

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  else
  {
    uint64_t v10 = sub_10000B070("octagon-tlk-recoverability");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = *(void *)(a1 + 32);
      *(_DWORD *)long long buf = 138412546;
      uint64_t v15 = v11;
      __int16 v16 = 2112;
      id v17 = v6;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Octagon peerID not trusted for record %@: %@", buf, 0x16u);
    }

    uint64_t v12 = *(void *)(a1 + 48);
    id v8 = +[NSError errorWithDomain:@"com.apple.security.octagon" code:58 description:@"Octagon peerID not trusted for record" underlying:v6];
    (*(void (**)(uint64_t, void, void *))(v12 + 16))(v12, 0, v8);
  }
}

void sub_1000DDFA8(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (v4)
  {
    id v5 = sub_10000B070("octagon");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 138412290;
      id v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Unable to find bottleID: %@", (uint8_t *)&v7, 0xCu);
    }

    id v6 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
  }
  else
  {
    id v6 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
  }
  v6();
}

void sub_1000DE39C(id *a1)
{
  uint64_t v2 = [a1[4] error];

  if (!v2)
  {
    id v5 = sub_10000B070("octagon-ckks");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Done waiting for CKKS Priority view download", buf, 2u);
    }
    goto LABEL_16;
  }
  id v3 = sub_10000B070("SecError");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    id v4 = [a1[4] error];
    *(_DWORD *)long long buf = 138412290;
    id v29 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "octagon-ckks: Done waiting for CKKS Priority view download with error: %@", buf, 0xCu);
  }
  id v5 = [a1[4] error];
  id v6 = [v5 domain];
  if (([v6 isEqualToString:@"CKKSErrorDomain"] & 1) == 0)
  {

LABEL_16:
    goto LABEL_17;
  }
  int v7 = [a1[4] error];
  id v8 = [v7 code];

  if (v8 != (id)52)
  {
LABEL_17:
    id v19 = (void (**)(id, id))a1[6];
    id v12 = [a1[4] error];
    v19[2](v19, v12);
    goto LABEL_18;
  }
  id v9 = sub_10000B070("SecError");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "octagon-ckks: Retrying wait for CKKS Priority view download", buf, 2u);
  }

  id v10 = a1[5];
  id v27 = 0;
  unsigned __int8 v11 = [v10 recheckCKKSTrustStatus:&v27];
  id v12 = v27;
  if ((v11 & 1) == 0)
  {
    id v13 = sub_10000B070("SecError");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v29 = v12;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "octagon-ckks: Unable to retry CKKS Priority view download: %@", buf, 0xCu);
    }
  }
  __int16 v14 = [a1[5] ckks];
  uint64_t v15 = [v14 rpcWaitForPriorityViewProcessing];

  uint64_t v20 = _NSConcreteStackBlock;
  uint64_t v21 = 3221225472;
  long long v22 = sub_1000DE718;
  id v23 = &unk_100305810;
  id v24 = v15;
  id v25 = a1[4];
  id v26 = a1[6];
  id v16 = v15;
  id v17 = +[CKKSResultOperation named:@"wait-for-sync-reply" withBlock:&v20];
  [v17 addDependency:v16, v20, v21, v22, v23];
  id v18 = [a1[5] operationQueue];
  [v18 addOperation:v17];

LABEL_18:
}

void sub_1000DE718(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) error];

  if (v2)
  {
    id v3 = sub_10000B070("SecError");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      id v4 = [*(id *)(a1 + 40) error];
      int v7 = 138412290;
      id v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "octagon-ckks: Done waiting for CKKS Priority view download retry with error: %@", (uint8_t *)&v7, 0xCu);
    }
  }
  else
  {
    id v3 = sub_10000B070("octagon-ckks");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v7) = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Done waiting for CKKS Priority view download retry", (uint8_t *)&v7, 2u);
    }
  }

  uint64_t v5 = *(void *)(a1 + 48);
  id v6 = [*(id *)(a1 + 32) error];
  (*(void (**)(uint64_t, void *))(v5 + 16))(v5, v6);
}

void sub_1000DEAB0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    int v7 = sub_10000B070("SecError");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      id v9 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "octagon-settings: Failed fetching account settings: %@", (uint8_t *)&v8, 0xCu);
    }
  }
  else
  {
    int v7 = sub_10000B070("octagon-settings");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      id v9 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Succeeded fetching account settings: %@", (uint8_t *)&v8, 0xCu);
    }
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000DEE34(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  int v7 = sub_10000B070("SecError");
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    if (v8)
    {
      int v9 = 138412290;
      id v10 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "octagon-settings: Failed fetching account settings: %@", (uint8_t *)&v9, 0xCu);
    }
  }
  else if (v8)
  {
    int v9 = 138412290;
    id v10 = v5;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "octagon-settings: Succeeded fetching account settings: %@", (uint8_t *)&v9, 0xCu);
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000DF244(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000DF270(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v42 = a2;
  id v7 = a3;
  id v8 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v10 = WeakRetained;
  if (v8)
  {
    unsigned __int8 v11 = sub_10000B070("octagon");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      id v12 = [v10 containerName];
      id v13 = [v10 contextID];
      *(_DWORD *)long long buf = 138412802;
      uint64_t v49 = v12;
      __int16 v50 = 2112;
      id v51 = v13;
      __int16 v52 = 2112;
      id v53 = v8;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Unable to fetch trusted peers for (%@,%@): %@", buf, 0x20u);
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    CFTypeRef v40 = WeakRetained;
    id v14 = objc_alloc_init((Class)OTCurrentSecureElementIdentities);
    uint64_t v15 = +[NSMutableArray array];
    [v14 setTrustedPeerSecureElementIdentities:v15];

    long long v45 = 0u;
    long long v46 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    id v41 = v7;
    id v16 = v7;
    id v17 = [v16 countByEnumeratingWithState:&v43 objects:v47 count:16];
    if (v17)
    {
      id v18 = v17;
      uint64_t v19 = *(void *)v44;
      do
      {
        for (uint64_t i = 0; i != v18; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v44 != v19) {
            objc_enumerationMutation(v16);
          }
          uint64_t v21 = *(void **)(*((void *)&v43 + 1) + 8 * i);
          long long v22 = [v21 secureElementIdentity];

          if (v22)
          {
            id v23 = objc_alloc_init((Class)OTSecureElementPeerIdentity);
            id v24 = [v21 secureElementIdentity];
            id v25 = [v24 peerIdentifier];
            [v23 setPeerIdentifier:v25];

            id v26 = [v21 secureElementIdentity];
            id v27 = [v26 peerData];
            [v23 setPeerData:v27];

            BOOL v28 = [v21 peerID];
            id v29 = [v42 peerID];
            unsigned int v30 = [v28 isEqualToString:v29];

            if (v30)
            {
              [v14 setLocalPeerIdentity:v23];
            }
            else
            {
              id v31 = [v14 trustedPeerSecureElementIdentities];
              [v31 addObject:v23];
            }
          }
        }
        id v18 = [v16 countByEnumeratingWithState:&v43 objects:v47 count:16];
      }
      while (v18);
    }

    id v8 = 0;
    id v10 = v40;
    if (*(void *)(a1 + 32))
    {
      id v32 = objc_alloc_init((Class)OTSecureElementPeerIdentity);
      uint64_t v33 = [*(id *)(a1 + 32) peerIdentifier];
      [v32 setPeerIdentifier:v33];

      id v34 = [*(id *)(a1 + 32) peerData];
      [v32 setPeerData:v34];

      uint64_t v35 = [v14 localPeerIdentity];
      unsigned __int8 v36 = [v35 isEqual:v32];

      if ((v36 & 1) == 0)
      {
        CFTypeRef v37 = sub_10000B070("octagon");
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v38 = [v40 containerName];
          id v39 = [v40 contextID];
          *(_DWORD *)long long buf = 138412802;
          uint64_t v49 = v38;
          __int16 v50 = 2112;
          id v51 = v39;
          __int16 v52 = 2112;
          id v53 = v32;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "Returning pending identity for (%@,%@): %@", buf, 0x20u);
        }
        [v14 setPendingLocalPeerIdentity:v32];
      }
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();

    id v7 = v41;
  }
}

OTAccountMetadataClassC *__cdecl sub_1000DF84C(id a1, OTAccountMetadataClassC *a2)
{
  uint64_t v2 = a2;
  [(OTAccountMetadataClassC *)v2 setSecureElementIdentity:0];

  return v2;
}

id sub_1000DFA7C(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 setOctagonSecureElementIdentity:*(void *)(a1 + 32)];

  return v3;
}

void sub_1000E0330(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = sub_10000B070("octagon-ckks");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v5 = @"enabled";
      if (!*(unsigned char *)(a1 + 48)) {
        CFStringRef v5 = @"disabled";
      }
      int v19 = 138412546;
      CFStringRef v20 = v5;
      __int16 v21 = 2112;
      id v22 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Failed to set sync policy to '%@': %@", (uint8_t *)&v19, 0x16u);
    }

    id v6 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
LABEL_13:
    v6();
    goto LABEL_14;
  }
  id v7 = [*(id *)(a1 + 32) ckks];
  id v8 = [v7 operationDependencies];
  int v9 = [v8 syncingPolicy];

  if (v9)
  {
    id v10 = [*(id *)(a1 + 32) ckks];
    unsigned __int8 v11 = [v10 operationDependencies];
    id v12 = [v11 syncingPolicy];
    unsigned int v13 = [v12 syncUserControllableViewsAsBoolean];

    id v14 = sub_10000B070("octagon-ckks");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v15 = @"disabled";
      if (v13) {
        CFStringRef v15 = @"enabled";
      }
      int v19 = 138412290;
      CFStringRef v20 = v15;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "User-controllable sync status is set as '%@'", (uint8_t *)&v19, 0xCu);
    }

    id v6 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
    goto LABEL_13;
  }
  id v16 = sub_10000B070("octagon-ckks");
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v19) = 0;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "Policy missing even after a refetch?", (uint8_t *)&v19, 2u);
  }

  uint64_t v17 = *(void *)(a1 + 40);
  id v18 = +[NSError errorWithDomain:@"com.apple.security.octagon" code:49 description:@"Sync policy is missing even after refetching"];
  (*(void (**)(uint64_t, void, void *))(v17 + 16))(v17, 0, v18);

LABEL_14:
}

void sub_1000E09E8(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = sub_10000B070("octagon-ckks");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      CFStringRef v21 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Failed to fetch policy: %@", buf, 0xCu);
    }

    CFStringRef v5 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
LABEL_18:
    v5();
    goto LABEL_19;
  }
  id v6 = [*(id *)(a1 + 32) ckks];
  id v7 = [v6 syncingPolicy];

  if (v7)
  {
    id v8 = [*(id *)(a1 + 32) ckks];
    int v9 = [v8 syncingPolicy];
    unsigned int v10 = [v9 syncUserControllableViewsAsBoolean];

    unsigned __int8 v11 = sub_10000B070("octagon-ckks");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      if (v10) {
        CFStringRef v12 = @"enabled";
      }
      else {
        CFStringRef v12 = @"disabled";
      }
      unsigned int v13 = [*(id *)(a1 + 32) ckks];
      id v14 = [v13 syncingPolicy];
      id v15 = [v14 syncUserControllableViews];
      if (v15 >= 4)
      {
        id v16 = +[NSString stringWithFormat:@"(unknown: %i)", v15];
      }
      else
      {
        id v16 = off_1002F9F78[v15];
      }
      *(_DWORD *)long long buf = 138412546;
      CFStringRef v21 = v12;
      __int16 v22 = 2112;
      id v23 = v16;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Returning user-controllable status as %@ (%@)", buf, 0x16u);
    }
    CFStringRef v5 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
    goto LABEL_18;
  }
  uint64_t v17 = sub_10000B070("octagon-ckks");
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "Policy missing even after a refetch?", buf, 2u);
  }

  uint64_t v18 = *(void *)(a1 + 40);
  int v19 = +[NSError errorWithDomain:@"com.apple.security.octagon" code:49 description:@"Sync policy is missing even after refetching"];
  (*(void (**)(uint64_t, void, void *))(v18 + 16))(v18, 0, v19);

LABEL_19:
}

void sub_1000E0FDC(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  if (v12)
  {
    unsigned int v13 = sub_10000B070("SecError");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = 138412290;
      id v15 = v12;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "octagon: error fetching escrow contents: %@", (uint8_t *)&v14, 0xCu);
    }
  }
  else
  {
    unsigned int v13 = sub_10000B070("octagon");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = 138412290;
      id v15 = v10;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "fetched escrow contents for bottle: %@", (uint8_t *)&v14, 0xCu);
    }
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000E12F0(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = sub_10000B070("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 138412290;
      id v6 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "octagon: failed to remove escrow cache: %@", (uint8_t *)&v5, 0xCu);
    }
  }
  else
  {
    id v4 = sub_10000B070("octagon");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v5) = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "successfully removed escrow cache", (uint8_t *)&v5, 2u);
    }
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000E15B8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    id v7 = sub_10000B070("SecError");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      id v9 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "octagon: error fetching all viable escrow records: %@", (uint8_t *)&v8, 0xCu);
    }
  }
  else
  {
    id v7 = sub_10000B070("octagon");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      id v9 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "fetched escrow records: %@", (uint8_t *)&v8, 0xCu);
    }
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000E18FC(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (v9)
  {
    id v10 = sub_10000B070("SecError");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = 138412290;
      id v13 = v9;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "octagon: error fetching all viable bottles: %@", (uint8_t *)&v12, 0xCu);
    }
  }
  else
  {
    id v11 = sub_10000B070("octagon");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = 138412290;
      id v13 = v7;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "fetched viable bottles: %@", (uint8_t *)&v12, 0xCu);
    }

    id v10 = sub_10000B070("octagon");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = 138412290;
      id v13 = v8;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "fetched partially viable bottles: %@", (uint8_t *)&v12, 0xCu);
    }
  }

  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000E20E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  _Block_object_dispose(&a22, 8);
  _Block_object_dispose(&a26, 8);
  _Block_object_dispose(&a30, 8);
  _Block_object_dispose(&a34, 8);
  _Block_object_dispose((const void *)(v34 - 144), 8);
  _Block_object_dispose((const void *)(v34 - 192), 8);
  _Unwind_Resume(a1);
}

void sub_1000E2150(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  unsigned __int8 v7 = [v5 egoStatus];
  uint64_t v8 = [v5 egoPeerID];
  uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 8);
  id v10 = *(void **)(v9 + 40);
  *(void *)(v9 + 40) = v8;

  *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = [v5 isExcluded];
  uint64_t v11 = [v5 viablePeerCountsByModelID];
  uint64_t v12 = *(void *)(*(void *)(a1 + 64) + 8);
  id v13 = *(void **)(v12 + 40);
  *(void *)(v12 + 40) = v11;

  *(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) = [v5 isLocked];
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 80) + 8) + 40), a3);
  int v14 = sub_10000B070("octagon");
  BOOL v15 = os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    if (v15)
    {
      *(_DWORD *)long long buf = 138412290;
      id v27 = v6;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "error fetching trust status: %@", buf, 0xCu);
    }
    goto LABEL_26;
  }
  if (v15)
  {
    id v16 = TPPeerStatusToString();
    *(_DWORD *)long long buf = 138412290;
    id v27 = v16;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "trust status: %@", buf, 0xCu);
  }
  [*(id *)(a1 + 32) popTooManyPeersDialogWithEgoPeerStatus:v5 accountMeta:*(void *)(a1 + 40)];
  if ((v7 & 4) != 0)
  {
LABEL_15:
    uint64_t v17 = 1;
    goto LABEL_16;
  }
  if ((v7 & 0x5B) == 0)
  {
    if ((v7 & 0x80) == 0)
    {
      if ((v7 & 0x20) == 0)
      {
        uint64_t v18 = sub_10000B070("octagon");
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "TPPeerStatus is empty", buf, 2u);
        }
      }
      uint64_t v17 = 3;
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  uint64_t v17 = 0;
LABEL_16:
  *(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 24) = v17;
  uint64_t v19 = *(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 24);
  if (v19) {
    uint64_t v20 = v19 == 1;
  }
  else {
    uint64_t v20 = 2;
  }
  CFStringRef v21 = [*(id *)(a1 + 32) accountMetadataStore];
  id v25 = 0;
  unsigned int v22 = [v21 persistNewTrustState:v20 error:&v25];
  int v14 = v25;

  if (!v22 || v14)
  {
    id v23 = sub_10000B070("SecError");
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v27 = v14;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "octagon: unable to persist clique trust state: %@", buf, 0xCu);
    }
  }
  else
  {
    id v23 = sub_10000B070("octagon");
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      id v24 = off_1002F9F60[v20];
      *(_DWORD *)long long buf = 138412290;
      id v27 = v24;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "updated account trust state: %@", buf, 0xCu);
    }
  }

LABEL_26:
}

void sub_1000E2868(uint64_t a1)
{
  uint64_t v2 = sub_10000B070("otrpc");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(a1 + 32) error];
    int v7 = 138412290;
    uint64_t v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Returning an inheritance key call: %@", (uint8_t *)&v7, 0xCu);
  }
  uint64_t v4 = *(void *)(a1 + 40);
  id v5 = [*(id *)(a1 + 32) ik];
  id v6 = [*(id *)(a1 + 32) error];
  (*(void (**)(uint64_t, void *, void *))(v4 + 16))(v4, v5, v6);
}

void sub_1000E2BA8(uint64_t a1)
{
  uint64_t v2 = sub_10000B070("otrpc");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(a1 + 32) error];
    int v7 = 138412290;
    uint64_t v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Returning an inheritance key call: %@", (uint8_t *)&v7, 0xCu);
  }
  uint64_t v4 = *(void *)(a1 + 40);
  id v5 = [*(id *)(a1 + 32) ik];
  id v6 = [*(id *)(a1 + 32) error];
  (*(void (**)(uint64_t, void *, void *))(v4 + 16))(v4, v5, v6);
}

void sub_1000E2E14(uint64_t a1)
{
  id v3 = sub_10000B070("otrpc");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = [*(id *)(a1 + 32) crk];
    uint64_t v1 = [*(id *)(a1 + 32) error];
    int v9 = 138412546;
    id v10 = v4;
    __int16 v11 = 2112;
    uint64_t v12 = v1;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Returning a check inheritance key call: %@, %@", (uint8_t *)&v9, 0x16u);
  }
  uint64_t v5 = *(void *)(a1 + 40);
  id v6 = [*(id *)(a1 + 32) crk];
  if (v6)
  {
    uint64_t v1 = [*(id *)(a1 + 32) crk];
    BOOL v7 = [v1 kind] == 2;
  }
  else
  {
    BOOL v7 = 0;
  }
  uint64_t v8 = [*(id *)(a1 + 32) error];
  (*(void (**)(uint64_t, BOOL, void *))(v5 + 16))(v5, v7, v8);

  if (v6) {
}
  }

void sub_1000E30D8(uint64_t a1)
{
  uint64_t v2 = sub_10000B070("otrpc");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(a1 + 32) error];
    int v6 = 138412290;
    BOOL v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Returning remove inheritance key call: %@", (uint8_t *)&v6, 0xCu);
  }
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = [*(id *)(a1 + 32) error];
  (*(void (**)(uint64_t, void *))(v4 + 16))(v4, v5);
}

void sub_1000E332C(uint64_t a1)
{
  uint64_t v2 = sub_10000B070("otrpc");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(a1 + 32) error];
    int v6 = 138412290;
    BOOL v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Returning an inheritance key call: %@", (uint8_t *)&v6, 0xCu);
  }
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = [*(id *)(a1 + 32) error];
  (*(void (**)(uint64_t, void *))(v4 + 16))(v4, v5);
}

void sub_1000E36D0(uint64_t a1)
{
  uint64_t v2 = sub_10000B070("otrpc");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(a1 + 32) error];
    int v7 = 138412290;
    uint64_t v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Returning an inheritance key call: %@", (uint8_t *)&v7, 0xCu);
  }
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = [*(id *)(a1 + 32) ik];
  int v6 = [*(id *)(a1 + 32) error];
  (*(void (**)(uint64_t, void *, void *))(v4 + 16))(v4, v5, v6);
}

void sub_1000E393C(uint64_t a1)
{
  id v3 = sub_10000B070("otrpc");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = [*(id *)(a1 + 32) crk];
    uint64_t v1 = [*(id *)(a1 + 32) error];
    int v9 = 138412546;
    id v10 = v4;
    __int16 v11 = 2112;
    uint64_t v12 = v1;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Returning a check custodian recovery key call: %@, %@", (uint8_t *)&v9, 0x16u);
  }
  uint64_t v5 = *(void *)(a1 + 40);
  int v6 = [*(id *)(a1 + 32) crk];
  if (v6)
  {
    uint64_t v1 = [*(id *)(a1 + 32) crk];
    BOOL v7 = [v1 kind] == 1;
  }
  else
  {
    BOOL v7 = 0;
  }
  uint64_t v8 = [*(id *)(a1 + 32) error];
  (*(void (**)(uint64_t, BOOL, void *))(v5 + 16))(v5, v7, v8);

  if (v6) {
}
  }

void sub_1000E3C00(uint64_t a1)
{
  uint64_t v2 = sub_10000B070("otrpc");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(a1 + 32) error];
    int v6 = 138412290;
    BOOL v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Returning a remove custodian recovery key call: %@", (uint8_t *)&v6, 0xCu);
  }
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = [*(id *)(a1 + 32) error];
  (*(void (**)(uint64_t, void *))(v4 + 16))(v4, v5);
}

void sub_1000E3E54(uint64_t a1)
{
  uint64_t v2 = sub_10000B070("otrpc");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(a1 + 32) error];
    int v7 = 138412290;
    uint64_t v8 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Returning a create custodian recovery key call: %@", (uint8_t *)&v7, 0xCu);
  }
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = [*(id *)(a1 + 32) crk];
  int v6 = [*(id *)(a1 + 32) error];
  (*(void (**)(uint64_t, void *, void *))(v4 + 16))(v4, v5, v6);
}

uint64_t sub_1000E40E0(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1000E4274(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_1000E4408(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_1000E45A8(uint64_t a1)
{
  uint64_t v2 = sub_10000B070("otrpc");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(a1 + 32) error];
    int v6 = 138412290;
    int v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Returning a set recovery key call: %@", (uint8_t *)&v6, 0xCu);
  }
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = [*(id *)(a1 + 32) error];
  (*(void (**)(uint64_t, void *))(v4 + 16))(v4, v5);
}

void sub_1000E481C(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (v4)
  {
    uint64_t v5 = sub_10000B070("octagon");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 138412290;
      id v8 = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Unable to fetch names by peerID: %@", (uint8_t *)&v7, 0xCu);
    }

    int v6 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
  }
  else
  {
    int v6 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
  }
  v6();
}

void sub_1000E527C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000E52B8(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  int v7 = sub_10000B070("octagon");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)int v9 = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Finished dump for status RPC", v9, 2u);
  }

  if (v6)
  {
    id v8 = +[SecXPCHelper cleanseErrorForXPC:v6];
    [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) setObject:v8 forKeyedSubscript:@"contextDumpError"];
  }
  else
  {
    [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) setObject:v5 forKeyedSubscript:@"contextDump"];
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

id sub_1000E5C8C(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 setVoucher:*(void *)(a1 + 32)];
  [v3 setVoucherSignature:*(void *)(a1 + 40)];

  return v3;
}

void sub_1000E5CDC(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    id v4 = sub_10000B070("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 138412290;
      id v7 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "octagon failed to join: %@", (uint8_t *)&v6, 0xCu);
    }
  }
  else
  {
    id v4 = [*(id *)(a1 + 32) ckks];
    id v5 = [v4 rpcFetchBecause:@"octagon-pairing-complete"];
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_1000E64A0(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  if (v5)
  {
    int v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 138412290;
      CFStringRef v11 = v5;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "octagon-preflight-rk: error checking recovery key correctness: %@", (uint8_t *)&v10, 0xCu);
    }

    id v7 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
  }
  else
  {
    id v8 = sub_10000B070("octagon-preflight-rk");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v9 = @"incorrect";
      if (a2) {
        CFStringRef v9 = @"correct";
      }
      int v10 = 138412290;
      CFStringRef v11 = v9;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "recovery key is %@", (uint8_t *)&v10, 0xCu);
    }

    id v7 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
  }
  v7();
}

void sub_1000E75B0(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (!v4)
  {
    id v3 = [*(id *)(a1 + 32) notifierClass];
    [v3 post:OTJoinedViaBottle];
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_1000E7AA4(uint64_t a1)
{
  uint64_t v2 = sub_10000B070("otrpc");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(a1 + 32) peerID];
    id v4 = [*(id *)(a1 + 32) error];
    int v12 = 138412546;
    id v13 = v3;
    __int16 v14 = 2112;
    BOOL v15 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Returning a prepare call: %@  %@", (uint8_t *)&v12, 0x16u);
  }
  uint64_t v5 = *(void *)(a1 + 40);
  int v6 = [*(id *)(a1 + 32) peerID];
  id v7 = [*(id *)(a1 + 32) permanentInfo];
  id v8 = [*(id *)(a1 + 32) permanentInfoSig];
  CFStringRef v9 = [*(id *)(a1 + 32) stableInfo];
  int v10 = [*(id *)(a1 + 32) stableInfoSig];
  CFStringRef v11 = [*(id *)(a1 + 32) error];
  (*(void (**)(uint64_t, void *, void *, void *, void *, void *, void *))(v5 + 16))(v5, v6, v7, v8, v9, v10, v11);
}

void sub_1000E8174(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 128));
  _Unwind_Resume(a1);
}

void sub_1000E819C(uint64_t a1)
{
  uint64_t v2 = sub_10000B070("otrpc");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = [*(id *)(a1 + 32) voucher];
    id v4 = [*(id *)(a1 + 32) voucherSig];
    uint64_t v5 = [*(id *)(a1 + 32) error];
    int v10 = 138412802;
    CFStringRef v11 = v3;
    __int16 v12 = 2112;
    id v13 = v4;
    __int16 v14 = 2112;
    BOOL v15 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Returning a voucher call: %@, %@, %@", (uint8_t *)&v10, 0x20u);
  }
  uint64_t v6 = *(void *)(a1 + 40);
  id v7 = [*(id *)(a1 + 32) voucher];
  id v8 = [*(id *)(a1 + 32) voucherSig];
  CFStringRef v9 = [*(id *)(a1 + 32) error];
  (*(void (**)(uint64_t, void *, void *, void *))(v6 + 16))(v6, v7, v8, v9);
}

void sub_1000E8300(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 64));
  id v3 = sub_10000B070("otrpc");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    id v4 = [*(id *)(a1 + 32) error];
    int v9 = 138412290;
    int v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Returning a updateTDL: %@", (uint8_t *)&v9, 0xCu);
  }
  uint64_t v5 = [*(id *)(a1 + 32) error];

  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 56);
    id v7 = [*(id *)(a1 + 32) error];
    (*(void (**)(uint64_t, void, void, void *))(v6 + 16))(v6, 0, 0, v7);
  }
  else
  {
    id v8 = [WeakRetained operationQueue];
    [v8 addOperation:*(void *)(a1 + 40)];

    id v7 = [WeakRetained stateMachine];
    [v7 handleExternalRequest:*(void *)(a1 + 48) startTimeout:120000000000];
  }
}

void sub_1000E864C(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (v5)
  {
    uint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 138412290;
      id v11 = v5;
      id v7 = "rpc-epoch: failed to fetch epoch! error: %@";
      id v8 = v6;
      uint32_t v9 = 12;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v10, v9);
    }
  }
  else
  {
    uint64_t v6 = sub_10000B070("rpc-epoch");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v10) = 0;
      id v7 = "fetched epoch";
      id v8 = v6;
      uint32_t v9 = 2;
      goto LABEL_6;
    }
  }

  (*(void (**)(void, uint64_t))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), a2);
}

void sub_1000E8BDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_1000E8C10(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) cloudKitAccountInfo];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v2 != 0;

  id v3 = [*(id *)(a1 + 32) cloudKitAccountInfo];
  if (v3)
  {
    id v5 = v3;
    id v4 = [*(id *)(a1 + 32) cloudKitAccountInfo];
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = [v4 accountStatus] == (id)1;

    id v3 = v5;
  }
  else
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
  }
}

void sub_1000E8CC0(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) cloudKitAccountInfo];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v2 != 0;

  id v3 = [*(id *)(a1 + 32) cloudKitAccountInfo];
  if (v3)
  {
    id v5 = v3;
    id v4 = [*(id *)(a1 + 32) cloudKitAccountInfo];
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = [v4 accountStatus] == (id)1;

    id v3 = v5;
  }
  else
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
  }
}

void sub_1000E9018(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000E9034(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v1 = [WeakRetained stateMachine];
  [v1 handleFlag:@"attempt_sos_consistency"];
}

OTAccountMetadataClassC *__cdecl sub_1000E9988(id a1, OTAccountMetadataClassC *a2)
{
  uint64_t v2 = a2;
  [(OTAccountMetadataClassC *)v2 setWarnedTooManyPeers:1];

  return v2;
}

void sub_1000E9F80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v13 - 144), 8);
  _Unwind_Resume(a1);
}

void sub_1000E9FD0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = sub_10000B070("octagon-count-trusted-peers");
  BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
  if (v6)
  {
    if (v8)
    {
      int v14 = 138412290;
      id v15 = v6;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "totalTrustedPeers errored: %@", (uint8_t *)&v14, 0xCu);
    }

    uint64_t v9 = a1 + 32;
    int v10 = v6;
  }
  else
  {
    if (v8)
    {
      int v14 = 138412290;
      id v15 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "totalTrustedPeers succeeded, total count: %@", (uint8_t *)&v14, 0xCu);
    }

    uint64_t v9 = a1 + 40;
    int v10 = v5;
  }
  uint64_t v11 = *(void *)(*(void *)v9 + 8);
  id v12 = v10;
  uint64_t v13 = *(void **)(v11 + 40);
  *(void *)(v11 + 40) = v12;
}

void sub_1000EA10C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    uint64_t v2 = sub_10000B070("octagon-push-ratelimited");
    if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
    {
      id v3 = [WeakRetained contextID];
      int v6 = 138412290;
      id v7 = v3;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "notifying container of change for context: %@", (uint8_t *)&v6, 0xCu);
    }
    id v4 = [[OctagonPendingFlag alloc] initWithFlag:@"recd_push" conditions:1];
    id v5 = [WeakRetained stateMachine];
    [v5 handlePendingFlag:v4];
  }
}

void sub_1000EA774(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 24));
  _Unwind_Resume(a1);
}

void sub_1000EA790(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v5 = [WeakRetained contextID];
  unsigned int v6 = [v5 isEqualToString:@"defaultContext"];

  if (v6)
  {
    id v7 = [WeakRetained accountStateTracker];
    [v7 triggerOctagonStatusFetch];
  }
  uint64_t v64 = 0;
  id v65 = &v64;
  uint64_t v66 = 0x3032000000;
  CFTypeRef v67 = sub_1000DAD14;
  id v68 = sub_1000DAD24;
  id v69 = 0;
  uint64_t v58 = 0;
  long long v59 = &v58;
  uint64_t v60 = 0x3032000000;
  id v61 = sub_1000DAD14;
  id v62 = sub_1000DAD24;
  id v63 = 0;
  BOOL v8 = [WeakRetained accountMetadataStore];
  id v56 = 0;
  v57[0] = _NSConcreteStackBlock;
  v57[1] = 3221225472;
  v57[2] = sub_1000EB0AC;
  v57[3] = &unk_1002F9C30;
  void v57[4] = &v64;
  v57[5] = &v58;
  [v8 persistAccountChanges:v57 error:&v56];
  id v9 = v56;

  if (!v65[5] || v9)
  {
    id v16 = sub_10000B070("SecError");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "octagon-ckks: No peer ID to pass to CKKS. Syncing will be disabled.", buf, 2u);
    }
    goto LABEL_41;
  }
  int v10 = (void *)v59[5];
  if (v10)
  {
    if ([v10 syncUserControllableViews])
    {
      uint64_t v11 = [WeakRetained sosAdapter];
      unsigned int v12 = [v11 sosEnabled];

      if (!v12)
      {
LABEL_21:
        uint64_t v19 = sub_10000B070("octagon-ckks");
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v20 = v59[5];
          CFStringRef v21 = [v20 viewList];
          *(_DWORD *)long long buf = 138412546;
          id v73 = v20;
          __int16 v74 = 2112;
          id v75 = v21;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Initializing CKKS views with policy %@: %@", buf, 0x16u);
        }
        unsigned int v22 = [WeakRetained ckks];
        [v22 setCurrentSyncingPolicy:v59[5]];

        id v23 = [OctagonCKKSPeerAdapter alloc];
        uint64_t v24 = v65[5];
        id v25 = [WeakRetained activeAccount];
        id v26 = [WeakRetained personaAdapter];
        id v27 = [WeakRetained cuttlefishXPCWrapper];
        id v16 = [(OctagonCKKSPeerAdapter *)v23 initWithPeerID:v24 specificUser:v25 personaAdapter:v26 cuttlefishXPC:v27];

        id v54 = 0;
        BOOL v28 = [v16 fetchSelfPeers:&v54];
        id v29 = v54;
        unsigned int v30 = v29;
        if (!v28 || v29)
        {
          id v39 = sub_10000B070("SecError");
          if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138412546;
            id v73 = v16;
            __int16 v74 = 2112;
            id v75 = v30;
            _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "octagon-ckks: Unable to fetch self peers for %@: %@", buf, 0x16u);
          }

          CFTypeRef v40 = [WeakRetained lockStateTracker];
          unsigned int v41 = [v40 isLockedError:v30];

          id v42 = sub_10000B070("octagon-ckks");
          BOOL v43 = os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT);
          if (v41)
          {
            if (v43)
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "Waiting for device unlock to proceed", buf, 2u);
            }
            long long v44 = &off_1003052F0;
          }
          else
          {
            if (v43)
            {
              *(_WORD *)long long buf = 0;
              _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "Error is scary; becoming untrusted",
                buf,
                2u);
            }
            long long v44 = &off_100305548;
          }

          [v3 setNextState:*v44];
          goto LABEL_51;
        }
        [WeakRetained setOctagonAdapter:v16];
        id v31 = sub_10000B070("octagon-ckks");
        if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
        {
          id v32 = [WeakRetained ckks];
          uint64_t v33 = v65[5];
          *(_DWORD *)long long buf = 138412546;
          id v73 = v32;
          __int16 v74 = 2112;
          id v75 = v33;
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Informing CKKS %@ of trusted operation with self peer %@", buf, 0x16u);
        }
        uint64_t v34 = [WeakRetained sosAdapter];
        unsigned int v35 = [v34 sosEnabled];

        [WeakRetained octagonAdapter];
        if (v35) {
          unsigned __int8 v36 = {;
        }
          v71[0] = v36;
          CFTypeRef v37 = [WeakRetained sosAdapter];
          v71[1] = v37;
          uint64_t v38 = +[NSArray arrayWithObjects:v71 count:2];
        }
        else {
          unsigned __int8 v36 = {;
        }
          uint64_t v70 = v36;
          uint64_t v38 = +[NSArray arrayWithObjects:&v70 count:1];
        }

        long long v45 = [WeakRetained ckks];
        long long v46 = [WeakRetained suggestTLKUploadNotifier];
        uint64_t v47 = [WeakRetained requestPolicyCheckNotifier];
        [v45 beginTrustedOperation:v38 suggestTLKUpload:v46 requestPolicyCheck:v47];

LABEL_41:
        unint64_t v48 = [v3 intendedState];
        [v3 setNextState:v48];

        [WeakRetained setShouldSendMetricsForOctagon:2];
        id v53 = 0;
        unsigned int v49 = [WeakRetained fetchSendingMetricsPermitted:&v53];
        __int16 v50 = v53;
        if (v50) {
          unsigned int v51 = 0;
        }
        else {
          unsigned int v51 = v49;
        }
        if (v51 == 1)
        {
          __int16 v52 = sub_10000B070("octagon-metrics");
          if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "triggered metrics check", buf, 2u);
          }

          unsigned int v30 = [WeakRetained checkMetricsTrigger];
          [v30 trigger];
          id v16 = 0;
        }
        else
        {
          id v16 = v50;
          if (!v50)
          {
LABEL_52:

            goto LABEL_53;
          }
          unsigned int v30 = sub_10000B070("SecError");
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138412290;
            id v73 = v16;
            _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "octagon-metrics, failed to fetch metrics setting: %@", buf, 0xCu);
          }
        }
LABEL_51:

        goto LABEL_52;
      }
      uint64_t v13 = [WeakRetained sosAdapter];
      id v55 = 0;
      [v13 updateCKKS4AllStatus:1 error:&v55];
      int v14 = v55;

      if (v14)
      {
        id v15 = sub_10000B070("octagon-ckks");
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          id v73 = v14;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Unable to enable the CKKS4All status in SOS: %@", buf, 0xCu);
        }
      }
    }
    else
    {
      uint64_t v18 = sub_10000B070("octagon-ckks");
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Memoized CKKS policy has no opinion of user-controllable view status", buf, 2u);
      }

      int v14 = [WeakRetained upgradeUserControllableViewsRateLimiter];
      [v14 trigger];
    }

    goto LABEL_21;
  }
  uint64_t v17 = sub_10000B070("SecError");
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "octagon-ckks: No memoized CKKS policy, re-fetching", buf, 2u);
  }

  [v3 setNextState:@"RefetchCKKSPolicy"];
LABEL_53:
  _Block_object_dispose(&v58, 8);

  _Block_object_dispose(&v64, 8);
}

void sub_1000EB064(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

id sub_1000EB0AC(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [v3 peerID];
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
  unsigned int v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;

  unsigned int v7 = [v3 hasSyncingPolicy];
  if (v7)
  {
    BOOL v8 = [v3 getTPSyncingPolicy];
  }
  else
  {
    BOOL v8 = 0;
  }
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), v8);
  if (v7) {

  }
  if ([v3 attemptedJoin] == 2)
  {
    id v9 = 0;
  }
  else
  {
    [v3 setAttemptedJoin:2];
    id v9 = v3;
  }

  return v9;
}

void sub_1000EB264(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 24));
  _Unwind_Resume(a1);
}

void sub_1000EB280(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v48 = 0;
  unsigned int v49 = &v48;
  uint64_t v50 = 0x3032000000;
  unsigned int v51 = sub_1000DAD14;
  __int16 v52 = sub_1000DAD24;
  id v53 = 0;
  uint64_t v42 = 0;
  BOOL v43 = &v42;
  uint64_t v44 = 0x3032000000;
  long long v45 = sub_1000DAD14;
  long long v46 = sub_1000DAD24;
  id v47 = 0;
  uint64_t v5 = [WeakRetained accountMetadataStore];
  id v40 = 0;
  v41[0] = _NSConcreteStackBlock;
  v41[1] = 3221225472;
  v41[2] = sub_1000EB96C;
  v41[3] = &unk_1002F9C30;
  v41[4] = &v48;
  v41[5] = &v42;
  [v5 persistAccountChanges:v41 error:&v40];
  id v6 = v40;

  if (!v49[5] || v6)
  {
    id v16 = sub_10000B070("SecError");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "octagon-ckks: No peer ID to pass to CKKS. Syncing will be disabled.", buf, 2u);
    }
    goto LABEL_29;
  }
  if (v43[5])
  {
    unsigned int v7 = sub_10000B070("octagon-ckks");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v8 = v43[5];
      id v9 = [v8 viewList];
      *(_DWORD *)long long buf = 138412546;
      long long v57 = v8;
      __int16 v58 = 2112;
      long long v59 = v9;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Initializing CKKS views with policy %@: %@", buf, 0x16u);
    }
    int v10 = [WeakRetained ckks];
    [v10 setCurrentSyncingPolicy:v43[5]];

    uint64_t v11 = [OctagonCKKSPeerAdapter alloc];
    uint64_t v12 = v49[5];
    uint64_t v13 = [WeakRetained activeAccount];
    int v14 = [WeakRetained personaAdapter];
    id v15 = [WeakRetained cuttlefishXPCWrapper];
    id v16 = [(OctagonCKKSPeerAdapter *)v11 initWithPeerID:v12 specificUser:v13 personaAdapter:v14 cuttlefishXPC:v15];

    id v39 = 0;
    uint64_t v17 = [v16 fetchSelfPeers:&v39];
    id v18 = v39;
    uint64_t v19 = v18;
    if (v17 && !v18)
    {
      [WeakRetained setOctagonAdapter:v16];
      uint64_t v20 = sub_10000B070("octagon-ckks");
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v21 = [WeakRetained ckks];
        unsigned int v22 = (void *)v49[5];
        *(_DWORD *)long long buf = 138412546;
        long long v57 = v21;
        __int16 v58 = 2112;
        long long v59 = v22;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Informing CKKS %@ of trusted operation with self peer %@", buf, 0x16u);
      }
      id v23 = [WeakRetained sosAdapter];
      unsigned int v24 = [v23 sosEnabled];

      [WeakRetained octagonAdapter];
      if (v24) {
        id v25 = {;
      }
        v55[0] = v25;
        id v26 = [WeakRetained sosAdapter];
        v55[1] = v26;
        id v27 = +[NSArray arrayWithObjects:v55 count:2];
      }
      else {
        id v25 = {;
      }
        id v54 = v25;
        id v27 = +[NSArray arrayWithObjects:&v54 count:1];
      }

      [WeakRetained setSuggestTLKUploadNotifier:0];
      [WeakRetained setRequestPolicyCheckNotifier:0];
      unsigned int v35 = [WeakRetained ckks];
      unsigned __int8 v36 = [WeakRetained suggestTLKUploadNotifier];
      CFTypeRef v37 = [WeakRetained requestPolicyCheckNotifier];
      [v35 beginTrustedOperation:v27 suggestTLKUpload:v36 requestPolicyCheck:v37];

LABEL_29:
      [WeakRetained notifyTrustChanged:2];
      uint64_t v38 = [v3 intendedState];
      [v3 setNextState:v38];

      [WeakRetained setShouldSendMetricsForOctagon:2];
      goto LABEL_30;
    }
    id v29 = sub_10000B070("SecError");
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412546;
      long long v57 = v16;
      __int16 v58 = 2112;
      long long v59 = v19;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "octagon-ckks: Unable to fetch self peers for %@: %@", buf, 0x16u);
    }

    unsigned int v30 = [WeakRetained lockStateTracker];
    unsigned int v31 = [v30 isLockedError:v19];

    id v32 = sub_10000B070("octagon-ckks");
    BOOL v33 = os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT);
    if (v31)
    {
      if (v33)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "Waiting for device unlock to proceed", buf, 2u);
      }
      uint64_t v34 = &off_1003052F0;
    }
    else
    {
      if (v33)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "Error is scary; becoming untrusted",
          buf,
          2u);
      }
      uint64_t v34 = &off_100305548;
    }

    [v3 setNextState:*v34];
  }
  else
  {
    BOOL v28 = sub_10000B070("SecError");
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "octagon-ckks: No memoized CKKS policy, re-fetching", buf, 2u);
    }

    [v3 setNextState:@"RefetchCKKSPolicy"];
  }
LABEL_30:
  _Block_object_dispose(&v42, 8);

  _Block_object_dispose(&v48, 8);
}

void sub_1000EB92C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  va_start(va1, a10);
  va_start(va, a10);
  uint64_t v11 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v15 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

id sub_1000EB96C(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [v3 peerID];
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;

  unsigned int v7 = [v3 hasSyncingPolicy];
  if (v7)
  {
    BOOL v8 = [v3 getTPSyncingPolicy];
  }
  else
  {
    BOOL v8 = 0;
  }
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), v8);
  if (v7) {

  }
  return v3;
}

void sub_1000EBB08(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000EBB24(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v5 = [WeakRetained contextID];
  unsigned int v6 = [v5 isEqualToString:@"defaultContext"];

  if (v6)
  {
    unsigned int v7 = [WeakRetained accountStateTracker];
    [v7 triggerOctagonStatusFetch];
  }
  uint64_t v24 = 0;
  id v25 = &v24;
  uint64_t v26 = 0x2020000000;
  char v27 = 0;
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 3221225472;
  void v23[2] = sub_1000EBF24;
  v23[3] = &unk_1002F9B50;
  void v23[4] = &v24;
  [WeakRetained checkTrustStatusAndPostRepairCFUIfNecessary:v23];
  if (*((unsigned char *)v25 + 24))
  {
    BOOL v8 = sub_10000B070("octagon");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "device is locked, state moving to wait for unlock", buf, 2u);
    }

    [v3 setNextState:@"WaitForUnlock"];
    id v9 = 0;
  }
  else
  {
    int v10 = [WeakRetained accountMetadataStore];
    id v22 = 0;
    [v10 persistAccountChanges:&stru_1002F9C08 error:&v22];
    id v9 = v22;

    [WeakRetained setMetricsStateToActive];
    if (v9)
    {
      uint64_t v11 = sub_10000B070("octagon");
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v29 = v9;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Unable to set trust state: %@", buf, 0xCu);
      }

      [v3 setNextState:@"Error"];
    }
    else
    {
      uint64_t v12 = [v3 intendedState];
      [v3 setNextState:v12];
    }
    uint64_t v13 = sub_10000B070("octagon-ckks");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = [WeakRetained ckks];
      *(_DWORD *)long long buf = 138412290;
      id v29 = v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Informing %@ of new untrusted status", buf, 0xCu);
    }
    uint64_t v15 = [WeakRetained ckks];
    [v15 endTrustedOperation];

    uint64_t v16 = [WeakRetained sosAdapter];
    unsigned int v17 = [v16 sosEnabled];

    if (v17)
    {
      id v18 = [WeakRetained sosAdapter];
      id v21 = 0;
      [v18 updateCKKS4AllStatus:0 error:&v21];
      id v19 = v21;

      if (v19)
      {
        uint64_t v20 = sub_10000B070("octagon-ckks");
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          id v29 = v19;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Unable to disable the CKKS4All status in SOS: %@", buf, 0xCu);
        }
      }
    }
    if (([WeakRetained initialBecomeUntrustedPosted] & 1) == 0)
    {
      [WeakRetained notifyTrustChanged:1];
      [WeakRetained setInitialBecomeUntrustedPosted:1];
    }
    [WeakRetained setOctagonAdapter:0];
  }
  _Block_object_dispose(&v24, 8);
}

void sub_1000EBEFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000EBF24(uint64_t a1, uint64_t a2, int a3, uint64_t a4, char a5, void *a6)
{
  id v9 = a6;
  int v10 = +[CKKSAnalytics logger];
  [v10 logResultForEvent:@"OctagonEventCheckTrustForCFU" hardFailure:0 result:v9];

  if (!v9)
  {
    if ((a5 & 1) == 0) {
      goto LABEL_5;
    }
    goto LABEL_8;
  }
  if ([v9 code] != (id)-25308)
  {
    uint64_t v11 = sub_10000B070("SecError");
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_13;
    }
    int v16 = 138412290;
    id v17 = v9;
    uint64_t v13 = "octagon: hit an error checking trust state or posting a cfu: %@";
    uint64_t v14 = v11;
    uint32_t v15 = 12;
    goto LABEL_12;
  }
  if ((a5 & 1) != 0 || [v9 code] == (id)-25308)
  {
LABEL_8:
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a5;
    uint64_t v11 = sub_10000B070("SecError");
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_13;
    }
    LOWORD(v16) = 0;
    uint64_t v13 = "octagon: device is locked, not posting cfu";
    uint64_t v14 = v11;
    uint32_t v15 = 2;
LABEL_12:
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v13, (uint8_t *)&v16, v15);
    goto LABEL_13;
  }
LABEL_5:
  uint64_t v11 = sub_10000B070("octagon");
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = OTCliqueStatusToString();
    int v16 = 138412546;
    id v17 = v12;
    __int16 v18 = 1024;
    int v19 = a3;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "clique status: %@, posted cfu: %d", (uint8_t *)&v16, 0x12u);
  }
LABEL_13:
}

OTAccountMetadataClassC *__cdecl sub_1000EC124(id a1, OTAccountMetadataClassC *a2)
{
  uint64_t v2 = a2;
  [(OTAccountMetadataClassC *)v2 setTrustState:1];
  [(OTAccountMetadataClassC *)v2 setSendingMetricsPermitted:1];

  return v2;
}

void sub_1000EC25C(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_1000EC280(uint64_t a1, uint64_t a2, void *a3, void *a4, int a5, int a6, void *a7)
{
  id v13 = a3;
  id v14 = a4;
  id v15 = a7;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v17 = sub_10000B070("octagon");
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v18 = OTCliqueStatusToString();
    *(_DWORD *)long long buf = 138413314;
    uint64_t v50 = v18;
    __int16 v51 = 2112;
    id v52 = v13;
    __int16 v53 = 2112;
    id v54 = v14;
    __int16 v55 = 1024;
    int v56 = a5;
    __int16 v57 = 2112;
    id v58 = v15;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "clique status: %@, egoPeerID: %@, peerCountByModelID: %@, isExcluded: %d error: %@", buf, 0x30u);
  }
  if (a2 == -1 && [v15 code] == (id)-25300)
  {
    int v19 = sub_10000B070("SecError");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "octagon: Lost our identity keys!", buf, 2u);
    }

    uint64_t v20 = sub_10000B070("SecError");
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "octagon: Posting CFU", buf, 2u);
    }

    id v48 = 0;
    [WeakRetained postRepairCFU:&v48];
    id v21 = v48;
    id v22 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
    goto LABEL_49;
  }
  if (v15 && [v15 code] != (id)-25308)
  {
    uint64_t v24 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
    goto LABEL_47;
  }
  if (a6)
  {
    id v23 = sub_10000B070("octagon");
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "device is locked; not posting CFU", buf, 2u);
    }

    uint64_t v24 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
    goto LABEL_47;
  }
  id v25 = [WeakRetained sosAdapter];
  unsigned int v26 = [v25 sosEnabled];

  if (v26)
  {
    char v27 = [WeakRetained accountMetadataStore];
    id v47 = 0;
    BOOL v28 = [v27 loadOrCreateAccountMetadata:&v47];
    id v29 = v47;

    unsigned int v30 = v28;
    if (!v28 || v29)
    {
      BOOL v33 = sub_10000B070("SecError");
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        uint64_t v50 = v29;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "octagon: failed to retrieve joining attempt information: %@", buf, 0xCu);
      }
      goto LABEL_42;
    }
    if ([v28 attemptedJoin] == 2)
    {
LABEL_43:

      goto LABEL_44;
    }
    uint64_t v44 = v28;
    unsigned int v31 = sub_10000B070("octagon");
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "SOS is enabled and we haven't attempted to join; checking with SOS",
        buf,
        2u);
    }

    id v32 = [WeakRetained sosAdapter];
    id v46 = 0;
    unsigned int v40 = [v32 circleStatus:&v46];
    BOOL v33 = v46;

    if (v33)
    {
      uint64_t v34 = [v33 domain];
      if ([v34 isEqualToString:kSOSErrorDomain])
      {
        os_log_t loga = (os_log_t)[v33 code];

        if (loga == (os_log_t)4)
        {
          unsigned int v35 = sub_10000B070("octagon");
          unsigned __int8 v36 = v44;
          if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "SOS is not ready, not posting CFU until it becomes so", buf, 2u);
          }
          goto LABEL_52;
        }
      }
      else
      {
      }
      log = sub_10000B070("octagon");
      unsigned int v30 = v44;
      if (os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        uint64_t v50 = v33;
        _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "SOS is in an unknown error state, posting CFU: %@", buf, 0xCu);
      }
    }
    else
    {
      log = sub_10000B070("octagon");
      BOOL v37 = os_log_type_enabled(log, OS_LOG_TYPE_DEFAULT);
      if (!v40)
      {
        if (v37)
        {
          *(_WORD *)long long buf = 0;
          unsigned int v35 = log;
          _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "SOS is InCircle, not posting CFU", buf, 2u);
        }
        else
        {
          unsigned int v35 = log;
        }
        unsigned __int8 v36 = v44;
LABEL_52:

        (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
        goto LABEL_50;
      }
      if (v37)
      {
        uint64_t v38 = SOSCCGetStatusDescription();
        *(_DWORD *)long long buf = 138412290;
        uint64_t v50 = v38;
        unsigned int v41 = v38;
        _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "SOS is %@, posting CFU", buf, 0xCu);

        id v39 = log;
        unsigned int v30 = v44;
LABEL_41:

LABEL_42:
        goto LABEL_43;
      }
      unsigned int v30 = v44;
    }
    id v39 = log;
    goto LABEL_41;
  }
LABEL_44:
  if ((a2 & 0xFFFFFFFFFFFFFFFDLL) == 1 || a5)
  {
    id v45 = 0;
    [WeakRetained postRepairCFU:&v45];
    id v21 = v45;
    id v22 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
LABEL_49:
    v22();

    goto LABEL_50;
  }
  uint64_t v24 = *(void (**)(void))(*(void *)(a1 + 32) + 16);
LABEL_47:
  v24();
LABEL_50:
}

void sub_1000ECCC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000ECCD8(uint64_t a1, void *a2, void *a3, uint64_t a4, int a5, int a6, void *a7)
{
  id v12 = a3;
  id v13 = a7;
  id v14 = sub_10000B070("octagon-health");
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218754;
    id v37 = a2;
    __int16 v38 = 2112;
    id v39 = v12;
    __int16 v40 = 1024;
    int v41 = a5;
    __int16 v42 = 2112;
    id v43 = v13;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "repairAccountIfTrustedByTPHWithIntendedState status: %ld, peerID: %@, isExcluded: %d error: %@", buf, 0x26u);
  }

  if (v13)
  {
    id v15 = sub_10000B070("octagon-health");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v37 = v13;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "got an error from tph, returning to become_ready state: %@", buf, 0xCu);
    }

    uint64_t v16 = *(void *)(*(void *)(a1 + 48) + 8);
    id v17 = @"BecomeReady";
LABEL_25:
    id v29 = v17;
    id v22 = *(id *)(v16 + 40);
    *(void *)(v16 + 40) = v17;
LABEL_26:

    goto LABEL_27;
  }
  if (a6)
  {
    __int16 v18 = sub_10000B070("octagon-health");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "device is locked", buf, 2u);
    }

    uint64_t v16 = *(void *)(*(void *)(a1 + 48) + 8);
    id v17 = @"WaitForUnlock";
    goto LABEL_25;
  }
  if (!a2 && v12)
  {
    int v19 = sub_10000B070("octagon-health");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v37 = v12;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "TPH believes we're trusted, accepting ego peerID as %@", buf, 0xCu);
    }

    uint64_t v20 = [*(id *)(a1 + 32) accountMetadataStore];
    v34[0] = _NSConcreteStackBlock;
    v34[1] = 3221225472;
    v34[2] = sub_1000ED100;
    v34[3] = &unk_100307118;
    id v35 = v12;
    id v33 = 0;
    unsigned int v21 = [v20 persistAccountChanges:v34 error:&v33];
    id v22 = v33;

    if (!v21 || v22)
    {
      unsigned int v30 = sub_10000B070("SecError");
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v37 = v22;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "octagon-health: couldn't persist results: %@", buf, 0xCu);
      }

      uint64_t v31 = *(void *)(*(void *)(a1 + 48) + 8);
      id v32 = @"Error";
      char v27 = *(void **)(v31 + 40);
      *(void *)(v31 + 40) = @"Error";
    }
    else
    {
      id v23 = sub_10000B070("octagon-health");
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "added trusted identity to account metadata", buf, 2u);
      }

      uint64_t v24 = *(void **)(a1 + 40);
      uint64_t v25 = *(void *)(*(void *)(a1 + 48) + 8);
      id v26 = v24;
      char v27 = *(void **)(v25 + 40);
      *(void *)(v25 + 40) = v26;
    }

    goto LABEL_26;
  }
  if (a2 && v12)
  {
    BOOL v28 = sub_10000B070("octagon-health");
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "TPH believes we're not trusted, requesting CFU post", buf, 2u);
    }

    uint64_t v16 = *(void *)(*(void *)(a1 + 48) + 8);
    id v17 = @"PostRepairCFU";
    goto LABEL_25;
  }
LABEL_27:
}

id sub_1000ED100(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 setTrustState:2];
  [v3 setPeerID:*(void *)(a1 + 32)];

  return v3;
}

void sub_1000ED248(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000ED264(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = (id *)(a1 + 32);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  unsigned int v6 = [WeakRetained accountMetadataStore];
  id v37 = 0;
  unsigned int v7 = [v6 loadOrCreateAccountMetadata:&v37];
  id v8 = v37;

  if (v8)
  {
    id v9 = [WeakRetained lockStateTracker];
    unsigned int v10 = [v9 isLockedError:v8];

    if (v10)
    {
      uint64_t v11 = sub_10000B070("octagon");
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Device is locked! pending initialization on unlock", buf, 2u);
      }

      [v3 setNextState:@"WaitForClassCUnlock"];
      goto LABEL_30;
    }
  }
  else if (v7)
  {
    goto LABEL_10;
  }
  id v12 = sub_10000B070("octagon");
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    id v39 = v8;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Error loading account data: %@", buf, 0xCu);
  }

  [v3 setNextState:@"NoAccount"];
LABEL_10:
  if ([v7 isInheritedAccount])
  {
    [v3 setNextState:@"BecomeInherited"];
    goto LABEL_30;
  }
  if ([v7 warmedEscrowCache]) {
    goto LABEL_27;
  }
  id v13 = [v7 peerID];
  BOOL v14 = v13 == 0;

  id v15 = sub_10000B070("octagon-warm-escrowcache");
  BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
  if (v14)
  {
    if (v16)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Beginning fetching escrow records to warm up the escrow cache in TPH", buf, 2u);
    }

    id v17 = objc_alloc_init(CKKSCondition);
    [WeakRetained setPendingEscrowCacheWarmup:v17];

    __int16 v18 = dispatch_get_global_queue(17, 0);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000ED784;
    block[3] = &unk_1003077A0;
    objc_copyWeak(&v36, v4);
    dispatch_async(v18, block);

    objc_destroyWeak(&v36);
  }
  else
  {
    if (v16)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Already have a peerID; no need to warm escrow cache",
        buf,
        2u);
    }
  }
  int v19 = [WeakRetained accountMetadataStore];
  id v34 = 0;
  [v19 persistAccountChanges:&stru_1002F9B70 error:&v34];
  id v20 = v34;

  if (v20)
  {
    unsigned int v21 = sub_10000B070("SecError");
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v39 = v20;
      id v22 = "octagon-warm-escrowcache: Failed to write down escrow cache attempt: %@";
      id v23 = v21;
      uint32_t v24 = 12;
LABEL_25:
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, v22, buf, v24);
    }
  }
  else
  {
    unsigned int v21 = sub_10000B070("octagon-warm-escrowcache");
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      id v22 = "Successfully persisted warmed-escrow-cache attempt state";
      id v23 = v21;
      uint32_t v24 = 2;
      goto LABEL_25;
    }
  }

LABEL_27:
  uint64_t v25 = sub_10000B070("octagon");
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "iCloud sign in occurred. Attempting to register with APS...", buf, 2u);
  }

  id v26 = [WeakRetained containerName];
  char v27 = +[CKContainer containerWithIdentifier:v26];

  id v29 = _NSConcreteStackBlock;
  uint64_t v30 = 3221225472;
  uint64_t v31 = sub_1000ED844;
  id v32 = &unk_1002F9B98;
  objc_copyWeak(&v33, v4);
  [v27 serverPreferredPushEnvironmentWithCompletionHandler:&v29];
  BOOL v28 = [v3 intendedState:v29, v30, v31, v32];
  [v3 setNextState:v28];

  objc_destroyWeak(&v33);
LABEL_30:
}

void sub_1000ED764(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_1000ED784(uint64_t a1)
{
  uint64_t v1 = (id *)(a1 + 32);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_1000EDA38;
  v3[3] = &unk_100304E40;
  objc_copyWeak(&v4, v1);
  [WeakRetained rpcFetchAllViableEscrowRecordsFromSource:0 reply:v3];
  objc_destroyWeak(&v4);
}

void sub_1000ED830(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_1000ED844(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (!WeakRetained)
  {
    id v9 = sub_10000B070("SecError");
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_12;
    }
    LOWORD(v13) = 0;
    unsigned int v10 = "octagonpush: received callback for released object";
    uint64_t v11 = v9;
    uint32_t v12 = 2;
LABEL_11:
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v13, v12);
    goto LABEL_12;
  }
  if (!v5 || v6)
  {
    id v9 = sub_10000B070("SecError");
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_12;
    }
    int v13 = 138412546;
    id v14 = v5;
    __int16 v15 = 2112;
    id v16 = v6;
    unsigned int v10 = "octagonpush: Received error fetching preferred push environment (%@): %@";
    uint64_t v11 = v9;
    uint32_t v12 = 22;
    goto LABEL_11;
  }
  id v8 = sub_10000B070("octagonpush");
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = 138412290;
    id v14 = v5;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "Registering for environment '%@'", (uint8_t *)&v13, 0xCu);
  }

  id v9 = [WeakRetained apsReceiver];
  [v9 registerForEnvironment:v5];
LABEL_12:
}

OTAccountMetadataClassC *__cdecl sub_1000ED9F8(id a1, OTAccountMetadataClassC *a2)
{
  uint64_t v2 = a2;
  [(OTAccountMetadataClassC *)v2 setWarmedEscrowCache:1];

  return v2;
}

void sub_1000EDA38(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (v4)
  {
    id v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 138412290;
      id v12 = v4;
      unsigned int v7 = "octagon-warm-escrowcache: failed to fetch escrow records, %@";
      id v8 = v6;
      uint32_t v9 = 12;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v11, v9);
    }
  }
  else
  {
    id v6 = sub_10000B070("octagon-warm-escrowcache");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v11) = 0;
      unsigned int v7 = "Successfully fetched escrow records";
      id v8 = v6;
      uint32_t v9 = 2;
      goto LABEL_6;
    }
  }

  unsigned int v10 = [WeakRetained pendingEscrowCacheWarmup];
  [v10 fulfill];
}

void sub_1000EDC10(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v7 = 0;
  id v8 = &v7;
  uint64_t v9 = 0x2020000000;
  char v10 = 0;
  id v4 = *(void **)(a1 + 32);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  _DWORD v6[2] = sub_1000EDCFC;
  v6[3] = &unk_1002F9B50;
  void v6[4] = &v7;
  [v4 checkTrustStatusAndPostRepairCFUIfNecessary:v6];
  if (*((unsigned char *)v8 + 24)) {
    CFStringRef v5 = @"WaitForUnlock";
  }
  else {
    CFStringRef v5 = @"Untrusted";
  }
  [v3 setNextState:v5];
  _Block_object_dispose(&v7, 8);
}

void sub_1000EDCE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000EDCFC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, void *a6)
{
  id v8 = a6;
  if (!v8)
  {
    if (a5)
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a5;
      uint64_t v9 = sub_10000B070("octagon-health");
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_11;
      }
      LOWORD(v13) = 0;
      char v10 = "device is locked, not posting cfu";
    }
    else
    {
      uint64_t v9 = sub_10000B070("octagon-health");
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_11;
      }
      LOWORD(v13) = 0;
      char v10 = "posted repair cfu via state machine";
    }
    int v11 = v9;
    uint32_t v12 = 2;
    goto LABEL_10;
  }
  uint64_t v9 = sub_10000B070("SecError");
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = 138412290;
    id v14 = v8;
    char v10 = "ocagon-health: failed to post repair cfu via state machine: %@";
    int v11 = v9;
    uint32_t v12 = 12;
LABEL_10:
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v13, v12);
  }
LABEL_11:
}

void sub_1000EDFEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000EE00C(uint64_t a1)
{
  from = (id *)(a1 + 40);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v2 = sub_10000B070("octagon-health");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v48 = [*(id *)(a1 + 32) results];
    unsigned int v43 = [v48 postRepairCFU];
    id v47 = [*(id *)(a1 + 32) results];
    unsigned int v42 = [v47 postEscrowCFU];
    id v46 = [*(id *)(a1 + 32) results];
    unsigned int v3 = [v46 resetOctagon];
    id v45 = [*(id *)(a1 + 32) results];
    unsigned int v4 = [v45 leaveTrust];
    CFStringRef v5 = [*(id *)(a1 + 32) results];
    unsigned int v6 = [v5 reroll];
    uint64_t v7 = [*(id *)(a1 + 32) results];
    id v8 = [v7 moveRequest];
    uint64_t v9 = [*(id *)(a1 + 32) results];
    *(_DWORD *)long long buf = 67110658;
    *(_DWORD *)id v58 = v43;
    *(_WORD *)&v58[4] = 1024;
    *(_DWORD *)&v58[6] = v42;
    __int16 v59 = 1024;
    unsigned int v60 = v3;
    __int16 v61 = 1024;
    unsigned int v62 = v4;
    __int16 v63 = 1024;
    unsigned int v64 = v6;
    __int16 v65 = 1024;
    BOOL v66 = v8 != 0;
    __int16 v67 = 2112;
    id v68 = v9;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Returning from cuttlefish trust check call: postRepairCFU(%d), postEscrowCFU(%d), resetOctagon(%d), leaveTrust(%d), reroll(%d), moveRequest(%d), results=%@", buf, 0x30u);
  }
  uint64_t v10 = [*(id *)(a1 + 32) results];
  int v11 = (void *)WeakRetained[8];
  WeakRetained[8] = v10;

  uint32_t v12 = [*(id *)(a1 + 32) results];
  unsigned int v13 = [v12 postRepairCFU];

  if (v13)
  {
    id v14 = sub_10000B070("octagon-health");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Posting Repair CFU", buf, 2u);
    }

    id v56 = 0;
    [WeakRetained postRepairCFU:&v56];
    id v15 = v56;
    if (v15) {
      [*(id *)(a1 + 32) setError:v15];
    }
  }
  id v16 = [*(id *)(a1 + 32) results];
  unsigned int v17 = [v16 postEscrowCFU];

  if (v17)
  {
    id v55 = 0;
    unsigned int v18 = [WeakRetained shouldPostConfirmPasscodeCFU:&v55];
    id v19 = v55;
    if (v19)
    {
      id v20 = sub_10000B070("SecError");
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        *(void *)id v58 = v19;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "octagon-health, hit an error evaluating prerecord status: %@", buf, 0xCu);
      }

      [*(id *)(a1 + 32) setError:v19];
    }
    unsigned int v21 = sub_10000B070("octagon-health");
    BOOL v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
    if (v18)
    {
      if (v22)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Posting Escrow CFU", buf, 2u);
      }

      id v54 = 0;
      unsigned __int8 v23 = [WeakRetained postConfirmPasscodeCFU:&v54];
      unsigned int v21 = v54;
      if ((v23 & 1) == 0) {
        [*(id *)(a1 + 32) setError:v21];
      }
    }
    else if (v22)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Not posting confirm passcode CFU, already pending a prerecord upload", buf, 2u);
    }
  }
  uint32_t v24 = [*(id *)(a1 + 32) results];
  unsigned int v25 = [v24 leaveTrust];

  if (v25)
  {
    id v26 = sub_10000B070("octagon-health");
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Leaving Octagon and SOS trust", buf, 2u);
    }

    id v53 = 0;
    unsigned __int8 v27 = [WeakRetained leaveTrust:&v53];
    id v28 = v53;
    if ((v27 & 1) == 0) {
      [*(id *)(a1 + 32) setError:v28];
    }
  }
  id v29 = [*(id *)(a1 + 32) results];
  unsigned int v30 = [v29 reroll];

  if (v30)
  {
    v51[0] = _NSConcreteStackBlock;
    v51[1] = 3221225472;
    v51[2] = sub_1000EE6C4;
    v51[3] = &unk_1002F9B28;
    objc_copyWeak(&v52, from);
    uint64_t v31 = +[CKKSResultOperation named:@"reroll" withBlockTakingSelf:v51];
    [*(id *)(a1 + 32) addDependency:v31];
    id v32 = [WeakRetained operationQueue];
    [v32 addOperation:v31];

    objc_destroyWeak(&v52);
  }
  id v33 = [*(id *)(a1 + 32) results];
  id v34 = [v33 moveRequest];

  if (v34)
  {
    id v35 = sub_10000B070("octagon-health");
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      id v36 = [*(id *)(a1 + 32) results];
      id v37 = [v36 moveRequest];
      *(_DWORD *)long long buf = 138412290;
      *(void *)id v58 = v37;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "Received escrow move request: %@", buf, 0xCu);
    }
    __int16 v38 = [*(id *)(a1 + 32) results];
    id v39 = [v38 moveRequest];
    id v50 = 0;
    unsigned __int8 v40 = [WeakRetained processMoveRequest:v39 error:&v50];
    id v41 = v50;

    if ((v40 & 1) == 0) {
      [*(id *)(a1 + 32) setError:v41];
    }
  }
}

void sub_1000EE6A4(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  _Unwind_Resume(a1);
}

void sub_1000EE6C4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  CFStringRef v5 = sub_10000B070("octagon-health");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Rerolling Octagon PeerID", buf, 2u);
  }

  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_1000EE7C0;
  v7[3] = &unk_1002F9A20;
  id v8 = v3;
  id v6 = v3;
  [WeakRetained rerollWithReply:v7];
}

void sub_1000EE7C0(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    unsigned int v4 = sub_10000B070("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 138412290;
      id v6 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "octagon-health: reroll failed: %@", (uint8_t *)&v5, 0xCu);
    }

    [*(id *)(a1 + 32) setError:v3];
  }
}

void sub_1000EE934(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v4 = *(void **)(a1 + 32);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  _DWORD v6[2] = sub_1000EE9CC;
  v6[3] = &unk_1002F9B00;
  id v7 = v3;
  id v5 = v3;
  [v4 checkTrustStatusAndPostRepairCFUIfNecessary:v6];
}

void sub_1000EE9CC(uint64_t a1, uint64_t a2, int a3, char a4, int a5, void *a6)
{
  id v11 = a6;
  uint32_t v12 = +[CKKSAnalytics logger];
  [v12 logResultForEvent:@"OctagonEventTPHHealthCheckStatus" hardFailure:0 result:v11];

  if (v11)
  {
    unsigned int v13 = sub_10000B070("SecError");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      int v19 = 138412290;
      id v20 = v11;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "octagon-health: hit an error asking TPH for trust status: %@", (uint8_t *)&v19, 0xCu);
    }

    [*(id *)(a1 + 32) setError:v11];
    id v14 = *(void **)(a1 + 32);
    CFStringRef v15 = @"Error";
LABEL_5:
    [v14 setNextState:v15];
    goto LABEL_6;
  }
  if (!a5)
  {
    if (a4)
    {
      unsigned int v17 = sub_10000B070("octagon-health");
      BOOL v18 = os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT);
      if (a2)
      {
        if (v18)
        {
          int v19 = 67109120;
          LODWORD(v20) = a3;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "TPH says we have an identity but we are not in Octagon, posted CFU: %d", (uint8_t *)&v19, 8u);
        }

        id v14 = *(void **)(a1 + 32);
        CFStringRef v15 = @"PostRepairCFU";
      }
      else
      {
        if (v18)
        {
          LOWORD(v19) = 0;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "TPH says we're trusted and in", (uint8_t *)&v19, 2u);
        }

        id v14 = *(void **)(a1 + 32);
        CFStringRef v15 = @"CuttlefishTrustCheck";
      }
    }
    else
    {
      id v14 = *(void **)(a1 + 32);
      CFStringRef v15 = @"Untrusted";
    }
    goto LABEL_5;
  }
  [*(id *)(a1 + 32) setNextState:@"WaitForUnlock"];
  id v16 = sub_10000B070("octagon-health");
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    LOWORD(v19) = 0;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "TPH says device is locked!", (uint8_t *)&v19, 2u);
  }

LABEL_6:
}

void sub_1000EECC0(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v4 = [*(id *)(a1 + 32) accountMetadataStore];
  id v15 = 0;
  id v5 = [v4 loadOrCreateAccountMetadata:&v15];
  id v6 = v15;

  uint64_t v7 = [v5 peerID];
  if (v7 && (id v8 = (void *)v7, v9 = [v5 trustState], v8, v9 == 2))
  {
    uint64_t v10 = sub_10000B070("octagon-health");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      id v11 = [v5 peerID];
      *(_DWORD *)long long buf = 138412290;
      unsigned int v17 = v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "peer is trusted: %@", buf, 0xCu);
    }
    [v3 setNextState:@"TPHTrustCheck"];
  }
  else
  {
    uint32_t v12 = sub_10000B070("octagon-health");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v13 = [v5 trustStateAsString:[v5 trustState]];
      *(_DWORD *)long long buf = 138412290;
      unsigned int v17 = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "trust state (%@). checking in with TPH", buf, 0xCu);
    }
    id v14 = [*(id *)(a1 + 32) repairAccountIfTrustedByTPHWithIntendedState:@"TPHTrustCheck"];
    [v3 setNextState:v14];
  }
}

void sub_1000EEFC4(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_1000EEFE0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v5 = [WeakRetained accountMetadataStore];
  id v13 = 0;
  id v6 = [v5 loadOrCreateAccountMetadata:&v13];
  id v7 = v13;

  if (v7)
  {
    id v8 = [WeakRetained lockStateTracker];
    unsigned int v9 = [v8 isLockedError:v7];

    if (v9)
    {
      uint64_t v10 = sub_10000B070("octagon");
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Device is locked! pending initialization on unlock", buf, 2u);
      }

      id v11 = &off_100305530;
      goto LABEL_11;
    }
  }
  else if (v6)
  {
    id v11 = (__CFString **)(a1 + 32);
    goto LABEL_11;
  }
  uint32_t v12 = sub_10000B070("octagon");
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    id v15 = v7;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Error loading account data: %@", buf, 0xCu);
  }

  id v11 = &off_1003052E8;
LABEL_11:
  [v3 setNextState:*v11];
}

void sub_1000EF230(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v4 = sub_10000B070("octagon");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    id v5 = *(void **)(a1 + 32);
    *(_DWORD *)long long buf = 138412290;
    id v15 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Account now unavailable: %@", buf, 0xCu);
  }

  id v6 = [*(id *)(a1 + 32) accountMetadataStore];
  id v13 = 0;
  [v6 persistAccountChanges:&stru_1002F9AB0 error:&v13];
  id v7 = v13;

  if (v7)
  {
    id v8 = sub_10000B070("SecError");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v15 = v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon: unable to persist new account availability: %@", buf, 0xCu);
    }
  }
  unsigned int v9 = [*(id *)(a1 + 32) accountStateTracker];
  [v9 setCDPCapableiCloudAccountStatus:3];

  uint64_t v10 = sub_10000B070("octagon-ckks");
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    id v11 = [*(id *)(a1 + 32) ckks];
    *(_DWORD *)long long buf = 138412290;
    id v15 = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Informing %@ of new untrusted status (due to account disappearance)", buf, 0xCu);
  }
  uint32_t v12 = [*(id *)(a1 + 32) ckks];
  [v12 endTrustedOperation];

  [v3 setError:v7];
}

OTAccountMetadataClassC *__cdecl sub_1000EF43C(id a1, OTAccountMetadataClassC *a2)
{
  uint64_t v2 = a2;
  [(OTAccountMetadataClassC *)v2 setIcloudAccountState:1];
  [(OTAccountMetadataClassC *)v2 setAltDSID:0];
  [(OTAccountMetadataClassC *)v2 setTrustState:0];
  [(OTAccountMetadataClassC *)v2 setCdpState:0];
  [(OTAccountMetadataClassC *)v2 setSecureElementIdentity:0];

  return v2;
}

void sub_1000EF590(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 24));
  _Unwind_Resume(a1);
}

void sub_1000EF5AC(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v5 = [WeakRetained accountMetadataStore];
  id v53 = 0;
  id v6 = [v5 loadOrCreateAccountMetadata:&v53];
  id v7 = v53;

  if (v7)
  {
    id v8 = [WeakRetained lockStateTracker];
    unsigned int v9 = [v8 isLockedError:v7];

    if (v9)
    {
      uint64_t v10 = sub_10000B070("octagon");
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Device is locked! pending initialization on unlock", buf, 2u);
      }

      CFStringRef v11 = @"WaitForClassCUnlock";
      goto LABEL_20;
    }
    goto LABEL_16;
  }
  if (!v6)
  {
LABEL_16:
    id v26 = sub_10000B070("octagon");
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v55 = v7;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Error loading account data: %@", buf, 0xCu);
    }

    [WeakRetained setMetricsStateToActive];
LABEL_19:
    CFStringRef v11 = @"NoAccount";
    goto LABEL_20;
  }
  if ([v6 icloudAccountState] != 2)
  {
    if ([v6 icloudAccountState] == 1
      && ([v6 altDSID], unsigned __int8 v27 = objc_claimAutoreleasedReturnValue(), v27, v27))
    {
      id v28 = sub_10000B070("octagon");
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "An iCloud account exists, but doesn't appear to be CDP Capable. Let's check!", buf, 2u);
      }
    }
    else
    {
      if ([v6 icloudAccountState] == 1)
      {
        id v29 = [WeakRetained accountStateTracker];
        [v29 setCDPCapableiCloudAccountStatus:3];

        unsigned int v30 = sub_10000B070("octagon");
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)long long buf = 0;
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "No iCloud account available.", buf, 2u);
        }

        [WeakRetained setMetricsToState:[v6 sendingMetricsPermitted]];
        goto LABEL_19;
      }
      id v28 = sub_10000B070("octagon");
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v31 = [v6 icloudAccountStateAsString:[v6 icloudAccountState]];
        *(_DWORD *)long long buf = 138412290;
        id v55 = v31;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Unknown account state (%@). Determining...", buf, 0xCu);
      }
    }

    [WeakRetained setMetricsToState:[v6 sendingMetricsPermitted]];
    CFStringRef v11 = @"DetermineiCloudAccountState";
    goto LABEL_20;
  }
  uint32_t v12 = sub_10000B070("octagon");
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "An CDP Capable iCloud account exists; waiting for CloudKit to confirm",
      buf,
      2u);
  }

  [WeakRetained setMetricsToState:[v6 sendingMetricsPermitted]];
  id v13 = [WeakRetained activeAccount];

  if (!v13)
  {
    id v14 = [WeakRetained accountsAdapter];
    id v15 = [WeakRetained personaAdapter];
    id v16 = [WeakRetained containerName];
    unsigned int v17 = [WeakRetained contextID];
    id v52 = 0;
    BOOL v18 = [v14 findAccountForCurrentThread:v15 optionalAltDSID:0 cloudkitContainerName:v16 octagonContextID:v17 error:&v52];
    id v19 = v52;
    [WeakRetained setActiveAccount:v18];

    id v20 = [WeakRetained activeAccount];

    if (!v20 || v19)
    {
      uint32_t v24 = sub_10000B070("SecError");
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_35;
      }
      unsigned int v25 = [WeakRetained contextID];
      *(_DWORD *)long long buf = 138412546;
      id v55 = v25;
      __int16 v56 = 2112;
      id v57 = v19;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "octagon-account: unable to determine active account for context(%@). Issues ahead: %@", buf, 0x16u);
    }
    else
    {
      unsigned int v21 = sub_10000B070("octagon-account");
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        BOOL v22 = [WeakRetained contextID];
        unsigned __int8 v23 = [WeakRetained activeAccount];
        *(_DWORD *)long long buf = 138412546;
        id v55 = v22;
        __int16 v56 = 2112;
        id v57 = v23;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Found a new account (%@): %@", buf, 0x16u);
      }
      uint32_t v24 = [WeakRetained accountMetadataStore];
      unsigned int v25 = [WeakRetained activeAccount];
      [v24 changeActiveAccount:v25];
    }

LABEL_35:
    id v50 = v19;

    id v32 = [WeakRetained activeAccount];
    uint64_t v33 = [v32 altDSID];
    if (v33)
    {
      id v34 = (void *)v33;
      id v35 = [WeakRetained activeAccount:v19];
      id v36 = [v35 altDSID];
      id v37 = [v6 altDSID];
      unsigned __int8 v38 = [v36 isEqualToString:v37];

      if (v38)
      {
LABEL_42:

        goto LABEL_43;
      }
    }
    else
    {
    }
    id v39 = sub_10000B070("SecError");
    if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
    {
      unsigned __int8 v40 = [WeakRetained activeAccount];
      id v41 = [v40 altDSID];
      unsigned int v42 = [v6 altDSID];
      *(_DWORD *)long long buf = 138412546;
      id v55 = v41;
      __int16 v56 = 2112;
      id v57 = v42;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "octagon-account: discovered altDSID (%@) does not match persisted altDSID (%@)", buf, 0x16u);
    }
    goto LABEL_42;
  }
LABEL_43:
  unsigned int v43 = [WeakRetained accountStateTracker];
  [v43 setCDPCapableiCloudAccountStatus:1];

  uint64_t v44 = sub_10000B070("octagon-ckks");
  if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "Initializing CKKS views", buf, 2u);
  }

  id v45 = [WeakRetained cuttlefishXPCWrapper];
  id v46 = [WeakRetained activeAccount];
  id v47 = [WeakRetained deviceAdapter];
  id v48 = [v47 modelID];
  v51[0] = _NSConcreteStackBlock;
  v51[1] = 3221225472;
  v51[2] = sub_1000EFDD4;
  v51[3] = &unk_1002F9A90;
  void v51[4] = WeakRetained;
  [v45 fetchCurrentPolicyWithSpecificUser:v46 modelIDOverride:v48 isInheritedAccount:[v6 isInheritedAccount] reply:v51];

  unsigned int v49 = [WeakRetained ckks];
  [v49 beginCloudKitOperation];

  CFStringRef v11 = @"WaitingForCloudKitAccount";
LABEL_20:
  [v3 setNextState:v11];
}

void sub_1000EFDD4(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6 = a2;
  id v7 = a4;
  id v8 = v7;
  if (!v6 || v7)
  {
    uint64_t v10 = sub_10000B070("SecError");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 138412290;
      id v12 = v8;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "octagon-ckks: Unable to fetch initial syncing policy. THIS MIGHT CAUSE SYNCING FAILURES LATER: %@", (uint8_t *)&v11, 0xCu);
    }
  }
  else
  {
    unsigned int v9 = sub_10000B070("octagon-ckks");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 138412290;
      id v12 = v6;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Fetched initial syncing policy: %@", (uint8_t *)&v11, 0xCu);
    }

    uint64_t v10 = [*(id *)(a1 + 32) ckks];
    [v10 setCurrentSyncingPolicy:v6];
  }
}

void sub_1000F33C4(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 112));
  _Unwind_Resume(a1);
}

void sub_1000F33E8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v17 = 0;
  unsigned int v2 = [WeakRetained fetchSendingMetricsPermitted:&v17];
  id v3 = (__CFString *)v17;
  if (!v3)
  {
    id v6 = sub_10000B070("octagon-metrics");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v7 = @"Not Permitted";
      if (v2) {
        CFStringRef v7 = @"Permitted";
      }
      *(_DWORD *)long long buf = 138412290;
      CFStringRef v19 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "current metrics setting set to: %@", buf, 0xCu);
    }

    if (!v2) {
      goto LABEL_18;
    }
    id v16 = 0;
    unsigned int v8 = [WeakRetained persistSendingMetricsPermitted:0 error:&v16];
    unsigned int v9 = (__CFString *)v16;
    uint64_t v10 = v9;
    if (!v8 || v9)
    {
      int v11 = sub_10000B070("SecError");
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        CFStringRef v19 = v10;
        id v12 = "octagon-metrics: failed to persist metrics setting: %@";
        id v13 = v11;
        uint32_t v14 = 12;
        goto LABEL_16;
      }
    }
    else
    {
      int v11 = sub_10000B070("octagon-metrics");
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        id v12 = "persisted metrics setting set to not permitted";
        id v13 = v11;
        uint32_t v14 = 2;
LABEL_16:
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v12, buf, v14);
      }
    }

LABEL_18:
    id v15 = [WeakRetained checkMetricsTrigger];
    [v15 cancel];

    [WeakRetained setCheckMetricsTrigger:0];
    goto LABEL_19;
  }
  unsigned int v4 = sub_10000B070("SecError");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    CFStringRef v19 = v3;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "octagon-metrics: failed to fetch account metadata: %@", buf, 0xCu);
  }

  id v5 = [WeakRetained checkMetricsTrigger];
  [v5 trigger];

LABEL_19:
}

void sub_1000F392C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    unsigned int v4 = sub_10000B070("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 138412290;
      id v7 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "localReset returned an error: %@", (uint8_t *)&v6, 0xCu);
    }
  }
  else
  {
    id v5 = sub_10000B070("octagon");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v6) = 0;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "localReset succeeded", (uint8_t *)&v6, 2u);
    }

    unsigned int v4 = [*(id *)(a1 + 40) pairingUUID];
    [*(id *)(a1 + 32) setPairingUUID:v4];
  }

  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 48));
}

void sub_1000F49C4(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    unsigned int v4 = sub_10000B070("SecError");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 138412290;
      id v9 = v3;
      id v5 = "octagon-perform-ckserver-unreadable-data-removal: failed with error: %@";
      int v6 = v4;
      uint32_t v7 = 12;
LABEL_6:
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v5, (uint8_t *)&v8, v7);
    }
  }
  else
  {
    unsigned int v4 = sub_10000B070("octagon-perform-ckserver-unreadable-data-removal");
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(v_Block_object_dispose(&STACK[0x3F0], 8) = 0;
      id v5 = "succeeded!";
      int v6 = v4;
      uint32_t v7 = 2;
      goto LABEL_6;
    }
  }

  (*(void (**)(void, id))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), v3);
}

OTAccountMetadataClassC *__cdecl sub_1000F53C8(id a1, OTAccountMetadataClassC *a2)
{
  unsigned int v2 = a2;
  [(OTAccountMetadataClassC *)v2 setCdpState:2];

  return v2;
}

id sub_1000F5CBC(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 setAltDSID:*(void *)(a1 + 32)];

  return v3;
}

void sub_1000F5FF4(uint64_t a1)
{
  unsigned int v2 = sub_10000B070("octagon");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    id v3 = *(void **)(a1 + 32);
    *(_DWORD *)long long buf = 138412290;
    id v31 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Told of a new CK account status: %@", buf, 0xCu);
  }

  [*(id *)(a1 + 40) setCloudKitAccountInfo:*(void *)(a1 + 32)];
  if ([*(id *)(a1 + 32) accountStatus] == (id)1)
  {
    unsigned int v4 = [*(id *)(a1 + 40) activeAccount];

    if (!v4)
    {
      id v5 = [*(id *)(a1 + 40) sessionMetrics];
      id v7 = objc_alloc((Class)AAFAnalyticsEventSecurity);
      int v8 = [*(id *)(a1 + 40) activeAccount];
      id v9 = [v8 altDSID];
      uint64_t v10 = [v5 flowID];
      int v11 = [v5 deviceSessionID];
      uint64_t v12 = kSecurityRTCEventNameCloudKitAccountAvailability;
      LOBYTE(v2_Block_object_dispose(&STACK[0x3F0], 8) = [*(id *)(a1 + 40) canSendMetricsUsingAccountState:[*(id *)(a1 + 40) shouldSendMetricsForOctagon]];
      id v6 = [v7 initWithKeychainCircleMetrics:0 altDSID:v9 flowID:v10 deviceSessionID:v11 eventName:v12 testsAreEnabled:0 canSendMetrics:v28 category:kSecurityRTCEventCategoryAccountDataAccessRecovery];

      id v13 = [*(id *)(a1 + 40) accountsAdapter];
      uint32_t v14 = [*(id *)(a1 + 40) personaAdapter];
      id v15 = [*(id *)(a1 + 40) containerName];
      id v16 = [*(id *)(a1 + 40) contextID];
      id v29 = 0;
      id v17 = [v13 findAccountForCurrentThread:v14 optionalAltDSID:0 cloudkitContainerName:v15 octagonContextID:v16 error:&v29];
      id v18 = v29;
      [*(id *)(a1 + 40) setActiveAccount:v17];

      CFStringRef v19 = [*(id *)(a1 + 40) activeAccount];

      id v20 = sub_10000B070("octagon-account");
      BOOL v21 = os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT);
      if (v19)
      {
        if (v21)
        {
          BOOL v22 = [*(id *)(a1 + 40) contextID];
          unsigned __int8 v23 = [*(id *)(a1 + 40) activeAccount];
          *(_DWORD *)long long buf = 138412546;
          id v31 = v22;
          __int16 v32 = 2112;
          id v33 = v23;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Found a new account (%@): %@", buf, 0x16u);
        }
        id v20 = [*(id *)(a1 + 40) accountMetadataStore];
        uint32_t v24 = [*(id *)(a1 + 40) activeAccount];
        [v20 changeActiveAccount:v24];
      }
      else
      {
        if (!v21)
        {
LABEL_14:

          unsigned int v25 = [*(id *)(a1 + 40) activeAccount];
          +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v6 success:v25 != 0 error:v18];

          goto LABEL_15;
        }
        uint32_t v24 = [*(id *)(a1 + 40) contextID];
        *(_DWORD *)long long buf = 138412546;
        id v31 = v24;
        __int16 v32 = 2112;
        id v33 = v18;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Unable to find a current account (context %@): %@", buf, 0x16u);
      }

      goto LABEL_14;
    }
  }
  id v5 = sub_10000B070("octagon-account");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    id v6 = [*(id *)(a1 + 40) contextID];
    *(_DWORD *)long long buf = 138412290;
    id v31 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "skipping account fetch %@", buf, 0xCu);
LABEL_15:
  }
  id v26 = [*(id *)(a1 + 40) stateMachine];
  [v26 _onqueuePokeStateMachine];

  unsigned __int8 v27 = [*(id *)(a1 + 40) cloudKitAccountStateKnown];
  [v27 fulfill];
}

id sub_1000F6458(uint64_t a1, uint64_t a2)
{
  return +[SecurityAnalyticsReporterRTC sendMetricWithEvent:*(void *)(a1 + 32) success:a2 == 0 error:a2];
}

void sub_1000F73A0(_Unwind_Exception *a1)
{
  objc_destroyWeak(v4);
  objc_destroyWeak(v1);
  objc_destroyWeak(v3);
  objc_destroyWeak(v2);
  objc_destroyWeak((id *)(v5 - 128));
  _Unwind_Resume(a1);
}

void sub_1000F7400(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  unsigned int v2 = sub_10000B070("octagon-ckks");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unsigned int v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Adding flag for CKKS TLK upload", v4, 2u);
  }

  id v3 = [WeakRetained stateMachine];
  [v3 handleFlag:@"tlk_upload_needed"];
}

void sub_1000F74A0(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  unsigned int v2 = sub_10000B070("octagon-ckks");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unsigned int v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Adding flag for CKKS policy check", v4, 2u);
  }

  id v3 = [WeakRetained stateMachine];
  [v3 handleFlag:@"policy_check_needed"];
}

void sub_1000F7540(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v1 = [[OctagonPendingFlag alloc] initWithFlag:@"attempt_ucv_upgrade" conditions:3];
  unsigned int v2 = [WeakRetained stateMachine];
  [v2 handlePendingFlag:v1];
}

void sub_1000F75C4(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  unsigned int v2 = sub_10000B070("octagon-metrics");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)unsigned int v4 = 0;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Added check-on-metrics flag to the state machine", v4, 2u);
  }

  id v3 = [WeakRetained stateMachine];
  [v3 handleFlag:@"check_on_rtc_metrics"];
}

__CFString *sub_1000F787C(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    unsigned int v2 = +[NSMutableSet set];
    id v3 = v2;
    if (v1)
    {
      [v2 addObject:@"unlock"];
      v1 &= ~1uLL;
      if ((v1 & 2) == 0)
      {
LABEL_4:
        if (!v1)
        {
LABEL_6:
          uint64_t v5 = [v3 allObjects];
          id v6 = [v5 componentsJoinedByString:@","];

          goto LABEL_8;
        }
LABEL_5:
        unsigned int v4 = +[NSString stringWithFormat:@"Conditions<0x%x>", v1];
        [v3 addObject:v4];

        goto LABEL_6;
      }
    }
    else if ((v1 & 2) == 0)
    {
      goto LABEL_4;
    }
    [v3 addObject:@"network"];
    v1 &= ~2uLL;
    if (!v1) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  id v6 = @"none";
LABEL_8:

  return v6;
}

BOOL sub_1000F800C(uint64_t a1, uint64_t a2)
{
  if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) < *(void *)(a2 + OBJC_IVAR___PBDataReader__length))
  {
    while (1)
    {
      if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
      }
      char v4 = 0;
      unsigned int v5 = 0;
      unint64_t v6 = 0;
      while (1)
      {
        unint64_t v7 = *(void *)(a2 + OBJC_IVAR___PBDataReader__pos);
        if (v7 == -1 || v7 >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
          break;
        }
        char v8 = *(unsigned char *)(*(void *)(a2 + OBJC_IVAR___PBDataReader__bytes) + v7);
        *(void *)(a2 + OBJC_IVAR___PBDataReader__pos) = v7 + 1;
        v6 |= (unint64_t)(v8 & 0x7F) << v4;
        if ((v8 & 0x80) == 0) {
          goto LABEL_11;
        }
        v4 += 7;
        if (v5++ >= 9)
        {
          unint64_t v6 = 0;
          int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
          goto LABEL_13;
        }
      }
      *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) = 1;
LABEL_11:
      int v10 = *(unsigned __int8 *)(a2 + OBJC_IVAR___PBDataReader__error);
      if (*(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error)) {
        unint64_t v6 = 0;
      }
LABEL_13:
      if (v10 || (v6 & 7) == 4) {
        return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
      }
      if ((v6 >> 3) == 102) {
        break;
      }
      if ((v6 >> 3) == 101)
      {
        uint64_t v12 = PBReaderReadString();
        uint64_t v13 = 8;
LABEL_21:
        uint32_t v14 = *(void **)(a1 + v13);
        *(void *)(a1 + v13) = v12;

        goto LABEL_23;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0) {
        return 0;
      }
LABEL_23:
      if (*(void *)(a2 + OBJC_IVAR___PBDataReader__pos) >= *(void *)(a2 + OBJC_IVAR___PBDataReader__length)) {
        return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
      }
    }
    uint64_t v12 = PBReaderReadString();
    uint64_t v13 = 16;
    goto LABEL_21;
  }
  return *(unsigned char *)(a2 + OBJC_IVAR___PBDataReader__error) == 0;
}

void sub_1000F8600(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000F8624(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6 = a2;
  id v7 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v9 = +[CKKSAnalytics logger];
  [v9 logResultForEvent:@"OctagonEventPreflightVouchWithCustodianRecoveryKey" hardFailure:1 result:v7];

  if (!v6 || v7)
  {
    uint64_t v12 = sub_10000B070("SecError");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = 138412290;
      id v15 = v7;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "octagon: Error preflighting voucher using custodian recovery key: %@", (uint8_t *)&v14, 0xCu);
    }

    [WeakRetained setError:v7];
  }
  else
  {
    int v10 = sub_10000B070("octagon");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = 138412290;
      id v15 = v6;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "Preflight Custodian Recovery key ID %@ looks good to go", (uint8_t *)&v14, 0xCu);
    }

    int v11 = [WeakRetained intendedState];
    [WeakRetained setNextState:v11];
  }
  uint64_t v13 = [WeakRetained finishOp];
  [WeakRetained runBeforeGroupFinished:v13];
}

id sub_1000F8AE4(uint64_t a1, int a2, unsigned char *a3)
{
  uint64_t v3 = a2;
  unint64_t v4 = *(void *)(a1 + 40);
  if (a2 >= v4)
  {
    if (a2 - v4 < (unint64_t)[*(id *)(*(void *)(a1 + 32) + 8) count])
    {
      id v7 = [*(id *)(*(void *)(a1 + 32) + 8) objectAtIndexedSubscript:v3 - *(void *)(a1 + 40)];
      id v8 = [v7 pointerValue];

      return v8;
    }
    *a3 = 1;
  }
  return 0;
}

void sub_1000F9180(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000F91A4(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  id v11 = a2;
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v17 = +[CKKSAnalytics logger];
  [v17 logResultForEvent:@"OctagonEventVoucherWithCustodianRecoveryKey" hardFailure:1 result:v15];

  if (v15)
  {
    id v18 = sub_10000B070("SecError");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v34 = v15;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "octagon: Error preparing voucher using custodian recovery key: %@", buf, 0xCu);
    }

    [WeakRetained setError:v15];
LABEL_16:
    id v23 = [WeakRetained finishOp];
    [WeakRetained runBeforeGroupFinished:v23];
    goto LABEL_17;
  }
  CFStringRef v19 = +[CKKSAnalytics logger];
  [v19 recordRecoveredTLKMetrics:*(void *)(a1 + 32) tlkRecoveryResults:v14 uniqueTLKsRecoveredEvent:@"OACustodianUniqueTLKsRecoveredCount" totalSharesRecoveredEvent:@"OACustodianTotalTLKSharesRecoveredCount" totalRecoverableTLKSharesEvent:@"OACustodianTotalTLKSharesCount" totalRecoverableTLKsEvent:@"OACustodianUniqueTLKsWithSharesCount" totalViewsWithSharesEvent:@"OACustodianTLKUniqueViewCount"];

  [WeakRetained setVoucher:v11];
  [WeakRetained setVoucherSig:v12];
  if (![WeakRetained saveVoucher])
  {
LABEL_13:
    id v26 = sub_10000B070("octagon");
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412546;
      id v34 = v11;
      __int16 v35 = 2112;
      id v36 = v12;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Successfully vouched with a custodian recovery key: %@, %@", buf, 0x16u);
    }

    unsigned __int8 v27 = [WeakRetained intendedState];
    [WeakRetained setNextState:v27];

    goto LABEL_16;
  }
  id v20 = sub_10000B070("octagon");
  if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "Saving voucher for later use...", buf, 2u);
  }

  BOOL v21 = [WeakRetained deps];
  BOOL v22 = [v21 stateHolder];
  v29[0] = _NSConcreteStackBlock;
  v29[1] = 3221225472;
  v29[2] = sub_1000F95BC;
  void v29[3] = &unk_1002F9FF0;
  id v30 = v11;
  id v31 = v12;
  id v32 = v13;
  id v28 = 0;
  [v22 persistAccountChanges:v29 error:&v28];
  id v23 = v28;

  if (!v23)
  {

    goto LABEL_13;
  }
  uint32_t v24 = sub_10000B070("octagon");
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    id v34 = v23;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "unable to save voucher: %@", buf, 0xCu);
  }

  unsigned int v25 = [WeakRetained finishOp];
  [WeakRetained runBeforeGroupFinished:v25];

LABEL_17:
}

id sub_1000F95BC(void *a1, void *a2)
{
  id v3 = a2;
  [v3 setVoucher:a1[4]];
  [v3 setVoucherSignature:a1[5]];
  [v3 setTLKSharesPairedWithVoucher:a1[6]];

  return v3;
}

void sub_1000F9730(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000F9754(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v8 = WeakRetained;
  if (v6)
  {
    id v9 = sub_10000B070("SecError");
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v32 = v6;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "octagon: Error fetching TLKShares to recover: %@", buf, 0xCu);
    }

    [v8 setError:v6];
    int v10 = [v8 finishOp];
    [v8 runBeforeGroupFinished:v10];
  }
  else
  {
    unsigned int v25 = WeakRetained;
    int v10 = +[NSMutableArray array];
    long long v26 = 0u;
    long long v27 = 0u;
    long long v28 = 0u;
    long long v29 = 0u;
    id v24 = v5;
    id v11 = v5;
    id v12 = [v11 countByEnumeratingWithState:&v26 objects:v30 count:16];
    if (v12)
    {
      id v13 = v12;
      uint64_t v14 = *(void *)v27;
      do
      {
        for (uint64_t i = 0; i != v13; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v27 != v14) {
            objc_enumerationMutation(v11);
          }
          id v16 = *(void **)(*((void *)&v26 + 1) + 8 * i);
          id v17 = [v16 recordType];
          unsigned int v18 = [v17 isEqual:@"tlkshare"];

          if (v18)
          {
            CFStringRef v19 = [CKKSTLKShareRecord alloc];
            id v20 = [v25 deps];
            BOOL v21 = [v20 contextID];
            BOOL v22 = [(CKKSCKRecordHolder *)v19 initWithCKRecord:v16 contextID:v21];

            id v23 = [(CKKSTLKShareRecord *)v22 share];
            [v10 addObject:v23];
          }
        }
        id v13 = [v11 countByEnumeratingWithState:&v26 objects:v30 count:16];
      }
      while (v13);
    }

    id v8 = v25;
    [v25 proceedWithFilteredTLKShares:v10];
    id v6 = 0;
    id v5 = v24;
  }
}

void sub_1000F9D84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000F9DB0(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v11 = +[CKKSAnalytics logger];
  [v11 logResultForEvent:@"OctagonEventPreflightVouchWithCustodianRecoveryKey" hardFailure:1 result:v9];

  if (!v7 || v9)
  {
    id v15 = sub_10000B070("SecError");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = 138412290;
      id v18 = v9;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "octagon: Error preflighting voucher using custodian recovery key: %@", (uint8_t *)&v17, 0xCu);
    }

    [WeakRetained setError:v9];
    id v16 = [WeakRetained finishOp];
    [WeakRetained runBeforeGroupFinished:v16];
  }
  else
  {
    id v12 = sub_10000B070("octagon");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = 138412290;
      id v18 = v7;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "Custodian Recovery key ID %@ looks good to go", (uint8_t *)&v17, 0xCu);
    }

    id v13 = [WeakRetained deps];
    uint64_t v14 = [v13 ckks];
    [v14 setCurrentSyncingPolicy:v8];

    [WeakRetained proceedWithRecoveryKeyID:v7];
  }
}

void sub_1000FA4D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000FA4FC(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v11 = +[CKKSAnalytics logger];
  [v11 logResultForEvent:@"OctagonEventVoucherWithInheritanceKey" hardFailure:1 result:v9];

  if (v9)
  {
    id v12 = sub_10000B070("SecError");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v25 = v9;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "octagon-inheritor: Error recovering tlkshares: %@", buf, 0xCu);
    }

    [WeakRetained setError:v9];
    id v13 = [WeakRetained finishOp];
    [WeakRetained runBeforeGroupFinished:v13];
  }
  else
  {
    uint64_t v14 = +[CKKSAnalytics logger];
    [v14 recordRecoveredTLKMetrics:*(void *)(a1 + 32) tlkRecoveryResults:v8 uniqueTLKsRecoveredEvent:@"OAInheritanceUniqueTLKsRecoveredCount" totalSharesRecoveredEvent:@"OAInheritanceTotalTLKSharesRecoveredCount" totalRecoverableTLKSharesEvent:@"OAInheritanceTotalTLKSharesCount" totalRecoverableTLKsEvent:@"OAInheritanceUniqueTLKsWithSharesCount" totalViewsWithSharesEvent:@"OAInheritanceTLKUniqueViewCount"];

    id v15 = sub_10000B070("octagon-inheritor");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Saving tlkshares for later use...", buf, 2u);
    }

    id v16 = [WeakRetained deps];
    int v17 = [v16 stateHolder];
    v22[0] = _NSConcreteStackBlock;
    v22[1] = 3221225472;
    v22[2] = sub_1000FA858;
    v22[3] = &unk_100307118;
    id v23 = v7;
    id v21 = 0;
    [v17 persistAccountChanges:v22 error:&v21];
    id v13 = v21;

    id v18 = sub_10000B070("octagon-inheritor");
    BOOL v19 = os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT);
    if (v13)
    {
      if (v19)
      {
        *(_DWORD *)long long buf = 138412290;
        id v25 = v13;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "unable to save shares: %@", buf, 0xCu);
      }
    }
    else
    {
      if (v19)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Successfully recovered shares", buf, 2u);
      }

      id v18 = [WeakRetained intendedState];
      [WeakRetained setNextState:v18];
    }

    id v20 = [WeakRetained finishOp];
    [WeakRetained runBeforeGroupFinished:v20];
  }
}

id sub_1000FA858(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 setTLKSharesPairedWithVoucher:*(void *)(a1 + 32)];

  return v3;
}

void sub_1000FAE0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id *location)
{
  objc_destroyWeak(location);
  objc_destroyWeak((id *)(v20 - 128));
  _Block_object_dispose((const void *)(v20 - 176), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000FAE4C(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_1000FAE5C(uint64_t a1)
{
}

id sub_1000FAE64(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [v3 parsedSecureElementIdentity];
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;

  return v3;
}

void sub_1000FAEBC(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, uint64_t a8, void *a9, void *a10)
{
  id v16 = a2;
  id v17 = a3;
  id v18 = a4;
  id v19 = a5;
  id v20 = a6;
  id v59 = a7;
  id v21 = a9;
  id v22 = a10;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v24 = +[CKKSAnalytics logger];
  [v24 logResultForEvent:@"OctagonEventPrepareIdentity" hardFailure:1 result:v22];

  if (v22)
  {
    id v25 = sub_10000B070("SecError");
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v72 = v22;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "octagon-inheritor: Error preparing inheritor identity: %@", buf, 0xCu);
    }

    [WeakRetained setError:v22];
    id v26 = [WeakRetained finishOp];
    [WeakRetained runBeforeGroupFinished:v26];
    long long v27 = WeakRetained;
    long long v28 = v59;
  }
  else
  {
    long long v29 = sub_10000B070("octagon-inheritor");
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412802;
      id v72 = v16;
      __int16 v73 = 2112;
      id v74 = v17;
      __int16 v75 = 2112;
      id v76 = v18;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "Prepared: %@ %@ %@", buf, 0x20u);
    }

    [WeakRetained setPeerID:v16];
    id v58 = v17;
    [WeakRetained setPermanentInfo:v17];
    id v57 = v18;
    [WeakRetained setPermanentInfoSig:v18];
    id v56 = v19;
    [WeakRetained setStableInfo:v19];
    __int16 v61 = WeakRetained;
    id v55 = v20;
    [WeakRetained setStableInfoSig:v20];
    id v30 = sub_10000B070("octagon-inheritor");
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      id v31 = [v59 viewList];
      *(_DWORD *)long long buf = 138412546;
      id v72 = v59;
      __int16 v73 = 2112;
      id v74 = v31;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "New syncing policy: %@ views: %@", buf, 0x16u);
    }
    unsigned int v60 = +[NSMutableArray array];
    long long v66 = 0u;
    long long v67 = 0u;
    long long v68 = 0u;
    long long v69 = 0u;
    id v54 = v21;
    id v32 = v21;
    id v33 = [v32 countByEnumeratingWithState:&v66 objects:v70 count:16];
    if (v33)
    {
      id v34 = v33;
      uint64_t v35 = *(void *)v67;
      do
      {
        for (uint64_t i = 0; i != v34; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v67 != v35) {
            objc_enumerationMutation(v32);
          }
          id v37 = *(void **)(*((void *)&v66 + 1) + 8 * i);
          unsigned __int8 v38 = [v37 recordType];
          unsigned int v39 = [v38 isEqual:@"tlkshare"];

          if (v39)
          {
            unsigned __int8 v40 = [CKKSTLKShareRecord alloc];
            id v41 = [v61 deps];
            unsigned int v42 = [v41 contextID];
            unsigned int v43 = [(CKKSCKRecordHolder *)v40 initWithCKRecord:v37 contextID:v42];

            uint64_t v44 = [(CKKSTLKShareRecord *)v43 share];
            [v60 addObject:v44];
          }
        }
        id v34 = [v32 countByEnumeratingWithState:&v66 objects:v70 count:16];
      }
      while (v34);
    }

    id v45 = [v61 deps];
    id v46 = [v45 stateHolder];
    v63[0] = _NSConcreteStackBlock;
    v63[1] = 3221225472;
    v63[2] = sub_1000FB4B0;
    v63[3] = &unk_1002FAEE8;
    id v64 = v16;
    long long v28 = v59;
    id v47 = v59;
    id v65 = v47;
    id v62 = 0;
    unsigned int v48 = [v46 persistAccountChanges:v63 error:&v62];
    id v26 = v62;

    if (!v48 || v26)
    {
      id v52 = sub_10000B070("octagon-inheritor");
      if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v72 = v26;
        _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "Couldn't persist metadata: %@", buf, 0xCu);
      }

      [v61 setError:v26];
      id v53 = [v61 finishOp];
      [v61 runBeforeGroupFinished:v53];

      id v18 = v57;
      id v17 = v58;
      id v20 = v55;
      id v19 = v56;
      id v21 = v54;
      __int16 v51 = v60;
    }
    else
    {
      unsigned int v49 = [v61 deps];
      id v50 = [v49 ckks];
      [v50 setCurrentSyncingPolicy:v47];

      __int16 v51 = v60;
      [v61 proceedWithFilteredTLKShares:v60];
      id v18 = v57;
      id v17 = v58;
      id v20 = v55;
      id v19 = v56;
      id v21 = v54;
    }

    id v22 = 0;
    long long v27 = v61;
  }
}

id sub_1000FB4B0(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 setPeerID:*(void *)(a1 + 32)];
  [v3 setTrustState:2];
  [v3 setIsInheritedAccount:1];
  uint64_t v4 = [v3 tlkSharesForVouchedIdentitys];
  [v4 removeAllObjects];

  [v3 setTPSyncingPolicy:*(void *)(a1 + 40)];

  return v3;
}

CFMutableDictionaryRef sub_1000FBC38(uint64_t a1)
{
  **(void **)(a1 + 32) = _CFRuntimeRegisterClass();
  dispatch_queue_t v1 = dispatch_queue_create("SOSEngine queue", 0);
  unsigned int v2 = (void *)qword_10035CE90;
  qword_10035CE90 = (uint64_t)v1;

  CFMutableDictionaryRef result = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  qword_10035CE98 = (uint64_t)result;
  return result;
}

CFStringRef sub_1000FBCB8(void *a1)
{
  return sub_1000FBCC0(a1, 0);
}

CFStringRef sub_1000FBCC0(void *a1, const __CFDictionary *a2)
{
  CFArrayRef v4 = (const __CFArray *)a1[10];
  if (v4) {
    CFStringRef v5 = CFStringCreateByCombiningStrings(kCFAllocatorDefault, v4, @" ");
  }
  else {
    CFStringRef v5 = &stru_10030AA90;
  }
  uint64_t v6 = a1[3];
  CFDictionaryRef v7 = (const __CFDictionary *)a1[6];
  if (v7) {
    CFIndex Count = CFDictionaryGetCount(v7);
  }
  else {
    CFIndex Count = 0;
  }
  CFDictionaryRef v9 = (const __CFDictionary *)a1[7];
  if (v9) {
    CFDictionaryRef v9 = (const __CFDictionary *)CFDictionaryGetCount(v9);
  }
  CFStringRef v10 = CFStringCreateWithFormat(kCFAllocatorDefault, a2, @"<Engine %@ peers %@ MC[%d] PS[%d]>", v6, v5, Count, v9);
  if (v5) {
    CFRelease(v5);
  }
  return v10;
}

const void *sub_1000FBD88(uint64_t a1, const void *a2)
{
  if (!-[OTSOSActualAdapter sosEnabled]_0()) {
    return 0;
  }
  CFArrayRef v4 = 0;
  if (a2)
  {
    CFDictionaryRef v5 = *(const __CFDictionary **)(a1 + 48);
    if (v5)
    {
      CFStringRef Value = CFDictionaryGetValue(v5, a2);
      CFArrayRef v4 = Value;
      if (Value)
      {
        CFTypeID v7 = CFGetTypeID(Value);
        if (v7 != sub_100200AFC())
        {
          id v8 = sub_10000B070("SecError");
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            int v10 = 138412290;
            id v11 = a2;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "dropping corrupt manifest for %@ from cache", (uint8_t *)&v10, 0xCu);
          }

          CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 48), a2);
          return 0;
        }
      }
    }
  }
  return v4;
}

const void *sub_1000FBE94(uint64_t a1, const __CFDictionary *a2, const void *a3)
{
  if (!-[OTSOSActualAdapter sosEnabled]_0()) {
    return 0;
  }
  CFStringRef Value = CFDictionaryGetValue(a2, a3);
  if (!Value || (CFTypeID v7 = Value, v8 = CFGetTypeID(Value), v8 != CFDataGetTypeID())) {
    CFTypeID v7 = 0;
  }
  CFDictionaryRef v9 = sub_1000FBD88(a1, v7);
  int v10 = v9;
  if (v9) {
    CFRetain(v9);
  }
  return v10;
}

CFMutableArrayRef sub_1000FBF20(uint64_t a1, const __CFDictionary *a2, const void *a3, __CFArray *Mutable)
{
  if (!-[OTSOSActualAdapter sosEnabled]_0())
  {
    SOSCCSetSOSDisabledError();
    return 0;
  }
  CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(a2, a3);
  if (Value)
  {
    CFArrayRef v9 = Value;
    CFTypeID v10 = CFGetTypeID(Value);
    if (v10 == CFArrayGetTypeID())
    {
      CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      CFIndex Count = CFArrayGetCount(v9);
      if (Count >= 1)
      {
        CFIndex v12 = Count;
        for (CFIndex i = 0; i != v12; ++i)
        {
          CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(v9, i);
          id v15 = sub_1000FBD88(a1, ValueAtIndex);
          if (v15) {
            CFArrayAppendValue(Mutable, v15);
          }
        }
      }
      return Mutable;
    }
    if (!Mutable) {
      return Mutable;
    }
    sub_100012A40(-50, (__CFString **)Mutable, @"object %@ is not an array", v9);
    return 0;
  }

  return CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
}

void sub_1000FC074(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned char *a6)
{
  uint64_t v8 = a1[5];
  CFStringRef v9 = (const __CFString *)a1[6];
  uint64_t v11 = a1[7];
  CFTypeID v10 = (const void *)a1[8];
  if (!a3) {
    goto LABEL_11;
  }
  SOSFullPeerInfoGetPeerInfo();
  CFIndex v12 = (const void *)SOSPeerInfoCopyPubKey();
  if (v12)
  {
    id v13 = (const void *)SOSPeerInfoCopyPubKey();
    if (v13)
    {
      char v14 = SecOTRSIsForKeys();
      goto LABEL_5;
    }
  }
  else
  {
    id v13 = 0;
  }
  char v14 = 0;
LABEL_5:
  if (v12) {
    CFRelease(v12);
  }
  if (v13) {
    CFRelease(v13);
  }
  if (v14)
  {
    char v15 = 1;
    goto LABEL_27;
  }
LABEL_11:
  id v16 = sub_10000B070("coder");
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 138412290;
    CFStringRef v30 = v9;
    _os_log_debug_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEBUG, "New coder for id %@.", buf, 0xCu);
  }

  CFGetAllocator(v10);
  sub_1001FF7C8();
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(void *)(Instance + 16) = 0;
  *(void *)(Instance + 24) = 0;
  *(unsigned char *)(Instance + 32) = 0;
  *(void *)(Instance + 40) = 0;
  *(void *)(Instance + 4_Block_object_dispose(&STACK[0x3F0], 8) = 0;
  *(unsigned char *)(Instance + 56) = 0;
  if (!v10 || !v11)
  {
    id v23 = sub_10000B070("coder");
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "NULL Coder requested, no transport security", buf, 2u);
    }
    goto LABEL_26;
  }
  id v18 = (const void *)SOSFullPeerInfoCopyDeviceKey();
  if (!v18)
  {
    id v20 = 0;
    id v21 = 0;
    id v19 = 0;
    goto LABEL_35;
  }
  id v19 = (const void *)SecOTRFullIdentityCreateFromSecKeyRefSOS();
  if (!v19)
  {
    id v20 = 0;
LABEL_33:
    id v21 = 0;
    goto LABEL_35;
  }
  CFRelease(v18);
  id v20 = (const void *)SOSPeerInfoCopyPubKey();
  if (!v20)
  {
    id v18 = 0;
    goto LABEL_33;
  }
  id v21 = (const void *)SecOTRPublicIdentityCreateFromSecKeyRef();
  if (v21)
  {
    if (kCFBooleanTrue == kCFBooleanFalse) {
      uint64_t v22 = SecOTRSessionCreateFromIDAndFlags();
    }
    else {
      uint64_t v22 = SecOTRSessionCreateFromID();
    }
    *(void *)(Instance + 24) = v22;
    if (v22)
    {
      *(unsigned char *)(Instance + 32) = 0;
      *(void *)(Instance + 40) = 0;
      CFRelease(v20);
      CFRelease(v19);
      CFRelease(v21);
LABEL_26:
      CFIndex v24 = *(void *)ccsha1_di();
      CFMutableArrayRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
      CFDataSetLength(Mutable, v24);
      *(void *)(Instance + 4_Block_object_dispose(&STACK[0x3F0], 8) = Mutable;
      *(unsigned char *)(Instance + 56) = 0;
      sub_1001FFC14(Instance, 0);
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(v8 + 96), v9, (const void *)Instance);
      CFRelease((CFTypeRef)Instance);
      char v15 = 1;
      *(unsigned char *)(v8 + 105) = 1;
      goto LABEL_27;
    }
    id v18 = 0;
  }
  else
  {
    id v18 = 0;
  }
LABEL_35:
  id v26 = sub_10000B070("SecError");
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    CFStringRef v30 = @"No local error in SOSCoderCreate";
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Coder create failed: %@\n", buf, 0xCu);
  }
  long long v27 = sub_10000B070("SecError");
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412290;
    CFStringRef v30 = 0;
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "Coder create failed: %@\n", buf, 0xCu);
  }
  if (v19) {
    CFRelease(v19);
  }
  if (v21) {
    CFRelease(v21);
  }
  if (v20) {
    CFRelease(v20);
  }
  if (v18) {
    CFRelease(v18);
  }
  CFRelease((CFTypeRef)Instance);
  long long v28 = sub_10000B070("SecError");
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412546;
    CFStringRef v30 = v9;
    __int16 v31 = 2112;
    uint64_t v32 = 0;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Failed to create coder for %@: %@", buf, 0x16u);
  }

  char v15 = 0;
LABEL_27:
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = v15;
  *a6 = *(unsigned char *)(a1[5] + 105);
}

uint64_t sub_1000FC5B8(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7 = a4;
  if (-[OTSOSActualAdapter sosEnabled]_0())
  {
    uint64_t v17 = 0;
    id v18 = &v17;
    uint64_t v19 = 0x2020000000;
    char v20 = 1;
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    void v11[2] = sub_1000FC6D8;
    v11[3] = &unk_1002FA320;
    uint64_t v15 = a2;
    uint64_t v16 = a3;
    id v13 = &v17;
    uint64_t v14 = a1;
    id v12 = v7;
    unsigned int v8 = sub_1000FC9E4(a1, a3, v11);
    if (*((unsigned char *)v18 + 24)) {
      uint64_t v9 = v8;
    }
    else {
      uint64_t v9 = 0;
    }
    *((unsigned char *)v18 + 24) = v9;

    _Block_object_dispose(&v17, 8);
  }
  else
  {
    SOSCCSetSOSDisabledError();
    uint64_t v9 = 0;
  }

  return v9;
}

void sub_1000FC6C0(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

void sub_1000FC6D8(uint64_t a1)
{
  unsigned int v2 = sub_1000FCB54(*(void *)(a1 + 48), *(const void **)(a1 + 56), *(__CFArray **)(a1 + 64));
  if (v2)
  {
    id v3 = v2;
    uint64_t v5 = *(void *)(a1 + 48);
    CFArrayRef v4 = *(const void **)(a1 + 56);
    uint64_t v6 = *(CFTypeRef **)(a1 + 64);
    if (!*(unsigned char *)(v5 + 104))
    {
      uint64_t v17 = 0;
      id v18 = &v17;
      uint64_t v19 = 0x2020000000;
      char v20 = 0;
      CFDataRef v7 = (const __CFData *)(*(uint64_t (**)(void))(*(void *)(v5 + 16) + 40))();
      CFDataRef v8 = v7;
      if (v7)
      {
        CFTypeRef v9 = sub_1000FCCA0(v7, v6);
        if (v9)
        {
          CFDictionaryRef v10 = *(const __CFDictionary **)(v5 + 56);
          context[0] = _NSConcreteStackBlock;
          context[1] = 3221225472;
          context[2] = sub_1000FCD78;
          context[3] = &unk_100308BF0;
          void context[5] = v9;
          context[6] = v5;
          context[4] = &v17;
          CFDictionaryApplyFunction(v10, (CFDictionaryApplierFunction)sub_1000FE194, context);
          uint64_t v11 = sub_10000B070("coder");
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            int v12 = *((unsigned __int8 *)v18 + 24);
            *(_DWORD *)long long buf = 67109120;
            int v22 = v12;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Will force peer registration: %{BOOL}d", buf, 8u);
          }

          if (*((unsigned char *)v18 + 24))
          {
            id v13 = dispatch_get_global_queue(-32768, 0);
            dispatch_async(v13, &stru_1002FA620);
          }
          *(unsigned char *)(v5 + 104) = 1;
        }
        CFRelease(v8);
        if (v9) {
          CFRelease(v9);
        }
      }
      _Block_object_dispose(&v17, 8);
      *(unsigned char *)(v5 + 104) = 1;
    }
    CFArrayRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v5 + 96), v4);
    if (!Value || (CFTypeID v15 = CFGetTypeID(Value), v15 != sub_1001FF7C8())) {
      SOSErrorCreate();
    }
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32));
    CFRelease(v3);
  }
  else
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = SOSErrorCreate();
  }
}

void sub_1000FC9BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1000FC9E4(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = *(void *)(a1 + 16);
  v11[0] = _NSConcreteStackBlock;
  v11[1] = 3221225472;
  void v11[2] = sub_1000FCAA0;
  v11[3] = &unk_1002FA560;
  id v12 = v5;
  uint64_t v13 = a1;
  CFDataRef v7 = *(uint64_t (**)(uint64_t, uint64_t, void, uint64_t, void *))(v6 + 64);
  id v8 = v5;
  uint64_t v9 = v7(v6, a2, 0, 1, v11);

  return v9;
}

void sub_1000FCAA0(uint64_t a1, uint64_t a2, uint64_t a3)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1000FCB3C;
  block[3] = &unk_1002FA538;
  uint64_t v5 = *(void *)(a1 + 40);
  id v7 = *(id *)(a1 + 32);
  uint64_t v8 = a2;
  uint64_t v9 = a3;
  dispatch_sync(*(dispatch_queue_t *)(v5 + 112), block);
}

uint64_t sub_1000FCB3C(void *a1)
{
  return (*(uint64_t (**)(void, void, void))(a1[4] + 16))(a1[4], a1[5], a1[6]);
}

void *sub_1000FCB54(uint64_t a1, const void *a2, __CFArray *a3)
{
  CFArrayRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 56), a2);
  if (Value)
  {
    return sub_1000FDEDC(a1, a2, Value, a3);
  }
  else
  {
    uint64_t v8 = sub_10000B070("SecError");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = *(void *)(a1 + 56);
      *(_DWORD *)long long buf = 138412802;
      uint64_t v11 = a2;
      __int16 v12 = 2112;
      uint64_t v13 = v9;
      __int16 v14 = 2112;
      uint64_t v15 = a1;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "peer: %@ not found, peerMap: %@, engine: %@", buf, 0x20u);
    }

    SOSErrorCreate();
    return 0;
  }
}

CFTypeRef sub_1000FCCA0(const __CFData *a1, CFTypeRef *a2)
{
  if (!-[OTSOSActualAdapter sosEnabled]_0())
  {
    SOSCCSetSOSDisabledError();
    return 0;
  }
  CFTypeRef cf = 0;
  if (a1)
  {
    BytePtr = CFDataGetBytePtr(a1);
    CFIndex Length = CFDataGetLength(a1);
    uint64_t v6 = &BytePtr[Length];
    uint64_t v7 = sub_10000EEF8(kCFAllocatorDefault, &cf, a2, (uint64_t)BytePtr, (uint64_t)&BytePtr[Length]);
    if (v7) {
      BOOL v8 = v7 == (void)v6;
    }
    else {
      BOOL v8 = 1;
    }
    if (!v8)
    {
      char v10 = SOSErrorCreate();
      if (v10) {
        return cf;
      }
      goto LABEL_12;
    }
    if (!v7)
    {
LABEL_12:
      CFTypeRef v11 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        CFRelease(v11);
      }
    }
  }
  return cf;
}

void sub_1000FCD78(uint64_t a1, const __CFString *cf)
{
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 == CFStringGetTypeID())
    {
      if (CFStringHasSuffix(cf, @"-tomb"))
      {
        uint64_t v5 = sub_10000B070("coder");
        if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = cf;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "Skipping coder check for peer: %@", buf, 0xCu);
        }

        return;
      }
    }
  }
  CFDataRef Value = (const __CFData *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 40), cf);
  if (!Value)
  {
    char v10 = sub_10000B070("coder");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = *(void *)(a1 + 40);
      *(_DWORD *)long long buf = 138412546;
      *(void *)&uint8_t buf[4] = cf;
      __int16 v15 = 2112;
      uint64_t v16 = v11;
      __int16 v12 = "didn't find coder for peer: %@ engine dictionary: %@";
LABEL_14:
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v12, buf, 0x16u);
    }
LABEL_15:

    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
    return;
  }
  CFDataRef v7 = Value;
  CFTypeID v8 = CFGetTypeID(Value);
  if (v8 != CFDataGetTypeID())
  {
    char v10 = sub_10000B070("coder");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412546;
      *(void *)&uint8_t buf[4] = cf;
      __int16 v15 = 2112;
      uint64_t v16 = 0;
      __int16 v12 = "coder for %@ was not cf data: %@";
      goto LABEL_14;
    }
    goto LABEL_15;
  }
  sub_1001FF7C8();
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(void *)(Instance + 40) = 0;
  *(void *)(Instance + 16) = 0;
  *(void *)(Instance + 24) = 0;
  *(unsigned char *)(Instance + 32) = 0;
  *(void *)(Instance + 4_Block_object_dispose(&STACK[0x3F0], 8) = 0;
  *(unsigned char *)(Instance + 56) = 0;
  CFDataGetBytePtr(v7);
  CFDataGetLength(v7);
  *(void *)long long buf = 0xAAAAAAAAAAAAAAAALL;
  ccder_decode_tag();
  SOSErrorCreate();
  CFRelease((CFTypeRef)Instance);
  uint64_t v13 = sub_10000B070("coder");
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = cf;
    __int16 v15 = 2112;
    uint64_t v16 = 0;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Coder for '%@' failed to create: %@", buf, 0x16u);
  }
}

uint64_t sub_1000FD354(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  if (!*(void *)(a1 + 16)) {
    return 1;
  }
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDataRef v7 = Mutable;
  CFTypeID v8 = *(const void **)(a1 + 24);
  if (v8) {
    CFDictionarySetValue(Mutable, @"id", v8);
  }
  uint64_t v9 = *(const void **)(a1 + 80);
  if (v9) {
    CFDictionarySetValue(v7, @"peerIDs", v9);
  }
  char v10 = *(const void **)(a1 + 88);
  if (v10) {
    CFDictionarySetValue(v7, @"traceDate", v10);
  }
  *(void *)int valuePtr = 2;
  CFNumberRef v11 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, valuePtr);
  CFDictionarySetValue(v7, @"engine-stateVersion", v11);
  if (v11) {
    CFRelease(v11);
  }
  if (v7)
  {
    unsigned int v37 = sub_1000FD8C4(a1, a2, @"engine-state-v2", kSecAttrAccessibleAlwaysPrivate, (const __CFString *)v7, a3);
    CFRelease(v7);
  }
  else
  {
    unsigned int v37 = 0;
  }
  CFStringRef v13 = (const __CFString *)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDictionaryRef v14 = *(const __CFDictionary **)(a1 + 56);
  *(void *)int valuePtr = _NSConcreteStackBlock;
  *(void *)&valuePtr[8] = 3221225472;
  *(void *)&valuePtr[16] = sub_1000FD948;
  unsigned __int8 v40 = &unk_100308F10;
  uint64_t v41 = (uint64_t)v13;
  CFDictionaryApplyFunction(v14, (CFDictionaryApplierFunction)sub_1000FE194, valuePtr);
  if (v13)
  {
    unsigned int v15 = sub_1000FD8C4(a1, a2, @"engine-peer-states", kSecAttrAccessibleAlwaysPrivate, v13, a3);
    CFRelease(v13);
  }
  else
  {
    unsigned int v15 = 0;
  }
  CFStringRef v16 = (const __CFString *)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  *(void *)int valuePtr = _NSConcreteStackBlock;
  *(void *)&valuePtr[8] = 3221225472;
  *(void *)&valuePtr[16] = sub_1000FDA94;
  unsigned __int8 v40 = &unk_1002FA3B0;
  uint64_t v41 = (uint64_t)v16;
  sub_1000FDB00(a1, valuePtr);
  if (v16)
  {
    unsigned int v17 = sub_1000FD8C4(a1, a2, @"engine-manifest-cache", kSecAttrAccessibleAlwaysPrivate, v16, a3);
    CFRelease(v16);
  }
  else
  {
    unsigned int v17 = 0;
  }
  if (*(unsigned char *)(a1 + 105))
  {
    CFTypeRef cf = 0;
    CFStringRef v18 = (const __CFString *)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    CFDictionaryRef v19 = *(const __CFDictionary **)(a1 + 56);
    *(void *)int valuePtr = _NSConcreteStackBlock;
    *(void *)&valuePtr[8] = 3221225472;
    *(void *)&valuePtr[16] = sub_1000FDB8C;
    unsigned __int8 v40 = &unk_1002FADD8;
    uint64_t v41 = a1;
    CFStringRef v42 = v18;
    CFDictionaryApplyFunction(v19, (CFDictionaryApplierFunction)sub_1000FE194, valuePtr);
    id v23 = sub_1000298CC(v18, &cf, v20, v21, v22);
    if (v18) {
      CFRelease(v18);
    }
    if (v23 && (*(unsigned int (**)(void))(*(void *)(a1 + 16) + 96))())
    {
      *(unsigned char *)(a1 + 105) = 0;
      CFIndex v24 = sub_10000B070("coder");
      if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v36 = *(void *)(a1 + 96);
        *(_DWORD *)int valuePtr = 138412290;
        *(void *)&valuePtr[4] = v36;
        _os_log_debug_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "saved coders: %@", valuePtr, 0xCu);
      }

      int v25 = 1;
    }
    else
    {
      if (a3)
      {
        CFTypeRef v26 = cf;
        CFTypeRef cf = 0;
        if (*a3) {
          CFRelease(*a3);
        }
        *a3 = v26;
      }
      long long v27 = sub_10000B070("coder");
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v28 = *(void *)(a1 + 96);
        *(_DWORD *)int valuePtr = 138412546;
        *(void *)&valuePtr[4] = v28;
        *(_WORD *)&valuePtr[12] = 2112;
        *(void *)&valuePtr[14] = cf;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "failed to save coders: %@ (%@)", valuePtr, 0x16u);
      }

      int v25 = 0;
      int v29 = 0;
      if (!v23) {
        goto LABEL_36;
      }
    }
    CFRelease(v23);
    int v29 = v25;
LABEL_36:
    if (cf) {
      CFRelease(cf);
    }
    goto LABEL_39;
  }
  int v29 = 1;
LABEL_39:
  CFStringRef v30 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFStringRef v33 = (const __CFString *)v30;
  id v34 = *(const void **)(a1 + 24);
  if (v34) {
    CFDictionarySetValue(v30, @"id", v34);
  }
  uint64_t v35 = sub_1000298CC(v33, 0, (uint64_t)v34, v31, v32);
  if (v33) {
    CFRelease(v33);
  }
  if (v35)
  {
    (*(void (**)(void))(*(void *)(a1 + 16) + 96))();
    CFRelease(v35);
  }
  return v37 & v15 & v17 & v29;
}

__CFData *sub_1000FD8C4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const __CFString *a5, CFTypeRef *a6)
{
  CFMutableDictionaryRef result = sub_1000298CC(a5, a6, a3, a4, (uint64_t)a5);
  if (result)
  {
    CFTypeID v8 = result;
    uint64_t v9 = (*(uint64_t (**)(void))(*(void *)(a1 + 16) + 96))();
    CFRelease(v8);
    return (__CFData *)v9;
  }
  return result;
}

void sub_1000FD948(uint64_t a1, const void *a2, __CFDictionary *cf)
{
  if (!cf) {
    return;
  }
  id v3 = cf;
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 == sub_100204858())
  {
    id v3 = sub_1002058A8((uint64_t)v3);
    if (!v3)
    {
      CFDataRef v7 = sub_10000B070("engine");
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
      {
        int v8 = 138412546;
        uint64_t v9 = a2;
        __int16 v10 = 2112;
        uint64_t v11 = 0;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%@ failed to encode peer: %@", (uint8_t *)&v8, 0x16u);
      }

      return;
    }
  }
  else
  {
    CFRetain(v3);
  }
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, v3);

  CFRelease(v3);
}

void sub_1000FDA94(uint64_t a1, uint64_t a2)
{
  id v3 = *(__CFDictionary **)(a1 + 32);
  sub_10020689C(v3, *(__CFData **)(a2 + 56));
  sub_10020689C(v3, *(__CFData **)(a2 + 64));
  sub_10020689C(v3, *(__CFData **)(a2 + 72));
  sub_1002068FC(v3, *(CFTypeRef *)(a2 + 88));
  CFTypeID v4 = *(const void **)(a2 + 80);

  sub_1002068FC(v3, v4);
}

void sub_1000FDB00(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v5 = a1;
  id v6 = objc_retainBlock(v3);
  CFDictionaryRef Copy = CFDictionaryCreateCopy(0, *(CFDictionaryRef *)(a1 + 56));
  CFDictionaryApplyFunction(Copy, (CFDictionaryApplierFunction)sub_1000FDE6C, &v5);
  CFRelease(Copy);
}

void sub_1000FDB78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_1000FDB8C(uint64_t a1, const void *a2)
{
  uint64_t v4 = *(void *)(a1 + 32);
  CFDataRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v4 + 96), a2);
  if (!Value) {
    return;
  }
  uint64_t v6 = (uint64_t)Value;
  CFTypeID v7 = CFGetTypeID(Value);
  if (v7 != sub_1001FF7C8()) {
    return;
  }
  CFDataRef v23 = 0;
  CFDataRef v8 = sub_1001FFB50(v6);
  if (v8)
  {
    CFDataRef v9 = v8;
    CFDataGetLength(v8);
    uint64_t v10 = ccder_sizeof_raw_octet_string();
    uint64_t v11 = ccder_sizeof();
    CFDataRef v12 = *(const __CFData **)(v6 + 40);
    if (v12)
    {
      CFDataGetLength(v12);
      ccder_sizeof_raw_octet_string();
    }
    if (v10) {
      BOOL v13 = v11 == 0;
    }
    else {
      BOOL v13 = 1;
    }
    if (v13)
    {
LABEL_11:
      CFRelease(v9);
      goto LABEL_19;
    }
    CFIndex v14 = ccder_sizeof();
    CFRelease(v9);
    if (v14)
    {
      CFMutableArrayRef Mutable = CFDataCreateMutable(0, v14);
      if (Mutable)
      {
        CFDataRef v9 = Mutable;
        CFDataSetLength(Mutable, v14);
        CFDataGetMutableBytePtr(v9);
        CFMutableDataRef v16 = sub_1001FFB50(v6);
        if (v16)
        {
          CFDataRef v17 = v16;
          uint8_t v18 = *(unsigned char *)(v6 + 32);
          CFDataRef v19 = *(const __CFData **)(v6 + 40);
          if (v19) {
            sub_100010510(v19, (CFTypeRef *)&v23);
          }
          buf[0] = v18;
          ccder_encode_body();
          ccder_encode_tl();
          sub_100010510(v17, (CFTypeRef *)&v23);
          uint64_t v20 = ccder_encode_constructed_tl();
          CFRelease(v17);
          if (v20)
          {
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 40), a2, v9);
LABEL_24:
            CFRelease(v9);
            return;
          }
        }
        goto LABEL_11;
      }
    }
  }
LABEL_19:
  uint64_t v21 = sub_10000B070("SecError");
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412546;
    int v25 = a2;
    __int16 v26 = 2112;
    CFDataRef v27 = v23;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "failed to der encode coder for peer %@, dropping it: %@", buf, 0x16u);
  }

  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(v4 + 96), a2);
  CFDataRef v9 = v23;
  uint64_t v22 = sub_10000B070("engine");
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412546;
    int v25 = a2;
    __int16 v26 = 2112;
    CFDataRef v27 = v9;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%@ no coder for peer: %@", buf, 0x16u);
  }

  if (v9) {
    goto LABEL_24;
  }
}

void sub_1000FDE6C(const void *a1, CFTypeRef cf, uint64_t *a3)
{
  uint64_t v4 = sub_1000FDEDC(*a3, a1, cf, 0);
  if (v4)
  {
    uint64_t v5 = v4;
    (*(void (**)(void))(a3[1] + 16))();
    CFRelease(v5);
  }
}

void *sub_1000FDEDC(uint64_t a1, const void *a2, CFTypeRef cf, __CFArray *a4)
{
  if (cf && (CFTypeID v8 = CFGetTypeID(cf), v8 == sub_100204858()))
  {
    return CFRetain(cf);
  }
  else
  {
    CFArrayRef v10 = *(const __CFArray **)(a1 + 80);
    if (v10
      && (v22.size_t length = CFArrayGetCount(*(CFArrayRef *)(a1 + 80)), v22.location = 0, CFArrayContainsValue(v10, v22, a2)))
    {
      CFTypeRef cfa = 0;
      uint64_t v11 = sub_100206408(a1, a2, (const __CFDictionary *)cf, (__CFArray *)&cfa);
      if (v11) {
        goto LABEL_14;
      }
      CFDataRef v12 = sub_10000B070("SecError");
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412802;
        CFMutableDataRef v16 = a2;
        __int16 v17 = 2112;
        CFTypeRef v18 = cfa;
        __int16 v19 = 2112;
        CFTypeRef v20 = cf;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "error inflating peer: %@: %@ from state: %@", buf, 0x20u);
      }

      CFTypeRef v13 = cfa;
      if (cfa)
      {
        CFTypeRef cfa = 0;
        CFRelease(v13);
      }
      uint64_t v11 = sub_100206408(a1, a2, 0, a4);
      if (v11) {
LABEL_14:
      }
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 56), a2, v11);
    }
    else
    {
      SOSErrorCreate();
      return 0;
    }
    return v11;
  }
}

void sub_1000FE0C8(id a1)
{
  CFTypeRef cf = 0;
  if (!sub_100226BD8(&cf))
  {
    uint64_t v1 = sub_10000B070("coder");
    if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      CFTypeRef v5 = cf;
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "SOSCCProcessEnsurePeerRegistration failed with: %@", buf, 0xCu);
    }
  }
  CFTypeRef v2 = cf;
  if (cf)
  {
    CFTypeRef cf = 0;
    CFRelease(v2);
  }
}

uint64_t sub_1000FE194(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

uint64_t sub_1000FE1B0(uint64_t a1, uint64_t a2, CFTypeRef *a3)
{
  CFTypeRef cf = 0;
  CFDataRef v5 = (const __CFData *)(*(uint64_t (**)(void))(*(void *)(a1 + 16) + 40))();
  CFDataRef v6 = v5;
  if (v5)
  {
    CFDictionaryRef v7 = (const __CFDictionary *)sub_1000FCCA0(v5, &cf);
    CFDataRef v8 = (const __CFData *)(*(uint64_t (**)(void))(*(void *)(a1 + 16) + 40))();
    CFTypeRef v9 = sub_1000FCCA0(v8, &cf);
    if (v8) {
      CFRelease(v8);
    }
    CFDataRef v10 = (const __CFData *)(*(uint64_t (**)(void))(*(void *)(a1 + 16) + 40))();
    CFTypeRef v11 = sub_1000FCCA0(v10, &cf);
    if (v10) {
      CFRelease(v10);
    }
  }
  else
  {
    CFDataRef v12 = (const __CFData *)(*(uint64_t (**)(void))(*(void *)(a1 + 16) + 40))();
    if (v12)
    {
      CFDataRef v13 = v12;
      CFDictionaryRef v14 = (const __CFDictionary *)sub_1000FCCA0(v12, &cf);
      CFDictionaryRef v7 = v14;
      if (v14)
      {
        CFDataRef Value = CFDictionaryGetValue(v14, @"manifestCache");
        CFTypeRef v9 = Value;
        if (Value)
        {
          CFTypeID v16 = CFGetTypeID(Value);
          if (v16 == CFDictionaryGetTypeID()) {
            CFRetain(v9);
          }
          else {
            CFTypeRef v9 = 0;
          }
        }
        __int16 v17 = CFDictionaryGetValue(v7, @"peerState");
        CFTypeRef v11 = v17;
        if (v17)
        {
          CFTypeID v18 = CFGetTypeID(v17);
          if (v18 == CFDictionaryGetTypeID()) {
            CFRetain(v11);
          }
          else {
            CFTypeRef v11 = 0;
          }
        }
      }
      else
      {
        CFTypeRef v11 = 0;
        CFTypeRef v9 = 0;
      }
      CFRelease(v13);
    }
    else
    {
      CFTypeRef v11 = 0;
      CFTypeRef v9 = 0;
      CFDictionaryRef v7 = 0;
    }
    __int16 v19 = sub_10000B070("coder");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(buf) = 0;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Migrating from v0 engine state; dropping coders and forcing re-negotiation",
        (uint8_t *)&buf,
        2u);
    }

    _os_activity_initiate((void *)&_mh_execute_header, "CloudCircle EnsurePeerRegistration", OS_ACTIVITY_FLAG_DEFAULT, &stru_1003093E8);
    uint64_t v20 = *(void *)(a1 + 80);
    if (v20)
    {
      *(void *)&long long buf = _NSConcreteStackBlock;
      *((void *)&buf + 1) = 3221225472;
      uint64_t v44 = sub_10021C2D0;
      id v45 = &unk_1003093A8;
      uint64_t v46 = v20;
      _os_activity_initiate((void *)&_mh_execute_header, "CloudCircle RequestSyncWithPeersList", OS_ACTIVITY_FLAG_DEFAULT, &buf);
    }
  }
  if (v7)
  {
    uint64_t v21 = CFDictionaryGetValue(v7, @"id");
    if (v21 && (CFRange v22 = v21, v23 = CFGetTypeID(v21), v23 == CFStringGetTypeID()))
    {
      if (*(const void **)(a1 + 24) != v22)
      {
        CFRetain(v22);
        CFIndex v24 = *(const void **)(a1 + 24);
        if (!v24) {
          goto LABEL_32;
        }
        goto LABEL_31;
      }
    }
    else
    {
      CFIndex v24 = *(const void **)(a1 + 24);
      if (v24)
      {
        CFRange v22 = 0;
LABEL_31:
        CFRelease(v24);
LABEL_32:
        *(void *)(a1 + 24) = v22;
      }
    }
    int v25 = CFDictionaryGetValue(v7, @"peerIDs");
    if (v25 && (v26 = v25, CFTypeID v27 = CFGetTypeID(v25), v27 == CFArrayGetTypeID()))
    {
      if (*(const void **)(a1 + 80) != v26)
      {
        CFRetain(v26);
        uint64_t v28 = *(const void **)(a1 + 80);
        if (!v28) {
          goto LABEL_41;
        }
        goto LABEL_40;
      }
    }
    else
    {
      uint64_t v28 = *(const void **)(a1 + 80);
      if (v28)
      {
        __int16 v26 = 0;
LABEL_40:
        CFRelease(v28);
LABEL_41:
        *(void *)(a1 + 80) = v26;
      }
    }
    int v29 = CFDictionaryGetValue(v7, @"traceDate");
    if (v29 && (v30 = v29, CFTypeID v31 = CFGetTypeID(v29), v31 == CFDateGetTypeID()))
    {
      if (*(const void **)(a1 + 88) != v30)
      {
        CFRetain(v30);
        uint64_t v32 = *(const void **)(a1 + 88);
        if (!v32) {
          goto LABEL_50;
        }
        goto LABEL_49;
      }
    }
    else
    {
      uint64_t v32 = *(const void **)(a1 + 88);
      if (v32)
      {
        CFStringRef v30 = 0;
LABEL_49:
        CFRelease(v32);
LABEL_50:
        *(void *)(a1 + 8_Block_object_dispose(&STACK[0x3F0], 8) = v30;
      }
    }
    CFStringRef v33 = sub_10000B070("engine");
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = a1;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "%@", (uint8_t *)&buf, 0xCu);
    }
  }
  id v34 = *(const void **)(a1 + 48);
  if (v34)
  {
    *(void *)(a1 + 4_Block_object_dispose(&STACK[0x3F0], 8) = 0;
    CFRelease(v34);
  }
  if (v9)
  {
    *(void *)(a1 + 4_Block_object_dispose(&STACK[0x3F0], 8) = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    *(void *)&long long buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 3221225472;
    uint64_t v44 = sub_1000FE818;
    id v45 = &unk_100308F10;
    uint64_t v46 = a1;
    CFDictionaryApplyFunction((CFDictionaryRef)v9, (CFDictionaryApplierFunction)sub_1000FE194, &buf);
  }
  if (v11)
  {
    CFArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    CFArrayRef v36 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    CFTypeID v37 = CFGetTypeID(v11);
    if (v37 == CFDictionaryGetTypeID())
    {
      *(void *)&long long buf = _NSConcreteStackBlock;
      *((void *)&buf + 1) = 3221225472;
      uint64_t v44 = sub_1000FE8B0;
      id v45 = &unk_100308F10;
      uint64_t v46 = a1;
      CFDictionaryApplyFunction((CFDictionaryRef)v11, (CFDictionaryApplierFunction)sub_1000FE194, &buf);
    }
    sub_1000FEAA8(a1, (uint64_t)v36, (uint64_t)Mutable);
    sub_1000FEBD8(a1, *(CFTypeRef *)(a1 + 24), v36, Mutable);
    if (v36) {
      CFRelease(v36);
    }
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
  if (v11) {
    BOOL v38 = v7 == 0;
  }
  else {
    BOOL v38 = 1;
  }
  uint64_t v39 = !v38;
  if (v6) {
    CFRelease(v6);
  }
  if (v7) {
    CFRelease(v7);
  }
  if (v9) {
    CFRelease(v9);
  }
  if (v11 && (CFRelease(v11), v39))
  {
    CFTypeRef v40 = cf;
  }
  else
  {
    CFTypeRef v40 = cf;
    if (a3)
    {
      *a3 = cf;
      return v39;
    }
  }
  if (v40)
  {
    CFTypeRef cf = 0;
    CFRelease(v40);
  }
  return v39;
}

void sub_1000FE818(uint64_t a1, const void *a2, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == CFDataGetTypeID())
    {
      CFDictionaryRef v7 = (const void *)sub_100200FE0((const __CFData *)cf, 0);
      if (v7)
      {
        CFDataRef v8 = v7;
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(a1 + 32) + 48), a2, v7);
        CFRelease(v8);
      }
    }
  }
}

void sub_1000FE8B0(uint64_t a1, const void *a2, const __CFData *a3)
{
  CFDataRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 32) + 56), a2);
  if (Value && (uint64_t v7 = (uint64_t)Value, v8 = CFGetTypeID(Value), v8 == sub_100204858()))
  {
    CFTypeRef cf = 0;
    if (!sub_10020610C(v7, *(void *)(a1 + 32), a3, (__CFArray *)&cf))
    {
      CFIndex Length = CFDataGetLength(a3);
      CFArrayRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 2 * Length);
      BytePtr = CFDataGetBytePtr(a3);
      CFIndex v12 = CFDataGetLength(a3);
      if (v12 >= 1)
      {
        CFIndex v13 = v12;
        do
        {
          unsigned int v14 = *BytePtr++;
          CFStringAppendFormat(Mutable, 0, @"%02X", v14);
          --v13;
        }
        while (v13);
      }
      unsigned int v15 = sub_10000B070("SecError");
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412802;
        uint64_t v20 = a2;
        __int16 v21 = 2112;
        CFTypeRef v22 = cf;
        __int16 v23 = 2112;
        CFIndex v24 = Mutable;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "peer: %@: bad state: %@ in engine state: %@", buf, 0x20u);
      }

      if (Mutable) {
        CFRelease(Mutable);
      }
      CFTypeRef v16 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        CFRelease(v16);
      }
    }
  }
  else
  {
    __int16 v17 = *(__CFDictionary **)(*(void *)(a1 + 32) + 56);
    CFDictionarySetValue(v17, a2, a3);
  }
}

void sub_1000FEAA8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  CFArrayRef v6 = *(const __CFArray **)(a1 + 80);
  if (v6)
  {
    unint64_t Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 80));
    if (Count >> 61)
    {
      CFArrayRef v6 = 0;
    }
    else
    {
      CFIndex v8 = Count;
      CFTypeRef v9 = (const void **)malloc_type_malloc(8 * Count, 0xC0040B8AA526DuLL);
      v13.id location = 0;
      v13.size_t length = v8;
      CFArrayGetValues(v6, v13, v9);
      CFAllocatorRef v10 = CFGetAllocator(v6);
      CFArrayRef v6 = CFSetCreate(v10, v9, v8, &kCFTypeSetCallBacks);
      free(v9);
    }
  }
  CFDictionaryRef v11 = *(const __CFDictionary **)(a1 + 56);
  context[0] = _NSConcreteStackBlock;
  context[1] = 3221225472;
  context[2] = sub_1001002D8;
  context[3] = &unk_1002FA3D0;
  context[4] = v6;
  void context[5] = a2;
  context[6] = a3;
  CFDictionaryApplyFunction(v11, (CFDictionaryApplierFunction)sub_1000FE194, context);
  if (v6) {
    CFRelease(v6);
  }
}

void sub_1000FEBD8(uint64_t a1, CFTypeRef a2, const __CFArray *a3, const __CFArray *a4)
{
  CFSetRef v20 = 0;
  __int16 v21 = 0;
  uint64_t v19 = 0;
  MutableCFDictionaryRef Copy = CFStringCreateMutableCopy(kCFAllocatorDefault, 0, @"me");
  if (a2) {
    a2 = sub_100204574(a2, (uint64_t *)&v20, &v19, &v21);
  }
  if (MutableCopy)
  {
    *(void *)&long long buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 3221225472;
    __int16 v23 = sub_1000FEEC4;
    CFIndex v24 = &unk_100307FB8;
    int v25 = MutableCopy;
    CFTypeRef v26 = a2;
    sub_100025B70(v20, (uint64_t)&buf);
  }
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (*(unsigned char *)(a1 + 104))
  {
    CFTypeRef v10 = *(CFTypeRef *)(a1 + 24);
    if (a2 && v10)
    {
      if (!CFEqual(a2, v10)) {
        goto LABEL_16;
      }
    }
    else if (a2 != v10)
    {
LABEL_16:
      *(unsigned char *)(a1 + 105) = 1;
      goto LABEL_17;
    }
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 3221225472;
    void v18[2] = sub_1000FEEFC;
    v18[3] = &unk_100308DB0;
    void v18[4] = a1;
    v18[5] = Mutable;
    CFDictionaryRef v11 = objc_retainBlock(v18);
    CFIndex v12 = v11;
    if (a3)
    {
      CFRange v13 = v11;
      v27.size_t length = CFArrayGetCount(a3);
      v27.id location = 0;
      CFArrayApplyFunction(a3, v27, (CFArrayApplierFunction)sub_1001002C0, v13);
    }
    if (a4)
    {
      id v14 = v12;
      v28.size_t length = CFArrayGetCount(a4);
      v28.id location = 0;
      CFArrayApplyFunction(a4, v28, (CFArrayApplierFunction)sub_1001002C0, v14);
    }
    goto LABEL_16;
  }
LABEL_17:
  CFTypeRef v15 = *(CFTypeRef *)(a1 + 24);
  if (v15 != a2)
  {
    if (!a2 || (CFRetain(a2), (CFTypeRef v15 = *(CFTypeRef *)(a1 + 24)) != 0)) {
      CFRelease(v15);
    }
    *(void *)(a1 + 24) = a2;
  }
  CFTypeRef v16 = *(const void **)(a1 + 96);
  if (v16) {
    CFRelease(v16);
  }
  *(void *)(a1 + 96) = Mutable;
  sub_1000FEF74(a1, a3, a4, MutableCopy);
  __int16 v17 = sub_10000B070("engine");
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = MutableCopy;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%@", (uint8_t *)&buf, 0xCu);
  }

  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
}

void sub_1000FEEC4(uint64_t a1, uint64_t a2)
{
}

void sub_1000FEEFC(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = sub_100204574(cf, 0, 0, 0);
  if (v3)
  {
    uint64_t v4 = v3;
    CFDataRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 32) + 96), v3);
    if (Value)
    {
      CFArrayRef v6 = Value;
      uint64_t v7 = *(__CFDictionary **)(a1 + 40);
      CFDictionarySetValue(v7, v4, v6);
    }
  }
}

void sub_1000FEF74(uint64_t a1, const __CFArray *a2, const __CFArray *a3, __CFString *a4)
{
  CFMutableDictionaryRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  CFDictionaryRef theDict = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDictionaryRef v61 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (*(void *)(a1 + 24))
  {
    CFArrayRef v6 = (const void *)kSOSViewKeychainV0_tomb;
    CFDataRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 56), kSOSViewKeychainV0_tomb);
    if (Value && (v15 = Value, CFTypeID v16 = CFGetTypeID(Value), v16 == sub_100204858()))
    {
      __int16 v17 = (const void *)*((void *)v15 + 14);
      if (v17) {
        CFRetain(*((CFTypeRef *)v15 + 14));
      }
    }
    else
    {
      CFTypeRef cf = 0;
      CFTypeID v18 = sub_1000FF7EC(kCFAllocatorDefault, v8, v9, v10, v11, v12, v13, v14, (void *)kSecAttrAccessGroup, @"com.apple.sbd");
      __int16 v17 = (const void *)(*(uint64_t (**)(void))(*(void *)(a1 + 16) + 48))();
      if (v18) {
        CFRelease(v18);
      }
      if (!v17)
      {
        uint64_t v19 = sub_10000B070("engine");
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(buf) = 138412290;
          *(void *)((char *)&buf + 4) = cf;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "No keybag found for v0 backup peer: %@", (uint8_t *)&buf, 0xCu);
        }
      }
    }
    V0BackupViewSet = (void *)SOSViewsGetV0BackupViewSet();
    sub_1000FF870(a1, v6, V0BackupViewSet, v17, v61, theDict);
    if (v17) {
      CFRelease(v17);
    }
    CFDictionaryRef v21 = *(const __CFDictionary **)(a1 + 64);
    V0BackupBagViewSet = (void *)SOSViewsGetV0BackupBagViewSet();
    uint64_t v23 = sub_1000FF9D4(v21, v61, V0BackupBagViewSet);
    CFArrayAppendValue(*(CFMutableArrayRef *)(v23 + 24), &stru_1002FA430);
  }
  if (a2 && CFArrayGetCount(a2))
  {
    if (a4) {
      CFStringAppend(a4, @" trusted");
    }
    CFIndex Count = CFArrayGetCount(a2);
    if (Count >= 1)
    {
      for (CFIndex i = 0; i != Count; ++i)
      {
        CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(a2, i);
        CFSetRef v70 = 0;
        id v65 = 0;
        CFTypeRef v27 = sub_100204574(ValueAtIndex, (uint64_t *)&v70, &v65, 0);
        CFArrayAppendValue(Mutable, v27);
        if (a4)
        {
          *(void *)&long long buf = _NSConcreteStackBlock;
          *((void *)&buf + 1) = 3221225472;
          id v72 = sub_1000FEEC4;
          __int16 v73 = &unk_100307FB8;
          p_isa = (CFTypeRef *)&a4->isa;
          CFTypeRef v75 = v27;
          sub_100025B70(v70, (uint64_t)&buf);
        }
        CFSetRef V0ViewSet = v70;
        if (!v70)
        {
          CFSetRef V0ViewSet = (const __CFSet *)SOSViewsGetV0ViewSet();
          CFSetRef v70 = V0ViewSet;
        }
        if (v65)
        {
          sub_1000FF870(a1, v27, V0ViewSet, v65, v61, theDict);
        }
        else
        {
          int v29 = (__CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 56), v27);
          CFDictionaryRef v35 = sub_10020471C(v29, V0ViewSet, 0, v30, v31, v32, v33, v34);
          if (v35)
          {
            uint64_t v36 = sub_1000FF9D4(*(const __CFDictionary **)(a1 + 64), v61, V0ViewSet);
            CFTypeID v37 = CFGetTypeID(v35);
            if (v37 == CFDictionaryGetTypeID())
            {
              p_long long buf = (CFTypeRef *)&buf;
              *(void *)&long long buf = _NSConcreteStackBlock;
              *((void *)&buf + 1) = 3221225472;
              uint64_t v39 = sub_1000FFB5C;
              CFDictionaryRef v40 = (CFDictionaryRef)v27;
            }
            else
            {
              p_long long buf = &cf;
              CFTypeRef cf = _NSConcreteStackBlock;
              p_CFTypeRef cf = 3221225472;
              uint64_t v39 = sub_1000FFC94;
              CFDictionaryRef v40 = v35;
            }
            p_buf[2] = v39;
            p_buf[3] = &unk_1002FA450;
            p_uint8_t buf[4] = v40;
            uint64_t v41 = objc_retainBlock(p_buf);
            CFStringRef v42 = objc_retainBlock(v41);
            CFArrayAppendValue(*(CFMutableArrayRef *)(v36 + 32), v42);
            CFDictionarySetValue(theDict, v27, v35);
            CFRelease(v35);
          }
        }
      }
    }
  }
  if (a3 && CFArrayGetCount(a3))
  {
    if (a4) {
      CFStringAppend(a4, @" untrusted");
    }
    CFIndex v43 = CFArrayGetCount(a3);
    if (v43 >= 1)
    {
      for (CFIndex j = 0; j != v43; ++j)
      {
        id v45 = CFArrayGetValueAtIndex(a3, j);
        CFSetRef v70 = 0;
        CFTypeRef v46 = sub_100204574(v45, (uint64_t *)&v70, 0, 0);
        if (a4)
        {
          *(void *)&long long buf = _NSConcreteStackBlock;
          *((void *)&buf + 1) = 3221225472;
          id v72 = sub_1000FEEC4;
          __int16 v73 = &unk_100307FB8;
          p_isa = (CFTypeRef *)&a4->isa;
          CFTypeRef v75 = v46;
          sub_100025B70(v70, (uint64_t)&buf);
        }
        if (v70)
        {
          CFSetRef v47 = 0;
        }
        else
        {
          CFSetRef v47 = CFSetCreate(kCFAllocatorDefault, 0, 0, &kCFTypeSetCallBacks);
          CFSetRef v70 = v47;
        }
        MutableCFDictionaryRef Copy = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 56), v46);
        CFSetRef v49 = v70;
        if (!v70) {
          sub_10002BBA0(@"Execution has encountered an unexpected state", 0x53C0000Eu);
        }
        if (MutableCopy)
        {
          CFTypeID v50 = CFGetTypeID(MutableCopy);
          if (v50 == sub_100204858())
          {
            sub_1002048F0((uint64_t)MutableCopy, v49);
            MutableCFDictionaryRef Copy = sub_1002058A8((uint64_t)MutableCopy);
          }
          else
          {
            CFTypeID v51 = CFGetTypeID(MutableCopy);
            if (v51 == CFDictionaryGetTypeID())
            {
              id v52 = CFDictionaryGetValue((CFDictionaryRef)MutableCopy, @"views");
              MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, (CFDictionaryRef)MutableCopy);
              CFDictionarySetValue((CFMutableDictionaryRef)MutableCopy, @"views", v49);
              if (v52)
              {
                CFTypeRef cf = 0;
                p_CFTypeRef cf = (uint64_t)&cf;
                uint64_t v68 = 0x2020000000;
                char v69 = 1;
                *(void *)&long long buf = _NSConcreteStackBlock;
                *((void *)&buf + 1) = 3221225472;
                id v72 = sub_100205474;
                __int16 v73 = &unk_1003087F0;
                p_isa = &cf;
                CFTypeRef v75 = v52;
                CFSetApplyFunction(v49, (CFSetApplierFunction)sub_1002054AC, &buf);
                int v53 = *(unsigned __int8 *)(p_cf + 24);
                _Block_object_dispose(&cf, 8);
                if (!v53) {
                  CFDictionarySetValue((CFMutableDictionaryRef)MutableCopy, @"has-been-in-sync", kCFBooleanFalse);
                }
              }
            }
            else
            {
              MutableCFDictionaryRef Copy = 0;
            }
          }
        }
        if (v47) {
          CFRelease(v47);
        }
        if (MutableCopy)
        {
          CFDictionarySetValue(theDict, v46, MutableCopy);
          CFRelease(MutableCopy);
        }
      }
    }
  }
  id v54 = *(const void **)(a1 + 80);
  if (v54) {
    CFRelease(v54);
  }
  *(void *)(a1 + 80) = Mutable;
  id v55 = *(const void **)(a1 + 56);
  if (v55) {
    CFRelease(v55);
  }
  *(void *)(a1 + 56) = theDict;
  id v56 = *(const void **)(a1 + 64);
  if (v56) {
    CFRelease(v56);
  }
  *(void *)(a1 + 64) = v61;
  CFMutableDictionaryRef v57 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDictionaryRef v58 = *(const __CFDictionary **)(a1 + 64);
  *(void *)&long long buf = _NSConcreteStackBlock;
  *((void *)&buf + 1) = 3221225472;
  id v72 = sub_1000FFCC4;
  __int16 v73 = &unk_100308F10;
  p_isa = (CFTypeRef *)v57;
  CFDictionaryApplyFunction(v58, (CFDictionaryApplierFunction)sub_1000FE194, &buf);
  id v59 = *(const void **)(a1 + 72);
  if (v59) {
    CFRelease(v59);
  }
  *(void *)(a1 + 72) = v57;
}

void sub_1000FF7CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
}

__CFDictionary *sub_1000FF7EC(const __CFAllocator *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *key, uint64_t a10)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  int v14 = (const void **)&a10;
  int v11 = key;
  if (key)
  {
    do
    {
      CFDictionarySetValue(Mutable, v11, *v14);
      int v12 = v14 + 1;
      v14 += 2;
      int v11 = *v12;
    }
    while (*v12);
  }
  return Mutable;
}

void sub_1000FF870(uint64_t a1, const void *a2, void *a3, const void *a4, const __CFDictionary *a5, __CFDictionary *a6)
{
  CFDataRef Value = (__CFDictionary *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 56), a2);
  CFDictionaryRef v18 = sub_10020471C(Value, a3, a4, v13, v14, v15, v16, v17);
  if (v18)
  {
    CFDictionaryRef v19 = v18;
    CFTypeID v20 = CFGetTypeID(v18);
    if (v20 == CFDictionaryGetTypeID())
    {
      CFDictionaryRef v21 = sub_100206408(a1, a2, v19, 0);
      CFRelease(v19);
      if (!Value) {
        sub_100204BB4((uint64_t)v21);
      }
    }
    else
    {
      CFDictionaryRef v21 = v19;
    }
    CFDictionarySetValue(a6, a2, v21);
    CFRelease(v21);
    if (a4)
    {
      uint64_t v22 = sub_1000FF9D4(*(const __CFDictionary **)(a1 + 64), a5, a3);
      v25[0] = _NSConcreteStackBlock;
      v25[1] = 3221225472;
      v25[2] = sub_1001000B4;
      v25[3] = &unk_1002FA3F0;
      v25[4] = v21;
      uint64_t v23 = objc_retainBlock(v25);
      id v24 = [v23 copy];
      CFArrayAppendValue(*(CFMutableArrayRef *)(v22 + 24), v24);
    }
  }
}

uint64_t sub_1000FF9D4(const __CFDictionary *a1, CFDictionaryRef theDict, void *key)
{
  uint64_t Value = (uint64_t)CFDictionaryGetValue(theDict, key);
  if (!Value)
  {
    uint64_t v7 = (CFMutableArrayRef *)CFDictionaryGetValue(a1, key);
    if (v7)
    {
      uint64_t Value = (uint64_t)v7;
      CFArrayRemoveAllValues(v7[3]);
      CFArrayRemoveAllValues(*(CFMutableArrayRef *)(Value + 32));
      int v8 = theDict;
      int v9 = key;
      int v10 = (const void *)Value;
    }
    else
    {
      block[0] = _NSConcreteStackBlock;
      block[1] = 0x40000000;
      block[2] = sub_1000B3DAC;
      block[3] = &unk_1002F9068;
      void block[4] = &qword_10035CE38;
      if (qword_10035CE30 != -1) {
        dispatch_once(&qword_10035CE30, block);
      }
      uint64_t Value = _CFRuntimeCreateInstance();
      if (Value)
      {
        *(void *)(Value + 24) = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        *(void *)(Value + 32) = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        CFDictionarySetValue(theDict, key, (const void *)Value);
        CFRelease((CFTypeRef)Value);
        return Value;
      }
      int v8 = theDict;
      int v9 = key;
      int v10 = 0;
    }
    CFDictionarySetValue(v8, v9, v10);
  }
  return Value;
}

BOOL sub_1000FFB5C(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, CFDataRef *a8, CFTypeRef *a9)
{
  CFDictionaryRef v19 = 0;
  int v13 = sub_1000FCB54(a3, *(const void **)(a1 + 32), (__CFArray *)&v19);
  BOOL v14 = v13 != 0;
  if (v13)
  {
    int v15 = v13;
    sub_100206984(v13, a5, a7, a8, a9);
  }
  else
  {
    int v16 = sub_10000B070("SecError");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = *(void *)(a1 + 32);
      *(_DWORD *)long long buf = 138412546;
      uint64_t v21 = v17;
      __int16 v22 = 2112;
      uint64_t v23 = v19;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%@: peer failed to inflate: %@", buf, 0x16u);
    }

    int v15 = v19;
    if (!v19) {
      return 0;
    }
  }
  CFRelease(v15);
  return v14;
}

uint64_t sub_1000FFC94(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, CFDataRef *a8, CFTypeRef *a9)
{
  return 1;
}

void sub_1000FFCC4(uint64_t a1, CFSetRef theSet, uint64_t a3)
{
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 3221225472;
  v3[2] = sub_1000FFD48;
  v3[3] = &unk_100308DB0;
  void v3[4] = *(void *)(a1 + 32);
  void v3[5] = a3;
  CFSetApplyFunction(theSet, (CFSetApplierFunction)sub_1001002C0, v3);
}

void sub_1000FFD48(uint64_t a1, const void *a2)
{
  xpc_object_t value = 0;
  if (CFDictionaryGetValueIfPresent(*(CFDictionaryRef *)(a1 + 32), a2, (const void **)&value))
  {
    if (value)
    {
      CFTypeID v4 = CFGetTypeID(value);
      CFTypeID TypeID = CFSetGetTypeID();
      CFArrayRef v6 = value;
      if (v4 == TypeID)
      {
        CFSetAddValue((CFMutableSetRef)value, *(const void **)(a1 + 40));
        return;
      }
    }
    else
    {
      CFArrayRef v6 = 0;
    }
    if (!CFEqual(*(CFTypeRef *)(a1 + 40), v6))
    {
      CFMutableDictionaryRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
      CFSetAddValue(Mutable, value);
      CFSetAddValue(Mutable, *(const void **)(a1 + 40));
      CFDictionaryReplaceValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, Mutable);
      CFRelease(Mutable);
    }
  }
  else
  {
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, *(const void **)(a1 + 40));
  }
}

BOOL sub_1000FFE30(id a1, __OpaqueSOSChangeTracker *a2, __OpaqueSOSEngine *a3, __OpaqueSOSTransaction *a4, unint64_t a5, unint64_t a6, __CFArray *a7, __CFError **a8)
{
  CFIndex Count = CFArrayGetCount(a7);
  if (Count >= 1)
  {
    CFIndex v10 = Count;
    CFIndex v11 = 0;
    CFTypeRef v26 = (const void *)kSOSViewKeychainV0_tomb;
    do
    {
      CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(a7, v11);
      CFTypeID v13 = CFGetTypeID(ValueAtIndex);
      if (v13 == CFArrayGetTypeID())
      {
        if (CFArrayGetCount((CFArrayRef)ValueAtIndex) != 1) {
          sub_10002BBA0(@"Execution has encountered an unexpected state", 0x53C0000Eu);
        }
        BOOL v14 = CFArrayGetValueAtIndex((CFArrayRef)ValueAtIndex, 0);
        CFDataRef ValueAtIndex = 0;
        if (!v14)
        {
LABEL_10:
          int v16 = 0;
          goto LABEL_11;
        }
      }
      else
      {
        BOOL v14 = ValueAtIndex;
        if (!ValueAtIndex) {
          goto LABEL_10;
        }
      }
      CFTypeID v15 = CFGetTypeID(v14);
      if (v15 == CFDataGetTypeID()) {
        goto LABEL_29;
      }
      int v16 = v14;
LABEL_11:
      uint64_t v17 = sub_100119CB8(v16, kSecAttrService);
      if (v17 && CFEqual(v17, @"SecureBackupService"))
      {
        CFStringRef v18 = (const __CFString *)sub_100119CB8(v14, kSecAttrAccessible);
        if (v18 && kSecAttrAccessibleWhenUnlocked)
        {
          if (CFEqual(v18, kSecAttrAccessibleWhenUnlocked)) {
            goto LABEL_18;
          }
        }
        else if (v18 == kSecAttrAccessibleWhenUnlocked)
        {
LABEL_18:
          CFDictionaryRef v19 = sub_100119CB8(v14, kSecAttrAccount);
          if (v19 && CFEqual(v19, @"SecureBackupPublicKeybag"))
          {
            CFTypeID v20 = sub_1000FCB54((uint64_t)a3, v26, 0);
            if (ValueAtIndex) {
              uint64_t v21 = sub_100118CF8(ValueAtIndex, (uint64_t)&off_1002FC058, 0);
            }
            else {
              uint64_t v21 = 0;
            }
            uint64_t v22 = v20[14];
            sub_100204A08((uint64_t)v20, v21);
            if (!v22) {
              sub_100204BB4((uint64_t)v20);
            }
            CFRelease(v20);
            CFArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
            CFArrayRef v24 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
            sub_1000FEAA8((uint64_t)a3, (uint64_t)v24, (uint64_t)Mutable);
            sub_1000FEF74((uint64_t)a3, v24, Mutable, 0);
            if (v24) {
              CFRelease(v24);
            }
            if (Mutable) {
              CFRelease(Mutable);
            }
          }
        }
      }
LABEL_29:
      ++v11;
    }
    while (v10 != v11);
  }
  return 1;
}

BOOL sub_1001000B4(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, CFTypeRef *a8)
{
  uint64_t v11 = *(void *)(a1 + 32);
  if (-[OTSOSActualAdapter sosEnabled]_0()) {
    uint64_t v12 = *(void *)(a3 + 16);
  }
  else {
    uint64_t v12 = 0;
  }
  uint64_t v19 = 0;
  CFTypeID v20 = &v19;
  uint64_t v21 = 0x2020000000;
  char v22 = 1;
  if (*(unsigned char *)(v11 + 48) && (sub_100204FC8(v11, a8) & 1) == 0)
  {
    *((unsigned char *)v20 + 24) = 0;
LABEL_12:
    uint64_t v24 = *(void *)(v11 + 16);
    int v16 = +[NSArray arrayWithObjects:&v24 count:1];
    activity_block[0] = _NSConcreteStackBlock;
    activity_block[1] = 3221225472;
    activity_block[2] = sub_10022802C;
    activity_block[3] = &unk_1003093A8;
    activity_void block[4] = v16;
    _os_activity_initiate((void *)&_mh_execute_header, "CloudCircle SOSCCRequestSyncWithBackupPeerList", OS_ACTIVITY_FLAG_DEFAULT, activity_block);

    BOOL v15 = *((unsigned char *)v20 + 24) != 0;
    goto LABEL_13;
  }
  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472;
  void v18[2] = sub_100206C78;
  v18[3] = &unk_1003087C8;
  void v18[4] = &v19;
  v18[5] = a7;
  void v18[6] = v12;
  v18[7] = v11;
  v18[8] = a8;
  BOOL v13 = sub_100205E7C(v11, a8, v18);
  if (*((unsigned char *)v20 + 24)) {
    BOOL v14 = v13;
  }
  else {
    BOOL v14 = 0;
  }
  *((unsigned char *)v20 + 24) = v14;
  if (!v14) {
    goto LABEL_12;
  }
  BOOL v15 = 1;
LABEL_13:
  _Block_object_dispose(&v19, 8);
  return v15;
}

void sub_10010029C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
}

uint64_t sub_1001002C0(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

void sub_1001002D8(const __CFSet **a1, const __CFDictionary *cf1, uint64_t *cf)
{
  if (cf)
  {
    CFTypeID v6 = CFGetTypeID(cf);
    if (v6 == sub_100204858())
    {
      uint64_t v7 = cf[3];
      int v8 = (const void *)cf[14];
      CFDictionaryRef v9 = cf1;
LABEL_10:
      CFDictionaryRef v10 = sub_100204420(v9, v7, (uint64_t)v8);
      goto LABEL_11;
    }
  }
  if (!cf1 || !kSOSViewKeychainV0_tomb)
  {
    if ((const __CFDictionary *)kSOSViewKeychainV0_tomb == cf1) {
      goto LABEL_7;
    }
LABEL_9:
    uint64_t Value = CFDictionaryGetValue((CFDictionaryRef)cf, @"views");
    int v8 = CFDictionaryGetValue((CFDictionaryRef)cf, @"keybag");
    CFDictionaryRef v9 = cf1;
    uint64_t v7 = (uint64_t)Value;
    goto LABEL_10;
  }
  if (!CFEqual(cf1, kSOSViewKeychainV0_tomb)) {
    goto LABEL_9;
  }
LABEL_7:
  CFDictionaryRef v10 = 0;
LABEL_11:
  CFSetRef v12 = a1[4];
  if (v12 && CFSetContainsValue(v12, cf1)) {
    goto LABEL_16;
  }
  if (!cf1 || !kSOSViewKeychainV0_tomb)
  {
    if ((const __CFDictionary *)kSOSViewKeychainV0_tomb == cf1) {
      goto LABEL_16;
    }
LABEL_19:
    CFArrayAppendValue(a1[6], cf1);
    if (!v10) {
      return;
    }
    goto LABEL_20;
  }
  if (!CFEqual(cf1, kSOSViewKeychainV0_tomb)) {
    goto LABEL_19;
  }
LABEL_16:
  if (!v10) {
    return;
  }
  CFArrayAppendValue(a1[5], v10);
LABEL_20:

  CFRelease(v10);
}

CFTypeRef sub_100100424(uint64_t a1, uint64_t a2)
{
  if (-[OTSOSActualAdapter sosEnabled]_0())
  {
    CFTypeID v4 = *(const void **)(a2 + 24);
    return sub_100100494(a1, v4);
  }
  else
  {
    SOSCCSetSOSDisabledError();
    return 0;
  }
}

CFTypeRef sub_100100494(uint64_t a1, const void *a2)
{
  uint64_t Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 64), a2);
  if (Value)
  {
    CFTypeID v4 = Value;
    CFRetain(Value);
    CFDataRef v5 = (const void *)v4[2];
    if (v5)
    {
      CFTypeRef v6 = CFRetain(v5);
      if (v6)
      {
LABEL_12:
        CFRelease(v4);
        return v6;
      }
    }
    else
    {
      SOSErrorCreate();
    }
    CFTypeRef v6 = (CFTypeRef)(*(uint64_t (**)(void))(*(void *)(a1 + 16) + 24))();
    CFTypeRef v7 = (CFTypeRef)v4[2];
    if (v7 != v6)
    {
      if (!v6 || (CFRetain(v6), (CFTypeRef v7 = (CFTypeRef)v4[2]) != 0)) {
        CFRelease(v7);
      }
      v4[2] = v6;
    }
    goto LABEL_12;
  }
  SOSErrorCreate();
  return 0;
}

void sub_100100588(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6 = *(void *)(a1 + 32);
  CFTypeRef v7 = *(NSObject **)(v6 + 112);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100100604;
  block[3] = &unk_1002FA470;
  void block[4] = v6;
  void block[5] = a3;
  void block[6] = a4;
  block[7] = a5;
  block[8] = a6;
  dispatch_sync(v7, block);
}

void sub_100100604(uint64_t a1)
{
  if (-[OTSOSActualAdapter sosEnabled]_0())
  {
    CFTypeRef cf = 0;
    if ((sub_100100734(*(void *)(a1 + 32), *(void *)(a1 + 40), *(void *)(a1 + 48), *(void *)(a1 + 56), *(const __CFArray **)(a1 + 64), &cf) & 1) == 0)
    {
      CFTypeRef v2 = sub_10000B070("SecError");
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        CFTypeRef v6 = cf;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "updateChanged failed: %@", buf, 0xCu);
      }
    }
    if (cf) {
      CFRelease(cf);
    }
  }
  else
  {
    CFTypeRef v3 = sub_10000B070("engine");
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "SOS disabled for this platform", buf, 2u);
    }
  }
}

uint64_t sub_100100734(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, const __CFArray *a5, CFTypeRef *a6)
{
  if (!-[OTSOSActualAdapter sosEnabled]_0())
  {
    SOSCCSetSOSDisabledError();
    return 0;
  }
  uint64_t v11 = sub_10000B070("engine");
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = *(void *)(a1 + 24);
    BOOL v13 = "did-rollback";
    if (a3 == 2) {
      BOOL v13 = "did-commit";
    }
    if (a3 == 1) {
      BOOL v14 = "will-commit";
    }
    else {
      BOOL v14 = v13;
    }
    if (a4)
    {
      if (a4 == 3)
      {
        BOOL v15 = "ckks";
      }
      else if (a4 == 1)
      {
        BOOL v15 = "api";
      }
      else
      {
        BOOL v15 = "unknown";
      }
    }
    else
    {
      BOOL v15 = "sos";
    }
    *(_DWORD *)long long buf = 138413570;
    *(void *)&uint8_t buf[4] = v12;
    *(_WORD *)&unsigned char buf[12] = 2080;
    *(void *)&buf[14] = v14;
    *(_WORD *)&buf[22] = 2080;
    uint64_t v44 = v15;
    *(_WORD *)id v45 = 2048;
    *(void *)&v45[2] = CFArrayGetCount(a5);
    *(_WORD *)&v45[10] = 2112;
    *(void *)&v45[12] = a2;
    *(_WORD *)&v45[20] = 2048;
    *(void *)&v45[22] = a2;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%@: %s %s %ld changes, txn=%@, %p", buf, 0x3Eu);
  }

  if ((unint64_t)(a3 - 1) >= 2)
  {
    if (!a3) {
      return sub_1000FE1B0(a1, a2, a6);
    }
    return 1;
  }
  v36[0] = a1;
  v36[1] = a2;
  v36[2] = a3;
  void v36[3] = a4;
  CFDictionaryRef theDict = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFSetRef theSet = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  CFIndex Count = CFArrayGetCount(a5);
  if (Count >= 1)
  {
    CFIndex v18 = 0;
    int v19 = 0;
    while (1)
    {
      CFArrayRef ValueAtIndex = (const __CFArray *)CFArrayGetValueAtIndex(a5, v18);
      CFArrayRef v21 = ValueAtIndex;
      if (!ValueAtIndex) {
        goto LABEL_38;
      }
      CFTypeID v22 = CFGetTypeID(ValueAtIndex);
      if (v22 == CFArrayGetTypeID())
      {
        CFIndex v23 = CFArrayGetCount(v21);
        if (v23 == 1)
        {
          uint64_t v24 = CFArrayGetValueAtIndex(v21, 0);
          CFArrayRef v21 = 0;
          if (v24) {
            goto LABEL_28;
          }
        }
        else
        {
          if (v23 != 2)
          {
            sub_100012A40(-50, (__CFString **)a6, 0, @"invalid entry in changes array: %@", v21);
            goto LABEL_38;
          }
          uint64_t v24 = CFArrayGetValueAtIndex(v21, 0);
          CFArrayRef v21 = (const __CFArray *)CFArrayGetValueAtIndex(v21, 1);
          if (v24)
          {
LABEL_28:
            v19 |= sub_100101554((uint64_t)v36, 0, v24);
            if (!v21) {
              goto LABEL_38;
            }
            goto LABEL_29;
          }
        }
        if (!v21) {
          goto LABEL_38;
        }
      }
LABEL_29:
      if (sub_100101554((uint64_t)v36, 1, v21))
      {
        int v19 = 1;
      }
      else
      {
        CFTypeID v25 = CFGetTypeID(v21);
        if (v25 != CFDataGetTypeID() && sub_10011BAEC((void **)v21))
        {
          CFBooleanRef v26 = (CFBooleanRef)sub_100118CF8(v21, (uint64_t)&off_1002FC0D0, 0);
          if (v26 && kCFBooleanTrue)
          {
            if (!CFEqual(v26, kCFBooleanTrue)) {
              goto LABEL_41;
            }
          }
          else if (v26 != kCFBooleanTrue)
          {
LABEL_41:
            CFTypeRef cf = 0;
            if (!sub_10011E31C((CFStringRef **)v21, a2, &cf, (uint64_t)&stru_1002FAA18))
            {
              CFTypeRef v27 = sub_10000B070("SecError");
              if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)long long buf = 138478083;
                *(void *)&uint8_t buf[4] = v21;
                *(_WORD *)&unsigned char buf[12] = 2112;
                *(void *)&buf[14] = cf;
                _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "failed to delete tombstone %{private}@ that no one cares about: %@", buf, 0x16u);
              }

              CFTypeRef v28 = cf;
              if (cf)
              {
                CFTypeRef cf = 0;
                CFRelease(v28);
              }
            }
          }
        }
      }
LABEL_38:
      if (Count == ++v18) {
        goto LABEL_49;
      }
    }
  }
  int v19 = 0;
LABEL_49:
  CFTypeRef cf = 0;
  p_CFTypeRef cf = &cf;
  uint64_t v41 = 0x2020000000;
  char v42 = 1;
  *(void *)long long buf = _NSConcreteStackBlock;
  *(void *)&uint8_t buf[8] = 3221225472;
  *(void *)&uint8_t buf[16] = sub_100100E20;
  uint64_t v44 = (const char *)&unk_100308BF0;
  *(void *)id v45 = &cf;
  *(void *)&v45[8] = v36;
  *(void *)&v45[16] = a6;
  CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)sub_1000FE194, buf);
  int v29 = *((unsigned __int8 *)p_cf + 24);
  uint64_t v16 = *((unsigned char *)p_cf + 24) != 0;
  _Block_object_dispose(&cf, 8);
  CFSetRef v30 = theSet;
  if (qword_10035CEA8 != -1) {
    dispatch_once(&qword_10035CEA8, &stru_1002FA4F0);
  }
  if (qword_10035CEB0 && CFSetGetCount(v30))
  {
    CFRetain(v30);
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 3221225472;
    *(void *)&uint8_t buf[16] = sub_100101474;
    uint64_t v44 = (const char *)&unk_1003093A8;
    *(void *)id v45 = v30;
    dispatch_async((dispatch_queue_t)qword_10035CEB0, buf);
  }
  if (theDict) {
    CFRelease(theDict);
  }
  if (theSet) {
    CFRelease(theSet);
  }
  if (a3 == 1 && v29)
  {
    int v31 = sub_10000B070("engine");
    int v32 = v31;
    if (((a4 != 0) & (v19 ^ 1)) == 0)
    {
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "saving engine state", buf, 2u);
      }

      uint64_t v16 = sub_1000FD354(a1, a2, a6);
      if ((a4 & 0xFFFFFFFFFFFFFFFDLL) == 1)
      {
        uint64_t v33 = *(void *)(a1 + 80);
        *(void *)long long buf = _NSConcreteStackBlock;
        *(void *)&uint8_t buf[8] = 3221225472;
        *(void *)&uint8_t buf[16] = sub_10021C2D0;
        uint64_t v44 = (const char *)&unk_1003093A8;
        *(void *)id v45 = v33;
        _os_activity_initiate((void *)&_mh_execute_header, "CloudCircle RequestSyncWithPeersList", OS_ACTIVITY_FLAG_DEFAULT, buf);
      }
      return v16;
    }
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)long long buf = 0;
      _os_log_debug_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEBUG, "Not saving engine state, nothing changed.", buf, 2u);
    }

    return 1;
  }
  return v16;
}

void sub_100100E00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100100E20(uint64_t result, uint64_t a2, CFArrayRef theArray)
{
  uint64_t v3 = result;
  if (theArray
    && (CFTypeRef v6 = *(uint64_t **)(result + 40),
        CFTypeRef v7 = *(CFTypeRef **)(result + 48),
        uint64_t v8 = v6[1],
        uint64_t v66 = *v6,
        uint64_t v10 = v6[2],
        uint64_t v9 = v6[3],
        (CFMutableDictionaryRef result = CFArrayGetCount(theArray)) != 0))
  {
    uint64_t v64 = v10;
    uint64_t v65 = v9;
    __int16 v63 = v7;
    uint64_t v61 = a2;
    uint64_t v62 = v3;
    MutableCFDictionaryRef Copy = CFStringCreateMutableCopy(kCFAllocatorDefault, 0, @"(");
    CFIndex Count = CFArrayGetCount(theArray);
    if (Count >= 1)
    {
      CFIndex v13 = Count;
      for (CFIndex i = 0; i != v13; ++i)
      {
        CFArrayRef ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
        CFTypeID v16 = CFGetTypeID(ValueAtIndex);
        CFTypeID TypeID = CFArrayGetTypeID();
        if (v16 == TypeID) {
          CFArrayRef ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)ValueAtIndex, 0);
        }
        if (ValueAtIndex)
        {
          CFTypeID v18 = CFGetTypeID(ValueAtIndex);
          BOOL v19 = v18 == CFDataGetTypeID();
          CFStringRef v20 = @"a";
          if (v16 == TypeID)
          {
            CFStringRef v20 = @"d";
            CFStringRef v21 = @"D";
          }
          else
          {
            CFStringRef v21 = @"A";
          }
          if (v19) {
            CFStringRef v22 = v20;
          }
          else {
            CFStringRef v22 = v21;
          }
        }
        else if (v16 == TypeID)
        {
          CFStringRef v22 = @"D";
        }
        else
        {
          CFStringRef v22 = @"A";
        }
        CFStringAppend(MutableCopy, v22);
        CFRelease(v22);
      }
    }
    CFStringAppend(MutableCopy, @""));
    CFIndex v23 = sub_10000B070("tracker");
    uint64_t v25 = v64;
    uint64_t v24 = v65;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      CFBooleanRef v26 = "did-rollback";
      if (v64 == 2) {
        CFBooleanRef v26 = "did-commit";
      }
      if (v64 == 1) {
        CFBooleanRef v26 = "will-commit";
      }
      if (v65)
      {
        if (v65 == 3)
        {
          CFTypeRef v27 = "ckks";
        }
        else
        {
          CFTypeRef v27 = "unknown";
          if (v65 == 1) {
            CFTypeRef v27 = "api";
          }
        }
      }
      else
      {
        CFTypeRef v27 = "sos";
      }
      *(_DWORD *)long long buf = 138413058;
      *(void *)&uint8_t buf[4] = a2;
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v26;
      *(_WORD *)&buf[22] = 2080;
      *(void *)&unsigned char buf[24] = v27;
      __int16 v71 = 2112;
      id v72 = MutableCopy;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%@ %s %s changes: %@", buf, 0x2Au);
    }
    if (MutableCopy) {
      CFRelease(MutableCopy);
    }
    if (*(void *)(a2 + 16) || *(void *)(a2 + 32))
    {
      memset(buf, 0, sizeof(buf));
      *(_OWORD *)uint64_t v68 = 0u;
      long long v69 = 0u;
      CFIndex v29 = CFArrayGetCount(theArray);
      if (v29 >= 1)
      {
        CFIndex v30 = v29;
        for (CFIndex j = 0; v30 != j; ++j)
        {
          CFArrayRef v32 = (const __CFArray *)CFArrayGetValueAtIndex(theArray, j);
          CFArrayRef v33 = v32;
          if (v32)
          {
            CFTypeID v34 = CFGetTypeID(v32);
            if (v34 == CFArrayGetTypeID())
            {
              CFArrayRef v33 = (const __CFArray *)CFArrayGetValueAtIndex(v33, 0);
              CFDictionaryRef v35 = (char **)buf;
              if (!v33) {
                goto LABEL_45;
              }
            }
            else
            {
              CFDictionaryRef v35 = (char **)v68;
            }
            CFTypeID v36 = CFGetTypeID(v33);
            if (v36 == CFDataGetTypeID())
            {
              CFTypeID v37 = 0;
              CFDataRef v38 = v33;
              goto LABEL_47;
            }
          }
          else
          {
            CFDictionaryRef v35 = (char **)v68;
          }
LABEL_45:
          CFTypeRef cf = 0;
          -[OTSOSActualAdapter sosEnabled]_0();
          uint64_t v39 = (*(uint64_t (**)(const __CFArray *, CFTypeRef *))(*(void *)(v66 + 16) + 112))(v33, &cf);
          if (!v39)
          {
            CFIndex v43 = sub_10000B070("SecError");
            if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int16 v73 = 138412546;
              CFArrayRef v74 = v33;
              __int16 v75 = 2112;
              CFTypeRef v76 = cf;
              _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "change %@ SOSObjectCopyDigest: %@", v73, 0x16u);
            }
            CFTypeRef v42 = cf;
            if (!cf) {
              continue;
            }
            CFTypeRef cf = 0;
            goto LABEL_57;
          }
          CFTypeID v37 = (const void *)v39;
          CFDataRef v38 = (const __CFData *)v39;
LABEL_47:
          if (CFDataGetLength(v38) == 20)
          {
            BytePtr = (long long *)CFDataGetBytePtr(v38);
            sub_100200054(v35, BytePtr);
            *((unsigned char *)v35 + 24) = 1;
          }
          else
          {
            uint64_t v41 = sub_10000B070("SecError");
            if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)__int16 v73 = 138412546;
              CFArrayRef v74 = v33;
              __int16 v75 = 2112;
              CFTypeRef v76 = v38;
              _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "change %@ bad length digest: %@", v73, 0x16u);
            }
          }
          if (!v37) {
            continue;
          }
          CFTypeRef v42 = v37;
LABEL_57:
          CFRelease(v42);
        }
      }
      uint64_t v44 = (const void *)sub_100201498((uint64_t)buf, v63);
      if (v44)
      {
        id v45 = (const void *)sub_100201498((uint64_t)v68, v63);
        BOOL v46 = v45 != 0;
      }
      else
      {
        id v45 = 0;
        BOOL v46 = 0;
      }
      free(v68[0]);
      v68[0] = 0;
      v68[1] = 0;
      BYTE8(v69) = 0;
      *(void *)&long long v69 = 0;
      free(*(void **)buf);
      int v47 = 0;
      if (v46)
      {
        uint64_t v48 = *(void *)(v61 + 16);
        if (v48)
        {
          uint64_t v49 = sub_1002014F4(v48, (uint64_t)v44, (uint64_t)v45, v63);
          if (v49)
          {
            uint64_t v50 = v49;
            CFTypeID v51 = *(const void **)(v61 + 16);
            if (v51) {
              CFRelease(v51);
            }
            *(void *)(v61 + 16) = v50;
          }
        }
        CFArrayRef v52 = *(const __CFArray **)(v61 + 32);
        if (v52 && (CFIndex v53 = CFArrayGetCount(v52), v53 >= 1))
        {
          CFIndex v54 = v53;
          CFIndex v55 = 0;
          LOBYTE(v47) = 1;
          do
          {
            id v56 = (uint64_t (**)(const void *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, const void *, const void *, CFTypeRef *))CFArrayGetValueAtIndex(*(CFArrayRef *)(v61 + 32), v55);
            if ((_BYTE)v47) {
              int v47 = v56[2](v56, v61, v66, v8, v65, v64, v44, v45, v63);
            }
            else {
              int v47 = 0;
            }
            ++v55;
          }
          while (v54 != v55);
        }
        else
        {
          int v47 = 1;
        }
      }
      if (v44) {
        CFRelease(v44);
      }
      uint64_t v57 = v8;
      uint64_t v25 = v64;
      uint64_t v24 = v65;
      if (v45) {
        CFRelease(v45);
      }
    }
    else
    {
      int v47 = 1;
      uint64_t v57 = v8;
    }
    CFMutableDictionaryRef result = *(void *)(v61 + 24);
    if (result)
    {
      CFMutableDictionaryRef result = CFArrayGetCount((CFArrayRef)result);
      if (result >= 1)
      {
        uint64_t v58 = result;
        for (CFIndex k = 0; k != v58; ++k)
        {
          CFMutableDictionaryRef result = (uint64_t)CFArrayGetValueAtIndex(*(CFArrayRef *)(v61 + 24), k);
          if ((_BYTE)v47)
          {
            CFMutableDictionaryRef result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, CFArrayRef, CFTypeRef *))(result + 16))(result, v61, v66, v57, v24, v25, theArray, v63);
            int v47 = result;
          }
          else
          {
            int v47 = 0;
          }
        }
      }
    }
    BOOL v28 = v47 != 0;
    uint64_t v3 = v62;
  }
  else
  {
    BOOL v28 = 1;
  }
  uint64_t v60 = *(void *)(*(void *)(v3 + 32) + 8);
  if (!*(unsigned char *)(v60 + 24)) {
    BOOL v28 = 0;
  }
  *(unsigned char *)(v60 + 24) = v28;
  return result;
}

void sub_100101474(uint64_t a1)
{
  CFSetRef v2 = *(const __CFSet **)(a1 + 32);
  if (qword_10035CEA0)
  {
    context[0] = _NSConcreteStackBlock;
    context[1] = 3221225472;
    context[2] = sub_10010204C;
    context[3] = &unk_100309D30;
    context[4] = qword_10035CEA0;
    CFSetApplyFunction(v2, (CFSetApplierFunction)sub_1001002C0, context);
  }
  else
  {
    qword_10035CEA0 = (uint64_t)CFSetCreateMutableCopy(0, 0, v2);
    dispatch_time_t v3 = dispatch_time(0, 1000000000);
    dispatch_after(v3, (dispatch_queue_t)qword_10035CEB0, &stru_1002FA510);
  }
  CFRelease(*(CFTypeRef *)(a1 + 32));
}

BOOL sub_100101554(uint64_t a1, char a2, void *cf)
{
  CFTypeID v6 = CFGetTypeID(cf);
  if (v6 == CFDataGetTypeID())
  {
    CFDictionaryRef v7 = *(const __CFDictionary **)(*(void *)a1 + 64);
    context[0] = _NSConcreteStackBlock;
    context[1] = 3221225472;
    context[2] = sub_100101DA4;
    context[3] = &unk_1002FA4B0;
    char v40 = a2;
    context[4] = a1;
    void context[5] = cf;
    CFDictionaryApplyFunction(v7, (CFDictionaryApplierFunction)sub_1000FE194, context);
    CFIndex Count = CFDictionaryGetCount(*(CFDictionaryRef *)(*(void *)a1 + 64));
    return Count != 0;
  }
  CFSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
  v34[0] = _NSConcreteStackBlock;
  v34[1] = 3221225472;
  CFDictionaryRef v35 = sub_100101DB8;
  CFTypeID v36 = &unk_100307FB8;
  uint64_t v37 = a1;
  CFSetRef v38 = Mutable;
  uint64_t v10 = v34;
  CFTypeID v11 = CFGetTypeID(cf);
  if (v11 == CFDictionaryGetTypeID())
  {
    CFBooleanRef Value = (const __CFBoolean *)CFDictionaryGetValue((CFDictionaryRef)cf, kSecAttrTombstone);
    if (Value)
    {
      int v13 = CFBooleanGetValue(Value);
      v35((uint64_t)v10, (const __CFString *)kSOSViewKeychainV0);
      if (v13) {
        goto LABEL_31;
      }
    }
    else
    {
      v35((uint64_t)v10, (const __CFString *)kSOSViewKeychainV0);
    }
    CFStringRef v21 = (const __CFString **)&kSOSViewKeychainV0_tomb;
    goto LABEL_30;
  }
  BOOL valuePtr = 0;
  *(void *)long long buf = 0;
  uint64_t v14 = sub_100118974((void *)cf[2], 11, (__CFString **)buf);
  if (!sub_10011B8D0(cf, v14, &valuePtr, (__CFString **)buf)) {
    BOOL valuePtr = SecErrorGetOSStatus() == -26275;
  }
  if (*(void *)buf) {
    CFRelease(*(CFTypeRef *)buf);
  }
  if (!valuePtr) {
    goto LABEL_31;
  }
  uint64_t v15 = cf[2];
  CFTypeID v16 = sub_100119CB8(cf, kSecAttrAccessible);
  if (v15 != sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008)
    && v15 != sub_10000C75C(@"inet", &qword_10035D020, (uint64_t)&unk_10035D018)
    && v15 != sub_10000C75C(@"keys", &qword_10035D040, (uint64_t)&unk_10035D038)
    && v15 != sub_10000C75C(@"cert", &qword_10035D030, (uint64_t)&unk_10035D028))
  {
    goto LABEL_31;
  }
  if (!v16) {
    goto LABEL_31;
  }
  CFTypeID v17 = CFGetTypeID(v16);
  if (v17 != CFStringGetTypeID()
    || !CFEqual(v16, kSecAttrAccessibleWhenUnlocked)
    && !CFEqual(v16, kSecAttrAccessibleAfterFirstUnlock)
    && !CFEqual(v16, kSecAttrAccessibleAlwaysPrivate)
    && !CFEqual(v16, kSecAttrAccessibleWhenUnlockedThisDeviceOnly)
    && !CFEqual(v16, kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly)
    && !CFEqual(v16, kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate))
  {
    goto LABEL_31;
  }
  CFNumberRef v18 = (const __CFNumber *)sub_100119CB8(cf, kSecAttrTombstone);
  BOOL valuePtr = 0;
  BOOL v31 = v18
     && (CFNumberRef v19 = v18, v20 = CFGetTypeID(v18), v20 == CFNumberGetTypeID())
     && CFNumberGetValue(v19, kCFNumberCharType, &valuePtr)
     && valuePtr;
  CFStringRef v23 = (const __CFString *)sub_100119CB8(cf, kSecAttrSyncViewHint);
  CFStringRef v24 = v23;
  if (v23)
  {
    CFTypeID v25 = CFGetTypeID(v23);
    if (v25 != CFStringGetTypeID()) {
      CFStringRef v24 = 0;
    }
  }
  if (SOSViewHintInCKKSSystem()) {
    goto LABEL_31;
  }
  if (!sub_10011BA64(cf))
  {
    BOOL v28 = sub_10000B070("item");
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138477827;
      *(void *)&uint8_t buf[4] = cf;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Skipping non-primary item %{private}@", buf, 0xCu);
    }

    goto LABEL_31;
  }
  if (v24)
  {
    v35((uint64_t)v10, v24);
    if (!v31)
    {
      CFStringRef v26 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"%@-tomb", v24);
      if (v26)
      {
        CFStringRef v27 = v26;
        v35((uint64_t)v10, v26);
        CFRelease(v27);
      }
    }
    goto LABEL_31;
  }
  if (v15 == sub_10000C75C(@"cert", &qword_10035D030, (uint64_t)&unk_10035D028))
  {
    v35((uint64_t)v10, (const __CFString *)kSOSViewOtherSyncable);
    if (v31) {
      goto LABEL_31;
    }
    goto LABEL_64;
  }
  if (!sub_100119CB8(cf, kSecAttrTokenID))
  {
    v35((uint64_t)v10, (const __CFString *)kSOSViewKeychainV0);
    if (!v31) {
      v35((uint64_t)v10, (const __CFString *)kSOSViewKeychainV0_tomb);
    }
  }
  CFIndex v29 = sub_100119CB8(cf, kSecAttrAccessGroup);
  if (v15 != sub_10000C75C(@"keys", &qword_10035D040, (uint64_t)&unk_10035D038))
  {
    if (v29)
    {
LABEL_53:
      if (CFEqual(v29, @"com.apple.cfnetwork"))
      {
        v35((uint64_t)v10, (const __CFString *)kSOSViewAutofillPasswords);
        if (!v31)
        {
          CFStringRef v21 = (const __CFString **)&kSOSViewAutofillPasswords_tomb;
LABEL_30:
          v35((uint64_t)v10, *v21);
          goto LABEL_31;
        }
        goto LABEL_31;
      }
      if (CFEqual(v29, @"com.apple.safari.credit-cards"))
      {
        v35((uint64_t)v10, (const __CFString *)kSOSViewSafariCreditCards);
        if (!v31)
        {
          CFStringRef v21 = (const __CFString **)&kSOSViewSafariCreditCards_tomb;
          goto LABEL_30;
        }
        goto LABEL_31;
      }
      if (v15 == sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008))
      {
        if (CFEqual(v29, @"apple"))
        {
          CFIndex v30 = sub_100119CB8(cf, kSecAttrService);
          if (v30)
          {
            if (CFEqual(v30, @"AirPort"))
            {
              v35((uint64_t)v10, (const __CFString *)kSOSViewWiFi);
              if (!v31)
              {
                CFStringRef v21 = (const __CFString **)&kSOSViewWiFi_tomb;
                goto LABEL_30;
              }
              goto LABEL_31;
            }
          }
        }
        if (CFEqual(v29, @"com.apple.sbd"))
        {
          v35((uint64_t)v10, (const __CFString *)kSOSViewBackupBagV0);
          if (!v31)
          {
            CFStringRef v21 = (const __CFString **)&kSOSViewBackupBagV0_tomb;
            goto LABEL_30;
          }
          goto LABEL_31;
        }
      }
      goto LABEL_63;
    }
LABEL_62:
    sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008);
LABEL_63:
    v35((uint64_t)v10, (const __CFString *)kSOSViewOtherSyncable);
    if (v31) {
      goto LABEL_31;
    }
LABEL_64:
    CFStringRef v21 = (const __CFString **)&kSOSViewOtherSyncable_tomb;
    goto LABEL_30;
  }
  if (!v29) {
    goto LABEL_62;
  }
  if (!CFEqual(v29, @"com.apple.security.sos")) {
    goto LABEL_53;
  }
  v35((uint64_t)v10, (const __CFString *)kSOSViewiCloudIdentity);
  if (!v31)
  {
    CFStringRef v21 = (const __CFString **)&kSOSViewiCloudIdentity_tomb;
    goto LABEL_30;
  }
LABEL_31:

  v32[0] = _NSConcreteStackBlock;
  v32[1] = 3221225472;
  v32[2] = sub_100101EEC;
  v32[3] = &unk_1002FA4D0;
  char v33 = a2;
  void v32[4] = a1;
  void v32[5] = cf;
  CFSetApplyFunction(Mutable, (CFSetApplierFunction)sub_1001002C0, v32);
  CFIndex Count = CFSetGetCount(Mutable);
  if (Mutable) {
    CFRelease(Mutable);
  }
  return Count != 0;
}

void sub_100101DA4(uint64_t a1, uint64_t a2, const void *a3)
{
}

void sub_100101DB8(uint64_t a1, const __CFString *a2)
{
  CFSetRef Value = (const __CFSet *)CFDictionaryGetValue(*(CFDictionaryRef *)(**(void **)(a1 + 32) + 72), a2);
  if (Value)
  {
    CFSetRef v5 = Value;
    CFTypeID v6 = CFGetTypeID(Value);
    if (v6 == CFSetGetTypeID())
    {
      context[0] = _NSConcreteStackBlock;
      context[1] = 3221225472;
      context[2] = sub_100102044;
      context[3] = &unk_100309D30;
      context[4] = *(void *)(a1 + 40);
      CFSetApplyFunction(v5, (CFSetApplierFunction)sub_1001002C0, context);
    }
    else
    {
      CFSetAddValue(*(CFMutableSetRef *)(a1 + 40), v5);
    }
  }
  uint64_t v7 = *(void *)(a1 + 32);
  if (!a2 || (CFTypeID v8 = CFGetTypeID(a2), v8 != CFStringGetTypeID())) {
    sub_10002BBA0(@"Execution has encountered an unexpected state", 0x53C0000Eu);
  }
  if (CFStringHasPrefix(a2, @"PCS-")) {
    CFStringRef v9 = @"PCS";
  }
  else {
    CFStringRef v9 = a2;
  }
  CFSetSetValue(*(CFMutableSetRef *)(v7 + 40), v9);
}

void sub_100101EEC(uint64_t a1, const void *a2)
{
}

void sub_100101EFC(uint64_t a1, const void *a2, int a3, const void *a4)
{
  CFSetRef Value = (void *)CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 32), a2);
  if (!Value)
  {
    CFSetRef Value = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, Value);
    if (Value) {
      CFRelease(Value);
    }
  }
  if (a3)
  {
    CFArrayAppendValue((CFMutableArrayRef)Value, a4);
  }
  else
  {
    uint64_t v10 = a4;
    CFArrayRef v9 = CFArrayCreate(kCFAllocatorDefault, &v10, 1, &kCFTypeArrayCallBacks);
    CFArrayAppendValue((CFMutableArrayRef)Value, v9);
    if (v9) {
      CFRelease(v9);
    }
  }
}

void sub_100102044(uint64_t a1, const void *a2)
{
}

void sub_10010204C(uint64_t a1, const void *a2)
{
}

void sub_100102054(id a1)
{
  CFSetRef v1 = (const __CFSet *)qword_10035CEA0;
  context[0] = _NSConcreteStackBlock;
  context[1] = 3221225472;
  context[2] = sub_1001020F4;
  context[3] = &unk_100309D30;
  context[4] = CFNotificationCenterGetDarwinNotifyCenter();
  CFSetApplyFunction(v1, (CFSetApplierFunction)sub_1001002C0, context);
  CFRelease((CFTypeRef)qword_10035CEA0);
  qword_10035CEA0 = 0;
}

void sub_1001020F4(uint64_t a1, uint64_t a2)
{
  CFTypeID v4 = sub_10000B070("view");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 138412290;
    uint64_t v8 = a2;
    _os_log_debug_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEBUG, "Sending view notification for view %@", buf, 0xCu);
  }

  CFStringRef v5 = CFStringCreateWithFormat(0, 0, @"com.apple.security.view-change.%@", a2);
  if (v5)
  {
    CFStringRef v6 = v5;
    CFNotificationCenterPostNotificationWithOptions(*(CFNotificationCenterRef *)(a1 + 32), v5, 0, 0, 0);
    CFRelease(v6);
  }
}

void sub_1001021F0(id a1)
{
  qword_10035CEB0 = (uint64_t)dispatch_queue_create("ViewNotificationQueue", 0);

  _objc_release_x1();
}

uint64_t sub_100102230(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned char *a5)
{
  uint64_t result = SOSErrorCreate();
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  *a5 = 1;
  return result;
}

void sub_100102280(uint64_t a1, const void *a2, unsigned char *a3)
{
  CFDataRef v6 = (const __CFData *)(*(uint64_t (**)(const void *, void))(*(void *)(*(void *)(a1 + 56) + 16)
                                                                         + 112))(a2, *(void *)(a1 + 64));
  if (v6)
  {
    CFDataRef v7 = v6;
    uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8);
    BytePtr = (long long *)CFDataGetBytePtr(v6);
    sub_100200054((char **)(v8 + 32), BytePtr);
    *(unsigned char *)(v8 + 56) = 1;
    CFTypeRef cf1 = 0;
    uint64_t v10 = (*(uint64_t (**)(void, const void *, CFTypeRef *, void))(*(void *)(*(void *)(a1 + 56) + 16)
                                                                               + 88))(*(void *)(a1 + 88), a2, &cf1, *(void *)(a1 + 64));
    uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8);
    if (v10) {
      BOOL v12 = *(unsigned char *)(v11 + 24) == 0;
    }
    else {
      BOOL v12 = 1;
    }
    char v13 = !v12;
    *(unsigned char *)(v11 + 24) = v13;
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
    {
      if ((v10 & 0xFFFFFFFFFFFFFFFELL) == 2)
      {
        **(unsigned char **)(a1 + 96) = 1;
      }
      else
      {
        if (!CFEqual(cf1, a2))
        {
          uint64_t v20 = *(void *)(*(void *)(a1 + 48) + 8);
          CFStringRef v21 = (long long *)CFDataGetBytePtr(v7);
          sub_100200054((char **)(v20 + 32), v21);
          *(unsigned char *)(v20 + 56) = 1;
        }
        CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 104), cf1);
      }
    }
    else
    {
      *a3 = 1;
      **(unsigned char **)(a1 + 72) = 0;
      CFTypeID v17 = sub_10000B070("SecError");
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v18 = *(void *)(*(void *)(a1 + 80) + 16);
        CFNumberRef v19 = *(void **)(a1 + 64);
        if (v19) {
          CFNumberRef v19 = (void *)*v19;
        }
        *(_DWORD *)long long buf = 138412546;
        uint64_t v32 = v18;
        __int16 v33 = 2112;
        CFTypeID v34 = v19;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%@ SOSDataSourceMergeObject failed %@ rolling back changes", buf, 0x16u);
      }
    }
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
    {
      if (*(unsigned char *)(a1 + 112))
      {
        uint64_t v22 = (*(uint64_t (**)(const void *, void))(*(void *)(*(void *)(a1 + 56) + 16) + 120))(a2, 0);
        if (v22)
        {
          CFDateRef v23 = (const __CFDate *)v22;
          double Current = CFAbsoluteTimeGetCurrent();
          CFAbsoluteTime AbsoluteTime = CFDateGetAbsoluteTime(v23);
          uint64_t v26 = (uint64_t)(Current - AbsoluteTime);
          if (AbsoluteTime <= Current) {
            uint64_t v26 = 0;
          }
          uint64_t v27 = 1;
          if (v26 >= 101)
          {
            unint64_t v28 = v26;
            do
            {
              v27 *= 10;
              BOOL v29 = v28 > 0x3F1;
              v28 /= 0xAuLL;
            }
            while (v29);
          }
          SecCoreAnalyticsSendValue();
          CFRelease(v23);
        }
      }
    }
    if (cf1) {
      CFRelease(cf1);
    }
    CFRelease(v7);
  }
  else
  {
    *a3 = 1;
    **(unsigned char **)(a1 + 72) = 0;
    uint64_t v14 = sub_10000B070("SecError");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = *(void *)(*(void *)(a1 + 80) + 16);
      CFTypeID v16 = *(void **)(a1 + 64);
      if (v16) {
        CFTypeID v16 = (void *)*v16;
      }
      *(_DWORD *)long long buf = 138412546;
      uint64_t v32 = v15;
      __int16 v33 = 2112;
      CFTypeID v34 = v16;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%@ peer sent bad object: %@, rolling back changes", buf, 0x16u);
    }
  }
}

void sub_1001025C8(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (-[OTSOSActualAdapter sosEnabled]_0())
  {
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472;
    v4[2] = sub_100102668;
    v4[3] = &unk_1002FA140;
    uint64_t v6 = a1;
    id v5 = v3;
    dispatch_sync(*(dispatch_queue_t *)(a1 + 112), v4);
  }
}

uint64_t sub_100102668(uint64_t a1)
{
  *(void *)(*(void *)(a1 + 40) + 136) = [*(id *)(a1 + 32) copy];

  return _objc_release_x1();
}

void sub_1001026AC(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (-[OTSOSActualAdapter sosEnabled]_0())
  {
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472;
    v4[2] = sub_10010274C;
    v4[3] = &unk_1002FA1B8;
    uint64_t v6 = a1;
    id v5 = v3;
    dispatch_sync(*(dispatch_queue_t *)(a1 + 112), v4);
  }
}

void sub_10010274C(uint64_t a1)
{
}

void sub_100102758(void *a1)
{
  (*(void (**)(void))(a1[4] + 16))();
  CFSetRef v2 = (const void *)a1[5];
  if (v2) {
    CFRelease(v2);
  }
  id v3 = (const void *)a1[6];
  if (v3)
  {
    CFRelease(v3);
  }
}

void sub_1001027BC(uint64_t a1, CFDataRef theData, const void *a3, unsigned char *a4)
{
  CFTypeRef cf = 0;
  if (!a3)
  {
    BytePtr = CFDataGetBytePtr(theData);
    uint64_t v37 = sub_10000B070("SecError");
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v38 = *(void *)(*(void *)(a1 + 64) + 24);
      uint64_t v39 = *(void *)(*(void *)(a1 + 72) + 16);
      int v40 = *BytePtr;
      int v41 = BytePtr[1];
      int v42 = BytePtr[2];
      int v43 = BytePtr[3];
      uint64_t v44 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      *(_DWORD *)long long buf = 138413826;
      *(void *)&uint8_t buf[4] = v38;
      __int16 v102 = 2112;
      uint64_t v103 = v39;
      __int16 v104 = 1024;
      int v105 = v40;
      __int16 v106 = 1024;
      int v107 = v41;
      __int16 v108 = 1024;
      int v109 = v42;
      __int16 v110 = 1024;
      int v111 = v43;
      __int16 v112 = 2112;
      *(void *)long long v113 = v44;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "%@:%@ object %02X%02X%02X%02X dropping from manifest: not found in datasource: %@", buf, 0x38u);
    }

    id v45 = *(__CFArray **)(a1 + 80);
    *(void *)long long buf = theData;
    CFArrayRef v46 = CFArrayCreate(kCFAllocatorDefault, (const void **)buf, 1, &kCFTypeArrayCallBacks);
    CFArrayAppendValue(v45, v46);
    if (v46) {
      CFRelease(v46);
    }
    char v13 = 0;
    goto LABEL_51;
  }
  CFStringRef v8 = (const __CFString *)(*(uint64_t (**)(const void *, CFTypeRef *))(*(void *)(*(void *)(a1 + 64) + 16)
                                                                                + 136))(a3, &cf);
  if (!v8)
  {
    char v13 = 0;
    goto LABEL_22;
  }
  CFStringRef v12 = v8;
  char v13 = sub_1000298CC(v8, &cf, v9, v10, v11);
  CFRelease(v12);
  if (!v13
    || (CFDataRef v14 = (const __CFData *)(*(uint64_t (**)(const void *, CFTypeRef *))(*(void *)(*(void *)(a1 + 64)
                                                                                                 + 16)
                                                                                     + 112))(a3, &cf)) == 0)
  {
LABEL_22:
    int OSStatus = SecErrorGetOSStatus();
    uint64_t v48 = CFDataGetBytePtr(theData);
    uint64_t v49 = sub_10000B070("engine");
    BOOL v50 = os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT);
    if (OSStatus == -26275)
    {
      if (v50)
      {
        uint64_t v51 = *(void *)(*(void *)(a1 + 64) + 24);
        uint64_t v52 = *(void *)(*(void *)(a1 + 72) + 16);
        int v53 = *v48;
        int v54 = v48[1];
        int v55 = v48[2];
        int v56 = v48[3];
        *(_DWORD *)long long buf = 138413826;
        *(void *)&uint8_t buf[4] = v51;
        __int16 v102 = 2112;
        uint64_t v103 = v52;
        __int16 v104 = 1024;
        int v105 = v53;
        __int16 v106 = 1024;
        int v107 = v54;
        __int16 v108 = 1024;
        int v109 = v55;
        __int16 v110 = 1024;
        int v111 = v56;
        __int16 v112 = 2112;
        *(void *)long long v113 = cf;
        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "%@:%@ object %02X%02X%02X%02X dropping from manifest: %@", buf, 0x38u);
      }

      uint64_t v57 = *(__CFArray **)(a1 + 80);
      *(void *)long long buf = theData;
      CFArrayRef v58 = CFArrayCreate(kCFAllocatorDefault, (const void **)buf, 1, &kCFTypeArrayCallBacks);
      CFArrayAppendValue(v57, v58);
      if (v58) {
        CFRelease(v58);
      }
      CFTypeRef v59 = cf;
    }
    else
    {
      if (v50)
      {
        uint64_t v60 = *(void *)(*(void *)(a1 + 64) + 24);
        uint64_t v61 = *(void *)(*(void *)(a1 + 72) + 16);
        int v62 = *v48;
        int v63 = v48[1];
        int v64 = v48[2];
        int v65 = v48[3];
        *(_DWORD *)long long buf = 138413826;
        *(void *)&uint8_t buf[4] = v60;
        __int16 v102 = 2112;
        uint64_t v103 = v61;
        __int16 v104 = 1024;
        int v105 = v62;
        __int16 v106 = 1024;
        int v107 = v63;
        __int16 v108 = 1024;
        int v109 = v64;
        __int16 v110 = 1024;
        int v111 = v65;
        __int16 v112 = 2112;
        *(void *)long long v113 = cf;
        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "%@:%@ object %02X%02X%02X%02X in SOSDataSourceForEachObject: %@", buf, 0x38u);
      }

      *a4 = 1;
      if (cf)
      {
        uint64_t v66 = *(CFTypeRef **)(a1 + 88);
        if (v66 && !*v66) {
          *uint64_t v66 = cf;
        }
        else {
          CFRelease(cf);
        }
      }
      uint64_t v85 = *(void *)(*(void *)(a1 + 40) + 8);
      CFTypeRef v59 = *(CFTypeRef *)(v85 + 24);
      if (!v59) {
        goto LABEL_51;
      }
      *(void *)(v85 + 24) = 0;
    }
    CFRelease(v59);
LABEL_51:
    CFDataRef v15 = 0;
    goto LABEL_52;
  }
  CFDataRef v15 = v14;
  if (!CFEqual(theData, v14))
  {
    CFTypeID v16 = CFDataGetBytePtr(theData);
    CFTypeID v17 = CFDataGetBytePtr(v15);
    uint64_t v18 = sub_10000B070("engine");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = *(void *)(*(void *)(a1 + 64) + 24);
      uint64_t v20 = *(void *)(*(void *)(a1 + 72) + 16);
      int v21 = *v16;
      int v22 = v16[1];
      int v23 = v16[2];
      int v24 = v16[3];
      int v25 = *v17;
      int v26 = v17[1];
      int v27 = v17[2];
      int v28 = v17[3];
      *(_DWORD *)long long buf = 138414594;
      *(void *)&uint8_t buf[4] = v19;
      __int16 v102 = 2112;
      uint64_t v103 = v20;
      __int16 v104 = 1024;
      int v105 = v21;
      __int16 v106 = 1024;
      int v107 = v22;
      __int16 v108 = 1024;
      int v109 = v23;
      __int16 v110 = 1024;
      int v111 = v24;
      __int16 v112 = 1024;
      *(_DWORD *)long long v113 = v25;
      *(_WORD *)&v113[4] = 1024;
      *(_DWORD *)&v113[6] = v26;
      LOWORD(v114) = 1024;
      *(_DWORD *)((char *)&v114 + 2) = v27;
      HIWORD(v114) = 1024;
      int v115 = v28;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%@:%@ object %02X%02X%02X%02X is really %02X%02X%02X%02X dropping from local manifest", buf, 0x46u);
    }

    BOOL v29 = *(__CFArray **)(a1 + 80);
    *(void *)long long buf = theData;
    CFArrayRef v30 = CFArrayCreate(kCFAllocatorDefault, (const void **)buf, 1, &kCFTypeArrayCallBacks);
    CFArrayAppendValue(v29, v30);
    if (v30) {
      CFRelease(v30);
    }
    CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 80), a3);
  }
  CFIndex Length = CFDataGetLength(v13);
  uint64_t v32 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  __int16 v33 = CFDataGetBytePtr(v13);
  CFTypeID v34 = &v33[CFDataGetLength(v13)];
  uint64_t v100 = 0;
  *(void *)long long buf = 0;
  if (ccder_decode_tag())
  {
    if (*(void *)buf)
    {
      uint64_t v35 = ccder_decode_len();
      if (v35)
      {
        if (v34 == (const UInt8 *)(v35 + v100)) {
          goto LABEL_63;
        }
      }
    }
    if (SOSErrorCreate()) {
      goto LABEL_63;
    }
LABEL_35:
    CFIndex v98 = Length;
    long long v67 = CFDataGetBytePtr(v15);
    CFIndex v68 = CFDataGetLength(v13);
    CFSetRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 2 * v68);
    CFSetRef v70 = CFDataGetBytePtr(v13);
    CFIndex v71 = CFDataGetLength(v13);
    if (v71 >= 1)
    {
      CFIndex v72 = v71;
      do
      {
        unsigned int v73 = *v70++;
        CFStringAppendFormat(Mutable, 0, @"%02X", v73);
        --v72;
      }
      while (v72);
    }
    CFArrayRef v74 = sub_10000B070("engine");
    if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v75 = *(void *)(*(void *)(a1 + 64) + 24);
      uint64_t v76 = *(void *)(*(void *)(a1 + 72) + 16);
      int v77 = *v67;
      int v78 = v67[1];
      int v79 = v67[2];
      int v80 = v67[3];
      *(_DWORD *)long long buf = 138414082;
      *(void *)&uint8_t buf[4] = v75;
      __int16 v102 = 2112;
      uint64_t v103 = v76;
      __int16 v104 = 1024;
      int v105 = v77;
      __int16 v106 = 1024;
      int v107 = v78;
      __int16 v108 = 1024;
      int v109 = v79;
      __int16 v110 = 1024;
      int v111 = v80;
      __int16 v112 = 2112;
      *(void *)long long v113 = Mutable;
      *(_WORD *)&v113[8] = 2112;
      CFTypeRef v114 = cf;
      _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "%@:%@ object %02X%02X%02X%02X der: %@ dropping from manifest: %@", buf, 0x42u);
    }

    CFIndex Length = v98;
    if (Mutable) {
      CFRelease(Mutable);
    }
    uint64_t v81 = *(void *)(*(void *)(a1 + 40) + 8);
    long long v82 = *(const void **)(v81 + 24);
    if (v82)
    {
      *(void *)(v81 + 24) = 0;
      CFRelease(v82);
    }
    long long v83 = *(__CFArray **)(a1 + 80);
    *(void *)long long buf = v15;
    CFArrayRef v84 = CFArrayCreate(kCFAllocatorDefault, (const void **)buf, 1, &kCFTypeArrayCallBacks);
    CFArrayAppendValue(v83, v84);
    if (!v84) {
      goto LABEL_72;
    }
    goto LABEL_71;
  }
  if (!SOSErrorCreate()) {
    goto LABEL_35;
  }
LABEL_63:
  long long v88 = (__CFArray *)v32[10];
  if (v88
    || (CFAllocatorRef v89 = CFGetAllocator(v32), v88 = CFArrayCreateMutable(v89, 0, &kCFTypeArrayCallBacks), (v32[10] = v88) != 0))
  {
    CFArrayAppendValue(v88, v13);
  }
  uint64_t v90 = *(void *)(*(void *)(a1 + 48) + 8);
  long long v91 = (long long *)CFDataGetBytePtr(v15);
  sub_100200054((char **)(v90 + 32), v91);
  *(unsigned char *)(v90 + 56) = 1;
  if (!**(void **)(a1 + 96)) {
    **(void **)(a1 + 96) = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  }
  uint64_t v92 = (*(uint64_t (**)(const void *, CFTypeRef *))(*(void *)(*(void *)(a1 + 64) + 16) + 136))(a3, &cf);
  if (!v92) {
    goto LABEL_72;
  }
  CFArrayRef v84 = (CFArrayRef)v92;
  CFArrayRef v93 = **(const __CFArray ***)(a1 + 96);
  CFIndex Count = CFArrayGetCount(v93);
  CFSetRef Value = CFDictionaryGetValue(v84, kSecAttrAccessGroup);
  v116.id location = 0;
  v116.size_t length = Count;
  if (!CFArrayContainsValue(v93, v116, Value))
  {
    __int16 v96 = **(__CFArray ***)(a1 + 96);
    id v97 = CFDictionaryGetValue(v84, kSecAttrAccessGroup);
    CFArrayAppendValue(v96, v97);
  }
LABEL_71:
  CFRelease(v84);
LABEL_72:
  *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) += Length;
  if (*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) >= 0xFA01uLL) {
    *a4 = 1;
  }
LABEL_52:
  long long v86 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if (v86)
  {
    long long v87 = *(void **)(a1 + 88);
    if (v87 && !*v87) {
      *long long v87 = v86;
    }
    else {
      CFRelease(v86);
    }
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
  if (v13) {
    CFRelease(v13);
  }
  if (v15) {
    CFRelease(v15);
  }
}

void sub_1001030DC(uint64_t a1, char a2)
{
  CFTypeID v4 = *((void *)[*(id *)(a1 + 32) engine] + 14);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  _DWORD v5[2] = sub_100103184;
  v5[3] = &unk_1003055B0;
  char v7 = a2;
  id v6 = *(id *)(a1 + 32);
  dispatch_async(v4, v5);
}

void sub_100103184(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 40))
  {
    *((unsigned char *)[*(id *)(a1 + 32) peer] + 4_Block_object_dispose(&STACK[0x3F0], 8) = 0;
    if (![*(id *)(a1 + 32) confirmed] && !objc_msgSend(*(id *)(a1 + 32), "proposed"))
    {
      *((unsigned char *)[*(id *)(a1 + 32) peer] + 49) = 1;
      CFSetRef v2 = sub_10000B070("engine");
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v3 = *((void *)[*(id *)(a1 + 32) engine] + 3);
        uint64_t v4 = *((void *)[*(id *)(a1 + 32) peer] + 2);
        id v5 = [*(id *)(a1 + 32) local];
        int v14 = 138412802;
        uint64_t v15 = v3;
        __int16 v16 = 2112;
        uint64_t v17 = v4;
        __int16 v18 = 2112;
        id v19 = v5;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%@:%@ sendObjects=true L:%@", (uint8_t *)&v14, 0x20u);
      }
    }
    sub_10020664C((CFArrayRef *)[*(id *)(a1 + 32) peer] + 11, [*(id *)(a1 + 32) local]);
    sub_10020664C((CFArrayRef *)[*(id *)(a1 + 32) peer] + 10, [*(id *)(a1 + 32) proposed]);
    id v6 = sub_10000B070("engine");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *((void *)[*(id *)(a1 + 32) engine] + 3);
      uint64_t v8 = *((void *)[*(id *)(a1 + 32) peer] + 2);
      id v9 = [*(id *)(a1 + 32) message];
      int v14 = 138412802;
      uint64_t v15 = v7;
      __int16 v16 = 2112;
      uint64_t v17 = v8;
      __int16 v18 = 2112;
      id v19 = v9;
      uint64_t v10 = "send %@:%@ %@";
LABEL_11:
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v10, (uint8_t *)&v14, 0x20u);
    }
  }
  else
  {
    id v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = *((void *)[*(id *)(a1 + 32) engine] + 3);
      uint64_t v12 = *((void *)[*(id *)(a1 + 32) peer] + 2);
      id v13 = [*(id *)(a1 + 32) message];
      int v14 = 138412802;
      uint64_t v15 = v11;
      __int16 v16 = 2112;
      uint64_t v17 = v12;
      __int16 v18 = 2112;
      id v19 = v13;
      uint64_t v10 = "%@:%@ failed to send %@";
      goto LABEL_11;
    }
  }
}

CFMutableSetRef sub_1001033EC(uint64_t a1, uint64_t a2, char a3, uint64_t a4)
{
  if (-[OTSOSActualAdapter sosEnabled]_0())
  {
    v12[0] = 0;
    v12[1] = v12;
    int v12[2] = 0x2020000000;
    char v13 = 0;
    CFMutableSetRef Mutable = CFSetCreateMutable(kCFAllocatorDefault, 0, &kCFTypeSetCallBacks);
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_100103524;
    void v10[3] = &unk_1002FA258;
    char v11 = a3;
    void v10[4] = v12;
    v10[5] = a2;
    v10[6] = a1;
    v10[7] = Mutable;
    if ((sub_1000FC9E4(a1, a4, v10) & 1) == 0 && Mutable)
    {
      CFRelease(Mutable);
      CFMutableSetRef Mutable = 0;
    }
    _Block_object_dispose(v12, 8);
  }
  else
  {
    SOSCCSetSOSDisabledError();
    return 0;
  }
  return Mutable;
}

void sub_100103504(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100103524(uint64_t a1, uint64_t a2)
{
  uint64_t v11 = 0;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2020000000;
  char v14 = 0;
  CFSetRef v4 = *(const __CFSet **)(a1 + 40);
  context[0] = _NSConcreteStackBlock;
  context[1] = 3221225472;
  context[2] = sub_1001036BC;
  context[3] = &unk_1002FA230;
  char v10 = *(unsigned char *)(a1 + 64);
  uint64_t v5 = *(void *)(a1 + 32);
  context[4] = &v11;
  void context[5] = v5;
  long long v9 = *(_OWORD *)(a1 + 48);
  CFSetApplyFunction(v4, (CFSetApplierFunction)sub_1001002C0, context);
  if (*((unsigned char *)v12 + 24))
  {
    CFTypeRef v7 = 0;
    if ((sub_1000FD354(*(void *)(a1 + 48), a2, &v7) & 1) == 0)
    {
      id v6 = sub_10000B070("engine-save");
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        CFTypeRef v16 = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Failed to save engine: %@", buf, 0xCu);
      }
    }
  }
  _Block_object_dispose(&v11, 8);
}

void sub_100103698(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
}

void sub_1001036BC(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v2 = cf;
  CFTypeRef cfa = 0;
  if (!cf)
  {
    sub_100012A40(-50, (__CFString **)&cfa, @"object %@ is not a string", 0);
LABEL_9:
    CFDictionaryRef v5 = 0;
    BOOL v6 = 0;
    goto LABEL_10;
  }
  CFTypeID v4 = CFGetTypeID(cf);
  if (v4 != CFStringGetTypeID())
  {
    sub_100012A40(-50, (__CFString **)&cfa, @"object %@ is not a string", v2);
    CFTypeRef v2 = 0;
    goto LABEL_9;
  }
  CFDictionaryRef v5 = (const __CFDictionary *)sub_1000FCB54(*(void *)(a1 + 48), v2, (__CFArray *)&cfa);
  if (sub_100205BF4(v5))
  {
    if (*(unsigned char *)(a1 + 64)) {
      *((unsigned char *)v5 + 4_Block_object_dispose(&STACK[0x3F0], 8) = 1;
    }
    BOOL v6 = sub_100103884(*(void *)(a1 + 48), (uint64_t)v5, 0, *(void *)(*(void *)(a1 + 32) + 8) + 24, *(void *)(*(void *)(a1 + 40) + 8) + 24, &cfa);
  }
  else
  {
    BOOL v6 = 1;
  }
LABEL_10:
  if (cfa)
  {
    CFTypeRef v7 = sub_10000B070("engine-sync");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412546;
      CFTypeRef v11 = v2;
      __int16 v12 = 2112;
      CFTypeRef v13 = cfa;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Failed to process sync for %@: %@", buf, 0x16u);
    }
  }
  if (v6) {
    CFSetAddValue(*(CFMutableSetRef *)(a1 + 56), v2);
  }
  CFTypeRef v8 = cfa;
  if (cfa)
  {
    CFTypeRef cfa = 0;
    CFRelease(v8);
  }
  if (v5) {
    CFRelease(v5);
  }
}

BOOL sub_100103884(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, CFTypeRef *a6)
{
  __int16 v12 = &v54;
  uint64_t v54 = 0;
  int v55 = &v54;
  uint64_t v56 = 0x2020000000;
  char v57 = -86;
  if (*(unsigned char *)(a2 + 48))
  {
    char v13 = sub_100204FC8(a2, a6);
    __int16 v12 = v55;
  }
  else
  {
    char v13 = 1;
  }
  char v57 = v13;
  if (!*((unsigned char *)v12 + 24))
  {
    BOOL v24 = 0;
    goto LABEL_50;
  }
  if (!*(void *)(a2 + 112))
  {
    BOOL v24 = 1;
    goto LABEL_50;
  }
  uint64_t v50 = 0;
  uint64_t v51 = &v50;
  uint64_t v52 = 0x2020000000;
  CFTypeRef v53 = (CFTypeRef)0xAAAAAAAAAAAAAAAALL;
  CFTypeRef v53 = sub_100100424(a1, a2);
  uint64_t v46 = 0;
  int v47 = &v46;
  uint64_t v48 = 0x2020000000;
  uint64_t v49 = (const void *)0xAAAAAAAAAAAAAAAALL;
  uint64_t v49 = sub_1002065A8(a2);
  uint64_t v42 = 0;
  int v43 = &v42;
  uint64_t v44 = 0x2020000000;
  char v45 = 1;
  CFTypeRef v40 = 0;
  CFTypeRef cf = 0;
  uint64_t v14 = *(void *)(a2 + 16);
  char v15 = sub_10020113C(v47[3], v51[3], (uint64_t *)&v40, &cf, a6);
  if (*((unsigned char *)v55 + 24)) {
    char v16 = v15;
  }
  else {
    char v16 = 0;
  }
  *((unsigned char *)v55 + 24) = v16;
  uint64_t v17 = sub_10000B070("engine");
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    int v36 = a3;
    uint64_t v18 = v14;
    uint64_t v37 = a4;
    uint64_t v38 = a5;
    id v19 = *(const char **)(a1 + 24);
    if (v51[3]) {
      uint64_t v20 = "L";
    }
    else {
      uint64_t v20 = "l";
    }
    if (v47[3]) {
      int v21 = "P";
    }
    else {
      int v21 = "0";
    }
    if (cf) {
      int v22 = "O";
    }
    else {
      int v22 = "0";
    }
    if (cf) {
      unint64_t v23 = CFDataGetLength(*((CFDataRef *)cf + 3)) / 0x14uLL;
    }
    else {
      unint64_t v23 = 0;
    }
    unint64_t v25 = (unint64_t)v40;
    if (v40) {
      unint64_t v25 = CFDataGetLength(*((CFDataRef *)v40 + 3)) / 0x14uLL;
    }
    *(_DWORD *)long long buf = 138413826;
    CFTypeRef v59 = v19;
    __int16 v60 = 2112;
    uint64_t v61 = v18;
    __int16 v62 = 2080;
    int v63 = v20;
    __int16 v64 = 2080;
    int v65 = v21;
    uint64_t v14 = v18;
    __int16 v66 = 2080;
    long long v67 = v22;
    __int16 v68 = 2048;
    unint64_t v69 = v23;
    __int16 v70 = 2048;
    unint64_t v71 = v25;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%@:%@: Send state for peer [%s%s%s] O: %zu, M: %zu", buf, 0x48u);
    a4 = v37;
    a5 = v38;
    a3 = v36;
  }

  if ((!v40 || (unint64_t)CFDataGetLength(*((CFDataRef *)v40 + 3)) <= 0x13)
    && (!cf || (unint64_t)CFDataGetLength(*((CFDataRef *)cf + 3)) <= 0x13))
  {
    if (!a3)
    {
      BOOL v29 = sub_10000B070("engine");
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        CFArrayRef v30 = *(const char **)(a1 + 24);
        *(_DWORD *)long long buf = 138412546;
        CFTypeRef v59 = v30;
        __int16 v60 = 2112;
        uint64_t v61 = a2;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%@:%@ backup still done", buf, 0x16u);
      }

      goto LABEL_43;
    }
    *((unsigned char *)v43 + 24) = 0;
  }
  v39[0] = _NSConcreteStackBlock;
  v39[1] = 3221225472;
  v39[2] = sub_100103DE4;
  v39[3] = &unk_1002FA5D8;
  v39[8] = v40;
  v39[9] = a1;
  v39[10] = v14;
  v39[11] = a6;
  uint8_t v39[4] = &v54;
  v39[5] = &v50;
  v39[12] = cf;
  v39[13] = a2;
  v39[6] = &v46;
  v39[7] = &v42;
  v39[14] = a4;
  v39[15] = a5;
  BOOL v26 = sub_100205E7C(a2, a6, v39);
  if (*((unsigned char *)v55 + 24)) {
    BOOL v27 = v26;
  }
  else {
    BOOL v27 = 0;
  }
  *((unsigned char *)v55 + 24) = v27;
  if (*((unsigned char *)v43 + 24))
  {
    int v28 = sub_10000B070("backup");
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136315138;
      CFTypeRef v59 = "writing changes to backup";
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "posting notification to CloudServices: %s", buf, 0xCu);
    }

    notify_post("com.apple.security.itembackup");
  }
LABEL_43:
  BOOL v31 = (const void *)v51[3];
  if (v31) {
    CFRelease(v31);
  }
  CFTypeRef v32 = cf;
  if (cf)
  {
    CFTypeRef cf = 0;
    CFRelease(v32);
  }
  CFTypeRef v33 = v40;
  if (v40)
  {
    CFTypeRef v40 = 0;
    CFRelease(v33);
  }
  int v34 = *((unsigned __int8 *)v55 + 24);
  _Block_object_dispose(&v42, 8);
  _Block_object_dispose(&v46, 8);
  _Block_object_dispose(&v50, 8);
  BOOL v24 = v34 != 0;
LABEL_50:
  _Block_object_dispose(&v54, 8);
  return v24;
}

void sub_100103D84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  _Block_object_dispose(&a31, 8);
  _Block_object_dispose(&a35, 8);
  _Block_object_dispose(&a39, 8);
  _Block_object_dispose((const void *)(v39 - 224), 8);
  _Unwind_Resume(a1);
}

void sub_100103DE4(uint64_t a1, FILE *a2, int a3)
{
  uint64_t v56 = 0;
  char v57 = &v56;
  uint64_t v58 = 0x4010000000;
  CFTypeRef v59 = "";
  long long v60 = 0u;
  long long v61 = 0u;
  uint64_t v50 = 0;
  uint64_t v51 = &v50;
  uint64_t v52 = 0x4010000000;
  CFTypeRef v53 = "";
  long long v54 = 0u;
  long long v55 = 0u;
  uint64_t v6 = *(void *)(a1 + 64);
  v47[0] = _NSConcreteStackBlock;
  v47[1] = 3221225472;
  v47[2] = sub_100104510;
  v47[3] = &unk_1002FA588;
  long long v48 = *(_OWORD *)(a1 + 72);
  uint64_t v49 = *(void *)(a1 + 88);
  uint64_t v7 = *(void *)(a1 + 32);
  void v47[4] = &v56;
  v47[5] = v7;
  v47[6] = a2;
  sub_100200E78(v6, (uint64_t)v47);
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    uint64_t v8 = *(void *)(a1 + 96);
    if (v8)
    {
      if ((unint64_t)CFDataGetLength(*(CFDataRef *)(v8 + 24)) >= 0x14)
      {
        CFArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        uint64_t v10 = *(void *)(a1 + 88);
        cf[1] = _NSConcreteStackBlock;
        CFTypeRef cf[2] = (CFTypeRef)3221225472;
        long long v11 = *(_OWORD *)(a1 + 72);
        uint64_t v12 = *(void *)(*(void *)(a1 + 72) + 16);
        cf[3] = sub_100104600;
        cf[4] = &unk_1002FA5B0;
        long long v43 = v11;
        int v46 = a3;
        CFArrayRef v44 = Mutable;
        uint64_t v45 = v10;
        CFTypeRef cf[5] = *(CFTypeRef *)(a1 + 32);
        cf[6] = &v50;
        cf[7] = a2;
        char v13 = (*(uint64_t (**)(void))(v12 + 32))();
        uint64_t v14 = *(void *)(*(void *)(a1 + 32) + 8);
        if (*(unsigned char *)(v14 + 24)) {
          char v15 = v13;
        }
        else {
          char v15 = 0;
        }
        *(unsigned char *)(v14 + 24) = v15;
        if (CFArrayGetCount(Mutable))
        {
          cf[0] = 0;
          if ((sub_100100734(*(void *)(a1 + 72), 0, 2, 0, Mutable, cf) & 1) == 0)
          {
            char v16 = sub_10000B070("SecError");
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)long long buf = 138412546;
              CFArrayRef v63 = Mutable;
              __int16 v64 = 2112;
              CFTypeRef v65 = cf[0];
              _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "SOSEngineUpdateChanges_locked: %@ failed: %@", buf, 0x16u);
            }
          }
          if (cf[0]) {
            CFRelease(cf[0]);
          }
          uint64_t v17 = *(void *)(*(void *)(a1 + 40) + 8);
          CFTypeRef v18 = sub_100100424(*(void *)(a1 + 72), *(void *)(a1 + 104));
          id v19 = *(const void **)(v17 + 24);
          if (v19) {
            CFRelease(v19);
          }
          *(void *)(v17 + 24) = v18;
          *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = sub_1002065A8(*(void *)(a1 + 104));
        }
        if (Mutable) {
          CFRelease(Mutable);
        }
      }
    }
  }
  if (v51[5] || (unint64_t v23 = v57, *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24)) && v57[5])
  {
    **(unsigned char **)(a1 + 112) = 1;
    uint64_t v20 = (const void *)sub_100201498((uint64_t)(v57 + 4), *(CFTypeRef **)(a1 + 88));
    int v21 = (const void *)sub_100201498((uint64_t)(v51 + 4), *(CFTypeRef **)(a1 + 88));
    int v22 = (const void *)sub_1002014F4(*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24), (uint64_t)v20, (uint64_t)v21, *(CFTypeRef **)(a1 + 88));
    if (v20) {
      CFRelease(v20);
    }
    if (v21) {
      CFRelease(v21);
    }
    sub_100206508((__CFArray **)(*(void *)(a1 + 104) + 80), v22);
    if (v22) {
      CFRelease(v22);
    }
    *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = sub_1002065A8(*(void *)(a1 + 104));
    unint64_t v23 = v57;
  }
  free((void *)v23[4]);
  void v23[4] = 0;
  void v23[5] = 0;
  *((unsigned char *)v23 + 56) = 0;
  v23[6] = 0;
  BOOL v24 = v51;
  free((void *)v51[4]);
  uint8_t v24[4] = 0;
  void v24[5] = 0;
  *((unsigned char *)v24 + 56) = 0;
  v24[6] = 0;
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    unint64_t v25 = *(const void **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    BOOL v26 = *(const void **)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
    if (v25 && v26)
    {
      if (CFEqual(v25, v26)) {
        goto LABEL_31;
      }
    }
    else if (v25 == v26)
    {
LABEL_31:
      cf[0] = 0;
      if (sub_1001FB3CC(a2, 899, (__CFString **)cf))
      {
        *(unsigned char *)(*(void *)(a1 + 104) + 49) = 1;
        **(unsigned char **)(a1 + 112) = 1;
        BOOL v27 = sub_10000B070("backup");
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          int v28 = *(const void **)(a1 + 80);
          CFArrayRef v29 = *(const __CFArray **)(*(void *)(a1 + 72) + 24);
          if (*(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24)) {
            CFArrayRef v30 = " notifying sbd";
          }
          else {
            CFArrayRef v30 = "";
          }
          *(_DWORD *)long long buf = 138412802;
          CFArrayRef v63 = v29;
          __int16 v64 = 2112;
          CFTypeRef v65 = v28;
          __int16 v66 = 2080;
          CFTypeRef v67 = v30;
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "%@:%@ backup done%s", buf, 0x20u);
        }
      }
      else
      {
        int v36 = sub_10000B070("SecWarning");
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v37 = *(const void **)(a1 + 80);
          CFArrayRef v38 = *(const __CFArray **)(*(void *)(a1 + 72) + 24);
          *(_DWORD *)long long buf = 138412802;
          CFArrayRef v63 = v38;
          __int16 v64 = 2112;
          CFTypeRef v65 = v37;
          __int16 v66 = 2112;
          CFTypeRef v67 = cf[0];
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%@:%@ in SOSBackupPeerWriteCompleteMarker: %@", buf, 0x20u);
        }

        *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
        **(unsigned char **)(a1 + 120) = 1;
        if (cf[0])
        {
          uint64_t v39 = *(CFTypeRef **)(a1 + 88);
          if (v39 && !*v39) {
            CFTypeRef *v39 = cf[0];
          }
          else {
            CFRelease(cf[0]);
          }
        }
      }
      goto LABEL_59;
    }
  }
  BOOL v31 = sub_10000B070("backup");
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    CFTypeRef v32 = *(const void **)(a1 + 80);
    CFArrayRef v33 = *(const __CFArray **)(*(void *)(a1 + 72) + 24);
    uint64_t v34 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    if (v34) {
      unint64_t v35 = CFDataGetLength(*(CFDataRef *)(v34 + 24)) / 0x14uLL;
    }
    else {
      unint64_t v35 = 0;
    }
    unint64_t v40 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
    if (v40) {
      unint64_t v40 = CFDataGetLength(*(CFDataRef *)(v40 + 24)) / 0x14uLL;
    }
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24)) {
      int v41 = " notifying sbd";
    }
    else {
      int v41 = "";
    }
    *(_DWORD *)long long buf = 138413314;
    CFArrayRef v63 = v33;
    __int16 v64 = 2112;
    CFTypeRef v65 = v32;
    __int16 v66 = 2048;
    CFTypeRef v67 = (CFTypeRef)v35;
    __int16 v68 = 2048;
    unint64_t v69 = v40;
    __int16 v70 = 2080;
    unint64_t v71 = v41;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "%@:%@ backup incomplete [%zu/%zu]%s", buf, 0x34u);
  }

  **(unsigned char **)(a1 + 120) = 1;
LABEL_59:
  _Block_object_dispose(&v50, 8);
  _Block_object_dispose(&v56, 8);
}

void sub_1001044BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  _Block_object_dispose(&a33, 8);
  _Block_object_dispose((const void *)(v33 - 208), 8);
  _Unwind_Resume(a1);
}

void sub_100104510(uint64_t a1, const __CFData *a2, unsigned char *a3)
{
  CFTypeRef cf = 0;
  if (ftello(*(FILE **)(a1 + 48)) < 64001)
  {
    if (sub_1001FB210(*(FILE **)(a1 + 48), a2, (__CFString **)&cf))
    {
      uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
      BytePtr = (long long *)CFDataGetBytePtr(a2);
      sub_100200054((char **)(v6 + 32), BytePtr);
      *(unsigned char *)(v6 + 56) = 1;
    }
    else
    {
      sub_100104940(*(void *)(a1 + 56), *(void *)(a1 + 64), a2, 0, (uint64_t)"in SOSPeerWriteDelete", (const __CFString *)cf);
      if (cf)
      {
        uint64_t v8 = *(CFTypeRef **)(a1 + 72);
        if (v8 && !*v8) {
          *uint64_t v8 = cf;
        }
        else {
          CFRelease(cf);
        }
      }
      *a3 = 1;
      *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
    }
  }
  else
  {
    *a3 = 1;
  }
}

void sub_100104600(uint64_t a1, const __CFData *a2, const void *a3, unsigned char *a4)
{
  CFTypeRef cf = 0;
  if (ftello(*(FILE **)(a1 + 48)) >= 64001)
  {
    *a4 = 1;
    return;
  }
  uint64_t v8 = *(void *)(a1 + 56);
  if (!a3)
  {
    sub_100104940(v8, *(void *)(a1 + 64), a2, 0, (uint64_t)"dropping from manifest: not found in datasource", 0);
    int v21 = *(__CFArray **)(a1 + 72);
    values = a2;
    CFArrayRef v9 = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
    CFArrayAppendValue(v21, v9);
    if (!v9) {
      return;
    }
    goto LABEL_29;
  }
  CFArrayRef v9 = (CFArrayRef)(*(uint64_t (**)(const void *, void, CFTypeRef *))(*(void *)(v8 + 16) + 144))(a3, *(int *)(a1 + 88), &cf);
  if (v9)
  {
    CFDataRef v10 = (const __CFData *)(*(uint64_t (**)(const void *, CFTypeRef *))(*(void *)(*(void *)(a1 + 56)
                                                                                             + 16)
                                                                                 + 112))(a3, &cf);
    if (v10)
    {
      CFDataRef v11 = v10;
      if (!CFEqual(a2, v10))
      {
        sub_100104940(*(void *)(a1 + 56), *(void *)(a1 + 64), a2, v11, (uint64_t)"", 0);
        uint64_t v12 = *(__CFArray **)(a1 + 72);
        values = a2;
        CFArrayRef v13 = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
        CFArrayAppendValue(v12, v13);
        if (v13) {
          CFRelease(v13);
        }
        CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 72), a3);
      }
      if (sub_1001FB314(*(FILE **)(a1 + 48), v9, (__CFString **)&cf))
      {
        uint64_t v14 = *(void *)(*(void *)(a1 + 40) + 8);
        BytePtr = (long long *)CFDataGetBytePtr(v11);
        sub_100200054((char **)(v14 + 32), BytePtr);
        *(unsigned char *)(v14 + 56) = 1;
      }
      else
      {
        sub_100104940(*(void *)(a1 + 56), *(void *)(a1 + 64), a2, 0, (uint64_t)"in SOSPeerWriteAdd", (const __CFString *)cf);
        *a4 = 1;
        if (cf)
        {
          unint64_t v23 = *(CFTypeRef **)(a1 + 80);
          if (v23 && !*v23) {
            CFTypeRef *v23 = cf;
          }
          else {
            CFRelease(cf);
          }
        }
        *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
      }
      CFRelease(v9);
      CFDataRef v24 = v11;
      goto LABEL_33;
    }
  }
  int OSStatus = SecErrorGetOSStatus();
  uint64_t v17 = *(void *)(a1 + 56);
  uint64_t v18 = *(void *)(a1 + 64);
  if (OSStatus == -26275)
  {
    sub_100104940(v17, v18, a2, 0, (uint64_t)"dropping from manifest", (const __CFString *)cf);
    id v19 = *(__CFArray **)(a1 + 72);
    values = a2;
    CFArrayRef v20 = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
    CFArrayAppendValue(v19, v20);
    if (v20) {
      CFRelease(v20);
    }
    CFRelease(cf);
    if (!v9) {
      return;
    }
LABEL_29:
    CFDataRef v24 = v9;
LABEL_33:
    CFRelease(v24);
    return;
  }
  sub_100104940(v17, v18, a2, 0, (uint64_t)"in SOSDataSourceForEachObject", (const __CFString *)cf);
  *a4 = 1;
  if (cf)
  {
    int v22 = *(CFTypeRef **)(a1 + 80);
    if (v22 && !*v22) {
      *int v22 = cf;
    }
    else {
      CFRelease(cf);
    }
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
  if (v9) {
    goto LABEL_29;
  }
}

void sub_100104940(uint64_t a1, uint64_t a2, CFDataRef theData, const __CFData *a4, uint64_t a5, const __CFString *a6)
{
  BytePtr = CFDataGetBytePtr(theData);
  if (a4)
  {
    uint64_t v12 = CFDataGetBytePtr(a4);
    CFArrayRef v13 = sub_10000B070("SecWarning");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = *(void *)(a1 + 24);
      int v15 = *BytePtr;
      int v16 = BytePtr[1];
      int v17 = BytePtr[2];
      int v18 = BytePtr[3];
      int v19 = *v12;
      int v20 = v12[1];
      int v21 = v12[2];
      int v22 = v12[3];
      int v32 = 138414594;
      uint64_t v33 = v14;
      __int16 v34 = 2112;
      uint64_t v35 = a2;
      __int16 v36 = 1024;
      int v37 = v15;
      __int16 v38 = 1024;
      int v39 = v16;
      __int16 v40 = 1024;
      int v41 = v17;
      __int16 v42 = 1024;
      int v43 = v18;
      __int16 v44 = 1024;
      *(_DWORD *)uint64_t v45 = v19;
      *(_WORD *)&v45[4] = 1024;
      *(_DWORD *)&v45[6] = v20;
      LOWORD(v46) = 1024;
      *(_DWORD *)((char *)&v46 + 2) = v21;
      HIWORD(v46) = 1024;
      int v47 = v22;
      unint64_t v23 = "%@:%@ object %02X%02X%02X%02X is really %02X%02X%02X%02X dropping from local manifest";
      CFDataRef v24 = v13;
      uint32_t v25 = 70;
LABEL_8:
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, v23, (uint8_t *)&v32, v25);
    }
  }
  else
  {
    CFArrayRef v13 = sub_10000B070("SecWarning");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v26 = *(void *)(a1 + 24);
      int v27 = *BytePtr;
      int v28 = BytePtr[1];
      int v29 = BytePtr[2];
      CFStringRef v30 = &stru_10030AA90;
      int v31 = BytePtr[3];
      if (a6) {
        CFStringRef v30 = a6;
      }
      int v32 = 138414082;
      uint64_t v33 = v26;
      __int16 v34 = 2112;
      uint64_t v35 = a2;
      __int16 v36 = 1024;
      int v37 = v27;
      __int16 v38 = 1024;
      int v39 = v28;
      __int16 v40 = 1024;
      int v41 = v29;
      __int16 v42 = 1024;
      int v43 = v31;
      __int16 v44 = 2080;
      *(void *)uint64_t v45 = a5;
      *(_WORD *)&v45[8] = 2112;
      CFStringRef v46 = v30;
      unint64_t v23 = "%@:%@ object %02X%02X%02X%02X %s: %@";
      CFDataRef v24 = v13;
      uint32_t v25 = 66;
      goto LABEL_8;
    }
  }
}

void sub_100104B58(uint64_t a1)
{
  sub_1000FEBD8(*(void *)(a1 + 40), *(CFTypeRef *)(a1 + 48), *(const __CFArray **)(a1 + 56), *(const __CFArray **)(a1 + 64));
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    uint64_t v2 = *(void *)(a1 + 40);
    if (*(void *)(v2 + 24))
    {
      if (CFArrayGetCount(*(CFArrayRef *)(v2 + 80)))
      {
        uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 80);
        activity_block[0] = _NSConcreteStackBlock;
        activity_block[1] = 3221225472;
        activity_block[2] = sub_10021C2D0;
        activity_block[3] = &unk_1003093A8;
        activity_void block[4] = v3;
        _os_activity_initiate((void *)&_mh_execute_header, "CloudCircle RequestSyncWithPeersList", OS_ACTIVITY_FLAG_DEFAULT, activity_block);
      }
    }
  }
}

uint64_t sub_100104C34(void *a1, uint64_t a2, unsigned char *a3)
{
  uint64_t result = sub_1000FD354(a1[6], a2, (CFTypeRef *)(*(void *)(a1[5] + 8) + 24));
  *a3 = result;
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = result;
  return result;
}

CFTypeRef sub_100104C7C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  CFSetRef V0ViewSet = (const void *)SOSViewsGetV0ViewSet();
  CFTypeRef result = sub_100100494(v2, V0ViewSet);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

void sub_100104CC0(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = *(void *)(a1 + 16);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  _OWORD v9[2] = sub_100104D70;
  v9[3] = &unk_1002FA600;
  id v10 = v5;
  uint64_t v11 = a1;
  uint64_t v7 = *(void (**)(uint64_t, uint64_t, void, void *))(v6 + 80);
  id v8 = v5;
  v7(v6, a2, 0, v9);
}

void sub_100104D70(uint64_t a1, uint64_t a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_100104DFC;
  v4[3] = &unk_1002FA140;
  uint64_t v3 = *(void *)(a1 + 40);
  id v5 = *(id *)(a1 + 32);
  uint64_t v6 = a2;
  dispatch_sync(*(dispatch_queue_t *)(v3 + 112), v4);
}

uint64_t sub_100104DFC(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40));
}

uint64_t sub_100104E10(uint64_t a1)
{
  uint64_t result = sub_100100734(*(void *)(a1 + 40), 0, 2, *(void *)(a1 + 48), *(const __CFArray **)(a1 + 56), *(CFTypeRef **)(a1 + 64));
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

BOOL sub_100104E54(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  id v7 = a4;
  if (-[OTSOSActualAdapter sosEnabled]_0())
  {
    uint64_t v16 = 0;
    int v17 = &v16;
    uint64_t v18 = 0x2020000000;
    char v19 = 1;
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_100104F78;
    void v10[3] = &unk_1002FA2F8;
    uint64_t v13 = a1;
    uint64_t v14 = a2;
    uint64_t v15 = a3;
    id v11 = v7;
    uint64_t v12 = &v16;
    sub_100104CC0(a1, a3, v10);
    BOOL v8 = *((unsigned char *)v17 + 24) != 0;

    _Block_object_dispose(&v16, 8);
  }
  else
  {
    SOSCCSetSOSDisabledError();
    BOOL v8 = 0;
  }

  return v8;
}

void sub_100104F60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100104F78(uint64_t a1)
{
  uint64_t v2 = sub_1000FCB54(*(void *)(a1 + 48), *(const void **)(a1 + 56), *(__CFArray **)(a1 + 64));
  if (v2)
  {
    uint64_t v3 = v2;
    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
    CFRelease(v3);
  }
  else
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
  }
}

void sub_100105000(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int16 v18 = 0;
  CFDataRef v5 = *(const __CFData **)(a3 + 112);
  if (v5)
  {
    uint64_t v6 = sub_100029C50(v5);
    id v7 = *(__CFData **)(a1 + 40);
    BOOL v8 = v6 == 0;
    if (v6) {
      BOOL v9 = v7 == 0;
    }
    else {
      BOOL v9 = 1;
    }
    if (!v9)
    {
      int v10 = CFEqual(v7, v6);
      BOOL v8 = 0;
      id v11 = v6;
      if (v10) {
        goto LABEL_7;
      }
LABEL_11:
      uint64_t v12 = 0;
      *(unsigned char *)(a3 + 4_Block_object_dispose(&STACK[0x3F0], 8) = 1;
      uint64_t v6 = v11;
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v6 = 0;
    id v7 = *(__CFData **)(a1 + 40);
    BOOL v8 = 1;
  }
  id v11 = v6;
  uint64_t v6 = v7;
  if (v7 != v11) {
    goto LABEL_11;
  }
LABEL_7:
  uint64_t v12 = (const void *)sub_100200FE0(*(const __CFData **)(a1 + 48), *(CFTypeRef **)(a1 + 56));
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v12 != 0;
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    sub_100206600(a3, v12);
    sub_100206508((__CFArray **)(a3 + 80), v12);
  }
LABEL_12:
  *(unsigned char *)(a3 + 49) = 0;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = sub_100103884(*(void *)(a1 + 64), a3, 1, (uint64_t)&v18 + 1, (uint64_t)&v18, *(CFTypeRef **)(a1 + 56));
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)
    && *(void *)(a1 + 56)
    && SecErrorGetOSStatus() == -25308)
  {
    if (qword_10035D268 != -1) {
      dispatch_once(&qword_10035D268, &stru_100306D28);
    }
    id v13 = (id)qword_10035D278;
    objc_sync_enter(v13);
    id v14 = [(id)qword_10035D270 operationCount];
    uint64_t v15 = sub_10000B070("engine");
    BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
    if (v14)
    {
      if (v16)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "SOSEnsureBackup: Backup already scheduled for next unlock", buf, 2u);
      }
    }
    else
    {
      if (v16)
      {
        *(_WORD *)char v19 = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "SOSEnsureBackup: Scheduling a backup for next unlock", v19, 2u);
      }

      uint64_t v15 = +[NSBlockOperation blockOperationWithBlock:&stru_100306D48];
      int v17 = [(id)qword_10035D278 unlockDependency];
      [v15 addNullableDependency:v17];

      [(id)qword_10035D270 addOperation:v15];
    }

    objc_sync_exit(v13);
  }
  if (v12) {
    CFRelease(v12);
  }
  if (!v8) {
    CFRelease(v6);
  }
}

void sub_10010528C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1001052A4(uint64_t a1)
{
  if (-[OTSOSActualAdapter sosEnabled]_0())
  {
    uint64_t v6 = 0;
    id v7 = &v6;
    uint64_t v8 = 0x2020000000;
    CFMutableArrayRef Mutable = (CFMutableArrayRef)0xAAAAAAAAAAAAAAAALL;
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    _DWORD v5[2] = sub_1001053E4;
    v5[3] = &unk_1002FA370;
    void v5[4] = &v6;
    uint64_t v2 = v5;
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1001053F8;
    block[3] = &unk_1002FA140;
    id v11 = v2;
    uint64_t v12 = a1;
    dispatch_sync(*(dispatch_queue_t *)(a1 + 112), block);

    uint64_t v3 = v7[3];
    _Block_object_dispose(&v6, 8);
  }
  else
  {
    SOSCCSetSOSDisabledError();
    return 0;
  }
  return v3;
}

void sub_1001053E4(uint64_t a1, uint64_t a2)
{
}

void sub_1001053F8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  id v2 = *(id *)(a1 + 32);
  uint64_t v4 = v1;
  id v5 = objc_retainBlock(v2);
  CFDictionaryRef Copy = CFDictionaryCreateCopy(0, *(CFDictionaryRef *)(v1 + 56));
  CFDictionaryApplyFunction(Copy, (CFDictionaryApplierFunction)sub_100105484, &v4);
  CFRelease(Copy);
}

void sub_100105470(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void sub_100105484(const void *a1, const void *a2, uint64_t *a3)
{
  if (sub_100205BF4((const __CFDictionary *)a2))
  {
    uint64_t v6 = sub_1000FDEDC(*a3, a1, a2, 0);
    if (v6)
    {
      id v7 = v6;
      (*(void (**)(void))(a3[1] + 16))();
      CFRelease(v7);
    }
  }
}

void *sub_100105514(void *result, uint64_t a2)
{
  id v2 = result;
  uint64_t v3 = *(void *)(a2 + 16);
  if (v3) {
    uint64_t result = CFRetain(*(CFTypeRef *)(a2 + 16));
  }
  *(void *)(*(void *)(v2[4] + 8) + 24) = v3;
  return result;
}

void sub_100105550(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  uint64_t v1 = *(const void **)(a1 + 48);
  id v3 = *(id *)(a1 + 32);
  uint64_t v7 = v2;
  id v8 = objc_retainBlock(v3);
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFDictionaryRef Copy = CFDictionaryCreateCopy(0, *(CFDictionaryRef *)(v2 + 56));
  CFSetRef Value = CFDictionaryGetValue(Copy, v1);
  if (Value)
  {
    CFDictionaryAddValue(Mutable, v1, Value);
    CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)sub_100105484, &v7);
  }
  CFRelease(Copy);
  CFRelease(Mutable);
}

void sub_100105630(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t sub_100105650(uint64_t a1, uint64_t a2)
{
  if (-[OTSOSActualAdapter sosEnabled]_0())
  {
    uint64_t v7 = 0;
    id v8 = &v7;
    uint64_t v9 = 0x2020000000;
    uint64_t v10 = 0;
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    _DWORD v6[2] = sub_100105738;
    v6[3] = &unk_1002FA2D0;
    void v6[4] = &v7;
    void v6[5] = a1;
    void v6[6] = a2;
    sub_100104CC0(a1, a2, v6);
    uint64_t v4 = v8[3];
    _Block_object_dispose(&v7, 8);
  }
  else
  {
    SOSCCSetSOSDisabledError();
    return 0;
  }
  return v4;
}

void sub_100105720(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

void sub_100105738(uint64_t a1)
{
  long long v4 = *(_OWORD *)(a1 + 40);
  CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  CFDictionaryRef v3 = *(const __CFDictionary **)(v4 + 64);
  context[0] = _NSConcreteStackBlock;
  context[1] = 3221225472;
  context[2] = sub_100105870;
  context[3] = &unk_1002FA3D0;
  long long v7 = v4;
  CFMutableArrayRef v8 = Mutable;
  CFDictionaryApplyFunction(v3, (CFDictionaryApplierFunction)sub_1000FE194, context);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  _DWORD v5[2] = sub_1001058EC;
  v5[3] = &unk_1002FA640;
  void v5[4] = v4;
  void v5[5] = Mutable;
  sub_1000FDB00(v4, v5);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = Mutable;
}

void sub_100105870(uint64_t a1, const void *a2)
{
  long long v4 = (CFDataRef *)sub_100100494(*(void *)(a1 + 32), a2);
  sub_100105984(*(__CFArray **)(a1 + 48), 0, v4, a2);
  if (v4)
  {
    CFRelease(v4);
  }
}

void sub_1001058EC(uint64_t a1, uint64_t a2)
{
  CFDictionaryRef v4 = *(const __CFDictionary **)(*(void *)(a1 + 32) + 96);
  if (v4)
  {
    CFStringRef Value = (const __CFString *)CFDictionaryGetValue(v4, *(const void **)(a2 + 16));
    if (!Value)
    {
      CFStringRef v6 = 0;
      goto LABEL_6;
    }
  }
  else
  {
    CFStringRef Value = @"Coders not loaded.";
  }
  CFStringRef v6 = CFCopyDescription(Value);
LABEL_6:
  sub_100105984(*(__CFArray **)(a1 + 40), *(void *)(a2 + 16), *(CFDataRef **)(a2 + 72), *(const void **)(a2 + 24));
  if (v6)
  {
    CFRelease(v6);
  }
}

void sub_100105984(__CFArray *a1, uint64_t a2, CFDataRef *a3, const void *a4)
{
  CFAllocatorRef v8 = kCFAllocatorDefault;
  if (a3) {
    unint64_t v9 = CFDataGetLength(a3[3]) / 0x14uLL;
  }
  else {
    unint64_t v9 = 0;
  }
  unint64_t valuePtr = v9;
  CFNumberRef v10 = CFNumberCreate(kCFAllocatorDefault, kCFNumberCFIndexType, &valuePtr);
  sub_100200D6C((__CFData *)a3);
  key = (void *)kSOSCCEngineStatePeerIDKey;
  if (a4)
  {
    CFGetTypeID(a4);
    CFSetGetTypeID();
    CFAllocatorRef v8 = kCFAllocatorDefault;
  }
  char v19 = sub_100105AF4(v8, v11, v12, v13, v14, v15, v16, v17, key, a2);
  if (v10) {
    CFRelease(v10);
  }
  CFArrayAppendValue(a1, v19);
  if (v19) {
    CFRelease(v19);
  }
}

__CFDictionary *sub_100105AF4(const __CFAllocator *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *key, uint64_t a10)
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  int v15 = (const void **)&a10;
  int v11 = key;
  if (key)
  {
    do
    {
      int v12 = v15;
      int v16 = v15 + 1;
      if (*v12) {
        CFDictionarySetValue(Mutable, v11, *v12);
      }
      int v13 = v16;
      int v15 = v16 + 1;
      int v11 = *v13;
    }
    while (*v13);
  }
  return Mutable;
}

void sub_100105B7C(id a1, __CFString *a2)
{
  CFDictionaryRef v3 = sub_10000B070("engineLogState");
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 138412290;
    id v5 = a2;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%@", (uint8_t *)&v4, 0xCu);
  }
}

void sub_100109FF4(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v11 = [v3 objectForKeyedSubscript:@"count(rowid)"];
  int v4 = [v11 asNSNumberInteger];
  id v5 = *(void **)(a1 + 32);
  CFStringRef v6 = [v3 objectForKeyedSubscript:@"state"];
  long long v7 = [v6 asString];
  CFAllocatorRef v8 = [v3 objectForKeyedSubscript:@"keyclass"];

  unint64_t v9 = [v8 asString];
  CFNumberRef v10 = +[NSString stringWithFormat:@"%@-%@", v7, v9];
  [v5 setObject:v4 forKeyedSubscript:v10];
}

void sub_10010A31C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10010A340(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10010A350(uint64_t a1)
{
}

void sub_10010A358(uint64_t a1, void *a2)
{
  id v6 = [a2 objectForKeyedSubscript:@"count(rowid)"];
  uint64_t v3 = [v6 asNSNumberInteger];
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  id v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;
}

void sub_10010C3DC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  id v3 = [*(id *)(a1 + 32) sanitizeErrorDomain:a2];
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v3);
}

void sub_10010C7A4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  id v3 = [*(id *)(a1 + 32) sanitizeErrorDomain:a2];
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v3);
}

void sub_10010CB70(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5)
{
  unint64_t v9 = *(void **)(a1 + 32);
  uint64_t v8 = *(void *)(a1 + 40);
  id v10 = a4;
  id v11 = a3;
  id v12 = a2;
  id v13 = [v9 sanitizeErrorDomain:a5];
  (*(void (**)(uint64_t, id, id, id, id))(v8 + 16))(v8, v12, v11, v10, v13);
}

void sub_10010CFAC(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 40);
  id v3 = [*(id *)(a1 + 32) sanitizeErrorDomain:a2];
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v3);
}

id sub_10010D31C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return [*(id *)(a1 + 32) setObject:a3 forKeyedSubscript:a2];
}

void sub_10010D8BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id *location, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id a18)
{
}

void sub_10010D8E8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  [WeakRetained allDependentsSuccessful];
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = [WeakRetained error];
  uint64_t v4 = CKXPCSuitableError();
  (*(void (**)(uint64_t, void *))(v2 + 16))(v2, v4);
}

void sub_10010DEC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id *location, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id a18)
{
}

void sub_10010DEF4(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  [WeakRetained allDependentsSuccessful];
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = [WeakRetained error];
  uint64_t v4 = CKXPCSuitableError();
  (*(void (**)(uint64_t, void *))(v2 + 16))(v2, v4);
}

void sub_10010E5D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10010E5FC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v3 = sub_1000CD884(@"ckks", 0);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = [WeakRetained error];
    int v8 = 138412290;
    unint64_t v9 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Ending rsync-local rpc with %@", (uint8_t *)&v8, 0xCu);
  }
  uint64_t v5 = *(void *)(a1 + 32);
  id v6 = [WeakRetained error];
  long long v7 = CKXPCSuitableError();
  (*(void (**)(uint64_t, void *))(v5 + 16))(v5, v7);
}

void sub_10010EAF4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10010EB20(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v3 = sub_1000CD884(@"ckks", 0);
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = [WeakRetained error];
    int v8 = 138412290;
    unint64_t v9 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Ending rsync-CloudKit rpc with %@", (uint8_t *)&v8, 0xCu);
  }
  uint64_t v5 = *(void *)(a1 + 32);
  id v6 = [WeakRetained error];
  long long v7 = CKXPCSuitableError();
  (*(void (**)(uint64_t, void *))(v5 + 16))(v5, v7);
}

void sub_10010F798(id a1, SOSAccountTransaction *a2)
{
  CFTypeRef cf = 0;
  CFMutableSetRef v2 = sub_1001ED2C8(a2, (uint64_t)&cf);
  if (cf)
  {
    id v3 = sub_1000CD884(@"backup", 0);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      CFTypeRef v8 = cf;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "Couldn't process sync with backup peers: %@", buf, 0xCu);
    }
  }
  else
  {
    uint64_t v4 = sub_1000CD884(@"ckksbackup", 0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "telling CloudServices about TLK arrival", buf, 2u);
    }

    notify_post("com.apple.security.itembackup");
  }
  CFTypeRef v5 = cf;
  if (cf)
  {
    CFTypeRef cf = 0;
    CFRelease(v5);
  }
}

void sub_100110DBC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_100110E68(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100110F18(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100111090(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1001111D8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100111580(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100111590(uint64_t a1)
{
}

void sub_100111598(uint64_t a1)
{
  id v9 = 0;
  CFMutableSetRef v2 = +[CKKSZoneStateEntry tryFromDatabase:&stru_10030AA90 zoneName:@"all" error:&v9];
  id v3 = v9;
  if (v3)
  {
    uint64_t v4 = sub_1000CD884(@"manager", 0);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 138412290;
      id v11 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, " couldn't load global zone state: %@", buf, 0xCu);
    }
  }
  else
  {
    id v6 = [v2 rateLimiter];

    if (v6)
    {
      CFTypeRef v5 = [v2 rateLimiter];
      goto LABEL_8;
    }
  }
  CFTypeRef v5 = objc_alloc_init(CKKSRateLimiter);
LABEL_8:
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
  CFTypeRef v8 = *(void **)(v7 + 40);
  *(void *)(v7 + 40) = v5;
}

void sub_1001116DC(id a1)
{
  id v3 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  dispatch_queue_t v1 = dispatch_queue_create("CKKS global zone state", v3);
  CFMutableSetRef v2 = (void *)qword_10035CEC0;
  qword_10035CEC0 = (uint64_t)v1;
}

void sub_1001119EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id *location, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,id a32)
{
}

id sub_100111A44(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  CFMutableSetRef v2 = WeakRetained;
  if (WeakRetained)
  {
    id v3 = [WeakRetained sosPeerAdapter];
    id v32 = 0;
    unsigned int v4 = [v3 circleStatus:&v32];
    id v5 = v32;

    if (v5)
    {
      id v6 = sub_1000CD884(@"manager", 0);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 138412290;
        id v36 = v5;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, " couldn't fetch sos status for SF report: %@", buf, 0xCu);
      }
    }
    uint64_t v7 = +[NSMutableDictionary dictionary];
    if (!v4)
    {
      CFTypeRef v8 = +[CKKSAnalytics logger];
      id v9 = +[NSDate date];
      [v8 setDateProperty:v9 forKey:@"lastInCircle"];
    }
    id v25 = v5;
    id v10 = +[NSNumber numberWithBool:v4 == 0];
    [v7 setObject:v10 forKeyedSubscript:@"inCircle"];

    int v27 = v2;
    id v11 = [v2 accountTracker];
    id v12 = [v11 currentCKAccountInfo];
    unsigned __int8 v13 = [v12 hasValidCredentials];

    if ((v13 & 1) == 0)
    {
      int v14 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", 0, v5);
      [v7 setObject:v14 forKeyedSubscript:@"validCredentials"];
    }
    v34[0] = @"lastUnlock";
    v34[1] = @"lastInCircle";
    +[NSArray arrayWithObjects:count:](NSArray, "arrayWithObjects:count:", v34, 2, v25);
    long long v28 = 0u;
    long long v29 = 0u;
    long long v30 = 0u;
    long long v31 = 0u;
    id v15 = (id)objc_claimAutoreleasedReturnValue();
    id v16 = [v15 countByEnumeratingWithState:&v28 objects:v33 count:16];
    if (v16)
    {
      id v17 = v16;
      uint64_t v18 = *(void *)v29;
      do
      {
        for (CFIndex i = 0; i != v17; CFIndex i = (char *)i + 1)
        {
          if (*(void *)v29 != v18) {
            objc_enumerationMutation(v15);
          }
          uint64_t v20 = *(void *)(*((void *)&v28 + 1) + 8 * i);
          int v21 = +[CKKSAnalytics logger];
          int v22 = [v21 datePropertyForKey:v20];

          unint64_t v23 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", +[CKKSAnalytics fuzzyDaysSinceDate:v22]);
          [v7 setObject:v23 forKeyedSubscript:v20];
        }
        id v17 = [v15 countByEnumeratingWithState:&v28 objects:v33 count:16];
      }
      while (v17);
    }

    CFMutableSetRef v2 = v27;
  }
  else
  {
    uint64_t v7 = 0;
  }

  return v7;
}

id sub_100111D88(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  if (!WeakRetained)
  {
    id v3 = 0;
    goto LABEL_40;
  }
  id v3 = +[NSMutableDictionary dictionary];
  unsigned int v4 = [*(id *)(a1 + 32) viewStateForName:*(void *)(a1 + 40)];
  if (v4)
  {
    id v5 = +[CKKSAnalytics logger];
    id v6 = [v4 zoneName];
    uint64_t v7 = [v5 dateOfLastSuccessForEvent:@"CKKSEventProcessIncomingQueueClassA" zoneName:v6];

    CFTypeRef v8 = +[CKKSAnalytics logger];
    id v9 = [v4 zoneName];
    uint64_t v10 = [v8 dateOfLastSuccessForEvent:@"CKKSEventProcessIncomingQueueClassC" zoneName:v9];

    id v11 = +[CKKSAnalytics logger];
    id v12 = [v4 zoneName];
    uint64_t v13 = [v11 datePropertyForKey:@"lastKSR" zoneName:v12];

    uint64_t v75 = (void *)v7;
    id v14 = +[CKKSAnalytics fuzzyDaysSinceDate:v7];
    CFArrayRef v74 = (void *)v10;
    id v15 = +[CKKSAnalytics fuzzyDaysSinceDate:v10];
    unsigned int v73 = (void *)v13;
    id v16 = +[CKKSAnalytics fuzzyDaysSinceDate:v13];
    unint64_t v70 = (unint64_t)v14;
    id v17 = +[NSNumber numberWithInteger:v14];
    uint64_t v18 = +[NSString stringWithFormat:@"%@-daysSinceClassASync", *(void *)(a1 + 40)];
    [v3 setValue:v17 forKey:v18];

    unint64_t v71 = (unint64_t)v15;
    char v19 = +[NSNumber numberWithInteger:v15];
    uint64_t v20 = +[NSString stringWithFormat:@"%@-daysSinceClassCSync", *(void *)(a1 + 40)];
    [v3 setValue:v19 forKey:v20];

    int v21 = +[NSNumber numberWithInteger:v16];
    int v22 = +[NSString stringWithFormat:@"%@-daysSinceLastKeystateReady", *(void *)(a1 + 40)];
    [v3 setValue:v21 forKey:v22];

    unint64_t v23 = [v4 contextID];
    CFDataRef v24 = [v4 zoneID];
    id v83 = 0;
    uint64_t v25 = +[CKKSMirrorEntry countsWithContextID:v23 zoneID:v24 error:&v83];
    id v26 = v83;

    int v79 = v26;
    if (v26 || !v25)
    {
      long long v29 = sub_1000CD884(@"manager", 0);
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
LABEL_12:

        long long v31 = [v4 contextID];
        id v32 = [v4 zoneID];
        id v82 = 0;
        uint64_t v33 = +[CKKSTLKShareRecord countsWithContextID:v31 zoneID:v32 error:&v82];
        id v34 = v82;

        int v78 = v34;
        int v80 = (void *)v33;
        if (v34 || !v33)
        {
          int v37 = sub_1000CD884(@"manager", 0);
          if (!os_log_type_enabled(v37, OS_LOG_TYPE_ERROR)) {
            goto LABEL_20;
          }
          __int16 v38 = [v4 zoneID];
          *(_DWORD *)long long buf = 138412546;
          uint64_t v85 = (uint64_t)v38;
          __int16 v86 = 2112;
          id v87 = v34;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "couldn't fetch CKKSTLKShare counts for %@: %@", buf, 0x16u);
        }
        else
        {
          uint64_t v35 = [v4 zoneName];
          id v36 = sub_1000CD884(@"metrics", v35);

          if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138412290;
            uint64_t v85 = (uint64_t)v80;
            _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "View has %@ tlkshares", buf, 0xCu);
          }

          int v37 = +[CKKSAnalytics fuzzyNumber:v80];
          __int16 v38 = +[NSString stringWithFormat:@"%@-%@", *(void *)(a1 + 40), @"numTLKShares"];
          [v3 setObject:v37 forKeyedSubscript:v38];
        }

LABEL_20:
        int v39 = [v4 contextID];
        __int16 v40 = [v4 zoneID];
        id v81 = 0;
        int v41 = +[CKKSKey countsWithContextID:v39 zoneID:v40 error:&v81];
        id v42 = v81;

        int v77 = v42;
        CFIndex v72 = (void *)v25;
        if (v42 || !v41)
        {
          uint64_t v45 = sub_1000CD884(@"manager", 0);
          if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
          {
            int v47 = [v4 zoneID];
            *(_DWORD *)long long buf = 138412546;
            uint64_t v85 = (uint64_t)v47;
            __int16 v86 = 2112;
            id v87 = v77;
            _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "couldn't fetch CKKSKey counts for %@: %@", buf, 0x16u);
          }
          CFStringRef v46 = v3;
        }
        else
        {
          int v43 = [v4 zoneName];
          __int16 v44 = sub_1000CD884(@"metrics", v43);

          if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138412290;
            uint64_t v85 = (uint64_t)v41;
            _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "View has %@ sync keys", buf, 0xCu);
          }

          uint64_t v45 = +[NSString stringWithFormat:@"%@-%@", *(void *)(a1 + 40), @"numSyncKeys"];
          [v3 setObject:v41 forKeyedSubscript:v45];
          CFStringRef v46 = v3;
        }

        long long v48 = [v4 viewKeyHierarchyState];
        id v49 = [v48 isEqualToString:@"ready"];

        uint64_t v50 = [*(id *)(a1 + 32) lastIncomingQueueOperation];
        [v50 error];
        uint64_t v51 = v76 = v4;

        uint64_t v52 = [*(id *)(a1 + 32) lastOutgoingQueueOperation];
        unint64_t v69 = [v52 error];

        __int16 v68 = +[NSString stringWithFormat:@"%@-%@", *(void *)(a1 + 40), @"TLKs"];
        uint64_t v53 = +[NSString stringWithFormat:@"%@-%@", *(void *)(a1 + 40), @"inSyncA"];
        CFTypeRef v67 = (void *)v53;
        long long v54 = +[NSString stringWithFormat:@"%@-%@", *(void *)(a1 + 40), @"inSyncC"];
        CFTypeRef v65 = +[NSString stringWithFormat:@"%@-%@", *(void *)(a1 + 40), @"IQNOE"];
        __int16 v66 = +[NSString stringWithFormat:@"%@-%@", *(void *)(a1 + 40), @"OQNOE"];
        long long v55 = +[NSNumber numberWithBool:v49];
        [v46 setObject:v55 forKeyedSubscript:v68];

        if (v70 < 7) {
          unsigned int v56 = v49;
        }
        else {
          unsigned int v56 = 0;
        }
        char v57 = +[NSNumber numberWithBool:v70 < 7];
        [v46 setObject:v57 forKeyedSubscript:v53];

        if (v71 >= 7) {
          unsigned int v56 = 0;
        }
        uint64_t v58 = +[NSNumber numberWithBool:v71 < 7];
        [v46 setObject:v58 forKeyedSubscript:v54];

        unsigned int v4 = v76;
        if (v51) {
          unsigned int v56 = 0;
        }
        CFTypeRef v59 = +[NSNumber numberWithBool:v51 == 0];
        [v46 setObject:v59 forKeyedSubscript:v65];

        if (v69) {
          uint64_t v60 = 0;
        }
        else {
          uint64_t v60 = v56;
        }
        long long v61 = +[NSNumber numberWithBool:v69 == 0];
        [v46 setObject:v61 forKeyedSubscript:v66];

        __int16 v62 = +[NSString stringWithFormat:@"%@-%@", *(void *)(a1 + 40), @"inSync"];
        CFArrayRef v63 = +[NSNumber numberWithBool:v60];
        [v46 setObject:v63 forKeyedSubscript:v62];

        id v3 = v46;
        goto LABEL_39;
      }
      long long v30 = [v4 zoneID];
      *(_DWORD *)long long buf = 138412546;
      uint64_t v85 = (uint64_t)v30;
      __int16 v86 = 2112;
      id v87 = v79;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "couldn't fetch CKMirror counts for %@: %@", buf, 0x16u);
    }
    else
    {
      int v27 = [v4 zoneName];
      long long v28 = sub_1000CD884(@"metrics", v27);

      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        uint64_t v85 = v25;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "View has %@ item ckrecords", buf, 0xCu);
      }

      long long v29 = +[CKKSAnalytics fuzzyNumber:v25];
      long long v30 = +[NSString stringWithFormat:@"%@-%@", *(void *)(a1 + 40), @"numItems"];
      [v3 setObject:v29 forKeyedSubscript:v30];
    }

    goto LABEL_12;
  }
LABEL_39:

LABEL_40:

  return v3;
}

void sub_100112938(uint64_t a1)
{
  id v4 = +[OTManager manager];
  id v2 = objc_alloc_init((Class)OTControlArguments);
  unsigned __int8 v3 = [v4 waitForReady:v2 wait:2000000000];

  if ((v3 & 1) == 0) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
  }
}

void sub_10011313C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100113168(uint64_t a1, void *a2, uint64_t a3, void *a4)
{
  id v6 = a2;
  id v7 = a4;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v9 = +[CKKSAnalytics logger];
  [v9 logResultForEvent:@"OctagonEventFetchViews" hardFailure:1 result:v7];

  if (v7)
  {
    uint64_t v10 = sub_10000B070("SecError");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v25 = v7;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "octagon: failed to retrieve policy+views: %@", buf, 0xCu);
    }

    [WeakRetained setError:v7];
  }
  else
  {
    id v11 = sub_10000B070("octagon-ckks");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      id v12 = [v6 viewList];
      *(_DWORD *)long long buf = 138412546;
      id v25 = v6;
      __int16 v26 = 2112;
      int v27 = v12;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Received syncing policy %@ with view list: %@", buf, 0x16u);
    }
    uint64_t v13 = [WeakRetained deps];
    id v14 = [v13 stateHolder];
    v22[0] = _NSConcreteStackBlock;
    v22[1] = 3221225472;
    v22[2] = sub_100113468;
    v22[3] = &unk_100307118;
    id v15 = v6;
    id v23 = v15;
    id v21 = 0;
    [v14 persistAccountChanges:v22 error:&v21];
    id v16 = v21;

    if (v16)
    {
      id v17 = sub_10000B070("SecError");
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v25 = v16;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "octagon: failed to save policy+views: %@", buf, 0xCu);
      }

      [WeakRetained setError:v16];
    }
    else
    {
      uint64_t v18 = [WeakRetained deps];
      char v19 = [v18 ckks];
      [v19 setCurrentSyncingPolicy:v15];

      uint64_t v20 = [WeakRetained intendedState];
      [WeakRetained setNextState:v20];
    }
  }
}

id sub_100113468(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 setTPSyncingPolicy:*(void *)(a1 + 32)];

  return v3;
}

void sub_100115848(id a1)
{
  v4[0] = kSecAttrAccessGroup;
  v4[1] = kSecAttrSharingGroup;
  v4[2] = kSecAttrKeyType;
  v4[3] = kSecAttrApplicationTag;
  void v4[4] = kSecAttrLabel;
  void v4[5] = kSecAttrApplicationLabel;
  void v4[6] = kSecValueData;
  void v4[7] = kSecAttrKeySizeInBits;
  void v4[8] = kSecAttrEffectiveKeySize;
  v4[9] = kSecAttrCreationDate;
  v4[10] = kSecAttrModificationDate;
  dispatch_queue_t v1 = +[NSArray arrayWithObjects:v4 count:11];
  uint64_t v2 = +[NSSet setWithArray:v1];
  id v3 = (void *)qword_10035CED0;
  qword_10035CED0 = v2;
}

void sub_100117054(uint64_t a1)
{
  id v2 = objc_alloc((Class)_SFAuthenticatedEncryptionOperation);
  id v5 = [*(id *)(a1 + 32) keySpecifier];
  id v3 = [v2 initWithKeySpecifier:v5];
  id v4 = (void *)qword_10035CF00;
  qword_10035CF00 = (uint64_t)v3;
}

void sub_10011716C(uint64_t a1)
{
  id v2 = objc_alloc((Class)_SFAuthenticatedEncryptionOperation);
  id v5 = [*(id *)(a1 + 32) keySpecifier];
  id v3 = [v2 initWithKeySpecifier:v5];
  id v4 = (void *)qword_10035CEF0;
  qword_10035CEF0 = (uint64_t)v3;
}

void sub_1001171E4(id a1)
{
  qword_10035CEE0 = (uint64_t)[objc_alloc((Class)_SFAESKeySpecifier) initWithBitSize:2];

  _objc_release_x1();
}

id sub_1001173AC(uint64_t a1)
{
  return [*(id *)(a1 + 32) _onqueueSetNetworkReachability:*(unsigned __int8 *)(a1 + 40)];
}

void sub_100117708(_Unwind_Exception *a1)
{
  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v3 - 72));
  _Unwind_Resume(a1);
}

void sub_100117738(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v2 = [WeakRetained queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100117858;
  block[3] = &unk_100308558;
  void block[4] = WeakRetained;
  dispatch_sync(v2, block);
}

void sub_1001177CC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v4 = WeakRetained;
    id v2 = [WeakRetained timer];

    id WeakRetained = v4;
    if (v2)
    {
      uint64_t v3 = +[CKKSAnalytics logger];
      [v3 noteEvent:@"CKKSEventReachabilityTimerExpired"];

      [v4 _onQueueRunReachabilityDependency];
      id WeakRetained = v4;
    }
  }
}

void sub_100117858(uint64_t a1)
{
  unsigned int v2 = [*(id *)(a1 + 32) haveNetwork];
  uint64_t v3 = sub_1000CD884(@"network", 0);
  BOOL v4 = os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      LOWORD(v5) = 0;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Network available", (uint8_t *)&v5, 2u);
    }
  }
  else
  {
    if (v4)
    {
      int v5 = 134217984;
      uint64_t v6 = 0x4028000000000000;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Network still not available, retrying after waiting %2.1f hours", (uint8_t *)&v5, 0xCu);
    }

    [*(id *)(a1 + 32) _onQueueResetReachabilityDependency];
  }
}

void sub_100117B0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_100117B24(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) haveNetwork];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = (_BYTE)result;
  return result;
}

void sub_100117D98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

id sub_100117DC0(uint64_t a1)
{
  return [*(id *)(a1 + 32) _onQueueResetReachabilityDependency];
}

void sub_100117DC8(uint64_t a1, void *a2)
{
  unsigned int v2 = (id *)(a1 + 32);
  uint64_t v3 = a2;
  id WeakRetained = objc_loadWeakRetained(v2);
  nw_path_status_t status = nw_path_get_status(v3);

  uint64_t v6 = sub_1000CD884(@"ckksnetwork", 0);
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
  {
    CFStringRef v7 = @"unavailable";
    if (status == nw_path_status_satisfied) {
      CFStringRef v7 = @"available";
    }
    int v8 = 138412290;
    CFStringRef v9 = v7;
    _os_log_debug_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEBUG, "nw_path update: network is %@", (uint8_t *)&v8, 0xCu);
  }

  [WeakRetained _onqueueSetNetworkReachability:status == nw_path_status_satisfied];
}

uint64_t sub_100118974(void *a1, uint64_t a2, __CFString **a3)
{
  uint64_t v3 = a1[2];
  if (!v3) {
    goto LABEL_7;
  }
  uint64_t v4 = 0;
  int v5 = a1 + 3;
  do
  {
    if (*(_DWORD *)(v3 + 8) == a2) {
      uint64_t v4 = v3;
    }
    uint64_t v6 = *v5++;
    uint64_t v3 = v6;
  }
  while (v6);
  if (!v4)
  {
LABEL_7:
    sub_100012A40(-26276, a3, @"Can't find attribute of kind %d in class %@", a2, *a1);
    return 0;
  }
  return v4;
}

CFDataRef sub_1001189E0(uint64_t a1, __CFString **a2)
{
  CFNumberRef v2 = (CFNumberRef)&stru_10030AA90;
  switch(*(_DWORD *)(a1 + 8))
  {
    case 0:
    case 1:
    case 0x10:
      return CFDataCreate(kCFAllocatorDefault, 0, 0);
    case 2:
    case 0xE:
    case 0xF:
      goto LABEL_12;
    case 3:
    case 0xB:
    case 0xC:
      int valuePtr = 0;
      CFNumberRef v2 = CFNumberCreate(kCFAllocatorDefault, kCFNumberSInt32Type, &valuePtr);
      goto LABEL_12;
    case 4:
      CFAllocatorRef v5 = kCFAllocatorDefault;
      double Current = 0.0;
      goto LABEL_8;
    case 5:
    case 6:
      double Current = CFAbsoluteTimeGetCurrent();
      CFAllocatorRef v5 = kCFAllocatorDefault;
LABEL_8:
      CFDataRef result = CFDateCreate(v5, Current);
      break;
    default:
      sub_100012A40(-26276, a2, @"attr %@ has no default value", *(void *)a1);
      CFNumberRef v2 = 0;
LABEL_12:
      CFDataRef result = v2;
      break;
  }
  return result;
}

__CFDictionary *sub_100118B3C(void *a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  CFMutableArrayRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  uint64_t v9 = a1[2];
  uint64_t v10 = *(void **)(v9 + 16);
  if (!v10) {
    return Mutable;
  }
  for (CFIndex i = (void *)(v9 + 24); ; ++i)
  {
    uint64_t v12 = v10[2];
    if ((a2 & ~v12) == 0)
    {
      if ((v12 & a3) != 0) {
        return Mutable;
      }
      uint64_t v13 = sub_100118CF8(a1, (uint64_t)v10, a4);
      if (!v13) {
        goto LABEL_17;
      }
      id v14 = v13;
      if (!CFEqual(kCFNull, v13))
      {
        CFDictionarySetValue(Mutable, (const void *)*v10, v14);
        goto LABEL_10;
      }
      if ((*((unsigned char *)v10 + 17) & 0x10) != 0) {
        break;
      }
    }
LABEL_10:
    id v15 = (void *)*i;
    uint64_t v10 = v15;
    if (!v15) {
      return Mutable;
    }
  }
  sub_100012A40(-26275, a4, @"attribute %@ has NULL value", *v10);
  id v16 = sub_10000B070("SecError");
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    if (a4) {
      CFStringRef v18 = *a4;
    }
    else {
      CFStringRef v18 = @"error == NULL";
    }
    *(_DWORD *)long long buf = 138412290;
    CFStringRef v21 = v18;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%@", buf, 0xCu);
  }
LABEL_17:
  if (Mutable)
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

const void *sub_100118CF8(const void *a1, uint64_t a2, __CFString **a3)
{
  if (!a2) {
    return 0;
  }
  unint64_t v6 = *(void *)(a2 + 16);
  if ((v6 & 0x20A0) != 0 && !sub_100118DFC(a1, (v6 >> 5) & 1, a3)) {
    return 0;
  }
  CFStringRef v7 = (void *)sub_1001193FC((uint64_t)a1, (const void **)a2);
  if (v7) {
    return v7;
  }
  CFDataRef v8 = sub_1001194FC(a1, a2);
  if (!v8) {
    return 0;
  }
  CFDataRef v9 = v8;
  CFStringRef v7 = kCFNull;
  if (CFEqual(kCFNull, v8))
  {
    CFRelease(v9);
    return v7;
  }
  sub_1001196B4((uint64_t)a1, (void *)a2, v9, a3);
  CFRelease(v9);

  return sub_1001193FC((uint64_t)a1, (const void **)a2);
}

BOOL sub_100118DFC(uint64_t a1, int a2, __CFString **a3)
{
  int v3 = *(_DWORD *)(a1 + 40);
  if (v3 == 6) {
    int v4 = a2;
  }
  else {
    int v4 = 0;
  }
  BOOL v5 = v3 != 1 && v4 == 0;
  if (v5 || (CFDataRef v9 = (const void **)sub_100118974(*(void **)(a1 + 16), 9, a3)) == 0)
  {
    char v20 = 1;
    return v20 & 1;
  }
  CFDataRef v10 = (const __CFData *)sub_1001193FC(a1, v9);
  if (v10)
  {
    *(_DWORD *)(a1 + 40) = 3;
    CFTypeRef cf = 0;
    CFDictionaryRef theDict = 0;
    unsigned int v46 = 0;
    if (!sub_100015484(*(unsigned int *)(a1 + 28), *(void *)(a1 + 32), *(char **)(a1 + 64), &cf, *(const __CFData **)(a1 + 56), v10, *(void *)(a1 + 16), *(const __CFString **)(a1 + 72), (const void **)&theDict, &v46, a2, 0, a3))goto LABEL_54; {
    if (v46 > 1)
    }
    {
      if (theDict)
      {
        int v22 = sub_10011A93C(a1, theDict, a3);
LABEL_26:
        BOOL v16 = v22;
        goto LABEL_50;
      }
    }
    else
    {
      CFDataRef Value = (const __CFData *)CFDictionaryGetValue(theDict, @"v_Data");
      if (sub_10011A9B8(a1, @"v_Data", Value, a3))
      {
        uint64_t v12 = sub_100119CB8((void *)a1, kSecAttrAccessGroup);
        uint64_t v13 = sub_100119CB8((void *)a1, kSecAttrAccessible);
        if (!v12) {
          goto LABEL_19;
        }
        id v14 = v13;
        CFTypeID v15 = CFGetTypeID(v12);
        BOOL v16 = 1;
        if (v15 != CFStringGetTypeID() || !v14)
        {
LABEL_50:
          id v34 = sub_100125608((void **)a1, a3);
          if (v34)
          {
            uint64_t v35 = v34;
            uint64_t Protection = (const void *)SecAccessControlGetProtection();
            int v37 = (const void *)SecAccessControlGetProtection();
            if (!CFEqual(Protection, v37))
            {
              uint64_t v38 = SecAccessControlGetProtection();
              uint64_t v39 = SecAccessControlGetProtection();
              BOOL v16 = sub_100012A40(-26275, a3, @"ACL protection doesn't match the one in blob (%@ : %@)", v38, v39);
            }
            CFRelease(v35);
            goto LABEL_55;
          }
LABEL_54:
          BOOL v16 = 0;
LABEL_55:
          int v40 = sub_10011AC34(a1, (uint64_t)cf, 0);
          if (theDict) {
            CFRelease(theDict);
          }
          if (cf) {
            CFRelease(cf);
          }
          if (a2) {
            int v41 = 2;
          }
          else {
            int v41 = 6;
          }
          char v20 = v40 & v16;
          if ((v40 & v16) == 0) {
            int v41 = 1;
          }
          *(_DWORD *)(a1 + 40) = v41;
          return v20 & 1;
        }
        CFTypeID v17 = CFGetTypeID(v14);
        if (v17 != CFStringGetTypeID()) {
          goto LABEL_19;
        }
        uint64_t v18 = *(void *)(a1 + 16);
        if (v18 == sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008)
          && CFEqual(v14, kSecAttrAccessibleAlwaysPrivate))
        {
          id v23 = sub_100119CB8((void *)a1, kSecAttrService);
          if (!v23) {
            goto LABEL_19;
          }
          CFDataRef v24 = v23;
          CFTypeID v25 = CFGetTypeID(v23);
          if (v25 != CFStringGetTypeID() || !CFEqual(v12, @"apple")) {
            goto LABEL_19;
          }
          if (CFEqual(v24, @"AirPort"))
          {
LABEL_32:
            __int16 v26 = &kSecAttrAccessibleAfterFirstUnlock;
LABEL_36:
            CFDataRef v27 = (const __CFData *)*v26;
            uint64_t v28 = a1;
            CFStringRef v29 = kSecAttrAccessible;
LABEL_37:
            int v22 = sub_10011A9B8(v28, v29, v27, a3);
            goto LABEL_26;
          }
          if (!CFEqual(v24, @"com.apple.airplay.password"))
          {
            if (CFEqual(v24, @"YouTube"))
            {
              if (sub_10011A9B8(a1, kSecAttrAccessible, (const __CFData *)kSecAttrAccessibleWhenUnlocked, a3))
              {
                CFDataRef v27 = (const __CFData *)@"com.apple.youtube.credentials";
                uint64_t v28 = a1;
                CFStringRef v29 = kSecAttrAccessGroup;
                goto LABEL_37;
              }
              goto LABEL_49;
            }
            int v43 = sub_100119CB8((void *)a1, kSecAttrDescription);
            if (v43)
            {
              __int16 v44 = v43;
              CFTypeID v45 = CFGetTypeID(v43);
              if (v45 == CFStringGetTypeID()
                && (CFEqual(v44, @"IPSec Shared Secret") || CFEqual(v44, @"PPP Password")))
              {
                goto LABEL_32;
              }
            }
LABEL_19:
            BOOL v16 = 1;
            goto LABEL_50;
          }
        }
        else
        {
          uint64_t v19 = *(void *)(a1 + 16);
          if (v19 != sub_10000C75C(@"inet", &qword_10035D020, (uint64_t)&unk_10035D018)
            || !CFEqual(v14, kSecAttrAccessibleAlwaysPrivate))
          {
            goto LABEL_19;
          }
          if (!CFEqual(v12, @"PrintKitAccessGroup"))
          {
            if (!CFEqual(v12, @"apple")) {
              goto LABEL_19;
            }
            CFNumberRef v30 = (const __CFNumber *)sub_100119CB8((void *)a1, kSecAttrProtocol);
            if (!v30) {
              goto LABEL_19;
            }
            CFNumberRef v31 = v30;
            CFTypeID v32 = CFGetTypeID(v30);
            if (v32 == CFNumberGetTypeID())
            {
              int valuePtr = -1431655766;
              CFNumberGetValue(v31, kCFNumberSInt32Type, &valuePtr);
              if (valuePtr > 2020635749)
              {
                if (valuePtr > 2020832359)
                {
                  if (valuePtr == 2020832370) {
                    goto LABEL_35;
                  }
                  int v33 = 2020832360;
                }
                else
                {
                  if (valuePtr == 2020635750) {
                    goto LABEL_35;
                  }
                  int v33 = 2020635752;
                }
              }
              else if (valuePtr > 1752462199)
              {
                if (valuePtr == 1752462200) {
                  goto LABEL_35;
                }
                int v33 = 1920234360;
              }
              else
              {
                if (valuePtr == 1718907000) {
                  goto LABEL_35;
                }
                int v33 = 1752461432;
              }
              if (valuePtr != v33) {
                goto LABEL_19;
              }
            }
            else
            {
              CFTypeID v42 = CFGetTypeID(v31);
              if (v42 != CFStringGetTypeID()
                || !CFEqual(v31, kSecAttrProtocolHTTPProxy)
                && !CFEqual(v31, kSecAttrProtocolHTTPSProxy)
                && !CFEqual(v31, kSecAttrProtocolRTSPProxy)
                && !CFEqual(v31, kSecAttrProtocolFTPProxy))
              {
                goto LABEL_19;
              }
            }
          }
        }
LABEL_35:
        __int16 v26 = &kSecAttrAccessibleWhenUnlocked;
        goto LABEL_36;
      }
    }
LABEL_49:
    BOOL v16 = 0;
    goto LABEL_50;
  }

  return sub_100012A40(-26276, a3, @"state= encrypted but edata is NULL");
}

const void *sub_1001193FC(uint64_t a1, const void **a2)
{
  if (!a1)
  {
    unint64_t v6 = sub_10000B070("SecError");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v12 = 0;
      CFStringRef v7 = "secitem: item is nil!";
      CFDataRef v8 = (uint8_t *)&v12;
LABEL_14:
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v7, v8, 2u);
    }
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 48);
  if (!a2 || !v2)
  {
    unint64_t v6 = sub_10000B070("SecError");
    BOOL v9 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
    if (v2)
    {
      if (v9)
      {
        __int16 v10 = 0;
        CFStringRef v7 = "secitem: desc is nil!";
        CFDataRef v8 = (uint8_t *)&v10;
        goto LABEL_14;
      }
    }
    else if (v9)
    {
      *(_WORD *)long long buf = 0;
      CFStringRef v7 = "secitem: item->attributes is nil!";
      CFDataRef v8 = buf;
      goto LABEL_14;
    }
    return 0;
  }
  int v3 = *a2;
  CFDictionaryRef v4 = *(const __CFDictionary **)(a1 + 48);

  return CFDictionaryGetValue(v4, v3);
}

CFDataRef sub_1001194FC(const void *a1, uint64_t a2)
{
  uint64_t v2 = *(uint64_t (**)(void))(a2 + 24);
  if (v2)
  {
    return (CFDataRef)v2();
  }
  else
  {
    CFStringRef v4 = 0;
    int v5 = *(_DWORD *)(a2 + 8);
    switch(v5)
    {
      case 0:
      case 2:
      case 14:
      case 15:
        uint64_t v6 = *(void *)(a2 + 16);
        if ((v6 & 0x1000) == 0) {
          goto LABEL_15;
        }
        if ((v6 & 0x400) != 0)
        {
          CFStringRef v4 = @"0";
          goto LABEL_25;
        }
        if (v5 && (v6 & 0x800) != 0)
        {
          CFStringRef v4 = &stru_10030AA90;
          goto LABEL_25;
        }
        goto LABEL_15;
      case 1:
        uint64_t v6 = *(void *)(a2 + 16);
LABEL_15:
        if ((~(_WORD)v6 & 0x1800) == 0) {
          goto LABEL_16;
        }
        goto LABEL_24;
      case 3:
      case 11:
      case 12:
        if ((*(unsigned char *)(a2 + 17) & 0x10) == 0) {
          goto LABEL_24;
        }
        int valuePtr = 0;
        CFAllocatorRef v7 = CFGetAllocator(a1);
        CFStringRef v4 = (const __CFString *)CFNumberCreate(v7, kCFNumberSInt32Type, &valuePtr);
        goto LABEL_25;
      case 4:
        if ((~*(_DWORD *)(a2 + 16) & 0x1400) != 0) {
          goto LABEL_24;
        }
        CFAllocatorRef v10 = kCFAllocatorDefault;
        double Current = 0.0;
LABEL_21:
        return CFDateCreate(v10, Current);
      case 5:
      case 6:
        CFAllocatorRef v8 = CFGetAllocator(a1);
        double Current = CFAbsoluteTimeGetCurrent();
        CFAllocatorRef v10 = v8;
        goto LABEL_21;
      case 8:
      case 13:
LABEL_24:
        CFStringRef v4 = (const __CFString *)kCFNull;
        goto LABEL_25;
      case 16:
LABEL_16:
        CFAllocatorRef v11 = CFGetAllocator(a1);
        return CFDataCreate(v11, 0, 0);
      default:
LABEL_25:
        CFDataRef result = (CFDataRef)v4;
        break;
    }
  }
  return result;
}

uint64_t sub_1001196B4(uint64_t a1, void *a2, const __CFData *a3, __CFString **a4)
{
  if (!a2) {
    return 0;
  }
  if (a3) {
    CFDataRef v7 = a3;
  }
  else {
    CFDataRef v7 = kCFNull;
  }
  CFAllocatorRef v8 = (uint64_t (*)(uint64_t))a2[4];
  if (!v8)
  {
    if ((a2[2] & 0x2080) != 0)
    {
      uint64_t result = sub_100118DFC(a1, 1, a4);
      if (!result) {
        return result;
      }
    }
    switch(*((_DWORD *)a2 + 2))
    {
      case 0:
      case 0xF:
        CFDataRef v10 = (const __CFData *)sub_10000E4C0(v7);
        goto LABEL_24;
      case 1:
      case 0xA:
        CFDataRef v10 = sub_10000E3E0((const __CFString *)v7);
        goto LABEL_24;
      case 2:
      case 0xE:
        CFDataRef v10 = (const __CFData *)sub_10000E568((const __CFString *)v7);
        goto LABEL_24;
      case 3:
      case 8:
      case 0xB:
      case 0xC:
        CFDataRef v10 = sub_10000E2F0(v7);
        goto LABEL_24;
      case 4:
      case 5:
      case 6:
        CFDataRef v10 = (const __CFData *)sub_100017DBC(v7);
        goto LABEL_24;
      case 7:
        CFDataRef v10 = sub_100004398(v7);
        goto LABEL_24;
      case 9:
        CFDataRef v11 = sub_10000E3E0((const __CFString *)v7);
        if (v11)
        {
          CFDataRef v12 = v11;
          if (*(_DWORD *)(a1 + 40) == 4) {
            int v13 = 2;
          }
          else {
            int v13 = 1;
          }
          *(_DWORD *)(a1 + 40) = v13;
LABEL_25:
          CFDataRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 48), (const void *)*a2);
          if (Value)
          {
            int v16 = CFEqual(Value, v12);
            CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 48), (const void *)*a2, v12);
            CFRelease(v12);
            if (!v16) {
              goto LABEL_36;
            }
            return 1;
          }
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 48), (const void *)*a2, v12);
          CFRelease(v12);
LABEL_36:
          uint64_t v19 = a2[2];
          if ((v19 & 0x100) != 0)
          {
            uint64_t v20 = sub_100118974(*(void **)(a1 + 16), 7, 0);
            sub_1001196B4(a1, v20, kCFNull, 0);
            uint64_t v19 = a2[2];
          }
          if (v19)
          {
            uint64_t v21 = sub_100118974(*(void **)(a1 + 16), 10, 0);
            sub_1001196B4(a1, v21, kCFNull, 0);
            uint64_t v19 = a2[2];
          }
          if ((v19 & 0x2080) != 0)
          {
            int v22 = *(_DWORD *)(a1 + 40);
            if (v22 == 2 || v22 == 6 && (v19 & 0x20) == 0)
            {
              uint64_t v23 = sub_100118974(*(void **)(a1 + 16), 9, 0);
              sub_1001196B4(a1, v23, kCFNull, 0);
              uint64_t v19 = a2[2];
            }
          }
          if ((v19 & 8) == 0) {
            return 1;
          }
          CFDataRef v24 = *(__CFDictionary **)(a1 + 48);
          CFTypeID v25 = (const void *)sub_100119A68(a2);
          __int16 v26 = v24;
          goto LABEL_48;
        }
        if (!v7 || CFEqual(kCFNull, v7))
        {
          *(_DWORD *)(a1 + 40) = 0;
LABEL_32:
          if (!v7) {
            goto LABEL_34;
          }
        }
        if (CFEqual(kCFNull, v7))
        {
LABEL_34:
          CFTypeID v17 = CFDictionaryGetValue(*(CFDictionaryRef *)(a1 + 48), (const void *)*a2);
          if (!v17)
          {
            __int16 v26 = *(__CFDictionary **)(a1 + 48);
            CFTypeID v25 = (const void *)*a2;
LABEL_48:
            CFDictionaryRemoveValue(v26, v25);
            return 1;
          }
          int v18 = CFEqual(v17, kCFNull);
          CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 48), (const void *)*a2);
          if (v18) {
            return 1;
          }
          goto LABEL_36;
        }
        sub_100012A40(-50, a4, @"attribute %@: value: %@ failed to convert", *a2, v7);
        break;
      case 0xD:
        CFDataRef v14 = (const __CFData *)sub_100119A28(v7);
        if (!v14) {
          goto LABEL_32;
        }
        CFDataRef v12 = v14;
        CFRetain(v14);
        goto LABEL_25;
      case 0x10:
        CFDataRef v10 = sub_100004024(v7);
LABEL_24:
        CFDataRef v12 = v10;
        if (v10) {
          goto LABEL_25;
        }
        goto LABEL_32;
      default:
        goto LABEL_32;
    }
    return 0;
  }

  return v8(a1);
}

const void *sub_100119A28(const void *a1)
{
  if (!a1) {
    return 0;
  }
  dispatch_queue_t v1 = a1;
  CFTypeID v2 = CFGetTypeID(a1);
  if (v2 != CFBooleanGetTypeID()) {
    return 0;
  }
  return v1;
}

uint64_t sub_100119A68(unsigned char *a1)
{
  if ((a1[16] & 8) == 0) {
    return *(void *)a1;
  }
  if (qword_10035CF20 != -1) {
    dispatch_once(&qword_10035CF20, &stru_1002FACF8);
  }
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000;
  unint64_t v8 = 0xAAAAAAAAAAAAAAAALL;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_100119B54;
  v4[3] = &unk_1002FAD20;
  void v4[4] = &v5;
  void v4[5] = a1;
  dispatch_sync((dispatch_queue_t)qword_10035CF30, v4);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_100119B54(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CFDictionaryGetValue((CFDictionaryRef)qword_10035CF28, **(const void ***)(a1 + 40));
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CFStringCreateWithFormat(0, 0, @"#%@", **(void **)(a1 + 40));
    CFDictionarySetValue((CFMutableDictionaryRef)qword_10035CF28, **(const void ***)(a1 + 40), *(const void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
    uint64_t v2 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    CFRelease(v2);
  }
}

void sub_100119C1C(id a1)
{
  qword_10035CF30 = (uint64_t)dispatch_queue_create("secd-hash-name", 0);
  qword_10035CF28 = (uint64_t)CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
}

void sub_100119C6C(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 56);
  if (v3 != cf)
  {
    if (!cf || (CFRetain(cf), (CFTypeRef v3 = *(CFTypeRef *)(a1 + 56)) != 0)) {
      CFRelease(v3);
    }
    *(void *)(a1 + 56) = cf;
  }
}

const void *sub_100119CB8(void *a1, CFTypeRef cf2)
{
  if (!a1 || !cf2 || (CFDictionaryRef v4 = (const __CFDictionary *)a1[6]) == 0 || (result = CFDictionaryGetValue(v4, cf2)) == 0)
  {
    uint64_t v6 = a1[2];
    uint64_t v7 = *(CFTypeRef **)(v6 + 16);
    if (v7)
    {
      unint64_t v8 = (CFTypeRef **)(v6 + 24);
      while (!CFEqual(*v7, cf2))
      {
        BOOL v9 = *v8++;
        uint64_t v7 = v9;
        if (!v9) {
          return 0;
        }
      }
      return sub_100118CF8(a1, (uint64_t)v7, 0);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_100119D58(uint64_t a1)
{
  uint64_t result = _CFRuntimeRegisterClass();
  **(void **)(a1 + 32) = result;
  return result;
}

__CFString *sub_100119D8C(void **a1)
{
  uint64_t v2 = (const void *)sub_100025824();

  return sub_100119DC8(a1, v2);
}

__CFString *sub_100119DC8(void **a1, CFTypeRef cf)
{
  if (cf
    && (CFTypeID v4 = CFGetTypeID(cf), v4 == CFDictionaryGetTypeID())
    && CFDictionaryContainsKey((CFDictionaryRef)cf, @"debug"))
  {
    CFAllocatorRef v5 = CFGetAllocator(a1);
    CFMutableArrayRef Mutable = CFStringCreateMutable(v5, 0);
    CFStringAppendFormat(Mutable, 0, @"<%@", *a1[2]);
    uint64_t v7 = a1[2];
    uint64_t v8 = v7[2];
    if (v8)
    {
      BOOL v9 = v7 + 3;
      do
      {
        if (*(unsigned char *)(v8 + 16)) {
          sub_10011A4C0(a1, (CFStringRef *)v8, Mutable);
        }
        uint64_t v10 = *v9++;
        uint64_t v8 = v10;
      }
      while (v10);
    }
    CFStringAppend(Mutable, @", |otherAttr");
    CFDataRef v11 = a1[2];
    CFDataRef v12 = (CFStringRef *)v11[2];
    if (v12)
    {
      int v13 = (CFStringRef **)(v11 + 3);
      do
      {
        if (*v12 && CFEqual(@"tomb", *v12)) {
          sub_10011A4C0(a1, v12, Mutable);
        }
        CFDataRef v14 = *v13++;
        CFDataRef v12 = v14;
      }
      while (v14);
      CFTypeID v15 = a1[2];
      uint64_t v16 = v15[2];
      if (v16)
      {
        CFTypeID v17 = v15 + 3;
        do
        {
          if ((*(unsigned char *)(v16 + 16) & 1) == 0 && (!*(void *)v16 || !CFEqual(@"tomb", *(CFTypeRef *)v16))) {
            sub_10011A4C0(a1, (CFStringRef *)v16, Mutable);
          }
          uint64_t v18 = *v17++;
          uint64_t v16 = v18;
        }
        while (v18);
      }
    }
    CFStringAppend(Mutable, @">");
  }
  else
  {
    int v87 = 0;
    __int16 valuePtr = 0;
    uint64_t v85 = 0;
    long long v88 = 0u;
    long long v89 = 0u;
    uint64_t v19 = CFStringCreateMutable(kCFAllocatorDefault, 0);
    uint64_t v20 = a1[2];
    uint64_t v23 = v20[2];
    uint64_t v21 = v20 + 2;
    uint64_t v22 = v23;
    CFDataRef v24 = &v88;
    if (v23)
    {
      id v83 = 0;
      CFArrayRef v84 = 0;
      CFTypeID v25 = 0;
      CFTypeRef v80 = (CFTypeRef)kSecAttrMultiUser;
      BytePtr = (const UInt8 *)&v87;
      __int16 v26 = (const UInt8 *)&v87;
      do
      {
        switch(*(_DWORD *)(v22 + 8))
        {
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 9:
            if ((*(unsigned char *)(v22 + 16) & 0x30) != 0)
            {
              CFDataRef v27 = sub_100118CF8(a1, v22, 0);
              if (v27)
              {
                uint64_t v28 = v27;
                if (!CFEqual(v27, kCFNull))
                {
                  CFTypeID v29 = CFGetTypeID(v28);
                  if (v29 != CFStringGetTypeID() || !CFEqual(*(CFTypeRef *)v22, kSecAttrAccessGroup))
                  {
                    CFStringAppend(v19, @",");
                    goto LABEL_70;
                  }
                  id v83 = v28;
                }
              }
            }
            break;
          case 6:
            CFDateRef v30 = (const __CFDate *)sub_100118CF8(a1, v22, 0);
            if (v30)
            {
              CFDateRef v31 = v30;
              CFTypeID v32 = CFGetTypeID(v30);
              if (v32 == CFDateGetTypeID())
              {
                double AbsoluteTime = CFDateGetAbsoluteTime(v31);
                CFDataRef v24 = (long long *)sub_100012404(0, 0, (uint64_t)v24, (unint64_t)&v89 + 15, AbsoluteTime);
              }
            }
            break;
          case 7:
            CFDataRef v34 = (const __CFData *)sub_100118CF8(a1, v22, 0);
            if (v34)
            {
              CFDataRef v35 = v34;
              CFTypeID v36 = CFGetTypeID(v34);
              if (v36 == CFDataGetTypeID() && CFDataGetLength(v35) >= 4) {
                BytePtr = CFDataGetBytePtr(v35);
              }
            }
            break;
          case 8:
            CFNumberRef v46 = (const __CFNumber *)sub_100118CF8(a1, v22, 0);
            if (v46)
            {
              CFNumberRef v47 = v46;
              CFTypeID v48 = CFGetTypeID(v46);
              if (v48 == CFNumberGetTypeID())
              {
                p___int16 valuePtr = (char *)&v85;
                CFNumberRef v49 = v47;
                CFNumberType v50 = kCFNumberSInt64Type;
                goto LABEL_56;
              }
            }
            break;
          case 0xA:
            CFDataRef v51 = (const __CFData *)sub_100118CF8(a1, v22, 0);
            if (v51)
            {
              CFDataRef v52 = v51;
              CFTypeID v53 = CFGetTypeID(v51);
              if (v53 == CFDataGetTypeID()) {
                __int16 v26 = CFDataGetBytePtr(v52);
              }
            }
            break;
          case 0xB:
            CFNumberRef v54 = (const __CFNumber *)sub_100118CF8(a1, v22, 0);
            if (v54)
            {
              CFNumberRef v38 = v54;
              CFTypeID v55 = CFGetTypeID(v54);
              if (v55 == CFNumberGetTypeID())
              {
                p___int16 valuePtr = (char *)&valuePtr + 1;
                goto LABEL_55;
              }
            }
            break;
          case 0xC:
            CFNumberRef v37 = (const __CFNumber *)sub_100118CF8(a1, v22, 0);
            if (v37)
            {
              CFNumberRef v38 = v37;
              CFTypeID v39 = CFGetTypeID(v37);
              if (v39 == CFNumberGetTypeID())
              {
                p___int16 valuePtr = (char *)&valuePtr;
LABEL_55:
                CFNumberRef v49 = v38;
                CFNumberType v50 = kCFNumberCharType;
LABEL_56:
                CFNumberGetValue(v49, v50, p_valuePtr);
              }
            }
            break;
          case 0xD:
            int v41 = sub_100118CF8(a1, v22, 0);
            if (v41)
            {
              CFTypeID v42 = v41;
              CFTypeID v43 = CFGetTypeID(v41);
              BOOL v44 = v43 != CFBooleanGetTypeID();
              CFTypeID v45 = v84;
              if (!v44) {
                CFTypeID v45 = v42;
              }
              CFArrayRef v84 = v45;
            }
            break;
          case 0xE:
            unsigned int v56 = sub_100118CF8(a1, v22, 0);
            if (v56)
            {
              char v57 = v56;
              CFTypeID v58 = CFGetTypeID(v56);
              if (v58 == CFStringGetTypeID()) {
                CFTypeID v25 = v57;
              }
            }
            break;
          case 0x10:
            CFTypeRef v59 = sub_100118CF8(a1, v22, 0);
            if (v59)
            {
              uint64_t v60 = v59;
              if (CFEqual(*(CFTypeRef *)v22, v80))
              {
                CFTypeID v61 = CFGetTypeID(v60);
                if (v61 == CFDataGetTypeID())
                {
                  CFStringAppend(v19, @",");
                  if (CFDataGetLength((CFDataRef)v60))
                  {
                    __int16 v62 = CFDataGetBytePtr((CFDataRef)v60);
                    CFIndex Length = CFDataGetLength((CFDataRef)v60);
                    if (Length >= 1)
                    {
                      CFIndex v64 = Length;
                      do
                      {
                        unsigned int v65 = *v62++;
                        CFStringAppendFormat(v19, 0, @"%02X", v65);
                        --v64;
                      }
                      while (v64);
                    }
                  }
                  else
                  {
LABEL_70:
                    CFStringAppend(v19, *(CFStringRef *)v22);
                  }
                }
              }
            }
            break;
          default:
            break;
        }
        uint64_t v66 = v21[1];
        ++v21;
        uint64_t v22 = v66;
      }
      while (v66);
    }
    else
    {
      CFTypeID v25 = 0;
      id v83 = 0;
      CFArrayRef v84 = 0;
      __int16 v26 = (const UInt8 *)&v87;
      BytePtr = (const UInt8 *)&v87;
    }
    cf2 = v19;
    CFTypeRef v81 = v25;
    CFAllocatorRef v67 = CFGetAllocator(a1);
    if ((_BYTE)valuePtr) {
      __int16 v68 = "T";
    }
    else {
      __int16 v68 = "O";
    }
    uint64_t v69 = *a1[2];
    uint64_t v70 = *v26;
    uint64_t v71 = v26[1];
    uint64_t v72 = v26[2];
    uint64_t v73 = v26[3];
    if (HIBYTE(valuePtr)) {
      CFArrayRef v74 = "S";
    }
    else {
      CFArrayRef v74 = "L";
    }
    uint64_t v75 = v85;
    if (v84)
    {
      int v76 = CFEqual(v84, kCFBooleanFalse);
      int v77 = "F,";
      if (!v76) {
        int v77 = "T,";
      }
    }
    else
    {
      int v77 = "";
    }
    CFMutableArrayRef Mutable = (__CFString *)CFStringCreateWithFormat(v67, 0, @"%s,%@,%02X%02X%02X%02X,%s,%@,%@,%lld%@,%s,%s%02X%02X%02X%02X", v68, v69, v70, v71, v72, v73, v74, v81, v83, v75, cf2, v24, v77, *BytePtr, BytePtr[1], BytePtr[2],
                              BytePtr[3]);
    if (cf2) {
      CFRelease(cf2);
    }
  }
  return Mutable;
}

void sub_10011A4C0(const void *a1, CFStringRef *a2, __CFString *a3)
{
  if (!CFEqual(@"data", *a2) && !CFEqual(@"v_pk", *a2))
  {
    CFNullRef v6 = (const __CFNull *)sub_100118CF8(a1, (uint64_t)a2, 0);
    if (v6)
    {
      CFDataRef v7 = v6;
      if (v6 != kCFNull)
      {
        CFStringAppend(a3, @",");
        CFStringAppend(a3, *a2);
        CFStringAppend(a3, @"=");
        if (CFEqual(@"data", *a2))
        {
          BytePtr = CFDataGetBytePtr(v7);
          CFIndex Length = CFDataGetLength(v7);
          if ((Length & 0x8000000000000000) == 0)
          {
            unint64_t v10 = Length;
            CFStringAppendFormat(a3, 0, @"%04lx:", Length);
            if (v10 > 8)
            {
              CNCRC();
              for (uint64_t i = 0; i != 8; ++i)
                CFStringAppendFormat(a3, 0, @"%02X", BytePtr[i]);
              CFStringAppendFormat(a3, 0, @"...|%08llx", 0);
            }
            else
            {
              for (; v10; --v10)
              {
                unsigned int v11 = *BytePtr++;
                CFStringAppendFormat(a3, 0, @"%02X", v11);
              }
            }
          }
        }
        else if (CFEqual(@"v_Data", *a2))
        {
          CFStringAppend(a3, @"<?>");
        }
        else
        {
          CFTypeID v13 = CFGetTypeID(v7);
          if (v13 == CFDataGetTypeID())
          {
            sub_10011A6F4(a3, v7);
          }
          else
          {
            CFStringAppendFormat(a3, 0, @"%@", v7);
          }
        }
      }
    }
  }
}

void sub_10011A6F4(__CFString *a1, CFDataRef theData)
{
  BytePtr = CFDataGetBytePtr(theData);
  CFIndex Length = CFDataGetLength(theData);
  if (Length >= 1)
  {
    CFIndex v6 = Length;
    do
    {
      unsigned int v7 = *BytePtr++;
      CFStringAppendFormat(a1, 0, @"%02X", v7);
      --v6;
    }
    while (v6);
  }
}

uint64_t sub_10011A770(void **a1)
{
  uint64_t v2 = sub_100118974(a1[2], 7, 0);
  CFDataRef v3 = (const __CFData *)sub_100118CF8(a1, v2, 0);
  return *(int *)CFDataGetBytePtr(v3);
}

uint64_t sub_10011A7B8(void **a1, void **a2)
{
  CFDataRef v3 = a1;
  if (a1)
  {
    uint64_t v4 = sub_100118974(a1[2], 7, 0);
    CFDataRef v3 = sub_100118CF8(v3, v4, 0);
  }
  if (a2)
  {
    uint64_t v5 = sub_100118974(a2[2], 7, 0);
    CFIndex v6 = sub_100118CF8(a2, v5, 0);
  }
  else
  {
    CFIndex v6 = 0;
  }

  return CFEqual(v3, v6);
}

void sub_10011A848(void *a1)
{
  uint64_t v2 = (const void *)a1[6];
  if (v2) {
    CFRelease(v2);
  }
  CFDataRef v3 = (const void *)a1[7];
  if (v3) {
    CFRelease(v3);
  }
  uint64_t v4 = (const void *)a1[9];
  if (v4) {
    CFRelease(v4);
  }
  uint64_t v5 = (const void *)a1[8];
  if (v5)
  {
    CFRelease(v5);
  }
}

BOOL sub_10011A8B0(uint64_t a1, int a2, __CFString **a3)
{
  BOOL v5 = sub_100118DFC(a1, 1, a3);
  if (v5 && *(_DWORD *)(a1 + 28) != a2)
  {
    *(_DWORD *)(a1 + 2_Block_object_dispose(&STACK[0x3F0], 8) = a2;
    *(void *)(a1 + 32) = 0;
    if (*(_DWORD *)(a1 + 40) == 2)
    {
      CFIndex v6 = (void *)sub_100118974(*(void **)(a1 + 16), 9, 0);
      sub_1001196B4(a1, v6, kCFNull, 0);
    }
  }
  return v5;
}

uint64_t sub_10011A93C(uint64_t a1, CFDictionaryRef theDict, __CFString **a3)
{
  uint64_t v3 = *(void *)(a1 + 16);
  uint64_t v4 = *(const void ***)(v3 + 16);
  if (!v4) {
    return 1;
  }
  for (uint64_t i = (const void ***)(v3 + 24); ; ++i)
  {
    CFDataRef Value = (const __CFData *)CFDictionaryGetValue(theDict, *v4);
    if (Value)
    {
      uint64_t result = sub_1001196B4(a1, v4, Value, a3);
      if (!result) {
        break;
      }
    }
    unsigned int v11 = *i;
    uint64_t v4 = v11;
    if (!v11) {
      return 1;
    }
  }
  return result;
}

uint64_t sub_10011A9B8(uint64_t a1, CFTypeRef cf2, const __CFData *a3, __CFString **a4)
{
  uint64_t v4 = *(void *)(a1 + 16);
  BOOL v5 = *(CFTypeRef **)(v4 + 16);
  if (!v5) {
    return 0;
  }
  unint64_t v10 = (CFTypeRef **)(v4 + 24);
  while (!CFEqual(*v5, cf2))
  {
    unsigned int v11 = *v10++;
    BOOL v5 = v11;
    if (!v11) {
      return 0;
    }
  }

  return sub_1001196B4(a1, v5, a3, a4);
}

void sub_10011AA54(uint64_t a1, const void *a2, uint64_t *a3)
{
  CFTypeRef cf = 0;
  CFDataRef v5 = (const __CFData *)sub_100118CF8(a2, (uint64_t)a3, (__CFString **)&cf);
  if (cf)
  {
    CFIndex v6 = sub_10000B070("secitem");
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_5;
    }
    uint64_t v7 = *a3;
    *(_DWORD *)long long buf = 138412546;
    uint64_t v16 = v7;
    __int16 v17 = 2112;
    CFTypeRef v18 = cf;
    uint64_t v8 = "Merging: unable to get attribute (%@) : %@";
    goto LABEL_4;
  }
  CFDataRef v10 = v5;
  if (v5 && (!kCFNull || !CFEqual(v5, kCFNull)))
  {
    unsigned int v11 = sub_10000B070("secitem");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v13 = *a3;
      *(_DWORD *)long long buf = 138412290;
      uint64_t v16 = v13;
      _os_log_debug_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "Preserving existing data for %@", buf, 0xCu);
    }
    sub_1001196B4(a1, a3, v10, (__CFString **)&cf);
    if (cf)
    {
      CFIndex v6 = sub_10000B070("secitem");
      if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
LABEL_5:
        CFTypeRef v9 = cf;
        if (cf)
        {
          CFTypeRef cf = 0;
          CFRelease(v9);
        }
        return;
      }
      uint64_t v12 = *a3;
      *(_DWORD *)long long buf = 138412546;
      uint64_t v16 = v12;
      __int16 v17 = 2112;
      CFTypeRef v18 = cf;
      uint64_t v8 = "Unable to set attribute (%@) : %@";
LABEL_4:
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, v8, buf, 0x16u);
      goto LABEL_5;
    }
  }
}

uint64_t sub_10011AC34(uint64_t a1, uint64_t a2, __CFString **a3)
{
  if (*(_DWORD *)(a1 + 40) == 2)
  {
    CFIndex v6 = (void *)sub_100118974(*(void **)(a1 + 16), 9, a3);
    uint64_t result = sub_1001196B4(a1, v6, kCFNull, a3);
    if (!a2) {
      return result;
    }
  }
  else
  {
    uint64_t result = 1;
    if (!a2) {
      return result;
    }
  }
  if (result)
  {
    *(_DWORD *)(a1 + 40) = 0;
    CFDataRef v8 = (const __CFData *)SecAccessControlCopyData();
    CFTypeRef v9 = (void *)sub_100118974(*(void **)(a1 + 16), 15, a3);
    uint64_t v10 = sub_1001196B4(a1, v9, v8, a3);
    CFRelease(v8);
    return v10;
  }
  return result;
}

const void *sub_10011ACF4(uint64_t a1, const __CFDictionary *a2, int a3, __CFString **a4)
{
  uint64_t v6 = sub_10011AD64(kCFAllocatorDefault, a1, a3, 0);
  uint64_t v7 = (const void *)v6;
  if (v6 && (sub_10011A93C(v6, a2, a4) & 1) == 0)
  {
    CFRelease(v7);
    return 0;
  }
  return v7;
}

uint64_t sub_10011AD64(const __CFAllocator *a1, uint64_t a2, int a3, uint64_t a4)
{
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100119D58;
  block[3] = &unk_1002FA8A0;
  void block[4] = &qword_10035CF18;
  if (qword_10035CF10 != -1) {
    dispatch_once(&qword_10035CF10, block);
  }
  uint64_t Instance = _CFRuntimeCreateInstance();
  *(void *)(Instance + 16) = a2;
  *(void *)(Instance + 4_Block_object_dispose(&STACK[0x3F0], 8) = CFDictionaryCreateMutable(a1, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  *(_DWORD *)(Instance + 2_Block_object_dispose(&STACK[0x3F0], 8) = a3;
  *(void *)(Instance + 32) = a4;
  *(_DWORD *)(Instance + 40) = 0;
  *(void *)(Instance + 64) = @"od";
  return Instance;
}

void *sub_10011AE7C(const __CFAllocator *a1, sqlite3_stmt *a2, uint64_t a3, int iCol)
{
  uint64_t result = 0;
  switch(*(_DWORD *)(a3 + 8))
  {
    case 0:
    case 3:
      switch(sqlite3_column_type(a2, iCol))
      {
        case 1:
          goto LABEL_9;
        case 2:
          double valuePtr = sqlite3_column_double(a2, iCol);
          CFAllocatorRef v11 = a1;
          CFNumberType v12 = kCFNumberDoubleType;
          goto LABEL_18;
        case 3:
          goto LABEL_12;
        case 4:
          goto LABEL_2;
        case 5:
          uint64_t result = kCFNull;
          break;
        default:
          uint64_t result = 0;
          break;
      }
      break;
    case 1:
    case 7:
    case 9:
    case 0xA:
    case 0x10:
LABEL_2:
      uint64_t result = sub_10011B1A8(a1, a2, iCol);
      break;
    case 2:
    case 0xE:
LABEL_12:
      uint64_t v10 = *(void *)(a3 + 16);
      uint64_t result = (void *)sub_10011B0FC(a1, a2, iCol, v10);
      break;
    case 4:
    case 5:
    case 6:
      double v9 = sqlite3_column_double(a2, iCol);
      uint64_t result = CFDateCreate(a1, v9);
      break;
    case 8:
      double valuePtr = COERCE_DOUBLE(sqlite3_column_int64(a2, iCol));
      CFAllocatorRef v11 = a1;
      CFNumberType v12 = kCFNumberSInt64Type;
LABEL_18:
      uint64_t result = CFNumberCreate(v11, v12, &valuePtr);
      break;
    case 0xB:
    case 0xC:
LABEL_9:
      uint64_t result = sub_10011B098(a1, a2, iCol);
      break;
    default:
      return result;
  }
  return result;
}

CFNumberRef sub_10011B098(const __CFAllocator *a1, sqlite3_stmt *a2, int iCol)
{
  sqlite3_int64 v4 = sqlite3_column_int64(a2, iCol);
  sqlite3_int64 valuePtr = v4;
  if (v4 == (int)v4)
  {
    int v9 = v4;
    p_sqlite3_int64 valuePtr = (sqlite3_int64 *)&v9;
    CFAllocatorRef v6 = a1;
    CFNumberType v7 = kCFNumberSInt32Type;
  }
  else
  {
    p_sqlite3_int64 valuePtr = &valuePtr;
    CFAllocatorRef v6 = a1;
    CFNumberType v7 = kCFNumberSInt64Type;
  }
  return CFNumberCreate(v6, v7, p_valuePtr);
}

CFStringRef sub_10011B0FC(const __CFAllocator *a1, sqlite3_stmt *a2, int iCol, __int16 a4)
{
  CFAllocatorRef v6 = sqlite3_column_text(a2, iCol);
  if (v6 && (CFNumberType v7 = v6, (v8 = strlen((const char *)v6)) != 0))
  {
    return CFStringCreateWithBytes(a1, v7, v8, 0x8000100u, 0);
  }
  else if ((a4 & 0x800) != 0)
  {
    return &stru_10030AA90;
  }
  else if ((a4 & 0x400) != 0)
  {
    return @"0";
  }
  else
  {
    return (CFStringRef)kCFNull;
  }
}

CFDataRef sub_10011B1A8(const __CFAllocator *a1, sqlite3_stmt *a2, int iCol)
{
  CFAllocatorRef v6 = (const UInt8 *)sqlite3_column_blob(a2, iCol);
  CFIndex v7 = sqlite3_column_bytes(a2, iCol);

  return CFDataCreate(a1, v6, v7);
}

uint64_t sub_10011B210(const __CFAllocator *a1, void *a2, sqlite3_stmt *a3, int a4, uint64_t a5)
{
  uint64_t v8 = sub_10011AD64(a1, (uint64_t)a2, a4, 0);
  int v9 = (unsigned char *)a2[2];
  if (!v9) {
    return v8;
  }
  int v10 = 0;
  for (uint64_t i = 3; ; ++i)
  {
    if (!(*(unsigned int (**)(uint64_t, unsigned char *))(a5 + 16))(a5, v9)) {
      goto LABEL_6;
    }
    CFNumberType v12 = sub_10011AE7C(a1, a3, (uint64_t)v9, v10);
    if (!v12) {
      break;
    }
    uint64_t v13 = v12;
    ++v10;
    CFDataRef v14 = *(__CFDictionary **)(v8 + 48);
    CFTypeID v15 = (const void *)sub_100119A68(v9);
    CFDictionarySetValue(v14, v15, v13);
    CFRelease(v13);
LABEL_6:
    uint64_t v16 = (const void **)sub_100118974(a2, 9, 0);
    if (v16 && CFDictionaryGetValue(*(CFDictionaryRef *)(v8 + 48), *v16)) {
      *(_DWORD *)(v8 + 40) = 1;
    }
    int v9 = (unsigned char *)a2[i];
    if (!v9) {
      return v8;
    }
  }
  if (v8)
  {
    CFRelease((CFTypeRef)v8);
    return 0;
  }
  return v8;
}

const void *sub_10011B334(const __CFAllocator *a1, void *a2, const __CFData *a3, int a4, uint64_t a5, __CFString **a6)
{
  int v9 = (const void *)sub_10011AD64(a1, (uint64_t)a2, a4, a5);
  int v10 = (void *)sub_100118974(a2, 9, a6);
  if (v10 && (sub_1001196B4((uint64_t)v9, v10, a3, a6) & 1) == 0 && v9)
  {
    CFRelease(v9);
    return 0;
  }
  return v9;
}

const void *sub_10011B3B4(uint64_t a1, const __CFDictionary *a2, __CFString **a3)
{
  CFAllocatorRef v6 = CFGetAllocator((CFTypeRef)a1);
  CFIndex v7 = (const void *)sub_10011AD64(v6, *(void *)(a1 + 16), *(_DWORD *)(a1 + 28), *(void *)(a1 + 32));
  sub_100119C6C((uint64_t)v7, *(CFTypeRef *)(a1 + 56));
  uint64_t v8 = *(void *)(a1 + 16);
  uint64_t v9 = *(void *)(v8 + 16);
  if (!v9) {
    return v7;
  }
  for (uint64_t i = (uint64_t *)(v8 + 24); ; ++i)
  {
    unsigned int v11 = *(_DWORD *)(v9 + 8);
    BOOL v12 = v11 > 0xA;
    int v13 = (1 << v11) & 0x6C0;
    if (!v12 && v13 != 0) {
      goto LABEL_7;
    }
    xpc_object_t value = 0;
    if (CFDictionaryGetValueIfPresent(a2, *(const void **)v9, (const void **)&value)) {
      break;
    }
    uint64_t v16 = (void *)sub_100118CF8((const void *)a1, v9, a3);
    xpc_object_t value = v16;
    if (!v16) {
      goto LABEL_15;
    }
LABEL_14:
    if ((sub_1001196B4((uint64_t)v7, (void *)v9, (const __CFData *)v16, a3) & 1) == 0) {
      goto LABEL_15;
    }
LABEL_7:
    uint64_t v15 = *i;
    uint64_t v9 = v15;
    if (!v15) {
      return v7;
    }
  }
  uint64_t v16 = value;
  if (value) {
    goto LABEL_14;
  }
  sub_100012A40(-50, a3, @"NULL value in dictionary");
  uint64_t v16 = value;
  if (value) {
    goto LABEL_14;
  }
LABEL_15:
  if (v7) {
    CFRelease(v7);
  }
  return 0;
}

__CFString ***sub_10011B4E8(__CFString ***result)
{
  if (result)
  {
    dispatch_queue_t v1 = result;
    uint64_t v2 = sub_10000FD40(result[2], kSecAttrAccessGroup, 0);
    uint64_t result = (__CFString ***)sub_100118CF8(v1, (uint64_t)v2, 0);
    if (result)
    {
      CFStringRef v3 = (const __CFString *)result;
      CFTypeID v4 = CFGetTypeID(result);
      if (v4 == CFStringGetTypeID()) {
        return (__CFString ***)(CFEqual(v3, kSOSInternalAccessGroup));
      }
      else {
        return 0;
      }
    }
  }
  return result;
}

void sub_10011B57C(CFMutableStringRef theString, uint64_t a2)
{
  if (a2 >= 1)
  {
    unint64_t v3 = a2 + 1;
    char v4 = 1;
    do
    {
      if ((v4 & 1) == 0) {
        CFStringAppend(theString, @",");
      }
      CFStringAppend(theString, @"?");
      char v4 = 0;
      --v3;
    }
    while (v3 > 1);
  }

  CFStringAppend(theString, @""));
}

const void *sub_10011B60C(void **a1, __CFString **a2)
{
  uint64_t v4 = sub_100118974(a1[2], 16, a2);
  if (!v4) {
    return 0;
  }
  CFDataRef v5 = sub_100118CF8(a1, v4, a2);
  CFAllocatorRef v6 = v5;
  if (v5)
  {
    CFTypeID v7 = CFGetTypeID(v5);
    if (v7 != CFDataGetTypeID()) {
      sub_1000263CC(1, (CFTypeRef *)a2, @"persistent ref %@ is not a data", v6);
    }
  }
  else
  {
    sub_1000263CC(1, (CFTypeRef *)a2, @"persistent ref %@ is not a data", 0);
  }
  return v6;
}

uint64_t sub_10011B6B0(uint64_t a1, const __CFData *a2, __CFString **a3)
{
  CFAllocatorRef v6 = (void *)sub_100118974(*(void **)(a1 + 16), 16, a3);
  if (!a2 || !v6) {
    return 1;
  }

  return sub_1001196B4(a1, v6, a2, a3);
}

uint64_t sub_10011B728(void **a1, __CFString **a2)
{
  uint64_t valuePtr = 0;
  uint64_t v4 = sub_100118974(a1[2], 8, a2);
  if (v4)
  {
    CFNumberRef v5 = (const __CFNumber *)sub_100118CF8(a1, v4, a2);
    CFNumberRef v6 = v5;
    if (!v5
      || (CFTypeID v7 = CFGetTypeID(v5), v7 != CFNumberGetTypeID())
      || !CFNumberGetValue(v6, kCFNumberSInt64Type, &valuePtr))
    {
      sub_1000263CC(1, (CFTypeRef *)a2, @"rowid %@ is not a 64 bit number", v6);
    }
  }
  return valuePtr;
}

uint64_t sub_10011B7D4(void **a1, uint64_t a2, __CFString **a3)
{
  uint64_t v6 = sub_100118974(a1[2], 8, a3);
  if (!v6) {
    return 1;
  }
  CFTypeID v7 = (void *)v6;
  uint64_t valuePtr = a2;
  CFAllocatorRef v8 = CFGetAllocator(a1);
  CFDataRef v9 = CFNumberCreate(v8, kCFNumberSInt64Type, &valuePtr);
  if (!v9) {
    return 0;
  }
  CFDataRef v10 = v9;
  uint64_t v11 = sub_1001196B4((uint64_t)a1, v7, v9, a3);
  CFRelease(v10);
  return v11;
}

void sub_10011B874(uint64_t a1, __CFString **a2)
{
  unint64_t v3 = (const void **)sub_100118974(*(void **)(a1 + 16), 8, a2);
  if (v3)
  {
    uint64_t v4 = *v3;
    CFNumberRef v5 = *(__CFDictionary **)(a1 + 48);
    CFDictionaryRemoveValue(v5, v4);
  }
}

BOOL sub_10011B8D0(const void *a1, uint64_t a2, BOOL *a3, __CFString **a4)
{
  CFNumberRef v5 = (const __CFNumber *)sub_100118CF8(a1, a2, a4);
  CFNumberRef v6 = v5;
  if (v5)
  {
    char valuePtr = -86;
    CFTypeID v7 = CFGetTypeID(v5);
    BOOL v8 = v7 == CFNumberGetTypeID() && CFNumberGetValue(v6, kCFNumberCharType, &valuePtr) && valuePtr == 1;
    *a3 = v8;
  }
  return v6 != 0;
}

uint64_t sub_10011B964(void **a1)
{
  char v4 = -86;
  uint64_t v2 = sub_100118974(a1[2], 11, 0);
  LODWORD(result) = sub_10011B8D0(a1, v2, (BOOL *)&v4, 0);
  if (v4) {
    return result;
  }
  else {
    return 0;
  }
}

const void *sub_10011B9C4(void *a1)
{
  uint64_t result = sub_100119CB8(a1, kSecAttrSharingGroup);
  if (result)
  {
    CFTypeID v2 = CFGetTypeID(result);
    return (const void *)(v2 == CFStringGetTypeID());
  }
  return result;
}

uint64_t sub_10011BA08(uint64_t a1, __CFString **a2)
{
  char v4 = (void *)sub_100118974(*(void **)(a1 + 16), 11, a2);

  return sub_1001196B4(a1, v4, kCFBooleanTrue, a2);
}

BOOL sub_10011BA64(const void *a1)
{
  dispatch_queue_t v1 = sub_100118CF8(a1, (uint64_t)&off_100303FD0, 0);
  if (!v1) {
    return 1;
  }
  CFTypeID v2 = v1;
  if (qword_10035CF58 != -1) {
    dispatch_once(&qword_10035CF58, &stru_1002FAF90);
  }
  return qword_10035CF60 && CFEqual(v2, (CFTypeRef)qword_10035CF60) != 0;
}

uint64_t sub_10011BAEC(void **a1)
{
  char v4 = -86;
  uint64_t v2 = sub_100118974(a1[2], 12, 0);
  LODWORD(result) = sub_10011B8D0(a1, v2, (BOOL *)&v4, 0);
  if (v4) {
    return result;
  }
  else {
    return 0;
  }
}

__CFData *sub_10011BB4C(CFMutableDictionaryRef *a1, unsigned char *a2, __CFString **a3)
{
  CFNumberRef v6 = (const void *)sub_100119A68(a2);
  if ((~*((_DWORD *)a2 + 4) & 0xALL) != 0 || (CFDataRef Value = (__CFData *)CFDictionaryGetValue(a1[6], v6)) == 0)
  {
    CFNullRef v9 = (const __CFNull *)sub_100118CF8(a1, (uint64_t)a2, a3);
    if (v9)
    {
      BOOL v8 = sub_10011BC10((uint64_t)a2, v9, a3);
      if (v8 && (a2[16] & 8) != 0) {
        CFDictionarySetValue(a1[6], v6, v8);
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    BOOL v8 = Value;
    CFRetain(Value);
  }
  return v8;
}

__CFData *sub_10011BC10(uint64_t a1, const __CFNull *a2, __CFString **a3)
{
  if (a2) {
    CFNullRef v5 = a2;
  }
  else {
    CFNullRef v5 = kCFNull;
  }
  if (CFEqual(v5, kCFNull) && (*(unsigned char *)(a1 + 16) & 1) != 0)
  {
    CFStringRef v6 = (const __CFString *)sub_1001189E0(a1, a3);
    if (!v6) {
      return 0;
    }
  }
  else
  {
    CFStringRef v6 = (const __CFString *)CFRetain(v5);
  }
  if ((*(unsigned char *)(a1 + 16) & 8) == 0 || CFEqual(v6, kCFNull)) {
    return (__CFData *)v6;
  }
  CFDataRef v9 = sub_10000E3E0(v6);
  if (v9)
  {
    CFStringRef v10 = (const __CFString *)v9;
    CFTypeID v7 = sub_100029C50(v9);
    if (v6) {
      CFRelease(v6);
    }
    CFStringRef v6 = v10;
  }
  else
  {
    sub_100012A40(-26276, a3, @"failed to get attribute %@ data", *(void *)a1);
    CFTypeID v7 = 0;
    if (!v6) {
      return v7;
    }
  }
  CFRelease(v6);
  return v7;
}

const void *sub_10011BD18(void **a1, __CFString **a2)
{
  uint64_t v4 = sub_100118974(a1[2], 7, a2);

  return sub_100118CF8(a1, v4, a2);
}

BOOL sub_10011BD68(CFStringRef **a1, uint64_t a2, __CFString **a3)
{
  if (!sub_100118DFC((uint64_t)a1, 1, a3)) {
    return 0;
  }
  CFAllocatorRef v6 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v6, 0);
  CFStringAppend(Mutable, @"INSERT INTO ");
  CFStringAppend(Mutable, *a1[2]);
  CFStringAppend(Mutable, @"(");
  BOOL v8 = a1[2];
  CFStringRef v9 = v8[2];
  if (v9)
  {
    uint64_t v10 = 0;
    int v11 = 0;
    BOOL v12 = v8 + 3;
    do
    {
      if (((uint64_t)v9->data & 2) != 0)
      {
        CFStringRef isa = (const __CFString *)v9->isa;
        if (v11) {
          CFStringAppend(Mutable, @",");
        }
        ++v10;
        CFStringAppend(Mutable, isa);
        int v11 = 1;
      }
      CFStringRef v14 = *v12++;
      CFStringRef v9 = v14;
    }
    while (v14);
    CFStringAppend(Mutable, @"VALUES(?"));
    if (v10 >= 2)
    {
      unint64_t v15 = v10 + 1;
      do
      {
        CFStringAppend(Mutable, @",?");
        --v15;
      }
      while (v15 > 2);
    }
  }
  else
  {
    CFStringAppend(Mutable, @"VALUES(?"));
  }
  CFStringAppend(Mutable, @""));
  uint64_t v24 = 0;
  CFTypeID v25 = &v24;
  uint64_t v26 = 0x2000000000;
  BOOL v27 = Mutable != 0;
  if (!Mutable) {
    goto LABEL_33;
  }
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 0x40000000;
  void v23[2] = sub_10011C09C;
  v23[3] = &unk_1002FA8E8;
  v23[6] = a1;
  v23[7] = a3;
  void v23[4] = &stru_1002FA8C0;
  void v23[5] = &v24;
  v23[8] = a2;
  char v17 = sub_10002742C(a2, (uint64_t)Mutable, (CFTypeRef *)a3, (uint64_t)v23);
  char v18 = *((unsigned char *)v25 + 24) ? v17 : 0;
  *((unsigned char *)v25 + 24) = v18;
  CFRelease(Mutable);
  if (*((unsigned char *)v25 + 24))
  {
    uint64_t v19 = sub_10000B070("item");
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138477827;
      CFTypeID v29 = a1;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "inserted %{private}@", buf, 0xCu);
    }
    sub_100029024(a2, 0, (CFArrayRef)a1);
  }
  else
  {
LABEL_33:
    if ((sub_10011B4E8((__CFString ***)a1) & 1) == 0)
    {
      uint64_t v20 = sub_10000B070("item");
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        if (a3) {
          uint64_t v21 = *a3;
        }
        else {
          uint64_t v21 = 0;
        }
        *(_DWORD *)long long buf = 138478083;
        CFTypeID v29 = a1;
        __int16 v30 = 2112;
        CFDateRef v31 = v21;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "insert failed for item %{private}@ with %@", buf, 0x16u);
      }
    }
  }
  BOOL v16 = *((unsigned char *)v25 + 24) != 0;
  _Block_object_dispose(&v24, 8);
  return v16;
}

CFStringRef sub_10011C09C(void *a1, sqlite3_stmt *pStmt)
{
  uint64_t v5 = a1[6];
  uint64_t v4 = (__CFString **)a1[7];
  uint64_t v6 = *(void *)(v5 + 16);
  CFTypeID v7 = *(unsigned char **)(v6 + 16);
  if (v7)
  {
    LODWORD(v_Block_object_dispose(&STACK[0x3F0], 8) = 0;
    uint64_t v9 = a1[4];
    uint64_t v10 = (void *)(v6 + 24);
    while (1)
    {
      if ((*(unsigned int (**)(uint64_t, unsigned char *))(v9 + 16))(v9, v7))
      {
        CFStringRef result = (const __CFString *)sub_10011BB4C((CFMutableDictionaryRef *)v5, v7, v4);
        if (!result) {
          goto LABEL_11;
        }
        CFStringRef v12 = result;
        uint64_t v8 = (v8 + 1);
        int v13 = sub_10000E8B0(pStmt, v8, result, (CFTypeRef *)v4);
        CFRelease(v12);
        if (!v13) {
          break;
        }
      }
      CFStringRef v14 = (unsigned char *)*v10++;
      CFTypeID v7 = v14;
      if (!v14)
      {
        uint64_t v4 = (__CFString **)a1[7];
        goto LABEL_8;
      }
    }
    CFStringRef result = 0;
  }
  else
  {
LABEL_8:
    CFStringRef result = (const __CFString *)sub_1000275B0(a1[8], pStmt, (CFTypeRef *)v4, 0);
    if (result)
    {
      unint64_t v15 = (__CFString **)a1[7];
      BOOL v16 = (void **)a1[6];
      sqlite3_int64 insert_rowid = sqlite3_last_insert_rowid(*(sqlite3 **)(a1[8] + 64));
      CFStringRef result = (const __CFString *)sub_10011B7D4(v16, insert_rowid, v15);
    }
  }
LABEL_11:
  *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = (_BYTE)result;
  return result;
}

BOOL sub_10011C1AC(id a1, const SecDbAttr *a2)
{
  return (LOBYTE(a2->var2) >> 1) & 1;
}

__CFError *sub_10011C1B8(__CFError *result)
{
  if (result)
  {
    dispatch_queue_t v1 = result;
    if (CFErrorGetCode(result) == 19)
    {
      CFErrorDomain Domain = CFErrorGetDomain(v1);
      return (__CFError *)(CFEqual(@"com.apple.utilities.sqlite3", Domain) != 0);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_10011C214(uint64_t a1, uint64_t a2, __CFString **a3, uint64_t a4)
{
  uint64_t v27 = 0;
  uint64_t v28 = &v27;
  uint64_t v29 = 0x2000000000;
  __int16 v30 = 0;
  uint64_t v23 = 0;
  uint64_t v24 = &v23;
  uint64_t v25 = 0x2000000000;
  char v26 = -86;
  char v26 = sub_10011BD68((CFStringRef **)a1, a2, &v30);
  if (!*((unsigned char *)v24 + 24))
  {
    CFStringRef v12 = (__CFError *)v28[3];
    if (v12)
    {
      if (CFErrorGetCode(v12) == 19)
      {
        CFErrorDomain Domain = CFErrorGetDomain((CFErrorRef)v28[3]);
        if (CFEqual(@"com.apple.utilities.sqlite3", Domain))
        {
          CFStringRef v14 = (CFDictionaryRef *)sub_10011C45C((void *)a1, a3);
          if (v14)
          {
            unint64_t v15 = v14;
            CFDictionaryRef v16 = *(const __CFDictionary **)(a1 + 56);
            CFDictionaryRef v17 = v14[18];
            if (v17 != v16)
            {
              if (!v16 || (CFRetain(*(CFTypeRef *)(a1 + 56)), (CFDictionaryRef v17 = v15[18]) != 0)) {
                CFRelease(v17);
              }
              v15[18] = v16;
            }
            v22[0] = _NSConcreteStackBlock;
            v22[1] = 0x40000000;
            v22[2] = sub_10011C4E8;
            v22[3] = &unk_1002FA990;
            void v22[4] = a4;
            v22[5] = &v23;
            v22[6] = &v27;
            v22[7] = a3;
            v22[8] = a1;
            v22[9] = a2;
            sub_10011C750(v15, a2, (CFTypeRef *)a3, 0, &stru_1002FA928, 0, 0, (uint64_t)v22);
            sub_100119C6C(a1, v15[18]);
            char v18 = sub_10000C2C4((const void **)v15, (CFErrorRef *)a3);
            if (*((unsigned char *)v24 + 24)) {
              char v19 = v18;
            }
            else {
              char v19 = 0;
            }
            *((unsigned char *)v24 + 24) = v19;
          }
        }
      }
    }
  }
  int v8 = *((unsigned __int8 *)v24 + 24);
  uint64_t v9 = (__CFString *)v28[3];
  if (a3 && v9)
  {
    if (*a3)
    {
      if (CFErrorGetCode((CFErrorRef)*a3) != -25330) {
        goto LABEL_10;
      }
      uint64_t v10 = *a3;
      if (*a3)
      {
        *a3 = 0;
        CFRelease(v10);
LABEL_10:
        if (*a3) {
          goto LABEL_11;
        }
      }
    }
    unsigned int v11 = 0;
    *a3 = v9;
    goto LABEL_27;
  }
  if (v9)
  {
    if (!a3)
    {
LABEL_11:
      CFRelease(v9);
      unsigned int v11 = 0;
      goto LABEL_27;
    }
    goto LABEL_10;
  }
  unsigned int v11 = 1;
LABEL_27:
  if (v8) {
    uint64_t v20 = v11;
  }
  else {
    uint64_t v20 = 0;
  }
  _Block_object_dispose(&v23, 8);
  _Block_object_dispose(&v27, 8);
  return v20;
}

void *sub_10011C45C(void *a1, __CFString **a2)
{
  uint64_t v4 = sub_100118B3C(a1, 1, 0, a2);
  if (!v4) {
    return 0;
  }
  uint64_t v5 = v4;
  uint64_t v6 = sub_10000C7F0(a1[2], 0, 0, 0, a2);
  CFTypeID v7 = v6;
  if (v6)
  {
    int v8 = (const void *)v6[1];
    if (v8) {
      CFRelease(v8);
    }
    v7[1] = v5;
  }
  else
  {
    CFRelease(v5);
  }
  return v7;
}

void sub_10011C4E8(uint64_t a1, uint64_t a2)
{
  unsigned __int8 v19 = 0;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = sub_10011D080((__CFString *)a2, &v19, *(CFErrorRef **)(a1 + 56));
  CFTypeRef cf = 0;
  int v4 = v19;
  if (!v19)
  {
    if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
      return;
    }
    uint64_t v15 = *(void *)(a1 + 32);
    if (!v15) {
      return;
    }
    (*(void (**)(uint64_t, uint64_t, CFTypeRef *))(v15 + 16))(v15, a2, &cf);
    if (!cf) {
      return;
    }
LABEL_8:
    uint64_t v10 = (const void **)sub_100118974(*(void **)(a2 + 16), 8, *(__CFString ***)(a1 + 56));
    CFDataRef v11 = (const __CFData *)sub_1001193FC(a2, v10);
    if (v11)
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = sub_1001196B4((uint64_t)cf, v10, v11, (__CFString **)(*(void *)(*(void *)(a1 + 48)+ 8)+ 24));
      uint64_t v12 = *(void *)(*(void *)(a1 + 40) + 8);
      int v13 = *(unsigned __int8 *)(v12 + 24);
      if (!v4 && *(unsigned char *)(v12 + 24))
      {
        *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = sub_10011D714((void **)cf, (const void *)a2, *(__CFString ***)(a1 + 56));
        uint64_t v12 = *(void *)(*(void *)(a1 + 40) + 8);
        int v13 = *(unsigned __int8 *)(v12 + 24);
      }
      if (!v13)
      {
        BOOL v14 = 0;
LABEL_21:
        *(unsigned char *)(v12 + 24) = v14;
        CFRelease(cf);
        if (*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
        {
          uint64_t v16 = *(void *)(*(void *)(a1 + 48) + 8);
          CFDictionaryRef v17 = *(const void **)(v16 + 24);
          if (v17)
          {
            *(void *)(v16 + 24) = 0;
            CFRelease(v17);
          }
        }
        return;
      }
      BOOL v14 = sub_10011D784((__CFString ***)a2, (CFStringRef **)cf, *(void *)(a1 + 72), (CFTypeRef *)(*(void *)(*(void *)(a1 + 48) + 8) + 24), (uint64_t)&stru_1002FA968);
    }
    else
    {
      BOOL v14 = sub_100012A40(-26276, (__CFString **)(*(void *)(*(void *)(a1 + 48) + 8) + 24), @"no rowid for %@", a2);
    }
    uint64_t v12 = *(void *)(*(void *)(a1 + 40) + 8);
    goto LABEL_21;
  }
  uint64_t v5 = sub_10000B070("item");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 64);
    *(_DWORD *)long long buf = 138478083;
    uint64_t v21 = a2;
    __int16 v22 = 2113;
    uint64_t v23 = v6;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "replacing corrupted item %{private}@ with %{private}@", buf, 0x16u);
  }
  CFTypeID v7 = *(const void **)(a1 + 64);
  CFTypeRef cf = v7;
  CFRetain(v7);
  int v8 = *(const void ***)(a1 + 56);
  if (v8)
  {
    uint64_t v9 = *v8;
    if (*v8)
    {
      *int v8 = 0;
      CFRelease(v9);
    }
  }
  if (v7) {
    goto LABEL_8;
  }
}

BOOL sub_10011C750(CFDictionaryRef *a1, uint64_t a2, CFTypeRef *a3, Block_layout *a4, Block_layout *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v22 = 0;
  uint64_t v23 = &v22;
  uint64_t v24 = 0x2000000000;
  char v25 = 1;
  if (a4) {
    int v13 = a4;
  }
  else {
    int v13 = &stru_1002FAC28;
  }
  if (a5) {
    BOOL v14 = a5;
  }
  else {
    BOOL v14 = &stru_1002FAC68;
  }
  uint64_t v15 = sub_10011C8B0(a1, (uint64_t)v13, (uint64_t)v14, a6);
  if (v15)
  {
    uint64_t v16 = v15;
    v21[0] = _NSConcreteStackBlock;
    v21[1] = 0x40000000;
    void v21[2] = sub_10011CB60;
    v21[3] = &unk_1002FACB8;
    v21[8] = &v22;
    v21[9] = a1;
    void v21[4] = v14;
    void v21[5] = a7;
    v21[10] = a3;
    v21[11] = a2;
    v21[6] = v13;
    v21[7] = a8;
    char v17 = sub_10002742C(a2, (uint64_t)v15, a3, (uint64_t)v21);
    if (*((unsigned char *)v23 + 24)) {
      char v18 = v17;
    }
    else {
      char v18 = 0;
    }
    *((unsigned char *)v23 + 24) = v18;
    CFRelease(v16);
    BOOL v19 = *((unsigned char *)v23 + 24) != 0;
  }
  else
  {
    BOOL v19 = 0;
    *((unsigned char *)v23 + 24) = 0;
  }
  _Block_object_dispose(&v22, 8);
  return v19;
}

__CFString *sub_10011C8B0(CFDictionaryRef *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  CFMutableArrayRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  CFStringAppend(Mutable, @"SELECT ");
  int v8 = (const __CFString **)*((void *)*a1 + 2);
  if (!v8)
  {
    if (((_BYTE)a1[6] & 8) == 0) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  int v9 = 0;
  uint64_t v10 = (const __CFString ***)((char *)*a1 + 24);
  do
  {
    if ((*(unsigned int (**)(uint64_t, const __CFString **))(a2 + 16))(a2, v8))
    {
      CFStringRef v11 = *v8;
      if (v9) {
        CFStringAppend(Mutable, @",");
      }
      CFStringAppend(Mutable, v11);
      int v9 = 1;
    }
    uint64_t v12 = *v10++;
    int v8 = v12;
  }
  while (v12);
  if (((_BYTE)a1[6] & 8) != 0)
  {
    if (v9) {
      CFStringAppend(Mutable, @",");
    }
LABEL_12:
    CFStringAppend(Mutable, @"persistref");
  }
LABEL_13:
  CFStringAppend(Mutable, @" FROM ");
  CFStringAppend(Mutable, *(CFStringRef *)*a1);
  char v31 = 1;
  int v13 = (const void **)*((void *)*a1 + 2);
  if (v13)
  {
    BOOL v14 = (const void ***)((char *)*a1 + 24);
    do
    {
      if ((*(unsigned int (**)(uint64_t, const void **))(a3 + 16))(a3, v13))
      {
        CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(a1[1], *v13);
        if (!Value || (CFArrayRef v16 = Value, v17 = CFGetTypeID(Value), v17 != CFArrayGetTypeID()))
        {
          CFStringRef v23 = (const __CFString *)*v13;
          uint64_t v24 = Mutable;
LABEL_25:
          sub_100011710(v24, v23, &v31);
          goto LABEL_26;
        }
        CFIndex Count = CFArrayGetCount(v16);
        uint64_t v19 = Count - 1;
        if (Count >= 1)
        {
          CFIndex v20 = Count;
          CFNullRef ValueAtIndex = (CFNullRef)CFArrayGetValueAtIndex(v16, 0);
          if (ValueAtIndex && kCFNull)
          {
            if (!CFEqual(ValueAtIndex, kCFNull)) {
              goto LABEL_29;
            }
          }
          else if (ValueAtIndex != kCFNull)
          {
LABEL_29:
            CFStringRef v26 = (const __CFString *)*v13;
            if (v20 != 1)
            {
              sub_100011764(Mutable, &v31);
              CFStringAppend(Mutable, v26);
              CFStringAppend(Mutable, @" IN (");
              uint64_t v27 = Mutable;
              uint64_t v28 = v20;
LABEL_33:
              sub_10011B57C(v27, v28);
              goto LABEL_26;
            }
            uint64_t v24 = Mutable;
            CFStringRef v23 = (const __CFString *)*v13;
            goto LABEL_25;
          }
          CFStringRef v22 = (const __CFString *)*v13;
          sub_100011764(Mutable, &v31);
          CFStringAppend(Mutable, v22);
          if (v19 != 1)
          {
            CFStringAppend(Mutable, @" NOT IN (");
            uint64_t v27 = Mutable;
            uint64_t v28 = v19;
            goto LABEL_33;
          }
          CFStringAppend(Mutable, @"!=?");
        }
      }
LABEL_26:
      char v25 = *v14++;
      int v13 = v25;
    }
    while (v25);
  }
  if (a4) {
    (*(void (**)(void))(a4 + 16))();
  }
  return Mutable;
}

uint64_t sub_10011CB60(uint64_t a1, sqlite3_stmt *a2)
{
  uint64_t result = sub_10011CC14(*(CFDictionaryRef **)(a1 + 72), a2, *(__CFString ***)(a1 + 80), *(void *)(a1 + 32), *(void *)(a1 + 40));
  if (result)
  {
    uint64_t v6 = *(CFTypeRef **)(a1 + 80);
    uint64_t v5 = *(void *)(a1 + 88);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 0x40000000;
    v7[2] = sub_10011CE94;
    v7[3] = &unk_1002FAC90;
    uint64_t v9 = *(void *)(a1 + 72);
    uint64_t v10 = a2;
    CFStringRef v11 = v6;
    long long v8 = *(_OWORD *)(a1 + 48);
    uint64_t result = sub_1000275B0(v5, a2, v6, (uint64_t)v7);
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = result;
  return result;
}

uint64_t sub_10011CC14(CFDictionaryRef *a1, sqlite3_stmt *a2, __CFString **a3, uint64_t a4, uint64_t a5)
{
  uint64_t v33 = 0;
  CFDataRef v34 = &v33;
  uint64_t v35 = 0x2000000000;
  char v36 = 1;
  uint64_t v29 = 0;
  __int16 v30 = &v29;
  uint64_t v31 = 0x2000000000;
  int v32 = 0;
  uint64_t v6 = (const void **)*((void *)*a1 + 2);
  if (v6)
  {
    uint64_t v10 = (const void ***)((char *)*a1 + 24);
    do
    {
      if ((*(unsigned int (**)(uint64_t, const void **))(a4 + 16))(a4, v6))
      {
        CFArrayRef Value = (const __CFArray *)CFDictionaryGetValue(a1[1], *v6);
        if (!Value)
        {
          int v17 = *((_DWORD *)v30 + 6);
          *((_DWORD *)v30 + 6) = v17 + 1;
          uint64_t v18 = (uint64_t)a1;
          uint64_t v19 = a2;
          uint64_t v20 = (uint64_t)v6;
          CFNullRef v21 = 0;
          goto LABEL_12;
        }
        CFArrayRef v12 = Value;
        CFTypeID v13 = CFGetTypeID(Value);
        if (v13 != CFArrayGetTypeID())
        {
          int v17 = *((_DWORD *)v30 + 6);
          *((_DWORD *)v30 + 6) = v17 + 1;
          uint64_t v18 = (uint64_t)a1;
          uint64_t v19 = a2;
          uint64_t v20 = (uint64_t)v6;
          CFNullRef v21 = v12;
LABEL_12:
          int v22 = sub_10011CFA8(v18, v19, v17, v20, v21, a3);
          *((unsigned char *)v34 + 24) = v22;
          if (!v22) {
            break;
          }
          goto LABEL_18;
        }
        uint64_t Count = CFArrayGetCount(v12);
        if (Count < 1)
        {
          v23.id location = 0;
        }
        else
        {
          CFNullRef ValueAtIndex = (CFNullRef)CFArrayGetValueAtIndex(v12, 0);
          if (ValueAtIndex && kCFNull) {
            BOOL v16 = CFEqual(ValueAtIndex, kCFNull) != 0;
          }
          else {
            BOOL v16 = ValueAtIndex == kCFNull;
          }
          Count -= v16;
          v23.id location = v16;
        }
        context[0] = _NSConcreteStackBlock;
        context[1] = 0x40000000;
        context[2] = sub_10011CF54;
        context[3] = &unk_1002FABE8;
        void context[6] = a1;
        void context[7] = a2;
        void context[4] = &v33;
        void context[5] = &v29;
        context[8] = v6;
        context[9] = a3;
        v23.size_t length = Count;
        CFArrayApplyFunction(v12, v23, (CFArrayApplierFunction)sub_10011D03C, context);
        if (!*((unsigned char *)v34 + 24)) {
          break;
        }
      }
LABEL_18:
      uint64_t v24 = *v10++;
      uint64_t v6 = v24;
    }
    while (v24);
  }
  if (a5)
  {
    ++*((_DWORD *)v30 + 6);
    (*(void (**)(uint64_t, sqlite3_stmt *))(a5 + 16))(a5, a2);
  }
  uint64_t v25 = *((unsigned __int8 *)v34 + 24);
  _Block_object_dispose(&v29, 8);
  _Block_object_dispose(&v33, 8);
  return v25;
}

void sub_10011CE94(uint64_t a1)
{
  uint64_t v2 = sub_10011B210(kCFAllocatorDefault, **(void ***)(a1 + 48), *(sqlite3_stmt **)(a1 + 56), *(_DWORD *)(*(void *)(a1 + 48) + 120), *(void *)(a1 + 32));
  if (v2)
  {
    unint64_t v3 = (void *)v2;
    uint64_t v4 = *(void *)(a1 + 48);
    uint64_t v5 = *(const void **)(v4 + 144);
    uint64_t v6 = *(const void **)(v2 + 56);
    if (v6 != v5)
    {
      if (!v5 || (CFRetain(*(CFTypeRef *)(v4 + 144)), (uint64_t v6 = (const void *)v3[7]) != 0)) {
        CFRelease(v6);
      }
      v3[7] = v5;
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    CFRelease(v3);
  }
}

uint64_t sub_10011CF54(uint64_t a1, const __CFNull *a2)
{
  uint64_t v3 = *(void *)(a1 + 48);
  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8);
  int v5 = *(_DWORD *)(v4 + 24);
  *(_DWORD *)(v4 + 24) = v5 + 1;
  uint64_t result = sub_10011CFA8(v3, *(sqlite3_stmt **)(a1 + 56), v5, *(void *)(a1 + 64), a2, *(__CFString ***)(a1 + 72));
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t sub_10011CFA8(uint64_t a1, sqlite3_stmt *a2, int a3, uint64_t a4, const __CFNull *a5, __CFString **a6)
{
  if (*(_DWORD *)(a4 + 8) == 8) {
    CFStringRef v9 = (const __CFString *)CFNumberCreate(0, kCFNumberSInt64Type, (const void *)(a1 + 72));
  }
  else {
    CFStringRef v9 = (const __CFString *)sub_10011BC10(a4, a5, a6);
  }
  CFStringRef v10 = v9;
  if (!v9) {
    return 0;
  }
  uint64_t v11 = sub_10000E8B0(a2, (a3 + 1), v9, (CFTypeRef *)a6);
  CFRelease(v10);
  return v11;
}

uint64_t sub_10011D03C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

BOOL sub_10011D054(id a1, const SecDbAttr *a2)
{
  return 0;
}

BOOL sub_10011D05C(id a1, const SecDbAttr *a2)
{
  int var1 = a2->var1;
  return (var1 - 7) < 3 || var1 == 16;
}

BOOL sub_10011D074(id a1, const SecDbAttr *a2)
{
  return a2->var2 & 1;
}

uint64_t sub_10011D080(__CFString *a1, unsigned char *a2, CFErrorRef *a3)
{
  CFTypeRef cf = 0;
  uint64_t v6 = (const void **)sub_100118974((void *)a1->data, 7, (__CFString **)&cf);
  CFDataRef v7 = (const __CFData *)sub_100118CF8(a1, (uint64_t)v6, (__CFString **)&cf);
  CFDataRef v8 = v7;
  if (v7) {
    CFRetain(v7);
  }
  if (!cf && sub_100118DFC((uint64_t)a1, 1, (__CFString **)&cf) || SecErrorGetOSStatus() != -26275)
  {
    int v14 = 0;
    goto LABEL_23;
  }
  uint64_t v9 = sub_100118974((void *)a1->data, 15, (__CFString **)&cf);
  CFStringRef v10 = sub_100118CF8(a1, v9, (__CFString **)&cf);
  if (!v10) {
    goto LABEL_17;
  }
  CFTypeID v11 = CFGetTypeID(v10);
  if (v11 != CFDataGetTypeID()) {
    goto LABEL_17;
  }
  CFGetAllocator(a1);
  if (!SecAccessControlCreateFromData()) {
    goto LABEL_17;
  }
  CFStringRef Protection = (const __CFString *)SecAccessControlGetProtection();
  if (!Protection || !kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly)
  {
    if (Protection == kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly) {
      goto LABEL_12;
    }
LABEL_17:
    uint64_t v15 = sub_10000B070("SecError");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412547;
      CFTypeRef v52 = cf;
      __int16 v53 = 2113;
      CFTypeRef v54 = a1;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "error %@ reading item %{private}@ (corrupted)", buf, 0x16u);
    }
    sub_10002BBA0(@"Corrupted item found in keychain", 0x53C00002u);
    int v14 = 0;
    goto LABEL_20;
  }
  if (!CFEqual(Protection, kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly)) {
    goto LABEL_17;
  }
LABEL_12:
  CFTypeID v13 = sub_10000B070("SecWarning");
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138478083;
    CFTypeRef v52 = a1;
    __int16 v53 = 2112;
    CFTypeRef v54 = cf;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "cannot decrypt item %{private}@, item is irrecoverably lost with older passcode (error %@)", buf, 0x16u);
  }
  int v14 = 1;
LABEL_20:
  CFTypeRef v16 = cf;
  if (cf)
  {
    CFTypeRef cf = 0;
    CFRelease(v16);
  }
  *a2 = 1;
LABEL_23:
  CFDataRef v17 = sub_1001194FC(a1, (uint64_t)v6);
  CFDataRef v18 = v17;
  if (v8 && v17 && !CFEqual(v8, v17))
  {
    int v48 = v14;
    CFNumberRef v49 = a2;
    CFIndex Length = CFDataGetLength(v8);
    CFMutableArrayRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 2 * Length);
    BytePtr = CFDataGetBytePtr(v8);
    CFIndex v22 = CFDataGetLength(v8);
    if (v22 >= 1)
    {
      CFIndex v23 = v22;
      do
      {
        unsigned int v24 = *BytePtr++;
        CFStringAppendFormat(Mutable, 0, @"%02X", v24);
        --v23;
      }
      while (v23);
    }
    CFIndex v25 = CFDataGetLength(v18);
    CFStringRef v26 = CFStringCreateMutable(kCFAllocatorDefault, 2 * v25);
    uint64_t v27 = CFDataGetBytePtr(v18);
    CFIndex v28 = CFDataGetLength(v18);
    if (v28 >= 1)
    {
      CFIndex v29 = v28;
      do
      {
        unsigned int v30 = *v27++;
        CFStringAppendFormat(v26, 0, @"%02X", v30);
        --v29;
      }
      while (v29);
    }
    uint64_t v31 = sub_10000B070("SecError");
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      int v32 = *v6;
      *(_DWORD *)long long buf = 138413059;
      CFTypeRef v52 = v32;
      __int16 v53 = 2112;
      CFTypeRef v54 = Mutable;
      __int16 v55 = 2112;
      unsigned int v56 = v26;
      __int16 v57 = 2113;
      CFTypeID v58 = a1;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "error %@ %@ != %@ item %{private}@ (corrupted)", buf, 0x2Au);
    }
    int v14 = v48;
    if (Mutable) {
      CFRelease(Mutable);
    }
    a2 = v49;
    if (v26) {
      CFRelease(v26);
    }
    *CFNumberRef v49 = 1;
  }
  if (!cf)
  {
    data = a1->data;
    uint64_t v37 = *((void *)data + 2);
    if (v37)
    {
      CFNumberRef v38 = (uint64_t *)(data + 24);
      do
      {
        if ((*(_WORD *)(v37 + 16) & 0x2080) != 0)
        {
          CFTypeID v39 = sub_100118CF8(a1, v37, (__CFString **)&cf);
          if (!v39)
          {
            if (SecErrorGetOSStatus() == -26275)
            {
              if (v14)
              {
                int v41 = sub_10000B070("SecWarning");
                if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
                {
                  CFTypeID v42 = *(const void **)v37;
                  *(_DWORD *)long long buf = 138412803;
                  CFTypeRef v52 = v42;
                  __int16 v53 = 2112;
                  CFTypeRef v54 = cf;
                  __int16 v55 = 2113;
                  unsigned int v56 = a1;
                  _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "attribute %@: %@ item %{private}@ (item lost with older passcode)", buf, 0x20u);
                }
              }
              else
              {
                CFTypeID v45 = sub_10000B070("SecError");
                if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
                {
                  CFNumberRef v46 = *(const void **)v37;
                  *(_DWORD *)long long buf = 138412803;
                  CFTypeRef v52 = v46;
                  __int16 v53 = 2112;
                  CFTypeRef v54 = cf;
                  __int16 v55 = 2113;
                  unsigned int v56 = a1;
                  _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "error attribute %@: %@ item %{private}@ (corrupted)", buf, 0x20u);
                }
                sub_10002BBA0(@"Corrupted item found in keychain", 0x53C00002u);
              }
              *a2 = 1;
              CFTypeRef v47 = cf;
              if (cf)
              {
                CFTypeRef cf = 0;
                CFRelease(v47);
              }
            }
            break;
          }
          if (CFEqual(kCFNull, v39) && (*(unsigned char *)(v37 + 17) & 0x10) != 0)
          {
            CFTypeID v43 = sub_10000B070("SecError");
            if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
            {
              BOOL v44 = *(const void **)v37;
              *(_DWORD *)long long buf = 138412547;
              CFTypeRef v52 = v44;
              __int16 v53 = 2113;
              CFTypeRef v54 = a1;
              _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "error attribute %@ has NULL value in item %{private}@ (corrupted)", buf, 0x16u);
            }
            sub_10002BBA0(@"Corrupted item (attr NULL) found in keychain", 0x53C00002u);
            *a2 = 1;
            break;
          }
        }
        uint64_t v40 = *v38++;
        uint64_t v37 = v40;
      }
      while (v40);
    }
  }
  if (v18) {
    CFRelease(v18);
  }
  if (v8) {
    CFRelease(v8);
  }
  uint64_t v33 = (__CFError *)cf;
  if (a3 && cf)
  {
    if (*a3)
    {
      if (CFErrorGetCode(*a3) != -25330) {
        goto LABEL_52;
      }
      CFErrorRef v34 = *a3;
      if (*a3)
      {
        *a3 = 0;
        CFRelease(v34);
LABEL_52:
        if (*a3) {
          goto LABEL_53;
        }
      }
    }
    uint64_t result = 0;
    *a3 = v33;
    return result;
  }
  if (cf)
  {
    if (!a3)
    {
LABEL_53:
      CFRelease(v33);
      return 0;
    }
    goto LABEL_52;
  }
  return 1;
}

void *sub_10011D714(void **a1, const void *a2, __CFString **a3)
{
  uint64_t result = (void *)sub_100118974(a1[2], 6, a3);
  if (result)
  {
    return (void *)sub_10011DC9C(a1, a2, result, a3);
  }
  return result;
}

BOOL sub_10011D784(__CFString ***a1, CFStringRef **a2, uint64_t a3, CFTypeRef *a4, uint64_t a5)
{
  CFDataRef v10 = (const __CFData *)sub_100119CB8(a1, kSecAttrPersistentReference);
  if (!v10 || CFDataGetLength(v10) != 16)
  {
    CFUUIDRef v11 = CFUUIDCreate(kCFAllocatorDefault);
    CFUUIDBytes bytes = CFUUIDGetUUIDBytes(v11);
    CFDataRef v12 = CFDataCreate(kCFAllocatorDefault, &bytes.byte0, 16);
    *(void *)CFTypeRef cf = 0;
    sub_10011B6B0((uint64_t)a2, v12, (__CFString **)cf);
    if (v11) {
      CFRelease(v11);
    }
    if (v12) {
      CFRelease(v12);
    }
    CFTypeID v13 = *(const void **)cf;
    if (*(void *)cf)
    {
      *(void *)CFTypeRef cf = 0;
      CFRelease(v13);
    }
  }
  CFAllocatorRef v14 = CFGetAllocator(a2);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v14, 0);
  CFStringAppend(Mutable, @"UPDATE ");
  CFStringAppend(Mutable, *a2[2]);
  CFStringAppend(Mutable, @" SET ");
  CFTypeRef v16 = a2[2];
  CFStringRef v17 = v16[2];
  if (v17)
  {
    int v18 = 0;
    uint64_t v19 = v16 + 3;
    do
    {
      if (((uint64_t)v17->data & 2) != 0)
      {
        CFStringRef isa = (const __CFString *)v17->isa;
        if (v18) {
          CFStringAppend(Mutable, @",");
        }
        CFStringAppend(Mutable, isa);
        CFStringAppend(Mutable, @"=?");
        int v18 = 1;
      }
      CFStringRef v21 = *v19++;
      CFStringRef v17 = v21;
    }
    while (v21);
  }
  bytes.byte0 = 1;
  CFIndex v22 = a1[2];
  CFIndex v23 = (const __CFString **)v22[2];
  if (v23)
  {
    unsigned int v24 = (const __CFString ***)(v22 + 3);
    do
    {
      if ((*(unsigned int (**)(uint64_t, const __CFString **))(a5 + 16))(a5, v23)) {
        sub_100011710(Mutable, *v23, &bytes);
      }
      CFIndex v25 = *v24++;
      CFIndex v23 = v25;
    }
    while (v25);
  }
  *(void *)&bytes.byte0 = 0;
  *(void *)&bytes.byte8 = &bytes;
  uint64_t v34 = 0x2000000000;
  BOOL v35 = Mutable != 0;
  if (!Mutable) {
    goto LABEL_32;
  }
  v32[0] = _NSConcreteStackBlock;
  v32[1] = 0x40000000;
  v32[2] = sub_10011DB2C;
  v32[3] = &unk_1002FA9D8;
  void v32[6] = a1;
  v32[7] = a2;
  void v32[4] = a5;
  void v32[5] = &bytes;
  v32[8] = a4;
  v32[9] = a3;
  char v26 = sub_10002742C(a3, (uint64_t)Mutable, a4, (uint64_t)v32);
  char v27 = *(unsigned char *)(*(void *)&bytes.byte8 + 24) ? v26 : 0;
  *(unsigned char *)(*(void *)&bytes.byte8 + 24) = v27;
  CFRelease(Mutable);
  if (*(unsigned char *)(*(void *)&bytes.byte8 + 24))
  {
    if ((sub_10011B4E8(a1) & 1) == 0)
    {
      CFIndex v28 = sub_10000B070("item");
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)CFTypeRef cf = 138478083;
        *(void *)&cf[4] = a1;
        __int16 v37 = 2112;
        uint64_t v38 = a3;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "replaced %{private}@ in %@", cf, 0x16u);
      }
      CFIndex v29 = sub_10000B070("item");
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)CFTypeRef cf = 138478083;
        *(void *)&cf[4] = a2;
        __int16 v37 = 2112;
        uint64_t v38 = a3;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "    with %{private}@ in %@", cf, 0x16u);
      }
    }
    sub_100029024(a3, (uint64_t)a1, (CFArrayRef)a2);
    BOOL v30 = *(unsigned char *)(*(void *)&bytes.byte8 + 24) != 0;
  }
  else
  {
LABEL_32:
    BOOL v30 = 0;
  }
  _Block_object_dispose(&bytes, 8);
  return v30;
}

CFStringRef sub_10011DB2C(uint64_t a1, sqlite3_stmt *a2)
{
  uint64_t v4 = *(void *)(a1 + 48);
  uint64_t v5 = *(void *)(a1 + 56);
  uint64_t v6 = *(__CFString ***)(a1 + 64);
  uint64_t v7 = *(void *)(a1 + 32);
  uint64_t v8 = *(void *)(v5 + 16);
  uint64_t v9 = *(unsigned char **)(v8 + 16);
  if (v9)
  {
    LODWORD(v10) = 0;
    CFUUIDRef v11 = (void *)(v8 + 24);
    while (1)
    {
      if ((v9[16] & 2) != 0)
      {
        CFDataRef v12 = sub_10011BB4C((CFMutableDictionaryRef *)v5, v9, v6);
        if (!v12) {
          goto LABEL_10;
        }
        uint64_t v10 = (v10 + 1);
        int v13 = sub_10000E8B0(a2, v10, (const __CFString *)v12, (CFTypeRef *)v6);
        CFRelease(v12);
        if (!v13) {
          break;
        }
      }
      CFAllocatorRef v14 = (unsigned char *)*v11++;
      uint64_t v9 = v14;
      if (!v14) {
        goto LABEL_9;
      }
    }
    LODWORD(v12) = 0;
  }
  else
  {
    LODWORD(v10) = 0;
LABEL_9:
    LODWORD(v12) = 1;
  }
LABEL_10:
  uint64_t v15 = *(void *)(v4 + 16);
  CFTypeRef v16 = *(unsigned char **)(v15 + 16);
  if (v16)
  {
    CFStringRef v17 = (void *)(v15 + 24);
    do
    {
      if ((*(unsigned int (**)(uint64_t, unsigned char *))(v7 + 16))(v7, v16))
      {
        CFStringRef result = (const __CFString *)sub_10011BB4C((CFMutableDictionaryRef *)v4, v16, v6);
        if (!result) {
          goto LABEL_19;
        }
        CFStringRef v19 = result;
        uint64_t v10 = (v10 + 1);
        LODWORD(v12) = v12 & sub_10000E8B0(a2, v10, result, (CFTypeRef *)v6);
        CFRelease(v19);
        if (v12 != 1) {
          goto LABEL_18;
        }
      }
      uint64_t v20 = (unsigned char *)*v17++;
      CFTypeRef v16 = v20;
    }
    while (v20);
  }
  if ((v12 & 1) == 0)
  {
LABEL_18:
    CFStringRef result = 0;
    goto LABEL_19;
  }
  CFStringRef result = (const __CFString *)sub_1000275B0(*(void *)(a1 + 72), a2, *(CFTypeRef **)(a1 + 64), 0);
LABEL_19:
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = (_BYTE)result;
  return result;
}

BOOL sub_10011DC8C(id a1, const SecDbAttr *a2)
{
  return a2->var1 == 8;
}

uint64_t sub_10011DC9C(const void *a1, const void *a2, void *a3, __CFString **a4)
{
  uint64_t result = (uint64_t)sub_100118CF8(a2, (uint64_t)a3, a4);
  if (result)
  {
    CFDateRef v8 = (const __CFDate *)result;
    uint64_t result = (uint64_t)sub_100118CF8(a1, (uint64_t)a3, a4);
    if (result)
    {
      uint64_t result = CFDateCompare((CFDateRef)result, v8, 0);
      if (result != 1)
      {
        CFAbsoluteTime AbsoluteTime = CFDateGetAbsoluteTime(v8);
        CFDataRef v10 = CFDateCreate(kCFAllocatorDefault, AbsoluteTime + 0.001);
        if (v10)
        {
          CFDataRef v11 = v10;
          uint64_t v12 = sub_1001196B4((uint64_t)a1, a3, v10, a4);
          CFRelease(v11);
          return v12;
        }
        else
        {
          return 1;
        }
      }
    }
  }
  return result;
}

uint64_t sub_10011DD70(uint64_t a1, uint64_t a2, char a3, char a4, __CFString **a5)
{
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  _DWORD v6[2] = sub_10011DDE8;
  v6[3] = &unk_1002FA9B0;
  void v6[4] = a1;
  char v7 = a3;
  char v8 = a4;
  return sub_10011C214(a1, a2, a5, (uint64_t)v6);
}

void sub_10011DDE8(uint64_t a1, void **a2, uint64_t *a3)
{
  if (sub_10011BAEC(a2))
  {
    uint64_t v6 = *(const void **)(a1 + 32);
    if (v6)
    {
      CFRetain(v6);
      uint64_t v7 = *(void *)(a1 + 32);
    }
    else
    {
      uint64_t v7 = 0;
    }
    *a3 = v7;
    if (!*(unsigned char *)(a1 + 40))
    {
      uint64_t v17 = *(void *)(*(void *)(a1 + 32) + 16);
      int v18 = *(uint64_t **)(v17 + 16);
      if (v18)
      {
        CFStringRef v19 = (uint64_t **)(v17 + 24);
        do
        {
          if (CFEqual((CFTypeRef)*v18, @"UUID") || CFEqual((CFTypeRef)*v18, @"persistref")) {
            sub_10011AA54(*(void *)(a1 + 32), a2, v18);
          }
          uint64_t v20 = *v19++;
          int v18 = v20;
        }
        while (v20);
      }
    }
    return;
  }
  if (!a3 || !*(unsigned char *)(a1 + 41) || *a3) {
    return;
  }
  unint64_t v49 = 0;
  *(void *)CFTypeRef cf = 0;
  char v8 = *(__CFString ****)(a1 + 32);
  uint64_t v9 = sub_10000FD40(v8[2], kSecAttrModificationDate, (__CFString **)&v49);
  CFDateRef v10 = (const __CFDate *)sub_100118CF8(v8, (uint64_t)v9, (__CFString **)cf);
  CFDateRef v11 = (const __CFDate *)sub_100118CF8(a2, (uint64_t)v9, (__CFString **)cf);
  CFDateRef v12 = v11;
  if (v10) {
    BOOL v13 = v11 == 0;
  }
  else {
    BOOL v13 = 1;
  }
  if (v13)
  {
    if (SecErrorGetOSStatus() == -26275)
    {
      if (v10) {
        CFAllocatorRef v14 = v8;
      }
      else {
        CFAllocatorRef v14 = 0;
      }
      BOOL v15 = v12 == 0;
      goto LABEL_17;
    }
LABEL_56:
    uint64_t v16 = 0;
    goto LABEL_57;
  }
  CFComparisonResult v21 = CFDateCompare(v10, v11, 0);
  uint64_t v16 = (uint64_t)a2;
  if (v21 == kCFCompareLessThan) {
    goto LABEL_57;
  }
  if (v21)
  {
    uint64_t v16 = 0;
    if (v21 == kCFCompareGreaterThan) {
      uint64_t v16 = (uint64_t)v8;
    }
    goto LABEL_57;
  }
  uint64_t v22 = sub_100118974(v8[2], 7, (__CFString **)cf);
  CFDataRef v23 = (const __CFData *)sub_100118CF8(v8, v22, (__CFString **)cf);
  uint64_t v24 = sub_100118974(a2[2], 7, (__CFString **)cf);
  CFDataRef v25 = (const __CFData *)sub_100118CF8(a2, v24, (__CFString **)cf);
  CFDataRef v26 = v25;
  if (!v23 || !v25)
  {
    if (SecErrorGetOSStatus() == -26275)
    {
      if (v23) {
        CFAllocatorRef v14 = v8;
      }
      else {
        CFAllocatorRef v14 = 0;
      }
      BOOL v15 = v26 == 0;
LABEL_17:
      if (v15) {
        uint64_t v16 = (uint64_t)v14;
      }
      else {
        uint64_t v16 = (uint64_t)a2;
      }
      goto LABEL_57;
    }
    goto LABEL_56;
  }
  CFIndex Length = CFDataGetLength(v23);
  CFIndex v28 = CFDataGetLength(v26);
  unint64_t v29 = v28;
  if (Length < 0 || v28 < 0)
  {
    uint64_t v16 = (uint64_t)a2;
    if (Length > v28) {
      goto LABEL_57;
    }
    BOOL v34 = Length < v28;
  }
  else
  {
    if (Length >= v28) {
      size_t v30 = v28;
    }
    else {
      size_t v30 = Length;
    }
    BytePtr = CFDataGetBytePtr(v23);
    int v32 = CFDataGetBytePtr(v26);
    int v33 = memcmp(BytePtr, v32, v30);
    uint64_t v16 = (uint64_t)a2;
    if (v33 > 0) {
      goto LABEL_57;
    }
    if (!v33)
    {
      uint64_t v16 = (uint64_t)a2;
      if (Length > v29) {
        goto LABEL_57;
      }
    }
    BOOL v34 = v33 == 0;
    if (Length >= v29) {
      BOOL v34 = 0;
    }
    if (v33 < 0) {
      BOOL v34 = 1;
    }
  }
  uint64_t v16 = (uint64_t)v8;
  if (!v34) {
    uint64_t v16 = (uint64_t)a2;
  }
LABEL_57:
  BOOL v35 = *(const void **)cf;
  if (!*(void *)cf) {
    goto LABEL_61;
  }
  if (v16 | v49)
  {
    *(void *)CFTypeRef cf = 0;
    CFRelease(v35);
LABEL_61:
    if (!v16) {
      goto LABEL_72;
    }
    uint64_t v36 = *(void *)(v16 + 16);
    __int16 v37 = *(uint64_t **)(v36 + 16);
    if (v37)
    {
      uint64_t v38 = (uint64_t **)(v36 + 24);
      do
      {
        if (*v37 && CFEqual((CFTypeRef)*v37, @"persistref")) {
          sub_10011AA54(v16, v8, v37);
        }
        CFTypeID v39 = *v38++;
        __int16 v37 = v39;
      }
      while (v39);
    }
    CFRetain((CFTypeRef)v16);
    CFRetain((CFTypeRef)v16);
    *a3 = v16;
    if (a2 && CFEqual((CFTypeRef)v16, a2))
    {
      uint64_t v40 = sub_10000B070("insert");
      if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)CFTypeRef cf = 138477827;
        *(void *)&cf[4] = a2;
        int v41 = "Conflict resolver chose my (local) item: %{private}@";
LABEL_85:
        int v48 = v40;
        goto LABEL_86;
      }
    }
    else
    {
      CFTypeID v45 = *(const void **)(a1 + 32);
      if (v45 && CFEqual((CFTypeRef)v16, v45))
      {
        CFNumberRef v46 = sub_10000B070("insert");
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v47 = *(void *)(a1 + 32);
          *(_DWORD *)CFTypeRef cf = 138477827;
          *(void *)&cf[4] = v47;
          int v41 = "Conflict resolver chose item from the backup: %{private}@";
          int v48 = v46;
LABEL_86:
          _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, v41, cf, 0xCu);
        }
      }
      else
      {
        uint64_t v40 = sub_10000B070("insert");
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)CFTypeRef cf = 138477827;
          *(void *)&cf[4] = v16;
          int v41 = "Conflict resolver created a new item; return it to our caller: %{private}@";
          goto LABEL_85;
        }
      }
    }
    CFRelease((CFTypeRef)v16);
    return;
  }
  unint64_t v49 = *(void *)cf;
LABEL_72:
  CFTypeID v42 = sub_10000B070("SecError");
  if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)CFTypeRef cf = 138412290;
    *(void *)&cf[4] = v49;
    _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "insert: failed to created a merged item: %@", cf, 0xCu);
  }
  CFTypeID v43 = sub_10000B070("insert");
  if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)CFTypeRef cf = 0;
    _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "failed to create a merged item so we will choose the item from the backup", cf, 2u);
  }
  BOOL v44 = *(const void **)(a1 + 32);
  if (v44) {
    CFRetain(v44);
  }
  *a3 = (uint64_t)v44;
}

BOOL sub_10011E31C(CFStringRef **a1, uint64_t a2, CFTypeRef *a3, uint64_t a4)
{
  CFAllocatorRef v8 = CFGetAllocator(a1);
  CFMutableArrayRef Mutable = CFStringCreateMutable(v8, 0);
  CFStringAppend(Mutable, @"DELETE FROM ");
  CFStringAppend(Mutable, *a1[2]);
  LOBYTE(v19) = 1;
  CFDateRef v10 = a1[2];
  CFDateRef v11 = (const __CFString **)v10[2];
  if (v11)
  {
    CFDateRef v12 = (const __CFString ***)(v10 + 3);
    do
    {
      if ((*(unsigned int (**)(uint64_t, const __CFString **))(a4 + 16))(a4, v11)) {
        sub_100011710(Mutable, *v11, &v19);
      }
      BOOL v13 = *v12++;
      CFDateRef v11 = v13;
    }
    while (v13);
  }
  uint64_t v19 = 0;
  uint64_t v20 = &v19;
  uint64_t v21 = 0x2000000000;
  BOOL v22 = Mutable != 0;
  if (Mutable)
  {
    v18[0] = _NSConcreteStackBlock;
    v18[1] = 0x40000000;
    void v18[2] = sub_10011E4A8;
    v18[3] = &unk_1002FAD48;
    void v18[6] = a1;
    v18[7] = a3;
    void v18[4] = a4;
    v18[5] = &v19;
    v18[8] = a2;
    char v14 = sub_10002742C(a2, (uint64_t)Mutable, a3, (uint64_t)v18);
    if (*((unsigned char *)v20 + 24)) {
      char v15 = v14;
    }
    else {
      char v15 = 0;
    }
    *((unsigned char *)v20 + 24) = v15;
    CFRelease(Mutable);
    BOOL v16 = *((unsigned char *)v20 + 24) != 0;
  }
  else
  {
    BOOL v16 = 0;
  }
  _Block_object_dispose(&v19, 8);
  return v16;
}

CFStringRef sub_10011E4A8(void *a1, sqlite3_stmt *pStmt)
{
  uint64_t v5 = a1[6];
  uint64_t v4 = (__CFString **)a1[7];
  uint64_t v6 = *(void *)(v5 + 16);
  uint64_t v7 = *(unsigned char **)(v6 + 16);
  if (v7)
  {
    LODWORD(v_Block_object_dispose(&STACK[0x3F0], 8) = 0;
    uint64_t v9 = a1[4];
    CFDateRef v10 = (void *)(v6 + 24);
    while (1)
    {
      if ((*(unsigned int (**)(uint64_t, unsigned char *))(v9 + 16))(v9, v7))
      {
        CFStringRef result = (const __CFString *)sub_10011BB4C((CFMutableDictionaryRef *)v5, v7, v4);
        if (!result) {
          goto LABEL_9;
        }
        CFStringRef v12 = result;
        uint64_t v8 = (v8 + 1);
        int v13 = sub_10000E8B0(pStmt, v8, result, (CFTypeRef *)v4);
        CFRelease(v12);
        if (!v13) {
          break;
        }
      }
      char v14 = (unsigned char *)*v10++;
      uint64_t v7 = v14;
      if (!v14)
      {
        uint64_t v4 = (__CFString **)a1[7];
        goto LABEL_8;
      }
    }
    CFStringRef result = 0;
  }
  else
  {
LABEL_8:
    CFStringRef result = (const __CFString *)sub_1000275B0(a1[8], pStmt, (CFTypeRef *)v4, 0);
  }
LABEL_9:
  *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = (_BYTE)result;
  return result;
}

BOOL sub_10011E594(id a1, const SecDbAttr *a2)
{
  return a2->var1 == 8;
}

BOOL sub_10011E5A4(CFStringRef **a1, uint64_t a2, CFTypeRef *a3, uint64_t a4)
{
  BOOL v6 = sub_10011E31C(a1, a2, a3, a4);
  if (v6)
  {
    uint64_t v7 = sub_10000B070("item");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 138478083;
      CFDateRef v10 = a1;
      __int16 v11 = 2112;
      uint64_t v12 = a2;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "deleted %{private}@ from %@", (uint8_t *)&v9, 0x16u);
    }
    sub_100029024(a2, (uint64_t)a1, 0);
  }
  return v6;
}

uint64_t sub_10011E680(void **a1, void **a2, uint64_t a3, CFBooleanRef a4, int a5, __CFString **a6)
{
  uint64_t v44 = 0;
  CFTypeID v45 = &v44;
  uint64_t v46 = 0x2000000000;
  char v47 = 1;
  uint64_t v40 = 0;
  int v41 = (CFTypeRef *)&v40;
  uint64_t v42 = 0x2000000000;
  uint64_t v43 = 0;
  uint64_t v12 = sub_100118974(a1[2], 10, a6);
  int v13 = sub_100118CF8(a1, v12, a6);
  uint64_t v14 = sub_100118974(a2[2], 10, a6);
  char v15 = sub_100118CF8(a2, v14, a6);
  if (v13) {
    BOOL v16 = v15 == 0;
  }
  else {
    BOOL v16 = 1;
  }
  char v17 = !v16;
  *((unsigned char *)v45 + 24) = v17;
  if (!v16 && CFEqual(v13, v15))
  {
    unsigned __int8 v18 = sub_10011D714(a2, a1, a6);
    *((unsigned char *)v45 + 24) = v18;
    char v19 = 1;
    goto LABEL_18;
  }
  if (a4 && kCFBooleanFalse)
  {
    if (!CFEqual(a4, kCFBooleanFalse))
    {
LABEL_15:
      if (sub_1000B14D4()) {
        sub_100138D94(a2, a5, a6);
      }
    }
  }
  else if (kCFBooleanFalse != a4)
  {
    goto LABEL_15;
  }
  char v19 = 0;
LABEL_18:
  uint64_t v20 = v45;
  if (*((unsigned char *)v45 + 24))
  {
    BOOL v21 = sub_10011D784((__CFString ***)a1, (CFStringRef **)a2, a3, v41 + 3, (uint64_t)&stru_1002FAA58);
    uint64_t v20 = v45;
  }
  else
  {
    BOOL v21 = 0;
  }
  *((unsigned char *)v20 + 24) = v21;
  BOOL v22 = (__CFError *)v41[3];
  if (v22)
  {
    if (CFErrorGetCode(v22) == 19)
    {
      CFErrorDomain Domain = CFErrorGetDomain((CFErrorRef)v41[3]);
      if (CFEqual(@"com.apple.utilities.sqlite3", Domain))
      {
        uint64_t v24 = (CFDictionaryRef *)sub_10011C45C(a2, a6);
        *((unsigned char *)v45 + 24) = v24 != 0;
        if (v24)
        {
          CFDataRef v25 = (const void **)v24;
          v39[0] = _NSConcreteStackBlock;
          v39[1] = 0x40000000;
          v39[2] = sub_10011EA40;
          v39[3] = &unk_1002FAB40;
          v39[6] = a6;
          v39[7] = a2;
          v39[8] = a1;
          v39[9] = a3;
          uint8_t v39[4] = &v44;
          v39[5] = &v40;
          BOOL v26 = sub_10011C750(v24, a3, (CFTypeRef *)a6, 0, &stru_1002FAA98, 0, 0, (uint64_t)v39);
          if (*((unsigned char *)v45 + 24)) {
            BOOL v27 = v26;
          }
          else {
            BOOL v27 = 0;
          }
          *((unsigned char *)v45 + 24) = v27;
          char v28 = sub_10000C2C4(v25, (CFErrorRef *)a6);
          if (*((unsigned char *)v45 + 24)) {
            char v29 = v28;
          }
          else {
            char v29 = 0;
          }
          *((unsigned char *)v45 + 24) = v29;
        }
      }
    }
    size_t v30 = v41;
    uint64_t v31 = (__CFString *)v41[3];
    uint64_t v20 = v45;
    if (v31)
    {
      *((unsigned char *)v45 + 24) = 0;
      if (a6 && !*a6)
      {
        *a6 = v31;
        void v30[3] = 0;
      }
      else
      {
        CFRelease(v31);
        uint64_t v20 = v45;
      }
    }
  }
  if (*((unsigned char *)v20 + 24)) {
    char v32 = v19;
  }
  else {
    char v32 = 1;
  }
  if ((v32 & 1) == 0)
  {
    if (a4 && kCFBooleanFalse)
    {
      if (CFEqual(a4, kCFBooleanFalse)) {
        goto LABEL_52;
      }
    }
    else if (kCFBooleanFalse == a4)
    {
      goto LABEL_52;
    }
    int v33 = (CFStringRef **)sub_10011EB98((uint64_t)a1, a4, 0, a6);
    *((unsigned char *)v45 + 24) = v33 != 0;
    if (v33)
    {
      BOOL v34 = v33;
      CFDataRef v35 = CFUUIDCreate(kCFAllocatorDefault);
      int v36 = sub_10011A9B8((uint64_t)v34, kSecAttrPersistentReference, v35, a6);
      if (v36)
      {
        sub_10011B874((uint64_t)v34, a6);
        LOBYTE(v36) = sub_10011BD68(v34, a3, a6);
      }
      *((unsigned char *)v45 + 24) = v36;
      if (v35) {
        CFRelease(v35);
      }
      CFRelease(v34);
    }
  }
LABEL_52:
  uint64_t v37 = *((unsigned __int8 *)v45 + 24);
  _Block_object_dispose(&v40, 8);
  _Block_object_dispose(&v44, 8);
  return v37;
}

void sub_10011EA40(uint64_t a1, __CFString *a2)
{
  unsigned __int8 v13 = 0;
  char v4 = sub_10011D080(a2, &v13, *(CFErrorRef **)(a1 + 48));
  int v5 = 0;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v4;
  int v6 = v13;
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    BOOL v7 = v13 == 0;
  }
  else {
    BOOL v7 = 0;
  }
  if (v7)
  {
    if (sub_10011BAEC(a2))
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = sub_10011D714(*(void ***)(a1 + 56), a2, *(__CFString ***)(a1 + 48));
      int v5 = 1;
    }
    else
    {
      int v5 = 0;
    }
  }
  if (v6) {
    int v5 = 1;
  }
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
    BOOL v8 = v5 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (!v8)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = sub_10011E5A4(*(CFStringRef ***)(a1 + 64), *(void *)(a1 + 72), *(CFTypeRef **)(a1 + 48), (uint64_t)&stru_1002FAAD8);
    uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8);
    if (*(unsigned char *)(v9 + 24))
    {
      BOOL v10 = sub_10011D784((__CFString ***)a2, *(CFStringRef ***)(a1 + 56), *(void *)(a1 + 72), *(CFTypeRef **)(a1 + 48), (uint64_t)&stru_1002FAB18);
      uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8);
    }
    else
    {
      BOOL v10 = 0;
    }
    *(unsigned char *)(v9 + 24) = v10;
    uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8);
    uint64_t v12 = *(const void **)(v11 + 24);
    if (v12)
    {
      *(void *)(v11 + 24) = 0;
      CFRelease(v12);
    }
  }
}

const void *sub_10011EB98(uint64_t a1, const __CFData *a2, int a3, __CFString **a4)
{
  CFAllocatorRef v8 = CFGetAllocator((CFTypeRef)a1);
  uint64_t v9 = (const void *)sub_10011AD64(v8, *(void *)(a1 + 16), *(_DWORD *)(a1 + 28), *(void *)(a1 + 32));
  uint64_t v10 = *(void *)(a1 + 16);
  uint64_t v11 = *(void *)(v10 + 16);
  if (!v11) {
    return v9;
  }
  for (uint64_t i = (uint64_t *)(v10 + 24); ; ++i)
  {
    unsigned int v13 = *(_DWORD *)(v11 + 8);
    if (v13 == 12)
    {
      uint64_t v14 = (uint64_t)v9;
      char v15 = (void *)v11;
      CFDataRef v16 = kCFBooleanTrue;
LABEL_13:
      if ((sub_1001196B4(v14, v15, v16, a4) & 1) == 0) {
        break;
      }
      goto LABEL_14;
    }
    uint64_t v17 = *(void *)(v11 + 16);
    if ((v17 & 1) != 0 || (v13 <= 0xE ? (BOOL v18 = ((1 << v13) & 0x4120) == 0) : (BOOL v18 = 1), !v18 || (v17 & 0x2000) != 0))
    {
      CFDataRef v19 = (const __CFData *)sub_100118CF8((const void *)a1, v11, a4);
      if (!v19) {
        break;
      }
      CFDataRef v20 = v19;
      if (CFEqual(kCFNull, v19)) {
        goto LABEL_14;
      }
      uint64_t v14 = (uint64_t)v9;
      char v15 = (void *)v11;
      CFDataRef v16 = v20;
      goto LABEL_13;
    }
    if (v13 != 6)
    {
      if (a2 && v13 == 13) {
        sub_1001196B4((uint64_t)v9, (void *)v11, a2, a4);
      }
      goto LABEL_14;
    }
    if (a3) {
      sub_10011AA54((uint64_t)v9, (const void *)a1, (uint64_t *)v11);
    }
    if ((sub_10011DC9C(v9, (const void *)a1, (void *)v11, a4) & 1) == 0) {
      break;
    }
LABEL_14:
    uint64_t v21 = *i;
    uint64_t v11 = v21;
    if (!v21) {
      return v9;
    }
  }
  if (v9)
  {
    CFRelease(v9);
    return 0;
  }
  return v9;
}

BOOL sub_10011ED3C(id a1, const SecDbAttr *a2)
{
  return a2->var2 & 1;
}

BOOL sub_10011ED48(id a1, const SecDbAttr *a2)
{
  return a2->var1 == 8;
}

BOOL sub_10011ED58(id a1, const SecDbAttr *a2)
{
  return a2->var1 == 8;
}

BOOL sub_10011ED68(id a1, const SecDbAttr *a2)
{
  return a2->var1 == 8;
}

CFStringRef **sub_10011ED78(CFStringRef **a1, uint64_t a2, CFBooleanRef cf1, int a4, CFTypeRef *a5)
{
  if (cf1 && kCFBooleanFalse)
  {
    if (CFEqual(cf1, kCFBooleanFalse))
    {
LABEL_4:
      return (CFStringRef **)sub_10011E5A4(a1, a2, a5, (uint64_t)&stru_1002FABC0);
    }
  }
  else if (kCFBooleanFalse == cf1)
  {
    goto LABEL_4;
  }
  CFStringRef result = (CFStringRef **)sub_10011EB98((uint64_t)a1, cf1, a4, (__CFString **)a5);
  if (result)
  {
    uint64_t v11 = result;
    BOOL v12 = sub_10011D784((__CFString ***)a1, result, a2, a5, (uint64_t)&stru_1002FAB80);
    CFRelease(v11);
    return (CFStringRef **)v12;
  }
  return result;
}

BOOL sub_10011EE60(id a1, const SecDbAttr *a2)
{
  return a2->var1 == 8;
}

BOOL sub_10011EE70(id a1, const SecDbAttr *a2)
{
  return a2->var1 == 8;
}

void sub_10011F500(uint64_t a1, void *a2)
{
  uint64_t v3 = *(void **)(a1 + 32);
  id v4 = a2;
  int v5 = [v3 name];
  int v6 = sub_10000B100((const __CFString *)+[NSString stringWithFormat:@"%@-%@", v5, @"state-rpc"]);

  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a1 + 40);
    CFAllocatorRef v8 = [*(id *)(a1 + 48) result];
    uint64_t v9 = [v8 error];
    uint64_t v10 = (void *)v9;
    CFStringRef v11 = @"no error";
    if (v9) {
      CFStringRef v11 = (const __CFString *)v9;
    }
    *(_DWORD *)long long buf = 138412546;
    uint64_t v18 = v7;
    __int16 v19 = 2112;
    CFStringRef v20 = v11;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Returning '%@' result: %@", buf, 0x16u);
  }
  uint64_t v12 = *(void *)(a1 + 56);
  if (v12)
  {
    unsigned int v13 = [*(id *)(a1 + 48) result];
    uint64_t v14 = [v13 error];
    (*(void (**)(uint64_t, void *))(v12 + 16))(v12, v14);
  }
  char v15 = [*(id *)(a1 + 48) result];
  CFDataRef v16 = [v15 error];
  [v4 setError:v16];
}

void sub_10011FAB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
  objc_destroyWeak(v19);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10011FAEC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 56));
  uint64_t v3 = [WeakRetained name];
  id v4 = sub_10000B100((const __CFString *)+[NSString stringWithFormat:@"%@-%@", v3, @"state-rpc"]);

  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = [*(id *)(a1 + 40) error];
    uint64_t v7 = (void *)v6;
    CFStringRef v8 = @"no error";
    if (v6) {
      CFStringRef v8 = (const __CFString *)v6;
    }
    *(_DWORD *)long long buf = 138412546;
    uint64_t v12 = v5;
    __int16 v13 = 2112;
    CFStringRef v14 = v8;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Returning '%@' result: %@", buf, 0x16u);
  }
  uint64_t v9 = *(void *)(a1 + 48);
  uint64_t v10 = [*(id *)(a1 + 40) error];
  (*(void (**)(uint64_t, void *))(v9 + 16))(v9, v10);
}

void sub_10011FDD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
}

void sub_10011FDE4(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v2 = *(void **)(a1 + 32);
  uint64_t v3 = [WeakRetained currentState];
  id v4 = [WeakRetained timeoutErrorForState:v3];
  [v2 onqueueHandleStartTimeout:v4];
}

id sub_10011FF28(uint64_t a1)
{
  return [*(id *)(a1 + 32) _onqueueRegisterMultiStateArrivalWatcher:*(void *)(a1 + 40) startTimeout:*(void *)(a1 + 48)];
}

void sub_10011FFF4(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) stateMachineWatchers];
  [v2 addObject:*(void *)(a1 + 40)];

  [*(id *)(a1 + 32) _onqueuePokeStateMachine];
  if ((unint64_t)(*(void *)(a1 + 48) + 1) >= 2)
  {
    id location = (id)0xAAAAAAAAAAAAAAAALL;
    objc_initWeak(&location, *(id *)(a1 + 32));
    dispatch_time_t v3 = dispatch_time(0, *(void *)(a1 + 48));
    id v4 = [*(id *)(a1 + 32) queue];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10012012C;
    block[3] = &unk_100306AD0;
    objc_copyWeak(&v7, &location);
    id v6 = *(id *)(a1 + 40);
    dispatch_after(v3, v4, block);

    objc_destroyWeak(&v7);
    objc_destroyWeak(&location);
  }
}

void sub_100120118(_Unwind_Exception *a1)
{
  objc_destroyWeak((id *)(v1 - 40));
  _Unwind_Resume(a1);
}

void sub_10012012C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v2 = *(void **)(a1 + 32);
  dispatch_time_t v3 = [WeakRetained currentState];
  id v4 = [WeakRetained timeoutErrorForState:v3];
  [v2 onqueueHandleStartTimeout:v4];
}

void sub_100120270(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) stateMachineRequests];
  [v2 addObject:*(void *)(a1 + 40)];

  [*(id *)(a1 + 32) _onqueuePokeStateMachine];
  if ((unint64_t)(*(void *)(a1 + 48) + 1) >= 2)
  {
    id location = (id)0xAAAAAAAAAAAAAAAALL;
    objc_initWeak(&location, *(id *)(a1 + 32));
    dispatch_time_t v3 = dispatch_time(0, *(void *)(a1 + 48));
    id v4 = [*(id *)(a1 + 32) queue];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1001203A8;
    block[3] = &unk_100306AD0;
    objc_copyWeak(&v7, &location);
    id v6 = *(id *)(a1 + 40);
    dispatch_after(v3, v4, block);

    objc_destroyWeak(&v7);
    objc_destroyWeak(&location);
  }
}

void sub_100120394(_Unwind_Exception *a1)
{
  objc_destroyWeak((id *)(v1 - 40));
  _Unwind_Resume(a1);
}

void sub_1001203A8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v2 = *(void **)(a1 + 32);
  dispatch_time_t v3 = [WeakRetained currentState];
  id v4 = [WeakRetained timeoutErrorForState:v3];
  [v2 onqueueHandleStartTimeout:v4];
}

id sub_1001205C4(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) holdStateMachineOperation];

  if (v2)
  {
    dispatch_time_t v3 = [*(id *)(a1 + 32) operationQueue];
    id v4 = [*(id *)(a1 + 32) holdStateMachineOperation];
    [v3 addOperation:v4];

    [*(id *)(a1 + 32) setHoldStateMachineOperation:0];
  }
  [*(id *)(a1 + 32) setHalted:1];
  [*(id *)(a1 + 32) setAllowPendingFlags:0];
  uint64_t v5 = *(void **)(a1 + 32);

  return [v5 _onqueuePokeStateMachine];
}

void sub_1001206F8(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) holdStateMachineOperation];

  if (v2)
  {
    dispatch_time_t v3 = [*(id *)(a1 + 32) operationQueue];
    id v4 = [*(id *)(a1 + 32) holdStateMachineOperation];
    [v3 addOperation:v4];

    uint64_t v5 = *(void **)(a1 + 32);
    [v5 setHoldStateMachineOperation:0];
  }
}

void sub_100120854(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10012086C(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) nextStateMachineCycleOperation];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v2 == 0;
}

id sub_100120970(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) name];
  dispatch_time_t v3 = sub_10000B100((const __CFString *)+[NSString stringWithFormat:@"%@-%@", v2, @"test"]);

  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v4 = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 138412290;
    uint64_t v8 = v4;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Releasing state machine test pause from %@", buf, 0xCu);
  }

  uint64_t v5 = [*(id *)(a1 + 32) testHoldStates];
  [v5 removeObject:*(void *)(a1 + 40)];

  return [*(id *)(a1 + 32) _onqueuePokeStateMachine];
}

void sub_100120B34(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) testHoldStates];
  [v2 addObject:*(void *)(a1 + 40)];
}

void sub_1001216F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id location)
{
  objc_destroyWeak(v22);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100121758(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v2 = WeakRetained;
  if (WeakRetained)
  {
    dispatch_time_t v3 = [WeakRetained queue];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100121968;
    block[3] = &unk_100308558;
    void block[4] = v2;
    dispatch_sync(v3, block);
  }
}

void sub_1001217F4(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v2 = WeakRetained;
  if (WeakRetained)
  {
    dispatch_time_t v3 = [WeakRetained queue];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100121890;
    block[3] = &unk_100308558;
    void block[4] = v2;
    dispatch_sync(v3, block);
  }
}

id sub_100121890(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) name];
  dispatch_time_t v3 = sub_10000B100((const __CFString *)+[NSString stringWithFormat:@"%@-%@", v2, @"pending-flag"]);

  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Network is reachable", buf, 2u);
  }

  [*(id *)(a1 + 32) setConditionChecksInFlight:((unint64_t)[*(id *)(a1 + 32) conditionChecksInFlight] & 0xFFFFFFFFFFFFFFFDLL)];
  [*(id *)(a1 + 32) _onqueueRecheckConditions];
  return [*(id *)(a1 + 32) _onqueueSendAnyPendingFlags];
}

id sub_100121968(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) name];
  dispatch_time_t v3 = sub_10000B100((const __CFString *)+[NSString stringWithFormat:@"%@-%@", v2, @"pending-flag"]);

  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Unlock occurred", buf, 2u);
  }

  [*(id *)(a1 + 32) setConditionChecksInFlight:((unint64_t)[*(id *)(a1 + 32) conditionChecksInFlight] & 0xFFFFFFFFFFFFFFFELL)];
  [*(id *)(a1 + 32) _onqueueRecheckConditions];
  return [*(id *)(a1 + 32) _onqueueSendAnyPendingFlags];
}

void sub_100121BAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100121BC4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_100121BD4(uint64_t a1)
{
}

void sub_100121BDC(uint64_t a1)
{
  long long v12 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  id v2 = [*(id *)(a1 + 32) pendingFlags];
  dispatch_time_t v3 = [v2 allKeys];

  id v4 = [v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v13;
    do
    {
      id v7 = 0;
      do
      {
        if (*(void *)v13 != v6) {
          objc_enumerationMutation(v3);
        }
        uint64_t v8 = *(void *)(*((void *)&v12 + 1) + 8 * (void)v7);
        uint64_t v9 = [*(id *)(a1 + 32) pendingFlags];
        uint64_t v10 = [v9 objectForKeyedSubscript:v8];
        CFStringRef v11 = [v10 description];
        [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) setObject:v11 forKeyedSubscript:v8];

        id v7 = (char *)v7 + 1;
      }
      while (v5 != v7);
      id v5 = [v3 countByEnumeratingWithState:&v12 objects:v16 count:16];
    }
    while (v5);
  }
}

id sub_100121DC8(uint64_t a1)
{
  return [*(id *)(a1 + 32) setAllowPendingFlags:0];
}

void sub_100121F64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100121F84(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v2 = [WeakRetained queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100122018;
  block[3] = &unk_100308558;
  void block[4] = WeakRetained;
  dispatch_sync(v2, block);
}

id sub_100122018(uint64_t a1)
{
  id v2 = [*(id *)(a1 + 32) name];
  dispatch_time_t v3 = sub_10000B100((const __CFString *)+[NSString stringWithFormat:@"%@-%@", v2, @"pending-flag"]);

  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)long long buf = 0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Finished waiting for operation", buf, 2u);
  }

  return [*(id *)(a1 + 32) _onqueueSendAnyPendingFlags];
}

id sub_10012219C(uint64_t a1)
{
  return [*(id *)(a1 + 32) _onqueueHandlePendingFlag:*(void *)(a1 + 40)];
}

id sub_10012225C(uint64_t a1)
{
  return [*(id *)(a1 + 32) _onqueueHandlePendingFlag:*(void *)(a1 + 40)];
}

id sub_100122398(uint64_t a1)
{
  return [*(id *)(a1 + 32) _onqueueHandleFlag:*(void *)(a1 + 40)];
}

id sub_100122478(uint64_t a1)
{
  return [*(id *)(a1 + 32) _onqueuePokeStateMachine];
}

void sub_1001225B8(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_1001225D8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  dispatch_time_t v3 = [WeakRetained queue];
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 3221225472;
  v4[2] = sub_100122690;
  v4[3] = &unk_100305930;
  void v4[4] = WeakRetained;
  id v5 = *(id *)(a1 + 32);
  dispatch_sync(v3, v4);
}

id sub_100122690(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) name];
  dispatch_time_t v3 = sub_10000B100((const __CFString *)+[NSString stringWithFormat:@"%@-%@", v2, @"state"]);

  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    id v4 = [*(id *)(a1 + 40) nextState];
    id v5 = [*(id *)(a1 + 40) intendedState];
    uint64_t v6 = [*(id *)(a1 + 32) currentFlags];
    id v7 = [v6 contentsAsString];
    uint64_t v8 = [*(id *)(a1 + 32) pendingFlagsString];
    uint64_t v9 = *(void **)(a1 + 40);
    uint64_t v10 = [v9 error];
    CFStringRef v11 = (void *)v10;
    *(_DWORD *)long long buf = 138413570;
    CFStringRef v12 = @"(no error)";
    int v36 = v4;
    if (v10) {
      CFStringRef v12 = (const __CFString *)v10;
    }
    __int16 v37 = 2112;
    uint64_t v38 = v5;
    __int16 v39 = 2112;
    uint64_t v40 = v7;
    __int16 v41 = 2112;
    uint64_t v42 = v8;
    __int16 v43 = 2112;
    uint64_t v44 = v9;
    __int16 v45 = 2112;
    CFStringRef v46 = v12;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "Finishing state transition attempt (ending in %@, intended: %@, f:[%@], p:[%@]): %@ %@", buf, 0x3Eu);
  }
  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  long long v13 = [*(id *)(a1 + 32) stateMachineWatchers];
  id v14 = [v13 countByEnumeratingWithState:&v30 objects:v34 count:16];
  if (v14)
  {
    id v15 = v14;
    uint64_t v16 = *(void *)v31;
    do
    {
      for (uint64_t i = 0; i != v15; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v31 != v16) {
          objc_enumerationMutation(v13);
        }
        uint64_t v18 = *(void **)(*((void *)&v30 + 1) + 8 * i);
        __int16 v19 = [*(id *)(a1 + 32) name];
        CFStringRef v20 = sub_10000B100((const __CFString *)+[NSString stringWithFormat:@"%@-%@", v19, @"state"]);

        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          int v36 = v18;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "notifying watcher: %@", buf, 0xCu);
        }

        [v18 onqueueHandleTransition:*(void *)(a1 + 40)];
      }
      id v15 = [v13 countByEnumeratingWithState:&v30 objects:v34 count:16];
    }
    while (v15);
  }

  uint64_t v21 = [*(id *)(a1 + 32) stateMachineWatchers];
  BOOL v22 = (char *)[v21 count];

  if ((uint64_t)(v22 - 1) >= 0)
  {
    do
    {
      --v22;
      CFDataRef v23 = [*(id *)(a1 + 32) stateMachineWatchers];
      uint64_t v24 = [v23 objectAtIndexedSubscript:v22];
      CFDataRef v25 = [v24 result];
      unsigned int v26 = [v25 isFinished];

      if (v26)
      {
        BOOL v27 = [*(id *)(a1 + 32) stateMachineWatchers];
        [v27 removeObjectAtIndex:v22];
      }
    }
    while ((uint64_t)v22 > 0);
  }
  char v28 = [*(id *)(a1 + 40) nextState];
  [*(id *)(a1 + 32) setCurrentState:v28];

  [*(id *)(a1 + 32) setNextStateMachineCycleOperation:0];
  return [*(id *)(a1 + 32) _onqueueStartNextStateMachineOperation:1];
}

void sub_100123538(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100123550(uint64_t a1)
{
  id v5 = [*(id *)(a1 + 32) mutableStateConditions];
  id v2 = [v5 copy];
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void sub_100123AE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id location)
{
  objc_destroyWeak(v24);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100123B1C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v2 = [WeakRetained queue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_100123BC4;
  block[3] = &unk_100308558;
  id v5 = WeakRetained;
  id v3 = WeakRetained;
  dispatch_sync(v2, block);
}

id sub_100123BC4(uint64_t a1)
{
  return [*(id *)(a1 + 32) _onqueueSendAnyPendingFlags];
}

BOOL sub_100123BD0(const __CFData *a1, uint64_t a2, const __CFData *a3, __CFData *a4, const __CFDictionary *a5, __CFData **a6, int a7, char a8, CFTypeRef *a9)
{
  *(void *)&long long v16 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v16 + 1) = 0xAAAAAAAAAAAAAAAALL;
  bytes[0] = v16;
  bytes[1] = v16;
  CFMutableArrayRef Mutable = CFDataCreateMutable(0, 0);
  CFDataSetLength(Mutable, 72);
  uint64_t Constraints = SecAccessControlGetConstraints();
  uint64_t v22 = Constraints;
  if (Constraints) {
    int v23 = 6;
  }
  else {
    int v23 = 3;
  }
  CFTypeRef v81 = a6;
  if (!Constraints)
  {
    CFDataRef v24 = a3;
    CFDataRef v25 = a1;
    unsigned int v79 = v23;
    MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(0, 0, a4);
    BOOL v27 = MutableCopy;
    if (a5)
    {
      context[0] = _NSConcreteStackBlock;
      context[1] = 3221225472;
      context[2] = sub_1001243B0;
      context[3] = &unk_100308F10;
      void context[4] = MutableCopy;
      CFDictionaryApplyFunction(a5, (CFDictionaryApplierFunction)sub_100124518, context);
    }
    if (v27)
    {
      CFDictionaryRemoveValue(v27, kSecAttrAccessControl);
      a4 = sub_1000298CC((const __CFString *)v27, a9, v28, v29, v30);
      CFRelease(v27);
      a1 = v25;
      a3 = v24;
      uint64_t v22 = 0;
      if (a4) {
        goto LABEL_12;
      }
    }
    else
    {
      a4 = 0;
    }
LABEL_17:
    LOBYTE(v33) = 1;
LABEL_18:
    BOOL v35 = sub_100012A40(-50, (__CFString **)a9, @"ks_encrypt_data: invalid plain text");
    goto LABEL_19;
  }
  if (!a4) {
    goto LABEL_17;
  }
  unsigned int v79 = v23;
  a4 = sub_1000298CC((const __CFString *)a4, a9, v19, v20, v21);
  if (!a4) {
    goto LABEL_17;
  }
LABEL_12:
  CFDataRef theData = a1;
  CFTypeID v31 = CFGetTypeID(a4);
  CFTypeID TypeID = CFDataGetTypeID();
  LOBYTE(v33) = 0;
  if (!a2 || v31 != TypeID) {
    goto LABEL_18;
  }
  CFIndex Length = CFDataGetLength(a4);
  uint64_t v83 = 16;
  int v82 = 0;
  if (SecRandomCopyBytes(kSecRandomDefault, 0x20uLL, bytes))
  {
    BOOL v35 = sub_100012A40(-108, (__CFString **)a9, @"ks_encrypt_data: SecRandomCopyBytes failed");
    LOBYTE(v33) = 0;
LABEL_19:
    int v36 = 0;
    goto LABEL_20;
  }
  CFStringRef Protection = (const void *)SecAccessControlGetProtection();
  uint64_t v40 = sub_1001243B8(Protection, (__CFString **)a9);
  if (!v40)
  {
    LOBYTE(v33) = 0;
    int v36 = 0;
LABEL_73:
    BOOL v35 = 1;
    goto LABEL_20;
  }
  CFIndex v76 = Length;
  if (v22)
  {
    uint64_t v75 = v40;
    __int16 v41 = (const void *)SecAccessControlGetConstraints();
    uint64_t v42 = CFDictionaryCreateMutableCopy(0, 0, a5);
    CFDictionarySetValue(v42, @"acl", v41);
    int v36 = sub_1000298CC((const __CFString *)v42, 0, v43, v44, v45);
    if (v42) {
      CFRelease(v42);
    }
    long long v89 = 0;
    uint64_t v90 = 0;
    CFIndex v87 = 0;
    uint64_t v88 = 0;
    CFStringRef v46 = (const void *)SecAccessControlCopyData();
    __int16 v86 = 0;
    if (a3 && (SecAccessControlIsBound() & 1) != 0)
    {
      BytePtr = CFDataGetBytePtr(v36);
      CFIndex v47 = CFDataGetLength(v36);
      int v48 = CFDataGetBytePtr(a3);
      CFIndex v49 = CFDataGetLength(a3);
      sub_100018A78(0, 0, (uint64_t)BytePtr, v47, (uint64_t)v48, v49, &v90, &v88);
      uint64_t v50 = sub_100018F90((int)theData, v75, 0, (uint64_t)v90, v88, &v86);
      if (v50 || (uint64_t v50 = sub_1000191C0((uint64_t *)v86, (uint64_t)v90, v88, (uint64_t)bytes), v50))
      {
        sub_100154CB4(v50, @"oe", (uint64_t)theData, v75, (uint64_t)v46, a3, (__CFString **)a9);
      }
      else
      {
        CFIndex v85 = 0xAAAAAAAAAAAAAAAALL;
        CFDataRef v51 = (const UInt8 *)sub_10001A1FC((uint64_t *)v86, &v85);
        if (v51)
        {
          if (sub_100154600((UInt8 *)v89, v87, v51, v85, Mutable))
          {
            char v52 = 1;
LABEL_45:
            if (v86) {
              sub_100019344((uint64_t *)&v86);
            }
            if (v90) {
              free(v90);
            }
            if (v89) {
              free(v89);
            }
            if (v46) {
              CFRelease(v46);
            }
            if (v52)
            {
              unsigned int v53 = CFDataGetLength(Mutable);
              CFStringRef v54 = (const __CFString *)SecAccessControlGetProtection();
              CFIndex v58 = sub_10000FE8C(v54, 0, v55, v56, v57);
              long long v33 = CFDataCreateMutable(0, 0);
              CFDataSetLength(v33, v58);
              MutableBytePtr = CFDataGetMutableBytePtr(v33);
              uint64_t v60 = CFDataGetMutableBytePtr(v33);
              if (sub_10000F7B0(v54, 0, 0, MutableBytePtr, (unint64_t)&v60[v58]))
              {
                if (v33)
                {
                  CFDataRef theDataa = v33;
                  unsigned int v61 = CFDataGetLength(v33);
                  uint64_t v62 = v61 + 28;
                  CFIndex Length = v76;
                  goto LABEL_59;
                }
              }
              else
              {
                CFRelease(v33);
                LOBYTE(v33) = 0;
              }
              goto LABEL_73;
            }
            LOBYTE(v33) = 0;
LABEL_83:
            BOOL v35 = 0;
LABEL_20:
            memset_s(bytes, 0x20uLL, 0, 0x20uLL);
            __int16 v37 = 0;
            if (!Mutable) {
              goto LABEL_22;
            }
            goto LABEL_21;
          }
          sub_100012A40(-26275, (__CFString **)a9, @"ks_crypt_acl: %x failed to '%s' item (class %d, bag: %d) Item can't be encrypted due to merge failed, so drop the item.", 0, "encrypt", v75, theData);
        }
        else
        {
          sub_100012A40(-26275, (__CFString **)a9, @"ks_crypt_acl: %x failed to '%s' item (class %d, bag: %d) Item can't be encrypted due to invalid key data, so drop the item.", 0, "encrypt", v75, theData);
        }
      }
    }
    else
    {
      SecAccessControlIsBound();
      sub_100154A3C((CFErrorRef *)a9, (uint64_t)v46);
    }
    char v52 = 0;
    goto LABEL_45;
  }
  if (!sub_100014458(@"oe", (uint64_t)theData, 0, v40, 0x20u, bytes, &v82, Mutable, a8, (__CFString **)a9))
  {
    LOBYTE(v33) = 0;
    int v36 = 0;
    goto LABEL_83;
  }
  unsigned int v53 = CFDataGetLength(Mutable);
  int v36 = 0;
  unsigned int v61 = 0;
  CFDataRef theDataa = 0;
  uint64_t v62 = 28;
LABEL_59:
  CFIndex v63 = v62 + Length + v53;
  CFIndex v64 = CFDataCreateMutable(0, v63);
  __int16 v37 = v64;
  if (!v64)
  {
    BOOL v35 = 1;
    goto LABEL_69;
  }
  CFDataSetLength(v64, v63);
  unsigned int v65 = CFDataGetMutableBytePtr(v37);
  unsigned int v66 = v79 | 0x80000000;
  if (!a7) {
    unsigned int v66 = v79;
  }
  *(_DWORD *)unsigned int v65 = v66;
  if (v22)
  {
    *((_DWORD *)v65 + 1) = v61;
    CFAllocatorRef v67 = v65 + 8;
    v92.size_t length = v61;
    v92.id location = 0;
    CFDataGetBytes(theDataa, v92, v65 + 8);
    __int16 v68 = &v67[v61];
  }
  else
  {
    *((_DWORD *)v65 + 1) = v82;
    __int16 v68 = v65 + 8;
  }
  *(_DWORD *)__int16 v68 = v53;
  uint64_t v69 = (char *)(v68 + 4);
  if (a7) {
    CFDataGetMutableBytePtr(v37);
  }
  uint64_t v70 = CFDataGetBytePtr(Mutable);
  memcpy(v69, v70, v53);
  uint64_t v71 = &v69[v53];
  CFDataGetBytePtr(a4);
  uint64_t v72 = CCCryptorGCM();
  if (v72)
  {
    BOOL v35 = sub_100012A40(-26276, (__CFString **)a9, @"ks_encrypt_data: CCCryptorGCM failed: %d", v72);
LABEL_69:
    CFDataRef v73 = theDataa;
    goto LABEL_75;
  }
  CFDataRef v73 = theDataa;
  BOOL v35 = v83 == 16
     || sub_100012A40(-26276, (__CFString **)a9, @"ks_encrypt_data: CCCryptorGCM expected: 16 got: %ld byte tag", v83, v76, v71, &v71[v76], &v83);
LABEL_75:
  memset_s(bytes, 0x20uLL, 0, 0x20uLL);
  if (v73) {
    CFRelease(v73);
  }
  LOBYTE(v33) = 0;
  if (Mutable) {
LABEL_21:
  }
    CFRelease(Mutable);
LABEL_22:
  if ((v33 & 1) == 0) {
    CFRelease(a4);
  }
  if (v35)
  {
    *CFTypeRef v81 = v37;
  }
  else if (v37)
  {
    CFRelease(v37);
  }
  if (v36) {
    CFRelease(v36);
  }
  return v35;
}

void sub_1001243B0(uint64_t a1, const void *a2, const void *a3)
{
}

uint64_t sub_1001243B8(const void *a1, __CFString **a2)
{
  if (!a1)
  {
    sub_100012A40(-50, a2, @"accessible attribute %@ not a string", 0);
    return 0;
  }
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 != CFStringGetTypeID())
  {
    sub_100012A40(-50, a2, @"accessible attribute %@ not a string", a1);
    return 0;
  }
  if (CFEqual(a1, kSecAttrAccessibleWhenUnlocked)) {
    return 6;
  }
  if (CFEqual(a1, kSecAttrAccessibleAfterFirstUnlock)) {
    return 7;
  }
  if (CFEqual(a1, kSecAttrAccessibleAlwaysPrivate)) {
    return 8;
  }
  if (CFEqual(a1, kSecAttrAccessibleWhenUnlockedThisDeviceOnly)) {
    return 9;
  }
  if (CFEqual(a1, kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly)) {
    return 10;
  }
  if (CFEqual(a1, kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate)) {
    return 11;
  }
  if (!CFEqual(a1, kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly))
  {
    sub_100012A40(-50, a2, @"accessible attribute %@ unknown", a1);
    return 0;
  }
  return 12;
}

uint64_t sub_100124518(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

BOOL sub_100124534(const __CFData *a1, uint64_t a2, const __CFData *a3, CFDictionaryRef theDict, void *a5, const __CFDictionary *a6, __CFData **a7, int a8, char a9, __CFString **a10)
{
  if (dword_10035D2B0 == a1 && a9 == 0)
  {
    CFStringRef Protection = (const void *)SecAccessControlGetProtection();
    uint64_t v24 = sub_1001243B8(Protection, a10);
    if (v24)
    {
      uint64_t v25 = v24;
      uint64_t v40 = a7;
      if (a5)
      {
        id v26 = [a5 mutableCopy];
      }
      else
      {
        id v26 = +[NSMutableDictionary dictionary];
      }
      BOOL v27 = v26;
      [v26 addEntriesFromDictionary:a6];
      uint64_t v28 = (void *)SecAccessControlCopyData();
      [v27 setObject:v28 forKeyedSubscript:@"SecAccessControl"];

      uint64_t v29 = +[NSUUID UUID];
      uint64_t v30 = [v29 UUIDString];

      CFTypeID v31 = [[SecDbKeychainItemV7 alloc] initWithSecretAttributes:theDict metadataAttributes:v27 tamperCheck:v30 keyclass:v25];
      id v42 = 0;
      long long v32 = [(SecDbKeychainItemV7 *)v31 encryptedBlobWithKeybag:a1 accessControl:a2 acmContext:a3 error:&v42];
      id v33 = v42;
      BOOL v34 = v33;
      BOOL v22 = v32 != 0;
      if (v32)
      {
        +[NSMutableData dataWithLength:](NSMutableData, "dataWithLength:", (char *)[v32 length] + 4);
        id v35 = objc_claimAutoreleasedReturnValue();
        *(_DWORD *)[v35 mutableBytes] = 8;
        id v36 = v35;
        __int16 v37 = (char *)[v36 mutableBytes] + 4;
        id v38 = v32;
        memcpy(v37, [v38 bytes], (size_t)[v38 length]);
        void *v40 = (__CFData *)v36;
      }
      else if (a10)
      {
        *a10 = (__CFString *)v33;
      }
    }
    else
    {
      return 0;
    }
  }
  else
  {
    if ((a9 & 1) == 0)
    {
      if (qword_10035CF38 != -1) {
        dispatch_once(&qword_10035CF38, &stru_1002FADF8);
      }
      dispatch_source_merge_data((dispatch_source_t)qword_10035CF40, 1uLL);
    }
    CFIndex Count = CFDictionaryGetCount(theDict);
    CFIndex v20 = CFDictionaryGetCount((CFDictionaryRef)a5);
    MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(0, v20 + Count, (CFDictionaryRef)a5);
    context[0] = _NSConcreteStackBlock;
    context[1] = 3221225472;
    context[2] = sub_10012486C;
    context[3] = &unk_100308F10;
    void context[4] = MutableCopy;
    CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)sub_100124518, context);
    BOOL v22 = sub_100123BD0(a1, a2, a3, MutableCopy, a6, a7, a8, a9, (CFTypeRef *)a10);
    if (MutableCopy) {
      CFRelease(MutableCopy);
    }
  }
  return v22;
}

void sub_10012486C(uint64_t a1, const void *a2, const void *a3)
{
}

void sub_100124874(id a1)
{
  uint64_t v1 = sub_100029A10("non-device keybag", 2);
  id v2 = (void *)qword_10035CF40;
  qword_10035CF40 = (uint64_t)v1;

  id v3 = qword_10035CF40;
  context = dispatch_get_context((dispatch_object_t)qword_10035CF40);
  context[2] = _Block_copy(&stru_1002FAE18);

  dispatch_activate(v3);
}

void sub_1001248E4(id a1)
{
  uint64_t v1 = sub_10000B070("SecWarning");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_WORD *)id v2 = 0;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "ks_encrypt_data: called with non-device keybag - call should be rerouted to ks_encrypt_data_legacy", v2, 2u);
  }
}

__CFData *sub_100124954(const __CFString *a1, CFTypeRef *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  CFIndex v7 = sub_10000FE8C(a1, a2, a3, a4, a5);
  CFMutableArrayRef Mutable = CFDataCreateMutable(kCFAllocatorDefault, 0);
  CFDataSetLength(Mutable, v7);
  MutableBytePtr = CFDataGetMutableBytePtr(Mutable);
  uint64_t v10 = CFDataGetMutableBytePtr(Mutable);
  if (!sub_10000F7B0(a1, a2, 0, MutableBytePtr, (unint64_t)&v10[v7]))
  {
    CFRelease(Mutable);
    return 0;
  }
  return Mutable;
}

uint64_t sub_1001249F0(uint64_t a1, uint64_t a2, const UInt8 *a3, CFIndex a4, uint64_t a5, unsigned int a6, __CFDictionary **a7, void *a8, CFTypeRef *a9, __CFString **a10)
{
  uint64_t v41 = 0;
  CFDictionaryRef v42 = 0;
  CFDataRef v39 = 0;
  CFDataRef theData = 0;
  sub_10000F124(0, (int)&v42, 0, (uint64_t)a3, (uint64_t)&a3[a4]);
  CFDictionaryRef v16 = v42;
  if (!v42)
  {
    CFDataRef v17 = 0;
    MutableCFDictionaryRef Copy = 0;
    sub_100012A40(-26275, a10, @"kc_attribs_key_encrypted_data_from_blob: failed to decode 'blob data'");
    goto LABEL_52;
  }
  if (sub_100154980(v42, (CFTypeRef *)&v39, (CFTypeRef *)&theData))
  {
    CFDataRef v17 = v39;
  }
  else
  {
    CFDataRef v17 = CFDataCreate(kCFAllocatorDefault, a3, a4);
    CFDataRef v39 = v17;
    CFDataRef theData = (CFDataRef)CFRetain(v17);
  }
  if (!v17)
  {
    MutableCFDictionaryRef Copy = 0;
    sub_100012A40(-26275, a10, @"kc_attribs_key_encrypted_data_from_blob: failed to decode 'encrypted data'");
    goto LABEL_52;
  }
  CFDataRef v18 = theData;
  if (!theData)
  {
    MutableCFDictionaryRef Copy = 0;
    sub_100012A40(-26275, a10, @"kc_attribs_key_encrypted_data_from_blob: failed to decode 'key data'");
    goto LABEL_52;
  }
  uint64_t v38 = 0;
  BytePtr = CFDataGetBytePtr(theData);
  size_t Length = CFDataGetLength(v18);
  uint64_t v21 = sub_1000193F8(a1, BytePtr, Length, &v41);
  if (v21)
  {
    if (v21 == -536870206) {
      sub_100012A40(-26275, a10, @"aks_ref_key: failed to create ref key with blob because bad data (bag: %d)", a1);
    }
    else {
      sub_100012A40(-26275, a10, @"aks_ref_key: failed to create ref key with blob: %x (bag: %d)", v21, a1);
    }
    goto LABEL_24;
  }
  id v35 = a8;
  uint64_t v22 = sub_10001A208(v41, &v38);
  if (!v22)
  {
LABEL_24:
    uint64_t v31 = 0;
    MutableCFDictionaryRef Copy = 0;
    goto LABEL_25;
  }
  CFDictionaryRef theDict = 0;
  sub_10000F124(0, (int)&theDict, 0, v22, v22 + v38);
  CFDictionaryRef v23 = theDict;
  if (!theDict)
  {
    MutableCFDictionaryRef Copy = 0;
    sub_100012A40(-26275, a10, @"kc_attribs_key_encrypted_data_from_blob: failed to decode 'encrypted data dictionary'");
    goto LABEL_52;
  }
  MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(0, 0, theDict);
  uint64_t v25 = *(void *)(a2 + 16);
  if (v25)
  {
    id v26 = (uint64_t *)(a2 + 24);
    do
    {
      if ((*(unsigned char *)(v25 + 17) & 0x20) != 0)
      {
        CFDictionaryRemoveValue(MutableCopy, *(const void **)v25);
        CFArrayRef Value = CFDictionaryGetValue(v23, *(const void **)v25);
        if (Value)
        {
          uint64_t v28 = Value;
          CFMutableArrayRef Mutable = *a7;
          if (!*a7)
          {
            CFMutableArrayRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            *a7 = Mutable;
          }
          CFDictionaryAddValue(Mutable, *(const void **)v25, v28);
        }
      }
      uint64_t v30 = *v26++;
      uint64_t v25 = v30;
    }
    while (v30);
  }
  CFRelease(v23);
  if (MutableCopy)
  {
    if (a6 == 4)
    {
      SecAccessControlSetConstraints();
LABEL_39:
      if (!SecAccessControlGetConstraint()) {
        SecAccessControlAddConstraintForOperation();
      }
      goto LABEL_41;
    }
    id v33 = CFDictionaryGetValue(MutableCopy, @"acl");
    if (v33)
    {
      CFTypeID v34 = CFGetTypeID(v33);
      if (v34 == CFDictionaryGetTypeID())
      {
        SecAccessControlSetConstraints();
        if (a6 > 5) {
          goto LABEL_41;
        }
        goto LABEL_39;
      }
    }
    sub_100012A40(-26275, a10, @"kc_attribs_key_encrypted_data_from_blob: acl missing");
LABEL_52:
    uint64_t v31 = 0;
LABEL_25:
    if (v41) {
      sub_100019344(&v41);
    }
    if (v16) {
      goto LABEL_28;
    }
    goto LABEL_29;
  }
LABEL_41:
  if (a9) {
    *a9 = CFRetain(v17);
  }
  if (!v35)
  {
    uint64_t v31 = 1;
    goto LABEL_25;
  }
  *id v35 = v41;
  uint64_t v41 = 0;
  uint64_t v31 = 1;
  if (v16) {
LABEL_28:
  }
    CFRelease(v16);
LABEL_29:
  if (theData) {
    CFRelease(theData);
  }
  if (v17) {
    CFRelease(v17);
  }
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  return v31;
}

CFTypeRef sub_100124D90(CFDataRef data, CFErrorRef *error)
{
  CFPropertyListRef v3 = CFPropertyListCreateWithData(0, data, 1uLL, 0, error);

  return sub_100125460(v3, (__CFString **)error);
}

CFTypeRef sub_100124DDC(const __CFData *a1, CFTypeRef *a2)
{
  CFTypeRef cf = 0;
  BytePtr = CFDataGetBytePtr(a1);
  CFIndex Length = CFDataGetLength(a1);
  uint64_t v6 = (uint64_t)&BytePtr[Length];
  uint64_t v7 = sub_10000F124(0, (int)&cf, a2, (uint64_t)BytePtr, (uint64_t)&BytePtr[Length]);
  if (a2 && !v7)
  {
    CFErrorDomain Domain = CFErrorGetDomain((CFErrorRef)*a2);
    if (!Domain || !CFEqual(Domain, @"com.apple.security.cfder.error") || CFErrorGetCode((CFErrorRef)*a2) != -1) {
      goto LABEL_13;
    }
    CFTypeRef v11 = *a2;
    if (*a2)
    {
      *a2 = 0;
      CFRelease(v11);
    }
    uint64_t v7 = sub_100124EF8((uint64_t)&cf, a2, (uint64_t)BytePtr, v6, v10);
  }
  if (v7)
  {
    if (v7 != v6)
    {
      sub_1000297A0(-26275, kCFErrorDomainOSStatus, 0, a2, v8, @"trailing garbage at end of decrypted item");
      CFTypeRef v12 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        CFRelease(v12);
      }
    }
  }
LABEL_13:
  CFTypeRef v13 = cf;

  return sub_100125460(v13, (__CFString **)a2);
}

void sub_100124EF0(uint64_t a1, const void *a2, const void *a3)
{
}

uint64_t sub_100124EF8(uint64_t a1, CFTypeRef *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5 = a3;
  if (a3)
  {
    if (ccder_decode_tag()) {
      sub_1000297A0(-2, @"com.apple.security.cfder.error", 0, a2, v7, @"Unsupported DER Type");
    }
    else {
      sub_1000297A0(-1, @"com.apple.security.cfder.error", 0, a2, v7, @"Unknown data encoding");
    }
    return 0;
  }
  else
  {
    sub_1000297A0(-1, @"com.apple.security.cfder.error", 0, a2, a5, @"Null DER");
  }
  return v5;
}

CFTypeRef sub_100125460(CFTypeRef cf, __CFString **a2)
{
  CFTypeRef v2 = cf;
  if (cf)
  {
    CFTypeID v4 = CFGetTypeID(cf);
    if (v4 != CFDictionaryGetTypeID())
    {
      CFTypeID v5 = CFGetTypeID(v2);
      CFStringRef v6 = CFCopyTypeIDDescription(v5);
      sub_100012A40(-26275, a2, @"plist is a %@, expecting a dictionary", v6);
      if (v6) {
        CFRelease(v6);
      }
      CFRelease(v2);
      return 0;
    }
  }
  return v2;
}

uint64_t sub_1001254F4(CFDateRef *a1, CFErrorRef *a2, uint64_t a3)
{
  CFErrorDomain Domain = CFErrorGetDomain(*a2);
  if (!Domain || !CFEqual(Domain, @"com.apple.security.cfder.error") || CFErrorGetCode(*a2) != -1) {
    return 0;
  }
  CFAbsoluteTime at = 0.0;
  uint64_t v8 = CFCalendarCreateWithIdentifier(0, kCFGregorianCalendar);
  CFTimeZoneRef v9 = CFTimeZoneCreateWithTimeIntervalFromGMT(0, 0.0);
  CFCalendarSetTimeZone(v8, v9);
  CFCalendarComposeAbsoluteTime(v8, &at, "yMd", 2001, 3, 24);
  if (v9) {
    CFRelease(v9);
  }
  if (v8) {
    CFRelease(v8);
  }
  CFDateRef v10 = CFDateCreate(0, at);
  *a1 = v10;
  if (!v10) {
    return 0;
  }
  CFErrorRef v11 = *a2;
  if (*a2)
  {
    *a2 = 0;
    CFRelease(v11);
  }
  return a3;
}

const void *sub_100125608(void **a1, __CFString **a2)
{
  uint64_t v4 = sub_100118974(a1[2], 15, a2);
  CFTypeID v5 = sub_100118CF8(a1, v4, a2);
  uint64_t v6 = sub_100118974(a1[2], 14, a2);
  uint64_t v7 = sub_100118CF8(a1, v6, a2);
  if (v5) {
    BOOL v8 = v7 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8) {
    return 0;
  }
  CFDateRef v10 = v7;
  if (!CFEqual(v5, kCFNull))
  {
    CFGetAllocator(a1);
    uint64_t v13 = SecAccessControlCreateFromData();
    if (v13)
    {
      CFTypeRef v12 = (const void *)v13;
      if (CFEqual(v10, kCFNull))
      {
        id v14 = 0;
        goto LABEL_22;
      }
LABEL_13:
      CFGetAllocator(a1);
      id v14 = (const void *)SecAccessControlCreate();
      if (!v14 || !SecAccessControlSetProtection())
      {
        CFIndex v20 = 0;
        CFTimeZoneRef v9 = 0;
        if (!v12)
        {
LABEL_24:
          if (!v14) {
            return v9;
          }
          goto LABEL_27;
        }
LABEL_23:
        CFRelease(v12);
        CFTimeZoneRef v9 = v20;
        goto LABEL_24;
      }
      if (!v12)
      {
        CFRetain(v14);
        CFTimeZoneRef v9 = v14;
LABEL_27:
        CFRelease(v14);
        return v9;
      }
      CFDataRef Protection = (const __CFData *)SecAccessControlGetProtection();
      CFDictionaryRef v16 = (const void *)SecAccessControlGetProtection();
      CFDataRef v17 = v16;
      if (!Protection || !v16 || !CFEqual(Protection, v16))
      {
        CFDataRef v18 = sub_10000B070("SecError");
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
        {
          int v22 = 138412546;
          CFDataRef v23 = Protection;
          __int16 v24 = 2112;
          uint64_t v25 = v17;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "SecDbItemCopyAccessControl accc %@ != pdmn %@, setting pdmn to accc value", (uint8_t *)&v22, 0x16u);
        }

        sub_10002BBA0(@"Corrupted item on decrypt accc != pdmn", 0x53C00002u);
        uint64_t v19 = (void *)sub_100118974(a1[2], 14, a2);
        if (!sub_1001196B4((uint64_t)a1, v19, Protection, a2))
        {
          CFIndex v20 = 0;
          goto LABEL_23;
        }
      }
LABEL_22:
      CFRetain(v12);
      CFIndex v20 = v12;
      goto LABEL_23;
    }
    return 0;
  }
  CFTypeRef v12 = 0;
  CFTimeZoneRef v9 = 0;
  if (!CFEqual(v10, kCFNull)) {
    goto LABEL_13;
  }
  return v9;
}

void sub_100125890(uint64_t a1, CFDictionaryRef theDict, __CFString **a3)
{
  CFArrayRef Value = CFDictionaryGetValue(theDict, kSecValuePersistentRef);
  if (Value)
  {
    uint64_t v7 = Value;
    if (_SecItemParsePersistentRef())
    {
      if (!CFEqual(**(CFTypeRef **)(a1 + 16), 0)) {
        sub_100012A40(-26275, a3, @"v_PersistentRef has unexpected class %@", 0, 0xAAAAAAAAAAAAAAAALL, 0);
      }
    }
    else
    {
      sub_100012A40(-26275, a3, @"v_PersistentRef %@ failed to decode", v7, 0xAAAAAAAAAAAAAAAALL, 0);
    }
  }
  else
  {
    sub_100012A40(-26275, a3, @"No v_PersistentRef in backup dictionary %@", theDict);
  }
}

__CFDictionary *sub_1001259B0(void *a1, uint64_t a2, __CFString **a3)
{
  return sub_1001259B8(a1, 1, a3);
}

__CFDictionary *sub_1001259B8(void *a1, uint64_t a2, __CFString **a3)
{
  CFStringRef result = sub_1001259F4(a1, a2, a3);
  if (result)
  {
    uint64_t v4 = result;
    CFTypeID v5 = sub_100029C50(result);
    CFRelease(v4);
    return v5;
  }
  return result;
}

__CFDictionary *sub_1001259F4(void *a1, uint64_t a2, __CFString **a3)
{
  CFStringRef result = sub_100118B3C(a1, a2, 0, a3);
  if (result)
  {
    BOOL v8 = result;
    CFTimeZoneRef v9 = sub_1000298CC((const __CFString *)result, (CFTypeRef *)a3, v5, v6, v7);
    CFRelease(v8);
    return v9;
  }
  return result;
}

__CFDictionary *sub_100125A40(void *a1, uint64_t a2, __CFString **a3)
{
  return sub_1001259B8(a1, 256, a3);
}

__CFData *sub_100125A48(uint64_t a1, uint64_t a2, __CFString **a3)
{
  int v22 = 0;
  uint64_t v5 = sub_100118B3C((void *)a1, 32, 0, a3);
  uint64_t v6 = sub_100118B3C((void *)a1, 128, 0, a3);
  uint64_t v7 = sub_100118B3C((void *)a1, 0x2000, 0, a3);
  BOOL v8 = v7;
  if (v5 && v6 && v7)
  {
    CFTimeZoneRef v9 = sub_100125608((void **)a1, a3);
    CFDateRef v10 = sub_1001259B8((void *)a1, 256, a3);
    CFErrorRef v11 = v10;
    if (v9 && v10)
    {
      CFDictionarySetValue(v8, kSecAttrSHA1, v10);
      context[0] = _NSConcreteStackBlock;
      context[1] = 3221225472;
      context[2] = sub_100125DC0;
      context[3] = &unk_1002FADD8;
      void context[4] = v6;
      void context[5] = v8;
      CFDictionaryApplyFunction(v5, (CFDictionaryApplierFunction)sub_100124518, context);
      if (sub_100124534((const __CFData *)*(unsigned int *)(a1 + 28), (uint64_t)v9, *(const __CFData **)(a1 + 56), v5, v6, v8, &v22, 1, 0, a3))
      {
        *(_DWORD *)(a1 + 40) = 4;
LABEL_36:
        CFRelease(v9);
        goto LABEL_37;
      }
      if (a3 && *a3 && CFErrorGetCode((CFErrorRef)*a3) == -25330)
      {
        CFErrorDomain Domain = CFErrorGetDomain((CFErrorRef)*a3);
        if (Domain && kCFErrorDomainOSStatus)
        {
          if (CFEqual(Domain, kCFErrorDomainOSStatus)) {
            goto LABEL_36;
          }
        }
        else if (Domain == kCFErrorDomainOSStatus)
        {
          goto LABEL_36;
        }
      }
      id v15 = sub_10000B070("SecCritical");
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        if (a3) {
          CFStringRef v16 = *a3;
        }
        else {
          CFStringRef v16 = &stru_10030AA90;
        }
        *(_DWORD *)long long buf = 138412290;
        CFStringRef v24 = v16;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "ks_encrypt_data (db): failed: %@", buf, 0xCu);
      }

      goto LABEL_36;
    }
    if (v10) {
LABEL_37:
    }
      CFRelease(v11);
  }
  else
  {
    if (!v5 && !v6 && !v7) {
      return v22;
    }
    if (dword_10035AEC8 == -1)
    {
      CFTypeRef v12 = sub_10000B070("SecEmergency");
      if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      {
        CFStringRef v17 = @"missing";
        if (v5) {
          CFStringRef v18 = @"present";
        }
        else {
          CFStringRef v18 = @"missing";
        }
        if (v6) {
          CFStringRef v19 = @"present";
        }
        else {
          CFStringRef v19 = @"missing";
        }
        if (v8) {
          CFStringRef v17 = @"present";
        }
        if (a3) {
          CFStringRef v20 = *a3;
        }
        else {
          CFStringRef v20 = @"no error pointer";
        }
        *(_DWORD *)long long buf = 138413058;
        CFStringRef v24 = v18;
        __int16 v25 = 2112;
        CFStringRef v26 = v19;
        __int16 v27 = 2112;
        CFStringRef v28 = v17;
        __int16 v29 = 2112;
        CFStringRef v30 = v20;
        _os_log_fault_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_FAULT, "SecDbKeychainItemCopyEncryptedData: not all plists are present: secretStuff: %@, attributes: %@, auth_attributes: %@ : %@", buf, 0x2Au);
      }
    }
    if (!v5)
    {
      if (!v6) {
        goto LABEL_17;
      }
      goto LABEL_16;
    }
  }
  CFRelease(v5);
  if (v6) {
LABEL_16:
  }
    CFRelease(v6);
LABEL_17:
  if (v8) {
    CFRelease(v8);
  }
  return v22;
}

void sub_100125DC0(uint64_t a1, const void *a2)
{
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a1 + 32), a2);
  uint64_t v4 = *(__CFDictionary **)(a1 + 40);

  CFDictionaryRemoveValue(v4, a2);
}

CFDateRef sub_100125E04(int a1, uint64_t a2, __CFString **a3)
{
  int v3 = *(_DWORD *)(a2 + 8);
  if ((v3 - 5) >= 2)
  {
    if (v3 != 4)
    {
      sub_100012A40(-26276, a3, @"attr %@ has no default value", *(void *)a2);
      return 0;
    }
    CFAllocatorRef v5 = kCFAllocatorDefault;
    double Current = 0.0;
  }
  else
  {
    double Current = CFAbsoluteTimeGetCurrent();
    CFAllocatorRef v5 = kCFAllocatorDefault;
  }

  return CFDateCreate(v5, Current);
}

void sub_1001260A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id obj)
{
}

void sub_1001260BC(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_10012629C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100126390(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100126830(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100126860(uint64_t a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v14 = +[CKKSAnalytics logger];
  [v14 logResultForEvent:@"OctagonEventUpgradePreapprovedJoin" hardFailure:1 result:v12];

  if (v12)
  {
    id v15 = sub_10000B070("SecError");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v38 = v12;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "octagon-sos: attemptPreapprovedJoin failed: %@", buf, 0xCu);
    }

    if ([v12 isCuttlefishError:1033])
    {
      CFStringRef v16 = sub_10000B070("octagon-ckks");
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "A CKKS key hierarchy is out of date; requesting reset",
          buf,
          2u);
      }

      CFStringRef v17 = [WeakRetained ckksConflictState];
      [WeakRetained setNextState:v17];
    }
    else
    {
      [WeakRetained setError:v12];
      [WeakRetained setNextState:@"BecomeUntrusted"];
    }
    id v24 = [WeakRetained finishedOp];
    [WeakRetained runBeforeGroupFinished:v24];
  }
  else
  {
    [WeakRetained requestSilentEscrowUpdate];
    CFStringRef v18 = sub_10000B070("SecError");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "octagon-sos: attemptPreapprovedJoin succeded", buf, 2u);
    }

    CFStringRef v19 = [WeakRetained deps];
    CFStringRef v20 = [v19 ckks];
    [v20 setCurrentSyncingPolicy:v11];

    uint64_t v21 = [WeakRetained deps];
    int v22 = [v21 stateHolder];
    v34[0] = _NSConcreteStackBlock;
    v34[1] = 3221225472;
    void v34[2] = sub_100126CFC;
    v34[3] = &unk_1002FAEE8;
    id v35 = v9;
    id v36 = v11;
    id v33 = 0;
    unsigned int v23 = [v22 persistAccountChanges:v34 error:&v33];
    id v24 = v33;

    if (!v23 || v24)
    {
      uint64_t v31 = sub_10000B070("octagon-sos");
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v38 = v24;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "Couldn't persist results: %@", buf, 0xCu);
      }

      [WeakRetained setError:v24];
      [WeakRetained setNextState:@"Error"];
    }
    else
    {
      __int16 v25 = [WeakRetained intendedState];
      [WeakRetained setNextState:v25];

      CFStringRef v26 = sub_10000B070("octagon-ckks");
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v27 = [WeakRetained deps];
        CFStringRef v28 = [v27 ckks];
        *(_DWORD *)long long buf = 138412290;
        id v38 = v28;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "Providing ck records (from sos upgrade) to %@", buf, 0xCu);
      }
      __int16 v29 = [WeakRetained deps];
      CFStringRef v30 = [v29 ckks];
      [v30 receiveTLKUploadRecords:v10];
    }
    long long v32 = [WeakRetained finishedOp];
    [WeakRetained runBeforeGroupFinished:v32];
  }
}

id sub_100126CFC(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 setTrustState:2];
  [v3 setPeerID:*(void *)(a1 + 32)];
  [v3 setTPSyncingPolicy:*(void *)(a1 + 40)];

  return v3;
}

void sub_100126EE4(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_100126F0C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v2 = [*(id *)(a1 + 32) viewKeySets];
  id v3 = [*(id *)(a1 + 32) pendingTLKShares];
  [WeakRetained proceedWithKeys:v2 pendingTLKShares:v3];
}

void sub_100127540(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100127568(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained afterUpdate];
}

void sub_1001276C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1001276EC(uint64_t a1, char a2, void *a3)
{
  id v5 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v7 = +[CKKSAnalytics logger];
  [v7 logResultForEvent:@"OctagonEventUpgradePreflightPreapprovedJoin" hardFailure:1 result:v5];

  if (v5)
  {
    BOOL v8 = sub_10000B070("SecError");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = 138412290;
      id v13 = v5;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "octagon-sos: preflightPreapprovedJoin failed: %@", (uint8_t *)&v12, 0xCu);
    }

    [WeakRetained setError:v5];
LABEL_12:
    [WeakRetained setNextState:@"BecomeUntrusted"];
    id v11 = [WeakRetained finishedOp];
    [WeakRetained runBeforeGroupFinished:v11];

    goto LABEL_13;
  }
  id v9 = sub_10000B070("octagon-sos");
  BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if ((a2 & 1) == 0)
  {
    if (v10)
    {
      LOWORD(v12) = 0;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "TPH believes a preapprovedJoin will fail; aborting.",
        (uint8_t *)&v12,
        2u);
    }

    goto LABEL_12;
  }
  if (v10)
  {
    LOWORD(v12) = 0;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "TPH believes a preapprovedJoin might succeed; continuing.",
      (uint8_t *)&v12,
      2u);
  }

  [WeakRetained afterPreflight];
LABEL_13:
}

void sub_1001288F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,id *location)
{
  objc_destroyWeak(location);
  objc_destroyWeak((id *)(v42 - 152));
  _Unwind_Resume(a1);
}

void sub_10012896C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = [WeakRetained error];

  if (v2)
  {
    id v3 = [WeakRetained error];
    unsigned int v4 = [v3 isRetryable];

    if (v4)
    {
      id v5 = [WeakRetained error];
      [v5 retryInterval];
      double v7 = v6;

      BOOL v8 = sub_10000B070("octagon-sos");
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        id v9 = [WeakRetained error];
        int v15 = 134218242;
        double v16 = v7;
        __int16 v17 = 2112;
        CFStringRef v18 = v9;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "SOS upgrade error is not fatal: requesting retry in %0.2fs: %@", (uint8_t *)&v15, 0x16u);
      }
      BOOL v10 = [WeakRetained deps];
      id v11 = [v10 flagHandler];
      int v12 = [[OctagonPendingFlag alloc] initWithFlag:@"attempt_sos_upgrade" delayInSeconds:v7];
      [v11 handlePendingFlag:v12];
    }
    else
    {
      BOOL v10 = sub_10000B070("octagon-sos");
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
LABEL_10:

        id v13 = [WeakRetained eventS];
        id v14 = [WeakRetained error];
        +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v13 success:0 error:v14];

        goto LABEL_11;
      }
      id v11 = [WeakRetained error];
      int v15 = 138412290;
      double v16 = *(double *)&v11;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "SOS upgrade error is: %@; not retrying",
        (uint8_t *)&v15,
        0xCu);
    }

    goto LABEL_10;
  }
  id v13 = [WeakRetained eventS];
  +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v13 success:1 error:0];
LABEL_11:
}

void sub_100128BD4(uint64_t a1, void *a2, void *a3, void *a4, uint64_t a5, uint64_t a6, void *a7, void *a8)
{
  id v13 = a2;
  id v14 = a3;
  id v15 = a4;
  id v16 = a7;
  id v17 = a8;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  CFStringRef v19 = +[CKKSAnalytics logger];
  [v19 logResultForEvent:@"OctagonEventUpgradePrepare" hardFailure:1 result:v17];

  if (v17)
  {
    CFStringRef v20 = sub_10000B070("SecError");
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v36 = v17;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "octagon-sos: Error preparing identity: %@", buf, 0xCu);
    }

    [WeakRetained setError:v17];
    [WeakRetained handlePrepareErrors:v17 nextExpectedState:@"BecomeUntrusted"];
    id v21 = [WeakRetained finishedOp];
    [WeakRetained runBeforeGroupFinished:v21];
  }
  else
  {
    int v22 = sub_10000B070("octagon-sos");
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412802;
      id v36 = v13;
      __int16 v37 = 2112;
      id v38 = v14;
      __int16 v39 = 2112;
      id v40 = v15;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "Prepared: %@ %@ %@", buf, 0x20u);
    }
    id v31 = v13;

    unsigned int v23 = [WeakRetained deps];
    id v24 = [v23 stateHolder];
    v33[0] = _NSConcreteStackBlock;
    v33[1] = 3221225472;
    void v33[2] = sub_100128F5C;
    v33[3] = &unk_100307118;
    id v25 = v16;
    id v34 = v25;
    id v32 = 0;
    unsigned int v26 = [v24 persistAccountChanges:v33 error:&v32];
    id v21 = v32;

    if (!v26 || v21)
    {
      __int16 v29 = sub_10000B070("SecError");
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        id v36 = v21;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "octagon-ckks: Error persisting new views and policy: %@", buf, 0xCu);
      }

      [WeakRetained setError:v21];
      [WeakRetained handlePrepareErrors:v21 nextExpectedState:@"BecomeUntrusted"];
      CFStringRef v30 = [WeakRetained finishedOp];
      [WeakRetained runBeforeGroupFinished:v30];
    }
    else
    {
      __int16 v27 = [WeakRetained deps];
      CFStringRef v28 = [v27 ckks];
      [v28 setCurrentSyncingPolicy:v25];

      [WeakRetained afterPrepare];
    }
    id v13 = v31;
  }
}

id sub_100128F5C(uint64_t a1, void *a2)
{
  id v3 = a2;
  [v3 setTPSyncingPolicy:*(void *)(a1 + 32)];

  return v3;
}

OTAccountMetadataClassC *__cdecl sub_100128FA0(id a1, OTAccountMetadataClassC *a2)
{
  uint64_t v2 = a2;
  [(OTAccountMetadataClassC *)v2 setAttemptedJoin:2];
  [(OTAccountMetadataClassC *)v2 setCdpState:2];

  return v2;
}

void sub_1001291EC(id a1)
{
  qword_10035CF50 = (uint64_t)CFDataCreateWithBytesNoCopy(0, byte_10026568C, 16, kCFAllocatorNull);
}

void sub_100129228(id a1)
{
  qword_10035CF60 = (uint64_t)CFDataCreateWithBytesNoCopy(0, 0, 0, kCFAllocatorNull);
}

BOOL sub_100129260(CFTypeRef cf1)
{
  if (qword_10035CF58 != -1) {
    dispatch_once(&qword_10035CF58, &stru_1002FAF90);
  }
  return CFEqual(cf1, (CFTypeRef)qword_10035CF60) != 0;
}

void sub_1001292C0(id a1)
{
  qword_10035CF70 = (uint64_t)CFDataCreateWithBytesNoCopy(0, byte_10026569D, 16, kCFAllocatorNull);
}

void sub_100129340(const void *a1, const __CFData *a2, uint64_t a3)
{
  id v5 = sub_10000FD40(*(__CFString ***)a3, a1, (__CFString **)(a3 + 40));
  if (!v5) {
    return;
  }
  double v6 = v5;
  CFArrayRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 8), *v5);
  if (!Value)
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (!Mutable) {
      return;
    }
    goto LABEL_9;
  }
  BOOL v8 = Value;
  CFTypeID v9 = CFGetTypeID(Value);
  if (v9 == CFArrayGetTypeID())
  {
    CFMutableArrayRef Mutable = (__CFArray *)CFRetain(v8);
  }
  else
  {
    CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    CFArrayAppendValue(Mutable, v8);
  }
  CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a3 + 8), *v6);
  if (Mutable)
  {
LABEL_9:
    sub_10000E0A8(v6, a2, a3);
    id v11 = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 8), *v6);
    CFArrayAppendValue(Mutable, v11);
    CFDictionarySetValue(*(CFMutableDictionaryRef *)(a3 + 8), *v6, Mutable);
    CFRelease(Mutable);
  }
}

void sub_10012947C(const void *a1, const __CFData *a2, uint64_t a3)
{
  id v5 = sub_10000FD40(*(__CFString ***)a3, a1, (__CFString **)(a3 + 40));
  if (v5)
  {
    double v6 = v5;
    CFArrayRef Value = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 8), *v5);
    if (Value)
    {
      BOOL v8 = Value;
      CFTypeID v9 = CFGetTypeID(Value);
      if (v9 == CFArrayGetTypeID())
      {
        CFMutableArrayRef Mutable = (__CFArray *)CFRetain(v8);
      }
      else
      {
        id v11 = sub_10000B070("SecError");
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          int v12 = *v6;
          int v14 = 138412546;
          id v15 = v12;
          __int16 v16 = 2112;
          id v17 = v8;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "negating %@ = %@ in query", (uint8_t *)&v14, 0x16u);
        }
        CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
        CFArrayAppendValue(Mutable, kCFNull);
        CFArrayAppendValue(Mutable, v8);
      }
      CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a3 + 8), *v6);
      if (Mutable) {
        goto LABEL_11;
      }
    }
    else
    {
      CFMutableArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      CFArrayAppendValue(Mutable, kCFNull);
      if (Mutable)
      {
LABEL_11:
        sub_10000E0A8(v6, a2, a3);
        id v13 = CFDictionaryGetValue(*(CFDictionaryRef *)(a3 + 8), *v6);
        CFArrayAppendValue(Mutable, v13);
        CFDictionarySetValue(*(CFMutableDictionaryRef *)(a3 + 8), *v6, Mutable);
        CFRelease(Mutable);
      }
    }
  }
}

void sub_100129654(uint64_t *a1, CFTypeRef cf1)
{
  if (!a1[17])
  {
    if (CFEqual(cf1, @"com.apple.apsd"))
    {
      id v3 = (const CFStringRef *)&kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate;
    }
    else
    {
      uint64_t v4 = *a1;
      uint64_t v5 = sub_10000C75C(@"cert", &qword_10035D030, (uint64_t)&unk_10035D028);
      id v3 = &kSecAttrAccessibleWhenUnlocked;
      if (v4 == v5) {
        id v3 = (const CFStringRef *)&kSecAttrAccessibleAlwaysPrivate;
      }
    }
    CFBooleanRef v6 = (const __CFBoolean *)*v3;
    sub_10000DF34(kSecAttrAccessible, v6, (uint64_t)a1);
  }
}

uint64_t sub_100129708(uint64_t a1, int a2, CFErrorRef *a3)
{
  if (a2 && !*(void *)(a1 + 40))
  {
    if (*(unsigned char *)(a1 + 114) || *(unsigned char *)(a1 + 113) && !sub_100129260(*(CFTypeRef *)(a1 + 128))) {
      sub_10013F0C8();
    }
    if (*(unsigned char *)(a1 + 115)) {
      sub_10013F064();
    }
  }
  return sub_10000C2C4((const void **)a1, a3) & a2;
}

void sub_100129784(CFTypeRef cf, const void *a2, uint64_t a3)
{
  id v3 = (__CFString **)(a3 + 40);
  if (*(void *)(a3 + 40)) {
    return;
  }
  if (!cf)
  {
    CFTypeRef v9 = 0;
LABEL_10:
    sub_100012A40(-50, v3, @"update_applier: unknown key type %@", v9);
    return;
  }
  CFTypeID v7 = CFGetTypeID(cf);
  if (v7 != CFStringGetTypeID())
  {
    CFTypeRef v9 = cf;
    goto LABEL_10;
  }
  if (a2)
  {
    if (CFEqual(cf, @"musr"))
    {
      BOOL v8 = sub_10000B070("item");
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "update_applier: refusing to update musr", buf, 2u);
      }
    }
    else if (CFEqual(cf, kSecValueData))
    {
      sub_1001298F8(a2, a3);
    }
    else
    {
      sub_10000DF34(cf, (const __CFBoolean *)a2, a3);
    }
  }
  else
  {
    sub_100012A40(-50, v3, @"update_applier: key %@ has NULL value", cf);
  }
}

void sub_1001298F8(const void *a1, uint64_t a2)
{
  CFTypeID v4 = CFGetTypeID(a1);
  if (v4 == CFDataGetTypeID())
  {
    *(void *)(a2 + 56) = a1;
    uint64_t v5 = *(__CFDictionary **)(a2 + 8);
    if (v5)
    {
      CFDictionarySetValue(v5, kSecValueData, a1);
    }
  }
  else
  {
    sub_100012A40(-50, (__CFString **)(a2 + 40), @"set_data: value %@ is not type data", a1);
  }
}

void sub_1001299C0(const void *a1, const __CFString *a2, uint64_t a3)
{
  if (CFEqual(a1, @"u_ItemList"))
  {
    *(void *)(a3 + 8_Block_object_dispose(&STACK[0x3F0], 8) = a2;
    return;
  }
  if (!CFEqual(a1, kSecUseTombstones))
  {
    if (CFEqual(a1, kSecUseCredentialReference))
    {
      CFTypeID v7 = CFGetTypeID(a2);
      if (v7 == CFDataGetTypeID())
      {
        if (*(const __CFString **)(a3 + 144) != a2)
        {
          CFRetain(a2);
          BOOL v8 = *(const void **)(a3 + 144);
          if (v8) {
            CFRelease(v8);
          }
          *(void *)(a3 + 144) = a2;
        }
      }
      else
      {
        sub_100012A40(-50, (__CFString **)(a3 + 40), @"add_use: value %@ for key %@ is not CFData", a2, a1);
      }
      return;
    }
    if (CFEqual(a1, kSecUseAuthenticationUI))
    {
      CFTypeID v13 = CFGetTypeID(a2);
      if (v13 == CFStringGetTypeID())
      {
        if (kSecUseAuthenticationUISkip) {
          BOOL v14 = CFEqual(kSecUseAuthenticationUISkip, a2) != 0;
        }
        else {
          BOOL v14 = 0;
        }
        *(unsigned char *)(a3 + 152) = v14;
      }
      else
      {
        sub_100012A40(-50, (__CFString **)(a3 + 40), @"add_use: value %@ for key %@ is not CFString", a2, a1);
      }
      return;
    }
    uint64_t v15 = kSecUseSystemKeychain;
    if (CFEqual(a1, kSecUseSystemKeychain))
    {
      *(_DWORD *)(a3 + 120) = dword_10035D2B0;
      if (*(_DWORD *)(a3 + 192) == 2)
      {
        __int16 v16 = (__CFString **)(a3 + 40);
        uint64_t v20 = kSecUseSystemKeychainAlways;
        uint64_t v21 = v15;
LABEL_29:
        sub_100012A40(-50, v16, @"add_use: can't specify both %@ and %@", v20, v21);
        return;
      }
      int v18 = 1;
    }
    else
    {
      if (qword_10035D0B8 != -1) {
        dispatch_once(&qword_10035D0B8, &stru_100303B18);
      }
      if (!byte_10035D0B0 || (uint64_t v17 = kSecUseSystemKeychainAlways, !CFEqual(a1, kSecUseSystemKeychainAlways)))
      {
        if (CFEqual(a1, kSecUseSyncBubbleKeychain))
        {
          CFTypeID v19 = CFGetTypeID(a2);
          if (v19 == CFNumberGetTypeID()
            && CFNumberGetValue((CFNumberRef)a2, kCFNumberSInt32Type, (void *)(a3 + 196))
            && *(int *)(a3 + 196) >= 1)
          {
            *(_DWORD *)(a3 + 120) = dword_10035D2B0;
          }
          else
          {
            sub_100012A40(-50, (__CFString **)(a3 + 40), @"add_use: value %@ for key %@ is not valid uid", a2, a1);
          }
        }
        else
        {
          sub_100012A40(-50, (__CFString **)(a3 + 40), @"add_use: unknown key %@", a1);
        }
        return;
      }
      if (*(_DWORD *)(a3 + 192) == 1)
      {
        __int16 v16 = (__CFString **)(a3 + 40);
        uint64_t v20 = v15;
        uint64_t v21 = v17;
        goto LABEL_29;
      }
      *(_DWORD *)(a3 + 120) = dword_10035D2B0;
      int v18 = 2;
    }
    *(_DWORD *)(a3 + 192) = v18;
    return;
  }
  CFTypeID v6 = CFGetTypeID(a2);
  if (v6 == CFBooleanGetTypeID())
  {
    *(void *)(a3 + 96) = a2;
    return;
  }
  CFTypeID v9 = CFGetTypeID(a2);
  if (v9 == CFNumberGetTypeID())
  {
    SInt32 Value = CFBooleanGetValue((CFBooleanRef)a2);
  }
  else
  {
    CFTypeID v11 = CFGetTypeID(a2);
    if (v11 != CFStringGetTypeID())
    {
      sub_100012A40(-50, (__CFString **)(a3 + 40), @"add_use: value %@ for key %@ is neither CFBoolean nor CFNumber", a2, a1);
      return;
    }
    SInt32 Value = CFStringGetIntValue(a2);
  }
  int v12 = &kCFBooleanTrue;
  if (!Value) {
    int v12 = &kCFBooleanFalse;
  }
  *(CFBooleanRef *)(a3 + 96) = *v12;
}

void sub_100129D18(const void *a1, const void *a2, uint64_t a3)
{
  if (CFEqual(a1, kSecValueData))
  {
    sub_1001298F8(a2, a3);
  }
  else if (CFEqual(a1, kSecValuePersistentRef))
  {
    if (_SecItemParsePersistentRef()) {
      sub_10000B978((void *)a3, 0, (__CFString **)(a3 + 40));
    }
    else {
      sub_100012A40(-50, (__CFString **)(a3 + 40), @"add_value: value %@ is not a valid persitent ref", a2);
    }
  }
  else
  {
    sub_100012A40(-50, (__CFString **)(a3 + 40), @"add_value: unknown key %@", a1);
  }
}

void sub_100129F50(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 208);
  if (v3 != cf)
  {
    if (!cf || (CFRetain(cf), (CFTypeRef v3 = *(CFTypeRef *)(a1 + 208)) != 0)) {
      CFRelease(v3);
    }
    *(void *)(a1 + 20_Block_object_dispose(&STACK[0x3F0], 8) = cf;
  }
}

void sub_100129F9C(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3 = *(CFTypeRef *)(a1 + 216);
  if (v3 != cf)
  {
    if (!cf || (CFRetain(cf), (CFTypeRef v3 = *(CFTypeRef *)(a1 + 216)) != 0)) {
      CFRelease(v3);
    }
    *(void *)(a1 + 216) = cf;
  }
}

void sub_100129FE8(uint64_t a1, CFTypeRef cf)
{
  if (*(CFTypeRef *)(a1 + 232) != cf)
  {
    CFRetain(cf);
    CFTypeID v4 = *(const void **)(a1 + 232);
    if (v4) {
      CFRelease(v4);
    }
    *(void *)(a1 + 232) = cf;
  }
}

void sub_10012A030(uint64_t a1, CFTypeRef cf)
{
  if (*(CFTypeRef *)(a1 + 248) != cf)
  {
    CFRetain(cf);
    CFTypeID v4 = *(const void **)(a1 + 248);
    if (v4) {
      CFRelease(v4);
    }
    *(void *)(a1 + 24_Block_object_dispose(&STACK[0x3F0], 8) = cf;
  }
}

void sub_10012A078(uint64_t a1, CFTypeRef cf)
{
  if (*(CFTypeRef *)(a1 + 224) != cf)
  {
    CFRetain(cf);
    CFTypeID v4 = *(const void **)(a1 + 224);
    if (v4) {
      CFRelease(v4);
    }
    *(void *)(a1 + 224) = cf;
  }
}

void sub_10012A60C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id obj)
{
}

void sub_10012A700(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10012A7FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
}

void sub_10012A810(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if ([WeakRetained timeoutCanOccur])
  {
    uint64_t v1 = [WeakRetained _onqueueTimeoutError];
    [WeakRetained setError:v1];

    [WeakRetained setTimeoutCanOccur:0];
    [WeakRetained cancel];
  }
}

BOOL sub_10012AC84(id a1, id a2, unint64_t a3, BOOL *a4)
{
  return [a2 isFinished:a3, a4] ^ 1;
}

id sub_10012AD2C(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) isCancelled];
  if ((result & 1) == 0)
  {
    CFTypeRef v3 = *(void **)(a1 + 32);
    return [v3 setTimeoutCanOccur:0];
  }
  return result;
}

void sub_10012AEC4(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_10012AEE0(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  CFTypeRef v3 = WeakRetained;
  if (WeakRetained)
  {
    CFTypeID v4 = [WeakRetained finishingBlock];
    v4[2]();

    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
    uint64_t v5 = [v3 completionHandlerDidRunCondition];
    [v5 fulfill];

    long long v14 = 0u;
    long long v15 = 0u;
    long long v12 = 0u;
    long long v13 = 0u;
    CFTypeID v6 = [v3 dependencies];
    id v7 = [v6 countByEnumeratingWithState:&v12 objects:v17 count:16];
    if (v7)
    {
      id v8 = v7;
      uint64_t v9 = *(void *)v13;
      do
      {
        for (uint64_t i = 0; i != v8; uint64_t i = (char *)i + 1)
        {
          if (*(void *)v13 != v9) {
            objc_enumerationMutation(v6);
          }
          [v3 removeDependency:*(void *)(*((void *)&v12 + 1) + 8 * i)];
        }
        id v8 = [v6 countByEnumeratingWithState:&v12 objects:v17 count:16];
      }
      while (v8);
    }
  }
  else
  {
    CFTypeID v11 = sub_1000CD884(@"resultoperation", 0);
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "completion handler called on deallocated operation instance", buf, 2u);
    }

    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

void sub_10012B468(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10012B48C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v1 = +[NSDate dateWithTimeIntervalSinceNow:0.0];
  [WeakRetained setFinishDate:v1];
}

void sub_10012B60C(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_10012B62C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_10012C73C(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v6 = 0;
  id v7 = &v6;
  uint64_t v8 = 0x2000000000;
  int v9 = -1;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  _DWORD v5[2] = sub_10012C80C;
  v5[3] = &unk_1002FB060;
  void v5[5] = a1;
  void v5[6] = a2;
  void v5[4] = &v6;
  unsigned __int8 v2 = sub_10012C888(a2, (uint64_t)v5);
  uint64_t v3 = *((unsigned int *)v7 + 6);
  if ((v2 & 1) == 0 && (v3 & 0x80000000) == 0)
  {
    close(*((_DWORD *)v7 + 6));
    uint64_t v3 = 0xFFFFFFFFLL;
    *((_DWORD *)v7 + 6) = -1;
  }
  _Block_object_dispose(&v6, 8);
  return v3;
}

BOOL sub_10012C80C(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = a1[5];
  uint64_t v5 = a1[6];
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_10012C944;
  v7[3] = &unk_1002FB038;
  void v7[4] = a1[4];
  void v7[5] = v5;
  return sub_100104E54(a3, v4, v5, v7);
}

void *sub_10012C888(CFTypeRef *a1, uint64_t a2)
{
  uint64_t v4 = sub_10000CF0C(0);
  uint64_t v5 = sub_100134054(v4);
  sub_1000297D0(v5 != 0, a1, @"No datasource");
  if (!v5) {
    return 0;
  }
  id result = (void *)(*(uint64_t (**)(uint64_t, const CFStringRef, CFTypeRef *))(v5 + 8))(v5, kSecAttrAccessibleWhenUnlocked, a1);
  if (result)
  {
    id v7 = result;
    uint64_t v8 = *result;
    if (*result) {
      (*(void (**)(uint64_t, void *, uint64_t))(a2 + 16))(a2, result, v8);
    }
    LODWORD(result) = ((uint64_t (*)(void *, CFTypeRef *))v7[9])(v7, a1);
    if (v8) {
      return (void *)result;
    }
    else {
      return 0;
    }
  }
  return result;
}

void sub_10012C944(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4 = *(CFTypeRef **)(a1 + 40);
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2020000000;
  int v10 = -1;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  _DWORD v6[2] = sub_100205C54;
  v6[3] = &unk_100308778;
  void v6[4] = &v7;
  void v6[5] = v4;
  sub_100204E84(a3, v4, v6);
  int v5 = *((_DWORD *)v8 + 6);
  _Block_object_dispose(&v7, 8);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v5;
}

void sub_10012CA04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10012CA1C(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  char v11 = 1;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_10012CADC;
  v7[3] = &unk_1002FB088;
  void v7[4] = &v8;
  void v7[5] = a1;
  void v7[6] = a2;
  void v7[7] = a3;
  v7[8] = a4;
  unsigned int v4 = sub_10012C888(a4, (uint64_t)v7);
  if (*((unsigned char *)v9 + 24)) {
    uint64_t v5 = v4;
  }
  else {
    uint64_t v5 = 0;
  }
  *((unsigned char *)v9 + 24) = v5;
  _Block_object_dispose(&v8, 8);
  return v5;
}

void sub_10012CADC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 40);
  long long v9 = *(_OWORD *)(a1 + 48);
  uint64_t v6 = *(void *)(a1 + 64);
  if (-[OTSOSActualAdapter sosEnabled]_0())
  {
    uint64_t v14 = 0;
    long long v15 = &v14;
    uint64_t v16 = 0x2020000000;
    char v17 = 1;
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    v10[2] = sub_100105000;
    void v10[3] = &unk_1002FA348;
    void v10[4] = &v14;
    long long v11 = v9;
    uint64_t v12 = v6;
    uint64_t v13 = a3;
    BOOL v7 = sub_100104E54(a3, v5, v6, v10);
    if (*((unsigned char *)v15 + 24)) {
      BOOL v8 = v7;
    }
    else {
      BOOL v8 = 0;
    }
    *((unsigned char *)v15 + 24) = v8;
    _Block_object_dispose(&v14, 8);
  }
  else
  {
    SOSCCSetSOSDisabledError();
    BOOL v8 = 0;
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v8;
}

void sub_10012CBE8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 64), 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10012CC00(CFTypeRef *a1)
{
  uint64_t v7 = 0;
  BOOL v8 = &v7;
  uint64_t v9 = 0x2000000000;
  uint64_t v10 = 0;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  _DWORD v6[2] = sub_10012CCBC;
  v6[3] = &unk_1002FB0B0;
  void v6[4] = &v7;
  void v6[5] = a1;
  unsigned __int8 v1 = sub_10012C888(a1, (uint64_t)v6);
  unsigned __int8 v2 = v8;
  if ((v1 & 1) == 0)
  {
    uint64_t v3 = (const void *)v8[3];
    if (v3)
    {
      v8[3] = 0;
      CFRelease(v3);
      unsigned __int8 v2 = v8;
    }
  }
  uint64_t v4 = v2[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

uint64_t sub_10012CCBC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result = sub_1001052A4(a3);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t sub_10012CCF4(uint64_t a1, CFTypeRef *a2)
{
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x2000000000;
  uint64_t v11 = 0;
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_10012CDBC;
  v7[3] = &unk_1002FB0D8;
  void v7[4] = &v8;
  void v7[5] = a1;
  void v7[6] = a2;
  unsigned __int8 v2 = sub_10012C888(a2, (uint64_t)v7);
  uint64_t v3 = v9;
  if ((v2 & 1) == 0)
  {
    uint64_t v4 = (const void *)v9[3];
    if (v4)
    {
      v9[3] = 0;
      CFRelease(v4);
      uint64_t v3 = v9;
    }
  }
  uint64_t v5 = v3[3];
  _Block_object_dispose(&v8, 8);
  return v5;
}

void sub_10012CDBC(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = *(void *)(a1 + 40);
  if (-[OTSOSActualAdapter sosEnabled]_0())
  {
    uint64_t v9 = 0;
    uint64_t v10 = &v9;
    uint64_t v11 = 0x2020000000;
    CFStringRef v12 = &stru_10030AA90;
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 3221225472;
    v8[2] = sub_100105514;
    v8[3] = &unk_1002FA370;
    v8[4] = &v9;
    uint64_t v6 = v8;
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100105550;
    block[3] = &unk_1002FA538;
    uint64_t v15 = a3;
    uint64_t v16 = v5;
    id v14 = v6;
    dispatch_sync(*(dispatch_queue_t *)(a3 + 112), block);

    uint64_t v7 = v10[3];
    _Block_object_dispose(&v9, 8);
  }
  else
  {
    SOSCCSetSOSDisabledError();
    uint64_t v7 = 0;
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v7;
}

uint64_t sub_10012CEF8(int a1, uint64_t a2, int a3, CFTypeRef cf, uint64_t a5, CFTypeRef *a6)
{
  uint64_t v23 = 0;
  id v24 = &v23;
  uint64_t v25 = 0x2000000000;
  char v26 = 0;
  if (cf && (CFTypeID v10 = CFGetTypeID(cf), v10 == CFDataGetTypeID()))
  {
    uint64_t v11 = SOSBackupSliceKeyBagCreateFromData();
    if (v11)
    {
      CFStringRef v12 = (const void *)v11;
      if (a2)
      {
        int v13 = SOSBSKBLoadAndUnlockWithPeerIDAndSecret();
      }
      else if (SOSBSKBIsDirect())
      {
        int v13 = SOSBSKBLoadAndUnlockWithDirectSecret();
      }
      else
      {
        int v13 = SOSBSKBLoadAndUnlockWithWrappingSecret();
      }
      int v14 = v13;
      if (v13 != -1)
      {
        *((unsigned char *)v24 + 24) = 1;
        v21[0] = _NSConcreteStackBlock;
        v21[1] = 0x40000000;
        void v21[2] = sub_10012D0C4;
        v21[3] = &unk_1002FB148;
        void v21[4] = &v23;
        void v21[5] = a6;
        v21[6] = a5;
        int v22 = v13;
        unsigned __int8 v15 = sub_10012C888(a6, (uint64_t)v21);
        if (*((unsigned char *)v24 + 24)) {
          unsigned __int8 v16 = v15;
        }
        else {
          unsigned __int8 v16 = 0;
        }
        *((unsigned char *)v24 + 24) = v16;
        BOOL v17 = sub_10015554C(v14, a6);
        if (*((unsigned char *)v24 + 24)) {
          BOOL v18 = v17;
        }
        else {
          BOOL v18 = 0;
        }
        *((unsigned char *)v24 + 24) = v18;
      }
      CFRelease(v12);
    }
  }
  else if (a6)
  {
    sub_100012A40(-50, (__CFString **)a6, @"object %@ is not a data", cf);
  }
  uint64_t v19 = *((unsigned __int8 *)v24 + 24);
  _Block_object_dispose(&v23, 8);
  return v19;
}

uint64_t sub_10012D0C4(uint64_t a1, uint64_t a2)
{
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_10012D184;
  v7[3] = &unk_1002FB120;
  void v7[4] = *(void *)(a1 + 32);
  void v7[5] = a2;
  int v9 = *(_DWORD *)(a1 + 56);
  int8x16_t v3 = *(int8x16_t *)(a1 + 40);
  int8x16_t v8 = vextq_s8(v3, v3, 8uLL);
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, void, void, void *))(a2 + 64))(a2, v3.i64[0], 0, 0, v7);
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v5 + 24)) {
    char v6 = result;
  }
  else {
    char v6 = 0;
  }
  *(unsigned char *)(v5 + 24) = v6;
  return result;
}

void sub_10012D184(uint64_t a1, uint64_t a2)
{
  int v3 = *(_DWORD *)(a1 + 64);
  CFDataRef v4 = *(const __CFData **)(a1 + 48);
  uint64_t v5 = *(CFTypeRef **)(a1 + 56);
  CFStringRef v12 = _NSConcreteStackBlock;
  uint64_t v13 = 0x40000000;
  int v14 = sub_10012D358;
  unsigned __int8 v15 = &unk_1002FB0F8;
  uint64_t v16 = *(void *)(a1 + 40);
  uint64_t v17 = a2;
  BOOL v18 = v5;
  uint64_t v21 = 0;
  int v22 = &v21;
  uint64_t v23 = 0x2000000000;
  char v24 = 1;
  CFDictionaryRef v6 = (const __CFDictionary *)sub_100014ED0((int)kCFAllocatorDefault, v4, v5);
  CFDictionaryRef v7 = v6;
  if (v6)
  {
    CFTypeID v8 = CFGetTypeID(v6);
    if (v8 == CFDictionaryGetTypeID())
    {
      *((unsigned char *)v22 + 24) = 1;
      context[0] = _NSConcreteStackBlock;
      context[1] = 0x40000000;
      context[2] = sub_10012D3A0;
      context[3] = &unk_1002FB170;
      int v20 = v3;
      void context[4] = &v12;
      void context[5] = &v21;
      void context[6] = v5;
      CFDictionaryApplyFunction(v7, (CFDictionaryApplierFunction)sub_10012D540, context);
LABEL_7:
      CFRelease(v7);
      BOOL v9 = *((unsigned char *)v22 + 24) != 0;
      goto LABEL_9;
    }
  }
  if (v5) {
    sub_100012A40(-50, (__CFString **)v5, @"object %@ is not a dictionary", v7, v12, v13, v14, v15, v16, v17, v18);
  }
  *((unsigned char *)v22 + 24) = 0;
  if (v7) {
    goto LABEL_7;
  }
  BOOL v9 = 0;
LABEL_9:
  _Block_object_dispose(&v21, 8);
  uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v10 + 24)) {
    BOOL v11 = v9;
  }
  else {
    BOOL v11 = 0;
  }
  *(unsigned char *)(v10 + 24) = v11;
}

void sub_10012D358(void *a1, uint64_t a2)
{
  CFTypeRef cf = 0;
  if ((*(uint64_t (**)(void, uint64_t, CFTypeRef *, void))(a1[4] + 88))(a1[5], a2, &cf, a1[6]))
  {
    if (cf) {
      CFRelease(cf);
    }
  }
}

void sub_10012D3A0(uint64_t a1, CFTypeRef cf, const void *a3)
{
  uint64_t v5 = *(__CFString ***)(a1 + 48);
  if (!cf || (CFTypeID v7 = CFGetTypeID(cf), v7 != CFStringGetTypeID()))
  {
    if (v5) {
      sub_100012A40(-50, v5, @"object %@ is not a string", cf);
    }
    goto LABEL_15;
  }
  CFTypeID v8 = sub_10000C614(cf);
  BOOL v9 = *(__CFString ***)(a1 + 48);
  if (!v8)
  {
    BOOL v18 = sub_100012A40(-26275, v9, @"bad class %@ in backup", cf);
    uint64_t v19 = *(void *)(*(void *)(a1 + 40) + 8);
    if (*(unsigned char *)(v19 + 24)) {
      BOOL v20 = v18;
    }
    else {
      BOOL v20 = 0;
    }
    *(unsigned char *)(v19 + 24) = v20;
    return;
  }
  if (!a3 || (uint64_t v10 = v8, v11 = CFGetTypeID(a3), v11 != CFArrayGetTypeID()))
  {
    if (v9) {
      sub_100012A40(-50, v9, @"object %@ is not an array", a3);
    }
LABEL_15:
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
    return;
  }
  CFIndex Count = CFArrayGetCount((CFArrayRef)a3);
  if (Count >= 1)
  {
    CFIndex v13 = Count;
    for (CFIndex i = 0; i != v13; ++i)
    {
      CFDataRef ValueAtIndex = (const __CFData *)CFArrayGetValueAtIndex((CFArrayRef)a3, i);
      uint64_t v16 = sub_10011B334(kCFAllocatorDefault, v10, ValueAtIndex, *(_DWORD *)(a1 + 56), 0, *(__CFString ***)(a1 + 48));
      if (v16)
      {
        uint64_t v17 = v16;
        (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
        CFRelease(v17);
      }
      else
      {
        *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
      }
    }
  }
}

uint64_t sub_10012D540(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

void sub_10012E158(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

uint64_t sub_10012E1B4(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void sub_10012E1C4(uint64_t a1)
{
}

void sub_10012E1CC(uint64_t a1, int a2, int a3, int a4, uint64_t a5, void *a6)
{
  id v12 = a6;
  CFIndex v13 = sub_10000B070("octagon");
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    v14[0] = 67109632;
    v14[1] = a2;
    __int16 v15 = 1024;
    int v16 = a3;
    __int16 v17 = 1024;
    int v18 = a4;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "fetch ramp records returned with featureAllowed: %d,\n featurePromoted: %d,\n featureVisible: %d,\n", (uint8_t *)v14, 0x14u);
  }

  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = a2;
  *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = a5;
  if (v12) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40), a6);
  }
  dispatch_semaphore_signal(*(dispatch_semaphore_t *)(a1 + 32));
}

void sub_10012E53C(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  CFTypeID v7 = sub_10000B070("octagon");
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412546;
    id v27 = v5;
    __int16 v28 = 2112;
    id v29 = v6;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "Fetch operation records %@ fetchError %@", buf, 0x16u);
  }

  CFTypeID v8 = [v5 objectForKeyedSubscript:*(void *)(a1 + 32)];
  BOOL v9 = v8;
  if (v8)
  {
    uint64_t v10 = [v8 objectForKeyedSubscript:@"FeatureAllowed"];
    unsigned int v11 = [v10 BOOLValue];

    id v12 = [v9 objectForKeyedSubscript:@"FeaturePromoted"];
    unsigned int v13 = [v12 BOOLValue];

    int v14 = [v9 objectForKeyedSubscript:@"FeatureVisible"];
    unsigned int v15 = [v14 BOOLValue];

    int v16 = [v9 objectForKeyedSubscript:@"RetryAfter"];
    id v17 = [v16 integerValue];

    int v18 = sub_10000B070("octagon");
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = &__kCFBooleanFalse;
      if (v11) {
        BOOL v20 = &__kCFBooleanTrue;
      }
      else {
        BOOL v20 = &__kCFBooleanFalse;
      }
      if (v13) {
        uint64_t v21 = &__kCFBooleanTrue;
      }
      else {
        uint64_t v21 = &__kCFBooleanFalse;
      }
      *(_DWORD *)long long buf = 138413058;
      if (v15) {
        uint64_t v19 = &__kCFBooleanTrue;
      }
      id v27 = v20;
      __int16 v28 = 2112;
      id v29 = v21;
      __int16 v30 = 2112;
      id v31 = v19;
      __int16 v32 = 2048;
      id v33 = v17;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "Fetch ramp state - featureAllowed %@, featurePromoted: %@, featureVisible: %@, retryAfter: %ld", buf, 0x2Au);
    }
  }
  else
  {
    int v22 = sub_10000B070("SecError");
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "octagon: Couldn't find CKRecord for ramp. Defaulting to not ramped in", buf, 2u);
    }

    NSErrorUserInfoKey v24 = NSLocalizedDescriptionKey;
    CFStringRef v25 = @" Couldn't find CKRecord for ramp. Defaulting to not ramped in";
    int v18 = +[NSDictionary dictionaryWithObjects:&v25 forKeys:&v24 count:1];
    uint64_t v23 = +[NSError errorWithDomain:@"com.apple.security.octagon" code:26 userInfo:v18];

    id v6 = (id)v23;
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_10012EC98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10012ECBC(uint64_t a1, void *a2)
{
  int v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v5 = WeakRetained;
  if (!v3)
  {
    unsigned int v11 = [WeakRetained deps];
    id v12 = [v11 stateHolder];
    id v21 = 0;
    unsigned int v13 = [v12 persistNewTrustState:1 error:&v21];
    BOOL v9 = v21;

    if (!v13 || v9)
    {
      uint64_t v19 = sub_10000B070("SecError");
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        uint64_t v23 = v9;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "octagon: unable to persist clique departure: %@", buf, 0xCu);
      }

      [v5 setError:v9];
      goto LABEL_17;
    }
    int v14 = sub_10000B070("octagon");
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Successfully departed clique", buf, 2u);
    }

    unsigned int v15 = [v5 intendedState];
    [v5 setNextState:v15];
    goto LABEL_13;
  }
  [WeakRetained setError:v3];
  id v6 = [v5 deps];
  CFTypeID v7 = [v6 lockStateTracker];
  unsigned int v8 = [v7 isLockedError:v3];

  BOOL v9 = sub_10000B070("octagon");
  BOOL v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  if (!v8)
  {
    if (!v10)
    {
LABEL_17:

      goto LABEL_18;
    }
    unsigned int v15 = [v5 deps];
    int v16 = [v15 containerName];
    id v17 = [v5 deps];
    int v18 = [v17 contextID];
    *(_DWORD *)long long buf = 138412802;
    uint64_t v23 = v16;
    __int16 v24 = 2112;
    CFStringRef v25 = v18;
    __int16 v26 = 2112;
    id v27 = v3;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Unable to depart for (%@,%@): %@", buf, 0x20u);

LABEL_13:
    goto LABEL_17;
  }
  if (v10)
  {
    *(_DWORD *)long long buf = 138412290;
    uint64_t v23 = v3;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "Departing failed due to lock state: %@", buf, 0xCu);
  }

  [v5 setNextState:@"WaitForUnlock"];
LABEL_18:
  BOOL v20 = [v5 finishedOp];
  [v5 runBeforeGroupFinished:v20];
}

void sub_10012F098(uint64_t a1, uint64_t a2, const __CFBoolean *a3)
{
  id v6 = objc_alloc((Class)_SWCServiceSpecifier);
  id v7 = [v6 initWithServiceType:_SWCServiceTypeWebCredentials applicationIdentifier:a1 domain:a2];
  id v17 = 0;
  unsigned int v8 = +[_SWCServiceDetails serviceDetailsWithServiceSpecifier:v7 error:&v17];
  id v9 = v17;
  if (!v8)
  {
    unsigned int v11 = sub_10000B070("SecError");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v19 = v9;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "+[_SWCServiceDetails serviceDetailsWithServiceSpecifier:error:] failed with %@", buf, 0xCu);
    }
    goto LABEL_12;
  }
  BOOL v10 = [v8 firstObject];
  unsigned int v11 = v10;
  if (!v10)
  {
LABEL_12:
    id v14 = v9;
    goto LABEL_13;
  }
  if (kCFBooleanTrue == a3) {
    uint64_t v12 = 1;
  }
  else {
    uint64_t v12 = 2 * (kCFBooleanFalse == a3);
  }
  id v16 = v9;
  unsigned __int8 v13 = [v10 setUserApprovalState:v12 error:&v16];
  id v14 = v16;

  if ((v13 & 1) == 0)
  {
    unsigned int v15 = sub_10000B070("SecError");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      id v19 = v14;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "-[_SWCServiceDetails setUserApprovalState:error:] failed with %@", buf, 0xCu);
    }
  }
LABEL_13:
}

void sub_10012F3A4(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  sub_100006558(a2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v3);
}

void sub_10012F4B0(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  sub_100006558(a3);
  id v5 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, uint64_t, id))(v4 + 16))(v4, a2, v5);
}

void sub_10012F810(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  sub_100006558(a2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v3);
}

void sub_10012F920(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  sub_100006558(a2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v3);
}

void sub_10012FB40(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = a2;
  sub_100006558(a3);
  id v6 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id, id))(v4 + 16))(v4, v5, v6);
}

void sub_10012FC84(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = a2;
  sub_100006558(a3);
  id v6 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id, id))(v4 + 16))(v4, v5, v6);
}

void sub_10012FDC8(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = a2;
  sub_100006558(a3);
  id v6 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id, id))(v4 + 16))(v4, v5, v6);
}

void sub_10012FF0C(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  sub_100006558(a2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v3);
}

void sub_100130034(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void *)(a1 + 32);
  sub_100006558(a2);
  id v3 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id))(v2 + 16))(v2, v3);
}

void sub_10013015C(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = a2;
  sub_100006558(a3);
  id v6 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id, id))(v4 + 16))(v4, v5, v6);
}

void sub_1001302A0(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = a2;
  sub_100006558(a3);
  id v6 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id, id))(v4 + 16))(v4, v5, v6);
}

void sub_1001303E4(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = a2;
  sub_100006558(a3);
  id v6 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id, id))(v4 + 16))(v4, v5, v6);
}

void sub_100130528(uint64_t a1, void *a2, void *a3)
{
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = a2;
  sub_100006558(a3);
  id v6 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id, id))(v4 + 16))(v4, v5, v6);
}

uint64_t sub_100130654(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4)
{
  uint64_t v4 = 0;
  uint64_t v51 = 0;
  char v52 = &v51;
  uint64_t v53 = 0x2000000000;
  uint64_t v54 = 0;
  uint64_t v47 = 0;
  int v48 = &v47;
  uint64_t v49 = 0x2000000000;
  uint64_t v50 = 0;
  uint64_t v43 = 0;
  uint64_t v44 = &v43;
  uint64_t v45 = 0x2000000000;
  uint64_t v46 = 0;
  uint64_t v35 = 0;
  id v36 = &v35;
  uint64_t v39 = 0;
  id v40 = (__CFString **)&v39;
  uint64_t v41 = 0x2000000000;
  uint64_t v42 = 0;
  uint64_t v37 = 0x2000000000;
  char v38 = 0;
  if (a1 && a2)
  {
    BOOL v9 = sub_10011A8B0(a2, dword_10035D2B0, &v42);
    BOOL v10 = sub_10000B070("ds");
    unsigned int v11 = v10;
    if (v9)
    {
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 138477827;
        uint64_t v56 = a2;
        _os_log_debug_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "setting UUID persistent ref on peersitem: %{private}@", buf, 0xCu);
      }
      CFUUIDRef v12 = CFUUIDCreate(kCFAllocatorDefault);
      CFUUIDBytes bytes = CFUUIDGetUUIDBytes(v12);
      CFDataRef v13 = CFDataCreate(kCFAllocatorDefault, &bytes.byte0, 16);
      if (v12) {
        CFRelease(v12);
      }
      CFTypeRef cf = 0;
      sub_10011B6B0(a2, v13, (__CFString **)&cf);
      if (cf)
      {
        id v14 = sub_10000B070("ds");
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138478083;
          uint64_t v56 = a2;
          __int16 v57 = 2112;
          CFTypeRef v58 = cf;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "failed to set persistent ref on item %{private}@, error: %@", buf, 0x16u);
        }
        CFTypeRef v15 = cf;
        if (cf)
        {
          CFTypeRef cf = 0;
          CFRelease(v15);
        }
      }
      if (v13) {
        CFRelease(v13);
      }
      v32[0] = _NSConcreteStackBlock;
      v32[1] = 0x40000000;
      v32[2] = sub_100130B90;
      v32[3] = &unk_1002FB2B0;
      void v32[4] = &v35;
      void v32[5] = &v47;
      void v32[6] = &v39;
      v32[7] = &v51;
      v32[9] = a2;
      void v32[10] = a3;
      v32[8] = &v43;
      if (sub_10011C214(a2, a1, v40 + 3, (uint64_t)v32) && !*((unsigned char *)v36 + 24))
      {
        __int16 v24 = sub_10000B070("ds");
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138477827;
          uint64_t v56 = a2;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "Insert succeeded for: %{private}@", buf, 0xCu);
        }
        v52[3] = 2;
        if (v40[3])
        {
          CFStringRef v25 = sub_10000B070("ds");
          if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
          {
            __int16 v26 = v40[3];
            *(_DWORD *)long long buf = 138412290;
            uint64_t v56 = (uint64_t)v26;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "kSOSMergeFailure => kSOSMergePeersObject, %@", buf, 0xCu);
          }
          id v27 = v40[3];
          if (v27) {
            CFRelease(v27);
          }
        }
      }
      id v16 = (__CFError *)v40[3];
      if (v16 && (sub_10011C1B8(v16) & 1) == 0)
      {
        id v17 = sub_10000B070("ds");
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v18 = v52[3];
          id v19 = v40[3];
          *(_DWORD *)long long buf = 134218242;
          uint64_t v56 = v18;
          __int16 v57 = 2112;
          CFTypeRef v58 = v19;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "dsMergeObject failed: mr=%ld, %@", buf, 0x16u);
        }
        if (!v52[3])
        {
          BOOL v20 = v40;
          id v21 = v40[3];
          if (v21)
          {
            if (a4 && !*a4)
            {
              *a4 = v21;
            }
            else
            {
              CFRelease(v21);
              BOOL v20 = v40;
            }
          }
          v20[3] = 0;
        }
      }
      __int16 v28 = (const void *)v48[3];
      if (v28) {
        CFRelease(v28);
      }
      id v29 = (const void *)v44[3];
      if (v29) {
        CFRelease(v29);
      }
      __int16 v30 = v40[3];
      if (v30) {
        CFRelease(v30);
      }
      uint64_t v4 = v52[3];
    }
    else
    {
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        int v22 = v40[3];
        *(_DWORD *)long long buf = 138412290;
        uint64_t v56 = (uint64_t)v22;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "kSOSMergeFailure => SecDbItemSetKeybag: %@", buf, 0xCu);
      }
      uint64_t v23 = v40[3];
      if (v23)
      {
        if (a4 && !*a4)
        {
          uint64_t v4 = 0;
          *a4 = v23;
          goto LABEL_50;
        }
        CFRelease(v23);
      }
      uint64_t v4 = 0;
    }
  }
LABEL_50:
  _Block_object_dispose(&v35, 8);
  _Block_object_dispose(&v39, 8);
  _Block_object_dispose(&v43, 8);
  _Block_object_dispose(&v47, 8);
  _Block_object_dispose(&v51, 8);
  return v4;
}

void sub_100130B90(uint64_t a1, __CFString ***a2, void *a3)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  id v6 = *(__CFString ****)(a1 + 72);
  id v7 = (__CFString **)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
  *(void *)CFTypeRef cf = 0;
  unsigned int v8 = sub_10000FD40(v6[2], kSecAttrModificationDate, v7);
  CFDateRef v9 = (const __CFDate *)sub_100118CF8(v6, (uint64_t)v8, (__CFString **)cf);
  CFDateRef v10 = (const __CFDate *)sub_100118CF8(a2, (uint64_t)v8, (__CFString **)cf);
  CFDataRef v11 = v10;
  if (v9) {
    BOOL v12 = v10 == 0;
  }
  else {
    BOOL v12 = 1;
  }
  if (v12) {
    goto LABEL_6;
  }
  CFComparisonResult v15 = CFDateCompare(v9, v10, 0);
  id v14 = a2;
  if (v15 == kCFCompareLessThan) {
    goto LABEL_40;
  }
  if (v15)
  {
    id v14 = 0;
    if (v15 == kCFCompareGreaterThan) {
      id v14 = v6;
    }
    goto LABEL_40;
  }
  uint64_t v16 = sub_100118974(v6[2], 7, (__CFString **)cf);
  CFDateRef v9 = (const __CFDate *)sub_100118CF8(v6, v16, (__CFString **)cf);
  uint64_t v17 = sub_100118974(a2[2], 7, (__CFString **)cf);
  CFDataRef v18 = (const __CFData *)sub_100118CF8(a2, v17, (__CFString **)cf);
  CFDataRef v11 = v18;
  if (!v9 || v18 == 0)
  {
LABEL_6:
    if (SecErrorGetOSStatus() == -26275)
    {
      if (v9) {
        CFDataRef v13 = v6;
      }
      else {
        CFDataRef v13 = 0;
      }
      if (v11) {
        id v14 = a2;
      }
      else {
        id v14 = v13;
      }
    }
    else
    {
      id v14 = 0;
    }
    goto LABEL_40;
  }
  CFIndex Length = CFDataGetLength(v9);
  CFIndex v21 = CFDataGetLength(v11);
  unint64_t v22 = v21;
  if (Length < 0 || v21 < 0)
  {
    id v14 = a2;
    if (Length > v21) {
      goto LABEL_40;
    }
    BOOL v28 = Length < v21;
  }
  else
  {
    if (Length >= v21) {
      size_t v23 = v21;
    }
    else {
      size_t v23 = Length;
    }
    BytePtr = CFDataGetBytePtr(v9);
    CFStringRef v25 = CFDataGetBytePtr(v11);
    int v26 = memcmp(BytePtr, v25, v23);
    id v14 = a2;
    if (v26 > 0) {
      goto LABEL_40;
    }
    BOOL v27 = !v26 && Length > v22;
    id v14 = a2;
    if (v27) {
      goto LABEL_40;
    }
    BOOL v28 = v26 == 0;
    if (Length >= v22) {
      BOOL v28 = 0;
    }
    if (v26 < 0) {
      BOOL v28 = 1;
    }
  }
  id v14 = v6;
  if (!v28) {
    id v14 = a2;
  }
LABEL_40:
  if (!*(void *)cf)
  {
LABEL_44:
    if (v14 && a2 && v14 != a2)
    {
      id v29 = v14[2];
      __int16 v30 = (uint64_t *)v29[2];
      if (!v30) {
        goto LABEL_62;
      }
      id v31 = (uint64_t **)(v29 + 3);
      do
      {
        if (*v30)
        {
          if (CFEqual((CFTypeRef)*v30, @"UUID")) {
            sub_10011AA54((uint64_t)v14, a2, v30);
          }
          if (*v30 && CFEqual((CFTypeRef)*v30, @"persistref")) {
            sub_10011AA54((uint64_t)v14, a2, v30);
          }
        }
        __int16 v32 = *v31++;
        __int16 v30 = v32;
      }
      while (v32);
      id v33 = v14[2];
      id v34 = v33[2];
      if (!v34)
      {
LABEL_62:
        CFRetain(v14);
        goto LABEL_63;
      }
      uint64_t v35 = v33 + 3;
      do
      {
        if ((BYTE2(v34->data) & 2) != 0) {
          sub_10011AA54((uint64_t)v14, a2, (uint64_t *)v34);
        }
        id v36 = *v35++;
        id v34 = v36;
      }
      while (v36);
    }
    if (!v14) {
      goto LABEL_63;
    }
    goto LABEL_62;
  }
  if (v14 || *v7)
  {
    CFRelease(*(CFTypeRef *)cf);
    goto LABEL_44;
  }
  *id v7 = *(__CFString **)cf;
LABEL_63:
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v14;
  uint64_t v37 = *(const void **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  if (v37)
  {
    if (*(void *)(a1 + 80))
    {
      **(void **)(a1 + 80) = CFRetain(v37);
      uint64_t v37 = *(const void **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    }
    if (CFEqual(v37, a2))
    {
      if ((sub_10011B4E8(a2) & 1) == 0)
      {
        char v38 = sub_10000B070("ds");
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)CFTypeRef cf = 138477827;
          *(void *)&cf[4] = a2;
          _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "Conflict resolver chose my (local) item: %{private}@", cf, 0xCu);
        }
      }
      uint64_t v39 = 1;
    }
    else
    {
      uint64_t v40 = *(void *)(*(void *)(a1 + 64) + 8);
      uint64_t v41 = *(__CFString ****)(v40 + 24);
      if (v41 != a2)
      {
        if (!a2 || (CFRetain(a2), (uint64_t v41 = *(__CFString ****)(v40 + 24)) != 0)) {
          CFRelease(v41);
        }
        *(void *)(v40 + 24) = a2;
      }
      uint64_t v42 = *(void *)(*(void *)(a1 + 40) + 8);
      uint64_t v43 = *(void *)(v42 + 24);
      if (v43) {
        CFRetain(*(CFTypeRef *)(v42 + 24));
      }
      *a3 = v43;
      if (CFEqual(*(CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), *(CFTypeRef *)(a1 + 72)))
      {
        if ((sub_10011B4E8(*(__CFString ****)(a1 + 72)) & 1) == 0)
        {
          uint64_t v44 = sub_10000B070("ds");
          if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v45 = *(void *)(a1 + 72);
            *(_DWORD *)CFTypeRef cf = 138477827;
            *(void *)&cf[4] = v45;
            _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "Conflict resolver chose peers item: %{private}@", cf, 0xCu);
          }
        }
        uint64_t v39 = 2;
      }
      else
      {
        if ((sub_10011B4E8(*(__CFString ****)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) & 1) == 0)
        {
          uint64_t v46 = sub_10000B070("ds");
          if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v47 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
            *(_DWORD *)CFTypeRef cf = 138477827;
            *(void *)&cf[4] = v47;
            _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "Conflict resolver created a new item; return it to our caller: %{private}@",
              cf,
              0xCu);
          }
        }
        uint64_t v39 = 3;
      }
    }
  }
  else
  {
    uint64_t v39 = 0;
  }
  *(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = v39;
}

CFDictionaryRef sub_1001310B4(uint64_t a1, const __CFData *a2, __CFString **a3)
{
  uint64_t v6 = sub_100118974(*(void **)(a1 + 16), 7, a3);
  values[0] = (void *)sub_100118CF8((const void *)a1, v6, a3);
  if (!values[0]) {
    return 0;
  }
  BOOL v20 = 0;
  id v7 = sub_100118B3C((void *)a1, 128, 0, a3);
  unsigned int v8 = sub_100118B3C((void *)a1, 0x2000, 0, a3);
  CFDictionaryRef v9 = v8;
  if (v7 && v8)
  {
    CFDateRef v10 = sub_100125608((void **)a1, a3);
    if (v10)
    {
      CFDataRef v11 = v10;
      if (sub_100123BD0(a2, (uint64_t)v10, *(const __CFData **)(a1 + 56), v7, v9, &v20, 0, 0, (CFTypeRef *)a3))
      {
        *(_DWORD *)(a1 + 40) = 4;
      }
      else
      {
        CFComparisonResult v15 = sub_10000B070("SecCritical");
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          if (a3) {
            CFStringRef v16 = *a3;
          }
          else {
            CFStringRef v16 = &stru_10030AA90;
          }
          *(_DWORD *)long long buf = 138412290;
          CFStringRef v24 = v16;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "ks_encrypt_data (db): failed: %@", buf, 0xCu);
        }
      }
      CFRelease(v11);
    }
    goto LABEL_23;
  }
  if (!((unint64_t)v7 | (unint64_t)v8)) {
    goto LABEL_13;
  }
  if (dword_10035AEC8 != -1
    || (BOOL v12 = sub_10000B070("SecEmergency"), !os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)))
  {
    if (v7) {
      goto LABEL_23;
    }
LABEL_11:
    if (!v9) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  CFStringRef v17 = @"missing";
  if (v7) {
    CFStringRef v18 = @"present";
  }
  else {
    CFStringRef v18 = @"missing";
  }
  if (v9) {
    CFStringRef v17 = @"present";
  }
  if (a3) {
    CFStringRef v19 = *a3;
  }
  else {
    CFStringRef v19 = @"no error pointer";
  }
  *(_DWORD *)long long buf = 138412802;
  CFStringRef v24 = v18;
  __int16 v25 = 2112;
  CFStringRef v26 = v17;
  __int16 v27 = 2112;
  CFStringRef v28 = v19;
  _os_log_fault_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_FAULT, "SecDbItemCopyEncryptedDataToBackup: not all plists are present: attributes: %@, auth_attributes: %@ : %@", buf, 0x20u);
  if (!v7) {
    goto LABEL_11;
  }
LABEL_23:
  CFRelease(v7);
  if (v9) {
LABEL_12:
  }
    CFRelease(v9);
LABEL_13:
  CFTypeRef cf = v20;
  if (!v20) {
    return 0;
  }
  values[1] = **(void ***)(a1 + 16);
  CFDictionaryRef v13 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)&off_10035BB90, (const void **)values, 3, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  CFRelease(cf);
  return v13;
}

__CFDictionary *sub_100131370(uint64_t a1, __CFString **a2)
{
  uint64_t v4 = sub_100118B3C((void *)a1, 32, 0x20000, a2);
  id v5 = sub_100118B3C((void *)a1, 128, 0x20000, a2);
  uint64_t v6 = sub_100118B3C((void *)a1, 0x2000, 0x20000, a2);
  id v7 = v6;
  if (v5)
  {
    if (v6)
    {
      context[0] = _NSConcreteStackBlock;
      context[1] = 0x40000000;
      context[2] = sub_1001314F8;
      context[3] = &unk_1002FB7D0;
      void context[4] = v5;
      CFDictionaryApplyFunction(v6, (CFDictionaryApplierFunction)sub_100131508, context);
    }
    if (v4)
    {
      v9[0] = _NSConcreteStackBlock;
      v9[1] = 0x40000000;
      _OWORD v9[2] = sub_100131500;
      v9[3] = &unk_1002FB7F0;
      void v9[4] = v5;
      CFDictionaryApplyFunction(v4, (CFDictionaryApplierFunction)sub_100131508, v9);
    }
    CFDictionaryAddValue(v5, kSecClass, **(const void ***)(a1 + 16));
  }
  if (v4) {
    CFRelease(v4);
  }
  if (v7) {
    CFRelease(v7);
  }
  return v5;
}

void sub_1001314F8(uint64_t a1, const void *a2, const void *a3)
{
}

void sub_100131500(uint64_t a1, const void *a2, const void *a3)
{
}

uint64_t sub_100131508(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, a1, a2);
}

const void *sub_100131524(const __CFDictionary *a1, __CFString **a2)
{
  SInt32 Value = CFDictionaryGetValue(a1, kSecClass);
  if (!Value)
  {
    sub_100012A40(-50, a2, @"query missing %@ attribute", kSecClass);
    return 0;
  }
  id v5 = Value;
  uint64_t v6 = sub_10000C614(Value);
  if (!v6)
  {
    sub_100012A40(-25306, a2, @"can find class named: %@", v5);
    return 0;
  }
  int v7 = dword_10035D2B0;

  return sub_10011ACF4((uint64_t)v6, a1, v7, a2);
}

const void *sub_1001315E0(void **a1)
{
  uint64_t v2 = sub_100118974(a1[2], 6, 0);
  if (!v2) {
    return 0;
  }
  id v3 = sub_100118CF8(a1, v2, 0);
  uint64_t v4 = v3;
  if (v3) {
    CFRetain(v3);
  }
  return v4;
}

const void *sub_100131640(void **a1, __CFString **a2)
{
  uint64_t v4 = sub_100118974(a1[2], 7, a2);
  id v5 = sub_100118CF8(a1, v4, a2);
  uint64_t v6 = v5;
  if (v5) {
    CFRetain(v5);
  }
  return v6;
}

BOOL sub_100131698(uint64_t a1, int a2, CFDictionaryRef theDict, __CFString **a4)
{
  SInt32 Value = CFDictionaryGetValue(theDict, @"class");
  CFDataRef v9 = (const __CFData *)CFDictionaryGetValue(theDict, @"data");
  if (Value) {
    BOOL v10 = v9 == 0;
  }
  else {
    BOOL v10 = 1;
  }
  if (v10)
  {
    return sub_100012A40(-26275, a4, @"no class or data in object");
  }
  else
  {
    CFDataRef v12 = v9;
    CFDictionaryRef v13 = sub_10000C614(Value);
    if (v13)
    {
      id v14 = sub_10011B334(kCFAllocatorDefault, v13, v12, a2, 0, a4);
      if (!v14) {
        return 0;
      }
      CFComparisonResult v15 = v14;
      BOOL v16 = sub_100130654(a1, (uint64_t)v14, 0, a4) != 0;
      CFRelease(v15);
      return v16;
    }
    else
    {
      return sub_100012A40(-26275, a4, @"no such class %@; update kc_class_with_name ", Value);
    }
  }
}

BOOL sub_1001317CC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __CFString **a5)
{
  CFStringRef v7 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"SOSDataSource-%@", *(void *)(a1 + 160));
  CFComparisonResult v15 = sub_1000FF7EC(kCFAllocatorDefault, v8, v9, v10, v11, v12, v13, v14, (void *)kSecAttrAccessGroup, kSOSInternalAccessGroup);
  if (v7) {
    CFRelease(v7);
  }
  uint64_t v16 = sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008);
  CFStringRef v17 = (CFStringRef **)sub_10011ACF4(v16, v15, dword_10035D2B0, a5);
  BOOL v18 = sub_10011E31C(v17, a4, (CFTypeRef *)a5, (uint64_t)&stru_1002FAA18);
  if (v15) {
    CFRelease(v15);
  }
  if (v17) {
    CFRelease(v17);
  }
  return v18;
}

BOOL sub_100131928(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, __CFString **a6)
{
  CFStringRef v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"SOSDataSource-%@", *(void *)(a1 + 160));
  BOOL v18 = sub_1000FF7EC(kCFAllocatorDefault, v11, v12, v13, v14, v15, v16, v17, (void *)kSecAttrAccessGroup, kSOSInternalAccessGroup);
  if (v10) {
    CFRelease(v10);
  }
  uint64_t v19 = sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008);
  BOOL v20 = sub_10011ACF4(v19, v18, dword_10035D2B0, a6);
  uint64_t v21 = sub_100130654(a2, (uint64_t)v20, 0, a6);
  if (!v21)
  {
    unint64_t v22 = sub_10000B070("SecError");
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      if (a6) {
        size_t v23 = *a6;
      }
      else {
        size_t v23 = 0;
      }
      *(_DWORD *)long long buf = 138412802;
      uint64_t v26 = a3;
      __int16 v27 = 2112;
      uint64_t v28 = a4;
      __int16 v29 = 2112;
      __int16 v30 = v23;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "failed to save %@@%@ state: %@", buf, 0x20u);
    }
  }
  if (v20) {
    CFRelease(v20);
  }
  if (v18) {
    CFRelease(v18);
  }
  return v21 != 0;
}

uint64_t sub_100131B48()
{
  return 1;
}

uint64_t sub_100131B50(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4 = *(void *)(a1 + 152);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  _DWORD v6[2] = sub_100131BD0;
  v6[3] = &unk_1002FB7B0;
  void v6[4] = a4;
  return sub_10000CBA4(0, 1, v4, a2, v6);
}

uint64_t sub_100131BD0(uint64_t a1, uint64_t a2)
{
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_100131C8C;
  v4[3] = &unk_1002FB788;
  void v4[4] = *(void *)(a1 + 32);
  void v4[5] = a2;
  uint64_t v2 = *(NSObject **)(*(void *)(a2 + 16) + 32);
  block[0] = _NSConcreteStackBlock;
  block[1] = 0x40000000;
  block[2] = sub_100028F6C;
  block[3] = &unk_1002F77C8;
  void block[4] = v4;
  dispatch_sync(v2, block);
  return 1;
}

uint64_t sub_100131C8C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40));
}

uint64_t sub_100131CA0(uint64_t a1, uint64_t a2, uint64_t a3, char a4, uint64_t a5)
{
  uint64_t v5 = *(void *)(a1 + 152);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 0x40000000;
  v7[2] = sub_100131D2C;
  v7[3] = &unk_1002FB760;
  void v7[5] = a3;
  void v7[6] = a2;
  char v8 = a4;
  void v7[4] = a5;
  return sub_10000CBA4(1, 1, v5, a2, v7);
}

BOOL sub_100131D2C(uint64_t a1, uint64_t a2)
{
  id v3 = *(CFTypeRef **)(a1 + 48);
  if (*(void *)(a1 + 40) == 1) {
    uint64_t v4 = 2;
  }
  else {
    uint64_t v4 = 4;
  }
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  _DWORD v6[2] = sub_100131DC0;
  v6[3] = &unk_1002FB738;
  char v7 = *(unsigned char *)(a1 + 56);
  void v6[4] = *(void *)(a1 + 32);
  void v6[5] = a2;
  return sub_100027B34(a2, v4, v3, (uint64_t)v6);
}

void sub_100131DC0(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a1 + 48))
  {
    v8[0] = _NSConcreteStackBlock;
    v8[1] = 0x40000000;
    v8[2] = sub_100131EB4;
    v8[3] = &unk_1002FB710;
    uint64_t v3 = *(void *)(a1 + 40);
    v8[4] = *(void *)(a1 + 32);
    void v8[5] = v3;
    void v8[6] = a2;
    uint64_t v4 = *(NSObject **)(*(void *)(v3 + 16) + 32);
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = sub_100028F6C;
    block[3] = &unk_1002F77C8;
    void block[4] = v8;
    dispatch_sync(v4, block);
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 40);
    uint64_t v6 = *(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 32) + 16);
    uint64_t v7 = *(void *)(a1 + 32);
    v6(v7, v5, a2);
  }
}

uint64_t sub_100131EB4(void *a1)
{
  return (*(uint64_t (**)(void, void, void))(a1[4] + 16))(a1[4], a1[5], a1[6]);
}

uint64_t sub_100131ECC(uint64_t a1, uint64_t a2, uint64_t a3, __CFString **a4, uint64_t a5)
{
  uint64_t v19 = 0;
  BOOL v20 = &v19;
  uint64_t v21 = 0x2000000000;
  char v22 = 1;
  CFStringRef v10 = (void *)sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008);
  uint64_t v11 = sub_100118974(v10, 7, a4);
  if (v11)
  {
    memset(v25, 0, sizeof(v25));
    memset(v24, 0, sizeof(v24));
    memset(v23, 0, sizeof(v23));
    v18[0] = 0;
    v18[1] = v18;
    void v18[2] = 0x2000000000;
    v18[3] = v25;
    v17[0] = 0;
    v17[1] = v17;
    v17[2] = 0x2000000000;
    v17[3] = v24;
    v16[0] = 0;
    v16[1] = v16;
    void v16[2] = 0x2000000000;
    v16[3] = v23;
    v15[0] = _NSConcreteStackBlock;
    v15[1] = 0x40000000;
    int v15[2] = sub_1001320D8;
    v15[3] = &unk_1002FB6E8;
    v15[8] = v18;
    v15[9] = v17;
    void v15[4] = &stru_1002FB630;
    void v15[5] = &stru_1002FB670;
    v15[10] = v16;
    v15[11] = a4;
    v15[12] = a3;
    v15[13] = v11;
    void v15[6] = a5;
    v15[7] = &v19;
    if (a2)
    {
      sub_1001320D8((uint64_t)v15, a2);
      uint64_t v12 = *((unsigned char *)v20 + 24) != 0;
    }
    else
    {
      unsigned int v13 = sub_10000CBA4(0, 1, *(void *)(a1 + 152), a4, v15);
      if (*((unsigned char *)v20 + 24)) {
        uint64_t v12 = v13;
      }
      else {
        uint64_t v12 = 0;
      }
      *((unsigned char *)v20 + 24) = v12;
    }
    _Block_object_dispose(v16, 8);
    _Block_object_dispose(v17, 8);
    _Block_object_dispose(v18, 8);
  }
  else
  {
    uint64_t v12 = 0;
  }
  _Block_object_dispose(&v19, 8);
  return v12;
}

uint64_t sub_1001320D8(uint64_t a1, uint64_t a2)
{
  for (unint64_t i = 0; i != 32; i += 8)
  {
    char v5 = *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
    if (v5)
    {
      if (qword_10035CFB0 != -1) {
        dispatch_once(&qword_10035CFB0, &stru_1002FB410);
      }
      uint64_t v6 = sub_10000C7F0(qword_10035CFB8[i / 8], 0, 0, 0, *(__CFString ***)(a1 + 88));
      *(void *)(*(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) + i) = v6;
      if (v6
        && (uint64_t v7 = sub_10011C8B0(*(CFDictionaryRef **)(*(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) + i), *(void *)(a1 + 32), *(void *)(a1 + 40), 0), (*(void *)(*(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) + i) = v7) != 0))
      {
        char v8 = sub_1000111CC(a2, *(const __CFString **)(*(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) + i), 0, *(CFTypeRef **)(a1 + 88));
        *(void *)(*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) + i) = v8;
        char v5 = v8 != 0;
      }
      else
      {
        char v5 = 0;
      }
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = v5;
  }
  uint64_t v9 = *(void *)(a1 + 56);
  if (*(unsigned char *)(*(void *)(v9 + 8) + 24))
  {
    v25[0] = _NSConcreteStackBlock;
    v25[1] = 0x40000000;
    _OWORD v25[2] = sub_100132344;
    v25[3] = &unk_1002FB6C0;
    uint64_t v10 = *(void *)(a1 + 96);
    uint64_t v11 = *(void *)(a1 + 104);
    uint64_t v12 = *(void *)(a1 + 80);
    uint64_t v13 = *(void *)(a1 + 88);
    uint64_t v29 = *(void *)(a1 + 64);
    uint64_t v30 = v12;
    uint64_t v31 = v11;
    uint64_t v32 = v13;
    uint64_t v33 = a2;
    int8x16_t v26 = vextq_s8(*(int8x16_t *)(a1 + 32), *(int8x16_t *)(a1 + 32), 8uLL);
    uint64_t v27 = *(void *)(a1 + 48);
    uint64_t v28 = v9;
    sub_100200E78(v10, (uint64_t)v25);
  }
  for (uint64_t j = 0; j != 32; j += 8)
  {
    int v15 = *(sqlite3_stmt **)(*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) + j);
    if (v15) {
      BOOL v16 = sub_100011164(v15, *(CFTypeRef **)(a1 + 88));
    }
    else {
      BOOL v16 = 1;
    }
    uint64_t v17 = *(void *)(*(void *)(a1 + 56) + 8);
    if (*(unsigned char *)(v17 + 24)) {
      BOOL v18 = v16;
    }
    else {
      BOOL v18 = 0;
    }
    *(unsigned char *)(v17 + 24) = v18;
    uint64_t v19 = *(const void **)(*(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) + j);
    if (v19) {
      CFRelease(v19);
    }
    BOOL v20 = *(const void ***)(*(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) + j);
    if (v20)
    {
      char v21 = sub_10000C2C4(v20, *(CFErrorRef **)(a1 + 88));
      uint64_t v22 = *(void *)(*(void *)(a1 + 56) + 8);
      if (*(unsigned char *)(v22 + 24)) {
        char v23 = v21;
      }
      else {
        char v23 = 0;
      }
      *(unsigned char *)(v22 + 24) = v23;
    }
  }
  return 1;
}

void sub_100132344(uint64_t a1, void *value)
{
  uint64_t v21 = 0;
  uint64_t v22 = &v21;
  uint64_t v23 = 0x2000000000;
  uint64_t v24 = 0;
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24))
  {
    unint64_t v4 = 0;
    do
    {
      if (v22[3]) {
        BOOL v5 = 1;
      }
      else {
        BOOL v5 = v4 >= 4;
      }
      if (v5) {
        break;
      }
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(*(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) + 8 * v4)+ 8), **(const void ***)(a1 + 80), value);
      *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = sub_10011CC14(*(CFDictionaryRef **)(*(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24)+ 8 * v4), *(sqlite3_stmt **)(*(void *)(*(void *)(*(void *)(a1 + 72) + 8)+ 24)+ 8 * v4), *(__CFString ***)(a1 + 88), *(void *)(a1 + 32), 0);
      if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24)) {
        break;
      }
      uint64_t v6 = *(void *)(a1 + 72);
      uint64_t v7 = *(sqlite3_stmt **)(*(void *)(*(void *)(v6 + 8) + 24) + 8 * v4);
      uint64_t v9 = *(CFTypeRef **)(a1 + 88);
      uint64_t v8 = *(void *)(a1 + 96);
      v20[0] = _NSConcreteStackBlock;
      v20[1] = 0x40000000;
      int v20[2] = sub_10013258C;
      v20[3] = &unk_1002FB698;
      v20[6] = *(void *)(a1 + 64);
      v20[7] = v6;
      v20[8] = v4;
      v20[9] = v9;
      void v20[4] = *(void *)(a1 + 40);
      v20[5] = &v21;
      char v10 = sub_1000275B0(v8, v7, v9, (uint64_t)v20);
      uint64_t v11 = *(void *)(*(void *)(a1 + 56) + 8);
      char v12 = *(unsigned char *)(v11 + 24) ? v10 : 0;
      *(unsigned char *)(v11 + 24) = v12;
      if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24)) {
        break;
      }
      uint64_t v13 = *(sqlite3_stmt **)(*(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) + 8 * v4);
      int v14 = *(CFTypeRef **)(a1 + 88);
      uint64_t v15 = sqlite3_reset(v13);
      BOOL v16 = sub_10000ED34(v15, v13, v14, @"reset");
      uint64_t v17 = *(void *)(*(void *)(a1 + 56) + 8);
      BOOL v18 = *(unsigned char *)(v17 + 24) && v16;
      *(unsigned char *)(v17 + 24) = v18;
      ++v4;
    }
    while (*(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24));
  }
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  uint64_t v19 = (const void *)v22[3];
  if (v19) {
    CFRelease(v19);
  }
  _Block_object_dispose(&v21, 8);
}

uint64_t sub_10013258C(uint64_t *a1)
{
  uint64_t result = sub_10011B210(kCFAllocatorDefault, **(void ***)(*(void *)(*(void *)(a1[6] + 8) + 24) + 8 * a1[8]), *(sqlite3_stmt **)(*(void *)(*(void *)(a1[7] + 8) + 24) + 8 * a1[8]), dword_10035D2B0, a1[4]);
  *(void *)(*(void *)(a1[5] + 8) + 24) = result;
  return result;
}

void sub_1001325F8(id a1)
{
  qword_10035CFB8[0] = sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008);
  qword_10035CFC0 = sub_10000C75C(@"inet", &qword_10035D020, (uint64_t)&unk_10035D018);
  qword_10035CFC8 = sub_10000C75C(@"keys", &qword_10035D040, (uint64_t)&unk_10035D038);
  qword_10035CFD0 = sub_10000C75C(@"cert", &qword_10035D030, (uint64_t)&unk_10035D028);
}

BOOL sub_10013269C(id a1, const SecDbAttr *a2)
{
  return a2->var1 == 7;
}

BOOL sub_1001326AC(id a1, const SecDbAttr *a2)
{
  return (a2->var1 & 0xFFFFFFFE) == 8;
}

uint64_t sub_1001326C0(uint64_t a1, CFDictionaryRef theDict, __CFString **a3)
{
  MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(kCFAllocatorDefault, 0, theDict);
  uint64_t v17 = 0;
  BOOL v18 = &v17;
  uint64_t v19 = 0x2000000000;
  uint64_t v20 = 0;
  uint64_t v7 = sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008);
  uint64_t v8 = (const void **)sub_10000C7F0(v7, 0, MutableCopy, 0, a3);
  if (v8)
  {
    uint64_t v9 = v8;
    char v10 = v8[1];
    if (v10) {
      CFRelease(v10);
    }
    v9[1] = MutableCopy;
    uint64_t v11 = *(void *)(a1 + 152);
    v16[0] = _NSConcreteStackBlock;
    v16[1] = 0x40000000;
    void v16[2] = sub_1001328C0;
    v16[3] = &unk_1002FB5F0;
    v16[6] = a3;
    v16[7] = MutableCopy;
    v16[8] = theDict;
    void v16[4] = &v17;
    void v16[5] = v9;
    sub_10000CBA4(0, 1, v11, a3, v16);
    sub_10000C2C4(v9, (CFErrorRef *)a3);
  }
  else if (MutableCopy)
  {
    CFRelease(MutableCopy);
  }
  if (!v18[3])
  {
    char v12 = sub_10000B070("ds");
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      if (a3) {
        uint64_t v13 = *a3;
      }
      else {
        uint64_t v13 = 0;
      }
      *(_DWORD *)long long buf = 138412546;
      CFDictionaryRef v22 = theDict;
      __int16 v23 = 2112;
      uint64_t v24 = v13;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "failed to load item %@: %@", buf, 0x16u);
    }
  }
  uint64_t v14 = v18[3];
  _Block_object_dispose(&v17, 8);
  return v14;
}

BOOL sub_1001328C0(void *a1, uint64_t a2)
{
  uint64_t v3 = (CFDictionaryRef *)a1[5];
  uint64_t v2 = (CFTypeRef *)a1[6];
  v7.CFStringRef isa = _NSConcreteStackBlock;
  *(void *)&v7.flags = 0x40000000;
  v7.invoke = (void (*)(void *, ...))sub_100132994;
  v7.descriptor = (Block_descriptor_1 *)&unk_1002FB5A0;
  uint64_t v8 = a1[7];
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  _DWORD v6[2] = sub_1001329BC;
  v6[3] = &unk_1002FB5C8;
  uint64_t v4 = a1[8];
  void v6[4] = a1[4];
  void v6[5] = v4;
  void v6[6] = v2;
  return sub_10011C750(v3, a2, v2, 0, &v7, 0, 0, (uint64_t)v6);
}

BOOL sub_100132994(uint64_t a1, const void **a2)
{
  return CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 32), *a2) != 0;
}

const void *sub_1001329BC(uint64_t a1, const void *a2)
{
  uint64_t v4 = sub_10000B070("ds");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 40);
    int v8 = 138412290;
    uint64_t v9 = v5;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "found item for keys %@", (uint8_t *)&v8, 0xCu);
  }
  uint64_t result = sub_100118CF8(a2, (uint64_t)&off_1002FC058, *(__CFString ***)(a1 + 48));
  Block_layout v7 = result;
  if (result) {
    uint64_t result = CFRetain(result);
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v7;
  return result;
}

uint64_t sub_100132AA0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, __CFString **a5)
{
  CFStringRef v10 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"SOSDataSource-%@", *(void *)(a1 + 160));
  BOOL v18 = sub_1000FF7EC(kCFAllocatorDefault, v11, v12, v13, v14, v15, v16, v17, (void *)kSecAttrAccessGroup, kSOSInternalAccessGroup);
  if (v10) {
    CFRelease(v10);
  }
  uint64_t v28 = 0;
  uint64_t v29 = &v28;
  uint64_t v30 = 0x2000000000;
  uint64_t v31 = 0;
  uint64_t v19 = sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008);
  uint64_t v20 = (const void **)sub_10000C7F0(v19, 0, v18, 0, a5);
  if (v20)
  {
    uint64_t v21 = v20;
    CFDictionaryRef v22 = v20[1];
    if (v22) {
      CFRelease(v22);
    }
    v21[1] = v18;
    v27[0] = _NSConcreteStackBlock;
    v27[1] = 0x40000000;
    v27[2] = sub_100132D60;
    v27[3] = &unk_1002FB580;
    v27[6] = a5;
    v27[7] = v18;
    v27[8] = a2;
    v27[9] = a3;
    v27[4] = &v28;
    void v27[5] = v21;
    if (a4) {
      sub_100132D60((uint64_t)v27, a4);
    }
    else {
      sub_10000CBA4(0, 1, *(void *)(a1 + 152), a5, v27);
    }
    sub_10000C2C4(v21, (CFErrorRef *)a5);
  }
  else if (v18)
  {
    CFRelease(v18);
  }
  if (!v29[3])
  {
    __int16 v23 = sub_10000B070("ds");
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      if (a5) {
        uint64_t v24 = *a5;
      }
      else {
        uint64_t v24 = 0;
      }
      *(_DWORD *)long long buf = 138412802;
      uint64_t v33 = a2;
      __int16 v34 = 2112;
      uint64_t v35 = a3;
      __int16 v36 = 2112;
      uint64_t v37 = v24;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "failed to load %@@%@ state: %@", buf, 0x20u);
    }
  }
  uint64_t v25 = v29[3];
  _Block_object_dispose(&v28, 8);
  return v25;
}

BOOL sub_100132D60(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(CFDictionaryRef **)(a1 + 40);
  uint64_t v2 = *(CFTypeRef **)(a1 + 48);
  v8.CFStringRef isa = _NSConcreteStackBlock;
  *(void *)&v8.flags = 0x40000000;
  v8.invoke = (void (*)(void *, ...))sub_100132E38;
  v8.descriptor = (Block_descriptor_1 *)&unk_1002FB530;
  uint64_t v9 = *(void *)(a1 + 56);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  _DWORD v5[2] = sub_100132E60;
  v5[3] = &unk_1002FB558;
  long long v6 = *(_OWORD *)(a1 + 64);
  void v5[4] = *(void *)(a1 + 32);
  Block_layout v7 = v2;
  return sub_10011C750(v3, a2, v2, 0, &v8, 0, 0, (uint64_t)v5);
}

BOOL sub_100132E38(uint64_t a1, const void **a2)
{
  return CFDictionaryContainsKey(*(CFDictionaryRef *)(a1 + 32), *a2) != 0;
}

const void *sub_100132E60(uint64_t a1, const void *a2)
{
  uint64_t v4 = sub_10000B070("ds");
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v5 = *(void *)(a1 + 40);
    uint64_t v6 = *(void *)(a1 + 48);
    int v9 = 138412546;
    uint64_t v10 = v5;
    __int16 v11 = 2112;
    uint64_t v12 = v6;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "found item for key %@@%@", (uint8_t *)&v9, 0x16u);
  }
  uint64_t result = sub_100118CF8(a2, (uint64_t)&off_1002FC058, *(__CFString ***)(a1 + 56));
  Block_layout v8 = result;
  if (result) {
    uint64_t result = CFRetain(result);
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v8;
  return result;
}

CFTypeRef sub_100132F50(uint64_t a1, const __CFSet *a2, CFTypeRef *a3)
{
  CFArrayRef Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, 0);
  uint64_t v18 = 0;
  uint64_t v19 = &v18;
  uint64_t v20 = 0x2000000000;
  char v21 = 1;
  context[0] = _NSConcreteStackBlock;
  context[1] = 0x40000000;
  context[2] = sub_100133258;
  context[3] = &unk_1002FB390;
  void context[4] = &v18;
  void context[5] = a1;
  void context[6] = Mutable;
  void context[7] = a3;
  CFSetApplyFunction(a2, (CFSetApplierFunction)sub_100133CBC, context);
  if (*((unsigned char *)v19 + 24))
  {
    CFTypeRef cf = 0;
    p_CFTypeRef cf = &cf;
    uint64_t v28 = 0x2000000000;
    uint64_t v29 = 0;
    uint64_t v22 = 0;
    __int16 v23 = &v22;
    uint64_t v24 = 0x2000000000;
    uint64_t v25 = 0;
    uint64_t v7 = *(void *)(a1 + 152);
    *(void *)&long long buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 0x40000000;
    uint64_t v31 = sub_10013379C;
    uint64_t v32 = &unk_1002FB480;
    __int16 v34 = &cf;
    CFArrayRef v35 = Mutable;
    uint64_t v33 = &v22;
    if ((sub_10000CBA4(0, 1, v7, a3, &buf) & 1) == 0)
    {
      CFTypeRef v8 = p_cf[3];
      if (v8) {
        CFRelease(v8);
      }
    }
    int v9 = (const void *)v23[3];
    if (v9)
    {
      if (a3 && !*a3) {
        *a3 = v9;
      }
      else {
        CFRelease(v9);
      }
    }
    CFTypeRef v10 = p_cf[3];
    _Block_object_dispose(&v22, 8);
    _Block_object_dispose(&cf, 8);
  }
  else
  {
    CFTypeRef v10 = 0;
  }
  CFIndex Count = CFArrayGetCount(Mutable);
  if (Count >= 1)
  {
    CFIndex v12 = Count;
    CFIndex v13 = 0;
    while (1)
    {
      CFDataRef ValueAtIndex = (const void **)CFArrayGetValueAtIndex(Mutable, v13);
      CFTypeRef cf = 0;
      if (sub_10000C2C4(ValueAtIndex, (CFErrorRef *)&cf)) {
        goto LABEL_22;
      }
      int v15 = sub_10000B070("SecError");
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        LODWORD(buf) = 138412290;
        *(void *)((char *)&buf + 4) = cf;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "query_destroy failed: %@", (uint8_t *)&buf, 0xCu);
      }
      if (!cf) {
        goto LABEL_21;
      }
      if (!a3 || *a3) {
        break;
      }
      *a3 = cf;
      if (v10)
      {
LABEL_25:
        CFRelease(v10);
        CFTypeRef v10 = 0;
      }
LABEL_22:
      if (v12 == ++v13) {
        goto LABEL_26;
      }
    }
    CFRelease(cf);
LABEL_21:
    if (v10) {
      goto LABEL_25;
    }
    goto LABEL_22;
  }
LABEL_26:
  if (Mutable) {
    CFRelease(Mutable);
  }
  _Block_object_dispose(&v18, 8);
  return v10;
}

void sub_100133258(uint64_t a1, CFStringRef theString)
{
  uint64_t v4 = *(__CFArray **)(a1 + 48);
  uint64_t v3 = *(__CFString ***)(a1 + 56);
  int HasSuffix = CFStringHasSuffix(theString, @"-tomb");
  if (HasSuffix)
  {
    v26.size_t length = CFStringGetLength(theString) - 5;
    v26.id location = 0;
    uint64_t v6 = (void *)CFStringCreateWithSubstring(kCFAllocatorDefault, theString, v26);
  }
  else
  {
    uint64_t v6 = (void *)CFRetain(theString);
  }
  uint64_t v7 = v6;
  if ((SOSViewInSOSSystem() & 1) == 0) {
    goto LABEL_23;
  }
  if (CFEqual(v7, kSOSViewKeychainV0))
  {
    for (uint64_t i = 0; i != 3; ++i)
    {
      if (qword_10035CF90 != -1) {
        dispatch_once(&qword_10035CF90, &stru_1002FB3D0);
      }
      sub_100133CD4(v4, qword_10035CF98[i], HasSuffix != 0, 0, 0, v3);
    }
    goto LABEL_23;
  }
  if (CFEqual(v7, kSOSViewWiFi))
  {
    uint64_t v9 = sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008);
    CFTypeRef v10 = sub_100133ED8(v4, v9, HasSuffix != 0, (const __CFBoolean *)@"apple", v3);
    if (v10) {
      sub_10000DF34(kSecAttrService, (const __CFBoolean *)@"AirPort", (uint64_t)v10);
    }
    goto LABEL_23;
  }
  if (CFEqual(v7, kSOSViewAutofillPasswords))
  {
    BOOL v11 = HasSuffix != 0;
    uint64_t v12 = sub_10000C75C(@"inet", &qword_10035D020, (uint64_t)&unk_10035D018);
    CFStringRef v13 = @"com.apple.cfnetwork";
LABEL_22:
    sub_100133ED8(v4, v12, v11, (const __CFBoolean *)v13, v3);
    goto LABEL_23;
  }
  if (CFEqual(v7, kSOSViewSafariCreditCards))
  {
    BOOL v11 = HasSuffix != 0;
    uint64_t v12 = sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008);
    CFStringRef v13 = @"com.apple.safari.credit-cards";
    goto LABEL_22;
  }
  if (CFEqual(v7, kSOSViewiCloudIdentity))
  {
    BOOL v11 = HasSuffix != 0;
    uint64_t v12 = sub_10000C75C(@"keys", &qword_10035D040, (uint64_t)&unk_10035D038);
    CFStringRef v13 = @"com.apple.security.sos";
    goto LABEL_22;
  }
  if (CFEqual(v7, kSOSViewBackupBagV0))
  {
    BOOL v11 = HasSuffix != 0;
    uint64_t v12 = sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008);
    CFStringRef v13 = @"com.apple.sbd";
    goto LABEL_22;
  }
  if (CFEqual(v7, kSOSViewOtherSyncable))
  {
    BOOL v14 = HasSuffix != 0;
    uint64_t v15 = sub_10000C75C(@"cert", &qword_10035D030, (uint64_t)&unk_10035D028);
    sub_100133CD4(v4, v15, v14, 1, 0, v3);
    uint64_t v16 = sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008);
    int v17 = sub_100133ED8(v4, v16, v14, (const __CFBoolean *)@"apple", v3);
    sub_10012947C(kSecAttrService, (const __CFData *)@"AirPort", (uint64_t)v17);
    uint64_t v18 = sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008);
    uint64_t v19 = sub_100133CD4(v4, v18, v14, 1, 0, v3);
    sub_10012947C(kSecAttrAccessGroup, (const __CFData *)@"apple", (uint64_t)v19);
    sub_10012947C(kSecAttrAccessGroup, (const __CFData *)@"com.apple.safari.credit-cards", (uint64_t)v19);
    sub_10012947C(kSecAttrAccessGroup, (const __CFData *)@"com.apple.sbd", (uint64_t)v19);
    uint64_t v20 = sub_10000C75C(@"inet", &qword_10035D020, (uint64_t)&unk_10035D018);
    char v21 = sub_100133CD4(v4, v20, v14, 1, 0, v3);
    sub_10012947C(kSecAttrAccessGroup, (const __CFData *)@"com.apple.cfnetwork", (uint64_t)v21);
    uint64_t v22 = sub_10000C75C(@"keys", &qword_10035D040, (uint64_t)&unk_10035D038);
    __int16 v23 = sub_100133CD4(v4, v22, v14, 1, 0, v3);
    sub_10012947C(kSecAttrAccessGroup, (const __CFData *)@"com.apple.security.sos", (uint64_t)v23);
  }
  else
  {
    for (uint64_t j = 0; j != 4; ++j)
    {
      if (qword_10035CFB0 != -1) {
        dispatch_once(&qword_10035CFB0, &stru_1002FB410);
      }
      sub_100133CD4(v4, qword_10035CFB8[j], HasSuffix != 0, 1, (const __CFData *)v7, v3);
    }
  }
LABEL_23:
  if (v7)
  {
    CFRelease(v7);
  }
}

BOOL sub_10013379C(uint64_t a1, uint64_t a2)
{
  uint64_t v21 = 0;
  uint64_t v22 = &v21;
  uint64_t v23 = 0x3800000000;
  long long v24 = 0u;
  long long v25 = 0u;
  CFIndex Count = CFArrayGetCount(*(CFArrayRef *)(a1 + 48));
  if (Count < 1)
  {
    BOOL v6 = 1;
LABEL_11:
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = sub_100201498((uint64_t)(v22 + 3), (CFTypeRef *)(*(void *)(*(void *)(a1 + 32) + 8)+ 24));
  }
  else
  {
    CFIndex v5 = Count;
    BOOL v6 = 0;
    CFIndex v7 = 0;
    while (1)
    {
      CFDataRef ValueAtIndex = (CFDictionaryRef *)CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 48), v7);
      uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8);
      v20[0] = _NSConcreteStackBlock;
      v20[1] = 0x40000000;
      int v20[2] = sub_100133AC4;
      v20[3] = &unk_1002FB430;
      void v20[4] = ValueAtIndex;
      v19[0] = _NSConcreteStackBlock;
      v19[1] = 0x40000000;
      v19[2] = sub_100133AF0;
      v19[3] = &unk_1002FB458;
      void v19[4] = &v21;
      uint64_t v26 = 0;
      uint64_t v27 = &v26;
      uint64_t v28 = 0x2000000000;
      char v29 = 1;
      CFTypeRef v10 = sub_10011C8B0(ValueAtIndex, (uint64_t)&stru_1002FB4C0, (uint64_t)v20, 0);
      if (!v10) {
        break;
      }
      BOOL v11 = v10;
      *(void *)&long long buf = _NSConcreteStackBlock;
      *((void *)&buf + 1) = 0x40000000;
      uint64_t v31 = sub_100133BEC;
      uint64_t v32 = &unk_1002FB510;
      uint64_t v37 = ValueAtIndex;
      uint64_t v38 = v9 + 24;
      uint64_t v33 = v20;
      uint64_t v34 = 0;
      uint64_t v39 = a2;
      CFArrayRef v35 = v19;
      __int16 v36 = &v26;
      char v12 = sub_10002742C(a2, (uint64_t)v10, (CFTypeRef *)(v9 + 24), (uint64_t)&buf);
      if (*((unsigned char *)v27 + 24)) {
        char v13 = v12;
      }
      else {
        char v13 = 0;
      }
      *((unsigned char *)v27 + 24) = v13;
      CFRelease(v11);
      int v14 = *((unsigned __int8 *)v27 + 24);
      _Block_object_dispose(&v26, 8);
      if (!v14) {
        goto LABEL_13;
      }
      BOOL v6 = ++v7 >= v5;
      if (v5 == v7) {
        goto LABEL_11;
      }
    }
    *((unsigned char *)v27 + 24) = 0;
    _Block_object_dispose(&v26, 8);
LABEL_13:
    uint64_t v15 = sub_10000B070("SecError");
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      LODWORD(buf) = 138412290;
      *(void *)((char *)&buf + 4) = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "SecDbItemSelectSHA1 failed: %@", (uint8_t *)&buf, 0xCu);
    }
  }
  int v17 = v22;
  free((void *)v22[3]);
  v17[3] = 0;
  void v17[4] = 0;
  *((unsigned char *)v17 + 4_Block_object_dispose(&STACK[0x3F0], 8) = 0;
  v17[5] = 0;
  _Block_object_dispose(&v21, 8);
  return v6;
}

BOOL sub_100133AC4(uint64_t a1, const void **a2)
{
  return CFDictionaryContainsKey(*(CFDictionaryRef *)(*(void *)(a1 + 32) + 8), *a2) != 0;
}

void sub_100133AF0(uint64_t a1, sqlite3_stmt *a2)
{
  uint64_t v4 = (long long *)sqlite3_column_blob(a2, 0);
  int v5 = sqlite3_column_bytes(a2, 0);
  if (v5 == 20)
  {
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
    sub_100200054((char **)(v6 + 24), v4);
    *(unsigned char *)(v6 + 4_Block_object_dispose(&STACK[0x3F0], 8) = 1;
  }
  else
  {
    int v7 = v5;
    CFTypeRef v8 = sub_10000B070("SecError");
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = 134217984;
      uint64_t v10 = v7;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "digest %zu bytes", (uint8_t *)&v9, 0xCu);
    }
  }
}

uint64_t sub_100133BEC(uint64_t a1, sqlite3_stmt *a2)
{
  uint64_t result = sub_10011CC14(*(CFDictionaryRef **)(a1 + 64), a2, *(__CFString ***)(a1 + 72), *(void *)(a1 + 32), *(void *)(a1 + 40));
  if (result)
  {
    uint64_t v6 = *(CFTypeRef **)(a1 + 72);
    uint64_t v5 = *(void *)(a1 + 80);
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 0x40000000;
    v7[2] = sub_100133C94;
    v7[3] = &unk_1002FB4E8;
    void v7[4] = *(void *)(a1 + 48);
    void v7[5] = a2;
    uint64_t result = sub_1000275B0(v5, a2, v6, (uint64_t)v7);
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = result;
  return result;
}

uint64_t sub_100133C94(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, void, uint64_t))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40), a2);
}

BOOL sub_100133CAC(id a1, const SecDbAttr *a2)
{
  return a2->var1 == 7;
}

uint64_t sub_100133CBC(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

__CFString **sub_100133CD4(__CFArray *a1, uint64_t a2, int a3, BOOL a4, const __CFData *a5, __CFString **a6)
{
  BOOL v11 = (__CFString **)sub_10000C7F0(a2, 0, 0, 0, a6);
  char v12 = v11;
  if (v11)
  {
    *((_DWORD *)v11 + 12) = 3;
    v11[13] = (__CFString *)-1;
    *((_DWORD *)v11 + 30) = dword_10035D2B0;
    sub_10000DF34(kSecAttrSynchronizable, kCFBooleanTrue, (uint64_t)v11);
    sub_100129340(kSecAttrAccessible, (const __CFData *)kSecAttrAccessibleWhenUnlocked, (uint64_t)v12);
    sub_100129340(kSecAttrAccessible, (const __CFData *)kSecAttrAccessibleAfterFirstUnlock, (uint64_t)v12);
    sub_100129340(kSecAttrAccessible, kSecAttrAccessibleAlwaysPrivate, (uint64_t)v12);
    sub_100129340(kSecAttrAccessible, (const __CFData *)kSecAttrAccessibleWhenUnlockedThisDeviceOnly, (uint64_t)v12);
    sub_100129340(kSecAttrAccessible, (const __CFData *)kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly, (uint64_t)v12);
    sub_100129340(kSecAttrAccessible, kSecAttrAccessibleAlwaysThisDeviceOnlyPrivate, (uint64_t)v12);
    if (a3) {
      sub_10000DF34(kSecAttrTombstone, kCFBooleanFalse, (uint64_t)v12);
    }
    CFArrayAppendValue(a1, v12);
    char v13 = *(__CFString ***)(a2 + 16);
    if (v13)
    {
      int v14 = (__CFString ***)(a2 + 24);
      do
      {
        BOOL v15 = v13 != &off_100305768;
        if (v13 == &off_1002FC0A8) {
          BOOL v15 = a4;
        }
        if (!v15)
        {
          if (a5 && v13 == &off_100305768)
          {
            sub_10000E0A8(&off_100305768, a5, (uint64_t)v12);
          }
          else
          {
            CFDataRef v16 = sub_1001189E0((uint64_t)v13, v12 + 5);
            if (v16)
            {
              CFDataRef v17 = v16;
              sub_10000E0A8(v13, v16, (uint64_t)v12);
              CFRelease(v17);
            }
          }
        }
        uint64_t v18 = *v14++;
        char v13 = v18;
      }
      while (v18);
    }
  }
  return v12;
}

__CFString **sub_100133ED8(__CFArray *a1, uint64_t a2, int a3, const __CFBoolean *a4, __CFString **a5)
{
  uint64_t v6 = sub_100133CD4(a1, a2, a3, 1, 0, a5);
  int v7 = v6;
  if (a4 && v6) {
    sub_10000DF34(kSecAttrAccessGroup, a4, (uint64_t)v6);
  }
  return v7;
}

void sub_100133F30(id a1)
{
  qword_10035CF98[0] = sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008);
  qword_10035CFA0 = sub_10000C75C(@"inet", &qword_10035D020, (uint64_t)&unk_10035D018);
  qword_10035CFA8 = sub_10000C75C(@"keys", &qword_10035D040, (uint64_t)&unk_10035D038);
}

void sub_100133FB4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 152);
  v3[0] = _NSConcreteStackBlock;
  v3[1] = 0x40000000;
  v3[2] = sub_100134028;
  v3[3] = &unk_1002FB368;
  void v3[4] = a2;
  void v3[5] = a1;
  sub_100026884(v2, v3);
}

uint64_t sub_100134028(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return (*(uint64_t (**)(void, void, uint64_t, uint64_t, uint64_t, uint64_t))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40), a2, a3, a4, a5);
}

uint64_t sub_10013404C(uint64_t a1)
{
  return *(void *)(a1 + 160);
}

uint64_t sub_100134054(uint64_t a1)
{
  if (qword_10035CF88 != -1) {
    dispatch_once(&qword_10035CF88, &stru_1002FB2F0);
  }
  uint64_t v5 = 0;
  uint64_t v6 = &v5;
  uint64_t v7 = 0x2000000000;
  uint64_t v8 = 0;
  v4[0] = _NSConcreteStackBlock;
  v4[1] = 0x40000000;
  v4[2] = sub_10013412C;
  v4[3] = &unk_1002FB318;
  void v4[4] = &v5;
  void v4[5] = a1;
  dispatch_sync((dispatch_queue_t)qword_10035CF78, v4);
  uint64_t v2 = v6[3];
  _Block_object_dispose(&v5, 8);
  return v2;
}

void sub_10013412C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  if (v1)
  {
    uint64_t v2 = *(const void **)(v1 + 16);
    if (v2)
    {
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CFDictionaryGetValue((CFDictionaryRef)qword_10035CF80, *(const void **)(v1 + 16));
      if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
      {
        uint64_t v4 = *(const void **)(a1 + 40);
        uint64_t v5 = malloc_type_calloc(1uLL, 0x30uLL, 0xA0040C7E57C1AuLL);
        *uint64_t v5 = sub_1001349D8;
        v5[1] = sub_100134368;
        _DWORD v5[2] = nullsub_26;
        v5[3] = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, 0);
        void v5[4] = dispatch_queue_create("dsf queue", 0);
        if (v4) {
          CFRetain(v4);
        }
        void v5[5] = v4;
        uint64_t v6 = (const void *)((uint64_t (*)(void *))*v5)(v5);
        CFTypeRef cf = 0;
        uint64_t v7 = ((uint64_t (*)(void *, const void *, CFTypeRef *))v5[1])(v5, v6, &cf);
        if (!v7)
        {
          uint64_t v8 = sub_10000B070("SecError");
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138412546;
            char v13 = v6;
            __int16 v14 = 2112;
            CFTypeRef v15 = cf;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "create_datasource %@ failed %@", buf, 0x16u);
          }
        }
        CFTypeRef v9 = cf;
        if (cf)
        {
          CFTypeRef cf = 0;
          CFRelease(v9);
        }
        if (v7) {
          (*(void (**)(uint64_t, CFTypeRef *))(v7 + 72))(v7, &cf);
        }
        CFTypeRef v10 = cf;
        if (cf)
        {
          CFTypeRef cf = 0;
          CFRelease(v10);
        }
        if (v6) {
          CFRelease(v6);
        }
        *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v5;
        CFDictionaryAddValue((CFMutableDictionaryRef)qword_10035CF80, v2, *(const void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
      }
    }
  }
}

uint64_t sub_100134368(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = 0;
  uint64_t v8 = &v7;
  uint64_t v9 = 0x2000000000;
  uint64_t v10 = 0;
  uint64_t v3 = *(NSObject **)(a1 + 32);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  _DWORD v6[2] = sub_100134418;
  v6[3] = &unk_1002FB818;
  void v6[4] = &v7;
  void v6[5] = a1;
  void v6[6] = a2;
  void v6[7] = a3;
  dispatch_sync(v3, v6);
  uint64_t v4 = v8[3];
  _Block_object_dispose(&v7, 8);
  return v4;
}

void sub_100134418(uint64_t a1)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = CFDictionaryGetValue(*(CFDictionaryRef *)(*(void *)(a1 + 40) + 24), *(const void **)(a1 + 48));
  if (!*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    uint64_t v2 = *(const void **)(*(void *)(a1 + 40) + 40);
    if (v2)
    {
      uint64_t v3 = *(const void **)(a1 + 48);
      uint64_t v4 = malloc_type_calloc(1uLL, 0xA8uLL, 0xE00405186C4AEuLL);
      v4[1] = sub_10013404C;
      v4[2] = sub_100133FB4;
      v4[3] = sub_100132F50;
      void v4[5] = sub_100132AA0;
      void v4[6] = sub_1001326C0;
      void v4[4] = sub_100131ECC;
      void v4[8] = sub_100131CA0;
      v4[10] = sub_100131B50;
      v4[9] = sub_100131B48;
      void v4[11] = sub_100130654;
      v4[12] = sub_100131928;
      void v4[7] = sub_1001317CC;
      v4[13] = sub_100131698;
      v4[14] = sub_100131640;
      v4[15] = sub_1001315E0;
      uint8_t v4[16] = sub_100131524;
      v4[17] = sub_100131370;
      void v4[18] = sub_1001310B4;
      CFRetain(v2);
      v4[19] = v2;
      if (v3) {
        CFRetain(v3);
      }
      v4[20] = v3;
      if (-[OTSOSActualAdapter sosEnabled]_0())
      {
        *(void *)&long long buf = _NSConcreteStackBlock;
        *((void *)&buf + 1) = 3221225472;
        uint64_t v27 = sub_1000FBC38;
        uint64_t v28 = &unk_1003093A8;
        char v29 = &qword_10035CE88;
        if (qword_10035CE80 != -1) {
          dispatch_once(&qword_10035CE80, &buf);
        }
        uint64_t Instance = _CFRuntimeCreateInstance();
        *(void *)(Instance + 16) = v4;
        dispatch_queue_t v6 = dispatch_queue_create("engine", 0);
        uint64_t v7 = *(void **)(Instance + 112);
        *(void *)(Instance + 112) = v6;

        *(void *)(Instance + 56) = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        *(void *)(Instance + 64) = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        *(void *)(Instance + 72) = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        uint64_t v8 = *(void **)(Instance + 136);
        *(void *)(Instance + 136) = 0;

        *(void *)(Instance + 96) = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
        *(_WORD *)(Instance + 104) = 0;
        CFTypeRef cf = 0;
        if ((sub_1000FE1B0(Instance, 0, &cf) & 1) == 0)
        {
          uint64_t v9 = sub_10000B070("SecWarning");
          if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
          {
            LODWORD(buf) = 138412290;
            *(void *)((char *)&buf + 4) = cf;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "engine failed load state starting with nothing %@", (uint8_t *)&buf, 0xCu);
          }

          CFTypeRef v10 = cf;
          if (cf)
          {
            CFTypeRef cf = 0;
            CFRelease(v10);
          }
          BOOL v11 = sub_10000B070("engine");
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v12 = (*(uint64_t (**)(void))(*(void *)(Instance + 16) + 8))();
            LODWORD(buf) = 138412290;
            *(void *)((char *)&buf + 4) = v12;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "new engine for datasource named %@", (uint8_t *)&buf, 0xCu);
          }

          CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          __int16 v14 = *(const void **)(Instance + 56);
          if (v14) {
            CFRelease(v14);
          }
          *(void *)(Instance + 56) = Mutable;
          CFMutableDictionaryRef v15 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          CFDataRef v16 = *(const void **)(Instance + 64);
          if (v16) {
            CFRelease(v16);
          }
          *(void *)(Instance + 64) = v15;
          CFMutableDictionaryRef v17 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
          uint64_t v18 = *(const void **)(Instance + 72);
          if (v18) {
            CFRelease(v18);
          }
          *(void *)(Instance + 72) = v17;
          uint64_t v19 = *(const void **)(Instance + 48);
          if (v19)
          {
            *(void *)(Instance + 4_Block_object_dispose(&STACK[0x3F0], 8) = 0;
            CFRelease(v19);
          }
          uint64_t v20 = *(const void **)(Instance + 80);
          if (v20)
          {
            *(void *)(Instance + 80) = 0;
            CFRelease(v20);
          }
          sub_1000FEBD8(Instance, 0, 0, 0);
        }
        uint64_t v21 = *(void *)(Instance + 16);
        *(void *)&long long buf = _NSConcreteStackBlock;
        *((void *)&buf + 1) = 3221225472;
        uint64_t v27 = sub_100100588;
        uint64_t v28 = &unk_1002FA490;
        char v29 = (uint64_t *)Instance;
        (*(void (**)(void))(v21 + 16))();
        *uint64_t v4 = Instance;
      }
      else
      {
        SOSCCSetSOSDisabledError();
        free(v4);
        uint64_t v4 = 0;
      }
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v4;
      uint64_t v22 = *(__CFDictionary **)(*(void *)(a1 + 40) + 24);
      uint64_t v23 = *(const void **)(a1 + 48);
      long long v24 = *(const void **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      CFDictionarySetValue(v22, v23, v24);
    }
  }
}

CFStringRef sub_1001349D8()
{
  return kSecAttrAccessibleWhenUnlocked;
}

void sub_1001349E8(id a1)
{
  qword_10035CF78 = (uint64_t)dispatch_queue_create("dataSourceFactory queue", 0);
  qword_10035CF80 = (uint64_t)CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, 0);
}

uint64_t sub_100134A3C(const __CFDictionary *a1, CFTypeRef *a2)
{
  uint64_t v3 = &v8;
  uint64_t v8 = 0;
  uint64_t v9 = &v8;
  uint64_t v10 = 0x3800000000;
  long long v11 = 0u;
  long long v12 = 0u;
  if (a1)
  {
    v7[0] = _NSConcreteStackBlock;
    v7[1] = 0x40000000;
    v7[2] = sub_100134B20;
    v7[3] = &unk_1002FB340;
    void v7[4] = &v8;
    CFDictionaryApplyFunction(a1, (CFDictionaryApplierFunction)sub_100131508, v7);
    uint64_t v3 = v9;
  }
  uint64_t v4 = sub_100201498((uint64_t)(v3 + 3), a2);
  uint64_t v5 = v9;
  free((void *)v9[3]);
  v5[3] = 0;
  void v5[4] = 0;
  *((unsigned char *)v5 + 4_Block_object_dispose(&STACK[0x3F0], 8) = 0;
  void v5[5] = 0;
  _Block_object_dispose(&v8, 8);
  return v4;
}

void sub_100134B20(uint64_t a1, int a2, CFTypeRef cf)
{
  if (cf)
  {
    CFTypeID v5 = CFGetTypeID(cf);
    if (v5 == CFDictionaryGetTypeID())
    {
      CFDataRef Value = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)cf, @"hash");
      if (Value)
      {
        CFDataRef v7 = Value;
        CFTypeID v8 = CFGetTypeID(Value);
        if (v8 == CFDataGetTypeID() && CFDataGetLength(v7) == 20)
        {
          uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 8);
          BytePtr = (long long *)CFDataGetBytePtr(v7);
          sub_100200054((char **)(v9 + 24), BytePtr);
          *(unsigned char *)(v9 + 4_Block_object_dispose(&STACK[0x3F0], 8) = 1;
        }
      }
    }
  }
}

void sub_100134C84(id a1, OTAuthKitAdapterNotifier *a2)
{
}

void sub_100135164(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    CFDataRef v7 = +[CKKSAnalytics logger];
    [v7 logUnrecoverableError:v6 forEvent:@"OctagonEventAuthKitDeviceList" withAttributes:0];

    id v8 = objc_alloc((Class)AAFAnalyticsEventSecurity);
    LOBYTE(v50) = 1;
    id v9 = [v8 initWithKeychainCircleMetrics:&__NSDictionary0__struct altDSID:a1[4] flowID:a1[5] deviceSessionID:a1[6] eventName:kSecurityRTCEventNameTrustedDeviceListFailure testsAreEnabled:0 canSendMetrics:v50 category:kSecurityRTCEventCategoryAccountDataAccessRecovery];
    +[SecurityAnalyticsReporterRTC sendMetricWithEvent:v9 success:0 error:v6];
    uint64_t v10 = sub_10000B070("authkit");
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      long long v11 = (void *)a1[4];
      *(_DWORD *)long long buf = 138412546;
      id v67 = v11;
      __int16 v68 = 2112;
      id v69 = v6;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "received no device list(%@): %@", buf, 0x16u);
    }

    (*(void (**)(void, void))(a1[7] + 16))(a1[7], 0);
    goto LABEL_5;
  }
  uint64_t v55 = a1;
  if (!v5)
  {
    id v9 = +[NSError errorWithDomain:@"com.apple.security.octagon" code:68 description:@"bad response from AuthKit"];
    (*(void (**)(void, void))(a1[7] + 16))(a1[7], 0);
    uint64_t v46 = +[CKKSAnalytics logger];
    [v46 logUnrecoverableError:v9 forEvent:@"OctagonEventAuthKitDeviceList" withAttributes:0];

LABEL_5:
    goto LABEL_47;
  }
  __int16 v57 = +[NSMutableSet set];
  uint64_t v52 = +[NSMutableSet set];
  uint64_t v53 = +[NSMutableSet set];
  uint64_t v54 = +[NSMutableSet set];
  uint64_t v56 = [v5 deviceListVersion];
  long long v62 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  uint64_t v51 = v5;
  long long v12 = [v5 deviceList];
  id v13 = [v12 countByEnumeratingWithState:&v62 objects:v75 count:16];
  if (v13)
  {
    id v14 = v13;
    uint64_t v15 = *(void *)v63;
    do
    {
      for (uint64_t i = 0; i != v14; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v63 != v15) {
          objc_enumerationMutation(v12);
        }
        CFMutableDictionaryRef v17 = *(void **)(*((void *)&v62 + 1) + 8 * i);
        uint64_t v18 = [v17 machineId];
        [v57 addObject:v18];

        uint64_t v19 = sub_10000B070("authkit");
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v20 = (void *)v55[4];
          uint64_t v21 = [v17 machineId];
          *(_DWORD *)long long buf = 138412802;
          id v67 = v20;
          __int16 v68 = 2112;
          id v69 = v56;
          __int16 v70 = 2112;
          uint64_t v71 = v21;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Current machine ID on list for (%@) version %@: %@", buf, 0x20u);
        }
      }
      id v14 = [v12 countByEnumeratingWithState:&v62 objects:v75 count:16];
    }
    while (v14);
  }

  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  uint64_t v22 = [v5 deletedDeviceList];
  id v23 = [v22 countByEnumeratingWithState:&v58 objects:v74 count:16];
  long long v24 = v55;
  long long v25 = (void *)v52;
  if (v23)
  {
    id v26 = v23;
    uint64_t v27 = *(void *)v59;
    do
    {
      for (uint64_t j = 0; j != v26; uint64_t j = (char *)j + 1)
      {
        if (*(void *)v59 != v27) {
          objc_enumerationMutation(v22);
        }
        char v29 = *(void **)(*((void *)&v58 + 1) + 8 * (void)j);
        id v30 = [v29 removalReason];
        if (!v30)
        {
          uint64_t v39 = [v29 machineId];
          [v54 addObject:v39];

          uint64_t v32 = sub_10000B070("authkit");
          if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_34;
          }
          uint64_t v40 = (void *)v24[4];
          uint64_t v34 = [v29 machineId];
          *(_DWORD *)long long buf = 138412802;
          id v67 = v40;
          __int16 v68 = 2112;
          id v69 = v56;
          __int16 v70 = 2112;
          uint64_t v71 = v34;
          CFArrayRef v35 = v32;
          __int16 v36 = "Device evicted for unknown reason for (%@) version %@: %@";
          goto LABEL_30;
        }
        if (v30 == (id)2)
        {
          uint64_t v37 = [v29 machineId];
          [v53 addObject:v37];

          uint64_t v32 = sub_10000B070("authkit");
          if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_34;
          }
          uint64_t v38 = (void *)v24[4];
          uint64_t v34 = [v29 machineId];
          *(_DWORD *)long long buf = 138412802;
          id v67 = v38;
          __int16 v68 = 2112;
          id v69 = v56;
          __int16 v70 = 2112;
          uint64_t v71 = v34;
          CFArrayRef v35 = v32;
          __int16 v36 = "Device evicted due to limit for (%@) version %@: %@";
          goto LABEL_30;
        }
        if (v30 == (id)1)
        {
          uint64_t v31 = [v29 machineId];
          [v25 addObject:v31];

          uint64_t v32 = sub_10000B070("authkit");
          if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_34;
          }
          uint64_t v33 = (void *)v24[4];
          uint64_t v34 = [v29 machineId];
          *(_DWORD *)long long buf = 138412802;
          id v67 = v33;
          __int16 v68 = 2112;
          id v69 = v56;
          __int16 v70 = 2112;
          uint64_t v71 = v34;
          CFArrayRef v35 = v32;
          __int16 v36 = "User initiated removed machine ID for (%@) version %@: %@";
LABEL_30:
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, v36, buf, 0x20u);

          goto LABEL_34;
        }
        uint64_t v41 = sub_10000B070("SecError");
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          id v42 = [v29 removalReason];
          uint64_t v43 = (void *)v55[4];
          uint64_t v44 = [v29 machineId];
          *(_DWORD *)long long buf = 134218754;
          id v67 = v42;
          long long v25 = (void *)v52;
          __int16 v68 = 2112;
          id v69 = v43;
          long long v24 = v55;
          __int16 v70 = 2112;
          uint64_t v71 = v56;
          __int16 v72 = 2112;
          CFDataRef v73 = v44;
          _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "authkit: super shrug here. Device is in the deletedDeviceList but has an undefined removal reason (%ld) for (%@) version %@: %@", buf, 0x2Au);
        }
        uint64_t v32 = [v29 machineId];
        [v54 addObject:v32];
LABEL_34:
      }
      id v26 = [v22 countByEnumeratingWithState:&v58 objects:v74 count:16];
    }
    while (v26);
  }

  id v5 = v51;
  if (objc_opt_respondsToSelector())
  {
    uint64_t v45 = [v51 trustedDeviceHash];
  }
  else
  {
    uint64_t v45 = &stru_10030AA90;
  }
  if (objc_opt_respondsToSelector())
  {
    uint64_t v47 = [v51 deletedDeviceHash];
  }
  else
  {
    uint64_t v47 = &stru_10030AA90;
  }
  if (objc_opt_respondsToSelector())
  {
    int v48 = [v51 trustedDevicesUpdateTimestamp];
  }
  else
  {
    int v48 = 0;
  }
  (*(void (**)(void, void *))(v24[7] + 16))(v24[7], v57);
  uint64_t v49 = +[CKKSAnalytics logger];
  [v49 logSuccessForEventNamed:@"OctagonEventAuthKitDeviceList"];

  id v6 = 0;
LABEL_47:
}

void sub_100138160(id a1)
{
  uint64_t v2 = objc_opt_new();
  uint64_t v3 = (void *)qword_10035CFE8;
  qword_10035CFE8 = v2;

  id v4 = [objc_alloc((Class)NSXPCListener) initWithMachServiceName:@"com.apple.security.octagon"];
  id v5 = (void *)qword_10035CFF0;
  qword_10035CFF0 = (uint64_t)v4;

  [(id)qword_10035CFF0 setDelegate:qword_10035CFE8];
  [(id)qword_10035CFF0 resume];
}

BOOL sub_1001381F8(uint64_t a1, uint64_t a2, CFTypeRef *a3, uint64_t a4)
{
  v7[0] = 0;
  v7[1] = v7;
  v7[2] = 0x2000000000;
  char v8 = 1;
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 0x40000000;
  _DWORD v6[2] = sub_10013829C;
  v6[3] = &unk_1002FB8C8;
  void v6[4] = a4;
  void v6[5] = v7;
  BOOL v4 = sub_100027B34(a1, a2, a3, (uint64_t)v6);
  _Block_object_dispose(v7, 8);
  return v4;
}

uint64_t sub_10013829C(uint64_t a1, unsigned char *a2)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  *a2 = result;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = result;
  return result;
}

uint64_t sub_1001382E0(uint64_t a1, unsigned int *a2, const __CFArray *a3, int a4, uint64_t a5)
{
  uint64_t v19 = 0;
  uint64_t v20 = &v19;
  uint64_t v21 = 0x2000000000;
  char v22 = 1;
  CFMutableStringRef Mutable = CFStringCreateMutable(kCFAllocatorDefault, 0);
  long long v11 = Mutable;
  if (a3)
  {
    context[0] = _NSConcreteStackBlock;
    context[1] = 0x40000000;
    context[2] = sub_1001384D8;
    context[3] = &unk_1002FB8E8;
    void context[4] = a2;
    void context[5] = Mutable;
    v24.size_t length = CFArrayGetCount(a3);
    v24.id location = 0;
    CFArrayApplyFunction(a3, v24, (CFArrayApplierFunction)sub_10013879C, context);
  }
  else
  {
    long long v12 = (uint64_t *)*((void *)a2 + 1);
    if (v12)
    {
      id v13 = (uint64_t **)(a2 + 4);
      do
      {
        sub_1001384EC(v11, v12);
        id v14 = *v13++;
        long long v12 = v14;
      }
      while (v14);
    }
  }
  if (a4) {
    CFStringAppendFormat(v11, 0, @"INSERT INTO tversion(version,minor) VALUES(%d, %d);", *a2, a2[1]);
  }
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 0x40000000;
  v17[2] = sub_100138734;
  v17[3] = &unk_1002FB910;
  void v17[4] = &v19;
  v17[5] = a1;
  v17[6] = a5;
  v23[0] = _NSConcreteStackBlock;
  v23[1] = 0x40000000;
  _OWORD v23[2] = sub_10000B880;
  v23[3] = &unk_1002F7408;
  void v23[4] = v17;
  sub_10000EB80(v11, (uint64_t)v23);
  if (v11) {
    CFRelease(v11);
  }
  uint64_t v15 = *((unsigned __int8 *)v20 + 24);
  _Block_object_dispose(&v19, 8);
  return v15;
}

void sub_1001384D8(uint64_t a1, int a2)
{
}

void sub_1001384EC(__CFString *a1, uint64_t *a2)
{
  CFStringAppendFormat(a1, 0, @"CREATE TABLE %@("), *a2;
  uint64_t v4 = a2[2];
  if (!v4) {
    goto LABEL_26;
  }
  id v5 = a2 + 3;
  do
  {
    if ((*(unsigned char *)(v4 + 16) & 2) == 0) {
      goto LABEL_11;
    }
    unsigned int v6 = *(_DWORD *)(v4 + 8) - 2;
    CFStringRef v7 = @"BLOB";
    if (v6 <= 0xD) {
      CFStringRef v7 = off_1002FBE58[v6];
    }
    CFStringAppendFormat(a1, 0, @"%@ %@", *(void *)v4, v7);
    uint64_t v8 = *(void *)(v4 + 16);
    if ((v8 & 0x1000) != 0)
    {
      CFStringAppend(a1, @" NOT NULL");
      uint64_t v8 = *(void *)(v4 + 16);
      if ((v8 & 0x400) != 0)
      {
LABEL_14:
        CFStringAppend(a1, @" DEFAULT 0");
        if ((*(void *)(v4 + 16) & 0x800) == 0) {
          goto LABEL_10;
        }
LABEL_9:
        CFStringAppend(a1, @" DEFAULT ''");
        goto LABEL_10;
      }
    }
    else if ((v8 & 0x400) != 0)
    {
      goto LABEL_14;
    }
    if ((v8 & 0x800) != 0) {
      goto LABEL_9;
    }
LABEL_10:
    CFStringAppend(a1, @",");
LABEL_11:
    uint64_t v9 = *v5++;
    uint64_t v4 = v9;
  }
  while (v9);
  uint64_t v10 = a2[2];
  if (v10)
  {
    char v11 = 0;
    long long v12 = a2 + 3;
    do
    {
      if ((~*(_DWORD *)(v10 + 16) & 3) == 0)
      {
        CFStringRef v13 = *(const __CFString **)v10;
        if (v11) {
          CFStringRef v14 = @",";
        }
        else {
          CFStringRef v14 = CFSTR("UNIQUE(");
        }
        char v11 = 1;
        CFStringAppend(a1, v14);
        CFStringAppend(a1, v13);
      }
      uint64_t v15 = *v12++;
      uint64_t v10 = v15;
    }
    while (v15);
    if (v11) {
      CFStringAppend(a1, @""));
    }
  }
LABEL_26:
  CFStringAppend(a1, @";"));
  CFDataRef v16 = (uint64_t *)a2[2];
  if (v16)
  {
    uint64_t v17 = 3;
    do
    {
      if ((~*((_DWORD *)v16 + 4) & 6) == 0)
      {
        int v18 = *((_DWORD *)v16 + 2);
        uint64_t v19 = *a2;
        uint64_t v20 = *v16;
        if (v18 == 11) {
          CFStringAppendFormat(a1, 0, @"CREATE INDEX %@%@0 ON %@(%@) WHERE %@=0;", v19, v20, v19, v20, v20);
        }
        else {
          CFStringAppendFormat(a1, 0, @"CREATE INDEX %@%@ ON %@(%@);", v19, v20, *a2, v20, v21);
        }
      }
      CFDataRef v16 = (uint64_t *)a2[v17++];
    }
    while (v16);
  }
}

BOOL sub_100138734(uint64_t a1, const char *a2)
{
  uint64_t v4 = sqlite3_exec(*(sqlite3 **)(*(void *)(a1 + 40) + 64), a2, 0, 0, 0);
  BOOL result = sub_10002641C(v4, *(sqlite3 **)(*(void *)(a1 + 40) + 64), *(CFTypeRef **)(a1 + 48), @"sqlite3_exec: %s", a2);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

uint64_t sub_10013879C(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

CFDataRef sub_1001387B4(uint64_t a1, int a2, __CFString **a3)
{
  if (a2 == 8)
  {
    sub_10011B60C((void **)a1, a3);
    return (CFDataRef)_SecItemCreateUUIDBasedPersistentRef();
  }
  else
  {
    char v5 = a2;
    if (a2 != 1)
    {
      if (!a2) {
        return kCFNull;
      }
      CFAllocatorRef v9 = CFGetAllocator((CFTypeRef)a1);
      CFMutableStringRef Mutable = CFDictionaryCreateMutable(v9, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      unsigned int v6 = Mutable;
      if ((v5 & 4) != 0) {
        CFDictionarySetValue(Mutable, kSecClass, **(const void ***)(a1 + 16));
      }
      uint64_t v11 = *(void *)(a1 + 16);
      uint64_t v12 = *(void *)(v11 + 16);
      if (v12)
      {
        CFStringRef v13 = (uint64_t *)(v11 + 24);
        do
        {
          if ((*(void *)(v12 + 16) & ((16 * ((v5 & 6) != 0)) | (32 * ((v5 & 5) != 0)))) != 0)
          {
            CFStringRef v14 = sub_100118CF8((const void *)a1, v12, a3);
            if (!v14)
            {
              if (v6)
              {
                CFRelease(v6);
                unsigned int v6 = 0;
              }
              break;
            }
            uint64_t v15 = v14;
            if (!CFEqual(kCFNull, v14)) {
              CFDictionarySetValue(v6, *(const void **)v12, v15);
            }
          }
          uint64_t v16 = *v13++;
          uint64_t v12 = v16;
        }
        while (v16);
      }
      CFDictionaryRemoveValue(v6, kSecAttrUUID);
      if ((v5 & 8) != 0)
      {
        sub_10011B60C((void **)a1, a3);
        uint64_t UUIDBasedPersistentRef = (const void *)_SecItemCreateUUIDBasedPersistentRef();
        CFDictionarySetValue(v6, kSecValuePersistentRef, UUIDBasedPersistentRef);
        if (UUIDBasedPersistentRef) {
          CFRelease(UUIDBasedPersistentRef);
        }
      }
      return v6;
    }
    uint64_t v8 = (__CFDictionary *)sub_100119CB8((void *)a1, kSecValueData);
    if (v8)
    {
      unsigned int v6 = v8;
      CFRetain(v8);
      return v6;
    }
    return CFDataCreate(kCFAllocatorDefault, 0, 0);
  }
}

uint64_t sub_100138A0C(uint64_t a1, uint64_t a2, CFDataRef *a3, __CFString **a4)
{
  if (*(void *)(a2 + 24) == *(void *)(a2 + 16) && !*(void *)(a2 + 88))
  {
    uint64_t v10 = (void **)sub_10011ACF4(*(void *)a2, *(const __CFDictionary **)(a2 + 8), dword_10035D2B0, a4);
    if (!v10) {
      return 0;
    }
    uint64_t v11 = v10;
    if (sub_10011BAEC(v10))
    {
      if (*(void *)(a2 + 96)) {
        CFDataRef v12 = *(const __CFData **)(a2 + 96);
      }
      else {
        CFDataRef v12 = kCFBooleanTrue;
      }
      sub_1001196B4((uint64_t)v11, &off_1002FC0D0, v12, 0);
    }
    CFDataRef v13 = *(const __CFData **)(a2 + 56);
    if (v13) {
      int v14 = sub_10011A9B8((uint64_t)v11, @"v_Data", v13, a4);
    }
    else {
      int v14 = 1;
    }
    uint64_t v15 = *(void *)(a2 + 72);
    if (v15) {
      int v14 = sub_10011B7D4(v11, v15, a4);
    }
    CFDataRef v16 = *(const __CFData **)(a2 + 80);
    if (v16) {
      int v14 = sub_10011B6B0((uint64_t)v11, v16, a4);
    }
    CFDataRef v17 = *(const __CFData **)(a2 + 128);
    if (v17) {
      int v14 = sub_10011A9B8((uint64_t)v11, @"musr", v17, a4);
    }
    sub_100119C6C((uint64_t)v11, *(CFTypeRef *)(a2 + 144));
    if (sub_1000B14D4())
    {
      sub_100138D94(v11, *(unsigned __int8 *)(a2 + 154), a4);
      if (*(void *)(a2 + 160))
      {
        int v18 = sub_100118CF8(v11, (uint64_t)&off_100305790, a4);
        if (v18)
        {
          sub_1000B19C4((uint64_t)v18, *(void **)(a2 + 160));
        }
        else
        {
          uint64_t v19 = sub_10000B070("SecError");
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Couldn't fetch UUID from item; can't call callback",
              buf,
              2u);
          }
        }
      }
    }
    if (v14)
    {
      char v20 = *(unsigned char *)(a2 + 154);
      *(void *)long long buf = _NSConcreteStackBlock;
      uint64_t v31 = 0x40000000;
      uint64_t v32 = sub_10011DDE8;
      uint64_t v33 = &unk_1002FA9B0;
      uint64_t v34 = v11;
      char v35 = v20;
      char v36 = 0;
      int v21 = sub_10011C214((uint64_t)v11, a1, a4, (uint64_t)buf);
      int v22 = v21;
      if (a3 && v21)
      {
        int v23 = *(_DWORD *)(a2 + 48);
        if (v23) {
          *a3 = sub_1001387B4((uint64_t)v11, v23, a4);
        }
        goto LABEL_50;
      }
    }
    else
    {
      int v22 = 0;
    }
    if (a4 && (v22 & 1) == 0 && *a4)
    {
      CFErrorDomain Domain = CFErrorGetDomain((CFErrorRef)*a4);
      if (CFEqual(Domain, @"com.apple.utilities.sqlite3") && CFErrorGetCode((CFErrorRef)*a4) == 19)
      {
        long long v25 = *a4;
        if (*a4)
        {
          *a4 = 0;
          CFRelease(v25);
        }
        sub_100012A40(-25299, a4, @"duplicate item %@", v11);
        goto LABEL_54;
      }
      CFErrorDomain v26 = CFErrorGetDomain((CFErrorRef)*a4);
      if (CFEqual(v26, kCFErrorDomainOSStatus))
      {
        if (CFErrorGetCode((CFErrorRef)*a4) == -26275)
        {
          uint64_t v27 = sub_100118974(v11[2], 14, a4);
          uint64_t v28 = sub_100118CF8(v11, v27, a4);
          if (v28)
          {
            if (CFEqual(v28, kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly))
            {
              char v29 = *a4;
              if (*a4)
              {
                *a4 = 0;
                CFRelease(v29);
              }
              sub_100012A40(-25293, a4, @"authentication failed");
              goto LABEL_54;
            }
          }
        }
      }
    }
    if (v22)
    {
LABEL_50:
      uint64_t v5 = 1;
      *(unsigned char *)(a2 + 113) = 1;
      if (sub_10011B964(v11)) {
        *(unsigned char *)(a2 + 114) = 1;
      }
      if (sub_10011B9C4(v11)) {
        *(unsigned char *)(a2 + 115) = 1;
      }
      goto LABEL_55;
    }
LABEL_54:
    uint64_t v5 = 0;
LABEL_55:
    CFRelease(v11);
    return v5;
  }
  return 1;
}

void sub_100138D94(void *a1, int a2, __CFString **a3)
{
  if (a1)
  {
    if (!a2) {
      goto LABEL_13;
    }
    uint64_t v5 = sub_1001259F4(a1, 1, a3);
    if (v5)
    {
      unsigned int v6 = v5;
      CFStringRef v7 = sub_100029CBC(v5);
      CFRelease(v6);
    }
    else
    {
      CFStringRef v7 = 0;
    }
    if (CFDataGetLength(v7) < 16)
    {
      CFDataRef v8 = 0;
      if (!v7) {
        goto LABEL_11;
      }
    }
    else
    {
      memset(buffer, 170, sizeof(buffer));
      v10.id location = 0;
      v10.size_t length = 16;
      CFDataGetBytes(v7, v10, buffer);
      CFDataRef v8 = CFUUIDCreateWithBytes(0, buffer[0], buffer[1], buffer[2], buffer[3], buffer[4], buffer[5], buffer[6], buffer[7], buffer[8], buffer[9], buffer[10], buffer[11], buffer[12], buffer[13], buffer[14], buffer[15]);
      if (!v7)
      {
LABEL_11:
        if (v8)
        {
          sub_10011A9B8((uint64_t)a1, kSecAttrUUID, v8, a3);
LABEL_14:
          CFRelease(v8);
          return;
        }
LABEL_13:
        CFDataRef v8 = CFUUIDCreate(0);
        sub_10011A9B8((uint64_t)a1, kSecAttrUUID, v8, a3);
        if (!v8) {
          return;
        }
        goto LABEL_14;
      }
    }
    CFRelease(v7);
    goto LABEL_11;
  }
}

BOOL sub_100138F00(uint64_t a1, const __CFArray *a2, uint64_t a3, __CFString **a4, uint64_t a5)
{
  uint64_t v17 = 0;
  int v18 = &v17;
  uint64_t v19 = 0x2000000000;
  char v20 = 1;
  if (*(void *)(a1 + 64))
  {
    BOOL v6 = sub_100012A40(-50, a4, @"value ref not supported by queries");
  }
  else
  {
    uint64_t v11 = sub_100010BE4(a1, a2);
    *((unsigned char *)v18 + 24) = v11 != 0;
    if (v11)
    {
      CFDataRef v12 = v11;
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 0x40000000;
      void v16[2] = sub_10013905C;
      v16[3] = &unk_1002FB9A0;
      v16[6] = &v17;
      v16[7] = a1;
      v16[8] = a2;
      void v16[9] = a4;
      v16[10] = a3;
      void v16[4] = &stru_1002FB950;
      void v16[5] = a5;
      char v13 = sub_10002742C(a3, (uint64_t)v11, (CFTypeRef *)a4, (uint64_t)v16);
      if (*((unsigned char *)v18 + 24)) {
        char v14 = v13;
      }
      else {
        char v14 = 0;
      }
      *((unsigned char *)v18 + 24) = v14;
      CFRelease(v12);
      BOOL v6 = *((unsigned char *)v18 + 24) != 0;
    }
    else
    {
      BOOL v6 = 0;
    }
  }
  _Block_object_dispose(&v17, 8);
  return v6;
}

uint64_t sub_10013905C(uint64_t result, sqlite3_stmt *a2)
{
  uint64_t v3 = result;
  int v18 = 1;
  if (**(__CFString ****)(result + 56) == &off_1002FFC58)
  {
    BOOL result = sub_100010978(a2, *(CFArrayRef *)(result + 64), &v18, *(CFTypeRef **)(result + 72));
    uint64_t v4 = *(void *)(*(void *)(v3 + 48) + 8);
    if (*(unsigned char *)(v4 + 24)) {
      char v5 = result;
    }
    else {
      char v5 = 0;
    }
    *(unsigned char *)(v4 + 24) = v5;
  }
  if (*(unsigned char *)(*(void *)(*(void *)(v3 + 48) + 8) + 24))
  {
    BOOL result = sub_10000E62C(a2, *(void *)(v3 + 56), *(const __CFArray **)(v3 + 64), &v18, *(CFTypeRef **)(v3 + 72));
    uint64_t v6 = *(void *)(*(void *)(v3 + 48) + 8);
    if (*(unsigned char *)(v6 + 24)) {
      char v7 = result;
    }
    else {
      char v7 = 0;
    }
    *(unsigned char *)(v6 + 24) = v7;
    if (*(unsigned char *)(*(void *)(*(void *)(v3 + 48) + 8) + 24))
    {
      CFAllocatorRef v9 = *(CFTypeRef **)(v3 + 72);
      uint64_t v8 = *(void *)(v3 + 80);
      v11[0] = _NSConcreteStackBlock;
      v11[1] = 0x40000000;
      void v11[2] = sub_100139188;
      v11[3] = &unk_1002FB978;
      uint64_t v10 = *(void *)(v3 + 64);
      uint64_t v13 = *(void *)(v3 + 56);
      char v14 = a2;
      uint64_t v15 = v9;
      uint64_t v16 = v8;
      uint64_t v17 = v10;
      long long v12 = *(_OWORD *)(v3 + 32);
      return sub_1000275B0(v8, a2, v9, (uint64_t)v11);
    }
  }
  return result;
}

void sub_100139188(uint64_t a1)
{
  uint64_t v2 = sub_10011B210(kCFAllocatorDefault, **(void ***)(a1 + 48), *(sqlite3_stmt **)(a1 + 56), *(_DWORD *)(*(void *)(a1 + 48) + 120), *(void *)(a1 + 32));
  if (v2)
  {
    uint64_t v3 = v2;
    uint64_t v4 = *(void *)(a1 + 48);
    uint64_t v5 = *(void *)(v4 + 144);
    *(void *)(v4 + 144) = 0;
    uint64_t v6 = *(const void **)(v2 + 56);
    if (v6) {
      CFRelease(v6);
    }
    *(void *)(v3 + 56) = v5;
    if (sub_100013CBC(*(void *)(a1 + 72), *(void *)(a1 + 48), *(void *)(a1 + 80), *(CFDictionaryRef *)(v3 + 48)))(*(void (**)(void))(*(void *)(a1 + 40) + 16))(); {
    CFRelease((CFTypeRef)v3);
    }
  }
  else
  {
    char v7 = sub_10000B070("SecError");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(const char ***)(a1 + 64);
      if (v8) {
        CFAllocatorRef v9 = *v8;
      }
      else {
        CFAllocatorRef v9 = "no error";
      }
      int v12 = 138412290;
      uint64_t v13 = v9;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "failed to create item from stmt: %@", (uint8_t *)&v12, 0xCu);
    }
    uint64_t v10 = *(const void ***)(a1 + 64);
    if (v10)
    {
      uint64_t v11 = *v10;
      if (*v10)
      {
        *uint64_t v10 = 0;
        CFRelease(v11);
      }
    }
  }
}

BOOL sub_100139318(id a1, const SecDbAttr *a2)
{
  int var1 = a2->var1;
  return (var1 & 0xFFFFFFFE) == 8 || var1 == 16;
}

BOOL sub_100139330(const void *a1, uint64_t a2)
{
  if (!a2) {
    return 0;
  }
  CFDictionaryRef v3 = (const __CFDictionary *)SecTokenItemValueCopy();
  if (!v3) {
    return 0;
  }
  CFDictionaryRef v4 = v3;
  CFDataRef Value = CFDictionaryGetValue(v3, @"oid");
  if (Value) {
    BOOL v6 = CFEqual(a1, Value) != 0;
  }
  else {
    BOOL v6 = a1 == 0;
  }
  CFRelease(v4);
  return v6;
}

void sub_1001393AC(void *key, void *value, CFMutableDictionaryRef theDict)
{
}

void sub_1001393C0(id a1)
{
  uint64_t v1 = sub_100029A10("ratelimiterdisabledlogevent", 1);
  qword_10035D000 = (uint64_t)v1;
  context = dispatch_get_context(v1);
  context[2] = _Block_copy(&stru_1002FBDF8);

  dispatch_activate(v1);
}

void sub_100139424(id a1)
{
  uint64_t v1 = sub_10000B070("SecError");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    v2[0] = 67109120;
    v2[1] = -25308;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "decode item failed, keychain is locked (%d)", (uint8_t *)v2, 8u);
  }
}

void sub_1001394C8(sqlite3_stmt *a1, uint64_t a2)
{
  CFDictionaryRef v4 = *(uint64_t ***)a2;
  sqlite3_int64 v5 = sqlite3_column_int64(a1, 0);
  CFDataRef v6 = sub_100013C54(a1, 1);
  char v7 = (const UInt8 *)sqlite3_column_blob(a1, 3);
  int v8 = sqlite3_column_bytes(a1, 3);
  CFDataRef v9 = CFDataCreate(kCFAllocatorDefault, v7, v8);
  if (!v9)
  {
    uint64_t UUIDBasedPersistentRef = 0;
    if (v6) {
      goto LABEL_8;
    }
LABEL_5:
    BOOL v12 = 0;
    uint64_t v13 = 0;
    BOOL v14 = UUIDBasedPersistentRef != 0;
    goto LABEL_13;
  }
  CFDataRef v10 = v9;
  if (CFDataGetLength(v9) == 16) {
    uint64_t UUIDBasedPersistentRef = (const void *)_SecItemCreateUUIDBasedPersistentRef();
  }
  else {
    uint64_t UUIDBasedPersistentRef = 0;
  }
  CFRelease(v10);
  if (!v6) {
    goto LABEL_5;
  }
LABEL_8:
  uint64_t v13 = sub_100029CBC(v6);
  BOOL v12 = v13 != 0;
  BOOL v14 = UUIDBasedPersistentRef != 0;
  if (v13 && UUIDBasedPersistentRef)
  {
    CFDictionaryRef v22 = sub_100139704(0, v15, v16, v17, v18, v19, v20, v21, (uint64_t)kSecValuePersistentRef, (uint64_t)UUIDBasedPersistentRef);
    if (v22)
    {
      CFDictionaryRef v23 = v22;
      CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 24), v22);
      CFRelease(v23);
    }
    ++*(_DWORD *)(a2 + 32);
    BOOL v14 = 1;
    goto LABEL_15;
  }
LABEL_13:
  CFRange v24 = sub_10000B070("item");
  if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
  {
    if (!v12) {
      goto LABEL_16;
    }
    goto LABEL_15;
  }
  uint64_t v25 = **v4;
  *(_DWORD *)long long buf = 134218242;
  sqlite3_int64 v27 = v5;
  __int16 v28 = 2112;
  uint64_t v29 = v25;
  _os_log_debug_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEBUG, "rowid %lu in %@ failed to create pref/digest", buf, 0x16u);
  if (v12) {
LABEL_15:
  }
    CFRelease(v13);
LABEL_16:
  if (v6)
  {
    CFRelease(v6);
    if (!v14) {
      return;
    }
    goto LABEL_18;
  }
  if (v14) {
LABEL_18:
  }
    CFRelease(UUIDBasedPersistentRef);
}

CFDictionaryRef sub_100139704(CFAllocatorRef allocator, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  CFDictionaryRef v22 = &a10;
  unint64_t v11 = 0;
  if (a9)
  {
    do
    {
      v11 += 2;
      BOOL v12 = v22;
      v22 += 2;
    }
    while (v12[1]);
  }
  unint64_t v13 = v11 >> 1;
  CFDictionaryRef v23 = (const void **)&a9;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(allocator, v11 >> 1, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (!Mutable) {
    return 0;
  }
  int v15 = Mutable;
  if (v11)
  {
    do
    {
      int v16 = v23;
      int v17 = *v23;
      v23 += 2;
      CFNullRef v18 = (const __CFNull *)v16[1];
      if (v18) {
        CFNullRef v19 = v18;
      }
      else {
        CFNullRef v19 = kCFNull;
      }
      CFDictionarySetValue(v15, v17, v19);
      --v13;
    }
    while (v13);
  }
  CFDictionaryRef Copy = CFDictionaryCreateCopy(allocator, v15);
  CFRelease(v15);
  return Copy;
}

void sub_1001397F8(CFDictionaryRef *a1)
{
  CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
  CFDataRef v3 = CFDateCreate(0, Current);
  uint64_t v4 = *((void *)*a1 + 2);
  if (v4)
  {
    sqlite3_int64 v5 = (uint64_t *)((char *)*a1 + 24);
    do
    {
      uint64_t v6 = *(void *)(v4 + 16);
      if ((v6 & 2) != 0)
      {
        if ((*(_DWORD *)(v4 + 8) - 5) > 1)
        {
          if ((v6 & 0x1000) == 0 || CFDictionaryContainsKey(a1[1], *(const void **)v4)) {
            goto LABEL_18;
          }
          uint64_t v7 = *(void *)(v4 + 16);
          if ((v7 & 0x400) != 0)
          {
            if (*(_DWORD *)(v4 + 8) == 4)
            {
              CFDateRef v9 = CFDateCreate(kCFAllocatorDefault, 0.0);
            }
            else
            {
              int valuePtr = 0;
              CFDateRef v9 = CFNumberCreate(0, kCFNumberSInt32Type, &valuePtr);
            }
          }
          else
          {
            if ((v7 & 0x800) == 0) {
              goto LABEL_18;
            }
            int v8 = *(_DWORD *)(v4 + 8);
            if (v8 != 16 && v8 != 1)
            {
              CFRetain(&stru_10030AA90);
              CFDataRef v10 = (const __CFData *)&stru_10030AA90;
LABEL_17:
              sub_10000E0A8((void *)v4, v10, (uint64_t)a1);
              CFRelease(v10);
              goto LABEL_18;
            }
            CFDateRef v9 = CFDataCreate(kCFAllocatorDefault, 0, 0);
          }
          CFDataRef v10 = v9;
          if (v9) {
            goto LABEL_17;
          }
        }
        else
        {
          sub_100139958((CFTypeRef *)v4, v3, (uint64_t)a1);
        }
      }
LABEL_18:
      uint64_t v11 = *v5++;
      uint64_t v4 = v11;
    }
    while (v11);
  }
  if (v3) {
    CFRelease(v3);
  }
}

void sub_100139958(CFTypeRef *a1, const __CFData *a2, uint64_t a3)
{
  if (CFDictionaryContainsKey(*(CFDictionaryRef *)(a3 + 8), *a1) && *(uint64_t *)(a3 + 32) >= 1)
  {
    uint64_t v6 = 0;
    uint64_t v7 = (CFTypeRef *)(a3 + 280);
    while (!CFEqual(*a1, *(v7 - 2)))
    {
      ++v6;
      v7 += 2;
      if (v6 >= *(void *)(a3 + 32)) {
        goto LABEL_13;
      }
    }
    int v8 = *(const void **)(a3 + 16 * v6 + 272);
    if (v8) {
      CFRelease(v8);
    }
    uint64_t v9 = *(void *)(a3 + 32);
    *(void *)(a3 + 32) = v9 - 1;
    if (v6 < v9 - 1)
    {
      uint64_t v10 = ~v6 + v9;
      do
      {
        *((_OWORD *)v7 - 1) = *(_OWORD *)v7;
        v7 += 2;
        --v10;
      }
      while (v10);
    }
    CFDictionaryRemoveValue(*(CFMutableDictionaryRef *)(a3 + 8), *a1);
  }
LABEL_13:

  sub_10000E0A8(a1, a2, a3);
}

BOOL sub_100139A44(void *a1, unsigned char *a2)
{
  uint64_t v4 = (const void *)kSecAttrTombstone;
  if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(a1[5] + 8), kSecAttrTombstone)) {
    sub_10000DF34(v4, kCFBooleanFalse, a1[5]);
  }
  uint64_t v5 = a1[5];
  CFArrayRef v6 = (const __CFArray *)a1[6];
  uint64_t v7 = a1[7];
  int v8 = (__CFString **)a1[8];
  v12[0] = _NSConcreteStackBlock;
  v12[1] = 0x40000000;
  int v12[2] = sub_100139B44;
  void v12[3] = &unk_1002FB9C8;
  v12[6] = a1[9];
  v12[7] = v7;
  void v12[4] = a1[4];
  v12[5] = v5;
  v12[8] = v8;
  BOOL result = sub_100138F00(v5, v6, v7, v8, (uint64_t)v12);
  uint64_t v10 = *(void *)(a1[4] + 8);
  if (*(unsigned char *)(v10 + 24)) {
    BOOL v11 = result;
  }
  else {
    BOOL v11 = 0;
  }
  *(unsigned char *)(v10 + 24) = v11;
  if (!*(unsigned char *)(*(void *)(a1[4] + 8) + 24)) {
    *a2 = 0;
  }
  return result;
}

void sub_100139B44(uint64_t a1, void **a2)
{
  CFTypeRef cf = 0;
  uint64_t v4 = *(void *)(a1 + 40);
  if (*(void *)(v4 + 240))
  {
    uint64_t v5 = sub_100118974(a2[2], 1, 0);
    CFArrayRef v6 = sub_100118CF8(a2, v5, 0);
    uint64_t v4 = *(void *)(a1 + 40);
    uint64_t v7 = *(const void **)(v4 + 240);
    if (v7)
    {
      if (!sub_100139330(v7, (uint64_t)v6)) {
        return;
      }
      uint64_t v4 = *(void *)(a1 + 40);
    }
  }
  if (*(unsigned char *)(v4 + 116))
  {
    CFStringRef v8 = (const __CFString *)sub_100119CB8(a2, kSecAttrSharingGroup);
    if (v8)
    {
      CFStringRef v9 = v8;
      CFTypeID v10 = CFGetTypeID(v8);
      if (v10 == CFStringGetTypeID())
      {
        if (CFStringCompare(v9, kSecAttrSharingGroupNone, 0))
        {
          BOOL v11 = sub_10000B070("SecError");
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Cannot update shared item for unentitled client", buf, 2u);
          }
          return;
        }
      }
    }
  }
  BOOL v12 = (void *)sub_100118974(a2[2], 7, 0);
  CFDataRef v13 = (const __CFData *)sub_100118CF8(a2, (uint64_t)v12, 0);
  CFDataRef v14 = v13;
  if (v13) {
    CFRetain(v13);
  }
  int v15 = sub_10011B3B4((uint64_t)a2, *(const __CFDictionary **)(*(void *)(a1 + 48) + 8), (__CFString **)&cf);
  sub_1001196B4((uint64_t)a2, v12, v14, 0);
  if (v14) {
    CFRelease(v14);
  }
  if (SecErrorGetOSStatus() == -26275)
  {
    int v16 = sub_10000B070("SecWarning");
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = ***(void ***)(a1 + 40);
      uint64_t v18 = sub_10011B728(a2, 0);
      *(_DWORD *)long long buf = 138412802;
      uint64_t v36 = v17;
      __int16 v37 = 2048;
      uint64_t v38 = v18;
      __int16 v39 = 2112;
      CFTypeRef v40 = cf;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "deleting corrupt %@,rowid=%lld %@", buf, 0x20u);
    }
    CFTypeRef v19 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v19);
    }
    if ((sub_10011ED78((CFStringRef **)a2, *(void *)(a1 + 56), 0, 0, &cf) & 1) == 0)
    {
      int v20 = sub_10000B070("SecError");
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v21 = ***(void ***)(a1 + 40);
        uint64_t v22 = sub_10011B728(a2, 0);
        *(_DWORD *)long long buf = 138412802;
        uint64_t v36 = v21;
        __int16 v37 = 2048;
        uint64_t v38 = v22;
        __int16 v39 = 2112;
        CFTypeRef v40 = cf;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "failed to delete corrupt %@,rowid=%lld %@", buf, 0x20u);
      }
      CFTypeRef v23 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        CFRelease(v23);
      }
    }
    if (!v15) {
      return;
    }
LABEL_58:
    CFRelease(v15);
    return;
  }
  if (v15)
  {
    uint64_t v24 = *(void *)(*(void *)(a1 + 48) + 136);
    if (v24) {
      sub_10011AC34((uint64_t)v15, v24, (__CFString **)&cf);
    }
  }
  uint64_t v25 = (__CFError *)cf;
  CFErrorDomain v26 = *(CFErrorRef **)(a1 + 64);
  if (cf && v26)
  {
    if (*v26)
    {
      if (CFErrorGetCode(*v26) != -25330) {
        goto LABEL_38;
      }
      CFErrorRef v27 = *v26;
      if (*v26)
      {
        CFErrorRef *v26 = 0;
        CFRelease(v27);
LABEL_38:
        if (*v26) {
          goto LABEL_39;
        }
      }
    }
    char v28 = 0;
    CFErrorRef *v26 = v25;
    goto LABEL_42;
  }
  if (cf)
  {
    if (!v26)
    {
LABEL_39:
      CFRelease(v25);
      char v28 = 0;
      goto LABEL_42;
    }
    goto LABEL_38;
  }
  char v28 = 1;
LABEL_42:
  if (!v15) {
    char v28 = 0;
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v28;
  if (v15)
  {
    int v29 = sub_10011B964(a2);
    unsigned __int8 v30 = sub_10011B9C4(a2);
    uint64_t v31 = *(void *)(a1 + 56);
    CFBooleanRef v32 = *(const __CFBoolean **)(*(void *)(a1 + 40) + 96);
    if (!v32)
    {
      if (v29 && !sub_10011BAEC(a2)) {
        CFBooleanRef v32 = 0;
      }
      else {
        CFBooleanRef v32 = kCFBooleanFalse;
      }
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = sub_10011E680(a2, (void **)v15, v31, v32, *(unsigned __int8 *)(*(void *)(a1 + 40) + 154), *(__CFString ***)(a1 + 64));
    if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) {
      goto LABEL_58;
    }
    uint64_t v33 = *(void *)(a1 + 40);
    *(unsigned char *)(v33 + 113) = 1;
    if ((v29 & 1) == 0)
    {
      if (!sub_10011B964((void **)v15))
      {
LABEL_55:
        if ((v30 & 1) != 0 || sub_10011B9C4(v15)) {
          *(unsigned char *)(*(void *)(a1 + 40) + 115) = 1;
        }
        goto LABEL_58;
      }
      uint64_t v33 = *(void *)(a1 + 40);
    }
    *(unsigned char *)(v33 + 114) = 1;
    goto LABEL_55;
  }
}

BOOL sub_100139FCC(uint64_t a1, uint64_t a2, uint64_t a3, CFTypeRef *a4)
{
  uint64_t v22 = 0;
  CFTypeRef v23 = &v22;
  uint64_t v24 = 0x2000000000;
  char v25 = 1;
  uint64_t v18 = 0;
  CFTypeRef v19 = &v18;
  uint64_t v20 = 0x2000000000;
  char v21 = 0;
  CFStringRef v8 = (const void *)kSecAttrTombstone;
  if (!CFDictionaryContainsKey(*(CFDictionaryRef *)(a2 + 8), kSecAttrTombstone)) {
    sub_10000DF34(v8, kCFBooleanFalse, a2);
  }
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 0x40000000;
  v17[2] = sub_10013A1F8;
  v17[3] = &unk_1002FBA50;
  void v17[4] = a2;
  v17[5] = a3;
  v16[0] = _NSConcreteStackBlock;
  v16[1] = 0x40000000;
  void v16[2] = sub_10013A220;
  v16[3] = &unk_1002FBA70;
  void v16[4] = a2;
  void v16[5] = a3;
  v16[6] = a4;
  v15[0] = _NSConcreteStackBlock;
  v15[1] = 0x40000000;
  int v15[2] = sub_10013A258;
  v15[3] = &unk_1002FBA98;
  void v15[6] = a2;
  v15[7] = a4;
  void v15[4] = &v18;
  void v15[5] = &v22;
  v15[8] = a1;
  BOOL v9 = sub_10011C750((CFDictionaryRef *)a2, a1, a4, 0, &stru_1002FBA30, (uint64_t)v17, (uint64_t)v16, (uint64_t)v15);
  if (*((unsigned char *)v23 + 24)) {
    BOOL v10 = v9;
  }
  else {
    BOOL v10 = 0;
  }
  *((unsigned char *)v23 + 24) = v10;
  if (!v10) {
    goto LABEL_12;
  }
  BOOL v11 = v19;
  if (*(unsigned char *)(a2 + 113) || *((unsigned char *)v19 + 24)) {
    goto LABEL_11;
  }
  BOOL v12 = sub_100012A40(-25300, (__CFString **)a4, @"Delete failed to delete anything");
  *((unsigned char *)v23 + 24) = v12;
  if (!v12)
  {
LABEL_12:
    BOOL v13 = 0;
    goto LABEL_13;
  }
  BOOL v11 = v19;
LABEL_11:
  BOOL v13 = *((unsigned __int8 *)v11 + 24) == 0;
LABEL_13:
  _Block_object_dispose(&v18, 8);
  _Block_object_dispose(&v22, 8);
  return v13;
}

uint64_t sub_10013A1F8(uint64_t a1, __CFString *a2)
{
  return 1;
}

uint64_t sub_10013A220(uint64_t a1, sqlite3_stmt *a2, int a3)
{
  int v4 = a3;
  return sub_10000E62C(a2, *(void *)(a1 + 32), *(const __CFArray **)(a1 + 40), &v4, *(CFTypeRef **)(a1 + 48));
}

void sub_10013A258(uint64_t a1, uint64_t a2)
{
  if (*(void *)(*(void *)(a1 + 48) + 240))
  {
    uint64_t v4 = sub_100118974(*(void **)(a2 + 16), 1, 0);
    uint64_t v5 = sub_100118CF8((const void *)a2, v4, 0);
    CFArrayRef v6 = *(const void **)(*(void *)(a1 + 48) + 240);
    if (v6)
    {
      if (!sub_100139330(v6, (uint64_t)v5)) {
        return;
      }
    }
  }
  *(void *)(a2 + 64) = @"odel";
  uint64_t v7 = *(CFErrorRef **)(a1 + 56);
  CFErrorRef err = 0;
  BOOL v8 = sub_100118DFC(a2, 1, (__CFString **)&err);
  CFErrorRef v9 = err;
  if (!v8 && err)
  {
    if (CFErrorGetCode(err) == -25330)
    {
      if (v7) {
        *uint64_t v7 = err;
      }
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
      return;
    }
    CFErrorRef v9 = err;
  }
  if (v9) {
    CFRelease(v9);
  }
  if (*(unsigned char *)(*(void *)(a1 + 48) + 116)
    && (CFStringRef v10 = (const __CFString *)sub_100119CB8((void *)a2, kSecAttrSharingGroup)) != 0
    && (CFStringRef v11 = v10, v12 = CFGetTypeID(v10), v12 == CFStringGetTypeID())
    && CFStringCompare(v11, kSecAttrSharingGroupNone, 0))
  {
    BOOL v13 = sub_10000B070("SecError");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)uint64_t v22 = 0;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "Cannot delete shared item for unentitled client", v22, 2u);
    }
  }
  else
  {
    CFDataRef v14 = (void *)sub_100118974(*(void **)(a2 + 16), 7, 0);
    CFDataRef v15 = (const __CFData *)sub_100118CF8((const void *)a2, (uint64_t)v14, 0);
    if (v15)
    {
      CFDataRef v16 = v15;
      CFRetain(v15);
      int v17 = sub_10011B964((void **)a2);
      unsigned int v18 = sub_10011B9C4((void *)a2);
      sub_1001196B4(a2, v14, v16, 0);
      CFRelease(v16);
    }
    else
    {
      int v17 = sub_10011B964((void **)a2);
      unsigned int v18 = sub_10011B9C4((void *)a2);
      sub_1001196B4(a2, v14, 0, 0);
    }
    uint64_t v19 = *(void *)(a1 + 64);
    CFBooleanRef v20 = *(const __CFBoolean **)(*(void *)(a1 + 48) + 96);
    if (!v20)
    {
      if (v17 && !sub_10011BAEC((void **)a2)) {
        CFBooleanRef v20 = 0;
      }
      else {
        CFBooleanRef v20 = kCFBooleanFalse;
      }
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = sub_10011ED78((CFStringRef **)a2, v19, v20, *(unsigned __int8 *)(*(void *)(a1 + 48) + 155), *(CFTypeRef **)(a1 + 56));
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24))
    {
      char v21 = *(unsigned char **)(a1 + 48);
      v21[113] = 1;
      if (v17) {
        v21[114] = 1;
      }
      if (v18) {
        v21[115] = 1;
      }
    }
  }
}

BOOL sub_10013A500(id a1, const SecDbAttr *a2)
{
  return 0;
}

uint64_t sub_10013A508(const __CFDictionary *a1, uint64_t a2, int a3)
{
  CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(a1, kSecAttrSysBound);
  if (Value && (CFNumberRef v7 = Value, v8 = CFGetTypeID(Value), v8 == CFNumberGetTypeID()))
  {
    int valuePtr = 0;
    if (CFNumberGetValue(v7, kCFNumberSInt32Type, &valuePtr)) {
      BOOL v9 = valuePtr == 0;
    }
    else {
      BOOL v9 = 1;
    }
    return !v9;
  }
  else
  {
    uint64_t result = (uint64_t)CFDictionaryGetValue(a1, kSecAttrAccessGroup);
    if (result)
    {
      CFStringRef v11 = (const void *)result;
      CFTypeID v12 = CFGetTypeID((CFTypeRef)result);
      if (v12 != CFStringGetTypeID()) {
        return 0;
      }
      if (kSOSInternalAccessGroup && CFEqual(v11, kSOSInternalAccessGroup)
        || CFEqual(v11, @"lockdown-identities"))
      {
        return 1;
      }
      if (CFEqual(v11, @"apple")
        && sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008) == a2)
      {
        __int16 v37 = CFDictionaryGetValue(a1, kSecAttrService);
        uint64_t v38 = CFDictionaryGetValue(a1, kSecAttrAccount);
        if (sub_10013AB80(v37))
        {
          if (sub_10013AB80(v38) && CFEqual(v37, @"com.apple.managedconfiguration"))
          {
            char v39 = 0;
            uint64_t v40 = 0;
            char v41 = 1;
            char v42 = 1;
            do
            {
              char v43 = v42;
              char v44 = v39;
              char v42 = v41;
              int v45 = CFEqual(v38, off_1002FBAB8[v40]);
              if (v45) {
                break;
              }
              char v41 = 0;
              char v39 = 1;
              uint64_t v40 = 1;
            }
            while ((v44 & 1) == 0);
            char v46 = v45 ? v43 : v42;
            if (v46) {
              return 1;
            }
          }
        }
        if (sub_10013AB80(v37) && CFEqual(v37, @"com.apple.account.CloudKit.token")
          || sub_10013AB80(v37) && CFEqual(v37, @"com.apple.account.idms.continuation-key"))
        {
          return 1;
        }
      }
      if (a3)
      {
        if (CFEqual(v11, @"com.apple.apsd"))
        {
          if (sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008) == a2)
          {
            BOOL v13 = CFDictionaryGetValue(a1, kSecAttrService);
            if (sub_10013AB80(v13))
            {
              char v14 = 0;
              uint64_t v15 = 0;
              char v16 = 1;
              char v17 = 1;
              do
              {
                char v18 = v17;
                char v19 = v14;
                char v17 = v16;
                int v20 = CFEqual(v13, off_1002FBAC8[v15]);
                if (v20) {
                  break;
                }
                char v16 = 0;
                char v14 = 1;
                uint64_t v15 = 1;
              }
              while ((v19 & 1) == 0);
              char v21 = v20 ? v18 : v17;
              if (v21) {
                return 1;
              }
            }
          }
        }
        if (CFEqual(v11, @"appleaccount"))
        {
          if (sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008) == a2)
          {
            uint64_t v22 = CFDictionaryGetValue(a1, kSecAttrService);
            if (sub_10013AB80(v22))
            {
              unint64_t v23 = 0;
              BOOL v24 = 1;
              do
              {
                if (CFEqual(v22, off_1002FBAD8[v23])) {
                  break;
                }
                BOOL v24 = v23++ < 3;
              }
              while (v23 != 4);
              if (v24) {
                return 1;
              }
            }
          }
        }
        if (CFEqual(v11, @"apple")
          && sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008) == a2)
        {
          CFStringRef v47 = (const __CFString *)CFDictionaryGetValue(a1, kSecAttrService);
          if (sub_10013AB80(v47))
          {
            unint64_t v48 = 0;
            BOOL v49 = 1;
            do
            {
              if (CFEqual(v47, off_1002FBAF8[v48])) {
                break;
              }
              BOOL v49 = v48++ < 0xD;
            }
            while (v48 != 14);
            if (v49) {
              return 1;
            }
          }
          if (sub_10013AB80(v47) && CFStringHasPrefix(v47, @"com.apple.gs.")) {
            return 1;
          }
          if (sub_10013AB80(v47))
          {
            if (CFEqual(v47, @"com.apple.facetime"))
            {
              uint64_t v50 = CFDictionaryGetValue(a1, kSecAttrAccount);
              if (sub_10013AB80(v50))
              {
                if (CFEqual(v50, @"registrationV1")) {
                  return 1;
                }
              }
            }
          }
        }
        if (CFEqual(v11, @"com.apple.ind"))
        {
          if (sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008) == a2)
          {
            char v25 = CFDictionaryGetValue(a1, kSecAttrService);
            if (sub_10013AB80(v25))
            {
              if (CFEqual(v25, @"com.apple.ind.registration")) {
                return 1;
              }
            }
          }
        }
        if (CFEqual(v11, @"ichat"))
        {
          if (sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008) == a2)
          {
            CFErrorDomain v26 = CFDictionaryGetValue(a1, kSecAttrService);
            if (sub_10013AB80(v26))
            {
              if (CFEqual(v26, @"ids")) {
                return 1;
              }
            }
          }
        }
        if (CFEqual(v11, @"ichat"))
        {
          if (sub_10000C75C(@"keys", &qword_10035D040, (uint64_t)&unk_10035D038) == a2)
          {
            CFErrorRef v27 = CFDictionaryGetValue(a1, kSecAttrLabel);
            if (sub_10013AB80(v27))
            {
              char v28 = 0;
              uint64_t v29 = 0;
              char v30 = 1;
              char v31 = 1;
              do
              {
                char v32 = v31;
                char v33 = v28;
                char v31 = v30;
                int v34 = CFEqual(v27, off_1002FBB68[v29]);
                if (v34) {
                  break;
                }
                char v30 = 0;
                char v28 = 1;
                uint64_t v29 = 1;
              }
              while ((v33 & 1) == 0);
              char v35 = v34 ? v32 : v31;
              if (v35) {
                return 1;
              }
            }
          }
        }
        if (CFEqual(v11, @"com.apple.rapport")
          && sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008) == a2)
        {
          return 1;
        }
      }
      CFTypeRef cf = 0;
      if (CFDictionaryGetValueIfPresent(a1, kSecAttrSharingGroup, &cf)
        && cf
        && (CFTypeID v36 = CFGetTypeID(cf), v36 == CFStringGetTypeID()))
      {
        return 1;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

const void *sub_10013AB80(const void *result)
{
  if (result)
  {
    CFTypeID v1 = CFGetTypeID(result);
    return (const void *)(v1 == CFStringGetTypeID());
  }
  return result;
}

BOOL sub_10013ABB8(uint64_t a1, uint64_t a2, int a3, CFTypeRef *a4)
{
  CFTypeID v8 = sub_10000B070("SecWarning");
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 138412546;
    uint64_t v13 = a2;
    __int16 v14 = 1024;
    int v15 = a3;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "SecServerDeleteAllForUser for user: %@ keepU %{BOOL}d", buf, 0x12u);
  }
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = sub_10013ACE8;
  void v10[3] = &unk_1002FBB78;
  void v10[4] = a1;
  void v10[5] = a2;
  char v11 = a3;
  v10[6] = a4;
  return sub_1001381F8(a1, 2, a4, (uint64_t)v10);
}

uint64_t sub_10013ACE8(uint64_t a1)
{
  if (!sub_10013AD90(*(void *)(a1 + 32), @"DELETE FROM genp WHERE musr = ?", *(const __CFString **)(a1 + 40), *(unsigned __int8 *)(a1 + 56), *(CFTypeRef **)(a1 + 48))|| !sub_10013AD90(*(void *)(a1 + 32), @"DELETE FROM inet WHERE musr = ?", *(const __CFString **)(a1 + 40), *(unsigned __int8 *)(a1 + 56), *(CFTypeRef **)(a1 + 48))|| !sub_10013AD90(*(void *)(a1 + 32), @"DELETE FROM cert WHERE musr = ?", *(const __CFString **)(a1 + 40), *(unsigned __int8 *)(a1 + 56), *(CFTypeRef **)(a1 + 48)))
  {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 32);
  CFStringRef v3 = *(const __CFString **)(a1 + 40);
  int v4 = *(unsigned __int8 *)(a1 + 56);
  uint64_t v5 = *(CFTypeRef **)(a1 + 48);

  return sub_10013AD90(v2, @"DELETE FROM keys WHERE musr = ?", v3, v4, v5);
}

uint64_t sub_10013AD90(uint64_t a1, CFTypeRef cf, const __CFString *a3, int a4, CFTypeRef *a5)
{
  if (a4) {
    CFStringRef v8 = CFStringCreateWithFormat(0, 0, @"%@ AND pdmn NOT IN ('aku','akpu','cku','dku')", cf);
  }
  else {
    CFStringRef v8 = (const __CFString *)CFRetain(cf);
  }
  CFStringRef v9 = v8;
  if (v8)
  {
    CFStringRef v10 = sub_1000111CC(a1, v8, 0, a5);
    if (v10)
    {
      char v11 = v10;
      if (sub_10000E8B0(v10, 1, a3, a5)) {
        sub_1000275B0(a1, v11, a5, (uint64_t)&stru_1002FBE18);
      }
      if (sub_100011164(v11, a5))
      {
        uint64_t v12 = 1;
LABEL_16:
        CFRelease(v9);
        return v12;
      }
    }
  }
  uint64_t v13 = sub_10000B070("SecWarning");
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    if (a5) {
      CFTypeRef v14 = *a5;
    }
    else {
      CFTypeRef v14 = 0;
    }
    *(_DWORD *)long long buf = 138412802;
    CFStringRef v17 = v9;
    __int16 v18 = 2112;
    CFStringRef v19 = a3;
    __int16 v20 = 2112;
    CFTypeRef v21 = v14;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "DeleteAllFromTableForMUSRView failed for %@ for musr: %@: %@", buf, 0x20u);
  }
  uint64_t v12 = 0;
  uint64_t result = 0;
  if (v9) {
    goto LABEL_16;
  }
  return result;
}

uint64_t sub_10013AF1C(uint64_t a1)
{
  uint64_t v2 = sub_10000B070("item");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    LODWORD(buf) = 138412290;
    *(void *)((char *)&buf + 4) = a1;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "Request to delete app clip keychain items for identifier '%@'", (uint8_t *)&buf, 0xCu);
  }
  *(void *)&long long buf = 0;
  *((void *)&buf + 1) = &buf;
  uint64_t v22 = 0x2000000000;
  uint64_t v23 = 0;
  uint64_t v11 = 0;
  uint64_t v12 = &v11;
  uint64_t v13 = 0x2000000000;
  char v14 = 1;
  v10[0] = _NSConcreteStackBlock;
  v10[1] = 0x40000000;
  v10[2] = sub_10013B118;
  void v10[3] = &unk_1002FBBF0;
  void v10[4] = &buf;
  void v10[5] = &v11;
  v10[6] = a1;
  unsigned __int8 v3 = sub_10000CBA4(1, 1, 0, (uint64_t)&v23, (uint64_t)v10);
  int v4 = v3 & (*((unsigned char *)v12 + 24) != 0);
  *((unsigned char *)v12 + 24) = v4;
  if (v4) {
    uint64_t v5 = 0;
  }
  else {
    uint64_t v5 = 4294941020;
  }
  CFArrayRef v6 = sub_10000B070("item");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(*((void *)&buf + 1) + 24);
    *(_DWORD *)int v15 = 138412802;
    uint64_t v16 = a1;
    __int16 v17 = 1024;
    int v18 = v5;
    __int16 v19 = 2112;
    uint64_t v20 = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Finished request to delete app clip keychain items for identifier '%@' with status %i: %@", v15, 0x1Cu);
  }
  CFStringRef v8 = *(const void **)(*((void *)&buf + 1) + 24);
  if (v8)
  {
    *(void *)(*((void *)&buf + 1) + 24) = 0;
    CFRelease(v8);
  }
  _Block_object_dispose(&v11, 8);
  _Block_object_dispose(&buf, 8);
  return v5;
}

BOOL sub_10013B118(int8x16_t *a1, uint64_t a2)
{
  v6[0] = _NSConcreteStackBlock;
  int8x16_t v2 = vextq_s8(a1[2], a1[2], 8uLL);
  unsigned __int8 v3 = (CFTypeRef *)(*(void *)(a1[2].i64[0] + 8) + 24);
  v6[1] = 0x40000000;
  _DWORD v6[2] = sub_10013B1A8;
  v6[3] = &unk_1002FBBC8;
  int8x16_t v7 = v2;
  uint64_t v4 = a1[3].i64[0];
  uint64_t v8 = a2;
  uint64_t v9 = v4;
  return sub_1001381F8(a2, 2, v3, (uint64_t)v6);
}

uint64_t sub_10013B1A8(int8x16_t *a1)
{
  int8x16_t v2 = &off_1002FE3E8;
  unsigned __int8 v3 = off_100300578;
  do
  {
    if (*((unsigned char *)v2 + 8))
    {
      CFStringRef v4 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"DELETE FROM %@ WHERE agrp = ? AND clip = 1", *v2);
      uint64_t v5 = a1[2].i64[1];
      CFArrayRef v6 = (CFTypeRef *)(*(void *)(v5 + 8) + 24);
      v13[0] = _NSConcreteStackBlock;
      v13[1] = 0x40000000;
      size_t v13[2] = sub_10013B2E4;
      void v13[3] = &unk_1002FBBA0;
      v13[4] = a1[2].i64[0];
      _OWORD v13[5] = v5;
      int8x16_t v7 = a1[3];
      int8x16_t v14 = vextq_s8(v7, v7, 8uLL);
      char v8 = sub_10002742C(v7.i64[0], (uint64_t)v4, v6, (uint64_t)v13);
      uint64_t v9 = *(void *)(a1[2].i64[0] + 8);
      if (*(unsigned char *)(v9 + 24)) {
        char v10 = v8;
      }
      else {
        char v10 = 0;
      }
      *(unsigned char *)(v9 + 24) = v10;
      if (v4) {
        CFRelease(v4);
      }
    }
    uint64_t v11 = *v3++;
    int8x16_t v2 = v11;
  }
  while (v11);
  return *(unsigned __int8 *)(*(void *)(a1[2].i64[0] + 8) + 24);
}

uint64_t sub_10013B2E4(uint64_t a1, sqlite3_stmt *a2)
{
  char v4 = sub_10000E8B0(a2, 1, *(const __CFString **)(a1 + 48), (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v5 + 24)) {
    char v6 = v4;
  }
  else {
    char v6 = 0;
  }
  *(unsigned char *)(v5 + 24) = v6;
  uint64_t result = sub_1000275B0(*(void *)(a1 + 56), a2, (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24), 0);
  uint64_t v8 = *(void *)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(v8 + 24)) {
    char v9 = result;
  }
  else {
    char v9 = 0;
  }
  *(unsigned char *)(v8 + 24) = v9;
  return result;
}

BOOL sub_10013B36C(int8x16_t *a1, uint64_t a2)
{
  v6[0] = _NSConcreteStackBlock;
  int8x16_t v2 = vextq_s8(a1[2], a1[2], 8uLL);
  unsigned __int8 v3 = (CFTypeRef *)(*(void *)(a1[2].i64[0] + 8) + 24);
  v6[1] = 0x40000000;
  _DWORD v6[2] = sub_10013B400;
  v6[3] = &unk_1002FBCA0;
  int8x16_t v7 = v2;
  uint64_t v4 = a1[3].i64[1];
  uint64_t v8 = a1[3].i64[0];
  uint64_t v9 = a2;
  uint64_t v10 = v4;
  return sub_1001381F8(a2, 2, v3, (uint64_t)v6);
}

uint64_t sub_10013B400(uint64_t a1)
{
  int8x16_t v2 = &off_1002FE3E8;
  unsigned __int8 v3 = off_100300578;
  do
  {
    if (*((unsigned char *)v2 + 8))
    {
      CFDictionarySetValue(*(CFMutableDictionaryRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), kSecClass, *v2);
      CFDictionaryRef v4 = *(const __CFDictionary **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      if (qword_10035CF68 != -1) {
        dispatch_once(&qword_10035CF68, &stru_1002FAFD0);
      }
      uint64_t v5 = (CFDictionaryRef *)sub_10000C3CC(v4, (const void *)qword_10035CF70, -1, 0, (__CFString **)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
      if (v5)
      {
        char v6 = (const void **)v5;
        v20[0] = _NSConcreteStackBlock;
        int8x16_t v7 = vextq_s8(*(int8x16_t *)(a1 + 40), *(int8x16_t *)(a1 + 40), 8uLL);
        uint64_t v8 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
        v20[1] = 0x40000000;
        int v20[2] = sub_10013B670;
        v20[3] = &unk_1002FBC78;
        int8x16_t v9 = *(int8x16_t *)(a1 + 56);
        int8x16_t v21 = v7;
        int8x16_t v22 = vextq_s8(v9, v9, 8uLL);
        BOOL v10 = sub_10011C750(v5, v9.i64[0], v8, 0, &stru_1002FBC30, 0, 0, (uint64_t)v20);
        uint64_t v11 = *(void *)(*(void *)(a1 + 48) + 8);
        if (*(unsigned char *)(v11 + 24)) {
          BOOL v12 = v10;
        }
        else {
          BOOL v12 = 0;
        }
        *(unsigned char *)(v11 + 24) = v12;
        sub_10000C2C4(v6, 0);
      }
      else
      {
        uint64_t v13 = sub_10000B070("SecError");
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v14 = (uint64_t)**(v3 - 1);
          uint64_t v15 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
          *(_DWORD *)long long buf = 138412546;
          uint64_t v24 = v14;
          __int16 v25 = 2112;
          uint64_t v26 = v15;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "AppcClipPromotion: unable to create query for class %@: %@", buf, 0x16u);
        }
        uint64_t v16 = *(void *)(*(void *)(a1 + 40) + 8);
        __int16 v17 = *(const void **)(v16 + 24);
        if (v17)
        {
          *(void *)(v16 + 24) = 0;
          CFRelease(v17);
        }
      }
    }
    int v18 = *v3++;
    int8x16_t v2 = v18;
  }
  while (v18);
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
}

void sub_10013B670(uint64_t a1, uint64_t a2, unsigned char *a3)
{
  CFTypeRef cf = 0;
  if (!sub_100118DFC(a2, 1, (__CFString **)&cf)) {
    goto LABEL_13;
  }
  char v6 = sub_10011B3B4(a2, *(const __CFDictionary **)(a1 + 48), (__CFString **)&cf);
  int8x16_t v7 = v6;
  if (cf || (sub_10011B874((uint64_t)v6, (__CFString **)&cf), cf))
  {
LABEL_11:
    if (!v7) {
      goto LABEL_13;
    }
    goto LABEL_12;
  }
  uint64_t v8 = *(void *)(a1 + 56);
  v19[0] = _NSConcreteStackBlock;
  v19[1] = 0x40000000;
  v19[2] = sub_10013B9B8;
  v19[3] = &unk_1002FBC50;
  void v19[4] = v7;
  if ((sub_10011C214((uint64_t)v7, v8, (__CFString **)&cf, (uint64_t)v19) & 1) == 0)
  {
    if (!sub_10011C1B8((__CFError *)cf))
    {
      int v10 = 0;
      goto LABEL_10;
    }
    CFTypeRef v9 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v9);
    }
  }
  int v10 = 1;
LABEL_10:
  uint64_t v11 = sub_10000B070("item");
  if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG)) {
    goto LABEL_11;
  }
  *(_DWORD *)long long buf = 67109120;
  int v22 = v10;
  _os_log_debug_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEBUG, "SecServerPromoteAppClipItemsToParentApp SecDbItemInsertOrReplace %d", buf, 8u);
  if (v7) {
LABEL_12:
  }
    CFRelease(v7);
LABEL_13:
  if (cf)
  {
    int Code = CFErrorGetCode((CFErrorRef)cf);
    if (Code == -25330 || Code == -26275)
    {
      uint64_t v14 = sub_10000B070("item");
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109379;
        int v22 = Code;
        __int16 v23 = 2113;
        uint64_t v24 = a2;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "Unable (%i) to promote item: %{private}@", buf, 0x12u);
      }
    }
    else
    {
      uint64_t v15 = sub_10000B070("item");
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 67109379;
        int v22 = Code;
        __int16 v23 = 2113;
        uint64_t v24 = a2;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "Encountered error %i during promotion: %{private}@", buf, 0x12u);
      }
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
    }
  }
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    CFTypeRef v17 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v17);
    }
  }
  else
  {
    *a3 = 1;
    if (cf)
    {
      uint64_t v18 = *(void *)(*(void *)(a1 + 40) + 8);
      if (!*(void *)(v18 + 24)) {
        *(void *)(v18 + 24) = cf;
      }
    }
  }
}

BOOL sub_10013B93C(id a1, const SecDbAttr *a2)
{
  var0 = a2->var0;
  if (!a2->var0)
  {
    CFStringRef v5 = kSecAttrAccessGroup;
    return var0 == v5;
  }
  if (CFEqual(var0, @"clip")) {
    return 1;
  }
  var0 = a2->var0;
  CFStringRef v5 = kSecAttrAccessGroup;
  if (!a2->var0 || !kSecAttrAccessGroup) {
    return var0 == v5;
  }
  return CFEqual(var0, kSecAttrAccessGroup) != 0;
}

CFTypeRef sub_10013B9B8(CFTypeRef result, uint64_t a2, void *a3)
{
  uint64_t v4 = *((void *)result + 4);
  if (v4) {
    uint64_t result = CFRetain(*((CFTypeRef *)result + 4));
  }
  *a3 = v4;
  return result;
}

__CFDictionary *sub_10013B9EC(uint64_t a1, uint64_t a2, int *a3, int a4, __CFString **a5)
{
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  uint64_t v57 = 0;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long cf = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v44 = 0u;
  memset(v43, 0, sizeof(v43));
  DWORD2(v4_Block_object_dispose(&STACK[0x3F0], 8) = dword_10035D2B0;
  CFDictionaryRef theDict = Mutable;
  if (!Mutable)
  {
    if (a5 && !*a5) {
      sub_100012A40(-108, a5, @"Can't create keychain dictionary");
    }
    CFStringRef v13 = 0;
    goto LABEL_54;
  }
  LODWORD(v44) = 11;
  *((void *)&v47 + 1) = -1;
  WORD4(v50) = 257;
  __int16 v37 = (CFTypeRef *)a5;
  if (!a2 || !*(unsigned char *)(a2 + 36))
  {
    if (qword_10035CF58 != -1) {
      dispatch_once(&qword_10035CF58, &stru_1002FAF90);
    }
    *(void *)&long long cf = qword_10035CF60;
    CFRetain((CFTypeRef)qword_10035CF60);
    if (a3)
    {
      CFStringRef v12 = sub_10013C088(*a3, 0);
    }
    else
    {
      int v14 = dword_10035D2B0;
      memset(buf, 170, 16);
      int v15 = sub_10001B560(dword_10035D2B0, buf);
      if (v15)
      {
        int v16 = v15;
        CFTypeRef v17 = sub_10000B070("SecError");
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)CFUUIDBytes bytes = 67109376;
          *(_DWORD *)&bytes[4] = v14;
          *(_WORD *)&UInt8 bytes[8] = 1024;
          *(_DWORD *)&bytes[10] = v16;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "keybag-uuid: could not determine backup keybag UUID for %d: %d", bytes, 0xEu);
        }
        goto LABEL_18;
      }
      memset(bytes, 0, 37);
      uuid_unparse_lower(buf, bytes);
      CFStringRef v12 = CFStringCreateWithCString(0, bytes, 0x8000100u);
    }
    if (v12)
    {
      CFStringRef v38 = v12;
      CFDictionarySetValue(theDict, @"keybag-uuid", v12);
LABEL_19:
      char v11 = 0;
      goto LABEL_20;
    }
LABEL_18:
    CFStringRef v38 = 0;
    goto LABEL_19;
  }
  unsigned int v10 = *(_DWORD *)(a2 + 20);
  *(void *)CFUUIDBytes bytes = 0x104B57A5353A5AA7;
  *(_DWORD *)&UInt8 bytes[8] = -1803342146;
  *(_DWORD *)&bytes[12] = bswap32(v10);
  CFStringRef v38 = 0;
  *(void *)&long long cf = CFDataCreate(0, bytes, 16);
  char v11 = 1;
LABEL_20:
  v62[0] = sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008);
  v62[1] = sub_10000C75C(@"inet", &qword_10035D020, (uint64_t)&unk_10035D018);
  v62[2] = sub_10000C75C(@"cert", &qword_10035D030, (uint64_t)&unk_10035D028);
  uint64_t v18 = 0;
  v62[3] = sub_10000C75C(@"keys", &qword_10035D040, (uint64_t)&unk_10035D038);
  BOOL v19 = a3 == 0;
  if (a3) {
    uint64_t v20 = a3;
  }
  else {
    uint64_t v20 = &dword_10035D2B0;
  }
  if (a4 == 1) {
    int8x16_t v21 = "";
  }
  else {
    int8x16_t v21 = "non-";
  }
  char v41 = v21;
  uint64_t v22 = a1;
  while (1)
  {
    *(void *)&v43[0] = v62[v18];
    unint64_t v60 = 0xAAAAAAAAAAAAAAAALL;
    unint64_t v61 = 0xAAAAAAAAAAAAAAAALL;
    *(void *)&unsigned char bytes[32] = 0xAAAAAAAAAAAAAAAALL;
    *(void *)CFUUIDBytes bytes = v43;
    *(void *)&UInt8 bytes[8] = 0;
    *(void *)&bytes[16] = v22;
    *(void *)&bytes[24] = 0;
    int v23 = *v20;
    *(_DWORD *)&unsigned char bytes[32] = 0;
    LODWORD(v60) = v23;
    BYTE4(v60) = v19;
    LODWORD(v61) = a4;
    BYTE4(v61) = v11;
    uint64_t v24 = sub_10000B070("item");
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v25 = **(void **)&v43[0];
      *(_DWORD *)long long buf = 136315394;
      *(void *)&uint8_t buf[4] = v41;
      *(_WORD *)&unsigned char buf[12] = 2112;
      *(void *)&buf[14] = v25;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "exporting %ssysbound class '%@'", buf, 0x16u);
    }
    CFErrorRef err = 0;
    if (!sub_100010A40((uint64_t)sub_10013C19C, (uint64_t)bytes, (__CFString **)&err)) {
      break;
    }
    uint64_t v26 = sub_10000B070("item");
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v27 = **(void **)&v43[0];
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v27;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "exporting class '%@' complete", buf, 0xCu);
    }
    if (CFArrayGetCount(*(CFArrayRef *)&bytes[24]))
    {
      CFStringRef v28 = **(const __CFString ***)&v43[0];
      CFArrayGetCount(*(CFArrayRef *)&bytes[24]);
      if (CFStringGetLength(v28) == 4)
      {
        memset(buf, 170, 5);
        if (CFStringGetCString(v28, (char *)buf, 5, 0x8000100u)) {
          kdebug_trace();
        }
      }
      CFDictionaryAddValue(theDict, **(const void ***)&v43[0], *(const void **)&bytes[24]);
      uint64_t v22 = a1;
    }
LABEL_41:
    char v31 = *(const void **)&bytes[24];
    if (*(void *)&bytes[24])
    {
      *(void *)&bytes[24] = 0;
      CFRelease(v31);
    }
    if (++v18 == 4)
    {
      CFStringRef v13 = v38;
      goto LABEL_55;
    }
  }
  if (CFErrorGetCode(err) == -25300)
  {
    uint64_t v29 = sub_10000B070("item");
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v30 = **(void **)&v43[0];
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v30;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "exporting class '%@' complete (no items)", buf, 0xCu);
    }
    CFRelease(err);
    goto LABEL_41;
  }
  char v32 = sub_10000B070("SecError");
  if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v33 = **(void **)&v43[0];
    *(_DWORD *)long long buf = 138412546;
    *(void *)&uint8_t buf[4] = v33;
    *(_WORD *)&unsigned char buf[12] = 2112;
    *(void *)&buf[14] = err;
    _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "exporting class '%@' failed: %@", buf, 0x16u);
  }
  if (v37)
  {
    if (*v37) {
      CFRelease(*v37);
    }
    CFTypeRef *v37 = err;
  }
  else
  {
    CFRelease(err);
  }
  CFRelease(theDict);
  int v34 = *(const void **)&bytes[24];
  CFStringRef v13 = v38;
  if (*(void *)&bytes[24])
  {
    *(void *)&bytes[24] = 0;
    CFRelease(v34);
  }
LABEL_54:
  CFDictionaryRef theDict = 0;
LABEL_55:
  char v35 = (const void *)cf;
  if ((void)cf)
  {
    *(void *)&long long cf = 0;
    CFRelease(v35);
  }
  if (v13) {
    CFRelease(v13);
  }
  return theDict;
}

CFStringRef sub_10013C088(int a1, uint64_t a2)
{
  *(void *)&long long v7 = 0xAAAAAAAAAAAAAAAALL;
  *((void *)&v7 + 1) = 0xAAAAAAAAAAAAAAAALL;
  if (a2)
  {
    uuid_copy((unsigned __int8 *)&v7, (const unsigned __int8 *)(a2 + 32));
LABEL_3:
    memset(out, 0, sizeof(out));
    uuid_unparse_lower((const unsigned __int8 *)&v7, out);
    return CFStringCreateWithCString(0, out, 0x8000100u);
  }
  int v4 = sub_10001AD68(a1, &v7);
  if (!v4) {
    goto LABEL_3;
  }
  int v5 = v4;
  char v6 = sub_10000B070("SecError");
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uuid_string_t out = 67109376;
    *(_DWORD *)&out[4] = a1;
    *(_WORD *)&out[8] = 1024;
    *(_DWORD *)&out[10] = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "keybag-uuid: could not determine keybag UUID for %d: %d", (uint8_t *)out, 0xEu);
  }
  return 0;
}

void sub_10013C19C(sqlite3_stmt *a1, uint64_t a2)
{
  int v4 = *(void ***)a2;
  long long v63 = 0;
  CFTypeRef cf = 0;
  sqlite3_int64 v5 = sqlite3_column_int64(a1, 0);
  CFDictionaryRef theDict = 0;
  CFMutableDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  int v61 = 0;
  int v7 = sub_1000139C0(a1, (uint64_t)v4, 1, *(const __CFArray **)(a2 + 8), &theDict, &cf, &v61, &v63);
  MutableCFDictionaryRef Copy = 0;
  if (v7)
  {
    MutableCFDictionaryRef Copy = CFDictionaryCreateMutableCopy(0, 0, theDict);
    uint64_t v9 = *((void *)*v4 + 2);
    if (v9)
    {
      unsigned int v10 = (uint64_t *)((char *)*v4 + 24);
      do
      {
        if ((*(unsigned char *)(v9 + 16) & 0x20) != 0)
        {
          char v11 = CFDictionaryGetValue(MutableCopy, *(const void **)v9);
          if (v11)
          {
            CFDictionarySetValue(Mutable, *(const void **)v9, v11);
            CFDictionaryRemoveValue(MutableCopy, *(const void **)v9);
          }
        }
        uint64_t v12 = *v10++;
        uint64_t v9 = v12;
      }
      while (v12);
    }
  }
  if (!cf)
  {
    BOOL v15 = (v61 & 0x1F) == 12;
    goto LABEL_14;
  }
  CFStringRef Protection = (CFStringRef)SecAccessControlGetProtection();
  if (!Protection || !kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly)
  {
    BOOL v15 = Protection == kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly;
LABEL_14:
    BOOL v14 = v15;
    goto LABEL_17;
  }
  BOOL v14 = CFEqual(Protection, kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly) != 0;
LABEL_17:
  if (theDict) {
    int v16 = v7;
  }
  else {
    int v16 = 0;
  }
  if (v16 == 1) {
    int v17 = CFDictionaryContainsKey(theDict, kSecAttrTokenID);
  }
  else {
    int v17 = 0;
  }
  if (v17) {
    int v18 = 1;
  }
  else {
    int v18 = v14;
  }
  BOOL v19 = v18 == 1 && *(_DWORD *)(a2 + 48) == 2;
  CFDictionaryRef v20 = theDict;
  if (theDict) {
    int v21 = v7;
  }
  else {
    int v21 = 0;
  }
  if (v21 != 1 || v19)
  {
    if (v21)
    {
      uint64_t v25 = sub_10000B070("item");
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 134218240;
        *(void *)unsigned int v66 = v5;
        *(_WORD *)&v66[8] = 1024;
        *(_DWORD *)&v66[10] = v19;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "export rowid %llu skipped. akpu/token: %i", buf, 0x12u);
      }
      goto LABEL_83;
    }
    int OSStatus = SecErrorGetOSStatus();
    if (OSStatus == -25308 && v14)
    {
      if (!v19)
      {
        CFStringRef v28 = sub_10000B070("SecError");
        if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
        {
          int v29 = *(_DWORD *)(a2 + 48);
          *(_DWORD *)long long buf = 67109378;
          *(_DWORD *)unsigned int v66 = v29;
          *(_WORD *)&v66[4] = 2112;
          *(void *)&v66[6] = v63;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "Encountered akpu item we cannot export (filter %d), skipping. %@", buf, 0x12u);
        }
        if (sqlite3_column_count(a1) >= 3)
        {
          uint64_t v30 = sqlite3_column_text(a1, 2);
          CFStringRef v31 = CFStringCreateWithCString(kCFAllocatorDefault, (const char *)v30, 0x8000100u);
          if (v31)
          {
            CFStringRef v39 = v31;
            CFDictionaryRef v40 = sub_100139704(0, v32, v33, v34, v35, v36, v37, v38, @"agrp", (uint64_t)v31);
            SecABCTrigger();
            if (v40) {
              CFRelease(v40);
            }
            CFRelease(v39);
          }
        }
      }
    }
    else
    {
      int v51 = OSStatus;
      long long v52 = sub_10000B070("item");
      if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 134218242;
        *(void *)unsigned int v66 = v5;
        *(_WORD *)&v66[8] = 2112;
        *(void *)&v66[10] = v63;
        _os_log_debug_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEBUG, "Could not export item for rowid %llu: %@", buf, 0x16u);
      }
      if (v51 != -26275)
      {
        long long v59 = v4[5];
        if (v59) {
          CFRelease(v59);
        }
        void v4[5] = v63;
        goto LABEL_83;
      }
    }
    long long v53 = v63;
    if (!v63) {
      goto LABEL_83;
    }
    long long v63 = 0;
    goto LABEL_82;
  }
  int v22 = *(_DWORD *)(a2 + 48);
  if (v22)
  {
    if ((v22 != 1) == sub_10013A508(theDict, (uint64_t)*v4, *(unsigned __int8 *)(a2 + 52))) {
      goto LABEL_83;
    }
    CFDictionaryRef v20 = theDict;
  }
  CFDataRef v23 = (const __CFData *)CFDictionaryGetValue(v20, kSecAttrPersistentReference);
  if (v23 && CFDataGetLength(v23) == 16)
  {
    uint64_t UUIDBasedPersistentRef = _SecItemCreateUUIDBasedPersistentRef();
  }
  else
  {
    char v41 = sub_10000B070("pref");
    if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 134217984;
      *(void *)unsigned int v66 = v5;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "s3dl_export_row: Creating old persistent ref for %llu", buf, 0xCu);
    }
    uint64_t UUIDBasedPersistentRef = _SecItemCreatePersistentRef();
  }
  char v42 = (__CFString *)UUIDBasedPersistentRef;
  if (UUIDBasedPersistentRef)
  {
    if (*(_DWORD *)(a2 + 40) != -1)
    {
      char v43 = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
      uint64_t v44 = *((void *)*v4 + 2);
      if (v44)
      {
        long long v45 = (uint64_t *)((char *)*v4 + 24);
        do
        {
          if ((*(unsigned char *)(v44 + 17) & 0x20) != 0)
          {
            long long v46 = CFDictionaryGetValue(MutableCopy, *(const void **)v44);
            if (v46)
            {
              CFDictionaryAddValue(v43, *(const void **)v44, v46);
              CFDictionaryRemoveValue(MutableCopy, *(const void **)v44);
            }
          }
          uint64_t v47 = *v45++;
          uint64_t v44 = v47;
        }
        while (v47);
      }
      xpc_object_t value = 0;
      long long v48 = v4 + 5;
      BOOL v49 = sub_100124534((const __CFData *)*(unsigned int *)(a2 + 40), (uint64_t)cf, (const __CFData *)v4[18], Mutable, MutableCopy, v43, (__CFData **)&value, 0, *(unsigned char *)(a2 + 44), (__CFString **)v4 + 5);
      CFDictionaryRemoveAllValues(theDict);
      CFRelease(v43);
      if (v49)
      {
        long long v50 = value;
        CFDictionarySetValue(theDict, kSecValueData, value);
        if (!v50) {
          goto LABEL_79;
        }
      }
      else
      {
        long long v54 = sub_10000B070("SecCritical");
        if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v55 = *(void *)*v4;
          long long v56 = v4[5];
          *(_DWORD *)long long buf = 138412802;
          *(void *)unsigned int v66 = v55;
          *(_WORD *)&v66[8] = 2048;
          *(void *)&v66[10] = v5;
          __int16 v67 = 2112;
          __int16 v68 = v56;
          _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "ks_encrypt_data %@,rowid=%lld: failed: %@", buf, 0x20u);
        }
        long long v50 = *v48;
        if (!*v48) {
          goto LABEL_79;
        }
        void *v48 = 0;
      }
      CFRelease(v50);
    }
LABEL_79:
    if (CFDictionaryGetCount(theDict))
    {
      CFDictionarySetValue(theDict, kSecValuePersistentRef, v42);
      CFArrayAppendValue(*(CFMutableArrayRef *)(a2 + 24), theDict);
      ++*(_DWORD *)(a2 + 32);
    }
    long long v53 = v42;
LABEL_82:
    CFRelease(v53);
  }
LABEL_83:
  CFTypeRef v57 = cf;
  if (cf)
  {
    CFTypeRef cf = 0;
    CFRelease(v57);
  }
  CFDictionaryRef v58 = theDict;
  if (theDict)
  {
    CFDictionaryRef theDict = 0;
    CFRelease(v58);
  }
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
}

BOOL sub_10013C868(uint64_t a1, uint64_t a2, int a3, uint64_t a4, int a5, const __CFDictionary *a6, int a7, int a8, __CFString **a9)
{
  int v16 = (CFTypeRef *)a9;
  if (a7 == 2)
  {
    LODWORD(bytes) = -1;
    BOOL v17 = 1;
    int v18 = sub_10013B9EC(a1, a2, (int *)&bytes, 1, a9);
    if (!v18) {
      return v17;
    }
  }
  else
  {
    int v18 = 0;
  }
  CFStringRef cf1 = sub_10013C088(a3, a4);
  BOOL v49 = (const void *)a1;
  if (!cf1
    || (CFNumberRef Value = CFDictionaryGetValue(a6, @"keybag-uuid")) == 0
    || (CFDictionaryRef v20 = Value,
        CFDictionaryRef v21 = a6,
        CFTypeID v22 = CFGetTypeID(Value),
        BOOL v23 = v22 == CFStringGetTypeID(),
        a6 = v21,
        int v16 = (CFTypeRef *)a9,
        !v23)
    || CFEqual(cf1, v20))
  {
    if (*(unsigned char *)(a2 + 36))
    {
      unsigned int v24 = *(_DWORD *)(a2 + 20);
      *(void *)&long long bytes = 0x104B57A5353A5AA7;
      DWORD2(bytes) = -1803342146;
      HIDWORD(bytes) = bswap32(v24);
      CFDataRef v25 = CFDataCreate(0, (const UInt8 *)&bytes, 16);
      if (!v25) {
        goto LABEL_18;
      }
      CFDataRef v26 = v25;
      CFDictionaryRef v27 = a6;
      CFStringRef v28 = v49;
      BOOL v29 = sub_10013ABB8((uint64_t)v49, (uint64_t)v25, 1, v16);
      CFRelease(v26);
      if (!v29) {
        goto LABEL_18;
      }
      goto LABEL_29;
    }
    if (a8)
    {
      CFDictionaryRef v27 = a6;
      uint64_t v30 = sub_10000B070("SecWarning");
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        LOWORD(bytes) = 0;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "SecServerDeleteAll", (uint8_t *)&bytes, 2u);
      }
      *(void *)&long long bytes = _NSConcreteStackBlock;
      *((void *)&bytes + 1) = 0x40000000;
      uint64_t v64 = (uint64_t)sub_10013CE6C;
      v65[0] = &unk_1002FBE38;
      CFStringRef v28 = v49;
      v65[1] = v49;
      v65[2] = v16;
      if (!sub_1001381F8((uint64_t)v49, 2, v16, (uint64_t)&bytes))
      {
LABEL_18:
        BOOL v17 = 0;
        CFStringRef v31 = cf1;
        if (!v18) {
          goto LABEL_47;
        }
LABEL_46:
        CFRelease(v18);
        goto LABEL_47;
      }
LABEL_29:
      int v53 = -1431655766;
      int v56 = -1431655766;
      context = v28;
      CFTypeRef cf = 0;
      int v52 = a3;
      uint64_t v54 = a4;
      int v55 = a5;
      uint64_t v57 = a2;
      int v59 = -1431655766;
      int v58 = a7;
      CFStringRef v39 = sub_10000B070("SecWarning");
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        CFIndex Count = CFDictionaryGetCount(v27);
        LODWORD(bytes) = 134217984;
        *(void *)((char *)&bytes + 4) = Count;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "Restoring backup items '%ld'", (uint8_t *)&bytes, 0xCu);
      }
      CFDictionaryApplyFunction(v27, (CFDictionaryApplierFunction)sub_10013CF98, &context);
      CFStringRef v31 = cf1;
      if (v18)
      {
        int v52 = -1;
        uint64_t v54 = 0;
        int v58 = 1;
        char v41 = sub_10000B070("SecWarning");
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
        {
          CFIndex v42 = CFDictionaryGetCount(v18);
          LODWORD(bytes) = 134217984;
          *(void *)((char *)&bytes + 4) = v42;
          _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "Restoring sysbound items '%ld'", (uint8_t *)&bytes, 0xCu);
        }
        CFDictionaryApplyFunction(v18, (CFDictionaryApplierFunction)sub_10013CF98, &context);
      }
      CFTypeRef v43 = cf;
      BOOL v17 = cf == 0;
      if (cf)
      {
        if (v16)
        {
          if (*v16)
          {
            CFRelease(*v16);
            CFTypeRef v43 = cf;
          }
          *int v16 = v43;
        }
        else
        {
          CFRelease(cf);
        }
      }
      if (sub_1000B14D4())
      {
        uint64_t v44 = sub_1000CD884(@"reset", 0);
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
        {
          LOWORD(bytes) = 0;
          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "Local keychain was reset; performing local resync",
            (uint8_t *)&bytes,
            2u);
        }

        long long v45 = +[CKKSViewManager manager];
        [v45 rpcResyncLocal:0 reply:&stru_1002F8F50];
      }
      if (!v18) {
        goto LABEL_47;
      }
      goto LABEL_46;
    }
    *(void *)&long long bytes = 0;
    *((void *)&bytes + 1) = &bytes;
    uint64_t v64 = 0x2000000000;
    v65[0] = 0;
    v60[0] = _NSConcreteStackBlock;
    v60[1] = 0x40000000;
    v60[2] = sub_10013CEF8;
    v60[3] = &unk_1002FBCF0;
    v60[4] = &bytes;
    v60[5] = a1;
    CFDictionaryRef v27 = a6;
    if (sub_1001381F8(a1, 2, v65, (uint64_t)v60))
    {
      int v32 = sub_10000B070("restore");
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        int v33 = "Successfully deleted nonsyncable items";
        int v34 = v32;
        uint32_t v35 = 2;
LABEL_25:
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, v33, buf, v35);
      }
    }
    else
    {
      int v36 = sub_10000B070("SecError");
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v37 = *(void *)(*((void *)&bytes + 1) + 24);
        *(_DWORD *)long long buf = 138412290;
        uint64_t v62 = v37;
        int v33 = "Unable to delete nonsyncable items prior to keychain restore: %@";
        int v34 = v36;
        uint32_t v35 = 12;
        goto LABEL_25;
      }
    }
    int v38 = *(const void **)(*((void *)&bytes + 1) + 24);
    if (v38)
    {
      *(void *)(*((void *)&bytes + 1) + 24) = 0;
      CFRelease(v38);
    }
    _Block_object_dispose(&bytes, 8);
    CFStringRef v28 = v49;
    goto LABEL_29;
  }
  CFStringRef v31 = cf1;
  sub_100012A40(-26275, a9, @"Keybag UUID (%@) mismatch with backup (%@)", cf1, v20);
  BOOL v17 = 1;
  if (v18) {
    goto LABEL_46;
  }
LABEL_47:
  if (v31) {
    CFRelease(v31);
  }
  return v17;
}

uint64_t sub_10013CE6C(uint64_t a1)
{
  if (!sub_100026908(*(void *)(a1 + 32), @"DELETE from genp;", *(CFTypeRef **)(a1 + 40))
    || !sub_100026908(*(void *)(a1 + 32), @"DELETE from inet;", *(CFTypeRef **)(a1 + 40))
    || !sub_100026908(*(void *)(a1 + 32), @"DELETE from cert;", *(CFTypeRef **)(a1 + 40)))
  {
    return 0;
  }
  uint64_t v2 = *(void *)(a1 + 32);
  unsigned __int8 v3 = *(CFTypeRef **)(a1 + 40);

  return sub_100026908(v2, @"DELETE from keys;", v3);
}

uint64_t sub_10013CEF8(uint64_t a1)
{
  int v2 = sub_100026908(*(void *)(a1 + 40), @"DELETE FROM genp WHERE sync = 0 AND NOT agrp IN ('com.apple.security.sos', 'com.apple.security.sos-usercredential', 'com.apple.security.ckks', 'com.apple.security.egoIdentities', 'com.apple.security.octagon') AND NOT ggrp <> '';",
         (CFTypeRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
  int v3 = v2 & sub_100026908(*(void *)(a1 + 40), @"DELETE FROM inet WHERE sync = 0 AND NOT agrp IN ('com.apple.security.sos', 'com.apple.security.sos-usercredential', 'com.apple.security.ckks', 'com.apple.security.egoIdentities', 'com.apple.security.octagon') AND NOT ggrp <> '';",
              (CFTypeRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
  int v4 = sub_100026908(*(void *)(a1 + 40), @"DELETE FROM cert WHERE sync = 0 AND NOT agrp IN ('com.apple.security.sos', 'com.apple.security.sos-usercredential', 'com.apple.security.ckks', 'com.apple.security.egoIdentities', 'com.apple.security.octagon') AND NOT ggrp <> '';",
         (CFTypeRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
  return v3 & v4 & sub_100026908(*(void *)(a1 + 40), @"DELETE FROM keys WHERE sync = 0 AND NOT agrp IN ('com.apple.security.sos', 'com.apple.security.sos-usercredential', 'com.apple.security.ckks', 'com.apple.security.egoIdentities', 'com.apple.security.octagon') AND NOT ggrp <> '';",
                                   (CFTypeRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24));
}

void sub_10013CF98(CFTypeRef cf, const void *a2, uint64_t a3)
{
  int v3 = (__CFString **)(a3 + 8);
  if (*(void *)(a3 + 8)) {
    return;
  }
  if (!cf)
  {
    sub_100012A40(-50, v3, @"class name %@ is not a string", 0);
    return;
  }
  CFTypeID v7 = CFGetTypeID(cf);
  if (v7 != CFStringGetTypeID())
  {
    sub_100012A40(-50, v3, @"class name %@ is not a string", cf);
    return;
  }
  if (CFEqual(cf, @"keybag-uuid")) {
    return;
  }
  uint64_t v8 = (uint64_t *)sub_10000C614(cf);
  if (!v8)
  {
    BOOL v15 = sub_10000B070("SecWarning");
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)long long buf = 138412290;
    uint64_t v27 = (uint64_t)cf;
    int v16 = "Ignoring unknown key class '%@'";
    BOOL v17 = v15;
    uint32_t v18 = 12;
    goto LABEL_28;
  }
  uint64_t v9 = (const __CFString **)v8;
  if (v8 != (uint64_t *)&off_1002FFC58)
  {
    context[0] = v8;
    context[1] = (uint64_t *)a3;
    if (a2)
    {
      CFTypeID v10 = CFGetTypeID(a2);
      if (v10 == CFArrayGetTypeID())
      {
        char v11 = sub_10000B070("SecWarning");
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          CFIndex Count = CFArrayGetCount((CFArrayRef)a2);
          int v13 = *(_DWORD *)(a3 + 48);
          *(_DWORD *)long long buf = 134218498;
          uint64_t v27 = Count;
          __int16 v28 = 2112;
          CFTypeRef v29 = cf;
          __int16 v30 = 1024;
          int v31 = v13;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Import %ld items of class %@ (filter %d)", buf, 0x1Cu);
        }
        CFStringRef v14 = *v9;
        CFArrayGetCount((CFArrayRef)a2);
        sub_10013D300(v14);
        v33.size_t length = CFArrayGetCount((CFArrayRef)a2);
        v33.id location = 0;
        CFArrayApplyFunction((CFArrayRef)a2, v33, (CFArrayApplierFunction)sub_10013D388, context);
        return;
      }
      CFTypeID v20 = CFGetTypeID(a2);
      BOOL v19 = v20 == CFDictionaryGetTypeID();
    }
    else
    {
      BOOL v19 = 0;
    }
    CFDictionaryRef v21 = sub_10000B070("SecWarning");
    BOOL v22 = os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT);
    if (v19)
    {
      if (v22)
      {
        int v23 = *(_DWORD *)(a3 + 48);
        *(_DWORD *)long long buf = 134218498;
        uint64_t v27 = 1;
        __int16 v28 = 2112;
        CFTypeRef v29 = cf;
        __int16 v30 = 1024;
        int v31 = v23;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "Import %ld items of class %@ (filter %d)", buf, 0x1Cu);
      }
      sub_10013D300(*v9);
      sub_10013D388(a2, context);
      return;
    }
    if (!v22) {
      return;
    }
    int v24 = *(_DWORD *)(a3 + 48);
    *(_DWORD *)long long buf = 138412546;
    uint64_t v27 = (uint64_t)cf;
    __int16 v28 = 1024;
    LODWORD(v29) = v24;
    int v16 = "Unknown value type for class %@ (filter %d)";
    BOOL v17 = v21;
    uint32_t v18 = 18;
LABEL_28:
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v16, buf, v18);
    return;
  }

  sub_100012A40(-50, v3, @"attempt to import an identity");
}

uint64_t sub_10013D300(const __CFString *a1)
{
  uint64_t result = CFStringGetLength(a1);
  if (result == 4)
  {
    memset(buffer, 170, 5);
    uint64_t result = CFStringGetCString(a1, buffer, 5, 0x8000100u);
    if (result) {
      return kdebug_trace();
    }
  }
  return result;
}

void sub_10013D388(CFTypeRef cf, uint64_t **a2)
{
  int v3 = a2[1];
  uint64_t v5 = v3[1];
  int v4 = (__CFString **)(v3 + 1);
  if (v5) {
    return;
  }
  if (!cf)
  {
    sub_100012A40(-50, v4, @"value %@ is not a dictionary", 0);
    return;
  }
  int v7 = BYTE4(v4[4][1].isa);
  CFTypeID v8 = CFGetTypeID(cf);
  CFTypeID TypeID = CFDictionaryGetTypeID();
  CFTypeID v10 = a2[1];
  if (v8 != TypeID)
  {
    sub_100012A40(-50, (__CFString **)v10 + 1, @"value %@ is not a dictionary", cf);
    return;
  }
  int v11 = *((_DWORD *)v10 + 4);
  uint64_t v12 = v10[3];
  int v13 = *a2;
  int v14 = *((_DWORD *)v10 + 8);
  BOOL v15 = (__CFString **)(v10 + 1);
  if (v11 == -1 && v12 == 0)
  {
    BOOL v19 = (const __CFDictionary **)sub_10011ACF4((uint64_t)*a2, (const __CFDictionary *)cf, *((_DWORD *)v10 + 8), (__CFString **)v10 + 1);
    if (v19) {
      goto LABEL_16;
    }
LABEL_65:
    char v35 = 1;
LABEL_66:
    if (a2[1][1])
    {
      int v36 = sub_10000B070("SecWarning");
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v37 = **a2;
        int v38 = (void *)a2[1][1];
        *(_DWORD *)long long buf = 138478339;
        *(void *)&uint8_t buf[4] = v19;
        *(_WORD *)&unsigned char buf[12] = 2112;
        *(void *)&buf[14] = v37;
        *(_WORD *)&buf[22] = 2112;
        __int16 v68 = v38;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "Failed to import an item (%{private}@) of class '%@': %@ - ignoring error.", buf, 0x20u);
      }
      CFStringRef v39 = a2[1];
      CFDictionaryRef v40 = (const void *)v39[1];
      if (v40)
      {
        v39[1] = 0;
        CFRelease(v40);
      }
    }
    else
    {
      char v41 = sub_10000B070("import");
      if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138477827;
        *(void *)&uint8_t buf[4] = v19;
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "imported item: %{private}@", buf, 0xCu);
      }
    }
    if ((v35 & 1) == 0) {
      CFRelease(v19);
    }
    return;
  }
  CFDataRef Value = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)cf, @"v_Data");
  if (!Value)
  {
    sub_100012A40(-26275, v15, @"No v_Data in backup dictionary %@", cf);
LABEL_64:
    BOOL v19 = 0;
    goto LABEL_65;
  }
  uint32_t v18 = (const __CFDictionary **)sub_10011B334(kCFAllocatorDefault, v13, Value, v11, v12, v15);
  BOOL v19 = v18;
  if (!v18) {
    goto LABEL_65;
  }
  if (!sub_10011A8B0((uint64_t)v18, v14, v15)) {
    goto LABEL_63;
  }
LABEL_16:
  if (!sub_100118DFC((uint64_t)v19, 1, (__CFString **)a2[1] + 1)) {
    goto LABEL_63;
  }
  CFDictionaryRef v20 = v19[6];
  if (!v20) {
    goto LABEL_52;
  }
  if (*((_DWORD *)a2[1] + 12) != 2)
  {
LABEL_32:
    int v23 = CFDictionaryGetValue(v20, kSecAttrMultiUser);
    if (qword_10035CF48 != -1) {
      dispatch_once(&qword_10035CF48, &stru_1002FAF50);
    }
    if (v23 && qword_10035CF50) {
      BOOL v24 = CFEqual(v23, (CFTypeRef)qword_10035CF50) != 0;
    }
    else {
      BOOL v24 = v23 == (const void *)qword_10035CF50;
    }
    uint64_t v25 = a2[1][5];
    if (v25 && *(unsigned char *)(v25 + 36))
    {
      if (v24)
      {
        CFDataRef v26 = sub_10000B070("SecWarning");
        if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138477827;
          *(void *)&uint8_t buf[4] = v19;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "system keychain not allowed in multi user mode for item: %{private}@", buf, 0xCu);
        }
        goto LABEL_63;
      }
      unsigned int v29 = *(_DWORD *)(v25 + 20);
      *(void *)long long buf = 0x104B57A5353A5AA7;
      *(_DWORD *)&uint8_t buf[8] = -1803342146;
      *(_DWORD *)&unsigned char buf[12] = bswap32(v29);
      CFDataRef v27 = CFDataCreate(0, buf, 16);
    }
    else
    {
      if (!v24)
      {
        if (qword_10035CF58 != -1) {
          dispatch_once(&qword_10035CF58, &stru_1002FAF90);
        }
        CFDataRef v28 = (const __CFData *)qword_10035CF60;
        if (!qword_10035CF60) {
          goto LABEL_63;
        }
        CFRetain((CFTypeRef)qword_10035CF60);
        goto LABEL_51;
      }
      CFDataRef v27 = CFDataCreateWithBytesNoCopy(0, byte_10026568C, 16, kCFAllocatorNull);
    }
    CFDataRef v28 = v27;
    if (v27)
    {
LABEL_51:
      sub_10011A9B8((uint64_t)v19, @"musr", v28, (__CFString **)a2[1] + 1);
      CFRelease(v28);
      goto LABEL_52;
    }
LABEL_63:
    CFRelease(v19);
    goto LABEL_64;
  }
  if (!sub_10013A508(v20, (uint64_t)*a2, v7 != 0))
  {
    if (!v7
      || (CFDictionaryRef v21 = CFDictionaryGetValue(v19[6], kSecAttrAccessible)) == 0
      || (BOOL v22 = v21, !CFEqual(v21, kSecAttrAccessibleWhenUnlockedThisDeviceOnly))
      && !CFEqual(v22, kSecAttrAccessibleAfterFirstUnlockThisDeviceOnly)
      && !CFEqual(v22, kSecAttrAccessibleWhenUnlockedThisDeviceOnly)
      && !CFEqual(v22, kSecAttrAccessibleWhenPasscodeSetThisDeviceOnly))
    {
      if (!CFDictionaryContainsKey(v19[6], kSecAttrTokenID))
      {
        CFDictionaryRef v20 = v19[6];
        if (v20) {
          goto LABEL_32;
        }
LABEL_52:
        __int16 v30 = (__CFString **)a2[1];
        if (*((_DWORD *)v30 + 12) != 1) {
          sub_100125890((uint64_t)v19, (CFDictionaryRef)cf, v30 + 1);
        }
        CFTypeRef cfa = 0;
        CFDataRef v31 = (const __CFData *)sub_10011B60C((void **)v19, (__CFString **)&cfa);
        if (cfa)
        {
          int v32 = sub_10000B070("SecError");
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138412290;
            *(void *)&uint8_t buf[4] = cfa;
            _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "import: failed to get the persistent ref: %@", buf, 0xCu);
          }
          CFTypeRef v33 = cfa;
          if (cfa)
          {
            CFTypeRef cfa = 0;
            CFRelease(v33);
          }
        }
        if (v31 && CFDataGetLength(v31) == 16)
        {
          int v34 = sub_10000B070("import");
          if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138477827;
            *(void *)&uint8_t buf[4] = v19;
            _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "Item already has a UUID persistent ref set: %{private}@", buf, 0xCu);
          }
        }
        else
        {
          CFUUIDRef v42 = CFUUIDCreate(kCFAllocatorDefault);
          CFUUIDBytes bytes = CFUUIDGetUUIDBytes(v42);
          CFDataRef v43 = CFDataCreate(kCFAllocatorDefault, &bytes.byte0, 16);
          CFTypeRef v64 = 0;
          sub_10011B6B0((uint64_t)v19, v43, (__CFString **)&v64);
          uint64_t v44 = sub_10000B070("import");
          if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 138478083;
            *(void *)&uint8_t buf[4] = v19;
            *(_WORD *)&unsigned char buf[12] = 2112;
            *(void *)&buf[14] = v64;
            _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "SecServerImportItem: generated a new persistentref UUID for item %{private}@: %@", buf, 0x16u);
          }
          if (v42) {
            CFRelease(v42);
          }
          if (v43) {
            CFRelease(v43);
          }
          CFTypeRef v45 = v64;
          if (v64)
          {
            CFTypeRef v64 = 0;
            CFRelease(v45);
          }
        }
        long long v46 = (__CFString **)a2[1];
        CFStringRef v47 = (const __CFString *)sub_100119CB8(v19, kSecAttrSharingGroup);
        if (!v47 || (v48 = v47, CFTypeID v49 = CFGetTypeID(v47), v49 != CFStringGetTypeID()) || !CFStringGetLength(v48))
        {
          long long v50 = sub_100119CB8(v19, kSecAttrAccessGroup);
          if (v50)
          {
            int v51 = v50;
            CFTypeID v52 = CFGetTypeID(v50);
            if (v52 == CFStringGetTypeID())
            {
              if (CFEqual(v51, @"com.apple.cfnetwork"))
              {
                CFDictionaryRef v53 = v19[2];
                if (v53 == (const __CFDictionary *)sub_10000C75C(@"inet", &qword_10035D020, (uint64_t)&unk_10035D018))
                {
                  int v56 = sub_100119CB8(v19, kSecAttrServer);
                  uint64_t v57 = sub_100119CB8(v19, kSecAttrProtocol);
                  int v58 = sub_100119CB8(v19, kSecAttrAuthenticationType);
                  if (v56)
                  {
                    int v59 = v58;
                    CFTypeID v60 = CFGetTypeID(v56);
                    if (v60 == CFStringGetTypeID())
                    {
                      if (v57)
                      {
                        CFTypeID v61 = CFGetTypeID(v57);
                        if (v61 == CFStringGetTypeID())
                        {
                          if (v59)
                          {
                            CFTypeID v62 = CFGetTypeID(v59);
                            if (v62 == CFStringGetTypeID())
                            {
                              long long v63 = sub_10000B070("item");
                              if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
                              {
                                *(_DWORD *)long long buf = 138477827;
                                *(void *)&uint8_t buf[4] = v19;
                                _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "Make this item syncable: %{private}@", buf, 0xCu);
                              }

                              sub_10011BA08((uint64_t)v19, v46 + 1);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
        uint64_t v54 = a2[1];
        uint64_t v55 = *v54;
        *(void *)long long buf = _NSConcreteStackBlock;
        *(void *)&uint8_t buf[8] = 0x40000000;
        *(void *)&uint8_t buf[16] = sub_10011DDE8;
        __int16 v68 = &unk_1002FA9B0;
        id v69 = v19;
        __int16 v70 = 256;
        if ((sub_10011C214((uint64_t)v19, v55, (__CFString **)v54 + 1, (uint64_t)buf) & 1) == 0)
        {
          sub_10011B874((uint64_t)v19, 0);
          sub_10011DD70((uint64_t)v19, *a2[1], 0, 1, (__CFString **)a2[1] + 1);
        }
        char v35 = 0;
        goto LABEL_66;
      }
    }
  }

  CFRelease(v19);
}

BOOL sub_10013DCE0(const void *a1, int a2)
{
  CFErrorRef err = 0;
  cf[1] = 0;
  long long v16 = 0u;
  long long v14 = 0u;
  cf[0] = a1;
  DWORD2(v16) = a2;
  v20[0] = sub_10000C75C(@"genp", &qword_10035D010, (uint64_t)&unk_10035D008);
  v20[1] = sub_10000C75C(@"inet", &qword_10035D020, (uint64_t)&unk_10035D018);
  int v20[2] = sub_10000C75C(@"keys", &qword_10035D040, (uint64_t)&unk_10035D038);
  BOOL v2 = 0;
  unint64_t v3 = 0;
  v20[3] = sub_10000C75C(@"cert", &qword_10035D030, (uint64_t)&unk_10035D028);
  do
  {
    int v4 = (uint64_t *)v20[v3];
    uint64_t v5 = (const void **)sub_10000C7F0((uint64_t)v4, 0, 0, 0, (__CFString **)&err);
    if (!v5) {
      break;
    }
    char v6 = v5;
    *(void *)&long long v14 = v5;
    v5[13] = (const void *)-1;
    BOOL v7 = sub_100010A40((uint64_t)sub_10013DEFC, (uint64_t)&v14, (__CFString **)&err);
    sub_10000C2C4(v6, 0);
    CFTypeRef v8 = cf[1];
    if (cf[1])
    {
      cf[1] = 0;
      CFRelease(v8);
    }
    if (err) {
      char v9 = v7;
    }
    else {
      char v9 = 1;
    }
    if ((v9 & 1) != 0 || CFErrorGetCode(err) != -25300)
    {
      int v11 = sub_10000B070("SecError");
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = *v4;
        *(_DWORD *)long long buf = 138412290;
        uint64_t v19 = v12;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "Class %@ not up to date", buf, 0xCu);
      }
      return v2;
    }
    CFErrorRef v10 = err;
    if (err)
    {
      CFErrorRef err = 0;
      CFRelease(v10);
    }
    BOOL v2 = v3++ > 2;
  }
  while (v3 != 4);
  return v2;
}

void sub_10013DEFC(sqlite3_stmt *a1, _DWORD *a2)
{
  int v3 = a2[10];
  CFDataRef v4 = sub_100013C54(a1, 1);
  if (!v4)
  {
    ++a2[8];
    return;
  }
  CFDataRef v5 = v4;
  unint64_t Length = CFDataGetLength(v4);
  BytePtr = CFDataGetBytePtr(v5);
  if (Length < 8)
  {
    sub_100012A40(-26275, (__CFString **)(*(void *)a2 + 40), @"check_generation: Check for underflow");
LABEL_5:
    ++a2[8];
    goto LABEL_6;
  }
  if ((v3 == 0) == *((_DWORD *)BytePtr + 1) > 0x1Fu) {
    goto LABEL_5;
  }
LABEL_6:

  CFRelease(v5);
}

void sub_10013DFC4(uint64_t a1, unsigned char *a2)
{
  uint64_t v9 = 0;
  CFErrorRef v10 = &v9;
  uint64_t v11 = 0x2000000000;
  char v12 = 0;
  int v8 = -1431655766;
  if (!sub_10001BA9C(dword_10035D2B0, 0, &v8) && (v8 & 2) != 0)
  {
    CFDataRef v5 = *(CFTypeRef **)(a1 + 32);
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 0x40000000;
    _DWORD v6[2] = sub_10013E0E0;
    v6[3] = &unk_1002FBD18;
    void v6[4] = &v9;
    long long v7 = *(_OWORD *)(a1 + 40);
    int v4 = sub_10002AF90(dword_10035D2B0, v5, (uint64_t)v6);
    if (v4) {
      LOBYTE(v4) = *((unsigned char *)v10 + 24);
    }
    else {
      *((unsigned char *)v10 + 24) = 0;
    }
  }
  else
  {
    LOBYTE(v4) = sub_100012A40(-909, *(__CFString ***)(a1 + 32), @"No key roll in progress.");
    *((unsigned char *)v10 + 24) = v4;
  }
  *a2 = v4;
  _Block_object_dispose(&v9, 8);
}

void sub_10013E0E0(void *a1)
{
  CFTypeRef cf = 0;
  int v8 = -1;
  BOOL v2 = sub_10013B9EC(a1[5], 0, &v8, 0, (__CFString **)&cf);
  if (v2)
  {
    CFDictionaryRef v3 = v2;
    if (cf)
    {
      int v4 = sub_10000B070("SecError");
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        CFTypeRef v11 = cf;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "Ignoring export error: %@ during roll export", buf, 0xCu);
      }
      CFTypeRef v5 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        CFRelease(v5);
      }
    }
    *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = sub_10013C868(a1[5], a1[6], -1, 0, dword_10035D2B0, v3, 0, 1, (__CFString **)&cf);
    if (cf)
    {
      char v6 = sub_10000B070("SecError");
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 138412290;
        CFTypeRef v11 = cf;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "Ignoring export error: %@ during roll export", buf, 0xCu);
      }
      CFTypeRef v7 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        CFRelease(v7);
      }
    }
    CFRelease(v3);
  }
}

const void *sub_10013E280(uint64_t a1)
{
  BOOL v2 = *(const void **)(a1 + 40);
  CFDictionaryRef v3 = off_100300570;
  int v4 = (const void **)&off_1002FE3E8;
  while (1)
  {
    uint64_t result = *v4;
    if (!v2 || !result)
    {
      if (result == v2) {
        goto LABEL_8;
      }
      goto LABEL_7;
    }
    uint64_t result = (const void *)CFEqual(result, v2);
    if (result) {
      break;
    }
LABEL_7:
    char v6 = (const void **)v3[1];
    ++v3;
    int v4 = v6;
    if (!v6) {
      goto LABEL_8;
    }
  }
  int v4 = (const void **)*v3;
LABEL_8:
  **(void **)(a1 + 32) = v4;
  return result;
}

void sub_10013E34C(id a1)
{
  v4[0] = kSecAttrUUID;
  v4[1] = @"zone";
  v4[2] = @"ownr";
  v4[3] = @"type";
  void v4[4] = @"deln";
  void v4[5] = kSecValueData;
  CFTypeID v1 = +[NSArray arrayWithObjects:v4 count:6];
  uint64_t v2 = +[NSSet setWithArray:v1];
  CFDictionaryRef v3 = (void *)qword_10035D078;
  qword_10035D078 = v2;
}

void sub_10013E550(id a1)
{
  byte_10035BC68 = _os_feature_enabled_impl();
  CFTypeID v1 = sub_10000B070("octagon");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_10035BC68) {
      CFStringRef v2 = @"enabled";
    }
    else {
      CFStringRef v2 = @"disabled";
    }
    int v3 = 138412290;
    CFStringRef v4 = v2;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "SOS Feature is %@ (via feature flags)", (uint8_t *)&v3, 0xCu);
  }
}

void sub_10013E630(id a1)
{
  byte_10035D090 = _os_feature_enabled_impl();
  CFTypeID v1 = sub_10000B070("octagon");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_10035D090) {
      CFStringRef v2 = "enabled";
    }
    else {
      CFStringRef v2 = "disabled";
    }
    int v3 = 136315138;
    CFStringRef v4 = v2;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "OctagonSupportsMultiuser is %s", (uint8_t *)&v3, 0xCu);
  }
}

void sub_10013E710(id a1)
{
  byte_10035D0A0 = _os_feature_enabled_impl();
  CFTypeID v1 = sub_10000B070("octagon");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_10035D0A0) {
      CFStringRef v2 = "enabled";
    }
    else {
      CFStringRef v2 = "disabled";
    }
    int v3 = 136315138;
    CFStringRef v4 = v2;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "DeferSOSFromSignIn is %s", (uint8_t *)&v3, 0xCu);
  }
}

void sub_10013E7F0(id a1)
{
  byte_10035D0B0 = _os_feature_enabled_impl();
  CFTypeID v1 = sub_10000B070("keychain");
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    if (byte_10035D0B0) {
      CFStringRef v2 = "enabled";
    }
    else {
      CFStringRef v2 = "disabled";
    }
    int v3 = 136315138;
    CFStringRef v4 = v2;
    _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_DEFAULT, "System Keychain Always Supported set via feature flag to %s", (uint8_t *)&v3, 0xCu);
  }
}

void sub_10013F064()
{
  os_unfair_lock_lock((os_unfair_lock_t)&unk_10035D0C0);
  DistributedCenter = CFNotificationCenterGetDistributedCenter();
  os_unfair_lock_unlock((os_unfair_lock_t)&unk_10035D0C0);

  CFNotificationCenterPostNotificationWithOptions(DistributedCenter, @"com.apple.security.shared-items-changed", 0, 0, 0);
}

void sub_10013F0C8()
{
  if (qword_10035D0C8 != -1) {
    dispatch_once(&qword_10035D0C8, &stru_100303B58);
  }
  uint64_t v0 = qword_10035D0D0;

  dispatch_source_merge_data(v0, 1uLL);
}

void sub_10013F120(id a1)
{
  CFTypeID v1 = sub_100029A10("SecKeychainChanged", 1);
  qword_10035D0D0 = (uint64_t)v1;
  context = dispatch_get_context(v1);
  context[2] = _Block_copy(&stru_100303B98);

  dispatch_activate(v1);
}

void sub_10013F184(id a1)
{
  uint32_t v1 = notify_post("com.apple.security.keychainchanged");
  if (v1)
  {
    uint32_t v2 = v1;
    int v3 = sub_10000B070("SecError");
    if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v8 = 136315394;
    uint64_t v9 = "com.apple.security.keychainchanged";
    __int16 v10 = 1024;
    uint32_t v11 = v2;
    CFStringRef v4 = "notify_post %s returned: %u";
    CFTypeRef v5 = v3;
    uint32_t v6 = 18;
  }
  else
  {
    CFTypeRef v7 = sub_10000B070("item");
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v8 = 136315138;
    uint64_t v9 = "com.apple.security.keychainchanged";
    CFStringRef v4 = "Sent %s";
    CFTypeRef v5 = v7;
    uint32_t v6 = 12;
  }
  _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v4, (uint8_t *)&v8, v6);
}

uint64_t sub_10013F2A0(uint64_t a1, int *a2, CFTypeRef *a3)
{
  uint64_t v33 = 0;
  int v34 = &v33;
  uint64_t v35 = 0x2000000000;
  char v36 = 1;
  uint64_t v29 = 0;
  __int16 v30 = (CFTypeRef *)&v29;
  uint64_t v31 = 0x2000000000;
  CFTypeRef v32 = 0;
  uint64_t v25 = 0;
  CFDataRef v26 = &v25;
  uint64_t v27 = 0x2000000000;
  char v28 = 0;
  v24[0] = _NSConcreteStackBlock;
  v24[1] = 0x40000000;
  _OWORD v24[2] = sub_10013F680;
  void v24[3] = &unk_100303BE8;
  void v24[5] = &v25;
  v24[6] = a1;
  uint8_t v24[4] = &v33;
  char v6 = sub_10002742C(a1, @"SELECT name FROM sqlite_master WHERE type='table' AND name='tversion'", &v32, (uint64_t)v24);
  if (*((unsigned char *)v34 + 24)) {
    char v7 = v6;
  }
  else {
    char v7 = 0;
  }
  *((unsigned char *)v34 + 24) = v7;
  if (v7)
  {
    if (*((unsigned char *)v26 + 24))
    {
      v23[0] = _NSConcreteStackBlock;
      v23[1] = 0x40000000;
      _OWORD v23[2] = sub_10013F710;
      v23[3] = &unk_100303C30;
      void v23[4] = &v33;
      void v23[5] = a1;
      v23[6] = a2;
      int v8 = sub_10002742C(a1, @"SELECT version FROM tversion", v30 + 3, (uint64_t)v23);
      if (*((unsigned char *)v34 + 24)) {
        int v9 = v8;
      }
      else {
        int v9 = 0;
      }
      *((unsigned char *)v34 + 24) = v9;
      if (v9 == 1 && *(unsigned __int16 *)a2 >= 9u)
      {
        v22[0] = _NSConcreteStackBlock;
        v22[1] = 0x40000000;
        v22[2] = sub_10013F7A0;
        v22[3] = &unk_100303C78;
        void v22[4] = &v33;
        v22[5] = &v29;
        v22[6] = a2;
        v22[7] = a1;
        sub_10002742C(a1, @"SELECT minor FROM tversion WHERE version = ?", v30 + 3, (uint64_t)v22);
        *((unsigned char *)v34 + 24) = 1;
      }
    }
    else
    {
      __int16 v10 = sub_10000B070("upgr");
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        CFTypeRef v11 = v30[3];
        *(_DWORD *)long long buf = 138412290;
        *(void *)int v38 = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "no tversion table, will setup a new database: %@", buf, 0xCu);
      }
      *a2 = 0;
    }
  }
  else
  {
    sub_1000263CC(11, a3, @"Failed to read sqlite_master table: %@", v30[3]);
  }
  char v12 = sub_10000B070("upgr");
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = *a2;
    int v14 = *((unsigned __int8 *)v34 + 24);
    CFTypeRef v15 = v30[3];
    *(_DWORD *)long long buf = 67109634;
    *(_DWORD *)int v38 = v13;
    *(_WORD *)&v38[4] = 1024;
    *(_DWORD *)&v38[6] = v14;
    __int16 v39 = 2112;
    CFTypeRef v40 = v15;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "database version is: 0x%08x : %d : %@", buf, 0x18u);
  }
  long long v16 = sub_10000B070("upgr");
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    uid_t v17 = getuid();
    uid_t v18 = geteuid();
    *(_DWORD *)long long buf = 67109376;
    *(_DWORD *)int v38 = v17;
    *(_WORD *)&v38[4] = 1024;
    *(_DWORD *)&v38[6] = v18;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "UID: %d  EUID: %d", buf, 0xEu);
  }
  CFTypeRef v19 = v30[3];
  if (v19) {
    CFRelease(v19);
  }
  uint64_t v20 = *((unsigned __int8 *)v34 + 24);
  _Block_object_dispose(&v25, 8);
  _Block_object_dispose(&v29, 8);
  _Block_object_dispose(&v33, 8);
  return v20;
}

uint64_t sub_10013F680(void *a1, sqlite3_stmt *a2)
{
  uint64_t v3 = a1[6];
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  _DWORD v5[2] = sub_10013F90C;
  v5[3] = &unk_100303BC0;
  void v5[4] = a1[5];
  uint64_t result = sub_1000275B0(v3, a2, 0, (uint64_t)v5);
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = result;
  return result;
}

uint64_t sub_10013F710(void *a1, sqlite3_stmt *a2)
{
  uint64_t v3 = a1[5];
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  _DWORD v5[2] = sub_10013F8C8;
  v5[3] = &unk_100303C08;
  void v5[4] = a1[6];
  void v5[5] = a2;
  uint64_t result = sub_1000275B0(v3, a2, 0, (uint64_t)v5);
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = result;
  return result;
}

uint64_t sub_10013F7A0(uint64_t a1, sqlite3_stmt *a2)
{
  CFStringRef v4 = (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  uint64_t v5 = sqlite3_bind_int(a2, 1, **(_DWORD **)(a1 + 48));
  uint64_t result = sub_10000ED34(v5, a2, v4, @"bind_int[%d]", 1);
  if (result)
  {
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000;
    _OWORD v9[2] = sub_10013F878;
    v9[3] = &unk_100303C50;
    uint64_t v8 = *(void *)(a1 + 48);
    uint64_t v7 = *(void *)(a1 + 56);
    void v9[4] = a2;
    void v9[5] = v8;
    uint64_t result = sub_1000275B0(v7, a2, 0, (uint64_t)v9);
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  return result;
}

sqlite3_int64 sub_10013F878(uint64_t a1, unsigned char *a2)
{
  sqlite3_int64 result = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 32), 0);
  **(_DWORD **)(a1 + 40) |= (result << 8) & 0xFF00FF00;
  *a2 = 1;
  return result;
}

uint64_t sub_10013F8C8(uint64_t a1, unsigned char *a2)
{
  uint64_t result = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 40), 0);
  **(_DWORD **)(a1 + 32) = result;
  if (result) {
    *a2 = 1;
  }
  return result;
}

uint64_t sub_10013F90C(uint64_t result, unsigned char *a2)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  *a2 = 1;
  return result;
}

CFDataRef sub_10013F924()
{
  CFUUIDRef v0 = CFUUIDCreate(kCFAllocatorDefault);
  CFUUIDBytes v3 = CFUUIDGetUUIDBytes(v0);
  CFDataRef v1 = CFDataCreate(kCFAllocatorDefault, &v3.byte0, 16);
  if (v0) {
    CFRelease(v0);
  }
  return v1;
}

uint64_t sub_10013F98C(uint64_t a1)
{
  v7.tv_sec = 0xAAAAAAAAAAAAAAAALL;
  *(void *)&v7.tv_usec = 0xAAAAAAAAAAAAAAAALL;
  gettimeofday(&v7, 0);
  int64_t v2 = 1000 * (v7.tv_sec - *(void *)a1) + *(_DWORD *)(a1 + 8) / -1000 + v7.tv_usec / 1000;
  uint64_t v3 = 1;
  if (v2 >= 101)
  {
    unint64_t v4 = 1000 * (v7.tv_sec - *(void *)a1) + *(_DWORD *)(a1 + 8) / -1000 + v7.tv_usec / 1000;
    do
    {
      int64_t v2 = v4 / 0xA;
      v3 *= 10;
      BOOL v5 = v4 > 0x3F1;
      v4 /= 0xAuLL;
    }
    while (v5);
  }
  return v3 * v2;
}

uint64_t sub_10013FA54(void *a1, sqlite3_stmt *a2)
{
  int64_t v2 = (CFTypeRef *)(*(void *)(a1[4] + 8) + 24);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 0x40000000;
  _DWORD v5[2] = sub_1001404C8;
  v5[3] = &unk_100303CA0;
  uint64_t v3 = a1[6];
  void v5[4] = a1[5];
  void v5[5] = a2;
  void v5[6] = a1[7];
  return sub_1000275B0(v3, a2, v2, (uint64_t)v5);
}

void sub_10013FADC(uint64_t a1, uint64_t a2)
{
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    int v14 = 0;
    uint64_t v4 = **(void **)(a1 + 40);
    if (qword_10035CF68 != -1) {
      dispatch_once(&qword_10035CF68, &stru_1002FAFD0);
    }
    BOOL v5 = (CFDictionaryRef *)sub_10000C7F0(v4, (const void *)qword_10035CF70, 0, 0, &v14);
    char v6 = v14;
    if (v14)
    {
      int v14 = 0;
      CFRelease(v6);
    }
    uint64_t v7 = *(void *)(a1 + 48);
    v13[0] = _NSConcreteStackBlock;
    v13[1] = 0x40000000;
    size_t v13[2] = sub_10013FC80;
    void v13[3] = &unk_100303D68;
    v13[4] = a2;
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 0x40000000;
    _OWORD v9[2] = sub_10013FC94;
    v9[3] = &unk_100303D90;
    void v9[4] = *(void *)(a1 + 32);
    void v9[5] = a2;
    long long v10 = *(_OWORD *)(a1 + 56);
    uint64_t v11 = v7;
    char v12 = v5;
    sub_10011C750(v5, v7, (CFTypeRef *)&v14, &stru_100303D08, &stru_100303D48, 0, (uint64_t)v13, (uint64_t)v9);
    if (v5) {
      sub_10000C2C4((const void **)v5, 0);
    }
    uint64_t v8 = v14;
    if (v14)
    {
      int v14 = 0;
      CFRelease(v8);
    }
  }
}

uint64_t sub_10013FC68(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(a2 + 16))(a2, a1);
}

uint64_t sub_10013FC80(uint64_t a1, sqlite3_stmt *a2)
{
  return sub_10000E8B0(a2, 1, *(const __CFString **)(a1 + 32), 0);
}

void sub_10013FC94(uint64_t a1, void **a2)
{
  CFTypeRef v30 = 0;
  CFTypeRef cf = 0;
  uint64_t v4 = qword_10035D0D8;
  qword_10035D0D8 = 0;
  uint64_t v5 = *(void *)(a1 + 40);
  if (v5) {
    CFRetain(*(CFTypeRef *)(a1 + 40));
  }
  qword_10035D0D8 = v5;
  CFDataRef v6 = (const __CFData *)sub_10011B60C(a2, (__CFString **)&cf);
  if (cf)
  {
    uint64_t v7 = sub_10000B070("SecError");
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v33 = (uint64_t)cf;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "upgr-phase3: failed to get persistent ref error: %@", buf, 0xCu);
    }
    if (sub_100140228((__CFError *)cf, *(__CFError ***)(a1 + 48)))
    {
LABEL_7:
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
      **(unsigned char **)(a1 + 56) = 1;
      if (qword_10035D0D8) {
        CFRelease((CFTypeRef)qword_10035D0D8);
      }
      qword_10035D0D8 = v4;
      CFTypeRef v8 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
LABEL_65:
        CFRelease(v8);
        return;
      }
      return;
    }
    CFTypeRef v9 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v9);
    }
  }
  uint64_t v10 = sub_10011B728(a2, (__CFString **)&v30);
  if (v30)
  {
    uint64_t v11 = sub_10000B070("SecError");
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      uint64_t v33 = (uint64_t)v30;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "upgr-phase3: failed to get rowID error: %@", buf, 0xCu);
    }
  }
  uint64_t v12 = *a2[2];
  CFStringRef v13 = @"YES";
  if (v6 && CFDataGetLength(v6) == 16) {
    CFStringRef v13 = @"NO";
  }
  int v14 = sub_10000B070("upgr-phase3");
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134218498;
    uint64_t v33 = v10;
    __int16 v34 = 2112;
    *(void *)uint64_t v35 = v12;
    *(_WORD *)&v35[8] = 2112;
    *(void *)&v35[10] = v13;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "inspecting item at row %lld in table %@, should add persistref uuid?: %@", buf, 0x20u);
  }
  CFTypeRef v15 = v30;
  if (v30)
  {
    CFTypeRef v30 = 0;
    CFRelease(v15);
  }
  CFTypeRef v16 = cf;
  if (cf)
  {
    CFTypeRef cf = 0;
    CFRelease(v16);
  }
  if (CFStringCompare(v13, @"YES", 0)) {
    return;
  }
  uid_t v17 = sub_10000B070("upgr-phase3");
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    uint64_t v33 = v10;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "upgrading item persistentref at row id %lld", buf, 0xCu);
  }
  CFDataRef v18 = sub_10013F924();
  char v19 = sub_10011A9B8((uint64_t)a2, kSecAttrPersistentReference, v18, (__CFString **)&cf);
  if (v18) {
    CFRelease(v18);
  }
  if (cf) {
    char v20 = 0;
  }
  else {
    char v20 = v19;
  }
  if ((v20 & 1) == 0)
  {
    uint64_t v25 = sub_10000B070("SecError");
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138478083;
      uint64_t v33 = (uint64_t)a2;
      __int16 v34 = 2112;
      *(void *)uint64_t v35 = cf;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "upgr-phase3: failed to set persistentref for item:%{private}@, error:%@", buf, 0x16u);
    }
    if (cf)
    {
      if (sub_100140228((__CFError *)cf, *(__CFError ***)(a1 + 48))) {
        goto LABEL_7;
      }
      CFTypeRef v26 = cf;
      if (cf)
      {
        CFTypeRef cf = 0;
        goto LABEL_60;
      }
    }
    else if ((v19 & 1) == 0)
    {
      uint64_t v27 = sub_10000B070("SecError");
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "upgr-phase3: SecDbItemSetValueWithName returned false", buf, 2u);
      }
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
      **(unsigned char **)(a1 + 56) = 1;
      if (qword_10035D0D8) {
        CFRelease((CFTypeRef)qword_10035D0D8);
      }
      qword_10035D0D8 = v4;
      return;
    }
LABEL_63:
    if (!v4) {
      return;
    }
    CFTypeRef v8 = (CFTypeRef)v4;
    goto LABEL_65;
  }
  CFTypeRef v29 = 0;
  int v21 = sub_10011E680(a2, a2, *(void *)(a1 + 64), 0, *(unsigned __int8 *)(*(void *)(a1 + 72) + 154), (__CFString **)&v29);
  CFTypeRef v22 = v29;
  int v23 = sub_10000B070("upgr-phase3");
  BOOL v24 = os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT);
  if (v21 && !v22)
  {
    if (v24)
    {
      *(_DWORD *)long long buf = 138478083;
      uint64_t v33 = (uint64_t)a2;
      __int16 v34 = 1024;
      *(_DWORD *)uint64_t v35 = 1;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "updated item %{private}@: %d", buf, 0x12u);
    }
    goto LABEL_61;
  }
  if (v24)
  {
    *(_DWORD *)long long buf = 138478339;
    uint64_t v33 = (uint64_t)a2;
    __int16 v34 = 1024;
    *(_DWORD *)uint64_t v35 = v21;
    *(_WORD *)&void v35[4] = 2112;
    *(void *)&v35[6] = v29;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "phase3: failed to update item %{private}@: %d, error: %@", buf, 0x1Cu);
  }
  if (!v29) {
    goto LABEL_61;
  }
  if (!sub_100140228((__CFError *)v29, *(__CFError ***)(a1 + 48)))
  {
    CFTypeRef v26 = v29;
    if (!v29) {
      goto LABEL_61;
    }
    CFTypeRef v29 = 0;
LABEL_60:
    CFRelease(v26);
LABEL_61:
    CFTypeRef v28 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v28);
    }
    goto LABEL_63;
  }
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  **(unsigned char **)(a1 + 56) = 1;
  if (qword_10035D0D8) {
    CFRelease((CFTypeRef)qword_10035D0D8);
  }
  qword_10035D0D8 = v4;
  CFTypeRef v8 = v29;
  if (v29)
  {
    CFTypeRef v29 = 0;
    goto LABEL_65;
  }
}

BOOL sub_10014020C(id a1, const SecDbAttr *a2)
{
  return a2->var1 == 8;
}

BOOL sub_10014021C(id a1, const SecDbAttr *a2)
{
  return (LOBYTE(a2->var2) >> 1) & 1;
}

uint64_t sub_100140228(__CFError *a1, __CFError **a2)
{
  CFIndex Code = CFErrorGetCode(a1);
  if (Code > -25331)
  {
    switch(Code)
    {
      case -25330:
        uint64_t v11 = sub_10000B070("upgr-phase3");
        BOOL v15 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
        uint64_t result = 0;
        if (!v15) {
          return result;
        }
        int v16 = 138412290;
        uid_t v17 = a1;
        CFTypeRef v8 = "authentication needed: %@";
        break;
      case -25308:
        CFStringRef v13 = sub_10000B070("upgr-phase3");
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          int v16 = 138412290;
          uid_t v17 = a1;
          int v14 = "interaction not allowed: %@";
          goto LABEL_20;
        }
LABEL_21:
        if (a1)
        {
          CFRetain(a1);
          if (a2 && !*a2) {
            *a2 = a1;
          }
          else {
            CFRelease(a1);
          }
        }
        return 1;
      case -25291:
        uint64_t v11 = sub_10000B070("upgr-phase3");
        BOOL v12 = os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT);
        uint64_t result = 0;
        if (!v12) {
          return result;
        }
        int v16 = 138412290;
        uid_t v17 = a1;
        CFTypeRef v8 = "AKS is unavailable: %@";
        break;
      default:
        goto LABEL_25;
    }
    CFTypeRef v9 = v11;
    uint32_t v10 = 12;
    goto LABEL_17;
  }
  if (Code == -536870186 || Code == -536870184)
  {
    CFStringRef v13 = sub_10000B070("upgr-phase3");
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = 138412290;
      uid_t v17 = a1;
      int v14 = "AKS is not ready/timing out: %@";
LABEL_20:
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v14, (uint8_t *)&v16, 0xCu);
      goto LABEL_21;
    }
    goto LABEL_21;
  }
  if (Code != -26275)
  {
LABEL_25:
    if (!a1) {
      return 0;
    }
    CFRetain(a1);
    if (!a2 || *a2)
    {
      CFRelease(a1);
      return 0;
    }
    uint64_t result = 0;
    *a2 = a1;
    return result;
  }
  uint64_t v5 = sub_10000B070("upgr-phase3");
  BOOL v6 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  uint64_t result = 0;
  if (v6)
  {
    LOWORD(v16) = 0;
    CFTypeRef v8 = "failed to decode keychain item";
    CFTypeRef v9 = v5;
    uint32_t v10 = 2;
LABEL_17:
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v16, v10);
    return 0;
  }
  return result;
}

void sub_1001404C8(uint64_t a1, unsigned char *a2)
{
  sqlite3_int64 v4 = sqlite3_column_int64(*(sqlite3_stmt **)(a1 + 40), 0);
  sqlite3_int64 valuePtr = v4;
  uint64_t v5 = sub_10000B070("upgr-phase3");
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 134217984;
    sqlite3_int64 v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "picked up rowid: %lld that needs a persistref", buf, 0xCu);
  }
  CFNumberRef v6 = CFNumberCreate(kCFAllocatorDefault, kCFNumberLongLongType, &valuePtr);
  CFNumberRef v7 = v6;
  if (qword_10035D0D8 && CFNumberCompare(v6, (CFNumberRef)qword_10035D0D8, 0) != kCFCompareGreaterThan)
  {
LABEL_7:
    if (!v7) {
      return;
    }
    goto LABEL_8;
  }
  if (CFArrayGetCount(*(CFArrayRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24)) <= 99)
  {
    CFArrayAppendValue(*(CFMutableArrayRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), v7);
    goto LABEL_7;
  }
  *a2 = 1;
  **(unsigned char **)(a1 + 4_Block_object_dispose(&STACK[0x3F0], 8) = 1;
  if (!v7) {
    return;
  }
LABEL_8:
  CFRelease(v7);
}

uint64_t sub_100140618(uint64_t a1, uint8_t *a2, uint64_t a3, int a4, unsigned char *a5, CFTypeRef *a6)
{
  int v79 = 0;
  int v11 = 0;
  if (sub_10002B120())
  {
    if (qword_10035CC68 != -1) {
      dispatch_once(&qword_10035CC68, &stru_1002F7BD0);
    }
    if (byte_10035CC60)
    {
      int v11 = 0;
    }
    else
    {
      if (qword_10035CC58 != -1) {
        dispatch_once(&qword_10035CC58, &stru_1002F7B90);
      }
      int v11 = byte_10035CC54;
    }
  }
  int v73 = a4;
  if (a4)
  {
    if (v11)
    {
      BOOL v12 = sub_10000B070("upgr");
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "created new db, setting edu bag version", buf, 2u);
      }
      sub_1001413DC(a3);
    }
    goto LABEL_18;
  }
  int v13 = sub_10013F2A0(a3, &v79, a6);
  if ((v13 & v11) == 1)
  {
    char v14 = sub_100141324(a3);
    BOOL v15 = sub_10000B070("upgr");
    BOOL v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
    if ((v14 & 1) == 0)
    {
      if (v16)
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "must transcrypt", buf, 2u);
      }
      blocCFIndex k = 0;
      *(_DWORD *)long long buf = -1431655766;
      uint64_t v49 = sub_10001AE90(-6, buf);
      if (sub_100029664(v49, &block, @"aks_get_lock_state failed: %x", v49))
      {
        if ((buf[0] & 1) == 0)
        {
          long long v63 = sub_10000B070("upgr");
          if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
          {
            *(_WORD *)long long buf = 0;
            _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "using default keybag", buf, 2u);
          }
          dword_10035D2B0 = 0;
          int v17 = 1;
          goto LABEL_20;
        }
      }
      else
      {
        long long v50 = sub_10000B070("upgr");
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 138412290;
          *(void *)&uint8_t buf[4] = block;
          _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "error querying system keybag lock state: %@", buf, 0xCu);
        }
        CFTypeRef v51 = block;
        if (block)
        {
          blocCFIndex k = 0;
          CFRelease(v51);
        }
      }
      CFTypeRef v64 = sub_10000B070("SecError");
      if (os_log_type_enabled(v64, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "Cannot transcrypt because system keybag not (yet) unlocked!! ", buf, 2u);
      }
      sub_100012A40(-25291, (__CFString **)a6, @"transcryption error: system keybag not (yet) unlocked");
      int v17 = 0;
LABEL_111:
      long long v65 = sub_10000B070("SecError");
      if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v66 = "";
        if (v73) {
          unsigned int v66 = "from v0 ";
        }
        if (a6) {
          CFTypeRef v67 = *a6;
        }
        else {
          CFTypeRef v67 = 0;
        }
        *(_DWORD *)long long buf = 136315394;
        *(void *)&uint8_t buf[4] = v66;
        *(_WORD *)&unsigned char buf[12] = 2112;
        *(void *)&buf[14] = v67;
        _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "Upgrade %sfailed: %@", buf, 0x16u);
      }
      uint64_t v61 = 0;
      if (!a6) {
        goto LABEL_103;
      }
      goto LABEL_119;
    }
    if (v16)
    {
      *(_WORD *)long long buf = 0;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "already transcrypted", buf, 2u);
LABEL_18:
      int v17 = 0;
      goto LABEL_20;
    }
  }
  int v17 = 0;
  if (!v13) {
    goto LABEL_111;
  }
LABEL_20:
  int v18 = v79;
  blocCFIndex k = 0;
  p_blocCFIndex k = (uint64_t)&block;
  uint64_t v91 = 0x2000000000;
  LOBYTE(v92) = 0;
  values = 0;
  p_values = &values;
  uint64_t v87 = 0x2000000000;
  char v88 = 1;
  uint64_t v81 = 0;
  int v82 = &v81;
  uint64_t v83 = 0x2000000000;
  CFTypeRef v84 = 0;
  if (a6) {
    *a6 = 0;
  }
  if (v18 != 2060)
  {
    if (v18 == 12 && (v18 & 0xFF00u) >= 0x801)
    {
      char v19 = sub_10000B070("upgr");
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        *(_WORD *)long long buf = 0;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "skipping upgrade since minor is newer", buf, 2u);
      }
    }
    else
    {
      *(void *)long long buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 0x40000000;
      *(void *)&uint8_t buf[16] = sub_100141554;
      *(void *)&unsigned char buf[24] = &unk_100304650;
      *(void *)&long long v103 = &values;
      *((void *)&v103 + 1) = &v81;
      int v107 = v18;
      int v108 = 2060;
      int v105 = dword_100300568;
      __int16 v106 = a5;
      *(void *)&long long v104 = &block;
      *((void *)&v104 + 1) = a3;
      BOOL v20 = sub_100027B34(a3, 2, &v84, (uint64_t)buf);
      if (*((unsigned char *)p_values + 24)) {
        BOOL v21 = v20;
      }
      else {
        BOOL v21 = 0;
      }
      *((unsigned char *)p_values + 24) = v21;
      if (v21 && *(unsigned char *)(p_block + 24)) {
        SecCoreAnalyticsSendValue();
      }
    }
  }
  int v77 = a6;
  int v78 = a5;
  uint64_t v76 = a1;
  int v75 = v17;
  if (!*((unsigned char *)p_values + 24))
  {
LABEL_38:
    int v23 = sub_10000B070("SecError");
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v24 = (__CFString *)v82[3];
      *(_DWORD *)__int16 v96 = 138412290;
      id v97 = v24;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "upgrade: error occurred, considering marking database as corrupt: %@", v96, 0xCu);
    }
    uint64_t v25 = (__CFError *)v82[3];
    if (v25)
    {
      CFErrorDomain Domain = CFErrorGetDomain(v25);
      CFIndex Code = CFErrorGetCode((CFErrorRef)v82[3]);
      if (Domain && CFEqual(Domain, @"com.apple.utilities.sqlite3"))
      {
        if ((unint64_t)Code - 5 < 2
          || Code == -536870184
          || Code == 13
          || Code == -25291)
        {
          goto LABEL_52;
        }
        uint64_t v28 = -536870186;
      }
      else
      {
        if (Code == -536870186 || Code == -536870184) {
          goto LABEL_52;
        }
        uint64_t v28 = -25291;
      }
      if (Code == v28)
      {
LABEL_52:
        CFTypeRef v29 = sub_10000B070("SecError");
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          CFTypeRef v30 = (__CFString *)v82[3];
          *(_DWORD *)__int16 v96 = 138412290;
          id v97 = v30;
          _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "upgrade: not marking keychain database corrupt for error: %@", v96, 0xCu);
        }
        uint64_t v31 = (const void *)v82[3];
        if (v31)
        {
          v82[3] = 0;
          CFRelease(v31);
        }
        goto LABEL_97;
      }
      CFTypeID v52 = sub_10000B070("SecError");
      if (!os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_86;
      }
      CFDictionaryRef v53 = (__CFString *)v82[3];
      *(_DWORD *)__int16 v96 = 138412290;
      id v97 = v53;
      uint64_t v33 = "upgrade: unable to complete upgrade, marking DB as corrupt: %@";
      __int16 v34 = v52;
      uint32_t v35 = 12;
    }
    else
    {
      CFTypeRef v32 = sub_10000B070("SecError");
      if (!os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
LABEL_86:
        uint64_t v54 = sub_10000B070("SecError");
        if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
        {
          *(_WORD *)__int16 v96 = 0;
          _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "upgrade: marking database as corrupt", v96, 2u);
        }
        uint64_t v55 = (__CFString *)v82[3];
        if (dword_10035AEC8 == -1)
        {
          int v56 = sub_10000B070("SecEmergency");
          if (os_log_type_enabled(v56, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)__int16 v96 = 138412290;
            id v97 = v55;
            _os_log_fault_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_FAULT, "SecDBCorrupt: %@", v96, 0xCu);
          }
        }
        *(unsigned char *)(a3 + 40) = 1;
        uint64_t v57 = *(__CFString **)(a3 + 56);
        if (v57 != v55)
        {
          if (!v55 || (CFRetain(v55), (uint64_t v57 = *(__CFString **)(a3 + 56)) != 0)) {
            CFRelease(v57);
          }
          *(void *)(a3 + 56) = v55;
        }
        SecCoreAnalyticsSendValue();
        goto LABEL_97;
      }
      *(_WORD *)__int16 v96 = 0;
      uint64_t v33 = "upgrade: unable to complete upgrade and no error object returned, marking DB as corrupt";
      __int16 v34 = v32;
      uint32_t v35 = 2;
    }
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, v33, v96, v35);
    goto LABEL_86;
  }
  if (v82[3])
  {
    CFTypeRef v22 = sub_10000B070("SecWarning");
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      *(_WORD *)__int16 v96 = 0;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "upgrade: error has been set but status is true", v96, 2u);
    }
    *((unsigned char *)p_values + 24) = 0;
    goto LABEL_38;
  }
  if (*(unsigned char *)(p_block + 24)) {
    LKAReportKeychainUpgradeOutcomeWithError();
  }
  if (v18 == 2060 || *(unsigned char *)(p_block + 24))
  {
    sub_100142B30(a3);
    char v36 = off_100300570;
    uint64_t v37 = &off_1002FE3E8;
    do
    {
      int v38 = v37[2];
      if (v38)
      {
        __int16 v39 = v37 + 3;
        do
        {
          if ((~LODWORD(v38->data) & 6) == 0)
          {
            CFTypeRef cf = 0;
            CFTypeRef v40 = *v36;
            CFStringRef v41 = CFStringCreateWithFormat(0, 0, @"CREATE INDEX IF NOT EXISTS %@%@ ON %@(%@);",
                    **v36,
                    v38->isa,
                    **v36,
                    v38->isa);
            char v42 = sub_100026908(a3, v41, &cf);
            if (v41) {
              CFRelease(v41);
            }
            if ((v42 & 1) == 0)
            {
              CFDataRef v43 = sub_10000B070("SecError");
              if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v44 = *v40;
                CFStringRef isa = v38->isa;
                *(_DWORD *)__int16 v96 = 138412802;
                id v97 = v44;
                __int16 v98 = 2112;
                long long v99 = isa;
                __int16 v100 = 2112;
                CFTypeRef v101 = cf;
                _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "upgrade: unable to opportunistically create index (%@,%@): %@", v96, 0x20u);
              }
            }
            CFTypeRef v46 = cf;
            if (cf)
            {
              CFTypeRef cf = 0;
              CFRelease(v46);
            }
          }
          CFStringRef v47 = *v39++;
          int v38 = v47;
        }
        while (v47);
      }
      CFStringRef v48 = v36[1];
      ++v36;
      uint64_t v37 = v48;
    }
    while (v48);
  }
LABEL_97:
  int v58 = v82;
  int v59 = (const void *)v82[3];
  a6 = v77;
  a5 = v78;
  a1 = v76;
  int v17 = v75;
  if (v59)
  {
    if (!v77 || (*v77 = CFRetain(v59), int v58 = v82, (v59 = (const void *)v82[3]) != 0))
    {
      v58[3] = 0;
      CFRelease(v59);
    }
  }
  int v60 = *((unsigned __int8 *)p_values + 24);
  _Block_object_dispose(&v81, 8);
  _Block_object_dispose(&values, 8);
  _Block_object_dispose(&block, 8);
  if (!v60) {
    goto LABEL_111;
  }
  uint64_t v61 = 1;
  if (!v77)
  {
LABEL_103:
    CFTypeRef v62 = 0;
    goto LABEL_120;
  }
LABEL_119:
  CFTypeRef v62 = *a6;
LABEL_120:
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v62;
  if (v17)
  {
    values = @"*";
    long long v103 = 0u;
    long long v104 = 0u;
    memset(buf, 0, sizeof(buf));
    *(void *)&uint8_t buf[8] = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
    *(_WORD *)&uint8_t buf[16] = 1;
    buf[18] = 0;
    blocCFIndex k = _NSConcreteStackBlock;
    p_blocCFIndex k = 0x40000000;
    uint64_t v91 = (uint64_t)sub_100142FBC;
    CFRange v92 = &unk_1003049C0;
    CFArrayRef v93 = buf;
    __int16 v94 = a6;
    uint64_t v95 = a3;
    sub_1001381F8(a3, 2, a6, (uint64_t)&block);
    __int16 v68 = *(const void **)&buf[8];
    if (*(void *)&buf[8])
    {
      *(void *)&uint8_t buf[8] = 0;
      CFRelease(v68);
    }
    id v69 = sub_10000B070("upgr");
    if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(block) = 0;
      _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "transcrypted, setting flag to remember we've already done so", (uint8_t *)&block, 2u);
    }
    sub_1001413DC(a3);
    __int16 v70 = sub_10000B070("upgr");
    if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
    {
      LOWORD(block) = 0;
      _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "transcrypted, using system keychain handle", (uint8_t *)&block, 2u);
    }
    dword_10035D2B0 = -6;
  }
  if (v61 && (!a5 || !*a5))
  {
    global_queue = dispatch_get_global_queue(0, 0);
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&uint8_t buf[16] = sub_1001431F0;
    *(void *)&unsigned char buf[24] = &unk_100303E90;
    *(void *)&long long v103 = a2;
    dispatch_async(global_queue, buf);
    if (byte_10035CE78 == 1) {
      dispatch_async(global_queue, &stru_100303ED0);
    }
    blocCFIndex k = _NSConcreteStackBlock;
    p_blocCFIndex k = 0x40000000;
    uint64_t v91 = (uint64_t)sub_1001432F0;
    CFRange v92 = &unk_100303EF0;
    CFArrayRef v93 = a2;
    dispatch_async(global_queue, &block);
  }
  return v61;
}

void sub_100141318(id a1)
{
}

uint64_t sub_100141324(uint64_t a1)
{
  uint64_t v1 = sub_10002789C(a1, @"PRAGMA user_version", 0) & 1;
  int64_t v2 = sub_10000B070("edutranscrypted");
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    v4[0] = 67109120;
    v4[1] = v1;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "got: %{BOOL}d", (uint8_t *)v4, 8u);
  }
  return v1;
}

void sub_1001413DC(uint64_t a1)
{
  CFTypeRef cf = 0;
  int v2 = sub_10002789C(a1, @"PRAGMA user_version", 0);
  CFStringRef v3 = CFStringCreateWithFormat(kCFAllocatorDefault, 0, @"PRAGMA user_version = %d", v2 | 1u);
  char v4 = sub_100026908(a1, v3, &cf);
  if ((v4 & 1) == 0)
  {
    uint64_t v5 = sub_10000B070("SecError");
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      CFTypeRef v10 = cf;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "setDbUserVersion failed: %@", buf, 0xCu);
    }
  }
  if (v3) {
    CFRelease(v3);
  }
  if ((v4 & 1) == 0)
  {
    CFNumberRef v6 = sub_10000B070("edutranscrypted");
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 138412290;
      CFTypeRef v10 = cf;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "failed to set DB user version: %@", buf, 0xCu);
    }
    CFTypeRef v7 = cf;
    if (cf)
    {
      CFTypeRef cf = 0;
      CFRelease(v7);
    }
  }
}

void sub_100141554(uint64_t a1, const void **a2)
{
  uint64_t v4 = a1;
  unsigned int v135 = 0;
  int v5 = sub_10013F2A0(*(void *)(a1 + 56), (int *)&v135, (CFTypeRef *)(*(void *)(*(void *)(a1 + 40) + 8) + 24));
  *(unsigned char *)(*(void *)(*(void *)(v4 + 32) + 8) + 24) = v5;
  if (!v5) {
    goto LABEL_14;
  }
  unsigned int v6 = *(_DWORD *)(v4 + 80);
  if (v6 != v135)
  {
    uint64_t v109 = *(void *)(*(void *)(v4 + 40) + 8);
    __int16 v110 = *(const void **)(v109 + 24);
    if (v110)
    {
      *(void *)(v109 + 24) = 0;
      CFRelease(v110);
    }
    CFStringRef v18 = 0;
    *(unsigned char *)(*(void *)(*(void *)(v4 + 32) + 8) + 24) = 1;
    goto LABEL_166;
  }
  CFTypeRef v7 = *(unsigned int **)(v4 + 64);
  unsigned int v8 = v7[1];
  if ((*v7 | (v8 << 8)) == v6) {
    goto LABEL_14;
  }
  if (!v6)
  {
    *(unsigned char *)(*(void *)(*(void *)(v4 + 32) + 8) + 24) = sub_1001382E0(*(void *)(v4 + 56), v7, 0, 1, *(void *)(*(void *)(v4 + 40) + 8) + 24);
    sub_100142B30(*(void *)(v4 + 56));
    goto LABEL_13;
  }
  int v9 = (unsigned __int16)*(_DWORD *)(v4 + 80);
  unsigned int v135 = v9;
  uint64_t v10 = *v7 | (v8 << 8);
  if (v6 >= 0x10000 && v9 != v10)
  {
    sub_1000263CC(11, (CFTypeRef *)(*(void *)(*(void *)(v4 + 40) + 8) + 24), @"Half migrated but obsolete DB found: found 0x%x(0x%x) but 0x%x is needed", (unsigned __int16)v6, HIWORD(v6), v10);
    *(unsigned char *)(*(void *)(*(void *)(v4 + 32) + 8) + 24) = 0;
    goto LABEL_13;
  }
  int v11 = &unk_100265000;
  unsigned int v12 = HIWORD(v6);
  unsigned int v124 = HIWORD(v6);
  uint64_t v125 = v4;
  id v126 = a2;
  if (!HIWORD(v6))
  {
    unsigned int v135 = v10;
    int v13 = dword_100300568;
    char v14 = (int **)&off_100303190;
    BOOL v15 = dword_100300568;
    do
    {
      if ((*v15 | (v15[1] << 8)) == v9)
      {
        unsigned int v120 = v6;
        char v19 = sub_10000B070("upgr");
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          int v20 = **(_DWORD **)(v4 + 64) | (*(_DWORD *)(*(void *)(v4 + 64) + 4) << 8);
          *(_DWORD *)long long buf = 67109376;
          *(_DWORD *)&uint8_t buf[4] = v9;
          *(_WORD *)&uint8_t buf[8] = 1024;
          *(_DWORD *)&buf[10] = v20;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "Upgrading from version 0x%x to 0x%x", buf, 0xEu);
        }
        int v121 = v9;
        kdebug_trace();
        uint64_t v131 = *(void *)(v4 + 56);
        uint64_t v21 = *(void *)(*(void *)(v4 + 40) + 8);
        CFStringRef v175 = 0;
        uint64_t v176 = &v175;
        uint64_t v177 = 0x2000000000;
        char v178 = 1;
        uint64_t v171 = 0;
        id v172 = &v171;
        uint64_t v173 = 0x2000000000;
        uint64_t v174 = 0;
        v170.tv_sec = 0xAAAAAAAAAAAAAAAALL;
        *(void *)&v170.tv_usec = 0xAAAAAAAAAAAAAAAALL;
        gettimeofday(&v170, 0);
        v193.id location = 48;
        v193.size_t length = 57;
        CFTypeRef v22 = (uint64_t *)CFCharacterSetCreateWithCharactersInRange(0, v193);
        CFDictionaryRef theDict = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, 0);
        int v23 = (const __CFString **)*((void *)v15 + 1);
        if (v23)
        {
          BOOL v24 = 0;
          a2 = (const void **)(v15 + 4);
          CFMutableStringRef v2 = (CFMutableStringRef)theDict;
          while (1)
          {
            CFStringRef v25 = sub_100025DD4(*v23, (const __CFCharacterSet *)v22);
            if (CFDictionaryContainsKey(theDict, v25)) {
              break;
            }
            CFDictionarySetValue(theDict, v25, v24);
            if (v25) {
              CFRelease(v25);
            }
            int v23 = (const __CFString **)a2[(void)v24];
            BOOL v24 = (char *)v24 + 1;
            if (!v23) {
              goto LABEL_23;
            }
          }
        }
        else
        {
LABEL_23:
          id v129 = (CFTypeRef *)(v21 + 24);
          CFDictionaryRef Mutable = CFDictionaryCreateMutable(0, 0, &kCFTypeDictionaryKeyCallBacks, 0);
          uint64_t v27 = 0;
          uint64_t v28 = (const __CFString **)&off_1002FE3E8;
          while (1)
          {
            CFStringRef v29 = sub_100025DD4(*v28, (const __CFCharacterSet *)v22);
            if (CFDictionaryContainsKey(Mutable, v29)) {
              break;
            }
            CFDictionarySetValue(Mutable, v29, v27);
            if (v29) {
              CFRelease(v29);
            }
            uint64_t v28 = *(const __CFString ***)&dword_100300568[2 * (void)v27 + 4];
            uint64_t v27 = (char *)v27 + 1;
            if (v27 == (const void *)27)
            {
              if (v22) {
                CFRelease(v22);
              }
              CFSetRef v30 = CFSetCreateMutable(0, 0, &kCFTypeSetCallBacks);
              context = _NSConcreteStackBlock;
              uint64_t p_context = 0x40000000;
              v164 = sub_1001436E8;
              id v165 = &unk_100304670;
              CFDictionaryRef v166 = Mutable;
              v167 = v15;
              uint64_t v168 = dword_100300568;
              CFSetRef v169 = v30;
              CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)sub_100144470, &context);
              CFMutableStringRef v2 = CFStringCreateMutable(0, 0);
              CFMutableArrayRef v31 = CFArrayCreateMutable(0, 0, 0);
              *(void *)long long buf = _NSConcreteStackBlock;
              *(void *)&uint8_t buf[8] = 0x40000000;
              *(void *)&uint8_t buf[16] = sub_100143814;
              unsigned int v186 = &unk_100304690;
              CFDataRef v187 = theDict;
              id v188 = v15;
              uint64_t v189 = (__CFString **)Mutable;
              uint64_t v190 = dword_100300568;
              CFMutableStringRef v191 = v2;
              uint64_t v192 = (uint64_t)v31;
              CFSetApplyFunction(v30, (CFSetApplierFunction)sub_10013FC68, buf);
              CFStringRef v154 = _NSConcreteStackBlock;
              uint64_t v155 = 0x40000000;
              uint64_t v156 = sub_1001438B0;
              uint64_t v157 = &unk_1003046B0;
              CFSetRef v158 = v30;
              CFDictionaryRef v159 = Mutable;
              v160 = v15;
              CFMutableStringRef v161 = v2;
              CFDictionaryApplyFunction(theDict, (CFDictionaryApplierFunction)sub_100144470, &v154);
              uint32_t v145 = _NSConcreteStackBlock;
              uint64_t v146 = 0x40000000;
              BOOL v147 = sub_10014392C;
              int v148 = &unk_1003046D0;
              CFSetRef v149 = v30;
              CFDictionaryRef v150 = theDict;
              id v151 = dword_100300568;
              CFMutableStringRef v152 = v2;
              CFMutableArrayRef v153 = v31;
              CFArrayRef cf = v31;
              CFDictionaryRef v128 = Mutable;
              CFDictionaryApplyFunction(Mutable, (CFDictionaryApplierFunction)sub_100144470, &v145);
              CFSetRef theSet = v30;
              if (CFStringGetLength(v2) < 1
                || ((int v32 = sub_100026908(v131, v2, v129), *((unsigned char *)v176 + 24)) ? (v33 = v32) : (v33 = 0),
                    *((unsigned char *)v176 + 24) = v33,
                    v33 == 1))
              {
                if (v2) {
                  CFRelease(v2);
                }
                CFMutableStringRef v2 = CFStringCreateMutable(0, 0);
                __int16 v34 = off_100300570;
                uint32_t v35 = &off_1002FE3E8;
                do
                {
                  char v36 = v35[2];
                  if (v36)
                  {
                    uint64_t v37 = v35 + 3;
                    do
                    {
                      if ((~LODWORD(v36->data) & 6) == 0)
                      {
                        int v38 = *v34;
                        CFStringAppendFormat(v2, 0, @"DROP INDEX IF EXISTS %@%@;", **v34, v36->isa);
                        if (LODWORD(v36->info) == 11) {
                          CFStringAppendFormat(v2, 0, @"DROP INDEX IF EXISTS %@%@0;", *v38, v36->isa);
                        }
                      }
                      __int16 v39 = *v37++;
                      char v36 = v39;
                    }
                    while (v39);
                  }
                  CFTypeRef v40 = v34[1];
                  ++v34;
                  uint32_t v35 = v40;
                }
                while (v40);
                CFStringRef v41 = v129;
                char v42 = sub_100026908(v131, v2, v129);
                if (*((unsigned char *)v176 + 24)) {
                  char v43 = v42;
                }
                else {
                  char v43 = 0;
                }
                *((unsigned char *)v176 + 24) = v43;
                if (v43)
                {
                  int v13 = (int *)theDict;
                  if (v2) {
                    CFRelease(v2);
                  }
                  int v44 = sub_1001382E0(v131, (unsigned int *)dword_100300568, cf, 0, (uint64_t)v129);
                  if (*((unsigned char *)v176 + 24)) {
                    int v45 = v44;
                  }
                  else {
                    int v45 = 0;
                  }
                  *((unsigned char *)v176 + 24) = v45;
                  if (v45 != 1)
                  {
                    CFArrayRef v127 = 0;
                    CFMutableStringRef v2 = 0;
                    CFTypeRef v22 = 0;
                    a2 = 0;
                    goto LABEL_181;
                  }
                  CFArrayRef v46 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
                  size_t v136 = _NSConcreteStackBlock;
                  uint64_t v137 = 0x40000000;
                  BOOL v138 = sub_1001439D8;
                  unsigned int v139 = &unk_1003047B8;
                  CFArrayRef v140 = (__CFString **)v46;
                  CFSetApplyFunction(v30, (CFSetApplierFunction)sub_10013FC68, &v136);
                  CFMutableStringRef v2 = 0;
                  CFIndex v47 = 0;
                  CFTypeRef v22 = 0;
                  a2 = 0;
                  CFArrayRef v127 = v46;
                  while (2)
                  {
                    if (v47 >= CFArrayGetCount(v46))
                    {
                      if (v2) {
                        CFRelease(v2);
                      }
                      CFMutableStringRef v2 = CFStringCreateMutable(0, 0);
                      v179.tv_sec = (__darwin_time_t)_NSConcreteStackBlock;
                      *(void *)&v179.tv_usec = 0x40000000;
                      unsigned int v180 = sub_100143E28;
                      v181 = &unk_100304798;
                      unsigned int v182 = v13;
                      CFStringRef v183 = v15;
                      CFMutableStringRef v184 = v2;
                      CFSetApplyFunction(theSet, (CFSetApplierFunction)sub_10013FC68, &v179);
                      if (CFStringGetLength(v2) < 1
                        || ((char v68 = sub_100026908(v131, v2, v41), *((unsigned char *)v176 + 24)) ? (v69 = v68) : (v69 = 0),
                            *((unsigned char *)v176 + 24) = v69,
                            (v69 & 1) != 0))
                      {
LABEL_104:
                        uint64_t v70 = 1;
                        if (v172[3] >= 101)
                        {
                          unint64_t v71 = v172[3];
                          do
                          {
                            v70 *= 10;
                            BOOL v72 = v71 > 0x3F1;
                            v71 /= 0xAuLL;
                          }
                          while (v72);
                        }
                        sub_10013F98C((uint64_t)&v170);
                        SecCoreAnalyticsSendValue();
                        SecCoreAnalyticsSendValue();
                        if (a2) {
                          sub_10000C2C4(a2, 0);
                        }
                        int v11 = &unk_100265000;
                        if (v2) {
                          CFRelease(v2);
                        }
                        uint64_t v4 = v125;
                        if (cf) {
                          CFRelease(cf);
                        }
                        a2 = v126;
                        if (v22)
                        {
                          int v73 = (const void *)*v22;
                          if (*v22)
                          {
                            *CFTypeRef v22 = 0;
                            CFRelease(v73);
                          }
                          free(v22);
                        }
                        if (v127) {
                          CFRelease(v127);
                        }
                        if (theSet) {
                          CFRelease(theSet);
                        }
                        if (v13) {
                          CFRelease(v13);
                        }
                        if (v128) {
                          CFRelease(v128);
                        }
                        int v74 = *((unsigned __int8 *)v176 + 24);
                        _Block_object_dispose(&v171, 8);
                        _Block_object_dispose(&v175, 8);
                        *(unsigned char *)(*(void *)(*(void *)(v125 + 32) + 8) + 24) = v74;
                        if (v74)
                        {
                          kdebug_trace();
                          unsigned int v12 = v121;
                          unsigned int v6 = v120;
                          goto LABEL_127;
                        }
                        id v118 = sub_10000B070("SecError");
                        if (os_log_type_enabled(v118, OS_LOG_TYPE_DEFAULT))
                        {
                          uint64_t v119 = *(void *)(*(void *)(*(void *)(v125 + 40) + 8) + 24);
                          *(_DWORD *)long long buf = 138412290;
                          *(void *)&uint8_t buf[4] = v119;
                          long long v113 = "upgrade: Upgrade phase1 failed: %@";
                          CFTypeRef v114 = v118;
                          uint32_t v115 = 12;
LABEL_194:
                          _os_log_impl((void *)&_mh_execute_header, v114, OS_LOG_TYPE_DEFAULT, v113, buf, v115);
                        }
                        goto LABEL_14;
                      }
LABEL_181:
                      LKAReportKeychainUpgradeOutcomeWithError();
                      goto LABEL_104;
                    }
                    CFDataRef ValueAtIndex = CFArrayGetValueAtIndex(v46, v47);
                    uint64_t v49 = *(__darwin_time_t **)&v15[2 * (int)CFDictionaryGetValue((CFDictionaryRef)v13, ValueAtIndex)
                                                  + 2];
                    long long v50 = *(void **)&dword_100300568[2 * (int)CFDictionaryGetValue(v128, ValueAtIndex) + 2];
                    CFTypeRef v51 = sub_10000B070("upgr");
                    if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
                    {
                      __darwin_time_t v52 = *v49;
                      LODWORD(v179.tv_sec) = 138412290;
                      *(__darwin_time_t *)((char *)&v179.tv_sec + 4) = v52;
                      _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "Upgrading table %@", (uint8_t *)&v179, 0xCu);
                    }
                    if (v49[2])
                    {
                      uint64_t v53 = 0;
                      while (v49[v53++ + 3])
                        ;
                      uint64_t v55 = v53;
                      if (!v22) {
                        goto LABEL_68;
                      }
                    }
                    else
                    {
                      uint64_t v55 = 0;
                      if (!v22)
                      {
LABEL_68:
                        uint64_t v57 = v55;
                        CFTypeRef v22 = (uint64_t *)malloc_type_malloc(8 * v55 + 24, 0x649CA7ECuLL);
                        *CFTypeRef v22 = (uint64_t)CFStringCreateWithFormat(0, 0, @"%@_old", *v49);
                        *((unsigned char *)v22 + _Block_object_dispose(&STACK[0x3F0], 8) = *((unsigned char *)v49 + 8);
                        if ((v55 & 0x80000000) == 0)
                        {
                          do
                          {
                            v22[v57 + 2] = v49[v57 + 2];
                            --v57;
                          }
                          while (v57 != -1);
                        }
                        if (*((unsigned char *)v49 + 8))
                        {
                          int v13 = (int *)theDict;
                          CFStringRef v41 = v129;
                          if (a2) {
                            sub_10000C2C4(a2, 0);
                          }
                          CFArrayRef v46 = v127;
                          if (qword_10035CF68 != -1) {
                            dispatch_once(&qword_10035CF68, &stru_1002FAFD0);
                          }
                          int v58 = (CFDictionaryRef *)sub_10000C7F0((uint64_t)v22, (const void *)qword_10035CF70, 0, 0, (__CFString **)v129);
                          a2 = (const void **)v58;
                          if (!v58) {
                            goto LABEL_104;
                          }
                          size_t v136 = _NSConcreteStackBlock;
                          uint64_t v137 = 0x40000000;
                          BOOL v138 = sub_1001439E0;
                          unsigned int v139 = &unk_100304778;
                          CFArrayRef v140 = (__CFString **)&v171;
                          CFStringRef v141 = &v175;
                          uint64_t v142 = v50;
                          unsigned int v143 = v129;
                          uint64_t v144 = v131;
                          BOOL v59 = sub_10011C750(v58, v131, v129, &stru_100304710, &stru_100304750, 0, 0, (uint64_t)&v136);
                          if (*((unsigned char *)v176 + 24)) {
                            BOOL v60 = v59;
                          }
                          else {
                            BOOL v60 = 0;
                          }
                          *((unsigned char *)v176 + 24) = v60;
                          if (!v60) {
                            goto LABEL_181;
                          }
                        }
                        else
                        {
                          int v13 = (int *)theDict;
                          if (v2) {
                            CFRelease(v2);
                          }
                          CFMutableStringRef v2 = CFStringCreateMutable(0, 0);
                          uint64_t v61 = CFStringCreateMutable(0, 0);
                          uint64_t v62 = v22[2];
                          if (v62)
                          {
                            char v63 = 0;
                            CFTypeRef v64 = v22 + 3;
                            do
                            {
                              if ((*(unsigned char *)(v62 + 16) & 2) != 0)
                              {
                                if (v63) {
                                  CFStringAppendFormat(v61, 0, @",");
                                }
                                CFStringAppendFormat(v61, 0, @"%@", *(void *)v62);
                                char v63 = 1;
                              }
                              uint64_t v65 = *v64++;
                              uint64_t v62 = v65;
                            }
                            while (v65);
                          }
                          CFStringAppendFormat(v2, 0, @"INSERT OR REPLACE INTO %@ (%@) SELECT %@ FROM %@;",
                            *v50,
                            v61,
                            v61,
                            *v22);
                          if (v61) {
                            CFRelease(v61);
                          }
                          CFStringRef v41 = v129;
                          int v66 = sub_100026908(v131, v2, v129);
                          if (*((unsigned char *)v176 + 24)) {
                            int v67 = v66;
                          }
                          else {
                            int v67 = 0;
                          }
                          *((unsigned char *)v176 + 24) = v67;
                          CFArrayRef v46 = v127;
                          if (v67 != 1) {
                            goto LABEL_181;
                          }
                        }
                        ++v47;
                        continue;
                      }
                    }
                    break;
                  }
                  int v56 = (const void *)*v22;
                  if (*v22)
                  {
                    *CFTypeRef v22 = 0;
                    CFRelease(v56);
                  }
                  free(v22);
                  goto LABEL_68;
                }
                CFArrayRef v127 = 0;
                CFTypeRef v22 = 0;
                a2 = 0;
              }
              else
              {
                CFArrayRef v127 = 0;
                CFTypeRef v22 = 0;
                a2 = 0;
              }
              int v13 = (int *)theDict;
              goto LABEL_181;
            }
          }
          _os_assert_log();
          _os_crash();
          __break(1u);
        }
        _os_assert_log();
        _os_crash();
        __break(1u);
        goto LABEL_104;
      }
      BOOL v16 = *v14++;
      BOOL v15 = v16;
    }
    while (v16);
    sub_1000263CC(11, (CFTypeRef *)(*(void *)(*(void *)(v4 + 40) + 8) + 24), @"no schema for version: 0x%x", (unsigned __int16)v6);
    *(unsigned char *)(*(void *)(*(void *)(v4 + 32) + 8) + 24) = 0;
    int v17 = sub_10000B070("SecError");
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = v9;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "no schema for version 0x%x", buf, 8u);
    }
LABEL_13:
    LKAReportKeychainUpgradeOutcomeWithError();
    goto LABEL_14;
  }
LABEL_127:
  unsigned int v132 = v12;
  BOOL v130 = v6 < 0x10000;
  CFStringRef v175 = 0;
  kdebug_trace();
  int v75 = *(__CFString **)(v4 + 72);
  unsigned int v76 = v135;
  off_10035CA60();
  int v78 = v77;
  CFDictionaryRef theDicta = (CFDictionaryRef)*v77;
  *int v77 = v79;
  context = 0;
  uint64_t p_context = (uint64_t)&context;
  v164 = (void (*)(uint64_t, const void *, int))*((void *)v11 + 102);
  LOBYTE(v165) = 1;
  CFStringRef v154 = 0;
  uint64_t v155 = (uint64_t)&v154;
  uint64_t v156 = v164;
  uint64_t v157 = 0;
  memset(&v179, 170, sizeof(v179));
  gettimeofday(&v179, 0);
  CFTypeRef v80 = 0;
  uint64_t v81 = &off_1002FE3E8;
  int v82 = off_100300578;
  while (!LOBYTE(v75->isa))
  {
    if (*((unsigned char *)v81 + 8))
    {
      uint64_t v83 = sub_100118974(v81, 14, &v175);
      if (v83)
      {
        uint64_t v84 = v83;
        if (v80) {
          sub_10000C2C4(v80, 0);
        }
        uint64_t v85 = (uint64_t)*(v82 - 1);
        if (qword_10035CF68 != -1) {
          dispatch_once(&qword_10035CF68, &stru_1002FAFD0);
        }
        __int16 v86 = (CFDictionaryRef *)sub_10000C7F0(v85, (const void *)qword_10035CF70, 0, 0, &v175);
        if (!v86)
        {
          *(unsigned char *)(p_context + 24) = 0;
          uint64_t v4 = v125;
          a2 = v126;
          CFDictionaryRef v93 = theDicta;
          goto LABEL_148;
        }
        CFTypeRef v80 = (const void **)v86;
        uint64_t v87 = *v78;
        uint32_t v145 = _NSConcreteStackBlock;
        uint64_t v146 = 0x40000000;
        BOOL v147 = sub_100143E80;
        int v148 = &unk_100304818;
        CFSetRef v149 = (const __CFSet *)v84;
        size_t v136 = _NSConcreteStackBlock;
        uint64_t v137 = 0x40000000;
        BOOL v138 = sub_100143EDC;
        unsigned int v139 = &unk_100304838;
        CFArrayRef v140 = &v175;
        *(void *)long long buf = _NSConcreteStackBlock;
        *(void *)&uint8_t buf[8] = 0x40000000;
        *(void *)&uint8_t buf[16] = sub_100143F64;
        unsigned int v186 = &unk_100304860;
        CFDataRef v187 = &v154;
        id v188 = &context;
        uint64_t v189 = &v175;
        uint64_t v190 = (int *)v86;
        CFMutableStringRef v191 = v75;
        uint64_t v192 = v76 | 0x80C00000000;
        BOOL v88 = sub_10011C750(v86, v87, (CFTypeRef *)&v175, 0, &stru_1003047F8, (uint64_t)&v145, (uint64_t)&v136, (uint64_t)buf);
        BOOL v89 = *(unsigned char *)(p_context + 24) && v88;
        *(unsigned char *)(p_context + 24) = v89;
        if (!v89)
        {
          LKAReportKeychainUpgradeOutcomeWithError();
          uint64_t v4 = v125;
          a2 = v126;
          CFDictionaryRef v93 = theDicta;
LABEL_147:
          sub_10000C2C4(v80, 0);
          goto LABEL_148;
        }
      }
    }
    uint64_t v90 = *v82++;
    uint64_t v81 = v90;
    if (!v90) {
      break;
    }
  }
  uint64_t v91 = 1;
  if (*(uint64_t *)(v155 + 24) < 101)
  {
    uint64_t v4 = v125;
    a2 = v126;
    CFDictionaryRef v93 = theDicta;
  }
  else
  {
    unint64_t v92 = *(void *)(v155 + 24);
    uint64_t v4 = v125;
    a2 = v126;
    CFDictionaryRef v93 = theDicta;
    do
    {
      v91 *= 10;
      BOOL v72 = v92 > 0x3F1;
      v92 /= 0xAuLL;
    }
    while (v72);
  }
  sub_10013F98C((uint64_t)&v179);
  SecCoreAnalyticsSendValue();
  SecCoreAnalyticsSendValue();
  if (v80) {
    goto LABEL_147;
  }
LABEL_148:
  *int v78 = (uint64_t)v93;
  char v94 = *(unsigned char *)(p_context + 24);
  _Block_object_dispose(&v154, 8);
  _Block_object_dispose(&context, 8);
  *(unsigned char *)(*(void *)(*(void *)(v4 + 32) + 8) + 24) = v94;
  if (!*(unsigned char *)(*(void *)(*(void *)(v4 + 32) + 8) + 24))
  {
    if (!v124)
    {
      **(unsigned char **)(v4 + 72) = 1;
      *(unsigned char *)(*(void *)(*(void *)(v4 + 32) + 8) + 24) = 1;
      __int16 v100 = v175;
      if (!v175) {
        goto LABEL_149;
      }
      CFStringRef v175 = 0;
      goto LABEL_174;
    }
    __int16 v96 = v175;
    if (!v175) {
      goto LABEL_149;
    }
    uint64_t v97 = *(void *)(*(void *)(v4 + 40) + 8);
    __int16 v98 = *(__CFError **)(v97 + 24);
    if (v98)
    {
      if (CFErrorGetCode(v98) == -25330)
      {
        long long v99 = *(const void **)(v97 + 24);
        if (!v99) {
          goto LABEL_175;
        }
        *(void *)(v97 + 24) = 0;
        CFRelease(v99);
      }
      if (*(void *)(v97 + 24))
      {
        __int16 v100 = v96;
LABEL_174:
        CFRelease(v100);
        goto LABEL_149;
      }
    }
LABEL_175:
    *(void *)(v97 + 24) = v96;
  }
LABEL_149:
  if (*(unsigned char *)(*(void *)(*(void *)(v4 + 32) + 8) + 24))
  {
    if (**(unsigned char **)(v4 + 72))
    {
      unsigned int v95 = v132;
    }
    else
    {
      CFTypeRef v101 = sub_10000B070("upgr");
      if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
      {
        int v102 = **(_DWORD **)(v4 + 64) | (*(_DWORD *)(*(void *)(v4 + 64) + 4) << 8);
        *(_DWORD *)long long buf = 67109376;
        *(_DWORD *)&uint8_t buf[4] = v132;
        *(_WORD *)&uint8_t buf[8] = 1024;
        *(_DWORD *)&buf[10] = v102;
        _os_log_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_DEFAULT, "Done upgrading from version 0x%x to 0x%x", buf, 0xEu);
      }
      *(unsigned char *)(*(void *)(*(void *)(v4 + 48) + 8) + 24) = 1;
      kdebug_trace();
      unsigned int v95 = 0;
    }
    uint64_t v103 = v135 | (v95 << 16);
    uint64_t v104 = (v95 << 8) & 0xFF0000 | BYTE1(v135);
    int v105 = sub_10000B070("upgr");
    if (os_log_type_enabled(v105, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 67109376;
      *(_DWORD *)&uint8_t buf[4] = v103;
      *(_WORD *)&uint8_t buf[8] = 1024;
      *(_DWORD *)&buf[10] = v104;
      _os_log_impl((void *)&_mh_execute_header, v105, OS_LOG_TYPE_DEFAULT, "Upgrading saving version major 0x%x minor 0x%x", buf, 0xEu);
    }
    CFStringRef v18 = CFStringCreateWithFormat(0, 0, @"UPDATE tversion SET version='%d', minor='%d'", v103, v104);
    char v106 = sub_100026908(*(void *)(v4 + 56), v18, (CFTypeRef *)(*(void *)(*(void *)(v4 + 40) + 8) + 24));
    *(unsigned char *)(*(void *)(*(void *)(v4 + 32) + 8) + 24) = v106;
    if ((v106 & 1) == 0)
    {
      CFRange v116 = sub_10000B070("SecError");
      if (os_log_type_enabled(v116, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v117 = *(void *)(*(void *)(*(void *)(v4 + 40) + 8) + 24);
        *(_DWORD *)long long buf = 138412290;
        *(void *)&uint8_t buf[4] = v117;
        _os_log_impl((void *)&_mh_execute_header, v116, OS_LOG_TYPE_DEFAULT, "upgrade: Setting version failed: %@", buf, 0xCu);
      }
    }
  }
  else
  {
    int v111 = sub_10000B070("SecError");
    if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v112 = *(void *)(*(void *)(*(void *)(v4 + 40) + 8) + 24);
      *(_DWORD *)long long buf = 67109378;
      *(_DWORD *)&uint8_t buf[4] = v130;
      *(_WORD *)&uint8_t buf[8] = 2112;
      *(void *)&buf[10] = v112;
      long long v113 = "upgrade: Upgrade phase2 (%d) failed: %@";
      CFTypeRef v114 = v111;
      uint32_t v115 = 18;
      goto LABEL_194;
    }
LABEL_14:
    CFStringRef v18 = 0;
  }
LABEL_166:
  if (!*(unsigned char *)(*(void *)(*(void *)(v4 + 32) + 8) + 24))
  {
    int v107 = sub_10000B070("SecError");
    if (os_log_type_enabled(v107, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v108 = *(void *)(*(void *)(*(void *)(v4 + 40) + 8) + 24);
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v108;
      _os_log_impl((void *)&_mh_execute_header, v107, OS_LOG_TYPE_DEFAULT, "upgrade: SecDB upgrade failed: %@", buf, 0xCu);
    }
  }
  if (v18) {
    CFRelease(v18);
  }
  *(unsigned char *)a2 = *(unsigned char *)(*(void *)(*(void *)(v4 + 32) + 8) + 24);
}