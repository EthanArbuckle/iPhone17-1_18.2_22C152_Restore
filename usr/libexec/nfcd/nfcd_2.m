void sub_1001C3404(uint64_t a1)
{
  uint64_t Logger;
  void (*v3)(uint64_t, const char *, ...);
  objc_class *Class;
  BOOL isMetaClass;
  const char *ClassName;
  const char *Name;
  void *v8;
  uint64_t v9;
  NSObject *v10;
  objc_class *v11;
  int v12;
  const char *v13;
  const char *v14;
  void *v15;
  uint64_t v16;
  id v17;
  void *v18;
  void *v19;
  void *v20;
  id v21;
  void *v22;
  uint64_t v23;
  NSErrorUserInfoKey v24;
  void *v25;
  uint8_t buf[4];
  int v27;
  __int16 v28;
  const char *v29;
  __int16 v30;
  const char *v31;
  __int16 v32;
  int v33;
  __int16 v34;
  void *v35;
  uint64_t vars8;

  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    Logger = NFLogGetLogger();
    if (Logger)
    {
      v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      v8 = [*(id *)(a1 + 32) sessionUID];
      v9 = 45;
      if (isMetaClass) {
        v9 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 1728, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        v12 = 43;
      }
      else {
        v12 = 45;
      }
      v13 = object_getClassName(*(id *)(a1 + 32));
      v14 = sel_getName(*(SEL *)(a1 + 48));
      v15 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)buf = 67110146;
      v27 = v12;
      v28 = 2082;
      v29 = v13;
      v30 = 2082;
      v31 = v14;
      v32 = 1024;
      v33 = 1728;
      v34 = 2114;
      v35 = v15;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    v16 = *(void *)(a1 + 40);
    if (v16)
    {
      v17 = objc_alloc((Class)NSError);
      v18 = +[NSString stringWithUTF8String:"nfcd"];
      v24 = NSLocalizedDescriptionKey;
      v19 = +[NSString stringWithUTF8String:"Session not active"];
      v25 = v19;
      v20 = +[NSDictionary dictionaryWithObjects:&v25 forKeys:&v24 count:1];
      v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
      (*(void (**)(uint64_t, id))(v16 + 16))(v16, v21);
    }
  }
  else
  {
    v22 = *(void **)(a1 + 32);
    v23 = *(void *)(a1 + 40);
    [v22 _sync_restartPolling:v23];
  }
}

void sub_1001C3C1C(uint64_t a1)
{
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      v8 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 1771, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      v13 = object_getClassName(*(id *)(a1 + 32));
      v14 = sel_getName(*(SEL *)(a1 + 56));
      v15 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)buf = 67110146;
      int v28 = v12;
      __int16 v29 = 2082;
      v30 = v13;
      __int16 v31 = 2082;
      v32 = v14;
      __int16 v33 = 1024;
      int v34 = 1771;
      __int16 v35 = 2114;
      v36 = v15;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v16 = *(void *)(a1 + 48);
    if (v16)
    {
      id v17 = objc_alloc((Class)NSError);
      v18 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v25 = NSLocalizedDescriptionKey;
      v19 = +[NSString stringWithUTF8String:"Session not active"];
      v26 = v19;
      v20 = +[NSDictionary dictionaryWithObjects:&v26 forKeys:&v25 count:1];
      id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
      (*(void (**)(uint64_t, void, void, id, double))(v16 + 16))(v16, 0, 0, v21, 0.0);
    }
  }
  else
  {
    v22 = *(void **)(a1 + 32);
    uint64_t v23 = *(void *)(a1 + 40);
    uint64_t v24 = *(void *)(a1 + 48);
    [v22 _sync_execRemoteAdminScript:v23 completion:v24];
  }
}

void sub_1001C5D50(uint64_t a1)
{
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 64));
      v8 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 1948, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      v13 = object_getClassName(*(id *)(a1 + 32));
      v14 = sel_getName(*(SEL *)(a1 + 64));
      v15 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)buf = 67110146;
      int v30 = v12;
      __int16 v31 = 2082;
      v32 = v13;
      __int16 v33 = 2082;
      int v34 = v14;
      __int16 v35 = 1024;
      int v36 = 1948;
      __int16 v37 = 2114;
      v38 = v15;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v16 = *(void *)(a1 + 56);
    if (v16)
    {
      id v17 = objc_alloc((Class)NSError);
      v18 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v27 = NSLocalizedDescriptionKey;
      v19 = +[NSString stringWithUTF8String:"Session not active"];
      int v28 = v19;
      v20 = +[NSDictionary dictionaryWithObjects:&v28 forKeys:&v27 count:1];
      id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
      (*(void (**)(uint64_t, void, id))(v16 + 16))(v16, 0, v21);
    }
  }
  else
  {
    v22 = *(void **)(a1 + 32);
    uint64_t v23 = *(void *)(a1 + 40);
    uint64_t v24 = *(unsigned __int8 *)(a1 + 72);
    uint64_t v25 = *(void *)(a1 + 48);
    uint64_t v26 = *(void *)(a1 + 56);
    [v22 _sync_felicaStateForSystemCode:v23 withRequestService:v25 performSearchServiceCode:v24 completion:v26];
  }
}

void sub_1001C6D84(uint64_t a1)
{
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    v18 = [*(id *)(a1 + 32) _RequestService:*(void *)(a1 + 40)];
    id v22 = [v18 count];
    id v23 = [*(id *)(a1 + 40) count];
    uint64_t v24 = *(void *)(a1 + 48);
    if (v22 == v23)
    {
      (*(void (**)(uint64_t, void *, void))(v24 + 16))(v24, v18, 0);
    }
    else
    {
      id v25 = objc_alloc((Class)NSError);
      uint64_t v26 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v30 = NSLocalizedDescriptionKey;
      NSErrorUserInfoKey v27 = +[NSString stringWithUTF8String:"Unexpected Result"];
      __int16 v31 = v27;
      int v28 = +[NSDictionary dictionaryWithObjects:&v31 forKeys:&v30 count:1];
      id v29 = [v25 initWithDomain:v26 code:13 userInfo:v28];
      (*(void (**)(uint64_t, void *, id))(v24 + 16))(v24, v18, v29);
    }
    goto LABEL_15;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    v8 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 2054, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    v13 = object_getClassName(*(id *)(a1 + 32));
    v14 = sel_getName(*(SEL *)(a1 + 56));
    v15 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)buf = 67110146;
    int v35 = v12;
    __int16 v36 = 2082;
    __int16 v37 = v13;
    __int16 v38 = 2082;
    v39 = v14;
    __int16 v40 = 1024;
    int v41 = 2054;
    __int16 v42 = 2114;
    v43 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v16 = *(void *)(a1 + 48);
  if (v16)
  {
    id v17 = objc_alloc((Class)NSError);
    v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v32 = NSLocalizedDescriptionKey;
    v19 = +[NSString stringWithUTF8String:"Session not active"];
    __int16 v33 = v19;
    v20 = +[NSDictionary dictionaryWithObjects:&v33 forKeys:&v32 count:1];
    id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
    (*(void (**)(uint64_t, void, id))(v16 + 16))(v16, 0, v21);

LABEL_15:
  }
}

void sub_1001C7248(uint64_t a1)
{
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    v18 = [*(id *)(a1 + 32) _RequestService:*(void *)(a1 + 40) forSystemCode:*(void *)(a1 + 48)];
    id v22 = [v18 count];
    id v23 = [*(id *)(a1 + 40) count];
    uint64_t v24 = *(void *)(a1 + 56);
    if (v22 == v23)
    {
      (*(void (**)(uint64_t, void *, void))(v24 + 16))(v24, v18, 0);
    }
    else
    {
      id v25 = objc_alloc((Class)NSError);
      uint64_t v26 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v30 = NSLocalizedDescriptionKey;
      NSErrorUserInfoKey v27 = +[NSString stringWithUTF8String:"Unexpected Result"];
      __int16 v31 = v27;
      int v28 = +[NSDictionary dictionaryWithObjects:&v31 forKeys:&v30 count:1];
      id v29 = [v25 initWithDomain:v26 code:13 userInfo:v28];
      (*(void (**)(uint64_t, void *, id))(v24 + 16))(v24, v18, v29);
    }
    goto LABEL_15;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 64));
    v8 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 2069, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    v13 = object_getClassName(*(id *)(a1 + 32));
    v14 = sel_getName(*(SEL *)(a1 + 64));
    v15 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)buf = 67110146;
    int v35 = v12;
    __int16 v36 = 2082;
    __int16 v37 = v13;
    __int16 v38 = 2082;
    v39 = v14;
    __int16 v40 = 1024;
    int v41 = 2069;
    __int16 v42 = 2114;
    v43 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v16 = *(void *)(a1 + 56);
  if (v16)
  {
    id v17 = objc_alloc((Class)NSError);
    v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v32 = NSLocalizedDescriptionKey;
    v19 = +[NSString stringWithUTF8String:"Session not active"];
    __int16 v33 = v19;
    v20 = +[NSDictionary dictionaryWithObjects:&v33 forKeys:&v32 count:1];
    id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
    (*(void (**)(uint64_t, void, id))(v16 + 16))(v16, 0, v21);

LABEL_15:
  }
}

void sub_1001C76C4(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 2084, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    v13 = object_getClassName(*(id *)(a1 + 32));
    v14 = sel_getName(*(SEL *)(a1 + 48));
    v15 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)buf = 67110146;
    int v61 = v12;
    __int16 v62 = 2082;
    v63 = v13;
    __int16 v64 = 2082;
    v65 = v14;
    __int16 v66 = 1024;
    int v67 = 2084;
    __int16 v68 = 2114;
    v69 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    uint64_t v39 = *(void *)(a1 + 32);
    __int16 v40 = *(void **)(v39 + 344);
    if (v40)
    {
      int v41 = *(void **)(v39 + 312);
      id v55 = 0;
      sub_1001944EC(v41, v40, &v55);
      id v32 = v55;
      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
      goto LABEL_25;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v42 = NFLogGetLogger();
    if (v42)
    {
      v43 = (void (*)(uint64_t, const char *, ...))v42;
      v44 = object_getClass(*(id *)(a1 + 32));
      BOOL v45 = class_isMetaClass(v44);
      v46 = object_getClassName(*(id *)(a1 + 32));
      v54 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v47 = 45;
      if (v45) {
        uint64_t v47 = 43;
      }
      v43(3, "%c[%{public}s %{public}s]:%i Invalid tag state", v47, v46, v54, 2090);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v48 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
    {
      v49 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v49)) {
        int v50 = 43;
      }
      else {
        int v50 = 45;
      }
      v51 = object_getClassName(*(id *)(a1 + 32));
      v52 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67109890;
      int v61 = v50;
      __int16 v62 = 2082;
      v63 = v51;
      __int16 v64 = 2082;
      v65 = v52;
      __int16 v66 = 1024;
      int v67 = 2090;
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid tag state", buf, 0x22u);
    }

    uint64_t v30 = *(void *)(a1 + 40);
    id v53 = objc_alloc((Class)NSError);
    id v32 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v56 = NSLocalizedDescriptionKey;
    __int16 v33 = +[NSString stringWithUTF8String:"Invalid State"];
    v57 = v33;
    int v34 = +[NSDictionary dictionaryWithObjects:&v57 forKeys:&v56 count:1];
    int v35 = v53;
    id v36 = v32;
    uint64_t v37 = 12;
LABEL_24:
    id v38 = [v35 initWithDomain:v36 code:v37 userInfo:v34];
    (*(void (**)(uint64_t, id))(v30 + 16))(v30, v38);

LABEL_25:
    return;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v16 = NFLogGetLogger();
  if (v16)
  {
    id v17 = (void (*)(uint64_t, const char *, ...))v16;
    v18 = object_getClass(*(id *)(a1 + 32));
    BOOL v19 = class_isMetaClass(v18);
    v20 = object_getClassName(*(id *)(a1 + 32));
    id v21 = sel_getName(*(SEL *)(a1 + 48));
    id v22 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v23 = 45;
    if (v19) {
      uint64_t v23 = 43;
    }
    v17(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v23, v20, v21, 2087, v22);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v24 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    id v25 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v25)) {
      int v26 = 43;
    }
    else {
      int v26 = 45;
    }
    NSErrorUserInfoKey v27 = object_getClassName(*(id *)(a1 + 32));
    int v28 = sel_getName(*(SEL *)(a1 + 48));
    id v29 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)buf = 67110146;
    int v61 = v26;
    __int16 v62 = 2082;
    v63 = v27;
    __int16 v64 = 2082;
    v65 = v28;
    __int16 v66 = 1024;
    int v67 = 2087;
    __int16 v68 = 2114;
    v69 = v29;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v30 = *(void *)(a1 + 40);
  if (v30)
  {
    id v31 = objc_alloc((Class)NSError);
    id v32 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v58 = NSLocalizedDescriptionKey;
    __int16 v33 = +[NSString stringWithUTF8String:"Session not active"];
    v59 = v33;
    int v34 = +[NSDictionary dictionaryWithObjects:&v59 forKeys:&v58 count:1];
    int v35 = v31;
    id v36 = v32;
    uint64_t v37 = 54;
    goto LABEL_24;
  }
}

void sub_1001C7D9C(uint64_t a1)
{
  v2 = *(void **)(a1 + 32);
  if (!v2[43])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      int v26 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v30 = 45;
      if (isMetaClass) {
        uint64_t v30 = 43;
      }
      v26(3, "%c[%{public}s %{public}s]:%i Tag not connected", v30, ClassName, Name, 2105);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v31 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      id v32 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v32)) {
        int v33 = 43;
      }
      else {
        int v33 = 45;
      }
      int v34 = object_getClassName(*(id *)(a1 + 32));
      int v35 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)buf = 67109890;
      int v111 = v33;
      __int16 v112 = 2082;
      v113 = v34;
      __int16 v114 = 2082;
      v115 = v35;
      __int16 v116 = 1024;
      int v117 = 2105;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Tag not connected", buf, 0x22u);
    }

    uint64_t v17 = *(void *)(a1 + 48);
    id v36 = objc_alloc((Class)NSError);
    id v19 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v120 = NSLocalizedDescriptionKey;
    uint64_t v20 = +[NSString stringWithUTF8String:"Tag Not Found"];
    uint64_t v121 = v20;
    id v21 = +[NSDictionary dictionaryWithObjects:&v121 forKeys:&v120 count:1];
    id v22 = v36;
    id v23 = v19;
    uint64_t v24 = 28;
    goto LABEL_26;
  }
  if ([v2 didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    long long v101 = 0u;
    long long v102 = 0u;
    long long v99 = 0u;
    long long v100 = 0u;
    id v19 = *(id *)(a1 + 40);
    id v38 = [v19 countByEnumeratingWithState:&v99 objects:v107 count:16];
    if (v38)
    {
      id v39 = v38;
      uint64_t v40 = *(void *)v100;
      while (2)
      {
        for (i = 0; i != v39; i = (char *)i + 1)
        {
          if (*(void *)v100 != v40) {
            objc_enumerationMutation(v19);
          }
          if (!+[NFVASRequest validateDictionary:*(void *)(*((void *)&v99 + 1) + 8 * i)])
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v60 = NFLogGetLogger();
            if (v60)
            {
              int v61 = (void (*)(uint64_t, const char *, ...))v60;
              __int16 v62 = object_getClass(*(id *)(a1 + 32));
              BOOL v63 = class_isMetaClass(v62);
              __int16 v64 = object_getClassName(*(id *)(a1 + 32));
              v94 = sel_getName(*(SEL *)(a1 + 56));
              uint64_t v65 = 45;
              if (v63) {
                uint64_t v65 = 43;
              }
              v61(3, "%c[%{public}s %{public}s]:%i Invalid parameter", v65, v64, v94, 2114);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            __int16 v66 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
            {
              int v67 = object_getClass(*(id *)(a1 + 32));
              if (class_isMetaClass(v67)) {
                int v68 = 43;
              }
              else {
                int v68 = 45;
              }
              v69 = object_getClassName(*(id *)(a1 + 32));
              v70 = sel_getName(*(SEL *)(a1 + 56));
              *(_DWORD *)buf = 67109890;
              int v111 = v68;
              __int16 v112 = 2082;
              v113 = v69;
              __int16 v114 = 2082;
              v115 = v70;
              __int16 v116 = 1024;
              int v117 = 2114;
              _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid parameter", buf, 0x22u);
            }

            uint64_t v71 = *(void *)(a1 + 48);
            id v72 = objc_alloc((Class)NSError);
            uint64_t v20 = +[NSString stringWithUTF8String:"nfcd"];
            NSErrorUserInfoKey v105 = NSLocalizedDescriptionKey;
            id v21 = +[NSString stringWithUTF8String:"Invalid Parameter"];
            v106 = v21;
            id v37 = +[NSDictionary dictionaryWithObjects:&v106 forKeys:&v105 count:1];
            id v73 = [v72 initWithDomain:v20 code:10 userInfo:v37];
            (*(void (**)(uint64_t, id, void))(v71 + 16))(v71, v73, 0);

            goto LABEL_27;
          }
        }
        id v39 = [v19 countByEnumeratingWithState:&v99 objects:v107 count:16];
        if (v39) {
          continue;
        }
        break;
      }
    }

    uint64_t v20 = objc_opt_new();
    uint64_t v42 = [*(id *)(a1 + 32) driverWrapper];
    sub_10009012C(v20, v42);

    v43 = [*(id *)(a1 + 32) currentTag];
    sub_10009011C(v20, v43);

    v44 = [*(id *)(a1 + 32) whitelistChecker];
    [v44 sessionTimeLimit];
    if (v20) {
      *(void *)(v20 + 24) = v45;
    }

    v98.isa = 0;
    id v21 = sub_10008D77C(v20, &v98);
    v46 = v98.isa;
    if (v46)
    {
      id v19 = v46;
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v47 = NFLogGetLogger();
      if (v47)
      {
        v48 = (void (*)(uint64_t, const char *, ...))v47;
        v49 = object_getClass(*(id *)(a1 + 32));
        BOOL v50 = class_isMetaClass(v49);
        v90 = object_getClassName(*(id *)(a1 + 32));
        v93 = sel_getName(*(SEL *)(a1 + 56));
        uint64_t v51 = 45;
        if (v50) {
          uint64_t v51 = 43;
        }
        v48(3, "%c[%{public}s %{public}s]:%i error: %{public}@", v51, v90, v93, 2128, v19);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v52 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
      {
        id v53 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v53)) {
          int v54 = 43;
        }
        else {
          int v54 = 45;
        }
        id v55 = object_getClassName(*(id *)(a1 + 32));
        NSErrorUserInfoKey v56 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)buf = 67110146;
        int v111 = v54;
        __int16 v112 = 2082;
        v113 = v55;
        __int16 v114 = 2082;
        v115 = v56;
        __int16 v116 = 1024;
        int v117 = 2128;
        __int16 v118 = 2114;
        id v119 = v19;
        _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i error: %{public}@", buf, 0x2Cu);
      }

      uint64_t v57 = *(void *)(a1 + 48);
      id v96 = objc_alloc((Class)NSError);
      id v37 = +[NSString stringWithUTF8String:"nfcd"];
      id v58 = [v19 code];
      v103[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[v19 code] > 70) {
        uint64_t v59 = 71;
      }
      else {
        uint64_t v59 = (uint64_t)[v19 code];
      }
      v85 = +[NSString stringWithUTF8String:off_100306978[v59]];
      v104[0] = v85;
      v104[1] = v19;
      v103[1] = NSUnderlyingErrorKey;
      v103[2] = @"Line";
      v104[2] = &off_10031D8A8;
      v103[3] = @"Method";
      id v86 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
      v104[3] = v86;
      v103[4] = NSDebugDescriptionErrorKey;
      id v87 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 2129];
      v104[4] = v87;
      v88 = +[NSDictionary dictionaryWithObjects:v104 forKeys:v103 count:5];
      id v89 = [v96 initWithDomain:v37 code:v58 userInfo:v88];
      (*(void (**)(uint64_t, id, void))(v57 + 16))(v57, v89, 0);
    }
    else
    {
      v74 = *(void **)(a1 + 40);
      id v97 = 0;
      sub_10008E820((unsigned __int8 *)v20, v74, &v97);
      id v19 = (id)objc_claimAutoreleasedReturnValue();
      id v37 = v97;
      if (v19)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v75 = NFLogGetLogger();
        if (v75)
        {
          v76 = (void (*)(uint64_t, const char *, ...))v75;
          v77 = object_getClass(*(id *)(a1 + 32));
          BOOL v78 = class_isMetaClass(v77);
          v91 = object_getClassName(*(id *)(a1 + 32));
          v95 = sel_getName(*(SEL *)(a1 + 56));
          uint64_t v79 = 45;
          if (v78) {
            uint64_t v79 = 43;
          }
          v76(3, "%c[%{public}s %{public}s]:%i error: %{public}@", v79, v91, v95, 2136, v19);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v80 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
        {
          v81 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v81)) {
            int v82 = 43;
          }
          else {
            int v82 = 45;
          }
          v83 = object_getClassName(*(id *)(a1 + 32));
          v84 = sel_getName(*(SEL *)(a1 + 56));
          *(_DWORD *)buf = 67110146;
          int v111 = v82;
          __int16 v112 = 2082;
          v113 = v83;
          __int16 v114 = 2082;
          v115 = v84;
          __int16 v116 = 1024;
          int v117 = 2136;
          __int16 v118 = 2114;
          id v119 = v19;
          _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i error: %{public}@", buf, 0x2Cu);
        }
      }
      (*(void (**)(void, id, id))(*(void *)(a1 + 48) + 16))(*(void *)(a1 + 48), v19, v37);
    }
    goto LABEL_27;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v3 = NFLogGetLogger();
  if (v3)
  {
    v4 = (void (*)(uint64_t, const char *, ...))v3;
    v5 = object_getClass(*(id *)(a1 + 32));
    BOOL v6 = class_isMetaClass(v5);
    v7 = object_getClassName(*(id *)(a1 + 32));
    v8 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v9 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v10 = 45;
    if (v6) {
      uint64_t v10 = 43;
    }
    v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, v7, v8, 2110, v9);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v11 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    int v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12)) {
      int v13 = 43;
    }
    else {
      int v13 = 45;
    }
    v14 = object_getClassName(*(id *)(a1 + 32));
    v15 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v16 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)buf = 67110146;
    int v111 = v13;
    __int16 v112 = 2082;
    v113 = v14;
    __int16 v114 = 2082;
    v115 = v15;
    __int16 v116 = 1024;
    int v117 = 2110;
    __int16 v118 = 2114;
    id v119 = v16;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v17 = *(void *)(a1 + 48);
  if (v17)
  {
    id v18 = objc_alloc((Class)NSError);
    id v19 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v108 = NSLocalizedDescriptionKey;
    uint64_t v20 = +[NSString stringWithUTF8String:"Session not active"];
    uint64_t v109 = v20;
    id v21 = +[NSDictionary dictionaryWithObjects:&v109 forKeys:&v108 count:1];
    id v22 = v18;
    id v23 = v19;
    uint64_t v24 = 54;
LABEL_26:
    id v37 = [v22 initWithDomain:v23 code:v24 userInfo:v21];
    (*(void (**)(uint64_t, id, void))(v17 + 16))(v17, v37, 0);
LABEL_27:
  }
}

void sub_1001C8A14(uint64_t a1)
{
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      v8 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 2146, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      int v13 = object_getClassName(*(id *)(a1 + 32));
      v14 = sel_getName(*(SEL *)(a1 + 48));
      v15 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)buf = 67110146;
      int v71 = v12;
      __int16 v72 = 2082;
      id v73 = v13;
      __int16 v74 = 2082;
      uint64_t v75 = v14;
      __int16 v76 = 1024;
      int v77 = 2146;
      __int16 v78 = 2114;
      uint64_t v79 = v15;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v16 = *(void *)(a1 + 40);
    if (v16)
    {
      id v17 = objc_alloc((Class)NSError);
      id v18 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v68 = NSLocalizedDescriptionKey;
      id v19 = +[NSString stringWithUTF8String:"Session not active"];
      v69 = v19;
      uint64_t v20 = +[NSDictionary dictionaryWithObjects:&v69 forKeys:&v68 count:1];
      id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
      (*(void (**)(uint64_t, id))(v16 + 16))(v16, v21);
    }
  }
  else if ([*(id *)(*(void *)(a1 + 32) + 160) readerInternalAccess] {
         && ([*(id *)(*(void *)(a1 + 32) + 160) pollingProfileUpdate] & 1) != 0)
  }
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v22 = NFLogGetLogger();
    if (v22)
    {
      id v23 = (void (*)(uint64_t, const char *, ...))v22;
      uint64_t v24 = object_getClass(*(id *)(a1 + 32));
      BOOL v25 = class_isMetaClass(v24);
      int v26 = object_getClassName(*(id *)(a1 + 32));
      NSErrorUserInfoKey v27 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v28 = 45;
      if (v25) {
        uint64_t v28 = 43;
      }
      v23(6, "%c[%{public}s %{public}s]:%i Using polling profile: %ld", v28, v26, v27, 2154, *(void *)(a1 + 56));
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v29 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v30 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v30)) {
        int v31 = 43;
      }
      else {
        int v31 = 45;
      }
      id v32 = object_getClassName(*(id *)(a1 + 32));
      int v33 = sel_getName(*(SEL *)(a1 + 48));
      int v34 = *(void **)(a1 + 56);
      *(_DWORD *)buf = 67110146;
      int v71 = v31;
      __int16 v72 = 2082;
      id v73 = v32;
      __int16 v74 = 2082;
      uint64_t v75 = v33;
      __int16 v76 = 1024;
      int v77 = 2154;
      __int16 v78 = 2048;
      uint64_t v79 = v34;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Using polling profile: %ld", buf, 0x2Cu);
    }

    *(_DWORD *)(*(void *)(a1 + 32) + 288) = 0;
    int v35 = 0;
    switch(*(void *)(a1 + 56))
    {
      case 0:
        goto LABEL_51;
      case 1:
        int v35 = 1;
        goto LABEL_51;
      case 2:
        int v35 = 2;
        goto LABEL_51;
      case 3:
        int v35 = 3;
        goto LABEL_51;
      case 4:
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v53 = NFLogGetLogger();
        if (v53)
        {
          int v54 = (void (*)(uint64_t, const char *, ...))v53;
          id v55 = object_getClass(*(id *)(a1 + 32));
          BOOL v56 = class_isMetaClass(v55);
          uint64_t v57 = object_getClassName(*(id *)(a1 + 32));
          uint64_t v65 = sel_getName(*(SEL *)(a1 + 48));
          uint64_t v58 = 45;
          if (v56) {
            uint64_t v58 = 43;
          }
          v54(6, "%c[%{public}s %{public}s]:%i NON ECP Polling", v58, v57, v65, 2166);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v59 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v60 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v60)) {
            int v61 = 43;
          }
          else {
            int v61 = 45;
          }
          __int16 v62 = object_getClassName(*(id *)(a1 + 32));
          BOOL v63 = sel_getName(*(SEL *)(a1 + 48));
          *(_DWORD *)buf = 67109890;
          int v71 = v61;
          __int16 v72 = 2082;
          id v73 = v62;
          __int16 v74 = 2082;
          uint64_t v75 = v63;
          __int16 v76 = 1024;
          int v77 = 2166;
          _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NON ECP Polling", buf, 0x22u);
        }

        int v35 = 4;
LABEL_51:
        *(_DWORD *)(*(void *)(a1 + 32) + 288) = v35;
        break;
      default:
        break;
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v36 = NFLogGetLogger();
    if (v36)
    {
      id v37 = (void (*)(uint64_t, const char *, ...))v36;
      id v38 = object_getClass(*(id *)(a1 + 32));
      BOOL v39 = class_isMetaClass(v38);
      uint64_t v40 = object_getClassName(*(id *)(a1 + 32));
      __int16 v64 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v41 = 45;
      if (v39) {
        uint64_t v41 = 43;
      }
      v37(3, "%c[%{public}s %{public}s]:%i Missing entitlement", v41, v40, v64, 2149);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v42 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
    {
      v43 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v43)) {
        int v44 = 43;
      }
      else {
        int v44 = 45;
      }
      uint64_t v45 = object_getClassName(*(id *)(a1 + 32));
      v46 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67109890;
      int v71 = v44;
      __int16 v72 = 2082;
      id v73 = v45;
      __int16 v74 = 2082;
      uint64_t v75 = v46;
      __int16 v76 = 1024;
      int v77 = 2149;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Missing entitlement", buf, 0x22u);
    }

    uint64_t v47 = *(void *)(a1 + 40);
    id v48 = objc_alloc((Class)NSError);
    v49 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v66 = NSLocalizedDescriptionKey;
    BOOL v50 = +[NSString stringWithUTF8String:"Not entitled"];
    int v67 = v50;
    uint64_t v51 = +[NSDictionary dictionaryWithObjects:&v67 forKeys:&v66 count:1];
    id v52 = [v48 initWithDomain:v49 code:32 userInfo:v51];
    (*(void (**)(uint64_t, id))(v47 + 16))(v47, v52);
  }
}

void sub_1001C94E0(uint64_t a1)
{
  unsigned __int8 v2 = [*(id *)(*(void *)(a1 + 32) + 160) readerInternalAccess];
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  v4 = (void (*)(uint64_t, const char *, ...))Logger;
  if (v2)
  {
    if (Logger)
    {
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      if (*(unsigned char *)(a1 + 56)) {
        uint64_t v9 = "enable";
      }
      else {
        uint64_t v9 = "disable";
      }
      uint64_t v10 = 45;
      if (isMetaClass) {
        uint64_t v10 = 43;
      }
      v4(6, "%c[%{public}s %{public}s]:%i Wanting to %s ContinuousWave", v10, ClassName, Name, 2203, v9);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v11 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v12)) {
        int v13 = 43;
      }
      else {
        int v13 = 45;
      }
      v14 = object_getClassName(*(id *)(a1 + 32));
      v15 = sel_getName(*(SEL *)(a1 + 48));
      if (*(unsigned char *)(a1 + 56)) {
        uint64_t v16 = "enable";
      }
      else {
        uint64_t v16 = "disable";
      }
      *(_DWORD *)buf = 67110146;
      int v67 = v13;
      __int16 v68 = 2082;
      v69 = v14;
      __int16 v70 = 2082;
      int v71 = v15;
      __int16 v72 = 1024;
      int v73 = 2203;
      __int16 v74 = 2080;
      uint64_t v75 = v16;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Wanting to %s ContinuousWave", buf, 0x2Cu);
    }

    id v17 = +[_NFHardwareManager sharedHardwareManager];
    id v18 = +[NFRoutingConfig routingOffWithFD:0];
    id v19 = [v17 setRoutingConfig:v18];

    if (v19)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v20 = NFLogGetLogger();
      if (v20)
      {
        id v21 = (void (*)(uint64_t, const char *, ...))v20;
        uint64_t v22 = object_getClass(*(id *)(a1 + 32));
        BOOL v23 = class_isMetaClass(v22);
        uint64_t v24 = object_getClassName(*(id *)(a1 + 32));
        BOOL v63 = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v25 = 45;
        if (v23) {
          uint64_t v25 = 43;
        }
        v21(6, "%c[%{public}s %{public}s]:%i Error turning off routing.", v25, v24, v63, 2207);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v26 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_54;
      }
      NSErrorUserInfoKey v27 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v27)) {
        int v28 = 43;
      }
      else {
        int v28 = 45;
      }
      id v29 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v30 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67109890;
      int v67 = v28;
      __int16 v68 = 2082;
      v69 = v29;
      __int16 v70 = 2082;
      int v71 = v30;
      __int16 v72 = 1024;
      int v73 = 2207;
      int v31 = "%c[%{public}s %{public}s]:%i Error turning off routing.";
      id v32 = v26;
      os_log_type_t v33 = OS_LOG_TYPE_DEFAULT;
      uint32_t v34 = 34;
    }
    else
    {
      id v19 = sub_1001EC2F4(*(void **)(*(void *)(a1 + 32) + 312), *(unsigned __int8 *)(a1 + 56));
      if (!v19)
      {
        uint64_t v62 = 1;
        if (*(unsigned char *)(a1 + 57)) {
          uint64_t v62 = 2;
        }
        *(void *)(*(void *)(a1 + 32) + 296) = v62;
        goto LABEL_55;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v49 = NFLogGetLogger();
      if (v49)
      {
        BOOL v50 = (void (*)(uint64_t, const char *, ...))v49;
        uint64_t v51 = object_getClass(*(id *)(a1 + 32));
        BOOL v52 = class_isMetaClass(v51);
        uint64_t v53 = object_getClassName(*(id *)(a1 + 32));
        int v54 = sel_getName(*(SEL *)(a1 + 48));
        if (*(unsigned char *)(a1 + 56)) {
          id v55 = "enable";
        }
        else {
          id v55 = "disable";
        }
        uint64_t v65 = v55;
        uint64_t v56 = 45;
        if (v52) {
          uint64_t v56 = 43;
        }
        v50(3, "%c[%{public}s %{public}s]:%i Failed to %s ContinuousWave - error=%{public}@", v56, v53, v54, 2211, v65, v19);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v26 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
LABEL_54:

LABEL_55:
        (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
        goto LABEL_56;
      }
      uint64_t v57 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v57)) {
        int v58 = 43;
      }
      else {
        int v58 = 45;
      }
      uint64_t v59 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v60 = sel_getName(*(SEL *)(a1 + 48));
      if (*(unsigned char *)(a1 + 56)) {
        int v61 = "enable";
      }
      else {
        int v61 = "disable";
      }
      *(_DWORD *)buf = 67110402;
      int v67 = v58;
      __int16 v68 = 2082;
      v69 = v59;
      __int16 v70 = 2082;
      int v71 = v60;
      __int16 v72 = 1024;
      int v73 = 2211;
      __int16 v74 = 2080;
      uint64_t v75 = v61;
      __int16 v76 = 2114;
      int v77 = v19;
      int v31 = "%c[%{public}s %{public}s]:%i Failed to %s ContinuousWave - error=%{public}@";
      id v32 = v26;
      os_log_type_t v33 = OS_LOG_TYPE_ERROR;
      uint32_t v34 = 54;
    }
    _os_log_impl((void *)&_mh_execute_header, v32, v33, v31, buf, v34);
    goto LABEL_54;
  }
  if (Logger)
  {
    int v35 = object_getClass(*(id *)(a1 + 32));
    BOOL v36 = class_isMetaClass(v35);
    id v37 = object_getClassName(*(id *)(a1 + 32));
    __int16 v64 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v38 = 45;
    if (v36) {
      uint64_t v38 = 43;
    }
    v4(3, "%c[%{public}s %{public}s]:%i Missing entitlement", v38, v37, v64, 2198);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  BOOL v39 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
  {
    uint64_t v40 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v40)) {
      int v41 = 43;
    }
    else {
      int v41 = 45;
    }
    uint64_t v42 = object_getClassName(*(id *)(a1 + 32));
    v43 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)buf = 67109890;
    int v67 = v41;
    __int16 v68 = 2082;
    v69 = v42;
    __int16 v70 = 2082;
    int v71 = v43;
    __int16 v72 = 1024;
    int v73 = 2198;
    _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Missing entitlement", buf, 0x22u);
  }

  uint64_t v44 = *(void *)(a1 + 40);
  id v45 = objc_alloc((Class)NSError);
  id v19 = +[NSString stringWithUTF8String:"nfcd"];
  NSErrorUserInfoKey v78 = NSLocalizedDescriptionKey;
  v46 = +[NSString stringWithUTF8String:"Not entitled"];
  uint64_t v79 = v46;
  uint64_t v47 = +[NSDictionary dictionaryWithObjects:&v79 forKeys:&v78 count:1];
  id v48 = [v45 initWithDomain:v19 code:32 userInfo:v47];
  (*(void (**)(uint64_t, id))(v44 + 16))(v44, v48);

LABEL_56:
}

void sub_1001CA384(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v14 = va_arg(va1, void);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v17 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  uint64_t v19 = va_arg(va1, void);
  uint64_t v20 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  objc_destroyWeak(v11);
  _Block_object_dispose(va1, 8);
  objc_destroyWeak((id *)(v12 - 88));
  _Unwind_Resume(a1);
}

void sub_1001CA3C8(uint64_t a1)
{
}

void sub_1001CA3D0(uint64_t a1)
{
  unsigned __int8 v2 = _os_activity_create((void *)&_mh_execute_header, "com.apple.nfcd.reader.presenceCheckTimer", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  v7.opaque[0] = 0;
  v7.opaque[1] = 0;
  os_activity_scope_enter(v2, &v7);
  os_activity_scope_leave(&v7);

  WeakRetained = (void **)objc_loadWeakRetained((id *)(a1 + 48));
  v4 = WeakRetained;
  if (WeakRetained && ([WeakRetained didEnd] & 1) == 0)
  {
    int v5 = sub_100194CFC(v4[39], *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 40));
    if (v5 != 51)
    {
      if (!v5)
      {
        [*(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) startTimer:0.5];
        goto LABEL_10;
      }
      sub_1001900C4(v4[39], *(void **)(*(void *)(*(void *)(a1 + 32) + 8) + 40), 0);
    }
    BOOL v6 = NFSharedSignpostLog();
    if (os_signpost_enabled(v6))
    {
      LOWORD(v7.opaque[0]) = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v6, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "tagRemovalDetect", (const char *)&unk_100286819, (uint8_t *)&v7, 2u);
    }

    sub_1002128B4(v4[39]);
  }
LABEL_10:
}

BOOL sub_1001CD084(id a1, NF7816App *a2, NSDictionary *a3)
{
  return (id)[(NF7816App *)a2 type] == (id)3;
}

BOOL sub_1001CD0A8(id a1, NF7816App *a2, NSDictionary *a3)
{
  return (id)[(NF7816App *)a2 type] != (id)3;
}

id sub_1001D66D4(uint64_t a1, unint64_t a2, size_t a3)
{
  self;
  int v5 = malloc_type_calloc(1uLL, a3, 0x100004077774924uLL);
  uint64_t v6 = 0;
  int64x2_t v7 = (int64x2_t)xmmword_100284390;
  uint64x2_t v8 = (uint64x2_t)vdupq_n_s64(a3 - 1);
  int64x2_t v9 = vdupq_n_s64(2uLL);
  do
  {
    int32x2_t v10 = vmovn_s64((int64x2_t)vcgeq_u64(v8, (uint64x2_t)v7));
    int64x2_t v11 = vaddq_s64(v7, vdupq_n_s64(1uLL));
    if (v10.i8[0]) {
      v5[v6] = a2 >> (8 * (a3 - v11.i8[0]));
    }
    if (v10.i8[4]) {
      v5[v6 + 1] = a2 >> (8 * (a3 - v11.i8[8]));
    }
    v6 += 2;
    int64x2_t v7 = vaddq_s64(v7, v9);
  }
  while (((a3 + 1) & 0xFFFFFFFFFFFFFFFELL) != v6);
  id v12 = [objc_alloc((Class)NSData) initWithBytesNoCopy:v5 length:a3];

  return v12;
}

id sub_1001D67D0(uint64_t a1, void *a2)
{
  id v2 = a2;
  uint64_t v3 = self;
  if (v2)
  {
    v4 = +[NSCalendar currentCalendar];
    int v5 = [v4 components:28 fromDate:v2];

    uint64_t v6 = (uint64_t)[v5 year];
    uint64_t v7 = (unsigned __int128)(v6 / 10 * (__int128)0x6666666666666667) >> 64;
    buf[0] = ((int)[v5 year] % 10) | (16 * (v6 / 10 - 10 * ((v7 < 0) + (v7 >> 2))));
    uint64_t v8 = (uint64_t)[v5 month];
    uint64_t v9 = (unsigned __int128)(v8 / 10 * (__int128)0x6666666666666667) >> 64;
    buf[1] = ((int)[v5 month] % 10) | (16 * (v8 / 10 - 10 * ((v9 < 0) + (v9 >> 2))));
    uint64_t v10 = (uint64_t)[v5 day];
    uint64_t v11 = (unsigned __int128)(v10 / 10 * (__int128)0x6666666666666667) >> 64;
    buf[2] = ((char)[v5 day] % 10) | (16 * (v10 / 10 - 10 * ((v11 < 0) + (v11 >> 2))));
    id v12 = [objc_alloc((Class)NSData) initWithBytes:buf length:3];
    int v13 = +[NFTLV TLVWithTag:154 value:v12];
  }
  else
  {
    uint64_t v14 = (void *)v3;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v16 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v14);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(v14);
      Name = sel_getName("_tlvForDate:");
      uint64_t v20 = 45;
      if (isMetaClass) {
        uint64_t v20 = 43;
      }
      v16(3, "%c[%{public}s %{public}s]:%i Invalid parameter", v20, ClassName, Name, 52);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v21 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      uint64_t v22 = object_getClass(v14);
      if (class_isMetaClass(v22)) {
        int v23 = 43;
      }
      else {
        int v23 = 45;
      }
      *(_DWORD *)buf = 67109890;
      int v27 = v23;
      __int16 v28 = 2082;
      id v29 = object_getClassName(v14);
      __int16 v30 = 2082;
      int v31 = sel_getName("_tlvForDate:");
      __int16 v32 = 1024;
      int v33 = 52;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid parameter", buf, 0x22u);
    }

    int v13 = 0;
  }

  return v13;
}

id sub_1001D6AE4(uint64_t a1, void *a2)
{
  id v2 = a2;
  uint64_t v3 = self;
  unint64_t v4 = sub_1001D6D04((uint64_t)NFECommercePaymentRequestEncoder, v2);
  if (v4)
  {
    int v5 = sub_1001D66D4((uint64_t)v3, v4, 2uLL);
    uint64_t v6 = +[NFTLV TLVWithTag:40730 value:v5];
  }
  else
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v8 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v3);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(v3);
      Name = sel_getName("_tlvForCountryCode:");
      uint64_t v11 = 45;
      if (isMetaClass) {
        uint64_t v11 = 43;
      }
      v8(3, "%c[%{public}s %{public}s]:%i Invalid country code, %{public}@", v11, ClassName, Name, 75, v2);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v12 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      int v13 = object_getClass(v3);
      if (class_isMetaClass(v13)) {
        int v14 = 43;
      }
      else {
        int v14 = 45;
      }
      *(_DWORD *)buf = 67110146;
      int v19 = v14;
      __int16 v20 = 2082;
      id v21 = object_getClassName(v3);
      __int16 v22 = 2082;
      int v23 = sel_getName("_tlvForCountryCode:");
      __int16 v24 = 1024;
      int v25 = 75;
      __int16 v26 = 2114;
      id v27 = v2;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid country code, %{public}@", buf, 0x2Cu);
    }

    uint64_t v6 = 0;
  }

  return v6;
}

uint64_t sub_1001D6D04(uint64_t a1, void *a2)
{
  id v2 = a2;
  id v3 = self;
  objc_sync_enter(v3);
  if (!qword_1003475B0) {
    qword_1003475B0 = (uint64_t)&off_1003235C8;
  }
  objc_sync_exit(v3);

  if ([v2 length] != (id)2)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v8 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v3);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(v3);
      Name = sel_getName("_iso3166ForCountryCode:");
      uint64_t v12 = 45;
      if (isMetaClass) {
        uint64_t v12 = 43;
      }
      v8(3, "%c[%{public}s %{public}s]:%i Country code length too small", v12, ClassName, Name, 352);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v13 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      goto LABEL_25;
    }
    int v14 = object_getClass(v3);
    if (class_isMetaClass(v14)) {
      int v15 = 43;
    }
    else {
      int v15 = 45;
    }
    *(_DWORD *)buf = 67109890;
    int v31 = v15;
    __int16 v32 = 2082;
    int v33 = object_getClassName(v3);
    __int16 v34 = 2082;
    int v35 = sel_getName("_iso3166ForCountryCode:");
    __int16 v36 = 1024;
    int v37 = 352;
    uint64_t v16 = "%c[%{public}s %{public}s]:%i Country code length too small";
    uint64_t v17 = v13;
    uint32_t v18 = 34;
    goto LABEL_24;
  }
  unint64_t v4 = [(id)qword_1003475B0 objectForKey:v2];
  unsigned int v5 = [v4 unsignedShortValue];

  if (!v5)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v19 = NFLogGetLogger();
    if (v19)
    {
      __int16 v20 = (void (*)(uint64_t, const char *, ...))v19;
      id v21 = object_getClass(v3);
      BOOL v22 = class_isMetaClass(v21);
      id v27 = object_getClassName(v3);
      id v29 = sel_getName("_iso3166ForCountryCode:");
      uint64_t v23 = 45;
      if (v22) {
        uint64_t v23 = 43;
      }
      v20(3, "%c[%{public}s %{public}s]:%i Invalid country code, %{public}@", v23, v27, v29, 358, v2);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v13 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      goto LABEL_25;
    }
    __int16 v24 = object_getClass(v3);
    if (class_isMetaClass(v24)) {
      int v25 = 43;
    }
    else {
      int v25 = 45;
    }
    *(_DWORD *)buf = 67110146;
    int v31 = v25;
    __int16 v32 = 2082;
    int v33 = object_getClassName(v3);
    __int16 v34 = 2082;
    int v35 = sel_getName("_iso3166ForCountryCode:");
    __int16 v36 = 1024;
    int v37 = 358;
    __int16 v38 = 2114;
    id v39 = v2;
    uint64_t v16 = "%c[%{public}s %{public}s]:%i Invalid country code, %{public}@";
    uint64_t v17 = v13;
    uint32_t v18 = 44;
LABEL_24:
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, v16, buf, v18);
LABEL_25:

    uint64_t v6 = 0;
    goto LABEL_26;
  }
  uint64_t v6 = v5;
LABEL_26:

  return v6;
}

id sub_1001D703C(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  unsigned int v5 = self;
  if ([v4 length] != (id)3)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v10 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v5);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(v5);
      Name = sel_getName("_tlvForCurrency:decimalDigits:");
      uint64_t v14 = 45;
      if (isMetaClass) {
        uint64_t v14 = 43;
      }
      v10(3, "%c[%{public}s %{public}s]:%i Invalid parameter length", v14, ClassName, Name, 86);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v15 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    uint64_t v16 = object_getClass(v5);
    if (class_isMetaClass(v16)) {
      int v17 = 43;
    }
    else {
      int v17 = 45;
    }
    *(_DWORD *)buf = 67109890;
    int v37 = v17;
    __int16 v38 = 2082;
    id v39 = object_getClassName(v5);
    __int16 v40 = 2082;
    int v41 = sel_getName("_tlvForCurrency:decimalDigits:");
    __int16 v42 = 1024;
    int v43 = 86;
    uint32_t v18 = "%c[%{public}s %{public}s]:%i Invalid parameter length";
    uint64_t v19 = v15;
    uint32_t v20 = 34;
    goto LABEL_22;
  }
  uint64_t v46 = 0;
  [v4 getCharacters:&v46 range:0, 3];
  int NumericCode = ucurr_getNumericCode();
  if (!NumericCode)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v21 = NFLogGetLogger();
    if (v21)
    {
      BOOL v22 = (void (*)(uint64_t, const char *, ...))v21;
      uint64_t v23 = object_getClass(v5);
      BOOL v24 = class_isMetaClass(v23);
      int v33 = object_getClassName(v5);
      int v35 = sel_getName("_tlvForCurrency:decimalDigits:");
      uint64_t v25 = 45;
      if (v24) {
        uint64_t v25 = 43;
      }
      v22(3, "%c[%{public}s %{public}s]:%i Unable to determine ISO currency code for %{public}@", v25, v33, v35, 95, v4);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v15 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    __int16 v26 = object_getClass(v5);
    if (class_isMetaClass(v26)) {
      int v27 = 43;
    }
    else {
      int v27 = 45;
    }
    *(_DWORD *)buf = 67110146;
    int v37 = v27;
    __int16 v38 = 2082;
    id v39 = object_getClassName(v5);
    __int16 v40 = 2082;
    int v41 = sel_getName("_tlvForCurrency:decimalDigits:");
    __int16 v42 = 1024;
    int v43 = 95;
    __int16 v44 = 2114;
    id v45 = v4;
    uint32_t v18 = "%c[%{public}s %{public}s]:%i Unable to determine ISO currency code for %{public}@";
    uint64_t v19 = v15;
    uint32_t v20 = 44;
LABEL_22:
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, v18, buf, v20);
LABEL_23:

    __int16 v28 = 0;
    goto LABEL_27;
  }
  int v7 = NumericCode;
  int DefaultFractionDigits = ucurr_getDefaultFractionDigits();
  if (a3) {
    *a3 = DefaultFractionDigits;
  }
  int v29 = v7 / 100 % 100;
  unsigned int v30 = (((103 * (char)v29) >> 15) & 1) + ((103 * (char)v29) >> 10);
  int v31 = sub_1001D66D4((uint64_t)v5, (unsigned __int16)(((_WORD)v30 << 12) | (((_WORD)v29 - 10 * (_WORD)v30) << 8)) | (unint64_t)((v7 % 100 - 10 * ((((103 * (v7 % 100)) & 0x8000) != 0) + ((103 * (v7 % 100)) >> 10))) | (16 * ((((103 * (v7 % 100)) & 0x8000) != 0) + ((103 * (v7 % 100)) >> 10)))), 2uLL);
  __int16 v28 = +[NFTLV TLVWithTag:24362 value:v31];

LABEL_27:

  return v28;
}

id sub_1001D756C(uint64_t a1, void *a2, uint64_t a3)
{
  id v4 = a2;
  unsigned int v5 = self;
  if (!v4)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      int v17 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v5);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(v5);
      Name = sel_getName("_tlvForAmount:decimalDigits:");
      uint64_t v21 = 45;
      if (isMetaClass) {
        uint64_t v21 = 43;
      }
      v17(3, "%c[%{public}s %{public}s]:%i Invalid parameter", v21, ClassName, Name, 116);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v12 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_54;
    }
    BOOL v22 = object_getClass(v5);
    if (class_isMetaClass(v22)) {
      int v23 = 43;
    }
    else {
      int v23 = 45;
    }
    *(_DWORD *)buf = 67109890;
    int v95 = v23;
    __int16 v96 = 2082;
    id v97 = object_getClassName(v5);
    __int16 v98 = 2082;
    long long v99 = sel_getName("_tlvForAmount:decimalDigits:");
    __int16 v100 = 1024;
    int v101 = 116;
    int v15 = "%c[%{public}s %{public}s]:%i Invalid parameter";
    goto LABEL_53;
  }
  if (a3 < 0)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v24 = NFLogGetLogger();
    if (v24)
    {
      uint64_t v25 = (void (*)(uint64_t, const char *, ...))v24;
      __int16 v26 = object_getClass(v5);
      BOOL v27 = class_isMetaClass(v26);
      __int16 v28 = object_getClassName(v5);
      id v87 = sel_getName("_tlvForAmount:decimalDigits:");
      uint64_t v29 = 45;
      if (v27) {
        uint64_t v29 = 43;
      }
      v25(3, "%c[%{public}s %{public}s]:%i Digits is negative", v29, v28, v87, 121);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v12 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_54;
    }
    unsigned int v30 = object_getClass(v5);
    if (class_isMetaClass(v30)) {
      int v31 = 43;
    }
    else {
      int v31 = 45;
    }
    *(_DWORD *)buf = 67109890;
    int v95 = v31;
    __int16 v96 = 2082;
    id v97 = object_getClassName(v5);
    __int16 v98 = 2082;
    long long v99 = sel_getName("_tlvForAmount:decimalDigits:");
    __int16 v100 = 1024;
    int v101 = 121;
    int v15 = "%c[%{public}s %{public}s]:%i Digits is negative";
    goto LABEL_53;
  }
  if ((unint64_t)a3 >= 0x10000)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v6 = NFLogGetLogger();
    if (v6)
    {
      int v7 = (void (*)(uint64_t, const char *, ...))v6;
      uint64_t v8 = object_getClass(v5);
      BOOL v9 = class_isMetaClass(v8);
      uint64_t v10 = object_getClassName(v5);
      v85 = sel_getName("_tlvForAmount:decimalDigits:");
      uint64_t v11 = 45;
      if (v9) {
        uint64_t v11 = 43;
      }
      v7(3, "%c[%{public}s %{public}s]:%i Digits is too large", v11, v10, v85, 126);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v12 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_54;
    }
    int v13 = object_getClass(v5);
    if (class_isMetaClass(v13)) {
      int v14 = 43;
    }
    else {
      int v14 = 45;
    }
    *(_DWORD *)buf = 67109890;
    int v95 = v14;
    __int16 v96 = 2082;
    id v97 = object_getClassName(v5);
    __int16 v98 = 2082;
    long long v99 = sel_getName("_tlvForAmount:decimalDigits:");
    __int16 v100 = 1024;
    int v101 = 126;
    int v15 = "%c[%{public}s %{public}s]:%i Digits is too large";
LABEL_53:
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, v15, buf, 0x22u);
LABEL_54:

    uint64_t v47 = 0;
    goto LABEL_55;
  }
  __int16 v32 = +[NSDecimalNumber notANumber];
  unsigned int v33 = [v4 isEqualToNumber:v32];

  if (v33)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v34 = NFLogGetLogger();
    if (v34)
    {
      int v35 = (void (*)(uint64_t, const char *, ...))v34;
      __int16 v36 = object_getClass(v5);
      BOOL v37 = class_isMetaClass(v36);
      __int16 v38 = object_getClassName(v5);
      v88 = sel_getName("_tlvForAmount:decimalDigits:");
      uint64_t v39 = 45;
      if (v37) {
        uint64_t v39 = 43;
      }
      v35(3, "%c[%{public}s %{public}s]:%i Value is NaN", v39, v38, v88, 132);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v12 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_54;
    }
    __int16 v40 = object_getClass(v5);
    if (class_isMetaClass(v40)) {
      int v41 = 43;
    }
    else {
      int v41 = 45;
    }
    *(_DWORD *)buf = 67109890;
    int v95 = v41;
    __int16 v96 = 2082;
    id v97 = object_getClassName(v5);
    __int16 v98 = 2082;
    long long v99 = sel_getName("_tlvForAmount:decimalDigits:");
    __int16 v100 = 1024;
    int v101 = 132;
    int v15 = "%c[%{public}s %{public}s]:%i Value is NaN";
    goto LABEL_53;
  }
  __int16 v42 = +[NSDecimalNumber zero];
  id v43 = [v4 compare:v42];

  if (v43 == (id)-1)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v48 = NFLogGetLogger();
    if (v48)
    {
      uint64_t v49 = (void (*)(uint64_t, const char *, ...))v48;
      BOOL v50 = object_getClass(v5);
      BOOL v51 = class_isMetaClass(v50);
      BOOL v52 = object_getClassName(v5);
      id v89 = sel_getName("_tlvForAmount:decimalDigits:");
      uint64_t v53 = 45;
      if (v51) {
        uint64_t v53 = 43;
      }
      v49(3, "%c[%{public}s %{public}s]:%i Value is negative", v53, v52, v89, 138);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v12 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_54;
    }
    int v54 = object_getClass(v5);
    if (class_isMetaClass(v54)) {
      int v55 = 43;
    }
    else {
      int v55 = 45;
    }
    *(_DWORD *)buf = 67109890;
    int v95 = v55;
    __int16 v96 = 2082;
    id v97 = object_getClassName(v5);
    __int16 v98 = 2082;
    long long v99 = sel_getName("_tlvForAmount:decimalDigits:");
    __int16 v100 = 1024;
    int v101 = 138;
    int v15 = "%c[%{public}s %{public}s]:%i Value is negative";
    goto LABEL_53;
  }
  __int16 v93 = 0;
  int v92 = 0;
  __int16 v44 = +[NSDecimalNumber zero];
  unsigned __int8 v45 = [v4 isEqualToNumber:v44];

  if (v45) {
    goto LABEL_43;
  }
  uint64_t v57 = +[NSDecimalNumber one];
  unsigned int v58 = [v4 isEqualToNumber:v57];

  if (v58)
  {
    unint64_t v59 = (unint64_t)__exp10((double)a3);
  }
  else
  {
    uint64_t v60 = +[NSDecimalNumberHandler decimalNumberHandlerWithRoundingMode:0 scale:(__int16)a3 raiseOnExactness:0 raiseOnOverflow:0 raiseOnUnderflow:0 raiseOnDivideByZero:0];
    uint64_t v46 = [v4 decimalNumberByRoundingAccordingToBehavior:v60];

    if (v46) {
      [v46 decimalValue];
    }
    unint64_t v61 = (unint64_t)__exp10((double)a3);
    if (!is_mul_ok(0, v61))
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v62 = NFLogGetLogger();
      if (v62)
      {
        BOOL v63 = (void (*)(uint64_t, const char *, ...))v62;
        __int16 v64 = object_getClass(v5);
        BOOL v65 = class_isMetaClass(v64);
        NSErrorUserInfoKey v66 = object_getClassName(v5);
        v90 = sel_getName("_tlvForAmount:decimalDigits:");
        uint64_t v67 = 45;
        if (v65) {
          uint64_t v67 = 43;
        }
        v63(3, "%c[%{public}s %{public}s]:%i mantissa overflow during mult of %llu and %lld", v67, v66, v90, 185, 0, v61);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v68 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
      {
        v69 = object_getClass(v5);
        if (class_isMetaClass(v69)) {
          int v70 = 43;
        }
        else {
          int v70 = 45;
        }
        int v71 = object_getClassName(v5);
        __int16 v72 = sel_getName("_tlvForAmount:decimalDigits:");
        *(_DWORD *)buf = 67110402;
        int v95 = v70;
        __int16 v96 = 2082;
        id v97 = v71;
        __int16 v98 = 2082;
        long long v99 = v72;
        __int16 v100 = 1024;
        int v101 = 185;
        __int16 v102 = 2048;
        uint64_t v103 = 0;
        __int16 v104 = 2048;
        unint64_t v105 = v61;
        _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i mantissa overflow during mult of %llu and %lld", buf, 0x36u);
      }

      goto LABEL_89;
    }
    unint64_t v59 = 0;
  }
  if (v59 > 0xE8D4A50FFFLL)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v73 = NFLogGetLogger();
    if (v73)
    {
      __int16 v74 = (void (*)(uint64_t, const char *, ...))v73;
      uint64_t v75 = object_getClass(v5);
      BOOL v76 = class_isMetaClass(v75);
      int v77 = object_getClassName(v5);
      v91 = sel_getName("_tlvForAmount:decimalDigits:");
      uint64_t v78 = 45;
      if (v76) {
        uint64_t v78 = 43;
      }
      v74(3, "%c[%{public}s %{public}s]:%i Size of mantissa > provided buffer size.", v78, v77, v91, 194);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v46 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
    {
      uint64_t v79 = object_getClass(v5);
      if (class_isMetaClass(v79)) {
        int v80 = 43;
      }
      else {
        int v80 = 45;
      }
      v81 = object_getClassName(v5);
      int v82 = sel_getName("_tlvForAmount:decimalDigits:");
      *(_DWORD *)buf = 67109890;
      int v95 = v80;
      __int16 v96 = 2082;
      id v97 = v81;
      __int16 v98 = 2082;
      long long v99 = v82;
      __int16 v100 = 1024;
      int v101 = 194;
      _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Size of mantissa > provided buffer size.", buf, 0x22u);
    }
LABEL_89:
    uint64_t v47 = 0;
    goto LABEL_90;
  }
  if (v59)
  {
    uint64_t v83 = 5;
    do
    {
      *((unsigned char *)&v92 + v83) = (v59 % 0x64 % 0xA) | (16 * (v59 % 0x64 / 0xA));
      if ((unint64_t)(v83 + 1) < 2) {
        break;
      }
      --v83;
      BOOL v84 = v59 > 0x63;
      v59 /= 0x64uLL;
    }
    while (v84);
  }
LABEL_43:
  uint64_t v46 = [objc_alloc((Class)NSData) initWithBytes:&v92 length:6];
  uint64_t v47 = +[NFTLV TLVWithTag:40706 value:v46];
LABEL_90:

LABEL_55:

  return v47;
}

void *sub_1001D812C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v6 = a2;
  id v7 = a3;
  uint64_t v8 = self;
  if (v6)
  {
    BOOL v9 = [v6 merchantData];

    if (v9)
    {
      uint64_t v142 = 0;
      uint64_t v10 = objc_opt_new();
      uint64_t v11 = [v6 countryCode];
      uint64_t v12 = sub_1001D6AE4((uint64_t)v8, v11);

      if (v12)
      {
        [v10 addObject:v12];
        int v13 = [v6 transactionDate];
        int v14 = sub_1001D67D0((uint64_t)v8, v13);

        if (v14)
        {
          [v10 addObject:v14];
          int v15 = [v6 currencyCode];
          uint64_t v16 = sub_1001D703C((uint64_t)v8, v15, &v142);

          if (v16)
          {
            [v10 addObject:v16];
            int v17 = [v6 transactionAmount];
            uint32_t v18 = sub_1001D756C((uint64_t)v8, v17, v142);

            if (v18)
            {
              [v10 addObject:v18];
              unint64_t v19 = [v6 unpredictableNumber];
              uint64_t v20 = self;
              uint64_t v21 = sub_1001D66D4(v20, v19, 4uLL);
              BOOL v22 = +[NFTLV TLVWithTag:40759 value:v21];

              if (v22)
              {
                [v10 addObject:v22];
                id v23 = [v6 merchantCapabilities];
                uint64_t v24 = self;
                uint64_t v25 = (void *)v24;
                if ((v23 & 0x43) == 0 || (v23 & 0xBC) != 0)
                {
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  uint64_t Logger = NFLogGetLogger();
                  if (Logger)
                  {
                    __int16 v68 = (void (*)(uint64_t, const char *, ...))Logger;
                    Class = object_getClass(v25);
                    BOOL isMetaClass = class_isMetaClass(Class);
                    sel = object_getClassName(v25);
                    Name = sel_getName("_tlvForMerchantCapabilities:");
                    uint64_t v71 = 45;
                    if (isMetaClass) {
                      uint64_t v71 = 43;
                    }
                    v68(3, "%c[%{public}s %{public}s]:%i Invalid merchant capabilities 0x%x", v71, sel, Name, 218, v23);
                  }
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  __int16 v72 = NFSharedLogGetLogger();
                  if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
                  {
                    uint64_t v73 = object_getClass(v25);
                    if (class_isMetaClass(v73)) {
                      int v74 = 43;
                    }
                    else {
                      int v74 = 45;
                    }
                    int v138 = v74;
                    ClassName = object_getClassName(v25);
                    BOOL v76 = sel_getName("_tlvForMerchantCapabilities:");
                    *(_DWORD *)buf = 67110146;
                    *(_DWORD *)&uint8_t buf[4] = v138;
                    *(_WORD *)v160 = 2082;
                    *(void *)&v160[2] = ClassName;
                    *(_WORD *)&v160[10] = 2082;
                    *(void *)&v160[12] = v76;
                    *(_WORD *)&v160[20] = 1024;
                    *(_DWORD *)&v160[22] = 218;
                    __int16 v161 = 1024;
                    LODWORD(v162) = v23;
                    _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid merchant capabilities 0x%x", buf, 0x28u);
                  }
                }
                else
                {
                  __int16 v26 = sub_1001D66D4(v24, v23 | 0x80, 1uLL);
                  BOOL v27 = +[NFTLV TLVWithTag:40757 value:v26];

                  if (v27)
                  {
                    [v10 addObject:v27];
                    if (v7)
                    {
                      __int16 v28 = +[NFTLV TLVWithTag:153 value:v7];
                      [v10 addObject:v28];
                    }
                    id v29 = (id)objc_opt_new();
                    id v30 = [v6 appletIdentifier];
                    int v31 = self;
                    if (v30)
                    {
                      uint64_t v32 = +[NSData NF_dataWithHexString:v30];
                      if (v32)
                      {
                        unsigned int v33 = (void *)v32;
                        uint64_t v34 = &AMFDRSealingMapCopyLocalData_ptr;
                        int v35 = +[NFTLV TLVWithTag:79 value:v32];
LABEL_92:

                        goto LABEL_93;
                      }
                      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                      uint64_t v97 = NFLogGetLogger();
                      v140 = v27;
                      if (v97)
                      {
                        __int16 v98 = (void (*)(uint64_t, const char *, ...))v97;
                        long long v99 = object_getClass(v31);
                        BOOL v100 = class_isMetaClass(v99);
                        v127 = object_getClassName(v31);
                        v131 = sel_getName("_tlvForApplicationIdentifier:error:");
                        BOOL v101 = !v100;
                        BOOL v27 = v140;
                        uint64_t v102 = 45;
                        if (!v101) {
                          uint64_t v102 = 43;
                        }
                        v98(3, "%c[%{public}s %{public}s]:%i Invalid identifier: %{public}@", v102, v127, v131, 41, v30);
                      }
                      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                      uint64_t v103 = NFSharedLogGetLogger();
                      if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
                      {
                        __int16 v104 = object_getClass(v31);
                        BOOL v101 = !class_isMetaClass(v104);
                        unint64_t v105 = v31;
                        id v106 = v30;
                        v107 = v27;
                        if (v101) {
                          int v108 = 45;
                        }
                        else {
                          int v108 = 43;
                        }
                        uint64_t v109 = object_getClassName(v105);
                        v110 = sel_getName("_tlvForApplicationIdentifier:error:");
                        *(_DWORD *)buf = 67110146;
                        *(_DWORD *)&uint8_t buf[4] = v108;
                        BOOL v27 = v107;
                        id v30 = v106;
                        *(_WORD *)v160 = 2082;
                        *(void *)&v160[2] = v109;
                        *(_WORD *)&v160[10] = 2082;
                        *(void *)&v160[12] = v110;
                        *(_WORD *)&v160[20] = 1024;
                        *(_DWORD *)&v160[22] = 41;
                        __int16 v161 = 2114;
                        id v162 = v106;
                        _os_log_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid identifier: %{public}@", buf, 0x2Cu);
                      }

                      if (a4)
                      {
                        id v134 = objc_alloc((Class)NSError);
                        v132 = +[NSString stringWithUTF8String:"nfcd"];
                        NSErrorUserInfoKey v163 = NSLocalizedDescriptionKey;
                        v136 = +[NSString stringWithUTF8String:"Invalid Parameter"];
                        *(void *)buf = v136;
                        *(void *)v160 = &off_10031DBD8;
                        CFStringRef v164 = @"Line";
                        CFStringRef v165 = @"Method";
                        id v111 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_tlvForApplicationIdentifier:error:")];
                        *(void *)&v160[8] = v111;
                        NSErrorUserInfoKey v166 = NSDebugDescriptionErrorKey;
                        id v112 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_tlvForApplicationIdentifier:error:"), 42];
                        *(void *)&v160[16] = v112;
                        v113 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v163 count:4];
                        *a4 = [v134 initWithDomain:v132 code:10 userInfo:v113];

                        BOOL v27 = v140;
                      }
                      unsigned int v33 = 0;
                    }
                    else
                    {
                      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                      uint64_t v79 = NFLogGetLogger();
                      if (v79)
                      {
                        int v80 = (void (*)(uint64_t, const char *, ...))v79;
                        v81 = object_getClass(v31);
                        BOOL v82 = class_isMetaClass(v81);
                        uint64_t v83 = v27;
                        BOOL v84 = object_getClassName(v31);
                        v130 = sel_getName("_tlvForApplicationIdentifier:error:");
                        uint64_t v85 = 45;
                        if (v82) {
                          uint64_t v85 = 43;
                        }
                        v126 = v84;
                        BOOL v27 = v83;
                        id v30 = 0;
                        v80(3, "%c[%{public}s %{public}s]:%i Invalid parameter length", v85, v126, v130, 34);
                      }
                      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                      id v86 = NFSharedLogGetLogger();
                      if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
                      {
                        id v87 = object_getClass(v31);
                        if (class_isMetaClass(v87)) {
                          int v88 = 43;
                        }
                        else {
                          int v88 = 45;
                        }
                        id v89 = object_getClassName(v31);
                        id v90 = v30;
                        v91 = v27;
                        int v92 = v89;
                        __int16 v93 = sel_getName("_tlvForApplicationIdentifier:error:");
                        *(_DWORD *)buf = 67109890;
                        *(_DWORD *)&uint8_t buf[4] = v88;
                        *(_WORD *)v160 = 2082;
                        *(void *)&v160[2] = v92;
                        BOOL v27 = v91;
                        id v30 = v90;
                        *(_WORD *)&v160[10] = 2082;
                        *(void *)&v160[12] = v93;
                        *(_WORD *)&v160[20] = 1024;
                        *(_DWORD *)&v160[22] = 34;
                        _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid parameter length", buf, 0x22u);
                      }

                      if (!a4)
                      {
                        int v35 = 0;
                        uint64_t v34 = &AMFDRSealingMapCopyLocalData_ptr;
LABEL_93:

                        if (v35)
                        {
                          __int16 v114 = [v35 asData];
                          [v29 appendData:v114];

                          v115 = v34[424];
                          __int16 v116 = [v6 merchantData];
                          int v117 = [v115 TLVWithTag:40726 value:v116];
                          __int16 v118 = [v117 asData];
                          [v29 appendData:v118];

                          if (([v6 merchantCapabilities] & 0x40) != 0)
                          {
                            id v119 = [v6 networkMerchantIdentifier];

                            if (v119)
                            {
                              NSErrorUserInfoKey v120 = v34[424];
                              uint64_t v121 = [v6 networkMerchantIdentifier];
                              v122 = [v120 TLVWithTag:57206 value:v121];
                              v123 = [v122 asData];
                              [v29 appendData:v123];
                            }
                          }
                          v124 = [v34[424] TLVWithTag:226 children:v10];
                          v125 = [v124 asData];
                          [v29 appendData:v125];

                          id v29 = v29;
                          a4 = v29;
                          goto LABEL_63;
                        }
LABEL_62:
                        a4 = 0;
LABEL_63:

                        goto LABEL_64;
                      }
                      id v133 = objc_alloc((Class)NSError);
                      v139 = v27;
                      unsigned int v33 = +[NSString stringWithUTF8String:"nfcd"];
                      NSErrorUserInfoKey v163 = NSLocalizedDescriptionKey;
                      v135 = +[NSString stringWithUTF8String:"Missing Parameter"];
                      *(void *)buf = v135;
                      *(void *)v160 = &off_10031DBC0;
                      CFStringRef v164 = @"Line";
                      CFStringRef v165 = @"Method";
                      id v94 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_tlvForApplicationIdentifier:error:")];
                      *(void *)&v160[8] = v94;
                      NSErrorUserInfoKey v166 = NSDebugDescriptionErrorKey;
                      id v95 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_tlvForApplicationIdentifier:error:"), 35];
                      *(void *)&v160[16] = v95;
                      __int16 v96 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v163 count:4];
                      *a4 = [v133 initWithDomain:v33 code:9 userInfo:v96];

                      BOOL v27 = v139;
                    }
                    int v35 = 0;
                    uint64_t v34 = &AMFDRSealingMapCopyLocalData_ptr;
                    goto LABEL_92;
                  }
                }
                if (a4)
                {
                  id v62 = objc_alloc((Class)NSError);
                  int v35 = +[NSString stringWithUTF8String:"nfcd"];
                  v143[0] = NSLocalizedDescriptionKey;
                  id v29 = +[NSString stringWithUTF8String:"Encoding Error"];
                  v144[0] = v29;
                  v144[1] = &off_10031DC98;
                  v143[1] = @"Line";
                  v143[2] = @"Method";
                  id v63 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("encodeRequest:withPIN:error:")];
                  v144[2] = v63;
                  v143[3] = NSDebugDescriptionErrorKey;
                  id v64 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("encodeRequest:withPIN:error:"), 269];
                  v144[3] = v64;
                  BOOL v65 = v144;
                  NSErrorUserInfoKey v66 = v143;
                  goto LABEL_61;
                }
LABEL_64:

                goto LABEL_65;
              }
              if (!a4) {
                goto LABEL_64;
              }
              id v62 = objc_alloc((Class)NSError);
              int v35 = +[NSString stringWithUTF8String:"nfcd"];
              v145[0] = NSLocalizedDescriptionKey;
              id v29 = +[NSString stringWithUTF8String:"Encoding Error"];
              v146[0] = v29;
              v146[1] = &off_10031DC80;
              v145[1] = @"Line";
              v145[2] = @"Method";
              id v63 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("encodeRequest:withPIN:error:")];
              v146[2] = v63;
              v145[3] = NSDebugDescriptionErrorKey;
              id v64 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("encodeRequest:withPIN:error:"), 266];
              v146[3] = v64;
              BOOL v65 = v146;
              NSErrorUserInfoKey v66 = v145;
            }
            else
            {
              if (!a4) {
                goto LABEL_64;
              }
              id v62 = objc_alloc((Class)NSError);
              int v35 = +[NSString stringWithUTF8String:"nfcd"];
              v147[0] = NSLocalizedDescriptionKey;
              id v29 = +[NSString stringWithUTF8String:"Encoding Error"];
              v148[0] = v29;
              v148[1] = &off_10031DC68;
              v147[1] = @"Line";
              v147[2] = @"Method";
              id v63 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("encodeRequest:withPIN:error:")];
              v148[2] = v63;
              v147[3] = NSDebugDescriptionErrorKey;
              id v64 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("encodeRequest:withPIN:error:"), 263];
              v148[3] = v64;
              BOOL v65 = v148;
              NSErrorUserInfoKey v66 = v147;
            }
          }
          else
          {
            if (!a4) {
              goto LABEL_64;
            }
            id v62 = objc_alloc((Class)NSError);
            int v35 = +[NSString stringWithUTF8String:"nfcd"];
            v149[0] = NSLocalizedDescriptionKey;
            id v29 = +[NSString stringWithUTF8String:"Encoding Error"];
            v150[0] = v29;
            v150[1] = &off_10031DC50;
            v149[1] = @"Line";
            v149[2] = @"Method";
            id v63 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("encodeRequest:withPIN:error:")];
            v150[2] = v63;
            v149[3] = NSDebugDescriptionErrorKey;
            id v64 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("encodeRequest:withPIN:error:"), 260];
            v150[3] = v64;
            BOOL v65 = v150;
            NSErrorUserInfoKey v66 = v149;
          }
        }
        else
        {
          if (!a4) {
            goto LABEL_64;
          }
          id v62 = objc_alloc((Class)NSError);
          int v35 = +[NSString stringWithUTF8String:"nfcd"];
          v151[0] = NSLocalizedDescriptionKey;
          id v29 = +[NSString stringWithUTF8String:"Encoding Error"];
          v152[0] = v29;
          v152[1] = &off_10031DC38;
          v151[1] = @"Line";
          v151[2] = @"Method";
          id v63 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("encodeRequest:withPIN:error:")];
          v152[2] = v63;
          v151[3] = NSDebugDescriptionErrorKey;
          id v64 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("encodeRequest:withPIN:error:"), 256];
          v152[3] = v64;
          BOOL v65 = v152;
          NSErrorUserInfoKey v66 = v151;
        }
      }
      else
      {
        if (!a4) {
          goto LABEL_64;
        }
        id v62 = objc_alloc((Class)NSError);
        int v35 = +[NSString stringWithUTF8String:"nfcd"];
        v153[0] = NSLocalizedDescriptionKey;
        id v29 = +[NSString stringWithUTF8String:"Encoding Error"];
        v154[0] = v29;
        v154[1] = &off_10031DC20;
        v153[1] = @"Line";
        v153[2] = @"Method";
        id v63 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("encodeRequest:withPIN:error:")];
        v154[2] = v63;
        v153[3] = NSDebugDescriptionErrorKey;
        id v64 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("encodeRequest:withPIN:error:"), 253];
        v154[3] = v64;
        BOOL v65 = v154;
        NSErrorUserInfoKey v66 = v153;
      }
LABEL_61:
      int v77 = +[NSDictionary dictionaryWithObjects:v65 forKeys:v66 count:4];
      *a4 = [v62 initWithDomain:v35 code:22 userInfo:v77];

      goto LABEL_62;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v52 = NFLogGetLogger();
    if (v52)
    {
      uint64_t v53 = (void (*)(uint64_t, const char *, ...))v52;
      int v54 = object_getClass(v8);
      BOOL v55 = class_isMetaClass(v54);
      uint64_t v56 = object_getClassName(v8);
      v129 = sel_getName("encodeRequest:withPIN:error:");
      uint64_t v57 = 45;
      if (v55) {
        uint64_t v57 = 43;
      }
      v53(3, "%c[%{public}s %{public}s]:%i Invalid parameter", v57, v56, v129, 244);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    unsigned int v58 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
    {
      unint64_t v59 = object_getClass(v8);
      if (class_isMetaClass(v59)) {
        int v60 = 43;
      }
      else {
        int v60 = 45;
      }
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)&uint8_t buf[4] = v60;
      *(_WORD *)v160 = 2082;
      *(void *)&v160[2] = object_getClassName(v8);
      *(_WORD *)&v160[10] = 2082;
      *(void *)&v160[12] = sel_getName("encodeRequest:withPIN:error:");
      *(_WORD *)&v160[20] = 1024;
      *(_DWORD *)&v160[22] = 244;
      _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid parameter", buf, 0x22u);
    }

    if (a4)
    {
      id v45 = objc_alloc((Class)NSError);
      uint64_t v46 = +[NSString stringWithUTF8String:"nfcd"];
      v155[0] = NSLocalizedDescriptionKey;
      uint64_t v47 = +[NSString stringWithUTF8String:"Invalid Parameter"];
      v156[0] = v47;
      v156[1] = &off_10031DC08;
      v155[1] = @"Line";
      v155[2] = @"Method";
      id v48 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("encodeRequest:withPIN:error:")];
      v156[2] = v48;
      v155[3] = NSDebugDescriptionErrorKey;
      id v49 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("encodeRequest:withPIN:error:"), 245];
      v156[3] = v49;
      BOOL v50 = v156;
      BOOL v51 = v155;
      goto LABEL_38;
    }
  }
  else
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v36 = NFLogGetLogger();
    if (v36)
    {
      BOOL v37 = (void (*)(uint64_t, const char *, ...))v36;
      __int16 v38 = object_getClass(v8);
      BOOL v39 = class_isMetaClass(v38);
      __int16 v40 = object_getClassName(v8);
      v128 = sel_getName("encodeRequest:withPIN:error:");
      uint64_t v41 = 45;
      if (v39) {
        uint64_t v41 = 43;
      }
      v37(3, "%c[%{public}s %{public}s]:%i Invalid parameter", v41, v40, v128, 238);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v42 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
    {
      id v43 = object_getClass(v8);
      if (class_isMetaClass(v43)) {
        int v44 = 43;
      }
      else {
        int v44 = 45;
      }
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)&uint8_t buf[4] = v44;
      *(_WORD *)v160 = 2082;
      *(void *)&v160[2] = object_getClassName(v8);
      *(_WORD *)&v160[10] = 2082;
      *(void *)&v160[12] = sel_getName("encodeRequest:withPIN:error:");
      *(_WORD *)&v160[20] = 1024;
      *(_DWORD *)&v160[22] = 238;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid parameter", buf, 0x22u);
    }

    if (a4)
    {
      id v45 = objc_alloc((Class)NSError);
      uint64_t v46 = +[NSString stringWithUTF8String:"nfcd"];
      v157[0] = NSLocalizedDescriptionKey;
      uint64_t v47 = +[NSString stringWithUTF8String:"Invalid Parameter"];
      v158[0] = v47;
      v158[1] = &off_10031DBF0;
      v157[1] = @"Line";
      v157[2] = @"Method";
      id v48 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("encodeRequest:withPIN:error:")];
      v158[2] = v48;
      v157[3] = NSDebugDescriptionErrorKey;
      id v49 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("encodeRequest:withPIN:error:"), 239];
      v158[3] = v49;
      BOOL v50 = v158;
      BOOL v51 = v157;
LABEL_38:
      unint64_t v61 = +[NSDictionary dictionaryWithObjects:v50 forKeys:v51 count:4];
      *a4 = [v45 initWithDomain:v46 code:10 userInfo:v61];

      a4 = 0;
    }
  }
LABEL_65:

  return a4;
}

uint64_t sub_1001D972C(uint64_t a1, void *a2)
{
  id v2 = a2;
  id v3 = self;
  if ([v2 length] != (id)3)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v7 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v3);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(v3);
      Name = sel_getName("_iso4217ForCurrencyCode:");
      uint64_t v11 = 45;
      if (isMetaClass) {
        uint64_t v11 = 43;
      }
      v7(3, "%c[%{public}s %{public}s]:%i Invalid parameter length", v11, ClassName, Name, 295);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v12 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    int v13 = object_getClass(v3);
    if (class_isMetaClass(v13)) {
      int v14 = 43;
    }
    else {
      int v14 = 45;
    }
    *(_DWORD *)buf = 67109890;
    int v31 = v14;
    __int16 v32 = 2082;
    unsigned int v33 = object_getClassName(v3);
    __int16 v34 = 2082;
    int v35 = sel_getName("_iso4217ForCurrencyCode:");
    __int16 v36 = 1024;
    int v37 = 295;
    int v15 = "%c[%{public}s %{public}s]:%i Invalid parameter length";
    uint64_t v16 = v12;
    uint32_t v17 = 34;
    goto LABEL_22;
  }
  uint64_t v40 = 0;
  [v2 getCharacters:&v40 range:0, 3];
  int NumericCode = ucurr_getNumericCode();
  if (!NumericCode)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v18 = NFLogGetLogger();
    if (v18)
    {
      unint64_t v19 = (void (*)(uint64_t, const char *, ...))v18;
      uint64_t v20 = object_getClass(v3);
      BOOL v21 = class_isMetaClass(v20);
      BOOL v27 = object_getClassName(v3);
      id v29 = sel_getName("_iso4217ForCurrencyCode:");
      uint64_t v22 = 45;
      if (v21) {
        uint64_t v22 = 43;
      }
      v19(3, "%c[%{public}s %{public}s]:%i Unable to determine ISO currency code for %{public}@", v22, v27, v29, 304, v2);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v12 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    id v23 = object_getClass(v3);
    if (class_isMetaClass(v23)) {
      int v24 = 43;
    }
    else {
      int v24 = 45;
    }
    *(_DWORD *)buf = 67110146;
    int v31 = v24;
    __int16 v32 = 2082;
    unsigned int v33 = object_getClassName(v3);
    __int16 v34 = 2082;
    int v35 = sel_getName("_iso4217ForCurrencyCode:");
    __int16 v36 = 1024;
    int v37 = 304;
    __int16 v38 = 2114;
    id v39 = v2;
    int v15 = "%c[%{public}s %{public}s]:%i Unable to determine ISO currency code for %{public}@";
    uint64_t v16 = v12;
    uint32_t v17 = 44;
LABEL_22:
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, v15, buf, v17);
LABEL_23:

    uint64_t v26 = -1;
    goto LABEL_24;
  }
  int v5 = NumericCode;
  ucurr_getDefaultFractionDigits();
  uint64_t v26 = v5;
LABEL_24:

  return v26;
}

void sub_1001D9B88(uint64_t a1, void *a2, void *a3, uint64_t a4)
{
  id v7 = a2;
  id v8 = a3;
  if (a1)
  {
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    v9[2] = sub_1001D9C68;
    v9[3] = &unk_100306DD8;
    v9[4] = a1;
    uint64_t v12 = "notifySharingServicesClient:payload:retryCount:";
    uint64_t v13 = a4;
    id v10 = v7;
    id v11 = v8;
    [v10 broadwayPresentCardWithCode:v11 options:0 completion:v9];
  }
}

void sub_1001D9C68(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (!v3)
  {
LABEL_23:
    [*(id *)(a1 + 40) invalidate];
    goto LABEL_24;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    int v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v5(5, "%c[%{public}s %{public}s]:%i error=%{public}@", v8, ClassName, Name, 36, v3);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  BOOL v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    id v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    uint64_t v12 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v13 = sel_getName(*(SEL *)(a1 + 56));
    *(_DWORD *)buf = 67110146;
    int v38 = v11;
    __int16 v39 = 2082;
    uint64_t v40 = v12;
    __int16 v41 = 2082;
    __int16 v42 = v13;
    __int16 v43 = 1024;
    int v44 = 36;
    __int16 v45 = 2114;
    id v46 = v3;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i error=%{public}@", buf, 0x2Cu);
  }

  if (!*(void *)(a1 + 64))
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v19 = NFLogGetLogger();
    if (v19)
    {
      uint64_t v20 = (void (*)(uint64_t, const char *, ...))v19;
      BOOL v21 = object_getClass(*(id *)(a1 + 32));
      BOOL v22 = class_isMetaClass(v21);
      id v23 = object_getClassName(*(id *)(a1 + 32));
      __int16 v32 = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v24 = 45;
      if (v22) {
        uint64_t v24 = 43;
      }
      v20(3, "%c[%{public}s %{public}s]:%i Maximum retry count is reached; dropping notification",
        v24,
        v23,
        v32,
        38);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v25 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      uint64_t v26 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v26)) {
        int v27 = 43;
      }
      else {
        int v27 = 45;
      }
      __int16 v28 = object_getClassName(*(id *)(a1 + 32));
      id v29 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)buf = 67109890;
      int v38 = v27;
      __int16 v39 = 2082;
      uint64_t v40 = v28;
      __int16 v41 = 2082;
      __int16 v42 = v29;
      __int16 v43 = 1024;
      int v44 = 38;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Maximum retry count is reached; dropping notification",
        buf,
        0x22u);
    }

    goto LABEL_23;
  }
  dispatch_time_t v14 = dispatch_time(0, 100000000);
  int v15 = dispatch_get_global_queue(25, 0);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1001D9FD8;
  block[3] = &unk_100301CE0;
  uint64_t v16 = *(void **)(a1 + 40);
  block[4] = *(void *)(a1 + 32);
  id v34 = v16;
  id v17 = *(id *)(a1 + 48);
  uint64_t v18 = *(void *)(a1 + 64);
  id v35 = v17;
  uint64_t v36 = v18;
  dispatch_after(v14, v15, block);

LABEL_24:
}

uint64_t sub_1001D9FD8(void *a1)
{
  return sub_1001D9B88(a1[4], a1[5], a1[6], a1[7] - 1);
}

void sub_1001DA694(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

uint64_t sub_1001DA6B4()
{
  if (!qword_1003475B8) {
    qword_1003475B8 = _sl_dlopen();
  }
  return qword_1003475B8;
}

uint64_t sub_1001DA784()
{
  uint64_t result = _sl_dlopen();
  qword_1003475B8 = result;
  return result;
}

void sub_1001DA7F8(void *a1)
{
  if (!sub_1001DA6B4())
  {
    id v2 = +[NSAssertionHandler currentHandler];
    a1 = +[NSString stringWithUTF8String:"void *SharingLibrary(void)"];
    [v2 handleFailureInFunction:a1 file:@"NFTagAppProcessorWallet.m" lineNumber:19 description:@"%s"];

    __break(1u);
    free(v3);
  }
  *(void *)(*(void *)(a1[4] + 8) + 24) = objc_getClass("SFClient");
  if (*(void *)(*(void *)(a1[4] + 8) + 24))
  {
    qword_1003475C0 = *(void *)(*(void *)(a1[4] + 8) + 24);
  }
  else
  {
    id v4 = +[NSAssertionHandler currentHandler];
    int v5 = +[NSString stringWithUTF8String:"Class getSFClientClass(void)_block_invoke"];
    [v4 handleFailureInFunction:v5 file:@"NFTagAppProcessorWallet.m" lineNumber:20 description:@"Unable to find class %s", "SFClient"];

    __break(1u);
  }
}

id sub_1001DAE10(void *a1, void *a2, int a3, _DWORD *a4)
{
  id v53 = a2;
  if (!a1)
  {
LABEL_22:
    id v28 = 0;
    goto LABEL_26;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v8 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(a1);
    if (class_isMetaClass(Class)) {
      uint64_t v10 = 43;
    }
    else {
      uint64_t v10 = 45;
    }
    ClassName = object_getClassName(a1);
    Name = sel_getName("queueSessionPreCheckConnection:checkSE:outUID:");
    uint64_t v13 = [v53 NF_userInfo];
    dispatch_time_t v14 = [v13 objectForKeyedSubscript:@"ClientName"];
    v8(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 35, v14);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v15 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = object_getClass(a1);
    if (class_isMetaClass(v16)) {
      int v17 = 43;
    }
    else {
      int v17 = 45;
    }
    uint64_t v18 = object_getClassName(a1);
    uint64_t v19 = sel_getName("queueSessionPreCheckConnection:checkSE:outUID:");
    uint64_t v20 = [v53 NF_userInfo];
    BOOL v21 = [v20 objectForKeyedSubscript:@"ClientName"];
    *(_DWORD *)buf = 67110146;
    int v69 = v17;
    __int16 v70 = 2082;
    uint64_t v71 = v18;
    __int16 v72 = 2082;
    uint64_t v73 = v19;
    __int16 v74 = 1024;
    int v75 = 35;
    __int16 v76 = 2114;
    int v77 = v21;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  switch(-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)a1))
  {
    case 1u:
    case 3u:
      id v22 = objc_alloc((Class)NSError);
      id v23 = +[NSString stringWithUTF8String:"nfcd"];
      v66[0] = NSLocalizedDescriptionKey;
      uint64_t v24 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
      v67[0] = v24;
      v67[1] = &off_10031F3D8;
      v66[1] = @"Line";
      v66[2] = @"Method";
      id v25 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queueSessionPreCheckConnection:checkSE:outUID:")];
      v67[2] = v25;
      v66[3] = NSDebugDescriptionErrorKey;
      id v26 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("queueSessionPreCheckConnection:checkSE:outUID:"), 40];
      v67[3] = v26;
      int v27 = +[NSDictionary dictionaryWithObjects:v67 forKeys:v66 count:4];
      id v28 = [v22 initWithDomain:v23 code:58 userInfo:v27];

      break;
    case 4u:
      id v39 = objc_alloc((Class)NSError);
      id v23 = +[NSString stringWithUTF8String:"nfcd"];
      v64[0] = NSLocalizedDescriptionKey;
      uint64_t v40 = +[NSString stringWithUTF8String:"No NFC on device"];
      v65[0] = v40;
      v65[1] = &off_10031F3F0;
      v64[1] = @"Line";
      v64[2] = @"Method";
      id v41 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queueSessionPreCheckConnection:checkSE:outUID:")];
      v65[2] = v41;
      v64[3] = NSDebugDescriptionErrorKey;
      id v42 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("queueSessionPreCheckConnection:checkSE:outUID:"), 42];
      v65[3] = v42;
      __int16 v43 = +[NSDictionary dictionaryWithObjects:v65 forKeys:v64 count:4];
      id v28 = [v39 initWithDomain:v23 code:57 userInfo:v43];

      break;
    case 5u:
      id v44 = objc_alloc((Class)NSError);
      id v23 = +[NSString stringWithUTF8String:"nfcd"];
      v62[0] = NSLocalizedDescriptionKey;
      __int16 v45 = +[NSString stringWithUTF8String:"Invalid State"];
      v63[0] = v45;
      v63[1] = &off_10031F408;
      v62[1] = @"Line";
      v62[2] = @"Method";
      id v46 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queueSessionPreCheckConnection:checkSE:outUID:")];
      v63[2] = v46;
      v62[3] = NSDebugDescriptionErrorKey;
      id v47 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("queueSessionPreCheckConnection:checkSE:outUID:"), 44];
      v63[3] = v47;
      id v48 = +[NSDictionary dictionaryWithObjects:v63 forKeys:v62 count:4];
      id v28 = [v44 initWithDomain:v23 code:12 userInfo:v48];

      break;
    default:
      if (a4) {
        *a4 = -1;
      }
      if (!a3) {
        goto LABEL_22;
      }
      id v23 = a1;
      objc_sync_enter(v23);
      if ([v23[5] OSMode] == (id)2)
      {
        id v30 = objc_getProperty(v23, v29, 40, 1);
        unsigned int v31 = [v30 restrictedMode];

        if (v31)
        {
          id v32 = objc_alloc((Class)NSError);
          unsigned int v33 = +[NSString stringWithUTF8String:"nfcd"];
          v58[0] = NSLocalizedDescriptionKey;
          id v34 = +[NSString stringWithUTF8String:"Restricted Mode"];
          v59[0] = v34;
          v59[1] = &off_10031F438;
          v58[1] = @"Line";
          v58[2] = @"Method";
          id v35 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queueSessionPreCheckConnection:checkSE:outUID:")];
          v59[2] = v35;
          v58[3] = NSDebugDescriptionErrorKey;
          id v36 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("queueSessionPreCheckConnection:checkSE:outUID:"), 67];
          v59[3] = v36;
          int v37 = +[NSDictionary dictionaryWithObjects:v59 forKeys:v58 count:4];
          id v38 = [v32 initWithDomain:v33 code:24 userInfo:v37];
        }
        else if (sub_1000F2880((uint64_t)v23))
        {
          id v51 = objc_alloc((Class)NSError);
          unsigned int v33 = +[NSString stringWithUTF8String:"nfcd"];
          v56[0] = NSLocalizedDescriptionKey;
          id v34 = +[NSString stringWithUTF8String:"Applet Migration"];
          v57[0] = v34;
          v57[1] = &off_10031F450;
          v56[1] = @"Line";
          v56[2] = @"Method";
          id v35 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queueSessionPreCheckConnection:checkSE:outUID:")];
          v57[2] = v35;
          v56[3] = NSDebugDescriptionErrorKey;
          id v36 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("queueSessionPreCheckConnection:checkSE:outUID:"), 70];
          v57[3] = v36;
          int v37 = +[NSDictionary dictionaryWithObjects:v57 forKeys:v56 count:4];
          id v38 = [v51 initWithDomain:v33 code:26 userInfo:v37];
        }
        else
        {
          if (!sub_1000F28DC((uint64_t)v23))
          {
            objc_sync_exit(v23);
            id v28 = 0;
            break;
          }
          id v52 = objc_alloc((Class)NSError);
          unsigned int v33 = +[NSString stringWithUTF8String:"nfcd"];
          v54[0] = NSLocalizedDescriptionKey;
          id v34 = +[NSString stringWithUTF8String:"JCOP in OSU"];
          v55[0] = v34;
          v55[1] = &off_10031F468;
          v54[1] = @"Line";
          v54[2] = @"Method";
          id v35 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queueSessionPreCheckConnection:checkSE:outUID:")];
          v55[2] = v35;
          v54[3] = NSDebugDescriptionErrorKey;
          id v36 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("queueSessionPreCheckConnection:checkSE:outUID:"), 73];
          v55[3] = v36;
          int v37 = +[NSDictionary dictionaryWithObjects:v55 forKeys:v54 count:4];
          id v38 = [v52 initWithDomain:v33 code:52 userInfo:v37];
        }
      }
      else
      {
        id v49 = objc_alloc((Class)NSError);
        unsigned int v33 = +[NSString stringWithUTF8String:"nfcd"];
        v60[0] = NSLocalizedDescriptionKey;
        id v34 = +[NSString stringWithUTF8String:"JCOP not available"];
        v61[0] = v34;
        v61[1] = &off_10031F420;
        v60[1] = @"Line";
        v60[2] = @"Method";
        id v35 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queueSessionPreCheckConnection:checkSE:outUID:")];
        v61[2] = v35;
        v60[3] = NSDebugDescriptionErrorKey;
        id v36 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("queueSessionPreCheckConnection:checkSE:outUID:"), 64];
        v61[3] = v36;
        int v37 = +[NSDictionary dictionaryWithObjects:v61 forKeys:v60 count:4];
        id v38 = [v49 initWithDomain:v33 code:53 userInfo:v37];
      }
      id v28 = v38;

      objc_sync_exit(v23);
      break;
  }

LABEL_26:

  return v28;
}

void sub_1001DB954(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_1001DBA28(id *a1, void *a2, void *a3, unsigned char *a4)
{
  id v148 = a2;
  id v147 = a3;
  if (a1)
  {
    self = a1;
    id v8 = objc_getProperty(a1, v7, 176, 1);
    objc_sync_enter(v8);
    BOOL v9 = self;
    id v11 = objc_getProperty(self, v10, 176, 1);
    unsigned __int8 v12 = [v11 containsObject:v147];

    objc_sync_exit(v8);
    id obj = self[23];
    objc_sync_enter(obj);
    if (([v148 didEnd] & 1) != 0 || objc_msgSend(v148, "isEnding"))
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (Logger)
      {
        Class = object_getClass(self);
        if (class_isMetaClass(Class)) {
          uint64_t v15 = 43;
        }
        else {
          uint64_t v15 = 45;
        }
        ClassName = object_getClassName(self);
        Name = sel_getName("queueSecureElementSession:forConnection:isFirstInQueue:");
        Logger(6, "%c[%{public}s %{public}s]:%i Session ended before queueing - not queueing it up.", v15, ClassName, Name, 96);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v18 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v19 = object_getClass(self);
        if (class_isMetaClass(v19)) {
          int v20 = 43;
        }
        else {
          int v20 = 45;
        }
        *(_DWORD *)buf = 67109890;
        *(_DWORD *)v183 = v20;
        *(_WORD *)&v183[4] = 2082;
        *(void *)&v183[6] = object_getClassName(self);
        __int16 v184 = 2082;
        v185 = sel_getName("queueSecureElementSession:forConnection:isFirstInQueue:");
        __int16 v186 = 1024;
        int v187 = 96;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Session ended before queueing - not queueing it up.", buf, 0x22u);
      }
      id v21 = 0;
    }
    else
    {
      uint64_t v24 = [v148 startOnFieldList];
      id v25 = [v24 count];

      if (v25)
      {
        long long v173 = 0u;
        long long v174 = 0u;
        long long v171 = 0u;
        long long v172 = 0u;
        id v26 = self[24];
        id v27 = [v26 countByEnumeratingWithState:&v171 objects:v197 count:16];
        if (v27)
        {
          uint64_t v28 = *(void *)v172;
          v149 = v26;
          while (2)
          {
            for (i = 0; i != v27; i = (char *)i + 1)
            {
              if (*(void *)v172 != v28) {
                objc_enumerationMutation(v149);
              }
              id v30 = *(void **)(*((void *)&v171 + 1) + 8 * i);
              if (([v30 isEnding] & 1) == 0
                && ([v30 didEnd] & 1) == 0)
              {
                unsigned int v31 = [v30 startOnFieldList];
                BOOL v32 = [v31 count] == 0;

                if (!v32)
                {
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  id v39 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
                  if (v39)
                  {
                    uint64_t v40 = object_getClass(self);
                    if (class_isMetaClass(v40)) {
                      uint64_t v41 = 43;
                    }
                    else {
                      uint64_t v41 = 45;
                    }
                    id v42 = object_getClassName(self);
                    __int16 v43 = sel_getName("queueSecureElementSession:forConnection:isFirstInQueue:");
                    v39(3, "%c[%{public}s %{public}s]:%i Session in suspended queue:", v41, v42, v43, 105);
                  }
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  id v44 = NFSharedLogGetLogger();
                  if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
                  {
                    __int16 v45 = object_getClass(self);
                    if (class_isMetaClass(v45)) {
                      int v46 = 43;
                    }
                    else {
                      int v46 = 45;
                    }
                    id v47 = object_getClassName(self);
                    id v48 = sel_getName("queueSecureElementSession:forConnection:isFirstInQueue:");
                    *(_DWORD *)buf = 67109890;
                    *(_DWORD *)v183 = v46;
                    *(_WORD *)&v183[4] = 2082;
                    *(void *)&v183[6] = v47;
                    __int16 v184 = 2082;
                    v185 = v48;
                    __int16 v186 = 1024;
                    int v187 = 105;
                    _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session in suspended queue:", buf, 0x22u);
                  }

                  long long v169 = 0u;
                  long long v170 = 0u;
                  long long v167 = 0u;
                  long long v168 = 0u;
                  id v150 = self[24];
                  id v154 = [v150 countByEnumeratingWithState:&v167 objects:v196 count:16];
                  if (v154)
                  {
                    uint64_t v152 = *(void *)v168;
                    do
                    {
                      for (j = 0; j != v154; j = (char *)j + 1)
                      {
                        if (*(void *)v168 != v152) {
                          objc_enumerationMutation(v150);
                        }
                        id v49 = *(void **)(*((void *)&v167 + 1) + 8 * (void)j);
                        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                        BOOL v50 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
                        if (v50)
                        {
                          id v51 = object_getClass(self);
                          if (class_isMetaClass(v51)) {
                            uint64_t v52 = 43;
                          }
                          else {
                            uint64_t v52 = 45;
                          }
                          id v53 = object_getClassName(self);
                          int v54 = sel_getName("queueSecureElementSession:forConnection:isFirstInQueue:");
                          BOOL v55 = [v49 sessionUID];
                          uint64_t v56 = [v49 clientName];
                          id v57 = [v49 processIdentifier];
                          unsigned int v58 = +[NSDate now];
                          unint64_t v59 = [v49 dequeueDate];
                          [v58 timeIntervalSinceDate:v59];
                          v50(3, "%c[%{public}s %{public}s]:%i %{public}@ for %{public}@ (%d) for %f seconds", v52, v53, v54, 111, v55, v56, v57, v60);
                        }
                        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                        unint64_t v61 = NFSharedLogGetLogger();
                        if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
                        {
                          id v62 = object_getClass(self);
                          if (class_isMetaClass(v62)) {
                            int v63 = 43;
                          }
                          else {
                            int v63 = 45;
                          }
                          id v64 = object_getClassName(self);
                          BOOL v65 = sel_getName("queueSecureElementSession:forConnection:isFirstInQueue:");
                          id v66 = [v49 sessionUID];
                          id v67 = [v49 clientName];
                          unsigned int v68 = [v49 processIdentifier];
                          int v69 = +[NSDate now];
                          __int16 v70 = [v49 dequeueDate];
                          [v69 timeIntervalSinceDate:v70];
                          *(_DWORD *)buf = 67110914;
                          *(_DWORD *)v183 = v63;
                          *(_WORD *)&v183[4] = 2082;
                          *(void *)&v183[6] = v64;
                          __int16 v184 = 2082;
                          v185 = v65;
                          __int16 v186 = 1024;
                          int v187 = 111;
                          __int16 v188 = 2114;
                          id v189 = v66;
                          __int16 v190 = 2114;
                          id v191 = v67;
                          __int16 v192 = 1024;
                          unsigned int v193 = v68;
                          __int16 v194 = 2048;
                          uint64_t v195 = v71;
                          _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i %{public}@ for %{public}@ (%d) for %f seconds", buf, 0x46u);
                        }
                      }
                      id v154 = [v150 countByEnumeratingWithState:&v167 objects:v196 count:16];
                    }
                    while (v154);
                  }

                  id v72 = objc_alloc((Class)NSError);
                  uint64_t v73 = +[NSString stringWithUTF8String:"nfcd"];
                  v180[0] = NSLocalizedDescriptionKey;
                  __int16 v74 = +[NSString stringWithUTF8String:"No resources"];
                  v181[0] = v74;
                  v181[1] = &off_10031F480;
                  v180[1] = @"Line";
                  v180[2] = @"Method";
                  id v75 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queueSecureElementSession:forConnection:isFirstInQueue:")];
                  v181[2] = v75;
                  v180[3] = NSDebugDescriptionErrorKey;
                  id v76 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("queueSecureElementSession:forConnection:isFirstInQueue:"), 113];
                  v181[3] = v76;
                  int v77 = +[NSDictionary dictionaryWithObjects:v181 forKeys:v180 count:4];
                  id v21 = [v72 initWithDomain:v73 code:34 userInfo:v77];

                  uint64_t v18 = v149;
                  goto LABEL_15;
                }
              }
            }
            id v26 = v149;
            id v27 = [v149 countByEnumeratingWithState:&v171 objects:v197 count:16];
            if (v27) {
              continue;
            }
            break;
          }
        }

        BOOL v9 = self;
      }
      objc_opt_class();
      if (v12 & 1 | ((objc_opt_isKindOfClass() & 1) == 0))
      {
        if (v147)
        {
          unsigned int v33 = [v147 NF_userInfo];
          id v34 = [v33 objectForKeyedSubscript:@"ProxyObjects"];

          if ([v148 serviceType] == (id)2)
          {
            long long v165 = 0u;
            long long v166 = 0u;
            long long v163 = 0u;
            long long v164 = 0u;
            uint64_t v18 = v34;
            id v35 = [v18 countByEnumeratingWithState:&v163 objects:v177 count:16];
            if (v35)
            {
              uint64_t v36 = *(void *)v164;
              while (2)
              {
                for (k = 0; k != v35; k = (char *)k + 1)
                {
                  if (*(void *)v164 != v36) {
                    objc_enumerationMutation(v18);
                  }
                  if ([*(id *)(*((void *)&v163 + 1) + 8 * (void)k) serviceType] == (id)2)
                  {
                    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                    __int16 v96 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
                    if (v96)
                    {
                      uint64_t v97 = object_getClass(self);
                      if (class_isMetaClass(v97)) {
                        uint64_t v98 = 43;
                      }
                      else {
                        uint64_t v98 = 45;
                      }
                      long long v99 = object_getClassName(self);
                      BOOL v100 = sel_getName("queueSecureElementSession:forConnection:isFirstInQueue:");
                      uint64_t v101 = objc_opt_class();
                      v96(6, "%c[%{public}s %{public}s]:%i %{public}@ already exist in queue", v98, v99, v100, 129, v101);
                    }
                    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                    uint64_t v102 = NFSharedLogGetLogger();
                    if (os_log_type_enabled(v102, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v103 = object_getClass(self);
                      if (class_isMetaClass(v103)) {
                        int v104 = 43;
                      }
                      else {
                        int v104 = 45;
                      }
                      unint64_t v105 = object_getClassName(self);
                      id v106 = sel_getName("queueSecureElementSession:forConnection:isFirstInQueue:");
                      v107 = objc_opt_class();
                      *(_DWORD *)buf = 67110146;
                      *(_DWORD *)v183 = v104;
                      *(_WORD *)&v183[4] = 2082;
                      *(void *)&v183[6] = v105;
                      __int16 v184 = 2082;
                      v185 = v106;
                      __int16 v186 = 1024;
                      int v187 = 129;
                      __int16 v188 = 2114;
                      id v189 = v107;
                      id v108 = v107;
                      _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@ already exist in queue", buf, 0x2Cu);
                    }
                    id v109 = objc_alloc((Class)NSError);
                    v110 = +[NSString stringWithUTF8String:"nfcd"];
                    v175[0] = NSLocalizedDescriptionKey;
                    id v111 = +[NSString stringWithUTF8String:"Busy"];
                    v176[0] = v111;
                    v176[1] = &off_10031F4B0;
                    v175[1] = @"Line";
                    v175[2] = @"Method";
                    id v112 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queueSecureElementSession:forConnection:isFirstInQueue:")];
                    v176[2] = v112;
                    v175[3] = NSDebugDescriptionErrorKey;
                    id v113 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("queueSecureElementSession:forConnection:isFirstInQueue:"), 130];
                    v176[3] = v113;
                    __int16 v114 = +[NSDictionary dictionaryWithObjects:v176 forKeys:v175 count:4];
                    id v21 = [v109 initWithDomain:v110 code:2 userInfo:v114];

                    goto LABEL_15;
                  }
                }
                id v35 = [v18 countByEnumeratingWithState:&v163 objects:v177 count:16];
                if (v35) {
                  continue;
                }
                break;
              }
            }
          }
          [v34 addObject:v148];

          BOOL v9 = self;
        }
        if (a4) {
          *a4 = [v9 isFirstInQueue];
        }
        ++*((unsigned char *)v9 + 336);
        [v148 setSessionID:];
        if (v25)
        {
          id v38 = v9[24];
          [v38 addObject:v148];
        }
        else
        {
          id v94 = v9[14];
          if (v94)
          {

            id v95 = self;
          }
          else
          {
            id v115 = v9[23];
            BOOL v116 = [v115 count] == 0;

            id v95 = self;
            if (v116) {
              sub_1000EA4BC(self, 1);
            }
          }
          id v38 = v95[23];
          [v38 addObject:v148];
        }

        int v117 = self;
        if ([v148 priority])
        {
          sub_1001DCE6C((uint64_t)self);
          __int16 v118 = sub_10012050C(self);
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472;
          block[2] = sub_1001DD0C0;
          block[3] = &unk_100301C68;
          block[4] = self;
          dispatch_async(v118, block);

          int v117 = self;
        }
        id v119 = v117[14];

        if (v119)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          NSErrorUserInfoKey v120 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v120)
          {
            uint64_t v121 = object_getClass(self);
            if (class_isMetaClass(v121)) {
              uint64_t v122 = 43;
            }
            else {
              uint64_t v122 = 45;
            }
            uint64_t v160 = v122;
            v155 = object_getClassName(self);
            v153 = sel_getName("queueSecureElementSession:forConnection:isFirstInQueue:");
            id v151 = self[14];
            v123 = [v151 sessionUID];
            id v124 = self[14];
            v125 = [v124 clientName];
            id v126 = self[14];
            id v127 = [v126 processIdentifier];
            v128 = +[NSDate now];
            id v129 = self[14];
            v130 = [v129 dequeueDate];
            [v128 timeIntervalSinceDate:v130];
            v120(6, "%c[%{public}s %{public}s]:%i Currently processing session %{public}@ for %{public}@ (%d) for %f seconds", v160, v155, v153, 167, v123, v125, v127, v131);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v132 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v132, OS_LOG_TYPE_DEFAULT))
          {
            id v133 = object_getClass(self);
            if (class_isMetaClass(v133)) {
              int v134 = 43;
            }
            else {
              int v134 = 45;
            }
            __int16 v161 = object_getClassName(self);
            sel = sel_getName("queueSecureElementSession:forConnection:isFirstInQueue:");
            id v156 = self[14];
            id v135 = [v156 sessionUID];
            id v136 = self[14];
            id v137 = [v136 clientName];
            id v138 = self[14];
            unsigned int v139 = [v138 processIdentifier];
            v140 = +[NSDate now];
            id v141 = self[14];
            uint64_t v142 = [v141 dequeueDate];
            [v140 timeIntervalSinceDate:v142];
            *(_DWORD *)buf = 67110914;
            *(_DWORD *)v183 = v134;
            *(_WORD *)&v183[4] = 2082;
            *(void *)&v183[6] = v161;
            __int16 v184 = 2082;
            v185 = sel;
            __int16 v186 = 1024;
            int v187 = 167;
            __int16 v188 = 2114;
            id v189 = v135;
            __int16 v190 = 2114;
            id v191 = v137;
            __int16 v192 = 1024;
            unsigned int v193 = v139;
            __int16 v194 = 2048;
            uint64_t v195 = v143;
            _os_log_impl((void *)&_mh_execute_header, v132, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Currently processing session %{public}@ for %{public}@ (%d) for %f seconds", buf, 0x46u);
          }
        }
        kdebug_trace();
        v144 = NFSharedSignpostLog();
        if (os_signpost_enabled(v144))
        {
          v145 = [v148 sessionUID];
          *(_DWORD *)buf = 138412290;
          *(void *)v183 = v145;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v144, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SESSION_QUEUED", "sessionUID=%@", buf, 0xCu);
        }
        objc_sync_exit(obj);

        id v22 = self[51];
        [v22 retainECPOption:[v148 backgroundTagReadEcpOption]];
        id v21 = 0;
        goto LABEL_16;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v78 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v78)
      {
        uint64_t v79 = object_getClass(v9);
        if (class_isMetaClass(v79)) {
          uint64_t v80 = 43;
        }
        else {
          uint64_t v80 = 45;
        }
        v81 = object_getClassName(v9);
        BOOL v82 = sel_getName("queueSecureElementSession:forConnection:isFirstInQueue:");
        v78(6, "%c[%{public}s %{public}s]:%i XPC connection disappeared before queueing.", v80, v81, v82, 119);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v83 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
      {
        BOOL v84 = object_getClass(v9);
        if (class_isMetaClass(v84)) {
          int v85 = 43;
        }
        else {
          int v85 = 45;
        }
        id v86 = object_getClassName(v9);
        id v87 = sel_getName("queueSecureElementSession:forConnection:isFirstInQueue:");
        *(_DWORD *)buf = 67109890;
        *(_DWORD *)v183 = v85;
        *(_WORD *)&v183[4] = 2082;
        *(void *)&v183[6] = v86;
        __int16 v184 = 2082;
        v185 = v87;
        __int16 v186 = 1024;
        int v187 = 119;
        _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i XPC connection disappeared before queueing.", buf, 0x22u);
      }

      id v88 = objc_alloc((Class)NSError);
      uint64_t v89 = +[NSString stringWithUTF8String:"nfcd"];
      v178[0] = NSLocalizedDescriptionKey;
      id v90 = +[NSString stringWithUTF8String:"User cancelled"];
      v179[0] = v90;
      v179[1] = &off_10031F498;
      v178[1] = @"Line";
      v178[2] = @"Method";
      id v91 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queueSecureElementSession:forConnection:isFirstInQueue:")];
      v179[2] = v91;
      v178[3] = NSDebugDescriptionErrorKey;
      id v92 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("queueSecureElementSession:forConnection:isFirstInQueue:"), 120];
      v179[3] = v92;
      __int16 v93 = +[NSDictionary dictionaryWithObjects:v179 forKeys:v178 count:4];
      id v21 = [v88 initWithDomain:v89 code:48 userInfo:v93];

      uint64_t v18 = v89;
    }
LABEL_15:

    id v22 = obj;
    objc_sync_exit(obj);
LABEL_16:

    goto LABEL_17;
  }
  id v21 = 0;
LABEL_17:

  return v21;
}

void sub_1001DCDC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id obj)
{
}

void sub_1001DCE6C(uint64_t a1)
{
  if (a1)
  {
    long long v20 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    id v2 = *(id *)(a1 + 184);
    id v3 = [v2 countByEnumeratingWithState:&v20 objects:v34 count:16];
    if (v3)
    {
      id v4 = v3;
      int v5 = 0;
      uint64_t v6 = *(void *)v21;
      do
      {
        for (i = 0; i != v4; i = (char *)i + 1)
        {
          if (*(void *)v21 != v6) {
            objc_enumerationMutation(v2);
          }
          v5 += [*(id *)(*((void *)&v20 + 1) + 8 * i) priority];
        }
        id v4 = [v2 countByEnumeratingWithState:&v20 objects:v34 count:16];
      }
      while (v4);
    }
    else
    {
      LOWORD(v5) = 0;
    }

    if ((unsigned __int16)v5 != *(unsigned __int16 *)(a1 + 334))
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        BOOL v9 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass((id)a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName((id)a1);
        Name = sel_getName("updatePrioritySessionCount");
        uint64_t v12 = 45;
        if (isMetaClass) {
          uint64_t v12 = 43;
        }
        v9(6, "%c[%{public}s %{public}s]:%i Priority session count = %d", v12, ClassName, Name, 190, (unsigned __int16)v5);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v13 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        dispatch_time_t v14 = object_getClass((id)a1);
        if (class_isMetaClass(v14)) {
          int v15 = 43;
        }
        else {
          int v15 = 45;
        }
        uint64_t v16 = object_getClassName((id)a1);
        int v17 = sel_getName("updatePrioritySessionCount");
        *(_DWORD *)buf = 67110146;
        int v25 = v15;
        __int16 v26 = 2082;
        id v27 = v16;
        __int16 v28 = 2082;
        id v29 = v17;
        __int16 v30 = 1024;
        int v31 = 190;
        __int16 v32 = 1024;
        int v33 = (unsigned __int16)v5;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Priority session count = %d", buf, 0x28u);
      }

      *(_WORD *)(a1 + 334) = v5;
    }
  }
}

void sub_1001DD0C0(uint64_t a1)
{
}

void sub_1001DD0C8(uint64_t a1)
{
  if (a1)
  {
    if (*(_WORD *)(a1 + 334))
    {
      id v2 = *(id *)(a1 + 112);
      if (v2)
      {
        id v3 = v2;
        id v4 = *(id *)(a1 + 112);
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
        }
        else
        {
          id v5 = *(id *)(a1 + 112);
          objc_opt_class();
          char isKindOfClass = objc_opt_isKindOfClass();

          if ((isKindOfClass & 1) == 0) {
            return;
          }
        }
        id v7 = *(id *)(a1 + 112);
        [v7 handlePendingServerRequest];
      }
    }
  }
}

uint64_t sub_1001DD1C4(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v99 = a3;
  BOOL v100 = v5;
  id v101 = a3;
  int v104 = a1;
  if (!a1)
  {
    uint64_t v31 = 0;
    goto LABEL_29;
  }
  uint64_t v122 = 0;
  v123 = (id *)&v122;
  uint64_t v124 = 0x3032000000;
  v125 = sub_10000B908;
  id v126 = sub_1001DDF94;
  id v127 = 0;
  unsigned __int8 v6 = [v5 cachedBeforeRFReset];
  if (!sub_1000FAF70(a1))
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (Logger)
    {
      Class = object_getClass(a1);
      if (class_isMetaClass(Class)) {
        uint64_t v23 = 43;
      }
      else {
        uint64_t v23 = 45;
      }
      ClassName = object_getClassName(a1);
      Name = sel_getName("resumeSessionWaitingOnField:forceStartSession:");
      Logger(6, "%c[%{public}s %{public}s]:%i Ignore field due to first unlock not completed", v23, ClassName, Name, 212);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v26 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      id v27 = object_getClass(a1);
      if (class_isMetaClass(v27)) {
        int v28 = 43;
      }
      else {
        int v28 = 45;
      }
      id v29 = object_getClassName(v104);
      __int16 v30 = sel_getName("resumeSessionWaitingOnField:forceStartSession:");
      *(_DWORD *)buf = 67109890;
      int v131 = v28;
      __int16 v132 = 2082;
      id v133 = v29;
      __int16 v134 = 2082;
      id v135 = v30;
      __int16 v136 = 1024;
      int v137 = 212;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Ignore field due to first unlock not completed", buf, 0x22u);
    }

    unsigned __int8 v128 = 0;
    goto LABEL_28;
  }
  id obj = a1[23];
  objc_sync_enter(obj);
  id v7 = a1[14];
  BOOL v8 = v7 == 0;

  if (!v8)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    BOOL v9 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v9)
    {
      SEL v10 = object_getClass(a1);
      if (class_isMetaClass(v10)) {
        uint64_t v11 = 43;
      }
      else {
        uint64_t v11 = 45;
      }
      uint64_t v12 = object_getClassName(a1);
      uint64_t v13 = sel_getName("resumeSessionWaitingOnField:forceStartSession:");
      id v14 = a1[14];
      v9(4, "%c[%{public}s %{public}s]:%i Active session running, %{public}@", v11, v12, v13, 220, v14);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v15 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      uint64_t v16 = object_getClass(a1);
      if (class_isMetaClass(v16)) {
        int v17 = 43;
      }
      else {
        int v17 = 45;
      }
      uint64_t v18 = object_getClassName(v104);
      uint64_t v19 = sel_getName("resumeSessionWaitingOnField:forceStartSession:");
      id v20 = v104[14];
      *(_DWORD *)buf = 67110146;
      int v131 = v17;
      __int16 v132 = 2082;
      id v133 = v18;
      __int16 v134 = 2082;
      id v135 = v19;
      __int16 v136 = 1024;
      int v137 = 220;
      __int16 v138 = 2114;
      id v139 = v20;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Active session running, %{public}@", buf, 0x2Cu);
    }
    id v102 = 0;
    id v103 = 0;
LABEL_15:
    unsigned __int8 v128 = 0;
    goto LABEL_16;
  }
  long long v120 = 0u;
  long long v121 = 0u;
  long long v118 = 0u;
  long long v119 = 0u;
  id v33 = a1[24];
  id v34 = [v33 countByEnumeratingWithState:&v118 objects:v129 count:16];
  if (!v34)
  {
    id v102 = 0;
    id v103 = 0;
    goto LABEL_75;
  }
  id v102 = 0;
  id v103 = 0;
  uint64_t v35 = *(void *)v119;
  do
  {
    for (i = 0; i != v34; i = (char *)i + 1)
    {
      if (*(void *)v119 != v35) {
        objc_enumerationMutation(v33);
      }
      id v37 = *(id *)(*((void *)&v118 + 1) + 8 * i);
      id v38 = v123[5];
      if (v101)
      {
        if (!v38 && v37 == v101)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v40 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v40)
          {
            uint64_t v41 = object_getClass(v104);
            if (class_isMetaClass(v41)) {
              uint64_t v42 = 43;
            }
            else {
              uint64_t v42 = 45;
            }
            __int16 v43 = object_getClassName(v104);
            id v44 = sel_getName("resumeSessionWaitingOnField:forceStartSession:");
            v40(5, "%c[%{public}s %{public}s]:%i Force start session found", v42, v43, v44, 227);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          __int16 v45 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
          {
            int v46 = object_getClass(v104);
            if (class_isMetaClass(v46)) {
              int v47 = 43;
            }
            else {
              int v47 = 45;
            }
            id v48 = object_getClassName(v104);
            id v49 = sel_getName("resumeSessionWaitingOnField:forceStartSession:");
            *(_DWORD *)buf = 67109890;
            int v131 = v47;
            __int16 v132 = 2082;
            id v133 = v48;
            __int16 v134 = 2082;
            id v135 = v49;
            __int16 v136 = 1024;
            int v137 = 227;
            _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Force start session found", buf, 0x22u);
          }

          objc_storeStrong(v123 + 5, v99);
          id v38 = v123[5];
        }
      }
      if (v38) {
        char v50 = 1;
      }
      else {
        char v50 = v6;
      }
      if ((v50 & 1) == 0)
      {
        id v51 = [v37 startOnFieldList];
        v112[0] = _NSConcreteStackBlock;
        v112[1] = 3221225472;
        v112[2] = sub_1001DDF9C;
        v112[3] = &unk_100306E18;
        id v113 = v100;
        __int16 v114 = v104;
        id v115 = v37;
        BOOL v116 = &v122;
        int v117 = "resumeSessionWaitingOnField:forceStartSession:";
        [v51 enumerateObjectsUsingBlock:v112];
      }
      if (v103) {
        char v52 = 1;
      }
      else {
        char v52 = v6;
      }
      if ((v52 & 1) == 0)
      {
        if (([v37 fieldHandlingInSuspension] & 1) != 0
          && (objc_opt_respondsToSelector() & 1) != 0)
        {
          id v103 = v37;
        }
        else
        {
          id v103 = 0;
        }
      }
      if (!v102)
      {
        id v53 = [v37 startOnFieldList];
        if ([v53 count])
        {
          int v54 = [v37 parentToken];
          BOOL v55 = v54 == 0;

          if (v55)
          {
            id v102 = v37;
            continue;
          }
        }
        else
        {
        }
        id v102 = 0;
      }
    }
    id v34 = [v33 countByEnumeratingWithState:&v118 objects:v129 count:16];
  }
  while (v34);
LABEL_75:

  if (!v123[5])
  {
    if (!v101)
    {
      if (v102)
      {
        unsigned int v68 = [v104 lastKnownRoutingConfig];
        unsigned int v69 = [v68 fdOn];

        if (v69)
        {
          unsigned __int8 v70 = [v102 fieldHandlingInSuspension];
          uint64_t v108 = 0;
          id v109 = &v108;
          uint64_t v110 = 0x2020000000;
          char v111 = 0;
          if ((v70 & 2) != 0)
          {
            BOOL v84 = [v102 startOnFieldList];
            v105[0] = _NSConcreteStackBlock;
            v105[1] = 3221225472;
            v105[2] = sub_1001DE1A4;
            v105[3] = &unk_100306E40;
            id v106 = v100;
            v107 = &v108;
            [v84 enumerateObjectsUsingBlock:v105];
          }
          else
          {
            char v111 = 1;
          }
          if ((v6 & 1) == 0)
          {
            if (*((unsigned char *)v109 + 24))
            {
              int v85 = v104[3];
              if (!v85 || (BOOL v86 = v85[172] == 0, v85, v86))
              {
                id v87 = [v100 chFieldType];
                if (v87 != (id)3 && v87 != (id)5)
                {
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  id v88 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
                  if (v88)
                  {
                    uint64_t v89 = object_getClass(v104);
                    if (class_isMetaClass(v89)) {
                      uint64_t v90 = 43;
                    }
                    else {
                      uint64_t v90 = 45;
                    }
                    id v91 = object_getClassName(v104);
                    id v92 = sel_getName("resumeSessionWaitingOnField:forceStartSession:");
                    v88(6, "%c[%{public}s %{public}s]:%i Restart discovery & field detect", v90, v91, v92, 292);
                  }
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  __int16 v93 = NFSharedLogGetLogger();
                  if (os_log_type_enabled(v93, OS_LOG_TYPE_DEFAULT))
                  {
                    id v94 = object_getClass(v104);
                    if (class_isMetaClass(v94)) {
                      int v95 = 43;
                    }
                    else {
                      int v95 = 45;
                    }
                    __int16 v96 = object_getClassName(v104);
                    uint64_t v97 = sel_getName("resumeSessionWaitingOnField:forceStartSession:");
                    *(_DWORD *)buf = 67109890;
                    int v131 = v95;
                    __int16 v132 = 2082;
                    id v133 = v96;
                    __int16 v134 = 2082;
                    id v135 = v97;
                    __int16 v136 = 1024;
                    int v137 = 292;
                    _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Restart discovery & field detect", buf, 0x22u);
                  }

                  [v104 restartDiscovery];
                }
              }
            }
          }
          _Block_object_dispose(&v108, 8);
        }
      }
      if (v103) {
        [v103 handleFieldNotification:v100];
      }
    }
    goto LABEL_15;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v56 = v123[5];
    unsigned int v57 = [v56 disableAutoStartOnField] ^ 1;
    if (v101) {
      LOBYTE(v57) = 1;
    }
    if ((v57 & 1) == 0)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      unsigned int v58 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v58)
      {
        unint64_t v59 = object_getClass(v104);
        if (class_isMetaClass(v59)) {
          uint64_t v60 = 43;
        }
        else {
          uint64_t v60 = 45;
        }
        unint64_t v61 = object_getClassName(v104);
        id v62 = sel_getName("resumeSessionWaitingOnField:forceStartSession:");
        v58(5, "%c[%{public}s %{public}s]:%i Session resume disabled", v60, v61, v62, 311);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v63 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
      {
        id v64 = object_getClass(v104);
        if (class_isMetaClass(v64)) {
          int v65 = 43;
        }
        else {
          int v65 = 45;
        }
        id v66 = object_getClassName(v104);
        id v67 = sel_getName("resumeSessionWaitingOnField:forceStartSession:");
        *(_DWORD *)buf = 67109890;
        int v131 = v65;
        __int16 v132 = 2082;
        id v133 = v66;
        __int16 v134 = 2082;
        id v135 = v67;
        __int16 v136 = 1024;
        int v137 = 311;
        _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Session resume disabled", buf, 0x22u);
      }

      if (v100) {
        [v56 suspensionStateUpdate:0 triggeredByField:v100];
      }
      unsigned __int8 v128 = 0;

      goto LABEL_16;
    }
    if (v100) {
      [v56 suspensionStateUpdate:1 triggeredByField:v100];
    }
  }
  if ([v123[5] didStart])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v71 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v71)
    {
      id v72 = object_getClass(v104);
      if (class_isMetaClass(v72)) {
        uint64_t v73 = 43;
      }
      else {
        uint64_t v73 = 45;
      }
      __int16 v74 = object_getClassName(v104);
      id v75 = sel_getName("resumeSessionWaitingOnField:forceStartSession:");
      v71(5, "%c[%{public}s %{public}s]:%i Resume session", v73, v74, v75, 324);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v76 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v76, OS_LOG_TYPE_DEFAULT))
    {
      int v77 = object_getClass(v104);
      if (class_isMetaClass(v77)) {
        int v78 = 43;
      }
      else {
        int v78 = 45;
      }
      uint64_t v79 = object_getClassName(v104);
      uint64_t v80 = sel_getName("resumeSessionWaitingOnField:forceStartSession:");
      *(_DWORD *)buf = 67109890;
      int v131 = v78;
      __int16 v132 = 2082;
      id v133 = v79;
      __int16 v134 = 2082;
      id v135 = v80;
      __int16 v136 = 1024;
      int v137 = 324;
      _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Resume session", buf, 0x22u);
    }

    id v81 = v104[51];
    [v81 stop];

    unsigned __int8 v128 = [v104 _syncResumeSession:v123[5] field:v100];
LABEL_16:
    objc_sync_exit(obj);
  }
  else
  {
    id v82 = v104[23];
    [v82 insertObject:v123[5] atIndex:0];

    id v83 = v104[24];
    [v83 removeObject:v123[5]];

    objc_sync_exit(obj);
    sub_1000F63F0(v104, v100);
    unsigned __int8 v128 = 1;
  }
LABEL_28:
  _Block_object_dispose(&v122, 8);

  uint64_t v31 = v128;
LABEL_29:

  return v31;
}

void sub_1001DDEF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id obj, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,char a54)
{
}

void sub_1001DDF94(uint64_t a1)
{
}

void sub_1001DDF9C(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  if ([a2 isEqual:*(void *)(a1 + 32)])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v7 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 40));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 40));
      Name = sel_getName(*(SEL *)(a1 + 64));
      uint64_t v12 = *(void *)(a1 + 48);
      uint64_t v13 = [*(id *)(a1 + 32) description];
      uint64_t v14 = 45;
      if (isMetaClass) {
        uint64_t v14 = 43;
      }
      v7(6, "%c[%{public}s %{public}s]:%i Found suspend %@ waiting on field %@", v14, ClassName, Name, 235, v12, v13);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v15 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = object_getClass(*(id *)(a1 + 40));
      if (class_isMetaClass(v16)) {
        int v17 = 43;
      }
      else {
        int v17 = 45;
      }
      uint64_t v18 = object_getClassName(*(id *)(a1 + 40));
      uint64_t v19 = sel_getName(*(SEL *)(a1 + 64));
      uint64_t v20 = *(void *)(a1 + 48);
      long long v21 = [*(id *)(a1 + 32) description];
      *(_DWORD *)buf = 67110402;
      int v23 = v17;
      __int16 v24 = 2082;
      int v25 = v18;
      __int16 v26 = 2082;
      id v27 = v19;
      __int16 v28 = 1024;
      int v29 = 235;
      __int16 v30 = 2112;
      uint64_t v31 = v20;
      __int16 v32 = 2112;
      id v33 = v21;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Found suspend %@ waiting on field %@", buf, 0x36u);
    }
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40), *(id *)(a1 + 48));
    *a4 = 1;
  }
}

id sub_1001DE1A4(uint64_t a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  id result = [*(id *)(a1 + 32) isEqualTerminalInfo:a2];
  if (result)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
    *a4 = 1;
  }
  return result;
}

uint64_t sub_1001DE1EC(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    long long v20 = 0u;
    long long v21 = 0u;
    long long v18 = 0u;
    long long v19 = 0u;
    id v2 = *(id *)(result + 192);
    id v3 = [v2 countByEnumeratingWithState:&v18 objects:v22 count:16];
    if (v3)
    {
      id v4 = v3;
      uint64_t v5 = *(void *)v19;
      while (2)
      {
        for (i = 0; i != v4; i = (char *)i + 1)
        {
          if (*(void *)v19 != v5) {
            objc_enumerationMutation(v2);
          }
          id v7 = *(void **)(*((void *)&v18 + 1) + 8 * i);
          uint64_t v8 = [v7 startOnFieldList:v18];
          if (v8)
          {
            BOOL v9 = (void *)v8;
            SEL v10 = [v7 parentToken];

            if (!v10)
            {

              return 1;
            }
          }
        }
        id v4 = [v2 countByEnumeratingWithState:&v18 objects:v22 count:16];
        if (v4) {
          continue;
        }
        break;
      }
    }

    id v11 = *(id *)(v1 + 112);
    if (v11) {
      goto LABEL_12;
    }
    id v11 = *(id *)(v1 + 184);
    uint64_t v12 = [v11 firstObject];
    uint64_t v13 = [v12 startOnFieldList];
    if (!v13)
    {

LABEL_12:
      return 0;
    }
    uint64_t v14 = (void *)v13;
    id v15 = *(id *)(v1 + 184);
    uint64_t v16 = [v15 firstObject];
    int v17 = [v16 parentToken];

    return !v17;
  }
  return result;
}

uint64_t sub_1001DE3AC(id *a1, void *a2, uint64_t a3, void *a4, void *a5, int a6)
{
  id v11 = a2;
  id v12 = a4;
  id v13 = a5;
  if (!a1) {
    goto LABEL_17;
  }
  if (a3 == 2 && !v12)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v15 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("suspendSession:reason:field:token:startNextSession:");
      uint64_t v19 = 45;
      if (isMetaClass) {
        uint64_t v19 = 43;
      }
      v15(3, "%c[%{public}s %{public}s]:%i Missing field", v19, ClassName, Name, 368);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    long long v20 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      long long v21 = object_getClass(a1);
      if (class_isMetaClass(v21)) {
        int v22 = 43;
      }
      else {
        int v22 = 45;
      }
      *(_DWORD *)buf = 67109890;
      int v57 = v22;
      __int16 v58 = 2082;
      unint64_t v59 = object_getClassName(a1);
      __int16 v60 = 2082;
      unint64_t v61 = sel_getName("suspendSession:reason:field:token:startNextSession:");
      __int16 v62 = 1024;
      int v63 = 368;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Missing field", buf, 0x22u);
    }
    goto LABEL_13;
  }
  if (![v11 didStart] || (objc_msgSend(v11, "didEnd") & 1) != 0)
  {
LABEL_17:
    uint64_t v23 = 0;
    goto LABEL_18;
  }
  if ([v11 isSuspended])
  {
    uint64_t v23 = 1;
    goto LABEL_18;
  }
  long long v20 = a1[23];
  objc_sync_enter(v20);
  id v25 = a1[14];

  if (v25 == v11)
  {
    id v34 = a1[24];
    [v34 addObject:v11];

    objc_storeStrong(a1 + 14, 0);
    id v35 = a1[23];
    id v36 = [v35 count];

    if (!v36) {
      sub_1000EA4BC(a1, 0);
    }
    BOOL v37 = a3 == 2;
    objc_sync_exit(v20);

    long long v20 = objc_opt_new();
    id v38 = +[NSNumber numberWithInteger:a3];
    [v20 setObject:v38 forKey:@"ReasonCode"];

    if (v37)
    {
      id v55 = 0;
      int v54 = +[NSKeyedArchiver archivedDataWithRootObject:v12 requiringSecureCoding:1 error:&v55];
      id v39 = v55;
      if (v39)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v40 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v40)
        {
          uint64_t v41 = object_getClass(a1);
          if (class_isMetaClass(v41)) {
            uint64_t v42 = 43;
          }
          else {
            uint64_t v42 = 45;
          }
          uint64_t v52 = v42;
          __int16 v43 = object_getClassName(a1);
          id v44 = sel_getName("suspendSession:reason:field:token:startNextSession:");
          v40(4, "%c[%{public}s %{public}s]:%i Archive error=%{public}@", v52, v43, v44, 402, v39);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        __int16 v45 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
        {
          int v46 = object_getClass(a1);
          if (class_isMetaClass(v46)) {
            int v47 = 43;
          }
          else {
            int v47 = 45;
          }
          int v53 = v47;
          id v48 = object_getClassName(a1);
          id v49 = sel_getName("suspendSession:reason:field:token:startNextSession:");
          *(_DWORD *)buf = 67110146;
          int v57 = v53;
          __int16 v58 = 2082;
          unint64_t v59 = v48;
          __int16 v60 = 2082;
          unint64_t v61 = v49;
          __int16 v62 = 1024;
          int v63 = 402;
          __int16 v64 = 2114;
          id v65 = v39;
          _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Archive error=%{public}@", buf, 0x2Cu);
        }
      }
      else
      {
        [v20 setObject:v54 forKey:@"Field"];
      }
    }
    if (v13)
    {
      char v50 = [v11 token];
      [v20 setObject:v50 forKey:@"Token"];
    }
    uint64_t v23 = (uint64_t)[v11 suspendWithInfo:v20];
    if ((v23 & a6) == 1)
    {
      [a1 maybeStartNextSession];
      uint64_t v23 = 1;
    }
    goto LABEL_14;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  __int16 v26 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
  if (v26)
  {
    id v27 = object_getClass(a1);
    if (class_isMetaClass(v27)) {
      uint64_t v28 = 43;
    }
    else {
      uint64_t v28 = 45;
    }
    int v29 = object_getClassName(a1);
    __int16 v30 = sel_getName("suspendSession:reason:field:token:startNextSession:");
    v26(6, "%c[%{public}s %{public}s]:%i %{public}@ is not active", v28, v29, v30, 387, v11);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v31 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v32 = object_getClass(a1);
    if (class_isMetaClass(v32)) {
      int v33 = 43;
    }
    else {
      int v33 = 45;
    }
    *(_DWORD *)buf = 67110146;
    int v57 = v33;
    __int16 v58 = 2082;
    unint64_t v59 = object_getClassName(a1);
    __int16 v60 = 2082;
    unint64_t v61 = sel_getName("suspendSession:reason:field:token:startNextSession:");
    __int16 v62 = 1024;
    int v63 = 387;
    __int16 v64 = 2114;
    id v65 = v11;
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@ is not active", buf, 0x2Cu);
  }

  objc_sync_exit(v20);
LABEL_13:
  uint64_t v23 = 0;
LABEL_14:

LABEL_18:
  return v23;
}

void sub_1001DE9AC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id *sub_1001DEEB4(id *a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    uint64_t v5 = [v3 parentToken];
    uint64_t v35 = 0;
    id v36 = &v35;
    uint64_t v37 = 0x3032000000;
    id v38 = sub_10000B908;
    id v39 = sub_1001DDF94;
    id v40 = 0;
    id v6 = a1[23];
    objc_sync_enter(v6);
    id v7 = a1[24];
    v32[0] = _NSConcreteStackBlock;
    v32[1] = 3221225472;
    v32[2] = sub_1001DF308;
    v32[3] = &unk_100306E68;
    id v8 = v5;
    id v33 = v8;
    id v34 = &v35;
    [v7 enumerateObjectsUsingBlock:v32];

    uint64_t v9 = v36[5];
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    if (v9)
    {
      uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (Logger)
      {
        Class = object_getClass(a1);
        if (class_isMetaClass(Class)) {
          uint64_t v12 = 43;
        }
        else {
          uint64_t v12 = 45;
        }
        ClassName = object_getClassName(a1);
        Name = sel_getName("requeueParentSession:");
        Logger(6, "%c[%{public}s %{public}s]:%i Found parent %{public}@ of session %{public}@ using parent token %{public}@", v12, ClassName, Name, 479, v36[5], v4, v8);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v15 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v16 = object_getClass(a1);
        if (class_isMetaClass(v16)) {
          int v17 = 43;
        }
        else {
          int v17 = 45;
        }
        long long v18 = object_getClassName(a1);
        uint64_t v19 = sel_getName("requeueParentSession:");
        long long v20 = (void *)v36[5];
        *(_DWORD *)buf = 67110658;
        int v42 = v17;
        __int16 v43 = 2082;
        id v44 = v18;
        __int16 v45 = 2082;
        int v46 = v19;
        __int16 v47 = 1024;
        int v48 = 479;
        __int16 v49 = 2114;
        char v50 = v20;
        __int16 v51 = 2114;
        id v52 = v4;
        __int16 v53 = 2114;
        id v54 = v8;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Found parent %{public}@ of session %{public}@ using parent token %{public}@", buf, 0x40u);
      }

      a1 = (id *)[a1 _syncResumeSession:v36[5]];
    }
    else
    {
      long long v21 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v21)
      {
        int v22 = object_getClass(a1);
        if (class_isMetaClass(v22)) {
          uint64_t v23 = 43;
        }
        else {
          uint64_t v23 = 45;
        }
        __int16 v24 = object_getClassName(a1);
        id v25 = sel_getName("requeueParentSession:");
        v21(6, "%c[%{public}s %{public}s]:%i No parent for session %{public}@ using parent token %{public}@", v23, v24, v25, 482, v4, v8);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v26 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        id v27 = object_getClass(a1);
        if (class_isMetaClass(v27)) {
          int v28 = 43;
        }
        else {
          int v28 = 45;
        }
        int v29 = object_getClassName(a1);
        __int16 v30 = sel_getName("requeueParentSession:");
        *(_DWORD *)buf = 67110402;
        int v42 = v28;
        __int16 v43 = 2082;
        id v44 = v29;
        __int16 v45 = 2082;
        int v46 = v30;
        __int16 v47 = 1024;
        int v48 = 482;
        __int16 v49 = 2114;
        char v50 = v4;
        __int16 v51 = 2114;
        id v52 = v8;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i No parent for session %{public}@ using parent token %{public}@", buf, 0x36u);
      }

      a1 = 0;
    }

    objc_sync_exit(v6);
    _Block_object_dispose(&v35, 8);
  }
  return a1;
}

void sub_1001DF2C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  objc_sync_exit(v23);
  _Block_object_dispose(&a23, 8);
  _Unwind_Resume(a1);
}

void sub_1001DF308(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  id v9 = a2;
  id v7 = [v9 token];
  unsigned int v8 = [v7 isEqualToData:*(void *)(a1 + 32)];

  if (v8)
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a2);
    *a4 = 1;
  }
}

void sub_1001DF454(uint64_t a1)
{
}

id sub_1001DF518(uint64_t a1)
{
  id v2 = sub_1001DBA28(*(id **)(a1 + 32), *(void **)(a1 + 40), 0, 0);
  id v3 = *(void **)(a1 + 32);

  return [v3 maybeStartNextSession];
}

void sub_1001DF624(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  if (v2) {
    id v2 = (void *)v2[23];
  }
  id v3 = v2;
  objc_sync_enter(v3);
  id v4 = *(void **)(a1 + 32);
  if (v4) {
    id v4 = (void *)v4[14];
  }
  uint64_t v5 = v4;
  id v6 = *(void **)(a1 + 40);

  if (v5 == v6)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (Logger)
    {
      Class = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(Class)) {
        uint64_t v31 = 43;
      }
      else {
        uint64_t v31 = 45;
      }
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      Logger(6, "%c[%{public}s %{public}s]:%i Session already running", v31, ClassName, Name, 513);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v28 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
    {
      id v34 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v34)) {
        int v35 = 43;
      }
      else {
        int v35 = 45;
      }
      id v36 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v37 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67109890;
      int v51 = v35;
      __int16 v52 = 2082;
      __int16 v53 = v36;
      __int16 v54 = 2082;
      id v55 = v37;
      __int16 v56 = 1024;
      int v57 = 513;
      id v38 = "%c[%{public}s %{public}s]:%i Session already running";
      id v39 = v28;
      os_log_type_t v40 = OS_LOG_TYPE_DEFAULT;
      goto LABEL_48;
    }
  }
  else
  {
    id v7 = *(void **)(a1 + 32);
    if (v7) {
      id v7 = (void *)v7[23];
    }
    unsigned int v8 = v7;
    unsigned __int8 v9 = [v8 containsObject:*(void *)(a1 + 40)];

    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    if (v9)
    {
      SEL v10 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v10)
      {
        id v11 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v11)) {
          uint64_t v12 = 43;
        }
        else {
          uint64_t v12 = 45;
        }
        id v13 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
        id v15 = *(void **)(a1 + 32);
        if (v15) {
          id v15 = (void *)v15[23];
        }
        uint64_t v16 = v15;
        v10(6, "%c[%{public}s %{public}s]:%i Prioritizing session from %d to 0", v12, v13, v14, 522, [v16 indexOfObject:*(void *)(a1 + 40)]);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v17 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        long long v18 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v18)) {
          int v19 = 43;
        }
        else {
          int v19 = 45;
        }
        long long v20 = object_getClassName(*(id *)(a1 + 32));
        long long v21 = sel_getName(*(SEL *)(a1 + 48));
        int v22 = *(void **)(a1 + 32);
        if (v22) {
          int v22 = (void *)v22[23];
        }
        uint64_t v23 = v22;
        unsigned int v24 = [v23 indexOfObject:*(void *)(a1 + 40)];
        *(_DWORD *)buf = 67110146;
        int v51 = v19;
        __int16 v52 = 2082;
        __int16 v53 = v20;
        __int16 v54 = 2082;
        id v55 = v21;
        __int16 v56 = 1024;
        int v57 = 522;
        __int16 v58 = 1024;
        unsigned int v59 = v24;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Prioritizing session from %d to 0", buf, 0x28u);
      }
      id v25 = *(void **)(a1 + 32);
      if (v25) {
        id v25 = (void *)v25[23];
      }
      __int16 v26 = v25;
      [v26 removeObject:*(void *)(a1 + 40)];

      id v27 = *(void **)(a1 + 32);
      if (v27) {
        id v27 = (void *)v27[23];
      }
      int v28 = v27;
      [v28 insertObject:*(void *)(a1 + 40) atIndex:0];
      goto LABEL_49;
    }
    uint64_t v41 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v41)
    {
      int v42 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v42)) {
        uint64_t v43 = 43;
      }
      else {
        uint64_t v43 = 45;
      }
      id v44 = object_getClassName(*(id *)(a1 + 32));
      __int16 v45 = sel_getName(*(SEL *)(a1 + 48));
      v41(3, "%c[%{public}s %{public}s]:%i Session not queued !", v43, v44, v45, 518);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v28 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      int v46 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v46)) {
        int v47 = 43;
      }
      else {
        int v47 = 45;
      }
      int v48 = object_getClassName(*(id *)(a1 + 32));
      __int16 v49 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67109890;
      int v51 = v47;
      __int16 v52 = 2082;
      __int16 v53 = v48;
      __int16 v54 = 2082;
      id v55 = v49;
      __int16 v56 = 1024;
      int v57 = 518;
      id v38 = "%c[%{public}s %{public}s]:%i Session not queued !";
      id v39 = v28;
      os_log_type_t v40 = OS_LOG_TYPE_ERROR;
LABEL_48:
      _os_log_impl((void *)&_mh_execute_header, v39, v40, v38, buf, 0x22u);
    }
  }
LABEL_49:

  objc_sync_exit(v3);
}

void sub_1001DFABC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1001E04F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id obj)
{
}

void sub_1001E0544(void *a1)
{
  if (a1)
  {
    id obj = a1;
    objc_sync_enter(obj);
    if (!obj[137]) {
      NFDriverSetPollingConfig();
    }
    objc_sync_exit(obj);
  }
}

void sub_1001E05CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

uint64_t sub_1001E05E0(void *a1)
{
  if (!a1) {
    return 0;
  }
  id v1 = a1;
  objc_sync_enter(v1);
  uint64_t v2 = NFDriverSetPollingProfile();
  objc_sync_exit(v1);

  return v2;
}

void sub_1001E0638(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1001E064C(void *a1)
{
  if (a1)
  {
    id obj = a1;
    objc_sync_enter(obj);
    NFDriverSetTemporaryPollingPeriod();
    objc_sync_exit(obj);
  }
}

void sub_1001E06C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void *sub_1001E06D4(void *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("configureECPPolling:");
      uint64_t v8 = 45;
      if (isMetaClass) {
        uint64_t v8 = 43;
      }
      v5(6, "%c[%{public}s %{public}s]:%i %{public}@", v8, ClassName, Name, 55, v3);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    unsigned __int8 v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      SEL v10 = object_getClass(a1);
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      *(_DWORD *)buf = 67110146;
      int v17 = v11;
      __int16 v18 = 2082;
      int v19 = object_getClassName(a1);
      __int16 v20 = 2082;
      long long v21 = sel_getName("configureECPPolling:");
      __int16 v22 = 1024;
      int v23 = 55;
      __int16 v24 = 2114;
      id v25 = v3;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
    }

    if (v3)
    {
      id v12 = v3;
      [v12 bytes];
      [v12 length];
    }
    a1 = (void *)NFDriverConfigureVASPolling();
  }

  return a1;
}

void *sub_1001E08CC(void *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v4 = a1;
    objc_sync_enter(v4);
    if (!v4[5])
    {
      id v6 = +[NSAssertionHandler currentHandler];
      [v6 handleFailureInMethod:"getRFSettings:" object:v4 file:@"NFDriverWrapper+RFConfig.m" lineNumber:73 description:@"driver not open"];
    }
    a1 = (void *)NFDriverRFSettingsCopy();
    objc_sync_exit(v4);
  }
  return a1;
}

void sub_1001E0A74(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1001E0A88(void *a1)
{
  if (!a1) {
    return 0;
  }
  id v1 = a1;
  objc_sync_enter(v1);
  if (v1[137]) {
    uint64_t v2 = 0;
  }
  else {
    uint64_t v2 = NFDriverEnableFelicaTxEndPatternV2();
  }
  objc_sync_exit(v1);

  return v2;
}

void sub_1001E0AE8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1001E0AFC(void *a1)
{
  if (!a1) {
    return 0;
  }
  id v1 = a1;
  objc_sync_enter(v1);
  if (v1[137]) {
    uint64_t v2 = 0;
  }
  else {
    uint64_t v2 = NFDriverConfigureExpressFelicaEntry();
  }
  objc_sync_exit(v1);

  return v2;
}

void sub_1001E0B64(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

BOOL sub_1001E0B78(void *a1)
{
  if (!a1) {
    return 0;
  }
  id v1 = a1;
  objc_sync_enter(v1);
  BOOL v2 = !v1[137] && (NFDriverEnableGreenCarThreshold() & 1) != 0;
  objc_sync_exit(v1);

  return v2;
}

void sub_1001E0BE4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1001E0BF8(void *a1)
{
  if (!a1) {
    return 0;
  }
  id v1 = a1;
  objc_sync_enter(v1);
  if (v1[137]) {
    uint64_t v2 = 0;
  }
  else {
    uint64_t v2 = NFDriverConfigureReaderModeRFForTransitPartner();
  }
  objc_sync_exit(v1);

  return v2;
}

void sub_1001E0C78(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_1001E0C8C(void *a1)
{
  if (a1)
  {
    id v1 = a1;
    objc_sync_enter(v1);
    if (v1[137])
    {
      id v2 = objc_alloc((Class)NSError);
      ErrorCode = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
      id v4 = +[NSString stringWithUTF8String:"Aborted"];
      id v13 = v4;
      uint64_t v5 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      id v6 = [v2 initWithDomain:ErrorCode code:3 userInfo:v5];
    }
    else
    {
      if (!NFDriverEnableAutomaticRFOverride())
      {
        id v6 = 0;
        goto LABEL_7;
      }
      ErrorCode = (void *)NFDriverCreateErrorCode();
      id v7 = objc_alloc((Class)NSError);
      id v4 = +[NSString stringWithUTF8String:"nfcd"];
      v10[0] = NSLocalizedDescriptionKey;
      uint64_t v5 = +[NSString stringWithUTF8String:"Stack Error"];
      v10[1] = NSUnderlyingErrorKey;
      v11[0] = v5;
      v11[1] = ErrorCode;
      uint64_t v8 = +[NSDictionary dictionaryWithObjects:v11 forKeys:v10 count:2];
      id v6 = [v7 initWithDomain:v4 code:15 userInfo:v8];
    }
LABEL_7:
    objc_sync_exit(v1);

    goto LABEL_8;
  }
  id v6 = 0;
LABEL_8:

  return v6;
}

void sub_1001E0E94(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_1001E0EB8(void *a1)
{
  if (a1)
  {
    id v1 = a1;
    objc_sync_enter(v1);
    if (v1[137])
    {
      id v2 = objc_alloc((Class)NSError);
      ErrorCode = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
      id v4 = +[NSString stringWithUTF8String:"Aborted"];
      id v13 = v4;
      uint64_t v5 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      id v6 = [v2 initWithDomain:ErrorCode code:3 userInfo:v5];
    }
    else
    {
      if (!NFDriverEnableReaderModeDynamicBBAControl())
      {
        id v6 = 0;
        goto LABEL_7;
      }
      ErrorCode = (void *)NFDriverCreateErrorCode();
      id v7 = objc_alloc((Class)NSError);
      id v4 = +[NSString stringWithUTF8String:"nfcd"];
      v10[0] = NSLocalizedDescriptionKey;
      uint64_t v5 = +[NSString stringWithUTF8String:"Stack Error"];
      v10[1] = NSUnderlyingErrorKey;
      v11[0] = v5;
      v11[1] = ErrorCode;
      uint64_t v8 = +[NSDictionary dictionaryWithObjects:v11 forKeys:v10 count:2];
      id v6 = [v7 initWithDomain:v4 code:15 userInfo:v8];
    }
LABEL_7:
    objc_sync_exit(v1);

    goto LABEL_8;
  }
  id v6 = 0;
LABEL_8:

  return v6;
}

void sub_1001E10C0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_1001E10E4(void *a1, void *a2)
{
  id v3 = a2;
  if (!a1) {
    goto LABEL_13;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(a1);
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(a1);
    Name = sel_getName("pushSignedRF:");
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v5(6, "%c[%{public}s %{public}s]:%i ", v9, ClassName, Name, 232);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  SEL v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = object_getClass(a1);
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    *(_DWORD *)buf = 67109890;
    int v31 = v12;
    __int16 v32 = 2082;
    id v33 = object_getClassName(a1);
    __int16 v34 = 2082;
    int v35 = sel_getName("pushSignedRF:");
    __int16 v36 = 1024;
    int v37 = 232;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  id v13 = v3;
  [v13 bytes];
  [v13 length];
  if (NFDataCreateWithBytes())
  {
    char v14 = NFDriverRFSettingsPushSignedSetting();
    NFDataRelease();
    if (v14)
    {
LABEL_13:
      id v15 = 0;
      goto LABEL_17;
    }
    id v23 = objc_alloc((Class)NSError);
    int v17 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v26 = NSLocalizedDescriptionKey;
    __int16 v18 = +[NSString stringWithUTF8String:"Unknown Error"];
    id v27 = v18;
    int v19 = +[NSDictionary dictionaryWithObjects:&v27 forKeys:&v26 count:1];
    __int16 v20 = v23;
    long long v21 = v17;
    uint64_t v22 = 6;
  }
  else
  {
    id v16 = objc_alloc((Class)NSError);
    int v17 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v28 = NSLocalizedDescriptionKey;
    __int16 v18 = +[NSString stringWithUTF8String:"No resources"];
    int v29 = v18;
    int v19 = +[NSDictionary dictionaryWithObjects:&v29 forKeys:&v28 count:1];
    __int16 v20 = v16;
    long long v21 = v17;
    uint64_t v22 = 34;
  }
  id v15 = [v20 initWithDomain:v21 code:v22 userInfo:v19];

LABEL_17:

  return v15;
}

id sub_1001E140C(void *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v4 = a1;
    objc_sync_enter(v4);
    if (v4[137])
    {
      id v5 = objc_alloc((Class)NSError);
      ErrorCode = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v16 = NSLocalizedDescriptionKey;
      id v7 = +[NSString stringWithUTF8String:"Aborted"];
      int v17 = v7;
      uint64_t v8 = +[NSDictionary dictionaryWithObjects:&v17 forKeys:&v16 count:1];
      id v9 = [v5 initWithDomain:ErrorCode code:3 userInfo:v8];
    }
    else
    {
      id v10 = v3;
      [v10 bytes];
      [v10 length];
      if (!NFDriverEnableAntiRelay())
      {
        id v9 = 0;
        goto LABEL_7;
      }
      ErrorCode = (void *)NFDriverCreateErrorCode();
      id v11 = objc_alloc((Class)NSError);
      id v7 = +[NSString stringWithUTF8String:"nfcd"];
      v14[0] = NSLocalizedDescriptionKey;
      uint64_t v8 = +[NSString stringWithUTF8String:"Stack Error"];
      v14[1] = NSUnderlyingErrorKey;
      v15[0] = v8;
      v15[1] = ErrorCode;
      int v12 = +[NSDictionary dictionaryWithObjects:v15 forKeys:v14 count:2];
      id v9 = [v11 initWithDomain:v7 code:15 userInfo:v12];
    }
LABEL_7:
    objc_sync_exit(v4);

    goto LABEL_8;
  }
  id v9 = 0;
LABEL_8:

  return v9;
}

void sub_1001E164C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id *sub_1001E1714(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    v9.receiver = a1;
    v9.super_class = (Class)NFAssertPreventConnectionHandover;
    id v7 = (id *)[super initWithRemoteAssertion:v5];
    a1 = v7;
    if (v7) {
      objc_storeStrong(v7 + 2, a3);
    }
  }

  return a1;
}

id sub_1001E1E24()
{
  self;
  id v0 = objc_alloc((Class)NSSet);
  uint64_t v1 = objc_opt_class();
  uint64_t v2 = objc_opt_class();
  uint64_t v3 = objc_opt_class();
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  id v37 = [v0 initWithObjects:v1, v2, v3, v4, v5, v6, objc_opt_class(), 0];
  id v36 = objc_alloc((Class)NSSet);
  uint64_t v35 = objc_opt_class();
  uint64_t v7 = objc_opt_class();
  uint64_t v8 = objc_opt_class();
  uint64_t v9 = objc_opt_class();
  uint64_t v10 = objc_opt_class();
  uint64_t v11 = objc_opt_class();
  uint64_t v12 = objc_opt_class();
  uint64_t v13 = objc_opt_class();
  uint64_t v14 = objc_opt_class();
  uint64_t v15 = objc_opt_class();
  id v16 = [v36 initWithObjects:v35, v7, v8, v9, v10, v11, v12, v13, v14, v15, objc_opt_class(), 0];
  id v17 = objc_alloc((Class)NSSet);
  uint64_t v18 = objc_opt_class();
  uint64_t v19 = objc_opt_class();
  id v20 = [v17 initWithObjects:v18, v19, objc_opt_class(), 0];
  long long v21 = +[NSXPCInterface interfaceWithProtocol:&OBJC_PROTOCOL___NFSecureElementManagerSessionInterface];
  [v21 setClasses:v37 forSelector:"deleteApplets:completion:" argumentIndex:0 ofReply:0];
  [v21 setClasses:v37 forSelector:"getAppletsWithCompletion:" argumentIndex:0 ofReply:1];
  [v21 setClasses:v37 forSelector:"deleteApplets:completion:" argumentIndex:0 ofReply:1];
  [v21 setClasses:v37 forSelector:"deleteAllAppletsWithCompletion:" argumentIndex:0 ofReply:1];
  id v22 = [objc_alloc((Class)NSSet) initWithObjects:objc_opt_class(), 0];
  [v21 setClasses:v22 forSelector:"signChallenge:useOSVersion:completion:" argumentIndex:1 ofReply:1];

  [v21 setClasses:v37 forSelector:"getFelicaAppletState:completion:" argumentIndex:0 ofReply:0];
  [v21 setClasses:v16 forSelector:"getFelicaAppletState:completion:" argumentIndex:0 ofReply:1];
  [v21 setClasses:v37 forSelector:"getTransitAppletState:completion:" argumentIndex:0 ofReply:0];
  [v21 setClasses:v16 forSelector:"getTransitAppletState:completion:" argumentIndex:0 ofReply:1];
  [v21 setClasses:v37 forSelector:"getServiceProviderDataForApplet:publicKey:scheme:completion:" argumentIndex:0 ofReply:0];
  [v21 setClasses:v16 forSelector:"getServiceProviderDataForApplet:publicKey:scheme:completion:" argumentIndex:0 ofReply:1];
  [v21 setClasses:v37 forSelector:"disableAuthorizationForApplets:andKey:authorization:completion:" argumentIndex:0 ofReply:0];
  id v23 = [objc_alloc((Class)NSSet) initWithObjects:objc_opt_class(), 0];
  [v21 setClasses:v23 forSelector:"disableAuthorizationForApplets:andKey:authorization:completion:" argumentIndex:1 ofReply:0];

  id v24 = [objc_alloc((Class)NSSet) initWithObjects:objc_opt_class(), 0];
  [v21 setClasses:v24 forSelector:"disableAuthorizationForApplets:andKey:authorization:completion:" argumentIndex:2 ofReply:0];

  [v21 setClasses:v20 forSelector:"restoreAuthorizationForAllAppletsExcept:completion:" argumentIndex:0 ofReply:0];
  id v25 = [objc_alloc((Class)NSSet) initWithObjects:objc_opt_class(), 0];
  [v21 setClasses:v25 forSelector:"performPeerPaymentEnrollment:completion:" argumentIndex:0 ofReply:0];

  id v26 = [objc_alloc((Class)NSSet) initWithObjects:objc_opt_class(), 0];
  [v21 setClasses:v26 forSelector:"performPeerPaymentEnrollment:completion:" argumentIndex:0 ofReply:1];

  id v27 = [v16 setByAddingObject:objc_opt_class()];
  [v21 setClasses:v27 forSelector:"dumpDomain:forSEID:completion:" argumentIndex:0 ofReply:1];

  id v28 = objc_alloc((Class)NSSet);
  uint64_t v29 = objc_opt_class();
  uint64_t v30 = objc_opt_class();
  uint64_t v31 = objc_opt_class();
  uint64_t v32 = objc_opt_class();
  id v33 = [v28 initWithObjects:v29, v30, v31, v32, objc_opt_class(), 0];
  [v21 setClasses:v33 forSelector:"execRemoteAdminScript:params:completion:" argumentIndex:1 ofReply:0];

  return v21;
}

id sub_1001E3884(void *a1)
{
  if (a1)
  {
    uint64_t v1 = [a1 userInfo];
    if (v1 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    {
      id v2 = v1;
    }
    else
    {
      uint64_t v3 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT))
      {
        *(_WORD *)uint64_t v5 = 0;
        _os_log_fault_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, "Expected entitlement object is missing", v5, 2u);
      }

      id v2 = 0;
    }
  }
  else
  {
    id v2 = 0;
  }

  return v2;
}

void sub_1001E3954(void *a1)
{
  if (a1)
  {
    id v1 = a1;
    uint64_t v2 = self;
    id v23 = (id *)objc_opt_new();
    [v1 auditToken];
    SecTaskRef v3 = SecTaskCreateWithAuditToken(kCFAllocatorDefault, &token);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = @"application-identifier";
      self;
      uint64_t v6 = @"application-identifier";
      uint64_t v7 = self;
      CFErrorRef error = 0;
      uint64_t v8 = (void *)SecTaskCopyValueForEntitlement(v4, @"application-identifier", &error);

      if (error)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          uint64_t v10 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(v7);
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(v7);
          Name = sel_getName("_copyValueOfEntitlement:secTask:");
          uint64_t v15 = 45;
          if (isMetaClass) {
            uint64_t v15 = 43;
          }
          v10(3, "%c[%{public}s %{public}s]:%i Failed to get entitlements: %{public}@", v15, ClassName, Name, 50, error);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v16 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          id v17 = object_getClass(v7);
          if (class_isMetaClass(v17)) {
            int v18 = 43;
          }
          else {
            int v18 = 45;
          }
          uint64_t v19 = object_getClassName(v7);
          id v20 = sel_getName("_copyValueOfEntitlement:secTask:");
          *(_DWORD *)buf = 67110146;
          int v27 = v18;
          __int16 v28 = 2082;
          uint64_t v29 = v19;
          __int16 v30 = 2082;
          uint64_t v31 = v20;
          __int16 v32 = 1024;
          int v33 = 50;
          __int16 v34 = 2114;
          CFErrorRef v35 = error;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get entitlements: %{public}@", buf, 0x2Cu);
        }

        CFRelease(error);
      }

      if (v8)
      {
        CFTypeID v21 = CFGetTypeID(v8);
        if (v21 != CFStringGetTypeID())
        {
          CFRelease(v8);
          uint64_t v8 = 0;
        }
      }
      if (v23) {
        objc_storeStrong(v23 + 1, v8);
      }

      CFRelease(v4);
    }
    else
    {
      id v22 = +[NSAssertionHandler currentHandler];
      [v22 handleFailureInMethod:"entitlementFromXPC:" object:v2 file:@"NFWalletPresentationEntitlement.m" lineNumber:105 description:@"Missing task ref"];
    }
    [v1 setUserInfo:v23];
  }
}

id sub_1001E3C9C(void *a1)
{
  if (!a1) {
    return 0;
  }
  id v1 = [a1 valueForEntitlement:@"com.apple.nfcd.wallet.presentation"];
  if (v1 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0)) {
    id v2 = [v1 BOOLValue];
  }
  else {
    id v2 = 0;
  }

  return v2;
}

id *sub_1001E3D84(id *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    v7.receiver = a1;
    v7.super_class = (Class)NFTagAppLauncher;
    a1 = (id *)[super init];
    if (a1)
    {
      id v4 = [objc_alloc((Class)NSMutableArray) initWithArray:v3];
      id v5 = a1[1];
      a1[1] = v4;

      [a1[1] addObject:a1];
    }
  }

  return a1;
}

uint64_t sub_1001E4194(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  objc_super v7 = v6;
  if (!a1) {
    goto LABEL_20;
  }
  uint64_t v8 = 0;
  if (!v5 || !v6) {
    goto LABEL_55;
  }
  if (!sub_1001E4A50() || !sub_1001E4B94())
  {
LABEL_20:
    uint64_t v8 = 0;
    goto LABEL_55;
  }
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  id v9 = *(id *)(a1 + 8);
  id v10 = [v9 countByEnumeratingWithState:&v54 objects:v62 count:16];
  if (v10)
  {
    uint64_t v11 = *(void *)v55;
    while (2)
    {
      for (i = 0; i != v10; i = (char *)i + 1)
      {
        if (*(void *)v55 != v11) {
          objc_enumerationMutation(v9);
        }
        uint64_t v13 = *(void **)(*((void *)&v54 + 1) + 8 * i);
        char v53 = 0;
        id v52 = 0;
        uint64_t v14 = [v13 processNDEFMesssage:v7 outputMessage:&v52 tag:v5 stopProcessing:&v53];
        id v15 = v52;
        id v16 = v15;
        if (v14) {
          BOOL v17 = v15 == 0;
        }
        else {
          BOOL v17 = 1;
        }
        if (!v17)
        {
          uint64_t v19 = &off_100283000;
          if (!*(void *)(a1 + 16))
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
            if (Logger)
            {
              Class = object_getClass((id)a1);
              if (class_isMetaClass(Class)) {
                uint64_t v22 = 43;
              }
              else {
                uint64_t v22 = 45;
              }
              ClassName = object_getClassName((id)a1);
              Name = sel_getName("processTag:withNDEFMessage:");
              Logger(5, "%c[%{public}s %{public}s]:%i Creating barcode parser", v22, ClassName, Name, 103);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            id v25 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
            {
              id v26 = object_getClass((id)a1);
              if (class_isMetaClass(v26)) {
                int v27 = 43;
              }
              else {
                int v27 = 45;
              }
              __int16 v28 = object_getClassName((id)a1);
              uint64_t v29 = sel_getName("processTag:withNDEFMessage:");
              *(_DWORD *)buf = 67109890;
              *(_DWORD *)&uint8_t buf[4] = v27;
              *(_WORD *)__int16 v64 = 2082;
              *(void *)&v64[2] = v28;
              *(_WORD *)&v64[10] = 2082;
              *(void *)&v64[12] = v29;
              *(_WORD *)&v64[20] = 1024;
              *(_DWORD *)&v64[22] = 103;
              _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Creating barcode parser", buf, 0x22u);
            }

            uint64_t v58 = 0;
            unsigned int v59 = &v58;
            uint64_t v60 = 0x2050000000;
            __int16 v30 = (void *)qword_1003475D8;
            uint64_t v61 = qword_1003475D8;
            if (!qword_1003475D8)
            {
              *(void *)buf = _NSConcreteStackBlock;
              *(void *)__int16 v64 = 3221225472;
              *(void *)&v64[8] = sub_1001E4CD8;
              *(void *)&v64[16] = &unk_100301E40;
              *(void *)&v64[24] = &v58;
              sub_1001E4CD8(buf);
              __int16 v30 = (void *)v59[3];
            }
            uint64_t v31 = v30;
            _Block_object_dispose(&v58, 8);
            id v32 = objc_alloc_init(v31);
            int v33 = *(void **)(a1 + 16);
            *(void *)(a1 + 16) = v32;

            uint64_t v19 = &off_100283000;
            if (!*(void *)(a1 + 16))
            {
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              __int16 v34 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
              if (v34)
              {
                CFErrorRef v35 = object_getClass((id)a1);
                if (class_isMetaClass(v35)) {
                  uint64_t v36 = 43;
                }
                else {
                  uint64_t v36 = 45;
                }
                id v37 = object_getClassName((id)a1);
                id v38 = sel_getName("processTag:withNDEFMessage:");
                v34(3, "%c[%{public}s %{public}s]:%i Failed to allocate barcode parser", v36, v37, v38, 107);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              id v39 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
              {
                os_log_type_t v40 = object_getClass((id)a1);
                if (class_isMetaClass(v40)) {
                  int v41 = 43;
                }
                else {
                  int v41 = 45;
                }
                int v42 = object_getClassName((id)a1);
                uint64_t v43 = sel_getName("processTag:withNDEFMessage:");
                *(_DWORD *)buf = 67109890;
                *(_DWORD *)&uint8_t buf[4] = v41;
                *(_WORD *)__int16 v64 = 2082;
                *(void *)&v64[2] = v42;
                *(_WORD *)&v64[10] = 2082;
                *(void *)&v64[12] = v43;
                *(_WORD *)&v64[20] = 1024;
                *(_DWORD *)&v64[22] = 107;
                _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to allocate barcode parser", buf, 0x22u);
              }

              uint64_t v19 = &off_100283000;
            }
          }
          uint64_t v58 = 0;
          unsigned int v59 = &v58;
          uint64_t v60 = *((void *)v19 + 207);
          id v44 = (void *)qword_1003475E0;
          uint64_t v61 = qword_1003475E0;
          if (!qword_1003475E0)
          {
            *(void *)buf = _NSConcreteStackBlock;
            *(void *)__int16 v64 = 3221225472;
            *(void *)&v64[8] = sub_1001E4E20;
            *(void *)&v64[16] = &unk_100301E40;
            *(void *)&v64[24] = &v58;
            sub_1001E4E20(buf);
            id v44 = (void *)v59[3];
          }
          __int16 v45 = v44;
          _Block_object_dispose(&v58, 8);
          id v46 = [[v45 alloc] initWithNFNdefMessage:v16];
          int v47 = NFSharedSignpostLog();
          if (os_signpost_enabled(v47))
          {
            *(_WORD *)buf = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v47, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "TagAppProcessed", (const char *)&unk_100286819, buf, 2u);
          }

          int v48 = *(void **)(a1 + 16);
          v51[0] = _NSConcreteStackBlock;
          v51[1] = 3221225472;
          v51[2] = sub_1001E4838;
          v51[3] = &unk_100306E90;
          v51[4] = a1;
          v51[5] = "processTag:withNDEFMessage:";
          [v48 postNotificationForURL:v14 payload:v46 completionHandler:v51];
          __int16 v49 = NFSharedSignpostLog();
          if (os_signpost_enabled(v49))
          {
            *(_WORD *)buf = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v49, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "LPCD_POSTED_NOTIFICATION", (const char *)&unk_100286819, buf, 2u);
          }

          uint64_t v8 = 1;
          goto LABEL_54;
        }
        BOOL v18 = v53 == 0;

        if (!v18) {
          goto LABEL_21;
        }
      }
      id v10 = [v9 countByEnumeratingWithState:&v54 objects:v62 count:16];
      uint64_t v8 = 0;
      if (v10) {
        continue;
      }
      break;
    }
  }
  else
  {
LABEL_21:
    uint64_t v8 = 0;
  }
LABEL_54:

LABEL_55:
  return v8;
}

void sub_1001E4814(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
}

void sub_1001E4838(uint64_t a1, int a2, void *a3)
{
  id v5 = a3;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    objc_super v7 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 40));
    if (a2) {
      CFStringRef v12 = @"Y";
    }
    else {
      CFStringRef v12 = @"N";
    }
    CFStringRef v20 = v12;
    uint64_t v13 = 45;
    if (isMetaClass) {
      uint64_t v13 = 43;
    }
    v7(6, "%c[%{public}s %{public}s]:%i Posted notification, isActionable:%{public}@, error:%{public}@", v13, ClassName, Name, 117, v20, v5);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v14 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    id v15 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v15)) {
      int v16 = 43;
    }
    else {
      int v16 = 45;
    }
    BOOL v17 = object_getClassName(*(id *)(a1 + 32));
    BOOL v18 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)buf = 67110402;
    if (a2) {
      CFStringRef v19 = @"Y";
    }
    else {
      CFStringRef v19 = @"N";
    }
    int v22 = v16;
    __int16 v23 = 2082;
    id v24 = v17;
    __int16 v25 = 2082;
    id v26 = v18;
    __int16 v27 = 1024;
    int v28 = 117;
    __int16 v29 = 2114;
    CFStringRef v30 = v19;
    __int16 v31 = 2114;
    id v32 = v5;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Posted notification, isActionable:%{public}@, error:%{public}@", buf, 0x36u);
  }
}

uint64_t sub_1001E4A50()
{
  if (!qword_1003475C8) {
    qword_1003475C8 = _sl_dlopen();
  }
  return qword_1003475C8;
}

uint64_t sub_1001E4B20()
{
  uint64_t result = _sl_dlopen();
  qword_1003475C8 = result;
  return result;
}

uint64_t sub_1001E4B94()
{
  if (!qword_1003475D0) {
    qword_1003475D0 = _sl_dlopen();
  }
  return qword_1003475D0;
}

uint64_t sub_1001E4C64()
{
  uint64_t result = _sl_dlopen();
  qword_1003475D0 = result;
  return result;
}

void sub_1001E4CD8(void *a1)
{
  if (!sub_1001E4B94())
  {
    id v2 = +[NSAssertionHandler currentHandler];
    a1 = +[NSString stringWithUTF8String:"void *BarcodeSupportLibrary(void)"];
    [v2 handleFailureInFunction:a1 file:@"NFTagAppLauncher.m" lineNumber:24 description:@"%s"];

    __break(1u);
    free(v3);
  }
  *(void *)(*(void *)(a1[4] + 8) + 24) = objc_getClass("BCSNFCCodeParser");
  if (*(void *)(*(void *)(a1[4] + 8) + 24))
  {
    qword_1003475D8 = *(void *)(*(void *)(a1[4] + 8) + 24);
  }
  else
  {
    id v4 = +[NSAssertionHandler currentHandler];
    id v5 = +[NSString stringWithUTF8String:"Class getBCSNFCCodeParserClass(void)_block_invoke"];
    [v4 handleFailureInFunction:v5 file:@"NFTagAppLauncher.m" lineNumber:25 description:@"Unable to find class %s", "BCSNFCCodeParser"];

    __break(1u);
  }
}

void sub_1001E4E20(void *a1)
{
  if (!sub_1001E4A50())
  {
    id v2 = +[NSAssertionHandler currentHandler];
    a1 = +[NSString stringWithUTF8String:"void *CoreNFCLibrary(void)"];
    [v2 handleFailureInFunction:a1 file:@"NFTagAppLauncher.m" lineNumber:27 description:@"%s"];

    __break(1u);
    free(v3);
  }
  *(void *)(*(void *)(a1[4] + 8) + 24) = objc_getClass("NFCNDEFMessage");
  if (*(void *)(*(void *)(a1[4] + 8) + 24))
  {
    qword_1003475E0 = *(void *)(*(void *)(a1[4] + 8) + 24);
  }
  else
  {
    id v4 = +[NSAssertionHandler currentHandler];
    id v5 = +[NSString stringWithUTF8String:"Class getNFCNDEFMessageClass(void)_block_invoke"];
    [v4 handleFailureInFunction:v5 file:@"NFTagAppLauncher.m" lineNumber:28 description:@"Unable to find class %s" arguments:@"NFCNDEFMessage", nil];

    __break(1u);
  }
}

id sub_1001E6B60(uint64_t a1)
{
  kern_return_t v5;
  id v6;
  void *v7;
  void *v8;
  id v9;
  id v10;
  void *v11;
  id v12;
  void v14[4];
  void v15[4];
  uint64_t vars8;

  if (!a1) {
    goto LABEL_12;
  }
  id v1 = (io_connect_t *)(a1 + 8);
  CFDictionaryRef v2 = IOServiceMatching("AppleSMC");
  io_service_t MatchingService = IOServiceGetMatchingService(kIOMainPortDefault, v2);
  if (!MatchingService
    || (v4 = MatchingService, id v5 = IOServiceOpen(MatchingService, mach_task_self_, 0, v1), IOObjectRelease(v4), v5)
    || !*v1
    || IOConnectCallScalarMethod(*v1, 0, 0, 0, 0, 0))
  {
    io_connect_t *v1 = 0;
LABEL_5:
    id v6 = objc_alloc((Class)NSError);
    objc_super v7 = +[NSString stringWithUTF8String:"nfcd"];
    v14[0] = NSLocalizedDescriptionKey;
    uint64_t v8 = +[NSString stringWithUTF8String:"Unknown Error"];
    v15[0] = v8;
    v15[1] = &off_10031F510;
    v14[1] = @"Line";
    void v14[2] = @"Method";
    id v9 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("open")];
    void v15[2] = v9;
    v14[3] = NSDebugDescriptionErrorKey;
    id v10 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("open"), 121];
    v15[3] = v10;
    uint64_t v11 = +[NSDictionary dictionaryWithObjects:v15 forKeys:v14 count:4];
    CFStringRef v12 = [v6 initWithDomain:v7 code:6 userInfo:v11];

    goto LABEL_6;
  }
  if (!*v1) {
    goto LABEL_5;
  }
LABEL_12:
  CFStringRef v12 = 0;
LABEL_6:

  return v12;
}

uint64_t sub_1001E6DA4(uint64_t a1)
{
  if (a1)
  {
    mach_port_t v2 = *(_DWORD *)(a1 + 8);
    if (v2)
    {
      IOConnectCallScalarMethod(v2, 1u, 0, 0, 0, 0);
      IOServiceClose(*(_DWORD *)(a1 + 8));
      *(_DWORD *)(a1 + 8) = 0;
    }
  }
  return 0;
}

void sub_1001E6E4C(unsigned char *a1, unsigned int a2)
{
  if (a1)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("setReaderModeActive:");
      uint64_t v8 = 45;
      if (isMetaClass) {
        uint64_t v8 = 43;
      }
      v5(6, "%c[%{public}s %{public}s]:%i active %d", v8, ClassName, Name, 145, a2);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      id v10 = object_getClass(a1);
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      *(_DWORD *)buf = 67110146;
      int v15 = v11;
      __int16 v16 = 2082;
      BOOL v17 = object_getClassName(a1);
      __int16 v18 = 2082;
      CFStringRef v19 = sel_getName("setReaderModeActive:");
      __int16 v20 = 1024;
      int v21 = 145;
      __int16 v22 = 1024;
      unsigned int v23 = a2;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i active %d", buf, 0x28u);
    }

    a1[12] = a2;
  }
}

id sub_1001E73CC(void *a1, void *a2)
{
  if (a1)
  {
    mach_port_t v2 = a1;
    objc_sync_enter(v2);
    if (*((unsigned char *)v2 + 137))
    {
      id v3 = objc_alloc((Class)NSError);
      ErrorCode = +[NSString stringWithUTF8String:"nfcd"];
      v62[0] = NSLocalizedDescriptionKey;
      id v5 = +[NSString stringWithUTF8String:"Aborted"];
      v63[0] = v5;
      v63[1] = &off_10031F540;
      v62[1] = @"Line";
      v62[2] = @"Method";
      id v6 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("getPowerCounters:")];
      v63[2] = v6;
      v62[3] = NSDebugDescriptionErrorKey;
      id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("getPowerCounters:"), 39];
      v63[3] = v7;
      uint64_t v8 = +[NSDictionary dictionaryWithObjects:v63 forKeys:v62 count:4];
      id v9 = [v3 initWithDomain:ErrorCode code:3 userInfo:v8];
    }
    else
    {
      if (v2[9])
      {
        int PowerCounter = NFDriverGetPowerCounter();
        if (!PowerCounter || PowerCounter == 15)
        {
          [v2[9] timeIntervalSinceNow];
          double v14 = v13;
          ErrorCode = objc_opt_new();
          __int16 v25 = +[NSNumber numberWithUnsignedInt:0];
          [ErrorCode setObject:v25 forKey:@"idleTime"];

          id v26 = +[NSNumber numberWithUnsignedInt:0];
          [ErrorCode setObject:v26 forKey:@"rfTime"];

          __int16 v27 = +[NSNumber numberWithInt:-((double)0 - v14 * -1000.0)];
          [ErrorCode setObject:v27 forKey:@"sleepTime"];

          int v28 = +[NSNumber numberWithUnsignedLongLong:0];
          [ErrorCode setObject:v28 forKey:@"fieldDetectUpTime"];

          __int16 v29 = +[NSNumber numberWithUnsignedLongLong:0];
          [ErrorCode setObject:v29 forKey:@"expressUpTime"];
          id v10 = 0;

          CFStringRef v30 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:");
          [ErrorCode setObject:v30 forKey:@"lpcdFalseDetectCount"];

          __int16 v31 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:");
          [ErrorCode setObject:v31 forKey:@"SEUptime"];

          id v32 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:");
          [ErrorCode setObject:v32 forKey:@"jcopUpCounter"];

          int v33 = +[NSNumber numberWithUnsignedLongLong:](NSNumber, "numberWithUnsignedLongLong:");
          [ErrorCode setObject:v33 forKey:@"uiccUpCounter"];

          __int16 v34 = +[NSNumber numberWithBool:0];
          [ErrorCode setObject:v34 forKey:@"eseStatus"];

          CFErrorRef v35 = +[NSNumber numberWithBool:0];
          [ErrorCode setObject:v35 forKey:@"mboxStatus"];

          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (Logger)
          {
            Class = object_getClass(v2);
            if (class_isMetaClass(Class)) {
              uint64_t v38 = 43;
            }
            else {
              uint64_t v38 = 45;
            }
            ClassName = object_getClassName(v2);
            Name = sel_getName("getPowerCounters:");
            Logger(6, "%c[%{public}s %{public}s]:%i Last query was %f seconds ago, power dict = %{public}@", v38, ClassName, Name, 98, *(void *)&v14, ErrorCode);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          int v41 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
          {
            int v42 = object_getClass(v2);
            if (class_isMetaClass(v42)) {
              int v43 = 43;
            }
            else {
              int v43 = 45;
            }
            *(_DWORD *)buf = 67110402;
            int v47 = v43;
            __int16 v48 = 2082;
            __int16 v49 = object_getClassName(v2);
            __int16 v50 = 2082;
            int v51 = sel_getName("getPowerCounters:");
            __int16 v52 = 1024;
            int v53 = 98;
            __int16 v54 = 2048;
            double v55 = v14;
            __int16 v56 = 2114;
            long long v57 = ErrorCode;
            _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Last query was %f seconds ago, power dict = %{public}@", buf, 0x36u);
          }

          if (a2) {
            *a2 = [objc_alloc((Class)NSDictionary) initWithDictionary:ErrorCode];
          }
          id v44 = [objc_alloc((Class)NSDate) initWithTimeIntervalSinceNow:0.0];
          id v5 = v2[9];
          v2[9] = v44;
          goto LABEL_6;
        }
        ErrorCode = (void *)NFDriverCreateErrorCode();
        id v24 = objc_alloc((Class)NSError);
        id v5 = +[NSString stringWithUTF8String:"nfcd"];
        v58[0] = NSLocalizedDescriptionKey;
        id v6 = +[NSString stringWithUTF8String:"Stack Error"];
        v58[1] = NSUnderlyingErrorKey;
        v59[0] = v6;
        v59[1] = ErrorCode;
        id v7 = +[NSDictionary dictionaryWithObjects:v59 forKeys:v58 count:2];
        id v10 = [v24 initWithDomain:v5 code:15 userInfo:v7];
LABEL_5:

LABEL_6:
        objc_sync_exit(v2);

        goto LABEL_7;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v15 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v15)
      {
        __int16 v16 = object_getClass(v2);
        if (class_isMetaClass(v16)) {
          uint64_t v17 = 43;
        }
        else {
          uint64_t v17 = 45;
        }
        __int16 v18 = object_getClassName(v2);
        CFStringRef v19 = sel_getName("getPowerCounters:");
        v15(3, "%c[%{public}s %{public}s]:%i Power state tracking not available", v17, v18, v19, 43);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v20 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        int v21 = object_getClass(v2);
        if (class_isMetaClass(v21)) {
          int v22 = 43;
        }
        else {
          int v22 = 45;
        }
        *(_DWORD *)buf = 67109890;
        int v47 = v22;
        __int16 v48 = 2082;
        __int16 v49 = object_getClassName(v2);
        __int16 v50 = 2082;
        int v51 = sel_getName("getPowerCounters:");
        __int16 v52 = 1024;
        int v53 = 43;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Power state tracking not available", buf, 0x22u);
      }

      id v23 = objc_alloc((Class)NSError);
      ErrorCode = +[NSString stringWithUTF8String:"nfcd"];
      v60[0] = NSLocalizedDescriptionKey;
      id v5 = +[NSString stringWithUTF8String:"Invalid State"];
      v61[0] = v5;
      v61[1] = &off_10031F558;
      v60[1] = @"Line";
      v60[2] = @"Method";
      id v6 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("getPowerCounters:")];
      v61[2] = v6;
      v60[3] = NSDebugDescriptionErrorKey;
      id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("getPowerCounters:"), 44];
      v61[3] = v7;
      uint64_t v8 = +[NSDictionary dictionaryWithObjects:v61 forKeys:v60 count:4];
      id v9 = [v23 initWithDomain:ErrorCode code:12 userInfo:v8];
    }
    id v10 = v9;

    goto LABEL_5;
  }
  id v10 = 0;
LABEL_7:

  return v10;
}

void sub_1001E83C0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_1001E8404(uint64_t a1, void *a2, void *a3, int a4, int a5)
{
  id v9 = a2;
  id v10 = a3;
  if (a1)
  {
    int v11 = objc_opt_new();
    if ([v9 count])
    {
      CFStringRef v12 = [v9 objectForKeyedSubscript:@"idleTime"];
      unsigned int v13 = [v12 intValue];
      double v14 = [v10 objectForKeyedSubscript:@"idleTime"];
      uint64_t v15 = [v14 intValue] + v13;

      __int16 v16 = +[NSNumber numberWithUnsignedInt:v15];
      [v11 setObject:v16 forKeyedSubscript:@"idleTime"];

      uint64_t v17 = [v9 objectForKeyedSubscript:@"rfTime"];
      LODWORD(v15) = [v17 intValue];
      __int16 v18 = [v10 objectForKeyedSubscript:@"rfTime"];
      uint64_t v19 = [v18 intValue] + v15;

      __int16 v20 = +[NSNumber numberWithUnsignedInt:v19];
      [v11 setObject:v20 forKeyedSubscript:@"rfTime"];

      int v21 = [v9 objectForKeyedSubscript:@"sleepTime"];
      LODWORD(v19) = [v21 intValue];
      int v22 = [v10 objectForKeyedSubscript:@"sleepTime"];
      uint64_t v23 = [v22 intValue] + v19;

      id v24 = +[NSNumber numberWithUnsignedInt:v23];
      [v11 setObject:v24 forKeyedSubscript:@"sleepTime"];

      __int16 v25 = [v9 objectForKeyedSubscript:@"lpcdFalseDetectCount"];
      LODWORD(v23) = [v25 intValue];
      id v26 = [v10 objectForKeyedSubscript:@"lpcdFalseDetectCount"];
      uint64_t v27 = [v26 intValue] + v23;

      int v28 = +[NSNumber numberWithUnsignedInt:v27];
      [v11 setObject:v28 forKeyedSubscript:@"lpcdFalseDetectCount"];

      __int16 v29 = [v9 objectForKeyedSubscript:@"SEUptime"];
      CFStringRef v30 = (char *)[v29 longLongValue];
      __int16 v31 = [v10 objectForKeyedSubscript:@"SEUptime"];
      id v32 = &v30[(void)[v31 longLongValue]];

      int v33 = +[NSNumber numberWithUnsignedLongLong:v32];
      [v11 setObject:v33 forKeyedSubscript:@"SEUptime"];

      if (a4)
      {
        __int16 v34 = +[NSNumber numberWithBool:1];
        [v11 setObject:v34 forKeyedSubscript:@"Overflow"];
      }
      CFErrorRef v35 = [v9 objectForKeyedSubscript:@"fieldDetectUpTime"];
      uint64_t v36 = (char *)[v35 longLongValue];
      id v37 = [v10 objectForKeyedSubscript:@"fieldDetectUpTime"];
      uint64_t v38 = &v36[(void)[v37 longLongValue]];

      id v39 = +[NSNumber numberWithUnsignedLongLong:v38];
      [v11 setObject:v39 forKeyedSubscript:@"fieldDetectUpTime"];

      os_log_type_t v40 = [v9 objectForKeyedSubscript:@"expressUpTime"];
      int v41 = (char *)[v40 longLongValue];
      int v42 = [v10 objectForKeyedSubscript:@"expressUpTime"];
      int v43 = &v41[(void)[v42 longLongValue]];

      id v44 = +[NSNumber numberWithUnsignedLongLong:v43];
      [v11 setObject:v44 forKeyedSubscript:@"expressUpTime"];

      if ((a5 & 1) == 0)
      {
        __int16 v45 = [v9 objectForKeyedSubscript:@"jcopUpCounter"];
        id v46 = (char *)[v45 longLongValue];
        int v47 = [v10 objectForKeyedSubscript:@"jcopUpCounter"];
        __int16 v48 = &v46[(void)[v47 longLongValue]];

        __int16 v49 = +[NSNumber numberWithUnsignedLongLong:v48];
        [v11 setObject:v49 forKeyedSubscript:@"jcopUpCounter"];

        __int16 v50 = [v9 objectForKeyedSubscript:@"uiccUpCounter"];
        int v51 = (char *)[v50 longLongValue];
        __int16 v52 = [v10 objectForKeyedSubscript:@"uiccUpCounter"];
        int v53 = &v51[(void)[v52 longLongValue]];

        __int16 v54 = +[NSNumber numberWithUnsignedLongLong:v53];
        [v11 setObject:v54 forKeyedSubscript:@"uiccUpCounter"];
      }
      double v55 = [v9 objectForKeyedSubscript:@"uiccUpCounter"];
      __int16 v56 = (char *)[v55 longLongValue];
      long long v57 = [v10 objectForKeyedSubscript:@"uiccUpCounter"];
      uint64_t v58 = &v56[(void)[v57 longLongValue]];

      unsigned int v59 = +[NSNumber numberWithUnsignedLongLong:v58];
      [v11 setObject:v59 forKeyedSubscript:@"uiccUpCounter"];

      if (a5)
      {
        [v11 removeObjectForKey:@"jcopUpCounter"];
        [v11 removeObjectForKey:@"uiccUpCounter"];
      }
      uint64_t v60 = [v10 objectForKeyedSubscript:@"eseStatus"];

      if (v60)
      {
        uint64_t v61 = [v10 objectForKeyedSubscript:@"eseStatus"];
        [v11 setObject:v61 forKeyedSubscript:@"eseStatus"];
      }
      __int16 v62 = [v10 objectForKeyedSubscript:@"mboxStatus"];

      id v63 = v11;
      if (!v62) {
        goto LABEL_16;
      }
      __int16 v64 = [v10 objectForKeyedSubscript:@"mboxStatus"];
      id v65 = v11;
      id v66 = v64;
      CFStringRef v67 = @"mboxStatus";
    }
    else
    {
      id v63 = v10;
      if (!a4)
      {
LABEL_16:
        id v68 = [objc_alloc((Class)NSDictionary) initWithDictionary:v63];

        goto LABEL_17;
      }
      [v11 addEntriesFromDictionary:v10];
      __int16 v64 = +[NSNumber numberWithBool:1];
      CFStringRef v67 = @"Overflow";
      id v65 = v11;
      id v66 = v64;
    }
    [v65 setObject:v66 forKeyedSubscript:v67];

    id v63 = v11;
    goto LABEL_16;
  }
  id v68 = 0;
LABEL_17:

  return v68;
}

id sub_1001E8A64(void *a1, void *a2)
{
  if (a1)
  {
    id v3 = a1;
    objc_sync_enter(v3);
    if (v3[5])
    {
      int v4 = NFDriverGetFlashWriteCounter();
      if (v4) {
        BOOL v5 = v4 == 15;
      }
      else {
        BOOL v5 = 1;
      }
      if (v5)
      {
        if (a2)
        {
          +[NSNumber numberWithInt:](NSNumber, "numberWithInt:");
          id v17 = 0;
          *a2 = (id)objc_claimAutoreleasedReturnValue();
        }
        else
        {
          id v17 = 0;
        }
      }
      else
      {
        ErrorCode = (void *)NFDriverCreateErrorCode();
        id v13 = objc_alloc((Class)NSError);
        double v14 = +[NSString stringWithUTF8String:"nfcd"];
        v19[0] = NSLocalizedDescriptionKey;
        uint64_t v15 = +[NSString stringWithUTF8String:"Stack Error"];
        v19[1] = NSUnderlyingErrorKey;
        v20[0] = v15;
        v20[1] = ErrorCode;
        __int16 v16 = +[NSDictionary dictionaryWithObjects:v20 forKeys:v19 count:2];
        id v17 = [v13 initWithDomain:v14 code:15 userInfo:v16];
      }
    }
    else
    {
      id v6 = objc_alloc((Class)NSError);
      id v7 = +[NSString stringWithUTF8String:"nfcd"];
      v21[0] = NSLocalizedDescriptionKey;
      uint64_t v8 = +[NSString stringWithUTF8String:"Aborted"];
      v22[0] = v8;
      v22[1] = &off_10031F5E8;
      v21[1] = @"Line";
      v21[2] = @"Method";
      id v9 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("getFlashWriteCounters:")];
      v22[2] = v9;
      v21[3] = NSDebugDescriptionErrorKey;
      id v10 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("getFlashWriteCounters:"), 183];
      v22[3] = v10;
      int v11 = +[NSDictionary dictionaryWithObjects:v22 forKeys:v21 count:4];
      id v17 = [v6 initWithDomain:v7 code:3 userInfo:v11];
    }
    objc_sync_exit(v3);
  }
  else
  {
    id v17 = 0;
  }

  return v17;
}

void sub_1001E8EA0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_1001E8EC0(void *a1, void *a2)
{
  if (a1)
  {
    int v39 = 0;
    memset(v38, 0, sizeof(v38));
    if (!a2)
    {
      id v11 = objc_alloc((Class)NSError);
      id v3 = +[NSString stringWithUTF8String:"nfcd"];
      v54[0] = NSLocalizedDescriptionKey;
      CFStringRef v12 = +[NSString stringWithUTF8String:"Invalid Parameter"];
      v55[0] = v12;
      v55[1] = &off_10031F618;
      v54[1] = @"Line";
      v54[2] = @"Method";
      id v13 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("getFlashEraseCounters:")];
      v55[2] = v13;
      v54[3] = NSDebugDescriptionErrorKey;
      id v14 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("getFlashEraseCounters:"), 210];
      v55[3] = v14;
      uint64_t v15 = +[NSDictionary dictionaryWithObjects:v55 forKeys:v54 count:4];
      id v16 = [v11 initWithDomain:v3 code:10 userInfo:v15];

LABEL_10:
      goto LABEL_11;
    }
    id v3 = a1;
    objc_sync_enter(v3);
    if (*((void *)v3 + 5))
    {
      if (!*((unsigned char *)v3 + 137))
      {
        int PageEraseCounter = NFDriverReadPageEraseCounter();
        if (PageEraseCounter == 19)
        {
          id v16 = 0;
          *a2 = 0;
        }
        else if (PageEraseCounter)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (Logger)
          {
            Class = object_getClass(v3);
            if (class_isMetaClass(Class)) {
              uint64_t v26 = 43;
            }
            else {
              uint64_t v26 = 45;
            }
            ClassName = object_getClassName(v3);
            Name = sel_getName("getFlashEraseCounters:");
            Logger(3, "%c[%{public}s %{public}s]:%i Failed to get erase counters", v26, ClassName, Name, 236);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          __int16 v29 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
          {
            CFStringRef v30 = object_getClass(v3);
            if (class_isMetaClass(v30)) {
              int v31 = 43;
            }
            else {
              int v31 = 45;
            }
            *(_DWORD *)buf = 67109890;
            int v43 = v31;
            __int16 v44 = 2082;
            __int16 v45 = object_getClassName(v3);
            __int16 v46 = 2082;
            int v47 = sel_getName("getFlashEraseCounters:");
            __int16 v48 = 1024;
            int v49 = 236;
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get erase counters", buf, 0x22u);
          }

          *a2 = 0;
          id v32 = objc_alloc((Class)NSError);
          int v33 = +[NSString stringWithUTF8String:"nfcd"];
          v40[0] = NSLocalizedDescriptionKey;
          __int16 v34 = +[NSString stringWithUTF8String:"Stack Error"];
          v41[0] = v34;
          v41[1] = &off_10031F660;
          v40[1] = @"Line";
          v40[2] = @"Method";
          id v35 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("getFlashEraseCounters:")];
          v41[2] = v35;
          v40[3] = NSDebugDescriptionErrorKey;
          id v36 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("getFlashEraseCounters:"), 238];
          v41[3] = v36;
          id v37 = +[NSDictionary dictionaryWithObjects:v41 forKeys:v40 count:4];
          id v16 = [v32 initWithDomain:v33 code:15 userInfo:v37];
        }
        else
        {
          __int16 v20 = objc_opt_new();
          NFDriverPrintPageEraseCounter();
          if (LOWORD(v38[0]))
          {
            unint64_t v21 = 0;
            do
            {
              int v22 = +[NSNumber numberWithUnsignedInt:*((unsigned int *)v38 + v21 + 1)];
              [v20 setObject:v22 atIndexedSubscript:v21];

              ++v21;
            }
            while (v21 < LOWORD(v38[0]));
          }
          id v23 = v20;
          *a2 = v23;

          id v16 = 0;
        }
        goto LABEL_9;
      }
      id v4 = objc_alloc((Class)NSError);
      BOOL v5 = +[NSString stringWithUTF8String:"nfcd"];
      v50[0] = NSLocalizedDescriptionKey;
      id v6 = +[NSString stringWithUTF8String:"Aborted"];
      v51[0] = v6;
      v51[1] = &off_10031F648;
      v50[1] = @"Line";
      v50[2] = @"Method";
      id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("getFlashEraseCounters:")];
      v51[2] = v7;
      v50[3] = NSDebugDescriptionErrorKey;
      id v8 = [[objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("getFlashEraseCounters:"), 219];
      v51[3] = v8;
      id v9 = +[NSDictionary dictionaryWithObjects:v51 forKeys:v50 count:4];
      id v10 = [v4 initWithDomain:v5 code:3 userInfo:v9];
    }
    else
    {
      id v17 = objc_alloc((Class)NSError);
      BOOL v5 = +[NSString stringWithUTF8String:"nfcd"];
      v52[0] = NSLocalizedDescriptionKey;
      id v6 = +[NSString stringWithUTF8String:"Aborted"];
      v53[0] = v6;
      v53[1] = &off_10031F630;
      v52[1] = @"Line";
      v52[2] = @"Method";
      id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("getFlashEraseCounters:")];
      v53[2] = v7;
      v52[3] = NSDebugDescriptionErrorKey;
      id v8 = [[objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("getFlashEraseCounters:"), 215];
      v53[3] = v8;
      id v9 = +[NSDictionary dictionaryWithObjects:v53 forKeys:v52 count:4];
      id v10 = [v17 initWithDomain:v5 code:3 userInfo:v9];
    }
    id v16 = v10;

LABEL_9:
    objc_sync_exit(v3);
    goto LABEL_10;
  }
  id v16 = 0;
LABEL_11:

  return v16;
}

void sub_1001E9630(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

double sub_1001E9660(void **a1)
{
  uint64_t v37 = 0;
  uint64_t v38 = &v37;
  uint64_t v39 = 0x2020000000;
  uint64_t v40 = 0;
  uint64_t v31 = 0;
  id v32 = &v31;
  uint64_t v33 = 0x3032000000;
  __int16 v34 = sub_10000B918;
  id v35 = sub_1001E9A58;
  id v36 = 0;
  v30[0] = _NSConcreteStackBlock;
  v30[1] = 3221225472;
  v30[2] = sub_1001E9A60;
  v30[3] = &unk_100306EE8;
  v30[4] = a1;
  v30[5] = &v31;
  v30[6] = &v37;
  mach_port_t v2 = +[NFRoutingConfig embeddedWiredModeWithFD:1];
  char v3 = sub_1000F23D8(a1, v30, @"AvoidSEReset", v2);

  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  if (v3)
  {
    uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (Logger)
    {
      Class = object_getClass(a1);
      if (class_isMetaClass(Class)) {
        uint64_t v6 = 43;
      }
      else {
        uint64_t v6 = 45;
      }
      ClassName = object_getClassName(a1);
      Name = sel_getName("_queryRemainTimeFromTimers");
      Logger(6, "%c[%{public}s %{public}s]:%i SE keep alive active", v6, ClassName, Name, 42);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      id v10 = object_getClass(a1);
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      CFStringRef v12 = object_getClassName(a1);
      id v13 = sel_getName("_queryRemainTimeFromTimers");
      *(_DWORD *)buf = 67109890;
      int v42 = v11;
      __int16 v43 = 2082;
      __int16 v44 = v12;
      __int16 v45 = 2082;
      __int16 v46 = v13;
      __int16 v47 = 1024;
      int v48 = 42;
      id v14 = "%c[%{public}s %{public}s]:%i SE keep alive active";
      uint64_t v15 = v9;
      os_log_type_t v16 = OS_LOG_TYPE_DEFAULT;
      uint32_t v17 = 34;
LABEL_22:
      _os_log_impl((void *)&_mh_execute_header, v15, v16, v14, buf, v17);
    }
  }
  else
  {
    __int16 v18 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v18)
    {
      uint64_t v19 = object_getClass(a1);
      if (class_isMetaClass(v19)) {
        uint64_t v20 = 43;
      }
      else {
        uint64_t v20 = 45;
      }
      unint64_t v21 = object_getClassName(a1);
      int v22 = sel_getName("_queryRemainTimeFromTimers");
      v18(3, "%c[%{public}s %{public}s]:%i Failed to query timers: %{public}@", v20, v21, v22, 40, v32[5]);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      id v23 = object_getClass(a1);
      if (class_isMetaClass(v23)) {
        int v24 = 43;
      }
      else {
        int v24 = 45;
      }
      __int16 v25 = object_getClassName(a1);
      uint64_t v26 = sel_getName("_queryRemainTimeFromTimers");
      uint64_t v27 = v32[5];
      *(_DWORD *)buf = 67110146;
      int v42 = v24;
      __int16 v43 = 2082;
      __int16 v44 = v25;
      __int16 v45 = 2082;
      __int16 v46 = v26;
      __int16 v47 = 1024;
      int v48 = 40;
      __int16 v49 = 2114;
      uint64_t v50 = v27;
      id v14 = "%c[%{public}s %{public}s]:%i Failed to query timers: %{public}@";
      uint64_t v15 = v9;
      os_log_type_t v16 = OS_LOG_TYPE_ERROR;
      uint32_t v17 = 44;
      goto LABEL_22;
    }
  }

  unint64_t v28 = v38[3];
  _Block_object_dispose(&v31, 8);

  _Block_object_dispose(&v37, 8);
  return (double)v28;
}

void sub_1001E9A14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_1001E9A58(uint64_t a1)
{
}

BOOL sub_1001E9A60(uint64_t a1)
{
  mach_port_t v2 = [*(id *)(a1 + 32) secureElementWrapper];
  uint64_t v3 = [v2 checkDeepSleepTimerRunning:*(void *)(*(void *)(a1 + 48) + 8) + 24];
  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8);
  BOOL v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;

  return *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) == 0;
}

id sub_1001E9AD0(void *a1)
{
  mach_port_t v2 = [a1 controllerInfo];
  if ((unint64_t)[v2 siliconName] < 7)
  {
    id v4 = 0;
  }
  else
  {
    uint64_t v3 = [a1 controllerInfo];
    id v4 = [v3 poweredRunDuringSleep];
  }
  return v4;
}

void sub_1001E9B3C(uint64_t a1)
{
  if (a1 && sub_1001E9AD0((void *)a1))
  {
    if (*(unsigned char *)(a1 + 341))
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass((id)a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName((id)a1);
        Name = sel_getName("openDriverForDPDTimers");
        uint64_t v7 = 45;
        if (isMetaClass) {
          uint64_t v7 = 43;
        }
        v3(6, "%c[%{public}s %{public}s]:%i SE keep alive active", v7, ClassName, Name, 69);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v8 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        id v9 = object_getClass((id)a1);
        if (class_isMetaClass(v9)) {
          int v10 = 43;
        }
        else {
          int v10 = 45;
        }
        *(_DWORD *)buf = 67109890;
        int v58 = v10;
        __int16 v59 = 2082;
        uint64_t v60 = object_getClassName((id)a1);
        __int16 v61 = 2082;
        __int16 v62 = sel_getName("openDriverForDPDTimers");
        __int16 v63 = 1024;
        int v64 = 69;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i SE keep alive active", buf, 0x22u);
      }
LABEL_28:

      return;
    }
    if (!*(unsigned char *)(a1 + 340)) {
      return;
    }
    int v11 = (unsigned __int8 *)*(id *)(a1 + 24);
    if (v11)
    {
      if (*((void *)v11 + 17) == 1)
      {

LABEL_19:
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v13 = NFLogGetLogger();
        if (v13)
        {
          id v14 = (void (*)(uint64_t, const char *, ...))v13;
          uint64_t v15 = object_getClass((id)a1);
          BOOL v16 = class_isMetaClass(v15);
          uint32_t v17 = object_getClassName((id)a1);
          __int16 v52 = sel_getName("openDriverForDPDTimers");
          uint64_t v18 = 45;
          if (v16) {
            uint64_t v18 = 43;
          }
          v14(6, "%c[%{public}s %{public}s]:%i EMM in progress", v18, v17, v52, 81);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v8 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v19 = object_getClass((id)a1);
          if (class_isMetaClass(v19)) {
            int v20 = 43;
          }
          else {
            int v20 = 45;
          }
          *(_DWORD *)buf = 67109890;
          int v58 = v20;
          __int16 v59 = 2082;
          uint64_t v60 = object_getClassName((id)a1);
          __int16 v61 = 2082;
          __int16 v62 = sel_getName("openDriverForDPDTimers");
          __int16 v63 = 1024;
          int v64 = 81;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i EMM in progress", buf, 0x22u);
        }
        goto LABEL_28;
      }
      int v12 = v11[170];

      if (v12) {
        goto LABEL_19;
      }
    }
    if (sub_1000F596C(a1))
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v21 = NFLogGetLogger();
      if (v21)
      {
        int v22 = (void (*)(uint64_t, const char *, ...))v21;
        id v23 = object_getClass((id)a1);
        BOOL v24 = class_isMetaClass(v23);
        __int16 v25 = object_getClassName((id)a1);
        int v53 = sel_getName("openDriverForDPDTimers");
        uint64_t v26 = 45;
        if (v24) {
          uint64_t v26 = 43;
        }
        v22(6, "%c[%{public}s %{public}s]:%i Active session", v26, v25, v53, 86);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v8 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v27 = object_getClass((id)a1);
        if (class_isMetaClass(v27)) {
          int v28 = 43;
        }
        else {
          int v28 = 45;
        }
        *(_DWORD *)buf = 67109890;
        int v58 = v28;
        __int16 v59 = 2082;
        uint64_t v60 = object_getClassName((id)a1);
        __int16 v61 = 2082;
        __int16 v62 = sel_getName("openDriverForDPDTimers");
        __int16 v63 = 1024;
        int v64 = 86;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Active session", buf, 0x22u);
      }
      goto LABEL_28;
    }
    double v29 = sub_1001E9660((void **)a1);
    if (v29 > 0.0)
    {
      double v30 = v29;
      uint64_t v31 = [(id)a1 driverWrapper];
      id v32 = sub_10020EC8C(v31, @"SE KeepAlive", 0);

      if (!v32)
      {
        *(unsigned char *)(a1 + 341) = 1;
        objc_initWeak(&location, (id)a1);
        uint64_t v33 = (id *)(a1 + 144);
        id v34 = *(id *)(a1 + 144);
        BOOL v35 = v34 == 0;

        if (v35)
        {
          id v36 = objc_alloc((Class)NFTimer);
          v54[0] = _NSConcreteStackBlock;
          v54[1] = 3221225472;
          v54[2] = sub_1001EA210;
          v54[3] = &unk_1003022A0;
          objc_copyWeak(v55, &location);
          v55[1] = "openDriverForDPDTimers";
          id v37 = *(id *)(a1 + 232);
          id v38 = [v36 initWithCallback:v54 queue:v37];
          objc_storeStrong((id *)(a1 + 144), v38);

          objc_destroyWeak(v55);
        }
        id v39 = *v33;
        [v39 stopTimer];

        id v40 = *v33;
        [v40 startTimer:v30];

        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v41 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v41)
        {
          int v42 = object_getClass((id)a1);
          if (class_isMetaClass(v42)) {
            uint64_t v43 = 43;
          }
          else {
            uint64_t v43 = 45;
          }
          __int16 v44 = object_getClassName((id)a1);
          __int16 v45 = sel_getName("openDriverForDPDTimers");
          v41(6, "%c[%{public}s %{public}s]:%i Check in %fs", v43, v44, v45, 117, *(void *)&v30);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        __int16 v46 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v47 = object_getClass((id)a1);
          if (class_isMetaClass(v47)) {
            int v48 = 43;
          }
          else {
            int v48 = 45;
          }
          __int16 v49 = object_getClassName((id)a1);
          uint64_t v50 = sel_getName("openDriverForDPDTimers");
          *(_DWORD *)buf = 67110146;
          int v58 = v48;
          __int16 v59 = 2082;
          uint64_t v60 = v49;
          __int16 v61 = 2082;
          __int16 v62 = v50;
          __int16 v63 = 1024;
          int v64 = 117;
          __int16 v65 = 2048;
          double v66 = v30;
          _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Check in %fs", buf, 0x2Cu);
        }

        objc_destroyWeak(&location);
      }
    }
    *(unsigned char *)(a1 + 340) = 0;
  }
}

void sub_1001EA1D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1001EA210(uint64_t a1)
{
  WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v3 = WeakRetained;
  if (!WeakRetained) {
    goto LABEL_40;
  }
  double v4 = -1.0;
  if (sub_1001E9AD0(WeakRetained))
  {
    BOOL v5 = (unsigned __int8 *)v3[3];
    if (v5)
    {
      if (*((void *)v5 + 17) == 1)
      {

LABEL_7:
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          id v8 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(v3);
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(v3);
          Name = sel_getName("_dpdTimerRunning");
          uint64_t v12 = 45;
          if (isMetaClass) {
            uint64_t v12 = 43;
          }
          v8(6, "%c[%{public}s %{public}s]:%i EMM in progress", v12, ClassName, Name, 151);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v13 = NFSharedLogGetLogger();
        if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_17;
        }
        id v14 = object_getClass(v3);
        if (class_isMetaClass(v14)) {
          int v15 = 43;
        }
        else {
          int v15 = 45;
        }
        *(_DWORD *)buf = 67109890;
        int v53 = v15;
        __int16 v54 = 2082;
        double v55 = object_getClassName(v3);
        __int16 v56 = 2082;
        long long v57 = sel_getName("_dpdTimerRunning");
        __int16 v58 = 1024;
        int v59 = 151;
        BOOL v16 = "%c[%{public}s %{public}s]:%i EMM in progress";
LABEL_16:
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, v16, buf, 0x22u);
LABEL_17:

        goto LABEL_18;
      }
      int v6 = v5[170];

      if (v6) {
        goto LABEL_7;
      }
    }
    if (!sub_1000F596C((uint64_t)v3))
    {
      double v4 = sub_1001E9660(v3);
      goto LABEL_18;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v40 = NFLogGetLogger();
    if (v40)
    {
      int v41 = (void (*)(uint64_t, const char *, ...))v40;
      int v42 = object_getClass(v3);
      BOOL v43 = class_isMetaClass(v42);
      __int16 v44 = object_getClassName(v3);
      int v51 = sel_getName("_dpdTimerRunning");
      uint64_t v45 = 45;
      if (v43) {
        uint64_t v45 = 43;
      }
      v41(6, "%c[%{public}s %{public}s]:%i Active session", v45, v44, v51, 156);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v13 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_17;
    }
    __int16 v46 = object_getClass(v3);
    if (class_isMetaClass(v46)) {
      int v47 = 43;
    }
    else {
      int v47 = 45;
    }
    *(_DWORD *)buf = 67109890;
    int v53 = v47;
    __int16 v54 = 2082;
    double v55 = object_getClassName(v3);
    __int16 v56 = 2082;
    long long v57 = sel_getName("_dpdTimerRunning");
    __int16 v58 = 1024;
    int v59 = 156;
    BOOL v16 = "%c[%{public}s %{public}s]:%i Active session";
    goto LABEL_16;
  }
LABEL_18:
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v17 = NFLogGetLogger();
  if (v17)
  {
    uint64_t v18 = (void (*)(uint64_t, const char *, ...))v17;
    uint64_t v19 = object_getClass(v3);
    BOOL v20 = class_isMetaClass(v19);
    uint64_t v21 = object_getClassName(v3);
    __int16 v49 = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v22 = 45;
    if (v20) {
      uint64_t v22 = 43;
    }
    v18(6, "%c[%{public}s %{public}s]:%i Check DPD timer: %f", v22, v21, v49, 105, *(void *)&v4);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v23 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v24 = object_getClass(v3);
    if (class_isMetaClass(v24)) {
      int v25 = 43;
    }
    else {
      int v25 = 45;
    }
    uint64_t v26 = object_getClassName(v3);
    uint64_t v27 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)buf = 67110146;
    int v53 = v25;
    __int16 v54 = 2082;
    double v55 = v26;
    __int16 v56 = 2082;
    long long v57 = v27;
    __int16 v58 = 1024;
    int v59 = 105;
    __int16 v60 = 2048;
    double v61 = v4;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Check DPD timer: %f", buf, 0x2Cu);
  }

  if (v4 == 0.0)
  {
    sub_1001EA77C(v3);
  }
  else if (v4 > 0.0)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v28 = NFLogGetLogger();
    if (v28)
    {
      double v29 = (void (*)(uint64_t, const char *, ...))v28;
      double v30 = object_getClass(v3);
      BOOL v31 = class_isMetaClass(v30);
      id v32 = object_getClassName(v3);
      uint64_t v50 = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v33 = 45;
      if (v31) {
        uint64_t v33 = 43;
      }
      v29(6, "%c[%{public}s %{public}s]:%i Restart delay check, %fs", v33, v32, v50, 110, *(void *)&v4);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v34 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v35 = object_getClass(v3);
      if (class_isMetaClass(v35)) {
        int v36 = 43;
      }
      else {
        int v36 = 45;
      }
      id v37 = object_getClassName(v3);
      id v38 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)buf = 67110146;
      int v53 = v36;
      __int16 v54 = 2082;
      double v55 = v37;
      __int16 v56 = 2082;
      long long v57 = v38;
      __int16 v58 = 1024;
      int v59 = 110;
      __int16 v60 = 2048;
      double v61 = v4;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Restart delay check, %fs", buf, 0x2Cu);
    }

    id v39 = v3[18];
    [v39 startTimer:v4];
  }
LABEL_40:
}

void sub_1001EA77C(unsigned char *a1)
{
  if (a1)
  {
    if (a1[341])
    {
      mach_port_t v2 = [a1 driverWrapper];
      sub_1002114AC(v2, @"SE KeepAlive");

      a1[341] = 0;
    }
  }
}

void sub_1001EA7D0(unsigned char *a1)
{
  if (a1 && sub_1001E9AD0(a1))
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("markDPDTimerChanged");
      uint64_t v7 = 45;
      if (isMetaClass) {
        uint64_t v7 = 43;
      }
      v3(6, "%c[%{public}s %{public}s]:%i ", v7, ClassName, Name, 128);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v8 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      id v9 = object_getClass(a1);
      if (class_isMetaClass(v9)) {
        int v10 = 43;
      }
      else {
        int v10 = 45;
      }
      *(_DWORD *)buf = 67109890;
      int v13 = v10;
      __int16 v14 = 2082;
      int v15 = object_getClassName(a1);
      __int16 v16 = 2082;
      uint64_t v17 = sel_getName("markDPDTimerChanged");
      __int16 v18 = 1024;
      int v19 = 128;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
    }

    a1[340] = 1;
  }
}

uint64_t sub_1001EADFC(void *a1)
{
  if (!a1) {
    return 0;
  }
  id v1 = a1;
  objc_sync_enter(v1);
  if (v1[137]) {
    uint64_t v2 = 0;
  }
  else {
    uint64_t v2 = NFDriverTriggerDelayedWake();
  }
  objc_sync_exit(v1);

  return v2;
}

void sub_1001EAE64(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1001EAE78(void *a1)
{
  if (!a1) {
    return 0;
  }
  id v1 = a1;
  objc_sync_enter(v1);
  if (v1[137]) {
    uint64_t v2 = 0;
  }
  else {
    uint64_t v2 = NFDriverCrashNFCC();
  }
  objc_sync_exit(v1);

  return v2;
}

void sub_1001EAEE0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1001EAEF4(void *a1)
{
  if (!a1) {
    return 0;
  }
  id v1 = a1;
  objc_sync_enter(v1);
  if (v1[137]) {
    uint64_t v2 = 0;
  }
  else {
    uint64_t v2 = NFDriverToggleGPIO();
  }
  objc_sync_exit(v1);

  return v2;
}

void sub_1001EAF5C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_1001EAF70(void *a1, int a2)
{
  id v2 = a1;
  if (a1)
  {
    int v4 = *(unsigned __int8 *)(a1[5] + 58);
    BOOL v5 = v4 != a2;
    int v6 = a1;
    objc_sync_enter(v6);
    if (*((unsigned char *)v6 + 137))
    {
      id v7 = objc_alloc((Class)NSError);
      id v8 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v99 = NSLocalizedDescriptionKey;
      id v9 = +[NSString stringWithUTF8String:"Aborted"];
      BOOL v100 = v9;
      id v10 = +[NSDictionary dictionaryWithObjects:&v100 forKeys:&v99 count:1];
      id v2 = [v7 initWithDomain:v8 code:3 userInfo:v10];
LABEL_20:

LABEL_21:
      objc_sync_exit(v6);

      goto LABEL_22;
    }
    if (v6[37] != 1)
    {
      id v27 = objc_alloc((Class)NSError);
      id v8 = +[NSString stringWithUTF8String:"nfcd"];
      v97[0] = NSLocalizedDescriptionKey;
      id v9 = +[NSString stringWithUTF8String:"Invalid State"];
      v98[0] = v9;
      v98[1] = &off_10031F678;
      v97[1] = @"Line";
      v97[2] = @"Method";
      id v10 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("setupChipscope:")];
      v98[2] = v10;
      v97[3] = NSDebugDescriptionErrorKey;
      id v28 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("setupChipscope:"), 101];
      v98[3] = v28;
      double v29 = +[NSDictionary dictionaryWithObjects:v98 forKeys:v97 count:4];
      id v2 = [v27 initWithDomain:v8 code:12 userInfo:v29];

      goto LABEL_20;
    }
    if (a2)
    {
      sub_100211D70((uint64_t)v6, 0);
      if (v4 != a2)
      {
        int v11 = objc_opt_new();
        uint64_t v12 = [v11 runService:&off_1003235F0];
        int v13 = [v12 valueForKey:@"Error"];

        if (v13)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (Logger)
          {
            Class = object_getClass(v6);
            if (class_isMetaClass(Class)) {
              uint64_t v16 = 43;
            }
            else {
              uint64_t v16 = 45;
            }
            ClassName = object_getClassName(v6);
            Name = sel_getName("setupChipscope:");
            Logger(3, "%c[%{public}s %{public}s]:%i Failed to restore MFG FW", v16, ClassName, Name, 113);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          int v19 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            BOOL v20 = object_getClass(v6);
            if (class_isMetaClass(v20)) {
              int v21 = 43;
            }
            else {
              int v21 = 45;
            }
            *(_DWORD *)buf = 67109890;
            int v90 = v21;
            __int16 v91 = 2082;
            id v92 = object_getClassName(v6);
            __int16 v93 = 2082;
            id v94 = sel_getName("setupChipscope:");
            __int16 v95 = 1024;
            int v96 = 113;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to restore MFG FW", buf, 0x22u);
          }

          id v22 = objc_alloc((Class)NSError);
          id v23 = +[NSString stringWithUTF8String:"nfcd"];
          NSErrorUserInfoKey v87 = NSLocalizedDescriptionKey;
          BOOL v24 = +[NSString stringWithUTF8String:"Unknown Error"];
          id v88 = v24;
          int v25 = +[NSDictionary dictionaryWithObjects:&v88 forKeys:&v87 count:1];
          id v26 = [v22 initWithDomain:v23 code:6 userInfo:v25];
LABEL_38:
          id v2 = v26;

LABEL_71:
          BOOL v5 = 1;
LABEL_72:
          uint64_t v64 = v6[37];
          if (v64 != 4 && v64 != 1)
          {
LABEL_75:
            if (v5)
            {
              dispatch_time_t v65 = dispatch_time(0, 100000000);
              dispatch_after(v65, (dispatch_queue_t)&_dispatch_main_q, &stru_100306F08);
            }
            goto LABEL_21;
          }
LABEL_74:
          sub_1002112A8((uint64_t)v6);
          goto LABEL_75;
        }
      }
      int v42 = sub_10020F914((uint64_t)v6);
      if (v42)
      {
      }
      else if (v6[37] == 1)
      {
        if (v4 != a2)
        {
          id v2 = 0;
          BOOL v5 = 1;
          goto LABEL_74;
        }
        id v66 = objc_getProperty(v6, v43, 280, 1);
        [v66 bytes];
        id v68 = objc_getProperty(v6, v67, 280, 1);
        [v68 length];
        int v69 = NFDriverSetChipscope();

        if (!v69)
        {
          id v2 = 0;
          BOOL v5 = 0;
          goto LABEL_72;
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        unsigned __int8 v70 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v70)
        {
          uint64_t v71 = object_getClass(v6);
          if (class_isMetaClass(v71)) {
            uint64_t v72 = 43;
          }
          else {
            uint64_t v72 = 45;
          }
          uint64_t v73 = object_getClassName(v6);
          __int16 v74 = sel_getName("setupChipscope:");
          v70(3, "%c[%{public}s %{public}s]:%i Failed to enable chipscope", v72, v73, v74, 123);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v75 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
        {
          id v76 = object_getClass(v6);
          if (class_isMetaClass(v76)) {
            int v77 = 43;
          }
          else {
            int v77 = 45;
          }
          *(_DWORD *)buf = 67109890;
          int v90 = v77;
          __int16 v91 = 2082;
          id v92 = object_getClassName(v6);
          __int16 v93 = 2082;
          id v94 = sel_getName("setupChipscope:");
          __int16 v95 = 1024;
          int v96 = 123;
          _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to enable chipscope", buf, 0x22u);
        }

        id v78 = objc_alloc((Class)NSError);
        id v23 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v83 = NSLocalizedDescriptionKey;
        BOOL v24 = +[NSString stringWithUTF8String:"Stack Error"];
        BOOL v84 = v24;
        int v25 = +[NSDictionary dictionaryWithObjects:&v84 forKeys:&v83 count:1];
        id v54 = [v78 initWithDomain:v23 code:15 userInfo:v25];
        goto LABEL_70;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v45 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v45)
      {
        __int16 v46 = object_getClass(v6);
        if (class_isMetaClass(v46)) {
          uint64_t v47 = 43;
        }
        else {
          uint64_t v47 = 45;
        }
        int v48 = object_getClassName(v6);
        __int16 v49 = sel_getName("setupChipscope:");
        v45(3, "%c[%{public}s %{public}s]:%i Failed to restart stack", v47, v48, v49, 118);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v50 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
      {
        int v51 = object_getClass(v6);
        if (class_isMetaClass(v51)) {
          int v52 = 43;
        }
        else {
          int v52 = 45;
        }
        *(_DWORD *)buf = 67109890;
        int v90 = v52;
        __int16 v91 = 2082;
        id v92 = object_getClassName(v6);
        __int16 v93 = 2082;
        id v94 = sel_getName("setupChipscope:");
        __int16 v95 = 1024;
        int v96 = 118;
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to restart stack", buf, 0x22u);
      }

      id v53 = objc_alloc((Class)NSError);
      id v23 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v85 = NSLocalizedDescriptionKey;
      BOOL v24 = +[NSString stringWithUTF8String:"Stack Error"];
      BOOL v86 = v24;
      int v25 = +[NSDictionary dictionaryWithObjects:&v86 forKeys:&v85 count:1];
      id v54 = [v53 initWithDomain:v23 code:15 userInfo:v25];
    }
    else
    {
      sub_100211D70((uint64_t)v6, 0);
      if (v4)
      {
        BOOL v31 = objc_opt_new();
        id v32 = [v31 runService:0];
        int v13 = [v32 valueForKey:@"Error"];

        if (v13)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v33 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v33)
          {
            id v34 = object_getClass(v6);
            if (class_isMetaClass(v34)) {
              uint64_t v35 = 43;
            }
            else {
              uint64_t v35 = 45;
            }
            int v36 = object_getClassName(v6);
            id v37 = sel_getName("setupChipscope:");
            v33(3, "%c[%{public}s %{public}s]:%i Failed to restore Prod FW", v35, v36, v37, 136);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v38 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
          {
            id v39 = object_getClass(v6);
            if (class_isMetaClass(v39)) {
              int v40 = 43;
            }
            else {
              int v40 = 45;
            }
            *(_DWORD *)buf = 67109890;
            int v90 = v40;
            __int16 v91 = 2082;
            id v92 = object_getClassName(v6);
            __int16 v93 = 2082;
            id v94 = sel_getName("setupChipscope:");
            __int16 v95 = 1024;
            int v96 = 136;
            _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to restore Prod FW", buf, 0x22u);
          }

          id v41 = objc_alloc((Class)NSError);
          id v23 = +[NSString stringWithUTF8String:"nfcd"];
          NSErrorUserInfoKey v81 = NSLocalizedDescriptionKey;
          BOOL v24 = +[NSString stringWithUTF8String:"Unknown Error"];
          id v82 = v24;
          int v25 = +[NSDictionary dictionaryWithObjects:&v82 forKeys:&v81 count:1];
          id v26 = [v41 initWithDomain:v23 code:6 userInfo:v25];
          goto LABEL_38;
        }
      }
      __int16 v44 = sub_10020F914((uint64_t)v6);
      if (v44)
      {
      }
      else if (v6[37] == 1)
      {
        id v2 = 0;
        goto LABEL_74;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      double v55 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v55)
      {
        __int16 v56 = object_getClass(v6);
        if (class_isMetaClass(v56)) {
          uint64_t v57 = 43;
        }
        else {
          uint64_t v57 = 45;
        }
        __int16 v58 = object_getClassName(v6);
        int v59 = sel_getName("setupChipscope:");
        v55(3, "%c[%{public}s %{public}s]:%i Failed to restart stack", v57, v58, v59, 140);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v60 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
      {
        double v61 = object_getClass(v6);
        if (class_isMetaClass(v61)) {
          int v62 = 43;
        }
        else {
          int v62 = 45;
        }
        *(_DWORD *)buf = 67109890;
        int v90 = v62;
        __int16 v91 = 2082;
        id v92 = object_getClassName(v6);
        __int16 v93 = 2082;
        id v94 = sel_getName("setupChipscope:");
        __int16 v95 = 1024;
        int v96 = 140;
        _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to restart stack", buf, 0x22u);
      }

      id v63 = objc_alloc((Class)NSError);
      id v23 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v79 = NSLocalizedDescriptionKey;
      BOOL v24 = +[NSString stringWithUTF8String:"Stack Error"];
      uint64_t v80 = v24;
      int v25 = +[NSDictionary dictionaryWithObjects:&v80 forKeys:&v79 count:1];
      id v54 = [v63 initWithDomain:v23 code:15 userInfo:v25];
    }
LABEL_70:
    id v2 = v54;
    goto LABEL_71;
  }
LABEL_22:

  return v2;
}

void sub_1001EBC28(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1001EBC80(id a1)
{
}

void sub_1001EBC94(void *a1, void *a2)
{
  id v3 = a2;
  int v4 = v3;
  if (a1)
  {
    memset(v69, 0, sizeof(v69));
    id v5 = [v3 length];
    __int16 v58 = v4;
    id v6 = v4;
    int v59 = (unsigned __int8 *)[v6 bytes];
    uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    id v8 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136315906;
      int v62 = (uint8_t *)"-[NFDriverWrapper(Test) chipscopeNotify:]";
      __int16 v63 = 1024;
      int v64 = 162;
      __int16 v65 = 2082;
      id v66 = "Chipscope : ";
      __int16 v67 = 2048;
      id v68 = [v6 length];
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%s:%i %{public}s %lu bytes", buf, 0x26u);
    }
    id v57 = a1;

    if (Logger) {
      Logger(6, "%s:%i %s %lu bytes :", "-[NFDriverWrapper(Test) chipscopeNotify:]", 162, "Chipscope : ", [v6 length]);
    }
    id v56 = v6;
    if (v5)
    {
      uint64_t v9 = 0;
      do
      {
        unint64_t v10 = 0;
        int v11 = (char *)&v69[__sprintf_chk((char *)v69, 0, 0x30uLL, "%04lX: ", v9)];
        do
        {
          unint64_t v12 = v10 + 1;
          unint64_t v13 = v10 + 1 + v9;
          int v14 = sprintf(v11, "0x%02X ", v59[v9 + v10]);
          if (v10 > 6) {
            break;
          }
          v11 += v14;
          ++v10;
        }
        while (v13 < (unint64_t)v5);
        int v15 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          int v62 = v69;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%{public}s", buf, 0xCu);
        }

        if (Logger) {
          Logger(6, "%s", (const char *)v69);
        }
        v9 += v12;
      }
      while (v13 < (unint64_t)v5);
    }
    id v16 = objc_alloc((Class)NSString);
    uint64_t v17 = +[NSDate date];
    __int16 v18 = +[NSTimeZone localTimeZone];
    int v19 = +[NSISO8601DateFormatter stringFromDate:v17 timeZone:v18 formatOptions:1907];
    id v20 = [v16 initWithFormat:@"Chipscope_%@.txt", v19];

    int v21 = +[NSFileManager defaultManager];
    id v22 = [v21 temporaryDirectory];
    id v23 = [v22 URLByAppendingPathComponent:v20];

    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v24 = NFLogGetLogger();
    if (v24)
    {
      int v25 = (void (*)(uint64_t, const char *, ...))v24;
      Class = object_getClass(v57);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(v57);
      Name = sel_getName("chipscopeNotify:");
      double v30 = [v23 path];
      uint64_t v31 = 45;
      if (isMetaClass) {
        uint64_t v31 = 43;
      }
      v25(6, "%c[%{public}s %{public}s]:%i Log: %@", v31, ClassName, Name, 170, v30);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v32 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v33 = object_getClass(v57);
      if (class_isMetaClass(v33)) {
        int v34 = 43;
      }
      else {
        int v34 = 45;
      }
      uint64_t v35 = object_getClassName(v57);
      int v36 = sel_getName("chipscopeNotify:");
      id v37 = [v23 path];
      *(_DWORD *)int v69 = 67110146;
      *(_DWORD *)&v69[4] = v34;
      *(_WORD *)&v69[8] = 2082;
      *(void *)&v69[10] = v35;
      *(_WORD *)&v69[18] = 2082;
      *(void *)&v69[20] = v36;
      *(_WORD *)&v69[28] = 1024;
      *(_DWORD *)&v69[30] = 170;
      *(_WORD *)&v69[34] = 2112;
      *(void *)&v69[36] = v37;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Log: %@", v69, 0x2Cu);
    }
    id v38 = objc_alloc_init((Class)NSMutableString);
    id v39 = v56;
    int v40 = (unsigned __int8 *)[v39 bytes];
    if ([v39 length])
    {
      unint64_t v41 = 0;
      do
        [v38 appendFormat:@"%02X\n", v40[v41++]];
      while ((unint64_t)[v39 length] > v41);
    }
    id v60 = 0;
    unsigned __int8 v42 = [v38 writeToURL:v23 atomically:1 encoding:1 error:&v60];
    id v43 = v60;
    if ((v42 & 1) == 0)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v44 = NFLogGetLogger();
      if (v44)
      {
        uint64_t v45 = (void (*)(uint64_t, const char *, ...))v44;
        __int16 v46 = object_getClass(v57);
        BOOL v47 = class_isMetaClass(v46);
        id v54 = object_getClassName(v57);
        double v55 = sel_getName("chipscopeNotify:");
        uint64_t v48 = 45;
        if (v47) {
          uint64_t v48 = 43;
        }
        v45(3, "%c[%{public}s %{public}s]:%i Error creating log: %@", v48, v54, v55, 182, v43);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v49 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
      {
        uint64_t v50 = object_getClass(v57);
        if (class_isMetaClass(v50)) {
          int v51 = 43;
        }
        else {
          int v51 = 45;
        }
        int v52 = object_getClassName(v57);
        id v53 = sel_getName("chipscopeNotify:");
        *(_DWORD *)int v69 = 67110146;
        *(_DWORD *)&v69[4] = v51;
        *(_WORD *)&v69[8] = 2082;
        *(void *)&v69[10] = v52;
        *(_WORD *)&v69[18] = 2082;
        *(void *)&v69[20] = v53;
        *(_WORD *)&v69[28] = 1024;
        *(_DWORD *)&v69[30] = 182;
        *(_WORD *)&v69[34] = 2112;
        *(void *)&v69[36] = v43;
        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error creating log: %@", v69, 0x2Cu);
      }
    }
    int v4 = v58;
  }
}

id sub_1001EC2F4(void *a1, unsigned int a2)
{
  if (a1)
  {
    id v3 = a1;
    objc_sync_enter(v3);
    if (*((unsigned char *)v3 + 137))
    {
      id v4 = objc_alloc((Class)NSError);
      ErrorCode = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
      id v6 = +[NSString stringWithUTF8String:"Aborted"];
      int v15 = v6;
      id v7 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
      id v8 = [v4 initWithDomain:ErrorCode code:3 userInfo:v7];
    }
    else
    {
      if (!NFDriverContinuousWave())
      {
        sub_1001E6E4C(*((unsigned char **)v3 + 10), a2);
        id v8 = 0;
        goto LABEL_7;
      }
      ErrorCode = (void *)NFDriverCreateErrorCode();
      id v9 = objc_alloc((Class)NSError);
      id v6 = +[NSString stringWithUTF8String:"nfcd"];
      v12[0] = NSLocalizedDescriptionKey;
      id v7 = +[NSString stringWithUTF8String:"Stack Error"];
      v12[1] = NSUnderlyingErrorKey;
      v13[0] = v7;
      v13[1] = ErrorCode;
      unint64_t v10 = +[NSDictionary dictionaryWithObjects:v13 forKeys:v12 count:2];
      id v8 = [v9 initWithDomain:v6 code:15 userInfo:v10];
    }
LABEL_7:
    objc_sync_exit(v3);

    goto LABEL_8;
  }
  id v8 = 0;
LABEL_8:

  return v8;
}

void sub_1001EC510(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_1001EC534(void *a1)
{
  if (a1)
  {
    id v1 = a1;
    objc_sync_enter(v1);
    if (v1[137])
    {
      id v2 = objc_alloc((Class)NSError);
      ErrorCode = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
      id v4 = +[NSString stringWithUTF8String:"Aborted"];
      unint64_t v13 = v4;
      id v5 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      id v6 = [v2 initWithDomain:ErrorCode code:3 userInfo:v5];
    }
    else
    {
      if (!NFDriverReadATETrimVersion())
      {
        id v6 = 0;
        goto LABEL_7;
      }
      ErrorCode = (void *)NFDriverCreateErrorCode();
      id v7 = objc_alloc((Class)NSError);
      id v4 = +[NSString stringWithUTF8String:"nfcd"];
      v10[0] = NSLocalizedDescriptionKey;
      id v5 = +[NSString stringWithUTF8String:"Stack Error"];
      v10[1] = NSUnderlyingErrorKey;
      v11[0] = v5;
      v11[1] = ErrorCode;
      id v8 = +[NSDictionary dictionaryWithObjects:v11 forKeys:v10 count:2];
      id v6 = [v7 initWithDomain:v4 code:15 userInfo:v8];
    }
LABEL_7:
    objc_sync_exit(v1);

    goto LABEL_8;
  }
  id v6 = 0;
LABEL_8:

  return v6;
}

void sub_1001EC73C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_1001EC760(void *a1, int a2)
{
  if (a1)
  {
    id v3 = a1;
    objc_sync_enter(v3);
    if (v3[137])
    {
      id v4 = objc_alloc((Class)NSError);
      id v5 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v18 = NSLocalizedDescriptionKey;
      id v6 = +[NSString stringWithUTF8String:"Aborted"];
      int v19 = v6;
      id v7 = +[NSDictionary dictionaryWithObjects:&v19 forKeys:&v18 count:1];
      id v8 = [v4 initWithDomain:v5 code:3 userInfo:v7];
    }
    else if (NFDriverEnableSMBLogging())
    {
      id v9 = [objc_alloc((Class)NSUserDefaults) initWithSuiteName:@"com.apple.stockholm"];
      unint64_t v10 = v9;
      if (a2) {
        [v9 setBool:1 forKey:@"smbLogEnabled"];
      }
      else {
        [v9 removeObjectForKey:@"smbLogEnabled"];
      }

      id v8 = 0;
    }
    else
    {
      id v11 = objc_alloc((Class)NSError);
      NSErrorUserInfoKey v12 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v16 = NSLocalizedDescriptionKey;
      unint64_t v13 = +[NSString stringWithUTF8String:"Stack Error"];
      uint64_t v17 = v13;
      NSErrorUserInfoKey v14 = +[NSDictionary dictionaryWithObjects:&v17 forKeys:&v16 count:1];
      id v8 = [v11 initWithDomain:v12 code:15 userInfo:v14];
    }
    objc_sync_exit(v3);
  }
  else
  {
    id v8 = 0;
  }

  return v8;
}

void sub_1001EC9A4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1001EC9C4(void *a1)
{
  if (!a1) {
    return 0;
  }
  id v1 = a1;
  objc_sync_enter(v1);
  if (v1[137]) {
    uint64_t v2 = 0;
  }
  else {
    uint64_t v2 = NFDriverCopySMBLog();
  }
  objc_sync_exit(v1);

  return v2;
}

void sub_1001ECA24(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1001ED16C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id location)
{
}

void sub_1001ED238(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(id **)(a1 + 40);
    if (v2)
    {
      sub_100202390(v2, 0);
      id v3 = *(void **)(a1 + 40);
      *(void *)(a1 + 40) = 0;
    }
  }
}

void sub_1001ED290(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(void **)(a1 + 32);
    if (v2)
    {
      sub_1000BA23C(v2);
      id v3 = *(void **)(a1 + 32);
      *(void *)(a1 + 32) = 0;
    }
  }
}

void sub_1001ED2E4(uint64_t a1)
{
  SCPreferencesSynchronize(*(SCPreferencesRef *)(a1 + 64));
  CFBooleanRef Value = (const __CFBoolean *)SCPreferencesGetValue(*(SCPreferencesRef *)(a1 + 64), @"AirplaneMode");
  if (!Value)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass((id)a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName((id)a1);
      Name = sel_getName("updateAirplaneMode");
      uint64_t v10 = 45;
      if (isMetaClass) {
        uint64_t v10 = 43;
      }
      v6(3, "%c[%{public}s %{public}s]:%i Can't read AP mode", v10, ClassName, Name, 256);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v11 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    NSErrorUserInfoKey v12 = object_getClass((id)a1);
    if (class_isMetaClass(v12)) {
      int v13 = 43;
    }
    else {
      int v13 = 45;
    }
    *(_DWORD *)buf = 67109890;
    int v26 = v13;
    __int16 v27 = 2082;
    id v28 = object_getClassName((id)a1);
    __int16 v29 = 2082;
    double v30 = sel_getName("updateAirplaneMode");
    __int16 v31 = 1024;
    int v32 = 256;
    NSErrorUserInfoKey v14 = "%c[%{public}s %{public}s]:%i Can't read AP mode";
    goto LABEL_22;
  }
  CFBooleanRef v3 = Value;
  CFTypeID v4 = CFGetTypeID(Value);
  if (v4 == CFBooleanGetTypeID())
  {
    *(unsigned char *)(a1 + 153) = CFBooleanGetValue(v3) != 0;
    return;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v15 = NFLogGetLogger();
  if (v15)
  {
    NSErrorUserInfoKey v16 = (void (*)(uint64_t, const char *, ...))v15;
    uint64_t v17 = object_getClass((id)a1);
    BOOL v18 = class_isMetaClass(v17);
    int v19 = object_getClassName((id)a1);
    uint64_t v24 = sel_getName("updateAirplaneMode");
    uint64_t v20 = 45;
    if (v18) {
      uint64_t v20 = 43;
    }
    v16(3, "%c[%{public}s %{public}s]:%i Unexpected type", v20, v19, v24, 252);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v11 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    int v21 = object_getClass((id)a1);
    if (class_isMetaClass(v21)) {
      int v22 = 43;
    }
    else {
      int v22 = 45;
    }
    *(_DWORD *)buf = 67109890;
    int v26 = v22;
    __int16 v27 = 2082;
    id v28 = object_getClassName((id)a1);
    __int16 v29 = 2082;
    double v30 = sel_getName("updateAirplaneMode");
    __int16 v31 = 1024;
    int v32 = 252;
    NSErrorUserInfoKey v14 = "%c[%{public}s %{public}s]:%i Unexpected type";
LABEL_22:
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, v14, buf, 0x22u);
  }
LABEL_23:
}

void sub_1001ED5B8(uint64_t a1, char a2, unsigned __int8 *a3)
{
  if ((a2 & 2) != 0 && a3)
  {
    uint64_t v6 = a3[153];
    sub_1001ED2E4((uint64_t)a3);
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v8 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a3);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a3);
      Name = sel_getName("airplaneModeChanged");
      uint64_t v13 = 45;
      if (isMetaClass) {
        uint64_t v13 = 43;
      }
      v8(6, "%c[%{public}s %{public}s]:%i Airplane mode state changed: %d -> %d", v13, ClassName, Name, 207, v6, a3[153]);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    NSErrorUserInfoKey v14 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = object_getClass(a3);
      if (class_isMetaClass(v15)) {
        int v16 = 43;
      }
      else {
        int v16 = 45;
      }
      uint64_t v17 = object_getClassName(a3);
      BOOL v18 = sel_getName("airplaneModeChanged");
      int v19 = a3[153];
      *(_DWORD *)buf = 67110402;
      int v21 = v16;
      __int16 v22 = 2082;
      id v23 = v17;
      __int16 v24 = 2082;
      int v25 = v18;
      __int16 v26 = 1024;
      int v27 = 207;
      __int16 v28 = 1024;
      int v29 = v6;
      __int16 v30 = 1024;
      int v31 = v19;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Airplane mode state changed: %d -> %d", buf, 0x2Eu);
    }

    if (v6 != a3[153])
    {
      if (a3[153]) {
        [a3 suspend];
      }
      else {
        [a3 resume];
      }
    }
  }
}

void sub_1001ED864(void *a1, int a2)
{
  if (a1)
  {
    uint64_t v3 = a1[14];
    a1[14] = v3 + 1;
    if (!v3)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        uint64_t v6 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("_suspend:");
        uint64_t v10 = 45;
        if (isMetaClass) {
          uint64_t v10 = 43;
        }
        v6(6, "%c[%{public}s %{public}s]:%i suspend", v10, ClassName, Name, 311);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v11 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        NSErrorUserInfoKey v12 = object_getClass(a1);
        if (class_isMetaClass(v12)) {
          int v13 = 43;
        }
        else {
          int v13 = 45;
        }
        *(_DWORD *)buf = 67109890;
        int v21 = v13;
        __int16 v22 = 2082;
        id v23 = object_getClassName(a1);
        __int16 v24 = 2082;
        int v25 = sel_getName("_suspend:");
        __int16 v26 = 1024;
        int v27 = 311;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i suspend", buf, 0x22u);
      }

      sub_1001ED238((uint64_t)a1);
      sub_1001ED290((uint64_t)a1);
      NSErrorUserInfoKey v14 = +[_NFHardwareManager sharedHardwareManager];
      uint64_t v15 = v14;
      if (a2)
      {
        int v16 = sub_10012050C(v14);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_1001EDAB4;
        block[3] = &unk_100301C68;
        int v19 = v15;
        dispatch_async(v16, block);
      }
      else
      {
        [v14 maybeStartNextSession];
      }
    }
  }
}

id sub_1001EDAB4(uint64_t a1)
{
  return [*(id *)(a1 + 32) maybeStartNextSession];
}

void sub_1001EDAC4(void *a1, int a2)
{
  if (a1)
  {
    uint64_t v3 = a1[14];
    if (v3)
    {
      uint64_t v4 = v3 - 1;
      a1[14] = v4;
      if (v4) {
        return;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        id v7 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("_resume:");
        uint64_t v11 = 45;
        if (isMetaClass) {
          uint64_t v11 = 43;
        }
        v7(6, "%c[%{public}s %{public}s]:%i resume", v11, ClassName, Name, 345);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      NSErrorUserInfoKey v12 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        int v13 = object_getClass(a1);
        if (class_isMetaClass(v13)) {
          int v14 = 43;
        }
        else {
          int v14 = 45;
        }
        *(_DWORD *)buf = 67109890;
        int v31 = v14;
        __int16 v32 = 2082;
        uint64_t v33 = object_getClassName(a1);
        __int16 v34 = 2082;
        uint64_t v35 = sel_getName("_resume:");
        __int16 v36 = 1024;
        int v37 = 345;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i resume", buf, 0x22u);
      }

      sub_1001EDE34((uint64_t)a1);
      sub_1001EDE9C((void **)a1);
      uint64_t v15 = +[_NFHardwareManager sharedHardwareManager];
      int v16 = v15;
      if (a2)
      {
        uint64_t v17 = sub_10012050C(v15);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_1001EDFF4;
        block[3] = &unk_100301C68;
        int v16 = v16;
        int v29 = v16;
        dispatch_async(v17, block);
      }
      else
      {
        [v15 maybeStartNextSession];
      }
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v18 = NFLogGetLogger();
      if (v18)
      {
        int v19 = (void (*)(uint64_t, const char *, ...))v18;
        uint64_t v20 = object_getClass(a1);
        BOOL v21 = class_isMetaClass(v20);
        __int16 v22 = object_getClassName(a1);
        int v27 = sel_getName("_resume:");
        uint64_t v23 = 45;
        if (v21) {
          uint64_t v23 = 43;
        }
        v19(3, "%c[%{public}s %{public}s]:%i Suspend count underflow", v23, v22, v27, 340);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v16 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        __int16 v24 = object_getClass(a1);
        if (class_isMetaClass(v24)) {
          int v25 = 43;
        }
        else {
          int v25 = 45;
        }
        *(_DWORD *)buf = 67109890;
        int v31 = v25;
        __int16 v32 = 2082;
        uint64_t v33 = object_getClassName(a1);
        __int16 v34 = 2082;
        uint64_t v35 = sel_getName("_resume:");
        __int16 v36 = 1024;
        int v37 = 340;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Suspend count underflow", buf, 0x22u);
      }
    }
  }
}

void sub_1001EDE34(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = *(id **)(a1 + 40);
    if (!v2)
    {
      uint64_t v3 = sub_1002022E8((id *)[NFScreenStateMonitor alloc], *(void **)(a1 + 80));
      uint64_t v4 = *(void **)(a1 + 40);
      *(void *)(a1 + 40) = v3;

      uint64_t v2 = *(id **)(a1 + 40);
    }
    sub_100202390(v2, (void *)a1);
  }
}

void **sub_1001EDE9C(void **result)
{
  if (result)
  {
    id v1 = result;
    uint64_t v2 = result[4];
    if (!v2)
    {
      uint64_t v3 = sub_1000B9C04((id *)[NFTouchSensorMonitor alloc], v1[10], v1);
      uint64_t v4 = v1[4];
      v1[4] = v3;

      if (v1[4])
      {
        objc_initWeak(&location, v1);
        id v5 = objc_alloc((Class)NFTimer);
        v8[0] = _NSConcreteStackBlock;
        v8[1] = 3221225472;
        v8[2] = sub_1001EFB8C;
        v8[3] = &unk_100301E90;
        objc_copyWeak(v9, &location);
        v9[1] = "startTouchSensorMonitor";
        v8[4] = v1;
        id v6 = [v5 initWithCallback:v8 queue:v1[10]];
        id v7 = v1[6];
        v1[6] = v6;

        objc_destroyWeak(v9);
        objc_destroyWeak(&location);
        uint64_t v2 = v1[4];
      }
      else
      {
        uint64_t v2 = 0;
      }
    }
    sub_1000B9E7C(v2);
    return (void **)[v1[6] startTimer:0.7];
  }
  return result;
}

void sub_1001EDFD0(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

id sub_1001EDFF4(uint64_t a1)
{
  return [*(id *)(a1 + 32) maybeStartNextSession];
}

void sub_1001EF50C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 160), 8);
  _Unwind_Resume(a1);
}

void sub_1001EF568(uint64_t a1)
{
  uint64_t v2 = _os_activity_create((void *)&_mh_execute_header, "com.apple.nfcd.reader.background.suspensionTimer", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  *(void *)state = 0;
  *(void *)&state[8] = 0;
  os_activity_scope_enter(v2, (os_activity_scope_state_t)state);
  os_activity_scope_leave((os_activity_scope_state_t)state);

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v4 = WeakRetained;
  if (WeakRetained)
  {
    id v5 = (void *)*((void *)WeakRetained + 7);
    *((void *)WeakRetained + 7) = 0;

    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v7 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v4);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(v4);
      Name = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v11 = 45;
      if (isMetaClass) {
        uint64_t v11 = 43;
      }
      v7(4, "%c[%{public}s %{public}s]:%i Resume non-compliant tag suspension", v11, ClassName, Name, 426);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    NSErrorUserInfoKey v12 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      int v13 = object_getClass(v4);
      if (class_isMetaClass(v13)) {
        int v14 = 43;
      }
      else {
        int v14 = 45;
      }
      uint64_t v15 = object_getClassName(v4);
      int v16 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)state = 67109890;
      *(_DWORD *)&state[4] = v14;
      *(_WORD *)&state[8] = 2082;
      *(void *)&state[10] = v15;
      __int16 v19 = 2082;
      uint64_t v20 = v16;
      __int16 v21 = 1024;
      int v22 = 426;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Resume non-compliant tag suspension", state, 0x22u);
    }

    [v4 resume];
  }
}

void sub_1001EFB8C(uint64_t a1)
{
  uint64_t v2 = _os_activity_create((void *)&_mh_execute_header, "com.apple.nfcd.touch.eventTimer", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  *(void *)state = 0;
  *(void *)&state[8] = 0;
  os_activity_scope_enter(v2, (os_activity_scope_state_t)state);
  os_activity_scope_leave((os_activity_scope_state_t)state);

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(WeakRetained);
      if (class_isMetaClass(Class)) {
        uint64_t v7 = 43;
      }
      else {
        uint64_t v7 = 45;
      }
      ClassName = object_getClassName(WeakRetained);
      Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v10 = WeakRetained[4];
      if (v10) {
        uint64_t v10 = *(unsigned __int8 *)(v10 + 8);
      }
      v5(4, "%c[%{public}s %{public}s]:%i Touch system ready event expired, systemReady=%d", v7, ClassName, Name, 568, v10);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v11 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      NSErrorUserInfoKey v12 = object_getClass(WeakRetained);
      if (class_isMetaClass(v12)) {
        int v13 = 43;
      }
      else {
        int v13 = 45;
      }
      int v14 = object_getClassName(WeakRetained);
      uint64_t v15 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v16 = WeakRetained[4];
      if (v16) {
        LODWORD(v16) = *(unsigned __int8 *)(v16 + 8);
      }
      *(_DWORD *)state = 67110146;
      *(_DWORD *)&state[4] = v13;
      *(_WORD *)&state[8] = 2082;
      *(void *)&state[10] = v14;
      __int16 v18 = 2082;
      __int16 v19 = v15;
      __int16 v20 = 1024;
      int v21 = 568;
      __int16 v22 = 1024;
      int v23 = v16;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Touch system ready event expired, systemReady=%d", state, 0x28u);
    }

    [WeakRetained touchSystemReady:1];
    dispatch_async(*(dispatch_queue_t *)(*(void *)(a1 + 32) + 72), &stru_100306F28);
  }
}

void sub_1001EFD98(id a1)
{
  id v1 = +[_NFHardwareManager sharedHardwareManager];
  [v1 maybeStartNextSession];
}

void sub_1001F050C(uint64_t a1)
{
  uint64_t v2 = +[_NFHardwareManager sharedHardwareManager];
  [v2 enablePowerCountersLogging:*(unsigned __int8 *)(a1 + 40)];

  uint64_t v3 = *(void *)(a1 + 32);
  if (*(unsigned char *)(a1 + 40))
  {
    if (!v3 || *(void *)(v3 + 32) && !*(unsigned char *)(v3 + 152))
    {
      uint64_t v4 = *(void **)(v3 + 48);
      [v4 startTimer:0.7];
      return;
    }
  }
  else
  {
    [*(id *)(v3 + 48) stopTimer];
    uint64_t v5 = *(void *)(a1 + 32);
    if (v5 && *(void *)(v5 + 32)) {
      *(unsigned char *)(v5 + 152) = 0;
    }
  }
  id v6 = +[_NFHardwareManager sharedHardwareManager];
  [v6 maybeStartNextSession];
}

void sub_1001F0660(uint64_t a1)
{
  id v2 = +[_NFHardwareManager sharedHardwareManager];
  [v2 didCameraStateChange:*(unsigned __int8 *)(a1 + 32)];
  [v2 maybeStartNextSession];
}

void sub_1001F0914(uint64_t a1)
{
  sub_1001F09DC();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("_CDContextQueries");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    qword_100347600 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    id v2 = +[NSAssertionHandler currentHandler];
    uint64_t v3 = +[NSString stringWithUTF8String:"Class get_CDContextQueriesClass(void)_block_invoke"];
    [v2 handleFailureInFunction:v3 file:@"NFBackgroundTagReadingManager.m" lineNumber:58 description:@"Unable to find class %s", "_CDContextQueries"];

    __break(1u);
  }
}

void sub_1001F09DC()
{
  v3[0] = 0;
  if (!qword_1003475F0)
  {
    v3[1] = _NSConcreteStackBlock;
    v3[2] = (void *)3221225472;
    v3[3] = sub_1001F0B2C;
    v3[4] = &unk_1003010A8;
    v3[5] = v3;
    long long v4 = off_100306F68;
    uint64_t v5 = 0;
    qword_1003475F0 = _sl_dlopen();
  }
  if (!qword_1003475F0)
  {
    id v1 = +[NSAssertionHandler currentHandler];
    id v2 = +[NSString stringWithUTF8String:"void *CoreDuetContextLibrary(void)"];
    [v1 handleFailureInFunction:v2 file:@"NFBackgroundTagReadingManager.m" lineNumber:57 description:@"%s" argument:v3[0]];

    __break(1u);
    goto LABEL_7;
  }
  id v0 = v3[0];
  if (v3[0]) {
LABEL_7:
  }
    free(v0);
}

uint64_t sub_1001F0B2C()
{
  uint64_t result = _sl_dlopen();
  qword_1003475F0 = result;
  return result;
}

void sub_1001F0BA0(uint64_t a1)
{
  sub_1001F09DC();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("_CDClientContext");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    qword_100347608 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    id v2 = +[NSAssertionHandler currentHandler];
    uint64_t v3 = +[NSString stringWithUTF8String:"Class get_CDClientContextClass(void)_block_invoke"];
    [v2 handleFailureInFunction:v3 file:@"NFBackgroundTagReadingManager.m" lineNumber:59 description:@"Unable to find class %s" _CDClientContext];

    __break(1u);
  }
}

void sub_1001F0C68(uint64_t a1)
{
  sub_1001F0D30();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("BMDeviceNFCTag");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    qword_100347610 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    id v2 = +[NSAssertionHandler currentHandler];
    uint64_t v3 = +[NSString stringWithUTF8String:"Class getBMDeviceNFCTagClass(void)_block_invoke"];
    [v2 handleFailureInFunction:v3 file:@"NFBackgroundTagReadingManager.m" lineNumber:63 description:@"Unable to find class %s" arguments:("BMDeviceNFCTag", nil)];

    __break(1u);
  }
}

void *sub_1001F0D30()
{
  v4[0] = 0;
  if (!qword_1003475F8)
  {
    v4[1] = _NSConcreteStackBlock;
    v4[2] = (void *)3221225472;
    v4[3] = sub_1001F0E84;
    v4[4] = &unk_1003010A8;
    v4[5] = v4;
    long long v5 = off_100306F80;
    uint64_t v6 = 0;
    qword_1003475F8 = _sl_dlopen();
  }
  id v0 = (void *)qword_1003475F8;
  if (!qword_1003475F8)
  {
    id v0 = +[NSAssertionHandler currentHandler];
    uint64_t v3 = +[NSString stringWithUTF8String:"void *BiomeLibraryLibrary(void)"];
    [v0 handleFailureInFunction:v3 file:@"NFBackgroundTagReadingManager.m" lineNumber:61 description:v4[0]];

    __break(1u);
    goto LABEL_7;
  }
  id v1 = v4[0];
  if (v4[0]) {
LABEL_7:
  }
    free(v1);
  return v0;
}

uint64_t sub_1001F0E84()
{
  uint64_t result = _sl_dlopen();
  qword_1003475F8 = result;
  return result;
}

void *sub_1001F0EF8(uint64_t a1)
{
  id v2 = sub_1001F0D30();
  uint64_t result = dlsym(v2, "__BMRootLibrary");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_100347618 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t sub_1001F1284(void *a1, void *a2, uint64_t a3, void *a4)
{
  id v7 = a2;
  id v8 = a4;
  if (!a1)
  {
    uint64_t v16 = 0;
    goto LABEL_133;
  }
  if (!v7)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      __int16 v18 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("_authorizeContactlessPayment:uid:targetAID:");
      uint64_t v22 = 45;
      if (isMetaClass) {
        uint64_t v22 = 43;
      }
      v18(3, "%c[%{public}s %{public}s]:%i Missing SSE handle", v22, ClassName, Name, 48);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v11 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      int v23 = object_getClass(a1);
      if (class_isMetaClass(v23)) {
        int v24 = 43;
      }
      else {
        int v24 = 45;
      }
      *(_DWORD *)buf = 67109890;
      int v163 = v24;
      __int16 v164 = 2082;
      long long v165 = object_getClassName(a1);
      __int16 v166 = 2082;
      long long v167 = sel_getName("_authorizeContactlessPayment:uid:targetAID:");
      __int16 v168 = 1024;
      int v169 = 48;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Missing SSE handle", buf, 0x22u);
    }
    uint64_t v16 = 9;
    goto LABEL_132;
  }
  kdebug_trace();
  id v9 = NFSharedSignpostLog();
  if (os_signpost_enabled(v9))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseGetHostChallenge in", buf, 2u);
  }

  id v161 = 0;
  unsigned int v10 = sub_10021F7F0((uint64_t)NFSSEWrapper, &v161);
  uint64_t v11 = v161;
  kdebug_trace();
  NSErrorUserInfoKey v12 = NFSharedSignpostLog();
  if (os_signpost_enabled(v12))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v12, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseGetHostChallenge out", buf, 2u);
  }

  if (!v11 || v10)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v25 = NFLogGetLogger();
    if (v25)
    {
      __int16 v26 = (void (*)(uint64_t, const char *, ...))v25;
      int v27 = object_getClass(a1);
      BOOL v28 = class_isMetaClass(v27);
      int v29 = object_getClassName(a1);
      v145 = sel_getName("_authorizeContactlessPayment:uid:targetAID:");
      uint64_t v30 = 45;
      if (v28) {
        uint64_t v30 = 43;
      }
      v26(3, "%c[%{public}s %{public}s]:%i Failed to get host challenge", v30, v29, v145, 60);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v31 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      __int16 v32 = object_getClass(a1);
      if (class_isMetaClass(v32)) {
        int v33 = 43;
      }
      else {
        int v33 = 45;
      }
      __int16 v34 = object_getClassName(a1);
      uint64_t v35 = sel_getName("_authorizeContactlessPayment:uid:targetAID:");
      *(_DWORD *)buf = 67109890;
      int v163 = v33;
      __int16 v164 = 2082;
      long long v165 = v34;
      __int16 v166 = 2082;
      long long v167 = v35;
      __int16 v168 = 1024;
      int v169 = 60;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get host challenge", buf, 0x22u);
    }

    if (v10) {
      uint64_t v16 = v10;
    }
    else {
      uint64_t v16 = 6;
    }
    goto LABEL_132;
  }
  if ([v11 length] != (id)8)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v36 = NFLogGetLogger();
    if (v36)
    {
      int v37 = (void (*)(uint64_t, const char *, ...))v36;
      id v38 = object_getClass(a1);
      BOOL v39 = class_isMetaClass(v38);
      int v40 = object_getClassName(a1);
      unint64_t v41 = sel_getName("_authorizeContactlessPayment:uid:targetAID:");
      id v147 = [v11 length];
      uint64_t v42 = 45;
      if (v39) {
        uint64_t v42 = 43;
      }
      v37(3, "%c[%{public}s %{public}s]:%i Invalid host challenge length: %lu", v42, v40, v41, 64, v147);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v43 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      uint64_t v44 = object_getClass(a1);
      if (class_isMetaClass(v44)) {
        int v45 = 43;
      }
      else {
        int v45 = 45;
      }
      __int16 v46 = object_getClassName(a1);
      BOOL v47 = sel_getName("_authorizeContactlessPayment:uid:targetAID:");
      CFStringRef v48 = (const __CFString *)[v11 length];
      *(_DWORD *)buf = 67110146;
      int v163 = v45;
      __int16 v164 = 2082;
      long long v165 = v46;
      __int16 v166 = 2082;
      long long v167 = v47;
      __int16 v168 = 1024;
      int v169 = 64;
      __int16 v170 = 2048;
      CFStringRef v171 = v48;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid host challenge length: %lu", buf, 0x2Cu);
    }

    uint64_t v16 = 13;
    goto LABEL_132;
  }
  id v160 = 0;
  id v13 = [a1 selectCRSWithError:&v160];
  id v14 = v160;
  uint64_t v15 = v14;
  if (v14)
  {
    if ([v14 code]) {
      uint64_t v16 = (uint64_t)[v15 code];
    }
    else {
      uint64_t v16 = 16;
    }
    goto LABEL_131;
  }
  id v159 = 0;
  uint64_t v16 = sub_1000C5684(a1, v11, &v159);
  id v49 = v159;
  uint64_t v50 = v49;
  if (v16)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v51 = NFLogGetLogger();
    if (v51)
    {
      int v52 = (void (*)(uint64_t, const char *, ...))v51;
      id v53 = object_getClass(a1);
      BOOL v54 = class_isMetaClass(v53);
      double v55 = object_getClassName(a1);
      id v56 = sel_getName("_authorizeContactlessPayment:uid:targetAID:");
      if (v16 >= 0x47) {
        int v57 = 71;
      }
      else {
        int v57 = v16;
      }
      id v150 = off_100306F98[v57];
      uint64_t v58 = 43;
      if (!v54) {
        uint64_t v58 = 45;
      }
      id v141 = v55;
      uint64_t v15 = 0;
      v52(3, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", v58, v141, v56, 78, @"Failed to authenticate", v16, v150);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v59 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
    {
      id v60 = object_getClass(a1);
      double v61 = v50;
      if (class_isMetaClass(v60)) {
        int v62 = 43;
      }
      else {
        int v62 = 45;
      }
      __int16 v63 = object_getClassName(a1);
      int v64 = sel_getName("_authorizeContactlessPayment:uid:targetAID:");
      if (v16 >= 0x47) {
        int v65 = 71;
      }
      else {
        int v65 = v16;
      }
      id v66 = off_100306F98[v65];
      *(_DWORD *)buf = 67110658;
      int v163 = v62;
      uint64_t v50 = v61;
      __int16 v164 = 2082;
      long long v165 = v63;
      __int16 v166 = 2082;
      long long v167 = v64;
      __int16 v168 = 1024;
      int v169 = 78;
      __int16 v170 = 2112;
      CFStringRef v171 = @"Failed to authenticate";
      __int16 v172 = 1024;
      int v173 = v16;
      __int16 v174 = 2080;
      v175 = v66;
      _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", buf, 0x3Cu);
    }

    goto LABEL_130;
  }
  if ([v49 length] != (id)16)
  {
    v155 = v50;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v102 = NFLogGetLogger();
    if (v102)
    {
      id v103 = (void (*)(uint64_t, const char *, ...))v102;
      int v104 = object_getClass(a1);
      BOOL v105 = class_isMetaClass(v104);
      id v106 = object_getClassName(a1);
      v107 = sel_getName("_authorizeContactlessPayment:uid:targetAID:");
      id v148 = [v50 length];
      BOOL v108 = !v105;
      uint64_t v15 = 0;
      uint64_t v109 = 45;
      if (!v108) {
        uint64_t v109 = 43;
      }
      v103(3, "%c[%{public}s %{public}s]:%i Invalid authenticate response length: %lu", v109, v106, v107, 82, v148);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v110 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v110, OS_LOG_TYPE_ERROR))
    {
      char v111 = object_getClass(a1);
      if (class_isMetaClass(v111)) {
        int v112 = 43;
      }
      else {
        int v112 = 45;
      }
      id v113 = object_getClassName(a1);
      __int16 v114 = sel_getName("_authorizeContactlessPayment:uid:targetAID:");
      CFStringRef v115 = (const __CFString *)[v155 length];
      *(_DWORD *)buf = 67110146;
      int v163 = v112;
      __int16 v164 = 2082;
      long long v165 = v113;
      __int16 v166 = 2082;
      long long v167 = v114;
      __int16 v168 = 1024;
      int v169 = 82;
      __int16 v170 = 2048;
      CFStringRef v171 = v115;
      _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid authenticate response length: %lu", buf, 0x2Cu);
    }

    uint64_t v16 = 13;
    uint64_t v50 = v155;
    goto LABEL_130;
  }
  unsigned __int8 v158 = 0;
  kdebug_trace();
  __int16 v67 = NFSharedSignpostLog();
  if (os_signpost_enabled(v67))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v67, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseAuthorize in", buf, 2u);
  }

  id v68 = [a1 serialNumberAsData];
  id v157 = 0;
  int v69 = sub_10021F9D8((uint64_t)NFSSEWrapper, 2, v7, v68, a3, v11, v50, (char *)&v158, &v157, 0, 0, 0, 0);
  id v154 = v157;

  kdebug_trace();
  unsigned __int8 v70 = NFSharedSignpostLog();
  if (os_signpost_enabled(v70))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v70, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseAuthorize out", buf, 2u);
  }

  uint64_t v15 = 0;
  if (!v69)
  {
    v153 = 0;
    BOOL v116 = v50;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v117 = NFLogGetLogger();
    if (v117)
    {
      long long v118 = (void (*)(uint64_t, const char *, ...))v117;
      long long v119 = object_getClass(a1);
      BOOL v120 = class_isMetaClass(v119);
      long long v121 = object_getClassName(a1);
      v146 = sel_getName("_authorizeContactlessPayment:uid:targetAID:");
      BOOL v108 = !v120;
      uint64_t v15 = 0;
      uint64_t v122 = 45;
      if (!v108) {
        uint64_t v122 = 43;
      }
      v118(3, "%c[%{public}s %{public}s]:%i Failed to generate cryptogram", v122, v121, v146, 158);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v94 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
    {
      v123 = object_getClass(a1);
      if (class_isMetaClass(v123)) {
        int v124 = 43;
      }
      else {
        int v124 = 45;
      }
      v125 = object_getClassName(a1);
      id v126 = sel_getName("_authorizeContactlessPayment:uid:targetAID:");
      *(_DWORD *)buf = 67109890;
      int v163 = v124;
      __int16 v164 = 2082;
      long long v165 = v125;
      __int16 v166 = 2082;
      long long v167 = v126;
      __int16 v168 = 1024;
      int v169 = 158;
      _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to generate cryptogram", buf, 0x22u);
    }
    uint64_t v16 = 8;
    uint64_t v50 = v116;
    goto LABEL_127;
  }
  if ([v69 length] != (id)8)
  {
    v153 = v69;
    id v156 = v50;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v127 = NFLogGetLogger();
    if (v127)
    {
      unsigned __int8 v128 = (void (*)(uint64_t, const char *, ...))v127;
      id v129 = object_getClass(a1);
      BOOL v130 = class_isMetaClass(v129);
      int v131 = object_getClassName(a1);
      __int16 v132 = sel_getName("_authorizeContactlessPayment:uid:targetAID:");
      id v149 = [v153 length];
      uint64_t v133 = 45;
      if (v130) {
        uint64_t v133 = 43;
      }
      v128(3, "%c[%{public}s %{public}s]:%i Invalid cryptogram length: %lu", v133, v131, v132, 162, v149);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v94 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
    {
      __int16 v134 = object_getClass(a1);
      if (class_isMetaClass(v134)) {
        int v135 = 43;
      }
      else {
        int v135 = 45;
      }
      __int16 v136 = object_getClassName(a1);
      int v137 = sel_getName("_authorizeContactlessPayment:uid:targetAID:");
      int v69 = v153;
      CFStringRef v138 = (const __CFString *)[v153 length];
      *(_DWORD *)buf = 67110146;
      int v163 = v135;
      __int16 v164 = 2082;
      long long v165 = v136;
      __int16 v166 = 2082;
      long long v167 = v137;
      __int16 v168 = 1024;
      int v169 = 162;
      __int16 v170 = 2048;
      CFStringRef v171 = v138;
      _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid cryptogram length: %lu", buf, 0x2Cu);
      uint64_t v16 = 13;
      uint64_t v15 = 0;
      uint64_t v50 = v156;
      goto LABEL_128;
    }
    uint64_t v16 = 13;
    uint64_t v15 = 0;
LABEL_127:
    int v69 = v153;
LABEL_128:
    id v139 = v154;

    goto LABEL_129;
  }
  uint64_t v16 = sub_1000C5B9C((uint64_t)a1, v158, v69, v8);
  id v71 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284470 length:8];
  id v72 = [a1 selectByName:v71 error:0];

  if (v16 >= 2)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v73 = NFLogGetLogger();
    uint64_t v152 = v69;
    if (v73)
    {
      __int16 v74 = (void (*)(uint64_t, const char *, ...))v73;
      id v75 = object_getClass(a1);
      BOOL v76 = class_isMetaClass(v75);
      int v77 = object_getClassName(a1);
      id v78 = sel_getName("_authorizeContactlessPayment:uid:targetAID:");
      uint64_t v79 = 45;
      if (v76) {
        uint64_t v79 = 43;
      }
      uint64_t v142 = v77;
      int v69 = v152;
      v74(3, "%c[%{public}s %{public}s]:%i Failed to authorize with for type=%d", v79, v142, v78, 172, v158);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v80 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
    {
      NSErrorUserInfoKey v81 = object_getClass(a1);
      id v82 = v50;
      if (class_isMetaClass(v81)) {
        int v83 = 43;
      }
      else {
        int v83 = 45;
      }
      BOOL v84 = object_getClassName(a1);
      NSErrorUserInfoKey v85 = sel_getName("_authorizeContactlessPayment:uid:targetAID:");
      *(_DWORD *)buf = 67110146;
      int v163 = v83;
      uint64_t v50 = v82;
      int v69 = v152;
      __int16 v164 = 2082;
      long long v165 = v84;
      __int16 v166 = 2082;
      long long v167 = v85;
      __int16 v168 = 1024;
      int v169 = 172;
      __int16 v170 = 1024;
      LODWORD(v171) = v158;
      _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to authorize with for type=%d", buf, 0x28u);
    }

    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v86 = NFLogGetLogger();
    if (v86)
    {
      NSErrorUserInfoKey v87 = (void (*)(uint64_t, const char *, ...))v86;
      id v88 = object_getClass(a1);
      BOOL v89 = class_isMetaClass(v88);
      int v90 = object_getClassName(a1);
      __int16 v91 = sel_getName("_authorizeContactlessPayment:uid:targetAID:");
      if (v16 >= 0x47) {
        int v92 = 71;
      }
      else {
        int v92 = v16;
      }
      id v151 = off_100306F98[v92];
      uint64_t v93 = 43;
      if (!v89) {
        uint64_t v93 = 45;
      }
      uint64_t v143 = v90;
      int v69 = v152;
      v87(3, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", v93, v143, v91, 173, @"Returned", v16, v151);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v94 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
    {
      __int16 v95 = object_getClass(a1);
      int v96 = v50;
      if (class_isMetaClass(v95)) {
        int v97 = 43;
      }
      else {
        int v97 = 45;
      }
      uint64_t v98 = object_getClassName(a1);
      NSErrorUserInfoKey v99 = sel_getName("_authorizeContactlessPayment:uid:targetAID:");
      if (v16 >= 0x47) {
        int v100 = 71;
      }
      else {
        int v100 = v16;
      }
      id v101 = off_100306F98[v100];
      *(_DWORD *)buf = 67110658;
      int v163 = v97;
      uint64_t v50 = v96;
      __int16 v164 = 2082;
      long long v165 = v98;
      __int16 v166 = 2082;
      long long v167 = v99;
      __int16 v168 = 1024;
      int v169 = 173;
      __int16 v170 = 2112;
      CFStringRef v171 = @"Returned";
      __int16 v172 = 1024;
      int v173 = v16;
      __int16 v174 = 2080;
      v175 = v101;
      _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", buf, 0x3Cu);
    }
    uint64_t v15 = 0;
    goto LABEL_128;
  }
  id v139 = v154;
  uint64_t v15 = 0;
LABEL_129:

LABEL_130:
LABEL_131:

LABEL_132:
LABEL_133:

  return v16;
}

uint64_t sub_1001F22B8(void *a1, void *a2, uint64_t a3, void *a4, void *a5)
{
  id v9 = a2;
  id v10 = a4;
  id v12 = a5;
  if (a1)
  {
    if (v12) {
      uint64_t v13 = sub_1001F2350(a1, v9, v11, v12);
    }
    else {
      uint64_t v13 = sub_1001F1284(a1, v9, a3, v10);
    }
    uint64_t v14 = v13;
  }
  else
  {
    uint64_t v14 = 0;
  }

  return v14;
}

uint64_t sub_1001F2350(void *a1, void *a2, uint64_t a3, void *a4)
{
  id v6 = a2;
  id v7 = a4;
  if (!a1)
  {
    uint64_t v40 = 0;
    goto LABEL_23;
  }
  double v9 = sub_10026E2FC(v8);
  uint64_t v11 = *(void **)(v10 + 3832);
  id v12 = [a1 serialNumberAsData:v9];
  id v133 = 0;
  uint64_t v13 = [v11 performChainAuthIfNeededForACL:v7 operation:@"se,nfc" auth:v6 seHandle:a1 seid:v12 error:&v133];
  id v14 = v133;

  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v16 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(a1);
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(a1);
    Name = sel_getName("_authorizeContactlessWithOperationApproval:uid:usingACL:");
    uint64_t v20 = 45;
    if (isMetaClass) {
      uint64_t v20 = 43;
    }
    v16(6, "%c[%{public}s %{public}s]:%i Chained Auth required: %d success: %d", v20, ClassName, Name, 207, v13 != 0, v14 == 0);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v21 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v22 = object_getClass(a1);
    if (class_isMetaClass(v22)) {
      int v23 = 43;
    }
    else {
      int v23 = 45;
    }
    int v24 = object_getClassName(a1);
    uint64_t v25 = sel_getName("_authorizeContactlessWithOperationApproval:uid:usingACL:");
    *(_DWORD *)buf = 67110402;
    *(_DWORD *)&uint8_t buf[4] = v23;
    *(_WORD *)__int16 v136 = 2082;
    *(void *)&v136[2] = v24;
    *(_WORD *)&v136[10] = 2082;
    *(void *)&v136[12] = v25;
    *(_WORD *)&v136[20] = 1024;
    *(_DWORD *)&v136[22] = 207;
    *(_WORD *)&v136[26] = 1024;
    *(_DWORD *)&v136[28] = v13 != 0;
    *(_WORD *)&v136[32] = 1024;
    *(_DWORD *)&v136[34] = v14 == 0;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Chained Auth required: %d success: %d", buf, 0x2Eu);
  }

  if (v14)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v26 = NFLogGetLogger();
    if (v26)
    {
      int v27 = (void (*)(uint64_t, const char *, ...))v26;
      BOOL v28 = object_getClass(a1);
      BOOL v29 = class_isMetaClass(v28);
      unsigned __int8 v128 = object_getClassName(a1);
      id v30 = v6;
      int v31 = sel_getName("_authorizeContactlessWithOperationApproval:uid:usingACL:");
      __int16 v32 = [v7 debugDescription];
      uint64_t v109 = v31;
      id v6 = v30;
      uint64_t v33 = 45;
      if (v29) {
        uint64_t v33 = 43;
      }
      v27(3, "%c[%{public}s %{public}s]:%i Failed to performChainAuthIfNeededForACL %@ : %@", v33, v128, v109, 209, v14, v32);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v34 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
    {
      uint64_t v35 = object_getClass(a1);
      if (class_isMetaClass(v35)) {
        int v36 = 43;
      }
      else {
        int v36 = 45;
      }
      int v37 = object_getClassName(a1);
      id v38 = sel_getName("_authorizeContactlessWithOperationApproval:uid:usingACL:");
      BOOL v39 = [v7 debugDescription];
      *(_DWORD *)buf = 67110402;
      *(_DWORD *)&uint8_t buf[4] = v36;
      *(_WORD *)__int16 v136 = 2082;
      *(void *)&v136[2] = v37;
      *(_WORD *)&v136[10] = 2082;
      *(void *)&v136[12] = v38;
      *(_WORD *)&v136[20] = 1024;
      *(_DWORD *)&v136[22] = 209;
      *(_WORD *)&v136[26] = 2112;
      *(void *)&v136[28] = v14;
      *(_WORD *)&v136[36] = 2112;
      int v137 = v39;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to performChainAuthIfNeededForACL %@ : %@", buf, 0x36u);
    }
    uint64_t v40 = 6;
    goto LABEL_22;
  }
  if (v13)
  {
    uint64_t v42 = [v13 resolvedAuthorization];

    id v6 = (id)v42;
  }
  id v132 = 0;
  id v43 = [a1 selectCRSWithError:&v132];
  id v44 = v132;
  if (v44)
  {
    id v14 = v44;
    if ([v44 code]) {
      uint64_t v40 = (uint64_t)[v14 code];
    }
    else {
      uint64_t v40 = 16;
    }
    goto LABEL_22;
  }
  id v134 = 0;
  int v45 = [a1 sendCommandWithClass:128 instruction:250 p1:1 p2:0 data:0 error:&v134];
  id v46 = v134;
  if ([v45 status] == 36864)
  {
    BOOL v47 = [v45 response];
    id v48 = 0;
  }
  else
  {
    id v129 = v46;
    id v123 = objc_alloc((Class)NSError);
    long long v119 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v138 = NSLocalizedDescriptionKey;
    long long v121 = +[NSString stringWithUTF8String:"Commmand Error"];
    *(void *)buf = v121;
    *(void *)__int16 v136 = &off_10031F6C0;
    CFStringRef v139 = @"Line";
    CFStringRef v140 = @"Method";
    id v125 = v6;
    id v49 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_crs_GetOperationApprovalNonce:")];
    *(void *)&v136[8] = v49;
    NSErrorUserInfoKey v141 = NSDebugDescriptionErrorKey;
    id v50 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_crs_GetOperationApprovalNonce:"), 261];
    *(void *)&v136[16] = v50;
    NSErrorUserInfoKey v142 = NSLocalizedFailureReasonErrorKey;
    id v51 = [objc_alloc((Class)NSString) initWithFormat:@"Failed to GetNonce 0x%X", [v45 status]];
    *(void *)&v136[24] = v51;
    int v52 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v138 count:5];
    id v48 = [v123 initWithDomain:v119 code:16 userInfo:v52];

    id v46 = v129;
    id v6 = v125;

    BOOL v47 = 0;
  }

  id v14 = v48;
  BOOL v130 = v47;
  if (v14 || !v47)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v73 = NFLogGetLogger();
    if (v73)
    {
      __int16 v74 = (void (*)(uint64_t, const char *, ...))v73;
      id v75 = object_getClass(a1);
      BOOL v76 = class_isMetaClass(v75);
      BOOL v105 = object_getClassName(a1);
      uint64_t v110 = sel_getName("_authorizeContactlessWithOperationApproval:uid:usingACL:");
      uint64_t v77 = 45;
      if (v76) {
        uint64_t v77 = 43;
      }
      v74(3, "%c[%{public}s %{public}s]:%i Failed to GetOperationApprovalNonce - %@", v77, v105, v110, 225, v14);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v78 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
    {
      uint64_t v79 = object_getClass(a1);
      if (class_isMetaClass(v79)) {
        int v80 = 43;
      }
      else {
        int v80 = 45;
      }
      NSErrorUserInfoKey v81 = object_getClassName(a1);
      id v82 = sel_getName("_authorizeContactlessWithOperationApproval:uid:usingACL:");
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)&uint8_t buf[4] = v80;
      *(_WORD *)__int16 v136 = 2082;
      *(void *)&v136[2] = v81;
      *(_WORD *)&v136[10] = 2082;
      *(void *)&v136[12] = v82;
      *(_WORD *)&v136[20] = 1024;
      *(_DWORD *)&v136[22] = 225;
      *(_WORD *)&v136[26] = 2112;
      *(void *)&v136[28] = v14;
      _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to GetOperationApprovalNonce - %@", buf, 0x2Cu);
    }

    BOOL v47 = v130;
    if ([v14 code]) {
      uint64_t v40 = (uint64_t)[v14 code];
    }
    else {
      uint64_t v40 = 16;
    }
    goto LABEL_88;
  }
  id v53 = [a1 serialNumberAsData];
  id v131 = 0;
  uint64_t v54 = sub_100220D84((uint64_t)NFSSEWrapper, @"se,nfc", v6, v47, v53, v7, &v131);
  id v14 = v131;

  int v124 = (void *)v54;
  if (v54)
  {
    id v134 = 0;
    LOBYTE(v104) = 1;
    double v55 = [a1 sendCommandWithClass:128 instruction:250 p1:2 p2:0 data:v54 expectedLength:0 toOS:0 useExtendedLength:v104 error:&v134];
    id v120 = v134;
    id v56 = v14;
    unsigned int v122 = [v55 status];
    if (v122 != 36864)
    {
      long long v118 = v55;
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v57 = NFLogGetLogger();
      if (v57)
      {
        uint64_t v58 = (void (*)(uint64_t, const char *, ...))v57;
        int v59 = object_getClass(a1);
        BOOL v60 = class_isMetaClass(v59);
        id v126 = object_getClassName(a1);
        double v61 = sel_getName("_crs_SendOperationApproval:error:");
        uint64_t v113 = [v118 status];
        uint64_t v62 = 45;
        if (v60) {
          uint64_t v62 = 43;
        }
        v58(3, "%c[%{public}s %{public}s]:%i SE rejected OperationApproval with 0x%X", v62, v126, v61, 281, v113);
      }
      id v127 = v6;
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v63 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
      {
        int v64 = object_getClass(a1);
        if (class_isMetaClass(v64)) {
          int v65 = 43;
        }
        else {
          int v65 = 45;
        }
        id v66 = object_getClassName(a1);
        __int16 v67 = sel_getName("_crs_SendOperationApproval:error:");
        unsigned int v68 = [v118 status];
        *(_DWORD *)buf = 67110146;
        *(_DWORD *)&uint8_t buf[4] = v65;
        *(_WORD *)__int16 v136 = 2082;
        *(void *)&v136[2] = v66;
        *(_WORD *)&v136[10] = 2082;
        *(void *)&v136[12] = v67;
        *(_WORD *)&v136[20] = 1024;
        *(_DWORD *)&v136[22] = 281;
        *(_WORD *)&v136[26] = 1024;
        *(_DWORD *)&v136[28] = v68;
        _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i SE rejected OperationApproval with 0x%X", buf, 0x28u);
      }

      id v69 = objc_alloc((Class)NSError);
      BOOL v116 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v138 = NSLocalizedDescriptionKey;
      uint64_t v117 = +[NSString stringWithUTF8String:"Commmand Error"];
      *(void *)buf = v117;
      *(void *)__int16 v136 = &off_10031F6D8;
      CFStringRef v139 = @"Line";
      CFStringRef v140 = @"Method";
      id v115 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_crs_SendOperationApproval:error:")];
      *(void *)&v136[8] = v115;
      NSErrorUserInfoKey v141 = NSDebugDescriptionErrorKey;
      id v114 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_crs_SendOperationApproval:error:"), 283];
      *(void *)&v136[16] = v114;
      NSErrorUserInfoKey v142 = NSLocalizedFailureReasonErrorKey;
      double v55 = v118;
      id v70 = [objc_alloc((Class)NSString) initWithFormat:@"Failed to send OA 0x%hx", [v118 status]];
      *(void *)&v136[24] = v70;
      id v71 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v138 count:5];
      id v56 = [v69 initWithDomain:v116 code:16 userInfo:v71];

      id v6 = v127;
      BOOL v47 = v130;
    }

    id v72 = v56;
    if (v122 == 36864)
    {
      uint64_t v40 = 0;
LABEL_86:
      id v14 = v72;
      goto LABEL_87;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v94 = NFLogGetLogger();
    if (v94)
    {
      __int16 v95 = (void (*)(uint64_t, const char *, ...))v94;
      int v96 = object_getClass(a1);
      BOOL v97 = class_isMetaClass(v96);
      v107 = object_getClassName(a1);
      int v112 = sel_getName("_authorizeContactlessWithOperationApproval:uid:usingACL:");
      BOOL v87 = !v97;
      BOOL v47 = v130;
      uint64_t v98 = 45;
      if (!v87) {
        uint64_t v98 = 43;
      }
      v95(3, "%c[%{public}s %{public}s]:%i SE doesn't like SignedOperationApproval : %@", v98, v107, v112, 244, v72);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    NSErrorUserInfoKey v99 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v99, OS_LOG_TYPE_ERROR))
    {
      int v100 = object_getClass(a1);
      if (class_isMetaClass(v100)) {
        int v101 = 43;
      }
      else {
        int v101 = 45;
      }
      uint64_t v102 = object_getClassName(a1);
      id v103 = sel_getName("_authorizeContactlessWithOperationApproval:uid:usingACL:");
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)&uint8_t buf[4] = v101;
      *(_WORD *)__int16 v136 = 2082;
      *(void *)&v136[2] = v102;
      BOOL v47 = v130;
      *(_WORD *)&v136[10] = 2082;
      *(void *)&v136[12] = v103;
      *(_WORD *)&v136[20] = 1024;
      *(_DWORD *)&v136[22] = 244;
      *(_WORD *)&v136[26] = 2112;
      *(void *)&v136[28] = v72;
      _os_log_impl((void *)&_mh_execute_header, v99, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i SE doesn't like SignedOperationApproval : %@", buf, 0x2Cu);
    }

    if (![v72 code])
    {
      uint64_t v40 = 6;
      goto LABEL_86;
    }
    id v14 = v72;
  }
  else
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v83 = NFLogGetLogger();
    if (v83)
    {
      BOOL v84 = (void (*)(uint64_t, const char *, ...))v83;
      NSErrorUserInfoKey v85 = object_getClass(a1);
      BOOL v86 = class_isMetaClass(v85);
      id v106 = object_getClassName(a1);
      char v111 = sel_getName("_authorizeContactlessWithOperationApproval:uid:usingACL:");
      BOOL v87 = !v86;
      BOOL v47 = v130;
      uint64_t v88 = 45;
      if (!v87) {
        uint64_t v88 = 43;
      }
      v84(3, "%c[%{public}s %{public}s]:%i Failed to get SignedOperationApproval from SEP: %@", v88, v106, v111, 237, v14);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    BOOL v89 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
    {
      int v90 = object_getClass(a1);
      if (class_isMetaClass(v90)) {
        int v91 = 43;
      }
      else {
        int v91 = 45;
      }
      int v92 = object_getClassName(a1);
      uint64_t v93 = sel_getName("_authorizeContactlessWithOperationApproval:uid:usingACL:");
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)&uint8_t buf[4] = v91;
      *(_WORD *)__int16 v136 = 2082;
      *(void *)&v136[2] = v92;
      BOOL v47 = v130;
      *(_WORD *)&v136[10] = 2082;
      *(void *)&v136[12] = v93;
      *(_WORD *)&v136[20] = 1024;
      *(_DWORD *)&v136[22] = 237;
      *(_WORD *)&v136[26] = 2112;
      *(void *)&v136[28] = v14;
      _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get SignedOperationApproval from SEP: %@", buf, 0x2Cu);
    }

    if (![v14 code])
    {
      uint64_t v40 = 6;
      goto LABEL_87;
    }
    id v72 = v14;
  }
  uint64_t v40 = (uint64_t)[v72 code];
LABEL_87:

LABEL_88:
LABEL_22:

LABEL_23:
  return v40;
}

uint64_t sub_1001F3198(void *a1)
{
  uint64_t v1 = (uint64_t)a1;
  if (a1)
  {
    id v7 = 0;
    id v2 = [a1 selectCRSWithError:&v7];
    id v3 = v7;
    long long v4 = v3;
    if (v3)
    {
      if ([v3 code]) {
        uint64_t v1 = (uint64_t)[v4 code];
      }
      else {
        uint64_t v1 = 16;
      }
    }
    else
    {
      sub_1000C7830((void *)v1);
      id v5 = [(id)v1 globalUnmountCOX];
      uint64_t v1 = 0;
    }
  }
  return v1;
}

id sub_1001F3234(void *a1)
{
  id v1 = a1;
  unint64_t v2 = (unint64_t)[v1 length];
  int v12 = 324736;
  char v11 = 0;
  id v3 = [objc_alloc((Class)NSMutableData) initWithCapacity:v2 + 7];
  [v3 appendBytes:&v12 length:4];
  if (v2 <= 0xFF)
  {
    char v10 = v2;
    long long v4 = &v10;
    id v5 = v3;
    uint64_t v6 = 1;
LABEL_5:
    [v5 appendBytes:v4 length:v6];
    [v3 appendData:v1];
    [v3 appendBytes:&v11 length:1];
    id v7 = v3;
    goto LABEL_7;
  }
  if (!(v2 >> 16))
  {
    v9[0] = 0;
    v9[1] = BYTE1(v2);
    id v9[2] = v2;
    long long v4 = v9;
    id v5 = v3;
    uint64_t v6 = 3;
    goto LABEL_5;
  }
  id v7 = 0;
LABEL_7:

  return v7;
}

uint64_t sub_1001F3330(void *a1, void *a2, NSObject **a3, _DWORD *a4)
{
  id v7 = a2;
  *a3 = 0;
  if (!a4)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v16 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("sendEcommerceAPDU:response:swStatus:");
      uint64_t v20 = 45;
      if (isMetaClass) {
        uint64_t v20 = 43;
      }
      v16(3, "%c[%{public}s %{public}s]:%i Invalid swStatus parameter", v20, ClassName, Name, 343);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    char v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      int v21 = object_getClass(a1);
      if (class_isMetaClass(v21)) {
        int v22 = 43;
      }
      else {
        int v22 = 45;
      }
      *(_DWORD *)buf = 67109890;
      int v78 = v22;
      __int16 v79 = 2082;
      int v80 = object_getClassName(a1);
      __int16 v81 = 2082;
      id v82 = sel_getName("sendEcommerceAPDU:response:swStatus:");
      __int16 v83 = 1024;
      int v84 = 343;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid swStatus parameter", buf, 0x22u);
    }
    uint64_t v14 = 10;
    goto LABEL_86;
  }
  double v8 = NFSharedSignpostLog();
  if (os_signpost_enabled(v8))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEND_ECOMMERCE_APDU", "transceiveData in", buf, 2u);
  }

  id v76 = 0;
  double v9 = [a1 transceiveData:v7 toOS:0 error:&v76];
  char v10 = v76;
  char v11 = NFSharedSignpostLog();
  if (os_signpost_enabled(v11))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v11, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEND_ECOMMERCE_APDU", "transceiveData out", buf, 2u);
  }

  if (!v9)
  {
    *a4 = 0;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v23 = NFLogGetLogger();
    if (v23)
    {
      int v24 = (void (*)(uint64_t, const char *, ...))v23;
      uint64_t v25 = object_getClass(a1);
      BOOL v26 = class_isMetaClass(v25);
      int v27 = object_getClassName(a1);
      id v69 = sel_getName("sendEcommerceAPDU:response:swStatus:");
      uint64_t v28 = 45;
      if (v26) {
        uint64_t v28 = 43;
      }
      v24(3, "%c[%{public}s %{public}s]:%i Failed send APDU to SE", v28, v27, v69, 353);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    BOOL v29 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      id v30 = object_getClass(a1);
      if (class_isMetaClass(v30)) {
        int v31 = 43;
      }
      else {
        int v31 = 45;
      }
      __int16 v32 = object_getClassName(a1);
      uint64_t v33 = sel_getName("sendEcommerceAPDU:response:swStatus:");
      *(_DWORD *)buf = 67109890;
      int v78 = v31;
      __int16 v79 = 2082;
      int v80 = v32;
      __int16 v81 = 2082;
      id v82 = v33;
      __int16 v83 = 1024;
      int v84 = 353;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed send APDU to SE", buf, 0x22u);
    }

    if ([v10 code]) {
      uint64_t v14 = (uint64_t)[v10 code];
    }
    else {
      uint64_t v14 = 16;
    }
    goto LABEL_85;
  }
  uint64_t v73 = v9;
  int v12 = +[NFResponseAPDU responseWithData:v9];
  *a4 = [v12 status];
  if ([v12 status] == 36864)
  {
    *a3 = [v12 response];
    uint64_t v13 = NFSharedSignpostLog();
    if (os_signpost_enabled(v13))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEND_ECOMMERCE_APDU", "done", buf, 2u);
    }
    uint64_t v14 = 0;
    goto LABEL_84;
  }
  id v72 = v7;
  __int16 v74 = objc_opt_new();
  __int16 v34 = v12;
  uint64_t v35 = v10;
  while (1)
  {
    if (([v34 status] & 0xFF00) != 0x6100)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v42 = NFLogGetLogger();
      if (v42)
      {
        id v43 = (void (*)(uint64_t, const char *, ...))v42;
        id v44 = object_getClass(a1);
        BOOL v45 = class_isMetaClass(v44);
        id v46 = object_getClassName(a1);
        BOOL v47 = sel_getName("sendEcommerceAPDU:response:swStatus:");
        uint64_t v71 = [v34 status];
        uint64_t v48 = 45;
        if (v45) {
          uint64_t v48 = 43;
        }
        v43(3, "%c[%{public}s %{public}s]:%i Returned error: 0x%04x", v48, v46, v47, 398, v71);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v49 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
      {
        id v50 = object_getClass(a1);
        if (class_isMetaClass(v50)) {
          int v51 = 43;
        }
        else {
          int v51 = 45;
        }
        int v52 = object_getClassName(a1);
        id v53 = sel_getName("sendEcommerceAPDU:response:swStatus:");
        unsigned int v54 = [v34 status];
        *(_DWORD *)buf = 67110146;
        int v78 = v51;
        __int16 v79 = 2082;
        int v80 = v52;
        __int16 v81 = 2082;
        id v82 = v53;
        __int16 v83 = 1024;
        int v84 = 398;
        __int16 v85 = 1024;
        unsigned int v86 = v54;
        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Returned error: 0x%04x", buf, 0x28u);
      }

      if ([v34 status] == 27010)
      {
        uint64_t v14 = 8;
        uint64_t v13 = v74;
      }
      else
      {
        uint64_t v13 = v74;
        if ([v34 status] == 27013)
        {
          uint64_t v14 = 8;
        }
        else if ([v34 status] == 27265)
        {
          uint64_t v14 = 14;
        }
        else if ([v34 status] == 27012)
        {
          uint64_t v14 = 23;
        }
        else if ([v34 status] == 27264)
        {
          uint64_t v14 = 10;
        }
        else if ([v34 status] == 27272 {
               || [v34 status] == 27015)
        }
        {
          uint64_t v14 = 9;
        }
        else
        {
          uint64_t v14 = 6;
        }
      }
      id v66 = NFSharedSignpostLog();
      if (os_signpost_enabled(v66))
      {
        *(_DWORD *)buf = 67109120;
        int v78 = v14;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v66, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEND_ECOMMERCE_APDU", "done - error: %d", buf, 8u);
      }

      int v12 = v34;
      char v10 = v35;
      goto LABEL_83;
    }
    int v36 = [v34 response];
    [v74 appendData:v36];

    int v37 = NFSharedSignpostLog();
    if (os_signpost_enabled(v37))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v37, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEND_ECOMMERCE_APDU", "reading extra RADPU", buf, 2u);
    }

    unsigned __int8 v38 = [v34 status];
    id v75 = v35;
    int v12 = [a1 sendCommandWithClass:128 instruction:192 p1:0 p2:0 data:0 expectedLength:v38 toOS:0 error:&v75];
    char v10 = v75;

    BOOL v39 = NFSharedSignpostLog();
    if (os_signpost_enabled(v39))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v39, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEND_ECOMMERCE_APDU", "reading extra RADPU done", buf, 2u);
    }

    if (!v12) {
      break;
    }
    *a4 = [v12 status];
    __int16 v34 = v12;
    uint64_t v35 = v10;
    if ([v12 status] == 36864)
    {
      uint64_t v40 = [v12 response];
      [v74 appendData:v40];

      uint64_t v13 = v74;
      *a3 = v13;
      unint64_t v41 = NFSharedSignpostLog();
      if (os_signpost_enabled(v41))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v41, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEND_ECOMMERCE_APDU", "done", buf, 2u);
      }

      uint64_t v14 = 0;
LABEL_83:
      id v7 = v72;
      goto LABEL_84;
    }
  }
  *a4 = 0;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v55 = NFLogGetLogger();
  if (v55)
  {
    id v56 = (void (*)(uint64_t, const char *, ...))v55;
    uint64_t v57 = object_getClass(a1);
    BOOL v58 = class_isMetaClass(v57);
    int v59 = object_getClassName(a1);
    id v70 = sel_getName("sendEcommerceAPDU:response:swStatus:");
    uint64_t v60 = 45;
    if (v58) {
      uint64_t v60 = 43;
    }
    v56(3, "%c[%{public}s %{public}s]:%i Command failed", v60, v59, v70, 384);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  double v61 = NFSharedLogGetLogger();
  id v7 = v72;
  if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
  {
    uint64_t v62 = object_getClass(a1);
    if (class_isMetaClass(v62)) {
      int v63 = 43;
    }
    else {
      int v63 = 45;
    }
    int v64 = object_getClassName(a1);
    int v65 = sel_getName("sendEcommerceAPDU:response:swStatus:");
    *(_DWORD *)buf = 67109890;
    int v78 = v63;
    __int16 v79 = 2082;
    int v80 = v64;
    __int16 v81 = 2082;
    id v82 = v65;
    __int16 v83 = 1024;
    int v84 = 384;
    _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Command failed", buf, 0x22u);
  }

  int v12 = 0;
  if ([v10 code]) {
    uint64_t v14 = (uint64_t)[v10 code];
  }
  else {
    uint64_t v14 = 16;
  }
  uint64_t v13 = v74;
LABEL_84:

  double v9 = v73;
LABEL_85:

LABEL_86:
  return v14;
}

void sub_1001F3D88(void *a1, void *a2, void *a3, uint64_t *a4, uint64_t a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = v9;
  int v12 = (unsigned __int8 *)[v11 bytes];
  if (v12 && (uint64_t v13 = v12, (unint64_t)[v11 length] >= 4))
  {
    uint64_t v14 = v13[3];
    if (v14 > 7)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        BOOL v26 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("postCACRSAuth:request:response:status:");
        uint64_t v29 = 45;
        if (isMetaClass) {
          uint64_t v29 = 43;
        }
        v26(6, "%c[%{public}s %{public}s]:%i Failed to post CA as we have an invalid Validation Type %d", v29, ClassName, Name, 442, v14);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v30 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        int v31 = object_getClass(a1);
        if (class_isMetaClass(v31)) {
          int v32 = 43;
        }
        else {
          int v32 = 45;
        }
        *(_DWORD *)buf = 67110146;
        int v37 = v32;
        __int16 v38 = 2082;
        BOOL v39 = object_getClassName(a1);
        __int16 v40 = 2082;
        unint64_t v41 = sel_getName("postCACRSAuth:request:response:status:");
        __int16 v42 = 1024;
        int v43 = 442;
        __int16 v44 = 1024;
        LODWORD(v45) = v14;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Failed to post CA as we have an invalid Validation Type %d", buf, 0x28u);
      }
    }
    else
    {
      sub_1000C73B0(a1, v14, v10, *a4, a5);
    }
  }
  else
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v15 = NFLogGetLogger();
    if (v15)
    {
      uint64_t v16 = (void (*)(uint64_t, const char *, ...))v15;
      uint64_t v17 = object_getClass(a1);
      BOOL v18 = class_isMetaClass(v17);
      __int16 v19 = object_getClassName(a1);
      uint64_t v20 = sel_getName("postCACRSAuth:request:response:status:");
      id v35 = [v11 length];
      uint64_t v21 = 45;
      if (v18) {
        uint64_t v21 = 43;
      }
      v16(6, "%c[%{public}s %{public}s]:%i Failed to post CA as we have an invalid APDU buffer with length %lu", v21, v19, v20, 445, v35);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v22 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v23 = object_getClass(a1);
      if (class_isMetaClass(v23)) {
        int v24 = 43;
      }
      else {
        int v24 = 45;
      }
      *(_DWORD *)buf = 67110146;
      int v37 = v24;
      __int16 v38 = 2082;
      BOOL v39 = object_getClassName(a1);
      __int16 v40 = 2082;
      unint64_t v41 = sel_getName("postCACRSAuth:request:response:status:");
      __int16 v42 = 1024;
      int v43 = 445;
      __int16 v44 = 2048;
      id v45 = [v11 length];
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Failed to post CA as we have an invalid APDU buffer with length %lu", buf, 0x2Cu);
    }
  }
}

id sub_1001F40E0(NFECommercePaymentResponse *a1, void *a2, uint64_t a3, void *a4, uint64_t *a5)
{
  id v9 = a2;
  id v10 = a4;
  if (a1)
  {
    id v11 = NFSharedSignpostLog();
    if (os_signpost_enabled(v11))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v11, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "AUTH_ECOMMERCE", "begin", buf, 2u);
    }

    v394 = v10;
    if (!v9)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        uint64_t v20 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
        uint64_t v24 = 45;
        if (isMetaClass) {
          uint64_t v24 = 43;
        }
        v20(3, "%c[%{public}s %{public}s]:%i Missing SSE handle", v24, ClassName, Name, 460);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v25 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        BOOL v26 = object_getClass(a1);
        if (class_isMetaClass(v26)) {
          int v27 = 43;
        }
        else {
          int v27 = 45;
        }
        uint64_t v28 = object_getClassName(a1);
        uint64_t v29 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
        *(_DWORD *)buf = 67109890;
        int v431 = v27;
        __int16 v432 = 2082;
        v433 = v28;
        __int16 v434 = 2082;
        v435 = v29;
        __int16 v436 = 1024;
        int v437 = 460;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Missing SSE handle", buf, 0x22u);
      }

      id v30 = objc_alloc((Class)NSError);
      id v14 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v456 = NSLocalizedDescriptionKey;
      id v31 = +[NSString stringWithUTF8String:"Missing Parameter"];
      id v457 = v31;
      id v32 = +[NSDictionary dictionaryWithObjects:&v457 forKeys:&v456 count:1];
      id v18 = [v30 initWithDomain:v14 code:9 userInfo:v32];
      goto LABEL_52;
    }
    kdebug_trace();
    int v12 = NFSharedSignpostLog();
    if (os_signpost_enabled(v12))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v12, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseGetHostChallenge in", buf, 2u);
    }

    id v409 = 0;
    unsigned int v13 = sub_10021F7F0((uint64_t)NFSSEWrapper, &v409);
    id v14 = v409;
    kdebug_trace();
    uint64_t v15 = NFSharedSignpostLog();
    if (os_signpost_enabled(v15))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseGetHostChallenge out", buf, 2u);
    }

    if (!v14 || v13)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v33 = NFLogGetLogger();
      if (v33)
      {
        __int16 v34 = (void (*)(uint64_t, const char *, ...))v33;
        id v35 = object_getClass(a1);
        BOOL v36 = class_isMetaClass(v35);
        int v37 = object_getClassName(a1);
        v345 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
        uint64_t v38 = 45;
        if (v36) {
          uint64_t v38 = 43;
        }
        v34(3, "%c[%{public}s %{public}s]:%i Failed to get host challenge", v38, v37, v345, 473);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      BOOL v39 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
      {
        __int16 v40 = object_getClass(a1);
        if (class_isMetaClass(v40)) {
          int v41 = 43;
        }
        else {
          int v41 = 45;
        }
        __int16 v42 = object_getClassName(a1);
        int v43 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
        *(_DWORD *)buf = 67109890;
        int v431 = v41;
        __int16 v432 = 2082;
        v433 = v42;
        __int16 v434 = 2082;
        v435 = v43;
        __int16 v436 = 1024;
        int v437 = 473;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get host challenge", buf, 0x22u);
      }

      id v44 = objc_alloc((Class)NSError);
      id v31 = +[NSString stringWithUTF8String:"nfcd"];
      if (v13)
      {
        uint64_t v45 = v13;
        NSErrorUserInfoKey v452 = NSLocalizedDescriptionKey;
        if (v13 >= 0x47) {
          int v46 = 71;
        }
        else {
          int v46 = v13;
        }
        id v32 = +[NSString stringWithUTF8String:off_100306F98[v46]];
        id v453 = v32;
        id v47 = +[NSDictionary dictionaryWithObjects:&v453 forKeys:&v452 count:1];
        uint64_t v48 = v44;
        id v49 = v31;
        uint64_t v50 = v45;
      }
      else
      {
        NSErrorUserInfoKey v454 = NSLocalizedDescriptionKey;
        id v32 = +[NSString stringWithUTF8String:"Unknown Error"];
        id v455 = v32;
        id v47 = +[NSDictionary dictionaryWithObjects:&v455 forKeys:&v454 count:1];
        uint64_t v48 = v44;
        id v49 = v31;
        uint64_t v50 = 6;
      }
    }
    else
    {
      if ([v14 length] == (id)8)
      {
        id v408 = 0;
        id v16 = [(NFECommercePaymentResponse *)a1 selectCRSWithError:&v408];
        id v17 = v408;
        if (v17)
        {
          id v18 = v17;
LABEL_53:

          goto LABEL_54;
        }
        kdebug_trace();
        unsigned int v68 = NFSharedSignpostLog();
        if (os_signpost_enabled(v68))
        {
          *(_WORD *)buf = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v68, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "acmGetOlsoType in", buf, 2u);
        }

        uint64_t v69 = sub_1002200C0((uint64_t)NFSSEWrapper, v9);
        kdebug_trace();
        id v70 = NFSharedSignpostLog();
        if (os_signpost_enabled(v70))
        {
          *(_WORD *)buf = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v70, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "acmGetOlsoType out", buf, 2u);
        }

        char v71 = 0;
        int v72 = 1;
        int v73 = 3;
        switch((int)v69)
        {
          case 1:
            char v71 = 0;
            int v72 = 0;
            goto LABEL_104;
          case 2:
            int v84 = [v10 appletIdentifier];
            __int16 v85 = +[NSData NF_dataWithHexString:v84];

            id v31 = v85;
            unsigned int v86 = [v31 bytes];
            if (*(_DWORD *)v86 == 50331808 && v86[4] == 51)
            {

              int v72 = 0;
              int v73 = 5;
              char v71 = 1;
              goto LABEL_104;
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v88 = NFLogGetLogger();
            if (v88)
            {
              BOOL v89 = (void (*)(uint64_t, const char *, ...))v88;
              int v90 = object_getClass(a1);
              BOOL v91 = class_isMetaClass(v90);
              v385 = object_getClassName(a1);
              int v92 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
              uint64_t v93 = [v394 appletIdentifier];
              uint64_t v94 = 45;
              if (v91) {
                uint64_t v94 = 43;
              }
              v89(3, "%c[%{public}s %{public}s]:%i PIN not supported on %{public}@", v94, v385, v92, 514, v93);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            __int16 v95 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v95, OS_LOG_TYPE_ERROR))
            {
              int v96 = object_getClass(a1);
              if (class_isMetaClass(v96)) {
                int v97 = 43;
              }
              else {
                int v97 = 45;
              }
              uint64_t v98 = object_getClassName(a1);
              NSErrorUserInfoKey v99 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
              int v100 = [v394 appletIdentifier];
              *(_DWORD *)buf = 67110146;
              int v431 = v97;
              __int16 v432 = 2082;
              v433 = v98;
              __int16 v434 = 2082;
              v435 = v99;
              __int16 v436 = 1024;
              int v437 = 514;
              __int16 v438 = 2114;
              CFStringRef v439 = v100;
              _os_log_impl((void *)&_mh_execute_header, v95, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i PIN not supported on %{public}@", buf, 0x2Cu);
            }
            id v101 = objc_alloc((Class)NSError);
            id v32 = +[NSString stringWithUTF8String:"nfcd"];
            NSErrorUserInfoKey v446 = NSLocalizedDescriptionKey;
            id v47 = +[NSString stringWithUTF8String:"Feature Not Supported"];
            id v447 = v47;
            uint64_t v102 = &v447;
            id v103 = &v446;
            goto LABEL_101;
          case 3:
          case 5:
            goto LABEL_104;
          case 4:
            uint64_t v104 = [v10 appletIdentifier];
            BOOL v105 = +[NSData NF_dataWithHexString:v104];

            id v31 = v105;
            id v106 = [v31 bytes];
            if (*(_DWORD *)v106 != 50331808 || v106[4] != 51)
            {
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v108 = NFLogGetLogger();
              if (v108)
              {
                uint64_t v109 = (void (*)(uint64_t, const char *, ...))v108;
                uint64_t v110 = object_getClass(a1);
                BOOL v111 = class_isMetaClass(v110);
                v386 = object_getClassName(a1);
                int v112 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
                uint64_t v113 = [v394 appletIdentifier];
                uint64_t v114 = 45;
                if (v111) {
                  uint64_t v114 = 43;
                }
                v109(3, "%c[%{public}s %{public}s]:%i PIN not supported on %{public}@", v114, v386, v112, 502, v113);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              id v115 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v115, OS_LOG_TYPE_ERROR))
              {
                BOOL v116 = object_getClass(a1);
                if (class_isMetaClass(v116)) {
                  int v117 = 43;
                }
                else {
                  int v117 = 45;
                }
                long long v118 = object_getClassName(a1);
                long long v119 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
                id v120 = [v394 appletIdentifier];
                *(_DWORD *)buf = 67110146;
                int v431 = v117;
                __int16 v432 = 2082;
                v433 = v118;
                __int16 v434 = 2082;
                v435 = v119;
                __int16 v436 = 1024;
                int v437 = 502;
                __int16 v438 = 2114;
                CFStringRef v439 = v120;
                _os_log_impl((void *)&_mh_execute_header, v115, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i PIN not supported on %{public}@", buf, 0x2Cu);
              }
              id v101 = objc_alloc((Class)NSError);
              id v32 = +[NSString stringWithUTF8String:"nfcd"];
              NSErrorUserInfoKey v448 = NSLocalizedDescriptionKey;
              id v47 = +[NSString stringWithUTF8String:"Feature Not Supported"];
              id v449 = v47;
              uint64_t v102 = &v449;
              id v103 = &v448;
LABEL_101:
              long long v121 = +[NSDictionary dictionaryWithObjects:v102 forKeys:v103 count:1];
              id v18 = [v101 initWithDomain:v32 code:14 userInfo:v121];

              goto LABEL_51;
            }

            int v73 = 5;
            char v71 = 1;
            int v72 = 1;
LABEL_104:
            int v387 = v73;
            char v378 = v71;
            unsigned int v382 = v72;
            unsigned int v122 = NFSharedSignpostLog();
            if (os_signpost_enabled(v122))
            {
              *(_WORD *)buf = 0;
              _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v122, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "AUTH_ECOMMERCE", "crs_authenticate in", buf, 2u);
            }

            id v407 = 0;
            uint64_t v123 = sub_1000C5684(a1, v14, &v407);
            id v32 = v407;
            int v124 = NFSharedSignpostLog();
            if (os_signpost_enabled(v124))
            {
              *(_WORD *)buf = 0;
              _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v124, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "AUTH_ECOMMERCE", "crs_authenticate out", buf, 2u);
            }

            if (v123)
            {
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v125 = NFLogGetLogger();
              if (v125)
              {
                id v126 = (void (*)(uint64_t, const char *, ...))v125;
                id v127 = object_getClass(a1);
                BOOL v128 = class_isMetaClass(v127);
                id v129 = object_getClassName(a1);
                BOOL v130 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
                if (v123 >= 0x47) {
                  int v131 = 71;
                }
                else {
                  int v131 = v123;
                }
                v358 = off_100306F98[v131];
                uint64_t v132 = 43;
                if (!v128) {
                  uint64_t v132 = 45;
                }
                v126(3, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", v132, v129, v130, 541, @"Failed to authenticate", v123, v358);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              id v133 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v133, OS_LOG_TYPE_ERROR))
              {
                id v134 = object_getClass(a1);
                if (class_isMetaClass(v134)) {
                  int v135 = 43;
                }
                else {
                  int v135 = 45;
                }
                __int16 v136 = object_getClassName(a1);
                int v137 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
                if (v123 >= 0x47) {
                  uint64_t v138 = 71;
                }
                else {
                  uint64_t v138 = v123;
                }
                CFStringRef v139 = off_100306F98[v138];
                *(_DWORD *)buf = 67110658;
                int v431 = v135;
                __int16 v432 = 2082;
                v433 = v136;
                __int16 v434 = 2082;
                v435 = v137;
                __int16 v436 = 1024;
                int v437 = 541;
                __int16 v438 = 2112;
                CFStringRef v439 = @"Failed to authenticate";
                __int16 v440 = 1024;
                int v441 = v123;
                __int16 v442 = 2080;
                v443 = v139;
                _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", buf, 0x3Cu);
              }
              else if (v123 >= 0x47)
              {
                uint64_t v138 = 71;
              }
              else
              {
                uint64_t v138 = v123;
              }

              id v156 = objc_alloc((Class)NSError);
              id v47 = +[NSString stringWithUTF8String:"nfcd"];
              NSErrorUserInfoKey v428 = NSLocalizedDescriptionKey;
              id v157 = +[NSString stringWithUTF8String:off_100306F98[v138]];
              v429 = v157;
              unsigned __int8 v158 = +[NSDictionary dictionaryWithObjects:&v429 forKeys:&v428 count:1];
              id v18 = [v156 initWithDomain:v47 code:v123 userInfo:v158];

              id v31 = 0;
              goto LABEL_300;
            }
            if ([v32 length] != (id)16)
            {
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v159 = NFLogGetLogger();
              if (v159)
              {
                id v160 = (void (*)(uint64_t, const char *, ...))v159;
                id v161 = object_getClass(a1);
                BOOL v162 = class_isMetaClass(v161);
                int v163 = object_getClassName(a1);
                __int16 v164 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
                id v356 = [v32 length];
                uint64_t v165 = 45;
                if (v162) {
                  uint64_t v165 = 43;
                }
                v160(3, "%c[%{public}s %{public}s]:%i Invalid authenticate response length: %lu", v165, v163, v164, 545, v356);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              __int16 v166 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v166, OS_LOG_TYPE_ERROR))
              {
                long long v167 = object_getClass(a1);
                if (class_isMetaClass(v167)) {
                  int v168 = 43;
                }
                else {
                  int v168 = 45;
                }
                int v169 = object_getClassName(a1);
                __int16 v170 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
                CFStringRef v171 = (const __CFString *)[v32 length];
                *(_DWORD *)buf = 67110146;
                int v431 = v168;
                __int16 v432 = 2082;
                v433 = v169;
                __int16 v434 = 2082;
                v435 = v170;
                __int16 v436 = 1024;
                int v437 = 545;
                __int16 v438 = 2048;
                CFStringRef v439 = v171;
                _os_log_impl((void *)&_mh_execute_header, v166, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid authenticate response length: %lu", buf, 0x2Cu);
              }

              id v172 = objc_alloc((Class)NSError);
              id v47 = +[NSString stringWithUTF8String:"nfcd"];
              NSErrorUserInfoKey v426 = NSLocalizedDescriptionKey;
              id v157 = +[NSString stringWithUTF8String:"Unexpected Result"];
              v427 = v157;
              int v173 = +[NSDictionary dictionaryWithObjects:&v427 forKeys:&v426 count:1];
              id v18 = [v172 initWithDomain:v47 code:13 userInfo:v173];

              id v31 = 0;
              goto LABEL_300;
            }
            uint64_t v406 = 0;
            CFStringRef v140 = NFSharedSignpostLog();
            if (os_signpost_enabled(v140))
            {
              *(_WORD *)buf = 0;
              _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v140, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "AUTH_ECOMMERCE", "supportSSESigning in", buf, 2u);
            }

            id v405 = 0;
            BOOL v374 = sub_100221D9C((uint64_t)NFSSEWrapper, &v405);
            id v141 = v405;
            NSErrorUserInfoKey v142 = NFSharedSignpostLog();
            if (os_signpost_enabled(v142))
            {
              *(_WORD *)buf = 0;
              _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v142, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "AUTH_ECOMMERCE", "supportSSESigning out", buf, 2u);
            }

            if (v141)
            {
              uint64_t v143 = v141;
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v144 = NFLogGetLogger();
              if (v144)
              {
                v145 = (void (*)(uint64_t, const char *, ...))v144;
                v146 = object_getClass(a1);
                BOOL v147 = class_isMetaClass(v146);
                id v148 = object_getClassName(a1);
                v347 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
                uint64_t v149 = 45;
                if (v147) {
                  uint64_t v149 = 43;
                }
                v145(3, "%c[%{public}s %{public}s]:%i Failed to get SSE support", v149, v148, v347, 559);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              id v150 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v150, OS_LOG_TYPE_ERROR))
              {
                id v151 = object_getClass(a1);
                if (class_isMetaClass(v151)) {
                  int v152 = 43;
                }
                else {
                  int v152 = 45;
                }
                v153 = object_getClassName(a1);
                id v154 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
                *(_DWORD *)buf = 67109890;
                int v431 = v152;
                __int16 v432 = 2082;
                v433 = v153;
                __int16 v434 = 2082;
                v435 = v154;
                __int16 v436 = 1024;
                int v437 = 559;
                _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get SSE support", buf, 0x22u);
              }

              id v31 = v143;
              id v47 = 0;
              id v383 = 0;
              v155 = 0;
              id v18 = v31;
              goto LABEL_299;
            }
            if (v374)
            {
              uint64_t v174 = [v32 subdataWithRange:0, 8];
              uint64_t v175 = [v32 subdataWithRange:8, 8];
              v375 = (void *)v174;
              if (!v174 || !v175)
              {
                v237 = (void *)v175;
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v238 = NFLogGetLogger();
                if (v238)
                {
                  v239 = (void (*)(uint64_t, const char *, ...))v238;
                  v240 = object_getClass(a1);
                  BOOL v241 = class_isMetaClass(v240);
                  v242 = object_getClassName(a1);
                  v349 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
                  uint64_t v243 = 45;
                  if (v241) {
                    uint64_t v243 = 43;
                  }
                  v239(3, "%c[%{public}s %{public}s]:%i Failed to get card info", v243, v242, v349, 569);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v244 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v244, OS_LOG_TYPE_ERROR))
                {
                  v245 = object_getClass(a1);
                  if (class_isMetaClass(v245)) {
                    int v246 = 43;
                  }
                  else {
                    int v246 = 45;
                  }
                  v247 = object_getClassName(a1);
                  v248 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
                  *(_DWORD *)buf = 67109890;
                  int v431 = v246;
                  __int16 v432 = 2082;
                  v433 = v247;
                  __int16 v434 = 2082;
                  v435 = v248;
                  __int16 v436 = 1024;
                  int v437 = 569;
                  _os_log_impl((void *)&_mh_execute_header, v244, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get card info", buf, 0x22u);
                }

                id v249 = objc_alloc((Class)NSError);
                v250 = +[NSString stringWithUTF8String:"nfcd"];
                NSErrorUserInfoKey v424 = NSLocalizedDescriptionKey;
                v251 = +[NSString stringWithUTF8String:"Commmand Error"];
                v425 = v251;
                v252 = +[NSDictionary dictionaryWithObjects:&v425 forKeys:&v424 count:1];
                id v18 = [v249 initWithDomain:v250 code:16 userInfo:v252];

                id v31 = 0;
                id v47 = 0;
                id v383 = 0;
                v155 = 0;
                goto LABEL_299;
              }
              v370 = (void *)v175;
              id v404 = 0;
              v176 = sub_1001D812C((uint64_t)NFECommercePaymentRequestEncoder, v394, 0, &v404);
              id v31 = v404;
              v369 = v176;
              if (v176)
              {
                uint64_t v177 = sub_1001F3234(v176);
                if (v177)
                {
                  v364 = (void *)v177;
                  kdebug_trace();
                  v178 = NFSharedSignpostLog();
                  if (os_signpost_enabled(v178))
                  {
                    *(_WORD *)buf = 0;
                    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v178, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "authorizeAndSign in", buf, 2u);
                  }

                  [(NFECommercePaymentResponse *)a1 serialNumberAsData];
                  id v402 = 0;
                  id v403 = 0;
                  v179 = id v401 = 0;
                  v371 = sub_100220920((uint64_t)NFSSEWrapper, 3, v364, a3, v9, v179, v378, v382, v14, v375, v370, &v403, &v402, &v406, &v401);
                  id v47 = v403;
                  id v180 = v402;
                  id v379 = v401;

                  kdebug_trace();
                  v181 = NFSharedSignpostLog();
                  if (os_signpost_enabled(v181))
                  {
                    *(_WORD *)buf = 0;
                    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v181, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "authorizeAndSign out", buf, 2u);
                  }

                  id v18 = v371;
                  id v383 = v180;
                  if (v371)
                  {
                    unsigned int v400 = 0;
                    *a5 = 0;
                    v399 = 0;
                    int v182 = sub_1001F3330(a1, v371, &v399, &v400);
                    v362 = v399;
                    unsigned int v366 = v182;
                    if (v182)
                    {
                      id v388 = v9;
                      sub_1001F3D88(a1, v371, v394, a5, v400);
                      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                      uint64_t v183 = NFLogGetLogger();
                      if (v183)
                      {
                        __int16 v184 = (void (*)(uint64_t, const char *, ...))v183;
                        v185 = object_getClass(a1);
                        BOOL v360 = class_isMetaClass(v185);
                        __int16 v186 = object_getClassName(a1);
                        v348 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
                        uint64_t v187 = 45;
                        if (v360) {
                          uint64_t v187 = 43;
                        }
                        v184(3, "%c[%{public}s %{public}s]:%i Failed to send signed APDU", v187, v186, v348, 623);
                      }
                      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                      __int16 v188 = NFSharedLogGetLogger();
                      if (os_log_type_enabled(v188, OS_LOG_TYPE_ERROR))
                      {
                        id v189 = object_getClass(a1);
                        if (class_isMetaClass(v189)) {
                          int v190 = 43;
                        }
                        else {
                          int v190 = 45;
                        }
                        id v191 = object_getClassName(a1);
                        __int16 v192 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
                        *(_DWORD *)buf = 67109890;
                        int v431 = v190;
                        __int16 v432 = 2082;
                        v433 = v191;
                        __int16 v434 = 2082;
                        v435 = v192;
                        __int16 v436 = 1024;
                        int v437 = 623;
                        _os_log_impl((void *)&_mh_execute_header, v188, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to send signed APDU", buf, 0x22u);
                      }

                      id v193 = objc_alloc((Class)NSError);
                      uint64_t v194 = +[NSString stringWithUTF8String:"nfcd"];
                      uint64_t v361 = v366;
                      NSErrorUserInfoKey v416 = NSLocalizedDescriptionKey;
                      if (v366 >= 0x47) {
                        int v195 = 71;
                      }
                      else {
                        int v195 = v366;
                      }
                      v367 = +[NSString stringWithUTF8String:off_100306F98[v195]];
                      v417 = v367;
                      int v182 = 1;
                      v196 = +[NSDictionary dictionaryWithObjects:&v417 forKeys:&v416 count:1];
                      v197 = v193;
                      v198 = (void *)v194;
                      id v18 = [v197 initWithDomain:v194 code:v361 userInfo:v196];

                      id v9 = v388;
                    }
                    else
                    {
                      sub_1000C63FC(a1, v362);
                      *a5 = (uint64_t)(id)objc_claimAutoreleasedReturnValue();
                      sub_1001F3D88(a1, v371, v394, a5, v400);
                    }
                    int v368 = v182;
                    v155 = v379;
                    v311 = v362;
                    v312 = v364;
                  }
                  else
                  {
                    id v393 = v9;
                    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                    uint64_t v316 = NFLogGetLogger();
                    if (v316)
                    {
                      v317 = (void (*)(uint64_t, const char *, ...))v316;
                      v318 = object_getClass(a1);
                      BOOL v373 = class_isMetaClass(v318);
                      v319 = object_getClassName(a1);
                      v354 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
                      uint64_t v320 = 45;
                      if (v373) {
                        uint64_t v320 = 43;
                      }
                      v317(3, "%c[%{public}s %{public}s]:%i Failed to get signed APDU", v320, v319, v354, 606);
                    }
                    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                    v321 = NFSharedLogGetLogger();
                    if (os_log_type_enabled(v321, OS_LOG_TYPE_ERROR))
                    {
                      v322 = object_getClass(a1);
                      if (class_isMetaClass(v322)) {
                        int v323 = 43;
                      }
                      else {
                        int v323 = 45;
                      }
                      v324 = object_getClassName(a1);
                      v325 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
                      *(_DWORD *)buf = 67109890;
                      int v431 = v323;
                      __int16 v432 = 2082;
                      v433 = v324;
                      __int16 v434 = 2082;
                      v435 = v325;
                      __int16 v436 = 1024;
                      int v437 = 606;
                      _os_log_impl((void *)&_mh_execute_header, v321, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get signed APDU", buf, 0x22u);
                    }

                    id v326 = objc_alloc((Class)NSError);
                    uint64_t v327 = +[NSString stringWithUTF8String:"nfcd"];
                    NSErrorUserInfoKey v418 = NSLocalizedDescriptionKey;
                    v328 = +[NSString stringWithUTF8String:"Security Violation"];
                    v419 = v328;
                    v329 = +[NSDictionary dictionaryWithObjects:&v419 forKeys:&v418 count:1];
                    id v18 = [v326 initWithDomain:v327 code:8 userInfo:v329];

                    v311 = (void *)v327;
                    v371 = 0;
                    int v368 = 1;
                    v155 = v379;
                    v312 = v364;
                    id v9 = v393;
                  }
                }
                else
                {
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  uint64_t v297 = NFLogGetLogger();
                  if (v297)
                  {
                    v298 = (void (*)(uint64_t, const char *, ...))v297;
                    v299 = object_getClass(a1);
                    BOOL v300 = class_isMetaClass(v299);
                    v392 = object_getClassName(a1);
                    v353 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
                    uint64_t v301 = 45;
                    if (v300) {
                      uint64_t v301 = 43;
                    }
                    v298(3, "%c[%{public}s %{public}s]:%i Failed to create request", v301, v392, v353, 582);
                  }
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  v302 = NFSharedLogGetLogger();
                  if (os_log_type_enabled(v302, OS_LOG_TYPE_ERROR))
                  {
                    v303 = object_getClass(a1);
                    if (class_isMetaClass(v303)) {
                      int v304 = 43;
                    }
                    else {
                      int v304 = 45;
                    }
                    v305 = object_getClassName(a1);
                    v306 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
                    *(_DWORD *)buf = 67109890;
                    int v431 = v304;
                    __int16 v432 = 2082;
                    v433 = v305;
                    __int16 v434 = 2082;
                    v435 = v306;
                    __int16 v436 = 1024;
                    int v437 = 582;
                    _os_log_impl((void *)&_mh_execute_header, v302, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to create request", buf, 0x22u);
                  }

                  id v307 = objc_alloc((Class)NSError);
                  uint64_t v308 = +[NSString stringWithUTF8String:"nfcd"];
                  NSErrorUserInfoKey v420 = NSLocalizedDescriptionKey;
                  uint64_t v309 = +[NSString stringWithUTF8String:"Encoding Error"];
                  uint64_t v421 = v309;
                  int v368 = 1;
                  v310 = +[NSDictionary dictionaryWithObjects:&v421 forKeys:&v420 count:1];
                  v371 = (void *)v308;
                  id v18 = [v307 initWithDomain:v308 code:22 userInfo:v310];

                  v311 = (void *)v309;
                  v312 = 0;
                  id v47 = 0;
                  id v383 = 0;
                  v155 = 0;
                }
              }
              else
              {
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v286 = NFLogGetLogger();
                if (v286)
                {
                  v287 = (void (*)(uint64_t, const char *, ...))v286;
                  v288 = object_getClass(a1);
                  BOOL v289 = class_isMetaClass(v288);
                  v390 = object_getClassName(a1);
                  v352 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
                  uint64_t v290 = 45;
                  if (v289) {
                    uint64_t v290 = 43;
                  }
                  v287(3, "%c[%{public}s %{public}s]:%i Failed to encode request", v290, v390, v352, 576);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v291 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v291, OS_LOG_TYPE_ERROR))
                {
                  v292 = object_getClass(a1);
                  if (class_isMetaClass(v292)) {
                    int v293 = 43;
                  }
                  else {
                    int v293 = 45;
                  }
                  v294 = object_getClassName(a1);
                  v295 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
                  *(_DWORD *)buf = 67109890;
                  int v431 = v293;
                  __int16 v432 = 2082;
                  v433 = v294;
                  __int16 v434 = 2082;
                  v435 = v295;
                  __int16 v436 = 1024;
                  int v437 = 576;
                  _os_log_impl((void *)&_mh_execute_header, v291, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to encode request", buf, 0x22u);
                }

                id v391 = objc_alloc((Class)NSError);
                uint64_t v365 = +[NSString stringWithUTF8String:"nfcd"];
                id v384 = [v31 code];
                v422[0] = NSLocalizedDescriptionKey;
                if ((uint64_t)[v31 code] > 70) {
                  uint64_t v296 = 71;
                }
                else {
                  uint64_t v296 = (uint64_t)[v31 code];
                }
                v371 = +[NSString stringWithUTF8String:off_100306F98[v296]];
                v423[0] = v371;
                v423[1] = v31;
                v422[1] = NSUnderlyingErrorKey;
                v422[2] = @"Line";
                v423[2] = &off_10031F6F0;
                v422[3] = @"Method";
                id v363 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("authorizeEcommerceTransaction:uid:request:response:")];
                v423[3] = v363;
                v422[4] = NSDebugDescriptionErrorKey;
                id v314 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("authorizeEcommerceTransaction:uid:request:response:"), 577];
                v423[4] = v314;
                v315 = +[NSDictionary dictionaryWithObjects:v423 forKeys:v422 count:5];
                v312 = (void *)v365;
                id v18 = [v391 initWithDomain:v365 code:v384 userInfo:v315];

                v311 = v363;
                id v47 = 0;
                id v383 = 0;
                v155 = 0;
                int v368 = 1;
              }

              if (!v368) {
                goto LABEL_286;
              }
LABEL_299:

              id v157 = v383;
LABEL_300:

              goto LABEL_51;
            }
            LOBYTE(v400) = 0;
            kdebug_trace();
            v199 = NFSharedSignpostLog();
            if (os_signpost_enabled(v199))
            {
              *(_WORD *)buf = 0;
              _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v199, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseAuthorize in", buf, 2u);
            }

            v200 = [(NFECommercePaymentResponse *)a1 serialNumberAsData];
            id v397 = 0;
            id v398 = 0;
            id v395 = 0;
            id v396 = 0;
            v389 = sub_10021F9D8((uint64_t)NFSSEWrapper, v387, v9, v200, a3, v14, v32, (char *)&v400, &v398, &v397, &v396, &v406, &v395);
            id v201 = v398;
            id v47 = v397;
            id v383 = v396;
            id v380 = v395;

            kdebug_trace();
            v202 = NFSharedSignpostLog();
            if (os_signpost_enabled(v202))
            {
              *(_WORD *)buf = 0;
              _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v202, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseAuthorize out", buf, 2u);
            }

            if (v389)
            {
              if ([v389 length] == (id)8)
              {
                v203 = NFSharedSignpostLog();
                if (os_signpost_enabled(v203))
                {
                  *(_WORD *)buf = 0;
                  _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v203, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEND_ECOMMERCE_APDU", "crs_authorizeForECommerce in", buf, 2u);
                }

                uint64_t v204 = sub_1000C69E4(a1, v400, v389, v201, v394, a5);
                v205 = NFSharedSignpostLog();
                if (os_signpost_enabled(v205))
                {
                  *(_WORD *)buf = 0;
                  _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v205, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEND_ECOMMERCE_APDU", "crs_authorizeForECommerce out", buf, 2u);
                }

                if (!v204)
                {

                  id v31 = 0;
                  v155 = v380;
LABEL_286:
                  if (*a5)
                  {
                    v381 = v155;
                    v330 = objc_opt_new();
                    v331 = [(NFECommercePaymentResponse *)a1 rsaCertificate];

                    if (v331)
                    {
                      v332 = [(NFECommercePaymentResponse *)a1 rsaCertificate];
                      [v330 setObject:v332 forKeyedSubscript:@"RSA"];
                    }
                    v333 = [(NFECommercePaymentResponse *)a1 eccCertificate];

                    if (v333)
                    {
                      v334 = [(NFECommercePaymentResponse *)a1 eccCertificate];
                      [v330 setObject:v334 forKeyedSubscript:@"ECDSA"];
                    }
                    v335 = [(NFECommercePaymentResponse *)a1 eckaCertificate];

                    if (v335)
                    {
                      v336 = [(NFECommercePaymentResponse *)a1 eckaCertificate];
                      [v330 setObject:v336 forKeyedSubscript:@"ECKA"];
                    }
                    v337 = [(NFECommercePaymentResponse *)a1 eccCertificate];

                    if (v337)
                    {
                      v338 = [(NFECommercePaymentResponse *)a1 eccCertificate];
                      [v330 setObject:v338 forKeyedSubscript:@"ECC"];
                    }
                    [(id)*a5 setCerts:v330];
                    [(id)*a5 setConfirmationBlobHash:v47 withSignature:v383 version:v406];
                    [(id)*a5 setSEPCerts:v381];

                    v155 = v381;
                  }
                  v339 = NFSharedSignpostLog();
                  if (os_signpost_enabled(v339))
                  {
                    *(_WORD *)buf = 0;
                    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v339, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEND_ECOMMERCE_APDU", "done", buf, 2u);
                  }

                  id v18 = 0;
                  goto LABEL_299;
                }
                uint64_t v376 = v204;
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v206 = NFLogGetLogger();
                if (v206)
                {
                  v207 = (void (*)(uint64_t, const char *, ...))v206;
                  v208 = object_getClass(a1);
                  BOOL v209 = class_isMetaClass(v208);
                  id v210 = v201;
                  v211 = object_getClassName(a1);
                  v212 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
                  uint64_t v213 = 45;
                  if (v209) {
                    uint64_t v213 = 43;
                  }
                  v341 = v211;
                  id v201 = v210;
                  v207(3, "%c[%{public}s %{public}s]:%i Failed to authorize for type=%d", v213, v341, v212, 666, v400);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v214 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v214, OS_LOG_TYPE_ERROR))
                {
                  v215 = object_getClass(a1);
                  id v216 = v201;
                  if (class_isMetaClass(v215)) {
                    int v217 = 43;
                  }
                  else {
                    int v217 = 45;
                  }
                  v218 = object_getClassName(a1);
                  v219 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
                  *(_DWORD *)buf = 67110146;
                  int v431 = v217;
                  id v201 = v216;
                  __int16 v432 = 2082;
                  v433 = v218;
                  __int16 v434 = 2082;
                  v435 = v219;
                  __int16 v436 = 1024;
                  int v437 = 666;
                  __int16 v438 = 1024;
                  LODWORD(v439) = v400;
                  _os_log_impl((void *)&_mh_execute_header, v214, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to authorize for type=%d", buf, 0x28u);
                }

                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v220 = NFLogGetLogger();
                if (v220)
                {
                  v221 = (void (*)(uint64_t, const char *, ...))v220;
                  v222 = object_getClass(a1);
                  BOOL v223 = class_isMetaClass(v222);
                  id v224 = v201;
                  v225 = object_getClassName(a1);
                  v226 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
                  if (v376 >= 0x47) {
                    int v227 = 71;
                  }
                  else {
                    int v227 = v376;
                  }
                  v359 = off_100306F98[v227];
                  v342 = v225;
                  uint64_t v228 = 43;
                  if (!v223) {
                    uint64_t v228 = 45;
                  }
                  id v201 = v224;
                  v221(3, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", v228, v342, v226, 667, @"Returned", v376, v359);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v229 = NFSharedLogGetLogger();
                id v372 = v201;
                if (os_log_type_enabled(v229, OS_LOG_TYPE_ERROR))
                {
                  v230 = object_getClass(a1);
                  if (class_isMetaClass(v230)) {
                    int v231 = 43;
                  }
                  else {
                    int v231 = 45;
                  }
                  v232 = object_getClassName(a1);
                  v233 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
                  unsigned int v234 = v376;
                  if (v376 >= 0x47) {
                    uint64_t v235 = 71;
                  }
                  else {
                    uint64_t v235 = v376;
                  }
                  v236 = off_100306F98[v235];
                  *(_DWORD *)buf = 67110658;
                  int v431 = v231;
                  __int16 v432 = 2082;
                  v433 = v232;
                  __int16 v434 = 2082;
                  v435 = v233;
                  __int16 v436 = 1024;
                  int v437 = 667;
                  __int16 v438 = 2112;
                  CFStringRef v439 = @"Returned";
                  __int16 v440 = 1024;
                  int v441 = v376;
                  __int16 v442 = 2080;
                  v443 = v236;
                  _os_log_impl((void *)&_mh_execute_header, v229, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", buf, 0x3Cu);
                }
                else
                {
                  unsigned int v234 = v376;
                  if (v376 >= 0x47) {
                    uint64_t v235 = 71;
                  }
                  else {
                    uint64_t v235 = v376;
                  }
                }

                id v313 = objc_alloc((Class)NSError);
                v266 = +[NSString stringWithUTF8String:"nfcd"];
                NSErrorUserInfoKey v410 = NSLocalizedDescriptionKey;
                v267 = +[NSString stringWithUTF8String:off_100306F98[v235]];
                v411 = v267;
                v268 = +[NSDictionary dictionaryWithObjects:&v411 forKeys:&v410 count:1];
                id v18 = [v313 initWithDomain:v266 code:v234 userInfo:v268];
                id v201 = v372;
                goto LABEL_270;
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v272 = NFLogGetLogger();
              if (v272)
              {
                v273 = (void (*)(uint64_t, const char *, ...))v272;
                v274 = object_getClass(a1);
                BOOL v275 = class_isMetaClass(v274);
                v377 = object_getClassName(a1);
                id v276 = v201;
                v277 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
                id v357 = [v389 length];
                v351 = v277;
                id v201 = v276;
                uint64_t v278 = 45;
                if (v275) {
                  uint64_t v278 = 43;
                }
                v273(3, "%c[%{public}s %{public}s]:%i Invalid cryptogram length: %lu", v278, v377, v351, 654, v357);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v279 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v279, OS_LOG_TYPE_ERROR))
              {
                v280 = object_getClass(a1);
                if (class_isMetaClass(v280)) {
                  int v281 = 43;
                }
                else {
                  int v281 = 45;
                }
                v282 = object_getClassName(a1);
                v283 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
                CFStringRef v284 = (const __CFString *)[v389 length];
                *(_DWORD *)buf = 67110146;
                int v431 = v281;
                __int16 v432 = 2082;
                v433 = v282;
                __int16 v434 = 2082;
                v435 = v283;
                __int16 v436 = 1024;
                int v437 = 654;
                __int16 v438 = 2048;
                CFStringRef v439 = v284;
                _os_log_impl((void *)&_mh_execute_header, v279, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid cryptogram length: %lu", buf, 0x2Cu);
              }

              id v285 = objc_alloc((Class)NSError);
              v266 = +[NSString stringWithUTF8String:"nfcd"];
              NSErrorUserInfoKey v412 = NSLocalizedDescriptionKey;
              v267 = +[NSString stringWithUTF8String:"Unexpected Result"];
              v413 = v267;
              v268 = +[NSDictionary dictionaryWithObjects:&v413 forKeys:&v412 count:1];
              v269 = v285;
              v270 = v266;
              uint64_t v271 = 13;
            }
            else
            {
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v253 = NFLogGetLogger();
              if (v253)
              {
                v254 = (void (*)(uint64_t, const char *, ...))v253;
                v255 = object_getClass(a1);
                BOOL v256 = class_isMetaClass(v255);
                id v257 = v201;
                v258 = object_getClassName(a1);
                v350 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
                uint64_t v259 = 45;
                if (v256) {
                  uint64_t v259 = 43;
                }
                v343 = v258;
                id v201 = v257;
                v254(3, "%c[%{public}s %{public}s]:%i Failed to generate cryptogram", v259, v343, v350, 649);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v260 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v260, OS_LOG_TYPE_ERROR))
              {
                v261 = object_getClass(a1);
                if (class_isMetaClass(v261)) {
                  int v262 = 43;
                }
                else {
                  int v262 = 45;
                }
                v263 = object_getClassName(a1);
                v264 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
                *(_DWORD *)buf = 67109890;
                int v431 = v262;
                __int16 v432 = 2082;
                v433 = v263;
                __int16 v434 = 2082;
                v435 = v264;
                __int16 v436 = 1024;
                int v437 = 649;
                _os_log_impl((void *)&_mh_execute_header, v260, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to generate cryptogram", buf, 0x22u);
              }

              id v265 = objc_alloc((Class)NSError);
              v266 = +[NSString stringWithUTF8String:"nfcd"];
              NSErrorUserInfoKey v414 = NSLocalizedDescriptionKey;
              v267 = +[NSString stringWithUTF8String:"Security Violation"];
              v415 = v267;
              v268 = +[NSDictionary dictionaryWithObjects:&v415 forKeys:&v414 count:1];
              v269 = v265;
              v270 = v266;
              uint64_t v271 = 8;
            }
            id v18 = [v269 initWithDomain:v270 code:v271 userInfo:v268];
LABEL_270:

            id v31 = 0;
            v155 = v380;
            goto LABEL_299;
          default:
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v74 = NFLogGetLogger();
            if (v74)
            {
              id v75 = (void (*)(uint64_t, const char *, ...))v74;
              id v76 = object_getClass(a1);
              BOOL v77 = class_isMetaClass(v76);
              v340 = object_getClassName(a1);
              v346 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
              uint64_t v78 = 45;
              if (v77) {
                uint64_t v78 = 43;
              }
              v75(3, "%c[%{public}s %{public}s]:%i Unknown transaction type: %d", v78, v340, v346, 531, v69);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            __int16 v79 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
            {
              int v80 = object_getClass(a1);
              if (class_isMetaClass(v80)) {
                int v81 = 43;
              }
              else {
                int v81 = 45;
              }
              id v82 = object_getClassName(a1);
              __int16 v83 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
              *(_DWORD *)buf = 67110146;
              int v431 = v81;
              __int16 v432 = 2082;
              v433 = v82;
              __int16 v434 = 2082;
              v435 = v83;
              __int16 v436 = 1024;
              int v437 = 531;
              __int16 v438 = 1024;
              LODWORD(v439) = v69;
              _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unknown transaction type: %d", buf, 0x28u);
            }

            id v64 = objc_alloc((Class)NSError);
            id v31 = +[NSString stringWithUTF8String:"nfcd"];
            NSErrorUserInfoKey v444 = NSLocalizedDescriptionKey;
            id v32 = +[NSString stringWithUTF8String:"Unexpected Result"];
            id v445 = v32;
            int v65 = &v445;
            id v66 = &v444;
            goto LABEL_48;
        }
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v51 = NFLogGetLogger();
      if (v51)
      {
        int v52 = (void (*)(uint64_t, const char *, ...))v51;
        id v53 = object_getClass(a1);
        BOOL v54 = class_isMetaClass(v53);
        uint64_t v55 = object_getClassName(a1);
        id v56 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
        id v355 = [v14 length];
        uint64_t v57 = 45;
        if (v54) {
          uint64_t v57 = 43;
        }
        v52(3, "%c[%{public}s %{public}s]:%i Invalid host challenge length: %lu", v57, v55, v56, 477, v355);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      BOOL v58 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
      {
        int v59 = object_getClass(a1);
        if (class_isMetaClass(v59)) {
          int v60 = 43;
        }
        else {
          int v60 = 45;
        }
        double v61 = object_getClassName(a1);
        uint64_t v62 = sel_getName("authorizeEcommerceTransaction:uid:request:response:");
        CFStringRef v63 = (const __CFString *)[v14 length];
        *(_DWORD *)buf = 67110146;
        int v431 = v60;
        __int16 v432 = 2082;
        v433 = v61;
        __int16 v434 = 2082;
        v435 = v62;
        __int16 v436 = 1024;
        int v437 = 477;
        __int16 v438 = 2048;
        CFStringRef v439 = v63;
        _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid host challenge length: %lu", buf, 0x2Cu);
      }

      id v64 = objc_alloc((Class)NSError);
      id v31 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v450 = NSLocalizedDescriptionKey;
      id v32 = +[NSString stringWithUTF8String:"Unexpected Result"];
      id v451 = v32;
      int v65 = &v451;
      id v66 = &v450;
LABEL_48:
      id v47 = +[NSDictionary dictionaryWithObjects:v65 forKeys:v66 count:1];
      uint64_t v48 = v64;
      id v49 = v31;
      uint64_t v50 = 13;
    }
    id v18 = [v48 initWithDomain:v49 code:v50 userInfo:v47];
LABEL_51:

LABEL_52:
    id v10 = v394;
    goto LABEL_53;
  }
  id v18 = 0;
LABEL_54:

  return v18;
}

NSObject *sub_1001F7028(void *a1, void *a2, void *a3, uint64_t a4, void *a5, unsigned int a6)
{
  id v11 = a2;
  id v12 = a3;
  id v212 = a5;
  if (a1)
  {
    id v219 = 0;
    unsigned int v13 = [a1 selectCRSWithError:&v219];
    id v14 = v219;
    if (v14)
    {
      uint64_t v15 = v14;
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        id v17 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("_authorizeAppletTransaction:forApplet:authType:authorization:uid:");
        uint64_t v20 = 45;
        if (isMetaClass) {
          uint64_t v20 = 43;
        }
        v17(3, "%c[%{public}s %{public}s]:%i Failed to select CRS: %{public}@", v20, ClassName, Name, 700, v15);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v21 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        int v22 = object_getClass(a1);
        if (class_isMetaClass(v22)) {
          int v23 = 43;
        }
        else {
          int v23 = 45;
        }
        uint64_t v24 = object_getClassName(a1);
        uint64_t v25 = sel_getName("_authorizeAppletTransaction:forApplet:authType:authorization:uid:");
        *(_DWORD *)buf = 67110146;
        int v241 = v23;
        __int16 v242 = 2082;
        uint64_t v243 = v24;
        __int16 v244 = 2082;
        v245 = v25;
        __int16 v246 = 1024;
        int v247 = 700;
        __int16 v248 = 2114;
        id v249 = v15;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select CRS: %{public}@", buf, 0x2Cu);
      }
      goto LABEL_115;
    }
    if ([v13 status] != 36864)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v68 = NFLogGetLogger();
      if (v68)
      {
        uint64_t v69 = (void (*)(uint64_t, const char *, ...))v68;
        id v70 = object_getClass(a1);
        BOOL v71 = class_isMetaClass(v70);
        id v72 = v12;
        id v73 = v11;
        uint64_t v74 = object_getClassName(a1);
        id v75 = sel_getName("_authorizeAppletTransaction:forApplet:authType:authorization:uid:");
        uint64_t v189 = [v13 status];
        int v182 = v74;
        uint64_t v76 = 45;
        if (v71) {
          uint64_t v76 = 43;
        }
        id v11 = v73;
        id v12 = v72;
        v69(3, "%c[%{public}s %{public}s]:%i Failed to select CRS, status=%x", v76, v182, v75, 704, v189);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      BOOL v77 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
      {
        uint64_t v78 = object_getClass(a1);
        if (class_isMetaClass(v78)) {
          int v79 = 43;
        }
        else {
          int v79 = 45;
        }
        int v80 = object_getClassName(a1);
        int v81 = sel_getName("_authorizeAppletTransaction:forApplet:authType:authorization:uid:");
        unsigned int v82 = [v13 status];
        *(_DWORD *)buf = 67110146;
        int v241 = v79;
        __int16 v242 = 2082;
        uint64_t v243 = v80;
        __int16 v244 = 2082;
        v245 = v81;
        __int16 v246 = 1024;
        int v247 = 704;
        __int16 v248 = 1024;
        LODWORD(v249) = v82;
        _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select CRS, status=%x", buf, 0x28u);
      }

      id v83 = objc_alloc((Class)NSError);
      uint64_t v21 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v238 = NSLocalizedDescriptionKey;
      int v84 = +[NSString stringWithUTF8String:"Commmand Error"];
      v239 = v84;
      __int16 v85 = +[NSDictionary dictionaryWithObjects:&v239 forKeys:&v238 count:1];
      uint64_t v15 = [v83 initWithDomain:v21 code:16 userInfo:v85];

      goto LABEL_115;
    }
    BOOL v209 = v13;
    id v26 = [objc_alloc((Class)NSMutableData) initWithLength:32];
    id v210 = v11;
    id v27 = v11;
    id v28 = [v27 bytes];
    LODWORD(v27) = [v27 length];
    id v29 = v26;
    CC_SHA256(v28, (CC_LONG)v27, (unsigned __int8 *)[v29 mutableBytes]);
    id v30 = objc_opt_new();
    id v202 = v12;
    id v31 = [v12 identifierAsData];
    id v32 = +[NFTLV TLVWithTag:79 value:v31];
    [v30 addObject:v32];

    uint64_t v33 = objc_opt_new();
    __int16 v34 = +[NFTLV TLVWithTag:2 unsignedChar:a4];
    [v33 addObject:v34];

    id v201 = v29;
    id v35 = +[NFTLV TLVWithTag:4 value:v29];
    [v33 addObject:v35];

    v203 = +[NFTLV TLVWithTag:48 children:v33];
    BOOL v36 = [v203 asData];
    uint64_t v37 = +[NFTLV TLVWithTag:239 value:v36];

    uint64_t v204 = (void *)v37;
    [v30 addObject:v37];
    v200 = v30;
    uint64_t v38 = +[NFTLV TLVWithTag:228 children:v30];
    BOOL v39 = [v38 asData];
    int v217 = 849024;
    unsigned __int8 v218 = [v39 length];
    char v216 = 0;
    id v40 = [objc_alloc((Class)NSMutableData) initWithCapacity:[v39 length] + 6];
    [v40 appendBytes:&v217 length:5];
    [v40 appendData:v39];
    [v40 appendBytes:&v216 length:1];
    id v215 = 0;
    unsigned int v41 = sub_10021F7F0((uint64_t)NFSSEWrapper, &v215);
    id v42 = v215;
    v207 = v38;
    v208 = v33;
    v205 = v40;
    uint64_t v206 = v39;
    v211 = v42;
    if (!v42 || v41)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v86 = NFLogGetLogger();
      if (v86)
      {
        BOOL v87 = (void (*)(uint64_t, const char *, ...))v86;
        uint64_t v88 = object_getClass(a1);
        BOOL v89 = class_isMetaClass(v88);
        int v90 = object_getClassName(a1);
        v185 = sel_getName("_authorizeAppletTransaction:forApplet:authType:authorization:uid:");
        uint64_t v91 = 45;
        if (v89) {
          uint64_t v91 = 43;
        }
        v87(3, "%c[%{public}s %{public}s]:%i Failed to get host challenge", v91, v90, v185, 758);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v92 = NFSharedLogGetLogger();
      id v12 = v202;
      if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
      {
        uint64_t v93 = object_getClass(a1);
        if (class_isMetaClass(v93)) {
          int v94 = 43;
        }
        else {
          int v94 = 45;
        }
        __int16 v95 = object_getClassName(a1);
        int v96 = sel_getName("_authorizeAppletTransaction:forApplet:authType:authorization:uid:");
        *(_DWORD *)buf = 67109890;
        int v241 = v94;
        __int16 v242 = 2082;
        uint64_t v243 = v95;
        __int16 v244 = 2082;
        v245 = v96;
        __int16 v246 = 1024;
        int v247 = 758;
        _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get host challenge", buf, 0x22u);
      }

      id v97 = objc_alloc((Class)NSError);
      uint64_t v98 = +[NSString stringWithUTF8String:"nfcd"];
      if (v41)
      {
        NSErrorUserInfoKey v234 = NSLocalizedDescriptionKey;
        if (v41 >= 0x47) {
          int v99 = 71;
        }
        else {
          int v99 = v41;
        }
        int v100 = +[NSString stringWithUTF8String:off_100306F98[v99]];
        uint64_t v235 = v100;
        id v101 = +[NSDictionary dictionaryWithObjects:&v235 forKeys:&v234 count:1];
        uint64_t v102 = v97;
        uint64_t v103 = v98;
        uint64_t v104 = v41;
      }
      else
      {
        NSErrorUserInfoKey v236 = NSLocalizedDescriptionKey;
        int v100 = +[NSString stringWithUTF8String:"Unknown Error"];
        v237 = v100;
        id v101 = +[NSDictionary dictionaryWithObjects:&v237 forKeys:&v236 count:1];
        uint64_t v102 = v97;
        uint64_t v103 = v98;
        uint64_t v104 = 6;
      }
      uint64_t v15 = [v102 initWithDomain:v103 code:v104 userInfo:v101];
      uint64_t v125 = (void *)v98;
      uint64_t v21 = 0;
      uint64_t v123 = v200;
      unsigned int v122 = v201;
      __int16 v67 = v203;
      int v124 = v204;
      goto LABEL_114;
    }
    unsigned int v195 = a6;
    id v214 = 0;
    unsigned int v43 = sub_1000C5684(a1, v42, &v214);
    id v44 = v214;
    id v199 = v44;
    if (v43)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v45 = NFLogGetLogger();
      if (v45)
      {
        int v46 = (void (*)(uint64_t, const char *, ...))v45;
        id v47 = object_getClass(a1);
        BOOL v192 = class_isMetaClass(v47);
        v196 = object_getClassName(a1);
        id v191 = sel_getName("_authorizeAppletTransaction:forApplet:authType:authorization:uid:");
        id v48 = objc_alloc((Class)NSError);
        id v49 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v232 = NSLocalizedDescriptionKey;
        if (v43 >= 0x47) {
          int v50 = 71;
        }
        else {
          int v50 = v43;
        }
        uint64_t v51 = +[NSString stringWithUTF8String:off_100306F98[v50]];
        v233 = v51;
        int v52 = +[NSDictionary dictionaryWithObjects:&v233 forKeys:&v232 count:1];
        id v53 = [v48 initWithDomain:v49 code:v43 userInfo:v52];
        uint64_t v54 = 45;
        if (v192) {
          uint64_t v54 = 43;
        }
        v46(3, "%c[%{public}s %{public}s]:%i Failed to authenticate to CRS %{public}@", v54, v196, v191, 769, v53);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v55 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
      {
        id v56 = object_getClass(a1);
        if (class_isMetaClass(v56)) {
          int v57 = 43;
        }
        else {
          int v57 = 45;
        }
        int v197 = v57;
        id v193 = object_getClassName(a1);
        BOOL v58 = sel_getName("_authorizeAppletTransaction:forApplet:authType:authorization:uid:");
        id v59 = objc_alloc((Class)NSError);
        int v60 = +[NSString stringWithUTF8String:"nfcd"];
        uint64_t v61 = v43;
        NSErrorUserInfoKey v62 = NSLocalizedDescriptionKey;
        NSErrorUserInfoKey v230 = NSLocalizedDescriptionKey;
        if (v43 >= 0x47) {
          uint64_t v63 = 71;
        }
        else {
          uint64_t v63 = v43;
        }
        id v64 = +[NSString stringWithUTF8String:off_100306F98[v63]];
        int v231 = v64;
        int v65 = +[NSDictionary dictionaryWithObjects:&v231 forKeys:&v230 count:1];
        id v66 = [v59 initWithDomain:v60 code:v61 userInfo:v65];
        *(_DWORD *)buf = 67110146;
        int v241 = v197;
        __int16 v242 = 2082;
        uint64_t v243 = v193;
        __int16 v244 = 2082;
        v245 = v58;
        __int16 v246 = 1024;
        int v247 = 769;
        __int16 v248 = 2114;
        id v249 = v66;
        _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to authenticate to CRS %{public}@", buf, 0x2Cu);

        __int16 v67 = v203;
      }
      else
      {
        NSErrorUserInfoKey v62 = NSLocalizedDescriptionKey;
        uint64_t v61 = v43;
        if (v43 >= 0x47) {
          uint64_t v63 = 71;
        }
        else {
          uint64_t v63 = v43;
        }
        __int16 v67 = v203;
      }

      id v126 = objc_alloc((Class)NSError);
      uint64_t v127 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v228 = v62;
      id v101 = +[NSString stringWithUTF8String:off_100306F98[v63]];
      v229 = v101;
      uint64_t v128 = +[NSDictionary dictionaryWithObjects:&v229 forKeys:&v228 count:1];
      int v100 = (void *)v127;
      uint64_t v129 = v127;
      long long v121 = (void *)v128;
      uint64_t v15 = [v126 initWithDomain:v129 code:v61 userInfo:v128];
      uint64_t v21 = 0;
      unsigned int v122 = v201;
      id v12 = v202;
      uint64_t v123 = v200;
      int v124 = v204;
      goto LABEL_113;
    }
    BOOL v105 = v44;
    if ((unint64_t)[v44 length] <= 0xF)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v106 = NFLogGetLogger();
      if (v106)
      {
        v107 = (void (*)(uint64_t, const char *, ...))v106;
        uint64_t v108 = object_getClass(a1);
        BOOL v109 = class_isMetaClass(v108);
        uint64_t v110 = object_getClassName(a1);
        BOOL v111 = sel_getName("_authorizeAppletTransaction:forApplet:authType:authorization:uid:");
        id v190 = [v105 length];
        uint64_t v112 = 45;
        if (v109) {
          uint64_t v112 = 43;
        }
        v107(3, "%c[%{public}s %{public}s]:%i Initialize auth response too small: %lu", v112, v110, v111, 774, v190);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v113 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v113, OS_LOG_TYPE_ERROR))
      {
        uint64_t v114 = object_getClass(a1);
        if (class_isMetaClass(v114)) {
          int v115 = 43;
        }
        else {
          int v115 = 45;
        }
        BOOL v116 = object_getClassName(a1);
        int v117 = sel_getName("_authorizeAppletTransaction:forApplet:authType:authorization:uid:");
        long long v118 = [v105 length];
        *(_DWORD *)buf = 67110146;
        int v241 = v115;
        __int16 v242 = 2082;
        uint64_t v243 = v116;
        __int16 v244 = 2082;
        v245 = v117;
        __int16 v246 = 1024;
        int v247 = 774;
        __int16 v248 = 2048;
        id v249 = v118;
        _os_log_impl((void *)&_mh_execute_header, v113, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Initialize auth response too small: %lu", buf, 0x2Cu);
      }

      id v119 = objc_alloc((Class)NSError);
      uint64_t v120 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v226 = NSLocalizedDescriptionKey;
      id v101 = +[NSString stringWithUTF8String:"Commmand Error"];
      int v227 = v101;
      long long v121 = +[NSDictionary dictionaryWithObjects:&v227 forKeys:&v226 count:1];
      int v100 = (void *)v120;
      uint64_t v15 = [v119 initWithDomain:v120 code:16 userInfo:v121];
      uint64_t v21 = 0;
      unsigned int v122 = v201;
      id v12 = v202;
      uint64_t v123 = v200;
      __int16 v67 = v203;
      int v124 = v204;
      goto LABEL_113;
    }
    BOOL v130 = [v105 subdataWithRange:0, 8];
    uint64_t v131 = [v105 subdataWithRange:NSMakeRange(8, 8)];
    uint64_t v132 = (void *)v131;
    if (v130 && v131)
    {
      id v133 = [a1 serialNumberAsData];
      uint64_t v21 = sub_100220920((uint64_t)NFSSEWrapper, 6, v40, v195, v212, v133, 0, 0, v211, v130, v132, 0, 0, 0, 0);

      if (v21)
      {
        id v213 = 0;
        v198 = v21;
        id v134 = [a1 transceiveData:v21 toOS:0 error:&v213];
        int v135 = v213;
        __int16 v136 = +[NFResponseAPDU responseWithData:v134];

        uint64_t v194 = v136;
        if (v135)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v137 = NFLogGetLogger();
          if (v137)
          {
            uint64_t v138 = (void (*)(uint64_t, const char *, ...))v137;
            CFStringRef v139 = object_getClass(a1);
            BOOL v140 = class_isMetaClass(v139);
            uint64_t v183 = object_getClassName(a1);
            __int16 v186 = sel_getName("_authorizeAppletTransaction:forApplet:authType:authorization:uid:");
            uint64_t v141 = 45;
            if (v140) {
              uint64_t v141 = 43;
            }
            v138(3, "%c[%{public}s %{public}s]:%i signed authorized opaque to CRS failed: %{public}@", v141, v183, v186, 812, v135);
          }
          id v101 = v132;
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          NSErrorUserInfoKey v142 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v142, OS_LOG_TYPE_ERROR))
          {
            uint64_t v143 = object_getClass(a1);
            if (class_isMetaClass(v143)) {
              int v144 = 43;
            }
            else {
              int v144 = 45;
            }
            v145 = object_getClassName(a1);
            v146 = sel_getName("_authorizeAppletTransaction:forApplet:authType:authorization:uid:");
            *(_DWORD *)buf = 67110146;
            int v241 = v144;
            __int16 v242 = 2082;
            uint64_t v243 = v145;
            __int16 v244 = 2082;
            v245 = v146;
            __int16 v246 = 1024;
            int v247 = 812;
            __int16 v248 = 2114;
            id v249 = v135;
            _os_log_impl((void *)&_mh_execute_header, v142, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i signed authorized opaque to CRS failed: %{public}@", buf, 0x2Cu);
          }

          uint64_t v21 = v135;
          uint64_t v15 = v21;
        }
        else
        {
          id v101 = v132;
          if ([v136 status] == 36864)
          {
            uint64_t v21 = 0;
            uint64_t v15 = 0;
          }
          else
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v165 = NFLogGetLogger();
            if (v165)
            {
              __int16 v166 = (void (*)(uint64_t, const char *, ...))v165;
              long long v167 = object_getClass(a1);
              BOOL v168 = class_isMetaClass(v167);
              int v169 = object_getClassName(a1);
              __int16 v188 = sel_getName("_authorizeAppletTransaction:forApplet:authType:authorization:uid:");
              uint64_t v170 = 45;
              if (v168) {
                uint64_t v170 = 43;
              }
              v166(3, "%c[%{public}s %{public}s]:%i Failed to execute opaque data, expecting RAPDU", v170, v169, v188, 816);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            CFStringRef v171 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v171, OS_LOG_TYPE_ERROR))
            {
              id v172 = object_getClass(a1);
              if (class_isMetaClass(v172)) {
                int v173 = 43;
              }
              else {
                int v173 = 45;
              }
              uint64_t v174 = object_getClassName(a1);
              uint64_t v175 = sel_getName("_authorizeAppletTransaction:forApplet:authType:authorization:uid:");
              *(_DWORD *)buf = 67109890;
              int v241 = v173;
              __int16 v242 = 2082;
              uint64_t v243 = v174;
              __int16 v244 = 2082;
              v245 = v175;
              __int16 v246 = 1024;
              int v247 = 816;
              _os_log_impl((void *)&_mh_execute_header, v171, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to execute opaque data, expecting RAPDU", buf, 0x22u);
            }

            id v176 = objc_alloc((Class)NSError);
            uint64_t v177 = +[NSString stringWithUTF8String:"nfcd"];
            NSErrorUserInfoKey v220 = NSLocalizedDescriptionKey;
            v178 = +[NSString stringWithUTF8String:"Commmand Error"];
            v221 = v178;
            v179 = +[NSDictionary dictionaryWithObjects:&v221 forKeys:&v220 count:1];
            uint64_t v15 = [v176 initWithDomain:v177 code:16 userInfo:v179];

            uint64_t v21 = 0;
          }
        }
        unsigned int v122 = v201;
        id v12 = v202;
        uint64_t v123 = v200;
        id v160 = v194;
        goto LABEL_112;
      }
      id v101 = v132;
      id v162 = objc_alloc((Class)NSError);
      id v160 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v222 = NSLocalizedDescriptionKey;
      int v163 = +[NSString stringWithUTF8String:"Security Violation"];
      BOOL v223 = v163;
      __int16 v164 = +[NSDictionary dictionaryWithObjects:&v223 forKeys:&v222 count:1];
      uint64_t v15 = [v162 initWithDomain:v160 code:8 userInfo:v164];

      v198 = 0;
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v147 = NFLogGetLogger();
      if (v147)
      {
        id v148 = (void (*)(uint64_t, const char *, ...))v147;
        uint64_t v149 = object_getClass(a1);
        BOOL v150 = class_isMetaClass(v149);
        id v151 = object_getClassName(a1);
        uint64_t v187 = sel_getName("_authorizeAppletTransaction:forApplet:authType:authorization:uid:");
        uint64_t v152 = 45;
        if (v150) {
          uint64_t v152 = 43;
        }
        v148(3, "%c[%{public}s %{public}s]:%i Failed to get cardChallenge and cardCryptogram from CRS", v152, v151, v187, 782);
      }
      id v101 = v132;
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v153 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v153, OS_LOG_TYPE_ERROR))
      {
        id v154 = object_getClass(a1);
        if (class_isMetaClass(v154)) {
          int v155 = 43;
        }
        else {
          int v155 = 45;
        }
        id v156 = object_getClassName(a1);
        id v157 = sel_getName("_authorizeAppletTransaction:forApplet:authType:authorization:uid:");
        *(_DWORD *)buf = 67109890;
        int v241 = v155;
        __int16 v242 = 2082;
        uint64_t v243 = v156;
        __int16 v244 = 2082;
        v245 = v157;
        __int16 v246 = 1024;
        int v247 = 782;
        _os_log_impl((void *)&_mh_execute_header, v153, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get cardChallenge and cardCryptogram from CRS", buf, 0x22u);
      }

      id v158 = objc_alloc((Class)NSError);
      uint64_t v159 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v224 = NSLocalizedDescriptionKey;
      id v160 = +[NSString stringWithUTF8String:"Commmand Error"];
      v225 = v160;
      id v161 = +[NSDictionary dictionaryWithObjects:&v225 forKeys:&v224 count:1];
      v198 = (void *)v159;
      uint64_t v15 = [v158 initWithDomain:v159 code:16 userInfo:v161];

      uint64_t v21 = 0;
    }
    unsigned int v122 = v201;
    id v12 = v202;
    uint64_t v123 = v200;
LABEL_112:
    int v100 = v130;

    __int16 v67 = v203;
    int v124 = v204;
    long long v121 = v198;
LABEL_113:

    uint64_t v125 = v199;
LABEL_114:

    unsigned int v13 = v209;
    id v11 = v210;
LABEL_115:

    goto LABEL_116;
  }
  uint64_t v15 = 0;
LABEL_116:

  return v15;
}

uint64_t sub_1001F8564(void *a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  id v179 = 0;
  id v4 = [a1 selectCRSWithError:&v179];
  id v5 = v179;
  uint64_t v6 = v5;
  if (v5)
  {
    if ([v5 code]) {
      uint64_t v7 = (uint64_t)[v6 code];
    }
    else {
      uint64_t v7 = 16;
    }
    goto LABEL_152;
  }
  if ((sub_1000C41C4((uint64_t)a1, 0) & 1) == 0)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v9 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("_effaceAuthorization:");
      uint64_t v13 = 45;
      if (isMetaClass) {
        uint64_t v13 = 43;
      }
      v9(4, "%c[%{public}s %{public}s]:%i Failed to mark-all-for-delete", v13, ClassName, Name, 847);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v14 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      uint64_t v15 = object_getClass(a1);
      if (class_isMetaClass(v15)) {
        int v16 = 43;
      }
      else {
        int v16 = 45;
      }
      id v17 = object_getClassName(a1);
      id v18 = sel_getName("_effaceAuthorization:");
      *(_DWORD *)buf = 67109890;
      int v181 = v16;
      __int16 v182 = 2082;
      uint64_t v183 = v17;
      __int16 v184 = 2082;
      v185 = v18;
      __int16 v186 = 1024;
      int v187 = 847;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to mark-all-for-delete", buf, 0x22u);
    }
  }
  int v19 = +[NFSecureElementWrapper isAuthRandomEntangled];
  kdebug_trace();
  uint64_t v20 = NFSharedSignpostLog();
  if (os_signpost_enabled(v20))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v20, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseResetAuthRandom in", buf, 2u);
  }

  uint64_t v21 = [a1 serialNumberAsData];
  id v177 = 0;
  id v178 = 0;
  uint64_t v7 = sub_10021F038((uint64_t)NFSSEWrapper, v21, a2, &v178, &v177, v19);
  id v22 = v178;
  id v23 = v177;

  kdebug_trace();
  uint64_t v24 = NFSharedSignpostLog();
  if (os_signpost_enabled(v24))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v24, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseResetAuthRandom out", buf, 2u);
  }

  if (v7)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v25 = NFLogGetLogger();
    if (v25)
    {
      id v26 = (void (*)(uint64_t, const char *, ...))v25;
      id v27 = object_getClass(a1);
      BOOL v28 = class_isMetaClass(v27);
      id v29 = object_getClassName(a1);
      __int16 v164 = sel_getName("_effaceAuthorization:");
      uint64_t v30 = 45;
      if (v28) {
        uint64_t v30 = 43;
      }
      v26(3, "%c[%{public}s %{public}s]:%i Failed to reset auth random", v30, v29, v164, 862);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v31 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      id v32 = object_getClass(a1);
      id v33 = v22;
      if (class_isMetaClass(v32)) {
        int v34 = 43;
      }
      else {
        int v34 = 45;
      }
      id v35 = object_getClassName(a1);
      BOOL v36 = sel_getName("_effaceAuthorization:");
      *(_DWORD *)buf = 67109890;
      int v181 = v34;
      id v22 = v33;
      __int16 v182 = 2082;
      uint64_t v183 = v35;
      __int16 v184 = 2082;
      v185 = v36;
      __int16 v186 = 1024;
      int v187 = 862;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to reset auth random", buf, 0x22u);
    }
    goto LABEL_151;
  }
  if (v19) {
    uint64_t v37 = sub_1000C46D0(a1, v22, v23);
  }
  else {
    uint64_t v37 = sub_1000C4BCC(a1, v22, v23);
  }
  uint64_t v7 = v37;
  if (v37)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v38 = NFLogGetLogger();
    if (v38)
    {
      BOOL v39 = (void (*)(uint64_t, const char *, ...))v38;
      id v40 = object_getClass(a1);
      BOOL v41 = class_isMetaClass(v40);
      id v42 = object_getClassName(a1);
      unsigned int v43 = sel_getName("_effaceAuthorization:");
      if (v7 >= 0x47) {
        int v44 = 71;
      }
      else {
        int v44 = v7;
      }
      int v169 = off_100306F98[v44];
      uint64_t v45 = 43;
      if (!v41) {
        uint64_t v45 = 45;
      }
      v39(3, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", v45, v42, v43, 873, @"Failed to set auth random", v7, v169);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v31 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      int v46 = object_getClass(a1);
      if (class_isMetaClass(v46)) {
        int v47 = 43;
      }
      else {
        int v47 = 45;
      }
      id v48 = object_getClassName(a1);
      id v49 = sel_getName("_effaceAuthorization:");
      if (v7 >= 0x47) {
        int v50 = 71;
      }
      else {
        int v50 = v7;
      }
      uint64_t v51 = off_100306F98[v50];
      *(_DWORD *)buf = 67110658;
      int v181 = v47;
      __int16 v182 = 2082;
      uint64_t v183 = v48;
      __int16 v184 = 2082;
      v185 = v49;
      __int16 v186 = 1024;
      int v187 = 873;
      __int16 v188 = 2112;
      CFStringRef v189 = @"Failed to set auth random";
      __int16 v190 = 1024;
      int v191 = v7;
      __int16 v192 = 2080;
      id v193 = v51;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", buf, 0x3Cu);
    }
    goto LABEL_151;
  }
  kdebug_trace();
  int v52 = NFSharedSignpostLog();
  if (os_signpost_enabled(v52))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v52, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseGetHostChallenge in", buf, 2u);
  }

  id v176 = 0;
  unsigned int v53 = sub_10021F7F0((uint64_t)NFSSEWrapper, &v176);
  id v31 = v176;
  kdebug_trace();
  uint64_t v54 = NFSharedSignpostLog();
  if (os_signpost_enabled(v54))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v54, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseGetHostChallenge out", buf, 2u);
  }

  if (!v31 || v53)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v72 = NFLogGetLogger();
    if (v72)
    {
      id v73 = (void (*)(uint64_t, const char *, ...))v72;
      uint64_t v74 = object_getClass(a1);
      BOOL v75 = class_isMetaClass(v74);
      uint64_t v76 = object_getClassName(a1);
      uint64_t v165 = sel_getName("_effaceAuthorization:");
      uint64_t v77 = 45;
      if (v75) {
        uint64_t v77 = 43;
      }
      v73(3, "%c[%{public}s %{public}s]:%i Failed to get host challenge", v77, v76, v165, 885);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v78 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
    {
      int v79 = object_getClass(a1);
      id v80 = v22;
      if (class_isMetaClass(v79)) {
        int v81 = 43;
      }
      else {
        int v81 = 45;
      }
      unsigned int v82 = object_getClassName(a1);
      id v83 = sel_getName("_effaceAuthorization:");
      *(_DWORD *)buf = 67109890;
      int v181 = v81;
      id v22 = v80;
      __int16 v182 = 2082;
      uint64_t v183 = v82;
      __int16 v184 = 2082;
      v185 = v83;
      __int16 v186 = 1024;
      int v187 = 885;
      _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get host challenge", buf, 0x22u);
    }

    if (v53) {
      uint64_t v7 = v53;
    }
    else {
      uint64_t v7 = 6;
    }
    goto LABEL_151;
  }
  if ([v31 length] != (id)8)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v84 = NFLogGetLogger();
    if (v84)
    {
      __int16 v85 = (void (*)(uint64_t, const char *, ...))v84;
      uint64_t v86 = object_getClass(a1);
      BOOL v87 = class_isMetaClass(v86);
      uint64_t v88 = object_getClassName(a1);
      BOOL v89 = sel_getName("_effaceAuthorization:");
      id v167 = [v31 length];
      uint64_t v90 = 45;
      if (v87) {
        uint64_t v90 = 43;
      }
      v85(3, "%c[%{public}s %{public}s]:%i Invalid host challenge length: %lu", v90, v88, v89, 891, v167);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v91 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v91, OS_LOG_TYPE_ERROR))
    {
      int v92 = object_getClass(a1);
      id v93 = v22;
      if (class_isMetaClass(v92)) {
        int v94 = 43;
      }
      else {
        int v94 = 45;
      }
      __int16 v95 = object_getClassName(a1);
      int v96 = sel_getName("_effaceAuthorization:");
      CFStringRef v97 = (const __CFString *)[v31 length];
      *(_DWORD *)buf = 67110146;
      int v181 = v94;
      id v22 = v93;
      __int16 v182 = 2082;
      uint64_t v183 = v95;
      __int16 v184 = 2082;
      v185 = v96;
      __int16 v186 = 1024;
      int v187 = 891;
      __int16 v188 = 2048;
      CFStringRef v189 = v97;
      _os_log_impl((void *)&_mh_execute_header, v91, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid host challenge length: %lu", buf, 0x2Cu);
    }

    uint64_t v7 = 13;
    goto LABEL_151;
  }
  id v175 = 0;
  uint64_t v7 = sub_1000C5684(a1, v31, &v175);
  id v55 = v175;
  id v172 = v55;
  if (v7)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v56 = NFLogGetLogger();
    if (v56)
    {
      int v57 = (void (*)(uint64_t, const char *, ...))v56;
      BOOL v58 = object_getClass(a1);
      BOOL v59 = class_isMetaClass(v58);
      int v60 = object_getClassName(a1);
      uint64_t v61 = sel_getName("_effaceAuthorization:");
      if (v7 >= 0x47) {
        int v62 = 71;
      }
      else {
        int v62 = v7;
      }
      uint64_t v170 = off_100306F98[v62];
      uint64_t v63 = 43;
      if (!v59) {
        uint64_t v63 = 45;
      }
      v57(3, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", v63, v60, v61, 899, @"Failed to authenticate", v7, v170);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v64 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
    {
      int v65 = object_getClass(a1);
      id v66 = v22;
      if (class_isMetaClass(v65)) {
        int v67 = 43;
      }
      else {
        int v67 = 45;
      }
      uint64_t v68 = object_getClassName(a1);
      uint64_t v69 = sel_getName("_effaceAuthorization:");
      if (v7 >= 0x47) {
        int v70 = 71;
      }
      else {
        int v70 = v7;
      }
      BOOL v71 = off_100306F98[v70];
      *(_DWORD *)buf = 67110658;
      int v181 = v67;
      id v22 = v66;
      __int16 v182 = 2082;
      uint64_t v183 = v68;
      __int16 v184 = 2082;
      v185 = v69;
      __int16 v186 = 1024;
      int v187 = 899;
      __int16 v188 = 2112;
      CFStringRef v189 = @"Failed to authenticate";
      __int16 v190 = 1024;
      int v191 = v7;
      __int16 v192 = 2080;
      id v193 = v71;
      _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", buf, 0x3Cu);
    }

    goto LABEL_150;
  }
  if ([v55 length] != (id)16)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v118 = NFLogGetLogger();
    if (v118)
    {
      id v119 = (void (*)(uint64_t, const char *, ...))v118;
      uint64_t v120 = object_getClass(a1);
      BOOL v121 = class_isMetaClass(v120);
      unsigned int v122 = object_getClassName(a1);
      uint64_t v123 = sel_getName("_effaceAuthorization:");
      id v168 = [v172 length];
      uint64_t v124 = 45;
      if (v121) {
        uint64_t v124 = 43;
      }
      v119(3, "%c[%{public}s %{public}s]:%i Invalid authenticate response length: %lu", v124, v122, v123, 903, v168);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v125 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v125, OS_LOG_TYPE_ERROR))
    {
      id v126 = object_getClass(a1);
      id v127 = v22;
      if (class_isMetaClass(v126)) {
        int v128 = 43;
      }
      else {
        int v128 = 45;
      }
      uint64_t v129 = object_getClassName(a1);
      BOOL v130 = sel_getName("_effaceAuthorization:");
      CFStringRef v131 = (const __CFString *)[v172 length];
      *(_DWORD *)buf = 67110146;
      int v181 = v128;
      id v22 = v127;
      __int16 v182 = 2082;
      uint64_t v183 = v129;
      __int16 v184 = 2082;
      v185 = v130;
      __int16 v186 = 1024;
      int v187 = 903;
      __int16 v188 = 2048;
      CFStringRef v189 = v131;
      _os_log_impl((void *)&_mh_execute_header, v125, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid authenticate response length: %lu", buf, 0x2Cu);
    }

    uint64_t v7 = 13;
    goto LABEL_150;
  }
  unsigned __int16 v174 = 0;
  kdebug_trace();
  uint64_t v98 = NFSharedSignpostLog();
  if (os_signpost_enabled(v98))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v98, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseGetAuthorizationTimeout in", buf, 2u);
  }

  int v99 = [a1 serialNumberAsData];
  id v173 = v23;
  int v100 = sub_10021F55C((uint64_t)NFSSEWrapper, v99, a2, v31, v172, &v174, &v173);
  id v101 = v173;

  kdebug_trace();
  uint64_t v102 = NFSharedSignpostLog();
  if (os_signpost_enabled(v102))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v102, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseGetAuthorizationTimeout out", buf, 2u);
  }

  if (v100)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v103 = NFLogGetLogger();
    if (v103)
    {
      uint64_t v104 = (void (*)(uint64_t, const char *, ...))v103;
      BOOL v105 = object_getClass(a1);
      BOOL v106 = class_isMetaClass(v105);
      v107 = object_getClassName(a1);
      __int16 v166 = sel_getName("_effaceAuthorization:");
      uint64_t v108 = 45;
      if (v106) {
        uint64_t v108 = 43;
      }
      v104(4, "%c[%{public}s %{public}s]:%i Failed to get auth timeout", v108, v107, v166, 921);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    BOOL v109 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v109, OS_LOG_TYPE_ERROR)) {
      goto LABEL_148;
    }
    uint64_t v110 = object_getClass(a1);
    id v111 = v22;
    if (class_isMetaClass(v110)) {
      int v112 = 43;
    }
    else {
      int v112 = 45;
    }
    uint64_t v113 = object_getClassName(a1);
    uint64_t v114 = sel_getName("_effaceAuthorization:");
    *(_DWORD *)buf = 67109890;
    int v181 = v112;
    id v22 = v111;
    __int16 v182 = 2082;
    uint64_t v183 = v113;
    __int16 v184 = 2082;
    v185 = v114;
    __int16 v186 = 1024;
    int v187 = 921;
    int v115 = "%c[%{public}s %{public}s]:%i Failed to get auth timeout";
    BOOL v116 = v109;
    uint32_t v117 = 34;
LABEL_147:
    _os_log_impl((void *)&_mh_execute_header, v116, OS_LOG_TYPE_ERROR, v115, buf, v117);
LABEL_148:

    goto LABEL_149;
  }
  uint64_t v132 = sub_1000C5100(a1, v174, v31, v101);
  if (v132)
  {
    uint64_t v133 = v132;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v134 = NFLogGetLogger();
    if (v134)
    {
      int v135 = (void (*)(uint64_t, const char *, ...))v134;
      __int16 v136 = object_getClass(a1);
      BOOL v137 = class_isMetaClass(v136);
      uint64_t v138 = object_getClassName(a1);
      CFStringRef v139 = sel_getName("_effaceAuthorization:");
      uint64_t v140 = 45;
      if (v137) {
        uint64_t v140 = 43;
      }
      v135(4, "%c[%{public}s %{public}s]:%i Failed to set auth timeout = %d", v140, v138, v139, 930, v174);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v141 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v141, OS_LOG_TYPE_ERROR))
    {
      NSErrorUserInfoKey v142 = object_getClass(a1);
      id v143 = v22;
      if (class_isMetaClass(v142)) {
        int v144 = 43;
      }
      else {
        int v144 = 45;
      }
      v145 = object_getClassName(a1);
      v146 = sel_getName("_effaceAuthorization:");
      *(_DWORD *)buf = 67110146;
      int v181 = v144;
      id v22 = v143;
      __int16 v182 = 2082;
      uint64_t v183 = v145;
      __int16 v184 = 2082;
      v185 = v146;
      __int16 v186 = 1024;
      int v187 = 930;
      __int16 v188 = 1024;
      LODWORD(v189) = v174;
      _os_log_impl((void *)&_mh_execute_header, v141, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set auth timeout = %d", buf, 0x28u);
    }

    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v147 = NFLogGetLogger();
    if (v147)
    {
      id v148 = (void (*)(uint64_t, const char *, ...))v147;
      uint64_t v149 = object_getClass(a1);
      BOOL v150 = class_isMetaClass(v149);
      id v151 = object_getClassName(a1);
      uint64_t v152 = sel_getName("_effaceAuthorization:");
      if (v133 >= 0x47) {
        int v153 = 71;
      }
      else {
        int v153 = v133;
      }
      CFStringRef v171 = off_100306F98[v153];
      uint64_t v154 = 43;
      if (!v150) {
        uint64_t v154 = 45;
      }
      v148(3, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", v154, v151, v152, 931, @"Returned", v133, v171);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    BOOL v109 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v109, OS_LOG_TYPE_ERROR)) {
      goto LABEL_148;
    }
    int v155 = object_getClass(a1);
    id v156 = v22;
    if (class_isMetaClass(v155)) {
      int v157 = 43;
    }
    else {
      int v157 = 45;
    }
    id v158 = object_getClassName(a1);
    uint64_t v159 = sel_getName("_effaceAuthorization:");
    if (v133 >= 0x47) {
      int v160 = 71;
    }
    else {
      int v160 = v133;
    }
    id v161 = off_100306F98[v160];
    *(_DWORD *)buf = 67110658;
    int v181 = v157;
    id v22 = v156;
    __int16 v182 = 2082;
    uint64_t v183 = v158;
    __int16 v184 = 2082;
    v185 = v159;
    __int16 v186 = 1024;
    int v187 = 931;
    __int16 v188 = 2112;
    CFStringRef v189 = @"Returned";
    __int16 v190 = 1024;
    int v191 = v133;
    __int16 v192 = 2080;
    id v193 = v161;
    int v115 = "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"";
    BOOL v116 = v109;
    uint32_t v117 = 60;
    goto LABEL_147;
  }
LABEL_149:
  uint64_t v7 = 0;
  id v23 = v101;
LABEL_150:

LABEL_151:
LABEL_152:

  return v7;
}

uint64_t sub_1001F97B4(void *a1, void *a2, uint64_t a3, void *a4)
{
  id v7 = a2;
  double v8 = v7;
  if (!a1)
  {
    uint64_t v27 = 0;
    goto LABEL_65;
  }
  if (!v7)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v20 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("signChallenge:authenticationType:value:");
      uint64_t v24 = 45;
      if (isMetaClass) {
        uint64_t v24 = 43;
      }
      v20(3, "%c[%{public}s %{public}s]:%i Invalid challenge string", v24, ClassName, Name, 947);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v15 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    uint64_t v25 = object_getClass(a1);
    if (class_isMetaClass(v25)) {
      int v26 = 43;
    }
    else {
      int v26 = 45;
    }
    *(_DWORD *)buf = 67109890;
    int v75 = v26;
    __int16 v76 = 2082;
    uint64_t v77 = object_getClassName(a1);
    __int16 v78 = 2082;
    int v79 = sel_getName("signChallenge:authenticationType:value:");
    __int16 v80 = 1024;
    int v81 = 947;
    id v18 = "%c[%{public}s %{public}s]:%i Invalid challenge string";
    goto LABEL_22;
  }
  if ((unint64_t)[v7 length] < 0xB1)
  {
    id v28 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284478 length:12];
    id v73 = 0;
    id v29 = [a1 selectByName:v28 error:&v73];
    uint64_t v15 = v73;

    if (v29)
    {
      if ([v29 status] == 36864)
      {
        uint64_t v30 = sub_1000A39CC(a1, (uint64_t)v8, a3);
        id v31 = v30;
        if (v30)
        {
          uint64_t v27 = 0;
          *a4 = v30;
        }
        else
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v55 = NFLogGetLogger();
          if (v55)
          {
            uint64_t v56 = (void (*)(uint64_t, const char *, ...))v55;
            int v57 = object_getClass(a1);
            BOOL v58 = class_isMetaClass(v57);
            BOOL v59 = object_getClassName(a1);
            BOOL v71 = sel_getName("signChallenge:authenticationType:value:");
            uint64_t v60 = 45;
            if (v58) {
              uint64_t v60 = 43;
            }
            v56(3, "%c[%{public}s %{public}s]:%i Failed to get signature", v60, v59, v71, 973);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v61 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
          {
            int v62 = object_getClass(a1);
            if (class_isMetaClass(v62)) {
              int v63 = 43;
            }
            else {
              int v63 = 45;
            }
            id v64 = object_getClassName(a1);
            int v65 = sel_getName("signChallenge:authenticationType:value:");
            *(_DWORD *)buf = 67109890;
            int v75 = v63;
            __int16 v76 = 2082;
            uint64_t v77 = v64;
            __int16 v78 = 2082;
            int v79 = v65;
            __int16 v80 = 1024;
            int v81 = 973;
            _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get signature", buf, 0x22u);
          }

          uint64_t v27 = 16;
        }
      }
      else
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v42 = NFLogGetLogger();
        if (v42)
        {
          unsigned int v43 = (void (*)(uint64_t, const char *, ...))v42;
          int v44 = object_getClass(a1);
          BOOL v45 = class_isMetaClass(v44);
          int v46 = object_getClassName(a1);
          int v47 = sel_getName("signChallenge:authenticationType:value:");
          uint64_t v72 = [v29 status];
          uint64_t v48 = 45;
          if (v45) {
            uint64_t v48 = 43;
          }
          v43(3, "%c[%{public}s %{public}s]:%i Failed to select CASD: 0x%04x", v48, v46, v47, 963, v72);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v49 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
        {
          int v50 = object_getClass(a1);
          if (class_isMetaClass(v50)) {
            int v51 = 43;
          }
          else {
            int v51 = 45;
          }
          int v52 = object_getClassName(a1);
          unsigned int v53 = sel_getName("signChallenge:authenticationType:value:");
          unsigned int v54 = [v29 status];
          *(_DWORD *)buf = 67110146;
          int v75 = v51;
          __int16 v76 = 2082;
          uint64_t v77 = v52;
          __int16 v78 = 2082;
          int v79 = v53;
          __int16 v80 = 1024;
          int v81 = 963;
          __int16 v82 = 1024;
          LODWORD(v83) = v54;
          _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select CASD: 0x%04x", buf, 0x28u);
        }

        if ([v29 status] == 26277) {
          uint64_t v27 = 24;
        }
        else {
          uint64_t v27 = 16;
        }
      }
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v32 = NFLogGetLogger();
      if (v32)
      {
        id v33 = (void (*)(uint64_t, const char *, ...))v32;
        int v34 = object_getClass(a1);
        BOOL v35 = class_isMetaClass(v34);
        int v67 = object_getClassName(a1);
        int v70 = sel_getName("signChallenge:authenticationType:value:");
        uint64_t v36 = 45;
        if (v35) {
          uint64_t v36 = 43;
        }
        v33(3, "%c[%{public}s %{public}s]:%i Failed to select CRS: %{public}@", v36, v67, v70, 959, v15);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v37 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
      {
        uint64_t v38 = object_getClass(a1);
        if (class_isMetaClass(v38)) {
          int v39 = 43;
        }
        else {
          int v39 = 45;
        }
        id v40 = object_getClassName(a1);
        BOOL v41 = sel_getName("signChallenge:authenticationType:value:");
        *(_DWORD *)buf = 67110146;
        int v75 = v39;
        __int16 v76 = 2082;
        uint64_t v77 = v40;
        __int16 v78 = 2082;
        int v79 = v41;
        __int16 v80 = 1024;
        int v81 = 959;
        __int16 v82 = 2114;
        id v83 = v15;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select CRS: %{public}@", buf, 0x2Cu);
      }

      if ([v15 code]) {
        uint64_t v27 = (uint64_t)[v15 code];
      }
      else {
        uint64_t v27 = 16;
      }
    }

    goto LABEL_64;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFLogGetLogger();
  if (v9)
  {
    id v10 = (void (*)(uint64_t, const char *, ...))v9;
    id v11 = object_getClass(a1);
    BOOL v12 = class_isMetaClass(v11);
    uint64_t v13 = object_getClassName(a1);
    uint64_t v68 = sel_getName("signChallenge:authenticationType:value:");
    uint64_t v14 = 45;
    if (v12) {
      uint64_t v14 = 43;
    }
    v10(3, "%c[%{public}s %{public}s]:%i challenge for signing is too large", v14, v13, v68, 951);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v15 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    int v16 = object_getClass(a1);
    if (class_isMetaClass(v16)) {
      int v17 = 43;
    }
    else {
      int v17 = 45;
    }
    *(_DWORD *)buf = 67109890;
    int v75 = v17;
    __int16 v76 = 2082;
    uint64_t v77 = object_getClassName(a1);
    __int16 v78 = 2082;
    int v79 = sel_getName("signChallenge:authenticationType:value:");
    __int16 v80 = 1024;
    int v81 = 951;
    id v18 = "%c[%{public}s %{public}s]:%i challenge for signing is too large";
LABEL_22:
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, v18, buf, 0x22u);
  }
LABEL_23:
  uint64_t v27 = 10;
LABEL_64:

LABEL_65:
  return v27;
}

id sub_1001F9EEC(id a1, void *a2, void *a3)
{
  id v3 = a1;
  if (a1)
  {
    if (a2 && a3)
    {
      id v43 = 0;
      uint64_t v6 = [a1 serialNumberAsData];
      id v7 = sub_10022156C((uint64_t)NFSSEWrapper, &v43, v6);
      id v8 = v43;

      if (v7)
      {
        id v9 = v7;
LABEL_31:
        id v3 = v9;

        id v8 = v3;
        goto LABEL_32;
      }
      if ((unint64_t)[v8 length] > 0xF)
      {
        id v42 = 0;
        id v37 = [v3 selectCRSWithError:&v42];
        id v38 = v42;
        if (!v38)
        {
          sub_1000C855C(v3, v8, a3);
          id v38 = (id)objc_claimAutoreleasedReturnValue();
          if (!v38)
          {
            [v8 subdataWithRange:0, (char *)[v8 length] - 16];
            id v3 = 0;
            *a2 = (id)objc_claimAutoreleasedReturnValue();
            goto LABEL_32;
          }
        }
        id v9 = v38;
        goto LABEL_31;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        id v23 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(v3);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(v3);
        Name = sel_getName("getPlatformData:withSignature:");
        id v41 = [v8 length];
        uint64_t v28 = 45;
        if (isMetaClass) {
          uint64_t v28 = 43;
        }
        v23(3, "%c[%{public}s %{public}s]:%i Invalid platform data length %lu", v28, ClassName, Name, 998, v41);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v29 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        uint64_t v30 = object_getClass(v3);
        if (class_isMetaClass(v30)) {
          int v31 = 43;
        }
        else {
          int v31 = 45;
        }
        uint64_t v32 = object_getClassName(v3);
        id v33 = sel_getName("getPlatformData:withSignature:");
        id v34 = [v8 length];
        *(_DWORD *)buf = 67110146;
        int v47 = v31;
        __int16 v48 = 2082;
        id v49 = v32;
        __int16 v50 = 2082;
        int v51 = v33;
        __int16 v52 = 1024;
        int v53 = 998;
        __int16 v54 = 2048;
        id v55 = v34;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid platform data length %lu", buf, 0x2Cu);
      }

      id v35 = objc_alloc((Class)NSError);
      uint64_t v20 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v44 = NSLocalizedDescriptionKey;
      uint64_t v21 = +[NSString stringWithUTF8String:"Unexpected Result"];
      BOOL v45 = v21;
      uint64_t v36 = +[NSDictionary dictionaryWithObjects:&v45 forKeys:&v44 count:1];
      id v3 = [v35 initWithDomain:v20 code:13 userInfo:v36];
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v10 = NFLogGetLogger();
      if (v10)
      {
        id v11 = (void (*)(uint64_t, const char *, ...))v10;
        BOOL v12 = object_getClass(v3);
        BOOL v13 = class_isMetaClass(v12);
        uint64_t v14 = object_getClassName(v3);
        id v40 = sel_getName("getPlatformData:withSignature:");
        uint64_t v15 = 45;
        if (v13) {
          uint64_t v15 = 43;
        }
        v11(3, "%c[%{public}s %{public}s]:%i Invalid parameter", v15, v14, v40, 987);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v16 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      {
        int v17 = object_getClass(v3);
        if (class_isMetaClass(v17)) {
          int v18 = 43;
        }
        else {
          int v18 = 45;
        }
        *(_DWORD *)buf = 67109890;
        int v47 = v18;
        __int16 v48 = 2082;
        id v49 = object_getClassName(v3);
        __int16 v50 = 2082;
        int v51 = sel_getName("getPlatformData:withSignature:");
        __int16 v52 = 1024;
        int v53 = 987;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid parameter", buf, 0x22u);
      }

      id v19 = objc_alloc((Class)NSError);
      id v8 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v56 = NSLocalizedDescriptionKey;
      uint64_t v20 = +[NSString stringWithUTF8String:"Invalid Parameter"];
      int v57 = v20;
      uint64_t v21 = +[NSDictionary dictionaryWithObjects:&v57 forKeys:&v56 count:1];
      id v3 = [v19 initWithDomain:v8 code:10 userInfo:v21];
    }

LABEL_32:
  }

  return v3;
}

uint64_t sub_1001FA3F0(void *a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(a1);
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(a1);
    Name = sel_getName("_validateSEAndSEPPairing:");
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v5(6, "%c[%{public}s %{public}s]:%i Validating pairing for uid %d", v8, ClassName, Name, 1022, a2);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = object_getClass(a1);
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    *(_DWORD *)buf = 67110146;
    int v110 = v11;
    __int16 v111 = 2082;
    int v112 = object_getClassName(a1);
    __int16 v113 = 2082;
    uint64_t v114 = sel_getName("_validateSEAndSEPPairing:");
    __int16 v115 = 1024;
    int v116 = 1022;
    __int16 v117 = 1024;
    LODWORD(v118) = a2;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Validating pairing for uid %d", buf, 0x28u);
  }

  kdebug_trace();
  BOOL v12 = NFSharedSignpostLog();
  if (os_signpost_enabled(v12))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v12, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseGetHostChallenge in", buf, 2u);
  }

  id v108 = 0;
  unsigned int v13 = sub_10021F7F0((uint64_t)NFSSEWrapper, &v108);
  id v14 = v108;
  kdebug_trace();
  uint64_t v15 = NFSharedSignpostLog();
  if (os_signpost_enabled(v15))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseGetHostChallenge out", buf, 2u);
  }

  if (!v14 || v13)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v20 = NFLogGetLogger();
    if (v20)
    {
      uint64_t v21 = (void (*)(uint64_t, const char *, ...))v20;
      id v22 = object_getClass(a1);
      BOOL v23 = class_isMetaClass(v22);
      uint64_t v24 = object_getClassName(a1);
      CFStringRef v97 = sel_getName("_validateSEAndSEPPairing:");
      uint64_t v25 = 45;
      if (v23) {
        uint64_t v25 = 43;
      }
      v21(3, "%c[%{public}s %{public}s]:%i Failed to get host challenge", v25, v24, v97, 1032);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v26 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      uint64_t v27 = object_getClass(a1);
      if (class_isMetaClass(v27)) {
        int v28 = 43;
      }
      else {
        int v28 = 45;
      }
      id v29 = object_getClassName(a1);
      uint64_t v30 = sel_getName("_validateSEAndSEPPairing:");
      *(_DWORD *)buf = 67109890;
      int v110 = v28;
      __int16 v111 = 2082;
      int v112 = v29;
      __int16 v113 = 2082;
      uint64_t v114 = v30;
      __int16 v115 = 1024;
      int v116 = 1032;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get host challenge", buf, 0x22u);
    }

    if (v13) {
      uint64_t v19 = v13;
    }
    else {
      uint64_t v19 = 6;
    }
    goto LABEL_79;
  }
  if ([v14 length] != (id)8)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v31 = NFLogGetLogger();
    if (v31)
    {
      uint64_t v32 = (void (*)(uint64_t, const char *, ...))v31;
      id v33 = object_getClass(a1);
      BOOL v34 = class_isMetaClass(v33);
      id v35 = object_getClassName(a1);
      uint64_t v36 = sel_getName("_validateSEAndSEPPairing:");
      id v100 = [v14 length];
      uint64_t v37 = 45;
      if (v34) {
        uint64_t v37 = 43;
      }
      v32(3, "%c[%{public}s %{public}s]:%i Invalid host challenge length: %lu", v37, v35, v36, 1036, v100);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v38 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
    {
      int v39 = object_getClass(a1);
      if (class_isMetaClass(v39)) {
        int v40 = 43;
      }
      else {
        int v40 = 45;
      }
      id v41 = object_getClassName(a1);
      id v42 = sel_getName("_validateSEAndSEPPairing:");
      CFStringRef v43 = (const __CFString *)[v14 length];
      *(_DWORD *)buf = 67110146;
      int v110 = v40;
      __int16 v111 = 2082;
      int v112 = v41;
      __int16 v113 = 2082;
      uint64_t v114 = v42;
      __int16 v115 = 1024;
      int v116 = 1036;
      __int16 v117 = 2048;
      CFStringRef v118 = v43;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid host challenge length: %lu", buf, 0x2Cu);
    }

    uint64_t v19 = 13;
    goto LABEL_79;
  }
  id v107 = 0;
  id v16 = [a1 selectCRSWithError:&v107];
  id v17 = v107;
  int v18 = v17;
  if (v17)
  {
    if ([v17 code]) {
      uint64_t v19 = (uint64_t)[v18 code];
    }
    else {
      uint64_t v19 = 16;
    }
    goto LABEL_78;
  }
  id v106 = 0;
  uint64_t v19 = sub_1000C5684(a1, v14, &v106);
  id v44 = v106;
  BOOL v45 = v44;
  if (v19)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v46 = NFLogGetLogger();
    if (v46)
    {
      int v47 = (void (*)(uint64_t, const char *, ...))v46;
      __int16 v48 = object_getClass(a1);
      BOOL v49 = class_isMetaClass(v48);
      __int16 v50 = v45;
      int v51 = object_getClassName(a1);
      __int16 v52 = sel_getName("_validateSEAndSEPPairing:");
      if (v19 >= 0x47) {
        int v53 = 71;
      }
      else {
        int v53 = v19;
      }
      uint64_t v102 = off_100306F98[v53];
      int v94 = v51;
      uint64_t v54 = 43;
      if (!v49) {
        uint64_t v54 = 45;
      }
      BOOL v45 = v50;
      v47(3, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", v54, v94, v52, 1050, @"Failed to authenticate", v19, v102);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v55 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      NSErrorUserInfoKey v56 = object_getClass(a1);
      if (class_isMetaClass(v56)) {
        int v57 = 43;
      }
      else {
        int v57 = 45;
      }
      BOOL v58 = object_getClassName(a1);
      BOOL v59 = sel_getName("_validateSEAndSEPPairing:");
      if (v19 >= 0x47) {
        int v60 = 71;
      }
      else {
        int v60 = v19;
      }
      uint64_t v61 = off_100306F98[v60];
      *(_DWORD *)buf = 67110658;
      int v110 = v57;
      __int16 v111 = 2082;
      int v112 = v58;
      __int16 v113 = 2082;
      uint64_t v114 = v59;
      __int16 v115 = 1024;
      int v116 = 1050;
      __int16 v117 = 2112;
      CFStringRef v118 = @"Failed to authenticate";
      __int16 v119 = 1024;
      int v120 = v19;
      __int16 v121 = 2080;
      unsigned int v122 = v61;
      _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", buf, 0x3Cu);
    }
  }
  else
  {
    if ([v44 length] != (id)16)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v79 = NFLogGetLogger();
      if (v79)
      {
        __int16 v80 = (void (*)(uint64_t, const char *, ...))v79;
        int v81 = object_getClass(a1);
        BOOL v82 = class_isMetaClass(v81);
        id v83 = object_getClassName(a1);
        uint64_t v84 = v45;
        __int16 v85 = sel_getName("_validateSEAndSEPPairing:");
        id v101 = [v84 length];
        int v99 = v85;
        BOOL v45 = v84;
        uint64_t v86 = 45;
        if (v82) {
          uint64_t v86 = 43;
        }
        v80(3, "%c[%{public}s %{public}s]:%i Invalid authenticate response length: %lu", v86, v83, v99, 1054, v101);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      BOOL v87 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v87, OS_LOG_TYPE_ERROR))
      {
        uint64_t v88 = object_getClass(a1);
        if (class_isMetaClass(v88)) {
          int v89 = 43;
        }
        else {
          int v89 = 45;
        }
        uint64_t v90 = object_getClassName(a1);
        uint64_t v91 = sel_getName("_validateSEAndSEPPairing:");
        CFStringRef v92 = (const __CFString *)[v45 length];
        *(_DWORD *)buf = 67110146;
        int v110 = v89;
        __int16 v111 = 2082;
        int v112 = v90;
        __int16 v113 = 2082;
        uint64_t v114 = v91;
        __int16 v115 = 1024;
        int v116 = 1054;
        __int16 v117 = 2048;
        CFStringRef v118 = v92;
        _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid authenticate response length: %lu", buf, 0x2Cu);
      }

      uint64_t v19 = 13;
      goto LABEL_77;
    }
    unsigned __int16 v105 = 0;
    kdebug_trace();
    int v62 = NFSharedSignpostLog();
    if (os_signpost_enabled(v62))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v62, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseGetAuthorizationTimeout in", buf, 2u);
    }

    int v63 = [a1 serialNumberAsData];
    id v104 = 0;
    uint64_t v19 = sub_10021F55C((uint64_t)NFSSEWrapper, v63, a2, v14, v45, &v105, &v104);
    id v55 = v104;

    kdebug_trace();
    id v64 = NFSharedSignpostLog();
    if (os_signpost_enabled(v64))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v64, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseGetAuthorizationTimeout out", buf, 2u);
    }

    if (v19)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v65 = NFLogGetLogger();
      if (v65)
      {
        id v66 = (void (*)(uint64_t, const char *, ...))v65;
        int v67 = object_getClass(a1);
        uint64_t v68 = v45;
        BOOL v69 = class_isMetaClass(v67);
        uint64_t v103 = v55;
        int v70 = object_getClassName(a1);
        uint64_t v98 = sel_getName("_validateSEAndSEPPairing:");
        BOOL v71 = !v69;
        BOOL v45 = v68;
        uint64_t v72 = 45;
        if (!v71) {
          uint64_t v72 = 43;
        }
        __int16 v95 = v70;
        id v55 = v103;
        v66(3, "%c[%{public}s %{public}s]:%i Failed to validate challenge response", v72, v95, v98, 1073);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v73 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
      {
        uint64_t v74 = object_getClass(a1);
        if (class_isMetaClass(v74)) {
          int v75 = 43;
        }
        else {
          int v75 = 45;
        }
        __int16 v76 = object_getClassName(a1);
        uint64_t v77 = sel_getName("_validateSEAndSEPPairing:");
        *(_DWORD *)buf = 67109890;
        int v110 = v75;
        __int16 v111 = 2082;
        int v112 = v76;
        __int16 v113 = 2082;
        uint64_t v114 = v77;
        __int16 v115 = 1024;
        int v116 = 1073;
        _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to validate challenge response", buf, 0x22u);
      }
    }
  }

LABEL_77:
LABEL_78:

LABEL_79:
  return v19;
}

id sub_1001FAED8(void *a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  id v4 = sub_1001FAF54(a1);
  id v5 = v4;
  if (v4)
  {
    id v6 = [v4 code];
  }
  else
  {
    id v6 = (id)sub_1001FA3F0(a1, a2);
    if (!v6) {
      [a1 storePairedState];
    }
  }

  return v6;
}

id sub_1001FAF54(id a1)
{
  id v1 = a1;
  if (a1)
  {
    unint64_t v2 = [a1 serialNumberAsData];
    if ([v1 upgradeChecked])
    {
      id v1 = 0;
LABEL_140:

      goto LABEL_141;
    }
    if (([v1 jcopSupportsEntanglement] & 1) == 0)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        uint64_t v21 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(v1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(v1);
        Name = sel_getName("upgradeAuthRandom");
        uint64_t v25 = 45;
        if (isMetaClass) {
          uint64_t v25 = 43;
        }
        v21(6, "%c[%{public}s %{public}s]:%i JCOP doesn't support entanglement", v25, ClassName, Name, 1507);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v26 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_27;
      }
      uint64_t v27 = object_getClass(v1);
      if (class_isMetaClass(v27)) {
        int v28 = 43;
      }
      else {
        int v28 = 45;
      }
      *(_DWORD *)buf = 67109890;
      int v319 = v28;
      __int16 v320 = 2082;
      v321 = object_getClassName(v1);
      __int16 v322 = 2082;
      int v323 = sel_getName("upgradeAuthRandom");
      __int16 v324 = 1024;
      int v325 = 1507;
      id v29 = "%c[%{public}s %{public}s]:%i JCOP doesn't support entanglement";
LABEL_26:
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, v29, buf, 0x22u);
LABEL_27:

LABEL_28:
      id v30 = 0;
      id v31 = 0;
LABEL_29:
      id v6 = 0;
LABEL_51:
      [v1 setUpgradeChecked:1];
LABEL_139:
      id v1 = v6;

      goto LABEL_140;
    }
    p_info = NFHeadlessModeController.info;
    id v297 = 0;
    BOOL v4 = sub_10021E3E0((uint64_t)NFSSEWrapper, &v297);
    id v5 = v297;
    id v6 = v5;
    if (!v4 || v5)
    {
      if (v5 && [v5 code] == (id)41)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v32 = NFLogGetLogger();
        if (v32)
        {
          id v33 = (void (*)(uint64_t, const char *, ...))v32;
          BOOL v34 = object_getClass(v1);
          BOOL v35 = class_isMetaClass(v34);
          uint64_t v36 = object_getClassName(v1);
          id v276 = sel_getName("upgradeAuthRandom");
          uint64_t v37 = 45;
          if (v35) {
            uint64_t v37 = 43;
          }
          v33(6, "%c[%{public}s %{public}s]:%i SSE isn't ready", v37, v36, v276, 1513);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v38 = NFSharedLogGetLogger();
        if (!os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_137;
        }
        int v39 = object_getClass(v1);
        if (class_isMetaClass(v39)) {
          int v40 = 43;
        }
        else {
          int v40 = 45;
        }
        id v41 = object_getClassName(v1);
        id v42 = sel_getName("upgradeAuthRandom");
        *(_DWORD *)buf = 67109890;
        int v319 = v40;
        __int16 v320 = 2082;
        v321 = v41;
        __int16 v322 = 2082;
        int v323 = v42;
        __int16 v324 = 1024;
        int v325 = 1513;
        CFStringRef v43 = "%c[%{public}s %{public}s]:%i SSE isn't ready";
        id v44 = v38;
        os_log_type_t v45 = OS_LOG_TYPE_DEFAULT;
        goto LABEL_136;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v46 = NFLogGetLogger();
      if (v46)
      {
        int v47 = (void (*)(uint64_t, const char *, ...))v46;
        __int16 v48 = object_getClass(v1);
        BOOL v49 = class_isMetaClass(v48);
        uint64_t v272 = object_getClassName(v1);
        v277 = sel_getName("upgradeAuthRandom");
        uint64_t v50 = 45;
        if (v49) {
          uint64_t v50 = 43;
        }
        v47(6, "%c[%{public}s %{public}s]:%i SSE doesn't support entanglement : %{public}@", v50, v272, v277, 1516, v6);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v51 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v52 = object_getClass(v1);
        if (class_isMetaClass(v52)) {
          int v53 = 43;
        }
        else {
          int v53 = 45;
        }
        uint64_t v54 = object_getClassName(v1);
        id v55 = sel_getName("upgradeAuthRandom");
        *(_DWORD *)buf = 67110146;
        int v319 = v53;
        __int16 v320 = 2082;
        v321 = v54;
        __int16 v322 = 2082;
        int v323 = v55;
        __int16 v324 = 1024;
        int v325 = 1516;
        __int16 v326 = 2114;
        id v327 = v6;
        _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i SSE doesn't support entanglement : %{public}@", buf, 0x2Cu);
      }

      id v30 = 0;
      id v31 = 0;
      goto LABEL_51;
    }
    id v299 = 0;
    id v7 = [v1 selectCRSWithError:&v299];
    id v8 = v299;
    if (v8)
    {
      id v9 = v8;
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v10 = NFLogGetLogger();
      if (v10)
      {
        int v11 = (void (*)(uint64_t, const char *, ...))v10;
        BOOL v12 = object_getClass(v1);
        BOOL v13 = class_isMetaClass(v12);
        uint64_t v271 = object_getClassName(v1);
        v274 = sel_getName("getAuthRandomFlagFromCRS:");
        uint64_t v14 = 45;
        if (v13) {
          uint64_t v14 = 43;
        }
        v11(3, "%c[%{public}s %{public}s]:%i Failed to select CRS: %{public}@", v14, v271, v274, 1419, v9);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v15 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        id v16 = object_getClass(v1);
        if (class_isMetaClass(v16)) {
          int v17 = 43;
        }
        else {
          int v17 = 45;
        }
        int v18 = object_getClassName(v1);
        uint64_t v19 = sel_getName("getAuthRandomFlagFromCRS:");
        *(_DWORD *)buf = 67110146;
        int v319 = v17;
        __int16 v320 = 2082;
        v321 = v18;
        __int16 v322 = 2082;
        int v323 = v19;
        __int16 v324 = 1024;
        int v325 = 1419;
        __int16 v326 = 2114;
        id v327 = v9;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select CRS: %{public}@", buf, 0x2Cu);
      }
LABEL_126:

      id v6 = v9;
      goto LABEL_127;
    }
    if (v7)
    {
      if ([v7 status] != 36864)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v82 = NFLogGetLogger();
        if (v82)
        {
          id v83 = (void (*)(uint64_t, const char *, ...))v82;
          uint64_t v84 = object_getClass(v1);
          BOOL v85 = class_isMetaClass(v84);
          uint64_t v86 = object_getClassName(v1);
          BOOL v87 = sel_getName("getAuthRandomFlagFromCRS:");
          uint64_t v291 = [v7 status];
          uint64_t v88 = 45;
          if (v85) {
            uint64_t v88 = 43;
          }
          v83(3, "%c[%{public}s %{public}s]:%i Failed to select CRS, expecting 0x9000, got 0x%x", v88, v86, v87, 1427, v291);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v89 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
        {
          uint64_t v90 = object_getClass(v1);
          if (class_isMetaClass(v90)) {
            int v91 = 43;
          }
          else {
            int v91 = 45;
          }
          CFStringRef v92 = object_getClassName(v1);
          id v93 = sel_getName("getAuthRandomFlagFromCRS:");
          unsigned int v94 = [v7 status];
          *(_DWORD *)buf = 67110146;
          int v319 = v91;
          __int16 v320 = 2082;
          v321 = v92;
          __int16 v322 = 2082;
          int v323 = v93;
          __int16 v324 = 1024;
          int v325 = 1427;
          __int16 v326 = 1024;
          LODWORD(v327) = v94;
          _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select CRS, expecting 0x9000, got 0x%x", buf, 0x28u);
        }

        id v95 = objc_alloc((Class)NSError);
        __int16 v78 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v314 = NSLocalizedDescriptionKey;
        int v81 = +[NSString stringWithUTF8String:"Commmand Error"];
        v315 = v81;
        int v96 = +[NSDictionary dictionaryWithObjects:&v315 forKeys:&v314 count:1];
        id v6 = [v95 initWithDomain:v78 code:16 userInfo:v96];

        goto LABEL_85;
      }
      id v298 = 0;
      NSErrorUserInfoKey v56 = [v1 getData:128 tag:220 data:0 error:&v298];
      id v9 = v298;

      if (v9)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v57 = NFLogGetLogger();
        if (v57)
        {
          BOOL v58 = (void (*)(uint64_t, const char *, ...))v57;
          BOOL v59 = object_getClass(v1);
          BOOL v60 = class_isMetaClass(v59);
          v273 = object_getClassName(v1);
          uint64_t v278 = sel_getName("getAuthRandomFlagFromCRS:");
          uint64_t v61 = 45;
          if (v60) {
            uint64_t v61 = 43;
          }
          v58(3, "%c[%{public}s %{public}s]:%i Failed to get flag: %{public}@", v61, v273, v278, 1433, v9);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v15 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          int v62 = object_getClass(v1);
          if (class_isMetaClass(v62)) {
            int v63 = 43;
          }
          else {
            int v63 = 45;
          }
          id v64 = object_getClassName(v1);
          uint64_t v65 = sel_getName("getAuthRandomFlagFromCRS:");
          *(_DWORD *)buf = 67110146;
          int v319 = v63;
          __int16 v320 = 2082;
          v321 = v64;
          __int16 v322 = 2082;
          int v323 = v65;
          __int16 v324 = 1024;
          int v325 = 1433;
          __int16 v326 = 2114;
          id v327 = v9;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get flag: %{public}@", buf, 0x2Cu);
          id v7 = v56;
        }
        else
        {
          id v7 = v56;
        }
        goto LABEL_126;
      }
      if (v56)
      {
        if ([v56 status] == 36864)
        {
          id v107 = [v56 response];
          id v108 = [v107 length];

          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v109 = NFLogGetLogger();
          int v110 = (void (*)(uint64_t, const char *, ...))v109;
          if ((unint64_t)v108 > 2)
          {
            if (v109)
            {
              id v193 = object_getClass(v1);
              BOOL v194 = class_isMetaClass(v193);
              int v293 = object_getClassName(v1);
              unsigned int v195 = sel_getName("getAuthRandomFlagFromCRS:");
              v196 = [v56 response];
              uint64_t v197 = 45;
              if (v194) {
                uint64_t v197 = 43;
              }
              v110(6, "%c[%{public}s %{public}s]:%i Auth random flag = %{public}@", v197, v293, v195, 1450, v196);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v198 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v198, OS_LOG_TYPE_DEFAULT))
            {
              id v199 = object_getClass(v1);
              if (class_isMetaClass(v199)) {
                int v200 = 43;
              }
              else {
                int v200 = 45;
              }
              v294 = object_getClassName(v1);
              id v201 = sel_getName("getAuthRandomFlagFromCRS:");
              id v202 = [v56 response];
              *(_DWORD *)buf = 67110146;
              int v319 = v200;
              __int16 v320 = 2082;
              v321 = v294;
              __int16 v322 = 2082;
              int v323 = v201;
              __int16 v324 = 1024;
              int v325 = 1450;
              __int16 v326 = 2114;
              id v327 = v202;
              _os_log_impl((void *)&_mh_execute_header, v198, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Auth random flag = %{public}@", buf, 0x2Cu);
            }
            id v203 = [v56 response];
            uint64_t v204 = (unsigned __int8 *)[v203 bytes];

            if (*v204 == 220)
            {
              int v205 = v204[2];

              p_info = NFHeadlessModeController.info;
              if (v205 == 90)
              {
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v206 = NFLogGetLogger();
                if (v206)
                {
                  v207 = (void (*)(uint64_t, const char *, ...))v206;
                  v208 = object_getClass(v1);
                  BOOL v209 = class_isMetaClass(v208);
                  id v210 = object_getClassName(v1);
                  uint64_t v286 = sel_getName("upgradeAuthRandom");
                  uint64_t v211 = 45;
                  if (v209) {
                    uint64_t v211 = 43;
                  }
                  v207(6, "%c[%{public}s %{public}s]:%i Already entangled, telling SSE", v211, v210, v286, 1530);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                id v212 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v212, OS_LOG_TYPE_DEFAULT))
                {
                  id v213 = object_getClass(v1);
                  if (class_isMetaClass(v213)) {
                    int v214 = 43;
                  }
                  else {
                    int v214 = 45;
                  }
                  id v215 = object_getClassName(v1);
                  char v216 = sel_getName("upgradeAuthRandom");
                  *(_DWORD *)buf = 67109890;
                  int v319 = v214;
                  __int16 v320 = 2082;
                  v321 = v215;
                  __int16 v322 = 2082;
                  int v323 = v216;
                  __int16 v324 = 1024;
                  int v325 = 1530;
                  _os_log_impl((void *)&_mh_execute_header, v212, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Already entangled, telling SSE", buf, 0x22u);
                }

                unsigned int v217 = sub_10021E92C((uint64_t)NFSSEWrapper, 1);
                if (v217)
                {
                  unsigned int v218 = v217;
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  uint64_t v219 = NFLogGetLogger();
                  if (v219)
                  {
                    NSErrorUserInfoKey v220 = (void (*)(uint64_t, const char *, ...))v219;
                    v221 = object_getClass(v1);
                    BOOL v222 = class_isMetaClass(v221);
                    BOOL v223 = object_getClassName(v1);
                    v287 = sel_getName("upgradeAuthRandom");
                    uint64_t v224 = 45;
                    if (v222) {
                      uint64_t v224 = 43;
                    }
                    v220(3, "%c[%{public}s %{public}s]:%i Failed to set auth random", v224, v223, v287, 1533);
                  }
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  v225 = NFSharedLogGetLogger();
                  if (os_log_type_enabled(v225, OS_LOG_TYPE_ERROR))
                  {
                    NSErrorUserInfoKey v226 = object_getClass(v1);
                    if (class_isMetaClass(v226)) {
                      int v227 = 43;
                    }
                    else {
                      int v227 = 45;
                    }
                    NSErrorUserInfoKey v228 = object_getClassName(v1);
                    v229 = sel_getName("upgradeAuthRandom");
                    *(_DWORD *)buf = 67109890;
                    int v319 = v227;
                    __int16 v320 = 2082;
                    v321 = v228;
                    __int16 v322 = 2082;
                    int v323 = v229;
                    __int16 v324 = 1024;
                    int v325 = 1533;
                    _os_log_impl((void *)&_mh_execute_header, v225, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set auth random", buf, 0x22u);
                  }

                  id v230 = objc_alloc((Class)NSError);
                  int v231 = +[NSString stringWithUTF8String:"nfcd"];
                  uint64_t v232 = v218;
                  NSErrorUserInfoKey v304 = NSLocalizedDescriptionKey;
                  if (v218 >= 0x47) {
                    int v233 = 71;
                  }
                  else {
                    int v233 = v218;
                  }
                  NSErrorUserInfoKey v234 = +[NSString stringWithUTF8String:off_100306F98[v233]];
                  v305 = v234;
                  uint64_t v235 = +[NSDictionary dictionaryWithObjects:&v305 forKeys:&v304 count:1];
                  id v6 = [v230 initWithDomain:v231 code:v232 userInfo:v235];

                  goto LABEL_138;
                }
                +[NFSecureElementWrapper setAuthRandomEntangled];
                goto LABEL_28;
              }
              goto LABEL_87;
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v259 = NFLogGetLogger();
            p_info = (__objc2_class_ro **)(NFHeadlessModeController + 32);
            if (v259)
            {
              v260 = (void (*)(uint64_t, const char *, ...))v259;
              v261 = object_getClass(v1);
              BOOL v262 = class_isMetaClass(v261);
              v263 = object_getClassName(v1);
              uint64_t v290 = sel_getName("getAuthRandomFlagFromCRS:");
              uint64_t v264 = 45;
              if (v262) {
                uint64_t v264 = 43;
              }
              v260(3, "%c[%{public}s %{public}s]:%i Unexpected instruction.", v264, v263, v290, 1453);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            id v265 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v265, OS_LOG_TYPE_ERROR))
            {
              v266 = object_getClass(v1);
              if (class_isMetaClass(v266)) {
                int v267 = 43;
              }
              else {
                int v267 = 45;
              }
              v268 = object_getClassName(v1);
              v269 = sel_getName("getAuthRandomFlagFromCRS:");
              *(_DWORD *)buf = 67109890;
              int v319 = v267;
              __int16 v320 = 2082;
              v321 = v268;
              __int16 v322 = 2082;
              int v323 = v269;
              __int16 v324 = 1024;
              int v325 = 1453;
              _os_log_impl((void *)&_mh_execute_header, v265, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected instruction.", buf, 0x22u);
            }

            id v120 = objc_alloc((Class)NSError);
            __int16 v78 = +[NSString stringWithUTF8String:"nfcd"];
            NSErrorUserInfoKey v306 = NSLocalizedDescriptionKey;
            int v81 = +[NSString stringWithUTF8String:"Unexpected Result"];
            id v307 = v81;
            __int16 v121 = &v307;
            unsigned int v122 = &v306;
          }
          else
          {
            if (v109)
            {
              __int16 v111 = object_getClass(v1);
              BOOL v112 = class_isMetaClass(v111);
              __int16 v113 = object_getClassName(v1);
              int v281 = sel_getName("getAuthRandomFlagFromCRS:");
              uint64_t v114 = 45;
              if (v112) {
                uint64_t v114 = 43;
              }
              v110(3, "%c[%{public}s %{public}s]:%i Invalid response size", v114, v113, v281, 1446);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            __int16 v115 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v115, OS_LOG_TYPE_ERROR))
            {
              int v116 = object_getClass(v1);
              if (class_isMetaClass(v116)) {
                int v117 = 43;
              }
              else {
                int v117 = 45;
              }
              CFStringRef v118 = object_getClassName(v1);
              __int16 v119 = sel_getName("getAuthRandomFlagFromCRS:");
              *(_DWORD *)buf = 67109890;
              int v319 = v117;
              __int16 v320 = 2082;
              v321 = v118;
              __int16 v322 = 2082;
              int v323 = v119;
              __int16 v324 = 1024;
              int v325 = 1446;
              _os_log_impl((void *)&_mh_execute_header, v115, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid response size", buf, 0x22u);
            }

            id v120 = objc_alloc((Class)NSError);
            __int16 v78 = +[NSString stringWithUTF8String:"nfcd"];
            NSErrorUserInfoKey v308 = NSLocalizedDescriptionKey;
            int v81 = +[NSString stringWithUTF8String:"Unexpected Result"];
            uint64_t v309 = v81;
            __int16 v121 = &v309;
            unsigned int v122 = &v308;
          }
          v270 = +[NSDictionary dictionaryWithObjects:v121 forKeys:v122 count:1];
          id v6 = [v120 initWithDomain:v78 code:13 userInfo:v270];

          id v7 = v56;
LABEL_86:

          if (v6)
          {
LABEL_127:
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v143 = NFLogGetLogger();
            if (v143)
            {
              int v144 = (void (*)(uint64_t, const char *, ...))v143;
              v145 = object_getClass(v1);
              BOOL v146 = class_isMetaClass(v145);
              uint64_t v147 = object_getClassName(v1);
              v283 = sel_getName("upgradeAuthRandom");
              uint64_t v148 = 45;
              if (v146) {
                uint64_t v148 = 43;
              }
              v144(3, "%c[%{public}s %{public}s]:%i Failed to get flag", v148, v147, v283, 1523);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            id v38 = NFSharedLogGetLogger();
            if (!os_log_type_enabled(v38, OS_LOG_TYPE_ERROR)) {
              goto LABEL_137;
            }
            uint64_t v149 = object_getClass(v1);
            if (class_isMetaClass(v149)) {
              int v150 = 43;
            }
            else {
              int v150 = 45;
            }
            id v151 = object_getClassName(v1);
            uint64_t v152 = sel_getName("upgradeAuthRandom");
            *(_DWORD *)buf = 67109890;
            int v319 = v150;
            __int16 v320 = 2082;
            v321 = v151;
            __int16 v322 = 2082;
            int v323 = v152;
            __int16 v324 = 1024;
            int v325 = 1523;
            CFStringRef v43 = "%c[%{public}s %{public}s]:%i Failed to get flag";
            id v44 = v38;
            os_log_type_t v45 = OS_LOG_TYPE_ERROR;
LABEL_136:
            _os_log_impl((void *)&_mh_execute_header, v44, v45, v43, buf, 0x22u);
LABEL_137:

LABEL_138:
            id v30 = 0;
            id v31 = 0;
            goto LABEL_139;
          }
LABEL_87:
          if (!sub_1001FA3F0(v1, 0xFFFFFFFFLL))
          {
            id v295 = 0;
            id v296 = 0;
            unsigned int v123 = sub_10021F0B0((uint64_t)(p_info + 6), v2, 0xFFFFFFFFLL, &v296, &v295, 1, 1u);
            id v30 = v296;
            id v31 = v295;
            if (v123)
            {
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v124 = NFLogGetLogger();
              if (v124)
              {
                uint64_t v125 = (void (*)(uint64_t, const char *, ...))v124;
                id v126 = object_getClass(v1);
                BOOL v127 = class_isMetaClass(v126);
                int v128 = object_getClassName(v1);
                v282 = sel_getName("upgradeAuthRandom");
                uint64_t v129 = 45;
                if (v127) {
                  uint64_t v129 = 43;
                }
                v125(3, "%c[%{public}s %{public}s]:%i Failed to get auth random", v129, v128, v282, 1551);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              BOOL v130 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v130, OS_LOG_TYPE_ERROR))
              {
                CFStringRef v131 = object_getClass(v1);
                if (class_isMetaClass(v131)) {
                  int v132 = 43;
                }
                else {
                  int v132 = 45;
                }
                uint64_t v133 = object_getClassName(v1);
                uint64_t v134 = sel_getName("upgradeAuthRandom");
                *(_DWORD *)buf = 67109890;
                int v319 = v132;
                __int16 v320 = 2082;
                v321 = v133;
                __int16 v322 = 2082;
                int v323 = v134;
                __int16 v324 = 1024;
                int v325 = 1551;
                _os_log_impl((void *)&_mh_execute_header, v130, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get auth random", buf, 0x22u);
              }

              id v135 = objc_alloc((Class)NSError);
              __int16 v136 = +[NSString stringWithUTF8String:"nfcd"];
              uint64_t v137 = v123;
              NSErrorUserInfoKey v302 = NSLocalizedDescriptionKey;
              if (v123 >= 0x47) {
                int v138 = 71;
              }
              else {
                int v138 = v123;
              }
              CFStringRef v139 = +[NSString stringWithUTF8String:off_100306F98[v138]];
              v303 = v139;
              uint64_t v140 = &v303;
              uint64_t v141 = &v302;
            }
            else
            {
              uint64_t v165 = [v1 handle];
              [v165 redactLogging:1];

              sub_1001FFC68(v1, v30, v31);
              id v6 = (id)objc_claimAutoreleasedReturnValue();
              __int16 v166 = [v1 handle];
              [v166 redactLogging:0];

              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v167 = NFLogGetLogger();
              id v168 = (void (*)(uint64_t, const char *, ...))v167;
              if (v6)
              {
                if (v167)
                {
                  int v169 = object_getClass(v1);
                  BOOL v170 = class_isMetaClass(v169);
                  CFStringRef v171 = object_getClassName(v1);
                  id v285 = sel_getName("upgradeAuthRandom");
                  uint64_t v172 = 45;
                  if (v170) {
                    uint64_t v172 = 43;
                  }
                  v168(3, "%c[%{public}s %{public}s]:%i Failed to set CRS auth random", v172, v171, v285, 1561);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                id v173 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v173, OS_LOG_TYPE_ERROR))
                {
                  unsigned __int16 v174 = object_getClass(v1);
                  if (class_isMetaClass(v174)) {
                    int v175 = 43;
                  }
                  else {
                    int v175 = 45;
                  }
                  id v176 = object_getClassName(v1);
                  id v177 = sel_getName("upgradeAuthRandom");
                  *(_DWORD *)buf = 67109890;
                  int v319 = v175;
                  __int16 v320 = 2082;
                  v321 = v176;
                  __int16 v322 = 2082;
                  int v323 = v177;
                  __int16 v324 = 1024;
                  int v325 = 1561;
                  _os_log_impl((void *)&_mh_execute_header, v173, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set CRS auth random", buf, 0x22u);
                }

                goto LABEL_139;
              }
              if (v167)
              {
                NSErrorUserInfoKey v236 = object_getClass(v1);
                BOOL v237 = class_isMetaClass(v236);
                NSErrorUserInfoKey v238 = object_getClassName(v1);
                v288 = sel_getName("upgradeAuthRandom");
                uint64_t v239 = 45;
                if (v237) {
                  uint64_t v239 = 43;
                }
                v168(6, "%c[%{public}s %{public}s]:%i Entanglement success, telling SSE", v239, v238, v288, 1565);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v240 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v240, OS_LOG_TYPE_DEFAULT))
              {
                int v241 = object_getClass(v1);
                if (class_isMetaClass(v241)) {
                  int v242 = 43;
                }
                else {
                  int v242 = 45;
                }
                uint64_t v243 = object_getClassName(v1);
                __int16 v244 = sel_getName("upgradeAuthRandom");
                *(_DWORD *)buf = 67109890;
                int v319 = v242;
                __int16 v320 = 2082;
                v321 = v243;
                __int16 v322 = 2082;
                int v323 = v244;
                __int16 v324 = 1024;
                int v325 = 1565;
                _os_log_impl((void *)&_mh_execute_header, v240, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Entanglement success, telling SSE", buf, 0x22u);
              }

              unsigned int v245 = sub_10021E92C((uint64_t)(p_info + 6), 1);
              if (!v245)
              {
                +[NFSecureElementWrapper setAuthRandomEntangled];
                goto LABEL_29;
              }
              unsigned int v246 = v245;
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v247 = NFLogGetLogger();
              if (v247)
              {
                __int16 v248 = (void (*)(uint64_t, const char *, ...))v247;
                id v249 = object_getClass(v1);
                BOOL v250 = class_isMetaClass(v249);
                v251 = object_getClassName(v1);
                BOOL v289 = sel_getName("upgradeAuthRandom");
                uint64_t v252 = 45;
                if (v250) {
                  uint64_t v252 = 43;
                }
                v248(3, "%c[%{public}s %{public}s]:%i Failed to set auth random", v252, v251, v289, 1569);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v253 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v253, OS_LOG_TYPE_ERROR))
              {
                v254 = object_getClass(v1);
                if (class_isMetaClass(v254)) {
                  int v255 = 43;
                }
                else {
                  int v255 = 45;
                }
                BOOL v256 = object_getClassName(v1);
                id v257 = sel_getName("upgradeAuthRandom");
                *(_DWORD *)buf = 67109890;
                int v319 = v255;
                __int16 v320 = 2082;
                v321 = v256;
                __int16 v322 = 2082;
                int v323 = v257;
                __int16 v324 = 1024;
                int v325 = 1569;
                _os_log_impl((void *)&_mh_execute_header, v253, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set auth random", buf, 0x22u);
              }

              id v135 = objc_alloc((Class)NSError);
              __int16 v136 = +[NSString stringWithUTF8String:"nfcd"];
              uint64_t v137 = v246;
              NSErrorUserInfoKey v300 = NSLocalizedDescriptionKey;
              if (v246 >= 0x47) {
                int v258 = 71;
              }
              else {
                int v258 = v246;
              }
              CFStringRef v139 = +[NSString stringWithUTF8String:off_100306F98[v258]];
              uint64_t v301 = v139;
              uint64_t v140 = &v301;
              uint64_t v141 = &v300;
            }
            NSErrorUserInfoKey v142 = +[NSDictionary dictionaryWithObjects:v140 forKeys:v141 count:1];
            id v6 = [v135 initWithDomain:v136 code:v137 userInfo:v142];

            goto LABEL_139;
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v97 = NFLogGetLogger();
          if (v97)
          {
            uint64_t v98 = (void (*)(uint64_t, const char *, ...))v97;
            int v99 = object_getClass(v1);
            BOOL v100 = class_isMetaClass(v99);
            id v101 = object_getClassName(v1);
            v280 = sel_getName("upgradeAuthRandom");
            uint64_t v102 = 45;
            if (v100) {
              uint64_t v102 = 43;
            }
            v98(6, "%c[%{public}s %{public}s]:%i Not paired", v102, v101, v280, 1544);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          int v26 = NFSharedLogGetLogger();
          if (!os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_27;
          }
          uint64_t v103 = object_getClass(v1);
          if (class_isMetaClass(v103)) {
            int v104 = 43;
          }
          else {
            int v104 = 45;
          }
          unsigned __int16 v105 = object_getClassName(v1);
          id v106 = sel_getName("upgradeAuthRandom");
          *(_DWORD *)buf = 67109890;
          int v319 = v104;
          __int16 v320 = 2082;
          v321 = v105;
          __int16 v322 = 2082;
          int v323 = v106;
          __int16 v324 = 1024;
          int v325 = 1544;
          id v29 = "%c[%{public}s %{public}s]:%i Not paired";
          goto LABEL_26;
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v178 = NFLogGetLogger();
        if (v178)
        {
          id v179 = (void (*)(uint64_t, const char *, ...))v178;
          id v180 = object_getClass(v1);
          BOOL v181 = class_isMetaClass(v180);
          __int16 v182 = object_getClassName(v1);
          uint64_t v183 = sel_getName("getAuthRandomFlagFromCRS:");
          uint64_t v292 = [v56 status];
          uint64_t v184 = 45;
          if (v181) {
            uint64_t v184 = 43;
          }
          v179(3, "%c[%{public}s %{public}s]:%i Failed to get flag, expecting 0x9000, got 0x%x", v184, v182, v183, 1441, v292);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v185 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v185, OS_LOG_TYPE_ERROR))
        {
          __int16 v186 = object_getClass(v1);
          if (class_isMetaClass(v186)) {
            int v187 = 43;
          }
          else {
            int v187 = 45;
          }
          __int16 v188 = object_getClassName(v1);
          CFStringRef v189 = sel_getName("getAuthRandomFlagFromCRS:");
          unsigned int v190 = [v56 status];
          *(_DWORD *)buf = 67110146;
          int v319 = v187;
          __int16 v320 = 2082;
          v321 = v188;
          __int16 v322 = 2082;
          int v323 = v189;
          __int16 v324 = 1024;
          int v325 = 1441;
          __int16 v326 = 1024;
          LODWORD(v327) = v190;
          _os_log_impl((void *)&_mh_execute_header, v185, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get flag, expecting 0x9000, got 0x%x", buf, 0x28u);
        }

        id v191 = objc_alloc((Class)NSError);
        __int16 v78 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v310 = NSLocalizedDescriptionKey;
        int v81 = +[NSString stringWithUTF8String:"Commmand Error"];
        v311 = v81;
        __int16 v192 = +[NSDictionary dictionaryWithObjects:&v311 forKeys:&v310 count:1];
        id v6 = [v191 initWithDomain:v78 code:16 userInfo:v192];

        id v7 = v56;
LABEL_85:
        p_info = NFHeadlessModeController.info;
        goto LABEL_86;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v154 = NFLogGetLogger();
      if (v154)
      {
        int v155 = (void (*)(uint64_t, const char *, ...))v154;
        id v156 = object_getClass(v1);
        BOOL v157 = class_isMetaClass(v156);
        id v158 = object_getClassName(v1);
        CFStringRef v284 = sel_getName("getAuthRandomFlagFromCRS:");
        uint64_t v159 = 45;
        if (v157) {
          uint64_t v159 = 43;
        }
        v155(3, "%c[%{public}s %{public}s]:%i Failed to get flag, expecting RAPDU", v159, v158, v284, 1437);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v160 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v160, OS_LOG_TYPE_ERROR))
      {
        id v161 = object_getClass(v1);
        if (class_isMetaClass(v161)) {
          int v162 = 43;
        }
        else {
          int v162 = 45;
        }
        int v163 = object_getClassName(v1);
        __int16 v164 = sel_getName("getAuthRandomFlagFromCRS:");
        *(_DWORD *)buf = 67109890;
        int v319 = v162;
        __int16 v320 = 2082;
        v321 = v163;
        __int16 v322 = 2082;
        int v323 = v164;
        __int16 v324 = 1024;
        int v325 = 1437;
        _os_log_impl((void *)&_mh_execute_header, v160, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get flag, expecting RAPDU", buf, 0x22u);
      }

      id v77 = objc_alloc((Class)NSError);
      id v7 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v312 = NSLocalizedDescriptionKey;
      __int16 v78 = +[NSString stringWithUTF8String:"Commmand Error"];
      id v313 = v78;
      uint64_t v79 = &v313;
      __int16 v80 = &v312;
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v66 = NFLogGetLogger();
      if (v66)
      {
        int v67 = (void (*)(uint64_t, const char *, ...))v66;
        uint64_t v68 = object_getClass(v1);
        BOOL v69 = class_isMetaClass(v68);
        int v70 = object_getClassName(v1);
        v279 = sel_getName("getAuthRandomFlagFromCRS:");
        uint64_t v71 = 45;
        if (v69) {
          uint64_t v71 = 43;
        }
        v67(3, "%c[%{public}s %{public}s]:%i Failed to select CRS, expecting RAPDU", v71, v70, v279, 1423);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v72 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
      {
        id v73 = object_getClass(v1);
        if (class_isMetaClass(v73)) {
          int v74 = 43;
        }
        else {
          int v74 = 45;
        }
        int v75 = object_getClassName(v1);
        __int16 v76 = sel_getName("getAuthRandomFlagFromCRS:");
        *(_DWORD *)buf = 67109890;
        int v319 = v74;
        __int16 v320 = 2082;
        v321 = v75;
        __int16 v322 = 2082;
        int v323 = v76;
        __int16 v324 = 1024;
        int v325 = 1423;
        _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select CRS, expecting RAPDU", buf, 0x22u);
      }

      id v77 = objc_alloc((Class)NSError);
      id v7 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v316 = NSLocalizedDescriptionKey;
      __int16 v78 = +[NSString stringWithUTF8String:"Commmand Error"];
      v317 = v78;
      uint64_t v79 = &v317;
      __int16 v80 = &v316;
    }
    int v81 = +[NSDictionary dictionaryWithObjects:v79 forKeys:v80 count:1];
    id v6 = [v77 initWithDomain:v7 code:16 userInfo:v81];
    goto LABEL_86;
  }
LABEL_141:

  return v1;
}

uint64_t sub_1001FCE84(void *a1, void *a2, void *a3)
{
  if (!a1) {
    return 0;
  }
  kdebug_trace();
  id v6 = NFSharedSignpostLog();
  if (os_signpost_enabled(v6))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v6, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseGetHostChallenge in", buf, 2u);
  }

  id v77 = 0;
  unsigned int v7 = sub_10021F7F0((uint64_t)NFSSEWrapper, &v77);
  id v8 = v77;
  kdebug_trace();
  id v9 = NFSharedSignpostLog();
  if (os_signpost_enabled(v9))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseGetHostChallenge out", buf, 2u);
  }

  if (!v8 || v7)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v16 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("_getCryptogram:challengeResponse:");
      uint64_t v20 = 45;
      if (isMetaClass) {
        uint64_t v20 = 43;
      }
      v16(3, "%c[%{public}s %{public}s]:%i Failed to get host challenge", v20, ClassName, Name, 1107);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v21 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      id v22 = object_getClass(a1);
      if (class_isMetaClass(v22)) {
        int v23 = 43;
      }
      else {
        int v23 = 45;
      }
      uint64_t v24 = object_getClassName(a1);
      uint64_t v25 = sel_getName("_getCryptogram:challengeResponse:");
      *(_DWORD *)buf = 67109890;
      int v79 = v23;
      __int16 v80 = 2082;
      int v81 = v24;
      __int16 v82 = 2082;
      id v83 = v25;
      __int16 v84 = 1024;
      int v85 = 1107;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get host challenge", buf, 0x22u);
    }

    if (v7) {
      uint64_t v14 = v7;
    }
    else {
      uint64_t v14 = 6;
    }
  }
  else if ([v8 length] == (id)8)
  {
    id v10 = v8;
    *a2 = v10;
    id v76 = 0;
    id v11 = [a1 selectCRSWithError:&v76];
    id v12 = v76;
    BOOL v13 = v12;
    if (v12)
    {
      if ([v12 code]) {
        uint64_t v14 = (uint64_t)[v13 code];
      }
      else {
        uint64_t v14 = 16;
      }
    }
    else
    {
      id v75 = 0;
      uint64_t v14 = sub_1000C5684(a1, v10, &v75);
      id v39 = v75;
      int v40 = v39;
      if (v14)
      {
        id v74 = v39;
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v41 = NFLogGetLogger();
        if (v41)
        {
          id v42 = (void (*)(uint64_t, const char *, ...))v41;
          CFStringRef v43 = object_getClass(a1);
          BOOL v44 = class_isMetaClass(v43);
          os_log_type_t v45 = object_getClassName(a1);
          uint64_t v46 = sel_getName("_getCryptogram:challengeResponse:");
          if (v14 >= 0x47) {
            int v47 = 71;
          }
          else {
            int v47 = v14;
          }
          id v73 = off_100306F98[v47];
          uint64_t v48 = 43;
          if (!v44) {
            uint64_t v48 = 45;
          }
          v42(3, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", v48, v45, v46, 1126, @"Failed to authenticate", v14, v73);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        BOOL v49 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
        {
          uint64_t v50 = object_getClass(a1);
          if (class_isMetaClass(v50)) {
            int v51 = 43;
          }
          else {
            int v51 = 45;
          }
          __int16 v52 = object_getClassName(a1);
          int v53 = sel_getName("_getCryptogram:challengeResponse:");
          if (v14 >= 0x47) {
            int v54 = 71;
          }
          else {
            int v54 = v14;
          }
          id v55 = off_100306F98[v54];
          *(_DWORD *)buf = 67110658;
          int v79 = v51;
          __int16 v80 = 2082;
          int v81 = v52;
          __int16 v82 = 2082;
          id v83 = v53;
          __int16 v84 = 1024;
          int v85 = 1126;
          __int16 v86 = 2112;
          CFStringRef v87 = @"Failed to authenticate";
          __int16 v88 = 1024;
          int v89 = v14;
          __int16 v90 = 2080;
          int v91 = v55;
          _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", buf, 0x3Cu);
        }

        int v40 = v74;
      }
      else if ([v39 length] == (id)16)
      {
        uint64_t v14 = 0;
        *a3 = v40;
      }
      else
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v56 = NFLogGetLogger();
        if (v56)
        {
          uint64_t v57 = (void (*)(uint64_t, const char *, ...))v56;
          BOOL v58 = object_getClass(a1);
          BOOL v59 = class_isMetaClass(v58);
          BOOL v60 = object_getClassName(a1);
          uint64_t v61 = sel_getName("_getCryptogram:challengeResponse:");
          id v72 = [v40 length];
          uint64_t v62 = 45;
          if (v59) {
            uint64_t v62 = 43;
          }
          v57(3, "%c[%{public}s %{public}s]:%i Invalid authenticate response length: %lu", v62, v60, v61, 1130, v72);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v63 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
        {
          id v64 = object_getClass(a1);
          if (class_isMetaClass(v64)) {
            int v65 = 43;
          }
          else {
            int v65 = 45;
          }
          uint64_t v66 = object_getClassName(a1);
          int v67 = sel_getName("_getCryptogram:challengeResponse:");
          CFStringRef v68 = (const __CFString *)[v40 length];
          *(_DWORD *)buf = 67110146;
          int v79 = v65;
          __int16 v80 = 2082;
          int v81 = v66;
          __int16 v82 = 2082;
          id v83 = v67;
          __int16 v84 = 1024;
          int v85 = 1130;
          __int16 v86 = 2048;
          CFStringRef v87 = v68;
          _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid authenticate response length: %lu", buf, 0x2Cu);
        }

        uint64_t v14 = 13;
      }
    }
  }
  else
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v26 = NFLogGetLogger();
    if (v26)
    {
      uint64_t v27 = (void (*)(uint64_t, const char *, ...))v26;
      int v28 = object_getClass(a1);
      BOOL v29 = class_isMetaClass(v28);
      id v30 = object_getClassName(a1);
      id v31 = sel_getName("_getCryptogram:challengeResponse:");
      id v71 = [v8 length];
      uint64_t v32 = 45;
      if (v29) {
        uint64_t v32 = 43;
      }
      v27(3, "%c[%{public}s %{public}s]:%i Invalid host challenge length: %lu", v32, v30, v31, 1111, v71);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v33 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      BOOL v34 = object_getClass(a1);
      if (class_isMetaClass(v34)) {
        int v35 = 43;
      }
      else {
        int v35 = 45;
      }
      uint64_t v36 = object_getClassName(a1);
      uint64_t v37 = sel_getName("_getCryptogram:challengeResponse:");
      CFStringRef v38 = (const __CFString *)[v8 length];
      *(_DWORD *)buf = 67110146;
      int v79 = v35;
      __int16 v80 = 2082;
      int v81 = v36;
      __int16 v82 = 2082;
      id v83 = v37;
      __int16 v84 = 1024;
      int v85 = 1111;
      __int16 v86 = 2048;
      CFStringRef v87 = v38;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid host challenge length: %lu", buf, 0x2Cu);
    }

    uint64_t v14 = 13;
  }

  return v14;
}

uint64_t sub_1001FD620(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = v5;
  id v133 = (id)a1;
  if (a1)
  {
    if (!v5)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        uint64_t v20 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(v133);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(v133);
        Name = sel_getName("signChallengeWithOSVersion:signature:");
        uint64_t v24 = 45;
        if (isMetaClass) {
          uint64_t v24 = 43;
        }
        v20(3, "%c[%{public}s %{public}s]:%i Invalid challenge string", v24, ClassName, Name, 1215);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      BOOL v13 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        goto LABEL_23;
      }
      uint64_t v25 = object_getClass(v133);
      if (class_isMetaClass(v25)) {
        int v26 = 43;
      }
      else {
        int v26 = 45;
      }
      *(_DWORD *)buf = 67109890;
      int v151 = v26;
      __int16 v152 = 2082;
      int v153 = object_getClassName(v133);
      __int16 v154 = 2082;
      int v155 = sel_getName("signChallengeWithOSVersion:signature:");
      __int16 v156 = 1024;
      int v157 = 1215;
      id v16 = "%c[%{public}s %{public}s]:%i Invalid challenge string";
      int v17 = v13;
      uint32_t v18 = 34;
      goto LABEL_22;
    }
    if ((unint64_t)[v5 length] >= 0x41)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v7 = NFLogGetLogger();
      if (v7)
      {
        id v8 = (void (*)(uint64_t, const char *, ...))v7;
        id v9 = object_getClass(v133);
        BOOL v10 = class_isMetaClass(v9);
        id v11 = object_getClassName(v133);
        int v117 = sel_getName("signChallengeWithOSVersion:signature:");
        uint64_t v12 = 45;
        if (v10) {
          uint64_t v12 = 43;
        }
        v8(3, "%c[%{public}s %{public}s]:%i challenge for signing is too large: Max = %d", v12, v11, v117, 1220, 64);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      BOOL v13 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        goto LABEL_23;
      }
      uint64_t v14 = object_getClass(v133);
      if (class_isMetaClass(v14)) {
        int v15 = 43;
      }
      else {
        int v15 = 45;
      }
      *(_DWORD *)buf = 67110146;
      int v151 = v15;
      __int16 v152 = 2082;
      int v153 = object_getClassName(v133);
      __int16 v154 = 2082;
      int v155 = sel_getName("signChallengeWithOSVersion:signature:");
      __int16 v156 = 1024;
      int v157 = 1220;
      __int16 v158 = 1024;
      LODWORD(v159) = 64;
      id v16 = "%c[%{public}s %{public}s]:%i challenge for signing is too large: Max = %d";
      int v17 = v13;
      uint32_t v18 = 40;
LABEL_22:
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, v16, buf, v18);
LABEL_23:
      a1 = 10;
LABEL_103:

      goto LABEL_104;
    }
    id v27 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284478 length:12];
    id v134 = 0;
    int v28 = [v133 selectByName:v27 error:&v134];
    BOOL v13 = v134;

    if (v28)
    {
      if ([v28 status] == 36864)
      {
        BOOL v29 = +[NFTLV TLVWithTag:40759 value:v6];
        id v30 = [v29 asData];

        int v139 = 836706527;
        id v31 = [objc_alloc((Class)NSData) initWithBytes:&v139 length:4];
        uint64_t v32 = +[NFTLV TLVWithTag:92 value:v31];
        id v33 = [v32 asData];

        id v34 = [objc_alloc((Class)NSMutableData) initWithCapacity:((char *)[v30 length] + [v33 length])];
        int v128 = v30;
        [v34 appendData:v30];
        CFStringRef v131 = v33;
        [v34 appendData:v33];
        BOOL v130 = v34;
        int v35 = [v133 getData:128 tag:257 data:v34 error:0];
        uint64_t v129 = v28;
        if ([v35 status] == 36864)
        {
          id v126 = a3;
          BOOL v127 = v6;
          uint64_t v36 = objc_opt_new();
          uint64_t v37 = [v35 response];
          [v36 setObject:v37 forKey:@"SignedResponse"];

          uint64_t v125 = v35;
          CFStringRef v38 = [v35 response];
          id v39 = +[NFTLV TLVsWithData:v38];

          long long v137 = 0u;
          long long v138 = 0u;
          long long v135 = 0u;
          long long v136 = 0u;
          int v40 = v39;
          id v41 = [v40 countByEnumeratingWithState:&v135 objects:buf count:16];
          if (!v41) {
            goto LABEL_54;
          }
          id v42 = v41;
          uint64_t v43 = *(void *)v136;
          int v132 = v36;
          while (1)
          {
            for (i = 0; i != v42; i = (char *)i + 1)
            {
              if (*(void *)v136 != v43) {
                objc_enumerationMutation(v40);
              }
              os_log_type_t v45 = *(void **)(*((void *)&v135 + 1) + 8 * i);
              int v46 = [v45 tag];
              if (v46 > 57119)
              {
                if (v46 == 57137)
                {
                  int v63 = [v45 value];
                  uint64_t v50 = [v63 NF_asHexString];

                  id v64 = -[NSObject substringWithRange:](v50, "substringWithRange:", 0, 4);
                  [v36 setObject:v64 forKey:@"jsblSequenceCounter"];
                }
                else if (v46 == 57120)
                {
                  id v48 = objc_alloc((Class)NSString);
                  BOOL v49 = [v45 value];
                  uint64_t v50 = [v48 initWithData:v49 encoding:4];

                  [v36 setObject:v50 forKey:@"kPlatformId"];
                }
                else
                {
LABEL_41:
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  uint64_t v51 = NFLogGetLogger();
                  if (v51)
                  {
                    __int16 v52 = (void (*)(uint64_t, const char *, ...))v51;
                    int v53 = object_getClass(v133);
                    BOOL v54 = class_isMetaClass(v53);
                    id v55 = object_getClassName(v133);
                    uint64_t v56 = sel_getName("_signChallengeWithOSVersionComet:");
                    id v122 = [v45 tag];
                    BOOL v47 = !v54;
                    uint64_t v36 = v132;
                    uint64_t v57 = 45;
                    if (!v47) {
                      uint64_t v57 = 43;
                    }
                    v52(3, "%c[%{public}s %{public}s]:%i Unexpected tag found, %d", v57, v55, v56, 1196, v122);
                  }
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  uint64_t v50 = NFSharedLogGetLogger();
                  if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
                  {
                    BOOL v58 = object_getClass(v133);
                    if (class_isMetaClass(v58)) {
                      int v59 = 43;
                    }
                    else {
                      int v59 = 45;
                    }
                    BOOL v60 = object_getClassName(v133);
                    uint64_t v61 = sel_getName("_signChallengeWithOSVersionComet:");
                    unsigned int v62 = [v45 tag];
                    *(_DWORD *)uint64_t v140 = 67110146;
                    int v141 = v59;
                    uint64_t v36 = v132;
                    __int16 v142 = 2082;
                    uint64_t v143 = v60;
                    __int16 v144 = 2082;
                    v145 = v61;
                    __int16 v146 = 1024;
                    int v147 = 1196;
                    __int16 v148 = 1024;
                    unsigned int v149 = v62;
                    _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected tag found, %d", v140, 0x28u);
                  }
                }

                continue;
              }
              BOOL v47 = v46 == 133 || v46 == 24375;
              if (!v47) {
                goto LABEL_41;
              }
            }
            id v42 = [v40 countByEnumeratingWithState:&v135 objects:buf count:16];
            if (!v42)
            {
LABEL_54:

              id v6 = v127;
              a3 = v126;
              int v65 = v128;
              int v35 = v125;
              goto LABEL_88;
            }
          }
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v89 = NFLogGetLogger();
        if (v89)
        {
          __int16 v90 = (void (*)(uint64_t, const char *, ...))v89;
          int v91 = object_getClass(v133);
          BOOL v92 = class_isMetaClass(v91);
          id v93 = object_getClassName(v133);
          unsigned int v94 = a3;
          id v95 = sel_getName("_signChallengeWithOSVersionComet:");
          uint64_t v124 = [v35 status];
          id v120 = v95;
          a3 = v94;
          uint64_t v96 = 45;
          if (v92) {
            uint64_t v96 = 43;
          }
          v90(3, "%c[%{public}s %{public}s]:%i Unable to obtain Authenticated GET DATA 0x%x", v96, v93, v120, 1164, v124);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v40 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
        {
          uint64_t v97 = object_getClass(v133);
          if (class_isMetaClass(v97)) {
            int v98 = 43;
          }
          else {
            int v98 = 45;
          }
          int v99 = object_getClassName(v133);
          BOOL v100 = sel_getName("_signChallengeWithOSVersionComet:");
          unsigned int v101 = [v35 status];
          *(_DWORD *)buf = 67110146;
          int v151 = v98;
          __int16 v152 = 2082;
          int v153 = v99;
          __int16 v154 = 2082;
          int v155 = v100;
          __int16 v156 = 1024;
          int v157 = 1164;
          __int16 v158 = 1024;
          LODWORD(v159) = v101;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unable to obtain Authenticated GET DATA 0x%x", buf, 0x28u);
        }
        uint64_t v36 = 0;
        int v65 = v128;
LABEL_88:

        if (v36)
        {
          a1 = 0;
          *a3 = v36;
          int v28 = v129;
        }
        else
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v102 = NFLogGetLogger();
          int v28 = v129;
          if (v102)
          {
            uint64_t v103 = (void (*)(uint64_t, const char *, ...))v102;
            int v104 = object_getClass(v133);
            BOOL v105 = class_isMetaClass(v104);
            id v106 = object_getClassName(v133);
            __int16 v121 = sel_getName("signChallengeWithOSVersion:signature:");
            uint64_t v107 = 45;
            if (v105) {
              uint64_t v107 = 43;
            }
            int v116 = v106;
            uint64_t v36 = 0;
            v103(3, "%c[%{public}s %{public}s]:%i Failed to get signature", v107, v116, v121, 1242);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v108 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v108, OS_LOG_TYPE_ERROR))
          {
            uint64_t v109 = object_getClass(v133);
            int v110 = v36;
            if (class_isMetaClass(v109)) {
              int v111 = 43;
            }
            else {
              int v111 = 45;
            }
            BOOL v112 = object_getClassName(v133);
            __int16 v113 = sel_getName("signChallengeWithOSVersion:signature:");
            *(_DWORD *)buf = 67109890;
            int v151 = v111;
            uint64_t v36 = v110;
            __int16 v152 = 2082;
            int v153 = v112;
            __int16 v154 = 2082;
            int v155 = v113;
            __int16 v156 = 1024;
            int v157 = 1242;
            _os_log_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get signature", buf, 0x22u);
          }

          a1 = 16;
        }
      }
      else
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v76 = NFLogGetLogger();
        if (v76)
        {
          id v77 = (void (*)(uint64_t, const char *, ...))v76;
          __int16 v78 = object_getClass(v133);
          BOOL v79 = class_isMetaClass(v78);
          __int16 v80 = object_getClassName(v133);
          int v81 = sel_getName("signChallengeWithOSVersion:signature:");
          uint64_t v123 = [v28 status];
          uint64_t v82 = 45;
          if (v79) {
            uint64_t v82 = 43;
          }
          v77(3, "%c[%{public}s %{public}s]:%i Failed to select CASD: 0x%04x", v82, v80, v81, 1232, v123);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v83 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
        {
          __int16 v84 = object_getClass(v133);
          if (class_isMetaClass(v84)) {
            int v85 = 43;
          }
          else {
            int v85 = 45;
          }
          __int16 v86 = object_getClassName(v133);
          CFStringRef v87 = sel_getName("signChallengeWithOSVersion:signature:");
          unsigned int v88 = [v28 status];
          *(_DWORD *)buf = 67110146;
          int v151 = v85;
          __int16 v152 = 2082;
          int v153 = v86;
          __int16 v154 = 2082;
          int v155 = v87;
          __int16 v156 = 1024;
          int v157 = 1232;
          __int16 v158 = 1024;
          LODWORD(v159) = v88;
          _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select CASD: 0x%04x", buf, 0x28u);
        }

        if ([v28 status] == 26277) {
          a1 = 24;
        }
        else {
          a1 = 16;
        }
      }
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v66 = NFLogGetLogger();
      if (v66)
      {
        int v67 = (void (*)(uint64_t, const char *, ...))v66;
        CFStringRef v68 = object_getClass(v133);
        BOOL v69 = class_isMetaClass(v68);
        __int16 v115 = object_getClassName(v133);
        __int16 v119 = sel_getName("signChallengeWithOSVersion:signature:");
        uint64_t v70 = 45;
        if (v69) {
          uint64_t v70 = 43;
        }
        v67(3, "%c[%{public}s %{public}s]:%i Failed to select CRS: %{public}@", v70, v115, v119, 1228, v13);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v71 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
      {
        id v72 = object_getClass(v133);
        if (class_isMetaClass(v72)) {
          int v73 = 43;
        }
        else {
          int v73 = 45;
        }
        id v74 = object_getClassName(v133);
        id v75 = sel_getName("signChallengeWithOSVersion:signature:");
        *(_DWORD *)buf = 67110146;
        int v151 = v73;
        __int16 v152 = 2082;
        int v153 = v74;
        __int16 v154 = 2082;
        int v155 = v75;
        __int16 v156 = 1024;
        int v157 = 1228;
        __int16 v158 = 2114;
        uint64_t v159 = v13;
        _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select CRS: %{public}@", buf, 0x2Cu);
      }

      if ([v13 code]) {
        a1 = (uint64_t)[v13 code];
      }
      else {
        a1 = 16;
      }
    }

    goto LABEL_103;
  }
LABEL_104:

  return a1;
}

uint64_t sub_1001FE394(void *a1, int a2, unsigned int a3, void *a4, void *a5)
{
  id v8 = a4;
  id v178 = a5;
  if (!a1)
  {
    uint64_t v29 = 0;
    id v11 = v8;
    goto LABEL_154;
  }
  id v9 = [v8 count];
  if ((unint64_t)v9 >= 0xC) {
    uint64_t v10 = 12;
  }
  else {
    uint64_t v10 = (uint64_t)v9;
  }
  id v11 = v8;
  if (v10)
  {
    unsigned int v172 = a3;
    uint64_t v12 = 0;
    id v174 = v8;
    do
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        uint64_t v14 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("requireTransientAuth:uid:applets:authorization:");
        uint64_t v18 = 45;
        if (isMetaClass) {
          uint64_t v18 = 43;
        }
        v14(6, "%c[%{public}s %{public}s]:%i Disabling transient authorization on %u:%u applets", v18, ClassName, Name, 1347, v12, v10);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v19 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v20 = object_getClass(a1);
        if (class_isMetaClass(v20)) {
          int v21 = 43;
        }
        else {
          int v21 = 45;
        }
        id v22 = object_getClassName(a1);
        int v23 = sel_getName("requireTransientAuth:uid:applets:authorization:");
        *(_DWORD *)buf = 67110402;
        int v185 = v21;
        __int16 v186 = 2082;
        int v187 = v22;
        __int16 v188 = 2082;
        CFStringRef v189 = v23;
        __int16 v190 = 1024;
        int v191 = 1347;
        __int16 v192 = 1024;
        *(_DWORD *)id v193 = v12;
        *(_WORD *)&v193[4] = 1024;
        *(_DWORD *)&v193[6] = v10;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Disabling transient authorization on %u:%u applets", buf, 0x2Eu);
      }

      [v11 subarrayWithRange:v12, v10];
      id v24 = (id)objc_claimAutoreleasedReturnValue();
      id v25 = v178;
      id v183 = 0;
      id v26 = [a1 selectCRSWithError:&v183];
      id v27 = v183;
      int v28 = v27;
      if (v27)
      {
        if ([v27 code]) {
          uint64_t v29 = (uint64_t)[v28 code];
        }
        else {
          uint64_t v29 = 16;
        }
      }
      else
      {
        if (a2)
        {
          uint64_t v29 = sub_1000C7C84((uint64_t)a1, 1, v24, 0);
          goto LABEL_147;
        }
        if (v178)
        {
          kdebug_trace();
          uint64_t v29 = NFSharedSignpostLog();
          if (os_signpost_enabled((os_log_t)v29))
          {
            *(_WORD *)buf = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, (os_log_t)v29, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseGetHostChallenge in", buf, 2u);
          }

          id v182 = 0;
          LODWORD(v29) = sub_10021F7F0((uint64_t)NFSSEWrapper, &v182);
          os_log_t log = (os_log_t)v182;
          kdebug_trace();
          id v30 = NFSharedSignpostLog();
          if (os_signpost_enabled(v30))
          {
            *(_WORD *)buf = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v30, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseGetHostChallenge out", buf, 2u);
          }

          os_log_t v31 = log;
          if (!log || v29)
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v59 = NFLogGetLogger();
            if (v59)
            {
              BOOL v60 = (void (*)(uint64_t, const char *, ...))v59;
              uint64_t v61 = object_getClass(a1);
              BOOL v62 = class_isMetaClass(v61);
              int v63 = object_getClassName(a1);
              int v160 = sel_getName("_requireTransientAuth:uid:applets:authorization:");
              uint64_t v64 = 45;
              if (v62) {
                uint64_t v64 = 43;
              }
              v60(3, "%c[%{public}s %{public}s]:%i Failed to get host challenge", v64, v63, v160, 1280);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            int v65 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
            {
              uint64_t v66 = object_getClass(a1);
              if (class_isMetaClass(v66)) {
                int v67 = 43;
              }
              else {
                int v67 = 45;
              }
              CFStringRef v68 = object_getClassName(a1);
              BOOL v69 = sel_getName("_requireTransientAuth:uid:applets:authorization:");
              *(_DWORD *)buf = 67109890;
              int v185 = v67;
              __int16 v186 = 2082;
              int v187 = v68;
              __int16 v188 = 2082;
              CFStringRef v189 = v69;
              __int16 v190 = 1024;
              int v191 = 1280;
              _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get host challenge", buf, 0x22u);
            }

            if (v29) {
              uint64_t v29 = v29;
            }
            else {
              uint64_t v29 = 6;
            }
          }
          else
          {
            if ([log length] == (id)8)
            {
              id v181 = 0;
              uint64_t v29 = sub_1000C5684(a1, log, &v181);
              id v32 = v181;
              id v173 = v32;
              if (v29)
              {
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v33 = NFLogGetLogger();
                if (v33)
                {
                  id v34 = (void (*)(uint64_t, const char *, ...))v33;
                  int v35 = object_getClass(a1);
                  BOOL v36 = class_isMetaClass(v35);
                  uint64_t v37 = object_getClassName(a1);
                  CFStringRef v38 = sel_getName("_requireTransientAuth:uid:applets:authorization:");
                  if (v29 >= 0x47) {
                    int v39 = 71;
                  }
                  else {
                    int v39 = v29;
                  }
                  id v168 = off_100306F98[v39];
                  uint64_t v40 = 45;
                  if (v36) {
                    uint64_t v40 = 43;
                  }
                  int v151 = v37;
                  id v11 = v174;
                  v34(3, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", v40, v151, v38, 1292, @"Failed to authenticate", v29, v168);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                id v41 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
                {
                  id v42 = object_getClass(a1);
                  if (class_isMetaClass(v42)) {
                    int v43 = 43;
                  }
                  else {
                    int v43 = 45;
                  }
                  BOOL v44 = object_getClassName(a1);
                  os_log_type_t v45 = sel_getName("_requireTransientAuth:uid:applets:authorization:");
                  if (v29 >= 0x47) {
                    int v46 = 71;
                  }
                  else {
                    int v46 = v29;
                  }
                  BOOL v47 = off_100306F98[v46];
                  *(_DWORD *)buf = 67110658;
                  int v185 = v43;
                  id v11 = v174;
                  __int16 v186 = 2082;
                  int v187 = v44;
                  __int16 v188 = 2082;
                  CFStringRef v189 = v45;
                  __int16 v190 = 1024;
                  int v191 = 1292;
                  __int16 v192 = 2112;
                  *(void *)id v193 = @"Failed to authenticate";
                  *(_WORD *)&v193[8] = 1024;
                  int v194 = v29;
                  __int16 v195 = 2080;
                  v196 = v47;
                  _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", buf, 0x3Cu);
                }

                os_log_t v31 = log;
                goto LABEL_145;
              }
              if ([v32 length] == (id)16)
              {
                char v180 = 0;
                kdebug_trace();
                id v83 = NFSharedSignpostLog();
                if (os_signpost_enabled(v83))
                {
                  *(_WORD *)buf = 0;
                  _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v83, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseAuthorize out", buf, 2u);
                }

                __int16 v84 = [a1 serialNumberAsData];
                id v179 = 0;
                CFStringRef v171 = sub_10021F9D8((uint64_t)NFSSEWrapper, 6, v25, v84, v172, log, v173, &v180, &v179, 0, 0, 0, 0);
                id v170 = v179;

                kdebug_trace();
                int v85 = NFSharedSignpostLog();
                if (os_signpost_enabled(v85))
                {
                  *(_WORD *)buf = 0;
                  _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v85, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseAuthorize out", buf, 2u);
                }

                id v11 = v174;
                if (v171)
                {
                  if ([v171 length] == (id)8)
                  {
                    uint64_t v29 = sub_1000C7C84((uint64_t)a1, 0, v24, v171);
                    if (v29 >= 2)
                    {
                      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                      uint64_t v86 = NFLogGetLogger();
                      if (v86)
                      {
                        CFStringRef v87 = (void (*)(uint64_t, const char *, ...))v86;
                        unsigned int v88 = object_getClass(a1);
                        BOOL v89 = class_isMetaClass(v88);
                        __int16 v90 = object_getClassName(a1);
                        id v161 = sel_getName("_requireTransientAuth:uid:applets:authorization:");
                        uint64_t v91 = 45;
                        if (v89) {
                          uint64_t v91 = 43;
                        }
                        int v153 = v90;
                        id v11 = v174;
                        v87(3, "%c[%{public}s %{public}s]:%i Failed to disable transient auth requirement for applets %{public}@", v91, v153, v161, 1332, v24);
                      }
                      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                      BOOL v92 = NFSharedLogGetLogger();
                      if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
                      {
                        id v93 = object_getClass(a1);
                        if (class_isMetaClass(v93)) {
                          int v94 = 43;
                        }
                        else {
                          int v94 = 45;
                        }
                        id v95 = object_getClassName(a1);
                        uint64_t v96 = sel_getName("_requireTransientAuth:uid:applets:authorization:");
                        *(_DWORD *)buf = 67110146;
                        int v185 = v94;
                        id v11 = v174;
                        __int16 v186 = 2082;
                        int v187 = v95;
                        __int16 v188 = 2082;
                        CFStringRef v189 = v96;
                        __int16 v190 = 1024;
                        int v191 = 1332;
                        __int16 v192 = 2114;
                        *(void *)id v193 = v24;
                        _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to disable transient auth requirement for applets %{public}@", buf, 0x2Cu);
                      }

                      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                      uint64_t v97 = NFLogGetLogger();
                      if (v97)
                      {
                        int v98 = (void (*)(uint64_t, const char *, ...))v97;
                        int v99 = object_getClass(a1);
                        BOOL v100 = class_isMetaClass(v99);
                        unsigned int v101 = object_getClassName(a1);
                        uint64_t v102 = sel_getName("_requireTransientAuth:uid:applets:authorization:");
                        if (v29 >= 0x47) {
                          int v103 = 71;
                        }
                        else {
                          int v103 = v29;
                        }
                        int v169 = off_100306F98[v103];
                        uint64_t v104 = 45;
                        if (v100) {
                          uint64_t v104 = 43;
                        }
                        __int16 v154 = v101;
                        id v11 = v174;
                        v98(3, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", v104, v154, v102, 1333, @"Returned", v29, v169);
                      }
                      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                      BOOL v105 = NFSharedLogGetLogger();
                      if (os_log_type_enabled(v105, OS_LOG_TYPE_ERROR))
                      {
                        id v106 = object_getClass(a1);
                        if (class_isMetaClass(v106)) {
                          int v107 = 43;
                        }
                        else {
                          int v107 = 45;
                        }
                        id v108 = object_getClassName(a1);
                        uint64_t v109 = sel_getName("_requireTransientAuth:uid:applets:authorization:");
                        if (v29 >= 0x47) {
                          int v110 = 71;
                        }
                        else {
                          int v110 = v29;
                        }
                        int v111 = off_100306F98[v110];
                        *(_DWORD *)buf = 67110658;
                        int v185 = v107;
                        id v11 = v174;
                        __int16 v186 = 2082;
                        int v187 = v108;
                        __int16 v188 = 2082;
                        CFStringRef v189 = v109;
                        __int16 v190 = 1024;
                        int v191 = 1333;
                        __int16 v192 = 2112;
                        *(void *)id v193 = @"Returned";
                        *(_WORD *)&v193[8] = 1024;
                        int v194 = v29;
                        __int16 v195 = 2080;
                        v196 = v111;
                        _os_log_impl((void *)&_mh_execute_header, v105, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", buf, 0x3Cu);
                      }
                      BOOL v112 = v105;
                      os_log_t v31 = log;
                      goto LABEL_143;
                    }
LABEL_144:

                    goto LABEL_145;
                  }
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  uint64_t v137 = NFLogGetLogger();
                  if (v137)
                  {
                    long long v138 = (void (*)(uint64_t, const char *, ...))v137;
                    int v139 = object_getClass(a1);
                    BOOL v140 = class_isMetaClass(v139);
                    int v141 = object_getClassName(a1);
                    __int16 v142 = sel_getName("_requireTransientAuth:uid:applets:authorization:");
                    id v167 = [v171 length];
                    __int16 v164 = v142;
                    os_log_t v31 = log;
                    uint64_t v143 = 45;
                    if (v140) {
                      uint64_t v143 = 43;
                    }
                    int v157 = v141;
                    id v11 = v174;
                    v138(3, "%c[%{public}s %{public}s]:%i Invalid cryptogram length: %lu", v143, v157, v164, 1326, v167);
                  }
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  loga = NFSharedLogGetLogger();
                  if (os_log_type_enabled(loga, OS_LOG_TYPE_ERROR))
                  {
                    __int16 v144 = object_getClass(a1);
                    if (class_isMetaClass(v144)) {
                      int v145 = 43;
                    }
                    else {
                      int v145 = 45;
                    }
                    __int16 v146 = object_getClassName(a1);
                    int v147 = sel_getName("_requireTransientAuth:uid:applets:authorization:");
                    id v148 = [v171 length];
                    *(_DWORD *)buf = 67110146;
                    int v185 = v145;
                    __int16 v186 = 2082;
                    int v187 = v146;
                    __int16 v188 = 2082;
                    CFStringRef v189 = v147;
                    id v11 = v174;
                    __int16 v190 = 1024;
                    int v191 = 1326;
                    __int16 v192 = 2048;
                    *(void *)id v193 = v148;
                    _os_log_impl((void *)&_mh_execute_header, loga, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid cryptogram length: %lu", buf, 0x2Cu);
                  }
                  uint64_t v29 = 13;
                  BOOL v112 = loga;
                }
                else
                {
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  uint64_t v126 = NFLogGetLogger();
                  if (v126)
                  {
                    BOOL v127 = (void (*)(uint64_t, const char *, ...))v126;
                    int v128 = object_getClass(a1);
                    BOOL v129 = class_isMetaClass(v128);
                    BOOL v130 = object_getClassName(a1);
                    int v163 = sel_getName("_requireTransientAuth:uid:applets:authorization:");
                    uint64_t v131 = 45;
                    if (v129) {
                      uint64_t v131 = 43;
                    }
                    __int16 v156 = v130;
                    id v11 = v174;
                    v127(3, "%c[%{public}s %{public}s]:%i Failed to generate cryptogram", v131, v156, v163, 1322);
                  }
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  int v132 = NFSharedLogGetLogger();
                  if (os_log_type_enabled(v132, OS_LOG_TYPE_ERROR))
                  {
                    id v133 = object_getClass(a1);
                    if (class_isMetaClass(v133)) {
                      int v134 = 43;
                    }
                    else {
                      int v134 = 45;
                    }
                    long long v135 = object_getClassName(a1);
                    long long v136 = sel_getName("_requireTransientAuth:uid:applets:authorization:");
                    *(_DWORD *)buf = 67109890;
                    int v185 = v134;
                    id v11 = v174;
                    __int16 v186 = 2082;
                    int v187 = v135;
                    __int16 v188 = 2082;
                    CFStringRef v189 = v136;
                    __int16 v190 = 1024;
                    int v191 = 1322;
                    _os_log_impl((void *)&_mh_execute_header, v132, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to generate cryptogram", buf, 0x22u);
                  }
                  BOOL v112 = v132;
                  uint64_t v29 = 8;
                }
LABEL_143:

                goto LABEL_144;
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v113 = NFLogGetLogger();
              if (v113)
              {
                uint64_t v114 = (void (*)(uint64_t, const char *, ...))v113;
                __int16 v115 = object_getClass(a1);
                BOOL v116 = class_isMetaClass(v115);
                int v117 = object_getClassName(a1);
                CFStringRef v118 = sel_getName("_requireTransientAuth:uid:applets:authorization:");
                id v166 = [v173 length];
                int v162 = v118;
                os_log_t v31 = log;
                uint64_t v119 = 45;
                if (v116) {
                  uint64_t v119 = 43;
                }
                int v155 = v117;
                id v11 = v174;
                v114(3, "%c[%{public}s %{public}s]:%i Invalid authenticate response length: %lu", v119, v155, v162, 1296, v166);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              id v120 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v120, OS_LOG_TYPE_ERROR))
              {
                __int16 v121 = object_getClass(a1);
                if (class_isMetaClass(v121)) {
                  int v122 = 43;
                }
                else {
                  int v122 = 45;
                }
                uint64_t v123 = object_getClassName(a1);
                uint64_t v124 = sel_getName("_requireTransientAuth:uid:applets:authorization:");
                id v125 = [v173 length];
                *(_DWORD *)buf = 67110146;
                int v185 = v122;
                os_log_t v31 = log;
                __int16 v186 = 2082;
                int v187 = v123;
                __int16 v188 = 2082;
                CFStringRef v189 = v124;
                id v11 = v174;
                __int16 v190 = 1024;
                int v191 = 1296;
                __int16 v192 = 2048;
                *(void *)id v193 = v125;
                _os_log_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid authenticate response length: %lu", buf, 0x2Cu);
              }

              uint64_t v29 = 13;
LABEL_145:

LABEL_146:
              goto LABEL_147;
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v70 = NFLogGetLogger();
            if (v70)
            {
              id v71 = (void (*)(uint64_t, const char *, ...))v70;
              id v72 = object_getClass(a1);
              BOOL v73 = class_isMetaClass(v72);
              id v74 = object_getClassName(a1);
              id v75 = sel_getName("_requireTransientAuth:uid:applets:authorization:");
              id v165 = [log length];
              uint64_t v76 = 45;
              if (v73) {
                uint64_t v76 = 43;
              }
              v71(3, "%c[%{public}s %{public}s]:%i Invalid host challenge length: %lu", v76, v74, v75, 1284, v165);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            id v77 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v77, OS_LOG_TYPE_ERROR))
            {
              __int16 v78 = object_getClass(a1);
              if (class_isMetaClass(v78)) {
                int v79 = 43;
              }
              else {
                int v79 = 45;
              }
              __int16 v80 = object_getClassName(a1);
              int v81 = sel_getName("_requireTransientAuth:uid:applets:authorization:");
              id v82 = [log length];
              *(_DWORD *)buf = 67110146;
              int v185 = v79;
              __int16 v186 = 2082;
              int v187 = v80;
              __int16 v188 = 2082;
              CFStringRef v189 = v81;
              __int16 v190 = 1024;
              int v191 = 1284;
              __int16 v192 = 2048;
              *(void *)id v193 = v82;
              _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid host challenge length: %lu", buf, 0x2Cu);
            }

            uint64_t v29 = 13;
          }
          id v11 = v174;
          os_log_t v31 = log;
          goto LABEL_146;
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v48 = NFLogGetLogger();
        if (v48)
        {
          BOOL v49 = (void (*)(uint64_t, const char *, ...))v48;
          uint64_t v50 = object_getClass(a1);
          BOOL v51 = class_isMetaClass(v50);
          __int16 v52 = object_getClassName(a1);
          uint64_t v159 = sel_getName("_requireTransientAuth:uid:applets:authorization:");
          uint64_t v53 = 45;
          if (v51) {
            uint64_t v53 = 43;
          }
          __int16 v152 = v52;
          id v11 = v174;
          v49(3, "%c[%{public}s %{public}s]:%i Missing SSE handle", v53, v152, v159, 1268);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        BOOL v54 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
        {
          id v55 = object_getClass(a1);
          if (class_isMetaClass(v55)) {
            int v56 = 43;
          }
          else {
            int v56 = 45;
          }
          uint64_t v57 = object_getClassName(a1);
          BOOL v58 = sel_getName("_requireTransientAuth:uid:applets:authorization:");
          *(_DWORD *)buf = 67109890;
          int v185 = v56;
          __int16 v186 = 2082;
          int v187 = v57;
          id v11 = v174;
          __int16 v188 = 2082;
          CFStringRef v189 = v58;
          __int16 v190 = 1024;
          int v191 = 1268;
          _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Missing SSE handle", buf, 0x22u);
        }

        uint64_t v29 = 9;
      }
LABEL_147:

      if (v29)
      {

        goto LABEL_154;
      }
      v12 += v10;
      unsigned int v149 = (char *)[v11 count];
      if ((unint64_t)&v149[-v12] >= 0xC) {
        uint64_t v10 = 12;
      }
      else {
        uint64_t v10 = (uint64_t)&v149[-v12];
      }
    }
    while (v10);
  }
  uint64_t v29 = 0;
LABEL_154:

  return v29;
}

uint64_t sub_1001FF5AC(void *a1, void *a2, unsigned int a3, unsigned char *a4)
{
  id v7 = a2;
  if (a1)
  {
    id v80 = 0;
    id v8 = sub_100243D60(a1, &v80);
    id v9 = v80;
    if (v8)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        id v11 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("restoreTransientAuthForAllAppletsExcept:uid:updated:");
        uint64_t v14 = 45;
        if (isMetaClass) {
          uint64_t v14 = 43;
        }
        v11(3, "%c[%{public}s %{public}s]:%i getApplets failed - %{public}@", v14, ClassName, Name, 1365, v8);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v15 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        id v16 = object_getClass(a1);
        if (class_isMetaClass(v16)) {
          int v17 = 43;
        }
        else {
          int v17 = 45;
        }
        uint64_t v18 = object_getClassName(a1);
        uint64_t v19 = sel_getName("restoreTransientAuthForAllAppletsExcept:uid:updated:");
        *(_DWORD *)buf = 67110146;
        int v82 = v17;
        __int16 v83 = 2082;
        __int16 v84 = v18;
        __int16 v85 = 2082;
        uint64_t v86 = v19;
        __int16 v87 = 1024;
        int v88 = 1365;
        __int16 v89 = 2114;
        __int16 v90 = v8;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i getApplets failed - %{public}@", buf, 0x2Cu);
      }
      uint64_t v20 = 6;
    }
    else
    {
      unsigned int v65 = a3;
      uint64_t v66 = a4;
      int v15 = objc_opt_new();
      long long v76 = 0u;
      long long v77 = 0u;
      long long v78 = 0u;
      long long v79 = 0u;
      id v67 = v9;
      id v21 = v9;
      id v22 = [v21 countByEnumeratingWithState:&v76 objects:v94 count:16];
      if (v22)
      {
        id v23 = v22;
        uint64_t v24 = *(void *)v77;
        id v69 = v7;
        uint64_t v70 = v15;
        id v71 = a1;
        CFStringRef v68 = v21;
        do
        {
          for (i = 0; i != v23; i = (char *)i + 1)
          {
            if (*(void *)v77 != v24) {
              objc_enumerationMutation(v21);
            }
            id v26 = *(void **)(*((void *)&v76 + 1) + 8 * i);
            if ([v26 authTransientConfigurable]
              && ([v26 authTransientSupport] & 1) == 0
              && ([v26 isGPLocked] & 1) == 0
              && [v26 lifecycleState] == 15)
            {
              long long v74 = 0u;
              long long v75 = 0u;
              long long v72 = 0u;
              long long v73 = 0u;
              id v27 = v7;
              id v28 = [v27 countByEnumeratingWithState:&v72 objects:v93 count:16];
              if (v28)
              {
                id v29 = v28;
                uint64_t v30 = *(void *)v73;
                while (2)
                {
                  for (j = 0; j != v29; j = (char *)j + 1)
                  {
                    if (*(void *)v73 != v30) {
                      objc_enumerationMutation(v27);
                    }
                    id v32 = *(void **)(*((void *)&v72 + 1) + 8 * (void)j);
                    objc_opt_class();
                    if ((objc_opt_isKindOfClass() & 1) == 0)
                    {
                      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                      uint64_t v49 = NFLogGetLogger();
                      if (v49)
                      {
                        uint64_t v50 = (void (*)(uint64_t, const char *, ...))v49;
                        BOOL v51 = object_getClass(v71);
                        BOOL v52 = class_isMetaClass(v51);
                        uint64_t v53 = object_getClassName(v71);
                        uint64_t v64 = sel_getName("restoreTransientAuthForAllAppletsExcept:uid:updated:");
                        uint64_t v54 = 45;
                        if (v52) {
                          uint64_t v54 = 43;
                        }
                        v50(3, "%c[%{public}s %{public}s]:%i aids provided are not of NSString class", v54, v53, v64, 1382);
                      }
                      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                      id v55 = NFSharedLogGetLogger();
                      id v7 = v69;
                      int v15 = v70;
                      id v9 = v67;
                      id v8 = 0;
                      if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
                      {
                        int v56 = object_getClass(v71);
                        if (class_isMetaClass(v56)) {
                          int v57 = 43;
                        }
                        else {
                          int v57 = 45;
                        }
                        BOOL v58 = object_getClassName(v71);
                        uint64_t v59 = sel_getName("restoreTransientAuthForAllAppletsExcept:uid:updated:");
                        *(_DWORD *)buf = 67109890;
                        int v82 = v57;
                        __int16 v83 = 2082;
                        __int16 v84 = v58;
                        __int16 v85 = 2082;
                        uint64_t v86 = v59;
                        __int16 v87 = 1024;
                        int v88 = 1382;
                        _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i aids provided are not of NSString class", buf, 0x22u);
                      }

                      uint64_t v20 = 10;
                      goto LABEL_60;
                    }
                    uint64_t v33 = [v26 identifier];
                    id v34 = [v32 caseInsensitiveCompare:v33];

                    if (!v34)
                    {

                      id v7 = v69;
                      int v15 = v70;
                      a1 = v71;
                      id v21 = v68;
                      goto LABEL_33;
                    }
                  }
                  id v29 = [v27 countByEnumeratingWithState:&v72 objects:v93 count:16];
                  id v21 = v68;
                  id v7 = v69;
                  if (v29) {
                    continue;
                  }
                  break;
                }
              }

              int v15 = v70;
              [v70 addObject:v26];
              a1 = v71;
            }
LABEL_33:
            ;
          }
          id v23 = [v21 countByEnumeratingWithState:&v76 objects:v94 count:16];
        }
        while (v23);
      }

      if ([v15 count])
      {
        uint64_t v35 = sub_1001FE394(a1, 1, v65, v15, 0);
        id v8 = 0;
        if (v35)
        {
          uint64_t v36 = v35;
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v37 = NFLogGetLogger();
          if (v37)
          {
            CFStringRef v38 = (void (*)(uint64_t, const char *, ...))v37;
            int v39 = object_getClass(a1);
            BOOL v40 = class_isMetaClass(v39);
            id v41 = object_getClassName(a1);
            int v63 = sel_getName("restoreTransientAuthForAllAppletsExcept:uid:updated:");
            uint64_t v42 = 45;
            if (v40) {
              uint64_t v42 = 43;
            }
            v38(4, "%c[%{public}s %{public}s]:%i Failed to restore transient auth to applets %{public}@ : %d", v42, v41, v63, 1400, v15, v36);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          int v43 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
          {
            BOOL v44 = object_getClass(a1);
            if (class_isMetaClass(v44)) {
              int v45 = 43;
            }
            else {
              int v45 = 45;
            }
            int v46 = object_getClassName(a1);
            BOOL v47 = sel_getName("restoreTransientAuthForAllAppletsExcept:uid:updated:");
            *(_DWORD *)buf = 67110402;
            int v82 = v45;
            __int16 v83 = 2082;
            __int16 v84 = v46;
            __int16 v85 = 2082;
            uint64_t v86 = v47;
            __int16 v87 = 1024;
            int v88 = 1400;
            __int16 v89 = 2114;
            __int16 v90 = v15;
            __int16 v91 = 1024;
            int v92 = v36;
            _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to restore transient auth to applets %{public}@ : %d", buf, 0x32u);
          }
        }
        id v48 = sub_100244F68(a1, v15);
        id v9 = v67;
        uint64_t v20 = 0;
        if (v66) {
          *uint64_t v66 = 1;
        }
      }
      else
      {
        uint64_t v20 = 0;
        id v9 = v67;
        id v8 = 0;
      }
    }
LABEL_60:
  }
  else
  {
    uint64_t v20 = 0;
  }

  return v20;
}

id sub_1001FFC68(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v59 = 0;
  id v7 = [a1 selectCRSWithError:&v59];
  id v8 = v59;
  if (v8)
  {
    id v9 = v8;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v11 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("sendTokenToCRS:mac:");
      uint64_t v14 = 45;
      if (isMetaClass) {
        uint64_t v14 = 43;
      }
      v11(3, "%c[%{public}s %{public}s]:%i Failed to select CRS: %{public}@", v14, ClassName, Name, 1470, v9);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v15 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      id v16 = object_getClass(a1);
      if (class_isMetaClass(v16)) {
        int v17 = 43;
      }
      else {
        int v17 = 45;
      }
      uint64_t v18 = object_getClassName(a1);
      uint64_t v19 = sel_getName("sendTokenToCRS:mac:");
      *(_DWORD *)buf = 67110146;
      int v67 = v17;
      __int16 v68 = 2082;
      id v69 = v18;
      __int16 v70 = 2082;
      id v71 = v19;
      __int16 v72 = 1024;
      int v73 = 1470;
      __int16 v74 = 2114;
      id v75 = v9;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select CRS: %{public}@", buf, 0x2Cu);
    }
    goto LABEL_39;
  }
  if (!v7)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v27 = NFLogGetLogger();
    if (v27)
    {
      id v28 = (void (*)(uint64_t, const char *, ...))v27;
      id v29 = object_getClass(a1);
      BOOL v30 = class_isMetaClass(v29);
      os_log_t v31 = object_getClassName(a1);
      int v57 = sel_getName("sendTokenToCRS:mac:");
      uint64_t v32 = 45;
      if (v30) {
        uint64_t v32 = 43;
      }
      v28(3, "%c[%{public}s %{public}s]:%i Failed to select CRS, expecting RAPDU", v32, v31, v57, 1474);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v33 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      id v34 = object_getClass(a1);
      if (class_isMetaClass(v34)) {
        int v35 = 43;
      }
      else {
        int v35 = 45;
      }
      uint64_t v36 = object_getClassName(a1);
      uint64_t v37 = sel_getName("sendTokenToCRS:mac:");
      *(_DWORD *)buf = 67109890;
      int v67 = v35;
      __int16 v68 = 2082;
      id v69 = v36;
      __int16 v70 = 2082;
      id v71 = v37;
      __int16 v72 = 1024;
      int v73 = 1474;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select CRS, expecting RAPDU", buf, 0x22u);
    }

    id v38 = objc_alloc((Class)NSError);
    int v15 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v64 = NSLocalizedDescriptionKey;
    int v39 = +[NSString stringWithUTF8String:"Commmand Error"];
    unsigned int v65 = v39;
    BOOL v40 = &v65;
    id v41 = &v64;
    goto LABEL_38;
  }
  if ([v7 status] != 36864)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v42 = NFLogGetLogger();
    if (v42)
    {
      int v43 = (void (*)(uint64_t, const char *, ...))v42;
      BOOL v44 = object_getClass(a1);
      BOOL v45 = class_isMetaClass(v44);
      int v46 = object_getClassName(a1);
      BOOL v58 = sel_getName("sendTokenToCRS:mac:");
      uint64_t v47 = 45;
      if (v45) {
        uint64_t v47 = 43;
      }
      v43(3, "%c[%{public}s %{public}s]:%i Failed to select CRS, expecting0x9000", v47, v46, v58, 1478);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v48 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
    {
      uint64_t v49 = object_getClass(a1);
      if (class_isMetaClass(v49)) {
        int v50 = 43;
      }
      else {
        int v50 = 45;
      }
      BOOL v51 = object_getClassName(a1);
      BOOL v52 = sel_getName("sendTokenToCRS:mac:");
      *(_DWORD *)buf = 67109890;
      int v67 = v50;
      __int16 v68 = 2082;
      id v69 = v51;
      __int16 v70 = 2082;
      id v71 = v52;
      __int16 v72 = 1024;
      int v73 = 1478;
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select CRS, expecting0x9000", buf, 0x22u);
    }

    id v38 = objc_alloc((Class)NSError);
    int v15 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v62 = NSLocalizedDescriptionKey;
    int v39 = +[NSString stringWithUTF8String:"Commmand Error"];
    int v63 = v39;
    BOOL v40 = &v63;
    id v41 = &v62;
LABEL_38:
    uint64_t v53 = +[NSDictionary dictionaryWithObjects:v40 forKeys:v41 count:1];
    id v9 = [v38 initWithDomain:v15 code:16 userInfo:v53];

LABEL_39:
    goto LABEL_40;
  }
  unsigned int v20 = sub_1000C46D0(a1, v5, v6);
  if (v20)
  {
    unsigned int v21 = v20;
    id v22 = objc_alloc((Class)NSError);
    int v15 = +[NSString stringWithUTF8String:"nfcd"];
    uint64_t v23 = v21;
    NSErrorUserInfoKey v60 = NSLocalizedDescriptionKey;
    if (v21 >= 0x47) {
      int v24 = 71;
    }
    else {
      int v24 = v21;
    }
    id v25 = +[NSString stringWithUTF8String:off_100306F98[v24]];
    uint64_t v61 = v25;
    id v26 = +[NSDictionary dictionaryWithObjects:&v61 forKeys:&v60 count:1];
    id v9 = [v22 initWithDomain:v15 code:v23 userInfo:v26];

    goto LABEL_39;
  }
  id v9 = 0;
LABEL_40:

  return v9;
}

void sub_100200548(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, ...)
{
  va_start(va, a14);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100200568(uint64_t result, uint64_t a2, char a3, unsigned char *a4)
{
  if ((a3 & 0x10) == 0) {
    *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
  }
  *a4 = 1;
  return result;
}

BOOL sub_100200588(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  id v6 = a2;
  id v7 = [v6 length];
  if (v7 <= [*(id *)(a1 + 32) length])
  {
    id v9 = *(id *)(a1 + 32);
    if (*(void *)(a1 + 40) == 1)
    {
      id v10 = [v6 length];
      id v11 = [*(id *)(a1 + 32) length];
      uint64_t v12 = *(void **)(a1 + 32);
      if (v10 == v11)
      {
        id v13 = v12;
      }
      else
      {
        [v12 substringToIndex:[v6 length]];
        id v13 = (id)objc_claimAutoreleasedReturnValue();
      }
      id v14 = v13;

      id v9 = v14;
    }
    BOOL v8 = [v9 compare:v6 options:11] == 0;
  }
  else
  {
    BOOL v8 = 0;
    *a4 = 1;
  }

  return v8;
}

void sub_100200B8C(unsigned char *a1)
{
  if (a1)
  {
    self;
    a1[14] = MKBGetDeviceLockState() - 1 < 2;
    if (!a1[12] || !a1[13])
    {
      unsigned int valuePtr = 0;
      CFDictionaryRef v2 = (const __CFDictionary *)MKBGetDeviceLockStateInfo();
      if (v2)
      {
        CFDictionaryRef v3 = v2;
        CFNumberRef Value = (const __CFNumber *)CFDictionaryGetValue(v2, kMKBInfoBagState);
        if (Value && (CFNumberRef v5 = Value, TypeID = CFNumberGetTypeID(), TypeID == CFGetTypeID(v5)))
        {
          int v7 = CFNumberGetValue(v5, kCFNumberSInt32Type, &valuePtr);
          CFRelease(v3);
          if (v7)
          {
            unsigned int v8 = valuePtr;
            BOOL v9 = (valuePtr & 0x2000) == 0;
            a1[12] = (valuePtr & 6) != 0;
            if ((v8 & 6) == 0) {
              BOOL v9 = 0;
            }
            char v10 = (~v8 & 0xA000) == 0 || v9;
            a1[13] = v10;
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
            if (Logger)
            {
              if ((valuePtr & 0x2000) != 0) {
                CFStringRef v12 = &stru_100309C40;
              }
              else {
                CFStringRef v12 = @" not";
              }
              Logger(6, "%s:%i Keybag is%@ SE entangled, state is 0x%x", "-[NFKeyBag _updateFirstUnlockStatus]", 84, v12, valuePtr);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            id v13 = NFSharedLogGetLogger();
            if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_33;
            }
            if ((valuePtr & 0x2000) != 0) {
              CFStringRef v14 = &stru_100309C40;
            }
            else {
              CFStringRef v14 = @" not";
            }
            *(_DWORD *)buf = 136446978;
            int v24 = "-[NFKeyBag _updateFirstUnlockStatus]";
            __int16 v25 = 1024;
            int v26 = 84;
            __int16 v27 = 2112;
            CFStringRef v28 = v14;
            __int16 v29 = 1024;
            unsigned int v30 = valuePtr;
            int v15 = "%{public}s:%i Keybag is%@ SE entangled, state is 0x%x";
            id v16 = v13;
            os_log_type_t v17 = OS_LOG_TYPE_DEFAULT;
            uint32_t v18 = 34;
LABEL_32:
            _os_log_impl((void *)&_mh_execute_header, v16, v17, v15, buf, v18);
LABEL_33:

            return;
          }
        }
        else
        {
          CFRelease(v3);
        }
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v19 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v19) {
        v19(3, "%s:%i Failed to query unlock state", "GetKeybagState", 39);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      unsigned int v20 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        int v24 = "GetKeybagState";
        __int16 v25 = 1024;
        int v26 = 39;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "%{public}s:%i Failed to query unlock state", buf, 0x12u);
      }

      *((_WORD *)a1 + 6) = 257;
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      unsigned int v21 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v21) {
        v21(3, "%s:%i Error getting device unlock state", "-[NFKeyBag _updateFirstUnlockStatus]", 93);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v13 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446466;
      int v24 = "-[NFKeyBag _updateFirstUnlockStatus]";
      __int16 v25 = 1024;
      int v26 = 93;
      int v15 = "%{public}s:%i Error getting device unlock state";
      id v16 = v13;
      os_log_type_t v17 = OS_LOG_TYPE_ERROR;
      uint32_t v18 = 18;
      goto LABEL_32;
    }
  }
}

void sub_100200EE8(void *a1)
{
  if (a1)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      CFDictionaryRef v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("_lockStateChanged");
      uint64_t v7 = 45;
      if (isMetaClass) {
        uint64_t v7 = 43;
      }
      v3(6, "%c[%{public}s %{public}s]:%i ", v7, ClassName, Name, 132);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    unsigned int v8 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v9 = object_getClass(a1);
      if (class_isMetaClass(v9)) {
        int v10 = 43;
      }
      else {
        int v10 = 45;
      }
      *(_DWORD *)buf = 67109890;
      int v29 = v10;
      __int16 v30 = 2082;
      os_log_t v31 = object_getClassName(a1);
      __int16 v32 = 2082;
      uint64_t v33 = sel_getName("_lockStateChanged");
      __int16 v34 = 1024;
      int v35 = 132;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
    }

    id v11 = a1;
    objc_sync_enter(v11);
    sub_100200B8C(v11);
    int v12 = *((unsigned __int8 *)v11 + 14);
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v13 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v13)
    {
      CFStringRef v14 = object_getClass(v11);
      if (class_isMetaClass(v14)) {
        uint64_t v15 = 43;
      }
      else {
        uint64_t v15 = 45;
      }
      id v16 = object_getClassName(v11);
      os_log_type_t v17 = sel_getName("_lockStateChanged");
      v13(6, "%c[%{public}s %{public}s]:%i locked=%d beenUnlocked=%d beenSEUnlocked=%d", v15, v16, v17, 145, *((unsigned __int8 *)v11 + 14), *((unsigned __int8 *)v11 + 12), *((unsigned __int8 *)v11 + 13));
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint32_t v18 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = object_getClass(v11);
      if (class_isMetaClass(v19)) {
        int v20 = 43;
      }
      else {
        int v20 = 45;
      }
      unsigned int v21 = object_getClassName(v11);
      id v22 = sel_getName("_lockStateChanged");
      int v23 = *((unsigned __int8 *)v11 + 14);
      int v24 = *((unsigned __int8 *)v11 + 12);
      int v25 = *((unsigned __int8 *)v11 + 13);
      *(_DWORD *)buf = 67110658;
      int v29 = v20;
      __int16 v30 = 2082;
      os_log_t v31 = v21;
      __int16 v32 = 2082;
      uint64_t v33 = v22;
      __int16 v34 = 1024;
      int v35 = 145;
      __int16 v36 = 1024;
      int v37 = v23;
      __int16 v38 = 1024;
      int v39 = v24;
      __int16 v40 = 1024;
      int v41 = v25;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i locked=%d beenUnlocked=%d beenSEUnlocked=%d", buf, 0x34u);
    }

    int v26 = (void (**)(id, BOOL))objc_retainBlock(v11[2]);
    objc_sync_exit(v11);

    if (v26) {
      v26[2](v26, v12 != 0);
    }
  }
}

void sub_10020120C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100201234(void *a1, void *a2, void *a3)
{
  CFNumberRef v5 = a2;
  id v6 = a3;
  if (a1)
  {
    uint64_t v7 = a1;
    objc_sync_enter(v7);
    id v8 = objc_retainBlock(v6);
    BOOL v9 = (void *)*((void *)v7 + 2);
    *((void *)v7 + 2) = v8;

    objc_sync_exit(v7);
    if (v7[2] == -1)
    {
      handler[0] = _NSConcreteStackBlock;
      handler[1] = 3221225472;
      handler[2] = sub_100201324;
      handler[3] = &unk_100307230;
      handler[4] = v7;
      notify_register_dispatch("com.apple.mobile.keybagd.lock_status", v7 + 2, v5, handler);
      sub_100200EE8(v7);
    }
  }
}

void sub_100201324(uint64_t a1)
{
  CFDictionaryRef v2 = _os_activity_create((void *)&_mh_execute_header, "Lock state changed", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
  v3.opaque[0] = 0;
  v3.opaque[1] = 0;
  os_activity_scope_enter(v2, &v3);
  os_activity_scope_leave(&v3);

  sub_100200EE8(*(void **)(a1 + 32));
}

void sub_100201390(void *a1)
{
  if (a1)
  {
    id v1 = a1;
    objc_sync_enter(v1);
    CFDictionaryRef v2 = (void *)*((void *)v1 + 2);
    *((void *)v1 + 2) = 0;

    objc_sync_exit(v1);
    if ((v1[2] & 0x80000000) == 0)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        BOOL v4 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(v1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(v1);
        Name = sel_getName("unregisterStateChange");
        uint64_t v8 = 45;
        if (isMetaClass) {
          uint64_t v8 = 43;
        }
        v4(6, "%c[%{public}s %{public}s]:%i Clearing mkb notification", v8, ClassName, Name, 179);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      BOOL v9 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        int v10 = object_getClass(v1);
        if (class_isMetaClass(v10)) {
          int v11 = 43;
        }
        else {
          int v11 = 45;
        }
        *(_DWORD *)buf = 67109890;
        int v14 = v11;
        __int16 v15 = 2082;
        id v16 = object_getClassName(v1);
        __int16 v17 = 2082;
        uint32_t v18 = sel_getName("unregisterStateChange");
        __int16 v19 = 1024;
        int v20 = 179;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Clearing mkb notification", buf, 0x22u);
      }

      notify_cancel(v1[2]);
      v1[2] = -1;
    }
  }
}

BOOL sub_100201550(void *a1)
{
  if (!a1) {
    return 0;
  }
  id v1 = a1;
  objc_sync_enter(v1);
  BOOL v2 = v1[12] != 0;
  objc_sync_exit(v1);

  return v2;
}

BOOL sub_1002015A0(void *a1)
{
  if (!a1) {
    return 0;
  }
  id v1 = a1;
  objc_sync_enter(v1);
  BOOL v2 = v1[13] != 0;
  objc_sync_exit(v1);

  return v2;
}

BOOL sub_1002015F0(void *a1)
{
  if (!a1) {
    return 0;
  }
  id v1 = a1;
  objc_sync_enter(v1);
  BOOL v2 = v1[14] != 0;
  objc_sync_exit(v1);

  return v2;
}

BOOL sub_100201AE0(void *a1, uint64_t a2)
{
  BOOL v2 = 0;
  if (a1 && !a2)
  {
    BOOL v4 = @"CN";
    if (!sub_100202054()) {
      goto LABEL_34;
    }
    uint64_t v37 = 0;
    __int16 v38 = &v37;
    uint64_t v39 = 0x2020000000;
    CFNumberRef v5 = (uint64_t (*)(void))off_100347628;
    __int16 v40 = off_100347628;
    if (!off_100347628)
    {
      *(void *)buf = _NSConcreteStackBlock;
      *(void *)uint64_t v42 = 3221225472;
      *(void *)&v42[8] = sub_100202198;
      *(void *)&v42[16] = &unk_100301E40;
      *(void *)&v42[24] = &v37;
      id v6 = sub_1002021E8();
      uint64_t v7 = dlsym(v6, "CPPhoneNumberCopyNetworkCountryCode");
      *(void *)(*(void *)(*(void *)&v42[24] + 8) + 24) = v7;
      off_100347628 = *(_UNKNOWN **)(*(void *)(*(void *)&v42[24] + 8) + 24);
      CFNumberRef v5 = (uint64_t (*)(void))v38[3];
    }
    _Block_object_dispose(&v37, 8);
    if (v5)
    {
      uint64_t v8 = (const void *)v5();
      if (v8)
      {
LABEL_12:
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (Logger)
        {
          Class = object_getClass(a1);
          if (class_isMetaClass(Class)) {
            uint64_t v14 = 43;
          }
          else {
            uint64_t v14 = 45;
          }
          ClassName = object_getClassName(a1);
          Name = sel_getName("_isLastKnownCountryCode:");
          Logger(6, "%c[%{public}s %{public}s]:%i CountryCode is \"%{public}@\"\n", v14, ClassName, Name, 43, v8);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        __int16 v17 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
        {
          uint32_t v18 = object_getClass(a1);
          if (class_isMetaClass(v18)) {
            int v19 = 43;
          }
          else {
            int v19 = 45;
          }
          int v20 = object_getClassName(a1);
          unsigned int v21 = sel_getName("_isLastKnownCountryCode:");
          *(_DWORD *)buf = 67110146;
          *(_DWORD *)&uint8_t buf[4] = v19;
          *(_WORD *)uint64_t v42 = 2082;
          *(void *)&v42[2] = v20;
          *(_WORD *)&v42[10] = 2082;
          *(void *)&v42[12] = v21;
          *(_WORD *)&v42[20] = 1024;
          *(_DWORD *)&v42[22] = 43;
          *(_WORD *)&v42[26] = 2114;
          *(void *)&v42[28] = v8;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i CountryCode is \"%{public}@\"\n", buf, 0x2Cu);
        }

        BOOL v2 = [@"CN" caseInsensitiveCompare:v8] == 0;
        CFRelease(v8);
        goto LABEL_35;
      }
      uint64_t v37 = 0;
      __int16 v38 = &v37;
      uint64_t v39 = 0x2020000000;
      BOOL v9 = (uint64_t (*)(void))off_100347630;
      __int16 v40 = off_100347630;
      if (!off_100347630)
      {
        *(void *)buf = _NSConcreteStackBlock;
        *(void *)uint64_t v42 = 3221225472;
        *(void *)&v42[8] = sub_100202298;
        *(void *)&v42[16] = &unk_100301E40;
        *(void *)&v42[24] = &v37;
        int v10 = sub_1002021E8();
        int v11 = dlsym(v10, "CPPhoneNumberCopyLastKnownNetworkCountryCode");
        *(void *)(*(void *)(*(void *)&v42[24] + 8) + 24) = v11;
        off_100347630 = *(_UNKNOWN **)(*(void *)(*(void *)&v42[24] + 8) + 24);
        BOOL v9 = (uint64_t (*)(void))v38[3];
      }
      _Block_object_dispose(&v37, 8);
      if (v9)
      {
        uint64_t v8 = (const void *)v9();
        if (v8) {
          goto LABEL_12;
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v22 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v22)
        {
          int v23 = object_getClass(a1);
          if (class_isMetaClass(v23)) {
            uint64_t v24 = 43;
          }
          else {
            uint64_t v24 = 45;
          }
          int v25 = object_getClassName(a1);
          int v26 = sel_getName("_isLastKnownCountryCode:");
          v22(6, "%c[%{public}s %{public}s]:%i CountryCode is NULL", v24, v25, v26, 50);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        __int16 v27 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
        {
          CFStringRef v28 = object_getClass(a1);
          if (class_isMetaClass(v28)) {
            int v29 = 43;
          }
          else {
            int v29 = 45;
          }
          __int16 v30 = object_getClassName(a1);
          os_log_t v31 = sel_getName("_isLastKnownCountryCode:");
          *(_DWORD *)buf = 67109890;
          *(_DWORD *)&uint8_t buf[4] = v29;
          *(_WORD *)uint64_t v42 = 2082;
          *(void *)&v42[2] = v30;
          *(_WORD *)&v42[10] = 2082;
          *(void *)&v42[12] = v31;
          *(_WORD *)&v42[20] = 1024;
          *(_DWORD *)&v42[22] = 50;
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i CountryCode is NULL", buf, 0x22u);
        }

LABEL_34:
        BOOL v2 = 0;
LABEL_35:

        return v2;
      }
      int v35 = +[NSAssertionHandler currentHandler];
      __int16 v36 = +[NSString stringWithUTF8String:"CFStringRef NFCPPhoneNumberCopyLastKnownNetworkCountryCode(void)"];
      [v35 handleFailureInFunction:v36 file:@"NFCoreTelephonyConnection.m" lineNumber:19 description:@"%s" dlerror()];
    }
    else
    {
      uint64_t v33 = +[NSAssertionHandler currentHandler];
      __int16 v34 = +[NSString stringWithUTF8String:"CFStringRef NFCPPhoneNumberCopyNetworkCountryCode(void)"];
      [v33 handleFailureInFunction:v34 file:@"NFCoreTelephonyConnection.m" lineNumber:17 description:@"%s", dlerror()];
    }
    __break(1u);
  }
  return v2;
}

void sub_100202030(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_100202054()
{
  if (!qword_100347620) {
    qword_100347620 = _sl_dlopen();
  }
  return qword_100347620;
}

uint64_t sub_100202124()
{
  uint64_t result = _sl_dlopen();
  qword_100347620 = result;
  return result;
}

void *sub_100202198(uint64_t a1)
{
  BOOL v2 = sub_1002021E8();
  uint64_t result = dlsym(v2, "CPPhoneNumberCopyNetworkCountryCode");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_100347628 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *sub_1002021E8()
{
  uint64_t v0 = sub_100202054();
  if (v0) {
    return (void *)v0;
  }
  id v1 = +[NSAssertionHandler currentHandler];
  os_activity_scope_state_s v3 = +[NSString stringWithUTF8String:"void *AppSupportLibrary(void)"];
  [v1 handleFailureInFunction:v3 file:@"NFCoreTelephonyConnection.m" lineNumber:16 description:@"%s"];

  __break(1u);
  free(v4);
  return v1;
}

void *sub_100202298(uint64_t a1)
{
  BOOL v2 = sub_1002021E8();
  uint64_t result = dlsym(v2, "CPPhoneNumberCopyLastKnownNetworkCountryCode");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  off_100347630 = *(_UNKNOWN **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

id *sub_1002022E8(id *a1, void *a2)
{
  id v4 = a2;
  if (a1)
  {
    v9.receiver = a1;
    v9.super_class = (Class)NFScreenStateMonitor;
    CFNumberRef v5 = (id *)[super init];
    a1 = v5;
    if (v5)
    {
      objc_storeStrong(v5 + 1, a2);
      objc_storeWeak(a1 + 2, 0);
      id v6 = a1[3];
      a1[3] = 0;

      id v7 = a1[4];
      a1[4] = 0;

      a1[5] = 0;
      *((_DWORD *)a1 + 12) = -1;
    }
  }

  return a1;
}

void sub_100202390(id *a1, void *a2)
{
  id obj = a2;
  if (a1 && (NFIsDarwinOS() & 1) == 0)
  {
    objc_storeWeak(a1 + 2, obj);
    if (obj)
    {
      sub_100202430((uint64_t)a1);
      sub_1002026B0((uint64_t)a1);
    }
    else
    {
      [a1[4] setTransitionHandler:0];
      id v3 = a1[4];
      a1[4] = 0;

      [a1[3] invalidate];
      sub_100202910((uint64_t)a1);
    }
  }
}

void sub_100202430(uint64_t a1)
{
  if (a1 && !*(void *)(a1 + 32))
  {
    if (sub_10020295C() && sub_100202A64())
    {
      uint64_t v2 = [sub_10020295C() configurationForDefaultMainDisplayMonitor];
      id v3 = *(void **)(a1 + 32);
      *(void *)(a1 + 32) = v2;

      objc_initWeak(&location, (id)a1);
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 3221225472;
      v16[2] = sub_10000AE4C;
      v16[3] = &unk_100307298;
      objc_copyWeak(&v17, &location);
      [*(id *)(a1 + 32) setTransitionHandler:v16];
      uint64_t v4 = [sub_100202A64() monitorWithConfiguration:*(void *)(a1 + 32)];
      CFNumberRef v5 = *(void **)(a1 + 24);
      *(void *)(a1 + 24) = v4;

      objc_destroyWeak(&v17);
      objc_destroyWeak(&location);
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        id v7 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass((id)a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName((id)a1);
        Name = sel_getName("_registerFromFrontboardServices");
        uint64_t v11 = 45;
        if (isMetaClass) {
          uint64_t v11 = 43;
        }
        v7(3, "%c[%{public}s %{public}s]:%i FrontBoardServices is not available.", v11, ClassName, Name, 103);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v12 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        id v13 = object_getClass((id)a1);
        if (class_isMetaClass(v13)) {
          int v14 = 43;
        }
        else {
          int v14 = 45;
        }
        LODWORD(location) = 67109890;
        HIDWORD(location) = v14;
        __int16 v19 = 2082;
        int v20 = object_getClassName((id)a1);
        __int16 v21 = 2082;
        id v22 = sel_getName("_registerFromFrontboardServices");
        __int16 v23 = 1024;
        int v24 = 103;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i FrontBoardServices is not available.", (uint8_t *)&location, 0x22u);
      }
    }
  }
}

void sub_100202688(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location)
{
  objc_destroyWeak(v19);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1002026B0(uint64_t a1)
{
  if (a1 && NFIsInternalBuild())
  {
    objc_initWeak(&location, (id)a1);
    id v13 = _NSConcreteStackBlock;
    uint64_t v14 = 3221225472;
    __int16 v15 = sub_100202B6C;
    id v16 = &unk_100302900;
    objc_copyWeak(&v17, &location);
    uint64_t v2 = objc_retainBlock(&v13);
    if (notify_register_dispatch("com.apple.stockholm.bg.tag.detect.state", (int *)(a1 + 48), *(dispatch_queue_t *)(a1 + 8), v2))
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (Logger)
      {
        Class = object_getClass((id)a1);
        if (class_isMetaClass(Class)) {
          uint64_t v5 = 43;
        }
        else {
          uint64_t v5 = 45;
        }
        ClassName = object_getClassName((id)a1);
        Name = sel_getName("_registerBGTagDetectOverrideNotifications");
        Logger(4, "%c[%{public}s %{public}s]:%i Fail to register for bg tag detect state change", v5, ClassName, Name, 147, v13, v14, v15, v16);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v8 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        objc_super v9 = object_getClass((id)a1);
        if (class_isMetaClass(v9)) {
          int v10 = 43;
        }
        else {
          int v10 = 45;
        }
        uint64_t v11 = object_getClassName((id)a1);
        int v12 = sel_getName("_registerBGTagDetectOverrideNotifications");
        *(_DWORD *)buf = 67109890;
        int v20 = v10;
        __int16 v21 = 2082;
        id v22 = v11;
        __int16 v23 = 2082;
        int v24 = v12;
        __int16 v25 = 1024;
        int v26 = 147;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Fail to register for bg tag detect state change", buf, 0x22u);
      }
    }
    objc_destroyWeak(&v17);
    objc_destroyWeak(&location);
  }
}

void sub_1002028E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
  objc_destroyWeak(v18);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t sub_100202910(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t result = *(unsigned int *)(result + 48);
    if (result != -1)
    {
      uint64_t result = notify_is_valid_token(result);
      if (result) {
        uint64_t result = notify_cancel(*(_DWORD *)(v1 + 48));
      }
      *(_DWORD *)(v1 + 48) = -1;
    }
  }
  return result;
}

id sub_10020295C()
{
  uint64_t v3 = 0;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2050000000;
  uint64_t v0 = (void *)qword_100347638;
  uint64_t v6 = qword_100347638;
  if (!qword_100347638)
  {
    sub_100202D94();
    v4[3] = (uint64_t)objc_getClass("FBSDisplayLayoutMonitorConfiguration");
    qword_100347638 = v4[3];
    uint64_t v0 = (void *)v4[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v3, 8);

  return v1;
}

void sub_100202A4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_100202A64()
{
  uint64_t v3 = 0;
  uint64_t v4 = &v3;
  uint64_t v5 = 0x2050000000;
  uint64_t v0 = (void *)qword_100347648;
  uint64_t v6 = qword_100347648;
  if (!qword_100347648)
  {
    sub_100202D94();
    v4[3] = (uint64_t)objc_getClass("FBSDisplayLayoutMonitor");
    qword_100347648 = v4[3];
    uint64_t v0 = (void *)v4[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v3, 8);

  return v1;
}

void sub_100202B54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100202B6C(uint64_t a1, int a2)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    uint64_t state64 = 0;
    if (!notify_get_state(a2, &state64))
    {
      uint64_t v4 = state64;
      if (state64 == 1) {
        uint64_t v5 = "screen on update";
      }
      else {
        uint64_t v5 = "screen off update";
      }
      uint64_t v6 = _os_activity_create((void *)&_mh_execute_header, v5, (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
      state.opaque[0] = 0;
      state.opaque[1] = 0;
      os_activity_scope_enter(v6, &state);
      os_activity_scope_leave(&state);

      id v7 = objc_loadWeakRetained(WeakRetained + 2);
      char v8 = objc_opt_respondsToSelector();

      if (v8)
      {
        id v9 = objc_loadWeakRetained(WeakRetained + 2);
        [v9 didScreenStateChange:v4 == 1];
      }
    }
  }
}

BOOL sub_100202C68(void *a1)
{
  if (!a1) {
    return 0;
  }
  id v1 = a1;
  objc_sync_enter(v1);
  uint64_t v2 = *((void *)v1 + 5);
  objc_sync_exit(v1);

  if (!NFIsInternalBuild() || v2) {
    return v2;
  }
  int v3 = v1[12];
  if (v3 == -1) {
    return 0;
  }
  uint64_t state64 = 0;
  return !notify_get_state(v3, &state64) && state64 == 1;
}

Class sub_100202D44(uint64_t a1)
{
  sub_100202D94();
  Class result = objc_getClass("FBSDisplayLayoutMonitorConfiguration");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  qword_100347638 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_100202D94()
{
  if (!qword_100347640) {
    qword_100347640 = _sl_dlopen();
  }
}

uint64_t sub_100202E64()
{
  uint64_t result = _sl_dlopen();
  qword_100347640 = result;
  return result;
}

Class sub_100202ED8(uint64_t a1)
{
  sub_100202D94();
  Class result = objc_getClass("FBSDisplayLayoutMonitor");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  qword_100347648 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

uint64_t sub_100202F28()
{
  uint64_t result = _sl_dlopen();
  qword_100347650 = result;
  return result;
}

void *sub_100202F9C(void *a1)
{
  uint64_t v2 = sub_10000B064();
  if (v2)
  {
    int v3 = (void *)v2;
  }
  else
  {
    a1 = +[NSAssertionHandler currentHandler];
    int v3 = +[NSString stringWithUTF8String:"void *SpringBoardServicesLibrary(void)"];
    [a1 handleFailureInFunction:v3 file:@"NFScreenStateMonitor.m" lineNumber:26 description:@"%s"];

    __break(1u);
    free(v5);
  }
  uint64_t result = dlsym(v3, "SBSBacklightChangeSourceForDisplayLayoutTransitionReason");
  *(void *)(*(void *)(a1[4] + 8) + 24) = result;
  qword_100347658 = *(void *)(*(void *)(a1[4] + 8) + 24);
  return result;
}

void sub_10020307C(uint64_t a1, void *a2)
{
  id v2 = a2;
  self;
  int v3 = +[NFCALogger sharedCALogger];
  v13[0] = @"operationType";
  uint64_t v4 = [v2 objectForKey:@"purpleTrustOperationType"];
  uint64_t v5 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", [v4 unsignedIntValue]);
  v14[0] = v5;
  v13[1] = @"errorStep";
  uint64_t v6 = [v2 objectForKey:@"purpleTrustOperationErrorStep"];
  id v7 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", [v6 unsignedIntValue]);
  v14[1] = v7;
  void v13[2] = @"awdErrorCode";
  char v8 = [v2 objectForKey:@"purpleTrustOperationCAErrorCode"];
  id v9 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", [v8 unsignedIntValue]);
  void v14[2] = v9;
  v13[3] = @"errorCode";
  int v10 = [v2 objectForKey:@"purpleTrustOperationErrorCode"];

  uint64_t v11 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", [v10 unsignedIntValue]);
  v14[3] = v11;
  int v12 = +[NSDictionary dictionaryWithObjects:v14 forKeys:v13 count:4];
  [v3 postCAEventFor:@"com.apple.nfcd.purpleTrustOperationEvent" eventInput:v12];
}

void sub_10020328C(uint64_t a1, void *a2)
{
  id v2 = a2;
  self;
  int v3 = +[NFCALogger sharedCALogger];
  unsigned int v4 = [v3 getTimestamp];

  uint64_t v5 = +[NFCALogger sharedCALogger];
  v13[0] = @"errorStep";
  uint64_t v6 = [v2 objectForKey:@"peerPaymentEnrollmentErrorStep"];
  id v7 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", [v6 unsignedIntValue]);
  v14[0] = v7;
  v13[1] = @"errorCode";
  char v8 = [v2 objectForKey:@"peerPaymentEnrollmentErrorCode"];
  id v9 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", [v8 unsignedIntValue]);
  v14[1] = v9;
  void v13[2] = @"duration";
  int v10 = [v2 objectForKey:@"peerPaymentEnrollmentStartTime"];

  uint64_t v11 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v4 - [v10 unsignedLongLongValue]);
  void v14[2] = v11;
  int v12 = +[NSDictionary dictionaryWithObjects:v14 forKeys:v13 count:3];
  [v5 postCAEventFor:@"com.apple.nfcd.peerPaymentEnrolledEvent" eventInput:v12];
}

void sub_10020346C(uint64_t a1, void *a2)
{
  id v2 = a2;
  self;
  int v3 = +[NFCALogger sharedCALogger];
  unsigned int v14 = [v3 getTimestamp];

  unsigned int v4 = +[NFCALogger sharedCALogger];
  v15[0] = @"type";
  uint64_t v5 = [v2 objectForKey:@"peerPaymentRequestType"];
  uint64_t v6 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", [v5 unsignedIntValue]);
  v16[0] = v6;
  v15[1] = @"errorStep";
  id v7 = [v2 objectForKey:@"peerPaymentRequestErrorStep"];
  char v8 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", [v7 unsignedIntValue]);
  v16[1] = v8;
  void v15[2] = @"errorCode";
  id v9 = [v2 objectForKey:@"peerPaymentRequestErrorCode"];
  int v10 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", [v9 unsignedIntValue]);
  v16[2] = v10;
  v15[3] = @"duration";
  uint64_t v11 = [v2 objectForKey:@"peerPaymentRequestStartTime"];

  int v12 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", v14 - [v11 unsignedLongLongValue]);
  v16[3] = v12;
  id v13 = +[NSDictionary dictionaryWithObjects:v16 forKeys:v15 count:4];
  [v4 postCAEventFor:@"com.apple.nfcd.peerPaymentRequestEvent" eventInput:v13];
}

void sub_100203D94(uint64_t a1)
{
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    id v22 = [*(id *)(a1 + 32) _getSecureElementWrapperForSEID:*(void *)(a1 + 40)];
    if (v22)
    {
      uint32_t v18 = v22;
      uint64_t v23 = *(unsigned __int8 *)(a1 + 64);
      id v40 = 0;
      int v20 = sub_1000A695C(v22, v23, &v40);
      id v19 = v40;
      (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        __int16 v25 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(*(id *)(a1 + 32));
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(*(id *)(a1 + 32));
        Name = sel_getName(*(SEL *)(a1 + 56));
        uint64_t v29 = 45;
        if (isMetaClass) {
          uint64_t v29 = 43;
        }
        v25(3, "%c[%{public}s %{public}s]:%i Invalid secure element", v29, ClassName, Name, 72);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v30 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        os_log_t v31 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v31)) {
          int v32 = 43;
        }
        else {
          int v32 = 45;
        }
        uint64_t v33 = object_getClassName(*(id *)(a1 + 32));
        __int16 v34 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)buf = 67109890;
        int v46 = v32;
        __int16 v47 = 2082;
        id v48 = v33;
        __int16 v49 = 2082;
        int v50 = v34;
        __int16 v51 = 1024;
        int v52 = 72;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid secure element", buf, 0x22u);
      }

      uint64_t v35 = *(void *)(a1 + 48);
      id v36 = objc_alloc((Class)NSError);
      id v19 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v41 = NSLocalizedDescriptionKey;
      int v20 = +[NSString stringWithUTF8String:"Stack Error"];
      uint64_t v42 = v20;
      uint64_t v37 = +[NSDictionary dictionaryWithObjects:&v42 forKeys:&v41 count:1];
      id v38 = [v36 initWithDomain:v19 code:15 userInfo:v37];
      (*(void (**)(uint64_t, void, id))(v35 + 16))(v35, 0, v38);

      uint32_t v18 = 0;
    }
    goto LABEL_15;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v2 = NFLogGetLogger();
  if (v2)
  {
    int v3 = (void (*)(uint64_t, const char *, ...))v2;
    unsigned int v4 = object_getClass(*(id *)(a1 + 32));
    BOOL v5 = class_isMetaClass(v4);
    uint64_t v6 = object_getClassName(*(id *)(a1 + 32));
    id v7 = sel_getName(*(SEL *)(a1 + 56));
    char v8 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v9 = 45;
    if (v5) {
      uint64_t v9 = 43;
    }
    v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, v6, v7, 65, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    uint64_t v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    id v13 = object_getClassName(*(id *)(a1 + 32));
    unsigned int v14 = sel_getName(*(SEL *)(a1 + 56));
    __int16 v15 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)buf = 67110146;
    int v46 = v12;
    __int16 v47 = 2082;
    id v48 = v13;
    __int16 v49 = 2082;
    int v50 = v14;
    __int16 v51 = 1024;
    int v52 = 65;
    __int16 v53 = 2114;
    uint64_t v54 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v16 = *(void *)(a1 + 48);
  if (v16)
  {
    id v17 = objc_alloc((Class)NSError);
    uint32_t v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v43 = NSLocalizedDescriptionKey;
    id v19 = +[NSString stringWithUTF8String:"Session not active"];
    id v44 = v19;
    int v20 = +[NSDictionary dictionaryWithObjects:&v44 forKeys:&v43 count:1];
    id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
    (*(void (**)(uint64_t, void, id))(v16 + 16))(v16, 0, v21);

LABEL_15:
  }
}

void sub_100204364(uint64_t a1)
{
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    id v22 = [*(id *)(a1 + 32) _getSecureElementWrapperForSEID:*(void *)(a1 + 40)];
    if (v22)
    {
      uint32_t v18 = v22;
      uint64_t v23 = *(void *)(a1 + 48);
      int v24 = sub_1000AB908(v22, *(unsigned __int8 *)(a1 + 64));
      (*(void (**)(uint64_t, void *))(v23 + 16))(v23, v24);
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        int v26 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(*(id *)(a1 + 32));
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(*(id *)(a1 + 32));
        Name = sel_getName(*(SEL *)(a1 + 56));
        uint64_t v30 = 45;
        if (isMetaClass) {
          uint64_t v30 = 43;
        }
        v26(3, "%c[%{public}s %{public}s]:%i Invalid secure element", v30, ClassName, Name, 94);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      os_log_t v31 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        int v32 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v32)) {
          int v33 = 43;
        }
        else {
          int v33 = 45;
        }
        __int16 v34 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v35 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)buf = 67109890;
        int v48 = v33;
        __int16 v49 = 2082;
        int v50 = v34;
        __int16 v51 = 2082;
        int v52 = v35;
        __int16 v53 = 1024;
        int v54 = 94;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid secure element", buf, 0x22u);
      }

      uint64_t v36 = *(void *)(a1 + 48);
      id v37 = objc_alloc((Class)NSError);
      id v38 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v43 = NSLocalizedDescriptionKey;
      uint64_t v39 = +[NSString stringWithUTF8String:"Stack Error"];
      id v44 = v39;
      id v40 = +[NSDictionary dictionaryWithObjects:&v44 forKeys:&v43 count:1];
      id v41 = [v37 initWithDomain:v38 code:15 userInfo:v40];
      (*(void (**)(uint64_t, id))(v36 + 16))(v36, v41);

      uint32_t v18 = 0;
    }
    goto LABEL_15;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v2 = NFLogGetLogger();
  if (v2)
  {
    int v3 = (void (*)(uint64_t, const char *, ...))v2;
    unsigned int v4 = object_getClass(*(id *)(a1 + 32));
    BOOL v5 = class_isMetaClass(v4);
    uint64_t v6 = object_getClassName(*(id *)(a1 + 32));
    id v7 = sel_getName(*(SEL *)(a1 + 56));
    char v8 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v9 = 45;
    if (v5) {
      uint64_t v9 = 43;
    }
    v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, v6, v7, 89, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    uint64_t v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    id v13 = object_getClassName(*(id *)(a1 + 32));
    unsigned int v14 = sel_getName(*(SEL *)(a1 + 56));
    __int16 v15 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)buf = 67110146;
    int v48 = v12;
    __int16 v49 = 2082;
    int v50 = v13;
    __int16 v51 = 2082;
    int v52 = v14;
    __int16 v53 = 1024;
    int v54 = 89;
    __int16 v55 = 2114;
    int v56 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v16 = *(void *)(a1 + 48);
  if (v16)
  {
    id v17 = objc_alloc((Class)NSError);
    uint32_t v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v45 = NSLocalizedDescriptionKey;
    id v19 = +[NSString stringWithUTF8String:"Session not active"];
    int v46 = v19;
    int v20 = +[NSDictionary dictionaryWithObjects:&v46 forKeys:&v45 count:1];
    id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
    (*(void (**)(uint64_t, id))(v16 + 16))(v16, v21);

LABEL_15:
  }
}

void sub_1002048F4(uint64_t a1)
{
  uint64_t v2 = objc_opt_new();
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    id v19 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];

    if (v19)
    {
      uint64_t v23 = objc_opt_new();
      buf[0] = 0;
      int v24 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      __int16 v25 = sub_1000AE4D0(v24);

      if (v25)
      {
        int v26 = +[NSNumber numberWithBool:buf[0]];
        [v23 setValue:v26 forKey:@"HasACLog"];
      }
      __int16 v27 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      id v31 = 0;
      CFStringRef v28 = sub_1000AD750(v27, &v31);
      id v19 = v31;

      if (v28) {
        [v23 setValue:v28 forKey:@"ACLog"];
      }
      uint64_t v29 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      uint64_t v30 = [v29 systemOSSerialNumber];
      [v2 setValue:v23 forKey:v30];
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    goto LABEL_15;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    unsigned int v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v9 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v10 = 45;
    if (isMetaClass) {
      uint64_t v10 = 43;
    }
    v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, ClassName, Name, 110, v9);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v11 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    int v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12)) {
      int v13 = 43;
    }
    else {
      int v13 = 45;
    }
    unsigned int v14 = object_getClassName(*(id *)(a1 + 32));
    __int16 v15 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v16 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)buf = 67110146;
    int v35 = v13;
    __int16 v36 = 2082;
    id v37 = v14;
    __int16 v38 = 2082;
    uint64_t v39 = v15;
    __int16 v40 = 1024;
    int v41 = 110;
    __int16 v42 = 2114;
    NSErrorUserInfoKey v43 = v16;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v17 = *(void *)(a1 + 40);
  if (v17)
  {
    id v18 = objc_alloc((Class)NSError);
    id v19 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v32 = NSLocalizedDescriptionKey;
    int v20 = +[NSString stringWithUTF8String:"Session not active"];
    int v33 = v20;
    id v21 = +[NSDictionary dictionaryWithObjects:&v33 forKeys:&v32 count:1];
    id v22 = [v18 initWithDomain:v19 code:54 userInfo:v21];
    (*(void (**)(uint64_t, id, void))(v17 + 16))(v17, v22, 0);

LABEL_15:
  }
}

void sub_100204DB8(uint64_t a1)
{
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      int v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(Class)) {
        uint64_t v5 = 43;
      }
      else {
        uint64_t v5 = 45;
      }
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      char v8 = [*(id *)(a1 + 32) sessionUID];
      v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v5, ClassName, Name, 136, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      int v12 = object_getClassName(*(id *)(a1 + 32));
      int v13 = sel_getName(*(SEL *)(a1 + 48));
      unsigned int v14 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)&uint8_t buf[4] = v11;
      *(_WORD *)int v63 = 2082;
      *(void *)&v63[2] = v12;
      *(_WORD *)&v63[10] = 2082;
      *(void *)&v63[12] = v13;
      *(_WORD *)&v63[20] = 1024;
      *(_DWORD *)&v63[22] = 136;
      *(_WORD *)&v63[26] = 2114;
      *(void *)&v63[28] = v14;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v15 = *(void *)(a1 + 40);
    if (v15)
    {
      id v16 = objc_alloc((Class)NSError);
      uint64_t v17 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v66 = NSLocalizedDescriptionKey;
      id v18 = +[NSString stringWithUTF8String:"Session not active"];
      int v67 = v18;
      id v19 = +[NSDictionary dictionaryWithObjects:&v67 forKeys:&v66 count:1];
      id v20 = [v16 initWithDomain:v17 code:54 userInfo:v19];
      (*(void (**)(uint64_t, id))(v15 + 16))(v15, v20);
    }
  }
  else if (NFIsInternalBuild())
  {
    *(void *)buf = 0;
    *(void *)int v63 = buf;
    *(void *)&v63[8] = 0x3032000000;
    *(void *)&v63[16] = sub_10000B928;
    *(void *)&v63[24] = sub_100205494;
    *(void *)&v63[32] = 0;
    id v21 = +[_NFHardwareManager sharedHardwareManager];
    v52[0] = _NSConcreteStackBlock;
    v52[1] = 3221225472;
    v52[2] = sub_10020549C;
    v52[3] = &unk_1003072F0;
    void v52[4] = *(void *)(a1 + 32);
    v52[5] = buf;
    char v53 = *(unsigned char *)(a1 + 56);
    id v22 = +[NFRoutingConfig routingOffWithFD:0];
    char v23 = sub_1000F23D8(v21, v52, @"enable SMB logging", v22);

    if ((v23 & 1) == 0)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v24 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v24)
      {
        __int16 v25 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v25)) {
          uint64_t v26 = 43;
        }
        else {
          uint64_t v26 = 45;
        }
        __int16 v27 = object_getClassName(*(id *)(a1 + 32));
        CFStringRef v28 = sel_getName(*(SEL *)(a1 + 48));
        v24(3, "%c[%{public}s %{public}s]:%i Failed to enable SMB log", v26, v27, v28, 152);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v29 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        uint64_t v30 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v30)) {
          int v31 = 43;
        }
        else {
          int v31 = 45;
        }
        NSErrorUserInfoKey v32 = object_getClassName(*(id *)(a1 + 32));
        int v33 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)int v54 = 67109890;
        int v55 = v31;
        __int16 v56 = 2082;
        int v57 = v32;
        __int16 v58 = 2082;
        id v59 = v33;
        __int16 v60 = 1024;
        int v61 = 152;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to enable SMB log", v54, 0x22u);
      }
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    _Block_object_dispose(buf, 8);
  }
  else
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v34 = NFLogGetLogger();
    if (v34)
    {
      int v35 = (void (*)(uint64_t, const char *, ...))v34;
      __int16 v36 = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(v36);
      __int16 v38 = object_getClassName(*(id *)(a1 + 32));
      __int16 v51 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v39 = 45;
      if (isMetaClass) {
        uint64_t v39 = 43;
      }
      v35(4, "%c[%{public}s %{public}s]:%i Not an internal build", v39, v38, v51, 139);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v40 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      int v41 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v41)) {
        int v42 = 43;
      }
      else {
        int v42 = 45;
      }
      NSErrorUserInfoKey v43 = object_getClassName(*(id *)(a1 + 32));
      id v44 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)&uint8_t buf[4] = v42;
      *(_WORD *)int v63 = 2082;
      *(void *)&v63[2] = v43;
      *(_WORD *)&v63[10] = 2082;
      *(void *)&v63[12] = v44;
      *(_WORD *)&v63[20] = 1024;
      *(_DWORD *)&v63[22] = 139;
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Not an internal build", buf, 0x22u);
    }

    uint64_t v45 = *(void *)(a1 + 40);
    id v46 = objc_alloc((Class)NSError);
    __int16 v47 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v64 = NSLocalizedDescriptionKey;
    int v48 = +[NSString stringWithUTF8String:"Feature Not Supported"];
    unsigned int v65 = v48;
    __int16 v49 = +[NSDictionary dictionaryWithObjects:&v65 forKeys:&v64 count:1];
    id v50 = [v46 initWithDomain:v47 code:14 userInfo:v49];
    (*(void (**)(uint64_t, id))(v45 + 16))(v45, v50);
  }
}

void sub_100205468(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_100205494(uint64_t a1)
{
}

BOOL sub_10020549C(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) driverWrapper];
  uint64_t v3 = sub_1001EC760(v2, *(unsigned __int8 *)(a1 + 48));
  uint64_t v4 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = v3;

  return *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) == 0;
}

void sub_1002055D4(uint64_t a1)
{
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(Class)) {
        uint64_t v5 = 43;
      }
      else {
        uint64_t v5 = 45;
      }
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      char v8 = [*(id *)(a1 + 32) sessionUID];
      v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v5, ClassName, Name, 161, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      int v12 = object_getClassName(*(id *)(a1 + 32));
      int v13 = sel_getName(*(SEL *)(a1 + 48));
      unsigned int v14 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)buf = 67110146;
      int v71 = v11;
      __int16 v72 = 2082;
      int v73 = v12;
      __int16 v74 = 2082;
      id v75 = v13;
      __int16 v76 = 1024;
      int v77 = 161;
      __int16 v78 = 2114;
      long long v79 = v14;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v15 = *(void *)(a1 + 40);
    if (v15)
    {
      id v16 = objc_alloc((Class)NSError);
      uint64_t v17 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v68 = NSLocalizedDescriptionKey;
      id v18 = +[NSString stringWithUTF8String:"Session not active"];
      id v69 = v18;
      id v19 = +[NSDictionary dictionaryWithObjects:&v69 forKeys:&v68 count:1];
      id v20 = [v16 initWithDomain:v17 code:54 userInfo:v19];
      (*(void (**)(uint64_t, id, void))(v15 + 16))(v15, v20, 0);
    }
  }
  else if (NFIsInternalBuild())
  {
    uint64_t v60 = 0;
    int v61 = &v60;
    uint64_t v62 = 0x2020000000;
    uint64_t v63 = 0;
    id v21 = +[_NFHardwareManager sharedHardwareManager];
    v59[0] = _NSConcreteStackBlock;
    v59[1] = 3221225472;
    void v59[2] = sub_100205D88;
    v59[3] = &unk_100304498;
    void v59[4] = *(void *)(a1 + 32);
    v59[5] = &v60;
    id v22 = +[NFRoutingConfig routingOffWithFD:0];
    char v23 = sub_1000F23D8(v21, v59, @"getting SMB log", v22);

    if (v23)
    {
      if (v61[3])
      {
        id v24 = objc_alloc((Class)NSData);
        id v25 = [v24 initWithBytes:*(void *)v61[3] length:*(void *)(v61[3] + 8)];
        NFDataRelease();
      }
      else
      {
        id v25 = 0;
      }
      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      NSErrorUserInfoKey v43 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v43)
      {
        id v44 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v44)) {
          uint64_t v45 = 43;
        }
        else {
          uint64_t v45 = 45;
        }
        id v46 = object_getClassName(*(id *)(a1 + 32));
        __int16 v47 = sel_getName(*(SEL *)(a1 + 48));
        v43(3, "%c[%{public}s %{public}s]:%i Failed to get SMB log", v45, v46, v47, 177);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v48 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
      {
        __int16 v49 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v49)) {
          int v50 = 43;
        }
        else {
          int v50 = 45;
        }
        __int16 v51 = object_getClassName(*(id *)(a1 + 32));
        int v52 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)buf = 67109890;
        int v71 = v50;
        __int16 v72 = 2082;
        int v73 = v51;
        __int16 v74 = 2082;
        id v75 = v52;
        __int16 v76 = 1024;
        int v77 = 177;
        _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get SMB log", buf, 0x22u);
      }

      uint64_t v53 = *(void *)(a1 + 40);
      id v54 = objc_alloc((Class)NSError);
      id v25 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v64 = NSLocalizedDescriptionKey;
      int v55 = +[NSString stringWithUTF8String:"Stack Error"];
      unsigned int v65 = v55;
      __int16 v56 = +[NSDictionary dictionaryWithObjects:&v65 forKeys:&v64 count:1];
      id v57 = [v54 initWithDomain:v25 code:15 userInfo:v56];
      (*(void (**)(uint64_t, id, void))(v53 + 16))(v53, v57, 0);
    }
    _Block_object_dispose(&v60, 8);
  }
  else
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v26 = NFLogGetLogger();
    if (v26)
    {
      __int16 v27 = (void (*)(uint64_t, const char *, ...))v26;
      CFStringRef v28 = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(v28);
      uint64_t v30 = object_getClassName(*(id *)(a1 + 32));
      __int16 v58 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v31 = 45;
      if (isMetaClass) {
        uint64_t v31 = 43;
      }
      v27(4, "%c[%{public}s %{public}s]:%i Not an internal build", v31, v30, v58, 164);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    NSErrorUserInfoKey v32 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      int v33 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v33)) {
        int v34 = 43;
      }
      else {
        int v34 = 45;
      }
      int v35 = object_getClassName(*(id *)(a1 + 32));
      __int16 v36 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67109890;
      int v71 = v34;
      __int16 v72 = 2082;
      int v73 = v35;
      __int16 v74 = 2082;
      id v75 = v36;
      __int16 v76 = 1024;
      int v77 = 164;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Not an internal build", buf, 0x22u);
    }

    uint64_t v37 = *(void *)(a1 + 40);
    id v38 = objc_alloc((Class)NSError);
    uint64_t v39 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v66 = NSLocalizedDescriptionKey;
    __int16 v40 = +[NSString stringWithUTF8String:"Feature Not Supported"];
    int v67 = v40;
    int v41 = +[NSDictionary dictionaryWithObjects:&v67 forKeys:&v66 count:1];
    id v42 = [v38 initWithDomain:v39 code:14 userInfo:v41];
    (*(void (**)(uint64_t, id, void))(v37 + 16))(v37, v42, 0);
  }
}

void sub_100205D58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_100205D88(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) driverWrapper];
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = sub_1001EC9C4(v2);

  return *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) != 0;
}

void sub_100205EA8(uint64_t a1)
{
  sub_100216594(*(void **)(*(void *)(a1 + 32) + 160));
  id v2 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_1002066C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id obj)
{
}

void sub_1002070C0(uint64_t a1, int a2)
{
  if (a1 && NFIsInternalBuild() && *(uint64_t *)(a1 + 296) >= 1)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    uint64_t v5 = (void (*)(uint64_t, const char *, ...))Logger;
    if (a2)
    {
      if (Logger)
      {
        Class = object_getClass((id)a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName((id)a1);
        Name = sel_getName("_enablePowerCountersLogging:");
        uint64_t v9 = 45;
        if (isMetaClass) {
          uint64_t v9 = 43;
        }
        v5(6, "%c[%{public}s %{public}s]:%i Enabling power counters timer", v9, ClassName, Name, 124);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v10 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        int v11 = object_getClass((id)a1);
        if (class_isMetaClass(v11)) {
          int v12 = 43;
        }
        else {
          int v12 = 45;
        }
        LODWORD(buf) = 67109890;
        HIDWORD(buf) = v12;
        __int16 v41 = 2082;
        id v42 = object_getClassName((id)a1);
        __int16 v43 = 2082;
        id v44 = sel_getName("_enablePowerCountersLogging:");
        __int16 v45 = 1024;
        int v46 = 124;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Enabling power counters timer", (uint8_t *)&buf, 0x22u);
      }

      int v13 = *(void **)(a1 + 216);
      *(unsigned char *)(a1 + 353) = 1;
      id v14 = v13;
      BOOL v15 = v14 == 0;

      if (v15)
      {
        id v16 = NSHomeDirectory();
        uint64_t v17 = +[NSString stringWithFormat:@"%@/Library/Logs/nfcd_lpcd_false-detect.plist", v16];

        id v18 = +[NSURL fileURLWithPath:v17];
        objc_storeStrong((id *)(a1 + 216), v18);
      }
      id v19 = *(id *)(a1 + 136);
      BOOL v20 = v19 == 0;

      if (v20)
      {
        objc_initWeak(&buf, (id)a1);
        id v21 = objc_alloc((Class)NFTimer);
        v38[0] = _NSConcreteStackBlock;
        v38[1] = 3221225472;
        v38[2] = sub_1002075A4;
        v38[3] = &unk_100304198;
        objc_copyWeak(&v39, &buf);
        v38[4] = a1;
        id v22 = *(id *)(a1 + 232);
        id v23 = [v21 initWithCallback:v38 queue:v22];
        objc_storeStrong((id *)(a1 + 136), v23);

        objc_destroyWeak(&v39);
        objc_destroyWeak(&buf);
      }
      id v24 = *(id *)(a1 + 136);
      [v24 stopTimer];

      id v25 = *(id *)(a1 + 136);
      [v25 startTimer:(double)*(uint64_t *)(a1 + 296) leeway:0.5];
    }
    else
    {
      if (Logger)
      {
        uint64_t v26 = object_getClass((id)a1);
        BOOL v27 = class_isMetaClass(v26);
        CFStringRef v28 = object_getClassName((id)a1);
        int v35 = sel_getName("_enablePowerCountersLogging:");
        uint64_t v29 = 45;
        if (v27) {
          uint64_t v29 = 43;
        }
        v5(6, "%c[%{public}s %{public}s]:%i Disabling power counters timer", v29, v28, v35, 149);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v30 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v31 = object_getClass((id)a1);
        if (class_isMetaClass(v31)) {
          int v32 = 43;
        }
        else {
          int v32 = 45;
        }
        LODWORD(buf) = 67109890;
        HIDWORD(buf) = v32;
        __int16 v41 = 2082;
        id v42 = object_getClassName((id)a1);
        __int16 v43 = 2082;
        id v44 = sel_getName("_enablePowerCountersLogging:");
        __int16 v45 = 1024;
        int v46 = 149;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Disabling power counters timer", (uint8_t *)&buf, 0x22u);
      }

      id v25 = *(id *)(a1 + 136);
      [v25 stopTimer];
    }

    int v33 = *(id *)(a1 + 232);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10020767C;
    block[3] = &unk_100301BC8;
    void block[4] = a1;
    char v37 = a2;
    dispatch_async(v33, block);
  }
}

void sub_100207578(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,id location)
{
  objc_destroyWeak(v25);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1002075A4(uint64_t a1)
{
  id v2 = _os_activity_create((void *)&_mh_execute_header, "com.apple.nfcd.hw.counter.powerTimer", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  v11.opaque[0] = 0;
  v11.opaque[1] = 0;
  os_activity_scope_enter(v2, &v11);
  os_activity_scope_leave(&v11);

  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v4 = WeakRetained;
  if (WeakRetained)
  {
    id v5 = [WeakRetained updateAllPowerCounters];
    id v6 = v4[17];
    [v6 stopTimer];

    id v7 = v4[17];
    char v8 = v7;
    uint64_t v9 = *(void *)(a1 + 32);
    if (v9) {
      double v10 = (double)*(uint64_t *)(v9 + 296);
    }
    else {
      double v10 = 0.0;
    }
    [v7 startTimer:v10 leeway:0.5];
  }
}

id sub_10020767C(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) updateAllPowerCounters];
  if (!*(unsigned char *)(a1 + 40))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3) {
      *(unsigned char *)(v3 + 353) = 0;
    }
  }
  return result;
}

id sub_1002077A0(uint64_t a1)
{
  return [*(id *)(a1 + 32) _sync_getPowerCountersForConnection:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];
}

id sub_100207BA8(id a1)
{
  id v1 = a1;
  if (a1)
  {
    id v2 = [a1 driverWrapper];
    id v35 = 0;
    uint64_t v3 = sub_1001E8A64(v2, &v35);
    id v29 = v35;

    if (v29)
    {
      if (v3 && [v3 code] != (id)45)
      {
        id v21 = objc_alloc((Class)NSError);
        uint64_t v30 = +[NSString stringWithUTF8String:"nfcd"];
        id v22 = [v3 code];
        v37[0] = NSLocalizedDescriptionKey;
        if ((uint64_t)[v3 code] > 70) {
          uint64_t v23 = 71;
        }
        else {
          uint64_t v23 = (uint64_t)[v3 code];
        }
        id v16 = +[NSString stringWithUTF8String:(&off_100307310)[v23]];
        v38[0] = v16;
        v38[1] = v3;
        v37[1] = NSUnderlyingErrorKey;
        v37[2] = @"Line";
        v38[2] = &off_10031F798;
        v37[3] = @"Method";
        id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("updateAllWriteCounters")];
        v38[3] = v24;
        v37[4] = NSDebugDescriptionErrorKey;
        id v25 = [[objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("updateAllWriteCounters"), 233];
        v38[4] = v25;
        uint64_t v26 = +[NSDictionary dictionaryWithObjects:v38 forKeys:v37 count:5];
        id v1 = [v21 initWithDomain:v30 code:v22 userInfo:v26];
      }
      else
      {
        uint64_t v30 = +[NSDictionary dictionaryWithObject:v29 forKey:@"NFCC Write Counters"];
        id obj = objc_getProperty(v1, v4, 176, 1);
        objc_sync_enter(obj);
        long long v31 = 0u;
        long long v32 = 0u;
        long long v33 = 0u;
        long long v34 = 0u;
        id v6 = objc_getProperty(v1, v5, 176, 1);
        id v7 = [v6 countByEnumeratingWithState:&v31 objects:v36 count:16];
        if (v7)
        {
          uint64_t v8 = *(void *)v32;
          do
          {
            for (i = 0; i != v7; i = (char *)i + 1)
            {
              if (*(void *)v32 != v8) {
                objc_enumerationMutation(v6);
              }
              double v10 = *(void **)(*((void *)&v31 + 1) + 8 * i);
              os_activity_scope_state_s v11 = [v10 NF_userInfo];
              int v12 = [v11 objectForKeyedSubscript:@"flashWriteCounters"];

              if (v12)
              {
                BOOL v13 = v3 && [v3 code] == (id)45;
                id v14 = [v1 combineFlashWriteCounters:v12 with:v30 overflow:v13];

                if (v14)
                {
                  BOOL v15 = [v10 NF_userInfo];
                  [v15 setObject:v14 forKeyedSubscript:@"flashWriteCounters"];
                }
              }
            }
            id v7 = [v6 countByEnumeratingWithState:&v31 objects:v36 count:16];
          }
          while (v7);
        }

        id v16 = obj;
        objc_sync_exit(obj);
        id v1 = 0;
      }
    }
    else
    {
      id v17 = objc_alloc((Class)NSError);
      uint64_t v30 = +[NSString stringWithUTF8String:"nfcd"];
      v39[0] = NSLocalizedDescriptionKey;
      id v16 = +[NSString stringWithUTF8String:"Stack Error"];
      v40[0] = v16;
      v40[1] = &off_10031F780;
      v39[1] = @"Line";
      v39[2] = @"Method";
      id v18 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("updateAllWriteCounters")];
      v40[2] = v18;
      v39[3] = NSDebugDescriptionErrorKey;
      id v19 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("updateAllWriteCounters"), 230];
      v40[3] = v19;
      BOOL v20 = +[NSDictionary dictionaryWithObjects:v40 forKeys:v39 count:4];
      id v1 = [v17 initWithDomain:v30 code:15 userInfo:v20];
    }
  }

  return v1;
}

void sub_1002080D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id obj)
{
}

id sub_100208C50(uint64_t a1)
{
  return [*(id *)(a1 + 32) _sync_getFlashWriteCountersForConnection:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];
}

id sub_1002090CC()
{
  self;
  if (qword_100347668 != -1) {
    dispatch_once(&qword_100347668, &stru_100307550);
  }
  uint64_t v0 = (void *)qword_100347660;

  return v0;
}

void sub_100209124(id a1)
{
  uint64_t v1 = objc_opt_new();
  uint64_t v2 = qword_100347660;
  qword_100347660 = v1;

  _objc_release_x1(v1, v2);
}

void sub_1002093BC(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a1)
  {
    v14[0] = @"status";
    uint64_t v8 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:");
    v15[0] = v8;
    v14[1] = @"stackLoadTime";
    uint64_t v9 = +[NSNumber numberWithUnsignedInt:a2];
    v15[1] = v9;
    void v14[2] = @"nfcControllerType";
    double v10 = +[NSNumber numberWithUnsignedInt:a4];
    void v15[2] = v10;
    void v14[3] = @"unlockedSinceBoot";
    os_activity_scope_state_s v11 = +[NSNumber numberWithBool:a5];
    v15[3] = v11;
    int v12 = +[NSDictionary dictionaryWithObjects:v15 forKeys:v14 count:4];

    id v13 = v12;
    AnalyticsSendEventLazy();
  }
}

id sub_100209558(uint64_t a1)
{
  return *(id *)(a1 + 32);
}

id sub_100209560(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a1)
  {
    if (a2 == 3) {
      unsigned int v8 = 2;
    }
    else {
      unsigned int v8 = 1;
    }
    if (a2 == 8) {
      uint64_t v9 = 3;
    }
    else {
      uint64_t v9 = v8;
    }
    v17[0] = @"tagType";
    double v10 = +[NSNumber numberWithUnsignedInt:v9];
    v18[0] = v10;
    v17[1] = @"operation";
    os_activity_scope_state_s v11 = +[NSNumber numberWithUnsignedInt:a3];
    v18[1] = v11;
    v17[2] = @"duration";
    int v12 = +[NSNumber numberWithUnsignedLongLong:a4];
    v18[2] = v12;
    v17[3] = @"status";
    id v13 = +[NSNumber numberWithInteger:a5];
    v18[3] = v13;
    id v14 = +[NSDictionary dictionaryWithObjects:v18 forKeys:v17 count:4];

    id v15 = v14;
    AnalyticsSendEventLazy();
  }
  else
  {
    id v15 = 0;
  }

  return v15;
}

id sub_10020972C(uint64_t a1)
{
  return *(id *)(a1 + 32);
}

id sub_100209734(void *a1, void *a2, void *a3, unsigned int a4)
{
  id v7 = a2;
  id v97 = a3;
  int v99 = v7;
  uint64_t v104 = a1;
  if (a1)
  {
    unsigned int v96 = a4;
    long long v109 = 0u;
    long long v110 = 0u;
    long long v111 = 0u;
    long long v112 = 0u;
    id v8 = [v7 countByEnumeratingWithState:&v109 objects:v118 count:16];
    if (v8)
    {
      id v9 = v8;
      uint64_t v103 = 0;
      uint64_t v10 = 0;
      unsigned int v101 = 0;
      uint64_t v11 = *(void *)v110;
      do
      {
        for (i = 0; i != v9; i = (char *)i + 1)
        {
          if (*(void *)v110 != v11) {
            objc_enumerationMutation(v7);
          }
          id v13 = *(void **)(*((void *)&v109 + 1) + 8 * i);
          if ([v13 type] == 8)
          {
            uint64_t v10 = (v10 + 1);
          }
          else if ([v13 isSilent] && objc_msgSend(v13, "silentType") == 2)
          {
            LODWORD(v103) = v103 + 1;
          }
          else if ([v13 isSilent] && objc_msgSend(v13, "silentType") == 3)
          {
            ++v101;
          }
          else if ([v13 type] == 3)
          {
            ++HIDWORD(v103);
          }
          else
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t Logger = NFLogGetLogger();
            if (Logger)
            {
              id v15 = (void (*)(uint64_t, const char *, ...))Logger;
              Class = object_getClass(v104);
              BOOL isMetaClass = class_isMetaClass(Class);
              ClassName = object_getClassName(v104);
              Name = sel_getName("postCAFuryTagDetectionEvent:previousTags:rfError:");
              uint64_t v18 = 45;
              if (isMetaClass) {
                uint64_t v18 = 43;
              }
              id v7 = v99;
              v15(3, "%c[%{public}s %{public}s]:%i Unknown tag found in new list %{public}@", v18, ClassName, Name, 176, v13);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            id v19 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
            {
              BOOL v20 = object_getClass(v104);
              if (class_isMetaClass(v20)) {
                int v21 = 43;
              }
              else {
                int v21 = 45;
              }
              id v22 = object_getClassName(v104);
              uint64_t v23 = sel_getName("postCAFuryTagDetectionEvent:previousTags:rfError:");
              *(_DWORD *)id buf = 67110146;
              *(_DWORD *)&uint8_t buf[4] = v21;
              id v7 = v99;
              *(_WORD *)id v120 = 2082;
              *(void *)&v120[2] = v22;
              *(_WORD *)&v120[10] = 2082;
              *(void *)&v120[12] = v23;
              *(_WORD *)&v120[20] = 1024;
              *(_DWORD *)&v120[22] = 176;
              *(_WORD *)&v120[26] = 2114;
              *(void *)&v120[28] = v13;
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unknown tag found in new list %{public}@", buf, 0x2Cu);
            }
          }
        }
        id v9 = [v7 countByEnumeratingWithState:&v109 objects:v118 count:16];
      }
      while (v9);
    }
    else
    {
      uint64_t v103 = 0;
      uint64_t v10 = 0;
      unsigned int v101 = 0;
    }
    long long v107 = 0u;
    long long v108 = 0u;
    long long v105 = 0u;
    long long v106 = 0u;
    id v24 = v97;
    id v25 = [v24 countByEnumeratingWithState:&v105 objects:v117 count:16];
    if (v25)
    {
      id v26 = v25;
      uint64_t v27 = 0;
      unsigned int v28 = 0;
      unsigned int v102 = 0;
      unsigned int v100 = 0;
      uint64_t v29 = *(void *)v106;
      id v98 = v24;
      do
      {
        for (j = 0; j != v26; j = (char *)j + 1)
        {
          if (*(void *)v106 != v29) {
            objc_enumerationMutation(v24);
          }
          long long v31 = *(void **)(*((void *)&v105 + 1) + 8 * (void)j);
          if ([v31 type] == 8)
          {
            ++v28;
          }
          else if ([v31 isSilent] && objc_msgSend(v31, "silentType") == 2)
          {
            ++v102;
          }
          else if ([v31 isSilent] && objc_msgSend(v31, "silentType") == 3)
          {
            ++v100;
          }
          else if ([v31 type] == 3)
          {
            uint64_t v27 = (v27 + 1);
          }
          else
          {
            uint64_t v32 = v10;
            uint64_t v33 = v27;
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v34 = NFLogGetLogger();
            if (v34)
            {
              id v35 = (void (*)(uint64_t, const char *, ...))v34;
              __int16 v36 = object_getClass(v104);
              BOOL v37 = class_isMetaClass(v36);
              int v92 = object_getClassName(v104);
              int v94 = sel_getName("postCAFuryTagDetectionEvent:previousTags:rfError:");
              uint64_t v38 = 45;
              if (v37) {
                uint64_t v38 = 43;
              }
              v35(3, "%c[%{public}s %{public}s]:%i Unknown tag found in old list %{public}@", v38, v92, v94, 199, v31);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            id v39 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
            {
              __int16 v40 = object_getClass(v104);
              if (class_isMetaClass(v40)) {
                int v41 = 43;
              }
              else {
                int v41 = 45;
              }
              id v42 = object_getClassName(v104);
              __int16 v43 = sel_getName("postCAFuryTagDetectionEvent:previousTags:rfError:");
              *(_DWORD *)id buf = 67110146;
              *(_DWORD *)&uint8_t buf[4] = v41;
              *(_WORD *)id v120 = 2082;
              *(void *)&v120[2] = v42;
              *(_WORD *)&v120[10] = 2082;
              *(void *)&v120[12] = v43;
              *(_WORD *)&v120[20] = 1024;
              *(_DWORD *)&v120[22] = 199;
              *(_WORD *)&v120[26] = 2114;
              *(void *)&v120[28] = v31;
              _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unknown tag found in old list %{public}@", buf, 0x2Cu);
            }

            uint64_t v27 = v33;
            uint64_t v10 = v32;
            id v24 = v98;
          }
        }
        id v26 = [v24 countByEnumeratingWithState:&v105 objects:v117 count:16];
      }
      while (v26);
    }
    else
    {
      LODWORD(v27) = 0;
      unsigned int v28 = 0;
      unsigned int v102 = 0;
      unsigned int v100 = 0;
    }

    if (v27 == HIDWORD(v103))
    {
      int v44 = v103;
      if (v28 == v10)
      {
        unsigned int v45 = v101;
        unsigned int v46 = v101 - v100;
        unsigned int v47 = v100 - v101;
        if (v100 > v101) {
          unsigned int v46 = 0;
        }
        else {
          unsigned int v47 = 0;
        }
        if (v100 > v101) {
          unsigned int v48 = 2;
        }
        else {
          unsigned int v48 = 1;
        }
        if (v100 == v101)
        {
          unsigned int v47 = 0;
          unsigned int v46 = 0;
          unsigned int v48 = 0;
          unsigned int v49 = 1;
        }
        else
        {
          unsigned int v49 = 5;
        }
        unsigned int v50 = v103 - v102;
        unsigned int v51 = v102 - v103;
        if (v102 > v103) {
          unsigned int v50 = 0;
        }
        else {
          unsigned int v51 = 0;
        }
        if (v102 > v103) {
          unsigned int v52 = 2;
        }
        else {
          unsigned int v52 = 1;
        }
        if (v102 == v103) {
          uint64_t v53 = v47;
        }
        else {
          uint64_t v53 = v51;
        }
        if (v102 == v103) {
          uint64_t v54 = v46;
        }
        else {
          uint64_t v54 = v50;
        }
        if (v102 == v103) {
          uint64_t v55 = v48;
        }
        else {
          uint64_t v55 = v52;
        }
        if (v102 == v103) {
          uint64_t v56 = v49;
        }
        else {
          uint64_t v56 = 4;
        }
        if (v10) {
          goto LABEL_116;
        }
        goto LABEL_112;
      }
      if (v28 > v10) {
        uint64_t v53 = v28 - v10;
      }
      else {
        uint64_t v53 = 0;
      }
      if (v28 > v10) {
        uint64_t v54 = 0;
      }
      else {
        uint64_t v54 = v10 - v28;
      }
      if (v28 > v10) {
        uint64_t v55 = 2;
      }
      else {
        uint64_t v55 = 1;
      }
      uint64_t v56 = 3;
    }
    else
    {
      if (v27 > HIDWORD(v103)) {
        uint64_t v53 = (v27 - HIDWORD(v103));
      }
      else {
        uint64_t v53 = 0;
      }
      if (v27 > HIDWORD(v103)) {
        uint64_t v54 = 0;
      }
      else {
        uint64_t v54 = (HIDWORD(v103) - v27);
      }
      if (v27 > HIDWORD(v103)) {
        uint64_t v55 = 2;
      }
      else {
        uint64_t v55 = 1;
      }
      uint64_t v56 = 2;
      int v44 = v103;
    }
    unsigned int v45 = v101;
    if (v10) {
      goto LABEL_116;
    }
LABEL_112:
    if (!HIDWORD(v103) && !v44 && !v45)
    {
      uint64_t v57 = 1;
      goto LABEL_180;
    }
LABEL_116:
    if (v10 != 1 || HIDWORD(v103) || v44 || v45)
    {
      if (v10 || HIDWORD(v103) != 1 || v44 || v45)
      {
        if (v10 != 1 || HIDWORD(v103) != 1 || v44 || v45)
        {
          if (v10 || HIDWORD(v103) != 2 || v44 || v45)
          {
            BOOL v58 = v10 == 0;
            BOOL v59 = v44 == 1 && v45 == 0;
            char v60 = v59;
            if (!v59) {
              BOOL v58 = 0;
            }
            if (!v58 || HIDWORD(v103))
            {
              if (v45 != 1 || v44 | v10 || HIDWORD(v103))
              {
                if (HIDWORD(v103) != 1) {
                  LOBYTE(v58) = 0;
                }
                if (v58)
                {
                  uint64_t v57 = 8;
                }
                else
                {
                  char v61 = v60 ^ 1;
                  if (v10 != 1) {
                    char v61 = 1;
                  }
                  if ((v61 & 1) != 0 || HIDWORD(v103))
                  {
                    if (v10 || v44 != 1 || v45 != 1 || HIDWORD(v103))
                    {
                      if (v44) {
                        BOOL v62 = 0;
                      }
                      else {
                        BOOL v62 = v45 == 1;
                      }
                      int v63 = v62;
                      if (!v10 && v63 && HIDWORD(v103) == 1)
                      {
                        uint64_t v57 = 11;
                      }
                      else
                      {
                        char v64 = v63 ^ 1;
                        if (v10 != 1) {
                          char v64 = 1;
                        }
                        if ((v64 & 1) != 0 || HIDWORD(v103))
                        {
                          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                          uint64_t v80 = NFLogGetLogger();
                          uint64_t v65 = v96;
                          if (v80)
                          {
                            int v81 = (void (*)(uint64_t, const char *, ...))v80;
                            int v82 = object_getClass(v104);
                            BOOL v83 = class_isMetaClass(v82);
                            __int16 v84 = object_getClassName(v104);
                            id v95 = sel_getName("postCAFuryTagDetectionEvent:previousTags:rfError:");
                            uint64_t v85 = 45;
                            if (v83) {
                              uint64_t v85 = 43;
                            }
                            v81(3, "%c[%{public}s %{public}s]:%i multiTag : Invalid tag configuration", v85, v84, v95, 313);
                          }
                          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                          uint64_t v86 = NFSharedLogGetLogger();
                          if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
                          {
                            __int16 v87 = object_getClass(v104);
                            if (class_isMetaClass(v87)) {
                              int v88 = 43;
                            }
                            else {
                              int v88 = 45;
                            }
                            __int16 v89 = object_getClassName(v104);
                            __int16 v90 = sel_getName("postCAFuryTagDetectionEvent:previousTags:rfError:");
                            *(_DWORD *)id buf = 67109890;
                            *(_DWORD *)&uint8_t buf[4] = v88;
                            *(_WORD *)id v120 = 2082;
                            *(void *)&v120[2] = v89;
                            *(_WORD *)&v120[10] = 2082;
                            *(void *)&v120[12] = v90;
                            *(_WORD *)&v120[20] = 1024;
                            *(_DWORD *)&v120[22] = 313;
                            _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i multiTag : Invalid tag configuration", buf, 0x22u);
                          }

                          uint64_t v57 = 13;
                          goto LABEL_181;
                        }
                        uint64_t v57 = 12;
                      }
                    }
                    else
                    {
                      uint64_t v57 = 10;
                    }
                  }
                  else
                  {
                    uint64_t v57 = 9;
                  }
                }
              }
              else
              {
                uint64_t v57 = 7;
              }
            }
            else
            {
              uint64_t v57 = 6;
            }
          }
          else
          {
            uint64_t v57 = 5;
          }
        }
        else
        {
          uint64_t v57 = 4;
        }
      }
      else
      {
        uint64_t v57 = 2;
      }
    }
    else
    {
      uint64_t v57 = 3;
    }
LABEL_180:
    uint64_t v65 = v96;
LABEL_181:
    v115[0] = @"tagType";
    NSErrorUserInfoKey v66 = +[NSNumber numberWithUnsignedInt:v56];
    v116[0] = v66;
    v115[1] = @"operation";
    int v67 = +[NSNumber numberWithUnsignedInt:v55];
    v116[1] = v67;
    v115[2] = @"multiTagState";
    NSErrorUserInfoKey v68 = +[NSNumber numberWithUnsignedInt:v57];
    v116[2] = v68;
    v115[3] = @"rfErrorOccured";
    id v69 = +[NSNumber numberWithBool:v65];
    v116[3] = v69;
    __int16 v70 = +[NSDictionary dictionaryWithObjects:v116 forKeys:v115 count:4];

    v113[0] = @"NFMultiTagState";
    int v71 = +[NSNumber numberWithUnsignedInt:v57];
    v114[0] = v71;
    v113[1] = @"totalDailyTagsAdded";
    __int16 v72 = +[NSNumber numberWithInt:v54];
    v114[1] = v72;
    v113[2] = @"totalDailyTagsRemoved";
    int v73 = +[NSNumber numberWithInt:v53];
    v114[2] = v73;
    __int16 v74 = +[NSDictionary dictionaryWithObjects:v114 forKeys:v113 count:3];

    id v75 = v74;
    __int16 v76 = v104[2];
    *(void *)id buf = _NSConcreteStackBlock;
    *(void *)id v120 = 3221225472;
    *(void *)&v120[8] = sub_10020A7A4;
    *(void *)&v120[16] = &unk_1003018E8;
    *(void *)&v120[24] = v104;
    id v77 = v75;
    *(void *)&v120[32] = v77;
    char v121 = 0;
    dispatch_async(v76, buf);

    id v78 = v70;
    AnalyticsSendEventLazy();

    goto LABEL_182;
  }
  id v78 = 0;
LABEL_182:

  return v78;
}

id sub_10020A2E0(uint64_t a1)
{
  return *(id *)(a1 + 32);
}

void sub_10020A2E8(uint64_t a1, void *a2)
{
  id v3 = a2;
  SEL v4 = v3;
  if (a1)
  {
    SEL v5 = *(NSObject **)(a1 + 16);
    v6[0] = _NSConcreteStackBlock;
    v6[1] = 3221225472;
    v6[2] = sub_10020A390;
    v6[3] = &unk_100301CB8;
    v6[4] = a1;
    id v7 = v3;
    dispatch_async(v5, v6);
  }
}

void sub_10020A390(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    uint64_t v2 = *(void **)(a1 + 40);
    CFStringRef v7 = @"totalDailyFalseDetectionCount";
    id v8 = v2;
    id v3 = v2;
    SEL v4 = +[NSDictionary dictionaryWithObjects:&v8 forKeys:&v7 count:1];
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    v5[2] = sub_10020A694;
    v5[3] = &unk_1003075A0;
    char v6 = 0;
    v5[4] = v1;
    [v4 enumerateKeysAndObjectsUsingBlock:v5];
  }
}

void sub_10020A48C(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = *(NSObject **)(a1 + 16);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_10020A508;
    block[3] = &unk_100301C68;
    void block[4] = a1;
    dispatch_async(v1, block);
  }
}

void sub_10020A508(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    uint64_t v2 = [*(id *)(v1 + 8) objectForKey:@"totalDailyTagsAdded"];
    id v3 = [*(id *)(v1 + 8) objectForKey:@"totalDailyTagsRemoved"];
    uint64_t v4 = [*(id *)(v1 + 8) objectForKey:@"totalDailyFalseDetectionCount"];
    SEL v5 = (void *)v4;
    char v6 = &off_10031F810;
    if (v2) {
      CFStringRef v7 = v2;
    }
    else {
      CFStringRef v7 = &off_10031F810;
    }
    v12[0] = @"totalDailyTagsAdded";
    v12[1] = @"totalDailyTagsRemoved";
    if (v3) {
      id v8 = v3;
    }
    else {
      id v8 = &off_10031F810;
    }
    v13[0] = v7;
    v13[1] = v8;
    void v12[2] = @"totalDailyFalseDetectionCount";
    if (v4) {
      char v6 = (_UNKNOWN **)v4;
    }
    void v13[2] = v6;
    id v9 = +[NSDictionary dictionaryWithObjects:v13 forKeys:v12 count:3];
    v10[0] = _NSConcreteStackBlock;
    v10[1] = 3221225472;
    void v10[2] = sub_10020A694;
    v10[3] = &unk_1003075A0;
    char v11 = 1;
    v10[4] = v1;
    [v9 enumerateKeysAndObjectsUsingBlock:v10];
    AnalyticsSendEvent();
  }
}

void sub_10020A694(uint64_t a1, void *a2, void *a3)
{
  id v10 = a2;
  id v5 = a3;
  char v6 = *(void **)(*(void *)(a1 + 32) + 8);
  if (*(unsigned char *)(a1 + 40))
  {
    [v6 setObject:&off_10031F810 forKey:v10];
  }
  else
  {
    CFStringRef v7 = [v6 objectForKey:v10];
    if (v7)
    {
      if ([v5 integerValue])
      {
        id v8 = *(void **)(*(void *)(a1 + 32) + 8);
        id v9 = [NSNumber numberWithLong:][v7 longValue] + [v5 longValue];
        [v8 setObject:v9 forKey:v10];
      }
    }
    else
    {
      [*(id *)(*(void *)(a1 + 32) + 8) setObject:v5 forKey:v10];
    }
  }
}

void *sub_10020A7A4(void *result)
{
  uint64_t v1 = result[4];
  if (v1)
  {
    uint64_t v2 = (void *)result[5];
    char v3 = *((unsigned char *)result + 48);
    v4[0] = _NSConcreteStackBlock;
    v4[1] = 3221225472;
    v4[2] = sub_10020A694;
    v4[3] = &unk_1003075A0;
    char v5 = v3;
    v4[4] = v1;
    return [v2 enumerateKeysAndObjectsUsingBlock:v4];
  }
  return result;
}

void sub_10020A828(uint64_t a1, void *a2)
{
  if (a1)
  {
    char v5 = a2;
    char v6 = &off_10031F828;
    id v2 = a2;
    char v3 = +[NSDictionary dictionaryWithObjects:&v6 forKeys:&v5 count:1];
    uint64_t v4 = +[NFCALogger sharedCALogger];

    [v4 postCAEventFor:@"com.apple.fury.exceptionStatisticsEvent" eventInput:v3];
  }
}

id sub_10020A934()
{
  self;
  if (qword_100347678 != -1) {
    dispatch_once(&qword_100347678, &stru_1003075C0);
  }
  uint64_t v0 = (void *)qword_100347670;

  return v0;
}

void sub_10020A98C(id a1)
{
  uint64_t v1 = objc_alloc_init(_NFFailForwardCoordinator);
  uint64_t v2 = qword_100347670;
  qword_100347670 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_10020A9C8(void *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      char v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("registerPrimaryDelegate:");
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v5(6, "%c[%{public}s %{public}s]:%i ", v9, ClassName, Name, 34);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      char v11 = object_getClass(a1);
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      *(_DWORD *)id buf = 67109890;
      int v29 = v12;
      __int16 v30 = 2082;
      long long v31 = object_getClassName(a1);
      __int16 v32 = 2082;
      uint64_t v33 = sel_getName("registerPrimaryDelegate:");
      __int16 v34 = 1024;
      int v35 = 34;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
    }

    id v13 = a1;
    objc_sync_enter(v13);
    objc_storeWeak(v13 + 1, v3);
    id WeakRetained = objc_loadWeakRetained(v13 + 2);
    objc_sync_exit(v13);

    if (WeakRetained)
    {
      [WeakRetained primaryDelegateRegistered:v3];
      [v3 furyDelegateRegistered:WeakRetained];
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v15 = NFLogGetLogger();
      if (v15)
      {
        id v16 = (void (*)(uint64_t, const char *, ...))v15;
        id v17 = object_getClass(v13);
        BOOL v18 = class_isMetaClass(v17);
        id v19 = object_getClassName(v13);
        BOOL v20 = sel_getName("registerPrimaryDelegate:");
        uint64_t v21 = 45;
        if (v18) {
          uint64_t v21 = 43;
        }
        v16(6, "%c[%{public}s %{public}s]:%i Fury delegate not present yet", v21, v19, v20, 45);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v22 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v23 = object_getClass(v13);
        if (class_isMetaClass(v23)) {
          int v24 = 43;
        }
        else {
          int v24 = 45;
        }
        id v25 = object_getClassName(v13);
        id v26 = sel_getName("registerPrimaryDelegate:");
        *(_DWORD *)id buf = 67109890;
        int v29 = v24;
        __int16 v30 = 2082;
        long long v31 = v25;
        __int16 v32 = 2082;
        uint64_t v33 = v26;
        __int16 v34 = 1024;
        int v35 = 45;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Fury delegate not present yet", buf, 0x22u);
      }
    }
  }
}

void sub_10020ACC0(void *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      char v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("registerFuryDelegate:");
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v5(6, "%c[%{public}s %{public}s]:%i ", v9, ClassName, Name, 53);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      char v11 = object_getClass(a1);
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      *(_DWORD *)id buf = 67109890;
      int v29 = v12;
      __int16 v30 = 2082;
      long long v31 = object_getClassName(a1);
      __int16 v32 = 2082;
      uint64_t v33 = sel_getName("registerFuryDelegate:");
      __int16 v34 = 1024;
      int v35 = 53;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
    }

    id v13 = a1;
    objc_sync_enter(v13);
    objc_storeWeak(v13 + 2, v3);
    id WeakRetained = objc_loadWeakRetained(v13 + 1);
    objc_sync_exit(v13);

    if (WeakRetained)
    {
      [WeakRetained furyDelegateRegistered:v3];
      [v3 primaryDelegateRegistered:WeakRetained];
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v15 = NFLogGetLogger();
      if (v15)
      {
        id v16 = (void (*)(uint64_t, const char *, ...))v15;
        id v17 = object_getClass(v13);
        BOOL v18 = class_isMetaClass(v17);
        id v19 = object_getClassName(v13);
        uint64_t v27 = sel_getName("registerFuryDelegate:");
        uint64_t v20 = 45;
        if (v18) {
          uint64_t v20 = 43;
        }
        v16(6, "%c[%{public}s %{public}s]:%i Primary delegate not present yet", v20, v19, v27, 63);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v21 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        id v22 = object_getClass(v13);
        if (class_isMetaClass(v22)) {
          int v23 = 43;
        }
        else {
          int v23 = 45;
        }
        int v24 = object_getClassName(v13);
        id v25 = sel_getName("registerFuryDelegate:");
        *(_DWORD *)id buf = 67109890;
        int v29 = v23;
        __int16 v30 = 2082;
        long long v31 = v24;
        __int16 v32 = 2082;
        uint64_t v33 = v25;
        __int16 v34 = 1024;
        int v35 = 63;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Primary delegate not present yet", buf, 0x22u);
      }
    }
  }
}

uint64_t sub_10020B708(void *a1)
{
  id v7 = 0;
  unsigned int v1 = sub_10020CA8C(a1, &v7);
  id v2 = v7;
  if (v2)
  {
LABEL_9:
    uint64_t v3 = 0;
    goto LABEL_10;
  }
  if (v1 != 36864)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (Logger) {
      Logger(4, "%s:%i SW1SW2 error=0x%x", "_IsRAPDUSuccess", 59, v1);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    char v5 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)id buf = 136446722;
      uint64_t v9 = "_IsRAPDUSuccess";
      __int16 v10 = 1024;
      int v11 = 59;
      __int16 v12 = 1024;
      unsigned int v13 = v1;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "%{public}s:%i SW1SW2 error=0x%x", buf, 0x18u);
    }

    goto LABEL_9;
  }
  uint64_t v3 = 1;
LABEL_10:

  return v3;
}

void *sub_10020CA8C(void *a1, void *a2)
{
  id v3 = a1;
  if ((unint64_t)[v3 length] > 1)
  {
    id v10 = v3;
    a2 = (void *)(bswap32(*(unsigned __int16 *)((char *)[v10 bytes]
                                                + (void)[v10 length]
                                                - 2)) >> 16);
  }
  else
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (Logger) {
      Logger(4, "%s:%i Invalid tag response", "_ParseSWFromRAPDUEX", 42);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    char v5 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)id buf = 136446466;
      uint64_t v15 = "_ParseSWFromRAPDUEX";
      __int16 v16 = 1024;
      int v17 = 42;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "%{public}s:%i Invalid tag response", buf, 0x12u);
    }

    if (a2)
    {
      id v6 = objc_alloc((Class)NSError);
      id v7 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
      id v8 = +[NSString stringWithUTF8String:"Tag Error"];
      unsigned int v13 = v8;
      uint64_t v9 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      *a2 = [v6 initWithDomain:v7 code:29 userInfo:v9];

      a2 = 0;
    }
  }

  return a2;
}

id sub_10020D9A0(void *a1)
{
  uint64_t v2 = a1[4];
  uint64_t v1 = a1[5];
  id v3 = *(void **)(v2 + 371);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  v6[2] = sub_10020DA24;
  v6[3] = &unk_100301BF0;
  uint64_t v4 = a1[6];
  v6[4] = v2;
  void v6[5] = v4;
  return [v3 hceReadWithHandle:v1 completion:v6];
}

void sub_10020DA24(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v5)
  {
    id v7 = [*(id *)(a1 + 32) expressModeManager];
    if (v7)
    {
      int v8 = v7[172];

      uint64_t v9 = *(void **)(a1 + 32);
      if (v8)
      {
        id v10 = [v9 expressModeManager];
        [v10 handleTransactionEndEvent:v5 atlData:v6 caData:0];

        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v9 = *(void **)(a1 + 32);
    }
    [v9 handleTransactionEndEvent:v5 atlData:v6];
    goto LABEL_17;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    NSErrorUserInfoKey v12 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v16 = 45;
    if (isMetaClass) {
      uint64_t v16 = 43;
    }
    v12(3, "%c[%{public}s %{public}s]:%i Invalid decoded event for posting EndEvent.", v16, ClassName, Name, 91);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v17 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
  {
    BOOL v18 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v18)) {
      int v19 = 43;
    }
    else {
      int v19 = 45;
    }
    uint64_t v20 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v21 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)id buf = 67109890;
    int v31 = v19;
    __int16 v32 = 2082;
    uint64_t v33 = v20;
    __int16 v34 = 2082;
    int v35 = v21;
    __int16 v36 = 1024;
    int v37 = 91;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid decoded event for posting EndEvent.", buf, 0x22u);
  }

LABEL_17:
  id v22 = [v6 objectForKeyedSubscript:@"endPointIdentifier"];
  if (v22)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      unsigned int v23 = [v5 didError];
      CFStringRef v24 = @"noError";
      if (v23) {
        CFStringRef v24 = @"withError";
      }
      id v25 = +[NSString stringWithFormat:@"%@/%@", v22, v24];
      id v26 = +[_NFHardwareManager sharedHardwareManager];
      uint64_t v27 = +[NFSecureXPCEventPublisherManager sharedManager];
      unsigned int v28 = [v27 homed];
      [v26 postEventForPublisher:v28 event:"com.apple.stockholm.forHome.transaction.end" objectString:v25];
    }
  }
}

id *sub_10020E878(id *a1, void *a2)
{
  id v4 = a2;
  if (a1)
  {
    v27.receiver = a1;
    v27.super_class = (Class)NFDriverWrapper;
    id v5 = (id)[super init];
    a1 = v5;
    if (v5)
    {
      v5[18] = 0;
      v5[19] = 0;
      id v6 = objc_alloc_init((Class)NSMutableDictionary);
      id v7 = a1[7];
      a1[7] = v6;

      *((unsigned char *)a1 + 220) = 0;
      int v8 = objc_alloc_init(NFCoreTelephonyConnection);
      id v9 = a1[21];
      a1[21] = v8;

      id v10 = objc_alloc_init((Class)NSLock);
      id v11 = a1[13];
      a1[13] = v10;

      *((unsigned char *)a1 + 223) = 0;
      objc_initWeak(&location, a1);
      id v12 = objc_alloc((Class)NFTimer);
      v24[0] = _NSConcreteStackBlock;
      v24[1] = 3221225472;
      v24[2] = sub_10020EAF4;
      v24[3] = &unk_100301C18;
      objc_copyWeak(&v25, &location);
      id v13 = [v12 initWithCallback:v24 queue:v4];
      id v14 = a1[14];
      a1[14] = v13;

      id v15 = objc_alloc((Class)NFTimer);
      v22[0] = _NSConcreteStackBlock;
      v22[1] = 3221225472;
      v22[2] = sub_100003AF4;
      v22[3] = &unk_100301C18;
      objc_copyWeak(&v23, &location);
      id v16 = [v15 initWithCallback:v22 queue:v4];
      id v17 = a1[15];
      a1[15] = v16;

      objc_storeStrong(a1 + 26, a2);
      *((unsigned char *)a1 + 219) = NFProductIsPhone() ^ 1;
      *((unsigned char *)a1 + 218) = NFProductHasNFCRadio();
      uint64_t v18 = objc_opt_new();
      id v19 = a1[23];
      a1[23] = (id)v18;

      *((_DWORD *)a1 + 2) = 0;
      a1[2] = 0;
      *((unsigned char *)a1 + 24) = 0;
      *((_DWORD *)a1 + 7) = -1;
      id v20 = a1[4];
      a1[4] = 0;

      *((_DWORD *)a1 + 48) = 0;
      objc_destroyWeak(&v23);
      objc_destroyWeak(&v25);
      objc_destroyWeak(&location);
    }
  }

  return a1;
}

void sub_10020EAB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  objc_destroyWeak(v21);
  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10020EAF4(uint64_t a1)
{
  uint64_t v2 = _os_activity_create((void *)&_mh_execute_header, "com.apple.nfcd.field.assertionTimer", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  *(void *)os_activity_scope_state_s state = 0;
  *(void *)&state[8] = 0;
  os_activity_scope_enter(v2, (os_activity_scope_state_t)state);
  os_activity_scope_leave((os_activity_scope_state_t)state);

  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
  if (Logger) {
    Logger(6, "%s:%i Field assertion timeout.", "-[NFDriverWrapper initWithQueue:]_block_invoke", 185);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v4 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)os_activity_scope_state_s state = 136446466;
    *(void *)&state[4] = "-[NFDriverWrapper initWithQueue:]_block_invoke";
    *(_WORD *)&state[12] = 1024;
    *(_DWORD *)&state[14] = 185;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s:%i Field assertion timeout.", state, 0x12u);
  }

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  sub_100001FF4((uint64_t)WeakRetained);
}

id *sub_10020EC44(id *a1)
{
  if (a1)
  {
    if (a1[5] && !*((unsigned char *)a1 + 137)) {
      a1 = (id *)a1[25];
    }
    else {
      a1 = 0;
    }
    uint64_t v1 = vars8;
  }
  return a1;
}

id sub_10020EC8C(void *a1, void *a2, unint64_t a3)
{
  id v5 = a2;
  if (a1)
  {
    id v6 = a1;
    objc_sync_enter(v6);
    if (*((_DWORD *)v6 + 25))
    {
      id v7 = 0;
    }
    else
    {
      __int16 v30 = sub_10020F914((uint64_t)v6);
      id v7 = v30;
      if (v30)
      {
        if ([v30 code] == (id)58 && NFProductIsDevBoard())
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (Logger)
          {
            Class = object_getClass(v6);
            if (class_isMetaClass(Class)) {
              uint64_t v33 = 43;
            }
            else {
              uint64_t v33 = 45;
            }
            ClassName = object_getClassName(v6);
            Name = sel_getName("openSession:forType:");
            Logger(3, "%c[%{public}s %{public}s]:%i Hardware unavailable; please verify all hardware connections and power cycle system to retry",
              v33,
              ClassName,
              Name,
              243);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          __int16 v36 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
          {
            int v37 = object_getClass(v6);
            if (class_isMetaClass(v37)) {
              int v38 = 43;
            }
            else {
              int v38 = 45;
            }
            *(_DWORD *)id buf = 67109890;
            int v79 = v38;
            __int16 v80 = 2082;
            int v81 = object_getClassName(v6);
            __int16 v82 = 2082;
            BOOL v83 = sel_getName("openSession:forType:");
            __int16 v84 = 1024;
            int v85 = 243;
            _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Hardware unavailable; please verify all hardware connections and power cycle system to retry",
              buf,
              0x22u);
          }

          v6[37] = (id)3;
          id v39 = objc_alloc((Class)NSError);
          __int16 v40 = +[NSString stringWithUTF8String:"nfcd"];
          v90[0] = NSLocalizedDescriptionKey;
          int v41 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
          v91[0] = v41;
          v91[1] = &off_10031F8B8;
          v90[1] = @"Line";
          v90[2] = @"Method";
          id v42 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("openSession:forType:")];
          v91[2] = v42;
          v90[3] = NSDebugDescriptionErrorKey;
          id v43 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("openSession:forType:"), 245];
          v91[3] = v43;
          int v44 = +[NSDictionary dictionaryWithObjects:v91 forKeys:v90 count:4];
          id v45 = [v39 initWithDomain:v40 code:58 userInfo:v44];

          goto LABEL_63;
        }
        int v8 = 0;
LABEL_5:
        id v9 = v6[37];
        if (v9 == (id)1 || v9 == (id)4 && (a3 & 0xFFFFFFFFFFFFFFFDLL) == 0)
        {
          if ([v7 code] == (id)56)
          {

            id v7 = 0;
          }
          int v16 = *((_DWORD *)v6 + 25);
          if (!v16)
          {
            *((unsigned char *)v6 + 137) = 0;
            sub_1002112A8((uint64_t)v6);
            int v16 = *((_DWORD *)v6 + 25);
          }
          *((_DWORD *)v6 + 25) = v16 + 1;
          id v17 = [v6[23] objectForKey:v5];

          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          if (!v17)
          {
            unsigned int v49 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
            if (v49)
            {
              unsigned int v50 = object_getClass(v6);
              if (class_isMetaClass(v50)) {
                uint64_t v51 = 43;
              }
              else {
                uint64_t v51 = 45;
              }
              unsigned int v52 = object_getClassName(v6);
              uint64_t v53 = sel_getName("openSession:forType:");
              v49(6, "%c[%{public}s %{public}s]:%i Opening session on behalf of %@ with type %lu", v51, v52, v53, 272, v5, a3);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v54 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v55 = object_getClass(v6);
              if (class_isMetaClass(v55)) {
                int v56 = 43;
              }
              else {
                int v56 = 45;
              }
              *(_DWORD *)id buf = 67110402;
              int v79 = v56;
              __int16 v80 = 2082;
              int v81 = object_getClassName(v6);
              __int16 v82 = 2082;
              BOOL v83 = sel_getName("openSession:forType:");
              __int16 v84 = 1024;
              int v85 = 272;
              __int16 v86 = 2112;
              __int16 v87 = v5;
              __int16 v88 = 2048;
              unint64_t v89 = a3;
              _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Opening session on behalf of %@ with type %lu", buf, 0x36u);
            }

            id v11 = +[NSNumber numberWithInt:1];
            [v6[23] setObject:v11 forKeyedSubscript:v5];
            goto LABEL_62;
          }
          uint64_t v18 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v18)
          {
            id v19 = object_getClass(v6);
            if (class_isMetaClass(v19)) {
              uint64_t v20 = 43;
            }
            else {
              uint64_t v20 = 45;
            }
            uint64_t v21 = object_getClassName(v6);
            id v22 = sel_getName("openSession:forType:");
            id v23 = [v6[23] objectForKeyedSubscript:v5];
            v18(3, "%c[%{public}s %{public}s]:%i Owner %@ already has a session : %@", v20, v21, v22, 268, v5, v23);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          CFStringRef v24 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            id v25 = object_getClass(v6);
            if (class_isMetaClass(v25)) {
              int v26 = 43;
            }
            else {
              int v26 = 45;
            }
            objc_super v27 = object_getClassName(v6);
            unsigned int v28 = sel_getName("openSession:forType:");
            int v29 = [v6[23] objectForKeyedSubscript:v5];
            *(_DWORD *)id buf = 67110402;
            int v79 = v26;
            __int16 v80 = 2082;
            int v81 = v27;
            __int16 v82 = 2082;
            BOOL v83 = v28;
            __int16 v84 = 1024;
            int v85 = 268;
            __int16 v86 = 2112;
            __int16 v87 = v5;
            __int16 v88 = 2112;
            unint64_t v89 = (unint64_t)v29;
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Owner %@ already has a session : %@", buf, 0x36u);
          }
          id v11 = [v6[23] objectForKeyedSubscript:v5];
          id v12 = +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", [v11 intValue] + 1);
          [v6[23] setObject:v12 forKeyedSubscript:v5];
LABEL_61:

LABEL_62:
          id v7 = v7;
          id v45 = v7;
LABEL_63:

          objc_sync_exit(v6);
          goto LABEL_64;
        }
        if (*((_DWORD *)v6 + 25))
        {
          if (v8)
          {
            id v10 = objc_alloc((Class)NSError);
            id v11 = +[NSString stringWithUTF8String:"nfcd"];
            v74[0] = NSLocalizedDescriptionKey;
            id v12 = +[NSString stringWithUTF8String:"NFCC is in Download mode. NCI not available."];
            v75[0] = v12;
            v75[1] = &off_10031F8E8;
            v74[1] = @"Line";
            v74[2] = @"Method";
            id v13 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("openSession:forType:")];
            v75[2] = v13;
            v74[3] = NSDebugDescriptionErrorKey;
            id v14 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("openSession:forType:"), 294];
            v75[3] = v14;
            id v15 = +[NSDictionary dictionaryWithObjects:v75 forKeys:v74 count:4];
            id v7 = [v10 initWithDomain:v11 code:56 userInfo:v15];
LABEL_60:

            goto LABEL_61;
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          BOOL v59 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v59)
          {
            NSErrorUserInfoKey v66 = object_getClass(v6);
            if (class_isMetaClass(v66)) {
              uint64_t v67 = 43;
            }
            else {
              uint64_t v67 = 45;
            }
            NSErrorUserInfoKey v68 = object_getClassName(v6);
            id v69 = sel_getName("openSession:forType:");
            v59(3, "%c[%{public}s %{public}s]:%i FAILED: %s", v67, v68, v69, 293, "error == ((void *)0)");
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          char v60 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
          {
            char v61 = object_getClass(v6);
            if (class_isMetaClass(v61)) {
              int v62 = 43;
            }
            else {
              int v62 = 45;
            }
            *(_DWORD *)id buf = 67110146;
            int v79 = v62;
            __int16 v80 = 2082;
            int v81 = object_getClassName(v6);
            __int16 v82 = 2082;
            BOOL v83 = sel_getName("openSession:forType:");
            __int16 v84 = 1024;
            int v85 = 293;
            __int16 v86 = 2080;
            __int16 v87 = "error == ((void *)0)";
LABEL_80:
            _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i FAILED: %s", buf, 0x2Cu);
          }
        }
        else
        {
          if (!v8)
          {
            *((unsigned char *)v6 + 137) = 1;
            if (v9 == (id)4)
            {
              NFDriverUnloadStackAndLeaveHWEnabled();
              NFDriverClose();
              void v6[5] = 0;
            }
            id v46 = objc_alloc((Class)NSError);
            id v11 = +[NSString stringWithUTF8String:"nfcd"];
            id v47 = [v7 code];
            v76[0] = NSLocalizedDescriptionKey;
            if ((uint64_t)[v7 code] > 70) {
              uint64_t v48 = 71;
            }
            else {
              uint64_t v48 = (uint64_t)[v7 code];
            }
            id v12 = +[NSString stringWithUTF8String:(&off_100307820)[v48]];
            v77[0] = v12;
            v77[1] = v7;
            v76[1] = NSUnderlyingErrorKey;
            v76[2] = @"Line";
            v77[2] = &off_10031F8D0;
            v76[3] = @"Method";
            id v13 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("openSession:forType:")];
            v77[3] = v13;
            v76[4] = NSDebugDescriptionErrorKey;
            id v14 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("openSession:forType:"), 290];
            v77[4] = v14;
            id v15 = +[NSDictionary dictionaryWithObjects:v77 forKeys:v76 count:5];
            id v57 = [v46 initWithDomain:v11 code:v47 userInfo:v15];

            id v7 = v57;
            goto LABEL_60;
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          int v63 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v63)
          {
            __int16 v70 = object_getClass(v6);
            if (class_isMetaClass(v70)) {
              uint64_t v71 = 43;
            }
            else {
              uint64_t v71 = 45;
            }
            __int16 v72 = object_getClassName(v6);
            int v73 = sel_getName("openSession:forType:");
            v63(3, "%c[%{public}s %{public}s]:%i FAILED: %s", v71, v72, v73, 280, "error != ((void *)0)");
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          char v60 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
          {
            char v64 = object_getClass(v6);
            if (class_isMetaClass(v64)) {
              int v65 = 43;
            }
            else {
              int v65 = 45;
            }
            *(_DWORD *)id buf = 67110146;
            int v79 = v65;
            __int16 v80 = 2082;
            int v81 = object_getClassName(v6);
            __int16 v82 = 2082;
            BOOL v83 = sel_getName("openSession:forType:");
            __int16 v84 = 1024;
            int v85 = 280;
            __int16 v86 = 2080;
            __int16 v87 = "error != ((void *)0)";
            goto LABEL_80;
          }
        }

        abort();
      }
    }
    int v8 = 1;
    goto LABEL_5;
  }
  id v45 = 0;
LABEL_64:

  return v45;
}

void sub_10020F8B8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_10020F914(uint64_t a1)
{
  if (!a1)
  {
LABEL_43:
    id v20 = 0;
    goto LABEL_111;
  }
  uint64_t v2 = *(void *)(a1 + 40);
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  id v4 = (void (*)(uint64_t, const char *, ...))Logger;
  if (v2)
  {
    if (Logger)
    {
      Class = object_getClass((id)a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName((id)a1);
      Name = sel_getName("_openDriver");
      uint64_t v8 = 45;
      if (isMetaClass) {
        uint64_t v8 = 43;
      }
      v4(3, "%c[%{public}s %{public}s]:%i Stack already opened !", v8, ClassName, Name, 1744);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      id v10 = object_getClass((id)a1);
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      id v12 = object_getClassName((id)a1);
      id v13 = sel_getName("_openDriver");
      *(_DWORD *)id buf = 67109890;
      *(_DWORD *)&uint8_t buf[4] = v11;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = v12;
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = v13;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 1744;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Stack already opened !", buf, 0x22u);
    }

    if (*(unsigned char *)(a1 + 223))
    {
      id v14 = objc_alloc((Class)NSError);
      id v15 = +[NSString stringWithUTF8String:"nfcd"];
      v121[0] = NSLocalizedDescriptionKey;
      int v16 = +[NSString stringWithUTF8String:"NFCC is in Download mode. NCI not available."];
      v122[0] = v16;
      v122[1] = &off_10031FA68;
      v121[1] = @"Line";
      v121[2] = @"Method";
      id v17 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_openDriver")];
      v122[2] = v17;
      v121[3] = NSDebugDescriptionErrorKey;
      id v18 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_openDriver"), 1746];
      v122[3] = v18;
      id v19 = +[NSDictionary dictionaryWithObjects:v122 forKeys:v121 count:4];
      id v20 = [v14 initWithDomain:v15 code:56 userInfo:v19];

      goto LABEL_111;
    }
    goto LABEL_43;
  }
  if (Logger)
  {
    uint64_t v21 = object_getClass((id)a1);
    BOOL v22 = class_isMetaClass(v21);
    id v23 = object_getClassName((id)a1);
    uint64_t v119 = sel_getName("_openDriver");
    uint64_t v24 = 45;
    if (v22) {
      uint64_t v24 = 43;
    }
    v4(6, "%c[%{public}s %{public}s]:%i starting stack", v24, v23, v119, 1656);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v25 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    int v26 = object_getClass((id)a1);
    if (class_isMetaClass(v26)) {
      int v27 = 43;
    }
    else {
      int v27 = 45;
    }
    unsigned int v28 = object_getClassName((id)a1);
    int v29 = sel_getName("_openDriver");
    *(_DWORD *)id buf = 67109890;
    *(_DWORD *)&uint8_t buf[4] = v27;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = v28;
    *(_WORD *)&buf[18] = 2082;
    *(void *)&buf[20] = v29;
    *(_WORD *)&buf[28] = 1024;
    *(_DWORD *)&buf[30] = 1656;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i starting stack", buf, 0x22u);
  }

  sub_100159AD4(a1);
  *(unsigned char *)(a1 + 176) = 0;
  *(unsigned char *)(a1 + 136) = 0;
  *(_DWORD *)(a1 + 192) = 0;
  *(void *)(a1 + 144) = 0;
  __int16 v30 = *(void **)(a1 + 160);
  *(void *)(a1 + 160) = 0;

  memset(buf, 0, 48);
  *(void *)id buf = getenv("STOCKHOLM_DEVICE");
  *(void *)&uint8_t buf[8] = getenv("HAMMERFEST_DEVICE");
  *(void *)&buf[24] = *(void *)(a1 + 272);
  int v31 = *(_DWORD *)(a1 + 244);
  *(_DWORD *)&buf[32] = *(_DWORD *)(a1 + 224);
  *(_DWORD *)&buf[36] = v31;
  __int16 v32 = NFSharedSignpostLog();
  if (os_signpost_enabled(v32))
  {
    *(_WORD *)long long v135 = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v32, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "DRIVER_OPEN", (const char *)&unk_100286819, v135, 2u);
  }

  uint64_t v33 = NFDriverOpen();
  *(void *)(a1 + 40) = v33;
  if (v33)
  {
    __int16 v34 = NFSharedSignpostLog();
    if (os_signpost_enabled(v34))
    {
      *(_WORD *)long long v135 = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v34, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "DRIVER_OPEN", "success", v135, 2u);
    }

    NFDriverSetCallback();
    NFDriverSetCallback();
    NFDriverSetCallback();
    NFDriverSetCallback();
    NFDriverSetCallback();
    NFDriverSetCallback();
    NFDriverSetCallback();
    NFDriverSetCallback();
    NFDriverSetCallback();
    NFDriverSetCallback();
    NFDriverSetCallback();
    NFDriverSetCallback();
    NFDriverSetCallback();
    NFDriverSetCallback();
    NFDriverSetCallback();
    NFDriverSetCallback();
    NFDriverSetCallback();
    NFDriverSetCallback();
    NFDriverSetCallback();
    NFDriverSetCallback();
    NFDriverSetCallback();
    NFDriverSetCallback();
    NFDriverSetCallback();
    NFDriverSetCallback();
    NFDriverSetCallback();
    NFDriverSetCallback();
    NFDriverSetCallback();
    int v35 = NFSharedSignpostLog();
    if (os_signpost_enabled(v35))
    {
      *(_WORD *)long long v135 = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v35, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "DRIVER_LOAD_STACK", (const char *)&unk_100286819, v135, 2u);
    }

    id v120 = [objc_alloc((Class)NSUserDefaults) initWithSuiteName:@"com.apple.stockholm"];
    if (!NFIsInternalBuild()
      || ([v120 objectForKey:@"fakeDriverInitResult"],
          __int16 v36 = objc_claimAutoreleasedReturnValue(),
          BOOL v37 = v36 == 0,
          v36,
          v37))
    {
      __int16 v70 = +[NFCALogger sharedCALogger];
      id v71 = [v70 getTimestamp];
      uint64_t Stack = NFDriverLoadStack();
      id v72 = [v70 getDurationFrom:v71];
      if (Stack)
      {
        sub_10006E5A4((uint64_t)NFHardwareEventCALogger, (uint64_t)v72, Stack, 0);
      }
      else
      {
        memset(v135, 0, sizeof(v135));
        NFDriverGetControllerInfo();
        sub_10006E5A4((uint64_t)NFHardwareEventCALogger, (uint64_t)v72, 0, (uint64_t)[v70 getHardwareTypeForCA:*(unsigned int *)&v135[4]]);
      }
    }
    else
    {
      uint64_t Stack = (uint64_t)[v120 integerForKey:@"fakeDriverInitResult"];
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v39 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v39)
      {
        __int16 v40 = object_getClass((id)a1);
        if (class_isMetaClass(v40)) {
          uint64_t v41 = 43;
        }
        else {
          uint64_t v41 = 45;
        }
        id v42 = object_getClassName((id)a1);
        id v43 = sel_getName("_openDriver");
        v39(4, "%c[%{public}s %{public}s]:%i Faking driver init failure; error code=%d", v41, v42, v43, 1685, Stack);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v44 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
      {
        id v45 = object_getClass((id)a1);
        if (class_isMetaClass(v45)) {
          int v46 = 43;
        }
        else {
          int v46 = 45;
        }
        id v47 = object_getClassName((id)a1);
        uint64_t v48 = sel_getName("_openDriver");
        *(_DWORD *)long long v135 = 67110146;
        *(_DWORD *)&v135[4] = v46;
        *(_WORD *)&v135[8] = 2082;
        *(void *)&v135[10] = v47;
        *(_WORD *)&v135[18] = 2082;
        *(void *)&v135[20] = v48;
        __int16 v136 = 1024;
        int v137 = 1685;
        __int16 v138 = 1024;
        LODWORD(v139) = Stack;
        _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Faking driver init failure; error code=%d",
          v135,
          0x28u);
      }

      sleep(2u);
    }
    if (!Stack)
    {
      __int16 v90 = NFSharedSignpostLog();
      if (os_signpost_enabled(v90))
      {
        *(_WORD *)long long v135 = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v90, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "DRIVER_LOAD_STACK", "success", v135, 2u);
      }

      id v20 = 0;
      *(void *)(a1 + 296) = 1;
      *(unsigned char *)(a1 + 223) = 0;
      goto LABEL_89;
    }
    if (Stack == 24)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v73 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v73)
      {
        __int16 v74 = object_getClass((id)a1);
        if (class_isMetaClass(v74)) {
          uint64_t v75 = 43;
        }
        else {
          uint64_t v75 = 45;
        }
        __int16 v76 = object_getClassName((id)a1);
        id v77 = sel_getName("_openDriver");
        v73(3, "%c[%{public}s %{public}s]:%i Stack not loaded, NFCC is download mode", v75, v76, v77, 1733);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v78 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
      {
        int v79 = object_getClass((id)a1);
        if (class_isMetaClass(v79)) {
          int v80 = 43;
        }
        else {
          int v80 = 45;
        }
        int v81 = object_getClassName((id)a1);
        __int16 v82 = sel_getName("_openDriver");
        *(_DWORD *)long long v135 = 67109890;
        *(_DWORD *)&v135[4] = v80;
        *(_WORD *)&v135[8] = 2082;
        *(void *)&v135[10] = v81;
        *(_WORD *)&v135[18] = 2082;
        *(void *)&v135[20] = v82;
        __int16 v136 = 1024;
        int v137 = 1733;
        _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Stack not loaded, NFCC is download mode", v135, 0x22u);
      }

      BOOL v83 = NFSharedSignpostLog();
      if (os_signpost_enabled(v83))
      {
        *(_WORD *)long long v135 = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v83, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "DRIVER_LOAD_STACK", "limited", v135, 2u);
      }

      *(void *)(a1 + 296) = 4;
      *(unsigned char *)(a1 + 223) = 1;
      id v84 = objc_alloc((Class)NSError);
      int v85 = +[NSString stringWithUTF8String:"nfcd"];
      v123[0] = NSLocalizedDescriptionKey;
      __int16 v86 = +[NSString stringWithUTF8String:"NFCC is in Download mode. NCI not available."];
      v124[0] = v86;
      v124[1] = &off_10031FA50;
      v123[1] = @"Line";
      v123[2] = @"Method";
      id v87 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_openDriver")];
      v124[2] = v87;
      v123[3] = NSDebugDescriptionErrorKey;
      id v88 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_openDriver"), 1737];
      v124[3] = v88;
      unint64_t v89 = +[NSDictionary dictionaryWithObjects:v124 forKeys:v123 count:4];
      id v20 = [v84 initWithDomain:v85 code:56 userInfo:v89];

LABEL_89:
      goto LABEL_111;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v91 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v91)
    {
      int v92 = object_getClass((id)a1);
      if (class_isMetaClass(v92)) {
        uint64_t v93 = 43;
      }
      else {
        uint64_t v93 = 45;
      }
      int v94 = object_getClassName((id)a1);
      id v95 = sel_getName("_openDriver");
      v91(3, "%c[%{public}s %{public}s]:%i Failed to start stack : %d", v93, v94, v95, 1710, Stack);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    unsigned int v96 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
    {
      id v97 = object_getClass((id)a1);
      if (class_isMetaClass(v97)) {
        int v98 = 43;
      }
      else {
        int v98 = 45;
      }
      int v99 = object_getClassName((id)a1);
      unsigned int v100 = sel_getName("_openDriver");
      *(_DWORD *)long long v135 = 67110146;
      *(_DWORD *)&v135[4] = v98;
      *(_WORD *)&v135[8] = 2082;
      *(void *)&v135[10] = v99;
      *(_WORD *)&v135[18] = 2082;
      *(void *)&v135[20] = v100;
      __int16 v136 = 1024;
      int v137 = 1710;
      __int16 v138 = 1024;
      LODWORD(v139) = Stack;
      _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to start stack : %d", v135, 0x28u);
    }

    unsigned int v101 = NFSharedSignpostLog();
    if (os_signpost_enabled(v101))
    {
      *(_DWORD *)long long v135 = 67109120;
      *(_DWORD *)&v135[4] = Stack;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v101, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "DRIVER_LOAD_STACK", "failure (%d)", v135, 8u);
    }

    sub_100223B0C((uint64_t)NFDailyStatisticsCALogger, @"loadStackErrorCount");
    *(void *)(a1 + 296) = 2;
    if ((Stack & 0xFFFFFFFE) == 0x10)
    {
      sub_100198FF8((uint64_t)NFBugCapture, @"NFC controller in bad state", @"NFC controller in bad state", 0);
      id v102 = objc_alloc((Class)NSError);
      uint64_t v103 = +[NSString stringWithUTF8String:"nfcd"];
      v131[0] = NSLocalizedDescriptionKey;
      uint64_t v104 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
      v132[0] = v104;
      v132[1] = &off_10031F9F0;
      v131[1] = @"Line";
      v131[2] = @"Method";
      id v105 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_openDriver")];
      v132[2] = v105;
      v131[3] = NSDebugDescriptionErrorKey;
      id v106 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_openDriver"), 1717];
      v132[3] = v106;
      long long v107 = +[NSDictionary dictionaryWithObjects:v132 forKeys:v131 count:4];
      id v108 = [v102 initWithDomain:v103 code:58 userInfo:v107];

      +[NFExceptionsCALogger postAnalyticsSEFailureEvent:4 context:@"NFC controller in bad state" error:v108];
    }
    else
    {
      if (Stack == 14)
      {
        id v116 = objc_alloc((Class)NSError);
        long long v110 = +[NSString stringWithUTF8String:"nfcd"];
        v127[0] = NSLocalizedDescriptionKey;
        long long v111 = +[NSString stringWithUTF8String:"Bad firmware"];
        v128[0] = v111;
        v128[1] = &off_10031FA20;
        v127[1] = @"Line";
        v127[2] = @"Method";
        id v112 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_openDriver")];
        v128[2] = v112;
        v127[3] = NSDebugDescriptionErrorKey;
        id v113 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_openDriver"), 1724];
        v128[3] = v113;
        uint64_t v114 = +[NSDictionary dictionaryWithObjects:v128 forKeys:v127 count:4];
        id v115 = [v116 initWithDomain:v110 code:55 userInfo:v114];
      }
      else
      {
        id v109 = objc_alloc((Class)NSError);
        +[NSString stringWithUTF8String:"nfcd"];
        if (Stack == 2) {
          long long v110 = {;
        }
          v129[0] = NSLocalizedDescriptionKey;
          long long v111 = +[NSString stringWithUTF8String:"Bad firmware"];
          v130[0] = v111;
          v130[1] = &off_10031FA08;
          v129[1] = @"Line";
          v129[2] = @"Method";
          id v112 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_openDriver")];
          v130[2] = v112;
          v129[3] = NSDebugDescriptionErrorKey;
          id v113 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_openDriver"), 1722];
          v130[3] = v113;
          uint64_t v114 = +[NSDictionary dictionaryWithObjects:v130 forKeys:v129 count:4];
          id v115 = [v109 initWithDomain:v110 code:55 userInfo:v114];
        }
        else {
          long long v110 = {;
        }
          v125[0] = NSLocalizedDescriptionKey;
          long long v111 = +[NSString stringWithUTF8String:"Stack Error"];
          v126[0] = v111;
          v126[1] = &off_10031FA38;
          v125[1] = @"Line";
          v125[2] = @"Method";
          id v112 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_openDriver")];
          v126[2] = v112;
          v125[3] = NSDebugDescriptionErrorKey;
          id v113 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_openDriver"), 1726];
          v126[3] = v113;
          uint64_t v114 = +[NSDictionary dictionaryWithObjects:v126 forKeys:v125 count:4];
          id v115 = [v109 initWithDomain:v110 code:15 userInfo:v114];
        }
      }
      id v108 = v115;
    }
    NFDriverClose();
    *(void *)(a1 + 40) = 0;
    id v20 = v108;
  }
  else
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    unsigned int v49 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v49)
    {
      unsigned int v50 = object_getClass((id)a1);
      if (class_isMetaClass(v50)) {
        uint64_t v51 = 43;
      }
      else {
        uint64_t v51 = 45;
      }
      unsigned int v52 = object_getClassName((id)a1);
      uint64_t v53 = sel_getName("_openDriver");
      uint64_t v54 = *(const char **)&buf[8];
      if (!*(void *)&buf[8]) {
        uint64_t v54 = "Unknown device";
      }
      if (*(void *)buf) {
        uint64_t v55 = *(const char **)buf;
      }
      else {
        uint64_t v55 = v54;
      }
      v49(3, "%c[%{public}s %{public}s]:%i Failed to open device: %s", v51, v52, v53, 1671, v55);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v56 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
    {
      id v57 = object_getClass((id)a1);
      if (class_isMetaClass(v57)) {
        int v58 = 43;
      }
      else {
        int v58 = 45;
      }
      BOOL v59 = object_getClassName((id)a1);
      char v60 = sel_getName("_openDriver");
      char v61 = *(const char **)buf;
      int v62 = *(const char **)&buf[8];
      if (!*(void *)&buf[8]) {
        int v62 = "Unknown device";
      }
      if (!*(void *)buf) {
        char v61 = v62;
      }
      *(_DWORD *)long long v135 = 67110146;
      *(_DWORD *)&v135[4] = v58;
      *(_WORD *)&v135[8] = 2082;
      *(void *)&v135[10] = v59;
      *(_WORD *)&v135[18] = 2082;
      *(void *)&v135[20] = v60;
      __int16 v136 = 1024;
      int v137 = 1671;
      __int16 v138 = 2080;
      int v139 = v61;
      _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open device: %s", v135, 0x2Cu);
    }

    int v63 = NFSharedSignpostLog();
    if (os_signpost_enabled(v63))
    {
      *(_WORD *)long long v135 = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v63, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "DRIVER_OPEN", "open failure", v135, 2u);
    }

    *(void *)(a1 + 296) = 2;
    id v64 = objc_alloc((Class)NSError);
    int v65 = +[NSString stringWithUTF8String:"nfcd"];
    v133[0] = NSLocalizedDescriptionKey;
    NSErrorUserInfoKey v66 = +[NSString stringWithUTF8String:"Stack Error"];
    v134[0] = v66;
    v134[1] = &off_10031F9D8;
    v133[1] = @"Line";
    v133[2] = @"Method";
    id v67 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_openDriver")];
    v134[2] = v67;
    v133[3] = NSDebugDescriptionErrorKey;
    id v68 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_openDriver"), 1674];
    v134[3] = v68;
    id v69 = +[NSDictionary dictionaryWithObjects:v134 forKeys:v133 count:4];
    id v20 = [v64 initWithDomain:v65 code:15 userInfo:v69];
  }
LABEL_111:

  return v20;
}

void sub_100211228(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1002112A8(uint64_t a1)
{
  if (a1)
  {
    if (NFProductHasThermistor())
    {
      uint64_t v2 = objc_opt_new();
      id v3 = *(void **)(a1 + 80);
      *(void *)(a1 + 80) = v2;

      id v4 = sub_1001E6B60(*(void *)(a1 + 80));
      objc_initWeak(&location, (id)a1);
      id v5 = objc_alloc((Class)NFTimer);
      id v12 = _NSConcreteStackBlock;
      uint64_t v13 = 3221225472;
      id v14 = sub_1002191D0;
      id v15 = &unk_100301E90;
      objc_copyWeak(v17, &location);
      uint64_t v16 = a1;
      v17[1] = "_openDriverFinalizer";
      id v6 = [v5 initWithCallback:&v12 queue:*(void *)(a1 + 208)];
      id v7 = *(void **)(a1 + 128);
      *(void *)(a1 + 128) = v6;

      objc_destroyWeak(v17);
      objc_destroyWeak(&location);
    }
    [*(id *)(a1 + 248) handleStackLoad:v12 v13:v14 v15:v15];
    [*(id *)(a1 + 88) stackLoaded:*(void *)(a1 + 208)];
    id v8 = [objc_alloc((Class)NSDate) initWithTimeIntervalSinceNow:0.0];
    id v9 = *(void **)(a1 + 72);
    *(void *)(a1 + 72) = v8;

    if ((*(unsigned char *)(a1 + 274) & 2) != 0)
    {
      [*(id *)(a1 + 280) bytes];
      [*(id *)(a1 + 280) length];
      NFDriverSetChipscope();
    }
    id v10 = [objc_alloc((Class)NSUserDefaults) initWithSuiteName:@"com.apple.stockholm"];
    if (NFIsInternalBuild())
    {
      int v11 = [v10 objectForKey:@"smbLogEnabled"];

      if (v11)
      {
        if ([v10 BOOLForKey:@"smbLogEnabled"]) {
          NFDriverEnableSMBLogging();
        }
      }
    }
  }
}

void sub_100211488(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_1002114AC(void *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v4 = a1;
    objc_sync_enter(v4);
    id v5 = [*((id *)v4 + 23) objectForKey:v3];
    id v6 = v5;
    if (v5 && [v5 intValue])
    {
      unsigned int v7 = [v6 intValue];
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      if (v7 == 1)
      {
        uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (Logger)
        {
          Class = object_getClass(v4);
          if (class_isMetaClass(Class)) {
            uint64_t v10 = 43;
          }
          else {
            uint64_t v10 = 45;
          }
          ClassName = object_getClassName(v4);
          Name = sel_getName("closeSession:");
          Logger(6, "%c[%{public}s %{public}s]:%i Closing session on behalf of %{public}@", v10, ClassName, Name, 315, v3);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v13 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          id v14 = object_getClass(v4);
          if (class_isMetaClass(v14)) {
            int v15 = 43;
          }
          else {
            int v15 = 45;
          }
          *(_DWORD *)id buf = 67110146;
          int v54 = v15;
          __int16 v55 = 2082;
          int v56 = object_getClassName(v4);
          __int16 v57 = 2082;
          int v58 = sel_getName("closeSession:");
          __int16 v59 = 1024;
          int v60 = 315;
          __int16 v61 = 2114;
          id v62 = v3;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Closing session on behalf of %{public}@", buf, 0x2Cu);
        }

        [*((id *)v4 + 23) removeObjectForKey:v3];
      }
      else
      {
        __int16 v40 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v40)
        {
          uint64_t v41 = object_getClass(v4);
          if (class_isMetaClass(v41)) {
            uint64_t v42 = 43;
          }
          else {
            uint64_t v42 = 45;
          }
          id v43 = object_getClassName(v4);
          int v44 = sel_getName("closeSession:");
          v40(6, "%c[%{public}s %{public}s]:%i Decrementing session on behalf of %{public}@", v42, v43, v44, 318, v3);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v45 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
        {
          int v46 = object_getClass(v4);
          if (class_isMetaClass(v46)) {
            int v47 = 43;
          }
          else {
            int v47 = 45;
          }
          *(_DWORD *)id buf = 67110146;
          int v54 = v47;
          __int16 v55 = 2082;
          int v56 = object_getClassName(v4);
          __int16 v57 = 2082;
          int v58 = sel_getName("closeSession:");
          __int16 v59 = 1024;
          int v60 = 318;
          __int16 v61 = 2114;
          id v62 = v3;
          _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Decrementing session on behalf of %{public}@", buf, 0x2Cu);
        }

        uint64_t v48 = +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", [v6 intValue] - 1);
        [*((id *)v4 + 23) setObject:v48 forKeyedSubscript:v3];
      }
      int v49 = *((_DWORD *)v4 + 25);
      if (v49 <= 0)
      {
        unsigned int v52 = +[NSAssertionHandler currentHandler];
        [v52 handleFailureInMethod:"closeSession:" object:v4 file:@"NFDriverWrapper.m" lineNumber:322 description:@"Session over released"];

        int v49 = *((_DWORD *)v4 + 25);
      }
      int v50 = v49 - 1;
      *((_DWORD *)v4 + 25) = v50;
      if (!v50)
      {
        *((unsigned char *)v4 + 137) = 1;
        sub_100211D70((uint64_t)v4, 0);
        uint64_t v51 = (void *)*((void *)v4 + 4);
        if (v51) {
          [v51 startTimer:0.0];
        }
      }
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v16 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v16)
      {
        id v17 = object_getClass(v4);
        if (class_isMetaClass(v17)) {
          uint64_t v18 = 43;
        }
        else {
          uint64_t v18 = 45;
        }
        id v19 = object_getClassName(v4);
        id v20 = sel_getName("closeSession:");
        uint64_t v21 = [*((id *)v4 + 23) objectForKeyedSubscript:v3];
        v16(3, "%c[%{public}s %{public}s]:%i Owner %{public}@ does not have a session : %{public}@", v18, v19, v20, 308, v3, v21);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      BOOL v22 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        id v23 = object_getClass(v4);
        if (class_isMetaClass(v23)) {
          int v24 = 43;
        }
        else {
          int v24 = 45;
        }
        id v25 = object_getClassName(v4);
        int v26 = sel_getName("closeSession:");
        int v27 = [*((id *)v4 + 23) objectForKeyedSubscript:v3];
        *(_DWORD *)id buf = 67110402;
        int v54 = v24;
        __int16 v55 = 2082;
        int v56 = v25;
        __int16 v57 = 2082;
        int v58 = v26;
        __int16 v59 = 1024;
        int v60 = 308;
        __int16 v61 = 2114;
        id v62 = v3;
        __int16 v63 = 2114;
        id v64 = v27;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Owner %{public}@ does not have a session : %{public}@", buf, 0x36u);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      unsigned int v28 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v28)
      {
        int v29 = object_getClass(v4);
        if (class_isMetaClass(v29)) {
          uint64_t v30 = 43;
        }
        else {
          uint64_t v30 = 45;
        }
        int v31 = object_getClassName(v4);
        __int16 v32 = sel_getName("closeSession:");
        v28(3, "%c[%{public}s %{public}s]:%i Session Owners: %{public}@", v30, v31, v32, 309, *((void *)v4 + 23));
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v33 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      {
        __int16 v34 = object_getClass(v4);
        if (class_isMetaClass(v34)) {
          int v35 = 43;
        }
        else {
          int v35 = 45;
        }
        __int16 v36 = object_getClassName(v4);
        BOOL v37 = sel_getName("closeSession:");
        int v38 = (void *)*((void *)v4 + 23);
        *(_DWORD *)id buf = 67110146;
        int v54 = v35;
        __int16 v55 = 2082;
        int v56 = v36;
        __int16 v57 = 2082;
        int v58 = v37;
        __int16 v59 = 1024;
        int v60 = 309;
        __int16 v61 = 2114;
        id v62 = v38;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session Owners: %{public}@", buf, 0x2Cu);
      }

      if (NFIsInternalBuild())
      {
        id v39 = +[NSAssertionHandler currentHandler];
        [v39 handleFailureInMethod:"closeSession:" object:v4 file:@"NFDriverWrapper.m" lineNumber:311 description:@"driver session not held"];
      }
    }

    objc_sync_exit(v4);
  }
}

void sub_100211B54(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100211BA0(void *a1)
{
  if (a1)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("stopNow");
      uint64_t v7 = 45;
      if (isMetaClass) {
        uint64_t v7 = 43;
      }
      v3(6, "%c[%{public}s %{public}s]:%i Closing driver now !", v7, ClassName, Name, 338);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v8 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      id v9 = object_getClass(a1);
      if (class_isMetaClass(v9)) {
        int v10 = 43;
      }
      else {
        int v10 = 45;
      }
      *(_DWORD *)id buf = 67109890;
      int v14 = v10;
      __int16 v15 = 2082;
      uint64_t v16 = object_getClassName(a1);
      __int16 v17 = 2082;
      uint64_t v18 = sel_getName("stopNow");
      __int16 v19 = 1024;
      int v20 = 338;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Closing driver now !", buf, 0x22u);
    }

    int v11 = a1;
    objc_sync_enter(v11);
    v11[137] = 1;
    sub_100211D70((uint64_t)v11, 1);
    objc_sync_exit(v11);
  }
}

void sub_100211D54(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100211D70(uint64_t a1, char a2)
{
  if (a1 && *(void *)(a1 + 40))
  {
    kdebug_trace();
    id v4 = NFSharedSignpostLog();
    if (os_signpost_enabled(v4))
    {
      *(_WORD *)id buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "DRIVER_CLOSE", (const char *)&unk_100286819, buf, 2u);
    }

    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass((id)a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName((id)a1);
      Name = sel_getName("_closeDriver:");
      uint64_t v10 = 45;
      if (isMetaClass) {
        uint64_t v10 = 43;
      }
      v6(6, "%c[%{public}s %{public}s]:%i stopping stack", v10, ClassName, Name, 1839);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v11 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      id v12 = object_getClass((id)a1);
      if (class_isMetaClass(v12)) {
        int v13 = 43;
      }
      else {
        int v13 = 45;
      }
      int v14 = object_getClassName((id)a1);
      __int16 v15 = sel_getName("_closeDriver:");
      *(_DWORD *)id buf = 67109890;
      int v24 = v13;
      __int16 v25 = 2082;
      int v26 = v14;
      __int16 v27 = 2082;
      unsigned int v28 = v15;
      __int16 v29 = 1024;
      int v30 = 1839;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i stopping stack", buf, 0x22u);
    }

    [*(id *)(a1 + 112) stopTimer];
    [*(id *)(a1 + 120) stopTimer];
    [*(id *)(a1 + 128) stopTimer];
    uint64_t v16 = *(void **)(a1 + 128);
    *(void *)(a1 + 128) = 0;

    if ((a2 & 1) == 0)
    {
      [*(id *)(a1 + 88) stackUnloaded];
      __int16 v17 = *(void **)(a1 + 88);
      *(void *)(a1 + 88) = 0;

      sub_100001FF4(a1);
      [*(id *)(a1 + 248) handleStackUnload];
      id v18 = (id)sub_1001E6DA4(*(void *)(a1 + 80));
      __int16 v19 = *(void **)(a1 + 80);
      *(void *)(a1 + 80) = 0;
    }
    NFDriverUnloadStackAndLeaveHWEnabled();
    NFDriverClose();
    *(void *)(a1 + 40) = 0;
    int v20 = *(void **)(a1 + 72);
    *(void *)(a1 + 72) = 0;

    uint64_t v21 = *(void **)(a1 + 200);
    *(void *)(a1 + 200) = 0;
  }
}

BOOL sub_100212014(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    id v5 = [v3 objectForKeyedSubscript:@"atx"];
    unsigned int v6 = [v5 unsignedIntValue];

    int v7 = *(_DWORD *)(a1 + 244);
    BOOL v8 = v7 != v6;
    if (v7 != v6) {
      *(_DWORD *)(a1 + 244) = v6;
    }
    id v9 = [v4 objectForKeyedSubscript:@"chipscope"];
    uint64_t v10 = *(void **)(a1 + 280);
    if (!v10 && v9 || v10 && !v9 || v10 && v9 && ([v10 isEqualToData:v9] & 1) == 0)
    {
      objc_storeStrong((id *)(a1 + 280), v9);
      BOOL v8 = 1;
    }
    int v11 = [v4 objectForKeyedSubscript:@"flags"];
    id v12 = [v11 unsignedLongValue];

    if (*(id *)(a1 + 272) != v12)
    {
      *(void *)(a1 + 272) = v12;
      BOOL v8 = 1;
    }
    int v13 = [v4 objectForKeyedSubscript:@"pollPeriod"];
    unsigned int v14 = [v13 unsignedIntValue];

    if (*(_DWORD *)(a1 + 224) != v14)
    {
      *(_DWORD *)(a1 + 224) = v14;
      BOOL v8 = 1;
    }
    __int16 v15 = [v4 objectForKeyedSubscript:@"multiTagPollPeriod"];
    unsigned int v16 = [v15 unsignedIntValue];

    if (*(_DWORD *)(a1 + 228) != v16)
    {
      *(_DWORD *)(a1 + 228) = v16;
      BOOL v8 = 1;
    }
    __int16 v17 = [v4 objectForKeyedSubscript:@"multiTagPollRetries"];
    unsigned int v18 = [v17 unsignedIntValue];

    if (*(_DWORD *)(a1 + 232) != v18)
    {
      *(_DWORD *)(a1 + 232) = v18;
      BOOL v8 = 1;
    }
    __int16 v19 = [v4 objectForKeyedSubscript:@"typeATagDataRate"];
    unsigned int v20 = [v19 unsignedIntValue];

    if (*(_DWORD *)(a1 + 96) != v20)
    {
      *(_DWORD *)(a1 + 96) = v20;
      BOOL v8 = 1;
    }
    uint64_t v21 = [v4 objectForKeyedSubscript:@"ntag5DataRate"];
    unsigned int v22 = [v21 unsignedIntValue];

    if (*(_DWORD *)(a1 + 236) != v22)
    {
      *(_DWORD *)(a1 + 236) = v22;
      BOOL v8 = 1;
    }
    id v23 = [v4 objectForKeyedSubscript:@"ntag5T1"];
    unsigned int v24 = [v23 unsignedIntValue];

    if (*(_DWORD *)(a1 + 240) != v24)
    {
      *(_DWORD *)(a1 + 240) = v24;
      BOOL v8 = 1;
    }
  }
  else
  {
    BOOL v8 = 0;
  }

  return v8;
}

uint64_t sub_100212274(void *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = a1;
  objc_sync_enter(v1);
  if (!v1[137])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (Logger)
    {
      Class = object_getClass(v1);
      if (class_isMetaClass(Class)) {
        uint64_t v5 = 43;
      }
      else {
        uint64_t v5 = 45;
      }
      ClassName = object_getClassName(v1);
      Name = sel_getName("restartDriver");
      Logger(6, "%c[%{public}s %{public}s]:%i re-starting the driver..", v5, ClassName, Name, 416);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    BOOL v8 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      id v9 = object_getClass(v1);
      if (class_isMetaClass(v9)) {
        int v10 = 43;
      }
      else {
        int v10 = 45;
      }
      *(_DWORD *)id buf = 67109890;
      int v24 = v10;
      __int16 v25 = 2082;
      int v26 = object_getClassName(v1);
      __int16 v27 = 2082;
      unsigned int v28 = sel_getName("restartDriver");
      __int16 v29 = 1024;
      int v30 = 416;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i re-starting the driver..", buf, 0x22u);
    }

    sub_100211D70((uint64_t)v1, 0);
    int v11 = sub_10020F914((uint64_t)v1);
    if (v11)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v12 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v12)
      {
        int v13 = object_getClass(v1);
        if (class_isMetaClass(v13)) {
          uint64_t v14 = 43;
        }
        else {
          uint64_t v14 = 45;
        }
        __int16 v15 = object_getClassName(v1);
        unsigned int v16 = sel_getName("restartDriver");
        v12(3, "%c[%{public}s %{public}s]:%i failed to re-start the driver! error=%@", v14, v15, v16, 420, v11);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v17 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        unsigned int v18 = object_getClass(v1);
        if (class_isMetaClass(v18)) {
          int v19 = 43;
        }
        else {
          int v19 = 45;
        }
        unsigned int v20 = object_getClassName(v1);
        uint64_t v21 = sel_getName("restartDriver");
        *(_DWORD *)id buf = 67110146;
        int v24 = v19;
        __int16 v25 = 2082;
        int v26 = v20;
        __int16 v27 = 2082;
        unsigned int v28 = v21;
        __int16 v29 = 1024;
        int v30 = 420;
        __int16 v31 = 2112;
        __int16 v32 = v11;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i failed to re-start the driver! error=%@", buf, 0x2Cu);
      }

      NFDriverSimulateCrash();
      uint64_t v2 = 0;
      goto LABEL_26;
    }
    sub_1002112A8((uint64_t)v1);
  }
  uint64_t v2 = 1;
LABEL_26:
  objc_sync_exit(v1);

  return v2;
}

void sub_100212594(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_1002125C8(uint64_t a1)
{
  if (a1)
  {
    [*(id *)(a1 + 104) lock];
    id v2 = *(id *)(a1 + 160);
    [*(id *)(a1 + 104) unlock];
  }
  else
  {
    id v2 = 0;
  }

  return v2;
}

void sub_100212624(uint64_t a1)
{
  if (a1)
  {
    [*(id *)(a1 + 104) lock];
    int v2 = *(unsigned __int8 *)(a1 + 176);
    [*(id *)(a1 + 112) stopTimer];
    [*(id *)(a1 + 120) stopTimer];
    [*(id *)(a1 + 104) unlock];
    if (v2)
    {
      id v3 = *(NSObject **)(a1 + 208);
      v4[0] = _NSConcreteStackBlock;
      v4[1] = 3221225472;
      v4[2] = sub_1002126D8;
      v4[3] = &unk_100301C40;
      v4[4] = a1;
      void v4[5] = "_resetFieldState";
      dispatch_async(v3, v4);
    }
  }
}

void sub_1002126D8(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v7 = 45;
    if (isMetaClass) {
      uint64_t v7 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i Forcing field exit on state reset", v7, ClassName, Name, 597);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  BOOL v8 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    id v9 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v9)) {
      int v10 = 43;
    }
    else {
      int v10 = 45;
    }
    int v11 = object_getClassName(*(id *)(a1 + 32));
    id v12 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)id buf = 67109890;
    int v15 = v10;
    __int16 v16 = 2082;
    __int16 v17 = v11;
    __int16 v18 = 2082;
    int v19 = v12;
    __int16 v20 = 1024;
    int v21 = 597;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Forcing field exit on state reset", buf, 0x22u);
  }

  sub_100001FF4(*(void *)(a1 + 32));
}

void sub_10021285C(uint64_t a1, void *a2)
{
  if (a1)
  {
    int v2 = *(void **)(a1 + 264);
    id v3 = a2;
    [v2 driverRequestService:v3];
  }
}

uint64_t sub_1002128B4(void *a1)
{
  if (!a1) {
    return 0;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(a1);
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(a1);
    Name = sel_getName("restartDiscovery");
    uint64_t v7 = 45;
    if (isMetaClass) {
      uint64_t v7 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i ", v7, ClassName, Name, 1431);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  BOOL v8 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    id v9 = object_getClass(a1);
    if (class_isMetaClass(v9)) {
      int v10 = 43;
    }
    else {
      int v10 = 45;
    }
    *(_DWORD *)id buf = 67109890;
    int v16 = v10;
    __int16 v17 = 2082;
    __int16 v18 = object_getClassName(a1);
    __int16 v19 = 2082;
    __int16 v20 = sel_getName("restartDiscovery");
    __int16 v21 = 1024;
    int v22 = 1431;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  int v11 = a1;
  objc_sync_enter(v11);
  if (v11[137]) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = sub_100215914((uint64_t)v11);
  }
  objc_sync_exit(v11);

  return v12;
}

void sub_100212A80(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void *sub_100212A9C(void *a1)
{
  uint64_t v1 = a1;
  if (a1)
  {
    int v2 = objc_opt_new();
    id v3 = +[NSNumber numberWithBool:*((unsigned __int8 *)v1 + 137)];
    [v2 setObject:v3 forKeyedSubscript:@"isClosing"];

    id v4 = +[NSNumber numberWithBool:*((unsigned __int8 *)v1 + 24)];
    [v2 setObject:v4 forKeyedSubscript:@"FFStateStored"];

    uint64_t v5 = +[NSNumber numberWithBool:*((unsigned __int8 *)v1 + 176)];
    [v2 setObject:v5 forKeyedSubscript:@"FieldON"];

    unsigned int v6 = +[NSNumber numberWithBool:*((unsigned __int8 *)v1 + 136)];
    [v2 setObject:v6 forKeyedSubscript:@"TechnologySent"];

    uint64_t v7 = (void *)v1[11];
    if (v7)
    {
      BOOL v8 = [v7 state];
      [v2 setObject:v8 forKeyedSubscript:@"Reader Policy"];
    }
    else
    {
      [v2 setObject:&stru_100309C40 forKeyedSubscript:@"Reader Policy"];
    }
    id v9 = [objc_alloc((Class)NSDictionary) initWithDictionary:v1[23]];
    [v2 setObject:v9 forKeyedSubscript:@"driverSessionOpened"];

    int v10 = +[NSNumber numberWithInt:*((unsigned int *)v1 + 25)];
    [v2 setObject:v10 forKeyedSubscript:@"driverSessionCount"];

    uint64_t v1 = [objc_alloc((Class)NSDictionary) initWithDictionary:v2];
  }

  return v1;
}

uint64_t sub_100212C64(void *a1, void *a2)
{
  if (!a1)
  {
    LODWORD(ControllerInfo) = 0;
    return ControllerInfo;
  }
  int v2 = a1;
  objc_sync_enter(v2);
  if (!*((void *)v2 + 5))
  {
    int v81 = +[NSAssertionHandler currentHandler];
    [v81 handleFailureInMethod:"getControllerInfo:" object:v2 file:@"NFDriverWrapper.m" lineNumber:992 description:@"driver not open"];
  }
  uint64_t ControllerInfo = NFDriverGetControllerInfo();
  if ((ControllerInfo & 1) == 0)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (Logger)
    {
      Class = object_getClass(v2);
      if (class_isMetaClass(Class)) {
        uint64_t v5 = 43;
      }
      else {
        uint64_t v5 = 45;
      }
      ClassName = object_getClassName(v2);
      Name = sel_getName("getControllerInfo:");
      Logger(3, "%c[%{public}s %{public}s]:%i Failed to get info", v5, ClassName, Name, 996);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    BOOL v8 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      id v9 = object_getClass(v2);
      if (class_isMetaClass(v9)) {
        int v10 = 43;
      }
      else {
        int v10 = 45;
      }
      *(_DWORD *)id buf = 67109890;
      int v104 = v10;
      __int16 v105 = 2082;
      id v106 = object_getClassName(v2);
      __int16 v107 = 2082;
      id v108 = sel_getName("getControllerInfo:");
      __int16 v109 = 1024;
      int v110 = 996;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get info", buf, 0x22u);
    }
    goto LABEL_85;
  }
  if (NF_isFeatureSupported())
  {
    unsigned int IsHostWakeCapable = 1;
    goto LABEL_45;
  }
  int v11 = v2;
  objc_sync_enter(v11);
  if (v11[137])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v12 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v12)
    {
      int v13 = object_getClass(v11);
      if (class_isMetaClass(v13)) {
        uint64_t v14 = 43;
      }
      else {
        uint64_t v14 = 45;
      }
      int v15 = object_getClassName(v11);
      int v16 = sel_getName("isHostWakeCapable:");
      v12(6, "%c[%{public}s %{public}s]:%i Driver is closed", v14, v15, v16, 1897);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v17 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v18 = object_getClass(v11);
      if (class_isMetaClass(v18)) {
        int v19 = 43;
      }
      else {
        int v19 = 45;
      }
      *(_DWORD *)id buf = 67109890;
      int v104 = v19;
      __int16 v105 = 2082;
      id v106 = object_getClassName(v11);
      __int16 v107 = 2082;
      id v108 = sel_getName("isHostWakeCapable:");
      __int16 v109 = 1024;
      int v110 = 1897;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Driver is closed", buf, 0x22u);
    }

    id v20 = objc_alloc((Class)NSError);
    __int16 v21 = +[NSString stringWithUTF8String:"nfcd"];
    v101[0] = NSLocalizedDescriptionKey;
    int v22 = +[NSString stringWithUTF8String:"Aborted"];
    v102[0] = v22;
    v102[1] = &off_10031FA98;
    v101[1] = @"Line";
    v101[2] = @"Method";
    id v23 = [[objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("isHostWakeCapable:")];
    v102[2] = v23;
    v101[3] = NSDebugDescriptionErrorKey;
    id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("isHostWakeCapable:"), 1898];
    v102[3] = v24;
    __int16 v25 = +[NSDictionary dictionaryWithObjects:v102 forKeys:v101 count:4];
    id v26 = [v20 initWithDomain:v21 code:3 userInfo:v25];
  }
  else
  {
    if (*((void *)v2 + 5))
    {
      unsigned int IsHostWakeCapable = NFDriverIsHostWakeCapable();
      objc_sync_exit(v11);

      uint64_t v33 = 0;
LABEL_43:

      goto LABEL_45;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v68 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v68)
    {
      id v69 = object_getClass(v11);
      if (class_isMetaClass(v69)) {
        uint64_t v70 = 43;
      }
      else {
        uint64_t v70 = 45;
      }
      id v71 = object_getClassName(v11);
      id v72 = sel_getName("isHostWakeCapable:");
      if (*((void *)v2 + 5)) {
        int v73 = "open";
      }
      else {
        int v73 = "closed";
      }
      v68(6, "%c[%{public}s %{public}s]:%i Driver is %s", v70, v71, v72, 1904, v73);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v74 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v75 = object_getClass(v11);
      if (class_isMetaClass(v75)) {
        int v76 = 43;
      }
      else {
        int v76 = 45;
      }
      id v77 = object_getClassName(v11);
      id v78 = sel_getName("isHostWakeCapable:");
      if (*((void *)v2 + 5)) {
        int v79 = "open";
      }
      else {
        int v79 = "closed";
      }
      *(_DWORD *)id buf = 67110146;
      int v104 = v76;
      __int16 v105 = 2082;
      id v106 = v77;
      __int16 v107 = 2082;
      id v108 = v78;
      __int16 v109 = 1024;
      int v110 = 1904;
      __int16 v111 = 2080;
      id v112 = (void *)v79;
      _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Driver is %s", buf, 0x2Cu);
    }

    id v80 = objc_alloc((Class)NSError);
    __int16 v21 = +[NSString stringWithUTF8String:"nfcd"];
    v99[0] = NSLocalizedDescriptionKey;
    int v22 = +[NSString stringWithUTF8String:"Invalid State"];
    v100[0] = v22;
    v100[1] = &off_10031FAB0;
    v99[1] = @"Line";
    v99[2] = @"Method";
    id v23 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("isHostWakeCapable:")];
    v100[2] = v23;
    v99[3] = NSDebugDescriptionErrorKey;
    id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("isHostWakeCapable:"), 1905];
    v100[3] = v24;
    __int16 v25 = +[NSDictionary dictionaryWithObjects:v100 forKeys:v99 count:4];
    id v26 = [v80 initWithDomain:v21 code:12 userInfo:v25];
  }
  __int16 v27 = v26;

  objc_sync_exit(v11);
  if (v27)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    unsigned int v28 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v28)
    {
      __int16 v29 = object_getClass(v11);
      if (class_isMetaClass(v29)) {
        uint64_t v30 = 43;
      }
      else {
        uint64_t v30 = 45;
      }
      __int16 v31 = object_getClassName(v11);
      __int16 v32 = sel_getName("getControllerInfo:");
      v28(3, "%c[%{public}s %{public}s]:%i Error querying wake capability", v30, v31, v32, 1004);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v33 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
    {
      __int16 v34 = object_getClass(v11);
      if (class_isMetaClass(v34)) {
        int v35 = 43;
      }
      else {
        int v35 = 45;
      }
      __int16 v36 = object_getClassName(v11);
      BOOL v37 = sel_getName("getControllerInfo:");
      *(_DWORD *)id buf = 67109890;
      int v104 = v35;
      __int16 v105 = 2082;
      id v106 = v36;
      __int16 v107 = 2082;
      id v108 = v37;
      __int16 v109 = 1024;
      int v110 = 1004;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error querying wake capability", buf, 0x22u);
    }
    unsigned int IsHostWakeCapable = 0;
    goto LABEL_43;
  }
  unsigned int IsHostWakeCapable = 0;
LABEL_45:
  int v85 = [NFHardwareControllerInfo alloc];
  v97[0] = @"siliconVersion";
  BOOL v8 = +[NSNumber numberWithUnsignedInt:HIDWORD(ControllerInfo)];
  v98[0] = v8;
  v97[1] = @"siliconName";
  int v94 = +[NSNumber numberWithUnsignedInt:0];
  v98[1] = v94;
  v97[2] = @"ROMVersion";
  uint64_t v93 = +[NSNumber numberWithUnsignedInt:0];
  v98[2] = v93;
  v97[3] = @"firmwareVersion";
  int v92 = +[NSNumber numberWithUnsignedInt:0];
  v98[3] = v92;
  void v97[4] = @"firmwareRevision";
  __int16 v91 = +[NSNumber numberWithUnsignedInt:0];
  void v98[4] = v91;
  v97[5] = @"middlewareVersion";
  __int16 v90 = +[NSNumber numberWithUnsignedInt:0];
  v98[5] = v90;
  v97[6] = @"hasAntenna";
  unint64_t v89 = +[NSNumber numberWithBool:v2[218]];
  v98[6] = v89;
  v97[7] = @"hasMFW";
  id v88 = +[NSNumber numberWithBool:*(unsigned __int8 *)(*((void *)v2 + 5) + 58)];
  v98[7] = v88;
  v97[8] = @"hasHLMSupport";
  id v87 = +[NSNumber numberWithBool:*(unsigned __int8 *)(*((void *)v2 + 5) + 64)];
  v98[8] = v87;
  v97[9] = @"hasLPEMSupport";
  int v38 = +[NSNumber numberWithInt:sub_1001A9EEC(v2)];
  v98[9] = v38;
  v97[10] = @"hasCarKeySupport";
  if (v2[218] && !NFProductIsPhone() && NFProductIsWatch()) {
    NFGetProductType();
  }
  id v39 = +[NSNumber numberWithInt:0];
  v98[10] = v39;
  v97[11] = @"hasReaderModeSupport";
  __int16 v40 = +[NSUserDefaults standardUserDefaults];
  unsigned int v41 = [v40 BOOLForKey:@"ReaderMode"];

  if (v41)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v42 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v42)
    {
      id v43 = object_getClass(v2);
      if (class_isMetaClass(v43)) {
        uint64_t v44 = 43;
      }
      else {
        uint64_t v44 = 45;
      }
      id v45 = object_getClassName(v2);
      int v46 = sel_getName("_supportsReaderMode");
      v42(4, "%c[%{public}s %{public}s]:%i Defaults override for reader mode", v44, v45, v46, 1331);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v47 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
    {
      uint64_t v48 = object_getClass(v2);
      if (class_isMetaClass(v48)) {
        int v49 = 43;
      }
      else {
        int v49 = 45;
      }
      int v50 = object_getClassName(v2);
      uint64_t v51 = sel_getName("_supportsReaderMode");
      *(_DWORD *)id buf = 67109890;
      int v104 = v49;
      __int16 v105 = 2082;
      id v106 = v50;
      __int16 v107 = 2082;
      id v108 = v51;
      __int16 v109 = 1024;
      int v110 = 1331;
      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Defaults override for reader mode", buf, 0x22u);
    }

    uint64_t v52 = 1;
  }
  else
  {
    uint64_t v52 = NFProductSupportsNFCReader();
    if (NFIsInternalBuild() && v2[218] != v52)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      BOOL v83 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v83)
      {
        uint64_t v53 = object_getClass(v2);
        if (class_isMetaClass(v53)) {
          uint64_t v54 = 43;
        }
        else {
          uint64_t v54 = 45;
        }
        __int16 v82 = object_getClassName(v2);
        __int16 v55 = sel_getName("_supportsReaderMode");
        CFStringRef v56 = @"NO";
        if (v2[218]) {
          CFStringRef v57 = @"YES";
        }
        else {
          CFStringRef v57 = @"NO";
        }
        if (v52) {
          CFStringRef v56 = @"YES";
        }
        v83(3, "%c[%{public}s %{public}s]:%i DeviceSupportsNFC result does not match!!! hasAntenna=%{public}@,  expected=%{public}@", v54, v82, v55, 1371, v57, v56);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v58 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
      {
        __int16 v59 = object_getClass(v2);
        if (class_isMetaClass(v59)) {
          int v60 = 43;
        }
        else {
          int v60 = 45;
        }
        id v84 = object_getClassName(v2);
        __int16 v61 = sel_getName("_supportsReaderMode");
        CFStringRef v62 = @"NO";
        if (v2[218]) {
          CFStringRef v63 = @"YES";
        }
        else {
          CFStringRef v63 = @"NO";
        }
        if (v52) {
          CFStringRef v62 = @"YES";
        }
        *(_DWORD *)id buf = 67110402;
        int v104 = v60;
        __int16 v105 = 2082;
        id v106 = v84;
        __int16 v107 = 2082;
        id v108 = v61;
        __int16 v109 = 1024;
        int v110 = 1371;
        __int16 v111 = 2114;
        id v112 = (void *)v63;
        __int16 v113 = 2114;
        CFStringRef v114 = v62;
        _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i DeviceSupportsNFC result does not match!!! hasAntenna=%{public}@,  expected=%{public}@", buf, 0x36u);
      }

      uint64_t v52 = v2[218] != 0;
    }
  }
  id v64 = +[NSNumber numberWithInt:v52];
  v98[11] = v64;
  v97[12] = @"poweredRunDuringSleep";
  int v65 = +[NSNumber numberWithBool:IsHostWakeCapable];
  v98[12] = v65;
  NSErrorUserInfoKey v66 = +[NSDictionary dictionaryWithObjects:v98 forKeys:v97 count:13];
  *a2 = [(NFHardwareControllerInfo *)v85 initWithDictionary:v66];

LABEL_85:
  objc_sync_exit(v2);

  return ControllerInfo;
}

void sub_100213AEC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

unint64_t sub_100213B4C(unint64_t result)
{
  if (result >= 3)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (Logger) {
      Logger(3, "%s:%i Returning NFSecureElementRoutingOff because of invalid mode.", "-[NFDriverWrapper _asSecureElementRouting:]", 1043);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v2 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)id buf = 136446466;
      id v4 = "-[NFDriverWrapper _asSecureElementRouting:]";
      __int16 v5 = 1024;
      int v6 = 1043;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "%{public}s:%i Returning NFSecureElementRoutingOff because of invalid mode.", buf, 0x12u);
    }

    return 0;
  }
  return result;
}

unint64_t sub_100213C4C(void *a1)
{
  id v1 = a1;
  [v1 wantsExpress];
  [v1 wantsIsoDepToHost];
  unsigned int v2 = sub_100213B4C((unint64_t)[v1 embeddedMode]);
  id v3 = [v1 hostMode];

  return v2 | (sub_100213B4C((unint64_t)v3) << 32);
}

id sub_100213CD8(void *a1, void *a2)
{
  id v4 = a2;
  if (a1)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      int v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(a1);
      uint64_t Name = (uint64_t)sel_getName("setRouting:");
      if ([v4 fdOn]) {
        int v10 = "yes";
      }
      else {
        int v10 = "no";
      }
      int v162 = v10;
      uint64_t v11 = 45;
      if (isMetaClass) {
        uint64_t v11 = 43;
      }
      v6(6, "%c[%{public}s %{public}s]:%i FieldDetect=%s : Routing %{public}@", v11, ClassName, Name, 1069, v162, v4);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v12 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = object_getClass(a1);
      if (class_isMetaClass(v13)) {
        uint64_t Name = 43;
      }
      else {
        uint64_t Name = 45;
      }
      uint64_t v14 = object_getClassName(a1);
      int v15 = sel_getName("setRouting:");
      *(_DWORD *)id buf = 67110402;
      if ([v4 fdOn]) {
        int v16 = "yes";
      }
      else {
        int v16 = "no";
      }
      int v180 = Name;
      __int16 v181 = 2082;
      id v182 = v14;
      __int16 v183 = 2082;
      uint64_t v184 = v15;
      __int16 v185 = 1024;
      int v186 = 1069;
      __int16 v187 = 2080;
      __int16 v188 = v16;
      __int16 v189 = 2114;
      id v190 = v4;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i FieldDetect=%s : Routing %{public}@", buf, 0x36u);
    }

    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v17 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v17)
    {
      __int16 v18 = object_getClass(a1);
      if (class_isMetaClass(v18)) {
        uint64_t v19 = 43;
      }
      else {
        uint64_t v19 = 45;
      }
      id v20 = object_getClassName(a1);
      __int16 v21 = sel_getName("setRouting:");
      v17(6, "%c[%{public}s %{public}s]:%i current routing: %{public}@", v19, v20, v21, 1070, a1[25]);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v22 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      id v23 = object_getClass(a1);
      if (class_isMetaClass(v23)) {
        int v24 = 43;
      }
      else {
        int v24 = 45;
      }
      __int16 v25 = object_getClassName(a1);
      id v26 = sel_getName("setRouting:");
      __int16 v27 = (const char *)a1[25];
      *(_DWORD *)id buf = 67110146;
      int v180 = v24;
      __int16 v181 = 2082;
      id v182 = v25;
      __int16 v183 = 2082;
      uint64_t v184 = v26;
      __int16 v185 = 1024;
      int v186 = 1070;
      __int16 v187 = 2114;
      __int16 v188 = v27;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i current routing: %{public}@", buf, 0x2Cu);
    }

    unsigned int v165 = [v4 fdOn];
    unsigned int v167 = [v4 wantsCardEmulation];
    unsigned int v166 = [v4 pollingType];
    unsigned int v168 = [v4 wantsExpress];
    unsigned int v164 = [v4 wantsSEReader];
    unsigned int v28 = a1;
    objc_sync_enter(v28);
    if (v28[137])
    {
      id v29 = objc_alloc((Class)NSError);
      uint64_t v30 = +[NSString stringWithUTF8String:"nfcd"];
      v177[0] = NSLocalizedDescriptionKey;
      __int16 v31 = +[NSString stringWithUTF8String:"Aborted"];
      v178[0] = v31;
      v178[1] = &off_10031F930;
      v177[1] = @"Line";
      v177[2] = @"Method";
      id v32 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("setRouting:")];
      v178[2] = v32;
      v177[3] = NSDebugDescriptionErrorKey;
      id v33 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", @"setRouting:", 1085];
      v178[3] = v33;
      __int16 v34 = +[NSDictionary dictionaryWithObjects:v178 forKeys:v177 count:4];
      id v35 = [v29 initWithDomain:v30 code:3 userInfo:v34];

LABEL_182:
      objc_sync_exit(v28);

      goto LABEL_183;
    }
    if (!*((void *)v28 + 5))
    {
      id v161 = +[NSAssertionHandler currentHandler];
      [v161 handleFailureInMethod:"setRouting:" object:v28 file:@"NFDriverWrapper.m" lineNumber:1088 description:@"driver not open"];
    }
    BOOL v37 = (id *)(v28 + 200);
    __int16 v36 = (void *)*((void *)v28 + 25);
    if (v36
      && [v36 isEquivalentRouting:v4]
      && (v165 == [*v37 fdOn] || objc_msgSend(v4, "fieldDetectType") == (id)3))
    {
      int v38 = NFSharedSignpostLog();
      if (os_signpost_enabled(v38))
      {
        *(_WORD *)id buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v38, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SetRoutingConfigInDriverWrapper", "No changes necessary", buf, 2u);
      }

LABEL_168:
      id v35 = 0;
      goto LABEL_182;
    }
    if ([v4 pollingType] == 1 || objc_msgSend(v4, "pollingType") == 2)
    {
      [v4 polling];
      [v4 tagDiscoveryConfig];
      sub_1001E0544(v28);
    }
    id v39 = [*v37 lpcdEcpFrame];
    if (!v39 || ([v4 lpcdEcpFrame], (uint64_t Name = objc_claimAutoreleasedReturnValue()) != 0))
    {
      unsigned int v41 = [*v37 lpcdEcpFrame];
      if (v41)
      {
        BOOL v40 = 0;
      }
      else
      {
        uint64_t v42 = [v4 lpcdEcpFrame];
        BOOL v40 = v42 != 0;
      }
      if (!v39) {
        goto LABEL_49;
      }
    }
    else
    {
      BOOL v40 = 1;
    }

LABEL_49:
    id v43 = [*v37 lpcdEcpFrame];
    if (v43)
    {
      uint64_t v44 = [v4 lpcdEcpFrame];
      if (v44)
      {
        id v45 = [*v37 lpcdEcpFrame];
        int v46 = [v4 lpcdEcpFrame];
        unsigned int v47 = [v45 isEqualToData:v46];

        int v48 = v47 ^ 1;
      }
      else
      {
        int v48 = 0;
      }
    }
    else
    {
      int v48 = 0;
    }

    if ([v4 pollingType] == 2
      || [*v37 pollingType] == 2
      || [v4 pollingType] == 1
      || [*v37 pollingType] == 1)
    {
      if ((v40 | v48) == 1)
      {
LABEL_60:
        if ((NFDriverSetConfiguration() & 1) == 0)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v51 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v51)
          {
            uint64_t v52 = object_getClass(v28);
            if (class_isMetaClass(v52)) {
              uint64_t v53 = 43;
            }
            else {
              uint64_t v53 = 45;
            }
            uint64_t v54 = object_getClassName(v28);
            __int16 v55 = sel_getName("setRouting:");
            v51(3, "%c[%{public}s %{public}s]:%i Failed to stop routing for ECP configurationconfigure card emulation", v53, v54, v55, 1134);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          CFStringRef v56 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
          {
            CFStringRef v57 = object_getClass(v28);
            if (class_isMetaClass(v57)) {
              int v58 = 43;
            }
            else {
              int v58 = 45;
            }
            __int16 v59 = object_getClassName(v28);
            int v60 = sel_getName("setRouting:");
            *(_DWORD *)id buf = 67109890;
            int v180 = v58;
            __int16 v181 = 2082;
            id v182 = v59;
            __int16 v183 = 2082;
            uint64_t v184 = v60;
            __int16 v185 = 1024;
            int v186 = 1134;
            _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to stop routing for ECP configurationconfigure card emulation", buf, 0x22u);
          }

          id v61 = objc_alloc((Class)NSError);
          CFStringRef v62 = +[NSString stringWithUTF8String:"nfcd"];
          v175[0] = NSLocalizedDescriptionKey;
          CFStringRef v63 = +[NSString stringWithUTF8String:"Stack Error"];
          v176[0] = v63;
          v176[1] = &off_10031F948;
          v175[1] = @"Line";
          v175[2] = @"Method";
          id v64 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("setRouting:")];
          v176[2] = v64;
          v175[3] = NSDebugDescriptionErrorKey;
          id v65 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("setRouting:"), 1135];
          v176[3] = v65;
          NSErrorUserInfoKey v66 = +[NSDictionary dictionaryWithObjects:v176 forKeys:v175 count:4];
          id v35 = [v61 initWithDomain:v62 code:15 userInfo:v66];

          goto LABEL_182;
        }
        int v49 = [v4 lpcdEcpFrame];
        sub_1001E06D4(v28, v49);

        int v50 = 1;
LABEL_75:
        [*((id *)v28 + 13) lock];
        int v67 = v28[176];
        *((_DWORD *)v28 + 48) = 1;
        [*((id *)v28 + 13) unlock];
        if ([v4 embeddedMode] == (id)1)
        {
          if (v67)
          {
            if (v28[220]) {
              float v68 = 1.0;
            }
            else {
              float v68 = 0.5;
            }
          }
          else
          {
            float v68 = 0.0;
          }
          goto LABEL_99;
        }
        if ([v4 embeddedMode] == (id)2)
        {
          if (v67) {
            float v68 = 0.5;
          }
          else {
            float v68 = 0.0;
          }
        }
        else
        {
          float v68 = 0.0;
          if ([v4 embeddedMode] || !v28[64])
          {
LABEL_99:
            id v79 = [v4 hostMode];
            BOOL v80 = v67 != 0;
            BOOL v82 = v68 == 0.0 && v79 == (id)2;
            float v83 = 0.5;
            if (!v80 || !v82) {
              float v83 = v68;
            }
            if (v80 && v83 == 0.0) {
              float v84 = 1.0;
            }
            else {
              float v84 = v83;
            }
            if ((v167 | v168) == 1) {
              *(unsigned char *)(*((void *)v28 + 5) + 59) = sub_100201AE0(*((void **)v28 + 21), 0);
            }
            if (v167) {
              [v4 cardEmulationType];
            }
            if (v166)
            {
              if (v166 == 3)
              {
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                int v85 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
                if (v85)
                {
                  __int16 v86 = object_getClass(v28);
                  if (class_isMetaClass(v86)) {
                    uint64_t v87 = 43;
                  }
                  else {
                    uint64_t v87 = 45;
                  }
                  id v88 = object_getClassName(v28);
                  unint64_t v89 = sel_getName("setRouting:");
                  v85(6, "%c[%{public}s %{public}s]:%i MultiTag Detection enabled", v87, v88, v89, 1210);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                __int16 v90 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
                {
                  __int16 v91 = object_getClass(v28);
                  if (class_isMetaClass(v91)) {
                    int v92 = 43;
                  }
                  else {
                    int v92 = 45;
                  }
                  uint64_t v93 = object_getClassName(v28);
                  int v94 = sel_getName("setRouting:");
                  *(_DWORD *)id buf = 67109890;
                  int v180 = v92;
                  __int16 v181 = 2082;
                  id v182 = v93;
                  __int16 v183 = 2082;
                  uint64_t v184 = v94;
                  __int16 v185 = 1024;
                  int v186 = 1210;
                  _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i MultiTag Detection enabled", buf, 0x22u);
                }
              }
              [v4 pollingDuration];
              sub_1001E064C(v28);
              if ([*((id *)v28 + 11) readerModeProtectionActive])
              {
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                id v95 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
                if (v95)
                {
                  unsigned int v96 = object_getClass(v28);
                  if (class_isMetaClass(v96)) {
                    uint64_t v97 = 43;
                  }
                  else {
                    uint64_t v97 = 45;
                  }
                  int v98 = object_getClassName(v28);
                  int v99 = sel_getName("setRouting:");
                  unsigned int v100 = [*((id *)v28 + 11) state];
                  v95(4, "%c[%{public}s %{public}s]:%i Denying reader mode, protection active. state=%@", v97, v98, v99, 1216, v100);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                unsigned int v101 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
                {
                  id v102 = object_getClass(v28);
                  if (class_isMetaClass(v102)) {
                    int v103 = 43;
                  }
                  else {
                    int v103 = 45;
                  }
                  int v104 = object_getClassName(v28);
                  __int16 v105 = sel_getName("setRouting:");
                  id v106 = [*((id *)v28 + 11) state];
                  *(_DWORD *)id buf = 67110146;
                  int v180 = v103;
                  __int16 v181 = 2082;
                  id v182 = v104;
                  __int16 v183 = 2082;
                  uint64_t v184 = v105;
                  __int16 v185 = 1024;
                  int v186 = 1216;
                  __int16 v187 = 2112;
                  __int16 v188 = v106;
                  _os_log_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Denying reader mode, protection active. state=%@", buf, 0x2Cu);
                }
                if (v50
                  && (sub_100213C4C(*v37),
                      [*v37 fdOn],
                      [*v37 pollingType],
                      [*v37 wantsExpress],
                      [*v37 cardEmulationType],
                      [*v37 wantsSEReader],
                      !NFDriverSetConfiguration()))
                {
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  int v145 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
                  if (v145)
                  {
                    __int16 v146 = object_getClass(v28);
                    if (class_isMetaClass(v146)) {
                      uint64_t v147 = 43;
                    }
                    else {
                      uint64_t v147 = 45;
                    }
                    id v148 = object_getClassName(v28);
                    unsigned int v149 = sel_getName("setRouting:");
                    v145(3, "%c[%{public}s %{public}s]:%i Failed to set configuration", v147, v148, v149, 1228);
                  }
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  int v150 = NFSharedLogGetLogger();
                  if (os_log_type_enabled(v150, OS_LOG_TYPE_ERROR))
                  {
                    int v151 = object_getClass(v28);
                    if (class_isMetaClass(v151)) {
                      int v152 = 43;
                    }
                    else {
                      int v152 = 45;
                    }
                    int v153 = object_getClassName(v28);
                    __int16 v154 = sel_getName("setRouting:");
                    *(_DWORD *)id buf = 67109890;
                    int v180 = v152;
                    __int16 v181 = 2082;
                    id v182 = v153;
                    __int16 v183 = 2082;
                    uint64_t v184 = v154;
                    __int16 v185 = 1024;
                    int v186 = 1228;
                    _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set configuration", buf, 0x22u);
                  }

                  id v155 = objc_alloc((Class)NSError);
                  __int16 v156 = +[NSString stringWithUTF8String:"nfcd"];
                  v173[0] = NSLocalizedDescriptionKey;
                  int v157 = +[NSString stringWithUTF8String:"Stack Error"];
                  v174[0] = v157;
                  v174[1] = &off_10031F960;
                  v173[1] = @"Line";
                  v173[2] = @"Method";
                  id v158 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("setRouting:")];
                  v174[2] = v158;
                  v173[3] = NSDebugDescriptionErrorKey;
                  id v159 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("setRouting:"), 1229];
                  v174[3] = v159;
                  int v160 = +[NSDictionary dictionaryWithObjects:v174 forKeys:v173 count:4];
                  id v35 = [v155 initWithDomain:v156 code:15 userInfo:v160];
                }
                else
                {
                  id v107 = objc_alloc((Class)NSError);
                  id v108 = +[NSString stringWithUTF8String:"nfcd"];
                  v171[0] = NSLocalizedDescriptionKey;
                  __int16 v109 = +[NSString stringWithUTF8String:"Reader mode temporarily disabled"];
                  v172[0] = v109;
                  v172[1] = &off_10031F978;
                  v171[1] = @"Line";
                  v171[2] = @"Method";
                  id v110 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("setRouting:")];
                  v172[2] = v110;
                  v171[3] = NSDebugDescriptionErrorKey;
                  id v111 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("setRouting:"), 1232];
                  v172[3] = v111;
                  id v112 = +[NSDictionary dictionaryWithObjects:v172 forKeys:v171 count:4];
                  id v35 = [v107 initWithDomain:v108 code:47 userInfo:v112];
                }
                goto LABEL_182;
              }
            }
            else
            {
              sub_1001E064C(v28);
              sub_1001E6E4C(*((unsigned char **)v28 + 10), 0);
              if ([*((id *)v28 + 11) readerModeStoppedShouldCooloffRun]) {
                id v113 = sub_10020EC8C(v28, @"Cooloff", 1uLL);
              }
            }
            sub_100213C4C(v4);
            CFStringRef v114 = NFSharedSignpostLog();
            if (os_signpost_enabled(v114))
            {
              *(_WORD *)id buf = 0;
              _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v114, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "SET_SE_ROUTING", "NFDriverSetConfiguration", buf, 2u);
            }

            uint64_t v115 = mach_absolute_time();
            if ((NFDriverSetConfiguration() & 1) == 0)
            {
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              BOOL v127 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
              if (v127)
              {
                int v128 = object_getClass(v28);
                if (class_isMetaClass(v128)) {
                  uint64_t v129 = 43;
                }
                else {
                  uint64_t v129 = 45;
                }
                BOOL v130 = object_getClassName(v28);
                uint64_t v131 = sel_getName("setRouting:");
                v127(3, "%c[%{public}s %{public}s]:%i Failed to set configuration", v129, v130, v131, 1256);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              int v132 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v132, OS_LOG_TYPE_ERROR))
              {
                id v133 = object_getClass(v28);
                if (class_isMetaClass(v133)) {
                  int v134 = 43;
                }
                else {
                  int v134 = 45;
                }
                long long v135 = object_getClassName(v28);
                __int16 v136 = sel_getName("setRouting:");
                *(_DWORD *)id buf = 67109890;
                int v180 = v134;
                __int16 v181 = 2082;
                id v182 = v135;
                __int16 v183 = 2082;
                uint64_t v184 = v136;
                __int16 v185 = 1024;
                int v186 = 1256;
                _os_log_impl((void *)&_mh_execute_header, v132, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set configuration", buf, 0x22u);
              }

              int v137 = NFSharedSignpostLog();
              if (os_signpost_enabled(v137))
              {
                *(_WORD *)id buf = 0;
                _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v137, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SET_SE_ROUTING", "Error in NFDriverSetConfiguration", buf, 2u);
              }

              id v138 = objc_alloc((Class)NSError);
              int v139 = +[NSString stringWithUTF8String:"nfcd"];
              v169[0] = NSLocalizedDescriptionKey;
              BOOL v140 = +[NSString stringWithUTF8String:"Stack Error"];
              v170[0] = v140;
              v170[1] = &off_10031F990;
              v169[1] = @"Line";
              v169[2] = @"Method";
              id v141 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("setRouting:")];
              v170[2] = v141;
              v169[3] = NSDebugDescriptionErrorKey;
              id v142 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("setRouting:"), 1258];
              v170[3] = v142;
              uint64_t v143 = +[NSDictionary dictionaryWithObjects:v170 forKeys:v169 count:4];
              id v35 = [v138 initWithDomain:v139 code:15 userInfo:v143];

              goto LABEL_182;
            }
            objc_storeStrong((id *)v28 + 25, a2);
            id v116 = NFSharedSignpostLog();
            if (os_signpost_enabled(v116))
            {
              *(_WORD *)id buf = 0;
              _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v116, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SET_SE_ROUTING", "NFDriverSetConfiguration", buf, 2u);
            }

            if (v164 && v28[64])
            {
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              int v117 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
              if (v117)
              {
                CFStringRef v118 = object_getClass(v28);
                if (class_isMetaClass(v118)) {
                  uint64_t v119 = 43;
                }
                else {
                  uint64_t v119 = 45;
                }
                id v120 = object_getClassName(v28);
                char v121 = sel_getName("setRouting:");
                v117(6, "%c[%{public}s %{public}s]:%i Reader starting and Applet is ready.", v119, v120, v121, 1264);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              int v122 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v123 = object_getClass(v28);
                if (class_isMetaClass(v123)) {
                  int v124 = 43;
                }
                else {
                  int v124 = 45;
                }
                id v125 = object_getClassName(v28);
                uint64_t v126 = sel_getName("setRouting:");
                *(_DWORD *)id buf = 67109890;
                int v180 = v124;
                __int16 v181 = 2082;
                id v182 = v125;
                __int16 v183 = 2082;
                uint64_t v184 = v126;
                __int16 v185 = 1024;
                int v186 = 1264;
                _os_log_impl((void *)&_mh_execute_header, v122, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Reader starting and Applet is ready.", buf, 0x22u);
              }
            }
            if (v84 != 0.0)
            {
              [*((id *)v28 + 13) lock];
              if (v28[176] && v115 > *((void *)v28 + 19))
              {
                if (*((_DWORD *)v28 + 48) == 1) {
                  [*((id *)v28 + 15) startTimer:v84];
                }
                *((_DWORD *)v28 + 48) = 0;
              }
              [*((id *)v28 + 13) unlock];
            }
            goto LABEL_168;
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v69 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v69)
          {
            uint64_t v70 = object_getClass(v28);
            if (class_isMetaClass(v70)) {
              uint64_t v71 = 43;
            }
            else {
              uint64_t v71 = 45;
            }
            id v72 = object_getClassName(v28);
            int v73 = sel_getName("setRouting:");
            v69(6, "%c[%{public}s %{public}s]:%i Resetting applet state", v71, v72, v73, 1172);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          __int16 v74 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v75 = object_getClass(v28);
            if (class_isMetaClass(v75)) {
              int v76 = 43;
            }
            else {
              int v76 = 45;
            }
            id v77 = object_getClassName(v28);
            id v78 = sel_getName("setRouting:");
            *(_DWORD *)id buf = 67109890;
            int v180 = v76;
            __int16 v181 = 2082;
            id v182 = v77;
            __int16 v183 = 2082;
            uint64_t v184 = v78;
            __int16 v185 = 1024;
            int v186 = 1172;
            _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Resetting applet state", buf, 0x22u);
          }
        }
        v28[64] = 0;
        goto LABEL_99;
      }
    }
    else if ([v4 fdOn] & (v40 | v48))
    {
      goto LABEL_60;
    }
    int v50 = 0;
    goto LABEL_75;
  }
  id v35 = 0;
LABEL_183:

  return v35;
}

void sub_100215558(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1002155FC(void *a1, uint64_t a2, int a3)
{
  if (a1)
  {
    __int16 v5 = a1;
    objc_sync_enter(v5);
    if (!v5[137])
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (Logger)
      {
        Class = object_getClass(v5);
        if (class_isMetaClass(Class)) {
          uint64_t v8 = 43;
        }
        else {
          uint64_t v8 = 45;
        }
        Classuint64_t Name = object_getClassName(v5);
        uint64_t Name = sel_getName("setExpressConfig:updateLPEMConfig:");
        Logger(6, "%c[%{public}s %{public}s]:%i 0x%04x", v8, ClassName, Name, 1294, a2);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v11 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = object_getClass(v5);
        if (class_isMetaClass(v12)) {
          int v13 = 43;
        }
        else {
          int v13 = 45;
        }
        *(_DWORD *)id buf = 67110146;
        int v25 = v13;
        __int16 v26 = 2082;
        __int16 v27 = object_getClassName(v5);
        __int16 v28 = 2082;
        id v29 = sel_getName("setExpressConfig:updateLPEMConfig:");
        __int16 v30 = 1024;
        int v31 = 1294;
        __int16 v32 = 1024;
        int v33 = a2;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i 0x%04x", buf, 0x28u);
      }

      NFDriverSetExpressConfig();
      if (a3)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v14 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v14)
        {
          int v15 = object_getClass(v5);
          if (class_isMetaClass(v15)) {
            uint64_t v16 = 43;
          }
          else {
            uint64_t v16 = 45;
          }
          __int16 v17 = object_getClassName(v5);
          __int16 v18 = sel_getName("setExpressConfig:updateLPEMConfig:");
          v14(6, "%c[%{public}s %{public}s]:%i Updating the express config", v16, v17, v18, 1297);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v19 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
        {
          id v20 = object_getClass(v5);
          if (class_isMetaClass(v20)) {
            int v21 = 43;
          }
          else {
            int v21 = 45;
          }
          int v22 = object_getClassName(v5);
          id v23 = sel_getName("setExpressConfig:updateLPEMConfig:");
          *(_DWORD *)id buf = 67109890;
          int v25 = v21;
          __int16 v26 = 2082;
          __int16 v27 = v22;
          __int16 v28 = 2082;
          id v29 = v23;
          __int16 v30 = 1024;
          int v31 = 1297;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Updating the express config", buf, 0x22u);
        }

        NFDriverSetHeadlessMode();
      }
    }
    objc_sync_exit(v5);
  }
}

void sub_1002158E0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100215914(uint64_t a1)
{
  if (*(_DWORD *)(*(void *)(a1 + 40) + 32)) {
    unsigned int v2 = [*(id *)(a1 + 88) readerModeProtectionActive];
  }
  else {
    unsigned int v2 = 0;
  }
  sub_1001E6E4C(*(unsigned char **)(a1 + 80), 0);
  if ([*(id *)(a1 + 88) readerModeStoppedShouldCooloffRun])
  {
    unsigned int v2 = 1;
    id v3 = (id)sub_10020EC8C(a1, @"Cooloff", 1);
  }
  [*(id *)(a1 + 104) lock];
  int v4 = *(unsigned __int8 *)(a1 + 176);
  if (*(unsigned char *)(a1 + 176))
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      int v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass((id)a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName((id)a1);
      uint64_t Name = sel_getName("_restartDiscoveryWithReconfig:");
      uint64_t v10 = 45;
      if (isMetaClass) {
        uint64_t v10 = 43;
      }
      v6(6, "%c[%{public}s %{public}s]:%i Restarting field coalescing timer", v10, ClassName, Name, 1407);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v11 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = object_getClass((id)a1);
      if (class_isMetaClass(v12)) {
        int v13 = 43;
      }
      else {
        int v13 = 45;
      }
      *(_DWORD *)id buf = 67109890;
      int v32 = v13;
      __int16 v33 = 2082;
      __int16 v34 = object_getClassName((id)a1);
      __int16 v35 = 2082;
      __int16 v36 = sel_getName("_restartDiscoveryWithReconfig:");
      __int16 v37 = 1024;
      int v38 = 1407;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Restarting field coalescing timer", buf, 0x22u);
    }

    [*(id *)(a1 + 120) stopTimer];
    [*(id *)(a1 + 120) startTimer:0.5];
  }
  [*(id *)(a1 + 104) unlock];
  uint64_t restarted = NFDriverRestartDiscovery();
  if ((v2 & restarted) == 1)
  {
    uint64_t v15 = 1;
    sub_1001E6E4C(*(unsigned char **)(a1 + 80), 1u);
    [*(id *)(a1 + 88) triggerBurnoutTimer];
  }
  else
  {
    uint64_t v15 = restarted;
    if (v4) {
      char v16 = restarted;
    }
    else {
      char v16 = 1;
    }
    if ((v16 & 1) == 0)
    {
      [*(id *)(a1 + 104) lock];
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v17 = NFLogGetLogger();
      if (v17)
      {
        __int16 v18 = (void (*)(uint64_t, const char *, ...))v17;
        uint64_t v19 = object_getClass((id)a1);
        BOOL v20 = class_isMetaClass(v19);
        int v21 = object_getClassName((id)a1);
        __int16 v30 = sel_getName("_restartDiscoveryWithReconfig:");
        uint64_t v22 = 45;
        if (v20) {
          uint64_t v22 = 43;
        }
        v18(4, "%c[%{public}s %{public}s]:%i Stopping coalescing timer as restart discovery failed", v22, v21, v30, 1421);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v23 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
        int v24 = object_getClass((id)a1);
        if (class_isMetaClass(v24)) {
          int v25 = 43;
        }
        else {
          int v25 = 45;
        }
        __int16 v26 = object_getClassName((id)a1);
        __int16 v27 = sel_getName("_restartDiscoveryWithReconfig:");
        *(_DWORD *)id buf = 67109890;
        int v32 = v25;
        __int16 v33 = 2082;
        __int16 v34 = v26;
        __int16 v35 = 2082;
        __int16 v36 = v27;
        __int16 v37 = 1024;
        int v38 = 1421;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Stopping coalescing timer as restart discovery failed", buf, 0x22u);
      }

      [*(id *)(a1 + 120) stopTimer];
      [*(id *)(a1 + 104) unlock];
      return 0;
    }
  }
  return v15;
}

uint64_t sub_100215CAC(void *a1)
{
  if (!a1) {
    return 0;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(a1);
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(a1);
    uint64_t Name = sel_getName("resumeDiscovery");
    uint64_t v7 = 45;
    if (isMetaClass) {
      uint64_t v7 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i ", v7, ClassName, Name, 1443);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v8 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    id v9 = object_getClass(a1);
    if (class_isMetaClass(v9)) {
      int v10 = 43;
    }
    else {
      int v10 = 45;
    }
    *(_DWORD *)id buf = 67109890;
    int v16 = v10;
    __int16 v17 = 2082;
    __int16 v18 = object_getClassName(a1);
    __int16 v19 = 2082;
    BOOL v20 = sel_getName("resumeDiscovery");
    __int16 v21 = 1024;
    int v22 = 1443;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  uint64_t v11 = a1;
  objc_sync_enter(v11);
  if (v11[137]) {
    uint64_t v12 = 0;
  }
  else {
    uint64_t v12 = sub_100215914((uint64_t)v11);
  }
  objc_sync_exit(v11);

  return v12;
}

void sub_100215E78(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_100215E94(void *a1)
{
  if (a1)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(a1);
      uint64_t Name = sel_getName("getDieID");
      uint64_t v7 = 45;
      if (isMetaClass) {
        uint64_t v7 = 43;
      }
      v3(6, "%c[%{public}s %{public}s]:%i ", v7, ClassName, Name, 1455);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v8 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      id v9 = object_getClass(a1);
      if (class_isMetaClass(v9)) {
        int v10 = 43;
      }
      else {
        int v10 = 45;
      }
      *(_DWORD *)id buf = 67109890;
      *(_DWORD *)&uint8_t buf[4] = v10;
      __int16 v19 = 2082;
      BOOL v20 = object_getClassName(a1);
      __int16 v21 = 2082;
      int v22 = sel_getName("getDieID");
      __int16 v23 = 1024;
      int v24 = 1455;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
    }

    uint64_t v11 = a1;
    objc_sync_enter(v11);
    if (v11[137]
      || ((*(void *)buf = 0, DieID = NFDriverReadDieID(), *(void *)buf) ? (char v13 = DieID) : (char v13 = 0), (v13 & 1) == 0))
    {
      id v15 = 0;
    }
    else
    {
      id v14 = objc_alloc((Class)NSData);
      id v15 = [v14 initWithBytesNoCopy:*(void *)buf length:0];
    }
    objc_sync_exit(v11);
  }
  else
  {
    id v15 = 0;
  }

  return v15;
}

void sub_1002160A4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void *sub_1002160C0(void *a1, void *a2)
{
  if (a1)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      __int16 v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(a1);
      uint64_t Name = sel_getName("getUniqueFDRKey:");
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v5(6, "%c[%{public}s %{public}s]:%i ", v9, ClassName, Name, 1478);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = object_getClass(a1);
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      *(_DWORD *)id buf = 67109890;
      int v36 = v12;
      __int16 v37 = 2082;
      int v38 = object_getClassName(a1);
      __int16 v39 = 2082;
      BOOL v40 = sel_getName("getUniqueFDRKey:");
      __int16 v41 = 1024;
      int v42 = 1478;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
    }

    char v13 = a1;
    objc_sync_enter(v13);
    if (v13[137])
    {
      if (a2)
      {
        id v14 = objc_alloc((Class)NSError);
        id v15 = +[NSString stringWithUTF8String:"nfcd"];
        v33[0] = NSLocalizedDescriptionKey;
        int v16 = +[NSString stringWithUTF8String:"Aborted"];
        v34[0] = v16;
        v34[1] = &off_10031F9A8;
        v33[1] = @"Line";
        v33[2] = @"Method";
        id v17 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("getUniqueFDRKey:")];
        v34[2] = v17;
        v33[3] = NSDebugDescriptionErrorKey;
        id v18 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("getUniqueFDRKey:"), 1482];
        v34[3] = v18;
        __int16 v19 = +[NSDictionary dictionaryWithObjects:v34 forKeys:v33 count:4];
        *a2 = [v14 initWithDomain:v15 code:3 userInfo:v19];

LABEL_27:
        a2 = 0;
      }
    }
    else
    {
      if (a2) {
        *a2 = 0;
      }
      *(_DWORD *)id buf = 0;
      UniqueFDRKey = (void *)NFDriverGetUniqueFDRKey();
      if (UniqueFDRKey) {
        BOOL v21 = *(_DWORD *)buf == 0;
      }
      else {
        BOOL v21 = 0;
      }
      int v22 = !v21;
      if (a2 && v22)
      {
        id v23 = objc_alloc((Class)NSError);
        int v24 = +[NSString stringWithUTF8String:"nfcd"];
        v31[0] = NSLocalizedDescriptionKey;
        int v25 = +[NSString stringWithUTF8String:"Stack Error"];
        v32[0] = v25;
        v32[1] = &off_10031F9C0;
        v31[1] = @"Line";
        v31[2] = @"Method";
        id v26 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("getUniqueFDRKey:")];
        v32[2] = v26;
        v31[3] = NSDebugDescriptionErrorKey;
        id v27 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("getUniqueFDRKey:"), 1491];
        v32[3] = v27;
        __int16 v28 = +[NSDictionary dictionaryWithObjects:v32 forKeys:v31 count:4];
        *a2 = [v23 initWithDomain:v24 code:15 userInfo:v28];
      }
      if (!UniqueFDRKey) {
        goto LABEL_27;
      }
      a2 = [objc_alloc((Class)NSString) initWithUTF8String:UniqueFDRKey];
      free(UniqueFDRKey);
    }
    objc_sync_exit(v13);

    goto LABEL_29;
  }
  a2 = 0;
LABEL_29:

  return a2;
}

void sub_100216574(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_100216594(void *a1)
{
  if (a1)
  {
    id v1 = a1;
    objc_sync_enter(v1);
    if (v1[137]) {
      unsigned int v2 = 0;
    }
    else {
      unsigned int v2 = (void *)NFDriverCopyAndClearAssertion();
    }
    objc_sync_exit(v1);
  }
  else
  {
    unsigned int v2 = 0;
  }

  return v2;
}

void sub_100216604(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id *sub_100216618(id *result, unsigned char *a2, void *a3)
{
  if (result)
  {
    __int16 v5 = result;
    [result[13] lock];
    if (a2) {
      *a2 = *((unsigned char *)v5 + 176);
    }
    if (a3) {
      *a3 = v5[20];
    }
    id v6 = v5[13];
    return (id *)[v6 unlock];
  }
  return result;
}

id sub_100216688(void *a1)
{
  if (a1)
  {
    id v1 = a1;
    objc_sync_enter(v1);
    if (v1[137])
    {
      id v2 = objc_alloc((Class)NSError);
      ErrorCode = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
      int v4 = +[NSString stringWithUTF8String:"Aborted"];
      char v13 = v4;
      __int16 v5 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
      id v6 = [v2 initWithDomain:ErrorCode code:3 userInfo:v5];
    }
    else
    {
      if (!NFDriverGetSWIOTemperature())
      {
        id v6 = 0;
        goto LABEL_7;
      }
      ErrorCode = (void *)NFDriverCreateErrorCode();
      id v7 = objc_alloc((Class)NSError);
      int v4 = +[NSString stringWithUTF8String:"nfcd"];
      v10[0] = NSLocalizedDescriptionKey;
      __int16 v5 = +[NSString stringWithUTF8String:"Stack Error"];
      v10[1] = NSUnderlyingErrorKey;
      v11[0] = v5;
      v11[1] = ErrorCode;
      uint64_t v8 = +[NSDictionary dictionaryWithObjects:v11 forKeys:v10 count:2];
      id v6 = [v7 initWithDomain:v4 code:15 userInfo:v8];
    }
LABEL_7:
    objc_sync_exit(v1);

    goto LABEL_8;
  }
  id v6 = 0;
LABEL_8:

  return v6;
}

void sub_100216890(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1002168B4(id *a1, uint64_t a2)
{
  int v4 = _os_activity_create((void *)&_mh_execute_header, "NFCC hw reset", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  v5.opaque[0] = 0;
  v5.opaque[1] = 0;
  os_activity_scope_enter(v4, &v5);
  os_activity_scope_leave(&v5);

  if (a1)
  {
    if ((sub_10015CBB4(a1) & 1) == 0) {
      [a1[31] handleHardwareReset:a2];
    }
  }
}

void sub_100216940(uint64_t a1, void *a2)
{
  int v4 = _os_activity_create((void *)&_mh_execute_header, "NFCC SE aid select", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  v9.opaque[0] = 0;
  v9.opaque[1] = 0;
  os_activity_scope_enter(v4, &v9);
  os_activity_scope_leave(&v9);

  id v5 = [objc_alloc((Class)NSData) initWithBytes:*a2 length:a2[1]];
  if (a1)
  {
    id v6 = *(id *)(a1 + 248);
    id v7 = v5;
    uint64_t v8 = [v7 NF_asHexString];
    [v6 handleSelectEvent:v8];
  }
}

void sub_100216A08(uint64_t a1, void *a2, void *a3)
{
  id v6 = _os_activity_create((void *)&_mh_execute_header, "NFCC SE txn", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  *(void *)os_activity_scope_state_s state = 0;
  *(void *)&state[8] = 0;
  os_activity_scope_enter(v6, (os_activity_scope_state_t)state);
  os_activity_scope_leave((os_activity_scope_state_t)state);

  if (a2) {
    a2 = [objc_alloc((Class)NSData) initWithBytes:*a2 length:a2[1]];
  }
  if (a3) {
    id v7 = [objc_alloc((Class)NSData) initWithBytes:*a3 length:a3[1]];
  }
  else {
    id v7 = 0;
  }
  uint64_t v8 = a2;
  id v9 = v7;
  int v10 = v9;
  if (a1)
  {
    if ([v9 length] == (id)2)
    {
      uint64_t v11 = (unsigned __int8 *)[v10 bytes];
      int v12 = *v11;
      int v13 = v11[1];
      if ((v13 - 12) < 0xFFFFFFFE || (v12 - 5) <= 0xFFFFFFFD)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (Logger) {
          Logger(3, "%s:%i Unexpected eventID=0x%x, eventType=0x%x", "ExtractProhibitTimerEvent", 113, v13, v12);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v18 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)os_activity_scope_state_s state = 136446978;
          *(void *)&state[4] = "ExtractProhibitTimerEvent";
          *(_WORD *)&state[12] = 1024;
          *(_DWORD *)&state[14] = 113;
          __int16 v34 = 1024;
          *(_DWORD *)__int16 v35 = v13;
          *(_WORD *)&v35[4] = 1024;
          *(_DWORD *)&v35[6] = v12;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "%{public}s:%i Unexpected eventID=0x%x, eventType=0x%x", state, 0x1Eu);
        }
      }
      else
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v14 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v12 == 3)
        {
          if (v13 == 11)
          {
            if (v14) {
              v14(5, "%s:%i ProhibitTimer.Host.Start", "ExtractProhibitTimerEvent", 121);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            id v15 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)os_activity_scope_state_s state = 136446466;
              *(void *)&state[4] = "ExtractProhibitTimerEvent";
              *(_WORD *)&state[12] = 1024;
              *(_DWORD *)&state[14] = 121;
              _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%{public}s:%i ProhibitTimer.Host.Start", state, 0x12u);
            }
            uint64_t v16 = 2;
          }
          else
          {
            if (v14) {
              v14(5, "%s:%i ProhibitTimer.SE.Start", "ExtractProhibitTimerEvent", 124);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            id v15 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)os_activity_scope_state_s state = 136446466;
              *(void *)&state[4] = "ExtractProhibitTimerEvent";
              *(_WORD *)&state[12] = 1024;
              *(_DWORD *)&state[14] = 124;
              _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%{public}s:%i ProhibitTimer.SE.Start", state, 0x12u);
            }
            uint64_t v16 = 0;
          }
        }
        else if (v13 == 11)
        {
          if (v14) {
            v14(5, "%s:%i ProhibitTimer.Host.End", "ExtractProhibitTimerEvent", 129);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v15 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)os_activity_scope_state_s state = 136446466;
            *(void *)&state[4] = "ExtractProhibitTimerEvent";
            *(_WORD *)&state[12] = 1024;
            *(_DWORD *)&state[14] = 129;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%{public}s:%i ProhibitTimer.Host.End", state, 0x12u);
          }
          uint64_t v16 = 3;
        }
        else
        {
          if (v14) {
            v14(5, "%s:%i ProhibitTimer.SE.End", "ExtractProhibitTimerEvent", 132);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v15 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)os_activity_scope_state_s state = 136446466;
            *(void *)&state[4] = "ExtractProhibitTimerEvent";
            *(_WORD *)&state[12] = 1024;
            *(_DWORD *)&state[14] = 132;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%{public}s:%i ProhibitTimer.SE.End", state, 0x12u);
          }
          uint64_t v16 = 1;
        }

        [*(id *)(a1 + 248) handleReaderModeProhibitTimerEvent:v16];
      }
    }
    id v19 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284498 length:9];
    unsigned __int8 v20 = [v8 isEqual:v19];

    if ((v20 & 1) != 0 || !*(unsigned char *)(a1 + 221))
    {
      [*(id *)(a1 + 256) decodeSecureElementTransaction:v8 event:v10];
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v21 = NFLogGetLogger();
      if (v21)
      {
        int v22 = (void (*)(uint64_t, const char *, ...))v21;
        Class = object_getClass((id)a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        Classuint64_t Name = object_getClassName((id)a1);
        uint64_t Name = sel_getName("driverSecureElementTransaction:event:");
        uint64_t v26 = 45;
        if (isMetaClass) {
          uint64_t v26 = 43;
        }
        v22(6, "%c[%{public}s %{public}s]:%i Routing SE transaction event to active session", v26, ClassName, Name, 812);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v27 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v28 = object_getClass((id)a1);
        if (class_isMetaClass(v28)) {
          int v29 = 43;
        }
        else {
          int v29 = 45;
        }
        __int16 v30 = object_getClassName((id)a1);
        int v31 = sel_getName("driverSecureElementTransaction:event:");
        *(_DWORD *)os_activity_scope_state_s state = 67109890;
        *(_DWORD *)&state[4] = v29;
        *(_WORD *)&state[8] = 2082;
        *(void *)&state[10] = v30;
        __int16 v34 = 2082;
        *(void *)__int16 v35 = v31;
        *(_WORD *)&v35[8] = 1024;
        int v36 = 812;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Routing SE transaction event to active session", state, 0x22u);
      }

      [*(id *)(a1 + 248) handleSecureElementTransactionData:v10 appletIdentifier:v8];
    }
  }
}

void sub_10021702C(uint64_t a1, uint64_t a2, unsigned int a3)
{
  id v6 = _os_activity_create((void *)&_mh_execute_header, "NFCC SE restricted mode enter", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  v7.opaque[0] = 0;
  v7.opaque[1] = 0;
  os_activity_scope_enter(v6, &v7);
  os_activity_scope_leave(&v7);

  if (a1) {
    [*(id *)(a1 + 248) handleSecureElementEnteredRestrictedMode:a2 os:a3];
  }
}

void sub_1002170B4(uint64_t a1, uint64_t a2, unsigned int a3)
{
  id v6 = _os_activity_create((void *)&_mh_execute_header, "NFCC SE restricted mode exit", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  v7.opaque[0] = 0;
  v7.opaque[1] = 0;
  os_activity_scope_enter(v6, &v7);
  os_activity_scope_leave(&v7);

  if (a1) {
    [*(id *)(a1 + 248) handleSecureElementEnteredRestrictedModeExit:a2 os:a3];
  }
}

void sub_10021713C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v6 = _os_activity_create((void *)&_mh_execute_header, "NFCC SE removed", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  v7.opaque[0] = 0;
  v7.opaque[1] = 0;
  os_activity_scope_enter(v6, &v7);
  os_activity_scope_leave(&v7);

  if (a1)
  {
    [*(id *)(a1 + 248) handleSecureElementRemoved:a2 withReason:a3];
    if (a3 == 33)
    {
      sub_100198FF8((uint64_t)NFBugCapture, @"Secure Element crashed", @"Secure Element crashed. Reason: 0x21", 0);
      +[NFExceptionsCALogger postAnalyticsSEFailureEvent:1 context:@"Secure Element crashed. Reason: 0x21" error:0];
    }
  }
}

void sub_100217208(uint64_t a1, unsigned int a2, uint64_t a3)
{
  id v6 = _os_activity_create((void *)&_mh_execute_header, "NFCC SE OS reset", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  v7.opaque[0] = 0;
  v7.opaque[1] = 0;
  os_activity_scope_enter(v6, &v7);
  os_activity_scope_leave(&v7);

  if (a1) {
    [*(id *)(a1 + 248) handleSecureElementOSReset:a2 withReason:a3];
  }
}

void sub_100217290(id *a1, uint64_t a2)
{
  int v4 = _os_activity_create((void *)&_mh_execute_header, "NFCC HCE dev detected", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  v8.opaque[0] = 0;
  v8.opaque[1] = 0;
  os_activity_scope_enter(v4, &v8);
  os_activity_scope_leave(&v8);

  if (a1)
  {
    id v5 = objc_opt_new();
    os_activity_scope_state_s v7 = v5;
    if (v5)
    {
      objc_setProperty_atomic(v5, v6, a1, 8);
      v7[2] = a2;
    }
    [a1[33] handleHostCardReaderDetected:v7];
  }
}

void sub_10021733C(uint64_t a1, unsigned int a2, unsigned __int8 *a3, unsigned int a4)
{
  os_activity_scope_state_s v8 = _os_activity_create((void *)&_mh_execute_header, "NFCC RF tech ntf", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  *(void *)os_activity_scope_state_s state = 0;
  *(void *)&state[8] = 0;
  os_activity_scope_enter(v8, (os_activity_scope_state_t)state);
  os_activity_scope_leave((os_activity_scope_state_t)state);

  id v9 = sub_100219F78((id *)a1, a2, a3, a4, 0);
  int v10 = v9;
  if (v9)
  {
    id v11 = v9;
    if (a1)
    {
      if (*(unsigned char *)(a1 + 137))
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          int v13 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass((id)a1);
          BOOL isMetaClass = class_isMetaClass(Class);
          Classuint64_t Name = object_getClassName((id)a1);
          uint64_t Name = sel_getName("driverDidReceiveTechnologyEvent:");
          uint64_t v17 = 45;
          if (isMetaClass) {
            uint64_t v17 = 43;
          }
          v13(3, "%c[%{public}s %{public}s]:%i Driver session is closed", v17, ClassName, Name, 761);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v18 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
        {
          id v19 = object_getClass((id)a1);
          if (class_isMetaClass(v19)) {
            int v20 = 43;
          }
          else {
            int v20 = 45;
          }
          uint64_t v21 = object_getClassName((id)a1);
          int v22 = sel_getName("driverDidReceiveTechnologyEvent:");
          *(_DWORD *)os_activity_scope_state_s state = 67109890;
          *(_DWORD *)&state[4] = v20;
          *(_WORD *)&state[8] = 2082;
          *(void *)&state[10] = v21;
          __int16 v25 = 2082;
          uint64_t v26 = v22;
          __int16 v27 = 1024;
          int v28 = 761;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Driver session is closed", state, 0x22u);
        }
      }
      else
      {
        [*(id *)(a1 + 104) lock];
        objc_storeStrong((id *)(a1 + 160), v10);
        if (*(unsigned char *)(a1 + 136))
        {
          [*(id *)(a1 + 104) unlock];
          [*(id *)(a1 + 248) handleFilteredFieldNotification:*(void *)(a1 + 160)];
        }
        else
        {
          *(unsigned char *)(a1 + 136) = 1;
          [*(id *)(a1 + 104) unlock];
          [*(id *)(a1 + 248) handleFieldNotification:*(void *)(a1 + 160)];
        }
      }
    }
  }
}

void sub_1002175A4(uint64_t a1)
{
  id v2 = _os_activity_create((void *)&_mh_execute_header, "NFCC SE end of operation", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  v3.opaque[0] = 0;
  v3.opaque[1] = 0;
  os_activity_scope_enter(v2, &v3);
  os_activity_scope_leave(&v3);

  if (a1)
  {
    *(unsigned char *)(a1 + 216) = 1;
    [*(id *)(a1 + 248) handleSecureElementEndOfOperation];
  }
}

void sub_10021761C(uint64_t a1)
{
  id v2 = _os_activity_create((void *)&_mh_execute_header, "NFCC SE RAPDU sent", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  v3.opaque[0] = 0;
  v3.opaque[1] = 0;
  os_activity_scope_enter(v2, &v3);
  os_activity_scope_leave(&v3);

  if (a1) {
    *(unsigned char *)(a1 + 217) = 1;
  }
}

void sub_10021768C(uint64_t a1)
{
  id v2 = _os_activity_create((void *)&_mh_execute_header, "NFCC PLL unlocked", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  v3.opaque[0] = 0;
  v3.opaque[1] = 0;
  os_activity_scope_enter(v2, &v3);
  os_activity_scope_leave(&v3);

  if (a1) {
    sub_100223B0C((uint64_t)NFDailyStatisticsCALogger, @"pllUnlock");
  }
}

void sub_100217708(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  if (a3) {
    os_activity_scope_state_s v8 = "NFCC tags detected";
  }
  else {
    os_activity_scope_state_s v8 = "NFCC 0 tag detected";
  }
  id v9 = _os_activity_create((void *)&_mh_execute_header, v8, (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  v10.opaque[0] = 0;
  v10.opaque[1] = 0;
  os_activity_scope_enter(v9, &v10);
  os_activity_scope_leave(&v10);

  sub_100197388(a1, a2, a3, a4);
}

void sub_1002177AC(uint64_t a1)
{
  id v2 = _os_activity_create((void *)&_mh_execute_header, "NFCC express txn", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  v3.opaque[0] = 0;
  v3.opaque[1] = 0;
  os_activity_scope_enter(v2, &v3);
  os_activity_scope_leave(&v3);

  if (a1) {
    [*(id *)(a1 + 264) driverExpressModeExited];
  }
}

void sub_10021781C(uint64_t a1, uint64_t a2, unsigned int a3)
{
  id v6 = _os_activity_create((void *)&_mh_execute_header, "NFCC typeF request service ntf", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  v8.opaque[0] = 0;
  v8.opaque[1] = 0;
  os_activity_scope_enter(v6, &v8);
  os_activity_scope_leave(&v8);

  if (a2)
  {
    id v7 = [objc_alloc((Class)NSData) initWithBytes:a2 length:a3];
    sub_10021285C(a1, v7);
  }
  else
  {
    sub_10021285C(a1, 0);
  }
}

void sub_1002178D0(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  os_activity_scope_state_s v10 = _os_activity_create((void *)&_mh_execute_header, "NFCC RSSI ntf", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  v11.opaque[0] = 0;
  v11.opaque[1] = 0;
  os_activity_scope_enter(v10, &v11);
  os_activity_scope_leave(&v11);

  if (a1) {
    [*(id *)(a1 + 256) driverRSSIStatsWithTotalSamples:a2 avgRSSI:a3 maxRSSI:a4 minRSSI:a5];
  }
}

void sub_100217970(void *a1, uint64_t a2, unsigned int a3, unsigned __int8 *a4, unsigned int a5)
{
  os_activity_scope_state_s v10 = _os_activity_create((void *)&_mh_execute_header, "NFCC express txn/w RF", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  *(void *)os_activity_scope_state_s state = 0;
  *(void *)&state[8] = 0;
  os_activity_scope_enter(v10, (os_activity_scope_state_t)state);
  os_activity_scope_leave((os_activity_scope_state_t)state);

  os_activity_scope_state_s v11 = a1;
  int v12 = sub_100219F78(v11, a3, a4, a5, 1);
  int v13 = v12;
  if (v12)
  {
    id v14 = v12;
    if (v11)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        uint64_t v16 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(v11);
        BOOL isMetaClass = class_isMetaClass(Class);
        Classuint64_t Name = object_getClassName(v11);
        uint64_t Name = sel_getName("driverDidReceiveExpressStartRfTech:withNotification:");
        uint64_t v20 = 45;
        if (isMetaClass) {
          uint64_t v20 = 43;
        }
        v16(6, "%c[%{public}s %{public}s]:%i expressType: %d RfTech:%{public}@", v20, ClassName, Name, 705, a2, v14);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v21 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
      {
        int v22 = object_getClass(v11);
        if (class_isMetaClass(v22)) {
          int v23 = 43;
        }
        else {
          int v23 = 45;
        }
        int v24 = object_getClassName(v11);
        __int16 v25 = sel_getName("driverDidReceiveExpressStartRfTech:withNotification:");
        *(_DWORD *)os_activity_scope_state_s state = 67110402;
        *(_DWORD *)&state[4] = v23;
        *(_WORD *)&state[8] = 2082;
        *(void *)&state[10] = v24;
        __int16 v79 = 2082;
        BOOL v80 = v25;
        __int16 v81 = 1024;
        int v82 = 705;
        __int16 v83 = 1024;
        unsigned int v84 = a2;
        __int16 v85 = 2114;
        id v86 = v14;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i expressType: %d RfTech:%{public}@", state, 0x32u);
      }

      objc_storeStrong(v11 + 20, v13);
      switch((int)a2)
      {
        case 0:
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v26 = NFLogGetLogger();
          if (v26)
          {
            __int16 v27 = (void (*)(uint64_t, const char *, ...))v26;
            int v28 = object_getClass(v11);
            BOOL v29 = class_isMetaClass(v28);
            __int16 v30 = object_getClassName(v11);
            __int16 v74 = sel_getName("driverDidReceiveExpressStartRfTech:withNotification:");
            uint64_t v31 = 45;
            if (v29) {
              uint64_t v31 = 43;
            }
            v27(4, "%c[%{public}s %{public}s]:%i Ignoring Express type None", v31, v30, v74, 741);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          int v32 = NFSharedLogGetLogger();
          if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
            goto LABEL_35;
          }
          __int16 v33 = object_getClass(v11);
          if (class_isMetaClass(v33)) {
            int v34 = 43;
          }
          else {
            int v34 = 45;
          }
          __int16 v35 = object_getClassName(v11);
          int v36 = sel_getName("driverDidReceiveExpressStartRfTech:withNotification:");
          *(_DWORD *)os_activity_scope_state_s state = 67109890;
          *(_DWORD *)&state[4] = v34;
          *(_WORD *)&state[8] = 2082;
          *(void *)&state[10] = v35;
          __int16 v79 = 2082;
          BOOL v80 = v36;
          __int16 v81 = 1024;
          int v82 = 741;
          __int16 v37 = "%c[%{public}s %{public}s]:%i Ignoring Express type None";
          goto LABEL_33;
        case 1:
          if ([v14 typeFSystemCode] == 768)
          {
            uint64_t v38 = 1;
            goto LABEL_45;
          }
          if ([v14 typeFSystemCode] == 2176)
          {
            uint64_t v38 = 5;
            goto LABEL_45;
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v51 = NFLogGetLogger();
          if (v51)
          {
            uint64_t v52 = (void (*)(uint64_t, const char *, ...))v51;
            uint64_t v53 = object_getClass(v11);
            BOOL v54 = class_isMetaClass(v53);
            __int16 v55 = object_getClassName(v11);
            CFStringRef v56 = sel_getName("driverDidReceiveExpressStartRfTech:withNotification:");
            uint64_t v77 = [v14 typeFSystemCode];
            uint64_t v57 = 45;
            if (v54) {
              uint64_t v57 = 43;
            }
            v52(4, "%c[%{public}s %{public}s]:%i Type-F express entered for unknown system code 0x%x?", v57, v55, v56, 723, v77);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          int v32 = NFSharedLogGetLogger();
          if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
            goto LABEL_35;
          }
          int v58 = object_getClass(v11);
          if (class_isMetaClass(v58)) {
            int v59 = 43;
          }
          else {
            int v59 = 45;
          }
          int v60 = object_getClassName(v11);
          id v61 = sel_getName("driverDidReceiveExpressStartRfTech:withNotification:");
          unsigned int v62 = [v14 typeFSystemCode];
          *(_DWORD *)os_activity_scope_state_s state = 67110146;
          *(_DWORD *)&state[4] = v59;
          *(_WORD *)&state[8] = 2082;
          *(void *)&state[10] = v60;
          __int16 v79 = 2082;
          BOOL v80 = v61;
          __int16 v81 = 1024;
          int v82 = 723;
          __int16 v83 = 1024;
          unsigned int v84 = v62;
          __int16 v37 = "%c[%{public}s %{public}s]:%i Type-F express entered for unknown system code 0x%x?";
          int v49 = v32;
          uint32_t v50 = 40;
          goto LABEL_34;
        case 2:
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            uint64_t v38 = 4;
            goto LABEL_45;
          }
          objc_opt_class();
          if (objc_opt_isKindOfClass())
          {
            uint64_t v38 = 2;
            goto LABEL_45;
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v63 = NFLogGetLogger();
          if (v63)
          {
            id v64 = (void (*)(uint64_t, const char *, ...))v63;
            id v65 = object_getClass(v11);
            BOOL v66 = class_isMetaClass(v65);
            int v67 = object_getClassName(v11);
            int v76 = sel_getName("driverDidReceiveExpressStartRfTech:withNotification:");
            uint64_t v68 = 45;
            if (v66) {
              uint64_t v68 = 43;
            }
            v64(4, "%c[%{public}s %{public}s]:%i VAS express entered but field is non-ECP?", v68, v67, v76, 737);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          int v32 = NFSharedLogGetLogger();
          if (!os_log_type_enabled(v32, OS_LOG_TYPE_ERROR)) {
            goto LABEL_35;
          }
          id v69 = object_getClass(v11);
          if (class_isMetaClass(v69)) {
            int v70 = 43;
          }
          else {
            int v70 = 45;
          }
          uint64_t v71 = object_getClassName(v11);
          id v72 = sel_getName("driverDidReceiveExpressStartRfTech:withNotification:");
          *(_DWORD *)os_activity_scope_state_s state = 67109890;
          *(_DWORD *)&state[4] = v70;
          *(_WORD *)&state[8] = 2082;
          *(void *)&state[10] = v71;
          __int16 v79 = 2082;
          BOOL v80 = v72;
          __int16 v81 = 1024;
          int v82 = 737;
          __int16 v37 = "%c[%{public}s %{public}s]:%i VAS express entered but field is non-ECP?";
          goto LABEL_33;
        case 3:
          goto LABEL_24;
        case 4:
          uint64_t v38 = 3;
          goto LABEL_45;
        default:
          if (a2 == 32)
          {
            uint64_t v38 = 6;
LABEL_45:
            [v11[33] driverExpressModeEntered:v38];
          }
          else
          {
LABEL_24:
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v39 = NFLogGetLogger();
            if (v39)
            {
              BOOL v40 = (void (*)(uint64_t, const char *, ...))v39;
              __int16 v41 = object_getClass(v11);
              BOOL v42 = class_isMetaClass(v41);
              id v43 = object_getClassName(v11);
              uint64_t v75 = sel_getName("driverDidReceiveExpressStartRfTech:withNotification:");
              uint64_t v44 = 45;
              if (v42) {
                uint64_t v44 = 43;
              }
              v40(4, "%c[%{public}s %{public}s]:%i Unknown express type", v44, v43, v75, 744);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            int v32 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
            {
              id v45 = object_getClass(v11);
              if (class_isMetaClass(v45)) {
                int v46 = 43;
              }
              else {
                int v46 = 45;
              }
              unsigned int v47 = object_getClassName(v11);
              int v48 = sel_getName("driverDidReceiveExpressStartRfTech:withNotification:");
              *(_DWORD *)os_activity_scope_state_s state = 67109890;
              *(_DWORD *)&state[4] = v46;
              *(_WORD *)&state[8] = 2082;
              *(void *)&state[10] = v47;
              __int16 v79 = 2082;
              BOOL v80 = v48;
              __int16 v81 = 1024;
              int v82 = 744;
              __int16 v37 = "%c[%{public}s %{public}s]:%i Unknown express type";
LABEL_33:
              int v49 = v32;
              uint32_t v50 = 34;
LABEL_34:
              _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, v37, state, v50);
            }
LABEL_35:
          }
          break;
      }
    }
  }
}

void sub_1002180C8(uint64_t a1, int a2, int a3)
{
  if (!a1) {
    return;
  }
  if (a3)
  {
    if (a2 == 3)
    {
      id v5 = *(void **)(a1 + 88);
      uint64_t v6 = 0;
      goto LABEL_26;
    }
    if (a2 == 2)
    {
      [*(id *)(a1 + 128) startTimer:5.0];
      if (([*(id *)(a1 + 200) wantsReader] & 1) != 0
        || [*(id *)(a1 + 200) wantsSEReader])
      {
        id v5 = *(void **)(a1 + 88);
        uint64_t v6 = 4;
LABEL_26:
        [v5 thermalStateChanged:v6];
        return;
      }
    }
  }
  id v7 = +[NSDate now];
  os_activity_scope_state_s v8 = +[NSUserDefaults standardUserDefaults];
  uint64_t v9 = (uint64_t)[v8 integerForKey:@"lowTemperatureCount"];
  os_activity_scope_state_s v10 = [v8 objectForKey:@"lastLowTemperatureDate"];
  if (!v10) {
    goto LABEL_12;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0) {
    goto LABEL_12;
  }
  id v11 = v10;
  [v7 timeIntervalSinceDate:v11];
  if (v12 < 0.0)
  {

LABEL_12:
    id v11 = 0;
  }
  [v8 setInteger:v9 + 1 forKey:@"lowTemperatureCount"];
  [v8 setObject:v7 forKey:@"lastLowTemperatureDate"];
  [v8 synchronize];
  if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT))
  {
    *(_WORD *)id v15 = 0;
    _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT, "NFC Controller low temp", v15, 2u);
  }
  if (a2 == 5) {
    int v13 = &off_100323690;
  }
  else {
    int v13 = &off_1003236B8;
  }
  +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:v13];
  if (NFIsInternalBuild())
  {
    sub_100198FF8((uint64_t)NFBugCapture, @"NFC controller Low Temp", @"NFC controller low temp", 0);
    +[NFExceptionsCALogger postAnalyticsSEFailureEvent:2 context:@"NFC controller low temp" error:0];
  }
  else if (v9 < 9 || v11 && ([v7 timeIntervalSinceDate:v11], v14 > 30.0))
  {
    sleep(1u);
    exit(-1);
  }
}

uint64_t sub_100218330(void *a1, void *a2)
{
  id v3 = [objc_alloc((Class)NSData) initWithBytes:*a2 length:a2[1]];
  id v4 = v3;
  if (a1)
  {
    id v6 = v3;
    sub_1001EBC94(a1, v3);
    id v4 = v6;
  }

  return _objc_release_x1(v3, v4);
}

void sub_100218398(uint64_t a1, int a2, int a3, int a4)
{
  if (a2)
  {
    if (a4) {
      os_activity_scope_state_s v8 = "NFCC SE reader started (ISODEP)";
    }
    else {
      os_activity_scope_state_s v8 = "NFCC SE reader started";
    }
  }
  else if (a4)
  {
    os_activity_scope_state_s v8 = "NFCC SE reader stopped (ISODEP)";
  }
  else
  {
    os_activity_scope_state_s v8 = "NFCC SE reader stopped";
  }
  uint64_t v9 = _os_activity_create((void *)&_mh_execute_header, v8, (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  os_activity_scope_state_s state = 0;
  *(void *)state_8 = 0;
  os_activity_scope_enter(v9, (os_activity_scope_state_t)&state);
  os_activity_scope_leave((os_activity_scope_state_t)&state);

  if (a1)
  {
    CFStringRef v10 = @"B";
    if (a3 != 2) {
      CFStringRef v10 = @"Unknown";
    }
    if (a3 == 1) {
      CFStringRef v10 = @"A";
    }
    v85[0] = @"Polling";
    v85[1] = @"Protocol";
    CFStringRef v11 = @"isoDep";
    if (!a4) {
      CFStringRef v11 = @"Unknown";
    }
    v86[0] = v10;
    v86[1] = v11;
    double v12 = +[NSDictionary dictionaryWithObjects:v86 forKeys:v85 count:2];
    if (a2)
    {
      if (a3)
      {
        *(unsigned char *)(a1 + 64) = 1;
        if (*(unsigned char *)(*(void *)(a1 + 40) + 62))
        {
          unsigned int v13 = [*(id *)(a1 + 88) readerModeProtectionActive];
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t Logger = NFLogGetLogger();
          id v15 = (void (*)(uint64_t, const char *, ...))Logger;
          if (v13)
          {
            if (Logger)
            {
              Class = object_getClass((id)a1);
              BOOL isMetaClass = class_isMetaClass(Class);
              Classuint64_t Name = object_getClassName((id)a1);
              uint64_t Name = sel_getName("driverSecureElementReaderMode:polling:isoDep:");
              uint64_t v19 = 45;
              if (isMetaClass) {
                uint64_t v19 = 43;
              }
              v15(6, "%c[%{public}s %{public}s]:%i Request to start eSE reader mode while thermal protection active. Dropping.", v19, ClassName, Name, 914);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v20 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v21 = object_getClass((id)a1);
              if (class_isMetaClass(v21)) {
                int v22 = 43;
              }
              else {
                int v22 = 45;
              }
              int v23 = object_getClassName((id)a1);
              int v24 = sel_getName("driverSecureElementReaderMode:polling:isoDep:");
              LODWORD(state) = 67109890;
              HIDWORD(state) = v22;
              *(_WORD *)state_8 = 2082;
              *(void *)&state_8[2] = v23;
              *(_WORD *)&state_8[10] = 2082;
              *(void *)&state_8[12] = v24;
              *(_WORD *)&state_8[20] = 1024;
              *(_DWORD *)&state_8[22] = 914;
              _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Request to start eSE reader mode while thermal protection active. Dropping.", (uint8_t *)&state, 0x22u);
            }

            CFStringRef v81 = @"Error";
            id v25 = objc_alloc((Class)NSError);
            uint64_t v26 = +[NSString stringWithUTF8String:"nfcd"];
            v80[0] = NSLocalizedDescriptionKey;
            __int16 v27 = +[NSString stringWithUTF8String:"Reader mode temporarily disabled"];
            os_activity_scope_state_s state = v27;
            *(void *)state_8 = &off_10031F918;
            v80[1] = @"Line";
            v80[2] = @"Method";
            id v28 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("driverSecureElementReaderMode:polling:isoDep:")];
            *(void *)&state_8[8] = v28;
            v80[3] = NSDebugDescriptionErrorKey;
            id v29 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("driverSecureElementReaderMode:polling:isoDep:"), 916];
            *(void *)&state_8[16] = v29;
            __int16 v30 = +[NSDictionary dictionaryWithObjects:&state forKeys:v80 count:4];
            id v31 = [v25 initWithDomain:v26 code:47 userInfo:v30];
            id v82 = v31;
            uint64_t v32 = +[NSDictionary dictionaryWithObjects:&v82 forKeys:&v81 count:1];

            double v12 = (void *)v32;
          }
          else
          {
            if (Logger)
            {
              BOOL v66 = object_getClass((id)a1);
              BOOL v67 = class_isMetaClass(v66);
              uint64_t v68 = object_getClassName((id)a1);
              __int16 v79 = sel_getName("driverSecureElementReaderMode:polling:isoDep:");
              uint64_t v69 = 45;
              if (v67) {
                uint64_t v69 = 43;
              }
              v15(6, "%c[%{public}s %{public}s]:%i Starting RF reader", v69, v68, v79, 919);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            int v70 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v71 = object_getClass((id)a1);
              if (class_isMetaClass(v71)) {
                int v72 = 43;
              }
              else {
                int v72 = 45;
              }
              int v73 = object_getClassName((id)a1);
              __int16 v74 = sel_getName("driverSecureElementReaderMode:polling:isoDep:");
              LODWORD(state) = 67109890;
              HIDWORD(state) = v72;
              *(_WORD *)state_8 = 2082;
              *(void *)&state_8[2] = v73;
              *(_WORD *)&state_8[10] = 2082;
              *(void *)&state_8[12] = v74;
              *(_WORD *)&state_8[20] = 1024;
              *(_DWORD *)&state_8[22] = 919;
              _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Starting RF reader", (uint8_t *)&state, 0x22u);
            }

            sub_1002128B4((void *)a1);
          }
        }
        else
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v55 = NFLogGetLogger();
          if (v55)
          {
            CFStringRef v56 = (void (*)(uint64_t, const char *, ...))v55;
            uint64_t v57 = object_getClass((id)a1);
            BOOL v58 = class_isMetaClass(v57);
            int v59 = object_getClassName((id)a1);
            id v78 = sel_getName("driverSecureElementReaderMode:polling:isoDep:");
            uint64_t v60 = 45;
            if (v58) {
              uint64_t v60 = 43;
            }
            v56(6, "%c[%{public}s %{public}s]:%i Applet requested RF reader", v60, v59, v78, 923);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v61 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
          {
            unsigned int v62 = object_getClass((id)a1);
            if (class_isMetaClass(v62)) {
              int v63 = 43;
            }
            else {
              int v63 = 45;
            }
            id v64 = object_getClassName((id)a1);
            id v65 = sel_getName("driverSecureElementReaderMode:polling:isoDep:");
            LODWORD(state) = 67109890;
            HIDWORD(state) = v63;
            *(_WORD *)state_8 = 2082;
            *(void *)&state_8[2] = v64;
            *(_WORD *)&state_8[10] = 2082;
            *(void *)&state_8[12] = v65;
            *(_WORD *)&state_8[20] = 1024;
            *(_DWORD *)&state_8[22] = 923;
            _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Applet requested RF reader", (uint8_t *)&state, 0x22u);
          }
        }
        [*(id *)(a1 + 248) handleSecureElementReaderModeStarted:v12];
      }
      else
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v44 = NFLogGetLogger();
        if (v44)
        {
          id v45 = (void (*)(uint64_t, const char *, ...))v44;
          int v46 = object_getClass((id)a1);
          BOOL v47 = class_isMetaClass(v46);
          int v48 = object_getClassName((id)a1);
          uint64_t v77 = sel_getName("driverSecureElementReaderMode:polling:isoDep:");
          uint64_t v49 = 45;
          if (v47) {
            uint64_t v49 = 43;
          }
          v45(6, "%c[%{public}s %{public}s]:%i SE reader ready", v49, v48, v77, 907);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint32_t v50 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v51 = object_getClass((id)a1);
          if (class_isMetaClass(v51)) {
            int v52 = 43;
          }
          else {
            int v52 = 45;
          }
          uint64_t v53 = object_getClassName((id)a1);
          BOOL v54 = sel_getName("driverSecureElementReaderMode:polling:isoDep:");
          LODWORD(state) = 67109890;
          HIDWORD(state) = v52;
          *(_WORD *)state_8 = 2082;
          *(void *)&state_8[2] = v53;
          *(_WORD *)&state_8[10] = 2082;
          *(void *)&state_8[12] = v54;
          *(_WORD *)&state_8[20] = 1024;
          *(_DWORD *)&state_8[22] = 907;
          _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i SE reader ready", (uint8_t *)&state, 0x22u);
        }
      }
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v33 = NFLogGetLogger();
      if (v33)
      {
        int v34 = (void (*)(uint64_t, const char *, ...))v33;
        __int16 v35 = object_getClass((id)a1);
        BOOL v36 = class_isMetaClass(v35);
        __int16 v37 = object_getClassName((id)a1);
        int v76 = sel_getName("driverSecureElementReaderMode:polling:isoDep:");
        uint64_t v38 = 45;
        if (v36) {
          uint64_t v38 = 43;
        }
        v34(6, "%c[%{public}s %{public}s]:%i Ended reader mode", v38, v37, v76, 929);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v39 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        BOOL v40 = object_getClass((id)a1);
        if (class_isMetaClass(v40)) {
          int v41 = 43;
        }
        else {
          int v41 = 45;
        }
        BOOL v42 = object_getClassName((id)a1);
        id v43 = sel_getName("driverSecureElementReaderMode:polling:isoDep:");
        LODWORD(state) = 67109890;
        HIDWORD(state) = v41;
        *(_WORD *)state_8 = 2082;
        *(void *)&state_8[2] = v42;
        *(_WORD *)&state_8[10] = 2082;
        *(void *)&state_8[12] = v43;
        *(_WORD *)&state_8[20] = 1024;
        *(_DWORD *)&state_8[22] = 929;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Ended reader mode", (uint8_t *)&state, 0x22u);
      }

      *(unsigned char *)(a1 + 64) = 0;
      [*(id *)(a1 + 248) handleSecureElementReaderModeEnded:v12];
    }
  }
}

void sub_100218C2C(uint64_t a1)
{
  id v2 = _os_activity_create((void *)&_mh_execute_header, "EMVCO field collision", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  v3.opaque[0] = 0;
  v3.opaque[1] = 0;
  os_activity_scope_enter(v2, &v3);
  os_activity_scope_leave(&v3);

  if (a1) {
    [*(id *)(a1 + 248) handleEMVCOCollisionDetected];
  }
}

void sub_100218C9C(uint64_t a1)
{
  id v2 = _os_activity_create((void *)&_mh_execute_header, "NFCC tag removed", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  v4.opaque[0] = 0;
  v4.opaque[1] = 0;
  os_activity_scope_enter(v2, &v4);
  os_activity_scope_leave(&v4);

  if (a1)
  {
    os_activity_scope_state_s v3 = *(NSObject **)(a1 + 48);
    if (v3) {
      dispatch_semaphore_signal(v3);
    }
  }
}

void sub_100218D10(uint64_t a1)
{
  id v2 = _os_activity_create((void *)&_mh_execute_header, "NFCC HCE dev target lost", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  v3.opaque[0] = 0;
  v3.opaque[1] = 0;
  os_activity_scope_enter(v2, &v3);
  os_activity_scope_leave(&v3);

  sub_100197CC0(a1);
}

void sub_100218D7C(uint64_t a1)
{
  id v2 = _os_activity_create((void *)&_mh_execute_header, "TXLDO Error", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  v3.opaque[0] = 0;
  v3.opaque[1] = 0;
  os_activity_scope_enter(v2, &v3);
  os_activity_scope_leave(&v3);

  if (a1)
  {
    if (NFIsInternalBuild())
    {
      sub_100198FF8((uint64_t)NFBugCapture, @"LDO Error detected", @"LDO Error detected", 0);
      +[NFExceptionsCALogger postAnalyticsSEFailureEvent:3 context:@"LDO Error detected" error:0];
    }
  }
}

void sub_100218E24(uint64_t a1)
{
  id v2 = _os_activity_create((void *)&_mh_execute_header, "Erase counter exceeded", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  v3.opaque[0] = 0;
  v3.opaque[1] = 0;
  os_activity_scope_enter(v2, &v3);
  os_activity_scope_leave(&v3);

  if (a1) {
    [*(id *)(a1 + 248) handleEraseCounterExceeded];
  }
}

id sub_100218E94(void *a1)
{
  if (a1)
  {
    a1 = sub_10015B654(a1);
    uint64_t v1 = vars8;
  }
  return a1;
}

void *sub_100218EC4(void *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(a1);
      uint64_t Name = sel_getName("triggerHammerfestRecoveryAt:");
      uint64_t v10 = 45;
      if (isMetaClass) {
        uint64_t v10 = 43;
      }
      v5(6, "%c[%{public}s %{public}s]:%i triggering time %{public}@  last Fury recovery %{public}@", v10, ClassName, Name, 1627, v3, a1[36]);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    CFStringRef v11 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      double v12 = object_getClass(a1);
      if (class_isMetaClass(v12)) {
        int v13 = 43;
      }
      else {
        int v13 = 45;
      }
      double v14 = object_getClassName(a1);
      id v15 = sel_getName("triggerHammerfestRecoveryAt:");
      uint64_t v16 = a1[36];
      *(_DWORD *)id buf = 67110402;
      int v31 = v13;
      __int16 v32 = 2082;
      uint64_t v33 = v14;
      __int16 v34 = 2082;
      __int16 v35 = v15;
      __int16 v36 = 1024;
      int v37 = 1627;
      __int16 v38 = 2114;
      id v39 = v3;
      __int16 v40 = 2114;
      uint64_t v41 = v16;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i triggering time %{public}@  last Fury recovery %{public}@", buf, 0x36u);
    }

    if ([v3 compare:a1[36]] == (id)-1)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v17 = NFLogGetLogger();
      if (v17)
      {
        id v18 = (void (*)(uint64_t, const char *, ...))v17;
        uint64_t v19 = object_getClass(a1);
        BOOL v20 = class_isMetaClass(v19);
        uint64_t v21 = object_getClassName(a1);
        id v29 = sel_getName("triggerHammerfestRecoveryAt:");
        uint64_t v22 = 45;
        if (v20) {
          uint64_t v22 = 43;
        }
        v18(6, "%c[%{public}s %{public}s]:%i Just recovered recently - skip this one", v22, v21, v29, 1629);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v23 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        int v24 = object_getClass(a1);
        if (class_isMetaClass(v24)) {
          int v25 = 43;
        }
        else {
          int v25 = 45;
        }
        uint64_t v26 = object_getClassName(a1);
        __int16 v27 = sel_getName("triggerHammerfestRecoveryAt:");
        *(_DWORD *)id buf = 67109890;
        int v31 = v25;
        __int16 v32 = 2082;
        uint64_t v33 = v26;
        __int16 v34 = 2082;
        __int16 v35 = v27;
        __int16 v36 = 1024;
        int v37 = 1629;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Just recovered recently - skip this one", buf, 0x22u);
      }

      a1 = 0;
    }
    else
    {
      a1 = sub_10015B250(a1);
    }
  }

  return a1;
}

void sub_1002191D0(uint64_t a1)
{
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 40));
  id v3 = WeakRetained;
  if (WeakRetained && [WeakRetained[11] thermalPressureCritical])
  {
    os_activity_scope_state_s v4 = sub_100216688(v3);
    if (!v4)
    {
      uint64_t v6 = (uint64_t)v3[10];
      if (v6)
      {
        id v7 = sub_10000B254(v6, 0.0, v5);
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          uint64_t v9 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(*(id *)(a1 + 32));
          BOOL isMetaClass = class_isMetaClass(Class);
          Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
          uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
          uint64_t v13 = 45;
          if (isMetaClass) {
            uint64_t v13 = 43;
          }
          v9(6, "%c[%{public}s %{public}s]:%i Requesting temperature", v13, ClassName, Name, 1769);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        double v14 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          id v15 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v15)) {
            int v16 = 43;
          }
          else {
            int v16 = 45;
          }
          uint64_t v17 = object_getClassName(*(id *)(a1 + 32));
          id v18 = sel_getName(*(SEL *)(a1 + 48));
          *(_DWORD *)id buf = 67109890;
          int v21 = v16;
          __int16 v22 = 2082;
          int v23 = v17;
          __int16 v24 = 2082;
          int v25 = v18;
          __int16 v26 = 1024;
          int v27 = 1769;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Requesting temperature", buf, 0x22u);
        }
      }
    }
    [v3[16] startTimer:5.0];
  }
}

void sub_1002193BC(uint64_t a1, void *a2)
{
  if (a1)
  {
    id v3 = a2;
    os_activity_scope_state_s v4 = sub_100077710((id *)[NFThermalMonitor alloc], v3);

    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    id v9[2] = sub_1002194B8;
    unsigned char v9[3] = &unk_100301C40;
    v9[4] = a1;
    void v9[5] = "setPowerConsumptionMonitor:";
    sub_100077E6C((uint64_t)v4, v9);
    int ShouldUseLookbackRestrictor = NFPlatformShouldUseLookbackRestrictor();
    uint64_t v6 = &off_100300CB8;
    if (!ShouldUseLookbackRestrictor) {
      uint64_t v6 = off_100300CB0;
    }
    id v7 = [objc_alloc(*v6) initWithThermalMonitor:v4 delegate:a1];
    os_activity_scope_state_s v8 = *(void **)(a1 + 88);
    *(void *)(a1 + 88) = v7;
  }
}

void sub_1002194B8(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v7 = 45;
    if (isMetaClass) {
      uint64_t v7 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i Requesting temperature polling", v7, ClassName, Name, 1800);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  os_activity_scope_state_s v8 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v9)) {
      int v10 = 43;
    }
    else {
      int v10 = 45;
    }
    CFStringRef v11 = object_getClassName(*(id *)(a1 + 32));
    double v12 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)id buf = 67109890;
    int v16 = v10;
    __int16 v17 = 2082;
    id v18 = v11;
    __int16 v19 = 2082;
    BOOL v20 = v12;
    __int16 v21 = 1024;
    int v22 = 1800;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Requesting temperature polling", buf, 0x22u);
  }

  uint64_t v13 = *(void *)(a1 + 32);
  if (v13) {
    [*(id *)(v13 + 128) startTimer:5.0];
  }
}

id sub_100219648(uint64_t a1, char a2)
{
  if (!a1) {
    goto LABEL_4;
  }
  if (*(void *)(a1 + 40))
  {
    *(unsigned char *)(a1 + 222) = a2;
    NFDriverPreventReset();
LABEL_4:
    id v3 = 0;
    goto LABEL_15;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    float v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass((id)a1);
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName((id)a1);
    uint64_t Name = sel_getName("setPreventReset:");
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v5(3, "%c[%{public}s %{public}s]:%i No driver !", v9, ClassName, Name, 1887);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    CFStringRef v11 = object_getClass((id)a1);
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    *(_DWORD *)id buf = 67109890;
    int v24 = v12;
    __int16 v25 = 2082;
    __int16 v26 = object_getClassName((id)a1);
    __int16 v27 = 2082;
    id v28 = sel_getName("setPreventReset:");
    __int16 v29 = 1024;
    int v30 = 1887;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i No driver !", buf, 0x22u);
  }

  id v13 = objc_alloc((Class)NSError);
  double v14 = +[NSString stringWithUTF8String:"nfcd"];
  v21[0] = NSLocalizedDescriptionKey;
  id v15 = +[NSString stringWithUTF8String:"Invalid State"];
  v22[0] = v15;
  v22[1] = &off_10031FA80;
  v21[1] = @"Line";
  v21[2] = @"Method";
  id v16 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("setPreventReset:")];
  v22[2] = v16;
  v21[3] = NSDebugDescriptionErrorKey;
  id v17 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("setPreventReset:"), 1888];
  v22[3] = v17;
  id v18 = +[NSDictionary dictionaryWithObjects:v22 forKeys:v21 count:4];
  id v3 = [v13 initWithDomain:v14 code:12 userInfo:v18];

LABEL_15:

  return v3;
}

id sub_100219938(void *a1, unsigned char *a2)
{
  if (a1)
  {
    id v3 = a1;
    objc_sync_enter(v3);
    if (a2)
    {
      id v4 = 0;
      *a2 = NFDriverSupportsSecureTimersInOFF();
    }
    else
    {
      id v5 = objc_alloc((Class)NSError);
      uint64_t v6 = +[NSString stringWithUTF8String:"nfcd"];
      v12[0] = NSLocalizedDescriptionKey;
      uint64_t v7 = +[NSString stringWithUTF8String:"Invalid Parameter"];
      v13[0] = v7;
      v13[1] = &off_10031FAC8;
      v12[1] = @"Line";
      void v12[2] = @"Method";
      id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("supportsSecureTimersInOFF:")];
      void v13[2] = v8;
      void v12[3] = NSDebugDescriptionErrorKey;
      id v9 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("supportsSecureTimersInOFF:"), 1920];
      void v13[3] = v9;
      int v10 = +[NSDictionary dictionaryWithObjects:v13 forKeys:v12 count:4];
      id v4 = [v5 initWithDomain:v6 code:10 userInfo:v10];
    }
    objc_sync_exit(v3);
  }
  else
  {
    id v4 = 0;
  }

  return v4;
}

void sub_100219B2C(_Unwind_Exception *exception_object)
{
}

id sub_100219F78(id *a1, unsigned int a2, unsigned __int8 *a3, unsigned int a4, int a5)
{
  unsigned int v5 = a4;
  uint64_t v6 = a3;
  unsigned int v8 = a2;
  if ((a2 & 0x10) == 0) {
    goto LABEL_13;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
  if (Logger)
  {
    if (a5) {
      CFStringRef v11 = "express ";
    }
    else {
      CFStringRef v11 = "";
    }
    Logger(4, "%s:%i RF Error found on %sFD (A=%d, B=%d, F=%d, V=%d)", "_NFDriverWrapperProccessRFTechDetectionInfo", 2044, v11, v8 & 1, (v8 >> 1) & 1, (v8 >> 2) & 1, (v8 >> 3) & 1);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v12 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    if (a5) {
      id v13 = "express ";
    }
    else {
      id v13 = "";
    }
    *(_DWORD *)id buf = 136447746;
    *(void *)CFStringRef v56 = "_NFDriverWrapperProccessRFTechDetectionInfo";
    *(_WORD *)&v56[8] = 1024;
    *(_DWORD *)&v56[10] = 2044;
    __int16 v57 = 2080;
    *(void *)BOOL v58 = v13;
    *(_WORD *)&v58[8] = 1024;
    *(_DWORD *)int v59 = v8 & 1;
    *(_WORD *)&void v59[4] = 1024;
    *(_DWORD *)uint64_t v60 = (v8 >> 1) & 1;
    *(_WORD *)&void v60[4] = 1024;
    int v61 = (v8 >> 2) & 1;
    __int16 v62 = 1024;
    int v63 = (v8 >> 3) & 1;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%{public}s:%i RF Error found on %sFD (A=%d, B=%d, F=%d, V=%d)", buf, 0x34u);
  }

  unsigned int v5 = a4;
  uint64_t v6 = a3;
  if (a5)
  {
LABEL_13:
    double v14 = objc_opt_new();
    id v15 = v14;
    if ((v8 & 8) != 0 && v6 && v5)
    {
      if (*v6 != 106)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        __int16 v32 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v32) {
          v32(3, "%s:%i Houston we have a problem! Payload corrupted without RF errors being set. vData[0] = 0x%X", "_NFDriverWrapperProccessRFTechDetectionInfo", 2088, *v6);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        __int16 v19 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          int v33 = *v6;
          *(_DWORD *)id buf = 136446722;
          *(void *)CFStringRef v56 = "_NFDriverWrapperProccessRFTechDetectionInfo";
          *(_WORD *)&v56[8] = 1024;
          *(_DWORD *)&v56[10] = 2088;
          __int16 v57 = 1024;
          *(_DWORD *)BOOL v58 = v33;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "%{public}s:%i Houston we have a problem! Payload corrupted without RF errors being set. vData[0] = 0x%X", buf, 0x18u);
        }
        __int16 v21 = 0;
        goto LABEL_43;
      }
      [v14 appendBytes:v6 length:v5];
    }
    uint64_t v16 = ((int)(v8 << 29) >> 31) & HIWORD(a2);
    v53[0] = @"FieldTechnology";
    id v17 = +[NSNumber numberWithUnsignedInt:v8 & 0xF];
    v54[0] = v17;
    v53[1] = @"SystemCode";
    id v18 = +[NSNumber numberWithUnsignedShort:v16];
    v53[2] = @"ECPData";
    v54[1] = v18;
    v54[2] = v15;
    __int16 v19 = +[NSDictionary dictionaryWithObjects:v54 forKeys:v53 count:3];

    BOOL v20 = +[NFFieldNotification notificationWithDictionary:v19];
    __int16 v21 = v20;
    if (v20)
    {
      id v22 = v20;
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v30 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v30) {
        v30(3, "%s:%i Error creating field notification", "_NFDriverWrapperProccessRFTechDetectionInfo", 2114);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v31 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)id buf = 136446466;
        *(void *)CFStringRef v56 = "_NFDriverWrapperProccessRFTechDetectionInfo";
        *(_WORD *)&v56[8] = 1024;
        *(_DWORD *)&v56[10] = 2114;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "%{public}s:%i Error creating field notification", buf, 0x12u);
      }
    }
LABEL_43:

    goto LABEL_66;
  }
  if ((v8 & 8) != 0)
  {
    if (!a3 || a4 < 2 || *a3 != 106)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v34 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v34) {
        v34(3, "%s:%i ECP payload corrupted.", "_NFDriverWrapperProccessRFTechDetectionInfo", 2066);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v25 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        goto LABEL_49;
      }
      *(_DWORD *)id buf = 136446466;
      *(void *)CFStringRef v56 = "_NFDriverWrapperProccessRFTechDetectionInfo";
      *(_WORD *)&v56[8] = 1024;
      *(_DWORD *)&v56[10] = 2066;
      __int16 v27 = "%{public}s:%i ECP payload corrupted.";
      id v28 = v25;
      uint32_t v29 = 18;
LABEL_48:
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, v27, buf, v29);
LABEL_49:

      goto LABEL_50;
    }
    int v23 = a3[1];
    if (v23 == 1) {
      goto LABEL_13;
    }
    if (v23 == 2)
    {
      if (a4 >= 5 && (a3[2] & 0xF) + 5 == a4) {
        goto LABEL_13;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v24 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v24) {
        v24(3, "%s:%i vDataLen %d does not match with payload length %d + %d bytes of ECP2HeaderLength", "_NFDriverWrapperProccessRFTechDetectionInfo", 2061, a4, a3[2] & 0xF, 5);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v25 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_ERROR)) {
        goto LABEL_49;
      }
      int v26 = a3[2] & 0xF;
      *(_DWORD *)id buf = 136447234;
      *(void *)CFStringRef v56 = "_NFDriverWrapperProccessRFTechDetectionInfo";
      *(_WORD *)&v56[8] = 1024;
      *(_DWORD *)&v56[10] = 2061;
      __int16 v57 = 1024;
      *(_DWORD *)BOOL v58 = a4;
      *(_WORD *)&void v58[4] = 1024;
      *(_DWORD *)&v58[6] = v26;
      *(_WORD *)int v59 = 1024;
      *(_DWORD *)&void v59[2] = 5;
      __int16 v27 = "%{public}s:%i vDataLen %d does not match with payload length %d + %d bytes of ECP2HeaderLength";
      id v28 = v25;
      uint32_t v29 = 36;
      goto LABEL_48;
    }
  }
LABEL_50:
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  __int16 v35 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
  if (v35) {
    v35(3, "%s:%i RF Error found (A=%d, B=%d, F=%d, V=%d). Restart Discovery", "_NFDriverWrapperProccessRFTechDetectionInfo", 2072, v8 & 1, (v8 >> 1) & 1, (v8 >> 2) & 1, (v8 >> 3) & 1);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  __int16 v36 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)id buf = 136447490;
    *(void *)CFStringRef v56 = "_NFDriverWrapperProccessRFTechDetectionInfo";
    *(_WORD *)&v56[8] = 1024;
    *(_DWORD *)&v56[10] = 2072;
    __int16 v57 = 1024;
    *(_DWORD *)BOOL v58 = v8 & 1;
    *(_WORD *)&void v58[4] = 1024;
    *(_DWORD *)&v58[6] = (v8 >> 1) & 1;
    *(_WORD *)int v59 = 1024;
    *(_DWORD *)&void v59[2] = (v8 >> 2) & 1;
    *(_WORD *)uint64_t v60 = 1024;
    *(_DWORD *)&v60[2] = (v8 >> 3) & 1;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "%{public}s:%i RF Error found (A=%d, B=%d, F=%d, V=%d). Restart Discovery", buf, 0x2Au);
  }

  if (a1)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v37 = NFLogGetLogger();
    if (v37)
    {
      __int16 v38 = (void (*)(uint64_t, const char *, ...))v37;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(a1);
      uint64_t Name = sel_getName("driverRestartDiscovery");
      uint64_t v42 = 45;
      if (isMetaClass) {
        uint64_t v42 = 43;
      }
      v38(6, "%c[%{public}s %{public}s]:%i Restarting Discovery", v42, ClassName, Name, 607);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v43 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v44 = object_getClass(a1);
      if (class_isMetaClass(v44)) {
        int v45 = 43;
      }
      else {
        int v45 = 45;
      }
      int v46 = object_getClassName(a1);
      BOOL v47 = sel_getName("driverRestartDiscovery");
      *(_DWORD *)id buf = 67109890;
      *(_DWORD *)CFStringRef v56 = v45;
      *(_WORD *)&void v56[4] = 2082;
      *(void *)&v56[6] = v46;
      __int16 v57 = 2082;
      *(void *)BOOL v58 = v47;
      *(_WORD *)&v58[8] = 1024;
      *(_DWORD *)int v59 = 607;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Restarting Discovery", buf, 0x22u);
    }

    [a1[31] handleRestartDiscovery];
  }
  __int16 v21 = 0;
LABEL_66:

  return v21;
}

id sub_10021A750()
{
  self;
  if (qword_100347690 != -1) {
    dispatch_once(&qword_100347690, &stru_100307A60);
  }
  uint64_t v0 = (void *)qword_100347688;

  return v0;
}

void sub_10021A7A8(id a1)
{
  uint64_t v1 = objc_opt_new();
  uint64_t v2 = qword_100347688;
  qword_100347688 = v1;

  _objc_release_x1(v1, v2);
}

unsigned char *sub_10021AD90(unsigned char *a1)
{
  if (a1)
  {
    uint64_t v2 = a1;
    [a1 _setHeadlessModeFeature:0];
    sub_10021CFD8(v2);
    a1 = [v2 pushIndexToPMU:0];
    uint64_t v1 = vars8;
  }
  return a1;
}

id sub_10021ADE4(void *a1)
{
  if (a1)
  {
    uint64_t v2 = a1;
    id v3 = [a1 getIndexFromLocale];
    [v2 kickRTCTimer];
    a1 = [v2 pushIndexToPMU:v3];
    uint64_t v1 = vars8;
  }
  return a1;
}

void sub_10021B0B8(id a1)
{
  io_registry_entry_t v1 = IORegistryEntryFromPath(kIOMainPortDefault, "IODeviceTree:/product");
  if (v1)
  {
    io_object_t v2 = v1;
    CFTypeRef CFProperty = IORegistryEntryCreateCFProperty(v1, @"has-applelpm", 0, 0);
    IOObjectRelease(v2);
    if (CFProperty)
    {
      CFTypeID v4 = CFGetTypeID(CFProperty);
      if (v4 == CFDataGetTypeID())
      {
        CFDataGetBytePtr((CFDataRef)CFProperty);
        CFDataGetLength((CFDataRef)CFProperty);
        __memcpy_chk();
      }
      CFRelease(CFProperty);
      byte_100347680 = 0;
    }
  }
}

void sub_10021CFD8(unsigned char *a1)
{
  if (a1 && a1[11])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(a1);
      uint64_t Name = sel_getName("cancelRTCTimer");
      uint64_t v7 = 45;
      if (isMetaClass) {
        uint64_t v7 = 43;
      }
      v3(6, "%c[%{public}s %{public}s]:%i Cancelling RTC timer", v7, ClassName, Name, 807);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    unsigned int v8 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      id v9 = object_getClass(a1);
      if (class_isMetaClass(v9)) {
        int v10 = 43;
      }
      else {
        int v10 = 45;
      }
      *(_DWORD *)id buf = 67109890;
      int v47 = v10;
      __int16 v48 = 2082;
      uint64_t v49 = object_getClassName(a1);
      __int16 v50 = 2082;
      uint64_t v51 = sel_getName("cancelRTCTimer");
      __int16 v52 = 1024;
      int v53 = 807;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Cancelling RTC timer", buf, 0x22u);
    }
    __int16 v40 = (id *)a1;

    long long v41 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    CFArrayRef v11 = IOPMCopyScheduledPowerEvents();
    id v12 = [(__CFArray *)v11 countByEnumeratingWithState:&v41 objects:v45 count:16];
    if (v12)
    {
      id v13 = v12;
      uint64_t v14 = *(void *)v42;
      CFArrayRef v39 = v11;
      do
      {
        for (i = 0; i != v13; i = (char *)i + 1)
        {
          if (*(void *)v42 != v14) {
            objc_enumerationMutation(v11);
          }
          uint64_t v16 = *(void **)(*((void *)&v41 + 1) + 8 * i);
          id v17 = [objc_alloc((Class)NSString) initWithUTF8String:"time"];
          CFDateRef v18 = [v16 objectForKey:v17];

          id v19 = [objc_alloc((Class)NSString) initWithUTF8String:"scheduledby"];
          BOOL v20 = [v16 objectForKey:v19];

          id v21 = [objc_alloc((Class)NSString) initWithUTF8String:"eventtype"];
          id v22 = [v16 objectForKey:v21];

          if ([v20 isEqualToString:@"com.apple.nfcd.headless"])
          {
            id v23 = [objc_alloc((Class)NSString) initWithUTF8String:"poweron"];
            unsigned int v24 = [v22 isEqualToString:v23];

            if (v24)
            {
              if (IOPMCancelScheduledPowerEvent(v18, @"com.apple.nfcd.headless", @"poweron"))
              {
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v25 = NFLogGetLogger();
                if (v25)
                {
                  int v26 = (void (*)(uint64_t, const char *, ...))v25;
                  __int16 v27 = object_getClass(v40);
                  BOOL v28 = class_isMetaClass(v27);
                  uint32_t v29 = object_getClassName(v40);
                  __int16 v38 = sel_getName("cancelRTCTimer");
                  uint64_t v30 = 45;
                  if (v28) {
                    uint64_t v30 = 43;
                  }
                  __int16 v36 = v29;
                  CFArrayRef v11 = v39;
                  v26(3, "%c[%{public}s %{public}s]:%i Failed to set RTC timer", v30, v36, v38, 818);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                int v31 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
                {
                  __int16 v32 = object_getClass(v40);
                  if (class_isMetaClass(v32)) {
                    int v33 = 43;
                  }
                  else {
                    int v33 = 45;
                  }
                  __int16 v34 = object_getClassName(v40);
                  __int16 v35 = sel_getName("cancelRTCTimer");
                  *(_DWORD *)id buf = 67109890;
                  int v47 = v33;
                  CFArrayRef v11 = v39;
                  __int16 v48 = 2082;
                  uint64_t v49 = v34;
                  __int16 v50 = 2082;
                  uint64_t v51 = v35;
                  __int16 v52 = 1024;
                  int v53 = 818;
                  _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set RTC timer", buf, 0x22u);
                }
              }
            }
          }
        }
        id v13 = [(__CFArray *)v11 countByEnumeratingWithState:&v41 objects:v45 count:16];
      }
      while (v13);
    }

    [v40[2] stopTimer];
  }
}

BOOL sub_10021D45C(void *a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  id v3 = a1;
  objc_sync_enter(v3);
  uint64_t v4 = v3[4];
  BOOL v5 = v4 != a2;
  if (v4 != a2)
  {
    [v3 _setHeadlessModeFeature:a2];
    id v6 = sub_10021ADE4(v3);
  }
  objc_sync_exit(v3);

  return v5;
}

void sub_10021D4D8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

BOOL sub_10021D4EC(void *a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  id v3 = a1;
  objc_sync_enter(v3);
  uint64_t v4 = *((void *)v3 + 4);
  BOOL v5 = v4 != (v4 | a2);
  if (v4 != (v4 | a2))
  {
    [v3 _setHeadlessModeFeature:];
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (Logger)
    {
      Class = object_getClass(v3);
      if (class_isMetaClass(Class)) {
        uint64_t v8 = 43;
      }
      else {
        uint64_t v8 = 45;
      }
      Classuint64_t Name = object_getClassName(v3);
      uint64_t Name = sel_getName("addHeadlessModeFeature:");
      Logger(6, "%c[%{public}s %{public}s]:%i Adding LPEM feature %d changed the feature set", v8, ClassName, Name, 653, a2);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    CFArrayRef v11 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      id v12 = object_getClass(v3);
      if (class_isMetaClass(v12)) {
        int v13 = 43;
      }
      else {
        int v13 = 45;
      }
      *(_DWORD *)id buf = 67110146;
      int v27 = v13;
      __int16 v28 = 2082;
      uint32_t v29 = object_getClassName(v3);
      __int16 v30 = 2082;
      int v31 = sel_getName("addHeadlessModeFeature:");
      __int16 v32 = 1024;
      int v33 = 653;
      __int16 v34 = 1024;
      int v35 = a2;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Adding LPEM feature %d changed the feature set", buf, 0x28u);
    }

    id v14 = sub_10021ADE4(v3);
  }
  if (*((unsigned char *)v3 + 9))
  {
    *((unsigned char *)v3 + 9) = 0;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v15 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v15)
    {
      uint64_t v16 = object_getClass(v3);
      if (class_isMetaClass(v16)) {
        uint64_t v17 = 43;
      }
      else {
        uint64_t v17 = 45;
      }
      CFDateRef v18 = object_getClassName(v3);
      id v19 = sel_getName("addHeadlessModeFeature:");
      v15(6, "%c[%{public}s %{public}s]:%i First time setting LPEM, reported as change", v17, v18, v19, 662);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    BOOL v20 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
    {
      id v21 = object_getClass(v3);
      if (class_isMetaClass(v21)) {
        int v22 = 43;
      }
      else {
        int v22 = 45;
      }
      id v23 = object_getClassName(v3);
      unsigned int v24 = sel_getName("addHeadlessModeFeature:");
      *(_DWORD *)id buf = 67109890;
      int v27 = v22;
      __int16 v28 = 2082;
      uint32_t v29 = v23;
      __int16 v30 = 2082;
      int v31 = v24;
      __int16 v32 = 1024;
      int v33 = 662;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i First time setting LPEM, reported as change", buf, 0x22u);
    }

    BOOL v5 = 1;
  }
  objc_sync_exit(v3);

  return v5;
}

void sub_10021D7F0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

BOOL sub_10021D824(void *a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  id v3 = a1;
  objc_sync_enter(v3);
  uint64_t v4 = *((void *)v3 + 4);
  uint64_t v5 = v4 & ~a2;
  BOOL v6 = v4 != v5;
  if (v4 != v5)
  {
    [v3 _setHeadlessModeFeature:];
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (Logger)
    {
      Class = object_getClass(v3);
      if (class_isMetaClass(Class)) {
        uint64_t v9 = 43;
      }
      else {
        uint64_t v9 = 45;
      }
      Classuint64_t Name = object_getClassName(v3);
      uint64_t Name = sel_getName("removeHeadlessModeFeature:");
      Logger(6, "%c[%{public}s %{public}s]:%i Removing LPEM feature %d changed the feature set", v9, ClassName, Name, 679, a2);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v12 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = object_getClass(v3);
      if (class_isMetaClass(v13)) {
        int v14 = 43;
      }
      else {
        int v14 = 45;
      }
      *(_DWORD *)id buf = 67110146;
      int v28 = v14;
      __int16 v29 = 2082;
      __int16 v30 = object_getClassName(v3);
      __int16 v31 = 2082;
      __int16 v32 = sel_getName("removeHeadlessModeFeature:");
      __int16 v33 = 1024;
      int v34 = 679;
      __int16 v35 = 1024;
      int v36 = a2;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Removing LPEM feature %d changed the feature set", buf, 0x28u);
    }

    id v15 = sub_10021ADE4(v3);
  }
  if (*((unsigned char *)v3 + 9))
  {
    *((unsigned char *)v3 + 9) = 0;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v16 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v16)
    {
      uint64_t v17 = object_getClass(v3);
      if (class_isMetaClass(v17)) {
        uint64_t v18 = 43;
      }
      else {
        uint64_t v18 = 45;
      }
      id v19 = object_getClassName(v3);
      BOOL v20 = sel_getName("removeHeadlessModeFeature:");
      v16(6, "%c[%{public}s %{public}s]:%i First time setting LPEM, reported as change", v18, v19, v20, 688);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v21 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      int v22 = object_getClass(v3);
      if (class_isMetaClass(v22)) {
        int v23 = 43;
      }
      else {
        int v23 = 45;
      }
      unsigned int v24 = object_getClassName(v3);
      uint64_t v25 = sel_getName("removeHeadlessModeFeature:");
      *(_DWORD *)id buf = 67109890;
      int v28 = v23;
      __int16 v29 = 2082;
      __int16 v30 = v24;
      __int16 v31 = 2082;
      __int16 v32 = v25;
      __int16 v33 = 1024;
      int v34 = 688;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i First time setting LPEM, reported as change", buf, 0x22u);
    }

    BOOL v6 = 1;
  }
  objc_sync_exit(v3);

  return v6;
}

void sub_10021DB28(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10021DB84(uint64_t a1)
{
  if (a1)
  {
    if (!*(unsigned char *)(a1 + 8))
    {
      io_object_t v2 = objc_opt_new();
      objc_initWeak(&location, (id)a1);
      [v2 setUnderlyingQueue:*(void *)(a1 + 24)];
      id v3 = +[NSNotificationCenter defaultCenter];
      v5[0] = _NSConcreteStackBlock;
      v5[1] = 3221225472;
      v5[2] = sub_10021DCC8;
      v5[3] = &unk_100307AA8;
      objc_copyWeak(&v6, &location);
      id v4 = [v3 addObserverForName:NSCurrentLocaleDidChangeNotification object:0 queue:v2 usingBlock:v5];

      *(unsigned char *)(a1 + 8) = 1;
      objc_destroyWeak(&v6);
      objc_destroyWeak(&location);
    }
  }
}

void sub_10021DCA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10021DCC8(uint64_t a1)
{
  io_object_t v2 = _os_activity_create((void *)&_mh_execute_header, "headless locale changed", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
  v5.opaque[0] = 0;
  v5.opaque[1] = 0;
  os_activity_scope_enter(v2, &v5);
  os_activity_scope_leave(&v5);

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v4 = WeakRetained;
  if (WeakRetained) {
    [WeakRetained localeChanged];
  }
}

void sub_10021DD48(uint64_t a1)
{
  if (a1)
  {
    if (*(unsigned char *)(a1 + 8))
    {
      io_object_t v2 = +[NSNotificationCenter defaultCenter];
      [v2 removeObserver:a1 name:NSCurrentLocaleDidChangeNotification object:0];

      *(unsigned char *)(a1 + 8) = 0;
    }
  }
}

void sub_10021E18C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10021E1B0(uint64_t a1)
{
  io_object_t v2 = _os_activity_create((void *)&_mh_execute_header, "com.apple.nfcd.hw.rtc.kickTimer", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  v5.opaque[0] = 0;
  v5.opaque[1] = 0;
  os_activity_scope_enter(v2, &v5);
  os_activity_scope_leave(&v5);

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  id v4 = WeakRetained;
  if (WeakRetained)
  {
    sub_10021CFD8(WeakRetained);
    [v4 headlessTimerLogic];
  }
}

void *sub_10021E238(void *a1)
{
  io_registry_entry_t v1 = a1;
  if (a1)
  {
    io_object_t v2 = objc_opt_new();
    id v3 = +[NSNumber numberWithBool:*((unsigned __int8 *)v1 + 8)];
    [v2 setObject:v3 forKeyedSubscript:@"registered"];

    id v4 = (void *)v1[2];
    if (v4)
    {
      os_activity_scope_state_s v5 = [v4 description];
      [v2 setObject:v5 forKeyedSubscript:@"timer"];
    }
    else
    {
      [v2 setObject:@"nil" forKeyedSubscript:@"timer"];
    }
    id v6 = +[NSNumber numberWithUnsignedInteger:v1[4]];
    [v2 setObject:v6 forKeyedSubscript:@"features"];

    uint64_t v7 = [v1 getLPMControl];
    [v2 setObject:v7 forKeyedSubscript:@"PMU"];

    uint64_t v8 = +[NSNumber numberWithBool:*((unsigned __int8 *)v1 + 11)];
    [v2 setObject:v8 forKeyedSubscript:@"Requires SCC timer"];

    io_registry_entry_t v1 = [objc_alloc((Class)NSDictionary) initWithDictionary:v2];
  }

  return v1;
}

BOOL sub_10021E3E0(uint64_t a1, void *a2)
{
  id v3 = self;
  if (a2) {
    *a2 = 0;
  }
  uint64_t v4 = SSEIsFeatureSupported(41);
  uint64_t v5 = v4;
  if ((int)v4 > -11)
  {
    if (!v4) {
      return v5 == 0;
    }
    if (v4 != -10) {
      goto LABEL_28;
    }
  }
  else if (v4 != -19)
  {
    if (v4 == -17)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        uint64_t v7 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(v3);
        BOOL isMetaClass = class_isMetaClass(Class);
        Classuint64_t Name = object_getClassName(v3);
        uint64_t Name = sel_getName("supportsEntanglement:");
        uint64_t v11 = 45;
        if (isMetaClass) {
          uint64_t v11 = 43;
        }
        v7(3, "%c[%{public}s %{public}s]:%i Feature support check not supported", v11, ClassName, Name, 38);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v12 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        int v13 = object_getClass(v3);
        if (class_isMetaClass(v13)) {
          int v14 = 43;
        }
        else {
          int v14 = 45;
        }
        *(_DWORD *)id buf = 67109890;
        int v49 = v14;
        __int16 v50 = 2082;
        uint64_t v51 = object_getClassName(v3);
        __int16 v52 = 2082;
        int v53 = sel_getName("supportsEntanglement:");
        __int16 v54 = 1024;
        int v55 = 38;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Feature support check not supported", buf, 0x22u);
      }
      goto LABEL_40;
    }
LABEL_28:
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v29 = NFLogGetLogger();
    if (v29)
    {
      __int16 v30 = (void (*)(uint64_t, const char *, ...))v29;
      __int16 v31 = object_getClass(v3);
      BOOL v32 = class_isMetaClass(v31);
      __int16 v33 = object_getClassName(v3);
      long long v43 = sel_getName("supportsEntanglement:");
      uint64_t v34 = 45;
      if (v32) {
        uint64_t v34 = 43;
      }
      v30(3, "%c[%{public}s %{public}s]:%i Feature support check failed : %d", v34, v33, v43, 35, v5);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v35 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      int v36 = object_getClass(v3);
      if (class_isMetaClass(v36)) {
        int v37 = 43;
      }
      else {
        int v37 = 45;
      }
      *(_DWORD *)id buf = 67110146;
      int v49 = v37;
      __int16 v50 = 2082;
      uint64_t v51 = object_getClassName(v3);
      __int16 v52 = 2082;
      int v53 = sel_getName("supportsEntanglement:");
      __int16 v54 = 1024;
      int v55 = 35;
      __int16 v56 = 1024;
      int v57 = v5;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Feature support check failed : %d", buf, 0x28u);
    }

    if (a2)
    {
      id v38 = objc_alloc((Class)NSError);
      id v12 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v44 = NSLocalizedDescriptionKey;
      unsigned int v24 = +[NSString stringWithUTF8String:"Security Not Initialized"];
      int v45 = v24;
      uint64_t v25 = +[NSDictionary dictionaryWithObjects:&v45 forKeys:&v44 count:1];
      int v26 = v38;
      int v27 = v12;
      uint64_t v28 = 27;
      goto LABEL_39;
    }
    return v5 == 0;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v15 = NFLogGetLogger();
  if (v15)
  {
    uint64_t v16 = (void (*)(uint64_t, const char *, ...))v15;
    uint64_t v17 = object_getClass(v3);
    BOOL v18 = class_isMetaClass(v17);
    __int16 v40 = object_getClassName(v3);
    long long v42 = sel_getName("supportsEntanglement:");
    uint64_t v19 = 45;
    if (v18) {
      uint64_t v19 = 43;
    }
    v16(3, "%c[%{public}s %{public}s]:%i Feature support check not allowed : %d", v19, v40, v42, 32, v5);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  BOOL v20 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    id v21 = object_getClass(v3);
    if (class_isMetaClass(v21)) {
      int v22 = 43;
    }
    else {
      int v22 = 45;
    }
    *(_DWORD *)id buf = 67110146;
    int v49 = v22;
    __int16 v50 = 2082;
    uint64_t v51 = object_getClassName(v3);
    __int16 v52 = 2082;
    int v53 = sel_getName("supportsEntanglement:");
    __int16 v54 = 1024;
    int v55 = 32;
    __int16 v56 = 1024;
    int v57 = v5;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Feature support check not allowed : %d", buf, 0x28u);
  }

  if (a2)
  {
    id v23 = objc_alloc((Class)NSError);
    id v12 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v46 = NSLocalizedDescriptionKey;
    unsigned int v24 = +[NSString stringWithUTF8String:"Keychain locked"];
    int v47 = v24;
    uint64_t v25 = +[NSDictionary dictionaryWithObjects:&v47 forKeys:&v46 count:1];
    int v26 = v23;
    int v27 = v12;
    uint64_t v28 = 41;
LABEL_39:
    *a2 = [v26 initWithDomain:v27 code:v28 userInfo:v25];

LABEL_40:
  }
  return v5 == 0;
}

uint64_t sub_10021E92C(uint64_t a1, int a2)
{
  id v3 = self;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(v3);
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(v3);
    uint64_t Name = sel_getName("useEntangledFlag:");
    if (a2) {
      int v10 = "entangled";
    }
    else {
      int v10 = "non-entangled";
    }
    uint64_t v11 = 45;
    if (isMetaClass) {
      uint64_t v11 = 43;
    }
    v5(6, "%c[%{public}s %{public}s]:%i Telling SSE to use %s auth", v11, ClassName, Name, 52, v10);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v12 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = object_getClass(v3);
    if (class_isMetaClass(v13)) {
      int v14 = 43;
    }
    else {
      int v14 = 45;
    }
    uint64_t v15 = object_getClassName(v3);
    uint64_t v16 = sel_getName("useEntangledFlag:");
    *(_DWORD *)id buf = 67110146;
    if (a2) {
      uint64_t v17 = "entangled";
    }
    else {
      uint64_t v17 = "non-entangled";
    }
    int v34 = v14;
    __int16 v35 = 2082;
    int v36 = v15;
    __int16 v37 = 2082;
    id v38 = v16;
    __int16 v39 = 1024;
    int v40 = 52;
    __int16 v41 = 2080;
    long long v42 = v17;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Telling SSE to use %s auth", buf, 0x2Cu);
  }

  uint64_t result = SSEUseEntangledAuthorizationRandom(a2);
  if (result)
  {
    uint64_t v19 = result;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v20 = NFLogGetLogger();
    if (v20)
    {
      id v21 = (void (*)(uint64_t, const char *, ...))v20;
      int v22 = object_getClass(v3);
      BOOL v23 = class_isMetaClass(v22);
      __int16 v31 = object_getClassName(v3);
      BOOL v32 = sel_getName("useEntangledFlag:");
      uint64_t v24 = 45;
      if (v23) {
        uint64_t v24 = 43;
      }
      v21(3, "%c[%{public}s %{public}s]:%i Failed set flag: %d", v24, v31, v32, 55, v19);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v25 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      int v26 = object_getClass(v3);
      if (class_isMetaClass(v26)) {
        int v27 = 43;
      }
      else {
        int v27 = 45;
      }
      uint64_t v28 = object_getClassName(v3);
      uint64_t v29 = sel_getName("useEntangledFlag:");
      *(_DWORD *)id buf = 67110146;
      int v34 = v27;
      __int16 v35 = 2082;
      int v36 = v28;
      __int16 v37 = 2082;
      id v38 = v29;
      __int16 v39 = 1024;
      int v40 = 55;
      __int16 v41 = 1024;
      LODWORD(v42) = v19;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed set flag: %d", buf, 0x28u);
    }

    if (v19 == -19 || v19 == -10) {
      return 41;
    }
    else {
      return 6;
    }
  }
  return result;
}

uint64_t sub_10021EC3C(uint64_t a1, int a2)
{
  id v3 = self;
  if (a2)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v3);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(v3);
      uint64_t Name = sel_getName("sseEffaceAuthorization:");
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v5(6, "%c[%{public}s %{public}s]:%i Telling SSE to use entangled auth", v9, ClassName, Name, 73);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = object_getClass(v3);
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      *(_DWORD *)id buf = 67109890;
      int v43 = v12;
      __int16 v44 = 2082;
      int v45 = object_getClassName(v3);
      __int16 v46 = 2082;
      int v47 = sel_getName("sseEffaceAuthorization:");
      __int16 v48 = 1024;
      int v49 = 73;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Telling SSE to use entangled auth", buf, 0x22u);
    }

    uint64_t v13 = SSEUseEntangledAuthorizationRandom(1);
    if (v13)
    {
      uint64_t v14 = v13;
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v15 = NFLogGetLogger();
      if (v15)
      {
        uint64_t v16 = (void (*)(uint64_t, const char *, ...))v15;
        uint64_t v17 = object_getClass(v3);
        BOOL v18 = class_isMetaClass(v17);
        __int16 v37 = object_getClassName(v3);
        int v40 = sel_getName("sseEffaceAuthorization:");
        uint64_t v19 = 45;
        if (v18) {
          uint64_t v19 = 43;
        }
        v16(3, "%c[%{public}s %{public}s]:%i Failed to set entangled: %d", v19, v37, v40, 76, v14);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v20 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        id v21 = object_getClass(v3);
        if (class_isMetaClass(v21)) {
          int v22 = 43;
        }
        else {
          int v22 = 45;
        }
        BOOL v23 = object_getClassName(v3);
        uint64_t v24 = sel_getName("sseEffaceAuthorization:");
        *(_DWORD *)id buf = 67110146;
        int v43 = v22;
        __int16 v44 = 2082;
        int v45 = v23;
        __int16 v46 = 2082;
        int v47 = v24;
        __int16 v48 = 1024;
        int v49 = 76;
        __int16 v50 = 1024;
        int v51 = v14;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set entangled: %d", buf, 0x28u);
      }
    }
  }
  uint64_t result = SSEEffaceAuthorizationRandom();
  if (result)
  {
    uint64_t v26 = result;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v27 = NFLogGetLogger();
    if (v27)
    {
      uint64_t v28 = (void (*)(uint64_t, const char *, ...))v27;
      uint64_t v29 = object_getClass(v3);
      BOOL v30 = class_isMetaClass(v29);
      id v38 = object_getClassName(v3);
      __int16 v41 = sel_getName("sseEffaceAuthorization:");
      uint64_t v31 = 45;
      if (v30) {
        uint64_t v31 = 43;
      }
      v28(3, "%c[%{public}s %{public}s]:%i Failed to efface: %d", v31, v38, v41, 83, v26);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    BOOL v32 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      __int16 v33 = object_getClass(v3);
      if (class_isMetaClass(v33)) {
        int v34 = 43;
      }
      else {
        int v34 = 45;
      }
      __int16 v35 = object_getClassName(v3);
      int v36 = sel_getName("sseEffaceAuthorization:");
      *(_DWORD *)id buf = 67110146;
      int v43 = v34;
      __int16 v44 = 2082;
      int v45 = v35;
      __int16 v46 = 2082;
      int v47 = v36;
      __int16 v48 = 1024;
      int v49 = 83;
      __int16 v50 = 1024;
      int v51 = v26;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to efface: %d", buf, 0x28u);
    }

    if (v26 == -10) {
      return 41;
    }
    else {
      return 6;
    }
  }
  return result;
}

uint64_t sub_10021F038(uint64_t a1, void *a2, uint64_t a3, void *a4, void *a5, int a6)
{
  id v10 = a2;
  uint64_t v11 = self;
  uint64_t v12 = sub_10021F0B0(v11, v10, a3, a4, a5, a6, 0);

  return v12;
}

uint64_t sub_10021F0B0(uint64_t a1, void *a2, uint64_t a3, void *a4, void *a5, int a6, unsigned int a7)
{
  CFDataRef v11 = a2;
  uint64_t v12 = self;
  id v48 = 0;
  id v49 = 0;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  uint64_t v14 = (void (*)(uint64_t, const char *, ...))Logger;
  if (a6)
  {
    if (Logger)
    {
      Class = object_getClass(v12);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(v12);
      uint64_t Name = sel_getName("sseGetAuthRandom:uid:authRandom:mac:entangled:previous:");
      uint64_t v17 = 45;
      if (isMetaClass) {
        uint64_t v17 = 43;
      }
      v14(6, "%c[%{public}s %{public}s]:%i Get entangled auth %d", v17, ClassName, Name, 116, a7);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    BOOL v18 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = object_getClass(v12);
      if (class_isMetaClass(v19)) {
        int v20 = 43;
      }
      else {
        int v20 = 45;
      }
      *(_DWORD *)id buf = 67110146;
      int v51 = v20;
      __int16 v52 = 2082;
      int v53 = object_getClassName(v12);
      __int16 v54 = 2082;
      int v55 = sel_getName("sseGetAuthRandom:uid:authRandom:mac:entangled:previous:");
      __int16 v56 = 1024;
      int v57 = 116;
      __int16 v58 = 1024;
      int v59 = a7;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Get entangled auth %d", buf, 0x28u);
    }

    uint64_t v21 = SSEGetEntangledAuthorizationRandom(a3, v11, a7, (CFDataRef *)&v49, (CFDataRef *)&v48);
  }
  else
  {
    if (Logger)
    {
      int v22 = object_getClass(v12);
      BOOL v23 = class_isMetaClass(v22);
      int v43 = object_getClassName(v12);
      int v45 = sel_getName("sseGetAuthRandom:uid:authRandom:mac:entangled:previous:");
      uint64_t v24 = 45;
      if (v23) {
        uint64_t v24 = 43;
      }
      v14(6, "%c[%{public}s %{public}s]:%i Get non-entangled auth %d", v24, v43, v45, 119, a7);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v25 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v26 = object_getClass(v12);
      if (class_isMetaClass(v26)) {
        int v27 = 43;
      }
      else {
        int v27 = 45;
      }
      *(_DWORD *)id buf = 67110146;
      int v51 = v27;
      __int16 v52 = 2082;
      int v53 = object_getClassName(v12);
      __int16 v54 = 2082;
      int v55 = sel_getName("sseGetAuthRandom:uid:authRandom:mac:entangled:previous:");
      __int16 v56 = 1024;
      int v57 = 119;
      __int16 v58 = 1024;
      int v59 = a7;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Get non-entangled auth %d", buf, 0x28u);
    }

    uint64_t v21 = SSEGetAuthorizationRandom(a3, v11, (const __CFData **)&v49, (const __CFData **)&v48);
  }
  uint64_t v28 = v21;

  if (v28)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v29 = NFLogGetLogger();
    if (v29)
    {
      BOOL v30 = (void (*)(uint64_t, const char *, ...))v29;
      uint64_t v31 = object_getClass(v12);
      BOOL v32 = class_isMetaClass(v31);
      __int16 v33 = object_getClassName(v12);
      __int16 v46 = sel_getName("sseGetAuthRandom:uid:authRandom:mac:entangled:previous:");
      uint64_t v34 = 45;
      if (v32) {
        uint64_t v34 = 43;
      }
      v30(3, "%c[%{public}s %{public}s]:%i Failed to generate: error %d for uid %d", v34, v33, v46, 129, v28, a3);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v35 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      int v36 = object_getClass(v12);
      if (class_isMetaClass(v36)) {
        int v37 = 43;
      }
      else {
        int v37 = 45;
      }
      id v38 = object_getClassName(v12);
      __int16 v39 = sel_getName("sseGetAuthRandom:uid:authRandom:mac:entangled:previous:");
      *(_DWORD *)id buf = 67110402;
      int v51 = v37;
      __int16 v52 = 2082;
      int v53 = v38;
      __int16 v54 = 2082;
      int v55 = v39;
      __int16 v56 = 1024;
      int v57 = 129;
      __int16 v58 = 1024;
      int v59 = v28;
      __int16 v60 = 1024;
      int v61 = a3;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to generate: error %d for uid %d", buf, 0x2Eu);
    }

    if (v28 == -10) {
      return 41;
    }
    else {
      return 6;
    }
  }
  else
  {
    if (a4) {
      *a4 = v49;
    }
    if (a5)
    {
      id v41 = v48;
      uint64_t result = 0;
      *a5 = v41;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t sub_10021F55C(uint64_t a1, void *a2, uint64_t a3, void *a4, void *a5, unsigned __int16 *a6, void *a7)
{
  id v12 = a5;
  CFDataRef v13 = a4;
  CFDataRef v14 = a2;
  uint64_t v15 = self;
  id v33 = 0;
  CFDataRef v16 = (const __CFData *)[v12 subdataWithRange:0, 8];
  CFDataRef v17 = (const __CFData *)[v12 subdataWithRange:NSMakeRange(8, 8)];

  uint64_t v18 = SSEGetActivationTimeout(v14, v13, v16, v17, a6, (const __CFData **)&v33);
  if (v18)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      int v20 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v15);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(v15);
      uint64_t Name = sel_getName("sseGetAuthorizationTimeout:uid:challenge:response:timeout:mac:");
      uint64_t v24 = 45;
      if (isMetaClass) {
        uint64_t v24 = 43;
      }
      v20(3, "%c[%{public}s %{public}s]:%i Failed to get activation timeout: %d for uid %d", v24, ClassName, Name, 165, v18, a3);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v25 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      uint64_t v26 = object_getClass(v15);
      if (class_isMetaClass(v26)) {
        int v27 = 43;
      }
      else {
        int v27 = 45;
      }
      uint64_t v28 = object_getClassName(v15);
      uint64_t v29 = sel_getName("sseGetAuthorizationTimeout:uid:challenge:response:timeout:mac:");
      *(_DWORD *)id buf = 67110402;
      int v35 = v27;
      __int16 v36 = 2082;
      int v37 = v28;
      __int16 v38 = 2082;
      __int16 v39 = v29;
      __int16 v40 = 1024;
      int v41 = 165;
      __int16 v42 = 1024;
      int v43 = v18;
      __int16 v44 = 1024;
      int v45 = a3;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get activation timeout: %d for uid %d", buf, 0x2Eu);
    }

    switch(v18)
    {
      case 0xFFFFFFF6:
        return 41;
      case 0xFFFFFFFC:
        return 10;
      case 0xFFFFFFFD:
        return 8;
      default:
        return 6;
    }
  }
  else if (a7)
  {
    id v31 = v33;
    uint64_t result = 0;
    *a7 = v31;
  }
  else
  {
    return 0;
  }
  return result;
}

uint64_t sub_10021F7F0(uint64_t a1, void *a2)
{
  id v3 = self;
  id v20 = 0;
  uint64_t v4 = SSEGetHostChallenge((CFDataRef *)&v20);
  if (v4)
  {
    uint64_t v5 = v4;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v7 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v3);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(v3);
      uint64_t Name = sel_getName("sseGetHostChallenge:");
      uint64_t v10 = 45;
      if (isMetaClass) {
        uint64_t v10 = 43;
      }
      v7(3, "%c[%{public}s %{public}s]:%i Failed to get host challenge: %d", v10, ClassName, Name, 188, v5);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    CFDataRef v11 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      id v12 = object_getClass(v3);
      if (class_isMetaClass(v12)) {
        int v13 = 43;
      }
      else {
        int v13 = 45;
      }
      CFDataRef v14 = object_getClassName(v3);
      uint64_t v15 = sel_getName("sseGetHostChallenge:");
      *(_DWORD *)id buf = 67110146;
      int v22 = v13;
      __int16 v23 = 2082;
      uint64_t v24 = v14;
      __int16 v25 = 2082;
      uint64_t v26 = v15;
      __int16 v27 = 1024;
      int v28 = 188;
      __int16 v29 = 1024;
      int v30 = v5;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get host challenge: %d", buf, 0x28u);
    }

    if (v5 == -10) {
      return 41;
    }
    else {
      return 6;
    }
  }
  else if (a2)
  {
    id v17 = v20;
    uint64_t result = 0;
    *a2 = v17;
  }
  else
  {
    return 0;
  }
  return result;
}

id sub_10021F9D8(uint64_t a1, int a2, void *a3, void *a4, uint64_t a5, void *a6, void *a7, char *a8, void *a9, void *a10, void *a11, void *a12, void *a13)
{
  id v18 = a7;
  CFDataRef v19 = a6;
  CFDataRef v20 = a4;
  CFDataRef v21 = a3;
  int v22 = self;
  id v74 = 0;
  unsigned int v76 = 0;
  id v75 = 0;
  CFDataRef v23 = (const __CFData *)[v18 subdataWithRange:NSMakeRange(0, 8)];
  CFDataRef v24 = (const __CFData *)[v18 subdataWithRange:NSMakeRange(8, 8)];

  if (a2 == 5)
  {
    uint64_t v25 = SSEAuthorizeWithPIN(5, v21, v20, v19, v23, v24, &v76, (CFDataRef *)&v75, (CFDataRef *)&v74);

    uint64_t v26 = a9;
    if (v25)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      int v28 = a5;
      if (Logger)
      {
        __int16 v29 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(v22);
        BOOL isMetaClass = class_isMetaClass(Class);
        Classuint64_t Name = object_getClassName(v22);
        uint64_t Name = sel_getName("sseAuthorize:handle:SEID:uid:challenge:response:validation:encryptedPIN:confirmationHash:confirmationSignature:confirmationVersion:certs:");
        uint64_t v33 = 45;
        if (isMetaClass) {
          uint64_t v33 = 43;
        }
        v29(3, "%c[%{public}s %{public}s]:%i Failed to authorize with PIN: %d for uid %d", v33, ClassName, Name, 291, v25, a5);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v34 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
        goto LABEL_23;
      }
      int v35 = object_getClass(v22);
      if (class_isMetaClass(v35)) {
        int v36 = 43;
      }
      else {
        int v36 = 45;
      }
      int v37 = object_getClassName(v22);
      __int16 v38 = sel_getName("sseAuthorize:handle:SEID:uid:challenge:response:validation:encryptedPIN:confirmationHash:confirmationSignature:confirmationVersion:certs:");
      *(_DWORD *)id buf = 67110402;
      int v78 = v36;
      __int16 v79 = 2082;
      BOOL v80 = v37;
      __int16 v81 = 2082;
      id v82 = v38;
      __int16 v83 = 1024;
      int v84 = 291;
      __int16 v85 = 1024;
      int v86 = v25;
      __int16 v87 = 1024;
      int v88 = v28;
      __int16 v39 = "%c[%{public}s %{public}s]:%i Failed to authorize with PIN: %d for uid %d";
      __int16 v40 = v34;
      uint32_t v41 = 46;
LABEL_22:
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, v39, buf, v41);
LABEL_23:

      id v52 = 0;
      goto LABEL_49;
    }
  }
  else
  {
    uint64_t v42 = SSEAuthorize(a2, v21, a5, v20, v19, v23, v24, &v76, (CFDataRef *)&v74);

    *a9 = 0;
    uint64_t v26 = a9;
    if (v42)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v43 = NFLogGetLogger();
      if (v43)
      {
        __int16 v44 = (void (*)(uint64_t, const char *, ...))v43;
        int v45 = object_getClass(v22);
        BOOL v46 = class_isMetaClass(v45);
        int v70 = object_getClassName(v22);
        int v72 = sel_getName("sseAuthorize:handle:SEID:uid:challenge:response:validation:encryptedPIN:confirmationHash:confirmationSignature:confirmationVersion:certs:");
        uint64_t v47 = 45;
        if (v46) {
          uint64_t v47 = 43;
        }
        v44(3, "%c[%{public}s %{public}s]:%i Failed to authorize: %d", v47, v70, v72, 328, v42);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v34 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_ERROR)) {
        goto LABEL_23;
      }
      id v48 = object_getClass(v22);
      if (class_isMetaClass(v48)) {
        int v49 = 43;
      }
      else {
        int v49 = 45;
      }
      __int16 v50 = object_getClassName(v22);
      int v51 = sel_getName("sseAuthorize:handle:SEID:uid:challenge:response:validation:encryptedPIN:confirmationHash:confirmationSignature:confirmationVersion:certs:");
      *(_DWORD *)id buf = 67110146;
      int v78 = v49;
      __int16 v79 = 2082;
      BOOL v80 = v50;
      __int16 v81 = 2082;
      id v82 = v51;
      __int16 v83 = 1024;
      int v84 = 328;
      __int16 v85 = 1024;
      int v86 = v42;
      __int16 v39 = "%c[%{public}s %{public}s]:%i Failed to authorize: %d";
      __int16 v40 = v34;
      uint32_t v41 = 40;
      goto LABEL_22;
    }
  }
  if (a12) {
    *a12 = 0;
  }
  if (a8)
  {
    char v53 = v76;
    if (v76 == 3)
    {
      BOOL v55 = a2 == 5;
      char v56 = 7;
    }
    else
    {
      if (v76 != 2)
      {
        if (v76 == 1)
        {
          if (a2 == 5) {
            char v54 = 5;
          }
          else {
            char v54 = 1;
          }
          *a8 = v54;
          if (!v26) {
            goto LABEL_42;
          }
        }
        else
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v58 = NFLogGetLogger();
          if (v58)
          {
            int v59 = (void (*)(uint64_t, const char *, ...))v58;
            __int16 v60 = object_getClass(v22);
            BOOL v61 = class_isMetaClass(v60);
            __int16 v62 = object_getClassName(v22);
            int v63 = sel_getName("sseAuthorize:handle:SEID:uid:challenge:response:validation:encryptedPIN:confirmationHash:confirmationSignature:confirmationVersion:certs:");
            uint64_t v64 = 45;
            if (v61) {
              uint64_t v64 = 43;
            }
            v59(3, "%c[%{public}s %{public}s]:%i Unknown validation: %d", v64, v62, v63, 350, v76);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v65 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
          {
            BOOL v66 = object_getClass(v22);
            if (class_isMetaClass(v66)) {
              int v67 = 43;
            }
            else {
              int v67 = 45;
            }
            uint64_t v68 = object_getClassName(v22);
            uint64_t v69 = sel_getName("sseAuthorize:handle:SEID:uid:challenge:response:validation:encryptedPIN:confirmationHash:confirmationSignature:confirmationVersion:certs:");
            *(_DWORD *)id buf = 67110146;
            int v78 = v67;
            __int16 v79 = 2082;
            BOOL v80 = v68;
            __int16 v81 = 2082;
            id v82 = v69;
            __int16 v83 = 1024;
            int v84 = 350;
            __int16 v85 = 1024;
            int v86 = v76;
            _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unknown validation: %d", buf, 0x28u);
          }

          if (!v26) {
            goto LABEL_42;
          }
        }
        goto LABEL_41;
      }
      BOOL v55 = a2 == 5;
      char v56 = 6;
    }
    if (v55) {
      char v53 = v56;
    }
    *a8 = v53;
  }
  if (v26) {
LABEL_41:
  }
    void *v26 = v75;
LABEL_42:
  if (a10) {
    *a10 = 0;
  }
  if (a11) {
    *a11 = 0;
  }
  if (a13) {
    *a13 = 0;
  }
  id v52 = v74;
LABEL_49:

  return v52;
}

uint64_t sub_10021FFB4(uint64_t a1, char *a2, _OWORD *a3, uint64_t a4)
{
  self;
  uint64_t v10 = 0;
  CFDataRef v11 = &v10;
  uint64_t v12 = 0x2020000000;
  char v13 = 0;
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  id v9[2] = sub_1002200A0;
  unsigned char v9[3] = &unk_100307AD0;
  v9[4] = &v10;
  void v9[5] = a4;
  ACMContextVerifyPolicyEx(a3, a2, 1, 0, 0, 0, (uint64_t)v9);
  uint64_t v7 = *((unsigned __int8 *)v11 + 24);
  _Block_object_dispose(&v10, 8);
  return v7;
}

void sub_100220088(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1002200A0(uint64_t result, int a2, char a3)
{
  **(_DWORD **)(result + 40) = a2;
  if (!a2) {
    *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = a3;
  }
  return result;
}

uint64_t sub_1002200C0(uint64_t a1, void *a2)
{
  id v2 = a2;
  id v3 = self;
  unsigned int v84 = 0;
  id v4 = v2;
  uint64_t v5 = [v4 bytes];
  id v6 = [v4 length];

  uint64_t v7 = ACMContextCreateWithExternalForm(v5, (uint64_t)v6);
  if (!v7)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      CFDataRef v23 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v3);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(v3);
      uint64_t Name = sel_getName("acmGetOlsoType:");
      uint64_t v27 = 45;
      if (isMetaClass) {
        uint64_t v27 = 43;
      }
      v23(3, "%c[%{public}s %{public}s]:%i Unable to reconstruct cred context", v27, ClassName, Name, 410);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v28 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      __int16 v29 = object_getClass(v3);
      if (class_isMetaClass(v29)) {
        int v30 = 43;
      }
      else {
        int v30 = 45;
      }
      *(_DWORD *)id buf = 67109890;
      int v86 = v30;
      __int16 v87 = 2082;
      int v88 = object_getClassName(v3);
      __int16 v89 = 2082;
      __int16 v90 = sel_getName("acmGetOlsoType:");
      __int16 v91 = 1024;
      int v92 = 410;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unable to reconstruct cred context", buf, 0x22u);
    }

    return 0;
  }
  uint64_t v8 = v7;
  int v9 = sub_10021FFB4((uint64_t)NFSSEWrapper, "PraguePIN", v7, (uint64_t)&v84);
  if (!v84 && v9)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v10 = NFLogGetLogger();
    if (v10)
    {
      CFDataRef v11 = (void (*)(uint64_t, const char *, ...))v10;
      uint64_t v12 = object_getClass(v3);
      BOOL v13 = class_isMetaClass(v12);
      CFDataRef v14 = object_getClassName(v3);
      __int16 v79 = sel_getName("acmGetOlsoType:");
      uint64_t v15 = 45;
      if (v13) {
        uint64_t v15 = 43;
      }
      v11(6, "%c[%{public}s %{public}s]:%i Policy is prague PIN", v15, v14, v79, 423);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    CFDataRef v16 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      id v17 = object_getClass(v3);
      if (class_isMetaClass(v17)) {
        int v18 = 43;
      }
      else {
        int v18 = 45;
      }
      CFDataRef v19 = object_getClassName(v3);
      CFDataRef v20 = sel_getName("acmGetOlsoType:");
      *(_DWORD *)id buf = 67109890;
      int v86 = v18;
      __int16 v87 = 2082;
      int v88 = v19;
      __int16 v89 = 2082;
      __int16 v90 = v20;
      __int16 v91 = 1024;
      int v92 = 423;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Policy is prague PIN", buf, 0x22u);
    }

    ACMContextDelete(v8, 0);
    return 4;
  }
  int v31 = sub_10021FFB4((uint64_t)NFSSEWrapper, "Prague", v8, (uint64_t)&v84);
  if (!v84 && v31)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v32 = NFLogGetLogger();
    if (v32)
    {
      uint64_t v33 = (void (*)(uint64_t, const char *, ...))v32;
      uint64_t v34 = object_getClass(v3);
      BOOL v35 = class_isMetaClass(v34);
      int v36 = object_getClassName(v3);
      __int16 v81 = sel_getName("acmGetOlsoType:");
      uint64_t v37 = 45;
      if (v35) {
        uint64_t v37 = 43;
      }
      v33(6, "%c[%{public}s %{public}s]:%i Policy is prague", v37, v36, v81, 430);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v38 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v39 = object_getClass(v3);
      if (class_isMetaClass(v39)) {
        int v40 = 43;
      }
      else {
        int v40 = 45;
      }
      uint32_t v41 = object_getClassName(v3);
      uint64_t v42 = sel_getName("acmGetOlsoType:");
      *(_DWORD *)id buf = 67109890;
      int v86 = v40;
      __int16 v87 = 2082;
      int v88 = v41;
      __int16 v89 = 2082;
      __int16 v90 = v42;
      __int16 v91 = 1024;
      int v92 = 430;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Policy is prague", buf, 0x22u);
    }

    ACMContextDelete(v8, 0);
    return 3;
  }
  int v43 = sub_10021FFB4((uint64_t)NFSSEWrapper, "OsloPIN", v8, (uint64_t)&v84);
  if (v84)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v44 = NFLogGetLogger();
    if (v44)
    {
      int v45 = (void (*)(uint64_t, const char *, ...))v44;
      BOOL v46 = object_getClass(v3);
      BOOL v47 = class_isMetaClass(v46);
      id v48 = object_getClassName(v3);
      int v49 = sel_getName("acmGetOlsoType:");
      uint64_t v50 = 45;
      if (v47) {
        uint64_t v50 = 43;
      }
      v45(3, "%c[%{public}s %{public}s]:%i Error verifying with PIN policy: %d", v50, v48, v49, 438, v84);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v51 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
    {
      id v52 = object_getClass(v3);
      if (class_isMetaClass(v52)) {
        int v53 = 43;
      }
      else {
        int v53 = 45;
      }
      char v54 = object_getClassName(v3);
      BOOL v55 = sel_getName("acmGetOlsoType:");
      *(_DWORD *)id buf = 67110146;
      int v86 = v53;
      __int16 v87 = 2082;
      int v88 = v54;
      __int16 v89 = 2082;
      __int16 v90 = v55;
      __int16 v91 = 1024;
      int v92 = 438;
      __int16 v93 = 1024;
      unsigned int v94 = v84;
      _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error verifying with PIN policy: %d", buf, 0x28u);
    }

    goto LABEL_47;
  }
  if (v43)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v56 = NFLogGetLogger();
    if (v56)
    {
      int v57 = (void (*)(uint64_t, const char *, ...))v56;
      uint64_t v58 = object_getClass(v3);
      BOOL v59 = class_isMetaClass(v58);
      __int16 v60 = object_getClassName(v3);
      id v82 = sel_getName("acmGetOlsoType:");
      uint64_t v61 = 45;
      if (v59) {
        uint64_t v61 = 43;
      }
      v57(6, "%c[%{public}s %{public}s]:%i Policy is oslo PIN", v61, v60, v82, 443);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v62 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
    {
      int v63 = object_getClass(v3);
      if (class_isMetaClass(v63)) {
        int v64 = 43;
      }
      else {
        int v64 = 45;
      }
      id v65 = object_getClassName(v3);
      BOOL v66 = sel_getName("acmGetOlsoType:");
      *(_DWORD *)id buf = 67109890;
      int v86 = v64;
      __int16 v87 = 2082;
      int v88 = v65;
      __int16 v89 = 2082;
      __int16 v90 = v66;
      __int16 v91 = 1024;
      int v92 = 443;
      _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Policy is oslo PIN", buf, 0x22u);
    }

    ACMContextDelete(v8, 0);
    return 2;
  }
  else
  {
    int v67 = sub_10021FFB4((uint64_t)NFSSEWrapper, "Oslo", v8, (uint64_t)&v84);
    if (v84 || !v67)
    {
LABEL_47:
      ACMContextDelete(v8, 0);
      return 0;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v68 = NFLogGetLogger();
    if (v68)
    {
      uint64_t v69 = (void (*)(uint64_t, const char *, ...))v68;
      int v70 = object_getClass(v3);
      BOOL v71 = class_isMetaClass(v70);
      int v72 = object_getClassName(v3);
      __int16 v83 = sel_getName("acmGetOlsoType:");
      uint64_t v73 = 45;
      if (v71) {
        uint64_t v73 = 43;
      }
      v69(6, "%c[%{public}s %{public}s]:%i Policy is oslo", v73, v72, v83, 450);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v74 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
    {
      id v75 = object_getClass(v3);
      if (class_isMetaClass(v75)) {
        int v76 = 43;
      }
      else {
        int v76 = 45;
      }
      uint64_t v77 = object_getClassName(v3);
      int v78 = sel_getName("acmGetOlsoType:");
      *(_DWORD *)id buf = 67109890;
      int v86 = v76;
      __int16 v87 = 2082;
      int v88 = v77;
      __int16 v89 = 2082;
      __int16 v90 = v78;
      __int16 v91 = 1024;
      int v92 = 450;
      _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Policy is oslo", buf, 0x22u);
    }

    ACMContextDelete(v8, 0);
    return 1;
  }
}

__CFData *sub_100220920(uint64_t a1, int a2, void *a3, uint64_t a4, void *a5, void *a6, char a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15)
{
  CFDataRef v19 = a11;
  CFDataRef v20 = a10;
  CFDataRef v21 = a9;
  CFDataRef v22 = a6;
  CFDataRef v23 = a5;
  CFDataRef v24 = a3;
  uint64_t v25 = self;
  __int16 v60 = 0;
  if (a2 == 6)
  {
    uint64_t v26 = a4;
    uint64_t v27 = SSEAuthorizeAndSignAPDU(6, v23, a4, v22, v21, v20, v19, v24, &v60);

    __int16 v29 = a13;
    int v28 = a15;
    int v30 = a12;
  }
  else
  {
    uint64_t v26 = a4;
    uint64_t v27 = SSEAuthorizeAndSignECommerceBlob(v23, a4, v22, a7, v21, v20, v19, v24, &v60);

    int v30 = a12;
    if (a12) {
      *a12 = 0;
    }
    __int16 v29 = a13;
    int v28 = a15;
    if (a13) {
      *a13 = 0;
    }
    if (a15) {
      *a15 = 0;
    }
  }
  if (v27)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    uint64_t v32 = v26;
    if (Logger)
    {
      uint64_t v33 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v25);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(v25);
      uint64_t Name = sel_getName("authorizeAndSign:requestBlob:uid:handle:SEID:usePIN:hasPrague:hostChallenge:cardChallenge:cardCryptogram:confirmationBlob:confirmationBlobSignature:confirmationVersion:certs:");
      uint64_t v37 = 45;
      if (isMetaClass) {
        uint64_t v37 = 43;
      }
      v33(3, "%c[%{public}s %{public}s]:%i Failed to authorize: %d for uid %d", v37, ClassName, Name, 547, v27, v32);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v38 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
    {
      __int16 v39 = object_getClass(v25);
      if (class_isMetaClass(v39)) {
        int v40 = 43;
      }
      else {
        int v40 = 45;
      }
      uint32_t v41 = object_getClassName(v25);
      uint64_t v42 = sel_getName("authorizeAndSign:requestBlob:uid:handle:SEID:usePIN:hasPrague:hostChallenge:cardChallenge:cardCryptogram:confirmationBlob:confirmationBlobSignature:confirmationVersion:certs:");
      *(_DWORD *)id buf = 67110402;
      int v62 = v40;
      __int16 v63 = 2082;
      int v64 = v41;
      __int16 v65 = 2082;
      BOOL v66 = v42;
      __int16 v67 = 1024;
      int v68 = 547;
      __int16 v69 = 1024;
      int v70 = v27;
      __int16 v71 = 1024;
      int v72 = v32;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to authorize: %d for uid %d", buf, 0x2Eu);
    }

LABEL_20:
    int v43 = 0;
    goto LABEL_21;
  }
  int v43 = v60;
  if (!v60)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v45 = NFLogGetLogger();
    if (v45)
    {
      BOOL v46 = (void (*)(uint64_t, const char *, ...))v45;
      BOOL v47 = object_getClass(v25);
      BOOL v48 = class_isMetaClass(v47);
      int v49 = object_getClassName(v25);
      int v57 = sel_getName("authorizeAndSign:requestBlob:uid:handle:SEID:usePIN:hasPrague:hostChallenge:cardChallenge:cardCryptogram:confirmationBlob:confirmationBlobSignature:confirmationVersion:certs:");
      uint64_t v50 = 45;
      if (v48) {
        uint64_t v50 = 43;
      }
      v46(3, "%c[%{public}s %{public}s]:%i Failed to get signed APDU, no error though", v50, v49, v57, 552);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v51 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
    {
      id v52 = object_getClass(v25);
      if (class_isMetaClass(v52)) {
        int v53 = 43;
      }
      else {
        int v53 = 45;
      }
      char v54 = object_getClassName(v25);
      BOOL v55 = sel_getName("authorizeAndSign:requestBlob:uid:handle:SEID:usePIN:hasPrague:hostChallenge:cardChallenge:cardCryptogram:confirmationBlob:confirmationBlobSignature:confirmationVersion:certs:");
      *(_DWORD *)id buf = 67109890;
      int v62 = v53;
      __int16 v63 = 2082;
      int v64 = v54;
      __int16 v65 = 2082;
      BOOL v66 = v55;
      __int16 v67 = 1024;
      int v68 = 552;
      _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get signed APDU, no error though", buf, 0x22u);
    }

    goto LABEL_20;
  }
  if (a14) {
    *a14 = 0;
  }
  if (v30) {
    void *v30 = 0;
  }
  if (v29) {
    *__int16 v29 = 0;
  }
  if (v28) {
    *int v28 = 0;
  }
LABEL_21:

  return v43;
}

id sub_100220D84(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7)
{
  id v11 = a6;
  CFDataRef v12 = a5;
  CFDataRef v13 = a4;
  CFDataRef v14 = a3;
  uint64_t v15 = a2;
  BOOL v66 = self;
  CFDataRef v16 = +[NFTLV TLVWithTag:4 value:v11];

  v86[0] = v16;
  id v17 = objc_opt_new();
  int v18 = +[NFTLV TLVWithTag:4 value:v17];
  v86[1] = v18;
  CFDataRef v19 = +[NSArray arrayWithObjects:v86 count:2];
  CFDataRef v20 = +[NFTLV TLVWithTag:48 children:v19];
  CFDataRef v21 = [v20 asData];

  __int16 v69 = 0;
  int v70 = 0;
  CFDataRef v22 = +[NSData data];
  CFDataRef v67 = v21;
  uint64_t v23 = SSEEvaluateSecureElementACL(v14, v12, v21, v22, v15, v13, 3u, &v70, &v69);

  CFDataRef v24 = v69;
  uint64_t v25 = v70;
  if (v23)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v27 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v66);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(v66);
      uint64_t Name = sel_getName("getSignedOperationApproval:handle:nonce:SEID:acl:error:");
      uint64_t v30 = 45;
      if (isMetaClass) {
        uint64_t v30 = 43;
      }
      v27(3, "%c[%{public}s %{public}s]:%i Failed to authorize: %d", v30, ClassName, Name, 596, v23);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v31 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      uint64_t v32 = object_getClass(v66);
      if (class_isMetaClass(v32)) {
        int v33 = 43;
      }
      else {
        int v33 = 45;
      }
      uint64_t v34 = object_getClassName(v66);
      BOOL v35 = sel_getName("getSignedOperationApproval:handle:nonce:SEID:acl:error:");
      *(_DWORD *)id buf = 67110146;
      int v77 = v33;
      __int16 v78 = 2082;
      __int16 v79 = v34;
      __int16 v80 = 2082;
      __int16 v81 = v35;
      __int16 v82 = 1024;
      int v83 = 596;
      __int16 v84 = 1024;
      int v85 = v23;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to authorize: %d", buf, 0x28u);
    }

    if (!a7)
    {
      BOOL v46 = 0;
      goto LABEL_29;
    }
    int v36 = v24;
    uint64_t v37 = v25;
    id v38 = objc_alloc((Class)NSError);
    __int16 v39 = +[NSString stringWithUTF8String:"nfcd"];
    v74[0] = NSLocalizedDescriptionKey;
    int v40 = +[NSString stringWithUTF8String:"Security Violation"];
    v75[0] = v40;
    v75[1] = &off_10031FAE0;
    v74[1] = @"Line";
    v74[2] = @"Method";
    id v41 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("getSignedOperationApproval:handle:nonce:SEID:acl:error:")];
    v75[2] = v41;
    v74[3] = NSDebugDescriptionErrorKey;
    id v42 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("getSignedOperationApproval:handle:nonce:SEID:acl:error:"), 598];
    v75[3] = v42;
    void v74[4] = NSLocalizedFailureReasonErrorKey;
    id v43 = [objc_alloc((Class)NSString) initWithFormat:@"SSE refused w/ %d", v23];
    void v75[4] = v43;
    uint64_t v44 = +[NSDictionary dictionaryWithObjects:v75 forKeys:v74 count:5];
    uint64_t v45 = v38;
    uint64_t v25 = v37;
    CFDataRef v24 = v36;
    *a7 = [v45 initWithDomain:v39 code:8 userInfo:v44];

    BOOL v46 = 0;
    goto LABEL_28;
  }
  if (v70 && v69)
  {
    __int16 v39 = +[NFTLV TLVWithTag:48 fromData:v70];
    v71[0] = v39;
    int v40 = +[NFTLV TLVWithTag:4 value:v24];
    v71[1] = v40;
    id v41 = +[NSArray arrayWithObjects:v71 count:2];
    id v42 = +[NFTLV TLVWithTag:236 children:v41];
    BOOL v46 = [v42 asData];
LABEL_28:

    goto LABEL_29;
  }
  BOOL v47 = v70;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v48 = NFLogGetLogger();
  if (v48)
  {
    int v49 = (void (*)(uint64_t, const char *, ...))v48;
    uint64_t v50 = object_getClass(v66);
    BOOL v51 = class_isMetaClass(v50);
    id v52 = object_getClassName(v66);
    __int16 v65 = sel_getName("getSignedOperationApproval:handle:nonce:SEID:acl:error:");
    uint64_t v53 = 45;
    if (v51) {
      uint64_t v53 = 43;
    }
    v49(3, "%c[%{public}s %{public}s]:%i Failed to get operation approval, no error though", v53, v52, v65, 603);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  char v54 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
  {
    BOOL v55 = object_getClass(v66);
    if (class_isMetaClass(v55)) {
      int v56 = 43;
    }
    else {
      int v56 = 45;
    }
    int v57 = object_getClassName(v66);
    uint64_t v58 = sel_getName("getSignedOperationApproval:handle:nonce:SEID:acl:error:");
    *(_DWORD *)id buf = 67109890;
    int v77 = v56;
    __int16 v78 = 2082;
    __int16 v79 = v57;
    __int16 v80 = 2082;
    __int16 v81 = v58;
    __int16 v82 = 1024;
    int v83 = 603;
    _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get operation approval, no error though", buf, 0x22u);
  }

  if (a7)
  {
    id v59 = objc_alloc((Class)NSError);
    __int16 v39 = +[NSString stringWithUTF8String:"nfcd"];
    v72[0] = NSLocalizedDescriptionKey;
    int v40 = +[NSString stringWithUTF8String:"Unknown Error"];
    v73[0] = v40;
    v73[1] = &off_10031FAF8;
    v72[1] = @"Line";
    v72[2] = @"Method";
    id v41 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("getSignedOperationApproval:handle:nonce:SEID:acl:error:")];
    v73[2] = v41;
    v72[3] = NSDebugDescriptionErrorKey;
    id v42 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", @"getSignedOperationApproval:handle:nonce:SEID:acl:error:", 605];
    v73[3] = v42;
    v72[4] = NSLocalizedFailureReasonErrorKey;
    id v60 = [objc_alloc((Class)NSString) initWithFormat:@"SSE inconsistent return"];
    v73[4] = v60;
    uint64_t v61 = +[NSDictionary dictionaryWithObjects:v73 forKeys:v72 count:5];
    *a7 = [v59 initWithDomain:v39 code:6 userInfo:v61];

    BOOL v46 = 0;
    uint64_t v25 = v47;
    goto LABEL_28;
  }
  BOOL v46 = 0;
  uint64_t v25 = v47;
LABEL_29:

  return v46;
}

id sub_10022156C(uint64_t a1, void *a2, void *a3)
{
  CFDataRef v4 = a3;
  uint64_t v5 = self;
  unsigned int v75 = 0;
  id v74 = 0;
  if (!a2 || !v4)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v26 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v5);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(v5);
      uint64_t Name = sel_getName("getPlatformData:forSEID:");
      uint64_t v30 = 45;
      if (isMetaClass) {
        uint64_t v30 = 43;
      }
      v26(3, "%c[%{public}s %{public}s]:%i Invalid parameter", v30, ClassName, Name, 627);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v31 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      uint64_t v32 = object_getClass(v5);
      if (class_isMetaClass(v32)) {
        int v33 = 43;
      }
      else {
        int v33 = 45;
      }
      *(_DWORD *)id buf = 67109890;
      int v85 = v33;
      __int16 v86 = 2082;
      __int16 v87 = object_getClassName(v5);
      __int16 v88 = 2082;
      __int16 v89 = sel_getName("getPlatformData:forSEID:");
      __int16 v90 = 1024;
      int v91 = 627;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid parameter", buf, 0x22u);
    }

    id v34 = objc_alloc((Class)NSError);
    CFDataRef v19 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v94 = NSLocalizedDescriptionKey;
    CFDataRef v20 = +[NSString stringWithUTF8String:"Invalid Parameter"];
    id v95 = v20;
    CFDataRef v21 = +[NSDictionary dictionaryWithObjects:&v95 forKeys:&v94 count:1];
    CFDataRef v22 = v34;
    uint64_t v23 = v19;
    uint64_t v24 = 10;
    goto LABEL_24;
  }
  uint64_t v6 = SSEGetVersion(&v75);
  if (v6)
  {
    uint64_t v7 = v6;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v8 = NFLogGetLogger();
    if (v8)
    {
      int v9 = (void (*)(uint64_t, const char *, ...))v8;
      uint64_t v10 = object_getClass(v5);
      BOOL v11 = class_isMetaClass(v10);
      __int16 v69 = object_getClassName(v5);
      __int16 v71 = sel_getName("getPlatformData:forSEID:");
      uint64_t v12 = 45;
      if (v11) {
        uint64_t v12 = 43;
      }
      v9(3, "%c[%{public}s %{public}s]:%i Failed to get SSE version : %d", v12, v69, v71, 633, v7);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    CFDataRef v13 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      CFDataRef v14 = object_getClass(v5);
      if (class_isMetaClass(v14)) {
        int v15 = 43;
      }
      else {
        int v15 = 45;
      }
      CFDataRef v16 = object_getClassName(v5);
      id v17 = sel_getName("getPlatformData:forSEID:");
      *(_DWORD *)id buf = 67110146;
      int v85 = v15;
      __int16 v86 = 2082;
      __int16 v87 = v16;
      __int16 v88 = 2082;
      __int16 v89 = v17;
      __int16 v90 = 1024;
      int v91 = 633;
      __int16 v92 = 1024;
      unsigned int v93 = v7;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get SSE version : %d", buf, 0x28u);
    }

    id v18 = objc_alloc((Class)NSError);
    CFDataRef v19 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v82 = NSLocalizedDescriptionKey;
    CFDataRef v20 = +[NSString stringWithUTF8String:"Unexpected Result"];
    int v83 = v20;
    CFDataRef v21 = +[NSDictionary dictionaryWithObjects:&v83 forKeys:&v82 count:1];
    CFDataRef v22 = v18;
    uint64_t v23 = v19;
    uint64_t v24 = 13;
LABEL_24:
    id v35 = [v22 initWithDomain:v23 code:v24 userInfo:v21];

    goto LABEL_25;
  }
  if (v75 <= 1)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v37 = NFLogGetLogger();
    if (v37)
    {
      id v38 = (void (*)(uint64_t, const char *, ...))v37;
      __int16 v39 = object_getClass(v5);
      BOOL v40 = class_isMetaClass(v39);
      id v41 = object_getClassName(v5);
      id v42 = sel_getName("getPlatformData:forSEID:");
      uint64_t v43 = 45;
      if (v40) {
        uint64_t v43 = 43;
      }
      v38(3, "%c[%{public}s %{public}s]:%i SSE version too old : %d", v43, v41, v42, 637, v75);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v44 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
      uint64_t v45 = object_getClass(v5);
      if (class_isMetaClass(v45)) {
        int v46 = 43;
      }
      else {
        int v46 = 45;
      }
      BOOL v47 = object_getClassName(v5);
      uint64_t v48 = sel_getName("getPlatformData:forSEID:");
      *(_DWORD *)id buf = 67110146;
      int v85 = v46;
      __int16 v86 = 2082;
      __int16 v87 = v47;
      __int16 v88 = 2082;
      __int16 v89 = v48;
      __int16 v90 = 1024;
      int v91 = 637;
      __int16 v92 = 1024;
      unsigned int v93 = v75;
      _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i SSE version too old : %d", buf, 0x28u);
    }

    id v49 = objc_alloc((Class)NSError);
    CFDataRef v19 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v80 = NSLocalizedDescriptionKey;
    CFDataRef v20 = +[NSString stringWithUTF8String:"Feature Not Supported"];
    __int16 v81 = v20;
    CFDataRef v21 = +[NSDictionary dictionaryWithObjects:&v81 forKeys:&v80 count:1];
    CFDataRef v22 = v49;
    uint64_t v23 = v19;
    uint64_t v24 = 14;
    goto LABEL_24;
  }
  uint64_t v50 = SSEGetSignedDeviceData(v4, (CFDataRef *)&v74);
  if (v50)
  {
    uint64_t v51 = v50;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v52 = NFLogGetLogger();
    if (v52)
    {
      uint64_t v53 = (void (*)(uint64_t, const char *, ...))v52;
      char v54 = object_getClass(v5);
      BOOL v55 = class_isMetaClass(v54);
      int v70 = object_getClassName(v5);
      uint64_t v73 = sel_getName("getPlatformData:forSEID:");
      uint64_t v56 = 45;
      if (v55) {
        uint64_t v56 = 43;
      }
      v53(3, "%c[%{public}s %{public}s]:%i Failed to get platform data : %d", v56, v70, v73, 644, v51);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v57 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
    {
      uint64_t v58 = object_getClass(v5);
      if (class_isMetaClass(v58)) {
        int v59 = 43;
      }
      else {
        int v59 = 45;
      }
      id v60 = object_getClassName(v5);
      uint64_t v61 = sel_getName("getPlatformData:forSEID:");
      *(_DWORD *)id buf = 67110146;
      int v85 = v59;
      __int16 v86 = 2082;
      __int16 v87 = v60;
      __int16 v88 = 2082;
      __int16 v89 = v61;
      __int16 v90 = 1024;
      int v91 = 644;
      __int16 v92 = 1024;
      unsigned int v93 = v51;
      _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get platform data : %d", buf, 0x28u);
    }

    id v62 = objc_alloc((Class)NSError);
    __int16 v63 = +[NSString stringWithUTF8String:"nfcd"];
    if (v51 == -10)
    {
      NSErrorUserInfoKey v78 = NSLocalizedDescriptionKey;
      int v64 = +[NSString stringWithUTF8String:"Keychain locked"];
      __int16 v79 = v64;
      __int16 v65 = +[NSDictionary dictionaryWithObjects:&v79 forKeys:&v78 count:1];
      BOOL v66 = v62;
      CFDataRef v67 = v63;
      uint64_t v68 = 41;
    }
    else
    {
      NSErrorUserInfoKey v76 = NSLocalizedDescriptionKey;
      int v64 = +[NSString stringWithUTF8String:"Security Violation"];
      int v77 = v64;
      __int16 v65 = +[NSDictionary dictionaryWithObjects:&v77 forKeys:&v76 count:1];
      BOOL v66 = v62;
      CFDataRef v67 = v63;
      uint64_t v68 = 8;
    }
    id v35 = [v66 initWithDomain:v67 code:v68 userInfo:v65];
  }
  else
  {
    id v35 = 0;
    *a2 = v74;
  }
LABEL_25:

  return v35;
}

BOOL sub_100221D9C(uint64_t a1, void *a2)
{
  id v3 = self;
  unsigned int v22 = 0;
  uint64_t v4 = SSEGetVersion(&v22);
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v6 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(v3);
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(v3);
    uint64_t Name = sel_getName("supportsAuthorizeAndSign:");
    uint64_t v11 = 45;
    if (isMetaClass) {
      uint64_t v11 = 43;
    }
    v6(6, "%c[%{public}s %{public}s]:%i SSEGetVersion version=0x%x, status=%d", v11, ClassName, Name, 665, v22, v4);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v12 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    CFDataRef v13 = object_getClass(v3);
    if (class_isMetaClass(v13)) {
      int v14 = 43;
    }
    else {
      int v14 = 45;
    }
    int v15 = object_getClassName(v3);
    CFDataRef v16 = sel_getName("supportsAuthorizeAndSign:");
    *(_DWORD *)id buf = 67110402;
    int v26 = v14;
    __int16 v27 = 2082;
    int v28 = v15;
    __int16 v29 = 2082;
    uint64_t v30 = v16;
    __int16 v31 = 1024;
    int v32 = 665;
    __int16 v33 = 1024;
    unsigned int v34 = v22;
    __int16 v35 = 1024;
    int v36 = v4;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i SSEGetVersion version=0x%x, status=%d", buf, 0x2Eu);
  }

  if (!v4) {
    return v22 > 1;
  }
  if (a2)
  {
    id v17 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v23 = NSLocalizedDescriptionKey;
    CFDataRef v19 = +[NSString stringWithUTF8String:"Unknown Error"];
    uint64_t v24 = v19;
    CFDataRef v20 = +[NSDictionary dictionaryWithObjects:&v24 forKeys:&v23 count:1];
    *a2 = [v17 initWithDomain:v18 code:6 userInfo:v20];
  }
  return 0;
}

BOOL sub_100222018()
{
  return !SSEIsFeatureSupported(46)
      && !SSEIsFeatureSupported(47)
      && SSEIsFeatureSupported(48) == 0;
}

uint64_t sub_100222060(uint64_t a1, void *a2)
{
  CFDataRef v2 = a2;
  id v3 = self;
  unsigned int v19 = 0;
  uint64_t v4 = SSEGetAuthKeySharingState(v2, &v19);

  if (v4)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v3);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(v3);
      uint64_t Name = sel_getName("getSharingState:");
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v6(3, "%c[%{public}s %{public}s]:%i Failed to get SSE sharing state : %d", v9, ClassName, Name, 694, v4);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      uint64_t v11 = object_getClass(v3);
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      CFDataRef v13 = object_getClassName(v3);
      int v14 = sel_getName("getSharingState:");
      *(_DWORD *)id buf = 67110146;
      int v21 = v12;
      __int16 v22 = 2082;
      NSErrorUserInfoKey v23 = v13;
      __int16 v24 = 2082;
      uint64_t v25 = v14;
      __int16 v26 = 1024;
      int v27 = 694;
      __int16 v28 = 1024;
      int v29 = v4;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get SSE sharing state : %d", buf, 0x28u);
    }

    return 0;
  }
  else
  {
    unsigned __int8 v15 = v19;
    if (v19 >= 4) {
      return 0;
    }
  }
  return v15;
}

id sub_100222240(uint64_t a1, void *a2)
{
  id v2 = a2;
  id v3 = self;
  uint64_t v4 = [v2 NF_asHexString];
  uint64_t v5 = [v4 uppercaseString];

  v60[0] = @"VerifyData";
  v60[1] = @"StripImg4";
  v61[0] = &__kCFBooleanFalse;
  v61[1] = &__kCFBooleanFalse;
  v60[2] = @"GetCombined";
  v61[2] = &__kCFBooleanTrue;
  uint64_t v6 = +[NSDictionary dictionaryWithObjects:v61 forKeys:v60 count:3];
  CFDataRef v7 = (const __CFData *)AMFDRSealingMapCopyLocalData();
  uint64_t v8 = SSESetSEPubKey((const __CFData *)v2, v7);
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  uint64_t v10 = (void (*)(uint64_t, const char *, ...))Logger;
  if (v8)
  {
    if (Logger)
    {
      Class = object_getClass(v3);
      BOOL isMetaClass = class_isMetaClass(Class);
      id v13 = v2;
      CFDataRef v14 = v7;
      unsigned __int8 v15 = v6;
      CFDataRef v16 = v5;
      Classuint64_t Name = object_getClassName(v3);
      uint64_t Name = sel_getName("setSEPublicKeyWithSEID:");
      uint64_t v18 = 45;
      if (isMetaClass) {
        uint64_t v18 = 43;
      }
      id v41 = ClassName;
      uint64_t v5 = v16;
      uint64_t v6 = v15;
      CFDataRef v7 = v14;
      id v2 = v13;
      v10(3, "%c[%{public}s %{public}s]:%i Failed to set SE Public key : %d", v18, v41, Name, 733, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    unsigned int v19 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      CFDataRef v20 = object_getClass(v3);
      id v21 = v2;
      CFDataRef v22 = v7;
      NSErrorUserInfoKey v23 = v6;
      __int16 v24 = v5;
      if (class_isMetaClass(v20)) {
        int v25 = 43;
      }
      else {
        int v25 = 45;
      }
      *(_DWORD *)id buf = 67110146;
      int v45 = v25;
      uint64_t v5 = v24;
      uint64_t v6 = v23;
      CFDataRef v7 = v22;
      id v2 = v21;
      __int16 v46 = 2082;
      BOOL v47 = object_getClassName(v3);
      __int16 v48 = 2082;
      id v49 = sel_getName("setSEPublicKeyWithSEID:");
      __int16 v50 = 1024;
      int v51 = 733;
      __int16 v52 = 1024;
      LODWORD(v53) = v8;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set SE Public key : %d", buf, 0x28u);
    }

    id v26 = objc_alloc((Class)NSError);
    int v27 = +[NSString stringWithUTF8String:"nfcd"];
    if (v8 == -10)
    {
      NSErrorUserInfoKey v58 = NSLocalizedDescriptionKey;
      __int16 v28 = +[NSString stringWithUTF8String:"Keychain locked"];
      int v59 = v28;
      int v29 = +[NSDictionary dictionaryWithObjects:&v59 forKeys:&v58 count:1];
      uint64_t v30 = v26;
      __int16 v31 = v27;
      uint64_t v32 = 41;
    }
    else
    {
      NSErrorUserInfoKey v56 = NSLocalizedDescriptionKey;
      __int16 v28 = +[NSString stringWithUTF8String:"Security Violation"];
      int v57 = v28;
      int v29 = +[NSDictionary dictionaryWithObjects:&v57 forKeys:&v56 count:1];
      uint64_t v30 = v26;
      __int16 v31 = v27;
      uint64_t v32 = 8;
    }
    id v39 = [v30 initWithDomain:v31 code:v32 userInfo:v29];
  }
  else
  {
    if (Logger)
    {
      __int16 v33 = object_getClass(v3);
      BOOL v34 = class_isMetaClass(v33);
      __int16 v35 = object_getClassName(v3);
      uint64_t v43 = sel_getName("setSEPublicKeyWithSEID:");
      uint64_t v36 = 45;
      if (v34) {
        uint64_t v36 = 43;
      }
      v10(6, "%c[%{public}s %{public}s]:%i Successfully set SE Public key %{public}@ for SEID %{public}@", v36, v35, v43, 741, v7, v2);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v27 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v37 = object_getClass(v3);
      if (class_isMetaClass(v37)) {
        int v38 = 43;
      }
      else {
        int v38 = 45;
      }
      *(_DWORD *)id buf = 67110402;
      int v45 = v38;
      __int16 v46 = 2082;
      BOOL v47 = object_getClassName(v3);
      __int16 v48 = 2082;
      id v49 = sel_getName("setSEPublicKeyWithSEID:");
      __int16 v50 = 1024;
      int v51 = 741;
      __int16 v52 = 2114;
      CFDataRef v53 = v7;
      __int16 v54 = 2114;
      id v55 = v2;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Successfully set SE Public key %{public}@ for SEID %{public}@", buf, 0x36u);
    }
    id v39 = 0;
  }

  return v39;
}

id sub_1002229C4(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  CFDataRef v10 = a4;
  CFDataRef v11 = a3;
  CFDataRef v12 = a2;
  id v13 = self;
  id v36 = 0;
  id v37 = 0;
  uint64_t v14 = SSEPerformAuthKeySharing(v10, v12, v11, (CFDataRef *)&v37, (CFDataRef *)&v36);

  if (v14)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      CFDataRef v16 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v13);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(v13);
      uint64_t Name = sel_getName("performSharing:signature:SEID:hostEphPK:hostEphPKSignature:");
      uint64_t v19 = 45;
      if (isMetaClass) {
        uint64_t v19 = 43;
      }
      v16(3, "%c[%{public}s %{public}s]:%i Failed to set SE Public key : %d", v19, ClassName, Name, 762, v14);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    CFDataRef v20 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      id v21 = object_getClass(v13);
      if (class_isMetaClass(v21)) {
        int v22 = 43;
      }
      else {
        int v22 = 45;
      }
      NSErrorUserInfoKey v23 = object_getClassName(v13);
      __int16 v24 = sel_getName("performSharing:signature:SEID:hostEphPK:hostEphPKSignature:");
      *(_DWORD *)id buf = 67110146;
      int v43 = v22;
      __int16 v44 = 2082;
      int v45 = v23;
      __int16 v46 = 2082;
      BOOL v47 = v24;
      __int16 v48 = 1024;
      int v49 = 762;
      __int16 v50 = 1024;
      int v51 = v14;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set SE Public key : %d", buf, 0x28u);
    }

    id v25 = objc_alloc((Class)NSError);
    id v26 = +[NSString stringWithUTF8String:"nfcd"];
    if (v14 == -10)
    {
      NSErrorUserInfoKey v40 = NSLocalizedDescriptionKey;
      int v27 = +[NSString stringWithUTF8String:"Keychain locked"];
      id v41 = v27;
      __int16 v28 = +[NSDictionary dictionaryWithObjects:&v41 forKeys:&v40 count:1];
      int v29 = v25;
      uint64_t v30 = v26;
      uint64_t v31 = 41;
    }
    else
    {
      NSErrorUserInfoKey v38 = NSLocalizedDescriptionKey;
      int v27 = +[NSString stringWithUTF8String:"Security Violation"];
      id v39 = v27;
      __int16 v28 = +[NSDictionary dictionaryWithObjects:&v39 forKeys:&v38 count:1];
      int v29 = v25;
      uint64_t v30 = v26;
      uint64_t v31 = 8;
    }
    id v32 = [v29 initWithDomain:v30 code:v31 userInfo:v28];
  }
  else
  {
    *a5 = v37;
    id v32 = 0;
    *a6 = v36;
  }

  return v32;
}

void sub_100222CE8(id a1)
{
  uint64_t v1 = objc_opt_new();
  uint64_t v2 = qword_1003476A0;
  qword_1003476A0 = v1;

  _objc_release_x1(v1, v2);
}

void sub_100222D30(uint64_t a1, void *a2)
{
  id v2 = a2;
  self;
  id v3 = sub_100222E80();
  v7[0] = @"totalCEEnable";
  v7[1] = @"totalAuthEvents";
  v8[0] = &off_10031FB28;
  v8[1] = &off_10031FB28;
  v7[2] = @"totalDeAuth";
  v7[3] = @"totalAuthECommerce";
  v8[2] = &off_10031FB28;
  v8[3] = &off_10031FB28;
  v7[4] = @"dailyDeviceUUID";
  v8[4] = v3;
  uint64_t v4 = +[NSDictionary dictionaryWithObjects:v8 forKeys:v7 count:5];
  uint64_t v5 = +[NSMutableDictionary dictionaryWithDictionary:v4];

  [v5 setObject:&off_10031FB40 forKeyedSubscript:v2];
  uint64_t v6 = +[NFCALogger sharedCALogger];
  [v6 postCAEventFor:@"com.apple.nfcd.crsAuthOperationStatistic" eventInput:v5];
}

__CFString *sub_100222E80()
{
  self;
  uint64_t v0 = +[NFCALogger sharedCALogger];
  uint64_t v1 = [v0 generateDailyUUIDForCA];

  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    id v2 = v1;
  }
  else {
    id v2 = @"noUUID";
  }

  return v2;
}

void sub_100222F0C(uint64_t a1, void *a2)
{
  id v2 = a2;
  self;
  id v4 = [v2 mutableCopy];

  id v3 = +[NFCALogger sharedCALogger];
  [v3 postCAEventFor:@"com.apple.nfcd.version" eventInput:v4];
}

void sub_100222F90(uint64_t a1, void *a2, uint64_t a3)
{
  id v4 = a2;
  self;
  v14[0] = @"counter";
  uint64_t v5 = +[NSNumber numberWithUnsignedInt:a3];
  v15[0] = v5;
  v14[1] = @"JCOP_Dev";
  uint64_t v6 = +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", [v4 signingKeyType] == (id)1);
  v15[1] = v6;
  void v14[2] = @"OSVersion";
  uint64_t v7 = [v4 sequenceCounter];
  uint64_t v8 = (void *)v7;
  uint64_t v9 = &off_10031FB28;
  if (v7) {
    uint64_t v9 = (_UNKNOWN **)v7;
  }
  void v15[2] = v9;
  void v14[3] = @"platformIdentifier";
  CFDataRef v10 = [v4 platformIdentifier];

  CFStringRef v11 = &stru_100309C40;
  if (v10) {
    CFStringRef v11 = v10;
  }
  v15[3] = v11;
  CFDataRef v12 = +[NSDictionary dictionaryWithObjects:v15 forKeys:v14 count:4];

  id v13 = +[NFCALogger sharedCALogger];
  [v13 postCAEventFor:@"nfcd.exceptions.seAppletMigrationFailure" eventInput:v12];
}

id sub_100223124()
{
  uint64_t v0 = self;
  uint64_t v1 = +[NFCALogger sharedCALogger];
  id v2 = [v1 getCALoggerUserDefaults];

  id v3 = [v2 objectForKey:@"flashCounters"];
  if (!v3)
  {
LABEL_32:
    id v9 = 0;
    goto LABEL_33;
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      CFStringRef v11 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v0);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(v0);
      uint64_t Name = sel_getName("_getStoredCounters");
      uint64_t v15 = 45;
      if (isMetaClass) {
        uint64_t v15 = 43;
      }
      v11(3, "%c[%{public}s %{public}s]:%i Unexpected type in storage", v15, ClassName, Name, 77);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    CFDataRef v16 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      id v17 = object_getClass(v0);
      if (class_isMetaClass(v17)) {
        int v18 = 43;
      }
      else {
        int v18 = 45;
      }
      *(_DWORD *)id buf = 67109890;
      int v39 = v18;
      __int16 v40 = 2082;
      id v41 = object_getClassName(v0);
      __int16 v42 = 2082;
      int v43 = sel_getName("_getStoredCounters");
      __int16 v44 = 1024;
      int v45 = 77;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected type in storage", buf, 0x22u);
    }

    [v2 removeObjectForKey:@"flashCounters"];
    goto LABEL_32;
  }
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  id v4 = v3;
  uint64_t v5 = (char *)[v4 countByEnumeratingWithState:&v33 objects:v37 count:16];
  if (v5)
  {
    uint64_t v6 = v5;
    uint64_t v7 = *(void *)v34;
    while (2)
    {
      for (i = 0; i != v6; ++i)
      {
        if (*(void *)v34 != v7) {
          objc_enumerationMutation(v4);
        }
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) == 0)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v19 = NFLogGetLogger();
          if (v19)
          {
            CFDataRef v20 = (void (*)(uint64_t, const char *, ...))v19;
            id v21 = object_getClass(v0);
            BOOL v22 = class_isMetaClass(v21);
            NSErrorUserInfoKey v23 = object_getClassName(v0);
            id v32 = sel_getName("_getStoredCounters");
            uint64_t v24 = 45;
            if (v22) {
              uint64_t v24 = 43;
            }
            v20(3, "%c[%{public}s %{public}s]:%i Unexpected type in storage", v24, v23, v32, 84, v33);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v25 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            id v26 = object_getClass(v0);
            if (class_isMetaClass(v26)) {
              int v27 = 43;
            }
            else {
              int v27 = 45;
            }
            __int16 v28 = object_getClassName(v0);
            int v29 = sel_getName("_getStoredCounters");
            *(_DWORD *)id buf = 67109890;
            int v39 = v27;
            __int16 v40 = 2082;
            id v41 = v28;
            __int16 v42 = 2082;
            int v43 = v29;
            __int16 v44 = 1024;
            int v45 = 84;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected type in storage", buf, 0x22u);
          }

          [v2 removeObjectForKey:@"flashCounters"];
          goto LABEL_32;
        }
      }
      uint64_t v6 = (char *)[v4 countByEnumeratingWithState:&v33 objects:v37 count:16];
      if (v6) {
        continue;
      }
      break;
    }
  }

  id v9 = v4;
LABEL_33:

  return v9;
}

void sub_10022352C(uint64_t a1, void *a2)
{
  id v2 = a2;
  self;
  id v3 = v2;
  self;
  id v4 = &AMFDRSealingMapCopyLocalData_ptr;
  uint64_t v5 = &AMFDRSealingMapCopyLocalData_ptr;
  if (NFIsInternalBuild())
  {
    uint64_t v6 = sub_100223124();
    uint64_t v7 = +[NFCALogger sharedCALogger];
    uint64_t v8 = [v7 getCALoggerUserDefaults];

    uint64_t v9 = [v8 objectForKey:@"flashCountersDate"];
    CFDataRef v10 = (void *)v9;
    if (v6 && v9)
    {
      CFStringRef v11 = +[NSDate now];
      id v12 = [objc_alloc((Class)NSCalendar) initWithCalendarIdentifier:NSCalendarIdentifierGregorian];
      id v13 = [v12 components:28 fromDate:v11];
      id v49 = v12;
      uint64_t v14 = [v12 components:28 fromDate:v10];
      id v15 = [v13 month];
      if (v15 != [v14 month] || (id v16 = objc_msgSend(v13, "day"), v16 != objc_msgSend(v14, "day")))
      {
        id v17 = [v6 count];
        if (v17 == [v3 count])
        {
          if ([v6 count])
          {
            BOOL v47 = v13;
            __int16 v48 = v11;
            unint64_t v18 = 0;
            while (1)
            {
              uint64_t v19 = [v6 objectAtIndex:v18];
              CFDataRef v20 = [v3 objectAtIndexedSubscript:v18];
              id v21 = [v20 unsignedLongValue];
              if ((unint64_t)(v21 - (unsigned char *)[v19 unsignedLongValue]) >= 0x2BD) {
                break;
              }
              ++v18;

              if (v18 >= (unint64_t)[v6 count])
              {
                BOOL v22 = 0;
                id v4 = &AMFDRSealingMapCopyLocalData_ptr;
                id v13 = v47;
                CFStringRef v11 = v48;
                goto LABEL_16;
              }
            }
            id v23 = [objc_alloc((Class)NSString) initWithFormat:@"Page %d was %@ is %@", v18, v19, v20];
            uint64_t v46 = [0 stringByAppendingFormat:@"%@%@", @" ; ", v23];
            sub_100198FF8((uint64_t)NFBugCapture, @"Excessive flash writes", v23, 0);
            if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)id buf = 138412290;
              id v52 = v23;
              _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT, "Flash page write exceeded %@", buf, 0xCu);
            }

            id v4 = &AMFDRSealingMapCopyLocalData_ptr;
            id v13 = v47;
            CFStringRef v11 = v48;
            BOOL v22 = (void *)v46;
          }
          else
          {
            BOOL v22 = 0;
          }
LABEL_16:
          +[NFExceptionsCALogger postAnalyticsSEFailureEvent:0 context:v22 error:0];
        }
      }

      uint64_t v5 = &AMFDRSealingMapCopyLocalData_ptr;
    }
  }
  uint64_t v24 = sub_100223124();
  id v25 = [v24 count];
  if (v25 != [v3 count])
  {

    uint64_t v24 = 0;
  }
  id v26 = objc_opt_new();
  if ([v3 count])
  {
    unint64_t v27 = 0;
    do
    {
      unint64_t v28 = v27 + 1;
      int v29 = [[v5[466] stringWithFormat:@"Page%02d", v27 + 1];
      uint64_t v30 = [v3 objectAtIndexedSubscript:v27];
      [v26 setObject:v30 forKeyedSubscript:v29];

      uint64_t v5 = &AMFDRSealingMapCopyLocalData_ptr;
      unint64_t v27 = v28;
    }
    while ((unint64_t)[v3 count] > v28);
  }
  uint64_t v31 = v24;
  if (v24)
  {
    id v32 = objc_opt_new();
    if ([v3 count])
    {
      unint64_t v33 = 0;
      do
      {
        unint64_t v34 = v33 + 1;
        long long v35 = [[v5[466] stringWithFormat:@"Page%02d", v33 + 1];
        id v36 = objc_alloc((Class)NSNumber);
        id v37 = [v3 objectAtIndexedSubscript:v33];
        unsigned int v38 = [v37 intValue];
        int v39 = [v31 objectAtIndexedSubscript:v33];
        id v40 = [v36 initWithInt:v38 - [v39 intValue]];
        [v32 setObject:v40 forKeyedSubscript:v35];

        uint64_t v5 = &AMFDRSealingMapCopyLocalData_ptr;
        unint64_t v33 = v34;
      }
      while ((unint64_t)[v3 count] > v34);
      id v4 = &AMFDRSealingMapCopyLocalData_ptr;
    }
  }
  else
  {
    id v32 = 0;
  }
  id v41 = +[NFCALogger sharedCALogger];
  [v41 postCAEventFor:@"com.apple.nfcd.flashCounterTotals" eventInput:v26];

  if (v32)
  {
    __int16 v42 = +[NFCALogger sharedCALogger];
    [v42 postCAEventFor:@"com.apple.nfcd.flashCounterDeltas" eventInput:v32];
  }
  id v50 = v3;
  self;
  int v43 = +[NFCALogger sharedCALogger];
  __int16 v44 = [v43 getCALoggerUserDefaults];

  [v44 setObject:v50 forKey:@"flashCounters"];
  int v45 = [v4[435] now];
  [v44 setObject:v45 forKey:@"flashCountersDate"];
}

void sub_100223B0C(uint64_t a1, void *a2)
{
  id v2 = a2;
  self;
  id v3 = sub_100222E80();
  v6[0] = @"dailyDeviceUUID";
  v6[1] = v2;
  v7[0] = v3;
  v7[1] = &off_10031FB40;
  id v4 = +[NSDictionary dictionaryWithObjects:v7 forKeys:v6 count:2];
  uint64_t v5 = +[NFCALogger sharedCALogger];

  [v5 postCAEventFor:@"com.apple.nfcd.deviceExceptionStatistic" eventInput:v4];
}

void sub_100228058(uint64_t a1)
{
  id v2 = NFSharedSignpostLog();
  if (os_signpost_enabled(v2))
  {
    *(_WORD *)id buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v2, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "SESHAT_ALLOCATE_SLOT", (const char *)&unk_100286819, buf, 2u);
  }

  int v62 = 0;
  unsigned __int16 v61 = -1;
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v26 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
      uint64_t Name = sel_getName(*(SEL *)(a1 + 56));
      if (*(void *)(a1 + 40)) {
        uint64_t v31 = "YES";
      }
      else {
        uint64_t v31 = "NO";
      }
      uint64_t v32 = 43;
      if (!isMetaClass) {
        uint64_t v32 = 45;
      }
      v26(6, "%c[%{public}s %{public}s]:%i Allocate slot %d, authorizer %d, token : %s", v32, ClassName, Name, 75, *(unsigned __int8 *)(a1 + 64), *(unsigned __int8 *)(a1 + 65), v31);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    unint64_t v33 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v34 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v34)) {
        int v35 = 43;
      }
      else {
        int v35 = 45;
      }
      id v36 = object_getClassName(*(id *)(a1 + 32));
      id v37 = sel_getName(*(SEL *)(a1 + 56));
      int v38 = *(unsigned __int8 *)(a1 + 64);
      int v39 = *(unsigned __int8 *)(a1 + 65);
      if (*(void *)(a1 + 40)) {
        id v40 = "YES";
      }
      else {
        id v40 = "NO";
      }
      *(_DWORD *)id buf = 67110658;
      int v68 = v35;
      __int16 v69 = 2082;
      int v70 = v36;
      __int16 v71 = 2082;
      int v72 = v37;
      __int16 v73 = 1024;
      int v74 = 75;
      __int16 v75 = 1024;
      *(_DWORD *)NSErrorUserInfoKey v76 = v38;
      *(_WORD *)&v76[4] = 1024;
      *(_DWORD *)&v76[6] = v39;
      __int16 v77 = 2080;
      NSErrorUserInfoKey v78 = v40;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Allocate slot %d, authorizer %d, token : %s", buf, 0x38u);
    }

    id v41 = *(void **)(a1 + 32);
    if (v41[20])
    {
      NFDriverRedactLogging();
      id v41 = *(void **)(a1 + 32);
    }
    __int16 v42 = [v41 embeddedSecureElementWrapper];

    if (v42)
    {
      int v43 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      uint64_t v44 = *(unsigned __int8 *)(a1 + 64);
      uint64_t v45 = *(unsigned __int8 *)(a1 + 65);
      uint64_t v46 = *(void *)(a1 + 40);
      id v60 = 0;
      BOOL v47 = [v43 allocateSlot:v44 authorizingUser:v45 authorizingUserToken:v46 outToken:&v60 outWriteCount:&v62 appletResult:&v61];
      id v20 = v60;

      uint64_t v48 = (uint64_t)[v47 code];
      if (!v47)
      {
        id v19 = 0;
LABEL_45:
        if (*(void *)(*(void *)(a1 + 32) + 160)) {
          NFDriverRedactLogging();
        }
        (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
        NSErrorUserInfoKey v58 = NFSharedSignpostLog();
        if (os_signpost_enabled(v58))
        {
          *(_WORD *)id buf = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v58, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SESHAT_ALLOCATE_SLOT", (const char *)&unk_100286819, buf, 2u);
        }

        [*(id *)(a1 + 32) maybeTTR:v48 appletResult:v61];
        goto LABEL_17;
      }
      id v49 = objc_alloc((Class)NSError);
      id v50 = +[NSString stringWithUTF8String:"nfcd"];
      id v51 = [v47 code];
      v65[0] = NSLocalizedDescriptionKey;
      id v59 = v51;
      if ((uint64_t)[v47 code] > 70) {
        uint64_t v52 = 71;
      }
      else {
        uint64_t v52 = (uint64_t)[v47 code];
      }
      __int16 v54 = +[NSString stringWithUTF8String:off_100307D50[v52]];
      v66[0] = v54;
      v66[1] = v47;
      v65[1] = NSUnderlyingErrorKey;
      v65[2] = @"Line";
      v66[2] = &off_10031FD20;
      v65[3] = @"Method";
      id v55 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
      v66[3] = v55;
      void v65[4] = NSDebugDescriptionErrorKey;
      id v56 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 88];
      void v66[4] = v56;
      int v57 = +[NSDictionary dictionaryWithObjects:v66 forKeys:v65 count:5];
      id v19 = [v49 initWithDomain:v50 code:v59 userInfo:v57];
    }
    else
    {
      id v53 = objc_alloc((Class)NSError);
      id v50 = +[NSString stringWithUTF8String:"nfcd"];
      v63[0] = NSLocalizedDescriptionKey;
      __int16 v54 = +[NSString stringWithUTF8String:"No resources"];
      v64[0] = v54;
      v64[1] = &off_10031FD38;
      v63[1] = @"Line";
      v63[2] = @"Method";
      id v55 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
      v64[2] = v55;
      v63[3] = NSDebugDescriptionErrorKey;
      id v56 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 91];
      v64[3] = v56;
      int v57 = +[NSDictionary dictionaryWithObjects:v64 forKeys:v63 count:4];
      uint64_t v48 = 34;
      id v19 = [v53 initWithDomain:v50 code:34 userInfo:v57];
      id v20 = 0;
    }

    goto LABEL_45;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v3 = NFLogGetLogger();
  if (v3)
  {
    id v4 = (void (*)(uint64_t, const char *, ...))v3;
    uint64_t v5 = object_getClass(*(id *)(a1 + 32));
    BOOL v6 = class_isMetaClass(v5);
    uint64_t v7 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v8 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v9 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v10 = 45;
    if (v6) {
      uint64_t v10 = 43;
    }
    v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, v7, v8, 73, v9);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  CFStringRef v11 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    id v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12)) {
      int v13 = 43;
    }
    else {
      int v13 = 45;
    }
    uint64_t v14 = object_getClassName(*(id *)(a1 + 32));
    id v15 = sel_getName(*(SEL *)(a1 + 56));
    id v16 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)id buf = 67110146;
    int v68 = v13;
    __int16 v69 = 2082;
    int v70 = v14;
    __int16 v71 = 2082;
    int v72 = v15;
    __int16 v73 = 1024;
    int v74 = 73;
    __int16 v75 = 2114;
    *(void *)NSErrorUserInfoKey v76 = v16;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v17 = *(void *)(a1 + 48);
  if (v17)
  {
    id v18 = objc_alloc((Class)NSError);
    id v19 = +[NSString stringWithUTF8String:"nfcd"];
    v79[0] = NSLocalizedDescriptionKey;
    id v20 = +[NSString stringWithUTF8String:"Session not active"];
    v80[0] = v20;
    v80[1] = &off_10031FD08;
    v79[1] = @"Line";
    v79[2] = @"Method";
    id v21 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v80[2] = v21;
    v79[3] = NSDebugDescriptionErrorKey;
    id v22 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 72];
    v80[3] = v22;
    id v23 = +[NSDictionary dictionaryWithObjects:v80 forKeys:v79 count:4];
    id v24 = [v18 initWithDomain:v19 code:54 userInfo:v23];
    (*(void (**)(uint64_t, uint64_t, void, void, id))(v17 + 16))(v17, 54, 0, 0, v24);

LABEL_17:
  }
}

void sub_100228A74(uint64_t a1)
{
  id v2 = NFSharedSignpostLog();
  if (os_signpost_enabled(v2))
  {
    *(_WORD *)id buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v2, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "SESHAT_DERIVE", (const char *)&unk_100286819, buf, 2u);
  }

  int v60 = 0;
  unsigned __int16 v59 = -1;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 56));
    if (*(void *)(a1 + 40)) {
      uint64_t v9 = "YES";
    }
    else {
      uint64_t v9 = "NO";
    }
    uint64_t v10 = 45;
    if (isMetaClass) {
      uint64_t v10 = 43;
    }
    v4(6, "%c[%{public}s %{public}s]:%i Derive slot %d, hash : %s", v10, ClassName, Name, 123, *(unsigned __int8 *)(a1 + 64), v9);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  CFStringRef v11 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    id v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12)) {
      int v13 = 43;
    }
    else {
      int v13 = 45;
    }
    uint64_t v14 = object_getClassName(*(id *)(a1 + 32));
    id v15 = sel_getName(*(SEL *)(a1 + 56));
    int v16 = *(unsigned __int8 *)(a1 + 64);
    if (*(void *)(a1 + 40)) {
      uint64_t v17 = "YES";
    }
    else {
      uint64_t v17 = "NO";
    }
    *(_DWORD *)id buf = 67110402;
    int v68 = v13;
    __int16 v69 = 2082;
    int v70 = v14;
    __int16 v71 = 2082;
    int v72 = v15;
    __int16 v73 = 1024;
    int v74 = 123;
    __int16 v75 = 1024;
    *(_DWORD *)NSErrorUserInfoKey v76 = v16;
    *(_WORD *)&v76[4] = 2080;
    *(void *)&v76[6] = v17;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Derive slot %d, hash : %s", buf, 0x32u);
  }

  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    id v40 = *(void **)(a1 + 32);
    if (v40[20])
    {
      NFDriverRedactLogging();
      id v40 = *(void **)(a1 + 32);
    }
    id v41 = [v40 embeddedSecureElementWrapper];

    if (v41)
    {
      __int16 v42 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      uint64_t v43 = *(unsigned __int8 *)(a1 + 64);
      uint64_t v44 = *(void *)(a1 + 40);
      id v58 = 0;
      uint64_t v45 = [v42 derive:v43 userHash:v44 outData:&v58 outWriteCount:&v60 appletResult:&v59];
      id v35 = v58;

      uint64_t v46 = (uint64_t)[v45 code];
      if (!v45)
      {
        id v34 = 0;
LABEL_45:
        if (*(void *)(*(void *)(a1 + 32) + 160)) {
          NFDriverRedactLogging();
        }
        (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
        id v56 = NFSharedSignpostLog();
        if (os_signpost_enabled(v56))
        {
          *(_WORD *)id buf = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v56, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SESHAT_DERIVE", (const char *)&unk_100286819, buf, 2u);
        }

        [*(id *)(a1 + 32) maybeTTR:v46 appletResult:v59];
        goto LABEL_32;
      }
      id v47 = objc_alloc((Class)NSError);
      uint64_t v48 = +[NSString stringWithUTF8String:"nfcd"];
      id v49 = [v45 code];
      v63[0] = NSLocalizedDescriptionKey;
      id v57 = v49;
      if ((uint64_t)[v45 code] > 70) {
        uint64_t v50 = 71;
      }
      else {
        uint64_t v50 = (uint64_t)[v45 code];
      }
      uint64_t v52 = +[NSString stringWithUTF8String:off_100307D50[v50]];
      v64[0] = v52;
      v64[1] = v45;
      v63[1] = NSUnderlyingErrorKey;
      v63[2] = @"Line";
      v64[2] = &off_10031FD68;
      v63[3] = @"Method";
      id v53 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
      v64[3] = v53;
      void v63[4] = NSDebugDescriptionErrorKey;
      id v54 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 141];
      void v64[4] = v54;
      id v55 = +[NSDictionary dictionaryWithObjects:v64 forKeys:v63 count:5];
      id v34 = [v47 initWithDomain:v48 code:v57 userInfo:v55];
    }
    else
    {
      id v51 = objc_alloc((Class)NSError);
      uint64_t v48 = +[NSString stringWithUTF8String:"nfcd"];
      v61[0] = NSLocalizedDescriptionKey;
      uint64_t v52 = +[NSString stringWithUTF8String:"No resources"];
      v62[0] = v52;
      v62[1] = &off_10031FD80;
      v61[1] = @"Line";
      v61[2] = @"Method";
      id v53 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
      v62[2] = v53;
      void v61[3] = NSDebugDescriptionErrorKey;
      id v54 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 144];
      v62[3] = v54;
      id v55 = +[NSDictionary dictionaryWithObjects:v62 forKeys:v61 count:4];
      uint64_t v46 = 34;
      id v34 = [v51 initWithDomain:v48 code:34 userInfo:v55];
      id v35 = 0;
    }

    goto LABEL_45;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v18 = NFLogGetLogger();
  if (v18)
  {
    id v19 = (void (*)(uint64_t, const char *, ...))v18;
    id v20 = object_getClass(*(id *)(a1 + 32));
    BOOL v21 = class_isMetaClass(v20);
    id v22 = object_getClassName(*(id *)(a1 + 32));
    id v23 = sel_getName(*(SEL *)(a1 + 56));
    id v24 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v25 = 45;
    if (v21) {
      uint64_t v25 = 43;
    }
    v19(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v25, v22, v23, 129, v24);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v26 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
  {
    unint64_t v27 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v27)) {
      int v28 = 43;
    }
    else {
      int v28 = 45;
    }
    int v29 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v30 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v31 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)id buf = 67110146;
    int v68 = v28;
    __int16 v69 = 2082;
    int v70 = v29;
    __int16 v71 = 2082;
    int v72 = v30;
    __int16 v73 = 1024;
    int v74 = 129;
    __int16 v75 = 2114;
    *(void *)NSErrorUserInfoKey v76 = v31;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v32 = *(void *)(a1 + 48);
  if (v32)
  {
    id v33 = objc_alloc((Class)NSError);
    id v34 = +[NSString stringWithUTF8String:"nfcd"];
    v65[0] = NSLocalizedDescriptionKey;
    id v35 = +[NSString stringWithUTF8String:"Session not active"];
    v66[0] = v35;
    v66[1] = &off_10031FD50;
    v65[1] = @"Line";
    v65[2] = @"Method";
    id v36 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v66[2] = v36;
    v65[3] = NSDebugDescriptionErrorKey;
    id v37 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 128];
    v66[3] = v37;
    int v38 = +[NSDictionary dictionaryWithObjects:v66 forKeys:v65 count:4];
    id v39 = [v33 initWithDomain:v34 code:54 userInfo:v38];
    (*(void (**)(uint64_t, uint64_t, void, void, id))(v32 + 16))(v32, 54, 0, 0, v39);

LABEL_32:
  }
}

void sub_100229470(uint64_t a1)
{
  id v2 = NFSharedSignpostLog();
  if (os_signpost_enabled(v2))
  {
    LOWORD(buf) = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v2, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "SESHAT_RESET_COUNTER", (const char *)&unk_100286819, (uint8_t *)&buf, 2u);
  }

  int v57 = 0;
  unsigned __int16 v56 = -1;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 56));
    if (*(void *)(a1 + 40)) {
      uint64_t v9 = "YES";
    }
    else {
      uint64_t v9 = "NO";
    }
    uint64_t v10 = 45;
    if (isMetaClass) {
      uint64_t v10 = 43;
    }
    v4(6, "%c[%{public}s %{public}s]:%i Reset counter %d, token : %s", v10, ClassName, Name, 175, *(unsigned __int8 *)(a1 + 64), v9);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  CFStringRef v11 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    id v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12)) {
      int v13 = 43;
    }
    else {
      int v13 = 45;
    }
    uint64_t v14 = object_getClassName(*(id *)(a1 + 32));
    id v15 = sel_getName(*(SEL *)(a1 + 56));
    int v16 = *(unsigned __int8 *)(a1 + 64);
    if (*(void *)(a1 + 40)) {
      uint64_t v17 = "YES";
    }
    else {
      uint64_t v17 = "NO";
    }
    int buf = 67110402;
    int v65 = v13;
    __int16 v66 = 2082;
    CFDataRef v67 = v14;
    __int16 v68 = 2082;
    __int16 v69 = v15;
    __int16 v70 = 1024;
    int v71 = 175;
    __int16 v72 = 1024;
    *(_DWORD *)__int16 v73 = v16;
    *(_WORD *)&v73[4] = 2080;
    *(void *)&v73[6] = v17;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Reset counter %d, token : %s", (uint8_t *)&buf, 0x32u);
  }

  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    id v40 = *(void **)(a1 + 32);
    if (v40[20])
    {
      NFDriverRedactLogging();
      id v40 = *(void **)(a1 + 32);
    }
    id v41 = [v40 embeddedSecureElementWrapper];

    if (v41)
    {
      __int16 v42 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      uint64_t v43 = [v42 resetCounter:*(unsigned __int8 *)(a1 + 64) userToken:*(void *)(a1 + 40) outWriteCount:&v57 appletResult:&v56];

      uint64_t v44 = (uint64_t)[v43 code];
      if (!v43)
      {
        id v34 = 0;
LABEL_45:
        if (*(void *)(*(void *)(a1 + 32) + 160)) {
          NFDriverRedactLogging();
        }
        (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
        id v54 = NFSharedSignpostLog();
        if (os_signpost_enabled(v54))
        {
          LOWORD(buf) = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v54, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SESHAT_RESET_COUNTER", (const char *)&unk_100286819, (uint8_t *)&buf, 2u);
        }

        [*(id *)(a1 + 32) maybeTTR:v44 appletResult:v56];
        goto LABEL_32;
      }
      id v45 = objc_alloc((Class)NSError);
      uint64_t v46 = +[NSString stringWithUTF8String:"nfcd"];
      id v47 = [v43 code];
      v60[0] = NSLocalizedDescriptionKey;
      id v55 = v47;
      if ((uint64_t)[v43 code] > 70) {
        uint64_t v48 = 71;
      }
      else {
        uint64_t v48 = (uint64_t)[v43 code];
      }
      uint64_t v50 = +[NSString stringWithUTF8String:off_100307D50[v48]];
      v61[0] = v50;
      v61[1] = v43;
      v60[1] = NSUnderlyingErrorKey;
      v60[2] = @"Line";
      v61[2] = &off_10031FDB0;
      void v60[3] = @"Method";
      id v51 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
      void v61[3] = v51;
      void v60[4] = NSDebugDescriptionErrorKey;
      id v52 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 192];
      void v61[4] = v52;
      id v53 = +[NSDictionary dictionaryWithObjects:v61 forKeys:v60 count:5];
      id v34 = [v45 initWithDomain:v46 code:v55 userInfo:v53];
    }
    else
    {
      id v49 = objc_alloc((Class)NSError);
      uint64_t v46 = +[NSString stringWithUTF8String:"nfcd"];
      v58[0] = NSLocalizedDescriptionKey;
      uint64_t v50 = +[NSString stringWithUTF8String:"No resources"];
      v59[0] = v50;
      v59[1] = &off_10031FDC8;
      v58[1] = @"Line";
      void v58[2] = @"Method";
      id v51 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
      void v59[2] = v51;
      v58[3] = NSDebugDescriptionErrorKey;
      id v52 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 195];
      v59[3] = v52;
      id v53 = +[NSDictionary dictionaryWithObjects:v59 forKeys:v58 count:4];
      id v34 = [v49 initWithDomain:v46 code:34 userInfo:v53];
      uint64_t v44 = 34;
    }

    goto LABEL_45;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v18 = NFLogGetLogger();
  if (v18)
  {
    id v19 = (void (*)(uint64_t, const char *, ...))v18;
    id v20 = object_getClass(*(id *)(a1 + 32));
    BOOL v21 = class_isMetaClass(v20);
    id v22 = object_getClassName(*(id *)(a1 + 32));
    id v23 = sel_getName(*(SEL *)(a1 + 56));
    id v24 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v25 = 45;
    if (v21) {
      uint64_t v25 = 43;
    }
    v19(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v25, v22, v23, 181, v24);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v26 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
  {
    unint64_t v27 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v27)) {
      int v28 = 43;
    }
    else {
      int v28 = 45;
    }
    int v29 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v30 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v31 = [*(id *)(a1 + 32) sessionUID];
    int buf = 67110146;
    int v65 = v28;
    __int16 v66 = 2082;
    CFDataRef v67 = v29;
    __int16 v68 = 2082;
    __int16 v69 = v30;
    __int16 v70 = 1024;
    int v71 = 181;
    __int16 v72 = 2114;
    *(void *)__int16 v73 = v31;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", (uint8_t *)&buf, 0x2Cu);
  }
  uint64_t v32 = *(void *)(a1 + 48);
  if (v32)
  {
    id v33 = objc_alloc((Class)NSError);
    id v34 = +[NSString stringWithUTF8String:"nfcd"];
    v62[0] = NSLocalizedDescriptionKey;
    id v35 = +[NSString stringWithUTF8String:"Session not active"];
    v63[0] = v35;
    v63[1] = &off_10031FD98;
    v62[1] = @"Line";
    v62[2] = @"Method";
    id v36 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v63[2] = v36;
    v62[3] = NSDebugDescriptionErrorKey;
    id v37 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 180];
    v63[3] = v37;
    int v38 = +[NSDictionary dictionaryWithObjects:v63 forKeys:v62 count:4];
    id v39 = [v33 initWithDomain:v34 code:54 userInfo:v38];
    (*(void (**)(uint64_t, uint64_t, void, id))(v32 + 16))(v32, 54, 0, v39);

LABEL_32:
  }
}

void sub_100229E54(uint64_t a1)
{
  id v2 = NFSharedSignpostLog();
  if (os_signpost_enabled(v2))
  {
    LOWORD(buf) = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v2, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "SESHAT_AUTH_UPDATE", (const char *)&unk_100286819, (uint8_t *)&buf, 2u);
  }

  int v59 = 0;
  unsigned __int16 v58 = -1;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 56));
    if (*(unsigned char *)(a1 + 64)) {
      uint64_t v9 = "Authorize";
    }
    else {
      uint64_t v9 = "De-authorize";
    }
    if (*(void *)(a1 + 40)) {
      uint64_t v10 = "YES";
    }
    else {
      uint64_t v10 = "NO";
    }
    uint64_t v11 = 43;
    if (!isMetaClass) {
      uint64_t v11 = 45;
    }
    v4(6, "%c[%{public}s %{public}s]:%i %s update, slot %d, token : %s", v11, ClassName, Name, 227, v9, *(unsigned __int8 *)(a1 + 65), v10);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v12 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v13)) {
      int v14 = 43;
    }
    else {
      int v14 = 45;
    }
    id v15 = object_getClassName(*(id *)(a1 + 32));
    int v16 = sel_getName(*(SEL *)(a1 + 56));
    if (*(unsigned char *)(a1 + 64)) {
      uint64_t v17 = "Authorize";
    }
    else {
      uint64_t v17 = "De-authorize";
    }
    int v18 = *(unsigned __int8 *)(a1 + 65);
    if (*(void *)(a1 + 40)) {
      id v19 = "YES";
    }
    else {
      id v19 = "NO";
    }
    int buf = 67110658;
    int v67 = v14;
    __int16 v68 = 2082;
    __int16 v69 = v15;
    __int16 v70 = 2082;
    int v71 = v16;
    __int16 v72 = 1024;
    int v73 = 227;
    __int16 v74 = 2080;
    __int16 v75 = v17;
    __int16 v76 = 1024;
    int v77 = v18;
    __int16 v78 = 2080;
    __int16 v79 = v19;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %s update, slot %d, token : %s", (uint8_t *)&buf, 0x3Cu);
  }

  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    __int16 v42 = *(void **)(a1 + 32);
    if (v42[20])
    {
      NFDriverRedactLogging();
      __int16 v42 = *(void **)(a1 + 32);
    }
    uint64_t v43 = [v42 embeddedSecureElementWrapper];

    if (v43)
    {
      uint64_t v44 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      id v45 = [v44 authorizeUpdate:*(unsigned __int8 *)(a1 + 64) slotIndex:*(unsigned __int8 *)(a1 + 65) userToken:*(void *)(a1 + 40) outWriteCount:&v59 appletResult:&v58];

      uint64_t v46 = (uint64_t)[v45 code];
      if (!v45)
      {
        id v36 = 0;
LABEL_51:
        if (*(void *)(*(void *)(a1 + 32) + 160)) {
          NFDriverRedactLogging();
        }
        (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
        unsigned __int16 v56 = NFSharedSignpostLog();
        if (os_signpost_enabled(v56))
        {
          LOWORD(buf) = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v56, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SESHAT_AUTH_UPDATE", (const char *)&unk_100286819, (uint8_t *)&buf, 2u);
        }

        [*(id *)(a1 + 32) maybeTTR:v46 appletResult:v58];
        goto LABEL_38;
      }
      id v47 = objc_alloc((Class)NSError);
      uint64_t v48 = +[NSString stringWithUTF8String:"nfcd"];
      id v49 = [v45 code];
      v62[0] = NSLocalizedDescriptionKey;
      id v57 = v49;
      if ((uint64_t)[v45 code] > 70) {
        uint64_t v50 = 71;
      }
      else {
        uint64_t v50 = (uint64_t)[v45 code];
      }
      id v52 = +[NSString stringWithUTF8String:off_100307D50[v50]];
      v63[0] = v52;
      v63[1] = v45;
      v62[1] = NSUnderlyingErrorKey;
      v62[2] = @"Line";
      v63[2] = &off_10031FDF8;
      v62[3] = @"Method";
      id v53 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
      v63[3] = v53;
      void v62[4] = NSDebugDescriptionErrorKey;
      id v54 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 244];
      void v63[4] = v54;
      id v55 = +[NSDictionary dictionaryWithObjects:v63 forKeys:v62 count:5];
      id v36 = [v47 initWithDomain:v48 code:v57 userInfo:v55];
    }
    else
    {
      id v51 = objc_alloc((Class)NSError);
      uint64_t v48 = +[NSString stringWithUTF8String:"nfcd"];
      v60[0] = NSLocalizedDescriptionKey;
      id v52 = +[NSString stringWithUTF8String:"No resources"];
      v61[0] = v52;
      v61[1] = &off_10031FE10;
      v60[1] = @"Line";
      v60[2] = @"Method";
      id v53 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
      v61[2] = v53;
      void v60[3] = NSDebugDescriptionErrorKey;
      id v54 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 247];
      void v61[3] = v54;
      id v55 = +[NSDictionary dictionaryWithObjects:v61 forKeys:v60 count:4];
      id v36 = [v51 initWithDomain:v48 code:34 userInfo:v55];
      uint64_t v46 = 34;
    }

    goto LABEL_51;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v20 = NFLogGetLogger();
  if (v20)
  {
    BOOL v21 = (void (*)(uint64_t, const char *, ...))v20;
    id v22 = object_getClass(*(id *)(a1 + 32));
    BOOL v23 = class_isMetaClass(v22);
    id v24 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v25 = sel_getName(*(SEL *)(a1 + 56));
    id v26 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v27 = 45;
    if (v23) {
      uint64_t v27 = 43;
    }
    v21(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v27, v24, v25, 233, v26);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v28 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
  {
    int v29 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v29)) {
      int v30 = 43;
    }
    else {
      int v30 = 45;
    }
    uint64_t v31 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v32 = sel_getName(*(SEL *)(a1 + 56));
    id v33 = [*(id *)(a1 + 32) sessionUID];
    int buf = 67110146;
    int v67 = v30;
    __int16 v68 = 2082;
    __int16 v69 = v31;
    __int16 v70 = 2082;
    int v71 = v32;
    __int16 v72 = 1024;
    int v73 = 233;
    __int16 v74 = 2114;
    __int16 v75 = v33;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", (uint8_t *)&buf, 0x2Cu);
  }
  uint64_t v34 = *(void *)(a1 + 48);
  if (v34)
  {
    id v35 = objc_alloc((Class)NSError);
    id v36 = +[NSString stringWithUTF8String:"nfcd"];
    v64[0] = NSLocalizedDescriptionKey;
    id v37 = +[NSString stringWithUTF8String:"Session not active"];
    v65[0] = v37;
    v65[1] = &off_10031FDE0;
    v64[1] = @"Line";
    v64[2] = @"Method";
    id v38 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v65[2] = v38;
    v64[3] = NSDebugDescriptionErrorKey;
    id v39 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 232];
    v65[3] = v39;
    id v40 = +[NSDictionary dictionaryWithObjects:v65 forKeys:v64 count:4];
    id v41 = [v35 initWithDomain:v36 code:54 userInfo:v40];
    (*(void (**)(uint64_t, uint64_t, void, id))(v34 + 16))(v34, 54, 0, v41);

LABEL_38:
  }
}

void sub_10022A840(uint64_t a1)
{
  id v2 = NFSharedSignpostLog();
  if (os_signpost_enabled(v2))
  {
    LOWORD(buf) = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v2, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "SESHAT_DELETE_SLOT", (const char *)&unk_100286819, (uint8_t *)&buf, 2u);
  }

  int v53 = 0;
  unsigned __int16 v52 = -1;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v4(6, "%c[%{public}s %{public}s]:%i Delete counter %d", v9, ClassName, Name, 277, *(unsigned __int8 *)(a1 + 56));
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    int v13 = object_getClassName(*(id *)(a1 + 32));
    int v14 = sel_getName(*(SEL *)(a1 + 48));
    int v15 = *(unsigned __int8 *)(a1 + 56);
    int buf = 67110146;
    int v61 = v12;
    __int16 v62 = 2082;
    __int16 v63 = v13;
    __int16 v64 = 2082;
    int v65 = v14;
    __int16 v66 = 1024;
    int v67 = 277;
    __int16 v68 = 1024;
    LODWORD(v69) = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Delete counter %d", (uint8_t *)&buf, 0x28u);
  }

  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    id v38 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];

    if (v38)
    {
      id v39 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      id v40 = [v39 deleteSlot:*(unsigned __int8 *)(a1 + 56) outWriteCount:&v53 appletResult:&v52];

      uint64_t v41 = (uint64_t)[v40 code];
      if (!v40)
      {
        id v32 = 0;
LABEL_37:
        (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
        id v51 = NFSharedSignpostLog();
        if (os_signpost_enabled(v51))
        {
          LOWORD(buf) = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v51, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SESHAT_DELETE_SLOT", (const char *)&unk_100286819, (uint8_t *)&buf, 2u);
        }

        [*(id *)(a1 + 32) maybeTTR:v41 appletResult:v52];
        goto LABEL_26;
      }
      id v42 = objc_alloc((Class)NSError);
      uint64_t v43 = +[NSString stringWithUTF8String:"nfcd"];
      id v44 = [v40 code];
      v56[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[v40 code] > 70) {
        uint64_t v45 = 71;
      }
      else {
        uint64_t v45 = (uint64_t)[v40 code];
      }
      id v47 = +[NSString stringWithUTF8String:off_100307D50[v45]];
      v57[0] = v47;
      v57[1] = v40;
      v56[1] = NSUnderlyingErrorKey;
      v56[2] = @"Line";
      v57[2] = &off_10031FE40;
      v56[3] = @"Method";
      id v48 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
      v57[3] = v48;
      void v56[4] = NSDebugDescriptionErrorKey;
      id v49 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 292];
      void v57[4] = v49;
      uint64_t v50 = +[NSDictionary dictionaryWithObjects:v57 forKeys:v56 count:5];
      id v32 = [v42 initWithDomain:v43 code:v44 userInfo:v50];
    }
    else
    {
      id v46 = objc_alloc((Class)NSError);
      uint64_t v43 = +[NSString stringWithUTF8String:"nfcd"];
      v54[0] = NSLocalizedDescriptionKey;
      id v47 = +[NSString stringWithUTF8String:"No resources"];
      v55[0] = v47;
      v55[1] = &off_10031FE58;
      v54[1] = @"Line";
      v54[2] = @"Method";
      id v48 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
      id v55[2] = v48;
      void v54[3] = NSDebugDescriptionErrorKey;
      id v49 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 295];
      v55[3] = v49;
      uint64_t v50 = +[NSDictionary dictionaryWithObjects:v55 forKeys:v54 count:4];
      id v32 = [v46 initWithDomain:v43 code:34 userInfo:v50];
      uint64_t v41 = 34;
    }

    goto LABEL_37;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v16 = NFLogGetLogger();
  if (v16)
  {
    uint64_t v17 = (void (*)(uint64_t, const char *, ...))v16;
    int v18 = object_getClass(*(id *)(a1 + 32));
    BOOL v19 = class_isMetaClass(v18);
    uint64_t v20 = object_getClassName(*(id *)(a1 + 32));
    BOOL v21 = sel_getName(*(SEL *)(a1 + 48));
    id v22 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v23 = 45;
    if (v19) {
      uint64_t v23 = 43;
    }
    v17(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v23, v20, v21, 283, v22);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v24 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    uint64_t v25 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v25)) {
      int v26 = 43;
    }
    else {
      int v26 = 45;
    }
    uint64_t v27 = object_getClassName(*(id *)(a1 + 32));
    int v28 = sel_getName(*(SEL *)(a1 + 48));
    int v29 = [*(id *)(a1 + 32) sessionUID];
    int buf = 67110146;
    int v61 = v26;
    __int16 v62 = 2082;
    __int16 v63 = v27;
    __int16 v64 = 2082;
    int v65 = v28;
    __int16 v66 = 1024;
    int v67 = 283;
    __int16 v68 = 2114;
    __int16 v69 = v29;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", (uint8_t *)&buf, 0x2Cu);
  }
  uint64_t v30 = *(void *)(a1 + 40);
  if (v30)
  {
    id v31 = objc_alloc((Class)NSError);
    id v32 = +[NSString stringWithUTF8String:"nfcd"];
    v58[0] = NSLocalizedDescriptionKey;
    id v33 = +[NSString stringWithUTF8String:"Session not active"];
    v59[0] = v33;
    v59[1] = &off_10031FE28;
    v58[1] = @"Line";
    void v58[2] = @"Method";
    id v34 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
    void v59[2] = v34;
    v58[3] = NSDebugDescriptionErrorKey;
    id v35 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 282];
    v59[3] = v35;
    id v36 = +[NSDictionary dictionaryWithObjects:v59 forKeys:v58 count:4];
    id v37 = [v31 initWithDomain:v32 code:54 userInfo:v36];
    (*(void (**)(uint64_t, uint64_t, void, id))(v30 + 16))(v30, 54, 0, v37);

LABEL_26:
  }
}

void sub_10022B178(uint64_t a1)
{
  id v2 = NFSharedSignpostLog();
  if (os_signpost_enabled(v2))
  {
    *(_WORD *)int buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v2, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "SESHAT_GET_DATA", (const char *)&unk_100286819, buf, 2u);
  }

  char v55 = 0;
  int v53 = 0;
  int v54 = 0;
  unsigned __int16 v52 = -1;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v4(6, "%c[%{public}s %{public}s]:%i ", v8, ClassName, Name, 325);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    int v12 = object_getClassName(*(id *)(a1 + 32));
    int v13 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)int buf = 67109890;
    int v63 = v11;
    __int16 v64 = 2082;
    int v65 = v12;
    __int16 v66 = 2082;
    int v67 = v13;
    __int16 v68 = 1024;
    int v69 = 325;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    id v36 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];

    if (v36)
    {
      id v37 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      id v51 = 0;
      id v38 = [v37 getData:&v51 updateKUD:&v55 outWriteLimit:&v54 outWriteCount:&v53 appletResult:&v52];
      id v31 = v51;

      uint64_t v39 = (uint64_t)[v38 code];
      if (!v38)
      {
        id v30 = 0;
LABEL_37:
        (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
        id v48 = NFSharedSignpostLog();
        if (os_signpost_enabled(v48))
        {
          *(_WORD *)int buf = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v48, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SESHAT_GET_DATA", (const char *)&unk_100286819, buf, 2u);
        }

        [*(id *)(a1 + 32) maybeTTR:v39 appletResult:v52];
        goto LABEL_26;
      }
      id v50 = objc_alloc((Class)NSError);
      id v40 = +[NSString stringWithUTF8String:"nfcd"];
      id v41 = [v38 code];
      v58[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[v38 code] > 70) {
        uint64_t v42 = 71;
      }
      else {
        uint64_t v42 = (uint64_t)[v38 code];
      }
      id v44 = +[NSString stringWithUTF8String:off_100307D50[v42]];
      v59[0] = v44;
      v59[1] = v38;
      v58[1] = NSUnderlyingErrorKey;
      void v58[2] = @"Line";
      void v59[2] = &off_10031FE88;
      v58[3] = @"Method";
      id v45 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
      v59[3] = v45;
      void v58[4] = NSDebugDescriptionErrorKey;
      id v46 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 342];
      void v59[4] = v46;
      id v47 = +[NSDictionary dictionaryWithObjects:v59 forKeys:v58 count:5];
      id v30 = [v50 initWithDomain:v40 code:v41 userInfo:v47];
    }
    else
    {
      id v43 = objc_alloc((Class)NSError);
      id v40 = +[NSString stringWithUTF8String:"nfcd"];
      v56[0] = NSLocalizedDescriptionKey;
      id v44 = +[NSString stringWithUTF8String:"No resources"];
      v57[0] = v44;
      v57[1] = &off_10031FEA0;
      v56[1] = @"Line";
      v56[2] = @"Method";
      id v45 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
      v57[2] = v45;
      v56[3] = NSDebugDescriptionErrorKey;
      id v46 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 345];
      v57[3] = v46;
      id v47 = +[NSDictionary dictionaryWithObjects:v57 forKeys:v56 count:4];
      uint64_t v39 = 34;
      id v30 = [v43 initWithDomain:v40 code:34 userInfo:v47];
      id v31 = 0;
    }

    goto LABEL_37;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v14 = NFLogGetLogger();
  if (v14)
  {
    int v15 = (void (*)(uint64_t, const char *, ...))v14;
    uint64_t v16 = object_getClass(*(id *)(a1 + 32));
    BOOL v17 = class_isMetaClass(v16);
    int v18 = object_getClassName(*(id *)(a1 + 32));
    BOOL v19 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v20 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v21 = 45;
    if (v17) {
      uint64_t v21 = 43;
    }
    v15(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v21, v18, v19, 331, v20);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v22 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    uint64_t v23 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v23)) {
      int v24 = 43;
    }
    else {
      int v24 = 45;
    }
    uint64_t v25 = object_getClassName(*(id *)(a1 + 32));
    int v26 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v27 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)int buf = 67110146;
    int v63 = v24;
    __int16 v64 = 2082;
    int v65 = v25;
    __int16 v66 = 2082;
    int v67 = v26;
    __int16 v68 = 1024;
    int v69 = 331;
    __int16 v70 = 2114;
    int v71 = v27;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v28 = *(void *)(a1 + 40);
  if (v28)
  {
    id v29 = objc_alloc((Class)NSError);
    id v30 = +[NSString stringWithUTF8String:"nfcd"];
    v60[0] = NSLocalizedDescriptionKey;
    id v31 = +[NSString stringWithUTF8String:"Session not active"];
    v61[0] = v31;
    v61[1] = &off_10031FE70;
    v60[1] = @"Line";
    v60[2] = @"Method";
    id v32 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
    v61[2] = v32;
    void v60[3] = NSDebugDescriptionErrorKey;
    id v33 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 330];
    void v61[3] = v33;
    id v34 = +[NSDictionary dictionaryWithObjects:v61 forKeys:v60 count:4];
    id v35 = [v29 initWithDomain:v30 code:54 userInfo:v34];
    (*(void (**)(uint64_t, uint64_t, void, void, void, void, id))(v28 + 16))(v28, 54, 0, 0, 0, 0, v35);

LABEL_26:
  }
}

void sub_10022BACC(uint64_t a1)
{
  id v2 = NFSharedSignpostLog();
  if (os_signpost_enabled(v2))
  {
    *(_WORD *)int buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v2, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "SESHAT_GET_HASH", (const char *)&unk_100286819, buf, 2u);
  }

  unsigned __int16 v52 = -1;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v4(6, "%c[%{public}s %{public}s]:%i ", v8, ClassName, Name, 371);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    int v12 = object_getClassName(*(id *)(a1 + 32));
    int v13 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)int buf = 67109890;
    int v60 = v11;
    __int16 v61 = 2082;
    __int16 v62 = v12;
    __int16 v63 = 2082;
    __int16 v64 = v13;
    __int16 v65 = 1024;
    int v66 = 371;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    id v36 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];

    if (v36)
    {
      id v37 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      id v51 = 0;
      id v38 = [v37 getHash:&v51 appletResult:&v52];
      id v31 = v51;

      uint64_t v39 = (uint64_t)[v38 code];
      if (!v38)
      {
        id v30 = 0;
LABEL_37:
        (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
        id v48 = NFSharedSignpostLog();
        if (os_signpost_enabled(v48))
        {
          *(_WORD *)int buf = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v48, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SESHAT_GET_HASH", (const char *)&unk_100286819, buf, 2u);
        }

        [*(id *)(a1 + 32) maybeTTR:v39 appletResult:v52];
        goto LABEL_26;
      }
      id v50 = objc_alloc((Class)NSError);
      id v40 = +[NSString stringWithUTF8String:"nfcd"];
      id v41 = [v38 code];
      v55[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[v38 code] > 70) {
        uint64_t v42 = 71;
      }
      else {
        uint64_t v42 = (uint64_t)[v38 code];
      }
      id v44 = +[NSString stringWithUTF8String:off_100307D50[v42]];
      v56[0] = v44;
      v56[1] = v38;
      v55[1] = NSUnderlyingErrorKey;
      id v55[2] = @"Line";
      v56[2] = &off_10031FED0;
      v55[3] = @"Method";
      id v45 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
      v56[3] = v45;
      void v55[4] = NSDebugDescriptionErrorKey;
      id v46 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 385];
      void v56[4] = v46;
      id v47 = +[NSDictionary dictionaryWithObjects:v56 forKeys:v55 count:5];
      id v30 = [v50 initWithDomain:v40 code:v41 userInfo:v47];
    }
    else
    {
      id v43 = objc_alloc((Class)NSError);
      id v40 = +[NSString stringWithUTF8String:"nfcd"];
      v53[0] = NSLocalizedDescriptionKey;
      id v44 = +[NSString stringWithUTF8String:"No resources"];
      v54[0] = v44;
      v54[1] = &off_10031FEE8;
      v53[1] = @"Line";
      v53[2] = @"Method";
      id v45 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
      v54[2] = v45;
      void v53[3] = NSDebugDescriptionErrorKey;
      id v46 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 388];
      void v54[3] = v46;
      id v47 = +[NSDictionary dictionaryWithObjects:v54 forKeys:v53 count:4];
      uint64_t v39 = 34;
      id v30 = [v43 initWithDomain:v40 code:34 userInfo:v47];
      id v31 = 0;
    }

    goto LABEL_37;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v14 = NFLogGetLogger();
  if (v14)
  {
    int v15 = (void (*)(uint64_t, const char *, ...))v14;
    uint64_t v16 = object_getClass(*(id *)(a1 + 32));
    BOOL v17 = class_isMetaClass(v16);
    int v18 = object_getClassName(*(id *)(a1 + 32));
    BOOL v19 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v20 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v21 = 45;
    if (v17) {
      uint64_t v21 = 43;
    }
    v15(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v21, v18, v19, 377, v20);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v22 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    uint64_t v23 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v23)) {
      int v24 = 43;
    }
    else {
      int v24 = 45;
    }
    uint64_t v25 = object_getClassName(*(id *)(a1 + 32));
    int v26 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v27 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)int buf = 67110146;
    int v60 = v24;
    __int16 v61 = 2082;
    __int16 v62 = v25;
    __int16 v63 = 2082;
    __int16 v64 = v26;
    __int16 v65 = 1024;
    int v66 = 377;
    __int16 v67 = 2114;
    __int16 v68 = v27;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v28 = *(void *)(a1 + 40);
  if (v28)
  {
    id v29 = objc_alloc((Class)NSError);
    id v30 = +[NSString stringWithUTF8String:"nfcd"];
    v57[0] = NSLocalizedDescriptionKey;
    id v31 = +[NSString stringWithUTF8String:"Session not active"];
    v58[0] = v31;
    v58[1] = &off_10031FEB8;
    v57[1] = @"Line";
    v57[2] = @"Method";
    id v32 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
    void v58[2] = v32;
    v57[3] = NSDebugDescriptionErrorKey;
    id v33 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 376];
    v58[3] = v33;
    id v34 = +[NSDictionary dictionaryWithObjects:v58 forKeys:v57 count:4];
    id v35 = [v29 initWithDomain:v30 code:54 userInfo:v34];
    (*(void (**)(uint64_t, uint64_t, void, id))(v28 + 16))(v28, 54, 0, v35);

LABEL_26:
  }
}

void sub_10022C428(uint64_t a1)
{
  id v2 = NFSharedSignpostLog();
  if (os_signpost_enabled(v2))
  {
    *(_WORD *)int buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v2, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "SESHAT_UPGRADE_KEY", (const char *)&unk_100286819, buf, 2u);
  }

  unsigned __int16 v57 = -1;
  int v56 = 0;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 56));
    if (*(void *)(a1 + 40)) {
      uint64_t v9 = "YES";
    }
    else {
      uint64_t v9 = "NO";
    }
    uint64_t v10 = 45;
    if (isMetaClass) {
      uint64_t v10 = 43;
    }
    v4(6, "%c[%{public}s %{public}s]:%i Upgrade:%d Data : %s", v10, ClassName, Name, 416, *(unsigned __int8 *)(a1 + 64), v9);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v11 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12)) {
      int v13 = 43;
    }
    else {
      int v13 = 45;
    }
    uint64_t v14 = object_getClassName(*(id *)(a1 + 32));
    int v15 = sel_getName(*(SEL *)(a1 + 56));
    int v16 = *(unsigned __int8 *)(a1 + 64);
    if (*(void *)(a1 + 40)) {
      BOOL v17 = "YES";
    }
    else {
      BOOL v17 = "NO";
    }
    *(_DWORD *)int buf = 67110402;
    int v65 = v13;
    __int16 v66 = 2082;
    __int16 v67 = v14;
    __int16 v68 = 2082;
    int v69 = v15;
    __int16 v70 = 1024;
    int v71 = 416;
    __int16 v72 = 1024;
    *(_DWORD *)int v73 = v16;
    *(_WORD *)&v73[4] = 2080;
    *(void *)&v73[6] = v17;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Upgrade:%d Data : %s", buf, 0x32u);
  }

  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    id v40 = *(void **)(a1 + 32);
    if (v40[20])
    {
      NFDriverRedactLogging();
      id v40 = *(void **)(a1 + 32);
    }
    id v41 = [v40 embeddedSecureElementWrapper];

    if (v41)
    {
      uint64_t v42 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      id v43 = [v42 upgradeKey:*(unsigned __int8 *)(a1 + 64) inputData:*(void *)(a1 + 40) outWriteCount:&v56 appletResult:&v57];

      uint64_t v44 = (uint64_t)[v43 code];
      if (!v43)
      {
        id v34 = 0;
LABEL_45:
        if (*(void *)(*(void *)(a1 + 32) + 160)) {
          NFDriverRedactLogging();
        }
        (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
        int v54 = NFSharedSignpostLog();
        if (os_signpost_enabled(v54))
        {
          *(_WORD *)int buf = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v54, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SESHAT_UPGRADE_KEY", (const char *)&unk_100286819, buf, 2u);
        }

        [*(id *)(a1 + 32) maybeTTR:v44 appletResult:v57];
        goto LABEL_32;
      }
      id v45 = objc_alloc((Class)NSError);
      id v46 = +[NSString stringWithUTF8String:"nfcd"];
      id v47 = [v43 code];
      v60[0] = NSLocalizedDescriptionKey;
      id v55 = v47;
      if ((uint64_t)[v43 code] > 70) {
        uint64_t v48 = 71;
      }
      else {
        uint64_t v48 = (uint64_t)[v43 code];
      }
      id v50 = +[NSString stringWithUTF8String:off_100307D50[v48]];
      v61[0] = v50;
      v61[1] = v43;
      v60[1] = NSUnderlyingErrorKey;
      v60[2] = @"Line";
      v61[2] = &off_10031FF18;
      void v60[3] = @"Method";
      id v51 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
      void v61[3] = v51;
      void v60[4] = NSDebugDescriptionErrorKey;
      id v52 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 432];
      void v61[4] = v52;
      int v53 = +[NSDictionary dictionaryWithObjects:v61 forKeys:v60 count:5];
      id v34 = [v45 initWithDomain:v46 code:v55 userInfo:v53];
    }
    else
    {
      id v49 = objc_alloc((Class)NSError);
      id v46 = +[NSString stringWithUTF8String:"nfcd"];
      v58[0] = NSLocalizedDescriptionKey;
      id v50 = +[NSString stringWithUTF8String:"No resources"];
      v59[0] = v50;
      v59[1] = &off_10031FF30;
      v58[1] = @"Line";
      void v58[2] = @"Method";
      id v51 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
      void v59[2] = v51;
      v58[3] = NSDebugDescriptionErrorKey;
      id v52 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 435];
      v59[3] = v52;
      int v53 = +[NSDictionary dictionaryWithObjects:v59 forKeys:v58 count:4];
      id v34 = [v49 initWithDomain:v46 code:34 userInfo:v53];
      uint64_t v44 = 34;
    }

    goto LABEL_45;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v18 = NFLogGetLogger();
  if (v18)
  {
    BOOL v19 = (void (*)(uint64_t, const char *, ...))v18;
    uint64_t v20 = object_getClass(*(id *)(a1 + 32));
    BOOL v21 = class_isMetaClass(v20);
    id v22 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v23 = sel_getName(*(SEL *)(a1 + 56));
    int v24 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v25 = 45;
    if (v21) {
      uint64_t v25 = 43;
    }
    v19(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v25, v22, v23, 422, v24);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v26 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
  {
    uint64_t v27 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v27)) {
      int v28 = 43;
    }
    else {
      int v28 = 45;
    }
    id v29 = object_getClassName(*(id *)(a1 + 32));
    id v30 = sel_getName(*(SEL *)(a1 + 56));
    id v31 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)int buf = 67110146;
    int v65 = v28;
    __int16 v66 = 2082;
    __int16 v67 = v29;
    __int16 v68 = 2082;
    int v69 = v30;
    __int16 v70 = 1024;
    int v71 = 422;
    __int16 v72 = 2114;
    *(void *)int v73 = v31;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v32 = *(void *)(a1 + 48);
  if (v32)
  {
    id v33 = objc_alloc((Class)NSError);
    id v34 = +[NSString stringWithUTF8String:"nfcd"];
    v62[0] = NSLocalizedDescriptionKey;
    id v35 = +[NSString stringWithUTF8String:"Session not active"];
    v63[0] = v35;
    v63[1] = &off_10031FF00;
    v62[1] = @"Line";
    v62[2] = @"Method";
    id v36 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v63[2] = v36;
    v62[3] = NSDebugDescriptionErrorKey;
    id v37 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 421];
    v63[3] = v37;
    id v38 = +[NSDictionary dictionaryWithObjects:v63 forKeys:v62 count:4];
    id v39 = [v33 initWithDomain:v34 code:54 userInfo:v38];
    (*(void (**)(uint64_t, uint64_t, void, id))(v32 + 16))(v32, 54, 0, v39);

LABEL_32:
  }
}

void sub_10022CDCC(uint64_t a1)
{
  id v2 = NFSharedSignpostLog();
  if (os_signpost_enabled(v2))
  {
    *(_WORD *)int buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v2, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "SESHAT_OBLITERATE", (const char *)&unk_100286819, buf, 2u);
  }

  int v56 = 0;
  __int16 v55 = 0;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v4(6, "%c[%{public}s %{public}s]:%i Delete all counters", v8, ClassName, Name, 463);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    int v12 = object_getClassName(*(id *)(a1 + 32));
    int v13 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)int buf = 67109890;
    int v60 = v11;
    __int16 v61 = 2082;
    __int16 v62 = v12;
    __int16 v63 = 2082;
    __int16 v64 = v13;
    __int16 v65 = 1024;
    int v66 = 463;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Delete all counters", buf, 0x22u);
  }

  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    id v36 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
    id v30 = [v36 deleteSlot:238 outWriteCount:&v56 appletResult:&v55];

    [v30 code];
    kdebug_trace();
    id v37 = NFSharedSignpostLog();
    if (os_signpost_enabled(v37))
    {
      *(_WORD *)int buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v37, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseEffaceAuthorization in", buf, 2u);
    }

    int v38 = sub_10021EC3C((uint64_t)NFSSEWrapper, +[NFSecureElementWrapper isAuthRandomEntangled]);
    kdebug_trace();
    id v39 = NFSharedSignpostLog();
    if (os_signpost_enabled(v39))
    {
      *(_WORD *)int buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v39, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseEffaceAuthorization out", buf, 2u);
    }

    if (v38)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v40 = NFLogGetLogger();
      if (v40)
      {
        id v41 = (void (*)(uint64_t, const char *, ...))v40;
        uint64_t v42 = object_getClass(*(id *)(a1 + 32));
        BOOL v43 = class_isMetaClass(v42);
        uint64_t v44 = object_getClassName(*(id *)(a1 + 32));
        int v54 = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v45 = 45;
        if (v43) {
          uint64_t v45 = 43;
        }
        v41(3, "%c[%{public}s %{public}s]:%i Failed to efface SEP", v45, v44, v54, 484);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v46 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
      {
        id v47 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v47)) {
          int v48 = 43;
        }
        else {
          int v48 = 45;
        }
        id v49 = object_getClassName(*(id *)(a1 + 32));
        id v50 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)int buf = 67109890;
        int v60 = v48;
        __int16 v61 = 2082;
        __int16 v62 = v49;
        __int16 v63 = 2082;
        __int16 v64 = v50;
        __int16 v65 = 1024;
        int v66 = 484;
        _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to efface SEP", buf, 0x22u);
      }
    }
    uint64_t v51 = *(void *)(a1 + 32);
    if (*(void *)(v51 + 160))
    {
      NFDriverRedactLogging();
      uint64_t v51 = *(void *)(a1 + 32);
    }
    id v52 = sub_1002437D4(*(void **)(v51 + 168), 0xFFFFFFFFLL);
    if (*(void *)(*(void *)(a1 + 32) + 160)) {
      NFDriverRedactLogging();
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    id v31 = NFSharedSignpostLog();
    if (os_signpost_enabled(v31))
    {
      *(_WORD *)int buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v31, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SESHAT_OBLITERATE", (const char *)&unk_100286819, buf, 2u);
    }
    goto LABEL_26;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v14 = NFLogGetLogger();
  if (v14)
  {
    int v15 = (void (*)(uint64_t, const char *, ...))v14;
    int v16 = object_getClass(*(id *)(a1 + 32));
    BOOL v17 = class_isMetaClass(v16);
    uint64_t v18 = object_getClassName(*(id *)(a1 + 32));
    BOOL v19 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v20 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v21 = 45;
    if (v17) {
      uint64_t v21 = 43;
    }
    v15(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v21, v18, v19, 469, v20);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v22 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    uint64_t v23 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v23)) {
      int v24 = 43;
    }
    else {
      int v24 = 45;
    }
    uint64_t v25 = object_getClassName(*(id *)(a1 + 32));
    int v26 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v27 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)int buf = 67110146;
    int v60 = v24;
    __int16 v61 = 2082;
    __int16 v62 = v25;
    __int16 v63 = 2082;
    __int16 v64 = v26;
    __int16 v65 = 1024;
    int v66 = 469;
    __int16 v67 = 2114;
    __int16 v68 = v27;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v28 = *(void *)(a1 + 40);
  if (v28)
  {
    id v29 = objc_alloc((Class)NSError);
    id v30 = +[NSString stringWithUTF8String:"nfcd"];
    v57[0] = NSLocalizedDescriptionKey;
    id v31 = +[NSString stringWithUTF8String:"Session not active"];
    v58[0] = v31;
    v58[1] = &off_10031FF48;
    v57[1] = @"Line";
    v57[2] = @"Method";
    id v32 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
    void v58[2] = v32;
    v57[3] = NSDebugDescriptionErrorKey;
    id v33 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 468];
    v58[3] = v33;
    id v34 = +[NSDictionary dictionaryWithObjects:v58 forKeys:v57 count:4];
    id v35 = [v29 initWithDomain:v30 code:54 userInfo:v34];
    (*(void (**)(uint64_t, uint64_t, id))(v28 + 16))(v28, 54, v35);

LABEL_26:
  }
}

id sub_10022F55C()
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2050000000;
  uint64_t v0 = (void *)qword_1003476B8;
  uint64_t v7 = qword_1003476B8;
  if (!qword_1003476B8)
  {
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_10022F7D8;
    v3[3] = &unk_100301E40;
    v3[4] = &v4;
    sub_10022F7D8(v3);
    uint64_t v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);

  return v1;
}

void sub_10022F628(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id *sub_10022F640(id *a1, void *a2, void *a3)
{
  id v6 = a2;
  id v7 = a3;
  if (a1)
  {
    v12.receiver = a1;
    v12.super_class = (Class)NFManagedConfigMonitor;
    uint64_t v8 = (id *)[super init];
    a1 = v8;
    if (v8)
    {
      objc_storeWeak(v8 + 3, v7);
      objc_storeStrong(a1 + 2, a2);
      if (sub_10022F920())
      {
        uint64_t v9 = [sub_10022F55C() sharedConnection];
        [v9 registerObserver:a1];

        uint64_t v10 = [sub_10022F55C() sharedConnection];
        *((unsigned char *)a1 + 8) = [v10 isNFCAllowed];
      }
      else
      {
        *((unsigned char *)a1 + 8) = 1;
      }
    }
  }

  return a1;
}

void sub_10022F7D8(void *a1)
{
  if (!sub_10022F920())
  {
    id v2 = +[NSAssertionHandler currentHandler];
    a1 = +[NSString stringWithUTF8String:"void *ManagedConfigurationLibrary(void)"];
    [v2 handleFailureInFunction:a1 file:@"NFManagedConfigMonitor.m" lineNumber:13 description:@"%s"];

    __break(1u);
    free(v3);
  }
  *(void *)(*(void *)(a1[4] + 8) + 24) = objc_getClass("MCProfileConnection");
  if (*(void *)(*(void *)(a1[4] + 8) + 24))
  {
    qword_1003476B8 = *(void *)(*(void *)(a1[4] + 8) + 24);
  }
  else
  {
    uint64_t v4 = +[NSAssertionHandler currentHandler];
    uint64_t v5 = +[NSString stringWithUTF8String:"Class getMCProfileConnectionClass(void)_block_invoke"];
    [v4 handleFailureInFunction:v5 file:@"NFManagedConfigMonitor.m" lineNumber:14 description:@"Unable to find class %s", "MCProfileConnection"];

    __break(1u);
  }
}

uint64_t sub_10022F920()
{
  if (!qword_1003476C0) {
    qword_1003476C0 = _sl_dlopen();
  }
  return qword_1003476C0;
}

uint64_t sub_10022F9F0()
{
  uint64_t result = _sl_dlopen();
  qword_1003476C0 = result;
  return result;
}

void sub_100230B00(uint64_t a1, void *a2)
{
  id v3 = a2;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v5(3, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", v8, ClassName, Name, 163, v3);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    uint64_t v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    objc_super v12 = object_getClassName(*(id *)(a1 + 32));
    int v13 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)int buf = 67110146;
    int v17 = v11;
    __int16 v18 = 2082;
    BOOL v19 = v12;
    __int16 v20 = 2082;
    uint64_t v21 = v13;
    __int16 v22 = 1024;
    int v23 = 163;
    __int16 v24 = 2114;
    id v25 = v3;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", buf, 0x2Cu);
  }
}

void sub_100230D34(uint64_t a1, void *a2)
{
  id v3 = a2;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v5(3, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", v8, ClassName, Name, 171, v3);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    uint64_t v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    objc_super v12 = object_getClassName(*(id *)(a1 + 32));
    int v13 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)int buf = 67110146;
    int v17 = v11;
    __int16 v18 = 2082;
    BOOL v19 = v12;
    __int16 v20 = 2082;
    uint64_t v21 = v13;
    __int16 v22 = 1024;
    int v23 = 171;
    __int16 v24 = 2114;
    id v25 = v3;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", buf, 0x2Cu);
  }
}

void sub_1002329AC(uint64_t a1, void *a2)
{
  id v3 = a2;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v5(3, "%c[%{public}s %{public}s]:%i error: %{public}@", v8, ClassName, Name, 288, v3);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    uint64_t v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    objc_super v12 = object_getClassName(*(id *)(a1 + 32));
    int v13 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)int buf = 67110146;
    int v21 = v11;
    __int16 v22 = 2082;
    int v23 = v12;
    __int16 v24 = 2082;
    id v25 = v13;
    __int16 v26 = 1024;
    int v27 = 288;
    __int16 v28 = 2114;
    id v29 = v3;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i error: %{public}@", buf, 0x2Cu);
  }

  v18[0] = _NSConcreteStackBlock;
  v18[1] = 3221225472;
  v18[2] = sub_100232BD4;
  v18[3] = &unk_100301F70;
  long long v19 = *(_OWORD *)(a1 + 32);
  uint64_t v14 = [(id)v19 _asynchronousRemoteProxyWithErrorHandler:v18];
  [v14 didStartSession:v3];

  int v15 = [*(id *)(a1 + 32) stsHelper];
  [v15 invalidate];

  [*(id *)(a1 + 32) setStsHelper:0];
}

void sub_100232BD4(uint64_t a1, void *a2)
{
  id v3 = a2;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v5(3, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", v8, ClassName, Name, 290, v3);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    uint64_t v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    objc_super v12 = object_getClassName(*(id *)(a1 + 32));
    int v13 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)int buf = 67110146;
    int v17 = v11;
    __int16 v18 = 2082;
    long long v19 = v12;
    __int16 v20 = 2082;
    int v21 = v13;
    __int16 v22 = 1024;
    int v23 = 290;
    __int16 v24 = 2114;
    id v25 = v3;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", buf, 0x2Cu);
  }
}

void sub_100232D6C(uint64_t a1)
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_100232DFC;
  v2[3] = &unk_100301F70;
  long long v3 = *(_OWORD *)(a1 + 32);
  id v1 = [(id)v3 _asynchronousRemoteProxyWithErrorHandler:v2];
  [v1 didStartSession:0];
}

void sub_100232DFC(uint64_t a1, void *a2)
{
  id v3 = a2;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v5(3, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", v8, ClassName, Name, 298, v3);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    uint64_t v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    objc_super v12 = object_getClassName(*(id *)(a1 + 32));
    int v13 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)int buf = 67110146;
    int v17 = v11;
    __int16 v18 = 2082;
    long long v19 = v12;
    __int16 v20 = 2082;
    int v21 = v13;
    __int16 v22 = 1024;
    int v23 = 298;
    __int16 v24 = 2114;
    id v25 = v3;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", buf, 0x2Cu);
  }
}

void sub_100232F94(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
      uint64_t Name = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v8 = 45;
      if (isMetaClass) {
        uint64_t v8 = 43;
      }
      v5(3, "%c[%{public}s %{public}s]:%i Reader start error: %{public}@", v8, ClassName, Name, 337, v3);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      objc_super v12 = object_getClassName(*(id *)(a1 + 32));
      int v13 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)int buf = 67110146;
      int v29 = v11;
      __int16 v30 = 2082;
      id v31 = v12;
      __int16 v32 = 2082;
      id v33 = v13;
      __int16 v34 = 1024;
      int v35 = 337;
      __int16 v36 = 2114;
      id v37 = v3;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Reader start error: %{public}@", buf, 0x2Cu);
    }

    uint64_t v14 = *(void *)(a1 + 40);
    id v15 = objc_alloc((Class)NSError);
    int v16 = +[NSString stringWithUTF8String:"nfcd"];
    id v17 = [v3 code];
    v26[0] = NSLocalizedDescriptionKey;
    if ((uint64_t)[v3 code] > 70) {
      uint64_t v18 = 71;
    }
    else {
      uint64_t v18 = (uint64_t)[v3 code];
    }
    long long v19 = +[NSString stringWithUTF8String:(&off_100307FD0)[v18]];
    v27[0] = v19;
    v27[1] = v3;
    v26[1] = NSUnderlyingErrorKey;
    v26[2] = @"Line";
    v27[2] = &off_100320008;
    v26[3] = @"Method";
    id v20 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v27[3] = v20;
    v26[4] = NSDebugDescriptionErrorKey;
    id v21 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 338];
    v27[4] = v21;
    __int16 v22 = +[NSDictionary dictionaryWithObjects:v27 forKeys:v26 count:5];
    id v23 = [v15 initWithDomain:v16 code:v17 userInfo:v22];
    (*(void (**)(uint64_t, id))(v14 + 16))(v14, v23);
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
}

void sub_1002332EC(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
      uint64_t Name = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v8 = 45;
      if (isMetaClass) {
        uint64_t v8 = 43;
      }
      v5(3, "%c[%{public}s %{public}s]:%i Device start error: %{public}@", v8, ClassName, Name, 373, v3);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      objc_super v12 = object_getClassName(*(id *)(a1 + 32));
      int v13 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)int buf = 67110146;
      int v29 = v11;
      __int16 v30 = 2082;
      id v31 = v12;
      __int16 v32 = 2082;
      id v33 = v13;
      __int16 v34 = 1024;
      int v35 = 373;
      __int16 v36 = 2114;
      id v37 = v3;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Device start error: %{public}@", buf, 0x2Cu);
    }

    uint64_t v14 = *(void *)(a1 + 40);
    id v15 = objc_alloc((Class)NSError);
    int v16 = +[NSString stringWithUTF8String:"nfcd"];
    id v17 = [v3 code];
    v26[0] = NSLocalizedDescriptionKey;
    if ((uint64_t)[v3 code] > 70) {
      uint64_t v18 = 71;
    }
    else {
      uint64_t v18 = (uint64_t)[v3 code];
    }
    long long v19 = +[NSString stringWithUTF8String:(&off_100307FD0)[v18]];
    v27[0] = v19;
    v27[1] = v3;
    v26[1] = NSUnderlyingErrorKey;
    v26[2] = @"Line";
    v27[2] = &off_100320020;
    v26[3] = @"Method";
    id v20 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v27[3] = v20;
    v26[4] = NSDebugDescriptionErrorKey;
    id v21 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 374];
    v27[4] = v21;
    __int16 v22 = +[NSDictionary dictionaryWithObjects:v27 forKeys:v26 count:5];
    id v23 = [v15 initWithDomain:v16 code:v17 userInfo:v22];
    (*(void (**)(uint64_t, id))(v14 + 16))(v14, v23);
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
}

void sub_100233B68(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [*(id *)(a1 + 32) driverWrapper];
  if (v4
    && (uint64_t v5 = (void *)v4,
        unsigned int v6 = [*(id *)(v4 + 88) readerModeProtectionActive],
        v5,
        v6))
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v8 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
      uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v12 = 45;
      if (isMetaClass) {
        uint64_t v12 = 43;
      }
      v8(4, "%c[%{public}s %{public}s]:%i Reader mode protection enabled", v12, ClassName, Name, 416);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v13 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      uint64_t v14 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v14)) {
        int v15 = 43;
      }
      else {
        int v15 = 45;
      }
      int v16 = object_getClassName(*(id *)(a1 + 32));
      id v17 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)int buf = 67109890;
      int v34 = v15;
      __int16 v35 = 2082;
      __int16 v36 = v16;
      __int16 v37 = 2082;
      int v38 = v17;
      __int16 v39 = 1024;
      int v40 = 416;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Reader mode protection enabled", buf, 0x22u);
    }

    uint64_t v18 = *(void *)(a1 + 40);
    id v19 = objc_alloc((Class)NSError);
    id v20 = +[NSString stringWithUTF8String:"nfcd"];
    v31[0] = NSLocalizedDescriptionKey;
    id v21 = +[NSString stringWithUTF8String:"Reader mode temporarily disabled"];
    v32[0] = v21;
    v32[1] = &off_100320050;
    v31[1] = @"Line";
    v31[2] = @"Method";
    id v22 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
    v32[2] = v22;
    v31[3] = NSDebugDescriptionErrorKey;
    id v23 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 417];
    v32[3] = v23;
    __int16 v24 = +[NSDictionary dictionaryWithObjects:v32 forKeys:v31 count:4];
    id v25 = [v19 initWithDomain:v20 code:47 userInfo:v24];
    (*(void (**)(uint64_t, id))(v18 + 16))(v18, v25);
  }
  else
  {
    if (!v3)
    {
      __int16 v26 = [*(id *)(a1 + 32) powerConsumptionReporter];
      sub_1001B0E88((uint64_t)v26, *(void **)(a1 + 32));

      int v27 = +[NFRoutingConfig readerModeWithFD:1];
      [v27 setPollingMask:19 tagConfig:48];
      __int16 v28 = +[_NFHardwareManager sharedHardwareManager];
      id v29 = [v28 setRoutingConfig:v27];
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

void sub_10023463C(uint64_t a1)
{
  if (([*(id *)(a1 + 32) didEnd] & 1) == 0)
  {
    id v5 = +[_NFHardwareManager sharedHardwareManager];
    id v2 = [v5 defaultRoutingConfig:3];
    id v3 = [v5 setRoutingConfig:v2];

    uint64_t v4 = [*(id *)(a1 + 32) powerConsumptionReporter];
    sub_1001B03F0((uint64_t)v4, *(void **)(a1 + 32));
  }
}

void sub_1002347F4(uint64_t a1)
{
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
      uint64_t Name = sel_getName(*(SEL *)(a1 + 64));
      uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 487, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      int v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      int v13 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v14 = sel_getName(*(SEL *)(a1 + 64));
      int v15 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)int buf = 67110146;
      int v65 = v12;
      __int16 v66 = 2082;
      __int16 v67 = v13;
      __int16 v68 = 2082;
      int v69 = v14;
      __int16 v70 = 1024;
      int v71 = 487;
      __int16 v72 = 2114;
      int v73 = v15;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v16 = *(void *)(a1 + 56);
    if (v16)
    {
      id v17 = objc_alloc((Class)NSError);
      id v18 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v62 = NSLocalizedDescriptionKey;
      id v19 = +[NSString stringWithUTF8String:"Session not active"];
      __int16 v63 = v19;
      id v20 = +[NSDictionary dictionaryWithObjects:&v63 forKeys:&v62 count:1];
      id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
      (*(void (**)(uint64_t, id))(v16 + 16))(v16, v21);

LABEL_15:
    }
  }
  else
  {
    long long v52 = 0u;
    long long v53 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    id v18 = *(id *)(a1 + 40);
    id v22 = (char *)[v18 countByEnumeratingWithState:&v50 objects:v61 count:16];
    if (v22)
    {
      id v23 = v22;
      uint64_t v24 = *(void *)v51;
      while (2)
      {
        for (i = 0; i != v23; ++i)
        {
          if (*(void *)v51 != v24) {
            objc_enumerationMutation(v18);
          }
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) == 0)
          {
            uint64_t v36 = *(void *)(a1 + 56);
            id v37 = objc_alloc((Class)NSError);
            int v38 = +[NSString stringWithUTF8String:"nfcd"];
            v59[0] = NSLocalizedDescriptionKey;
            __int16 v39 = +[NSString stringWithUTF8String:"Invalid Parameter"];
            v60[0] = v39;
            v60[1] = &off_100320068;
            v59[1] = @"Line";
            void v59[2] = @"Method";
            id v40 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 64))];
            v60[2] = v40;
            v59[3] = NSDebugDescriptionErrorKey;
            id v41 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 64)), 491];
            void v60[3] = v41;
            uint64_t v42 = v60;
            BOOL v43 = v59;
LABEL_38:
            uint64_t v44 = +[NSDictionary dictionaryWithObjects:v42 forKeys:v43 count:4];
            id v45 = [v37 initWithDomain:v38 code:10 userInfo:v44];
            (*(void (**)(uint64_t, id))(v36 + 16))(v36, v45);

            goto LABEL_15;
          }
        }
        id v23 = (char *)[v18 countByEnumeratingWithState:&v50 objects:v61 count:16];
        if (v23) {
          continue;
        }
        break;
      }
    }

    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    id v18 = *(id *)(a1 + 48);
    __int16 v26 = (char *)[v18 countByEnumeratingWithState:&v46 objects:v58 count:16];
    if (v26)
    {
      int v27 = v26;
      uint64_t v28 = *(void *)v47;
      while (2)
      {
        for (j = 0; j != v27; ++j)
        {
          if (*(void *)v47 != v28) {
            objc_enumerationMutation(v18);
          }
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) == 0)
          {
            uint64_t v36 = *(void *)(a1 + 56);
            id v37 = objc_alloc((Class)NSError);
            int v38 = +[NSString stringWithUTF8String:"nfcd"];
            v56[0] = NSLocalizedDescriptionKey;
            __int16 v39 = +[NSString stringWithUTF8String:"Invalid Parameter"];
            v57[0] = v39;
            v57[1] = &off_100320080;
            v56[1] = @"Line";
            v56[2] = @"Method";
            id v40 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 64))];
            v57[2] = v40;
            v56[3] = NSDebugDescriptionErrorKey;
            id v41 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 64)), 497];
            v57[3] = v41;
            uint64_t v42 = v57;
            BOOL v43 = v56;
            goto LABEL_38;
          }
        }
        int v27 = (char *)[v18 countByEnumeratingWithState:&v46 objects:v58 count:16];
        if (v27) {
          continue;
        }
        break;
      }
    }

    if ([*(id *)(a1 + 32) role] == (id)3 || !objc_msgSend(*(id *)(a1 + 32), "role"))
    {
      [*(id *)(a1 + 32) _startTNEPDeviceWithServices:*(void *)(a1 + 40) optionalRecords:*(void *)(a1 + 48) callback:*(void *)(a1 + 56)];
    }
    else
    {
      uint64_t v30 = *(void *)(a1 + 56);
      id v31 = objc_alloc((Class)NSError);
      __int16 v32 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v54 = NSLocalizedDescriptionKey;
      id v33 = +[NSString stringWithUTF8String:"Invalid State"];
      __int16 v55 = v33;
      int v34 = +[NSDictionary dictionaryWithObjects:&v55 forKeys:&v54 count:1];
      id v35 = [v31 initWithDomain:v32 code:12 userInfo:v34];
      (*(void (**)(uint64_t, id))(v30 + 16))(v30, v35);
    }
  }
}

void sub_10023500C(uint64_t a1)
{
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      __int16 v26 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
      uint64_t Name = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v30 = 45;
      if (isMetaClass) {
        uint64_t v30 = 43;
      }
      v26(6, "%c[%{public}s %{public}s]:%i ", v30, ClassName, Name, 517);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v31 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v32 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v32)) {
        int v33 = 43;
      }
      else {
        int v33 = 45;
      }
      int v34 = object_getClassName(*(id *)(a1 + 32));
      id v35 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)int buf = 67109890;
      int v58 = v33;
      __int16 v59 = 2082;
      int v60 = v34;
      __int16 v61 = 2082;
      NSErrorUserInfoKey v62 = v35;
      __int16 v63 = 1024;
      int v64 = 517;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
    }

    uint64_t v36 = [*(id *)(a1 + 32) tnepHandler];
    if (v36)
    {
      id v37 = (void *)v36;
      id v38 = [*(id *)(a1 + 32) role];

      if (v38 == (id)3)
      {
        id v18 = [*(id *)(a1 + 32) tnepHandler];
        [v18 tnepTagDeviceSendNDEFMessage:*(void *)(a1 + 40) callback:*(void *)(a1 + 48)];
        goto LABEL_16;
      }
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v39 = NFLogGetLogger();
    if (v39)
    {
      id v40 = (void (*)(uint64_t, const char *, ...))v39;
      id v41 = object_getClass(*(id *)(a1 + 32));
      BOOL v42 = class_isMetaClass(v41);
      BOOL v43 = object_getClassName(*(id *)(a1 + 32));
      long long v52 = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v44 = 45;
      if (v42) {
        uint64_t v44 = 43;
      }
      v40(3, "%c[%{public}s %{public}s]:%i Invalid state", v44, v43, v52, 519);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v45 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
    {
      long long v46 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v46)) {
        int v47 = 43;
      }
      else {
        int v47 = 45;
      }
      long long v48 = object_getClassName(*(id *)(a1 + 32));
      long long v49 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)int buf = 67109890;
      int v58 = v47;
      __int16 v59 = 2082;
      int v60 = v48;
      __int16 v61 = 2082;
      NSErrorUserInfoKey v62 = v49;
      __int16 v63 = 1024;
      int v64 = 519;
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid state", buf, 0x22u);
    }

    uint64_t v16 = *(void *)(a1 + 48);
    id v50 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v53 = NSLocalizedDescriptionKey;
    id v19 = +[NSString stringWithUTF8String:"Invalid State"];
    NSErrorUserInfoKey v54 = v19;
    id v20 = +[NSDictionary dictionaryWithObjects:&v54 forKeys:&v53 count:1];
    id v21 = v50;
    id v22 = v18;
    uint64_t v23 = 12;
LABEL_15:
    id v24 = [v21 initWithDomain:v22 code:v23 userInfo:v20];
    (*(void (**)(uint64_t, id))(v16 + 16))(v16, v24);

LABEL_16:
    return;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v2 = NFLogGetLogger();
  if (v2)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))v2;
    uint64_t v4 = object_getClass(*(id *)(a1 + 32));
    BOOL v5 = class_isMetaClass(v4);
    unsigned int v6 = object_getClassName(*(id *)(a1 + 32));
    id v7 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v9 = 45;
    if (v5) {
      uint64_t v9 = 43;
    }
    v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, v6, v7, 515, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    int v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    int v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 56));
    int v15 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)int buf = 67110146;
    int v58 = v12;
    __int16 v59 = 2082;
    int v60 = v13;
    __int16 v61 = 2082;
    NSErrorUserInfoKey v62 = v14;
    __int16 v63 = 1024;
    int v64 = 515;
    __int16 v65 = 2114;
    __int16 v66 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v16 = *(void *)(a1 + 48);
  if (v16)
  {
    id v17 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v55 = NSLocalizedDescriptionKey;
    id v19 = +[NSString stringWithUTF8String:"Session not active"];
    int v56 = v19;
    id v20 = +[NSDictionary dictionaryWithObjects:&v56 forKeys:&v55 count:1];
    id v21 = v17;
    id v22 = v18;
    uint64_t v23 = 54;
    goto LABEL_15;
  }
}

void sub_100235668(uint64_t a1)
{
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
      uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 532, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      int v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      int v13 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
      int v15 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)int buf = 67110146;
      int v47 = v12;
      __int16 v48 = 2082;
      long long v49 = v13;
      __int16 v50 = 2082;
      long long v51 = v14;
      __int16 v52 = 1024;
      int v53 = 532;
      __int16 v54 = 2114;
      NSErrorUserInfoKey v55 = v15;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v16 = *(void *)(a1 + 40);
    if (v16)
    {
      id v17 = objc_alloc((Class)NSError);
      id v18 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v44 = NSLocalizedDescriptionKey;
      id v19 = +[NSString stringWithUTF8String:"Session not active"];
      id v45 = v19;
      id v20 = +[NSDictionary dictionaryWithObjects:&v45 forKeys:&v44 count:1];
      id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
      (*(void (**)(uint64_t, id))(v16 + 16))(v16, v21);
    }
  }
  else if ([*(id *)(a1 + 32) role] == (id)4)
  {
    id v22 = *(void **)(a1 + 32);
    uint64_t v23 = *(void *)(a1 + 40);
    [v22 _startTNEPReaderWithCallback:v23];
  }
  else
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v24 = NFLogGetLogger();
    if (v24)
    {
      id v25 = (void (*)(uint64_t, const char *, ...))v24;
      __int16 v26 = object_getClass(*(id *)(a1 + 32));
      BOOL v27 = class_isMetaClass(v26);
      uint64_t v28 = object_getClassName(*(id *)(a1 + 32));
      id v41 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v29 = 45;
      if (v27) {
        uint64_t v29 = 43;
      }
      v25(3, "%c[%{public}s %{public}s]:%i Invalid state", v29, v28, v41, 535);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v30 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      id v31 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v31)) {
        int v32 = 43;
      }
      else {
        int v32 = 45;
      }
      int v33 = object_getClassName(*(id *)(a1 + 32));
      int v34 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)int buf = 67109890;
      int v47 = v32;
      __int16 v48 = 2082;
      long long v49 = v33;
      __int16 v50 = 2082;
      long long v51 = v34;
      __int16 v52 = 1024;
      int v53 = 535;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid state", buf, 0x22u);
    }

    uint64_t v35 = *(void *)(a1 + 40);
    id v36 = objc_alloc((Class)NSError);
    id v37 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v42 = NSLocalizedDescriptionKey;
    id v38 = +[NSString stringWithUTF8String:"Invalid State"];
    BOOL v43 = v38;
    uint64_t v39 = +[NSDictionary dictionaryWithObjects:&v43 forKeys:&v42 count:1];
    id v40 = [v36 initWithDomain:v37 code:12 userInfo:v39];
    (*(void (**)(uint64_t, id))(v35 + 16))(v35, v40);
  }
}

void sub_100235C1C(uint64_t a1)
{
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    id v25 = [*(id *)(a1 + 32) tnepHandler];

    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    BOOL v27 = (void (*)(uint64_t, const char *, ...))Logger;
    if (v25)
    {
      if (Logger)
      {
        Class = object_getClass(*(id *)(a1 + 32));
        BOOL isMetaClass = class_isMetaClass(Class);
        Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
        uint64_t Name = sel_getName(*(SEL *)(a1 + 56));
        uint64_t v32 = 45;
        if (isMetaClass) {
          uint64_t v32 = 43;
        }
        v27(6, "%c[%{public}s %{public}s]:%i %{public}@", v32, ClassName, Name, 553, *(void *)(a1 + 40));
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v33 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        int v34 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v34)) {
          int v35 = 43;
        }
        else {
          int v35 = 45;
        }
        id v36 = object_getClassName(*(id *)(a1 + 32));
        id v37 = sel_getName(*(SEL *)(a1 + 56));
        id v38 = *(void **)(a1 + 40);
        *(_DWORD *)int buf = 67110146;
        int v55 = v35;
        __int16 v56 = 2082;
        unsigned __int16 v57 = v36;
        __int16 v58 = 2082;
        __int16 v59 = v37;
        __int16 v60 = 1024;
        int v61 = 553;
        __int16 v62 = 2114;
        __int16 v63 = v38;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
      }

      id v18 = [*(id *)(a1 + 32) tnepHandler];
      [v18 tnepReaderSelectService:*(void *)(a1 + 40) callback:*(void *)(a1 + 48)];
      goto LABEL_16;
    }
    if (Logger)
    {
      uint64_t v39 = object_getClass(*(id *)(a1 + 32));
      BOOL v40 = class_isMetaClass(v39);
      id v41 = object_getClassName(*(id *)(a1 + 32));
      long long v49 = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v42 = 45;
      if (v40) {
        uint64_t v42 = 43;
      }
      v27(3, "%c[%{public}s %{public}s]:%i Missing tnepHandler", v42, v41, v49, 550);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    BOOL v43 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      NSErrorUserInfoKey v44 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v44)) {
        int v45 = 43;
      }
      else {
        int v45 = 45;
      }
      long long v46 = object_getClassName(*(id *)(a1 + 32));
      int v47 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)int buf = 67109890;
      int v55 = v45;
      __int16 v56 = 2082;
      unsigned __int16 v57 = v46;
      __int16 v58 = 2082;
      __int16 v59 = v47;
      __int16 v60 = 1024;
      int v61 = 550;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Missing tnepHandler", buf, 0x22u);
    }

    uint64_t v16 = *(void *)(a1 + 48);
    id v48 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v50 = NSLocalizedDescriptionKey;
    id v19 = +[NSString stringWithUTF8String:"Invalid State"];
    long long v51 = v19;
    id v20 = +[NSDictionary dictionaryWithObjects:&v51 forKeys:&v50 count:1];
    id v21 = v48;
    id v22 = v18;
    uint64_t v23 = 12;
LABEL_15:
    id v24 = [v21 initWithDomain:v22 code:v23 userInfo:v20];
    (*(void (**)(uint64_t, id))(v16 + 16))(v16, v24);

LABEL_16:
    return;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v2 = NFLogGetLogger();
  if (v2)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))v2;
    uint64_t v4 = object_getClass(*(id *)(a1 + 32));
    BOOL v5 = class_isMetaClass(v4);
    unsigned int v6 = object_getClassName(*(id *)(a1 + 32));
    id v7 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v9 = 45;
    if (v5) {
      uint64_t v9 = 43;
    }
    v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, v6, v7, 547, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    int v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    int v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 56));
    int v15 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)int buf = 67110146;
    int v55 = v12;
    __int16 v56 = 2082;
    unsigned __int16 v57 = v13;
    __int16 v58 = 2082;
    __int16 v59 = v14;
    __int16 v60 = 1024;
    int v61 = 547;
    __int16 v62 = 2114;
    __int16 v63 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v16 = *(void *)(a1 + 48);
  if (v16)
  {
    id v17 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v52 = NSLocalizedDescriptionKey;
    id v19 = +[NSString stringWithUTF8String:"Session not active"];
    int v53 = v19;
    id v20 = +[NSDictionary dictionaryWithObjects:&v53 forKeys:&v52 count:1];
    id v21 = v17;
    id v22 = v18;
    uint64_t v23 = 54;
    goto LABEL_15;
  }
}

void sub_10023626C(uint64_t a1)
{
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    id v25 = [*(id *)(a1 + 32) tnepHandler];

    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    BOOL v27 = (void (*)(uint64_t, const char *, ...))Logger;
    if (v25)
    {
      if (Logger)
      {
        Class = object_getClass(*(id *)(a1 + 32));
        BOOL isMetaClass = class_isMetaClass(Class);
        Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
        uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v31 = 45;
        if (isMetaClass) {
          uint64_t v31 = 43;
        }
        v27(6, "%c[%{public}s %{public}s]:%i ", v31, ClassName, Name, 568);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v32 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        int v33 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v33)) {
          int v34 = 43;
        }
        else {
          int v34 = 45;
        }
        int v35 = object_getClassName(*(id *)(a1 + 32));
        id v36 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)int buf = 67109890;
        int v54 = v34;
        __int16 v55 = 2082;
        __int16 v56 = v35;
        __int16 v57 = 2082;
        __int16 v58 = v36;
        __int16 v59 = 1024;
        int v60 = 568;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
      }

      id v18 = [*(id *)(a1 + 32) tnepHandler];
      [v18 tnepReaderDeselectWithCallback:*(void *)(a1 + 40)];
      goto LABEL_16;
    }
    if (Logger)
    {
      id v37 = object_getClass(*(id *)(a1 + 32));
      BOOL v38 = class_isMetaClass(v37);
      uint64_t v39 = object_getClassName(*(id *)(a1 + 32));
      id v48 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v40 = 45;
      if (v38) {
        uint64_t v40 = 43;
      }
      v27(3, "%c[%{public}s %{public}s]:%i Missing tnepHandler", v40, v39, v48, 565);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v41 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
    {
      uint64_t v42 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v42)) {
        int v43 = 43;
      }
      else {
        int v43 = 45;
      }
      NSErrorUserInfoKey v44 = object_getClassName(*(id *)(a1 + 32));
      int v45 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)int buf = 67109890;
      int v54 = v43;
      __int16 v55 = 2082;
      __int16 v56 = v44;
      __int16 v57 = 2082;
      __int16 v58 = v45;
      __int16 v59 = 1024;
      int v60 = 565;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Missing tnepHandler", buf, 0x22u);
    }

    uint64_t v16 = *(void *)(a1 + 40);
    id v46 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v49 = NSLocalizedDescriptionKey;
    id v19 = +[NSString stringWithUTF8String:"Invalid State"];
    NSErrorUserInfoKey v50 = v19;
    id v20 = +[NSDictionary dictionaryWithObjects:&v50 forKeys:&v49 count:1];
    id v21 = v46;
    id v22 = v18;
    uint64_t v23 = 12;
LABEL_15:
    id v24 = [v21 initWithDomain:v22 code:v23 userInfo:v20];
    (*(void (**)(uint64_t, id))(v16 + 16))(v16, v24);

LABEL_16:
    return;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v2 = NFLogGetLogger();
  if (v2)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))v2;
    uint64_t v4 = object_getClass(*(id *)(a1 + 32));
    BOOL v5 = class_isMetaClass(v4);
    unsigned int v6 = object_getClassName(*(id *)(a1 + 32));
    id v7 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v9 = 45;
    if (v5) {
      uint64_t v9 = 43;
    }
    v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, v6, v7, 562, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    int v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    int v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
    int v15 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)int buf = 67110146;
    int v54 = v12;
    __int16 v55 = 2082;
    __int16 v56 = v13;
    __int16 v57 = 2082;
    __int16 v58 = v14;
    __int16 v59 = 1024;
    int v60 = 562;
    __int16 v61 = 2114;
    __int16 v62 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v16 = *(void *)(a1 + 40);
  if (v16)
  {
    id v17 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v51 = NSLocalizedDescriptionKey;
    id v19 = +[NSString stringWithUTF8String:"Session not active"];
    NSErrorUserInfoKey v52 = v19;
    id v20 = +[NSDictionary dictionaryWithObjects:&v52 forKeys:&v51 count:1];
    id v21 = v17;
    id v22 = v18;
    uint64_t v23 = 54;
    goto LABEL_15;
  }
}

void sub_1002368CC(uint64_t a1)
{
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    id v25 = [*(id *)(a1 + 32) tnepHandler];

    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    BOOL v27 = (void (*)(uint64_t, const char *, ...))Logger;
    if (v25)
    {
      if (Logger)
      {
        Class = object_getClass(*(id *)(a1 + 32));
        BOOL isMetaClass = class_isMetaClass(Class);
        Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
        uint64_t Name = sel_getName(*(SEL *)(a1 + 56));
        uint64_t v31 = 45;
        if (isMetaClass) {
          uint64_t v31 = 43;
        }
        v27(6, "%c[%{public}s %{public}s]:%i ", v31, ClassName, Name, 584);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v32 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        int v33 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v33)) {
          int v34 = 43;
        }
        else {
          int v34 = 45;
        }
        int v35 = object_getClassName(*(id *)(a1 + 32));
        id v36 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)int buf = 67109890;
        int v54 = v34;
        __int16 v55 = 2082;
        __int16 v56 = v35;
        __int16 v57 = 2082;
        __int16 v58 = v36;
        __int16 v59 = 1024;
        int v60 = 584;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
      }

      id v18 = [*(id *)(a1 + 32) tnepHandler];
      [v18 tnepReaderSend:*(void *)(a1 + 40) callback:*(void *)(a1 + 48)];
      goto LABEL_16;
    }
    if (Logger)
    {
      id v37 = object_getClass(*(id *)(a1 + 32));
      BOOL v38 = class_isMetaClass(v37);
      uint64_t v39 = object_getClassName(*(id *)(a1 + 32));
      id v48 = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v40 = 45;
      if (v38) {
        uint64_t v40 = 43;
      }
      v27(3, "%c[%{public}s %{public}s]:%i Missing tnepHandler", v40, v39, v48, 581);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v41 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
    {
      uint64_t v42 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v42)) {
        int v43 = 43;
      }
      else {
        int v43 = 45;
      }
      NSErrorUserInfoKey v44 = object_getClassName(*(id *)(a1 + 32));
      int v45 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)int buf = 67109890;
      int v54 = v43;
      __int16 v55 = 2082;
      __int16 v56 = v44;
      __int16 v57 = 2082;
      __int16 v58 = v45;
      __int16 v59 = 1024;
      int v60 = 581;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Missing tnepHandler", buf, 0x22u);
    }

    uint64_t v16 = *(void *)(a1 + 48);
    id v46 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v49 = NSLocalizedDescriptionKey;
    id v19 = +[NSString stringWithUTF8String:"Invalid State"];
    NSErrorUserInfoKey v50 = v19;
    id v20 = +[NSDictionary dictionaryWithObjects:&v50 forKeys:&v49 count:1];
    id v21 = v46;
    id v22 = v18;
    uint64_t v23 = 12;
LABEL_15:
    id v24 = [v21 initWithDomain:v22 code:v23 userInfo:v20];
    (*(void (**)(uint64_t, void, id))(v16 + 16))(v16, 0, v24);

LABEL_16:
    return;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v2 = NFLogGetLogger();
  if (v2)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))v2;
    uint64_t v4 = object_getClass(*(id *)(a1 + 32));
    BOOL v5 = class_isMetaClass(v4);
    unsigned int v6 = object_getClassName(*(id *)(a1 + 32));
    id v7 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v9 = 45;
    if (v5) {
      uint64_t v9 = 43;
    }
    v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, v6, v7, 578, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    int v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    int v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 56));
    int v15 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)int buf = 67110146;
    int v54 = v12;
    __int16 v55 = 2082;
    __int16 v56 = v13;
    __int16 v57 = 2082;
    __int16 v58 = v14;
    __int16 v59 = 1024;
    int v60 = 578;
    __int16 v61 = 2114;
    __int16 v62 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v16 = *(void *)(a1 + 48);
  if (v16)
  {
    id v17 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v51 = NSLocalizedDescriptionKey;
    id v19 = +[NSString stringWithUTF8String:"Session not active"];
    NSErrorUserInfoKey v52 = v19;
    id v20 = +[NSDictionary dictionaryWithObjects:&v52 forKeys:&v51 count:1];
    id v21 = v17;
    id v22 = v18;
    uint64_t v23 = 54;
    goto LABEL_15;
  }
}

void sub_100236F08(uint64_t a1)
{
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    id v25 = [*(id *)(a1 + 32) tnepHandler];

    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    BOOL v27 = (void (*)(uint64_t, const char *, ...))Logger;
    if (v25)
    {
      if (Logger)
      {
        Class = object_getClass(*(id *)(a1 + 32));
        BOOL isMetaClass = class_isMetaClass(Class);
        Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
        uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v31 = 45;
        if (isMetaClass) {
          uint64_t v31 = 43;
        }
        v27(6, "%c[%{public}s %{public}s]:%i ", v31, ClassName, Name, 599);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v32 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        int v33 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v33)) {
          int v34 = 43;
        }
        else {
          int v34 = 45;
        }
        int v35 = object_getClassName(*(id *)(a1 + 32));
        id v36 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)int buf = 67109890;
        int v57 = v34;
        __int16 v58 = 2082;
        __int16 v59 = v35;
        __int16 v60 = 2082;
        __int16 v61 = v36;
        __int16 v62 = 1024;
        int v63 = 599;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
      }

      id v37 = [*(id *)(a1 + 32) driverWrapper];
      BOOL v38 = [*(id *)(a1 + 32) connectedTag];
      sub_1001900C4(v37, v38, 0);

      uint64_t v39 = [*(id *)(a1 + 32) tnepHandler];
      [v39 tnepReaderRestartPollingWithCallback:*(void *)(a1 + 40)];

      id v18 = [*(id *)(a1 + 32) driverWrapper];
      sub_1002128B4(v18);
      goto LABEL_16;
    }
    if (Logger)
    {
      uint64_t v40 = object_getClass(*(id *)(a1 + 32));
      BOOL v41 = class_isMetaClass(v40);
      uint64_t v42 = object_getClassName(*(id *)(a1 + 32));
      NSErrorUserInfoKey v51 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v43 = 45;
      if (v41) {
        uint64_t v43 = 43;
      }
      v27(3, "%c[%{public}s %{public}s]:%i Missing tnepHandler", v43, v42, v51, 596);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    NSErrorUserInfoKey v44 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
      int v45 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v45)) {
        int v46 = 43;
      }
      else {
        int v46 = 45;
      }
      int v47 = object_getClassName(*(id *)(a1 + 32));
      id v48 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)int buf = 67109890;
      int v57 = v46;
      __int16 v58 = 2082;
      __int16 v59 = v47;
      __int16 v60 = 2082;
      __int16 v61 = v48;
      __int16 v62 = 1024;
      int v63 = 596;
      _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Missing tnepHandler", buf, 0x22u);
    }

    uint64_t v16 = *(void *)(a1 + 40);
    id v49 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v52 = NSLocalizedDescriptionKey;
    id v19 = +[NSString stringWithUTF8String:"Invalid State"];
    int v53 = v19;
    id v20 = +[NSDictionary dictionaryWithObjects:&v53 forKeys:&v52 count:1];
    id v21 = v49;
    id v22 = v18;
    uint64_t v23 = 12;
LABEL_15:
    id v24 = [v21 initWithDomain:v22 code:v23 userInfo:v20];
    (*(void (**)(uint64_t, id))(v16 + 16))(v16, v24);

LABEL_16:
    return;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v2 = NFLogGetLogger();
  if (v2)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))v2;
    uint64_t v4 = object_getClass(*(id *)(a1 + 32));
    BOOL v5 = class_isMetaClass(v4);
    unsigned int v6 = object_getClassName(*(id *)(a1 + 32));
    id v7 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v9 = 45;
    if (v5) {
      uint64_t v9 = 43;
    }
    v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, v6, v7, 593, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    int v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    int v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
    int v15 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)int buf = 67110146;
    int v57 = v12;
    __int16 v58 = 2082;
    __int16 v59 = v13;
    __int16 v60 = 2082;
    __int16 v61 = v14;
    __int16 v62 = 1024;
    int v63 = 593;
    __int16 v64 = 2114;
    __int16 v65 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v16 = *(void *)(a1 + 40);
  if (v16)
  {
    id v17 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v54 = NSLocalizedDescriptionKey;
    id v19 = +[NSString stringWithUTF8String:"Session not active"];
    __int16 v55 = v19;
    id v20 = +[NSDictionary dictionaryWithObjects:&v55 forKeys:&v54 count:1];
    id v21 = v17;
    id v22 = v18;
    uint64_t v23 = 54;
    goto LABEL_15;
  }
}

void sub_100237868(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,id location)
{
}

void sub_100237884(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(WeakRetained);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(WeakRetained);
      uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v8 = 45;
      if (isMetaClass) {
        uint64_t v8 = 43;
      }
      v4(6, "%c[%{public}s %{public}s]:%i ", v8, ClassName, Name, 617);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = object_getClass(WeakRetained);
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      int v12 = object_getClassName(WeakRetained);
      int v13 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)int buf = 67109890;
      int v20 = v11;
      __int16 v21 = 2082;
      id v22 = v12;
      __int16 v23 = 2082;
      id v24 = v13;
      __int16 v25 = 1024;
      int v26 = 617;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
    }

    uint64_t v14 = [WeakRetained tnepHandler];
    [v14 tnepServiceInvalidate];

    [WeakRetained setTnepHandler:0];
    int v15 = +[_NFHardwareManager sharedHardwareManager];
    uint64_t v16 = +[NFRoutingConfig embeddedWiredModeWithFD:1];
    id v17 = [v15 setRoutingConfig:v16];
  }
}

void sub_100237E68(uint64_t a1, void *a2)
{
  id v3 = a2;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    BOOL v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v5(3, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", v8, ClassName, Name, 644, v3);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    uint64_t v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    int v12 = object_getClassName(*(id *)(a1 + 32));
    int v13 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)int buf = 67110146;
    int v17 = v11;
    __int16 v18 = 2082;
    id v19 = v12;
    __int16 v20 = 2082;
    __int16 v21 = v13;
    __int16 v22 = 1024;
    int v23 = 644;
    __int16 v24 = 2114;
    id v25 = v3;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", buf, 0x2Cu);
  }
}

void sub_1002384D8(uint64_t a1, void *a2)
{
  id v3 = a2;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    BOOL v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v5(3, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", v8, ClassName, Name, 659, v3);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    uint64_t v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    int v12 = object_getClassName(*(id *)(a1 + 32));
    int v13 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)int buf = 67110146;
    int v17 = v11;
    __int16 v18 = 2082;
    id v19 = v12;
    __int16 v20 = 2082;
    __int16 v21 = v13;
    __int16 v22 = 1024;
    int v23 = 659;
    __int16 v24 = 2114;
    id v25 = v3;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", buf, 0x2Cu);
  }
}

void sub_100238670(uint64_t a1, void *a2)
{
  id v3 = a2;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    BOOL v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v5(3, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", v8, ClassName, Name, 674, v3);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    uint64_t v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    int v12 = object_getClassName(*(id *)(a1 + 32));
    int v13 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)int buf = 67110146;
    int v17 = v11;
    __int16 v18 = 2082;
    id v19 = v12;
    __int16 v20 = 2082;
    __int16 v21 = v13;
    __int16 v22 = 1024;
    int v23 = 674;
    __int16 v24 = 2114;
    id v25 = v3;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", buf, 0x2Cu);
  }
}

void sub_100238808(uint64_t a1, void *a2)
{
  id v3 = a2;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    BOOL v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v5(3, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", v8, ClassName, Name, 678, v3);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    uint64_t v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    int v12 = object_getClassName(*(id *)(a1 + 32));
    int v13 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)int buf = 67110146;
    int v17 = v11;
    __int16 v18 = 2082;
    id v19 = v12;
    __int16 v20 = 2082;
    __int16 v21 = v13;
    __int16 v22 = 1024;
    int v23 = 678;
    __int16 v24 = 2114;
    id v25 = v3;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", buf, 0x2Cu);
  }
}

void sub_100238AE8(uint64_t a1, void *a2, char a3, void *a4)
{
  id v7 = a2;
  id v8 = a4;
  [*(id *)(a1 + 32) setDeviceHandoverSelectError:v8];
  if (v8)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v10 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
      uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v13 = 45;
      if (isMetaClass) {
        uint64_t v13 = 43;
      }
      v10(3, "%c[%{public}s %{public}s]:%i CH process error=%{public}@", v13, ClassName, Name, 692, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v14 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      int v15 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v15)) {
        int v16 = 43;
      }
      else {
        int v16 = 45;
      }
      int v17 = object_getClassName(*(id *)(a1 + 32));
      __int16 v18 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)int buf = 67110146;
      int v34 = v16;
      __int16 v35 = 2082;
      id v36 = v17;
      __int16 v37 = 2082;
      BOOL v38 = v18;
      __int16 v39 = 1024;
      int v40 = 692;
      __int16 v41 = 2114;
      id v42 = v8;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i CH process error=%{public}@", buf, 0x2Cu);
    }
  }
  if ([v7 length])
  {
    id v19 = objc_alloc((Class)NFNdefMessageInternal);
    id v20 = v7;
    id v21 = [v19 initWithBytes:[v20 bytes] length:[v20 length]];
  }
  else
  {
    id v21 = [*(id *)(a1 + 32) createCHSelectErrorMessage];
  }
  __int16 v22 = v21;
  int v23 = [*(id *)(a1 + 32) tnepHandler];
  v29[0] = _NSConcreteStackBlock;
  v29[1] = 3221225472;
  v29[2] = sub_100238D9C;
  v29[3] = &unk_1003022C8;
  uint64_t v24 = *(void *)(a1 + 32);
  uint64_t v25 = *(void *)(a1 + 40);
  id v30 = v8;
  uint64_t v31 = v25;
  v29[4] = v24;
  char v32 = a3;
  id v26 = v8;
  [v23 tnepTagDeviceSendNDEFMessage:v22 callback:v29];
}

void sub_100238D9C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      BOOL v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
      uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v8 = 45;
      if (isMetaClass) {
        uint64_t v8 = 43;
      }
      v5(3, "%c[%{public}s %{public}s]:%i error=%{public}@", v8, ClassName, Name, 701, v3);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v9 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      goto LABEL_12;
    }
    uint64_t v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    int v12 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v13 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)int buf = 67110146;
    *(_DWORD *)id v36 = v11;
    *(_WORD *)&v36[4] = 2082;
    *(void *)&v36[6] = v12;
    *(_WORD *)&v36[14] = 2082;
    *(void *)&v36[16] = v13;
    __int16 v37 = 1024;
    int v38 = 701;
    __int16 v39 = 2114;
    id v40 = v3;
    uint64_t v14 = "%c[%{public}s %{public}s]:%i error=%{public}@";
    int v15 = v9;
    os_log_type_t v16 = OS_LOG_TYPE_ERROR;
    uint32_t v17 = 44;
LABEL_11:
    _os_log_impl((void *)&_mh_execute_header, v15, v16, v14, buf, v17);
LABEL_12:

    goto LABEL_14;
  }
  if (!*(void *)(a1 + 40) && *(unsigned char *)(a1 + 56))
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v22 = NFLogGetLogger();
    if (v22)
    {
      int v23 = (void (*)(uint64_t, const char *, ...))v22;
      uint64_t v24 = object_getClass(*(id *)(a1 + 32));
      BOOL v25 = class_isMetaClass(v24);
      id v26 = object_getClassName(*(id *)(a1 + 32));
      int v34 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v27 = 45;
      if (v25) {
        uint64_t v27 = 43;
      }
      v23(6, "%c[%{public}s %{public}s]:%i TNEP is completed", v27, v26, v34, 703);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v9 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_12;
    }
    uint64_t v28 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v28)) {
      int v29 = 43;
    }
    else {
      int v29 = 45;
    }
    id v30 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v31 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)int buf = 67109890;
    *(_DWORD *)id v36 = v29;
    *(_WORD *)&v36[4] = 2082;
    *(void *)&v36[6] = v30;
    *(_WORD *)&v36[14] = 2082;
    *(void *)&v36[16] = v31;
    __int16 v37 = 1024;
    int v38 = 703;
    uint64_t v14 = "%c[%{public}s %{public}s]:%i TNEP is completed";
    int v15 = v9;
    os_log_type_t v16 = OS_LOG_TYPE_DEFAULT;
    uint32_t v17 = 34;
    goto LABEL_11;
  }
LABEL_14:
  __int16 v18 = NFSharedSignpostLog();
  id v19 = (char *)[*(id *)(a1 + 32) signpostId];
  if ((unint64_t)(v19 - 1) <= 0xFFFFFFFFFFFFFFFDLL)
  {
    os_signpost_id_t v20 = (os_signpost_id_t)v19;
    if (os_signpost_enabled(v18))
    {
      if (v3)
      {
        id v21 = "Failed";
      }
      else
      {
        id v21 = "Failed";
        if (!*(void *)(a1 + 40) && *(unsigned char *)(a1 + 56)) {
          id v21 = "Completed";
        }
      }
      *(_DWORD *)int buf = 136315394;
      *(void *)id v36 = v21;
      *(_WORD *)&v36[8] = 2112;
      *(void *)&v36[10] = v3;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v18, OS_SIGNPOST_INTERVAL_END, v20, "CH_Negotiation", "status=%s, error=%@", buf, 0x16u);
    }
  }
}

void sub_1002395AC(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = objc_alloc((Class)NSError);
  BOOL v5 = +[NSString stringWithUTF8String:"nfcd"];
  id v6 = [v3 code];
  v16[0] = NSLocalizedDescriptionKey;
  if ((uint64_t)[v3 code] > 70) {
    uint64_t v7 = 71;
  }
  else {
    uint64_t v7 = (uint64_t)[v3 code];
  }
  uint64_t v8 = +[NSString stringWithUTF8String:(&off_100307FD0)[v7]];
  v17[0] = v8;
  v17[1] = v3;
  v16[1] = NSUnderlyingErrorKey;
  v16[2] = @"Line";
  id v17[2] = &off_100320098;
  v16[3] = @"Method";
  id v9 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 40))];
  v17[3] = v9;
  void v16[4] = NSDebugDescriptionErrorKey;
  id v10 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 40)), 731];
  void v17[4] = v10;
  int v11 = +[NSDictionary dictionaryWithObjects:v17 forKeys:v16 count:5];
  id v12 = [v4 initWithDomain:v5 code:v6 userInfo:v11];

  v14[0] = _NSConcreteStackBlock;
  v14[1] = 3221225472;
  void v14[2] = sub_100239834;
  void v14[3] = &unk_100301F70;
  long long v15 = *(_OWORD *)(a1 + 32);
  uint64_t v13 = [(id)v15 _asynchronousRemoteProxyWithErrorHandler:v14];
  [v13 connectionHandoverProcessFailure:v12];

  if ([v3 code] == (id)47) {
    [*(id *)(a1 + 32) tnepReaderServicesAborted:v3];
  }
}

void sub_100239834(uint64_t a1, void *a2)
{
  id v3 = a2;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    BOOL v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v5(3, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", v8, ClassName, Name, 733, v3);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    id v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    id v12 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v13 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)int buf = 67110146;
    int v17 = v11;
    __int16 v18 = 2082;
    id v19 = v12;
    __int16 v20 = 2082;
    id v21 = v13;
    __int16 v22 = 1024;
    int v23 = 733;
    __int16 v24 = 2114;
    id v25 = v3;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", buf, 0x2Cu);
  }
}

void sub_1002399CC(uint64_t a1, void *a2)
{
  id v3 = a2;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    BOOL v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v5(3, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", v8, ClassName, Name, 742, v3);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    id v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    id v12 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v13 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)int buf = 67110146;
    int v17 = v11;
    __int16 v18 = 2082;
    id v19 = v12;
    __int16 v20 = 2082;
    id v21 = v13;
    __int16 v22 = 1024;
    int v23 = 742;
    __int16 v24 = 2114;
    id v25 = v3;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", buf, 0x2Cu);
  }
}

void sub_100239B64(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      BOOL v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
      uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v8 = 45;
      if (isMetaClass) {
        uint64_t v8 = 43;
      }
      v5(3, "%c[%{public}s %{public}s]:%i select failed, error=%{public}@", v8, ClassName, Name, 747, v3);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      id v10 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      id v12 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v13 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)int buf = 67110146;
      int v23 = v11;
      __int16 v24 = 2082;
      id v25 = v12;
      __int16 v26 = 2082;
      uint64_t v27 = v13;
      __int16 v28 = 1024;
      int v29 = 747;
      __int16 v30 = 2114;
      id v31 = v3;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i select failed, error=%{public}@", buf, 0x2Cu);
    }

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    uint64_t v14 = [*(id *)(a1 + 32) stsHelper];
    long long v15 = [*(id *)(a1 + 32) workQueue];
    v20[0] = _NSConcreteStackBlock;
    v20[1] = 3221225472;
    void v20[2] = sub_100239DC4;
    v20[3] = &unk_100302318;
    v20[4] = *(void *)(a1 + 32);
    long long v19 = *(_OWORD *)(a1 + 40);
    id v16 = (id)v19;
    long long v21 = v19;
    [v14 generateConnectionHandoverRequestWithQueue:v15 responseHandler:v20];
  }
}

void sub_100239DC4(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v8 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
      uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v11 = 45;
      if (isMetaClass) {
        uint64_t v11 = 43;
      }
      v8(3, "%c[%{public}s %{public}s]:%i CH Request generation fail: %{public}@", v11, ClassName, Name, 755, v6);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v12 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      uint64_t v13 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v13)) {
        int v14 = 43;
      }
      else {
        int v14 = 45;
      }
      long long v15 = object_getClassName(*(id *)(a1 + 32));
      id v16 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)int buf = 67110146;
      int v28 = v14;
      __int16 v29 = 2082;
      __int16 v30 = v15;
      __int16 v31 = 2082;
      char v32 = v16;
      __int16 v33 = 1024;
      int v34 = 755;
      __int16 v35 = 2114;
      id v36 = v6;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i CH Request generation fail: %{public}@", buf, 0x2Cu);
    }

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    id v17 = objc_alloc((Class)NFNdefMessageInternal);
    id v18 = v5;
    id v19 = [v17 initWithBytes:[v18 bytes] length:[v18 length]];
    __int16 v20 = [*(id *)(a1 + 32) tnepHandler];
    v25[0] = _NSConcreteStackBlock;
    v25[1] = 3221225472;
    v25[2] = sub_10023A064;
    v25[3] = &unk_100302340;
    v25[4] = *(void *)(a1 + 32);
    long long v24 = *(_OWORD *)(a1 + 40);
    id v21 = (id)v24;
    long long v26 = v24;
    [v20 tnepReaderSend:v19 callback:v25];
  }
}

void sub_10023A064(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v8 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
      uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v11 = 45;
      if (isMetaClass) {
        uint64_t v11 = 43;
      }
      v8(3, "%c[%{public}s %{public}s]:%i CH exchange error=%{public}@", v11, ClassName, Name, 763, v6);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v12 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      uint64_t v13 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v13)) {
        int v14 = 43;
      }
      else {
        int v14 = 45;
      }
      long long v15 = object_getClassName(*(id *)(a1 + 32));
      id v16 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)int buf = 67110146;
      int v30 = v14;
      __int16 v31 = 2082;
      char v32 = v15;
      __int16 v33 = 2082;
      int v34 = v16;
      __int16 v35 = 1024;
      int v36 = 763;
      __int16 v37 = 2114;
      id v38 = v6;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i CH exchange error=%{public}@", buf, 0x2Cu);
    }

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    id v17 = [*(id *)(a1 + 32) stsHelper];
    id v18 = [v5 asData];
    id v19 = [*(id *)(a1 + 32) workQueue];
    v27[0] = _NSConcreteStackBlock;
    v27[1] = 3221225472;
    v27[2] = sub_10023A35C;
    v27[3] = &unk_100302228;
    v27[4] = *(void *)(a1 + 32);
    long long v25 = *(_OWORD *)(a1 + 40);
    id v20 = (id)v25;
    long long v28 = v25;
    [v17 connectRemoteWithConnectionHandoverSelect:v18 callbackQueue:v19 responseHandler:v27];

    id v21 = [*(id *)(a1 + 32) tnepHandler];
    v26[0] = _NSConcreteStackBlock;
    v26[1] = 3221225472;
    v26[2] = sub_10023A50C;
    v26[3] = &unk_100301F70;
    uint64_t v22 = *(void *)(a1 + 48);
    v26[4] = *(void *)(a1 + 32);
    void v26[5] = v22;
    [v21 tnepReaderDeselectWithCallback:v26];
  }
}

void sub_10023A35C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
      uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v8 = 45;
      if (isMetaClass) {
        uint64_t v8 = 43;
      }
      v5(3, "%c[%{public}s %{public}s]:%i AC connection failure: %{public}@", v8, ClassName, Name, 773, v3);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      id v10 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      id v12 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v13 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)int buf = 67110146;
      int v17 = v11;
      __int16 v18 = 2082;
      id v19 = v12;
      __int16 v20 = 2082;
      id v21 = v13;
      __int16 v22 = 1024;
      int v23 = 773;
      __int16 v24 = 2114;
      id v25 = v3;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i AC connection failure: %{public}@", buf, 0x2Cu);
    }

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

void sub_10023A50C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
      uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v8 = 45;
      if (isMetaClass) {
        uint64_t v8 = 43;
      }
      v5(6, "%c[%{public}s %{public}s]:%i Deselect failure: %@; ignore since AC has successfully negotiated and connection attempt started",
        v8,
        ClassName,
        Name,
        783,
        v3);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      id v10 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      id v12 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v13 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)int buf = 67110146;
      int v20 = v11;
      __int16 v21 = 2082;
      __int16 v22 = v12;
      __int16 v23 = 2082;
      __int16 v24 = v13;
      __int16 v25 = 1024;
      int v26 = 783;
      __int16 v27 = 2112;
      id v28 = v3;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Deselect failure: %@; ignore since AC has successfully negotiated and connection attempt started",
        buf,
        0x2Cu);
    }
  }
  v17[0] = _NSConcreteStackBlock;
  v17[1] = 3221225472;
  id v17[2] = sub_10023A710;
  v17[3] = &unk_100301F70;
  long long v18 = *(_OWORD *)(a1 + 32);
  int v14 = [(id)v18 _asynchronousRemoteProxyWithErrorHandler:v17];
  [v14 connectionHandoverProcessCompleted];
}

void sub_10023A710(uint64_t a1, void *a2)
{
  id v3 = a2;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v5(3, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", v8, ClassName, Name, 786, v3);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    id v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    id v12 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v13 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)int buf = 67110146;
    int v17 = v11;
    __int16 v18 = 2082;
    id v19 = v12;
    __int16 v20 = 2082;
    __int16 v21 = v13;
    __int16 v22 = 1024;
    int v23 = 786;
    __int16 v24 = 2114;
    id v25 = v3;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", buf, 0x2Cu);
  }
}

void sub_10023AAE4(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
      uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v8 = 45;
      if (isMetaClass) {
        uint64_t v8 = 43;
      }
      v5(3, "%c[%{public}s %{public}s]:%i AC connection failure: %{public}@", v8, ClassName, Name, 801, v3);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      id v10 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      id v12 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v13 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)int buf = 67110146;
      int v22 = v11;
      __int16 v23 = 2082;
      __int16 v24 = v12;
      __int16 v25 = 2082;
      int v26 = v13;
      __int16 v27 = 1024;
      int v28 = 801;
      __int16 v29 = 2114;
      id v30 = v3;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i AC connection failure: %{public}@", buf, 0x2Cu);
    }

    v19[0] = _NSConcreteStackBlock;
    v19[1] = 3221225472;
    void v19[2] = sub_10023AD5C;
    v19[3] = &unk_100301F70;
    long long v20 = *(_OWORD *)(a1 + 32);
    int v14 = [(id)v20 _asynchronousRemoteProxyWithErrorHandler:v19];
    [v14 connectionHandoverProcessFailure:v3];
  }
  else
  {
    v17[0] = _NSConcreteStackBlock;
    v17[1] = 3221225472;
    id v17[2] = sub_10023AEF4;
    v17[3] = &unk_100301F70;
    long long v18 = *(_OWORD *)(a1 + 32);
    int v14 = [(id)v18 _asynchronousRemoteProxyWithErrorHandler:v17];
    [v14 connectionHandoverProcessCompleted];
  }
}

void sub_10023AD5C(uint64_t a1, void *a2)
{
  id v3 = a2;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v5(3, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", v8, ClassName, Name, 803, v3);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    id v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    id v12 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v13 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)int buf = 67110146;
    int v17 = v11;
    __int16 v18 = 2082;
    id v19 = v12;
    __int16 v20 = 2082;
    __int16 v21 = v13;
    __int16 v22 = 1024;
    int v23 = 803;
    __int16 v24 = 2114;
    id v25 = v3;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", buf, 0x2Cu);
  }
}

void sub_10023AEF4(uint64_t a1, void *a2)
{
  id v3 = a2;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v5(3, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", v8, ClassName, Name, 808, v3);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    id v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    id v12 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v13 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)int buf = 67110146;
    int v17 = v11;
    __int16 v18 = 2082;
    id v19 = v12;
    __int16 v20 = 2082;
    __int16 v21 = v13;
    __int16 v22 = 1024;
    int v23 = 808;
    __int16 v24 = 2114;
    id v25 = v3;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", buf, 0x2Cu);
  }
}

void sub_10023B300(uint64_t a1, void *a2)
{
  id v3 = a2;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v5(3, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", v8, ClassName, Name, 823, v3);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    id v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    id v12 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v13 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)int buf = 67110146;
    int v17 = v11;
    __int16 v18 = 2082;
    id v19 = v12;
    __int16 v20 = 2082;
    __int16 v21 = v13;
    __int16 v22 = 1024;
    int v23 = 823;
    __int16 v24 = 2114;
    id v25 = v3;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", buf, 0x2Cu);
  }
}

void sub_10023BE14(uint64_t a1, void *a2)
{
  id v3 = a2;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v5(3, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", v8, ClassName, Name, 919, v3);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    id v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    id v12 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v13 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)int buf = 67110146;
    int v17 = v11;
    __int16 v18 = 2082;
    id v19 = v12;
    __int16 v20 = 2082;
    __int16 v21 = v13;
    __int16 v22 = 1024;
    int v23 = 919;
    __int16 v24 = 2114;
    id v25 = v3;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i XPC error=%{public}@", buf, 0x2Cu);
  }
}

id sub_10023D968()
{
  self;
  if (qword_1003476D0 != -1) {
    dispatch_once(&qword_1003476D0, &stru_100308210);
  }
  uint64_t v0 = (void *)qword_1003476C8;

  return v0;
}

void sub_10023D9C0(id a1)
{
  uint64_t v1 = objc_opt_new();
  uint64_t v2 = qword_1003476C8;
  qword_1003476C8 = v1;

  _objc_release_x1(v1, v2);
}

uint64_t sub_10023D9FC(uint64_t a1, void *a2)
{
  id v4 = a2;
  id v5 = v4;
  if (a1)
  {
    id v6 = *(void **)(a1 + 40);
    *(void *)(a1 + 40) = 0;
    id v9 = v4;

    *(void *)(a1 + 32) = 0;
    *(void *)(a1 + 8) = 0;
    *(void *)(a1 + 16) = 0;
    *(_DWORD *)(a1 + 24) = 0;
    [*(id *)(a1 + 48) removeAllObjects];
    id v4 = [*(id *)(a1 + 48) addEntriesFromDictionary:&off_1003236E0];
    id v5 = v9;
    if (v9)
    {
      id v4 = [*(id *)(a1 + 40) isEqualToNFTag:v9];
      id v5 = v9;
      if ((v4 & 1) == 0)
      {
        objc_storeStrong((id *)(a1 + 40), a2);
        uint64_t v7 = +[NFCALogger sharedCALogger];
        *(void *)(a1 + 32) = [v7 getTimestamp];

        id v5 = v9;
      }
    }
  }

  return _objc_release_x1(v4, v5);
}

void sub_10023DAD0(uint64_t a1, void *a2, unsigned int a3)
{
  id v5 = a2;
  id v6 = v5;
  if (a1)
  {
    if (v5 && [v5 isEqualToNFTag:*(void *)(a1 + 40)])
    {
      uint64_t v7 = +[NFCALogger sharedCALogger];
      id v8 = [v7 getDurationFrom:*(void *)(a1 + 32)];

      id v9 = +[NSUUID UUID];
      uint64_t v10 = [v9 UUIDString];

      if (*(void *)(a1 + 40))
      {
        uint64_t v11 = 0;
        switch(a3)
        {
          case 1u:
          case 2u:
          case 3u:
            int v12 = *(_DWORD *)(a1 + 108);
            if ((((_BYTE)v12 + 1) & 0xF) != 0) {
              ++v12;
            }
            goto LABEL_13;
          case 4u:
          case 5u:
          case 6u:
            int v12 = *(_DWORD *)(a1 + 108);
            int v13 = v12 + 16;
            BOOL v14 = ((v12 + 16) & 0xF0) == 0;
            goto LABEL_11;
          case 7u:
            int v26 = *(_DWORD *)(a1 + 108);
            if (((v26 + 256) & 0xF00) != 0) {
              v26 += 256;
            }
            *(_DWORD *)(a1 + 108) = v26;
            uint64_t v11 = 3;
            goto LABEL_17;
          case 8u:
            int v27 = *(_DWORD *)(a1 + 108);
            if (((v27 + 4096) & 0xF000) != 0) {
              v27 += 4096;
            }
            *(_DWORD *)(a1 + 108) = v27;
            uint64_t v11 = 4;
            goto LABEL_17;
          case 9u:
          case 0xDu:
            int v12 = *(_DWORD *)(a1 + 108);
            int v13 = v12 + 0x10000;
            BOOL v14 = ((v12 + 0x10000) & 0xF0000) == 0;
LABEL_11:
            if (!v14) {
              int v12 = v13;
            }
LABEL_13:
            *(_DWORD *)(a1 + 108) = v12;
            break;
          case 0xBu:
            int v28 = *(_DWORD *)(a1 + 108);
            if (((v28 + 0x100000) & 0xF00000) != 0) {
              v28 += 0x100000;
            }
            *(_DWORD *)(a1 + 108) = v28;
            uint64_t v11 = 6;
            goto LABEL_17;
          case 0xCu:
            int v29 = *(_DWORD *)(a1 + 108);
            if (((v29 + 0x1000000) & 0xF000000) != 0) {
              v29 += 0x1000000;
            }
            *(_DWORD *)(a1 + 108) = v29;
            uint64_t v11 = 7;
            goto LABEL_17;
          case 0xEu:
            int v30 = *(_DWORD *)(a1 + 112);
            if ((((_BYTE)v30 + 1) & 0xF) != 0) {
              ++v30;
            }
            *(_DWORD *)(a1 + 112) = v30;
            uint64_t v11 = 9;
            goto LABEL_17;
          case 0xFu:
            unsigned int v31 = *(_DWORD *)(a1 + 108);
            if (v31 >> 28 != 15) {
              v31 += 0x10000000;
            }
            *(_DWORD *)(a1 + 108) = v31;
            uint64_t v11 = 8;
            goto LABEL_17;
          case 0x10u:
            int v32 = *(_DWORD *)(a1 + 112);
            if (((v32 + 16) & 0xF0) != 0) {
              v32 += 16;
            }
            *(_DWORD *)(a1 + 112) = v32;
            uint64_t v11 = 10;
            goto LABEL_17;
          default:
            goto LABEL_17;
        }
      }
      if (a3 > 0x10) {
        uint64_t v11 = 0;
      }
      else {
        uint64_t v11 = dword_1002844E0[a3];
      }
LABEL_17:
      __int16 v33 = *(void **)(a1 + 48);
      v37[0] = v10;
      v36[0] = @"transactionUUID";
      v36[1] = @"rawCommandCount";
      __int16 v35 = (void *)v10;
      int v34 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(a1 + 24)];
      v37[1] = v34;
      v36[2] = @"rawBytesRx";
      long long v15 = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 16)];
      v37[2] = v15;
      v36[3] = @"rawBytesTx";
      id v16 = +[NSNumber numberWithUnsignedLongLong:*(void *)(a1 + 8)];
      v37[3] = v16;
      v36[4] = @"duration";
      int v17 = +[NSNumber numberWithUnsignedInt:v8];
      v37[4] = v17;
      v36[5] = @"durationDim";
      __int16 v18 = +[NSNumber numberWithUnsignedInt:v8];
      void v37[5] = v18;
      v36[6] = @"tagType";
      id v19 = +[NSNumber numberWithUnsignedInt:v11];
      v37[6] = v19;
      v36[7] = @"isConnectionHandover";
      __int16 v20 = +[NSNumber numberWithBool:*(unsigned __int8 *)(a1 + 157)];
      v37[7] = v20;
      +[NSDictionary dictionaryWithObjects:v37 forKeys:v36 count:8];
      v22 = int v21 = (int)v8;
      [v33 addEntriesFromDictionary:v22];

      int v23 = +[NFCALogger sharedCALogger];
      [v23 postCAEventFor:@"com.apple.nfcd.tagReadEvent" eventInput:*(void *)(a1 + 48)];

      ++*(_DWORD *)(a1 + 148);
      *(_DWORD *)(a1 + 104) += v21;
      *(int32x2_t *)(a1 + 120) = vadd_s32(*(int32x2_t *)(a1 + 120), vrev64_s32(vmovn_s64(*(int64x2_t *)(a1 + 8))));
      *(_DWORD *)(a1 + 128) += *(_DWORD *)(a1 + 24);
      __int16 v24 = *(void **)(a1 + 40);
      *(void *)(a1 + 40) = 0;

      *(void *)(a1 + 32) = 0;
      *(void *)(a1 + 8) = 0;
      *(void *)(a1 + 16) = 0;
      *(_DWORD *)(a1 + 24) = 0;
      [*(id *)(a1 + 48) removeAllObjects];
      [*(id *)(a1 + 48) addEntriesFromDictionary:&off_1003236E0];
    }
    id v25 = *(void **)(a1 + 40);
    *(void *)(a1 + 40) = 0;
  }
}

void sub_10023DF68(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    if (*(void *)(a1 + 40))
    {
      [*(id *)(a1 + 48) setObject:&off_100320158 forKeyedSubscript:@"isNdef"];
      id v4 = +[NSNumber numberWithUnsignedLong:a2];
      [*(id *)(a1 + 48) setObject:v4 forKeyedSubscript:@"ndefPayloadSize"];

      *(unsigned char *)(a1 + 152) = 1;
    }
  }
}

void sub_10023DFEC(uint64_t a1, void *a2)
{
  if (a1 && a2)
  {
    id v3 = a2;
    sub_10023D9FC(a1, v3);
    [*(id *)(a1 + 48) setObject:&off_100320158 forKeyedSubscript:@"tagProhibited"];
    [*(id *)(a1 + 48) setObject:&off_100320170 forKeyedSubscript:@"resultCode"];
    sub_10023DAD0(a1, v3, [v3 type]);
  }
}

void sub_10023E090(uint64_t a1, uint64_t a2)
{
  if (a1 && *(void *)(a1 + 40))
  {
    id v3 = +[NSNumber numberWithUnsignedInt:a2];
    [*(id *)(a1 + 48) setObject:v3 forKeyedSubscript:@"backgroundTagReadResult"];
  }
}

void sub_10023E114(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v5 = v3;
    if (((unint64_t)[v3 code] & 0x8000000000000000) != 0
      || (uint64_t)[v5 code] > 70)
    {
      [*(id *)(a1 + 48) setObject:&off_100320188 forKeyedSubscript:@"resultCode"];
    }
    else
    {
      id v4 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [v5 code]);
      [*(id *)(a1 + 48) setObject:v4 forKeyedSubscript:@"resultCode"];
    }
    id v3 = v5;
  }
}

void sub_10023E1CC(uint64_t a1, void *a2, int a3)
{
  id v7 = a2;
  if (a1)
  {
    *(void *)(a1 + 56) = 0;
    *(_DWORD *)(a1 + 64) = 0;
    *(void *)(a1 + 72) = 0;
    *(_DWORD *)(a1 + 80) = 0;
    *(_DWORD *)(a1 + 148) = 0;
    *(unsigned char *)(a1 + 152) = 0;
    *(_WORD *)(a1 + 155) = 0;
    *(unsigned char *)(a1 + 157) = 0;
    *(_OWORD *)(a1 + 88) = 0u;
    *(_OWORD *)(a1 + 104) = 0u;
    *(_OWORD *)(a1 + 116) = 0u;
    id v6 = +[NFCALogger sharedCALogger];
    *(void *)(a1 + 56) = [v6 getTimestamp];

    objc_storeStrong((id *)(a1 + 136), a2);
    *(_DWORD *)(a1 + 144) = a3;
  }
}

void sub_10023E284(uint64_t a1, uint64_t a2)
{
  if (a1 && *(void *)(a1 + 56))
  {
    id v4 = +[NFCALogger sharedCALogger];
    *(_DWORD *)(a1 + 64) = [v4 getDurationFrom:*(void *)(a1 + 56)];

    id v5 = +[NFCALogger getBatteryPercent];
    v30[0] = *(void *)(a1 + 136);
    v29[0] = @"sessionUUID";
    v29[1] = @"sessionType";
    int v28 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(a1 + 144)];
    v30[1] = v28;
    v29[2] = @"tagCount";
    int v27 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(a1 + 148)];
    v30[2] = v27;
    v29[3] = @"tagTypeCountSetA";
    int v26 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(a1 + 108)];
    v30[3] = v26;
    v29[4] = @"tagTypeCountSetB";
    id v25 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(a1 + 112)];
    v30[4] = v25;
    void v29[5] = @"sessionDuration";
    __int16 v24 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(a1 + 64)];
    v30[5] = v24;
    v29[6] = @"sessionDurationDim";
    int v23 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(a1 + 64)];
    v30[6] = v23;
    v29[7] = @"pollingDuration";
    __int16 v22 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(a1 + 80)];
    void v30[7] = v22;
    v29[8] = @"pollingDurationDim";
    int v21 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(a1 + 80)];
    v30[8] = v21;
    v29[9] = @"connectedDuration";
    __int16 v20 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(a1 + 104)];
    v30[9] = v20;
    v29[10] = @"connectedDurationDim";
    id v19 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(a1 + 104)];
    v30[10] = v19;
    v29[11] = @"batteryLevel";
    __int16 v18 = +[NSNumber numberWithUnsignedInt:v5];
    v30[11] = v18;
    v29[12] = @"exitReason";
    uint64_t v6 = +[NSNumber numberWithUnsignedInt:a2];
    id v7 = (void *)v6;
    if (*(unsigned char *)(a1 + 155)) {
      id v8 = &off_100320158;
    }
    else {
      id v8 = &off_100320128;
    }
    v30[12] = v6;
    v30[13] = v8;
    v29[13] = @"burnout";
    v29[14] = @"pollingConfig";
    id v9 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(a1 + 116)];
    v30[14] = v9;
    v29[15] = @"bytesRx";
    uint64_t v10 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(a1 + 120)];
    v30[15] = v10;
    v29[16] = @"bytesTx";
    uint64_t v11 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(a1 + 124)];
    v30[16] = v11;
    v29[17] = @"commandCount";
    int v12 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(a1 + 128)];
    v30[17] = v12;
    v29[18] = @"didReadNdef";
    int v13 = +[NSNumber numberWithBool:*(unsigned __int8 *)(a1 + 152)];
    v30[18] = v13;
    v29[19] = @"didPACE";
    BOOL v14 = +[NSNumber numberWithBool:*(unsigned __int8 *)(a1 + 156)];
    v30[19] = v14;
    v29[20] = @"isConnectionHandover";
    long long v15 = +[NSNumber numberWithBool:*(unsigned __int8 *)(a1 + 157)];
    v30[20] = v15;
    id v16 = +[NSDictionary dictionaryWithObjects:v30 forKeys:v29 count:21];

    int v17 = +[NFCALogger sharedCALogger];
    [v17 postCAEventFor:@"com.apple.nfcd.readerSessionEvent" eventInput:v16];

    if (*(unsigned char *)(a1 + 155)) {
      +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:&off_100323708];
    }
    +[NFGeneralStatisticsCALogger updateGeneralDeviceStatistic:&off_100323730];
    *(void *)(a1 + 56) = 0;
    *(_DWORD *)(a1 + 64) = 0;
    *(void *)(a1 + 72) = 0;
    *(_DWORD *)(a1 + 80) = 0;
    *(_DWORD *)(a1 + 148) = 0;
    *(unsigned char *)(a1 + 152) = 0;
    *(_WORD *)(a1 + 155) = 0;
    *(unsigned char *)(a1 + 157) = 0;
    *(_OWORD *)(a1 + 88) = 0u;
    *(_OWORD *)(a1 + 104) = 0u;
    *(_OWORD *)(a1 + 116) = 0u;
  }
}

void sub_10023E740(uint64_t a1, int a2)
{
  if (a1)
  {
    id v4 = +[NFCALogger sharedCALogger];
    *(void *)(a1 + 72) = [v4 getTimestamp];

    *(_DWORD *)(a1 + 116) = a2;
  }
}

void sub_10023E798(uint64_t a1)
{
  if (a1)
  {
    if (*(void *)(a1 + 72))
    {
      uint64_t v2 = +[NFCALogger sharedCALogger];
      *(_DWORD *)(a1 + 80) += [v2 getDurationFrom:*(void *)(a1 + 72)];

      *(void *)(a1 + 72) = 0;
    }
  }
}

void sub_10023E848(uint64_t a1, void *a2, void *a3, char a4, int a5)
{
  id v8 = a2;
  id v9 = a3;
  uint64_t v10 = self;
  uint64_t v219 = v9;
  uint64_t v11 = [v9 objectForKeyedSubscript:@"EventType"];
  NSErrorUserInfoKey v220 = v8;
  unsigned int v217 = (void *)v11;
  if (!v11)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v16 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v10);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(v10);
      uint64_t Name = sel_getName("postAnalyticsHciTransactionEventWithEventDict:atlData:withExpressEnabled:prepOnly:");
      uint64_t v20 = 45;
      if (isMetaClass) {
        uint64_t v20 = 43;
      }
      v16(6, "%c[%{public}s %{public}s]:%i No valid event from ATL, HCI didn't contain a relevant message", v20, ClassName, Name, 134);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v21 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_27;
    }
    __int16 v22 = object_getClass(v10);
    if (class_isMetaClass(v22)) {
      int v23 = 43;
    }
    else {
      int v23 = 45;
    }
    *(_DWORD *)int buf = 67109890;
    int v261 = v23;
    __int16 v262 = 2082;
    v263 = object_getClassName(v10);
    __int16 v264 = 2082;
    id v265 = sel_getName("postAnalyticsHciTransactionEventWithEventDict:atlData:withExpressEnabled:prepOnly:");
    __int16 v266 = 1024;
    int v267 = 134;
    __int16 v24 = "%c[%{public}s %{public}s]:%i No valid event from ATL, HCI didn't contain a relevant message";
    id v25 = v21;
    uint32_t v26 = 34;
    goto LABEL_26;
  }
  int v12 = (__CFString *)v11;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    if ([(__CFString *)v12 isEqualToString:@"EndEvent"]) {
      +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:&off_100323758];
    }
    if (a5)
    {
      if ([(__CFString *)v12 isEqualToString:@"ActivityTimeout"])
      {
        uint64_t v13 = +[NSDate now];
        BOOL v14 = (void *)qword_1003476E0;
        qword_1003476E0 = v13;
      }
      else
      {
        NSErrorUserInfoKey v50 = &OBJC_PROTOCOL___NFContactlessSessionInterface;
        if (qword_1003476D8)
        {
          NSErrorUserInfoKey v51 = +[NSUUID UUID];
          NSErrorUserInfoKey v52 = [v51 UUIDString];

          if (qword_1003476E0)
          {
            [(id)qword_1003476E0 timeIntervalSinceDate:qword_1003476D8];
            unint64_t v54 = (unint64_t)(v53 * 1000.0);
            BOOL v55 = qword_1003476E0 == 0;
          }
          else
          {
            unint64_t v54 = 0;
            BOOL v55 = 1;
          }
          v249[0] = @"transactionUUID";
          v249[1] = @"command";
          v252[0] = v52;
          v252[1] = off_100346E78[0];
          v249[2] = @"commandParam1";
          v249[3] = @"commandResult";
          v249[4] = @"status";
          v249[5] = @"aid";
          v254 = off_100346EA0;
          int v255 = off_100346E98;
          long long v253 = *(_OWORD *)off_100346E80;
          BOOL v256 = off_100346E90;
          v249[6] = @"expressType";
          v249[7] = @"closingEventType";
          if (v55)
          {
            id v159 = &off_1003201A0;
            CFStringRef v257 = v12;
            int v258 = &off_1003201A0;
            CFStringRef v250 = @"transactionDurationMS";
            CFStringRef v251 = @"timeoutValue";
          }
          else
          {
            CFStringRef v257 = @"ActivityTimeout";
            int v258 = &off_1003201A0;
            CFStringRef v250 = @"transactionDurationMS";
            CFStringRef v251 = @"timeoutValue";
            id v159 = +[NSNumber numberWithUnsignedInteger:v54];
          }
          uint64_t v259 = v159;
          int v160 = +[NSDictionary dictionaryWithObjects:v252 forKeys:v249 count:10];
          if (!v55) {

          }
          id v161 = +[NFCALogger sharedCALogger];
          [v161 postCAEventFor:@"com.apple.nfcd.hciTransactionEvent" eventInput:v160];

          NSErrorUserInfoKey v50 = &OBJC_PROTOCOL___NFContactlessSessionInterface;
          if ([off_100346E88[0] unsignedIntValue] != 36864) {
            +[NFExceptionsCALogger postAnalyticsHciTransactionException:v52 eventType:v12 commandResult:off_100346E88[0] status:&off_1003201A0];
          }
          +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:&off_100323780];
          if (qword_1003476E0)
          {
            +[NFExceptionsCALogger postAnalyticsHciTransactionException:v52 eventType:v12 commandResult:&off_1003201A0 status:off_100346EA0];
            +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:&off_1003237A8];
          }
          int v162 = (void *)qword_1003476D8;
          qword_1003476D8 = 0;

          int v163 = off_100346E78[0];
          off_100346E78[0] = &off_1003201A0;

          unsigned int v164 = off_100346E80[0];
          off_100346E80[0] = &off_1003201A0;

          unsigned int v165 = off_100346E88[0];
          off_100346E88[0] = &off_1003201A0;

          unsigned int v166 = off_100346EA0;
          off_100346EA0 = &off_1003201A0;

          unsigned int v167 = off_100346E90;
          off_100346E90 = &off_1003201A0;

          unsigned int v168 = off_100346E98;
          off_100346E98 = &stru_100309C40;

          int v169 = off_100346EA8;
          off_100346EA8 = &stru_100309C40;

          id v170 = (void *)qword_1003476E0;
          qword_1003476E0 = 0;
        }
        uint64_t v171 = +[NSDate now];
        unsigned int v172 = (void *)qword_1003476D8;
        qword_1003476D8 = v171;

        id v173 = [v8 objectForKeyedSubscript:@"command"];
        objc_opt_class();
        char isKindOfClass = objc_opt_isKindOfClass();

        if (isKindOfClass)
        {
          int v175 = [v8 objectForKeyedSubscript:@"command"];
          id v176 = off_100346E78[0];
          off_100346E78[0] = v175;
        }
        id v177 = [v8 objectForKeyedSubscript:@"commandParam1"];
        objc_opt_class();
        char v178 = objc_opt_isKindOfClass();

        if (v178)
        {
          id v179 = [v8 objectForKeyedSubscript:@"commandParam1"];
          int v180 = off_100346E80[0];
          off_100346E80[0] = v179;
        }
        __int16 v181 = [v8 objectForKeyedSubscript:@"commandResult"];
        objc_opt_class();
        char v182 = objc_opt_isKindOfClass();

        if (v182)
        {
          uint64_t v183 = [v8 objectForKeyedSubscript:@"commandResult"];
          opt_class_meths = v50[51].opt_class_meths;
          v50[51].opt_class_meths = (__objc2_meth_list *)v183;
        }
        __int16 v185 = [v8 objectForKeyedSubscript:@"expressType"];
        objc_opt_class();
        char v186 = objc_opt_isKindOfClass();

        if (v186)
        {
          __int16 v187 = [v8 objectForKeyedSubscript:@"expressType"];
          __int16 v188 = off_100346E90;
          off_100346E90 = v187;
        }
        __int16 v189 = [v9 objectForKeyedSubscript:@"appletIdentifier"];
        objc_opt_class();
        char v190 = objc_opt_isKindOfClass();

        if (v190)
        {
          int v191 = [v9 objectForKeyedSubscript:@"appletIdentifier"];
          __int16 v192 = off_100346E98;
          off_100346E98 = v191;

          objc_storeStrong((id *)&off_100346EA8, off_100346E98);
        }
      }
      goto LABEL_28;
    }
    NSErrorUserInfoKey v44 = +[NSUUID UUID];
    id v212 = [v44 UUIDString];

    int v200 = +[NSDate now];
    int v45 = [v8 objectForKeyedSubscript:@"aid"];
    objc_opt_class();
    char v46 = objc_opt_isKindOfClass();

    if (v46)
    {
      id v210 = [v8 objectForKeyedSubscript:@"aid"];
      [v210 NF_asHexString];
      int v47 = (__CFString *)objc_claimAutoreleasedReturnValue();
      id v48 = off_100346EA8;
      off_100346EA8 = v47;

      id v49 = v9;
      if (!off_100346EA8) {
        off_100346EA8 = &stru_100309C40;
      }
    }
    else
    {
      id v210 = 0;
      id v49 = v9;
    }
    __int16 v56 = [v8 objectForKeyedSubscript:@"informative"];
    objc_opt_class();
    char v57 = objc_opt_isKindOfClass();

    if (v57)
    {
      __int16 v58 = [v8 objectForKeyedSubscript:@"informative"];
    }
    else
    {
      __int16 v58 = &off_1003201A0;
    }
    char v197 = a4;
    __int16 v59 = [v8 objectForKeyedSubscript:@"SPRaw"];
    objc_opt_class();
    char v60 = objc_opt_isKindOfClass();

    if (v60)
    {
      int v205 = [v8 objectForKeyedSubscript:@"SPRaw"];
    }
    else
    {
      int v205 = &off_1003201A0;
    }
    unsigned int v218 = v58;
    __int16 v61 = [v8 objectForKeyedSubscript:@"status"];
    objc_opt_class();
    char v62 = objc_opt_isKindOfClass();

    if (v62)
    {
      int v63 = [v8 objectForKeyedSubscript:@"status"];
      __int16 v64 = off_100346EA0;
      off_100346EA0 = v63;
    }
    CFStringRef v65 = @"transactionStatus";
    __int16 v66 = [v8 objectForKeyedSubscript:@"transactionStatus"];
    objc_opt_class();
    char v67 = objc_opt_isKindOfClass();

    if ((v67 & 1) != 0
      || (CFStringRef v65 = @"result",
          [v8 objectForKeyedSubscript:@"result"],
          __int16 v68 = objc_claimAutoreleasedReturnValue(),
          objc_opt_class(),
          char v69 = objc_opt_isKindOfClass(),
          v68,
          (v69 & 1) != 0))
    {
      uint64_t v206 = [v8 objectForKeyedSubscript:v65];
    }
    else
    {
      uint64_t v206 = &off_1003201A0;
    }
    __int16 v70 = [v8 objectForKeyedSubscript:@"transactionCategory"];
    objc_opt_class();
    char v71 = objc_opt_isKindOfClass();

    if (v71)
    {
      uint64_t v204 = [v8 objectForKeyedSubscript:@"transactionCategory"];
    }
    else
    {
      uint64_t v204 = &off_1003201A0;
    }
    __int16 v72 = [v8 objectForKeyedSubscript:@"transactionType"];
    objc_opt_class();
    char v73 = objc_opt_isKindOfClass();

    if (v73)
    {
      __int16 v74 = [v8 objectForKeyedSubscript:@"transactionType"];
    }
    else
    {
      __int16 v74 = &off_1003201A0;
    }
    __int16 v75 = [v8 objectForKeyedSubscript:@"expressType"];
    objc_opt_class();
    char v76 = objc_opt_isKindOfClass();

    if (v76)
    {
      int v77 = [v8 objectForKeyedSubscript:@"expressType"];
      __int16 v78 = off_100346E90;
      off_100346E90 = v77;
    }
    __int16 v79 = [v8 objectForKeyedSubscript:@"transactionExtension"];
    objc_opt_class();
    char v80 = objc_opt_isKindOfClass();

    if (v80)
    {
      __int16 v81 = [v8 objectForKeyedSubscript:@"transactionExtension"];
    }
    else
    {
      __int16 v81 = &off_1003201A0;
    }
    NSErrorUserInfoKey v82 = [v8 objectForKeyedSubscript:@"accessUniversityCode"];
    objc_opt_class();
    char v83 = objc_opt_isKindOfClass();

    if (v83)
    {
      __int16 v84 = [v8 objectForKeyedSubscript:@"accessUniversityCode"];
    }
    else
    {
      __int16 v84 = &off_1003201A0;
    }
    int v85 = [v8 objectForKeyedSubscript:@"interface"];
    objc_opt_class();
    char v86 = objc_opt_isKindOfClass();

    if (v86)
    {
      id v202 = [v8 objectForKeyedSubscript:@"interface"];
    }
    else
    {
      id v202 = &off_1003201B8;
    }
    id v215 = v84;
    char v216 = v74;
    __int16 v87 = [v8 objectForKeyedSubscript:@"ReadOperationInfo"];
    objc_opt_class();
    char v88 = objc_opt_isKindOfClass();

    if (v88)
    {
      [v8 objectForKeyedSubscript:@"ReadOperationInfo"];
      __int16 v89 = v8;
      __int16 v90 = (_UNKNOWN **)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      __int16 v89 = v8;
      __int16 v90 = &off_1003201A0;
    }
    int v91 = [v89 objectForKeyedSubscript:@"WriteOperationInfo"];
    objc_opt_class();
    char v92 = objc_opt_isKindOfClass();

    if (v92)
    {
      unsigned int v93 = [v89 objectForKeyedSubscript:@"WriteOperationInfo"];
    }
    else
    {
      unsigned int v93 = &off_1003201A0;
    }
    NSErrorUserInfoKey v94 = [v89 objectForKeyedSubscript:@"NFMultiTagState"];
    objc_opt_class();
    char v95 = objc_opt_isKindOfClass();

    if (v95)
    {
      BOOL v209 = [v89 objectForKeyedSubscript:@"NFMultiTagState"];
    }
    else
    {
      BOOL v209 = &off_1003201A0;
    }
    unsigned int v96 = [v89 objectForKeyedSubscript:@"terminalType"];
    objc_opt_class();
    char v97 = objc_opt_isKindOfClass();

    if (v97)
    {
      v208 = [v89 objectForKeyedSubscript:@"terminalType"];
    }
    else
    {
      v208 = &off_1003201A0;
    }
    int v98 = [v89 objectForKeyedSubscript:@"command"];
    objc_opt_class();
    char v99 = objc_opt_isKindOfClass();

    if ((v99 & 1) != 0
      || ([v49 objectForKeyedSubscript:@"command"],
          unsigned int v100 = objc_claimAutoreleasedReturnValue(),
          objc_opt_class(),
          char v101 = objc_opt_isKindOfClass(),
          v100,
          __int16 v89 = v49,
          (v101 & 1) != 0))
    {
      id v102 = [v89 objectForKeyedSubscript:@"command"];
    }
    else
    {
      id v102 = &off_1003201A0;
    }
    id v203 = v90;
    int v103 = [v220 objectForKeyedSubscript:@"commandParam1"];
    objc_opt_class();
    char v104 = objc_opt_isKindOfClass();

    id v201 = v102;
    if (v104)
    {
      v207 = [v220 objectForKeyedSubscript:@"commandParam1"];
    }
    else
    {
      v207 = &off_1003201A0;
    }
    __int16 v105 = [v220 objectForKeyedSubscript:@"status"];
    objc_opt_class();
    char v106 = objc_opt_isKindOfClass();

    id v213 = v81;
    int v214 = v93;
    if (v106)
    {
      uint64_t v211 = [v220 objectForKeyedSubscript:@"status"];
    }
    else
    {
      id v107 = [v49 objectForKeyedSubscript:@"result"];
      objc_opt_class();
      char v108 = objc_opt_isKindOfClass();

      if (v108)
      {
        uint64_t v211 = [v49 objectForKeyedSubscript:@"result"];
      }
      else
      {
        uint64_t v211 = &off_1003201A0;
      }
    }
    __int16 v109 = [v49 objectForKeyedSubscript:@"didError"];
    objc_opt_class();
    id v110 = v49;
    char v111 = objc_opt_isKindOfClass();

    if (v111)
    {
      id v112 = [v110 objectForKeyedSubscript:@"didError"];
      unsigned int v199 = [v112 BOOLValue];
    }
    else
    {
      unsigned int v199 = 0;
    }
    id v113 = off_100346EA8;
    self;
    id v114 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284524 length:7];
    uint64_t v115 = [v114 NF_asHexString];
    if (([(__CFString *)v113 hasPrefix:v115] & 1) == 0)
    {
      id v116 = [objc_alloc((Class)NSData) initWithBytes:&unk_10028452B length:7];
      int v117 = [v116 NF_asHexString];
      if (([(__CFString *)v113 hasPrefix:v117] & 1) == 0)
      {
        id v118 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284532 length:9];
        uint64_t v119 = [v118 NF_asHexString];
        if ((-[__CFString hasPrefix:](v113, "hasPrefix:") & 1) == 0)
        {
          id v157 = [objc_alloc((Class)NSData) initWithBytes:&unk_10028453B length:13];
          id v158 = [v157 NF_asHexString];
          unsigned __int8 v196 = [(__CFString *)v113 hasPrefix:v158];

          if ((v196 & 1) == 0)
          {
            int v122 = &off_1003201A0;
            unsigned int v123 = v199;
            goto LABEL_102;
          }
LABEL_99:
          id v120 = [v220 objectForKeyedSubscript:@"supportsUWB"];
          objc_opt_class();
          char v121 = objc_opt_isKindOfClass();

          int v122 = &off_1003201B8;
          unsigned int v123 = v199;
          if (v121)
          {
            int v124 = [v220 objectForKeyedSubscript:@"supportsUWB"];
            unsigned int v125 = [v124 BOOLValue];

            if (v125) {
              int v122 = &off_1003201D0;
            }
          }
LABEL_102:
          if (v197)
          {
            unsigned int v198 = 1;
          }
          else
          {
            uint64_t v126 = [v220 objectForKeyedSubscript:@"expressEnabled"];
            objc_opt_class();
            char v127 = objc_opt_isKindOfClass();

            if (v127)
            {
              int v128 = [v220 objectForKeyedSubscript:@"expressEnabled"];
              unsigned int v198 = [v128 BOOLValue];
            }
            else
            {
              unsigned int v198 = 0;
            }
          }
          if (qword_1003476D8)
          {
            [v200 timeIntervalSinceDate:x0];
            unint64_t v130 = (unint64_t)(v129 * 1000.0);
            if (qword_1003476E0)
            {
              [(id)qword_1003476E0 timeIntervalSinceDate:qword_1003476D8];
              unint64_t v132 = (unint64_t)(v131 * 1000.0);
              goto LABEL_112;
            }
          }
          else
          {
            unint64_t v130 = 0;
          }
          unint64_t v132 = 0;
LABEL_112:
          id v133 = [v210 length];
          int v134 = &off_1003201A0;
          __int16 v136 = v208;
          long long v135 = v209;
          int v137 = v207;
          if ((unint64_t)v133 >= 0xA)
          {
            id v138 = [v210 subdataWithRange:0, 10];
            id v139 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284548 length:10];
            unsigned int v140 = [v138 isEqualToData:v139];

            if (v140)
            {
              int v134 = [v219 objectForKeyedSubscript:@"identityAuthStatus"];
            }
            __int16 v136 = v208;
            long long v135 = v209;
            int v137 = v207;
            unsigned int v123 = v199;
          }
          v221[0] = @"transactionUUID";
          v221[1] = @"command";
          v222[0] = v212;
          v222[1] = off_100346E78[0];
          long long v223 = *(_OWORD *)off_100346E80;
          v221[2] = @"commandParam1";
          v221[3] = @"commandResult";
          v221[4] = @"status";
          v221[5] = @"expressType";
          uint64_t v224 = off_100346EA0;
          v225 = off_100346E90;
          v221[6] = @"aid";
          v221[7] = @"informative";
          NSErrorUserInfoKey v226 = off_100346EA8;
          int v227 = v218;
          v221[8] = @"SPID";
          v221[9] = @"transactionStatus";
          NSErrorUserInfoKey v228 = v205;
          v229 = v206;
          v221[10] = @"transactionCategory";
          v221[11] = @"transactionType";
          id v230 = v204;
          int v231 = v216;
          v221[12] = @"transactionExtension";
          v221[13] = @"accessUniversityCode";
          uint64_t v232 = v213;
          int v233 = v215;
          v221[14] = @"endEventInterface";
          v221[15] = @"sfiRead";
          NSErrorUserInfoKey v234 = v202;
          uint64_t v235 = v203;
          v221[16] = @"sfiUpdated";
          v221[17] = @"multiTagState";
          NSErrorUserInfoKey v236 = v214;
          BOOL v237 = v135;
          NSErrorUserInfoKey v238 = v136;
          v221[18] = @"terminalType";
          v221[19] = @"transactionDurationMS";
          id v141 = +[NSNumber numberWithUnsignedInteger:v130];
          uint64_t v239 = v141;
          v221[20] = @"timeoutValue";
          id v142 = +[NSNumber numberWithUnsignedInteger:v132];
          v240 = v142;
          int v241 = v201;
          v221[21] = @"endEventCommand";
          v221[22] = @"endEventCommandParam1";
          int v242 = v137;
          uint64_t v243 = v211;
          v221[23] = @"endEventCommandResult";
          v221[24] = @"didError";
          uint64_t v143 = &__kCFBooleanFalse;
          if (v123) {
            uint64_t v143 = &__kCFBooleanTrue;
          }
          __int16 v244 = v143;
          unsigned int v245 = v217;
          v221[25] = @"closingEventType";
          v221[26] = @"keyType";
          unsigned int v246 = v122;
          v221[27] = @"expressEnabled";
          __int16 v144 = +[NSNumber numberWithBool:v198];
          v221[28] = @"identityAuthStatus";
          uint64_t v247 = v144;
          __int16 v248 = v134;
          int v145 = +[NSDictionary dictionaryWithObjects:v222 forKeys:v221 count:29];

          __int16 v146 = +[NFCALogger sharedCALogger];
          [v146 postCAEventFor:@"com.apple.nfcd.hciTransactionEvent" eventInput:v145];

          if ([v217 isEqualToString:@"EndEvent"])
          {
            if ((v123 & 1) == 0
              && [v206 unsignedIntValue] != 256
              && ([v218 unsignedIntValue] & 0x80) == 0)
            {
              goto LABEL_126;
            }
            uint64_t v147 = &off_1003237D0;
          }
          else
          {
            if (![v217 isEqualToString:@"ActivityTimeout"])
            {
LABEL_126:
              id v148 = (void *)qword_1003476D8;
              qword_1003476D8 = 0;

              unsigned int v149 = (void *)qword_1003476E0;
              qword_1003476E0 = 0;

              int v150 = off_100346E78[0];
              off_100346E78[0] = &off_1003201A0;

              int v151 = off_100346E80[0];
              off_100346E80[0] = &off_1003201A0;

              int v152 = off_100346E88[0];
              off_100346E88[0] = &off_1003201A0;

              int v153 = off_100346E90;
              off_100346E90 = &off_1003201A0;

              __int16 v154 = off_100346E98;
              off_100346E98 = &stru_100309C40;

              id v155 = off_100346EA0;
              off_100346EA0 = &off_1003201A0;

              __int16 v156 = off_100346EA8;
              off_100346EA8 = &stru_100309C40;

              __int16 v39 = v205;
              id v38 = v206;
              int v34 = v203;
              __int16 v37 = v204;
              id v42 = v201;
              uint64_t v43 = v202;
              int v36 = v208;
              __int16 v35 = v209;
              __int16 v41 = v207;
              id v40 = v211;
              goto LABEL_29;
            }
            uint64_t v147 = &off_1003237F8;
          }
          +[NFExceptionsCALogger postAnalyticsHciTransactionException:v212 eventType:v217 commandResult:v211 status:off_100346EA0];
          +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:v147];
          goto LABEL_126;
        }
      }
    }

    goto LABEL_99;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v27 = NFLogGetLogger();
  if (v27)
  {
    int v28 = (void (*)(uint64_t, const char *, ...))v27;
    int v29 = object_getClass(v10);
    BOOL v30 = class_isMetaClass(v29);
    id v193 = object_getClassName(v10);
    __int16 v195 = sel_getName("postAnalyticsHciTransactionEventWithEventDict:atlData:withExpressEnabled:prepOnly:");
    uint64_t v31 = 45;
    if (v30) {
      uint64_t v31 = 43;
    }
    v28(6, "%c[%{public}s %{public}s]:%i Error : invalid event class : %{public}@", v31, v193, v195, 138, v12);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v21 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
  {
    int v32 = object_getClass(v10);
    if (class_isMetaClass(v32)) {
      int v33 = 43;
    }
    else {
      int v33 = 45;
    }
    *(_DWORD *)int buf = 67110146;
    int v261 = v33;
    __int16 v262 = 2082;
    v263 = object_getClassName(v10);
    __int16 v264 = 2082;
    id v265 = sel_getName("postAnalyticsHciTransactionEventWithEventDict:atlData:withExpressEnabled:prepOnly:");
    __int16 v266 = 1024;
    int v267 = 138;
    __int16 v268 = 2114;
    v269 = v12;
    __int16 v24 = "%c[%{public}s %{public}s]:%i Error : invalid event class : %{public}@";
    id v25 = v21;
    uint32_t v26 = 44;
LABEL_26:
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, v24, buf, v26);
  }
LABEL_27:

LABEL_28:
  int v34 = &off_1003201A0;
  int v214 = &off_1003201A0;
  id v215 = &off_1003201A0;
  __int16 v35 = &off_1003201A0;
  int v36 = &off_1003201A0;
  id v213 = &off_1003201A0;
  char v216 = &off_1003201A0;
  __int16 v37 = &off_1003201A0;
  id v38 = &off_1003201A0;
  __int16 v39 = &off_1003201A0;
  unsigned int v218 = &off_1003201A0;
  id v40 = &off_1003201A0;
  __int16 v41 = &off_1003201A0;
  id v42 = &off_1003201A0;
  uint64_t v43 = &off_1003201B8;
LABEL_29:
}

void sub_1002400F0(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  self;
  v9[0] = @"status";
  if (v4)
  {
    +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [v4 code]);
    uint64_t v6 = (_UNKNOWN **)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    uint64_t v6 = &off_1003201A0;
  }
  v9[1] = @"aid";
  v10[0] = v6;
  v10[1] = v5;
  id v7 = +[NSDictionary dictionaryWithObjects:v10 forKeys:v9 count:2];
  if (v4) {

  }
  id v8 = +[NFCALogger sharedCALogger];
  [v8 postCAEventFor:@"com.apple.nfcd.eCommerceTransactionEvent" eventInput:v7];
}

void sub_100240214(uint64_t a1, void *a2, int a3)
{
  id v28 = a2;
  uint64_t v4 = self;
  id v5 = objc_opt_new();
  uint64_t v6 = objc_opt_new();
  id v7 = (void *)v6;
  if (v5) {
    BOOL v8 = v6 == 0;
  }
  else {
    BOOL v8 = 1;
  }
  if (v8) {
    goto LABEL_27;
  }
  [v5 setObject:&off_1003201D0 forKeyedSubscript:@"version"];
  id v9 = [v28 objectForKeyedSubscript:@"appletIdentifier"];

  if (v9)
  {
    CFStringRef v10 = @"appletIdentifier";
  }
  else
  {
    uint64_t v11 = [v28 objectForKeyedSubscript:@"aid"];

    if (!v11) {
      goto LABEL_11;
    }
    CFStringRef v10 = @"aid";
  }
  int v12 = [v28 objectForKeyedSubscript:v10];
  uint64_t v13 = +[NSData NF_dataWithHexString:v12];

  if (v13)
  {
    [v5 setObject:v13 forKeyedSubscript:@"aid"];
  }
LABEL_11:
  BOOL v14 = [v28 objectForKeyedSubscript:@"result"];

  if (v14)
  {
    long long v15 = [v28 objectForKeyedSubscript:@"result"];
    [v5 setObject:v15 forKeyedSubscript:@"result"];
  }
  id v16 = [v28 objectForKeyedSubscript:@"transactionStatus"];
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();

  if (isKindOfClass)
  {
    __int16 v18 = [v28 objectForKeyedSubscript:@"transactionStatus"];
    [v5 setObject:v18 forKeyedSubscript:@"transactionStatus"];
  }
  id v19 = [v28 objectForKeyedSubscript:@"expressType"];

  if (v19)
  {
    uint64_t v20 = [v28 objectForKeyedSubscript:@"expressType"];
    [v5 setObject:v20 forKeyedSubscript:@"expressType"];
  }
  if (a3)
  {
    [v5 setObject:&__kCFBooleanTrue forKeyedSubscript:@"expressEnabled"];
LABEL_21:
    __int16 v22 = v28;
    goto LABEL_22;
  }
  int v21 = [v28 objectForKeyedSubscript:@"expressEnabled"];

  __int16 v22 = v28;
  if (v21)
  {
    int v23 = [v28 objectForKeyedSubscript:@"expressEnabled"];
    [v5 setObject:v23 forKeyedSubscript:@"expressEnabled"];

    goto LABEL_21;
  }
LABEL_22:
  __int16 v24 = [v22 objectForKeyedSubscript:@"felicaInfo"];

  if (v24)
  {
    id v25 = [v28 objectForKeyedSubscript:@"felicaInfo"];
    uint32_t v26 = [v25 objectForKeyedSubscript:@"NFServiceProviderID"];

    if (v26)
    {
      uint64_t v27 = [v25 objectForKeyedSubscript:@"NFServiceProviderID"];
      [v5 setObject:v27 forKeyedSubscript:@"SPRaw"];
    }
  }
  [v7 setObject:@"EndEvent" forKeyedSubscript:@"EventType"];
  sub_10023E848(v4, v5, v7, a3, 0);
LABEL_27:
}

void sub_1002405A0(uint64_t a1, void *a2)
{
  id v2 = a2;
  self;
  id v3 = [v2 objectForKeyedSubscript:@"appletIdentifier"];
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();

  if (isKindOfClass)
  {
    id v5 = [v2 objectForKeyedSubscript:@"appletIdentifier"];
  }
  else
  {
    id v5 = &stru_100309C40;
  }
  uint64_t v6 = [v2 objectForKeyedSubscript:@"Version"];
  objc_opt_class();
  char v7 = objc_opt_isKindOfClass();

  if (v7)
  {
    BOOL v8 = [v2 objectForKeyedSubscript:@"Version"];
  }
  else
  {
    BOOL v8 = &off_1003201A0;
  }
  id v9 = [v2 objectForKeyedSubscript:@"Interface"];
  objc_opt_class();
  char v10 = objc_opt_isKindOfClass();

  if (v10)
  {
    uint64_t v11 = [v2 objectForKeyedSubscript:@"Interface"];
  }
  else
  {
    uint64_t v11 = &off_1003201A0;
  }
  int v12 = [v2 objectForKeyedSubscript:@"UnavailableCertFileId"];
  objc_opt_class();
  char v13 = objc_opt_isKindOfClass();

  if (v13)
  {
    BOOL v14 = [v2 objectForKeyedSubscript:@"UnavailableCertFileId"];
  }
  else
  {
    BOOL v14 = &off_1003201A0;
  }
  long long v15 = [v2 objectForKeyedSubscript:@"UnavailableCertAvailablityInfo"];
  objc_opt_class();
  char v16 = objc_opt_isKindOfClass();

  if (v16)
  {
    int v17 = [v2 objectForKeyedSubscript:@"UnavailableCertAvailablityInfo"];
  }
  else
  {
    int v17 = &off_1003201A0;
  }
  v20[0] = @"aid";
  v20[1] = @"version";
  v21[0] = v5;
  v21[1] = v8;
  void v20[2] = @"interface";
  v20[3] = @"fileId";
  v21[2] = v11;
  v21[3] = v14;
  v20[4] = @"availabilityInfo";
  void v21[4] = v17;
  __int16 v18 = +[NSDictionary dictionaryWithObjects:v21 forKeys:v20 count:5];
  id v19 = +[NFCALogger sharedCALogger];
  [v19 postCAEventFor:@"com.apple.nfcd.mDocHybridUnavailableCertEvent" eventInput:v18];
}

void sub_100240EBC(uint64_t a1)
{
}

void sub_100240EC4(uint64_t a1)
{
  id v2 = objc_opt_new();
  __int16 v89 = objc_opt_new();
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  id obj = *(id *)(v3 + 40);
  uint64_t v4 = [v2 fetchAppletEntitiesWithError:&obj];
  objc_storeStrong((id *)(v3 + 40), obj);
  if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) || ![v4 count])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
      uint64_t Name = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v11 = 45;
      if (isMetaClass) {
        uint64_t v11 = 43;
      }
      v6(3, "%c[%{public}s %{public}s]:%i Could not load applets from storage : %{public}@ (config %{public}@)", v11, ClassName, Name, 79, *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), v4);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v12 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      char v13 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v13)) {
        int v14 = 43;
      }
      else {
        int v14 = 45;
      }
      long long v15 = object_getClassName(*(id *)(a1 + 32));
      char v16 = sel_getName(*(SEL *)(a1 + 56));
      int v17 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
      *(_DWORD *)int buf = 67110402;
      int v101 = v14;
      __int16 v102 = 2082;
      int v103 = v15;
      __int16 v104 = 2082;
      __int16 v105 = v16;
      __int16 v106 = 1024;
      int v107 = 79;
      __int16 v108 = 2114;
      __int16 v109 = v17;
      __int16 v110 = 2114;
      id v111 = v4;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Could not load applets from storage : %{public}@ (config %{public}@)", buf, 0x36u);
    }
    goto LABEL_11;
  }
  int v12 = [v4 objectForKey:@"applets"];
  __int16 v18 = [v4 objectForKey:@"crsUpdateCounter"];
  id v19 = [v4 objectForKey:@"seid"];
  char v88 = v19;
  if (v19)
  {
    uint64_t v20 = v19;
    if ([v19 isEqualToString:*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40)])
    {
      if (!v12) {
        goto LABEL_52;
      }
      char v86 = v18;
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        long long v92 = 0u;
        long long v93 = 0u;
        long long v90 = 0u;
        long long v91 = 0u;
        int v21 = v12;
        id v22 = [v21 countByEnumeratingWithState:&v90 objects:v97 count:16];
        if (!v22)
        {
LABEL_51:

          __int16 v18 = v86;
LABEL_52:
          if (v18)
          {
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              if ([v89 count])
              {
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v68 = NFLogGetLogger();
                if (v68)
                {
                  char v69 = (void (*)(uint64_t, const char *, ...))v68;
                  __int16 v70 = object_getClass(*(id *)(a1 + 32));
                  BOOL v71 = class_isMetaClass(v70);
                  __int16 v72 = object_getClassName(*(id *)(a1 + 32));
                  char v73 = sel_getName(*(SEL *)(a1 + 56));
                  id v83 = [v89 count];
                  uint64_t v74 = 45;
                  if (v71) {
                    uint64_t v74 = 43;
                  }
                  v69(6, "%c[%{public}s %{public}s]:%i Loading applets from storage into cache using counter %{public}@ : %ld applets", v74, v72, v73, 73, v18, v83);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                __int16 v75 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v75, OS_LOG_TYPE_DEFAULT))
                {
                  char v76 = object_getClass(*(id *)(a1 + 32));
                  if (class_isMetaClass(v76)) {
                    int v77 = 43;
                  }
                  else {
                    int v77 = 45;
                  }
                  __int16 v78 = object_getClassName(*(id *)(a1 + 32));
                  __int16 v79 = sel_getName(*(SEL *)(a1 + 56));
                  id v80 = [v89 count];
                  *(_DWORD *)int buf = 67110402;
                  int v101 = v77;
                  __int16 v102 = 2082;
                  int v103 = v78;
                  __int16 v104 = 2082;
                  __int16 v105 = v79;
                  __int16 v106 = 1024;
                  int v107 = 73;
                  __int16 v108 = 2114;
                  __int16 v109 = v18;
                  __int16 v110 = 2048;
                  id v111 = v80;
                  _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Loading applets from storage into cache using counter %{public}@ : %ld applets", buf, 0x36u);
                }

                id v81 = [v18 copy];
                [*(id *)(a1 + 32) setCachedAppletUpdateCounter:v81];

                [*(id *)(a1 + 32) setCachedAppletsUnfiltered:v89];
                uint64_t v20 = v88;
              }
            }
          }

LABEL_11:
          [v2 disconnect];
          goto LABEL_12;
        }
        id v23 = v22;
        __int16 v84 = v2;
        uint64_t v24 = *(void *)v91;
        do
        {
          for (i = 0; i != v23; i = (char *)i + 1)
          {
            if (*(void *)v91 != v24) {
              objc_enumerationMutation(v21);
            }
            uint64_t v26 = *(void *)(*((void *)&v90 + 1) + 8 * i);
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              id v27 = [objc_alloc((Class)NSMutableDictionary) initWithDictionary:v26];
              [v27 setObject:&off_1003201E8 forKeyedSubscript:@"activationState"];
              id v28 = [[NFApplet alloc] initWithDictionary:v27];
              if (v28) {
                [v89 addObject:v28];
              }
            }
          }
          id v23 = [v21 countByEnumeratingWithState:&v90 objects:v97 count:16];
        }
        while (v23);
        id v2 = v84;
      }
      else
      {
        int v85 = v12;
        id v49 = objc_alloc((Class)NSError);
        NSErrorUserInfoKey v50 = +[NSString stringWithUTF8String:"nfcd"];
        v95[0] = NSLocalizedDescriptionKey;
        NSErrorUserInfoKey v51 = +[NSString stringWithUTF8String:"Invalid State"];
        v96[0] = v51;
        v96[1] = &off_100320200;
        v95[1] = @"Line";
        v95[2] = @"Method";
        id v52 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
        v96[2] = v52;
        v95[3] = NSDebugDescriptionErrorKey;
        id v53 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 69];
        v96[3] = v53;
        unint64_t v54 = +[NSDictionary dictionaryWithObjects:v96 forKeys:v95 count:4];
        id v55 = [v49 initWithDomain:v50 code:12 userInfo:v54];
        uint64_t v56 = *(void *)(*(void *)(a1 + 40) + 8);
        char v57 = *(void **)(v56 + 40);
        *(void *)(v56 + 40) = v55;

        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v58 = NFLogGetLogger();
        if (v58)
        {
          __int16 v59 = (void (*)(uint64_t, const char *, ...))v58;
          char v60 = object_getClass(*(id *)(a1 + 32));
          BOOL v61 = class_isMetaClass(v60);
          char v62 = object_getClassName(*(id *)(a1 + 32));
          NSErrorUserInfoKey v82 = sel_getName(*(SEL *)(a1 + 56));
          uint64_t v63 = 45;
          if (v61) {
            uint64_t v63 = 43;
          }
          v59(3, "%c[%{public}s %{public}s]:%i Invalid applet storage", v63, v62, v82, 70);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v21 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          __int16 v64 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v64)) {
            int v65 = 43;
          }
          else {
            int v65 = 45;
          }
          __int16 v66 = object_getClassName(*(id *)(a1 + 32));
          char v67 = sel_getName(*(SEL *)(a1 + 56));
          *(_DWORD *)int buf = 67109890;
          int v101 = v65;
          __int16 v102 = 2082;
          int v103 = v66;
          __int16 v104 = 2082;
          __int16 v105 = v67;
          __int16 v106 = 1024;
          int v107 = 70;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid applet storage", buf, 0x22u);
        }
        int v12 = v85;
      }
      uint64_t v20 = v88;
      goto LABEL_51;
    }
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v29 = NFLogGetLogger();
  if (v29)
  {
    BOOL v30 = (void (*)(uint64_t, const char *, ...))v29;
    uint64_t v31 = object_getClass(*(id *)(a1 + 32));
    BOOL v32 = class_isMetaClass(v31);
    int v33 = object_getClassName(*(id *)(a1 + 32));
    int v34 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v35 = 45;
    if (v32) {
      uint64_t v35 = 43;
    }
    v30(6, "%c[%{public}s %{public}s]:%i SEID is not matching : %{public}@ != %{public}@", v35, v33, v34, 47, v88, *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40));
  }
  __int16 v87 = v18;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v36 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v37 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v37)) {
      int v38 = 43;
    }
    else {
      int v38 = 45;
    }
    __int16 v39 = object_getClassName(*(id *)(a1 + 32));
    id v40 = sel_getName(*(SEL *)(a1 + 56));
    __int16 v41 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
    *(_DWORD *)int buf = 67110402;
    int v101 = v38;
    __int16 v102 = 2082;
    int v103 = v39;
    __int16 v104 = 2082;
    __int16 v105 = v40;
    __int16 v106 = 1024;
    int v107 = 47;
    __int16 v108 = 2114;
    __int16 v109 = v88;
    __int16 v110 = 2114;
    id v111 = v41;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i SEID is not matching : %{public}@ != %{public}@", buf, 0x36u);
  }

  id v42 = objc_alloc((Class)NSError);
  uint64_t v43 = +[NSString stringWithUTF8String:"nfcd"];
  NSErrorUserInfoKey v98 = NSLocalizedDescriptionKey;
  NSErrorUserInfoKey v44 = +[NSString stringWithUTF8String:"SEID changed"];
  char v99 = v44;
  int v45 = +[NSDictionary dictionaryWithObjects:&v99 forKeys:&v98 count:1];
  id v46 = [v42 initWithDomain:v43 code:30 userInfo:v45];
  uint64_t v47 = *(void *)(*(void *)(a1 + 40) + 8);
  id v48 = *(void **)(v47 + 40);
  *(void *)(v47 + 40) = v46;

  [v2 disconnect];
LABEL_12:
}

void sub_1002418F4(uint64_t a1, void *a2)
{
  id v2 = *(void **)(a1 + 32);
  id v3 = [a2 asDictionary];
  [v2 addObject:v3];
}

id sub_10024194C(id a1, void *a2, int a3)
{
  id v3 = a1;
  if (a1)
  {
    id v119 = 0;
    id v113 = [a1 selectCRSWithError:&v119];
    id v4 = v119;
    if (v4) {
      BOOL v5 = 1;
    }
    else {
      BOOL v5 = v113 == 0;
    }
    id v112 = v4;
    if (v5)
    {
      BOOL v6 = v4 != 0;
      id v7 = objc_alloc((Class)NSError);
      id v114 = +[NSString stringWithUTF8String:"nfcd"];
      if (v6)
      {
        id v8 = [v112 code];
        v142[0] = NSLocalizedDescriptionKey;
        if ((uint64_t)[v112 code] > 70) {
          uint64_t v9 = 71;
        }
        else {
          uint64_t v9 = (uint64_t)[v112 code];
        }
        id v23 = +[NSString stringWithUTF8String:off_100308230[v9]];
        v143[0] = v23;
        v143[1] = v112;
        v142[1] = NSUnderlyingErrorKey;
        v142[2] = @"Line";
        v143[2] = &off_100320218;
        v142[3] = @"Method";
        id v69 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_getApplicationsFromSE:filtered:")];
        v143[3] = v69;
        v142[4] = NSDebugDescriptionErrorKey;
        id v70 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_getApplicationsFromSE:filtered:"), 124];
        void v143[4] = v70;
        BOOL v71 = +[NSDictionary dictionaryWithObjects:v143 forKeys:v142 count:5];
        id v3 = [v7 initWithDomain:v114 code:v8 userInfo:v71];
      }
      else
      {
        v140[0] = NSLocalizedDescriptionKey;
        id v23 = +[NSString stringWithUTF8String:"Commmand Error"];
        v141[0] = v23;
        v141[1] = &off_100320218;
        v140[1] = @"Line";
        v140[2] = @"Method";
        id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_getApplicationsFromSE:filtered:")];
        v141[2] = v24;
        v140[3] = NSDebugDescriptionErrorKey;
        id v25 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_getApplicationsFromSE:filtered:"), 124];
        v141[3] = v25;
        uint64_t v26 = +[NSDictionary dictionaryWithObjects:v141 forKeys:v140 count:4];
        id v3 = [v7 initWithDomain:v114 code:16 userInfo:v26];
      }
      goto LABEL_102;
    }
    *(void *)&long long v120 = 0;
    *((void *)&v120 + 1) = &v120;
    *(void *)&long long v121 = 0x3032000000;
    *((void *)&v121 + 1) = sub_10000B938;
    *(void *)&long long v122 = sub_100240EBC;
    *((void *)&v122 + 1) = 0;
    int v124 = 0;
    uint64_t v125 = (uint64_t)&v124;
    uint64_t v126 = 0x3032000000;
    char v127 = sub_10000B938;
    int v128 = sub_100240EBC;
    double v129 = [v3 serialNumber];
    *(void *)int buf = _NSConcreteStackBlock;
    *(void *)int v145 = 3221225472;
    *(void *)&v145[8] = sub_100240EC4;
    *(void *)&v145[16] = &unk_100308478;
    *(void *)&v145[24] = v3;
    *(void *)&v145[32] = &v120;
    *(void *)&v145[40] = &v124;
    *(void *)&v145[48] = "loadStoredApplets";
    if (qword_1003476E8 != -1) {
      dispatch_once(&qword_1003476E8, buf);
    }
    id v10 = *(id *)(*((void *)&v120 + 1) + 40);
    _Block_object_dispose(&v124, 8);

    _Block_object_dispose(&v120, 8);
    long long v115 = 0u;
    long long v116 = 0u;
    long long v117 = 0u;
    long long v118 = 0u;
    uint64_t v11 = [v113 data];
    int v12 = +[NFTLV TLVsWithData:v11];

    id v13 = [v12 countByEnumeratingWithState:&v115 objects:v139 count:16];
    if (v13)
    {
      uint64_t v14 = *(void *)v116;
      while (2)
      {
        for (i = 0; i != v13; i = (char *)i + 1)
        {
          if (*(void *)v116 != v14) {
            objc_enumerationMutation(v12);
          }
          char v16 = *(void **)(*((void *)&v115 + 1) + 8 * i);
          if ([v16 tag] == 111)
          {
            int v17 = [v16 childWithTag:165];
            __int16 v18 = [v17 childWithTag:254];

            if (!v18)
            {
              id v19 = [v16 childWithTag:165];
              __int16 v18 = [v19 childWithTag:128];

              if (!v18) {
                goto LABEL_26;
              }
            }
            uint64_t v20 = [v18 value];
            BOOL v21 = [v20 length] == (id)2;

            if (v21)
            {
              id v22 = [v18 value];
              id v114 = +[NSNumber numberWithShort:](NSNumber, "numberWithShort:", ((int)bswap32(*(unsigned __int16 *)[v22 bytes]) >> 16));
            }
            else
            {
LABEL_26:
              id v114 = 0;
            }

            goto LABEL_28;
          }
        }
        id v13 = [v12 countByEnumeratingWithState:&v115 objects:v139 count:16];
        if (v13) {
          continue;
        }
        break;
      }
    }
    id v114 = 0;
LABEL_28:

    id v27 = [v3 cachedAppletsUnfiltered];
    unsigned int v111 = 0;
    if (v27 && v114)
    {
      id v28 = [v3 cachedAppletUpdateCounter];
      unsigned int v111 = [v28 isEqualToNumber:v114];
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (Logger)
    {
      Class = object_getClass(v3);
      if (class_isMetaClass(Class)) {
        uint64_t v31 = 43;
      }
      else {
        uint64_t v31 = 45;
      }
      Classuint64_t Name = object_getClassName(v3);
      uint64_t Name = sel_getName("_getApplicationsFromSE:filtered:");
      int v34 = [v3 cachedAppletsUnfiltered];
      uint64_t v35 = [v3 cachedAppletUpdateCounter];
      Logger(6, "%c[%{public}s %{public}s]:%i haveCache %d cacheCtr %{public}@ currentCtr %{public}@ useCache %d", v31, ClassName, Name, 148, v34 != 0, v35, v114, v111);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v36 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v37 = object_getClass(v3);
      if (class_isMetaClass(v37)) {
        int v38 = 43;
      }
      else {
        int v38 = 45;
      }
      __int16 v39 = object_getClassName(v3);
      id v40 = sel_getName("_getApplicationsFromSE:filtered:");
      __int16 v41 = [v3 cachedAppletsUnfiltered];
      id v42 = [v3 cachedAppletUpdateCounter];
      *(_DWORD *)int buf = 67110914;
      *(_DWORD *)&uint8_t buf[4] = v38;
      *(_WORD *)int v145 = 2082;
      *(void *)&v145[2] = v39;
      *(_WORD *)&v145[10] = 2082;
      *(void *)&v145[12] = v40;
      *(_WORD *)&v145[20] = 1024;
      *(_DWORD *)&v145[22] = 148;
      *(_WORD *)&v145[26] = 1024;
      *(_DWORD *)&v145[28] = v41 != 0;
      *(_WORD *)&v145[32] = 2114;
      *(void *)&v145[34] = v42;
      *(_WORD *)&v145[42] = 2114;
      *(void *)&v145[44] = v114;
      *(_WORD *)&v145[52] = 1024;
      *(_DWORD *)&v145[54] = v111;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i haveCache %d cacheCtr %{public}@ currentCtr %{public}@ useCache %d", buf, 0x42u);
    }
    if (v111)
    {
      uint64_t v43 = [v3 cachedAppletsUnfiltered];
    }
    else
    {
      if ([v3 hasMultiOS])
      {
        NSErrorUserInfoKey v44 = objc_opt_new();
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v45 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v45)
        {
          id v46 = object_getClass(v3);
          if (class_isMetaClass(v46)) {
            uint64_t v47 = 43;
          }
          else {
            uint64_t v47 = 45;
          }
          id v48 = object_getClassName(v3);
          id v49 = sel_getName("_getApplicationsFromSE:filtered:");
          v45(6, "%c[%{public}s %{public}s]:%i Getting JCOP applets", v47, v48, v49, 159);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        NSErrorUserInfoKey v50 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
        {
          NSErrorUserInfoKey v51 = object_getClass(v3);
          if (class_isMetaClass(v51)) {
            int v52 = 43;
          }
          else {
            int v52 = 45;
          }
          id v53 = object_getClassName(v3);
          unint64_t v54 = sel_getName("_getApplicationsFromSE:filtered:");
          *(_DWORD *)int buf = 67109890;
          *(_DWORD *)&uint8_t buf[4] = v52;
          *(_WORD *)int v145 = 2082;
          *(void *)&v145[2] = v53;
          *(_WORD *)&v145[10] = 2082;
          *(void *)&v145[12] = v54;
          *(_WORD *)&v145[20] = 1024;
          *(_DWORD *)&v145[22] = 159;
          _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Getting JCOP applets", buf, 0x22u);
        }

        id v55 = sub_100242AC8(v3);
        [v44 addObjectsFromArray:v55];

        id v56 = [v44 copy];
        if (!v56) {
          goto LABEL_71;
        }
        goto LABEL_55;
      }
      uint64_t v43 = sub_100242AC8(v3);
    }
    id v56 = (id)v43;
    if (!v43)
    {
LABEL_71:
      id v72 = objc_alloc((Class)NSError);
      char v73 = +[NSString stringWithUTF8String:"nfcd"];
      v137[0] = NSLocalizedDescriptionKey;
      uint64_t v74 = +[NSString stringWithUTF8String:"Commmand Error"];
      v138[0] = v74;
      v138[1] = &off_100320230;
      v137[1] = @"Line";
      v137[2] = @"Method";
      id v75 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_getApplicationsFromSE:filtered:")];
      v138[2] = v75;
      v137[3] = NSDebugDescriptionErrorKey;
      id v76 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_getApplicationsFromSE:filtered:"), 167];
      v138[3] = v76;
      int v77 = +[NSDictionary dictionaryWithObjects:v138 forKeys:v137 count:4];
      id v3 = [v72 initWithDomain:v73 code:16 userInfo:v77];

      id v23 = 0;
      goto LABEL_102;
    }
LABEL_55:
    id v23 = v56;
    uint64_t v131 = 0;
    unint64_t v132 = &v131;
    uint64_t v133 = 0x3032000000;
    int v134 = sub_10000B938;
    long long v135 = sub_100240EBC;
    id v136 = (id)objc_opt_new();
    int v124 = _NSConcreteStackBlock;
    uint64_t v125 = 3221225472;
    uint64_t v126 = (uint64_t)sub_100246C78;
    char v127 = (uint64_t (*)(uint64_t, uint64_t))&unk_1003084C8;
    double v129 = &v131;
    unint64_t v130 = "_addInstanceACLsToApplets:";
    int v128 = (void (*)(uint64_t))v3;
    char v57 = sub_10018DC58(v3, 64, (uint64_t)&unk_100284605, 2uLL, &v124);
    if (v57)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v58 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v58)
      {
        __int16 v59 = object_getClass(v3);
        if (class_isMetaClass(v59)) {
          uint64_t v60 = 43;
        }
        else {
          uint64_t v60 = 45;
        }
        BOOL v61 = object_getClassName(v3);
        char v62 = sel_getName("_addInstanceACLsToApplets:");
        v58(3, "%c[%{public}s %{public}s]:%i Failed proprietary get status for InstaneACL", v60, v61, v62, 595);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v63 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
      {
        __int16 v64 = object_getClass(v3);
        if (class_isMetaClass(v64)) {
          int v65 = 43;
        }
        else {
          int v65 = 45;
        }
        __int16 v66 = object_getClassName(v3);
        char v67 = sel_getName("_addInstanceACLsToApplets:");
        *(_DWORD *)int buf = 67109890;
        *(_DWORD *)&uint8_t buf[4] = v65;
        *(_WORD *)int v145 = 2082;
        *(void *)&v145[2] = v66;
        *(_WORD *)&v145[10] = 2082;
        *(void *)&v145[12] = v67;
        *(_WORD *)&v145[20] = 1024;
        *(_DWORD *)&v145[22] = 595;
        _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed proprietary get status for InstaneACL", buf, 0x22u);
      }

      id v68 = v57;
    }
    else
    {
      long long v122 = 0u;
      long long v123 = 0u;
      long long v120 = 0u;
      long long v121 = 0u;
      id v78 = v23;
      id v79 = [v78 countByEnumeratingWithState:&v120 objects:buf count:16];
      if (v79)
      {
        uint64_t v80 = *(void *)v121;
        do
        {
          for (j = 0; j != v79; j = (char *)j + 1)
          {
            if (*(void *)v121 != v80) {
              objc_enumerationMutation(v78);
            }
            NSErrorUserInfoKey v82 = *(void **)(*((void *)&v120 + 1) + 8 * (void)j);
            id v83 = (void *)v132[5];
            __int16 v84 = [v82 identifierAsData];
            int v85 = [v83 objectForKeyedSubscript:v84];

            if (v85) {
              [v82 setInstanceACL:v85];
            }
          }
          id v79 = [v78 countByEnumeratingWithState:&v120 objects:buf count:16];
        }
        while (v79);
      }

      id v68 = 0;
    }

    _Block_object_dispose(&v131, 8);
    [v3 setCachedAppletsUnfiltered:v23];
    [v3 setCachedAppletUpdateCounter:v114];
    char v86 = [v3 cachedAppletUpdateCounter];
    if (v86) {
      char v87 = v111;
    }
    else {
      char v87 = 1;
    }

    if ((v87 & 1) == 0)
    {
      char v88 = objc_opt_new();
      __int16 v89 = objc_opt_new();
      long long v90 = objc_opt_new();
      long long v91 = [v3 cachedAppletsUnfiltered];
      *(void *)&long long v120 = _NSConcreteStackBlock;
      *((void *)&v120 + 1) = 3221225472;
      *(void *)&long long v121 = sub_1002418F4;
      *((void *)&v121 + 1) = &unk_1003084A0;
      id v92 = v89;
      *(void *)&long long v122 = v92;
      [v91 enumerateObjectsUsingBlock:&v120];

      long long v93 = [v3 cachedAppletUpdateCounter];
      [v88 setObject:v93 forKey:@"crsUpdateCounter"];

      NSErrorUserInfoKey v94 = [v3 serialNumber];
      [v88 setObject:v94 forKey:@"seid"];

      [v88 setObject:v92 forKey:@"applets"];
      char v95 = [v90 updateAppletEntitiesWithConfig:v88];
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      unsigned int v96 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v96)
      {
        char v97 = object_getClass(v3);
        if (class_isMetaClass(v97)) {
          uint64_t v98 = 43;
        }
        else {
          uint64_t v98 = 45;
        }
        char v99 = object_getClassName(v3);
        unsigned int v100 = sel_getName("storeApplets");
        v96(6, "%c[%{public}s %{public}s]:%i Storing applets from cache : %{public}@, error %{public}@", v98, v99, v100, 104, v88, v95);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v101 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v102 = object_getClass(v3);
        if (class_isMetaClass(v102)) {
          int v103 = 43;
        }
        else {
          int v103 = 45;
        }
        __int16 v104 = object_getClassName(v3);
        __int16 v105 = sel_getName("storeApplets");
        *(_DWORD *)int buf = 67110402;
        *(_DWORD *)&uint8_t buf[4] = v103;
        *(_WORD *)int v145 = 2082;
        *(void *)&v145[2] = v104;
        *(_WORD *)&v145[10] = 2082;
        *(void *)&v145[12] = v105;
        *(_WORD *)&v145[20] = 1024;
        *(_DWORD *)&v145[22] = 104;
        *(_WORD *)&v145[26] = 2114;
        *(void *)&v145[28] = v88;
        *(_WORD *)&v145[36] = 2114;
        *(void *)&v145[38] = v95;
        _os_log_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Storing applets from cache : %{public}@, error %{public}@", buf, 0x36u);
      }

      [v90 disconnect];
    }
    if (a2)
    {
      __int16 v106 = [v3 cachedAppletsUnfiltered];
      int v107 = v106;
      if (!a3)
      {
        id v3 = 0;
        *a2 = v106;
        goto LABEL_102;
      }
      sub_100242BEC((uint64_t)v3, v106);
      *a2 = (id)objc_claimAutoreleasedReturnValue();
    }
    id v3 = 0;
LABEL_102:
  }

  return v3;
}

void sub_100242A80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49)
{
}

id sub_100242AC8(void *a1)
{
  id v2 = objc_opt_new();
  id v3 = +[NFTLV TLVWithTag:79 value:0];
  id v4 = [v3 asData];
  [v2 appendData:v4];

  id v5 = [objc_alloc((Class)NSMutableData) initWithBytes:&unk_100284560 length:10];
  if (([a1 supportedTechnologies] & 4) != 0) {
    [v5 appendBytes:&unk_10028456A length:1];
  }
  BOOL v6 = +[NFTLV TLVWithTag:92 value:v5];
  id v7 = [v6 asData];
  [v2 appendData:v7];

  id v8 = sub_1000C1AB4(a1, v2, 0);

  return v8;
}

id sub_100242BEC(uint64_t a1, void *a2)
{
  id v29 = a2;
  if (a1)
  {
    id v30 = [objc_alloc((Class)NSData) initWithBytes:&unk_10028456B length:14];
    v37[0] = v30;
    id v28 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284579 length:12];
    v37[1] = v28;
    id v27 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284585 length:7];
    v37[2] = v27;
    id v26 = [objc_alloc((Class)NSData) initWithBytes:&unk_10028458C length:7];
    v37[3] = v26;
    id v3 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284593 length:9];
    v37[4] = v3;
    id v4 = [objc_alloc((Class)NSData) initWithBytes:&unk_10028459C length:8];
    void v37[5] = v4;
    id v5 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002845A4 length:12];
    v37[6] = v5;
    id v6 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002845B0 length:12];
    v37[7] = v6;
    id v7 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002845BC length:10];
    void v37[8] = v7;
    id v8 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002845C6 length:14];
    v37[9] = v8;
    id v9 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002845D4 length:10];
    v37[10] = v9;
    id v10 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002845DE length:10];
    v37[11] = v10;
    id v11 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002845E8 length:9];
    v37[12] = v11;
    int v12 = +[NSArray arrayWithObjects:v37 count:13];

    id v31 = (id)objc_opt_new();
    long long v32 = 0u;
    long long v33 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    id v13 = v29;
    id v14 = [v13 countByEnumeratingWithState:&v32 objects:v36 count:16];
    if (v14)
    {
      id v15 = v14;
      uint64_t v16 = *(void *)v33;
      do
      {
        for (i = 0; i != v15; i = (char *)i + 1)
        {
          if (*(void *)v33 != v16) {
            objc_enumerationMutation(v13);
          }
          __int16 v18 = *(void **)(*((void *)&v32 + 1) + 8 * i);
          id v19 = [v18 identifierAsData];
          unsigned __int8 v20 = [v12 containsObject:v19];

          if ((v20 & 1) == 0
            && [v18 lifecycleState] != 129
            && ([v18 isContainer] & 1) == 0
            && ([v18 isProxy] & 1) == 0)
          {
            BOOL v21 = [v18 identifier];
            unsigned __int8 v22 = [v21 hasPrefix:@"A00000085881"];

            if ((v22 & 1) == 0)
            {
              id v23 = [v18 identifier];
              unsigned __int8 v24 = [v23 hasPrefix:@"A000000704E0000100"];

              if ((v24 & 1) == 0) {
                [v31 addObject:v18];
              }
            }
          }
        }
        id v15 = [v13 countByEnumeratingWithState:&v32 objects:v36 count:16];
      }
      while (v15);
    }
  }
  else
  {
    id v31 = 0;
  }

  return v31;
}

void sub_100242FE4(void *a1)
{
  if (a1)
  {
    uint64_t v1 = sub_1002431DC(a1);
    long long v15 = 0u;
    long long v16 = 0u;
    long long v17 = 0u;
    long long v18 = 0u;
    id v2 = [v1 countByEnumeratingWithState:&v15 objects:v21 count:16];
    if (v2)
    {
      id v3 = v2;
      id v4 = 0;
      uint64_t v5 = 0;
      uint64_t v6 = *(void *)v16;
      do
      {
        for (i = 0; i != v3; i = (char *)i + 1)
        {
          if (*(void *)v16 != v6) {
            objc_enumerationMutation(v1);
          }
          id v8 = *(void **)(*((void *)&v15 + 1) + 8 * i);
          if ([v8 lifecycleState] == 15)
          {
            uint64_t v5 = (v5 + 1);
            uint64_t v9 = [v8 identifier];
            id v10 = (void *)v9;
            if (v4)
            {
              uint64_t v11 = [(__CFString *)v4 stringByAppendingFormat:@"%@%@", @"_", v9];

              id v4 = (__CFString *)v11;
            }
            else
            {
              id v4 = (__CFString *)v9;
            }
          }
        }
        id v3 = [v1 countByEnumeratingWithState:&v15 objects:v21 count:16];
      }
      while (v3);
    }
    else
    {
      id v4 = 0;
      uint64_t v5 = 0;
    }
    v19[0] = @"totalCardProvisioned";
    int v12 = +[NSNumber numberWithInt:v5];
    v19[1] = @"currentProvisionedCards";
    v20[0] = v12;
    CFStringRef v13 = &stru_100309C40;
    if (v4) {
      CFStringRef v13 = v4;
    }
    v20[1] = v13;
    id v14 = +[NSDictionary dictionaryWithObjects:v20 forKeys:v19 count:2];
    +[NFGeneralStatisticsCALogger updateGeneralDeviceStatistic:v14];
  }
}

id sub_1002431DC(id a1)
{
  id v1 = a1;
  if (a1)
  {
    id v2 = [a1 cachedAppletsUnfiltered];
    if (v2)
    {
      id v3 = [v1 cachedAppletsUnfiltered];
      sub_100242BEC((uint64_t)v1, v3);
      id v1 = (id)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      id v1 = 0;
    }
  }

  return v1;
}

id sub_100243264(void *a1, void *a2, unsigned int a3, uint64_t a4)
{
  id v7 = a2;
  id v40 = 0;
  id v8 = [a1 selectCRSWithError:&v40];
  id v9 = v40;
  if (v9)
  {
    id v10 = objc_alloc((Class)NSError);
    uint64_t v11 = +[NSString stringWithUTF8String:"nfcd"];
    id v12 = [v9 code];
    v55[0] = NSLocalizedDescriptionKey;
    if ((uint64_t)[v9 code] > 70) {
      uint64_t v13 = 71;
    }
    else {
      uint64_t v13 = (uint64_t)[v9 code];
    }
    long long v15 = +[NSString stringWithUTF8String:off_100308230[v13]];
    v56[0] = v15;
    v56[1] = v9;
    v55[1] = NSUnderlyingErrorKey;
    id v55[2] = @"Line";
    v56[2] = &off_100320248;
    v55[3] = @"Method";
    id v16 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("setApplications:asSelectable:groupActivationStyle:")];
    v56[3] = v16;
    void v55[4] = NSDebugDescriptionErrorKey;
    id v17 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", @"setApplications:asSelectable:groupActivationStyle:", 297];
    void v56[4] = v17;
    long long v18 = +[NSDictionary dictionaryWithObjects:v56 forKeys:v55 count:5];
    id v19 = v10;
    unsigned __int8 v20 = v11;
    uint64_t v21 = (uint64_t)v12;
  }
  else
  {
    if (sub_1000C3440(a1, v7, a3, a4))
    {
      id v14 = 0;
      goto LABEL_23;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    CFStringRef v23 = @"enable";
    if (Logger)
    {
      unsigned __int8 v24 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(a1);
      uint64_t Name = sel_getName("setApplications:asSelectable:groupActivationStyle:");
      if (!a3) {
        CFStringRef v23 = @"disable";
      }
      id v27 = +[NFApplet aidListForPrinting:v7];
      uint64_t v28 = 45;
      if (isMetaClass) {
        uint64_t v28 = 43;
      }
      v24(3, "%c[%{public}s %{public}s]:%i Failed to %{public}@ applications: %{public}@", v28, ClassName, Name, 301, v23, v27);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v29 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      id v30 = object_getClass(a1);
      CFStringRef v31 = @"enable";
      if (class_isMetaClass(v30)) {
        int v32 = 43;
      }
      else {
        int v32 = 45;
      }
      long long v33 = object_getClassName(a1);
      long long v34 = sel_getName("setApplications:asSelectable:groupActivationStyle:");
      if (!a3) {
        CFStringRef v31 = @"disable";
      }
      long long v35 = +[NFApplet aidListForPrinting:v7];
      *(_DWORD *)int buf = 67110402;
      int v44 = v32;
      __int16 v45 = 2082;
      id v46 = v33;
      __int16 v47 = 2082;
      id v48 = v34;
      __int16 v49 = 1024;
      int v50 = 301;
      __int16 v51 = 2114;
      CFStringRef v52 = v31;
      __int16 v53 = 2114;
      unint64_t v54 = v35;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to %{public}@ applications: %{public}@", buf, 0x36u);
    }
    id v36 = objc_alloc((Class)NSError);
    uint64_t v11 = +[NSString stringWithUTF8String:"nfcd"];
    v41[0] = NSLocalizedDescriptionKey;
    long long v15 = +[NSString stringWithUTF8String:"Commmand Error"];
    v42[0] = v15;
    v42[1] = &off_100320260;
    v41[1] = @"Line";
    v41[2] = @"Method";
    id v16 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("setApplications:asSelectable:groupActivationStyle:")];
    v42[2] = v16;
    v41[3] = NSDebugDescriptionErrorKey;
    id v17 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("setApplications:asSelectable:groupActivationStyle:"), 302];
    v42[3] = v17;
    long long v18 = +[NSDictionary dictionaryWithObjects:v42 forKeys:v41 count:4];
    id v19 = v36;
    unsigned __int8 v20 = v11;
    uint64_t v21 = 16;
  }
  id v14 = [v19 initWithDomain:v20 code:v21 userInfo:v18];

LABEL_23:

  return v14;
}

id sub_10024379C(void *a1)
{
  if (a1)
  {
    a1 = sub_10024194C(a1, 0, 1);
    uint64_t v1 = vars8;
  }
  return a1;
}

id sub_1002437D4(void *a1, uint64_t a2)
{
  if (!a1)
  {
LABEL_40:
    id v48 = 0;
    goto LABEL_45;
  }
  id v2 = a1;
  uint64_t v3 = sub_1001F8564(a1, a2);
  uint64_t v58 = v2;
  if (!v3)
  {
    id v63 = 0;
    unsigned __int8 v24 = sub_100243D60(v2, &v63);
    id v25 = v63;

    if (!v24)
    {
      long long v61 = 0u;
      long long v62 = 0u;
      long long v59 = 0u;
      long long v60 = 0u;
      id v57 = v25;
      id v26 = v25;
      id v27 = [v26 countByEnumeratingWithState:&v59 objects:v80 count:16];
      if (v27)
      {
        id v28 = v27;
        uint64_t v29 = *(void *)v60;
        do
        {
          for (i = 0; i != v28; i = (char *)i + 1)
          {
            if (*(void *)v60 != v29) {
              objc_enumerationMutation(v26);
            }
            CFStringRef v31 = *(void **)(*((void *)&v59 + 1) + 8 * i);
            if ([v31 isGPLocked] && (sub_1000C41C4((uint64_t)v2, v31) & 1) == 0)
            {
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t Logger = NFLogGetLogger();
              if (Logger)
              {
                long long v33 = (void (*)(uint64_t, const char *, ...))Logger;
                Class = object_getClass(v2);
                BOOL isMetaClass = class_isMetaClass(Class);
                Classuint64_t Name = object_getClassName(v2);
                uint64_t Name = sel_getName("deleteAllApplets:");
                int v38 = [v31 identifier];
                id v55 = ClassName;
                uint64_t v39 = 45;
                if (isMetaClass) {
                  uint64_t v39 = 43;
                }
                id v2 = v58;
                v33(3, "%c[%{public}s %{public}s]:%i Failed to mark %{public}@ for MFF", v39, v55, Name, 344, v38);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              id v40 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
              {
                __int16 v41 = object_getClass(v2);
                if (class_isMetaClass(v41)) {
                  int v42 = 43;
                }
                else {
                  int v42 = 45;
                }
                uint64_t v43 = object_getClassName(v2);
                int v44 = sel_getName("deleteAllApplets:");
                __int16 v45 = [v31 identifier];
                *(_DWORD *)int buf = 67110146;
                int v67 = v42;
                __int16 v68 = 2082;
                id v69 = v43;
                __int16 v70 = 2082;
                BOOL v71 = v44;
                id v2 = v58;
                __int16 v72 = 1024;
                int v73 = 344;
                __int16 v74 = 2114;
                CFStringRef v75 = v45;
                _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to mark %{public}@ for MFF", buf, 0x2Cu);
              }
            }
          }
          id v28 = [v26 countByEnumeratingWithState:&v59 objects:v80 count:16];
        }
        while (v28);
      }

      id v25 = v57;
    }

    id v46 = sub_10024379C(v2);
    id v47 = [v2 refreshISDCounter];
    [v2 setActiveApplet:0];
    +[NFGeneralStatisticsCALogger updateGeneralDeviceStatistic:&off_100323820];
    goto LABEL_40;
  }
  uint64_t v4 = v3;
  id v5 = sub_10024379C(v2);
  id v6 = [v2 refreshISDCounter];
  [v2 setActiveApplet:0];
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v7 = NFLogGetLogger();
  if (v7)
  {
    id v8 = (void (*)(uint64_t, const char *, ...))v7;
    id v9 = object_getClass(v2);
    BOOL v10 = class_isMetaClass(v9);
    uint64_t v11 = object_getClassName(v2);
    id v12 = sel_getName("deleteAllApplets:");
    if (v4 >= 0x47) {
      int v13 = 71;
    }
    else {
      int v13 = v4;
    }
    id v56 = off_100308230[v13];
    unint64_t v54 = v11;
    uint64_t v14 = 43;
    if (!v10) {
      uint64_t v14 = 45;
    }
    id v2 = v58;
    v8(3, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", v14, v54, v12, 357, @"Returned", v4, v56);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  long long v15 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
  {
    id v16 = object_getClass(v2);
    BOOL v17 = !class_isMetaClass(v16);
    long long v18 = v2;
    if (v17) {
      int v19 = 45;
    }
    else {
      int v19 = 43;
    }
    unsigned __int8 v20 = object_getClassName(v18);
    uint64_t v21 = sel_getName("deleteAllApplets:");
    if (v4 >= 0x47) {
      uint64_t v22 = 71;
    }
    else {
      uint64_t v22 = v4;
    }
    CFStringRef v23 = off_100308230[v22];
    *(_DWORD *)int buf = 67110658;
    int v67 = v19;
    __int16 v68 = 2082;
    id v69 = v20;
    __int16 v70 = 2082;
    BOOL v71 = v21;
    __int16 v72 = 1024;
    int v73 = 357;
    __int16 v74 = 2112;
    CFStringRef v75 = @"Returned";
    __int16 v76 = 1024;
    int v77 = v4;
    __int16 v78 = 2080;
    id v79 = v23;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", buf, 0x3Cu);
  }
  else if (v4 >= 0x47)
  {
    uint64_t v22 = 71;
  }
  else
  {
    uint64_t v22 = v4;
  }

  id v49 = objc_alloc((Class)NSError);
  int v50 = +[NSString stringWithUTF8String:"nfcd"];
  NSErrorUserInfoKey v64 = NSLocalizedDescriptionKey;
  __int16 v51 = +[NSString stringWithUTF8String:off_100308230[v22]];
  int v65 = v51;
  CFStringRef v52 = +[NSDictionary dictionaryWithObjects:&v65 forKeys:&v64 count:1];
  id v48 = [v49 initWithDomain:v50 code:v4 userInfo:v52];

LABEL_45:

  return v48;
}

id sub_100243D60(void *a1, void *a2)
{
  if (!a1)
  {
LABEL_17:
    id v5 = 0;
    goto LABEL_20;
  }
  uint64_t v4 = sub_1002431DC(a1);

  if (v4 || (sub_10024194C(a1, a2, 1), (uint64_t v6 = objc_claimAutoreleasedReturnValue()) == 0))
  {
    if (a2)
    {
      sub_1002431DC(a1);
      id v5 = 0;
      *a2 = (id)objc_claimAutoreleasedReturnValue();
      goto LABEL_20;
    }
    goto LABEL_17;
  }
  uint64_t v7 = (void *)v6;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v9 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(a1);
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(a1);
    uint64_t Name = sel_getName("getApplets:");
    uint64_t v12 = 45;
    if (isMetaClass) {
      uint64_t v12 = 43;
    }
    v9(3, "%c[%{public}s %{public}s]:%i Failed to get applications : %@", v12, ClassName, Name, 516, v7);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v13 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    uint64_t v14 = object_getClass(a1);
    if (class_isMetaClass(v14)) {
      int v15 = 43;
    }
    else {
      int v15 = 45;
    }
    *(_DWORD *)int buf = 67110146;
    int v30 = v15;
    __int16 v31 = 2082;
    int v32 = object_getClassName(a1);
    __int16 v33 = 2082;
    long long v34 = sel_getName("getApplets:");
    __int16 v35 = 1024;
    int v36 = 516;
    __int16 v37 = 2112;
    int v38 = v7;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get applications : %@", buf, 0x2Cu);
  }

  id v16 = objc_alloc((Class)NSError);
  BOOL v17 = +[NSString stringWithUTF8String:"nfcd"];
  id v18 = [v7 code];
  v27[0] = NSLocalizedDescriptionKey;
  if ((uint64_t)[v7 code] > 70) {
    uint64_t v19 = 71;
  }
  else {
    uint64_t v19 = (uint64_t)[v7 code];
  }
  unsigned __int8 v20 = +[NSString stringWithUTF8String:off_100308230[v19]];
  v28[0] = v20;
  v28[1] = v7;
  v27[1] = NSUnderlyingErrorKey;
  v27[2] = @"Line";
  v28[2] = &off_100320350;
  v27[3] = @"Method";
  id v21 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("getApplets:")];
  v28[3] = v21;
  v27[4] = NSDebugDescriptionErrorKey;
  id v22 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("getApplets:"), 517];
  v28[4] = v22;
  CFStringRef v23 = +[NSDictionary dictionaryWithObjects:v28 forKeys:v27 count:5];
  id v5 = [v16 initWithDomain:v17 code:v18 userInfo:v23];

LABEL_20:

  return v5;
}

id sub_1002440F8(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if (v3)
    {
      id v5 = NFSharedSignpostLog();
      if (os_signpost_enabled(v5))
      {
        uint64_t v6 = [v4 identifier];
        *(_DWORD *)int buf = 138412290;
        *(void *)id v40 = v6;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "ACTIVATE_APPLET", "Activate applet %@", buf, 0xCu);
      }
      int v36 = v4;
      uint64_t v7 = +[NSArray arrayWithObjects:&v36 count:1];
      sub_100243264(a1, v7, 1u, (uint64_t)[v4 groupActivationStyle]);
      id v8 = (id)objc_claimAutoreleasedReturnValue();

      if (!v8)
      {
        [a1 setActiveApplet:v4];
        id v8 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002845F1 length:8];
        id v27 = [a1 selectByName:v8 error:0];
        id v26 = 0;
LABEL_22:

        goto LABEL_23;
      }
      id v9 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002845F1 length:8];
      id v10 = [a1 selectByName:v9 error:0];

      id v11 = objc_alloc((Class)NSError);
      uint64_t v12 = +[NSString stringWithUTF8String:"nfcd"];
      id v13 = [v8 code];
      v34[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[v8 code] > 70) {
        uint64_t v14 = 71;
      }
      else {
        uint64_t v14 = (uint64_t)[v8 code];
      }
      id v28 = +[NSString stringWithUTF8String:off_100308230[v14]];
      v35[0] = v28;
      v35[1] = v8;
      v34[1] = NSUnderlyingErrorKey;
      v34[2] = @"Line";
      v35[2] = &off_1003202C0;
      v34[3] = @"Method";
      id v29 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("activateApplet:")];
      v35[3] = v29;
      void v34[4] = NSDebugDescriptionErrorKey;
      id v30 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("activateApplet:"), 389];
      v35[4] = v30;
      __int16 v31 = +[NSDictionary dictionaryWithObjects:v35 forKeys:v34 count:5];
      id v26 = [v11 initWithDomain:v12 code:v13 userInfo:v31];
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        id v16 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        Classuint64_t Name = object_getClassName(a1);
        uint64_t Name = sel_getName("activateApplet:");
        uint64_t v20 = 45;
        if (isMetaClass) {
          uint64_t v20 = 43;
        }
        v16(3, "%c[%{public}s %{public}s]:%i Missing applet parameter", v20, ClassName, Name, 372);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v21 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        id v22 = object_getClass(a1);
        if (class_isMetaClass(v22)) {
          int v23 = 43;
        }
        else {
          int v23 = 45;
        }
        *(_DWORD *)int buf = 67109890;
        *(_DWORD *)id v40 = v23;
        *(_WORD *)&void v40[4] = 2082;
        *(void *)&v40[6] = object_getClassName(a1);
        __int16 v41 = 2082;
        int v42 = sel_getName("activateApplet:");
        __int16 v43 = 1024;
        int v44 = 372;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Missing applet parameter", buf, 0x22u);
      }

      id v24 = objc_alloc((Class)NSError);
      id v8 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v37 = NSLocalizedDescriptionKey;
      uint64_t v12 = +[NSString stringWithUTF8String:"Missing Parameter"];
      int v38 = v12;
      id v25 = +[NSDictionary dictionaryWithObjects:&v38 forKeys:&v37 count:1];
      id v26 = [v24 initWithDomain:v8 code:9 userInfo:v25];
    }
    goto LABEL_22;
  }
  id v26 = 0;
LABEL_23:

  return v26;
}

id sub_10024461C(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if (v3 && [v3 count] == (id)2)
    {
      id v5 = [v4 firstObject];
      uint64_t v6 = [v4 lastObject];
      unsigned int v7 = [v5 groupActivationStyle];
      if (v7 == [v6 groupActivationStyle])
      {
        id v8 = NFSharedSignpostLog();
        if (os_signpost_enabled(v8))
        {
          id v9 = [v5 identifier];
          id v10 = [v6 identifier];
          *(_DWORD *)int buf = 138412546;
          *(void *)long long v62 = v9;
          *(_WORD *)&v62[8] = 2112;
          *(void *)&v62[10] = v10;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v8, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "ACTIVATE_APPLET", "Activate primary applet %@ and secondary applet %@", buf, 0x16u);
        }
        sub_100243264(a1, v4, 1u, (uint64_t)[v5 groupActivationStyle]);
        id v11 = (id)objc_claimAutoreleasedReturnValue();
        if (v11)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t Logger = NFLogGetLogger();
          if (Logger)
          {
            id v13 = (void (*)(uint64_t, const char *, ...))Logger;
            Class = object_getClass(a1);
            BOOL isMetaClass = class_isMetaClass(Class);
            Classuint64_t Name = object_getClassName(a1);
            uint64_t Name = sel_getName("activateApplets:");
            uint64_t v17 = 45;
            if (isMetaClass) {
              uint64_t v17 = 43;
            }
            v13(3, "%c[%{public}s %{public}s]:%i Unable to activate applets %@. Error %@", v17, ClassName, Name, 419, v4, v11);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v18 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            uint64_t v19 = object_getClass(a1);
            if (class_isMetaClass(v19)) {
              int v20 = 43;
            }
            else {
              int v20 = 45;
            }
            id v21 = object_getClassName(a1);
            id v22 = sel_getName("activateApplets:");
            *(_DWORD *)int buf = 67110402;
            *(_DWORD *)long long v62 = v20;
            *(_WORD *)&void v62[4] = 2082;
            *(void *)&v62[6] = v21;
            *(_WORD *)&v62[14] = 2082;
            *(void *)&v62[16] = v22;
            __int16 v63 = 1024;
            int v64 = 419;
            __int16 v65 = 2112;
            __int16 v66 = v4;
            __int16 v67 = 2112;
            id v68 = v11;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unable to activate applets %@. Error %@", buf, 0x36u);
          }
        }
        else
        {
          [a1 setActiveApplet:v5];
        }
        id v47 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002845F1 length:8];
        id v48 = [a1 selectByName:v47 error:0];

        if (!v11)
        {
          id v34 = 0;
LABEL_47:

          goto LABEL_48;
        }
        id v49 = objc_alloc((Class)NSError);
        id v32 = +[NSString stringWithUTF8String:"nfcd"];
        v59[0] = NSLocalizedDescriptionKey;
        id v57 = [v11 code];
        uint64_t v58 = v49;
        if ((uint64_t)[v11 code] > 70) {
          uint64_t v50 = 71;
        }
        else {
          uint64_t v50 = (uint64_t)[v11 code];
        }
        id v33 = +[NSString stringWithUTF8String:off_100308230[v50]];
        v60[0] = v33;
        v60[1] = v11;
        v59[1] = NSUnderlyingErrorKey;
        void v59[2] = @"Line";
        v60[2] = &off_100320308;
        v59[3] = @"Method";
        id v45 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("activateApplets:")];
        void v60[3] = v45;
        void v59[4] = NSDebugDescriptionErrorKey;
        id v46 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("activateApplets:"), 424];
        void v60[4] = v46;
        __int16 v51 = +[NSDictionary dictionaryWithObjects:v60 forKeys:v59 count:5];
        id v34 = [v58 initWithDomain:v32 code:v57 userInfo:v51];
      }
      else
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v35 = NFLogGetLogger();
        if (v35)
        {
          int v36 = (void (*)(uint64_t, const char *, ...))v35;
          NSErrorUserInfoKey v37 = object_getClass(a1);
          BOOL v38 = class_isMetaClass(v37);
          uint64_t v39 = object_getClassName(a1);
          id v56 = sel_getName("activateApplets:");
          uint64_t v40 = 45;
          if (v38) {
            uint64_t v40 = 43;
          }
          v36(3, "%c[%{public}s %{public}s]:%i Mismatch activation styles on both the applets.", v40, v39, v56, 406);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        __int16 v41 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
        {
          int v42 = object_getClass(a1);
          if (class_isMetaClass(v42)) {
            int v43 = 43;
          }
          else {
            int v43 = 45;
          }
          *(_DWORD *)int buf = 67109890;
          *(_DWORD *)long long v62 = v43;
          *(_WORD *)&void v62[4] = 2082;
          *(void *)&v62[6] = object_getClassName(a1);
          *(_WORD *)&v62[14] = 2082;
          *(void *)&v62[16] = sel_getName("activateApplets:");
          __int16 v63 = 1024;
          int v64 = 406;
          _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Mismatch activation styles on both the applets.", buf, 0x22u);
        }

        id v44 = objc_alloc((Class)NSError);
        id v11 = +[NSString stringWithUTF8String:"nfcd"];
        v69[0] = NSLocalizedDescriptionKey;
        id v32 = +[NSString stringWithUTF8String:"Invalid Parameter"];
        v70[0] = v32;
        v70[1] = &off_1003202F0;
        v69[1] = @"Line";
        v69[2] = @"Method";
        id v33 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("activateApplets:")];
        v70[2] = v33;
        v69[3] = NSDebugDescriptionErrorKey;
        id v45 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("activateApplets:"), 407];
        v70[3] = v45;
        id v46 = +[NSDictionary dictionaryWithObjects:v70 forKeys:v69 count:4];
        id v34 = [v44 initWithDomain:v11 code:10 userInfo:v46];
      }
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v23 = NFLogGetLogger();
      if (v23)
      {
        id v24 = (void (*)(uint64_t, const char *, ...))v23;
        id v25 = object_getClass(a1);
        BOOL v26 = class_isMetaClass(v25);
        __int16 v53 = object_getClassName(a1);
        id v55 = sel_getName("activateApplets:");
        uint64_t v27 = 45;
        if (v26) {
          uint64_t v27 = 43;
        }
        v24(3, "%c[%{public}s %{public}s]:%i Missing or invalid applets parameter %@", v27, v53, v55, 396, v4);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v28 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
      {
        id v29 = object_getClass(a1);
        if (class_isMetaClass(v29)) {
          int v30 = 43;
        }
        else {
          int v30 = 45;
        }
        *(_DWORD *)int buf = 67110146;
        *(_DWORD *)long long v62 = v30;
        *(_WORD *)&void v62[4] = 2082;
        *(void *)&v62[6] = object_getClassName(a1);
        *(_WORD *)&v62[14] = 2082;
        *(void *)&v62[16] = sel_getName("activateApplets:");
        __int16 v63 = 1024;
        int v64 = 396;
        __int16 v65 = 2112;
        __int16 v66 = v4;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Missing or invalid applets parameter %@", buf, 0x2Cu);
      }

      id v31 = objc_alloc((Class)NSError);
      id v5 = +[NSString stringWithUTF8String:"nfcd"];
      v71[0] = NSLocalizedDescriptionKey;
      uint64_t v6 = +[NSString stringWithUTF8String:"Missing Parameter"];
      v72[0] = v6;
      v72[1] = &off_1003202D8;
      v71[1] = @"Line";
      void v71[2] = @"Method";
      id v11 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("activateApplets:")];
      v72[2] = v11;
      v71[3] = NSDebugDescriptionErrorKey;
      id v32 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("activateApplets:"), 397];
      v72[3] = v32;
      id v33 = +[NSDictionary dictionaryWithObjects:v72 forKeys:v71 count:4];
      id v34 = [v31 initWithDomain:v5 code:9 userInfo:v33];
    }

    goto LABEL_47;
  }
  id v34 = 0;
LABEL_48:

  return v34;
}

id sub_100244F68(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (!a1) {
    goto LABEL_36;
  }
  if (v3)
  {
    if ([v3 count])
    {
      uint64_t v5 = sub_100243264(a1, v4, 0, 0);
      if (v5)
      {
        uint64_t v6 = (void *)v5;
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          id v8 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(a1);
          BOOL isMetaClass = class_isMetaClass(Class);
          Classuint64_t Name = object_getClassName(a1);
          uint64_t Name = sel_getName("deselectApplets:");
          uint64_t v11 = 45;
          if (isMetaClass) {
            uint64_t v11 = 43;
          }
          v8(3, "%c[%{public}s %{public}s]:%i Error in setApplications: %@", v11, ClassName, Name, 443, v6);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v12 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          id v13 = object_getClass(a1);
          if (class_isMetaClass(v13)) {
            int v14 = 43;
          }
          else {
            int v14 = 45;
          }
          *(_DWORD *)int buf = 67110146;
          int v56 = v14;
          __int16 v57 = 2082;
          uint64_t v58 = object_getClassName(a1);
          __int16 v59 = 2082;
          long long v60 = sel_getName("deselectApplets:");
          __int16 v61 = 1024;
          int v62 = 443;
          __int16 v63 = 2112;
          int v64 = v6;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error in setApplications: %@", buf, 0x2Cu);
        }

        id v15 = objc_alloc((Class)NSError);
        id v16 = +[NSString stringWithUTF8String:"nfcd"];
        id v17 = [v6 code];
        v53[0] = NSLocalizedDescriptionKey;
        if ((uint64_t)[v6 code] > 70) {
          uint64_t v18 = 71;
        }
        else {
          uint64_t v18 = (uint64_t)[v6 code];
        }
        id v44 = +[NSString stringWithUTF8String:off_100308230[v18]];
        v54[0] = v44;
        v54[1] = v6;
        v53[1] = NSUnderlyingErrorKey;
        v53[2] = @"Line";
        v54[2] = &off_100320320;
        void v53[3] = @"Method";
        id v45 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("deselectApplets:")];
        void v54[3] = v45;
        void v53[4] = NSDebugDescriptionErrorKey;
        id v46 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("deselectApplets:"), 444];
        void v54[4] = v46;
        id v47 = +[NSDictionary dictionaryWithObjects:v54 forKeys:v53 count:5];
        id v32 = [v15 initWithDomain:v16 code:v17 userInfo:v47];

        goto LABEL_42;
      }
      id v32 = [a1 activeApplet];
      if (!v32) {
        goto LABEL_42;
      }
      int v42 = [a1 activeApplet];
      unsigned int v43 = [v4 containsObject:v42];

      if (v43) {
        [a1 setActiveApplet:0];
      }
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v33 = NFLogGetLogger();
      if (v33)
      {
        id v34 = (void (*)(uint64_t, const char *, ...))v33;
        uint64_t v35 = object_getClass(a1);
        BOOL v36 = class_isMetaClass(v35);
        NSErrorUserInfoKey v37 = object_getClassName(a1);
        CFStringRef v52 = sel_getName("deselectApplets:");
        uint64_t v38 = 45;
        if (v36) {
          uint64_t v38 = 43;
        }
        v34(6, "%c[%{public}s %{public}s]:%i Empty array", v38, v37, v52, 437);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v39 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v40 = object_getClass(a1);
        if (class_isMetaClass(v40)) {
          int v41 = 43;
        }
        else {
          int v41 = 45;
        }
        *(_DWORD *)int buf = 67109890;
        int v56 = v41;
        __int16 v57 = 2082;
        uint64_t v58 = object_getClassName(a1);
        __int16 v59 = 2082;
        long long v60 = sel_getName("deselectApplets:");
        __int16 v61 = 1024;
        int v62 = 437;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Empty array", buf, 0x22u);
      }
    }
LABEL_36:
    id v32 = 0;
    goto LABEL_42;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v19 = NFLogGetLogger();
  if (v19)
  {
    int v20 = (void (*)(uint64_t, const char *, ...))v19;
    id v21 = object_getClass(a1);
    BOOL v22 = class_isMetaClass(v21);
    uint64_t v23 = object_getClassName(a1);
    __int16 v51 = sel_getName("deselectApplets:");
    uint64_t v24 = 45;
    if (v22) {
      uint64_t v24 = 43;
    }
    v20(3, "%c[%{public}s %{public}s]:%i Missing applets parameter", v24, v23, v51, 433);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v25 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
  {
    BOOL v26 = object_getClass(a1);
    if (class_isMetaClass(v26)) {
      int v27 = 43;
    }
    else {
      int v27 = 45;
    }
    *(_DWORD *)int buf = 67109890;
    int v56 = v27;
    __int16 v57 = 2082;
    uint64_t v58 = object_getClassName(a1);
    __int16 v59 = 2082;
    long long v60 = sel_getName("deselectApplets:");
    __int16 v61 = 1024;
    int v62 = 433;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Missing applets parameter", buf, 0x22u);
  }

  id v28 = objc_alloc((Class)NSError);
  id v29 = +[NSString stringWithUTF8String:"nfcd"];
  NSErrorUserInfoKey v65 = NSLocalizedDescriptionKey;
  int v30 = +[NSString stringWithUTF8String:"Missing Parameter"];
  __int16 v66 = v30;
  id v31 = +[NSDictionary dictionaryWithObjects:&v66 forKeys:&v65 count:1];
  id v32 = [v28 initWithDomain:v29 code:9 userInfo:v31];

LABEL_42:

  return v32;
}

id sub_100245608(void *a1)
{
  if (a1)
  {
    id v2 = NFSharedSignpostLog();
    if (os_signpost_enabled(v2))
    {
      *(_WORD *)int buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v2, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "DEACTIVATE_ALL", "deactivate all applets on eSE", buf, 2u);
    }

    id v12 = 0;
    id v3 = [a1 selectCRSWithError:&v12];
    id v4 = v12;
    uint64_t v5 = v4;
    if (v4)
    {
      id v6 = v4;
    }
    else
    {
      if (sub_1000C2FF0(a1)) {
        goto LABEL_8;
      }
      id v7 = objc_alloc((Class)NSError);
      id v8 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
      id v9 = +[NSString stringWithUTF8String:"Commmand Error"];
      id v15 = v9;
      id v10 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
      id v6 = [v7 initWithDomain:v8 code:16 userInfo:v10];

      if (!v6)
      {
LABEL_8:
        [a1 setActiveApplet:0];
        id v6 = 0;
      }
    }
  }
  else
  {
    id v6 = 0;
  }

  return v6;
}

id sub_1002457D4(void *a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v1);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(v1);
      uint64_t Name = sel_getName("deselectAllIfNeeded");
      id v8 = [v1 activeApplet];
      id v9 = [v8 identifier];
      uint64_t v10 = 45;
      if (isMetaClass) {
        uint64_t v10 = 43;
      }
      v3(6, "%c[%{public}s %{public}s]:%i eSE: activeApplet:%{public}@", v10, ClassName, Name, 479, v9);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v11 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      id v12 = object_getClass(v1);
      if (class_isMetaClass(v12)) {
        int v13 = 43;
      }
      else {
        int v13 = 45;
      }
      NSErrorUserInfoKey v14 = object_getClassName(v1);
      id v15 = sel_getName("deselectAllIfNeeded");
      id v16 = [v1 activeApplet];
      id v17 = [v16 identifier];
      *(_DWORD *)int buf = 67110146;
      int v21 = v13;
      __int16 v22 = 2082;
      uint64_t v23 = v14;
      __int16 v24 = 2082;
      id v25 = v15;
      __int16 v26 = 1024;
      int v27 = 479;
      __int16 v28 = 2114;
      id v29 = v17;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i eSE: activeApplet:%{public}@", buf, 0x2Cu);
    }
    uint64_t v18 = [v1 activeApplet];

    if (v18)
    {
      a1 = sub_100245608(v1);
    }
    else
    {
      a1 = 0;
    }
  }

  return a1;
}

id sub_100245A08(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (!a1) {
    goto LABEL_56;
  }
  id v93 = a1;
  if (v3 && [v3 count])
  {
    id v5 = v4;
    id v94 = 0;
    id v6 = [a1 selectCRSWithError:&v94];
    id v7 = v94;
    __int16 v89 = v5;
    long long v90 = v4;
    if (v7)
    {
      id v8 = v7;
      id v9 = objc_alloc((Class)NSError);
      uint64_t v10 = +[NSString stringWithUTF8String:"nfcd"];
      id v11 = [v8 code];
      *(void *)&long long v113 = NSLocalizedDescriptionKey;
      if ((uint64_t)[v8 code] > 70) {
        uint64_t v12 = 71;
      }
      else {
        uint64_t v12 = (uint64_t)[v8 code];
      }
      unint64_t v54 = +[NSString stringWithUTF8String:off_100308230[v12]];
      *(void *)int buf = v54;
      *(void *)id v112 = v8;
      *((void *)&v113 + 1) = NSUnderlyingErrorKey;
      *(void *)&long long v114 = @"Line";
      *(void *)&v112[8] = &off_100320278;
      *((void *)&v114 + 1) = @"Method";
      id v55 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_markApplicationsForDelete:")];
      *(void *)&v112[16] = v55;
      *(void *)&long long v115 = NSDebugDescriptionErrorKey;
      id v56 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_markApplicationsForDelete:"), 315];
      *(void *)&v112[24] = v56;
      __int16 v57 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v113 count:5];
      id v58 = [v9 initWithDomain:v10 code:v11 userInfo:v57];

      a1 = v93;
    }
    else
    {
      long long v115 = 0u;
      long long v116 = 0u;
      long long v113 = 0u;
      long long v114 = 0u;
      id obj = v5;
      id v27 = [obj countByEnumeratingWithState:&v113 objects:buf count:16];
      if (v27)
      {
        id v28 = v27;
        id v29 = 0;
        uint64_t v30 = *(void *)v114;
        do
        {
          id v31 = 0;
          id v91 = v28;
          do
          {
            if (*(void *)v114 != v30) {
              objc_enumerationMutation(obj);
            }
            id v32 = *(void **)(*((void *)&v113 + 1) + 8 * (void)v31);
            if ((sub_1000C41C4((uint64_t)a1, v32) & 1) == 0)
            {
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t Logger = NFLogGetLogger();
              if (Logger)
              {
                id v34 = (void (*)(uint64_t, const char *, ...))Logger;
                Class = object_getClass(v93);
                BOOL isMetaClass = class_isMetaClass(Class);
                Classuint64_t Name = object_getClassName(v93);
                uint64_t Name = sel_getName("_markApplicationsForDelete:");
                uint64_t v39 = [v32 identifier];
                uint64_t v40 = 45;
                if (isMetaClass) {
                  uint64_t v40 = 43;
                }
                v34(3, "%c[%{public}s %{public}s]:%i Failed to mark application for delete: %{public}@", v40, ClassName, Name, 320, v39);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              int v41 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
              {
                int v42 = object_getClass(v93);
                if (class_isMetaClass(v42)) {
                  int v43 = 43;
                }
                else {
                  int v43 = 45;
                }
                id v44 = object_getClassName(v93);
                id v45 = sel_getName("_markApplicationsForDelete:");
                id v46 = [v32 identifier];
                *(_DWORD *)int v101 = 67110146;
                int v102 = v43;
                __int16 v103 = 2082;
                __int16 v104 = v44;
                __int16 v105 = 2082;
                __int16 v106 = v45;
                __int16 v107 = 1024;
                int v108 = 320;
                __int16 v109 = 2114;
                __int16 v110 = v46;
                _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to mark application for delete: %{public}@", v101, 0x2Cu);
              }
              id v47 = objc_alloc((Class)NSError);
              id v48 = +[NSString stringWithUTF8String:"nfcd"];
              v99[0] = NSLocalizedDescriptionKey;
              id v49 = +[NSString stringWithUTF8String:"Commmand Error"];
              v100[0] = v49;
              v100[1] = &off_100320290;
              v99[1] = @"Line";
              v99[2] = @"Method";
              id v50 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_markApplicationsForDelete:")];
              v100[2] = v50;
              v99[3] = NSDebugDescriptionErrorKey;
              id v51 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_markApplicationsForDelete:"), 321];
              v100[3] = v51;
              CFStringRef v52 = +[NSDictionary dictionaryWithObjects:v100 forKeys:v99 count:4];
              id v53 = [v47 initWithDomain:v48 code:16 userInfo:v52];

              id v29 = v53;
              a1 = v93;
              id v28 = v91;
            }
            id v31 = (char *)v31 + 1;
          }
          while (v28 != v31);
          id v28 = [obj countByEnumeratingWithState:&v113 objects:buf count:16];
        }
        while (v28);
      }
      else
      {
        id v29 = 0;
      }

      id v59 = sub_10024379C(a1);
      id v60 = [a1 refreshISDCounter];
      [a1 setActiveApplet:0];
      id v8 = v29;
      id v58 = v8;
    }

    id v4 = v90;
    if (v58)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v61 = NFLogGetLogger();
      if (v61)
      {
        int v62 = (void (*)(uint64_t, const char *, ...))v61;
        __int16 v63 = object_getClass(a1);
        BOOL v64 = class_isMetaClass(v63);
        char v86 = object_getClassName(a1);
        char v88 = sel_getName("deleteApplets:");
        uint64_t v65 = 45;
        if (v64) {
          uint64_t v65 = 43;
        }
        a1 = v93;
        v62(3, "%c[%{public}s %{public}s]:%i Failed to Mark For Delete : %@", v65, v86, v88, 495, v58);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v66 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
      {
        __int16 v67 = object_getClass(a1);
        if (class_isMetaClass(v67)) {
          int v68 = 43;
        }
        else {
          int v68 = 45;
        }
        id v69 = object_getClassName(a1);
        __int16 v70 = sel_getName("deleteApplets:");
        *(_DWORD *)int buf = 67110146;
        *(_DWORD *)&uint8_t buf[4] = v68;
        *(_WORD *)id v112 = 2082;
        *(void *)&v112[2] = v69;
        *(_WORD *)&v112[10] = 2082;
        *(void *)&v112[12] = v70;
        *(_WORD *)&v112[20] = 1024;
        *(_DWORD *)&v112[22] = 495;
        *(_WORD *)&v112[26] = 2112;
        *(void *)&v112[28] = v58;
        _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to Mark For Delete : %@", buf, 0x2Cu);
      }

      id v71 = objc_alloc((Class)NSError);
      __int16 v72 = +[NSString stringWithUTF8String:"nfcd"];
      id v73 = [v58 code];
      v95[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[v58 code] > 70) {
        uint64_t v74 = 71;
      }
      else {
        uint64_t v74 = (uint64_t)[v58 code];
      }
      uint64_t v80 = +[NSString stringWithUTF8String:off_100308230[v74]];
      v96[0] = v80;
      v96[1] = v58;
      v95[1] = NSUnderlyingErrorKey;
      v95[2] = @"Line";
      v96[2] = &off_100320338;
      v95[3] = @"Method";
      id v81 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("deleteApplets:")];
      v96[3] = v81;
      void v95[4] = NSDebugDescriptionErrorKey;
      id v82 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("deleteApplets:"), 496];
      void v96[4] = v82;
      id v83 = +[NSDictionary dictionaryWithObjects:v96 forKeys:v95 count:5];
      id v26 = [v71 initWithDomain:v72 code:v73 userInfo:v83];

      id v4 = v90;
      goto LABEL_59;
    }
    uint64_t v75 = [a1 activeApplet];
    if (v75)
    {
      __int16 v76 = (void *)v75;
      int v77 = a1;
      __int16 v78 = [a1 activeApplet];
      unsigned int v79 = [v89 containsObject:v78];

      if (v79) {
        [v77 setActiveApplet:0];
      }
    }
    +[NFGeneralStatisticsCALogger updateGeneralDeviceStatistic:&off_100323848];
LABEL_56:
    id v26 = 0;
    goto LABEL_59;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v13 = NFLogGetLogger();
  if (v13)
  {
    NSErrorUserInfoKey v14 = (void (*)(uint64_t, const char *, ...))v13;
    id v15 = object_getClass(a1);
    BOOL v16 = class_isMetaClass(v15);
    id v17 = object_getClassName(a1);
    char v87 = sel_getName("deleteApplets:");
    uint64_t v18 = 45;
    if (v16) {
      uint64_t v18 = 43;
    }
    int v85 = v17;
    a1 = v93;
    v14(3, "%c[%{public}s %{public}s]:%i Missing applet parameter", v18, v85, v87, 489);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v19 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    int v20 = object_getClass(a1);
    if (class_isMetaClass(v20)) {
      int v21 = 43;
    }
    else {
      int v21 = 45;
    }
    *(_DWORD *)int buf = 67109890;
    *(_DWORD *)&uint8_t buf[4] = v21;
    *(_WORD *)id v112 = 2082;
    *(void *)&v112[2] = object_getClassName(a1);
    *(_WORD *)&v112[10] = 2082;
    *(void *)&v112[12] = sel_getName("deleteApplets:");
    *(_WORD *)&v112[20] = 1024;
    *(_DWORD *)&v112[22] = 489;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Missing applet parameter", buf, 0x22u);
  }

  id v22 = objc_alloc((Class)NSError);
  uint64_t v23 = +[NSString stringWithUTF8String:"nfcd"];
  NSErrorUserInfoKey v97 = NSLocalizedDescriptionKey;
  __int16 v24 = +[NSString stringWithUTF8String:"Missing Parameter"];
  uint64_t v98 = v24;
  id v25 = +[NSDictionary dictionaryWithObjects:&v98 forKeys:&v97 count:1];
  id v26 = [v22 initWithDomain:v23 code:9 userInfo:v25];

LABEL_59:

  return v26;
}

id sub_100246538(id a1, void *a2, void *a3)
{
  id v5 = a2;
  id v38 = a3;
  if (a1)
  {
    id v6 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002845F9 length:12];
    id v43 = 0;
    id v7 = [a1 selectByName:v6 error:&v43];
    id v8 = v43;

    id v9 = v7;
    id v37 = v8;
    if ([v7 status] == 26277)
    {
      id v10 = objc_alloc((Class)NSError);
      uint64_t v11 = +[NSString stringWithUTF8String:"nfcd"];
      v51[0] = NSLocalizedDescriptionKey;
      uint64_t v12 = +[NSString stringWithUTF8String:"Restricted Mode"];
      v52[0] = v12;
      v52[1] = &off_100320368;
      v51[1] = @"Line";
      v51[2] = @"Method";
      id v13 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queryAppletExtraInfo:outInfo:")];
      v52[2] = v13;
      v51[3] = NSDebugDescriptionErrorKey;
      NSErrorUserInfoKey v14 = (void *)v11;
      id v15 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("queryAppletExtraInfo:outInfo:"), 533];
      v52[3] = v15;
      id v16 = +[NSDictionary dictionaryWithObjects:v52 forKeys:v51 count:4];
      id v17 = v10;
      uint64_t v18 = (void *)v11;
      uint64_t v19 = 24;
    }
    else if (v8)
    {
      id v20 = objc_alloc((Class)NSError);
      NSErrorUserInfoKey v14 = +[NSString stringWithUTF8String:"nfcd"];
      id v21 = [v8 code];
      v49[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[v8 code] > 70) {
        uint64_t v22 = 71;
      }
      else {
        uint64_t v22 = (uint64_t)[v8 code];
      }
      uint64_t v12 = +[NSString stringWithUTF8String:off_100308230[v22]];
      v50[0] = v12;
      v50[1] = v8;
      v49[1] = NSUnderlyingErrorKey;
      v49[2] = @"Line";
      v50[2] = &off_100320380;
      v49[3] = @"Method";
      id v13 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queryAppletExtraInfo:outInfo:")];
      v50[3] = v13;
      v49[4] = NSDebugDescriptionErrorKey;
      id v15 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("queryAppletExtraInfo:outInfo:"), 536];
      void v50[4] = v15;
      id v16 = +[NSDictionary dictionaryWithObjects:v50 forKeys:v49 count:5];
      id v17 = v20;
      uint64_t v18 = v14;
      uint64_t v19 = (uint64_t)v21;
    }
    else
    {
      if (sub_100189DC8((BOOL)a1))
      {
        NSErrorUserInfoKey v14 = sub_100189EE8(a1, 1);
        if ([v14 count])
        {
          uint64_t v12 = [v14 objectForKeyedSubscript:@"containers"];
          long long v39 = 0u;
          long long v40 = 0u;
          long long v41 = 0u;
          long long v42 = 0u;
          id v23 = [v12 countByEnumeratingWithState:&v39 objects:v44 count:16];
          if (v23)
          {
            id v24 = v23;
            uint64_t v35 = v14;
            BOOL v36 = v9;
            uint64_t v25 = *(void *)v40;
            do
            {
              for (i = 0; i != v24; i = (char *)i + 1)
              {
                if (*(void *)v40 != v25) {
                  objc_enumerationMutation(v12);
                }
                id v27 = *(void **)(*((void *)&v39 + 1) + 8 * i);
                id v28 = [v27 objectForKeyedSubscript:@"appletAid"];
                if (v28)
                {
                  id v29 = +[NSData NF_dataWithHexString:v28];
                  if (v29 && [v5 containsObject:v29]) {
                    [v38 addObject:v27];
                  }
                }
              }
              id v24 = [v12 countByEnumeratingWithState:&v39 objects:v44 count:16];
            }
            while (v24);
            a1 = 0;
            id v9 = v36;
            id v8 = v37;
            NSErrorUserInfoKey v14 = v35;
          }
          else
          {
            a1 = 0;
          }
          goto LABEL_27;
        }
        id v33 = objc_alloc((Class)NSError);
        uint64_t v12 = +[NSString stringWithUTF8String:"nfcd"];
        v45[0] = NSLocalizedDescriptionKey;
        id v13 = +[NSString stringWithUTF8String:"Commmand Error"];
        v46[0] = v13;
        v46[1] = &off_1003203B0;
        v45[1] = @"Line";
        v45[2] = @"Method";
        id v15 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queryAppletExtraInfo:outInfo:")];
        v46[2] = v15;
        v45[3] = NSDebugDescriptionErrorKey;
        id v16 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("queryAppletExtraInfo:outInfo:"), 545];
        v46[3] = v16;
        id v34 = +[NSDictionary dictionaryWithObjects:v46 forKeys:v45 count:4];
        a1 = [v33 initWithDomain:v12 code:16 userInfo:v34];

LABEL_26:
        id v8 = v37;
LABEL_27:

        goto LABEL_28;
      }
      id v30 = objc_alloc((Class)NSError);
      uint64_t v31 = +[NSString stringWithUTF8String:"nfcd"];
      v47[0] = NSLocalizedDescriptionKey;
      uint64_t v12 = +[NSString stringWithUTF8String:"Feature Not Supported"];
      v48[0] = v12;
      v48[1] = &off_100320398;
      v47[1] = @"Line";
      v47[2] = @"Method";
      id v13 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queryAppletExtraInfo:outInfo:")];
      v48[2] = v13;
      v47[3] = NSDebugDescriptionErrorKey;
      NSErrorUserInfoKey v14 = (void *)v31;
      id v15 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("queryAppletExtraInfo:outInfo:"), 540];
      v48[3] = v15;
      id v16 = +[NSDictionary dictionaryWithObjects:v48 forKeys:v47 count:4];
      id v17 = v30;
      uint64_t v18 = (void *)v31;
      uint64_t v19 = 14;
    }
    a1 = [v17 initWithDomain:v18 code:v19 userInfo:v16];
    goto LABEL_26;
  }
LABEL_28:

  return a1;
}

void sub_100246C78(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v4 = +[NFTLV TLVSsWithBytes:a2 length:a3 requireDefiniteEncoding:1];
  long long v26 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v29 = 0u;
  id v5 = [v4 countByEnumeratingWithState:&v26 objects:v38 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v27;
    do
    {
      for (i = 0; i != v6; i = (char *)i + 1)
      {
        if (*(void *)v27 != v7) {
          objc_enumerationMutation(v4);
        }
        id v9 = *(void **)(*((void *)&v26 + 1) + 8 * i);
        id v10 = [v9 childWithTag:218];
        if (v10)
        {
          uint64_t v11 = [v9 childWithTag:79];
          if (v11)
          {
            uint64_t v12 = [v10 value];
            id v13 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
            NSErrorUserInfoKey v14 = [v11 value];
            [v13 setObject:v12 forKeyedSubscript:v14];
          }
          else
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t Logger = NFLogGetLogger();
            if (Logger)
            {
              id v16 = (void (*)(uint64_t, const char *, ...))Logger;
              Class = object_getClass(*(id *)(a1 + 32));
              BOOL isMetaClass = class_isMetaClass(Class);
              Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
              uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
              uint64_t v20 = 45;
              if (isMetaClass) {
                uint64_t v20 = 43;
              }
              v16(3, "%c[%{public}s %{public}s]:%i Missing AID tag", v20, ClassName, Name, 588);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v12 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
            {
              id v21 = object_getClass(*(id *)(a1 + 32));
              if (class_isMetaClass(v21)) {
                int v22 = 43;
              }
              else {
                int v22 = 45;
              }
              id v23 = object_getClassName(*(id *)(a1 + 32));
              id v24 = sel_getName(*(SEL *)(a1 + 48));
              *(_DWORD *)int buf = 67109890;
              int v31 = v22;
              __int16 v32 = 2082;
              id v33 = v23;
              __int16 v34 = 2082;
              uint64_t v35 = v24;
              __int16 v36 = 1024;
              int v37 = 588;
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Missing AID tag", buf, 0x22u);
            }
          }
        }
      }
      id v6 = [v4 countByEnumeratingWithState:&v26 objects:v38 count:16];
    }
    while (v6);
  }
}

id sub_100246F2C(void *a1, void *a2)
{
  if (a1)
  {
    if (a2)
    {
      id v4 = [a1 cachedAppletsUnfiltered];

      if (v4)
      {
        [a1 cachedAppletsUnfiltered];
        id v5 = 0;
        *a2 = (id)objc_claimAutoreleasedReturnValue();
      }
      else
      {
        id v35 = 0;
        uint64_t v11 = sub_10024194C(a1, &v35, 0);
        id v12 = v35;
        id v13 = v12;
        if (v11)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t Logger = NFLogGetLogger();
          if (Logger)
          {
            id v15 = (void (*)(uint64_t, const char *, ...))Logger;
            Class = object_getClass(a1);
            BOOL isMetaClass = class_isMetaClass(Class);
            Classuint64_t Name = object_getClassName(a1);
            uint64_t Name = sel_getName("getUnfilteredApplets:");
            uint64_t v18 = 45;
            if (isMetaClass) {
              uint64_t v18 = 43;
            }
            v15(3, "%c[%{public}s %{public}s]:%i Error getting applications : %@", v18, ClassName, Name, 623, v11);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v19 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
          {
            uint64_t v20 = object_getClass(a1);
            if (class_isMetaClass(v20)) {
              int v21 = 43;
            }
            else {
              int v21 = 45;
            }
            int v22 = object_getClassName(a1);
            id v23 = sel_getName("getUnfilteredApplets:");
            *(_DWORD *)int buf = 67110146;
            int v39 = v21;
            __int16 v40 = 2082;
            long long v41 = v22;
            __int16 v42 = 2082;
            id v43 = v23;
            __int16 v44 = 1024;
            int v45 = 623;
            __int16 v46 = 2112;
            id v47 = v11;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error getting applications : %@", buf, 0x2Cu);
          }

          id v24 = objc_alloc((Class)NSError);
          uint64_t v25 = +[NSString stringWithUTF8String:"nfcd"];
          id v26 = [v11 code];
          v36[0] = NSLocalizedDescriptionKey;
          if ((uint64_t)[v11 code] > 70) {
            uint64_t v27 = 71;
          }
          else {
            uint64_t v27 = (uint64_t)[v11 code];
          }
          long long v28 = +[NSString stringWithUTF8String:off_100308230[v27]];
          v37[0] = v28;
          v37[1] = v11;
          v36[1] = NSUnderlyingErrorKey;
          v36[2] = @"Line";
          v37[2] = &off_1003203C8;
          v36[3] = @"Method";
          id v29 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("getUnfilteredApplets:")];
          v37[3] = v29;
          v36[4] = NSDebugDescriptionErrorKey;
          id v30 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", @"getUnfilteredApplets:", 624];
          v37[4] = v30;
          int v31 = +[NSDictionary dictionaryWithObjects:v37 forKeys:v36 count:5];
          id v5 = [v24 initWithDomain:v25 code:v26 userInfo:v31];
        }
        else
        {
          id v5 = 0;
          if (v12) {
            *a2 = v12;
          }
        }
      }
    }
    else
    {
      id v6 = objc_alloc((Class)NSError);
      uint64_t v7 = +[NSString stringWithUTF8String:"nfcd"];
      v48[0] = NSLocalizedDescriptionKey;
      id v8 = +[NSString stringWithUTF8String:"Invalid Parameter"];
      v49[0] = v8;
      v48[1] = NSLocalizedFailureReasonErrorKey;
      id v9 = [objc_alloc((Class)NSString) initWithFormat:@"Nil outparam"];
      v49[1] = v9;
      id v10 = +[NSDictionary dictionaryWithObjects:v49 forKeys:v48 count:2];
      id v5 = [v6 initWithDomain:v7 code:10 userInfo:v10];
    }
  }
  else
  {
    id v5 = 0;
  }

  return v5;
}

id sub_1002473C8(void *a1, void *a2)
{
  if (a1)
  {
    a1 = sub_1002473FC(a1, a2, 1);
    uint64_t v2 = vars8;
  }
  return a1;
}

id sub_1002473FC(void *a1, void *a2, char a3)
{
  id v5 = a2;
  id v6 = v5;
  id v7 = 0;
  if (a1 && v5)
  {
    if (a3)
    {
      uint64_t v25 = 0;
      id v8 = (id *)&v25;
      uint64_t v9 = sub_100243D60(a1, &v25);
    }
    else
    {
      uint64_t v24 = 0;
      id v8 = (id *)&v24;
      uint64_t v9 = sub_100246F2C(a1, &v24);
    }
    id v10 = (void *)v9;
    id v11 = *v8;
    id v12 = v11;
    if (v10)
    {
      id v7 = 0;
    }
    else
    {
      long long v22 = 0u;
      long long v23 = 0u;
      long long v20 = 0u;
      long long v21 = 0u;
      id v13 = v11;
      id v7 = [v13 countByEnumeratingWithState:&v20 objects:v26 count:16];
      if (v7)
      {
        uint64_t v14 = *(void *)v21;
        while (2)
        {
          for (i = 0; i != v7; i = (char *)i + 1)
          {
            if (*(void *)v21 != v14) {
              objc_enumerationMutation(v13);
            }
            id v16 = *(void **)(*((void *)&v20 + 1) + 8 * i);
            id v17 = [v16 identifier:v20];
            unsigned __int8 v18 = [v6 isEqualToString:v17];

            if (v18)
            {
              id v7 = v16;
              goto LABEL_18;
            }
          }
          id v7 = [v13 countByEnumeratingWithState:&v20 objects:v26 count:16];
          if (v7) {
            continue;
          }
          break;
        }
      }
LABEL_18:
    }
  }

  return v7;
}

id sub_1002475B4(void *a1, uint64_t a2)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(a1);
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(a1);
    uint64_t Name = sel_getName("_setTemporaryVisibilityOnAllEndpointsOfSelectedApplet:");
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v5(6, "%c[%{public}s %{public}s]:%i visible=%d", v8, ClassName, Name, 697, a2);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    id v10 = object_getClass(a1);
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    *(_DWORD *)int buf = 67110146;
    int v117 = v11;
    __int16 v118 = 2082;
    id v119 = object_getClassName(a1);
    __int16 v120 = 2082;
    long long v121 = sel_getName("_setTemporaryVisibilityOnAllEndpointsOfSelectedApplet:");
    __int16 v122 = 1024;
    int v123 = 697;
    __int16 v124 = 1024;
    int v125 = a2;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i visible=%d", buf, 0x28u);
  }

  id v12 = +[NFTLV TLVWithTag:131 unsignedChar:a2];
  id v13 = [v12 asData];
  id v99 = 0;
  uint64_t v14 = [a1 sendCommandWithClass:128 instruction:52 p1:0 p2:0 data:v13 error:&v99];
  id v15 = v99;

  uint64_t v98 = v14;
  if (v14)
  {
    if ([v14 status] == 36864)
    {
      id v16 = 0;
      goto LABEL_53;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v32 = NFLogGetLogger();
    if (v32)
    {
      id v33 = (void (*)(uint64_t, const char *, ...))v32;
      __int16 v34 = object_getClass(a1);
      BOOL v35 = class_isMetaClass(v34);
      __int16 v36 = object_getClassName(a1);
      int v37 = sel_getName("_setTemporaryVisibilityOnAllEndpointsOfSelectedApplet:");
      uint64_t v92 = [v98 status];
      id v91 = v37;
      uint64_t v14 = v98;
      uint64_t v38 = 45;
      if (v35) {
        uint64_t v38 = 43;
      }
      v33(3, "%c[%{public}s %{public}s]:%i Returned error: 0x%04x", v38, v36, v91, 720, v92);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v39 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      __int16 v40 = object_getClass(a1);
      long long v41 = v12;
      if (class_isMetaClass(v40)) {
        int v42 = 43;
      }
      else {
        int v42 = 45;
      }
      id v43 = object_getClassName(a1);
      __int16 v44 = sel_getName("_setTemporaryVisibilityOnAllEndpointsOfSelectedApplet:");
      unsigned int v45 = [v14 status];
      *(_DWORD *)int buf = 67110146;
      int v117 = v42;
      id v12 = v41;
      __int16 v118 = 2082;
      id v119 = v43;
      __int16 v120 = 2082;
      long long v121 = v44;
      __int16 v122 = 1024;
      int v123 = 720;
      __int16 v124 = 1024;
      int v125 = v45;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Returned error: 0x%04x", buf, 0x28u);
    }

    if ([v14 status] != 26880)
    {
      __int16 v46 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Non-90000 response. Response: 0x%04X", [v14 status]);
      sub_1001990A4((uint64_t)NFBugCapture, @"Failed to set instance visibility", v46, &off_100323898);
    }
    unsigned int v47 = [v14 status];
    id v48 = objc_alloc((Class)NSError);
    id v49 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v97 = v12;
    unsigned int v95 = v47;
    if (v15)
    {
      id v93 = v48;
      id v50 = [v15 code];
      v106[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[v15 code] > 70) {
        uint64_t v51 = 71;
      }
      else {
        uint64_t v51 = (uint64_t)[v15 code];
      }
      unsigned int v79 = +[NSString stringWithUTF8String:off_100308230[v51]];
      v107[0] = v79;
      v107[1] = v15;
      v106[1] = NSUnderlyingErrorKey;
      v106[2] = @"Line";
      v107[2] = &off_100320458;
      v106[3] = @"Method";
      id v80 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_setTemporaryVisibilityOnAllEndpointsOfSelectedApplet:")];
      v107[3] = v80;
      v106[4] = NSDebugDescriptionErrorKey;
      id v81 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_setTemporaryVisibilityOnAllEndpointsOfSelectedApplet:"), 730];
      v107[4] = v81;
      id v82 = +[NSDictionary dictionaryWithObjects:v107 forKeys:v106 count:5];
      id v83 = [v93 initWithDomain:v49 code:v50 userInfo:v82];
      +[NFExceptionsCALogger postAnalyticsContactlessErrorsEvent:0 status:v95 error:v83];

      id v84 = objc_alloc((Class)NSError);
      id v58 = +[NSString stringWithUTF8String:"nfcd"];
      id v85 = [v15 code];
      v102[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[v15 code] > 70) {
        uint64_t v86 = 71;
      }
      else {
        uint64_t v86 = (uint64_t)[v15 code];
      }
      id v59 = +[NSString stringWithUTF8String:off_100308230[v86]];
      v103[0] = v59;
      v103[1] = v15;
      v102[1] = NSUnderlyingErrorKey;
      v102[2] = @"Line";
      v103[2] = &off_100320488;
      v102[3] = @"Method";
      id v60 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_setTemporaryVisibilityOnAllEndpointsOfSelectedApplet:")];
      v103[3] = v60;
      void v102[4] = NSDebugDescriptionErrorKey;
      id v61 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_setTemporaryVisibilityOnAllEndpointsOfSelectedApplet:"), 732];
      v103[4] = v61;
      int v62 = +[NSDictionary dictionaryWithObjects:v103 forKeys:v102 count:5];
      __int16 v63 = v84;
      int v77 = v58;
      uint64_t v78 = (uint64_t)v85;
      goto LABEL_52;
    }
    v104[0] = NSLocalizedDescriptionKey;
    id v71 = +[NSString stringWithUTF8String:"Commmand Error"];
    v105[0] = v71;
    v105[1] = &off_100320470;
    v104[1] = @"Line";
    v104[2] = @"Method";
    id v72 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_setTemporaryVisibilityOnAllEndpointsOfSelectedApplet:")];
    v105[2] = v72;
    v104[3] = NSDebugDescriptionErrorKey;
    id v73 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_setTemporaryVisibilityOnAllEndpointsOfSelectedApplet:"), 731];
    v105[3] = v73;
    uint64_t v74 = +[NSDictionary dictionaryWithObjects:v105 forKeys:v104 count:4];
    id v75 = [v48 initWithDomain:v49 code:16 userInfo:v74];
    +[NFExceptionsCALogger postAnalyticsContactlessErrorsEvent:0 status:v95 error:v75];

    id v76 = objc_alloc((Class)NSError);
    id v58 = +[NSString stringWithUTF8String:"nfcd"];
    v100[0] = NSLocalizedDescriptionKey;
    id v59 = +[NSString stringWithUTF8String:"Commmand Error"];
    v101[0] = v59;
    v101[1] = &off_100320488;
    v100[1] = @"Line";
    v100[2] = @"Method";
    id v60 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_setTemporaryVisibilityOnAllEndpointsOfSelectedApplet:")];
    v101[2] = v60;
    v100[3] = NSDebugDescriptionErrorKey;
    id v61 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_setTemporaryVisibilityOnAllEndpointsOfSelectedApplet:"), 732];
    v101[3] = v61;
    int v62 = +[NSDictionary dictionaryWithObjects:v101 forKeys:v100 count:4];
    __int16 v63 = v76;
  }
  else
  {
    NSErrorUserInfoKey v97 = v12;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v17 = NFLogGetLogger();
    if (v17)
    {
      unsigned __int8 v18 = (void (*)(uint64_t, const char *, ...))v17;
      uint64_t v19 = object_getClass(a1);
      BOOL v20 = class_isMetaClass(v19);
      long long v21 = object_getClassName(a1);
      long long v90 = sel_getName("_setTemporaryVisibilityOnAllEndpointsOfSelectedApplet:");
      uint64_t v22 = 45;
      if (v20) {
        uint64_t v22 = 43;
      }
      v18(3, "%c[%{public}s %{public}s]:%i Command (%02X) failed; error: %{public}@", v22, v21, v90, 709, 52, v15);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    long long v23 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      uint64_t v24 = object_getClass(a1);
      if (class_isMetaClass(v24)) {
        int v25 = 43;
      }
      else {
        int v25 = 45;
      }
      id v26 = object_getClassName(a1);
      uint64_t v27 = sel_getName("_setTemporaryVisibilityOnAllEndpointsOfSelectedApplet:");
      *(_DWORD *)int buf = 67110402;
      int v117 = v25;
      __int16 v118 = 2082;
      id v119 = v26;
      __int16 v120 = 2082;
      long long v121 = v27;
      __int16 v122 = 1024;
      int v123 = 709;
      __int16 v124 = 1024;
      int v125 = 52;
      __int16 v126 = 2114;
      id v127 = v15;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Command (%02X) failed; error: %{public}@",
        buf,
        0x32u);
    }

    sub_1001990A4((uint64_t)NFBugCapture, @"Failed to set instance visibility", @"No Response from SE", &off_100323870);
    id v28 = objc_alloc((Class)NSError);
    id v29 = +[NSString stringWithUTF8String:"nfcd"];
    if (v15)
    {
      id v94 = v28;
      id v30 = [v15 code];
      v114[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[v15 code] > 70) {
        uint64_t v31 = 71;
      }
      else {
        uint64_t v31 = (uint64_t)[v15 code];
      }
      BOOL v64 = +[NSString stringWithUTF8String:off_100308230[v31]];
      v115[0] = v64;
      v115[1] = v15;
      v114[1] = NSUnderlyingErrorKey;
      v114[2] = @"Line";
      v115[2] = &off_100320410;
      void v114[3] = @"Method";
      id v65 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_setTemporaryVisibilityOnAllEndpointsOfSelectedApplet:")];
      v115[3] = v65;
      v114[4] = NSDebugDescriptionErrorKey;
      id v66 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_setTemporaryVisibilityOnAllEndpointsOfSelectedApplet:"), 715];
      void v115[4] = v66;
      __int16 v67 = +[NSDictionary dictionaryWithObjects:v115 forKeys:v114 count:5];
      id v68 = [v94 initWithDomain:v29 code:v30 userInfo:v67];
      +[NFExceptionsCALogger postAnalyticsContactlessErrorsEvent:0 status:0 error:v68];

      id v96 = objc_alloc((Class)NSError);
      id v58 = +[NSString stringWithUTF8String:"nfcd"];
      id v69 = [v15 code];
      v110[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[v15 code] > 70) {
        uint64_t v70 = 71;
      }
      else {
        uint64_t v70 = (uint64_t)[v15 code];
      }
      id v59 = +[NSString stringWithUTF8String:off_100308230[v70]];
      v111[0] = v59;
      v111[1] = v15;
      v110[1] = NSUnderlyingErrorKey;
      v110[2] = @"Line";
      v111[2] = &off_100320440;
      v110[3] = @"Method";
      id v60 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_setTemporaryVisibilityOnAllEndpointsOfSelectedApplet:")];
      v111[3] = v60;
      v110[4] = NSDebugDescriptionErrorKey;
      id v61 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_setTemporaryVisibilityOnAllEndpointsOfSelectedApplet:"), 717];
      v111[4] = v61;
      int v62 = +[NSDictionary dictionaryWithObjects:v111 forKeys:v110 count:5];
      __int16 v63 = v96;
      int v77 = v58;
      uint64_t v78 = (uint64_t)v69;
      goto LABEL_52;
    }
    v112[0] = NSLocalizedDescriptionKey;
    CFStringRef v52 = +[NSString stringWithUTF8String:"Commmand Error"];
    v113[0] = v52;
    v113[1] = &off_100320428;
    v112[1] = @"Line";
    v112[2] = @"Method";
    id v53 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_setTemporaryVisibilityOnAllEndpointsOfSelectedApplet:")];
    v113[2] = v53;
    v112[3] = NSDebugDescriptionErrorKey;
    id v54 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_setTemporaryVisibilityOnAllEndpointsOfSelectedApplet:"), 716];
    void v113[3] = v54;
    id v55 = +[NSDictionary dictionaryWithObjects:v113 forKeys:v112 count:4];
    id v56 = [v28 initWithDomain:v29 code:16 userInfo:v55];
    +[NFExceptionsCALogger postAnalyticsContactlessErrorsEvent:0 status:0 error:v56];

    id v57 = objc_alloc((Class)NSError);
    id v58 = +[NSString stringWithUTF8String:"nfcd"];
    v108[0] = NSLocalizedDescriptionKey;
    id v59 = +[NSString stringWithUTF8String:"Commmand Error"];
    v109[0] = v59;
    v109[1] = &off_100320440;
    v108[1] = @"Line";
    v108[2] = @"Method";
    id v60 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_setTemporaryVisibilityOnAllEndpointsOfSelectedApplet:")];
    v109[2] = v60;
    v108[3] = NSDebugDescriptionErrorKey;
    id v61 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_setTemporaryVisibilityOnAllEndpointsOfSelectedApplet:"), 717];
    v109[3] = v61;
    int v62 = +[NSDictionary dictionaryWithObjects:v109 forKeys:v108 count:4];
    __int16 v63 = v57;
  }
  int v77 = v58;
  uint64_t v78 = 16;
LABEL_52:
  id v16 = [v63 initWithDomain:v77 code:v78 userInfo:v62];

  id v12 = v97;
LABEL_53:

  return v16;
}

id sub_100248584(void *a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v7 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(a1);
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(a1);
    uint64_t Name = sel_getName("_setupEndpoint:activate:");
    if (a3) {
      CFStringRef v12 = &stru_100309C40;
    }
    else {
      CFStringRef v12 = @"de";
    }
    CFStringRef v101 = v12;
    uint64_t v13 = 43;
    if (!isMetaClass) {
      uint64_t v13 = 45;
    }
    v7(6, "%c[%{public}s %{public}s]:%i %{public}@ %{public}@activation for endpoint %{public}@", v13, ClassName, Name, 739, @"temporary", v101, v5);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v14 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    id v15 = object_getClass(a1);
    id v16 = v5;
    if (class_isMetaClass(v15)) {
      int v17 = 43;
    }
    else {
      int v17 = 45;
    }
    unsigned __int8 v18 = object_getClassName(a1);
    uint64_t v19 = sel_getName("_setupEndpoint:activate:");
    *(_DWORD *)int buf = 67110658;
    if (a3) {
      CFStringRef v20 = &stru_100309C40;
    }
    else {
      CFStringRef v20 = @"de";
    }
    int v126 = v17;
    id v5 = v16;
    __int16 v127 = 2082;
    int v128 = v18;
    __int16 v129 = 2082;
    unint64_t v130 = v19;
    __int16 v131 = 1024;
    int v132 = 739;
    __int16 v133 = 2114;
    *(void *)int v134 = @"temporary";
    *(_WORD *)&v134[8] = 2114;
    *(void *)&v134[10] = v20;
    __int16 v135 = 2114;
    id v136 = v16;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@ %{public}@activation for endpoint %{public}@", buf, 0x40u);
  }

  long long v21 = +[NSData NF_dataWithHexString:v5];
  id v22 = [objc_alloc((Class)NSMutableData) initWithCapacity:[v21 length] + 7];
  long long v23 = +[NFTLV TLVWithTag:80 value:v21];
  uint64_t v24 = [v23 asData];
  [v22 appendData:v24];

  int v25 = +[NFTLV TLVWithTag:131 unsignedChar:a3];

  __int16 v107 = v25;
  id v26 = [v25 asData];
  [v22 appendData:v26];

  id v108 = 0;
  uint64_t v27 = [a1 sendCommandWithClass:128 instruction:126 p1:0 p2:0 data:v22 error:&v108];
  id v28 = v108;
  if (v27)
  {
    if ([v27 status] == 36864)
    {
      id v29 = 0;
      goto LABEL_63;
    }
    id v103 = v22;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v46 = NFLogGetLogger();
    if (v46)
    {
      unsigned int v47 = (void (*)(uint64_t, const char *, ...))v46;
      id v48 = object_getClass(a1);
      BOOL v49 = class_isMetaClass(v48);
      id v50 = object_getClassName(a1);
      uint64_t v51 = sel_getName("_setupEndpoint:activate:");
      uint64_t v100 = [v27 status];
      uint64_t v52 = 45;
      if (v49) {
        uint64_t v52 = 43;
      }
      v47(3, "%c[%{public}s %{public}s]:%i Returned error: 0x%04x", v52, v50, v51, 771, v100);
    }
    __int16 v104 = v21;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v53 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
    {
      id v54 = object_getClass(a1);
      if (class_isMetaClass(v54)) {
        int v55 = 43;
      }
      else {
        int v55 = 45;
      }
      id v56 = object_getClassName(a1);
      id v57 = sel_getName("_setupEndpoint:activate:");
      unsigned int v58 = [v27 status];
      *(_DWORD *)int buf = 67110146;
      int v126 = v55;
      __int16 v127 = 2082;
      int v128 = v56;
      __int16 v129 = 2082;
      unint64_t v130 = v57;
      __int16 v131 = 1024;
      int v132 = 771;
      __int16 v133 = 1024;
      *(_DWORD *)int v134 = v58;
      _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Returned error: 0x%04x", buf, 0x28u);
    }

    __int16 v106 = v27;
    if ([v27 status] != 26880)
    {
      unsigned int v102 = [v27 status];
      id v59 = objc_alloc((Class)NSError);
      id v60 = +[NSString stringWithUTF8String:"nfcd"];
      if (v28)
      {
        id v61 = [v28 code];
        v115[0] = NSLocalizedDescriptionKey;
        id v62 = v5;
        if ((uint64_t)[v28 code] > 70) {
          uint64_t v63 = 71;
        }
        else {
          uint64_t v63 = (uint64_t)[v28 code];
        }
        uint64_t v86 = +[NSString stringWithUTF8String:off_100308230[v63]];
        v116[0] = v86;
        v116[1] = v28;
        v115[1] = NSUnderlyingErrorKey;
        v115[2] = @"Line";
        v116[2] = &off_1003204E8;
        v115[3] = @"Method";
        id v87 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_setupEndpoint:activate:")];
        v116[3] = v87;
        void v115[4] = NSDebugDescriptionErrorKey;
        id v88 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_setupEndpoint:activate:"), 776];
        void v116[4] = v88;
        __int16 v89 = +[NSDictionary dictionaryWithObjects:v116 forKeys:v115 count:5];
        long long v90 = v59;
        id v91 = v60;
        uint64_t v92 = (uint64_t)v61;
      }
      else
      {
        id v62 = v5;
        v113[0] = NSLocalizedDescriptionKey;
        uint64_t v86 = +[NSString stringWithUTF8String:"Commmand Error"];
        v114[0] = v86;
        v114[1] = &off_100320500;
        v113[1] = @"Line";
        v113[2] = @"Method";
        id v87 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_setupEndpoint:activate:")];
        v114[2] = v87;
        void v113[3] = NSDebugDescriptionErrorKey;
        id v88 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_setupEndpoint:activate:"), 777];
        void v114[3] = v88;
        __int16 v89 = +[NSDictionary dictionaryWithObjects:v114 forKeys:v113 count:4];
        long long v90 = v59;
        id v91 = v60;
        uint64_t v92 = 16;
      }
      id v93 = [v90 initWithDomain:v91 code:v92 userInfo:v89];
      +[NFExceptionsCALogger postAnalyticsContactlessErrorsEvent:0 status:v102 error:v93];

      id v5 = v62;
      id v94 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Non-9000 Response from SE for endpoint keyID: %@, Response: 0x%04X", v62, [v106 status]);
      sub_1001990A4((uint64_t)NFBugCapture, @"Unable to set endpoint visibility", v94, &off_1003238E8);
    }
    id v95 = objc_alloc((Class)NSError);
    uint64_t v70 = +[NSString stringWithUTF8String:"nfcd"];
    id v105 = v5;
    if (v28)
    {
      id v96 = [v28 code];
      v111[0] = NSLocalizedDescriptionKey;
      long long v21 = v104;
      if ((uint64_t)[v28 code] > 70) {
        uint64_t v97 = 71;
      }
      else {
        uint64_t v97 = (uint64_t)[v28 code];
      }
      id v71 = +[NSString stringWithUTF8String:off_100308230[v97]];
      v112[0] = v71;
      v112[1] = v28;
      v111[1] = NSUnderlyingErrorKey;
      v111[2] = @"Line";
      v112[2] = &off_100320518;
      v111[3] = @"Method";
      id v72 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_setupEndpoint:activate:")];
      v112[3] = v72;
      v111[4] = NSDebugDescriptionErrorKey;
      id v73 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_setupEndpoint:activate:"), 784];
      void v112[4] = v73;
      uint64_t v74 = +[NSDictionary dictionaryWithObjects:v112 forKeys:v111 count:5];
      id v29 = [v95 initWithDomain:v70 code:v96 userInfo:v74];
      goto LABEL_62;
    }
    v109[0] = NSLocalizedDescriptionKey;
    id v71 = +[NSString stringWithUTF8String:"Commmand Error"];
    v110[0] = v71;
    v110[1] = &off_100320518;
    v109[1] = @"Line";
    v109[2] = @"Method";
    id v72 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_setupEndpoint:activate:")];
    v110[2] = v72;
    v109[3] = NSDebugDescriptionErrorKey;
    id v73 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_setupEndpoint:activate:"), 784];
    v110[3] = v73;
    uint64_t v74 = +[NSDictionary dictionaryWithObjects:v110 forKeys:v109 count:4];
    id v75 = v95;
  }
  else
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v30 = NFLogGetLogger();
    if (v30)
    {
      uint64_t v31 = (void (*)(uint64_t, const char *, ...))v30;
      uint64_t v32 = object_getClass(a1);
      BOOL v33 = class_isMetaClass(v32);
      __int16 v34 = object_getClassName(a1);
      id v99 = sel_getName("_setupEndpoint:activate:");
      uint64_t v35 = 45;
      if (v33) {
        uint64_t v35 = 43;
      }
      v31(3, "%c[%{public}s %{public}s]:%i Command (%02X) failed; error: %{public}@",
        v35,
        v34,
        v99,
        759,
        126,
        v28);
    }
    __int16 v104 = v21;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v36 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
    {
      int v37 = object_getClass(a1);
      if (class_isMetaClass(v37)) {
        int v38 = 43;
      }
      else {
        int v38 = 45;
      }
      int v39 = object_getClassName(a1);
      __int16 v40 = sel_getName("_setupEndpoint:activate:");
      *(_DWORD *)int buf = 67110402;
      int v126 = v38;
      __int16 v127 = 2082;
      int v128 = v39;
      __int16 v129 = 2082;
      unint64_t v130 = v40;
      __int16 v131 = 1024;
      int v132 = 759;
      __int16 v133 = 1024;
      *(_DWORD *)int v134 = 126;
      *(_WORD *)&void v134[4] = 2114;
      *(void *)&v134[6] = v28;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Command (%02X) failed; error: %{public}@",
        buf,
        0x32u);
    }

    long long v41 = +[NSString stringWithFormat:@"No Response from SE for endpoint keyID: %@", v5];
    sub_1001990A4((uint64_t)NFBugCapture, @"Unable to set endpoint visibility", v41, &off_1003238C0);

    id v42 = objc_alloc((Class)NSError);
    id v43 = +[NSString stringWithUTF8String:"nfcd"];
    id v105 = v5;
    __int16 v106 = 0;
    id v103 = v22;
    if (v28)
    {
      id v44 = [v28 code];
      v123[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[v28 code] > 70) {
        uint64_t v45 = 71;
      }
      else {
        uint64_t v45 = (uint64_t)[v28 code];
      }
      id v76 = +[NSString stringWithUTF8String:off_100308230[v45]];
      v124[0] = v76;
      v124[1] = v28;
      v123[1] = NSUnderlyingErrorKey;
      v123[2] = @"Line";
      v124[2] = &off_1003204A0;
      v123[3] = @"Method";
      id v77 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_setupEndpoint:activate:")];
      v124[3] = v77;
      void v123[4] = NSDebugDescriptionErrorKey;
      id v78 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_setupEndpoint:activate:"), 766];
      void v124[4] = v78;
      unsigned int v79 = +[NSDictionary dictionaryWithObjects:v124 forKeys:v123 count:5];
      id v80 = [v42 initWithDomain:v43 code:v44 userInfo:v79];
      +[NFExceptionsCALogger postAnalyticsContactlessErrorsEvent:0 status:0 error:v80];

      id v81 = objc_alloc((Class)NSError);
      uint64_t v70 = +[NSString stringWithUTF8String:"nfcd"];
      id v82 = [v28 code];
      v119[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[v28 code] > 70) {
        uint64_t v83 = 71;
      }
      else {
        uint64_t v83 = (uint64_t)[v28 code];
      }
      id v71 = +[NSString stringWithUTF8String:off_100308230[v83]];
      v120[0] = v71;
      v120[1] = v28;
      v119[1] = NSUnderlyingErrorKey;
      v119[2] = @"Line";
      v120[2] = &off_1003204D0;
      v119[3] = @"Method";
      id v72 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_setupEndpoint:activate:")];
      v120[3] = v72;
      v119[4] = NSDebugDescriptionErrorKey;
      id v73 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_setupEndpoint:activate:"), 768];
      v120[4] = v73;
      uint64_t v74 = +[NSDictionary dictionaryWithObjects:v120 forKeys:v119 count:5];
      id v75 = v81;
      id v84 = v70;
      uint64_t v85 = (uint64_t)v82;
      goto LABEL_59;
    }
    v121[0] = NSLocalizedDescriptionKey;
    BOOL v64 = +[NSString stringWithUTF8String:"Commmand Error"];
    v122[0] = v64;
    v122[1] = &off_1003204B8;
    v121[1] = @"Line";
    v121[2] = @"Method";
    id v65 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_setupEndpoint:activate:")];
    v122[2] = v65;
    v121[3] = NSDebugDescriptionErrorKey;
    id v66 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_setupEndpoint:activate:"), 767];
    v122[3] = v66;
    __int16 v67 = +[NSDictionary dictionaryWithObjects:v122 forKeys:v121 count:4];
    id v68 = [v42 initWithDomain:v43 code:16 userInfo:v67];
    +[NFExceptionsCALogger postAnalyticsContactlessErrorsEvent:0 status:0 error:v68];

    id v69 = objc_alloc((Class)NSError);
    uint64_t v70 = +[NSString stringWithUTF8String:"nfcd"];
    v117[0] = NSLocalizedDescriptionKey;
    id v71 = +[NSString stringWithUTF8String:"Commmand Error"];
    v118[0] = v71;
    v118[1] = &off_1003204D0;
    v117[1] = @"Line";
    v117[2] = @"Method";
    id v72 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_setupEndpoint:activate:")];
    v118[2] = v72;
    v117[3] = NSDebugDescriptionErrorKey;
    id v73 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_setupEndpoint:activate:"), 768];
    v118[3] = v73;
    uint64_t v74 = +[NSDictionary dictionaryWithObjects:v118 forKeys:v117 count:4];
    id v75 = v69;
  }
  id v84 = v70;
  uint64_t v85 = 16;
LABEL_59:
  id v29 = [v75 initWithDomain:v84 code:v85 userInfo:v74];
  long long v21 = v104;
LABEL_62:

  id v5 = v105;
  uint64_t v27 = v106;
  id v22 = v103;
LABEL_63:

  return v29;
}

id sub_10024967C(void *a1, int a2, void *a3, void *a4, void *a5)
{
  id v9 = a3;
  v204[1] = 0;
  id v202 = a4;
  unsigned __int8 v10 = [a1 selectApplet:error:];
  id v11 = 0;
  id v201 = v9;
  if ((v10 & 1) == 0)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      __int16 v40 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(a1);
      uint64_t Name = sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:");
      uint64_t v45 = [v202 identifier];
      uint64_t v46 = 45;
      if (isMetaClass) {
        uint64_t v46 = 43;
      }
      v40(3, "%c[%{public}s %{public}s]:%i Failed to select %{public}@", v46, ClassName, Name, 801, v45);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    unsigned int v47 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
    {
      id v48 = object_getClass(a1);
      if (class_isMetaClass(v48)) {
        int v49 = 43;
      }
      else {
        int v49 = 45;
      }
      id v50 = object_getClassName(a1);
      uint64_t v51 = sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:");
      uint64_t v52 = [v202 identifier];
      *(_DWORD *)int buf = 67110146;
      int v224 = v49;
      __int16 v225 = 2082;
      NSErrorUserInfoKey v226 = v50;
      __int16 v227 = 2082;
      NSErrorUserInfoKey v228 = v51;
      __int16 v229 = 1024;
      int v230 = 801;
      __int16 v231 = 2114;
      id v232 = v52;
      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select %{public}@", buf, 0x2Cu);
    }
    if (!a5)
    {
      uint64_t v14 = 0;
      id v37 = 0;
      goto LABEL_56;
    }
    id v53 = objc_alloc((Class)NSError);
    CFStringRef v12 = +[NSString stringWithUTF8String:"nfcd"];
    if (v11)
    {
      id v54 = [v11 code];
      v237[0] = NSLocalizedDescriptionKey;
      int v55 = a5;
      if ((uint64_t)[v11 code] > 70) {
        uint64_t v56 = 71;
      }
      else {
        uint64_t v56 = (uint64_t)[v11 code];
      }
      id v28 = +[NSString stringWithUTF8String:off_100308230[v56]];
      v238[0] = v28;
      v238[1] = v11;
      v237[1] = NSUnderlyingErrorKey;
      v237[2] = @"Line";
      v238[2] = &off_100320530;
      v237[3] = @"Method";
      id v29 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:")];
      v238[3] = v29;
      v237[4] = NSDebugDescriptionErrorKey;
      id v73 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:"), 803];
      v238[4] = v73;
      id v75 = +[NSDictionary dictionaryWithObjects:v238 forKeys:v237 count:5];
      id v76 = [v53 initWithDomain:v12 code:v54 userInfo:v75];
      *int v55 = v76;
    }
    else
    {
      v235[0] = NSLocalizedDescriptionKey;
      id v28 = +[NSString stringWithUTF8String:"Stack Error"];
      v236[0] = v28;
      v236[1] = &off_100320530;
      v235[1] = @"Line";
      v235[2] = @"Method";
      id v29 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:")];
      v236[2] = v29;
      v235[3] = NSDebugDescriptionErrorKey;
      id v73 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:"), 803];
      v236[3] = v73;
      +[NSDictionary dictionaryWithObjects:v236 forKeys:v235 count:4];
      id v75 = v74 = a5;
      id v76 = [v53 initWithDomain:v12 code:15 userInfo:v75];
      void *v74 = v76;
    }

    goto LABEL_51;
  }
  CFStringRef v12 = +[NSData NF_dataWithHexString:v9];
  v204[0] = v11;
  LOBYTE(v181) = 0;
  if (a2) {
    uint64_t v13 = 132;
  }
  else {
    uint64_t v13 = 133;
  }
  uint64_t v14 = [a1 sendCommandWithClass:128 instruction:118 p1:v13 p2:0 data:v12 expectedLength:0 toOS:0 useExtendedLength:v181 error:v204];
  id v15 = v204[0];

  if (!v14)
  {
    __int16 v195 = a5;
    id v57 = v12;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v58 = NFLogGetLogger();
    id v59 = v9;
    if (v58)
    {
      id v60 = (void (*)(uint64_t, const char *, ...))v58;
      id v61 = object_getClass(a1);
      BOOL v62 = class_isMetaClass(v61);
      uint64_t v63 = object_getClassName(a1);
      __int16 v185 = sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:");
      uint64_t v64 = 45;
      if (v62) {
        uint64_t v64 = 43;
      }
      v60(3, "%c[%{public}s %{public}s]:%i VIEW to %{public}@ failed: %{public}@", v64, v63, v185, 823, v59, v15);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v65 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
    {
      id v66 = object_getClass(a1);
      if (class_isMetaClass(v66)) {
        int v67 = 43;
      }
      else {
        int v67 = 45;
      }
      id v68 = object_getClassName(a1);
      id v69 = sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:");
      *(_DWORD *)int buf = 67110402;
      int v224 = v67;
      __int16 v225 = 2082;
      NSErrorUserInfoKey v226 = v68;
      __int16 v227 = 2082;
      NSErrorUserInfoKey v228 = v69;
      __int16 v229 = 1024;
      int v230 = 823;
      __int16 v231 = 2114;
      id v232 = v201;
      __int16 v233 = 2114;
      id v234 = v15;
      _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i VIEW to %{public}@ failed: %{public}@", buf, 0x36u);
    }

    if (!v195)
    {
      uint64_t v14 = 0;
      id v37 = 0;
      CFStringRef v12 = v57;
      goto LABEL_55;
    }
    id v70 = objc_alloc((Class)NSError);
    id v28 = +[NSString stringWithUTF8String:"nfcd"];
    CFStringRef v12 = v57;
    if (v15)
    {
      id v71 = [v15 code];
      v221[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[v15 code] > 70) {
        uint64_t v72 = 71;
      }
      else {
        uint64_t v72 = (uint64_t)[v15 code];
      }
      id v29 = +[NSString stringWithUTF8String:off_100308230[v72]];
      v222[0] = v29;
      v222[1] = v15;
      v221[1] = NSUnderlyingErrorKey;
      v221[2] = @"Line";
      void v222[2] = &off_100320548;
      v221[3] = @"Method";
      id v108 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:")];
      v222[3] = v108;
      v221[4] = NSDebugDescriptionErrorKey;
      id v109 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:"), 825];
      v222[4] = v109;
      __int16 v110 = +[NSDictionary dictionaryWithObjects:v222 forKeys:v221 count:5];
      id v111 = [v70 initWithDomain:v28 code:v71 userInfo:v110];
      *__int16 v195 = v111;

      int v38 = 0;
      id v37 = 0;
      id v11 = v15;
      goto LABEL_53;
    }
    v219[0] = NSLocalizedDescriptionKey;
    id v29 = +[NSString stringWithUTF8String:"Commmand Error"];
    v220[0] = v29;
    v220[1] = &off_100320548;
    v219[1] = @"Line";
    v219[2] = @"Method";
    id v90 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:")];
    v220[2] = v90;
    v219[3] = NSDebugDescriptionErrorKey;
    id v91 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:"), 825];
    v220[3] = v91;
    uint64_t v92 = +[NSDictionary dictionaryWithObjects:v220 forKeys:v219 count:4];
    id v93 = [v70 initWithDomain:v28 code:16 userInfo:v92];
    *__int16 v195 = v93;

LABEL_69:
    id v11 = 0;
LABEL_51:
    int v38 = 0;
    goto LABEL_52;
  }
  unsigned int v198 = v12;
  if ([v14 status] != 25600 && objc_msgSend(v14, "status") != 28410)
  {
    if ([v14 status] != 36864)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v94 = NFLogGetLogger();
      if (v94)
      {
        id v95 = (void (*)(uint64_t, const char *, ...))v94;
        id v96 = object_getClass(a1);
        BOOL v97 = class_isMetaClass(v96);
        uint64_t v98 = object_getClassName(a1);
        id v99 = sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:");
        uint64_t v187 = [v14 status];
        uint64_t v100 = 45;
        if (v97) {
          uint64_t v100 = 43;
        }
        v95(3, "%c[%{public}s %{public}s]:%i Failed to execute endpoint view command; status: 0x%04X",
          v100,
          v98,
          v99,
          842,
          v187);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      CFStringRef v101 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
      {
        unsigned int v102 = object_getClass(a1);
        if (class_isMetaClass(v102)) {
          int v103 = 43;
        }
        else {
          int v103 = 45;
        }
        __int16 v104 = object_getClassName(a1);
        id v105 = sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:");
        unsigned int v106 = [v14 status];
        *(_DWORD *)int buf = 67110146;
        int v224 = v103;
        __int16 v225 = 2082;
        NSErrorUserInfoKey v226 = v104;
        __int16 v227 = 2082;
        NSErrorUserInfoKey v228 = v105;
        __int16 v229 = 1024;
        int v230 = 842;
        __int16 v231 = 1024;
        LODWORD(v232) = v106;
        _os_log_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to execute endpoint view command; status: 0x%04X",
          buf,
          0x28u);
      }

      if (a5)
      {
        id v107 = objc_alloc((Class)NSError);
        id v28 = +[NSString stringWithUTF8String:"nfcd"];
        v215[0] = NSLocalizedDescriptionKey;
        id v29 = +[NSString stringWithUTF8String:"Commmand Error"];
        v216[0] = v29;
        v216[1] = &off_100320578;
        v215[1] = @"Line";
        v215[2] = @"Method";
        id v30 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:")];
        v216[2] = v30;
        v215[3] = NSDebugDescriptionErrorKey;
        id v31 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:"), 844];
        v216[3] = v31;
        +[NSDictionary dictionaryWithObjects:v216 forKeys:v215 count:4];
        BOOL v33 = v32 = a5;
        __int16 v34 = v107;
        uint64_t v35 = v28;
        uint64_t v36 = 16;
        goto LABEL_19;
      }
LABEL_81:
      id v37 = 0;
      CFStringRef v12 = v198;
      goto LABEL_55;
    }
    id v78 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284607 length:9];
    unsigned int v79 = [v78 NF_asHexString];

    id v80 = [v202 identifier];
    int v194 = v79;
    id v81 = [v80 compare:v79 options:1 range:[v79 length]];

    id v82 = [v14 response];
    id v83 = [v82 length];

    if (v81)
    {
      if (v83 == (id)2)
      {
        id v84 = [v14 response];
        unsigned int v85 = *(unsigned __int16 *)[v84 bytes];

        if (!v85)
        {
          id v37 = 0;
LABEL_101:
          CFStringRef v12 = v198;
          goto LABEL_102;
        }
        uint64_t v86 = __rev16(v85);
        id v203 = v15;
        LOBYTE(v182) = 0;
        int v38 = [a1 sendCommandWithClass:128 instruction:176 p1:0 p2:0 data:0 expectedLength:v86 toOS:0 useExtendedLength:v182 error:&v203];
        id v11 = v203;

        if (v38)
        {
          if ([v38 status] == 36864)
          {
            id v87 = [v38 data];
            id v37 = [v87 length];

            if (v37)
            {
              id v88 = objc_alloc((Class)NSData);
              id v29 = [v38 data];
              __int16 v89 = [v29 subdataWithRange:0, v86];
              id v37 = [v88 initWithData:v89];

              CFStringRef v12 = v198;
LABEL_98:
              id v28 = v194;
              goto LABEL_53;
            }
            id v15 = v11;
            uint64_t v14 = v38;
            goto LABEL_101;
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v145 = NFLogGetLogger();
          if (v145)
          {
            __int16 v146 = (void (*)(uint64_t, const char *, ...))v145;
            uint64_t v147 = object_getClass(a1);
            BOOL v148 = class_isMetaClass(v147);
            unsigned int v149 = object_getClassName(a1);
            int v150 = sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:");
            uint64_t v189 = [v38 status];
            uint64_t v151 = 45;
            if (v148) {
              uint64_t v151 = 43;
            }
            v146(3, "%c[%{public}s %{public}s]:%i Returned error: 0x%04x", v151, v149, v150, 895, v189);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          int v152 = NFSharedLogGetLogger();
          id v28 = v194;
          if (os_log_type_enabled(v152, OS_LOG_TYPE_ERROR))
          {
            int v153 = object_getClass(a1);
            if (class_isMetaClass(v153)) {
              int v154 = 43;
            }
            else {
              int v154 = 45;
            }
            id v155 = object_getClassName(a1);
            __int16 v156 = sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:");
            unsigned int v157 = [v38 status];
            *(_DWORD *)int buf = 67110146;
            int v224 = v154;
            __int16 v225 = 2082;
            NSErrorUserInfoKey v226 = v155;
            __int16 v227 = 2082;
            NSErrorUserInfoKey v228 = v156;
            __int16 v229 = 1024;
            int v230 = 895;
            __int16 v231 = 1024;
            LODWORD(v232) = v157;
            _os_log_impl((void *)&_mh_execute_header, v152, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Returned error: 0x%04x", buf, 0x28u);
          }

          if (a5)
          {
            id v158 = objc_alloc((Class)NSError);
            id v29 = +[NSString stringWithUTF8String:"nfcd"];
            CFStringRef v12 = v198;
            if (v11)
            {
              SEL sel = (SEL)[v11 code];
              v207[0] = NSLocalizedDescriptionKey;
              char v197 = a5;
              id v159 = v158;
              if ((uint64_t)[v11 code] > 70) {
                uint64_t v160 = 71;
              }
              else {
                uint64_t v160 = (uint64_t)[v11 code];
              }
              id v176 = +[NSString stringWithUTF8String:off_100308230[v160]];
              v208[0] = v176;
              v208[1] = v11;
              v207[1] = NSUnderlyingErrorKey;
              v207[2] = @"Line";
              v208[2] = &off_1003205C0;
              v207[3] = @"Method";
              id v177 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:")];
              v208[3] = v177;
              v207[4] = NSDebugDescriptionErrorKey;
              id v178 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:"), 898];
              v208[4] = v178;
              id v179 = +[NSDictionary dictionaryWithObjects:v208 forKeys:v207 count:5];
              id v180 = [v159 initWithDomain:v29 code:sel userInfo:v179];
              void *v197 = v180;

LABEL_139:
              id v37 = 0;
              goto LABEL_98;
            }
            v205[0] = NSLocalizedDescriptionKey;
            sela = +[NSString stringWithUTF8String:"Commmand Error"];
            v206[0] = sela;
            v206[1] = &off_1003205C0;
            v205[1] = @"Line";
            v205[2] = @"Method";
            id v170 = v158;
            id v171 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:")];
            v206[2] = v171;
            v205[3] = NSDebugDescriptionErrorKey;
            id v172 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:"), 898];
            v206[3] = v172;
            +[NSDictionary dictionaryWithObjects:v206 forKeys:v205 count:4];
            v174 = id v173 = a5;
            id v175 = [v170 initWithDomain:v29 code:16 userInfo:v174];
            *id v173 = v175;

            id v11 = 0;
LABEL_52:
            id v37 = 0;
            goto LABEL_53;
          }
          id v37 = 0;
          id v15 = v11;
          uint64_t v14 = v38;
LABEL_132:
          CFStringRef v12 = v198;
          goto LABEL_54;
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v132 = NFLogGetLogger();
        if (v132)
        {
          __int16 v133 = (void (*)(uint64_t, const char *, ...))v132;
          int v134 = object_getClass(a1);
          BOOL v135 = class_isMetaClass(v134);
          uint64_t v183 = object_getClassName(a1);
          char v186 = sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:");
          uint64_t v136 = 45;
          if (v135) {
            uint64_t v136 = 43;
          }
          v133(3, "%c[%{public}s %{public}s]:%i Read binary failed: %{public}@", v136, v183, v186, 888, v11);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v137 = NFSharedLogGetLogger();
        id v28 = v194;
        if (os_log_type_enabled(v137, OS_LOG_TYPE_ERROR))
        {
          id v138 = object_getClass(a1);
          if (class_isMetaClass(v138)) {
            int v139 = 43;
          }
          else {
            int v139 = 45;
          }
          unsigned int v140 = object_getClassName(a1);
          id v141 = sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:");
          *(_DWORD *)int buf = 67110146;
          int v224 = v139;
          __int16 v225 = 2082;
          NSErrorUserInfoKey v226 = v140;
          __int16 v227 = 2082;
          NSErrorUserInfoKey v228 = v141;
          __int16 v229 = 1024;
          int v230 = 888;
          __int16 v231 = 2114;
          id v232 = v11;
          _os_log_impl((void *)&_mh_execute_header, v137, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Read binary failed: %{public}@", buf, 0x2Cu);
        }

        if (!a5)
        {
          uint64_t v14 = 0;
          id v37 = 0;
          id v15 = v11;
          goto LABEL_132;
        }
        id v142 = objc_alloc((Class)NSError);
        id v29 = +[NSString stringWithUTF8String:"nfcd"];
        CFStringRef v12 = v198;
        if (v11)
        {
          id v143 = [v11 code];
          v211[0] = NSLocalizedDescriptionKey;
          unsigned __int8 v196 = a5;
          if ((uint64_t)[v11 code] > 70) {
            uint64_t v144 = 71;
          }
          else {
            uint64_t v144 = (uint64_t)[v11 code];
          }
          unsigned int v165 = +[NSString stringWithUTF8String:off_100308230[v144]];
          v212[0] = v165;
          v212[1] = v11;
          v211[1] = NSUnderlyingErrorKey;
          v211[2] = @"Line";
          v212[2] = &off_1003205A8;
          v211[3] = @"Method";
          id v166 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:")];
          v212[3] = v166;
          v211[4] = NSDebugDescriptionErrorKey;
          id v167 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:"), 890];
          v212[4] = v167;
          unsigned int v168 = +[NSDictionary dictionaryWithObjects:v212 forKeys:v211 count:5];
          id v169 = [v142 initWithDomain:v29 code:v143 userInfo:v168];
          void *v196 = v169;

          int v38 = 0;
          goto LABEL_139;
        }
        v209[0] = NSLocalizedDescriptionKey;
        id v193 = +[NSString stringWithUTF8String:"Commmand Error"];
        v210[0] = v193;
        v210[1] = &off_1003205A8;
        v209[1] = @"Line";
        v209[2] = @"Method";
        id v161 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:")];
        v210[2] = v161;
        v209[3] = NSDebugDescriptionErrorKey;
        id v162 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:"), 890];
        v210[3] = v162;
        int v163 = +[NSDictionary dictionaryWithObjects:v210 forKeys:v209 count:4];
        id v164 = [v142 initWithDomain:v29 code:16 userInfo:v163];
        *a5 = v164;

        goto LABEL_69;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v113 = NFLogGetLogger();
      if (v113)
      {
        long long v114 = (void (*)(uint64_t, const char *, ...))v113;
        long long v115 = object_getClass(a1);
        BOOL v190 = class_isMetaClass(v115);
        int v191 = object_getClassName(a1);
        long long v116 = sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:");
        int v117 = [v14 response];
        id v188 = [v117 length];
        uint64_t v118 = 45;
        if (v190) {
          uint64_t v118 = 43;
        }
        v114(3, "%c[%{public}s %{public}s]:%i Unexpected response length %lu", v118, v191, v116, 864, v188);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v119 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v119, OS_LOG_TYPE_ERROR))
      {
        __int16 v120 = object_getClass(a1);
        long long v121 = v12;
        if (class_isMetaClass(v120)) {
          int v122 = 43;
        }
        else {
          int v122 = 45;
        }
        int v123 = object_getClassName(a1);
        __int16 v124 = sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:");
        int v125 = [v14 response];
        id v126 = [v125 length];
        *(_DWORD *)int buf = 67110146;
        int v224 = v122;
        CFStringRef v12 = v121;
        __int16 v225 = 2082;
        NSErrorUserInfoKey v226 = v123;
        __int16 v227 = 2082;
        NSErrorUserInfoKey v228 = v124;
        __int16 v229 = 1024;
        int v230 = 864;
        __int16 v231 = 2048;
        id v232 = v126;
        _os_log_impl((void *)&_mh_execute_header, v119, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected response length %lu", buf, 0x2Cu);
      }
      if (a5)
      {
        id v192 = objc_alloc((Class)NSError);
        id v29 = +[NSString stringWithUTF8String:"nfcd"];
        v213[0] = NSLocalizedDescriptionKey;
        __int16 v127 = +[NSString stringWithUTF8String:"Commmand Error"];
        v214[0] = v127;
        v214[1] = &off_100320590;
        v213[1] = @"Line";
        v213[2] = @"Method";
        id v128 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:")];
        v214[2] = v128;
        v213[3] = NSDebugDescriptionErrorKey;
        id v129 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:"), 866];
        v214[3] = v129;
        +[NSDictionary dictionaryWithObjects:v214 forKeys:v213 count:4];
        __int16 v131 = v130 = a5;
        void *v130 = [v192 initWithDomain:v29 code:16 userInfo:v131];

        id v37 = 0;
        goto LABEL_97;
      }
    }
    else if (v83)
    {
      id v112 = objc_alloc((Class)NSData);
      id v29 = [v14 response];
      id v37 = [v112 initWithData:v29];
LABEL_97:
      id v11 = v15;
      int v38 = v14;
      goto LABEL_98;
    }
    id v37 = 0;
LABEL_102:
    id v28 = v194;
    goto LABEL_54;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v16 = NFLogGetLogger();
  if (v16)
  {
    int v17 = (void (*)(uint64_t, const char *, ...))v16;
    unsigned __int8 v18 = object_getClass(a1);
    BOOL v19 = class_isMetaClass(v18);
    CFStringRef v20 = object_getClassName(a1);
    uint64_t v184 = sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:");
    uint64_t v21 = 45;
    if (v19) {
      uint64_t v21 = 43;
    }
    v17(5, "%c[%{public}s %{public}s]:%i Endpoint not found", v21, v20, v184, 833);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v22 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    long long v23 = object_getClass(a1);
    if (class_isMetaClass(v23)) {
      int v24 = 43;
    }
    else {
      int v24 = 45;
    }
    int v25 = object_getClassName(a1);
    id v26 = sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:");
    *(_DWORD *)int buf = 67109890;
    int v224 = v24;
    __int16 v225 = 2082;
    NSErrorUserInfoKey v226 = v25;
    __int16 v227 = 2082;
    NSErrorUserInfoKey v228 = v26;
    __int16 v229 = 1024;
    int v230 = 833;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Endpoint not found", buf, 0x22u);
  }

  if (!a5) {
    goto LABEL_81;
  }
  id v27 = objc_alloc((Class)NSError);
  id v28 = +[NSString stringWithUTF8String:"nfcd"];
  v217[0] = NSLocalizedDescriptionKey;
  id v29 = +[NSString stringWithUTF8String:"Not found"];
  v218[0] = v29;
  v218[1] = &off_100320560;
  v217[1] = @"Line";
  v217[2] = @"Method";
  id v30 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:")];
  v218[2] = v30;
  v217[3] = NSDebugDescriptionErrorKey;
  id v31 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_readTransactionCodesForContactless:forIdentifier:onApplet:outError:"), 837];
  v218[3] = v31;
  +[NSDictionary dictionaryWithObjects:v218 forKeys:v217 count:4];
  BOOL v33 = v32 = a5;
  __int16 v34 = v27;
  uint64_t v35 = v28;
  uint64_t v36 = 65;
LABEL_19:
  void *v32 = [v34 initWithDomain:v35 code:v36 userInfo:v33];

  id v37 = 0;
  id v11 = v15;
  int v38 = v14;
  CFStringRef v12 = v198;
LABEL_53:

  id v15 = v11;
  uint64_t v14 = v38;
LABEL_54:

LABEL_55:
  id v11 = v15;
LABEL_56:

  return v37;
}

id sub_10024B1F8(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  id v5 = [v3 length];
  if (v5 == [v4 length])
  {
    id v6 = [v3 mutableCopy];
    id v7 = [v4 mutableCopy];
    if ([v6 length])
    {
      unint64_t v8 = 0;
      do
      {
        if ([v7 length])
        {
          uint64_t v9 = 0;
          while (1)
          {
            id v10 = v6;
            int v11 = *((unsigned __int8 *)[v10 mutableBytes] + v8);
            id v12 = v7;
            if (v11 == *((unsigned __int8 *)[v12 mutableBytes] + v9)) {
              break;
            }
            if ((unint64_t)[v12 length] <= ++v9) {
              goto LABEL_10;
            }
          }
          *((unsigned char *)[v10 mutableBytes] + v8) = 0;
          *((unsigned char *)[v12 mutableBytes] + v9) = 0;
        }
LABEL_10:
        ++v8;
      }
      while ((unint64_t)[v6 length] > v8);
    }
    id v13 = [v6 isEqual:v7];
  }
  else
  {
    id v13 = 0;
  }

  return v13;
}

id sub_10024B344(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, unsigned int a7)
{
  id v13 = a2;
  id v14 = a3;
  id v15 = a4;
  id v16 = a5;
  id v207 = a6;
  BOOL v209 = v13;
  if (a1)
  {
    unsigned int v203 = a7;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    id v210 = v16;
    if (Logger)
    {
      unsigned __int8 v18 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(a1);
      uint64_t Name = sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:");
      uint64_t v21 = 43;
      if (!isMetaClass) {
        uint64_t v21 = 45;
      }
      v18(6, "%c[%{public}s %{public}s]:%i setup key %{public}@ with contactless TC %{public}@ ; wired TC %{public}@",
        v21,
        ClassName,
        Name,
        944,
        v15,
        v13,
        v14);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v22 = NFSharedLogGetLogger();
    id v212 = v15;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      long long v23 = object_getClass(a1);
      if (class_isMetaClass(v23)) {
        int v24 = 43;
      }
      else {
        int v24 = 45;
      }
      *(_DWORD *)int buf = 67110658;
      int v243 = v24;
      id v15 = v212;
      __int16 v244 = 2082;
      unsigned int v245 = object_getClassName(a1);
      __int16 v246 = 2082;
      uint64_t v247 = sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:");
      __int16 v248 = 1024;
      int v249 = 944;
      __int16 v250 = 2114;
      CFStringRef v251 = v212;
      __int16 v252 = 2114;
      long long v253 = v13;
      __int16 v254 = 2114;
      id v255 = v14;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i setup key %{public}@ with contactless TC %{public}@ ; wired TC %{public}@",
        buf,
        0x40u);
    }

    if (v13)
    {
      int v25 = v14;
      id v219 = 0;
      id v26 = sub_10024967C(a1, 1, v15, v16, &v219);
      id v27 = v219;
      if (v27)
      {
        id v28 = v27;
        id v204 = objc_alloc((Class)NSError);
        id v29 = +[NSString stringWithUTF8String:"nfcd"];
        id v30 = [v28 code];
        v240[0] = NSLocalizedDescriptionKey;
        if ((uint64_t)[v28 code] > 70) {
          uint64_t v31 = 71;
        }
        else {
          uint64_t v31 = (uint64_t)[v28 code];
        }
        id v37 = +[NSString stringWithUTF8String:off_100308230[v31]];
        v241[0] = v37;
        v241[1] = v28;
        v240[1] = NSUnderlyingErrorKey;
        v240[2] = @"Line";
        v241[2] = &off_1003205D8;
        v240[3] = @"Method";
        id v38 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:")];
        v241[3] = v38;
        v240[4] = NSDebugDescriptionErrorKey;
        id v39 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:"), 953];
        v241[4] = v39;
        __int16 v40 = +[NSDictionary dictionaryWithObjects:v241 forKeys:v240 count:5];
        id v41 = [v204 initWithDomain:v29 code:v30 userInfo:v40];

LABEL_54:
        id v14 = v25;
        id v16 = v210;
        id v15 = v212;
LABEL_55:
        uint64_t v63 = v207;
LABEL_56:

        goto LABEL_57;
      }
      unsigned int v32 = sub_10024B1F8(v13, v26) ^ 1;

      id v14 = v25;
      if (!v25) {
        goto LABEL_20;
      }
    }
    else
    {
      LOBYTE(v32) = 0;
      if (!v14)
      {
LABEL_20:
        LOBYTE(v36) = 0;
        goto LABEL_24;
      }
    }
    int v25 = v14;
    id v218 = 0;
    id v26 = sub_10024967C(a1, 0, v212, v16, &v218);
    BOOL v33 = v218;
    if (v33)
    {
      id v28 = v33;
      id v205 = objc_alloc((Class)NSError);
      id v29 = +[NSString stringWithUTF8String:"nfcd"];
      id v34 = [v28 code];
      v238[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[v28 code] > 70) {
        uint64_t v35 = 71;
      }
      else {
        uint64_t v35 = (uint64_t)[v28 code];
      }
      id v37 = +[NSString stringWithUTF8String:off_100308230[v35]];
      v239[0] = v37;
      v239[1] = v28;
      v238[1] = NSUnderlyingErrorKey;
      v238[2] = @"Line";
      v239[2] = &off_1003205F0;
      v238[3] = @"Method";
      id v38 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:")];
      v239[3] = v38;
      v238[4] = NSDebugDescriptionErrorKey;
      id v77 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:"), 961];
      v239[4] = v77;
      id v78 = +[NSDictionary dictionaryWithObjects:v239 forKeys:v238 count:5];
      id v41 = [v205 initWithDomain:v29 code:v34 userInfo:v78];

      goto LABEL_54;
    }
    unsigned int v36 = sub_10024B1F8(v25, v26) ^ 1;

    id v14 = v25;
LABEL_24:
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v42 = NFLogGetLogger();
    id v43 = (void (*)(uint64_t, const char *, ...))v42;
    if (((v32 | v36) & 1) == 0)
    {
      if (v42)
      {
        id v69 = object_getClass(a1);
        BOOL v70 = class_isMetaClass(v69);
        id v71 = object_getClassName(a1);
        id v192 = sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:");
        uint64_t v72 = 45;
        if (v70) {
          uint64_t v72 = 43;
        }
        v43(6, "%c[%{public}s %{public}s]:%i TC already set - bailing", v72, v71, v192, 967);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v28 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        id v73 = object_getClass(a1);
        if (class_isMetaClass(v73)) {
          int v74 = 43;
        }
        else {
          int v74 = 45;
        }
        id v75 = object_getClassName(a1);
        id v76 = sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:");
        *(_DWORD *)int buf = 67109890;
        int v243 = v74;
        __int16 v244 = 2082;
        unsigned int v245 = v75;
        __int16 v246 = 2082;
        uint64_t v247 = v76;
        __int16 v248 = 1024;
        int v249 = 967;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i TC already set - bailing", buf, 0x22u);
      }
      id v41 = 0;
      id v15 = v212;
      goto LABEL_55;
    }
    if (v42)
    {
      id v44 = object_getClass(a1);
      BOOL v45 = class_isMetaClass(v44);
      uint64_t v46 = object_getClassName(a1);
      int v191 = sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:");
      uint64_t v47 = 45;
      if (v45) {
        uint64_t v47 = 43;
      }
      v43(6, "%c[%{public}s %{public}s]:%i TC are not set - changing", v47, v46, v191, 971);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v48 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
    {
      int v49 = object_getClass(a1);
      if (class_isMetaClass(v49)) {
        int v50 = 43;
      }
      else {
        int v50 = 45;
      }
      uint64_t v51 = object_getClassName(a1);
      uint64_t v52 = sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:");
      *(_DWORD *)int buf = 67109890;
      int v243 = v50;
      __int16 v244 = 2082;
      unsigned int v245 = v51;
      __int16 v246 = 2082;
      uint64_t v247 = v52;
      __int16 v248 = 1024;
      int v249 = 971;
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i TC are not set - changing", buf, 0x22u);
    }

    id v53 = objc_opt_new();
    uint64_t v199 = +[NSData NF_dataWithHexString:v212];
    id v54 = +[NFTLV TLVWithTag:value:](NFTLV, "TLVWithTag:value:", 80);
    int v55 = [v54 asData];
    [v53 appendData:v55];

    if (v13)
    {
      uint64_t v56 = +[NFTLV TLVWithTag:132 value:v13];

      id v57 = [v56 asData];
      [v53 appendData:v57];

      id v54 = v56;
    }
    uint64_t v58 = v53;
    if (v14)
    {
      id v59 = +[NFTLV TLVWithTag:133 value:v14];

      id v60 = [v59 asData];
      [v53 appendData:v60];

      id v54 = v59;
    }
    id v61 = objc_alloc((Class)NSMutableData);
    int v216 = 32384;
    unsigned __int8 v217 = [v53 length];
    id v62 = [v61 initWithBytes:&v216 length:5];
    id v202 = v58;
    [v62 appendData:v58];
    uint64_t v63 = v207;
    int v200 = v62;
    id v201 = v54;
    if (v207 && (sub_1001F7028(a1, v62, v16, 1, v207, v203), (uint64_t v64 = objc_claimAutoreleasedReturnValue()) != 0))
    {
      id v28 = v64;
      id v196 = v14;
      id v65 = objc_alloc((Class)NSError);
      id v66 = +[NSString stringWithUTF8String:"nfcd"];
      id v67 = [v28 code];
      v236[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[v28 code] > 70) {
        uint64_t v68 = 71;
      }
      else {
        uint64_t v68 = (uint64_t)[v28 code];
      }
      uint64_t v125 = +[NSString stringWithUTF8String:off_100308230[v68]];
      v237[0] = v125;
      v237[1] = v28;
      v236[1] = NSUnderlyingErrorKey;
      v236[2] = @"Line";
      v237[2] = &off_100320608;
      v236[3] = @"Method";
      id v126 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:")];
      v237[3] = v126;
      void v236[4] = NSDebugDescriptionErrorKey;
      id v127 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:"), 1002];
      v237[4] = v127;
      id v128 = +[NSDictionary dictionaryWithObjects:v237 forKeys:v236 count:5];
      id v41 = [v65 initWithDomain:v66 code:v67 userInfo:v128];

      id v129 = (void *)v125;
      uint64_t v206 = 0;
      id v14 = v196;
      id v16 = v210;
    }
    else
    {
      char v215 = 0;
      [v62 appendBytes:&v215 length:1];
      id v214 = 0;
      unsigned __int8 v80 = [a1 selectApplet:v16 error:&v214];
      id v81 = v214;
      id v28 = v81;
      if (v80)
      {
        id v197 = v14;
        id v213 = v81;
        id v82 = [a1 transceiveData:v62 toOS:0 error:&v213];
        id v83 = v213;

        id v84 = +[NFResponseAPDU responseWithData:v82];

        uint64_t v206 = v84;
        if (v83)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v85 = NFLogGetLogger();
          if (v85)
          {
            uint64_t v86 = (void (*)(uint64_t, const char *, ...))v85;
            id v87 = object_getClass(a1);
            BOOL v88 = class_isMetaClass(v87);
            __int16 v89 = object_getClassName(a1);
            id v90 = sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:");
            id v91 = [v16 identifier];
            uint64_t v92 = 45;
            if (v88) {
              uint64_t v92 = 43;
            }
            v86(3, "%c[%{public}s %{public}s]:%i SETUP_ENDPOINT to %{public}@ failed: %{public}@", v92, v89, v90, 1019, v91, v83);

            id v16 = v210;
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v93 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v93, OS_LOG_TYPE_ERROR))
          {
            uint64_t v94 = object_getClass(a1);
            if (class_isMetaClass(v94)) {
              int v95 = 43;
            }
            else {
              int v95 = 45;
            }
            id v96 = object_getClassName(a1);
            BOOL v97 = sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:");
            uint64_t v98 = [v16 identifier];
            *(_DWORD *)int buf = 67110402;
            int v243 = v95;
            __int16 v244 = 2082;
            unsigned int v245 = v96;
            __int16 v246 = 2082;
            uint64_t v247 = v97;
            __int16 v248 = 1024;
            int v249 = 1019;
            __int16 v250 = 2114;
            CFStringRef v251 = v98;
            __int16 v252 = 2114;
            long long v253 = v83;
            _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i SETUP_ENDPOINT to %{public}@ failed: %{public}@", buf, 0x36u);

            id v16 = v210;
          }

          id v99 = [v16 identifier];
          uint64_t v100 = +[NSString stringWithFormat:@"Applet AID: %@, keyID: %@", v99, v212];
          v230[0] = @"Applet Identifier";
          CFStringRef v101 = [v16 identifier];
          v230[1] = @"FailureKey";
          v231[0] = v101;
          v231[1] = @"ttrContactless";
          unsigned int v102 = +[NSDictionary dictionaryWithObjects:v231 forKeys:v230 count:2];
          sub_1001990A4((uint64_t)NFBugCapture, @"Failed to set endpoint transaction codes", v100, v102);

          if (v206) {
            id v103 = [v206 status];
          }
          else {
            id v103 = 0;
          }
          uint64_t v63 = v207;
          +[NFExceptionsCALogger postAnalyticsContactlessErrorsEvent:2 status:v103 error:v83];
          id v208 = objc_alloc((Class)NSError);
          id v66 = +[NSString stringWithUTF8String:"nfcd"];
          id v151 = [v83 code];
          v228[0] = NSLocalizedDescriptionKey;
          if ((uint64_t)[v83 code] > 70) {
            uint64_t v152 = 71;
          }
          else {
            uint64_t v152 = (uint64_t)[v83 code];
          }
          uint64_t v153 = +[NSString stringWithUTF8String:off_100308230[v152]];
          v229[0] = v153;
          v229[1] = v83;
          v228[1] = NSUnderlyingErrorKey;
          v228[2] = @"Line";
          v229[2] = &off_100320638;
          v228[3] = @"Method";
          id v126 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:")];
          v229[3] = v126;
          v228[4] = NSDebugDescriptionErrorKey;
          id v154 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:"), 1027];
          v229[4] = v154;
          id v155 = +[NSDictionary dictionaryWithObjects:v229 forKeys:v228 count:5];
          id v41 = [v208 initWithDomain:v66 code:v151 userInfo:v155];

          id v129 = (void *)v153;
          id v28 = v83;
          id v14 = v197;
          int v150 = (void *)v199;
          id v16 = v210;
          goto LABEL_107;
        }
        if ([v84 status] != 28181)
        {
          id v14 = v197;
          if ([v84 status] == 36864)
          {
            id v28 = 0;
            id v41 = 0;
            id v15 = v212;
            int v150 = (void *)v199;
            goto LABEL_108;
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v156 = NFLogGetLogger();
          if (v156)
          {
            unsigned int v157 = (void (*)(uint64_t, const char *, ...))v156;
            id v158 = object_getClass(a1);
            BOOL v159 = class_isMetaClass(v158);
            uint64_t v160 = object_getClassName(a1);
            id v161 = sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:");
            uint64_t v194 = [v206 status];
            uint64_t v189 = v160;
            uint64_t v162 = 45;
            if (v159) {
              uint64_t v162 = 43;
            }
            id v16 = v210;
            v157(3, "%c[%{public}s %{public}s]:%i Failed to execute opaque data, resp: 0x%04X", v162, v189, v161, 1037, v194);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          int v163 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v163, OS_LOG_TYPE_ERROR))
          {
            id v164 = object_getClass(a1);
            if (class_isMetaClass(v164)) {
              int v165 = 43;
            }
            else {
              int v165 = 45;
            }
            id v166 = object_getClassName(a1);
            id v167 = sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:");
            unsigned int v168 = [v206 status];
            *(_DWORD *)int buf = 67110146;
            int v243 = v165;
            __int16 v244 = 2082;
            unsigned int v245 = v166;
            __int16 v246 = 2082;
            uint64_t v247 = v167;
            __int16 v248 = 1024;
            int v249 = 1037;
            __int16 v250 = 1024;
            LODWORD(v251) = v168;
            _os_log_impl((void *)&_mh_execute_header, v163, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to execute opaque data, resp: 0x%04X", buf, 0x28u);
          }

          if ([v206 status] == 26880)
          {
            NSErrorUserInfoKey v169 = NSLocalizedDescriptionKey;
            NSErrorUserInfoKey v195 = NSDebugDescriptionErrorKey;
          }
          else
          {
            id v170 = [v206 status];
            id v171 = objc_alloc((Class)NSError);
            id v172 = +[NSString stringWithUTF8String:"nfcd"];
            v224[0] = NSLocalizedDescriptionKey;
            id v173 = +[NSString stringWithUTF8String:"Commmand Error"];
            v225[0] = v173;
            v225[1] = &off_100320650;
            v224[1] = @"Line";
            v224[2] = @"Method";
            id v174 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:")];
            v225[2] = v174;
            NSErrorUserInfoKey v195 = NSDebugDescriptionErrorKey;
            v224[3] = NSDebugDescriptionErrorKey;
            id v175 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:"), 1041];
            v225[3] = v175;
            id v176 = +[NSDictionary dictionaryWithObjects:v225 forKeys:v224 count:4];
            id v177 = [v171 initWithDomain:v172 code:16 userInfo:v176];
            +[NFExceptionsCALogger postAnalyticsContactlessErrorsEvent:2 status:v170 error:v177];

            id v178 = [v210 identifier];
            id v179 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Applet AID: %@, keyID: %@, Response: 0x%04X", v178, v212, [v206 status]);
            v222[0] = @"Applet Identifier";
            id v180 = [v210 identifier];
            v223[0] = v180;
            v222[1] = @"Response";
            uint64_t v181 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"%04X", [v206 status]);
            void v222[2] = @"FailureKey";
            v223[1] = v181;
            v223[2] = @"ttrContactless";
            uint64_t v182 = +[NSDictionary dictionaryWithObjects:v223 forKeys:v222 count:3];
            id v16 = v210;
            sub_1001990A4((uint64_t)NFBugCapture, @"Failed to set endpoint transaction codes", v179, v182);

            NSErrorUserInfoKey v169 = NSLocalizedDescriptionKey;
            id v14 = v197;
          }
          int v150 = (void *)v199;
          id v183 = objc_alloc((Class)NSError);
          id v66 = +[NSString stringWithUTF8String:"nfcd"];
          v220[0] = v169;
          uint64_t v184 = +[NSString stringWithUTF8String:"Commmand Error"];
          v221[0] = v184;
          v221[1] = &off_100320668;
          v220[1] = @"Line";
          v220[2] = @"Method";
          id v126 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:")];
          v221[2] = v126;
          v220[3] = v195;
          id v185 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:"), 1048];
          v221[3] = v185;
          char v186 = +[NSDictionary dictionaryWithObjects:v221 forKeys:v220 count:4];
          id v41 = [v183 initWithDomain:v66 code:16 userInfo:v186];

          id v129 = (void *)v184;
          id v28 = 0;
          uint64_t v63 = v207;
LABEL_107:

          id v15 = v212;
LABEL_108:

          goto LABEL_56;
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v130 = NFLogGetLogger();
        id v14 = v197;
        if (v130)
        {
          __int16 v131 = (void (*)(uint64_t, const char *, ...))v130;
          uint64_t v132 = object_getClass(a1);
          BOOL v133 = class_isMetaClass(v132);
          int v134 = object_getClassName(a1);
          id v193 = sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:");
          uint64_t v135 = 45;
          if (v133) {
            uint64_t v135 = 43;
          }
          v131(5, "%c[%{public}s %{public}s]:%i Endpoint not found", v135, v134, v193, 1031);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v136 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v136, OS_LOG_TYPE_DEFAULT))
        {
          int v137 = object_getClass(a1);
          if (class_isMetaClass(v137)) {
            int v138 = 43;
          }
          else {
            int v138 = 45;
          }
          int v139 = object_getClassName(a1);
          unsigned int v140 = sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:");
          *(_DWORD *)int buf = 67109890;
          int v243 = v138;
          __int16 v244 = 2082;
          unsigned int v245 = v139;
          __int16 v246 = 2082;
          uint64_t v247 = v140;
          __int16 v248 = 1024;
          int v249 = 1031;
          _os_log_impl((void *)&_mh_execute_header, v136, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Endpoint not found", buf, 0x22u);
        }

        id v141 = objc_alloc((Class)NSError);
        id v66 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v226 = NSLocalizedDescriptionKey;
        id v129 = +[NSString stringWithUTF8String:"Not found"];
        __int16 v227 = v129;
        id v126 = +[NSDictionary dictionaryWithObjects:&v227 forKeys:&v226 count:1];
        id v41 = [v141 initWithDomain:v66 code:65 userInfo:v126];
        id v28 = 0;
      }
      else
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v104 = NFLogGetLogger();
        if (v104)
        {
          id v105 = (void (*)(uint64_t, const char *, ...))v104;
          unsigned int v106 = object_getClass(a1);
          BOOL v107 = class_isMetaClass(v106);
          id v108 = v14;
          id v109 = object_getClassName(a1);
          __int16 v110 = sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:");
          id v111 = [v16 identifier];
          id v188 = v109;
          uint64_t v112 = 45;
          if (v107) {
            uint64_t v112 = 43;
          }
          id v14 = v108;
          v105(3, "%c[%{public}s %{public}s]:%i Failed to select %{public}@", v112, v188, v110, 1013, v111);

          id v16 = v210;
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v113 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v113, OS_LOG_TYPE_ERROR))
        {
          long long v114 = object_getClass(a1);
          if (class_isMetaClass(v114)) {
            int v115 = 43;
          }
          else {
            int v115 = 45;
          }
          long long v116 = object_getClassName(a1);
          int v117 = sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:");
          uint64_t v118 = [v16 identifier];
          *(_DWORD *)int buf = 67110146;
          int v243 = v115;
          __int16 v244 = 2082;
          unsigned int v245 = v116;
          __int16 v246 = 2082;
          uint64_t v247 = v117;
          __int16 v248 = 1024;
          int v249 = 1013;
          __int16 v250 = 2114;
          CFStringRef v251 = v118;
          _os_log_impl((void *)&_mh_execute_header, v113, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select %{public}@", buf, 0x2Cu);

          id v16 = v210;
        }

        id v119 = objc_alloc((Class)NSError);
        uint64_t v120 = +[NSString stringWithUTF8String:"nfcd"];
        long long v121 = (void *)v120;
        if (v28)
        {
          uint64_t v211 = (void *)v120;
          id v198 = v14;
          id v122 = [v28 code];
          v234[0] = NSLocalizedDescriptionKey;
          id v123 = v119;
          if ((uint64_t)[v28 code] > 70) {
            uint64_t v124 = 71;
          }
          else {
            uint64_t v124 = (uint64_t)[v28 code];
          }
          uint64_t v146 = +[NSString stringWithUTF8String:off_100308230[v124]];
          v235[0] = v146;
          v235[1] = v28;
          v234[1] = NSUnderlyingErrorKey;
          v234[2] = @"Line";
          v235[2] = &off_100320620;
          v234[3] = @"Method";
          id v126 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:")];
          v235[3] = v126;
          v234[4] = NSDebugDescriptionErrorKey;
          id v147 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:"), 1014];
          void v235[4] = v147;
          BOOL v148 = +[NSDictionary dictionaryWithObjects:v235 forKeys:v234 count:5];
          unsigned int v149 = v123;
          id v66 = v211;
          id v41 = [v149 initWithDomain:v211 code:v122 userInfo:v148];

          id v129 = (void *)v146;
          uint64_t v206 = 0;
          id v14 = v198;
        }
        else
        {
          v232[0] = NSLocalizedDescriptionKey;
          uint64_t v142 = +[NSString stringWithUTF8String:"Stack Error"];
          v233[0] = v142;
          v233[1] = &off_100320620;
          v232[1] = @"Line";
          v232[2] = @"Method";
          id v143 = v119;
          id v126 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:")];
          v233[2] = v126;
          v232[3] = NSDebugDescriptionErrorKey;
          id v144 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("setupContactlessTransactionCodes:wiredTransactionCodes:forIdentifier:onApplet:authorization:uid:"), 1014];
          v233[3] = v144;
          uint64_t v145 = +[NSDictionary dictionaryWithObjects:v233 forKeys:v232 count:4];
          id v41 = [v143 initWithDomain:v121 code:15 userInfo:v145];

          id v129 = (void *)v142;
          uint64_t v206 = 0;
          id v66 = v121;
        }
      }
    }
    uint64_t v63 = v207;
    int v150 = (void *)v199;
    goto LABEL_107;
  }
  id v41 = 0;
  uint64_t v63 = v207;
LABEL_57:

  return v41;
}

id sub_10024CE74(void *a1, uint64_t a2, void *a3, void *a4)
{
  id v68 = a3;
  id v67 = a4;
  if (!a1) {
    goto LABEL_53;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    unint64_t v8 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(a1);
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(a1);
    uint64_t Name = sel_getName("activateKeys:forIdentifiers:onApplet:");
    if (a2) {
      CFStringRef v13 = &stru_100309C40;
    }
    else {
      CFStringRef v13 = @"de";
    }
    CFStringRef v65 = v13;
    uint64_t v14 = 45;
    if (isMetaClass) {
      uint64_t v14 = 43;
    }
    v8(6, "%c[%{public}s %{public}s]:%i Temporary %{public}@activation for keys %{public}@", v14, ClassName, Name, 1058, v65, v68);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v15 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    id v16 = object_getClass(a1);
    if (class_isMetaClass(v16)) {
      int v17 = 43;
    }
    else {
      int v17 = 45;
    }
    unsigned __int8 v18 = object_getClassName(a1);
    BOOL v19 = sel_getName("activateKeys:forIdentifiers:onApplet:");
    *(_DWORD *)int buf = 67110402;
    if (a2) {
      CFStringRef v20 = &stru_100309C40;
    }
    else {
      CFStringRef v20 = @"de";
    }
    int v86 = v17;
    __int16 v87 = 2082;
    BOOL v88 = v18;
    __int16 v89 = 2082;
    id v90 = v19;
    __int16 v91 = 1024;
    int v92 = 1058;
    __int16 v93 = 2114;
    CFStringRef v94 = v20;
    __int16 v95 = 2114;
    id v96 = v68;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Temporary %{public}@activation for keys %{public}@", buf, 0x36u);
  }

  id v73 = 0;
  unsigned __int8 v21 = [a1 selectApplet:v67 error:&v73];
  id v22 = v73;
  if (v21)
  {
    if (v68)
    {
      long long v23 = sub_1002475B4(a1, 0);

      if (!v23)
      {
        long long v71 = 0u;
        long long v72 = 0u;
        long long v69 = 0u;
        long long v70 = 0u;
        id v25 = v68;
        id v51 = [v25 countByEnumeratingWithState:&v69 objects:v76 count:16];
        if (v51)
        {
          id v52 = v51;
          uint64_t v53 = *(void *)v70;
          while (2)
          {
            for (i = 0; i != v52; i = (char *)i + 1)
            {
              if (*(void *)v70 != v53) {
                objc_enumerationMutation(v25);
              }
              uint64_t v55 = sub_100248584(a1, *(void **)(*((void *)&v69 + 1) + 8 * i), a2);
              if (v55)
              {
                id v22 = (id)v55;
                id v58 = objc_alloc((Class)NSError);
                id v46 = +[NSString stringWithUTF8String:"nfcd"];
                id v59 = [v22 code];
                v74[0] = NSLocalizedDescriptionKey;
                id v66 = v59;
                if ((uint64_t)[v22 code] > 70) {
                  uint64_t v60 = 71;
                }
                else {
                  uint64_t v60 = (uint64_t)[v22 code];
                }
                id v47 = +[NSString stringWithUTF8String:off_100308230[v60]];
                v75[0] = v47;
                v75[1] = v22;
                v74[1] = NSUnderlyingErrorKey;
                v74[2] = @"Line";
                v75[2] = &off_1003206C8;
                v74[3] = @"Method";
                id v48 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("activateKeys:forIdentifiers:onApplet:")];
                v75[3] = v48;
                void v74[4] = NSDebugDescriptionErrorKey;
                id v63 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("activateKeys:forIdentifiers:onApplet:"), 1082];
                void v75[4] = v63;
                uint64_t v64 = +[NSDictionary dictionaryWithObjects:v75 forKeys:v74 count:5];
                id v49 = [v58 initWithDomain:v46 code:v66 userInfo:v64];

                goto LABEL_58;
              }
            }
            id v52 = [v25 countByEnumeratingWithState:&v69 objects:v76 count:16];
            if (v52) {
              continue;
            }
            break;
          }
        }
        id v49 = 0;
        goto LABEL_59;
      }
      id v24 = objc_alloc((Class)NSError);
      id v25 = +[NSString stringWithUTF8String:"nfcd"];
      id v26 = [v23 code];
      v77[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[v23 code] > 70) {
        uint64_t v27 = 71;
      }
      else {
        uint64_t v27 = (uint64_t)[v23 code];
      }
      id v46 = +[NSString stringWithUTF8String:off_100308230[v27]];
      v78[0] = v46;
      v78[1] = v23;
      v77[1] = NSUnderlyingErrorKey;
      v77[2] = @"Line";
      v78[2] = &off_1003206B0;
      v77[3] = @"Method";
      id v47 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("activateKeys:forIdentifiers:onApplet:")];
      v78[3] = v47;
      v77[4] = NSDebugDescriptionErrorKey;
      id v48 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("activateKeys:forIdentifiers:onApplet:"), 1077];
      v78[4] = v48;
      uint64_t v56 = v78;
      id v57 = v77;
      goto LABEL_56;
    }
    long long v23 = sub_1002475B4(a1, a2);

    if (v23)
    {
      id v24 = objc_alloc((Class)NSError);
      id v25 = +[NSString stringWithUTF8String:"nfcd"];
      id v26 = [v23 code];
      v79[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[v23 code] > 70) {
        uint64_t v45 = 71;
      }
      else {
        uint64_t v45 = (uint64_t)[v23 code];
      }
      id v46 = +[NSString stringWithUTF8String:off_100308230[v45]];
      v80[0] = v46;
      v80[1] = v23;
      v79[1] = NSUnderlyingErrorKey;
      v79[2] = @"Line";
      v80[2] = &off_100320698;
      v79[3] = @"Method";
      id v47 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("activateKeys:forIdentifiers:onApplet:")];
      v80[3] = v47;
      void v79[4] = NSDebugDescriptionErrorKey;
      id v48 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("activateKeys:forIdentifiers:onApplet:"), 1071];
      void v80[4] = v48;
      uint64_t v56 = v80;
      id v57 = v79;
LABEL_56:
      id v61 = +[NSDictionary dictionaryWithObjects:v56 forKeys:v57 count:5];
      id v49 = [v24 initWithDomain:v25 code:v26 userInfo:v61];

      goto LABEL_57;
    }
LABEL_53:
    id v49 = 0;
    goto LABEL_60;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v28 = NFLogGetLogger();
  if (v28)
  {
    id v29 = (void (*)(uint64_t, const char *, ...))v28;
    id v30 = object_getClass(a1);
    BOOL v31 = class_isMetaClass(v30);
    unsigned int v32 = object_getClassName(a1);
    BOOL v33 = sel_getName("activateKeys:forIdentifiers:onApplet:");
    id v34 = [v67 identifier];
    uint64_t v35 = 45;
    if (v31) {
      uint64_t v35 = 43;
    }
    v29(3, "%c[%{public}s %{public}s]:%i Failed to select %{public}@", v35, v32, v33, 1063, v34);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  unsigned int v36 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
  {
    id v37 = object_getClass(a1);
    if (class_isMetaClass(v37)) {
      int v38 = 43;
    }
    else {
      int v38 = 45;
    }
    id v39 = object_getClassName(a1);
    __int16 v40 = sel_getName("activateKeys:forIdentifiers:onApplet:");
    id v41 = [v67 identifier];
    *(_DWORD *)int buf = 67110146;
    int v86 = v38;
    __int16 v87 = 2082;
    BOOL v88 = v39;
    __int16 v89 = 2082;
    id v90 = v40;
    __int16 v91 = 1024;
    int v92 = 1063;
    __int16 v93 = 2114;
    CFStringRef v94 = v41;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select %{public}@", buf, 0x2Cu);
  }
  id v42 = objc_alloc((Class)NSError);
  long long v23 = +[NSString stringWithUTF8String:"nfcd"];
  if (v22)
  {
    id v43 = [v22 code];
    v83[0] = NSLocalizedDescriptionKey;
    if ((uint64_t)[v22 code] > 70) {
      uint64_t v44 = 71;
    }
    else {
      uint64_t v44 = (uint64_t)[v22 code];
    }
    id v46 = +[NSString stringWithUTF8String:off_100308230[v44]];
    v84[0] = v46;
    v84[1] = v22;
    v83[1] = NSUnderlyingErrorKey;
    v83[2] = @"Line";
    v84[2] = &off_100320680;
    v83[3] = @"Method";
    id v47 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("activateKeys:forIdentifiers:onApplet:")];
    v84[3] = v47;
    v83[4] = NSDebugDescriptionErrorKey;
    id v48 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("activateKeys:forIdentifiers:onApplet:"), 1064];
    v84[4] = v48;
    int v50 = +[NSDictionary dictionaryWithObjects:v84 forKeys:v83 count:5];
    id v49 = [v42 initWithDomain:v23 code:v43 userInfo:v50];

    id v25 = v23;
    goto LABEL_58;
  }
  v81[0] = NSLocalizedDescriptionKey;
  id v25 = +[NSString stringWithUTF8String:"Stack Error"];
  v82[0] = v25;
  v82[1] = &off_100320680;
  v81[1] = @"Line";
  v81[2] = @"Method";
  id v46 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("activateKeys:forIdentifiers:onApplet:")];
  v82[2] = v46;
  v81[3] = NSDebugDescriptionErrorKey;
  id v47 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("activateKeys:forIdentifiers:onApplet:"), 1064];
  v82[3] = v47;
  id v48 = +[NSDictionary dictionaryWithObjects:v82 forKeys:v81 count:4];
  id v49 = [v42 initWithDomain:v23 code:15 userInfo:v48];
LABEL_57:
  id v22 = v23;
LABEL_58:

  id v25 = v22;
LABEL_59:

LABEL_60:

  return v49;
}

id sub_10024D9AC(void *a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (!a1)
  {
    id v31 = 0;
    goto LABEL_84;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v7 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(a1);
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(a1);
    uint64_t Name = sel_getName("activateKeys:aidsAndKeys:");
    if (a2) {
      CFStringRef v12 = &stru_100309C40;
    }
    else {
      CFStringRef v12 = @"de";
    }
    CFStringRef v94 = v12;
    uint64_t v13 = 45;
    if (isMetaClass) {
      uint64_t v13 = 43;
    }
    v7(6, "%c[%{public}s %{public}s]:%i Temporary %{public}@activation for keys %{public}@", v13, ClassName, Name, 1092, v94, v5);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v14 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    id v15 = object_getClass(a1);
    if (class_isMetaClass(v15)) {
      int v16 = 43;
    }
    else {
      int v16 = 45;
    }
    int v17 = object_getClassName(a1);
    unsigned __int8 v18 = sel_getName("activateKeys:aidsAndKeys:");
    *(_DWORD *)int buf = 67110402;
    if (a2) {
      CFStringRef v19 = &stru_100309C40;
    }
    else {
      CFStringRef v19 = @"de";
    }
    int v114 = v16;
    __int16 v115 = 2082;
    long long v116 = v17;
    __int16 v117 = 2082;
    uint64_t v118 = v18;
    __int16 v119 = 1024;
    int v120 = 1092;
    __int16 v121 = 2114;
    CFStringRef v122 = v19;
    __int16 v123 = 2114;
    id v124 = v5;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Temporary %{public}@activation for keys %{public}@", buf, 0x36u);
  }

  CFStringRef v20 = [v5 keyEnumerator];
  uint64_t v21 = [v20 nextObject];
  if (!v21)
  {
LABEL_25:
    id v31 = 0;
    goto LABEL_83;
  }
  id v22 = (__CFString *)v21;
  while (1)
  {
    sub_1002473C8(a1, v22);
    long long v23 = (__CFString *)objc_claimAutoreleasedReturnValue();
    if (!v23)
    {
      uint64_t v27 = 0;
LABEL_28:
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v32 = NFLogGetLogger();
      if (v32)
      {
        BOOL v33 = (void (*)(uint64_t, const char *, ...))v32;
        id v34 = object_getClass(a1);
        BOOL v35 = class_isMetaClass(v34);
        id v90 = object_getClassName(a1);
        __int16 v91 = sel_getName("activateKeys:aidsAndKeys:");
        uint64_t v36 = 45;
        if (v35) {
          uint64_t v36 = 43;
        }
        v33(3, "%c[%{public}s %{public}s]:%i Failed to select %{public}@", v36, v90, v91, 1102, v22);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v37 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
      {
        int v38 = object_getClass(a1);
        if (class_isMetaClass(v38)) {
          int v39 = 43;
        }
        else {
          int v39 = 45;
        }
        __int16 v40 = object_getClassName(a1);
        id v41 = sel_getName("activateKeys:aidsAndKeys:");
        *(_DWORD *)int buf = 67110146;
        int v114 = v39;
        __int16 v115 = 2082;
        long long v116 = v40;
        __int16 v117 = 2082;
        uint64_t v118 = v41;
        __int16 v119 = 1024;
        int v120 = 1102;
        __int16 v121 = 2114;
        CFStringRef v122 = v22;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select %{public}@", buf, 0x2Cu);
      }

      id v42 = objc_alloc((Class)NSError);
      id v43 = +[NSString stringWithUTF8String:"nfcd"];
      if (!v27)
      {
        v109[0] = NSLocalizedDescriptionKey;
        uint64_t v100 = +[NSString stringWithUTF8String:"Stack Error"];
        v110[0] = v100;
        v110[1] = &off_1003206E0;
        v109[1] = @"Line";
        v109[2] = @"Method";
        id v99 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("activateKeys:aidsAndKeys:")];
        v110[2] = v99;
        v109[3] = NSDebugDescriptionErrorKey;
        id v70 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("activateKeys:aidsAndKeys:"), 1103];
        v110[3] = v70;
        id v71 = +[NSDictionary dictionaryWithObjects:v110 forKeys:v109 count:4];
        id v31 = [v42 initWithDomain:v43 code:15 userInfo:v71];
        uint64_t v27 = 0;
LABEL_78:
        uint64_t v28 = v23;
        long long v23 = v22;
        goto LABEL_82;
      }
      id v96 = [v27 code];
      v111[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[v27 code] > 70) {
        uint64_t v44 = 71;
      }
      else {
        uint64_t v44 = (uint64_t)[v27 code];
      }
      uint64_t v100 = +[NSString stringWithUTF8String:off_100308230[v44]];
      v112[0] = v100;
      v112[1] = v27;
      v111[1] = NSUnderlyingErrorKey;
      v111[2] = @"Line";
      v112[2] = &off_1003206E0;
      v111[3] = @"Method";
      id v99 = [[objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("activateKeys:aidsAndKeys:")];
      v112[3] = v99;
      v111[4] = NSDebugDescriptionErrorKey;
      id v70 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("activateKeys:aidsAndKeys:"), 1103];
      void v112[4] = v70;
      id v71 = +[NSDictionary dictionaryWithObjects:v112 forKeys:v111 count:5];
      uint64_t v85 = v42;
      int v86 = v43;
      id v87 = v96;
LABEL_77:
      id v31 = [v85 initWithDomain:v86 code:v87 userInfo:v71];
      goto LABEL_78;
    }
    id v102 = 0;
    unsigned __int8 v24 = [a1 selectApplet:v23 error:&v102];
    id v25 = v102;
    id v26 = v25;
    if ((v24 & 1) == 0)
    {
      uint64_t v27 = v25;
      goto LABEL_28;
    }
    uint64_t v27 = sub_1002475B4(a1, 0);

    if (v27)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v45 = NFLogGetLogger();
      if (v45)
      {
        id v46 = (void (*)(uint64_t, const char *, ...))v45;
        id v47 = object_getClass(a1);
        BOOL v48 = class_isMetaClass(v47);
        id v49 = object_getClassName(a1);
        int v92 = sel_getName("activateKeys:aidsAndKeys:");
        uint64_t v50 = 45;
        if (v48) {
          uint64_t v50 = 43;
        }
        v46(3, "%c[%{public}s %{public}s]:%i Failed to Disable all keys", v50, v49, v92, 1109);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v51 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
      {
        id v52 = object_getClass(a1);
        if (class_isMetaClass(v52)) {
          int v53 = 43;
        }
        else {
          int v53 = 45;
        }
        id v54 = object_getClassName(a1);
        uint64_t v55 = sel_getName("activateKeys:aidsAndKeys:");
        *(_DWORD *)int buf = 67109890;
        int v114 = v53;
        __int16 v115 = 2082;
        long long v116 = v54;
        __int16 v117 = 2082;
        uint64_t v118 = v55;
        __int16 v119 = 1024;
        int v120 = 1109;
        _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to Disable all keys", buf, 0x22u);
      }

      id v97 = objc_alloc((Class)NSError);
      id v43 = +[NSString stringWithUTF8String:"nfcd"];
      id v56 = [v27 code];
      v107[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[v27 code] > 70) {
        uint64_t v57 = 71;
      }
      else {
        uint64_t v57 = (uint64_t)[v27 code];
      }
      uint64_t v100 = +[NSString stringWithUTF8String:off_100308230[v57]];
      v108[0] = v100;
      v108[1] = v27;
      v107[1] = NSUnderlyingErrorKey;
      v107[2] = @"Line";
      v108[2] = &off_1003206F8;
      v107[3] = @"Method";
      id v99 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("activateKeys:aidsAndKeys:")];
      v108[3] = v99;
      v107[4] = NSDebugDescriptionErrorKey;
      id v70 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("activateKeys:aidsAndKeys:"), 1110];
      void v108[4] = v70;
      id v71 = +[NSDictionary dictionaryWithObjects:v108 forKeys:v107 count:5];
      uint64_t v85 = v97;
      int v86 = v43;
      id v87 = v56;
      goto LABEL_77;
    }
    uint64_t v28 = [v5 objectForKey:v22];
    if (!v28)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v58 = NFLogGetLogger();
      if (v58)
      {
        id v59 = (void (*)(uint64_t, const char *, ...))v58;
        uint64_t v60 = object_getClass(a1);
        BOOL v61 = class_isMetaClass(v60);
        id v62 = object_getClassName(a1);
        __int16 v93 = sel_getName("activateKeys:aidsAndKeys:");
        uint64_t v63 = 45;
        if (v61) {
          uint64_t v63 = 43;
        }
        v59(3, "%c[%{public}s %{public}s]:%i Invalid keyIdent", v63, v62, v93, 1116);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v64 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
      {
        CFStringRef v65 = object_getClass(a1);
        if (class_isMetaClass(v65)) {
          int v66 = 43;
        }
        else {
          int v66 = 45;
        }
        id v67 = object_getClassName(a1);
        id v68 = sel_getName("activateKeys:aidsAndKeys:");
        *(_DWORD *)int buf = 67109890;
        int v114 = v66;
        __int16 v115 = 2082;
        long long v116 = v67;
        __int16 v117 = 2082;
        uint64_t v118 = v68;
        __int16 v119 = 1024;
        int v120 = 1116;
        _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid keyIdent", buf, 0x22u);
      }

      id v69 = objc_alloc((Class)NSError);
      id v43 = +[NSString stringWithUTF8String:"nfcd"];
      v105[0] = NSLocalizedDescriptionKey;
      uint64_t v100 = +[NSString stringWithUTF8String:"Invalid Parameter"];
      v106[0] = v100;
      v106[1] = &off_100320710;
      v105[1] = @"Line";
      v105[2] = @"Method";
      id v99 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("activateKeys:aidsAndKeys:")];
      v106[2] = v99;
      v105[3] = NSDebugDescriptionErrorKey;
      id v70 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("activateKeys:aidsAndKeys:"), 1117];
      v106[3] = v70;
      id v71 = +[NSDictionary dictionaryWithObjects:v106 forKeys:v105 count:4];
      id v31 = [v69 initWithDomain:v43 code:10 userInfo:v71];
      goto LABEL_81;
    }
    uint64_t v29 = sub_100248584(a1, v28, a2);
    if (v29) {
      break;
    }

    uint64_t v30 = [v20 nextObject];

    id v22 = (__CFString *)v30;
    if (!v30) {
      goto LABEL_25;
    }
  }
  id v43 = (void *)v29;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v72 = NFLogGetLogger();
  if (v72)
  {
    id v73 = (void (*)(uint64_t, const char *, ...))v72;
    int v74 = object_getClass(a1);
    BOOL v75 = class_isMetaClass(v74);
    CFStringRef v101 = object_getClassName(a1);
    id v76 = sel_getName("activateKeys:aidsAndKeys:");
    uint64_t v77 = 45;
    if (v75) {
      uint64_t v77 = 43;
    }
    v73(3, "%c[%{public}s %{public}s]:%i Failed to activate keyIdentifier %@", v77, v101, v76, 1122, v28);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v78 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
  {
    unsigned int v79 = object_getClass(a1);
    if (class_isMetaClass(v79)) {
      int v80 = 43;
    }
    else {
      int v80 = 45;
    }
    id v81 = object_getClassName(a1);
    id v82 = sel_getName("activateKeys:aidsAndKeys:");
    *(_DWORD *)int buf = 67110146;
    int v114 = v80;
    __int16 v115 = 2082;
    long long v116 = v81;
    __int16 v117 = 2082;
    uint64_t v118 = v82;
    __int16 v119 = 1024;
    int v120 = 1122;
    __int16 v121 = 2112;
    CFStringRef v122 = v28;
    _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to activate keyIdentifier %@", buf, 0x2Cu);
  }

  id v98 = objc_alloc((Class)NSError);
  uint64_t v83 = +[NSString stringWithUTF8String:"nfcd"];
  id v95 = [v43 code];
  v103[0] = NSLocalizedDescriptionKey;
  uint64_t v100 = (void *)v83;
  if ((uint64_t)[v43 code] > 70) {
    uint64_t v84 = 71;
  }
  else {
    uint64_t v84 = (uint64_t)[v43 code];
  }
  id v99 = +[NSString stringWithUTF8String:off_100308230[v84]];
  v104[0] = v99;
  v104[1] = v43;
  v103[1] = NSUnderlyingErrorKey;
  v103[2] = @"Line";
  v104[2] = &off_100320728;
  v103[3] = @"Method";
  id v70 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("activateKeys:aidsAndKeys:")];
  v104[3] = v70;
  v103[4] = NSDebugDescriptionErrorKey;
  id v71 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("activateKeys:aidsAndKeys:"), 1123];
  void v104[4] = v71;
  BOOL v88 = +[NSDictionary dictionaryWithObjects:v104 forKeys:v103 count:5];
  id v31 = [v98 initWithDomain:v100 code:v95 userInfo:v88];

LABEL_81:
  uint64_t v27 = v22;
LABEL_82:

LABEL_83:
LABEL_84:

  return v31;
}

id sub_10024E7B8(void *a1, void *a2)
{
  id v3 = a2;
  id v97 = v3;
  if (a1)
  {
    id v4 = v3;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(a1);
      uint64_t Name = sel_getName("resetVolatileConfigOnApplet:");
      int v11 = [v4 identifier];
      uint64_t v12 = 45;
      if (isMetaClass) {
        uint64_t v12 = 43;
      }
      v6(6, "%c[%{public}s %{public}s]:%i resetting keys on %{public}@", v12, ClassName, Name, 1132, v11);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v13 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = object_getClass(a1);
      if (class_isMetaClass(v14)) {
        int v15 = 43;
      }
      else {
        int v15 = 45;
      }
      int v16 = object_getClassName(a1);
      int v17 = sel_getName("resetVolatileConfigOnApplet:");
      unsigned __int8 v18 = [v4 identifier];
      *(_DWORD *)int buf = 67110146;
      *(_DWORD *)&uint8_t buf[4] = v15;
      *(_WORD *)__int16 v110 = 2082;
      *(void *)&v110[2] = v16;
      *(_WORD *)&v110[10] = 2082;
      *(void *)&v110[12] = v17;
      *(_WORD *)&v110[20] = 1024;
      *(_DWORD *)&v110[22] = 1132;
      *(_WORD *)&v110[26] = 2114;
      *(void *)&v110[28] = v18;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i resetting keys on %{public}@", buf, 0x2Cu);
    }
    id v98 = 0;
    unsigned __int8 v19 = [a1 selectApplet:v4 error:&v98];
    id v20 = v98;
    if ((v19 & 1) == 0)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v25 = NFLogGetLogger();
      if (v25)
      {
        id v26 = (void (*)(uint64_t, const char *, ...))v25;
        uint64_t v27 = object_getClass(a1);
        BOOL v28 = class_isMetaClass(v27);
        uint64_t v29 = object_getClassName(a1);
        uint64_t v30 = sel_getName("resetVolatileConfigOnApplet:");
        id v31 = [v4 identifier];
        uint64_t v32 = 45;
        if (v28) {
          uint64_t v32 = 43;
        }
        v26(3, "%c[%{public}s %{public}s]:%i Failed to select %{public}@", v32, v29, v30, 1137, v31);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      BOOL v33 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      {
        id v34 = object_getClass(a1);
        if (class_isMetaClass(v34)) {
          int v35 = 43;
        }
        else {
          int v35 = 45;
        }
        uint64_t v36 = object_getClassName(a1);
        id v37 = sel_getName("resetVolatileConfigOnApplet:");
        int v38 = [v4 identifier];
        *(_DWORD *)int buf = 67110146;
        *(_DWORD *)&uint8_t buf[4] = v35;
        *(_WORD *)__int16 v110 = 2082;
        *(void *)&v110[2] = v36;
        *(_WORD *)&v110[10] = 2082;
        *(void *)&v110[12] = v37;
        *(_WORD *)&v110[20] = 1024;
        *(_DWORD *)&v110[22] = 1137;
        *(_WORD *)&v110[26] = 2114;
        *(void *)&v110[28] = v38;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select %{public}@", buf, 0x2Cu);
      }
      id v39 = objc_alloc((Class)NSError);
      id v22 = +[NSString stringWithUTF8String:"nfcd"];
      if (v20)
      {
        id v40 = [v20 code];
        v102[0] = NSLocalizedDescriptionKey;
        if ((uint64_t)[v20 code] > 70) {
          uint64_t v41 = 71;
        }
        else {
          uint64_t v41 = (uint64_t)[v20 code];
        }
        BOOL v75 = +[NSString stringWithUTF8String:off_100308230[v41]];
        v103[0] = v75;
        v103[1] = v20;
        v102[1] = NSUnderlyingErrorKey;
        v102[2] = @"Line";
        v103[2] = &off_100320740;
        v102[3] = @"Method";
        id v76 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("resetVolatileConfigOnApplet:")];
        v103[3] = v76;
        void v102[4] = NSDebugDescriptionErrorKey;
        id v77 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("resetVolatileConfigOnApplet:"), 1138];
        v103[4] = v77;
        id v78 = +[NSDictionary dictionaryWithObjects:v103 forKeys:v102 count:5];
        id v24 = [v39 initWithDomain:v22 code:v40 userInfo:v78];
      }
      else
      {
        v100[0] = NSLocalizedDescriptionKey;
        uint64_t v57 = +[NSString stringWithUTF8String:"Stack Error"];
        v101[0] = v57;
        v101[1] = &off_100320740;
        v100[1] = @"Line";
        v100[2] = @"Method";
        id v58 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("resetVolatileConfigOnApplet:")];
        v101[2] = v58;
        v100[3] = NSDebugDescriptionErrorKey;
        id v59 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("resetVolatileConfigOnApplet:"), 1138];
        v101[3] = v59;
        uint64_t v60 = +[NSDictionary dictionaryWithObjects:v101 forKeys:v100 count:4];
        id v24 = [v39 initWithDomain:v22 code:15 userInfo:v60];
      }
      goto LABEL_64;
    }
    id v96 = +[NFTLV TLVWithTag:144 value:0];
    uint64_t v21 = [v96 asData];
    id v99 = 0;
    id v22 = [a1 sendCommandWithClass:128 instruction:52 p1:0 p2:0 data:v21 error:&v99];
    id v23 = v99;

    if (v22)
    {
      if ([v22 status] == 36864)
      {
        id v24 = 0;
LABEL_63:

LABEL_64:
        goto LABEL_65;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v61 = NFLogGetLogger();
      if (v61)
      {
        id v62 = (void (*)(uint64_t, const char *, ...))v61;
        uint64_t v63 = object_getClass(a1);
        BOOL v64 = class_isMetaClass(v63);
        CFStringRef v65 = object_getClassName(a1);
        int v66 = sel_getName("_resetVolatileVisibilityOnAllEndpoints");
        uint64_t v94 = [v22 status];
        uint64_t v67 = 45;
        if (v64) {
          uint64_t v67 = 43;
        }
        v62(3, "%c[%{public}s %{public}s]:%i Returned error: 0x%04x", v67, v65, v66, 685, v94);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v68 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
      {
        id v69 = object_getClass(a1);
        if (class_isMetaClass(v69)) {
          int v70 = 43;
        }
        else {
          int v70 = 45;
        }
        id v71 = object_getClassName(a1);
        uint64_t v72 = sel_getName("_resetVolatileVisibilityOnAllEndpoints");
        unsigned int v73 = [v22 status];
        *(_DWORD *)int buf = 67110146;
        *(_DWORD *)&uint8_t buf[4] = v70;
        *(_WORD *)__int16 v110 = 2082;
        *(void *)&v110[2] = v71;
        *(_WORD *)&v110[10] = 2082;
        *(void *)&v110[12] = v72;
        *(_WORD *)&v110[20] = 1024;
        *(_DWORD *)&v110[22] = 685;
        *(_WORD *)&v110[26] = 1024;
        *(_DWORD *)&v110[28] = v73;
        _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Returned error: 0x%04x", buf, 0x28u);
      }

      id v53 = objc_alloc((Class)NSError);
      id v54 = +[NSString stringWithUTF8String:"nfcd"];
      if (v23)
      {
        id v95 = v53;
        id v55 = [v23 code];
        NSErrorUserInfoKey v104 = NSLocalizedDescriptionKey;
        if ((uint64_t)[v23 code] > 70) {
          uint64_t v74 = 71;
        }
        else {
          uint64_t v74 = (uint64_t)[v23 code];
        }
        unsigned int v79 = +[NSString stringWithUTF8String:off_100308230[v74]];
        *(void *)int buf = v79;
        *(void *)__int16 v110 = v23;
        CFStringRef v105 = (const __CFString *)NSUnderlyingErrorKey;
        CFStringRef v106 = @"Line";
        *(void *)&v110[8] = &off_1003203F8;
        CFStringRef v107 = @"Method";
        id v80 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_resetVolatileVisibilityOnAllEndpoints")];
        *(void *)&v110[16] = v80;
        NSErrorUserInfoKey v108 = NSDebugDescriptionErrorKey;
        id v84 = objc_alloc((Class)NSString);
        uint64_t v85 = sel_getName("_resetVolatileVisibilityOnAllEndpoints");
        uint64_t v86 = 687;
LABEL_61:
        id v87 = [v84 initWithFormat:v85, v86];
        *(void *)&v110[24] = v87;
        BOOL v88 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v104 count:5];
        __int16 v89 = v95;
        id v90 = v54;
        uint64_t v91 = (uint64_t)v55;
        goto LABEL_62;
      }
      NSErrorUserInfoKey v104 = NSLocalizedDescriptionKey;
      unsigned int v79 = +[NSString stringWithUTF8String:"Commmand Error"];
      *(void *)int buf = v79;
      *(void *)__int16 v110 = &off_1003203F8;
      CFStringRef v105 = @"Line";
      CFStringRef v106 = @"Method";
      id v80 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_resetVolatileVisibilityOnAllEndpoints")];
      *(void *)&v110[8] = v80;
      CFStringRef v107 = (const __CFString *)NSDebugDescriptionErrorKey;
      id v81 = objc_alloc((Class)NSString);
      id v82 = sel_getName("_resetVolatileVisibilityOnAllEndpoints");
      uint64_t v83 = 687;
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v42 = NFLogGetLogger();
      if (v42)
      {
        id v43 = (void (*)(uint64_t, const char *, ...))v42;
        uint64_t v44 = object_getClass(a1);
        BOOL v45 = class_isMetaClass(v44);
        id v46 = object_getClassName(a1);
        __int16 v93 = sel_getName("_resetVolatileVisibilityOnAllEndpoints");
        uint64_t v47 = 45;
        if (v45) {
          uint64_t v47 = 43;
        }
        v43(3, "%c[%{public}s %{public}s]:%i Command (%02X) failed; error: %{public}@",
          v47,
          v46,
          v93,
          681,
          52,
          v23);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      BOOL v48 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
      {
        id v49 = object_getClass(a1);
        if (class_isMetaClass(v49)) {
          int v50 = 43;
        }
        else {
          int v50 = 45;
        }
        id v51 = object_getClassName(a1);
        id v52 = sel_getName("_resetVolatileVisibilityOnAllEndpoints");
        *(_DWORD *)int buf = 67110402;
        *(_DWORD *)&uint8_t buf[4] = v50;
        *(_WORD *)__int16 v110 = 2082;
        *(void *)&v110[2] = v51;
        *(_WORD *)&v110[10] = 2082;
        *(void *)&v110[12] = v52;
        *(_WORD *)&v110[20] = 1024;
        *(_DWORD *)&v110[22] = 681;
        *(_WORD *)&v110[26] = 1024;
        *(_DWORD *)&v110[28] = 52;
        *(_WORD *)&v110[32] = 2114;
        *(void *)&v110[34] = v23;
        _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Command (%02X) failed; error: %{public}@",
          buf,
          0x32u);
      }

      id v53 = objc_alloc((Class)NSError);
      id v54 = +[NSString stringWithUTF8String:"nfcd"];
      if (v23)
      {
        id v95 = v53;
        id v55 = [v23 code];
        NSErrorUserInfoKey v104 = NSLocalizedDescriptionKey;
        if ((uint64_t)[v23 code] > 70) {
          uint64_t v56 = 71;
        }
        else {
          uint64_t v56 = (uint64_t)[v23 code];
        }
        unsigned int v79 = +[NSString stringWithUTF8String:off_100308230[v56]];
        *(void *)int buf = v79;
        *(void *)__int16 v110 = v23;
        CFStringRef v105 = (const __CFString *)NSUnderlyingErrorKey;
        CFStringRef v106 = @"Line";
        *(void *)&v110[8] = &off_1003203E0;
        CFStringRef v107 = @"Method";
        id v80 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_resetVolatileVisibilityOnAllEndpoints")];
        *(void *)&v110[16] = v80;
        NSErrorUserInfoKey v108 = NSDebugDescriptionErrorKey;
        id v84 = objc_alloc((Class)NSString);
        uint64_t v85 = sel_getName("_resetVolatileVisibilityOnAllEndpoints");
        uint64_t v86 = 682;
        goto LABEL_61;
      }
      NSErrorUserInfoKey v104 = NSLocalizedDescriptionKey;
      unsigned int v79 = +[NSString stringWithUTF8String:"Commmand Error"];
      *(void *)int buf = v79;
      *(void *)__int16 v110 = &off_1003203E0;
      CFStringRef v105 = @"Line";
      CFStringRef v106 = @"Method";
      id v80 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_resetVolatileVisibilityOnAllEndpoints")];
      *(void *)&v110[8] = v80;
      CFStringRef v107 = (const __CFString *)NSDebugDescriptionErrorKey;
      id v81 = objc_alloc((Class)NSString);
      id v82 = sel_getName("_resetVolatileVisibilityOnAllEndpoints");
      uint64_t v83 = 682;
    }
    id v87 = [v81 initWithFormat:@"%s:%d", v82, v83];
    *(void *)&v110[16] = v87;
    BOOL v88 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v104 count:4];
    __int16 v89 = v53;
    id v90 = v54;
    uint64_t v91 = 16;
LABEL_62:
    id v24 = [v89 initWithDomain:v90 code:v91 userInfo:v88];

    goto LABEL_63;
  }
  id v24 = 0;
LABEL_65:

  return v24;
}

void sub_10024F508(void *a1)
{
  id v1 = a1;
  id v2 = objc_alloc((Class)NSSet);
  uint64_t v3 = objc_opt_class();
  id v12 = [v2 initWithObjects:v3, objc_opt_class(), 0];
  id v4 = objc_alloc((Class)NSSet);
  uint64_t v5 = objc_opt_class();
  id v6 = [v4 initWithObjects:v5, objc_opt_class(), 0];
  [v1 setClasses:v6 forSelector:"startTNEPDeviceWithServices:optionalRecords:callback:" argumentIndex:0 ofReply:0];

  [v1 setClasses:v12 forSelector:"startTNEPDeviceWithServices:optionalRecords:callback:" argumentIndex:1 ofReply:0];
  id v7 = objc_alloc((Class)NSSet);
  uint64_t v8 = objc_opt_class();
  id v9 = [v7 initWithObjects:v8, objc_opt_class(), 0];
  [v1 setClasses:v9 forSelector:"tnepTagDeviceSendNDEFMessage:callback:" argumentIndex:0 ofReply:0];

  id v10 = [objc_alloc((Class)NSSet) initWithObjects:objc_opt_class(), 0];
  [v1 setClasses:v10 forSelector:"tnepReaderSend:callback:" argumentIndex:0 ofReply:0];

  id v11 = [objc_alloc((Class)NSSet) initWithObjects:objc_opt_class(), 0];
  [v1 setClasses:v11 forSelector:"tnepReaderSend:callback:" argumentIndex:0 ofReply:1];
}

void sub_10024F6FC(void *a1)
{
  id v1 = a1;
  id v2 = objc_alloc((Class)NSSet);
  uint64_t v3 = objc_opt_class();
  id v5 = [v2 initWithObjects:v3, objc_opt_class(), 0];
  [v1 setClasses:v5 forSelector:"tnepTagDeviceSelected:respondHandler:" argumentIndex:1 ofReply:1];
  id v4 = [objc_alloc((Class)NSSet) initWithObjects:objc_opt_class(), 0];
  [v1 setClasses:v4 forSelector:"tnepTagDeviceNDEFMessageReceived:" argumentIndex:0 ofReply:0];
}

NSXPCInterface *sub_10024F7F4()
{
  self;

  return +[NSXPCInterface interfaceWithProtocol:&OBJC_PROTOCOL___NFCCardSessionInterface];
}

NSXPCInterface *sub_10024F82C()
{
  self;

  return +[NSXPCInterface interfaceWithProtocol:&OBJC_PROTOCOL___NFCCardSessionCallbackInterface];
}

id sub_10024F870(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = v5;
  if (!a1) {
    goto LABEL_30;
  }
  if (v5)
  {
    id v53 = a3;
    id v7 = [v5 identifier];
    uint64_t v8 = [v6 packageIdentifier];
    id v9 = [v6 moduleIdentifier];
    id v55 = 0;
    id v10 = +[AppletTranslator getAppletStateAndHistory:v7 withPackage:v8 withModule:v9 withTransceiver:a1 withError:&v55];
    id v11 = v55;

    id v12 = [v10 objectForKey:@"didError"];
    if ([v12 BOOLValue])
    {
      uint64_t v13 = [v6 identifier];
      uint64_t v14 = [v6 packageIdentifier];
      int v15 = +[NSString stringWithFormat:@"Applet AID: %@, Applet PID: %@", v13, v14];
      v56[0] = @"Applet Identifier";
      [v6 identifier];
      int v16 = v51 = v10;
      v56[1] = @"FailureKey";
      v57[0] = v16;
      v57[1] = @"ttrATL";
      int v17 = +[NSDictionary dictionaryWithObjects:v57 forKeys:v56 count:2];
      sub_1001991EC((uint64_t)NFBugCapture, @"Error while getting Applet State from ATL", v15, v17);

      unsigned __int8 v18 = [v6 identifier];
      +[NFExceptionsCALogger postAnalyticsATLFailureEvent:0 aid:v18 error:v11];

      id v10 = v51;
    }
    if (v11 && [v11 code] == (id)5)
    {
      id v52 = v10;
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        id v20 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        Classuint64_t Name = object_getClassName(a1);
        uint64_t Name = sel_getName("getATLAppletState:error:");
        uint64_t v24 = 45;
        if (isMetaClass) {
          uint64_t v24 = 43;
        }
        v20(4, "%c[%{public}s %{public}s]:%i Applet is badly behaved, needs to be powercycled", v24, ClassName, Name, 54);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v25 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
      {
        id v26 = object_getClass(a1);
        if (class_isMetaClass(v26)) {
          int v27 = 43;
        }
        else {
          int v27 = 45;
        }
        BOOL v28 = object_getClassName(a1);
        uint64_t v29 = sel_getName("getATLAppletState:error:");
        *(_DWORD *)int buf = 67109890;
        int v61 = v27;
        __int16 v62 = 2082;
        uint64_t v63 = v28;
        __int16 v64 = 2082;
        CFStringRef v65 = v29;
        __int16 v66 = 1024;
        int v67 = 54;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Applet is badly behaved, needs to be powercycled", buf, 0x22u);
      }

      uint64_t v30 = [a1 powerCycleOrReset];

      if (v30 && [v30 code])
      {
        id v11 = v30;
        id v10 = v52;
      }
      else
      {

        uint64_t v44 = [v6 identifier];
        BOOL v45 = [v6 packageIdentifier];
        id v46 = [v6 moduleIdentifier];
        id v54 = 0;
        uint64_t v47 = +[AppletTranslator getAppletStateAndHistory:v44 withPackage:v45 withModule:v46 withTransceiver:a1 withError:&v54];
        id v11 = v54;

        id v10 = (void *)v47;
      }
    }
    if (v53)
    {
      id v11 = v11;
      *id v53 = v11;
    }
    goto LABEL_34;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v31 = NFLogGetLogger();
  if (v31)
  {
    uint64_t v32 = (void (*)(uint64_t, const char *, ...))v31;
    BOOL v33 = object_getClass(a1);
    BOOL v34 = class_isMetaClass(v33);
    int v35 = object_getClassName(a1);
    int v50 = sel_getName("getATLAppletState:error:");
    uint64_t v36 = 45;
    if (v34) {
      uint64_t v36 = 43;
    }
    v32(3, "%c[%{public}s %{public}s]:%i Failed to find applet", v36, v35, v50, 29);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v37 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
  {
    int v38 = object_getClass(a1);
    if (class_isMetaClass(v38)) {
      int v39 = 43;
    }
    else {
      int v39 = 45;
    }
    *(_DWORD *)int buf = 67109890;
    int v61 = v39;
    __int16 v62 = 2082;
    uint64_t v63 = object_getClassName(a1);
    __int16 v64 = 2082;
    CFStringRef v65 = sel_getName("getATLAppletState:error:");
    __int16 v66 = 1024;
    int v67 = 29;
    _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to find applet", buf, 0x22u);
  }

  if (!a3)
  {
LABEL_30:
    id v10 = 0;
    goto LABEL_35;
  }
  id v40 = objc_alloc((Class)NSError);
  id v11 = +[NSString stringWithUTF8String:"nfcd"];
  v58[0] = NSLocalizedDescriptionKey;
  id v12 = +[NSString stringWithUTF8String:"Invalid Parameter"];
  v59[0] = v12;
  v59[1] = &off_100320758;
  v58[1] = @"Line";
  void v58[2] = @"Method";
  id v41 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("getATLAppletState:error:")];
  void v59[2] = v41;
  v58[3] = NSDebugDescriptionErrorKey;
  id v42 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("getATLAppletState:error:"), 30];
  v59[3] = v42;
  id v43 = +[NSDictionary dictionaryWithObjects:v59 forKeys:v58 count:4];
  *a3 = [v40 initWithDomain:v11 code:10 userInfo:v43];

  id v10 = 0;
LABEL_34:

LABEL_35:

  return v10;
}

id sub_10024FF34(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = v5;
  if (a1)
  {
    if (v5)
    {
      id v7 = [v5 identifier];
      uint64_t v8 = [v6 packageIdentifier];
      id v9 = [v6 moduleIdentifier];
      id v40 = 0;
      id v10 = +[AppletTranslator GetAppletProperties:v7 withPackage:v8 withModule:v9 withTransceiver:a1 withError:&v40];
      id v11 = v40;

      if (v11)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          uint64_t v13 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(a1);
          BOOL isMetaClass = class_isMetaClass(Class);
          Classuint64_t Name = object_getClassName(a1);
          uint64_t Name = sel_getName("getATLAppletProperties:error:");
          uint64_t v16 = 45;
          if (isMetaClass) {
            uint64_t v16 = 43;
          }
          v13(4, "%c[%{public}s %{public}s]:%i Could not get the Applet properties... %{public}@", v16, ClassName, Name, 87, v11);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v17 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          unsigned __int8 v18 = object_getClass(a1);
          if (class_isMetaClass(v18)) {
            int v19 = 43;
          }
          else {
            int v19 = 45;
          }
          id v20 = object_getClassName(a1);
          uint64_t v21 = sel_getName("getATLAppletProperties:error:");
          *(_DWORD *)int buf = 67110146;
          int v42 = v19;
          __int16 v43 = 2082;
          uint64_t v44 = v20;
          __int16 v45 = 2082;
          id v46 = v21;
          __int16 v47 = 1024;
          int v48 = 87;
          __int16 v49 = 2114;
          id v50 = v11;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Could not get the Applet properties... %{public}@", buf, 0x2Cu);
        }
      }
      if (a3)
      {
        id v11 = v11;
        *a3 = v11;
      }
      goto LABEL_27;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v22 = NFLogGetLogger();
    if (v22)
    {
      id v23 = (void (*)(uint64_t, const char *, ...))v22;
      uint64_t v24 = object_getClass(a1);
      BOOL v25 = class_isMetaClass(v24);
      id v26 = object_getClassName(a1);
      int v39 = sel_getName("getATLAppletProperties:error:");
      uint64_t v27 = 45;
      if (v25) {
        uint64_t v27 = 43;
      }
      v23(3, "%c[%{public}s %{public}s]:%i Failed to find applet", v27, v26, v39, 75);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    BOOL v28 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      uint64_t v29 = object_getClass(a1);
      if (class_isMetaClass(v29)) {
        int v30 = 43;
      }
      else {
        int v30 = 45;
      }
      *(_DWORD *)int buf = 67109890;
      int v42 = v30;
      __int16 v43 = 2082;
      uint64_t v44 = object_getClassName(a1);
      __int16 v45 = 2082;
      id v46 = sel_getName("getATLAppletProperties:error:");
      __int16 v47 = 1024;
      int v48 = 75;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to find applet", buf, 0x22u);
    }

    if (a3)
    {
      id v31 = objc_alloc((Class)NSError);
      id v11 = +[NSString stringWithUTF8String:"nfcd"];
      v51[0] = NSLocalizedDescriptionKey;
      uint64_t v32 = +[NSString stringWithUTF8String:"Invalid Parameter"];
      v52[0] = v32;
      v52[1] = &off_100320770;
      v51[1] = @"Line";
      v51[2] = @"Method";
      id v33 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("getATLAppletProperties:error:")];
      v52[2] = v33;
      v51[3] = NSDebugDescriptionErrorKey;
      id v34 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("getATLAppletProperties:error:"), 76];
      v52[3] = v34;
      int v35 = +[NSDictionary dictionaryWithObjects:v52 forKeys:v51 count:4];
      *a3 = [v31 initWithDomain:v11 code:10 userInfo:v35];

      id v10 = 0;
LABEL_27:

      goto LABEL_28;
    }
  }
  id v10 = 0;
LABEL_28:

  return v10;
}

id sub_1002503F8(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = v5;
  if (a1)
  {
    if (v5)
    {
      id v7 = [v5 identifier];
      uint64_t v8 = [v6 packageIdentifier];
      id v9 = [v6 moduleIdentifier];
      id v48 = 0;
      id v10 = +[AppletTranslator getServiceProviderData:v7 withPackage:v8 withModule:v9 withTransceiver:a1 withError:&v48];
      id v11 = v48;

      if (v11)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          uint64_t v13 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(a1);
          BOOL isMetaClass = class_isMetaClass(Class);
          Classuint64_t Name = object_getClassName(a1);
          uint64_t Name = sel_getName("getATLServiceProviderDataForAID:error:");
          uint64_t v16 = 45;
          if (isMetaClass) {
            uint64_t v16 = 43;
          }
          v13(4, "%c[%{public}s %{public}s]:%i Could not get service provider data... %{public}@", v16, ClassName, Name, 121, v11);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v17 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          unsigned __int8 v18 = object_getClass(a1);
          if (class_isMetaClass(v18)) {
            int v19 = 43;
          }
          else {
            int v19 = 45;
          }
          id v20 = object_getClassName(a1);
          uint64_t v21 = sel_getName("getATLServiceProviderDataForAID:error:");
          *(_DWORD *)int buf = 67110146;
          int v50 = v19;
          __int16 v51 = 2082;
          id v52 = v20;
          __int16 v53 = 2082;
          id v54 = v21;
          __int16 v55 = 1024;
          int v56 = 121;
          __int16 v57 = 2114;
          id v58 = v11;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Could not get service provider data... %{public}@", buf, 0x2Cu);
        }
      }
      if (a3)
      {
        id v11 = v11;
        *a3 = v11;
      }
      goto LABEL_27;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v22 = NFLogGetLogger();
    if (v22)
    {
      id v23 = (void (*)(uint64_t, const char *, ...))v22;
      uint64_t v24 = object_getClass(a1);
      BOOL v25 = class_isMetaClass(v24);
      id v26 = object_getClassName(a1);
      id v46 = sel_getName("getATLServiceProviderDataForAID:error:");
      uint64_t v27 = 45;
      if (v25) {
        uint64_t v27 = 43;
      }
      v23(3, "%c[%{public}s %{public}s]:%i Failed to find applet", v27, v26, v46, 99);
    }
    __int16 v47 = a3;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    BOOL v28 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      uint64_t v29 = object_getClass(a1);
      if (class_isMetaClass(v29)) {
        int v30 = 43;
      }
      else {
        int v30 = 45;
      }
      *(_DWORD *)int buf = 67109890;
      int v50 = v30;
      __int16 v51 = 2082;
      id v52 = object_getClassName(a1);
      __int16 v53 = 2082;
      id v54 = sel_getName("getATLServiceProviderDataForAID:error:");
      __int16 v55 = 1024;
      int v56 = 99;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to find applet", buf, 0x22u);
    }

    sub_1001991EC((uint64_t)NFBugCapture, @"Error while getting Applet Properties", @"Applet AID: nil, Applet PID: nil", &off_100323910);
    id v31 = objc_alloc((Class)NSError);
    uint64_t v32 = +[NSString stringWithUTF8String:"nfcd"];
    v61[0] = NSLocalizedDescriptionKey;
    id v33 = +[NSString stringWithUTF8String:"Invalid Parameter"];
    v62[0] = v33;
    v62[1] = &off_100320788;
    v61[1] = @"Line";
    v61[2] = @"Method";
    id v34 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("getATLServiceProviderDataForAID:error:")];
    v62[2] = v34;
    void v61[3] = NSDebugDescriptionErrorKey;
    id v35 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("getATLServiceProviderDataForAID:error:"), 108];
    v62[3] = v35;
    uint64_t v36 = +[NSDictionary dictionaryWithObjects:v62 forKeys:v61 count:4];
    id v37 = [v31 initWithDomain:v32 code:10 userInfo:v36];
    +[NFExceptionsCALogger postAnalyticsATLFailureEvent:1 aid:0 error:v37];

    if (a3)
    {
      id v38 = objc_alloc((Class)NSError);
      id v11 = +[NSString stringWithUTF8String:"nfcd"];
      v59[0] = NSLocalizedDescriptionKey;
      int v39 = +[NSString stringWithUTF8String:"Invalid Parameter"];
      v60[0] = v39;
      v60[1] = &off_1003207A0;
      v59[1] = @"Line";
      void v59[2] = @"Method";
      id v40 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("getATLServiceProviderDataForAID:error:")];
      v60[2] = v40;
      v59[3] = NSDebugDescriptionErrorKey;
      id v41 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("getATLServiceProviderDataForAID:error:"), 110];
      void v60[3] = v41;
      int v42 = +[NSDictionary dictionaryWithObjects:v60 forKeys:v59 count:4];
      *__int16 v47 = [v38 initWithDomain:v11 code:10 userInfo:v42];

      id v10 = 0;
LABEL_27:

      goto LABEL_28;
    }
  }
  id v10 = 0;
LABEL_28:

  return v10;
}

id sub_100250A30(void *a1, void *a2, void *a3, void *a4, void *a5)
{
  id v9 = a2;
  id v10 = a3;
  id v11 = a4;
  int v50 = v10;
  if (a1)
  {
    if (v9)
    {
      id v12 = a5;
      uint64_t v13 = [v9 identifier];
      uint64_t v14 = [v9 packageIdentifier];
      int v15 = [v9 moduleIdentifier];
      id v51 = 0;
      uint64_t v16 = +[AppletTranslator getServiceProviderData:v13 withPackage:v14 withModule:v15 withPublicKey:v10 withEncryptionScheme:v11 withTransceiver:a1 withError:&v51];
      id v17 = v51;

      if (v17)
      {
        id v49 = v11;
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          int v19 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(a1);
          BOOL isMetaClass = class_isMetaClass(Class);
          Classuint64_t Name = object_getClassName(a1);
          uint64_t Name = sel_getName("getATLServiceProviderDataForAID:publicKey:scheme:error:");
          uint64_t v22 = 45;
          if (isMetaClass) {
            uint64_t v22 = 43;
          }
          v19(4, "%c[%{public}s %{public}s]:%i Could not get service provider data with privacy scheme... %{public}@", v22, ClassName, Name, 150, v17);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v23 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
        {
          uint64_t v24 = object_getClass(a1);
          if (class_isMetaClass(v24)) {
            int v25 = 43;
          }
          else {
            int v25 = 45;
          }
          id v26 = object_getClassName(a1);
          uint64_t v27 = sel_getName("getATLServiceProviderDataForAID:publicKey:scheme:error:");
          *(_DWORD *)int buf = 67110146;
          int v53 = v25;
          __int16 v54 = 2082;
          __int16 v55 = v26;
          __int16 v56 = 2082;
          __int16 v57 = v27;
          __int16 v58 = 1024;
          int v59 = 150;
          __int16 v60 = 2114;
          id v61 = v17;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Could not get service provider data with privacy scheme... %{public}@", buf, 0x2Cu);
        }

        id v11 = v49;
      }
      if (v12)
      {
        id v17 = v17;
        *id v12 = v17;
      }
      goto LABEL_27;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v28 = NFLogGetLogger();
    if (v28)
    {
      uint64_t v29 = (void (*)(uint64_t, const char *, ...))v28;
      int v30 = object_getClass(a1);
      BOOL v31 = class_isMetaClass(v30);
      uint64_t v32 = a5;
      id v33 = object_getClassName(a1);
      id v48 = sel_getName("getATLServiceProviderDataForAID:publicKey:scheme:error:");
      uint64_t v34 = 45;
      if (v31) {
        uint64_t v34 = 43;
      }
      id v46 = v33;
      a5 = v32;
      v29(3, "%c[%{public}s %{public}s]:%i Failed to find applet", v34, v46, v48, 136);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v35 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
    {
      uint64_t v36 = object_getClass(a1);
      if (class_isMetaClass(v36)) {
        int v37 = 43;
      }
      else {
        int v37 = 45;
      }
      *(_DWORD *)int buf = 67109890;
      int v53 = v37;
      __int16 v54 = 2082;
      __int16 v55 = object_getClassName(a1);
      __int16 v56 = 2082;
      __int16 v57 = sel_getName("getATLServiceProviderDataForAID:publicKey:scheme:error:");
      __int16 v58 = 1024;
      int v59 = 136;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to find applet", buf, 0x22u);
    }

    if (a5)
    {
      id v38 = objc_alloc((Class)NSError);
      id v17 = +[NSString stringWithUTF8String:"nfcd"];
      v62[0] = NSLocalizedDescriptionKey;
      int v39 = +[NSString stringWithUTF8String:"Invalid Parameter"];
      v63[0] = v39;
      v63[1] = &off_1003207B8;
      v62[1] = @"Line";
      v62[2] = @"Method";
      id v40 = a5;
      id v41 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("getATLServiceProviderDataForAID:publicKey:scheme:error:")];
      v63[2] = v41;
      v62[3] = NSDebugDescriptionErrorKey;
      id v42 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("getATLServiceProviderDataForAID:publicKey:scheme:error:"), 137];
      v63[3] = v42;
      __int16 v43 = +[NSDictionary dictionaryWithObjects:v63 forKeys:v62 count:4];
      *id v40 = [v38 initWithDomain:v17 code:10 userInfo:v43];

      uint64_t v16 = 0;
LABEL_27:

      goto LABEL_28;
    }
  }
  uint64_t v16 = 0;
LABEL_28:

  return v16;
}

id sub_100250F44(void *a1)
{
  if (a1)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(a1);
      uint64_t Name = sel_getName("reConfigureApplets");
      uint64_t v7 = 45;
      if (isMetaClass) {
        uint64_t v7 = 43;
      }
      v3(6, "%c[%{public}s %{public}s]:%i ", v7, ClassName, Name, 161);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v8 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      id v9 = object_getClass(a1);
      if (class_isMetaClass(v9)) {
        int v10 = 43;
      }
      else {
        int v10 = 45;
      }
      *(_DWORD *)int buf = 67109890;
      int v98 = v10;
      __int16 v99 = 2082;
      uint64_t v100 = object_getClassName(a1);
      __int16 v101 = 2082;
      id v102 = sel_getName("reConfigureApplets");
      __int16 v103 = 1024;
      int v104 = 161;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
    }

    id v89 = 0;
    sub_100243D60(a1, &v89);
    id v11 = (id)objc_claimAutoreleasedReturnValue();
    id v12 = v89;
    if (v11)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v13 = NFLogGetLogger();
      if (v13)
      {
        uint64_t v14 = (void (*)(uint64_t, const char *, ...))v13;
        int v15 = object_getClass(a1);
        BOOL v16 = class_isMetaClass(v15);
        id v76 = object_getClassName(a1);
        unsigned int v79 = sel_getName("reConfigureApplets");
        uint64_t v17 = 45;
        if (v16) {
          uint64_t v17 = 43;
        }
        v14(3, "%c[%{public}s %{public}s]:%i Failed to pull applets : %{public}@", v17, v76, v79, 166, v11);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      unsigned __int8 v18 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        int v19 = object_getClass(a1);
        if (class_isMetaClass(v19)) {
          int v20 = 43;
        }
        else {
          int v20 = 45;
        }
        uint64_t v21 = object_getClassName(a1);
        uint64_t v22 = sel_getName("reConfigureApplets");
        *(_DWORD *)int buf = 67110146;
        int v98 = v20;
        __int16 v99 = 2082;
        uint64_t v100 = v21;
        __int16 v101 = 2082;
        id v102 = v22;
        __int16 v103 = 1024;
        int v104 = 166;
        __int16 v105 = 2114;
        id v106 = v11;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to pull applets : %{public}@", buf, 0x2Cu);
      }

      id v23 = objc_alloc((Class)NSError);
      uint64_t v24 = +[NSString stringWithUTF8String:"nfcd"];
      id v25 = [v11 code];
      v95[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[v11 code] > 70) {
        uint64_t v26 = 71;
      }
      else {
        uint64_t v26 = (uint64_t)[v11 code];
      }
      id v33 = +[NSString stringWithUTF8String:off_1003084E8[v26]];
      v96[0] = v33;
      v96[1] = v11;
      v95[1] = NSUnderlyingErrorKey;
      v95[2] = @"Line";
      v96[2] = &off_1003207D0;
      v95[3] = @"Method";
      id v48 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("reConfigureApplets")];
      v96[3] = v48;
      void v95[4] = NSDebugDescriptionErrorKey;
      id v49 = [[objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("reConfigureApplets"), 167];
      void v96[4] = v49;
      int v50 = +[NSDictionary dictionaryWithObjects:v96 forKeys:v95 count:5];
      id v47 = [v23 initWithDomain:v24 code:v25 userInfo:v50];
    }
    else
    {
      uint64_t v24 = objc_opt_new();
      long long v85 = 0u;
      long long v86 = 0u;
      long long v87 = 0u;
      long long v88 = 0u;
      id v27 = v12;
      id v28 = [v27 countByEnumeratingWithState:&v85 objects:v94 count:16];
      if (v28)
      {
        id v29 = v28;
        uint64_t v30 = *(void *)v86;
        do
        {
          for (i = 0; i != v29; i = (char *)i + 1)
          {
            if (*(void *)v86 != v30) {
              objc_enumerationMutation(v27);
            }
            uint64_t v32 = [*(id *)(*((void *)&v85 + 1) + 8 * i) asDictionary];
            [v24 addObject:v32];
          }
          id v29 = [v27 countByEnumeratingWithState:&v85 objects:v94 count:16];
        }
        while (v29);
      }

      id v84 = 0;
      id v33 = [a1 queryISDCounter:&v84];
      id v11 = v84;
      if (v33)
      {
        uint64_t v34 = [a1 serialNumberAsData];
        id v83 = v11;
        +[AppletTranslator appletCacheUpdated:v24 serialNumber:v34 isdSequenceCounter:v33 transceiver:a1 error:&v83];
        id v35 = v83;

        if (v35)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v36 = NFLogGetLogger();
          if (v36)
          {
            int v37 = (void (*)(uint64_t, const char *, ...))v36;
            id v38 = object_getClass(a1);
            BOOL v39 = class_isMetaClass(v38);
            id v77 = object_getClassName(a1);
            id v80 = sel_getName("reConfigureApplets");
            uint64_t v40 = 45;
            if (v39) {
              uint64_t v40 = 43;
            }
            v37(3, "%c[%{public}s %{public}s]:%i ATL failed to reconfigure : %{public}@", v40, v77, v80, 187, v35);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v41 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
          {
            id v42 = object_getClass(a1);
            if (class_isMetaClass(v42)) {
              int v43 = 43;
            }
            else {
              int v43 = 45;
            }
            uint64_t v44 = object_getClassName(a1);
            __int16 v45 = sel_getName("reConfigureApplets");
            *(_DWORD *)int buf = 67110146;
            int v98 = v43;
            __int16 v99 = 2082;
            uint64_t v100 = v44;
            __int16 v101 = 2082;
            id v102 = v45;
            __int16 v103 = 1024;
            int v104 = 187;
            __int16 v105 = 2114;
            id v106 = v35;
            _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i ATL failed to reconfigure : %{public}@", buf, 0x2Cu);
          }

          id v46 = +[NSString stringWithFormat:@"ATL failed to reconfigure : %@", v35];
          sub_1001991EC((uint64_t)NFBugCapture, @"ATL failed to reconfigure", v46, &off_100323938);

          +[NFExceptionsCALogger postAnalyticsATLFailureEvent:2 aid:0 error:v35];
          id v11 = v35;
          id v47 = v11;
        }
        else
        {
          id v11 = 0;
          id v47 = 0;
        }
      }
      else
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v52 = NFLogGetLogger();
        if (v52)
        {
          int v53 = (void (*)(uint64_t, const char *, ...))v52;
          __int16 v54 = object_getClass(a1);
          BOOL v55 = class_isMetaClass(v54);
          __int16 v56 = object_getClassName(a1);
          id v81 = sel_getName("reConfigureApplets");
          uint64_t v57 = 45;
          if (v55) {
            uint64_t v57 = 43;
          }
          v53(3, "%c[%{public}s %{public}s]:%i Failed to get ISD counter", v57, v56, v81, 177);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        __int16 v58 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
        {
          int v59 = object_getClass(a1);
          if (class_isMetaClass(v59)) {
            int v60 = 43;
          }
          else {
            int v60 = 45;
          }
          id v61 = object_getClassName(a1);
          __int16 v62 = sel_getName("reConfigureApplets");
          *(_DWORD *)int buf = 67109890;
          int v98 = v60;
          __int16 v99 = 2082;
          uint64_t v100 = v61;
          __int16 v101 = 2082;
          id v102 = v62;
          __int16 v103 = 1024;
          int v104 = 177;
          _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get ISD counter", buf, 0x22u);
        }

        id v63 = objc_alloc((Class)NSError);
        __int16 v64 = +[NSString stringWithUTF8String:"nfcd"];
        if (v11)
        {
          id v65 = [v11 code];
          v92[0] = NSLocalizedDescriptionKey;
          id v82 = v65;
          __int16 v66 = v63;
          if ((uint64_t)[v11 code] > 70) {
            uint64_t v67 = 71;
          }
          else {
            uint64_t v67 = (uint64_t)[v11 code];
          }
          uint64_t v72 = +[NSString stringWithUTF8String:off_1003084E8[v67]];
          v93[0] = v72;
          v93[1] = v11;
          v92[1] = NSUnderlyingErrorKey;
          v92[2] = @"Line";
          v93[2] = &off_1003207E8;
          v92[3] = @"Method";
          id v73 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("reConfigureApplets")];
          v93[3] = v73;
          v92[4] = NSDebugDescriptionErrorKey;
          id v74 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("reConfigureApplets"), 178];
          v93[4] = v74;
          BOOL v75 = +[NSDictionary dictionaryWithObjects:v93 forKeys:v92 count:5];
          id v47 = [v66 initWithDomain:v64 code:v82 userInfo:v75];

          id v33 = 0;
        }
        else
        {
          v90[0] = NSLocalizedDescriptionKey;
          id v68 = +[NSString stringWithUTF8String:"Unknown Error"];
          v91[0] = v68;
          v91[1] = &off_1003207E8;
          v90[1] = @"Line";
          v90[2] = @"Method";
          id v69 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("reConfigureApplets")];
          v91[2] = v69;
          v90[3] = NSDebugDescriptionErrorKey;
          id v70 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("reConfigureApplets"), 178];
          v91[3] = v70;
          id v71 = +[NSDictionary dictionaryWithObjects:v91 forKeys:v90 count:4];
          id v47 = [v63 initWithDomain:v64 code:6 userInfo:v71];

          id v33 = 0;
          id v11 = 0;
        }
      }
    }
  }
  else
  {
    id v47 = 0;
  }

  return v47;
}

id sub_100251A48(void *a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  id v6 = v5;
  if (a1)
  {
    if ([v5 isTypeF])
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        uint64_t v8 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        Classuint64_t Name = object_getClassName(a1);
        uint64_t Name = sel_getName("setPlasticCardMode:forApplet:");
        uint64_t v12 = 45;
        if (isMetaClass) {
          uint64_t v12 = 43;
        }
        v8(6, "%c[%{public}s %{public}s]:%i Applet is typeF, skipping", v12, ClassName, Name, 207);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v13 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = object_getClass(a1);
        if (class_isMetaClass(v14)) {
          int v15 = 43;
        }
        else {
          int v15 = 45;
        }
        *(_DWORD *)int buf = 67109890;
        int v44 = v15;
        __int16 v45 = 2082;
        id v46 = object_getClassName(a1);
        __int16 v47 = 2082;
        id v48 = sel_getName("setPlasticCardMode:forApplet:");
        __int16 v49 = 1024;
        int v50 = 207;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Applet is typeF, skipping", buf, 0x22u);
      }
      id v16 = 0;
    }
    else
    {
      uint64_t v17 = [v6 identifier];
      unsigned __int8 v18 = [v6 packageIdentifier];
      int v19 = [v6 moduleIdentifier];
      int v20 = [a1 serialNumberAsData];
      id v40 = 0;
      +[AppletTranslator setPlasticCardMode:a2 withApplet:v17 withPackage:v18 withModule:v19 serialNumber:v20 transceiver:a1 error:&v40];
      id v16 = v40;

      if (!v16) {
        goto LABEL_25;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v21 = NFLogGetLogger();
      if (v21)
      {
        uint64_t v22 = (void (*)(uint64_t, const char *, ...))v21;
        id v23 = object_getClass(a1);
        BOOL v24 = class_isMetaClass(v23);
        id v25 = object_getClassName(a1);
        BOOL v39 = sel_getName("setPlasticCardMode:forApplet:");
        uint64_t v26 = 45;
        if (v24) {
          uint64_t v26 = 43;
        }
        v22(3, "%c[%{public}s %{public}s]:%i ATL failed to configure plastic card mode : enable=%d %{public}@", v26, v25, v39, 222, a2, v16);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v27 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        id v28 = object_getClass(a1);
        if (class_isMetaClass(v28)) {
          int v29 = 43;
        }
        else {
          int v29 = 45;
        }
        uint64_t v30 = object_getClassName(a1);
        BOOL v31 = sel_getName("setPlasticCardMode:forApplet:");
        *(_DWORD *)int buf = 67110402;
        int v44 = v29;
        __int16 v45 = 2082;
        id v46 = v30;
        __int16 v47 = 2082;
        id v48 = v31;
        __int16 v49 = 1024;
        int v50 = 222;
        __int16 v51 = 1024;
        int v52 = a2;
        __int16 v53 = 2114;
        id v54 = v16;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i ATL failed to configure plastic card mode : enable=%d %{public}@", buf, 0x32u);
      }

      uint64_t v32 = [v6 identifier];
      id v33 = [v6 packageIdentifier];
      uint64_t v34 = +[NSString stringWithFormat:@"Applet AID: %@, Applet PID: %@", v32, v33];
      v41[0] = @"Applet Identifier";
      id v35 = [v6 identifier];
      v42[0] = v35;
      v42[1] = @"Other Bug";
      v41[1] = @"Classification";
      v41[2] = @"FailureKey";
      v42[2] = @"ttrPlastic";
      uint64_t v36 = +[NSDictionary dictionaryWithObjects:v42 forKeys:v41 count:3];
      sub_1001991EC((uint64_t)NFBugCapture, @"ATL failed to configure plastic card mode", v34, v36);

      uint64_t v13 = [v6 identifier];
      +[NFExceptionsCALogger postAnalyticsATLFailureEvent:3 aid:v13 error:v16];
    }
  }
  else
  {
    id v16 = 0;
  }
LABEL_25:

  return v16;
}

id sub_100251EF4(void *a1, void *a2, void *a3, uint64_t a4)
{
  id v7 = a2;
  id v78 = a3;
  if (a1)
  {
    unsigned int v76 = a4;
    if ([v7 count] == (id)1
      && ([a1 activeApplet], (uint64_t v8 = objc_claimAutoreleasedReturnValue()) != 0))
    {
      id v9 = (void *)v8;
      int v10 = [a1 activeApplet];
      id v11 = [v10 identifierAsData];
      id v12 = [v11 length];

      if (v12)
      {
        uint64_t v13 = [v7 objectAtIndexedSubscript:0];
        uint64_t v14 = [v13 objectForKeyedSubscript:@"appletIdentifier"];
        int v15 = [v13 objectForKeyedSubscript:@"expressEnabled"];
        unsigned int v16 = [v15 BOOLValue];

        if (v16)
        {
          uint64_t v17 = [a1 activeApplet];
          unsigned __int8 v18 = [v17 identifierAsData];
          [v18 NF_asHexString];
          v20 = id v19 = v7;
          unsigned int v77 = [v20 isEqualToString:v14];

          id v7 = v19;
        }
        else
        {
          unsigned int v77 = 0;
        }
      }
      else
      {
        unsigned int v77 = 0;
      }
      a4 = v76;
    }
    else
    {
      unsigned int v77 = 0;
    }
    uint64_t v21 = [a1 activeApplet];

    BOOL v85 = v21 != 0;
    long long v81 = 0u;
    long long v82 = 0u;
    long long v83 = 0u;
    long long v84 = 0u;
    id v75 = v7;
    id v22 = v7;
    id v23 = [v22 countByEnumeratingWithState:&v81 objects:v97 count:16];
    if (v23)
    {
      id v24 = v23;
      uint64_t v25 = *(void *)v82;
      while (2)
      {
        for (i = 0; i != v24; i = (char *)i + 1)
        {
          if (*(void *)v82 != v25) {
            objc_enumerationMutation(v22);
          }
          id v27 = [*(id *)(*((void *)&v81 + 1) + 8 * i) objectForKeyedSubscript:@"expressEnabled"];
          unsigned __int8 v28 = [v27 BOOLValue];

          if (v28)
          {
            char v29 = 1;
            goto LABEL_22;
          }
        }
        id v24 = [v22 countByEnumeratingWithState:&v81 objects:v97 count:16];
        if (v24) {
          continue;
        }
        break;
      }
      char v29 = 0;
LABEL_22:
      a4 = v76;
    }
    else
    {
      char v29 = 0;
    }

    id v80 = 0;
    unsigned __int8 v30 = +[AppletTranslator configureSEWithPassInformation:v22 transceiver:a1 limitedToAID:v78 seHasActivatedApplets:&v85 skipAllActivations:v77 useLegacyBehavior:a4 error:&v80];
    id v31 = v80;
    id v32 = v31;
    if (v31 && [v31 code] == (id)5)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        uint64_t v34 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        Classuint64_t Name = object_getClassName(a1);
        uint64_t Name = sel_getName("configureSEExprWithPassInformation:limitedToAID:legacyWalletBehavior:");
        uint64_t v38 = 45;
        if (isMetaClass) {
          uint64_t v38 = 43;
        }
        uint64_t v72 = ClassName;
        a4 = v76;
        v34(4, "%c[%{public}s %{public}s]:%i Applet is badly behaved, needs to be powercycled", v38, v72, Name, 275);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      BOOL v39 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
      {
        id v40 = object_getClass(a1);
        if (class_isMetaClass(v40)) {
          int v41 = 43;
        }
        else {
          int v41 = 45;
        }
        id v42 = object_getClassName(a1);
        int v43 = sel_getName("configureSEExprWithPassInformation:limitedToAID:legacyWalletBehavior:");
        *(_DWORD *)int buf = 67109890;
        int v87 = v41;
        a4 = v76;
        __int16 v88 = 2082;
        id v89 = v42;
        __int16 v90 = 2082;
        uint64_t v91 = v43;
        __int16 v92 = 1024;
        int v93 = 275;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Applet is badly behaved, needs to be powercycled", buf, 0x22u);
      }

      int v44 = [a1 powerCycleOrReset];

      if (v44 && [v44 code])
      {
        id v32 = v44;
      }
      else
      {

        id v79 = 0;
        unsigned __int8 v30 = +[AppletTranslator configureSEWithPassInformation:v22 transceiver:a1 limitedToAID:v78 seHasActivatedApplets:&v85 skipAllActivations:v77 useLegacyBehavior:a4 error:&v79];
        id v32 = v79;
      }
    }
    if (v85) {
      char v45 = 1;
    }
    else {
      char v45 = v29;
    }
    if (v45)
    {
      id v46 = objc_opt_new();
      [a1 setActiveApplet:v46];
    }
    else
    {
      [a1 setActiveApplet:0];
    }
    if (v32) {
      unsigned __int8 v47 = 0;
    }
    else {
      unsigned __int8 v47 = v30;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v48 = NFLogGetLogger();
    __int16 v49 = (void (*)(uint64_t, const char *, ...))v48;
    if (v47)
    {
      if (v48)
      {
        int v50 = object_getClass(a1);
        BOOL v51 = class_isMetaClass(v50);
        int v52 = object_getClassName(a1);
        __int16 v53 = sel_getName("configureSEExprWithPassInformation:limitedToAID:legacyWalletBehavior:");
        uint64_t v54 = 45;
        if (v51) {
          uint64_t v54 = 43;
        }
        v49(6, "%c[%{public}s %{public}s]:%i Successfully configured ATL for Express. Skipped %d Dirty before %d after %d", v54, v52, v53, 306, v77, v21 != 0, v85);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      BOOL v55 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v56 = object_getClass(a1);
        if (class_isMetaClass(v56)) {
          int v57 = 43;
        }
        else {
          int v57 = 45;
        }
        __int16 v58 = object_getClassName(a1);
        int v59 = sel_getName("configureSEExprWithPassInformation:limitedToAID:legacyWalletBehavior:");
        *(_DWORD *)int buf = 67110658;
        int v87 = v57;
        __int16 v88 = 2082;
        id v89 = v58;
        __int16 v90 = 2082;
        uint64_t v91 = v59;
        __int16 v92 = 1024;
        int v93 = 306;
        __int16 v94 = 1024;
        *(_DWORD *)id v95 = v77;
        *(_WORD *)&void v95[4] = 1024;
        *(_DWORD *)&v95[6] = v21 != 0;
        *(_WORD *)id v96 = 1024;
        *(_DWORD *)&v96[2] = v85;
        _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Successfully configured ATL for Express. Skipped %d Dirty before %d after %d", buf, 0x34u);
      }
      id v60 = 0;
      id v7 = v75;
    }
    else
    {
      if (v48)
      {
        id v61 = object_getClass(a1);
        BOOL v62 = class_isMetaClass(v61);
        id v63 = object_getClassName(a1);
        id v74 = sel_getName("configureSEExprWithPassInformation:limitedToAID:legacyWalletBehavior:");
        uint64_t v64 = 45;
        if (v62) {
          uint64_t v64 = 43;
        }
        v49(3, "%c[%{public}s %{public}s]:%i Error : failed to configure SE pass information : %{public}@, useLegacyBehavior=%{public}d", v64, v63, v74, 292, v32, a4);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v65 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
      {
        __int16 v66 = object_getClass(a1);
        if (class_isMetaClass(v66)) {
          int v67 = 43;
        }
        else {
          int v67 = 45;
        }
        id v68 = object_getClassName(a1);
        id v69 = sel_getName("configureSEExprWithPassInformation:limitedToAID:legacyWalletBehavior:");
        *(_DWORD *)int buf = 67110402;
        int v87 = v67;
        __int16 v88 = 2082;
        id v89 = v68;
        __int16 v90 = 2082;
        uint64_t v91 = v69;
        __int16 v92 = 1024;
        int v93 = 292;
        __int16 v94 = 2114;
        *(void *)id v95 = v32;
        *(_WORD *)&v95[8] = 1026;
        *(_DWORD *)id v96 = a4;
        _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error : failed to configure SE pass information : %{public}@, useLegacyBehavior=%{public}d", buf, 0x32u);
      }

      id v7 = v75;
      if (v32)
      {
        id v70 = [v32 localizedDescription];
        BOOL v55 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Error: %@, Code: %ld", v70, [v32 code]);
      }
      else
      {
        BOOL v55 = @"No response from ATL";
      }
      sub_1001991EC((uint64_t)NFBugCapture, @"Failed to configure SE Express info", v55, &off_100323960);
      +[NFExceptionsCALogger postAnalyticsATLFailureEvent:4 aid:0 error:v32];
      id v60 = v32;
    }
  }
  else
  {
    id v60 = 0;
  }

  return v60;
}

uint64_t sub_100252724(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v4 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284610 length:10];
    id v5 = [v4 NF_asHexString];
    v25[0] = v5;
    id v6 = [objc_alloc((Class)NSData) initWithBytes:&unk_10028461A length:8];
    id v7 = [v6 NF_asHexString];
    v25[1] = v7;
    id v8 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284622 length:12];
    id v9 = [v8 NF_asHexString];
    v25[2] = v9;
    id v10 = [objc_alloc((Class)NSData) initWithBytes:&unk_10028462E length:10];
    id v11 = [v10 NF_asHexString];
    v25[3] = v11;
    id v12 = +[NSArray arrayWithObjects:v25 count:4];

    long long v22 = 0u;
    long long v23 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    id v13 = v12;
    uint64_t v14 = (uint64_t)[v13 countByEnumeratingWithState:&v20 objects:v24 count:16];
    if (v14)
    {
      uint64_t v15 = *(void *)v21;
      while (2)
      {
        for (uint64_t i = 0; i != v14; ++i)
        {
          if (*(void *)v21 != v15) {
            objc_enumerationMutation(v13);
          }
          uint64_t v17 = *(void *)(*((void *)&v20 + 1) + 8 * i);
          unsigned __int8 v18 = [v3 moduleIdentifier];
          LOBYTE(v17) = [v18 isEqualToString:v17];

          if (v17)
          {
            uint64_t v14 = 1;
            goto LABEL_12;
          }
        }
        uint64_t v14 = (uint64_t)[v13 countByEnumeratingWithState:&v20 objects:v24 count:16];
        if (v14) {
          continue;
        }
        break;
      }
    }
LABEL_12:
  }
  else
  {
    uint64_t v14 = 0;
  }

  return v14;
}

id sub_100252958(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = self;
  id v35 = 0;
  id v6 = +[AppletTranslator checkSEExpressAppletCompatibilityWithPassInformation:v4 error:&v35];

  id v7 = v35;
  id v8 = v7;
  if (v6) {
    BOOL v9 = v7 == 0;
  }
  else {
    BOOL v9 = 0;
  }
  if (!v9)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v11 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v5);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(v5);
      uint64_t Name = sel_getName("checkSEExpressPassCompatibility:error:");
      uint64_t v14 = 45;
      if (isMetaClass) {
        uint64_t v14 = 43;
      }
      v11(3, "%c[%{public}s %{public}s]:%i Error : failed to check SE Express Compatibility : %{public}@", v14, ClassName, Name, 335, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v15 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      unsigned int v16 = object_getClass(v5);
      if (class_isMetaClass(v16)) {
        int v17 = 43;
      }
      else {
        int v17 = 45;
      }
      unsigned __int8 v18 = object_getClassName(v5);
      id v19 = sel_getName("checkSEExpressPassCompatibility:error:");
      *(_DWORD *)int buf = 67110146;
      int v41 = v17;
      __int16 v42 = 2082;
      int v43 = v18;
      __int16 v44 = 2082;
      char v45 = v19;
      __int16 v46 = 1024;
      int v47 = 335;
      __int16 v48 = 2114;
      __int16 v49 = v8;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error : failed to check SE Express Compatibility : %{public}@", buf, 0x2Cu);
    }

    if (v8)
    {
      long long v20 = [v8 localizedDescription];
      +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Error: %@, Code: %ld", v20, [v8 code]);
      long long v21 = (__CFString *)objc_claimAutoreleasedReturnValue();

      sub_1001991EC((uint64_t)NFBugCapture, @"Failed to check SE Express compatibility", v21, &off_100323988);
      +[NFExceptionsCALogger postAnalyticsATLFailureEvent:5 aid:0 error:v8];
      if (a3) {
        *a3 = v8;
      }
    }
    else
    {
      long long v21 = @"No response received";
      sub_1001991EC((uint64_t)NFBugCapture, @"Failed to check SE Express compatibility", @"No response received", &off_100323988);
      id v22 = objc_alloc((Class)NSError);
      long long v23 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v38 = NSLocalizedDescriptionKey;
      id v24 = +[NSString stringWithUTF8String:"Unexpected Result"];
      BOOL v39 = v24;
      uint64_t v25 = +[NSDictionary dictionaryWithObjects:&v39 forKeys:&v38 count:1];
      id v26 = [v22 initWithDomain:v23 code:13 userInfo:v25];
      +[NFExceptionsCALogger postAnalyticsATLFailureEvent:5 aid:0 error:v26];

      if (a3)
      {
        id v27 = objc_alloc((Class)NSError);
        unsigned __int8 v28 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v36 = NSLocalizedDescriptionKey;
        char v29 = +[NSString stringWithUTF8String:"Unexpected Result"];
        int v37 = v29;
        unsigned __int8 v30 = +[NSDictionary dictionaryWithObjects:&v37 forKeys:&v36 count:1];
        id v31 = [v27 initWithDomain:v28 code:13 userInfo:v30];
        *a3 = v31;

        long long v21 = @"No response received";
      }
    }
  }

  return v6;
}

id sub_100252D84(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = self;
  uint64_t v6 = +[_NFHardwareManager sharedHardwareManager];
  id v7 = (void *)v6;
  if (v6)
  {
    unint64_t v8 = (unint64_t)[*(id *)(v6 + 120) walletDomain];
    if (v8 <= 4) {
      uint64_t v9 = (0x19u >> v8) & 1;
    }
    else {
      uint64_t v9 = 0;
    }
  }
  else
  {
    uint64_t v9 = 0;
  }

  id v38 = 0;
  id v10 = +[AppletTranslator checkSEExpressAppletCompatibilityWithPassInformation:v4 useLegacyBehavior:v9 error:&v38];

  id v11 = v38;
  id v12 = v11;
  if (!v10 || v11)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v14 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v5);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(v5);
      uint64_t Name = sel_getName("validateSEExpressPassCompatibility:outError:");
      uint64_t v17 = 45;
      if (isMetaClass) {
        uint64_t v17 = 43;
      }
      v14(3, "%c[%{public}s %{public}s]:%i Error : failed to check SE Express Compatibility : %{public}@", v17, ClassName, Name, 365, v12);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    unsigned __int8 v18 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      id v19 = object_getClass(v5);
      if (class_isMetaClass(v19)) {
        int v20 = 43;
      }
      else {
        int v20 = 45;
      }
      long long v21 = object_getClassName(v5);
      id v22 = sel_getName("validateSEExpressPassCompatibility:outError:");
      *(_DWORD *)int buf = 67110146;
      int v44 = v20;
      __int16 v45 = 2082;
      __int16 v46 = v21;
      __int16 v47 = 2082;
      __int16 v48 = v22;
      __int16 v49 = 1024;
      int v50 = 365;
      __int16 v51 = 2114;
      int v52 = v12;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error : failed to check SE Express Compatibility : %{public}@", buf, 0x2Cu);
    }

    if (v12)
    {
      long long v23 = [v12 localizedDescription];
      +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Error: %@, Code: %ld", v23, [v12 code]);
      id v24 = (__CFString *)objc_claimAutoreleasedReturnValue();

      sub_1001991EC((uint64_t)NFBugCapture, @"Failed to check SE Express compatibility", v24, &off_1003239B0);
      +[NFExceptionsCALogger postAnalyticsATLFailureEvent:5 aid:0 error:v12];
      if (a3) {
        *a3 = v12;
      }
    }
    else
    {
      id v24 = @"No response received";
      sub_1001991EC((uint64_t)NFBugCapture, @"Failed to check SE Express compatibility", @"No response received", &off_1003239B0);
      id v25 = objc_alloc((Class)NSError);
      id v26 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v41 = NSLocalizedDescriptionKey;
      id v27 = +[NSString stringWithUTF8String:"Unexpected Result"];
      __int16 v42 = v27;
      unsigned __int8 v28 = +[NSDictionary dictionaryWithObjects:&v42 forKeys:&v41 count:1];
      id v29 = [v25 initWithDomain:v26 code:13 userInfo:v28];
      +[NFExceptionsCALogger postAnalyticsATLFailureEvent:5 aid:0 error:v29];

      if (a3)
      {
        id v30 = objc_alloc((Class)NSError);
        id v31 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v39 = NSLocalizedDescriptionKey;
        id v32 = +[NSString stringWithUTF8String:"Unexpected Result"];
        id v40 = v32;
        id v33 = +[NSDictionary dictionaryWithObjects:&v40 forKeys:&v39 count:1];
        id v34 = [v30 initWithDomain:v31 code:13 userInfo:v33];
        *a3 = v34;

        id v24 = @"No response received";
      }
    }
  }

  return v10;
}

id sub_1002531F0(uint64_t a1, uint64_t a2)
{
  self;

  return +[AppletTranslator getCurrentInMetroStatus:a2];
}

id sub_100253230(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  uint64_t v6 = v5;
  if (a1)
  {
    id v7 = [v5 identifier];
    unint64_t v8 = [v6 packageIdentifier];
    uint64_t v9 = [v6 moduleIdentifier];
    id v28 = 0;
    id v10 = +[AppletTranslator processEndOfTransaction:v7 withPackage:v8 withModule:v9 withTransceiver:a1 withError:&v28];
    id v11 = v28;

    if (v11)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        id v13 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        Classuint64_t Name = object_getClassName(a1);
        uint64_t Name = sel_getName("processEndOfFelicaTransactionForApplet:error:");
        uint64_t v16 = 45;
        if (isMetaClass) {
          uint64_t v16 = 43;
        }
        v13(3, "%c[%{public}s %{public}s]:%i Error : failed to process End of Transaction : %{public}@", v16, ClassName, Name, 400, v11);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v17 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        unsigned __int8 v18 = object_getClass(a1);
        if (class_isMetaClass(v18)) {
          int v19 = 43;
        }
        else {
          int v19 = 45;
        }
        int v20 = object_getClassName(a1);
        long long v21 = sel_getName("processEndOfFelicaTransactionForApplet:error:");
        *(_DWORD *)int buf = 67110146;
        int v30 = v19;
        __int16 v31 = 2082;
        id v32 = v20;
        __int16 v33 = 2082;
        id v34 = v21;
        __int16 v35 = 1024;
        int v36 = 400;
        __int16 v37 = 2114;
        id v38 = v11;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error : failed to process End of Transaction : %{public}@", buf, 0x2Cu);
      }

      id v22 = [v11 localizedDescription];
      long long v23 = +[NSString stringWithFormat:](NSString, "stringWithFormat:", @"Error: %@, Code: %ld", v22, [v11 code]);
      sub_1001991EC((uint64_t)NFBugCapture, @"Error while processing end of transaction", v23, 0);

      id v24 = [v6 identifier];
      +[NFExceptionsCALogger postAnalyticsATLFailureEvent:6 aid:v24 error:v11];

      if (a3) {
        *a3 = v11;
      }
    }
  }
  else
  {
    id v10 = 0;
  }

  return v10;
}

id sub_100253528(id result, void *a2)
{
  if (result)
  {
    id v2 = a2;
    id v3 = [v2 identifier];
    id v4 = [v2 packageIdentifier];
    id v5 = [v2 moduleIdentifier];

    id v6 = +[AppletTranslator isLegacyApplet:v3 withPackage:v4 withModule:v5];
    return v6;
  }
  return result;
}

id sub_1002535C4()
{
  self;

  return +[AppletTranslator cleanup];
}

id *sub_1002535F4(id *a1, void *a2, void *a3, void *a4, unint64_t a5)
{
  id v9 = a3;
  id v10 = a4;
  if (a1)
  {
    v19.receiver = a1;
    v19.super_class = (Class)NFTNEPHandler;
    id v11 = (id *)[super init];
    a1 = v11;
    if (v11)
    {
      void v11[2] = a2;
      objc_storeWeak(v11 + 5, v9);
      id v12 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
      dispatch_queue_t v13 = dispatch_queue_create("com.apple.nfcd.tnepHandler", v12);
      id v14 = a1[3];
      a1[3] = v13;

      dispatch_queue_set_specific((dispatch_queue_t)a1[3], kNFLOG_DISPATCH_SPECIFIC_KEY, 0, 0);
      objc_storeStrong(a1 + 11, a4);
      id v15 = [objc_alloc((Class)NSMutableData) initWithLength:2050];
      id v16 = a1[10];
      a1[10] = v15;

      unint64_t v17 = 0xEEEEB0B5B2B2EEEELL;
      if (a5) {
        unint64_t v17 = a5;
      }
      a1[13] = (id)v17;
    }
  }

  return a1;
}

void sub_100253720(uint64_t a1, void *a2)
{
  id v5 = a2;
  if (a1)
  {
    id v4 = *(void **)(a1 + 56);
    *(void *)(a1 + 56) = 0;

    objc_storeStrong((id *)(a1 + 56), a2);
    *(unsigned char *)(a1 + 8) = 0;
    sub_100257688(a1);
    sub_100257A7C(a1, @"HCE_TagDeviceHandlingStart");
  }
}

void sub_1002537AC(id *a1, void *a2)
{
  id v132 = a2;
  if (!a1) {
    goto LABEL_137;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(a1);
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(a1);
    uint64_t Name = sel_getName("handleDeviceTag:");
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v4(6, "%c[%{public}s %{public}s]:%i ", v8, ClassName, Name, 120);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    id v10 = object_getClass(a1);
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    *(_DWORD *)int buf = 67109890;
    *(_DWORD *)&uint8_t buf[4] = v11;
    *(_WORD *)unsigned int v157 = 2082;
    *(void *)&v157[2] = object_getClassName(a1);
    *(_WORD *)&v157[10] = 2082;
    *(void *)&v157[12] = sel_getName("handleDeviceTag:");
    *(_WORD *)&v157[20] = 1024;
    *(_DWORD *)&v157[22] = 120;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  v143[0] = 0;
  v143[1] = 0;
  uint64_t v144 = 0;
  id v12 = a1[11];
  id v142 = 0;
  id v13 = v12;
  char v14 = sub_100190624(v13, v132, v143, (uint64_t)&v142);
  id v15 = v142;
  int v16 = v144;

  if (v16) {
    char v17 = v14;
  }
  else {
    char v17 = 0;
  }
  if ((v17 & 1) == 0)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v109 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v109)
    {
      __int16 v110 = object_getClass(a1);
      if (class_isMetaClass(v110)) {
        uint64_t v111 = 43;
      }
      else {
        uint64_t v111 = 45;
      }
      uint64_t v112 = object_getClassName(a1);
      uint64_t v113 = sel_getName("handleDeviceTag:");
      v109(4, "%c[%{public}s %{public}s]:%i NDEF capability query failed: %{public}@, readable=%d", v111, v112, v113, 127, v15, v144);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v114 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v114, OS_LOG_TYPE_ERROR))
    {
      __int16 v115 = object_getClass(a1);
      if (class_isMetaClass(v115)) {
        int v116 = 43;
      }
      else {
        int v116 = 45;
      }
      __int16 v117 = object_getClassName(a1);
      uint64_t v118 = sel_getName("handleDeviceTag:");
      *(_DWORD *)int buf = 67110402;
      *(_DWORD *)&uint8_t buf[4] = v116;
      *(_WORD *)unsigned int v157 = 2082;
      *(void *)&v157[2] = v117;
      *(_WORD *)&v157[10] = 2082;
      *(void *)&v157[12] = v118;
      *(_WORD *)&v157[20] = 1024;
      *(_DWORD *)&v157[22] = 127;
      *(_WORD *)&v157[26] = 2114;
      *(void *)&v157[28] = v15;
      *(_WORD *)&v157[36] = 1024;
      *(_DWORD *)&v157[38] = v144;
      _os_log_impl((void *)&_mh_execute_header, v114, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i NDEF capability query failed: %{public}@, readable=%d", buf, 0x32u);
    }

    sub_1002128B4(a1[11]);
    goto LABEL_136;
  }
  id v141 = v15;
  __int16 v131 = sub_100254840(a1, v132, &v141);
  id v130 = v141;

  if (!v131 || v130)
  {
    if (v130 && [v130 code] == (id)47) {
      goto LABEL_135;
    }
    sub_1002128B4(a1[11]);
  }
  id v129 = v131;
  id v128 = v132;
  id v140 = [objc_alloc((Class)NSData) initWithBytes:"TpHs" length:2];
  id v135 = [objc_alloc((Class)NSData) initWithBytes:"Hs" length:2];
  long long v147 = 0u;
  long long v148 = 0u;
  long long v145 = 0u;
  long long v146 = 0u;
  unsigned __int8 v18 = [v129 records];
  id v19 = [v18 countByEnumeratingWithState:&v145 objects:v153 count:16];
  if (!v19)
  {

    goto LABEL_134;
  }
  char v136 = 0;
  char obj = 0;
  uint64_t v20 = *(void *)v146;
  do
  {
    for (uint64_t i = 0; i != v19; uint64_t i = (char *)i + 1)
    {
      if (*(void *)v146 != v20) {
        objc_enumerationMutation(v18);
      }
      id v22 = *(void **)(*((void *)&v145 + 1) + 8 * i);
      long long v23 = [v22 payload];
      BOOL v24 = (unint64_t)[v23 length] < 2;

      if (v24)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v25 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v25)
        {
          id v26 = object_getClass(a1);
          if (class_isMetaClass(v26)) {
            uint64_t v27 = 43;
          }
          else {
            uint64_t v27 = 45;
          }
          id v28 = object_getClassName(a1);
          id v29 = sel_getName("_processNdefRead:tag:");
          v25(4, "%c[%{public}s %{public}s]:%i Invalid Service Parameter record; ignore", v27, v28, v29, 937);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v30 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
        {
          __int16 v31 = object_getClass(a1);
          if (class_isMetaClass(v31)) {
            int v32 = 43;
          }
          else {
            int v32 = 45;
          }
          __int16 v33 = object_getClassName(a1);
          id v34 = sel_getName("_processNdefRead:tag:");
          *(_DWORD *)int buf = 67109890;
          *(_DWORD *)&uint8_t buf[4] = v32;
          *(_WORD *)unsigned int v157 = 2082;
          *(void *)&v157[2] = v33;
          *(_WORD *)&v157[10] = 2082;
          *(void *)&v157[12] = v34;
          *(_WORD *)&v157[20] = 1024;
          *(_DWORD *)&v157[22] = 937;
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid Service Parameter record; ignore",
            buf,
            0x22u);
        }
      }
      else
      {
        if ([v22 typeNameFormat] != 1) {
          continue;
        }
        __int16 v35 = [v22 type];
        unsigned int v36 = [v35 isEqual:v140];

        if (v36)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          __int16 v37 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v37)
          {
            id v38 = object_getClass(a1);
            if (class_isMetaClass(v38)) {
              uint64_t v39 = 43;
            }
            else {
              uint64_t v39 = 45;
            }
            id v40 = object_getClassName(a1);
            NSErrorUserInfoKey v41 = sel_getName("_processNdefRead:tag:");
            v37(6, "%c[%{public}s %{public}s]:%i Negotiated Handover Exchange identified.", v39, v40, v41, 943);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          int v30 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
          {
            __int16 v42 = object_getClass(a1);
            if (class_isMetaClass(v42)) {
              int v43 = 43;
            }
            else {
              int v43 = 45;
            }
            int v44 = object_getClassName(a1);
            __int16 v45 = sel_getName("_processNdefRead:tag:");
            *(_DWORD *)int buf = 67109890;
            *(_DWORD *)&uint8_t buf[4] = v43;
            *(_WORD *)unsigned int v157 = 2082;
            *(void *)&v157[2] = v44;
            *(_WORD *)&v157[10] = 2082;
            *(void *)&v157[12] = v45;
            *(_WORD *)&v157[20] = 1024;
            *(_DWORD *)&v157[22] = 943;
            _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Negotiated Handover Exchange identified.", buf, 0x22u);
          }
          char obj = 1;
        }
        else
        {
          __int16 v46 = [v22 type];
          unsigned int v47 = [v46 isEqual:v135];

          if (!v47) {
            continue;
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          __int16 v48 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v48)
          {
            __int16 v49 = object_getClass(a1);
            if (class_isMetaClass(v49)) {
              uint64_t v50 = 43;
            }
            else {
              uint64_t v50 = 45;
            }
            __int16 v51 = object_getClassName(a1);
            int v52 = sel_getName("_processNdefRead:tag:");
            v48(6, "%c[%{public}s %{public}s]:%i Static Handover Exchange identified.", v50, v51, v52, 946);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          int v30 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
          {
            __int16 v53 = object_getClass(a1);
            if (class_isMetaClass(v53)) {
              int v54 = 43;
            }
            else {
              int v54 = 45;
            }
            BOOL v55 = object_getClassName(a1);
            __int16 v56 = sel_getName("_processNdefRead:tag:");
            *(_DWORD *)int buf = 67109890;
            *(_DWORD *)&uint8_t buf[4] = v54;
            *(_WORD *)unsigned int v157 = 2082;
            *(void *)&v157[2] = v55;
            *(_WORD *)&v157[10] = 2082;
            *(void *)&v157[12] = v56;
            *(_WORD *)&v157[20] = 1024;
            *(_DWORD *)&v157[22] = 946;
            _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Static Handover Exchange identified.", buf, 0x22u);
          }
          char v136 = 1;
        }
      }
    }
    id v19 = [v18 countByEnumeratingWithState:&v145 objects:v153 count:16];
  }
  while (v19);

  if (obj)
  {
    id v57 = v129;
    id v127 = v128;
    id v137 = [objc_alloc((Class)NSData) initWithBytes:"TpHs" length:2];
    BOOL v133 = objc_opt_new();
    long long v151 = 0u;
    long long v152 = 0u;
    long long v149 = 0u;
    long long v150 = 0u;
    id obja = [v57 records];
    id v58 = [obja countByEnumeratingWithState:&v149 objects:buf count:16];
    if (!v58) {
      goto LABEL_109;
    }
    uint64_t v59 = *(void *)v150;
    while (1)
    {
      for (j = 0; j != v58; j = (char *)j + 1)
      {
        if (*(void *)v150 != v59) {
          objc_enumerationMutation(obja);
        }
        id v61 = *(void **)(*((void *)&v149 + 1) + 8 * (void)j);
        if ([v61 typeNameFormat] == 1)
        {
          BOOL v62 = [v61 type];
          unsigned int v63 = [v62 isEqual:v137];

          if (v63)
          {
            uint64_t v64 = [v61 payload];
            BOOL v65 = (unint64_t)[v64 length] < 2;

            if (v65)
            {
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              __int16 v66 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
              if (v66)
              {
                int v67 = object_getClass(a1);
                if (class_isMetaClass(v67)) {
                  uint64_t v68 = 43;
                }
                else {
                  uint64_t v68 = 45;
                }
                id v69 = object_getClassName(a1);
                id v70 = sel_getName("_processNegotiatedNdefRead:tag:");
                v66(4, "%c[%{public}s %{public}s]:%i Invalid Service Parameter record; ignore", v68, v69, v70, 874);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              id v71 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
              {
                uint64_t v72 = object_getClass(a1);
                if (class_isMetaClass(v72)) {
                  int v73 = 43;
                }
                else {
                  int v73 = 45;
                }
                id v74 = object_getClassName(a1);
                id v75 = sel_getName("_processNegotiatedNdefRead:tag:");
                *(_DWORD *)block = 67109890;
                *(_DWORD *)&void block[4] = v73;
                *(_WORD *)id v155 = 2082;
                *(void *)&v155[2] = v74;
                *(_WORD *)&v155[10] = 2082;
                *(void *)&v155[12] = v75;
                *(_WORD *)&v155[20] = 1024;
                *(_DWORD *)&v155[22] = 874;
                unsigned int v76 = v71;
                goto LABEL_105;
              }
            }
            else
            {
              id v77 = [v61 payload];
              id v78 = [v77 bytes];

              id v79 = (unsigned char *)*((unsigned __int8 *)v78 + 1);
              id v80 = [v61 payload];
              LOBYTE(v77) = (char *)[v80 length] - 7 == v79;

              if (v77)
              {
                id v81 = objc_alloc((Class)NSString);
                long long v82 = [v61 payload];
                long long v83 = [v82 subdataWithRange:2, v79];
                id v71 = [v81 initWithData:v83 encoding:1];

                long long v84 = +[NFTNEPService serviceWithURI:v71 minWaitTime:v79[(void)v78 + 3] maxWaitTimeExtension:v79[(void)v78 + 4] maxMessageSize:bswap32(*(unsigned __int16 *)&v79[(void)v78 + 5]) >> 16];
                [a1[9] addObject:v84];
                [v133 addObject:v71];
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                BOOL v85 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
                if (v85)
                {
                  long long v86 = object_getClass(a1);
                  if (class_isMetaClass(v86)) {
                    uint64_t v87 = 43;
                  }
                  else {
                    uint64_t v87 = 45;
                  }
                  __int16 v88 = object_getClassName(a1);
                  id v89 = sel_getName("_processNegotiatedNdefRead:tag:");
                  v85(6, "%c[%{public}s %{public}s]:%i Found TNEP service: %{public}@", v87, v88, v89, 894, v84);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                __int16 v90 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v91 = object_getClass(a1);
                  if (class_isMetaClass(v91)) {
                    int v92 = 43;
                  }
                  else {
                    int v92 = 45;
                  }
                  int v93 = object_getClassName(a1);
                  __int16 v94 = sel_getName("_processNegotiatedNdefRead:tag:");
                  *(_DWORD *)block = 67110146;
                  *(_DWORD *)&void block[4] = v92;
                  *(_WORD *)id v155 = 2082;
                  *(void *)&v155[2] = v93;
                  *(_WORD *)&v155[10] = 2082;
                  *(void *)&v155[12] = v94;
                  *(_WORD *)&v155[20] = 1024;
                  *(_DWORD *)&v155[22] = 894;
                  *(_WORD *)&v155[26] = 2114;
                  *(void *)&v155[28] = v84;
                  _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Found TNEP service: %{public}@", block, 0x2Cu);
                }
              }
              else
              {
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                id v95 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
                if (v95)
                {
                  id v96 = object_getClass(a1);
                  if (class_isMetaClass(v96)) {
                    uint64_t v97 = 43;
                  }
                  else {
                    uint64_t v97 = 45;
                  }
                  int v98 = object_getClassName(a1);
                  __int16 v99 = sel_getName("_processNegotiatedNdefRead:tag:");
                  v95(4, "%c[%{public}s %{public}s]:%i Invalid Service Parameter record; ignore",
                    v97,
                    v98,
                    v99,
                    881);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                id v71 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
                {
                  uint64_t v100 = object_getClass(a1);
                  if (class_isMetaClass(v100)) {
                    int v101 = 43;
                  }
                  else {
                    int v101 = 45;
                  }
                  id v102 = object_getClassName(a1);
                  __int16 v103 = sel_getName("_processNegotiatedNdefRead:tag:");
                  *(_DWORD *)block = 67109890;
                  *(_DWORD *)&void block[4] = v101;
                  *(_WORD *)id v155 = 2082;
                  *(void *)&v155[2] = v102;
                  *(_WORD *)&v155[10] = 2082;
                  *(void *)&v155[12] = v103;
                  *(_WORD *)&v155[20] = 1024;
                  *(_DWORD *)&v155[22] = 881;
                  unsigned int v76 = v71;
LABEL_105:
                  _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid Service Parameter record; ignore",
                    block,
                    0x22u);
                }
              }
            }

            continue;
          }
        }
      }
      id v58 = [obja countByEnumeratingWithState:&v149 objects:buf count:16];
      if (!v58)
      {
LABEL_109:

        if ([v133 count])
        {
          int v104 = a1;
          objc_sync_enter(v104);
          sub_100257670((uint64_t)v104, v127);
          objc_sync_exit(v104);

          __int16 v105 = NFSharedSignpostLog();
          id v106 = v105;
          os_signpost_id_t v107 = (os_signpost_id_t)v104[13];
          if (v107 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v105))
          {
            *(_WORD *)block = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v106, OS_SIGNPOST_EVENT, v107, "TNEP_Reader_DiscoveredServices", (const char *)&unk_100286819, block, 2u);
          }

          NSErrorUserInfoKey v108 = v104[3];
          *(void *)block = _NSConcreteStackBlock;
          *(void *)id v155 = 3221225472;
          *(void *)&v155[8] = sub_10025AACC;
          *(void *)&v155[16] = &unk_100301CB8;
          *(void *)&v155[24] = v104;
          *(void *)&v155[32] = v133;
          dispatch_async(v108, block);
        }
        goto LABEL_134;
      }
    }
  }
  if (v136)
  {
    id v119 = v129;
    id v120 = v128;
    if (v131)
    {
      __int16 v121 = a1;
      objc_sync_enter(v121);
      objc_storeStrong(v121 + 12, a2);
      objc_sync_exit(v121);

      CFStringRef v122 = NFSharedSignpostLog();
      __int16 v123 = v122;
      os_signpost_id_t v124 = (os_signpost_id_t)v121[13];
      if (v124 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v122))
      {
        *(_WORD *)int buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v123, OS_SIGNPOST_EVENT, v124, "StaticNFC_Reader_EngagementDiscovered", (const char *)&unk_100286819, buf, 2u);
      }

      uint64_t v125 = v121[3];
      *(void *)int buf = _NSConcreteStackBlock;
      *(void *)unsigned int v157 = 3221225472;
      *(void *)&v157[8] = sub_10025AB2C;
      *(void *)&v157[16] = &unk_100301CB8;
      *(void *)&v157[24] = v121;
      *(void *)&v157[32] = v119;
      dispatch_async(v125, buf);
    }
  }
LABEL_134:

LABEL_135:
  id v15 = v130;
LABEL_136:

LABEL_137:
}

void *sub_100254840(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  if (!a1) {
    goto LABEL_18;
  }
  uint64_t v6 = a1[11];
  if (!v6)
  {
    id v25 = 0;
    goto LABEL_17;
  }
  if (([*(id *)(v6 + 88) readerModeProtectionActive] & 1) == 0)
  {
    id v25 = (void *)a1[11];
LABEL_17:
    a1 = sub_1001932E8(v25, v5, a3);
    goto LABEL_18;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v8 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(a1);
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(a1);
    uint64_t Name = sel_getName("_readNdefFromTag:outError:");
    uint64_t v12 = 45;
    if (isMetaClass) {
      uint64_t v12 = 43;
    }
    v8(4, "%c[%{public}s %{public}s]:%i Reader protection active", v12, ClassName, Name, 963);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v13 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    char v14 = object_getClass(a1);
    if (class_isMetaClass(v14)) {
      int v15 = 43;
    }
    else {
      int v15 = 45;
    }
    *(_DWORD *)int buf = 67109890;
    int v33 = v15;
    __int16 v34 = 2082;
    __int16 v35 = object_getClassName(a1);
    __int16 v36 = 2082;
    __int16 v37 = sel_getName("_readNdefFromTag:outError:");
    __int16 v38 = 1024;
    int v39 = 963;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Reader protection active", buf, 0x22u);
  }

  id v16 = objc_alloc((Class)NSError);
  char v17 = +[NSString stringWithUTF8String:"nfcd"];
  v30[0] = NSLocalizedDescriptionKey;
  unsigned __int8 v18 = +[NSString stringWithUTF8String:"Reader mode temporarily disabled"];
  v31[0] = v18;
  v31[1] = &off_100320818;
  v30[1] = @"Line";
  v30[2] = @"Method";
  id v19 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_readNdefFromTag:outError:")];
  v31[2] = v19;
  v30[3] = NSDebugDescriptionErrorKey;
  id v20 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_readNdefFromTag:outError:"), 964];
  v31[3] = v20;
  long long v21 = +[NSDictionary dictionaryWithObjects:v31 forKeys:v30 count:4];
  id v22 = [v16 initWithDomain:v17 code:47 userInfo:v21];

  if (a3) {
    *a3 = v22;
  }
  long long v23 = a1[3];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10025AB8C;
  block[3] = &unk_100301CB8;
  void block[4] = a1;
  id v29 = v22;
  id v24 = v22;
  dispatch_async(v23, block);

  a1 = 0;
LABEL_18:

  return a1;
}

void sub_100254EE0(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 72), a2);
  }
}

void sub_100254EF0(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 64), a2);
  }
}

uint64_t sub_100254F00(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100255388(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = objc_alloc((Class)NSError);
  id v3 = +[NSString stringWithUTF8String:"nfcd"];
  NSErrorUserInfoKey v7 = NSLocalizedDescriptionKey;
  id v4 = +[NSString stringWithUTF8String:"Invalid State"];
  uint64_t v8 = v4;
  id v5 = +[NSDictionary dictionaryWithObjects:&v8 forKeys:&v7 count:1];
  id v6 = [v2 initWithDomain:v3 code:12 userInfo:v5];
  (*(void (**)(uint64_t, id))(v1 + 16))(v1, v6);
}

BOOL sub_1002554A0(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = *(id *)(a1 + 80);
  objc_sync_enter(v4);
  id v5 = [v3 asData];
  id v6 = [v5 length];
  if (v6)
  {
    id v7 = *(id *)(a1 + 80);
    id v8 = *(id *)(a1 + 80);
    [v7 resetBytesInRange:0, [v8 length]];

    id v9 = *(id *)(a1 + 80);
    id v10 = [v5 length];
    id v11 = v5;
    [v9 replaceBytesInRange:2 withBytes:v10 length:[v11 bytes]];

    id v12 = *(id *)(a1 + 80);
    id v13 = [v12 mutableBytes];

    unsigned char *v13 = (unsigned __int16)[v11 length] >> 8;
    v13[1] = [v11 length];
  }

  objc_sync_exit(v4);
  return v6 != 0;
}

void sub_1002555F0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100255608(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

uint64_t sub_10025576C(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void sub_100255BD4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100255BF8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = objc_alloc((Class)NSError);
  id v3 = +[NSString stringWithUTF8String:"nfcd"];
  NSErrorUserInfoKey v7 = NSLocalizedDescriptionKey;
  id v4 = +[NSString stringWithUTF8String:"TNEP invalid service"];
  id v8 = v4;
  id v5 = +[NSDictionary dictionaryWithObjects:&v8 forKeys:&v7 count:1];
  id v6 = [v2 initWithDomain:v3 code:59 userInfo:v5];
  (*(void (**)(uint64_t, id))(v1 + 16))(v1, v6);
}

void sub_100255D10(uint64_t a1, void *a2, void *a3)
{
  id v45 = a2;
  id v46 = a3;
  id v5 = NFSharedSignpostLog();
  id v6 = v5;
  uint64_t v7 = *(void *)(a1 + 32);
  if (v7)
  {
    os_signpost_id_t v8 = *(void *)(v7 + 104);
    if (v8 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v5))
    {
      uint64_t v9 = *(void *)(a1 + 40);
      *(_DWORD *)int buf = 138412546;
      *(void *)__int16 v56 = v9;
      *(_WORD *)&v56[8] = 2112;
      *(void *)&v56[10] = v46;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v6, OS_SIGNPOST_INTERVAL_END, v8, "TNEP_Reader_Select", "service=%@  error=%@", buf, 0x16u);
    }
  }

  if (v46)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (Logger)
    {
      Class = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(Class)) {
        uint64_t v12 = 43;
      }
      else {
        uint64_t v12 = 45;
      }
      Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
      uint64_t Name = sel_getName(*(SEL *)(a1 + 64));
      Logger(3, "%c[%{public}s %{public}s]:%i %{public}@", v12, ClassName, Name, 215, v46);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v15 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      id v16 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v16)) {
        int v17 = 43;
      }
      else {
        int v17 = 45;
      }
      unsigned __int8 v18 = object_getClassName(*(id *)(a1 + 32));
      id v19 = sel_getName(*(SEL *)(a1 + 64));
      *(_DWORD *)int buf = 67110146;
      *(_DWORD *)__int16 v56 = v17;
      *(_WORD *)&void v56[4] = 2082;
      *(void *)&v56[6] = v18;
      *(_WORD *)&unsigned char v56[14] = 2082;
      *(void *)&v56[16] = v19;
      __int16 v57 = 1024;
      int v58 = 215;
      __int16 v59 = 2114;
      id v60 = v46;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
    }

    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
  }
  else
  {
    uint64_t v20 = *(void *)(a1 + 32);
    id v44 = v45;
    if (v20)
    {
      id v21 = [objc_alloc((Class)NSData) initWithBytes:"TeTsTpHs" length:2];
      long long v49 = 0u;
      long long v50 = 0u;
      long long v47 = 0u;
      long long v48 = 0u;
      id v22 = [v44 records];
      id v23 = [v22 countByEnumeratingWithState:&v47 objects:buf count:16];
      if (v23)
      {
        uint64_t v24 = *(void *)v48;
        do
        {
          for (uint64_t i = 0; i != v23; uint64_t i = (char *)i + 1)
          {
            if (*(void *)v48 != v24) {
              objc_enumerationMutation(v22);
            }
            id v26 = *(void **)(*((void *)&v47 + 1) + 8 * i);
            if ([v26 typeNameFormat] == 1)
            {
              uint64_t v27 = [v26 type];
              if ([v27 isEqualToData:v21])
              {
                id v28 = [v26 payload];
                BOOL v29 = [v28 length] == (id)1;

                if (v29)
                {
                  id v23 = [v26 payload];
                  int v30 = (unsigned __int8 *)[v23 bytes];

                  LODWORD(v20) = *v30;
                  LODWORD(v23) = 1;
                  goto LABEL_31;
                }
              }
              else
              {
              }
            }
          }
          id v23 = [v22 countByEnumeratingWithState:&v47 objects:buf count:16];
        }
        while (v23);
      }
      LODWORD(v20) = 0;
LABEL_31:
    }
    else
    {
      LODWORD(v23) = 0;
    }

    id v31 = *(id *)(a1 + 32);
    objc_sync_enter(v31);
    if (v23)
    {
      sub_10009012C(*(void *)(a1 + 32), *(void **)(a1 + 48));
      objc_sync_exit(v31);

      if (v20)
      {
        id v32 = [objc_alloc((Class)NSError) initWithDomain:@"tnep.reader" code:v20 userInfo:0];
        uint64_t v33 = *(void *)(a1 + 56);
        id v34 = objc_alloc((Class)NSError);
        __int16 v35 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v53 = NSUnderlyingErrorKey;
        id v54 = v32;
        __int16 v36 = +[NSDictionary dictionaryWithObjects:&v54 forKeys:&v53 count:1];
        id v37 = [v34 initWithDomain:v35 code:61 userInfo:v36];
        (*(void (**)(uint64_t, id))(v33 + 16))(v33, v37);
      }
      else
      {
        (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
      }
    }
    else
    {
      sub_10009012C(*(void *)(a1 + 32), 0);
      objc_sync_exit(v31);

      uint64_t v38 = *(void *)(a1 + 56);
      id v39 = objc_alloc((Class)NSError);
      id v40 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v51 = NSLocalizedDescriptionKey;
      NSErrorUserInfoKey v41 = +[NSString stringWithUTF8String:"TNEP invalid service"];
      int v52 = v41;
      __int16 v42 = +[NSDictionary dictionaryWithObjects:&v52 forKeys:&v51 count:1];
      id v43 = [v39 initWithDomain:v40 code:59 userInfo:v42];
      (*(void (**)(uint64_t, id))(v38 + 16))(v38, v43);
    }
  }
}

void sub_1002562C0(uint64_t a1, void *a2, unsigned int a3, void *a4)
{
  id v7 = a2;
  id v8 = a4;
  uint64_t v9 = v8;
  if (a1)
  {
    BOOL v62 = v8;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v11 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass((id)a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName((id)a1);
      uint64_t Name = sel_getName("_changeService:select:completionHandler:");
      id v16 = [v7 uri];
      uint64_t v17 = 45;
      if (isMetaClass) {
        uint64_t v17 = 43;
      }
      v11(6, "%c[%{public}s %{public}s]:%i svc:%{public}@   select:%d", v17, ClassName, Name, 816, v16, a3);
    }
    unsigned int v63 = v7;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    unsigned __int8 v18 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      id v19 = object_getClass((id)a1);
      if (class_isMetaClass(v19)) {
        int v20 = 43;
      }
      else {
        int v20 = 45;
      }
      id v21 = object_getClassName((id)a1);
      id v22 = sel_getName("_changeService:select:completionHandler:");
      id v23 = [v63 uri];
      *(_DWORD *)int buf = 67110402;
      int v77 = v20;
      __int16 v78 = 2082;
      id v79 = v21;
      __int16 v80 = 2082;
      id v81 = v22;
      __int16 v82 = 1024;
      int v83 = 816;
      __int16 v84 = 2114;
      BOOL v85 = v23;
      __int16 v86 = 1024;
      unsigned int v87 = a3;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i svc:%{public}@   select:%d", buf, 0x32u);
    }
    uint64_t v24 = *(void *)(a1 + 88);
    if (v24 && [*(id *)(v24 + 88) readerModeProtectionActive])
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v25 = NFLogGetLogger();
      if (v25)
      {
        id v26 = (void (*)(uint64_t, const char *, ...))v25;
        uint64_t v27 = object_getClass((id)a1);
        BOOL v28 = class_isMetaClass(v27);
        BOOL v29 = object_getClassName((id)a1);
        id v61 = sel_getName("_changeService:select:completionHandler:");
        uint64_t v30 = 45;
        if (v28) {
          uint64_t v30 = 43;
        }
        v26(4, "%c[%{public}s %{public}s]:%i Reader protection active", v30, v29, v61, 819);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v31 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        id v32 = object_getClass((id)a1);
        if (class_isMetaClass(v32)) {
          int v33 = 43;
        }
        else {
          int v33 = 45;
        }
        id v34 = object_getClassName((id)a1);
        __int16 v35 = sel_getName("_changeService:select:completionHandler:");
        *(_DWORD *)int buf = 67109890;
        int v77 = v33;
        __int16 v78 = 2082;
        id v79 = v34;
        __int16 v80 = 2082;
        id v81 = v35;
        __int16 v82 = 1024;
        int v83 = 819;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Reader protection active", buf, 0x22u);
      }

      id v36 = objc_alloc((Class)NSError);
      id v37 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v74 = NSLocalizedDescriptionKey;
      uint64_t v38 = +[NSString stringWithUTF8String:"Reader mode temporarily disabled"];
      id v75 = v38;
      id v39 = +[NSDictionary dictionaryWithObjects:&v75 forKeys:&v74 count:1];
      id v40 = [v36 initWithDomain:v37 code:47 userInfo:v39];

      id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
      [WeakRetained tnepReaderServicesAborted:v40];

      __int16 v42 = *(NSObject **)(a1 + 24);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10025A980;
      block[3] = &unk_1003045D8;
      uint64_t v9 = v62;
      id v72 = v40;
      id v73 = v62;
      id v43 = v40;
      dispatch_async(v42, block);

      id v7 = v63;
    }
    else
    {
      id v43 = [objc_alloc((Class)NSData) initWithBytes:"TsTpHs" length:2];
      id v7 = v63;
      id v44 = [v63 uri];
      unsigned __int8 v45 = [v44 length];

      unsigned __int8 v70 = v45;
      id v46 = [objc_alloc((Class)NSMutableData) initWithBytes:&v70 length:1];
      if (v70)
      {
        long long v47 = [v63 uri];
        long long v48 = [v47 dataUsingEncoding:1];
        [v46 appendData:v48];
      }
      *(_DWORD *)int buf = 0;
      long long v49 = objc_opt_new();
      long long v50 = +[NFNdefRecordInternal recordsWithTNF:type:identifier:payload:chunkSize:outError:](NFNdefRecordInternal, "recordsWithTNF:type:identifier:payload:chunkSize:outError:", 1, v43, v49, v46, (char *)[v46 length] + 1, buf);

      if (*(_DWORD *)buf)
      {
        NSErrorUserInfoKey v51 = *(NSObject **)(a1 + 24);
        v68[0] = _NSConcreteStackBlock;
        v68[1] = 3221225472;
        v68[2] = sub_10025A998;
        v68[3] = &unk_1003046C8;
        uint64_t v9 = v62;
        id v69 = v62;
        dispatch_async(v51, v68);
        int v52 = v69;
      }
      else
      {
        int v52 = objc_opt_new();
        [v52 addRecordArray:v50];
        uint64_t v9 = v62;
        if (a3)
        {
          sub_10025723C((void *)a1, v52, v63, v62);
        }
        else
        {
          id v54 = *(void **)(a1 + 88);
          NSErrorUserInfoKey v53 = *(void **)(a1 + 96);
          id v67 = 0;
          id v55 = v53;
          id v56 = v54;
          id v7 = v63;
          id v57 = v56;
          sub_1001933C0(v56, v52, v55, 0, &v67);
          id v58 = v67;

          __int16 v59 = *(NSObject **)(a1 + 24);
          v64[0] = _NSConcreteStackBlock;
          v64[1] = 3221225472;
          v64[2] = sub_10025AAB4;
          v64[3] = &unk_1003045D8;
          id v65 = v58;
          id v66 = v62;
          id v60 = v58;
          dispatch_async(v59, v64);
        }
      }
    }
  }
}

void sub_100256BEC(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = NFSharedSignpostLog();
  id v6 = v5;
  uint64_t v7 = *(void *)(a1 + 32);
  if (v7)
  {
    os_signpost_id_t v8 = *(void *)(v7 + 104);
    if (v8 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v5))
    {
      *(_DWORD *)int buf = 138412290;
      id v20 = v4;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v6, OS_SIGNPOST_INTERVAL_END, v8, "TNEP_Reader_Deselect", "error=%@", buf, 0xCu);
    }
  }

  id v9 = *(id *)(a1 + 32);
  objc_sync_enter(v9);
  sub_10009012C(*(void *)(a1 + 32), 0);
  objc_sync_exit(v9);

  if (v4)
  {
    if ([v4 code] != (id)47)
    {
      id v10 = objc_alloc((Class)NSError);
      id v11 = +[NSString stringWithUTF8String:"nfcd"];
      v17[0] = NSLocalizedDescriptionKey;
      uint64_t v12 = +[NSString stringWithUTF8String:"TNEP service specific error"];
      v18[0] = v12;
      v18[1] = v4;
      v17[1] = NSUnderlyingErrorKey;
      id v17[2] = @"Line";
      v18[2] = &off_100320800;
      v17[3] = @"Method";
      id v13 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
      v18[3] = v13;
      void v17[4] = NSDebugDescriptionErrorKey;
      id v14 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 259];
      void v18[4] = v14;
      int v15 = +[NSDictionary dictionaryWithObjects:v18 forKeys:v17 count:5];
      id v16 = [v10 initWithDomain:v11 code:61 userInfo:v15];

      id v4 = v16;
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

void sub_100256FEC(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = NFSharedSignpostLog();
  os_signpost_id_t v8 = v7;
  uint64_t v9 = *(void *)(a1 + 32);
  if (v9)
  {
    os_signpost_id_t v10 = *(void *)(v9 + 104);
    if (v10 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v7))
    {
      *(_DWORD *)int buf = 138412290;
      *(void *)uint64_t v25 = v6;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v8, OS_SIGNPOST_INTERVAL_END, v10, "TNEP_Reader_Send", "error=%@", buf, 0xCu);
    }
  }

  if (v6)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v12 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
      uint64_t Name = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v17 = 45;
      if (isMetaClass) {
        uint64_t v17 = 43;
      }
      v12(3, "%c[%{public}s %{public}s]:%i Error sending msg=%{public}@\nerror=%{public}@", v17, ClassName, Name, 278, *(void *)(a1 + 40), v6);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    unsigned __int8 v18 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      id v19 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v19)) {
        int v20 = 43;
      }
      else {
        int v20 = 45;
      }
      id v21 = object_getClassName(*(id *)(a1 + 32));
      id v22 = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v23 = *(void *)(a1 + 40);
      *(_DWORD *)int buf = 67110402;
      *(_DWORD *)uint64_t v25 = v20;
      *(_WORD *)&void v25[4] = 2082;
      *(void *)&v25[6] = v21;
      __int16 v26 = 2082;
      uint64_t v27 = v22;
      __int16 v28 = 1024;
      int v29 = 278;
      __int16 v30 = 2114;
      uint64_t v31 = v23;
      __int16 v32 = 2114;
      id v33 = v6;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error sending msg=%{public}@\nerror=%{public}@", buf, 0x36u);
    }
  }
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
}

void sub_10025723C(void *a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (a1)
  {
    __int16 v35 = v7;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v11 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(a1);
      uint64_t Name = sel_getName("_transmitMessage:toService:completionHandler:");
      id v16 = [v8 uri];
      uint64_t v17 = 45;
      if (isMetaClass) {
        uint64_t v17 = 43;
      }
      v11(6, "%c[%{public}s %{public}s]:%i %{public}@", v17, ClassName, Name, 786, v16);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    unsigned __int8 v18 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      id v19 = object_getClass(a1);
      if (class_isMetaClass(v19)) {
        int v20 = 43;
      }
      else {
        int v20 = 45;
      }
      id v21 = object_getClassName(a1);
      id v22 = sel_getName("_transmitMessage:toService:completionHandler:");
      uint64_t v23 = [v8 uri];
      *(_DWORD *)int buf = 67110146;
      int v46 = v20;
      __int16 v47 = 2082;
      long long v48 = v21;
      __int16 v49 = 2082;
      long long v50 = v22;
      __int16 v51 = 1024;
      int v52 = 786;
      __int16 v53 = 2114;
      id v54 = v23;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
    }
    uint64_t v24 = a1[11];
    if (v24)
    {
      if ([*(id *)(v24 + 88) readerModeProtectionActive])
      {
        uint64_t v25 = a1[3];
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_10025A570;
        block[3] = &unk_100301D38;
        void block[4] = a1;
        id v44 = "_transmitMessage:toService:completionHandler:";
        id v43 = v9;
        dispatch_async(v25, block);

        goto LABEL_22;
      }
      __int16 v26 = (void *)a1[11];
    }
    else
    {
      __int16 v26 = 0;
    }
    uint64_t v27 = (void *)a1[12];
    id v41 = 0;
    id v28 = v27;
    id v29 = v26;
    id v7 = v35;
    sub_1001933C0(v29, v35, v28, 0, &v41);
    id v30 = v41;

    if (v30)
    {
      uint64_t v31 = a1[3];
      v36[0] = _NSConcreteStackBlock;
      v36[1] = 3221225472;
      v36[2] = sub_10025A7D0;
      v36[3] = &unk_100306BE8;
      v36[4] = a1;
      id v40 = "_transmitMessage:toService:completionHandler:";
      id v37 = v35;
      id v38 = v30;
      id v39 = v9;
      dispatch_async(v31, v36);
    }
    else
    {
      id v32 = v8;
      unsigned int v33 = [v32 minWaitTime];
      if (v33 >= 4) {
        int64_t v34 = 1000000 * (1 << ((v33 >> 2) - 1));
      }
      else {
        int64_t v34 = 0;
      }

      sub_100259E1C((dispatch_queue_t *)a1, v34, ([v32 maxWaitTimeExtension] + 1), v9);
    }
  }
LABEL_22:
}

void sub_100257670(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 96), a2);
  }
}

void sub_100257688(uint64_t a1)
{
  uint64_t v31 = objc_opt_new();
  [v31 addRecordArray:*(void *)(a1 + 64)];
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  id v33 = (id)a1;
  id obj = *(id *)(a1 + 72);
  id v32 = [obj countByEnumeratingWithState:&v37 objects:v51 count:16];
  if (v32)
  {
    uint64_t v30 = *(void *)v38;
    do
    {
      for (uint64_t i = 0; i != v32; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v38 != v30) {
          objc_enumerationMutation(obj);
        }
        id v3 = *(void **)(*((void *)&v37 + 1) + 8 * i);
        char v34 = 16;
        id v4 = [v3 uri];
        unsigned __int8 v35 = [v4 length];
        memset(v36, 0, sizeof(v36));

        id v5 = [objc_alloc((Class)NSMutableData) initWithBytes:&v34 length:2];
        id v6 = [v3 uri];
        id v7 = [v6 dataUsingEncoding:4];
        [v5 appendData:v7];

        char v34 = 0;
        unsigned __int8 v35 = [v3 minWaitTime];
        v36[0] = [v3 maxWaitTimeExtension] & 0xF;
        unsigned int v8 = [v3 maxMessageSize];
        if (v8 >= 0x800) {
          unsigned int v9 = 2048;
        }
        else {
          unsigned int v9 = v8;
        }
        *(_WORD *)&v36[1] = __rev16(v9);
        [v5 appendBytes:&v34 length:5];
        id v10 = objc_alloc((Class)NFNdefRecordInternal);
        id v11 = [@"Tp" dataUsingEncoding:4];
        id v12 = [v10 initWithHeader:17 type:v11 identifier:0 payload:v5];

        [v31 addRecord:v12];
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          id v14 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(v33);
          BOOL isMetaClass = class_isMetaClass(Class);
          Classuint64_t Name = object_getClassName(v33);
          uint64_t Name = sel_getName("_generateInitialServiceReadyMessage");
          id v19 = [v3 uri];
          id v28 = [v19 UTF8String];
          uint64_t v20 = 45;
          if (isMetaClass) {
            uint64_t v20 = 43;
          }
          v14(6, "%c[%{public}s %{public}s]:%i service=%s", v20, ClassName, Name, 380, v28);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v21 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
        {
          id v22 = object_getClass(v33);
          if (class_isMetaClass(v22)) {
            int v23 = 43;
          }
          else {
            int v23 = 45;
          }
          uint64_t v24 = object_getClassName(v33);
          uint64_t v25 = sel_getName("_generateInitialServiceReadyMessage");
          id v26 = [v3 uri];
          id v27 = [v26 UTF8String];
          *(_DWORD *)int buf = 67110146;
          int v42 = v23;
          __int16 v43 = 2082;
          id v44 = v24;
          __int16 v45 = 2082;
          int v46 = v25;
          __int16 v47 = 1024;
          int v48 = 380;
          __int16 v49 = 2080;
          id v50 = v27;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i service=%s", buf, 0x2Cu);
        }
      }
      id v32 = [obj countByEnumeratingWithState:&v37 objects:v51 count:16];
    }
    while (v32);
  }

  sub_1002554A0((uint64_t)v33, v31);
}

void sub_100257A7C(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    id v5 = *(NSObject **)(a1 + 24);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100258F50;
    block[3] = &unk_100301C90;
    void block[4] = a1;
    id v7 = v3;
    unsigned int v8 = "_hceReadForPurpose:";
    dispatch_async(v5, block);
  }
}

uint64_t sub_100257B2C(uint64_t a1)
{
  id v134 = *(id *)(a1 + 80);
  objc_sync_enter(v134);
  id v2 = *(id *)(a1 + 80);
  id v3 = (unsigned __int16 *)[v2 bytes];

  uint64_t v4 = __rev16(*v3);
  if (v4)
  {
    id v5 = [objc_alloc((Class)NFNdefMessageInternal) initWithBytes:v3 + 1 length:v4];
    if (v5)
    {
      int v6 = *(unsigned __int8 *)(a1 + 9);
      *(unsigned char *)(a1 + 9) = 0;
      id v135 = v5;
      id v7 = [v5 records];
      id v8 = [v7 count];

      if (v8 != (id)1)
      {
        int v44 = 1;
        if (!v6) {
          goto LABEL_60;
        }
        goto LABEL_55;
      }
      int v133 = v6;
      long long v147 = 0u;
      long long v148 = 0u;
      long long v145 = 0u;
      long long v146 = 0u;
      unsigned int v9 = [v135 records];
      id v10 = [v9 countByEnumeratingWithState:&v145 objects:v153 count:16];
      id obj = v9;
      if (!v10) {
        goto LABEL_39;
      }
      uint64_t v11 = *(void *)v146;
LABEL_6:
      uint64_t v12 = 0;
      while (1)
      {
        if (*(void *)v146 != v11) {
          objc_enumerationMutation(obj);
        }
        id v13 = *(void **)(*((void *)&v145 + 1) + 8 * v12);
        if ([v13 typeNameFormat] != 1) {
          goto LABEL_37;
        }
        id v14 = [v13 type];
        int v15 = [@"Ts" dataUsingEncoding:4];
        unsigned int v16 = [v14 isEqualToData:v15];

        if (!v16) {
          goto LABEL_37;
        }
        id v17 = [v13 payload];
        unsigned __int8 v18 = [v17 bytes];

        id v19 = [v13 payload];
        BOOL v20 = [v19 length] == 0;

        if (v20)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (Logger)
          {
            Class = object_getClass((id)a1);
            if (class_isMetaClass(Class)) {
              uint64_t v37 = 43;
            }
            else {
              uint64_t v37 = 45;
            }
            Classuint64_t Name = object_getClassName((id)a1);
            uint64_t Name = sel_getName("_checkTagMemoryUpdate");
            Logger(4, "%c[%{public}s %{public}s]:%i Invalid Ts record", v37, ClassName, Name, 417);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v29 = NFSharedLogGetLogger();
          if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
            goto LABEL_36;
          }
          long long v40 = object_getClass((id)a1);
          if (class_isMetaClass(v40)) {
            int v41 = 43;
          }
          else {
            int v41 = 45;
          }
          int v42 = object_getClassName((id)a1);
          __int16 v43 = sel_getName("_checkTagMemoryUpdate");
          *(_DWORD *)int buf = 67109890;
          int v155 = v41;
          __int16 v156 = 2082;
          unsigned int v157 = v42;
          __int16 v158 = 2082;
          BOOL v159 = v43;
          __int16 v160 = 1024;
          int v161 = 417;
          char v34 = v29;
        }
        else
        {
          if (!v18 || (unint64_t v21 = *v18, !*v18))
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            id v96 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
            if (v96)
            {
              uint64_t v97 = object_getClass((id)a1);
              if (class_isMetaClass(v97)) {
                uint64_t v98 = 43;
              }
              else {
                uint64_t v98 = 45;
              }
              __int16 v99 = object_getClassName((id)a1);
              uint64_t v100 = sel_getName("_checkTagMemoryUpdate");
              v96(6, "%c[%{public}s %{public}s]:%i TNEP Deselect", v98, v99, v100, 424);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            int v101 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v101, OS_LOG_TYPE_DEFAULT))
            {
              id v102 = object_getClass((id)a1);
              if (class_isMetaClass(v102)) {
                int v103 = 43;
              }
              else {
                int v103 = 45;
              }
              int v104 = object_getClassName((id)a1);
              __int16 v105 = sel_getName("_checkTagMemoryUpdate");
              *(_DWORD *)int buf = 67109890;
              int v155 = v103;
              __int16 v156 = 2082;
              unsigned int v157 = v104;
              __int16 v158 = 2082;
              BOOL v159 = v105;
              __int16 v160 = 1024;
              int v161 = 424;
              _os_log_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i TNEP Deselect", buf, 0x22u);
            }

            id v106 = NFSharedSignpostLog();
            os_signpost_id_t v107 = v106;
            os_signpost_id_t v108 = *(void *)(a1 + 104);
            if (v108 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v106))
            {
              *(_WORD *)int buf = 0;
              _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v107, OS_SIGNPOST_EVENT, v108, "TNEP_TagDevice_Deselect", "NoServiceName", buf, 2u);
            }

            *(unsigned char *)(a1 + 8) = 0;
            sub_100257688(a1);
            id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
            [WeakRetained tnepTagDeviceDeselected:0];

            unsigned __int8 v149 = 1;
LABEL_130:

            goto LABEL_99;
          }
          id v22 = [v13 payload];
          BOOL v23 = (char *)[v22 length] - 1 == (unsigned char *)v21;

          if (v23)
          {
            id v110 = objc_alloc((Class)NSString);
            uint64_t v111 = [v13 payload];
            uint64_t v112 = [v13 payload];
            uint64_t v113 = [v111 subdataWithRange:1, [v112 length] - 1];
            id v114 = [v110 initWithData:v113 encoding:4];

            long long v143 = 0u;
            long long v144 = 0u;
            long long v141 = 0u;
            long long v142 = 0u;
            id v115 = *(id *)(a1 + 72);
            id v116 = [v115 countByEnumeratingWithState:&v141 objects:v152 count:16];
            if (v116)
            {
              uint64_t v117 = *(void *)v142;
              while (2)
              {
                for (uint64_t i = 0; i != v116; uint64_t i = (char *)i + 1)
                {
                  if (*(void *)v142 != v117) {
                    objc_enumerationMutation(v115);
                  }
                  id v119 = *(void **)(*((void *)&v141 + 1) + 8 * i);
                  id v120 = [v119 uri];
                  unsigned int v121 = [v120 isEqualToString:v114];

                  if (v121)
                  {
                    if (*(unsigned char *)(a1 + 8))
                    {
                      id v131 = objc_loadWeakRetained((id *)(a1 + 40));
                      [v131 tnepTagDeviceDeselected:0];
                    }
                    id v132 = objc_loadWeakRetained((id *)(a1 + 40));
                    v137[0] = _NSConcreteStackBlock;
                    v137[1] = 3221225472;
                    v137[2] = sub_100258B50;
                    v137[3] = &unk_100308780;
                    void v137[4] = a1;
                    id v140 = "_checkTagMemoryUpdate";
                    id v138 = v114;
                    int v139 = v119;
                    [v132 tnepTagDeviceSelected:v138 respondHandler:v137];

                    unsigned __int8 v149 = 0;
                    goto LABEL_129;
                  }
                }
                id v116 = [v115 countByEnumeratingWithState:&v141 objects:v152 count:16];
                if (v116) {
                  continue;
                }
                break;
              }
            }

            CFStringRef v122 = NFSharedSignpostLog();
            __int16 v123 = v122;
            os_signpost_id_t v124 = *(void *)(a1 + 104);
            if (v124 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v122))
            {
              *(_WORD *)int buf = 0;
              _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v123, OS_SIGNPOST_EVENT, v124, "TNEP_TagDevice_Deselect", "InvalidServiceName", buf, 2u);
            }

            *(unsigned char *)(a1 + 8) = 0;
            sub_100257688(a1);
            id v125 = objc_loadWeakRetained((id *)(a1 + 40));
            id v126 = objc_alloc((Class)NSError);
            id v127 = +[NSString stringWithUTF8String:"nfcd"];
            NSErrorUserInfoKey v150 = NSLocalizedDescriptionKey;
            id v128 = +[NSString stringWithUTF8String:"TNEP invalid service"];
            long long v151 = v128;
            id v129 = +[NSDictionary dictionaryWithObjects:&v151 forKeys:&v150 count:1];
            id v130 = [v126 initWithDomain:v127 code:59 userInfo:v129];
            [v125 tnepTagDeviceDeselected:v130];

            unsigned __int8 v149 = 1;
LABEL_129:

            goto LABEL_130;
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v24 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v24)
          {
            uint64_t v25 = object_getClass((id)a1);
            if (class_isMetaClass(v25)) {
              uint64_t v26 = 43;
            }
            else {
              uint64_t v26 = 45;
            }
            id v27 = object_getClassName((id)a1);
            id v28 = sel_getName("_checkTagMemoryUpdate");
            v24(4, "%c[%{public}s %{public}s]:%i Invalid Ts record", v26, v27, v28, 431);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v29 = NFSharedLogGetLogger();
          if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR)) {
            goto LABEL_36;
          }
          uint64_t v30 = object_getClass((id)a1);
          if (class_isMetaClass(v30)) {
            int v31 = 43;
          }
          else {
            int v31 = 45;
          }
          id v32 = object_getClassName((id)a1);
          id v33 = sel_getName("_checkTagMemoryUpdate");
          *(_DWORD *)int buf = 67109890;
          int v155 = v31;
          __int16 v156 = 2082;
          unsigned int v157 = v32;
          __int16 v158 = 2082;
          BOOL v159 = v33;
          __int16 v160 = 1024;
          int v161 = 431;
          char v34 = v29;
        }
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid Ts record", buf, 0x22u);
LABEL_36:

LABEL_37:
        if (v10 == (id)++v12)
        {
          id v10 = [obj countByEnumeratingWithState:&v145 objects:v153 count:16];
          if (v10) {
            goto LABEL_6;
          }
LABEL_39:

          int v44 = 1;
          if (!v133)
          {
LABEL_60:
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            id v55 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
            if (v55)
            {
              id v56 = object_getClass((id)a1);
              if (class_isMetaClass(v56)) {
                uint64_t v57 = 43;
              }
              else {
                uint64_t v57 = 45;
              }
              id v58 = object_getClassName((id)a1);
              __int16 v59 = sel_getName("_checkTagMemoryUpdate");
              v55(6, "%c[%{public}s %{public}s]:%i Write completed", v57, v58, v59, 473);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            id v60 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v60, OS_LOG_TYPE_DEFAULT))
            {
              id v61 = object_getClass((id)a1);
              if (class_isMetaClass(v61)) {
                int v62 = 43;
              }
              else {
                int v62 = 45;
              }
              unsigned int v63 = object_getClassName((id)a1);
              uint64_t v64 = sel_getName("_checkTagMemoryUpdate");
              *(_DWORD *)int buf = 67109890;
              int v155 = v62;
              __int16 v156 = 2082;
              unsigned int v157 = v63;
              __int16 v158 = 2082;
              BOOL v159 = v64;
              __int16 v160 = 1024;
              int v161 = 473;
              _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Write completed", buf, 0x22u);
            }

            if (*(unsigned char *)(a1 + 8))
            {
              if (v44)
              {
                id v65 = NFSharedSignpostLog();
                id v66 = v65;
                os_signpost_id_t v67 = *(void *)(a1 + 104);
                if (v67 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v65))
                {
                  *(_WORD *)int buf = 0;
                  _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v66, OS_SIGNPOST_EVENT, v67, "TNEP_TagDevice_MsgReceived", (const char *)&unk_100286819, buf, 2u);
                }

                id v68 = objc_loadWeakRetained((id *)(a1 + 40));
                [v68 tnepTagDeviceNDEFMessageReceived:v135];

                id v69 = *(id *)(a1 + 80);
                id v70 = *(id *)(a1 + 80);
                [v69 resetBytesInRange:0, [v70 length]];
              }
              else
              {
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                id v81 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
                if (v81)
                {
                  __int16 v82 = object_getClass((id)a1);
                  if (class_isMetaClass(v82)) {
                    uint64_t v83 = 43;
                  }
                  else {
                    uint64_t v83 = 45;
                  }
                  __int16 v84 = object_getClassName((id)a1);
                  BOOL v85 = sel_getName("_checkTagMemoryUpdate");
                  v81(3, "%c[%{public}s %{public}s]:%i Dropping invalid message received in TNEP select state", v83, v84, v85, 482);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                __int16 v86 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
                {
                  unsigned int v87 = object_getClass((id)a1);
                  if (class_isMetaClass(v87)) {
                    int v88 = 43;
                  }
                  else {
                    int v88 = 45;
                  }
                  id v89 = object_getClassName((id)a1);
                  __int16 v90 = sel_getName("_checkTagMemoryUpdate");
                  *(_DWORD *)int buf = 67109890;
                  int v155 = v88;
                  __int16 v156 = 2082;
                  unsigned int v157 = v89;
                  __int16 v158 = 2082;
                  BOOL v159 = v90;
                  __int16 v160 = 1024;
                  int v161 = 482;
                  _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Dropping invalid message received in TNEP select state", buf, 0x22u);
                }

                id v91 = *(id *)(a1 + 80);
                id v92 = *(id *)(a1 + 80);
                [v91 resetBytesInRange:0, [v92 length]];

                *(_WORD *)int buf = 1536;
                id v93 = *(id *)(a1 + 80);
                [v93 replaceBytesInRange:0 withBytes:buf length:2];

                id v94 = *(id *)(a1 + 80);
                [v94 replaceBytesInRange:2 withBytes:&unk_10028463C length:6];
              }
            }
            else
            {
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              id v71 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
              if (v71)
              {
                id v72 = object_getClass((id)a1);
                if (class_isMetaClass(v72)) {
                  uint64_t v73 = 43;
                }
                else {
                  uint64_t v73 = 45;
                }
                NSErrorUserInfoKey v74 = object_getClassName((id)a1);
                id v75 = sel_getName("_checkTagMemoryUpdate");
                v71(4, "%c[%{public}s %{public}s]:%i Reset to TNEP initial state due to invalid message recevied", v73, v74, v75, 493);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              unsigned int v76 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v76, OS_LOG_TYPE_ERROR))
              {
                int v77 = object_getClass((id)a1);
                if (class_isMetaClass(v77)) {
                  int v78 = 43;
                }
                else {
                  int v78 = 45;
                }
                id v79 = object_getClassName((id)a1);
                __int16 v80 = sel_getName("_checkTagMemoryUpdate");
                *(_DWORD *)int buf = 67109890;
                int v155 = v78;
                __int16 v156 = 2082;
                unsigned int v157 = v79;
                __int16 v158 = 2082;
                BOOL v159 = v80;
                __int16 v160 = 1024;
                int v161 = 493;
                _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Reset to TNEP initial state due to invalid message recevied", buf, 0x22u);
              }

              sub_100257688(a1);
            }
            goto LABEL_98;
          }
LABEL_55:
          if (v4) {
            char v54 = v44;
          }
          else {
            char v54 = 0;
          }
          if ((v54 & 1) != 0 || !*(unsigned char *)(a1 + 9)) {
            goto LABEL_60;
          }
          goto LABEL_98;
        }
      }
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v45 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v45)
    {
      int v46 = object_getClass((id)a1);
      if (class_isMetaClass(v46)) {
        uint64_t v47 = 43;
      }
      else {
        uint64_t v47 = 45;
      }
      int v48 = object_getClassName((id)a1);
      __int16 v49 = sel_getName("_checkTagMemoryUpdate");
      v45(4, "%c[%{public}s %{public}s]:%i Invalid NDEF message, NLEN=%d", v47, v48, v49, 402, v4);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v50 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
    {
      __int16 v51 = object_getClass((id)a1);
      if (class_isMetaClass(v51)) {
        int v52 = 43;
      }
      else {
        int v52 = 45;
      }
      *(_DWORD *)int buf = 67110146;
      int v155 = v52;
      __int16 v156 = 2082;
      unsigned int v157 = object_getClassName((id)a1);
      __int16 v158 = 2082;
      BOOL v159 = sel_getName("_checkTagMemoryUpdate");
      __int16 v160 = 1024;
      int v161 = 402;
      __int16 v162 = 1024;
      int v163 = v4;
      _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid NDEF message, NLEN=%d", buf, 0x28u);
    }
  }
  id v135 = 0;
  int v53 = *(unsigned __int8 *)(a1 + 9);
  *(unsigned char *)(a1 + 9) = v4 == 0;
  if (v53)
  {
    int v44 = 0;
    goto LABEL_55;
  }
LABEL_98:
  unsigned __int8 v149 = 1;
LABEL_99:

  objc_sync_exit(v134);
  return v149;
}

void sub_100258AA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id obj)
{
}

void sub_100258B50(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v7 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v12 = 43;
    if (!isMetaClass) {
      uint64_t v12 = 45;
    }
    v7(6, "%c[%{public}s %{public}s]:%i Activated (%{public}@),status=0x%lx,optionalRecs=%{public}@", v12, ClassName, Name, 448, *(void *)(a1 + 40), a2, v5);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v13 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    id v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14)) {
      int v15 = 43;
    }
    else {
      int v15 = 45;
    }
    unsigned int v16 = object_getClassName(*(id *)(a1 + 32));
    id v17 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v18 = *(void *)(a1 + 40);
    *(_DWORD *)int buf = 67110658;
    *(_DWORD *)int v41 = v15;
    *(_WORD *)&void v41[4] = 2082;
    *(void *)&v41[6] = v16;
    *(_WORD *)&v41[14] = 2082;
    *(void *)&v41[16] = v17;
    __int16 v42 = 1024;
    int v43 = 448;
    __int16 v44 = 2114;
    uint64_t v45 = v18;
    __int16 v46 = 2048;
    uint64_t v47 = a2;
    __int16 v48 = 2114;
    id v49 = v5;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Activated (%{public}@),status=0x%lx,optionalRecs=%{public}@", buf, 0x40u);
  }

  id v19 = NFSharedSignpostLog();
  BOOL v20 = v19;
  uint64_t v21 = *(void *)(a1 + 32);
  if (v21)
  {
    os_signpost_id_t v22 = *(void *)(v21 + 104);
    if (v22 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v19))
    {
      uint64_t v23 = *(void *)(a1 + 48);
      *(_DWORD *)int buf = 138412546;
      *(void *)int v41 = v23;
      *(_WORD *)&v41[8] = 2048;
      *(void *)&v41[10] = a2;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v20, OS_SIGNPOST_INTERVAL_BEGIN, v22, "TNEP_TagDevice_Select", "service=%@, status=%ld", buf, 0x16u);
    }
  }

  uint64_t v24 = *(void *)(a1 + 32);
  if (v24)
  {
    id v25 = v5;
    id v26 = v5;
    id v27 = objc_opt_new();
    uint64_t v28 = a2;
    buf[0] = a2;
    id v29 = objc_alloc((Class)NFNdefRecordInternal);
    uint64_t v30 = [@"Te" dataUsingEncoding:4];
    id v31 = [objc_alloc((Class)NSData) initWithBytes:buf length:1];
    id v32 = [v29 initWithHeader:17 type:v30 identifier:0 payload:v31];

    [v27 addRecord:v32];
    [v27 addRecordArray:v26];

    if (sub_1002554A0(v24, v27)) {
      *(unsigned char *)(v24 + 8) = 1;
    }
    id v33 = *(id *)(v24 + 56);
    id v34 = [objc_alloc((Class)NSData) initWithBytes:&unk_10028463A length:2];
    [v33 sendAPDU:v34];

    sub_100257A7C(v24, @"TNEP_ActivateService");
    a2 = v28;
    id v5 = v25;
  }
  unsigned __int8 v35 = NFSharedSignpostLog();
  id v36 = v35;
  uint64_t v37 = *(void *)(a1 + 32);
  if (v37)
  {
    os_signpost_id_t v38 = *(void *)(v37 + 104);
    if (v38 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v35))
    {
      uint64_t v39 = *(void *)(a1 + 48);
      *(_DWORD *)int buf = 138412546;
      *(void *)int v41 = v39;
      *(_WORD *)&v41[8] = 2048;
      *(void *)&v41[10] = a2;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v36, OS_SIGNPOST_INTERVAL_END, v38, "TNEP_TagDevice_Select", "service=%@, status=%ld", buf, 0x16u);
    }
  }
}

void sub_100258F50(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 32);
  if (v3)
  {
    id v4 = *(id *)(v3 + 112);
    if (v4)
    {
      id v5 = v4;
      uint64_t v6 = *(void *)(a1 + 32);
      id v7 = v6 ? *(void **)(v6 + 112) : 0;
      unsigned __int8 v8 = [v7 isEqualToString:*(void *)(a1 + 40)];

      if ((v8 & 1) == 0)
      {
        unsigned int v9 = NFSharedSignpostLog();
        id v10 = v9;
        uint64_t v11 = *(void *)(a1 + 32);
        if (v11)
        {
          os_signpost_id_t v12 = *(void *)(v11 + 104);
          if (v12 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v9))
          {
            uint64_t v13 = *(void *)(a1 + 40);
            *(_DWORD *)int buf = 138412290;
            *(void *)int v139 = v13;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v10, OS_SIGNPOST_INTERVAL_END, v12, "TNEP_HCE_Read", "%@", buf, 0xCu);
          }
        }

        sub_10012B380(*(void *)(a1 + 32), 0);
      }
    }
    uint64_t v14 = *(void *)(a1 + 32);
    if (v14 && *(void *)(v14 + 112)) {
      goto LABEL_18;
    }
  }
  else
  {
    uint64_t v14 = 0;
  }
  sub_10012B380(v14, *(void **)(a1 + 40));
  int v15 = NFSharedSignpostLog();
  unsigned int v16 = v15;
  uint64_t v17 = *(void *)(a1 + 32);
  if (v17)
  {
    os_signpost_id_t v18 = *(void *)(v17 + 104);
    if (v18 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v15))
    {
      uint64_t v19 = *(void *)(a1 + 40);
      *(_DWORD *)int buf = 138412290;
      *(void *)int v139 = v19;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_INTERVAL_BEGIN, v18, "TNEP_HCE_Read", "%@", buf, 0xCu);
    }
  }

  uint64_t v14 = *(void *)(a1 + 32);
  if (v14)
  {
LABEL_18:
    BOOL v20 = *(void **)(v14 + 56);
    goto LABEL_19;
  }
  BOOL v20 = 0;
LABEL_19:
  id v137 = 0;
  id v21 = v20;
  os_signpost_id_t v22 = [v21 readApduAndReturnError:&v137];
  id v23 = v137;

  if (v22)
  {
    uint64_t v24 = *(void *)(a1 + 32);
    id v25 = v22;
    id v26 = v25;
    if (!v24)
    {
      id v29 = 0;
LABEL_24:

      if ([v29 length])
      {
        uint64_t v30 = *(void *)(a1 + 32);
        if (v30) {
          id v31 = *(void **)(v30 + 56);
        }
        else {
          id v31 = 0;
        }
        [v31 sendAPDU:v29];
        sub_100257A7C(*(void *)(a1 + 32), *(void *)(a1 + 40));
      }
      else
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          uint64_t v57 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(*(id *)(a1 + 32));
          BOOL isMetaClass = class_isMetaClass(Class);
          Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
          uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
          uint64_t v61 = 45;
          if (isMetaClass) {
            uint64_t v61 = 43;
          }
          v57(6, "%c[%{public}s %{public}s]:%i read complete", v61, ClassName, Name, 696);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v62 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v63 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v63)) {
            int v64 = 43;
          }
          else {
            int v64 = 45;
          }
          id v65 = object_getClassName(*(id *)(a1 + 32));
          id v66 = sel_getName(*(SEL *)(a1 + 48));
          *(_DWORD *)int buf = 67109890;
          *(_DWORD *)int v139 = v64;
          *(_WORD *)&v139[4] = 2082;
          *(void *)&v139[6] = v65;
          __int16 v140 = 2082;
          long long v141 = v66;
          __int16 v142 = 1024;
          int v143 = 696;
          _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i read complete", buf, 0x22u);
        }

        sub_10012B380(*(void *)(a1 + 32), 0);
        os_signpost_id_t v67 = NFSharedSignpostLog();
        id v68 = v67;
        uint64_t v69 = *(void *)(a1 + 32);
        if (v69)
        {
          os_signpost_id_t v70 = *(void *)(v69 + 104);
          if (v70 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v67))
          {
            uint64_t v71 = *(void *)(a1 + 40);
            *(_DWORD *)int buf = 138412290;
            *(void *)int v139 = v71;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v68, OS_SIGNPOST_INTERVAL_END, v70, "TNEP_HCE_Read", "%@", buf, 0xCu);
          }
        }
      }
      goto LABEL_66;
    }
    if ((unint64_t)[v25 length] <= 3
      || (v27 = v26, uint64_t v28 = [v27 bytes], *v28))
    {
      id v29 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284638 length:2];
      goto LABEL_24;
    }
    id v72 = v28;
    char v136 = v2;
    uint64_t v73 = v28[1];
    int v74 = v28[2];
    int v75 = v28[3];
    if ((unint64_t)[v27 length] < 5) {
      uint64_t v76 = 0;
    }
    else {
      uint64_t v76 = v72[4];
    }
    switch(v73)
    {
      case 0xD6:
        if (*(void *)(v24 + 48) != 2) {
          goto LABEL_99;
        }
        uint64_t v93 = v76;
        if ((unint64_t)[v27 length] > 4)
        {
          if ((unint64_t)[v27 length] > 0x104)
          {
            if (v93) {
              break;
            }
            uint64_t v115 = __rev16(*(unsigned __int16 *)(v72 + 5));
            if (!v115) {
              break;
            }
            uint64_t v116 = v115;
            if ([v27 length] != (id)(v115 + 7)) {
              break;
            }
            uint64_t v94 = v116;
            uint64_t v95 = 7;
          }
          else
          {
            if (!v93 || [v27 length] != (id)(v93 + 5)) {
              break;
            }
            uint64_t v94 = v93;
            uint64_t v95 = 5;
          }
          uint64_t v117 = v75 | (v74 << 8);
          uint64_t v118 = v94;
          if (v94 + (unint64_t)v117 <= (unint64_t)[*(id *)(v24 + 80) length])
          {
            __int16 v123 = [v27 subdataWithRange:v95, v118];
            os_signpost_id_t v124 = *(void **)(v24 + 80);
            id v125 = v123;
            id v126 = v124;
            id v127 = v125;
            id v128 = v126;
            [v126 replaceBytesInRange:v117 withBytes:[v127 bytes] length:[v127 length]];

            if (v117 > 1
              || ([*(id *)(v24 + 80) bytes], sub_100257B2C(v24)))
            {
              id v129 = NFSharedSignpostLog();
              id v130 = v129;
              os_signpost_id_t v131 = *(void *)(v24 + 104);
              if (v131 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v129))
              {
                *(_WORD *)int buf = 0;
                _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v130, OS_SIGNPOST_EVENT, v131, "TNEP_TagDevice_UpdatedMemory", "NDEF", buf, 2u);
              }

              id v29 = [objc_alloc((Class)NSData) initWithBytes:&unk_10028463A length:2];
            }
            else
            {
              id v29 = 0;
            }
            id v2 = v136;

            goto LABEL_24;
          }
        }
        break;
      case 0xB0:
        if ([v27 length] == (id)5)
        {
          unsigned int v85 = v72[4];
        }
        else
        {
          if ([v27 length] != (id)7 || v72[4]) {
            break;
          }
          unsigned int v85 = __rev16(*(unsigned __int16 *)(v72 + 5));
        }
        uint64_t v86 = v75 | (v74 << 8);
        uint64_t v87 = *(void *)(v24 + 48);
        if (v87 == 2)
        {
          if (v85) {
            uint64_t v113 = v85;
          }
          else {
            uint64_t v113 = 512;
          }
          id v29 = [objc_alloc((Class)NSMutableData) initWithLength:v113];
          id v2 = v136;
          if ((unint64_t)[*(id *)(v24 + 80) length] > v86)
          {
            if ((unint64_t)[*(id *)(v24 + 80) length] < (v113 + v86)) {
              LODWORD(v113) = [*(id *)(v24 + 80) length] - v86;
            }
            -[NSObject replaceBytesInRange:withBytes:](v29, "replaceBytesInRange:withBytes:", 0, (int)v113, (char *)[*(id *)(v24 + 80) bytes] + v86);
          }
          [v29 appendBytes:&unk_10028463A length:2];
          id v114 = NFSharedSignpostLog();
          __int16 v90 = v114;
          os_signpost_id_t v91 = *(void *)(v24 + 104);
          if (v91 - 1 > 0xFFFFFFFFFFFFFFFDLL || !os_signpost_enabled(v114)) {
            goto LABEL_132;
          }
          *(_WORD *)int buf = 0;
          id v92 = "NDEF";
          goto LABEL_131;
        }
        if (v87 != 3) {
          goto LABEL_99;
        }
        if (v85) {
          uint64_t v88 = v85;
        }
        else {
          uint64_t v88 = 15;
        }
        if ((v88 + v86) < 0x10)
        {
          id v29 = [objc_alloc((Class)NSMutableData) initWithBytes:(char *)&unk_100284651 + v86 length:v88];
          [v29 appendBytes:&unk_10028463A length:2];
          id v89 = NFSharedSignpostLog();
          __int16 v90 = v89;
          os_signpost_id_t v91 = *(void *)(v24 + 104);
          id v2 = v136;
          if (v91 - 1 > 0xFFFFFFFFFFFFFFFDLL || !os_signpost_enabled(v89)) {
            goto LABEL_132;
          }
          *(_WORD *)int buf = 0;
          id v92 = "CC";
LABEL_131:
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v90, OS_SIGNPOST_EVENT, v91, "TNEP_TagDevice_ReadBinaryCmd", v92, buf, 2u);
LABEL_132:

          goto LABEL_24;
        }
        break;
      case 0xA4:
        if (v74 == 4 && !v75 && v76 == 7)
        {
          if ((unint64_t)[v27 length] >= 0xB)
          {
            int v77 = [v27 subdataWithRange:NSMakeRange(5, 7)];
            id v78 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284642 length:7];
            unsigned int v79 = [v77 isEqualToData:v78];

            if (v79)
            {
              __int16 v80 = NFSharedSignpostLog();
              id v81 = v80;
              os_signpost_id_t v82 = *(void *)(v24 + 104);
              if (v82 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v80))
              {
                *(_WORD *)int buf = 0;
                _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v81, OS_SIGNPOST_EVENT, v82, "TNEP_TagDevice_SelectCmd", "NDEFApp", buf, 2u);
              }

              *(void *)(v24 + 48) = 1;
              id v83 = objc_alloc((Class)NSData);
              __int16 v84 = &unk_10028463A;
              goto LABEL_145;
            }
          }
          goto LABEL_144;
        }
        if (!v74 && v75 == 12 && v76 == 2 && (unint64_t)[v27 length] >= 6)
        {
          id v106 = [v27 subdataWithRange:NSMakeRange(5, 2)];
          id v107 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284649 length:2];
          unsigned int v108 = [v106 isEqualToData:v107];

          if (v108)
          {
            id v109 = NFSharedSignpostLog();
            id v110 = v109;
            os_signpost_id_t v111 = *(void *)(v24 + 104);
            if (v111 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v109))
            {
              *(_WORD *)int buf = 0;
              _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v110, OS_SIGNPOST_EVENT, v111, "TNEP_TagDevice_SelectCmd", "CC", buf, 2u);
            }
            uint64_t v112 = 3;
            goto LABEL_154;
          }
          id v119 = [objc_alloc((Class)NSData) initWithBytes:&unk_10028464B length:2];
          unsigned int v120 = [v106 isEqualToData:v119];

          if (v120)
          {
            unsigned int v121 = NFSharedSignpostLog();
            id v110 = v121;
            os_signpost_id_t v122 = *(void *)(v24 + 104);
            if (v122 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v121))
            {
              *(_WORD *)int buf = 0;
              uint64_t v112 = 2;
              _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v110, OS_SIGNPOST_EVENT, v122, "TNEP_TagDevice_SelectCmd", "NDEF", buf, 2u);
            }
            else
            {
              uint64_t v112 = 2;
            }
LABEL_154:

            *(void *)(v24 + 48) = v112;
            id v29 = [objc_alloc((Class)NSData) initWithBytes:&unk_10028463A length:2];

            goto LABEL_146;
          }
        }
LABEL_144:
        *(void *)(v24 + 48) = 0;
        id v83 = objc_alloc((Class)NSData);
        __int16 v84 = &unk_10028464D;
        goto LABEL_145;
      default:
LABEL_99:
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v96 = NFLogGetLogger();
        if (v96)
        {
          uint64_t v97 = (void (*)(uint64_t, const char *, ...))v96;
          uint64_t v98 = object_getClass((id)v24);
          BOOL v99 = class_isMetaClass(v98);
          id v132 = object_getClassName((id)v24);
          id v135 = sel_getName("_parseAPDU:");
          uint64_t v100 = 45;
          if (v99) {
            uint64_t v100 = 43;
          }
          v97(4, "%c[%{public}s %{public}s]:%i Unsupported command; CMD=0x%x", v100, v132, v135, 643, v73);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v101 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
        {
          id v102 = object_getClass((id)v24);
          if (class_isMetaClass(v102)) {
            int v103 = 43;
          }
          else {
            int v103 = 45;
          }
          int v104 = object_getClassName((id)v24);
          __int16 v105 = sel_getName("_parseAPDU:");
          *(_DWORD *)int buf = 67110146;
          *(_DWORD *)int v139 = v103;
          *(_WORD *)&v139[4] = 2082;
          *(void *)&v139[6] = v104;
          __int16 v140 = 2082;
          long long v141 = v105;
          __int16 v142 = 1024;
          int v143 = 643;
          __int16 v144 = 1024;
          int v145 = v73;
          _os_log_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unsupported command; CMD=0x%x",
            buf,
            0x28u);
        }

        id v83 = objc_alloc((Class)NSData);
        __int16 v84 = &unk_100284638;
        goto LABEL_145;
    }
    id v83 = objc_alloc((Class)NSData);
    __int16 v84 = &unk_10028464F;
LABEL_145:
    id v29 = [v83 initWithBytes:v84 length:2];
LABEL_146:
    id v2 = v136;
    goto LABEL_24;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v32 = NFLogGetLogger();
  if (v32)
  {
    id v33 = (void (*)(uint64_t, const char *, ...))v32;
    id v34 = object_getClass(*(id *)(a1 + 32));
    BOOL v35 = class_isMetaClass(v34);
    id v36 = object_getClassName(*(id *)(a1 + 32));
    int v133 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v37 = 45;
    if (v35) {
      uint64_t v37 = 43;
    }
    v33(6, "%c[%{public}s %{public}s]:%i Connection lost, read complete", v37, v36, v133, 671);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  os_signpost_id_t v38 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v39 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v39)) {
      int v40 = 43;
    }
    else {
      int v40 = 45;
    }
    int v41 = object_getClassName(*(id *)(a1 + 32));
    __int16 v42 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)int buf = 67109890;
    *(_DWORD *)int v139 = v40;
    *(_WORD *)&v139[4] = 2082;
    *(void *)&v139[6] = v41;
    __int16 v140 = 2082;
    long long v141 = v42;
    __int16 v142 = 1024;
    int v143 = 671;
    _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Connection lost, read complete", buf, 0x22u);
  }

  uint64_t v43 = *(void *)(a1 + 32);
  if (!v43) {
    goto LABEL_162;
  }
  if (*(unsigned char *)(v43 + 8))
  {
    __int16 v44 = NFSharedSignpostLog();
    uint64_t v45 = v44;
    uint64_t v46 = *(void *)(a1 + 32);
    if (v46)
    {
      os_signpost_id_t v47 = *(void *)(v46 + 104);
      if (v47 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v44))
      {
        *(_WORD *)int buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v45, OS_SIGNPOST_EVENT, v47, "TNEP_TagDevice_Deselect", "ConnectionLost", buf, 2u);
      }
    }

    uint64_t v48 = *(void *)(a1 + 32);
    id v49 = v48 ? objc_loadWeakRetained((id *)(v48 + 40)) : 0;
    [v49 tnepTagDeviceDeselected:v23];

    uint64_t v43 = *(void *)(a1 + 32);
    if (!v43) {
      goto LABEL_162;
    }
  }
  *(unsigned char *)(v43 + 8) = 0;
  uint64_t v50 = *(void *)(a1 + 32);
  if (v50)
  {
    objc_storeStrong((id *)(v50 + 56), 0);
    uint64_t v51 = *(void *)(a1 + 32);
  }
  else
  {
LABEL_162:
    uint64_t v51 = 0;
  }
  sub_10012B380(v51, 0);
  int v52 = NFSharedSignpostLog();
  id v29 = v52;
  uint64_t v53 = *(void *)(a1 + 32);
  if (v53)
  {
    os_signpost_id_t v54 = *(void *)(v53 + 104);
    if (v54 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v52))
    {
      uint64_t v55 = *(void *)(a1 + 40);
      *(_DWORD *)int buf = 138412290;
      *(void *)int v139 = v55;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v29, OS_SIGNPOST_INTERVAL_END, v54, "TNEP_HCE_Read", "%@", buf, 0xCu);
    }
  }
LABEL_66:
}

void sub_100259E1C(dispatch_queue_t *a1, int64_t a2, int a3, void *a4)
{
  id v7 = a4;
  unsigned __int8 v8 = (void (**)(void, void, void))v7;
  if (a1)
  {
    if (a3)
    {
      v26[0] = _NSConcreteStackBlock;
      v26[1] = 3221225472;
      v26[2] = sub_10025A120;
      v26[3] = &unk_1003087A8;
      v26[4] = a1;
      uint64_t v28 = "_receiveWithWaitTime:timeExtension:completionHandler:";
      id v27 = v7;
      int64_t v29 = a2;
      char v30 = a3;
      unsigned int v9 = objc_retainBlock(v26);
      if (a2)
      {
        dispatch_time_t v10 = dispatch_time(0, a2);
        dispatch_after(v10, a1[3], v9);
      }
      else
      {
        dispatch_async(a1[3], v9);
      }
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        os_signpost_id_t v12 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        Classuint64_t Name = object_getClassName(a1);
        uint64_t Name = sel_getName("_receiveWithWaitTime:timeExtension:completionHandler:");
        uint64_t v16 = 45;
        if (isMetaClass) {
          uint64_t v16 = 43;
        }
        v12(4, "%c[%{public}s %{public}s]:%i Timeout", v16, ClassName, Name, 749);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v17 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        os_signpost_id_t v18 = object_getClass(a1);
        if (class_isMetaClass(v18)) {
          int v19 = 43;
        }
        else {
          int v19 = 45;
        }
        *(_DWORD *)int buf = 67109890;
        int v34 = v19;
        __int16 v35 = 2082;
        id v36 = object_getClassName(a1);
        __int16 v37 = 2082;
        os_signpost_id_t v38 = sel_getName("_receiveWithWaitTime:timeExtension:completionHandler:");
        __int16 v39 = 1024;
        int v40 = 749;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Timeout", buf, 0x22u);
      }

      id v20 = objc_alloc((Class)NSError);
      id v21 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v31 = NSLocalizedDescriptionKey;
      os_signpost_id_t v22 = +[NSString stringWithUTF8String:"Timeout"];
      uint64_t v32 = v22;
      id v23 = +[NSDictionary dictionaryWithObjects:&v32 forKeys:&v31 count:1];
      id v24 = [v20 initWithDomain:v21 code:5 userInfo:v23];
      ((void (**)(void, void, id))v8)[2](v8, 0, v24);
    }
  }
}

void sub_10025A120(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  if (!v2) {
    goto LABEL_33;
  }
  uint64_t v3 = v2[11];
  if (!v3) {
    goto LABEL_17;
  }
  if ([*(id *)(v3 + 88) readerModeProtectionActive])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
      uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v5(4, "%c[%{public}s %{public}s]:%i Reader protection active", v9, ClassName, Name, 756);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    dispatch_time_t v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      uint64_t v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      uint64_t v13 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)int buf = 67109890;
      int v42 = v12;
      __int16 v43 = 2082;
      __int16 v44 = v13;
      __int16 v45 = 2082;
      uint64_t v46 = v14;
      __int16 v47 = 1024;
      int v48 = 756;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Reader protection active", buf, 0x22u);
    }

    id v15 = objc_alloc((Class)NSError);
    uint64_t v16 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v53 = NSLocalizedDescriptionKey;
    uint64_t v17 = +[NSString stringWithUTF8String:"Reader mode temporarily disabled"];
    os_signpost_id_t v54 = v17;
    os_signpost_id_t v18 = +[NSDictionary dictionaryWithObjects:&v54 forKeys:&v53 count:1];
    id v19 = [v15 initWithDomain:v16 code:47 userInfo:v18];

    uint64_t v20 = *(void *)(a1 + 32);
    if (v20) {
      id WeakRetained = objc_loadWeakRetained((id *)(v20 + 40));
    }
    else {
      id WeakRetained = 0;
    }
    [WeakRetained tnepReaderServicesAborted:v19];

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    goto LABEL_32;
  }
  id v2 = *(void **)(a1 + 32);
  if (v2) {
LABEL_17:
  }
    os_signpost_id_t v22 = (void *)v2[12];
  else {
LABEL_33:
  }
    os_signpost_id_t v22 = 0;
  id v40 = 0;
  id v23 = v22;
  id v24 = sub_100254840(v2, v23, &v40);
  id v19 = v40;

  if (!v24 || v19)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v25 = NFLogGetLogger();
    if (v25)
    {
      id v26 = (void (*)(uint64_t, const char *, ...))v25;
      id v27 = object_getClass(*(id *)(a1 + 32));
      BOOL v28 = class_isMetaClass(v27);
      int64_t v29 = object_getClassName(*(id *)(a1 + 32));
      char v30 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v31 = 45;
      if (v28) {
        uint64_t v31 = 43;
      }
      v26(6, "%c[%{public}s %{public}s]:%i Retry in %ld, N=%d", v31, v29, v30, 766, *(void *)(a1 + 56), *(unsigned __int8 *)(a1 + 64));
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v32 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      id v33 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v33)) {
        int v34 = 43;
      }
      else {
        int v34 = 45;
      }
      __int16 v35 = object_getClassName(*(id *)(a1 + 32));
      id v36 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v37 = *(void *)(a1 + 56);
      int v38 = *(unsigned __int8 *)(a1 + 64);
      *(_DWORD *)int buf = 67110402;
      int v42 = v34;
      __int16 v43 = 2082;
      __int16 v44 = v35;
      __int16 v45 = 2082;
      uint64_t v46 = v36;
      __int16 v47 = 1024;
      int v48 = 766;
      __int16 v49 = 2048;
      uint64_t v50 = v37;
      __int16 v51 = 1024;
      int v52 = v38;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Retry in %ld, N=%d", buf, 0x32u);
    }

    sub_100259E1C(*(void *)(a1 + 32), *(void *)(a1 + 56), (*(unsigned char *)(a1 + 64) - 1), *(void *)(a1 + 40));
  }
  else
  {
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }

LABEL_32:
}

void sub_10025A570(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v7 = 45;
    if (isMetaClass) {
      uint64_t v7 = 43;
    }
    v3(4, "%c[%{public}s %{public}s]:%i Reader protection active", v7, ClassName, Name, 790);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  unsigned __int8 v8 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    uint64_t v9 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v9)) {
      int v10 = 43;
    }
    else {
      int v10 = 45;
    }
    uint64_t v11 = object_getClassName(*(id *)(a1 + 32));
    int v12 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)int buf = 67109890;
    int v24 = v10;
    __int16 v25 = 2082;
    id v26 = v11;
    __int16 v27 = 2082;
    BOOL v28 = v12;
    __int16 v29 = 1024;
    int v30 = 790;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Reader protection active", buf, 0x22u);
  }

  id v13 = objc_alloc((Class)NSError);
  uint64_t v14 = +[NSString stringWithUTF8String:"nfcd"];
  NSErrorUserInfoKey v21 = NSLocalizedDescriptionKey;
  id v15 = +[NSString stringWithUTF8String:"Reader mode temporarily disabled"];
  os_signpost_id_t v22 = v15;
  uint64_t v16 = +[NSDictionary dictionaryWithObjects:&v22 forKeys:&v21 count:1];
  id v17 = [v13 initWithDomain:v14 code:47 userInfo:v16];

  uint64_t v18 = *(void *)(a1 + 32);
  if (v18) {
    id WeakRetained = objc_loadWeakRetained((id *)(v18 + 40));
  }
  else {
    id WeakRetained = 0;
  }
  [WeakRetained tnepReaderServicesAborted:v17];

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

uint64_t sub_10025A7D0(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 64));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v3(3, "%c[%{public}s %{public}s]:%i NDEF write failed: %{public}@  error:%{public}@", v8, ClassName, Name, 802, *(void *)(a1 + 40), *(void *)(a1 + 48));
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    int v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    int v12 = object_getClassName(*(id *)(a1 + 32));
    id v13 = sel_getName(*(SEL *)(a1 + 64));
    uint64_t v14 = *(void *)(a1 + 40);
    uint64_t v15 = *(void *)(a1 + 48);
    *(_DWORD *)int buf = 67110402;
    int v18 = v11;
    __int16 v19 = 2082;
    uint64_t v20 = v12;
    __int16 v21 = 2082;
    os_signpost_id_t v22 = v13;
    __int16 v23 = 1024;
    int v24 = 802;
    __int16 v25 = 2114;
    uint64_t v26 = v14;
    __int16 v27 = 2114;
    uint64_t v28 = v15;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i NDEF write failed: %{public}@  error:%{public}@", buf, 0x36u);
  }

  return (*(uint64_t (**)(void))(*(void *)(a1 + 56) + 16))();
}

uint64_t sub_10025A980(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), 0, *(void *)(a1 + 32));
}

void sub_10025A998(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = objc_alloc((Class)NSError);
  uint64_t v3 = +[NSString stringWithUTF8String:"nfcd"];
  NSErrorUserInfoKey v7 = NSLocalizedDescriptionKey;
  id v4 = +[NSString stringWithUTF8String:"No resources"];
  uint64_t v8 = v4;
  id v5 = +[NSDictionary dictionaryWithObjects:&v8 forKeys:&v7 count:1];
  id v6 = [v2 initWithDomain:v3 code:34 userInfo:v5];
  (*(void (**)(uint64_t, void, id))(v1 + 16))(v1, 0, v6);
}

uint64_t sub_10025AAB4(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), 0, *(void *)(a1 + 32));
}

void sub_10025AACC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 40));
  }
  else {
    id WeakRetained = 0;
  }
  id v4 = WeakRetained;
  [WeakRetained tnepReaderServicesDiscovered:*(void *)(a1 + 40)];
}

void sub_10025AB2C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 40));
  }
  else {
    id WeakRetained = 0;
  }
  id v4 = WeakRetained;
  [WeakRetained staticReaderEngagementDiscovered:*(void *)(a1 + 40)];
}

void sub_10025AB8C(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    id WeakRetained = objc_loadWeakRetained((id *)(v2 + 40));
  }
  else {
    id WeakRetained = 0;
  }
  id v4 = WeakRetained;
  [WeakRetained tnepReaderServicesAborted:*(void *)(a1 + 40)];
}

void sub_10025F504(id a1)
{
  uint64_t v3 = [(NFSecureTransactionServicesHandoverBaseSessionInterface *)[NFUnifiedAccessSessionInterface alloc] initWithProtocol:&OBJC_PROTOCOL___NFUnifiedAccessSessionInterface];
  uint64_t v1 = [(NFSecureTransactionServicesHandoverBaseSessionInterface *)v3 protocolInterface];
  uint64_t v2 = (void *)qword_1003476F0;
  qword_1003476F0 = v1;
}

void sub_10025F5F4(id a1)
{
  uint64_t v3 = [(NFSecureTransactionServicesHandoverBaseSessionCallbacksInterface *)[NFUnifiedAccessSessionCallbacksInterface alloc] initWithProtocol:&OBJC_PROTOCOL___NFUnifiedAccessSessionCallbacksInterface];
  uint64_t v1 = [(NFSecureTransactionServicesHandoverBaseSessionCallbacksInterface *)v3 protocolInterface];
  uint64_t v2 = (void *)qword_100347700;
  qword_100347700 = v1;
}

void sub_10025F6E4(id a1)
{
  uint64_t v1 = objc_alloc_init(_NFACHardwareManager);
  uint64_t v2 = qword_100347718;
  qword_100347718 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_10025FE30(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_10025FE4C(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 40)) {
    [*(id *)(*(void *)(a1 + 32) + 88) failForwardCompleted];
  }
  uint64_t v2 = *(void **)(a1 + 32);

  return [v2 _probeHW];
}

void sub_100260394(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1002603B4(uint64_t a1)
{
  uint64_t v6 = 0;
  NSErrorUserInfoKey v7 = &v6;
  uint64_t v8 = 0x2020000000;
  uint64_t v9 = 0;
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 16);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_100260460;
  v5[3] = &unk_100301EB8;
  void v5[4] = v1;
  void v5[5] = &v6;
  dispatch_async_and_wait(v2, v5);
  uint64_t v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

id sub_100260460(uint64_t a1)
{
  id result = [*(id *)(a1 + 32) dumpState];
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = result;
  return result;
}

void sub_100260494(uint64_t a1, xpc_object_t xdict)
{
  kern_return_t v15;
  uint32_t denom;
  uint64_t v17;
  void (*v18)(uint64_t, const char *, ...);
  objc_class *v19;
  BOOL v20;
  const char *v21;
  const char *v22;
  uint64_t v23;
  NSObject *v24;
  objc_class *v25;
  int v26;
  const char *v27;
  const char *v28;
  const char *v29;
  NSObject *v30;
  uint32_t v31;
  objc_class *v32;
  BOOL v33;
  const char *v34;
  uint64_t v35;
  objc_class *v36;
  int v37;
  const char *v38;
  const char *v39;
  uint64_t v40;
  NSObject *v41;
  const char *ClassName;
  const char *Name;
  const char *v44;
  void block[5];
  mach_timebase_info info;
  uint8_t buf[4];
  int v48;
  __int16 v49;
  const char *v50;
  __int16 v51;
  const char *v52;
  __int16 v53;
  int v54;
  __int16 v55;
  unint64_t v56;

  string = xpc_dictionary_get_string(xdict, _xpc_event_key_name);
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v5(6, "%c[%{public}s %{public}s]:%i Launched by %s", v8, ClassName, Name, 200, string);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    int v12 = object_getClassName(*(id *)(a1 + 32));
    id v13 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)int buf = 67110146;
    int v48 = v11;
    __int16 v49 = 2082;
    uint64_t v50 = v12;
    __int16 v51 = 2082;
    int v52 = v13;
    NSErrorUserInfoKey v53 = 1024;
    os_signpost_id_t v54 = 200;
    uint64_t v55 = 2080;
    id v56 = (unint64_t)string;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Launched by %s", buf, 0x2Cu);
  }

  if (!strcmp(string, "fury.spmi.activity"))
  {
    uint64_t v14 = mach_absolute_time();
    info = 0;
    uint64_t v15 = mach_timebase_info(&info);
    denom = info.denom;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v17 = NFLogGetLogger();
    int v18 = (void (*)(uint64_t, const char *, ...))v17;
    if (v15 || !denom)
    {
      if (v17)
      {
        uint64_t v32 = object_getClass(*(id *)(a1 + 32));
        id v33 = class_isMetaClass(v32);
        int v34 = object_getClassName(*(id *)(a1 + 32));
        __int16 v44 = sel_getName(*(SEL *)(a1 + 40));
        __int16 v35 = 45;
        if (v33) {
          __int16 v35 = 43;
        }
        v18(6, "%c[%{public}s %{public}s]:%i Fury SPMI activity", v35, v34, v44, 209);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v24 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_32;
      }
      id v36 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v36)) {
        uint64_t v37 = 43;
      }
      else {
        uint64_t v37 = 45;
      }
      int v38 = object_getClassName(*(id *)(a1 + 32));
      __int16 v39 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)int buf = 67109890;
      int v48 = v37;
      __int16 v49 = 2082;
      uint64_t v50 = v38;
      __int16 v51 = 2082;
      int v52 = v39;
      NSErrorUserInfoKey v53 = 1024;
      os_signpost_id_t v54 = 209;
      __int16 v29 = "%c[%{public}s %{public}s]:%i Fury SPMI activity";
      int v30 = v24;
      uint64_t v31 = 34;
    }
    else
    {
      if (v17)
      {
        __int16 v19 = object_getClass(*(id *)(a1 + 32));
        uint64_t v20 = class_isMetaClass(v19);
        __int16 v21 = object_getClassName(*(id *)(a1 + 32));
        os_signpost_id_t v22 = sel_getName(*(SEL *)(a1 + 40));
        __int16 v23 = 45;
        if (v20) {
          __int16 v23 = 43;
        }
        v18(6, "%c[%{public}s %{public}s]:%i Fury SPMI activity (%llu)", v23, v21, v22, 206, v14 * info.numer / info.denom);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v24 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_32;
      }
      __int16 v25 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v25)) {
        uint64_t v26 = 43;
      }
      else {
        uint64_t v26 = 45;
      }
      __int16 v27 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v28 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)int buf = 67110146;
      int v48 = v26;
      __int16 v49 = 2082;
      uint64_t v50 = v27;
      __int16 v51 = 2082;
      int v52 = v28;
      NSErrorUserInfoKey v53 = 1024;
      os_signpost_id_t v54 = 206;
      uint64_t v55 = 2048;
      id v56 = v14 * info.numer / info.denom;
      __int16 v29 = "%c[%{public}s %{public}s]:%i Fury SPMI activity (%llu)";
      int v30 = v24;
      uint64_t v31 = 44;
    }
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, v29, buf, v31);
LABEL_32:

    id v40 = *(void *)(a1 + 32);
    int v41 = *(NSObject **)(v40 + 16);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100260900;
    block[3] = &unk_100301C68;
    void block[4] = v40;
    dispatch_async(v41, block);
  }
}

id sub_100260900(uint64_t a1)
{
  return [*(id *)(a1 + 32) _probeHW];
}

void sub_100260908(uint64_t a1)
{
  uint64_t v2 = sub_1002090CC();
  sub_10020A48C((uint64_t)v2);

  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v4(6, "%c[%{public}s %{public}s]:%i com.apple.nfcacd.coreanalytics.event ready", v8, ClassName, Name, 222);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    int v12 = object_getClassName(*(id *)(a1 + 32));
    id v13 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)int buf = 67109890;
    int v16 = v11;
    __int16 v17 = 2082;
    int v18 = v12;
    __int16 v19 = 2082;
    uint64_t v20 = v13;
    __int16 v21 = 1024;
    int v22 = 222;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i com.apple.nfcacd.coreanalytics.event ready", buf, 0x22u);
  }
}

void sub_100260E30(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1002616F8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100261924(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_100261940(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 88) failForwardCompleted];
}

void sub_100261BD0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v1 + 8))
  {
    id v3 = *(id *)(v1 + 48);
    objc_sync_enter(v3);
    if (*(void *)(*(void *)(a1 + 32) + 64))
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (Logger)
      {
        Class = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(Class)) {
          uint64_t v6 = 43;
        }
        else {
          uint64_t v6 = 45;
        }
        Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
        uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v9 = [*(id *)(*(void *)(a1 + 32) + 64) clientName];
        Logger(6, "%c[%{public}s %{public}s]:%i Invalidating active session for %{public}@ due to sleep", v6, ClassName, Name, 336, v9);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v10 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        int v11 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v11)) {
          int v12 = 43;
        }
        else {
          int v12 = 45;
        }
        id v13 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v15 = [*(id *)(*(void *)(a1 + 32) + 64) clientName];
        *(_DWORD *)int buf = 67110146;
        int v21 = v12;
        __int16 v22 = 2082;
        __int16 v23 = v13;
        __int16 v24 = 2082;
        __int16 v25 = v14;
        __int16 v26 = 1024;
        int v27 = 336;
        __int16 v28 = 2114;
        __int16 v29 = v15;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Invalidating active session for %{public}@ due to sleep", buf, 0x2Cu);
      }
      int v16 = [*(id *)(*(void *)(a1 + 32) + 64) connection];
      [v16 invalidate];

      __int16 v17 = NFSharedSignpostLog();
      if (os_signpost_enabled(v17))
      {
        *(_WORD *)int buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v17, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "powerObserverSystemWillSleep: session in progress; preventing sleep",
          (const char *)&unk_100286819,
          buf,
          2u);
      }

      objc_sync_exit(v3);
    }
    else
    {
      objc_sync_exit(v3);

      __int16 v19 = NFSharedSignpostLog();
      if (os_signpost_enabled(v19))
      {
        *(_WORD *)int buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v19, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "powerObserverSystemWillSleep: allowing to sleep", (const char *)&unk_100286819, buf, 2u);
      }

      [*(id *)(a1 + 40) allowSleep];
    }
  }
  else
  {
    [*(id *)(v1 + 72) allowSleep];
    int v18 = NFSharedSignpostLog();
    if (os_signpost_enabled(v18))
    {
      *(_WORD *)int buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v18, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "powerObserverSystemWillSleep: not running; allowing to sleep",
        (const char *)&unk_100286819,
        buf,
        2u);
    }
  }
}

void sub_100261F08(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void *sub_10026215C(void *result)
{
  uint64_t v1 = result[4];
  if (*(unsigned char *)(v1 + 8))
  {
    uint64_t v2 = result;
    id v3 = *(id *)(v1 + 48);
    objc_sync_enter(v3);
    *(unsigned char *)(v2[4] + 104) = 0;
    objc_sync_exit(v3);

    id v4 = (void *)v2[4];
    return [v4 maybeStartNextSession];
  }
  return result;
}

void sub_10026277C(uint64_t a1)
{
  uint64_t v2 = NFSharedSignpostLog();
  if (os_signpost_enabled(v2))
  {
    *(_WORD *)int buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v2, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "NFCACD_GET_INFO", (const char *)&unk_100286819, buf, 2u);
  }

  id v3 = [*(id *)(a1 + 32) _getInfo];
  id v4 = NFSharedSignpostLog();
  if (os_signpost_enabled(v4))
  {
    *(_WORD *)id v5 = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "NFCACD_GET_INFO", (const char *)&unk_100286819, v5, 2u);
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_100262918(uint64_t a1)
{
  uint64_t v2 = NFSharedSignpostLog();
  if (os_signpost_enabled(v2))
  {
    *(_WORD *)int buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v2, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "NFCACD_GET_DIE_ID", (const char *)&unk_100286819, buf, 2u);
  }

  *(void *)int buf = 0;
  uint64_t v9 = buf;
  uint64_t v10 = 0x3032000000;
  int v11 = sub_10000B948;
  int v12 = sub_100262AE0;
  id v13 = 0;
  id v3 = *(void **)(a1 + 32);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  void v7[2] = sub_100262AE8;
  v7[3] = &unk_1003088B0;
  v7[4] = v3;
  void v7[5] = buf;
  id v4 = [v3 _executeWithDriverSessionSync:@"GetDieId" block:v7];
  id v5 = NFSharedSignpostLog();
  if (os_signpost_enabled(v5))
  {
    *(_WORD *)uint64_t v6 = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "NFCACD_GET_DIE_ID", (const char *)&unk_100286819, v6, 2u);
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  _Block_object_dispose(buf, 8);
}

void sub_100262AC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100262AE0(uint64_t a1)
{
}

id sub_100262AE8(uint64_t a1)
{
  uint64_t v2 = [*(id *)(*(void *)(a1 + 32) + 88) getDieID];
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40))
  {
    id v5 = 0;
  }
  else
  {
    id v6 = objc_alloc((Class)NSError);
    NSErrorUserInfoKey v7 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v11 = NSLocalizedDescriptionKey;
    uint64_t v8 = +[NSString stringWithUTF8String:"Stack Error"];
    int v12 = v8;
    uint64_t v9 = +[NSDictionary dictionaryWithObjects:&v12 forKeys:&v11 count:1];
    id v5 = [v6 initWithDomain:v7 code:15 userInfo:v9];
  }

  return v5;
}

void sub_100262CC8(uint64_t a1)
{
  uint64_t v2 = NFSharedSignpostLog();
  if (os_signpost_enabled(v2))
  {
    *(_WORD *)int buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v2, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "NFCACD_GET_POWER_COUNTERS", (const char *)&unk_100286819, buf, 2u);
  }

  *(void *)int buf = 0;
  uint64_t v9 = buf;
  uint64_t v10 = 0x3032000000;
  NSErrorUserInfoKey v11 = sub_10000B948;
  int v12 = sub_100262AE0;
  id v13 = 0;
  uint64_t v3 = *(void **)(a1 + 32);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  void v7[2] = sub_100262E90;
  v7[3] = &unk_1003088B0;
  v7[4] = v3;
  void v7[5] = buf;
  id v4 = [v3 _executeWithDriverSessionSync:@"GetPowerCounters" block:v7];
  id v5 = NFSharedSignpostLog();
  if (os_signpost_enabled(v5))
  {
    *(_WORD *)id v6 = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "NFCACD_GET_POWER_COUNTERS", (const char *)&unk_100286819, v6, 2u);
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  _Block_object_dispose(buf, 8);
}

void sub_100262E74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_100262E90(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  uint64_t v2 = *(void **)(*(void *)(a1 + 32) + 88);
  uint64_t v3 = *(void *)(v1 + 8);
  id obj = *(id *)(v3 + 40);
  id v4 = [v2 getPowerCounters:&obj];
  objc_storeStrong((id *)(v3 + 40), obj);

  return v4;
}

void sub_100262F90(uint64_t a1)
{
  uint64_t v2 = NFSharedSignpostLog();
  if (os_signpost_enabled(v2))
  {
    *(_WORD *)int buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v2, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "NFCACD_GET_RF_SETTINGS", (const char *)&unk_100286819, buf, 2u);
  }

  *(void *)int buf = 0;
  uint64_t v9 = buf;
  uint64_t v10 = 0x3032000000;
  NSErrorUserInfoKey v11 = sub_10000B948;
  int v12 = sub_100262AE0;
  id v13 = 0;
  uint64_t v3 = *(void **)(a1 + 32);
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  void v7[2] = sub_100263158;
  v7[3] = &unk_1003088B0;
  v7[4] = v3;
  void v7[5] = buf;
  id v4 = [v3 _executeWithDriverSessionSync:@"GetRfSettings" block:v7];
  id v5 = NFSharedSignpostLog();
  if (os_signpost_enabled(v5))
  {
    *(_WORD *)id v6 = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "NFCACD_GET_RF_SETTINGS", (const char *)&unk_100286819, v6, 2u);
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  _Block_object_dispose(buf, 8);
}

void sub_10026313C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_100263158(uint64_t a1)
{
  uint64_t v2 = objc_opt_new();
  if ([*(id *)(*(void *)(a1 + 32) + 88) getRFSettings:v2])
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), v2);
    id v3 = 0;
  }
  else
  {
    id v4 = objc_alloc((Class)NSError);
    id v5 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v9 = NSLocalizedDescriptionKey;
    id v6 = +[NSString stringWithUTF8String:"Stack Error"];
    uint64_t v10 = v6;
    NSErrorUserInfoKey v7 = +[NSDictionary dictionaryWithObjects:&v10 forKeys:&v9 count:1];
    id v3 = [v4 initWithDomain:v5 code:15 userInfo:v7];
  }

  return v3;
}

void sub_1002636D0(uint64_t a1)
{
  *(void *)(*(void *)(a1 + 32) + 112) = 0;
  if (*(unsigned __int8 *)(a1 + 56) == *(unsigned __int8 *)(*(void *)(a1 + 32) + 106))
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
      uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v8 = 45;
      if (isMetaClass) {
        uint64_t v8 = 43;
      }
      v3(6, "%c[%{public}s %{public}s]:%i MultiTagDetection already set to: %d", v8, ClassName, Name, 506, *(unsigned __int8 *)(a1 + 56));
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    NSErrorUserInfoKey v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      int v12 = object_getClassName(*(id *)(a1 + 32));
      id v13 = sel_getName(*(SEL *)(a1 + 48));
      int v14 = *(unsigned __int8 *)(a1 + 56);
      *(_DWORD *)int buf = 67110146;
      int v23 = v11;
      __int16 v24 = 2082;
      __int16 v25 = v12;
      __int16 v26 = 2082;
      int v27 = v13;
      __int16 v28 = 1024;
      int v29 = 506;
      __int16 v30 = 1024;
      int v31 = v14;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i MultiTagDetection already set to: %d", buf, 0x28u);
    }

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    uint64_t v15 = NFSharedSignpostLog();
    if (os_signpost_enabled(v15))
    {
      *(_WORD *)int buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "NFCACD_ENABLE_MULTI_TAG", (const char *)&unk_100286819, buf, 2u);
    }

    int v16 = *(void **)(a1 + 32);
    v20[0] = _NSConcreteStackBlock;
    v20[1] = 3221225472;
    void v20[2] = sub_1002639C4;
    v20[3] = &unk_1003088D8;
    char v21 = *(unsigned char *)(a1 + 56);
    uint64_t v17 = *(void *)(a1 + 48);
    v20[4] = v16;
    void v20[5] = v17;
    int v18 = [v16 _executeWithDriverSessionSync:@"enableMultiTag" block:v20];
    __int16 v19 = NFSharedSignpostLog();
    if (os_signpost_enabled(v19))
    {
      *(_WORD *)int buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v19, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "NFCACD_ENABLE_MULTI_TAG", (const char *)&unk_100286819, buf, 2u);
    }

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

id sub_1002639C4(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 48);
  id v3 = *(void **)(*(void *)(a1 + 32) + 88);
  if (!v2)
  {
    [v3 clearMultiTagPollingState];
    [*(id *)(*(void *)(a1 + 32) + 88) closeSession:@"MultiTagSession"];
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      NSErrorUserInfoKey v9 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
      uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v13 = 45;
      if (isMetaClass) {
        uint64_t v13 = 43;
      }
      v9(6, "%c[%{public}s %{public}s]:%i releaseing multitag transaction", v13, ClassName, Name, 535);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v14 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v15)) {
        int v16 = 43;
      }
      else {
        int v16 = 45;
      }
      uint64_t v17 = object_getClassName(*(id *)(a1 + 32));
      int v18 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)int buf = 67109890;
      int v59 = v16;
      __int16 v60 = 2082;
      uint64_t v61 = v17;
      __int16 v62 = 2082;
      unsigned int v63 = v18;
      __int16 v64 = 1024;
      int v65 = 535;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i releaseing multitag transaction", buf, 0x22u);
    }

    uint64_t v19 = *(void *)(a1 + 32);
    NSErrorUserInfoKey v7 = *(void **)(v19 + 128);
    *(void *)(v19 + 128) = 0;
    goto LABEL_14;
  }
  id v4 = [v3 openSession:@"MultiTagSession"];
  if (v4 == (id)1)
  {
    uint64_t v5 = os_transaction_create();
    uint64_t v6 = *(void *)(a1 + 32);
    NSErrorUserInfoKey v7 = *(void **)(v6 + 128);
    *(void *)(v6 + 128) = v5;
LABEL_14:

LABEL_15:
    *(unsigned char *)(*(void *)(a1 + 32) + 106) = *(unsigned char *)(a1 + 48);
    uint64_t v20 = *(void *)(a1 + 32);
    char v21 = *(void **)(v20 + 152);
    *(void *)(v20 + 152) = 0;

    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v22 = NFLogGetLogger();
    if (v22)
    {
      int v23 = (void (*)(uint64_t, const char *, ...))v22;
      __int16 v24 = object_getClass(*(id *)(a1 + 32));
      BOOL v25 = class_isMetaClass(v24);
      __int16 v26 = object_getClassName(*(id *)(a1 + 32));
      int v27 = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v28 = 45;
      if (v25) {
        uint64_t v28 = 43;
      }
      v23(6, "%c[%{public}s %{public}s]:%i Multitag state: %d", v28, v26, v27, 542, *(unsigned __int8 *)(a1 + 48));
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v29 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v30 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v30)) {
        int v31 = 43;
      }
      else {
        int v31 = 45;
      }
      uint64_t v32 = object_getClassName(*(id *)(a1 + 32));
      id v33 = sel_getName(*(SEL *)(a1 + 40));
      int v34 = *(unsigned __int8 *)(a1 + 48);
      *(_DWORD *)int buf = 67110146;
      int v59 = v31;
      __int16 v60 = 2082;
      uint64_t v61 = v32;
      __int16 v62 = 2082;
      unsigned int v63 = v33;
      __int16 v64 = 1024;
      int v65 = 542;
      __int16 v66 = 1024;
      LODWORD(v67) = v34;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Multitag state: %d", buf, 0x28u);
    }

    __int16 v35 = [*(id *)(a1 + 32) _getDefaults];
    [v35 setBool:*(unsigned __int8 *)(*(void *)(a1 + 32) + 106) forKey:@"MultiTagDetectionOn"];
    [v35 synchronize];

    [*(id *)(a1 + 32) maybeStartNextSession];
    id v36 = 0;
    goto LABEL_25;
  }
  id v38 = v4;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v39 = NFLogGetLogger();
  if (v39)
  {
    id v40 = (void (*)(uint64_t, const char *, ...))v39;
    int v41 = object_getClass(*(id *)(a1 + 32));
    BOOL v42 = class_isMetaClass(v41);
    NSErrorUserInfoKey v53 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v55 = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v43 = 45;
    if (v42) {
      uint64_t v43 = 43;
    }
    v40(3, "%c[%{public}s %{public}s]:%i Failed to open session; hwState=%lu", v43, v53, v55, 520, v38);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  __int16 v44 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
  {
    __int16 v45 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v45)) {
      int v46 = 43;
    }
    else {
      int v46 = 45;
    }
    __int16 v47 = object_getClassName(*(id *)(a1 + 32));
    int v48 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)int buf = 67110146;
    int v59 = v46;
    __int16 v60 = 2082;
    uint64_t v61 = v47;
    __int16 v62 = 2082;
    unsigned int v63 = v48;
    __int16 v64 = 1024;
    int v65 = 520;
    __int16 v66 = 2048;
    id v67 = v38;
    _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session; hwState=%lu",
      buf,
      0x2Cu);
  }

  id v49 = objc_alloc((Class)NSError);
  uint64_t v50 = +[NSString stringWithUTF8String:"nfcd"];
  NSErrorUserInfoKey v56 = NSLocalizedDescriptionKey;
  __int16 v51 = +[NSString stringWithUTF8String:"Unknown Error"];
  uint64_t v57 = v51;
  int v52 = +[NSDictionary dictionaryWithObjects:&v57 forKeys:&v56 count:1];
  id v36 = [v49 initWithDomain:v50 code:6 userInfo:v52];

  if (!v36) {
    goto LABEL_15;
  }
LABEL_25:

  return v36;
}

void sub_100263FB0(uint64_t a1)
{
  if (*(unsigned __int8 *)(a1 + 56) == *(unsigned __int8 *)(*(void *)(a1 + 32) + 105))
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
      uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v8 = 45;
      if (isMetaClass) {
        uint64_t v8 = 43;
      }
      v3(6, "%c[%{public}s %{public}s]:%i LPCD is already set to: %d", v8, ClassName, Name, 566, *(unsigned __int8 *)(a1 + 56));
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    NSErrorUserInfoKey v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      int v12 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v13 = sel_getName(*(SEL *)(a1 + 48));
      int v14 = *(unsigned __int8 *)(a1 + 56);
      *(_DWORD *)int buf = 67110146;
      int v23 = v11;
      __int16 v24 = 2082;
      BOOL v25 = v12;
      __int16 v26 = 2082;
      int v27 = v13;
      __int16 v28 = 1024;
      int v29 = 566;
      __int16 v30 = 1024;
      int v31 = v14;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i LPCD is already set to: %d", buf, 0x28u);
    }

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    uint64_t v15 = NFSharedSignpostLog();
    if (os_signpost_enabled(v15))
    {
      *(_WORD *)int buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "NFCACD_ENABLE_LPCD", (const char *)&unk_100286819, buf, 2u);
    }

    int v16 = *(void **)(a1 + 32);
    v20[0] = _NSConcreteStackBlock;
    v20[1] = 3221225472;
    void v20[2] = sub_10026429C;
    v20[3] = &unk_1003088D8;
    char v21 = *(unsigned char *)(a1 + 56);
    uint64_t v17 = *(void *)(a1 + 48);
    v20[4] = v16;
    void v20[5] = v17;
    int v18 = [v16 _executeWithDriverSessionSync:@"enableLPCD" block:v20];
    uint64_t v19 = NFSharedSignpostLog();
    if (os_signpost_enabled(v19))
    {
      *(_WORD *)int buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v19, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "NFCACD_ENABLE_LPCD", (const char *)&unk_100286819, buf, 2u);
    }

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

uint64_t sub_10026429C(uint64_t a1)
{
  int v2 = *(unsigned __int8 *)(a1 + 48);
  id v3 = *(void **)(*(void *)(a1 + 32) + 88);
  if (v2)
  {
    id v4 = [v3 openSession:@"LpcdSession"];
    if (v4 != (id)1)
    {
      id v5 = v4;
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        NSErrorUserInfoKey v7 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(*(id *)(a1 + 32));
        BOOL isMetaClass = class_isMetaClass(Class);
        Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
        uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
        uint64_t v10 = 45;
        if (isMetaClass) {
          uint64_t v10 = 43;
        }
        v7(3, "%c[%{public}s %{public}s]:%i Failed to open session; hwState=%lu", v10, ClassName, Name, 581, v5);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v11 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        int v12 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v12)) {
          int v13 = 43;
        }
        else {
          int v13 = 45;
        }
        int v14 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v15 = sel_getName(*(SEL *)(a1 + 40));
        *(_DWORD *)int buf = 67110146;
        int v40 = v13;
        __int16 v41 = 2082;
        BOOL v42 = v14;
        __int16 v43 = 2082;
        __int16 v44 = v15;
        __int16 v45 = 1024;
        int v46 = 581;
        __int16 v47 = 2048;
        id v48 = v5;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session; hwState=%lu",
          buf,
          0x2Cu);
      }
    }
    uint64_t v16 = os_transaction_create();
    uint64_t v17 = *(void *)(a1 + 32);
    int v18 = *(void **)(v17 + 120);
    *(void *)(v17 + 120) = v16;

    char v19 = 1;
  }
  else
  {
    [v3 closeSession:@"LpcdSession"];
    uint64_t v20 = *(void *)(a1 + 32);
    char v21 = *(void **)(v20 + 120);
    *(void *)(v20 + 120) = 0;

    char v19 = 0;
  }
  *(unsigned char *)(*(void *)(a1 + 32) + 105) = v19;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v22 = NFLogGetLogger();
  if (v22)
  {
    int v23 = (void (*)(uint64_t, const char *, ...))v22;
    __int16 v24 = object_getClass(*(id *)(a1 + 32));
    BOOL v25 = class_isMetaClass(v24);
    __int16 v26 = object_getClassName(*(id *)(a1 + 32));
    int v27 = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v28 = 45;
    if (v25) {
      uint64_t v28 = 43;
    }
    v23(6, "%c[%{public}s %{public}s]:%i enabled: %d", v28, v26, v27, 594, *(unsigned __int8 *)(a1 + 48));
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v29 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v30 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v30)) {
      int v31 = 43;
    }
    else {
      int v31 = 45;
    }
    uint64_t v32 = object_getClassName(*(id *)(a1 + 32));
    id v33 = sel_getName(*(SEL *)(a1 + 40));
    int v34 = *(unsigned __int8 *)(a1 + 48);
    *(_DWORD *)int buf = 67110146;
    int v40 = v31;
    __int16 v41 = 2082;
    BOOL v42 = v32;
    __int16 v43 = 2082;
    __int16 v44 = v33;
    __int16 v45 = 1024;
    int v46 = 594;
    __int16 v47 = 1024;
    LODWORD(v48) = v34;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i enabled: %d", buf, 0x28u);
  }

  __int16 v35 = [*(id *)(a1 + 32) _getDefaults];
  [v35 setBool:*(unsigned __int8 *)(*(void *)(a1 + 32) + 105) forKey:@"LpcdAlwaysOn"];
  [v35 synchronize];

  [*(id *)(a1 + 32) maybeStartNextSession];
  return 0;
}

void sub_10026469C(void *a1)
{
  int v2 = NFSharedSignpostLog();
  if (os_signpost_enabled(v2))
  {
    *(_WORD *)int buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v2, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "NFCACD_GET_LAST_DETECTED_TAGS", (const char *)&unk_100286819, buf, 2u);
  }

  v15[0] = 0;
  v15[1] = v15;
  void v15[2] = 0x2020000000;
  char v16 = 0;
  *(void *)int buf = 0;
  uint64_t v10 = buf;
  uint64_t v11 = 0x3032000000;
  int v12 = sub_10000B948;
  int v13 = sub_100262AE0;
  id v14 = 0;
  id v3 = (void *)a1[4];
  v8[0] = _NSConcreteStackBlock;
  v8[1] = 3221225472;
  v8[2] = sub_10026489C;
  v8[3] = &unk_100308900;
  v8[4] = v3;
  void v8[5] = buf;
  uint64_t v4 = a1[6];
  v8[6] = v15;
  v8[7] = v4;
  id v5 = [v3 _executeWithDriverSessionSync:@"getLastDetectedTags" block:v8];
  uint64_t v6 = NFSharedSignpostLog();
  if (os_signpost_enabled(v6))
  {
    *(_WORD *)NSErrorUserInfoKey v7 = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v6, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "NFCACD_GET_LAST_DETECTED_TAGS", (const char *)&unk_100286819, v7, 2u);
  }

  (*(void (**)(void))(a1[5] + 16))();
  _Block_object_dispose(buf, 8);

  _Block_object_dispose(v15, 8);
}

void sub_100264874(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 64), 8);
  _Unwind_Resume(a1);
}

id sub_10026489C(uint64_t a1)
{
  int v2 = *(void **)(*(void *)(a1 + 32) + 88);
  uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8) + 24;
  id v35 = 0;
  uint64_t v4 = [v2 queryMultiTagState:v3 error:&v35];
  id v5 = v35;
  uint64_t v6 = *(void *)(*(void *)(a1 + 40) + 8);
  NSErrorUserInfoKey v7 = *(void **)(v6 + 40);
  *(void *)(v6 + 40) = v4;

  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    NSErrorUserInfoKey v9 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v14 = 45;
    if (isMetaClass) {
      uint64_t v14 = 43;
    }
    v9(6, "%c[%{public}s %{public}s]:%i enabled : %d  error: %{public}@", v14, ClassName, Name, 624, *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 48) + 8) + 24), v5);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v15 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    char v16 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v16)) {
      int v17 = 43;
    }
    else {
      int v17 = 45;
    }
    int v18 = object_getClassName(*(id *)(a1 + 32));
    char v19 = sel_getName(*(SEL *)(a1 + 56));
    int v20 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
    *(_DWORD *)int buf = 67110402;
    int v37 = v17;
    __int16 v38 = 2082;
    uint64_t v39 = v18;
    __int16 v40 = 2082;
    __int16 v41 = v19;
    __int16 v42 = 1024;
    int v43 = 624;
    __int16 v44 = 1024;
    LODWORD(v45[0]) = v20;
    WORD2(v45[0]) = 2114;
    *(void *)((char *)v45 + 6) = v5;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i enabled : %d  error: %{public}@", buf, 0x32u);
  }

  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v21 = NFLogGetLogger();
  if (v21)
  {
    uint64_t v22 = (void (*)(uint64_t, const char *, ...))v21;
    int v23 = object_getClass(*(id *)(a1 + 32));
    BOOL v24 = class_isMetaClass(v23);
    BOOL v25 = object_getClassName(*(id *)(a1 + 32));
    __int16 v26 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v27 = 45;
    if (v24) {
      uint64_t v27 = 43;
    }
    v22(6, "%c[%{public}s %{public}s]:%i %{public}@", v27, v25, v26, 625, *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40));
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v28 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    int v29 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v29)) {
      int v30 = 43;
    }
    else {
      int v30 = 45;
    }
    int v31 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v32 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v33 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    *(_DWORD *)int buf = 67110146;
    int v37 = v30;
    __int16 v38 = 2082;
    uint64_t v39 = v31;
    __int16 v40 = 2082;
    __int16 v41 = v32;
    __int16 v42 = 1024;
    int v43 = 625;
    __int16 v44 = 2114;
    v45[0] = v33;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }

  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24)) {
    objc_storeStrong((id *)(*(void *)(a1 + 32) + 152), *(id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40));
  }

  return v5;
}

uint64_t sub_100264CA8(uint64_t a1)
{
  int v2 = NFSharedSignpostLog();
  if (os_signpost_enabled(v2))
  {
    *(_WORD *)int buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v2, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFCACD_GET_MULTI_TAG_STATE", (const char *)&unk_100286819, buf, 2u);
  }

  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 644, *(void *)(*(void *)(a1 + 32) + 152));
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    int v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v15 = *(void *)(*(void *)(a1 + 32) + 152);
    *(_DWORD *)int buf = 67110146;
    int v18 = v12;
    __int16 v19 = 2082;
    int v20 = v13;
    __int16 v21 = 2082;
    uint64_t v22 = v14;
    __int16 v23 = 1024;
    int v24 = 644;
    __int16 v25 = 2114;
    uint64_t v26 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }

  return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_100265188(uint64_t a1)
{
  int v2 = NFSharedSignpostLog();
  if (os_signpost_enabled(v2))
  {
    *(_WORD *)int buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v2, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "NFCACD_CLEAR_MULTI_TAG_STATE", (const char *)&unk_100286819, buf, 2u);
  }

  uint64_t v3 = *(void **)(a1 + 32);
  v6[0] = _NSConcreteStackBlock;
  v6[1] = 3221225472;
  void v6[2] = sub_1002652DC;
  v6[3] = &unk_1003031A8;
  v6[4] = v3;
  uint64_t v4 = [v3 _executeWithDriverSessionSync:@"clearMultiTagState" block:v6];
  id v5 = NFSharedSignpostLog();
  if (os_signpost_enabled(v5))
  {
    *(_WORD *)int buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v5, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "NFCACD_CLEAR_MULTI_TAG_STATE", (const char *)&unk_100286819, buf, 2u);
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

id sub_1002652DC(uint64_t a1)
{
  unsigned __int8 v2 = [*(id *)(*(void *)(a1 + 32) + 88) clearMultiTagPollingState];
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void **)(v3 + 152);
  *(void *)(v3 + 152) = 0;

  id v5 = 0;
  if ((v2 & 1) == 0)
  {
    id v6 = objc_alloc((Class)NSError);
    NSErrorUserInfoKey v7 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v11 = NSLocalizedDescriptionKey;
    uint64_t v8 = +[NSString stringWithUTF8String:"Unknown Error"];
    int v12 = v8;
    uint64_t v9 = +[NSDictionary dictionaryWithObjects:&v12 forKeys:&v11 count:1];
    id v5 = [v6 initWithDomain:v7 code:6 userInfo:v9];
  }

  return v5;
}

void sub_1002656AC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_100265A64(uint64_t a1)
{
  return [*(id *)(a1 + 32) maybeStartNextSession];
}

void sub_1002663DC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10026672C(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 32) + 88) openSession:@"Shutdown preparation"];
  if (v2 == (id)1)
  {
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    [*(id *)(a1 + 32) _unloadService];
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
      uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v8 = 45;
      if (isMetaClass) {
        uint64_t v8 = 43;
      }
      v4(6, "%c[%{public}s %{public}s]:%i stop now but leave HW on", v8, ClassName, Name, 844);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      int v12 = object_getClassName(*(id *)(a1 + 32));
      int v13 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)int buf = 67109890;
      int v41 = v11;
      __int16 v42 = 2082;
      int v43 = v12;
      __int16 v44 = 2082;
      __int16 v45 = v13;
      __int16 v46 = 1024;
      int v47 = 844;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i stop now but leave HW on", buf, 0x22u);
    }

    [*(id *)(*(void *)(a1 + 32) + 88) stopNowAndLeveHWEnabled:*(unsigned __int8 *)(a1 + 56)];
    uint64_t v14 = *(void *)(a1 + 32);
    uint64_t v15 = *(NSObject **)(v14 + 16);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100266B34;
    block[3] = &unk_100301C40;
    uint64_t v16 = *(void *)(a1 + 48);
    void block[4] = v14;
    void block[5] = v16;
    dispatch_async(v15, block);
  }
  else
  {
    id v17 = v2;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v18 = NFLogGetLogger();
    if (v18)
    {
      __int16 v19 = (void (*)(uint64_t, const char *, ...))v18;
      int v20 = object_getClass(*(id *)(a1 + 32));
      BOOL v21 = class_isMetaClass(v20);
      int v34 = object_getClassName(*(id *)(a1 + 32));
      id v36 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v22 = 45;
      if (v21) {
        uint64_t v22 = 43;
      }
      v19(3, "%c[%{public}s %{public}s]:%i Failed to open session; hwState=%lu", v22, v34, v36, 838, v17);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v23 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
    {
      int v24 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v24)) {
        int v25 = 43;
      }
      else {
        int v25 = 45;
      }
      uint64_t v26 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v27 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)int buf = 67110146;
      int v41 = v25;
      __int16 v42 = 2082;
      int v43 = v26;
      __int16 v44 = 2082;
      __int16 v45 = v27;
      __int16 v46 = 1024;
      int v47 = 838;
      __int16 v48 = 2048;
      id v49 = v17;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session; hwState=%lu",
        buf,
        0x2Cu);
    }

    uint64_t v28 = *(void *)(a1 + 40);
    id v29 = objc_alloc((Class)NSError);
    int v30 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v38 = NSLocalizedDescriptionKey;
    int v31 = +[NSString stringWithUTF8String:"Unknown Error"];
    uint64_t v39 = v31;
    uint64_t v32 = +[NSDictionary dictionaryWithObjects:&v39 forKeys:&v38 count:1];
    id v33 = [v29 initWithDomain:v30 code:6 userInfo:v32];
    (*(void (**)(uint64_t, id))(v28 + 16))(v28, v33);
  }
}

void sub_100266B34(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v7 = 45;
    if (isMetaClass) {
      uint64_t v7 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i exiting now...", v7, ClassName, Name, 848);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v8 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v9)) {
      int v10 = 43;
    }
    else {
      int v10 = 45;
    }
    int v11 = object_getClassName(*(id *)(a1 + 32));
    int v12 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)int buf = 67109890;
    int v15 = v10;
    __int16 v16 = 2082;
    id v17 = v11;
    __int16 v18 = 2082;
    __int16 v19 = v12;
    __int16 v20 = 1024;
    int v21 = 848;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i exiting now...", buf, 0x22u);
  }

  exit(0);
}

id sub_100266D1C(uint64_t a1)
{
  return [*(id *)(a1 + 32) _dequeueSession:*(void *)(a1 + 40) startNextSession:1];
}

void sub_100267264(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_100267290(uint64_t a1)
{
  return [*(id *)(a1 + 32) maybeStartNextSession];
}

id sub_1002674A4(uint64_t a1)
{
  id v2 = *(void **)(*(void *)(a1 + 32) + 88);
  uint64_t v3 = +[NFRoutingConfig none];
  id v4 = [v2 setRouting:v3];

  id v5 = *(void **)(*(void *)(a1 + 32) + 88);
  id v28 = 0;
  unsigned __int8 v6 = [v5 getControllerInfo:&v28];
  id v7 = v28;
  id v8 = 0;
  if ((v6 & 1) == 0)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      int v10 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
      uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v14 = 45;
      if (isMetaClass) {
        uint64_t v14 = 43;
      }
      v10(3, "%c[%{public}s %{public}s]:%i Failed to get controller info", v14, ClassName, Name, 924);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v15 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      __int16 v16 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v16)) {
        int v17 = 43;
      }
      else {
        int v17 = 45;
      }
      __int16 v18 = object_getClassName(*(id *)(a1 + 32));
      __int16 v19 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)int buf = 67109890;
      int v32 = v17;
      __int16 v33 = 2082;
      int v34 = v18;
      __int16 v35 = 2082;
      id v36 = v19;
      __int16 v37 = 1024;
      int v38 = 924;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get controller info", buf, 0x22u);
    }

    id v20 = objc_alloc((Class)NSError);
    int v21 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v29 = NSLocalizedDescriptionKey;
    uint64_t v22 = +[NSString stringWithUTF8String:"Stack Error"];
    int v30 = v22;
    __int16 v23 = +[NSDictionary dictionaryWithObjects:&v30 forKeys:&v29 count:1];
    id v8 = [v20 initWithDomain:v21 code:15 userInfo:v23];
  }
  uint64_t v24 = *(void *)(a1 + 32);
  int v25 = *(void **)(v24 + 144);
  *(void *)(v24 + 144) = v7;

  return v8;
}

id sub_100267D74(uint64_t a1)
{
  return [*(id *)(a1 + 32) preferencesDidChange];
}

void sub_100268050(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v7 = 45;
    if (isMetaClass) {
      uint64_t v7 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i Releasing queued sessions", v7, ClassName, Name, 1016);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v8 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v9)) {
      int v10 = 43;
    }
    else {
      int v10 = 45;
    }
    int v11 = object_getClassName(*(id *)(a1 + 32));
    int v12 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)int buf = 67109890;
    int v37 = v10;
    __int16 v38 = 2082;
    uint64_t v39 = v11;
    __int16 v40 = 2082;
    int v41 = v12;
    __int16 v42 = 1024;
    int v43 = 1016;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Releasing queued sessions", buf, 0x22u);
  }

  int v13 = [*(id *)(a1 + 40) NF_userInfo];
  uint64_t v14 = [v13 objectForKeyedSubscript:@"ProxyObjects"];

  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  id v15 = [v14 copy];
  id v16 = [v15 countByEnumeratingWithState:&v31 objects:v35 count:16];
  if (v16)
  {
    uint64_t v17 = *(void *)v32;
    do
    {
      for (uint64_t i = 0; i != v16; uint64_t i = (char *)i + 1)
      {
        if (*(void *)v32 != v17) {
          objc_enumerationMutation(v15);
        }
        [*(id *)(a1 + 32) _dequeueSession:*(void *)(*((void *)&v31 + 1) + 8 * i) startNextSession:1];
      }
      id v16 = [v15 countByEnumeratingWithState:&v31 objects:v35 count:16];
    }
    while (v16);
  }

  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  __int16 v19 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
  if (v19)
  {
    id v20 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v20)) {
      uint64_t v21 = 43;
    }
    else {
      uint64_t v21 = 45;
    }
    uint64_t v22 = object_getClassName(*(id *)(a1 + 32));
    __int16 v23 = sel_getName(*(SEL *)(a1 + 48));
    v19(6, "%c[%{public}s %{public}s]:%i removing xpc connection from list", v21, v22, v23, 1024, (void)v31);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v24 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
  {
    int v25 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v25)) {
      int v26 = 43;
    }
    else {
      int v26 = 45;
    }
    uint64_t v27 = object_getClassName(*(id *)(a1 + 32));
    id v28 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)int buf = 67109890;
    int v37 = v26;
    __int16 v38 = 2082;
    uint64_t v39 = v27;
    __int16 v40 = 2082;
    int v41 = v28;
    __int16 v42 = 1024;
    int v43 = 1024;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i removing xpc connection from list", buf, 0x22u);
  }

  id v29 = *(id *)(*(void *)(a1 + 32) + 40);
  objc_sync_enter(v29);
  [*(id *)(*(void *)(a1 + 32) + 40) removeObject:*(void *)(a1 + 40)];
  objc_sync_exit(v29);
}

void sub_1002683E4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100268B00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,char a35)
{
}

void sub_100268B68(uint64_t a1)
{
  id v2 = NFSharedSignpostLog();
  if (os_signpost_enabled(v2))
  {
    *(_WORD *)int buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v2, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "initialLoad", (const char *)&unk_100286819, buf, 2u);
  }

  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = [*(id *)(a1 + 32) _loadHW];
  uint64_t v3 = NFSharedSignpostLog();
  if (os_signpost_enabled(v3))
  {
    *(_WORD *)id v4 = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v3, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "initialLoad", (const char *)&unk_100286819, v4, 2u);
  }
}

void sub_100268C4C(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  [v1 didCloseXPCConnection:WeakRetained];
}

void sub_100268CA0(uint64_t a1)
{
  uint64_t v1 = *(void **)(a1 + 32);
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  [v1 didCloseXPCConnection:WeakRetained];
}

void sub_100268DD0(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v7 = 45;
    if (isMetaClass) {
      uint64_t v7 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i Reader mode must stop", v7, ClassName, Name, 1086);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v8 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v9)) {
      int v10 = 43;
    }
    else {
      int v10 = 45;
    }
    int v11 = object_getClassName(*(id *)(a1 + 32));
    int v12 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)int buf = 67109890;
    int v20 = v10;
    __int16 v21 = 2082;
    uint64_t v22 = v11;
    __int16 v23 = 2082;
    uint64_t v24 = v12;
    __int16 v25 = 1024;
    int v26 = 1086;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Reader mode must stop", buf, 0x22u);
  }

  char v13 = objc_opt_respondsToSelector();
  uint64_t v14 = *(void *)(a1 + 32);
  if (v13)
  {
    [*(id *)(v14 + 64) handleReaderBurnoutTimer];
  }
  else
  {
    id v15 = *(void **)(v14 + 88);
    id v16 = +[NFRoutingConfig none];
    id v17 = [v15 setRouting:v16];
  }
}

id sub_100269080(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v7 = 45;
    if (isMetaClass) {
      uint64_t v7 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i Reader mode can resume", v7, ClassName, Name, 1102);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v8 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v9)) {
      int v10 = 43;
    }
    else {
      int v10 = 45;
    }
    int v11 = object_getClassName(*(id *)(a1 + 32));
    int v12 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)int buf = 67109890;
    int v18 = v10;
    __int16 v19 = 2082;
    int v20 = v11;
    __int16 v21 = 2082;
    uint64_t v22 = v12;
    __int16 v23 = 1024;
    int v24 = 1102;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Reader mode can resume", buf, 0x22u);
  }

  char v13 = objc_opt_respondsToSelector();
  uint64_t v14 = *(id **)(a1 + 32);
  if (v13) {
    return [v14[8] handleReaderBurnoutCleared];
  }
  else {
    return [v14 maybeStartNextSession];
  }
}

void sub_100269520(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v1 + 106))
  {
    if (*(void *)(v1 + 112) < 5uLL)
    {
      if (!*(unsigned char *)(v1 + 107))
      {
        *(unsigned char *)(v1 + 107) = 1;
        ++*(void *)(*(void *)(a1 + 32) + 112);
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          id v16 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(*(id *)(a1 + 32));
          BOOL isMetaClass = class_isMetaClass(Class);
          Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
          uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
          uint64_t v21 = 45;
          if (isMetaClass) {
            uint64_t v21 = 43;
          }
          v16(6, "%c[%{public}s %{public}s]:%i Restart MT detection : %d", v21, ClassName, Name, 1151, *(void *)(*(void *)(a1 + 32) + 112));
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v22 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v23 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v23)) {
            int v24 = 43;
          }
          else {
            int v24 = 45;
          }
          __int16 v25 = object_getClassName(*(id *)(a1 + 32));
          int v26 = sel_getName(*(SEL *)(a1 + 40));
          uint64_t v27 = *(void *)(*(void *)(a1 + 32) + 112);
          *(_DWORD *)int buf = 67110146;
          int v35 = v24;
          __int16 v36 = 2082;
          int v37 = v25;
          __int16 v38 = 2082;
          uint64_t v39 = v26;
          __int16 v40 = 1024;
          int v41 = 1151;
          __int16 v42 = 1024;
          int v43 = v27;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Restart MT detection : %d", buf, 0x28u);
        }

        id v28 = +[NFPowerAssertion sharedPowerAssertion];
        [v28 holdPowerAssertion:@"NfcacdPLLUnlock"];

        dispatch_time_t v29 = dispatch_time(0, 5000000000);
        uint64_t v30 = *(void *)(a1 + 32);
        long long v31 = *(NSObject **)(v30 + 16);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_1002698E0;
        block[3] = &unk_100301C68;
        void block[4] = v30;
        dispatch_after(v29, v31, block);
      }
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v3 = NFLogGetLogger();
      if (v3)
      {
        id v4 = (void (*)(uint64_t, const char *, ...))v3;
        id v5 = object_getClass(*(id *)(a1 + 32));
        BOOL v6 = class_isMetaClass(v5);
        uint64_t v7 = object_getClassName(*(id *)(a1 + 32));
        long long v32 = sel_getName(*(SEL *)(a1 + 40));
        uint64_t v8 = 45;
        if (v6) {
          uint64_t v8 = 43;
        }
        v4(3, "%c[%{public}s %{public}s]:%i Max restarts reached", v8, v7, v32, 1139);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v9 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        int v10 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v10)) {
          int v11 = 43;
        }
        else {
          int v11 = 45;
        }
        int v12 = object_getClassName(*(id *)(a1 + 32));
        char v13 = sel_getName(*(SEL *)(a1 + 40));
        *(_DWORD *)int buf = 67109890;
        int v35 = v11;
        __int16 v36 = 2082;
        int v37 = v12;
        __int16 v38 = 2082;
        uint64_t v39 = v13;
        __int16 v40 = 1024;
        int v41 = 1139;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Max restarts reached", buf, 0x22u);
      }

      uint64_t v14 = +[NSDistributedNotificationCenter defaultCenter];
      [v14 postNotificationName:@"com.apple.nfcacd.multitag.restart.error" object:0 userInfo:0 options:3];

      [*(id *)(*(void *)(a1 + 32) + 168) sendSimpleEvent:@"com.apple.nfcacd.multitag.restart.error"];
    }
  }
}

void sub_1002698E0(uint64_t a1)
{
  [*(id *)(a1 + 32) maybeStartNextSession];
  id v1 = +[NFPowerAssertion sharedPowerAssertion];
  [v1 releasePowerAssertion:@"NfcacdPLLUnlock"];
}

void sub_100269D88(uint64_t a1)
{
  id v2 = NFSharedSignpostLog();
  if (os_signpost_enabled(v2))
  {
    *(_WORD *)int buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v2, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFCACD_TAGS_DETECTED", (const char *)&unk_100286819, buf, 2u);
  }

  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 1179, *(void *)(a1 + 40));
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    char v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
    id v15 = *(void **)(a1 + 40);
    *(_DWORD *)int buf = 67110146;
    int v79 = v12;
    __int16 v80 = 2082;
    id v81 = v13;
    __int16 v82 = 2082;
    id v83 = v14;
    __int16 v84 = 1024;
    int v85 = 1179;
    __int16 v86 = 2114;
    uint64_t v87 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }

  if (*(void *)(*(void *)(a1 + 32) + 64) && (objc_opt_respondsToSelector() & 1) != 0)
  {
    [*(id *)(*(void *)(a1 + 32) + 64) handleRemoteTagsDetected:*(void *)(a1 + 40)];
    return;
  }
  if ([*(id *)(a1 + 40) count])
  {
    id v16 = [*(id *)(a1 + 40) objectAtIndex:0];
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v17 = NFLogGetLogger();
    if (v17)
    {
      int v18 = (void (*)(uint64_t, const char *, ...))v17;
      __int16 v19 = object_getClass(*(id *)(a1 + 32));
      BOOL v20 = class_isMetaClass(v19);
      id v72 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v73 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v21 = 45;
      if (v20) {
        uint64_t v21 = 43;
      }
      v18(6, "%c[%{public}s %{public}s]:%i Connecting to tag; %{public}@", v21, v72, v73, 1185, v16);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v22 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v23 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v23)) {
        int v24 = 43;
      }
      else {
        int v24 = 45;
      }
      __int16 v25 = object_getClassName(*(id *)(a1 + 32));
      int v26 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)int buf = 67110146;
      int v79 = v24;
      __int16 v80 = 2082;
      id v81 = v25;
      __int16 v82 = 2082;
      id v83 = v26;
      __int16 v84 = 1024;
      int v85 = 1185;
      __int16 v86 = 2114;
      uint64_t v87 = v16;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Connecting to tag; %{public}@",
        buf,
        0x2Cu);
    }

    unsigned int v27 = [*(id *)(*(void *)(a1 + 32) + 88) connectTag:v16];
    if (v27)
    {
      if (v27 != 51)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v61 = NFLogGetLogger();
        if (v61)
        {
          __int16 v62 = (void (*)(uint64_t, const char *, ...))v61;
          unsigned int v63 = object_getClass(*(id *)(a1 + 32));
          BOOL v64 = class_isMetaClass(v63);
          int v65 = object_getClassName(*(id *)(a1 + 32));
          int v77 = sel_getName(*(SEL *)(a1 + 48));
          uint64_t v66 = 45;
          if (v64) {
            uint64_t v66 = 43;
          }
          v62(6, "%c[%{public}s %{public}s]:%i Resuming discovery after failed connection", v66, v65, v77, 1192);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v67 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v67, OS_LOG_TYPE_DEFAULT))
        {
          id v68 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v68)) {
            int v69 = 43;
          }
          else {
            int v69 = 45;
          }
          os_signpost_id_t v70 = object_getClassName(*(id *)(a1 + 32));
          uint64_t v71 = sel_getName(*(SEL *)(a1 + 48));
          *(_DWORD *)int buf = 67109890;
          int v79 = v69;
          __int16 v80 = 2082;
          id v81 = v70;
          __int16 v82 = 2082;
          id v83 = v71;
          __int16 v84 = 1024;
          int v85 = 1192;
          _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Resuming discovery after failed connection", buf, 0x22u);
        }

        [*(id *)(*(void *)(a1 + 32) + 88) resumeDiscovery];
        goto LABEL_67;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v28 = NFLogGetLogger();
      if (v28)
      {
        dispatch_time_t v29 = (void (*)(uint64_t, const char *, ...))v28;
        uint64_t v30 = object_getClass(*(id *)(a1 + 32));
        BOOL v31 = class_isMetaClass(v30);
        long long v32 = object_getClassName(*(id *)(a1 + 32));
        int v74 = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v33 = 45;
        if (v31) {
          uint64_t v33 = 43;
        }
        v29(6, "%c[%{public}s %{public}s]:%i Restarting discovery after failed connection", v33, v32, v74, 1189);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      long long v34 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
LABEL_56:

        [*(id *)(*(void *)(a1 + 32) + 88) restartDiscovery];
LABEL_67:

        return;
      }
      int v35 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v35)) {
        int v36 = 43;
      }
      else {
        int v36 = 45;
      }
      int v37 = object_getClassName(*(id *)(a1 + 32));
      __int16 v38 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)int buf = 67109890;
      int v79 = v36;
      __int16 v80 = 2082;
      id v81 = v37;
      __int16 v82 = 2082;
      id v83 = v38;
      __int16 v84 = 1024;
      int v85 = 1189;
      uint64_t v39 = "%c[%{public}s %{public}s]:%i Restarting discovery after failed connection";
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v40 = NFLogGetLogger();
      if (v40)
      {
        int v41 = (void (*)(uint64_t, const char *, ...))v40;
        __int16 v42 = object_getClass(*(id *)(a1 + 32));
        BOOL v43 = class_isMetaClass(v42);
        __int16 v44 = object_getClassName(*(id *)(a1 + 32));
        int v75 = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v45 = 45;
        if (v43) {
          uint64_t v45 = 43;
        }
        v41(6, "%c[%{public}s %{public}s]:%i Disconnecting with tag removal detection", v45, v44, v75, 1197);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v46 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
      {
        int v47 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v47)) {
          int v48 = 43;
        }
        else {
          int v48 = 45;
        }
        id v49 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v50 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)int buf = 67109890;
        int v79 = v48;
        __int16 v80 = 2082;
        id v81 = v49;
        __int16 v82 = 2082;
        id v83 = v50;
        __int16 v84 = 1024;
        int v85 = 1197;
        _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Disconnecting with tag removal detection", buf, 0x22u);
      }

      if (![*(id *)(*(void *)(a1 + 32) + 88) disconnectTag:v16 tagRemovalDetect:1])goto LABEL_67; {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      }
      uint64_t v51 = NFLogGetLogger();
      if (v51)
      {
        int v52 = (void (*)(uint64_t, const char *, ...))v51;
        NSErrorUserInfoKey v53 = object_getClass(*(id *)(a1 + 32));
        BOOL v54 = class_isMetaClass(v53);
        uint64_t v55 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v76 = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v56 = 45;
        if (v54) {
          uint64_t v56 = 43;
        }
        v52(6, "%c[%{public}s %{public}s]:%i Restarting discovery after failed disconnection", v56, v55, v76, 1200);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      long long v34 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_56;
      }
      uint64_t v57 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v57)) {
        int v58 = 43;
      }
      else {
        int v58 = 45;
      }
      int v59 = object_getClassName(*(id *)(a1 + 32));
      __int16 v60 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)int buf = 67109890;
      int v79 = v58;
      __int16 v80 = 2082;
      id v81 = v59;
      __int16 v82 = 2082;
      id v83 = v60;
      __int16 v84 = 1024;
      int v85 = 1200;
      uint64_t v39 = "%c[%{public}s %{public}s]:%i Restarting discovery after failed disconnection";
    }
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, v39, buf, 0x22u);
    goto LABEL_56;
  }
}

void sub_10026A60C(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v8, ClassName, Name, 1211, *(void *)(a1 + 40));
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    int v12 = object_getClassName(*(id *)(a1 + 32));
    char v13 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v14 = *(void *)(a1 + 40);
    *(_DWORD *)int buf = 67110146;
    int v49 = v11;
    __int16 v50 = 2082;
    uint64_t v51 = v12;
    __int16 v52 = 2082;
    NSErrorUserInfoKey v53 = v13;
    __int16 v54 = 1024;
    int v55 = 1211;
    __int16 v56 = 2114;
    uint64_t v57 = v14;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }

  id v15 = NFSharedSignpostLog();
  if (os_signpost_enabled(v15))
  {
    *(_WORD *)int buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFCACD_MULTI_TAG_STATE_CHANGE", (const char *)&unk_100286819, buf, 2u);
  }

  id v16 = sub_1002090CC();
  uint64_t v17 = sub_100209734(v16, *(void **)(a1 + 40), *(void **)(*(void *)(a1 + 32) + 152), *(unsigned __int8 *)(a1 + 56));

  if (!*(unsigned char *)(a1 + 56))
  {
    id v18 = [*(id *)(a1 + 40) copy];
    uint64_t v19 = *(void *)(a1 + 32);
    BOOL v20 = *(void **)(v19 + 152);
    *(void *)(v19 + 152) = v18;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v21 = NFLogGetLogger();
  if (v21)
  {
    uint64_t v22 = (void (*)(uint64_t, const char *, ...))v21;
    __int16 v23 = object_getClass(*(id *)(a1 + 32));
    BOOL v24 = class_isMetaClass(v23);
    __int16 v25 = object_getClassName(*(id *)(a1 + 32));
    int v26 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v27 = 45;
    if (v24) {
      uint64_t v27 = 43;
    }
    v22(6, "%c[%{public}s %{public}s]:%i %{public}@", v27, v25, v26, 1221, *(void *)(*(void *)(a1 + 32) + 152));
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v28 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    dispatch_time_t v29 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v29)) {
      int v30 = 43;
    }
    else {
      int v30 = 45;
    }
    BOOL v31 = object_getClassName(*(id *)(a1 + 32));
    long long v32 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v33 = *(void *)(*(void *)(a1 + 32) + 152);
    *(_DWORD *)int buf = 67110146;
    int v49 = v30;
    __int16 v50 = 2082;
    uint64_t v51 = v31;
    __int16 v52 = 2082;
    NSErrorUserInfoKey v53 = v32;
    __int16 v54 = 1024;
    int v55 = 1221;
    __int16 v56 = 2114;
    uint64_t v57 = v33;
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }

  long long v34 = +[NSDistributedNotificationCenter defaultCenter];
  [v34 postNotificationName:@"com.apple.nfcacd.multitag.state.change" object:0 userInfo:v17 options:3];

  [*(id *)(*(void *)(a1 + 32) + 168) sendSimpleEvent:@"com.apple.nfcacd.multitag.state.change"];
  if (*(unsigned char *)(a1 + 56))
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v35 = NFLogGetLogger();
    if (v35)
    {
      int v36 = (void (*)(uint64_t, const char *, ...))v35;
      int v37 = object_getClass(*(id *)(a1 + 32));
      BOOL v38 = class_isMetaClass(v37);
      uint64_t v39 = object_getClassName(*(id *)(a1 + 32));
      int v47 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v40 = 45;
      if (v38) {
        uint64_t v40 = 43;
      }
      v36(3, "%c[%{public}s %{public}s]:%i RF Error seen during multitag scan", v40, v39, v47, 1229);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v41 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
    {
      __int16 v42 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v42)) {
        int v43 = 43;
      }
      else {
        int v43 = 45;
      }
      __int16 v44 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v45 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)int buf = 67109890;
      int v49 = v43;
      __int16 v50 = 2082;
      uint64_t v51 = v44;
      __int16 v52 = 2082;
      NSErrorUserInfoKey v53 = v45;
      __int16 v54 = 1024;
      int v55 = 1229;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i RF Error seen during multitag scan", buf, 0x22u);
    }

    __int16 v46 = +[NSDistributedNotificationCenter defaultCenter];
    [v46 postNotificationName:@"com.apple.nfcacd.multitag.state.change.rfError" object:0 userInfo:0 options:3];

    [*(id *)(*(void *)(a1 + 32) + 168) sendSimpleEvent:@"com.apple.nfcacd.multitag.state.change.rfError"];
  }
  *(void *)(*(void *)(a1 + 32) + 112) = 0;
}

void sub_10026B89C(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 32) + 88) openSession:@"Delayed Sleep"];
  if (v2 == (id)1)
  {
    unsigned __int8 v3 = [*(id *)(*(void *)(a1 + 32) + 88) triggerDelayedWake:*(unsigned __int8 *)(a1 + 56)];
    uint64_t v4 = *(void *)(a1 + 40);
    if (v3)
    {
      (*(void (**)(void, void))(v4 + 16))(*(void *)(a1 + 40), 0);
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        BOOL v6 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(*(id *)(a1 + 32));
        BOOL isMetaClass = class_isMetaClass(Class);
        Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
        uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v11 = 45;
        if (isMetaClass) {
          uint64_t v11 = 43;
        }
        v6(6, "%c[%{public}s %{public}s]:%i Delaying session close for %d seconds", v11, ClassName, Name, 1422, *(unsigned __int8 *)(a1 + 56) + 1);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v12 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        char v13 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v13)) {
          int v14 = 43;
        }
        else {
          int v14 = 45;
        }
        id v15 = object_getClassName(*(id *)(a1 + 32));
        id v16 = sel_getName(*(SEL *)(a1 + 48));
        int v17 = *(unsigned __int8 *)(a1 + 56) + 1;
        *(_DWORD *)int buf = 67110146;
        int v51 = v14;
        __int16 v52 = 2082;
        NSErrorUserInfoKey v53 = v15;
        __int16 v54 = 2082;
        int v55 = v16;
        __int16 v56 = 1024;
        int v57 = 1422;
        __int16 v58 = 1024;
        LODWORD(v59) = v17;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Delaying session close for %d seconds", buf, 0x28u);
      }

      dispatch_time_t v18 = dispatch_time(0, 1000000000 * *(unsigned __int8 *)(a1 + 56) + 1000000000);
      uint64_t v19 = *(void *)(a1 + 32);
      BOOL v20 = *(NSObject **)(v19 + 16);
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10026BDA4;
      block[3] = &unk_100301C68;
      void block[4] = v19;
      dispatch_after(v18, v20, block);
    }
    else
    {
      id v38 = objc_alloc((Class)NSError);
      uint64_t v39 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v46 = NSLocalizedDescriptionKey;
      uint64_t v40 = +[NSString stringWithUTF8String:"Stack Error"];
      int v47 = v40;
      int v41 = +[NSDictionary dictionaryWithObjects:&v47 forKeys:&v46 count:1];
      id v42 = [v38 initWithDomain:v39 code:15 userInfo:v41];
      (*(void (**)(uint64_t, id))(v4 + 16))(v4, v42);

      [*(id *)(*(void *)(a1 + 32) + 88) closeSession:@"Delayed Sleep"];
    }
  }
  else
  {
    id v21 = v2;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v22 = NFLogGetLogger();
    if (v22)
    {
      __int16 v23 = (void (*)(uint64_t, const char *, ...))v22;
      BOOL v24 = object_getClass(*(id *)(a1 + 32));
      BOOL v25 = class_isMetaClass(v24);
      int v43 = object_getClassName(*(id *)(a1 + 32));
      __int16 v44 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v26 = 45;
      if (v25) {
        uint64_t v26 = 43;
      }
      v23(3, "%c[%{public}s %{public}s]:%i Failed to open session; hwState=%lu", v26, v43, v44, 1407, v21);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v27 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      uint64_t v28 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v28)) {
        int v29 = 43;
      }
      else {
        int v29 = 45;
      }
      int v30 = object_getClassName(*(id *)(a1 + 32));
      BOOL v31 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)int buf = 67110146;
      int v51 = v29;
      __int16 v52 = 2082;
      NSErrorUserInfoKey v53 = v30;
      __int16 v54 = 2082;
      int v55 = v31;
      __int16 v56 = 1024;
      int v57 = 1407;
      __int16 v58 = 2048;
      id v59 = v21;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session; hwState=%lu",
        buf,
        0x2Cu);
    }

    uint64_t v32 = *(void *)(a1 + 40);
    id v33 = objc_alloc((Class)NSError);
    long long v34 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v48 = NSLocalizedDescriptionKey;
    uint64_t v35 = +[NSString stringWithUTF8String:"Stack Error"];
    int v49 = v35;
    int v36 = +[NSDictionary dictionaryWithObjects:&v49 forKeys:&v48 count:1];
    id v37 = [v33 initWithDomain:v34 code:15 userInfo:v36];
    (*(void (**)(uint64_t, id))(v32 + 16))(v32, v37);
  }
}

id sub_10026BDA4(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 88) closeSession:@"Delayed Sleep"];
}

id sub_10026BE7C(uint64_t a1)
{
  return [*(id *)(a1 + 32) _sync_pushSignedRF:*(void *)(a1 + 40) callback:*(void *)(a1 + 48)];
}

id sub_10026BF68(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    unsigned __int8 v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v7 = 45;
    if (isMetaClass) {
      uint64_t v7 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i Disabling all routing to change RF settings", v7, ClassName, Name, 1442);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v8 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v9)) {
      int v10 = 43;
    }
    else {
      int v10 = 45;
    }
    uint64_t v11 = object_getClassName(*(id *)(a1 + 32));
    int v12 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)int buf = 67109890;
    int v32 = v10;
    __int16 v33 = 2082;
    long long v34 = v11;
    __int16 v35 = 2082;
    int v36 = v12;
    __int16 v37 = 1024;
    int v38 = 1442;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Disabling all routing to change RF settings", buf, 0x22u);
  }

  char v13 = *(void **)(*(void *)(a1 + 32) + 88);
  int v14 = +[NFRoutingConfig none];
  id v15 = [v13 setRouting:v14];

  id v16 = [*(id *)(*(void *)(a1 + 32) + 88) pushSignedRF:*(void *)(a1 + 40)];
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v17 = NFLogGetLogger();
  if (v17)
  {
    dispatch_time_t v18 = (void (*)(uint64_t, const char *, ...))v17;
    uint64_t v19 = object_getClass(*(id *)(a1 + 32));
    BOOL v20 = class_isMetaClass(v19);
    id v21 = object_getClassName(*(id *)(a1 + 32));
    int v30 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v22 = 45;
    if (v20) {
      uint64_t v22 = 43;
    }
    v18(6, "%c[%{public}s %{public}s]:%i Restoring routing", v22, v21, v30, 1448);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  __int16 v23 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v24 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v24)) {
      int v25 = 43;
    }
    else {
      int v25 = 45;
    }
    uint64_t v26 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v27 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)int buf = 67109890;
    int v32 = v25;
    __int16 v33 = 2082;
    long long v34 = v26;
    __int16 v35 = 2082;
    int v36 = v27;
    __int16 v37 = 1024;
    int v38 = 1448;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Restoring routing", buf, 0x22u);
  }

  [*(id *)(a1 + 32) maybeStartNextSession];

  return v16;
}

void sub_10026C2D4(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    unsigned __int8 v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    Classuint64_t Name = object_getClassName(*(id *)(a1 + 32));
    uint64_t Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %d", v8, ClassName, Name, 1460, *(unsigned __int8 *)(a1 + 48));
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    int v12 = object_getClassName(*(id *)(a1 + 32));
    char v13 = sel_getName(*(SEL *)(a1 + 40));
    int v14 = *(unsigned __int8 *)(a1 + 48);
    *(_DWORD *)int buf = 67110146;
    int v29 = v11;
    __int16 v30 = 2082;
    BOOL v31 = v12;
    __int16 v32 = 2082;
    __int16 v33 = v13;
    __int16 v34 = 1024;
    int v35 = 1460;
    __int16 v36 = 1024;
    int v37 = v14;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %d", buf, 0x28u);
  }

  uint64_t v15 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v15 + 106) && *(void *)(v15 + 128) || *(unsigned char *)(v15 + 105) && *(void *)(v15 + 120))
  {
    [(id)v15 maybeStartNextSession];
  }
  else
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v16 = NFLogGetLogger();
    if (v16)
    {
      uint64_t v17 = (void (*)(uint64_t, const char *, ...))v16;
      dispatch_time_t v18 = object_getClass(*(id *)(a1 + 32));
      BOOL v19 = class_isMetaClass(v18);
      BOOL v20 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v27 = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v21 = 45;
      if (v19) {
        uint64_t v21 = 43;
      }
      v17(5, "%c[%{public}s %{public}s]:%i MultiTag or LPCD not setup yet", v21, v20, v27, 1467);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v22 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v23 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v23)) {
        int v24 = 43;
      }
      else {
        int v24 = 45;
      }
      int v25 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v26 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)int buf = 67109890;
      int v29 = v24;
      __int16 v30 = 2082;
      BOOL v31 = v25;
      __int16 v32 = 2082;
      __int16 v33 = v26;
      __int16 v34 = 1024;
      int v35 = 1467;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i MultiTag or LPCD not setup yet", buf, 0x22u);
    }
  }
}

uint64_t AMFDRSealingMapCopyLocalData()
{
  return _AMFDRSealingMapCopyLocalData();
}

uint64_t AnalyticsSendEvent()
{
  return _AnalyticsSendEvent();
}

uint64_t AnalyticsSendEventLazy()
{
  return _AnalyticsSendEventLazy();
}

unsigned __int8 *__cdecl CC_SHA256(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return _CC_SHA256(data, len, md);
}

CFTypeID CFBooleanGetTypeID(void)
{
  return _CFBooleanGetTypeID();
}

Boolean CFBooleanGetValue(CFBooleanRef BOOLean)
{
  return _CFBooleanGetValue(BOOLean);
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return _CFDataCreate(allocator, bytes, length);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return _CFDataGetBytePtr(theData);
}

void CFDataGetBytes(CFDataRef theData, CFRange range, UInt8 *buffer)
{
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return _CFDataGetLength(theData);
}

CFTypeID CFDataGetTypeID(void)
{
  return _CFDataGetTypeID();
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return _CFDictionaryCreateMutable(allocator, capacity, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutableCopy(CFAllocatorRef allocator, CFIndex capacity, CFDictionaryRef theDict)
{
  return _CFDictionaryCreateMutableCopy(allocator, capacity, theDict);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return _CFDictionaryGetTypeID();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return _CFDictionaryGetValue(theDict, key);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return _CFGetTypeID(cf);
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  return _CFNotificationCenterGetDarwinNotifyCenter();
}

void CFNotificationCenterRemoveEveryObserver(CFNotificationCenterRef center, const void *observer)
{
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return _CFNumberCreate(allocator, theType, valuePtr);
}

CFTypeID CFNumberGetTypeID(void)
{
  return _CFNumberGetTypeID();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return _CFNumberGetValue(number, theType, valuePtr);
}

void CFRelease(CFTypeRef cf)
{
}

void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
}

CFRunLoopRef CFRunLoopGetCurrent(void)
{
  return _CFRunLoopGetCurrent();
}

CFRunLoopRef CFRunLoopGetMain(void)
{
  return _CFRunLoopGetMain();
}

void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
}

uint64_t CFRunLoopRunSpecific()
{
  return _CFRunLoopRunSpecific();
}

void CFRunLoopStop(CFRunLoopRef rl)
{
}

CFIndex CFStringGetBytes(CFStringRef theString, CFRange range, CFStringEncoding encoding, UInt8 lossByte, Boolean isExternalRepresentation, UInt8 *buffer, CFIndex maxBufLen, CFIndex *usedBufLen)
{
  return _CFStringGetBytes(theString, range, encoding, lossByte, isExternalRepresentation, buffer, maxBufLen, usedBufLen);
}

CFIndex CFStringGetLength(CFStringRef theString)
{
  return _CFStringGetLength(theString);
}

CFTypeID CFStringGetTypeID(void)
{
  return _CFStringGetTypeID();
}

CFUserNotificationRef CFUserNotificationCreate(CFAllocatorRef allocator, CFTimeInterval timeout, CFOptionFlags flags, SInt32 *error, CFDictionaryRef dictionary)
{
  return _CFUserNotificationCreate(allocator, timeout, flags, error, dictionary);
}

CFRunLoopSourceRef CFUserNotificationCreateRunLoopSource(CFAllocatorRef allocator, CFUserNotificationRef userNotification, CFUserNotificationCallBack callout, CFIndex order)
{
  return _CFUserNotificationCreateRunLoopSource(allocator, userNotification, callout, order);
}

uint64_t GetElapsedTimeInMillisecondsFromMachTime()
{
  return _GetElapsedTimeInMillisecondsFromMachTime();
}

kern_return_t IOConnectCallScalarMethod(mach_port_t connection, uint32_t selector, const uint64_t *input, uint32_t inputCnt, uint64_t *output, uint32_t *outputCnt)
{
  return _IOConnectCallScalarMethod(connection, selector, input, inputCnt, output, outputCnt);
}

kern_return_t IOConnectCallStructMethod(mach_port_t connection, uint32_t selector, const void *inputStruct, size_t inputStructCnt, void *outputStruct, size_t *outputStructCnt)
{
  return _IOConnectCallStructMethod(connection, selector, inputStruct, inputStructCnt, outputStruct, outputStructCnt);
}

uint64_t IOHIDEventCreateVendorDefinedEvent()
{
  return _IOHIDEventCreateVendorDefinedEvent();
}

uint64_t IOHIDServiceClientCopyEvent()
{
  return _IOHIDServiceClientCopyEvent();
}

BOOLean_t IOIteratorIsValid(io_iterator_t iterator)
{
  return _IOIteratorIsValid(iterator);
}

io_object_t IOIteratorNext(io_iterator_t iterator)
{
  return _IOIteratorNext(iterator);
}

IONotificationPortRef IONotificationPortCreate(mach_port_t mainPort)
{
  return _IONotificationPortCreate(mainPort);
}

void IONotificationPortDestroy(IONotificationPortRef notify)
{
}

void IONotificationPortSetDispatchQueue(IONotificationPortRef notify, dispatch_queue_t queue)
{
}

kern_return_t IOObjectRelease(io_object_t object)
{
  return _IOObjectRelease(object);
}

IOReturn IOPMCancelScheduledPowerEvent(CFDateRef time_to_wake, CFStringRef my_id, CFStringRef type)
{
  return _IOPMCancelScheduledPowerEvent(time_to_wake, my_id, type);
}

CFArrayRef IOPMCopyScheduledPowerEvents(void)
{
  return _IOPMCopyScheduledPowerEvents();
}

IOReturn IOPMSchedulePowerEvent(CFDateRef time_to_wake, CFStringRef my_id, CFStringRef type)
{
  return _IOPMSchedulePowerEvent(time_to_wake, my_id, type);
}

CFTypeRef IORegistryEntryCreateCFProperty(io_registry_entry_t entry, CFStringRef key, CFAllocatorRef allocator, IOOptionBits options)
{
  return _IORegistryEntryCreateCFProperty(entry, key, allocator, options);
}

io_registry_entry_t IORegistryEntryFromPath(mach_port_t mainPort, const io_string_t path)
{
  return _IORegistryEntryFromPath(mainPort, path);
}

kern_return_t IORegistryEntrySetCFProperty(io_registry_entry_t entry, CFStringRef propertyName, CFTypeRef property)
{
  return _IORegistryEntrySetCFProperty(entry, propertyName, property);
}

kern_return_t IOServiceAddInterestNotification(IONotificationPortRef notifyPort, io_service_t service, const io_name_t interestType, IOServiceInterestCallback callback, void *refCon, io_object_t *notification)
{
  return _IOServiceAddInterestNotification(notifyPort, service, interestType, callback, refCon, notification);
}

kern_return_t IOServiceClose(io_connect_t connect)
{
  return _IOServiceClose(connect);
}

io_service_t IOServiceGetMatchingService(mach_port_t mainPort, CFDictionaryRef matching)
{
  return _IOServiceGetMatchingService(mainPort, matching);
}

kern_return_t IOServiceGetMatchingServices(mach_port_t mainPort, CFDictionaryRef matching, io_iterator_t *existing)
{
  return _IOServiceGetMatchingServices(mainPort, matching, existing);
}

CFMutableDictionaryRef IOServiceMatching(const char *name)
{
  return _IOServiceMatching(name);
}

CFMutableDictionaryRef IOServiceNameMatching(const char *name)
{
  return _IOServiceNameMatching(name);
}

kern_return_t IOServiceOpen(io_service_t service, task_port_t owningTask, uint32_t type, io_connect_t *connect)
{
  return _IOServiceOpen(service, owningTask, type, connect);
}

uint64_t MKBDeviceUnlockedSinceBoot()
{
  return _MKBDeviceUnlockedSinceBoot();
}

uint64_t MKBGetDeviceLockState()
{
  return _MKBGetDeviceLockState();
}

uint64_t MKBGetDeviceLockStateInfo()
{
  return _MKBGetDeviceLockStateInfo();
}

uint64_t MSUParsedToleratedFailureForStep()
{
  return _MSUParsedToleratedFailureForStep();
}

uint64_t NFBootUUID()
{
  return _NFBootUUID();
}

uint64_t NFBuildVersion()
{
  return _NFBuildVersion();
}

uint64_t NFCreateWorkLoop()
{
  return _NFCreateWorkLoop();
}

uint64_t NFDataCreateWithBytes()
{
  return _NFDataCreateWithBytes();
}

uint64_t NFDataCreateWithBytesNoCopy()
{
  return _NFDataCreateWithBytesNoCopy();
}

uint64_t NFDataCreateWithLength()
{
  return _NFDataCreateWithLength();
}

uint64_t NFDataRelease()
{
  return _NFDataRelease();
}

uint64_t NFDataToCFDataCreateOwnership()
{
  return _NFDataToCFDataCreateOwnership();
}

uint64_t NFDriverClose()
{
  return _NFDriverClose();
}

uint64_t NFDriverConfigureAutomaticMultiTagPolling()
{
  return _NFDriverConfigureAutomaticMultiTagPolling();
}

uint64_t NFDriverConfigureExpressFelicaEntry()
{
  return _NFDriverConfigureExpressFelicaEntry();
}

uint64_t NFDriverConfigureReaderModeRFForTransitPartner()
{
  return _NFDriverConfigureReaderModeRFForTransitPartner();
}

uint64_t NFDriverConfigureVASPolling()
{
  return _NFDriverConfigureVASPolling();
}

uint64_t NFDriverContinuousWave()
{
  return _NFDriverContinuousWave();
}

uint64_t NFDriverCopyAndClearAssertion()
{
  return _NFDriverCopyAndClearAssertion();
}

uint64_t NFDriverCopySEIDFromFDR()
{
  return _NFDriverCopySEIDFromFDR();
}

uint64_t NFDriverCopySMBLog()
{
  return _NFDriverCopySMBLog();
}

uint64_t NFDriverCrashNFCC()
{
  return _NFDriverCrashNFCC();
}

uint64_t NFDriverCreateErrorCode()
{
  return _NFDriverCreateErrorCode();
}

uint64_t NFDriverDisableHeadlessModeMiniNV()
{
  return _NFDriverDisableHeadlessModeMiniNV();
}

uint64_t NFDriverDumpLPMDebugLog()
{
  return _NFDriverDumpLPMDebugLog();
}

uint64_t NFDriverEnableAntiRelay()
{
  return _NFDriverEnableAntiRelay();
}

uint64_t NFDriverEnableAutomaticRFOverride()
{
  return _NFDriverEnableAutomaticRFOverride();
}

uint64_t NFDriverEnableFelicaTxEndPatternV2()
{
  return _NFDriverEnableFelicaTxEndPatternV2();
}

uint64_t NFDriverEnableGreenCarThreshold()
{
  return _NFDriverEnableGreenCarThreshold();
}

uint64_t NFDriverEnableHeadlessModeMiniNV()
{
  return _NFDriverEnableHeadlessModeMiniNV();
}

uint64_t NFDriverEnableHeadlessTestMode()
{
  return _NFDriverEnableHeadlessTestMode();
}

uint64_t NFDriverEnableReaderModeDynamicBBAControl()
{
  return _NFDriverEnableReaderModeDynamicBBAControl();
}

uint64_t NFDriverEnableSMBLogging()
{
  return _NFDriverEnableSMBLogging();
}

uint64_t NFDriverGetControllerInfo()
{
  return _NFDriverGetControllerInfo();
}

uint64_t NFDriverGetFlashWriteCounter()
{
  return _NFDriverGetFlashWriteCounter();
}

uint64_t NFDriverGetHeadlessModeFlags()
{
  return _NFDriverGetHeadlessModeFlags();
}

uint64_t NFDriverGetMultiTagState()
{
  return _NFDriverGetMultiTagState();
}

uint64_t NFDriverGetOSUpdateLog()
{
  return _NFDriverGetOSUpdateLog();
}

uint64_t NFDriverGetPowerCounter()
{
  return _NFDriverGetPowerCounter();
}

uint64_t NFDriverGetReaderProhibitTimer()
{
  return _NFDriverGetReaderProhibitTimer();
}

uint64_t NFDriverGetSWIOTemperature()
{
  return _NFDriverGetSWIOTemperature();
}

uint64_t NFDriverGetSecureElementInfo()
{
  return _NFDriverGetSecureElementInfo();
}

uint64_t NFDriverGetUniqueFDRKey()
{
  return _NFDriverGetUniqueFDRKey();
}

uint64_t NFDriverGetUnlockRequestInfo()
{
  return _NFDriverGetUnlockRequestInfo();
}

uint64_t NFDriverHCISoftReset()
{
  return _NFDriverHCISoftReset();
}

uint64_t NFDriverISO15693SetDataRate()
{
  return _NFDriverISO15693SetDataRate();
}

uint64_t NFDriverIsHostWakeCapable()
{
  return _NFDriverIsHostWakeCapable();
}

uint64_t NFDriverLoadStack()
{
  return _NFDriverLoadStack();
}

uint64_t NFDriverOpen()
{
  return _NFDriverOpen();
}

uint64_t NFDriverPreventReset()
{
  return _NFDriverPreventReset();
}

uint64_t NFDriverPrintPageEraseCounter()
{
  return _NFDriverPrintPageEraseCounter();
}

uint64_t NFDriverRFSettingsCopy()
{
  return _NFDriverRFSettingsCopy();
}

uint64_t NFDriverRFSettingsPushSignedSetting()
{
  return _NFDriverRFSettingsPushSignedSetting();
}

uint64_t NFDriverReadATETrimVersion()
{
  return _NFDriverReadATETrimVersion();
}

uint64_t NFDriverReadDieID()
{
  return _NFDriverReadDieID();
}

uint64_t NFDriverReadPageEraseCounter()
{
  return _NFDriverReadPageEraseCounter();
}

uint64_t NFDriverRedactLogging()
{
  return _NFDriverRedactLogging();
}

uint64_t NFDriverRemoteDevCheckNdef()
{
  return _NFDriverRemoteDevCheckNdef();
}

uint64_t NFDriverRemoteDevCheckPresence()
{
  return _NFDriverRemoteDevCheckPresence();
}

uint64_t NFDriverRemoteDevConnect()
{
  return _NFDriverRemoteDevConnect();
}

uint64_t NFDriverRemoteDevDisconnect()
{
  return _NFDriverRemoteDevDisconnect();
}

uint64_t NFDriverRemoteDevFormatNdef()
{
  return _NFDriverRemoteDevFormatNdef();
}

uint64_t NFDriverRemoteDevGetMiFareInfo()
{
  return _NFDriverRemoteDevGetMiFareInfo();
}

uint64_t NFDriverRemoteDevReadNdef()
{
  return _NFDriverRemoteDevReadNdef();
}

uint64_t NFDriverRemoteDevReceive()
{
  return _NFDriverRemoteDevReceive();
}

uint64_t NFDriverRemoteDevReceiveAsync()
{
  return _NFDriverRemoteDevReceiveAsync();
}

uint64_t NFDriverRemoteDevSend()
{
  return _NFDriverRemoteDevSend();
}

uint64_t NFDriverRemoteDevWriteLockNdef()
{
  return _NFDriverRemoteDevWriteLockNdef();
}

uint64_t NFDriverRemoteDevWriteNdef()
{
  return _NFDriverRemoteDevWriteNdef();
}

uint64_t NFDriverRemoteDeviceFelicaTransceive()
{
  return _NFDriverRemoteDeviceFelicaTransceive();
}

uint64_t NFDriverRemoteDeviceIso14443Transceive()
{
  return _NFDriverRemoteDeviceIso14443Transceive();
}

uint64_t NFDriverRemoteDeviceIso15693Transceive()
{
  return _NFDriverRemoteDeviceIso15693Transceive();
}

uint64_t NFDriverRestartDiscovery()
{
  return _NFDriverRestartDiscovery();
}

uint64_t NFDriverSecureElementGetAttackCounterLog()
{
  return _NFDriverSecureElementGetAttackCounterLog();
}

uint64_t NFDriverSecureElementGetPresenceOfAttackLog()
{
  return _NFDriverSecureElementGetPresenceOfAttackLog();
}

uint64_t NFDriverSecureElementTransceive()
{
  return _NFDriverSecureElementTransceive();
}

uint64_t NFDriverSetCallback()
{
  return _NFDriverSetCallback();
}

uint64_t NFDriverSetChipscope()
{
  return _NFDriverSetChipscope();
}

uint64_t NFDriverSetConfiguration()
{
  return _NFDriverSetConfiguration();
}

uint64_t NFDriverSetExpressConfig()
{
  return _NFDriverSetExpressConfig();
}

uint64_t NFDriverSetHeadlessMode()
{
  return _NFDriverSetHeadlessMode();
}

uint64_t NFDriverSetPollingConfig()
{
  return _NFDriverSetPollingConfig();
}

uint64_t NFDriverSetPollingProfile()
{
  return _NFDriverSetPollingProfile();
}

uint64_t NFDriverSetSecureElementAlwaysOn()
{
  return _NFDriverSetSecureElementAlwaysOn();
}

uint64_t NFDriverSetSecureElementPower()
{
  return _NFDriverSetSecureElementPower();
}

uint64_t NFDriverSetTemporaryPollingPeriod()
{
  return _NFDriverSetTemporaryPollingPeriod();
}

uint64_t NFDriverSetTypeATagDataRate()
{
  return _NFDriverSetTypeATagDataRate();
}

uint64_t NFDriverSimulateCrash()
{
  return _NFDriverSimulateCrash();
}

uint64_t NFDriverSupportsSecureTimersInOFF()
{
  return _NFDriverSupportsSecureTimersInOFF();
}

uint64_t NFDriverToggleGPIO()
{
  return _NFDriverToggleGPIO();
}

uint64_t NFDriverTriggerDelayedWake()
{
  return _NFDriverTriggerDelayedWake();
}

uint64_t NFDriverUnloadStackAndLeaveHWEnabled()
{
  return _NFDriverUnloadStackAndLeaveHWEnabled();
}

uint64_t NFGetProductType()
{
  return _NFGetProductType();
}

uint64_t NFIsChinaSku()
{
  return _NFIsChinaSku();
}

uint64_t NFIsDarwinOS()
{
  return _NFIsDarwinOS();
}

uint64_t NFIsInternalBuild()
{
  return _NFIsInternalBuild();
}

uint64_t NFIsNonRFDeviceWithLPMSupport()
{
  return _NFIsNonRFDeviceWithLPMSupport();
}

uint64_t NFIsSeashipSupported()
{
  return _NFIsSeashipSupported();
}

uint64_t NFIsUIBuild()
{
  return _NFIsUIBuild();
}

uint64_t NFLogGetLogger()
{
  return _NFLogGetLogger();
}

uint64_t NFPlatformShouldLimitAccessoryReaderTime()
{
  return _NFPlatformShouldLimitAccessoryReaderTime();
}

uint64_t NFPlatformShouldUseLookbackRestrictor()
{
  return _NFPlatformShouldUseLookbackRestrictor();
}

uint64_t NFProductAllowsWiredInDLMode()
{
  return _NFProductAllowsWiredInDLMode();
}

uint64_t NFProductHasB0LPKey()
{
  return _NFProductHasB0LPKey();
}

uint64_t NFProductHasNFCRadio()
{
  return _NFProductHasNFCRadio();
}

uint64_t NFProductHasThermistor()
{
  return _NFProductHasThermistor();
}

uint64_t NFProductIsDevBoard()
{
  return _NFProductIsDevBoard();
}

uint64_t NFProductIsMac()
{
  return _NFProductIsMac();
}

uint64_t NFProductIsNED()
{
  return _NFProductIsNED();
}

uint64_t NFProductIsPad()
{
  return _NFProductIsPad();
}

uint64_t NFProductIsPhone()
{
  return _NFProductIsPhone();
}

uint64_t NFProductIsVM()
{
  return _NFProductIsVM();
}

uint64_t NFProductIsWatch()
{
  return _NFProductIsWatch();
}

uint64_t NFProductSupportsAC()
{
  return _NFProductSupportsAC();
}

uint64_t NFProductSupportsNFCReader()
{
  return _NFProductSupportsNFCReader();
}

uint64_t NFSetThreadPriority()
{
  return _NFSetThreadPriority();
}

uint64_t NFSharedLogGetLogger()
{
  return _NFSharedLogGetLogger();
}

uint64_t NFSharedSignpostLog()
{
  return _NFSharedSignpostLog();
}

uint64_t NFThermalMonitorProvidedBySMC()
{
  return _NFThermalMonitorProvidedBySMC();
}

uint64_t NF_isFeatureSupported()
{
  return _NF_isFeatureSupported();
}

Class NSClassFromString(NSString *aClassName)
{
  return _NSClassFromString(aClassName);
}

NSString *NSHomeDirectory(void)
{
  return _NSHomeDirectory();
}

SEL NSSelectorFromString(NSString *aSelectorName)
{
  return _NSSelectorFromString(aSelectorName);
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return _NSStringFromClass(aClass);
}

NSString *NSTemporaryDirectory(void)
{
  return _NSTemporaryDirectory();
}

uint64_t PLLogRegisteredEvent()
{
  return _PLLogRegisteredEvent();
}

SCPreferencesRef SCPreferencesCreate(CFAllocatorRef allocator, CFStringRef name, CFStringRef prefsID)
{
  return _SCPreferencesCreate(allocator, name, prefsID);
}

CFPropertyListRef SCPreferencesGetValue(SCPreferencesRef prefs, CFStringRef key)
{
  return _SCPreferencesGetValue(prefs, key);
}

Boolean SCPreferencesSetCallback(SCPreferencesRef prefs, SCPreferencesCallBack callout, SCPreferencesContext *context)
{
  return _SCPreferencesSetCallback(prefs, callout, context);
}

Boolean SCPreferencesSetDispatchQueue(SCPreferencesRef prefs, dispatch_queue_t queue)
{
  return _SCPreferencesSetDispatchQueue(prefs, queue);
}

void SCPreferencesSynchronize(SCPreferencesRef prefs)
{
}

int SecRandomCopyBytes(SecRandomRef rnd, size_t count, void *bytes)
{
  return _SecRandomCopyBytes(rnd, count, bytes);
}

CFTypeRef SecTaskCopyValueForEntitlement(SecTaskRef task, CFStringRef entitlement, CFErrorRef *error)
{
  return _SecTaskCopyValueForEntitlement(task, entitlement, error);
}

SecTaskRef SecTaskCreateWithAuditToken(CFAllocatorRef allocator, audit_token_t *token)
{
  return _SecTaskCreateWithAuditToken(allocator, token);
}

uint64_t TelephonyBasebandCreateController()
{
  return _TelephonyBasebandCreateController();
}

uint64_t TelephonyBasebandGetReset()
{
  return _TelephonyBasebandGetReset();
}

uint64_t TelephonyBasebandRegisterForReset()
{
  return _TelephonyBasebandRegisterForReset();
}

uint64_t ValidateAPDUWithAIDAllowList()
{
  return _ValidateAPDUWithAIDAllowList();
}

void _Block_object_dispose(const void *a1, const int a2)
{
}

uint64_t _CFXPCCreateCFObjectFromXPCObject()
{
  return __CFXPCCreateCFObjectFromXPCObject();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

int *__error(void)
{
  return ___error();
}

double __exp10(double a1)
{
  return ___exp10(a1);
}

uint64_t __memcpy_chk()
{
  return ___memcpy_chk();
}

int __sprintf_chk(char *a1, int a2, size_t a3, const char *a4, ...)
{
  return ___sprintf_chk(a1, a2, a3, a4);
}

uint64_t __strlcpy_chk()
{
  return ___strlcpy_chk();
}

void _exit(int a1)
{
}

os_activity_t _os_activity_create(void *dso, const char *description, os_activity_t activity, os_activity_flag_t flags)
{
  return __os_activity_create(dso, description, activity, flags);
}

void _os_log_debug_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_signpost_emit_with_name_impl(void *dso, os_log_t log, os_signpost_type_t type, os_signpost_id_t spid, const char *name, const char *format, uint8_t *buf, uint32_t size)
{
}

uint64_t _sl_dlopen()
{
  return __sl_dlopen();
}

void abort(void)
{
}

uint32_t arc4random(void)
{
  return _arc4random();
}

void arc4random_buf(void *__buf, size_t __nbytes)
{
}

void bzero(void *a1, size_t a2)
{
}

int chmod(const char *a1, mode_t a2)
{
  return _chmod(a1, a2);
}

objc_property_t *__cdecl class_copyPropertyList(Class cls, unsigned int *outCount)
{
  return _class_copyPropertyList(cls, outCount);
}

const char *__cdecl class_getName(Class cls)
{
  return _class_getName(cls);
}

Class class_getSuperclass(Class cls)
{
  return _class_getSuperclass(cls);
}

BOOL class_isMetaClass(Class cls)
{
  return _class_isMetaClass(cls);
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

void dispatch_async_and_wait(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return _dispatch_get_global_queue(identifier, flags);
}

void *__cdecl dispatch_get_specific(const void *key)
{
  return _dispatch_get_specific(key);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return _dispatch_queue_attr_make_with_autorelease_frequency(attr, frequency);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return _dispatch_queue_attr_make_with_qos_class(attr, qos_class, relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return _dispatch_queue_create(label, attr);
}

void dispatch_queue_set_specific(dispatch_queue_t queue, const void *key, void *context, dispatch_function_t destructor)
{
}

void dispatch_resume(dispatch_object_t object)
{
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return _dispatch_semaphore_create(value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return _dispatch_semaphore_signal(dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return _dispatch_semaphore_wait(dsema, timeout);
}

void dispatch_set_context(dispatch_object_t object, void *context)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return _dispatch_source_create(type, handle, mask, queue);
}

void dispatch_source_set_event_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return _dispatch_time(when, delta);
}

int dlclose(void *__handle)
{
  return _dlclose(__handle);
}

char *dlerror(void)
{
  return _dlerror();
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return _dlopen(__path, __mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return _dlsym(__handle, __symbol);
}

void exit(int a1)
{
}

int fflush(FILE *a1)
{
  return _fflush(a1);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return _fopen(__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return _fprintf(a1, a2);
}

int fputs(const char *a1, FILE *a2)
{
  return _fputs(a1, a2);
}

void free(void *a1)
{
}

uint64_t ftell(FILE *a1)
{
  return _ftell(a1);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return _fwrite(__ptr, __size, __nitems, __stream);
}

char *__cdecl getenv(const char *a1)
{
  return _getenv(a1);
}

const char *getprogname(void)
{
  return _getprogname();
}

int gettimeofday(timeval *a1, void *a2)
{
  return _gettimeofday(a1, a2);
}

uint64_t kdebug_trace()
{
  return _kdebug_trace();
}

tm *__cdecl localtime(const time_t *a1)
{
  return _localtime(a1);
}

uint64_t mach_absolute_time(void)
{
  return _mach_absolute_time();
}

uint64_t mach_continuous_time(void)
{
  return _mach_continuous_time();
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return _mach_timebase_info(info);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_calloc(count, size, type_id);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return _memcpy(__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return _memmove(__dst, __src, __len);
}

errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n)
{
  return _memset_s(__s, __smax, __c, __n);
}

uint32_t notify_cancel(int token)
{
  return _notify_cancel(token);
}

uint32_t notify_get_state(int token, uint64_t *state64)
{
  return _notify_get_state(token, state64);
}

BOOL notify_is_valid_token(int val)
{
  return _notify_is_valid_token(val);
}

uint32_t notify_post(const char *name)
{
  return _notify_post(name);
}

uint32_t notify_register_check(const char *name, int *out_token)
{
  return _notify_register_check(name, out_token);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return _notify_register_dispatch(name, out_token, queue, handler);
}

uint32_t notify_set_state(int token, uint64_t state64)
{
  return _notify_set_state(token, state64);
}

id objc_alloc(Class a1)
{
  return _[a1 alloc];
}

uint64_t objc_alloc_init()
{
  return _objc_alloc_init();
}

id objc_autorelease(id a1)
{
  return _objc_autorelease(a1);
}

{
}

{
}

id objc_autoreleaseReturnValue(id a1)
{
  return _objc_autoreleaseReturnValue(a1);
}

id objc_begin_catch(void *exc_buf)
{
  return _objc_begin_catch(exc_buf);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return _objc_claimAutoreleasedReturnValue();
}

void objc_copyWeak(id *to, id *from)
{
}

void objc_destroyWeak(id *location)
{
}

void objc_end_catch(void)
{
}

void objc_enumerationMutation(id obj)
{
}

Class objc_getClass(const char *name)
{
  return _objc_getClass(name);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return _objc_getProperty(self, _cmd, offset, atomic);
}

id objc_initWeak(id *location, id val)
{
  return _objc_initWeak(location, val);
}

id objc_loadWeakRetained(id *location)
{
  return _objc_loadWeakRetained(location);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return [super a2];
}

uint64_t objc_opt_class()
{
  return _objc_opt_class();
}

uint64_t objc_opt_isKindOfClass()
{
  return _objc_opt_isKindOfClass();
}

uint64_t objc_opt_new()
{
  return _objc_opt_new();
}

uint64_t objc_opt_respondsToSelector()
{
  return _objc_opt_respondsToSelector();
}

uint64_t self
{
  return _self;
}

void objc_release(id a1)
{
}

id objc_retain(id a1)
{
  return _objc_retain(a1);
}

id objc_retainAutorelease(id a1)
{
  return _a1;
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return _a1;
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return _a1;
}

id objc_retainBlock(id a1)
{
  return _objc_retainBlock(a1);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
}

void objc_storeStrong(id *location, id obj)
{
}

id objc_storeWeak(id *location, id obj)
{
  return _objc_storeWeak(location, obj);
}

int objc_sync_enter(id obj)
{
  return _objc_sync_enter(obj);
}

int objc_sync_exit(id obj)
{
  return _objc_sync_exit(obj);
}

id objc_unsafeClaimAutoreleasedReturnValue(id a1)
{
  return _objc_unsafeClaimAutoreleasedReturnValue(a1);
}

Class object_getClass(id a1)
{
  return _object_getClass(a1);
}

const char *__cdecl object_getClassName(id a1)
{
  return _object_getClassName(a1);
}

void os_activity_scope_enter(os_activity_t activity, os_activity_scope_state_t state)
{
}

void os_activity_scope_leave(os_activity_scope_state_t state)
{
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return _os_log_type_enabled(oslog, type);
}

BOOL os_signpost_enabled(os_log_t log)
{
  return _os_signpost_enabled(log);
}

os_signpost_id_t os_signpost_id_generate(os_log_t log)
{
  return _os_signpost_id_generate(log);
}

uint64_t os_state_add_handler()
{
  return _os_state_add_handler();
}

uint64_t os_transaction_create()
{
  return _os_transaction_create();
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

uint64_t os_variant_has_internal_diagnostics()
{
  return _os_variant_has_internal_diagnostics();
}

int printf(const char *a1, ...)
{
  return _printf(a1);
}

int proc_name(int pid, void *buffer, uint32_t buffersize)
{
  return _proc_name(pid, buffer, buffersize);
}

const char *__cdecl property_getName(objc_property_t property)
{
  return _property_getName(property);
}

const char *__cdecl sel_getName(SEL sel)
{
  return _sel_getName(sel);
}

void (__cdecl *__cdecl signal(int a1, void (__cdecl *a2)(int)))(int)
{
  return _signal(a1, a2);
}

unsigned int sleep(unsigned int a1)
{
  return _sleep(a1);
}

int sprintf(char *a1, const char *a2, ...)
{
  return _sprintf(a1, a2);
}

int strcmp(const char *__s1, const char *__s2)
{
  return _strcmp(__s1, __s2);
}

char *__cdecl strerror(int __errnum)
{
  return _strerror(__errnum);
}

size_t strftime(char *a1, size_t a2, const char *a3, const tm *a4)
{
  return _strftime(a1, a2, a3, a4);
}

size_t strnlen(const char *__s1, size_t __n)
{
  return _strnlen(__s1, __n);
}

char *__cdecl strtok_r(char *__str, const char *__sep, char **__lasts)
{
  return _strtok_r(__str, __sep, __lasts);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return _sysctl(a1, a2, a3, a4, a5, a6);
}

int sysctlbyname(const char *a1, void *a2, size_t *a3, void *a4, size_t a5)
{
  return _sysctlbyname(a1, a2, a3, a4, a5);
}

time_t time(time_t *a1)
{
  return _time(a1);
}

uint64_t ucurr_getDefaultFractionDigits()
{
  return _ucurr_getDefaultFractionDigits();
}

uint64_t ucurr_getNumericCode()
{
  return _ucurr_getNumericCode();
}

int usleep(useconds_t a1)
{
  return _usleep(a1);
}

int vfprintf(FILE *a1, const char *a2, va_list a3)
{
  return _vfprintf(a1, a2, a3);
}

const char *__cdecl xpc_dictionary_get_string(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_string(xdict, key);
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return _xpc_get_type(object);
}

void xpc_set_event_stream_handler(const char *stream, dispatch_queue_t targetq, xpc_handler_t handler)
{
}

double __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> sub_10026E234(double a1)
{
  return a1;
}

double sub_10026E2D8(double result)
{
  if (!atomic_load((unsigned int *)&unk_100344760)) {
    return sub_10026E234(result);
  }
  return result;
}

double sub_10026E2FC(double result)
{
  if (!atomic_load((unsigned int *)&unk_100344760)) {
    return sub_10026E234(result);
  }
  return result;
}

id objc_msgSend_AIDAllowList(void *a1, const char *a2, ...)
{
  return [a1 AIDAllowList];
}

id objc_msgSend_DERItem(void *a1, const char *a2, ...)
{
  return [a1 DERItem];
}

id objc_msgSend_Device(void *a1, const char *a2, ...)
{
  return [a1 Device];
}

id objc_msgSend_IDm(void *a1, const char *a2, ...)
{
  return [a1 IDm];
}

id objc_msgSend_NFCTag(void *a1, const char *a2, ...)
{
  return [a1 NFCTag];
}

id objc_msgSend_OSMode(void *a1, const char *a2, ...)
{
  return [a1 OSMode];
}

id objc_msgSend_PMm(void *a1, const char *a2, ...)
{
  return [a1 PMm];
}

id objc_msgSend_ROMVersion(void *a1, const char *a2, ...)
{
  return [a1 ROMVersion];
}

id objc_msgSend_SystemCode(void *a1, const char *a2, ...)
{
  return [a1 SystemCode];
}

id objc_msgSend_UID(void *a1, const char *a2, ...)
{
  return [a1 UID];
}

id objc_msgSend_URL(void *a1, const char *a2, ...)
{
  return [a1 URL];
}

id objc_msgSend_UTF8String(void *a1, const char *a2, ...)
{
  return [a1 UTF8String];
}

id objc_msgSend_UUID(void *a1, const char *a2, ...)
{
  return [a1 UUID];
}

id objc_msgSend_UUIDString(void *a1, const char *a2, ...)
{
  return [a1 UUIDString];
}

id objc_msgSend_Wireless(void *a1, const char *a2, ...)
{
  return [a1 Wireless];
}

id objc_msgSend__attemptNFCCRecovery(void *a1, const char *a2, ...)
{
  return [a1 _attemptNFCCRecovery];
}

id objc_msgSend__buildTapToRadarURL(void *a1, const char *a2, ...)
{
  return [a1 _buildTapToRadarURL];
}

id objc_msgSend__checkFailForwardState(void *a1, const char *a2, ...)
{
  return [a1 _checkFailForwardState];
}

id objc_msgSend__cleanupVAS(void *a1, const char *a2, ...)
{
  return [a1 _cleanupVAS];
}

id objc_msgSend__creationDateString(void *a1, const char *a2, ...)
{
  return [a1 _creationDateString];
}

id objc_msgSend__deauthorize(void *a1, const char *a2, ...)
{
  return [a1 _deauthorize];
}

id objc_msgSend__dumpLPEMAppletLogs(void *a1, const char *a2, ...)
{
  return [a1 _dumpLPEMAppletLogs];
}

id objc_msgSend__fireFelicaTransactionEndEvent(void *a1, const char *a2, ...)
{
  return [a1 _fireFelicaTransactionEndEvent];
}

id objc_msgSend__fireFelicaTransactionStartEvent(void *a1, const char *a2, ...)
{
  return [a1 _fireFelicaTransactionStartEvent];
}

id objc_msgSend__getDefaults(void *a1, const char *a2, ...)
{
  return [a1 _getDefaults];
}

id objc_msgSend__getInfo(void *a1, const char *a2, ...)
{
  return [a1 _getInfo];
}

id objc_msgSend__getInstance(void *a1, const char *a2, ...)
{
  return [a1 _getInstance];
}

id objc_msgSend__getMaxRFTimeLimitOverride(void *a1, const char *a2, ...)
{
  return [a1 _getMaxRFTimeLimitOverride];
}

id objc_msgSend__getNodeList(void *a1, const char *a2, ...)
{
  return [a1 _getNodeList];
}

id objc_msgSend__getRelatedGroupMembersForActiveApplet(void *a1, const char *a2, ...)
{
  return [a1 _getRelatedGroupMembersForActiveApplet];
}

id objc_msgSend__getTagNotificationConfig(void *a1, const char *a2, ...)
{
  return [a1 _getTagNotificationConfig];
}

id objc_msgSend__handleReaderBurnoutProtectionDebounceTimer(void *a1, const char *a2, ...)
{
  return [a1 _handleReaderBurnoutProtectionDebounceTimer];
}

id objc_msgSend__handleReaderBurnoutProtectionTimer(void *a1, const char *a2, ...)
{
  return [a1 _handleReaderBurnoutProtectionTimer];
}

id objc_msgSend__hceComplete(void *a1, const char *a2, ...)
{
  return [a1 _hceComplete];
}

id objc_msgSend__initManagedBySP(void *a1, const char *a2, ...)
{
  return [a1 _initManagedBySP];
}

id objc_msgSend__initPaymentAIDPrefixList(void *a1, const char *a2, ...)
{
  return [a1 _initPaymentAIDPrefixList];
}

id objc_msgSend__internalCleanup(void *a1, const char *a2, ...)
{
  return [a1 _internalCleanup];
}

id objc_msgSend__invalidateStepupController(void *a1, const char *a2, ...)
{
  return [a1 _invalidateStepupController];
}

id objc_msgSend__invalidateUIController(void *a1, const char *a2, ...)
{
  return [a1 _invalidateUIController];
}

id objc_msgSend__isClosed(void *a1, const char *a2, ...)
{
  return [a1 _isClosed];
}

id objc_msgSend__isCoreNFCSession(void *a1, const char *a2, ...)
{
  return [a1 _isCoreNFCSession];
}

id objc_msgSend__isEMVPolling(void *a1, const char *a2, ...)
{
  return [a1 _isEMVPolling];
}

id objc_msgSend__loadHW(void *a1, const char *a2, ...)
{
  return [a1 _loadHW];
}

id objc_msgSend__loadHWInfo(void *a1, const char *a2, ...)
{
  return [a1 _loadHWInfo];
}

id objc_msgSend__loadService(void *a1, const char *a2, ...)
{
  return [a1 _loadService];
}

id objc_msgSend__powerAssertionIdentifier(void *a1, const char *a2, ...)
{
  return [a1 _powerAssertionIdentifier];
}

id objc_msgSend__printHceCurrentState(void *a1, const char *a2, ...)
{
  return [a1 _printHceCurrentState];
}

id objc_msgSend__purgeOldOperations(void *a1, const char *a2, ...)
{
  return [a1 _purgeOldOperations];
}

id objc_msgSend__readDriverSettings(void *a1, const char *a2, ...)
{
  return [a1 _readDriverSettings];
}

id objc_msgSend__recoveryFailed(void *a1, const char *a2, ...)
{
  return [a1 _recoveryFailed];
}

id objc_msgSend__recoverySucceeded(void *a1, const char *a2, ...)
{
  return [a1 _recoverySucceeded];
}

id objc_msgSend__refreshNdefTagConnection(void *a1, const char *a2, ...)
{
  return [a1 _refreshNdefTagConnection];
}

id objc_msgSend__requiresReaderModeProtection(void *a1, const char *a2, ...)
{
  return [a1 _requiresReaderModeProtection];
}

id objc_msgSend__requiresThermalModeProtection(void *a1, const char *a2, ...)
{
  return [a1 _requiresThermalModeProtection];
}

id objc_msgSend__routingConfigWithECPBroadcastInHCE(void *a1, const char *a2, ...)
{
  return [a1 _routingConfigWithECPBroadcastInHCE];
}

id objc_msgSend__setReaderECP(void *a1, const char *a2, ...)
{
  return [a1 _setReaderECP];
}

id objc_msgSend__startSEProxyListener(void *a1, const char *a2, ...)
{
  return [a1 _startSEProxyListener];
}

id objc_msgSend__unloadService(void *a1, const char *a2, ...)
{
  return [a1 _unloadService];
}

id objc_msgSend__updateAllPowerCounters(void *a1, const char *a2, ...)
{
  return [a1 _updateAllPowerCounters];
}

id objc_msgSend__validateStartStopSequence(void *a1, const char *a2, ...)
{
  return [a1 _validateStartStopSequence];
}

id objc_msgSend__wasActiveTooLong(void *a1, const char *a2, ...)
{
  return [a1 _wasActiveTooLong];
}

id objc_msgSend_absoluteString(void *a1, const char *a2, ...)
{
  return [a1 absoluteString];
}

id objc_msgSend_accessoryMultiTag(void *a1, const char *a2, ...)
{
  return [a1 accessoryMultiTag];
}

id objc_msgSend_accessoryReaderWithLPCD(void *a1, const char *a2, ...)
{
  return [a1 accessoryReaderWithLPCD];
}

id objc_msgSend_activate(void *a1, const char *a2, ...)
{
  return [a1 activate];
}

id objc_msgSend_activeApplet(void *a1, const char *a2, ...)
{
  return [a1 activeApplet];
}

id objc_msgSend_activeAppletGroupMembers(void *a1, const char *a2, ...)
{
  return [a1 activeAppletGroupMembers];
}

id objc_msgSend_activeKeyIdentifiers(void *a1, const char *a2, ...)
{
  return [a1 activeKeyIdentifiers];
}

id objc_msgSend_activeRouting(void *a1, const char *a2, ...)
{
  return [a1 activeRouting];
}

id objc_msgSend_aid(void *a1, const char *a2, ...)
{
  return [a1 aid];
}

id objc_msgSend_allKeys(void *a1, const char *a2, ...)
{
  return [a1 allKeys];
}

id objc_msgSend_allObjects(void *a1, const char *a2, ...)
{
  return [a1 allObjects];
}

id objc_msgSend_allSystemCodes(void *a1, const char *a2, ...)
{
  return [a1 allSystemCodes];
}

id objc_msgSend_allValues(void *a1, const char *a2, ...)
{
  return [a1 allValues];
}

id objc_msgSend_allowBackgroundedSession(void *a1, const char *a2, ...)
{
  return [a1 allowBackgroundedSession];
}

id objc_msgSend_allowSleep(void *a1, const char *a2, ...)
{
  return [a1 allowSleep];
}

id objc_msgSend_allowTransactionsInWiredMode(void *a1, const char *a2, ...)
{
  return [a1 allowTransactionsInWiredMode];
}

id objc_msgSend_allowedAIDsListInWiredMode(void *a1, const char *a2, ...)
{
  return [a1 allowedAIDsListInWiredMode];
}

id objc_msgSend_allowlistChecker(void *a1, const char *a2, ...)
{
  return [a1 allowlistChecker];
}

id objc_msgSend_allowsBackgroundMode(void *a1, const char *a2, ...)
{
  return [a1 allowsBackgroundMode];
}

id objc_msgSend_alternateDSID(void *a1, const char *a2, ...)
{
  return [a1 alternateDSID];
}

id objc_msgSend_answer(void *a1, const char *a2, ...)
{
  return [a1 answer];
}

id objc_msgSend_appleTransactionHash(void *a1, const char *a2, ...)
{
  return [a1 appleTransactionHash];
}

id objc_msgSend_applet(void *a1, const char *a2, ...)
{
  return [a1 applet];
}

id objc_msgSend_appletIdentifier(void *a1, const char *a2, ...)
{
  return [a1 appletIdentifier];
}

id objc_msgSend_appletSelectedInWiredMode(void *a1, const char *a2, ...)
{
  return [a1 appletSelectedInWiredMode];
}

id objc_msgSend_applets(void *a1, const char *a2, ...)
{
  return [a1 applets];
}

id objc_msgSend_applicationIdentifier(void *a1, const char *a2, ...)
{
  return [a1 applicationIdentifier];
}

id objc_msgSend_array(void *a1, const char *a2, ...)
{
  return [a1 array];
}

id objc_msgSend_asData(void *a1, const char *a2, ...)
{
  return [a1 asData];
}

id objc_msgSend_asDictionary(void *a1, const char *a2, ...)
{
  return [a1 asDictionary];
}

id objc_msgSend_asMutableData(void *a1, const char *a2, ...)
{
  return [a1 asMutableData];
}

id objc_msgSend_asXPCObject(void *a1, const char *a2, ...)
{
  return [a1 asXPCObject];
}

id objc_msgSend_assertionHolders(void *a1, const char *a2, ...)
{
  return [a1 assertionHolders];
}

id objc_msgSend_assertionTime(void *a1, const char *a2, ...)
{
  return [a1 assertionTime];
}

id objc_msgSend_assertionType(void *a1, const char *a2, ...)
{
  return [a1 assertionType];
}

id objc_msgSend_auditToken(void *a1, const char *a2, ...)
{
  return [a1 auditToken];
}

id objc_msgSend_authTransientConfigurable(void *a1, const char *a2, ...)
{
  return [a1 authTransientConfigurable];
}

id objc_msgSend_authTransientSupport(void *a1, const char *a2, ...)
{
  return [a1 authTransientSupport];
}

id objc_msgSend_background(void *a1, const char *a2, ...)
{
  return [a1 background];
}

id objc_msgSend_backgroundTagReadCustomECP(void *a1, const char *a2, ...)
{
  return [a1 backgroundTagReadCustomECP];
}

id objc_msgSend_backgroundTagReadEcpOption(void *a1, const char *a2, ...)
{
  return [a1 backgroundTagReadEcpOption];
}

id objc_msgSend_bgTagReadingAssertion(void *a1, const char *a2, ...)
{
  return [a1 bgTagReadingAssertion];
}

id objc_msgSend_BOOLValue(void *a1, const char *a2, ...)
{
  return [a1 BOOLValue];
}

id objc_msgSend_bundle(void *a1, const char *a2, ...)
{
  return [a1 bundle];
}

id objc_msgSend_bundleIdentifier(void *a1, const char *a2, ...)
{
  return [a1 bundleIdentifier];
}

id objc_msgSend_bytes(void *a1, const char *a2, ...)
{
  return [a1 bytes];
}

id objc_msgSend_caLogger(void *a1, const char *a2, ...)
{
  return [a1 caLogger];
}

id objc_msgSend_cachedAppletUpdateCounter(void *a1, const char *a2, ...)
{
  return [a1 cachedAppletUpdateCounter];
}

id objc_msgSend_cachedAppletsUnfiltered(void *a1, const char *a2, ...)
{
  return [a1 cachedAppletsUnfiltered];
}

id objc_msgSend_cachedBeforeRFReset(void *a1, const char *a2, ...)
{
  return [a1 cachedBeforeRFReset];
}

id objc_msgSend_canEnableExpress(void *a1, const char *a2, ...)
{
  return [a1 canEnableExpress];
}

id objc_msgSend_cancel(void *a1, const char *a2, ...)
{
  return [a1 cancel];
}

id objc_msgSend_cardEmulationType(void *a1, const char *a2, ...)
{
  return [a1 cardEmulationType];
}

id objc_msgSend_cardModeAccess(void *a1, const char *a2, ...)
{
  return [a1 cardModeAccess];
}

id objc_msgSend_cardState(void *a1, const char *a2, ...)
{
  return [a1 cardState];
}

id objc_msgSend_category(void *a1, const char *a2, ...)
{
  return [a1 category];
}

id objc_msgSend_chAssertion(void *a1, const char *a2, ...)
{
  return [a1 chAssertion];
}

id objc_msgSend_chFieldType(void *a1, const char *a2, ...)
{
  return [a1 chFieldType];
}

id objc_msgSend_chRandomData(void *a1, const char *a2, ...)
{
  return [a1 chRandomData];
}

id objc_msgSend_challenge(void *a1, const char *a2, ...)
{
  return [a1 challenge];
}

id objc_msgSend_charValue(void *a1, const char *a2, ...)
{
  return [a1 charValue];
}

id objc_msgSend_checkAIDAllowList(void *a1, const char *a2, ...)
{
  return [a1 checkAIDAllowList];
}

id objc_msgSend_checkPairing(void *a1, const char *a2, ...)
{
  return [a1 checkPairing];
}

id objc_msgSend_children(void *a1, const char *a2, ...)
{
  return [a1 children];
}

id objc_msgSend_cleanup(void *a1, const char *a2, ...)
{
  return [a1 cleanup];
}

id objc_msgSend_cleanupUI(void *a1, const char *a2, ...)
{
  return [a1 cleanupUI];
}

id objc_msgSend_clearMultiTagPollingState(void *a1, const char *a2, ...)
{
  return [a1 clearMultiTagPollingState];
}

id objc_msgSend_clearUIControllerInvalidationHandler(void *a1, const char *a2, ...)
{
  return [a1 clearUIControllerInvalidationHandler];
}

id objc_msgSend_clientName(void *a1, const char *a2, ...)
{
  return [a1 clientName];
}

id objc_msgSend_cloneWithReaderDisabled(void *a1, const char *a2, ...)
{
  return [a1 cloneWithReaderDisabled];
}

id objc_msgSend_clss(void *a1, const char *a2, ...)
{
  return [a1 clss];
}

id objc_msgSend_code(void *a1, const char *a2, ...)
{
  return [a1 code];
}

id objc_msgSend_configurationForDefaultMainDisplayMonitor(void *a1, const char *a2, ...)
{
  return [a1 configurationForDefaultMainDisplayMonitor];
}

id objc_msgSend_connectedTag(void *a1, const char *a2, ...)
{
  return [a1 connectedTag];
}

id objc_msgSend_connection(void *a1, const char *a2, ...)
{
  return [a1 connection];
}

id objc_msgSend_connectionHandoverProcessCompleted(void *a1, const char *a2, ...)
{
  return [a1 connectionHandoverProcessCompleted];
}

id objc_msgSend_contactlessOnAny(void *a1, const char *a2, ...)
{
  return [a1 contactlessOnAny];
}

id objc_msgSend_containsSubKeys(void *a1, const char *a2, ...)
{
  return [a1 containsSubKeys];
}

id objc_msgSend_controllerInfo(void *a1, const char *a2, ...)
{
  return [a1 controllerInfo];
}

id objc_msgSend_copy(void *a1, const char *a2, ...)
{
  return [a1 copy];
}

id objc_msgSend_copyPMUService(void *a1, const char *a2, ...)
{
  return [a1 copyPMUService];
}

id objc_msgSend_coreDuetActivityRevoked(void *a1, const char *a2, ...)
{
  return [a1 coreDuetActivityRevoked];
}

id objc_msgSend_coreNFCUIInvalidate(void *a1, const char *a2, ...)
{
  return [a1 coreNFCUIInvalidate];
}

id objc_msgSend_count(void *a1, const char *a2, ...)
{
  return [a1 count];
}

id objc_msgSend_counterLimit(void *a1, const char *a2, ...)
{
  return [a1 counterLimit];
}

id objc_msgSend_counterValue(void *a1, const char *a2, ...)
{
  return [a1 counterValue];
}

id objc_msgSend_countryCode(void *a1, const char *a2, ...)
{
  return [a1 countryCode];
}

id objc_msgSend_createCHSelectErrorMessage(void *a1, const char *a2, ...)
{
  return [a1 createCHSelectErrorMessage];
}

id objc_msgSend_creation(void *a1, const char *a2, ...)
{
  return [a1 creation];
}

id objc_msgSend_creationDate(void *a1, const char *a2, ...)
{
  return [a1 creationDate];
}

id objc_msgSend_currencyCode(void *a1, const char *a2, ...)
{
  return [a1 currencyCode];
}

id objc_msgSend_currentCalendar(void *a1, const char *a2, ...)
{
  return [a1 currentCalendar];
}

id objc_msgSend_currentConnection(void *a1, const char *a2, ...)
{
  return [a1 currentConnection];
}

id objc_msgSend_currentHandler(void *a1, const char *a2, ...)
{
  return [a1 currentHandler];
}

id objc_msgSend_currentLocale(void *a1, const char *a2, ...)
{
  return [a1 currentLocale];
}

id objc_msgSend_currentRouting(void *a1, const char *a2, ...)
{
  return [a1 currentRouting];
}

id objc_msgSend_currentState(void *a1, const char *a2, ...)
{
  return [a1 currentState];
}

id objc_msgSend_currentTag(void *a1, const char *a2, ...)
{
  return [a1 currentTag];
}

id objc_msgSend_data(void *a1, const char *a2, ...)
{
  return [a1 data];
}

id objc_msgSend_date(void *a1, const char *a2, ...)
{
  return [a1 date];
}

id objc_msgSend_day(void *a1, const char *a2, ...)
{
  return [a1 day];
}

id objc_msgSend_deactivateAllApps(void *a1, const char *a2, ...)
{
  return [a1 deactivateAllApps];
}

id objc_msgSend_deactivateExpressConfig(void *a1, const char *a2, ...)
{
  return [a1 deactivateExpressConfig];
}

id objc_msgSend_debugDescription(void *a1, const char *a2, ...)
{
  return [a1 debugDescription];
}

id objc_msgSend_decimalValue(void *a1, const char *a2, ...)
{
  return [a1 decimalValue];
}

id objc_msgSend_decode(void *a1, const char *a2, ...)
{
  return [a1 decode];
}

id objc_msgSend_defaultAppIdentifier(void *a1, const char *a2, ...)
{
  return [a1 defaultAppIdentifier];
}

id objc_msgSend_defaultCenter(void *a1, const char *a2, ...)
{
  return [a1 defaultCenter];
}

id objc_msgSend_defaultEmulationType(void *a1, const char *a2, ...)
{
  return [a1 defaultEmulationType];
}

id objc_msgSend_defaultManager(void *a1, const char *a2, ...)
{
  return [a1 defaultManager];
}

id objc_msgSend_defaultSetting(void *a1, const char *a2, ...)
{
  return [a1 defaultSetting];
}

id objc_msgSend_defaultWiredModeApplet(void *a1, const char *a2, ...)
{
  return [a1 defaultWiredModeApplet];
}

id objc_msgSend_defaultWorkspace(void *a1, const char *a2, ...)
{
  return [a1 defaultWorkspace];
}

id objc_msgSend_defaults(void *a1, const char *a2, ...)
{
  return [a1 defaults];
}

id objc_msgSend_deferredActivationApplet(void *a1, const char *a2, ...)
{
  return [a1 deferredActivationApplet];
}

id objc_msgSend_delegate(void *a1, const char *a2, ...)
{
  return [a1 delegate];
}

id objc_msgSend_dequeueDate(void *a1, const char *a2, ...)
{
  return [a1 dequeueDate];
}

id objc_msgSend_description(void *a1, const char *a2, ...)
{
  return [a1 description];
}

id objc_msgSend_descriptor(void *a1, const char *a2, ...)
{
  return [a1 descriptor];
}

id objc_msgSend_deselectInstance(void *a1, const char *a2, ...)
{
  return [a1 deselectInstance];
}

id objc_msgSend_developerType(void *a1, const char *a2, ...)
{
  return [a1 developerType];
}

id objc_msgSend_deviceHandoverSelectError(void *a1, const char *a2, ...)
{
  return [a1 deviceHandoverSelectError];
}

id objc_msgSend_deviceType(void *a1, const char *a2, ...)
{
  return [a1 deviceType];
}

id objc_msgSend_dictionary(void *a1, const char *a2, ...)
{
  return [a1 dictionary];
}

id objc_msgSend_dictionaryRepresentation(void *a1, const char *a2, ...)
{
  return [a1 dictionaryRepresentation];
}

id objc_msgSend_didConnectToReader(void *a1, const char *a2, ...)
{
  return [a1 didConnectToReader];
}

id objc_msgSend_didDetectExternalReader(void *a1, const char *a2, ...)
{
  return [a1 didDetectExternalReader];
}

id objc_msgSend_didDisconnectFromReader(void *a1, const char *a2, ...)
{
  return [a1 didDisconnectFromReader];
}

id objc_msgSend_didEnd(void *a1, const char *a2, ...)
{
  return [a1 didEnd];
}

id objc_msgSend_didError(void *a1, const char *a2, ...)
{
  return [a1 didError];
}

id objc_msgSend_didFailDeferredAuthorization(void *a1, const char *a2, ...)
{
  return [a1 didFailDeferredAuthorization];
}

id objc_msgSend_didReceivePendingServerRequest(void *a1, const char *a2, ...)
{
  return [a1 didReceivePendingServerRequest];
}

id objc_msgSend_didStart(void *a1, const char *a2, ...)
{
  return [a1 didStart];
}

id objc_msgSend_disableAutoStartOnField(void *a1, const char *a2, ...)
{
  return [a1 disableAutoStartOnField];
}

id objc_msgSend_disableCompletionNotification(void *a1, const char *a2, ...)
{
  return [a1 disableCompletionNotification];
}

id objc_msgSend_disconnect(void *a1, const char *a2, ...)
{
  return [a1 disconnect];
}

id objc_msgSend_discretionaryData(void *a1, const char *a2, ...)
{
  return [a1 discretionaryData];
}

id objc_msgSend_displayBacklightLevel(void *a1, const char *a2, ...)
{
  return [a1 displayBacklightLevel];
}

id objc_msgSend_distantFuture(void *a1, const char *a2, ...)
{
  return [a1 distantFuture];
}

id objc_msgSend_domain(void *a1, const char *a2, ...)
{
  return [a1 domain];
}

id objc_msgSend_dontResetAssertion(void *a1, const char *a2, ...)
{
  return [a1 dontResetAssertion];
}

id objc_msgSend_dontWaitForEOT(void *a1, const char *a2, ...)
{
  return [a1 dontWaitForEOT];
}

id objc_msgSend_doubleClickEnable(void *a1, const char *a2, ...)
{
  return [a1 doubleClickEnable];
}

id objc_msgSend_doubleValue(void *a1, const char *a2, ...)
{
  return [a1 doubleValue];
}

id objc_msgSend_driver(void *a1, const char *a2, ...)
{
  return [a1 driver];
}

id objc_msgSend_driverExpressModeExited(void *a1, const char *a2, ...)
{
  return [a1 driverExpressModeExited];
}

id objc_msgSend_driverFieldEntered(void *a1, const char *a2, ...)
{
  return [a1 driverFieldEntered];
}

id objc_msgSend_driverFieldExited(void *a1, const char *a2, ...)
{
  return [a1 driverFieldExited];
}

id objc_msgSend_driverPLLUnlock(void *a1, const char *a2, ...)
{
  return [a1 driverPLLUnlock];
}

id objc_msgSend_driverRestartDiscovery(void *a1, const char *a2, ...)
{
  return [a1 driverRestartDiscovery];
}

id objc_msgSend_driverWrapper(void *a1, const char *a2, ...)
{
  return [a1 driverWrapper];
}

id objc_msgSend_dumpState(void *a1, const char *a2, ...)
{
  return [a1 dumpState];
}

id objc_msgSend_eCommerceAccess(void *a1, const char *a2, ...)
{
  return [a1 eCommerceAccess];
}

id objc_msgSend_eccCertificate(void *a1, const char *a2, ...)
{
  return [a1 eccCertificate];
}

id objc_msgSend_ecdsaCertificate(void *a1, const char *a2, ...)
{
  return [a1 ecdsaCertificate];
}

id objc_msgSend_eckaCertificate(void *a1, const char *a2, ...)
{
  return [a1 eckaCertificate];
}

id objc_msgSend_ecpBroadcastConfig(void *a1, const char *a2, ...)
{
  return [a1 ecpBroadcastConfig];
}

id objc_msgSend_effectiveECPFrame(void *a1, const char *a2, ...)
{
  return [a1 effectiveECPFrame];
}

id objc_msgSend_embeddedMode(void *a1, const char *a2, ...)
{
  return [a1 embeddedMode];
}

id objc_msgSend_embeddedSecureElementWrapper(void *a1, const char *a2, ...)
{
  return [a1 embeddedSecureElementWrapper];
}

id objc_msgSend_embeddedWiredMode(void *a1, const char *a2, ...)
{
  return [a1 embeddedWiredMode];
}

id objc_msgSend_embeddedWiredModeWithHCE(void *a1, const char *a2, ...)
{
  return [a1 embeddedWiredModeWithHCE];
}

id objc_msgSend_emulationOnSessionStart(void *a1, const char *a2, ...)
{
  return [a1 emulationOnSessionStart];
}

id objc_msgSend_endowmentNamespaces(void *a1, const char *a2, ...)
{
  return [a1 endowmentNamespaces];
}

id objc_msgSend_exportedInterface(void *a1, const char *a2, ...)
{
  return [a1 exportedInterface];
}

id objc_msgSend_expressModeManager(void *a1, const char *a2, ...)
{
  return [a1 expressModeManager];
}

id objc_msgSend_expressOnly(void *a1, const char *a2, ...)
{
  return [a1 expressOnly];
}

id objc_msgSend_externalReaderAccessAllow(void *a1, const char *a2, ...)
{
  return [a1 externalReaderAccessAllow];
}

id objc_msgSend_failForwardCompleted(void *a1, const char *a2, ...)
{
  return [a1 failForwardCompleted];
}

id objc_msgSend_fdOn(void *a1, const char *a2, ...)
{
  return [a1 fdOn];
}

id objc_msgSend_feliCaSystemCodeList(void *a1, const char *a2, ...)
{
  return [a1 feliCaSystemCodeList];
}

id objc_msgSend_felicaInfo(void *a1, const char *a2, ...)
{
  return [a1 felicaInfo];
}

id objc_msgSend_fetchFromStorage(void *a1, const char *a2, ...)
{
  return [a1 fetchFromStorage];
}

id objc_msgSend_fieldDetectRequested(void *a1, const char *a2, ...)
{
  return [a1 fieldDetectRequested];
}

id objc_msgSend_fieldDetectSessionClientNames(void *a1, const char *a2, ...)
{
  return [a1 fieldDetectSessionClientNames];
}

id objc_msgSend_fieldDetectSessions(void *a1, const char *a2, ...)
{
  return [a1 fieldDetectSessions];
}

id objc_msgSend_fieldDetectType(void *a1, const char *a2, ...)
{
  return [a1 fieldDetectType];
}

id objc_msgSend_fieldHandlingInSuspension(void *a1, const char *a2, ...)
{
  return [a1 fieldHandlingInSuspension];
}

id objc_msgSend_fieldPresent(void *a1, const char *a2, ...)
{
  return [a1 fieldPresent];
}

id objc_msgSend_firmwareVersion(void *a1, const char *a2, ...)
{
  return [a1 firmwareVersion];
}

id objc_msgSend_firstFieldNotification(void *a1, const char *a2, ...)
{
  return [a1 firstFieldNotification];
}

id objc_msgSend_firstFieldNotificationTimer(void *a1, const char *a2, ...)
{
  return [a1 firstFieldNotificationTimer];
}

id objc_msgSend_firstObject(void *a1, const char *a2, ...)
{
  return [a1 firstObject];
}

id objc_msgSend_floatValue(void *a1, const char *a2, ...)
{
  return [a1 floatValue];
}

id objc_msgSend_forceExpressExit(void *a1, const char *a2, ...)
{
  return [a1 forceExpressExit];
}

id objc_msgSend_fragment(void *a1, const char *a2, ...)
{
  return [a1 fragment];
}

id objc_msgSend_generateDailyUUIDForCA(void *a1, const char *a2, ...)
{
  return [a1 generateDailyUUIDForCA];
}

id objc_msgSend_generateUUID(void *a1, const char *a2, ...)
{
  return [a1 generateUUID];
}

id objc_msgSend_getAppInfoDictionary(void *a1, const char *a2, ...)
{
  return [a1 getAppInfoDictionary];
}

id objc_msgSend_getBatteryPercent(void *a1, const char *a2, ...)
{
  return [a1 getBatteryPercent];
}

id objc_msgSend_getCALoggerUserDefaults(void *a1, const char *a2, ...)
{
  return [a1 getCALoggerUserDefaults];
}

id objc_msgSend_getCHConfig(void *a1, const char *a2, ...)
{
  return [a1 getCHConfig];
}

id objc_msgSend_getCooloffTime(void *a1, const char *a2, ...)
{
  return [a1 getCooloffTime];
}

id objc_msgSend_getDieID(void *a1, const char *a2, ...)
{
  return [a1 getDieID];
}

id objc_msgSend_getECPFrame(void *a1, const char *a2, ...)
{
  return [a1 getECPFrame];
}

id objc_msgSend_getIndexFromLocale(void *a1, const char *a2, ...)
{
  return [a1 getIndexFromLocale];
}

id objc_msgSend_getLPMControl(void *a1, const char *a2, ...)
{
  return [a1 getLPMControl];
}

id objc_msgSend_getNFCSettings(void *a1, const char *a2, ...)
{
  return [a1 getNFCSettings];
}

id objc_msgSend_getPairingVersion(void *a1, const char *a2, ...)
{
  return [a1 getPairingVersion];
}

id objc_msgSend_getPrimaryHardwareState(void *a1, const char *a2, ...)
{
  return [a1 getPrimaryHardwareState];
}

id objc_msgSend_getSTSHelperOperation(void *a1, const char *a2, ...)
{
  return [a1 getSTSHelperOperation];
}

id objc_msgSend_getSecureElementWrapper(void *a1, const char *a2, ...)
{
  return [a1 getSecureElementWrapper];
}

id objc_msgSend_getSecureElementWrapperAndSetRouting(void *a1, const char *a2, ...)
{
  return [a1 getSecureElementWrapperAndSetRouting];
}

id objc_msgSend_getStateDumpInfo(void *a1, const char *a2, ...)
{
  return [a1 getStateDumpInfo];
}

id objc_msgSend_getTimestamp(void *a1, const char *a2, ...)
{
  return [a1 getTimestamp];
}

id objc_msgSend_getTransactionEvent(void *a1, const char *a2, ...)
{
  return [a1 getTransactionEvent];
}

id objc_msgSend_globalUnmountCOX(void *a1, const char *a2, ...)
{
  return [a1 globalUnmountCOX];
}

id objc_msgSend_groupActivationStyle(void *a1, const char *a2, ...)
{
  return [a1 groupActivationStyle];
}

id objc_msgSend_groupHeadID(void *a1, const char *a2, ...)
{
  return [a1 groupHeadID];
}

id objc_msgSend_groupMemberIDs(void *a1, const char *a2, ...)
{
  return [a1 groupMemberIDs];
}

id objc_msgSend_handle(void *a1, const char *a2, ...)
{
  return [a1 handle];
}

id objc_msgSend_handleDeferredAuthTimeout(void *a1, const char *a2, ...)
{
  return [a1 handleDeferredAuthTimeout];
}

id objc_msgSend_handleDeselect(void *a1, const char *a2, ...)
{
  return [a1 handleDeselect];
}

id objc_msgSend_handleEMVCOCollisionDetected(void *a1, const char *a2, ...)
{
  return [a1 handleEMVCOCollisionDetected];
}

id objc_msgSend_handleEraseCounterExceeded(void *a1, const char *a2, ...)
{
  return [a1 handleEraseCounterExceeded];
}

id objc_msgSend_handleExpressModeExited(void *a1, const char *a2, ...)
{
  return [a1 handleExpressModeExited];
}

id objc_msgSend_handleExpressModeStarted(void *a1, const char *a2, ...)
{
  return [a1 handleExpressModeStarted];
}

id objc_msgSend_handleExpressModeTimeout(void *a1, const char *a2, ...)
{
  return [a1 handleExpressModeTimeout];
}

id objc_msgSend_handleFailForwardCompleted(void *a1, const char *a2, ...)
{
  return [a1 handleFailForwardCompleted];
}

id objc_msgSend_handleFieldReset(void *a1, const char *a2, ...)
{
  return [a1 handleFieldReset];
}

id objc_msgSend_handleForceExpressModeEndEvent(void *a1, const char *a2, ...)
{
  return [a1 handleForceExpressModeEndEvent];
}

id objc_msgSend_handleHWRecoveryStarted(void *a1, const char *a2, ...)
{
  return [a1 handleHWRecoveryStarted];
}

id objc_msgSend_handleHceTargetLost(void *a1, const char *a2, ...)
{
  return [a1 handleHceTargetLost];
}

id objc_msgSend_handleNdefTagRead(void *a1, const char *a2, ...)
{
  return [a1 handleNdefTagRead];
}

id objc_msgSend_handlePLLUnlock(void *a1, const char *a2, ...)
{
  return [a1 handlePLLUnlock];
}

id objc_msgSend_handlePendingServerRequest(void *a1, const char *a2, ...)
{
  return [a1 handlePendingServerRequest];
}

id objc_msgSend_handleReaderBurnoutCleared(void *a1, const char *a2, ...)
{
  return [a1 handleReaderBurnoutCleared];
}

id objc_msgSend_handleReaderBurnoutTimer(void *a1, const char *a2, ...)
{
  return [a1 handleReaderBurnoutTimer];
}

id objc_msgSend_handleRestartDiscovery(void *a1, const char *a2, ...)
{
  return [a1 handleRestartDiscovery];
}

id objc_msgSend_handleSecureElementEndOfOperation(void *a1, const char *a2, ...)
{
  return [a1 handleSecureElementEndOfOperation];
}

id objc_msgSend_handleSessionResumed(void *a1, const char *a2, ...)
{
  return [a1 handleSessionResumed];
}

id objc_msgSend_handleStackLoad(void *a1, const char *a2, ...)
{
  return [a1 handleStackLoad];
}

id objc_msgSend_handleStackUnload(void *a1, const char *a2, ...)
{
  return [a1 handleStackUnload];
}

id objc_msgSend_hardwareVersion(void *a1, const char *a2, ...)
{
  return [a1 hardwareVersion];
}

id objc_msgSend_hasAntenna(void *a1, const char *a2, ...)
{
  return [a1 hasAntenna];
}

id objc_msgSend_hasAppleLPM(void *a1, const char *a2, ...)
{
  return [a1 hasAppleLPM];
}

id objc_msgSend_hasError(void *a1, const char *a2, ...)
{
  return [a1 hasError];
}

id objc_msgSend_hasLPEMSupport(void *a1, const char *a2, ...)
{
  return [a1 hasLPEMSupport];
}

id objc_msgSend_hasMultiOS(void *a1, const char *a2, ...)
{
  return [a1 hasMultiOS];
}

id objc_msgSend_hasReaderModeSupport(void *a1, const char *a2, ...)
{
  return [a1 hasReaderModeSupport];
}

id objc_msgSend_hasSentRAPDU(void *a1, const char *a2, ...)
{
  return [a1 hasSentRAPDU];
}

id objc_msgSend_hasSession(void *a1, const char *a2, ...)
{
  return [a1 hasSession];
}

id objc_msgSend_hasTransactionEnded(void *a1, const char *a2, ...)
{
  return [a1 hasTransactionEnded];
}

id objc_msgSend_hash(void *a1, const char *a2, ...)
{
  return [a1 hash];
}

id objc_msgSend_hceAccess(void *a1, const char *a2, ...)
{
  return [a1 hceAccess];
}

id objc_msgSend_headlessTimerLogic(void *a1, const char *a2, ...)
{
  return [a1 headlessTimerLogic];
}

id objc_msgSend_historicalBytes(void *a1, const char *a2, ...)
{
  return [a1 historicalBytes];
}

id objc_msgSend_holdAssertion(void *a1, const char *a2, ...)
{
  return [a1 holdAssertion];
}

id objc_msgSend_homeKitSchemeDataPayload(void *a1, const char *a2, ...)
{
  return [a1 homeKitSchemeDataPayload];
}

id objc_msgSend_homed(void *a1, const char *a2, ...)
{
  return [a1 homed];
}

id objc_msgSend_host(void *a1, const char *a2, ...)
{
  return [a1 host];
}

id objc_msgSend_hostCardEmulation(void *a1, const char *a2, ...)
{
  return [a1 hostCardEmulation];
}

id objc_msgSend_hostCardEmulationLog(void *a1, const char *a2, ...)
{
  return [a1 hostCardEmulationLog];
}

id objc_msgSend_hostCards(void *a1, const char *a2, ...)
{
  return [a1 hostCards];
}

id objc_msgSend_hostMode(void *a1, const char *a2, ...)
{
  return [a1 hostMode];
}

id objc_msgSend_identifier(void *a1, const char *a2, ...)
{
  return [a1 identifier];
}

id objc_msgSend_identifierAsData(void *a1, const char *a2, ...)
{
  return [a1 identifierAsData];
}

id objc_msgSend_ignoreAppStateMonitor(void *a1, const char *a2, ...)
{
  return [a1 ignoreAppStateMonitor];
}

id objc_msgSend_ignoreRFTechOnIsEqual(void *a1, const char *a2, ...)
{
  return [a1 ignoreRFTechOnIsEqual];
}

id objc_msgSend_includeAPDUDuration(void *a1, const char *a2, ...)
{
  return [a1 includeAPDUDuration];
}

id objc_msgSend_info(void *a1, const char *a2, ...)
{
  return [a1 info];
}

id objc_msgSend_informative(void *a1, const char *a2, ...)
{
  return [a1 informative];
}

id objc_msgSend_initSETransactionsStates(void *a1, const char *a2, ...)
{
  return [a1 initSETransactionsStates];
}

id objc_msgSend_initialECPConfig(void *a1, const char *a2, ...)
{
  return [a1 initialECPConfig];
}

id objc_msgSend_initialRoutingConfig(void *a1, const char *a2, ...)
{
  return [a1 initialRoutingConfig];
}

id objc_msgSend_initialScanText(void *a1, const char *a2, ...)
{
  return [a1 initialScanText];
}

id objc_msgSend_initialSelectBeforeRun(void *a1, const char *a2, ...)
{
  return [a1 initialSelectBeforeRun];
}

id objc_msgSend_initialUIText(void *a1, const char *a2, ...)
{
  return [a1 initialUIText];
}

id objc_msgSend_instanceACL(void *a1, const char *a2, ...)
{
  return [a1 instanceACL];
}

id objc_msgSend_instanceAID(void *a1, const char *a2, ...)
{
  return [a1 instanceAID];
}

id objc_msgSend_instruction(void *a1, const char *a2, ...)
{
  return [a1 instruction];
}

id objc_msgSend_intValue(void *a1, const char *a2, ...)
{
  return [a1 intValue];
}

id objc_msgSend_integerValue(void *a1, const char *a2, ...)
{
  return [a1 integerValue];
}

id objc_msgSend_interface(void *a1, const char *a2, ...)
{
  return [a1 interface];
}

id objc_msgSend_internalAccess(void *a1, const char *a2, ...)
{
  return [a1 internalAccess];
}

id objc_msgSend_invalidate(void *a1, const char *a2, ...)
{
  return [a1 invalidate];
}

id objc_msgSend_isActive(void *a1, const char *a2, ...)
{
  return [a1 isActive];
}

id objc_msgSend_isAuthRandomEntangled(void *a1, const char *a2, ...)
{
  return [a1 isAuthRandomEntangled];
}

id objc_msgSend_isCHTerminal(void *a1, const char *a2, ...)
{
  return [a1 isCHTerminal];
}

id objc_msgSend_isComplete(void *a1, const char *a2, ...)
{
  return [a1 isComplete];
}

id objc_msgSend_isContainer(void *a1, const char *a2, ...)
{
  return [a1 isContainer];
}

id objc_msgSend_isDirty(void *a1, const char *a2, ...)
{
  return [a1 isDirty];
}

id objc_msgSend_isEligible(void *a1, const char *a2, ...)
{
  return [a1 isEligible];
}

id objc_msgSend_isEligibleForDoubleClick(void *a1, const char *a2, ...)
{
  return [a1 isEligibleForDoubleClick];
}

id objc_msgSend_isEmpty(void *a1, const char *a2, ...)
{
  return [a1 isEmpty];
}

id objc_msgSend_isEnding(void *a1, const char *a2, ...)
{
  return [a1 isEnding];
}

id objc_msgSend_isFirstInQueue(void *a1, const char *a2, ...)
{
  return [a1 isFirstInQueue];
}

id objc_msgSend_isGPLocked(void *a1, const char *a2, ...)
{
  return [a1 isGPLocked];
}

id objc_msgSend_isGetVasDataCommand(void *a1, const char *a2, ...)
{
  return [a1 isGetVasDataCommand];
}

id objc_msgSend_isInstanceSelected(void *a1, const char *a2, ...)
{
  return [a1 isInstanceSelected];
}

id objc_msgSend_isNFCAllowed(void *a1, const char *a2, ...)
{
  return [a1 isNFCAllowed];
}

id objc_msgSend_isOperational(void *a1, const char *a2, ...)
{
  return [a1 isOperational];
}

id objc_msgSend_isProxy(void *a1, const char *a2, ...)
{
  return [a1 isProxy];
}

id objc_msgSend_isRecoveryInProgress(void *a1, const char *a2, ...)
{
  return [a1 isRecoveryInProgress];
}

id objc_msgSend_isSEOperational(void *a1, const char *a2, ...)
{
  return [a1 isSEOperational];
}

id objc_msgSend_isSecureMessaging(void *a1, const char *a2, ...)
{
  return [a1 isSecureMessaging];
}

id objc_msgSend_isSelectByDFNameCommand(void *a1, const char *a2, ...)
{
  return [a1 isSelectByDFNameCommand];
}

id objc_msgSend_isSelectCommand(void *a1, const char *a2, ...)
{
  return [a1 isSelectCommand];
}

id objc_msgSend_isSessionSEOnly(void *a1, const char *a2, ...)
{
  return [a1 isSessionSEOnly];
}

id objc_msgSend_isSilent(void *a1, const char *a2, ...)
{
  return [a1 isSilent];
}

id objc_msgSend_isSupported(void *a1, const char *a2, ...)
{
  return [a1 isSupported];
}

id objc_msgSend_isSuspended(void *a1, const char *a2, ...)
{
  return [a1 isSuspended];
}

id objc_msgSend_isTypeF(void *a1, const char *a2, ...)
{
  return [a1 isTypeF];
}

id objc_msgSend_isURIRecord(void *a1, const char *a2, ...)
{
  return [a1 isURIRecord];
}

id objc_msgSend_isWalletAttached(void *a1, const char *a2, ...)
{
  return [a1 isWalletAttached];
}

id objc_msgSend_iso7816AppList(void *a1, const char *a2, ...)
{
  return [a1 iso7816AppList];
}

id objc_msgSend_jcopSupportsEntanglement(void *a1, const char *a2, ...)
{
  return [a1 jcopSupportsEntanglement];
}

id objc_msgSend_jcopSupportsPerBootAuthKeys(void *a1, const char *a2, ...)
{
  return [a1 jcopSupportsPerBootAuthKeys];
}

id objc_msgSend_key(void *a1, const char *a2, ...)
{
  return [a1 key];
}

id objc_msgSend_keyAttestation(void *a1, const char *a2, ...)
{
  return [a1 keyAttestation];
}

id objc_msgSend_keyAttestationAuthority(void *a1, const char *a2, ...)
{
  return [a1 keyAttestationAuthority];
}

id objc_msgSend_keyEnumerator(void *a1, const char *a2, ...)
{
  return [a1 keyEnumerator];
}

id objc_msgSend_keyIdentifier(void *a1, const char *a2, ...)
{
  return [a1 keyIdentifier];
}

id objc_msgSend_keys(void *a1, const char *a2, ...)
{
  return [a1 keys];
}

id objc_msgSend_kickRTCTimer(void *a1, const char *a2, ...)
{
  return [a1 kickRTCTimer];
}

id objc_msgSend_lastKnownRoutingConfig(void *a1, const char *a2, ...)
{
  return [a1 lastKnownRoutingConfig];
}

id objc_msgSend_lastObject(void *a1, const char *a2, ...)
{
  return [a1 lastObject];
}

id objc_msgSend_length(void *a1, const char *a2, ...)
{
  return [a1 length];
}

id objc_msgSend_lengthExpected(void *a1, const char *a2, ...)
{
  return [a1 lengthExpected];
}

id objc_msgSend_lifecycleState(void *a1, const char *a2, ...)
{
  return [a1 lifecycleState];
}

id objc_msgSend_loadCustomDefaults(void *a1, const char *a2, ...)
{
  return [a1 loadCustomDefaults];
}

id objc_msgSend_loadDefaultValues(void *a1, const char *a2, ...)
{
  return [a1 loadDefaultValues];
}

id objc_msgSend_localTimeZone(void *a1, const char *a2, ...)
{
  return [a1 localTimeZone];
}

id objc_msgSend_localValidations(void *a1, const char *a2, ...)
{
  return [a1 localValidations];
}

id objc_msgSend_localeChanged(void *a1, const char *a2, ...)
{
  return [a1 localeChanged];
}

id objc_msgSend_localizedDescription(void *a1, const char *a2, ...)
{
  return [a1 localizedDescription];
}

id objc_msgSend_lock(void *a1, const char *a2, ...)
{
  return [a1 lock];
}

id objc_msgSend_logsTransactionDetails(void *a1, const char *a2, ...)
{
  return [a1 logsTransactionDetails];
}

id objc_msgSend_longLongValue(void *a1, const char *a2, ...)
{
  return [a1 longLongValue];
}

id objc_msgSend_longValue(void *a1, const char *a2, ...)
{
  return [a1 longValue];
}

id objc_msgSend_lowercaseString(void *a1, const char *a2, ...)
{
  return [a1 lowercaseString];
}

id objc_msgSend_lpcdEcpFrame(void *a1, const char *a2, ...)
{
  return [a1 lpcdEcpFrame];
}

id objc_msgSend_lpemConfigSessionAccess(void *a1, const char *a2, ...)
{
  return [a1 lpemConfigSessionAccess];
}

id objc_msgSend_lpmFactoryTest(void *a1, const char *a2, ...)
{
  return [a1 lpmFactoryTest];
}

id objc_msgSend_map(void *a1, const char *a2, ...)
{
  return [a1 map];
}

id objc_msgSend_maxMessageSize(void *a1, const char *a2, ...)
{
  return [a1 maxMessageSize];
}

id objc_msgSend_maxOperationTimeSpan(void *a1, const char *a2, ...)
{
  return [a1 maxOperationTimeSpan];
}

id objc_msgSend_maxReaderTime(void *a1, const char *a2, ...)
{
  return [a1 maxReaderTime];
}

id objc_msgSend_maxWaitTimeExtension(void *a1, const char *a2, ...)
{
  return [a1 maxWaitTimeExtension];
}

id objc_msgSend_maybeStartNextSession(void *a1, const char *a2, ...)
{
  return [a1 maybeStartNextSession];
}

id objc_msgSend_merchantCapabilities(void *a1, const char *a2, ...)
{
  return [a1 merchantCapabilities];
}

id objc_msgSend_merchantData(void *a1, const char *a2, ...)
{
  return [a1 merchantData];
}

id objc_msgSend_merchantId(void *a1, const char *a2, ...)
{
  return [a1 merchantId];
}

id objc_msgSend_middlewareVersion(void *a1, const char *a2, ...)
{
  return [a1 middlewareVersion];
}

id objc_msgSend_migrateFromDefaults(void *a1, const char *a2, ...)
{
  return [a1 migrateFromDefaults];
}

id objc_msgSend_migrationContext(void *a1, const char *a2, ...)
{
  return [a1 migrationContext];
}

id objc_msgSend_migrationInstances(void *a1, const char *a2, ...)
{
  return [a1 migrationInstances];
}

id objc_msgSend_migrationPackages(void *a1, const char *a2, ...)
{
  return [a1 migrationPackages];
}

id objc_msgSend_migrationState(void *a1, const char *a2, ...)
{
  return [a1 migrationState];
}

id objc_msgSend_minWaitTime(void *a1, const char *a2, ...)
{
  return [a1 minWaitTime];
}

id objc_msgSend_miniNVWriteAccess(void *a1, const char *a2, ...)
{
  return [a1 miniNVWriteAccess];
}

id objc_msgSend_moduleIdentifier(void *a1, const char *a2, ...)
{
  return [a1 moduleIdentifier];
}

id objc_msgSend_month(void *a1, const char *a2, ...)
{
  return [a1 month];
}

id objc_msgSend_multiSEGroupMemberIDs(void *a1, const char *a2, ...)
{
  return [a1 multiSEGroupMemberIDs];
}

id objc_msgSend_mutableBytes(void *a1, const char *a2, ...)
{
  return [a1 mutableBytes];
}

id objc_msgSend_mutableCopy(void *a1, const char *a2, ...)
{
  return [a1 mutableCopy];
}

id objc_msgSend_needsCleanup(void *a1, const char *a2, ...)
{
  return [a1 needsCleanup];
}

id objc_msgSend_negotiatePerBootAuthKeys(void *a1, const char *a2, ...)
{
  return [a1 negotiatePerBootAuthKeys];
}

id objc_msgSend_networkMerchantIdentifier(void *a1, const char *a2, ...)
{
  return [a1 networkMerchantIdentifier];
}

id objc_msgSend_nextObject(void *a1, const char *a2, ...)
{
  return [a1 nextObject];
}

id objc_msgSend_nextRetryTime(void *a1, const char *a2, ...)
{
  return [a1 nextRetryTime];
}

id objc_msgSend_nfcCardSessionAIDPrefixList(void *a1, const char *a2, ...)
{
  return [a1 nfcCardSessionAIDPrefixList];
}

id objc_msgSend_nfcCardSessionAccess(void *a1, const char *a2, ...)
{
  return [a1 nfcCardSessionAccess];
}

id objc_msgSend_nfcISO15693ReaderAccess(void *a1, const char *a2, ...)
{
  return [a1 nfcISO15693ReaderAccess];
}

id objc_msgSend_nfcNDEFReaderAccess(void *a1, const char *a2, ...)
{
  return [a1 nfcNDEFReaderAccess];
}

id objc_msgSend_nfcTagReaderAccess(void *a1, const char *a2, ...)
{
  return [a1 nfcTagReaderAccess];
}

id objc_msgSend_nfcTagReaderPACEPollingAllow(void *a1, const char *a2, ...)
{
  return [a1 nfcTagReaderPACEPollingAllow];
}

id objc_msgSend_nfcVASReaderAccess(void *a1, const char *a2, ...)
{
  return [a1 nfcVASReaderAccess];
}

id objc_msgSend_nonce(void *a1, const char *a2, ...)
{
  return [a1 nonce];
}

id objc_msgSend_none(void *a1, const char *a2, ...)
{
  return [a1 none];
}

id objc_msgSend_notANumber(void *a1, const char *a2, ...)
{
  return [a1 notANumber];
}

id objc_msgSend_notificationCategories(void *a1, const char *a2, ...)
{
  return [a1 notificationCategories];
}

id objc_msgSend_notificationConfig(void *a1, const char *a2, ...)
{
  return [a1 notificationConfig];
}

id objc_msgSend_notificationType(void *a1, const char *a2, ...)
{
  return [a1 notificationType];
}

id objc_msgSend_notifyPresentmentFieldExit(void *a1, const char *a2, ...)
{
  return [a1 notifyPresentmentFieldExit];
}

id objc_msgSend_notifyReaderModeActivityEnd(void *a1, const char *a2, ...)
{
  return [a1 notifyReaderModeActivityEnd];
}

id objc_msgSend_notifyReaderModeActivityStart(void *a1, const char *a2, ...)
{
  return [a1 notifyReaderModeActivityStart];
}

id objc_msgSend_now(void *a1, const char *a2, ...)
{
  return [a1 now];
}

id objc_msgSend_null(void *a1, const char *a2, ...)
{
  return [a1 null];
}

id objc_msgSend_odaRequired(void *a1, const char *a2, ...)
{
  return [a1 odaRequired];
}

id objc_msgSend_one(void *a1, const char *a2, ...)
{
  return [a1 one];
}

id objc_msgSend_openLoopSchemeBitfield(void *a1, const char *a2, ...)
{
  return [a1 openLoopSchemeBitfield];
}

id objc_msgSend_orderedSet(void *a1, const char *a2, ...)
{
  return [a1 orderedSet];
}

id objc_msgSend_owners(void *a1, const char *a2, ...)
{
  return [a1 owners];
}

id objc_msgSend_p1(void *a1, const char *a2, ...)
{
  return [a1 p1];
}

id objc_msgSend_p2(void *a1, const char *a2, ...)
{
  return [a1 p2];
}

id objc_msgSend_packageIdentifier(void *a1, const char *a2, ...)
{
  return [a1 packageIdentifier];
}

id objc_msgSend_pairedState(void *a1, const char *a2, ...)
{
  return [a1 pairedState];
}

id objc_msgSend_pairingMode(void *a1, const char *a2, ...)
{
  return [a1 pairingMode];
}

id objc_msgSend_parentToken(void *a1, const char *a2, ...)
{
  return [a1 parentToken];
}

id objc_msgSend_parsedInfo(void *a1, const char *a2, ...)
{
  return [a1 parsedInfo];
}

id objc_msgSend_password(void *a1, const char *a2, ...)
{
  return [a1 password];
}

id objc_msgSend_path(void *a1, const char *a2, ...)
{
  return [a1 path];
}

id objc_msgSend_payload(void *a1, const char *a2, ...)
{
  return [a1 payload];
}

id objc_msgSend_payloadBytes(void *a1, const char *a2, ...)
{
  return [a1 payloadBytes];
}

id objc_msgSend_payloadLength(void *a1, const char *a2, ...)
{
  return [a1 payloadLength];
}

id objc_msgSend_paymentAIDPrefixes(void *a1, const char *a2, ...)
{
  return [a1 paymentAIDPrefixes];
}

id objc_msgSend_paymentResponse(void *a1, const char *a2, ...)
{
  return [a1 paymentResponse];
}

id objc_msgSend_performSharing(void *a1, const char *a2, ...)
{
  return [a1 performSharing];
}

id objc_msgSend_persistentConfigID(void *a1, const char *a2, ...)
{
  return [a1 persistentConfigID];
}

id objc_msgSend_persistentFieldDetectClients(void *a1, const char *a2, ...)
{
  return [a1 persistentFieldDetectClients];
}

id objc_msgSend_persistentObserverNames(void *a1, const char *a2, ...)
{
  return [a1 persistentObserverNames];
}

id objc_msgSend_pid(void *a1, const char *a2, ...)
{
  return [a1 pid];
}

id objc_msgSend_plasticCardMode(void *a1, const char *a2, ...)
{
  return [a1 plasticCardMode];
}

id objc_msgSend_platformIdentifier(void *a1, const char *a2, ...)
{
  return [a1 platformIdentifier];
}

id objc_msgSend_pointerValue(void *a1, const char *a2, ...)
{
  return [a1 pointerValue];
}

id objc_msgSend_polling(void *a1, const char *a2, ...)
{
  return [a1 polling];
}

id objc_msgSend_pollingDuration(void *a1, const char *a2, ...)
{
  return [a1 pollingDuration];
}

id objc_msgSend_pollingProfileUpdate(void *a1, const char *a2, ...)
{
  return [a1 pollingProfileUpdate];
}

id objc_msgSend_pollingType(void *a1, const char *a2, ...)
{
  return [a1 pollingType];
}

id objc_msgSend_port(void *a1, const char *a2, ...)
{
  return [a1 port];
}

id objc_msgSend_postAnalyticsGeneralTransactionStatistics(void *a1, const char *a2, ...)
{
  return [a1 postAnalyticsGeneralTransactionStatistics];
}

id objc_msgSend_postGeneralDeviceStatistics(void *a1, const char *a2, ...)
{
  return [a1 postGeneralDeviceStatistics];
}

id objc_msgSend_powerAssertionIdentifier(void *a1, const char *a2, ...)
{
  return [a1 powerAssertionIdentifier];
}

id objc_msgSend_powerConsumptionReporter(void *a1, const char *a2, ...)
{
  return [a1 powerConsumptionReporter];
}

id objc_msgSend_powerCycleOrReset(void *a1, const char *a2, ...)
{
  return [a1 powerCycleOrReset];
}

id objc_msgSend_poweredRunDuringSleep(void *a1, const char *a2, ...)
{
  return [a1 poweredRunDuringSleep];
}

id objc_msgSend_preferredLanguages(void *a1, const char *a2, ...)
{
  return [a1 preferredLanguages];
}

id objc_msgSend_preloadApplets(void *a1, const char *a2, ...)
{
  return [a1 preloadApplets];
}

id objc_msgSend_primitiveLocalValidation(void *a1, const char *a2, ...)
{
  return [a1 primitiveLocalValidation];
}

id objc_msgSend_print(void *a1, const char *a2, ...)
{
  return [a1 print];
}

id objc_msgSend_priority(void *a1, const char *a2, ...)
{
  return [a1 priority];
}

id objc_msgSend_process(void *a1, const char *a2, ...)
{
  return [a1 process];
}

id objc_msgSend_processIdentifier(void *a1, const char *a2, ...)
{
  return [a1 processIdentifier];
}

id objc_msgSend_processInfo(void *a1, const char *a2, ...)
{
  return [a1 processInfo];
}

id objc_msgSend_processName(void *a1, const char *a2, ...)
{
  return [a1 processName];
}

id objc_msgSend_protocolInterface(void *a1, const char *a2, ...)
{
  return [a1 protocolInterface];
}

id objc_msgSend_publicTransactionHash(void *a1, const char *a2, ...)
{
  return [a1 publicTransactionHash];
}

id objc_msgSend_pupi(void *a1, const char *a2, ...)
{
  return [a1 pupi];
}

id objc_msgSend_purpleTrustAccess(void *a1, const char *a2, ...)
{
  return [a1 purpleTrustAccess];
}

id objc_msgSend_queryPMUCapability(void *a1, const char *a2, ...)
{
  return [a1 queryPMUCapability];
}

id objc_msgSend_queue(void *a1, const char *a2, ...)
{
  return [a1 queue];
}

id objc_msgSend_queueResume(void *a1, const char *a2, ...)
{
  return [a1 queueResume];
}

id objc_msgSend_queueSuspend(void *a1, const char *a2, ...)
{
  return [a1 queueSuspend];
}

id objc_msgSend_radioToggle(void *a1, const char *a2, ...)
{
  return [a1 radioToggle];
}

id objc_msgSend_rawGPState(void *a1, const char *a2, ...)
{
  return [a1 rawGPState];
}

id objc_msgSend_readAPDU(void *a1, const char *a2, ...)
{
  return [a1 readAPDU];
}

id objc_msgSend_readOnConnected(void *a1, const char *a2, ...)
{
  return [a1 readOnConnected];
}

id objc_msgSend_readerIdentifier(void *a1, const char *a2, ...)
{
  return [a1 readerIdentifier];
}

id objc_msgSend_readerInternalAccess(void *a1, const char *a2, ...)
{
  return [a1 readerInternalAccess];
}

id objc_msgSend_readerModeProtectionActive(void *a1, const char *a2, ...)
{
  return [a1 readerModeProtectionActive];
}

id objc_msgSend_readerModeStoppedShouldCooloffRun(void *a1, const char *a2, ...)
{
  return [a1 readerModeStoppedShouldCooloffRun];
}

id objc_msgSend_readerOperations(void *a1, const char *a2, ...)
{
  return [a1 readerOperations];
}

id objc_msgSend_readerPurposeString(void *a1, const char *a2, ...)
{
  return [a1 readerPurposeString];
}

id objc_msgSend_readerWithLPCD(void *a1, const char *a2, ...)
{
  return [a1 readerWithLPCD];
}

id objc_msgSend_readyForPayment(void *a1, const char *a2, ...)
{
  return [a1 readyForPayment];
}

id objc_msgSend_readyForVAS(void *a1, const char *a2, ...)
{
  return [a1 readyForVAS];
}

id objc_msgSend_records(void *a1, const char *a2, ...)
{
  return [a1 records];
}

id objc_msgSend_recoverSLAM(void *a1, const char *a2, ...)
{
  return [a1 recoverSLAM];
}

id objc_msgSend_referenceCounter(void *a1, const char *a2, ...)
{
  return [a1 referenceCounter];
}

id objc_msgSend_refreshISDCounter(void *a1, const char *a2, ...)
{
  return [a1 refreshISDCounter];
}

id objc_msgSend_refreshSecureElementInfo(void *a1, const char *a2, ...)
{
  return [a1 refreshSecureElementInfo];
}

id objc_msgSend_refreshUserDefaultsOverride(void *a1, const char *a2, ...)
{
  return [a1 refreshUserDefaultsOverride];
}

id objc_msgSend_registerForEvents(void *a1, const char *a2, ...)
{
  return [a1 registerForEvents];
}

id objc_msgSend_releaseAssertion(void *a1, const char *a2, ...)
{
  return [a1 releaseAssertion];
}

id objc_msgSend_releaseObjects(void *a1, const char *a2, ...)
{
  return [a1 releaseObjects];
}

id objc_msgSend_releaseRemoteObject(void *a1, const char *a2, ...)
{
  return [a1 releaseRemoteObject];
}

id objc_msgSend_remoteAssertion(void *a1, const char *a2, ...)
{
  return [a1 remoteAssertion];
}

id objc_msgSend_remoteObject(void *a1, const char *a2, ...)
{
  return [a1 remoteObject];
}

id objc_msgSend_remoteObjectProxy(void *a1, const char *a2, ...)
{
  return [a1 remoteObjectProxy];
}

id objc_msgSend_removeAllObjects(void *a1, const char *a2, ...)
{
  return [a1 removeAllObjects];
}

id objc_msgSend_removeAllPersistentFieldObservers(void *a1, const char *a2, ...)
{
  return [a1 removeAllPersistentFieldObservers];
}

id objc_msgSend_requestedApplets(void *a1, const char *a2, ...)
{
  return [a1 requestedApplets];
}

id objc_msgSend_requireSuppressDefaultAppPresentmentAssertion(void *a1, const char *a2, ...)
{
  return [a1 requireSuppressDefaultAppPresentmentAssertion];
}

id objc_msgSend_resolvedAuthorization(void *a1, const char *a2, ...)
{
  return [a1 resolvedAuthorization];
}

id objc_msgSend_response(void *a1, const char *a2, ...)
{
  return [a1 response];
}

id objc_msgSend_restartDiscovery(void *a1, const char *a2, ...)
{
  return [a1 restartDiscovery];
}

id objc_msgSend_restrictedMode(void *a1, const char *a2, ...)
{
  return [a1 restrictedMode];
}

id objc_msgSend_result(void *a1, const char *a2, ...)
{
  return [a1 result];
}

id objc_msgSend_resume(void *a1, const char *a2, ...)
{
  return [a1 resume];
}

id objc_msgSend_resumeDiscovery(void *a1, const char *a2, ...)
{
  return [a1 resumeDiscovery];
}

id objc_msgSend_reverseObjectEnumerator(void *a1, const char *a2, ...)
{
  return [a1 reverseObjectEnumerator];
}

id objc_msgSend_rfTechnology(void *a1, const char *a2, ...)
{
  return [a1 rfTechnology];
}

id objc_msgSend_role(void *a1, const char *a2, ...)
{
  return [a1 role];
}

id objc_msgSend_routingOff(void *a1, const char *a2, ...)
{
  return [a1 routingOff];
}

id objc_msgSend_rsaCertificate(void *a1, const char *a2, ...)
{
  return [a1 rsaCertificate];
}

id objc_msgSend_scheme(void *a1, const char *a2, ...)
{
  return [a1 scheme];
}

id objc_msgSend_seCredentialManagerAccess(void *a1, const char *a2, ...)
{
  return [a1 seCredentialManagerAccess];
}

id objc_msgSend_seDirty(void *a1, const char *a2, ...)
{
  return [a1 seDirty];
}

id objc_msgSend_seLoggingSessionAccess(void *a1, const char *a2, ...)
{
  return [a1 seLoggingSessionAccess];
}

id objc_msgSend_seName(void *a1, const char *a2, ...)
{
  return [a1 seName];
}

id objc_msgSend_seOS(void *a1, const char *a2, ...)
{
  return [a1 seOS];
}

id objc_msgSend_seProxyListener(void *a1, const char *a2, ...)
{
  return [a1 seProxyListener];
}

id objc_msgSend_seSessionAccess(void *a1, const char *a2, ...)
{
  return [a1 seSessionAccess];
}

id objc_msgSend_seType(void *a1, const char *a2, ...)
{
  return [a1 seType];
}

id objc_msgSend_secureElementAsReaderMode(void *a1, const char *a2, ...)
{
  return [a1 secureElementAsReaderMode];
}

id objc_msgSend_secureElementWrapper(void *a1, const char *a2, ...)
{
  return [a1 secureElementWrapper];
}

id objc_msgSend_seid(void *a1, const char *a2, ...)
{
  return [a1 seid];
}

id objc_msgSend_selectInstance(void *a1, const char *a2, ...)
{
  return [a1 selectInstance];
}

id objc_msgSend_selectStatus(void *a1, const char *a2, ...)
{
  return [a1 selectStatus];
}

id objc_msgSend_selectTag(void *a1, const char *a2, ...)
{
  return [a1 selectTag];
}

id objc_msgSend_selectedAID(void *a1, const char *a2, ...)
{
  return [a1 selectedAID];
}

id objc_msgSend_sequenceCounter(void *a1, const char *a2, ...)
{
  return [a1 sequenceCounter];
}

id objc_msgSend_serialNumber(void *a1, const char *a2, ...)
{
  return [a1 serialNumber];
}

id objc_msgSend_serialNumberAsData(void *a1, const char *a2, ...)
{
  return [a1 serialNumberAsData];
}

id objc_msgSend_server(void *a1, const char *a2, ...)
{
  return [a1 server];
}

id objc_msgSend_serviceType(void *a1, const char *a2, ...)
{
  return [a1 serviceType];
}

id objc_msgSend_services(void *a1, const char *a2, ...)
{
  return [a1 services];
}

id objc_msgSend_sesdEventPublisher(void *a1, const char *a2, ...)
{
  return [a1 sesdEventPublisher];
}

id objc_msgSend_seshatAccess(void *a1, const char *a2, ...)
{
  return [a1 seshatAccess];
}

id objc_msgSend_sessionConfig(void *a1, const char *a2, ...)
{
  return [a1 sessionConfig];
}

id objc_msgSend_sessionID(void *a1, const char *a2, ...)
{
  return [a1 sessionID];
}

id objc_msgSend_sessionResumeField(void *a1, const char *a2, ...)
{
  return [a1 sessionResumeField];
}

id objc_msgSend_sessionTimeLimit(void *a1, const char *a2, ...)
{
  return [a1 sessionTimeLimit];
}

id objc_msgSend_sessionType(void *a1, const char *a2, ...)
{
  return [a1 sessionType];
}

id objc_msgSend_sessionUID(void *a1, const char *a2, ...)
{
  return [a1 sessionUID];
}

id objc_msgSend_setAuthRandomEntangled(void *a1, const char *a2, ...)
{
  return [a1 setAuthRandomEntangled];
}

id objc_msgSend_setDriverCallbacks(void *a1, const char *a2, ...)
{
  return [a1 setDriverCallbacks];
}

id objc_msgSend_setUnpairedState(void *a1, const char *a2, ...)
{
  return [a1 setUnpairedState];
}

id objc_msgSend_setupInterface(void *a1, const char *a2, ...)
{
  return [a1 setupInterface];
}

id objc_msgSend_sharedCALogger(void *a1, const char *a2, ...)
{
  return [a1 sharedCALogger];
}

id objc_msgSend_sharedCPMSAgent(void *a1, const char *a2, ...)
{
  return [a1 sharedCPMSAgent];
}

id objc_msgSend_sharedConnection(void *a1, const char *a2, ...)
{
  return [a1 sharedConnection];
}

id objc_msgSend_sharedHardwareManager(void *a1, const char *a2, ...)
{
  return [a1 sharedHardwareManager];
}

id objc_msgSend_sharedManager(void *a1, const char *a2, ...)
{
  return [a1 sharedManager];
}

id objc_msgSend_sharedPowerAssertion(void *a1, const char *a2, ...)
{
  return [a1 sharedPowerAssertion];
}

id objc_msgSend_shouldHandleSecureElementTransactionData(void *a1, const char *a2, ...)
{
  return [a1 shouldHandleSecureElementTransactionData];
}

id objc_msgSend_signResponse(void *a1, const char *a2, ...)
{
  return [a1 signResponse];
}

id objc_msgSend_signingKeyType(void *a1, const char *a2, ...)
{
  return [a1 signingKeyType];
}

id objc_msgSend_signpostId(void *a1, const char *a2, ...)
{
  return [a1 signpostId];
}

id objc_msgSend_signupUrl(void *a1, const char *a2, ...)
{
  return [a1 signupUrl];
}

id objc_msgSend_silentType(void *a1, const char *a2, ...)
{
  return [a1 silentType];
}

id objc_msgSend_siliconName(void *a1, const char *a2, ...)
{
  return [a1 siliconName];
}

id objc_msgSend_siliconVersion(void *a1, const char *a2, ...)
{
  return [a1 siliconVersion];
}

id objc_msgSend_skipMifareClassification(void *a1, const char *a2, ...)
{
  return [a1 skipMifareClassification];
}

id objc_msgSend_source(void *a1, const char *a2, ...)
{
  return [a1 source];
}

id objc_msgSend_spIdentifier(void *a1, const char *a2, ...)
{
  return [a1 spIdentifier];
}

id objc_msgSend_stackUnloaded(void *a1, const char *a2, ...)
{
  return [a1 stackUnloaded];
}

id objc_msgSend_standardUserDefaults(void *a1, const char *a2, ...)
{
  return [a1 standardUserDefaults];
}

id objc_msgSend_start(void *a1, const char *a2, ...)
{
  return [a1 start];
}

id objc_msgSend_startDefaultMode(void *a1, const char *a2, ...)
{
  return [a1 startDefaultMode];
}

id objc_msgSend_startISO18013WithConnectionHandoverConfiguration(void *a1, const char *a2, ...)
{
  return [a1 startISO18013WithConnectionHandoverConfiguration];
}

id objc_msgSend_startOnFieldList(void *a1, const char *a2, ...)
{
  return [a1 startOnFieldList];
}

id objc_msgSend_startWiredMode(void *a1, const char *a2, ...)
{
  return [a1 startWiredMode];
}

id objc_msgSend_state(void *a1, const char *a2, ...)
{
  return [a1 state];
}

id objc_msgSend_status(void *a1, const char *a2, ...)
{
  return [a1 status];
}

id objc_msgSend_stop(void *a1, const char *a2, ...)
{
  return [a1 stop];
}

id objc_msgSend_stopFury(void *a1, const char *a2, ...)
{
  return [a1 stopFury];
}

id objc_msgSend_stopSEProxyListener(void *a1, const char *a2, ...)
{
  return [a1 stopSEProxyListener];
}

id objc_msgSend_stopTimer(void *a1, const char *a2, ...)
{
  return [a1 stopTimer];
}

id objc_msgSend_storePairedState(void *a1, const char *a2, ...)
{
  return [a1 storePairedState];
}

id objc_msgSend_string(void *a1, const char *a2, ...)
{
  return [a1 string];
}

id objc_msgSend_stringValue(void *a1, const char *a2, ...)
{
  return [a1 stringValue];
}

id objc_msgSend_strongToWeakObjectsMapTable(void *a1, const char *a2, ...)
{
  return [a1 strongToWeakObjectsMapTable];
}

id objc_msgSend_stsHelper(void *a1, const char *a2, ...)
{
  return [a1 stsHelper];
}

id objc_msgSend_subjectIdentifier(void *a1, const char *a2, ...)
{
  return [a1 subjectIdentifier];
}

id objc_msgSend_supportedTechnologies(void *a1, const char *a2, ...)
{
  return [a1 supportedTechnologies];
}

id objc_msgSend_supportedTypeFSystem(void *a1, const char *a2, ...)
{
  return [a1 supportedTypeFSystem];
}

id objc_msgSend_suppressTypeA(void *a1, const char *a2, ...)
{
  return [a1 suppressTypeA];
}

id objc_msgSend_suppressTypeB(void *a1, const char *a2, ...)
{
  return [a1 suppressTypeB];
}

id objc_msgSend_surfSessionAccess(void *a1, const char *a2, ...)
{
  return [a1 surfSessionAccess];
}

id objc_msgSend_suspend(void *a1, const char *a2, ...)
{
  return [a1 suspend];
}

id objc_msgSend_suspendOnDisconnect(void *a1, const char *a2, ...)
{
  return [a1 suspendOnDisconnect];
}

id objc_msgSend_suspendOnFieldList(void *a1, const char *a2, ...)
{
  return [a1 suspendOnFieldList];
}

id objc_msgSend_suspensionRequestor(void *a1, const char *a2, ...)
{
  return [a1 suspensionRequestor];
}

id objc_msgSend_synchronize(void *a1, const char *a2, ...)
{
  return [a1 synchronize];
}

id objc_msgSend_systemOSSerialNumber(void *a1, const char *a2, ...)
{
  return [a1 systemOSSerialNumber];
}

id objc_msgSend_tag(void *a1, const char *a2, ...)
{
  return [a1 tag];
}

id objc_msgSend_tagA(void *a1, const char *a2, ...)
{
  return [a1 tagA];
}

id objc_msgSend_tagB(void *a1, const char *a2, ...)
{
  return [a1 tagB];
}

id objc_msgSend_tagDetected(void *a1, const char *a2, ...)
{
  return [a1 tagDetected];
}

id objc_msgSend_tagDiscoveryConfig(void *a1, const char *a2, ...)
{
  return [a1 tagDiscoveryConfig];
}

id objc_msgSend_tagF(void *a1, const char *a2, ...)
{
  return [a1 tagF];
}

id objc_msgSend_tagID(void *a1, const char *a2, ...)
{
  return [a1 tagID];
}

id objc_msgSend_taskState(void *a1, const char *a2, ...)
{
  return [a1 taskState];
}

id objc_msgSend_tciArray(void *a1, const char *a2, ...)
{
  return [a1 tciArray];
}

id objc_msgSend_technology(void *a1, const char *a2, ...)
{
  return [a1 technology];
}

id objc_msgSend_temporaryDirectory(void *a1, const char *a2, ...)
{
  return [a1 temporaryDirectory];
}

id objc_msgSend_terminalCap(void *a1, const char *a2, ...)
{
  return [a1 terminalCap];
}

id objc_msgSend_terminalMode(void *a1, const char *a2, ...)
{
  return [a1 terminalMode];
}

id objc_msgSend_terminalProtocol(void *a1, const char *a2, ...)
{
  return [a1 terminalProtocol];
}

id objc_msgSend_terminalSubType(void *a1, const char *a2, ...)
{
  return [a1 terminalSubType];
}

id objc_msgSend_terminalType(void *a1, const char *a2, ...)
{
  return [a1 terminalType];
}

id objc_msgSend_thermalPressureBackoff(void *a1, const char *a2, ...)
{
  return [a1 thermalPressureBackoff];
}

id objc_msgSend_thermalPressureCritical(void *a1, const char *a2, ...)
{
  return [a1 thermalPressureCritical];
}

id objc_msgSend_thermalPressureNominal(void *a1, const char *a2, ...)
{
  return [a1 thermalPressureNominal];
}

id objc_msgSend_timeIntervalSinceNow(void *a1, const char *a2, ...)
{
  return [a1 timeIntervalSinceNow];
}

id objc_msgSend_timeIntervalSinceReferenceDate(void *a1, const char *a2, ...)
{
  return [a1 timeIntervalSinceReferenceDate];
}

id objc_msgSend_timeLimitedSession(void *a1, const char *a2, ...)
{
  return [a1 timeLimitedSession];
}

id objc_msgSend_tnepHandler(void *a1, const char *a2, ...)
{
  return [a1 tnepHandler];
}

id objc_msgSend_tnepServiceInvalidate(void *a1, const char *a2, ...)
{
  return [a1 tnepServiceInvalidate];
}

id objc_msgSend_toSystemOS(void *a1, const char *a2, ...)
{
  return [a1 toSystemOS];
}

id objc_msgSend_token(void *a1, const char *a2, ...)
{
  return [a1 token];
}

id objc_msgSend_topUpRequest(void *a1, const char *a2, ...)
{
  return [a1 topUpRequest];
}

id objc_msgSend_totalFieldDetectSessions(void *a1, const char *a2, ...)
{
  return [a1 totalFieldDetectSessions];
}

id objc_msgSend_totalPersistentClient(void *a1, const char *a2, ...)
{
  return [a1 totalPersistentClient];
}

id objc_msgSend_transactionAmount(void *a1, const char *a2, ...)
{
  return [a1 transactionAmount];
}

id objc_msgSend_transactionCountry(void *a1, const char *a2, ...)
{
  return [a1 transactionCountry];
}

id objc_msgSend_transactionCurrency(void *a1, const char *a2, ...)
{
  return [a1 transactionCurrency];
}

id objc_msgSend_transactionDate(void *a1, const char *a2, ...)
{
  return [a1 transactionDate];
}

id objc_msgSend_transactionIdentifier(void *a1, const char *a2, ...)
{
  return [a1 transactionIdentifier];
}

id objc_msgSend_transferRequest(void *a1, const char *a2, ...)
{
  return [a1 transferRequest];
}

id objc_msgSend_transitionReasons(void *a1, const char *a2, ...)
{
  return [a1 transitionReasons];
}

id objc_msgSend_triggerBurnoutTimer(void *a1, const char *a2, ...)
{
  return [a1 triggerBurnoutTimer];
}

id objc_msgSend_triggerFailForward(void *a1, const char *a2, ...)
{
  return [a1 triggerFailForward];
}

id objc_msgSend_trustDB(void *a1, const char *a2, ...)
{
  return [a1 trustDB];
}

id objc_msgSend_trustDBApplet(void *a1, const char *a2, ...)
{
  return [a1 trustDBApplet];
}

id objc_msgSend_trustObjectInternalRawNSData(void *a1, const char *a2, ...)
{
  return [a1 trustObjectInternalRawNSData];
}

id objc_msgSend_trustedISO7816AidList(void *a1, const char *a2, ...)
{
  return [a1 trustedISO7816AidList];
}

id objc_msgSend_type(void *a1, const char *a2, ...)
{
  return [a1 type];
}

id objc_msgSend_typeFSystemCode(void *a1, const char *a2, ...)
{
  return [a1 typeFSystemCode];
}

id objc_msgSend_typeNameFormat(void *a1, const char *a2, ...)
{
  return [a1 typeNameFormat];
}

id objc_msgSend_uiActivated(void *a1, const char *a2, ...)
{
  return [a1 uiActivated];
}

id objc_msgSend_uiMode(void *a1, const char *a2, ...)
{
  return [a1 uiMode];
}

id objc_msgSend_uiShown(void *a1, const char *a2, ...)
{
  return [a1 uiShown];
}

id objc_msgSend_uid(void *a1, const char *a2, ...)
{
  return [a1 uid];
}

id objc_msgSend_unfiltered(void *a1, const char *a2, ...)
{
  return [a1 unfiltered];
}

id objc_msgSend_unlock(void *a1, const char *a2, ...)
{
  return [a1 unlock];
}

id objc_msgSend_unpredictableNumber(void *a1, const char *a2, ...)
{
  return [a1 unpredictableNumber];
}

id objc_msgSend_unregisterForEvents(void *a1, const char *a2, ...)
{
  return [a1 unregisterForEvents];
}

id objc_msgSend_unsignedCharValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedCharValue];
}

id objc_msgSend_unsignedIntValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedIntValue];
}

id objc_msgSend_unsignedIntegerValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedIntegerValue];
}

id objc_msgSend_unsignedLongLongValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedLongLongValue];
}

id objc_msgSend_unsignedLongValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedLongValue];
}

id objc_msgSend_unsignedShortValue(void *a1, const char *a2, ...)
{
  return [a1 unsignedShortValue];
}

id objc_msgSend_updateAllPowerCounters(void *a1, const char *a2, ...)
{
  return [a1 updateAllPowerCounters];
}

id objc_msgSend_updateExpressAppletNumbers(void *a1, const char *a2, ...)
{
  return [a1 updateExpressAppletNumbers];
}

id objc_msgSend_updateStorage(void *a1, const char *a2, ...)
{
  return [a1 updateStorage];
}

id objc_msgSend_upgradeChecked(void *a1, const char *a2, ...)
{
  return [a1 upgradeChecked];
}

id objc_msgSend_uppercaseString(void *a1, const char *a2, ...)
{
  return [a1 uppercaseString];
}

id objc_msgSend_uri(void *a1, const char *a2, ...)
{
  return [a1 uri];
}

id objc_msgSend_useFilteredApplets(void *a1, const char *a2, ...)
{
  return [a1 useFilteredApplets];
}

id objc_msgSend_useUnfilteredApplets(void *a1, const char *a2, ...)
{
  return [a1 useUnfilteredApplets];
}

id objc_msgSend_user(void *a1, const char *a2, ...)
{
  return [a1 user];
}

id objc_msgSend_userInfo(void *a1, const char *a2, ...)
{
  return [a1 userInfo];
}

id objc_msgSend_userInterventionRequired(void *a1, const char *a2, ...)
{
  return [a1 userInterventionRequired];
}

id objc_msgSend_value(void *a1, const char *a2, ...)
{
  return [a1 value];
}

id objc_msgSend_valueAsHexString(void *a1, const char *a2, ...)
{
  return [a1 valueAsHexString];
}

id objc_msgSend_valueAsString(void *a1, const char *a2, ...)
{
  return [a1 valueAsString];
}

id objc_msgSend_valueAsUnsignedLong(void *a1, const char *a2, ...)
{
  return [a1 valueAsUnsignedLong];
}

id objc_msgSend_valueAsUnsignedShort(void *a1, const char *a2, ...)
{
  return [a1 valueAsUnsignedShort];
}

id objc_msgSend_vasData(void *a1, const char *a2, ...)
{
  return [a1 vasData];
}

id objc_msgSend_vasPasses(void *a1, const char *a2, ...)
{
  return [a1 vasPasses];
}

id objc_msgSend_waitForSafeTransactionCompletion(void *a1, const char *a2, ...)
{
  return [a1 waitForSafeTransactionCompletion];
}

id objc_msgSend_wallet(void *a1, const char *a2, ...)
{
  return [a1 wallet];
}

id objc_msgSend_walletBundleIdentifier(void *a1, const char *a2, ...)
{
  return [a1 walletBundleIdentifier];
}

id objc_msgSend_walletDomain(void *a1, const char *a2, ...)
{
  return [a1 walletDomain];
}

id objc_msgSend_wantsCardEmulation(void *a1, const char *a2, ...)
{
  return [a1 wantsCardEmulation];
}

id objc_msgSend_wantsExpress(void *a1, const char *a2, ...)
{
  return [a1 wantsExpress];
}

id objc_msgSend_wantsIsoDepToHost(void *a1, const char *a2, ...)
{
  return [a1 wantsIsoDepToHost];
}

id objc_msgSend_wantsLPCD(void *a1, const char *a2, ...)
{
  return [a1 wantsLPCD];
}

id objc_msgSend_wantsMultiTag(void *a1, const char *a2, ...)
{
  return [a1 wantsMultiTag];
}

id objc_msgSend_wantsReader(void *a1, const char *a2, ...)
{
  return [a1 wantsReader];
}

id objc_msgSend_wantsSEReader(void *a1, const char *a2, ...)
{
  return [a1 wantsSEReader];
}

id objc_msgSend_weakObjectsHashTable(void *a1, const char *a2, ...)
{
  return [a1 weakObjectsHashTable];
}

id objc_msgSend_whitelistChecker(void *a1, const char *a2, ...)
{
  return [a1 whitelistChecker];
}

id objc_msgSend_whitespaceAndNewlineCharacterSet(void *a1, const char *a2, ...)
{
  return [a1 whitespaceAndNewlineCharacterSet];
}

id objc_msgSend_willStartSession(void *a1, const char *a2, ...)
{
  return [a1 willStartSession];
}

id objc_msgSend_workQueue(void *a1, const char *a2, ...)
{
  return [a1 workQueue];
}

id objc_msgSend_xpcEventNotificationQueue(void *a1, const char *a2, ...)
{
  return [a1 xpcEventNotificationQueue];
}

id objc_msgSend_year(void *a1, const char *a2, ...)
{
  return [a1 year];
}

id objc_msgSend_zero(void *a1, const char *a2, ...)
{
  return [a1 zero];
}