void sub_1000D4570(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a21, 8);
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

void sub_1000D45A8(uint64_t a1)
{
}

void sub_1000D45B0(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v6)
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a3);
  }
  else
  {
    long long v87 = 0u;
    long long v88 = 0u;
    long long v85 = 0u;
    long long v86 = 0u;
    id v84 = [v5 countByEnumeratingWithState:&v85 objects:v101 count:16];
    v7 = 0;
    if (v84)
    {
      uint64_t v83 = *(void *)v86;
      id obj = v5;
      do
      {
        v8 = 0;
        do
        {
          if (*(void *)v86 != v83) {
            objc_enumerationMutation(obj);
          }
          v9 = *(void **)(*((void *)&v85 + 1) + 8 * (void)v8);
          if (v9) {
            v10 = (void *)v9[3];
          }
          else {
            v10 = 0;
          }
          id v11 = v10;

          if (v11)
          {
            v12 = NFSharedSignpostLog();
            if (os_signpost_enabled(v12))
            {
              *(_WORD *)buf = 0;
              _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v12, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "getKeyInSlot", (const char *)&unk_100286819, buf, 2u);
            }

            v13 = [*(id *)(a1 + 32) secureElementWrapper];
            if (v9) {
              v14 = (void *)v9[4];
            }
            else {
              v14 = 0;
            }
            id v15 = v14;
            uint64_t v16 = sub_1000BC598(v13, v15);

            if (v16)
            {
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t Logger = NFLogGetLogger();
              if (Logger)
              {
                v18 = (void (*)(uint64_t, const char *, ...))Logger;
                Class = object_getClass(*(id *)(a1 + 32));
                if (class_isMetaClass(Class)) {
                  uint64_t v20 = 43;
                }
                else {
                  uint64_t v20 = 45;
                }
                ClassName = object_getClassName(*(id *)(a1 + 32));
                Name = sel_getName(*(SEL *)(a1 + 56));
                if (v9) {
                  v23 = (void *)v9[1];
                }
                else {
                  v23 = 0;
                }
                id v24 = v23;
                v18(4, "%c[%{public}s %{public}s]:%i Could not getKey '%{public}@' from SE, delete the key from the database : %{public}@", v20, ClassName, Name, 260, v24, v16);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v25 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
              {
                v26 = object_getClass(*(id *)(a1 + 32));
                if (class_isMetaClass(v26)) {
                  int v27 = 43;
                }
                else {
                  int v27 = 45;
                }
                v28 = object_getClassName(*(id *)(a1 + 32));
                v29 = sel_getName(*(SEL *)(a1 + 56));
                if (v9) {
                  v30 = (void *)v9[1];
                }
                else {
                  v30 = 0;
                }
                id v31 = v30;
                *(_DWORD *)buf = 67110402;
                int v90 = v27;
                __int16 v91 = 2082;
                v92 = v28;
                __int16 v93 = 2082;
                v94 = v29;
                __int16 v95 = 1024;
                int v96 = 260;
                __int16 v97 = 2114;
                id v98 = v31;
                __int16 v99 = 2114;
                uint64_t v100 = v16;
                _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Could not getKey '%{public}@' from SE, delete the key from the database : %{public}@", buf, 0x36u);
              }
              v32 = [*(id *)(a1 + 32) deleteDBKey:v9];

              if (v32)
              {
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v33 = NFLogGetLogger();
                if (v33)
                {
                  v34 = (void (*)(uint64_t, const char *, ...))v33;
                  v35 = object_getClass(*(id *)(a1 + 32));
                  if (class_isMetaClass(v35)) {
                    uint64_t v36 = 43;
                  }
                  else {
                    uint64_t v36 = 45;
                  }
                  v37 = object_getClassName(*(id *)(a1 + 32));
                  v38 = sel_getName(*(SEL *)(a1 + 56));
                  if (v9) {
                    v39 = (void *)v9[1];
                  }
                  else {
                    v39 = 0;
                  }
                  id v40 = v39;
                  v34(3, "%c[%{public}s %{public}s]:%i Could not delete incomplete key with identifier %{public}@ from database", v36, v37, v38, 263, v40);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v41 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
                {
                  v42 = object_getClass(*(id *)(a1 + 32));
                  if (class_isMetaClass(v42)) {
                    int v43 = 43;
                  }
                  else {
                    int v43 = 45;
                  }
                  v44 = object_getClassName(*(id *)(a1 + 32));
                  v45 = sel_getName(*(SEL *)(a1 + 56));
                  if (v9) {
                    v46 = (void *)v9[1];
                  }
                  else {
                    v46 = 0;
                  }
                  id v47 = v46;
                  *(_DWORD *)buf = 67110146;
                  int v90 = v43;
                  __int16 v91 = 2082;
                  v92 = v44;
                  __int16 v93 = 2082;
                  v94 = v45;
                  __int16 v95 = 1024;
                  int v96 = 263;
                  __int16 v97 = 2114;
                  id v98 = v47;
                  _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Could not delete incomplete key with identifier %{public}@ from database", buf, 0x2Cu);
                }
              }
              v48 = NFSharedSignpostLog();
              if (os_signpost_enabled(v48))
              {
                *(_WORD *)buf = 0;
                _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v48, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "getKeyInSlot", "failed", buf, 2u);
              }

              v7 = (void *)v16;
            }
            else
            {
              v80 = NFSharedSignpostLog();
              if (os_signpost_enabled(v80))
              {
                *(_WORD *)buf = 0;
                _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v80, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "getKeyInSlot", (const char *)&unk_100286819, buf, 2u);
              }

              [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) addObject:v9];
              v7 = 0;
            }
          }
          else
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v49 = NFLogGetLogger();
            if (v49)
            {
              v50 = (void (*)(uint64_t, const char *, ...))v49;
              v51 = object_getClass(*(id *)(a1 + 32));
              if (class_isMetaClass(v51)) {
                uint64_t v52 = 43;
              }
              else {
                uint64_t v52 = 45;
              }
              v53 = object_getClassName(*(id *)(a1 + 32));
              v54 = sel_getName(*(SEL *)(a1 + 56));
              if (v9) {
                v55 = (void *)v9[1];
              }
              else {
                v55 = 0;
              }
              id v56 = v55;
              v50(4, "%c[%{public}s %{public}s]:%i Key attestion of %{public}@ is nil, key create/delete may have crashed, do not list key and try to delete the key again ... ", v52, v53, v54, 247, v56);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v57 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
            {
              v58 = object_getClass(*(id *)(a1 + 32));
              if (class_isMetaClass(v58)) {
                int v59 = 43;
              }
              else {
                int v59 = 45;
              }
              v60 = object_getClassName(*(id *)(a1 + 32));
              v61 = sel_getName(*(SEL *)(a1 + 56));
              if (v9) {
                v62 = (void *)v9[1];
              }
              else {
                v62 = 0;
              }
              id v63 = v62;
              *(_DWORD *)buf = 67110146;
              int v90 = v59;
              __int16 v91 = 2082;
              v92 = v60;
              __int16 v93 = 2082;
              v94 = v61;
              __int16 v95 = 1024;
              int v96 = 247;
              __int16 v97 = 2114;
              id v98 = v63;
              _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Key attestion of %{public}@ is nil, key create/delete may have crashed, do not list key and try to delete the key again ... ", buf, 0x2Cu);
            }
            v64 = [*(id *)(a1 + 32) deleteDBKey:v9];

            if (v64)
            {
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v65 = NFLogGetLogger();
              if (v65)
              {
                v66 = (void (*)(uint64_t, const char *, ...))v65;
                v67 = object_getClass(*(id *)(a1 + 32));
                if (class_isMetaClass(v67)) {
                  uint64_t v68 = 43;
                }
                else {
                  uint64_t v68 = 45;
                }
                v69 = object_getClassName(*(id *)(a1 + 32));
                v70 = sel_getName(*(SEL *)(a1 + 56));
                if (v9) {
                  v71 = (void *)v9[1];
                }
                else {
                  v71 = 0;
                }
                id v72 = v71;
                v66(3, "%c[%{public}s %{public}s]:%i Could not delete incomplete key with identifier %{public}@ from database", v68, v69, v70, 250, v72);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v73 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
              {
                v74 = object_getClass(*(id *)(a1 + 32));
                if (class_isMetaClass(v74)) {
                  int v75 = 43;
                }
                else {
                  int v75 = 45;
                }
                v76 = object_getClassName(*(id *)(a1 + 32));
                v77 = sel_getName(*(SEL *)(a1 + 56));
                if (v9) {
                  v78 = (void *)v9[1];
                }
                else {
                  v78 = 0;
                }
                id v79 = v78;
                *(_DWORD *)buf = 67110146;
                int v90 = v75;
                __int16 v91 = 2082;
                v92 = v76;
                __int16 v93 = 2082;
                v94 = v77;
                __int16 v95 = 1024;
                int v96 = 250;
                __int16 v97 = 2114;
                id v98 = v79;
                _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Could not delete incomplete key with identifier %{public}@ from database", buf, 0x2Cu);
              }
            }
          }
          v8 = (char *)v8 + 1;
        }
        while (v84 != v8);
        id v5 = obj;
        id v81 = [obj countByEnumeratingWithState:&v85 objects:v101 count:16];
        id v84 = v81;
      }
      while (v81);
    }

    id v6 = 0;
  }
}

void sub_1000D4F6C(uint64_t a1)
{
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    v22 = [*(id *)(a1 + 32) keys];

    if (v22) {
      goto LABEL_18;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      v44 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v48 = 45;
      if (isMetaClass) {
        uint64_t v48 = 43;
      }
      v44(6, "%c[%{public}s %{public}s]:%i Regenerating cached keys", v48, ClassName, Name, 295);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v49 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
    {
      v50 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v50)) {
        int v51 = 43;
      }
      else {
        int v51 = 45;
      }
      uint64_t v52 = object_getClassName(*(id *)(a1 + 32));
      v53 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67109890;
      int v79 = v51;
      __int16 v80 = 2082;
      id v81 = v52;
      __int16 v82 = 2082;
      uint64_t v83 = v53;
      __int16 v84 = 1024;
      int v85 = 295;
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Regenerating cached keys", buf, 0x22u);
    }

    v54 = *(void **)(a1 + 32);
    id v74 = 0;
    v55 = [v54 getListOfKeysWithError:&v74];
    id v18 = v74;
    [*(id *)(a1 + 32) setKeys:v55];

    if (!v18)
    {
LABEL_18:
      id v18 = (id)objc_opt_new();
      long long v70 = 0u;
      long long v71 = 0u;
      long long v72 = 0u;
      long long v73 = 0u;
      v23 = [*(id *)(a1 + 32) keys];
      id v24 = [v23 countByEnumeratingWithState:&v70 objects:v75 count:16];
      if (v24)
      {
        id v25 = v24;
        uint64_t v26 = *(void *)v71;
        while (2)
        {
          for (i = 0; i != v25; i = (char *)i + 1)
          {
            if (*(void *)v71 != v26) {
              objc_enumerationMutation(v23);
            }
            uint64_t v28 = sub_100035410(*(void *)(*((void *)&v70 + 1) + 8 * i));
            if (!v28)
            {
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v31 = NFLogGetLogger();
              if (v31)
              {
                v32 = (void (*)(uint64_t, const char *, ...))v31;
                uint64_t v33 = object_getClass(*(id *)(a1 + 32));
                BOOL v34 = class_isMetaClass(v33);
                v35 = object_getClassName(*(id *)(a1 + 32));
                v67 = sel_getName(*(SEL *)(a1 + 48));
                uint64_t v36 = 45;
                if (v34) {
                  uint64_t v36 = 43;
                }
                v32(3, "%c[%{public}s %{public}s]:%i Could not create NFTrustKey Object", v36, v35, v67, 311);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v37 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
              {
                v38 = object_getClass(*(id *)(a1 + 32));
                if (class_isMetaClass(v38)) {
                  int v39 = 43;
                }
                else {
                  int v39 = 45;
                }
                id v40 = object_getClassName(*(id *)(a1 + 32));
                v41 = sel_getName(*(SEL *)(a1 + 48));
                *(_DWORD *)buf = 67109890;
                int v79 = v39;
                __int16 v80 = 2082;
                id v81 = v40;
                __int16 v82 = 2082;
                uint64_t v83 = v41;
                __int16 v84 = 1024;
                int v85 = 311;
                _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Could not create NFTrustKey Object", buf, 0x22u);
              }

              uint64_t v42 = sub_100140860(@"Could not create NFTrustKey Object");

              (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
              id v18 = (id)v42;
              goto LABEL_15;
            }
            v29 = (void *)v28;
            [v18 addObject:v28];
          }
          id v25 = [v23 countByEnumeratingWithState:&v70 objects:v75 count:16];
          if (v25) {
            continue;
          }
          break;
        }
      }

      v30 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v56 = NFLogGetLogger();
      if (v56)
      {
        v57 = (void (*)(uint64_t, const char *, ...))v56;
        v58 = object_getClass(*(id *)(a1 + 32));
        BOOL v59 = class_isMetaClass(v58);
        v66 = object_getClassName(*(id *)(a1 + 32));
        v69 = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v60 = 45;
        if (v59) {
          uint64_t v60 = 43;
        }
        v57(3, "%c[%{public}s %{public}s]:%i Failed to getListOfKeys: %{public}@", v60, v66, v69, 298, v18);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v61 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
      {
        v62 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v62)) {
          int v63 = 43;
        }
        else {
          int v63 = 45;
        }
        v64 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v65 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)buf = 67110146;
        int v79 = v63;
        __int16 v80 = 2082;
        id v81 = v64;
        __int16 v82 = 2082;
        uint64_t v83 = v65;
        __int16 v84 = 1024;
        int v85 = 298;
        __int16 v86 = 2114;
        id v87 = v18;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to getListOfKeys: %{public}@", buf, 0x2Cu);
      }

      v30 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
    }
    v30();
    goto LABEL_15;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v2 = NFLogGetLogger();
  if (v2)
  {
    v3 = (void (*)(uint64_t, const char *, ...))v2;
    v4 = object_getClass(*(id *)(a1 + 32));
    BOOL v5 = class_isMetaClass(v4);
    id v6 = object_getClassName(*(id *)(a1 + 32));
    v7 = sel_getName(*(SEL *)(a1 + 48));
    v8 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v9 = 45;
    if (v5) {
      uint64_t v9 = 43;
    }
    v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, v6, v7, 292, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    id v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    v13 = object_getClassName(*(id *)(a1 + 32));
    v14 = sel_getName(*(SEL *)(a1 + 48));
    id v15 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)buf = 67110146;
    int v79 = v12;
    __int16 v80 = 2082;
    id v81 = v13;
    __int16 v82 = 2082;
    uint64_t v83 = v14;
    __int16 v84 = 1024;
    int v85 = 292;
    __int16 v86 = 2114;
    id v87 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v16 = *(void *)(a1 + 40);
  if (v16)
  {
    id v17 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v76 = NSLocalizedDescriptionKey;
    v19 = +[NSString stringWithUTF8String:"Session not active"];
    v77 = v19;
    uint64_t v20 = +[NSDictionary dictionaryWithObjects:&v77 forKeys:&v76 count:1];
    id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
    (*(void (**)(uint64_t, void, id))(v16 + 16))(v16, 0, v21);

LABEL_15:
  }
}

void sub_1000D6740(uint64_t a1)
{
  if (!*(void *)(a1 + 48))
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      v23 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v27 = 45;
      if (isMetaClass) {
        uint64_t v27 = 43;
      }
      v23(3, "%c[%{public}s %{public}s]:%i Could not delete Key with nil callback", v27, ClassName, Name, 500);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v18 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      uint64_t v28 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v28)) {
        int v29 = 43;
      }
      else {
        int v29 = 45;
      }
      v30 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v31 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)buf = 67109890;
      int v90 = v29;
      __int16 v91 = 2082;
      v92 = v30;
      __int16 v93 = 2082;
      v94 = v31;
      __int16 v95 = 1024;
      int v96 = 500;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Could not delete Key with nil callback", buf, 0x22u);
    }
    goto LABEL_26;
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    uint64_t v32 = [*(id *)(a1 + 32) trustDB];
    if (v32
      && (uint64_t v33 = (void *)v32,
          [*(id *)(a1 + 32) trustDBApplet],
          BOOL v34 = objc_claimAutoreleasedReturnValue(),
          v34,
          v33,
          v34))
    {
      if (*(void *)(a1 + 40))
      {
        v35 = [*(id *)(a1 + 32) trustDB];
        uint64_t v36 = *(void **)(a1 + 40);
        id v76 = 0;
        sub_100033858(v35, v36, &v76);
        id v37 = (id)objc_claimAutoreleasedReturnValue();
        id v18 = v76;

        if (v37)
        {
          v81[0] = @"purpleTrustOperationType";
          v81[1] = @"purpleTrustOperationErrorStep";
          v82[0] = &off_10031B328;
          v82[1] = &off_10031B3D0;
          v82[2] = &off_10031B340;
          v81[2] = @"purpleTrustOperationCAErrorCode";
          v81[3] = @"purpleTrustOperationErrorCode";
          v38 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [v37 code]);
          v82[3] = v38;
          int v39 = +[NSDictionary dictionaryWithObjects:v82 forKeys:v81 count:4];

          sub_10020307C((uint64_t)NFPeerPaymentAndPurpleTrustCALogger, v39);
          +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:&off_100322E20];
          (*(void (**)(void))(*(void *)(a1 + 48) + 16))();

LABEL_60:
          goto LABEL_26;
        }
        if (v18)
        {
          [*(id *)(a1 + 32) setKeys:0];
          uint64_t v44 = *(void *)(a1 + 48);
          v45 = [*(id *)(a1 + 32) deleteDBKey:v18];
          (*(void (**)(uint64_t, void *))(v44 + 16))(v44, v45);

          v46 = *(void **)(a1 + 32);
          id v75 = 0;
          id v47 = [v46 getNumberOfKeys:&v75];
          id v37 = v75;
          if (v37)
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v48 = NFLogGetLogger();
            if (v48)
            {
              uint64_t v49 = (void (*)(uint64_t, const char *, ...))v48;
              v50 = object_getClass(*(id *)(a1 + 32));
              BOOL v51 = class_isMetaClass(v50);
              uint64_t v52 = object_getClassName(*(id *)(a1 + 32));
              id v74 = sel_getName(*(SEL *)(a1 + 56));
              uint64_t v53 = 45;
              if (v51) {
                uint64_t v53 = 43;
              }
              v49(3, "%c[%{public}s %{public}s]:%i Could not get number of keys to post CA notification", v53, v52, v74, 605);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v54 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
            {
              v55 = object_getClass(*(id *)(a1 + 32));
              if (class_isMetaClass(v55)) {
                int v56 = 43;
              }
              else {
                int v56 = 45;
              }
              v57 = object_getClassName(*(id *)(a1 + 32));
              v58 = sel_getName(*(SEL *)(a1 + 56));
              *(_DWORD *)buf = 67109890;
              int v90 = v56;
              __int16 v91 = 2082;
              v92 = v57;
              __int16 v93 = 2082;
              v94 = v58;
              __int16 v95 = 1024;
              int v96 = 605;
              _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Could not get number of keys to post CA notification", buf, 0x22u);
            }
          }
          else
          {
            CFStringRef v77 = @"totalPurpleTrustKeys";
            v54 = +[NSNumber numberWithUnsignedInteger:v47];
            v78 = v54;
            long long v72 = +[NSDictionary dictionaryWithObjects:&v78 forKeys:&v77 count:1];
            +[NFGeneralStatisticsCALogger updateGeneralDeviceStatistic:v72];
          }
          [*(id *)(a1 + 32) listKeysWithCompletion:&stru_100304068];
          goto LABEL_60;
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v59 = NFLogGetLogger();
        if (v59)
        {
          uint64_t v60 = (void (*)(uint64_t, const char *, ...))v59;
          v61 = object_getClass(*(id *)(a1 + 32));
          BOOL v62 = class_isMetaClass(v61);
          int v63 = object_getClassName(*(id *)(a1 + 32));
          v64 = sel_getName(*(SEL *)(a1 + 56));
          uint64_t v65 = 45;
          if (v62) {
            uint64_t v65 = 43;
          }
          v60(3, "%c[%{public}s %{public}s]:%i Could not find DB Key with identifier : %{public}@", v65, v63, v64, 575, *(void *)(a1 + 40));
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v66 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v66, OS_LOG_TYPE_ERROR))
        {
          v67 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v67)) {
            int v68 = 43;
          }
          else {
            int v68 = 45;
          }
          v69 = object_getClassName(*(id *)(a1 + 32));
          long long v70 = sel_getName(*(SEL *)(a1 + 56));
          long long v71 = *(void **)(a1 + 40);
          *(_DWORD *)buf = 67110146;
          int v90 = v68;
          __int16 v91 = 2082;
          v92 = v69;
          __int16 v93 = 2082;
          v94 = v70;
          __int16 v95 = 1024;
          int v96 = 575;
          __int16 v97 = 2114;
          id v98 = v71;
          _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Could not find DB Key with identifier : %{public}@", buf, 0x2Cu);
        }

        id v18 = sub_100140D38(*(void **)(a1 + 40));
        v79[0] = @"purpleTrustOperationType";
        v79[1] = @"purpleTrustOperationErrorStep";
        v80[0] = &off_10031B328;
        v80[1] = &off_10031B3D0;
        v80[2] = &off_10031B3E8;
        v79[2] = @"purpleTrustOperationCAErrorCode";
        v79[3] = @"purpleTrustOperationErrorCode";
        v41 = +[NSNumber numberWithInteger:[v18 code]];
        v80[3] = v41;
        uint64_t v42 = v80;
        int v43 = v79;
      }
      else
      {
        id v18 = sub_100140F40(@"keyIdentifier is nil");
        v83[0] = @"purpleTrustOperationType";
        v83[1] = @"purpleTrustOperationErrorStep";
        v84[0] = &off_10031B328;
        v84[1] = &off_10031B328;
        v84[2] = &off_10031B3B8;
        v83[2] = @"purpleTrustOperationCAErrorCode";
        v83[3] = @"purpleTrustOperationErrorCode";
        v41 = +[NSNumber numberWithInteger:[v18 code]];
        v84[3] = v41;
        uint64_t v42 = v84;
        int v43 = v83;
      }
      v19 = +[NSDictionary dictionaryWithObjects:v42 forKeys:v43 count:4];

      sub_10020307C((uint64_t)NFPeerPaymentAndPurpleTrustCALogger, v19);
    }
    else
    {
      id v18 = sub_100140A54();
      v85[0] = @"purpleTrustOperationType";
      v85[1] = @"purpleTrustOperationErrorStep";
      v86[0] = &off_10031B328;
      v86[1] = &off_10031B328;
      v86[2] = &off_10031B340;
      v85[2] = @"purpleTrustOperationCAErrorCode";
      v85[3] = @"purpleTrustOperationErrorCode";
      id v40 = +[NSNumber numberWithInteger:[v18 code]];
      v86[3] = v40;
      v19 = +[NSDictionary dictionaryWithObjects:v86 forKeys:v85 count:4];

      sub_10020307C((uint64_t)NFPeerPaymentAndPurpleTrustCALogger, v19);
      +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:&off_100322DF8];
    }
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    goto LABEL_16;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v2 = NFLogGetLogger();
  if (v2)
  {
    v3 = (void (*)(uint64_t, const char *, ...))v2;
    v4 = object_getClass(*(id *)(a1 + 32));
    BOOL v5 = class_isMetaClass(v4);
    id v6 = object_getClassName(*(id *)(a1 + 32));
    v7 = sel_getName(*(SEL *)(a1 + 56));
    v8 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v9 = 45;
    if (v5) {
      uint64_t v9 = 43;
    }
    v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, v6, v7, 504, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    id v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    v13 = object_getClassName(*(id *)(a1 + 32));
    v14 = sel_getName(*(SEL *)(a1 + 56));
    id v15 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)buf = 67110146;
    int v90 = v12;
    __int16 v91 = 2082;
    v92 = v13;
    __int16 v93 = 2082;
    v94 = v14;
    __int16 v95 = 1024;
    int v96 = 504;
    __int16 v97 = 2114;
    id v98 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v16 = *(void *)(a1 + 48);
  if (v16)
  {
    id v17 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v87 = NSLocalizedDescriptionKey;
    v19 = +[NSString stringWithUTF8String:"Session not active"];
    long long v88 = v19;
    uint64_t v20 = +[NSDictionary dictionaryWithObjects:&v88 forKeys:&v87 count:1];
    id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
    (*(void (**)(uint64_t, id))(v16 + 16))(v16, v21);

LABEL_16:
LABEL_26:
  }
}

void sub_1000D72AC(uint64_t a1)
{
  if (!*(void *)(a1 + 56))
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      v23 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 64));
      uint64_t v27 = 45;
      if (isMetaClass) {
        uint64_t v27 = 43;
      }
      v23(3, "%c[%{public}s %{public}s]:%i Could not create Key with nil callback", v27, ClassName, Name, 631);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v18 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      uint64_t v28 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v28)) {
        int v29 = 43;
      }
      else {
        int v29 = 45;
      }
      v30 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v31 = sel_getName(*(SEL *)(a1 + 64));
      *(_DWORD *)buf = 67109890;
      int v301 = v29;
      __int16 v302 = 2082;
      v303 = v30;
      __int16 v304 = 2082;
      v305 = v31;
      __int16 v306 = 1024;
      int v307 = 631;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Could not create Key with nil callback", buf, 0x22u);
    }
    goto LABEL_26;
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    uint64_t v32 = [*(id *)(a1 + 32) trustDB];
    if (v32)
    {
      uint64_t v33 = (void *)v32;
      BOOL v34 = [*(id *)(a1 + 32) trustDBApplet];

      if (v34)
      {
        v35 = *(void **)(a1 + 32);
        id v269 = 0;
        id v36 = [v35 getNumberOfKeys:&v269];
        id v37 = v269;
        if (v37)
        {
          id v18 = v37;
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v38 = NFLogGetLogger();
          if (v38)
          {
            int v39 = (void (*)(uint64_t, const char *, ...))v38;
            id v40 = object_getClass(*(id *)(a1 + 32));
            BOOL v41 = class_isMetaClass(v40);
            v238 = object_getClassName(*(id *)(a1 + 32));
            v250 = sel_getName(*(SEL *)(a1 + 64));
            uint64_t v42 = 45;
            if (v41) {
              uint64_t v42 = 43;
            }
            v39(3, "%c[%{public}s %{public}s]:%i Could not createKey, could not get current number of keys : %{public}@", v42, v238, v250, 663, v18);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          int v43 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
          {
            uint64_t v44 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v44)) {
              int v45 = 43;
            }
            else {
              int v45 = 45;
            }
            v46 = object_getClassName(*(id *)(a1 + 32));
            id v47 = sel_getName(*(SEL *)(a1 + 64));
            *(_DWORD *)buf = 67110146;
            int v301 = v45;
            __int16 v302 = 2082;
            v303 = v46;
            __int16 v304 = 2082;
            v305 = v47;
            __int16 v306 = 1024;
            int v307 = 663;
            __int16 v308 = 2114;
            v309 = v18;
            _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Could not createKey, could not get current number of keys : %{public}@", buf, 0x2Cu);
          }

          uint64_t v48 = *(void *)(a1 + 56);
          uint64_t v49 = sub_100140860(&stru_100309C40);
          (*(void (**)(uint64_t, void, NSObject *))(v48 + 16))(v48, 0, v49);
          goto LABEL_41;
        }
        if ((unint64_t)v36 >= 2)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v54 = NFLogGetLogger();
          if (v54)
          {
            v55 = (void (*)(uint64_t, const char *, ...))v54;
            int v56 = object_getClass(*(id *)(a1 + 32));
            BOOL v57 = class_isMetaClass(v56);
            v58 = object_getClassName(*(id *)(a1 + 32));
            v251 = sel_getName(*(SEL *)(a1 + 64));
            uint64_t v59 = 45;
            if (v57) {
              uint64_t v59 = 43;
            }
            v55(3, "%c[%{public}s %{public}s]:%i Could not createKey, maximum number of keys reached", v59, v58, v251, 669);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v60 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
          {
            v61 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v61)) {
              int v62 = 43;
            }
            else {
              int v62 = 45;
            }
            int v63 = object_getClassName(*(id *)(a1 + 32));
            v64 = sel_getName(*(SEL *)(a1 + 64));
            *(_DWORD *)buf = 67109890;
            int v301 = v62;
            __int16 v302 = 2082;
            v303 = v63;
            __int16 v304 = 2082;
            v305 = v64;
            __int16 v306 = 1024;
            int v307 = 669;
            _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Could not createKey, maximum number of keys reached", buf, 0x22u);
          }

          uint64_t v65 = *(void *)(a1 + 56);
          id v18 = sub_100140C34(@"create key");
          (*(void (**)(uint64_t, void, NSObject *))(v65 + 16))(v65, 0, v18);
          goto LABEL_26;
        }
        if (*(void *)(a1 + 40))
        {
          if (*(void *)(a1 + 48))
          {
            v66 = [*(id *)(a1 + 32) trustDB];
            v67 = *(void **)(a1 + 40);
            id v268 = 0;
            id v18 = sub_100033858(v66, v67, &v268);
            uint64_t v49 = v268;

            if (v18)
            {
              v290[0] = @"purpleTrustOperationType";
              v290[1] = @"purpleTrustOperationErrorStep";
              v291[0] = &off_10031B400;
              v291[1] = &off_10031B418;
              v291[2] = &off_10031B340;
              v290[2] = @"purpleTrustOperationCAErrorCode";
              v290[3] = @"purpleTrustOperationErrorCode";
              int v68 = +[NSNumber numberWithInteger:[v18 code]];
              v291[3] = v68;
              v69 = +[NSDictionary dictionaryWithObjects:v291 forKeys:v290 count:4];

              sub_10020307C((uint64_t)NFPeerPaymentAndPurpleTrustCALogger, v69);
              +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:&off_100322E70];
LABEL_59:
              (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
LABEL_65:

LABEL_41:
              goto LABEL_26;
            }
            if (v49)
            {
              id v18 = sub_100140E3C(*(void **)(a1 + 40));
              v288[0] = @"purpleTrustOperationType";
              v288[1] = @"purpleTrustOperationErrorStep";
              v289[0] = &off_10031B400;
              v289[1] = &off_10031B418;
              v289[2] = &off_10031B430;
              v288[2] = @"purpleTrustOperationCAErrorCode";
              v288[3] = @"purpleTrustOperationErrorCode";
              long long v73 = +[NSNumber numberWithInteger:[v18 code]];
              v289[3] = v73;
              v69 = +[NSDictionary dictionaryWithObjects:v289 forKeys:v288 count:4];

              sub_10020307C((uint64_t)NFPeerPaymentAndPurpleTrustCALogger, v69);
              uint64_t v74 = *(void *)(a1 + 56);
              id v75 = sub_100140E3C(*(void **)(a1 + 40));
              (*(void (**)(uint64_t, void, void *))(v74 + 16))(v74, 0, v75);

              goto LABEL_65;
            }
            id v76 = *(void **)(a1 + 40);
            CFStringRef v77 = [*(id *)(a1 + 32) applicationIdentifier];
            v78 = [*(id *)(a1 + 32) trustDBApplet];
            int v79 = sub_1000330DC(v78);
            uint64_t v49 = sub_100034D04((uint64_t)NFTrustDBKey, v76, v77, v79, *(void **)(a1 + 48));

            if (v49)
            {
              uint64_t v80 = [*(id *)(a1 + 32) selectInstance];
              if (v80)
              {
                id v18 = v80;
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v81 = NFLogGetLogger();
                if (v81)
                {
                  __int16 v82 = (void (*)(uint64_t, const char *, ...))v81;
                  uint64_t v83 = object_getClass(*(id *)(a1 + 32));
                  BOOL v84 = class_isMetaClass(v83);
                  v239 = object_getClassName(*(id *)(a1 + 32));
                  v252 = sel_getName(*(SEL *)(a1 + 64));
                  uint64_t v85 = 45;
                  if (v84) {
                    uint64_t v85 = 43;
                  }
                  v82(3, "%c[%{public}s %{public}s]:%i Failed to select instance : %{public}@", v85, v239, v252, 787, v18);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                __int16 v86 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
                {
                  NSErrorUserInfoKey v87 = object_getClass(*(id *)(a1 + 32));
                  if (class_isMetaClass(v87)) {
                    int v88 = 43;
                  }
                  else {
                    int v88 = 45;
                  }
                  v89 = object_getClassName(*(id *)(a1 + 32));
                  int v90 = sel_getName(*(SEL *)(a1 + 64));
                  *(_DWORD *)buf = 67110146;
                  int v301 = v88;
                  __int16 v302 = 2082;
                  v303 = v89;
                  __int16 v304 = 2082;
                  v305 = v90;
                  __int16 v306 = 1024;
                  int v307 = 787;
                  __int16 v308 = 2114;
                  v309 = v18;
                  _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select instance : %{public}@", buf, 0x2Cu);
                }

                v284[0] = @"purpleTrustOperationType";
                v284[1] = @"purpleTrustOperationErrorStep";
                v285[0] = &off_10031B400;
                v285[1] = &off_10031B478;
                v285[2] = &off_10031B490;
                v284[2] = @"purpleTrustOperationCAErrorCode";
                v284[3] = @"purpleTrustOperationErrorCode";
                __int16 v91 = +[NSNumber numberWithInteger:[v18 code]];
                v285[3] = v91;
                v69 = +[NSDictionary dictionaryWithObjects:v285 forKeys:v284 count:4];

                sub_10020307C((uint64_t)NFPeerPaymentAndPurpleTrustCALogger, v69);
                goto LABEL_59;
              }
              v104 = [*(id *)(a1 + 32) trustDBApplet];
              id v267 = 0;
              id v18 = sub_100034120(v104, &v267);
              id v105 = v267;

              if (v18)
              {
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v106 = NFLogGetLogger();
                if (v106)
                {
                  v107 = (void (*)(uint64_t, const char *, ...))v106;
                  v108 = object_getClass(*(id *)(a1 + 32));
                  BOOL v109 = class_isMetaClass(v108);
                  v240 = object_getClassName(*(id *)(a1 + 32));
                  v254 = sel_getName(*(SEL *)(a1 + 64));
                  uint64_t v110 = 45;
                  if (v109) {
                    uint64_t v110 = 43;
                  }
                  v107(3, "%c[%{public}s %{public}s]:%i Failed to get slot for new key : %{public}@", v110, v240, v254, 807, v18);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v111 = NFSharedLogGetLogger();
                if (!os_log_type_enabled(v111, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_109;
                }
                v112 = object_getClass(*(id *)(a1 + 32));
                if (class_isMetaClass(v112)) {
                  int v113 = 43;
                }
                else {
                  int v113 = 45;
                }
                v114 = object_getClassName(*(id *)(a1 + 32));
                v115 = sel_getName(*(SEL *)(a1 + 64));
                *(_DWORD *)buf = 67110146;
                int v301 = v113;
                __int16 v302 = 2082;
                v303 = v114;
                __int16 v304 = 2082;
                v305 = v115;
                __int16 v306 = 1024;
                int v307 = 807;
                __int16 v308 = 2114;
                v309 = v18;
                v116 = "%c[%{public}s %{public}s]:%i Failed to get slot for new key : %{public}@";
LABEL_108:
                _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_ERROR, v116, buf, 0x2Cu);
LABEL_109:

                (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
LABEL_110:

                goto LABEL_41;
              }
              v117 = [*(id *)(a1 + 32) trustDBApplet];
              id v18 = sub_100034610(v117, v105);

              if (v18)
              {
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v118 = NFLogGetLogger();
                if (v118)
                {
                  v119 = (void (*)(uint64_t, const char *, ...))v118;
                  v120 = object_getClass(*(id *)(a1 + 32));
                  BOOL v121 = class_isMetaClass(v120);
                  v241 = object_getClassName(*(id *)(a1 + 32));
                  v255 = sel_getName(*(SEL *)(a1 + 64));
                  uint64_t v122 = 45;
                  if (v121) {
                    uint64_t v122 = 43;
                  }
                  v119(3, "%c[%{public}s %{public}s]:%i Failed to clean DB slot for new key : %{public}@", v122, v241, v255, 813, v18);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v111 = NFSharedLogGetLogger();
                if (!os_log_type_enabled(v111, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_109;
                }
                v123 = object_getClass(*(id *)(a1 + 32));
                if (class_isMetaClass(v123)) {
                  int v124 = 43;
                }
                else {
                  int v124 = 45;
                }
                v125 = object_getClassName(*(id *)(a1 + 32));
                v126 = sel_getName(*(SEL *)(a1 + 64));
                *(_DWORD *)buf = 67110146;
                int v301 = v124;
                __int16 v302 = 2082;
                v303 = v125;
                __int16 v304 = 2082;
                v305 = v126;
                __int16 v306 = 1024;
                int v307 = 813;
                __int16 v308 = 2114;
                v309 = v18;
                v116 = "%c[%{public}s %{public}s]:%i Failed to clean DB slot for new key : %{public}@";
                goto LABEL_108;
              }
              sub_10003554C((uint64_t)v49, v105);
              v127 = [*(id *)(a1 + 32) trustDB];
              id v18 = sub_1000331D0(v127, v49);

              if (v18)
              {
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v128 = NFLogGetLogger();
                if (v128)
                {
                  v129 = (void (*)(uint64_t, const char *, ...))v128;
                  v130 = object_getClass(*(id *)(a1 + 32));
                  BOOL v131 = class_isMetaClass(v130);
                  v242 = object_getClassName(*(id *)(a1 + 32));
                  v256 = sel_getName(*(SEL *)(a1 + 64));
                  uint64_t v132 = 45;
                  if (v131) {
                    uint64_t v132 = 43;
                  }
                  v129(3, "%c[%{public}s %{public}s]:%i Failed to add Key to NFTrustDB : %{public}@ -- Delete created key", v132, v242, v256, 822, v18);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v133 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v133, OS_LOG_TYPE_ERROR))
                {
                  v134 = object_getClass(*(id *)(a1 + 32));
                  if (class_isMetaClass(v134)) {
                    int v135 = 43;
                  }
                  else {
                    int v135 = 45;
                  }
                  v136 = object_getClassName(*(id *)(a1 + 32));
                  v137 = sel_getName(*(SEL *)(a1 + 64));
                  *(_DWORD *)buf = 67110146;
                  int v301 = v135;
                  __int16 v302 = 2082;
                  v303 = v136;
                  __int16 v304 = 2082;
                  v305 = v137;
                  __int16 v306 = 1024;
                  int v307 = 822;
                  __int16 v308 = 2114;
                  v309 = v18;
                  _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to add Key to NFTrustDB : %{public}@ -- Delete created key", buf, 0x2Cu);
                }

                v282[0] = @"purpleTrustOperationType";
                v282[1] = @"purpleTrustOperationErrorStep";
                v283[0] = &off_10031B400;
                v283[1] = &off_10031B4A8;
                v283[2] = &off_10031B340;
                v282[2] = @"purpleTrustOperationCAErrorCode";
                v282[3] = @"purpleTrustOperationErrorCode";
                v138 = +[NSNumber numberWithInteger:[v18 code]];
                v283[3] = v138;
                v139 = +[NSDictionary dictionaryWithObjects:v283 forKeys:v282 count:4];

                sub_10020307C((uint64_t)NFPeerPaymentAndPurpleTrustCALogger, v139);
                v140 = &off_100322E98;
LABEL_133:
                +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:v140];
                (*(void (**)(void))(*(void *)(a1 + 56) + 16))();

                goto LABEL_110;
              }
              v141 = [*(id *)(a1 + 32) trustDB];
              id v18 = sub_1000322DC((uint64_t)v141);

              if (v18)
              {
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v142 = NFLogGetLogger();
                if (v142)
                {
                  v143 = (void (*)(uint64_t, const char *, ...))v142;
                  v144 = object_getClass(*(id *)(a1 + 32));
                  BOOL v145 = class_isMetaClass(v144);
                  v243 = object_getClassName(*(id *)(a1 + 32));
                  v257 = sel_getName(*(SEL *)(a1 + 64));
                  uint64_t v146 = 45;
                  if (v145) {
                    uint64_t v146 = 43;
                  }
                  v143(3, "%c[%{public}s %{public}s]:%i Failed to commit NFTrustDB : %{public}@ -- Delete created key", v146, v243, v257, 844, v18);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v147 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v147, OS_LOG_TYPE_ERROR))
                {
                  v148 = object_getClass(*(id *)(a1 + 32));
                  if (class_isMetaClass(v148)) {
                    int v149 = 43;
                  }
                  else {
                    int v149 = 45;
                  }
                  v150 = object_getClassName(*(id *)(a1 + 32));
                  v151 = sel_getName(*(SEL *)(a1 + 64));
                  *(_DWORD *)buf = 67110146;
                  int v301 = v149;
                  __int16 v302 = 2082;
                  v303 = v150;
                  __int16 v304 = 2082;
                  v305 = v151;
                  __int16 v306 = 1024;
                  int v307 = 844;
                  __int16 v308 = 2114;
                  v309 = v18;
                  _os_log_impl((void *)&_mh_execute_header, v147, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to commit NFTrustDB : %{public}@ -- Delete created key", buf, 0x2Cu);
                }

                v280[0] = @"purpleTrustOperationType";
                v280[1] = @"purpleTrustOperationErrorStep";
                v281[0] = &off_10031B400;
                v281[1] = &off_10031B4A8;
                v281[2] = &off_10031B340;
                v280[2] = @"purpleTrustOperationCAErrorCode";
                v280[3] = @"purpleTrustOperationErrorCode";
                v152 = +[NSNumber numberWithInteger:[v18 code]];
                v281[3] = v152;
                v139 = +[NSDictionary dictionaryWithObjects:v281 forKeys:v280 count:4];

                sub_10020307C((uint64_t)NFPeerPaymentAndPurpleTrustCALogger, v139);
                v140 = &off_100322EC0;
                goto LABEL_133;
              }
              v153 = NFSharedSignpostLog();
              if (os_signpost_enabled(v153))
              {
                *(_WORD *)buf = 0;
                _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v153, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "createKeyInSlot", (const char *)&unk_100286819, buf, 2u);
              }

              v154 = [*(id *)(a1 + 32) secureElementWrapper];
              v155 = *(void **)(a1 + 48);
              id v266 = 0;
              id v18 = sub_1000BCA40(v154, v105, v155, &v266);
              id v264 = v266;

              v156 = NFSharedSignpostLog();
              BOOL v157 = os_signpost_enabled(v156);
              if (v18)
              {
                if (v157)
                {
                  *(_WORD *)buf = 0;
                  _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v156, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "createKeyInSlot", "failed", buf, 2u);
                }

                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v158 = NFLogGetLogger();
                if (v158)
                {
                  v159 = (void (*)(uint64_t, const char *, ...))v158;
                  v160 = object_getClass(*(id *)(a1 + 32));
                  BOOL v161 = class_isMetaClass(v160);
                  v244 = object_getClassName(*(id *)(a1 + 32));
                  v258 = sel_getName(*(SEL *)(a1 + 64));
                  uint64_t v162 = 45;
                  if (v161) {
                    uint64_t v162 = 43;
                  }
                  v159(3, "%c[%{public}s %{public}s]:%i Failed to create Key : %{public}@ ...", v162, v244, v258, 872, v18);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v163 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v163, OS_LOG_TYPE_ERROR))
                {
                  v164 = object_getClass(*(id *)(a1 + 32));
                  if (class_isMetaClass(v164)) {
                    int v165 = 43;
                  }
                  else {
                    int v165 = 45;
                  }
                  v166 = object_getClassName(*(id *)(a1 + 32));
                  v167 = sel_getName(*(SEL *)(a1 + 64));
                  *(_DWORD *)buf = 67110146;
                  int v301 = v165;
                  __int16 v302 = 2082;
                  v303 = v166;
                  __int16 v304 = 2082;
                  v305 = v167;
                  __int16 v306 = 1024;
                  int v307 = 872;
                  __int16 v308 = 2114;
                  v309 = v18;
                  _os_log_impl((void *)&_mh_execute_header, v163, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to create Key : %{public}@ ...", buf, 0x2Cu);
                }

                v278[0] = @"purpleTrustOperationType";
                v278[1] = @"purpleTrustOperationErrorStep";
                v279[0] = &off_10031B400;
                v279[1] = &off_10031B4C0;
                v279[2] = &off_10031B4D8;
                v278[2] = @"purpleTrustOperationCAErrorCode";
                v278[3] = @"purpleTrustOperationErrorCode";
                v168 = +[NSNumber numberWithInteger:[v18 code]];
                v279[3] = v168;
                v169 = +[NSDictionary dictionaryWithObjects:v279 forKeys:v278 count:4];

                sub_10020307C((uint64_t)NFPeerPaymentAndPurpleTrustCALogger, v169);
                v170 = [*(id *)(a1 + 32) deleteDBKey:v49];
                if (v170)
                {
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  uint64_t v171 = NFLogGetLogger();
                  if (v171)
                  {
                    v172 = (void (*)(uint64_t, const char *, ...))v171;
                    v173 = object_getClass(*(id *)(a1 + 32));
                    BOOL v174 = class_isMetaClass(v173);
                    v245 = object_getClassName(*(id *)(a1 + 32));
                    v259 = sel_getName(*(SEL *)(a1 + 64));
                    uint64_t v175 = 45;
                    if (v174) {
                      uint64_t v175 = 43;
                    }
                    v172(3, "%c[%{public}s %{public}s]:%i Failed to delete DB key after creation failure : %{public}@", v175, v245, v259, 888, v170);
                  }
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  v176 = NFSharedLogGetLogger();
                  if (os_log_type_enabled(v176, OS_LOG_TYPE_ERROR))
                  {
                    v177 = object_getClass(*(id *)(a1 + 32));
                    if (class_isMetaClass(v177)) {
                      int v178 = 43;
                    }
                    else {
                      int v178 = 45;
                    }
                    v179 = object_getClassName(*(id *)(a1 + 32));
                    v180 = sel_getName(*(SEL *)(a1 + 64));
                    *(_DWORD *)buf = 67110146;
                    int v301 = v178;
                    __int16 v302 = 2082;
                    v303 = v179;
                    __int16 v304 = 2082;
                    v305 = v180;
                    __int16 v306 = 1024;
                    int v307 = 888;
                    __int16 v308 = 2114;
                    v309 = v170;
                    _os_log_impl((void *)&_mh_execute_header, v176, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to delete DB key after creation failure : %{public}@", buf, 0x2Cu);
                  }

                  v276[0] = @"purpleTrustOperationType";
                  v276[1] = @"purpleTrustOperationErrorStep";
                  v277[0] = &off_10031B400;
                  v277[1] = &off_10031B4C0;
                  v277[2] = &off_10031B4F0;
                  v276[2] = @"purpleTrustOperationCAErrorCode";
                  v276[3] = @"purpleTrustOperationErrorCode";
                  v181 = +[NSNumber numberWithInteger:[v170 code]];
                  v277[3] = v181;
                  v182 = +[NSDictionary dictionaryWithObjects:v277 forKeys:v276 count:4];

                  sub_10020307C((uint64_t)NFPeerPaymentAndPurpleTrustCALogger, v182);
                  +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:&off_100322EE8];
                  v169 = v182;
                }
                (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
              }
              else
              {
                if (v157)
                {
                  *(_WORD *)buf = 0;
                  _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v156, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "createKeyInSlot", (const char *)&unk_100286819, buf, 2u);
                }

                v183 = [*(id *)(a1 + 32) secureElementWrapper];
                v184 = [v183 eccCertificate];
                sub_10003551C((uint64_t)v49, v184);

                sub_100035534((uint64_t)v49, v264);
                v185 = [*(id *)(a1 + 32) trustDBApplet];
                v186 = sub_100034468(v185, v49, v105);

                if (v186)
                {
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  uint64_t v187 = NFLogGetLogger();
                  if (v187)
                  {
                    v188 = (void (*)(uint64_t, const char *, ...))v187;
                    v189 = object_getClass(*(id *)(a1 + 32));
                    BOOL v190 = class_isMetaClass(v189);
                    v246 = object_getClassName(*(id *)(a1 + 32));
                    v260 = sel_getName(*(SEL *)(a1 + 64));
                    uint64_t v191 = 45;
                    if (v190) {
                      uint64_t v191 = 43;
                    }
                    v188(4, "%c[%{public}s %{public}s]:%i Failed to push Key in DB slot, will need to push it again next time : %{public}@ ...", v191, v246, v260, 914, v186);
                  }
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  v192 = NFSharedLogGetLogger();
                  if (os_log_type_enabled(v192, OS_LOG_TYPE_ERROR))
                  {
                    v193 = object_getClass(*(id *)(a1 + 32));
                    if (class_isMetaClass(v193)) {
                      int v194 = 43;
                    }
                    else {
                      int v194 = 45;
                    }
                    v195 = object_getClassName(*(id *)(a1 + 32));
                    v196 = sel_getName(*(SEL *)(a1 + 64));
                    *(_DWORD *)buf = 67110146;
                    int v301 = v194;
                    __int16 v302 = 2082;
                    v303 = v195;
                    __int16 v304 = 2082;
                    v305 = v196;
                    __int16 v306 = 1024;
                    int v307 = 914;
                    __int16 v308 = 2114;
                    v309 = v186;
                    _os_log_impl((void *)&_mh_execute_header, v192, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to push Key in DB slot, will need to push it again next time : %{public}@ ...", buf, 0x2Cu);
                  }
                }
                v197 = [*(id *)(a1 + 32) trustDB];
                id v18 = sub_1000322DC((uint64_t)v197);

                if (!v18)
                {
                  [*(id *)(a1 + 32) setKeys:0];
                  uint64_t v221 = *(void *)(a1 + 56);
                  v222 = sub_100035410((uint64_t)v49);
                  (*(void (**)(uint64_t, void *, void))(v221 + 16))(v221, v222, 0);

                  v223 = *(void **)(a1 + 32);
                  id v265 = 0;
                  id v224 = [v223 getNumberOfKeys:&v265];
                  v225 = v265;
                  if (!v225)
                  {
                    CFStringRef v270 = @"totalPurpleTrustKeys";
                    v236 = +[NSNumber numberWithUnsignedInteger:v224];
                    v271 = v236;
                    v237 = +[NSDictionary dictionaryWithObjects:&v271 forKeys:&v270 count:1];
                    +[NFGeneralStatisticsCALogger updateGeneralDeviceStatistic:v237];

                    id v18 = v49;
                    goto LABEL_26;
                  }
                  id v18 = v225;
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  uint64_t v226 = NFLogGetLogger();
                  if (v226)
                  {
                    v227 = (void (*)(uint64_t, const char *, ...))v226;
                    v228 = object_getClass(*(id *)(a1 + 32));
                    BOOL v229 = class_isMetaClass(v228);
                    v230 = object_getClassName(*(id *)(a1 + 32));
                    v263 = sel_getName(*(SEL *)(a1 + 64));
                    uint64_t v231 = 45;
                    if (v229) {
                      uint64_t v231 = 43;
                    }
                    v227(3, "%c[%{public}s %{public}s]:%i Could not get number of keys to post CA notification", v231, v230, v263, 977);
                  }
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  v169 = NFSharedLogGetLogger();
                  if (os_log_type_enabled(v169, OS_LOG_TYPE_ERROR))
                  {
                    v232 = object_getClass(*(id *)(a1 + 32));
                    if (class_isMetaClass(v232)) {
                      int v233 = 43;
                    }
                    else {
                      int v233 = 45;
                    }
                    v234 = object_getClassName(*(id *)(a1 + 32));
                    v235 = sel_getName(*(SEL *)(a1 + 64));
                    *(_DWORD *)buf = 67109890;
                    int v301 = v233;
                    __int16 v302 = 2082;
                    v303 = v234;
                    __int16 v304 = 2082;
                    v305 = v235;
                    __int16 v306 = 1024;
                    int v307 = 977;
                    _os_log_impl((void *)&_mh_execute_header, v169, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Could not get number of keys to post CA notification", buf, 0x22u);
                  }
                  goto LABEL_196;
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v198 = NFLogGetLogger();
                if (v198)
                {
                  v199 = (void (*)(uint64_t, const char *, ...))v198;
                  v200 = object_getClass(*(id *)(a1 + 32));
                  BOOL v201 = class_isMetaClass(v200);
                  v247 = object_getClassName(*(id *)(a1 + 32));
                  v261 = sel_getName(*(SEL *)(a1 + 64));
                  uint64_t v202 = 45;
                  if (v201) {
                    uint64_t v202 = 43;
                  }
                  v199(3, "%c[%{public}s %{public}s]:%i Failed to commit NFTrustDB : %{public}@ -- Delete created key", v202, v247, v261, 919, v18);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                v203 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v203, OS_LOG_TYPE_ERROR))
                {
                  v204 = object_getClass(*(id *)(a1 + 32));
                  if (class_isMetaClass(v204)) {
                    int v205 = 43;
                  }
                  else {
                    int v205 = 45;
                  }
                  v206 = object_getClassName(*(id *)(a1 + 32));
                  v207 = sel_getName(*(SEL *)(a1 + 64));
                  *(_DWORD *)buf = 67110146;
                  int v301 = v205;
                  __int16 v302 = 2082;
                  v303 = v206;
                  __int16 v304 = 2082;
                  v305 = v207;
                  __int16 v306 = 1024;
                  int v307 = 919;
                  __int16 v308 = 2114;
                  v309 = v18;
                  _os_log_impl((void *)&_mh_execute_header, v203, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to commit NFTrustDB : %{public}@ -- Delete created key", buf, 0x2Cu);
                }

                v274[0] = @"purpleTrustOperationType";
                v274[1] = @"purpleTrustOperationErrorStep";
                v275[0] = &off_10031B400;
                v275[1] = &off_10031B508;
                v275[2] = &off_10031B340;
                v274[2] = @"purpleTrustOperationCAErrorCode";
                v274[3] = @"purpleTrustOperationErrorCode";
                v208 = +[NSNumber numberWithInteger:[v18 code]];
                v275[3] = v208;
                v169 = +[NSDictionary dictionaryWithObjects:v275 forKeys:v274 count:4];

                sub_10020307C((uint64_t)NFPeerPaymentAndPurpleTrustCALogger, v169);
                +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:&off_100322F10];
                v170 = [*(id *)(a1 + 32) deleteDBKey:v49];
                if (v170)
                {
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  uint64_t v209 = NFLogGetLogger();
                  if (v209)
                  {
                    v210 = (void (*)(uint64_t, const char *, ...))v209;
                    v211 = object_getClass(*(id *)(a1 + 32));
                    BOOL v212 = class_isMetaClass(v211);
                    v248 = object_getClassName(*(id *)(a1 + 32));
                    v262 = sel_getName(*(SEL *)(a1 + 64));
                    uint64_t v213 = 45;
                    if (v212) {
                      uint64_t v213 = 43;
                    }
                    v210(3, "%c[%{public}s %{public}s]:%i Failed to delete DB key after creation failure : %{public}@", v213, v248, v262, 937, v170);
                  }
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  v214 = NFSharedLogGetLogger();
                  if (os_log_type_enabled(v214, OS_LOG_TYPE_ERROR))
                  {
                    v215 = object_getClass(*(id *)(a1 + 32));
                    if (class_isMetaClass(v215)) {
                      int v216 = 43;
                    }
                    else {
                      int v216 = 45;
                    }
                    v217 = object_getClassName(*(id *)(a1 + 32));
                    v218 = sel_getName(*(SEL *)(a1 + 64));
                    *(_DWORD *)buf = 67110146;
                    int v301 = v216;
                    __int16 v302 = 2082;
                    v303 = v217;
                    __int16 v304 = 2082;
                    v305 = v218;
                    __int16 v306 = 1024;
                    int v307 = 937;
                    __int16 v308 = 2114;
                    v309 = v170;
                    _os_log_impl((void *)&_mh_execute_header, v214, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to delete DB key after creation failure : %{public}@", buf, 0x2Cu);
                  }

                  v272[0] = @"purpleTrustOperationType";
                  v272[1] = @"purpleTrustOperationErrorStep";
                  v273[0] = &off_10031B400;
                  v273[1] = &off_10031B508;
                  v273[2] = &off_10031B4F0;
                  v272[2] = @"purpleTrustOperationCAErrorCode";
                  v272[3] = @"purpleTrustOperationErrorCode";
                  v219 = +[NSNumber numberWithInteger:[v170 code]];
                  v273[3] = v219;
                  v220 = +[NSDictionary dictionaryWithObjects:v273 forKeys:v272 count:4];

                  sub_10020307C((uint64_t)NFPeerPaymentAndPurpleTrustCALogger, v220);
                  +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:&off_100322F38];
                  v169 = v220;
                }
                (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
                [*(id *)(a1 + 32) deselectInstance];
              }

LABEL_196:
              goto LABEL_110;
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v92 = NFLogGetLogger();
            if (v92)
            {
              __int16 v93 = (void (*)(uint64_t, const char *, ...))v92;
              v94 = object_getClass(*(id *)(a1 + 32));
              BOOL v95 = class_isMetaClass(v94);
              int v96 = object_getClassName(*(id *)(a1 + 32));
              v253 = sel_getName(*(SEL *)(a1 + 64));
              uint64_t v97 = 45;
              if (v95) {
                uint64_t v97 = 43;
              }
              v93(3, "%c[%{public}s %{public}s]:%i Could not create DB Key", v97, v96, v253, 763);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            id v98 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v98, OS_LOG_TYPE_ERROR))
            {
              __int16 v99 = object_getClass(*(id *)(a1 + 32));
              if (class_isMetaClass(v99)) {
                int v100 = 43;
              }
              else {
                int v100 = 45;
              }
              v101 = object_getClassName(*(id *)(a1 + 32));
              v102 = sel_getName(*(SEL *)(a1 + 64));
              *(_DWORD *)buf = 67109890;
              int v301 = v100;
              __int16 v302 = 2082;
              v303 = v101;
              __int16 v304 = 2082;
              v305 = v102;
              __int16 v306 = 1024;
              int v307 = 763;
              _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Could not create DB Key", buf, 0x22u);
            }

            id v18 = sub_100140860(&stru_100309C40);
            v286[0] = @"purpleTrustOperationType";
            v286[1] = @"purpleTrustOperationErrorStep";
            v287[0] = &off_10031B400;
            v287[1] = &off_10031B448;
            v287[2] = &off_10031B460;
            v286[2] = @"purpleTrustOperationCAErrorCode";
            v286[3] = @"purpleTrustOperationErrorCode";
            v103 = +[NSNumber numberWithInteger:[v18 code]];
            v287[3] = v103;
            v19 = +[NSDictionary dictionaryWithObjects:v287 forKeys:v286 count:4];

            sub_10020307C((uint64_t)NFPeerPaymentAndPurpleTrustCALogger, v19);
            uint64_t v51 = *(void *)(a1 + 56);
            uint64_t v52 = sub_100140860(@"Could not create DB Key");
LABEL_43:
            uint64_t v53 = (void *)v52;
            (*(void (**)(uint64_t, void, uint64_t))(v51 + 16))(v51, 0, v52);

            goto LABEL_16;
          }
          id v18 = sub_100140A54();
          v292[0] = @"purpleTrustOperationType";
          v292[1] = @"purpleTrustOperationErrorStep";
          v293[0] = &off_10031B400;
          v293[1] = &off_10031B400;
          v293[2] = &off_10031B3B8;
          v292[2] = @"purpleTrustOperationCAErrorCode";
          v292[3] = @"purpleTrustOperationErrorCode";
          long long v72 = +[NSNumber numberWithInteger:[v18 code]];
          v293[3] = v72;
          v19 = +[NSDictionary dictionaryWithObjects:v293 forKeys:v292 count:4];

          sub_10020307C((uint64_t)NFPeerPaymentAndPurpleTrustCALogger, v19);
          uint64_t v51 = *(void *)(a1 + 56);
          long long v71 = @"Could not create key with nil request";
        }
        else
        {
          id v18 = sub_100140A54();
          v294[0] = @"purpleTrustOperationType";
          v294[1] = @"purpleTrustOperationErrorStep";
          v295[0] = &off_10031B400;
          v295[1] = &off_10031B400;
          v295[2] = &off_10031B3B8;
          v294[2] = @"purpleTrustOperationCAErrorCode";
          v294[3] = @"purpleTrustOperationErrorCode";
          long long v70 = +[NSNumber numberWithInteger:[v18 code]];
          v295[3] = v70;
          v19 = +[NSDictionary dictionaryWithObjects:v295 forKeys:v294 count:4];

          sub_10020307C((uint64_t)NFPeerPaymentAndPurpleTrustCALogger, v19);
          uint64_t v51 = *(void *)(a1 + 56);
          long long v71 = @"Could not create key with nil identifier";
        }
        uint64_t v52 = sub_100140F40(v71);
        goto LABEL_43;
      }
    }
    id v18 = sub_100140A54();
    v296[0] = @"purpleTrustOperationType";
    v296[1] = @"purpleTrustOperationErrorStep";
    v297[0] = &off_10031B400;
    v297[1] = &off_10031B400;
    v297[2] = &off_10031B340;
    v296[2] = @"purpleTrustOperationCAErrorCode";
    v296[3] = @"purpleTrustOperationErrorCode";
    v50 = +[NSNumber numberWithInteger:[v18 code]];
    v297[3] = v50;
    v19 = +[NSDictionary dictionaryWithObjects:v297 forKeys:v296 count:4];

    sub_10020307C((uint64_t)NFPeerPaymentAndPurpleTrustCALogger, v19);
    +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:&off_100322E48];
    uint64_t v51 = *(void *)(a1 + 56);
    uint64_t v52 = sub_100140A54();
    goto LABEL_43;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v2 = NFLogGetLogger();
  if (v2)
  {
    v3 = (void (*)(uint64_t, const char *, ...))v2;
    v4 = object_getClass(*(id *)(a1 + 32));
    BOOL v5 = class_isMetaClass(v4);
    id v6 = object_getClassName(*(id *)(a1 + 32));
    v7 = sel_getName(*(SEL *)(a1 + 64));
    v8 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v9 = 45;
    if (v5) {
      uint64_t v9 = 43;
    }
    v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, v6, v7, 635, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    id v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    v13 = object_getClassName(*(id *)(a1 + 32));
    v14 = sel_getName(*(SEL *)(a1 + 64));
    id v15 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)buf = 67110146;
    int v301 = v12;
    __int16 v302 = 2082;
    v303 = v13;
    __int16 v304 = 2082;
    v305 = v14;
    __int16 v306 = 1024;
    int v307 = 635;
    __int16 v308 = 2114;
    v309 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v16 = *(void *)(a1 + 56);
  if (v16)
  {
    id v17 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v298 = NSLocalizedDescriptionKey;
    v19 = +[NSString stringWithUTF8String:"Session not active"];
    v299 = v19;
    uint64_t v20 = +[NSDictionary dictionaryWithObjects:&v299 forKeys:&v298 count:1];
    id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
    (*(void (**)(uint64_t, void, id))(v16 + 16))(v16, 0, v21);

LABEL_16:
LABEL_26:
  }
}

void sub_1000D97A4(uint64_t a1)
{
  if (!*(void *)(a1 + 72))
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      v23 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 80));
      uint64_t v27 = 45;
      if (isMetaClass) {
        uint64_t v27 = 43;
      }
      v23(3, "%c[%{public}s %{public}s]:%i Could not sign with nil callback", v27, ClassName, Name, 999);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v18 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      uint64_t v28 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v28)) {
        int v29 = 43;
      }
      else {
        int v29 = 45;
      }
      v30 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v31 = sel_getName(*(SEL *)(a1 + 80));
      *(_DWORD *)buf = 67109890;
      int v283 = v29;
      __int16 v284 = 2082;
      v285 = v30;
      __int16 v286 = 2082;
      v287 = v31;
      __int16 v288 = 1024;
      int v289 = 999;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Could not sign with nil callback", buf, 0x22u);
    }
    goto LABEL_26;
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    uint64_t v32 = [*(id *)(a1 + 32) trustDB];
    if (v32
      && (uint64_t v33 = (void *)v32,
          [*(id *)(a1 + 32) trustDBApplet],
          BOOL v34 = objc_claimAutoreleasedReturnValue(),
          v34,
          v33,
          v34))
    {
      if (*(void *)(a1 + 40))
      {
        v35 = [*(id *)(a1 + 32) trustDB];
        id v36 = *(void **)(a1 + 40);
        id v277 = 0;
        id v37 = sub_100033858(v35, v36, &v277);
        id v18 = v277;

        if (v37)
        {
          v308[0] = @"purpleTrustOperationType";
          v308[1] = @"purpleTrustOperationErrorStep";
          v309[0] = &off_10031B520;
          v309[1] = &off_10031B538;
          v309[2] = &off_10031B340;
          v308[2] = @"purpleTrustOperationCAErrorCode";
          v308[3] = @"purpleTrustOperationErrorCode";
          uint64_t v38 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [v37 code]);
          v309[3] = v38;
          int v39 = +[NSDictionary dictionaryWithObjects:v309 forKeys:v308 count:4];

          sub_10020307C((uint64_t)NFPeerPaymentAndPurpleTrustCALogger, v39);
          +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:&off_100322F88];
LABEL_33:
          (*(void (**)(void))(*(void *)(a1 + 72) + 16))();
LABEL_34:

LABEL_35:
          goto LABEL_26;
        }
        if (!v18)
        {
          id v18 = sub_100140D38(*(void **)(a1 + 40));
          v306[0] = @"purpleTrustOperationType";
          v306[1] = @"purpleTrustOperationErrorStep";
          v307[0] = &off_10031B520;
          v307[1] = &off_10031B538;
          v307[2] = &off_10031B3E8;
          v306[2] = @"purpleTrustOperationCAErrorCode";
          v306[3] = @"purpleTrustOperationErrorCode";
          uint64_t v60 = +[NSNumber numberWithInteger:[v18 code]];
          v307[3] = v60;
          v19 = +[NSDictionary dictionaryWithObjects:v307 forKeys:v306 count:4];

          sub_10020307C((uint64_t)NFPeerPaymentAndPurpleTrustCALogger, v19);
          (*(void (**)(void))(*(void *)(a1 + 72) + 16))();
          goto LABEL_16;
        }
        int v45 = v18[3].isa;

        if (!v45)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v61 = NFLogGetLogger();
          if (v61)
          {
            int v62 = (void (*)(uint64_t, const char *, ...))v61;
            int v63 = object_getClass(*(id *)(a1 + 32));
            BOOL v64 = class_isMetaClass(v63);
            uint64_t v65 = object_getClassName(*(id *)(a1 + 32));
            v66 = sel_getName(*(SEL *)(a1 + 80));
            v67 = v18[1].isa;
            uint64_t v68 = 45;
            if (v64) {
              uint64_t v68 = 43;
            }
            v62(3, "%c[%{public}s %{public}s]:%i Key %{public}@ has nil keyAttestation, looks like previous delete didn't finish correctly, try to delete again ...", v68, v65, v66, 1099, v67);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v69 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
          {
            long long v70 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v70)) {
              int v71 = 43;
            }
            else {
              int v71 = 45;
            }
            long long v72 = object_getClassName(*(id *)(a1 + 32));
            long long v73 = sel_getName(*(SEL *)(a1 + 80));
            uint64_t v74 = v18[1].isa;
            *(_DWORD *)buf = 67110146;
            int v283 = v71;
            __int16 v284 = 2082;
            v285 = v72;
            __int16 v286 = 2082;
            v287 = v73;
            __int16 v288 = 1024;
            int v289 = 1099;
            __int16 v290 = 2114;
            v291 = v74;
            _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Key %{public}@ has nil keyAttestation, looks like previous delete didn't finish correctly, try to delete again ...", buf, 0x2Cu);
          }
          id v37 = [*(id *)(a1 + 32) deleteDBKey:v18];
          if (v37)
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v75 = NFLogGetLogger();
            if (v75)
            {
              id v76 = (void (*)(uint64_t, const char *, ...))v75;
              CFStringRef v77 = object_getClass(*(id *)(a1 + 32));
              BOOL v78 = class_isMetaClass(v77);
              v255 = object_getClassName(*(id *)(a1 + 32));
              v263 = sel_getName(*(SEL *)(a1 + 80));
              uint64_t v79 = 45;
              if (v78) {
                uint64_t v79 = 43;
              }
              v76(3, "%c[%{public}s %{public}s]:%i Delete failed : %{public}@", v79, v255, v263, 1102, v37);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v80 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
            {
              uint64_t v81 = object_getClass(*(id *)(a1 + 32));
              if (class_isMetaClass(v81)) {
                int v82 = 43;
              }
              else {
                int v82 = 45;
              }
              uint64_t v83 = object_getClassName(*(id *)(a1 + 32));
              BOOL v84 = sel_getName(*(SEL *)(a1 + 80));
              *(_DWORD *)buf = 67110146;
              int v283 = v82;
              __int16 v284 = 2082;
              v285 = v83;
              __int16 v286 = 2082;
              v287 = v84;
              __int16 v288 = 1024;
              int v289 = 1102;
              __int16 v290 = 2114;
              v291 = (objc_class *)v37;
              _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Delete failed : %{public}@", buf, 0x2Cu);
            }
          }
          uint64_t v85 = *(void *)(a1 + 72);
          __int16 v86 = sub_100140D38(*(void **)(a1 + 40));
          (*(void (**)(uint64_t, void, void *))(v85 + 16))(v85, 0, v86);

          goto LABEL_35;
        }
        if (!*(void *)(a1 + 48))
        {
          id v37 = sub_100140F40(@"signRequest is nil");
          v304[0] = @"purpleTrustOperationType";
          v304[1] = @"purpleTrustOperationErrorStep";
          v305[0] = &off_10031B520;
          v305[1] = &off_10031B538;
          v305[2] = &off_10031B3B8;
          v304[2] = @"purpleTrustOperationCAErrorCode";
          v304[3] = @"purpleTrustOperationErrorCode";
          BOOL v57 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [v37 code]);
          v305[3] = v57;
          v58 = v305;
          uint64_t v59 = v304;
LABEL_77:
          int v39 = +[NSDictionary dictionaryWithObjects:v58 forKeys:v59 count:4];

          sub_10020307C((uint64_t)NFPeerPaymentAndPurpleTrustCALogger, v39);
          goto LABEL_33;
        }
        uint64_t v46 = [*(id *)(a1 + 32) selectInstance];
        if (v46)
        {
          id v37 = (void *)v46;
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v47 = NFLogGetLogger();
          if (v47)
          {
            uint64_t v48 = (void (*)(uint64_t, const char *, ...))v47;
            uint64_t v49 = object_getClass(*(id *)(a1 + 32));
            BOOL v50 = class_isMetaClass(v49);
            v254 = object_getClassName(*(id *)(a1 + 32));
            v262 = sel_getName(*(SEL *)(a1 + 80));
            uint64_t v51 = 45;
            if (v50) {
              uint64_t v51 = 43;
            }
            v48(3, "%c[%{public}s %{public}s]:%i Failed to select instance : %{public}@", v51, v254, v262, 1136, v37);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v52 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
          {
            uint64_t v53 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v53)) {
              int v54 = 43;
            }
            else {
              int v54 = 45;
            }
            v55 = object_getClassName(*(id *)(a1 + 32));
            int v56 = sel_getName(*(SEL *)(a1 + 80));
            *(_DWORD *)buf = 67110146;
            int v283 = v54;
            __int16 v284 = 2082;
            v285 = v55;
            __int16 v286 = 2082;
            v287 = v56;
            __int16 v288 = 1024;
            int v289 = 1136;
            __int16 v290 = 2114;
            v291 = (objc_class *)v37;
            _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select instance : %{public}@", buf, 0x2Cu);
          }

          v302[0] = @"purpleTrustOperationType";
          v302[1] = @"purpleTrustOperationErrorStep";
          v303[0] = &off_10031B520;
          v303[1] = &off_10031B550;
          v303[2] = &off_10031B490;
          v302[2] = @"purpleTrustOperationCAErrorCode";
          v302[3] = @"purpleTrustOperationErrorCode";
          BOOL v57 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [v37 code]);
          v303[3] = v57;
          v58 = v303;
          uint64_t v59 = v302;
          goto LABEL_77;
        }
        if (*(void *)(a1 + 56))
        {
LABEL_79:
          [*(id *)(a1 + 32) setIsInstanceSelected:0];
          NSErrorUserInfoKey v87 = NFSharedSignpostLog();
          if (os_signpost_enabled(v87))
          {
            *(_WORD *)buf = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v87, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "signWithKeyInSlotAID", (const char *)&unk_100286819, buf, 2u);
          }

          int v88 = [*(id *)(a1 + 32) secureElementWrapper];
          v89 = v18[4].isa;
          int v90 = [*(id *)(a1 + 32) trustDBApplet];
          __int16 v91 = [v90 instanceAID];
          __int16 v93 = *(void **)(a1 + 56);
          uint64_t v92 = *(void **)(a1 + 64);
          v94 = *(void **)(a1 + 48);
          id v95 = [*(id *)(a1 + 32) uid];
          id v275 = 0;
          int v96 = sub_1000BE114(v88, v89, v91, v94, v92, v93, (uint64_t)v95, &v275);
          id v97 = v275;

          id v98 = NFSharedSignpostLog();
          BOOL v99 = os_signpost_enabled(v98);
          if (!v96)
          {
            if (v99)
            {
              *(_WORD *)buf = 0;
              _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v98, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "signWithKeyInSlotAID", (const char *)&unk_100286819, buf, 2u);
            }

            int v149 = [v97 signResponse];
            v150 = [v149 counterValue];

            if (v150)
            {
              v151 = [v97 signResponse];
              v152 = [v151 counterValue];
              sub_1000353B8((uint64_t)v18, v152);
            }
            v153 = [*(id *)(a1 + 32) trustDB];
            sub_1000322DC((uint64_t)v153);
            v154 = (objc_class *)objc_claimAutoreleasedReturnValue();

            if (v154)
            {
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v155 = NFLogGetLogger();
              if (v155)
              {
                v156 = (void (*)(uint64_t, const char *, ...))v155;
                BOOL v157 = object_getClass(*(id *)(a1 + 32));
                BOOL v158 = class_isMetaClass(v157);
                v257 = object_getClassName(*(id *)(a1 + 32));
                id v266 = sel_getName(*(SEL *)(a1 + 80));
                uint64_t v159 = 45;
                if (v158) {
                  uint64_t v159 = 43;
                }
                v156(3, "%c[%{public}s %{public}s]:%i Failed to commit NFTrustDB : %{public}@ -- Counter is out of sync", v159, v257, v266, 1326, v154);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v160 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v160, OS_LOG_TYPE_ERROR))
              {
                BOOL v161 = object_getClass(*(id *)(a1 + 32));
                if (class_isMetaClass(v161)) {
                  int v162 = 43;
                }
                else {
                  int v162 = 45;
                }
                v163 = object_getClassName(*(id *)(a1 + 32));
                v164 = sel_getName(*(SEL *)(a1 + 80));
                *(_DWORD *)buf = 67110146;
                int v283 = v162;
                __int16 v284 = 2082;
                v285 = v163;
                __int16 v286 = 2082;
                v287 = v164;
                __int16 v288 = 1024;
                int v289 = 1326;
                __int16 v290 = 2114;
                v291 = v154;
                _os_log_impl((void *)&_mh_execute_header, v160, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to commit NFTrustDB : %{public}@ -- Counter is out of sync", buf, 0x2Cu);
              }
            }
            int v165 = [v97 signResponse];
            v166 = sub_100035410((uint64_t)v18);
            [v165 setKey:v166];

            +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:&off_100322FD8];
            v167 = *(void **)(a1 + 32);
            v274 = v154;
            id v168 = [v167 getNumberOfKeys:&v274];
            uint64_t v118 = v274;

            if (v118)
            {
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v169 = NFLogGetLogger();
              if (v169)
              {
                v170 = (void (*)(uint64_t, const char *, ...))v169;
                uint64_t v171 = object_getClass(*(id *)(a1 + 32));
                BOOL v172 = class_isMetaClass(v171);
                v173 = object_getClassName(*(id *)(a1 + 32));
                id v267 = sel_getName(*(SEL *)(a1 + 80));
                uint64_t v174 = 45;
                if (v172) {
                  uint64_t v174 = 43;
                }
                v170(3, "%c[%{public}s %{public}s]:%i Could not get number of keys to post CA notification", v174, v173, v267, 1338);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v175 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v175, OS_LOG_TYPE_ERROR))
              {
                v176 = object_getClass(*(id *)(a1 + 32));
                if (class_isMetaClass(v176)) {
                  int v177 = 43;
                }
                else {
                  int v177 = 45;
                }
                int v178 = object_getClassName(*(id *)(a1 + 32));
                v179 = sel_getName(*(SEL *)(a1 + 80));
                *(_DWORD *)buf = 67109890;
                int v283 = v177;
                __int16 v284 = 2082;
                v285 = v178;
                __int16 v286 = 2082;
                v287 = v179;
                __int16 v288 = 1024;
                int v289 = 1338;
                _os_log_impl((void *)&_mh_execute_header, v175, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Could not get number of keys to post CA notification", buf, 0x22u);
              }
            }
            else
            {
              CFStringRef v278 = @"totalPurpleTrustKeys";
              uint64_t v175 = +[NSNumber numberWithUnsignedInteger:v168];
              v279 = v175;
              v215 = +[NSDictionary dictionaryWithObjects:&v279 forKeys:&v278 count:1];
              +[NFGeneralStatisticsCALogger updateGeneralDeviceStatistic:v215];
            }
            (*(void (**)(void))(*(void *)(a1 + 72) + 16))();
            goto LABEL_181;
          }
          if (v99)
          {
            *(_WORD *)buf = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v98, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "signWithKeyInSlotAID", "failed", buf, 2u);
          }

          int v100 = [v96 domain];
          if ([v100 isEqualToString:@"GP"])
          {
            id v101 = [v96 code];

            if (v101 == (id)27272)
            {
              id v273 = v97;
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v102 = NFLogGetLogger();
              if (v102)
              {
                v103 = (void (*)(uint64_t, const char *, ...))v102;
                v104 = object_getClass(*(id *)(a1 + 32));
                BOOL v105 = class_isMetaClass(v104);
                uint64_t v106 = object_getClassName(*(id *)(a1 + 32));
                v107 = sel_getName(*(SEL *)(a1 + 80));
                v108 = v18[1].isa;
                BOOL v109 = v18[4].isa;
                uint64_t v110 = 45;
                if (v105) {
                  uint64_t v110 = 43;
                }
                v103(3, "%c[%{public}s %{public}s]:%i Key with identifier %{public}@ is supposed to be in slot %{public}@ but slot is empty, deleting key from database ...", v110, v106, v107, 1290, v108, v109);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v111 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v111, OS_LOG_TYPE_ERROR))
              {
                v112 = object_getClass(*(id *)(a1 + 32));
                if (class_isMetaClass(v112)) {
                  int v113 = 43;
                }
                else {
                  int v113 = 45;
                }
                v114 = object_getClassName(*(id *)(a1 + 32));
                v115 = sel_getName(*(SEL *)(a1 + 80));
                v116 = v18[1].isa;
                v117 = v18[4].isa;
                *(_DWORD *)buf = 67110402;
                int v283 = v113;
                __int16 v284 = 2082;
                v285 = v114;
                __int16 v286 = 2082;
                v287 = v115;
                __int16 v288 = 1024;
                int v289 = 1290;
                __int16 v290 = 2114;
                v291 = v116;
                __int16 v292 = 2114;
                v293 = v117;
                _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Key with identifier %{public}@ is supposed to be in slot %{public}@ but slot is empty, deleting key from database ...", buf, 0x36u);
              }
              uint64_t v118 = [*(id *)(a1 + 32) deleteDBKey:v18];

              if (v118)
              {
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v119 = NFLogGetLogger();
                if (v119)
                {
                  v120 = (void (*)(uint64_t, const char *, ...))v119;
                  BOOL v121 = object_getClass(*(id *)(a1 + 32));
                  BOOL v122 = class_isMetaClass(v121);
                  v256 = object_getClassName(*(id *)(a1 + 32));
                  id v264 = sel_getName(*(SEL *)(a1 + 80));
                  uint64_t v123 = 45;
                  if (v122) {
                    uint64_t v123 = 43;
                  }
                  v120(3, "%c[%{public}s %{public}s]:%i Could not delete dbKey : %{public}@", v123, v256, v264, 1293, v118);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                int v124 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v124, OS_LOG_TYPE_ERROR))
                {
                  v125 = object_getClass(*(id *)(a1 + 32));
                  if (class_isMetaClass(v125)) {
                    int v126 = 43;
                  }
                  else {
                    int v126 = 45;
                  }
                  v127 = object_getClassName(*(id *)(a1 + 32));
                  uint64_t v128 = sel_getName(*(SEL *)(a1 + 80));
                  *(_DWORD *)buf = 67110146;
                  int v283 = v126;
                  __int16 v284 = 2082;
                  v285 = v127;
                  __int16 v286 = 2082;
                  v287 = v128;
                  __int16 v288 = 1024;
                  int v289 = 1293;
                  __int16 v290 = 2114;
                  v291 = v118;
                  _os_log_impl((void *)&_mh_execute_header, v124, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Could not delete dbKey : %{public}@", buf, 0x2Cu);
                }
              }
              uint64_t v129 = *(void *)(a1 + 72);
              v130 = sub_100140D38(*(void **)(a1 + 40));
              (*(void (**)(uint64_t, void, void *))(v129 + 16))(v129, 0, v130);

              id v97 = v273;
LABEL_181:

              goto LABEL_26;
            }
          }
          else
          {
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v180 = NFLogGetLogger();
          if (v180)
          {
            v181 = (void (*)(uint64_t, const char *, ...))v180;
            v182 = object_getClass(*(id *)(a1 + 32));
            BOOL v183 = class_isMetaClass(v182);
            v258 = object_getClassName(*(id *)(a1 + 32));
            id v268 = sel_getName(*(SEL *)(a1 + 80));
            uint64_t v184 = 45;
            if (v183) {
              uint64_t v184 = 43;
            }
            v181(3, "%c[%{public}s %{public}s]:%i Failed to sign with Key : %{public}@ ...", v184, v258, v268, 1301, v96);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v185 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v185, OS_LOG_TYPE_ERROR))
          {
            v186 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v186)) {
              int v187 = 43;
            }
            else {
              int v187 = 45;
            }
            v188 = object_getClassName(*(id *)(a1 + 32));
            v189 = sel_getName(*(SEL *)(a1 + 80));
            *(_DWORD *)buf = 67110146;
            int v283 = v187;
            __int16 v284 = 2082;
            v285 = v188;
            __int16 v286 = 2082;
            v287 = v189;
            __int16 v288 = 1024;
            int v289 = 1301;
            __int16 v290 = 2114;
            v291 = (objc_class *)v96;
            _os_log_impl((void *)&_mh_execute_header, v185, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to sign with Key : %{public}@ ...", buf, 0x2Cu);
          }

          v280[0] = @"purpleTrustOperationType";
          v280[1] = @"purpleTrustOperationErrorStep";
          v281[0] = &off_10031B520;
          v281[1] = &off_10031B5C8;
          v281[2] = &off_10031B340;
          v280[2] = @"purpleTrustOperationCAErrorCode";
          v280[3] = @"purpleTrustOperationErrorCode";
          BOOL v190 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [v96 code]);
          v281[3] = v190;
          uint64_t v191 = +[NSDictionary dictionaryWithObjects:v281 forKeys:v280 count:4];

          sub_10020307C((uint64_t)NFPeerPaymentAndPurpleTrustCALogger, v191);
          +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:&off_100322FB0];
          (*(void (**)(void))(*(void *)(a1 + 72) + 16))();

          uint64_t v118 = (objc_class *)v96;
          goto LABEL_181;
        }
        uint64_t v131 = *(void *)(a1 + 64);
        BOOL v132 = sub_1000353D0(v18);
        if (v131)
        {
          if (v132)
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v133 = NFLogGetLogger();
            if (v133)
            {
              v134 = (void (*)(uint64_t, const char *, ...))v133;
              int v135 = object_getClass(*(id *)(a1 + 32));
              BOOL v136 = class_isMetaClass(v135);
              v137 = object_getClassName(*(id *)(a1 + 32));
              id v265 = sel_getName(*(SEL *)(a1 + 80));
              uint64_t v138 = 45;
              if (v136) {
                uint64_t v138 = 43;
              }
              v134(3, "%c[%{public}s %{public}s]:%i Could not sign, NFTrustKey requires local validation", v138, v137, v265, 1225);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v139 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v139, OS_LOG_TYPE_ERROR))
            {
              v140 = object_getClass(*(id *)(a1 + 32));
              if (class_isMetaClass(v140)) {
                int v141 = 43;
              }
              else {
                int v141 = 45;
              }
              uint64_t v142 = object_getClassName(*(id *)(a1 + 32));
              v143 = sel_getName(*(SEL *)(a1 + 80));
              *(_DWORD *)buf = 67109890;
              int v283 = v141;
              __int16 v284 = 2082;
              v285 = v142;
              __int16 v286 = 2082;
              v287 = v143;
              __int16 v288 = 1024;
              int v289 = 1225;
              _os_log_impl((void *)&_mh_execute_header, v139, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Could not sign, NFTrustKey requires local validation", buf, 0x22u);
            }

            id v37 = sub_100140B44();
            v296[0] = @"purpleTrustOperationType";
            v296[1] = @"purpleTrustOperationErrorStep";
            v297[0] = &off_10031B520;
            v297[1] = &off_10031B568;
            v297[2] = &off_10031B580;
            v296[2] = @"purpleTrustOperationCAErrorCode";
            v296[3] = @"purpleTrustOperationErrorCode";
            v144 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [v37 code]);
            v297[3] = v144;
            BOOL v145 = v297;
            uint64_t v146 = v296;
          }
          else
          {
            if (*(void *)(a1 + 56) || !*(void *)(a1 + 64)) {
              goto LABEL_79;
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v204 = NFLogGetLogger();
            if (v204)
            {
              int v205 = (void (*)(uint64_t, const char *, ...))v204;
              v206 = object_getClass(*(id *)(a1 + 32));
              BOOL v207 = class_isMetaClass(v206);
              v208 = object_getClassName(*(id *)(a1 + 32));
              CFStringRef v270 = sel_getName(*(SEL *)(a1 + 80));
              uint64_t v209 = 45;
              if (v207) {
                uint64_t v209 = 43;
              }
              v205(3, "%c[%{public}s %{public}s]:%i Could not sign, NFECommercePaymentRequest requires local validation", v209, v208, v270, 1247);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v210 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v210, OS_LOG_TYPE_ERROR))
            {
              v211 = object_getClass(*(id *)(a1 + 32));
              if (class_isMetaClass(v211)) {
                int v212 = 43;
              }
              else {
                int v212 = 45;
              }
              uint64_t v213 = object_getClassName(*(id *)(a1 + 32));
              v214 = sel_getName(*(SEL *)(a1 + 80));
              *(_DWORD *)buf = 67109890;
              int v283 = v212;
              __int16 v284 = 2082;
              v285 = v213;
              __int16 v286 = 2082;
              v287 = v214;
              __int16 v288 = 1024;
              int v289 = 1247;
              _os_log_impl((void *)&_mh_execute_header, v210, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Could not sign, NFECommercePaymentRequest requires local validation", buf, 0x22u);
            }

            id v37 = sub_100140B44();
            v294[0] = @"purpleTrustOperationType";
            v294[1] = @"purpleTrustOperationErrorStep";
            v295[0] = &off_10031B520;
            v295[1] = &off_10031B568;
            v295[2] = &off_10031B580;
            v294[2] = @"purpleTrustOperationCAErrorCode";
            v294[3] = @"purpleTrustOperationErrorCode";
            v144 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [v37 code]);
            v295[3] = v144;
            BOOL v145 = v295;
            uint64_t v146 = v294;
          }
          int v39 = +[NSDictionary dictionaryWithObjects:v145 forKeys:v146 count:4];

          sub_10020307C((uint64_t)NFPeerPaymentAndPurpleTrustCALogger, v39);
          uint64_t v147 = *(void *)(a1 + 72);
          v148 = sub_100140B44();
          (*(void (**)(uint64_t, void, void *))(v147 + 16))(v147, 0, v148);

          goto LABEL_34;
        }
        if (v132)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v192 = NFLogGetLogger();
          if (v192)
          {
            v193 = (void (*)(uint64_t, const char *, ...))v192;
            int v194 = object_getClass(*(id *)(a1 + 32));
            BOOL v195 = class_isMetaClass(v194);
            v196 = object_getClassName(*(id *)(a1 + 32));
            id v269 = sel_getName(*(SEL *)(a1 + 80));
            uint64_t v197 = 45;
            if (v195) {
              uint64_t v197 = 43;
            }
            v193(3, "%c[%{public}s %{public}s]:%i Could not sign, NFTrustKey requires local validation", v197, v196, v269, 1161);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v198 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v198, OS_LOG_TYPE_ERROR))
          {
            v199 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v199)) {
              int v200 = 43;
            }
            else {
              int v200 = 45;
            }
            BOOL v201 = object_getClassName(*(id *)(a1 + 32));
            uint64_t v202 = sel_getName(*(SEL *)(a1 + 80));
            *(_DWORD *)buf = 67109890;
            int v283 = v200;
            __int16 v284 = 2082;
            v285 = v201;
            __int16 v286 = 2082;
            v287 = v202;
            __int16 v288 = 1024;
            int v289 = 1161;
            _os_log_impl((void *)&_mh_execute_header, v198, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Could not sign, NFTrustKey requires local validation", buf, 0x22u);
          }

          v19 = sub_100140B44();
          v300[0] = @"purpleTrustOperationType";
          v300[1] = @"purpleTrustOperationErrorStep";
          v301[0] = &off_10031B520;
          v301[1] = &off_10031B568;
          v301[2] = &off_10031B580;
          v300[2] = @"purpleTrustOperationCAErrorCode";
          v300[3] = @"purpleTrustOperationErrorCode";
          v203 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [v19 code]);
          v301[3] = v203;
          id v43 = +[NSDictionary dictionaryWithObjects:v301 forKeys:v300 count:4];

          sub_10020307C((uint64_t)NFPeerPaymentAndPurpleTrustCALogger, v43);
          (*(void (**)(void, void, void *))(*(void *)(a1 + 72) + 16))(*(void *)(a1 + 72), 0, v19);
        }
        else
        {
          int v216 = NFSharedSignpostLog();
          if (os_signpost_enabled(v216))
          {
            *(_WORD *)buf = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v216, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "signWithKeyInSlotRequest", (const char *)&unk_100286819, buf, 2u);
          }

          v217 = [*(id *)(a1 + 32) secureElementWrapper];
          v218 = v18[4].isa;
          v219 = *(void **)(a1 + 48);
          id v276 = 0;
          uint64_t v220 = sub_1000BDC0C(v217, v218, v219, &v276);
          id v43 = v276;

          uint64_t v221 = NFSharedSignpostLog();
          BOOL v222 = os_signpost_enabled(v221);
          if (v220)
          {
            v223 = (objc_class *)v220;
            if (v222)
            {
              *(_WORD *)buf = 0;
              _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v221, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "signWithKeyInSlotRequest", "failed", buf, 2u);
            }

            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v224 = NFLogGetLogger();
            if (v224)
            {
              v225 = (void (*)(uint64_t, const char *, ...))v224;
              uint64_t v226 = object_getClass(*(id *)(a1 + 32));
              BOOL v227 = class_isMetaClass(v226);
              v259 = object_getClassName(*(id *)(a1 + 32));
              v271 = sel_getName(*(SEL *)(a1 + 80));
              uint64_t v228 = 45;
              if (v227) {
                uint64_t v228 = 43;
              }
              v225(3, "%c[%{public}s %{public}s]:%i Failed to sign without LocalValidation : %{public}@", v228, v259, v271, 1190, v220);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            BOOL v229 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v229, OS_LOG_TYPE_ERROR))
            {
              v230 = object_getClass(*(id *)(a1 + 32));
              if (class_isMetaClass(v230)) {
                int v231 = 43;
              }
              else {
                int v231 = 45;
              }
              v232 = object_getClassName(*(id *)(a1 + 32));
              int v233 = sel_getName(*(SEL *)(a1 + 80));
              *(_DWORD *)buf = 67110146;
              int v283 = v231;
              __int16 v284 = 2082;
              v285 = v232;
              __int16 v286 = 2082;
              v287 = v233;
              __int16 v288 = 1024;
              int v289 = 1190;
              __int16 v290 = 2114;
              v291 = v223;
              _os_log_impl((void *)&_mh_execute_header, v229, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to sign without LocalValidation : %{public}@", buf, 0x2Cu);
            }

            v298[0] = @"purpleTrustOperationType";
            v298[1] = @"purpleTrustOperationErrorStep";
            v299[0] = &off_10031B520;
            v299[1] = &off_10031B598;
            v299[2] = &off_10031B5B0;
            v298[2] = @"purpleTrustOperationCAErrorCode";
            v298[3] = @"purpleTrustOperationErrorCode";
            v234 = +[NSNumber numberWithInteger:[(objc_class *)v223 code]];
            v299[3] = v234;
            v235 = +[NSDictionary dictionaryWithObjects:v299 forKeys:v298 count:4];

            sub_10020307C((uint64_t)NFPeerPaymentAndPurpleTrustCALogger, v235);
            v19 = v223;
            (*(void (**)(void))(*(void *)(a1 + 72) + 16))();
          }
          else
          {
            if (v222)
            {
              *(_WORD *)buf = 0;
              _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v221, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "signWithKeyInSlotRequest", (const char *)&unk_100286819, buf, 2u);
            }

            v236 = [v43 counterValue];

            if (v236)
            {
              v237 = [v43 counterValue];
              sub_1000353B8((uint64_t)v18, v237);
            }
            v238 = [*(id *)(a1 + 32) trustDB];
            uint64_t v239 = sub_1000322DC((uint64_t)v238);

            v240 = (objc_class *)v239;
            if (v239)
            {
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v241 = NFLogGetLogger();
              if (v241)
              {
                v242 = (void (*)(uint64_t, const char *, ...))v241;
                v243 = object_getClass(*(id *)(a1 + 32));
                BOOL v244 = class_isMetaClass(v243);
                v260 = object_getClassName(*(id *)(a1 + 32));
                v272 = sel_getName(*(SEL *)(a1 + 80));
                uint64_t v245 = 45;
                if (v244) {
                  uint64_t v245 = 43;
                }
                v242(3, "%c[%{public}s %{public}s]:%i Failed to commit NFTrustDB : %{public}@ -- Counter is out of sync", v245, v260, v272, 1214, v240);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v246 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v246, OS_LOG_TYPE_ERROR))
              {
                v247 = object_getClass(*(id *)(a1 + 32));
                if (class_isMetaClass(v247)) {
                  int v248 = 43;
                }
                else {
                  int v248 = 45;
                }
                v249 = object_getClassName(*(id *)(a1 + 32));
                v250 = sel_getName(*(SEL *)(a1 + 80));
                *(_DWORD *)buf = 67110146;
                int v283 = v248;
                __int16 v284 = 2082;
                v285 = v249;
                __int16 v286 = 2082;
                v287 = v250;
                __int16 v288 = 1024;
                int v289 = 1214;
                __int16 v290 = 2114;
                v291 = v240;
                _os_log_impl((void *)&_mh_execute_header, v246, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to commit NFTrustDB : %{public}@ -- Counter is out of sync", buf, 0x2Cu);
              }
            }
            v251 = sub_100035410((uint64_t)v18);
            [v43 setKey:v251];

            uint64_t v252 = *(void *)(a1 + 72);
            v253 = +[NFTrustPaymentSignResponse paymentSignResponseWithSignResponse:v43 paymentResponse:0];
            (*(void (**)(uint64_t, void *, void))(v252 + 16))(v252, v253, 0);

            v19 = v240;
          }
        }
LABEL_38:

        goto LABEL_16;
      }
      id v18 = sub_100140F40(@"keyIdentifier is nil");
      v310[0] = @"purpleTrustOperationType";
      v310[1] = @"purpleTrustOperationErrorStep";
      v311[0] = &off_10031B520;
      v311[1] = &off_10031B520;
      v311[2] = &off_10031B3B8;
      v310[2] = @"purpleTrustOperationCAErrorCode";
      v310[3] = @"purpleTrustOperationErrorCode";
      uint64_t v44 = +[NSNumber numberWithInteger:[v18 code]];
      v311[3] = v44;
      v19 = +[NSDictionary dictionaryWithObjects:v311 forKeys:v310 count:4];

      sub_10020307C((uint64_t)NFPeerPaymentAndPurpleTrustCALogger, v19);
      uint64_t v41 = *(void *)(a1 + 72);
      uint64_t v42 = sub_100140F40(@"Could not sign with nil identifier");
    }
    else
    {
      id v18 = sub_100140A54();
      v312[0] = @"purpleTrustOperationType";
      v312[1] = @"purpleTrustOperationErrorStep";
      v313[0] = &off_10031B520;
      v313[1] = &off_10031B520;
      v313[2] = &off_10031B340;
      v312[2] = @"purpleTrustOperationCAErrorCode";
      v312[3] = @"purpleTrustOperationErrorCode";
      id v40 = +[NSNumber numberWithInteger:[v18 code]];
      v313[3] = v40;
      v19 = +[NSDictionary dictionaryWithObjects:v313 forKeys:v312 count:4];

      sub_10020307C((uint64_t)NFPeerPaymentAndPurpleTrustCALogger, v19);
      +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:&off_100322F60];
      uint64_t v41 = *(void *)(a1 + 72);
      uint64_t v42 = sub_100140A54();
    }
    id v43 = (id)v42;
    (*(void (**)(uint64_t, void, uint64_t))(v41 + 16))(v41, 0, v42);
    goto LABEL_38;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v2 = NFLogGetLogger();
  if (v2)
  {
    v3 = (void (*)(uint64_t, const char *, ...))v2;
    v4 = object_getClass(*(id *)(a1 + 32));
    BOOL v5 = class_isMetaClass(v4);
    id v6 = object_getClassName(*(id *)(a1 + 32));
    v7 = sel_getName(*(SEL *)(a1 + 80));
    v8 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v9 = 45;
    if (v5) {
      uint64_t v9 = 43;
    }
    v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, v6, v7, 1003, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    id v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    v13 = object_getClassName(*(id *)(a1 + 32));
    v14 = sel_getName(*(SEL *)(a1 + 80));
    id v15 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)buf = 67110146;
    int v283 = v12;
    __int16 v284 = 2082;
    v285 = v13;
    __int16 v286 = 2082;
    v287 = v14;
    __int16 v288 = 1024;
    int v289 = 1003;
    __int16 v290 = 2114;
    v291 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v16 = *(void *)(a1 + 72);
  if (v16)
  {
    id v17 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v314 = NSLocalizedDescriptionKey;
    v19 = +[NSString stringWithUTF8String:"Session not active"];
    v315 = v19;
    uint64_t v20 = +[NSDictionary dictionaryWithObjects:&v315 forKeys:&v314 count:1];
    id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
    (*(void (**)(uint64_t, void, id))(v16 + 16))(v16, 0, v21);

LABEL_16:
LABEL_26:
  }
}

void sub_1000DBD80(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2)
  {
    v3 = [v2 objectForKeyedSubscript:@"EventType"];
    if (!v3 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        id v21 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(*(id *)(a1 + 40));
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(*(id *)(a1 + 40));
        Name = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v25 = 45;
        if (isMetaClass) {
          uint64_t v25 = 43;
        }
        v21(3, "%c[%{public}s %{public}s]:%i EventType missing or not NSString!!", v25, ClassName, Name, 80);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v4 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        uint64_t v26 = object_getClass(*(id *)(a1 + 40));
        if (class_isMetaClass(v26)) {
          int v27 = 43;
        }
        else {
          int v27 = 45;
        }
        uint64_t v28 = object_getClassName(*(id *)(a1 + 40));
        int v29 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)buf = 67109890;
        int v93 = v27;
        __int16 v94 = 2082;
        id v95 = v28;
        __int16 v96 = 2082;
        id v97 = v29;
        __int16 v98 = 1024;
        int v99 = 80;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i EventType missing or not NSString!!", buf, 0x22u);
      }
      goto LABEL_80;
    }
    v4 = [*(id *)(a1 + 32) objectForKeyedSubscript:@"appletIdentifier"];
    if (!v4 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v40 = NFLogGetLogger();
      if (v40)
      {
        uint64_t v41 = (void (*)(uint64_t, const char *, ...))v40;
        uint64_t v42 = object_getClass(*(id *)(a1 + 40));
        BOOL v43 = class_isMetaClass(v42);
        uint64_t v44 = object_getClassName(*(id *)(a1 + 40));
        int v88 = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v45 = 45;
        if (v43) {
          uint64_t v45 = 43;
        }
        v41(3, "%c[%{public}s %{public}s]:%i appletIdentifier missing or not NSString!!", v45, v44, v88, 86);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      BOOL v5 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        uint64_t v46 = object_getClass(*(id *)(a1 + 40));
        if (class_isMetaClass(v46)) {
          int v47 = 43;
        }
        else {
          int v47 = 45;
        }
        uint64_t v48 = object_getClassName(*(id *)(a1 + 40));
        uint64_t v49 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)buf = 67109890;
        int v93 = v47;
        __int16 v94 = 2082;
        id v95 = v48;
        __int16 v96 = 2082;
        id v97 = v49;
        __int16 v98 = 1024;
        int v99 = 86;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i appletIdentifier missing or not NSString!!", buf, 0x22u);
      }
      goto LABEL_79;
    }
    BOOL v5 = v3;
    id v6 = +[NSData NF_dataWithHexString:v4];
    if (v6)
    {
      if ([v5 isEqualToString:@"StartEvent"])
      {
        v7 = [[NFContactlessPaymentStartEvent alloc] initWithDictionary:*(void *)(a1 + 32)];
        if (v7)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v8 = NFLogGetLogger();
          if (v8)
          {
            uint64_t v9 = (void (*)(uint64_t, const char *, ...))v8;
            v10 = object_getClass(*(id *)(a1 + 40));
            BOOL v11 = class_isMetaClass(v10);
            int v82 = object_getClassName(*(id *)(a1 + 40));
            uint64_t v85 = sel_getName(*(SEL *)(a1 + 48));
            uint64_t v12 = 45;
            if (v11) {
              uint64_t v12 = 43;
            }
            v9(6, "%c[%{public}s %{public}s]:%i %@", v12, v82, v85, 103, v7);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v13 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            v14 = object_getClass(*(id *)(a1 + 40));
            if (class_isMetaClass(v14)) {
              int v15 = 43;
            }
            else {
              int v15 = 45;
            }
            uint64_t v16 = object_getClassName(*(id *)(a1 + 40));
            id v17 = sel_getName(*(SEL *)(a1 + 48));
            *(_DWORD *)buf = 67110146;
            int v93 = v15;
            __int16 v94 = 2082;
            id v95 = v16;
            __int16 v96 = 2082;
            id v97 = v17;
            __int16 v98 = 1024;
            int v99 = 103;
            __int16 v100 = 2112;
            id v101 = v7;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %@", buf, 0x2Cu);
          }

          id v18 = sub_1000DC74C(*(void **)(a1 + 40), v6, *(void **)(a1 + 32), v7);
          id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 40) + 40));
          [WeakRetained handleTransactionStartEvent:v7 atlData:*(void *)(a1 + 32) caData:v18];
LABEL_67:

          goto LABEL_78;
        }
        goto LABEL_78;
      }
      if ([v5 isEqualToString:@"EndEvent"])
      {
        v7 = [[NFContactlessPaymentEndEvent alloc] initWithDictionary:*(void *)(a1 + 32)];
        if (v7)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v63 = NFLogGetLogger();
          if (v63)
          {
            BOOL v64 = (void (*)(uint64_t, const char *, ...))v63;
            uint64_t v65 = object_getClass(*(id *)(a1 + 40));
            BOOL v66 = class_isMetaClass(v65);
            uint64_t v83 = object_getClassName(*(id *)(a1 + 40));
            int v90 = sel_getName(*(SEL *)(a1 + 48));
            uint64_t v67 = 45;
            if (v66) {
              uint64_t v67 = 43;
            }
            v64(6, "%c[%{public}s %{public}s]:%i %@", v67, v83, v90, 114, v7);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v68 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v68, OS_LOG_TYPE_DEFAULT))
          {
            v69 = object_getClass(*(id *)(a1 + 40));
            if (class_isMetaClass(v69)) {
              int v70 = 43;
            }
            else {
              int v70 = 45;
            }
            int v71 = object_getClassName(*(id *)(a1 + 40));
            long long v72 = sel_getName(*(SEL *)(a1 + 48));
            *(_DWORD *)buf = 67110146;
            int v93 = v70;
            __int16 v94 = 2082;
            id v95 = v71;
            __int16 v96 = 2082;
            id v97 = v72;
            __int16 v98 = 1024;
            int v99 = 114;
            __int16 v100 = 2112;
            id v101 = v7;
            _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %@", buf, 0x2Cu);
          }

          id v18 = sub_1000DCBA4(*(void *)(a1 + 40), v6, *(void **)(a1 + 32), v7);
          id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 40) + 40));
          [WeakRetained handleTransactionEndEvent:v7 atlData:*(void *)(a1 + 32) caData:v18];
          goto LABEL_67;
        }
LABEL_78:

LABEL_79:
LABEL_80:

        goto LABEL_81;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v73 = NFLogGetLogger();
      if (v73)
      {
        uint64_t v74 = (void (*)(uint64_t, const char *, ...))v73;
        uint64_t v75 = object_getClass(*(id *)(a1 + 40));
        BOOL v76 = class_isMetaClass(v75);
        BOOL v84 = object_getClassName(*(id *)(a1 + 40));
        __int16 v91 = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v77 = 45;
        if (v76) {
          uint64_t v77 = 43;
        }
        v74(3, "%c[%{public}s %{public}s]:%i Unexpected event: %@", v77, v84, v91, 121, v5);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      NFSharedLogGetLogger();
      v7 = (NFContactlessPaymentStartEvent *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(&v7->super, OS_LOG_TYPE_ERROR)) {
        goto LABEL_78;
      }
      BOOL v78 = object_getClass(*(id *)(a1 + 40));
      if (class_isMetaClass(v78)) {
        int v79 = 43;
      }
      else {
        int v79 = 45;
      }
      uint64_t v80 = object_getClassName(*(id *)(a1 + 40));
      uint64_t v81 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67110146;
      int v93 = v79;
      __int16 v94 = 2082;
      id v95 = v80;
      __int16 v96 = 2082;
      id v97 = v81;
      __int16 v98 = 1024;
      int v99 = 121;
      __int16 v100 = 2112;
      id v101 = (NFContactlessPaymentStartEvent *)v5;
      uint64_t v60 = "%c[%{public}s %{public}s]:%i Unexpected event: %@";
      p_super = &v7->super;
      uint32_t v62 = 44;
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v50 = NFLogGetLogger();
      if (v50)
      {
        uint64_t v51 = (void (*)(uint64_t, const char *, ...))v50;
        uint64_t v52 = object_getClass(*(id *)(a1 + 40));
        BOOL v53 = class_isMetaClass(v52);
        int v54 = object_getClassName(*(id *)(a1 + 40));
        v89 = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v55 = 45;
        if (v53) {
          uint64_t v55 = 43;
        }
        v51(3, "%c[%{public}s %{public}s]:%i Failed to convert appletIdentifier to NSData!!", v55, v54, v89, 95);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      NFSharedLogGetLogger();
      v7 = (NFContactlessPaymentStartEvent *)objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(&v7->super, OS_LOG_TYPE_ERROR)) {
        goto LABEL_78;
      }
      int v56 = object_getClass(*(id *)(a1 + 40));
      if (class_isMetaClass(v56)) {
        int v57 = 43;
      }
      else {
        int v57 = 45;
      }
      v58 = object_getClassName(*(id *)(a1 + 40));
      uint64_t v59 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)buf = 67109890;
      int v93 = v57;
      __int16 v94 = 2082;
      id v95 = v58;
      __int16 v96 = 2082;
      id v97 = v59;
      __int16 v98 = 1024;
      int v99 = 95;
      uint64_t v60 = "%c[%{public}s %{public}s]:%i Failed to convert appletIdentifier to NSData!!";
      p_super = &v7->super;
      uint32_t v62 = 34;
    }
    _os_log_impl((void *)&_mh_execute_header, p_super, OS_LOG_TYPE_ERROR, v60, buf, v62);
    goto LABEL_78;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v30 = NFLogGetLogger();
  if (v30)
  {
    uint64_t v31 = (void (*)(uint64_t, const char *, ...))v30;
    uint64_t v32 = object_getClass(*(id *)(a1 + 40));
    BOOL v33 = class_isMetaClass(v32);
    BOOL v34 = object_getClassName(*(id *)(a1 + 40));
    NSErrorUserInfoKey v87 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v35 = 45;
    if (v33) {
      uint64_t v35 = 43;
    }
    v31(3, "%c[%{public}s %{public}s]:%i Event is nil!", v35, v34, v87, 73);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v3 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    id v36 = object_getClass(*(id *)(a1 + 40));
    if (class_isMetaClass(v36)) {
      int v37 = 43;
    }
    else {
      int v37 = 45;
    }
    uint64_t v38 = object_getClassName(*(id *)(a1 + 40));
    int v39 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)buf = 67109890;
    int v93 = v37;
    __int16 v94 = 2082;
    id v95 = v38;
    __int16 v96 = 2082;
    id v97 = v39;
    __int16 v98 = 1024;
    int v99 = 73;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Event is nil!", buf, 0x22u);
  }
LABEL_81:
}

id sub_1000DC74C(void *a1, void *a2, void *a3, void *a4)
{
  id v7 = a3;
  if (a1)
  {
    uint64_t v47 = 0;
    id v8 = a4;
    id v9 = a2;
    v10 = objc_opt_new();
    id v11 = [v8 selectStatus];

    uint64_t v12 = +[NSNumber numberWithUnsignedShort:v11];
    [v10 setObject:v12 forKeyedSubscript:@"commandResult"];

    v13 = [a1 delegate];
    v14 = [v9 NF_asHexString];

    int v15 = [v13 appletForIdentifier:v14 filtered:1];

    id v16 = [objc_alloc((Class)NSData) initWithBytes:&unk_100283973 length:10];
    id v17 = [v16 NF_asHexString];

    id v18 = [objc_alloc((Class)NSData) initWithBytes:&unk_10028397D length:8];
    v19 = [v18 NF_asHexString];

    id v20 = [objc_alloc((Class)NSData) initWithBytes:&unk_100283985 length:16];
    id v21 = [v20 NF_asHexString];

    v22 = [v15 moduleIdentifier];
    unsigned int v23 = [v22 isEqualToString:v17];

    if (v23)
    {
      id v24 = (unsigned __int16 *)&unk_100283996;
      uint64_t v25 = v7;
      unsigned int v26 = 57;
    }
    else
    {
      int v27 = [v15 moduleIdentifier];
      unsigned int v28 = [v27 isEqualToString:v19];

      if (v28)
      {
        id v24 = (unsigned __int16 *)&unk_100283B5E;
        uint64_t v25 = v7;
        unsigned int v26 = 53;
      }
      else
      {
        uint64_t v46 = v7;
        int v29 = [v15 moduleIdentifier];
        id v30 = [objc_alloc((Class)NSData) initWithBytes:&unk_100283D06 length:12];
        uint64_t v31 = [v30 NF_asHexString];
        unsigned int v32 = [v29 isEqualToString:v31];

        if (v32)
        {
          id v24 = (unsigned __int16 *)&unk_100283D12;
          id v7 = v46;
          uint64_t v25 = v46;
          unsigned int v26 = 45;
        }
        else
        {
          BOOL v33 = [v15 moduleIdentifier];
          id v34 = [objc_alloc((Class)NSData) initWithBytes:&unk_100283FFC length:16];
          uint64_t v35 = [v34 NF_asHexString];
          unsigned int v36 = [v33 isEqualToString:v35];

          if (v36)
          {
            id v7 = v46;
            int v37 = [v46 objectForKeyedSubscript:@"command"];
            HIDWORD(v47) = [v37 intValue];

            LODWORD(v47) = 0;
LABEL_13:
            uint64_t v40 = +[NSNumber numberWithUnsignedInt:HIDWORD(v47)];
            [v10 setObject:v40 forKeyedSubscript:@"command"];

            uint64_t v41 = +[NSNumber numberWithUnsignedInt:v47];
            [v10 setObject:v41 forKeyedSubscript:@"commandParam1"];

            goto LABEL_14;
          }
          uint64_t v38 = [v15 moduleIdentifier];
          unsigned int v39 = [v38 isEqualToString:v21];

          if (!v39)
          {
            id v7 = v46;
            BOOL v43 = [v46 objectForKeyedSubscript:@"command"];
            objc_opt_class();
            int isKindOfClass = objc_opt_isKindOfClass();

            if (isKindOfClass)
            {
              uint64_t v45 = [v46 objectForKeyedSubscript:@"command"];
              HIDWORD(v47) = [v45 intValue];
            }
            LODWORD(v47) = 0;
            goto LABEL_13;
          }
          id v24 = (unsigned __int16 *)&unk_10028400C;
          id v7 = v46;
          uint64_t v25 = v46;
          unsigned int v26 = 6;
        }
      }
    }
    sub_1000DDFAC(v25, v24, v26, (unsigned int *)&v47 + 1, (unsigned int *)&v47);
    goto LABEL_13;
  }
  v10 = 0;
LABEL_14:

  return v10;
}

id sub_1000DCBA4(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a3;
  id v8 = a4;
  if (!a1)
  {
    v10 = 0;
    goto LABEL_44;
  }
  uint64_t v109 = 0;
  id v9 = a2;
  v10 = objc_opt_new();
  id v11 = [(id)a1 delegate];
  uint64_t v12 = [v9 NF_asHexString];

  v13 = [v11 appletForIdentifier:v12 filtered:1];

  id v14 = [objc_alloc((Class)NSData) initWithBytes:&unk_100283973 length:10];
  uint64_t v15 = [v14 NF_asHexString];

  id v16 = [objc_alloc((Class)NSData) initWithBytes:&unk_10028397D length:8];
  uint64_t v17 = [v16 NF_asHexString];

  id v18 = [objc_alloc((Class)NSData) initWithBytes:&unk_100283985 length:16];
  v107 = [v18 NF_asHexString];

  v19 = [v13 moduleIdentifier];
  LODWORD(v12) = [v19 isEqualToString:v15];

  uint64_t v103 = v17;
  BOOL v105 = (void *)v15;
  if (v12)
  {
    id v20 = (unsigned __int16 *)&unk_100283996;
    id v21 = v7;
    unsigned int v22 = 57;
LABEL_10:
    sub_1000DDFAC(v21, v20, v22, (unsigned int *)&v109 + 1, (unsigned int *)&v109);
    goto LABEL_11;
  }
  unsigned int v23 = [v13 moduleIdentifier:v17, v15];
  unsigned int v24 = [v23 isEqualToString:v17];

  if (v24)
  {
    id v20 = (unsigned __int16 *)&unk_100283B5E;
    id v21 = v7;
    unsigned int v22 = 53;
    goto LABEL_10;
  }
  uint64_t v25 = [v13 moduleIdentifier];
  id v26 = [objc_alloc((Class)NSData) initWithBytes:&unk_100283D06 length:12];
  int v27 = [v26 NF_asHexString];
  unsigned int v28 = [v25 isEqualToString:v27];

  if (v28)
  {
    id v20 = (unsigned __int16 *)&unk_100283D12;
    id v21 = v7;
    unsigned int v22 = 45;
    goto LABEL_10;
  }
  int v29 = [v13 moduleIdentifier];
  id v30 = [objc_alloc((Class)NSData) initWithBytes:&unk_100283E7A length:10];
  uint64_t v31 = [v30 NF_asHexString];
  unsigned int v32 = [v29 isEqualToString:v31];

  if (v32)
  {
    id v20 = (unsigned __int16 *)&unk_100283E84;
    id v21 = v7;
    unsigned int v22 = 47;
    goto LABEL_10;
  }
  NSErrorUserInfoKey v87 = [v13 moduleIdentifier];
  id v88 = [objc_alloc((Class)NSData) initWithBytes:&unk_100283FFC length:16];
  v89 = [v88 NF_asHexString];
  unsigned int v90 = [v87 isEqualToString:v89];

  if (v90) {
    goto LABEL_48;
  }
  uint64_t v92 = [v13 moduleIdentifier];
  unsigned int v93 = [v92 isEqualToString:v107];

  if (v93)
  {
    __int16 v94 = [v13 moduleIdentifier];
    unsigned int v95 = [v94 isEqualToString:v107];

    if (v95) {
      sub_1000DDFAC(v7, word_10028400C, 6u, (unsigned int *)&v109 + 1, (unsigned int *)&v109);
    }
    int v108 = 0;
    __int16 v96 = sub_1002125C8(*(void *)(a1 + 32));
    if ([v96 notificationType] == (id)3)
    {
      id v97 = v96;
      __int16 v98 = +[NFCALogger sharedCALogger];
      int v99 = [v97 tciArray];
      [v98 getCAUniversityCode:v99 universityCodes:&v108];

      if (v108)
      {
        __int16 v100 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:");
        [v10 setObject:v100 forKeyedSubscript:@"accessUniversityCode"];
      }
    }

    goto LABEL_11;
  }
  id v101 = [v7 objectForKeyedSubscript:@"command"];
  objc_opt_class();
  int isKindOfClass = objc_opt_isKindOfClass();

  if (isKindOfClass)
  {
LABEL_48:
    __int16 v91 = [v7 objectForKeyedSubscript:@"command"];
    HIDWORD(v109) = [v91 intValue];
  }
  LODWORD(v109) = 0;
LABEL_11:
  [v10 setObject:&off_10031B5E0 forKeyedSubscript:@"version" v103];
  BOOL v33 = +[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", [v8 status]);
  [v10 setObject:v33 forKeyedSubscript:@"status"];

  id v34 = +[NSNumber numberWithUnsignedInt:HIDWORD(v109)];
  [v10 setObject:v34 forKeyedSubscript:@"command"];

  uint64_t v35 = +[NSNumber numberWithUnsignedInt:v109];
  [v10 setObject:v35 forKeyedSubscript:@"commandParam1"];

  unsigned int v36 = +[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", [v8 result]);
  [v10 setObject:v36 forKeyedSubscript:@"result"];

  int v37 = +[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", [v8 informative]);
  [v10 setObject:v37 forKeyedSubscript:@"informative"];

  uint64_t v38 = [v8 appletIdentifier];
  unsigned int v39 = +[NSData NF_dataWithHexString:v38];

  if (v39) {
    [v10 setObject:v39 forKeyedSubscript:@"aid"];
  }
  uint64_t v106 = v13;
  uint64_t v40 = [v8 transactionIdentifier];
  uint64_t v41 = +[NSData NF_dataWithHexString:v40];

  if (v41) {
    [v10 setObject:v41 forKeyedSubscript:@"transactionId"];
  }
  uint64_t v42 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(a1 + 8)];
  [v10 setObject:v42 forKeyedSubscript:@"totalRSSISamples"];

  BOOL v43 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(a1 + 12)];
  [v10 setObject:v43 forKeyedSubscript:@"avgRSSIValue"];

  uint64_t v44 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(a1 + 16)];
  [v10 setObject:v44 forKeyedSubscript:@"maxRSSIValue"];

  uint64_t v45 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)(a1 + 20)];
  [v10 setObject:v45 forKeyedSubscript:@"minRSSIValue"];

  uint64_t v46 = [v8 parsedInfo];
  uint64_t v47 = [v46 objectForKeyedSubscript:@"Transaction"];

  uint64_t v48 = [v8 parsedInfo];
  uint64_t v49 = [v48 objectForKeyedSubscript:@"State"];

  uint64_t v50 = [v49 objectForKeyedSubscript:@"SPRaw"];

  if (v50)
  {
    uint64_t v51 = [v49 objectForKeyedSubscript:@"SPRaw"];
    [v10 setObject:v51 forKeyedSubscript:@"SPRaw"];
  }
  uint64_t v52 = [v49 objectForKeyedSubscript:@"CardDenyListed"];

  if (v52)
  {
    BOOL v53 = [v49 objectForKeyedSubscript:@"CardDenyListed"];
    [v10 setObject:v53 forKeyedSubscript:@"CardBlacklisted"];
  }
  int v54 = [v49 objectForKeyedSubscript:@"CardExpirationDate"];

  if (v54)
  {
    uint64_t v55 = [v49 objectForKeyedSubscript:@"CardExpirationDate"];
    [v10 setObject:v55 forKeyedSubscript:@"CardExpirationDate"];
  }
  int v56 = [v49 objectForKeyedSubscript:@"TransactionInProgress"];

  if (v56)
  {
    int v57 = [v49 objectForKeyedSubscript:@"TransactionInProgress"];
    [v10 setObject:v57 forKeyedSubscript:@"TransactionInProgress"];
  }
  v58 = [v49 objectForKeyedSubscript:@"CardCurrencyCode"];

  if (v58)
  {
    uint64_t v59 = [v49 objectForKeyedSubscript:@"CardCurrencyCode"];
    [v10 setObject:v59 forKeyedSubscript:@"CardCurrencyCode"];
  }
  uint64_t v60 = [v47 objectForKeyedSubscript:@"StartStation"];

  if (v60)
  {
    uint64_t v61 = [v47 objectForKeyedSubscript:@"StartStation"];
    [v10 setObject:v61 forKeyedSubscript:@"StartStation"];
  }
  uint32_t v62 = [v47 objectForKeyedSubscript:@"EndStation"];

  if (v62)
  {
    uint64_t v63 = [v47 objectForKeyedSubscript:@"EndStation"];
    [v10 setObject:v63 forKeyedSubscript:@"EndStation"];
  }
  BOOL v64 = [v47 objectForKeyedSubscript:@"TerminalIdentifier"];

  if (v64)
  {
    uint64_t v65 = [v47 objectForKeyedSubscript:@"TerminalIdentifier"];
    [v10 setObject:v65 forKeyedSubscript:@"TerminalIdentifier"];
  }
  uint64_t v66 = [v47 objectForKeyedSubscript:@"TypeDetailRaw"];
  if (v66)
  {
    uint64_t v67 = (void *)v66;
    uint64_t v68 = [v47 objectForKeyedSubscript:@"TypeDetailRaw"];
    objc_opt_class();
    char v69 = objc_opt_isKindOfClass();

    if (v69)
    {
      int v70 = [v47 objectForKeyedSubscript:@"TypeDetailRaw"];
      [v10 setObject:v70 forKeyedSubscript:@"transactionTypeRaw"];

      int v71 = [v47 objectForKeyedSubscript:@"TypeDetailRaw"];
      id v72 = [v71 length];

      if ((unint64_t)v72 >= 3)
      {
        id v73 = [v47 objectForKeyedSubscript:@"TypeDetailRaw"];
        uint64_t v74 = (unsigned __int8 *)[v73 bytes];

        uint64_t v75 = +[NSNumber numberWithUnsignedChar:*v74];
        [v10 setObject:v75 forKeyedSubscript:@"transactionCategory"];

        BOOL v76 = +[NSNumber numberWithUnsignedChar:v74[1]];
        [v10 setObject:v76 forKeyedSubscript:@"transactionType"];

        uint64_t v77 = +[NSNumber numberWithUnsignedChar:v74[2]];
        [v10 setObject:v77 forKeyedSubscript:@"transactionExtension"];
      }
    }
  }
  BOOL v78 = [v49 objectForKeyedSubscript:@"SPRaw"];

  if (v78)
  {
    int v79 = [v49 objectForKeyedSubscript:@"SPRaw"];
    [v10 setObject:v79 forKeyedSubscript:@"issuerCityCode"];
  }
  uint64_t v80 = [v7 objectForKeyedSubscript:@"interface"];

  if (v80)
  {
    uint64_t v81 = [v7 objectForKeyedSubscript:@"interface"];
    [v10 setObject:v81 forKeyedSubscript:@"interface"];
  }
  int v82 = [v7 objectForKeyedSubscript:@"ReadOperationInfo"];

  if (v82)
  {
    uint64_t v83 = [v7 objectForKeyedSubscript:@"ReadOperationInfo"];
    [v10 setObject:v83 forKeyedSubscript:@"ReadOperationInfo"];
  }
  BOOL v84 = [v7 objectForKeyedSubscript:@"WriteOperationInfo"];

  if (v84)
  {
    uint64_t v85 = [v7 objectForKeyedSubscript:@"WriteOperationInfo"];
    [v10 setObject:v85 forKeyedSubscript:@"WriteOperationInfo"];
  }
LABEL_44:

  return v10;
}

void sub_1000DDA14(void *a1, void *a2)
{
  id v3 = a2;
  v4 = v3;
  if (a1)
  {
    id v5 = v3;
    id v6 = (char *)[v5 bytes];
    if ((unint64_t)[v5 length] > 2)
    {
      uint64_t v12 = [objc_alloc((Class)NSData) initWithBytes:v6 + 2 length:(char *)[v5 length] - 2];
      int v54 = +[NFFelicaStateEvent decodeLogEvent:v12];
      uint64_t v15 = a1[4];
      if (v15 && (*(void *)(v15 + 272) & 0x203) != 0)
      {
        uint64_t v51 = v12;
        uint64_t v52 = v4;
        long long v57 = 0u;
        long long v58 = 0u;
        long long v55 = 0u;
        long long v56 = 0u;
        id obj = [v54 allKeys];
        id v16 = [obj countByEnumeratingWithState:&v55 objects:v71 count:16];
        if (v16)
        {
          id v17 = v16;
          uint64_t v18 = *(void *)v56;
          do
          {
            for (i = 0; i != v17; i = (char *)i + 1)
            {
              if (*(void *)v56 != v18) {
                objc_enumerationMutation(obj);
              }
              id v20 = *(void **)(*((void *)&v55 + 1) + 8 * i);
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t Logger = NFLogGetLogger();
              if (Logger)
              {
                unsigned int v22 = (void (*)(uint64_t, const char *, ...))Logger;
                Class = object_getClass(a1);
                BOOL isMetaClass = class_isMetaClass(Class);
                ClassName = object_getClassName(a1);
                Name = sel_getName("_decodeFelicaLoggingEvent:");
                int v27 = [v54 objectForKeyedSubscript:v20];
                uint64_t v28 = 45;
                if (isMetaClass) {
                  uint64_t v28 = 43;
                }
                v22(5, "%c[%{public}s %{public}s]:%i [L-ICF] %{public}@ = %{public}@", v28, ClassName, Name, 234, v20, v27);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              int v29 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
              {
                id v30 = object_getClass(a1);
                if (class_isMetaClass(v30)) {
                  int v31 = 43;
                }
                else {
                  int v31 = 45;
                }
                unsigned int v32 = object_getClassName(a1);
                BOOL v33 = sel_getName("_decodeFelicaLoggingEvent:");
                id v34 = [v54 objectForKeyedSubscript:v20];
                *(_DWORD *)buf = 67110402;
                int v60 = v31;
                __int16 v61 = 2082;
                uint32_t v62 = v32;
                __int16 v63 = 2082;
                BOOL v64 = v33;
                __int16 v65 = 1024;
                int v66 = 234;
                __int16 v67 = 2114;
                id v68 = v20;
                __int16 v69 = 2114;
                int v70 = v34;
                _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i [L-ICF] %{public}@ = %{public}@", buf, 0x36u);
              }
            }
            id v17 = [obj countByEnumeratingWithState:&v55 objects:v71 count:16];
          }
          while (v17);
        }

        uint64_t v12 = v51;
        v4 = v52;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v35 = NFLogGetLogger();
      if (v35)
      {
        unsigned int v36 = (void (*)(uint64_t, const char *, ...))v35;
        int v37 = object_getClass(a1);
        uint64_t v38 = v12;
        BOOL v39 = class_isMetaClass(v37);
        uint64_t v48 = object_getClassName(a1);
        uint64_t v50 = sel_getName("_decodeFelicaLoggingEvent:");
        BOOL v40 = !v39;
        uint64_t v12 = v38;
        uint64_t v41 = 45;
        if (!v40) {
          uint64_t v41 = 43;
        }
        v36(6, "%c[%{public}s %{public}s]:%i %{public}@", v41, v48, v50, 237, v54);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v42 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
      {
        BOOL v43 = object_getClass(a1);
        if (class_isMetaClass(v43)) {
          int v44 = 43;
        }
        else {
          int v44 = 45;
        }
        uint64_t v45 = object_getClassName(a1);
        uint64_t v46 = sel_getName("_decodeFelicaLoggingEvent:");
        *(_DWORD *)buf = 67110146;
        int v60 = v44;
        __int16 v61 = 2082;
        uint32_t v62 = v45;
        __int16 v63 = 2082;
        BOOL v64 = v46;
        __int16 v65 = 1024;
        int v66 = 237;
        __int16 v67 = 2114;
        id v68 = v54;
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
      }
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v7 = NFLogGetLogger();
      if (v7)
      {
        id v8 = (void (*)(uint64_t, const char *, ...))v7;
        id v9 = object_getClass(a1);
        BOOL v10 = class_isMetaClass(v9);
        uint64_t v47 = object_getClassName(a1);
        uint64_t v49 = sel_getName("_decodeFelicaLoggingEvent:");
        uint64_t v11 = 45;
        if (v10) {
          uint64_t v11 = 43;
        }
        v8(3, "%c[%{public}s %{public}s]:%i Unexpected HCI event: %{public}@", v11, v47, v49, 226, v5);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v12 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        v13 = object_getClass(a1);
        if (class_isMetaClass(v13)) {
          int v14 = 43;
        }
        else {
          int v14 = 45;
        }
        *(_DWORD *)buf = 67110146;
        int v60 = v14;
        __int16 v61 = 2082;
        uint32_t v62 = object_getClassName(a1);
        __int16 v63 = 2082;
        BOOL v64 = sel_getName("_decodeFelicaLoggingEvent:");
        __int16 v65 = 1024;
        int v66 = 226;
        __int16 v67 = 2114;
        id v68 = v5;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected HCI event: %{public}@", buf, 0x2Cu);
      }
    }
  }
}

uint64_t sub_1000DDFAC(void *a1, unsigned __int16 *a2, unsigned int a3, unsigned int *a4, unsigned int *a5)
{
  id v9 = a1;
  BOOL v10 = [v9 objectForKeyedSubscript:@"command"];
  unsigned int v11 = [v10 intValue];

  unsigned int v12 = 0;
  unsigned int v13 = HIWORD(v11);
  *a4 = v11;
  *a5 = v11;
  unsigned int v14 = v11 >> 8;
  do
  {
    if (v13 == *a2)
    {
      if (v12 < a3)
      {
        while (v13 == *a2)
        {
          int v15 = a2[1];
          if (v15 == 0xFFFF)
          {
            int v18 = a2[2];
            if (v18 == 0xFFFF || v11 == v18)
            {
              *a4 = *((unsigned __int8 *)a2 + 6);
              switch(*((unsigned char *)a2 + 7))
              {
                case 1:
                case 3:
LABEL_24:
                  LOBYTE(v14) = v11;
                  break;
                case 2:
                case 4:
                  goto LABEL_26;
                default:
LABEL_25:
                  LOBYTE(v14) = 0;
                  break;
              }
              goto LABEL_26;
            }
          }
          else if (BYTE1(v11) == v15)
          {
            int v16 = a2[2];
            if (v16 == 0xFFFF || v11 == v16)
            {
              *a4 = *((unsigned __int8 *)a2 + 6);
              switch(*((unsigned char *)a2 + 7))
              {
                case 1:
                case 3:
                  goto LABEL_24;
                case 2:
                case 4:
                  break;
                default:
                  goto LABEL_25;
              }
LABEL_26:
              *a5 = v14;
              uint64_t v20 = 1;
              goto LABEL_27;
            }
          }
          ++v12;
          a2 += 4;
          if (v12 >= a3) {
            goto LABEL_21;
          }
        }
      }
    }
    else
    {
      ++v12;
      a2 += 4;
    }
  }
  while (v12 < a3);
LABEL_21:
  uint64_t v20 = 0;
LABEL_27:

  return v20;
}

id sub_1000DE16C(void *a1, void *a2, void *a3)
{
  id v5 = a3;
  uint64_t v51 = 0;
  id v6 = a2;
  uint64_t v7 = [a1 delegate];
  id v8 = [v6 NF_asHexString];

  id v9 = [v7 appletForIdentifier:v8 filtered:1];

  id v10 = [objc_alloc((Class)NSData) initWithBytes:&unk_100283973 length:10];
  unsigned int v11 = [v10 NF_asHexString];

  id v12 = [objc_alloc((Class)NSData) initWithBytes:&unk_10028397D length:8];
  unsigned int v13 = [v12 NF_asHexString];

  unsigned int v14 = [v9 moduleIdentifier];
  unsigned int v15 = [v14 isEqualToString:v11];

  if (v15)
  {
    if (sub_1000DDFAC(v5, word_100283996, 0x39u, (unsigned int *)&v51 + 1, (unsigned int *)&v51)) {
      goto LABEL_25;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v17 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("_caHCIActivityTimeoutEvent:parsedEvent:");
      uint64_t v21 = 45;
      if (isMetaClass) {
        uint64_t v21 = 43;
      }
      v17(6, "%c[%{public}s %{public}s]:%i Could not find Enum. Defaulting to CLA_INS_P1_P2 format ", v21, ClassName, Name, 509);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    unsigned int v22 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_24;
    }
    unsigned int v23 = object_getClass(a1);
    if (class_isMetaClass(v23)) {
      int v24 = 43;
    }
    else {
      int v24 = 45;
    }
    uint64_t v25 = object_getClassName(a1);
    id v26 = sel_getName("_caHCIActivityTimeoutEvent:parsedEvent:");
    *(_DWORD *)buf = 67109890;
    int v53 = v24;
    __int16 v54 = 2082;
    long long v55 = v25;
    __int16 v56 = 2082;
    long long v57 = v26;
    __int16 v58 = 1024;
    int v59 = 509;
    goto LABEL_23;
  }
  int v27 = [v9 moduleIdentifier];
  unsigned int v28 = [v27 isEqualToString:v13];

  if (v28 && (sub_1000DDFAC(v5, word_100283B5E, 0x35u, (unsigned int *)&v51 + 1, (unsigned int *)&v51) & 1) == 0)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v29 = NFLogGetLogger();
    if (v29)
    {
      id v30 = (void (*)(uint64_t, const char *, ...))v29;
      int v31 = object_getClass(a1);
      BOOL v32 = class_isMetaClass(v31);
      BOOL v33 = object_getClassName(a1);
      uint64_t v50 = sel_getName("_caHCIActivityTimeoutEvent:parsedEvent:");
      uint64_t v34 = 45;
      if (v32) {
        uint64_t v34 = 43;
      }
      v30(6, "%c[%{public}s %{public}s]:%i Could not find Enum. Defaulting to CLA_INS_P1_P2 format ", v34, v33, v50, 518);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    unsigned int v22 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_24;
    }
    uint64_t v35 = object_getClass(a1);
    if (class_isMetaClass(v35)) {
      int v36 = 43;
    }
    else {
      int v36 = 45;
    }
    int v37 = object_getClassName(a1);
    uint64_t v38 = sel_getName("_caHCIActivityTimeoutEvent:parsedEvent:");
    *(_DWORD *)buf = 67109890;
    int v53 = v36;
    __int16 v54 = 2082;
    long long v55 = v37;
    __int16 v56 = 2082;
    long long v57 = v38;
    __int16 v58 = 1024;
    int v59 = 518;
LABEL_23:
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Could not find Enum. Defaulting to CLA_INS_P1_P2 format ", buf, 0x22u);
LABEL_24:
  }
LABEL_25:
  BOOL v39 = objc_opt_new();
  BOOL v40 = [v5 objectForKeyedSubscript:@"spid"];
  uint64_t v41 = +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", [v40 intValue]);
  [v39 setObject:v41 forKeyedSubscript:@"spid"];

  uint64_t v42 = [v5 objectForKeyedSubscript:@"commandResult"];
  BOOL v43 = +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", [v42 intValue]);
  [v39 setObject:v43 forKeyedSubscript:@"commandResult"];

  int v44 = +[NSNumber numberWithUnsignedInt:HIDWORD(v51)];
  [v39 setObject:v44 forKeyedSubscript:@"command"];

  uint64_t v45 = +[NSNumber numberWithUnsignedInt:v51];
  [v39 setObject:v45 forKeyedSubscript:@"commandParam1"];

  uint64_t v46 = [v5 objectForKeyedSubscript:@"timeoutValue"];
  uint64_t v47 = +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", [v46 intValue]);
  [v39 setObject:v47 forKeyedSubscript:@"timeoutValue"];

  return v39;
}

uint64_t sub_1000DE6C4(void *a1, void *a2, void *a3)
{
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  if (![v6 didError]) {
    goto LABEL_22;
  }
  id v8 = [v5 moduleIdentifier];
  id v9 = [objc_alloc((Class)NSData) initWithBytes:&unk_10028403C length:10];
  id v10 = [v9 NF_asHexString];
  unsigned __int8 v11 = [v8 isEqualToString:v10];

  if (v11) {
    goto LABEL_22;
  }
  id v12 = [v5 moduleIdentifier];
  id v13 = [objc_alloc((Class)NSData) initWithBytes:&unk_100283FFC length:16];
  unsigned int v14 = [v13 NF_asHexString];
  if ([v12 isEqualToString:v14]) {
    goto LABEL_6;
  }
  unsigned int v15 = [v5 moduleIdentifier];
  id v16 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284046 length:16];
  id v17 = [v16 NF_asHexString];
  if ([v15 isEqualToString:v17])
  {

LABEL_6:
    goto LABEL_7;
  }
  [v5 moduleIdentifier];
  v21 = id v47 = v7;
  id v22 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284056 length:16];
  [v22 NF_asHexString];
  v23 = uint64_t v45 = v15;
  unsigned __int8 v46 = [v21 isEqualToString:v23];

  id v7 = v47;
  if ((v46 & 1) == 0) {
    goto LABEL_12;
  }
LABEL_7:
  int v18 = +[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", [v6 informative]);
  if (![&off_1003227C0 containsObject:v18])
  {
    v19 = +[NSNumber numberWithUnsignedShort:](NSNumber, "numberWithUnsignedShort:", [v6 result]);
    unsigned __int8 v20 = [&off_1003227A8 containsObject:v19];

    if (v20) {
      goto LABEL_22;
    }
LABEL_12:
    int v24 = [v5 moduleIdentifier];
    id v25 = [objc_alloc((Class)NSData) initWithBytes:&unk_10028397D length:8];
    id v26 = [v25 NF_asHexString];
    if ([v24 isEqualToString:v26])
    {
      unsigned int v27 = [v6 result];

      if (v27 == 64) {
        goto LABEL_22;
      }
    }
    else
    {
    }
    unsigned int v28 = [v5 moduleIdentifier];
    id v29 = [objc_alloc((Class)NSData) initWithBytes:&unk_100283973 length:10];
    id v30 = [v29 NF_asHexString];
    if ([v28 isEqualToString:v30])
    {
    }
    else
    {
      int v31 = [v5 moduleIdentifier];
      id v32 = [objc_alloc((Class)NSData) initWithBytes:&unk_10028397D length:8];
      BOOL v33 = [v32 NF_asHexString];
      unsigned int v34 = [v31 isEqualToString:v33];

      if (!v34) {
        goto LABEL_20;
      }
    }
    if ([v6 result] == 61444) {
      goto LABEL_22;
    }
LABEL_20:
    uint64_t v35 = [v5 moduleIdentifier];
    id v36 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284066 length:16];
    int v37 = [v36 NF_asHexString];
    if ([v35 isEqualToString:v37])
    {
      unsigned int v38 = [v6 result];

      if (v38 == 61440) {
        goto LABEL_22;
      }
    }
    else
    {
    }
    uint64_t v41 = [v5 moduleIdentifier];
    id v42 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284076 length:10];
    BOOL v43 = [v42 NF_asHexString];
    unsigned int v44 = [v41 isEqualToString:v43];

    uint64_t v39 = v44 ^ 1;
    goto LABEL_23;
  }

LABEL_22:
  uint64_t v39 = 0;
LABEL_23:

  return v39;
}

void sub_1000DEB74(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (v5)
  {
    id v7 = [v5 objectForKeyedSubscript:@"appletIdentifier"];

    if (v7)
    {
      id v8 = [v5 objectForKeyedSubscript:@"appletIdentifier"];
      if ([a1 isUnifiedAccess:v8])
      {
        if ([v6 isEqualToString:@"StartEvent"])
        {
          id v9 = +[NSDate now];
          CFStringRef v15 = @"startEventStartTime";
          id v16 = v9;
          id v10 = &v16;
          unsigned __int8 v11 = &v15;
LABEL_8:
          id v12 = +[NSDictionary dictionaryWithObjects:v10 forKeys:v11 count:1];
          sub_1000B516C((uint64_t)NFUnifiedAccessTransactionCALogger, v12, 1);

          goto LABEL_9;
        }
        if ([v6 isEqualToString:@"StepUpRequested"])
        {
          id v9 = +[NSDate now];
          CFStringRef v13 = @"stepUpEventStartTime";
          unsigned int v14 = v9;
          id v10 = &v14;
          unsigned __int8 v11 = &v13;
          goto LABEL_8;
        }
      }
LABEL_9:
    }
  }
}

void sub_1000DEDC4(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 32);
  if (v2 && (*(void *)(v2 + 272) & 0x200) != 0)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v4(6, "%c[%{public}s %{public}s]:%i app=%{public}@ event=%{public}@", v9, ClassName, Name, 885, *(void *)(a1 + 40), *(void *)(a1 + 48));
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      unsigned __int8 v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      CFStringRef v13 = object_getClassName(*(id *)(a1 + 32));
      unsigned int v14 = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v15 = *(void *)(a1 + 40);
      uint64_t v16 = *(void *)(a1 + 48);
      *(_DWORD *)buf = 67110402;
      int v446 = v12;
      __int16 v447 = 2082;
      v448 = v13;
      __int16 v449 = 2082;
      v450 = v14;
      __int16 v451 = 1024;
      int v452 = 885;
      __int16 v453 = 2114;
      *(void *)v454 = v15;
      *(_WORD *)&v454[8] = 2114;
      *(void *)&v454[10] = v16;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i app=%{public}@ event=%{public}@", buf, 0x36u);
    }
  }
  if ((unint64_t)[*(id *)(a1 + 48) length] <= 1)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v17 = NFLogGetLogger();
    if (v17)
    {
      int v18 = (void (*)(uint64_t, const char *, ...))v17;
      v19 = object_getClass(*(id *)(a1 + 32));
      BOOL v20 = class_isMetaClass(v19);
      uint64_t v21 = object_getClassName(*(id *)(a1 + 32));
      id v22 = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v23 = 45;
      if (v20) {
        uint64_t v23 = 43;
      }
      v18(3, "%c[%{public}s %{public}s]:%i Invalid length: %{public}@", v23, v21, v22, 890, *(void *)(a1 + 48));
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v24 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
      goto LABEL_100;
    }
    id v25 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v25)) {
      int v26 = 43;
    }
    else {
      int v26 = 45;
    }
    unsigned int v27 = object_getClassName(*(id *)(a1 + 32));
    unsigned int v28 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v29 = *(void *)(a1 + 48);
    *(_DWORD *)buf = 67110146;
    int v446 = v26;
    __int16 v447 = 2082;
    v448 = v27;
    __int16 v449 = 2082;
    v450 = v28;
    __int16 v451 = 1024;
    int v452 = 890;
    __int16 v453 = 2114;
    *(void *)v454 = v29;
    id v30 = "%c[%{public}s %{public}s]:%i Invalid length: %{public}@";
    int v31 = v24;
    uint32_t v32 = 44;
    goto LABEL_99;
  }
  uint64_t v33 = *(void *)(a1 + 32);
  uint64_t v423 = a1;
  unsigned int v34 = *(void **)(a1 + 48);
  int v24 = *(id *)(a1 + 40);
  id v35 = v34;
  if (!v33) {
    goto LABEL_63;
  }
  id v36 = [(id)v33 delegate];
  int v37 = [v24 NF_asHexString];
  unsigned int v38 = [v36 appletForIdentifier:v37 filtered:0];

  if (!v35 || !v38)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v59 = NFLogGetLogger();
    if (v59)
    {
      int v60 = (void (*)(uint64_t, const char *, ...))v59;
      __int16 v61 = object_getClass((id)v33);
      BOOL v62 = class_isMetaClass(v61);
      v384 = object_getClassName((id)v33);
      v399 = sel_getName("parseWithATLLib:event:");
      uint64_t v63 = 45;
      if (v62) {
        uint64_t v63 = 43;
      }
      v60(6, "%c[%{public}s %{public}s]:%i Failed to get applet from event %{public}@", v63, v384, v399, 721, v35);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v48 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_62;
    }
    BOOL v64 = object_getClass((id)v33);
    if (class_isMetaClass(v64)) {
      int v65 = 43;
    }
    else {
      int v65 = 45;
    }
    int v66 = object_getClassName((id)v33);
    __int16 v67 = sel_getName("parseWithATLLib:event:");
    *(_DWORD *)buf = 67110146;
    int v446 = v65;
    __int16 v447 = 2082;
    v448 = v66;
    __int16 v449 = 2082;
    v450 = v67;
    __int16 v451 = 1024;
    int v452 = 721;
    __int16 v453 = 2114;
    *(void *)v454 = v35;
    id v68 = "%c[%{public}s %{public}s]:%i Failed to get applet from event %{public}@";
LABEL_61:
    _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, v68, buf, 0x2Cu);
LABEL_62:

LABEL_63:
    uint64_t v78 = v423;
    goto LABEL_64;
  }
  uint64_t v39 = [(__CFString *)v38 identifier];
  if (!v39) {
    goto LABEL_52;
  }
  BOOL v40 = (void *)v39;
  uint64_t v41 = [(__CFString *)v38 packageIdentifier];
  if (!v41)
  {

    goto LABEL_52;
  }
  id v42 = (void *)v41;
  BOOL v43 = [(__CFString *)v38 moduleIdentifier];

  if (!v43)
  {
LABEL_52:
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v69 = NFLogGetLogger();
    if (v69)
    {
      int v70 = (void (*)(uint64_t, const char *, ...))v69;
      int v71 = object_getClass((id)v33);
      BOOL v72 = class_isMetaClass(v71);
      v385 = object_getClassName((id)v33);
      v400 = sel_getName("parseWithATLLib:event:");
      uint64_t v73 = 45;
      if (v72) {
        uint64_t v73 = 43;
      }
      v70(6, "%c[%{public}s %{public}s]:%i Failed to get applet information from applet %{public}@", v73, v385, v400, 725, v38);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v48 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_62;
    }
    uint64_t v74 = object_getClass((id)v33);
    if (class_isMetaClass(v74)) {
      int v75 = 43;
    }
    else {
      int v75 = 45;
    }
    BOOL v76 = object_getClassName((id)v33);
    uint64_t v77 = sel_getName("parseWithATLLib:event:");
    *(_DWORD *)buf = 67110146;
    int v446 = v75;
    __int16 v447 = 2082;
    v448 = v76;
    __int16 v449 = 2082;
    v450 = v77;
    __int16 v451 = 1024;
    int v452 = 725;
    __int16 v453 = 2114;
    *(void *)v454 = v38;
    id v68 = "%c[%{public}s %{public}s]:%i Failed to get applet information from applet %{public}@";
    goto LABEL_61;
  }
  unsigned int v44 = [(__CFString *)v38 identifier];
  uint64_t v45 = [(__CFString *)v38 packageIdentifier];
  unsigned __int8 v46 = [(__CFString *)v38 moduleIdentifier];
  id v434 = 0;
  id v47 = +[AppletTranslator parseHCIEvent:v35 withApplet:v44 withPackage:v45 withModule:v46 withTransceiver:0 withError:&v434];
  uint64_t v48 = v434;

  if (v47 || !v48)
  {
    if (!v48) {
      goto LABEL_234;
    }
  }
  else if ([v48 code] == (id)2)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v49 = NFLogGetLogger();
    if (v49)
    {
      uint64_t v50 = (void (*)(uint64_t, const char *, ...))v49;
      uint64_t v51 = object_getClass((id)v33);
      BOOL v52 = class_isMetaClass(v51);
      v383 = object_getClassName((id)v33);
      v398 = sel_getName("parseWithATLLib:event:");
      uint64_t v53 = 45;
      if (v52) {
        uint64_t v53 = 43;
      }
      v50(6, "%c[%{public}s %{public}s]:%i Applet not supported by the ATL : %{public}@", v53, v383, v398, 737, v48);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v54 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v54, OS_LOG_TYPE_DEFAULT))
    {
      long long v55 = object_getClass((id)v33);
      if (class_isMetaClass(v55)) {
        int v56 = 43;
      }
      else {
        int v56 = 45;
      }
      long long v57 = object_getClassName((id)v33);
      __int16 v58 = sel_getName("parseWithATLLib:event:");
      *(_DWORD *)buf = 67110146;
      int v446 = v56;
      __int16 v447 = 2082;
      v448 = v57;
      __int16 v449 = 2082;
      v450 = v58;
      __int16 v451 = 1024;
      int v452 = 737;
      __int16 v453 = 2114;
      *(void *)v454 = v48;
      _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Applet not supported by the ATL : %{public}@", buf, 0x2Cu);
    }

    goto LABEL_62;
  }
  if ([v48 code] == (id)1
    || [v48 code] == (id)4
    || [v48 code] == (id)5)
  {
    sel = v47;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v137 = NFLogGetLogger();
    if (v137)
    {
      uint64_t v138 = (void (*)(uint64_t, const char *, ...))v137;
      v139 = object_getClass((id)v33);
      BOOL v140 = class_isMetaClass(v139);
      v389 = object_getClassName((id)v33);
      v404 = sel_getName("parseWithATLLib:event:");
      uint64_t v141 = 45;
      if (v140) {
        uint64_t v141 = 43;
      }
      v138(6, "%c[%{public}s %{public}s]:%i Error : failed to get more info : %{public}@", v141, v389, v404, 746, v48);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v142 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v142, OS_LOG_TYPE_DEFAULT))
    {
      v143 = object_getClass((id)v33);
      if (class_isMetaClass(v143)) {
        int v144 = 43;
      }
      else {
        int v144 = 45;
      }
      BOOL v145 = object_getClassName((id)v33);
      uint64_t v146 = sel_getName("parseWithATLLib:event:");
      *(_DWORD *)buf = 67110146;
      int v446 = v144;
      __int16 v447 = 2082;
      v448 = v145;
      __int16 v449 = 2082;
      v450 = v146;
      __int16 v451 = 1024;
      int v452 = 746;
      __int16 v453 = 2114;
      *(void *)v454 = v48;
      _os_log_impl((void *)&_mh_execute_header, v142, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Error : failed to get more info : %{public}@", buf, 0x2Cu);
    }

    goto LABEL_268;
  }
LABEL_234:
  uint64_t v247 = [v47 objectForKeyedSubscript:@"EventType"];
  v431 = (void *)v247;
  sela = v47;
  if (!v247)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v281 = NFLogGetLogger();
    if (v281)
    {
      v282 = (void (*)(uint64_t, const char *, ...))v281;
      int v283 = object_getClass((id)v33);
      BOOL v284 = class_isMetaClass(v283);
      v285 = object_getClassName((id)v33);
      v412 = sel_getName("parseWithATLLib:event:");
      uint64_t v286 = 45;
      if (v284) {
        uint64_t v286 = 43;
      }
      v282(6, "%c[%{public}s %{public}s]:%i No event from ATL, HCI didn't contain a relevant message", v286, v285, v412, 754);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v287 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v287, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v288 = object_getClass((id)v33);
      if (class_isMetaClass(v288)) {
        int v289 = 43;
      }
      else {
        int v289 = 45;
      }
      __int16 v290 = object_getClassName((id)v33);
      v291 = sel_getName("parseWithATLLib:event:");
      *(_DWORD *)buf = 67109890;
      int v446 = v289;
      __int16 v447 = 2082;
      v448 = v290;
      __int16 v449 = 2082;
      v450 = v291;
      __int16 v451 = 1024;
      int v452 = 754;
      _os_log_impl((void *)&_mh_execute_header, v287, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i No event from ATL, HCI didn't contain a relevant message", buf, 0x22u);
    }

    goto LABEL_279;
  }
  int v248 = (void *)v247;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v292 = NFLogGetLogger();
    if (v292)
    {
      v293 = (void (*)(uint64_t, const char *, ...))v292;
      v294 = object_getClass((id)v33);
      BOOL v295 = class_isMetaClass(v294);
      v394 = object_getClassName((id)v33);
      v413 = sel_getName("parseWithATLLib:event:");
      uint64_t v296 = 45;
      if (v295) {
        uint64_t v296 = 43;
      }
      v293(6, "%c[%{public}s %{public}s]:%i Error : invalid event class : %{public}@", v296, v394, v413, 758, v431);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v297 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v297, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_290;
    }
    NSErrorUserInfoKey v298 = object_getClass((id)v33);
    if (class_isMetaClass(v298)) {
      int v299 = 43;
    }
    else {
      int v299 = 45;
    }
    v300 = object_getClassName((id)v33);
    int v301 = sel_getName("parseWithATLLib:event:");
    *(_DWORD *)buf = 67110146;
    int v446 = v299;
    __int16 v447 = 2082;
    v448 = v300;
    __int16 v449 = 2082;
    v450 = v301;
    __int16 v451 = 1024;
    int v452 = 758;
    __int16 v453 = 2114;
    *(void *)v454 = v431;
    __int16 v302 = "%c[%{public}s %{public}s]:%i Error : invalid event class : %{public}@";
    v303 = v297;
    os_log_type_t v304 = OS_LOG_TYPE_DEFAULT;
    goto LABEL_289;
  }
  if ([v248 isEqualToString:@"StartEvent"])
  {
    v249 = NFSharedSignpostLog();
    if (os_signpost_enabled(v249))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v249, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "AtlEvent", "AtlStartEvent", buf, 2u);
    }

    sub_1000DEB74((void *)v33, sela, v248);
    uint64_t v250 = *(void *)(v33 + 32);
    if (v250)
    {
      *(unsigned char *)(v250 + 216) = 0;
      uint64_t v251 = *(void *)(v33 + 32);
      if (v251) {
        *(unsigned char *)(v251 + 217) = 0;
      }
    }
    uint64_t v252 = [[NFContactlessPaymentStartEvent alloc] initWithDictionary:sela];
    if (v252)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v253 = NFLogGetLogger();
      if (v253)
      {
        v254 = (void (*)(uint64_t, const char *, ...))v253;
        v255 = object_getClass((id)v33);
        BOOL v256 = class_isMetaClass(v255);
        v257 = object_getClassName((id)v33);
        v410 = sel_getName("parseWithATLLib:event:");
        uint64_t v258 = 45;
        if (v256) {
          uint64_t v258 = 43;
        }
        v254(6, "%c[%{public}s %{public}s]:%i %{public}@", v258, v257, v410, 774, v252);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v259 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v259, OS_LOG_TYPE_DEFAULT))
      {
        v260 = object_getClass((id)v33);
        if (class_isMetaClass(v260)) {
          int v261 = 43;
        }
        else {
          int v261 = 45;
        }
        v262 = object_getClassName((id)v33);
        v263 = sel_getName("parseWithATLLib:event:");
        *(_DWORD *)buf = 67110146;
        int v446 = v261;
        __int16 v447 = 2082;
        v448 = v262;
        __int16 v449 = 2082;
        v450 = v263;
        __int16 v451 = 1024;
        int v452 = 774;
        __int16 v453 = 2114;
        *(void *)v454 = v252;
        _os_log_impl((void *)&_mh_execute_header, v259, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
      }

      id v264 = sub_1000DC74C((void *)v33, v24, sela, v252);
      id WeakRetained = objc_loadWeakRetained((id *)(v33 + 40));
      [WeakRetained handleTransactionStartEvent:v252 atlData:sela caData:v264];
    }
    char v266 = 1;
    goto LABEL_291;
  }
  if ([v248 isEqualToString:@"EndEvent"])
  {
    v305 = NFSharedSignpostLog();
    if (os_signpost_enabled(v305))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v305, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "AtlEndEventEnter", (const char *)&unk_100286819, buf, 2u);
    }

    objb = [[NFContactlessPaymentEndEvent alloc] initWithDictionary:sela];
    if (objb)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v306 = NFLogGetLogger();
      if (v306)
      {
        int v307 = (void (*)(uint64_t, const char *, ...))v306;
        __int16 v308 = object_getClass((id)v33);
        BOOL v309 = class_isMetaClass(v308);
        v395 = object_getClassName((id)v33);
        v414 = sel_getName("parseWithATLLib:event:");
        uint64_t v310 = 45;
        if (v309) {
          uint64_t v310 = 43;
        }
        v307(6, "%c[%{public}s %{public}s]:%i %{public}@", v310, v395, v414, 786, objb);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v311 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v311, OS_LOG_TYPE_DEFAULT))
      {
        v312 = object_getClass((id)v33);
        if (class_isMetaClass(v312)) {
          int v313 = 43;
        }
        else {
          int v313 = 45;
        }
        NSErrorUserInfoKey v314 = object_getClassName((id)v33);
        v315 = sel_getName("parseWithATLLib:event:");
        *(_DWORD *)buf = 67110146;
        int v446 = v313;
        __int16 v447 = 2082;
        v448 = v314;
        __int16 v449 = 2082;
        v450 = v315;
        __int16 v451 = 1024;
        int v452 = 786;
        __int16 v453 = 2114;
        *(void *)v454 = objb;
        _os_log_impl((void *)&_mh_execute_header, v311, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
      }

      v316 = sub_1000DCBA4(v33, v24, sela, objb);
      id v317 = objc_loadWeakRetained((id *)(v33 + 40));
      [v317 handleTransactionEndEvent:objb atlData:sela caData:v316];

      v425 = v316;
      if (sub_1000DE6C4(v38, objb, v316))
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v318 = NFLogGetLogger();
        if (v318)
        {
          v319 = (void (*)(uint64_t, const char *, ...))v318;
          v320 = object_getClass((id)v33);
          BOOL v321 = class_isMetaClass(v320);
          v396 = object_getClassName((id)v33);
          v415 = sel_getName("parseWithATLLib:event:");
          uint64_t v322 = 45;
          if (v321) {
            uint64_t v322 = 43;
          }
          v319(6, "%c[%{public}s %{public}s]:%i atEvent = %{public}@", v322, v396, v415, 796, sela);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v323 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v323, OS_LOG_TYPE_DEFAULT))
        {
          v324 = object_getClass((id)v33);
          if (class_isMetaClass(v324)) {
            int v325 = 43;
          }
          else {
            int v325 = 45;
          }
          v326 = object_getClassName((id)v33);
          v327 = sel_getName("parseWithATLLib:event:");
          *(_DWORD *)buf = 67110146;
          int v446 = v325;
          __int16 v447 = 2082;
          v448 = v326;
          __int16 v449 = 2082;
          v450 = v327;
          __int16 v451 = 1024;
          int v452 = 796;
          __int16 v453 = 2114;
          *(void *)v454 = sela;
          _os_log_impl((void *)&_mh_execute_header, v323, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i atEvent = %{public}@", buf, 0x2Cu);
        }

        v422 = [(__CFString *)v38 identifier];
        v328 = [(__CFString *)v38 identifier];
        v329 = [v422 substringToIndex:[v328 length] - 2];
        v330 = [sela valueForKey:@"result"];
        v331 = +[NSString stringWithFormat:@"Applet AID: %@, Error: %@", v329, v330];
        *(void *)v437 = @"Applet Identifier";
        v332 = [(__CFString *)v38 identifier];
        *(void *)&long long v455 = v332;
        *((void *)&v455 + 1) = @"Other Bug";
        *(void *)v438 = @"Classification";
        *(void *)&v438[8] = @"FailureKey";
        *(void *)&long long v456 = @"ttrTransaction";
        v333 = +[NSDictionary dictionaryWithObjects:&v455 forKeys:v437 count:3];
        sub_100198F4C((uint64_t)NFBugCapture, @"Transaction Failed ", v331, v333);
      }
      int v248 = v431;
    }

    char v266 = 1;
    goto LABEL_292;
  }
  if ([v248 isEqualToString:@"ActivityTimeout"])
  {
    v334 = NFSharedSignpostLog();
    if (os_signpost_enabled(v334))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v334, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "AtlActivityTimeoutEvent", (const char *)&unk_100286819, buf, 2u);
    }

    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v335 = NFLogGetLogger();
    if (v335)
    {
      v336 = (void (*)(uint64_t, const char *, ...))v335;
      v337 = object_getClass((id)v33);
      BOOL v338 = class_isMetaClass(v337);
      v339 = object_getClassName((id)v33);
      v416 = sel_getName("parseWithATLLib:event:");
      uint64_t v340 = 45;
      if (v338) {
        uint64_t v340 = 43;
      }
      v336(6, "%c[%{public}s %{public}s]:%i Got activity timeout", v340, v339, v416, 806);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v341 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v341, OS_LOG_TYPE_DEFAULT))
    {
      v342 = object_getClass((id)v33);
      if (class_isMetaClass(v342)) {
        int v343 = 43;
      }
      else {
        int v343 = 45;
      }
      v344 = object_getClassName((id)v33);
      v345 = sel_getName("parseWithATLLib:event:");
      *(_DWORD *)buf = 67109890;
      int v446 = v343;
      __int16 v447 = 2082;
      v448 = v344;
      __int16 v449 = 2082;
      v450 = v345;
      __int16 v451 = 1024;
      int v452 = 806;
      _os_log_impl((void *)&_mh_execute_header, v341, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Got activity timeout", buf, 0x22u);
    }

    v346 = [sela valueForKey:@"Result"];
    v435[0] = @"result";
    v435[1] = @"applet";
    v436[0] = v346;
    v436[1] = v38;
    v347 = +[NSDictionary dictionaryWithObjects:v436 forKeys:v435 count:2];
    v348 = sub_1000DE16C((void *)v33, v24, sela);
    id v349 = objc_loadWeakRetained((id *)(v33 + 40));
    [v349 handleAppletInactivityTimeout:v347 atlData:sela caData:v348];

    v350 = NFSharedSignpostLog();
    if (os_signpost_enabled(v350))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v350, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "AtlEvent", "AtlActivityTimeoutEvent", buf, 2u);
    }

LABEL_279:
    char v266 = 1;
LABEL_291:
    int v248 = v431;
    goto LABEL_292;
  }
  if (![v248 isEqualToString:@"StepUpRequested"])
  {
    unsigned int v364 = [v248 isEqualToString:@"UnavailableCertEvent"];
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v365 = NFLogGetLogger();
    v366 = (void (*)(uint64_t, const char *, ...))v365;
    if (v364)
    {
      if (v365)
      {
        v367 = object_getClass((id)v33);
        BOOL v368 = class_isMetaClass(v367);
        v369 = object_getClassName((id)v33);
        v418 = sel_getName("parseWithATLLib:event:");
        uint64_t v370 = 45;
        if (v368) {
          uint64_t v370 = 43;
        }
        v366(6, "%c[%{public}s %{public}s]:%i UnavailableCert Event", v370, v369, v418, 830);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v371 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v371, OS_LOG_TYPE_DEFAULT))
      {
        v372 = object_getClass((id)v33);
        if (class_isMetaClass(v372)) {
          int v373 = 43;
        }
        else {
          int v373 = 45;
        }
        v374 = object_getClassName((id)v33);
        v375 = sel_getName("parseWithATLLib:event:");
        *(_DWORD *)buf = 67109890;
        int v446 = v373;
        __int16 v447 = 2082;
        v448 = v374;
        __int16 v449 = 2082;
        v450 = v375;
        __int16 v451 = 1024;
        int v452 = 830;
        _os_log_impl((void *)&_mh_execute_header, v371, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i UnavailableCert Event", buf, 0x22u);
      }

      sub_1002405A0((uint64_t)NFHciTransactionEventCALogger, sela);
      goto LABEL_279;
    }
    if (v365)
    {
      v376 = object_getClass((id)v33);
      BOOL v377 = class_isMetaClass(v376);
      v397 = object_getClassName((id)v33);
      v419 = sel_getName("parseWithATLLib:event:");
      uint64_t v378 = 45;
      if (v377) {
        uint64_t v378 = 43;
      }
      v366(3, "%c[%{public}s %{public}s]:%i Unknown event type : %{public}@", v378, v397, v419, 834, v431);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v297 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v297, OS_LOG_TYPE_ERROR))
    {
LABEL_290:

      char v266 = 0;
      goto LABEL_291;
    }
    v379 = object_getClass((id)v33);
    if (class_isMetaClass(v379)) {
      int v380 = 43;
    }
    else {
      int v380 = 45;
    }
    v381 = object_getClassName((id)v33);
    v382 = sel_getName("parseWithATLLib:event:");
    *(_DWORD *)buf = 67110146;
    int v446 = v380;
    __int16 v447 = 2082;
    v448 = v381;
    __int16 v449 = 2082;
    v450 = v382;
    __int16 v451 = 1024;
    int v452 = 834;
    __int16 v453 = 2114;
    *(void *)v454 = v431;
    __int16 v302 = "%c[%{public}s %{public}s]:%i Unknown event type : %{public}@";
    v303 = v297;
    os_log_type_t v304 = OS_LOG_TYPE_ERROR;
LABEL_289:
    _os_log_impl((void *)&_mh_execute_header, v303, v304, v302, buf, 0x2Cu);
    goto LABEL_290;
  }
  v351 = NFSharedSignpostLog();
  if (os_signpost_enabled(v351))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v351, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "AtlStepUpEventEnter", (const char *)&unk_100286819, buf, 2u);
  }

  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v352 = NFLogGetLogger();
  if (v352)
  {
    v353 = (void (*)(uint64_t, const char *, ...))v352;
    v354 = object_getClass((id)v33);
    BOOL v355 = class_isMetaClass(v354);
    v356 = object_getClassName((id)v33);
    v417 = sel_getName("parseWithATLLib:event:");
    uint64_t v357 = 45;
    if (v355) {
      uint64_t v357 = 43;
    }
    v353(6, "%c[%{public}s %{public}s]:%i StepUp Event", v357, v356, v417, 820);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  v358 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v358, OS_LOG_TYPE_DEFAULT))
  {
    v359 = object_getClass((id)v33);
    if (class_isMetaClass(v359)) {
      int v360 = 43;
    }
    else {
      int v360 = 45;
    }
    v361 = object_getClassName((id)v33);
    v362 = sel_getName("parseWithATLLib:event:");
    *(_DWORD *)buf = 67109890;
    int v446 = v360;
    __int16 v447 = 2082;
    v448 = v361;
    __int16 v449 = 2082;
    v450 = v362;
    __int16 v451 = 1024;
    int v452 = 820;
    _os_log_impl((void *)&_mh_execute_header, v358, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i StepUp Event", buf, 0x22u);
  }

  int v248 = v431;
  sub_1000DEB74((void *)v33, sela, v431);
  id v363 = objc_loadWeakRetained((id *)(v33 + 40));
  [v363 handleStepUpEvent:sela forApplet:v38];

  char v266 = 1;
LABEL_292:

  uint64_t v78 = v423;
  if (v266) {
    return;
  }
LABEL_64:
  int v79 = (unsigned __int8 *)[*(id *)(v78 + 48) bytes];
  uint64_t v80 = *v79;
  uint64_t v81 = v79[1];
  if ([*(id *)(v78 + 40) length] != (id)8
    || *(void *)[*(id *)(v78 + 40) bytes] != 0x51010000A0
    || [*(id *)(v78 + 48) length] != (id)8
    || *(void *)v79 != 0x5A5A5A5AA5A5A5A5)
  {
    if (v81 != 1)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v100 = NFLogGetLogger();
      if (v100)
      {
        id v101 = (void (*)(uint64_t, const char *, ...))v100;
        uint64_t v102 = object_getClass(*(id *)(v78 + 32));
        BOOL v103 = class_isMetaClass(v102);
        v104 = object_getClassName(*(id *)(v78 + 32));
        BOOL v105 = sel_getName(*(SEL *)(v78 + 56));
        uint64_t v106 = 43;
        if (!v103) {
          uint64_t v106 = 45;
        }
        v101(4, "%c[%{public}s %{public}s]:%i Unsupport version %d: %{public}@ - %{public}@", v106, v104, v105, 911, v81, *(void *)(v78 + 40), *(void *)(v78 + 48));
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v24 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
        goto LABEL_100;
      }
      v107 = object_getClass(*(id *)(v78 + 32));
      if (class_isMetaClass(v107)) {
        int v108 = 43;
      }
      else {
        int v108 = 45;
      }
      uint64_t v109 = object_getClassName(*(id *)(v78 + 32));
      uint64_t v110 = sel_getName(*(SEL *)(v78 + 56));
      uint64_t v111 = *(void *)(v78 + 40);
      uint64_t v112 = *(void *)(v78 + 48);
      *(_DWORD *)buf = 67110658;
      int v446 = v108;
      __int16 v447 = 2082;
      v448 = v109;
      __int16 v449 = 2082;
      v450 = v110;
      __int16 v451 = 1024;
      int v452 = 911;
      __int16 v453 = 1024;
      *(_DWORD *)v454 = v81;
      *(_WORD *)&v454[4] = 2114;
      *(void *)&v454[6] = v111;
      *(_WORD *)&v454[14] = 2114;
      *(void *)&v454[16] = v112;
      id v30 = "%c[%{public}s %{public}s]:%i Unsupport version %d: %{public}@ - %{public}@";
      int v31 = v24;
      uint32_t v32 = 60;
      goto LABEL_99;
    }
    int v82 = *(void **)(v78 + 40);
    if (v82
      && [v82 length] == 5
      && ((uint64_t v83 = (unsigned __int8 *)[*(id *)(v78 + 40) bytes],
           *(_DWORD *)v83 == -1)
        ? (BOOL v84 = v83[4] == 255)
        : (BOOL v84 = 0),
          v84))
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v147 = NFLogGetLogger();
      if (v147)
      {
        v148 = (void (*)(uint64_t, const char *, ...))v147;
        int v149 = object_getClass(*(id *)(v78 + 32));
        BOOL v150 = class_isMetaClass(v149);
        v151 = object_getClassName(*(id *)(v78 + 32));
        v405 = sel_getName(*(SEL *)(v78 + 56));
        uint64_t v152 = 45;
        if (v150) {
          uint64_t v152 = 43;
        }
        v148(6, "%c[%{public}s %{public}s]:%i SEOS routing handler logging event", v152, v151, v405, 918);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v153 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v153, OS_LOG_TYPE_DEFAULT))
      {
        v154 = object_getClass(*(id *)(v78 + 32));
        if (class_isMetaClass(v154)) {
          int v155 = 43;
        }
        else {
          int v155 = 45;
        }
        v156 = object_getClassName(*(id *)(v78 + 32));
        BOOL v157 = sel_getName(*(SEL *)(v78 + 56));
        *(_DWORD *)buf = 67109890;
        int v446 = v155;
        __int16 v447 = 2082;
        v448 = v156;
        __int16 v449 = 2082;
        v450 = v157;
        __int16 v451 = 1024;
        int v452 = 918;
        _os_log_impl((void *)&_mh_execute_header, v153, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i SEOS routing handler logging event", buf, 0x22u);
      }
    }
    else if (v80 != 32)
    {
      if (v80 != 16)
      {
        if (v80 == 4)
        {
          id v85 = objc_loadWeakRetained((id *)(*(void *)(v78 + 32) + 40));
          __int16 v86 = *(void **)(v78 + 32);
          id v87 = *(id *)(v78 + 48);
          id v88 = v87;
          if (v86)
          {
            if ((unint64_t)[v87 length] > 3)
            {
              id v200 = v88;
              BOOL v201 = (char *)[v200 bytes];
              int v99 = objc_opt_new();
              __int16 v94 = [objc_alloc((Class)NSData) initWithBytes:&unk_100283965 length:14];
              if ((unint64_t)[v200 length] >= 5)
              {
                id v424 = [objc_alloc((Class)NSData) initWithBytes:v201 + 4 length:(char *)[v200 length] - 4];
                uint64_t v202 = +[NFTLV TLVWithTag:fromData:](NFTLV, "TLVWithTag:fromData:", 225);
                v430 = v202;
                if (!v202)
                {
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  uint64_t v203 = NFLogGetLogger();
                  if (v203)
                  {
                    uint64_t v204 = (void (*)(uint64_t, const char *, ...))v203;
                    int v205 = object_getClass(v86);
                    BOOL v206 = class_isMetaClass(v205);
                    id v207 = v85;
                    v208 = object_getClassName(v86);
                    v408 = sel_getName("_decodeCRSAuthTimerExpiredEvent:status:");
                    uint64_t v209 = 45;
                    if (v206) {
                      uint64_t v209 = 43;
                    }
                    v391 = v208;
                    id v85 = v207;
                    v204(3, "%c[%{public}s %{public}s]:%i Invalid TLV", v209, v391, v408, 185);
                  }
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  v210 = NFSharedLogGetLogger();
                  if (os_log_type_enabled(v210, OS_LOG_TYPE_ERROR))
                  {
                    v211 = object_getClass(v86);
                    if (class_isMetaClass(v211)) {
                      int v212 = 43;
                    }
                    else {
                      int v212 = 45;
                    }
                    uint64_t v213 = object_getClassName(v86);
                    v214 = sel_getName("_decodeCRSAuthTimerExpiredEvent:status:");
                    *(_DWORD *)buf = 67109890;
                    int v446 = v212;
                    __int16 v447 = 2082;
                    v448 = v213;
                    __int16 v449 = 2082;
                    v450 = v214;
                    __int16 v451 = 1024;
                    int v452 = 185;
                    _os_log_impl((void *)&_mh_execute_header, v210, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid TLV", buf, 0x22u);
                  }

                  uint64_t v202 = 0;
                }
                id obja = v85;
                long long v457 = 0u;
                long long v458 = 0u;
                long long v455 = 0u;
                long long v456 = 0u;
                v215 = [v202 childrenWithTag:79];
                id v216 = [v215 countByEnumeratingWithState:&v455 objects:buf count:16];
                if (v216)
                {
                  id v217 = v216;
                  uint64_t v218 = *(void *)v456;
                  do
                  {
                    for (i = 0; i != v217; i = (char *)i + 1)
                    {
                      if (*(void *)v456 != v218) {
                        objc_enumerationMutation(v215);
                      }
                      uint64_t v220 = [*(id *)(*((void *)&v455 + 1) + 8 * i) value];
                      if (([v220 isEqualToData:v94] & 1) == 0)
                      {
                        uint64_t v221 = [v220 NF_asHexString];
                        [v99 addObject:v221];
                      }
                    }
                    id v217 = [v215 countByEnumeratingWithState:&v455 objects:buf count:16];
                  }
                  while (v217);
                }

                id v85 = obja;
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v222 = NFLogGetLogger();
              if (v222)
              {
                v223 = (void (*)(uint64_t, const char *, ...))v222;
                uint64_t v224 = object_getClass(v86);
                BOOL v225 = class_isMetaClass(v224);
                v392 = object_getClassName(v86);
                v409 = sel_getName("_decodeCRSAuthTimerExpiredEvent:status:");
                uint64_t v226 = 45;
                if (v225) {
                  uint64_t v226 = 43;
                }
                v223(6, "%c[%{public}s %{public}s]:%i %{public}@", v226, v392, v409, 196, v99);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              BOOL v227 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v227, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v228 = object_getClass(v86);
                if (class_isMetaClass(v228)) {
                  int v229 = 43;
                }
                else {
                  int v229 = 45;
                }
                v230 = object_getClassName(v86);
                int v231 = sel_getName("_decodeCRSAuthTimerExpiredEvent:status:");
                *(_DWORD *)v437 = 67110146;
                *(_DWORD *)&v437[4] = v229;
                *(_WORD *)v438 = 2082;
                *(void *)&v438[2] = v230;
                *(_WORD *)&v438[10] = 2082;
                *(void *)&v438[12] = v231;
                __int16 v439 = 1024;
                int v440 = 196;
                __int16 v441 = 2114;
                v442 = v99;
                _os_log_impl((void *)&_mh_execute_header, v227, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", v437, 0x2Cu);
              }
            }
            else
            {
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v89 = NFLogGetLogger();
              if (v89)
              {
                unsigned int v90 = (void (*)(uint64_t, const char *, ...))v89;
                __int16 v91 = object_getClass(v86);
                BOOL v92 = class_isMetaClass(v91);
                v386 = object_getClassName(v86);
                v401 = sel_getName("_decodeCRSAuthTimerExpiredEvent:status:");
                uint64_t v93 = 45;
                if (v92) {
                  uint64_t v93 = 43;
                }
                v90(3, "%c[%{public}s %{public}s]:%i Unexpected HCI event: %{public}@", v93, v386, v401, 169, v88);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              __int16 v94 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
              {
                unsigned int v95 = object_getClass(v86);
                if (class_isMetaClass(v95)) {
                  int v96 = 43;
                }
                else {
                  int v96 = 45;
                }
                id v97 = object_getClassName(v86);
                __int16 v98 = sel_getName("_decodeCRSAuthTimerExpiredEvent:status:");
                *(_DWORD *)buf = 67110146;
                int v446 = v96;
                __int16 v447 = 2082;
                v448 = v97;
                __int16 v449 = 2082;
                v450 = v98;
                __int16 v451 = 1024;
                int v452 = 169;
                __int16 v453 = 2114;
                *(void *)v454 = v88;
                _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected HCI event: %{public}@", buf, 0x2Cu);
              }
              int v99 = 0;
            }
          }
          else
          {
            int v99 = 0;
          }

          [v85 handleTimerExpiredEvent:v99];
          +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:&off_100323000];
          return;
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v128 = NFLogGetLogger();
        if (v128)
        {
          uint64_t v129 = (void (*)(uint64_t, const char *, ...))v128;
          v130 = object_getClass(*(id *)(v78 + 32));
          BOOL v131 = class_isMetaClass(v130);
          v388 = object_getClassName(*(id *)(v78 + 32));
          v403 = sel_getName(*(SEL *)(v78 + 56));
          uint64_t v132 = 45;
          if (v131) {
            uint64_t v132 = 43;
          }
          v129(3, "%c[%{public}s %{public}s]:%i Unknown type: %d", v132, v388, v403, 955, v80);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v24 = NFSharedLogGetLogger();
        if (!os_log_type_enabled(v24, OS_LOG_TYPE_ERROR)) {
          goto LABEL_100;
        }
        uint64_t v133 = object_getClass(*(id *)(v78 + 32));
        if (class_isMetaClass(v133)) {
          int v134 = 43;
        }
        else {
          int v134 = 45;
        }
        int v135 = object_getClassName(*(id *)(v78 + 32));
        BOOL v136 = sel_getName(*(SEL *)(v78 + 56));
        *(_DWORD *)buf = 67110146;
        int v446 = v134;
        __int16 v447 = 2082;
        v448 = v135;
        __int16 v449 = 2082;
        v450 = v136;
        __int16 v451 = 1024;
        int v452 = 955;
        __int16 v453 = 1024;
        *(_DWORD *)v454 = v80;
        id v30 = "%c[%{public}s %{public}s]:%i Unknown type: %d";
        int v31 = v24;
        uint32_t v32 = 40;
LABEL_99:
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, v30, buf, v32);
LABEL_100:

        return;
      }
      int v113 = *(void **)(v78 + 32);
      id v114 = *(id *)(v78 + 48);
      if (!v113)
      {

        int v24 = 0;
        goto LABEL_100;
      }
      id v115 = v114;
      v116 = (char *)[v115 bytes];
      if ((unint64_t)[v115 length] > 2)
      {
        id v421 = v115;
        v420 = [objc_alloc((Class)NSData) initWithBytes:v116 + 2 length:(char *)[v115 length] - 2];
        v429 = +[NFFelicaStateEvent decodeEvent:reverse:](NFFelicaStateEvent, "decodeEvent:reverse:");
        uint64_t v158 = v113[4];
        if (v158 && (*(void *)(v158 + 272) & 0x203) != 0)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v159 = NFLogGetLogger();
          if (v159)
          {
            v160 = (void (*)(uint64_t, const char *, ...))v159;
            BOOL v161 = object_getClass(v113);
            BOOL v162 = class_isMetaClass(v161);
            v163 = object_getClassName(v113);
            v406 = sel_getName("_decodeFelicaStateEvent:");
            uint64_t v164 = 45;
            if (v162) {
              uint64_t v164 = 43;
            }
            v160(5, "%c[%{public}s %{public}s]:%i [L-ICF] HCI State event", v164, v163, v406, 212);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          int v165 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v165, OS_LOG_TYPE_DEFAULT))
          {
            v166 = object_getClass(v113);
            if (class_isMetaClass(v166)) {
              int v167 = 43;
            }
            else {
              int v167 = 45;
            }
            id v168 = object_getClassName(v113);
            uint64_t v169 = sel_getName("_decodeFelicaStateEvent:");
            *(_DWORD *)v437 = 67109890;
            *(_DWORD *)&v437[4] = v167;
            *(_WORD *)v438 = 2082;
            *(void *)&v438[2] = v168;
            *(_WORD *)&v438[10] = 2082;
            *(void *)&v438[12] = v169;
            __int16 v439 = 1024;
            int v440 = 212;
            _os_log_impl((void *)&_mh_execute_header, v165, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i [L-ICF] HCI State event", v437, 0x22u);
          }

          long long v457 = 0u;
          long long v458 = 0u;
          long long v455 = 0u;
          long long v456 = 0u;
          id obj = [v429 allKeys];
          id v170 = [obj countByEnumeratingWithState:&v455 objects:buf count:16];
          if (v170)
          {
            id v171 = v170;
            uint64_t v172 = *(void *)v456;
            do
            {
              for (j = 0; j != v171; j = (char *)j + 1)
              {
                if (*(void *)v456 != v172) {
                  objc_enumerationMutation(obj);
                }
                uint64_t v174 = *(void **)(*((void *)&v455 + 1) + 8 * (void)j);
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v175 = NFLogGetLogger();
                if (v175)
                {
                  v176 = (void (*)(uint64_t, const char *, ...))v175;
                  int v177 = object_getClass(v113);
                  BOOL v178 = class_isMetaClass(v177);
                  v179 = object_getClassName(v113);
                  uint64_t v180 = sel_getName("_decodeFelicaStateEvent:");
                  v181 = [v429 objectForKeyedSubscript:v174];
                  uint64_t v182 = 45;
                  if (v178) {
                    uint64_t v182 = 43;
                  }
                  v176(5, "%c[%{public}s %{public}s]:%i [L-ICF] %{public}@ = %{public}@", v182, v179, v180, 214, v174, v181);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                BOOL v183 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v183, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v184 = object_getClass(v113);
                  if (class_isMetaClass(v184)) {
                    int v185 = 43;
                  }
                  else {
                    int v185 = 45;
                  }
                  v186 = object_getClassName(v113);
                  int v187 = sel_getName("_decodeFelicaStateEvent:");
                  v188 = [v429 objectForKeyedSubscript:v174];
                  *(_DWORD *)v437 = 67110402;
                  *(_DWORD *)&v437[4] = v185;
                  *(_WORD *)v438 = 2082;
                  *(void *)&v438[2] = v186;
                  *(_WORD *)&v438[10] = 2082;
                  *(void *)&v438[12] = v187;
                  __int16 v439 = 1024;
                  int v440 = 214;
                  __int16 v441 = 2114;
                  v442 = v174;
                  __int16 v443 = 2114;
                  v444 = v188;
                  _os_log_impl((void *)&_mh_execute_header, v183, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i [L-ICF] %{public}@ = %{public}@", v437, 0x36u);
                }
              }
              id v171 = [obj countByEnumeratingWithState:&v455 objects:buf count:16];
            }
            while (v171);
          }

          uint64_t v78 = v423;
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v189 = NFLogGetLogger();
        if (v189)
        {
          BOOL v190 = (void (*)(uint64_t, const char *, ...))v189;
          uint64_t v191 = object_getClass(v113);
          BOOL v192 = class_isMetaClass(v191);
          v390 = object_getClassName(v113);
          v407 = sel_getName("_decodeFelicaStateEvent:");
          uint64_t v193 = 45;
          if (v192) {
            uint64_t v193 = 43;
          }
          v190(6, "%c[%{public}s %{public}s]:%i %{public}@", v193, v390, v407, 217, v421);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v194 = NFSharedLogGetLogger();
        v117 = v421;
        if (os_log_type_enabled(v194, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v195 = object_getClass(v113);
          if (class_isMetaClass(v195)) {
            int v196 = 43;
          }
          else {
            int v196 = 45;
          }
          uint64_t v197 = object_getClassName(v113);
          uint64_t v198 = sel_getName("_decodeFelicaStateEvent:");
          *(_DWORD *)v437 = 67110146;
          *(_DWORD *)&v437[4] = v196;
          *(_WORD *)v438 = 2082;
          *(void *)&v438[2] = v197;
          *(_WORD *)&v438[10] = 2082;
          *(void *)&v438[12] = v198;
          __int16 v439 = 1024;
          int v440 = 217;
          __int16 v441 = 2114;
          v442 = v421;
          _os_log_impl((void *)&_mh_execute_header, v194, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", v437, 0x2Cu);
        }

        int v24 = v429;
        uint64_t v123 = v420;
      }
      else
      {
        v117 = v115;
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v118 = NFLogGetLogger();
        if (v118)
        {
          uint64_t v119 = (void (*)(uint64_t, const char *, ...))v118;
          v120 = object_getClass(v113);
          BOOL v121 = class_isMetaClass(v120);
          v387 = object_getClassName(v113);
          v402 = sel_getName("_decodeFelicaStateEvent:");
          uint64_t v122 = 45;
          if (v121) {
            uint64_t v122 = 43;
          }
          v119(3, "%c[%{public}s %{public}s]:%i Unexpected HCI event: %{public}@", v122, v387, v402, 205, v115);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v123 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v123, OS_LOG_TYPE_ERROR))
        {
          int v124 = object_getClass(v113);
          if (class_isMetaClass(v124)) {
            int v125 = 43;
          }
          else {
            int v125 = 45;
          }
          int v126 = object_getClassName(v113);
          v127 = sel_getName("_decodeFelicaStateEvent:");
          *(_DWORD *)v437 = 67110146;
          *(_DWORD *)&v437[4] = v125;
          *(_WORD *)v438 = 2082;
          *(void *)&v438[2] = v126;
          *(_WORD *)&v438[10] = 2082;
          *(void *)&v438[12] = v127;
          __int16 v439 = 1024;
          int v440 = 205;
          __int16 v441 = 2114;
          v442 = v117;
          _os_log_impl((void *)&_mh_execute_header, v123, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected HCI event: %{public}@", v437, 0x2Cu);
        }
        int v24 = 0;
      }

      if (!v24) {
        goto LABEL_100;
      }
      id v35 = [objc_alloc((Class)NSMutableDictionary) initWithDictionary:v24];
      v199 = *(void **)(v78 + 40);
      if (v199)
      {
        [v199 NF_asHexString];
        unsigned int v38 = (__CFString *)objc_claimAutoreleasedReturnValue();
      }
      else
      {
        unsigned int v38 = &stru_100309C40;
      }
      [v35 setObject:v38 forKey:@"NFAppletAID"];
      uint64_t v267 = *(void *)(v78 + 32);
      uint64_t v268 = *(void *)(v267 + 32);
      if (v268 && (*(void *)(v268 + 272) & 0x200) != 0)
      {
        id v269 = v24;
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v270 = NFLogGetLogger();
        if (v270)
        {
          v271 = (void (*)(uint64_t, const char *, ...))v270;
          v272 = object_getClass(*(id *)(v78 + 32));
          BOOL v273 = class_isMetaClass(v272);
          v393 = object_getClassName(*(id *)(v78 + 32));
          v411 = sel_getName(*(SEL *)(v78 + 56));
          uint64_t v274 = 45;
          if (v273) {
            uint64_t v274 = 43;
          }
          v271(6, "%c[%{public}s %{public}s]:%i stateInfo: %{public}@", v274, v393, v411, 941, v35);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v275 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v275, OS_LOG_TYPE_DEFAULT))
        {
          id v276 = object_getClass(*(id *)(v78 + 32));
          if (class_isMetaClass(v276)) {
            int v277 = 43;
          }
          else {
            int v277 = 45;
          }
          CFStringRef v278 = object_getClassName(*(id *)(v78 + 32));
          v279 = sel_getName(*(SEL *)(v78 + 56));
          *(_DWORD *)buf = 67110146;
          int v446 = v277;
          __int16 v447 = 2082;
          v448 = v278;
          __int16 v449 = 2082;
          v450 = v279;
          __int16 v451 = 1024;
          int v452 = 941;
          __int16 v453 = 2114;
          *(void *)v454 = v35;
          _os_log_impl((void *)&_mh_execute_header, v275, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i stateInfo: %{public}@", buf, 0x2Cu);
        }

        uint64_t v267 = *(void *)(v78 + 32);
        int v24 = v269;
      }
      id v280 = objc_loadWeakRetained((id *)(v267 + 40));
      [v280 handleFelicaStateEvent:v35 appletAID:v38];

LABEL_268:
      goto LABEL_100;
    }
    sub_1000DDA14(*(void **)(v78 + 32), *(void **)(v78 + 48));
    return;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v232 = NFLogGetLogger();
  if (v232)
  {
    int v233 = (void (*)(uint64_t, const char *, ...))v232;
    v234 = object_getClass(*(id *)(v78 + 32));
    BOOL v235 = class_isMetaClass(v234);
    v236 = object_getClassName(*(id *)(v78 + 32));
    v237 = sel_getName(*(SEL *)(v78 + 56));
    uint64_t v238 = 45;
    if (v235) {
      uint64_t v238 = 43;
    }
    v233(4, "%c[%{public}s %{public}s]:%i SE reset : %{public}@ - %{public}@", v238, v236, v237, 905, *(void *)(v78 + 40), *(void *)(v78 + 48));
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v239 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v239, OS_LOG_TYPE_ERROR))
  {
    v240 = object_getClass(*(id *)(v78 + 32));
    if (class_isMetaClass(v240)) {
      int v241 = 43;
    }
    else {
      int v241 = 45;
    }
    v242 = object_getClassName(*(id *)(v78 + 32));
    v243 = sel_getName(*(SEL *)(v78 + 56));
    uint64_t v244 = *(void *)(v78 + 40);
    uint64_t v245 = *(void *)(v78 + 48);
    *(_DWORD *)buf = 67110402;
    int v446 = v241;
    __int16 v447 = 2082;
    v448 = v242;
    __int16 v449 = 2082;
    v450 = v243;
    __int16 v451 = 1024;
    int v452 = 905;
    __int16 v453 = 2114;
    *(void *)v454 = v244;
    *(_WORD *)&v454[8] = 2114;
    *(void *)&v454[10] = v245;
    _os_log_impl((void *)&_mh_execute_header, v239, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i SE reset : %{public}@ - %{public}@", buf, 0x36u);
  }

  v246 = NFSharedSignpostLog();
  if (os_signpost_enabled(v246))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v246, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "HCI SE Reset", (const char *)&unk_100286819, buf, 2u);
  }
}

void sub_1000E1B30(uint64_t a1)
{
  id obj = *(id *)(a1 + 32);
  objc_sync_enter(obj);
  *(_DWORD *)(*(void *)(a1 + 32) + 8) = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(*(void *)(a1 + 32) + 12) = *(_DWORD *)(a1 + 44);
  *(_DWORD *)(*(void *)(a1 + 32) + 16) = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(*(void *)(a1 + 32) + 20) = *(_DWORD *)(a1 + 52);
  objc_sync_exit(obj);
}

void sub_1000E2218(void *a1)
{
  if (a1)
  {
    uint64_t v2 = [a1 fieldDetectSessions];
    id v3 = [v2 count];

    if (v3)
    {
      v4 = objc_opt_new();
      long long v11 = 0u;
      long long v12 = 0u;
      long long v13 = 0u;
      long long v14 = 0u;
      id v5 = [a1 fieldDetectSessions];
      id v6 = [v5 countByEnumeratingWithState:&v11 objects:v15 count:16];
      if (v6)
      {
        id v7 = v6;
        uint64_t v8 = *(void *)v12;
        do
        {
          uint64_t v9 = 0;
          do
          {
            if (*(void *)v12 != v8) {
              objc_enumerationMutation(v5);
            }
            if (!*(void *)(*((void *)&v11 + 1) + 8 * (void)v9)) {
              [v4 addObject:0];
            }
            uint64_t v9 = (char *)v9 + 1;
          }
          while (v7 != v9);
          id v7 = [v5 countByEnumeratingWithState:&v11 objects:v15 count:16];
        }
        while (v7);
      }

      id v10 = [a1 fieldDetectSessions];
      [v10 minusHashTable:v4];
    }
  }
}

id sub_1000E27F4(uint64_t a1)
{
  return [*(id *)(a1 + 32) maybeStartNextSession];
}

id sub_1000E2988(uint64_t a1)
{
  return [*(id *)(a1 + 32) maybeStartNextSession];
}

id sub_1000E4524()
{
  self;
  id v0 = objc_alloc((Class)NSSet);
  uint64_t v1 = objc_opt_class();
  uint64_t v2 = objc_opt_class();
  id v38 = [v0 initWithObjects:v1, v2, objc_opt_class(), 0];
  id v36 = objc_alloc((Class)NSSet);
  uint64_t v3 = objc_opt_class();
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_opt_class();
  uint64_t v8 = objc_opt_class();
  uint64_t v9 = objc_opt_class();
  uint64_t v10 = objc_opt_class();
  uint64_t v11 = objc_opt_class();
  uint64_t v12 = objc_opt_class();
  id v13 = [v36 initWithObjects:v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, objc_opt_class(), 0];
  id v14 = [objc_alloc((Class)NSSet) initWithObjects:objc_opt_class(), 0];
  id v15 = objc_alloc((Class)NSSet);
  uint64_t v16 = objc_opt_class();
  id v37 = [v15 initWithObjects:v16, objc_opt_class(), 0];
  id v35 = [objc_alloc((Class)NSSet) initWithObjects:objc_opt_class(), 0];
  id v17 = objc_alloc((Class)NSSet);
  uint64_t v18 = objc_opt_class();
  id v34 = [v17 initWithObjects:v18, objc_opt_class(), 0];
  v19 = +[NSXPCInterface interfaceWithProtocol:&OBJC_PROTOCOL___NFContactlessPaymentSessionInterface];
  [v19 setClasses:v14 forSelector:"setActivePaymentApplet:keys:authorization:completion:" argumentIndex:0 ofReply:0];
  [v19 setClasses:v14 forSelector:"setActivePaymentApplet:keys:authorization:completion:" argumentIndex:0 ofReply:1];
  [v19 setClasses:v37 forSelector:"setActivePaymentApplets:authorization:completion:" argumentIndex:0 ofReply:0];
  [v19 setClasses:v35 forSelector:"setActivePaymentApplets:authorization:completion:" argumentIndex:1 ofReply:0];
  uint64_t v33 = v14;
  [v19 setClasses:v14 forSelector:"setActivePaymentApplets:authorization:completion:" argumentIndex:0 ofReply:1];
  [v19 setClasses:v34 forSelector:"setActivePaymentApplets:authorization:completion:" argumentIndex:1 ofReply:1];
  [v19 setClasses:v38 forSelector:"getAppletsWithCompletion:" argumentIndex:0 ofReply:1];
  [v19 setClasses:v14 forSelector:"getAppletsWithCompletion:" argumentIndex:1 ofReply:1];
  [v19 setClasses:v38 forSelector:"getFelicaAppletState:completion:" argumentIndex:0 ofReply:0];
  uint32_t v32 = v13;
  [v19 setClasses:v13 forSelector:"getFelicaAppletState:completion:" argumentIndex:0 ofReply:1];
  [v19 setClasses:v38 forSelector:"getTransitAppletState:completion:" argumentIndex:0 ofReply:0];
  [v19 setClasses:v13 forSelector:"getTransitAppletState:completion:" argumentIndex:0 ofReply:1];
  id v31 = objc_alloc((Class)NSSet);
  uint64_t v20 = objc_opt_class();
  uint64_t v21 = objc_opt_class();
  uint64_t v22 = objc_opt_class();
  uint64_t v23 = objc_opt_class();
  uint64_t v24 = objc_opt_class();
  uint64_t v25 = objc_opt_class();
  uint64_t v26 = objc_opt_class();
  uint64_t v27 = objc_opt_class();
  uint64_t v28 = objc_opt_class();
  id v29 = [v31 initWithObjects:v20, v21, v22, v23, v24, v25, v26, v27, v28, objc_opt_class(), 0];
  [v19 setClasses:v29 forSelector:"setHostCards:" argumentIndex:0 ofReply:0];

  return v19;
}

id sub_1000E4A14()
{
  self;
  uint64_t v25 = +[NSXPCInterface interfaceWithProtocol:&OBJC_PROTOCOL___NFContactlessPaymentSessionCallbacks];
  id v23 = objc_alloc((Class)NSSet);
  uint64_t v21 = objc_opt_class();
  uint64_t v0 = objc_opt_class();
  uint64_t v1 = objc_opt_class();
  uint64_t v2 = objc_opt_class();
  uint64_t v3 = objc_opt_class();
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_opt_class();
  uint64_t v8 = objc_opt_class();
  id v9 = [v23 initWithObjects:v21, v0, v1, v2, v3, v4, v5, v6, v7, v8, objc_opt_class(), 0];
  [v25 setClasses:v9 forSelector:"didPerformValueAddedServiceTransactions:" argumentIndex:0 ofReply:0];
  id v24 = objc_alloc((Class)NSSet);
  uint64_t v22 = objc_opt_class();
  uint64_t v10 = objc_opt_class();
  uint64_t v11 = objc_opt_class();
  uint64_t v12 = objc_opt_class();
  uint64_t v13 = objc_opt_class();
  uint64_t v14 = objc_opt_class();
  uint64_t v15 = objc_opt_class();
  uint64_t v16 = objc_opt_class();
  uint64_t v17 = objc_opt_class();
  uint64_t v18 = objc_opt_class();
  id v19 = [v24 initWithObjects:v22, v10, v11, v12, v13, v14, v15, v16, v17, v18, objc_opt_class(), 0];
  [v25 setClasses:v19 forSelector:"didFelicaStateChange:" argumentIndex:0 ofReply:0];

  return v25;
}

void sub_1000E53E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id location)
{
}

void sub_1000E53F8(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v3 = WeakRetained;
  if (WeakRetained && ([WeakRetained didEnd] & 1) == 0)
  {
    kdebug_trace();
    uint64_t v4 = NFSharedSignpostLog();
    if (os_signpost_enabled(v4))
    {
      uint64_t v5 = [v3 clientName];
      *(_DWORD *)buf = 138412290;
      *(void *)id v38 = v5;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "TAG_SESSION_START_EMULATION", "starting Tag Emulation session for client %@", buf, 0xCu);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v7 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v12 = [v3 clientName];
      uint64_t v13 = 45;
      if (isMetaClass) {
        uint64_t v13 = 43;
      }
      v7(6, "%c[%{public}s %{public}s]:%i %{public}@", v13, ClassName, Name, 95, v12);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v14 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v15)) {
        int v16 = 43;
      }
      else {
        int v16 = 45;
      }
      uint64_t v17 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v18 = sel_getName(*(SEL *)(a1 + 48));
      id v19 = [v3 clientName];
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)id v38 = v16;
      *(_WORD *)&v38[4] = 2082;
      *(void *)&v38[6] = v17;
      __int16 v39 = 2082;
      BOOL v40 = v18;
      __int16 v41 = 1024;
      int v42 = 95;
      __int16 v43 = 2114;
      unsigned int v44 = v19;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
    }
    uint64_t v20 = +[_NFHardwareManager sharedHardwareManager];
    uint64_t v21 = +[NFRoutingConfig hostCardEmulation];
    id v22 = [v20 setRoutingConfig:v21];

    uint64_t v23 = NFLogGetLogger();
    if (v23)
    {
      id v24 = (void (*)(uint64_t, const char *, ...))v23;
      uint64_t v25 = object_getClass(*(id *)(a1 + 32));
      BOOL v26 = class_isMetaClass(v25);
      uint64_t v27 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v28 = sel_getName(*(SEL *)(a1 + 48));
      id v29 = [v3 clientName];
      uint64_t v30 = 45;
      if (v26) {
        uint64_t v30 = 43;
      }
      v24(6, "%c[%{public}s %{public}s]:%i NFC emulation mode activated: %@", v30, v27, v28, 98, v29);
    }
    id v31 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      uint32_t v32 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v32)) {
        int v33 = 43;
      }
      else {
        int v33 = 45;
      }
      id v34 = object_getClassName(*(id *)(a1 + 32));
      id v35 = sel_getName(*(SEL *)(a1 + 48));
      id v36 = [v3 clientName];
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)id v38 = v33;
      *(_WORD *)&v38[4] = 2082;
      *(void *)&v38[6] = v34;
      __int16 v39 = 2082;
      BOOL v40 = v35;
      __int16 v41 = 1024;
      int v42 = 98;
      __int16 v43 = 2112;
      unsigned int v44 = v36;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NFC emulation mode activated: %@", buf, 0x2Cu);
    }
  }
}

void sub_1000E712C(_Unwind_Exception *a1)
{
  objc_destroyWeak((id *)(v1 - 176));
  _Unwind_Resume(a1);
}

void sub_1000E7148(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  if (WeakRetained)
  {
    id v3 = WeakRetained;
    [WeakRetained _handleOneAPDU:*(void *)(a1 + 32)];
    id WeakRetained = v3;
  }
}

void sub_1000E7318(uint64_t a1)
{
  kdebug_trace();
  uint64_t v2 = NFSharedSignpostLog();
  if (os_signpost_enabled(v2))
  {
    *(_WORD *)buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v2, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "TAG_SESSION_START_EMULATION", "begin", buf, 2u);
  }

  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    id v9 = [*(id *)(a1 + 32) clientName];
    uint64_t v10 = 45;
    if (isMetaClass) {
      uint64_t v10 = 43;
    }
    v4(6, "%c[%{public}s %{public}s]:%i %{public}@", v10, ClassName, Name, 276, v9);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v11 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12)) {
      int v13 = 43;
    }
    else {
      int v13 = 45;
    }
    uint64_t v14 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v15 = sel_getName(*(SEL *)(a1 + 56));
    int v16 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)buf = 67110146;
    int v65 = v13;
    __int16 v66 = 2082;
    __int16 v67 = v14;
    __int16 v68 = 2082;
    uint64_t v69 = v15;
    __int16 v70 = 1024;
    int v71 = 276;
    __int16 v72 = 2114;
    uint64_t v73 = v16;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    id v37 = *(void **)(a1 + 40);
    if (v37)
    {
      sub_1000B7A24(*(void *)(*(void *)(a1 + 32) + 168), v37);
      id v38 = +[_NFHardwareManager sharedHardwareManager];
      __int16 v39 = +[NFRoutingConfig hostCardEmulation];
      id v40 = [v38 setRoutingConfig:v39];

      (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
      uint64_t v41 = NFLogGetLogger();
      if (v41)
      {
        int v42 = (void (*)(uint64_t, const char *, ...))v41;
        __int16 v43 = object_getClass(*(id *)(a1 + 32));
        BOOL v44 = class_isMetaClass(v43);
        uint64_t v45 = object_getClassName(*(id *)(a1 + 32));
        unsigned __int8 v46 = sel_getName(*(SEL *)(a1 + 56));
        id v47 = [*(id *)(a1 + 32) clientName];
        uint64_t v48 = 45;
        if (v44) {
          uint64_t v48 = 43;
        }
        v42(6, "%c[%{public}s %{public}s]:%i NFC emulation mode activated: %@", v48, v45, v46, 290, v47);
      }
      uint64_t v49 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v50 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v50)) {
          int v51 = 43;
        }
        else {
          int v51 = 45;
        }
        BOOL v52 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v53 = sel_getName(*(SEL *)(a1 + 56));
        __int16 v54 = [*(id *)(a1 + 32) clientName];
        *(_DWORD *)buf = 67110146;
        int v65 = v51;
        __int16 v66 = 2082;
        __int16 v67 = v52;
        __int16 v68 = 2082;
        uint64_t v69 = v53;
        __int16 v70 = 1024;
        int v71 = 290;
        __int16 v72 = 2112;
        uint64_t v73 = v54;
        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NFC emulation mode activated: %@", buf, 0x2Cu);
      }
    }
    else
    {
      uint64_t v55 = *(void *)(a1 + 48);
      id v56 = objc_alloc((Class)NSError);
      uint64_t v49 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v60 = NSLocalizedDescriptionKey;
      long long v57 = +[NSString stringWithUTF8String:"Invalid Parameter"];
      __int16 v61 = v57;
      __int16 v58 = +[NSDictionary dictionaryWithObjects:&v61 forKeys:&v60 count:1];
      id v59 = [v56 initWithDomain:v49 code:10 userInfo:v58];
      (*(void (**)(uint64_t, id))(v55 + 16))(v55, v59);
    }
    kdebug_trace();
    int v33 = NFSharedSignpostLog();
    if (os_signpost_enabled(v33))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v33, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "TAG_SESSION_START_EMULATION", "end", buf, 2u);
    }
    goto LABEL_26;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v17 = NFLogGetLogger();
  if (v17)
  {
    uint64_t v18 = (void (*)(uint64_t, const char *, ...))v17;
    id v19 = object_getClass(*(id *)(a1 + 32));
    BOOL v20 = class_isMetaClass(v19);
    uint64_t v21 = object_getClassName(*(id *)(a1 + 32));
    id v22 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v23 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v24 = 45;
    if (v20) {
      uint64_t v24 = 43;
    }
    v18(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v24, v21, v22, 278, v23);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v25 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
  {
    BOOL v26 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v26)) {
      int v27 = 43;
    }
    else {
      int v27 = 45;
    }
    uint64_t v28 = object_getClassName(*(id *)(a1 + 32));
    id v29 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v30 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)buf = 67110146;
    int v65 = v27;
    __int16 v66 = 2082;
    __int16 v67 = v28;
    __int16 v68 = 2082;
    uint64_t v69 = v29;
    __int16 v70 = 1024;
    int v71 = 278;
    __int16 v72 = 2114;
    uint64_t v73 = v30;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v31 = *(void *)(a1 + 48);
  if (v31)
  {
    id v32 = objc_alloc((Class)NSError);
    int v33 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v62 = NSLocalizedDescriptionKey;
    id v34 = +[NSString stringWithUTF8String:"Session not active"];
    uint64_t v63 = v34;
    id v35 = +[NSDictionary dictionaryWithObjects:&v63 forKeys:&v62 count:1];
    id v36 = [v32 initWithDomain:v33 code:54 userInfo:v35];
    (*(void (**)(uint64_t, id))(v31 + 16))(v31, v36);

LABEL_26:
  }
}

void sub_1000E7B30(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 300, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    int v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v15 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)buf = 67110146;
    int v55 = v12;
    __int16 v56 = 2082;
    long long v57 = v13;
    __int16 v58 = 2082;
    id v59 = v14;
    __int16 v60 = 1024;
    int v61 = 300;
    __int16 v62 = 2114;
    uint64_t v63 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    id v36 = +[_NFHardwareManager sharedHardwareManager];
    id v37 = +[NFRoutingConfig routingOff];
    id v38 = [v36 setRoutingConfig:v37];

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    uint64_t v39 = NFLogGetLogger();
    if (v39)
    {
      id v40 = (void (*)(uint64_t, const char *, ...))v39;
      uint64_t v41 = object_getClass(*(id *)(a1 + 32));
      BOOL v42 = class_isMetaClass(v41);
      __int16 v43 = object_getClassName(*(id *)(a1 + 32));
      BOOL v44 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v45 = [*(id *)(a1 + 32) clientName];
      uint64_t v46 = 45;
      if (v42) {
        uint64_t v46 = 43;
      }
      v40(6, "%c[%{public}s %{public}s]:%i NFC emulation mode terminated: %@", v46, v43, v44, 307, v45);
    }
    id v32 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
    {
      id v47 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v47)) {
        int v48 = 43;
      }
      else {
        int v48 = 45;
      }
      uint64_t v49 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v50 = sel_getName(*(SEL *)(a1 + 48));
      int v51 = [*(id *)(a1 + 32) clientName];
      *(_DWORD *)buf = 67110146;
      int v55 = v48;
      __int16 v56 = 2082;
      long long v57 = v49;
      __int16 v58 = 2082;
      id v59 = v50;
      __int16 v60 = 1024;
      int v61 = 307;
      __int16 v62 = 2112;
      uint64_t v63 = v51;
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NFC emulation mode terminated: %@", buf, 0x2Cu);
    }
    goto LABEL_24;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v16 = NFLogGetLogger();
  if (v16)
  {
    uint64_t v17 = (void (*)(uint64_t, const char *, ...))v16;
    uint64_t v18 = object_getClass(*(id *)(a1 + 32));
    BOOL v19 = class_isMetaClass(v18);
    BOOL v20 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v21 = sel_getName(*(SEL *)(a1 + 48));
    id v22 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v23 = 45;
    if (v19) {
      uint64_t v23 = 43;
    }
    v17(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v23, v20, v21, 301, v22);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v24 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    uint64_t v25 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v25)) {
      int v26 = 43;
    }
    else {
      int v26 = 45;
    }
    int v27 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v28 = sel_getName(*(SEL *)(a1 + 48));
    id v29 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)buf = 67110146;
    int v55 = v26;
    __int16 v56 = 2082;
    long long v57 = v27;
    __int16 v58 = 2082;
    id v59 = v28;
    __int16 v60 = 1024;
    int v61 = 301;
    __int16 v62 = 2114;
    uint64_t v63 = v29;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v30 = *(void *)(a1 + 40);
  if (v30)
  {
    id v31 = objc_alloc((Class)NSError);
    id v32 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v52 = NSLocalizedDescriptionKey;
    int v33 = +[NSString stringWithUTF8String:"Session not active"];
    uint64_t v53 = v33;
    id v34 = +[NSDictionary dictionaryWithObjects:&v53 forKeys:&v52 count:1];
    id v35 = [v31 initWithDomain:v32 code:54 userInfo:v34];
    (*(void (**)(uint64_t, id))(v30 + 16))(v30, v35);

LABEL_24:
  }
}

void sub_1000E81BC(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 314, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    int v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v15 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)buf = 67110146;
    int v39 = v12;
    __int16 v40 = 2082;
    uint64_t v41 = v13;
    __int16 v42 = 2082;
    __int16 v43 = v14;
    __int16 v44 = 1024;
    int v45 = 314;
    __int16 v46 = 2114;
    id v47 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v16 = NFLogGetLogger();
    if (v16)
    {
      uint64_t v17 = (void (*)(uint64_t, const char *, ...))v16;
      uint64_t v18 = object_getClass(*(id *)(a1 + 32));
      BOOL v19 = class_isMetaClass(v18);
      BOOL v20 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v21 = sel_getName(*(SEL *)(a1 + 56));
      id v22 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v23 = 45;
      if (v19) {
        uint64_t v23 = 43;
      }
      v17(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v23, v20, v21, 315, v22);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v24 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      uint64_t v25 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v25)) {
        int v26 = 43;
      }
      else {
        int v26 = 45;
      }
      int v27 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v28 = sel_getName(*(SEL *)(a1 + 56));
      id v29 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)buf = 67110146;
      int v39 = v26;
      __int16 v40 = 2082;
      uint64_t v41 = v27;
      __int16 v42 = 2082;
      __int16 v43 = v28;
      __int16 v44 = 1024;
      int v45 = 315;
      __int16 v46 = 2114;
      id v47 = v29;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v30 = *(void *)(a1 + 48);
    if (v30)
    {
      id v31 = objc_alloc((Class)NSError);
      id v32 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v36 = NSLocalizedDescriptionKey;
      int v33 = +[NSString stringWithUTF8String:"Session not active"];
      id v37 = v33;
      id v34 = +[NSDictionary dictionaryWithObjects:&v37 forKeys:&v36 count:1];
      id v35 = [v31 initWithDomain:v32 code:54 userInfo:v34];
      (*(void (**)(uint64_t, id))(v30 + 16))(v30, v35);
    }
  }
  else
  {
    sub_1000B7A24(*(void *)(*(void *)(a1 + 32) + 168), *(void **)(a1 + 40));
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
}

void sub_1000E86AC(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 326, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    int v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v15 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)buf = 67110146;
    int v40 = v12;
    __int16 v41 = 2082;
    __int16 v42 = v13;
    __int16 v43 = 2082;
    __int16 v44 = v14;
    __int16 v45 = 1024;
    int v46 = 326;
    __int16 v47 = 2114;
    int v48 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    uint64_t v36 = *(void *)(a1 + 40);
    id v32 = sub_1000B7D78(*(id **)(*(void *)(a1 + 32) + 168));
    (*(void (**)(uint64_t, void *, void))(v36 + 16))(v36, v32, 0);
    goto LABEL_24;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v16 = NFLogGetLogger();
  if (v16)
  {
    uint64_t v17 = (void (*)(uint64_t, const char *, ...))v16;
    uint64_t v18 = object_getClass(*(id *)(a1 + 32));
    BOOL v19 = class_isMetaClass(v18);
    BOOL v20 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v21 = sel_getName(*(SEL *)(a1 + 48));
    id v22 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v23 = 45;
    if (v19) {
      uint64_t v23 = 43;
    }
    v17(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v23, v20, v21, 327, v22);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v24 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    uint64_t v25 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v25)) {
      int v26 = 43;
    }
    else {
      int v26 = 45;
    }
    int v27 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v28 = sel_getName(*(SEL *)(a1 + 48));
    id v29 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)buf = 67110146;
    int v40 = v26;
    __int16 v41 = 2082;
    __int16 v42 = v27;
    __int16 v43 = 2082;
    __int16 v44 = v28;
    __int16 v45 = 1024;
    int v46 = 327;
    __int16 v47 = 2114;
    int v48 = v29;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v30 = *(void *)(a1 + 40);
  if (v30)
  {
    id v31 = objc_alloc((Class)NSError);
    id v32 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v37 = NSLocalizedDescriptionKey;
    int v33 = +[NSString stringWithUTF8String:"Session not active"];
    id v38 = v33;
    id v34 = +[NSDictionary dictionaryWithObjects:&v38 forKeys:&v37 count:1];
    id v35 = [v31 initWithDomain:v32 code:54 userInfo:v34];
    (*(void (**)(uint64_t, void, id))(v30 + 16))(v30, 0, v35);

LABEL_24:
  }
}

void sub_1000E8BBC(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 336, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    int v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v15 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)buf = 67110146;
    int v40 = v12;
    __int16 v41 = 2082;
    __int16 v42 = v13;
    __int16 v43 = 2082;
    __int16 v44 = v14;
    __int16 v45 = 1024;
    int v46 = 336;
    __int16 v47 = 2114;
    int v48 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v16 = NFLogGetLogger();
    if (v16)
    {
      uint64_t v17 = (void (*)(uint64_t, const char *, ...))v16;
      uint64_t v18 = object_getClass(*(id *)(a1 + 32));
      BOOL v19 = class_isMetaClass(v18);
      BOOL v20 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v21 = sel_getName(*(SEL *)(a1 + 48));
      id v22 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v23 = 45;
      if (v19) {
        uint64_t v23 = 43;
      }
      v17(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v23, v20, v21, 337, v22);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v24 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      uint64_t v25 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v25)) {
        int v26 = 43;
      }
      else {
        int v26 = 45;
      }
      int v27 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v28 = sel_getName(*(SEL *)(a1 + 48));
      id v29 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)buf = 67110146;
      int v40 = v26;
      __int16 v41 = 2082;
      __int16 v42 = v27;
      __int16 v43 = 2082;
      __int16 v44 = v28;
      __int16 v45 = 1024;
      int v46 = 337;
      __int16 v47 = 2114;
      int v48 = v29;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v30 = *(void *)(a1 + 40);
    if (v30)
    {
      id v31 = objc_alloc((Class)NSError);
      id v32 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v37 = NSLocalizedDescriptionKey;
      int v33 = +[NSString stringWithUTF8String:"Session not active"];
      id v38 = v33;
      id v34 = +[NSDictionary dictionaryWithObjects:&v38 forKeys:&v37 count:1];
      id v35 = [v31 initWithDomain:v32 code:54 userInfo:v34];
      (*(void (**)(uint64_t, id))(v30 + 16))(v30, v35);
    }
  }
  else
  {
    uint64_t v36 = *(void *)(*(void *)(a1 + 32) + 168);
    if (v36)
    {
      *(unsigned char *)(v36 + 29) = *(unsigned char *)(a1 + 56);
      sub_1000B6A54(v36);
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

void sub_1000E903C(id a1)
{
  uint64_t v1 = objc_alloc_init(_NFHardwareManager);
  uint64_t v2 = qword_100347448;
  qword_100347448 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_1000E9584(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id location)
{
  objc_destroyWeak(v22);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1000E95CC(uint64_t a1)
{
  uint64_t v2 = _os_activity_create((void *)&_mh_execute_header, "com.apple.nfcd.hw.postStartupTimer", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  state = 0;
  *(void *)state_8 = 0;
  os_activity_scope_enter(v2, (os_activity_scope_state_t)&state);
  os_activity_scope_leave((os_activity_scope_state_t)&state);

  id WeakRetained = (void **)objc_loadWeakRetained((id *)(a1 + 40));
  double v4 = sub_1000E9CB0((uint64_t)WeakRetained);
  if (v4 > 0.0) {
    goto LABEL_40;
  }
  uint64_t v5 = sub_10020EC8C(WeakRetained[46], @"runPostStartupWork", 1uLL);
  if (v5)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v7 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v10 = 45;
      if (isMetaClass) {
        uint64_t v10 = 43;
      }
      v7(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v10, ClassName, Name, 397, v5);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v11 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      int v12 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v12)) {
        int v13 = 43;
      }
      else {
        int v13 = 45;
      }
      uint64_t v14 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v15 = sel_getName(*(SEL *)(a1 + 48));
      LODWORD(state) = 67110146;
      HIDWORD(state) = v13;
      *(_WORD *)state_8 = 2082;
      *(void *)&state_8[2] = v14;
      *(_WORD *)&state_8[10] = 2082;
      *(void *)&state_8[12] = v15;
      *(_WORD *)&state_8[20] = 1024;
      *(_DWORD *)&state_8[22] = 397;
      *(_WORD *)&state_8[26] = 2112;
      *(void *)&state_8[28] = v5;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", (uint8_t *)&state, 0x2Cu);
    }
  }
  uint64_t v16 = WeakRetained[46];
  if (v16)
  {
    switch(v16[37])
    {
      case 1:
        if (!WeakRetained[16]) {
          goto LABEL_37;
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v18 = NFLogGetLogger();
        if (v18)
        {
          BOOL v19 = (void (*)(uint64_t, const char *, ...))v18;
          BOOL v20 = object_getClass(WeakRetained);
          BOOL v21 = class_isMetaClass(v20);
          id v22 = object_getClassName(WeakRetained);
          int v51 = sel_getName("doPostStartupWork");
          uint64_t v23 = 45;
          if (v21) {
            uint64_t v23 = 43;
          }
          v19(6, "%c[%{public}s %{public}s]:%i Running post stack bootup work", v23, v22, v51, 732);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v24 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v25 = object_getClass(WeakRetained);
          if (class_isMetaClass(v25)) {
            int v26 = 43;
          }
          else {
            int v26 = 45;
          }
          int v27 = object_getClassName(WeakRetained);
          uint64_t v28 = sel_getName("doPostStartupWork");
          LODWORD(state) = 67109890;
          HIDWORD(state) = v26;
          *(_WORD *)state_8 = 2082;
          *(void *)&state_8[2] = v27;
          *(_WORD *)&state_8[10] = 2082;
          *(void *)&state_8[12] = v28;
          *(_WORD *)&state_8[20] = 1024;
          *(_DWORD *)&state_8[22] = 732;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Running post stack bootup work", (uint8_t *)&state, 0x22u);
        }

        id v29 = NFSharedSignpostLog();
        if (os_signpost_enabled(v29))
        {
          LOWORD(state) = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v29, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "DUMP_LOGS_BOOTUP", (const char *)&unk_100286819, (uint8_t *)&state, 2u);
        }

        if ((NFIsInternalBuild() & 1) != 0 || *((unsigned char *)WeakRetained + 350))
        {
          uint64_t v30 = WeakRetained[29];
          id v31 = +[NFRoutingConfig embeddedWiredMode];
          state = _NSConcreteStackBlock;
          *(void *)state_8 = 3221225472;
          *(void *)&state_8[8] = sub_1000F5D0C;
          *(void *)&state_8[16] = &unk_100301C40;
          *(void *)&state_8[24] = WeakRetained;
          *(void *)&state_8[32] = "dumpLPEMAppletLogs";
          id v32 = +[_NFBuiltinSession createSessionWithWorkQueue:v30 routing:v31 sessionQueuer:WeakRetained didStartWork:&state];
        }
        else
        {
          int v48 = NFSharedSignpostLog();
          if (os_signpost_enabled(v48))
          {
            LOWORD(state) = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v48, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "DUMP_LOGS_BOOTUP", (const char *)&unk_100286819, (uint8_t *)&state, 2u);
          }
        }
        if (NFIsInternalBuild())
        {
          int v33 = WeakRetained[29];
          id v34 = +[NFRoutingConfig embeddedWiredMode];
          state = _NSConcreteStackBlock;
          *(void *)state_8 = 3221225472;
          *(void *)&state_8[8] = sub_1000EE2C8;
          *(void *)&state_8[16] = &unk_100301C40;
          *(void *)&state_8[24] = WeakRetained;
          *(void *)&state_8[32] = "cacheSeMemory";
          id v35 = +[_NFBuiltinSession createSessionWithWorkQueue:v33 routing:v34 sessionQueuer:WeakRetained didStartWork:&state];
        }
LABEL_36:
        uint64_t v36 = WeakRetained[16];
        WeakRetained[16] = 0;

LABEL_37:
        char v17 = 1;
        if (!v5) {
          goto LABEL_38;
        }
        goto LABEL_39;
      case 2:
      case 4:
        char v17 = 0;
        double v4 = 60.0;
        if (!v5) {
          goto LABEL_38;
        }
        goto LABEL_39;
      case 3:
        goto LABEL_36;
      default:
        break;
    }
  }
  char v17 = 0;
  if (!v5) {
LABEL_38:
  }
    sub_1002114AC(WeakRetained[46], @"runPostStartupWork");
LABEL_39:

  if ((v17 & 1) == 0)
  {
LABEL_40:
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v37 = NFLogGetLogger();
    if (v37)
    {
      id v38 = (void (*)(uint64_t, const char *, ...))v37;
      int v39 = object_getClass(WeakRetained);
      BOOL v40 = class_isMetaClass(v39);
      __int16 v41 = object_getClassName(WeakRetained);
      NSErrorUserInfoKey v52 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v42 = 45;
      if (v40) {
        uint64_t v42 = 43;
      }
      v38(6, "%c[%{public}s %{public}s]:%i Delaying post stack bootup work by %f seconds", v42, v41, v52, 417, *(void *)&v4);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v43 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v44 = object_getClass(WeakRetained);
      if (class_isMetaClass(v44)) {
        int v45 = 43;
      }
      else {
        int v45 = 45;
      }
      int v46 = object_getClassName(WeakRetained);
      __int16 v47 = sel_getName(*(SEL *)(a1 + 48));
      LODWORD(state) = 67110146;
      HIDWORD(state) = v45;
      *(_WORD *)state_8 = 2082;
      *(void *)&state_8[2] = v46;
      *(_WORD *)&state_8[10] = 2082;
      *(void *)&state_8[12] = v47;
      *(_WORD *)&state_8[20] = 1024;
      *(_DWORD *)&state_8[22] = 417;
      *(_WORD *)&state_8[26] = 2048;
      *(double *)&state_8[28] = v4;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Delaying post stack bootup work by %f seconds", (uint8_t *)&state, 0x2Cu);
    }

    [WeakRetained[16] startTimer:v4];
  }
}

double sub_1000E9CB0(uint64_t a1)
{
  double v1 = 0.0;
  if (a1 && *(void *)(a1 + 128))
  {
    if (sub_1002015A0(*(void **)(a1 + 88)))
    {
      double v1 = 20.0;
      if (!*(void *)(a1 + 112) && ![*(id *)(a1 + 184) count])
      {
        uint64_t v3 = *(void *)(a1 + 24);
        if (!v3 || !*(unsigned char *)(v3 + 172))
        {
          if (*(unsigned char *)(a1 + 346)) {
            return 20.0;
          }
          else {
            return 0.0;
          }
        }
      }
    }
    else
    {
      return 60.0;
    }
  }
  return v1;
}

void sub_1000EA174(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000EA19C(uint64_t a1)
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2020000000;
  uint64_t v9 = 0;
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(NSObject **)(v1 + 232);
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_1000EA248;
  v5[3] = &unk_100301EB8;
  v5[4] = v1;
  v5[5] = &v6;
  dispatch_async_and_wait(v2, v5);
  uint64_t v3 = v7[3];
  _Block_object_dispose(&v6, 8);
  return v3;
}

void sub_1000EA248(uint64_t a1)
{
  uint64_t v2 = *(_DWORD **)(a1 + 32);
  if (v2)
  {
    uint64_t v3 = sub_1000FDB50(*(void *)(a1 + 32));
    id v20 = 0;
    double v4 = +[NSPropertyListSerialization dataWithPropertyList:v3 format:200 options:0 error:&v20];
    id v5 = v20;

    if (v5)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        uint64_t v7 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(v2);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(v2);
        Name = sel_getName("dumpState");
        uint64_t v10 = 45;
        if (isMetaClass) {
          uint64_t v10 = 43;
        }
        v7(3, "%c[%{public}s %{public}s]:%i Failed to serialize state dump: %{public}@", v10, ClassName, Name, 8819, v5);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v11 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        int v12 = object_getClass(v2);
        if (class_isMetaClass(v12)) {
          int v13 = 43;
        }
        else {
          int v13 = 45;
        }
        uint64_t v14 = object_getClassName(v2);
        uint64_t v15 = sel_getName("dumpState");
        *(_DWORD *)buf = 67110146;
        int v22 = v13;
        __int16 v23 = 2082;
        uint64_t v24 = v14;
        __int16 v25 = 2082;
        int v26 = v15;
        __int16 v27 = 1024;
        int v28 = 8819;
        __int16 v29 = 2114;
        id v30 = v5;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to serialize state dump: %{public}@", buf, 0x2Cu);
      }
    }
    id v16 = [v4 length];
    uint64_t v2 = malloc_type_calloc(1uLL, (size_t)v16 + 200, 0x256B6C8BuLL);
    *uint64_t v2 = 1;
    v2[1] = v16;
    __strlcpy_chk();
    id v17 = v4;
    memcpy(v2 + 50, [v17 bytes], (size_t)v16);
  }
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v2;
}

void sub_1000EA4BC(void *a1, uint64_t a2)
{
  if (a1 && dword_100346248 != a2)
  {
    dword_100346248 = a2;
    int out_token = 0;
    uint64_t v4 = notify_register_check("com.apple.stockholm.sessions.active", &out_token);
    if (v4)
    {
      uint64_t v5 = v4;
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        uint64_t v7 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("_postActiveSessionsNotification:");
        uint64_t v10 = 45;
        if (isMetaClass) {
          uint64_t v10 = 43;
        }
        v7(3, "%c[%{public}s %{public}s]:%i Failed to notify register check : %d", v10, ClassName, Name, 1300, v5);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v11 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        int v12 = object_getClass(a1);
        if (class_isMetaClass(v12)) {
          int v13 = 43;
        }
        else {
          int v13 = 45;
        }
        uint64_t v14 = object_getClassName(a1);
        uint64_t v15 = sel_getName("_postActiveSessionsNotification:");
        *(_DWORD *)buf = 67110146;
        int v51 = v13;
        __int16 v52 = 2082;
        uint64_t v53 = v14;
        __int16 v54 = 2082;
        int v55 = v15;
        __int16 v56 = 1024;
        int v57 = 1300;
        __int16 v58 = 1024;
        int v59 = v5;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to notify register check : %d", buf, 0x28u);
      }

      goto LABEL_37;
    }
    uint64_t v16 = notify_set_state(out_token, dword_100346248);
    if (v16)
    {
      uint64_t v17 = v16;
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v18 = NFLogGetLogger();
      if (v18)
      {
        BOOL v19 = (void (*)(uint64_t, const char *, ...))v18;
        id v20 = object_getClass(a1);
        BOOL v21 = class_isMetaClass(v20);
        __int16 v44 = object_getClassName(a1);
        __int16 v47 = sel_getName("_postActiveSessionsNotification:");
        uint64_t v22 = 45;
        if (v21) {
          uint64_t v22 = 43;
        }
        v19(3, "%c[%{public}s %{public}s]:%i Failed to notify set state : %d", v22, v44, v47, 1294, v17);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v23 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
        goto LABEL_35;
      }
      uint64_t v24 = object_getClass(a1);
      if (class_isMetaClass(v24)) {
        int v25 = 43;
      }
      else {
        int v25 = 45;
      }
      int v26 = object_getClassName(a1);
      __int16 v27 = sel_getName("_postActiveSessionsNotification:");
      *(_DWORD *)buf = 67110146;
      int v51 = v25;
      __int16 v52 = 2082;
      uint64_t v53 = v26;
      __int16 v54 = 2082;
      int v55 = v27;
      __int16 v56 = 1024;
      int v57 = 1294;
      __int16 v58 = 1024;
      int v59 = v17;
      int v28 = "%c[%{public}s %{public}s]:%i Failed to notify set state : %d";
    }
    else
    {
      uint64_t v29 = notify_post("com.apple.stockholm.sessions.active");
      if (!v29)
      {
LABEL_36:
        notify_cancel(out_token);
LABEL_37:
        BOOL v40 = +[NFSecureXPCEventPublisherManager sharedManager];
        __int16 v41 = [v40 wallet];
        uint64_t v42 = +[NSNumber numberWithInt:a2];
        [v41 sendSimpleEvent:@"com.apple.stockholm.sessions.active" objectNumber:v42];

        return;
      }
      uint64_t v30 = v29;
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v31 = NFLogGetLogger();
      if (v31)
      {
        id v32 = (void (*)(uint64_t, const char *, ...))v31;
        int v33 = object_getClass(a1);
        BOOL v34 = class_isMetaClass(v33);
        int v45 = object_getClassName(a1);
        int v48 = sel_getName("_postActiveSessionsNotification:");
        uint64_t v35 = 45;
        if (v34) {
          uint64_t v35 = 43;
        }
        v32(3, "%c[%{public}s %{public}s]:%i Failed to notify : %d", v35, v45, v48, 1290, v30);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v23 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
      {
LABEL_35:

        goto LABEL_36;
      }
      uint64_t v36 = object_getClass(a1);
      if (class_isMetaClass(v36)) {
        int v37 = 43;
      }
      else {
        int v37 = 45;
      }
      id v38 = object_getClassName(a1);
      int v39 = sel_getName("_postActiveSessionsNotification:");
      *(_DWORD *)buf = 67110146;
      int v51 = v37;
      __int16 v52 = 2082;
      uint64_t v53 = v38;
      __int16 v54 = 2082;
      int v55 = v39;
      __int16 v56 = 1024;
      int v57 = 1290;
      __int16 v58 = 1024;
      int v59 = v30;
      int v28 = "%c[%{public}s %{public}s]:%i Failed to notify : %d";
    }
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, v28, buf, 0x28u);
    goto LABEL_35;
  }
}

void sub_1000EA94C(uint64_t a1)
{
  sub_1000EAC5C(*(void *)(a1 + 32), 0);
  uint64_t v21 = 0;
  uint64_t v22 = &v21;
  uint64_t v23 = 0x2020000000;
  int v24 = 0;
  int v24 = -[_NFHardwareManager getPrimaryHardwareState]_0(*(void *)(a1 + 32));
  sub_1000EC9F8(*(id **)(a1 + 32), *((unsigned int *)v22 + 6));
  id v2 = *(id *)(a1 + 32);
  objc_sync_enter(v2);
  BOOL v3 = *(unsigned char *)(*(void *)(a1 + 32) + 337) == 0;
  objc_sync_exit(v2);

  if (!v3)
  {
    int v4 = *((_DWORD *)v22 + 6);
    if (v4 == 2 || v4 == 4)
    {
      sub_1000ED6B4(*(void **)(a1 + 32));
    }
    else if (*(unsigned char *)(*(void *)(a1 + 32) + 354))
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (Logger)
      {
        Class = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(Class)) {
          uint64_t v8 = 43;
        }
        else {
          uint64_t v8 = 45;
        }
        ClassName = object_getClassName(*(id *)(a1 + 32));
        Name = sel_getName(*(SEL *)(a1 + 40));
        Logger(4, "%c[%{public}s %{public}s]:%i FailForward disabled - skipping HW recovery", v8, ClassName, Name, 498);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v11 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        int v12 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v12)) {
          int v13 = 43;
        }
        else {
          int v13 = 45;
        }
        uint64_t v14 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v15 = sel_getName(*(SEL *)(a1 + 40));
        *(_DWORD *)buf = 67109890;
        int v26 = v13;
        __int16 v27 = 2082;
        int v28 = v14;
        __int16 v29 = 2082;
        uint64_t v30 = v15;
        __int16 v31 = 1024;
        int v32 = 498;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i FailForward disabled - skipping HW recovery", buf, 0x22u);
      }
    }
    else
    {
      uint64_t v16 = NFSharedSignpostLog();
      if (os_signpost_enabled(v16))
      {
        *(_WORD *)buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "HWRecovery", "begin", buf, 2u);
      }

      uint64_t v17 = *(void *)(a1 + 32);
      uint64_t v18 = *(void **)(v17 + 368);
      BOOL v19 = *(void **)(v17 + 232);
      v20[0] = _NSConcreteStackBlock;
      v20[1] = 3221225472;
      v20[2] = sub_1000ECC4C;
      v20[3] = &unk_100304208;
      v20[4] = v17;
      v20[5] = &v21;
      v20[6] = *(void *)(a1 + 40);
      sub_10015C850(v18, v19, v20);
    }
  }
  _Block_object_dispose(&v21, 8);
}

void sub_1000EAC2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000EAC5C(uint64_t a1, int a2)
{
  if (!a1) {
    return;
  }
  int v4 = &AMFDRSealingMapCopyLocalData_ptr;
  uint64_t v5 = +[NFPowerAssertion sharedPowerAssertion];
  [v5 holdPowerAssertion:@"Load Stack"];

  if (!*(void *)(a1 + 80))
  {
    uint64_t v6 = sub_10022F640((id *)[NFManagedConfigMonitor alloc], *(void **)(a1 + 232), (void *)a1);
    uint64_t v7 = *(void **)(a1 + 80);
    *(void *)(a1 + 80) = v6;
  }
  uint64_t v8 = *(void *)(a1 + 368);
  uint64_t v9 = sub_1000EFF70((id *)a1);
  sub_100212014(v8, v9);

  uint64_t v10 = *(void *)(a1 + 368);
  if (!v10 || (*(unsigned char *)(v10 + 218) & 1) == 0)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      int v12 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass((id)a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName((id)a1);
      Name = sel_getName("_loadDriverConfigsFromDisk");
      uint64_t v16 = 45;
      if (isMetaClass) {
        uint64_t v16 = 43;
      }
      v12(6, "%c[%{public}s %{public}s]:%i clearing persistent field detect, device does not have antenna", v16, ClassName, Name, 922);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v17 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = object_getClass((id)a1);
      if (class_isMetaClass(v18)) {
        int v19 = 43;
      }
      else {
        int v19 = 45;
      }
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)&uint8_t buf[4] = v19;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = object_getClassName((id)a1);
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = sel_getName("_loadDriverConfigsFromDisk");
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 922;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i clearing persistent field detect, device does not have antenna", buf, 0x22u);
    }

    [*(id *)(a1 + 16) removeAllPersistentFieldObservers];
  }
  sub_1000ECDB8((void **)a1, @"Load HW");
  unsigned int v20 = -[_NFHardwareManager getPrimaryHardwareState]_0(a1);
  uint64_t v21 = (unsigned __int8 *)(id)a1;
  objc_sync_enter(v21);
  int v22 = v21[337];
  objc_sync_exit(v21);

  if (v20 == 4)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v23 = NFLogGetLogger();
    if (v23)
    {
      int v24 = (void (*)(uint64_t, const char *, ...))v23;
      int v25 = object_getClass(v21);
      BOOL v26 = class_isMetaClass(v25);
      __int16 v27 = object_getClassName(v21);
      uint64_t v253 = sel_getName("_updateSystemHealth:reportFailure:");
      uint64_t v28 = 45;
      if (v26) {
        uint64_t v28 = 43;
      }
      v24(5, "%c[%{public}s %{public}s]:%i NFC/SE not supported on this device", v28, v27, v253, 967);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v29 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v30 = object_getClass(v21);
      if (class_isMetaClass(v30)) {
        int v31 = 43;
      }
      else {
        int v31 = 45;
      }
      int v32 = object_getClassName(v21);
      int v33 = sel_getName("_updateSystemHealth:reportFailure:");
      *(_DWORD *)int v277 = 67109890;
      *(_DWORD *)&void v277[4] = v31;
      *(_WORD *)CFStringRef v278 = 2082;
      *(void *)&v278[2] = v32;
      *(_WORD *)&v278[10] = 2082;
      *(void *)&v278[12] = v33;
      *(_WORD *)&v278[20] = 1024;
      *(_DWORD *)&v278[22] = 967;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NFC/SE not supported on this device", v277, 0x22u);
    }

    goto LABEL_61;
  }
  uint64_t v34 = sub_10012B58C();
  if (!v22 || !v34)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v37 = NFLogGetLogger();
    if (v37)
    {
      id v38 = (void (*)(uint64_t, const char *, ...))v37;
      int v39 = object_getClass(v21);
      BOOL v40 = class_isMetaClass(v39);
      unsigned int v41 = v20;
      uint64_t v42 = object_getClassName(v21);
      v254 = sel_getName("_updateSystemHealth:reportFailure:");
      uint64_t v43 = 45;
      if (v40) {
        uint64_t v43 = 43;
      }
      v246 = v42;
      unsigned int v20 = v41;
      v38(4, "%c[%{public}s %{public}s]:%i missing system health library", v43, v246, v254, 1012);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v44 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
      int v45 = object_getClass(v21);
      if (class_isMetaClass(v45)) {
        int v46 = 43;
      }
      else {
        int v46 = 45;
      }
      __int16 v47 = object_getClassName(v21);
      int v48 = sel_getName("_updateSystemHealth:reportFailure:");
      *(_DWORD *)int v277 = 67109890;
      *(_DWORD *)&void v277[4] = v46;
      *(_WORD *)CFStringRef v278 = 2082;
      *(void *)&v278[2] = v47;
      *(_WORD *)&v278[10] = 2082;
      *(void *)&v278[12] = v48;
      *(_WORD *)&v278[20] = 1024;
      *(_DWORD *)&v278[22] = 1012;
      _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i missing system health library", v277, 0x22u);
    }
    goto LABEL_46;
  }
  if (v20 == 2) {
    uint64_t v35 = 1;
  }
  else {
    uint64_t v35 = 2;
  }
  uint64_t v36 = v21;
  objc_sync_enter(v36);
  if (v35 == qword_100346240)
  {
    objc_sync_exit(v36);

    goto LABEL_47;
  }
  objc_sync_exit(v36);

  if (v20 == 2 || a2)
  {
    __int16 v44 = dispatch_get_global_queue(17, 0);
    *(void *)buf = _NSConcreteStackBlock;
    *(void *)&buf[8] = 3221225472;
    *(void *)&buf[16] = sub_1000F1930;
    *(void *)&buf[24] = &unk_100304108;
    *(void *)&buf[32] = v36;
    *(void *)&buf[40] = v35;
    uint64_t v274 = "_updateSystemHealth:reportFailure:";
    dispatch_async(v44, buf);
LABEL_46:
  }
LABEL_47:
  if (v20 != 2 && v20 != 5)
  {
LABEL_61:
    int v65 = +[NFPowerAssertion sharedPowerAssertion];
    [v65 releasePowerAssertion:@"Load Stack"];

    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v66 = NFLogGetLogger();
    if (v66)
    {
      __int16 v67 = (void (*)(uint64_t, const char *, ...))v66;
      __int16 v68 = object_getClass(v21);
      BOOL v69 = class_isMetaClass(v68);
      int v248 = object_getClassName(v21);
      BOOL v256 = sel_getName("_initializeHardwareAndReportFailure:");
      uint64_t v70 = 45;
      if (v69) {
        uint64_t v70 = 43;
      }
      v67(4, "%c[%{public}s %{public}s]:%i Hardware not available : %lu", v70, v248, v256, 857, v20);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v71 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
    {
      __int16 v72 = object_getClass(v21);
      if (class_isMetaClass(v72)) {
        int v73 = 43;
      }
      else {
        int v73 = 45;
      }
      uint64_t v74 = object_getClassName(v21);
      int v75 = sel_getName("_initializeHardwareAndReportFailure:");
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)&uint8_t buf[4] = v73;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = v74;
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = v75;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 857;
      *(_WORD *)&buf[34] = 2048;
      *(void *)&buf[36] = v20;
      _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Hardware not available : %lu", buf, 0x2Cu);
    }

    return;
  }
  unsigned int v270 = v20;
  uint64_t v49 = sub_10020EC8C(*(void **)(a1 + 368), @"Load HW Info", 0);
  if (v49)
  {
    id v50 = (id)v49;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v51 = NFLogGetLogger();
    if (v51)
    {
      __int16 v52 = (void (*)(uint64_t, const char *, ...))v51;
      uint64_t v53 = object_getClass(v21);
      BOOL v54 = class_isMetaClass(v53);
      uint64_t v247 = object_getClassName(v21);
      v255 = sel_getName("_initializeSecureElementInfo");
      uint64_t v55 = 45;
      if (v54) {
        uint64_t v55 = 43;
      }
      v52(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v55, v247, v255, 1153, v50);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v56 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
    {
      int v57 = object_getClass(v21);
      if (class_isMetaClass(v57)) {
        int v58 = 43;
      }
      else {
        int v58 = 45;
      }
      int v59 = object_getClassName(v21);
      __int16 v60 = sel_getName("_initializeSecureElementInfo");
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)&uint8_t buf[4] = v58;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = v59;
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = v60;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 1153;
      *(_WORD *)&buf[34] = 2112;
      *(void *)&buf[36] = v50;
      _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
    }

    id v61 = objc_alloc((Class)NSError);
    __int16 v62 = +[NSString stringWithUTF8String:"nfcd"];
    id v63 = [v50 code];
    *(void *)int v277 = NSLocalizedDescriptionKey;
    if ((uint64_t)[v50 code] > 70) {
      uint64_t v64 = 71;
    }
    else {
      uint64_t v64 = (uint64_t)[v50 code];
    }
    int v82 = +[NSString stringWithUTF8String:off_100304250[v64]];
    *(void *)buf = v82;
    *(void *)&buf[8] = v50;
    *(void *)CFStringRef v278 = NSUnderlyingErrorKey;
    *(void *)&v278[8] = @"Line";
    *(void *)&buf[16] = &off_10031B700;
    *(void *)&v278[16] = @"Method";
    id v83 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_initializeSecureElementInfo")];
    *(void *)&buf[24] = v83;
    *(void *)&v278[24] = NSDebugDescriptionErrorKey;
    id v84 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_initializeSecureElementInfo"), 1154];
    *(void *)&buf[32] = v84;
    id v85 = +[NSDictionary dictionaryWithObjects:buf forKeys:v277 count:5];
    id v86 = [v61 initWithDomain:v62 code:v63 userInfo:v85];

    int v4 = &AMFDRSealingMapCopyLocalData_ptr;
    goto LABEL_101;
  }
  BOOL v76 = +[NFRoutingConfig embeddedWiredModeWithFD:0];
  uint64_t v77 = [v21 setRoutingConfig:v76];

  if (v77)
  {
    id v78 = objc_alloc((Class)NSError);
    int v79 = +[NSString stringWithUTF8String:"nfcd"];
    uint64_t v80 = (const char *)[v77 code];
    *(void *)int v277 = NSLocalizedDescriptionKey;
    SEL sel = v80;
    if ((uint64_t)[v77 code] > 70) {
      uint64_t v81 = 71;
    }
    else {
      uint64_t v81 = (uint64_t)[v77 code];
    }
    id v88 = +[NSString stringWithUTF8String:off_100304250[v81]];
    *(void *)buf = v88;
    *(void *)&buf[8] = v77;
    *(void *)CFStringRef v278 = NSUnderlyingErrorKey;
    *(void *)&v278[8] = @"Line";
    *(void *)&buf[16] = &off_10031B718;
    *(void *)&v278[16] = @"Method";
    id v89 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_initializeSecureElementInfo")];
    *(void *)&buf[24] = v89;
    *(void *)&v278[24] = NSDebugDescriptionErrorKey;
    id v90 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_initializeSecureElementInfo"), 1160];
    *(void *)&buf[32] = v90;
    __int16 v91 = +[NSDictionary dictionaryWithObjects:buf forKeys:v277 count:5];
    id v87 = [v78 initWithDomain:v79 code:sel userInfo:v91];

    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v92 = NFLogGetLogger();
    if (v92)
    {
      uint64_t v93 = (void (*)(uint64_t, const char *, ...))v92;
      __int16 v94 = object_getClass(v21);
      BOOL v95 = class_isMetaClass(v94);
      int v96 = object_getClassName(v21);
      v257 = sel_getName("_initializeSecureElementInfo");
      uint64_t v97 = 45;
      if (v95) {
        uint64_t v97 = 43;
      }
      v93(3, "%c[%{public}s %{public}s]:%i Failed to set routing mode", v97, v96, v257, 1161);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v98 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v98, OS_LOG_TYPE_ERROR))
    {
      int v99 = object_getClass(v21);
      if (class_isMetaClass(v99)) {
        int v100 = 43;
      }
      else {
        int v100 = 45;
      }
      id v101 = object_getClassName(v21);
      uint64_t v102 = sel_getName("_initializeSecureElementInfo");
      *(_DWORD *)id v275 = 67109890;
      *(_DWORD *)&void v275[4] = v100;
      *(_WORD *)id v276 = 2082;
      *(void *)&v276[2] = v101;
      *(_WORD *)&v276[10] = 2082;
      *(void *)&v276[12] = v102;
      *(_WORD *)&v276[20] = 1024;
      *(_DWORD *)&v276[22] = 1161;
      _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set routing mode", v275, 0x22u);
    }
    int v4 = &AMFDRSealingMapCopyLocalData_ptr;
LABEL_98:

    sub_1002114AC(*(void **)(a1 + 368), @"Load HW Info");
    if (v87)
    {
      uint64_t v119 = (void *)*((void *)v21 + 48);
      *((void *)v21 + 48) = 0;

      v120 = (void *)*((void *)v21 + 5);
      *((void *)v21 + 5) = 0;
    }
    goto LABEL_100;
  }
  if (![v21 refreshSecureElementInfo])
  {
    id v103 = objc_alloc((Class)NSError);
    v104 = +[NSString stringWithUTF8String:"nfcd"];
    *(void *)id v275 = NSLocalizedDescriptionKey;
    BOOL v105 = +[NSString stringWithUTF8String:"Stack Error"];
    *(void *)int v277 = v105;
    *(void *)CFStringRef v278 = &off_10031B730;
    *(void *)id v276 = @"Line";
    *(void *)&v276[8] = @"Method";
    id v106 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_initializeSecureElementInfo")];
    *(void *)&v278[8] = v106;
    *(void *)&v276[16] = NSDebugDescriptionErrorKey;
    id v107 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_initializeSecureElementInfo"), 1166];
    *(void *)&v278[16] = v107;
    int v108 = +[NSDictionary dictionaryWithObjects:v277 forKeys:v275 count:4];
    id v87 = [v103 initWithDomain:v104 code:15 userInfo:v108];

    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v109 = NFLogGetLogger();
    if (v109)
    {
      uint64_t v110 = (void (*)(uint64_t, const char *, ...))v109;
      uint64_t v111 = object_getClass(v21);
      BOOL v112 = class_isMetaClass(v111);
      int v113 = object_getClassName(v21);
      uint64_t v258 = sel_getName("_initializeSecureElementInfo");
      uint64_t v114 = 45;
      if (v112) {
        uint64_t v114 = 43;
      }
      v110(3, "%c[%{public}s %{public}s]:%i Failed to get embedded SE info", v114, v113, v258, 1167);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v98 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v98, OS_LOG_TYPE_ERROR))
    {
      id v115 = object_getClass(v21);
      if (class_isMetaClass(v115)) {
        int v116 = 43;
      }
      else {
        int v116 = 45;
      }
      v117 = object_getClassName(v21);
      uint64_t v118 = sel_getName("_initializeSecureElementInfo");
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)&uint8_t buf[4] = v116;
      *(_WORD *)&buf[8] = 2082;
      *(void *)&buf[10] = v117;
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = v118;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 1167;
      _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get embedded SE info", buf, 0x22u);
    }
    goto LABEL_98;
  }
  sub_1002114AC(*(void **)(a1 + 368), @"Load HW Info");
  id v87 = 0;
LABEL_100:
  id v50 = v87;
  id v86 = v50;
LABEL_101:

  if (v86)
  {
    if (os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT))
    {
      *(_WORD *)buf = 0;
      _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT, "Failed to get SE info but stack is up...", buf, 2u);
    }
    sub_1000EF63C(v21, 2);
    BOOL v121 = [v4[413] sharedPowerAssertion];
    [v121 releasePowerAssertion:@"Load Stack"];

    sub_1002114AC(*(void **)(a1 + 368), @"Load HW");
  }
  else
  {
    if (NFIsInternalBuild())
    {
      if ((unint64_t)[*((id *)v21 + 48) siliconName] >= 0xE)
      {
        uint64_t v122 = (unsigned __int16 *)(v21 + 332);
        uint64_t v123 = sub_1001EC534(*(void **)(a1 + 368));

        if (!v123)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          int v124 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v124) {
            v124(6, "%s:%i ATE Trim version = %d (%x)", "-[_NFHardwareManager _dumpATETrim]", 1022, *v122, *v122);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          int v125 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v125, OS_LOG_TYPE_DEFAULT))
          {
            int v126 = *v122;
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "-[_NFHardwareManager _dumpATETrim]";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = 1022;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v126;
            *(_WORD *)&buf[24] = 1024;
            *(_DWORD *)&buf[26] = v126;
            _os_log_impl((void *)&_mh_execute_header, v125, OS_LOG_TYPE_DEFAULT, "%{public}s:%i ATE Trim version = %d (%x)", buf, 0x1Eu);
          }
        }
      }
    }
    v127 = (id *)(v21 + 40);
    uint64_t v128 = [[NFSecureElementHandle alloc] initWithID:1 driverWrapper:*(void *)(a1 + 368) seInfo:*((void *)v21 + 5)];
    uint64_t v129 = [[NFSecureElementWrapper alloc] initWithHandle:v128];
    v130 = (void *)*((void *)v21 + 47);
    *((void *)v21 + 47) = v129;

    [*((id *)v21 + 47) setDelegate:v21];
    id v269 = v128;
    if ([*((id *)v21 + 5) migrationContext] == (id)4 || objc_msgSend(*v127, "migrationContext") == (id)5)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v131 = NFLogGetLogger();
      if (v131)
      {
        uint64_t v132 = (void (*)(uint64_t, const char *, ...))v131;
        uint64_t v133 = object_getClass(v21);
        BOOL v134 = class_isMetaClass(v133);
        int v135 = object_getClassName(v21);
        BOOL v136 = sel_getName("_loadEmbeddedSecureElement");
        id v264 = [*((id *)v21 + 5) migrationContext];
        uint64_t v137 = 45;
        if (v134) {
          uint64_t v137 = 43;
        }
        v132(4, "%c[%{public}s %{public}s]:%i Detected a torn SLAM migration state! %d", v137, v135, v136, 1390, v264);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v138 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v138, OS_LOG_TYPE_ERROR))
      {
        v139 = object_getClass(v21);
        if (class_isMetaClass(v139)) {
          int v140 = 43;
        }
        else {
          int v140 = 45;
        }
        uint64_t v141 = object_getClassName(v21);
        uint64_t v142 = sel_getName("_loadEmbeddedSecureElement");
        unsigned int v143 = [*((id *)v21 + 5) migrationContext];
        *(_DWORD *)buf = 67110146;
        *(_DWORD *)&uint8_t buf[4] = v140;
        *(_WORD *)&buf[8] = 2082;
        *(void *)&buf[10] = v141;
        *(_WORD *)&buf[18] = 2082;
        *(void *)&buf[20] = v142;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 1390;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v143;
        _os_log_impl((void *)&_mh_execute_header, v138, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Detected a torn SLAM migration state! %d", buf, 0x28u);
      }

      int v144 = [*((id *)v21 + 47) recoverSLAM];
      if (v144)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v145 = NFLogGetLogger();
        if (v145)
        {
          uint64_t v146 = (void (*)(uint64_t, const char *, ...))v145;
          uint64_t v147 = object_getClass(v21);
          BOOL v148 = class_isMetaClass(v147);
          v249 = object_getClassName(v21);
          v259 = sel_getName("_loadEmbeddedSecureElement");
          uint64_t v149 = 45;
          if (v148) {
            uint64_t v149 = 43;
          }
          v146(3, "%c[%{public}s %{public}s]:%i Failed to recover SLAM? %{public}@", v149, v249, v259, 1393, v144);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        BOOL v150 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v150, OS_LOG_TYPE_ERROR))
        {
          v151 = object_getClass(v21);
          if (class_isMetaClass(v151)) {
            int v152 = 43;
          }
          else {
            int v152 = 45;
          }
          v153 = object_getClassName(v21);
          v154 = sel_getName("_loadEmbeddedSecureElement");
          *(_DWORD *)buf = 67110146;
          *(_DWORD *)&uint8_t buf[4] = v152;
          *(_WORD *)&buf[8] = 2082;
          *(void *)&buf[10] = v153;
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v154;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = 1393;
          *(_WORD *)&buf[34] = 2114;
          *(void *)&buf[36] = v144;
          _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to recover SLAM? %{public}@", buf, 0x2Cu);
        }
      }
      int v155 = *(void **)(a1 + 368);
      *(void *)int v277 = 0;
      char v156 = sub_100029574(v155, 1, v277);
      id v157 = *(id *)v277;
      id v268 = *(id *)v277;
      if ((v156 & 1) == 0)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v158 = NFLogGetLogger();
        if (v158)
        {
          uint64_t v159 = (void (*)(uint64_t, const char *, ...))v158;
          v160 = object_getClass(v21);
          BOOL v161 = class_isMetaClass(v160);
          BOOL v162 = object_getClassName(v21);
          v260 = sel_getName("_loadEmbeddedSecureElement");
          uint64_t v163 = 45;
          if (v161) {
            uint64_t v163 = 43;
          }
          v159(3, "%c[%{public}s %{public}s]:%i Failed to get embedded SE info", v163, v162, v260, 1398);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v164 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v164, OS_LOG_TYPE_ERROR))
        {
          int v165 = object_getClass(v21);
          if (class_isMetaClass(v165)) {
            int v166 = 43;
          }
          else {
            int v166 = 45;
          }
          int v167 = object_getClassName(v21);
          id v168 = sel_getName("_loadEmbeddedSecureElement");
          *(_DWORD *)buf = 67109890;
          *(_DWORD *)&uint8_t buf[4] = v166;
          *(_WORD *)&buf[8] = 2082;
          *(void *)&buf[10] = v167;
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v168;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = 1398;
          _os_log_impl((void *)&_mh_execute_header, v164, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get embedded SE info", buf, 0x22u);
        }
      }
      objc_storeStrong((id *)v21 + 5, v157);
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v169 = NFLogGetLogger();
      if (v169)
      {
        id v170 = (void (*)(uint64_t, const char *, ...))v169;
        id v171 = object_getClass(v21);
        BOOL v172 = class_isMetaClass(v171);
        v173 = object_getClassName(v21);
        uint64_t v174 = sel_getName("_loadEmbeddedSecureElement");
        id v265 = [*((id *)v21 + 5) migrationContext];
        id v266 = [*((id *)v21 + 5) migrationState];
        uint64_t v175 = 45;
        if (v172) {
          uint64_t v175 = 43;
        }
        v170(6, "%c[%{public}s %{public}s]:%i After SLAM recovery, ctx %d state %d", v175, v173, v174, 1402, v265, v266);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v176 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v176, OS_LOG_TYPE_DEFAULT))
      {
        int v177 = object_getClass(v21);
        if (class_isMetaClass(v177)) {
          int v178 = 43;
        }
        else {
          int v178 = 45;
        }
        v179 = object_getClassName(v21);
        uint64_t v180 = sel_getName("_loadEmbeddedSecureElement");
        unsigned int v181 = [*((id *)v21 + 5) migrationContext];
        unsigned int v182 = [*((id *)v21 + 5) migrationState];
        *(_DWORD *)buf = 67110402;
        *(_DWORD *)&uint8_t buf[4] = v178;
        *(_WORD *)&buf[8] = 2082;
        *(void *)&buf[10] = v179;
        *(_WORD *)&buf[18] = 2082;
        *(void *)&buf[20] = v180;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 1402;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v181;
        *(_WORD *)&buf[40] = 1024;
        *(_DWORD *)&buf[42] = v182;
        _os_log_impl((void *)&_mh_execute_header, v176, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i After SLAM recovery, ctx %d state %d", buf, 0x2Eu);
      }

      int v4 = &AMFDRSealingMapCopyLocalData_ptr;
    }
    else
    {
      id v268 = 0;
    }
    id v183 = objc_alloc((Class)NSString);
    uint64_t v184 = NSTemporaryDirectory();
    id v185 = [v183 initWithFormat:@"%@/%@", v184, @"nfcd.firstlaunch"];

    if (*v127)
    {
      v186 = +[NSFileManager defaultManager];
      unsigned __int8 v187 = [v186 fileExistsAtPath:v185];

      if ((v187 & 1) == 0)
      {
        v188 = +[NSFileManager defaultManager];
        unsigned int v189 = [v188 createFileAtPath:v185 contents:0 attributes:0];

        if (v189)
        {
          BOOL v190 = +[NSUserDefaults standardUserDefaults];
          uint64_t v191 = [v190 arrayForKey:@"BootHistory"];

          uint64_t v267 = (void *)v191;
          if (v191) {
            id v192 = [objc_alloc((Class)NSMutableArray) initWithArray:v191];
          }
          else {
            id v192 = (id)objc_opt_new();
          }
          uint64_t v193 = v192;
          id v194 = [*v127 restrictedMode];
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v195 = NFLogGetLogger();
          if (v195)
          {
            int v196 = (void (*)(uint64_t, const char *, ...))v195;
            uint64_t v197 = object_getClass(v21);
            BOOL v198 = class_isMetaClass(v197);
            uint64_t v250 = object_getClassName(v21);
            int v261 = sel_getName("_initializeSecureElementBootHistory");
            uint64_t v199 = 45;
            if (v198) {
              uint64_t v199 = 43;
            }
            v196(6, "%c[%{public}s %{public}s]:%i Boot SE state: %d", v199, v250, v261, 1042, v194);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v200 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v200, OS_LOG_TYPE_DEFAULT))
          {
            BOOL v201 = object_getClass(v21);
            if (class_isMetaClass(v201)) {
              int v202 = 43;
            }
            else {
              int v202 = 45;
            }
            uint64_t v203 = object_getClassName(v21);
            uint64_t v204 = sel_getName("_initializeSecureElementBootHistory");
            *(_DWORD *)buf = 67110146;
            *(_DWORD *)&uint8_t buf[4] = v202;
            *(_WORD *)&buf[8] = 2082;
            *(void *)&buf[10] = v203;
            *(_WORD *)&buf[18] = 2082;
            *(void *)&buf[20] = v204;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = 1042;
            *(_WORD *)&buf[34] = 1024;
            *(_DWORD *)&buf[36] = v194;
            _os_log_impl((void *)&_mh_execute_header, v200, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Boot SE state: %d", buf, 0x28u);
          }

          int v205 = +[NSNumber numberWithInt:v194];
          [v193 addObject:v205];

          id v206 = v193;
          id v207 = v206;
          if ((unint64_t)[v206 count] >= 0x1F)
          {
            id v207 = [v206 subarrayWithRange:1, 30];
          }
          v208 = +[NSUserDefaults standardUserDefaults];
          [v208 removeObjectForKey:@"lowTemperatureCount"];

          uint64_t v209 = +[NSUserDefaults standardUserDefaults];
          [v209 setObject:v207 forKey:@"BootHistory"];

          v210 = +[NSUserDefaults standardUserDefaults];
          [v210 synchronize];

          int v4 = &AMFDRSealingMapCopyLocalData_ptr;
        }
      }
      id v211 = *v127;
      if (*v127)
      {
        int v212 = +[NSUserDefaults standardUserDefaults];
        uint64_t v213 = [v212 arrayForKey:@"BootHistory"];
        [v211 setBootHistory:v213];
      }
    }

    v214 = +[NFRoutingConfig embeddedWiredModeWithFD:0];
    v215 = [v21 setRoutingConfig:v214];

    if (!v215)
    {
      id v216 = sub_100245608(*((void **)v21 + 47));
      id v217 = sub_100250F44(*((void **)v21 + 47));
      uint64_t v218 = +[NSUserDefaults standardUserDefaults];
      [v218 removeObjectForKey:@"SecureElementSequenceCounter"];

      *(void *)id v275 = 0;
      v219 = sub_1000B0908(*((void **)v21 + 47), v275);
      if (v219)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v220 = NFLogGetLogger();
        if (v220)
        {
          uint64_t v221 = (void (*)(uint64_t, const char *, ...))v220;
          uint64_t v222 = object_getClass(v21);
          BOOL v223 = class_isMetaClass(v222);
          uint64_t v251 = object_getClassName(v21);
          v262 = sel_getName("_loadEmbeddedSecureElement");
          uint64_t v224 = 45;
          if (v223) {
            uint64_t v224 = 43;
          }
          v221(3, "%c[%{public}s %{public}s]:%i Failed to get LPEMCounter: %{public}@", v224, v251, v262, 1426, v219);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        BOOL v225 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v225, OS_LOG_TYPE_ERROR))
        {
          uint64_t v226 = object_getClass(v21);
          if (class_isMetaClass(v226)) {
            int v227 = 43;
          }
          else {
            int v227 = 45;
          }
          uint64_t v228 = object_getClassName(v21);
          int v229 = sel_getName("_loadEmbeddedSecureElement");
          *(_DWORD *)buf = 67110146;
          *(_DWORD *)&uint8_t buf[4] = v227;
          *(_WORD *)&buf[8] = 2082;
          *(void *)&buf[10] = v228;
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v229;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = 1426;
          *(_WORD *)&buf[34] = 2114;
          *(void *)&buf[36] = v219;
          _os_log_impl((void *)&_mh_execute_header, v225, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get LPEMCounter: %{public}@", buf, 0x2Cu);
        }
      }
    }

    if (([*((id *)v21 + 7) registerForEvents] & 1) == 0)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v230 = NFLogGetLogger();
      if (v230)
      {
        int v231 = (void (*)(uint64_t, const char *, ...))v230;
        uint64_t v232 = object_getClass(v21);
        BOOL v233 = class_isMetaClass(v232);
        v234 = object_getClassName(v21);
        v263 = sel_getName("_initializeHardwareAndReportFailure:");
        uint64_t v235 = 45;
        if (v233) {
          uint64_t v235 = 43;
        }
        v231(3, "%c[%{public}s %{public}s]:%i Failed to register for power events", v235, v234, v263, 879);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      v236 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v236, OS_LOG_TYPE_ERROR))
      {
        v237 = object_getClass(v21);
        if (class_isMetaClass(v237)) {
          int v238 = 43;
        }
        else {
          int v238 = 45;
        }
        uint64_t v239 = object_getClassName(v21);
        v240 = sel_getName("_initializeHardwareAndReportFailure:");
        *(_DWORD *)buf = 67109890;
        *(_DWORD *)&uint8_t buf[4] = v238;
        *(_WORD *)&buf[8] = 2082;
        *(void *)&buf[10] = v239;
        *(_WORD *)&buf[18] = 2082;
        *(void *)&buf[20] = v240;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 879;
        _os_log_impl((void *)&_mh_execute_header, v236, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to register for power events", buf, 0x22u);
      }
    }
    uint64_t v241 = objc_opt_new();
    v242 = (void *)*((void *)v21 + 11);
    *((void *)v21 + 11) = v241;

    v243 = (void *)*((void *)v21 + 11);
    uint64_t v244 = (void *)*((void *)v21 + 29);
    v272[0] = _NSConcreteStackBlock;
    v272[1] = 3221225472;
    v272[2] = sub_1000EF8C0;
    v272[3] = &unk_100301E68;
    void v272[4] = v21;
    sub_100201234(v243, v244, v272);
    if (v270 == 2) {
      sub_1000ED130((uint64_t)v21);
    }
    [v21 maybeStartNextSession];
    sub_1002114AC(*(void **)(a1 + 368), @"Load HW");
    uint64_t v245 = [v4[413] sharedPowerAssertion];
    [v245 releasePowerAssertion:@"Load Stack"];

    sub_1000EE58C((id *)v21, 60.0);
    notify_post("com.apple.nfcd.started");
  }
}

void sub_1000EC9F8(id *a1, uint64_t a2)
{
  if (a1)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("notifyOfHwStateChanged:");
      uint64_t v8 = 45;
      if (isMetaClass) {
        uint64_t v8 = 43;
      }
      v5(6, "%c[%{public}s %{public}s]:%i Notifying client of state update : %u.", v8, ClassName, Name, 564, a2);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = object_getClass(a1);
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      *(_DWORD *)buf = 67110146;
      int v26 = v11;
      __int16 v27 = 2082;
      uint64_t v28 = object_getClassName(a1);
      __int16 v29 = 2082;
      uint64_t v30 = sel_getName("notifyOfHwStateChanged:");
      __int16 v31 = 1024;
      int v32 = 564;
      __int16 v33 = 1024;
      int v34 = a2;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Notifying client of state update : %u.", buf, 0x28u);
    }

    int v12 = sub_10000B134(a1);
    long long v20 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    long long v23 = 0u;
    int v13 = [v12 allValues];
    id v14 = [v13 countByEnumeratingWithState:&v20 objects:v24 count:16];
    if (v14)
    {
      id v15 = v14;
      uint64_t v16 = *(void *)v21;
      do
      {
        for (i = 0; i != v15; i = (char *)i + 1)
        {
          if (*(void *)v21 != v16) {
            objc_enumerationMutation(v13);
          }
          [*(id *)(*((void *)&v20 + 1) + 8 * i) hwStateDidChange:a2];
        }
        id v15 = [v13 countByEnumeratingWithState:&v20 objects:v24 count:16];
      }
      while (v15);
    }

    [a1[21] hwStateDidChange:a2];
  }
}

BOOL sub_1000ECC4C(uint64_t a1)
{
  int v2 = *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  if (v2 == 5)
  {
    sub_1000ECDB8(*(void ***)(a1 + 32), @"Recovery");
    sub_1000ED130(*(void *)(a1 + 32));
    sub_1002114AC(*(void **)(*(void *)(a1 + 32) + 368), @"Recovery");
  }
  else
  {
    if (v2 != 3)
    {
      uint64_t v6 = +[NSAssertionHandler currentHandler];
      [v6 handleFailureInMethod:*(void *)(a1 + 48) object:*(void *)(a1 + 32) file:@"_NFHardwareManager.m" lineNumber:512 description:@"Unexpected state %u" argument:*(unsigned int *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)];
    }
    sub_1000EAC5C(*(void *)(a1 + 32), 1);
  }
  uint64_t v3 = -[_NFHardwareManager getPrimaryHardwareState]_0(*(void *)(a1 + 32));
  if (*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) != v3)
  {
    sub_1000EC9F8(*(id **)(a1 + 32), v3);
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v3;
  }
  if (v3 == 2)
  {
    sub_1000ED6B4(*(void **)(a1 + 32));
    int v4 = NFSharedSignpostLog();
    if (os_signpost_enabled(v4))
    {
      *(_WORD *)buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "HWRecovery", "end", buf, 2u);
    }
  }
  return v3 == 2;
}

void sub_1000ECDB8(void **a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    if (NFProductIsVM())
    {
      sub_1000EF63C(a1, 3);
    }
    else
    {
      int v4 = sub_10020EC8C(a1[46], v3, 0);
      uint64_t v5 = a1[46];
      if (v5) {
        uint64_t v6 = v5[37];
      }
      else {
        uint64_t v6 = 0;
      }
      sub_1000EF63C(a1, v6);
      if (v4)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          uint64_t v8 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(a1);
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(a1);
          Name = sel_getName("_bootHardwareForSession:");
          uint64_t v12 = 45;
          if (isMetaClass) {
            uint64_t v12 = 43;
          }
          v8(4, "%c[%{public}s %{public}s]:%i Failed to open session : %@. State is %lu", v12, ClassName, Name, 943, v4, v6);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v13 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
          id v14 = object_getClass(a1);
          if (class_isMetaClass(v14)) {
            int v15 = 43;
          }
          else {
            int v15 = 45;
          }
          *(_DWORD *)buf = 67110402;
          int v29 = v15;
          __int16 v30 = 2082;
          __int16 v31 = object_getClassName(a1);
          __int16 v32 = 2082;
          __int16 v33 = sel_getName("_bootHardwareForSession:");
          __int16 v34 = 1024;
          int v35 = 943;
          __int16 v36 = 2112;
          uint64_t v37 = v4;
          __int16 v38 = 2048;
          uint64_t v39 = v6;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@. State is %lu", buf, 0x36u);
        }
      }
      else
      {
        uint64_t v16 = sub_10020EC8C(a1[46], @"Check RF Session Allowed", 1uLL);
        if (!v16)
        {
          sub_1002114AC(a1[46], @"Check RF Session Allowed");
          goto LABEL_29;
        }
        int v4 = (void *)v16;
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v17 = NFLogGetLogger();
        if (v17)
        {
          uint64_t v18 = (void (*)(uint64_t, const char *, ...))v17;
          int v19 = object_getClass(a1);
          BOOL v20 = class_isMetaClass(v19);
          int v25 = object_getClassName(a1);
          __int16 v27 = sel_getName("_bootHardwareForSession:");
          uint64_t v21 = 45;
          if (v20) {
            uint64_t v21 = 43;
          }
          v18(3, "%c[%{public}s %{public}s]:%i RF sessions NOT allowed : %@", v21, v25, v27, 947, v4);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        long long v22 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          long long v23 = object_getClass(a1);
          if (class_isMetaClass(v23)) {
            int v24 = 43;
          }
          else {
            int v24 = 45;
          }
          *(_DWORD *)buf = 67110146;
          int v29 = v24;
          __int16 v30 = 2082;
          __int16 v31 = object_getClassName(a1);
          __int16 v32 = 2082;
          __int16 v33 = sel_getName("_bootHardwareForSession:");
          __int16 v34 = 1024;
          int v35 = 947;
          __int16 v36 = 2112;
          uint64_t v37 = v4;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i RF sessions NOT allowed : %@", buf, 0x2Cu);
        }
      }
    }
  }
LABEL_29:
}

uint64_t sub_1000ED130(uint64_t result)
{
  if (!result) {
    return result;
  }
  uint64_t v1 = result;
  if (-[_NFHardwareManager getPrimaryHardwareState]_0(result) == 2)
  {
    id v2 = sub_100040C9C([NFExpressModeManager alloc], (void *)v1, *(void **)(v1 + 368), *(void **)(v1 + 8), *(void **)(v1 + 232));
    id v3 = *(void **)(v1 + 24);
    *(void *)(v1 + 24) = v2;

    uint64_t v4 = *(void *)(v1 + 24);
    if (v4 && (*(void *)(v4 + 136) == 1 || *(unsigned char *)(v4 + 170)))
    {
      uint64_t v5 = sub_10020EC8C(*(void **)(v1 + 368), @"Enable Express", 1uLL);
      if (v5)
      {
LABEL_37:
        id v12 = 0;
        goto LABEL_38;
      }
      if ([*(id *)(v1 + 384) hasLPEMSupport]
        && sub_1001AA204(*(void *)(v1 + 368), 1))
      {
        sub_1001AA4BC(*(void **)(v1 + 368), 1);
      }
    }
    else if ([*(id *)(v1 + 384) hasLPEMSupport])
    {
      int v13 = sub_10021A750();
      if (v13)
      {
        unint64_t v14 = v13[4];

        if (v14)
        {
          if (v14)
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t Logger = NFLogGetLogger();
            if (Logger)
            {
              uint64_t v16 = (void (*)(uint64_t, const char *, ...))Logger;
              Class = object_getClass((id)v1);
              BOOL isMetaClass = class_isMetaClass(Class);
              ClassName = object_getClassName((id)v1);
              Name = sel_getName("_initializeExpressMode");
              uint64_t v20 = 45;
              if (isMetaClass) {
                uint64_t v20 = 43;
              }
              v16(3, "%c[%{public}s %{public}s]:%i ERROR : NFC headless mode is enabled but express is not.", v20, ClassName, Name, 1093);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v21 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
            {
              long long v22 = object_getClass((id)v1);
              if (class_isMetaClass(v22)) {
                int v23 = 43;
              }
              else {
                int v23 = 45;
              }
              *(_DWORD *)buf = 67109890;
              *(_DWORD *)&uint8_t buf[4] = v23;
              *(_WORD *)uint64_t v42 = 2082;
              *(void *)&v42[2] = object_getClassName((id)v1);
              *(_WORD *)&v42[10] = 2082;
              *(void *)&v42[12] = sel_getName("_initializeExpressMode");
              *(_WORD *)&v42[20] = 1024;
              *(_DWORD *)&v42[22] = 1093;
              _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i ERROR : NFC headless mode is enabled but express is not.", buf, 0x22u);
            }
          }
          if (v14 >= 2)
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v24 = NFLogGetLogger();
            if (v24)
            {
              int v25 = (void (*)(uint64_t, const char *, ...))v24;
              int v26 = object_getClass((id)v1);
              BOOL v27 = class_isMetaClass(v26);
              uint64_t v28 = object_getClassName((id)v1);
              BOOL v40 = sel_getName("_initializeExpressMode");
              uint64_t v29 = 45;
              if (v27) {
                uint64_t v29 = 43;
              }
              v25(6, "%c[%{public}s %{public}s]:%i Headless mode is enabled but express is not. Taking session", v29, v28, v40, 1098);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            __int16 v30 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
            {
              __int16 v31 = object_getClass((id)v1);
              if (class_isMetaClass(v31)) {
                int v32 = 43;
              }
              else {
                int v32 = 45;
              }
              __int16 v33 = object_getClassName((id)v1);
              __int16 v34 = sel_getName("_initializeExpressMode");
              *(_DWORD *)buf = 67109890;
              *(_DWORD *)&uint8_t buf[4] = v32;
              *(_WORD *)uint64_t v42 = 2082;
              *(void *)&v42[2] = v33;
              *(_WORD *)&v42[10] = 2082;
              *(void *)&v42[12] = v34;
              *(_WORD *)&v42[20] = 1024;
              *(_DWORD *)&v42[22] = 1098;
              _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Headless mode is enabled but express is not. Taking session", buf, 0x22u);
            }

            sub_10019B928((void *)v1);
          }
        }
      }
    }
    uint64_t v5 = 0;
    goto LABEL_37;
  }
  id v6 = objc_alloc((Class)NSError);
  uint64_t v7 = +[NSString stringWithUTF8String:"nfcd"];
  v43[0] = NSLocalizedDescriptionKey;
  uint64_t v8 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
  *(void *)buf = v8;
  *(void *)uint64_t v42 = &off_10031B6E8;
  v43[1] = @"Line";
  v43[2] = @"Method";
  id v9 = [[objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_initializeExpressMode")];
  *(void *)&v42[8] = v9;
  v43[3] = NSDebugDescriptionErrorKey;
  id v10 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_initializeExpressMode"), 1069];
  *(void *)&v42[16] = v10;
  int v11 = +[NSDictionary dictionaryWithObjects:buf forKeys:v43 count:4];
  id v12 = [v6 initWithDomain:v7 code:58 userInfo:v11];

  uint64_t v5 = 0;
LABEL_38:

  sub_1001E0BF8(*(void **)(v1 + 368));
  int v35 = [(id)v1 defaultRoutingConfig:1];
  id v36 = [(id)v1 setRoutingConfig:v35];

  result = NFProductIsDevBoard();
  if ((result & 1) == 0)
  {
    result = NFProductIsNED();
    if ((result & 1) == 0 && !*(void *)(v1 + 408))
    {
      uint64_t v37 = [[NFBackgroundTagReadingManager alloc] initWithQueue:*(void *)(v1 + 232) driverWrapper:*(void *)(v1 + 368)];
      uint64_t v38 = *(void *)(v1 + 408);
      *(void *)(v1 + 408) = v37;
      return _objc_release_x1(v37, v38);
    }
  }
  return result;
}

void *sub_1000ED6B4(void *result)
{
  if (result)
  {
    uint64_t v1 = result;
    id v2 = [objc_alloc((Class)NFBackgroundActivityScheduler) initWithQueue:result[29]];
    id v3 = (void *)v1[12];
    v1[12] = v2;

    uint64_t v4 = (void *)v1[12];
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    v5[2] = sub_1000ED768;
    v5[3] = &unk_100301F70;
    v5[4] = v1;
    v5[5] = "_scheduleDailyAnalytics";
    return [v4 schedulePreRegisteredActivity:@"com.apple.nfcd.coreanalytics.event" callback:v5];
  }
  return result;
}

void sub_1000ED768(uint64_t a1, void *a2)
{
  id v3 = a2;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v5(6, "%c[%{public}s %{public}s]:%i Stats scheduler invoked", v9, ClassName, Name, 543);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    int v13 = object_getClassName(*(id *)(a1 + 32));
    unint64_t v14 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)buf = 67109890;
    *(_DWORD *)&uint8_t buf[4] = v12;
    *(_WORD *)__int16 v31 = 2082;
    *(void *)&v31[2] = v13;
    *(_WORD *)&v31[10] = 2082;
    *(void *)&v31[12] = v14;
    *(_WORD *)&v31[20] = 1024;
    *(_DWORD *)&v31[22] = 543;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Stats scheduler invoked", buf, 0x22u);
  }

  if (v3)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v15 = NFLogGetLogger();
    if (v15)
    {
      uint64_t v16 = (void (*)(uint64_t, const char *, ...))v15;
      uint64_t v17 = object_getClass(*(id *)(a1 + 32));
      BOOL v18 = class_isMetaClass(v17);
      BOOL v27 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v29 = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v19 = 45;
      if (v18) {
        uint64_t v19 = 43;
      }
      v16(3, "%c[%{public}s %{public}s]:%i %{public}@", v19, v27, v29, 546, v3);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v20 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      uint64_t v21 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v21)) {
        int v22 = 43;
      }
      else {
        int v22 = 45;
      }
      int v23 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v24 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)&uint8_t buf[4] = v22;
      *(_WORD *)__int16 v31 = 2082;
      *(void *)&v31[2] = v23;
      *(_WORD *)&v31[10] = 2082;
      *(void *)&v31[12] = v24;
      *(_WORD *)&v31[20] = 1024;
      *(_DWORD *)&v31[22] = 546;
      *(_WORD *)&v31[26] = 2114;
      *(void *)&v31[28] = v3;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
    }
  }
  else
  {
    uint64_t v25 = *(void *)(a1 + 32);
    if (v25)
    {
      int v26 = *(NSObject **)(v25 + 232);
      *(void *)buf = _NSConcreteStackBlock;
      *(void *)__int16 v31 = 3221225472;
      *(void *)&v31[8] = sub_1000EE740;
      *(void *)&v31[16] = &unk_100301C40;
      *(void *)&v31[24] = v25;
      *(void *)&v31[32] = "triggerDailyStats";
      dispatch_async(v26, buf);
    }
  }
}

void sub_1000EDF88(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

BOOL sub_1000EDFA4(void *a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  uint64_t v4 = (void *)a1[47];
  id v5 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002840B0 length:12];
  LODWORD(v4) = [v4 select:v5 error:0];

  if (!v4)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v9 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("_getSEMemoryInfo:result:");
      uint64_t v13 = 45;
      if (isMetaClass) {
        uint64_t v13 = 43;
      }
      v9(3, "%c[%{public}s %{public}s]:%i Failed to select CASD", v13, ClassName, Name, 1142);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    unint64_t v14 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      uint64_t v15 = object_getClass(a1);
      if (class_isMetaClass(v15)) {
        int v16 = 43;
      }
      else {
        int v16 = 45;
      }
      *(_DWORD *)buf = 67109890;
      int v19 = v16;
      __int16 v20 = 2082;
      uint64_t v21 = object_getClassName(a1);
      __int16 v22 = 2082;
      int v23 = sel_getName("_getSEMemoryInfo:result:");
      __int16 v24 = 1024;
      int v25 = 1142;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select CASD", buf, 0x22u);
    }

    return 0;
  }
  id v6 = (void *)a1[47];

  return sub_1000A3344(v6, a2);
}

id sub_1000EE1BC(uint64_t a1)
{
  if (!a1 || (unint64_t)[*(id *)(a1 + 384) siliconName] < 0xE)
  {
    id v2 = 0;
    goto LABEL_10;
  }
  id v3 = *(void **)(a1 + 368);
  id v8 = 0;
  uint64_t v4 = sub_1001E8EC0(v3, &v8);
  id v5 = v8;
  id v6 = v5;
  if (v4)
  {
  }
  else if ([v5 count])
  {
    id v2 = v6;
    goto LABEL_9;
  }
  id v2 = 0;
LABEL_9:

LABEL_10:

  return v2;
}

id sub_1000EE260(uint64_t a1)
{
  if (!a1 || !*(void *)(a1 + 384)) {
    return 0;
  }
  id v2 = +[NFCALogger sharedCALogger];
  id v3 = [v2 getHardwareTypeForCA:[*(id *)(a1 + 384) siliconName]];

  return v3;
}

void sub_1000EE2C8(uint64_t a1)
{
  id v2 = *(void **)(a1 + 32);
  uint64_t v3 = v2[4];
  if (!v3)
  {
    *(void *)(*(void *)(a1 + 32) + 32) = malloc_type_calloc(1uLL, 0x34uLL, 0x10000403884A0CCuLL);
    id v2 = *(void **)(a1 + 32);
    uint64_t v3 = v2[4];
    if (!v3)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        uint64_t v17 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(*(id *)(a1 + 32));
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(*(id *)(a1 + 32));
        Name = sel_getName(*(SEL *)(a1 + 40));
        uint64_t v21 = 45;
        if (isMetaClass) {
          uint64_t v21 = 43;
        }
        v17(3, "%c[%{public}s %{public}s]:%i Failed to create SE memory.", v21, ClassName, Name, 717);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v10 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
        goto LABEL_23;
      }
      __int16 v22 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v22)) {
        int v23 = 43;
      }
      else {
        int v23 = 45;
      }
      __int16 v24 = object_getClassName(*(id *)(a1 + 32));
      int v25 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)buf = 67109890;
      int v29 = v23;
      __int16 v30 = 2082;
      __int16 v31 = v24;
      __int16 v32 = 2082;
      __int16 v33 = v25;
      __int16 v34 = 1024;
      int v35 = 717;
      uint64_t v15 = "%c[%{public}s %{public}s]:%i Failed to create SE memory.";
      goto LABEL_22;
    }
  }
  if (sub_1000EDFA4(v2, v3)) {
    return;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v4 = NFLogGetLogger();
  if (v4)
  {
    id v5 = (void (*)(uint64_t, const char *, ...))v4;
    id v6 = object_getClass(*(id *)(a1 + 32));
    BOOL v7 = class_isMetaClass(v6);
    id v8 = object_getClassName(*(id *)(a1 + 32));
    int v26 = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v9 = 45;
    if (v7) {
      uint64_t v9 = 43;
    }
    v5(4, "%c[%{public}s %{public}s]:%i Failed to get memory info", v9, v8, v26, 722);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    int v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    uint64_t v13 = object_getClassName(*(id *)(a1 + 32));
    unint64_t v14 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)buf = 67109890;
    int v29 = v12;
    __int16 v30 = 2082;
    __int16 v31 = v13;
    __int16 v32 = 2082;
    __int16 v33 = v14;
    __int16 v34 = 1024;
    int v35 = 722;
    uint64_t v15 = "%c[%{public}s %{public}s]:%i Failed to get memory info";
LABEL_22:
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, v15, buf, 0x22u);
  }
LABEL_23:
}

id *sub_1000EE58C(id *result, double a2)
{
  if (result[16])
  {
    uint64_t v3 = result;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v3);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(v3);
      Name = sel_getName("schedulePostStartupWork:");
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v5(6, "%c[%{public}s %{public}s]:%i Scheduling post stack bootup work in %f seconds", v9, ClassName, Name, 794, *(void *)&a2);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = object_getClass(v3);
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      *(_DWORD *)buf = 67110146;
      int v15 = v12;
      __int16 v16 = 2082;
      uint64_t v17 = object_getClassName(v3);
      __int16 v18 = 2082;
      int v19 = sel_getName("schedulePostStartupWork:");
      __int16 v20 = 1024;
      int v21 = 794;
      __int16 v22 = 2048;
      double v23 = a2;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Scheduling post stack bootup work in %f seconds", buf, 0x2Cu);
    }

    return (id *)[v3[16] startTimer:a2];
  }
  return result;
}

void sub_1000EE740(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 232);
  uint64_t v3 = +[NFRoutingConfig embeddedWiredMode];
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  v5[2] = sub_1000EE804;
  v5[3] = &unk_100301C40;
  long long v6 = *(_OWORD *)(a1 + 32);
  id v4 = +[_NFBuiltinSession createSessionWithWorkQueue:v2 routing:v3 sessionQueuer:(void)v6 didStartWork:v5];
}

void sub_1000EE804(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v7 = 45;
    if (isMetaClass) {
      uint64_t v7 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i daily stats", v7, ClassName, Name, 812);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v8 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v9)) {
      int v10 = 43;
    }
    else {
      int v10 = 45;
    }
    int v11 = object_getClassName(*(id *)(a1 + 32));
    int v12 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)buf = 67109890;
    *(_DWORD *)&uint8_t buf[4] = v10;
    *(_WORD *)int v75 = 2082;
    *(void *)&v75[2] = v11;
    *(_WORD *)&v75[10] = 2082;
    *(void *)&v75[12] = v12;
    *(_WORD *)&v75[20] = 1024;
    *(_DWORD *)&v75[22] = 812;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i daily stats", buf, 0x22u);
  }

  sub_1000EF080(*(void ***)(a1 + 32));
  uint64_t v13 = sub_1000455B0(*(void **)(*(void *)(a1 + 32) + 24));
  if (v13) {
    sub_1000B6280((uint64_t)NFUnifiedAccessTransactionCALogger, v13);
  }
  unint64_t v14 = sub_100045BDC(*(void **)(*(void *)(a1 + 32) + 24));

  if (v14) {
    sub_1000B62F4((uint64_t)NFUnifiedAccessTransactionCALogger, v14);
  }
  uint64_t v15 = *(void *)(a1 + 32);
  if (v15)
  {
    __int16 v16 = objc_opt_new();
    uint64_t v70 = 0;
    long long v68 = 0u;
    long long v69 = 0u;
    long long v67 = 0u;
    if (sub_1000EDFA4((void *)v15, (uint64_t)&v67))
    {
      v88[0] = @"seTransientDeselect";
      uint64_t v17 = +[NSNumber numberWithUnsignedInt:DWORD2(v67)];
      v89[0] = v17;
      v88[1] = @"seTransientReset";
      __int16 v18 = +[NSNumber numberWithUnsignedInt:DWORD1(v67)];
      v89[1] = v18;
      v88[2] = @"seTransientPersistent";
      int v19 = +[NSNumber numberWithUnsignedInt:v67];
      v89[2] = v19;
      v88[3] = @"seAvailableIndices";
      __int16 v20 = +[NSNumber numberWithUnsignedInt:HIDWORD(v67)];
      v89[3] = v20;
      v88[4] = @"seTotalIndices";
      int v21 = +[NSNumber numberWithUnsignedInt:v68];
      v89[4] = v21;
      __int16 v22 = +[NSDictionary dictionaryWithObjects:v89 forKeys:v88 count:5];
      [v16 addEntriesFromDictionary:v22];
    }
    double v23 = sub_1000EE1BC(v15);
    __int16 v24 = v23;
    if (v23 && [v23 count]) {
      sub_10022352C((uint64_t)NFDailyStatisticsCALogger, v24);
    }
    if (*(void *)(v15 + 384))
    {
      int v25 = *(void **)(v15 + 40);
      int v26 = &stru_100309C40;
      if (v25)
      {
        id v63 = v14;
        if ((unint64_t)[v25 migrationState] <= 1
          && (unint64_t)[*(id *)(v15 + 40) migrationState] > 6)
        {
          CFStringRef v29 = &stru_100309C40;
        }
        else
        {
          BOOL v27 = *(void **)(v15 + 376);
          uint64_t v66 = &stru_100309C40;
          id v28 = sub_1000B12C8(v27, &v66);
          CFStringRef v29 = v66;
        }
        id v30 = sub_1000AE6E0(*(void **)(v15 + 376), (_DWORD *)&v70 + 1, 1);
        v73[0] = @"nfccHWVersion";
        __int16 v62 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [*(id *)(v15 + 384) siliconVersion]);
        *(void *)buf = v62;
        v73[1] = @"nfccROMVersion";
        id v61 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [*(id *)(v15 + 384) ROMVersion]);
        *(void *)int v75 = v61;
        v73[2] = @"nfccFWVersion";
        __int16 v60 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [*(id *)(v15 + 384) firmwareVersion]);
        *(void *)&v75[8] = v60;
        v73[3] = @"middlewareVersion";
        int v59 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [*(id *)(v15 + 384) middlewareVersion]);
        *(void *)&v75[16] = v59;
        v73[4] = @"hardwareType";
        unsigned int v58 = sub_1000EE260(v15);
        uint64_t v64 = (__CFString *)v29;
        int v65 = v16;
        if (v58)
        {
          __int16 v31 = +[NSNumber numberWithUnsignedInt:sub_1000EE260(v15)];
        }
        else
        {
          __int16 v31 = &off_10031B6D0;
        }
        uint64_t v53 = v31;
        *(void *)&v75[24] = v31;
        v73[5] = @"seDeviceType";
        int v57 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [*(id *)(v15 + 40) deviceType]);
        BOOL v76 = v57;
        v73[6] = @"seHWVersion";
        __int16 v56 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [*(id *)(v15 + 40) hardwareVersion]);
        uint64_t v77 = v56;
        v73[7] = @"seFWVersion";
        uint64_t v55 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [*(id *)(v15 + 40) firmwareVersion]);
        id v78 = v55;
        v73[8] = @"seSignKeyType";
        BOOL v54 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [*(id *)(v15 + 40) signingKeyType]);
        int v79 = v54;
        v73[9] = @"seSequenceCounter";
        uint64_t v32 = [*(id *)(v15 + 40) sequenceCounter];
        __int16 v33 = (void *)v32;
        if (v32) {
          __int16 v34 = (_UNKNOWN **)v32;
        }
        else {
          __int16 v34 = &off_10031B6D0;
        }
        uint64_t v80 = v34;
        v73[10] = @"seReferenceCounter";
        uint64_t v35 = [*(id *)(v15 + 40) referenceCounter];
        id v36 = (void *)v35;
        if (v35) {
          uint64_t v37 = (_UNKNOWN **)v35;
        }
        else {
          uint64_t v37 = &off_10031B6D0;
        }
        uint64_t v81 = v37;
        v73[11] = @"seOSMode";
        uint64_t v38 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [*(id *)(v15 + 40) OSMode]);
        int v82 = v38;
        v73[12] = @"seRestrictedMode";
        uint64_t v39 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", [*(id *)(v15 + 40) restrictedMode]);
        id v83 = v39;
        v73[13] = @"seMigrationState";
        BOOL v40 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [*(id *)(v15 + 40) migrationState]);
        id v84 = v40;
        v73[14] = @"seMigrationPkgs";
        uint64_t v41 = [*(id *)(v15 + 40) migrationPackages];
        uint64_t v42 = (void *)v41;
        if (v41) {
          uint64_t v43 = (_UNKNOWN **)v41;
        }
        else {
          uint64_t v43 = &off_10031B6D0;
        }
        id v85 = v43;
        v73[15] = @"seMigrationInst";
        uint64_t v44 = [*(id *)(v15 + 40) migrationInstances];
        int v45 = (void *)v44;
        if (v44) {
          int v46 = (_UNKNOWN **)v44;
        }
        else {
          int v46 = &off_10031B6D0;
        }
        v73[16] = @"sePidMigrationState";
        id v86 = v46;
        id v87 = v64;
        __int16 v47 = +[NSDictionary dictionaryWithObjects:buf forKeys:v73 count:17];
        [v65 addEntriesFromDictionary:v47];

        if (v58) {
        unint64_t v14 = v63;
        }
        int v26 = v64;
        __int16 v16 = v65;
      }
    }
    else
    {
      int v26 = &stru_100309C40;
    }
    if ([v16 count]) {
      sub_100222F0C((uint64_t)NFDailyStatisticsCALogger, v16);
    }
    int v48 = [*(id *)(v15 + 376) cachedAppletsUnfiltered];

    if (v48) {
      sub_100242FE4(*(void **)(v15 + 376));
    }
    CFStringRef v71 = @"radioIsEnabled";
    if (*(void *)(v15 + 288) == 1) {
      uint64_t v49 = &__kCFBooleanTrue;
    }
    else {
      uint64_t v49 = &__kCFBooleanFalse;
    }
    __int16 v72 = v49;
    id v50 = +[NSDictionary dictionaryWithObjects:&v72 forKeys:&v71 count:1];
    +[NFGeneralStatisticsCALogger updateGeneralDeviceStatistic:v50];

    +[NFGeneralStatisticsCALogger postGeneralDeviceStatistics];
    +[NFGeneralStatisticsCALogger postAnalyticsGeneralTransactionStatistics];
    if (HIDWORD(v70))
    {
      if (*(void *)(v15 + 384))
      {
        uint64_t v51 = *(void **)(v15 + 40);
        if (v51) {
          sub_100222F90((uint64_t)NFDailyStatisticsCALogger, v51, HIDWORD(v70));
        }
      }
    }
  }
}

void sub_1000EF080(void **a1)
{
  if (a1)
  {
    char v49 = 0;
    sub_1000AE4D0(a1[47]);
    uint64_t v2 = (char *)objc_claimAutoreleasedReturnValue();
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    id v4 = (void (*)(uint64_t, const char *, ...))Logger;
    if (v2)
    {
      if (Logger)
      {
        Class = object_getClass(a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("_logSEAttacks");
        uint64_t v7 = 45;
        if (isMetaClass) {
          uint64_t v7 = 43;
        }
        v4(3, "%c[%{public}s %{public}s]:%i Failed to get AC log presence : %@", v7, ClassName, Name, 7592, v2);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v8 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        uint64_t v9 = object_getClass(a1);
        if (class_isMetaClass(v9)) {
          int v10 = 43;
        }
        else {
          int v10 = 45;
        }
        *(_DWORD *)buf = 67110146;
        int v53 = v10;
        __int16 v54 = 2082;
        uint64_t v55 = object_getClassName(a1);
        __int16 v56 = 2082;
        int v57 = sel_getName("_logSEAttacks");
        __int16 v58 = 1024;
        int v59 = 7592;
        __int16 v60 = 2112;
        id v61 = v2;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get AC log presence : %@", buf, 0x2Cu);
      }
    }
    else
    {
      if (Logger)
      {
        int v11 = object_getClass(a1);
        BOOL v12 = class_isMetaClass(v11);
        uint64_t v13 = object_getClassName(a1);
        unint64_t v14 = sel_getName("_logSEAttacks");
        uint64_t v15 = 45;
        if (v12) {
          uint64_t v15 = 43;
        }
        v4(6, "%c[%{public}s %{public}s]:%i AC Log%s present", v15, v13, v14, 7589, " not");
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v16 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v17 = object_getClass(a1);
        if (class_isMetaClass(v17)) {
          int v18 = 43;
        }
        else {
          int v18 = 45;
        }
        *(_DWORD *)buf = 67110146;
        int v53 = v18;
        __int16 v54 = 2082;
        uint64_t v55 = object_getClassName(a1);
        __int16 v56 = 2082;
        int v57 = sel_getName("_logSEAttacks");
        __int16 v58 = 1024;
        int v59 = 7589;
        __int16 v60 = 2080;
        id v61 = " not";
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i AC Log%s present", buf, 0x2Cu);
      }

      CFStringRef v50 = @"hasAttackLogs";
      uint64_t v51 = &__kCFBooleanFalse;
      id v8 = +[NSDictionary dictionaryWithObjects:&v51 forKeys:&v50 count:1];
      +[NFGeneralStatisticsCALogger updateGeneralDeviceStatistic:v8];
    }

    int v19 = a1[47];
    int v48 = v2;
    sub_1000AD6C4(v19, &v48);
    __int16 v20 = (char *)objc_claimAutoreleasedReturnValue();
    int v21 = v48;

    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v22 = NFLogGetLogger();
    double v23 = (void (*)(uint64_t, const char *, ...))v22;
    if (v21)
    {
      if (v22)
      {
        __int16 v24 = object_getClass(a1);
        BOOL v25 = class_isMetaClass(v24);
        uint64_t v43 = object_getClassName(a1);
        int v46 = sel_getName("_logSEAttacks");
        uint64_t v26 = 45;
        if (v25) {
          uint64_t v26 = 43;
        }
        v23(3, "%c[%{public}s %{public}s]:%i Failed to get AC log : %@", v26, v43, v46, 7598, v21);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      BOOL v27 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v27, OS_LOG_TYPE_ERROR)) {
        goto LABEL_42;
      }
      id v28 = object_getClass(a1);
      if (class_isMetaClass(v28)) {
        int v29 = 43;
      }
      else {
        int v29 = 45;
      }
      id v30 = object_getClassName(a1);
      __int16 v31 = sel_getName("_logSEAttacks");
      *(_DWORD *)buf = 67110146;
      int v53 = v29;
      __int16 v54 = 2082;
      uint64_t v55 = v30;
      __int16 v56 = 2082;
      int v57 = v31;
      __int16 v58 = 1024;
      int v59 = 7598;
      __int16 v60 = 2112;
      id v61 = v21;
      uint64_t v32 = "%c[%{public}s %{public}s]:%i Failed to get AC log : %@";
      __int16 v33 = v27;
      os_log_type_t v34 = OS_LOG_TYPE_ERROR;
    }
    else
    {
      if (v22)
      {
        uint64_t v35 = object_getClass(a1);
        BOOL v36 = class_isMetaClass(v35);
        uint64_t v44 = object_getClassName(a1);
        __int16 v47 = sel_getName("_logSEAttacks");
        uint64_t v37 = 45;
        if (v36) {
          uint64_t v37 = 43;
        }
        v23(6, "%c[%{public}s %{public}s]:%i AC Log : %{public}@", v37, v44, v47, 7596, v20);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      BOOL v27 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_42;
      }
      uint64_t v38 = object_getClass(a1);
      if (class_isMetaClass(v38)) {
        int v39 = 43;
      }
      else {
        int v39 = 45;
      }
      BOOL v40 = object_getClassName(a1);
      uint64_t v41 = sel_getName("_logSEAttacks");
      *(_DWORD *)buf = 67110146;
      int v53 = v39;
      __int16 v54 = 2082;
      uint64_t v55 = v40;
      __int16 v56 = 2082;
      int v57 = v41;
      __int16 v58 = 1024;
      int v59 = 7596;
      __int16 v60 = 2114;
      id v61 = v20;
      uint64_t v32 = "%c[%{public}s %{public}s]:%i AC Log : %{public}@";
      __int16 v33 = v27;
      os_log_type_t v34 = OS_LOG_TYPE_DEFAULT;
    }
    _os_log_impl((void *)&_mh_execute_header, v33, v34, v32, buf, 0x2Cu);
LABEL_42:
  }
}

void sub_1000EF63C(void *a1, uint64_t a2)
{
  uint64_t v3 = a1;
  objc_sync_enter(v3);
  if (v3[35] != a2)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (Logger)
    {
      Class = object_getClass(v3);
      if (class_isMetaClass(Class)) {
        uint64_t v6 = 43;
      }
      else {
        uint64_t v6 = 45;
      }
      ClassName = object_getClassName(v3);
      Name = sel_getName("_updateHardwareState:");
      unint64_t v9 = v3[35] - 1;
      if (v9 > 3) {
        CFStringRef v10 = @"Unknown";
      }
      else {
        CFStringRef v10 = (const __CFString *)*((void *)&off_100304A48 + v9);
      }
      if ((unint64_t)(a2 - 1) > 3) {
        CFStringRef v11 = @"Unknown";
      }
      else {
        CFStringRef v11 = (const __CFString *)*((void *)&off_100304A48 + a2 - 1);
      }
      Logger(6, "%c[%{public}s %{public}s]:%i Hardware state %@ -> %@", v6, ClassName, Name, 1579, v10, v11);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    BOOL v12 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v13 = object_getClass(v3);
      if (class_isMetaClass(v13)) {
        int v14 = 43;
      }
      else {
        int v14 = 45;
      }
      uint64_t v15 = object_getClassName(v3);
      __int16 v16 = sel_getName("_updateHardwareState:");
      unint64_t v17 = v3[35] - 1;
      if (v17 > 3) {
        CFStringRef v18 = @"Unknown";
      }
      else {
        CFStringRef v18 = (const __CFString *)*((void *)&off_100304A48 + v17);
      }
      if ((unint64_t)(a2 - 1) > 3) {
        CFStringRef v19 = @"Unknown";
      }
      else {
        CFStringRef v19 = (const __CFString *)*((void *)&off_100304A48 + a2 - 1);
      }
      *(_DWORD *)buf = 67110402;
      int v21 = v14;
      __int16 v22 = 2082;
      double v23 = v15;
      __int16 v24 = 2082;
      BOOL v25 = v16;
      __int16 v26 = 1024;
      int v27 = 1579;
      __int16 v28 = 2112;
      CFStringRef v29 = v18;
      __int16 v30 = 2112;
      CFStringRef v31 = v19;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Hardware state %@ -> %@", buf, 0x36u);
    }

    v3[35] = a2;
  }
  objc_sync_exit(v3);
}

void sub_1000EF89C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000EF8C0(uint64_t a1)
{
  uint64_t v2 = _os_activity_create((void *)&_mh_execute_header, "Lock state changed", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
  state = 0;
  *(void *)state_8 = 0;
  os_activity_scope_enter(v2, (os_activity_scope_state_t)&state);
  os_activity_scope_leave((os_activity_scope_state_t)&state);

  uint64_t v3 = *(void *)(a1 + 32);
  if (v3)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass((id)v3);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName((id)v3);
      Name = sel_getName("lockStateChanged");
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v5(6, "%c[%{public}s %{public}s]:%i ", v9, ClassName, Name, 2488);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    CFStringRef v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v11 = object_getClass((id)v3);
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      uint64_t v13 = object_getClassName((id)v3);
      int v14 = sel_getName("lockStateChanged");
      LODWORD(state) = 67109890;
      HIDWORD(state) = v12;
      *(_WORD *)state_8 = 2082;
      *(void *)&state_8[2] = v13;
      *(_WORD *)&state_8[10] = 2082;
      *(void *)&state_8[12] = v14;
      *(_WORD *)&state_8[20] = 1024;
      *(_DWORD *)&state_8[22] = 2488;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", (uint8_t *)&state, 0x22u);
    }

    BOOL v15 = sub_1002015F0(*(void **)(v3 + 88));
    BOOL v16 = sub_100201550(*(void **)(v3 + 88));
    BOOL v17 = sub_1002015A0(*(void **)(v3 + 88));
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v18 = NFLogGetLogger();
    if (v18)
    {
      CFStringRef v19 = (void (*)(uint64_t, const char *, ...))v18;
      __int16 v20 = object_getClass((id)v3);
      BOOL v21 = class_isMetaClass(v20);
      int v53 = object_getClassName((id)v3);
      __int16 v56 = sel_getName("lockStateChanged");
      uint64_t v22 = 45;
      if (v21) {
        uint64_t v22 = 43;
      }
      v19(6, "%c[%{public}s %{public}s]:%i isLocked: %d, hasBeenUnLocked: %d, hasBeenSEUnlocked: %d", v22, v53, v56, 2498, v15, v16, v17);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    double v23 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v24 = object_getClass((id)v3);
      if (class_isMetaClass(v24)) {
        int v25 = 43;
      }
      else {
        int v25 = 45;
      }
      __int16 v26 = object_getClassName((id)v3);
      int v27 = sel_getName("lockStateChanged");
      LODWORD(state) = 67110658;
      HIDWORD(state) = v25;
      *(_WORD *)state_8 = 2082;
      *(void *)&state_8[2] = v26;
      *(_WORD *)&state_8[10] = 2082;
      *(void *)&state_8[12] = v27;
      *(_WORD *)&state_8[20] = 1024;
      *(_DWORD *)&state_8[22] = 2498;
      *(_WORD *)&state_8[26] = 1024;
      *(_DWORD *)&state_8[28] = v15;
      *(_WORD *)&state_8[32] = 1024;
      *(_DWORD *)&state_8[34] = v16;
      __int16 v63 = 1024;
      BOOL v64 = v17;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i isLocked: %d, hasBeenUnLocked: %d, hasBeenSEUnlocked: %d", (uint8_t *)&state, 0x34u);
    }

    if (!v15
      && !+[NFSecureElementWrapper isAuthRandomEntangled]
      && [*(id *)(v3 + 376) jcopSupportsEntanglement])
    {
      id v60 = 0;
      BOOL v28 = sub_10021E3E0((uint64_t)NFSSEWrapper, &v60);
      id v29 = v60;
      if (v28)
      {
        sub_1000F1EC4(v3, 0);
      }
      else
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v30 = NFLogGetLogger();
        if (v30)
        {
          CFStringRef v31 = (void (*)(uint64_t, const char *, ...))v30;
          uint64_t v32 = object_getClass((id)v3);
          BOOL v33 = class_isMetaClass(v32);
          __int16 v54 = object_getClassName((id)v3);
          int v57 = sel_getName("lockStateChanged");
          uint64_t v34 = 45;
          if (v33) {
            uint64_t v34 = 43;
          }
          v31(6, "%c[%{public}s %{public}s]:%i SSE does not support entanglement : %{public}@", v34, v54, v57, 2508, v29);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v35 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v36 = object_getClass((id)v3);
          if (class_isMetaClass(v36)) {
            int v37 = 43;
          }
          else {
            int v37 = 45;
          }
          uint64_t v38 = object_getClassName((id)v3);
          int v39 = sel_getName("lockStateChanged");
          LODWORD(state) = 67110146;
          HIDWORD(state) = v37;
          *(_WORD *)state_8 = 2082;
          *(void *)&state_8[2] = v38;
          *(_WORD *)&state_8[10] = 2082;
          *(void *)&state_8[12] = v39;
          *(_WORD *)&state_8[20] = 1024;
          *(_DWORD *)&state_8[22] = 2508;
          *(_WORD *)&state_8[26] = 2114;
          *(void *)&state_8[28] = v29;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i SSE does not support entanglement : %{public}@", (uint8_t *)&state, 0x2Cu);
        }
      }
    }
    if (v16)
    {
      if ((NFProductIsMac() & 1) == 0) {
        sub_1000F5F34(v3, 0);
      }
      if (!v17)
      {
        NFProductIsWatch();
LABEL_55:
        __int16 v52 = *(NSObject **)(v3 + 232);
        block[0] = _NSConcreteStackBlock;
        block[1] = 3221225472;
        block[2] = sub_1000F9FD8;
        block[3] = &unk_100301C68;
        block[4] = v3;
        dispatch_async(v52, block);
        return;
      }
      if (*(unsigned char *)(v3 + 338))
      {
        *(unsigned char *)(v3 + 338) = 0;
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v40 = NFLogGetLogger();
        if (v40)
        {
          uint64_t v41 = (void (*)(uint64_t, const char *, ...))v40;
          uint64_t v42 = object_getClass((id)v3);
          BOOL v43 = class_isMetaClass(v42);
          uint64_t v44 = object_getClassName((id)v3);
          __int16 v58 = sel_getName("lockStateChanged");
          uint64_t v45 = 45;
          if (v43) {
            uint64_t v45 = 43;
          }
          v41(6, "%c[%{public}s %{public}s]:%i Ending hardware pre-warm", v45, v44, v58, 2541);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v46 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v47 = object_getClass((id)v3);
          if (class_isMetaClass(v47)) {
            int v48 = 43;
          }
          else {
            int v48 = 45;
          }
          char v49 = object_getClassName((id)v3);
          CFStringRef v50 = sel_getName("lockStateChanged");
          LODWORD(state) = 67109890;
          HIDWORD(state) = v48;
          *(_WORD *)state_8 = 2082;
          *(void *)&state_8[2] = v49;
          *(_WORD *)&state_8[10] = 2082;
          *(void *)&state_8[12] = v50;
          *(_WORD *)&state_8[20] = 1024;
          *(_DWORD *)&state_8[22] = 2541;
          _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Ending hardware pre-warm", (uint8_t *)&state, 0x22u);
        }

        sub_1002114AC(*(void **)(v3 + 368), @"Prewarm");
      }
    }
    if ((NFProductIsWatch() & 1) == 0 && v17)
    {
      uint64_t v51 = *(NSObject **)(v3 + 232);
      state = _NSConcreteStackBlock;
      *(void *)state_8 = 3221225472;
      *(void *)&state_8[8] = sub_1000F9ECC;
      *(void *)&state_8[16] = &unk_100301C68;
      *(void *)&state_8[24] = v3;
      dispatch_async(v51, &state);
    }
    goto LABEL_55;
  }
}

id *sub_1000EFF70(id *a1)
{
  uint64_t v1 = a1;
  if (a1)
  {
    uint64_t v241 = objc_opt_new();
    id v2 = [objc_alloc((Class)NSUserDefaults) initWithSuiteName:@"com.apple.stockholm"];
    [v2 synchronize];
    if ([v2 BOOLForKey:@"LogNCI"]) {
      uint64_t v3 = 132;
    }
    else {
      uint64_t v3 = 128;
    }
    if ([v2 BOOLForKey:@"LogAPI"]) {
      v3 |= 8uLL;
    }
    if ([v2 BOOLForKey:@"LogAPDU"]) {
      v3 |= 0x10uLL;
    }
    if ([v2 BOOLForKey:@"LogTransactionDetails"]) {
      v3 |= 0x200uLL;
    }
    if ([v2 BOOLForKey:@"LogExpressMode"]) {
      v3 |= 0x400uLL;
    }
    if ([v2 BOOLForKey:@"LogRSSI"]) {
      v3 |= 0x4000uLL;
    }
    if ([v2 BOOLForKey:@"LogMW"]) {
      v3 |= 0x40000000uLL;
    }
    if ([v2 BOOLForKey:@"DisableSEUptime"]) {
      v3 |= 0x8000uLL;
    }
    if ([v2 BOOLForKey:@"SinglePollExpress"]) {
      v3 |= 0x40000uLL;
    }
    if ([v2 BOOLForKey:@"SimulateRestoreOS"]) {
      v3 |= 0x200000uLL;
    }
    if ([v2 BOOLForKey:@"LogL1ExtStandby"]) {
      v3 |= 0x400000uLL;
    }
    if ([v2 BOOLForKey:@"ForceVenReset"]) {
      v3 |= 0x4000000uLL;
    }
    id v4 = [v2 integerForKey:@"LogRF"];
    uint64_t v5 = v3 | 1;
    uint64_t v6 = v3 | 2;
    if (v4 != (id)1) {
      uint64_t v6 = v3;
    }
    if (v4 != (id)2) {
      uint64_t v5 = v6;
    }
    if (v4 == (id)4) {
      unint64_t v7 = v3 | 3;
    }
    else {
      unint64_t v7 = v5;
    }
    if ([v2 integerForKey:@"LogLPCD"]) {
      v7 |= 0x2000uLL;
    }
    if ([v2 integerForKey:@"LogLPCDAssist"]) {
      v7 |= 0x100000uLL;
    }
    switch((unint64_t)[v2 integerForKey:@"CETech"])
    {
      case 1uLL:
        v7 |= 0x20uLL;
        break;
      case 2uLL:
        v7 |= 0x40uLL;
        break;
      case 3uLL:
        v7 |= 0x100uLL;
        break;
      case 4uLL:
        v7 |= 0x60uLL;
        break;
      case 5uLL:
        uint64_t v8 = 288;
        goto LABEL_46;
      case 6uLL:
        uint64_t v8 = 320;
        goto LABEL_46;
      case 7uLL:
        uint64_t v8 = 352;
LABEL_46:
        v7 |= v8;
        break;
      default:
        break;
    }
    uint64_t v9 = [v2 objectForKey:@"lpcdConfigOverride"];
    v240 = (void *)v9;
    if (v9)
    {
      CFStringRef v10 = (void *)v9;
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        unsigned int v11 = [v10 BOOLValue];
        uint64_t v12 = 0x10000;
        if (v11) {
          uint64_t v12 = 4096;
        }
        v7 |= v12;
      }
    }
    if ([v2 BOOLForKey:@"lpcdAssistDisabled"])
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        int v14 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(v1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(v1);
        Name = sel_getName("_readDriverSettings");
        uint64_t v18 = 45;
        if (isMetaClass) {
          uint64_t v18 = 43;
        }
        v14(6, "%c[%{public}s %{public}s]:%i disabling LPCD assist with defaults", v18, ClassName, Name, 8086);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      CFStringRef v19 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v20 = object_getClass(v1);
        if (class_isMetaClass(v20)) {
          int v21 = 43;
        }
        else {
          int v21 = 45;
        }
        *(_DWORD *)buf = 67109890;
        int v243 = v21;
        __int16 v244 = 2082;
        uint64_t v245 = object_getClassName(v1);
        __int16 v246 = 2082;
        uint64_t v247 = sel_getName("_readDriverSettings");
        __int16 v248 = 1024;
        int v249 = 8086;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i disabling LPCD assist with defaults", buf, 0x22u);
      }

      v7 |= 0x2000000uLL;
    }
    if ([v2 BOOLForKey:@"lpcdAssistWithECP"])
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v22 = NFLogGetLogger();
      if (v22)
      {
        double v23 = (void (*)(uint64_t, const char *, ...))v22;
        __int16 v24 = object_getClass(v1);
        BOOL v25 = class_isMetaClass(v24);
        __int16 v26 = object_getClassName(v1);
        uint64_t v226 = sel_getName("_readDriverSettings");
        uint64_t v27 = 45;
        if (v25) {
          uint64_t v27 = 43;
        }
        v23(6, "%c[%{public}s %{public}s]:%i Enabling LPCD assist w/ECP", v27, v26, v226, 8091);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      BOOL v28 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        id v29 = object_getClass(v1);
        if (class_isMetaClass(v29)) {
          int v30 = 43;
        }
        else {
          int v30 = 45;
        }
        CFStringRef v31 = object_getClassName(v1);
        uint64_t v32 = sel_getName("_readDriverSettings");
        *(_DWORD *)buf = 67109890;
        int v243 = v30;
        __int16 v244 = 2082;
        uint64_t v245 = v31;
        __int16 v246 = 2082;
        uint64_t v247 = v32;
        __int16 v248 = 1024;
        int v249 = 8091;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Enabling LPCD assist w/ECP", buf, 0x22u);
      }

      v7 |= 0xFFFFFFFF80000000;
    }
    if ([v2 BOOLForKey:@"DisableLPCDCardRemoval"])
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v33 = NFLogGetLogger();
      if (v33)
      {
        uint64_t v34 = (void (*)(uint64_t, const char *, ...))v33;
        uint64_t v35 = object_getClass(v1);
        BOOL v36 = class_isMetaClass(v35);
        int v37 = object_getClassName(v1);
        int v227 = sel_getName("_readDriverSettings");
        uint64_t v38 = 45;
        if (v36) {
          uint64_t v38 = 43;
        }
        v34(6, "%c[%{public}s %{public}s]:%i Disable LPCD card removal with defaults", v38, v37, v227, 8096);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v39 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v40 = object_getClass(v1);
        if (class_isMetaClass(v40)) {
          int v41 = 43;
        }
        else {
          int v41 = 45;
        }
        uint64_t v42 = object_getClassName(v1);
        BOOL v43 = sel_getName("_readDriverSettings");
        *(_DWORD *)buf = 67109890;
        int v243 = v41;
        __int16 v244 = 2082;
        uint64_t v245 = v42;
        __int16 v246 = 2082;
        uint64_t v247 = v43;
        __int16 v248 = 1024;
        int v249 = 8096;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Disable LPCD card removal with defaults", buf, 0x22u);
      }

      v7 |= 0x8000000uLL;
    }
    if ([v2 BOOLForKey:@"WriteCounters"])
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v44 = NFLogGetLogger();
      if (v44)
      {
        uint64_t v45 = (void (*)(uint64_t, const char *, ...))v44;
        int v46 = object_getClass(v1);
        BOOL v47 = class_isMetaClass(v46);
        int v48 = object_getClassName(v1);
        uint64_t v228 = sel_getName("_readDriverSettings");
        uint64_t v49 = 45;
        if (v47) {
          uint64_t v49 = 43;
        }
        v45(6, "%c[%{public}s %{public}s]:%i Enabling write counters", v49, v48, v228, 8101);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      CFStringRef v50 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v51 = object_getClass(v1);
        if (class_isMetaClass(v51)) {
          int v52 = 43;
        }
        else {
          int v52 = 45;
        }
        int v53 = object_getClassName(v1);
        __int16 v54 = sel_getName("_readDriverSettings");
        *(_DWORD *)buf = 67109890;
        int v243 = v52;
        __int16 v244 = 2082;
        uint64_t v245 = v53;
        __int16 v246 = 2082;
        uint64_t v247 = v54;
        __int16 v248 = 1024;
        int v249 = 8101;
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Enabling write counters", buf, 0x22u);
      }

      v7 |= 0x10000000uLL;
    }
    if ([v2 BOOLForKey:@"forceFieldDetectOff"])
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v55 = NFLogGetLogger();
      if (v55)
      {
        __int16 v56 = (void (*)(uint64_t, const char *, ...))v55;
        int v57 = object_getClass(v1);
        BOOL v58 = class_isMetaClass(v57);
        int v59 = object_getClassName(v1);
        int v229 = sel_getName("_readDriverSettings");
        uint64_t v60 = 45;
        if (v58) {
          uint64_t v60 = 43;
        }
        v56(6, "%c[%{public}s %{public}s]:%i Force disabling FD", v60, v59, v229, 8106);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v61 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v62 = object_getClass(v1);
        if (class_isMetaClass(v62)) {
          int v63 = 43;
        }
        else {
          int v63 = 45;
        }
        BOOL v64 = object_getClassName(v1);
        int v65 = sel_getName("_readDriverSettings");
        *(_DWORD *)buf = 67109890;
        int v243 = v63;
        __int16 v244 = 2082;
        uint64_t v245 = v64;
        __int16 v246 = 2082;
        uint64_t v247 = v65;
        __int16 v248 = 1024;
        int v249 = 8106;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Force disabling FD", buf, 0x22u);
      }

      v7 |= 0x20000000uLL;
    }
    if ([v2 BOOLForKey:@"DisableTypeBSuppression"])
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v66 = NFLogGetLogger();
      if (v66)
      {
        long long v67 = (void (*)(uint64_t, const char *, ...))v66;
        long long v68 = object_getClass(v1);
        BOOL v69 = class_isMetaClass(v68);
        uint64_t v70 = object_getClassName(v1);
        uint64_t v230 = sel_getName("_readDriverSettings");
        uint64_t v71 = 45;
        if (v69) {
          uint64_t v71 = 43;
        }
        v67(6, "%c[%{public}s %{public}s]:%i Force disabling Type B Suppression", v71, v70, v230, 8111);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v72 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
      {
        int v73 = object_getClass(v1);
        if (class_isMetaClass(v73)) {
          int v74 = 43;
        }
        else {
          int v74 = 45;
        }
        int v75 = object_getClassName(v1);
        BOOL v76 = sel_getName("_readDriverSettings");
        *(_DWORD *)buf = 67109890;
        int v243 = v74;
        __int16 v244 = 2082;
        uint64_t v245 = v75;
        __int16 v246 = 2082;
        uint64_t v247 = v76;
        __int16 v248 = 1024;
        int v249 = 8111;
        _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Force disabling Type B Suppression", buf, 0x22u);
      }

      v7 |= (unint64_t)&_mh_execute_header;
    }
    id v77 = [objc_alloc((Class)NSDictionary) initWithContentsOfFile:@"/Library/Preferences/Logging/Subsystems/com.apple.nfc.plist"];
    if (v77)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v78 = NFLogGetLogger();
      if (v78)
      {
        int v79 = (void (*)(uint64_t, const char *, ...))v78;
        uint64_t v80 = object_getClass(v1);
        BOOL v81 = class_isMetaClass(v80);
        int v82 = object_getClassName(v1);
        int v231 = sel_getName("_readDriverSettings");
        uint64_t v83 = 45;
        if (v81) {
          uint64_t v83 = 43;
        }
        v79(6, "%c[%{public}s %{public}s]:%i Loading managed profile settings", v83, v82, v231, 8118);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v84 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
      {
        id v85 = object_getClass(v1);
        if (class_isMetaClass(v85)) {
          int v86 = 43;
        }
        else {
          int v86 = 45;
        }
        id v87 = object_getClassName(v1);
        id v88 = sel_getName("_readDriverSettings");
        *(_DWORD *)buf = 67109890;
        int v243 = v86;
        __int16 v244 = 2082;
        uint64_t v245 = v87;
        __int16 v246 = 2082;
        uint64_t v247 = v88;
        __int16 v248 = 1024;
        int v249 = 8118;
        _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Loading managed profile settings", buf, 0x22u);
      }

      id v89 = [v77 objectForKey:@"LogTransactionDetails"];

      if (v89)
      {
        id v90 = [v77 objectForKey:@"LogTransactionDetails"];
        unsigned int v91 = [v90 BOOLValue];

        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v92 = NFLogGetLogger();
        if (v92)
        {
          uint64_t v93 = (void (*)(uint64_t, const char *, ...))v92;
          __int16 v94 = object_getClass(v1);
          BOOL v95 = class_isMetaClass(v94);
          id v217 = object_getClassName(v1);
          uint64_t v232 = sel_getName("_readDriverSettings");
          uint64_t v96 = 45;
          if (v95) {
            uint64_t v96 = 43;
          }
          v93(5, "%c[%{public}s %{public}s]:%i Overriding pref settings for Tx Details with managed profile: %d", v96, v217, v232, 8121, v91);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v97 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v97, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v98 = object_getClass(v1);
          if (class_isMetaClass(v98)) {
            int v99 = 43;
          }
          else {
            int v99 = 45;
          }
          int v100 = object_getClassName(v1);
          id v101 = sel_getName("_readDriverSettings");
          *(_DWORD *)buf = 67110146;
          int v243 = v99;
          __int16 v244 = 2082;
          uint64_t v245 = v100;
          __int16 v246 = 2082;
          uint64_t v247 = v101;
          __int16 v248 = 1024;
          int v249 = 8121;
          __int16 v250 = 1024;
          unsigned int v251 = v91;
          _os_log_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Overriding pref settings for Tx Details with managed profile: %d", buf, 0x28u);
        }

        uint64_t v102 = 512;
        if (!v91) {
          uint64_t v102 = 0;
        }
        unint64_t v7 = v102 | v7 & 0xFFFFFFFFFFFFFDFFLL;
      }
      id v103 = [v77 objectForKey:@"LogAPDU"];

      if (v103)
      {
        v104 = [v77 objectForKey:@"LogAPDU"];
        unsigned int v105 = [v104 BOOLValue];

        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v106 = NFLogGetLogger();
        if (v106)
        {
          id v107 = (void (*)(uint64_t, const char *, ...))v106;
          int v108 = object_getClass(v1);
          BOOL v109 = class_isMetaClass(v108);
          uint64_t v218 = object_getClassName(v1);
          BOOL v233 = sel_getName("_readDriverSettings");
          uint64_t v110 = 45;
          if (v109) {
            uint64_t v110 = 43;
          }
          v107(5, "%c[%{public}s %{public}s]:%i Overriding pref settings for LogAPDU with managed profile: %d", v110, v218, v233, 8127, v105);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v111 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v112 = object_getClass(v1);
          if (class_isMetaClass(v112)) {
            int v113 = 43;
          }
          else {
            int v113 = 45;
          }
          uint64_t v114 = object_getClassName(v1);
          id v115 = sel_getName("_readDriverSettings");
          *(_DWORD *)buf = 67110146;
          int v243 = v113;
          __int16 v244 = 2082;
          uint64_t v245 = v114;
          __int16 v246 = 2082;
          uint64_t v247 = v115;
          __int16 v248 = 1024;
          int v249 = 8127;
          __int16 v250 = 1024;
          unsigned int v251 = v105;
          _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Overriding pref settings for LogAPDU with managed profile: %d", buf, 0x28u);
        }

        uint64_t v116 = 16;
        if (!v105) {
          uint64_t v116 = 0;
        }
        unint64_t v7 = v116 | v7 & 0xFFFFFFFFFFFFFFEFLL;
      }
      v117 = [v77 objectForKey:@"LogAPI"];

      if (v117)
      {
        uint64_t v118 = [v77 objectForKey:@"LogAPI"];
        unsigned int v119 = [v118 BOOLValue];

        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v120 = NFLogGetLogger();
        if (v120)
        {
          BOOL v121 = (void (*)(uint64_t, const char *, ...))v120;
          uint64_t v122 = object_getClass(v1);
          BOOL v123 = class_isMetaClass(v122);
          v219 = object_getClassName(v1);
          v234 = sel_getName("_readDriverSettings");
          uint64_t v124 = 45;
          if (v123) {
            uint64_t v124 = 43;
          }
          v121(5, "%c[%{public}s %{public}s]:%i Overriding pref settings for LogAPI with managed profile: %d", v124, v219, v234, 8133, v119);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v125 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v125, OS_LOG_TYPE_DEFAULT))
        {
          int v126 = object_getClass(v1);
          if (class_isMetaClass(v126)) {
            int v127 = 43;
          }
          else {
            int v127 = 45;
          }
          uint64_t v128 = object_getClassName(v1);
          uint64_t v129 = sel_getName("_readDriverSettings");
          *(_DWORD *)buf = 67110146;
          int v243 = v127;
          __int16 v244 = 2082;
          uint64_t v245 = v128;
          __int16 v246 = 2082;
          uint64_t v247 = v129;
          __int16 v248 = 1024;
          int v249 = 8133;
          __int16 v250 = 1024;
          unsigned int v251 = v119;
          _os_log_impl((void *)&_mh_execute_header, v125, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Overriding pref settings for LogAPI with managed profile: %d", buf, 0x28u);
        }

        uint64_t v130 = 8;
        if (!v119) {
          uint64_t v130 = 0;
        }
        unint64_t v7 = v130 | v7 & 0xFFFFFFFFFFFFFFF7;
      }
      uint64_t v131 = [v77 objectForKey:@"LogExpressMode"];

      if (v131)
      {
        uint64_t v132 = [v77 objectForKey:@"LogExpressMode"];
        unsigned int v133 = [v132 BOOLValue];

        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v134 = NFLogGetLogger();
        if (v134)
        {
          int v135 = (void (*)(uint64_t, const char *, ...))v134;
          BOOL v136 = object_getClass(v1);
          BOOL v137 = class_isMetaClass(v136);
          uint64_t v220 = object_getClassName(v1);
          uint64_t v235 = sel_getName("_readDriverSettings");
          uint64_t v138 = 45;
          if (v137) {
            uint64_t v138 = 43;
          }
          v135(5, "%c[%{public}s %{public}s]:%i Overriding pref settings for LogExpressMode with managed profile: %d", v138, v220, v235, 8139, v133);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v139 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v139, OS_LOG_TYPE_DEFAULT))
        {
          int v140 = object_getClass(v1);
          if (class_isMetaClass(v140)) {
            int v141 = 43;
          }
          else {
            int v141 = 45;
          }
          uint64_t v142 = object_getClassName(v1);
          unsigned int v143 = sel_getName("_readDriverSettings");
          *(_DWORD *)buf = 67110146;
          int v243 = v141;
          __int16 v244 = 2082;
          uint64_t v245 = v142;
          __int16 v246 = 2082;
          uint64_t v247 = v143;
          __int16 v248 = 1024;
          int v249 = 8139;
          __int16 v250 = 1024;
          unsigned int v251 = v133;
          _os_log_impl((void *)&_mh_execute_header, v139, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Overriding pref settings for LogExpressMode with managed profile: %d", buf, 0x28u);
        }

        uint64_t v144 = 1024;
        if (!v133) {
          uint64_t v144 = 0;
        }
        unint64_t v7 = v144 | v7 & 0xFFFFFFFFFFFFFBFFLL;
      }
      uint64_t v145 = [v77 objectForKey:@"LogNCI"];

      if (v145)
      {
        uint64_t v146 = [v77 objectForKey:@"LogNCI"];
        unsigned int v147 = [v146 BOOLValue];

        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v148 = NFLogGetLogger();
        if (v148)
        {
          uint64_t v149 = (void (*)(uint64_t, const char *, ...))v148;
          BOOL v150 = object_getClass(v1);
          BOOL v151 = class_isMetaClass(v150);
          uint64_t v221 = object_getClassName(v1);
          v236 = sel_getName("_readDriverSettings");
          uint64_t v152 = 45;
          if (v151) {
            uint64_t v152 = 43;
          }
          v149(5, "%c[%{public}s %{public}s]:%i Overriding pref settings with LogNCI managed profile: %d", v152, v221, v236, 8145, v147);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v153 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v153, OS_LOG_TYPE_DEFAULT))
        {
          v154 = object_getClass(v1);
          if (class_isMetaClass(v154)) {
            int v155 = 43;
          }
          else {
            int v155 = 45;
          }
          char v156 = object_getClassName(v1);
          id v157 = sel_getName("_readDriverSettings");
          *(_DWORD *)buf = 67110146;
          int v243 = v155;
          __int16 v244 = 2082;
          uint64_t v245 = v156;
          __int16 v246 = 2082;
          uint64_t v247 = v157;
          __int16 v248 = 1024;
          int v249 = 8145;
          __int16 v250 = 1024;
          unsigned int v251 = v147;
          _os_log_impl((void *)&_mh_execute_header, v153, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Overriding pref settings with LogNCI managed profile: %d", buf, 0x28u);
        }

        uint64_t v158 = 4;
        if (!v147) {
          uint64_t v158 = 0;
        }
        unint64_t v7 = v158 | v7 & 0xFFFFFFFFFFFFFFFBLL;
      }
      uint64_t v159 = [v77 objectForKey:@"SinglePollExpress"];

      if (v159)
      {
        v160 = [v77 objectForKey:@"SinglePollExpress"];
        unsigned int v161 = [v160 BOOLValue];

        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v162 = NFLogGetLogger();
        if (v162)
        {
          uint64_t v163 = (void (*)(uint64_t, const char *, ...))v162;
          uint64_t v164 = object_getClass(v1);
          BOOL v165 = class_isMetaClass(v164);
          uint64_t v222 = object_getClassName(v1);
          v237 = sel_getName("_readDriverSettings");
          uint64_t v166 = 45;
          if (v165) {
            uint64_t v166 = 43;
          }
          v163(5, "%c[%{public}s %{public}s]:%i Overriding pref settings with Force SinglePoll Express managed profile: %d", v166, v222, v237, 8152, v161);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v167 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v167, OS_LOG_TYPE_DEFAULT))
        {
          id v168 = object_getClass(v1);
          if (class_isMetaClass(v168)) {
            int v169 = 43;
          }
          else {
            int v169 = 45;
          }
          id v170 = object_getClassName(v1);
          id v171 = sel_getName("_readDriverSettings");
          *(_DWORD *)buf = 67110146;
          int v243 = v169;
          __int16 v244 = 2082;
          uint64_t v245 = v170;
          __int16 v246 = 2082;
          uint64_t v247 = v171;
          __int16 v248 = 1024;
          int v249 = 8152;
          __int16 v250 = 1024;
          unsigned int v251 = v161;
          _os_log_impl((void *)&_mh_execute_header, v167, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Overriding pref settings with Force SinglePoll Express managed profile: %d", buf, 0x28u);
        }

        uint64_t v172 = 0x40000;
        if (!v161) {
          uint64_t v172 = 0;
        }
        unint64_t v7 = v172 | v7 & 0xFFFFFFFFFFFBFFFFLL;
      }
      v173 = [v77 objectForKey:@"CETech"];

      if (v173)
      {
        uint64_t v174 = [v77 objectForKey:@"CETech"];
        id v175 = [v174 intValue];

        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v176 = NFLogGetLogger();
        if (v176)
        {
          int v177 = (void (*)(uint64_t, const char *, ...))v176;
          int v178 = object_getClass(v1);
          BOOL v179 = class_isMetaClass(v178);
          BOOL v223 = object_getClassName(v1);
          int v238 = sel_getName("_readDriverSettings");
          uint64_t v180 = 45;
          if (v179) {
            uint64_t v180 = 43;
          }
          v177(5, "%c[%{public}s %{public}s]:%i Overriding pref settings with CE Tech managed profile: 0x%04x", v180, v223, v238, 8159, v175);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        unsigned int v181 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v181, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v182 = object_getClass(v1);
          if (class_isMetaClass(v182)) {
            int v183 = 43;
          }
          else {
            int v183 = 45;
          }
          uint64_t v184 = object_getClassName(v1);
          id v185 = sel_getName("_readDriverSettings");
          *(_DWORD *)buf = 67110146;
          int v243 = v183;
          __int16 v244 = 2082;
          uint64_t v245 = v184;
          __int16 v246 = 2082;
          uint64_t v247 = v185;
          __int16 v248 = 1024;
          int v249 = 8159;
          __int16 v250 = 1024;
          unsigned int v251 = v175;
          _os_log_impl((void *)&_mh_execute_header, v181, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Overriding pref settings with CE Tech managed profile: 0x%04x", buf, 0x28u);
        }

        unint64_t v186 = v7 & 0xFFFFFFFFFFFFFE9FLL;
        switch((int)v175)
        {
          case 1:
            unint64_t v7 = v186 | 0x20;
            break;
          case 2:
            unint64_t v7 = v186 | 0x40;
            break;
          case 3:
            unint64_t v7 = v186 | 0x100;
            break;
          case 4:
            unint64_t v7 = v186 | 0x60;
            break;
          case 5:
            uint64_t v187 = 288;
            goto LABEL_224;
          case 6:
            uint64_t v187 = 320;
LABEL_224:
            unint64_t v7 = v186 | v187;
            break;
          case 7:
            v7 |= 0x160uLL;
            break;
          default:
            v7 &= 0xFFFFFFFFFFFFFE9FLL;
            break;
        }
      }
      v188 = [v77 objectForKey:@"LogRF"];

      if (v188)
      {
        unsigned int v189 = [v77 objectForKey:@"LogRF"];
        id v190 = [v189 intValue];

        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v191 = NFLogGetLogger();
        if (v191)
        {
          id v192 = (void (*)(uint64_t, const char *, ...))v191;
          uint64_t v193 = object_getClass(v1);
          BOOL v194 = class_isMetaClass(v193);
          uint64_t v224 = object_getClassName(v1);
          uint64_t v239 = sel_getName("_readDriverSettings");
          uint64_t v195 = 45;
          if (v194) {
            uint64_t v195 = 43;
          }
          v192(5, "%c[%{public}s %{public}s]:%i Overriding pref settings with LogRF managed profile: 0x%04x", v195, v224, v239, 8174, v190);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v196 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v196, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v197 = object_getClass(v1);
          if (class_isMetaClass(v197)) {
            int v198 = 43;
          }
          else {
            int v198 = 45;
          }
          uint64_t v199 = object_getClassName(v1);
          id v200 = sel_getName("_readDriverSettings");
          *(_DWORD *)buf = 67110146;
          int v243 = v198;
          __int16 v244 = 2082;
          uint64_t v245 = v199;
          __int16 v246 = 2082;
          uint64_t v247 = v200;
          __int16 v248 = 1024;
          int v249 = 8174;
          __int16 v250 = 1024;
          unsigned int v251 = v190;
          _os_log_impl((void *)&_mh_execute_header, v196, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Overriding pref settings with LogRF managed profile: 0x%04x", buf, 0x28u);
        }

        unint64_t v201 = v7 & 0xFFFFFFFFFFFFFFFCLL;
        if (v190 == 1) {
          unint64_t v201 = v7 & 0xFFFFFFFFFFFFFFFCLL | 2;
        }
        if (v190 == 2) {
          unint64_t v201 = v7 & 0xFFFFFFFFFFFFFFFCLL | 1;
        }
        if (v190 == 4) {
          v7 |= 3uLL;
        }
        else {
          unint64_t v7 = v201;
        }
      }
    }
    int v202 = [v2 dataForKey:@"ChipscopeConfig"];
    if (v202)
    {
      objc_opt_class();
      if (objc_opt_isKindOfClass())
      {
        id v203 = v202;
        if ([v203 bytes])
        {
          if ([v203 length] && objc_msgSend(v2, "integerForKey:", @"Chipscope"))
          {
            v7 |= 0x20000uLL;
            [v241 setObject:v203 forKeyedSubscript:@"chipscope"];
          }
        }
      }
    }
    uint64_t v204 = (uint64_t)[v2 integerForKey:@"PollingPeriod"];
    uint64_t v205 = v204 & ~(v204 >> 63);
    uint64_t v206 = (uint64_t)[v2 integerForKey:@"GenericATxTimeout"];
    uint64_t v207 = v206 & ~(v206 >> 63);
    if (NFProductHasThermistor()) {
      uint64_t v208 = v7 | 0x1000000;
    }
    else {
      uint64_t v208 = v7;
    }
    uint64_t v209 = +[NSNumber numberWithUnsignedLongLong:v208];
    [v241 setObject:v209 forKeyedSubscript:@"flags"];

    v210 = +[NSNumber numberWithInteger:v205];
    [v241 setObject:v210 forKeyedSubscript:@"pollPeriod"];

    id v211 = +[NSNumber numberWithInteger:v207];
    [v241 setObject:v211 forKeyedSubscript:@"atx"];

    int v212 = v1[10];
    if (v212) {
      char v213 = v212[8] != 0;
    }
    else {
      char v213 = 0;
    }
    sub_1000F2AF0(v1, v213);
    [v1[51] refreshUserDefaultsOverride];
    *((unsigned char *)v1 + 350) = [v2 BOOLForKey:@"DumpLogsOnStartup"];
    *((unsigned char *)v1 + 349) = [v2 BOOLForKey:@"LPMAlwaysOn"];
    if (NFIsInternalBuild())
    {
      uint64_t v214 = (uint64_t)[v2 integerForKey:@"PowerCountersInterval"];
      uint64_t v215 = v214 & ~(v214 >> 63);
    }
    else
    {
      uint64_t v215 = 0;
    }
    v1[37] = (id)v215;
    uint64_t v1 = v241;
  }

  return v1;
}

void sub_1000F1930(uint64_t a1)
{
  objc_initWeak(&location, *(id *)(a1 + 32));
  uint64_t v12 = 0;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2050000000;
  id v2 = (void *)qword_100347440;
  uint64_t v15 = qword_100347440;
  if (!qword_100347440)
  {
    *(void *)&long long buf = _NSConcreteStackBlock;
    *((void *)&buf + 1) = 3221225472;
    BOOL v17 = sub_10012B754;
    uint64_t v18 = &unk_100301E40;
    CFStringRef v19 = &v12;
    sub_10012B754(&buf);
    id v2 = (void *)v13[3];
  }
  id v3 = v2;
  _Block_object_dispose(&v12, 8);
  id v4 = objc_opt_new();
  uint64_t v5 = *(void *)(a1 + 40);
  v9[0] = _NSConcreteStackBlock;
  v9[1] = 3221225472;
  v9[2] = sub_1000F1B90;
  v9[3] = &unk_100304230;
  objc_copyWeak(v10, &location);
  uint64_t v6 = *(void **)(a1 + 40);
  v10[1] = *(id *)(a1 + 48);
  v10[2] = v6;
  [v4 postComponentStatusEventFor:7 status:v5 withReply:v9];

  id v7 = *(id *)(a1 + 32);
  objc_sync_enter(v7);
  qword_100346240 = *(void *)(a1 + 40);
  objc_sync_exit(v7);

  uint64_t v8 = *(void *)(a1 + 40);
  if (v8 != 1 && os_log_type_enabled((os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT))
  {
    LODWORD(buf) = 134217984;
    *(void *)((char *)&buf + 4) = v8;
    _os_log_fault_impl((void *)&_mh_execute_header, (os_log_t)&_os_log_default, OS_LOG_TYPE_FAULT, "HW in bad state %llu - reported to the system health monitor", (uint8_t *)&buf, 0xCu);
  }
  objc_destroyWeak(v10);
  objc_destroyWeak(&location);
}

void sub_1000F1B50(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location, char a17)
{
}

void sub_1000F1B90(uint64_t a1, int a2, void *a3)
{
  uint64_t v5 = a3;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  uint64_t v8 = (void (*)(uint64_t, const char *, ...))Logger;
  if (v5)
  {
    if (Logger)
    {
      Class = object_getClass(WeakRetained);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(WeakRetained);
      Name = sel_getName(*(SEL *)(a1 + 40));
      if (a2) {
        CFStringRef v13 = @"success";
      }
      else {
        CFStringRef v13 = @"failure";
      }
      CFStringRef v36 = v13;
      uint64_t v14 = 45;
      if (isMetaClass) {
        uint64_t v14 = 43;
      }
      v8(3, "%c[%{public}s %{public}s]:%i Error posting status (%{public}@) to SystemHealthManager - %{public}@", v14, ClassName, Name, 996, v36, v5);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v15 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      BOOL v16 = object_getClass(WeakRetained);
      if (class_isMetaClass(v16)) {
        int v17 = 43;
      }
      else {
        int v17 = 45;
      }
      uint64_t v18 = object_getClassName(WeakRetained);
      CFStringRef v19 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)long long buf = 67110402;
      if (a2) {
        CFStringRef v20 = @"success";
      }
      else {
        CFStringRef v20 = @"failure";
      }
      int v38 = v17;
      __int16 v39 = 2082;
      uint64_t v40 = v18;
      __int16 v41 = 2082;
      uint64_t v42 = v19;
      __int16 v43 = 1024;
      int v44 = 996;
      __int16 v45 = 2114;
      CFStringRef v46 = v20;
      __int16 v47 = 2114;
      CFStringRef v48 = v5;
      int v21 = "%c[%{public}s %{public}s]:%i Error posting status (%{public}@) to SystemHealthManager - %{public}@";
      uint64_t v22 = v15;
      os_log_type_t v23 = OS_LOG_TYPE_ERROR;
LABEL_30:
      _os_log_impl((void *)&_mh_execute_header, v22, v23, v21, buf, 0x36u);
    }
  }
  else
  {
    if (Logger)
    {
      __int16 v24 = object_getClass(WeakRetained);
      BOOL v25 = class_isMetaClass(v24);
      __int16 v26 = object_getClassName(WeakRetained);
      uint64_t v27 = sel_getName(*(SEL *)(a1 + 40));
      CFStringRef v28 = @"failure";
      if (a2) {
        CFStringRef v28 = @"success";
      }
      uint64_t v29 = 45;
      if (v25) {
        uint64_t v29 = 43;
      }
      v8(6, "%c[%{public}s %{public}s]:%i Posted status (%llu) to SystemHealthManager - %@", v29, v26, v27, 999, *(void *)(a1 + 48), v28);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v15 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      int v30 = object_getClass(WeakRetained);
      if (class_isMetaClass(v30)) {
        int v31 = 43;
      }
      else {
        int v31 = 45;
      }
      uint64_t v32 = object_getClassName(WeakRetained);
      uint64_t v33 = sel_getName(*(SEL *)(a1 + 40));
      CFStringRef v34 = *(const __CFString **)(a1 + 48);
      CFStringRef v35 = @"failure";
      *(_DWORD *)long long buf = 67110402;
      int v38 = v31;
      if (a2) {
        CFStringRef v35 = @"success";
      }
      __int16 v39 = 2082;
      uint64_t v40 = v32;
      __int16 v41 = 2082;
      uint64_t v42 = v33;
      __int16 v43 = 1024;
      int v44 = 999;
      __int16 v45 = 2048;
      CFStringRef v46 = v34;
      __int16 v47 = 2112;
      CFStringRef v48 = v35;
      int v21 = "%c[%{public}s %{public}s]:%i Posted status (%llu) to SystemHealthManager - %@";
      uint64_t v22 = v15;
      os_log_type_t v23 = OS_LOG_TYPE_DEFAULT;
      goto LABEL_30;
    }
  }
}

void sub_1000F1EC4(uint64_t a1, int a2)
{
  unsigned __int8 v4 = [*(id *)(a1 + 376) upgradeChecked];
  if (!+[NFSecureElementWrapper isAuthRandomEntangled]
    && (v4 & 1) == 0
    && [*(id *)(a1 + 376) jcopSupportsEntanglement]
    && sub_10021E3E0((uint64_t)NFSSEWrapper, 0))
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass((id)a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName((id)a1);
      Name = sel_getName("_upgradeAuthRandomSynchronously:");
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v6(6, "%c[%{public}s %{public}s]:%i UpgradeChecked = %d", v9, ClassName, Name, 1191, 0);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    CFStringRef v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v11 = object_getClass((id)a1);
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      *(_DWORD *)long long buf = 67110146;
      *(_DWORD *)&uint8_t buf[4] = v12;
      *(_WORD *)__int16 v43 = 2082;
      *(void *)&v43[2] = object_getClassName((id)a1);
      *(_WORD *)&v43[10] = 2082;
      *(void *)&v43[12] = sel_getName("_upgradeAuthRandomSynchronously:");
      *(_WORD *)&v43[20] = 1024;
      *(_DWORD *)&v43[22] = 1191;
      *(_WORD *)&v43[26] = 1024;
      *(_DWORD *)&v43[28] = 0;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i UpgradeChecked = %d", buf, 0x28u);
    }

    *(void *)long long buf = 0;
    *(void *)__int16 v43 = buf;
    *(void *)&v43[8] = 0x3032000000;
    *(void *)&v43[16] = sub_10000B858;
    *(void *)&v43[24] = sub_1000F2378;
    id v44 = 0;
    if (a2)
    {
      v31[0] = _NSConcreteStackBlock;
      v31[1] = 3221225472;
      v31[2] = sub_1000F2380;
      v31[3] = &unk_100304498;
      v31[4] = a1;
      v31[5] = buf;
      CFStringRef v13 = +[NFRoutingConfig embeddedWiredModeWithFD:0];
      int v14 = sub_1000F23D8((void **)a1, v31, @"Upgrade SEP token", v13);

      if (v14 && !*(void *)(*(void *)v43 + 40)) {
        goto LABEL_29;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v15 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v15)
      {
        BOOL v16 = object_getClass((id)a1);
        if (class_isMetaClass(v16)) {
          uint64_t v17 = 43;
        }
        else {
          uint64_t v17 = 45;
        }
        uint64_t v18 = object_getClassName((id)a1);
        CFStringRef v19 = sel_getName("_upgradeAuthRandomSynchronously:");
        v15(3, "%c[%{public}s %{public}s]:%i Failed: %{public}@", v17, v18, v19, 1205, *(void *)(*(void *)v43 + 40));
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      CFStringRef v20 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        int v21 = object_getClass((id)a1);
        if (class_isMetaClass(v21)) {
          int v22 = 43;
        }
        else {
          int v22 = 45;
        }
        os_log_type_t v23 = object_getClassName((id)a1);
        __int16 v24 = sel_getName("_upgradeAuthRandomSynchronously:");
        uint64_t v25 = *(void *)(*(void *)v43 + 40);
        *(_DWORD *)uint64_t v32 = 67110146;
        int v33 = v22;
        __int16 v34 = 2082;
        CFStringRef v35 = v23;
        __int16 v36 = 2082;
        int v37 = v24;
        __int16 v38 = 1024;
        int v39 = 1205;
        __int16 v40 = 2114;
        uint64_t v41 = v25;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed: %{public}@", v32, 0x2Cu);
      }
    }
    else
    {
      uint64_t v26 = *(void *)(a1 + 232);
      CFStringRef v20 = +[NFRoutingConfig embeddedWiredMode];
      v30[0] = _NSConcreteStackBlock;
      v30[1] = 3221225472;
      v30[2] = sub_1000F27D8;
      v30[3] = &unk_100301C68;
      v30[4] = a1;
      id v27 = +[_NFBuiltinSession createSessionWithWorkQueue:v26 routing:v20 sessionQueuer:a1 didStartWork:v30];
    }

LABEL_29:
    _Block_object_dispose(buf, 8);
  }
}

void sub_1000F2348(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 144), 8);
  _Unwind_Resume(a1);
}

void sub_1000F2378(uint64_t a1)
{
}

BOOL sub_1000F2380(uint64_t a1)
{
  uint64_t v2 = sub_1001FAF54(*(id *)(*(void *)(a1 + 32) + 376));
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  unsigned __int8 v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  return *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) == 0;
}

uint64_t sub_1000F23D8(void **a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (a1)
  {
    CFStringRef v10 = [a1 lastKnownRoutingConfig];
    id v11 = [v10 copy];

    if (!v8) {
      goto LABEL_7;
    }
    int v12 = +[NFRoutingConfig embeddedWiredModeWithFD:0];
    unint64_t v13 = 0;
    if (([v9 isEqual:v12] & 1) == 0)
    {
      int v14 = +[NFRoutingConfig routingOff];
      unint64_t v13 = [v9 isEqual:v14] ^ 1;
    }
    uint64_t v15 = sub_10020EC8C(a1[46], v8, v13);
    if (v15)
    {
      uint64_t v16 = 0;
    }
    else
    {
LABEL_7:
      uint64_t v17 = [a1 setRoutingConfig:v9];

      if (v17)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          CFStringRef v19 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(a1);
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(a1);
          Name = sel_getName("executeBlock:sessionName:routingConfig:");
          uint64_t v23 = 45;
          if (isMetaClass) {
            uint64_t v23 = 43;
          }
          v19(3, "%c[%{public}s %{public}s]:%i Failed to change routing.", v23, ClassName, Name, 1720);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        __int16 v24 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        {
          uint64_t v25 = object_getClass(a1);
          if (class_isMetaClass(v25)) {
            int v26 = 43;
          }
          else {
            int v26 = 45;
          }
          *(_DWORD *)long long buf = 67109890;
          int v41 = v26;
          __int16 v42 = 2082;
          __int16 v43 = object_getClassName(a1);
          __int16 v44 = 2082;
          __int16 v45 = sel_getName("executeBlock:sessionName:routingConfig:");
          __int16 v46 = 1024;
          int v47 = 1720;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to change routing.", buf, 0x22u);
        }

        sub_1002114AC(a1[46], v8);
        uint64_t v16 = 0;
      }
      else
      {
        uint64_t v16 = v7[2](v7);
        id v27 = [a1 setRoutingConfig:v11];

        if (v27)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v28 = NFLogGetLogger();
          if (v28)
          {
            uint64_t v29 = (void (*)(uint64_t, const char *, ...))v28;
            int v30 = object_getClass(a1);
            BOOL v31 = class_isMetaClass(v30);
            uint64_t v32 = object_getClassName(a1);
            int v39 = sel_getName("executeBlock:sessionName:routingConfig:");
            uint64_t v33 = 45;
            if (v31) {
              uint64_t v33 = 43;
            }
            v29(3, "%c[%{public}s %{public}s]:%i Failed to restore routing", v33, v32, v39, 1728);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          __int16 v34 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
          {
            CFStringRef v35 = object_getClass(a1);
            if (class_isMetaClass(v35)) {
              int v36 = 43;
            }
            else {
              int v36 = 45;
            }
            *(_DWORD *)long long buf = 67109890;
            int v41 = v36;
            __int16 v42 = 2082;
            __int16 v43 = object_getClassName(a1);
            __int16 v44 = 2082;
            __int16 v45 = sel_getName("executeBlock:sessionName:routingConfig:");
            __int16 v46 = 1024;
            int v47 = 1728;
            _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to restore routing", buf, 0x22u);
          }
        }
        if (v8) {
          sub_1002114AC(a1[46], v8);
        }
      }
      uint64_t v15 = 0;
    }
  }
  else
  {
    uint64_t v16 = 0;
  }

  return v16;
}

id sub_1000F27D8(uint64_t a1)
{
  return sub_1001FAF54(*(id *)(*(void *)(a1 + 32) + 376));
}

BOOL sub_1000F2800(uint64_t a1)
{
  uint64_t v2 = [*(id *)(*(void *)(a1 + 32) + 376) negotiatePerBootAuthKeys];
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  unsigned __int8 v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  return *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) == 0;
}

id sub_1000F2858(uint64_t a1)
{
  return [*(id *)(*(void *)(a1 + 32) + 376) negotiatePerBootAuthKeys];
}

uint64_t sub_1000F2880(uint64_t result)
{
  if (result)
  {
    if ([*(id *)(result + 40) migrationState] == (id)1)
    {
      return 0;
    }
    else
    {
      sub_1001990A4((uint64_t)NFBugCapture, @"Failed to start the session", @"File: _NFHardwareManager, Function: _isInAppletMigrationState, Error: Migration state is not idle", &off_100323028);
      return 1;
    }
  }
  return result;
}

uint64_t sub_1000F28DC(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = (id *)result;
    result = (uint64_t)[*(id *)(result + 40) migrationState];
    if (result)
    {
      if ([v1[5] migrationState] == (id)1 || objc_msgSend(v1[5], "migrationContext") != (id)3)
      {
        return 0;
      }
      else
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(v1);
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(v1);
          Name = sel_getName("_isInOSUAppletMigrationState");
          id v16 = [v1[5] migrationState];
          id v17 = [v1[5] migrationContext];
          uint64_t v8 = 45;
          if (isMetaClass) {
            uint64_t v8 = 43;
          }
          v3(3, "%c[%{public}s %{public}s]:%i OSU SE migration incomplete 0x%04x, context 0x%04x", v8, ClassName, Name, 1264, v16, v17);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v9 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          CFStringRef v10 = object_getClass(v1);
          if (class_isMetaClass(v10)) {
            int v11 = 43;
          }
          else {
            int v11 = 45;
          }
          int v12 = object_getClassName(v1);
          unint64_t v13 = sel_getName("_isInOSUAppletMigrationState");
          unsigned int v14 = [v1[5] migrationState];
          unsigned int v15 = [v1[5] migrationContext];
          *(_DWORD *)long long buf = 67110402;
          int v19 = v11;
          __int16 v20 = 2082;
          int v21 = v12;
          __int16 v22 = 2082;
          uint64_t v23 = v13;
          __int16 v24 = 1024;
          int v25 = 1264;
          __int16 v26 = 1024;
          unsigned int v27 = v14;
          __int16 v28 = 1024;
          unsigned int v29 = v15;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i OSU SE migration incomplete 0x%04x, context 0x%04x", buf, 0x2Eu);
        }

        return 1;
      }
    }
  }
  return result;
}

void sub_1000F2AF0(void *a1, char a2)
{
  if (a1)
  {
    if (a2)
    {
      uint64_t v3 = [objc_alloc((Class)NSUserDefaults) initWithSuiteName:@"com.apple.stockholm"];
      [v3 synchronize];
      if ((NFIsChinaSku() & 1) == 0)
      {
        if (!NFIsInternalBuild()) {
          goto LABEL_47;
        }
        __int16 v28 = [v3 objectForKey:@"forceChinaSku"];

        if (!v28) {
          goto LABEL_47;
        }
        unsigned int v29 = [v3 BOOLForKey:@"forceChinaSku"];
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          BOOL v31 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(a1);
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(a1);
          Name = sel_getName("radioConfigChanged:");
          if (v29) {
            CFStringRef v36 = @"on";
          }
          else {
            CFStringRef v36 = @"off";
          }
          uint64_t v37 = 45;
          if (isMetaClass) {
            uint64_t v37 = 43;
          }
          v31(5, "%c[%{public}s %{public}s]:%i Force China Sku: %{public}@", v37, ClassName, Name, 1335, v36);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        __int16 v38 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
        {
          int v39 = object_getClass(a1);
          if (class_isMetaClass(v39)) {
            int v40 = 43;
          }
          else {
            int v40 = 45;
          }
          int v41 = object_getClassName(a1);
          __int16 v42 = sel_getName("radioConfigChanged:");
          *(_DWORD *)long long buf = 67110146;
          if (v29) {
            CFStringRef v43 = @"on";
          }
          else {
            CFStringRef v43 = @"off";
          }
          int v59 = v40;
          __int16 v60 = 2082;
          id v61 = v41;
          __int16 v62 = 2082;
          int v63 = v42;
          __int16 v64 = 1024;
          int v65 = 1335;
          __int16 v66 = 2114;
          CFStringRef v67 = v43;
          _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Force China Sku: %{public}@", buf, 0x2Cu);
        }

        if (!v29) {
          goto LABEL_47;
        }
      }
      unsigned __int8 v4 = [v3 objectForKey:@"nfcRadioEnabled"];

      if (v4)
      {
        uint64_t v5 = [v3 BOOLForKey:@"nfcRadioEnabled"];
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v6 = NFLogGetLogger();
        if (v6)
        {
          id v7 = (void (*)(uint64_t, const char *, ...))v6;
          uint64_t v8 = object_getClass(a1);
          BOOL v9 = class_isMetaClass(v8);
          CFStringRef v10 = object_getClassName(a1);
          int v11 = sel_getName("radioConfigChanged:");
          if (v5) {
            CFStringRef v12 = @"on";
          }
          else {
            CFStringRef v12 = @"off";
          }
          uint64_t v13 = 45;
          if (v9) {
            uint64_t v13 = 43;
          }
          v7(5, "%c[%{public}s %{public}s]:%i NFC radio preference setting %{public}@", v13, v10, v11, 1344, v12);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        unsigned int v14 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          unsigned int v15 = object_getClass(a1);
          if (class_isMetaClass(v15)) {
            int v16 = 43;
          }
          else {
            int v16 = 45;
          }
          id v17 = object_getClassName(a1);
          uint64_t v18 = sel_getName("radioConfigChanged:");
          CFStringRef v19 = @"off";
          *(_DWORD *)long long buf = 67110146;
          int v59 = v16;
          __int16 v60 = 2082;
          if (v5) {
            CFStringRef v19 = @"on";
          }
          id v61 = v17;
          __int16 v62 = 2082;
          int v63 = v18;
          __int16 v64 = 1024;
          int v65 = 1344;
          __int16 v66 = 2114;
          CFStringRef v67 = v19;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NFC radio preference setting %{public}@", buf, 0x2Cu);
        }
      }
      else
      {
LABEL_47:
        uint64_t v5 = 1;
      }
      a1[36] = v5;
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v44 = NFLogGetLogger();
      if (v44)
      {
        __int16 v45 = (void (*)(uint64_t, const char *, ...))v44;
        __int16 v46 = object_getClass(a1);
        BOOL v47 = class_isMetaClass(v46);
        CFStringRef v48 = object_getClassName(a1);
        uint64_t v49 = sel_getName("radioConfigChanged:");
        uint64_t v50 = 45;
        if (v47) {
          uint64_t v50 = 43;
        }
        v45(6, "%c[%{public}s %{public}s]:%i radio state: %d", v50, v48, v49, 1352, a1[36]);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v51 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
      {
        int v52 = object_getClass(a1);
        if (class_isMetaClass(v52)) {
          int v53 = 43;
        }
        else {
          int v53 = 45;
        }
        __int16 v54 = object_getClassName(a1);
        uint64_t v55 = sel_getName("radioConfigChanged:");
        uint64_t v56 = a1[36];
        *(_DWORD *)long long buf = 67110146;
        int v59 = v53;
        __int16 v60 = 2082;
        id v61 = v54;
        __int16 v62 = 2082;
        int v63 = v55;
        __int16 v64 = 1024;
        int v65 = 1352;
        __int16 v66 = 1024;
        LODWORD(v67) = v56;
        _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i radio state: %d", buf, 0x28u);
      }
    }
    else
    {
      a1[36] = -1;
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v20 = NFLogGetLogger();
      if (v20)
      {
        int v21 = (void (*)(uint64_t, const char *, ...))v20;
        __int16 v22 = object_getClass(a1);
        BOOL v23 = class_isMetaClass(v22);
        __int16 v24 = object_getClassName(a1);
        int v57 = sel_getName("radioConfigChanged:");
        uint64_t v25 = 45;
        if (v23) {
          uint64_t v25 = 43;
        }
        v21(5, "%c[%{public}s %{public}s]:%i Radio disabled by mobileconfig", v25, v24, v57, 1320);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v3 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v26 = object_getClass(a1);
        if (class_isMetaClass(v26)) {
          int v27 = 43;
        }
        else {
          int v27 = 45;
        }
        *(_DWORD *)long long buf = 67109890;
        int v59 = v27;
        __int16 v60 = 2082;
        id v61 = object_getClassName(a1);
        __int16 v62 = 2082;
        int v63 = sel_getName("radioConfigChanged:");
        __int16 v64 = 1024;
        int v65 = 1320;
        _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Radio disabled by mobileconfig", buf, 0x22u);
      }
    }
  }
}

void sub_1000F310C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    id v3 = WeakRetained;
    uint64_t v2 = WeakRetained;
    objc_sync_enter(v2);
    v2[352] = 0;
    objc_sync_exit(v2);

    id WeakRetained = v3;
  }
}

void sub_1000F3760(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  objc_sync_exit(v15);
  objc_sync_exit(v14);
  _Unwind_Resume(a1);
}

void sub_1000F37AC(uint64_t *a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("didCloseXPCConnection:");
      CFStringRef v10 = [v3 NF_userInfo];
      int v11 = [v10 objectForKeyedSubscript:@"ClientName"];
      uint64_t v12 = 45;
      if (isMetaClass) {
        uint64_t v12 = 43;
      }
      v5(6, "%c[%{public}s %{public}s]:%i Removing XPC connection for %{public}@ - %{public}@", v12, ClassName, Name, 1510, v11, v3);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v13 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v14 = object_getClass(a1);
      if (class_isMetaClass(v14)) {
        int v15 = 43;
      }
      else {
        int v15 = 45;
      }
      int v16 = object_getClassName(a1);
      id v17 = sel_getName("didCloseXPCConnection:");
      uint64_t v18 = [v3 NF_userInfo];
      CFStringRef v19 = [v18 objectForKeyedSubscript:@"ClientName"];
      *(_DWORD *)long long buf = 67110402;
      *(_DWORD *)BOOL v31 = v15;
      *(_WORD *)&v31[4] = 2082;
      *(void *)&void v31[6] = v16;
      __int16 v32 = 2082;
      uint64_t v33 = v17;
      __int16 v34 = 1024;
      int v35 = 1510;
      __int16 v36 = 2114;
      uint64_t v37 = v19;
      __int16 v38 = 2114;
      id v39 = v3;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Removing XPC connection for %{public}@ - %{public}@", buf, 0x36u);
    }
    kdebug_trace();
    uint64_t v20 = NFSharedSignpostLog();
    if (os_signpost_enabled(v20))
    {
      int v21 = [v3 NF_userInfo];
      __int16 v22 = [v21 objectForKeyedSubscript:@"ClientName"];
      *(_DWORD *)long long buf = 138412290;
      *(void *)BOOL v31 = v22;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v20, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "XPC_DISCONNECT", "removing XPC connection for %@", buf, 0xCu);
    }
    BOOL v23 = [v3 userInfo];
    __int16 v24 = [v23 objectForKey:@"serviceType"];

    if (v24 && [v24 unsignedIntegerValue] == (id)2)
    {
      uint64_t v25 = (void *)a1[21];
      a1[21] = 0;
    }
    sub_100052F78(a1[9], v3);
    __int16 v26 = a1[29];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1000F3B30;
    block[3] = &unk_100301C90;
    block[4] = a1;
    id v28 = v3;
    unsigned int v29 = "didCloseXPCConnection:";
    dispatch_async(v26, block);
  }
}

id sub_1000F3B30(uint64_t a1)
{
  id v2 = *(id *)(*(void *)(a1 + 32) + 176);
  objc_sync_enter(v2);
  [*(id *)(*(void *)(a1 + 32) + 176) removeObject:*(void *)(a1 + 40)];
  objc_sync_exit(v2);

  sub_100008014(*(void *)(a1 + 32), *(void **)(a1 + 40));
  id v27 = *(id *)(*(void *)(a1 + 32) + 184);
  objc_sync_enter(v27);
  id v3 = objc_alloc((Class)NSSet);
  unsigned __int8 v4 = [*(id *)(a1 + 40) NF_userInfo];
  uint64_t v5 = [v4 objectForKeyedSubscript:@"ProxyObjects"];
  id v6 = [v3 initWithSet:v5];

  long long v32 = 0u;
  long long v33 = 0u;
  long long v30 = 0u;
  long long v31 = 0u;
  id obj = v6;
  id v7 = [obj countByEnumeratingWithState:&v30 objects:v46 count:16];
  if (v7)
  {
    uint64_t v29 = *(void *)v31;
    do
    {
      for (i = 0; i != v7; i = (char *)i + 1)
      {
        if (*(void *)v31 != v29) {
          objc_enumerationMutation(obj);
        }
        BOOL v9 = *(void **)(*((void *)&v30 + 1) + 8 * i);
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          id v10 = v9;
          if (objc_opt_respondsToSelector())
          {
            int v11 = [[*(id *)(a1 + 40) NF_userInfo];
            [v10 handleInvalidatedXPCWithConnectionUserInfo:v11];
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (Logger)
          {
            Class = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(Class)) {
              uint64_t v14 = 43;
            }
            else {
              uint64_t v14 = 45;
            }
            ClassName = object_getClassName(*(id *)(a1 + 32));
            Name = sel_getName(*(SEL *)(a1 + 48));
            id v17 = [[*(id *)(a1 + 40) NF_userInfo];
            uint64_t v18 = [v17 objectForKeyedSubscript:@"ClientName"];
            Logger(6, "%c[%{public}s %{public}s]:%i dequeueing session:%{public}@ for %{public}@", v14, ClassName, Name, 1543, v10, v18);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          CFStringRef v19 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v20 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v20)) {
              int v21 = 43;
            }
            else {
              int v21 = 45;
            }
            __int16 v22 = object_getClassName(*(id *)(a1 + 32));
            BOOL v23 = sel_getName(*(SEL *)(a1 + 48));
            __int16 v24 = [[*(id *)(a1 + 40) NF_userInfo];
            uint64_t v25 = [v24 objectForKeyedSubscript:@"ClientName"];
            *(_DWORD *)long long buf = 67110402;
            int v35 = v21;
            __int16 v36 = 2082;
            uint64_t v37 = v22;
            __int16 v38 = 2082;
            id v39 = v23;
            __int16 v40 = 1024;
            int v41 = 1543;
            __int16 v42 = 2114;
            id v43 = v10;
            __int16 v44 = 2114;
            __int16 v45 = v25;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i dequeueing session:%{public}@ for %{public}@", buf, 0x36u);
          }
          sub_1000F3F40(*(id **)(a1 + 32), v10, 0);
        }
      }
      id v7 = [obj countByEnumeratingWithState:&v30 objects:v46 count:16];
    }
    while (v7);
  }

  objc_sync_exit(v27);
  sub_10017FC34(*(void **)(a1 + 32), *(void **)(a1 + 40));
  return [*(id *)(a1 + 32) maybeStartNextSession];
}

void sub_1000F3EFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id obj)
{
}

void sub_1000F3F40(id *a1, void *a2, unsigned int a3)
{
  id v180 = a2;
  if (a1)
  {
    kdebug_trace();
    unsigned __int8 v4 = NFSharedSignpostLog();
    if (os_signpost_enabled(v4))
    {
      uint64_t v5 = [v180 sessionUID];
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v5;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SESSION_ENDED", "sessionUID=%@", buf, 0xCu);
    }
    id v6 = a1[23];
    objc_sync_enter(v6);
    id v7 = a1;
    objc_sync_enter(v7);
    BOOL v8 = *((unsigned char *)v7 + 337) == 0;
    objc_sync_exit(v7);

    if (v8) {
      goto LABEL_144;
    }
    id v9 = v180;
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      id v10 = v9;
      if ([v10 timeLimitedSession])
      {
        int v11 = *((_DWORD *)v7 + 80);
        BOOL v12 = __OFSUB__(v11, 1);
        int v13 = v11 - 1;
        if (v13 < 0 == v12) {
          *((_DWORD *)v7 + 80) = v13;
        }
      }
      if (v7[14] == v10 && [v10 didStart] && objc_msgSend(v10, "uiShown"))
      {
        if ([v10 uiActivated])
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (Logger)
          {
            Class = object_getClass(v7);
            if (class_isMetaClass(Class)) {
              uint64_t v16 = 43;
            }
            else {
              uint64_t v16 = 45;
            }
            ClassName = object_getClassName(v7);
            Name = sel_getName("_dequeueHelperReaderSession:");
            CFStringRef v19 = [v10 sessionUID];
            Logger(6, "%c[%{public}s %{public}s]:%i Suspend until UI invalidation handler executes for session %@", v16, ClassName, Name, 2131, v19);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v20 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            int v21 = object_getClass(v7);
            if (class_isMetaClass(v21)) {
              int v22 = 43;
            }
            else {
              int v22 = 45;
            }
            BOOL v23 = object_getClassName(v7);
            __int16 v24 = sel_getName("_dequeueHelperReaderSession:");
            uint64_t v25 = [v10 sessionUID];
            *(_DWORD *)long long buf = 67110146;
            *(_DWORD *)&uint8_t buf[4] = v22;
            *(_WORD *)&uint8_t buf[8] = 2082;
            *(void *)&buf[10] = v23;
            *(_WORD *)&buf[18] = 2082;
            *(void *)&buf[20] = v24;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = 2131;
            *(_WORD *)&buf[34] = 2112;
            *(void *)&buf[36] = v25;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Suspend until UI invalidation handler executes for session %@", buf, 0x2Cu);
          }
          v7[38] = (char *)v7[38] + 1;
          [v7[51] suspend];
        }
        else
        {
          v7[38] = (char *)v7[38] + 1;
          [v7[51] suspend];
          __int16 v26 = [v10 sessionUID];
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v27 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v27)
          {
            id v28 = object_getClass(v7);
            if (class_isMetaClass(v28)) {
              uint64_t v29 = 43;
            }
            else {
              uint64_t v29 = 45;
            }
            long long v30 = object_getClassName(v7);
            long long v31 = sel_getName("_dequeueHelperReaderSession:");
            v27(6, "%c[%{public}s %{public}s]:%i Suspend reader activity for %fs (session %@)", v29, v30, v31, 2137, 0x3FF8000000000000, v26);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          long long v32 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
          {
            long long v33 = object_getClass(v7);
            if (class_isMetaClass(v33)) {
              int v34 = 43;
            }
            else {
              int v34 = 45;
            }
            int v35 = object_getClassName(v7);
            __int16 v36 = sel_getName("_dequeueHelperReaderSession:");
            *(_DWORD *)long long buf = 67110402;
            *(_DWORD *)&uint8_t buf[4] = v34;
            *(_WORD *)&uint8_t buf[8] = 2082;
            *(void *)&buf[10] = v35;
            *(_WORD *)&buf[18] = 2082;
            *(void *)&buf[20] = v36;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = 2137;
            *(_WORD *)&buf[34] = 2048;
            *(void *)&buf[36] = 0x3FF8000000000000;
            *(_WORD *)&buf[44] = 2112;
            *(void *)&buf[46] = v26;
            _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Suspend reader activity for %fs (session %@)", buf, 0x36u);
          }

          dispatch_time_t v37 = dispatch_time(0, 1500000000);
          __int16 v38 = v7[29];
          *(void *)long long buf = _NSConcreteStackBlock;
          *(void *)&uint8_t buf[8] = 3221225472;
          *(void *)&uint8_t buf[16] = sub_1000F9730;
          *(void *)&buf[24] = &unk_100301C90;
          *(void *)&buf[40] = v26;
          *(void *)&unsigned char buf[48] = "_dequeueHelperReaderSession:";
          *(void *)&buf[32] = v7;
          id v39 = v26;
          dispatch_after(v37, v38, buf);
        }
      }
    }
    if (v7[14] != v9)
    {
      if ([a1[23] containsObject:v9])
      {
        [a1[23] removeObject:v9];
        id v40 = objc_alloc((Class)NSError);
        int v41 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v185 = NSLocalizedDescriptionKey;
        __int16 v42 = +[NSString stringWithUTF8String:"Aborted"];
        unint64_t v186 = v42;
        id v43 = +[NSDictionary dictionaryWithObjects:&v186 forKeys:&v185 count:1];
        id v44 = [v40 initWithDomain:v41 code:3 userInfo:v43];
        [v9 didEndSession:v44];
      }
      else if ([v7[24] containsObject:v9])
      {
        [v7[24] removeObject:v9];
        id v46 = objc_alloc((Class)NSError);
        int v41 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v183 = NSLocalizedDescriptionKey;
        BOOL v47 = +[NSString stringWithUTF8String:"Aborted"];
        uint64_t v184 = v47;
        CFStringRef v48 = +[NSDictionary dictionaryWithObjects:&v184 forKeys:&v183 count:1];
        id v49 = [v46 initWithDomain:v41 code:3 userInfo:v48];
        [v9 didEndSession:v49];
      }
      else if ([v9 isFeatureSupported:4])
      {
        id v52 = objc_alloc((Class)NSError);
        int v53 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v181 = NSLocalizedDescriptionKey;
        __int16 v54 = +[NSString stringWithUTF8String:"Aborted"];
        unsigned int v182 = v54;
        uint64_t v55 = +[NSDictionary dictionaryWithObjects:&v182 forKeys:&v181 count:1];
        id v56 = [v52 initWithDomain:v53 code:3 userInfo:v55];
        [v9 didEndSession:v56];

        int v41 = v9;
        id v57 = v7[2];
        unsigned int v58 = [v57 containsFieldDetectSession:v41];

        id v59 = v7[2];
        [v59 removeFieldDetectSession:v41];

        if (v7[14]) {
          unsigned int v60 = 0;
        }
        else {
          unsigned int v60 = v58;
        }
        if (v60 == 1) {
          [v7 maybeStartNextSession];
        }
      }
      else
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        unsigned int v119 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v119)
        {
          uint64_t v120 = object_getClass(v7);
          if (class_isMetaClass(v120)) {
            uint64_t v121 = 43;
          }
          else {
            uint64_t v121 = 45;
          }
          uint64_t v122 = object_getClassName(v7);
          BOOL v123 = sel_getName("_dequeueSession:startNextSession:");
          v119(4, "%c[%{public}s %{public}s]:%i Session is not active or queued", v121, v122, v123, 2371);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v41 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
        {
          uint64_t v124 = object_getClass(v7);
          if (class_isMetaClass(v124)) {
            int v125 = 43;
          }
          else {
            int v125 = 45;
          }
          int v126 = object_getClassName(v7);
          int v127 = sel_getName("_dequeueSession:startNextSession:");
          *(_DWORD *)long long buf = 67109890;
          *(_DWORD *)&uint8_t buf[4] = v125;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = v126;
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v127;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = 2371;
          _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session is not active or queued", buf, 0x22u);
        }
      }

LABEL_127:
      [v9 releaseObjects];
      if (!v7[14] && ![a1[23] count]) {
        sub_1000EA4BC(v7, 0);
      }
      sub_1001DCE6C((uint64_t)v7);
      id v128 = v7[51];
      [v128 releaseECPOption:[v9 backgroundTagReadEcpOption]];

      if ([v9 backgroundTagReadEcpOption] == (id)1 && !v7[14])
      {
        id v129 = v7[51];
        unsigned int v130 = [v129 isActive];

        if (v130)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v131 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v131)
          {
            uint64_t v132 = object_getClass(v7);
            if (class_isMetaClass(v132)) {
              uint64_t v133 = 43;
            }
            else {
              uint64_t v133 = 45;
            }
            uint64_t v134 = object_getClassName(v7);
            int v135 = sel_getName("_dequeueSession:startNextSession:");
            v131(6, "%c[%{public}s %{public}s]:%i Refresh background tag reading to update VAS", v133, v134, v135, 2388);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          BOOL v136 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v136, OS_LOG_TYPE_DEFAULT))
          {
            BOOL v137 = object_getClass(v7);
            if (class_isMetaClass(v137)) {
              int v138 = 43;
            }
            else {
              int v138 = 45;
            }
            v139 = object_getClassName(v7);
            int v140 = sel_getName("_dequeueSession:startNextSession:");
            *(_DWORD *)long long buf = 67109890;
            *(_DWORD *)&uint8_t buf[4] = v138;
            *(_WORD *)&uint8_t buf[8] = 2082;
            *(void *)&buf[10] = v139;
            *(_WORD *)&buf[18] = 2082;
            *(void *)&buf[20] = v140;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = 2388;
            _os_log_impl((void *)&_mh_execute_header, v136, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Refresh background tag reading to update VAS", buf, 0x22u);
          }

          [v7 maybeStartNextSession];
        }
      }
LABEL_144:
      objc_sync_exit(v6);

      goto LABEL_145;
    }
    unsigned int v45 = [v9 conformsToProtocol:&OBJC_PROTOCOL___NFContactlessPaymentSessionInterface];
    objc_opt_class();
    char isKindOfClass = objc_opt_isKindOfClass();
    unsigned int v176 = v45;
    if ((unint64_t)[a1[23] count] <= 1 && (uint64_t v50 = v7[3]) != 0)
    {
      BOOL v51 = v50[17] == 1 || *((unsigned __int8 *)v50 + 170) != 0;
      BOOL v178 = v51;
    }
    else
    {
      BOOL v178 = 0;
    }
    double v61 = sub_1000E9CB0((uint64_t)v7);
    sub_1000EE58C(v7, v61);
    id v62 = v9;
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0 && v7[14] == v62)
    {
      uint64_t v63 = [v62 hostCardEmulationLog];
      id v64 = v7[25];
      v7[25] = (id)v63;
    }
    id v65 = v62;
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      *((unsigned char *)v7 + 345) = 0;
    }

    id v66 = v65;
    int v177 = [v66 sessionUID];
    objc_opt_class();
    int v67 = objc_opt_isKindOfClass();
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      int v68 = 1;
    }
    else
    {
      objc_opt_class();
      int v68 = objc_opt_isKindOfClass();
    }
    objc_opt_class();
    int v69 = objc_opt_isKindOfClass();
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      uint64_t v70 = [v66 suspendOnFieldList];
      BOOL v71 = [v70 count] != 0;
    }
    else
    {
      BOOL v71 = 0;
    }
    if (((v67 | v68 | v69) & 1) != 0 || v71)
    {
      v7[38] = (char *)v7[38] + 1;
      [v7[51] suspend];
      if (v71) {
        double v72 = 1.0;
      }
      else {
        double v72 = 4.0;
      }
      if (NFIsInternalBuild())
      {
        id v73 = [objc_alloc((Class)NSUserDefaults) initWithSuiteName:@"com.apple.stockholm"];
        int v74 = [v73 objectForKey:@"seReaderSessionToBGTagReaderDelay"];

        if (v74)
        {
          [v73 floatForKey:@"seReaderSessionToBGTagReaderDelay"];
          double v72 = v75;
          if (v75 > 10.0)
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            BOOL v76 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
            if (v76)
            {
              id v77 = object_getClass(v7);
              if (class_isMetaClass(v77)) {
                uint64_t v78 = 43;
              }
              else {
                uint64_t v78 = 45;
              }
              uint64_t v174 = object_getClassName(v7);
              int v79 = sel_getName("_dequeueHelperSessionAffectingBackgroundTagReading:");
              v76(4, "%c[%{public}s %{public}s]:%i seReaderSessionToBGTagReaderDelay (%fs) is too large - using %fs instead", v78, v174, v79, 2263, *(void *)&v72, 0x4024000000000000);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v80 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
            {
              BOOL v81 = object_getClass(v7);
              if (class_isMetaClass(v81)) {
                int v82 = 43;
              }
              else {
                int v82 = 45;
              }
              uint64_t v83 = object_getClassName(v7);
              id v84 = sel_getName("_dequeueHelperSessionAffectingBackgroundTagReading:");
              *(_DWORD *)long long buf = 67110402;
              *(_DWORD *)&uint8_t buf[4] = v82;
              *(_WORD *)&uint8_t buf[8] = 2082;
              *(void *)&buf[10] = v83;
              *(_WORD *)&buf[18] = 2082;
              *(void *)&buf[20] = v84;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = 2263;
              *(_WORD *)&buf[34] = 2048;
              *(double *)&buf[36] = v72;
              *(_WORD *)&buf[44] = 2048;
              *(void *)&buf[46] = 0x4024000000000000;
              _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i seReaderSessionToBGTagReaderDelay (%fs) is too large - using %fs instead", buf, 0x36u);
            }

            double v72 = 10.0;
          }
        }
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v85 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v85)
      {
        int v86 = object_getClass(v7);
        if (class_isMetaClass(v86)) {
          uint64_t v87 = 43;
        }
        else {
          uint64_t v87 = 45;
        }
        id v88 = object_getClassName(v7);
        id v89 = sel_getName("_dequeueHelperSessionAffectingBackgroundTagReading:");
        v85(6, "%c[%{public}s %{public}s]:%i Suspend reader activity for %fs (session %@)", v87, v88, v89, 2269, *(void *)&v72, v177);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v90 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v91 = object_getClass(v7);
        if (class_isMetaClass(v91)) {
          int v92 = 43;
        }
        else {
          int v92 = 45;
        }
        uint64_t v93 = object_getClassName(v7);
        __int16 v94 = sel_getName("_dequeueHelperSessionAffectingBackgroundTagReading:");
        *(_DWORD *)long long buf = 67110402;
        *(_DWORD *)&uint8_t buf[4] = v92;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = v93;
        *(_WORD *)&buf[18] = 2082;
        *(void *)&buf[20] = v94;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 2269;
        *(_WORD *)&buf[34] = 2048;
        *(double *)&buf[36] = v72;
        *(_WORD *)&buf[44] = 2112;
        *(void *)&buf[46] = v177;
        _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Suspend reader activity for %fs (session %@)", buf, 0x36u);
      }

      dispatch_time_t v95 = dispatch_time(0, (uint64_t)(v72 * 1000000000.0));
      uint64_t v96 = v7[29];
      *(void *)long long buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 3221225472;
      *(void *)&uint8_t buf[16] = sub_1000F98CC;
      *(void *)&buf[24] = &unk_100301C90;
      *(void *)&buf[32] = v7;
      *(void *)&unsigned char buf[48] = "_dequeueHelperSessionAffectingBackgroundTagReading:";
      *(void *)&buf[40] = v177;
      dispatch_after(v95, v96, buf);
    }
    uint64_t v97 = v7[46];
    if (v97) {
      v97[221] = 0;
    }
    id v98 = objc_alloc((Class)NSError);
    int v99 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v188 = NSLocalizedDescriptionKey;
    int v100 = +[NSString stringWithUTF8String:"Aborted"];
    unsigned int v189 = v100;
    id v101 = +[NSDictionary dictionaryWithObjects:&v189 forKeys:&v188 count:1];
    id v102 = [v98 initWithDomain:v99 code:3 userInfo:v101];
    [v66 didEndSession:v102];

    id v103 = v7[14];
    v7[14] = 0;

    sub_1001EA7D0(v7);
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    v104 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v104)
    {
      unsigned int v105 = object_getClass(v7);
      if (class_isMetaClass(v105)) {
        uint64_t v106 = 43;
      }
      else {
        uint64_t v106 = 45;
      }
      id v107 = object_getClassName(v7);
      int v108 = sel_getName("_dequeueSession:startNextSession:");
      v104(6, "%c[%{public}s %{public}s]:%i startNextSession=%d,_systemWillSleep=%d,_powerCycleAfterThisSession=%d,nextIsExpress=%d", v106, v107, v108, 2316, a3, *((unsigned __int8 *)v7 + 344), *((unsigned __int8 *)v7 + 348), v178);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    BOOL v109 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v109, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v110 = object_getClass(v7);
      if (class_isMetaClass(v110)) {
        int v111 = 43;
      }
      else {
        int v111 = 45;
      }
      BOOL v112 = object_getClassName(v7);
      int v113 = sel_getName("_dequeueSession:startNextSession:");
      int v114 = *((unsigned __int8 *)v7 + 344);
      int v115 = *((unsigned __int8 *)v7 + 348);
      *(_DWORD *)long long buf = 67110914;
      *(_DWORD *)&uint8_t buf[4] = v111;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = v112;
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = v113;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 2316;
      *(_WORD *)&buf[34] = 1024;
      *(_DWORD *)&buf[36] = a3;
      *(_WORD *)&buf[40] = 1024;
      *(_DWORD *)&buf[42] = v114;
      *(_WORD *)&buf[46] = 1024;
      *(_DWORD *)&unsigned char buf[48] = v115;
      *(_WORD *)&buf[52] = 1024;
      *(_DWORD *)&buf[54] = v178;
      _os_log_impl((void *)&_mh_execute_header, v109, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i startNextSession=%d,_systemWillSleep=%d,_powerCycleAfterThisSession=%d,nextIsExpress=%d", buf, 0x3Au);
    }

    if ([a1[23] count])
    {
      if (a3)
      {
        uint64_t v116 = [a1[23] objectAtIndex:0];
        unsigned int v117 = [v116 conformsToProtocol:&OBJC_PROTOCOL___NFContactlessPaymentSessionInterface];
      }
      else
      {
        unsigned int v117 = 0;
      }
      LODWORD(v118) = 1;
    }
    else
    {
      uint64_t v118 = v7[3];
      if (v118)
      {
        if (v118[17] == 1)
        {
          LODWORD(v118) = 1;
          unsigned int v117 = 1;
        }
        else
        {
          LODWORD(v118) = *((unsigned __int8 *)v118 + 170) != 0;
          unsigned int v117 = v118;
        }
      }
      else
      {
        unsigned int v117 = 0;
      }
    }
    if (*((unsigned char *)v7 + 348)) {
      int v141 = (int)v118;
    }
    else {
      int v141 = 0;
    }
    id v142 = [v7[48] siliconName];
    id v143 = [v7[48] siliconName];
    int v144 = v176 & v117 ^ 1;
    if ((unint64_t)v142 >= 7) {
      int v144 = 0;
    }
    if ((unint64_t)v143 <= 0xD && v141 | v144)
    {
      *((unsigned char *)v7 + 348) = 0;
      uint64_t v145 = +[NSUserDefaults standardUserDefaults];
      unsigned int v146 = [v145 BOOLForKey:@"DontPowerCycle"];

      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v147 = NFLogGetLogger();
      uint64_t v148 = (void (*)(uint64_t, const char *, ...))v147;
      if (v146)
      {
        if (v147)
        {
          uint64_t v149 = object_getClass(v7);
          if (class_isMetaClass(v149)) {
            uint64_t v150 = 43;
          }
          else {
            uint64_t v150 = 45;
          }
          BOOL v151 = object_getClassName(v7);
          uint64_t v152 = sel_getName("_dequeueHelperPowerCycle:startNextSession:");
          v148(4, "%c[%{public}s %{public}s]:%i Defaults override of power cycling SE", v150, v151, v152, 2199);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v153 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v153, OS_LOG_TYPE_ERROR))
        {
          v154 = object_getClass(v7);
          if (class_isMetaClass(v154)) {
            int v155 = 43;
          }
          else {
            int v155 = 45;
          }
          char v156 = object_getClassName(v7);
          id v157 = sel_getName("_dequeueHelperPowerCycle:startNextSession:");
          *(_DWORD *)long long buf = 67109890;
          *(_DWORD *)&uint8_t buf[4] = v155;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = v156;
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v157;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = 2199;
          _os_log_impl((void *)&_mh_execute_header, v153, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Defaults override of power cycling SE", buf, 0x22u);
        }
      }
      else
      {
        if (v147)
        {
          uint64_t v158 = object_getClass(v7);
          if (class_isMetaClass(v158)) {
            uint64_t v159 = 43;
          }
          else {
            uint64_t v159 = 45;
          }
          v160 = object_getClassName(v7);
          unsigned int v161 = sel_getName("_dequeueHelperPowerCycle:startNextSession:");
          v148(6, "%c[%{public}s %{public}s]:%i Restarting eSE", v159, v160, v161, 2201);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v162 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v162, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v163 = object_getClass(v7);
          if (class_isMetaClass(v163)) {
            int v164 = 43;
          }
          else {
            int v164 = 45;
          }
          BOOL v165 = object_getClassName(v7);
          uint64_t v166 = sel_getName("_dequeueHelperPowerCycle:startNextSession:");
          *(_DWORD *)long long buf = 67109890;
          *(_DWORD *)&uint8_t buf[4] = v164;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = v165;
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v166;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = 2201;
          _os_log_impl((void *)&_mh_execute_header, v162, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Restarting eSE", buf, 0x22u);
        }

        id v167 = [v7 powerCycleSE:v7[47]];
      }
    }
    sub_10004BB60((uint64_t)v7[3], 0);
    if (v178)
    {
      sub_100040348((uint64_t)v7[3]);
    }
    else if ((isKindOfClass & 1) == 0)
    {
      sub_100046E80((uint64_t)v7[3]);
    }
    id v168 = [v66 parentToken];

    if (v168)
    {
      if (sub_1001DEEB4(v7, v66) && (a3 & 1) == 0) {
        goto LABEL_184;
      }
    }
    else if (!a3)
    {
LABEL_184:
      char v169 = 0;
      goto LABEL_188;
    }
    if (!*((unsigned char *)v7 + 344))
    {
      [v7 maybeStartNextSession];
      char v169 = 1;
      goto LABEL_189;
    }
    char v169 = 1;
LABEL_188:
    sub_1001E9B3C((uint64_t)v7);
LABEL_189:
    unsigned int v170 = sub_1000A49F8(v7);
    id v171 = sub_1000A43A4(v7, v170);
    if ((v169 & 1) == 0) {
      sub_1000F8978(v7, 0);
    }
    sub_1002114AC(v7[46], @"Session");
    if (*((unsigned char *)v7 + 344))
    {
      uint64_t v172 = v7[3];
      if (!v172 || !v172[172])
      {
        v173 = NFSharedSignpostLog();
        if (os_signpost_enabled(v173))
        {
          *(_WORD *)long long buf = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v173, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_dequeueSession: allowing to sleep", (const char *)&unk_100286819, buf, 2u);
        }

        [v7[7] allowSleep];
      }
    }
    goto LABEL_127;
  }
LABEL_145:
}

void sub_1000F5628(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000F5958(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1000F596C(uint64_t a1)
{
  uint64_t v1 = a1;
  if (a1)
  {
    id v2 = *(id *)(a1 + 184);
    objc_sync_enter(v2);
    uint64_t v1 = *(void *)(v1 + 112) != 0;
    objc_sync_exit(v2);
  }
  return v1;
}

void sub_1000F59BC(uint64_t a1)
{
  if (a1)
  {
    char v6 = 0;
    id v2 = *(id **)(a1 + 368);
    id v5 = 0;
    sub_100216618(v2, &v6, &v5);
    id v3 = v5;
    if (v6)
    {
      if (objc_opt_respondsToSelector()) {
        [*(id *)(a1 + 112) handleFieldChanged:1];
      }
      if (v3 && (objc_opt_respondsToSelector() & 1) != 0)
      {
        id v4 = [v3 copy];
        [v4 setCachedBeforeRFReset:1];
        [*(id *)(a1 + 112) handleFieldNotification:v4];
      }
      if ([v3 chFieldType] != (id)1) {
        +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:&off_100323050];
      }
    }
  }
}

void *sub_1000F5AA4(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = v6;
  if (a1)
  {
    unsigned int v8 = 1;
    if (([v6 isEqualToString:@"seld"] & 1) == 0
      && ([v7 isEqualToString:@"seserviced"] & 1) == 0
      && ([v7 isEqualToString:@"asd"] & 1) == 0)
    {
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) == 0) {
        unsigned int v8 = 0;
      }
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v10 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("regularSessionsAllowed:clientName:");
      uint64_t v21 = objc_opt_class();
      uint64_t v15 = 45;
      if (isMetaClass) {
        uint64_t v15 = 43;
      }
      v10(6, "%c[%{public}s %{public}s]:%i Checking for %{public}@ session for %{public}@", v15, ClassName, Name, 2462, v21, v7);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v16 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      id v17 = object_getClass(a1);
      if (class_isMetaClass(v17)) {
        int v18 = 43;
      }
      else {
        int v18 = 45;
      }
      *(_DWORD *)long long buf = 67110402;
      int v23 = v18;
      __int16 v24 = 2082;
      uint64_t v25 = object_getClassName(a1);
      __int16 v26 = 2082;
      id v27 = sel_getName("regularSessionsAllowed:clientName:");
      __int16 v28 = 1024;
      int v29 = 2462;
      __int16 v30 = 2114;
      id v31 = (id)objc_opt_class();
      __int16 v32 = 2114;
      long long v33 = v7;
      id v19 = v31;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Checking for %{public}@ session for %{public}@", buf, 0x36u);
    }
    a1 = (void *)sub_1000F8268((void **)a1, v8);
  }

  return a1;
}

void sub_1000F5D0C(uint64_t a1)
{
  id v2 = *(void **)(*(void *)(a1 + 32) + 376);
  id v21 = 0;
  id v3 = sub_1000A695C(v2, 5, &v21);
  id v4 = v21;

  if (v3) {
    BOOL v5 = 1;
  }
  else {
    BOOL v5 = v4 == 0;
  }
  if (v5)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v7 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v11 = 45;
      if (isMetaClass) {
        uint64_t v11 = 43;
      }
      v7(6, "%c[%{public}s %{public}s]:%i Failed to log Applet FTA CDS Log", v11, ClassName, Name, 1757);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v18 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v12 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v12)) {
        int v13 = 43;
      }
      else {
        int v13 = 45;
      }
      uint64_t v14 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v15 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)long long buf = 67109890;
      int v23 = v13;
      __int16 v24 = 2082;
      uint64_t v25 = v14;
      __int16 v26 = 2082;
      id v27 = v15;
      __int16 v28 = 1024;
      int v29 = 1757;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Failed to log Applet FTA CDS Log", buf, 0x22u);
    }
  }
  else
  {
    id v16 = [v4 copy];
    uint64_t v17 = *(void *)(a1 + 32);
    int v18 = *(NSObject **)(v17 + 208);
    *(void *)(v17 + 208) = v16;
  }

  id v19 = NFSharedSignpostLog();
  if (os_signpost_enabled(v19))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v19, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "DUMP_LOGS_BOOTUP", (const char *)&unk_100286819, buf, 2u);
  }
}

void sub_1000F5F34(uint64_t a1, int a2)
{
  if ((byte_100347430 & 1) == 0)
  {
    id v4 = *(unsigned char **)(a1 + 88);
    if (v4)
    {
      sub_100200B8C(v4);
      id v4 = *(unsigned char **)(a1 + 88);
    }
    if (sub_100201550(v4))
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        id v6 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass((id)a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName((id)a1);
        Name = sel_getName("_updateSEPairingSynchronously:");
        uint64_t v10 = 45;
        if (isMetaClass) {
          uint64_t v10 = 43;
        }
        v6(6, "%c[%{public}s %{public}s]:%i ", v10, ClassName, Name, 1774);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v11 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        BOOL v12 = object_getClass((id)a1);
        if (class_isMetaClass(v12)) {
          int v13 = 43;
        }
        else {
          int v13 = 45;
        }
        *(_DWORD *)long long buf = 67109890;
        *(_DWORD *)&uint8_t buf[4] = v13;
        *(_WORD *)BOOL v47 = 2082;
        *(void *)&v47[2] = object_getClassName((id)a1);
        *(_WORD *)&v47[10] = 2082;
        *(void *)&v47[12] = sel_getName("_updateSEPairingSynchronously:");
        *(_WORD *)&v47[20] = 1024;
        *(_DWORD *)&v47[22] = 1774;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
      }

      sub_1000F1EC4(a1, a2);
      *(void *)long long buf = 0;
      *(void *)BOOL v47 = buf;
      *(void *)&v47[8] = 0x3032000000;
      *(void *)&v47[16] = sub_10000B858;
      *(void *)&v47[24] = sub_1000F2378;
      id v48 = 0;
      if ([*(id *)(a1 + 376) pairedState]) {
        goto LABEL_30;
      }
      if (a2)
      {
        __int16 v30 = _NSConcreteStackBlock;
        uint64_t v31 = 3221225472;
        __int16 v32 = sub_1000F2800;
        long long v33 = &unk_100304498;
        uint64_t v34 = a1;
        int v35 = buf;
        uint64_t v14 = +[NFRoutingConfig embeddedWiredModeWithFD:0];
        int v15 = sub_1000F23D8((void **)a1, &v30, @"Negotiate Auth Keys", v14);

        if (v15 && !*(void *)(*(void *)v47 + 40)) {
          goto LABEL_30;
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v16 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v16)
        {
          uint64_t v17 = object_getClass((id)a1);
          if (class_isMetaClass(v17)) {
            uint64_t v18 = 43;
          }
          else {
            uint64_t v18 = 45;
          }
          id v19 = object_getClassName((id)a1);
          uint64_t v20 = sel_getName("_negotiatePerBootAuthKeysSynchronously:");
          v16(3, "%c[%{public}s %{public}s]:%i Failed: %{public}@", v18, v19, v20, 1232, *(void *)(*(void *)v47 + 40));
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v21 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          int v22 = object_getClass((id)a1);
          if (class_isMetaClass(v22)) {
            int v23 = 43;
          }
          else {
            int v23 = 45;
          }
          __int16 v24 = object_getClassName((id)a1);
          uint64_t v25 = sel_getName("_negotiatePerBootAuthKeysSynchronously:");
          uint64_t v26 = *(void *)(*(void *)v47 + 40);
          *(_DWORD *)__int16 v36 = 67110146;
          int v37 = v23;
          __int16 v38 = 2082;
          id v39 = v24;
          __int16 v40 = 2082;
          int v41 = v25;
          __int16 v42 = 1024;
          int v43 = 1232;
          __int16 v44 = 2114;
          uint64_t v45 = v26;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed: %{public}@", v36, 0x2Cu);
        }
      }
      else
      {
        uint64_t v27 = *(void *)(a1 + 232);
        id v21 = +[NFRoutingConfig embeddedWiredMode];
        __int16 v30 = _NSConcreteStackBlock;
        uint64_t v31 = 3221225472;
        __int16 v32 = sub_1000F2858;
        long long v33 = &unk_100301C68;
        uint64_t v34 = a1;
        id v28 = +[_NFBuiltinSession createSessionWithWorkQueue:v27 routing:v21 sessionQueuer:a1 didStartWork:&v30];
      }

LABEL_30:
      _Block_object_dispose(buf, 8);

      byte_100347430 = 1;
    }
  }
}

void sub_1000F63B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_1000F63F0(id *a1, void *a2)
{
  id v199 = a2;
  if (a1
    && (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)a1) == 2
     || -[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)a1) == 5))
  {
    id obj = a1[23];
    objc_sync_enter(obj);
    kdebug_trace();
    id v3 = NFSharedSignpostLog();
    if (os_signpost_enabled(v3))
    {
      *(_WORD *)long long buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v3, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "MAYBE_START_NEXT_SESSION", (const char *)&unk_100286819, buf, 2u);
    }

    id v4 = a1;
    objc_sync_enter(v4);
    BOOL v5 = *((unsigned char *)v4 + 337) == 0;
    objc_sync_exit(v4);

    if (v5) {
      goto LABEL_35;
    }
    if (*((unsigned char *)v4 + 356))
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (Logger)
      {
        Class = object_getClass(v4);
        if (class_isMetaClass(Class)) {
          uint64_t v8 = 43;
        }
        else {
          uint64_t v8 = 45;
        }
        ClassName = object_getClassName(v4);
        Name = sel_getName("maybeStartNextSessionOnField:");
        Logger(6, "%c[%{public}s %{public}s]:%i User-initated shutdown started, abort further processing", v8, ClassName, Name, 1806);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v11 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_30;
      }
      BOOL v12 = object_getClass(v4);
      if (class_isMetaClass(v12)) {
        int v13 = 43;
      }
      else {
        int v13 = 45;
      }
      uint64_t v14 = object_getClassName(v4);
      int v15 = sel_getName("maybeStartNextSessionOnField:");
      *(_DWORD *)long long buf = 67109890;
      int v211 = v13;
      __int16 v212 = 2082;
      char v213 = v14;
      __int16 v214 = 2082;
      uint64_t v215 = v15;
      __int16 v216 = 1024;
      int v217 = 1806;
      id v16 = "%c[%{public}s %{public}s]:%i User-initated shutdown started, abort further processing";
      goto LABEL_29;
    }
    if (*((unsigned char *)v4 + 344))
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v17 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v17)
      {
        uint64_t v18 = object_getClass(v4);
        if (class_isMetaClass(v18)) {
          uint64_t v19 = 43;
        }
        else {
          uint64_t v19 = 45;
        }
        uint64_t v20 = object_getClassName(v4);
        id v21 = sel_getName("maybeStartNextSessionOnField:");
        v17(6, "%c[%{public}s %{public}s]:%i System is going to sleep - delaying start of new session", v19, v20, v21, 1812);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v11 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_30;
      }
      int v22 = object_getClass(v4);
      if (class_isMetaClass(v22)) {
        int v23 = 43;
      }
      else {
        int v23 = 45;
      }
      __int16 v24 = object_getClassName(v4);
      uint64_t v25 = sel_getName("maybeStartNextSessionOnField:");
      *(_DWORD *)long long buf = 67109890;
      int v211 = v23;
      __int16 v212 = 2082;
      char v213 = v24;
      __int16 v214 = 2082;
      uint64_t v215 = v25;
      __int16 v216 = 1024;
      int v217 = 1812;
      id v16 = "%c[%{public}s %{public}s]:%i System is going to sleep - delaying start of new session";
LABEL_29:
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v16, buf, 0x22u);
      goto LABEL_30;
    }
    uint64_t v27 = sub_1000A49F8(v4);
    sub_1000A3D08((uint64_t)v4, v27);
    if (v4[14] || (sub_1000F5F34((uint64_t)v4, 1), v4[14]))
    {
LABEL_35:
      uint64_t v26 = 0;
      goto LABEL_36;
    }
    uint64_t v26 = 0;
LABEL_39:
    uint64_t v197 = v26;
    if (![a1[23] count])
    {
      if (!v4[14])
      {
LABEL_168:
        uint64_t v148 = v4[3];
        if (v148 && v148[172])
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v149 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v149)
          {
            uint64_t v150 = object_getClass(v4);
            if (class_isMetaClass(v150)) {
              uint64_t v151 = 43;
            }
            else {
              uint64_t v151 = 45;
            }
            uint64_t v152 = object_getClassName(v4);
            v153 = sel_getName("maybeStartNextSessionOnField:");
            v149(6, "%c[%{public}s %{public}s]:%i Express Mode in progress - skip routing config", v151, v152, v153, 1934);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v11 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
          {
            v154 = object_getClass(v4);
            if (class_isMetaClass(v154)) {
              int v155 = 43;
            }
            else {
              int v155 = 45;
            }
            char v156 = object_getClassName(v4);
            id v157 = sel_getName("maybeStartNextSessionOnField:");
            *(_DWORD *)long long buf = 67109890;
            int v211 = v155;
            __int16 v212 = 2082;
            char v213 = v156;
            __int16 v214 = 2082;
            uint64_t v215 = v157;
            __int16 v216 = 1024;
            int v217 = 1934;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Express Mode in progress - skip routing config", buf, 0x22u);
          }
        }
        else
        {
          sub_1000F7FA0((uint64_t)v4);
          sub_1001E9B3C((uint64_t)v4);
          if (sub_1000F8268(v4, 1u)) {
            [v4[51] start];
          }
          if (*((unsigned char *)v4 + 339))
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v158 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
            if (v158)
            {
              uint64_t v159 = object_getClass(v4);
              if (class_isMetaClass(v159)) {
                uint64_t v160 = 43;
              }
              else {
                uint64_t v160 = 45;
              }
              unsigned int v161 = object_getClassName(v4);
              uint64_t v162 = sel_getName("maybeStartNextSessionOnField:");
              v158(5, "%c[%{public}s %{public}s]:%i Restarting driver for defaults changes", v160, v161, v162, 1954);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v163 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v163, OS_LOG_TYPE_DEFAULT))
            {
              int v164 = object_getClass(v4);
              if (class_isMetaClass(v164)) {
                int v165 = 43;
              }
              else {
                int v165 = 45;
              }
              uint64_t v166 = object_getClassName(v4);
              id v167 = sel_getName("maybeStartNextSessionOnField:");
              *(_DWORD *)long long buf = 67109890;
              int v211 = v165;
              __int16 v212 = 2082;
              char v213 = v166;
              __int16 v214 = 2082;
              uint64_t v215 = v167;
              __int16 v216 = 1024;
              int v217 = 1954;
              _os_log_impl((void *)&_mh_execute_header, v163, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Restarting driver for defaults changes", buf, 0x22u);
            }

            sub_100212274(v4[46]);
            *((unsigned char *)v4 + 339) = 0;
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            id v168 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
            if (v168)
            {
              char v169 = object_getClass(v4);
              if (class_isMetaClass(v169)) {
                uint64_t v170 = 43;
              }
              else {
                uint64_t v170 = 45;
              }
              id v171 = object_getClassName(v4);
              uint64_t v172 = sel_getName("maybeStartNextSessionOnField:");
              v168(5, "%c[%{public}s %{public}s]:%i Done restarting driver for defaults changes", v170, v171, v172, 1957);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v173 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v173, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v174 = object_getClass(v4);
              if (class_isMetaClass(v174)) {
                int v175 = 43;
              }
              else {
                int v175 = 45;
              }
              unsigned int v176 = object_getClassName(v4);
              int v177 = sel_getName("maybeStartNextSessionOnField:");
              *(_DWORD *)long long buf = 67109890;
              int v211 = v175;
              __int16 v212 = 2082;
              char v213 = v176;
              __int16 v214 = 2082;
              uint64_t v215 = v177;
              __int16 v216 = 1024;
              int v217 = 1957;
              _os_log_impl((void *)&_mh_execute_header, v173, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Done restarting driver for defaults changes", buf, 0x22u);
            }
          }
          long long v202 = 0u;
          long long v203 = 0u;
          long long v200 = 0u;
          long long v201 = 0u;
          id v178 = v4[24];
          id v179 = [v178 countByEnumeratingWithState:&v200 objects:v205 count:16];
          if (v179)
          {
            uint64_t v180 = *(void *)v201;
            while (2)
            {
              for (i = 0; i != v179; i = (char *)i + 1)
              {
                if (*(void *)v201 != v180) {
                  objc_enumerationMutation(v178);
                }
                unsigned int v182 = *(void **)(*((void *)&v200 + 1) + 8 * i);
                NSErrorUserInfoKey v183 = [v182 startOnFieldList];
                if (v183)
                {
                  uint64_t v184 = [v182 parentToken];
                  if (v184)
                  {
                  }
                  else
                  {
                    objc_opt_class();
                    char isKindOfClass = objc_opt_isKindOfClass();

                    if (isKindOfClass)
                    {
                      id v187 = v182;
                      uint64_t v11 = [v187 effectiveECPFrame];

                      goto LABEL_218;
                    }
                  }
                }
              }
              id v179 = [v178 countByEnumeratingWithState:&v200 objects:v205 count:16];
              if (v179) {
                continue;
              }
              break;
            }
          }
          uint64_t v11 = 0;
LABEL_218:

          sub_1000F8464(v4, v11);
          NSErrorUserInfoKey v188 = [v4 lastKnownRoutingConfig];
          unsigned int v189 = sub_1000F86B8((uint64_t)v4, (uint64_t)[v188 fieldDetectType], v11);

          id v190 = [v4 lastKnownRoutingConfig];
          unsigned int v191 = [v189 isEquivalentRouting:v190];

          if (!v191
            || ([v4 lastKnownRoutingConfig],
                id v192 = objc_claimAutoreleasedReturnValue(),
                unsigned int v193 = [v192 fdOn],
                int v194 = sub_1000A49F8(v4),
                v192,
                ((v193 ^ v194) & 1) != 0))
          {
            uint64_t v195 = sub_10020EC8C(v4[46], @"StartSessionOFF", 1uLL);
            BOOL v196 = v195 == 0;

            if (v196)
            {
              sub_1000F8978(v4, v11);
              sub_1002114AC(v4[46], @"StartSessionOFF");
            }
          }
        }
        goto LABEL_31;
      }
LABEL_32:
      uint64_t v26 = v197;
      goto LABEL_36;
    }
    id v28 = [a1[23] objectAtIndex:0];
    while (1)
    {
      if (![a1[23] count])
      {
        int v29 = 0;
LABEL_100:

        id v81 = v4[14];
        v4[14] = v29;

        id v82 = v4[14];
        if (!v82) {
          goto LABEL_168;
        }
        uint64_t v83 = v4[3];
        if (v83 && v83[172] && [v82 forceExpressExit])
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v84 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v84)
          {
            id v85 = object_getClass(v4);
            if (class_isMetaClass(v85)) {
              uint64_t v86 = 43;
            }
            else {
              uint64_t v86 = 45;
            }
            uint64_t v87 = object_getClassName(v4);
            id v88 = sel_getName("maybeStartNextSessionOnField:");
            v84(6, "%c[%{public}s %{public}s]:%i forcing exiting express mode", v86, v87, v88, 1842);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v89 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT))
          {
            id v90 = object_getClass(v4);
            if (class_isMetaClass(v90)) {
              int v91 = 43;
            }
            else {
              int v91 = 45;
            }
            int v92 = object_getClassName(v4);
            uint64_t v93 = sel_getName("maybeStartNextSessionOnField:");
            *(_DWORD *)long long buf = 67109890;
            int v211 = v91;
            __int16 v212 = 2082;
            char v213 = v92;
            __int16 v214 = 2082;
            uint64_t v215 = v93;
            __int16 v216 = 1024;
            int v217 = 1842;
            _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i forcing exiting express mode", buf, 0x22u);
          }

          id v94 = v4[3];
          if (v94) {
            sub_10004CD44(v94, 0);
          }
        }
        if ([v4[14] priority]) {
          sub_1001DCE6C((uint64_t)v4);
        }
        if (([v4[14] allowsBackgroundMode] & 1) != 0
          || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0)
          || (dispatch_time_t v95 = (id *)v4[9],
              [v4[14] connection],
              uint64_t v96 = objc_claimAutoreleasedReturnValue(),
              LODWORD(v95) = sub_1000532C0(v95, v96),
              v96,
              !v95))
        {
          [v4[14] holdAssertion];
          uint64_t v117 = sub_10020EC8C(v4[46], @"Session", [v4[14] isSessionSEOnly] ^ 1);

          [v4[51] stop];
          if (v117)
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v118 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
            if (v118)
            {
              unsigned int v119 = object_getClass(v4);
              if (class_isMetaClass(v119)) {
                uint64_t v120 = 43;
              }
              else {
                uint64_t v120 = 45;
              }
              uint64_t v121 = object_getClassName(v4);
              uint64_t v122 = sel_getName("maybeStartNextSessionOnField:");
              v118(3, "%c[%{public}s %{public}s]:%i Failed to open session with SE : %@", v120, v121, v122, 1905, v117);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v11 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            {
              BOOL v123 = object_getClass(v4);
              if (class_isMetaClass(v123)) {
                int v124 = 43;
              }
              else {
                int v124 = 45;
              }
              int v125 = object_getClassName(v4);
              int v126 = sel_getName("maybeStartNextSessionOnField:");
              *(_DWORD *)long long buf = 67110146;
              int v211 = v124;
              __int16 v212 = 2082;
              char v213 = v125;
              __int16 v214 = 2082;
              uint64_t v215 = v126;
              __int16 v216 = 1024;
              int v217 = 1905;
              __int16 v218 = 2112;
              uint64_t v219 = v117;
              _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session with SE : %@", buf, 0x2Cu);
            }
            uint64_t v197 = (void *)v117;
LABEL_158:

            int v141 = +[NSString stringWithFormat:@"Failed to open session. Error = %@", v197];
            sub_1001990A4((uint64_t)NFBugCapture, @"Failed to start the session", v141, 0);

            id v142 = v4[14];
            id v143 = objc_alloc((Class)NSError);
            int v111 = +[NSString stringWithUTF8String:"nfcd"];
            v206[0] = NSLocalizedDescriptionKey;
            BOOL v112 = +[NSString stringWithUTF8String:"Stack Error"];
            v207[0] = v112;
            v207[1] = v197;
            v206[1] = NSUnderlyingErrorKey;
            v206[2] = @"Line";
            v207[2] = &off_10031B778;
            v206[3] = @"Method";
            id v113 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("maybeStartNextSessionOnField:")];
            v207[3] = v113;
            v206[4] = NSDebugDescriptionErrorKey;
            id v114 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("maybeStartNextSessionOnField:"), 1912];
            v207[4] = v114;
            int v115 = +[NSDictionary dictionaryWithObjects:v207 forKeys:v206 count:5];
            id v116 = [v143 initWithDomain:v111 code:15 userInfo:v115];
            [v142 didStartSession:v116];
            goto LABEL_159;
          }
          [v4[14] willStartSession];
          id v127 = v4[14];
          uint64_t v11 = [v127 initialECPConfig];

          if ([v11 length]) {
            [v4 configureECPPolling:v11];
          }
          id v128 = [v4[14] initialRoutingConfigWithField:v199];
          uint64_t v197 = [v4 setRoutingConfig:v128];

          if (v197)
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            id v129 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
            if (v129)
            {
              unsigned int v130 = object_getClass(v4);
              if (class_isMetaClass(v130)) {
                uint64_t v131 = 43;
              }
              else {
                uint64_t v131 = 45;
              }
              uint64_t v132 = object_getClassName(v4);
              uint64_t v133 = sel_getName("maybeStartNextSessionOnField:");
              v129(3, "%c[%{public}s %{public}s]:%i Failed to set initial routing for session : %{public}@", v131, v132, v133, 1898, v197);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v134 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v134, OS_LOG_TYPE_ERROR))
            {
              int v135 = object_getClass(v4);
              if (class_isMetaClass(v135)) {
                int v136 = 43;
              }
              else {
                int v136 = 45;
              }
              BOOL v137 = object_getClassName(v4);
              int v138 = sel_getName("maybeStartNextSessionOnField:");
              *(_DWORD *)long long buf = 67110146;
              int v211 = v136;
              __int16 v212 = 2082;
              char v213 = v137;
              __int16 v214 = 2082;
              uint64_t v215 = v138;
              __int16 v216 = 1024;
              int v217 = 1898;
              __int16 v218 = 2114;
              uint64_t v219 = (uint64_t)v197;
              _os_log_impl((void *)&_mh_execute_header, v134, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set initial routing for session : %{public}@", buf, 0x2Cu);
            }

            v139 = +[NFRoutingConfig routingOff];
            id v140 = [v4 setRoutingConfig:v139];

            sub_1002114AC(v4[46], @"Session");
            goto LABEL_158;
          }
          unint64_t v186 = v4[29];
          block[0] = _NSConcreteStackBlock;
          block[1] = 3221225472;
          block[2] = sub_1000F7E70;
          block[3] = &unk_100301C68;
          block[4] = v4;
          dispatch_async(v186, block);
          sub_1001EA77C(v4);
LABEL_30:
          uint64_t v197 = 0;
LABEL_31:

          goto LABEL_32;
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v97 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v97)
        {
          id v98 = object_getClass(v4);
          if (class_isMetaClass(v98)) {
            uint64_t v99 = 43;
          }
          else {
            uint64_t v99 = 45;
          }
          int v100 = object_getClassName(v4);
          id v101 = sel_getName("maybeStartNextSessionOnField:");
          id v102 = [v4[14] clientName];
          v97(6, "%c[%{public}s %{public}s]:%i Session is not allowed because %{public}@ is in background mode", v99, v100, v101, 1854, v102);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v103 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT))
        {
          v104 = object_getClass(v4);
          if (class_isMetaClass(v104)) {
            int v105 = 43;
          }
          else {
            int v105 = 45;
          }
          uint64_t v106 = object_getClassName(v4);
          id v107 = sel_getName("maybeStartNextSessionOnField:");
          int v108 = [v4[14] clientName];
          *(_DWORD *)long long buf = 67110146;
          int v211 = v105;
          __int16 v212 = 2082;
          char v213 = v106;
          __int16 v214 = 2082;
          uint64_t v215 = v107;
          __int16 v216 = 1024;
          int v217 = 1854;
          __int16 v218 = 2114;
          uint64_t v219 = (uint64_t)v108;
          _os_log_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Session is not allowed because %{public}@ is in background mode", buf, 0x2Cu);
        }
        id v109 = v4[14];
        id v110 = objc_alloc((Class)NSError);
        int v111 = +[NSString stringWithUTF8String:"nfcd"];
        v208[0] = NSLocalizedDescriptionKey;
        BOOL v112 = +[NSString stringWithUTF8String:"Invalid State"];
        v209[0] = v112;
        v209[1] = &off_10031B760;
        v208[1] = @"Line";
        v208[2] = @"Method";
        id v113 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("maybeStartNextSessionOnField:")];
        v209[2] = v113;
        v208[3] = NSDebugDescriptionErrorKey;
        id v114 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("maybeStartNextSessionOnField:"), 1855];
        v209[3] = v114;
        int v115 = +[NSDictionary dictionaryWithObjects:v209 forKeys:v208 count:4];
        id v116 = [v110 initWithDomain:v111 code:12 userInfo:v115];
        [v109 didStartSession:v116];
LABEL_159:

        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          if ([v4[14] timeLimitedSession])
          {
            int v144 = *((_DWORD *)v4 + 80);
            BOOL v145 = __OFSUB__(v144, 1);
            int v146 = v144 - 1;
            if (v146 < 0 == v145) {
              *((_DWORD *)v4 + 80) = v146;
            }
          }
        }
        [v4[14] releaseObjects];
        id v147 = v4[14];
        v4[14] = 0;

        if (![a1[23] count]) {
          sub_1000EA4BC(v4, 0);
        }
        uint64_t v26 = v197;
        if (v4[14])
        {
LABEL_36:

          objc_sync_exit(obj);
          goto LABEL_37;
        }
        goto LABEL_39;
      }
      int v29 = [a1[23] objectAtIndex:0];
      [a1[23] removeObjectAtIndex:0];
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v30 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v30)
      {
        uint64_t v31 = object_getClass(v4);
        if (class_isMetaClass(v31)) {
          uint64_t v32 = 43;
        }
        else {
          uint64_t v32 = 45;
        }
        long long v33 = object_getClassName(v4);
        uint64_t v34 = sel_getName("copyNextDequeuableSession");
        int v35 = [v29 sessionUID];
        v30(6, "%c[%{public}s %{public}s]:%i Next queued session=%{public}@", v32, v33, v34, 1674, v35);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v36 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
      {
        int v37 = object_getClass(v4);
        if (class_isMetaClass(v37)) {
          int v38 = 43;
        }
        else {
          int v38 = 45;
        }
        id v39 = object_getClassName(v4);
        __int16 v40 = sel_getName("copyNextDequeuableSession");
        int v41 = [v29 sessionUID];
        *(_DWORD *)long long buf = 67110146;
        int v211 = v38;
        __int16 v212 = 2082;
        char v213 = v39;
        __int16 v214 = 2082;
        uint64_t v215 = v40;
        __int16 v216 = 1024;
        int v217 = 1674;
        __int16 v218 = 2114;
        uint64_t v219 = (uint64_t)v41;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Next queued session=%{public}@", buf, 0x2Cu);
      }
      uint64_t v42 = objc_opt_class();
      if (v42 == objc_opt_class())
      {
        id v59 = (id *)v4[46];
        if (v59)
        {
          if ([v59[11] readerModeProtectionActive]) {
            break;
          }
        }
        if (v4[38]) {
          break;
        }
      }
      uint64_t v43 = objc_opt_class();
      if (v43 != objc_opt_class())
      {
        __int16 v44 = [v29 clientName];
        unsigned __int8 v45 = sub_1000F5AA4(v4, v29, v44);

        if ((v45 & 1) == 0)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          int v69 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v69)
          {
            uint64_t v70 = object_getClass(v4);
            if (class_isMetaClass(v70)) {
              uint64_t v71 = 43;
            }
            else {
              uint64_t v71 = 45;
            }
            double v72 = object_getClassName(v4);
            id v73 = sel_getName("copyNextDequeuableSession");
            v69(6, "%c[%{public}s %{public}s]:%i Only seshat session allowed currently, enqueuing for later", v71, v72, v73, 1683);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v52 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
          {
            int v74 = object_getClass(v4);
            if (class_isMetaClass(v74)) {
              int v75 = 43;
            }
            else {
              int v75 = 45;
            }
            BOOL v76 = object_getClassName(v4);
            id v77 = sel_getName("copyNextDequeuableSession");
            *(_DWORD *)long long buf = 67109890;
            int v211 = v75;
            __int16 v212 = 2082;
            char v213 = v76;
            __int16 v214 = 2082;
            uint64_t v215 = v77;
            __int16 v216 = 1024;
            int v217 = 1683;
            id v57 = v52;
            unsigned int v58 = "%c[%{public}s %{public}s]:%i Only seshat session allowed currently, enqueuing for later";
            goto LABEL_91;
          }
LABEL_92:

          [a1[23] addObject:v29];
          int v29 = 0;
          goto LABEL_93;
        }
      }
      id v46 = v4[3];
      if (v46 && v46[172] && ([v29 forceExpressExit] & 1) == 0)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        BOOL v47 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v47)
        {
          id v48 = object_getClass(v4);
          if (class_isMetaClass(v48)) {
            uint64_t v49 = 43;
          }
          else {
            uint64_t v49 = 45;
          }
          uint64_t v50 = object_getClassName(v4);
          BOOL v51 = sel_getName("copyNextDequeuableSession");
          v47(6, "%c[%{public}s %{public}s]:%i Express Mode in progress - delaying start of session", v49, v50, v51, 1689);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v52 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
        {
          int v53 = object_getClass(v4);
          if (class_isMetaClass(v53)) {
            int v54 = 43;
          }
          else {
            int v54 = 45;
          }
          uint64_t v55 = object_getClassName(v4);
          id v56 = sel_getName("copyNextDequeuableSession");
          *(_DWORD *)long long buf = 67109890;
          int v211 = v54;
          __int16 v212 = 2082;
          char v213 = v55;
          __int16 v214 = 2082;
          uint64_t v215 = v56;
          __int16 v216 = 1024;
          int v217 = 1689;
          id v57 = v52;
          unsigned int v58 = "%c[%{public}s %{public}s]:%i Express Mode in progress - delaying start of session";
          goto LABEL_91;
        }
        goto LABEL_92;
      }
LABEL_93:
      if ([a1[23] count])
      {
        uint64_t v78 = [a1[23] objectAtIndex:0];
        BOOL v79 = v78 == v28;

        int v80 = v29 || v79;
        if (v80 != 1) {
          continue;
        }
      }
      goto LABEL_100;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    unsigned int v60 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v60)
    {
      double v61 = object_getClass(v4);
      if (class_isMetaClass(v61)) {
        uint64_t v62 = 43;
      }
      else {
        uint64_t v62 = 45;
      }
      uint64_t v63 = object_getClassName(v4);
      id v64 = sel_getName("copyNextDequeuableSession");
      v60(6, "%c[%{public}s %{public}s]:%i Reader sessions not ready for dequeue, enqueuing for later", v62, v63, v64, 1677);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v52 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
    {
      id v65 = object_getClass(v4);
      if (class_isMetaClass(v65)) {
        int v66 = 43;
      }
      else {
        int v66 = 45;
      }
      int v67 = object_getClassName(v4);
      int v68 = sel_getName("copyNextDequeuableSession");
      *(_DWORD *)long long buf = 67109890;
      int v211 = v66;
      __int16 v212 = 2082;
      char v213 = v67;
      __int16 v214 = 2082;
      uint64_t v215 = v68;
      __int16 v216 = 1024;
      int v217 = 1677;
      id v57 = v52;
      unsigned int v58 = "%c[%{public}s %{public}s]:%i Reader sessions not ready for dequeue, enqueuing for later";
LABEL_91:
      _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, v58, buf, 0x22u);
    }
    goto LABEL_92;
  }
LABEL_37:
}

void sub_1000F7DB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id obj)
{
}

void sub_1000F7E70(uint64_t a1)
{
  kdebug_trace();
  id v2 = NFSharedSignpostLog();
  if (os_signpost_enabled(v2))
  {
    id v3 = [*(id *)(*(void *)(a1 + 32) + 112) sessionUID];
    int v7 = 138412290;
    uint64_t v8 = v3;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v2, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SESSION_STARTED", "sessionUID=%@", (uint8_t *)&v7, 0xCu);
  }
  [*(id *)(*(void *)(a1 + 32) + 112) didStartSession:0];
  unsigned __int8 v4 = [*(id *)(*(void *)(a1 + 32) + 112) shouldHandleSecureElementTransactionData];
  uint64_t v5 = *(void *)(a1 + 32);
  uint64_t v6 = *(void *)(v5 + 368);
  if (v6)
  {
    *(unsigned char *)(v6 + 221) = v4;
    uint64_t v5 = *(void *)(a1 + 32);
  }
  sub_1000F59BC(v5);
  sub_1001DD0C8(*(void *)(a1 + 32));
}

void sub_1000F7FA0(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 354))
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass((id)a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName((id)a1);
      Name = sel_getName("_handleBackgroundTasks");
      uint64_t v7 = 45;
      if (isMetaClass) {
        uint64_t v7 = 43;
      }
      v3(4, "%c[%{public}s %{public}s]:%i FailForward disabled - are you sure you want this?!", v7, ClassName, Name, 2008);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v8 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      id v9 = object_getClass((id)a1);
      if (class_isMetaClass(v9)) {
        int v10 = 43;
      }
      else {
        int v10 = 45;
      }
      *(_DWORD *)long long buf = 67109890;
      int v24 = v10;
      __int16 v25 = 2082;
      uint64_t v26 = object_getClassName((id)a1);
      __int16 v27 = 2082;
      id v28 = sel_getName("_handleBackgroundTasks");
      __int16 v29 = 1024;
      int v30 = 2008;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i FailForward disabled - are you sure you want this?!", buf, 0x22u);
    }
  }
  else
  {
    uint64_t v11 = sub_100218E94(*(void **)(a1 + 368));

    if (v11)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v12 = NFLogGetLogger();
      if (v12)
      {
        int v13 = (void (*)(uint64_t, const char *, ...))v12;
        uint64_t v14 = object_getClass((id)a1);
        BOOL v15 = class_isMetaClass(v14);
        id v16 = object_getClassName((id)a1);
        int v22 = sel_getName("_handleBackgroundTasks");
        uint64_t v17 = 45;
        if (v15) {
          uint64_t v17 = 43;
        }
        v13(3, "%c[%{public}s %{public}s]:%i Failed to attempt Fail Forward recovery - bailing.", v17, v16, v22, 2003);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v18 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        uint64_t v19 = object_getClass((id)a1);
        if (class_isMetaClass(v19)) {
          int v20 = 43;
        }
        else {
          int v20 = 45;
        }
        *(_DWORD *)long long buf = 67109890;
        int v24 = v20;
        __int16 v25 = 2082;
        uint64_t v26 = object_getClassName((id)a1);
        __int16 v27 = 2082;
        id v28 = sel_getName("_handleBackgroundTasks");
        __int16 v29 = 1024;
        int v30 = 2003;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to attempt Fail Forward recovery - bailing.", buf, 0x22u);
      }

      exit(-1);
    }
  }
}

uint64_t sub_1000F8268(void **a1, unsigned int a2)
{
  BOOL v4 = sub_100201550(a1[11]);
  BOOL v5 = sub_1002015A0(a1[11]);
  uint64_t result = 1;
  if ((v4 & ~a2 & 1) == 0 && (a2 & v4 & v5 & 1) == 0)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v8 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("sessionsAllowedForTimeConsumingOperations:");
      uint64_t v11 = 45;
      if (isMetaClass) {
        uint64_t v11 = 43;
      }
      v8(6, "%c[%{public}s %{public}s]:%i sessionTimeConsuming=%d allowSimpleSessions=%d allowTimeConsumingSessions=%d", v11, ClassName, Name, 2479, a2, v4, v5);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v12 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = object_getClass(a1);
      if (class_isMetaClass(v13)) {
        int v14 = 43;
      }
      else {
        int v14 = 45;
      }
      *(_DWORD *)long long buf = 67110658;
      int v18 = v14;
      __int16 v19 = 2082;
      int v20 = object_getClassName(a1);
      __int16 v21 = 2082;
      int v22 = sel_getName("sessionsAllowedForTimeConsumingOperations:");
      __int16 v23 = 1024;
      int v24 = 2479;
      __int16 v25 = 1024;
      unsigned int v26 = a2;
      __int16 v27 = 1024;
      BOOL v28 = v4;
      __int16 v29 = 1024;
      BOOL v30 = v5;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i sessionTimeConsuming=%d allowSimpleSessions=%d allowTimeConsumingSessions=%d", buf, 0x34u);
    }

    if (a2) {
      return v5;
    }
    else {
      return v4;
    }
  }
  return result;
}

void sub_1000F8464(void *a1, void *a2)
{
  id v3 = a2;
  if ([v3 length])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      BOOL v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("_updateECPRandomOverride:");
      uint64_t v8 = 45;
      if (isMetaClass) {
        uint64_t v8 = 43;
      }
      v5(6, "%c[%{public}s %{public}s]:%i %@", v8, ClassName, Name, 8541, v3);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = object_getClass(a1);
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      *(_DWORD *)long long buf = 67110146;
      int v21 = v11;
      __int16 v22 = 2082;
      __int16 v23 = object_getClassName(a1);
      __int16 v24 = 2082;
      __int16 v25 = sel_getName("_updateECPRandomOverride:");
      __int16 v26 = 1024;
      int v27 = 8541;
      __int16 v28 = 2112;
      id v29 = v3;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %@", buf, 0x2Cu);
    }

    CFStringRef v18 = @"ECPData";
    id v19 = v3;
    uint64_t v12 = +[NSDictionary dictionaryWithObjects:&v19 forKeys:&v18 count:1];
    int v13 = +[NFFieldNotification notificationWithDictionary:v12];

    int v14 = [(os_unfair_lock_s *)v13 chRandomData];
    if (v14)
    {
      sub_100183960();
      BOOL v15 = (os_unfair_lock_s *)objc_claimAutoreleasedReturnValue();
      sub_100183A80(v15, v14);
    }
  }
  else
  {
    sub_100183960();
    int v13 = (os_unfair_lock_s *)objc_claimAutoreleasedReturnValue();
    sub_100183D60(v13);
  }
}

id sub_1000F86B8(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (a1)
  {
    BOOL v6 = sub_100044DB8(*(void *)(a1 + 24));
    if ([*(id *)(a1 + 384) hasReaderModeSupport]
      && (NFProductIsDevBoard() & 1) == 0
      && (NFProductIsNED() & 1) == 0
      && [(id)a1 nfcRadioEnabled:0 showUIPopup:0] == (id)1
      && NFIsUIBuild()
      && (!NFProductIsDevBoard() || *(void *)(a1 + 280) == 1)
      && [*(id *)(a1 + 408) isActive]
      && (sub_1000F8268((void **)a1, 1u) & 1) != 0)
    {
      uint64_t v7 = *(void *)(a1 + 368);
      if (!v7)
      {
        id v22 = v5;
        goto LABEL_13;
      }
      unsigned __int8 v8 = [*(id *)(v7 + 88) readerModeProtectionActive];
      id v9 = v5;
      if ((v8 & 1) == 0)
      {
LABEL_13:
        int v10 = [*(id *)(a1 + 408) getECPFrame];

        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          uint64_t v12 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass((id)a1);
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName((id)a1);
          Name = sel_getName("defaultRoutingConfig:ecp:");
          uint64_t v15 = 45;
          if (isMetaClass) {
            uint64_t v15 = 43;
          }
          v12(6, "%c[%{public}s %{public}s]:%i Setting ecp frame for background tag scanning: %{public}@", v15, ClassName, Name, 8572, v10);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v16 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v17 = object_getClass((id)a1);
          if (class_isMetaClass(v17)) {
            int v18 = 43;
          }
          else {
            int v18 = 45;
          }
          *(_DWORD *)long long buf = 67110146;
          int v26 = v18;
          __int16 v27 = 2082;
          __int16 v28 = object_getClassName((id)a1);
          __int16 v29 = 2082;
          BOOL v30 = sel_getName("defaultRoutingConfig:ecp:");
          __int16 v31 = 1024;
          int v32 = 8572;
          __int16 v33 = 2114;
          uint64_t v34 = v10;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Setting ecp frame for background tag scanning: %{public}@", buf, 0x2Cu);
        }

        uint64_t v19 = 1;
        goto LABEL_25;
      }
    }
    else
    {
      id v9 = v5;
    }
    int v10 = v9;
    uint64_t v19 = 0;
LABEL_25:
    int v20 = +[NFRoutingConfig wantsLPCD:v19 expressForEmbedded:v6 hostCardEmulation:0 fieldDetect:a2 lpcdEcpFrame:v10];

    goto LABEL_26;
  }
  int v20 = 0;
LABEL_26:

  return v20;
}

void sub_1000F8978(void *a1, void *a2)
{
  id v3 = a2;
  unsigned int v4 = sub_1000A49F8(a1);
  id v5 = sub_1000F86B8((uint64_t)a1, v4, v3);

  BOOL v6 = [a1 setRoutingConfig:v5];

  if ([v6 code] == (id)47)
  {
    uint64_t v7 = [a1 defaultRoutingConfig:3];
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v9 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("enableDefaultRoutingWithECP:");
      uint64_t v12 = 45;
      if (isMetaClass) {
        uint64_t v12 = 43;
      }
      v9(6, "%c[%{public}s %{public}s]:%i Retrying to set routing with mode %{public}@", v12, ClassName, Name, 2028, v7);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v13 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = object_getClass(a1);
      if (class_isMetaClass(v14)) {
        int v15 = 43;
      }
      else {
        int v15 = 45;
      }
      *(_DWORD *)long long buf = 67110146;
      int v20 = v15;
      __int16 v21 = 2082;
      id v22 = object_getClassName(a1);
      __int16 v23 = 2082;
      __int16 v24 = sel_getName("enableDefaultRoutingWithECP:");
      __int16 v25 = 1024;
      int v26 = 2028;
      __int16 v27 = 2114;
      __int16 v28 = v7;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Retrying to set routing with mode %{public}@", buf, 0x2Cu);
    }

    id v16 = [a1 setRoutingConfig:v7];
  }
}

id sub_1000F8B98(id a1, void *a2, void *a3, uint64_t a4, void *a5, void *a6, unsigned char *a7, void *a8)
{
  id v64 = a2;
  id v14 = a3;
  id v65 = a5;
  id v63 = a6;
  if (a1)
  {
    int v15 = [_NFReaderSession alloc];
    uint64_t v16 = *((void *)a1 + 29);
    id v17 = [v14 uiMode];
    id v18 = [v14 sessionType];
    uint64_t v19 = [v14 initialScanText];
    int v20 = [(_NFReaderSession *)v15 initWithRemoteObject:v64 workQueue:v16 whitelist:v65 serviceType:a4 showSharingUI:v17 coreNFCSessionType:v18 scanText:v19];

    if (!v20)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        BOOL v30 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("_queueHelperReaderSession:sessionConfig:serviceType:whitelist:xpcConnection:isFirstInQueue:outSession:");
        uint64_t v34 = 45;
        if (isMetaClass) {
          uint64_t v34 = 43;
        }
        v30(3, "%c[%{public}s %{public}s]:%i Session creation failed.", v34, ClassName, Name, 2050);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v35 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        __int16 v36 = object_getClass(a1);
        if (class_isMetaClass(v36)) {
          int v37 = 43;
        }
        else {
          int v37 = 45;
        }
        *(_DWORD *)long long buf = 67109890;
        int v74 = v37;
        __int16 v75 = 2082;
        BOOL v76 = object_getClassName(a1);
        __int16 v77 = 2082;
        uint64_t v78 = sel_getName("_queueHelperReaderSession:sessionConfig:serviceType:whitelist:xpcConnection:isFirstInQueue:outSession:");
        __int16 v79 = 1024;
        int v80 = 2050;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session creation failed.", buf, 0x22u);
      }

      id v38 = objc_alloc((Class)NSError);
      id v39 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v71 = NSLocalizedDescriptionKey;
      __int16 v40 = +[NSString stringWithUTF8String:"Unexpected Result"];
      double v72 = v40;
      int v41 = +[NSDictionary dictionaryWithObjects:&v72 forKeys:&v71 count:1];
      a1 = [v38 initWithDomain:v39 code:13 userInfo:v41];

      goto LABEL_36;
    }
    [(_NFSession *)v20 setQueue:a1];
    [(_NFXPCSession *)v20 setConnection:v63];
    [(_NFSession *)v20 setUid:0xFFFFFFFFLL];
    __int16 v21 = sub_1001AED74();
    [(_NFReaderSession *)v20 setPowerConsumptionReporter:v21];

    if ([v14 uiMode])
    {
      v66[0] = _NSConcreteStackBlock;
      v66[1] = 3221225472;
      v66[2] = sub_1000F9370;
      v66[3] = &unk_100304510;
      v66[4] = a1;
      v66[5] = "_queueHelperReaderSession:sessionConfig:serviceType:whitelist:xpcConnection:isFirstInQueue:outSession:";
      [(_NFReaderSession *)v20 setUiInvalidationHandler:v66];
    }
    [(_NFSession *)v20 setServiceType:a4];
    [(_NFReaderSession *)v20 setDriverWrapper:*((void *)a1 + 46)];
    *a7 = 0;
    uint64_t v22 = *((void *)a1 + 46);
    if (v22 && [*(id *)(v22 + 88) readerModeProtectionActive])
    {
      id v23 = objc_alloc((Class)NSError);
      __int16 v24 = +[NSString stringWithUTF8String:"nfcd"];
      v69[0] = NSLocalizedDescriptionKey;
      __int16 v25 = +[NSString stringWithUTF8String:"Reader mode temporarily disabled"];
      v70[0] = v25;
      v70[1] = &off_10031B790;
      v69[1] = @"Line";
      v69[2] = @"Method";
      id v26 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_queueHelperReaderSession:sessionConfig:serviceType:whitelist:xpcConnection:isFirstInQueue:outSession:")];
      v70[2] = v26;
      v69[3] = NSDebugDescriptionErrorKey;
      id v27 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_queueHelperReaderSession:sessionConfig:serviceType:whitelist:xpcConnection:isFirstInQueue:outSession:"), 2082];
      v70[3] = v27;
      __int16 v28 = +[NSDictionary dictionaryWithObjects:v70 forKeys:v69 count:4];
      a1 = [v23 initWithDomain:v24 code:47 userInfo:v28];
    }
    else
    {
      id v42 = *((id *)a1 + 23);
      objc_sync_enter(v42);
      if ([(_NFReaderSession *)v20 timeLimitedSession])
      {
        int v43 = *((_DWORD *)a1 + 80);
        if (v43 >= 1)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          __int16 v44 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v44)
          {
            unsigned __int8 v45 = object_getClass(a1);
            if (class_isMetaClass(v45)) {
              uint64_t v46 = 43;
            }
            else {
              uint64_t v46 = 45;
            }
            BOOL v47 = object_getClassName(a1);
            id v48 = sel_getName("_queueHelperReaderSession:sessionConfig:serviceType:whitelist:xpcConnection:isFirstInQueue:outSession:");
            v44(6, "%c[%{public}s %{public}s]:%i MaxReaderSession reached.", v46, v47, v48, 2090);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v49 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v50 = object_getClass(a1);
            if (class_isMetaClass(v50)) {
              int v51 = 43;
            }
            else {
              int v51 = 45;
            }
            id v52 = object_getClassName(a1);
            int v53 = sel_getName("_queueHelperReaderSession:sessionConfig:serviceType:whitelist:xpcConnection:isFirstInQueue:outSession:");
            *(_DWORD *)long long buf = 67109890;
            int v74 = v51;
            __int16 v75 = 2082;
            BOOL v76 = v52;
            __int16 v77 = 2082;
            uint64_t v78 = v53;
            __int16 v79 = 1024;
            int v80 = 2090;
            _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i MaxReaderSession reached.", buf, 0x22u);
          }

          id v54 = objc_alloc((Class)NSError);
          uint64_t v55 = +[NSString stringWithUTF8String:"nfcd"];
          NSErrorUserInfoKey v67 = NSLocalizedDescriptionKey;
          id v56 = +[NSString stringWithUTF8String:"Busy"];
          int v68 = v56;
          id v57 = +[NSDictionary dictionaryWithObjects:&v68 forKeys:&v67 count:1];
          a1 = [v54 initWithDomain:v55 code:2 userInfo:v57];

          objc_sync_exit(v42);
          goto LABEL_36;
        }
        *((_DWORD *)a1 + 80) = v43 + 1;
      }
      unsigned int v58 = [v63 NF_userInfo];
      id v59 = [v58 objectForKeyedSubscript:@"ProxyObjects"];
      [v59 addObject:v20];

      if (*((void *)a1 + 14) || [*((id *)a1 + 23) count])
      {
        *a7 = 0;
      }
      else
      {
        *a7 = 1;
        sub_1000EA4BC(a1, 1);
      }
      [*((id *)a1 + 23) addObject:v20];
      objc_sync_exit(v42);

      a1 = 0;
      *a8 = v20;
    }
LABEL_36:
  }

  return a1;
}

void sub_1000F9348(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1000F9370(uint64_t a1, void *a2)
{
  id v3 = a2;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 40));
    int v10 = [v3 sessionUID];
    uint64_t v11 = 45;
    if (isMetaClass) {
      uint64_t v11 = 43;
    }
    v5(6, "%c[%{public}s %{public}s]:%i Got invalidation handler (session %@)", v11, ClassName, Name, 2067, v10);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v12 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v13)) {
      int v14 = 43;
    }
    else {
      int v14 = 45;
    }
    int v15 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v16 = sel_getName(*(SEL *)(a1 + 40));
    id v17 = [v3 sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v19 = v14;
    __int16 v20 = 2082;
    __int16 v21 = v15;
    __int16 v22 = 2082;
    id v23 = v16;
    __int16 v24 = 1024;
    int v25 = 2067;
    __int16 v26 = 2112;
    id v27 = v17;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Got invalidation handler (session %@)", buf, 0x2Cu);
  }
  if ([v3 didEnd]) {
    sub_1000F9554(*(void **)(a1 + 32));
  }
}

void sub_1000F9554(void *a1)
{
  if (a1)
  {
    uint64_t v2 = a1[38];
    if (v2)
    {
      a1[38] = v2 - 1;
      id v3 = (void *)a1[51];
      [v3 resume];
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        id v5 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("resumeReaderSessionStart");
        uint64_t v9 = 45;
        if (isMetaClass) {
          uint64_t v9 = 43;
        }
        v5(3, "%c[%{public}s %{public}s]:%i Suspend count underflow", v9, ClassName, Name, 8862);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v10 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        uint64_t v11 = object_getClass(a1);
        if (class_isMetaClass(v11)) {
          int v12 = 43;
        }
        else {
          int v12 = 45;
        }
        *(_DWORD *)long long buf = 67109890;
        int v15 = v12;
        __int16 v16 = 2082;
        id v17 = object_getClassName(a1);
        __int16 v18 = 2082;
        int v19 = sel_getName("resumeReaderSessionStart");
        __int16 v20 = 1024;
        int v21 = 8862;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Suspend count underflow", buf, 0x22u);
      }
    }
  }
}

void sub_1000F9730(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i Resume reader activity after expiration of %@", v8, ClassName, Name, 2141, *(void *)(a1 + 40));
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    int v12 = object_getClassName(*(id *)(a1 + 32));
    int v13 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v14 = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 67110146;
    int v16 = v11;
    __int16 v17 = 2082;
    __int16 v18 = v12;
    __int16 v19 = 2082;
    __int16 v20 = v13;
    __int16 v21 = 1024;
    int v22 = 2141;
    __int16 v23 = 2112;
    uint64_t v24 = v14;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Resume reader activity after expiration of %@", buf, 0x2Cu);
  }

  sub_1000F9554(*(void **)(a1 + 32));
}

void sub_1000F98CC(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i Resume reader activity after delay (session %@)", v8, ClassName, Name, 2273, *(void *)(a1 + 40));
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    int v12 = object_getClassName(*(id *)(a1 + 32));
    int v13 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v14 = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 67110146;
    int v16 = v11;
    __int16 v17 = 2082;
    __int16 v18 = v12;
    __int16 v19 = 2082;
    __int16 v20 = v13;
    __int16 v21 = 1024;
    int v22 = 2273;
    __int16 v23 = 2112;
    uint64_t v24 = v14;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Resume reader activity after delay (session %@)", buf, 0x2Cu);
  }

  sub_1000F9554(*(void **)(a1 + 32));
}

void sub_1000F9ECC(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
  if (Logger) {
    Logger(6, "%s:%i Unregistering key bag handler after unlock", "-[_NFHardwareManager lockStateChanged]_block_invoke", 2549);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v3 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136446466;
    id v5 = "-[_NFHardwareManager lockStateChanged]_block_invoke";
    __int16 v6 = 1024;
    int v7 = 2549;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s:%i Unregistering key bag handler after unlock", buf, 0x12u);
  }

  sub_100201390(*(void **)(*(void *)(a1 + 32) + 88));
}

id sub_1000F9FD8(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
  if (Logger) {
    Logger(6, "%s:%i Lock state changed", "-[_NFHardwareManager lockStateChanged]_block_invoke", 2557);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v3 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136446466;
    __int16 v6 = "-[_NFHardwareManager lockStateChanged]_block_invoke";
    __int16 v7 = 1024;
    int v8 = 2557;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s:%i Lock state changed", buf, 0x12u);
  }

  return [*(id *)(a1 + 32) maybeStartNextSession];
}

void sub_1000FA0E0(void *a1, int a2, uint64_t a3)
{
  if (a1)
  {
    if ((a3 & 0xFFFFFFFFFFFFFFFDLL) != 0)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        __int16 v6 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("processRestrictedModeState:os:");
        uint64_t v9 = 45;
        if (isMetaClass) {
          uint64_t v9 = 43;
        }
        v6(6, "%c[%{public}s %{public}s]:%i Ignoring restricted mode for %ld", v9, ClassName, Name, 2601, a3);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v10 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        int v11 = object_getClass(a1);
        if (class_isMetaClass(v11)) {
          int v12 = 43;
        }
        else {
          int v12 = 45;
        }
        *(_DWORD *)long long buf = 67110146;
        int v42 = v12;
        __int16 v43 = 2082;
        __int16 v44 = object_getClassName(a1);
        __int16 v45 = 2082;
        uint64_t v46 = sel_getName("processRestrictedModeState:os:");
        __int16 v47 = 1024;
        int v48 = 2601;
        __int16 v49 = 2048;
        uint64_t v50 = a3;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Ignoring restricted mode for %ld", buf, 0x2Cu);
      }
    }
    else
    {
      uint64_t v14 = a1;
      objc_sync_enter(v14);
      if (*((unsigned char *)v14 + 345))
      {
        objc_sync_exit(v14);
      }
      else
      {
        *((unsigned char *)v14 + 345) = 1;
        objc_sync_exit(v14);

        if (a2 == 1)
        {
          [v14[5] _setIsInRestrictedMode:1];
          uint64_t v15 = [v14[5] platformIdentifier];
          if (v15)
          {
            int v16 = (void *)v15;
            __int16 v17 = objc_opt_new();
            __int16 v18 = +[NSNumber numberWithUnsignedInt:sub_1000EE260((uint64_t)v14)];
            [v17 setObject:v18 forKeyedSubscript:@"hardwareType"];

            __int16 v19 = [v14 lastKnownRoutingConfig];
            __int16 v20 = +[NSNumber numberWithInt:](NSNumber, "numberWithInt:", [v19 embeddedMode] == (id)2);
            [v17 setObject:v20 forKeyedSubscript:@"contactless"];

            [v17 setObject:v16 forKeyedSubscript:@"platformIdentifier"];
            +[NFExceptionsCALogger postAnalyticsSERestrictedModeEntered:v17];
          }
        }
        if (!*((unsigned char *)v14 + 347))
        {
          *((unsigned char *)v14 + 347) = 1;
          __int16 v21 = +[NSDistributedNotificationCenter defaultCenter];
          [v21 postNotificationName:@"com.apple.nfcd.se.restricted" object:0 userInfo:0 options:3];

          int v22 = NFSharedSignpostLog();
          if (os_signpost_enabled(v22))
          {
            *(_WORD *)long long buf = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v22, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SE_RESTRICTED_NOTIFICATION", "com.apple.nfcd.se.restricted", buf, 2u);
          }
        }
        __int16 v23 = v14[3];
        if (v23 && v23[172])
        {
          sub_100040C1C(v23);
          uint64_t v24 = +[NFPowerAssertion sharedPowerAssertion];
          [v24 releasePowerAssertion:@"ExpressMode"];
        }
        id v25 = v14[29];
        __int16 v26 = +[NFRoutingConfig embeddedWiredMode];
        v39[0] = _NSConcreteStackBlock;
        v39[1] = 3221225472;
        v39[2] = sub_1000FA5C0;
        v39[3] = &unk_100301C68;
        v39[4] = v14;
        id v27 = +[_NFBuiltinSession createSessionWithWorkQueue:v25 routing:v26 sessionQueuer:v14 didStartWork:v39];
      }
      int v10 = sub_10000B134(v14);
      long long v35 = 0u;
      long long v36 = 0u;
      long long v37 = 0u;
      long long v38 = 0u;
      __int16 v28 = [v10 allValues];
      id v29 = [v28 countByEnumeratingWithState:&v35 objects:v40 count:16];
      if (v29)
      {
        id v30 = v29;
        uint64_t v31 = *(void *)v36;
        do
        {
          for (i = 0; i != v30; i = (char *)i + 1)
          {
            if (*(void *)v36 != v31) {
              objc_enumerationMutation(v28);
            }
            [*(id *)(*((void *)&v35 + 1) + 8 * i) secureElementWithIdentifier:@"embedded" didChangeRestrictedMode:1];
          }
          id v30 = [v28 countByEnumeratingWithState:&v35 objects:v40 count:16];
        }
        while (v30);
      }
    }
  }
}

void sub_1000FA5C0(uint64_t a1)
{
}

void sub_1000FA5C8(void *a1, void *a2, void *a3)
{
  id v5 = a3;
  if (a1)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      __int16 v7 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("_postEvent:identifier:additionalData:");
      uint64_t v10 = 45;
      if (isMetaClass) {
        uint64_t v10 = 43;
      }
      v7(6, "%c[%{public}s %{public}s]:%i posting notification: %s with additional data.", v10, ClassName, Name, 2692, a2);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v11 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = object_getClass(a1);
      if (class_isMetaClass(v12)) {
        int v13 = 43;
      }
      else {
        int v13 = 45;
      }
      *(_DWORD *)long long buf = 67110146;
      int v34 = v13;
      __int16 v35 = 2082;
      long long v36 = object_getClassName(a1);
      __int16 v37 = 2082;
      long long v38 = sel_getName("_postEvent:identifier:additionalData:");
      __int16 v39 = 1024;
      int v40 = 2692;
      __int16 v41 = 2080;
      id v42 = a2;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i posting notification: %s with additional data.", buf, 0x2Cu);
    }

    id v14 = [objc_alloc((Class)NSString) initWithUTF8String:a2];
    uint64_t v15 = +[NSDistributedNotificationCenter defaultCenter];
    [v15 postNotificationName:v14 object:v5 userInfo:0 options:3];

    id v16 = objc_alloc_init((Class)NSMutableDictionary);
    [v16 setObject:v14 forKeyedSubscript:@"xpcEventName"];
    [v16 setObject:v5 forKeyedSubscript:@"xpcEventSimpleString"];
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v17 = NFLogGetLogger();
    if (v17)
    {
      __int16 v18 = (void (*)(uint64_t, const char *, ...))v17;
      __int16 v19 = object_getClass(a1);
      BOOL v20 = class_isMetaClass(v19);
      id v30 = object_getClassName(a1);
      int v32 = sel_getName("_postEvent:identifier:additionalData:");
      uint64_t v21 = 45;
      if (v20) {
        uint64_t v21 = 43;
      }
      v18(6, "%c[%{public}s %{public}s]:%i XpcPayload %{public}@", v21, v30, v32, 2709, v16);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v22 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v23 = object_getClass(a1);
      if (class_isMetaClass(v23)) {
        int v24 = 43;
      }
      else {
        int v24 = 45;
      }
      id v25 = object_getClassName(a1);
      __int16 v26 = sel_getName("_postEvent:identifier:additionalData:");
      *(_DWORD *)long long buf = 67110146;
      int v34 = v24;
      __int16 v35 = 2082;
      long long v36 = v25;
      __int16 v37 = 2082;
      long long v38 = v26;
      __int16 v39 = 1024;
      int v40 = 2709;
      __int16 v41 = 2114;
      id v42 = v16;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i XpcPayload %{public}@", buf, 0x2Cu);
    }

    id v27 = +[NFSecureXPCEventPublisherManager sharedManager];
    __int16 v28 = [v27 wallet];
    [v28 sendDictionary:v16];
  }
}

void sub_1000FA94C(void *a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (a1)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      __int16 v7 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("_postEvent:objectString:");
      uint64_t v10 = 45;
      if (isMetaClass) {
        uint64_t v10 = 43;
      }
      v7(6, "%c[%{public}s %{public}s]:%i posting notification: %s", v10, ClassName, Name, 2716, a2);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v11 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = object_getClass(a1);
      if (class_isMetaClass(v12)) {
        int v13 = 43;
      }
      else {
        int v13 = 45;
      }
      *(_DWORD *)long long buf = 67110146;
      int v22 = v13;
      __int16 v23 = 2082;
      int v24 = object_getClassName(a1);
      __int16 v25 = 2082;
      __int16 v26 = sel_getName("_postEvent:objectString:");
      __int16 v27 = 1024;
      int v28 = 2716;
      __int16 v29 = 2080;
      uint64_t v30 = a2;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i posting notification: %s", buf, 0x2Cu);
    }

    id v14 = [objc_alloc((Class)NSString) initWithUTF8String:a2];
    uint64_t v15 = +[NSDistributedNotificationCenter defaultCenter];
    [v15 postNotificationName:v14 object:v5 userInfo:0 options:3];

    id v16 = +[NFSecureXPCEventPublisherManager sharedManager];
    uint64_t v17 = [v16 wallet];
    __int16 v18 = v17;
    if (v5) {
      [v17 sendSimpleEvent:v14 objectString:v5];
    }
    else {
      [v17 sendSimpleEvent:v14];
    }
  }
}

uint64_t sub_1000FAEAC(uint64_t a1, void *a2)
{
  id v3 = a2;
  unsigned int v4 = v3;
  if (a1)
  {
    if (!v3 || (objc_opt_class(), (objc_opt_isKindOfClass()))
      && ([v4 objectForKeyedSubscript:@"session.prevent.ui.popup.on.radio.disabled"],
          id v5 = objc_claimAutoreleasedReturnValue(),
          objc_opt_class(),
          char isKindOfClass = objc_opt_isKindOfClass(),
          v5,
          (isKindOfClass & 1) != 0))
    {
      __int16 v7 = [v4 objectForKeyedSubscript:@"session.prevent.ui.popup.on.radio.disabled"];
      a1 = [v7 BOOLValue] ^ 1;
    }
    else
    {
      a1 = 0;
    }
  }

  return a1;
}

BOOL sub_1000FAF70(void *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = (void *)a1[11];
  if (!v2)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      __int16 v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("_hasBeenFirstUnlocked");
      uint64_t v10 = 45;
      if (isMetaClass) {
        uint64_t v10 = 43;
      }
      v6(4, "%c[%{public}s %{public}s]:%i Not init'ed", v10, ClassName, Name, 2763);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v11 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      int v12 = object_getClass(a1);
      if (class_isMetaClass(v12)) {
        int v13 = 43;
      }
      else {
        int v13 = 45;
      }
      *(_DWORD *)long long buf = 67109890;
      int v16 = v13;
      __int16 v17 = 2082;
      __int16 v18 = object_getClassName(a1);
      __int16 v19 = 2082;
      BOOL v20 = sel_getName("_hasBeenFirstUnlocked");
      __int16 v21 = 1024;
      int v22 = 2763;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Not init'ed", buf, 0x22u);
    }

    return 0;
  }
  if (!sub_100201550(v2)) {
    return 0;
  }
  id v3 = (void *)a1[11];

  return sub_1002015A0(v3);
}

id sub_1000FB150(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v13 = (id)objc_opt_new();
    if ([v3 count])
    {
      long long v16 = 0u;
      long long v17 = 0u;
      long long v14 = 0u;
      long long v15 = 0u;
      id v4 = v3;
      id v5 = [v4 countByEnumeratingWithState:&v14 objects:v20 count:16];
      if (v5)
      {
        id v6 = v5;
        uint64_t v7 = *(void *)v15;
        do
        {
          for (i = 0; i != v6; i = (char *)i + 1)
          {
            if (*(void *)v15 != v7) {
              objc_enumerationMutation(v4);
            }
            uint64_t v9 = *(void **)(*((void *)&v14 + 1) + 8 * i);
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0 && [v9 length])
            {
              v18[0] = @"ECPData";
              v18[1] = @"IgnoreRFTechOnIsEqual";
              v19[0] = v9;
              v19[1] = &off_10031B748;
              uint64_t v10 = +[NSDictionary dictionaryWithObjects:v19 forKeys:v18 count:2];
              int v11 = +[NFFieldNotification notificationWithDictionary:v10];

              if (v11) {
                [v13 addObject:v11];
              }
            }
          }
          id v6 = [v4 countByEnumeratingWithState:&v14 objects:v20 count:16];
        }
        while (v6);
      }
    }
  }
  else
  {
    id v13 = 0;
  }

  return v13;
}

void sub_1000FB434(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i Refresh express setting due to domain change=%@", v8, ClassName, Name, 2817, *(void *)(a1 + 40));
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    int v12 = object_getClassName(*(id *)(a1 + 32));
    id v13 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v14 = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 67110146;
    int v17 = v11;
    __int16 v18 = 2082;
    __int16 v19 = v12;
    __int16 v20 = 2082;
    __int16 v21 = v13;
    __int16 v22 = 1024;
    int v23 = 2817;
    __int16 v24 = 2112;
    uint64_t v25 = v14;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Refresh express setting due to domain change=%@", buf, 0x2Cu);
  }

  sub_10004F2BC(*(unsigned __int8 **)(*(void *)(a1 + 32) + 24));
  long long v15 = +[_NFHardwareManager sharedHardwareManager];
  [v15 maybeStartNextSession];
}

void sub_1000FB698(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 48);
  uint64_t v2 = *(void *)(a1 + 32);
  uint64_t v8 = (void (**)(id, void, BOOL, void *, void *))*(id *)(a1 + 40);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 24);
    if (v3) {
      uint64_t v4 = *(void *)(v3 + 136);
    }
    else {
      uint64_t v4 = 0;
    }
    BOOL v5 = sub_100044DB8(v3);
    if (v1)
    {
      id v6 = sub_10004B700(*(void *)(v2 + 24));
      if ((v1 & 2) != 0)
      {
LABEL_6:
        uint64_t v7 = sub_1000444D4(*(void **)(v2 + 24));
        v8[2](v8, v4, v5, v6, v7);

        if ((v1 & 1) == 0) {
          goto LABEL_11;
        }
LABEL_10:

        goto LABEL_11;
      }
    }
    else
    {
      id v6 = 0;
      if ((v1 & 2) != 0) {
        goto LABEL_6;
      }
    }
    v8[2](v8, v4, v5, v6, 0);
    if ((v1 & 1) == 0) {
      goto LABEL_11;
    }
    goto LABEL_10;
  }
LABEL_11:
}

BOOL sub_1000FBD90(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i Requested to set AID to %@", v8, ClassName, Name, 2897, *(void *)(a1 + 40));
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    int v12 = object_getClassName(*(id *)(a1 + 32));
    id v13 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v14 = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 67110146;
    int v40 = v11;
    __int16 v41 = 2082;
    id v42 = v12;
    __int16 v43 = 2082;
    __int16 v44 = v13;
    __int16 v45 = 1024;
    int v46 = 2897;
    __int16 v47 = 2112;
    uint64_t v48 = v14;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Requested to set AID to %@", buf, 0x2Cu);
  }

  uint64_t v15 = sub_1001E140C(*(void **)(*(void *)(a1 + 32) + 368), *(void **)(a1 + 40));
  uint64_t v16 = *(void *)(*(void *)(a1 + 48) + 8);
  int v17 = *(void **)(v16 + 40);
  *(void *)(v16 + 40) = v15;

  if (*(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40))
  {
    id v18 = objc_alloc((Class)NSError);
    __int16 v19 = +[NSString stringWithUTF8String:"nfcd"];
    id v20 = [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) code];
    v35[0] = NSLocalizedDescriptionKey;
    if ((uint64_t)[*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) code] > 70) {
      uint64_t v21 = 71;
    }
    else {
      uint64_t v21 = (uint64_t)[*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) code];
    }
    int v23 = +[NSString stringWithUTF8String:off_100304250[v21]];
    v35[1] = NSUnderlyingErrorKey;
    uint64_t v30 = *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
    v36[0] = v23;
    v36[1] = v30;
    v36[2] = &off_10031B7C0;
    v35[2] = @"Line";
    v35[3] = @"Method";
    id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v36[3] = v24;
    v35[4] = NSDebugDescriptionErrorKey;
    id v25 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 2905];
    uint8_t v36[4] = v25;
    __int16 v26 = +[NSDictionary dictionaryWithObjects:v36 forKeys:v35 count:5];
    __int16 v27 = v18;
    int v28 = v19;
    uint64_t v29 = (uint64_t)v20;
    goto LABEL_17;
  }
  if ((sub_100212274(*(void **)(*(void *)(a1 + 32) + 368)) & 1) == 0)
  {
    id v22 = objc_alloc((Class)NSError);
    __int16 v19 = +[NSString stringWithUTF8String:"nfcd"];
    v37[0] = NSLocalizedDescriptionKey;
    int v23 = +[NSString stringWithUTF8String:"Stack Error"];
    v38[0] = v23;
    v38[1] = &off_10031B7A8;
    v37[1] = @"Line";
    v37[2] = @"Method";
    id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v38[2] = v24;
    v37[3] = NSDebugDescriptionErrorKey;
    id v25 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 2902];
    v38[3] = v25;
    __int16 v26 = +[NSDictionary dictionaryWithObjects:v38 forKeys:v37 count:4];
    __int16 v27 = v22;
    int v28 = v19;
    uint64_t v29 = 15;
LABEL_17:
    id v31 = [v27 initWithDomain:v28 code:v29 userInfo:v26];
    uint64_t v32 = *(void *)(*(void *)(a1 + 48) + 8);
    __int16 v33 = *(void **)(v32 + 40);
    *(void *)(v32 + 40) = v31;
  }
  return *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) == 0;
}

void sub_1000FC31C(uint64_t a1)
{
  int v1 = *(void ***)(a1 + 32);
  uint64_t v2 = *(void **)(a1 + 48);
  id v3 = *(id *)(a1 + 40);
  uint64_t v4 = v2;
  if (v1)
  {
    uint64_t v10 = 0;
    int v11 = &v10;
    uint64_t v12 = 0x3032000000;
    id v13 = sub_10000B858;
    uint64_t v14 = sub_1000F2378;
    id v15 = 0;
    uint64_t v9 = "_sync_setAntiRelay:completion:";
    id v7 = v3;
    uint64_t v8 = &v10;
    BOOL v5 = +[NFRoutingConfig routingOffWithFD:](NFRoutingConfig, "routingOffWithFD:", 0, _NSConcreteStackBlock, 3221225472, sub_1000FBD90, &unk_100304560, v1);
    sub_1000F23D8(v1, &v6, @"Anti relay", v5);

    v4[2](v4, v11[5]);
    _Block_object_dispose(&v10, 8);
  }
}

void sub_1000FC46C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1000FC51C(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  id v2 = *(id *)(a1 + 40);
  if (v1)
  {
    id v3 = objc_opt_new();
    if (-[_NFHardwareManager getPrimaryHardwareState]_0(v1) == 2)
    {
      if ((sub_1000F596C(v1) & 1) == 0)
      {
        uint64_t v4 = *(void *)(v1 + 24);
        if (!v4 || !*(unsigned char *)(v4 + 172))
        {
          *(void *)long long buf = _NSConcreteStackBlock;
          *(void *)__int16 v43 = 3221225472;
          *(void *)&v43[8] = sub_1000FCBA4;
          *(void *)&v43[16] = &unk_1003045B0;
          *(void *)&v43[24] = v1;
          id v44 = v3;
          id v31 = v2;
          id v45 = v31;
          int v46 = "_sync_rfSettingsWithCompletion:";
          uint64_t v32 = +[NFRoutingConfig routingOffWithFD:0];
          char v33 = sub_1000F23D8((void **)v1, buf, @"Get RF Settings", v32);

          if ((v33 & 1) == 0)
          {
            id v34 = objc_alloc((Class)NSError);
            __int16 v35 = +[NSString stringWithUTF8String:"nfcd"];
            v41[0] = NSLocalizedDescriptionKey;
            long long v36 = +[NSString stringWithUTF8String:"Stack Error"];
            NSErrorUserInfoKey v47 = v36;
            CFStringRef v48 = (const __CFString *)&off_10031B820;
            v41[1] = @"Line";
            v41[2] = @"Method";
            __int16 v37 = (__CFString *)[objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_rfSettingsWithCompletion:")];
            CFStringRef v49 = v37;
            v41[3] = NSDebugDescriptionErrorKey;
            long long v38 = (NSString *)[[objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_rfSettingsWithCompletion:"), 2956];
            NSErrorUserInfoKey v50 = v38;
            __int16 v39 = +[NSDictionary dictionaryWithObjects:&v47 forKeys:v41 count:4];
            id v40 = [v34 initWithDomain:v35 code:15 userInfo:v39];
            (*((void (**)(id, void, id))v31 + 2))(v31, 0, v40);
          }
          goto LABEL_23;
        }
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        uint64_t v6 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass((id)v1);
        if (class_isMetaClass(Class)) {
          uint64_t v8 = 43;
        }
        else {
          uint64_t v8 = 45;
        }
        ClassName = object_getClassName((id)v1);
        Name = sel_getName("_sync_rfSettingsWithCompletion:");
        uint64_t v11 = sub_1000F596C(v1);
        uint64_t v12 = *(void *)(v1 + 24);
        if (v12) {
          uint64_t v12 = *(unsigned __int8 *)(v12 + 172);
        }
        v6(3, "%c[%{public}s %{public}s]:%i Session in progress (%d) or express in progress (%d) - bailing", v8, ClassName, Name, 2938, v11, v12);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v13 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        uint64_t v14 = object_getClass((id)v1);
        if (class_isMetaClass(v14)) {
          int v15 = 43;
        }
        else {
          int v15 = 45;
        }
        uint64_t v16 = object_getClassName((id)v1);
        int v17 = sel_getName("_sync_rfSettingsWithCompletion:");
        int v18 = sub_1000F596C(v1);
        uint64_t v19 = *(void *)(v1 + 24);
        if (v19) {
          LODWORD(v19) = *(unsigned __int8 *)(v19 + 172);
        }
        *(_DWORD *)long long buf = 67110402;
        *(_DWORD *)&uint8_t buf[4] = v15;
        *(_WORD *)__int16 v43 = 2082;
        *(void *)&v43[2] = v16;
        *(_WORD *)&v43[10] = 2082;
        *(void *)&v43[12] = v17;
        *(_WORD *)&v43[20] = 1024;
        *(_DWORD *)&v43[22] = 2938;
        *(_WORD *)&v43[26] = 1024;
        *(_DWORD *)&v43[28] = v18;
        LOWORD(v44) = 1024;
        *(_DWORD *)((char *)&v44 + 2) = v19;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session in progress (%d) or express in progress (%d) - bailing", buf, 0x2Eu);
      }

      id v20 = objc_alloc((Class)NSError);
      uint64_t v21 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v47 = NSLocalizedDescriptionKey;
      id v22 = +[NSString stringWithUTF8String:"Busy"];
      *(void *)long long buf = v22;
      *(void *)__int16 v43 = &off_10031B7F0;
      CFStringRef v48 = @"Line";
      CFStringRef v49 = @"Method";
      id v23 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_rfSettingsWithCompletion:")];
      *(void *)&v43[8] = v23;
      NSErrorUserInfoKey v50 = NSDebugDescriptionErrorKey;
      id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_rfSettingsWithCompletion:"), 2939];
      *(void *)&v43[16] = v24;
      id v25 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v47 count:4];
      __int16 v26 = v20;
      __int16 v27 = v21;
      uint64_t v28 = 2;
    }
    else
    {
      id v29 = objc_alloc((Class)NSError);
      uint64_t v21 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v47 = NSLocalizedDescriptionKey;
      id v22 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
      *(void *)long long buf = v22;
      *(void *)__int16 v43 = &off_10031B7D8;
      CFStringRef v48 = @"Line";
      CFStringRef v49 = @"Method";
      id v23 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_rfSettingsWithCompletion:")];
      *(void *)&v43[8] = v23;
      NSErrorUserInfoKey v50 = NSDebugDescriptionErrorKey;
      id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_rfSettingsWithCompletion:"), 2933];
      *(void *)&v43[16] = v24;
      id v25 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v47 count:4];
      __int16 v26 = v29;
      __int16 v27 = v21;
      uint64_t v28 = 58;
    }
    id v30 = [v26 initWithDomain:v27 code:v28 userInfo:v25];
    (*((void (**)(id, void, id))v2 + 2))(v2, 0, v30);

LABEL_23:
  }
}

uint64_t sub_1000FCBA4(uint64_t a1)
{
  unsigned int v2 = sub_1001E08CC(*(void **)(*(void *)(a1 + 32) + 368), *(void **)(a1 + 40));
  uint64_t v3 = *(void *)(a1 + 48);
  if (v2)
  {
    (*(void (**)(void, void, void))(v3 + 16))(*(void *)(a1 + 48), *(void *)(a1 + 40), 0);
  }
  else
  {
    id v4 = objc_alloc((Class)NSError);
    BOOL v5 = +[NSString stringWithUTF8String:"nfcd"];
    v12[0] = NSLocalizedDescriptionKey;
    uint64_t v6 = +[NSString stringWithUTF8String:"Feature Not Supported"];
    v13[0] = v6;
    v13[1] = &off_10031B808;
    v12[1] = @"Line";
    v12[2] = @"Method";
    id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v13[2] = v7;
    v12[3] = NSDebugDescriptionErrorKey;
    id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 2950];
    v13[3] = v8;
    uint64_t v9 = +[NSDictionary dictionaryWithObjects:v13 forKeys:v12 count:4];
    id v10 = [v4 initWithDomain:v5 code:14 userInfo:v9];
    (*(void (**)(uint64_t, void, id))(v3 + 16))(v3, 0, v10);
  }
  return 1;
}

void sub_1000FCE28(uint64_t a1)
{
  uint64_t v1 = *(void ***)(a1 + 32);
  unsigned int v2 = (void (**)(id, void *, void))*(id *)(a1 + 40);
  if (v1)
  {
    if (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v1) == 2
      || -[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v1) == 5)
    {
      uint64_t v3 = sub_10020EC8C(v1[46], @"DieID", 2uLL);
      if (!v3)
      {
        id v4 = sub_100215E94(v1[46]);
        if (v4)
        {
          v2[2](v2, v4, 0);
        }
        else
        {
          id v27 = objc_alloc((Class)NSError);
          uint64_t v28 = +[NSString stringWithUTF8String:"nfcd"];
          NSErrorUserInfoKey v36 = NSLocalizedDescriptionKey;
          id v29 = +[NSString stringWithUTF8String:"Unknown Error"];
          *(void *)long long buf = v29;
          *(void *)id v42 = &off_10031B868;
          CFStringRef v37 = @"Line";
          CFStringRef v38 = @"Method";
          id v30 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_getDieIDWithCompletion:")];
          *(void *)&v42[8] = v30;
          CFStringRef v39 = (const __CFString *)NSDebugDescriptionErrorKey;
          id v31 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_getDieIDWithCompletion:"), 2984];
          *(void *)&v42[16] = v31;
          uint64_t v32 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v36 count:4];
          id v33 = [v27 initWithDomain:v28 code:6 userInfo:v32];
          ((void (**)(id, void *, id))v2)[2](v2, 0, v33);
        }
        sub_1002114AC(v1[46], @"DieID");
        goto LABEL_24;
      }
      id v4 = (void *)v3;
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        uint64_t v6 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(v1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(v1);
        Name = sel_getName("_sync_getDieIDWithCompletion:");
        uint64_t v9 = 45;
        if (isMetaClass) {
          uint64_t v9 = 43;
        }
        v6(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v9, ClassName, Name, 2978, v4);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v10 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        uint64_t v11 = object_getClass(v1);
        if (class_isMetaClass(v11)) {
          int v12 = 43;
        }
        else {
          int v12 = 45;
        }
        *(_DWORD *)long long buf = 67110146;
        *(_DWORD *)&uint8_t buf[4] = v12;
        *(_WORD *)id v42 = 2082;
        *(void *)&v42[2] = object_getClassName(v1);
        *(_WORD *)&v42[10] = 2082;
        *(void *)&v42[12] = sel_getName("_sync_getDieIDWithCompletion:");
        *(_WORD *)&v42[20] = 1024;
        *(_DWORD *)&v42[22] = 2978;
        *(_WORD *)&unsigned char v42[26] = 2112;
        *(void *)&v42[28] = v4;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
      }

      id v13 = objc_alloc((Class)NSError);
      uint64_t v14 = +[NSString stringWithUTF8String:"nfcd"];
      id v15 = [v4 code];
      NSErrorUserInfoKey v36 = NSLocalizedDescriptionKey;
      if ((uint64_t)[v4 code] > 70) {
        uint64_t v16 = 71;
      }
      else {
        uint64_t v16 = (uint64_t)[v4 code];
      }
      id v22 = +[NSString stringWithUTF8String:off_100304250[v16]];
      *(void *)long long buf = v22;
      *(void *)id v42 = v4;
      CFStringRef v37 = (const __CFString *)NSUnderlyingErrorKey;
      CFStringRef v38 = @"Line";
      *(void *)&v42[8] = &off_10031B850;
      CFStringRef v39 = @"Method";
      id v23 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_getDieIDWithCompletion:")];
      *(void *)&v42[16] = v23;
      NSErrorUserInfoKey v40 = NSDebugDescriptionErrorKey;
      id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_getDieIDWithCompletion:"), 2979];
      *(void *)&v42[24] = v24;
      id v25 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v36 count:5];
      id v26 = [v13 initWithDomain:v14 code:v15 userInfo:v25];
      ((void (**)(id, void *, id))v2)[2](v2, 0, v26);
    }
    else
    {
      id v17 = objc_alloc((Class)NSError);
      id v4 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v36 = NSLocalizedDescriptionKey;
      uint64_t v14 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
      *(void *)long long buf = v14;
      *(void *)id v42 = &off_10031B838;
      CFStringRef v37 = @"Line";
      CFStringRef v38 = @"Method";
      id v18 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_getDieIDWithCompletion:")];
      *(void *)&v42[8] = v18;
      CFStringRef v39 = (const __CFString *)NSDebugDescriptionErrorKey;
      id v19 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_getDieIDWithCompletion:"), 2972];
      *(void *)&v42[16] = v19;
      id v20 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v36 count:4];
      id v21 = [v17 initWithDomain:v4 code:58 userInfo:v20];
      ((void (**)(id, void *, id))v2)[2](v2, 0, v21);
    }
LABEL_24:
  }
}

void sub_1000FD52C(uint64_t a1)
{
  uint64_t v1 = *(void ***)(a1 + 32);
  unsigned int v2 = (void (**)(id, void, id))*(id *)(a1 + 40);
  if (v1)
  {
    if (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v1) == 2
      || -[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v1) == 5)
    {
      uint64_t v3 = sub_10020EC8C(v1[46], @"FDRKey", 2uLL);
      if (v3)
      {
        id v4 = (id)v3;
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          uint64_t v6 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(v1);
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(v1);
          Name = sel_getName("_sync_getUniqueFDRKeyWithCompletion:");
          uint64_t v9 = 45;
          if (isMetaClass) {
            uint64_t v9 = 43;
          }
          v6(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v9, ClassName, Name, 3007, v4);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v10 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          uint64_t v11 = object_getClass(v1);
          if (class_isMetaClass(v11)) {
            int v12 = 43;
          }
          else {
            int v12 = 45;
          }
          *(_DWORD *)long long buf = 67110146;
          *(_DWORD *)&uint8_t buf[4] = v12;
          *(_WORD *)NSErrorUserInfoKey v36 = 2082;
          *(void *)&v36[2] = object_getClassName(v1);
          *(_WORD *)&v36[10] = 2082;
          *(void *)&v36[12] = sel_getName("_sync_getUniqueFDRKeyWithCompletion:");
          *(_WORD *)&v36[20] = 1024;
          *(_DWORD *)&v36[22] = 3007;
          *(_WORD *)&v36[26] = 2112;
          *(void *)&v36[28] = v4;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
        }

        id v13 = objc_alloc((Class)NSError);
        uint64_t v14 = +[NSString stringWithUTF8String:"nfcd"];
        id v15 = [v4 code];
        NSErrorUserInfoKey v30 = NSLocalizedDescriptionKey;
        if ((uint64_t)[v4 code] > 70) {
          uint64_t v16 = 71;
        }
        else {
          uint64_t v16 = (uint64_t)[v4 code];
        }
        id v23 = +[NSString stringWithUTF8String:off_100304250[v16]];
        *(void *)long long buf = v23;
        *(void *)NSErrorUserInfoKey v36 = v4;
        CFStringRef v31 = (const __CFString *)NSUnderlyingErrorKey;
        CFStringRef v32 = @"Line";
        *(void *)&v36[8] = &off_10031B898;
        CFStringRef v33 = @"Method";
        id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_getUniqueFDRKeyWithCompletion:")];
        *(void *)&v36[16] = v24;
        NSErrorUserInfoKey v34 = NSDebugDescriptionErrorKey;
        id v25 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_getUniqueFDRKeyWithCompletion:"), 3008];
        *(void *)&v36[24] = v25;
        id v26 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v30 count:5];
        id v27 = [v13 initWithDomain:v14 code:v15 userInfo:v26];
        v2[2](v2, 0, v27);
      }
      else
      {
        id v17 = v1[46];
        *(void *)long long buf = 0;
        uint64_t v14 = sub_1002160C0(v17, buf);
        id v4 = *(id *)buf;
        ((void (**)(id, void *, id))v2)[2](v2, v14, v4);
        sub_1002114AC(v1[46], @"FDRKey");
      }
    }
    else
    {
      id v18 = objc_alloc((Class)NSError);
      id v4 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v30 = NSLocalizedDescriptionKey;
      uint64_t v14 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
      *(void *)long long buf = v14;
      *(void *)NSErrorUserInfoKey v36 = &off_10031B880;
      CFStringRef v31 = @"Line";
      CFStringRef v32 = @"Method";
      id v19 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_getUniqueFDRKeyWithCompletion:")];
      *(void *)&v36[8] = v19;
      CFStringRef v33 = (const __CFString *)NSDebugDescriptionErrorKey;
      id v20 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_getUniqueFDRKeyWithCompletion:"), 3001];
      *(void *)&v36[16] = v20;
      id v21 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v30 count:4];
      id v22 = [v18 initWithDomain:v4 code:58 userInfo:v21];
      v2[2](v2, 0, v22);
    }
  }
}

void sub_1000FDAF0(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 40);
  sub_1000FDB50(*(void *)(a1 + 32));
  id v2 = (id)objc_claimAutoreleasedReturnValue();
  (*(void (**)(uint64_t, id, void))(v1 + 16))(v1, v2, 0);
}

id sub_1000FDB50(uint64_t a1)
{
  if (a1)
  {
    id v101 = (id)objc_opt_new();
    uint64_t v1 = +[NSNumber numberWithInteger:*(void *)(a1 + 288)];
    [v101 setObject:v1 forKeyedSubscript:@"radio"];

    uint64_t v2 = a1;
    uint64_t v3 = *(void **)(a1 + 384);
    if (v3)
    {
      id v4 = [v3 asDictionary];
      [v101 setObject:v4 forKeyedSubscript:@"controller"];

      uint64_t v2 = a1;
    }
    BOOL v5 = *(void **)(v2 + 40);
    if (v5)
    {
      uint64_t v6 = [v5 asDictionary];
      [v101 setObject:v6 forKeyedSubscript:@"embeddedSE"];

      uint64_t v2 = a1;
    }
    int v7 = *(unsigned __int16 *)(v2 + 332);
    if (v7)
    {
      id v8 = +[NSNumber numberWithShort:(__int16)v7];
      [v101 setObject:v8 forKeyedSubscript:@"ATE Trim Version"];
    }
    uint64_t v9 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", +[NFSecureElementWrapper isAuthRandomEntangled]);
    [v101 setObject:v9 forKeyedSubscript:@"authRandomEntangled"];

    uint64_t v10 = a1;
    uint64_t v11 = *(void **)(a1 + 376);
    if (v11)
    {
      int v12 = [v11 cachedAppletsUnfiltered];

      uint64_t v10 = a1;
      if (v12)
      {
        id v13 = objc_opt_new();
        long long v121 = 0u;
        long long v122 = 0u;
        long long v123 = 0u;
        long long v124 = 0u;
        uint64_t v14 = [*(id *)(a1 + 376) cachedAppletsUnfiltered];
        id v15 = [v14 countByEnumeratingWithState:&v121 objects:v136 count:16];
        if (v15)
        {
          uint64_t v16 = *(void *)v122;
          do
          {
            for (i = 0; i != v15; i = (char *)i + 1)
            {
              if (*(void *)v122 != v16) {
                objc_enumerationMutation(v14);
              }
              id v18 = [*(id *)(*((void *)&v121 + 1) + 8 * i) description];
              [v13 addObject:v18];
            }
            id v15 = [v14 countByEnumeratingWithState:&v121 objects:v136 count:16];
          }
          while (v15);
        }

        [v101 setObject:v13 forKeyedSubscript:@"embeddedSEApplets"];
        uint64_t v10 = a1;
      }
    }
    id v19 = +[NSNumber numberWithBool:*(unsigned __int8 *)(v10 + 337)];
    [v101 setObject:v19 forKeyedSubscript:@"isRunning"];

    uint64_t v20 = *(void *)(a1 + 24);
    if (v20) {
      BOOL v21 = *(unsigned __int8 *)(v20 + 172) != 0;
    }
    else {
      BOOL v21 = 0;
    }
    id v22 = +[NSNumber numberWithBool:v21];
    [v101 setObject:v22 forKeyedSubscript:@"expressModeInProgress"];

    id v23 = +[NSNumber numberWithBool:*(unsigned __int8 *)(a1 + 338)];
    [v101 setObject:v23 forKeyedSubscript:@"didPrewWarmHardware"];

    id v24 = *(void **)(a1 + 184);
    if (v24)
    {
      id v25 = +[NSNumber numberWithInteger:](NSNumber, "numberWithInteger:", [v24 count]);
      [v101 setObject:v25 forKeyedSubscript:@"numQueuedSessions"];
    }
    else
    {
      [v101 setObject:&off_10031B6D0 forKeyedSubscript:@"numQueuedSessions"];
    }
    if (*(void *)(a1 + 112)) {
      CFStringRef v26 = @"YES";
    }
    else {
      CFStringRef v26 = @"NO";
    }
    [v101 setObject:v26 forKeyedSubscript:@"hasCurrentSession"];
    if (*(void *)(a1 + 112))
    {
      id v27 = [(id)objc_opt_class() description];
      [v101 setObject:v27 forKeyedSubscript:@"currentSessionType"];

      uint64_t v28 = [*(id *)(a1 + 112) clientName];
      if (v28)
      {
        id v29 = [*(id *)(a1 + 112) clientName];
        [v101 setObject:v29 forKeyedSubscript:@"currentSessionOwner"];
      }
      else
      {
        [v101 setObject:&stru_100309C40 forKeyedSubscript:@"currentSessionOwner"];
      }

      NSErrorUserInfoKey v30 = [*(id *)(a1 + 112) creation];
      [v101 setObject:v30 forKeyedSubscript:@"currentSessionCreation"];

      CFStringRef v31 = [*(id *)(a1 + 112) dequeueDate];
      [v101 setObject:v31 forKeyedSubscript:@"currentSessionDequeue"];

      CFStringRef v32 = [*(id *)(a1 + 112) sessionUID];
      [v101 setObject:v32 forKeyedSubscript:@"currentSessionUID"];
    }
    CFStringRef v33 = [(id)a1 lastKnownRoutingConfig];
    NSErrorUserInfoKey v34 = [v33 description];
    [v101 setObject:v34 forKeyedSubscript:@"routingConfig"];

    if (NF_isFeatureSupported())
    {
      __int16 v35 = sub_10004B90C(*(void *)(a1 + 24));
      [v101 setObject:v35 forKeyedSubscript:@"expressModeState"];
    }
    NSErrorUserInfoKey v36 = sub_100212A9C(*(void **)(a1 + 368));
    [v101 setObject:v36 forKeyedSubscript:@"driverwrapperState"];

    CFStringRef v37 = sub_10021A750();
    CFStringRef v38 = sub_10021E238(v37);
    [v101 setObject:v38 forKeyedSubscript:@"LPEMState"];

    CFStringRef v39 = +[NSNumber numberWithInteger:*(void *)(a1 + 304)];
    [v101 setObject:v39 forKeyedSubscript:@"Reader Session suspension count"];

    NSErrorUserInfoKey v40 = objc_opt_new();
    long long v131 = 0u;
    long long v132 = 0u;
    long long v129 = 0u;
    long long v130 = 0u;
    id v41 = [&off_1003227F0 countByEnumeratingWithState:&v129 objects:v138 count:16];
    if (v41)
    {
      uint64_t v107 = *(void *)v130;
      do
      {
        for (j = 0; j != v41; j = (char *)j + 1)
        {
          if (*(void *)v130 != v107) {
            objc_enumerationMutation(&off_1003227F0);
          }
          id v43 = [objc_alloc((Class)NSUserDefaults) initWithSuiteName:*(void *)(*((void *)&v129 + 1) + 8 * (void)j)];
          long long v127 = 0u;
          long long v128 = 0u;
          long long v125 = 0u;
          long long v126 = 0u;
          id v44 = [&off_1003227D8 countByEnumeratingWithState:&v125 objects:v137 count:16];
          if (v44)
          {
            uint64_t v45 = *(void *)v126;
            do
            {
              for (k = 0; k != v44; k = (char *)k + 1)
              {
                if (*(void *)v126 != v45) {
                  objc_enumerationMutation(&off_1003227D8);
                }
                uint64_t v47 = *(void *)(*((void *)&v125 + 1) + 8 * (void)k);
                CFStringRef v48 = [v43 objectForKey:v47];
                if (v48) {
                  [v40 setObject:v48 forKeyedSubscript:v47];
                }
              }
              id v44 = [&off_1003227D8 countByEnumeratingWithState:&v125 objects:v137 count:16];
            }
            while (v44);
          }
        }
        id v41 = [&off_1003227F0 countByEnumeratingWithState:&v129 objects:v138 count:16];
      }
      while (v41);
    }
    [v101 setObject:v40 forKeyedSubscript:@"settings"];

    if ([*(id *)(a1 + 216) checkResourceIsReachableAndReturnError:0])
    {
      id v49 = [objc_alloc((Class)NSDictionary) initWithContentsOfURL:*(void *)(a1 + 216)];
      [v101 setObject:v49 forKeyedSubscript:@"LPCDFalseDetects"];
    }
    uint64_t v50 = *(void *)(a1 + 208);
    if (v50) {
      [v101 setObject:v50 forKeyedSubscript:@"LPEMLoggingFTA"];
    }
    id v51 = [objc_alloc((Class)NSString) initWithUTF8String:"NFCD built from (B&I) Stockholm_Base-352.12"];
    [v101 setObject:v51 forKeyedSubscript:@"buildInfo"];

    uint64_t v52 = a1;
    if (*(void *)(a1 + 32))
    {
      id v53 = objc_alloc((Class)NSString);
      id v54 = *(unsigned int **)(a1 + 32);
      id v55 = [v53 initWithFormat:@"Persistent=%d, COR=%d, CODS=%d, idx=%d/%d, availablePersistent=%d, eUICC=%d, reservedCODS=%d, maxMappedCODS=%d, tmpOSU=%d, OSU=%d, tmpCommon=%d, reservedCommon=%d", *v54, v54[1], v54[2], v54[3], v54[4], v54[5], v54[6], v54[7], v54[8], v54[9], v54[10], v54[11], v54[12]];
      [v101 setObject:v55 forKeyedSubscript:@"SE Memory"];

      uint64_t v52 = a1;
    }
    id v56 = [*(id *)(v52 + 192) copy];
    uint64_t v106 = objc_opt_new();
    long long v119 = 0u;
    long long v120 = 0u;
    long long v117 = 0u;
    long long v118 = 0u;
    id obj = v56;
    id v57 = [obj countByEnumeratingWithState:&v117 objects:v135 count:16];
    if (v57)
    {
      uint64_t v58 = *(void *)v118;
      do
      {
        for (m = 0; m != v57; m = (char *)m + 1)
        {
          if (*(void *)v118 != v58) {
            objc_enumerationMutation(obj);
          }
          unsigned int v60 = *(void **)(*((void *)&v117 + 1) + 8 * (void)m);
          id v61 = objc_alloc((Class)NSString);
          uint64_t v62 = [v60 sessionUID];
          id v63 = [v60 clientName];
          id v64 = [v60 processIdentifier];
          id v65 = +[NSDate now];
          int v66 = [v60 dequeueDate];
          [v65 timeIntervalSinceDate:v66];
          id v68 = [v61 initWithFormat:@"%@ for %@ (%d) for %f seconds", v62, v63, v64, v67];

          [v106 addObject:v68];
        }
        id v57 = [obj countByEnumeratingWithState:&v117 objects:v135 count:16];
      }
      while (v57);
    }

    [v101 setObject:v106 forKeyedSubscript:@"SuspendedSessionQueue"];
    int v69 = +[NFPowerAssertion sharedPowerAssertion];
    uint64_t v70 = [v69 dumpState];
    [v101 addEntriesFromDictionary:v70];

    NSErrorUserInfoKey v71 = *(void **)(a1 + 408);
    if (v71)
    {
      double v72 = [v71 dumpState];
      [v101 setObject:v72 forKeyedSubscript:@"Background Tag Reading"];
    }
    int v108 = objc_opt_new();
    id v99 = objc_getProperty((id)a1, v73, 176, 1);
    objc_sync_enter(v99);
    id v74 = [*(id *)(a1 + 176) copy];
    long long v115 = 0u;
    long long v116 = 0u;
    long long v113 = 0u;
    long long v114 = 0u;
    id v102 = v74;
    id v75 = [v102 countByEnumeratingWithState:&v113 objects:v134 count:16];
    if (v75)
    {
      uint64_t v104 = *(void *)v114;
      do
      {
        id v105 = v75;
        for (n = 0; n != v105; n = (char *)n + 1)
        {
          if (*(void *)v114 != v104) {
            objc_enumerationMutation(v102);
          }
          __int16 v77 = *(void **)(*((void *)&v113 + 1) + 8 * (void)n);
          id v78 = [v77 processIdentifier];
          __int16 v79 = [v77 NF_userInfo];
          int v80 = [v79 objectsForKeys:&off_100322808 notFoundMarker:&stru_100309C40];

          id v81 = +[NSNumber numberWithUnsignedInt:v78];
          id v82 = [v81 stringValue];

          uint64_t v83 = +[NSMutableDictionary dictionaryWithObjects:v80 forKeys:&off_100322808];
          [v108 setObject:v83 forKeyedSubscript:v82];

          id v84 = [v108 objectForKeyedSubscript:v82];
          id v85 = [v84 objectForKeyedSubscript:@"assertions"];

          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0 && [v85 count])
          {
            uint64_t v86 = objc_opt_new();
            long long v111 = 0u;
            long long v112 = 0u;
            long long v109 = 0u;
            long long v110 = 0u;
            id v87 = v85;
            id v88 = [v87 countByEnumeratingWithState:&v109 objects:v133 count:16];
            if (v88)
            {
              uint64_t v89 = *(void *)v110;
              do
              {
                for (ii = 0; ii != v88; ii = (char *)ii + 1)
                {
                  if (*(void *)v110 != v89) {
                    objc_enumerationMutation(v87);
                  }
                  int v91 = [*(id *)(*((void *)&v109 + 1) + 8 * (void)ii) description];
                  [v86 addObject:v91];
                }
                id v88 = [v87 countByEnumeratingWithState:&v109 objects:v133 count:16];
              }
              while (v88);
            }

            int v92 = [v108 objectForKeyedSubscript:v82];
            [v92 setObject:v86 forKeyedSubscript:@"assertions"];
          }
        }
        id v75 = [v102 countByEnumeratingWithState:&v113 objects:v134 count:16];
      }
      while (v75);
    }

    uint64_t v93 = *(void **)(a1 + 416);
    if (v93)
    {
      id v94 = v93;
      [v101 setObject:v94 forKeyedSubscript:@"CHAssertionForCamera"];
    }
    objc_sync_exit(v99);

    [v101 setObject:v108 forKeyedSubscript:@"XPCs"];
    dispatch_time_t v95 = [*(id *)(a1 + 160) allKeys];
    [v101 setObject:v95 forKeyedSubscript:@"callbackHandlers"];

    uint64_t v96 = [*(id *)(a1 + 120) dumpState];
    [v101 setObject:v96 forKeyedSubscript:@"walletPresentationService"];

    uint64_t v97 = [*(id *)(a1 + 16) getStateDumpInfo];
    [v101 addEntriesFromDictionary:v97];
  }
  else
  {
    id v101 = 0;
  }

  return v101;
}

void sub_1000FE948(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id obj)
{
}

void sub_1000FEA54(uint64_t a1)
{
  uint64_t v1 = *(void ***)(a1 + 32);
  uint64_t v2 = *(void **)(a1 + 48);
  id v3 = *(id *)(a1 + 40);
  id v4 = v2;
  if (v1)
  {
    uint64_t v28 = 0;
    id v29 = &v28;
    uint64_t v30 = 0x3032000000;
    CFStringRef v31 = sub_10000B858;
    CFStringRef v32 = sub_1000F2378;
    id v33 = 0;
    if (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v1) == 2)
    {
      if (v3 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
      {
        id v23 = objc_alloc((Class)NSError);
        id v24 = +[NSString stringWithUTF8String:"nfcd"];
        *(void *)long long buf = NSLocalizedDescriptionKey;
        id v25 = +[NSString stringWithUTF8String:"Invalid Parameter"];
        v43[0] = v25;
        CFStringRef v26 = +[NSDictionary dictionaryWithObjects:v43 forKeys:buf count:1];
        id v27 = [v23 initWithDomain:v24 code:10 userInfo:v26];
        v4[2](v4, v27);
      }
      else
      {
        v43[0] = _NSConcreteStackBlock;
        v43[1] = 3221225472;
        v43[2] = sub_1000FEEF8;
        v43[3] = &unk_100304718;
        uint64_t v45 = &v28;
        void v43[4] = v1;
        id v44 = v3;
        BOOL v5 = +[NFRoutingConfig routingOffWithFD:0];
        char v6 = sub_1000F23D8(v1, v43, @"Push RF", v5);

        if ((v6 & 1) == 0)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (Logger)
          {
            Class = object_getClass(v1);
            if (class_isMetaClass(Class)) {
              uint64_t v9 = 43;
            }
            else {
              uint64_t v9 = 45;
            }
            ClassName = object_getClassName(v1);
            Name = sel_getName("_sync_pushSignedRF:completion:");
            Logger(3, "%c[%{public}s %{public}s]:%i Failed to push signed rf: %{public}@", v9, ClassName, Name, 3101, v29[5]);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          int v12 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          {
            id v13 = object_getClass(v1);
            if (class_isMetaClass(v13)) {
              int v14 = 43;
            }
            else {
              int v14 = 45;
            }
            id v15 = object_getClassName(v1);
            uint64_t v16 = sel_getName("_sync_pushSignedRF:completion:");
            uint64_t v17 = v29[5];
            *(_DWORD *)long long buf = 67110146;
            *(_DWORD *)&uint8_t buf[4] = v14;
            __int16 v35 = 2082;
            NSErrorUserInfoKey v36 = v15;
            __int16 v37 = 2082;
            CFStringRef v38 = v16;
            __int16 v39 = 1024;
            int v40 = 3101;
            __int16 v41 = 2114;
            uint64_t v42 = v17;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to push signed rf: %{public}@", buf, 0x2Cu);
          }
        }
        v4[2](v4, (id)v29[5]);
      }
    }
    else
    {
      id v18 = objc_alloc((Class)NSError);
      id v19 = +[NSString stringWithUTF8String:"nfcd"];
      *(void *)long long buf = NSLocalizedDescriptionKey;
      uint64_t v20 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
      v43[0] = v20;
      BOOL v21 = +[NSDictionary dictionaryWithObjects:v43 forKeys:buf count:1];
      id v22 = [v18 initWithDomain:v19 code:58 userInfo:v21];
      v4[2](v4, v22);
    }
    _Block_object_dispose(&v28, 8);
  }
}

void sub_1000FEEC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_1000FEEF8(uint64_t a1)
{
  uint64_t v2 = sub_1001E10E4(*(void **)(*(void *)(a1 + 32) + 368), *(void **)(a1 + 40));
  uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;

  return *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) == 0;
}

void sub_1000FF030(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 56);
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = *(id *)(a1 + 40);
  id v4 = v3;
  if (v2)
  {
    id v50 = v3;
    BOOL v5 = [v3 NF_userInfo];
    uint64_t v6 = [v5 objectForKeyedSubscript:@"ClientName"];

    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    id v8 = "Enabling";
    if (Logger)
    {
      uint64_t v9 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass((id)v2);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName((id)v2);
      Name = sel_getName("_sync_setFieldDetectEnabled:connection:");
      if (!v1) {
        id v8 = "Disabling";
      }
      int v13 = v1;
      id v14 = *(id *)(v2 + 16);
      id v49 = [v14 totalPersistentClient];
      uint64_t v15 = 43;
      if (!isMetaClass) {
        uint64_t v15 = 45;
      }
      v9(6, "%c[%{public}s %{public}s]:%i %s (%lu clients) persistent field detect by %{public}@", v15, ClassName, Name, 3121, v8, v49, v6);

      int v1 = v13;
    }
    uint64_t v52 = (void *)v6;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v16 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v17 = object_getClass((id)v2);
      if (class_isMetaClass(v17)) {
        int v18 = 43;
      }
      else {
        int v18 = 45;
      }
      int v54 = v18;
      id v19 = object_getClassName((id)v2);
      uint64_t v20 = sel_getName("_sync_setFieldDetectEnabled:connection:");
      if (v1) {
        BOOL v21 = "Enabling";
      }
      else {
        BOOL v21 = "Disabling";
      }
      id v22 = *(id *)(v2 + 16);
      int v23 = v1;
      id v24 = [v22 totalPersistentClient];

      *(_DWORD *)long long buf = 67110658;
      *(_DWORD *)&uint8_t buf[4] = v54;
      __int16 v58 = 2082;
      id v59 = v19;
      __int16 v60 = 2082;
      id v61 = v20;
      __int16 v62 = 1024;
      int v63 = 3121;
      __int16 v64 = 2080;
      id v65 = v21;
      __int16 v66 = 2048;
      id v67 = v24;
      int v1 = v23;
      __int16 v68 = 2114;
      int v69 = v52;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %s (%lu clients) persistent field detect by %{public}@", buf, 0x40u);
    }

    if (-[_NFHardwareManager getPrimaryHardwareState]_0(v2) == 2)
    {
      uint64_t v25 = *(void *)(v2 + 368);
      if (!v25 || (*(unsigned char *)(v25 + 218) & 1) == 0)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v26 = NFLogGetLogger();
        if (v26)
        {
          id v27 = (void (*)(uint64_t, const char *, ...))v26;
          uint64_t v28 = object_getClass((id)v2);
          BOOL v29 = class_isMetaClass(v28);
          uint64_t v30 = object_getClassName((id)v2);
          CFStringRef v48 = sel_getName("_sync_setFieldDetectEnabled:connection:");
          uint64_t v31 = 45;
          if (v29) {
            uint64_t v31 = 43;
          }
          v27(4, "%c[%{public}s %{public}s]:%i Device does not have antenna", v31, v30, v48, 3128);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        CFStringRef v32 = NFSharedLogGetLogger();
        id v33 = v52;
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        {
          NSErrorUserInfoKey v34 = object_getClass((id)v2);
          if (class_isMetaClass(v34)) {
            int v35 = 43;
          }
          else {
            int v35 = 45;
          }
          NSErrorUserInfoKey v36 = object_getClassName((id)v2);
          __int16 v37 = sel_getName("_sync_setFieldDetectEnabled:connection:");
          *(_DWORD *)long long buf = 67109890;
          *(_DWORD *)&uint8_t buf[4] = v35;
          __int16 v58 = 2082;
          id v59 = v36;
          __int16 v60 = 2082;
          id v61 = v37;
          __int16 v62 = 1024;
          int v63 = 3128;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Device does not have antenna", buf, 0x22u);
        }

        id v38 = objc_alloc((Class)NSError);
        __int16 v39 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v56 = NSLocalizedDescriptionKey;
        int v40 = +[NSString stringWithUTF8String:"Feature Not Supported"];
        *(void *)long long buf = v40;
        __int16 v41 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v56 count:1];
        id v55 = [v38 initWithDomain:v39 code:14 userInfo:v41];

        id v4 = v50;
        uint64_t v42 = a1;
        goto LABEL_35;
      }
      uint64_t v47 = *(void **)(v2 + 16);
      id v4 = v50;
      if (v1) {
        [v47 addPersistentFieldObserver:v50];
      }
      else {
        [v47 removePersistentFieldObserver:v50];
      }
      uint64_t v42 = a1;
      [(id)v2 maybeStartNextSession];
      id v55 = 0;
    }
    else
    {
      id v43 = objc_alloc((Class)NSError);
      id v44 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v56 = NSLocalizedDescriptionKey;
      uint64_t v45 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
      *(void *)long long buf = v45;
      int v46 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v56 count:1];
      id v55 = [v43 initWithDomain:v44 code:58 userInfo:v46];

      id v4 = v50;
      uint64_t v42 = a1;
    }
    id v33 = v52;
LABEL_35:

    goto LABEL_36;
  }
  id v55 = 0;
  uint64_t v42 = a1;
LABEL_36:

  (*(void (**)(void))(*(void *)(v42 + 48) + 16))();
}

void sub_1000FF668(uint64_t a1)
{
  unsigned int v1 = *(unsigned __int8 *)(a1 + 48);
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = (void (**)(id, id))*(id *)(a1 + 40);
  if (v2)
  {
    if (-[_NFHardwareManager getPrimaryHardwareState]_0(v2) == 2)
    {
      uint64_t v4 = sub_10020EC8C(*(void **)(v2 + 368), @"Delayed Sleep", 1uLL);
      if (v4)
      {
        BOOL v5 = (void *)v4;
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          int v7 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass((id)v2);
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName((id)v2);
          Name = sel_getName("_sync_triggerDelayedWake:completion:");
          uint64_t v10 = 45;
          if (isMetaClass) {
            uint64_t v10 = 43;
          }
          v7(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v10, ClassName, Name, 3273, v5);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v11 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          int v12 = object_getClass((id)v2);
          if (class_isMetaClass(v12)) {
            int v13 = 43;
          }
          else {
            int v13 = 45;
          }
          *(_DWORD *)long long buf = 67110146;
          *(_DWORD *)&uint8_t buf[4] = v13;
          *(_WORD *)id v57 = 2082;
          *(void *)&v57[2] = object_getClassName((id)v2);
          *(_WORD *)&v57[10] = 2082;
          *(void *)&v57[12] = sel_getName("_sync_triggerDelayedWake:completion:");
          *(_WORD *)&v57[20] = 1024;
          *(_DWORD *)&v57[22] = 3273;
          *(_WORD *)&v57[26] = 2112;
          *(void *)&v57[28] = v5;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
        }

        id v14 = objc_alloc((Class)NSError);
        uint64_t v15 = +[NSString stringWithUTF8String:"nfcd"];
        id v16 = [v5 code];
        NSErrorUserInfoKey v51 = NSLocalizedDescriptionKey;
        if ((uint64_t)[v5 code] > 70) {
          uint64_t v17 = 71;
        }
        else {
          uint64_t v17 = (uint64_t)[v5 code];
        }
        int v35 = +[NSString stringWithUTF8String:off_100304250[v17]];
        *(void *)long long buf = v35;
        *(void *)id v57 = v5;
        CFStringRef v52 = (const __CFString *)NSUnderlyingErrorKey;
        CFStringRef v53 = @"Line";
        *(void *)&v57[8] = &off_10031B8E0;
        CFStringRef v54 = @"Method";
        id v36 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_triggerDelayedWake:completion:")];
        *(void *)&v57[16] = v36;
        NSErrorUserInfoKey v55 = NSDebugDescriptionErrorKey;
        id v37 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_triggerDelayedWake:completion:"), 3274];
        *(void *)&v57[24] = v37;
        id v38 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v51 count:5];
        id v39 = [v14 initWithDomain:v15 code:v16 userInfo:v38];
        v3[2](v3, v39);
      }
      else if (sub_1001EADFC(*(void **)(v2 + 368)))
      {
        *(unsigned char *)(v2 + 346) = 1;
        v3[2](v3, 0);
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v25 = NFLogGetLogger();
        if (v25)
        {
          uint64_t v26 = (void (*)(uint64_t, const char *, ...))v25;
          id v27 = object_getClass((id)v2);
          BOOL v28 = class_isMetaClass(v27);
          CFStringRef v48 = object_getClassName((id)v2);
          id v50 = sel_getName("_sync_triggerDelayedWake:completion:");
          uint64_t v29 = 45;
          if (v28) {
            uint64_t v29 = 43;
          }
          v26(6, "%c[%{public}s %{public}s]:%i Delaying session close for %d seconds", v29, v48, v50, 3290, v1 + 1);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v30 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v31 = object_getClass((id)v2);
          if (class_isMetaClass(v31)) {
            int v32 = 43;
          }
          else {
            int v32 = 45;
          }
          *(_DWORD *)long long buf = 67110146;
          *(_DWORD *)&uint8_t buf[4] = v32;
          *(_WORD *)id v57 = 2082;
          *(void *)&v57[2] = object_getClassName((id)v2);
          *(_WORD *)&v57[10] = 2082;
          *(void *)&v57[12] = sel_getName("_sync_triggerDelayedWake:completion:");
          *(_WORD *)&v57[20] = 1024;
          *(_DWORD *)&v57[22] = 3290;
          *(_WORD *)&v57[26] = 1024;
          *(_DWORD *)&v57[28] = v1 + 1;
          _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Delaying session close for %d seconds", buf, 0x28u);
        }

        dispatch_time_t v33 = dispatch_time(0, 1000000000 * v1 + 1000000000);
        NSErrorUserInfoKey v34 = *(NSObject **)(v2 + 232);
        *(void *)long long buf = _NSConcreteStackBlock;
        *(void *)id v57 = 3221225472;
        *(void *)&v57[8] = sub_1000FFE5C;
        *(void *)&v57[16] = &unk_100301C68;
        *(void *)&v57[24] = v2;
        dispatch_after(v33, v34, buf);
      }
      else
      {
        id v40 = objc_alloc((Class)NSError);
        __int16 v41 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v51 = NSLocalizedDescriptionKey;
        uint64_t v42 = +[NSString stringWithUTF8String:"Stack Error"];
        *(void *)long long buf = v42;
        *(void *)id v57 = &off_10031B8F8;
        CFStringRef v52 = @"Line";
        CFStringRef v53 = @"Method";
        id v43 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_triggerDelayedWake:completion:")];
        *(void *)&v57[8] = v43;
        CFStringRef v54 = (const __CFString *)NSDebugDescriptionErrorKey;
        id v44 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_triggerDelayedWake:completion:"), 3280];
        *(void *)&v57[16] = v44;
        uint64_t v45 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v51 count:4];
        id v46 = [v40 initWithDomain:v41 code:15 userInfo:v45];
        v3[2](v3, v46);

        sub_1002114AC(*(void **)(v2 + 368), @"Delayed Sleep");
      }
    }
    else
    {
      id v18 = objc_alloc((Class)NSError);
      id v19 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v51 = NSLocalizedDescriptionKey;
      uint64_t v20 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
      *(void *)long long buf = v20;
      *(void *)id v57 = &off_10031B8C8;
      CFStringRef v52 = @"Line";
      CFStringRef v53 = @"Method";
      id v21 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_triggerDelayedWake:completion:")];
      *(void *)&v57[8] = v21;
      CFStringRef v54 = (const __CFString *)NSDebugDescriptionErrorKey;
      id v22 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_triggerDelayedWake:completion:"), 3267];
      *(void *)&v57[16] = v22;
      int v23 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v51 count:4];
      id v24 = [v18 initWithDomain:v19 code:58 userInfo:v23];
      v3[2](v3, v24);
    }
  }
}

id sub_1000FFE5C(uint64_t a1)
{
  sub_1002114AC(*(void **)(*(void *)(a1 + 32) + 368), @"Delayed Sleep");
  *(unsigned char *)(*(void *)(a1 + 32) + 346) = 0;
  uint64_t v2 = *(void **)(a1 + 32);

  return [v2 maybeStartNextSession];
}

void sub_1000FFF54(uint64_t a1)
{
  __int16 v1 = *(_WORD *)(a1 + 48);
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = *(id *)(a1 + 40);
  if (v2)
  {
    if (-[_NFHardwareManager getPrimaryHardwareState]_0(v2) == 2)
    {
      if (NFIsInternalBuild())
      {
        uint64_t v4 = *(void *)(v2 + 232);
        BOOL v5 = +[NFRoutingConfig embeddedWiredMode];
        id v18 = _NSConcreteStackBlock;
        uint64_t v19 = 3221225472;
        uint64_t v20 = sub_1001002FC;
        id v21 = &unk_100302368;
        uint64_t v22 = v2;
        __int16 v25 = v1;
        id v23 = v3;
        id v24 = "_sync_triggerCrash:completion:";
        id v6 = +[_NFBuiltinSession createSessionWithWorkQueue:v4 routing:v5 sessionQueuer:v2 didStartWork:&v18];

        goto LABEL_8;
      }
      id v16 = objc_alloc((Class)NSError);
      id v8 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v26 = NSLocalizedDescriptionKey;
      uint64_t v9 = +[NSString stringWithUTF8String:"Feature Not Supported"];
      id v18 = v9;
      uint64_t v19 = (uint64_t)&off_10031B928;
      CFStringRef v27 = @"Line";
      CFStringRef v28 = @"Method";
      uint64_t v10 = (void (*)(uint64_t))[objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_triggerCrash:completion:")];
      uint64_t v20 = v10;
      NSErrorUserInfoKey v29 = NSDebugDescriptionErrorKey;
      id v11 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_triggerCrash:completion:"), 3313];
      id v21 = v11;
      int v12 = +[NSDictionary dictionaryWithObjects:&v18 forKeys:&v26 count:4];
      int v13 = v16;
      id v14 = v8;
      uint64_t v15 = 14;
    }
    else
    {
      id v7 = objc_alloc((Class)NSError);
      id v8 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v26 = NSLocalizedDescriptionKey;
      uint64_t v9 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
      id v18 = v9;
      uint64_t v19 = (uint64_t)&off_10031B910;
      CFStringRef v27 = @"Line";
      CFStringRef v28 = @"Method";
      uint64_t v10 = (void (*)(uint64_t))[objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_triggerCrash:completion:")];
      uint64_t v20 = v10;
      NSErrorUserInfoKey v29 = NSDebugDescriptionErrorKey;
      id v11 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_triggerCrash:completion:"), 3308];
      id v21 = v11;
      int v12 = +[NSDictionary dictionaryWithObjects:&v18 forKeys:&v26 count:4];
      int v13 = v7;
      id v14 = v8;
      uint64_t v15 = 58;
    }
    id v17 = [v13 initWithDomain:v14 code:v15 userInfo:v12];
    (*((void (**)(id, id))v3 + 2))(v3, v17);
  }
LABEL_8:
}

void sub_1001002FC(uint64_t a1)
{
  char v2 = sub_1001EAE78(*(void **)(*(void *)(a1 + 32) + 368));
  uint64_t v3 = *(void *)(a1 + 40);
  if (v2)
  {
    uint64_t v4 = *(void (**)(uint64_t, void))(v3 + 16);
    uint64_t v5 = *(void *)(a1 + 40);
    v4(v5, 0);
  }
  else
  {
    id v6 = objc_alloc((Class)NSError);
    id v7 = +[NSString stringWithUTF8String:"nfcd"];
    v13[0] = NSLocalizedDescriptionKey;
    id v8 = +[NSString stringWithUTF8String:"Stack Error"];
    v14[0] = v8;
    v14[1] = &off_10031B940;
    v13[1] = @"Line";
    v13[2] = @"Method";
    id v9 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
    v14[2] = v9;
    v13[3] = NSDebugDescriptionErrorKey;
    id v10 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 3323];
    v14[3] = v10;
    id v11 = +[NSDictionary dictionaryWithObjects:v14 forKeys:v13 count:4];
    id v12 = [v6 initWithDomain:v7 code:15 userInfo:v11];
    (*(void (**)(uint64_t, id))(v3 + 16))(v3, v12);
  }
}

void sub_1001005CC(uint64_t a1)
{
  __int16 v1 = *(void ***)(a1 + 32);
  char v2 = (void (**)(id, id))*(id *)(a1 + 40);
  if (v1)
  {
    if (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v1) == 2)
    {
      uint64_t v3 = sub_10020EC8C(v1[46], @"GPIO toggle", 1uLL);
      if (!v3)
      {
        if (sub_1001EAEF4(v1[46]))
        {
          id v4 = 0;
        }
        else
        {
          id v27 = objc_alloc((Class)NSError);
          CFStringRef v28 = +[NSString stringWithUTF8String:"nfcd"];
          NSErrorUserInfoKey v35 = NSLocalizedDescriptionKey;
          NSErrorUserInfoKey v29 = +[NSString stringWithUTF8String:"Stack Error"];
          *(void *)long long buf = v29;
          *(void *)__int16 v41 = &off_10031B988;
          CFStringRef v36 = @"Line";
          CFStringRef v37 = @"Method";
          id v30 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_toggleGPIO:completion:")];
          *(void *)&v41[8] = v30;
          CFStringRef v38 = (const __CFString *)NSDebugDescriptionErrorKey;
          id v31 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_toggleGPIO:completion:"), 3357];
          *(void *)&v41[16] = v31;
          int v32 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v35 count:4];
          id v4 = [v27 initWithDomain:v28 code:15 userInfo:v32];
        }
        v2[2](v2, v4);
        sub_1002114AC(v1[46], @"GPIO toggle");
        goto LABEL_21;
      }
      id v4 = (id)v3;
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        id v6 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(v1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(v1);
        Name = sel_getName("_sync_toggleGPIO:completion:");
        uint64_t v9 = 45;
        if (isMetaClass) {
          uint64_t v9 = 43;
        }
        v6(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v9, ClassName, Name, 3350, v4);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v10 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        id v11 = object_getClass(v1);
        if (class_isMetaClass(v11)) {
          int v12 = 43;
        }
        else {
          int v12 = 45;
        }
        *(_DWORD *)long long buf = 67110146;
        *(_DWORD *)&uint8_t buf[4] = v12;
        *(_WORD *)__int16 v41 = 2082;
        *(void *)&v41[2] = object_getClassName(v1);
        *(_WORD *)&v41[10] = 2082;
        *(void *)&v41[12] = sel_getName("_sync_toggleGPIO:completion:");
        *(_WORD *)&v41[20] = 1024;
        *(_DWORD *)&v41[22] = 3350;
        *(_WORD *)&v41[26] = 2112;
        *(void *)&v41[28] = v4;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
      }

      id v13 = objc_alloc((Class)NSError);
      id v14 = +[NSString stringWithUTF8String:"nfcd"];
      id v15 = [v4 code];
      NSErrorUserInfoKey v35 = NSLocalizedDescriptionKey;
      if ((uint64_t)[v4 code] > 70) {
        uint64_t v16 = 71;
      }
      else {
        uint64_t v16 = (uint64_t)[v4 code];
      }
      uint64_t v22 = +[NSString stringWithUTF8String:off_100304250[v16]];
      *(void *)long long buf = v22;
      *(void *)__int16 v41 = v4;
      CFStringRef v36 = (const __CFString *)NSUnderlyingErrorKey;
      CFStringRef v37 = @"Line";
      *(void *)&v41[8] = &off_10031B970;
      CFStringRef v38 = @"Method";
      id v23 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_toggleGPIO:completion:")];
      *(void *)&v41[16] = v23;
      NSErrorUserInfoKey v39 = NSDebugDescriptionErrorKey;
      id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_toggleGPIO:completion:"), 3351];
      *(void *)&v41[24] = v24;
      __int16 v25 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v35 count:5];
      id v26 = [v13 initWithDomain:v14 code:v15 userInfo:v25];
      v2[2](v2, v26);
    }
    else
    {
      id v17 = objc_alloc((Class)NSError);
      id v4 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v35 = NSLocalizedDescriptionKey;
      id v14 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
      *(void *)long long buf = v14;
      *(void *)__int16 v41 = &off_10031B958;
      CFStringRef v36 = @"Line";
      CFStringRef v37 = @"Method";
      id v18 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_toggleGPIO:completion:")];
      *(void *)&v41[8] = v18;
      CFStringRef v38 = (const __CFString *)NSDebugDescriptionErrorKey;
      id v19 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_toggleGPIO:completion:"), 3344];
      *(void *)&v41[16] = v19;
      uint64_t v20 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v35 count:4];
      id v21 = [v17 initWithDomain:v4 code:58 userInfo:v20];
      v2[2](v2, v21);
    }
LABEL_21:
  }
}

void sub_100100CD8(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  char v2 = *(void **)(a1 + 48);
  id v3 = *(id *)(a1 + 40);
  id v4 = v2;
  if (v1)
  {
    if (-[_NFHardwareManager getPrimaryHardwareState]_0(v1) == 2
      || -[_NFHardwareManager getPrimaryHardwareState]_0(v1) == 5)
    {
      uint64_t v5 = [v3 NF_whitelistChecker];
      if ([v5 hceAccess])
      {
        if (!*(void *)(v1 + 112) || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t Logger = NFLogGetLogger();
          if (Logger)
          {
            id v30 = (void (*)(uint64_t, const char *, ...))Logger;
            Class = object_getClass((id)v1);
            BOOL isMetaClass = class_isMetaClass(Class);
            ClassName = object_getClassName((id)v1);
            Name = sel_getName("_sync_getHostCardEmulationLogForConnection:completion:");
            uint64_t v35 = 45;
            if (isMetaClass) {
              uint64_t v35 = 43;
            }
            v30(6, "%c[%{public}s %{public}s]:%i %{public}@", v35, ClassName, Name, 3393, *(void *)(v1 + 200));
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          CFStringRef v36 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
          {
            CFStringRef v37 = object_getClass((id)v1);
            if (class_isMetaClass(v37)) {
              int v38 = 43;
            }
            else {
              int v38 = 45;
            }
            NSErrorUserInfoKey v39 = object_getClassName((id)v1);
            id v40 = sel_getName("_sync_getHostCardEmulationLogForConnection:completion:");
            uint64_t v41 = *(void *)(v1 + 200);
            *(_DWORD *)long long buf = 67110146;
            *(_DWORD *)&uint8_t buf[4] = v38;
            __int16 v49 = 2082;
            id v50 = v39;
            __int16 v51 = 2082;
            CFStringRef v52 = v40;
            __int16 v53 = 1024;
            int v54 = 3393;
            __int16 v55 = 2114;
            uint64_t v56 = v41;
            _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
          }

          (*((void (**)(id, void, void))v4 + 2))(v4, *(void *)(v1 + 200), 0);
          goto LABEL_39;
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v6 = NFLogGetLogger();
        if (v6)
        {
          id v7 = (void (*)(uint64_t, const char *, ...))v6;
          id v8 = object_getClass((id)v1);
          BOOL v9 = class_isMetaClass(v8);
          id v10 = object_getClassName((id)v1);
          id v46 = sel_getName("_sync_getHostCardEmulationLogForConnection:completion:");
          uint64_t v11 = 45;
          if (v9) {
            uint64_t v11 = 43;
          }
          v7(6, "%c[%{public}s %{public}s]:%i Getting host card emulation log from session", v11, v10, v46, 3388);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v12 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          id v13 = object_getClass((id)v1);
          if (class_isMetaClass(v13)) {
            int v14 = 43;
          }
          else {
            int v14 = 45;
          }
          *(_DWORD *)long long buf = 67109890;
          *(_DWORD *)&uint8_t buf[4] = v14;
          __int16 v49 = 2082;
          id v50 = object_getClassName((id)v1);
          __int16 v51 = 2082;
          CFStringRef v52 = sel_getName("_sync_getHostCardEmulationLogForConnection:completion:");
          __int16 v53 = 1024;
          int v54 = 3388;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Getting host card emulation log from session", buf, 0x22u);
        }

        id v15 = [*(id *)(v1 + 112) hostCardEmulationLog];
        (*((void (**)(id, void *, void))v4 + 2))(v4, v15, 0);
      }
      else
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v16 = NFLogGetLogger();
        if (v16)
        {
          id v17 = (void (*)(uint64_t, const char *, ...))v16;
          id v18 = object_getClass((id)v1);
          BOOL v19 = class_isMetaClass(v18);
          uint64_t v20 = object_getClassName((id)v1);
          uint64_t v47 = sel_getName("_sync_getHostCardEmulationLogForConnection:completion:");
          uint64_t v21 = 45;
          if (v19) {
            uint64_t v21 = 43;
          }
          v17(3, "%c[%{public}s %{public}s]:%i Invalid entitlements, requiring HCE access", v21, v20, v47, 3382);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v22 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
        {
          id v23 = object_getClass((id)v1);
          if (class_isMetaClass(v23)) {
            int v24 = 43;
          }
          else {
            int v24 = 45;
          }
          *(_DWORD *)long long buf = 67109890;
          *(_DWORD *)&uint8_t buf[4] = v24;
          __int16 v49 = 2082;
          id v50 = object_getClassName((id)v1);
          __int16 v51 = 2082;
          CFStringRef v52 = sel_getName("_sync_getHostCardEmulationLogForConnection:completion:");
          __int16 v53 = 1024;
          int v54 = 3382;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid entitlements, requiring HCE access", buf, 0x22u);
        }

        id v25 = objc_alloc((Class)NSError);
        id v15 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v57 = NSLocalizedDescriptionKey;
        id v26 = +[NSString stringWithUTF8String:"Not entitled"];
        *(void *)long long buf = v26;
        id v27 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v57 count:1];
        id v28 = [v25 initWithDomain:v15 code:32 userInfo:v27];
        (*((void (**)(id, void, id))v4 + 2))(v4, 0, v28);
      }
    }
    else
    {
      id v42 = objc_alloc((Class)NSError);
      uint64_t v5 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v57 = NSLocalizedDescriptionKey;
      id v43 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
      *(void *)long long buf = v43;
      id v44 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v57 count:1];
      id v45 = [v42 initWithDomain:v5 code:58 userInfo:v44];
      (*((void (**)(id, void, id))v4 + 2))(v4, 0, v45);
    }
LABEL_39:
  }
}

void sub_100101498(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v7 = 45;
    if (isMetaClass) {
      uint64_t v7 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i ", v7, ClassName, Name, 3413);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v8 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v9 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v9)) {
      int v10 = 43;
    }
    else {
      int v10 = 45;
    }
    uint64_t v11 = object_getClassName(*(id *)(a1 + 32));
    int v12 = sel_getName(*(SEL *)(a1 + 56));
    *(_DWORD *)long long buf = 67109890;
    int v18 = v10;
    __int16 v19 = 2082;
    uint64_t v20 = v11;
    __int16 v21 = 2082;
    uint64_t v22 = v12;
    __int16 v23 = 1024;
    int v24 = 3413;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  uint64_t v13 = sub_100218EC4(*(void **)(*(void *)(a1 + 32) + 368), *(void **)(a1 + 40));
  uint64_t v14 = *(void *)(*(void *)(a1 + 48) + 8);
  id v15 = *(void **)(v14 + 40);
  *(void *)(v14 + 40) = v13;
}

id sub_100101638(uint64_t a1)
{
  return [*(id *)(a1 + 32) maybeStartNextSession];
}

void sub_100101BDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_100101C14(uint64_t a1)
{
  if ([*(id *)(a1 + 32) isEqual:*(void *)(*(void *)(a1 + 40) + 376)])
  {
    uint64_t v2 = sub_10002A260(*(void **)(*(void *)(a1 + 40) + 368));
    uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8);
    id v4 = *(void **)(v3 + 40);
    *(void *)(v3 + 40) = v2;
  }
  else
  {
    id v5 = objc_alloc((Class)NSError);
    uint64_t v6 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v13 = NSLocalizedDescriptionKey;
    uint64_t v7 = +[NSString stringWithUTF8String:"SE not available"];
    uint64_t v14 = v7;
    id v8 = +[NSDictionary dictionaryWithObjects:&v14 forKeys:&v13 count:1];
    id v9 = [v5 initWithDomain:v6 code:35 userInfo:v8];
    uint64_t v10 = *(void *)(*(void *)(a1 + 48) + 8);
    uint64_t v11 = *(void **)(v10 + 40);
    *(void *)(v10 + 40) = v9;
  }
  return *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) == 0;
}

void sub_100101E18(uint64_t a1)
{
  if (-[_NFHardwareManager getPrimaryHardwareState]_0(*(void *)(a1 + 32)) == 2)
  {
    id v2 = objc_alloc((Class)NSError);
    uint64_t v3 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
    id v4 = +[NSString stringWithUTF8String:"Feature Not Supported"];
    NSErrorUserInfoKey v13 = v4;
    id v5 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
    id v6 = [v2 initWithDomain:v3 code:14 userInfo:v5];

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    uint64_t v7 = *(void *)(a1 + 40);
    id v8 = objc_alloc((Class)NSError);
    id v6 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
    id v9 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
    id v15 = v9;
    uint64_t v10 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
    id v11 = [v8 initWithDomain:v6 code:58 userInfo:v10];
    (*(void (**)(uint64_t, id))(v7 + 16))(v7, v11);
  }
}

void sub_100102090(uint64_t a1)
{
  if (-[_NFHardwareManager getPrimaryHardwareState]_0(*(void *)(a1 + 32)) == 2)
  {
    id v2 = objc_alloc((Class)NSError);
    uint64_t v3 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v12 = NSLocalizedDescriptionKey;
    id v4 = +[NSString stringWithUTF8String:"Feature Not Supported"];
    NSErrorUserInfoKey v13 = v4;
    id v5 = +[NSDictionary dictionaryWithObjects:&v13 forKeys:&v12 count:1];
    id v6 = [v2 initWithDomain:v3 code:14 userInfo:v5];

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    uint64_t v7 = *(void *)(a1 + 40);
    id v8 = objc_alloc((Class)NSError);
    id v6 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v14 = NSLocalizedDescriptionKey;
    id v9 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
    id v15 = v9;
    uint64_t v10 = +[NSDictionary dictionaryWithObjects:&v15 forKeys:&v14 count:1];
    id v11 = [v8 initWithDomain:v6 code:58 userInfo:v10];
    (*(void (**)(uint64_t, id))(v7 + 16))(v7, v11);
  }
}

void sub_100102308(uint64_t a1)
{
  if (-[_NFHardwareManager getPrimaryHardwareState]_0(*(void *)(a1 + 32)) == 2)
  {
    id v2 = *(void **)(a1 + 32);
    id v9 = 0;
    [v2 nfcRadioEnabled:&v9 showUIPopup:0];
    id v3 = v9;
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    uint64_t v4 = *(void *)(a1 + 40);
    id v5 = objc_alloc((Class)NSError);
    id v3 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v10 = NSLocalizedDescriptionKey;
    id v6 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
    id v11 = v6;
    uint64_t v7 = +[NSDictionary dictionaryWithObjects:&v11 forKeys:&v10 count:1];
    id v8 = [v5 initWithDomain:v3 code:58 userInfo:v7];
    (*(void (**)(uint64_t, void, id))(v4 + 16))(v4, 0, v8);
  }
}

void sub_100102558(uint64_t a1)
{
  if (-[_NFHardwareManager getPrimaryHardwareState]_0(*(void *)(a1 + 32)) != 2)
  {
    uint64_t v31 = *(void *)(a1 + 48);
    id v32 = objc_alloc((Class)NSError);
    id v2 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v119 = NSLocalizedDescriptionKey;
    id v3 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
    id v120 = v3;
    int v24 = +[NSDictionary dictionaryWithObjects:&v120 forKeys:&v119 count:1];
    id v33 = [v32 initWithDomain:v2 code:58 userInfo:v24];
    (*(void (**)(uint64_t, id))(v31 + 16))(v31, v33);

    goto LABEL_55;
  }
  id v2 = [*(id *)(a1 + 40) NF_whitelistChecker];
  if (([v2 radioToggle] & 1) == 0)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v35 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v39 = 45;
      if (isMetaClass) {
        uint64_t v39 = 43;
      }
      v35(3, "%c[%{public}s %{public}s]:%i Invalid entitlements, missing radio toggle", v39, ClassName, Name, 3921);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v40 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
    {
      uint64_t v41 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v41)) {
        int v42 = 43;
      }
      else {
        int v42 = 45;
      }
      id v43 = object_getClassName(*(id *)(a1 + 32));
      id v44 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)long long buf = 67109890;
      int v106 = v42;
      __int16 v107 = 2082;
      int v108 = v43;
      __int16 v109 = 2082;
      long long v110 = v44;
      __int16 v111 = 1024;
      int v112 = 3921;
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid entitlements, missing radio toggle", buf, 0x22u);
    }

    uint64_t v45 = *(void *)(a1 + 48);
    id v46 = objc_alloc((Class)NSError);
    id v3 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v117 = NSLocalizedDescriptionKey;
    int v24 = +[NSString stringWithUTF8String:"Not entitled"];
    long long v118 = v24;
    uint64_t v47 = &v118;
    CFStringRef v48 = &v117;
    goto LABEL_53;
  }
  if (*(void *)(*(void *)(a1 + 32) + 288) == -1)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v49 = NFLogGetLogger();
    if (v49)
    {
      id v50 = (void (*)(uint64_t, const char *, ...))v49;
      __int16 v51 = object_getClass(*(id *)(a1 + 32));
      BOOL v52 = class_isMetaClass(v51);
      __int16 v53 = object_getClassName(*(id *)(a1 + 32));
      id v94 = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v54 = 45;
      if (v52) {
        uint64_t v54 = 43;
      }
      v50(3, "%c[%{public}s %{public}s]:%i Radio disabled by mobileconfig", v54, v53, v94, 3927);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v55 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
    {
      uint64_t v56 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v56)) {
        int v57 = 43;
      }
      else {
        int v57 = 45;
      }
      __int16 v58 = object_getClassName(*(id *)(a1 + 32));
      id v59 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)long long buf = 67109890;
      int v106 = v57;
      __int16 v107 = 2082;
      int v108 = v58;
      __int16 v109 = 2082;
      long long v110 = v59;
      __int16 v111 = 1024;
      int v112 = 3927;
      _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Radio disabled by mobileconfig", buf, 0x22u);
    }

    uint64_t v45 = *(void *)(a1 + 48);
    id v46 = objc_alloc((Class)NSError);
    id v3 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v115 = NSLocalizedDescriptionKey;
    int v24 = +[NSString stringWithUTF8String:"Not entitled"];
    long long v116 = v24;
    uint64_t v47 = &v116;
    CFStringRef v48 = &v115;
LABEL_53:
    __int16 v60 = +[NSDictionary dictionaryWithObjects:v47 forKeys:v48 count:1];
    id v61 = [v46 initWithDomain:v3 code:32 userInfo:v60];
    (*(void (**)(uint64_t, id))(v45 + 16))(v45, v61);

LABEL_54:
    goto LABEL_55;
  }
  id v3 = [objc_alloc((Class)NSUserDefaults) initWithSuiteName:@"com.apple.stockholm"];
  if ((NFIsChinaSku() & 1) == 0)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v62 = NFLogGetLogger();
    if (v62)
    {
      int v63 = (void (*)(uint64_t, const char *, ...))v62;
      __int16 v64 = object_getClass(*(id *)(a1 + 32));
      BOOL v65 = class_isMetaClass(v64);
      __int16 v66 = object_getClassName(*(id *)(a1 + 32));
      dispatch_time_t v95 = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v67 = 45;
      if (v65) {
        uint64_t v67 = 43;
      }
      v63(3, "%c[%{public}s %{public}s]:%i Feature not supported on this device", v67, v66, v95, 3935);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v68 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
    {
      int v69 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v69)) {
        int v70 = 43;
      }
      else {
        int v70 = 45;
      }
      NSErrorUserInfoKey v71 = object_getClassName(*(id *)(a1 + 32));
      double v72 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)long long buf = 67109890;
      int v106 = v70;
      __int16 v107 = 2082;
      int v108 = v71;
      __int16 v109 = 2082;
      long long v110 = v72;
      __int16 v111 = 1024;
      int v112 = 3935;
      _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Feature not supported on this device", buf, 0x22u);
    }

    if (!NFIsInternalBuild()) {
      goto LABEL_82;
    }
    SEL v73 = [v3 objectForKey:@"forceChinaSku"];

    if (!v73) {
      goto LABEL_82;
    }
    unsigned int v74 = [v3 BOOLForKey:@"forceChinaSku"];
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v75 = NFLogGetLogger();
    if (v75)
    {
      BOOL v76 = (void (*)(uint64_t, const char *, ...))v75;
      __int16 v77 = object_getClass(*(id *)(a1 + 32));
      BOOL v78 = class_isMetaClass(v77);
      __int16 v79 = object_getClassName(*(id *)(a1 + 32));
      int v80 = sel_getName(*(SEL *)(a1 + 56));
      if (v74) {
        CFStringRef v81 = @"on";
      }
      else {
        CFStringRef v81 = @"off";
      }
      uint64_t v82 = 45;
      if (v78) {
        uint64_t v82 = 43;
      }
      v76(5, "%c[%{public}s %{public}s]:%i Force China Sku: %{public}@", v82, v79, v80, 3941, v81);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v83 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
    {
      id v84 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v84)) {
        int v85 = 43;
      }
      else {
        int v85 = 45;
      }
      uint64_t v86 = object_getClassName(*(id *)(a1 + 32));
      id v87 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)long long buf = 67110146;
      CFStringRef v88 = @"on";
      if (!v74) {
        CFStringRef v88 = @"off";
      }
      int v106 = v85;
      __int16 v107 = 2082;
      int v108 = v86;
      __int16 v109 = 2082;
      long long v110 = v87;
      __int16 v111 = 1024;
      int v112 = 3941;
      __int16 v113 = 2114;
      CFStringRef v114 = v88;
      _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Force China Sku: %{public}@", buf, 0x2Cu);
    }

    if ((v74 & 1) == 0)
    {
LABEL_82:
      uint64_t v89 = *(void *)(a1 + 48);
      id v90 = objc_alloc((Class)NSError);
      int v24 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v103 = NSLocalizedDescriptionKey;
      __int16 v60 = +[NSString stringWithUTF8String:"Feature Not Supported"];
      uint64_t v104 = v60;
      int v91 = +[NSDictionary dictionaryWithObjects:&v104 forKeys:&v103 count:1];
      id v92 = [v90 initWithDomain:v24 code:14 userInfo:v91];
      (*(void (**)(uint64_t, id))(v89 + 16))(v89, v92);

      goto LABEL_54;
    }
  }
  [v3 setBool:*(unsigned __int8 *)(a1 + 64) forKey:@"nfcRadioEnabled"];
  [v3 synchronize];
  if (!*(unsigned char *)(a1 + 64)) {
    id v4 = sub_1000429A8(*(void *)(*(void *)(a1 + 32) + 24), 0);
  }
  id v5 = *(id *)(a1 + 32);
  objc_sync_enter(v5);
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = *(void *)(v6 + 288);
  uint64_t v8 = *(unsigned __int8 *)(a1 + 64);
  *(void *)(v6 + 288) = v8;
  objc_sync_exit(v5);

  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFLogGetLogger();
  if (v9)
  {
    NSErrorUserInfoKey v10 = (void (*)(uint64_t, const char *, ...))v9;
    id v11 = object_getClass(*(id *)(a1 + 32));
    BOOL v12 = class_isMetaClass(v11);
    NSErrorUserInfoKey v13 = object_getClassName(*(id *)(a1 + 32));
    NSErrorUserInfoKey v14 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v15 = 45;
    if (v12) {
      uint64_t v15 = 43;
    }
    v10(6, "%c[%{public}s %{public}s]:%i %d", v15, v13, v14, 3965, *(unsigned __int8 *)(a1 + 64));
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v16 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    id v17 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v17)) {
      int v18 = 43;
    }
    else {
      int v18 = 45;
    }
    __int16 v19 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v20 = sel_getName(*(SEL *)(a1 + 56));
    int v21 = *(unsigned __int8 *)(a1 + 64);
    *(_DWORD *)long long buf = 67110146;
    int v106 = v18;
    __int16 v107 = 2082;
    int v108 = v19;
    __int16 v109 = 2082;
    long long v110 = v20;
    __int16 v111 = 1024;
    int v112 = 3965;
    __int16 v113 = 1024;
    LODWORD(v114) = v21;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %d", buf, 0x28u);
  }

  CFStringRef v101 = @"radioIsEnabled";
  if (*(void *)(*(void *)(a1 + 32) + 288) == 1) {
    uint64_t v22 = &__kCFBooleanTrue;
  }
  else {
    uint64_t v22 = &__kCFBooleanFalse;
  }
  id v102 = v22;
  __int16 v23 = +[NSDictionary dictionaryWithObjects:&v102 forKeys:&v101 count:1];
  +[NFGeneralStatisticsCALogger updateGeneralDeviceStatistic:v23];

  if (v7 != v8) {
    +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:&off_100323078];
  }
  (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  int v24 = sub_10000B134(*(id **)(a1 + 32));
  long long v96 = 0u;
  long long v97 = 0u;
  long long v98 = 0u;
  long long v99 = 0u;
  id v25 = [v24 allValues];
  id v26 = [v25 countByEnumeratingWithState:&v96 objects:v100 count:16];
  if (v26)
  {
    id v27 = v26;
    uint64_t v28 = *(void *)v97;
    do
    {
      for (i = 0; i != v27; i = (char *)i + 1)
      {
        if (*(void *)v97 != v28) {
          objc_enumerationMutation(v25);
        }
        [*(id *)(*((void *)&v96 + 1) + 8 * i) didChangeRadioState:*(unsigned __int8 *)(a1 + 64)];
      }
      id v27 = [v25 countByEnumeratingWithState:&v96 objects:v100 count:16];
    }
    while (v27);
  }

  if (*(unsigned char *)(a1 + 64)) {
    id v30 = @"1";
  }
  else {
    id v30 = @"0";
  }
  sub_1000FA94C(*(void **)(a1 + 32), (uint64_t)"com.apple.stockhom.radio.stateChanged", v30);
  [*(id *)(a1 + 32) maybeStartNextSession];
LABEL_55:
}

void sub_100103148(uint64_t a1)
{
  if (-[_NFHardwareManager getPrimaryHardwareState]_0(*(void *)(a1 + 32)) == 2)
  {
    uint64_t v2 = sub_10020EC8C(*(void **)(*(void *)(a1 + 32) + 368), @"GetTemperature", 1uLL);
    if (v2)
    {
      id v3 = (void *)v2;
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        id v5 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(*(id *)(a1 + 32));
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(*(id *)(a1 + 32));
        Name = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v8 = 45;
        if (isMetaClass) {
          uint64_t v8 = 43;
        }
        v5(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v8, ClassName, Name, 4003, v3);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v9 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        NSErrorUserInfoKey v10 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v10)) {
          int v11 = 43;
        }
        else {
          int v11 = 45;
        }
        BOOL v12 = object_getClassName(*(id *)(a1 + 32));
        NSErrorUserInfoKey v13 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)long long buf = 67110146;
        int v48 = v11;
        __int16 v49 = 2082;
        id v50 = v12;
        __int16 v51 = 2082;
        BOOL v52 = v13;
        __int16 v53 = 1024;
        int v54 = 4003;
        __int16 v55 = 2112;
        uint64_t v56 = v3;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
      }

      uint64_t v14 = *(void *)(a1 + 40);
      id v15 = objc_alloc((Class)NSError);
      uint64_t v16 = +[NSString stringWithUTF8String:"nfcd"];
      id v17 = [v3 code];
      v45[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[v3 code] > 70) {
        uint64_t v18 = 71;
      }
      else {
        uint64_t v18 = (uint64_t)[v3 code];
      }
      id v30 = +[NSString stringWithUTF8String:off_100304250[v18]];
      v46[0] = v30;
      v46[1] = v3;
      v45[1] = NSUnderlyingErrorKey;
      v45[2] = @"Line";
      v46[2] = &off_10031B9B8;
      v45[3] = @"Method";
      id v31 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
      v46[3] = v31;
      v45[4] = NSDebugDescriptionErrorKey;
      id v32 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 4004];
      v46[4] = v32;
      id v33 = +[NSDictionary dictionaryWithObjects:v46 forKeys:v45 count:5];
      id v34 = [v15 initWithDomain:v16 code:v17 userInfo:v33];
      (*(void (**)(uint64_t, id, double))(v14 + 16))(v14, v34, 0.0);
    }
    else
    {
      id v3 = sub_100216688(*(void **)(*(void *)(a1 + 32) + 368));
      uint64_t v26 = *(void *)(a1 + 40);
      if (v3)
      {
        id v42 = objc_alloc((Class)NSError);
        id v27 = +[NSString stringWithUTF8String:"nfcd"];
        id v28 = [v3 code];
        v43[0] = NSLocalizedDescriptionKey;
        if ((uint64_t)[v3 code] > 70) {
          uint64_t v29 = 71;
        }
        else {
          uint64_t v29 = (uint64_t)[v3 code];
        }
        uint64_t v35 = +[NSString stringWithUTF8String:off_100304250[v29]];
        v44[0] = v35;
        v44[1] = v3;
        v43[1] = NSUnderlyingErrorKey;
        v43[2] = @"Line";
        v44[2] = &off_10031B9D0;
        v43[3] = @"Method";
        id v36 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
        v44[3] = v36;
        void v43[4] = NSDebugDescriptionErrorKey;
        id v37 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 4010];
        v44[4] = v37;
        int v38 = +[NSDictionary dictionaryWithObjects:v44 forKeys:v43 count:5];
        id v39 = [v42 initWithDomain:v27 code:v28 userInfo:v38];
        (*(void (**)(uint64_t, id, double))(v26 + 16))(v26, v39, 0.0);
      }
      else
      {
        (*(void (**)(void, void, double))(v26 + 16))(*(void *)(a1 + 40), 0, 0.0);
      }
      sub_1002114AC(*(void **)(*(void *)(a1 + 32) + 368), @"GetTemperature");
    }
  }
  else
  {
    uint64_t v19 = *(void *)(a1 + 40);
    id v20 = objc_alloc((Class)NSError);
    id v3 = +[NSString stringWithUTF8String:"nfcd"];
    v57[0] = NSLocalizedDescriptionKey;
    int v21 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
    v58[0] = v21;
    v58[1] = &off_10031B9A0;
    v57[1] = @"Line";
    v57[2] = @"Method";
    id v22 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
    v58[2] = v22;
    v57[3] = NSDebugDescriptionErrorKey;
    id v23 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 3997];
    v58[3] = v23;
    int v24 = +[NSDictionary dictionaryWithObjects:v58 forKeys:v57 count:4];
    id v25 = [v20 initWithDomain:v3 code:58 userInfo:v24];
    (*(void (**)(uint64_t, id, double))(v19 + 16))(v19, v25, 0.0);
  }
}

void sub_100103894(uint64_t a1)
{
}

void sub_1001038A0(void **a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    if (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)a1) == 2)
    {
      uint64_t v4 = sub_10020EC8C(a1[46], @"GetReaderProhibitTimer", 0);
      if (!v4)
      {
        *(void *)long long buf = 0;
        id v5 = sub_10002C934(a1[46]);
        if (v5)
        {
          id v23 = objc_alloc((Class)NSError);
          int v24 = +[NSString stringWithUTF8String:"nfcd"];
          v39[0] = NSLocalizedDescriptionKey;
          id v38 = [v5 code];
          if ((uint64_t)[v5 code] > 70) {
            uint64_t v25 = 71;
          }
          else {
            uint64_t v25 = (uint64_t)[v5 code];
          }
          id v31 = +[NSString stringWithUTF8String:off_100304250[v25]];
          v40[0] = v31;
          v40[1] = v5;
          v39[1] = NSUnderlyingErrorKey;
          v39[2] = @"Line";
          v40[2] = &off_10031BA18;
          v39[3] = @"Method";
          id v32 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_getReaderProhibitTimer:")];
          v40[3] = v32;
          v39[4] = NSDebugDescriptionErrorKey;
          id v33 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_getReaderProhibitTimer:"), 4043];
          v40[4] = v33;
          id v34 = +[NSDictionary dictionaryWithObjects:v40 forKeys:v39 count:5];
          id v35 = [v23 initWithDomain:v24 code:v38 userInfo:v34];
          (*((void (**)(id, void, void, void, id))v3 + 2))(v3, 0, 0, 0, v35);
        }
        else
        {
          (*((void (**)(id, void, void, void, void))v3 + 2))(v3, buf[0], buf[1], *(unsigned int *)&buf[4], 0);
        }
        sub_1002114AC(a1[46], @"GetReaderProhibitTimer");
        goto LABEL_22;
      }
      id v5 = (void *)v4;
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        uint64_t v7 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("_sync_getReaderProhibitTimer:");
        uint64_t v10 = 45;
        if (isMetaClass) {
          uint64_t v10 = 43;
        }
        v7(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v10, ClassName, Name, 4034, v5);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v11 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        BOOL v12 = object_getClass(a1);
        if (class_isMetaClass(v12)) {
          int v13 = 43;
        }
        else {
          int v13 = 45;
        }
        *(_DWORD *)long long buf = 67110146;
        *(_DWORD *)&uint8_t buf[4] = v13;
        __int16 v44 = 2082;
        uint64_t v45 = object_getClassName(a1);
        __int16 v46 = 2082;
        uint64_t v47 = sel_getName("_sync_getReaderProhibitTimer:");
        __int16 v48 = 1024;
        int v49 = 4034;
        __int16 v50 = 2112;
        __int16 v51 = v5;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
      }

      id v14 = objc_alloc((Class)NSError);
      id v15 = +[NSString stringWithUTF8String:"nfcd"];
      id v16 = [v5 code];
      v41[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[v5 code] > 70) {
        uint64_t v17 = 71;
      }
      else {
        uint64_t v17 = (uint64_t)[v5 code];
      }
      uint64_t v26 = +[NSString stringWithUTF8String:off_100304250[v17]];
      v42[0] = v26;
      v42[1] = v5;
      v41[1] = NSUnderlyingErrorKey;
      v41[2] = @"Line";
      v42[2] = &off_10031BA00;
      v41[3] = @"Method";
      id v27 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_getReaderProhibitTimer:")];
      v42[3] = v27;
      void v41[4] = NSDebugDescriptionErrorKey;
      id v28 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_getReaderProhibitTimer:"), 4035];
      v42[4] = v28;
      uint64_t v29 = +[NSDictionary dictionaryWithObjects:v42 forKeys:v41 count:5];
      id v30 = [v14 initWithDomain:v15 code:v16 userInfo:v29];
      (*((void (**)(id, void, void, void, id))v3 + 2))(v3, 0, 0, 0, v30);
    }
    else
    {
      id v18 = objc_alloc((Class)NSError);
      id v5 = +[NSString stringWithUTF8String:"nfcd"];
      v52[0] = NSLocalizedDescriptionKey;
      id v15 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
      v53[0] = v15;
      v53[1] = &off_10031B9E8;
      v52[1] = @"Line";
      v52[2] = @"Method";
      id v19 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_getReaderProhibitTimer:")];
      v53[2] = v19;
      v52[3] = NSDebugDescriptionErrorKey;
      id v20 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_getReaderProhibitTimer:"), 4028];
      v53[3] = v20;
      int v21 = +[NSDictionary dictionaryWithObjects:v53 forKeys:v52 count:4];
      id v22 = [v18 initWithDomain:v5 code:58 userInfo:v21];
      (*((void (**)(id, void, void, void, id))v3 + 2))(v3, 0, 0, 0, v22);
    }
LABEL_22:
  }
}

void sub_10010400C(uint64_t a1)
{
  uint64_t v1 = *(void ***)(a1 + 32);
  uint64_t v2 = (void (**)(id, void))*(id *)(a1 + 40);
  if (v1)
  {
    if (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v1) == 2)
    {
      id v3 = sub_10020EC8C(v1[46], @"LPM Debug", 1uLL);
      if (!v3)
      {
        sub_1001ABBA4(v1[46]);
        sub_1002114AC(v1[46], @"LPM Debug");
        v2[2](v2, 0);
LABEL_20:

        goto LABEL_21;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        id v5 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(v1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(v1);
        Name = sel_getName("_sync_dumpLPMDebugLogWithCompletion:");
        uint64_t v8 = 45;
        if (isMetaClass) {
          uint64_t v8 = 43;
        }
        v5(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v8, ClassName, Name, 4066, v3);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v9 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        uint64_t v10 = object_getClass(v1);
        if (class_isMetaClass(v10)) {
          int v11 = 43;
        }
        else {
          int v11 = 45;
        }
        *(_DWORD *)long long buf = 67110146;
        *(_DWORD *)&uint8_t buf[4] = v11;
        *(_WORD *)id v34 = 2082;
        *(void *)&v34[2] = object_getClassName(v1);
        *(_WORD *)&v34[10] = 2082;
        *(void *)&v34[12] = sel_getName("_sync_dumpLPMDebugLogWithCompletion:");
        *(_WORD *)&v34[20] = 1024;
        *(_DWORD *)&v34[22] = 4066;
        *(_WORD *)&v34[26] = 2112;
        *(void *)&v34[28] = v3;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
      }

      id v12 = objc_alloc((Class)NSError);
      int v13 = +[NSString stringWithUTF8String:"nfcd"];
      id v14 = [v3 code];
      NSErrorUserInfoKey v28 = NSLocalizedDescriptionKey;
      if ((uint64_t)[v3 code] > 70) {
        uint64_t v15 = 71;
      }
      else {
        uint64_t v15 = (uint64_t)[v3 code];
      }
      int v21 = +[NSString stringWithUTF8String:off_100304250[v15]];
      *(void *)long long buf = v21;
      *(void *)id v34 = v3;
      CFStringRef v29 = (const __CFString *)NSUnderlyingErrorKey;
      CFStringRef v30 = @"Line";
      *(void *)&v34[8] = &off_10031BA48;
      CFStringRef v31 = @"Method";
      id v22 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_dumpLPMDebugLogWithCompletion:")];
      *(void *)&v34[16] = v22;
      NSErrorUserInfoKey v32 = NSDebugDescriptionErrorKey;
      id v23 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_dumpLPMDebugLogWithCompletion:"), 4067];
      *(void *)&v34[24] = v23;
      int v24 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v28 count:5];
      id v25 = [v12 initWithDomain:v13 code:v14 userInfo:v24];
      ((void (**)(id, id))v2)[2](v2, v25);
    }
    else
    {
      id v16 = objc_alloc((Class)NSError);
      id v3 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v28 = NSLocalizedDescriptionKey;
      int v13 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
      *(void *)long long buf = v13;
      *(void *)id v34 = &off_10031BA30;
      CFStringRef v29 = @"Line";
      CFStringRef v30 = @"Method";
      id v17 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_dumpLPMDebugLogWithCompletion:")];
      *(void *)&v34[8] = v17;
      CFStringRef v31 = (const __CFString *)NSDebugDescriptionErrorKey;
      id v18 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_dumpLPMDebugLogWithCompletion:"), 4060];
      *(void *)&v34[16] = v18;
      id v19 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v28 count:4];
      id v20 = [v16 initWithDomain:v3 code:58 userInfo:v19];
      ((void (**)(id, id))v2)[2](v2, v20);
    }
    goto LABEL_20;
  }
LABEL_21:
}

void sub_1001045A8(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 48);
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = (void (**)(id, id))*(id *)(a1 + 40);
  if (v2)
  {
    if (-[_NFHardwareManager getPrimaryHardwareState]_0(v2) != 2)
    {
      id v5 = objc_alloc((Class)NSError);
      uint64_t v4 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v40 = NSLocalizedDescriptionKey;
      uint64_t v6 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
      *(void *)long long buf = v6;
      uint64_t v7 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v40 count:1];
      uint64_t v8 = v5;
      uint64_t v9 = v4;
      uint64_t v10 = 58;
LABEL_27:
      id v30 = [v8 initWithDomain:v9 code:v10 userInfo:v7];
      v3[2](v3, v30);

      goto LABEL_28;
    }
    if ([*(id *)(v2 + 384) hasAntenna])
    {
      if (NFIsInternalBuild())
      {
        uint64_t v4 = sub_1001EAF70(*(void **)(v2 + 368), v1 != 0);
        v3[2](v3, v4);
LABEL_28:

        goto LABEL_29;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        id v22 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass((id)v2);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName((id)v2);
        Name = sel_getName("_sync_setChipscope:completion:");
        uint64_t v26 = 45;
        if (isMetaClass) {
          uint64_t v26 = 43;
        }
        v22(4, "%c[%{public}s %{public}s]:%i Not an internal build", v26, ClassName, Name, 4099);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v17 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        goto LABEL_26;
      }
      id v27 = object_getClass((id)v2);
      if (class_isMetaClass(v27)) {
        int v28 = 43;
      }
      else {
        int v28 = 45;
      }
      *(_DWORD *)long long buf = 67109890;
      *(_DWORD *)&uint8_t buf[4] = v28;
      __int16 v34 = 2082;
      id v35 = object_getClassName((id)v2);
      __int16 v36 = 2082;
      id v37 = sel_getName("_sync_setChipscope:completion:");
      __int16 v38 = 1024;
      int v39 = 4099;
      id v20 = "%c[%{public}s %{public}s]:%i Not an internal build";
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v11 = NFLogGetLogger();
      if (v11)
      {
        id v12 = (void (*)(uint64_t, const char *, ...))v11;
        int v13 = object_getClass((id)v2);
        BOOL v14 = class_isMetaClass(v13);
        uint64_t v15 = object_getClassName((id)v2);
        CFStringRef v31 = sel_getName("_sync_setChipscope:completion:");
        uint64_t v16 = 45;
        if (v14) {
          uint64_t v16 = 43;
        }
        v12(4, "%c[%{public}s %{public}s]:%i No antenna", v16, v15, v31, 4093);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v17 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v17, OS_LOG_TYPE_ERROR)) {
        goto LABEL_26;
      }
      id v18 = object_getClass((id)v2);
      if (class_isMetaClass(v18)) {
        int v19 = 43;
      }
      else {
        int v19 = 45;
      }
      *(_DWORD *)long long buf = 67109890;
      *(_DWORD *)&uint8_t buf[4] = v19;
      __int16 v34 = 2082;
      id v35 = object_getClassName((id)v2);
      __int16 v36 = 2082;
      id v37 = sel_getName("_sync_setChipscope:completion:");
      __int16 v38 = 1024;
      int v39 = 4093;
      id v20 = "%c[%{public}s %{public}s]:%i No antenna";
    }
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, v20, buf, 0x22u);
LABEL_26:

    id v29 = objc_alloc((Class)NSError);
    uint64_t v4 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v40 = NSLocalizedDescriptionKey;
    uint64_t v6 = +[NSString stringWithUTF8String:"Feature Not Supported"];
    *(void *)long long buf = v6;
    uint64_t v7 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v40 count:1];
    uint64_t v8 = v29;
    uint64_t v9 = v4;
    uint64_t v10 = 14;
    goto LABEL_27;
  }
LABEL_29:
}

void sub_100104A74(uint64_t a1)
{
  if (-[_NFHardwareManager getPrimaryHardwareState]_0(*(void *)(a1 + 32)) == 2
    || -[_NFHardwareManager getPrimaryHardwareState]_0(*(void *)(a1 + 32)) == 5)
  {
    uint64_t v2 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
    v2();
  }
  else
  {
    uint64_t v3 = *(void *)(a1 + 40);
    id v4 = objc_alloc((Class)NSError);
    id v5 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v9 = NSLocalizedDescriptionKey;
    uint64_t v6 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
    uint64_t v10 = v6;
    uint64_t v7 = +[NSDictionary dictionaryWithObjects:&v10 forKeys:&v9 count:1];
    id v8 = [v4 initWithDomain:v5 code:58 userInfo:v7];
    (*(void (**)(uint64_t, id, void))(v3 + 16))(v3, v8, 0);
  }
}

void sub_100104D00(void **a1)
{
}

void sub_100105080(uint64_t a1, uint64_t a2)
{
  switch(a2)
  {
    case 0:
      int v13 = +[NSAssertionHandler currentHandler];
      [v13 handleFailureInMethod:*(void *)(a1 + 56) object:*(void *)(a1 + 32) file:@"_NFHardwareManager.m" lineNumber:4164 description:@"Invalid state"];

      uint64_t v3 = *(void *)(a1 + 48);
      id v14 = objc_alloc((Class)NSError);
      id v5 = +[NSString stringWithUTF8String:"nfcd"];
      v22[0] = NSLocalizedDescriptionKey;
      uint64_t v6 = +[NSString stringWithUTF8String:"Invalid State"];
      v23[0] = v6;
      v23[1] = &off_10031BA90;
      v22[1] = @"Line";
      v22[2] = @"Method";
      id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
      v23[2] = v7;
      v22[3] = NSDebugDescriptionErrorKey;
      id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 4165];
      v23[3] = v8;
      NSErrorUserInfoKey v9 = +[NSDictionary dictionaryWithObjects:v23 forKeys:v22 count:4];
      uint64_t v10 = v14;
      uint64_t v11 = v5;
      uint64_t v12 = 12;
      goto LABEL_7;
    case 3:
      uint64_t v3 = *(void *)(a1 + 48);
      id v15 = objc_alloc((Class)NSError);
      id v5 = +[NSString stringWithUTF8String:"nfcd"];
      v24[0] = NSLocalizedDescriptionKey;
      uint64_t v6 = +[NSString stringWithUTF8String:"Session ineligible"];
      v25[0] = v6;
      v25[1] = &off_10031BA78;
      v24[1] = @"Line";
      v24[2] = @"Method";
      id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
      v25[2] = v7;
      v24[3] = NSDebugDescriptionErrorKey;
      id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 4161];
      v25[3] = v8;
      NSErrorUserInfoKey v9 = +[NSDictionary dictionaryWithObjects:v25 forKeys:v24 count:4];
      uint64_t v10 = v15;
      uint64_t v11 = v5;
      uint64_t v12 = 70;
      goto LABEL_7;
    case 2:
      uint64_t v3 = *(void *)(a1 + 48);
      id v4 = objc_alloc((Class)NSError);
      id v5 = +[NSString stringWithUTF8String:"nfcd"];
      v26[0] = NSLocalizedDescriptionKey;
      uint64_t v6 = +[NSString stringWithUTF8String:"TCC access denied"];
      v27[0] = v6;
      v27[1] = &off_10031BA60;
      v26[1] = @"Line";
      v26[2] = @"Method";
      id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
      v27[2] = v7;
      v26[3] = NSDebugDescriptionErrorKey;
      id v8 = [[objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 4158];
      v27[3] = v8;
      NSErrorUserInfoKey v9 = +[NSDictionary dictionaryWithObjects:v27 forKeys:v26 count:4];
      uint64_t v10 = v4;
      uint64_t v11 = v5;
      uint64_t v12 = 69;
LABEL_7:
      id v16 = [v10 initWithDomain:v11 code:v12 userInfo:v9];
      (*(void (**)(uint64_t, void, id))(v3 + 16))(v3, 0, v16);

      return;
  }
  uint64_t v17 = *(void *)(a1 + 32);
  id v18 = *(NSObject **)(v17 + 232);
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_10010554C;
  block[3] = &unk_100304588;
  block[4] = v17;
  id v20 = *(id *)(a1 + 40);
  id v21 = *(id *)(a1 + 48);
  dispatch_async(v18, block);
}

void sub_10010554C(uint64_t a1)
{
}

void sub_10010565C(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 32);
  if (v2 && ([v2 assertionTime], uint64_t v3 = objc_claimAutoreleasedReturnValue(), v3, v3))
  {
    id v5 = *(void **)(a1 + 32);
    id v4 = *(void **)(a1 + 40);
    uint64_t v6 = *(void **)(a1 + 48);
    id v7 = *(void **)(a1 + 56);
    sub_10017F434(v4, v5, v6, v7);
  }
  else
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      NSErrorUserInfoKey v9 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 40));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 40));
      Name = sel_getName(*(SEL *)(a1 + 64));
      uint64_t v13 = 45;
      if (isMetaClass) {
        uint64_t v13 = 43;
      }
      v9(3, "%c[%{public}s %{public}s]:%i Invalid assertion", v13, ClassName, Name, 4183);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v14 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      id v15 = object_getClass(*(id *)(a1 + 40));
      if (class_isMetaClass(v15)) {
        int v16 = 43;
      }
      else {
        int v16 = 45;
      }
      uint64_t v17 = object_getClassName(*(id *)(a1 + 40));
      id v18 = sel_getName(*(SEL *)(a1 + 64));
      *(_DWORD *)long long buf = 67109890;
      int v31 = v16;
      __int16 v32 = 2082;
      id v33 = v17;
      __int16 v34 = 2082;
      id v35 = v18;
      __int16 v36 = 1024;
      int v37 = 4183;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid assertion", buf, 0x22u);
    }

    uint64_t v19 = *(void *)(a1 + 56);
    id v20 = objc_alloc((Class)NSError);
    id v21 = +[NSString stringWithUTF8String:"nfcd"];
    v28[0] = NSLocalizedDescriptionKey;
    id v22 = +[NSString stringWithUTF8String:"Invalid Parameter"];
    v29[0] = v22;
    v29[1] = &off_10031BAA8;
    v28[1] = @"Line";
    v28[2] = @"Method";
    id v23 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 64))];
    v29[2] = v23;
    v28[3] = NSDebugDescriptionErrorKey;
    id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 64)), 4184];
    v29[3] = v24;
    id v25 = +[NSDictionary dictionaryWithObjects:v29 forKeys:v28 count:4];
    id v26 = [v20 initWithDomain:v21 code:10 userInfo:v25];
    (*(void (**)(uint64_t, id))(v19 + 16))(v19, v26);
  }
}

void sub_1001065EC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100106E10(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2 || [*(id *)(v2 + 40) OSMode] != (id)2)
  {
    uint64_t v3 = *(void **)(a1 + 40);
    id v13 = objc_alloc((Class)NSError);
    id v5 = +[NSString stringWithUTF8String:"nfcd"];
    v35[0] = NSLocalizedDescriptionKey;
    uint64_t v6 = +[NSString stringWithUTF8String:"JCOP not available"];
    v36[0] = v6;
    v36[1] = &off_10031BAC0;
    v35[1] = @"Line";
    v35[2] = @"Method";
    id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v36[2] = v7;
    v35[3] = NSDebugDescriptionErrorKey;
    id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 4305];
    v36[3] = v8;
    NSErrorUserInfoKey v9 = +[NSDictionary dictionaryWithObjects:v36 forKeys:v35 count:4];
    uint64_t v10 = v13;
    uint64_t v11 = v5;
    uint64_t v12 = 53;
    goto LABEL_6;
  }
  if ([*(id *)(*(void *)(a1 + 32) + 40) restrictedMode])
  {
    uint64_t v3 = *(void **)(a1 + 40);
    id v4 = objc_alloc((Class)NSError);
    id v5 = +[NSString stringWithUTF8String:"nfcd"];
    v33[0] = NSLocalizedDescriptionKey;
    uint64_t v6 = +[NSString stringWithUTF8String:"Restricted Mode"];
    v34[0] = v6;
    v34[1] = &off_10031BAD8;
    v33[1] = @"Line";
    v33[2] = @"Method";
    id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v34[2] = v7;
    v33[3] = NSDebugDescriptionErrorKey;
    id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 4308];
    v34[3] = v8;
    NSErrorUserInfoKey v9 = +[NSDictionary dictionaryWithObjects:v34 forKeys:v33 count:4];
    uint64_t v10 = v4;
    uint64_t v11 = v5;
    uint64_t v12 = 24;
LABEL_6:
    id v14 = [v10 initWithDomain:v11 code:v12 userInfo:v9];
    [v3 didStartSession:v14];

    goto LABEL_7;
  }
  if (sub_1000F2880(*(void *)(a1 + 32)))
  {
    uint64_t v3 = *(void **)(a1 + 40);
    id v15 = objc_alloc((Class)NSError);
    id v5 = +[NSString stringWithUTF8String:"nfcd"];
    v31[0] = NSLocalizedDescriptionKey;
    uint64_t v6 = +[NSString stringWithUTF8String:"Applet Migration"];
    v32[0] = v6;
    v32[1] = &off_10031BAF0;
    v31[1] = @"Line";
    v31[2] = @"Method";
    id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v32[2] = v7;
    v31[3] = NSDebugDescriptionErrorKey;
    id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 4311];
    v32[3] = v8;
    NSErrorUserInfoKey v9 = +[NSDictionary dictionaryWithObjects:v32 forKeys:v31 count:4];
    uint64_t v10 = v15;
    uint64_t v11 = v5;
    uint64_t v12 = 26;
    goto LABEL_6;
  }
  if (sub_1000F28DC(*(void *)(a1 + 32)))
  {
    uint64_t v3 = *(void **)(a1 + 40);
    id v16 = objc_alloc((Class)NSError);
    id v5 = +[NSString stringWithUTF8String:"nfcd"];
    v29[0] = NSLocalizedDescriptionKey;
    uint64_t v6 = +[NSString stringWithUTF8String:"JCOP in OSU"];
    v30[0] = v6;
    v30[1] = &off_10031BB08;
    v29[1] = @"Line";
    v29[2] = @"Method";
    id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v30[2] = v7;
    v29[3] = NSDebugDescriptionErrorKey;
    id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 4314];
    v30[3] = v8;
    NSErrorUserInfoKey v9 = +[NSDictionary dictionaryWithObjects:v30 forKeys:v29 count:4];
    uint64_t v10 = v16;
    uint64_t v11 = v5;
    uint64_t v12 = 52;
    goto LABEL_6;
  }
  id v5 = sub_1001DBA28(*(id **)(a1 + 32), *(void **)(a1 + 40), *(void **)(a1 + 48), 0);
  if (v5)
  {
    uint64_t v17 = *(void **)(a1 + 40);
    id v18 = objc_alloc((Class)NSError);
    uint64_t v19 = +[NSString stringWithUTF8String:"nfcd"];
    id v20 = [v5 code];
    v27[0] = NSLocalizedDescriptionKey;
    if ((uint64_t)[v5 code] > 70) {
      uint64_t v21 = 71;
    }
    else {
      uint64_t v21 = (uint64_t)[v5 code];
    }
    id v22 = +[NSString stringWithUTF8String:off_100304250[v21]];
    v28[0] = v22;
    v28[1] = v5;
    v27[1] = NSUnderlyingErrorKey;
    v27[2] = @"Line";
    v28[2] = &off_10031BB20;
    v27[3] = @"Method";
    id v23 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v28[3] = v23;
    void v27[4] = NSDebugDescriptionErrorKey;
    id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 4318];
    void v28[4] = v24;
    id v25 = +[NSDictionary dictionaryWithObjects:v28 forKeys:v27 count:5];
    id v26 = [v18 initWithDomain:v19 code:v20 userInfo:v25];
    [v17 didStartSession:v26];
  }
  else
  {
    [*(id *)(a1 + 32) maybeStartNextSession];
  }
LABEL_7:
}

void sub_1001081F8(uint64_t a1)
{
  uint64_t v2 = sub_1001AED74();
  [*(id *)(a1 + 32) setPowerConsumptionReporter:v2];

  uint64_t v3 = *(void *)(a1 + 40);
  if (!v3 || [*(id *)(v3 + 40) OSMode] != (id)2)
  {
    id v4 = *(void **)(a1 + 32);
    id v14 = objc_alloc((Class)NSError);
    uint64_t v6 = +[NSString stringWithUTF8String:"nfcd"];
    v36[0] = NSLocalizedDescriptionKey;
    id v7 = +[NSString stringWithUTF8String:"JCOP not available"];
    v37[0] = v7;
    v37[1] = &off_10031BB38;
    v36[1] = @"Line";
    v36[2] = @"Method";
    id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v37[2] = v8;
    v36[3] = NSDebugDescriptionErrorKey;
    id v9 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 4394];
    v37[3] = v9;
    uint64_t v10 = +[NSDictionary dictionaryWithObjects:v37 forKeys:v36 count:4];
    uint64_t v11 = v14;
    uint64_t v12 = v6;
    uint64_t v13 = 53;
    goto LABEL_6;
  }
  if ([*(id *)(*(void *)(a1 + 40) + 40) restrictedMode])
  {
    id v4 = *(void **)(a1 + 32);
    id v5 = objc_alloc((Class)NSError);
    uint64_t v6 = +[NSString stringWithUTF8String:"nfcd"];
    v34[0] = NSLocalizedDescriptionKey;
    id v7 = +[NSString stringWithUTF8String:"Restricted Mode"];
    v35[0] = v7;
    v35[1] = &off_10031BB50;
    v34[1] = @"Line";
    v34[2] = @"Method";
    id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v35[2] = v8;
    v34[3] = NSDebugDescriptionErrorKey;
    id v9 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 4397];
    v35[3] = v9;
    uint64_t v10 = +[NSDictionary dictionaryWithObjects:v35 forKeys:v34 count:4];
    uint64_t v11 = v5;
    uint64_t v12 = v6;
    uint64_t v13 = 24;
LABEL_6:
    id v15 = [v11 initWithDomain:v12 code:v13 userInfo:v10];
    [v4 didStartSession:v15];

    goto LABEL_7;
  }
  if (sub_1000F2880(*(void *)(a1 + 40)))
  {
    id v4 = *(void **)(a1 + 32);
    id v16 = objc_alloc((Class)NSError);
    uint64_t v6 = +[NSString stringWithUTF8String:"nfcd"];
    v32[0] = NSLocalizedDescriptionKey;
    id v7 = +[NSString stringWithUTF8String:"Applet Migration"];
    v33[0] = v7;
    v33[1] = &off_10031BB68;
    v32[1] = @"Line";
    v32[2] = @"Method";
    id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v33[2] = v8;
    v32[3] = NSDebugDescriptionErrorKey;
    id v9 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 4400];
    v33[3] = v9;
    uint64_t v10 = +[NSDictionary dictionaryWithObjects:v33 forKeys:v32 count:4];
    uint64_t v11 = v16;
    uint64_t v12 = v6;
    uint64_t v13 = 26;
    goto LABEL_6;
  }
  if (sub_1000F28DC(*(void *)(a1 + 40)))
  {
    id v4 = *(void **)(a1 + 32);
    id v17 = objc_alloc((Class)NSError);
    uint64_t v6 = +[NSString stringWithUTF8String:"nfcd"];
    v30[0] = NSLocalizedDescriptionKey;
    id v7 = +[NSString stringWithUTF8String:"JCOP in OSU"];
    v31[0] = v7;
    v31[1] = &off_10031BB80;
    v30[1] = @"Line";
    v30[2] = @"Method";
    id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v31[2] = v8;
    v30[3] = NSDebugDescriptionErrorKey;
    id v9 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 4403];
    v31[3] = v9;
    uint64_t v10 = +[NSDictionary dictionaryWithObjects:v31 forKeys:v30 count:4];
    uint64_t v11 = v17;
    uint64_t v12 = v6;
    uint64_t v13 = 52;
    goto LABEL_6;
  }
  uint64_t v6 = sub_1001DBA28(*(id **)(a1 + 40), *(void **)(a1 + 32), *(void **)(a1 + 48), 0);
  if (v6)
  {
    id v18 = *(void **)(a1 + 32);
    id v19 = objc_alloc((Class)NSError);
    id v20 = +[NSString stringWithUTF8String:"nfcd"];
    id v21 = [v6 code];
    v28[0] = NSLocalizedDescriptionKey;
    if ((uint64_t)[v6 code] > 70) {
      uint64_t v22 = 71;
    }
    else {
      uint64_t v22 = (uint64_t)[v6 code];
    }
    id v23 = +[NSString stringWithUTF8String:off_100304250[v22]];
    v29[0] = v23;
    v29[1] = v6;
    v28[1] = NSUnderlyingErrorKey;
    v28[2] = @"Line";
    v29[2] = &off_10031BB98;
    v28[3] = @"Method";
    id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v29[3] = v24;
    void v28[4] = NSDebugDescriptionErrorKey;
    id v25 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 4407];
    void v29[4] = v25;
    id v26 = +[NSDictionary dictionaryWithObjects:v29 forKeys:v28 count:5];
    id v27 = [v19 initWithDomain:v20 code:v21 userInfo:v26];
    [v18 didStartSession:v27];
  }
  else
  {
    [*(id *)(a1 + 40) maybeStartNextSession];
  }
LABEL_7:
}

void sub_1001095A4(uint64_t a1)
{
  uint64_t v2 = sub_1001AED74();
  [*(id *)(a1 + 32) setPowerConsumptionReporter:v2];

  uint64_t v3 = *(void *)(a1 + 40);
  if (!v3 || [*(id *)(v3 + 40) OSMode] != (id)2)
  {
    id v4 = *(void **)(a1 + 32);
    id v14 = objc_alloc((Class)NSError);
    uint64_t v6 = +[NSString stringWithUTF8String:"nfcd"];
    v36[0] = NSLocalizedDescriptionKey;
    id v7 = +[NSString stringWithUTF8String:"JCOP not available"];
    v37[0] = v7;
    v37[1] = &off_10031BBB0;
    v36[1] = @"Line";
    v36[2] = @"Method";
    id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v37[2] = v8;
    v36[3] = NSDebugDescriptionErrorKey;
    id v9 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 4481];
    v37[3] = v9;
    uint64_t v10 = +[NSDictionary dictionaryWithObjects:v37 forKeys:v36 count:4];
    uint64_t v11 = v14;
    uint64_t v12 = v6;
    uint64_t v13 = 53;
    goto LABEL_6;
  }
  if ([*(id *)(*(void *)(a1 + 40) + 40) restrictedMode])
  {
    id v4 = *(void **)(a1 + 32);
    id v5 = objc_alloc((Class)NSError);
    uint64_t v6 = +[NSString stringWithUTF8String:"nfcd"];
    v34[0] = NSLocalizedDescriptionKey;
    id v7 = +[NSString stringWithUTF8String:"Restricted Mode"];
    v35[0] = v7;
    v35[1] = &off_10031BBC8;
    v34[1] = @"Line";
    v34[2] = @"Method";
    id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v35[2] = v8;
    v34[3] = NSDebugDescriptionErrorKey;
    id v9 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 4484];
    v35[3] = v9;
    uint64_t v10 = +[NSDictionary dictionaryWithObjects:v35 forKeys:v34 count:4];
    uint64_t v11 = v5;
    uint64_t v12 = v6;
    uint64_t v13 = 24;
LABEL_6:
    id v15 = [v11 initWithDomain:v12 code:v13 userInfo:v10];
    [v4 didStartSession:v15];

    goto LABEL_7;
  }
  if (sub_1000F2880(*(void *)(a1 + 40)))
  {
    id v4 = *(void **)(a1 + 32);
    id v16 = objc_alloc((Class)NSError);
    uint64_t v6 = +[NSString stringWithUTF8String:"nfcd"];
    v32[0] = NSLocalizedDescriptionKey;
    id v7 = +[NSString stringWithUTF8String:"Applet Migration"];
    v33[0] = v7;
    v33[1] = &off_10031BBE0;
    v32[1] = @"Line";
    v32[2] = @"Method";
    id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v33[2] = v8;
    v32[3] = NSDebugDescriptionErrorKey;
    id v9 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 4487];
    v33[3] = v9;
    uint64_t v10 = +[NSDictionary dictionaryWithObjects:v33 forKeys:v32 count:4];
    uint64_t v11 = v16;
    uint64_t v12 = v6;
    uint64_t v13 = 26;
    goto LABEL_6;
  }
  if (sub_1000F28DC(*(void *)(a1 + 40)))
  {
    id v4 = *(void **)(a1 + 32);
    id v17 = objc_alloc((Class)NSError);
    uint64_t v6 = +[NSString stringWithUTF8String:"nfcd"];
    v30[0] = NSLocalizedDescriptionKey;
    id v7 = +[NSString stringWithUTF8String:"JCOP in OSU"];
    v31[0] = v7;
    v31[1] = &off_10031BBF8;
    v30[1] = @"Line";
    v30[2] = @"Method";
    id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v31[2] = v8;
    v30[3] = NSDebugDescriptionErrorKey;
    id v9 = [[objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 4490];
    v31[3] = v9;
    uint64_t v10 = +[NSDictionary dictionaryWithObjects:v31 forKeys:v30 count:4];
    uint64_t v11 = v17;
    uint64_t v12 = v6;
    uint64_t v13 = 52;
    goto LABEL_6;
  }
  uint64_t v6 = sub_1001DBA28(*(id **)(a1 + 40), *(void **)(a1 + 32), *(void **)(a1 + 48), 0);
  if (v6)
  {
    id v18 = *(void **)(a1 + 32);
    id v19 = objc_alloc((Class)NSError);
    id v20 = +[NSString stringWithUTF8String:"nfcd"];
    id v21 = [v6 code];
    v28[0] = NSLocalizedDescriptionKey;
    if ((uint64_t)[v6 code] > 70) {
      uint64_t v22 = 71;
    }
    else {
      uint64_t v22 = (uint64_t)[v6 code];
    }
    id v23 = +[NSString stringWithUTF8String:off_100304250[v22]];
    v29[0] = v23;
    v29[1] = v6;
    v28[1] = NSUnderlyingErrorKey;
    v28[2] = @"Line";
    v29[2] = &off_10031BC10;
    v28[3] = @"Method";
    id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v29[3] = v24;
    void v28[4] = NSDebugDescriptionErrorKey;
    id v25 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 4494];
    void v29[4] = v25;
    id v26 = +[NSDictionary dictionaryWithObjects:v29 forKeys:v28 count:5];
    id v27 = [v19 initWithDomain:v20 code:v21 userInfo:v26];
    [v18 didStartSession:v27];
  }
  else
  {
    [*(id *)(a1 + 40) maybeStartNextSession];
  }
LABEL_7:
}

void sub_10010A630(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) objectForKey:@"session.allowInJBSL"];
  objc_opt_class();
  char isKindOfClass = objc_opt_isKindOfClass();

  if ((isKindOfClass & 1) != 0
    && ([*(id *)(a1 + 32) objectForKeyedSubscript:@"session.allowInJBSL"],
        id v4 = objc_claimAutoreleasedReturnValue(),
        unsigned __int8 v5 = [v4 BOOLValue],
        v4,
        (v5 & 1) != 0)
    || (uint64_t v6 = *(void *)(a1 + 40)) != 0 && [*(id *)(v6 + 40) OSMode] == (id)2)
  {
    id v7 = sub_1001DBA28(*(id **)(a1 + 40), *(void **)(a1 + 48), *(void **)(a1 + 56), 0);
    if (v7)
    {
      id v8 = *(void **)(a1 + 48);
      id v9 = objc_alloc((Class)NSError);
      uint64_t v10 = +[NSString stringWithUTF8String:"nfcd"];
      id v11 = [v7 code];
      v25[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[v7 code] > 70) {
        uint64_t v12 = 71;
      }
      else {
        uint64_t v12 = (uint64_t)[v7 code];
      }
      id v20 = +[NSString stringWithUTF8String:off_100304250[v12]];
      v26[0] = v20;
      v26[1] = v7;
      v25[1] = NSUnderlyingErrorKey;
      v25[2] = @"Line";
      v26[2] = &off_10031BC40;
      v25[3] = @"Method";
      id v21 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 64))];
      v26[3] = v21;
      void v25[4] = NSDebugDescriptionErrorKey;
      id v22 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 64)), 4581];
      void v26[4] = v22;
      id v23 = +[NSDictionary dictionaryWithObjects:v26 forKeys:v25 count:5];
      id v24 = [v9 initWithDomain:v10 code:v11 userInfo:v23];
      [v8 didStartSession:v24];
    }
    else
    {
      [*(id *)(a1 + 40) maybeStartNextSession];
    }
  }
  else
  {
    uint64_t v13 = *(void **)(a1 + 48);
    id v14 = objc_alloc((Class)NSError);
    id v7 = +[NSString stringWithUTF8String:"nfcd"];
    v27[0] = NSLocalizedDescriptionKey;
    id v15 = +[NSString stringWithUTF8String:"JCOP not available"];
    v28[0] = v15;
    v28[1] = &off_10031BC28;
    v27[1] = @"Line";
    v27[2] = @"Method";
    id v16 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 64))];
    v28[2] = v16;
    v27[3] = NSDebugDescriptionErrorKey;
    id v17 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 64)), 4577];
    v28[3] = v17;
    id v18 = +[NSDictionary dictionaryWithObjects:v28 forKeys:v27 count:4];
    id v19 = [v14 initWithDomain:v7 code:53 userInfo:v18];
    [v13 didStartSession:v19];
  }
}

void sub_10010B784(uint64_t a1)
{
  uint64_t v2 = sub_1001AED74();
  [*(id *)(a1 + 32) setPowerConsumptionReporter:v2];

  uint64_t v3 = *(void *)(a1 + 40);
  if (!v3 || [*(id *)(v3 + 40) OSMode] != (id)2)
  {
    id v4 = *(void **)(a1 + 32);
    id v14 = objc_alloc((Class)NSError);
    uint64_t v6 = +[NSString stringWithUTF8String:"nfcd"];
    v60[0] = NSLocalizedDescriptionKey;
    id v7 = +[NSString stringWithUTF8String:"JCOP not available"];
    v61[0] = v7;
    v61[1] = &off_10031BC58;
    v60[1] = @"Line";
    v60[2] = @"Method";
    id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v61[2] = v8;
    v60[3] = NSDebugDescriptionErrorKey;
    id v9 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 4664];
    v61[3] = v9;
    uint64_t v10 = +[NSDictionary dictionaryWithObjects:v61 forKeys:v60 count:4];
    id v11 = v14;
    uint64_t v12 = v6;
    uint64_t v13 = 53;
    goto LABEL_6;
  }
  if ([*(id *)(*(void *)(a1 + 40) + 40) restrictedMode])
  {
    id v4 = *(void **)(a1 + 32);
    id v5 = objc_alloc((Class)NSError);
    uint64_t v6 = +[NSString stringWithUTF8String:"nfcd"];
    v58[0] = NSLocalizedDescriptionKey;
    id v7 = +[NSString stringWithUTF8String:"Restricted Mode"];
    v59[0] = v7;
    v59[1] = &off_10031BC70;
    v58[1] = @"Line";
    v58[2] = @"Method";
    id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v59[2] = v8;
    v58[3] = NSDebugDescriptionErrorKey;
    id v9 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 4667];
    v59[3] = v9;
    uint64_t v10 = +[NSDictionary dictionaryWithObjects:v59 forKeys:v58 count:4];
    id v11 = v5;
    uint64_t v12 = v6;
    uint64_t v13 = 24;
LABEL_6:
    id v15 = [v11 initWithDomain:v12 code:v13 userInfo:v10];
    [v4 didStartSession:v15];

    goto LABEL_7;
  }
  if (sub_1000F2880(*(void *)(a1 + 40)))
  {
    id v4 = *(void **)(a1 + 32);
    id v16 = objc_alloc((Class)NSError);
    uint64_t v6 = +[NSString stringWithUTF8String:"nfcd"];
    v56[0] = NSLocalizedDescriptionKey;
    id v7 = +[NSString stringWithUTF8String:"Applet Migration"];
    v57[0] = v7;
    v57[1] = &off_10031BC88;
    v56[1] = @"Line";
    v56[2] = @"Method";
    id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v57[2] = v8;
    v56[3] = NSDebugDescriptionErrorKey;
    id v9 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 4670];
    v57[3] = v9;
    uint64_t v10 = +[NSDictionary dictionaryWithObjects:v57 forKeys:v56 count:4];
    id v11 = v16;
    uint64_t v12 = v6;
    uint64_t v13 = 26;
    goto LABEL_6;
  }
  if (sub_1000F28DC(*(void *)(a1 + 40)))
  {
    id v4 = *(void **)(a1 + 32);
    id v17 = objc_alloc((Class)NSError);
    uint64_t v6 = +[NSString stringWithUTF8String:"nfcd"];
    v54[0] = NSLocalizedDescriptionKey;
    id v7 = +[NSString stringWithUTF8String:"JCOP in OSU"];
    v55[0] = v7;
    v55[1] = &off_10031BCA0;
    v54[1] = @"Line";
    v54[2] = @"Method";
    id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v55[2] = v8;
    v54[3] = NSDebugDescriptionErrorKey;
    id v9 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 4673];
    v55[3] = v9;
    uint64_t v10 = +[NSDictionary dictionaryWithObjects:v55 forKeys:v54 count:4];
    id v11 = v17;
    uint64_t v12 = v6;
    uint64_t v13 = 52;
    goto LABEL_6;
  }
  char v43 = 0;
  uint64_t v6 = sub_1001DBA28(*(id **)(a1 + 40), *(void **)(a1 + 32), *(void **)(a1 + 48), &v43);
  id v18 = *(void **)(a1 + 32);
  if (v6)
  {
    id v19 = objc_alloc((Class)NSError);
    id v20 = +[NSString stringWithUTF8String:"nfcd"];
    id v21 = [v6 code];
    v52[0] = NSLocalizedDescriptionKey;
    if ((uint64_t)[v6 code] > 70) {
      uint64_t v22 = 71;
    }
    else {
      uint64_t v22 = (uint64_t)[v6 code];
    }
    int v37 = +[NSString stringWithUTF8String:off_100304250[v22]];
    v53[0] = v37;
    v53[1] = v6;
    v52[1] = NSUnderlyingErrorKey;
    v52[2] = @"Line";
    v53[2] = &off_10031BCB8;
    v52[3] = @"Method";
    id v38 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v53[3] = v38;
    void v52[4] = NSDebugDescriptionErrorKey;
    id v39 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 4678];
    void v53[4] = v39;
    NSErrorUserInfoKey v40 = +[NSDictionary dictionaryWithObjects:v53 forKeys:v52 count:5];
    id v41 = [v19 initWithDomain:v20 code:v21 userInfo:v40];
    [v18 didStartSession:v41];
  }
  else
  {
    unsigned int v23 = [*(id *)(a1 + 32) forceExpressExit];
    id v24 = *(void **)(a1 + 40);
    if (v23)
    {
      if (!v43)
      {
        uint64_t v25 = v24[3];
        if (v25)
        {
          if (*(unsigned char *)(v25 + 172))
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t Logger = NFLogGetLogger();
            if (Logger)
            {
              id v27 = (void (*)(uint64_t, const char *, ...))Logger;
              Class = object_getClass(*(id *)(a1 + 40));
              BOOL isMetaClass = class_isMetaClass(Class);
              ClassName = object_getClassName(*(id *)(a1 + 40));
              Name = sel_getName(*(SEL *)(a1 + 56));
              uint64_t v31 = 45;
              if (isMetaClass) {
                uint64_t v31 = 43;
              }
              v27(6, "%c[%{public}s %{public}s]:%i forceExpressExit is set - re-prioritiing the session.", v31, ClassName, Name, 4683);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            __int16 v32 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
            {
              id v33 = object_getClass(*(id *)(a1 + 40));
              if (class_isMetaClass(v33)) {
                int v34 = 43;
              }
              else {
                int v34 = 45;
              }
              id v35 = object_getClassName(*(id *)(a1 + 40));
              __int16 v36 = sel_getName(*(SEL *)(a1 + 56));
              *(_DWORD *)long long buf = 67109890;
              int v45 = v34;
              __int16 v46 = 2082;
              uint64_t v47 = v35;
              __int16 v48 = 2082;
              int v49 = v36;
              __int16 v50 = 1024;
              int v51 = 4683;
              _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i forceExpressExit is set - re-prioritiing the session.", buf, 0x22u);
            }

            [*(id *)(a1 + 40) prioritizeSession:*(void *)(a1 + 32)];
            id v24 = *(void **)(a1 + 40);
          }
        }
      }
    }
    [v24 maybeStartNextSession];
  }
LABEL_7:
}

id sub_10010D3FC(uint64_t a1)
{
  return [*(id *)(a1 + 32) maybeStartNextSession];
}

void sub_10010D4D4(uint64_t a1)
{
  int v2 = -[_NFHardwareManager getPrimaryHardwareState]_0(*(void *)(a1 + 32));
  if ((v2 & 5) != 1)
  {
    if (v2 == 4)
    {
      uint64_t v3 = *(void *)(a1 + 48);
      id v11 = objc_alloc((Class)NSError);
      id v5 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v29 = NSLocalizedDescriptionKey;
      uint64_t v6 = +[NSString stringWithUTF8String:"No NFC on device"];
      id v30 = v6;
      id v7 = +[NSDictionary dictionaryWithObjects:&v30 forKeys:&v29 count:1];
      id v8 = v11;
      id v9 = v5;
      uint64_t v10 = 57;
      goto LABEL_11;
    }
    if (*(void *)(a1 + 56) > 0x7FuLL || (*(void *)(a1 + 56) & 0x7FLL) == 0)
    {
      uint64_t v3 = *(void *)(a1 + 48);
      id v13 = objc_alloc((Class)NSError);
      id v5 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v25 = NSLocalizedDescriptionKey;
      uint64_t v6 = +[NSString stringWithUTF8String:"Invalid Parameter"];
      id v26 = v6;
      id v7 = +[NSDictionary dictionaryWithObjects:&v26 forKeys:&v25 count:1];
      id v8 = v13;
      id v9 = v5;
      uint64_t v10 = 10;
      goto LABEL_11;
    }
    uint64_t v15 = [[*(id *)(a1 + 40) NF_whitelistChecker];
    if (!v15)
    {
      uint64_t v19 = *(void *)(a1 + 48);
      id v20 = objc_alloc((Class)NSError);
      id v21 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v27 = NSLocalizedDescriptionKey;
      uint64_t v22 = +[NSString stringWithUTF8String:"Not entitled"];
      int v28 = v22;
      unsigned int v23 = +[NSDictionary dictionaryWithObjects:&v28 forKeys:&v27 count:1];
      id v24 = [v20 initWithDomain:v21 code:32 userInfo:v23];
      (*(void (**)(uint64_t, void, id))(v19 + 16))(v19, 0, v24);

      id v5 = 0;
      goto LABEL_12;
    }
    id v5 = (void *)v15;
    unsigned int v16 = [*(id *)(*(void *)(a1 + 32) + 384) hasReaderModeSupport];
    unsigned int v17 = v16;
    uint64_t v18 = *(void *)(a1 + 56);
    if ((v18 & 6) != 0 && v16)
    {
      [v5 nfcNDEFReaderAccess];
      uint64_t v18 = *(void *)(a1 + 56);
    }
    if ((v18 & 8) != 0)
    {
      if (v17)
      {
        [v5 nfcISO15693ReaderAccess];
        uint64_t v18 = *(void *)(a1 + 56);
      }
      if ((v18 & 0x10) == 0)
      {
LABEL_20:
        if ((v18 & 0x20) == 0)
        {
LABEL_30:
          (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
          goto LABEL_12;
        }
LABEL_28:
        if (v17) {
          [v5 nfcVASReaderAccess];
        }
        goto LABEL_30;
      }
    }
    else if ((v18 & 0x10) == 0)
    {
      goto LABEL_20;
    }
    if (v17)
    {
      [v5 nfcTagReaderAccess];
      uint64_t v18 = *(void *)(a1 + 56);
    }
    if ((v18 & 0x20) == 0) {
      goto LABEL_30;
    }
    goto LABEL_28;
  }
  uint64_t v3 = *(void *)(a1 + 48);
  id v4 = objc_alloc((Class)NSError);
  id v5 = +[NSString stringWithUTF8String:"nfcd"];
  NSErrorUserInfoKey v31 = NSLocalizedDescriptionKey;
  uint64_t v6 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
  __int16 v32 = v6;
  id v7 = +[NSDictionary dictionaryWithObjects:&v32 forKeys:&v31 count:1];
  id v8 = v4;
  id v9 = v5;
  uint64_t v10 = 58;
LABEL_11:
  id v14 = [v8 initWithDomain:v9 code:v10 userInfo:v7];
  (*(void (**)(uint64_t, void, id))(v3 + 16))(v3, 0, v14);

LABEL_12:
}

void sub_10010D9C4(uint64_t a1)
{
  uint64_t v1 = *(unsigned __int8 *)(a1 + 60);
  uint64_t v38 = *(unsigned int *)(a1 + 56);
  int v2 = *(void **)(a1 + 32);
  uint64_t v3 = *(void **)(a1 + 48);
  id v39 = *(id *)(a1 + 40);
  id v4 = v3;
  if (v2)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v2);
      if (class_isMetaClass(Class)) {
        uint64_t v8 = 43;
      }
      else {
        uint64_t v8 = 45;
      }
      ClassName = object_getClassName(v2);
      Name = sel_getName("_sync_configureReaderModeRFForTransitPartner:transitPartner:connection:completion:");
      id v11 = [v39 NF_userInfo];
      uint64_t v12 = [v11 objectForKeyedSubscript:@"ClientName"];
      v6(6, "%c[%{public}s %{public}s]:%i %{public}@ with configureNewRFConfig = %d", v8, ClassName, Name, 4846, v12, v1);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v13 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      id v14 = object_getClass(v2);
      if (class_isMetaClass(v14)) {
        int v15 = 43;
      }
      else {
        int v15 = 45;
      }
      unsigned int v16 = object_getClassName(v2);
      unsigned int v17 = sel_getName("_sync_configureReaderModeRFForTransitPartner:transitPartner:connection:completion:");
      uint64_t v18 = [v39 NF_userInfo];
      uint64_t v19 = [v18 objectForKeyedSubscript:@"ClientName"];
      *(_DWORD *)long long buf = 67110402;
      *(_DWORD *)&uint8_t buf[4] = v15;
      *(_WORD *)__int16 v58 = 2082;
      *(void *)&v58[2] = v16;
      *(_WORD *)&v58[10] = 2082;
      *(void *)&v58[12] = v17;
      *(_WORD *)&v58[20] = 1024;
      *(_DWORD *)&v58[22] = 4846;
      *(_WORD *)&v58[26] = 2114;
      *(void *)&v58[28] = v19;
      *(_WORD *)&v58[36] = 1024;
      *(_DWORD *)&v58[38] = v1;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@ with configureNewRFConfig = %d", buf, 0x32u);
    }
    uint64_t v40 = 0;
    id v41 = &v40;
    uint64_t v42 = 0x3032000000;
    char v43 = sub_10000B858;
    __int16 v44 = sub_1000F2378;
    id v45 = 0;
    if (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v2) == 2)
    {
      *(void *)long long buf = _NSConcreteStackBlock;
      *(void *)__int16 v58 = 3221225472;
      *(void *)&v58[8] = sub_10010DF44;
      *(void *)&v58[16] = &unk_100304808;
      char v59 = v1;
      *(_DWORD *)&v58[40] = v38;
      *(void *)&v58[24] = v2;
      *(void *)&v58[32] = &v40;
      id v20 = +[NFRoutingConfig routingOffWithFD:0];
      char v21 = sub_1000F23D8((void **)v2, buf, @"ConfigureRF", v20);

      if ((v21 & 1) == 0)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v22 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v22)
        {
          unsigned int v23 = object_getClass(v2);
          if (class_isMetaClass(v23)) {
            uint64_t v24 = 43;
          }
          else {
            uint64_t v24 = 45;
          }
          NSErrorUserInfoKey v25 = object_getClassName(v2);
          id v26 = sel_getName("_sync_configureReaderModeRFForTransitPartner:transitPartner:connection:completion:");
          v22(3, "%c[%{public}s %{public}s]:%i configureReaderModeRFForTransitPartner for %d, failed: %{public}@", v24, v25, v26, 4865, v38, v41[5]);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        NSErrorUserInfoKey v27 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
        {
          int v28 = object_getClass(v2);
          if (class_isMetaClass(v28)) {
            int v29 = 43;
          }
          else {
            int v29 = 45;
          }
          id v30 = object_getClassName(v2);
          NSErrorUserInfoKey v31 = sel_getName("_sync_configureReaderModeRFForTransitPartner:transitPartner:connection:completion:");
          uint64_t v32 = v41[5];
          *(_DWORD *)__int16 v46 = 67110402;
          *(_DWORD *)&v46[4] = v29;
          __int16 v47 = 2082;
          __int16 v48 = v30;
          __int16 v49 = 2082;
          __int16 v50 = v31;
          __int16 v51 = 1024;
          int v52 = 4865;
          __int16 v53 = 1024;
          int v54 = v38;
          __int16 v55 = 2114;
          uint64_t v56 = v32;
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i configureReaderModeRFForTransitPartner for %d, failed: %{public}@", v46, 0x32u);
        }
      }
      v4[2](v4, v41[5]);
    }
    else
    {
      id v33 = objc_alloc((Class)NSError);
      int v34 = +[NSString stringWithUTF8String:"nfcd"];
      *(void *)__int16 v46 = NSLocalizedDescriptionKey;
      id v35 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
      *(void *)long long buf = v35;
      __int16 v36 = +[NSDictionary dictionaryWithObjects:buf forKeys:v46 count:1];
      id v37 = [v33 initWithDomain:v34 code:58 userInfo:v36];
      ((void (**)(id, id))v4)[2](v4, v37);
    }
    _Block_object_dispose(&v40, 8);
  }
}

void sub_10010DF14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_10010DF44(uint64_t a1)
{
  if ((sub_1001E0BF8(*(void **)(*(void *)(a1 + 32) + 368)) & 1) == 0)
  {
    id v2 = objc_alloc((Class)NSError);
    uint64_t v3 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v10 = NSLocalizedDescriptionKey;
    id v4 = +[NSString stringWithUTF8String:"Stack Error"];
    id v11 = v4;
    id v5 = +[NSDictionary dictionaryWithObjects:&v11 forKeys:&v10 count:1];
    id v6 = [v2 initWithDomain:v3 code:15 userInfo:v5];
    uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
    uint64_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }
  return *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40) == 0;
}

id sub_10010F120(uint64_t a1)
{
  return [*(id *)(a1 + 32) maybeStartNextSession];
}

void sub_10010FA2C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_10010FA48(uint64_t a1)
{
  return [*(id *)(a1 + 32) maybeStartNextSession];
}

void sub_10010FB20(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v7 = 45;
    if (isMetaClass) {
      uint64_t v7 = 43;
    }
    v3(5, "%c[%{public}s %{public}s]:%i ", v7, ClassName, Name, 5044);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v8 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    id v9 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v9)) {
      int v10 = 43;
    }
    else {
      int v10 = 45;
    }
    id v11 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v12 = sel_getName(*(SEL *)(a1 + 56));
    *(_DWORD *)long long buf = 67109890;
    int v26 = v10;
    __int16 v27 = 2082;
    int v28 = v11;
    __int16 v29 = 2082;
    id v30 = v12;
    __int16 v31 = 1024;
    int v32 = 5044;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  if (-[_NFHardwareManager getPrimaryHardwareState]_0(*(void *)(a1 + 32)) == 2
    || -[_NFHardwareManager getPrimaryHardwareState]_0(*(void *)(a1 + 32)) == 5)
  {
    id v13 = *(void **)(a1 + 32);
    id v14 = [[*(id *)(a1 + 40) NF_userInfo];
    int v15 = [v14 objectForKeyedSubscript:@"ClientName"];
    sub_1000F5AA4(v13, 0, v15);

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  else
  {
    uint64_t v16 = *(void *)(a1 + 48);
    id v17 = objc_alloc((Class)NSError);
    uint64_t v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v23 = NSLocalizedDescriptionKey;
    uint64_t v19 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
    uint64_t v24 = v19;
    id v20 = +[NSDictionary dictionaryWithObjects:&v24 forKeys:&v23 count:1];
    id v21 = [v17 initWithDomain:v18 code:58 userInfo:v20];
    (*(void (**)(uint64_t, void, id))(v16 + 16))(v16, 0, v21);
  }
}

void sub_1001105DC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2 || [*(id *)(v2 + 40) OSMode] != (id)2)
  {
    uint64_t v3 = *(void **)(a1 + 40);
    id v13 = objc_alloc((Class)NSError);
    id v5 = +[NSString stringWithUTF8String:"nfcd"];
    v35[0] = NSLocalizedDescriptionKey;
    id v6 = +[NSString stringWithUTF8String:"JCOP not available"];
    v36[0] = v6;
    v36[1] = &off_10031BCE8;
    v35[1] = @"Line";
    v35[2] = @"Method";
    id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v36[2] = v7;
    v35[3] = NSDebugDescriptionErrorKey;
    id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 5109];
    v36[3] = v8;
    id v9 = +[NSDictionary dictionaryWithObjects:v36 forKeys:v35 count:4];
    int v10 = v13;
    id v11 = v5;
    uint64_t v12 = 53;
    goto LABEL_6;
  }
  if ([*(id *)(*(void *)(a1 + 32) + 40) restrictedMode])
  {
    uint64_t v3 = *(void **)(a1 + 40);
    id v4 = objc_alloc((Class)NSError);
    id v5 = +[NSString stringWithUTF8String:"nfcd"];
    v33[0] = NSLocalizedDescriptionKey;
    id v6 = +[NSString stringWithUTF8String:"Restricted Mode"];
    v34[0] = v6;
    v34[1] = &off_10031BD00;
    v33[1] = @"Line";
    v33[2] = @"Method";
    id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v34[2] = v7;
    v33[3] = NSDebugDescriptionErrorKey;
    id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 5112];
    v34[3] = v8;
    id v9 = +[NSDictionary dictionaryWithObjects:v34 forKeys:v33 count:4];
    int v10 = v4;
    id v11 = v5;
    uint64_t v12 = 24;
LABEL_6:
    id v14 = [v10 initWithDomain:v11 code:v12 userInfo:v9];
    [v3 didStartSession:v14];

    goto LABEL_7;
  }
  if (sub_1000F2880(*(void *)(a1 + 32)))
  {
    uint64_t v3 = *(void **)(a1 + 40);
    id v15 = objc_alloc((Class)NSError);
    id v5 = +[NSString stringWithUTF8String:"nfcd"];
    v31[0] = NSLocalizedDescriptionKey;
    id v6 = +[NSString stringWithUTF8String:"Applet Migration"];
    v32[0] = v6;
    v32[1] = &off_10031BD18;
    v31[1] = @"Line";
    v31[2] = @"Method";
    id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v32[2] = v7;
    v31[3] = NSDebugDescriptionErrorKey;
    id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 5115];
    v32[3] = v8;
    id v9 = +[NSDictionary dictionaryWithObjects:v32 forKeys:v31 count:4];
    int v10 = v15;
    id v11 = v5;
    uint64_t v12 = 26;
    goto LABEL_6;
  }
  if (sub_1000F28DC(*(void *)(a1 + 32)))
  {
    uint64_t v3 = *(void **)(a1 + 40);
    id v16 = objc_alloc((Class)NSError);
    id v5 = +[NSString stringWithUTF8String:"nfcd"];
    v29[0] = NSLocalizedDescriptionKey;
    id v6 = +[NSString stringWithUTF8String:"JCOP in OSU"];
    v30[0] = v6;
    v30[1] = &off_10031BD30;
    v29[1] = @"Line";
    v29[2] = @"Method";
    id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v30[2] = v7;
    v29[3] = NSDebugDescriptionErrorKey;
    id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 5118];
    v30[3] = v8;
    id v9 = +[NSDictionary dictionaryWithObjects:v30 forKeys:v29 count:4];
    int v10 = v16;
    id v11 = v5;
    uint64_t v12 = 52;
    goto LABEL_6;
  }
  id v5 = sub_1001DBA28(*(id **)(a1 + 32), *(void **)(a1 + 40), *(void **)(a1 + 48), 0);
  if (v5)
  {
    id v17 = *(void **)(a1 + 40);
    id v18 = objc_alloc((Class)NSError);
    uint64_t v19 = +[NSString stringWithUTF8String:"nfcd"];
    id v20 = [v5 code];
    v27[0] = NSLocalizedDescriptionKey;
    if ((uint64_t)[v5 code] > 70) {
      uint64_t v21 = 71;
    }
    else {
      uint64_t v21 = (uint64_t)[v5 code];
    }
    uint64_t v22 = +[NSString stringWithUTF8String:off_100304250[v21]];
    v28[0] = v22;
    v28[1] = v5;
    v27[1] = NSUnderlyingErrorKey;
    v27[2] = @"Line";
    v28[2] = &off_10031BD48;
    v27[3] = @"Method";
    id v23 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v28[3] = v23;
    void v27[4] = NSDebugDescriptionErrorKey;
    id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 5122];
    void v28[4] = v24;
    NSErrorUserInfoKey v25 = +[NSDictionary dictionaryWithObjects:v28 forKeys:v27 count:5];
    id v26 = [v18 initWithDomain:v19 code:v20 userInfo:v25];
    [v17 didStartSession:v26];
  }
  else
  {
    [*(id *)(a1 + 32) maybeStartNextSession];
  }
LABEL_7:
}

void sub_100111428(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2 || [*(id *)(v2 + 40) OSMode] != (id)2)
  {
    uint64_t v3 = *(void **)(a1 + 40);
    id v13 = objc_alloc((Class)NSError);
    id v5 = +[NSString stringWithUTF8String:"nfcd"];
    v35[0] = NSLocalizedDescriptionKey;
    id v6 = +[NSString stringWithUTF8String:"JCOP not available"];
    v36[0] = v6;
    v36[1] = &off_10031BD60;
    v35[1] = @"Line";
    v35[2] = @"Method";
    id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v36[2] = v7;
    v35[3] = NSDebugDescriptionErrorKey;
    id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 5181];
    v36[3] = v8;
    id v9 = +[NSDictionary dictionaryWithObjects:v36 forKeys:v35 count:4];
    int v10 = v13;
    id v11 = v5;
    uint64_t v12 = 53;
    goto LABEL_6;
  }
  if ([*(id *)(*(void *)(a1 + 32) + 40) restrictedMode])
  {
    uint64_t v3 = *(void **)(a1 + 40);
    id v4 = objc_alloc((Class)NSError);
    id v5 = +[NSString stringWithUTF8String:"nfcd"];
    v33[0] = NSLocalizedDescriptionKey;
    id v6 = +[NSString stringWithUTF8String:"Restricted Mode"];
    v34[0] = v6;
    v34[1] = &off_10031BD78;
    v33[1] = @"Line";
    v33[2] = @"Method";
    id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v34[2] = v7;
    v33[3] = NSDebugDescriptionErrorKey;
    id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 5184];
    v34[3] = v8;
    id v9 = +[NSDictionary dictionaryWithObjects:v34 forKeys:v33 count:4];
    int v10 = v4;
    id v11 = v5;
    uint64_t v12 = 24;
LABEL_6:
    id v14 = [v10 initWithDomain:v11 code:v12 userInfo:v9];
    [v3 didStartSession:v14];

    goto LABEL_7;
  }
  if (sub_1000F2880(*(void *)(a1 + 32)))
  {
    uint64_t v3 = *(void **)(a1 + 40);
    id v15 = objc_alloc((Class)NSError);
    id v5 = +[NSString stringWithUTF8String:"nfcd"];
    v31[0] = NSLocalizedDescriptionKey;
    id v6 = +[NSString stringWithUTF8String:"Applet Migration"];
    v32[0] = v6;
    v32[1] = &off_10031BD90;
    v31[1] = @"Line";
    v31[2] = @"Method";
    id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v32[2] = v7;
    v31[3] = NSDebugDescriptionErrorKey;
    id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 5187];
    v32[3] = v8;
    id v9 = +[NSDictionary dictionaryWithObjects:v32 forKeys:v31 count:4];
    int v10 = v15;
    id v11 = v5;
    uint64_t v12 = 26;
    goto LABEL_6;
  }
  if (sub_1000F28DC(*(void *)(a1 + 32)))
  {
    uint64_t v3 = *(void **)(a1 + 40);
    id v16 = objc_alloc((Class)NSError);
    id v5 = +[NSString stringWithUTF8String:"nfcd"];
    v29[0] = NSLocalizedDescriptionKey;
    id v6 = +[NSString stringWithUTF8String:"JCOP in OSU"];
    v30[0] = v6;
    v30[1] = &off_10031BDA8;
    v29[1] = @"Line";
    v29[2] = @"Method";
    id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v30[2] = v7;
    v29[3] = NSDebugDescriptionErrorKey;
    id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 5190];
    v30[3] = v8;
    id v9 = +[NSDictionary dictionaryWithObjects:v30 forKeys:v29 count:4];
    int v10 = v16;
    id v11 = v5;
    uint64_t v12 = 52;
    goto LABEL_6;
  }
  id v5 = sub_1001DBA28(*(id **)(a1 + 32), *(void **)(a1 + 40), *(void **)(a1 + 48), 0);
  if (v5)
  {
    id v17 = *(void **)(a1 + 40);
    id v18 = objc_alloc((Class)NSError);
    uint64_t v19 = +[NSString stringWithUTF8String:"nfcd"];
    id v20 = [v5 code];
    v27[0] = NSLocalizedDescriptionKey;
    if ((uint64_t)[v5 code] > 70) {
      uint64_t v21 = 71;
    }
    else {
      uint64_t v21 = (uint64_t)[v5 code];
    }
    uint64_t v22 = +[NSString stringWithUTF8String:off_100304250[v21]];
    v28[0] = v22;
    v28[1] = v5;
    v27[1] = NSUnderlyingErrorKey;
    v27[2] = @"Line";
    v28[2] = &off_10031BDC0;
    v27[3] = @"Method";
    id v23 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v28[3] = v23;
    void v27[4] = NSDebugDescriptionErrorKey;
    id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 5194];
    void v28[4] = v24;
    NSErrorUserInfoKey v25 = +[NSDictionary dictionaryWithObjects:v28 forKeys:v27 count:5];
    id v26 = [v18 initWithDomain:v19 code:v20 userInfo:v25];
    [v17 didStartSession:v26];
  }
  else
  {
    [*(id *)(a1 + 32) maybeStartNextSession];
  }
LABEL_7:
}

id sub_1001125FC(uint64_t a1)
{
  return [*(id *)(a1 + 32) maybeStartNextSession];
}

void sub_100113B9C(uint64_t a1)
{
  uint64_t v2 = sub_10020EC44(*(id **)(*(void *)(a1 + 32) + 368));
  unsigned int v3 = [v2 fdOn];

  [*(id *)(a1 + 32) maybeStartNextSession];
  if ([*(id *)(a1 + 40) count]) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4 && (sub_1000F596C(*(void *)(a1 + 32)) & 1) == 0)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    uint64_t v6 = *(void *)(v5 + 24);
    if ((!v6 || !*(unsigned char *)(v6 + 172)) && ([*(id *)(v5 + 408) isActive] & 1) == 0)
    {
      uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 368);
      if (v7)
      {
        [*(id *)(v7 + 104) lock];
        id v8 = *(id *)(v7 + 160);
        [*(id *)(v7 + 104) unlock];
        id v9 = v8;
        if (v9)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t Logger = NFLogGetLogger();
          if (Logger)
          {
            id v11 = (void (*)(uint64_t, const char *, ...))Logger;
            Class = object_getClass(*(id *)(a1 + 32));
            BOOL isMetaClass = class_isMetaClass(Class);
            ClassName = object_getClassName(*(id *)(a1 + 32));
            Name = sel_getName(*(SEL *)(a1 + 48));
            uint64_t v15 = 45;
            if (isMetaClass) {
              uint64_t v15 = 43;
            }
            v11(6, "%c[%{public}s %{public}s]:%i Restart FD to refresh field notification", v15, ClassName, Name, 5442);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v16 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
          {
            id v17 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v17)) {
              int v18 = 43;
            }
            else {
              int v18 = 45;
            }
            uint64_t v19 = object_getClassName(*(id *)(a1 + 32));
            id v20 = sel_getName(*(SEL *)(a1 + 48));
            *(_DWORD *)long long buf = 67109890;
            int v23 = v18;
            __int16 v24 = 2082;
            NSErrorUserInfoKey v25 = v19;
            __int16 v26 = 2082;
            __int16 v27 = v20;
            __int16 v28 = 1024;
            int v29 = 5442;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Restart FD to refresh field notification", buf, 0x22u);
          }

          sub_1002128B4(*(void **)(*(void *)(a1 + 32) + 368));
        }
      }
      else
      {
        id v9 = 0;
      }
    }
  }
}

id sub_100114AA4(uint64_t a1)
{
  return [*(id *)(a1 + 32) maybeStartNextSession];
}

id sub_100115760(uint64_t a1)
{
  return [*(id *)(a1 + 32) maybeStartNextSession];
}

id sub_100116394(uint64_t a1)
{
  return [*(id *)(a1 + 32) maybeStartNextSession];
}

id sub_100116FBC(uint64_t a1)
{
  return [*(id *)(a1 + 32) maybeStartNextSession];
}

void sub_100117AC0(uint64_t a1)
{
  uint64_t v2 = sub_1001AED74();
  [*(id *)(a1 + 32) setPowerConsumptionReporter:v2];

  unsigned int v3 = sub_1001DBA28(*(id **)(a1 + 40), *(void **)(a1 + 32), *(void **)(a1 + 48), 0);
  BOOL v4 = *(void **)(a1 + 32);
  if (v3)
  {
    id v5 = objc_alloc((Class)NSError);
    uint64_t v6 = +[NSString stringWithUTF8String:"nfcd"];
    id v7 = [v3 code];
    v35[0] = NSLocalizedDescriptionKey;
    if ((uint64_t)[v3 code] > 70) {
      uint64_t v8 = 71;
    }
    else {
      uint64_t v8 = (uint64_t)[v3 code];
    }
    uint64_t v21 = +[NSString stringWithUTF8String:off_100304250[v8]];
    v36[0] = v21;
    v36[1] = v3;
    v35[1] = NSUnderlyingErrorKey;
    v35[2] = @"Line";
    v36[2] = &off_10031BDD8;
    v35[3] = @"Method";
    id v22 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v36[3] = v22;
    void v35[4] = NSDebugDescriptionErrorKey;
    id v23 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 5795];
    void v36[4] = v23;
    __int16 v24 = +[NSDictionary dictionaryWithObjects:v36 forKeys:v35 count:5];
    id v25 = [v5 initWithDomain:v6 code:v7 userInfo:v24];
    [v4 didStartSession:v25];
  }
  else
  {
    if ([*(id *)(a1 + 32) forceExpressExit])
    {
      if (!*(unsigned char *)(a1 + 64))
      {
        uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 24);
        if (v9)
        {
          if (*(unsigned char *)(v9 + 172))
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t Logger = NFLogGetLogger();
            if (Logger)
            {
              id v11 = (void (*)(uint64_t, const char *, ...))Logger;
              Class = object_getClass(*(id *)(a1 + 40));
              BOOL isMetaClass = class_isMetaClass(Class);
              ClassName = object_getClassName(*(id *)(a1 + 40));
              Name = sel_getName(*(SEL *)(a1 + 56));
              uint64_t v15 = 45;
              if (isMetaClass) {
                uint64_t v15 = 43;
              }
              v11(6, "%c[%{public}s %{public}s]:%i forceExpressExit is set - re-prioritiing the session.", v15, ClassName, Name, 5800);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            id v16 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
            {
              id v17 = object_getClass(*(id *)(a1 + 40));
              if (class_isMetaClass(v17)) {
                int v18 = 43;
              }
              else {
                int v18 = 45;
              }
              uint64_t v19 = object_getClassName(*(id *)(a1 + 40));
              id v20 = sel_getName(*(SEL *)(a1 + 56));
              *(_DWORD *)long long buf = 67109890;
              int v28 = v18;
              __int16 v29 = 2082;
              id v30 = v19;
              __int16 v31 = 2082;
              int v32 = v20;
              __int16 v33 = 1024;
              int v34 = 5800;
              _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i forceExpressExit is set - re-prioritiing the session.", buf, 0x22u);
            }

            [*(id *)(a1 + 40) prioritizeSession:*(void *)(a1 + 32)];
          }
        }
      }
    }
    [*(id *)(a1 + 40) maybeStartNextSession];
  }
}

id sub_100118684(uint64_t a1)
{
  return [*(id *)(a1 + 32) maybeStartNextSession];
}

id sub_100118BFC(uint64_t a1)
{
  return [*(id *)(a1 + 32) maybeStartNextSession];
}

id sub_1001192D4(uint64_t a1)
{
  return [*(id *)(a1 + 32) maybeStartNextSession];
}

void sub_100119CB4(uint64_t a1, uint64_t a2)
{
  switch(a2)
  {
    case 0:
      id v13 = +[NSAssertionHandler currentHandler];
      [v13 handleFailureInMethod:*(void *)(a1 + 88) object:*(void *)(a1 + 32) file:@"_NFHardwareManager.m" lineNumber:6005 description:@"Invalid state"];

      uint64_t v3 = *(void *)(a1 + 80);
      id v14 = objc_alloc((Class)NSError);
      id v5 = +[NSString stringWithUTF8String:"nfcd"];
      v55[0] = NSLocalizedDescriptionKey;
      uint64_t v6 = +[NSString stringWithUTF8String:"Invalid State"];
      v56[0] = v6;
      v56[1] = &off_10031BE50;
      v55[1] = @"Line";
      v55[2] = @"Method";
      id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 88))];
      v56[2] = v7;
      v55[3] = NSDebugDescriptionErrorKey;
      id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 88)), 6006];
      v56[3] = v8;
      uint64_t v9 = +[NSDictionary dictionaryWithObjects:v56 forKeys:v55 count:4];
      int v10 = v14;
      id v11 = v5;
      uint64_t v12 = 12;
      goto LABEL_7;
    case 3:
      uint64_t v3 = *(void *)(a1 + 80);
      id v15 = objc_alloc((Class)NSError);
      id v5 = +[NSString stringWithUTF8String:"nfcd"];
      v57[0] = NSLocalizedDescriptionKey;
      uint64_t v6 = +[NSString stringWithUTF8String:"Session ineligible"];
      v58[0] = v6;
      v58[1] = &off_10031BE38;
      v57[1] = @"Line";
      v57[2] = @"Method";
      id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 88))];
      v58[2] = v7;
      v57[3] = NSDebugDescriptionErrorKey;
      id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 88)), 6002];
      v58[3] = v8;
      uint64_t v9 = +[NSDictionary dictionaryWithObjects:v58 forKeys:v57 count:4];
      int v10 = v15;
      id v11 = v5;
      uint64_t v12 = 70;
      goto LABEL_7;
    case 2:
      uint64_t v3 = *(void *)(a1 + 80);
      id v4 = objc_alloc((Class)NSError);
      id v5 = +[NSString stringWithUTF8String:"nfcd"];
      v59[0] = NSLocalizedDescriptionKey;
      uint64_t v6 = +[NSString stringWithUTF8String:"TCC access denied"];
      v60[0] = v6;
      v60[1] = &off_10031BE20;
      v59[1] = @"Line";
      v59[2] = @"Method";
      id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 88))];
      v60[2] = v7;
      v59[3] = NSDebugDescriptionErrorKey;
      id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 88)), 5999];
      v60[3] = v8;
      uint64_t v9 = +[NSDictionary dictionaryWithObjects:v60 forKeys:v59 count:4];
      int v10 = v4;
      id v11 = v5;
      uint64_t v12 = 69;
LABEL_7:
      id v16 = [v10 initWithDomain:v11 code:v12 userInfo:v9];
      (*(void (**)(uint64_t, void, void, id))(v3 + 16))(v3, 0, 0, v16);

      goto LABEL_8;
  }
  id v17 = [_NFCardSession alloc];
  uint64_t v18 = *(void *)(a1 + 48);
  uint64_t v19 = *(void *)(a1 + 56);
  uint64_t v20 = *(void *)(a1 + 40);
  uint64_t v21 = sub_10012050C(*(id **)(a1 + 32));
  id v5 = [(_NFCardSession *)v17 initWithConfig:v20 allowlistChecker:v18 remoteObject:v19 workQueue:v21];

  if (v5)
  {
    [(_NFSession *)v5 setQueue:*(void *)(a1 + 32)];
    [(_NFXPCSession *)v5 setConnection:*(void *)(a1 + 64)];
    [(_NFSession *)v5 setUid:*(unsigned int *)(a1 + 96)];
    [(_NFHCESession *)v5 setReadOnConnected:1];
    [(_NFHCESession *)v5 setEmulationOnSessionStart:1];
    -[_NFSession setServiceType:](v5, "setServiceType:", [*(id *)(a1 + 72) unsignedIntegerValue]);
    buf[0] = 0;
    id v22 = sub_1001DBA28(*(id **)(a1 + 32), v5, *(void **)(a1 + 64), buf);
    if (!v22)
    {
      uint64_t v42 = sub_10012050C(*(id **)(a1 + 32));
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_10011A4D8;
      block[3] = &unk_100301C68;
      block[4] = *(void *)(a1 + 32);
      dispatch_async(v42, block);
    }
    (*(void (**)(void))(*(void *)(a1 + 80) + 16))();
  }
  else
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      __int16 v24 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 88));
      uint64_t v28 = 45;
      if (isMetaClass) {
        uint64_t v28 = 43;
      }
      v24(3, "%c[%{public}s %{public}s]:%i Session creation failed.", v28, ClassName, Name, 6015);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v29 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      id v30 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v30)) {
        int v31 = 43;
      }
      else {
        int v31 = 45;
      }
      int v32 = object_getClassName(*(id *)(a1 + 32));
      __int16 v33 = sel_getName(*(SEL *)(a1 + 88));
      *(_DWORD *)long long buf = 67109890;
      int v48 = v31;
      __int16 v49 = 2082;
      __int16 v50 = v32;
      __int16 v51 = 2082;
      int v52 = v33;
      __int16 v53 = 1024;
      int v54 = 6015;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session creation failed.", buf, 0x22u);
    }

    uint64_t v34 = *(void *)(a1 + 80);
    id v35 = objc_alloc((Class)NSError);
    __int16 v36 = +[NSString stringWithUTF8String:"nfcd"];
    v45[0] = NSLocalizedDescriptionKey;
    id v37 = +[NSString stringWithUTF8String:"Unexpected Result"];
    v46[0] = v37;
    v46[1] = &off_10031BE68;
    v45[1] = @"Line";
    v45[2] = @"Method";
    id v38 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 88))];
    v46[2] = v38;
    v45[3] = NSDebugDescriptionErrorKey;
    id v39 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 88)), 6016];
    v46[3] = v39;
    uint64_t v40 = +[NSDictionary dictionaryWithObjects:v46 forKeys:v45 count:4];
    id v41 = [v35 initWithDomain:v36 code:13 userInfo:v40];
    (*(void (**)(uint64_t, void, void, id))(v34 + 16))(v34, 0, 0, v41);

    id v5 = 0;
  }
LABEL_8:
}

id sub_10011A4D8(uint64_t a1)
{
  return [*(id *)(a1 + 32) maybeStartNextSession];
}

void sub_10011AE54(uint64_t a1, uint64_t a2)
{
  switch(a2)
  {
    case 0:
      id v13 = +[NSAssertionHandler currentHandler];
      [v13 handleFailureInMethod:*(void *)(a1 + 72) object:*(void *)(a1 + 32) file:@"_NFHardwareManager.m" lineNumber:6094 description:@"Invalid state"];

      uint64_t v3 = *(void *)(a1 + 64);
      id v14 = objc_alloc((Class)NSError);
      id v5 = +[NSString stringWithUTF8String:"nfcd"];
      v50[0] = NSLocalizedDescriptionKey;
      uint64_t v6 = +[NSString stringWithUTF8String:"Invalid State"];
      v51[0] = v6;
      v51[1] = &off_10031BEC8;
      v50[1] = @"Line";
      v50[2] = @"Method";
      id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 72))];
      v51[2] = v7;
      v50[3] = NSDebugDescriptionErrorKey;
      id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 72)), 6095];
      v51[3] = v8;
      uint64_t v9 = +[NSDictionary dictionaryWithObjects:v51 forKeys:v50 count:4];
      int v10 = v14;
      id v11 = v5;
      uint64_t v12 = 12;
      goto LABEL_7;
    case 3:
      uint64_t v3 = *(void *)(a1 + 64);
      id v15 = objc_alloc((Class)NSError);
      id v5 = +[NSString stringWithUTF8String:"nfcd"];
      v52[0] = NSLocalizedDescriptionKey;
      uint64_t v6 = +[NSString stringWithUTF8String:"Session ineligible"];
      v53[0] = v6;
      v53[1] = &off_10031BEB0;
      v52[1] = @"Line";
      v52[2] = @"Method";
      id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 72))];
      v53[2] = v7;
      v52[3] = NSDebugDescriptionErrorKey;
      id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 72)), 6091];
      v53[3] = v8;
      uint64_t v9 = +[NSDictionary dictionaryWithObjects:v53 forKeys:v52 count:4];
      int v10 = v15;
      id v11 = v5;
      uint64_t v12 = 70;
      goto LABEL_7;
    case 2:
      uint64_t v3 = *(void *)(a1 + 64);
      id v4 = objc_alloc((Class)NSError);
      id v5 = +[NSString stringWithUTF8String:"nfcd"];
      v54[0] = NSLocalizedDescriptionKey;
      uint64_t v6 = +[NSString stringWithUTF8String:"TCC access denied"];
      v55[0] = v6;
      v55[1] = &off_10031BE98;
      v54[1] = @"Line";
      v54[2] = @"Method";
      id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 72))];
      v55[2] = v7;
      v54[3] = NSDebugDescriptionErrorKey;
      id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 72)), 6088];
      v55[3] = v8;
      uint64_t v9 = +[NSDictionary dictionaryWithObjects:v55 forKeys:v54 count:4];
      int v10 = v4;
      id v11 = v5;
      uint64_t v12 = 69;
LABEL_7:
      id v16 = [v10 initWithDomain:v11 code:v12 userInfo:v9];
      (*(void (**)(uint64_t, void, id))(v3 + 16))(v3, 0, v16);

      goto LABEL_8;
  }
  id v17 = [_NFFieldDetectSession alloc];
  uint64_t v18 = *(void *)(a1 + 40);
  uint64_t v19 = sub_10012050C(*(id **)(a1 + 32));
  id v5 = [(_NFFieldDetectSession *)v17 initWithRemoteObject:v18 workQueue:v19];

  if (v5)
  {
    [(_NFSession *)v5 setQueue:*(void *)(a1 + 32)];
    [(_NFXPCSession *)v5 setConnection:*(void *)(a1 + 48)];
    [(_NFSession *)v5 setUid:*(unsigned int *)(a1 + 80)];
    -[_NFSession setServiceType:](v5, "setServiceType:", [*(id *)(a1 + 56) unsignedIntegerValue]);
    [(_NFFieldDetectSession *)v5 setNotificationConfig:14];
    [(_NFFieldDetectSession *)v5 setNotificationCategories:4];
    sub_1000A6270(*(void *)(a1 + 32), v5, 1, *(_DWORD *)(a1 + 84), *(void **)(a1 + 64));
  }
  else
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v21 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 72));
      uint64_t v25 = 45;
      if (isMetaClass) {
        uint64_t v25 = 43;
      }
      v21(3, "%c[%{public}s %{public}s]:%i Session creation failed.", v25, ClassName, Name, 6103);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v26 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      __int16 v27 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v27)) {
        int v28 = 43;
      }
      else {
        int v28 = 45;
      }
      __int16 v29 = object_getClassName(*(id *)(a1 + 32));
      id v30 = sel_getName(*(SEL *)(a1 + 72));
      *(_DWORD *)long long buf = 67109890;
      int v43 = v28;
      __int16 v44 = 2082;
      id v45 = v29;
      __int16 v46 = 2082;
      __int16 v47 = v30;
      __int16 v48 = 1024;
      int v49 = 6103;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session creation failed.", buf, 0x22u);
    }

    uint64_t v31 = *(void *)(a1 + 64);
    id v32 = objc_alloc((Class)NSError);
    __int16 v33 = +[NSString stringWithUTF8String:"nfcd"];
    v40[0] = NSLocalizedDescriptionKey;
    uint64_t v34 = +[NSString stringWithUTF8String:"Unexpected Result"];
    v41[0] = v34;
    v41[1] = &off_10031BEE0;
    v40[1] = @"Line";
    v40[2] = @"Method";
    id v35 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 72))];
    v41[2] = v35;
    v40[3] = NSDebugDescriptionErrorKey;
    id v36 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 72)), 6104];
    v41[3] = v36;
    id v37 = +[NSDictionary dictionaryWithObjects:v41 forKeys:v40 count:4];
    id v38 = [v32 initWithDomain:v33 code:13 userInfo:v37];
    (*(void (**)(uint64_t, void, id))(v31 + 16))(v31, 0, v38);

    id v5 = 0;
  }
LABEL_8:
}

uint64_t sub_10011BB3C(uint64_t a1, uint64_t a2)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v5(6, "%c[%{public}s %{public}s]:%i eligible=%lu", v8, ClassName, Name, 6142, a2);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    uint64_t v12 = object_getClassName(*(id *)(a1 + 32));
    id v13 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)long long buf = 67110146;
    int v18 = v11;
    __int16 v19 = 2082;
    uint64_t v20 = v12;
    __int16 v21 = 2082;
    id v22 = v13;
    __int16 v23 = 1024;
    int v24 = 6142;
    __int16 v25 = 2048;
    uint64_t v26 = a2;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i eligible=%lu", buf, 0x2Cu);
  }

  return (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_10011BDB4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void **)(a1 + 48);
  id v3 = *(id *)(a1 + 40);
  id v4 = v2;
  if (!v1) {
    goto LABEL_39;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v6 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass((id)v1);
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName((id)v1);
    Name = sel_getName("_sync_preWarmForConnection:completion:");
    [v3 NF_userInfo];
    v12 = id v11 = v3;
    id v13 = [v12 objectForKeyedSubscript:@"ClientName"];
    uint64_t v14 = 45;
    if (isMetaClass) {
      uint64_t v14 = 43;
    }
    v6(6, "%c[%{public}s %{public}s]:%i %{public}@", v14, ClassName, Name, 6157, v13);

    id v3 = v11;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v15 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
  {
    id v16 = object_getClass((id)v1);
    if (class_isMetaClass(v16)) {
      int v17 = 43;
    }
    else {
      int v17 = 45;
    }
    int v18 = object_getClassName((id)v1);
    __int16 v19 = sel_getName("_sync_preWarmForConnection:completion:");
    uint64_t v20 = [v3 NF_userInfo];
    [v20 objectForKeyedSubscript:@"ClientName"];
    v22 = id v21 = v3;
    *(_DWORD *)long long buf = 67110146;
    *(_DWORD *)&uint8_t buf[4] = v17;
    *(_WORD *)int v63 = 2082;
    *(void *)&v63[2] = v18;
    *(_WORD *)&v63[10] = 2082;
    *(void *)&v63[12] = v19;
    *(_WORD *)&v63[20] = 1024;
    *(_DWORD *)&v63[22] = 6157;
    *(_WORD *)&v63[26] = 2114;
    *(void *)&v63[28] = v22;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

    id v3 = v21;
  }

  if (-[_NFHardwareManager getPrimaryHardwareState]_0(v1) != 2
    && -[_NFHardwareManager getPrimaryHardwareState]_0(v1) != 5)
  {
    id v39 = objc_alloc((Class)NSError);
    uint64_t v40 = +[NSString stringWithUTF8String:"nfcd"];
    v61[0] = NSLocalizedDescriptionKey;
    id v41 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
    *(void *)long long buf = v41;
    uint64_t v42 = +[NSDictionary dictionaryWithObjects:buf forKeys:v61 count:1];
    id v43 = [v39 initWithDomain:v40 code:58 userInfo:v42];
    v4[2](v4, v43);

    goto LABEL_39;
  }
  if (*(unsigned char *)(v1 + 338) || sub_1002015A0(*(void **)(v1 + 88)))
  {
LABEL_38:
    v4[2](v4, 0);
    goto LABEL_39;
  }
  __int16 v23 = sub_10020EC8C(*(void **)(v1 + 368), @"Prewarm", 0);
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v24 = NFLogGetLogger();
  __int16 v25 = (void (*)(uint64_t, const char *, ...))v24;
  if (!v23)
  {
    if (v24)
    {
      __int16 v44 = object_getClass((id)v1);
      BOOL v45 = class_isMetaClass(v44);
      __int16 v46 = object_getClassName((id)v1);
      __int16 v60 = sel_getName("_sync_preWarmForConnection:completion:");
      uint64_t v47 = 45;
      if (v45) {
        uint64_t v47 = 43;
      }
      v25(6, "%c[%{public}s %{public}s]:%i pre-warming hardware until unlock", v47, v46, v60, 6173);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v48 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v48, OS_LOG_TYPE_DEFAULT))
    {
      int v49 = object_getClass((id)v1);
      if (class_isMetaClass(v49)) {
        int v50 = 43;
      }
      else {
        int v50 = 45;
      }
      __int16 v51 = object_getClassName((id)v1);
      int v52 = sel_getName("_sync_preWarmForConnection:completion:");
      *(_DWORD *)long long buf = 67109890;
      *(_DWORD *)&uint8_t buf[4] = v50;
      *(_WORD *)int v63 = 2082;
      *(void *)&v63[2] = v51;
      *(_WORD *)&v63[10] = 2082;
      *(void *)&v63[12] = v52;
      *(_WORD *)&v63[20] = 1024;
      *(_DWORD *)&v63[22] = 6173;
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i pre-warming hardware until unlock", buf, 0x22u);
    }

    *(unsigned char *)(v1 + 338) = 1;
    goto LABEL_38;
  }
  if (v24)
  {
    uint64_t v26 = object_getClass((id)v1);
    BOOL v27 = class_isMetaClass(v26);
    __int16 v58 = object_getClassName((id)v1);
    char v59 = sel_getName("_sync_preWarmForConnection:completion:");
    uint64_t v28 = 45;
    if (v27) {
      uint64_t v28 = 43;
    }
    v25(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v28, v58, v59, 6169, v23);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  __int16 v29 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
  {
    id v30 = object_getClass((id)v1);
    if (class_isMetaClass(v30)) {
      int v31 = 43;
    }
    else {
      int v31 = 45;
    }
    id v32 = object_getClassName((id)v1);
    __int16 v33 = sel_getName("_sync_preWarmForConnection:completion:");
    *(_DWORD *)long long buf = 67110146;
    *(_DWORD *)&uint8_t buf[4] = v31;
    *(_WORD *)int v63 = 2082;
    *(void *)&v63[2] = v32;
    *(_WORD *)&v63[10] = 2082;
    *(void *)&v63[12] = v33;
    *(_WORD *)&v63[20] = 1024;
    *(_DWORD *)&v63[22] = 6169;
    *(_WORD *)&v63[26] = 2112;
    *(void *)&v63[28] = v23;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
  }

  id v34 = objc_alloc((Class)NSError);
  id v35 = +[NSString stringWithUTF8String:"nfcd"];
  id v36 = [v23 code];
  v61[0] = NSLocalizedDescriptionKey;
  id v37 = v3;
  if ((uint64_t)[v23 code] > 70) {
    uint64_t v38 = 71;
  }
  else {
    uint64_t v38 = (uint64_t)[v23 code];
  }
  __int16 v53 = +[NSString stringWithUTF8String:off_100304250[v38]];
  *(void *)long long buf = v53;
  *(void *)int v63 = v23;
  v61[1] = NSUnderlyingErrorKey;
  v61[2] = @"Line";
  *(void *)&v63[8] = &off_10031BEF8;
  v61[3] = @"Method";
  id v54 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_preWarmForConnection:completion:")];
  *(void *)&v63[16] = v54;
  void v61[4] = NSDebugDescriptionErrorKey;
  id v55 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_preWarmForConnection:completion:"), 6170];
  *(void *)&v63[24] = v55;
  uint64_t v56 = +[NSDictionary dictionaryWithObjects:buf forKeys:v61 count:5];
  id v57 = [v34 initWithDomain:v35 code:v36 userInfo:v56];
  v4[2](v4, v57);

  id v3 = v37;
LABEL_39:
}

void sub_10011C5EC(uint64_t a1)
{
  int v48 = *(_DWORD *)(a1 + 56);
  uint64_t v1 = *(id **)(a1 + 32);
  uint64_t v2 = *(void **)(a1 + 48);
  id v3 = *(id *)(a1 + 40);
  id v4 = v2;
  id v5 = v4;
  if (v1)
  {
    id v49 = v4;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v7 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(v1);
      Name = sel_getName("_sync_updateBackgroundTagReading:connection:completion:");
      [v3 NF_userInfo];
      v13 = id v12 = v3;
      uint64_t v14 = [v13 objectForKeyedSubscript:@"ClientName"];
      uint64_t v15 = 45;
      if (isMetaClass) {
        uint64_t v15 = 43;
      }
      v7(6, "%c[%{public}s %{public}s]:%i %{public}@", v15, ClassName, Name, 6193, v14);

      id v3 = v12;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v16 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = object_getClass(v1);
      if (class_isMetaClass(v17)) {
        int v18 = 43;
      }
      else {
        int v18 = 45;
      }
      __int16 v19 = object_getClassName(v1);
      uint64_t v20 = sel_getName("_sync_updateBackgroundTagReading:connection:completion:");
      id v21 = [v3 NF_userInfo];
      [v21 objectForKeyedSubscript:@"ClientName"];
      __int16 v23 = v22 = v3;
      *(_DWORD *)long long buf = 67110146;
      *(_DWORD *)&uint8_t buf[4] = v18;
      __int16 v52 = 2082;
      __int16 v53 = v19;
      __int16 v54 = 2082;
      id v55 = v20;
      __int16 v56 = 1024;
      int v57 = 6193;
      __int16 v58 = 2114;
      char v59 = v23;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);

      id v3 = v22;
    }

    if (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v1) == 2)
    {
      uint64_t v24 = [v3 NF_whitelistChecker];
      if ([v24 readerInternalAccess])
      {
        if (byte_100347434) {
          int v25 = 3;
        }
        else {
          int v25 = 2;
        }
        id v5 = v49;
        if (v48 && v25 != v48)
        {
          if (v48 == 2)
          {
            byte_100347434 = 0;
            [v1[51] resume];
          }
          else if (v48 == 3)
          {
            byte_100347434 = 1;
            [v1[51] suspend];
          }
        }
        if (byte_100347434) {
          uint64_t v46 = 3;
        }
        else {
          uint64_t v46 = 2;
        }
        (*((void (**)(id, void, uint64_t))v49 + 2))(v49, 0, v46);
      }
      else
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v30 = NFLogGetLogger();
        if (v30)
        {
          int v31 = (void (*)(uint64_t, const char *, ...))v30;
          id v32 = object_getClass(v1);
          BOOL v33 = class_isMetaClass(v32);
          id v34 = object_getClassName(v1);
          uint64_t v47 = sel_getName("_sync_updateBackgroundTagReading:connection:completion:");
          uint64_t v35 = 45;
          if (v33) {
            uint64_t v35 = 43;
          }
          v31(3, "%c[%{public}s %{public}s]:%i Invalid entitlements, requiring internal reader access", v35, v34, v47, 6203);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v36 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
        {
          id v37 = object_getClass(v1);
          if (class_isMetaClass(v37)) {
            int v38 = 43;
          }
          else {
            int v38 = 45;
          }
          id v39 = object_getClassName(v1);
          uint64_t v40 = sel_getName("_sync_updateBackgroundTagReading:connection:completion:");
          *(_DWORD *)long long buf = 67109890;
          *(_DWORD *)&uint8_t buf[4] = v38;
          __int16 v52 = 2082;
          __int16 v53 = v39;
          __int16 v54 = 2082;
          id v55 = v40;
          __int16 v56 = 1024;
          int v57 = 6203;
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid entitlements, requiring internal reader access", buf, 0x22u);
        }

        id v41 = objc_alloc((Class)NSError);
        uint64_t v42 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v50 = NSLocalizedDescriptionKey;
        id v43 = +[NSString stringWithUTF8String:"Not entitled"];
        *(void *)long long buf = v43;
        __int16 v44 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v50 count:1];
        id v45 = [v41 initWithDomain:v42 code:32 userInfo:v44];
        id v5 = v49;
        (*((void (**)(id, id, void))v49 + 2))(v49, v45, 0);
      }
    }
    else
    {
      id v26 = objc_alloc((Class)NSError);
      uint64_t v24 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v50 = NSLocalizedDescriptionKey;
      BOOL v27 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
      *(void *)long long buf = v27;
      uint64_t v28 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v50 count:1];
      id v29 = [v26 initWithDomain:v24 code:58 userInfo:v28];
      id v5 = v49;
      (*((void (**)(id, id, uint64_t))v49 + 2))(v49, v29, 1);
    }
  }
}

void sub_10011CC04(uint64_t a1)
{
  uint64_t v1 = *(unsigned int *)(a1 + 48);
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = (void (**)(void))*(id *)(a1 + 40);
  if (v2)
  {
    if (!v1)
    {
LABEL_28:
      v3[2](v3);
      goto LABEL_29;
    }
    uint64_t v4 = sub_1001AA1B4(*(void *)(v2 + 368));
    if (*(unsigned char *)(v2 + 349))
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        uint64_t v6 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass((id)v2);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName((id)v2);
        Name = sel_getName("_sync_actOnUserInitiatedSystemShutDown:completion:");
        uint64_t v9 = 45;
        if (isMetaClass) {
          uint64_t v9 = 43;
        }
        v6(6, "%c[%{public}s %{public}s]:%i User shutdown (0x%x) - testing headless", v9, ClassName, Name, 6245, v1);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v10 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_25;
      }
      id v11 = object_getClass((id)v2);
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      *(_DWORD *)long long buf = 67110146;
      int v89 = v12;
      __int16 v90 = 2082;
      int v91 = object_getClassName((id)v2);
      __int16 v92 = 2082;
      uint64_t v93 = sel_getName("_sync_actOnUserInitiatedSystemShutDown:completion:");
      __int16 v94 = 1024;
      int v95 = 6245;
      __int16 v96 = 1024;
      int v97 = v1;
      id v13 = "%c[%{public}s %{public}s]:%i User shutdown (0x%x) - testing headless";
LABEL_24:
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v13, buf, 0x28u);
LABEL_25:

LABEL_26:
      char v23 = 0;
LABEL_27:
      *(unsigned char *)(v2 + 356) = v23;
      goto LABEL_28;
    }
    uint64_t v14 = v4;
    uint64_t v15 = *(void *)(v2 + 24);
    if (v15 && *(unsigned char *)(v15 + 170))
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v16 = NFLogGetLogger();
      if (v16)
      {
        int v17 = (void (*)(uint64_t, const char *, ...))v16;
        int v18 = object_getClass((id)v2);
        BOOL v19 = class_isMetaClass(v18);
        BOOL v78 = object_getClassName((id)v2);
        uint64_t v83 = sel_getName("_sync_actOnUserInitiatedSystemShutDown:completion:");
        uint64_t v20 = 45;
        if (v19) {
          uint64_t v20 = 43;
        }
        v17(6, "%c[%{public}s %{public}s]:%i User shutdown (0x%x) - factory test mode", v20, v78, v83, 6250, v1);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v10 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_25;
      }
      id v21 = object_getClass((id)v2);
      if (class_isMetaClass(v21)) {
        int v22 = 43;
      }
      else {
        int v22 = 45;
      }
      *(_DWORD *)long long buf = 67110146;
      int v89 = v22;
      __int16 v90 = 2082;
      int v91 = object_getClassName((id)v2);
      __int16 v92 = 2082;
      uint64_t v93 = sel_getName("_sync_actOnUserInitiatedSystemShutDown:completion:");
      __int16 v94 = 1024;
      int v95 = 6250;
      __int16 v96 = 1024;
      int v97 = v1;
      id v13 = "%c[%{public}s %{public}s]:%i User shutdown (0x%x) - factory test mode";
      goto LABEL_24;
    }
    uint64_t v24 = v4 & 0x1C;
    if ([*(id *)(v2 + 384) hasLPEMSupport]) {
      BOOL v25 = v24 == 0;
    }
    else {
      BOOL v25 = 1;
    }
    if (!v25 && (v14 & 0xFFFFFFFFFFFFFFE3) == 0)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v32 = NFLogGetLogger();
      if (v32)
      {
        BOOL v33 = (void (*)(uint64_t, const char *, ...))v32;
        id v34 = object_getClass((id)v2);
        BOOL v35 = class_isMetaClass(v34);
        __int16 v79 = object_getClassName((id)v2);
        id v84 = sel_getName("_sync_actOnUserInitiatedSystemShutDown:completion:");
        uint64_t v36 = 45;
        if (v35) {
          uint64_t v36 = 43;
        }
        v33(6, "%c[%{public}s %{public}s]:%i User shutdown (0x%x) - find my is enabled", v36, v79, v84, 6257, v1);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v37 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        int v38 = object_getClass((id)v2);
        if (class_isMetaClass(v38)) {
          int v39 = 43;
        }
        else {
          int v39 = 45;
        }
        *(_DWORD *)long long buf = 67110146;
        int v89 = v39;
        __int16 v90 = 2082;
        int v91 = object_getClassName((id)v2);
        __int16 v92 = 2082;
        uint64_t v93 = sel_getName("_sync_actOnUserInitiatedSystemShutDown:completion:");
        __int16 v94 = 1024;
        int v95 = 6257;
        __int16 v96 = 1024;
        int v97 = v1;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i User shutdown (0x%x) - find my is enabled", buf, 0x28u);
      }

      sub_10021A750();
      uint64_t v40 = (unsigned char *)objc_claimAutoreleasedReturnValue();
      sub_10021CFD8(v40);

      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v41 = NFLogGetLogger();
      if (v41)
      {
        uint64_t v42 = (void (*)(uint64_t, const char *, ...))v41;
        id v43 = object_getClass((id)v2);
        BOOL v44 = class_isMetaClass(v43);
        id v45 = object_getClassName((id)v2);
        int v85 = sel_getName("_sync_actOnUserInitiatedSystemShutDown:completion:");
        uint64_t v46 = 45;
        if (v44) {
          uint64_t v46 = 43;
        }
        v42(6, "%c[%{public}s %{public}s]:%i Clear SE express config", v46, v45, v85, 6263);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v47 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
      {
        int v48 = object_getClass((id)v2);
        if (class_isMetaClass(v48)) {
          int v49 = 43;
        }
        else {
          int v49 = 45;
        }
        NSErrorUserInfoKey v50 = object_getClassName((id)v2);
        __int16 v51 = sel_getName("_sync_actOnUserInitiatedSystemShutDown:completion:");
        *(_DWORD *)long long buf = 67109890;
        int v89 = v49;
        __int16 v90 = 2082;
        int v91 = v50;
        __int16 v92 = 2082;
        uint64_t v93 = v51;
        __int16 v94 = 1024;
        int v95 = 6263;
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Clear SE express config", buf, 0x22u);
      }

      goto LABEL_71;
    }
    if ([*(id *)(v2 + 384) hasLPEMSupport]) {
      BOOL v27 = v24 == 0;
    }
    else {
      BOOL v27 = 1;
    }
    if (!v27 && (v14 & 3) != 0)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v58 = NFLogGetLogger();
      if (v58)
      {
        char v59 = (void (*)(uint64_t, const char *, ...))v58;
        __int16 v60 = object_getClass((id)v2);
        BOOL v61 = class_isMetaClass(v60);
        int v80 = object_getClassName((id)v2);
        uint64_t v86 = sel_getName("_sync_actOnUserInitiatedSystemShutDown:completion:");
        uint64_t v62 = 45;
        if (v61) {
          uint64_t v62 = 43;
        }
        v59(6, "%c[%{public}s %{public}s]:%i User shutdown (0x%x) - find my is enabled but so is NFC / Alisha", v62, v80, v86, 6278, v1);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v63 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v64 = object_getClass((id)v2);
        if (class_isMetaClass(v64)) {
          int v65 = 43;
        }
        else {
          int v65 = 45;
        }
        *(_DWORD *)long long buf = 67110146;
        int v89 = v65;
        __int16 v90 = 2082;
        int v91 = object_getClassName((id)v2);
        __int16 v92 = 2082;
        uint64_t v93 = sel_getName("_sync_actOnUserInitiatedSystemShutDown:completion:");
        __int16 v94 = 1024;
        int v95 = 6278;
        __int16 v96 = 1024;
        int v97 = v1;
        _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i User shutdown (0x%x) - find my is enabled but so is NFC / Alisha", buf, 0x28u);
      }

      sub_10021A750();
      __int16 v66 = (unsigned char *)objc_claimAutoreleasedReturnValue();
      sub_10021CFD8(v66);

      if ((v14 & 2) != 0) {
        sub_1001AA914(*(void *)(v2 + 368), 2);
      }
LABEL_71:
      __int16 v52 = +[NFRoutingConfig embeddedWiredMode];
      id v53 = [(id)v2 setRoutingConfig:v52];

      id v54 = sub_100245608(*(void **)(v2 + 376));
      uint64_t v55 = *(void *)(v2 + 24);
      __int16 v56 = objc_opt_new();
      id v57 = sub_1000439FC(v55, v56, 0, 0);

      sub_100040348(*(void *)(v2 + 24));
      goto LABEL_26;
    }
    if (![*(id *)(v2 + 384) hasLPEMSupport]) {
      goto LABEL_51;
    }
    uint64_t v29 = *(void *)(v2 + 24);
    if (v29)
    {
      if (*(void *)(v29 + 136) == 1) {
        goto LABEL_83;
      }
      LOBYTE(v29) = *(unsigned char *)(v29 + 170) != 0;
    }
    if ((v29 & 1) == 0 && !v14)
    {
LABEL_51:
      uint64_t v30 = +[NFRoutingConfig routingOff];
      id v31 = [(id)v2 setRoutingConfig:v30];

LABEL_93:
      char v23 = 1;
      goto LABEL_27;
    }
LABEL_83:
    uint64_t v67 = +[NFRoutingConfig routingOff];
    id v68 = [(id)v2 setRoutingConfig:v67];

    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v69 = NFLogGetLogger();
    if (v69)
    {
      int v70 = (void (*)(uint64_t, const char *, ...))v69;
      NSErrorUserInfoKey v71 = object_getClass((id)v2);
      BOOL v72 = class_isMetaClass(v71);
      CFStringRef v81 = object_getClassName((id)v2);
      id v87 = sel_getName("_sync_actOnUserInitiatedSystemShutDown:completion:");
      uint64_t v73 = 45;
      if (v72) {
        uint64_t v73 = 43;
      }
      v70(6, "%c[%{public}s %{public}s]:%i User shutdown (0x%x) - tearing down headless", v73, v81, v87, 6295, v1);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    unsigned int v74 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v75 = object_getClass((id)v2);
      if (class_isMetaClass(v75)) {
        int v76 = 43;
      }
      else {
        int v76 = 45;
      }
      *(_DWORD *)long long buf = 67110146;
      int v89 = v76;
      __int16 v90 = 2082;
      int v91 = object_getClassName((id)v2);
      __int16 v92 = 2082;
      uint64_t v93 = sel_getName("_sync_actOnUserInitiatedSystemShutDown:completion:");
      __int16 v94 = 1024;
      int v95 = 6295;
      __int16 v96 = 1024;
      int v97 = v1;
      _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i User shutdown (0x%x) - tearing down headless", buf, 0x28u);
    }

    sub_1001AAB3C(*(id *)(v2 + 368));
    goto LABEL_93;
  }
LABEL_29:
}

void sub_10011D6FC(uint64_t a1)
{
  char v2 = sub_1002128B4(*(void **)(*(void *)(a1 + 32) + 368));
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  uint64_t v4 = (void (*)(uint64_t, const char *, ...))Logger;
  if (v2)
  {
    if (Logger)
    {
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v8 = 45;
      if (isMetaClass) {
        uint64_t v8 = 43;
      }
      v4(6, "%c[%{public}s %{public}s]:%i Succesfully restarted Discovery", v8, ClassName, Name, 6355);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      int v12 = object_getClassName(*(id *)(a1 + 32));
      id v13 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)long long buf = 67109890;
      int v28 = v11;
      __int16 v29 = 2082;
      uint64_t v30 = v12;
      __int16 v31 = 2082;
      uint64_t v32 = v13;
      __int16 v33 = 1024;
      int v34 = 6355;
      uint64_t v14 = "%c[%{public}s %{public}s]:%i Succesfully restarted Discovery";
      uint64_t v15 = v9;
      os_log_type_t v16 = OS_LOG_TYPE_DEFAULT;
LABEL_20:
      _os_log_impl((void *)&_mh_execute_header, v15, v16, v14, buf, 0x22u);
    }
  }
  else
  {
    if (Logger)
    {
      int v17 = object_getClass(*(id *)(a1 + 32));
      BOOL v18 = class_isMetaClass(v17);
      BOOL v19 = object_getClassName(*(id *)(a1 + 32));
      id v26 = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v20 = 45;
      if (v18) {
        uint64_t v20 = 43;
      }
      v4(3, "%c[%{public}s %{public}s]:%i Error restarting Discovery", v20, v19, v26, 6352);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      id v21 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v21)) {
        int v22 = 43;
      }
      else {
        int v22 = 45;
      }
      char v23 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v24 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)long long buf = 67109890;
      int v28 = v22;
      __int16 v29 = 2082;
      uint64_t v30 = v23;
      __int16 v31 = 2082;
      uint64_t v32 = v24;
      __int16 v33 = 1024;
      int v34 = 6352;
      uint64_t v14 = "%c[%{public}s %{public}s]:%i Error restarting Discovery";
      uint64_t v15 = v9;
      os_log_type_t v16 = OS_LOG_TYPE_ERROR;
      goto LABEL_20;
    }
  }
}

id sub_10011D9F8(uint64_t a1)
{
  id result = sub_100216594(*(void **)(*(void *)(a1 + 32) + 368));
  if (*(void *)(*(void *)(a1 + 32) + 368))
  {
    return (id)NFDriverSimulateCrash();
  }
  return result;
}

id sub_10011E0F4(uint64_t a1)
{
  return [*(id *)(a1 + 32) preferencesDidChange];
}

id *sub_10012050C(id *a1)
{
  if (a1)
  {
    a1 = (id *)a1[29];
    uint64_t v1 = vars8;
  }
  return a1;
}

void sub_100120A54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL sub_100120A8C(uint64_t a1)
{
  char v2 = *(void **)(*(void *)(a1 + 32) + 368);
  id v3 = [*(id *)(a1 + 40) handle];
  [v3 identifier];
  uint64_t v4 = sub_10002A930(v2);
  uint64_t v5 = *(void *)(*(void *)(a1 + 48) + 8);
  uint64_t v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;

  return *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) == 0;
}

void sub_100120B08(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 0;
  }
  id v5 = v4;
  uint64_t v6 = v5;
  if (v5)
  {
    id v7 = [v5 connection];
    if (objc_msgSend(v7, "NF_presentmentIntentSuppressionHolder"))
    {
      unsigned int v8 = 1;
    }
    else
    {
      uint64_t v9 = [v6 connection];
      unsigned int v8 = [v9 NF_fdPresentmentIntentSuppressionHolder];
    }
  }
  else
  {
    unsigned int v8 = 0;
  }
  if ((!*(unsigned char *)(a1 + 48) || v8)
    && (([v3 requireSuppressDefaultAppPresentmentAssertion] ^ 1 | v8) & 1) != 0)
  {
    [v3 handleFieldChanged:*(unsigned __int8 *)(a1 + 49)];
  }
  else
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      int v11 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      os_log_type_t v16 = [v6 clientName];
      uint64_t v17 = 45;
      if (isMetaClass) {
        uint64_t v17 = 43;
      }
      v11(5, "%c[%{public}s %{public}s]:%i Suppress notification to %{public}@ (defaultAppPresentmentSuppression=%d, assertionHolder=%d)", v17, ClassName, Name, 6788, v16, *(unsigned __int8 *)(a1 + 48), v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    BOOL v18 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v19 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v19)) {
        int v20 = 43;
      }
      else {
        int v20 = 45;
      }
      id v21 = object_getClassName(*(id *)(a1 + 32));
      int v22 = sel_getName(*(SEL *)(a1 + 40));
      char v23 = [v6 clientName];
      int v24 = *(unsigned __int8 *)(a1 + 48);
      *(_DWORD *)long long buf = 67110658;
      int v26 = v20;
      __int16 v27 = 2082;
      int v28 = v21;
      __int16 v29 = 2082;
      uint64_t v30 = v22;
      __int16 v31 = 1024;
      int v32 = 6788;
      __int16 v33 = 2114;
      int v34 = v23;
      __int16 v35 = 1024;
      int v36 = v24;
      __int16 v37 = 1024;
      unsigned int v38 = v8;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Suppress notification to %{public}@ (defaultAppPresentmentSuppression=%d, assertionHolder=%d)", buf, 0x38u);
    }
  }
}

void sub_100120E50(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v8, ClassName, Name, 6802, *(void *)(a1 + 40));
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    int v12 = object_getClassName(*(id *)(a1 + 32));
    id v13 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v14 = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 67110146;
    *(_DWORD *)&uint8_t buf[4] = v11;
    *(_WORD *)__int16 v52 = 2082;
    *(void *)&v52[2] = v12;
    __int16 v53 = 2082;
    id v54 = v13;
    __int16 v55 = 1024;
    int v56 = 6802;
    __int16 v57 = 2114;
    uint64_t v58 = v14;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }

  sub_1000A4B04(*(void **)(a1 + 32), *(void **)(a1 + 40));
  if (sub_1001804AC(*(void *)(a1 + 32)) && [*(id *)(a1 + 40) chFieldType] != (id)1)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v33 = NFLogGetLogger();
    if (v33)
    {
      int v34 = (void (*)(uint64_t, const char *, ...))v33;
      __int16 v35 = object_getClass(*(id *)(a1 + 32));
      BOOL v36 = class_isMetaClass(v35);
      __int16 v37 = object_getClassName(*(id *)(a1 + 32));
      unsigned int v38 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v39 = 45;
      if (v36) {
        uint64_t v39 = 43;
      }
      v34(5, "%c[%{public}s %{public}s]:%i Dropping field due to connection handover assertion: %@", v39, v37, v38, 6807, *(void *)(a1 + 40));
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v40 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v41 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v41)) {
        int v42 = 43;
      }
      else {
        int v42 = 45;
      }
      id v43 = object_getClassName(*(id *)(a1 + 32));
      BOOL v44 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v45 = *(void *)(a1 + 40);
      *(_DWORD *)long long buf = 67110146;
      *(_DWORD *)&uint8_t buf[4] = v42;
      *(_WORD *)__int16 v52 = 2082;
      *(void *)&v52[2] = v43;
      __int16 v53 = 2082;
      id v54 = v44;
      __int16 v55 = 1024;
      int v56 = 6807;
      __int16 v57 = 2112;
      uint64_t v58 = v45;
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Dropping field due to connection handover assertion: %@", buf, 0x2Cu);
    }
  }
  else
  {
    int v15 = sub_100003110(*(void *)(a1 + 32));
    char v16 = objc_opt_respondsToSelector();
    if (v16) {
      [*(id *)(*(void *)(a1 + 32) + 112) handleFilteredFieldNotification:*(void *)(a1 + 40)];
    }
    uint64_t v17 = *(void *)(a1 + 32);
    if (v17) {
      BOOL v18 = *(void **)(v17 + 16);
    }
    else {
      BOOL v18 = 0;
    }
    v48[0] = _NSConcreteStackBlock;
    v48[1] = 3221225472;
    v48[2] = sub_100121364;
    v48[3] = &unk_100304920;
    char v50 = v15;
    v48[4] = v17;
    long long v47 = *(_OWORD *)(a1 + 40);
    id v19 = (id)v47;
    long long v49 = v47;
    [v18 enumerateFieldDetectSessionsUsingBlock:v48];
    if (v15)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v20 = NFLogGetLogger();
      if (v20)
      {
        id v21 = (void (*)(uint64_t, const char *, ...))v20;
        int v22 = object_getClass(*(id *)(a1 + 32));
        BOOL v23 = class_isMetaClass(v22);
        int v24 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v46 = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v25 = 45;
        if (v23) {
          uint64_t v25 = 43;
        }
        v21(5, "%c[%{public}s %{public}s]:%i Default app presentment suppression in place", v25, v24, v46, 6845);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v26 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v27 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v27)) {
          int v28 = 43;
        }
        else {
          int v28 = 45;
        }
        __int16 v29 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v30 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)long long buf = 67109890;
        *(_DWORD *)&uint8_t buf[4] = v28;
        *(_WORD *)__int16 v52 = 2082;
        *(void *)&v52[2] = v29;
        __int16 v53 = 2082;
        id v54 = v30;
        __int16 v55 = 1024;
        int v56 = 6845;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Default app presentment suppression in place", buf, 0x22u);
      }
    }
    else
    {
      int v31 = sub_1000A55C0(*(void *)(a1 + 32), *(void **)(a1 + 40));
      if ((v16 & 1) == 0 || v31)
      {
        int v32 = _os_activity_create((void *)&_mh_execute_header, "resumeSessionWaitingOnField:forceStartSession:", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
        *(void *)long long buf = 0;
        *(void *)__int16 v52 = 0;
        os_activity_scope_enter(v32, (os_activity_scope_state_t)buf);
        os_activity_scope_leave((os_activity_scope_state_t)buf);

        sub_1001DD1C4(*(id **)(a1 + 32), *(void **)(a1 + 40), 0);
      }
    }
  }
}

void sub_100121364(uint64_t a1, void *a2)
{
  id v3 = a2;
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    uint64_t v4 = v3;
  }
  else {
    uint64_t v4 = 0;
  }
  id v5 = v4;
  uint64_t v6 = v5;
  if (v5)
  {
    id v7 = [v5 connection];
    if (objc_msgSend(v7, "NF_presentmentIntentSuppressionHolder"))
    {
      unsigned int v8 = 1;
    }
    else
    {
      uint64_t v9 = [v6 connection];
      unsigned int v8 = [v9 NF_fdPresentmentIntentSuppressionHolder];
    }
  }
  else
  {
    unsigned int v8 = 0;
  }
  if ((!*(unsigned char *)(a1 + 56) || v8)
    && (([v3 requireSuppressDefaultAppPresentmentAssertion] ^ 1 | v8) & 1) != 0)
  {
    [v3 handleFilteredFieldNotification:*(void *)(a1 + 40)];
  }
  else
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      int v11 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      char v16 = [v6 clientName];
      uint64_t v17 = 45;
      if (isMetaClass) {
        uint64_t v17 = 43;
      }
      v11(5, "%c[%{public}s %{public}s]:%i Suppress notification to %{public}@ (defaultAppPresentmentSuppression=%d, assertionHolder=%d)", v17, ClassName, Name, 6837, v16, *(unsigned __int8 *)(a1 + 56), v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    BOOL v18 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      id v19 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v19)) {
        int v20 = 43;
      }
      else {
        int v20 = 45;
      }
      id v21 = object_getClassName(*(id *)(a1 + 32));
      int v22 = sel_getName(*(SEL *)(a1 + 48));
      BOOL v23 = [v6 clientName];
      int v24 = *(unsigned __int8 *)(a1 + 56);
      *(_DWORD *)long long buf = 67110658;
      int v26 = v20;
      __int16 v27 = 2082;
      int v28 = v21;
      __int16 v29 = 2082;
      uint64_t v30 = v22;
      __int16 v31 = 1024;
      int v32 = 6837;
      __int16 v33 = 2114;
      int v34 = v23;
      __int16 v35 = 1024;
      int v36 = v24;
      __int16 v37 = 1024;
      unsigned int v38 = v8;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Suppress notification to %{public}@ (defaultAppPresentmentSuppression=%d, assertionHolder=%d)", buf, 0x38u);
    }
  }
}

void sub_1001216AC(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v8, ClassName, Name, 6863, *(void *)(a1 + 40));
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    int v12 = object_getClassName(*(id *)(a1 + 32));
    id v13 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v14 = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 67110146;
    *(_DWORD *)&uint8_t buf[4] = v11;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = v12;
    *(_WORD *)&buf[18] = 2082;
    *(void *)&buf[20] = v13;
    *(_WORD *)&buf[28] = 1024;
    *(_DWORD *)&buf[30] = 6863;
    *(_WORD *)&buf[34] = 2114;
    *(void *)&buf[36] = v14;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }

  kdebug_trace();
  int v15 = NFSharedSignpostLog();
  if (os_signpost_enabled(v15))
  {
    id v16 = [*(id *)(a1 + 40) notificationType];
    *(_DWORD *)long long buf = 134217984;
    *(void *)&uint8_t buf[4] = v16;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "FIELD_NOTIFICATION", "type %lu", buf, 0xCu);
  }

  uint64_t v17 = *(void **)(a1 + 32);
  uint64_t v18 = v17[46];
  if (v18 && (*(void *)(v18 + 272) & 0x400) != 0)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v22 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v22)
    {
      BOOL v23 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v23)) {
        uint64_t v24 = 43;
      }
      else {
        uint64_t v24 = 45;
      }
      uint64_t v25 = object_getClassName(*(id *)(a1 + 32));
      int v26 = sel_getName(*(SEL *)(a1 + 48));
      v22(4, "%c[%{public}s %{public}s]:%i Ignoring technology event due to ExpressModeDebug setting!", v24, v25, v26, 6869);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v27 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      int v28 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v28)) {
        int v29 = 43;
      }
      else {
        int v29 = 45;
      }
      uint64_t v30 = object_getClassName(*(id *)(a1 + 32));
      __int16 v31 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)long long buf = 67109890;
      *(_DWORD *)&uint8_t buf[4] = v29;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = v30;
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = v31;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 6869;
      int v32 = "%c[%{public}s %{public}s]:%i Ignoring technology event due to ExpressModeDebug setting!";
      __int16 v33 = v27;
      os_log_type_t v34 = OS_LOG_TYPE_ERROR;
      uint32_t v35 = 34;
      goto LABEL_29;
    }
  }
  else
  {
    sub_1000A4B04(v17, *(void **)(a1 + 40));
    sub_1000A5150(*(void *)(a1 + 32), *(void **)(a1 + 40));
    if (!sub_1001804AC(*(void *)(a1 + 32)) || [*(id *)(a1 + 40) chFieldType] == (id)1)
    {
      uint64_t v19 = *(void *)(a1 + 32);
      if (v19 && (unint64_t v20 = (unint64_t)[*(id *)(v19 + 120) walletDomain], v20 <= 4)) {
        unsigned int v21 = (0x19u >> v20) & 1;
      }
      else {
        unsigned int v21 = 0;
      }
      int v36 = sub_100003110(*(void *)(a1 + 32));
      if ((v36 & 1) == 0)
      {
        sub_1000A52B4(*(void **)(a1 + 32), *(void **)(a1 + 40));
        sub_1000A5370(*(id **)(a1 + 32), *(void **)(a1 + 40));
        if (v21) {
          sub_1000A5998(*(void *)(a1 + 32), *(void **)(a1 + 40));
        }
      }
      char v37 = objc_opt_respondsToSelector();
      if (v37) {
        [*(id *)(*(void *)(a1 + 32) + 112) handleFieldNotification:*(void *)(a1 + 40)];
      }
      unsigned int v38 = objc_opt_new();
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = buf;
      *(void *)&uint8_t buf[16] = 0x3032000000;
      *(void *)&buf[24] = sub_10000B858;
      *(void *)&buf[32] = sub_1000F2378;
      *(void *)&buf[40] = 0;
      uint64_t v39 = *(void **)(a1 + 32);
      if (v39) {
        uint64_t v39 = (void *)v39[15];
      }
      uint64_t v40 = v39;
      uint64_t v41 = [v40 walletBundleIdentifier];

      int v42 = *(void **)(a1 + 32);
      if (v42) {
        int v42 = (void *)v42[2];
      }
      id v43 = v42;
      v67[0] = _NSConcreteStackBlock;
      v67[1] = 3221225472;
      v67[2] = sub_100121EF0;
      v67[3] = &unk_100304948;
      char v73 = v36;
      uint64_t v44 = *(void *)(a1 + 48);
      v67[4] = *(void *)(a1 + 32);
      uint64_t v72 = v44;
      id v45 = v41;
      id v68 = v45;
      NSErrorUserInfoKey v71 = buf;
      __int16 v27 = v38;
      uint64_t v69 = v27;
      char v74 = v21;
      id v70 = *(id *)(a1 + 40);
      [v43 enumerateFieldDetectSessionsUsingBlock:v67];

      if (v36)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v46 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v46)
        {
          long long v47 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v47)) {
            uint64_t v48 = 43;
          }
          else {
            uint64_t v48 = 45;
          }
          long long v49 = object_getClassName(*(id *)(a1 + 32));
          char v50 = sel_getName(*(SEL *)(a1 + 48));
          v46(5, "%c[%{public}s %{public}s]:%i Field detect default app presentment suppression in place", v48, v49, v50, 6961);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        __int16 v51 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
        {
          __int16 v52 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v52)) {
            int v53 = 43;
          }
          else {
            int v53 = 45;
          }
          id v54 = object_getClassName(*(id *)(a1 + 32));
          __int16 v55 = sel_getName(*(SEL *)(a1 + 48));
          *(_DWORD *)uint64_t v75 = 67109890;
          *(_DWORD *)&v75[4] = v53;
          *(_WORD *)int v76 = 2082;
          *(void *)&v76[2] = v54;
          __int16 v77 = 2082;
          BOOL v78 = v55;
          __int16 v79 = 1024;
          int v80 = 6961;
          _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Field detect default app presentment suppression in place", v75, 0x22u);
        }
      }
      else if (sub_1000A55C0(*(void *)(a1 + 32), *(void **)(a1 + 40)) & 1 | ((v37 & 1) == 0))
      {
        int v56 = _os_activity_create((void *)&_mh_execute_header, "resumeSessionWaitingOnField:forceStartSession:", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
        *(void *)uint64_t v75 = 0;
        *(void *)int v76 = 0;
        os_activity_scope_enter(v56, (os_activity_scope_state_t)v75);
        os_activity_scope_leave((os_activity_scope_state_t)v75);

        sub_1001DD1C4(*(id **)(a1 + 32), *(void **)(a1 + 40), 0);
      }
      sub_1000A5A08(*(id **)(a1 + 32), *(void **)(a1 + 40), *(void **)(*(void *)&buf[8] + 40), v27);

      _Block_object_dispose(buf, 8);
      goto LABEL_55;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v57 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v57)
    {
      uint64_t v58 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v58)) {
        uint64_t v59 = 43;
      }
      else {
        uint64_t v59 = 45;
      }
      __int16 v60 = object_getClassName(*(id *)(a1 + 32));
      BOOL v61 = sel_getName(*(SEL *)(a1 + 48));
      v57(5, "%c[%{public}s %{public}s]:%i Dropping field due to connection handover assertion: %@", v59, v60, v61, 6877, *(void *)(a1 + 40));
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v27 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v62 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v62)) {
        int v63 = 43;
      }
      else {
        int v63 = 45;
      }
      __int16 v64 = object_getClassName(*(id *)(a1 + 32));
      int v65 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v66 = *(void *)(a1 + 40);
      *(_DWORD *)long long buf = 67110146;
      *(_DWORD *)&uint8_t buf[4] = v63;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = v64;
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = v65;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 6877;
      *(_WORD *)&buf[34] = 2112;
      *(void *)&buf[36] = v66;
      int v32 = "%c[%{public}s %{public}s]:%i Dropping field due to connection handover assertion: %@";
      __int16 v33 = v27;
      os_log_type_t v34 = OS_LOG_TYPE_DEFAULT;
      uint32_t v35 = 44;
LABEL_29:
      _os_log_impl((void *)&_mh_execute_header, v33, v34, v32, buf, v35);
    }
  }
LABEL_55:
}

void sub_100121EC0(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 144), 8);
  _Unwind_Resume(a1);
}

void sub_100121EF0(uint64_t a1, void *a2)
{
  id v4 = a2;
  id v5 = [v4 notificationCategories];
  objc_opt_class();
  if (objc_opt_isKindOfClass()) {
    uint64_t v6 = v4;
  }
  else {
    uint64_t v6 = 0;
  }
  id v7 = v6;
  uint64_t v8 = v7;
  if (v7)
  {
    uint64_t v9 = [v7 connection];
    if (objc_msgSend(v9, "NF_presentmentIntentSuppressionHolder"))
    {
      unsigned int v10 = 1;
    }
    else
    {
      int v11 = [v8 connection];
      unsigned int v10 = [v11 NF_fdPresentmentIntentSuppressionHolder];
    }
  }
  else
  {
    unsigned int v10 = 0;
  }
  if ((!*(unsigned char *)(a1 + 80) || v10)
    && (([v4 requireSuppressDefaultAppPresentmentAssertion] ^ 1 | v10) & 1) != 0)
  {
    if (v5 == (id)-1 || (v5 & 4) == 0)
    {
      if (*(unsigned char *)(a1 + 81)
        || ([v8 clientName],
            int v29 = objc_claimAutoreleasedReturnValue(),
            unsigned int v30 = [v29 isEqual:@"passd"],
            v29,
            !v30))
      {
        [v4 handleFieldNotification:*(void *)(a1 + 56)];
      }
      else
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          int v32 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(*(id *)(a1 + 32));
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(*(id *)(a1 + 32));
          Name = sel_getName(*(SEL *)(a1 + 72));
          uint64_t v36 = 45;
          if (isMetaClass) {
            uint64_t v36 = 43;
          }
          v32(4, "%c[%{public}s %{public}s]:%i Suppress field notification to passd", v36, ClassName, Name, 6952);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        char v37 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
        {
          unsigned int v38 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v38)) {
            int v39 = 43;
          }
          else {
            int v39 = 45;
          }
          uint64_t v40 = object_getClassName(*(id *)(a1 + 32));
          uint64_t v41 = sel_getName(*(SEL *)(a1 + 72));
          *(_DWORD *)long long buf = 67109890;
          int v44 = v39;
          __int16 v45 = 2082;
          uint64_t v46 = v40;
          __int16 v47 = 2082;
          uint64_t v48 = v41;
          __int16 v49 = 1024;
          int v50 = 6952;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Suppress field notification to passd", buf, 0x22u);
        }
      }
    }
    else
    {
      int v12 = *(void **)(a1 + 40);
      id v13 = [v8 bundleIdentifier];
      LODWORD(v12) = [v12 isEqual:v13];

      if (v12) {
        objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40), a2);
      }
      else {
        [*(id *)(a1 + 48) addObject:v4];
      }
    }
  }
  else
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v14 = NFLogGetLogger();
    if (v14)
    {
      int v15 = (void (*)(uint64_t, const char *, ...))v14;
      id v16 = object_getClass(*(id *)(a1 + 32));
      BOOL v17 = class_isMetaClass(v16);
      uint64_t v18 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v19 = sel_getName(*(SEL *)(a1 + 72));
      unint64_t v20 = [v8 clientName];
      uint64_t v21 = 45;
      if (v17) {
        uint64_t v21 = 43;
      }
      v15(5, "%c[%{public}s %{public}s]:%i Suppress notification to %{public}@ (defaultAppPresentmentSuppression=%d, assertionHolder=%d)", v21, v18, v19, 6932, v20, *(unsigned __int8 *)(a1 + 80), v10);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v22 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
    {
      BOOL v23 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v23)) {
        int v24 = 43;
      }
      else {
        int v24 = 45;
      }
      uint64_t v25 = object_getClassName(*(id *)(a1 + 32));
      int v26 = sel_getName(*(SEL *)(a1 + 72));
      __int16 v27 = [v8 clientName];
      int v28 = *(unsigned __int8 *)(a1 + 80);
      *(_DWORD *)long long buf = 67110658;
      int v44 = v24;
      __int16 v45 = 2082;
      uint64_t v46 = v25;
      __int16 v47 = 2082;
      uint64_t v48 = v26;
      __int16 v49 = 1024;
      int v50 = 6932;
      __int16 v51 = 2114;
      __int16 v52 = v27;
      __int16 v53 = 1024;
      int v54 = v28;
      __int16 v55 = 1024;
      unsigned int v56 = v10;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Suppress notification to %{public}@ (defaultAppPresentmentSuppression=%d, assertionHolder=%d)", buf, 0x38u);
    }
  }
}

uint64_t sub_1001223BC(uint64_t a1)
{
  uint64_t result = objc_opt_respondsToSelector();
  if (result)
  {
    id v3 = *(void **)(*(void *)(a1 + 32) + 112);
    return (uint64_t)[v3 handleSecureElementEndOfOperation];
  }
  return result;
}

void sub_100122490(uint64_t a1)
{
}

void sub_1001227D8(uint64_t a1)
{
  char v2 = sub_10020EC8C(*(void **)(*(void *)(a1 + 32) + 368), @"Entered restrictedMode Exit", 0);
  if (v2)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v7 = 45;
      if (isMetaClass) {
        uint64_t v7 = 43;
      }
      v4(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v7, ClassName, Name, 7027, v2);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v8 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v9)) {
        int v10 = 43;
      }
      else {
        int v10 = 45;
      }
      int v11 = object_getClassName(*(id *)(a1 + 32));
      int v12 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)long long buf = 67110146;
      int v22 = v10;
      __int16 v23 = 2082;
      int v24 = v11;
      __int16 v25 = 2082;
      int v26 = v12;
      __int16 v27 = 1024;
      int v28 = 7027;
      __int16 v29 = 2112;
      unsigned int v30 = v2;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
    }
  }
  else
  {
    id v13 = *(id *)(*(void *)(a1 + 32) + 376);
    uint64_t v8 = v13;
    if (v13)
    {
      uint64_t v14 = [v13 handle];
      int v15 = [v14 info];
      unsigned int v16 = [v15 restrictedMode];

      if (v16)
      {
        id v17 = [*(id *)(a1 + 32) secureElementDidExitRestrictedMode:v8 os:*(void *)(a1 + 48)];
        uint64_t v18 = +[NSDistributedNotificationCenter defaultCenter];
        [v18 postNotificationName:@"com.apple.nfcd.se.restricted.exit" object:0 userInfo:0 options:3];
      }
    }
    sub_1002114AC(*(void **)(*(void *)(a1 + 32) + 368), @"Entered restrictedMode Exit");
  }
}

void sub_100122AD8(uint64_t a1)
{
  if (objc_opt_respondsToSelector())
  {
    uint64_t v2 = *(void *)(a1 + 40);
    id v3 = *(void **)(*(void *)(a1 + 32) + 112);
    [v3 handleSelectEvent:v2];
  }
  else
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v10 = 45;
      if (isMetaClass) {
        uint64_t v10 = 43;
      }
      v5(4, "%c[%{public}s %{public}s]:%i Unexpected active session: %{public}@", v10, ClassName, Name, 7048, *(void *)(*(void *)(a1 + 32) + 112));
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v11 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      int v12 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v12)) {
        int v13 = 43;
      }
      else {
        int v13 = 45;
      }
      uint64_t v14 = object_getClassName(*(id *)(a1 + 32));
      int v15 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v16 = *(void *)(*(void *)(a1 + 32) + 112);
      *(_DWORD *)long long buf = 67110146;
      int v18 = v13;
      __int16 v19 = 2082;
      unint64_t v20 = v14;
      __int16 v21 = 2082;
      int v22 = v15;
      __int16 v23 = 1024;
      int v24 = 7048;
      __int16 v25 = 2114;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected active session: %{public}@", buf, 0x2Cu);
    }
  }
}

void sub_100122D90(uint64_t a1)
{
  uint64_t v1 = sub_1000EE1BC(*(void *)(a1 + 32));
  if (!v1) {
    uint64_t v1 = objc_opt_new();
  }
  CFStringRef v3 = @"Erase counter";
  id v4 = v1;
  uint64_t v2 = +[NSDictionary dictionaryWithObjects:&v4 forKeys:&v3 count:1];
  sub_1001990A4((uint64_t)NFBugCapture, @"Flash wear issue : erase counter exceeded", @"Flash wear issue : erase counter exceeded", v2);
}

void sub_100122F08(uint64_t a1)
{
  if (objc_opt_respondsToSelector())
  {
    uint64_t v2 = *(void *)(a1 + 40);
    CFStringRef v3 = *(void **)(*(void *)(a1 + 32) + 112);
    [v3 secureElementReaderStarted:v2];
  }
  else
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v10 = 45;
      if (isMetaClass) {
        uint64_t v10 = 43;
      }
      v5(4, "%c[%{public}s %{public}s]:%i Unexpected active session: %{public}@", v10, ClassName, Name, 7097, *(void *)(*(void *)(a1 + 32) + 112));
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v11 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      int v12 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v12)) {
        int v13 = 43;
      }
      else {
        int v13 = 45;
      }
      uint64_t v14 = object_getClassName(*(id *)(a1 + 32));
      int v15 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v16 = *(void *)(*(void *)(a1 + 32) + 112);
      *(_DWORD *)long long buf = 67110146;
      int v18 = v13;
      __int16 v19 = 2082;
      unint64_t v20 = v14;
      __int16 v21 = 2082;
      int v22 = v15;
      __int16 v23 = 1024;
      int v24 = 7097;
      __int16 v25 = 2114;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected active session: %{public}@", buf, 0x2Cu);
    }
  }
}

void sub_1001231AC(uint64_t a1)
{
  if (objc_opt_respondsToSelector())
  {
    uint64_t v2 = *(void *)(a1 + 40);
    CFStringRef v3 = *(void **)(*(void *)(a1 + 32) + 112);
    [v3 secureElementReaderStopped:v2];
  }
  else
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v10 = 45;
      if (isMetaClass) {
        uint64_t v10 = 43;
      }
      v5(4, "%c[%{public}s %{public}s]:%i Unexpected active session: %{public}@", v10, ClassName, Name, 7108, *(void *)(*(void *)(a1 + 32) + 112));
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v11 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      int v12 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v12)) {
        int v13 = 43;
      }
      else {
        int v13 = 45;
      }
      uint64_t v14 = object_getClassName(*(id *)(a1 + 32));
      int v15 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v16 = *(void *)(*(void *)(a1 + 32) + 112);
      *(_DWORD *)long long buf = 67110146;
      int v18 = v13;
      __int16 v19 = 2082;
      unint64_t v20 = v14;
      __int16 v21 = 2082;
      int v22 = v15;
      __int16 v23 = 1024;
      int v24 = 7108;
      __int16 v25 = 2114;
      uint64_t v26 = v16;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected active session: %{public}@", buf, 0x2Cu);
    }
  }
}

void sub_10012342C(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
  if (Logger) {
    Logger(6, "%s:%i Refresh on RM timer ends", "-[_NFHardwareManager handleReaderModeProhibitTimerEvent:]_block_invoke", 7119);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  CFStringRef v3 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136446466;
    id v5 = "-[_NFHardwareManager handleReaderModeProhibitTimerEvent:]_block_invoke";
    __int16 v6 = 1024;
    int v7 = 7119;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s:%i Refresh on RM timer ends", buf, 0x12u);
  }

  sub_1001E9B3C(*(void *)(a1 + 32));
}

void sub_1001235A8(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) lastKnownRoutingConfig];
  CFStringRef v3 = v2;
  if (v2 && [v2 wantsSEReader])
  {
    sub_100215CAC(*(void **)(*(void *)(a1 + 32) + 368));
  }
  else
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v8 = 45;
      if (isMetaClass) {
        uint64_t v8 = 43;
      }
      v5(3, "%c[%{public}s %{public}s]:%i Error : unexpected routing : %@", v8, ClassName, Name, 7134, v3);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      int v12 = object_getClassName(*(id *)(a1 + 32));
      int v13 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)long long buf = 67110146;
      int v29 = v11;
      __int16 v30 = 2082;
      __int16 v31 = v12;
      __int16 v32 = 2082;
      __int16 v33 = v13;
      __int16 v34 = 1024;
      int v35 = 7134;
      __int16 v36 = 2112;
      char v37 = v3;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error : unexpected routing : %@", buf, 0x2Cu);
    }

    id v14 = *(id *)(a1 + 32);
    objc_sync_enter(v14);
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v15 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v15)
    {
      uint64_t v16 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v16)) {
        uint64_t v17 = 43;
      }
      else {
        uint64_t v17 = 45;
      }
      int v18 = object_getClassName(*(id *)(a1 + 32));
      __int16 v19 = sel_getName(*(SEL *)(a1 + 40));
      v15(3, "%c[%{public}s %{public}s]:%i Current session is %@", v17, v18, v19, 7136, *(void *)(*(void *)(a1 + 32) + 112));
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    unint64_t v20 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      __int16 v21 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v21)) {
        int v22 = 43;
      }
      else {
        int v22 = 45;
      }
      __int16 v23 = object_getClassName(*(id *)(a1 + 32));
      int v24 = sel_getName(*(SEL *)(a1 + 40));
      __int16 v25 = *(void **)(*(void *)(a1 + 32) + 112);
      *(_DWORD *)long long buf = 67110146;
      int v29 = v22;
      __int16 v30 = 2082;
      __int16 v31 = v23;
      __int16 v32 = 2082;
      __int16 v33 = v24;
      __int16 v34 = 1024;
      int v35 = 7136;
      __int16 v36 = 2112;
      char v37 = v25;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Current session is %@", buf, 0x2Cu);
    }

    objc_sync_exit(v14);
  }
}

void sub_1001238B8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1001239A4(uint64_t a1)
{
  if (objc_opt_respondsToSelector())
  {
    uint64_t v2 = *(void *)(a1 + 40);
    CFStringRef v3 = *(void **)(*(void *)(a1 + 32) + 112);
    uint64_t v4 = *(void *)(a1 + 48);
    [v3 handleSecureElementTransactionData:v2 appletIdentifier:v4];
  }
  else
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      __int16 v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v11 = 45;
      if (isMetaClass) {
        uint64_t v11 = 43;
      }
      v6(4, "%c[%{public}s %{public}s]:%i Unexpected active session: %{public}@", v11, ClassName, Name, 7149, *(void *)(*(void *)(a1 + 32) + 112));
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v12 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      int v13 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v13)) {
        int v14 = 43;
      }
      else {
        int v14 = 45;
      }
      int v15 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v16 = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v17 = *(void *)(*(void *)(a1 + 32) + 112);
      *(_DWORD *)long long buf = 67110146;
      int v19 = v14;
      __int16 v20 = 2082;
      __int16 v21 = v15;
      __int16 v22 = 2082;
      __int16 v23 = v16;
      __int16 v24 = 1024;
      int v25 = 7149;
      __int16 v26 = 2114;
      uint64_t v27 = v17;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected active session: %{public}@", buf, 0x2Cu);
    }
  }
}

void sub_100123D74(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    if ([v5 background])
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        uint64_t v8 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("_postExpressTransactionStartEvent:keyIdentifier:");
        uint64_t v12 = 45;
        if (isMetaClass) {
          uint64_t v12 = 43;
        }
        v8(6, "%c[%{public}s %{public}s]:%i Ignoring background transaction event while in express mode", v12, ClassName, Name, 7169);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v13 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        int v14 = object_getClass(a1);
        if (class_isMetaClass(v14)) {
          int v15 = 43;
        }
        else {
          int v15 = 45;
        }
        *(_DWORD *)long long buf = 67109890;
        *(_DWORD *)__int16 v30 = v15;
        *(_WORD *)&void v30[4] = 2082;
        *(void *)&v30[6] = object_getClassName(a1);
        *(_WORD *)&v30[14] = 2082;
        *(void *)&v30[16] = sel_getName("_postExpressTransactionStartEvent:keyIdentifier:");
        __int16 v31 = 1024;
        int v32 = 7169;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Ignoring background transaction event while in express mode", buf, 0x22u);
      }
LABEL_12:

      goto LABEL_16;
    }
    uint64_t v16 = a1[3];
    if (v16 && *(unsigned char *)(v16 + 172) && !*(unsigned char *)(v16 + 173))
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v17 = NFLogGetLogger();
      if (v17)
      {
        int v18 = (void (*)(uint64_t, const char *, ...))v17;
        int v19 = object_getClass(a1);
        BOOL v20 = class_isMetaClass(v19);
        __int16 v21 = object_getClassName(a1);
        int v28 = sel_getName("_postExpressTransactionStartEvent:keyIdentifier:");
        uint64_t v22 = 45;
        if (v20) {
          uint64_t v22 = 43;
        }
        v18(6, "%c[%{public}s %{public}s]:%i Firing express txn started notification", v22, v21, v28, 7172);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v23 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v24 = object_getClass(a1);
        if (class_isMetaClass(v24)) {
          int v25 = 43;
        }
        else {
          int v25 = 45;
        }
        *(_DWORD *)long long buf = 67109890;
        *(_DWORD *)__int16 v30 = v25;
        *(_WORD *)&void v30[4] = 2082;
        *(void *)&v30[6] = object_getClassName(a1);
        *(_WORD *)&v30[14] = 2082;
        *(void *)&v30[16] = sel_getName("_postExpressTransactionStartEvent:keyIdentifier:");
        __int16 v31 = 1024;
        int v32 = 7172;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Firing express txn started notification", buf, 0x22u);
      }

      sub_1000FA94C(a1, (uint64_t)"com.apple.stockholm.express.transaction.start", v6);
      int v13 = NFSharedSignpostLog();
      if (os_signpost_enabled(v13))
      {
        __int16 v26 = [v5 appletIdentifier];
        *(_DWORD *)long long buf = 136315394;
        *(void *)__int16 v30 = "com.apple.stockholm.express.transaction.start";
        *(_WORD *)&v30[8] = 2112;
        *(void *)&v30[10] = v26;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v13, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "EXPRESS_MODE_TX_START_NOTIFICATION", "%s, aid: %@", buf, 0x16u);
      }
      goto LABEL_12;
    }
  }
LABEL_16:
}

void sub_100124868(void *a1, void *a2, void *a3, void *a4, void *a5, int a6, void *a7)
{
  id v13 = a2;
  id v14 = a3;
  id v15 = a4;
  id v16 = a7;
  if (a1)
  {
    if ([v13 background])
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        int v18 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("_postExpressTransactionEndEvent:atlData:keyIdentifier:additionalData:notificationName:isUnifiedAccess:homePayload:");
        uint64_t v22 = 45;
        if (isMetaClass) {
          uint64_t v22 = 43;
        }
        v18(6, "%c[%{public}s %{public}s]:%i Ignoring transaction event while in express mode", v22, ClassName, Name, 7270);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v23 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_25;
      }
      __int16 v24 = object_getClass(a1);
      if (class_isMetaClass(v24)) {
        int v25 = 43;
      }
      else {
        int v25 = 45;
      }
      *(_DWORD *)long long buf = 67109890;
      *(_DWORD *)int v44 = v25;
      *(_WORD *)&v44[4] = 2082;
      *(void *)&v44[6] = object_getClassName(a1);
      *(_WORD *)&v44[14] = 2082;
      *(void *)&v44[16] = sel_getName("_postExpressTransactionEndEvent:atlData:keyIdentifier:additionalData:notificationName:isUnifiedAccess:homePayload:");
      __int16 v45 = 1024;
      int v46 = 7270;
      __int16 v26 = "%c[%{public}s %{public}s]:%i Ignoring transaction event while in express mode";
      goto LABEL_24;
    }
    uint64_t v27 = a1[3];
    if (v27 && *(unsigned char *)(v27 + 172))
    {
      if (!*(unsigned char *)(v27 + 173))
      {
        sub_1000FA5C8(a1, a5, v15);
        if (a6)
        {
          __int16 v36 = +[NFSecureXPCEventPublisherManager sharedManager];
          char v37 = [v36 homed];
          [a1 postEventForPublisher:v37 event:"com.apple.stockholm.forHome.transaction.end" objectString:v16];

          if (v14)
          {
            unsigned int v38 = [v14 objectForKeyedSubscript:@"EventType"];
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) != 0
              && [v38 isEqualToString:@"EndEvent"])
            {
              sub_1000B4830((uint64_t)NFUnifiedAccessTransactionCALogger, v14, 1, 0);
            }
          }
          int v39 = NFSharedSignpostLog();
          if (os_signpost_enabled(v39))
          {
            *(_WORD *)long long buf = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v39, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "AtlEvent", "AtlEndEventComplete", buf, 2u);
          }
        }
        __int16 v23 = NFSharedSignpostLog();
        if (os_signpost_enabled(v23))
        {
          uint64_t v40 = [v13 appletIdentifier];
          *(_DWORD *)long long buf = 136315394;
          *(void *)int v44 = a5;
          *(_WORD *)&v44[8] = 2112;
          *(void *)&v44[10] = v40;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v23, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "EXPRESS_MODE_TX_END_NOTIFICATION", "%s, aid: %@", buf, 0x16u);
        }
        goto LABEL_25;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v28 = NFLogGetLogger();
      if (v28)
      {
        int v29 = (void (*)(uint64_t, const char *, ...))v28;
        __int16 v30 = object_getClass(a1);
        BOOL v31 = class_isMetaClass(v30);
        int v32 = object_getClassName(a1);
        int v42 = sel_getName("_postExpressTransactionEndEvent:atlData:keyIdentifier:additionalData:notificationName:isUnifiedAccess:homePayload:");
        uint64_t v33 = 45;
        if (v31) {
          uint64_t v33 = 43;
        }
        v29(5, "%c[%{public}s %{public}s]:%i Express end notification already fired, ignoring", v33, v32, v42, 7303);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v23 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
LABEL_25:

        goto LABEL_26;
      }
      __int16 v34 = object_getClass(a1);
      if (class_isMetaClass(v34)) {
        int v35 = 43;
      }
      else {
        int v35 = 45;
      }
      *(_DWORD *)long long buf = 67109890;
      *(_DWORD *)int v44 = v35;
      *(_WORD *)&v44[4] = 2082;
      *(void *)&v44[6] = object_getClassName(a1);
      *(_WORD *)&v44[14] = 2082;
      *(void *)&v44[16] = sel_getName("_postExpressTransactionEndEvent:atlData:keyIdentifier:additionalData:notificationName:isUnifiedAccess:homePayload:");
      __int16 v45 = 1024;
      int v46 = 7303;
      __int16 v26 = "%c[%{public}s %{public}s]:%i Express end notification already fired, ignoring";
LABEL_24:
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, v26, buf, 0x22u);
      goto LABEL_25;
    }
  }
LABEL_26:
}

uint64_t sub_100125F64(uint64_t result)
{
  if (*(void *)(*(void *)(result + 32) + 112))
  {
    uint64_t v1 = result;
    objc_opt_class();
    uint64_t result = objc_opt_isKindOfClass();
    if (result)
    {
      uint64_t result = objc_opt_respondsToSelector();
      if (result)
      {
        uint64_t v2 = *(void *)(v1 + 40);
        CFStringRef v3 = *(void **)(*(void *)(v1 + 32) + 112);
        return (uint64_t)[v3 handleHostCardReaderDetected:v2];
      }
    }
  }
  return result;
}

id sub_100126098(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 56))
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      CFStringRef v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v7 = 45;
      if (isMetaClass) {
        uint64_t v7 = 43;
      }
      v3(5, "%c[%{public}s %{public}s]:%i Drop and restart", v7, ClassName, Name, 7530);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v8 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v9)) {
        int v10 = 43;
      }
      else {
        int v10 = 45;
      }
      uint64_t v11 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v12 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)long long buf = 67109890;
      int v33 = v10;
      __int16 v34 = 2082;
      int v35 = v11;
      __int16 v36 = 2082;
      char v37 = v12;
      __int16 v38 = 1024;
      int v39 = 7530;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Drop and restart", buf, 0x22u);
    }

    return (id)sub_1002128B4(*(void **)(*(void *)(a1 + 32) + 368));
  }
  else if (objc_opt_respondsToSelector())
  {
    uint64_t v14 = *(void *)(a1 + 40);
    id v15 = *(void **)(*(void *)(a1 + 32) + 112);
    return [v15 handleRemoteTagsDetected:v14];
  }
  else
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v16 = NFLogGetLogger();
    if (v16)
    {
      uint64_t v17 = (void (*)(uint64_t, const char *, ...))v16;
      int v18 = object_getClass(*(id *)(a1 + 32));
      BOOL v19 = class_isMetaClass(v18);
      BOOL v20 = object_getClassName(*(id *)(a1 + 32));
      __int16 v21 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v22 = 45;
      if (v19) {
        uint64_t v22 = 43;
      }
      v17(6, "%c[%{public}s %{public}s]:%i Found tags:%{public}@", v22, v20, v21, 7538, *(void *)(a1 + 40));
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v23 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v24 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v24)) {
        int v25 = 43;
      }
      else {
        int v25 = 45;
      }
      __int16 v26 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v27 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v28 = *(void *)(a1 + 40);
      *(_DWORD *)long long buf = 67110146;
      int v33 = v25;
      __int16 v34 = 2082;
      int v35 = v26;
      __int16 v36 = 2082;
      char v37 = v27;
      __int16 v38 = 1024;
      int v39 = 7538;
      __int16 v40 = 2114;
      uint64_t v41 = v28;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Found tags:%{public}@", buf, 0x2Cu);
    }

    uint64_t v29 = *(void *)(a1 + 32);
    if (v29) {
      __int16 v30 = *(void **)(v29 + 408);
    }
    else {
      __int16 v30 = 0;
    }
    return [v30 handleDetectedTags:*(void *)(a1 + 40)];
  }
}

void sub_1001268BC(uint64_t a1)
{
  uint64_t v2 = sub_10020EC8C(*(void **)(*(void *)(a1 + 32) + 368), @"SE Removed", 0);
  if (v2)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v7 = 45;
      if (isMetaClass) {
        uint64_t v7 = 43;
      }
      v4(3, "%c[%{public}s %{public}s]:%i Failed to open session: %@", v7, ClassName, Name, 7609, v2);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v8 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v9)) {
        int v10 = 43;
      }
      else {
        int v10 = 45;
      }
      uint64_t v11 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v12 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)long long buf = 67110146;
      *(_DWORD *)__int16 v24 = v10;
      *(_WORD *)&void v24[4] = 2082;
      *(void *)&v24[6] = v11;
      __int16 v25 = 2082;
      __int16 v26 = v12;
      __int16 v27 = 1024;
      int v28 = 7609;
      __int16 v29 = 2112;
      __int16 v30 = v2;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session: %@", buf, 0x2Cu);
    }
  }
  else
  {
    sub_100040C1C(*(void **)(*(void *)(a1 + 32) + 24));
    id v13 = +[NFPowerAssertion sharedPowerAssertion];
    [v13 releasePowerAssertion:@"ExpressMode" logFaultOnOverRelease:0];

    [*(id *)(a1 + 32) refreshSecureElementInfo];
    uint64_t v14 = *(int *)(a1 + 48);
    if (v14 > 4) {
      CFStringRef v15 = @"unknown";
    }
    else {
      CFStringRef v15 = (const __CFString *)*((void *)&off_100304A68 + v14);
    }
    uint64_t v16 = +[NSDistributedNotificationCenter defaultCenter];
    [v16 postNotificationName:@"com.apple.nfcd.se.removed" object:v15 userInfo:0 options:3];

    uint64_t v17 = NFSharedSignpostLog();
    if (os_signpost_enabled(v17))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)__int16 v24 = v15;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v17, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SE_REMOVED_NOTIFICATION", "com.apple.nfcd.se.removed for %@", buf, 0xCu);
    }

    uint64_t v18 = *(void *)(*(void *)(a1 + 32) + 232);
    BOOL v19 = +[NFRoutingConfig embeddedWiredMode];
    id v20 = +[_NFBuiltinSession createSessionWithWorkQueue:routing:sessionQueuer:didStartWork:](_NFBuiltinSession, "createSessionWithWorkQueue:routing:sessionQueuer:didStartWork:", v18, v19);

    sub_1002114AC(*(void **)(*(void *)(a1 + 32) + 368), @"SE Removed");
  }
}

void sub_100126C08(uint64_t a1)
{
}

void sub_100126E44(uint64_t a1)
{
  uint64_t v2 = +[NSDate now];
  CFStringRef v3 = v2;
  if (!*(void *)(*(void *)(a1 + 32) + 224)) {
    goto LABEL_23;
  }
  [v2 timeIntervalSinceDate:];
  if (v4 >= 3600.0)
  {
    if (*(void *)(*(void *)(a1 + 32) + 224))
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        uint64_t v18 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(*(id *)(a1 + 32));
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(*(id *)(a1 + 32));
        Name = sel_getName(*(SEL *)(a1 + 40));
        [v3 timeIntervalSinceDate:*(void *)(*(void *)(a1 + 32) + 224)];
        uint64_t v24 = 45;
        if (isMetaClass) {
          uint64_t v24 = 43;
        }
        v18(6, "%c[%{public}s %{public}s]:%i Last OS reset was %f seconds ago", v24, ClassName, Name, 7660, v23);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v25 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_33;
      }
      __int16 v26 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v26)) {
        int v27 = 43;
      }
      else {
        int v27 = 45;
      }
      int v28 = object_getClassName(*(id *)(a1 + 32));
      __int16 v29 = sel_getName(*(SEL *)(a1 + 40));
      [v3 timeIntervalSinceDate:*(void *)(*(void *)(a1 + 32) + 224)];
      *(_DWORD *)long long buf = 67110146;
      *(_DWORD *)__int16 v57 = v27;
      *(_WORD *)&void v57[4] = 2082;
      *(void *)&v57[6] = v28;
      __int16 v58 = 2082;
      uint64_t v59 = v29;
      __int16 v60 = 1024;
      int v61 = 7660;
      __int16 v62 = 2048;
      uint64_t v63 = v30;
      BOOL v31 = "%c[%{public}s %{public}s]:%i Last OS reset was %f seconds ago";
      int v32 = v25;
      uint32_t v33 = 44;
LABEL_32:
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, v31, buf, v33);
LABEL_33:

      uint64_t v44 = *(void *)(a1 + 32);
      id v45 = v3;
      char v16 = 0;
      uint64_t v11 = *(NSObject **)(v44 + 224);
      *(void *)(v44 + 224) = v45;
      goto LABEL_34;
    }
LABEL_23:
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v34 = NFLogGetLogger();
    if (v34)
    {
      int v35 = (void (*)(uint64_t, const char *, ...))v34;
      __int16 v36 = object_getClass(*(id *)(a1 + 32));
      BOOL v37 = class_isMetaClass(v36);
      __int16 v38 = object_getClassName(*(id *)(a1 + 32));
      __int16 v55 = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v39 = 45;
      if (v37) {
        uint64_t v39 = 43;
      }
      v35(6, "%c[%{public}s %{public}s]:%i Cool ! This is the first SE OS reset since our process started. I mean it's not great but as the internets say : 'First!'", v39, v38, v55, 7662);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v25 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_33;
    }
    __int16 v40 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v40)) {
      int v41 = 43;
    }
    else {
      int v41 = 45;
    }
    int v42 = object_getClassName(*(id *)(a1 + 32));
    id v43 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)long long buf = 67109890;
    *(_DWORD *)__int16 v57 = v41;
    *(_WORD *)&void v57[4] = 2082;
    *(void *)&v57[6] = v42;
    __int16 v58 = 2082;
    uint64_t v59 = v43;
    __int16 v60 = 1024;
    int v61 = 7662;
    BOOL v31 = "%c[%{public}s %{public}s]:%i Cool ! This is the first SE OS reset since our process started. I mean it's not g"
          "reat but as the internets say : 'First!'";
    int v32 = v25;
    uint32_t v33 = 34;
    goto LABEL_32;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v5 = NFLogGetLogger();
  if (v5)
  {
    id v6 = (void (*)(uint64_t, const char *, ...))v5;
    uint64_t v7 = object_getClass(*(id *)(a1 + 32));
    BOOL v8 = class_isMetaClass(v7);
    uint64_t v9 = object_getClassName(*(id *)(a1 + 32));
    int v54 = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v10 = 45;
    if (v8) {
      uint64_t v10 = 43;
    }
    v6(3, "%c[%{public}s %{public}s]:%i Already reset within the last: %f", v10, v9, v54, 7656, 0x40AC200000000000);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v11 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    uint64_t v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12)) {
      int v13 = 43;
    }
    else {
      int v13 = 45;
    }
    uint64_t v14 = object_getClassName(*(id *)(a1 + 32));
    CFStringRef v15 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)long long buf = 67110146;
    *(_DWORD *)__int16 v57 = v13;
    *(_WORD *)&void v57[4] = 2082;
    *(void *)&v57[6] = v14;
    __int16 v58 = 2082;
    uint64_t v59 = v15;
    __int16 v60 = 1024;
    int v61 = 7656;
    __int16 v62 = 2048;
    uint64_t v63 = 0x40AC200000000000;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Already reset within the last: %f", buf, 0x2Cu);
  }
  char v16 = 1;
LABEL_34:

  unint64_t v46 = *(void *)(a1 + 48);
  if ((v46 | 2) == 2)
  {
    sub_100040C1C(*(void **)(*(void *)(a1 + 32) + 24));
    __int16 v47 = +[NFPowerAssertion sharedPowerAssertion];
    [v47 releasePowerAssertion:@"ExpressMode" logFaultOnOverRelease:0];

    unint64_t v46 = *(void *)(a1 + 48);
  }
  if (v46 > 3) {
    CFStringRef v48 = @"unknown";
  }
  else {
    CFStringRef v48 = (const __CFString *)*((void *)&off_100304A90 + v46);
  }
  __int16 v49 = +[NSDistributedNotificationCenter defaultCenter];
  [v49 postNotificationName:@"com.apple.nfcd.se.os.reset" object:v48 userInfo:0 options:3];

  int v50 = NFSharedSignpostLog();
  if (os_signpost_enabled(v50))
  {
    *(_DWORD *)long long buf = 138412290;
    *(void *)__int16 v57 = v48;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v50, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SE_REMOVED_NOTIFICATION", "com.apple.nfcd.se.os.reset for %@", buf, 0xCu);
  }

  if ((v16 & 1) == 0)
  {
    uint64_t v51 = *(void *)(*(void *)(a1 + 32) + 232);
    __int16 v52 = +[NFRoutingConfig embeddedWiredMode];
    id v53 = +[_NFBuiltinSession createSessionWithWorkQueue:routing:sessionQueuer:didStartWork:](_NFBuiltinSession, "createSessionWithWorkQueue:routing:sessionQueuer:didStartWork:", v51, v52);
  }
}

uint64_t sub_100127440(uint64_t a1)
{
  [*(id *)(a1 + 32) refreshSecureElementInfo];
  sub_1000EF080(*(void ***)(a1 + 32));
  if (*(void *)(a1 + 40) == 1)
  {
    uint64_t v2 = "eUICC OS reset";
    uint64_t v3 = 12748;
  }
  else
  {
    uint64_t v2 = "SE OS reset";
    uint64_t v3 = 21253;
  }

  return _NFSimulateCrash(v3, v2);
}

uint64_t sub_10012788C(uint64_t a1)
{
  objc_opt_class();
  uint64_t result = objc_opt_isKindOfClass();
  if (result)
  {
    uint64_t result = objc_opt_respondsToSelector();
    if (result)
    {
      uint64_t v3 = *(void **)(*(void *)(a1 + 32) + 112);
      return (uint64_t)[v3 handleHceTargetLost];
    }
  }
  return result;
}

void sub_100127980(uint64_t a1)
{
}

void sub_100127E14(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v2 + 337))
  {
    char v16 = NFSharedSignpostLog();
    if (os_signpost_enabled(v16))
    {
      *(_WORD *)long long buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "powerObserverSystemWillSleep: not running; allowing to sleep",
        (const char *)&unk_100286819,
        buf,
        2u);
    }
    goto LABEL_72;
  }
  uint64_t v3 = *(void *)(v2 + 24);
  if (v3 && *(unsigned char *)(v3 + 172))
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v5(6, "%c[%{public}s %{public}s]:%i Express mode in progress - delaying sleep", v9, ClassName, Name, 7794);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      int v13 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v14 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)long long buf = 67109890;
      *(_DWORD *)&uint8_t buf[4] = v12;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = v13;
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = v14;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 7794;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Express mode in progress - delaying sleep", buf, 0x22u);
    }

    CFStringRef v15 = NFSharedSignpostLog();
    if (os_signpost_enabled(v15))
    {
      *(_WORD *)long long buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "powerObserverSystemWillSleep: express in progress; preventing sleep",
        (const char *)&unk_100286819,
        buf,
        2u);
    }

    return;
  }
  if (!*(void *)(v2 + 112))
  {
    uint64_t v17 = [(id)v2 lastKnownRoutingConfig];
    if ([v17 activeRouting]) {
      goto LABEL_23;
    }
    uint64_t v18 = *(void *)(*(void *)(a1 + 32) + 24);
    if (!v18)
    {

      goto LABEL_52;
    }
    if (*(void *)(v18 + 136) == 1)
    {
LABEL_23:
    }
    else
    {
      int v66 = *(unsigned __int8 *)(v18 + 170);

      if (!v66) {
        goto LABEL_52;
      }
    }
    uint64_t v19 = *(void *)(*(void *)(a1 + 32) + 24);
    if (v19) {
      BOOL v20 = *(void *)(v19 + 136) == 1 || *(unsigned __int8 *)(v19 + 170) != 0;
    }
    else {
      BOOL v20 = 0;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v21 = NFLogGetLogger();
    uint64_t v22 = (void (*)(uint64_t, const char *, ...))v21;
    if (v20)
    {
      if (v21)
      {
        uint64_t v23 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v23)) {
          uint64_t v24 = 43;
        }
        else {
          uint64_t v24 = 45;
        }
        __int16 v25 = object_getClassName(*(id *)(a1 + 32));
        __int16 v26 = sel_getName(*(SEL *)(a1 + 40));
        int v27 = [*(id *)(a1 + 32) lastKnownRoutingConfig];
        v22(6, "%c[%{public}s %{public}s]:%i Setting routing to express before poweroff - was  %{public}@", v24, v25, v26, 7804, v27);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v28 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v29 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v29)) {
          int v30 = 43;
        }
        else {
          int v30 = 45;
        }
        BOOL v31 = object_getClassName(*(id *)(a1 + 32));
        int v32 = sel_getName(*(SEL *)(a1 + 40));
        uint32_t v33 = [*(id *)(a1 + 32) lastKnownRoutingConfig];
        *(_DWORD *)long long buf = 67110146;
        *(_DWORD *)&uint8_t buf[4] = v30;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = v31;
        *(_WORD *)&buf[18] = 2082;
        *(void *)&buf[20] = v32;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 7804;
        *(_WORD *)&buf[34] = 2114;
        *(void *)&buf[36] = v33;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Setting routing to express before poweroff - was  %{public}@", buf, 0x2Cu);
      }
      uint64_t v34 = *(void **)(a1 + 32);
      int v35 = [v34 lastKnownRoutingConfig];
      __int16 v36 = [v35 lpcdEcpFrame];
      BOOL v37 = +[NFRoutingConfig expressWithECP:v36];
      id v38 = [v34 setRoutingConfig:v37];
    }
    else
    {
      if (v21)
      {
        uint64_t v39 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v39)) {
          uint64_t v40 = 43;
        }
        else {
          uint64_t v40 = 45;
        }
        int v41 = object_getClassName(*(id *)(a1 + 32));
        int v42 = sel_getName(*(SEL *)(a1 + 40));
        id v43 = [*(id *)(a1 + 32) lastKnownRoutingConfig];
        v22(6, "%c[%{public}s %{public}s]:%i Forcing SE routing off:was  %{public}@", v40, v41, v42, 7807, v43);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v44 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
      {
        id v45 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v45)) {
          int v46 = 43;
        }
        else {
          int v46 = 45;
        }
        __int16 v47 = object_getClassName(*(id *)(a1 + 32));
        CFStringRef v48 = sel_getName(*(SEL *)(a1 + 40));
        __int16 v49 = [*(id *)(a1 + 32) lastKnownRoutingConfig];
        *(_DWORD *)long long buf = 67110146;
        *(_DWORD *)&uint8_t buf[4] = v46;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = v47;
        *(_WORD *)&buf[18] = 2082;
        *(void *)&buf[20] = v48;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 7807;
        *(_WORD *)&buf[34] = 2114;
        *(void *)&buf[36] = v49;
        _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Forcing SE routing off:was  %{public}@", buf, 0x2Cu);
      }
      int v50 = *(void **)(a1 + 32);
      int v35 = [v50 lastKnownRoutingConfig];
      __int16 v36 = [v35 lpcdEcpFrame];
      BOOL v37 = +[NFRoutingConfig routingOffWithFD:3 ecp:v36];
      id v51 = [v50 setRoutingConfig:v37];
    }
  }
LABEL_52:
  int IsPad = NFProductIsPad();
  uint64_t v53 = *(void *)(a1 + 32);
  if (IsPad && *(unsigned char *)(v53 + 338))
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v54 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v54)
    {
      __int16 v55 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v55)) {
        uint64_t v56 = 43;
      }
      else {
        uint64_t v56 = 45;
      }
      __int16 v57 = object_getClassName(*(id *)(a1 + 32));
      __int16 v58 = sel_getName(*(SEL *)(a1 + 40));
      v54(6, "%c[%{public}s %{public}s]:%i Closing pre-warmed session due to sleep", v56, v57, v58, 7819);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v59 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v60 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v60)) {
        int v61 = 43;
      }
      else {
        int v61 = 45;
      }
      __int16 v62 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v63 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)long long buf = 67109890;
      *(_DWORD *)&uint8_t buf[4] = v61;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = v62;
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = v63;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 7819;
      _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Closing pre-warmed session due to sleep", buf, 0x22u);
    }

    sub_1002114AC(*(void **)(*(void *)(a1 + 32) + 368), @"Prewarm");
    uint64_t v53 = *(void *)(a1 + 32);
  }
  uint64_t v64 = *(void *)(v53 + 368);
  if (!v64) {
    goto LABEL_70;
  }
  if ((*(unsigned char *)(v64 + 219) & 1) == 0) {
    goto LABEL_70;
  }
  uint64_t v65 = *(void *)(v53 + 24);
  if (v65)
  {
    if (*(void *)(v65 + 136) == 1 || *(unsigned char *)(v65 + 170)) {
      goto LABEL_70;
    }
  }
  if (NFProductIsWatch() && sub_1000A4A58(*(void *)(a1 + 32)))
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v67 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v67)
    {
      id v68 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v68)) {
        uint64_t v69 = 43;
      }
      else {
        uint64_t v69 = 45;
      }
      id v70 = object_getClassName(*(id *)(a1 + 32));
      NSErrorUserInfoKey v71 = sel_getName(*(SEL *)(a1 + 40));
      v67(6, "%c[%{public}s %{public}s]:%i Persistent field detect enabled on device which is supposed to sleep. Not disabling FD.", v69, v70, v71, 7830);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v72 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v72, OS_LOG_TYPE_DEFAULT))
    {
      char v73 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v73)) {
        int v74 = 43;
      }
      else {
        int v74 = 45;
      }
      uint64_t v75 = object_getClassName(*(id *)(a1 + 32));
      int v76 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)long long buf = 67109890;
      *(_DWORD *)&uint8_t buf[4] = v74;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = v75;
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = v76;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 7830;
      _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Persistent field detect enabled on device which is supposed to sleep. Not disabling FD.", buf, 0x22u);
    }
  }
  else
  {
    uint64_t v77 = *(void *)(a1 + 32);
    if (v77 && (*(unsigned char *)(v77 + 355) & 1) != 0)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      BOOL v78 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v78)
      {
        __int16 v79 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v79)) {
          uint64_t v80 = 43;
        }
        else {
          uint64_t v80 = 45;
        }
        CFStringRef v81 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v82 = sel_getName(*(SEL *)(a1 + 40));
        v78(3, "%c[%{public}s %{public}s]:%i Forcing field detect off", v80, v81, v82, 7836);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v83 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
      {
        id v84 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v84)) {
          int v85 = 43;
        }
        else {
          int v85 = 45;
        }
        uint64_t v86 = object_getClassName(*(id *)(a1 + 32));
        id v87 = sel_getName(*(SEL *)(a1 + 40));
        *(_DWORD *)long long buf = 67109890;
        *(_DWORD *)&uint8_t buf[4] = v85;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = v86;
        *(_WORD *)&buf[18] = 2082;
        *(void *)&buf[20] = v87;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 7836;
        _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Forcing field detect off", buf, 0x22u);
      }

      sub_1000A3D08(*(void *)(a1 + 32), 0);
      id v88 = sub_1000A43A4(*(id **)(a1 + 32), 0);
    }
  }
  id v89 = *(id *)(*(void *)(a1 + 32) + 184);
  objc_sync_enter(v89);
  uint64_t v90 = *(void *)(a1 + 32);
  if (!*(void *)(v90 + 112))
  {
    objc_sync_exit(v89);

LABEL_70:
    char v16 = NFSharedSignpostLog();
    if (os_signpost_enabled(v16))
    {
      *(_WORD *)long long buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v16, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "powerObserverSystemWillSleep: allowing to sleep", (const char *)&unk_100286819, buf, 2u);
    }
LABEL_72:

    [*(id *)(*(void *)(a1 + 32) + 56) allowSleep];
    return;
  }
  long long v130 = 0u;
  memset(v131, 0, sizeof(v131));
  long long v128 = 0u;
  long long v129 = 0u;
  long long v126 = 0u;
  long long v127 = 0u;
  long long v124 = 0u;
  long long v125 = 0u;
  long long v122 = 0u;
  long long v123 = 0u;
  long long v120 = 0u;
  long long v121 = 0u;
  memset(buf, 0, sizeof(buf));
  proc_name((int)[*(id *)(v90 + 112) processIdentifier], buf, 0xFEu);
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v91 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
  if (v91)
  {
    __int16 v92 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v92)) {
      uint64_t v93 = 43;
    }
    else {
      uint64_t v93 = 45;
    }
    __int16 v94 = object_getClassName(*(id *)(a1 + 32));
    int v95 = sel_getName(*(SEL *)(a1 + 40));
    __int16 v96 = (objc_class *)objc_opt_class();
    int v97 = class_getName(v96);
    v91(6, "%c[%{public}s %{public}s]:%i Invalidating opened session from %s: %s", v93, v94, v95, 7845, buf, v97);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  long long v98 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
  {
    long long v99 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v99)) {
      int v100 = 43;
    }
    else {
      int v100 = 45;
    }
    CFStringRef v101 = object_getClassName(*(id *)(a1 + 32));
    id v102 = sel_getName(*(SEL *)(a1 + 40));
    NSErrorUserInfoKey v103 = (objc_class *)objc_opt_class();
    *(_DWORD *)__int16 v107 = 67110402;
    int v108 = v100;
    __int16 v109 = 2082;
    long long v110 = v101;
    __int16 v111 = 2082;
    int v112 = v102;
    __int16 v113 = 1024;
    int v114 = 7845;
    __int16 v115 = 2080;
    long long v116 = buf;
    __int16 v117 = 2080;
    long long v118 = class_getName(v103);
    _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Invalidating opened session from %s: %s", v107, 0x36u);
  }

  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v104 = [*(id *)(*(void *)(a1 + 32) + 112) connection];
    [v104 invalidate];
  }
  id v105 = NFSharedSignpostLog();
  if (os_signpost_enabled(v105))
  {
    *(_WORD *)__int16 v107 = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v105, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "powerObserverSystemWillSleep: session in progress; preventing sleep",
      (const char *)&unk_100286819,
      v107,
      2u);
  }

  objc_sync_exit(v89);
}

void sub_100128B08(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void *sub_100128D08(void *result)
{
  uint64_t v1 = result[4];
  if (*(unsigned char *)(v1 + 337))
  {
    uint64_t v2 = result;
    id v3 = *(id *)(v1 + 184);
    objc_sync_enter(v3);
    *(unsigned char *)(v2[4] + 344) = 0;
    sub_1001DCE6C(v2[4]);
    objc_sync_exit(v3);

    double v4 = (void *)v2[4];
    uint64_t v5 = sub_1000A49F8(v4);
    sub_1000A3D08((uint64_t)v4, v5);
    int IsPad = NFProductIsPad();
    uint64_t v7 = (unsigned char *)v2[4];
    if (IsPad && v7[338])
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        uint64_t v9 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass((id)v2[4]);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName((id)v2[4]);
        Name = sel_getName((SEL)v2[5]);
        uint64_t v13 = 45;
        if (isMetaClass) {
          uint64_t v13 = 43;
        }
        v9(6, "%c[%{public}s %{public}s]:%i Re-opening pre-warm session", v13, ClassName, Name, 7901);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v14 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
        CFStringRef v15 = object_getClass((id)v2[4]);
        if (class_isMetaClass(v15)) {
          int v16 = 43;
        }
        else {
          int v16 = 45;
        }
        uint64_t v17 = object_getClassName((id)v2[4]);
        uint64_t v18 = sel_getName((SEL)v2[5]);
        *(_DWORD *)long long buf = 67109890;
        int v32 = v16;
        __int16 v33 = 2082;
        uint64_t v34 = v17;
        __int16 v35 = 2082;
        __int16 v36 = v18;
        __int16 v37 = 1024;
        int v38 = 7901;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Re-opening pre-warm session", buf, 0x22u);
      }

      uint64_t v19 = sub_10020EC8C(*(void **)(v2[4] + 368), @"Prewarm", 0);
      if (v19)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        BOOL v20 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v20)
        {
          uint64_t v21 = object_getClass((id)v2[4]);
          if (class_isMetaClass(v21)) {
            uint64_t v22 = 43;
          }
          else {
            uint64_t v22 = 45;
          }
          uint64_t v23 = object_getClassName((id)v2[4]);
          uint64_t v24 = sel_getName((SEL)v2[5]);
          v20(4, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v22, v23, v24, 7904, v19);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        __int16 v25 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          __int16 v26 = object_getClass((id)v2[4]);
          if (class_isMetaClass(v26)) {
            int v27 = 43;
          }
          else {
            int v27 = 45;
          }
          int v28 = object_getClassName((id)v2[4]);
          __int16 v29 = sel_getName((SEL)v2[5]);
          *(_DWORD *)long long buf = 67110146;
          int v32 = v27;
          __int16 v33 = 2082;
          uint64_t v34 = v28;
          __int16 v35 = 2082;
          __int16 v36 = v29;
          __int16 v37 = 1024;
          int v38 = 7904;
          __int16 v39 = 2112;
          uint64_t v40 = v19;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
        }
      }
      uint64_t v7 = (unsigned char *)v2[4];
    }
    return [v7 maybeStartNextSession];
  }
  return result;
}

void sub_100129040(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100129384(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) NF_whitelistChecker];
  unsigned int v3 = [v2 ignoreAppStateMonitor];

  if (!v3)
  {
    BOOL v20 = [*(id *)(a1 + 32) NF_userInfo];
    uint64_t v13 = [v20 objectForKey:@"serviceType"];

    if (v13 && [v13 unsignedIntegerValue] == (id)2)
    {
      int v21 = sub_1000532C0(*(id **)(*(void *)(a1 + 40) + 72), *(void **)(a1 + 32));
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      uint64_t v23 = (void (*)(uint64_t, const char *, ...))Logger;
      if (v21)
      {
        if (Logger)
        {
          Class = object_getClass(*(id *)(a1 + 40));
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(*(id *)(a1 + 40));
          Name = sel_getName(*(SEL *)(a1 + 48));
          int v28 = [[*(id *)(a1 + 32) NF_userInfo];
          __int16 v29 = [v28 objectForKeyedSubscript:@"ClientName"];
          uint64_t v30 = 45;
          if (isMetaClass) {
            uint64_t v30 = 43;
          }
          v23(6, "%c[%{public}s %{public}s]:%i Invalidating XPC connection for %{public}@", v30, ClassName, Name, 7944, v29);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        BOOL v31 = NFSharedLogGetLogger();
        if (!os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_34;
        }
        int v32 = object_getClass(*(id *)(a1 + 40));
        if (class_isMetaClass(v32)) {
          int v33 = 43;
        }
        else {
          int v33 = 45;
        }
        uint64_t v34 = object_getClassName(*(id *)(a1 + 40));
        __int16 v35 = sel_getName(*(SEL *)(a1 + 48));
        __int16 v36 = [[*(id *)(a1 + 32) NF_userInfo];
        __int16 v37 = [v36 objectForKeyedSubscript:@"ClientName"];
        *(_DWORD *)long long buf = 67110146;
        int v73 = v33;
        __int16 v74 = 2082;
        uint64_t v75 = v34;
        __int16 v76 = 2082;
        uint64_t v77 = v35;
        __int16 v78 = 1024;
        int v79 = 7944;
        __int16 v80 = 2114;
        CFStringRef v81 = v37;
LABEL_33:
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Invalidating XPC connection for %{public}@", buf, 0x2Cu);

LABEL_34:
        sub_100052F78(*(void *)(*(void *)(a1 + 40) + 72), *(void **)(a1 + 32));
        [*(id *)(a1 + 32) invalidate];
        goto LABEL_55;
      }
      if (Logger)
      {
        __int16 v62 = object_getClass(*(id *)(a1 + 40));
        BOOL v63 = class_isMetaClass(v62);
        uint64_t v64 = object_getClassName(*(id *)(a1 + 40));
        NSErrorUserInfoKey v71 = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v65 = 45;
        if (v63) {
          uint64_t v65 = 43;
        }
        v23(6, "%c[%{public}s %{public}s]:%i Client is no longer in background", v65, v64, v71, 7948);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v56 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
      {
        int v66 = object_getClass(*(id *)(a1 + 40));
        if (class_isMetaClass(v66)) {
          int v67 = 43;
        }
        else {
          int v67 = 45;
        }
        id v68 = object_getClassName(*(id *)(a1 + 40));
        uint64_t v69 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)long long buf = 67109890;
        int v73 = v67;
        __int16 v74 = 2082;
        uint64_t v75 = v68;
        __int16 v76 = 2082;
        uint64_t v77 = v69;
        __int16 v78 = 1024;
        int v79 = 7948;
        int v61 = "%c[%{public}s %{public}s]:%i Client is no longer in background";
LABEL_53:
        _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, v61, buf, 0x22u);
      }
    }
    else
    {
      BOOL v38 = sub_100053034(*(id **)(*(void *)(a1 + 40) + 72), *(void **)(a1 + 32));
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v39 = NFLogGetLogger();
      uint64_t v40 = (void (*)(uint64_t, const char *, ...))v39;
      if (v38)
      {
        if (v39)
        {
          int v41 = object_getClass(*(id *)(a1 + 40));
          BOOL v42 = class_isMetaClass(v41);
          id v43 = object_getClassName(*(id *)(a1 + 40));
          uint64_t v44 = sel_getName(*(SEL *)(a1 + 48));
          id v45 = [[*(id *)(a1 + 32) NF_userInfo];
          int v46 = [v45 objectForKeyedSubscript:@"ClientName"];
          uint64_t v47 = 45;
          if (v42) {
            uint64_t v47 = 43;
          }
          v40(6, "%c[%{public}s %{public}s]:%i Invalidating XPC connection for %{public}@", v47, v43, v44, 7955, v46);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        BOOL v31 = NFSharedLogGetLogger();
        if (!os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_34;
        }
        CFStringRef v48 = object_getClass(*(id *)(a1 + 40));
        if (class_isMetaClass(v48)) {
          int v49 = 43;
        }
        else {
          int v49 = 45;
        }
        int v50 = object_getClassName(*(id *)(a1 + 40));
        id v51 = sel_getName(*(SEL *)(a1 + 48));
        __int16 v36 = [[*(id *)(a1 + 32) NF_userInfo];
        __int16 v37 = [v36 objectForKeyedSubscript:@"ClientName"];
        *(_DWORD *)long long buf = 67110146;
        int v73 = v49;
        __int16 v74 = 2082;
        uint64_t v75 = v50;
        __int16 v76 = 2082;
        uint64_t v77 = v51;
        __int16 v78 = 1024;
        int v79 = 7955;
        __int16 v80 = 2114;
        CFStringRef v81 = v37;
        goto LABEL_33;
      }
      if (v39)
      {
        __int16 v52 = object_getClass(*(id *)(a1 + 40));
        BOOL v53 = class_isMetaClass(v52);
        int v54 = object_getClassName(*(id *)(a1 + 40));
        id v70 = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v55 = 45;
        if (v53) {
          uint64_t v55 = 43;
        }
        v40(6, "%c[%{public}s %{public}s]:%i Client is no longer suspended", v55, v54, v70, 7960);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v56 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v57 = object_getClass(*(id *)(a1 + 40));
        if (class_isMetaClass(v57)) {
          int v58 = 43;
        }
        else {
          int v58 = 45;
        }
        uint64_t v59 = object_getClassName(*(id *)(a1 + 40));
        __int16 v60 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)long long buf = 67109890;
        int v73 = v58;
        __int16 v74 = 2082;
        uint64_t v75 = v59;
        __int16 v76 = 2082;
        uint64_t v77 = v60;
        __int16 v78 = 1024;
        int v79 = 7960;
        int v61 = "%c[%{public}s %{public}s]:%i Client is no longer suspended";
        goto LABEL_53;
      }
    }

    goto LABEL_55;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v4 = NFLogGetLogger();
  if (v4)
  {
    uint64_t v5 = (void (*)(uint64_t, const char *, ...))v4;
    id v6 = object_getClass(*(id *)(a1 + 40));
    BOOL v7 = class_isMetaClass(v6);
    BOOL v8 = object_getClassName(*(id *)(a1 + 40));
    uint64_t v9 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v10 = [*(id *)(a1 + 32) NF_userInfo];
    uint64_t v11 = [v10 objectForKeyedSubscript:@"ClientName"];
    uint64_t v12 = 45;
    if (v7) {
      uint64_t v12 = 43;
    }
    v5(6, "%c[%{public}s %{public}s]:%i Ignoring suspension since process allows for background : %{public}@", v12, v8, v9, 7928, v11);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v13 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = object_getClass(*(id *)(a1 + 40));
    if (class_isMetaClass(v14)) {
      int v15 = 43;
    }
    else {
      int v15 = 45;
    }
    int v16 = object_getClassName(*(id *)(a1 + 40));
    uint64_t v17 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v18 = [*(id *)(a1 + 32) NF_userInfo];
    uint64_t v19 = [v18 objectForKeyedSubscript:@"ClientName"];
    *(_DWORD *)long long buf = 67110146;
    int v73 = v15;
    __int16 v74 = 2082;
    uint64_t v75 = v16;
    __int16 v76 = 2082;
    uint64_t v77 = v17;
    __int16 v78 = 1024;
    int v79 = 7928;
    __int16 v80 = 2114;
    CFStringRef v81 = v19;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Ignoring suspension since process allows for background : %{public}@", buf, 0x2Cu);
  }
LABEL_55:
}

void sub_100129B74(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(unsigned char *)(v2 + 337))
  {
    if (*(void *)(v2 + 280) == 1)
    {
      uint64_t v3 = *(void *)(v2 + 368);
      uint64_t v4 = sub_1000EFF70((id *)v2);
      LODWORD(v3) = sub_100212014(v3, v4);

      if (v3)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          id v6 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(*(id *)(a1 + 32));
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(*(id *)(a1 + 32));
          Name = sel_getName(*(SEL *)(a1 + 40));
          uint64_t v10 = 45;
          if (isMetaClass) {
            uint64_t v10 = 43;
          }
          v6(5, "%c[%{public}s %{public}s]:%i driver flag change pending", v10, ClassName, Name, 8255);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v11 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v12 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v12)) {
            int v13 = 43;
          }
          else {
            int v13 = 45;
          }
          uint64_t v14 = object_getClassName(*(id *)(a1 + 32));
          int v15 = sel_getName(*(SEL *)(a1 + 40));
          *(_DWORD *)long long buf = 67109890;
          int v18 = v13;
          __int16 v19 = 2082;
          BOOL v20 = v14;
          __int16 v21 = 2082;
          uint64_t v22 = v15;
          __int16 v23 = 1024;
          int v24 = 8255;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i driver flag change pending", buf, 0x22u);
        }

        *(unsigned char *)(*(void *)(a1 + 32) + 339) = 1;
        [*(id *)(a1 + 32) maybeStartNextSession];
      }
    }
  }
}

id sub_10012A06C(uint64_t a1, void *a2)
{
  if (a1)
  {
    id v3 = a2;
    uint64_t v4 = NFSharedSignpostLog();
    if (os_signpost_enabled(v4))
    {
      *(_WORD *)long long buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v4, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "SetRoutingConfigInDriver", (const char *)&unk_100286819, buf, 2u);
    }

    [v3 calculateFieldDetectEnabled:sub_1000A49F8((void *)a1)];
    uint64_t v5 = +[NFPowerAssertion sharedPowerAssertion];
    [v5 releasePowerAssertion:@"ExpressMode" logFaultOnOverRelease:0];

    sub_100040C1C(*(void **)(a1 + 24));
    id v6 = sub_100213CD8(*(void **)(a1 + 368), v3);

    if (v6)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        BOOL v8 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass((id)a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName((id)a1);
        Name = sel_getName("_setRoutingConfigInDriver:");
        uint64_t v12 = 45;
        if (isMetaClass) {
          uint64_t v12 = 43;
        }
        v8(3, "%c[%{public}s %{public}s]:%i Failed to change mode", v12, ClassName, Name, 8516);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v13 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        uint64_t v14 = object_getClass((id)a1);
        if (class_isMetaClass(v14)) {
          int v15 = 43;
        }
        else {
          int v15 = 45;
        }
        int v16 = object_getClassName((id)a1);
        uint64_t v17 = sel_getName("_setRoutingConfigInDriver:");
        *(_DWORD *)long long buf = 67109890;
        int v24 = v15;
        __int16 v25 = 2082;
        __int16 v26 = v16;
        __int16 v27 = 2082;
        int v28 = v17;
        __int16 v29 = 1024;
        int v30 = 8516;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to change mode", buf, 0x22u);
      }

      int v18 = NFSharedSignpostLog();
      if (os_signpost_enabled(v18))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v18, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SetRoutingConfigInDriver", "Failed", buf, 2u);
      }

      id v19 = v6;
    }
    else
    {
      BOOL v20 = NFSharedSignpostLog();
      if (os_signpost_enabled(v20))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v20, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SetRoutingConfigInDriver", "Success", buf, 2u);
      }
    }
  }
  else
  {
    id v6 = 0;
  }

  return v6;
}

void *sub_10012A770(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) driverWrapper];
  id v3 = sub_1001E06D4(v2, *(void **)(a1 + 40));

  if ((v3 & 1) == 0)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v5(3, "%c[%{public}s %{public}s]:%i Failed to configure ECP polling.", v9, ClassName, Name, 8396);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      uint64_t v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      int v13 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)long long buf = 67109890;
      int v18 = v12;
      __int16 v19 = 2082;
      BOOL v20 = v13;
      __int16 v21 = 2082;
      uint64_t v22 = v14;
      __int16 v23 = 1024;
      int v24 = 8396;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to configure ECP polling.", buf, 0x22u);
    }
  }
  return v3;
}

uint64_t sub_10012AF6C(uint64_t a1)
{
  if (!sub_1001E0AFC(*(void **)(*(void *)(a1 + 32) + 368)))
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v8 = 45;
      if (isMetaClass) {
        uint64_t v8 = 43;
      }
      v4(3, "%c[%{public}s %{public}s]:%i Failed to configure Felica entry conditions", v8, ClassName, Name, 8843);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v9 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
      goto LABEL_23;
    }
    uint64_t v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    int v12 = object_getClassName(*(id *)(a1 + 32));
    int v13 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)long long buf = 67109890;
    int v28 = v11;
    __int16 v29 = 2082;
    int v30 = v12;
    __int16 v31 = 2082;
    int v32 = v13;
    __int16 v33 = 1024;
    int v34 = 8843;
    uint64_t v14 = "%c[%{public}s %{public}s]:%i Failed to configure Felica entry conditions";
    goto LABEL_22;
  }
  if (sub_1001E0A88(*(void **)(*(void *)(a1 + 32) + 368))) {
    return 1;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v15 = NFLogGetLogger();
  if (v15)
  {
    int v16 = (void (*)(uint64_t, const char *, ...))v15;
    uint64_t v17 = object_getClass(*(id *)(a1 + 32));
    BOOL v18 = class_isMetaClass(v17);
    __int16 v19 = object_getClassName(*(id *)(a1 + 32));
    __int16 v26 = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v20 = 45;
    if (v18) {
      uint64_t v20 = 43;
    }
    v16(3, "%c[%{public}s %{public}s]:%i Failed to enable Felica dual entry", v20, v19, v26, 8839);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
  {
    __int16 v21 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v21)) {
      int v22 = 43;
    }
    else {
      int v22 = 45;
    }
    __int16 v23 = object_getClassName(*(id *)(a1 + 32));
    int v24 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)long long buf = 67109890;
    int v28 = v22;
    __int16 v29 = 2082;
    int v30 = v23;
    __int16 v31 = 2082;
    int v32 = v24;
    __int16 v33 = 1024;
    int v34 = 8839;
    uint64_t v14 = "%c[%{public}s %{public}s]:%i Failed to enable Felica dual entry";
LABEL_22:
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, v14, buf, 0x22u);
  }
LABEL_23:

  return 0;
}

id sub_10012B21C(id result)
{
  if (result)
  {
    uint64_t v1 = [result lastKnownRoutingConfig];
    id v2 = [v1 wantsReader];

    return v2;
  }
  return result;
}

uint64_t sub_10012B2A8(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v5 = *(void **)(a1 + 120);
    BOOL v7 = v4;
    if (v5)
    {
      [v5 removeObserver:a1 forKeyPath:@"walletDomain"];
      uint64_t v4 = v7;
    }
    *(void *)(a1 + 120) = v4;
    id v3 = [v4 addObserver:a1 forKeyPath:@"walletDomain" options:5 context:off_100346250];
    uint64_t v4 = v7;
  }

  return _objc_release_x1(v3, v4);
}

void sub_10012B370(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 168), a2);
  }
}

void sub_10012B380(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 112), a2);
  }
}

uint64_t sub_10012B58C()
{
  uint64_t v2 = 0;
  id v3 = &v2;
  uint64_t v4 = 0x2020000000;
  uint64_t v0 = qword_100347438;
  uint64_t v5 = qword_100347438;
  if (!qword_100347438)
  {
    long long v6 = *(_OWORD *)off_100304A08;
    uint64_t v7 = 0;
    v3[3] = _sl_dlopen();
    qword_100347438 = v3[3];
    uint64_t v0 = v3[3];
  }
  _Block_object_dispose(&v2, 8);
  return v0;
}

void sub_10012B6A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10012B6BC(uint64_t a1)
{
  uint64_t result = _sl_dlopen();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  qword_100347438 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_10012B754(void *a1)
{
  if (!sub_10012B58C())
  {
    uint64_t v2 = +[NSAssertionHandler currentHandler];
    a1 = +[NSString stringWithUTF8String:"void *libSystemHealthLibrary(void)"];
    [v2 handleFailureInFunction:a1 file:@"_NFHardwareManager.m" lineNumber:130 description:@"%s"];

    __break(1u);
    free(v3);
  }
  *(void *)(*(void *)(a1[4] + 8) + 24) = objc_getClass("SystemHealthManager");
  if (*(void *)(*(void *)(a1[4] + 8) + 24))
  {
    qword_100347440 = *(void *)(*(void *)(a1[4] + 8) + 24);
  }
  else
  {
    uint64_t v4 = +[NSAssertionHandler currentHandler];
    uint64_t v5 = +[NSString stringWithUTF8String:"Class getSystemHealthManagerClass(void)_block_invoke"];
    [v4 handleFailureInFunction:v5 file:@"_NFHardwareManager.m" lineNumber:131 description:@"Unable to find class %s" , @"SystemHealthManager"];

    __break(1u);
  }
}

void sub_10012EFA0(uint64_t a1)
{
  kdebug_trace();
  uint64_t v2 = NFSharedSignpostLog();
  if (os_signpost_enabled(v2))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v2, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLIENT_GET_APPLETS", "in dispatch", buf, 2u);
  }

  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    __int16 v19 = [*(id *)(a1 + 32) preloadApplets];
    uint64_t v23 = *(void *)(a1 + 40);
    uint64_t v20 = [*(id *)(a1 + 32) applets];
    __int16 v21 = [*(id *)(a1 + 32) activeApplet];
    (*(void (**)(uint64_t, void *, void *, void *))(v23 + 16))(v23, v20, v21, v19);
    goto LABEL_17;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v9 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v10 = 45;
    if (isMetaClass) {
      uint64_t v10 = 43;
    }
    v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, ClassName, Name, 260, v9);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v11 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    int v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12)) {
      int v13 = 43;
    }
    else {
      int v13 = 45;
    }
    uint64_t v14 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v15 = sel_getName(*(SEL *)(a1 + 48));
    int v16 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v27 = v13;
    __int16 v28 = 2082;
    __int16 v29 = v14;
    __int16 v30 = 2082;
    __int16 v31 = v15;
    __int16 v32 = 1024;
    int v33 = 260;
    __int16 v34 = 2114;
    __int16 v35 = v16;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v17 = *(void *)(a1 + 40);
  if (v17)
  {
    id v18 = objc_alloc((Class)NSError);
    __int16 v19 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v24 = NSLocalizedDescriptionKey;
    uint64_t v20 = +[NSString stringWithUTF8String:"Session not active"];
    __int16 v25 = v20;
    __int16 v21 = +[NSDictionary dictionaryWithObjects:&v25 forKeys:&v24 count:1];
    id v22 = [v18 initWithDomain:v19 code:54 userInfo:v21];
    (*(void (**)(uint64_t, void, void, id))(v17 + 16))(v17, 0, 0, v22);

LABEL_17:
  }
}

void sub_10012F500(uint64_t a1)
{
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v23 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 72));
      __int16 v28 = [*(id *)(a1 + 32) clientName];
      uint64_t v29 = 43;
      if (!isMetaClass) {
        uint64_t v29 = 45;
      }
      v23(6, "%c[%{public}s %{public}s]:%i %{public}@ : requestedApplet: %{public}@ keyIdentifiers: %{public}@", v29, ClassName, Name, 279, v28, *(void *)(a1 + 40), *(void *)(a1 + 48));
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v30 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v31 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v31)) {
        int v32 = 43;
      }
      else {
        int v32 = 45;
      }
      int v33 = object_getClassName(*(id *)(a1 + 32));
      __int16 v34 = sel_getName(*(SEL *)(a1 + 72));
      __int16 v35 = [*(id *)(a1 + 32) clientName];
      __int16 v36 = *(void **)(a1 + 40);
      uint64_t v37 = *(void *)(a1 + 48);
      *(_DWORD *)long long buf = 67110658;
      int v225 = v32;
      __int16 v226 = 2082;
      int v227 = v33;
      __int16 v228 = 2082;
      int v229 = v34;
      __int16 v230 = 1024;
      int v231 = 279;
      __int16 v232 = 2114;
      id v233 = v35;
      __int16 v234 = 2114;
      uint64_t v235 = v36;
      __int16 v236 = 2114;
      uint64_t v237 = v37;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@ : requestedApplet: %{public}@ keyIdentifiers: %{public}@", buf, 0x40u);
    }
    id v18 = *(id *)(a1 + 40);
    BOOL v38 = [*(id *)(a1 + 32) expressModeManager];
    if (v38)
    {
      int v39 = v38[172];

      if (v39)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v40 = NFLogGetLogger();
        if (v40)
        {
          int v41 = (void (*)(uint64_t, const char *, ...))v40;
          BOOL v42 = object_getClass(*(id *)(a1 + 32));
          BOOL v43 = class_isMetaClass(v42);
          uint64_t v44 = object_getClassName(*(id *)(a1 + 32));
          uint64_t v208 = sel_getName(*(SEL *)(a1 + 72));
          uint64_t v45 = 45;
          if (v43) {
            uint64_t v45 = 43;
          }
          v41(4, "%c[%{public}s %{public}s]:%i Express mode in progress, denying..", v45, v44, v208, 284);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v46 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
        {
          uint64_t v47 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v47)) {
            int v48 = 43;
          }
          else {
            int v48 = 45;
          }
          int v49 = object_getClassName(*(id *)(a1 + 32));
          int v50 = sel_getName(*(SEL *)(a1 + 72));
          *(_DWORD *)long long buf = 67109890;
          int v225 = v48;
          __int16 v226 = 2082;
          int v227 = v49;
          __int16 v228 = 2082;
          int v229 = v50;
          __int16 v230 = 1024;
          int v231 = 284;
          _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Express mode in progress, denying..", buf, 0x22u);
        }

        uint64_t v51 = *(void *)(a1 + 64);
        id v52 = objc_alloc((Class)NSError);
        BOOL v53 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v222 = NSLocalizedDescriptionKey;
        int v54 = +[NSString stringWithUTF8String:"Express Mode in progress"];
        BOOL v223 = v54;
        uint64_t v55 = +[NSDictionary dictionaryWithObjects:&v223 forKeys:&v222 count:1];
        id v56 = [v52 initWithDomain:v53 code:38 userInfo:v55];
        (*(void (**)(uint64_t, void, void, id))(v51 + 16))(v51, 0, 0, v56);

        goto LABEL_16;
      }
    }
    uint64_t v57 = [v18 groupHeadID];
    if (v57)
    {
      int v58 = (void *)v57;
      uint64_t v59 = [*(id *)(a1 + 32) secureElementWrapper];
      unsigned __int8 v60 = [v59 supportedTechnologies];

      if ((v60 & 4) != 0)
      {
        [*(id *)(a1 + 32) switchToSecureElementWrapperForApplet:v18];
        [*(id *)(a1 + 32) startWiredMode];
        int v61 = [*(id *)(a1 + 32) secureElementWrapper];
        __int16 v62 = [v18 groupHeadID];
        BOOL v63 = sub_1002473C8(v61, v62);

        if ([v63 isTypeF])
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v64 = NFLogGetLogger();
          if (v64)
          {
            uint64_t v65 = (void (*)(uint64_t, const char *, ...))v64;
            int v66 = object_getClass(*(id *)(a1 + 32));
            BOOL v67 = class_isMetaClass(v66);
            uint64_t v206 = object_getClassName(*(id *)(a1 + 32));
            uint64_t v209 = sel_getName(*(SEL *)(a1 + 72));
            uint64_t v68 = 45;
            if (v67) {
              uint64_t v68 = 43;
            }
            v65(6, "%c[%{public}s %{public}s]:%i Switching applet to Type-F group head applet - %{public}@", v68, v206, v209, 296, v63);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v69 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
          {
            id v70 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v70)) {
              int v71 = 43;
            }
            else {
              int v71 = 45;
            }
            uint64_t v72 = object_getClassName(*(id *)(a1 + 32));
            int v73 = sel_getName(*(SEL *)(a1 + 72));
            *(_DWORD *)long long buf = 67110146;
            int v225 = v71;
            __int16 v226 = 2082;
            int v227 = v72;
            __int16 v228 = 2082;
            int v229 = v73;
            __int16 v230 = 1024;
            int v231 = 296;
            __int16 v232 = 2114;
            id v233 = v63;
            _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Switching applet to Type-F group head applet - %{public}@", buf, 0x2Cu);
          }

          id v74 = v63;
          id v18 = v74;
        }
      }
    }
    uint64_t v76 = *(void *)(a1 + 40);
    uint64_t v75 = *(void *)(a1 + 48);
    uint64_t v77 = *(void **)(a1 + 32);
    uint64_t v78 = [v77 expressModeManager];
    int v79 = (void *)v78;
    if (v78) {
      uint64_t v80 = *(void *)(v78 + 136);
    }
    else {
      uint64_t v80 = 0;
    }
    CFStringRef v81 = [v77 setActiveKeys:v75 onApplet:v76 allowBackgroundTransactions:v80 != -1];

    if (v81)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v82 = NFLogGetLogger();
      if (v82)
      {
        uint64_t v83 = (void (*)(uint64_t, const char *, ...))v82;
        id v84 = object_getClass(*(id *)(a1 + 32));
        BOOL v85 = class_isMetaClass(v84);
        uint64_t v86 = object_getClassName(*(id *)(a1 + 32));
        id v87 = sel_getName(*(SEL *)(a1 + 72));
        uint64_t v88 = 45;
        if (v85) {
          uint64_t v88 = 43;
        }
        v83(3, "%c[%{public}s %{public}s]:%i Failed to setup active keys %{public}@ - error %{public}@", v88, v86, v87, 307, *(void *)(a1 + 48), v81);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v89 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v89, OS_LOG_TYPE_ERROR))
      {
        uint64_t v90 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v90)) {
          int v91 = 43;
        }
        else {
          int v91 = 45;
        }
        __int16 v92 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v93 = sel_getName(*(SEL *)(a1 + 72));
        __int16 v94 = *(void **)(a1 + 48);
        *(_DWORD *)long long buf = 67110402;
        int v225 = v91;
        __int16 v226 = 2082;
        int v227 = v92;
        __int16 v228 = 2082;
        int v229 = v93;
        __int16 v230 = 1024;
        int v231 = 307;
        __int16 v232 = 2114;
        id v233 = v94;
        __int16 v234 = 2114;
        uint64_t v235 = v81;
        _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to setup active keys %{public}@ - error %{public}@", buf, 0x36u);
      }

      goto LABEL_66;
    }
    [*(id *)(a1 + 32) setDeferredActivationApplet:0];
    long long v98 = [*(id *)(a1 + 32) activeApplet];
    unsigned __int8 v99 = [v18 isEqualToApplet:v98];

    if ((v99 & 1) == 0)
    {
      int v100 = *(unsigned char **)(a1 + 32);
      if (v18)
      {
        if (v100[264])
        {
          CFStringRef v101 = [*(id *)(a1 + 32) activeApplet];

          int v100 = *(unsigned char **)(a1 + 32);
          if (v101)
          {
            id v102 = [*(id *)(a1 + 32) activeApplet];
            NSErrorUserInfoKey v103 = [v100 seidForApplet:v102];

            uint64_t v104 = [*(id *)(a1 + 32) seidForApplet:v18];
            if (([v103 isEqualToString:v104] & 1) == 0)
            {
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v105 = NFLogGetLogger();
              if (v105)
              {
                int v106 = (void (*)(uint64_t, const char *, ...))v105;
                __int16 v107 = object_getClass(*(id *)(a1 + 32));
                BOOL v214 = class_isMetaClass(v107);
                int v108 = object_getClassName(*(id *)(a1 + 32));
                __int16 v109 = sel_getName(*(SEL *)(a1 + 72));
                long long v110 = [*(id *)(a1 + 32) activeApplet];
                uint64_t v111 = 45;
                if (v214) {
                  uint64_t v111 = 43;
                }
                v106(6, "%c[%{public}s %{public}s]:%i deauthorizing previously authed applet on different seid: %{public}@", v111, v108, v109, 321, v110);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              int v112 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v112, OS_LOG_TYPE_DEFAULT))
              {
                __int16 v113 = object_getClass(*(id *)(a1 + 32));
                if (class_isMetaClass(v113)) {
                  int v114 = 43;
                }
                else {
                  int v114 = 45;
                }
                int v215 = v114;
                __int16 v115 = object_getClassName(*(id *)(a1 + 32));
                long long v116 = sel_getName(*(SEL *)(a1 + 72));
                __int16 v117 = [*(id *)(a1 + 32) activeApplet];
                *(_DWORD *)long long buf = 67110146;
                int v225 = v215;
                __int16 v226 = 2082;
                int v227 = v115;
                __int16 v228 = 2082;
                int v229 = v116;
                __int16 v230 = 1024;
                int v231 = 321;
                __int16 v232 = 2114;
                id v233 = v117;
                _os_log_impl((void *)&_mh_execute_header, v112, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i deauthorizing previously authed applet on different seid: %{public}@", buf, 0x2Cu);
              }
              [*(id *)(a1 + 32) _deauthorize];
            }

            int v100 = *(unsigned char **)(a1 + 32);
          }
        }
      }
      if ([v100 _requiresDeferredActivation:v18])
      {
        [*(id *)(a1 + 32) setDeferredActivationApplet:v18];
        id v118 = [*(id *)(a1 + 32) setActiveApplet:0];
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v119 = NFLogGetLogger();
        if (v119)
        {
          long long v120 = (void (*)(uint64_t, const char *, ...))v119;
          long long v121 = object_getClass(*(id *)(a1 + 32));
          BOOL v122 = class_isMetaClass(v121);
          long long v123 = object_getClassName(*(id *)(a1 + 32));
          long long v124 = sel_getName(*(SEL *)(a1 + 72));
          long long v125 = [*(id *)(a1 + 32) deferredActivationApplet];
          long long v126 = [v125 identifier];
          uint64_t v127 = 45;
          if (v122) {
            uint64_t v127 = 43;
          }
          v120(6, "%c[%{public}s %{public}s]:%i Applet %{public}@ requires deferred activation", v127, v123, v124, 329, v126);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        long long v128 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v128, OS_LOG_TYPE_DEFAULT))
        {
          long long v129 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v129)) {
            int v130 = 43;
          }
          else {
            int v130 = 45;
          }
          long long v131 = object_getClassName(*(id *)(a1 + 32));
          long long v132 = sel_getName(*(SEL *)(a1 + 72));
          uint64_t v133 = [*(id *)(a1 + 32) deferredActivationApplet];
          uint64_t v134 = [v133 identifier];
          *(_DWORD *)long long buf = 67110146;
          int v225 = v130;
          __int16 v226 = 2082;
          int v227 = v131;
          __int16 v228 = 2082;
          int v229 = v132;
          __int16 v230 = 1024;
          int v231 = 329;
          __int16 v232 = 2114;
          id v233 = v134;
          _os_log_impl((void *)&_mh_execute_header, v128, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Applet %{public}@ requires deferred activation", buf, 0x2Cu);
        }
      }
      else
      {
        kdebug_trace();
        int v135 = NFSharedSignpostLog();
        if (os_signpost_enabled(v135))
        {
          *(_WORD *)long long buf = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v135, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "ACTIVATE_APPLET", (const char *)&unk_100286819, buf, 2u);
        }

        uint64_t v136 = [*(id *)(a1 + 32) setActiveApplet:v18];
        if (v136)
        {
          CFStringRef v81 = (void *)v136;
LABEL_66:
          uint64_t v95 = *(void *)(a1 + 64);
          __int16 v96 = [*(id *)(a1 + 32) activeApplet];
          int v97 = [*(id *)(a1 + 32) activeKeyIdentifiers];
          (*(void (**)(uint64_t, void *, void *, void *))(v95 + 16))(v95, v96, v97, v81);

          [*(id *)(a1 + 32) startDefaultMode];
          goto LABEL_16;
        }
      }
    }
    BOOL v137 = [*(id *)(a1 + 32) deferredActivationApplet];

    if (v137)
    {
      uint64_t v138 = *(void *)(a1 + 56);
      if (v138)
      {
        v139 = *(void **)(a1 + 32);
        v216[0] = _NSConcreteStackBlock;
        v216[1] = 3221225472;
        v216[2] = sub_100130BE0;
        v216[3] = &unk_100304D00;
        id v140 = *(id *)(a1 + 64);
        v216[4] = *(void *)(a1 + 32);
        id v217 = v140;
        [v139 _sync_startDeferredCardEmulationWithAuthorization:v138 completion:v216];

        goto LABEL_16;
      }
      uint64_t v175 = *(void *)(a1 + 64);
      uint64_t v176 = [*(id *)(a1 + 32) deferredActivationApplet];
      goto LABEL_158;
    }
    [*(id *)(a1 + 32) switchToSecureElementWrapperForApplet:v18];
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v141 = NFLogGetLogger();
    if (v141)
    {
      id v142 = (void (*)(uint64_t, const char *, ...))v141;
      id v143 = object_getClass(*(id *)(a1 + 32));
      BOOL v144 = class_isMetaClass(v143);
      uint64_t v207 = object_getClassName(*(id *)(a1 + 32));
      v210 = sel_getName(*(SEL *)(a1 + 72));
      uint64_t v145 = 45;
      if (v144) {
        uint64_t v145 = 43;
      }
      v142(6, "%c[%{public}s %{public}s]:%i active = %{public}@", v145, v207, v210, 359, v18);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v146 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v146, OS_LOG_TYPE_DEFAULT))
    {
      id v147 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v147)) {
        int v148 = 43;
      }
      else {
        int v148 = 45;
      }
      uint64_t v149 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v150 = sel_getName(*(SEL *)(a1 + 72));
      *(_DWORD *)long long buf = 67110146;
      int v225 = v148;
      __int16 v226 = 2082;
      int v227 = v149;
      __int16 v228 = 2082;
      int v229 = v150;
      __int16 v230 = 1024;
      int v231 = 359;
      __int16 v232 = 2114;
      id v233 = v18;
      _os_log_impl((void *)&_mh_execute_header, v146, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i active = %{public}@", buf, 0x2Cu);
    }

    if (*(void *)(a1 + 56))
    {
      kdebug_trace();
      uint64_t v151 = NFSharedSignpostLog();
      if (os_signpost_enabled(v151))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v151, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "AUTHORIZE_APPLET", (const char *)&unk_100286819, buf, 2u);
      }

      if (([*(id *)(a1 + 32) _authorize:*(void *)(a1 + 56)] & 1) == 0)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v189 = NFLogGetLogger();
        if (v189)
        {
          id v190 = (void (*)(uint64_t, const char *, ...))v189;
          unsigned int v191 = object_getClass(*(id *)(a1 + 32));
          BOOL v192 = class_isMetaClass(v191);
          unsigned int v193 = object_getClassName(*(id *)(a1 + 32));
          char v213 = sel_getName(*(SEL *)(a1 + 72));
          uint64_t v194 = 45;
          if (v192) {
            uint64_t v194 = 43;
          }
          v190(3, "%c[%{public}s %{public}s]:%i Failed to authorize", v194, v193, v213, 366);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v195 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v195, OS_LOG_TYPE_ERROR))
        {
          BOOL v196 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v196)) {
            int v197 = 43;
          }
          else {
            int v197 = 45;
          }
          int v198 = object_getClassName(*(id *)(a1 + 32));
          id v199 = sel_getName(*(SEL *)(a1 + 72));
          *(_DWORD *)long long buf = 67109890;
          int v225 = v197;
          __int16 v226 = 2082;
          int v227 = v198;
          __int16 v228 = 2082;
          int v229 = v199;
          __int16 v230 = 1024;
          int v231 = 366;
          _os_log_impl((void *)&_mh_execute_header, v195, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to authorize", buf, 0x22u);
        }

        uint64_t v165 = *(void *)(a1 + 64);
        uint64_t v166 = [*(id *)(a1 + 32) activeApplet];
        id v167 = [*(id *)(a1 + 32) activeKeyIdentifiers];
        id v200 = objc_alloc((Class)NSError);
        char v169 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v220 = NSLocalizedDescriptionKey;
        uint64_t v170 = +[NSString stringWithUTF8String:"Commmand Error"];
        uint64_t v221 = v170;
        id v171 = +[NSDictionary dictionaryWithObjects:&v221 forKeys:&v220 count:1];
        uint64_t v172 = v200;
        v173 = v169;
        uint64_t v174 = 16;
        goto LABEL_151;
      }
      kdebug_trace();
      uint64_t v152 = NFSharedSignpostLog();
      if (os_signpost_enabled(v152))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v152, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "START_PAYMENT_EMULATION", (const char *)&unk_100286819, buf, 2u);
      }

      if ((objc_msgSend(*(id *)(a1 + 32), "startCardEmulationWithType:", objc_msgSend(*(id *)(a1 + 32), "defaultEmulationType")) & 1) == 0)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v153 = NFLogGetLogger();
        if (v153)
        {
          v154 = (void (*)(uint64_t, const char *, ...))v153;
          int v155 = object_getClass(*(id *)(a1 + 32));
          BOOL v156 = class_isMetaClass(v155);
          id v157 = object_getClassName(*(id *)(a1 + 32));
          int v211 = sel_getName(*(SEL *)(a1 + 72));
          uint64_t v158 = 45;
          if (v156) {
            uint64_t v158 = 43;
          }
          v154(3, "%c[%{public}s %{public}s]:%i Failed to start card emulation", v158, v157, v211, 376);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v159 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v159, OS_LOG_TYPE_ERROR))
        {
          uint64_t v160 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v160)) {
            int v161 = 43;
          }
          else {
            int v161 = 45;
          }
          uint64_t v162 = object_getClassName(*(id *)(a1 + 32));
          uint64_t v163 = sel_getName(*(SEL *)(a1 + 72));
          *(_DWORD *)long long buf = 67109890;
          int v225 = v161;
          __int16 v226 = 2082;
          int v227 = v162;
          __int16 v228 = 2082;
          int v229 = v163;
          __int16 v230 = 1024;
          int v231 = 376;
          _os_log_impl((void *)&_mh_execute_header, v159, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to start card emulation", buf, 0x22u);
        }

        int v164 = *(unsigned char **)(a1 + 32);
        if (v164[264])
        {
          [v164 _deauthorize];
          int v164 = *(unsigned char **)(a1 + 32);
        }
        uint64_t v165 = *(void *)(a1 + 64);
        uint64_t v166 = [v164 activeApplet];
        id v167 = [*(id *)(a1 + 32) activeKeyIdentifiers];
        id v168 = objc_alloc((Class)NSError);
        char v169 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v218 = NSLocalizedDescriptionKey;
        uint64_t v170 = +[NSString stringWithUTF8String:"Stack Error"];
        uint64_t v219 = v170;
        id v171 = +[NSDictionary dictionaryWithObjects:&v219 forKeys:&v218 count:1];
        uint64_t v172 = v168;
        v173 = v169;
        uint64_t v174 = 15;
LABEL_151:
        id v201 = [v172 initWithDomain:v173 code:v174 userInfo:v171];
        (*(void (**)(uint64_t, void *, void *, id))(v165 + 16))(v165, v166, v167, v201);

        [*(id *)(a1 + 32) startDefaultMode];
        goto LABEL_16;
      }
    }
    else
    {
      int v177 = *(unsigned char **)(a1 + 32);
      if (v177[264])
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v178 = NFLogGetLogger();
        if (v178)
        {
          id v179 = (void (*)(uint64_t, const char *, ...))v178;
          uint64_t v180 = object_getClass(*(id *)(a1 + 32));
          BOOL v181 = class_isMetaClass(v180);
          unsigned int v182 = object_getClassName(*(id *)(a1 + 32));
          __int16 v212 = sel_getName(*(SEL *)(a1 + 72));
          uint64_t v183 = 45;
          if (v181) {
            uint64_t v183 = 43;
          }
          v179(6, "%c[%{public}s %{public}s]:%i Already authorized - staying in wired mode - need to call startCardEmulation or enable express", v183, v182, v212, 386);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v184 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v184, OS_LOG_TYPE_DEFAULT))
        {
          NSErrorUserInfoKey v185 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v185)) {
            int v186 = 43;
          }
          else {
            int v186 = 45;
          }
          id v187 = object_getClassName(*(id *)(a1 + 32));
          NSErrorUserInfoKey v188 = sel_getName(*(SEL *)(a1 + 72));
          *(_DWORD *)long long buf = 67109890;
          int v225 = v186;
          __int16 v226 = 2082;
          int v227 = v187;
          __int16 v228 = 2082;
          int v229 = v188;
          __int16 v230 = 1024;
          int v231 = 386;
          _os_log_impl((void *)&_mh_execute_header, v184, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Already authorized - staying in wired mode - need to call startCardEmulation or enable express", buf, 0x22u);
        }
      }
      else
      {
        long long v202 = [v177 activeKeyIdentifiers];

        long long v203 = *(void **)(a1 + 32);
        if (v202) {
          [v203 startDefaultModeAndKeepSEOn:1];
        }
        else {
          [v203 startDefaultMode];
        }
      }
    }
    kdebug_trace();
    uint64_t v204 = NFSharedSignpostLog();
    if (os_signpost_enabled(v204))
    {
      *(_WORD *)long long buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v204, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLIENT_CALLBACK", (const char *)&unk_100286819, buf, 2u);
    }

    uint64_t v175 = *(void *)(a1 + 64);
    uint64_t v176 = [*(id *)(a1 + 32) activeApplet];
LABEL_158:
    __int16 v19 = (void *)v176;
    uint64_t v205 = [*(id *)(a1 + 32) activeKeyIdentifiers];
    (*(void (**)(uint64_t, void *, void *, void))(v175 + 16))(v175, v19, v205, 0);

    goto LABEL_15;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v2 = NFLogGetLogger();
  if (v2)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))v2;
    uint64_t v4 = object_getClass(*(id *)(a1 + 32));
    BOOL v5 = class_isMetaClass(v4);
    long long v6 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v7 = sel_getName(*(SEL *)(a1 + 72));
    uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v9 = 45;
    if (v5) {
      uint64_t v9 = 43;
    }
    v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, v6, v7, 277, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    int v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    int v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 72));
    uint64_t v15 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v225 = v12;
    __int16 v226 = 2082;
    int v227 = v13;
    __int16 v228 = 2082;
    int v229 = v14;
    __int16 v230 = 1024;
    int v231 = 277;
    __int16 v232 = 2114;
    id v233 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v16 = *(void *)(a1 + 64);
  if (v16)
  {
    id v17 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v238 = NSLocalizedDescriptionKey;
    __int16 v19 = +[NSString stringWithUTF8String:"Session not active"];
    uint64_t v239 = v19;
    uint64_t v20 = +[NSDictionary dictionaryWithObjects:&v239 forKeys:&v238 count:1];
    id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
    (*(void (**)(uint64_t, void, void, id))(v16 + 16))(v16, 0, 0, v21);

LABEL_15:
LABEL_16:
  }
}

void sub_100130BE0(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  id v5 = a2;
  id v7 = [v4 deferredActivationApplet];
  long long v6 = [*(id *)(a1 + 32) activeKeyIdentifiers];
  (*(void (**)(uint64_t, id, void *, id))(v3 + 16))(v3, v7, v6, v5);
}

void sub_100130E40(uint64_t a1)
{
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    int v27 = [*(id *)(a1 + 32) expressModeManager];
    if (v27)
    {
      int v28 = v27[172];

      if (v28)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          __int16 v30 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(*(id *)(a1 + 32));
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(*(id *)(a1 + 32));
          Name = sel_getName(*(SEL *)(a1 + 64));
          uint64_t v34 = 45;
          if (isMetaClass) {
            uint64_t v34 = 43;
          }
          v30(4, "%c[%{public}s %{public}s]:%i Express mode in progress, denying..", v34, ClassName, Name, 416);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        __int16 v35 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          __int16 v36 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v36)) {
            int v37 = 43;
          }
          else {
            int v37 = 45;
          }
          BOOL v38 = object_getClassName(*(id *)(a1 + 32));
          int v39 = sel_getName(*(SEL *)(a1 + 64));
          *(_DWORD *)long long buf = 67109890;
          int v246 = v37;
          __int16 v247 = 2082;
          __int16 v248 = v38;
          __int16 v249 = 2082;
          __int16 v250 = v39;
          __int16 v251 = 1024;
          int v252 = 416;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Express mode in progress, denying..", buf, 0x22u);
        }

        uint64_t v16 = *(void *)(a1 + 56);
        id v40 = objc_alloc((Class)NSError);
        id v18 = +[NSString stringWithUTF8String:"nfcd"];
        v259[0] = NSLocalizedDescriptionKey;
        __int16 v19 = +[NSString stringWithUTF8String:"Express Mode in progress"];
        v260[0] = v19;
        v260[1] = &off_10031C060;
        v259[1] = @"Line";
        v259[2] = @"Method";
        id v20 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 64))];
        v260[2] = v20;
        v259[3] = NSDebugDescriptionErrorKey;
        id v21 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 64)), 417];
        v260[3] = v21;
        id v22 = +[NSDictionary dictionaryWithObjects:v260 forKeys:v259 count:4];
        uint64_t v23 = v40;
        id v24 = v18;
        uint64_t v25 = 38;
        goto LABEL_15;
      }
    }
    if ([*(id *)(a1 + 40) count] != (id)2)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v62 = NFLogGetLogger();
      if (v62)
      {
        BOOL v63 = (void (*)(uint64_t, const char *, ...))v62;
        uint64_t v64 = object_getClass(*(id *)(a1 + 32));
        BOOL v65 = class_isMetaClass(v64);
        int v66 = object_getClassName(*(id *)(a1 + 32));
        BOOL v67 = sel_getName(*(SEL *)(a1 + 64));
        uint64_t v68 = 45;
        if (v65) {
          uint64_t v68 = 43;
        }
        v63(3, "%c[%{public}s %{public}s]:%i Invalid number of aidsAndKeys %{public}@", v68, v66, v67, 422, *(void *)(a1 + 40));
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v69 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
      {
        id v70 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v70)) {
          int v71 = 43;
        }
        else {
          int v71 = 45;
        }
        uint64_t v72 = object_getClassName(*(id *)(a1 + 32));
        int v73 = sel_getName(*(SEL *)(a1 + 64));
        id v74 = *(void **)(a1 + 40);
        *(_DWORD *)long long buf = 67110146;
        int v246 = v71;
        __int16 v247 = 2082;
        __int16 v248 = v72;
        __int16 v249 = 2082;
        __int16 v250 = v73;
        __int16 v251 = 1024;
        int v252 = 422;
        __int16 v253 = 2114;
        id v254 = v74;
        _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid number of aidsAndKeys %{public}@", buf, 0x2Cu);
      }

      uint64_t v16 = *(void *)(a1 + 56);
      id v75 = objc_alloc((Class)NSError);
      id v18 = +[NSString stringWithUTF8String:"nfcd"];
      v257[0] = NSLocalizedDescriptionKey;
      __int16 v19 = +[NSString stringWithUTF8String:"Invalid Parameter"];
      v258[0] = v19;
      v258[1] = &off_10031C078;
      v257[1] = @"Line";
      v257[2] = @"Method";
      id v20 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 64))];
      v258[2] = v20;
      v257[3] = NSDebugDescriptionErrorKey;
      id v21 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 64)), 423];
      v258[3] = v21;
      id v22 = +[NSDictionary dictionaryWithObjects:v258 forKeys:v257 count:4];
      uint64_t v23 = v75;
      id v24 = v18;
      uint64_t v25 = 10;
      goto LABEL_15;
    }
    int v41 = *(void **)(a1 + 32);
    uint64_t v42 = *(void *)(a1 + 40);
    uint64_t v43 = [v41 expressModeManager];
    uint64_t v44 = (void *)v43;
    if (v43) {
      uint64_t v45 = *(void *)(v43 + 136);
    }
    else {
      uint64_t v45 = 0;
    }
    [v41 setActiveKeys:v42 allowBackgroundTransactions:v45 != -1];
    id v18 = (id)objc_claimAutoreleasedReturnValue();

    if (v18)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v46 = NFLogGetLogger();
      if (v46)
      {
        uint64_t v47 = (void (*)(uint64_t, const char *, ...))v46;
        int v48 = object_getClass(*(id *)(a1 + 32));
        BOOL v49 = class_isMetaClass(v48);
        int v50 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v51 = sel_getName(*(SEL *)(a1 + 64));
        uint64_t v52 = 45;
        if (v49) {
          uint64_t v52 = 43;
        }
        v47(3, "%c[%{public}s %{public}s]:%i Failed to setup active keys %{public}@ - error %{public}@", v52, v50, v51, 431, *(void *)(a1 + 40), v18);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      BOOL v53 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
      {
        int v54 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v54)) {
          int v55 = 43;
        }
        else {
          int v55 = 45;
        }
        id v56 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v57 = sel_getName(*(SEL *)(a1 + 64));
        int v58 = *(void **)(a1 + 40);
        *(_DWORD *)long long buf = 67110402;
        int v246 = v55;
        __int16 v247 = 2082;
        __int16 v248 = v56;
        __int16 v249 = 2082;
        __int16 v250 = v57;
        __int16 v251 = 1024;
        int v252 = 431;
        __int16 v253 = 2114;
        id v254 = v58;
        __int16 v255 = 2114;
        id v256 = v18;
        _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to setup active keys %{public}@ - error %{public}@", buf, 0x36u);
      }

      uint64_t v59 = *(void *)(a1 + 56);
      unsigned __int8 v60 = [*(id *)(a1 + 32) activeApplet];
      int v61 = [*(id *)(a1 + 32) activeKeyIdentifiers];
      (*(void (**)(uint64_t, void *, void *, id))(v59 + 16))(v59, v60, v61, v18);

      [*(id *)(a1 + 32) startDefaultMode];
      goto LABEL_16;
    }
    [*(id *)(a1 + 32) setDeferredActivationApplet:0];
    uint64_t v76 = objc_opt_new();
    uint64_t v77 = [*(id *)(a1 + 40) keyEnumerator];
    uint64_t v78 = [v77 nextObject];
    if (v78)
    {
      int v79 = (void *)v78;
      while (1)
      {
        uint64_t v80 = [*(id *)(a1 + 32) secureElementWrapper];
        CFStringRef v81 = sub_1002473C8(v80, v79);

        if (!v81) {
          break;
        }
        [v76 addObject:v81];

        uint64_t v82 = [v77 nextObject];

        int v79 = (void *)v82;
        if (!v82) {
          goto LABEL_58;
        }
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v117 = NFLogGetLogger();
      if (v117)
      {
        id v118 = (void (*)(uint64_t, const char *, ...))v117;
        uint64_t v119 = object_getClass(*(id *)(a1 + 32));
        BOOL v120 = class_isMetaClass(v119);
        __int16 v216 = object_getClassName(*(id *)(a1 + 32));
        NSErrorUserInfoKey v220 = sel_getName(*(SEL *)(a1 + 64));
        uint64_t v121 = 45;
        if (v120) {
          uint64_t v121 = 43;
        }
        v118(3, "%c[%{public}s %{public}s]:%i No applet for aid %@", v121, v216, v220, 445, v79);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      BOOL v122 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v122, OS_LOG_TYPE_ERROR))
      {
        long long v123 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v123)) {
          int v124 = 43;
        }
        else {
          int v124 = 45;
        }
        long long v125 = object_getClassName(*(id *)(a1 + 32));
        long long v126 = sel_getName(*(SEL *)(a1 + 64));
        *(_DWORD *)long long buf = 67110146;
        int v246 = v124;
        __int16 v247 = 2082;
        __int16 v248 = v125;
        __int16 v249 = 2082;
        __int16 v250 = v126;
        __int16 v251 = 1024;
        int v252 = 445;
        __int16 v253 = 2112;
        id v254 = v79;
        _os_log_impl((void *)&_mh_execute_header, v122, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i No applet for aid %@", buf, 0x2Cu);
      }

      id v127 = objc_alloc((Class)NSError);
      long long v128 = +[NSString stringWithUTF8String:"nfcd"];
      v243[0] = NSLocalizedDescriptionKey;
      long long v129 = +[NSString stringWithUTF8String:"Invalid Parameter"];
      v244[0] = v129;
      v244[1] = &off_10031C090;
      v243[1] = @"Line";
      v243[2] = @"Method";
      id v130 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 64))];
      v244[2] = v130;
      v243[3] = NSDebugDescriptionErrorKey;
      id v131 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 64)), 446];
      v244[3] = v131;
      long long v132 = +[NSDictionary dictionaryWithObjects:v244 forKeys:v243 count:4];
      id v18 = [v127 initWithDomain:v128 code:10 userInfo:v132];

      goto LABEL_95;
    }
LABEL_58:
    int v79 = [v76 objectAtIndex:0];
    uint64_t v83 = [*(id *)(a1 + 32) activeApplet];
    unsigned __int8 v84 = [v79 isEqualToApplet:v83];

    if ((v84 & 1) == 0)
    {
      BOOL v85 = *(unsigned char **)(a1 + 32);
      if (v79)
      {
        if (v85[264])
        {
          uint64_t v86 = [*(id *)(a1 + 32) activeApplet];

          BOOL v85 = *(unsigned char **)(a1 + 32);
          if (v86)
          {
            id v87 = [*(id *)(a1 + 32) activeApplet];
            uint64_t v88 = [v85 seidForApplet:v87];

            id v89 = [*(id *)(a1 + 32) seidForApplet:v79];
            if (([v88 isEqualToString:v89] & 1) == 0)
            {
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v90 = NFLogGetLogger();
              if (v90)
              {
                int v91 = (void (*)(uint64_t, const char *, ...))v90;
                __int16 v92 = object_getClass(*(id *)(a1 + 32));
                BOOL v232 = class_isMetaClass(v92);
                int v229 = object_getClassName(*(id *)(a1 + 32));
                uint64_t v93 = sel_getName(*(SEL *)(a1 + 64));
                __int16 v94 = [*(id *)(a1 + 32) activeApplet];
                uint64_t v95 = 45;
                if (v232) {
                  uint64_t v95 = 43;
                }
                v91(6, "%c[%{public}s %{public}s]:%i deauthorizing previously authed applet on different seid: %{public}@", v95, v229, v93, 462, v94);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              __int16 v96 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
              {
                int v97 = object_getClass(*(id *)(a1 + 32));
                if (class_isMetaClass(v97)) {
                  int v98 = 43;
                }
                else {
                  int v98 = 45;
                }
                int v233 = v98;
                __int16 v230 = object_getClassName(*(id *)(a1 + 32));
                unsigned __int8 v99 = sel_getName(*(SEL *)(a1 + 64));
                int v100 = [*(id *)(a1 + 32) activeApplet];
                *(_DWORD *)long long buf = 67110146;
                int v246 = v233;
                __int16 v247 = 2082;
                __int16 v248 = v230;
                __int16 v249 = 2082;
                __int16 v250 = v99;
                __int16 v251 = 1024;
                int v252 = 462;
                __int16 v253 = 2114;
                id v254 = v100;
                _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i deauthorizing previously authed applet on different seid: %{public}@", buf, 0x2Cu);
              }
              [*(id *)(a1 + 32) _deauthorize];
            }

            BOOL v85 = *(unsigned char **)(a1 + 32);
          }
        }
      }
      if ([v85 _requiresDeferredActivation:v79])
      {
        [*(id *)(a1 + 32) setDeferredActivationApplet:v79];
        id v101 = [*(id *)(a1 + 32) setActiveApplet:0];
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v102 = NFLogGetLogger();
        if (v102)
        {
          NSErrorUserInfoKey v103 = (void (*)(uint64_t, const char *, ...))v102;
          uint64_t v104 = object_getClass(*(id *)(a1 + 32));
          BOOL v234 = class_isMetaClass(v104);
          uint64_t v105 = object_getClassName(*(id *)(a1 + 32));
          int v106 = sel_getName(*(SEL *)(a1 + 64));
          __int16 v107 = [*(id *)(a1 + 32) deferredActivationApplet];
          int v108 = [v107 identifier];
          uint64_t v109 = 45;
          if (v234) {
            uint64_t v109 = 43;
          }
          v103(6, "%c[%{public}s %{public}s]:%i Applet %{public}@ requires deferred activation", v109, v105, v106, 470, v108);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        long long v110 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v111 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v111)) {
            int v112 = 43;
          }
          else {
            int v112 = 45;
          }
          int v235 = v112;
          __int16 v113 = object_getClassName(*(id *)(a1 + 32));
          int v114 = sel_getName(*(SEL *)(a1 + 64));
          __int16 v115 = [*(id *)(a1 + 32) deferredActivationApplet];
          long long v116 = [v115 identifier];
          *(_DWORD *)long long buf = 67110146;
          int v246 = v235;
          __int16 v247 = 2082;
          __int16 v248 = v113;
          __int16 v249 = 2082;
          __int16 v250 = v114;
          __int16 v251 = 1024;
          int v252 = 470;
          __int16 v253 = 2114;
          id v254 = v116;
          _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Applet %{public}@ requires deferred activation", buf, 0x2Cu);
        }
      }
      else
      {
        kdebug_trace();
        uint64_t v136 = NFSharedSignpostLog();
        if (os_signpost_enabled(v136))
        {
          *(_WORD *)long long buf = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v136, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "ACTIVATE_APPLET", (const char *)&unk_100286819, buf, 2u);
        }

        uint64_t v137 = [*(id *)(a1 + 32) setActiveApplets:v76];
        if (v137)
        {
          id v18 = (id)v137;
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v138 = NFLogGetLogger();
          if (v138)
          {
            v139 = (void (*)(uint64_t, const char *, ...))v138;
            id v140 = object_getClass(*(id *)(a1 + 32));
            BOOL v141 = class_isMetaClass(v140);
            id v217 = object_getClassName(*(id *)(a1 + 32));
            uint64_t v221 = sel_getName(*(SEL *)(a1 + 64));
            uint64_t v142 = 45;
            if (v141) {
              uint64_t v142 = 43;
            }
            v139(3, "%c[%{public}s %{public}s]:%i Unable to setActiveApplets : error = %@", v142, v217, v221, 477, v18);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          long long v128 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v128, OS_LOG_TYPE_ERROR))
          {
            id v143 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v143)) {
              int v144 = 43;
            }
            else {
              int v144 = 45;
            }
            uint64_t v145 = object_getClassName(*(id *)(a1 + 32));
            int v146 = sel_getName(*(SEL *)(a1 + 64));
            *(_DWORD *)long long buf = 67110146;
            int v246 = v144;
            __int16 v247 = 2082;
            __int16 v248 = v145;
            __int16 v249 = 2082;
            __int16 v250 = v146;
            __int16 v251 = 1024;
            int v252 = 477;
            __int16 v253 = 2112;
            id v254 = v18;
            _os_log_impl((void *)&_mh_execute_header, v128, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unable to setActiveApplets : error = %@", buf, 0x2Cu);
          }
LABEL_95:

          uint64_t v133 = *(void *)(a1 + 56);
          uint64_t v134 = [*(id *)(a1 + 32) activeApplet];
          int v135 = [*(id *)(a1 + 32) activeKeyIdentifiers];
          (*(void (**)(uint64_t, void *, void *, id))(v133 + 16))(v133, v134, v135, v18);

          [*(id *)(a1 + 32) startDefaultMode];
LABEL_170:

          goto LABEL_16;
        }
      }
    }
    id v147 = [*(id *)(a1 + 32) deferredActivationApplet];

    if (v147)
    {
      uint64_t v148 = *(void *)(a1 + 48);
      if (v148)
      {
        uint64_t v149 = *(void **)(a1 + 32);
        v237[0] = _NSConcreteStackBlock;
        v237[1] = 3221225472;
        v237[2] = sub_100132B24;
        v237[3] = &unk_100304D00;
        id v150 = *(id *)(a1 + 56);
        v237[4] = *(void *)(a1 + 32);
        id v238 = v150;
        [v149 _sync_startDeferredCardEmulationWithAuthorization:v148 completion:v237];

LABEL_169:
        id v18 = 0;
        goto LABEL_170;
      }
      uint64_t v184 = *(void *)(a1 + 56);
      uint64_t v185 = [*(id *)(a1 + 32) deferredActivationApplet];
LABEL_168:
      BOOL v214 = (void *)v185;
      int v215 = [*(id *)(a1 + 32) activeKeyIdentifiers];
      (*(void (**)(uint64_t, void *, void *, void))(v184 + 16))(v184, v214, v215, 0);

      goto LABEL_169;
    }
    [*(id *)(a1 + 32) switchToSecureElementWrapperForApplet:v79];
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v151 = NFLogGetLogger();
    if (v151)
    {
      uint64_t v152 = (void (*)(uint64_t, const char *, ...))v151;
      uint64_t v153 = object_getClass(*(id *)(a1 + 32));
      BOOL v154 = class_isMetaClass(v153);
      NSErrorUserInfoKey v218 = object_getClassName(*(id *)(a1 + 32));
      NSErrorUserInfoKey v222 = sel_getName(*(SEL *)(a1 + 64));
      uint64_t v155 = 45;
      if (v154) {
        uint64_t v155 = 43;
      }
      v152(6, "%c[%{public}s %{public}s]:%i active = %{public}@", v155, v218, v222, 501, v79);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    BOOL v156 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v156, OS_LOG_TYPE_DEFAULT))
    {
      id v157 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v157)) {
        int v158 = 43;
      }
      else {
        int v158 = 45;
      }
      uint64_t v159 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v160 = sel_getName(*(SEL *)(a1 + 64));
      *(_DWORD *)long long buf = 67110146;
      int v246 = v158;
      __int16 v247 = 2082;
      __int16 v248 = v159;
      __int16 v249 = 2082;
      __int16 v250 = v160;
      __int16 v251 = 1024;
      int v252 = 501;
      __int16 v253 = 2114;
      id v254 = v79;
      _os_log_impl((void *)&_mh_execute_header, v156, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i active = %{public}@", buf, 0x2Cu);
    }

    if (*(void *)(a1 + 48))
    {
      kdebug_trace();
      int v161 = NFSharedSignpostLog();
      if (os_signpost_enabled(v161))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v161, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "AUTHORIZE_APPLET", (const char *)&unk_100286819, buf, 2u);
      }

      if (([*(id *)(a1 + 32) _authorize:*(void *)(a1 + 48)] & 1) == 0)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v198 = NFLogGetLogger();
        if (v198)
        {
          id v199 = (void (*)(uint64_t, const char *, ...))v198;
          id v200 = object_getClass(*(id *)(a1 + 32));
          BOOL v201 = class_isMetaClass(v200);
          long long v202 = object_getClassName(*(id *)(a1 + 32));
          int v225 = sel_getName(*(SEL *)(a1 + 64));
          uint64_t v203 = 45;
          if (v201) {
            uint64_t v203 = 43;
          }
          v199(3, "%c[%{public}s %{public}s]:%i Failed to authorize", v203, v202, v225, 508);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v204 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v204, OS_LOG_TYPE_ERROR))
        {
          uint64_t v205 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v205)) {
            int v206 = 43;
          }
          else {
            int v206 = 45;
          }
          uint64_t v207 = object_getClassName(*(id *)(a1 + 32));
          uint64_t v208 = sel_getName(*(SEL *)(a1 + 64));
          *(_DWORD *)long long buf = 67109890;
          int v246 = v206;
          __int16 v247 = 2082;
          __int16 v248 = v207;
          __int16 v249 = 2082;
          __int16 v250 = v208;
          __int16 v251 = 1024;
          int v252 = 508;
          _os_log_impl((void *)&_mh_execute_header, v204, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to authorize", buf, 0x22u);
        }

        uint64_t v175 = *(void *)(a1 + 56);
        uint64_t v176 = [*(id *)(a1 + 32) activeApplet];
        __int16 v236 = [*(id *)(a1 + 32) activeKeyIdentifiers];
        id v228 = objc_alloc((Class)NSError);
        uint64_t v209 = +[NSString stringWithUTF8String:"nfcd"];
        v241[0] = NSLocalizedDescriptionKey;
        int v231 = +[NSString stringWithUTF8String:"Commmand Error"];
        v242[0] = v231;
        v242[1] = &off_10031C0A8;
        v241[1] = @"Line";
        v241[2] = @"Method";
        id v226 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 64))];
        v242[2] = v226;
        v241[3] = NSDebugDescriptionErrorKey;
        id v178 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 64)), 509];
        v242[3] = v178;
        id v179 = +[NSDictionary dictionaryWithObjects:v242 forKeys:v241 count:4];
        uint64_t v180 = v228;
        uint64_t v181 = v209;
        unsigned int v182 = (void *)v209;
        uint64_t v183 = 16;
        goto LABEL_161;
      }
      kdebug_trace();
      uint64_t v162 = NFSharedSignpostLog();
      if (os_signpost_enabled(v162))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v162, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "START_PAYMENT_EMULATION", (const char *)&unk_100286819, buf, 2u);
      }

      if ((objc_msgSend(*(id *)(a1 + 32), "startCardEmulationWithType:", objc_msgSend(*(id *)(a1 + 32), "defaultEmulationType")) & 1) == 0)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v163 = NFLogGetLogger();
        if (v163)
        {
          int v164 = (void (*)(uint64_t, const char *, ...))v163;
          uint64_t v165 = object_getClass(*(id *)(a1 + 32));
          BOOL v166 = class_isMetaClass(v165);
          id v167 = object_getClassName(*(id *)(a1 + 32));
          BOOL v223 = sel_getName(*(SEL *)(a1 + 64));
          uint64_t v168 = 45;
          if (v166) {
            uint64_t v168 = 43;
          }
          v164(3, "%c[%{public}s %{public}s]:%i Failed to start card emulation", v168, v167, v223, 518);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        char v169 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v169, OS_LOG_TYPE_ERROR))
        {
          uint64_t v170 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v170)) {
            int v171 = 43;
          }
          else {
            int v171 = 45;
          }
          uint64_t v172 = object_getClassName(*(id *)(a1 + 32));
          v173 = sel_getName(*(SEL *)(a1 + 64));
          *(_DWORD *)long long buf = 67109890;
          int v246 = v171;
          __int16 v247 = 2082;
          __int16 v248 = v172;
          __int16 v249 = 2082;
          __int16 v250 = v173;
          __int16 v251 = 1024;
          int v252 = 518;
          _os_log_impl((void *)&_mh_execute_header, v169, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to start card emulation", buf, 0x22u);
        }

        uint64_t v174 = *(unsigned char **)(a1 + 32);
        if (v174[264])
        {
          [v174 _deauthorize];
          uint64_t v174 = *(unsigned char **)(a1 + 32);
        }
        uint64_t v175 = *(void *)(a1 + 56);
        uint64_t v176 = [v174 activeApplet];
        __int16 v236 = [*(id *)(a1 + 32) activeKeyIdentifiers];
        id v227 = objc_alloc((Class)NSError);
        uint64_t v177 = +[NSString stringWithUTF8String:"nfcd"];
        v239[0] = NSLocalizedDescriptionKey;
        int v231 = +[NSString stringWithUTF8String:"Stack Error"];
        v240[0] = v231;
        v240[1] = &off_10031C0C0;
        v239[1] = @"Line";
        v239[2] = @"Method";
        id v226 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 64))];
        v240[2] = v226;
        v239[3] = NSDebugDescriptionErrorKey;
        id v178 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 64)), 522];
        v240[3] = v178;
        id v179 = +[NSDictionary dictionaryWithObjects:v240 forKeys:v239 count:4];
        uint64_t v180 = v227;
        uint64_t v181 = v177;
        unsigned int v182 = (void *)v177;
        uint64_t v183 = 15;
LABEL_161:
        id v210 = [v180 initWithDomain:v181 code:v183 userInfo:v179];
        (*(void (**)(uint64_t, void *, void *, id))(v175 + 16))(v175, v176, v236, v210);

        [*(id *)(a1 + 32) startDefaultMode];
        goto LABEL_169;
      }
    }
    else
    {
      int v186 = *(unsigned char **)(a1 + 32);
      if (v186[264])
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v187 = NFLogGetLogger();
        if (v187)
        {
          NSErrorUserInfoKey v188 = (void (*)(uint64_t, const char *, ...))v187;
          uint64_t v189 = object_getClass(*(id *)(a1 + 32));
          BOOL v190 = class_isMetaClass(v189);
          unsigned int v191 = object_getClassName(*(id *)(a1 + 32));
          uint64_t v224 = sel_getName(*(SEL *)(a1 + 64));
          uint64_t v192 = 45;
          if (v190) {
            uint64_t v192 = 43;
          }
          v188(6, "%c[%{public}s %{public}s]:%i Already authorized - staying in wired mode - need to call startCardEmulation or enable express", v192, v191, v224, 528);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        unsigned int v193 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v193, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v194 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v194)) {
            int v195 = 43;
          }
          else {
            int v195 = 45;
          }
          BOOL v196 = object_getClassName(*(id *)(a1 + 32));
          int v197 = sel_getName(*(SEL *)(a1 + 64));
          *(_DWORD *)long long buf = 67109890;
          int v246 = v195;
          __int16 v247 = 2082;
          __int16 v248 = v196;
          __int16 v249 = 2082;
          __int16 v250 = v197;
          __int16 v251 = 1024;
          int v252 = 528;
          _os_log_impl((void *)&_mh_execute_header, v193, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Already authorized - staying in wired mode - need to call startCardEmulation or enable express", buf, 0x22u);
        }
      }
      else
      {
        int v211 = [v186 activeKeyIdentifiers];

        __int16 v212 = *(void **)(a1 + 32);
        if (v211) {
          [v212 startDefaultModeAndKeepSEOn:1];
        }
        else {
          [v212 startDefaultMode];
        }
      }
    }
    kdebug_trace();
    char v213 = NFSharedSignpostLog();
    if (os_signpost_enabled(v213))
    {
      *(_WORD *)long long buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v213, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLIENT_CALLBACK", (const char *)&unk_100286819, buf, 2u);
    }

    uint64_t v184 = *(void *)(a1 + 56);
    uint64_t v185 = [*(id *)(a1 + 32) activeApplet];
    goto LABEL_168;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v2 = NFLogGetLogger();
  if (v2)
  {
    uint64_t v3 = (void (*)(uint64_t, const char *, ...))v2;
    uint64_t v4 = object_getClass(*(id *)(a1 + 32));
    BOOL v5 = class_isMetaClass(v4);
    long long v6 = object_getClassName(*(id *)(a1 + 32));
    id v7 = sel_getName(*(SEL *)(a1 + 64));
    uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v9 = 45;
    if (v5) {
      uint64_t v9 = 43;
    }
    v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, v6, v7, 413, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    int v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    int v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 64));
    uint64_t v15 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v246 = v12;
    __int16 v247 = 2082;
    __int16 v248 = v13;
    __int16 v249 = 2082;
    __int16 v250 = v14;
    __int16 v251 = 1024;
    int v252 = 413;
    __int16 v253 = 2114;
    id v254 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v16 = *(void *)(a1 + 56);
  if (v16)
  {
    id v17 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    v261[0] = NSLocalizedDescriptionKey;
    __int16 v19 = +[NSString stringWithUTF8String:"Session not active"];
    v262[0] = v19;
    v262[1] = &off_10031C048;
    v261[1] = @"Line";
    v261[2] = @"Method";
    id v20 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 64))];
    v262[2] = v20;
    v261[3] = NSDebugDescriptionErrorKey;
    id v21 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 64)), 413];
    v262[3] = v21;
    id v22 = +[NSDictionary dictionaryWithObjects:v262 forKeys:v261 count:4];
    uint64_t v23 = v17;
    id v24 = v18;
    uint64_t v25 = 54;
LABEL_15:
    id v26 = [v23 initWithDomain:v24 code:v25 userInfo:v22];
    (*(void (**)(uint64_t, void, void, id))(v16 + 16))(v16, 0, 0, v26);

LABEL_16:
  }
}

void sub_100132B24(uint64_t a1, void *a2)
{
  uint64_t v4 = *(void **)(a1 + 32);
  uint64_t v3 = *(void *)(a1 + 40);
  id v5 = a2;
  id v7 = [v4 deferredActivationApplet];
  long long v6 = [*(id *)(a1 + 32) activeKeyIdentifiers];
  (*(void (**)(uint64_t, id, void *, id))(v3 + 16))(v3, v7, v6, v5);
}

void sub_100132D60(uint64_t a1)
{
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 554, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      int v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      int v13 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v14 = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v15 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)long long buf = 67110146;
      int v65 = v12;
      __int16 v66 = 2082;
      BOOL v67 = v13;
      __int16 v68 = 2082;
      uint64_t v69 = v14;
      __int16 v70 = 1024;
      int v71 = 554;
      __int16 v72 = 2114;
      int v73 = v15;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v16 = *(void *)(a1 + 48);
    if (v16)
    {
      id v17 = objc_alloc((Class)NSError);
      id v18 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v62 = NSLocalizedDescriptionKey;
      __int16 v19 = +[NSString stringWithUTF8String:"Session not active"];
      BOOL v63 = v19;
      id v20 = +[NSDictionary dictionaryWithObjects:&v63 forKeys:&v62 count:1];
      id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
      (*(void (**)(uint64_t, id))(v16 + 16))(v16, v21);
    }
  }
  else
  {
    id v22 = [*(id *)(a1 + 32) expressModeManager];
    if (v22 && (int v23 = v22[172], v22, v23))
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v24 = NFLogGetLogger();
      if (v24)
      {
        uint64_t v25 = (void (*)(uint64_t, const char *, ...))v24;
        id v26 = object_getClass(*(id *)(a1 + 32));
        BOOL v27 = class_isMetaClass(v26);
        int v28 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v59 = sel_getName(*(SEL *)(a1 + 56));
        uint64_t v29 = 45;
        if (v27) {
          uint64_t v29 = 43;
        }
        v25(4, "%c[%{public}s %{public}s]:%i Express mode in progress, denying..", v29, v28, v59, 557);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v30 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        __int16 v31 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v31)) {
          int v32 = 43;
        }
        else {
          int v32 = 45;
        }
        int v33 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v34 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)long long buf = 67109890;
        int v65 = v32;
        __int16 v66 = 2082;
        BOOL v67 = v33;
        __int16 v68 = 2082;
        uint64_t v69 = v34;
        __int16 v70 = 1024;
        int v71 = 557;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Express mode in progress, denying..", buf, 0x22u);
      }

      uint64_t v35 = *(void *)(a1 + 48);
      id v36 = objc_alloc((Class)NSError);
      int v37 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v60 = NSLocalizedDescriptionKey;
      BOOL v38 = +[NSString stringWithUTF8String:"Express Mode in progress"];
      int v61 = v38;
      int v39 = +[NSDictionary dictionaryWithObjects:&v61 forKeys:&v60 count:1];
      id v40 = [v36 initWithDomain:v37 code:38 userInfo:v39];
      (*(void (**)(uint64_t, id))(v35 + 16))(v35, v40);
    }
    else
    {
      int v41 = [*(id *)(a1 + 32) deferredActivationApplet];

      if (v41)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v42 = NFLogGetLogger();
        if (v42)
        {
          uint64_t v43 = (void (*)(uint64_t, const char *, ...))v42;
          uint64_t v44 = object_getClass(*(id *)(a1 + 32));
          BOOL v45 = class_isMetaClass(v44);
          uint64_t v46 = object_getClassName(*(id *)(a1 + 32));
          uint64_t v47 = sel_getName(*(SEL *)(a1 + 56));
          int v48 = [*(id *)(a1 + 32) deferredActivationApplet];
          uint64_t v49 = 45;
          if (v45) {
            uint64_t v49 = 43;
          }
          v43(6, "%c[%{public}s %{public}s]:%i Applet requires deferred activation: %{public}@", v49, v46, v47, 560, v48);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v50 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v51 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v51)) {
            int v52 = 43;
          }
          else {
            int v52 = 45;
          }
          BOOL v53 = object_getClassName(*(id *)(a1 + 32));
          int v54 = sel_getName(*(SEL *)(a1 + 56));
          int v55 = [*(id *)(a1 + 32) deferredActivationApplet];
          *(_DWORD *)long long buf = 67110146;
          int v65 = v52;
          __int16 v66 = 2082;
          BOOL v67 = v53;
          __int16 v68 = 2082;
          uint64_t v69 = v54;
          __int16 v70 = 1024;
          int v71 = 560;
          __int16 v72 = 2114;
          int v73 = v55;
          _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Applet requires deferred activation: %{public}@", buf, 0x2Cu);
        }
        [*(id *)(a1 + 32) _sync_startDeferredCardEmulationWithAuthorization:*(void *)(a1 + 40) completion:*(void *)(a1 + 48)];
      }
      else
      {
        id v56 = *(void **)(a1 + 32);
        uint64_t v57 = *(void *)(a1 + 40);
        uint64_t v58 = *(void *)(a1 + 48);
        [v56 _performAuthAndStartCardEmulation:v57 fromDeferred:0 completion:v58];
      }
    }
  }
}

void sub_100133D98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,id location)
{
  objc_destroyWeak(v21);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_100133DD4(uint64_t a1)
{
  uint64_t v2 = _os_activity_create((void *)&_mh_execute_header, "com.apple.nfcd.txn.deferredAuthTimer", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  v4.opaque[0] = 0;
  v4.opaque[1] = 0;
  os_activity_scope_enter(v2, &v4);
  os_activity_scope_leave(&v4);

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  [WeakRetained handleDeferredAuthTimeout];
}

void sub_100133F44(uint64_t a1)
{
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 639, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      int v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      int v13 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v14 = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v15 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)long long buf = 67110146;
      int v28 = v12;
      __int16 v29 = 2082;
      __int16 v30 = v13;
      __int16 v31 = 2082;
      int v32 = v14;
      __int16 v33 = 1024;
      int v34 = 639;
      __int16 v35 = 2114;
      id v36 = v15;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v16 = *(void *)(a1 + 48);
    if (v16)
    {
      id v17 = objc_alloc((Class)NSError);
      id v18 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v25 = NSLocalizedDescriptionKey;
      __int16 v19 = +[NSString stringWithUTF8String:"Session not active"];
      id v26 = v19;
      id v20 = +[NSDictionary dictionaryWithObjects:&v26 forKeys:&v25 count:1];
      id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
      (*(void (**)(uint64_t, id))(v16 + 16))(v16, v21);
    }
  }
  else
  {
    id v22 = *(void **)(a1 + 32);
    uint64_t v23 = *(void *)(a1 + 40);
    uint64_t v24 = *(void *)(a1 + 48);
    [v22 _sync_startDeferredCardEmulationWithAuthorization:v23 completion:v24];
  }
}

void sub_100134314(uint64_t a1)
{
  uint64_t v2 = +[_NFHardwareManager sharedHardwareManager];
  uint64_t v3 = [v2 driverWrapper];
  os_activity_scope_state_s v4 = sub_10020EC44(v3);

  unsigned int v5 = [v4 fdOn];
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      __int16 v29 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v34 = 45;
      if (isMetaClass) {
        uint64_t v34 = 43;
      }
      v29(6, "%c[%{public}s %{public}s]:%i %d", v34, ClassName, Name, 657, *(unsigned __int8 *)(a1 + 56));
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v35 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
    {
      id v36 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v36)) {
        int v37 = 43;
      }
      else {
        int v37 = 45;
      }
      BOOL v38 = object_getClassName(*(id *)(a1 + 32));
      int v39 = sel_getName(*(SEL *)(a1 + 48));
      int v40 = *(unsigned __int8 *)(a1 + 56);
      *(_DWORD *)long long buf = 67110146;
      int v162 = v37;
      __int16 v163 = 2082;
      int v164 = v38;
      __int16 v165 = 2082;
      BOOL v166 = v39;
      __int16 v167 = 1024;
      int v168 = 657;
      __int16 v169 = 1024;
      LODWORD(v170) = v40;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %d", buf, 0x28u);
    }

    int v41 = *(unsigned char **)(a1 + 32);
    if (v41[280])
    {
      uint64_t v42 = [v41 activeApplet];

      if (!v42)
      {
        if (!v5)
        {
          int v82 = 0;
LABEL_56:
          uint64_t v83 = [*(id *)(a1 + 32) secureElementWrapper];
          unsigned __int8 v84 = [v83 handle];
          unsigned __int8 v85 = [v84 enableGreenCarThreshold:*(unsigned char *)(a1 + 56) == 0];

          if ((v85 & 1) == 0)
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v86 = NFLogGetLogger();
            if (v86)
            {
              id v87 = (void (*)(uint64_t, const char *, ...))v86;
              uint64_t v88 = object_getClass(*(id *)(a1 + 32));
              BOOL v89 = class_isMetaClass(v88);
              uint64_t v90 = object_getClassName(*(id *)(a1 + 32));
              uint64_t v148 = sel_getName(*(SEL *)(a1 + 48));
              uint64_t v91 = 45;
              if (v89) {
                uint64_t v91 = 43;
              }
              v87(6, "%c[%{public}s %{public}s]:%i Failed to configure GC logic", v91, v90, v148, 687);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            __int16 v92 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v92, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v93 = object_getClass(*(id *)(a1 + 32));
              if (class_isMetaClass(v93)) {
                int v94 = 43;
              }
              else {
                int v94 = 45;
              }
              uint64_t v95 = object_getClassName(*(id *)(a1 + 32));
              __int16 v96 = sel_getName(*(SEL *)(a1 + 48));
              *(_DWORD *)long long buf = 67109890;
              int v162 = v94;
              __int16 v163 = 2082;
              int v164 = v95;
              __int16 v165 = 2082;
              BOOL v166 = v96;
              __int16 v167 = 1024;
              int v168 = 687;
              _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Failed to configure GC logic", buf, 0x22u);
            }
          }
          int v97 = [*(id *)(a1 + 32) activeApplet];

          if (!v97) {
            goto LABEL_78;
          }
          int v98 = [*(id *)(a1 + 32) secureElementWrapper];
          uint64_t v99 = *(unsigned __int8 *)(a1 + 56);
          int v100 = [*(id *)(a1 + 32) activeApplet];
          sub_100251A48(v98, v99, v100);
          id v20 = (void (**)(id, id))objc_claimAutoreleasedReturnValue();

          if (v20)
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v101 = NFLogGetLogger();
            if (v101)
            {
              uint64_t v102 = (void (*)(uint64_t, const char *, ...))v101;
              NSErrorUserInfoKey v103 = object_getClass(*(id *)(a1 + 32));
              BOOL v104 = class_isMetaClass(v103);
              int v144 = object_getClassName(*(id *)(a1 + 32));
              uint64_t v149 = sel_getName(*(SEL *)(a1 + 48));
              uint64_t v105 = 45;
              if (v104) {
                uint64_t v105 = 43;
              }
              v102(6, "%c[%{public}s %{public}s]:%i Failed to configure plasticCardModeForApplet: %{public}@", v105, v144, v149, 693, v20);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            int v106 = NFSharedLogGetLogger();
            if (!os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
            {
LABEL_90:

              if ((v82 & 1) == 0)
              {
LABEL_92:
                (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
                if (!*(unsigned char *)(a1 + 56)) {
                  goto LABEL_16;
                }
                +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:&off_1003230C8];
                id v125 = [*(id *)(a1 + 32) plasticCardMode];
                id v22 = [*(id *)(a1 + 32) activeApplet];
                uint64_t v23 = [v22 identifier];
                +[NFGeneralStatisticsCALogger postPlasticCardEnableStatus:v125 aid:v23];
                goto LABEL_15;
              }
LABEL_91:
              id v124 = [v2 setRoutingConfig:v4];
              goto LABEL_92;
            }
            __int16 v107 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v107)) {
              int v108 = 43;
            }
            else {
              int v108 = 45;
            }
            uint64_t v109 = object_getClassName(*(id *)(a1 + 32));
            long long v110 = sel_getName(*(SEL *)(a1 + 48));
            *(_DWORD *)long long buf = 67110146;
            int v162 = v108;
            __int16 v163 = 2082;
            int v164 = v109;
            __int16 v165 = 2082;
            BOOL v166 = v110;
            __int16 v167 = 1024;
            int v168 = 693;
            __int16 v169 = 2114;
            uint64_t v170 = v20;
          }
          else
          {
LABEL_78:
            uint64_t v111 = [*(id *)(a1 + 32) deferredActivationApplet];

            if (!v111) {
              goto LABEL_94;
            }
            int v112 = [*(id *)(a1 + 32) secureElementWrapper];
            uint64_t v113 = *(unsigned __int8 *)(a1 + 56);
            int v114 = [*(id *)(a1 + 32) deferredActivationApplet];
            sub_100251A48(v112, v113, v114);
            id v20 = (void (**)(id, id))objc_claimAutoreleasedReturnValue();

            if (!v20)
            {
LABEL_94:
              [*(id *)(a1 + 32) setPlasticCardMode:*(unsigned __int8 *)(a1 + 56)];
              long long v126 = *(unsigned char **)(a1 + 32);
              if (v126[264])
              {
                if ([v126 startCardEmulationWithType:2])
                {
                  id v20 = 0;
                  goto LABEL_92;
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v127 = NFLogGetLogger();
                if (v127)
                {
                  long long v128 = (void (*)(uint64_t, const char *, ...))v127;
                  long long v129 = object_getClass(*(id *)(a1 + 32));
                  BOOL v130 = class_isMetaClass(v129);
                  id v131 = object_getClassName(*(id *)(a1 + 32));
                  uint64_t v151 = sel_getName(*(SEL *)(a1 + 48));
                  uint64_t v132 = 45;
                  if (v130) {
                    uint64_t v132 = 43;
                  }
                  v128(3, "%c[%{public}s %{public}s]:%i Failed to restore emulation after enabling plastic card mode", v132, v131, v151, 711);
                }
                char v152 = v82;
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v133 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v133, OS_LOG_TYPE_ERROR))
                {
                  uint64_t v134 = object_getClass(*(id *)(a1 + 32));
                  if (class_isMetaClass(v134)) {
                    int v135 = 43;
                  }
                  else {
                    int v135 = 45;
                  }
                  uint64_t v136 = object_getClassName(*(id *)(a1 + 32));
                  uint64_t v137 = sel_getName(*(SEL *)(a1 + 48));
                  *(_DWORD *)long long buf = 67109890;
                  int v162 = v135;
                  __int16 v163 = 2082;
                  int v164 = v136;
                  __int16 v165 = 2082;
                  BOOL v166 = v137;
                  __int16 v167 = 1024;
                  int v168 = 711;
                  _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to restore emulation after enabling plastic card mode", buf, 0x22u);
                }

                id v138 = objc_alloc((Class)NSError);
                v139 = +[NSString stringWithUTF8String:"nfcd"];
                v153[0] = NSLocalizedDescriptionKey;
                id v140 = +[NSString stringWithUTF8String:"Stack Error"];
                v154[0] = v140;
                v154[1] = &off_10031C120;
                v153[1] = @"Line";
                v153[2] = @"Method";
                id v141 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
                v154[2] = v141;
                v153[3] = NSDebugDescriptionErrorKey;
                id v142 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 712];
                v154[3] = v142;
                id v143 = +[NSDictionary dictionaryWithObjects:v154 forKeys:v153 count:4];
                id v20 = (void (**)(id, id))[v138 initWithDomain:v139 code:15 userInfo:v143];

                if ((v152 & 1) == 0) {
                  goto LABEL_92;
                }
              }
              else
              {
                id v20 = 0;
                if (!v82) {
                  goto LABEL_92;
                }
              }
              goto LABEL_91;
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v115 = NFLogGetLogger();
            if (v115)
            {
              long long v116 = (void (*)(uint64_t, const char *, ...))v115;
              uint64_t v117 = object_getClass(*(id *)(a1 + 32));
              BOOL v118 = class_isMetaClass(v117);
              uint64_t v145 = object_getClassName(*(id *)(a1 + 32));
              id v150 = sel_getName(*(SEL *)(a1 + 48));
              uint64_t v119 = 45;
              if (v118) {
                uint64_t v119 = 43;
              }
              v116(6, "%c[%{public}s %{public}s]:%i Failed to configure plasticCardModeForApplet: %{public}@", v119, v145, v150, 701, v20);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            int v106 = NFSharedLogGetLogger();
            if (!os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_90;
            }
            BOOL v120 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v120)) {
              int v121 = 43;
            }
            else {
              int v121 = 45;
            }
            BOOL v122 = object_getClassName(*(id *)(a1 + 32));
            long long v123 = sel_getName(*(SEL *)(a1 + 48));
            *(_DWORD *)long long buf = 67110146;
            int v162 = v121;
            __int16 v163 = 2082;
            int v164 = v122;
            __int16 v165 = 2082;
            BOOL v166 = v123;
            __int16 v167 = 1024;
            int v168 = 701;
            __int16 v169 = 2114;
            uint64_t v170 = v20;
          }
          _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Failed to configure plasticCardModeForApplet: %{public}@", buf, 0x2Cu);
          goto LABEL_90;
        }
        goto LABEL_43;
      }
      int v41 = *(unsigned char **)(a1 + 32);
    }
    if (([v41 startWiredMode] & 1) == 0)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v46 = NFLogGetLogger();
      if (v46)
      {
        uint64_t v47 = (void (*)(uint64_t, const char *, ...))v46;
        int v48 = object_getClass(*(id *)(a1 + 32));
        BOOL v49 = class_isMetaClass(v48);
        int v50 = object_getClassName(*(id *)(a1 + 32));
        int v146 = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v51 = 45;
        if (v49) {
          uint64_t v51 = 43;
        }
        v47(3, "%c[%{public}s %{public}s]:%i Failed to set wired mode", v51, v50, v146, 665);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v52 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
      {
        BOOL v53 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v53)) {
          int v54 = 43;
        }
        else {
          int v54 = 45;
        }
        int v55 = object_getClassName(*(id *)(a1 + 32));
        id v56 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)long long buf = 67109890;
        int v162 = v54;
        __int16 v163 = 2082;
        int v164 = v55;
        __int16 v165 = 2082;
        BOOL v166 = v56;
        __int16 v167 = 1024;
        int v168 = 665;
        _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set wired mode", buf, 0x22u);
      }

      id v57 = objc_alloc((Class)NSError);
      uint64_t v58 = +[NSString stringWithUTF8String:"nfcd"];
      v157[0] = NSLocalizedDescriptionKey;
      uint64_t v59 = +[NSString stringWithUTF8String:"Stack Error"];
      v158[0] = v59;
      v158[1] = &off_10031C0F0;
      v157[1] = @"Line";
      v157[2] = @"Method";
      id v60 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
      v158[2] = v60;
      v157[3] = NSDebugDescriptionErrorKey;
      id v61 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 666];
      v158[3] = v61;
      NSErrorUserInfoKey v62 = +[NSDictionary dictionaryWithObjects:v158 forKeys:v157 count:4];
      id v20 = (void (**)(id, id))[v57 initWithDomain:v58 code:15 userInfo:v62];

      goto LABEL_92;
    }
    uint64_t v43 = [v2 driverWrapper];
    uint64_t v44 = sub_10020EC44(v43);
    unsigned __int8 v45 = [v44 fdOn];

    if ((v45 & 1) == 0)
    {
LABEL_54:
      int v82 = 1;
      goto LABEL_56;
    }
LABEL_43:
    BOOL v63 = [v4 cloneWithFieldDetect:0];
    uint64_t v64 = [v2 setRoutingConfig:v63];

    if (v64)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v65 = NFLogGetLogger();
      if (v65)
      {
        __int16 v66 = (void (*)(uint64_t, const char *, ...))v65;
        BOOL v67 = object_getClass(*(id *)(a1 + 32));
        BOOL v68 = class_isMetaClass(v67);
        uint64_t v69 = object_getClassName(*(id *)(a1 + 32));
        id v147 = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v70 = 45;
        if (v68) {
          uint64_t v70 = 43;
        }
        v66(6, "%c[%{public}s %{public}s]:%i Failed to disable FD.", v70, v69, v147, 679);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v71 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v72 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v72)) {
          int v73 = 43;
        }
        else {
          int v73 = 45;
        }
        id v74 = object_getClassName(*(id *)(a1 + 32));
        id v75 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)long long buf = 67109890;
        int v162 = v73;
        __int16 v163 = 2082;
        int v164 = v74;
        __int16 v165 = 2082;
        BOOL v166 = v75;
        __int16 v167 = 1024;
        int v168 = 679;
        _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Failed to disable FD.", buf, 0x22u);
      }

      id v76 = objc_alloc((Class)NSError);
      uint64_t v77 = +[NSString stringWithUTF8String:"nfcd"];
      v155[0] = NSLocalizedDescriptionKey;
      uint64_t v78 = +[NSString stringWithUTF8String:"Stack Error"];
      v156[0] = v78;
      v156[1] = &off_10031C108;
      v155[1] = @"Line";
      v155[2] = @"Method";
      id v79 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
      v156[2] = v79;
      v155[3] = NSDebugDescriptionErrorKey;
      id v80 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 680];
      v156[3] = v80;
      CFStringRef v81 = +[NSDictionary dictionaryWithObjects:v156 forKeys:v155 count:4];
      id v20 = (void (**)(id, id))[v76 initWithDomain:v77 code:15 userInfo:v81];

      goto LABEL_91;
    }
    goto LABEL_54;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v6 = NFLogGetLogger();
  if (v6)
  {
    id v7 = (void (*)(uint64_t, const char *, ...))v6;
    uint64_t v8 = object_getClass(*(id *)(a1 + 32));
    BOOL v9 = class_isMetaClass(v8);
    uint64_t v10 = object_getClassName(*(id *)(a1 + 32));
    int v11 = sel_getName(*(SEL *)(a1 + 48));
    int v12 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v13 = 45;
    if (v9) {
      uint64_t v13 = 43;
    }
    v7(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v13, v10, v11, 655, v12);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v14 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    uint64_t v15 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v15)) {
      int v16 = 43;
    }
    else {
      int v16 = 45;
    }
    id v17 = object_getClassName(*(id *)(a1 + 32));
    id v18 = sel_getName(*(SEL *)(a1 + 48));
    __int16 v19 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v162 = v16;
    __int16 v163 = 2082;
    int v164 = v17;
    __int16 v165 = 2082;
    BOOL v166 = v18;
    __int16 v167 = 1024;
    int v168 = 655;
    __int16 v169 = 2114;
    uint64_t v170 = v19;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  id v20 = *(void (***)(id, id))(a1 + 40);
  if (v20)
  {
    id v21 = objc_alloc((Class)NSError);
    id v22 = +[NSString stringWithUTF8String:"nfcd"];
    v159[0] = NSLocalizedDescriptionKey;
    uint64_t v23 = +[NSString stringWithUTF8String:"Session not active"];
    v160[0] = v23;
    v160[1] = &off_10031C0D8;
    v159[1] = @"Line";
    v159[2] = @"Method";
    id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
    v160[2] = v24;
    v159[3] = NSDebugDescriptionErrorKey;
    id v25 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 655];
    v160[3] = v25;
    id v26 = +[NSDictionary dictionaryWithObjects:v160 forKeys:v159 count:4];
    id v27 = [v21 initWithDomain:v22 code:54 userInfo:v26];
    v20[2](v20, v27);

    id v20 = 0;
LABEL_15:
  }
LABEL_16:
}

void sub_10013552C(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 734, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    uint64_t v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v15 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)long long buf = 67110146;
    int v66 = v12;
    __int16 v67 = 2082;
    BOOL v68 = v13;
    __int16 v69 = 2082;
    uint64_t v70 = v14;
    __int16 v71 = 1024;
    int v72 = 734;
    __int16 v73 = 2114;
    id v74 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v16 = NFLogGetLogger();
    if (v16)
    {
      id v17 = (void (*)(uint64_t, const char *, ...))v16;
      id v18 = object_getClass(*(id *)(a1 + 32));
      BOOL v19 = class_isMetaClass(v18);
      id v20 = object_getClassName(*(id *)(a1 + 32));
      id v21 = sel_getName(*(SEL *)(a1 + 48));
      id v22 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v23 = 45;
      if (v19) {
        uint64_t v23 = 43;
      }
      v17(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v23, v20, v21, 736, v22);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v24 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      id v25 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v25)) {
        int v26 = 43;
      }
      else {
        int v26 = 45;
      }
      id v27 = object_getClassName(*(id *)(a1 + 32));
      int v28 = sel_getName(*(SEL *)(a1 + 48));
      __int16 v29 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)long long buf = 67110146;
      int v66 = v26;
      __int16 v67 = 2082;
      BOOL v68 = v27;
      __int16 v69 = 2082;
      uint64_t v70 = v28;
      __int16 v71 = 1024;
      int v72 = 736;
      __int16 v73 = 2114;
      id v74 = v29;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v30 = *(void *)(a1 + 40);
    if (v30)
    {
      id v31 = objc_alloc((Class)NSError);
      int v32 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v63 = NSLocalizedDescriptionKey;
      __int16 v33 = +[NSString stringWithUTF8String:"Session not active"];
      uint64_t v64 = v33;
      uint64_t v34 = +[NSDictionary dictionaryWithObjects:&v64 forKeys:&v63 count:1];
      id v35 = [v31 initWithDomain:v32 code:54 userInfo:v34];
      (*(void (**)(uint64_t, id))(v30 + 16))(v30, v35);
LABEL_24:
    }
  }
  else
  {
    id v36 = [*(id *)(a1 + 32) activeApplet];

    if (!v36)
    {
      int v54 = [*(id *)(a1 + 32) expressModeManager];
      sub_100040348((uint64_t)v54);

      unsigned __int8 v55 = [*(id *)(a1 + 32) startCardEmulationWithType:8];
      uint64_t v56 = *(void *)(a1 + 40);
      if (v55)
      {
        (*(void (**)(uint64_t, void))(v56 + 16))(v56, 0);
        return;
      }
      id v57 = objc_alloc((Class)NSError);
      int v32 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v59 = NSLocalizedDescriptionKey;
      __int16 v33 = +[NSString stringWithUTF8String:"Unknown Error"];
      id v60 = v33;
      uint64_t v34 = +[NSDictionary dictionaryWithObjects:&v60 forKeys:&v59 count:1];
      id v35 = [v57 initWithDomain:v32 code:6 userInfo:v34];
      (*(void (**)(uint64_t, id))(v56 + 16))(v56, v35);
      goto LABEL_24;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v37 = NFLogGetLogger();
    if (v37)
    {
      BOOL v38 = (void (*)(uint64_t, const char *, ...))v37;
      int v39 = object_getClass(*(id *)(a1 + 32));
      BOOL v40 = class_isMetaClass(v39);
      int v41 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v58 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v42 = 45;
      if (v40) {
        uint64_t v42 = 43;
      }
      v38(3, "%c[%{public}s %{public}s]:%i Can not start express mode when an applet is selected", v42, v41, v58, 739);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v43 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      uint64_t v44 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v44)) {
        int v45 = 43;
      }
      else {
        int v45 = 45;
      }
      uint64_t v46 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v47 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)long long buf = 67109890;
      int v66 = v45;
      __int16 v67 = 2082;
      BOOL v68 = v46;
      __int16 v69 = 2082;
      uint64_t v70 = v47;
      __int16 v71 = 1024;
      int v72 = 739;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Can not start express mode when an applet is selected", buf, 0x22u);
    }

    uint64_t v48 = *(void *)(a1 + 40);
    id v49 = objc_alloc((Class)NSError);
    int v50 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v61 = NSLocalizedDescriptionKey;
    uint64_t v51 = +[NSString stringWithUTF8String:"Invalid State"];
    NSErrorUserInfoKey v62 = v51;
    int v52 = +[NSDictionary dictionaryWithObjects:&v62 forKeys:&v61 count:1];
    id v53 = [v49 initWithDomain:v50 code:12 userInfo:v52];
    (*(void (**)(uint64_t, id))(v48 + 16))(v48, v53);
  }
}

void sub_100135CBC(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 756, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    uint64_t v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v15 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)long long buf = 67110146;
    int v66 = v12;
    __int16 v67 = 2082;
    BOOL v68 = v13;
    __int16 v69 = 2082;
    uint64_t v70 = v14;
    __int16 v71 = 1024;
    int v72 = 756;
    __int16 v73 = 2114;
    id v74 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v16 = NFLogGetLogger();
    if (v16)
    {
      id v17 = (void (*)(uint64_t, const char *, ...))v16;
      id v18 = object_getClass(*(id *)(a1 + 32));
      BOOL v19 = class_isMetaClass(v18);
      id v20 = object_getClassName(*(id *)(a1 + 32));
      id v21 = sel_getName(*(SEL *)(a1 + 48));
      id v22 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v23 = 45;
      if (v19) {
        uint64_t v23 = 43;
      }
      v17(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v23, v20, v21, 758, v22);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v24 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      id v25 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v25)) {
        int v26 = 43;
      }
      else {
        int v26 = 45;
      }
      id v27 = object_getClassName(*(id *)(a1 + 32));
      int v28 = sel_getName(*(SEL *)(a1 + 48));
      __int16 v29 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)long long buf = 67110146;
      int v66 = v26;
      __int16 v67 = 2082;
      BOOL v68 = v27;
      __int16 v69 = 2082;
      uint64_t v70 = v28;
      __int16 v71 = 1024;
      int v72 = 758;
      __int16 v73 = 2114;
      id v74 = v29;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v30 = *(void *)(a1 + 40);
    if (v30)
    {
      id v31 = objc_alloc((Class)NSError);
      int v32 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v63 = NSLocalizedDescriptionKey;
      __int16 v33 = +[NSString stringWithUTF8String:"Session not active"];
      uint64_t v64 = v33;
      uint64_t v34 = +[NSDictionary dictionaryWithObjects:&v64 forKeys:&v63 count:1];
      id v35 = [v31 initWithDomain:v32 code:54 userInfo:v34];
      (*(void (**)(uint64_t, id))(v30 + 16))(v30, v35);
LABEL_24:
    }
  }
  else
  {
    id v36 = [*(id *)(a1 + 32) expressModeManager];
    if (!v36 || (int v37 = v36[172], v36, !v37))
    {
      unsigned __int8 v55 = [*(id *)(a1 + 32) startCardEmulationWithType:4];
      uint64_t v56 = *(void *)(a1 + 40);
      if (v55)
      {
        (*(void (**)(uint64_t, void))(v56 + 16))(v56, 0);
        return;
      }
      id v57 = objc_alloc((Class)NSError);
      int v32 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v59 = NSLocalizedDescriptionKey;
      __int16 v33 = +[NSString stringWithUTF8String:"Unknown Error"];
      id v60 = v33;
      uint64_t v34 = +[NSDictionary dictionaryWithObjects:&v60 forKeys:&v59 count:1];
      id v35 = [v57 initWithDomain:v32 code:6 userInfo:v34];
      (*(void (**)(uint64_t, id))(v56 + 16))(v56, v35);
      goto LABEL_24;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v38 = NFLogGetLogger();
    if (v38)
    {
      int v39 = (void (*)(uint64_t, const char *, ...))v38;
      BOOL v40 = object_getClass(*(id *)(a1 + 32));
      BOOL v41 = class_isMetaClass(v40);
      uint64_t v42 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v58 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v43 = 45;
      if (v41) {
        uint64_t v43 = 43;
      }
      v39(4, "%c[%{public}s %{public}s]:%i Express mode in progress, denying..", v43, v42, v58, 761);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v44 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_ERROR))
    {
      int v45 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v45)) {
        int v46 = 43;
      }
      else {
        int v46 = 45;
      }
      uint64_t v47 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v48 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)long long buf = 67109890;
      int v66 = v46;
      __int16 v67 = 2082;
      BOOL v68 = v47;
      __int16 v69 = 2082;
      uint64_t v70 = v48;
      __int16 v71 = 1024;
      int v72 = 761;
      _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Express mode in progress, denying..", buf, 0x22u);
    }

    uint64_t v49 = *(void *)(a1 + 40);
    id v50 = objc_alloc((Class)NSError);
    uint64_t v51 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v61 = NSLocalizedDescriptionKey;
    int v52 = +[NSString stringWithUTF8String:"Express Mode in progress"];
    NSErrorUserInfoKey v62 = v52;
    id v53 = +[NSDictionary dictionaryWithObjects:&v62 forKeys:&v61 count:1];
    id v54 = [v50 initWithDomain:v51 code:38 userInfo:v53];
    (*(void (**)(uint64_t, id))(v49 + 16))(v49, v54);
  }
}

void sub_100136438(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 777, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    uint64_t v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v15 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)long long buf = 67110146;
    int v54 = v12;
    __int16 v55 = 2082;
    uint64_t v56 = v13;
    __int16 v57 = 2082;
    uint64_t v58 = v14;
    __int16 v59 = 1024;
    int v60 = 777;
    __int16 v61 = 2114;
    NSErrorUserInfoKey v62 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v16 = NFLogGetLogger();
    if (v16)
    {
      id v17 = (void (*)(uint64_t, const char *, ...))v16;
      id v18 = object_getClass(*(id *)(a1 + 32));
      BOOL v19 = class_isMetaClass(v18);
      id v20 = object_getClassName(*(id *)(a1 + 32));
      id v21 = sel_getName(*(SEL *)(a1 + 48));
      id v22 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v23 = 45;
      if (v19) {
        uint64_t v23 = 43;
      }
      v17(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v23, v20, v21, 779, v22);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v24 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      id v25 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v25)) {
        int v26 = 43;
      }
      else {
        int v26 = 45;
      }
      id v27 = object_getClassName(*(id *)(a1 + 32));
      int v28 = sel_getName(*(SEL *)(a1 + 48));
      __int16 v29 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)long long buf = 67110146;
      int v54 = v26;
      __int16 v55 = 2082;
      uint64_t v56 = v27;
      __int16 v57 = 2082;
      uint64_t v58 = v28;
      __int16 v59 = 1024;
      int v60 = 779;
      __int16 v61 = 2114;
      NSErrorUserInfoKey v62 = v29;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v30 = *(void *)(a1 + 40);
    if (v30)
    {
      id v31 = objc_alloc((Class)NSError);
      int v32 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v51 = NSLocalizedDescriptionKey;
      __int16 v33 = +[NSString stringWithUTF8String:"Session not active"];
      int v52 = v33;
      uint64_t v34 = +[NSDictionary dictionaryWithObjects:&v52 forKeys:&v51 count:1];
      id v35 = [v31 initWithDomain:v32 code:54 userInfo:v34];
      (*(void (**)(uint64_t, id))(v30 + 16))(v30, v35);
    }
  }
  else
  {
    *(unsigned char *)(*(void *)(a1 + 32) + 320) = 0;
    [*(id *)(*(void *)(a1 + 32) + 304) stopTimer];
    if ([*(id *)(a1 + 32) plasticCardMode])
    {
      id v36 = [*(id *)(a1 + 32) secureElementWrapper];
      int v37 = [v36 handle];
      unsigned __int8 v38 = [v37 enableGreenCarThreshold:1];

      if ((v38 & 1) == 0)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v39 = NFLogGetLogger();
        if (v39)
        {
          BOOL v40 = (void (*)(uint64_t, const char *, ...))v39;
          BOOL v41 = object_getClass(*(id *)(a1 + 32));
          BOOL v42 = class_isMetaClass(v41);
          uint64_t v43 = object_getClassName(*(id *)(a1 + 32));
          id v50 = sel_getName(*(SEL *)(a1 + 48));
          uint64_t v44 = 45;
          if (v42) {
            uint64_t v44 = 43;
          }
          v40(6, "%c[%{public}s %{public}s]:%i Failed to re-enable GC logic", v44, v43, v50, 786);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v45 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
        {
          int v46 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v46)) {
            int v47 = 43;
          }
          else {
            int v47 = 45;
          }
          uint64_t v48 = object_getClassName(*(id *)(a1 + 32));
          uint64_t v49 = sel_getName(*(SEL *)(a1 + 48));
          *(_DWORD *)long long buf = 67109890;
          int v54 = v47;
          __int16 v55 = 2082;
          uint64_t v56 = v48;
          __int16 v57 = 2082;
          uint64_t v58 = v49;
          __int16 v59 = 1024;
          int v60 = 786;
          _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Failed to re-enable GC logic", buf, 0x22u);
        }
      }
    }
    [*(id *)(a1 + 32) startDefaultMode];
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

void sub_100136B0C(uint64_t a1)
{
  kdebug_trace();
  uint64_t v2 = NFSharedSignpostLog();
  if (os_signpost_enabled(v2))
  {
    uint64_t v3 = [*(id *)(a1 + 32) expressModeManager];
    os_activity_scope_state_s v4 = (void *)v3;
    if (v3) {
      BOOL v5 = *(unsigned char *)(v3 + 172) != 0;
    }
    else {
      BOOL v5 = 0;
    }
    *(_DWORD *)long long buf = 67109120;
    int v76 = v5;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v2, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLIENT_FELICA_APPLET_STATE", "InSessionExpress=%d", buf, 8u);
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    [*(id *)(a1 + 32) switchToSecureElementWrapperForApplet:*(void *)(a1 + 40)];
    if ([*(id *)(a1 + 32) startWiredMode])
    {
      __int16 v29 = [*(id *)(a1 + 32) secureElementWrapper];
      uint64_t v30 = [*(id *)(a1 + 40) identifier];
      uint64_t v23 = sub_1002473C8(v29, v30);

      id v31 = [*(id *)(a1 + 32) secureElementWrapper];
      LODWORD(v30) = sub_100253528(v31, v23);

      int v32 = [*(id *)(a1 + 32) secureElementWrapper];
      __int16 v33 = v32;
      if (v30)
      {
        id v22 = sub_10006FAC4(v32, v23);

        kdebug_trace();
        uint64_t v34 = NFSharedSignpostLog();
        if (os_signpost_enabled(v34))
        {
          *(_WORD *)long long buf = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v34, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLIENT_CALLBACK", (const char *)&unk_100286819, buf, 2u);
        }

        uint64_t v35 = *(void *)(a1 + 48);
        if (v22)
        {
          (*(void (**)(void, void *, void))(v35 + 16))(*(void *)(a1 + 48), v22, 0);
        }
        else
        {
          id v61 = objc_alloc((Class)NSError);
          NSErrorUserInfoKey v62 = +[NSString stringWithUTF8String:"nfcd"];
          NSErrorUserInfoKey v69 = NSLocalizedDescriptionKey;
          NSErrorUserInfoKey v63 = +[NSString stringWithUTF8String:"Unexpected Result"];
          uint64_t v70 = v63;
          uint64_t v64 = +[NSDictionary dictionaryWithObjects:&v70 forKeys:&v69 count:1];
          id v65 = [v61 initWithDomain:v62 code:13 userInfo:v64];
          (*(void (**)(uint64_t, void, id))(v35 + 16))(v35, 0, v65);
        }
        [*(id *)(a1 + 32) startDefaultMode];
      }
      else
      {
        id v68 = 0;
        id v22 = sub_10024F870(v32, v23, &v68);
        id v48 = v68;

        (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
        uint64_t v49 = *(double **)(a1 + 32);
        if (v49[34] <= 0.0)
        {
          [v49 startDefaultMode];
        }
        else
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t Logger = NFLogGetLogger();
          if (Logger)
          {
            NSErrorUserInfoKey v51 = (void (*)(uint64_t, const char *, ...))Logger;
            Class = object_getClass(*(id *)(a1 + 32));
            BOOL isMetaClass = class_isMetaClass(Class);
            ClassName = object_getClassName(*(id *)(a1 + 32));
            Name = sel_getName(*(SEL *)(a1 + 56));
            uint64_t v55 = 45;
            if (isMetaClass) {
              uint64_t v55 = 43;
            }
            v51(6, "%c[%{public}s %{public}s]:%i Delaying restart of default mode", v55, ClassName, Name, 844);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v56 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
          {
            __int16 v57 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v57)) {
              int v58 = 43;
            }
            else {
              int v58 = 45;
            }
            __int16 v59 = object_getClassName(*(id *)(a1 + 32));
            int v60 = sel_getName(*(SEL *)(a1 + 56));
            *(_DWORD *)long long buf = 67109890;
            int v76 = v58;
            __int16 v77 = 2082;
            uint64_t v78 = v59;
            __int16 v79 = 2082;
            id v80 = v60;
            __int16 v81 = 1024;
            int v82 = 844;
            _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Delaying restart of default mode", buf, 0x22u);
          }

          [*(id *)(a1 + 32) pauseExpressAndStartDefaultModeAfter:*(double *)(*(void *)(a1 + 32) + 272)];
        }
      }
      goto LABEL_20;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v36 = NFLogGetLogger();
    if (v36)
    {
      int v37 = (void (*)(uint64_t, const char *, ...))v36;
      unsigned __int8 v38 = object_getClass(*(id *)(a1 + 32));
      BOOL v39 = class_isMetaClass(v38);
      BOOL v40 = object_getClassName(*(id *)(a1 + 32));
      int v66 = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v41 = 45;
      if (v39) {
        uint64_t v41 = 43;
      }
      v37(3, "%c[%{public}s %{public}s]:%i Failed to set mode to wired", v41, v40, v66, 810);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    BOOL v42 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
    {
      uint64_t v43 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v43)) {
        int v44 = 43;
      }
      else {
        int v44 = 45;
      }
      int v45 = object_getClassName(*(id *)(a1 + 32));
      int v46 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)long long buf = 67109890;
      int v76 = v44;
      __int16 v77 = 2082;
      uint64_t v78 = v45;
      __int16 v79 = 2082;
      id v80 = v46;
      __int16 v81 = 1024;
      int v82 = 810;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set mode to wired", buf, 0x22u);
    }

    uint64_t v20 = *(void *)(a1 + 48);
    id v47 = objc_alloc((Class)NSError);
    id v22 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v71 = NSLocalizedDescriptionKey;
    uint64_t v23 = +[NSString stringWithUTF8String:"Unexpected Result"];
    int v72 = v23;
    id v24 = +[NSDictionary dictionaryWithObjects:&v72 forKeys:&v71 count:1];
    id v25 = v47;
    int v26 = v22;
    uint64_t v27 = 13;
LABEL_19:
    id v28 = [v25 initWithDomain:v26 code:v27 userInfo:v24];
    (*(void (**)(uint64_t, void, id))(v20 + 16))(v20, 0, v28);

LABEL_20:
    return;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v6 = NFLogGetLogger();
  if (v6)
  {
    id v7 = (void (*)(uint64_t, const char *, ...))v6;
    uint64_t v8 = object_getClass(*(id *)(a1 + 32));
    BOOL v9 = class_isMetaClass(v8);
    uint64_t v10 = object_getClassName(*(id *)(a1 + 32));
    int v11 = sel_getName(*(SEL *)(a1 + 56));
    int v12 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v13 = 45;
    if (v9) {
      uint64_t v13 = 43;
    }
    v7(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v13, v10, v11, 803, v12);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v14 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    uint64_t v15 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v15)) {
      int v16 = 43;
    }
    else {
      int v16 = 45;
    }
    id v17 = object_getClassName(*(id *)(a1 + 32));
    id v18 = sel_getName(*(SEL *)(a1 + 56));
    BOOL v19 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v76 = v16;
    __int16 v77 = 2082;
    uint64_t v78 = v17;
    __int16 v79 = 2082;
    id v80 = v18;
    __int16 v81 = 1024;
    int v82 = 803;
    __int16 v83 = 2114;
    unsigned __int8 v84 = v19;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v20 = *(void *)(a1 + 48);
  if (v20)
  {
    id v21 = objc_alloc((Class)NSError);
    id v22 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v73 = NSLocalizedDescriptionKey;
    uint64_t v23 = +[NSString stringWithUTF8String:"Session not active"];
    id v74 = v23;
    id v24 = +[NSDictionary dictionaryWithObjects:&v74 forKeys:&v73 count:1];
    id v25 = v21;
    int v26 = v22;
    uint64_t v27 = 54;
    goto LABEL_19;
  }
}

void sub_1001374D8(uint64_t a1)
{
  kdebug_trace();
  uint64_t v2 = NFSharedSignpostLog();
  if (os_signpost_enabled(v2))
  {
    uint64_t v3 = [*(id *)(a1 + 32) expressModeManager];
    os_activity_scope_state_s v4 = (void *)v3;
    if (v3) {
      int v5 = *(unsigned __int8 *)(v3 + 172);
    }
    else {
      int v5 = 0;
    }
    *(_DWORD *)long long buf = 67109120;
    int v65 = v5;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v2, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLIENT_TRANSIT_APPLET_STATE", "InSessionExpress=%d", buf, 8u);
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    [*(id *)(a1 + 32) switchToSecureElementWrapperForApplet:*(void *)(a1 + 40)];
    if ([*(id *)(a1 + 32) startWiredMode])
    {
      __int16 v29 = [*(id *)(a1 + 32) secureElementWrapper];
      uint64_t v30 = [*(id *)(a1 + 40) identifier];
      uint64_t v23 = sub_1002473C8(v29, v30);

      id v31 = [*(id *)(a1 + 32) secureElementWrapper];
      id v59 = 0;
      id v24 = sub_10024F870(v31, v23, &v59);
      id v22 = v59;

      kdebug_trace();
      int v32 = NFSharedSignpostLog();
      if (os_signpost_enabled(v32))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v32, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CLIENT_CALLBACK", (const char *)&unk_100286819, buf, 2u);
      }

      (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
      __int16 v33 = *(double **)(a1 + 32);
      if (v33[34] <= 0.0)
      {
        [v33 startDefaultMode];
      }
      else
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          uint64_t v35 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(*(id *)(a1 + 32));
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(*(id *)(a1 + 32));
          Name = sel_getName(*(SEL *)(a1 + 56));
          uint64_t v39 = 45;
          if (isMetaClass) {
            uint64_t v39 = 43;
          }
          v35(6, "%c[%{public}s %{public}s]:%i Delaying restart of default mode", v39, ClassName, Name, 886);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        BOOL v40 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v41 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v41)) {
            int v42 = 43;
          }
          else {
            int v42 = 45;
          }
          uint64_t v43 = object_getClassName(*(id *)(a1 + 32));
          int v44 = sel_getName(*(SEL *)(a1 + 56));
          *(_DWORD *)long long buf = 67109890;
          int v65 = v42;
          __int16 v66 = 2082;
          __int16 v67 = v43;
          __int16 v68 = 2082;
          NSErrorUserInfoKey v69 = v44;
          __int16 v70 = 1024;
          int v71 = 886;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Delaying restart of default mode", buf, 0x22u);
        }

        [*(id *)(a1 + 32) pauseExpressAndStartDefaultModeAfter:*(double *)(*(void *)(a1 + 32) + 272)];
      }
      goto LABEL_20;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v45 = NFLogGetLogger();
    if (v45)
    {
      int v46 = (void (*)(uint64_t, const char *, ...))v45;
      id v47 = object_getClass(*(id *)(a1 + 32));
      BOOL v48 = class_isMetaClass(v47);
      uint64_t v49 = object_getClassName(*(id *)(a1 + 32));
      int v58 = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v50 = 45;
      if (v48) {
        uint64_t v50 = 43;
      }
      v46(3, "%c[%{public}s %{public}s]:%i Failed to set mode to wired", v50, v49, v58, 869);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    NSErrorUserInfoKey v51 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
    {
      int v52 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v52)) {
        int v53 = 43;
      }
      else {
        int v53 = 45;
      }
      int v54 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v55 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)long long buf = 67109890;
      int v65 = v53;
      __int16 v66 = 2082;
      __int16 v67 = v54;
      __int16 v68 = 2082;
      NSErrorUserInfoKey v69 = v55;
      __int16 v70 = 1024;
      int v71 = 869;
      _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set mode to wired", buf, 0x22u);
    }

    uint64_t v20 = *(void *)(a1 + 48);
    id v56 = objc_alloc((Class)NSError);
    id v22 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v60 = NSLocalizedDescriptionKey;
    uint64_t v23 = +[NSString stringWithUTF8String:"Unexpected Result"];
    id v61 = v23;
    id v24 = +[NSDictionary dictionaryWithObjects:&v61 forKeys:&v60 count:1];
    id v25 = v56;
    id v26 = v22;
    uint64_t v27 = 13;
LABEL_19:
    id v28 = [v25 initWithDomain:v26 code:v27 userInfo:v24];
    (*(void (**)(uint64_t, void, id))(v20 + 16))(v20, 0, v28);

LABEL_20:
    return;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v6 = NFLogGetLogger();
  if (v6)
  {
    id v7 = (void (*)(uint64_t, const char *, ...))v6;
    uint64_t v8 = object_getClass(*(id *)(a1 + 32));
    BOOL v9 = class_isMetaClass(v8);
    uint64_t v10 = object_getClassName(*(id *)(a1 + 32));
    int v11 = sel_getName(*(SEL *)(a1 + 56));
    int v12 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v13 = 45;
    if (v9) {
      uint64_t v13 = 43;
    }
    v7(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v13, v10, v11, 862, v12);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v14 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
  {
    uint64_t v15 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v15)) {
      int v16 = 43;
    }
    else {
      int v16 = 45;
    }
    id v17 = object_getClassName(*(id *)(a1 + 32));
    id v18 = sel_getName(*(SEL *)(a1 + 56));
    BOOL v19 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v65 = v16;
    __int16 v66 = 2082;
    __int16 v67 = v17;
    __int16 v68 = 2082;
    NSErrorUserInfoKey v69 = v18;
    __int16 v70 = 1024;
    int v71 = 862;
    __int16 v72 = 2114;
    NSErrorUserInfoKey v73 = v19;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v20 = *(void *)(a1 + 48);
  if (v20)
  {
    id v21 = objc_alloc((Class)NSError);
    id v22 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v62 = NSLocalizedDescriptionKey;
    uint64_t v23 = +[NSString stringWithUTF8String:"Session not active"];
    NSErrorUserInfoKey v63 = v23;
    id v24 = +[NSDictionary dictionaryWithObjects:&v63 forKeys:&v62 count:1];
    id v25 = v21;
    id v26 = v22;
    uint64_t v27 = 54;
    goto LABEL_19;
  }
}

void sub_10013A36C(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    id v2 = [*(id *)(a1 + 32) remoteObject];
    [v2 didFailDeferredAuthorization];
  }
}

void sub_10013DCC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id location)
{
  objc_destroyWeak(v22);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_10013DD0C(uint64_t a1)
{
  id v2 = _os_activity_create((void *)&_mh_execute_header, "com.apple.nfcd.express.restartTimer", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  *(void *)state = 0;
  *(void *)&state[8] = 0;
  os_activity_scope_enter(v2, (os_activity_scope_state_t)state);
  os_activity_scope_leave((os_activity_scope_state_t)state);

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      int v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(WeakRetained);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(WeakRetained);
      Name = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v5(6, "%c[%{public}s %{public}s]:%i ", v9, ClassName, Name, 1584);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = object_getClass(WeakRetained);
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      uint64_t v13 = object_getClassName(WeakRetained);
      uint64_t v14 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)state = 67109890;
      *(_DWORD *)&state[4] = v12;
      *(_WORD *)&state[8] = 2082;
      *(void *)&state[10] = v13;
      __int16 v20 = 2082;
      id v21 = v14;
      __int16 v22 = 1024;
      int v23 = 1584;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", state, 0x22u);
    }

    uint64_t v15 = [WeakRetained expressModeManager];
    int v16 = v15;
    if (v15) {
      sub_10004360C(v15, 0, 1u);
    }

    [WeakRetained startDefaultMode];
    id v17 = (void *)WeakRetained[39];
    WeakRetained[39] = 0;
  }
}

void sub_10013F360(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v7 = 45;
    if (isMetaClass) {
      uint64_t v7 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i ", v7, ClassName, Name, 1749);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v8 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v9)) {
      int v10 = 43;
    }
    else {
      int v10 = 45;
    }
    int v11 = object_getClassName(*(id *)(a1 + 32));
    int v12 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)long long buf = 67109890;
    int v16 = v10;
    __int16 v17 = 2082;
    id v18 = v11;
    __int16 v19 = 2082;
    __int16 v20 = v12;
    __int16 v21 = 1024;
    int v22 = 1749;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  uint64_t v13 = [*(id *)(a1 + 32) remoteObject];
  [v13 didReceivePendingServerRequest];
}

void sub_100140064(uint64_t a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  [v5 objectForKeyedSubscript:@"NFHistoryRecords"];
  long long v37 = 0u;
  long long v38 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  id v6 = (id)objc_claimAutoreleasedReturnValue();
  id v7 = [v6 countByEnumeratingWithState:&v37 objects:v53 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v38;
    id v34 = v5;
    id v35 = v4;
    while (2)
    {
      for (i = 0; i != v8; i = (char *)i + 1)
      {
        if (*(void *)v38 != v9) {
          objc_enumerationMutation(v6);
        }
        int v11 = *(void **)(*((void *)&v37 + 1) + 8 * i);
        int v12 = [v11 objectForKeyedSubscript:@"NFServiceProviderID"];
        if ([v12 intValue] == 1 || objc_msgSend(v12, "intValue") == 4) {
          goto LABEL_16;
        }
        uint64_t v13 = [v11 objectForKeyedSubscript:@"NFBalance"];
        if (v13
          || ([v11 objectForKeyedSubscript:@"NFTransactionDate"],
              (uint64_t v13 = objc_claimAutoreleasedReturnValue()) != 0))
        {

LABEL_16:
          uint64_t v15 = 61441;
          id v5 = v34;
          id v4 = v35;
          goto LABEL_17;
        }
        uint64_t v14 = [v11 objectForKeyedSubscript:@"NFAmount"];

        if (v14) {
          goto LABEL_16;
        }
      }
      id v8 = [v6 countByEnumeratingWithState:&v37 objects:v53 count:16];
      uint64_t v15 = 61442;
      id v5 = v34;
      id v4 = v35;
      if (v8) {
        continue;
      }
      break;
    }
  }
  else
  {
    uint64_t v15 = 61442;
  }
LABEL_17:

  id v16 = objc_alloc((Class)NSMutableDictionary);
  v51[0] = @"appletIdentifier";
  v51[1] = @"type";
  v52[0] = v4;
  v52[1] = &off_10031C1F8;
  v51[2] = @"result";
  __int16 v17 = +[NSNumber numberWithUnsignedShort:v15];
  v51[3] = @"felicaInfo";
  v52[2] = v17;
  v52[3] = v5;
  id v18 = +[NSDictionary dictionaryWithObjects:v52 forKeys:v51 count:4];
  id v19 = [v16 initWithDictionary:v18];

  __int16 v20 = [[NFContactlessPaymentEndEvent alloc] initWithDictionary:v19];
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    int v22 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v25 = 45;
    if (isMetaClass) {
      uint64_t v25 = 43;
    }
    v22(6, "%c[%{public}s %{public}s]:%i %{public}@", v25, ClassName, Name, 1855, v20);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v26 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v27 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v27)) {
      int v28 = 43;
    }
    else {
      int v28 = 45;
    }
    __int16 v29 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v30 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)long long buf = 67110146;
    int v42 = v28;
    __int16 v43 = 2082;
    int v44 = v29;
    __int16 v45 = 2082;
    int v46 = v30;
    __int16 v47 = 1024;
    int v48 = 1855;
    __int16 v49 = 2114;
    uint64_t v50 = v20;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }

  id v31 = [*(id *)(a1 + 32) remoteObject];
  [v31 didEndTransaction:v20];
}

id sub_100140860(void *a1)
{
  id v1 = a1;
  id v2 = objc_alloc((Class)NSError);
  id v3 = [objc_alloc((Class)NSString) initWithFormat:@"NFTrust Internal Error : '%@'", v1, NSLocalizedDescriptionKey];

  id v8 = v3;
  id v4 = +[NSDictionary dictionaryWithObjects:&v8 forKeys:&v7 count:1];
  id v5 = [v2 initWithDomain:@"Trust" code:0 userInfo:v4];

  return v5;
}

id sub_100140964()
{
  id v0 = objc_alloc((Class)NSError);
  NSErrorUserInfoKey v5 = NSLocalizedDescriptionKey;
  id v1 = [objc_alloc((Class)NSString) initWithFormat:@"NFTrust Need Refresh"];
  id v6 = v1;
  id v2 = +[NSDictionary dictionaryWithObjects:&v6 forKeys:&v5 count:1];
  id v3 = [v0 initWithDomain:@"Trust" code:1 userInfo:v2];

  return v3;
}

id sub_100140A54()
{
  id v0 = objc_alloc((Class)NSError);
  NSErrorUserInfoKey v5 = NSLocalizedDescriptionKey;
  id v1 = [objc_alloc((Class)NSString) initWithFormat:@"NFTrust database error"];
  id v6 = v1;
  id v2 = +[NSDictionary dictionaryWithObjects:&v6 forKeys:&v5 count:1];
  id v3 = [v0 initWithDomain:@"Trust" code:7 userInfo:v2];

  return v3;
}

id sub_100140B44()
{
  id v0 = objc_alloc((Class)NSError);
  NSErrorUserInfoKey v5 = NSLocalizedDescriptionKey;
  id v1 = [objc_alloc((Class)NSString) initWithFormat:@"Operation requires LocalValidation"];
  id v6 = v1;
  id v2 = +[NSDictionary dictionaryWithObjects:&v6 forKeys:&v5 count:1];
  id v3 = [v0 initWithDomain:@"Trust" code:4 userInfo:v2];

  return v3;
}

id sub_100140C34(void *a1)
{
  id v1 = a1;
  id v2 = objc_alloc((Class)NSError);
  id v3 = [objc_alloc((Class)NSString) initWithFormat:@"No space left in the instance to %@", v1, NSLocalizedDescriptionKey];

  id v8 = v3;
  id v4 = +[NSDictionary dictionaryWithObjects:&v8 forKeys:&v7 count:1];
  id v5 = [v2 initWithDomain:@"Trust" code:6 userInfo:v4];

  return v5;
}

id sub_100140D38(void *a1)
{
  id v1 = a1;
  id v2 = objc_alloc((Class)NSError);
  id v3 = [objc_alloc((Class)NSString) initWithFormat:@"Key with Identifier '%@' not found", v1, NSLocalizedDescriptionKey];

  id v8 = v3;
  id v4 = +[NSDictionary dictionaryWithObjects:&v8 forKeys:&v7 count:1];
  id v5 = [v2 initWithDomain:@"Trust" code:2 userInfo:v4];

  return v5;
}

id sub_100140E3C(void *a1)
{
  id v1 = a1;
  id v2 = objc_alloc((Class)NSError);
  id v3 = [objc_alloc((Class)NSString) initWithFormat:@"Key with Identifier '%@' already exists", v1, NSLocalizedDescriptionKey];

  id v8 = v3;
  id v4 = +[NSDictionary dictionaryWithObjects:&v8 forKeys:&v7 count:1];
  id v5 = [v2 initWithDomain:@"Trust" code:3 userInfo:v4];

  return v5;
}

id sub_100140F40(void *a1)
{
  id v1 = a1;
  id v2 = objc_alloc((Class)NSError);
  id v3 = [objc_alloc((Class)NSString) initWithFormat:@"Invalid Parameters : '%@'", v1, NSLocalizedDescriptionKey];

  id v8 = v3;
  id v4 = +[NSDictionary dictionaryWithObjects:&v8 forKeys:&v7 count:1];
  id v5 = [v2 initWithDomain:@"Trust" code:5 userInfo:v4];

  return v5;
}

void sub_100141098(id a1)
{
  id v19 = objc_alloc((Class)NSSet);
  uint64_t v18 = objc_opt_class();
  uint64_t v17 = objc_opt_class();
  uint64_t v16 = objc_opt_class();
  uint64_t v15 = objc_opt_class();
  uint64_t v14 = objc_opt_class();
  uint64_t v13 = objc_opt_class();
  uint64_t v1 = objc_opt_class();
  uint64_t v2 = objc_opt_class();
  uint64_t v3 = objc_opt_class();
  uint64_t v4 = objc_opt_class();
  uint64_t v5 = objc_opt_class();
  uint64_t v6 = objc_opt_class();
  uint64_t v7 = objc_opt_class();
  uint64_t v8 = objc_opt_class();
  uint64_t v9 = objc_opt_class();
  uint64_t v10 = objc_opt_class();
  id v11 = objc_msgSend(v19, "initWithObjects:", v18, v17, v16, v15, v14, v13, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, objc_opt_class(),
          0);
  uint64_t v12 = qword_100347460;
  qword_100347460 = (uint64_t)v11;

  _objc_release_x1(v11, v12);
}

void sub_100147928(uint64_t a1)
{
  uint64_t v2 = +[_NFHardwareManager sharedHardwareManager];
  if (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v2) != 2)
  {
    uint64_t v5 = *(void *)(a1 + 40);
    id v6 = objc_alloc((Class)NSError);
    uint64_t v7 = +[NSString stringWithUTF8String:"nfcd"];
    v176[0] = NSLocalizedDescriptionKey;
    uint64_t v8 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
    v177[0] = v8;
    v177[1] = &off_10031C270;
    v176[1] = @"Line";
    v176[2] = @"Method";
    id v9 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
    v177[2] = v9;
    v176[3] = NSDebugDescriptionErrorKey;
    id v10 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 94];
    v177[3] = v10;
    id v11 = +[NSDictionary dictionaryWithObjects:v177 forKeys:v176 count:4];
    uint64_t v12 = v6;
    uint64_t v13 = v7;
    uint64_t v14 = 58;
LABEL_48:
    id v66 = [v12 initWithDomain:v13 code:v14 userInfo:v11];
    (*(void (**)(uint64_t, id, void))(v5 + 16))(v5, v66, 0);

    goto LABEL_49;
  }
  uint64_t v3 = [v2 controllerInfo];
  unsigned __int8 v4 = [v3 hasLPEMSupport];

  if ((v4 & 1) == 0)
  {
    uint64_t v5 = *(void *)(a1 + 40);
    id v15 = objc_alloc((Class)NSError);
    uint64_t v7 = +[NSString stringWithUTF8String:"nfcd"];
    v174[0] = NSLocalizedDescriptionKey;
    uint64_t v8 = +[NSString stringWithUTF8String:"Feature Not Supported"];
    v175[0] = v8;
    v175[1] = &off_10031C288;
    v174[1] = @"Line";
    v174[2] = @"Method";
    id v9 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
    v175[2] = v9;
    v174[3] = NSDebugDescriptionErrorKey;
    id v10 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 99];
    v175[3] = v10;
    id v11 = +[NSDictionary dictionaryWithObjects:v175 forKeys:v174 count:4];
    uint64_t v12 = v15;
    uint64_t v13 = v7;
    uint64_t v14 = 14;
    goto LABEL_48;
  }
  if (byte_100347468 == 1)
  {
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    goto LABEL_49;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v17 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v21 = 45;
    if (isMetaClass) {
      uint64_t v21 = 43;
    }
    v17(6, "%c[%{public}s %{public}s]:%i Querying bluetooth log", v21, ClassName, Name, 109);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v22 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
  {
    int v23 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v23)) {
      int v24 = 43;
    }
    else {
      int v24 = 45;
    }
    uint64_t v25 = object_getClassName(*(id *)(a1 + 32));
    id v26 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)long long buf = 67109890;
    int v163 = v24;
    __int16 v164 = 2082;
    __int16 v165 = v25;
    __int16 v166 = 2082;
    __int16 v167 = v26;
    __int16 v168 = 1024;
    int v169 = 109;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Querying bluetooth log", buf, 0x22u);
  }

  if (([*(id *)(a1 + 32) _dumpLPEMAppletLogs] & 1) == 0)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v54 = NFLogGetLogger();
    if (v54)
    {
      uint64_t v55 = (void (*)(uint64_t, const char *, ...))v54;
      id v56 = object_getClass(*(id *)(a1 + 32));
      BOOL v57 = class_isMetaClass(v56);
      int v58 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v145 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v59 = 45;
      if (v57) {
        uint64_t v59 = 43;
      }
      v55(3, "%c[%{public}s %{public}s]:%i Failed to query log", v59, v58, v145, 111);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    NSErrorUserInfoKey v60 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
    {
      id v61 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v61)) {
        int v62 = 43;
      }
      else {
        int v62 = 45;
      }
      NSErrorUserInfoKey v63 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v64 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)long long buf = 67109890;
      int v163 = v62;
      __int16 v164 = 2082;
      __int16 v165 = v63;
      __int16 v166 = 2082;
      __int16 v167 = v64;
      __int16 v168 = 1024;
      int v169 = 111;
      _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to query log", buf, 0x22u);
    }

    uint64_t v5 = *(void *)(a1 + 40);
    id v65 = objc_alloc((Class)NSError);
    uint64_t v7 = +[NSString stringWithUTF8String:"nfcd"];
    v172[0] = NSLocalizedDescriptionKey;
    uint64_t v8 = +[NSString stringWithUTF8String:"Unknown Error"];
    v173[0] = v8;
    v173[1] = &off_10031C2A0;
    v172[1] = @"Line";
    v172[2] = @"Method";
    id v9 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
    v173[2] = v9;
    v172[3] = NSDebugDescriptionErrorKey;
    id v10 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 112];
    v173[3] = v10;
    id v11 = +[NSDictionary dictionaryWithObjects:v173 forKeys:v172 count:4];
    uint64_t v12 = v65;
    uint64_t v13 = v7;
    uint64_t v14 = 6;
    goto LABEL_48;
  }
  uint64_t v153 = NSHomeDirectory();
  uint64_t v27 = [v153 stringByAppendingFormat:@"/Library/Logs/nfcd_lpem.bin"];
  int v28 = +[NSURL fileURLWithPath:v27];

  if (!v28)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v67 = NFLogGetLogger();
    if (v67)
    {
      __int16 v68 = (void (*)(uint64_t, const char *, ...))v67;
      NSErrorUserInfoKey v69 = object_getClass(*(id *)(a1 + 32));
      BOOL v70 = class_isMetaClass(v69);
      int v71 = object_getClassName(*(id *)(a1 + 32));
      int v146 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v72 = 45;
      if (v70) {
        uint64_t v72 = 43;
      }
      v68(3, "%c[%{public}s %{public}s]:%i bluetoothLog not found", v72, v71, v146, 156);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    NSErrorUserInfoKey v73 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v73, OS_LOG_TYPE_ERROR))
    {
      id v74 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v74)) {
        int v75 = 43;
      }
      else {
        int v75 = 45;
      }
      int v76 = object_getClassName(*(id *)(a1 + 32));
      __int16 v77 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)long long buf = 67109890;
      int v163 = v75;
      __int16 v164 = 2082;
      __int16 v165 = v76;
      __int16 v166 = 2082;
      __int16 v167 = v77;
      __int16 v168 = 1024;
      int v169 = 156;
      _os_log_impl((void *)&_mh_execute_header, v73, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i bluetoothLog not found", buf, 0x22u);
    }

    id v78 = objc_alloc((Class)NSError);
    id v30 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v160 = NSLocalizedDescriptionKey;
    __int16 v49 = +[NSString stringWithUTF8String:"Not found"];
    int v161 = v49;
    __int16 v79 = +[NSDictionary dictionaryWithObjects:&v161 forKeys:&v160 count:1];
    id v43 = [v78 initWithDomain:v30 code:65 userInfo:v79];

    id v41 = 0;
    goto LABEL_107;
  }
  id v159 = 0;
  unsigned int v29 = [v28 checkResourceIsReachableAndReturnError:&v159];
  id v30 = v159;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v31 = NFLogGetLogger();
  if (v31)
  {
    int v32 = (void (*)(uint64_t, const char *, ...))v31;
    __int16 v33 = object_getClass(*(id *)(a1 + 32));
    BOOL v34 = class_isMetaClass(v33);
    v139 = object_getClassName(*(id *)(a1 + 32));
    id v143 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v35 = 45;
    if (v34) {
      uint64_t v35 = 43;
    }
    v32(6, "%c[%{public}s %{public}s]:%i bluetoothLogURL present = %d", v35, v139, v143, 125, v29);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v36 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
  {
    long long v37 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v37)) {
      int v38 = 43;
    }
    else {
      int v38 = 45;
    }
    long long v39 = object_getClassName(*(id *)(a1 + 32));
    long long v40 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)long long buf = 67110146;
    int v163 = v38;
    __int16 v164 = 2082;
    __int16 v165 = v39;
    __int16 v166 = 2082;
    __int16 v167 = v40;
    __int16 v168 = 1024;
    int v169 = 125;
    __int16 v170 = 1024;
    LODWORD(v171) = v29;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i bluetoothLogURL present = %d", buf, 0x28u);
  }

  if (v29)
  {
    id v158 = 0;
    id v41 = [objc_alloc((Class)NSDictionary) initWithContentsOfURL:v28 error:&v158];
    id v42 = v158;
    if (v42)
    {
      id v43 = v42;
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v44 = NFLogGetLogger();
      if (v44)
      {
        __int16 v45 = (void (*)(uint64_t, const char *, ...))v44;
        int v46 = object_getClass(*(id *)(a1 + 32));
        BOOL v47 = class_isMetaClass(v46);
        id v140 = object_getClassName(*(id *)(a1 + 32));
        int v144 = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v48 = 45;
        if (v47) {
          uint64_t v48 = 43;
        }
        v45(6, "%c[%{public}s %{public}s]:%i FileError: %@", v48, v140, v144, 129, v43);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v49 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v50 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v50)) {
          int v51 = 43;
        }
        else {
          int v51 = 45;
        }
        int v52 = object_getClassName(*(id *)(a1 + 32));
        int v53 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)long long buf = 67110146;
        int v163 = v51;
        __int16 v164 = 2082;
        __int16 v165 = v52;
        __int16 v166 = 2082;
        __int16 v167 = v53;
        __int16 v168 = 1024;
        int v169 = 129;
        __int16 v170 = 2112;
        id v171 = v43;
        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i FileError: %@", buf, 0x2Cu);
      }
      goto LABEL_107;
    }
    byte_100347468 = 1;
    BOOL v89 = [v41 NF_numberForKey:@"retrieved"];
    __int16 v49 = v89;
    if (v89 && [v89 BOOLValue])
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v90 = NFLogGetLogger();
      if (v90)
      {
        uint64_t v91 = (void (*)(uint64_t, const char *, ...))v90;
        __int16 v92 = object_getClass(*(id *)(a1 + 32));
        BOOL v93 = class_isMetaClass(v92);
        int v94 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v148 = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v95 = 45;
        if (v93) {
          uint64_t v95 = 43;
        }
        v91(6, "%c[%{public}s %{public}s]:%i Log file already retrieved", v95, v94, v148, 136);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v96 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
      {
        int v97 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v97)) {
          int v98 = 43;
        }
        else {
          int v98 = 45;
        }
        uint64_t v99 = object_getClassName(*(id *)(a1 + 32));
        int v100 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)long long buf = 67109890;
        int v163 = v98;
        __int16 v164 = 2082;
        __int16 v165 = v99;
        __int16 v166 = 2082;
        __int16 v167 = v100;
        __int16 v168 = 1024;
        int v169 = 136;
        _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Log file already retrieved", buf, 0x22u);
      }
      id v101 = v41;
      id v41 = 0;
    }
    else
    {
      if (!*(unsigned char *)(a1 + 56))
      {
LABEL_106:
        id v43 = 0;
LABEL_107:

        goto LABEL_108;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v102 = NFLogGetLogger();
      if (v102)
      {
        NSErrorUserInfoKey v103 = (void (*)(uint64_t, const char *, ...))v102;
        BOOL v104 = object_getClass(*(id *)(a1 + 32));
        BOOL v105 = class_isMetaClass(v104);
        int v106 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v149 = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v107 = 45;
        if (v105) {
          uint64_t v107 = 43;
        }
        v103(6, "%c[%{public}s %{public}s]:%i Updating log file as retrieved", v107, v106, v149, 141);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v108 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v108, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v109 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v109)) {
          int v110 = 43;
        }
        else {
          int v110 = 45;
        }
        uint64_t v111 = object_getClassName(*(id *)(a1 + 32));
        int v112 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)long long buf = 67109890;
        int v163 = v110;
        __int16 v164 = 2082;
        __int16 v165 = v111;
        __int16 v166 = 2082;
        __int16 v167 = v112;
        __int16 v168 = 1024;
        int v169 = 141;
        _os_log_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Updating log file as retrieved", buf, 0x22u);
      }

      id v113 = objc_alloc((Class)NSString);
      int v114 = NSHomeDirectory();
      id v101 = [v113 initWithFormat:@"%@%@", v114, @"/Library/Logs/nfcd_lpem.bin"];

      __int16 v96 = [v41 mutableCopy];
      [v96 setObject:&__kCFBooleanTrue forKeyedSubscript:@"retrieved"];
      if (([v96 writeToFile:v101 atomically:0] & 1) == 0)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v115 = NFLogGetLogger();
        if (v115)
        {
          long long v116 = (void (*)(uint64_t, const char *, ...))v115;
          uint64_t v117 = object_getClass(*(id *)(a1 + 32));
          BOOL v118 = class_isMetaClass(v117);
          uint64_t v151 = object_getClassName(*(id *)(a1 + 32));
          uint64_t v119 = sel_getName(*(SEL *)(a1 + 48));
          uint64_t v120 = 45;
          if (v118) {
            uint64_t v120 = 43;
          }
          v116(3, "%c[%{public}s %{public}s]:%i Failed to update LPEM log as read: %{public}@", v120, v151, v119, 146, v101);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v121 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v121, OS_LOG_TYPE_ERROR))
        {
          BOOL v122 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v122)) {
            int v123 = 43;
          }
          else {
            int v123 = 45;
          }
          char v152 = object_getClassName(*(id *)(a1 + 32));
          id v124 = sel_getName(*(SEL *)(a1 + 48));
          *(_DWORD *)long long buf = 67110146;
          int v163 = v123;
          __int16 v164 = 2082;
          __int16 v165 = v152;
          __int16 v166 = 2082;
          __int16 v167 = v124;
          __int16 v168 = 1024;
          int v169 = 146;
          __int16 v170 = 2114;
          id v171 = v101;
          _os_log_impl((void *)&_mh_execute_header, v121, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to update LPEM log as read: %{public}@", buf, 0x2Cu);
        }
      }
    }

    goto LABEL_106;
  }
  if (v30)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v80 = NFLogGetLogger();
    if (v80)
    {
      __int16 v81 = (void (*)(uint64_t, const char *, ...))v80;
      int v82 = object_getClass(*(id *)(a1 + 32));
      BOOL v83 = class_isMetaClass(v82);
      id v141 = object_getClassName(*(id *)(a1 + 32));
      id v147 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v84 = 45;
      if (v83) {
        uint64_t v84 = 43;
      }
      v81(3, "%c[%{public}s %{public}s]:%i Failed file check: %@", v84, v141, v147, 152, v30);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v49 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
    {
      unsigned __int8 v85 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v85)) {
        int v86 = 43;
      }
      else {
        int v86 = 45;
      }
      id v87 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v88 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)long long buf = 67110146;
      int v163 = v86;
      __int16 v164 = 2082;
      __int16 v165 = v87;
      __int16 v166 = 2082;
      __int16 v167 = v88;
      __int16 v168 = 1024;
      int v169 = 152;
      __int16 v170 = 2112;
      id v171 = v30;
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed file check: %@", buf, 0x2Cu);
    }
    id v41 = 0;
    goto LABEL_106;
  }
  id v41 = 0;
  id v43 = 0;
LABEL_108:

  if (*(unsigned char *)(a1 + 56))
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v125 = NFLogGetLogger();
    if (v125)
    {
      long long v126 = (void (*)(uint64_t, const char *, ...))v125;
      uint64_t v127 = object_getClass(*(id *)(a1 + 32));
      BOOL v128 = class_isMetaClass(v127);
      long long v129 = object_getClassName(*(id *)(a1 + 32));
      id v150 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v130 = 45;
      if (v128) {
        uint64_t v130 = 43;
      }
      v126(6, "%c[%{public}s %{public}s]:%i Clearing log data", v130, v129, v150, 161);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v131 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v131, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v132 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v132)) {
        int v133 = 43;
      }
      else {
        int v133 = 45;
      }
      uint64_t v134 = object_getClassName(*(id *)(a1 + 32));
      int v135 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)long long buf = 67109890;
      int v163 = v133;
      __int16 v164 = 2082;
      __int16 v165 = v134;
      __int16 v166 = 2082;
      __int16 v167 = v135;
      __int16 v168 = 1024;
      int v169 = 161;
      _os_log_impl((void *)&_mh_execute_header, v131, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Clearing log data", buf, 0x22u);
    }

    v154[0] = _NSConcreteStackBlock;
    v154[1] = 3221225472;
    v154[2] = sub_100148BB8;
    v154[3] = &unk_1003049C0;
    id v136 = v2;
    uint64_t v137 = *(void *)(a1 + 32);
    id v155 = v136;
    uint64_t v156 = v137;
    uint64_t v157 = *(void *)(a1 + 48);
    id v138 = +[NFRoutingConfig embeddedWiredModeWithFD:2];
    sub_1000F23D8((void **)v136, v154, @"erase bt log", v138);
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();

LABEL_49:
}

uint64_t sub_100148BB8(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) secureElementWrapper];
  uint64_t v3 = sub_1000AB908(v2, 4);

  if (!v3)
  {
    unsigned __int8 v4 = [*(id *)(a1 + 32) secureElementWrapper];
    uint64_t v3 = sub_1000AB908(v4, 5);

    if (!v3) {
      return 1;
    }
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v6 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 40));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 40));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v6(3, "%c[%{public}s %{public}s]:%i Failed to erase BT logs %@", v9, ClassName, Name, 172, v3);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    id v11 = object_getClass(*(id *)(a1 + 40));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    uint64_t v13 = object_getClassName(*(id *)(a1 + 40));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)long long buf = 67110146;
    int v19 = v12;
    __int16 v20 = 2082;
    uint64_t v21 = v13;
    __int16 v22 = 2082;
    int v23 = v14;
    __int16 v24 = 1024;
    int v25 = 172;
    __int16 v26 = 2112;
    uint64_t v27 = v3;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to erase BT logs %@", buf, 0x2Cu);
  }

  return 0;
}

void sub_100149C88(uint64_t a1, void *a2, void *a3)
{
  id v6 = a3;
  if (a2)
  {
    if (a2[1]) {
      id v5 = [objc_alloc((Class)NSData) initWithBytes:*a2 length:a2[1]];
    }
    else {
      id v5 = 0;
    }
    NFDataRelease();
  }
  else
  {
    id v5 = 0;
  }
  (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t sub_100149F1C(uint64_t result, unint64_t a2)
{
  if (result)
  {
    uint64_t v3 = (void *)result;
    if (a2 >= 3)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        id v5 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(v3);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(v3);
        Name = sel_getName("deassert:");
        uint64_t v8 = 45;
        if (isMetaClass) {
          uint64_t v8 = 43;
        }
        v5(3, "%c[%{public}s %{public}s]:%i Invalid type: %lu", v8, ClassName, Name, 40, a2);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v9 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        goto LABEL_23;
      }
      id v10 = object_getClass(v3);
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      *(_DWORD *)long long buf = 67110146;
      int v28 = v11;
      __int16 v29 = 2082;
      id v30 = object_getClassName(v3);
      __int16 v31 = 2082;
      int v32 = sel_getName("deassert:");
      __int16 v33 = 1024;
      int v34 = 40;
      __int16 v35 = 2048;
      unint64_t v36 = a2;
      int v12 = "%c[%{public}s %{public}s]:%i Invalid type: %lu";
      uint64_t v13 = v9;
      uint32_t v14 = 44;
LABEL_22:
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, v12, buf, v14);
LABEL_23:

      return 0;
    }
    unsigned int v15 = (*(unsigned char *)(result + a2 + 8))-- - 1;
    if (v15 >= 0x100)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v16 = NFLogGetLogger();
      if (v16)
      {
        uint64_t v17 = (void (*)(uint64_t, const char *, ...))v16;
        uint64_t v18 = object_getClass(v3);
        BOOL v19 = class_isMetaClass(v18);
        __int16 v20 = object_getClassName(v3);
        uint64_t v21 = sel_getName("deassert:");
        uint64_t v22 = 45;
        if (v19) {
          uint64_t v22 = 43;
        }
        v17(3, "%c[%{public}s %{public}s]:%i Count underflow", v22, v20, v21, 45);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v9 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
        goto LABEL_23;
      }
      int v23 = object_getClass(v3);
      if (class_isMetaClass(v23)) {
        int v24 = 43;
      }
      else {
        int v24 = 45;
      }
      *(_DWORD *)long long buf = 67109890;
      int v28 = v24;
      __int16 v29 = 2082;
      id v30 = object_getClassName(v3);
      __int16 v31 = 2082;
      int v32 = sel_getName("deassert:");
      __int16 v33 = 1024;
      int v34 = 45;
      int v12 = "%c[%{public}s %{public}s]:%i Count underflow";
      uint64_t v13 = v9;
      uint32_t v14 = 34;
      goto LABEL_22;
    }
    return 1;
  }
  return result;
}

id sub_10014A1F8(unsigned __int8 *a1)
{
  if (a1)
  {
    uint64_t v2 = objc_opt_new();
    uint64_t v3 = +[NSNumber numberWithUnsignedChar:a1[8]];
    [v2 setObject:v3 forKeyedSubscript:@"PKForegroundPresentment"];

    unsigned __int8 v4 = +[NSNumber numberWithUnsignedChar:a1[9]];
    [v2 setObject:v4 forKeyedSubscript:@"DefaultAppPresentmentSuppress"];

    id v5 = +[NSNumber numberWithUnsignedChar:a1[10]];
    [v2 setObject:v5 forKeyedSubscript:@"FDDefaultAppPresentmentSuppress"];
  }
  else
  {
    uint64_t v2 = 0;
  }

  return v2;
}

void *sub_10014A4A8(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    v10.receiver = a1;
    v10.super_class = (Class)NFTagAppProcessorHomeKitAccessory;
    a1 = [super init];
    if (a1)
    {
      id v7 = [objc_alloc((Class)NFXPCEventPublisher) initWithStreamName:v5 queue:v6];
      uint64_t v8 = (void *)a1[1];
      a1[1] = v7;
    }
  }

  return a1;
}

void sub_10014AA34(id a1)
{
  v3[0] = &off_10031C2B8;
  v3[1] = &off_10031C2D0;
  v4[0] = @"Suica";
  v4[1] = @"ECP1.Access";
  v3[2] = &off_10031C2E8;
  v3[3] = &off_10031C300;
  v4[2] = @"GenericA";
  v4[3] = @"ECP2";
  v3[4] = &off_10031C318;
  v3[5] = &off_10031C330;
  v4[4] = @"Cathay";
  v4[5] = @"QuickMode";
  uint64_t v1 = +[NSDictionary dictionaryWithObjects:v4 forKeys:v3 count:6];
  uint64_t v2 = (void *)qword_100347470;
  qword_100347470 = v1;
}

void sub_10014ABB0(id a1)
{
  v3[0] = @"Suica";
  v3[1] = @"ECP1.Access";
  v4[0] = &off_10031C2B8;
  v4[1] = &off_10031C2D0;
  v3[2] = @"GenericA";
  v3[3] = @"ECP2";
  v4[2] = &off_10031C2E8;
  v4[3] = &off_10031C300;
  v3[4] = @"Cathay";
  v3[5] = @"QuickMode";
  v4[4] = &off_10031C318;
  v4[5] = &off_10031C330;
  uint64_t v1 = +[NSDictionary dictionaryWithObjects:v4 forKeys:v3 count:6];
  uint64_t v2 = (void *)qword_100347480;
  qword_100347480 = v1;
}

void sub_10014C55C(void *a1, void *a2, void *a3, void *a4, unsigned int a5, void *a6)
{
  id v10 = a2;
  id v11 = a3;
  id v12 = a4;
  id v83 = a6;
  if (a1)
  {
    uint64_t v13 = [a1 getSecureElementWrapperAndSetRouting];
    uint32_t v14 = sub_1002473C8(v13, v11);

    id v86 = a1;
    if (v14)
    {
      long long v93 = 0u;
      long long v94 = 0u;
      long long v91 = 0u;
      long long v92 = 0u;
      unsigned int v15 = v10;
      id v84 = [v15 countByEnumeratingWithState:&v91 objects:v107 count:16];
      if (!v84) {
        goto LABEL_59;
      }
      uint64_t v78 = *(void *)v92;
      uint64_t v80 = v14;
      __int16 v81 = v12;
      __int16 v79 = v15;
      while (1)
      {
        uint64_t v16 = 0;
        do
        {
          if (*(void *)v92 != v78) {
            objc_enumerationMutation(v15);
          }
          uint64_t v85 = v16;
          uint64_t v17 = *(void **)(*((void *)&v91 + 1) + 8 * v16);
          long long v87 = 0u;
          long long v88 = 0u;
          long long v89 = 0u;
          long long v90 = 0u;
          id v18 = v83;
          id v19 = [v18 countByEnumeratingWithState:&v87 objects:v106 count:16];
          if (v19)
          {
            id v20 = v19;
            uint64_t v21 = *(void *)v88;
            do
            {
              uint64_t v22 = 0;
              do
              {
                if (*(void *)v88 != v21) {
                  objc_enumerationMutation(v18);
                }
                int v23 = *(void **)(*((void *)&v87 + 1) + 8 * (void)v22);
                int v24 = [v23 objectForKeyedSubscript:@"appletIdentifier"];
                if ([v11 caseInsensitiveCompare:v24]) {
                  goto LABEL_14;
                }
                int v25 = [v23 objectForKeyedSubscript:@"keyIdentifier"];
                id v26 = [v17 caseInsensitiveCompare:v25];

                if (!v26)
                {
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  uint64_t Logger = NFLogGetLogger();
                  if (Logger)
                  {
                    int v28 = (void (*)(uint64_t, const char *, ...))Logger;
                    Class = object_getClass(v86);
                    BOOL isMetaClass = class_isMetaClass(Class);
                    ClassName = object_getClassName(v86);
                    Name = sel_getName("_addKeysFromArray:forAid:expressInfo:supportsUWB:intoPassArray:");
                    uint64_t v32 = 45;
                    if (isMetaClass) {
                      uint64_t v32 = 43;
                    }
                    v28(6, "%c[%{public}s %{public}s]:%i aid:%{public}@ key:%{public}@ is already in the config", v32, ClassName, Name, 293, v11, v17);
                  }
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  int v24 = NFSharedLogGetLogger();
                  if (os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT))
                  {
                    __int16 v33 = object_getClass(v86);
                    if (class_isMetaClass(v33)) {
                      int v34 = 43;
                    }
                    else {
                      int v34 = 45;
                    }
                    __int16 v35 = object_getClassName(v86);
                    unint64_t v36 = sel_getName("_addKeysFromArray:forAid:expressInfo:supportsUWB:intoPassArray:");
                    *(_DWORD *)long long buf = 67110402;
                    *(_DWORD *)&uint8_t buf[4] = v34;
                    __int16 v96 = 2082;
                    int v97 = v35;
                    __int16 v98 = 2082;
                    uint64_t v99 = v36;
                    __int16 v100 = 1024;
                    int v101 = 293;
                    __int16 v102 = 2114;
                    id v103 = v11;
                    __int16 v104 = 2114;
                    BOOL v105 = v17;
                    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i aid:%{public}@ key:%{public}@ is already in the config", buf, 0x36u);
                  }
LABEL_14:
                }
                uint64_t v22 = (char *)v22 + 1;
              }
              while (v20 != v22);
              id v37 = [v18 countByEnumeratingWithState:&v87 objects:v106 count:16];
              id v20 = v37;
            }
            while (v37);
          }

          int v38 = objc_opt_new();
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v39 = NFLogGetLogger();
          if (v39)
          {
            long long v40 = (void (*)(uint64_t, const char *, ...))v39;
            id v41 = object_getClass(v86);
            BOOL v42 = class_isMetaClass(v41);
            id v43 = object_getClassName(v86);
            int v76 = sel_getName("_addKeysFromArray:forAid:expressInfo:supportsUWB:intoPassArray:");
            uint64_t v44 = 45;
            if (v42) {
              uint64_t v44 = 43;
            }
            v40(6, "%c[%{public}s %{public}s]:%i new pass for aid:%{public}@ key:%{public}@", v44, v43, v76, 299, v11, v17);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          __int16 v45 = NFSharedLogGetLogger();
          id v12 = v81;
          if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
          {
            int v46 = object_getClass(v86);
            if (class_isMetaClass(v46)) {
              int v47 = 43;
            }
            else {
              int v47 = 45;
            }
            uint64_t v48 = object_getClassName(v86);
            __int16 v49 = sel_getName("_addKeysFromArray:forAid:expressInfo:supportsUWB:intoPassArray:");
            *(_DWORD *)long long buf = 67110402;
            *(_DWORD *)&uint8_t buf[4] = v47;
            __int16 v96 = 2082;
            int v97 = v48;
            __int16 v98 = 2082;
            uint64_t v99 = v49;
            __int16 v100 = 1024;
            int v101 = 299;
            __int16 v102 = 2114;
            id v103 = v11;
            __int16 v104 = 2114;
            BOOL v105 = v17;
            _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i new pass for aid:%{public}@ key:%{public}@", buf, 0x36u);
          }

          uint64_t v50 = [v81 objectForKeyedSubscript:@"ExpressType"];
          [v38 setObject:v50 forKeyedSubscript:@"ExpressType"];

          [v38 setObject:v11 forKeyedSubscript:@"appletIdentifier"];
          [v38 setObject:v17 forKeyedSubscript:@"keyIdentifier"];
          [v38 setObject:&__kCFBooleanTrue forKeyedSubscript:@"expressEnabled"];
          int v51 = +[NSNumber numberWithBool:a5];
          [v38 setObject:v51 forKeyedSubscript:@"UWBExpressEnabled"];

          *(void *)long long buf = 0;
          *(void *)long long buf = arc4random();
          *(void *)long long buf = arc4random() | (*(void *)buf << 32);
          id v52 = [objc_alloc((Class)NSData) initWithBytes:buf length:8];
          int v53 = [v52 NF_asHexString];
          [v38 setObject:v53 forKeyedSubscript:@"passUniqueID"];

          uint64_t v54 = [v81 objectForKeyedSubscript:@"ECP2Info"];

          if (v54)
          {
            uint64_t v55 = [v81 objectForKeyedSubscript:@"ECP2Info"];
            [v38 setObject:v55 forKeyedSubscript:@"ECP2Info"];
          }
          uint32_t v14 = v80;
          id v56 = [v80 moduleIdentifier];
          [v38 setObject:v56 forKeyedSubscript:@"moduleIdentifier"];

          BOOL v57 = +[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", [v80 groupActivationStyle]);
          [v38 setObject:v57 forKeyedSubscript:@"groupActivationStyle"];

          int v58 = [v80 groupHeadID];

          if (v58)
          {
            uint64_t v59 = [v80 groupHeadID];
            [v38 setObject:v59 forKeyedSubscript:@"groupHead"];
          }
          NSErrorUserInfoKey v60 = [v80 groupMemberIDs];
          id v61 = [v60 count];

          if (v61)
          {
            int v62 = [v80 groupMemberIDs];
            [v38 setObject:v62 forKeyedSubscript:@"groupMembers"];
          }
          NSErrorUserInfoKey v63 = [v81 objectForKeyedSubscript:@"aliroGroupResolvingKeys"];

          if (v63)
          {
            uint64_t v64 = [v81 objectForKeyedSubscript:@"aliroGroupResolvingKeys"];
            [v38 setObject:v64 forKeyedSubscript:@"aliroGroupResolvingKeys"];
          }
          id v65 = [v81 objectForKeyedSubscript:@"associatedReaderIdentifiers"];

          if (v65)
          {
            id v66 = [v81 objectForKeyedSubscript:@"associatedReaderIdentifiers"];
            [v38 setObject:v66 forKeyedSubscript:@"associatedReaderIdentifiers"];
          }
          [v18 addObject:v38];

          uint64_t v16 = v85 + 1;
          unsigned int v15 = v79;
        }
        while ((id)(v85 + 1) != v84);
        id v84 = [v79 countByEnumeratingWithState:&v91 objects:v107 count:16];
        if (!v84) {
          goto LABEL_59;
        }
      }
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v67 = NFLogGetLogger();
    if (v67)
    {
      __int16 v68 = (void (*)(uint64_t, const char *, ...))v67;
      NSErrorUserInfoKey v69 = object_getClass(a1);
      BOOL v70 = class_isMetaClass(v69);
      id v74 = object_getClassName(a1);
      __int16 v77 = sel_getName("_addKeysFromArray:forAid:expressInfo:supportsUWB:intoPassArray:");
      uint64_t v71 = 45;
      if (v70) {
        uint64_t v71 = 43;
      }
      v68(3, "%c[%{public}s %{public}s]:%i no applet for AID: %{public}@ - skip", v71, v74, v77, 284, v11);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    unsigned int v15 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      uint64_t v72 = object_getClass(v86);
      if (class_isMetaClass(v72)) {
        int v73 = 43;
      }
      else {
        int v73 = 45;
      }
      *(_DWORD *)long long buf = 67110146;
      *(_DWORD *)&uint8_t buf[4] = v73;
      __int16 v96 = 2082;
      int v97 = object_getClassName(v86);
      __int16 v98 = 2082;
      uint64_t v99 = sel_getName("_addKeysFromArray:forAid:expressInfo:supportsUWB:intoPassArray:");
      __int16 v100 = 1024;
      int v101 = 284;
      __int16 v102 = 2114;
      id v103 = v11;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i no applet for AID: %{public}@ - skip", buf, 0x2Cu);
    }
LABEL_59:
  }
}

void sub_10014CF74(uint64_t a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = [v6 objectForKeyedSubscript:@"keyIdentifiersUWB"];

  if (v7)
  {
    uint64_t v8 = *(void **)(a1 + 32);
    uint64_t v9 = [v6 objectForKeyedSubscript:@"keyIdentifiersUWB"];
    sub_10014C55C(v8, v9, v5, v6, 1u, *(void **)(a1 + 40));
  }
  id v10 = [v6 objectForKeyedSubscript:@"keyIdentifiers"];

  if (v10)
  {
    id v11 = [v6 objectForKeyedSubscript:@"keyIdentifiers"];
    id v12 = [v11 mutableCopy];

    uint64_t v13 = [v6 objectForKeyedSubscript:@"keyIdentifiersUWB"];

    if (v13)
    {
      uint32_t v14 = [v6 objectForKeyedSubscript:@"keyIdentifiersUWB"];
      [v12 removeObjectsInArray:v14];
    }
    sub_10014C55C(*(void **)(a1 + 32), v12, v5, v6, 0, *(void **)(a1 + 40));
  }
  unsigned int v15 = [v6 objectForKeyedSubscript:@"keyIdentifiersUWB"];
  if (v15)
  {
  }
  else
  {
    uint64_t v16 = [v6 objectForKeyedSubscript:@"keyIdentifiers"];

    if (!v16)
    {
      uint64_t v17 = objc_opt_new();
      id v18 = [v6 objectForKeyedSubscript:@"ExpressType"];
      [v17 setObject:v18 forKeyedSubscript:@"ExpressType"];

      [v17 setObject:v5 forKeyedSubscript:@"appletIdentifier"];
      [v17 setObject:&__kCFBooleanTrue forKeyedSubscript:@"expressEnabled"];
      uint64_t v19 = arc4random();
      unint64_t v47 = arc4random() | (unint64_t)(v19 << 32);
      id v20 = [objc_alloc((Class)NSData) initWithBytes:&v47 length:8];
      uint64_t v21 = [v20 NF_asHexString];
      [v17 setObject:v21 forKeyedSubscript:@"passUniqueID"];

      uint64_t v22 = [v6 objectForKeyedSubscript:@"inSessionOnly"];

      if (v22)
      {
        int v23 = [v6 objectForKeyedSubscript:@"inSessionOnly"];
        [v17 setObject:v23 forKeyedSubscript:@"inSessionOnly"];
      }
      int v24 = [v6 objectForKeyedSubscript:@"ECP2Info"];

      if (v24)
      {
        int v25 = [v6 objectForKeyedSubscript:@"ECP2Info"];
        [v17 setObject:v25 forKeyedSubscript:@"ECP2Info"];
      }
      id v26 = [*(id *)(a1 + 32) getSecureElementWrapperAndSetRouting];
      uint64_t v27 = sub_1002473C8(v26, v5);

      if (v27)
      {
        int v28 = [v27 moduleIdentifier];
        [v17 setObject:v28 forKeyedSubscript:@"moduleIdentifier"];

        __int16 v29 = +[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:", [v27 groupActivationStyle]);
        [v17 setObject:v29 forKeyedSubscript:@"groupActivationStyle"];

        id v30 = [v27 groupHeadID];

        if (v30)
        {
          __int16 v31 = [v27 groupHeadID];
          [v17 setObject:v31 forKeyedSubscript:@"groupHead"];
        }
        uint64_t v32 = [v27 groupMemberIDs];
        id v33 = [v32 count];

        if (v33)
        {
          int v34 = [v27 groupMemberIDs];
          [v17 setObject:v34 forKeyedSubscript:@"groupMembers"];
        }
        [*(id *)(a1 + 40) addObject:v17];
      }
      else
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          unint64_t v36 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(*(id *)(a1 + 32));
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(*(id *)(a1 + 32));
          Name = sel_getName(*(SEL *)(a1 + 48));
          uint64_t v39 = 45;
          if (isMetaClass) {
            uint64_t v39 = 43;
          }
          v36(3, "%c[%{public}s %{public}s]:%i no applet for AID: %{public}@ - skip", v39, ClassName, Name, 372, v5, v47);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        long long v40 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
        {
          id v41 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v41)) {
            int v42 = 43;
          }
          else {
            int v42 = 45;
          }
          id v43 = object_getClassName(*(id *)(a1 + 32));
          uint64_t v44 = sel_getName(*(SEL *)(a1 + 48));
          *(_DWORD *)long long buf = 67110146;
          int v49 = v42;
          __int16 v50 = 2082;
          int v51 = v43;
          __int16 v52 = 2082;
          int v53 = v44;
          __int16 v54 = 1024;
          int v55 = 372;
          __int16 v56 = 2114;
          id v57 = v5;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i no applet for AID: %{public}@ - skip", buf, 0x2Cu);
        }
      }
    }
  }
}

void sub_10014E108(uint64_t a1)
{
}

void sub_10014E110(uint64_t a1, void *a2, void *a3)
{
  id v8 = a2;
  id v5 = a3;
  if ([v5 count])
  {
    id v6 = sub_1002473C8(*(void **)(a1 + 32), v8);
    id v7 = [*(id *)(a1 + 40) disableExpressForKeys:v5 onApplet:v6];
    if (v7) {
      objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), v7);
    }
  }
}

void sub_10014F400(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43)
{
}

void sub_100150370(uint64_t a1)
{
  *(unsigned char *)(*(void *)(a1 + 32) + 168) = 1;
  uint64_t v2 = NFSharedSignpostLog();
  if (os_signpost_enabled(v2))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v2, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+handleReaderBurnoutTimer", (const char *)&unk_100286819, buf, 2u);
  }

  uint64_t v3 = +[_NFHardwareManager sharedHardwareManager];
  unsigned __int8 v4 = +[NFRoutingConfig embeddedWiredMode];
  uint64_t v5 = [v3 setRoutingConfig:v4];

  if (v5)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      int v23 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v27 = 45;
      if (isMetaClass) {
        uint64_t v27 = 43;
      }
      v23(3, "%c[%{public}s %{public}s]:%i Failed to reset routing. Critical - exiting", v27, ClassName, Name, 127);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v28 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      __int16 v29 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v29)) {
        int v30 = 43;
      }
      else {
        int v30 = 45;
      }
      __int16 v31 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v32 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)long long buf = 67109890;
      int v35 = v30;
      __int16 v36 = 2082;
      id v37 = v31;
      __int16 v38 = 2082;
      uint64_t v39 = v32;
      __int16 v40 = 1024;
      int v41 = 127;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to reset routing. Critical - exiting", buf, 0x22u);
    }

    sub_100211BA0(*(void **)(*(void *)(a1 + 32) + 192));
    exit(1);
  }
  id v6 = [*(id *)(a1 + 32) remoteObject];
  [v6 didReceiveThermalIndication:1];

  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 200));
  sub_1001B03F0((uint64_t)WeakRetained, *(void **)(a1 + 32));

  uint64_t v8 = NFLogGetLogger();
  if (v8)
  {
    uint64_t v9 = (void (*)(uint64_t, const char *, ...))v8;
    id v10 = object_getClass(*(id *)(a1 + 32));
    BOOL v11 = class_isMetaClass(v10);
    id v12 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v13 = sel_getName(*(SEL *)(a1 + 40));
    uint32_t v14 = [*(id *)(a1 + 32) clientName];
    uint64_t v15 = 45;
    if (v11) {
      uint64_t v15 = 43;
    }
    v9(6, "%c[%{public}s %{public}s]:%i NFC Reader mode terminated: %@", v15, v12, v13, 134, v14);
  }
  uint64_t v16 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v17 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v17)) {
      int v18 = 43;
    }
    else {
      int v18 = 45;
    }
    uint64_t v19 = object_getClassName(*(id *)(a1 + 32));
    id v20 = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v21 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)long long buf = 67110146;
    int v35 = v18;
    __int16 v36 = 2082;
    id v37 = v19;
    __int16 v38 = 2082;
    uint64_t v39 = v20;
    __int16 v40 = 1024;
    int v41 = 134;
    __int16 v42 = 2112;
    id v43 = v21;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NFC Reader mode terminated: %@", buf, 0x2Cu);
  }
  *(unsigned char *)(*(void *)(a1 + 32) + 169) = 0;
}

void sub_1001511CC(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v7 = 45;
    if (isMetaClass) {
      uint64_t v7 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i ", v7, ClassName, Name, 192);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v8 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v9)) {
      int v10 = 43;
    }
    else {
      int v10 = 45;
    }
    BOOL v11 = object_getClassName(*(id *)(a1 + 32));
    id v12 = sel_getName(*(SEL *)(a1 + 56));
    *(_DWORD *)long long buf = 67109890;
    int v53 = v10;
    __int16 v54 = 2082;
    int v55 = v11;
    __int16 v56 = 2082;
    id v57 = v12;
    __int16 v58 = 1024;
    int v59 = 192;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    id v33 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
    id v34 = sub_100245608(v33);

    __int16 v29 = [*(id *)(a1 + 32) selectApplets:*(void *)(a1 + 40)];
    if (v29)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v35 = NFLogGetLogger();
      if (v35)
      {
        __int16 v36 = (void (*)(uint64_t, const char *, ...))v35;
        id v37 = object_getClass(*(id *)(a1 + 32));
        BOOL v38 = class_isMetaClass(v37);
        uint64_t v39 = object_getClassName(*(id *)(a1 + 32));
        int v49 = sel_getName(*(SEL *)(a1 + 56));
        uint64_t v40 = 45;
        if (v38) {
          uint64_t v40 = 43;
        }
        v36(3, "%c[%{public}s %{public}s]:%i Failed to select applets", v40, v39, v49, 199);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v41 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      {
        __int16 v42 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v42)) {
          int v43 = 43;
        }
        else {
          int v43 = 45;
        }
        uint64_t v44 = object_getClassName(*(id *)(a1 + 32));
        __int16 v45 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)long long buf = 67109890;
        int v53 = v43;
        __int16 v54 = 2082;
        int v55 = v44;
        __int16 v56 = 2082;
        id v57 = v45;
        __int16 v58 = 1024;
        int v59 = 199;
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select applets", buf, 0x22u);
      }
    }
    else
    {
      uint64_t v46 = *(void *)(a1 + 32);
      id v47 = *(id *)(a1 + 40);
      int v41 = *(NSObject **)(v46 + 160);
      *(void *)(v46 + 160) = v47;
    }

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    goto LABEL_24;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v13 = NFLogGetLogger();
  if (v13)
  {
    uint32_t v14 = (void (*)(uint64_t, const char *, ...))v13;
    uint64_t v15 = object_getClass(*(id *)(a1 + 32));
    BOOL v16 = class_isMetaClass(v15);
    uint64_t v17 = object_getClassName(*(id *)(a1 + 32));
    int v18 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v19 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v20 = 45;
    if (v16) {
      uint64_t v20 = 43;
    }
    v14(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v20, v17, v18, 193, v19);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v21 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    uint64_t v22 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v22)) {
      int v23 = 43;
    }
    else {
      int v23 = 45;
    }
    int v24 = object_getClassName(*(id *)(a1 + 32));
    int v25 = sel_getName(*(SEL *)(a1 + 56));
    id v26 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v53 = v23;
    __int16 v54 = 2082;
    int v55 = v24;
    __int16 v56 = 2082;
    id v57 = v25;
    __int16 v58 = 1024;
    int v59 = 193;
    __int16 v60 = 2114;
    id v61 = v26;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v27 = *(void *)(a1 + 48);
  if (v27)
  {
    id v28 = objc_alloc((Class)NSError);
    __int16 v29 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v50 = NSLocalizedDescriptionKey;
    int v30 = +[NSString stringWithUTF8String:"Session not active"];
    int v51 = v30;
    __int16 v31 = +[NSDictionary dictionaryWithObjects:&v51 forKeys:&v50 count:1];
    id v32 = [v28 initWithDomain:v29 code:54 userInfo:v31];
    (*(void (**)(uint64_t, id))(v27 + 16))(v27, v32);

LABEL_24:
  }
}

void sub_1001517C8(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v7 = 45;
    if (isMetaClass) {
      uint64_t v7 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i ", v7, ClassName, Name, 211);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v8 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v9)) {
      int v10 = 43;
    }
    else {
      int v10 = 45;
    }
    BOOL v11 = object_getClassName(*(id *)(a1 + 32));
    id v12 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)long long buf = 67109890;
    unsigned int v61 = v10;
    __int16 v62 = 2082;
    NSErrorUserInfoKey v63 = v11;
    __int16 v64 = 2082;
    id v65 = v12;
    __int16 v66 = 1024;
    int v67 = 211;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    __int16 v36 = *(void **)(*(void *)(a1 + 32) + 160);
    if (v36 && [v36 count])
    {
      if (*(unsigned char *)(*(void *)(a1 + 32) + 169))
      {
        __int16 v29 = 0;
      }
      else
      {
        int v49 = +[_NFHardwareManager sharedHardwareManager];
        NSErrorUserInfoKey v50 = +[NFRoutingConfig secureElementAsReaderMode];
        __int16 v29 = [v49 setRoutingConfig:v50];

        id WeakRetained = NFSharedSignpostLog();
        BOOL v52 = os_signpost_enabled(WeakRetained);
        if (v29)
        {
          if (v52)
          {
            unsigned int v53 = [v29 code];
            *(_DWORD *)long long buf = 67109120;
            unsigned int v61 = v53;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, WeakRetained, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+se_polling", "begin, error.code: %d", buf, 8u);
          }
        }
        else
        {
          if (v52)
          {
            *(_WORD *)long long buf = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, WeakRetained, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+se_polling", "begin", buf, 2u);
          }

          *(unsigned char *)(*(void *)(a1 + 32) + 169) = 1;
          id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 200));
          sub_1001B0E88((uint64_t)WeakRetained, *(void **)(a1 + 32));
        }
      }
      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
      goto LABEL_25;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v37 = NFLogGetLogger();
    if (v37)
    {
      BOOL v38 = (void (*)(uint64_t, const char *, ...))v37;
      uint64_t v39 = object_getClass(*(id *)(a1 + 32));
      BOOL v40 = class_isMetaClass(v39);
      int v41 = object_getClassName(*(id *)(a1 + 32));
      int v55 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v42 = 45;
      if (v40) {
        uint64_t v42 = 43;
      }
      v38(3, "%c[%{public}s %{public}s]:%i Invalid applets", v42, v41, v55, 217);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v43 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
    {
      uint64_t v44 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v44)) {
        int v45 = 43;
      }
      else {
        int v45 = 45;
      }
      uint64_t v46 = object_getClassName(*(id *)(a1 + 32));
      id v47 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)long long buf = 67109890;
      unsigned int v61 = v45;
      __int16 v62 = 2082;
      NSErrorUserInfoKey v63 = v46;
      __int16 v64 = 2082;
      id v65 = v47;
      __int16 v66 = 1024;
      int v67 = 217;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid applets", buf, 0x22u);
    }

    uint64_t v27 = *(void *)(a1 + 40);
    id v48 = objc_alloc((Class)NSError);
    __int16 v29 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v56 = NSLocalizedDescriptionKey;
    int v30 = +[NSString stringWithUTF8String:"Invalid Parameter"];
    id v57 = v30;
    __int16 v31 = +[NSDictionary dictionaryWithObjects:&v57 forKeys:&v56 count:1];
    id v32 = v48;
    id v33 = v29;
    uint64_t v34 = 10;
LABEL_24:
    id v35 = [v32 initWithDomain:v33 code:v34 userInfo:v31];
    (*(void (**)(uint64_t, id))(v27 + 16))(v27, v35);

LABEL_25:
    return;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v13 = NFLogGetLogger();
  if (v13)
  {
    uint32_t v14 = (void (*)(uint64_t, const char *, ...))v13;
    uint64_t v15 = object_getClass(*(id *)(a1 + 32));
    BOOL v16 = class_isMetaClass(v15);
    uint64_t v17 = object_getClassName(*(id *)(a1 + 32));
    int v18 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v19 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v20 = 45;
    if (v16) {
      uint64_t v20 = 43;
    }
    v14(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v20, v17, v18, 212, v19);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v21 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    uint64_t v22 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v22)) {
      int v23 = 43;
    }
    else {
      int v23 = 45;
    }
    int v24 = object_getClassName(*(id *)(a1 + 32));
    int v25 = sel_getName(*(SEL *)(a1 + 48));
    id v26 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    unsigned int v61 = v23;
    __int16 v62 = 2082;
    NSErrorUserInfoKey v63 = v24;
    __int16 v64 = 2082;
    id v65 = v25;
    __int16 v66 = 1024;
    int v67 = 212;
    __int16 v68 = 2114;
    NSErrorUserInfoKey v69 = v26;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v27 = *(void *)(a1 + 40);
  if (v27)
  {
    id v28 = objc_alloc((Class)NSError);
    __int16 v29 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v58 = NSLocalizedDescriptionKey;
    int v30 = +[NSString stringWithUTF8String:"Session not active"];
    int v59 = v30;
    __int16 v31 = +[NSDictionary dictionaryWithObjects:&v59 forKeys:&v58 count:1];
    id v32 = v28;
    id v33 = v29;
    uint64_t v34 = 54;
    goto LABEL_24;
  }
}

void sub_100151F5C(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v7 = 45;
    if (isMetaClass) {
      uint64_t v7 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i ", v7, ClassName, Name, 243);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v8 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v9)) {
      int v10 = 43;
    }
    else {
      int v10 = 45;
    }
    BOOL v11 = object_getClassName(*(id *)(a1 + 32));
    id v12 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)long long buf = 67109890;
    unsigned int v59 = v10;
    __int16 v60 = 2082;
    unsigned int v61 = v11;
    __int16 v62 = 2082;
    NSErrorUserInfoKey v63 = v12;
    __int16 v64 = 1024;
    int v65 = 243;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    if (!*(unsigned char *)(*(void *)(a1 + 32) + 169))
    {
      __int16 v29 = 0;
LABEL_44:
      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
      goto LABEL_24;
    }
    id v33 = +[_NFHardwareManager sharedHardwareManager];
    uint64_t v34 = +[NFRoutingConfig embeddedWiredMode];
    __int16 v29 = [v33 setRoutingConfig:v34];

    if (v29)
    {
      id v35 = NFSharedSignpostLog();
      if (!os_signpost_enabled(v35))
      {
LABEL_43:

        goto LABEL_44;
      }
      unsigned int v36 = [v29 code];
      *(_DWORD *)long long buf = 67109120;
      unsigned int v59 = v36;
      uint64_t v37 = "end, error.code: %d";
      BOOL v38 = v35;
      uint32_t v39 = 8;
    }
    else
    {
      *(unsigned char *)(*(void *)(a1 + 32) + 169) = 0;
      id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 200));
      sub_1001B03F0((uint64_t)WeakRetained, *(void **)(a1 + 32));

      uint64_t v41 = NFLogGetLogger();
      if (v41)
      {
        uint64_t v42 = (void (*)(uint64_t, const char *, ...))v41;
        int v43 = object_getClass(*(id *)(a1 + 32));
        BOOL v44 = class_isMetaClass(v43);
        int v45 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v46 = sel_getName(*(SEL *)(a1 + 48));
        id v47 = [*(id *)(a1 + 32) clientName];
        uint64_t v48 = 45;
        if (v44) {
          uint64_t v48 = 43;
        }
        v42(6, "%c[%{public}s %{public}s]:%i NFC Reader mode terminated: %@", v48, v45, v46, 251, v47);
      }
      int v49 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        NSErrorUserInfoKey v50 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v50)) {
          int v51 = 43;
        }
        else {
          int v51 = 45;
        }
        BOOL v52 = object_getClassName(*(id *)(a1 + 32));
        unsigned int v53 = sel_getName(*(SEL *)(a1 + 48));
        __int16 v54 = [*(id *)(a1 + 32) clientName];
        *(_DWORD *)long long buf = 67110146;
        unsigned int v59 = v51;
        __int16 v60 = 2082;
        unsigned int v61 = v52;
        __int16 v62 = 2082;
        NSErrorUserInfoKey v63 = v53;
        __int16 v64 = 1024;
        int v65 = 251;
        __int16 v66 = 2112;
        int v67 = v54;
        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NFC Reader mode terminated: %@", buf, 0x2Cu);
      }
      id v35 = NFSharedSignpostLog();
      if (!os_signpost_enabled(v35)) {
        goto LABEL_43;
      }
      *(_WORD *)long long buf = 0;
      uint64_t v37 = "end";
      BOOL v38 = v35;
      uint32_t v39 = 2;
    }
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v38, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+se_polling", v37, buf, v39);
    goto LABEL_43;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v13 = NFLogGetLogger();
  if (v13)
  {
    uint32_t v14 = (void (*)(uint64_t, const char *, ...))v13;
    uint64_t v15 = object_getClass(*(id *)(a1 + 32));
    BOOL v16 = class_isMetaClass(v15);
    uint64_t v17 = object_getClassName(*(id *)(a1 + 32));
    int v18 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v19 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v20 = 45;
    if (v16) {
      uint64_t v20 = 43;
    }
    v14(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v20, v17, v18, 244, v19);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v21 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    uint64_t v22 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v22)) {
      int v23 = 43;
    }
    else {
      int v23 = 45;
    }
    int v24 = object_getClassName(*(id *)(a1 + 32));
    int v25 = sel_getName(*(SEL *)(a1 + 48));
    id v26 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    unsigned int v59 = v23;
    __int16 v60 = 2082;
    unsigned int v61 = v24;
    __int16 v62 = 2082;
    NSErrorUserInfoKey v63 = v25;
    __int16 v64 = 1024;
    int v65 = 244;
    __int16 v66 = 2114;
    int v67 = v26;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v27 = *(void *)(a1 + 40);
  if (v27)
  {
    id v28 = objc_alloc((Class)NSError);
    __int16 v29 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v56 = NSLocalizedDescriptionKey;
    int v30 = +[NSString stringWithUTF8String:"Session not active"];
    id v57 = v30;
    __int16 v31 = +[NSDictionary dictionaryWithObjects:&v57 forKeys:&v56 count:1];
    id v32 = [v28 initWithDomain:v29 code:54 userInfo:v31];
    (*(void (**)(uint64_t, id))(v27 + 16))(v27, v32);

LABEL_24:
  }
}

void sub_1001526B0(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v7 = 45;
    if (isMetaClass) {
      uint64_t v7 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i ", v7, ClassName, Name, 266);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v8 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v9)) {
      int v10 = 43;
    }
    else {
      int v10 = 45;
    }
    BOOL v11 = object_getClassName(*(id *)(a1 + 32));
    id v12 = sel_getName(*(SEL *)(a1 + 56));
    *(_DWORD *)long long buf = 67109890;
    int v43 = v10;
    __int16 v44 = 2082;
    int v45 = v11;
    __int16 v46 = 2082;
    id v47 = v12;
    __int16 v48 = 1024;
    int v49 = 266;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    id v33 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
    uint64_t v34 = *(void *)(a1 + 40);
    id v39 = 0;
    int v30 = [v33 transceiveData:v34 toOS:0 error:&v39];
    id v29 = v39;

    __int16 v31 = +[NFResponseAPDU responseWithData:v30];
    if ([v31 status] == 25392)
    {
      id v35 = +[_NFHardwareManager sharedHardwareManager];
      v38[0] = _NSConcreteStackBlock;
      v38[1] = 3221225472;
      v38[2] = sub_100152B58;
      v38[3] = &unk_100305320;
      uint64_t v36 = *(void *)(a1 + 56);
      void v38[4] = *(void *)(a1 + 32);
      v38[5] = v36;
      sub_1001038A0(v35, v38);
    }
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    goto LABEL_24;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v13 = NFLogGetLogger();
  if (v13)
  {
    uint32_t v14 = (void (*)(uint64_t, const char *, ...))v13;
    uint64_t v15 = object_getClass(*(id *)(a1 + 32));
    BOOL v16 = class_isMetaClass(v15);
    uint64_t v17 = object_getClassName(*(id *)(a1 + 32));
    int v18 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v19 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v20 = 45;
    if (v16) {
      uint64_t v20 = 43;
    }
    v14(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v20, v17, v18, 267, v19);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v21 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    uint64_t v22 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v22)) {
      int v23 = 43;
    }
    else {
      int v23 = 45;
    }
    int v24 = object_getClassName(*(id *)(a1 + 32));
    int v25 = sel_getName(*(SEL *)(a1 + 56));
    id v26 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v43 = v23;
    __int16 v44 = 2082;
    int v45 = v24;
    __int16 v46 = 2082;
    id v47 = v25;
    __int16 v48 = 1024;
    int v49 = 267;
    __int16 v50 = 2114;
    int v51 = v26;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v27 = *(void *)(a1 + 48);
  if (v27)
  {
    id v28 = objc_alloc((Class)NSError);
    id v29 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v40 = NSLocalizedDescriptionKey;
    int v30 = +[NSString stringWithUTF8String:"Session not active"];
    uint64_t v41 = v30;
    __int16 v31 = +[NSDictionary dictionaryWithObjects:&v41 forKeys:&v40 count:1];
    id v32 = [v28 initWithDomain:v29 code:54 userInfo:v31];
    (*(void (**)(uint64_t, void, id))(v27 + 16))(v27, 0, v32);

LABEL_24:
  }
}

void sub_100152B58(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  if (!a5)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      int v10 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v13 = 45;
      if (isMetaClass) {
        uint64_t v13 = 43;
      }
      v10(6, "%c[%{public}s %{public}s]:%i SERmRunning=%d, HostRMRunning=%d, remainingTime=%d", v13, ClassName, Name, 277, a2, a3, a4);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint32_t v14 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v15 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v15)) {
        int v16 = 43;
      }
      else {
        int v16 = 45;
      }
      uint64_t v17 = object_getClassName(*(id *)(a1 + 32));
      int v18 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)long long buf = 67110658;
      int v22 = v16;
      __int16 v23 = 2082;
      int v24 = v17;
      __int16 v25 = 2082;
      id v26 = v18;
      __int16 v27 = 1024;
      int v28 = 277;
      __int16 v29 = 1024;
      unsigned int v30 = a2;
      __int16 v31 = 1024;
      unsigned int v32 = a3;
      __int16 v33 = 1024;
      int v34 = a4;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i SERmRunning=%d, HostRMRunning=%d, remainingTime=%d", buf, 0x34u);
    }
  }
}

void sub_100152E0C(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v7 = 45;
    if (isMetaClass) {
      uint64_t v7 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i ", v7, ClassName, Name, 289);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v8 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v9)) {
      int v10 = 43;
    }
    else {
      int v10 = 45;
    }
    BOOL v11 = object_getClassName(*(id *)(a1 + 32));
    id v12 = sel_getName(*(SEL *)(a1 + 56));
    *(_DWORD *)long long buf = 67109890;
    unsigned int v131 = v10;
    __int16 v132 = 2082;
    int v133 = v11;
    __int16 v134 = 2082;
    int v135 = v12;
    __int16 v136 = 1024;
    int v137 = 289;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    uint64_t v36 = +[NSUserDefaults standardUserDefaults];
    id v37 = [v36 integerForKey:@"SEReaderPollingDuration"];

    if (v37)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v38 = NFLogGetLogger();
      if (v38)
      {
        id v39 = (void (*)(uint64_t, const char *, ...))v38;
        NSErrorUserInfoKey v40 = object_getClass(*(id *)(a1 + 32));
        BOOL v41 = class_isMetaClass(v40);
        uint64_t v42 = object_getClassName(*(id *)(a1 + 32));
        BOOL v122 = sel_getName(*(SEL *)(a1 + 56));
        uint64_t v43 = 45;
        if (v41) {
          uint64_t v43 = 43;
        }
        v39(6, "%c[%{public}s %{public}s]:%i Using Polling override: %u", v43, v42, v122, 309, v37);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v44 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
      {
        int v45 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v45)) {
          int v46 = 43;
        }
        else {
          int v46 = 45;
        }
        id v47 = object_getClassName(*(id *)(a1 + 32));
        __int16 v48 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)long long buf = 67110146;
        unsigned int v131 = v46;
        __int16 v132 = 2082;
        int v133 = v47;
        __int16 v134 = 2082;
        int v135 = v48;
        __int16 v136 = 1024;
        int v137 = 309;
        __int16 v138 = 1024;
        LODWORD(v139) = v37;
        _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Using Polling override: %u", buf, 0x28u);
      }
    }
    else
    {
      LODWORD(v37) = 20;
    }
    int v49 = +[_NFHardwareManager sharedHardwareManager];
    unsigned __int8 v50 = [v49 configureECPPolling:*(void *)(a1 + 40)];

    if (v50)
    {
      *(unsigned char *)(*(void *)(a1 + 32) + 170) = [*(id *)(a1 + 40) length] != 0;
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v51 = NFLogGetLogger();
      if (v51)
      {
        BOOL v52 = (void (*)(uint64_t, const char *, ...))v51;
        unsigned int v53 = object_getClass(*(id *)(a1 + 32));
        BOOL v54 = class_isMetaClass(v53);
        int v55 = object_getClassName(*(id *)(a1 + 32));
        NSErrorUserInfoKey v56 = sel_getName(*(SEL *)(a1 + 56));
        if (*(unsigned char *)(*(void *)(a1 + 32) + 170)) {
          id v57 = "VAS ECP set";
        }
        else {
          id v57 = "VAS ECP not set";
        }
        uint64_t v58 = 45;
        if (v54) {
          uint64_t v58 = 43;
        }
        v52(6, "%c[%{public}s %{public}s]:%i %s", v58, v55, v56, 324, v57);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      unsigned int v59 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v59, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v60 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v60)) {
          int v61 = 43;
        }
        else {
          int v61 = 45;
        }
        __int16 v62 = object_getClassName(*(id *)(a1 + 32));
        NSErrorUserInfoKey v63 = sel_getName(*(SEL *)(a1 + 56));
        if (*(unsigned char *)(*(void *)(a1 + 32) + 170)) {
          __int16 v64 = "VAS ECP set";
        }
        else {
          __int16 v64 = "VAS ECP not set";
        }
        *(_DWORD *)long long buf = 67110146;
        unsigned int v131 = v61;
        __int16 v132 = 2082;
        int v133 = v62;
        __int16 v134 = 2082;
        int v135 = v63;
        __int16 v136 = 1024;
        int v137 = 324;
        __int16 v138 = 2080;
        v139 = v64;
        _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %s", buf, 0x2Cu);
      }

      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v65 = NFLogGetLogger();
      if (v65)
      {
        __int16 v66 = (void (*)(uint64_t, const char *, ...))v65;
        int v67 = object_getClass(*(id *)(a1 + 32));
        BOOL v68 = class_isMetaClass(v67);
        NSErrorUserInfoKey v69 = object_getClassName(*(id *)(a1 + 32));
        int v123 = sel_getName(*(SEL *)(a1 + 56));
        uint64_t v70 = 45;
        if (v68) {
          uint64_t v70 = 43;
        }
        v66(6, "%c[%{public}s %{public}s]:%i SEtting routing for polling and wired with no FD", v70, v69, v123, 327);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v71 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v72 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v72)) {
          int v73 = 43;
        }
        else {
          int v73 = 45;
        }
        id v74 = object_getClassName(*(id *)(a1 + 32));
        int v75 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)long long buf = 67109890;
        unsigned int v131 = v73;
        __int16 v132 = 2082;
        int v133 = v74;
        __int16 v134 = 2082;
        int v135 = v75;
        __int16 v136 = 1024;
        int v137 = 327;
        _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i SEtting routing for polling and wired with no FD", buf, 0x22u);
      }

      LODWORD(v120) = v37;
      id v29 = [[NFRoutingConfig alloc] initPollingType:1 wantsSEReader:0 wantsExpress:0 cardEmulationType:0 hostMode:0 embeddedMode:1 fieldDetect:0 pollingDuration:v120 lpcdEcpFrame:*(void *)(a1 + 40)];
      [v29 setPollingMask:19 tagConfig:112];
      int v76 = +[_NFHardwareManager sharedHardwareManager];
      unsigned int v30 = [v76 setRoutingConfig:v29];

      __int16 v77 = NFSharedSignpostLog();
      BOOL v78 = os_signpost_enabled(v77);
      if (v30)
      {
        if (v78)
        {
          unsigned int v79 = [v30 code];
          *(_DWORD *)long long buf = 67109120;
          unsigned int v131 = v79;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v77, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+vas_polling", "begin, error.code=%d", buf, 8u);
        }

        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v80 = NFLogGetLogger();
        if (v80)
        {
          __int16 v81 = (void (*)(uint64_t, const char *, ...))v80;
          int v82 = object_getClass(*(id *)(a1 + 32));
          BOOL v83 = class_isMetaClass(v82);
          id v84 = object_getClassName(*(id *)(a1 + 32));
          id v124 = sel_getName(*(SEL *)(a1 + 56));
          uint64_t v85 = 45;
          if (v83) {
            uint64_t v85 = 43;
          }
          v81(3, "%c[%{public}s %{public}s]:%i Failed to start polling", v85, v84, v124, 353);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v86 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
        {
          long long v87 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v87)) {
            int v88 = 43;
          }
          else {
            int v88 = 45;
          }
          long long v89 = object_getClassName(*(id *)(a1 + 32));
          long long v90 = sel_getName(*(SEL *)(a1 + 56));
          *(_DWORD *)long long buf = 67109890;
          unsigned int v131 = v88;
          __int16 v132 = 2082;
          int v133 = v89;
          __int16 v134 = 2082;
          int v135 = v90;
          __int16 v136 = 1024;
          int v137 = 353;
          _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to start polling", buf, 0x22u);
        }

        (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
      }
      else
      {
        if (v78)
        {
          *(_WORD *)long long buf = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v77, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+vas_polling", "begin", buf, 2u);
        }

        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v92 = NFLogGetLogger();
        if (v92)
        {
          long long v93 = (void (*)(uint64_t, const char *, ...))v92;
          long long v94 = object_getClass(*(id *)(a1 + 32));
          BOOL v95 = class_isMetaClass(v94);
          __int16 v96 = object_getClassName(*(id *)(a1 + 32));
          uint64_t v125 = sel_getName(*(SEL *)(a1 + 56));
          uint64_t v97 = 45;
          if (v95) {
            uint64_t v97 = 43;
          }
          v93(6, "%c[%{public}s %{public}s]:%i VAS Reader started", v97, v96, v125, 344);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        __int16 v98 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v99 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v99)) {
            int v100 = 43;
          }
          else {
            int v100 = 45;
          }
          int v101 = object_getClassName(*(id *)(a1 + 32));
          __int16 v102 = sel_getName(*(SEL *)(a1 + 56));
          *(_DWORD *)long long buf = 67109890;
          unsigned int v131 = v100;
          __int16 v132 = 2082;
          int v133 = v101;
          __int16 v134 = 2082;
          int v135 = v102;
          __int16 v136 = 1024;
          int v137 = 344;
          _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i VAS Reader started", buf, 0x22u);
        }

        uint64_t v103 = NFLogGetLogger();
        if (v103)
        {
          __int16 v104 = (void (*)(uint64_t, const char *, ...))v103;
          BOOL v105 = object_getClass(*(id *)(a1 + 32));
          BOOL v106 = class_isMetaClass(v105);
          uint64_t v107 = object_getClassName(*(id *)(a1 + 32));
          int v108 = sel_getName(*(SEL *)(a1 + 56));
          uint64_t v109 = [*(id *)(a1 + 32) clientName];
          uint64_t v110 = 45;
          if (v106) {
            uint64_t v110 = 43;
          }
          v104(6, "%c[%{public}s %{public}s]:%i NFC Reader mode activated: %@", v110, v107, v108, 345, v109);
        }
        uint64_t v111 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
        {
          int v112 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v112)) {
            int v113 = 43;
          }
          else {
            int v113 = 45;
          }
          int v114 = object_getClassName(*(id *)(a1 + 32));
          uint64_t v115 = sel_getName(*(SEL *)(a1 + 56));
          long long v116 = [*(id *)(a1 + 32) clientName];
          *(_DWORD *)long long buf = 67110146;
          unsigned int v131 = v113;
          __int16 v132 = 2082;
          int v133 = v114;
          __int16 v134 = 2082;
          int v135 = v115;
          __int16 v136 = 1024;
          int v137 = 345;
          __int16 v138 = 2112;
          v139 = v116;
          _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NFC Reader mode activated: %@", buf, 0x2Cu);
        }
        id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 200));
        sub_1001B0E88((uint64_t)WeakRetained, *(void **)(a1 + 32));

        uint64_t v118 = *(void *)(a1 + 32);
        uint64_t v119 = *(void **)(v118 + 184);
        *(void *)(v118 + 184) = 0;

        (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
        unsigned int v30 = 0;
      }
      goto LABEL_25;
    }
    *(unsigned char *)(*(void *)(a1 + 32) + 170) = 0;
    uint64_t v27 = *(void *)(a1 + 48);
    id v91 = objc_alloc((Class)NSError);
    id v29 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v126 = NSLocalizedDescriptionKey;
    unsigned int v30 = +[NSString stringWithUTF8String:"Stack Error"];
    uint64_t v127 = v30;
    __int16 v31 = +[NSDictionary dictionaryWithObjects:&v127 forKeys:&v126 count:1];
    unsigned int v32 = v91;
    id v33 = v29;
    uint64_t v34 = 15;
LABEL_24:
    id v35 = [v32 initWithDomain:v33 code:v34 userInfo:v31];
    (*(void (**)(uint64_t, id))(v27 + 16))(v27, v35);

LABEL_25:
    return;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v13 = NFLogGetLogger();
  if (v13)
  {
    uint32_t v14 = (void (*)(uint64_t, const char *, ...))v13;
    uint64_t v15 = object_getClass(*(id *)(a1 + 32));
    BOOL v16 = class_isMetaClass(v15);
    uint64_t v17 = object_getClassName(*(id *)(a1 + 32));
    int v18 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v19 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v20 = 45;
    if (v16) {
      uint64_t v20 = 43;
    }
    v14(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v20, v17, v18, 290, v19);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v21 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    int v22 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v22)) {
      int v23 = 43;
    }
    else {
      int v23 = 45;
    }
    int v24 = object_getClassName(*(id *)(a1 + 32));
    __int16 v25 = sel_getName(*(SEL *)(a1 + 56));
    id v26 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    unsigned int v131 = v23;
    __int16 v132 = 2082;
    int v133 = v24;
    __int16 v134 = 2082;
    int v135 = v25;
    __int16 v136 = 1024;
    int v137 = 290;
    __int16 v138 = 2114;
    v139 = v26;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v27 = *(void *)(a1 + 48);
  if (v27)
  {
    id v28 = objc_alloc((Class)NSError);
    id v29 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v128 = NSLocalizedDescriptionKey;
    unsigned int v30 = +[NSString stringWithUTF8String:"Session not active"];
    long long v129 = v30;
    __int16 v31 = +[NSDictionary dictionaryWithObjects:&v129 forKeys:&v128 count:1];
    unsigned int v32 = v28;
    id v33 = v29;
    uint64_t v34 = 54;
    goto LABEL_24;
  }
}

void sub_100153C20(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v7 = 45;
    if (isMetaClass) {
      uint64_t v7 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i ", v7, ClassName, Name, 365);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v8 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v9)) {
      int v10 = 43;
    }
    else {
      int v10 = 45;
    }
    BOOL v11 = object_getClassName(*(id *)(a1 + 32));
    id v12 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)long long buf = 67109890;
    unsigned int v69 = v10;
    __int16 v70 = 2082;
    uint64_t v71 = v11;
    __int16 v72 = 2082;
    int v73 = v12;
    __int16 v74 = 1024;
    int v75 = 365;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    uint64_t v33 = *(void *)(a1 + 32);
    uint64_t v34 = *(void **)(v33 + 184);
    *(void *)(v33 + 184) = 0;

    id v29 = +[NFRoutingConfig embeddedWiredMode];
    id v35 = +[_NFHardwareManager sharedHardwareManager];
    unsigned int v30 = [v35 setRoutingConfig:v29];

    uint64_t v36 = NFSharedSignpostLog();
    BOOL v37 = os_signpost_enabled(v36);
    if (v30)
    {
      if (v37)
      {
        unsigned int v38 = [v30 code];
        *(_DWORD *)long long buf = 67109120;
        unsigned int v69 = v38;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v36, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+vas_polling", "end, error.code: %d", buf, 8u);
      }

      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v39 = NFLogGetLogger();
      if (v39)
      {
        NSErrorUserInfoKey v40 = (void (*)(uint64_t, const char *, ...))v39;
        BOOL v41 = object_getClass(*(id *)(a1 + 32));
        BOOL v42 = class_isMetaClass(v41);
        uint64_t v43 = object_getClassName(*(id *)(a1 + 32));
        __int16 v64 = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v44 = 45;
        if (v42) {
          uint64_t v44 = 43;
        }
        v40(3, "%c[%{public}s %{public}s]:%i Failed to stop polling", v44, v43, v64, 381);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v45 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
      {
        int v46 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v46)) {
          int v47 = 43;
        }
        else {
          int v47 = 45;
        }
        __int16 v48 = object_getClassName(*(id *)(a1 + 32));
        int v49 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)long long buf = 67109890;
        unsigned int v69 = v47;
        __int16 v70 = 2082;
        uint64_t v71 = v48;
        __int16 v72 = 2082;
        int v73 = v49;
        __int16 v74 = 1024;
        int v75 = 381;
        _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to stop polling", buf, 0x22u);
      }

      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    }
    else
    {
      if (v37)
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v36, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+vas_polling", "end", buf, 2u);
      }

      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v50 = NFLogGetLogger();
      if (v50)
      {
        uint64_t v51 = (void (*)(uint64_t, const char *, ...))v50;
        BOOL v52 = object_getClass(*(id *)(a1 + 32));
        BOOL v53 = class_isMetaClass(v52);
        BOOL v54 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v65 = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v55 = 45;
        if (v53) {
          uint64_t v55 = 43;
        }
        v51(6, "%c[%{public}s %{public}s]:%i VAS Reader stopped", v55, v54, v65, 374);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      NSErrorUserInfoKey v56 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
      {
        id v57 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v57)) {
          int v58 = 43;
        }
        else {
          int v58 = 45;
        }
        unsigned int v59 = object_getClassName(*(id *)(a1 + 32));
        __int16 v60 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)long long buf = 67109890;
        unsigned int v69 = v58;
        __int16 v70 = 2082;
        uint64_t v71 = v59;
        __int16 v72 = 2082;
        int v73 = v60;
        __int16 v74 = 1024;
        int v75 = 374;
        _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i VAS Reader stopped", buf, 0x22u);
      }

      id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 200));
      sub_1001B03F0((uint64_t)WeakRetained, *(void **)(a1 + 32));

      __int16 v62 = +[_NFHardwareManager sharedHardwareManager];
      [v62 notifyReaderModeActivityEnd];

      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
      unsigned int v30 = 0;
    }
    goto LABEL_24;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v13 = NFLogGetLogger();
  if (v13)
  {
    uint32_t v14 = (void (*)(uint64_t, const char *, ...))v13;
    uint64_t v15 = object_getClass(*(id *)(a1 + 32));
    BOOL v16 = class_isMetaClass(v15);
    uint64_t v17 = object_getClassName(*(id *)(a1 + 32));
    int v18 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v19 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v20 = 45;
    if (v16) {
      uint64_t v20 = 43;
    }
    v14(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v20, v17, v18, 366, v19);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v21 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    int v22 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v22)) {
      int v23 = 43;
    }
    else {
      int v23 = 45;
    }
    int v24 = object_getClassName(*(id *)(a1 + 32));
    __int16 v25 = sel_getName(*(SEL *)(a1 + 48));
    id v26 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    unsigned int v69 = v23;
    __int16 v70 = 2082;
    uint64_t v71 = v24;
    __int16 v72 = 2082;
    int v73 = v25;
    __int16 v74 = 1024;
    int v75 = 366;
    __int16 v76 = 2114;
    __int16 v77 = v26;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v27 = *(void *)(a1 + 40);
  if (v27)
  {
    id v28 = objc_alloc((Class)NSError);
    id v29 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v66 = NSLocalizedDescriptionKey;
    unsigned int v30 = +[NSString stringWithUTF8String:"Session not active"];
    int v67 = v30;
    __int16 v31 = +[NSDictionary dictionaryWithObjects:&v67 forKeys:&v66 count:1];
    id v32 = [v28 initWithDomain:v29 code:54 userInfo:v31];
    (*(void (**)(uint64_t, id))(v27 + 16))(v27, v32);

LABEL_24:
  }
}

void sub_100154438(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v7 = 45;
    if (isMetaClass) {
      uint64_t v7 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i ", v7, ClassName, Name, 393);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v8 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v9)) {
      int v10 = 43;
    }
    else {
      int v10 = 45;
    }
    BOOL v11 = object_getClassName(*(id *)(a1 + 32));
    id v12 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)long long buf = 67109890;
    unsigned int v93 = v10;
    __int16 v94 = 2082;
    BOOL v95 = v11;
    __int16 v96 = 2082;
    uint64_t v97 = v12;
    __int16 v98 = 1024;
    int v99 = 393;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  uint64_t v13 = *(void **)(a1 + 32);
  if (!v13[22])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v36 = NFLogGetLogger();
    if (v36)
    {
      BOOL v37 = (void (*)(uint64_t, const char *, ...))v36;
      unsigned int v38 = object_getClass(*(id *)(a1 + 32));
      BOOL v39 = class_isMetaClass(v38);
      NSErrorUserInfoKey v40 = object_getClassName(*(id *)(a1 + 32));
      id v86 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v41 = 45;
      if (v39) {
        uint64_t v41 = 43;
      }
      v37(3, "%c[%{public}s %{public}s]:%i Tag not connected", v41, v40, v86, 395);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    BOOL v42 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
    {
      uint64_t v43 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v43)) {
        int v44 = 43;
      }
      else {
        int v44 = 45;
      }
      int v45 = object_getClassName(*(id *)(a1 + 32));
      int v46 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)long long buf = 67109890;
      unsigned int v93 = v44;
      __int16 v94 = 2082;
      BOOL v95 = v45;
      __int16 v96 = 2082;
      uint64_t v97 = v46;
      __int16 v98 = 1024;
      int v99 = 395;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Tag not connected", buf, 0x22u);
    }

    uint64_t v28 = *(void *)(a1 + 40);
    id v47 = objc_alloc((Class)NSError);
    id v30 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v102 = NSLocalizedDescriptionKey;
    uint64_t v31 = +[NSString stringWithUTF8String:"Tag Not Found"];
    uint64_t v103 = v31;
    id v32 = +[NSDictionary dictionaryWithObjects:&v103 forKeys:&v102 count:1];
    uint64_t v33 = v47;
    id v34 = v30;
    uint64_t v35 = 28;
    goto LABEL_35;
  }
  if ([v13 didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    if (!*(void *)(*(void *)(a1 + 32) + 184))
    {
      uint64_t v49 = objc_opt_new();
      uint64_t v50 = *(void *)(a1 + 32);
      uint64_t v51 = *(void **)(v50 + 184);
      *(void *)(v50 + 184) = v49;

      BOOL v52 = [*(id *)(a1 + 32) driverWrapper];
      sub_10009012C(*(void *)(*(void *)(a1 + 32) + 184), v52);

      sub_10009011C(*(void *)(*(void *)(a1 + 32) + 184), *(void **)(*(void *)(a1 + 32) + 176));
      uint64_t v53 = *(void *)(*(void *)(a1 + 32) + 184);
      if (v53) {
        *(void *)(v53 + 24) = 0x404E000000000000;
      }
    }
    BOOL v54 = NFSharedSignpostLog();
    if (os_signpost_enabled(v54))
    {
      *(_WORD *)long long buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v54, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+select_OSE", (const char *)&unk_100286819, buf, 2u);
    }

    uint64_t v55 = *(void *)(*(void *)(a1 + 32) + 184);
    v87.isa = 0;
    uint64_t v31 = sub_10008D77C(v55, &v87);
    NSErrorUserInfoKey v56 = v87.isa;
    if (v56)
    {
      id v57 = v56;
      id v58 = objc_alloc((Class)NSError);
      unsigned int v59 = +[NSString stringWithUTF8String:"nfcd"];
      id v60 = [(objc_class *)v57 code];
      v88[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[(objc_class *)v57 code] > 70) {
        uint64_t v61 = 71;
      }
      else {
        uint64_t v61 = (uint64_t)[(objc_class *)v57 code];
      }
      __int16 v62 = +[NSString stringWithUTF8String:off_1003050D8[v61]];
      v89[0] = v62;
      v89[1] = v57;
      v88[1] = NSUnderlyingErrorKey;
      v88[2] = @"Line";
      v89[2] = &off_10031C408;
      v88[3] = @"Method";
      id v63 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
      v89[3] = v63;
      v88[4] = NSDebugDescriptionErrorKey;
      id v64 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 413];
      v89[4] = v64;
      uint64_t v65 = +[NSDictionary dictionaryWithObjects:v89 forKeys:v88 count:5];
      id v30 = [v58 initWithDomain:v59 code:v60 userInfo:v65];

      NSErrorUserInfoKey v66 = NFSharedSignpostLog();
      if (os_signpost_enabled(v66))
      {
        unsigned int v67 = [v30 code];
        *(_DWORD *)long long buf = 67109120;
        unsigned int v93 = v67;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v66, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+select_OSE", "error.code: %d", buf, 8u);
      }

      if (v31) {
        goto LABEL_52;
      }
    }
    else
    {
      id v30 = 0;
      if (v31)
      {
LABEL_52:
        id v32 = objc_opt_new();
        id v68 = *(id *)(v31 + 16);
        id v69 = [v68 length];

        if (v69)
        {
          id v70 = *(id *)(v31 + 16);
          [v32 setObject:v70 forKeyedSubscript:@"AppLabel"];
        }
        id v71 = *(id *)(v31 + 24);
        id v72 = [v71 length];

        if (v72)
        {
          id v73 = *(id *)(v31 + 24);
          [v32 setObject:v73 forKeyedSubscript:@"AppVersion"];
        }
        id v74 = *(id *)(v31 + 32);
        id v75 = [v74 length];

        if (v75)
        {
          id v76 = *(id *)(v31 + 32);
          [v32 setObject:v76 forKeyedSubscript:@"Unpredictable"];
        }
        id v77 = [objc_alloc((Class)NSMutableData) initWithLength:1];
        char v78 = *(unsigned char *)(v31 + 8);
        id v79 = v77;
        *(unsigned char *)[v79 mutableBytes] = v78;
        [v32 setObject:v79 forKeyedSubscript:@"MobileCapabilities"];
        id v80 = [objc_alloc((Class)NSMutableData) initWithLength:2];
        char v81 = *(unsigned char *)(v31 + 11);
        id v82 = v80;
        *(unsigned char *)[v82 mutableBytes] = v81;
        char v83 = *(unsigned char *)(v31 + 10);
        id v84 = v82;
        *((unsigned char *)[v84 mutableBytes] + 1) = v83;
        [v32 setObject:v84 forKeyedSubscript:@"Status"];

        goto LABEL_59;
      }
    }
    id v32 = 0;
LABEL_59:
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    goto LABEL_36;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v14 = NFLogGetLogger();
  if (v14)
  {
    uint64_t v15 = (void (*)(uint64_t, const char *, ...))v14;
    BOOL v16 = object_getClass(*(id *)(a1 + 32));
    BOOL v17 = class_isMetaClass(v16);
    int v18 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v19 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v20 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v21 = 45;
    if (v17) {
      uint64_t v21 = 43;
    }
    v15(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v21, v18, v19, 400, v20);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v22 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    int v23 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v23)) {
      int v24 = 43;
    }
    else {
      int v24 = 45;
    }
    __int16 v25 = object_getClassName(*(id *)(a1 + 32));
    id v26 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v27 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    unsigned int v93 = v24;
    __int16 v94 = 2082;
    BOOL v95 = v25;
    __int16 v96 = 2082;
    uint64_t v97 = v26;
    __int16 v98 = 1024;
    int v99 = 400;
    __int16 v100 = 2114;
    int v101 = v27;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v28 = *(void *)(a1 + 40);
  if (v28)
  {
    id v29 = objc_alloc((Class)NSError);
    id v30 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v90 = NSLocalizedDescriptionKey;
    uint64_t v31 = +[NSString stringWithUTF8String:"Session not active"];
    uint64_t v91 = v31;
    id v32 = +[NSDictionary dictionaryWithObjects:&v91 forKeys:&v90 count:1];
    uint64_t v33 = v29;
    id v34 = v30;
    uint64_t v35 = 54;
LABEL_35:
    id v48 = [v33 initWithDomain:v34 code:v35 userInfo:v32];
    (*(void (**)(uint64_t, void, id))(v28 + 16))(v28, 0, v48);

LABEL_36:
  }
}

void sub_100154F1C(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v7 = 45;
    if (isMetaClass) {
      uint64_t v7 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i ", v7, ClassName, Name, 450);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v8 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v9)) {
      int v10 = 43;
    }
    else {
      int v10 = 45;
    }
    BOOL v11 = object_getClassName(*(id *)(a1 + 32));
    id v12 = sel_getName(*(SEL *)(a1 + 56));
    *(_DWORD *)long long buf = 67109890;
    unsigned int v133 = v10;
    __int16 v134 = 2082;
    int v135 = v11;
    __int16 v136 = 2082;
    int v137 = v12;
    __int16 v138 = 1024;
    int v139 = 450;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    if (!*(void *)(*(void *)(a1 + 32) + 176))
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v80 = NFLogGetLogger();
      if (v80)
      {
        char v81 = (void (*)(uint64_t, const char *, ...))v80;
        id v82 = object_getClass(*(id *)(a1 + 32));
        BOOL v83 = class_isMetaClass(v82);
        id v84 = object_getClassName(*(id *)(a1 + 32));
        int v114 = sel_getName(*(SEL *)(a1 + 56));
        uint64_t v85 = 45;
        if (v83) {
          uint64_t v85 = 43;
        }
        v81(3, "%c[%{public}s %{public}s]:%i Tag not connected", v85, v84, v114, 455);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v86 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
      {
        NSObject v87 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v87)) {
          int v88 = 43;
        }
        else {
          int v88 = 45;
        }
        long long v89 = object_getClassName(*(id *)(a1 + 32));
        NSErrorUserInfoKey v90 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)long long buf = 67109890;
        unsigned int v133 = v88;
        __int16 v134 = 2082;
        int v135 = v89;
        __int16 v136 = 2082;
        int v137 = v90;
        __int16 v138 = 1024;
        int v139 = 455;
        _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Tag not connected", buf, 0x22u);
      }

      uint64_t v27 = *(void *)(a1 + 48);
      id v91 = objc_alloc((Class)NSError);
      id v29 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v128 = NSLocalizedDescriptionKey;
      id v30 = +[NSString stringWithUTF8String:"Tag Not Found"];
      id v129 = v30;
      uint64_t v31 = +[NSDictionary dictionaryWithObjects:&v129 forKeys:&v128 count:1];
      id v32 = v91;
      id v33 = v29;
      uint64_t v34 = 28;
LABEL_24:
      id v35 = [v32 initWithDomain:v33 code:v34 userInfo:v31];
      (*(void (**)(uint64_t, id, void))(v27 + 16))(v27, v35, 0);

LABEL_25:
      goto LABEL_26;
    }
    long long v121 = 0u;
    long long v122 = 0u;
    long long v119 = 0u;
    long long v120 = 0u;
    id v29 = *(id *)(a1 + 40);
    id v36 = [v29 countByEnumeratingWithState:&v119 objects:v127 count:16];
    if (v36)
    {
      id v37 = v36;
      uint64_t v38 = *(void *)v120;
      while (2)
      {
        for (i = 0; i != v37; i = (char *)i + 1)
        {
          if (*(void *)v120 != v38) {
            objc_enumerationMutation(v29);
          }
          if (!+[NFVASRequest validateDictionary:*(void *)(*((void *)&v119 + 1) + 8 * i)])
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v65 = NFLogGetLogger();
            if (v65)
            {
              NSErrorUserInfoKey v66 = (void (*)(uint64_t, const char *, ...))v65;
              unsigned int v67 = object_getClass(*(id *)(a1 + 32));
              BOOL v68 = class_isMetaClass(v67);
              id v69 = object_getClassName(*(id *)(a1 + 32));
              int v113 = sel_getName(*(SEL *)(a1 + 56));
              uint64_t v70 = 45;
              if (v68) {
                uint64_t v70 = 43;
              }
              v66(3, "%c[%{public}s %{public}s]:%i Invalid parameter", v70, v69, v113, 462);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            id v71 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
            {
              id v72 = object_getClass(*(id *)(a1 + 32));
              if (class_isMetaClass(v72)) {
                int v73 = 43;
              }
              else {
                int v73 = 45;
              }
              id v74 = object_getClassName(*(id *)(a1 + 32));
              id v75 = sel_getName(*(SEL *)(a1 + 56));
              *(_DWORD *)long long buf = 67109890;
              unsigned int v133 = v73;
              __int16 v134 = 2082;
              int v135 = v74;
              __int16 v136 = 2082;
              int v137 = v75;
              __int16 v138 = 1024;
              int v139 = 462;
              _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid parameter", buf, 0x22u);
            }

            uint64_t v76 = *(void *)(a1 + 48);
            id v77 = objc_alloc((Class)NSError);
            id v30 = +[NSString stringWithUTF8String:"nfcd"];
            NSErrorUserInfoKey v125 = NSLocalizedDescriptionKey;
            uint64_t v31 = +[NSString stringWithUTF8String:"Invalid Parameter"];
            NSErrorUserInfoKey v126 = v31;
            char v78 = +[NSDictionary dictionaryWithObjects:&v126 forKeys:&v125 count:1];
            id v79 = [v77 initWithDomain:v30 code:10 userInfo:v78];
            (*(void (**)(uint64_t, id, void))(v76 + 16))(v76, v79, 0);

            goto LABEL_25;
          }
        }
        id v37 = [v29 countByEnumeratingWithState:&v119 objects:v127 count:16];
        if (v37) {
          continue;
        }
        break;
      }
    }

    if (!*(void *)(*(void *)(a1 + 32) + 184))
    {
      uint64_t v40 = objc_opt_new();
      uint64_t v41 = *(void *)(a1 + 32);
      BOOL v42 = *(void **)(v41 + 184);
      *(void *)(v41 + 184) = v40;

      uint64_t v43 = [*(id *)(a1 + 32) driverWrapper];
      sub_10009012C(*(void *)(*(void *)(a1 + 32) + 184), v43);

      sub_10009011C(*(void *)(*(void *)(a1 + 32) + 184), *(void **)(*(void *)(a1 + 32) + 176));
      uint64_t v44 = *(void *)(*(void *)(a1 + 32) + 184);
      if (v44) {
        *(void *)(v44 + 24) = 0x404E000000000000;
      }
    }
    if (*(unsigned char *)(a1 + 64))
    {
      int v45 = NFSharedSignpostLog();
      if (os_signpost_enabled(v45))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v45, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+select_OSE", (const char *)&unk_100286819, buf, 2u);
      }

      uint64_t v46 = *(void *)(*(void *)(a1 + 32) + 184);
      v118.isa = 0;
      sub_10008D77C(v46, &v118);
      id v30 = (id)objc_claimAutoreleasedReturnValue();
      id v47 = v118.isa;
      if (v47)
      {
        id v29 = v47;
        id v48 = NFSharedSignpostLog();
        if (os_signpost_enabled(v48))
        {
          unsigned int v49 = [v29 code];
          *(_DWORD *)long long buf = 67109120;
          unsigned int v133 = v49;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v48, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+select_OSE", "error.code: %d", buf, 8u);
        }

        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v50 = NFLogGetLogger();
        if (v50)
        {
          uint64_t v51 = (void (*)(uint64_t, const char *, ...))v50;
          BOOL v52 = object_getClass(*(id *)(a1 + 32));
          BOOL v53 = class_isMetaClass(v52);
          uint64_t v109 = object_getClassName(*(id *)(a1 + 32));
          int v112 = sel_getName(*(SEL *)(a1 + 56));
          uint64_t v54 = 45;
          if (v53) {
            uint64_t v54 = 43;
          }
          v51(3, "%c[%{public}s %{public}s]:%i error: %{public}@", v54, v109, v112, 481, v29);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v55 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v55, OS_LOG_TYPE_ERROR))
        {
          NSErrorUserInfoKey v56 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v56)) {
            int v57 = 43;
          }
          else {
            int v57 = 45;
          }
          id v58 = object_getClassName(*(id *)(a1 + 32));
          unsigned int v59 = sel_getName(*(SEL *)(a1 + 56));
          *(_DWORD *)long long buf = 67110146;
          unsigned int v133 = v57;
          __int16 v134 = 2082;
          int v135 = v58;
          __int16 v136 = 2082;
          int v137 = v59;
          __int16 v138 = 1024;
          int v139 = 481;
          __int16 v140 = 2114;
          id v141 = v29;
          _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i error: %{public}@", buf, 0x2Cu);
        }

        uint64_t v60 = *(void *)(a1 + 48);
        id v61 = objc_alloc((Class)NSError);
        __int16 v62 = +[NSString stringWithUTF8String:"nfcd"];
        id v63 = [v29 code];
        v123[0] = NSLocalizedDescriptionKey;
        id v116 = v63;
        if ((uint64_t)[v29 code] > 70) {
          uint64_t v64 = 71;
        }
        else {
          uint64_t v64 = (uint64_t)[v29 code];
        }
        __int16 v104 = +[NSString stringWithUTF8String:off_1003050D8[v64]];
        v124[0] = v104;
        v124[1] = v29;
        v123[1] = NSUnderlyingErrorKey;
        v123[2] = @"Line";
        v124[2] = &off_10031C420;
        v123[3] = @"Method";
        id v105 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
        v124[3] = v105;
        v123[4] = NSDebugDescriptionErrorKey;
        id v106 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 482];
        v124[4] = v106;
        uint64_t v107 = +[NSDictionary dictionaryWithObjects:v124 forKeys:v123 count:5];
        id v108 = [v61 initWithDomain:v62 code:v116 userInfo:v107];
        (*(void (**)(uint64_t, id, void))(v60 + 16))(v60, v108, 0);

LABEL_26:
        return;
      }
    }
    uint64_t v92 = *(void **)(a1 + 40);
    unsigned int v93 = *(unsigned __int8 **)(*(void *)(a1 + 32) + 184);
    id v117 = 0;
    sub_10008E820(v93, v92, &v117);
    id v29 = (id)objc_claimAutoreleasedReturnValue();
    id v30 = v117;
    if (v29)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v94 = NFLogGetLogger();
      if (v94)
      {
        BOOL v95 = (void (*)(uint64_t, const char *, ...))v94;
        __int16 v96 = object_getClass(*(id *)(a1 + 32));
        BOOL v97 = class_isMetaClass(v96);
        uint64_t v110 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v115 = sel_getName(*(SEL *)(a1 + 56));
        uint64_t v98 = 45;
        if (v97) {
          uint64_t v98 = 43;
        }
        v95(3, "%c[%{public}s %{public}s]:%i error: %{public}@", v98, v110, v115, 490, v29);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v99 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v99, OS_LOG_TYPE_ERROR))
      {
        __int16 v100 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v100)) {
          int v101 = 43;
        }
        else {
          int v101 = 45;
        }
        NSErrorUserInfoKey v102 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v103 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)long long buf = 67110146;
        unsigned int v133 = v101;
        __int16 v134 = 2082;
        int v135 = v102;
        __int16 v136 = 2082;
        int v137 = v103;
        __int16 v138 = 1024;
        int v139 = 490;
        __int16 v140 = 2114;
        id v141 = v29;
        _os_log_impl((void *)&_mh_execute_header, v99, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i error: %{public}@", buf, 0x2Cu);
      }
    }
    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    goto LABEL_26;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v13 = NFLogGetLogger();
  if (v13)
  {
    uint64_t v14 = (void (*)(uint64_t, const char *, ...))v13;
    uint64_t v15 = object_getClass(*(id *)(a1 + 32));
    BOOL v16 = class_isMetaClass(v15);
    BOOL v17 = object_getClassName(*(id *)(a1 + 32));
    int v18 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v19 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v20 = 45;
    if (v16) {
      uint64_t v20 = 43;
    }
    v14(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v20, v17, v18, 452, v19);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v21 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    int v22 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v22)) {
      int v23 = 43;
    }
    else {
      int v23 = 45;
    }
    int v24 = object_getClassName(*(id *)(a1 + 32));
    __int16 v25 = sel_getName(*(SEL *)(a1 + 56));
    id v26 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    unsigned int v133 = v23;
    __int16 v134 = 2082;
    int v135 = v24;
    __int16 v136 = 2082;
    int v137 = v25;
    __int16 v138 = 1024;
    int v139 = 452;
    __int16 v140 = 2114;
    id v141 = v26;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v27 = *(void *)(a1 + 48);
  if (v27)
  {
    id v28 = objc_alloc((Class)NSError);
    id v29 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v130 = NSLocalizedDescriptionKey;
    id v30 = +[NSString stringWithUTF8String:"Session not active"];
    id v131 = v30;
    uint64_t v31 = +[NSDictionary dictionaryWithObjects:&v131 forKeys:&v130 count:1];
    id v32 = v28;
    id v33 = v29;
    uint64_t v34 = 54;
    goto LABEL_24;
  }
}

void sub_100155F20(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v8, ClassName, Name, 506, *(void *)(a1 + 40));
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    id v12 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v13 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v14 = *(void **)(a1 + 40);
    *(_DWORD *)long long buf = 67110146;
    unsigned int v55 = v11;
    __int16 v56 = 2082;
    int v57 = v12;
    __int16 v58 = 2082;
    unsigned int v59 = v13;
    __int16 v60 = 1024;
    int v61 = 506;
    __int16 v62 = 2114;
    id v63 = v14;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }

  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    id v35 = +[_NFHardwareManager sharedHardwareManager];
    [v35 notifyReaderModeActivityStart];

    id v36 = *(void **)(*(void *)(a1 + 32) + 192);
    if (v36 && (int v37 = sub_10018FAE8(v36, *(void **)(a1 + 40), 0)) != 0)
    {
      LODWORD(v38) = v37;
      int v39 = v37 & 0x6F;
      id v40 = objc_alloc((Class)NSError);
      uint64_t v41 = +[NSString stringWithUTF8String:"nfcd"];
      if (v39 == 35 || v38 == 64) {
        uint64_t v38 = v38;
      }
      else {
        uint64_t v38 = 15;
      }
      NSErrorUserInfoKey v50 = NSLocalizedDescriptionKey;
      uint64_t v43 = +[NSString stringWithUTF8String:off_1003050D8[v38]];
      uint64_t v51 = v43;
      uint64_t v44 = +[NSDictionary dictionaryWithObjects:&v51 forKeys:&v50 count:1];
      id v31 = [v40 initWithDomain:v41 code:v38 userInfo:v44];

      int v45 = NFSharedSignpostLog();
      if (os_signpost_enabled(v45))
      {
        unsigned int v46 = [v31 code];
        *(_DWORD *)long long buf = 67109120;
        unsigned int v55 = v46;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v45, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+tag_connect", "begin, error.code: %d", buf, 8u);
      }
    }
    else
    {
      id v47 = NFSharedSignpostLog();
      if (os_signpost_enabled(v47))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v47, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+tag_connect", "begin", buf, 2u);
      }

      id v48 = [objc_alloc((Class)NFTagInternal) initWithNFTag:*(void *)(a1 + 40)];
      id v31 = 0;
      uint64_t v49 = *(void *)(a1 + 32);
      int v45 = *(NSObject **)(v49 + 176);
      *(void *)(v49 + 176) = v48;
    }

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    goto LABEL_24;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v15 = NFLogGetLogger();
  if (v15)
  {
    BOOL v16 = (void (*)(uint64_t, const char *, ...))v15;
    BOOL v17 = object_getClass(*(id *)(a1 + 32));
    BOOL v18 = class_isMetaClass(v17);
    uint64_t v19 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v20 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v21 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v22 = 45;
    if (v18) {
      uint64_t v22 = 43;
    }
    v16(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v22, v19, v20, 507, v21);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v23 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
  {
    int v24 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v24)) {
      int v25 = 43;
    }
    else {
      int v25 = 45;
    }
    id v26 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v27 = sel_getName(*(SEL *)(a1 + 56));
    id v28 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    unsigned int v55 = v25;
    __int16 v56 = 2082;
    int v57 = v26;
    __int16 v58 = 2082;
    unsigned int v59 = v27;
    __int16 v60 = 1024;
    int v61 = 507;
    __int16 v62 = 2114;
    id v63 = v28;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v29 = *(void *)(a1 + 48);
  if (v29)
  {
    id v30 = objc_alloc((Class)NSError);
    id v31 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v52 = NSLocalizedDescriptionKey;
    id v32 = +[NSString stringWithUTF8String:"Session not active"];
    BOOL v53 = v32;
    id v33 = +[NSDictionary dictionaryWithObjects:&v53 forKeys:&v52 count:1];
    id v34 = [v30 initWithDomain:v31 code:54 userInfo:v33];
    (*(void (**)(uint64_t, id))(v29 + 16))(v29, v34);

LABEL_24:
  }
}

void sub_1001565D4(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = [*(id *)(a1 + 32) connection];
    id v10 = [v9 processIdentifier];
    int v11 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v12 = 43;
    if (!isMetaClass) {
      uint64_t v12 = 45;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@ (%d) %{public}@", v12, ClassName, Name, 533, v8, v10, v11);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v13 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14)) {
      int v15 = 43;
    }
    else {
      int v15 = 45;
    }
    BOOL v16 = object_getClassName(*(id *)(a1 + 32));
    BOOL v17 = sel_getName(*(SEL *)(a1 + 48));
    BOOL v18 = [*(id *)(a1 + 32) clientName];
    uint64_t v19 = [*(id *)(a1 + 32) connection];
    unsigned int v20 = [v19 processIdentifier];
    uint64_t v21 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110658;
    unsigned int v52 = v15;
    __int16 v53 = 2082;
    uint64_t v54 = v16;
    __int16 v55 = 2082;
    __int16 v56 = v17;
    __int16 v57 = 1024;
    int v58 = 533;
    __int16 v59 = 2114;
    __int16 v60 = v18;
    __int16 v61 = 1024;
    unsigned int v62 = v20;
    __int16 v63 = 2114;
    uint64_t v64 = v21;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@ (%d) %{public}@", buf, 0x3Cu);
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    BOOL v42 = +[_NFHardwareManager sharedHardwareManager];
    [v42 notifyReaderModeActivityEnd];

    uint64_t v38 = [*(id *)(a1 + 32) _disconnectWithCardRemoval:*(unsigned __int8 *)(a1 + 56)];
    uint64_t v43 = NFSharedSignpostLog();
    BOOL v44 = os_signpost_enabled(v43);
    if (v38)
    {
      if (v44)
      {
        unsigned int v45 = [v38 code];
        *(_DWORD *)long long buf = 67109120;
        unsigned int v52 = v45;
        unsigned int v46 = "end, error.code: %d";
        id v47 = v43;
        uint32_t v48 = 8;
LABEL_31:
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v47, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "_NFSecureElementReaderSession+tag_connect", v46, buf, v48);
      }
    }
    else if (v44)
    {
      *(_WORD *)long long buf = 0;
      unsigned int v46 = "end";
      id v47 = v43;
      uint32_t v48 = 2;
      goto LABEL_31;
    }

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    goto LABEL_24;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v22 = NFLogGetLogger();
  if (v22)
  {
    int v23 = (void (*)(uint64_t, const char *, ...))v22;
    int v24 = object_getClass(*(id *)(a1 + 32));
    BOOL v25 = class_isMetaClass(v24);
    id v26 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v27 = sel_getName(*(SEL *)(a1 + 48));
    id v28 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v29 = 45;
    if (v25) {
      uint64_t v29 = 43;
    }
    v23(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v29, v26, v27, 535, v28);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v30 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    id v31 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v31)) {
      int v32 = 43;
    }
    else {
      int v32 = 45;
    }
    id v33 = object_getClassName(*(id *)(a1 + 32));
    id v34 = sel_getName(*(SEL *)(a1 + 48));
    id v35 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    unsigned int v52 = v32;
    __int16 v53 = 2082;
    uint64_t v54 = v33;
    __int16 v55 = 2082;
    __int16 v56 = v34;
    __int16 v57 = 1024;
    int v58 = 535;
    __int16 v59 = 2114;
    __int16 v60 = v35;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v36 = *(void *)(a1 + 40);
  if (v36)
  {
    id v37 = objc_alloc((Class)NSError);
    uint64_t v38 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v49 = NSLocalizedDescriptionKey;
    int v39 = +[NSString stringWithUTF8String:"Session not active"];
    NSErrorUserInfoKey v50 = v39;
    id v40 = +[NSDictionary dictionaryWithObjects:&v50 forKeys:&v49 count:1];
    id v41 = [v37 initWithDomain:v38 code:54 userInfo:v40];
    (*(void (**)(uint64_t, id))(v36 + 16))(v36, v41);

LABEL_24:
  }
}

void sub_100157918(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100157950(uint64_t a1)
{
}

void sub_100157958(uint64_t a1, void *a2, uint64_t a3, unsigned char *a4)
{
  id v11 = a2;
  id v6 = [v11 identifierAsData];
  unsigned int v7 = [v6 isEqualToData:*(void *)(a1 + 32)];

  if (v7)
  {
    uint64_t v8 = [v11 identifier];
    uint64_t v9 = *(void *)(*(void *)(a1 + 40) + 8);
    id v10 = *(void **)(v9 + 40);
    *(void *)(v9 + 40) = v8;

    *a4 = 1;
  }
}

void sub_100158664(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100159008(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10015929C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_1001592C4(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v7 = 45;
    if (isMetaClass) {
      uint64_t v7 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i ", v7, ClassName, Name, 186);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v8 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v9)) {
      int v10 = 43;
    }
    else {
      int v10 = 45;
    }
    id v11 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v12 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)long long buf = 67109890;
    int v16 = v10;
    __int16 v17 = 2082;
    BOOL v18 = v11;
    __int16 v19 = 2082;
    unsigned int v20 = v12;
    __int16 v21 = 1024;
    int v22 = 186;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  return [*(id *)(a1 + 32) internalEndSession:*(void *)(a1 + 40)];
}

void sub_100159AD4(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = +[NSUserDefaults standardUserDefaults];
    uint64_t v3 = [v2 objectForKey:@"RecoveryAttempts"];
    int v4 = [v3 intValue];

    if (v4 < 101)
    {
      switch([(id)a1 _checkFailForwardState])
      {
        case 0u:
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t Logger = NFLogGetLogger();
          if (Logger)
          {
            int v15 = (void (*)(uint64_t, const char *, ...))Logger;
            Class = object_getClass((id)a1);
            BOOL isMetaClass = class_isMetaClass(Class);
            ClassName = object_getClassName((id)a1);
            Name = sel_getName("recoverFailForwardIfNeeded");
            uint64_t v19 = 45;
            if (isMetaClass) {
              uint64_t v19 = 43;
            }
            v15(6, "%c[%{public}s %{public}s]:%i recovered already..", v19, ClassName, Name, 149);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          unsigned int v20 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
          {
            __int16 v21 = object_getClass((id)a1);
            if (class_isMetaClass(v21)) {
              int v22 = 43;
            }
            else {
              int v22 = 45;
            }
            *(_DWORD *)long long buf = 67109890;
            int v79 = v22;
            __int16 v80 = 2082;
            char v81 = object_getClassName((id)a1);
            __int16 v82 = 2082;
            BOOL v83 = sel_getName("recoverFailForwardIfNeeded");
            __int16 v84 = 1024;
            int v85 = 149;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i recovered already..", buf, 0x22u);
          }

          if (!*(unsigned char *)(a1 + 24)) {
            [(id)a1 _storeFailForwardRecovery:1];
          }
          return;
        case 1u:
          int v23 = NFSharedSignpostLog();
          if (os_signpost_enabled(v23))
          {
            *(_WORD *)long long buf = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v23, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "HWRecovery", "begin", buf, 2u);
          }

          id v24 = *(id *)(a1 + 248);
          [v24 handleHWRecoveryStarted];

          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v25 = NFLogGetLogger();
          if (v25)
          {
            id v26 = (void (*)(uint64_t, const char *, ...))v25;
            uint64_t v27 = object_getClass((id)a1);
            BOOL v28 = class_isMetaClass(v27);
            uint64_t v29 = object_getClassName((id)a1);
            id v75 = sel_getName("recoverFailForwardIfNeeded");
            uint64_t v30 = 45;
            if (v28) {
              uint64_t v30 = 43;
            }
            v26(6, "%c[%{public}s %{public}s]:%i Full restore..", v30, v29, v75, 106);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v31 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
          {
            int v32 = object_getClass((id)a1);
            if (class_isMetaClass(v32)) {
              int v33 = 43;
            }
            else {
              int v33 = 45;
            }
            id v34 = object_getClassName((id)a1);
            id v35 = sel_getName("recoverFailForwardIfNeeded");
            *(_DWORD *)long long buf = 67109890;
            int v79 = v33;
            __int16 v80 = 2082;
            char v81 = v34;
            __int16 v82 = 2082;
            BOOL v83 = v35;
            __int16 v84 = 1024;
            int v85 = 106;
            _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Full restore..", buf, 0x22u);
          }

          uint64_t v36 = objc_opt_new();
          id v37 = [v36 runService:&off_100323280];

          uint64_t v38 = [v37 valueForKey:@"Error"];

          int v39 = NFSharedSignpostLog();
          BOOL v40 = os_signpost_enabled(v39);
          if (v38)
          {
            if (!v40) {
              goto LABEL_68;
            }
            *(_WORD *)long long buf = 0;
            goto LABEL_67;
          }
          if (!v40) {
            goto LABEL_76;
          }
          *(_WORD *)long long buf = 0;
          goto LABEL_75;
        case 2u:
          id v41 = NFSharedSignpostLog();
          if (os_signpost_enabled(v41))
          {
            *(_WORD *)long long buf = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v41, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "HWRecovery", "begin", buf, 2u);
          }

          id v42 = *(id *)(a1 + 248);
          [v42 handleHWRecoveryStarted];

          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v43 = NFLogGetLogger();
          if (v43)
          {
            BOOL v44 = (void (*)(uint64_t, const char *, ...))v43;
            unsigned int v45 = object_getClass((id)a1);
            BOOL v46 = class_isMetaClass(v45);
            id v47 = object_getClassName((id)a1);
            uint64_t v76 = sel_getName("recoverFailForwardIfNeeded");
            uint64_t v48 = 45;
            if (v46) {
              uint64_t v48 = 43;
            }
            v44(6, "%c[%{public}s %{public}s]:%i Stockholm only restore..", v48, v47, v76, 120);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          NSErrorUserInfoKey v49 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
          {
            NSErrorUserInfoKey v50 = object_getClass((id)a1);
            if (class_isMetaClass(v50)) {
              int v51 = 43;
            }
            else {
              int v51 = 45;
            }
            unsigned int v52 = object_getClassName((id)a1);
            __int16 v53 = sel_getName("recoverFailForwardIfNeeded");
            *(_DWORD *)long long buf = 67109890;
            int v79 = v51;
            __int16 v80 = 2082;
            char v81 = v52;
            __int16 v82 = 2082;
            BOOL v83 = v53;
            __int16 v84 = 1024;
            int v85 = 120;
            _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Stockholm only restore..", buf, 0x22u);
          }

          uint64_t v54 = objc_opt_new();
          id v37 = [v54 runService:&off_1003232A8];

          __int16 v55 = [v37 valueForKey:@"Error"];

          int v39 = NFSharedSignpostLog();
          BOOL v56 = os_signpost_enabled(v39);
          if (v55)
          {
            if (!v56) {
              goto LABEL_68;
            }
            *(_WORD *)long long buf = 0;
            goto LABEL_67;
          }
          if (!v56) {
            goto LABEL_76;
          }
          *(_WORD *)long long buf = 0;
          goto LABEL_75;
        case 3u:
          __int16 v57 = NFSharedSignpostLog();
          if (os_signpost_enabled(v57))
          {
            *(_WORD *)long long buf = 0;
            _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v57, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "HWRecovery", "begin", buf, 2u);
          }

          id v58 = *(id *)(a1 + 248);
          [v58 handleHWRecoveryStarted];

          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v59 = NFLogGetLogger();
          if (v59)
          {
            __int16 v60 = (void (*)(uint64_t, const char *, ...))v59;
            __int16 v61 = object_getClass((id)a1);
            BOOL v62 = class_isMetaClass(v61);
            __int16 v63 = object_getClassName((id)a1);
            id v77 = sel_getName("recoverFailForwardIfNeeded");
            uint64_t v64 = 45;
            if (v62) {
              uint64_t v64 = 43;
            }
            v60(6, "%c[%{public}s %{public}s]:%i hammerfest only restore..", v64, v63, v77, 135);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v65 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v65, OS_LOG_TYPE_DEFAULT))
          {
            NSErrorUserInfoKey v66 = object_getClass((id)a1);
            if (class_isMetaClass(v66)) {
              int v67 = 43;
            }
            else {
              int v67 = 45;
            }
            BOOL v68 = object_getClassName((id)a1);
            id v69 = sel_getName("recoverFailForwardIfNeeded");
            *(_DWORD *)long long buf = 67109890;
            int v79 = v67;
            __int16 v80 = 2082;
            char v81 = v68;
            __int16 v82 = 2082;
            BOOL v83 = v69;
            __int16 v84 = 1024;
            int v85 = 135;
            _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i hammerfest only restore..", buf, 0x22u);
          }

          uint64_t v70 = objc_opt_new();
          id v37 = [v70 runService:&off_1003232D0];

          id v71 = [v37 valueForKey:@"Error"];

          int v39 = NFSharedSignpostLog();
          BOOL v72 = os_signpost_enabled(v39);
          if (v71)
          {
            if (v72)
            {
              *(_WORD *)long long buf = 0;
LABEL_67:
              _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v39, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "HWRecovery", "end, failed", buf, 2u);
            }
LABEL_68:

            [(id)a1 _recoveryFailed];
          }
          else
          {
            if (v72)
            {
              *(_WORD *)long long buf = 0;
LABEL_75:
              _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v39, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "HWRecovery", "end", buf, 2u);
            }
LABEL_76:

            [(id)a1 _recoverySucceeded];
          }

          break;
        default:
          return;
      }
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v5 = NFLogGetLogger();
      if (v5)
      {
        id v6 = (void (*)(uint64_t, const char *, ...))v5;
        uint64_t v7 = object_getClass((id)a1);
        BOOL v8 = class_isMetaClass(v7);
        uint64_t v9 = object_getClassName((id)a1);
        int v73 = sel_getName("recoverFailForwardIfNeeded");
        uint64_t v10 = 45;
        if (v8) {
          uint64_t v10 = 43;
        }
        v6(6, "%c[%{public}s %{public}s]:%i Recovered from failed restore", v10, v9, v73, 96);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v11 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v12 = object_getClass((id)a1);
        if (class_isMetaClass(v12)) {
          int v13 = 43;
        }
        else {
          int v13 = 45;
        }
        *(_DWORD *)long long buf = 67109890;
        int v79 = v13;
        __int16 v80 = 2082;
        char v81 = object_getClassName((id)a1);
        __int16 v82 = 2082;
        BOOL v83 = sel_getName("recoverFailForwardIfNeeded");
        __int16 v84 = 1024;
        int v85 = 96;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Recovered from failed restore", buf, 0x22u);
      }
    }
  }
}

uint64_t sub_10015A97C(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v7 = 45;
    if (isMetaClass) {
      uint64_t v7 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i Hammerfest failed during restore", v7, ClassName, Name, 202);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  BOOL v8 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v9)) {
      int v10 = 43;
    }
    else {
      int v10 = 45;
    }
    id v11 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v12 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)long long buf = 67109890;
    int v16 = v10;
    __int16 v17 = 2082;
    BOOL v18 = v11;
    __int16 v19 = 2082;
    unsigned int v20 = v12;
    __int16 v21 = 1024;
    int v22 = 202;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Hammerfest failed during restore", buf, 0x22u);
  }

  *(_DWORD *)(*(void *)(a1 + 32) + 28) = 3;
  return *(unsigned int *)(*(void *)(a1 + 32) + 28);
}

uint64_t sub_10015AB0C(uint64_t a1)
{
  int v2 = MSUParsedToleratedFailureForStep();
  *(_DWORD *)(*(void *)(a1 + 32) + 28) = 2 * (v2 != 0);
  if (*(_DWORD *)(*(void *)(a1 + 32) + 28))
  {
    +[NFExceptionsCALogger postAnalyticsMobileSoftwareUpdateExceptionEvent:(unsigned __int16)v2];
    uint64_t v3 = &off_1003232F8;
  }
  else
  {
    uint64_t v3 = &off_100323320;
  }
  +[NFGeneralStatisticsCALogger updateGeneralDeviceStatistic:v3];
  [*(id *)(a1 + 40) removeObjectForKey:@"RecoveryAttempts"];
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    if (*(_DWORD *)(*(void *)(a1 + 32) + 28)) {
      CFStringRef v10 = @"failed";
    }
    else {
      CFStringRef v10 = @"succeeded";
    }
    uint64_t v11 = 45;
    if (isMetaClass) {
      uint64_t v11 = 43;
    }
    v5(6, "%c[%{public}s %{public}s]:%i MSU reports restore %{public}@", v11, ClassName, Name, 226, v10);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v12 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v13)) {
      int v14 = 43;
    }
    else {
      int v14 = 45;
    }
    int v15 = object_getClassName(*(id *)(a1 + 32));
    int v16 = sel_getName(*(SEL *)(a1 + 48));
    if (*(_DWORD *)(*(void *)(a1 + 32) + 28)) {
      CFStringRef v17 = @"failed";
    }
    else {
      CFStringRef v17 = @"succeeded";
    }
    *(_DWORD *)long long buf = 67110146;
    int v20 = v14;
    __int16 v21 = 2082;
    int v22 = v15;
    __int16 v23 = 2082;
    id v24 = v16;
    __int16 v25 = 1024;
    int v26 = 226;
    __int16 v27 = 2114;
    CFStringRef v28 = v17;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i MSU reports restore %{public}@", buf, 0x2Cu);
  }

  return *(unsigned int *)(*(void *)(a1 + 32) + 28);
}

void sub_10015B1A8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10015B1D4(uint64_t a1, int a2)
{
  if (a1)
  {
    uint64_t v3 = +[NSUserDefaults standardUserDefaults];
    id v4 = v3;
    if (a2) {
      [v3 setBool:1 forKey:@"RecoveryInProgress"];
    }
    else {
      [v3 removeObjectForKey:@"RecoveryInProgress"];
    }
  }
}

id sub_10015B250(void *a1)
{
  if (a1)
  {
    int v2 = NFBuildVersion();
    if (v2)
    {
      id v3 = a1;
      objc_sync_enter(v3);
      sub_10015B1D4((uint64_t)v3, 1);
      id v4 = +[NSUserDefaults standardUserDefaults];
      [v4 setObject:v2 forKey:@"FuryRecoveryNeeded"];

      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (Logger)
      {
        Class = object_getClass(v3);
        if (class_isMetaClass(Class)) {
          uint64_t v7 = 43;
        }
        else {
          uint64_t v7 = 45;
        }
        ClassName = object_getClassName(v3);
        Name = sel_getName("attemptHammerfestRecovery");
        Logger(3, "%c[%{public}s %{public}s]:%i set %{public}@ for %{public}@", v7, ClassName, Name, 291, v2, @"FuryRecoveryNeeded");
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      CFStringRef v10 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        uint64_t v11 = object_getClass(v3);
        if (class_isMetaClass(v11)) {
          int v12 = 43;
        }
        else {
          int v12 = 45;
        }
        *(_DWORD *)long long buf = 67110402;
        int v29 = v12;
        __int16 v30 = 2082;
        id v31 = object_getClassName(v3);
        __int16 v32 = 2082;
        int v33 = sel_getName("attemptHammerfestRecovery");
        __int16 v34 = 1024;
        int v35 = 291;
        __int16 v36 = 2114;
        id v37 = v2;
        __int16 v38 = 2114;
        CFStringRef v39 = @"FuryRecoveryNeeded";
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i set %{public}@ for %{public}@", buf, 0x36u);
      }

      objc_sync_exit(v3);
      id v13 = 0;
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v14 = NFLogGetLogger();
      if (v14)
      {
        int v15 = (void (*)(uint64_t, const char *, ...))v14;
        int v16 = object_getClass(a1);
        BOOL isMetaClass = class_isMetaClass(v16);
        BOOL v18 = object_getClassName(a1);
        __int16 v27 = sel_getName("attemptHammerfestRecovery");
        uint64_t v19 = 45;
        if (isMetaClass) {
          uint64_t v19 = 43;
        }
        v15(3, "%c[%{public}s %{public}s]:%i Failed to query build", v19, v18, v27, 284);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v20 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        __int16 v21 = object_getClass(a1);
        if (class_isMetaClass(v21)) {
          int v22 = 43;
        }
        else {
          int v22 = 45;
        }
        *(_DWORD *)long long buf = 67109890;
        int v29 = v22;
        __int16 v30 = 2082;
        id v31 = object_getClassName(a1);
        __int16 v32 = 2082;
        int v33 = sel_getName("attemptHammerfestRecovery");
        __int16 v34 = 1024;
        int v35 = 284;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to query build", buf, 0x22u);
      }

      id v23 = objc_alloc((Class)NSError);
      id v3 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v40 = NSLocalizedDescriptionKey;
      id v24 = +[NSString stringWithUTF8String:"Unknown Error"];
      id v41 = v24;
      __int16 v25 = +[NSDictionary dictionaryWithObjects:&v41 forKeys:&v40 count:1];
      id v13 = [v23 initWithDomain:v3 code:6 userInfo:v25];
    }
  }
  else
  {
    id v13 = 0;
  }

  return v13;
}

void sub_10015B62C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_10015B654(void *a1)
{
  if (a1)
  {
    id v1 = a1;
    objc_sync_enter(v1);
    id v2 = [v1 _checkFailForwardState];
    if (v2)
    {
      uint64_t v40 = *((void *)v1 + 37);
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (Logger)
      {
        Class = object_getClass(v1);
        if (class_isMetaClass(Class)) {
          uint64_t v5 = 43;
        }
        else {
          uint64_t v5 = 45;
        }
        ClassName = object_getClassName(v1);
        Name = sel_getName("attemptFailForwardRecovery");
        Logger(6, "%c[%{public}s %{public}s]:%i [self checkFailForwardState] = %d", v5, ClassName, Name, 306, v2);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      BOOL v8 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v9 = object_getClass(v1);
        if (class_isMetaClass(v9)) {
          int v10 = 43;
        }
        else {
          int v10 = 45;
        }
        *(_DWORD *)long long buf = 67110146;
        int v42 = v10;
        __int16 v43 = 2082;
        BOOL v44 = object_getClassName(v1);
        __int16 v45 = 2082;
        BOOL v46 = sel_getName("attemptFailForwardRecovery");
        __int16 v47 = 1024;
        int v48 = 306;
        __int16 v49 = 1024;
        LODWORD(v50) = v2;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i [self checkFailForwardState] = %d", buf, 0x28u);
      }

      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v11 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v11)
      {
        int v12 = object_getClass(v1);
        if (class_isMetaClass(v12)) {
          uint64_t v13 = 43;
        }
        else {
          uint64_t v13 = 45;
        }
        uint64_t v14 = object_getClassName(v1);
        int v15 = sel_getName("attemptFailForwardRecovery");
        int v16 = +[NSUserDefaults standardUserDefaults];
        v11(6, "%c[%{public}s %{public}s]:%i NFFailedForwardRecoveryAttempts = %ld", v13, v14, v15, 307, [v16 integerForKey:@"RecoveryAttempts"]);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      CFStringRef v17 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
      {
        BOOL v18 = object_getClass(v1);
        if (class_isMetaClass(v18)) {
          int v19 = 43;
        }
        else {
          int v19 = 45;
        }
        int v20 = object_getClassName(v1);
        __int16 v21 = sel_getName("attemptFailForwardRecovery");
        int v22 = +[NSUserDefaults standardUserDefaults];
        id v23 = [v22 integerForKey:@"RecoveryAttempts"];
        *(_DWORD *)long long buf = 67110146;
        int v42 = v19;
        __int16 v43 = 2082;
        BOOL v44 = v20;
        __int16 v45 = 2082;
        BOOL v46 = v21;
        __int16 v47 = 1024;
        int v48 = 307;
        __int16 v49 = 2048;
        id v50 = v23;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NFFailedForwardRecoveryAttempts = %ld", buf, 0x2Cu);
      }
      if (v2 <= 3)
      {
        id v24 = +[NSUserDefaults standardUserDefaults];
        BOOL v25 = (uint64_t)[v24 integerForKey:@"RecoveryAttempts"] < 101;

        if (v25)
        {
          if ((*((unsigned char *)v1 + 222) & 1) == 0)
          {
            sub_10015B1D4((uint64_t)v1, 1);
            sub_100211D70((uint64_t)v1, 0);
            int v26 = sub_10020F914((uint64_t)v1);
            uint64_t v27 = *((void *)v1 + 37);
            if (v27 == 4 || v27 == 1)
            {
              sub_1002112A8((uint64_t)v1);
              uint64_t v27 = *((void *)v1 + 37);
            }
            if (v27 == v40 || v27 == 1 && v40 == 4)
            {
              id v28 = 0;
            }
            else
            {
              id v28 = v26;
              int v26 = v28;
            }
            goto LABEL_45;
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          int v29 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v29)
          {
            __int16 v30 = object_getClass(v1);
            if (class_isMetaClass(v30)) {
              uint64_t v31 = 43;
            }
            else {
              uint64_t v31 = 45;
            }
            __int16 v32 = object_getClassName(v1);
            int v33 = sel_getName("attemptFailForwardRecovery");
            v29(3, "%c[%{public}s %{public}s]:%i Not allowed to power off NFCC. Retry later", v31, v32, v33, 314);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          __int16 v34 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
          {
            int v35 = object_getClass(v1);
            if (class_isMetaClass(v35)) {
              int v36 = 43;
            }
            else {
              int v36 = 45;
            }
            id v37 = object_getClassName(v1);
            __int16 v38 = sel_getName("attemptFailForwardRecovery");
            *(_DWORD *)long long buf = 67109890;
            int v42 = v36;
            __int16 v43 = 2082;
            BOOL v44 = v37;
            __int16 v45 = 2082;
            BOOL v46 = v38;
            __int16 v47 = 1024;
            int v48 = 314;
            _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Not allowed to power off NFCC. Retry later", buf, 0x22u);
          }
        }
      }
    }
    id v28 = 0;
    int v26 = 0;
LABEL_45:

    objc_sync_exit(v1);
    goto LABEL_46;
  }
  id v28 = 0;
LABEL_46:

  return v28;
}

void sub_10015BB74(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10015C814(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_10015C850(void *a1, void *a2, void *a3)
{
  id v5 = a3;
  if (a1)
  {
    id v6 = a2;
    id v7 = objc_alloc((Class)NFTimer);
    v11[0] = _NSConcreteStackBlock;
    v11[1] = 3221225472;
    v11[2] = sub_10015C950;
    v11[3] = &unk_100301D38;
    v11[4] = a1;
    id v12 = v5;
    uint64_t v13 = "scheduleNFCCRecoveryOnQueue:onSuccess:";
    id v8 = [v7 initSleepTimerWithCallback:v11 queue:v6];

    uint64_t v9 = (void *)a1[4];
    a1[4] = v8;

    int v10 = (void *)a1[4];
    [a1 nextRetryTime];
    [v10 startTimer:];
  }
}

void sub_10015C950(uint64_t a1)
{
  id v2 = _os_activity_create((void *)&_mh_execute_header, "com.apple.nfcd.hw.recoveryTimer", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  *(void *)state = 0;
  *(void *)&state[8] = 0;
  os_activity_scope_enter(v2, (os_activity_scope_state_t)state);
  os_activity_scope_leave((os_activity_scope_state_t)state);

  id v3 = [*(id *)(a1 + 32) _attemptNFCCRecovery];
  if (v3) {
    goto LABEL_8;
  }
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4) {
    *(unsigned char *)(v4 + 223) = 0;
  }
  if (((*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16))() & 1) == 0)
  {
LABEL_8:
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v9 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      [*(id *)(a1 + 32) nextRetryTime];
      uint64_t v15 = 45;
      if (isMetaClass) {
        uint64_t v15 = 43;
      }
      v9(6, "%c[%{public}s %{public}s]:%i Retrying recovery in %lf seconds", v15, ClassName, Name, 462, v14);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v16 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
    {
      CFStringRef v17 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v17)) {
        int v18 = 43;
      }
      else {
        int v18 = 45;
      }
      int v19 = object_getClassName(*(id *)(a1 + 32));
      int v20 = sel_getName(*(SEL *)(a1 + 48));
      [*(id *)(a1 + 32) nextRetryTime];
      *(_DWORD *)state = 67110146;
      *(_DWORD *)&state[4] = v18;
      *(_WORD *)&state[8] = 2082;
      *(void *)&state[10] = v19;
      __int16 v25 = 2082;
      int v26 = v20;
      __int16 v27 = 1024;
      int v28 = 462;
      __int16 v29 = 2048;
      uint64_t v30 = v21;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Retrying recovery in %lf seconds", state, 0x2Cu);
    }

    int v22 = *(void **)(a1 + 32);
    id v23 = (void *)v22[4];
    [v22 nextRetryTime];
    [v23 startTimer:];
  }
  else
  {
    uint64_t v5 = *(void *)(a1 + 32);
    if (v5)
    {
      *(_DWORD *)(v5 + 8) = 0;
      *(void *)(v5 + 16) = 0;
      uint64_t v6 = *(void *)(a1 + 32);
      if (v6)
      {
        [*(id *)(v6 + 32) stopTimer];
        id v7 = *(void **)(v6 + 32);
        *(void *)(v6 + 32) = 0;
      }
    }
  }
}

id sub_10015CBB4(id result)
{
  if (result)
  {
    id v1 = +[NSUserDefaults standardUserDefaults];
    id v2 = [v1 BOOLForKey:@"RecoveryInProgress"];

    return v2;
  }
  return result;
}

BOOL sub_1001621F8(BOOL result)
{
  if (result)
  {
    id v1 = [*(id *)(result + 24) info];
    id v2 = [v1 deviceType];

    return v2 != (id)115;
  }
  return result;
}

void sub_1001662AC(uint64_t a1, void *a2)
{
  id v3 = a2;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v8 = 45;
    if (isMetaClass) {
      uint64_t v8 = 43;
    }
    v5(6, "%c[%{public}s %{public}s]:%i TSM update notification for AID %{public}@", v8, ClassName, Name, 441, v3);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    id v12 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v13 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)long long buf = 67110146;
    *(_DWORD *)int v19 = v11;
    *(_WORD *)&v19[4] = 2082;
    *(void *)&v19[6] = v12;
    *(_WORD *)&v19[14] = 2082;
    *(void *)&v19[16] = v13;
    __int16 v20 = 1024;
    int v21 = 441;
    __int16 v22 = 2114;
    id v23 = v3;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i TSM update notification for AID %{public}@", buf, 0x2Cu);
  }

  uint64_t v14 = +[_NFHardwareManager sharedHardwareManager];
  sub_1000FA94C(v14, (uint64_t)"com.apple.stockholm.se.update.by.tsm", v3);

  uint64_t v15 = NFSharedSignpostLog();
  if (os_signpost_enabled(v15))
  {
    *(_DWORD *)long long buf = 136315394;
    *(void *)int v19 = "com.apple.stockholm.se.update.by.tsm";
    *(_WORD *)&v19[8] = 2112;
    *(void *)&v19[10] = v3;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "UPDATE_BY_TSM_NOTIFICATION", "%s, key: %@", buf, 0x16u);
  }
}

void sub_100166904(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 492, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    uint64_t v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v15 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)long long buf = 67110146;
    int v84 = v12;
    __int16 v85 = 2082;
    id v86 = v13;
    __int16 v87 = 2082;
    int v88 = v14;
    __int16 v89 = 1024;
    int v90 = 492;
    __int16 v91 = 2114;
    CFStringRef v92 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    __int16 v32 = objc_opt_new();
    int v36 = *(void **)(a1 + 32);
    id v37 = [v36 embeddedSecureElementWrapper];
    LOBYTE(v36) = [v36 _activateSecureElementWrapper:v37];

    if (v36)
    {
      __int16 v38 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      CFStringRef v39 = *(void **)(a1 + 40);
      int v40 = *(unsigned __int8 *)(a1 + 64);
      id v80 = 0;
      uint64_t v41 = sub_100185954(v38, v39, v40, &v80);
      id v33 = v80;

      if (v41)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v42 = NFLogGetLogger();
        if (v42)
        {
          __int16 v43 = (void (*)(uint64_t, const char *, ...))v42;
          BOOL v44 = object_getClass(*(id *)(a1 + 32));
          BOOL v45 = class_isMetaClass(v44);
          BOOL v46 = object_getClassName(*(id *)(a1 + 32));
          __int16 v47 = sel_getName(*(SEL *)(a1 + 56));
          if (v41 >= 0x47) {
            int v48 = 71;
          }
          else {
            int v48 = v41;
          }
          int v79 = off_100305838[v48];
          uint64_t v49 = 43;
          if (!v45) {
            uint64_t v49 = 45;
          }
          v43(3, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", v49, v46, v47, 507, @"Returned", v41, v79);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v50 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
        {
          int v51 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v51)) {
            int v52 = 43;
          }
          else {
            int v52 = 45;
          }
          __int16 v53 = object_getClassName(*(id *)(a1 + 32));
          uint64_t v54 = sel_getName(*(SEL *)(a1 + 56));
          if (v41 >= 0x47) {
            uint64_t v55 = 71;
          }
          else {
            uint64_t v55 = v41;
          }
          BOOL v56 = off_100305838[v55];
          *(_DWORD *)long long buf = 67110658;
          int v84 = v52;
          __int16 v85 = 2082;
          id v86 = v53;
          __int16 v87 = 2082;
          int v88 = v54;
          __int16 v89 = 1024;
          int v90 = 507;
          __int16 v91 = 2112;
          CFStringRef v92 = @"Returned";
          __int16 v93 = 1024;
          int v94 = v41;
          __int16 v95 = 2080;
          __int16 v96 = v56;
          _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", buf, 0x3Cu);
        }
        else if (v41 >= 0x47)
        {
          uint64_t v55 = 71;
        }
        else
        {
          uint64_t v55 = v41;
        }

        uint64_t v72 = *(void *)(a1 + 48);
        id v73 = objc_alloc((Class)NSError);
        id v74 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v81 = NSLocalizedDescriptionKey;
        id v75 = +[NSString stringWithUTF8String:off_100305838[v55]];
        __int16 v82 = v75;
        uint64_t v76 = +[NSDictionary dictionaryWithObjects:&v82 forKeys:&v81 count:1];
        id v77 = [v73 initWithDomain:v74 code:v41 userInfo:v76];
        (*(void (**)(uint64_t, void, id))(v72 + 16))(v72, 0, v77);
      }
      else
      {
        [v32 addObject:v33];
        (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
      }
      goto LABEL_25;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v57 = NFLogGetLogger();
    if (v57)
    {
      id v58 = (void (*)(uint64_t, const char *, ...))v57;
      uint64_t v59 = object_getClass(*(id *)(a1 + 32));
      BOOL v60 = class_isMetaClass(v59);
      __int16 v61 = object_getClassName(*(id *)(a1 + 32));
      char v78 = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v62 = 45;
      if (v60) {
        uint64_t v62 = 43;
      }
      v58(3, "%c[%{public}s %{public}s]:%i Failed to activate embedded secure element", v62, v61, v78, 499);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v63 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
    {
      uint64_t v64 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v64)) {
        int v65 = 43;
      }
      else {
        int v65 = 45;
      }
      NSErrorUserInfoKey v66 = object_getClassName(*(id *)(a1 + 32));
      int v67 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)long long buf = 67109890;
      int v84 = v65;
      __int16 v85 = 2082;
      id v86 = v66;
      __int16 v87 = 2082;
      int v88 = v67;
      __int16 v89 = 1024;
      int v90 = 499;
      _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to activate embedded secure element", buf, 0x22u);
    }

    uint64_t v68 = *(void *)(a1 + 48);
    id v69 = objc_alloc((Class)NSError);
    id v33 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v97 = NSLocalizedDescriptionKey;
    __int16 v34 = +[NSString stringWithUTF8String:"Stack Error"];
    uint64_t v98 = v34;
    uint64_t v70 = +[NSDictionary dictionaryWithObjects:&v98 forKeys:&v97 count:1];
    id v71 = [v69 initWithDomain:v33 code:15 userInfo:v70];
    (*(void (**)(uint64_t, void, id))(v68 + 16))(v68, 0, v71);

LABEL_24:
LABEL_25:

    return;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v16 = NFLogGetLogger();
  if (v16)
  {
    CFStringRef v17 = (void (*)(uint64_t, const char *, ...))v16;
    int v18 = object_getClass(*(id *)(a1 + 32));
    BOOL v19 = class_isMetaClass(v18);
    __int16 v20 = object_getClassName(*(id *)(a1 + 32));
    int v21 = sel_getName(*(SEL *)(a1 + 56));
    __int16 v22 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v23 = 45;
    if (v19) {
      uint64_t v23 = 43;
    }
    v17(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v23, v20, v21, 494, v22);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v24 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    __int16 v25 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v25)) {
      int v26 = 43;
    }
    else {
      int v26 = 45;
    }
    __int16 v27 = object_getClassName(*(id *)(a1 + 32));
    int v28 = sel_getName(*(SEL *)(a1 + 56));
    __int16 v29 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v84 = v26;
    __int16 v85 = 2082;
    id v86 = v27;
    __int16 v87 = 2082;
    int v88 = v28;
    __int16 v89 = 1024;
    int v90 = 494;
    __int16 v91 = 2114;
    CFStringRef v92 = v29;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v30 = *(void *)(a1 + 48);
  if (v30)
  {
    id v31 = objc_alloc((Class)NSError);
    __int16 v32 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v99 = NSLocalizedDescriptionKey;
    id v33 = +[NSString stringWithUTF8String:"Session not active"];
    id v100 = v33;
    __int16 v34 = +[NSDictionary dictionaryWithObjects:&v100 forKeys:&v99 count:1];
    id v35 = [v31 initWithDomain:v32 code:54 userInfo:v34];
    (*(void (**)(uint64_t, void, id))(v30 + 16))(v30, 0, v35);

    goto LABEL_24;
  }
}

void sub_10016729C(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 522, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    uint64_t v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v15 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)long long buf = 67110146;
    int v99 = v12;
    __int16 v100 = 2082;
    int v101 = v13;
    __int16 v102 = 2082;
    uint64_t v103 = v14;
    __int16 v104 = 1024;
    int v105 = 522;
    __int16 v106 = 2114;
    CFStringRef v107 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    CFStringRef v39 = *(void **)(a1 + 32);
    int v40 = [v39 embeddedSecureElementWrapper];
    LOBYTE(v39) = [v39 _activateSecureElementWrapper:v40];

    if (v39)
    {
      uint64_t v41 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      uint64_t v42 = [v41 handle];
      __int16 v43 = [v42 info];
      unsigned int v44 = [v43 restrictedMode];

      if (!v44)
      {
        id v58 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
        uint64_t v59 = *(void **)(a1 + 40);
        id v95 = 0;
        uint64_t v60 = sub_1001F97B4(v58, v59, 3, &v95);
        id v32 = v95;

        if (v60)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v61 = NFLogGetLogger();
          if (v61)
          {
            uint64_t v62 = (void (*)(uint64_t, const char *, ...))v61;
            __int16 v63 = object_getClass(*(id *)(a1 + 32));
            BOOL v64 = class_isMetaClass(v63);
            int v65 = object_getClassName(*(id *)(a1 + 32));
            NSErrorUserInfoKey v66 = sel_getName(*(SEL *)(a1 + 56));
            if (v60 >= 0x47) {
              int v67 = 71;
            }
            else {
              int v67 = v60;
            }
            int v94 = off_100305838[v67];
            uint64_t v68 = 43;
            if (!v64) {
              uint64_t v68 = 45;
            }
            v62(3, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", v68, v65, v66, 539, @"Returned", v60, v94);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v69 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
          {
            uint64_t v70 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v70)) {
              int v71 = 43;
            }
            else {
              int v71 = 45;
            }
            uint64_t v72 = object_getClassName(*(id *)(a1 + 32));
            id v73 = sel_getName(*(SEL *)(a1 + 56));
            if (v60 >= 0x47) {
              uint64_t v74 = 71;
            }
            else {
              uint64_t v74 = v60;
            }
            id v75 = off_100305838[v74];
            *(_DWORD *)long long buf = 67110658;
            int v99 = v71;
            __int16 v100 = 2082;
            int v101 = v72;
            __int16 v102 = 2082;
            uint64_t v103 = v73;
            __int16 v104 = 1024;
            int v105 = 539;
            __int16 v106 = 2112;
            CFStringRef v107 = @"Returned";
            __int16 v108 = 1024;
            int v109 = v60;
            __int16 v110 = 2080;
            uint64_t v111 = v75;
            _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", buf, 0x3Cu);
          }
          else if (v60 >= 0x47)
          {
            uint64_t v74 = 71;
          }
          else
          {
            uint64_t v74 = v60;
          }

          uint64_t v88 = *(void *)(a1 + 48);
          id v89 = objc_alloc((Class)NSError);
          id v33 = +[NSString stringWithUTF8String:"nfcd"];
          NSErrorUserInfoKey v96 = NSLocalizedDescriptionKey;
          int v90 = +[NSString stringWithUTF8String:off_100305838[v74]];
          NSErrorUserInfoKey v97 = v90;
          __int16 v91 = +[NSDictionary dictionaryWithObjects:&v97 forKeys:&v96 count:1];
          id v92 = [v89 initWithDomain:v33 code:v60 userInfo:v91];
          (*(void (**)(uint64_t, void, void, id))(v88 + 16))(v88, 0, 0, v92);
        }
        else
        {
          id v33 = objc_opt_new();
          uint64_t v76 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
          id v77 = [v76 rsaCertificate];

          if (v77)
          {
            char v78 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
            int v79 = [v78 rsaCertificate];
            [v33 setObject:v79 forKeyedSubscript:@"RSA"];
          }
          id v80 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
          NSErrorUserInfoKey v81 = [v80 eccCertificate];

          if (v81)
          {
            __int16 v82 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
            BOOL v83 = [v82 eccCertificate];
            [v33 setObject:v83 forKeyedSubscript:@"ECDSA"];
          }
          int v84 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
          __int16 v85 = [v84 eckaCertificate];

          if (v85)
          {
            id v86 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
            __int16 v87 = [v86 eckaCertificate];
            [v33 setObject:v87 forKeyedSubscript:@"ECKA"];
          }
          (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
        }
        goto LABEL_25;
      }
      uint64_t v30 = *(void *)(a1 + 48);
      id v45 = objc_alloc((Class)NSError);
      id v32 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v112 = NSLocalizedDescriptionKey;
      id v33 = +[NSString stringWithUTF8String:"Restricted Mode"];
      int v113 = v33;
      __int16 v34 = +[NSDictionary dictionaryWithObjects:&v113 forKeys:&v112 count:1];
      id v35 = v45;
      id v36 = v32;
      uint64_t v37 = 24;
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v46 = NFLogGetLogger();
      if (v46)
      {
        __int16 v47 = (void (*)(uint64_t, const char *, ...))v46;
        int v48 = object_getClass(*(id *)(a1 + 32));
        BOOL v49 = class_isMetaClass(v48);
        id v50 = object_getClassName(*(id *)(a1 + 32));
        __int16 v93 = sel_getName(*(SEL *)(a1 + 56));
        uint64_t v51 = 45;
        if (v49) {
          uint64_t v51 = 43;
        }
        v47(3, "%c[%{public}s %{public}s]:%i Failed to activate embedded secure element", v51, v50, v93, 527);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v52 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
      {
        __int16 v53 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v53)) {
          int v54 = 43;
        }
        else {
          int v54 = 45;
        }
        uint64_t v55 = object_getClassName(*(id *)(a1 + 32));
        BOOL v56 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)long long buf = 67109890;
        int v99 = v54;
        __int16 v100 = 2082;
        int v101 = v55;
        __int16 v102 = 2082;
        uint64_t v103 = v56;
        __int16 v104 = 1024;
        int v105 = 527;
        _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to activate embedded secure element", buf, 0x22u);
      }

      uint64_t v30 = *(void *)(a1 + 48);
      id v57 = objc_alloc((Class)NSError);
      id v32 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v114 = NSLocalizedDescriptionKey;
      id v33 = +[NSString stringWithUTF8String:"Stack Error"];
      uint64_t v115 = v33;
      __int16 v34 = +[NSDictionary dictionaryWithObjects:&v115 forKeys:&v114 count:1];
      id v35 = v57;
      id v36 = v32;
      uint64_t v37 = 15;
    }
LABEL_24:
    id v38 = [v35 initWithDomain:v36 code:v37 userInfo:v34];
    (*(void (**)(uint64_t, void, void, id))(v30 + 16))(v30, 0, 0, v38);

LABEL_25:
    return;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v16 = NFLogGetLogger();
  if (v16)
  {
    CFStringRef v17 = (void (*)(uint64_t, const char *, ...))v16;
    int v18 = object_getClass(*(id *)(a1 + 32));
    BOOL v19 = class_isMetaClass(v18);
    __int16 v20 = object_getClassName(*(id *)(a1 + 32));
    int v21 = sel_getName(*(SEL *)(a1 + 56));
    __int16 v22 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v23 = 45;
    if (v19) {
      uint64_t v23 = 43;
    }
    v17(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v23, v20, v21, 524, v22);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v24 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    __int16 v25 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v25)) {
      int v26 = 43;
    }
    else {
      int v26 = 45;
    }
    __int16 v27 = object_getClassName(*(id *)(a1 + 32));
    int v28 = sel_getName(*(SEL *)(a1 + 56));
    __int16 v29 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v99 = v26;
    __int16 v100 = 2082;
    int v101 = v27;
    __int16 v102 = 2082;
    uint64_t v103 = v28;
    __int16 v104 = 1024;
    int v105 = 524;
    __int16 v106 = 2114;
    CFStringRef v107 = v29;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v30 = *(void *)(a1 + 48);
  if (v30)
  {
    id v31 = objc_alloc((Class)NSError);
    id v32 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v116 = NSLocalizedDescriptionKey;
    id v33 = +[NSString stringWithUTF8String:"Session not active"];
    id v117 = v33;
    __int16 v34 = +[NSDictionary dictionaryWithObjects:&v117 forKeys:&v116 count:1];
    id v35 = v31;
    id v36 = v32;
    uint64_t v37 = 54;
    goto LABEL_24;
  }
}

void sub_100167DF8(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 557, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    uint64_t v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v15 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)long long buf = 67110146;
    int v121 = v12;
    __int16 v122 = 2082;
    int v123 = v13;
    __int16 v124 = 2082;
    NSErrorUserInfoKey v125 = v14;
    __int16 v126 = 1024;
    int v127 = 557;
    __int16 v128 = 2114;
    CFStringRef v129 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    CFStringRef v39 = *(void **)(a1 + 32);
    int v40 = [v39 embeddedSecureElementWrapper];
    LOBYTE(v39) = [v39 _activateSecureElementWrapper:v40];

    if ((v39 & 1) == 0)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v46 = NFLogGetLogger();
      if (v46)
      {
        __int16 v47 = (void (*)(uint64_t, const char *, ...))v46;
        int v48 = object_getClass(*(id *)(a1 + 32));
        BOOL v49 = class_isMetaClass(v48);
        id v50 = object_getClassName(*(id *)(a1 + 32));
        NSErrorUserInfoKey v112 = sel_getName(*(SEL *)(a1 + 56));
        uint64_t v51 = 45;
        if (v49) {
          uint64_t v51 = 43;
        }
        v47(3, "%c[%{public}s %{public}s]:%i Failed to activate embedded secure element", v51, v50, v112, 562);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v52 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
      {
        __int16 v53 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v53)) {
          int v54 = 43;
        }
        else {
          int v54 = 45;
        }
        uint64_t v55 = object_getClassName(*(id *)(a1 + 32));
        BOOL v56 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)long long buf = 67109890;
        int v121 = v54;
        __int16 v122 = 2082;
        int v123 = v55;
        __int16 v124 = 2082;
        NSErrorUserInfoKey v125 = v56;
        __int16 v126 = 1024;
        int v127 = 562;
        _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to activate embedded secure element", buf, 0x22u);
      }

      uint64_t v30 = *(void *)(a1 + 48);
      id v57 = objc_alloc((Class)NSError);
      id v32 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v138 = NSLocalizedDescriptionKey;
      id v33 = +[NSString stringWithUTF8String:"Stack Error"];
      id v139 = v33;
      __int16 v34 = +[NSDictionary dictionaryWithObjects:&v139 forKeys:&v138 count:1];
      id v35 = v57;
      id v36 = v32;
      uint64_t v37 = 15;
      goto LABEL_24;
    }
    uint64_t v41 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
    uint64_t v42 = [v41 handle];
    __int16 v43 = [v42 info];
    unsigned int v44 = [v43 restrictedMode];

    if (v44)
    {
      uint64_t v30 = *(void *)(a1 + 48);
      id v45 = objc_alloc((Class)NSError);
      id v32 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v136 = NSLocalizedDescriptionKey;
      id v33 = +[NSString stringWithUTF8String:"Restricted Mode"];
      id v137 = v33;
      __int16 v34 = +[NSDictionary dictionaryWithObjects:&v137 forKeys:&v136 count:1];
      id v35 = v45;
      id v36 = v32;
      uint64_t v37 = 24;
      goto LABEL_24;
    }
    id v32 = objc_opt_new();
    id v58 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
    uint64_t v59 = [v58 rsaCertificate];
    [v32 setObject:v59 forKeyedSubscript:@"rsa"];

    uint64_t v60 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
    uint64_t v61 = [v60 eccCertificate];
    [v32 setObject:v61 forKeyedSubscript:@"ecc"];

    uint64_t v62 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
    __int16 v63 = [v62 eckaCertificate];
    [v32 setObject:v63 forKeyedSubscript:@"ecka"];

    BOOL v64 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
    int v65 = [v64 serialNumber];
    [v32 setObject:v65 forKeyedSubscript:@"seid"];

    [v32 setObject:&off_10031C6A8 forKeyedSubscript:@"certVersion"];
    LODWORD(v64) = *(unsigned __int8 *)(a1 + 64);
    NSErrorUserInfoKey v66 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
    int v67 = v66;
    uint64_t v68 = *(void **)(a1 + 40);
    if (!v64)
    {
      id v116 = 0;
      uint64_t v77 = sub_1001F97B4(v66, v68, 3, &v116);
      id v33 = v116;

      if (v77)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v78 = NFLogGetLogger();
        if (v78)
        {
          int v79 = (void (*)(uint64_t, const char *, ...))v78;
          id v80 = object_getClass(*(id *)(a1 + 32));
          BOOL v81 = class_isMetaClass(v80);
          __int16 v82 = object_getClassName(*(id *)(a1 + 32));
          BOOL v83 = sel_getName(*(SEL *)(a1 + 56));
          if (v77 >= 0x47) {
            int v84 = 71;
          }
          else {
            int v84 = v77;
          }
          int v113 = off_100305838[v84];
          uint64_t v85 = 43;
          if (!v81) {
            uint64_t v85 = 45;
          }
          v79(3, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", v85, v82, v83, 610, @"Returned", v77, v113);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v86 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
        {
          __int16 v87 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v87)) {
            int v88 = 43;
          }
          else {
            int v88 = 45;
          }
          id v89 = object_getClassName(*(id *)(a1 + 32));
          int v90 = sel_getName(*(SEL *)(a1 + 56));
          if (v77 >= 0x47) {
            uint64_t v91 = 71;
          }
          else {
            uint64_t v91 = v77;
          }
          id v92 = off_100305838[v91];
          *(_DWORD *)long long buf = 67110658;
          int v121 = v88;
          __int16 v122 = 2082;
          int v123 = v89;
          __int16 v124 = 2082;
          NSErrorUserInfoKey v125 = v90;
          __int16 v126 = 1024;
          int v127 = 610;
          __int16 v128 = 2112;
          CFStringRef v129 = @"Returned";
          __int16 v130 = 1024;
          int v131 = v77;
          __int16 v132 = 2080;
          unsigned int v133 = v92;
          _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", buf, 0x3Cu);
        }
        else if (v77 >= 0x47)
        {
          uint64_t v91 = 71;
        }
        else
        {
          uint64_t v91 = v77;
        }

        uint64_t v95 = *(void *)(a1 + 48);
        id v96 = objc_alloc((Class)NSError);
        __int16 v34 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v118 = NSLocalizedDescriptionKey;
        NSErrorUserInfoKey v97 = +[NSString stringWithUTF8String:off_100305838[v91]];
        long long v119 = v97;
        uint64_t v98 = +[NSDictionary dictionaryWithObjects:&v119 forKeys:&v118 count:1];
        id v99 = [v96 initWithDomain:v34 code:v77 userInfo:v98];
        (*(void (**)(uint64_t, void, void, id))(v95 + 16))(v95, 0, 0, v99);
      }
      else
      {
        __int16 v34 = [[NFSignatureInfo alloc] initWithDictionary:v32];
        (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
      }
      goto LABEL_25;
    }
    id v117 = 0;
    unsigned int v69 = sub_1001FD620((uint64_t)v66, v68, &v117);
    id v33 = v117;

    if (v69)
    {
      uint64_t v70 = *(void *)(a1 + 48);
      id v71 = objc_alloc((Class)NSError);
      __int16 v34 = +[NSString stringWithUTF8String:"nfcd"];
      uint64_t v72 = v69;
      NSErrorUserInfoKey v134 = NSLocalizedDescriptionKey;
      if (v69 >= 0x47) {
        int v73 = 71;
      }
      else {
        int v73 = v69;
      }
      uint64_t v74 = +[NSString stringWithUTF8String:off_100305838[v73]];
      int v135 = v74;
      id v75 = +[NSDictionary dictionaryWithObjects:&v135 forKeys:&v134 count:1];
      id v76 = [v71 initWithDomain:v34 code:v72 userInfo:v75];
      (*(void (**)(uint64_t, void, void, id))(v70 + 16))(v70, 0, 0, v76);

LABEL_78:
      goto LABEL_25;
    }
    __int16 v93 = [v33 objectForKeyedSubscript:@"kPlatformId"];

    if (v93)
    {
      int v94 = [v33 objectForKeyedSubscript:@"kPlatformId"];
      [v32 setObject:v94 forKeyedSubscript:@"platformid"];
    }
    else
    {
      int v94 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      uint64_t v100 = [v94 handle];
      if (v100)
      {
        int v101 = (void *)v100;
        __int16 v102 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
        uint64_t v103 = [v102 handle];
        uint64_t v104 = [v103 info];
        if (v104)
        {
          int v105 = (void *)v104;
          NSErrorUserInfoKey v114 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
          __int16 v106 = [v114 handle];
          [v106 info];
          v107 = uint64_t v115 = v102;
          __int16 v108 = [v107 platformIdentifier];

          if (!v108)
          {
LABEL_75:
            int v109 = [v33 objectForKeyedSubscript:@"jsblSequenceCounter"];

            if (v109)
            {
              __int16 v110 = [v33 objectForKeyedSubscript:@"jsblSequenceCounter"];
              [v32 setObject:v110 forKeyedSubscript:@"jsblCounter"];
            }
            __int16 v34 = [[NFSignatureInfo alloc] initWithDictionary:v32];
            uint64_t v111 = *(void *)(a1 + 48);
            uint64_t v74 = [v33 objectForKeyedSubscript:@"SignedResponse"];
            (*(void (**)(uint64_t, void *, NFSignatureInfo *, void))(v111 + 16))(v111, v74, v34, 0);
            goto LABEL_78;
          }
          int v94 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
          int v101 = [v94 handle];
          __int16 v102 = [v101 info];
          uint64_t v103 = [v102 platformIdentifier];
          [v32 setObject:v103 forKeyedSubscript:@"platformid"];
        }
      }
    }

    goto LABEL_75;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v16 = NFLogGetLogger();
  if (v16)
  {
    CFStringRef v17 = (void (*)(uint64_t, const char *, ...))v16;
    int v18 = object_getClass(*(id *)(a1 + 32));
    BOOL v19 = class_isMetaClass(v18);
    __int16 v20 = object_getClassName(*(id *)(a1 + 32));
    int v21 = sel_getName(*(SEL *)(a1 + 56));
    __int16 v22 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v23 = 45;
    if (v19) {
      uint64_t v23 = 43;
    }
    v17(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v23, v20, v21, 559, v22);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v24 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    __int16 v25 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v25)) {
      int v26 = 43;
    }
    else {
      int v26 = 45;
    }
    __int16 v27 = object_getClassName(*(id *)(a1 + 32));
    int v28 = sel_getName(*(SEL *)(a1 + 56));
    __int16 v29 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v121 = v26;
    __int16 v122 = 2082;
    int v123 = v27;
    __int16 v124 = 2082;
    NSErrorUserInfoKey v125 = v28;
    __int16 v126 = 1024;
    int v127 = 559;
    __int16 v128 = 2114;
    CFStringRef v129 = v29;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v30 = *(void *)(a1 + 48);
  if (v30)
  {
    id v31 = objc_alloc((Class)NSError);
    id v32 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v140 = NSLocalizedDescriptionKey;
    id v33 = +[NSString stringWithUTF8String:"Session not active"];
    id v141 = v33;
    __int16 v34 = +[NSDictionary dictionaryWithObjects:&v141 forKeys:&v140 count:1];
    id v35 = v31;
    id v36 = v32;
    uint64_t v37 = 54;
LABEL_24:
    id v38 = [v35 initWithDomain:v36 code:v37 userInfo:v34];
    (*(void (**)(uint64_t, void, void, id))(v30 + 16))(v30, 0, 0, v38);

LABEL_25:
  }
}

void sub_100168C78(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 64));
    uint64_t v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 626, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    uint64_t v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 64));
    uint64_t v15 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)long long buf = 67110146;
    int v128 = v12;
    __int16 v129 = 2082;
    __int16 v130 = v13;
    __int16 v131 = 2082;
    __int16 v132 = v14;
    __int16 v133 = 1024;
    int v134 = 626;
    __int16 v135 = 2114;
    CFStringRef v136 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    id v32 = [*(id *)(a1 + 32) _getSecureElementForAID:*(void *)(a1 + 40)];
    if (([*(id *)(a1 + 32) _activateSecureElementWrapper:v32] & 1) == 0)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v45 = NFLogGetLogger();
      if (v45)
      {
        uint64_t v46 = (void (*)(uint64_t, const char *, ...))v45;
        __int16 v47 = object_getClass(*(id *)(a1 + 32));
        BOOL v48 = class_isMetaClass(v47);
        BOOL v49 = object_getClassName(*(id *)(a1 + 32));
        __int16 v122 = sel_getName(*(SEL *)(a1 + 64));
        uint64_t v50 = 45;
        if (v48) {
          uint64_t v50 = 43;
        }
        v46(3, "%c[%{public}s %{public}s]:%i Failed to activate secure element", v50, v49, v122, 633);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v51 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
      {
        int v52 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v52)) {
          int v53 = 43;
        }
        else {
          int v53 = 45;
        }
        int v54 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v55 = sel_getName(*(SEL *)(a1 + 64));
        *(_DWORD *)long long buf = 67109890;
        int v128 = v53;
        __int16 v129 = 2082;
        __int16 v130 = v54;
        __int16 v131 = 2082;
        __int16 v132 = v55;
        __int16 v133 = 1024;
        int v134 = 633;
        _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to activate secure element", buf, 0x22u);
      }

      uint64_t v40 = *(void *)(a1 + 56);
      id v56 = objc_alloc((Class)NSError);
      id v33 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v143 = NSLocalizedDescriptionKey;
      __int16 v34 = +[NSString stringWithUTF8String:"Stack Error"];
      int v144 = v34;
      id v35 = +[NSDictionary dictionaryWithObjects:&v144 forKeys:&v143 count:1];
      uint64_t v42 = v56;
      id v43 = v33;
      uint64_t v44 = 15;
      goto LABEL_39;
    }
    id v36 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
    uint64_t v37 = [v36 handle];
    id v38 = [v37 info];
    unsigned int v39 = [v38 restrictedMode];

    if (v39)
    {
      uint64_t v40 = *(void *)(a1 + 56);
      id v41 = objc_alloc((Class)NSError);
      id v33 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v141 = NSLocalizedDescriptionKey;
      __int16 v34 = +[NSString stringWithUTF8String:"Restricted Mode"];
      id v142 = v34;
      id v35 = +[NSDictionary dictionaryWithObjects:&v142 forKeys:&v141 count:1];
      uint64_t v42 = v41;
      id v43 = v33;
      uint64_t v44 = 24;
LABEL_39:
      id v57 = [v42 initWithDomain:v43 code:v44 userInfo:v35];
      (*(void (**)(uint64_t, void, void, id))(v40 + 16))(v40, 0, 0, v57);

      goto LABEL_24;
    }
    id v58 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
    uint64_t v59 = *(void **)(a1 + 48);
    id v124 = 0;
    uint64_t v60 = sub_1001F97B4(v58, v59, 3, &v124);
    id v33 = v124;

    if (v60)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v61 = NFLogGetLogger();
      if (v61)
      {
        uint64_t v62 = (void (*)(uint64_t, const char *, ...))v61;
        __int16 v63 = object_getClass(*(id *)(a1 + 32));
        BOOL v64 = class_isMetaClass(v63);
        int v65 = object_getClassName(*(id *)(a1 + 32));
        NSErrorUserInfoKey v66 = sel_getName(*(SEL *)(a1 + 64));
        if (v60 >= 0x47) {
          int v67 = 71;
        }
        else {
          int v67 = v60;
        }
        int v123 = off_100305838[v67];
        uint64_t v68 = 43;
        if (!v64) {
          uint64_t v68 = 45;
        }
        v62(3, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", v68, v65, v66, 645, @"Returned", v60, v123);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      unsigned int v69 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v69, OS_LOG_TYPE_ERROR))
      {
        uint64_t v70 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v70)) {
          int v71 = 43;
        }
        else {
          int v71 = 45;
        }
        uint64_t v72 = object_getClassName(*(id *)(a1 + 32));
        int v73 = sel_getName(*(SEL *)(a1 + 64));
        if (v60 >= 0x47) {
          uint64_t v74 = 71;
        }
        else {
          uint64_t v74 = v60;
        }
        id v75 = off_100305838[v74];
        *(_DWORD *)long long buf = 67110658;
        int v128 = v71;
        __int16 v129 = 2082;
        __int16 v130 = v72;
        __int16 v131 = 2082;
        __int16 v132 = v73;
        __int16 v133 = 1024;
        int v134 = 645;
        __int16 v135 = 2112;
        CFStringRef v136 = @"Returned";
        __int16 v137 = 1024;
        int v138 = v60;
        __int16 v139 = 2080;
        NSErrorUserInfoKey v140 = v75;
        _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i %@ err=%d \"%s\"", buf, 0x3Cu);
      }
      else if (v60 >= 0x47)
      {
        uint64_t v74 = 71;
      }
      else
      {
        uint64_t v74 = v60;
      }

      uint64_t v117 = *(void *)(a1 + 56);
      id v118 = objc_alloc((Class)NSError);
      __int16 v34 = +[NSString stringWithUTF8String:"nfcd"];
      uint64_t v119 = v60;
      NSErrorUserInfoKey v125 = NSLocalizedDescriptionKey;
      id v35 = +[NSString stringWithUTF8String:off_100305838[v74]];
      __int16 v126 = v35;
      long long v120 = +[NSDictionary dictionaryWithObjects:&v126 forKeys:&v125 count:1];
      id v121 = [v118 initWithDomain:v34 code:v119 userInfo:v120];
      (*(void (**)(uint64_t, void, void, id))(v117 + 16))(v117, 0, 0, v121);

      goto LABEL_24;
    }
    __int16 v34 = objc_opt_new();
    id v76 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
    uint64_t v77 = [v76 rsaCertificate];

    if (v77)
    {
      uint64_t v78 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      int v79 = [v78 rsaCertificate];
      [v34 setObject:v79 forKeyedSubscript:@"rsa"];
    }
    id v80 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
    BOOL v81 = [v80 eccCertificate];

    if (v81)
    {
      __int16 v82 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      BOOL v83 = [v82 eccCertificate];
      [v34 setObject:v83 forKeyedSubscript:@"ecc"];
    }
    int v84 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
    uint64_t v85 = [v84 eckaCertificate];

    if (v85)
    {
      id v86 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      __int16 v87 = [v86 eckaCertificate];
      [v34 setObject:v87 forKeyedSubscript:@"ecka"];
    }
    [v34 setObject:&off_10031C6A8 forKeyedSubscript:@"certVersion"];
    int v88 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
    uint64_t v89 = [v88 handle];
    if (v89)
    {
      int v90 = (void *)v89;
      uint64_t v91 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      id v92 = [v91 handle];
      __int16 v93 = [v92 info];

      if (!v93) {
        goto LABEL_71;
      }
      int v94 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      uint64_t v95 = [v94 handle];
      id v96 = [v95 info];
      NSErrorUserInfoKey v97 = [v96 serialNumber];

      if (v97)
      {
        uint64_t v98 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
        id v99 = [v98 serialNumber];
        [v34 setObject:v99 forKeyedSubscript:@"seid"];
      }
      uint64_t v100 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      int v101 = [v100 handle];
      __int16 v102 = [v101 info];
      uint64_t v103 = [v102 platformIdentifier];

      if (v103)
      {
        uint64_t v104 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
        int v105 = [v104 handle];
        __int16 v106 = [v105 info];
        CFStringRef v107 = [v106 platformIdentifier];
        [v34 setObject:v107 forKeyedSubscript:@"platformid"];
      }
      __int16 v108 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      int v109 = [v108 handle];
      __int16 v110 = [v109 info];
      uint64_t v111 = [v110 sequenceCounter];

      if (!v111) {
        goto LABEL_71;
      }
      id v112 = objc_alloc((Class)NSString);
      int v88 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      int v113 = [v88 handle];
      NSErrorUserInfoKey v114 = [v113 info];
      uint64_t v115 = [v114 sequenceCounter];
      id v116 = [[v112 initWithFormat:@"%X", [v115 intValue]];
      [v34 setObject:v116 forKeyedSubscript:@"jsblCounter"];
    }
LABEL_71:
    id v35 = [[NFSignatureInfo alloc] initWithDictionary:v34];
    (*(void (**)(void, id, NFSignatureInfo *, void))(*(void *)(a1 + 56) + 16))(*(void *)(a1 + 56), v33, v35, 0);
    goto LABEL_24;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v16 = NFLogGetLogger();
  if (v16)
  {
    CFStringRef v17 = (void (*)(uint64_t, const char *, ...))v16;
    int v18 = object_getClass(*(id *)(a1 + 32));
    BOOL v19 = class_isMetaClass(v18);
    __int16 v20 = object_getClassName(*(id *)(a1 + 32));
    int v21 = sel_getName(*(SEL *)(a1 + 64));
    __int16 v22 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v23 = 45;
    if (v19) {
      uint64_t v23 = 43;
    }
    v17(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v23, v20, v21, 628, v22);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v24 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    __int16 v25 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v25)) {
      int v26 = 43;
    }
    else {
      int v26 = 45;
    }
    __int16 v27 = object_getClassName(*(id *)(a1 + 32));
    int v28 = sel_getName(*(SEL *)(a1 + 64));
    __int16 v29 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v128 = v26;
    __int16 v129 = 2082;
    __int16 v130 = v27;
    __int16 v131 = 2082;
    __int16 v132 = v28;
    __int16 v133 = 1024;
    int v134 = 628;
    __int16 v135 = 2114;
    CFStringRef v136 = v29;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v30 = *(void *)(a1 + 56);
  if (v30)
  {
    id v31 = objc_alloc((Class)NSError);
    id v32 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v145 = NSLocalizedDescriptionKey;
    id v33 = +[NSString stringWithUTF8String:"Session not active"];
    id v146 = v33;
    __int16 v34 = +[NSDictionary dictionaryWithObjects:&v146 forKeys:&v145 count:1];
    id v35 = (NFSignatureInfo *)[v31 initWithDomain:v32 code:54 userInfo:v34];
    (*(void (**)(uint64_t, void, void, NFSignatureInfo *))(v30 + 16))(v30, 0, 0, v35);
LABEL_24:
  }
}

void sub_100169A64(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 681, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    uint64_t v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v15 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)long long buf = 67110146;
    int v60 = v12;
    __int16 v61 = 2082;
    uint64_t v62 = v13;
    __int16 v63 = 2082;
    BOOL v64 = v14;
    __int16 v65 = 1024;
    int v66 = 681;
    __int16 v67 = 2114;
    uint64_t v68 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    id v32 = [*(id *)(a1 + 32) _getSecureElementWrapperForSEID:*(void *)(a1 + 40)];
    if ([*(id *)(a1 + 32) _activateSecureElementWrapper:v32])
    {
      unsigned int v39 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      uint64_t v40 = [v39 handle];
      id v41 = [v40 info];
      unsigned int v42 = [v41 restrictedMode];

      if (!v42)
      {
        uint64_t v50 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
        id v51 = 0;
        id v52 = 0;
        id v33 = sub_1001F9EEC(v50, &v52, &v51);
        id v34 = v52;
        id v35 = v51;

        uint64_t v37 = *(void *)(a1 + 48);
        id v36 = *(void (**)(void))(v37 + 16);
        if (!v33 && v34 && v35)
        {
          v36();
          id v33 = 0;
          goto LABEL_25;
        }
        id v38 = v33;
        goto LABEL_24;
      }
      uint64_t v43 = *(void *)(a1 + 48);
      id v44 = objc_alloc((Class)NSError);
      id v33 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v53 = NSLocalizedDescriptionKey;
      id v34 = +[NSString stringWithUTF8String:"Restricted Mode"];
      id v54 = v34;
      id v35 = +[NSDictionary dictionaryWithObjects:&v54 forKeys:&v53 count:1];
      uint64_t v45 = v44;
      uint64_t v46 = v33;
      uint64_t v47 = 24;
    }
    else
    {
      uint64_t v43 = *(void *)(a1 + 48);
      id v48 = objc_alloc((Class)NSError);
      id v33 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v55 = NSLocalizedDescriptionKey;
      id v34 = +[NSString stringWithUTF8String:"Stack Error"];
      id v56 = v34;
      id v35 = +[NSDictionary dictionaryWithObjects:&v56 forKeys:&v55 count:1];
      uint64_t v45 = v48;
      uint64_t v46 = v33;
      uint64_t v47 = 15;
    }
    id v49 = [v45 initWithDomain:v46 code:v47 userInfo:v35];
    (*(void (**)(uint64_t, void, void, id))(v43 + 16))(v43, 0, 0, v49);

    goto LABEL_25;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v16 = NFLogGetLogger();
  if (v16)
  {
    CFStringRef v17 = (void (*)(uint64_t, const char *, ...))v16;
    int v18 = object_getClass(*(id *)(a1 + 32));
    BOOL v19 = class_isMetaClass(v18);
    __int16 v20 = object_getClassName(*(id *)(a1 + 32));
    int v21 = sel_getName(*(SEL *)(a1 + 56));
    __int16 v22 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v23 = 45;
    if (v19) {
      uint64_t v23 = 43;
    }
    v17(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v23, v20, v21, 683, v22);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v24 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    __int16 v25 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v25)) {
      int v26 = 43;
    }
    else {
      int v26 = 45;
    }
    __int16 v27 = object_getClassName(*(id *)(a1 + 32));
    int v28 = sel_getName(*(SEL *)(a1 + 56));
    __int16 v29 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v60 = v26;
    __int16 v61 = 2082;
    uint64_t v62 = v27;
    __int16 v63 = 2082;
    BOOL v64 = v28;
    __int16 v65 = 1024;
    int v66 = 683;
    __int16 v67 = 2114;
    uint64_t v68 = v29;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v30 = *(void *)(a1 + 48);
  if (v30)
  {
    id v31 = objc_alloc((Class)NSError);
    id v32 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v57 = NSLocalizedDescriptionKey;
    id v33 = +[NSString stringWithUTF8String:"Session not active"];
    id v58 = v33;
    id v34 = +[NSDictionary dictionaryWithObjects:&v58 forKeys:&v57 count:1];
    id v35 = [v31 initWithDomain:v32 code:54 userInfo:v34];
    id v36 = *(void (**)(void))(v30 + 16);
    uint64_t v37 = v30;
    id v38 = v35;
LABEL_24:
    ((void (*)(uint64_t, void, void, id))v36)(v37, 0, 0, v38);
LABEL_25:
  }
}

void sub_10016A158(uint64_t a1)
{
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    __int16 v25 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
    int v26 = [v25 handle];
    __int16 v27 = [v26 info];
    unsigned int v28 = [v27 restrictedMode];

    if (!v28)
    {
      uint64_t v30 = *(void **)(a1 + 32);
      id v31 = 0;
      BOOL v19 = [v30 _getAllApplets:&v31];
      id v18 = v31;
      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
      goto LABEL_16;
    }
    uint64_t v16 = *(void *)(a1 + 40);
    id v29 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v32 = NSLocalizedDescriptionKey;
    BOOL v19 = +[NSString stringWithUTF8String:"Restricted Mode"];
    id v33 = v19;
    __int16 v20 = +[NSDictionary dictionaryWithObjects:&v33 forKeys:&v32 count:1];
    int v21 = v29;
    id v22 = v18;
    uint64_t v23 = 24;
LABEL_15:
    id v24 = [v21 initWithDomain:v22 code:v23 userInfo:v20];
    (*(void (**)(uint64_t, void, id))(v16 + 16))(v16, 0, v24);

LABEL_16:
    return;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 718, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    int v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    uint64_t v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v15 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v37 = v12;
    __int16 v38 = 2082;
    unsigned int v39 = v13;
    __int16 v40 = 2082;
    id v41 = v14;
    __int16 v42 = 1024;
    int v43 = 718;
    __int16 v44 = 2114;
    uint64_t v45 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v16 = *(void *)(a1 + 40);
  if (v16)
  {
    id v17 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v34 = NSLocalizedDescriptionKey;
    BOOL v19 = +[NSString stringWithUTF8String:"Session not active"];
    id v35 = v19;
    __int16 v20 = +[NSDictionary dictionaryWithObjects:&v35 forKeys:&v34 count:1];
    int v21 = v17;
    id v22 = v18;
    uint64_t v23 = 54;
    goto LABEL_15;
  }
}

void sub_10016A614(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 744, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    uint64_t v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v15 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)long long buf = 67110146;
    int v95 = v12;
    __int16 v96 = 2082;
    NSErrorUserInfoKey v97 = v13;
    __int16 v98 = 2082;
    id v99 = v14;
    __int16 v100 = 1024;
    int v101 = 744;
    __int16 v102 = 2114;
    uint64_t v103 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    unsigned int v39 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
    __int16 v40 = [v39 handle];
    id v41 = [v40 info];
    unsigned int v42 = [v41 restrictedMode];

    if (!v42)
    {
      long long v85 = 0u;
      long long v86 = 0u;
      long long v83 = 0u;
      long long v84 = 0u;
      id v32 = *(id *)(a1 + 40);
      __int16 v44 = (char *)[v32 countByEnumeratingWithState:&v83 objects:v89 count:16];
      if (v44)
      {
        uint64_t v45 = v44;
        uint64_t v46 = *(void *)v84;
        while (2)
        {
          for (i = 0; i != v45; ++i)
          {
            if (*(void *)v84 != v46) {
              objc_enumerationMutation(v32);
            }
            objc_opt_class();
            if ((objc_opt_isKindOfClass() & 1) == 0)
            {
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v62 = NFLogGetLogger();
              if (v62)
              {
                __int16 v63 = (void (*)(uint64_t, const char *, ...))v62;
                BOOL v64 = object_getClass(*(id *)(a1 + 32));
                BOOL v65 = class_isMetaClass(v64);
                int v66 = object_getClassName(*(id *)(a1 + 32));
                BOOL v81 = sel_getName(*(SEL *)(a1 + 56));
                uint64_t v67 = 45;
                if (v65) {
                  uint64_t v67 = 43;
                }
                v63(3, "%c[%{public}s %{public}s]:%i Invalid type for applet.", v67, v66, v81, 756);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v68 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
              {
                unsigned int v69 = object_getClass(*(id *)(a1 + 32));
                if (class_isMetaClass(v69)) {
                  int v70 = 43;
                }
                else {
                  int v70 = 45;
                }
                int v71 = object_getClassName(*(id *)(a1 + 32));
                uint64_t v72 = sel_getName(*(SEL *)(a1 + 56));
                *(_DWORD *)long long buf = 67109890;
                int v95 = v70;
                __int16 v96 = 2082;
                NSErrorUserInfoKey v97 = v71;
                __int16 v98 = 2082;
                id v99 = v72;
                __int16 v100 = 1024;
                int v101 = 756;
                _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid type for applet.", buf, 0x22u);
              }

              uint64_t v73 = *(void *)(a1 + 48);
              id v74 = objc_alloc((Class)NSError);
              id v75 = +[NSString stringWithUTF8String:"nfcd"];
              NSErrorUserInfoKey v87 = NSLocalizedDescriptionKey;
              id v76 = +[NSString stringWithUTF8String:"Invalid Parameter"];
              int v88 = v76;
              uint64_t v77 = +[NSDictionary dictionaryWithObjects:&v88 forKeys:&v87 count:1];
              id v78 = [v74 initWithDomain:v75 code:10 userInfo:v77];
              (*(void (**)(uint64_t, void, id))(v73 + 16))(v73, 0, v78);

              goto LABEL_25;
            }
          }
          uint64_t v45 = (char *)[v32 countByEnumeratingWithState:&v83 objects:v89 count:16];
          if (v45) {
            continue;
          }
          break;
        }
      }

      id v48 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      sub_100245A08(v48, *(void **)(a1 + 40));
      id v32 = (id)objc_claimAutoreleasedReturnValue();

      if (v32)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v49 = NFLogGetLogger();
        if (v49)
        {
          uint64_t v50 = (void (*)(uint64_t, const char *, ...))v49;
          id v51 = object_getClass(*(id *)(a1 + 32));
          BOOL v52 = class_isMetaClass(v51);
          NSErrorUserInfoKey v53 = object_getClassName(*(id *)(a1 + 32));
          id v54 = sel_getName(*(SEL *)(a1 + 56));
          uint64_t v55 = 45;
          if (v52) {
            uint64_t v55 = 43;
          }
          v50(3, "%c[%{public}s %{public}s]:%i Failed to delete applets from embedded SE %{public}@", v55, v53, v54, 764, *(void *)(a1 + 40));
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v56 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v56, OS_LOG_TYPE_ERROR))
        {
          NSErrorUserInfoKey v57 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v57)) {
            int v58 = 43;
          }
          else {
            int v58 = 45;
          }
          uint64_t v59 = object_getClassName(*(id *)(a1 + 32));
          int v60 = sel_getName(*(SEL *)(a1 + 56));
          __int16 v61 = *(void **)(a1 + 40);
          *(_DWORD *)long long buf = 67110146;
          int v95 = v58;
          __int16 v96 = 2082;
          NSErrorUserInfoKey v97 = v59;
          __int16 v98 = 2082;
          id v99 = v60;
          __int16 v100 = 1024;
          int v101 = 764;
          __int16 v102 = 2114;
          uint64_t v103 = v61;
          _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to delete applets from embedded SE %{public}@", buf, 0x2Cu);
        }

        (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
      }
      else
      {
        int v79 = *(void **)(a1 + 32);
        id v82 = 0;
        id v80 = [v79 _getAllApplets:&v82];
        id v32 = v82;
        (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
      }
      goto LABEL_25;
    }
    uint64_t v30 = *(void *)(a1 + 48);
    id v43 = objc_alloc((Class)NSError);
    id v32 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v90 = NSLocalizedDescriptionKey;
    id v33 = +[NSString stringWithUTF8String:"Restricted Mode"];
    uint64_t v91 = v33;
    NSErrorUserInfoKey v34 = +[NSDictionary dictionaryWithObjects:&v91 forKeys:&v90 count:1];
    id v35 = v43;
    id v36 = v32;
    uint64_t v37 = 24;
LABEL_24:
    id v38 = [v35 initWithDomain:v36 code:v37 userInfo:v34];
    (*(void (**)(uint64_t, void, id))(v30 + 16))(v30, 0, v38);

LABEL_25:
    return;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v16 = NFLogGetLogger();
  if (v16)
  {
    id v17 = (void (*)(uint64_t, const char *, ...))v16;
    id v18 = object_getClass(*(id *)(a1 + 32));
    BOOL v19 = class_isMetaClass(v18);
    __int16 v20 = object_getClassName(*(id *)(a1 + 32));
    int v21 = sel_getName(*(SEL *)(a1 + 56));
    id v22 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v23 = 45;
    if (v19) {
      uint64_t v23 = 43;
    }
    v17(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v23, v20, v21, 746, v22);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v24 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    __int16 v25 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v25)) {
      int v26 = 43;
    }
    else {
      int v26 = 45;
    }
    __int16 v27 = object_getClassName(*(id *)(a1 + 32));
    unsigned int v28 = sel_getName(*(SEL *)(a1 + 56));
    id v29 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v95 = v26;
    __int16 v96 = 2082;
    NSErrorUserInfoKey v97 = v27;
    __int16 v98 = 2082;
    id v99 = v28;
    __int16 v100 = 1024;
    int v101 = 746;
    __int16 v102 = 2114;
    uint64_t v103 = v29;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v30 = *(void *)(a1 + 48);
  if (v30)
  {
    id v31 = objc_alloc((Class)NSError);
    id v32 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v92 = NSLocalizedDescriptionKey;
    id v33 = +[NSString stringWithUTF8String:"Session not active"];
    __int16 v93 = v33;
    NSErrorUserInfoKey v34 = +[NSDictionary dictionaryWithObjects:&v93 forKeys:&v92 count:1];
    id v35 = v31;
    id v36 = v32;
    uint64_t v37 = 54;
    goto LABEL_24;
  }
}

void sub_10016AFD8(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 784, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    uint64_t v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v15 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)long long buf = 67110146;
    int v130 = v12;
    __int16 v131 = 2082;
    __int16 v132 = v13;
    __int16 v133 = 2082;
    int v134 = v14;
    __int16 v135 = 1024;
    int v136 = 784;
    __int16 v137 = 2114;
    int v138 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    unsigned int v39 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
    __int16 v40 = [v39 handle];
    id v41 = [v40 info];
    unsigned int v42 = [v41 restrictedMode];

    if (!v42)
    {
      if (!+[NFSecureElementWrapper isAuthRandomEntangled])
      {
        __int16 v44 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
        unsigned int v45 = [v44 jcopSupportsEntanglement];

        if (v45)
        {
          id v122 = 0;
          BOOL v46 = sub_10021E3E0((uint64_t)NFSSEWrapper, &v122);
          uint64_t v47 = v122;
          if (v46)
          {
            +[NFSecureElementWrapper setAuthRandomEntangled];
            sub_10021E92C((uint64_t)NFSSEWrapper, 1);
          }
          else
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v58 = NFLogGetLogger();
            if (v58)
            {
              uint64_t v59 = (void (*)(uint64_t, const char *, ...))v58;
              int v60 = object_getClass(*(id *)(a1 + 32));
              BOOL v61 = class_isMetaClass(v60);
              int v113 = object_getClassName(*(id *)(a1 + 32));
              uint64_t v117 = sel_getName(*(SEL *)(a1 + 48));
              uint64_t v62 = 45;
              if (v61) {
                uint64_t v62 = 43;
              }
              v59(6, "%c[%{public}s %{public}s]:%i SSE does not support entanglement : %{public}@", v62, v113, v117, 805, v47);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            __int16 v63 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v63, OS_LOG_TYPE_DEFAULT))
            {
              BOOL v64 = object_getClass(*(id *)(a1 + 32));
              if (class_isMetaClass(v64)) {
                int v65 = 43;
              }
              else {
                int v65 = 45;
              }
              int v66 = object_getClassName(*(id *)(a1 + 32));
              uint64_t v67 = sel_getName(*(SEL *)(a1 + 48));
              *(_DWORD *)long long buf = 67110146;
              int v130 = v65;
              __int16 v131 = 2082;
              __int16 v132 = v66;
              __int16 v133 = 2082;
              int v134 = v67;
              __int16 v135 = 1024;
              int v136 = 805;
              __int16 v137 = 2114;
              int v138 = v47;
              _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i SSE does not support entanglement : %{public}@", buf, 0x2Cu);
            }
          }
        }
        else
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v48 = NFLogGetLogger();
          if (v48)
          {
            uint64_t v49 = (void (*)(uint64_t, const char *, ...))v48;
            uint64_t v50 = object_getClass(*(id *)(a1 + 32));
            BOOL v51 = class_isMetaClass(v50);
            BOOL v52 = object_getClassName(*(id *)(a1 + 32));
            id v116 = sel_getName(*(SEL *)(a1 + 48));
            uint64_t v53 = 45;
            if (v51) {
              uint64_t v53 = 43;
            }
            v49(6, "%c[%{public}s %{public}s]:%i JCOP does not support entanglement", v53, v52, v116, 808);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v47 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v47, OS_LOG_TYPE_DEFAULT))
          {
            id v54 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v54)) {
              int v55 = 43;
            }
            else {
              int v55 = 45;
            }
            id v56 = object_getClassName(*(id *)(a1 + 32));
            NSErrorUserInfoKey v57 = sel_getName(*(SEL *)(a1 + 48));
            *(_DWORD *)long long buf = 67109890;
            int v130 = v55;
            __int16 v131 = 2082;
            __int16 v132 = v56;
            __int16 v133 = 2082;
            int v134 = v57;
            __int16 v135 = 1024;
            int v136 = 808;
            _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i JCOP does not support entanglement", buf, 0x22u);
          }
        }
      }
      int v68 = +[NFSecureElementWrapper isAuthRandomEntangled];
      kdebug_trace();
      unsigned int v69 = NFSharedSignpostLog();
      if (os_signpost_enabled(v69))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v69, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseEffaceAuthorization in", buf, 2u);
      }

      unsigned int v70 = sub_10021EC3C((uint64_t)NFSSEWrapper, v68);
      kdebug_trace();
      int v71 = NFSharedSignpostLog();
      if (os_signpost_enabled(v71))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v71, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "NFSSEWRAPPER_CALL", "sseEffaceAuthorization out", buf, 2u);
      }

      if (v70)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v72 = NFLogGetLogger();
        if (v72)
        {
          uint64_t v73 = (void (*)(uint64_t, const char *, ...))v72;
          id v74 = object_getClass(*(id *)(a1 + 32));
          BOOL v75 = class_isMetaClass(v74);
          id v76 = object_getClassName(*(id *)(a1 + 32));
          id v118 = sel_getName(*(SEL *)(a1 + 48));
          uint64_t v77 = 45;
          if (v75) {
            uint64_t v77 = 43;
          }
          v73(3, "%c[%{public}s %{public}s]:%i Failed to efface SEP", v77, v76, v118, 819);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v78 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
        {
          int v79 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v79)) {
            int v80 = 43;
          }
          else {
            int v80 = 45;
          }
          BOOL v81 = object_getClassName(*(id *)(a1 + 32));
          id v82 = sel_getName(*(SEL *)(a1 + 48));
          *(_DWORD *)long long buf = 67109890;
          int v130 = v80;
          __int16 v131 = 2082;
          __int16 v132 = v81;
          __int16 v133 = 2082;
          int v134 = v82;
          __int16 v135 = 1024;
          int v136 = 819;
          _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to efface SEP", buf, 0x22u);
        }

        id v83 = objc_alloc((Class)NSError);
        long long v84 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v123 = NSLocalizedDescriptionKey;
        if (v70 >= 0x47) {
          int v85 = 71;
        }
        else {
          int v85 = v70;
        }
        long long v86 = +[NSString stringWithUTF8String:off_100305838[v85]];
        id v124 = v86;
        NSErrorUserInfoKey v87 = +[NSDictionary dictionaryWithObjects:&v124 forKeys:&v123 count:1];
        id v32 = [v83 initWithDomain:v84 code:v70 userInfo:v87];
      }
      else
      {
        id v32 = 0;
      }
      if ([*(id *)(a1 + 32) uid]) {
        uint64_t v88 = (uint64_t)[*(id *)(a1 + 32) uid];
      }
      else {
        uint64_t v88 = 0xFFFFFFFFLL;
      }
      uint64_t v89 = *(void **)(a1 + 32);
      if (v89[25])
      {
        NFDriverRedactLogging();
        uint64_t v89 = *(void **)(a1 + 32);
      }
      NSErrorUserInfoKey v90 = [v89 embeddedSecureElementWrapper];
      uint64_t v91 = sub_1002437D4(v90, v88);

      if (*(void *)(*(void *)(a1 + 32) + 200)) {
        NFDriverRedactLogging();
      }
      if (v91)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v92 = NFLogGetLogger();
        if (v92)
        {
          __int16 v93 = (void (*)(uint64_t, const char *, ...))v92;
          int v94 = object_getClass(*(id *)(a1 + 32));
          BOOL v95 = class_isMetaClass(v94);
          NSErrorUserInfoKey v114 = object_getClassName(*(id *)(a1 + 32));
          uint64_t v119 = sel_getName(*(SEL *)(a1 + 48));
          uint64_t v96 = 45;
          if (v95) {
            uint64_t v96 = 43;
          }
          v93(3, "%c[%{public}s %{public}s]:%i Failed to delete applets from ese: %{public}@", v96, v114, v119, 832, v91);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        NSErrorUserInfoKey v97 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v97, OS_LOG_TYPE_ERROR))
        {
          __int16 v98 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v98)) {
            int v99 = 43;
          }
          else {
            int v99 = 45;
          }
          __int16 v100 = object_getClassName(*(id *)(a1 + 32));
          int v101 = sel_getName(*(SEL *)(a1 + 48));
          *(_DWORD *)long long buf = 67110146;
          int v130 = v99;
          __int16 v131 = 2082;
          __int16 v132 = v100;
          __int16 v133 = 2082;
          int v134 = v101;
          __int16 v135 = 1024;
          int v136 = 832;
          __int16 v137 = 2114;
          int v138 = v91;
          _os_log_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to delete applets from ese: %{public}@", buf, 0x2Cu);
        }

        if (!v32) {
          id v32 = v91;
        }
      }
      __int16 v102 = *(void **)(a1 + 32);
      id v121 = 0;
      NSErrorUserInfoKey v34 = [v102 _getAllApplets:&v121];
      id v33 = v121;

      if (v34)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v103 = NFLogGetLogger();
        if (v103)
        {
          uint64_t v104 = (void (*)(uint64_t, const char *, ...))v103;
          int v105 = object_getClass(*(id *)(a1 + 32));
          BOOL v106 = class_isMetaClass(v105);
          uint64_t v115 = object_getClassName(*(id *)(a1 + 32));
          long long v120 = sel_getName(*(SEL *)(a1 + 48));
          uint64_t v107 = 45;
          if (v106) {
            uint64_t v107 = 43;
          }
          v104(3, "%c[%{public}s %{public}s]:%i Failed to get applets: %{public}@", v107, v115, v120, 840, v34);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        __int16 v108 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v108, OS_LOG_TYPE_ERROR))
        {
          int v109 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v109)) {
            int v110 = 43;
          }
          else {
            int v110 = 45;
          }
          uint64_t v111 = object_getClassName(*(id *)(a1 + 32));
          id v112 = sel_getName(*(SEL *)(a1 + 48));
          *(_DWORD *)long long buf = 67110146;
          int v130 = v110;
          __int16 v131 = 2082;
          __int16 v132 = v111;
          __int16 v133 = 2082;
          int v134 = v112;
          __int16 v135 = 1024;
          int v136 = 840;
          __int16 v137 = 2114;
          int v138 = v34;
          _os_log_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get applets: %{public}@", buf, 0x2Cu);
        }

        if (!v32) {
          id v32 = v34;
        }
      }
      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
      goto LABEL_25;
    }
    uint64_t v30 = *(void *)(a1 + 40);
    id v43 = objc_alloc((Class)NSError);
    id v32 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v125 = NSLocalizedDescriptionKey;
    id v33 = +[NSString stringWithUTF8String:"Restricted Mode"];
    id v126 = v33;
    NSErrorUserInfoKey v34 = +[NSDictionary dictionaryWithObjects:&v126 forKeys:&v125 count:1];
    id v35 = v43;
    id v36 = v32;
    uint64_t v37 = 24;
LABEL_24:
    id v38 = [v35 initWithDomain:v36 code:v37 userInfo:v34];
    (*(void (**)(uint64_t, void, id))(v30 + 16))(v30, 0, v38);

LABEL_25:
    return;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v16 = NFLogGetLogger();
  if (v16)
  {
    id v17 = (void (*)(uint64_t, const char *, ...))v16;
    id v18 = object_getClass(*(id *)(a1 + 32));
    BOOL v19 = class_isMetaClass(v18);
    __int16 v20 = object_getClassName(*(id *)(a1 + 32));
    int v21 = sel_getName(*(SEL *)(a1 + 48));
    id v22 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v23 = 45;
    if (v19) {
      uint64_t v23 = 43;
    }
    v17(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v23, v20, v21, 788, v22);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v24 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    __int16 v25 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v25)) {
      int v26 = 43;
    }
    else {
      int v26 = 45;
    }
    __int16 v27 = object_getClassName(*(id *)(a1 + 32));
    unsigned int v28 = sel_getName(*(SEL *)(a1 + 48));
    id v29 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v130 = v26;
    __int16 v131 = 2082;
    __int16 v132 = v27;
    __int16 v133 = 2082;
    int v134 = v28;
    __int16 v135 = 1024;
    int v136 = 788;
    __int16 v137 = 2114;
    int v138 = v29;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v30 = *(void *)(a1 + 40);
  if (v30)
  {
    id v31 = objc_alloc((Class)NSError);
    id v32 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v127 = NSLocalizedDescriptionKey;
    id v33 = +[NSString stringWithUTF8String:"Session not active"];
    id v128 = v33;
    NSErrorUserInfoKey v34 = +[NSDictionary dictionaryWithObjects:&v128 forKeys:&v127 count:1];
    id v35 = v31;
    id v36 = v32;
    uint64_t v37 = 54;
    goto LABEL_24;
  }
}

void sub_10016BE50(uint64_t a1)
{
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    [*(id *)(a1 + 32) markAsDirty:1];
    id v18 = [*(id *)(a1 + 32) _getSecureElementWrapperForSEID:*(void *)(a1 + 40)];
    if ([*(id *)(a1 + 32) _activateSecureElementWrapper:v18])
    {
      id v22 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      uint64_t v23 = *(void *)(a1 + 48);
      uint64_t v24 = *(void *)(a1 + 72);
      id v29 = 0;
      BOOL v19 = [v22 transceiveData:v23 toOS:v24 error:&v29];
      id v20 = v29;

      (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
    }
    else
    {
      uint64_t v25 = *(void *)(a1 + 56);
      id v26 = objc_alloc((Class)NSError);
      BOOL v19 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v30 = NSLocalizedDescriptionKey;
      id v20 = +[NSString stringWithUTF8String:"Stack Error"];
      id v31 = v20;
      __int16 v27 = +[NSDictionary dictionaryWithObjects:&v31 forKeys:&v30 count:1];
      id v28 = [v26 initWithDomain:v19 code:15 userInfo:v27];
      (*(void (**)(uint64_t, void, id))(v25 + 16))(v25, 0, v28);
    }
    goto LABEL_15;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 64));
    uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 862, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    int v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    uint64_t v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 64));
    uint64_t v15 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v35 = v12;
    __int16 v36 = 2082;
    uint64_t v37 = v13;
    __int16 v38 = 2082;
    unsigned int v39 = v14;
    __int16 v40 = 1024;
    int v41 = 862;
    __int16 v42 = 2114;
    id v43 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v16 = *(void *)(a1 + 56);
  if (v16)
  {
    id v17 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v32 = NSLocalizedDescriptionKey;
    BOOL v19 = +[NSString stringWithUTF8String:"Session not active"];
    id v33 = v19;
    id v20 = +[NSDictionary dictionaryWithObjects:&v33 forKeys:&v32 count:1];
    id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
    (*(void (**)(uint64_t, void, id))(v16 + 16))(v16, 0, v21);

LABEL_15:
  }
}

void sub_10016C35C(uint64_t a1)
{
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    [*(id *)(a1 + 32) markAsDirty:1];
    id v18 = [*(id *)(a1 + 32) _getSecureElementWrapperForSEID:*(void *)(a1 + 40)];
    if ([*(id *)(a1 + 32) _activateSecureElementWrapper:v18])
    {
      uint64_t v58 = v18;
      uint64_t v59 = objc_opt_new();
      long long v64 = 0u;
      long long v65 = 0u;
      long long v66 = 0u;
      long long v67 = 0u;
      id obj = *(id *)(a1 + 48);
      id v62 = [obj countByEnumeratingWithState:&v64 objects:v78 count:16];
      if (v62)
      {
        uint64_t v22 = 0;
        id v20 = 0;
        id v19 = 0;
        uint64_t v61 = *(void *)v65;
        do
        {
          for (i = 0; i != v62; i = (char *)i + 1)
          {
            if (*(void *)v65 != v61) {
              objc_enumerationMutation(obj);
            }
            uint64_t v24 = *(void *)(*((void *)&v64 + 1) + 8 * i);
            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              uint64_t v25 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
              uint64_t v26 = *(void *)(a1 + 72);
              id v63 = v19;
              __int16 v27 = [v25 transceiveData:v24 toOS:v26 error:&v63];
              id v28 = v63;

              if (v28)
              {
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t Logger = NFLogGetLogger();
                if (Logger)
                {
                  NSErrorUserInfoKey v30 = (void (*)(uint64_t, const char *, ...))Logger;
                  Class = object_getClass(*(id *)(a1 + 32));
                  BOOL isMetaClass = class_isMetaClass(Class);
                  ClassName = object_getClassName(*(id *)(a1 + 32));
                  Name = sel_getName(*(SEL *)(a1 + 64));
                  uint64_t v34 = 45;
                  if (isMetaClass) {
                    uint64_t v34 = 43;
                  }
                  v30(3, "%c[%{public}s %{public}s]:%i transceive failed for [%d]: %{public}@", v34, ClassName, Name, 913, (char *)i + v22, v28);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                int v35 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
                {
                  __int16 v36 = object_getClass(*(id *)(a1 + 32));
                  if (class_isMetaClass(v36)) {
                    int v37 = 43;
                  }
                  else {
                    int v37 = 45;
                  }
                  __int16 v38 = object_getClassName(*(id *)(a1 + 32));
                  unsigned int v39 = sel_getName(*(SEL *)(a1 + 64));
                  *(_DWORD *)long long buf = 67110402;
                  int v69 = v37;
                  __int16 v70 = 2082;
                  int v71 = v38;
                  __int16 v72 = 2082;
                  uint64_t v73 = v39;
                  __int16 v74 = 1024;
                  int v75 = 913;
                  __int16 v76 = 1024;
                  LODWORD(v77[0]) = v22 + i;
                  WORD2(v77[0]) = 2114;
                  *(void *)((char *)v77 + 6) = v28;
                  _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i transceive failed for [%d]: %{public}@", buf, 0x32u);
                }

                id v40 = v28;
                id v20 = v40;
              }
              if (v27)
              {
                [v59 addObject:v27];
              }
              else
              {
                BOOL v51 = objc_opt_new();
                [v59 addObject:v51];
              }
              id v19 = v28;
            }
            else
            {
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v41 = NFLogGetLogger();
              if (v41)
              {
                __int16 v42 = (void (*)(uint64_t, const char *, ...))v41;
                id v43 = object_getClass(*(id *)(a1 + 32));
                BOOL v44 = class_isMetaClass(v43);
                int v55 = object_getClassName(*(id *)(a1 + 32));
                NSErrorUserInfoKey v57 = sel_getName(*(SEL *)(a1 + 64));
                uint64_t v45 = 45;
                if (v44) {
                  uint64_t v45 = 43;
                }
                v42(3, "%c[%{public}s %{public}s]:%i Invalid class for APDU %d", v45, v55, v57, 905, (char *)i + v22);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              BOOL v46 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
              {
                uint64_t v47 = object_getClass(*(id *)(a1 + 32));
                if (class_isMetaClass(v47)) {
                  int v48 = 43;
                }
                else {
                  int v48 = 45;
                }
                uint64_t v49 = object_getClassName(*(id *)(a1 + 32));
                uint64_t v50 = sel_getName(*(SEL *)(a1 + 64));
                *(_DWORD *)long long buf = 67110146;
                int v69 = v48;
                __int16 v70 = 2082;
                int v71 = v49;
                __int16 v72 = 2082;
                uint64_t v73 = v50;
                __int16 v74 = 1024;
                int v75 = 905;
                __int16 v76 = 1024;
                LODWORD(v77[0]) = v22 + i;
                _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid class for APDU %d", buf, 0x28u);
              }

              id v19 = v19;
              __int16 v27 = v20;
              id v20 = v19;
            }
          }
          uint64_t v22 = (v22 + i);
          id v62 = [obj countByEnumeratingWithState:&v64 objects:v78 count:16];
        }
        while (v62);
      }
      else
      {
        id v20 = 0;
        id v19 = 0;
      }

      id v21 = v59;
      (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
      id v18 = v58;
    }
    else
    {
      uint64_t v52 = *(void *)(a1 + 56);
      id v53 = objc_alloc((Class)NSError);
      id v19 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v79 = NSLocalizedDescriptionKey;
      id v20 = +[NSString stringWithUTF8String:"Stack Error"];
      int v80 = v20;
      id v21 = +[NSDictionary dictionaryWithObjects:&v80 forKeys:&v79 count:1];
      id v54 = [v53 initWithDomain:v19 code:15 userInfo:v21];
      (*(void (**)(uint64_t, void, id))(v52 + 16))(v52, 0, v54);
    }
    goto LABEL_15;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v2 = NFLogGetLogger();
  if (v2)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))v2;
    uint64_t v4 = object_getClass(*(id *)(a1 + 32));
    BOOL v5 = class_isMetaClass(v4);
    uint64_t v6 = object_getClassName(*(id *)(a1 + 32));
    id v7 = sel_getName(*(SEL *)(a1 + 64));
    uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v9 = 45;
    if (v5) {
      uint64_t v9 = 43;
    }
    v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, v6, v7, 889, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    int v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    uint64_t v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 64));
    uint64_t v15 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v69 = v12;
    __int16 v70 = 2082;
    int v71 = v13;
    __int16 v72 = 2082;
    uint64_t v73 = v14;
    __int16 v74 = 1024;
    int v75 = 889;
    __int16 v76 = 2114;
    v77[0] = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v16 = *(void *)(a1 + 56);
  if (v16)
  {
    id v17 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v81 = NSLocalizedDescriptionKey;
    id v19 = +[NSString stringWithUTF8String:"Session not active"];
    id v82 = v19;
    id v20 = +[NSDictionary dictionaryWithObjects:&v82 forKeys:&v81 count:1];
    id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
    (*(void (**)(uint64_t, void, id))(v16 + 16))(v16, 0, v21);
LABEL_15:
  }
}

void sub_10016DCD8(void *a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  if (a1)
  {
    v38[0] = 0;
    v38[1] = v38;
    v38[2] = 0x2020000000;
    v38[3] = -1;
    v37[0] = 0;
    v37[1] = v37;
    v37[2] = 0x2020000000;
    v37[3] = 0;
    v35[0] = 0;
    v35[1] = v35;
    v35[2] = 0x2020000000;
    char v36 = 0;
    v33[0] = 0;
    v33[1] = v33;
    v33[2] = 0x3032000000;
    v33[3] = sub_10000B888;
    void v33[4] = sub_10016DFB4;
    id v34 = (id)objc_opt_new();
    v32[0] = 0;
    v32[1] = v32;
    v32[2] = 0x2020000000;
    v32[3] = 0;
    uint64_t v26 = 0;
    __int16 v27 = &v26;
    uint64_t v28 = 0x3032000000;
    id v29 = sub_10016DFBC;
    NSErrorUserInfoKey v30 = sub_10016DFE8;
    id v31 = 0;
    v14[0] = _NSConcreteStackBlock;
    v14[1] = 3221225472;
    v14[2] = sub_10016DFF0;
    v14[3] = &unk_100305AD0;
    id v19 = v32;
    id v15 = v7;
    id v20 = v38;
    id v21 = v37;
    uint64_t v22 = v35;
    uint64_t v23 = v33;
    id v18 = v9;
    uint64_t v16 = a1;
    uint64_t v24 = &v26;
    uint64_t v25 = "_executeCommands:params:completion:";
    id v17 = v8;
    int v10 = objc_retainBlock(v14);
    int v11 = (void *)v27[5];
    void v27[5] = (uint64_t)v10;

    v13.receiver = a1;
    v13.super_class = (Class)_NFSecureElementManagerSession;
    int v12 = [super workQueue];
    dispatch_async(v12, (dispatch_block_t)v27[5]);

    _Block_object_dispose(&v26, 8);
    _Block_object_dispose(v32, 8);
    _Block_object_dispose(v33, 8);

    _Block_object_dispose(v35, 8);
    _Block_object_dispose(v37, 8);
    _Block_object_dispose(v38, 8);
  }
}

void sub_10016DF58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36)
{
  _Block_object_dispose(&a26, 8);
  _Block_object_dispose(&a32, 8);
  _Block_object_dispose(&a36, 8);
  _Block_object_dispose((const void *)(v36 - 200), 8);
  _Block_object_dispose((const void *)(v36 - 168), 8);
  _Block_object_dispose((const void *)(v36 - 136), 8);
  _Unwind_Resume(a1);
}

void sub_10016DFB4(uint64_t a1)
{
}

id sub_10016DFBC(uint64_t a1, uint64_t a2)
{
  id result = objc_retainBlock(*(id *)(a2 + 40));
  *(void *)(a1 + 40) = result;
  return result;
}

void sub_10016DFE8(uint64_t a1)
{
}

void sub_10016DFF0(uint64_t a1)
{
  unint64_t v2 = *(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
  if (v2 < (unint64_t)[*(id *)(a1 + 32) count])
  {
    if ([*(id *)(a1 + 40) didEnd])
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        uint64_t v4 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(*(id *)(a1 + 40));
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(*(id *)(a1 + 40));
        Name = sel_getName(*(SEL *)(a1 + 112));
        uint64_t v8 = 45;
        if (isMetaClass) {
          uint64_t v8 = 43;
        }
        v4(5, "%c[%{public}s %{public}s]:%i Aborted", v8, ClassName, Name, 1083);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v9 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        int v10 = object_getClass(*(id *)(a1 + 40));
        if (class_isMetaClass(v10)) {
          int v11 = 43;
        }
        else {
          int v11 = 45;
        }
        int v12 = object_getClassName(*(id *)(a1 + 40));
        objc_super v13 = sel_getName(*(SEL *)(a1 + 112));
        *(_DWORD *)long long buf = 67109890;
        int v47 = v11;
        __int16 v48 = 2082;
        uint64_t v49 = v12;
        __int16 v50 = 2082;
        BOOL v51 = v13;
        __int16 v52 = 1024;
        int v53 = 1083;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Aborted", buf, 0x22u);
      }

      uint64_t v14 = *(void *)(a1 + 56);
      id v15 = objc_alloc((Class)NSError);
      uint64_t v16 = +[NSString stringWithUTF8String:"nfcd"];
      v56[0] = NSLocalizedDescriptionKey;
      id v17 = +[NSString stringWithUTF8String:"Aborted"];
      v57[0] = v17;
      v57[1] = &off_10031C738;
      v56[1] = @"Line";
      v56[2] = @"Method";
      id v18 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 112))];
      v57[2] = v18;
      v56[3] = NSDebugDescriptionErrorKey;
      id v19 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 112)), 1084];
      v57[3] = v19;
      id v20 = +[NSDictionary dictionaryWithObjects:v57 forKeys:v56 count:4];
      id v21 = [v15 initWithDomain:v16 code:3 userInfo:v20];
      (*(void (**)(uint64_t, id, void, void, void, void))(v14 + 16))(v14, v21, 0, 0, 0, *(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 40));

      uint64_t v22 = *(void *)(*(void *)(a1 + 104) + 8);
      uint64_t v23 = *(void **)(v22 + 40);
      *(void *)(v22 + 40) = 0;

      return;
    }
    uint64_t v26 = *(void **)(a1 + 32);
    ++*(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
    __int16 v27 = [v26 objectAtIndex:];
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      uint64_t v28 = [*(id *)(a1 + 40) _sendOneCommand:v27 params:*(void *)(a1 + 48) responses:*(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 40) lastStatus:*(void *)(*(void *)(a1 + 72) + 8) + 24 totalTXTime:*(void *)(*(void *)(a1 + 80) + 8) + 24 failureDetected:*(void *)(*(void *)(a1 + 88) + 8) + 24];
      if (v28)
      {
        id v29 = v28;
        (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
        uint64_t v30 = *(void *)(*(void *)(a1 + 104) + 8);
        id v31 = *(void **)(v30 + 40);
        *(void *)(v30 + 40) = 0;

LABEL_30:
        return;
      }
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v32 = NFLogGetLogger();
      if (v32)
      {
        id v33 = (void (*)(uint64_t, const char *, ...))v32;
        id v34 = object_getClass(*(id *)(a1 + 40));
        BOOL v35 = class_isMetaClass(v34);
        __int16 v42 = object_getClassName(*(id *)(a1 + 40));
        BOOL v44 = sel_getName(*(SEL *)(a1 + 112));
        uint64_t v36 = 45;
        if (v35) {
          uint64_t v36 = 43;
        }
        v33(5, "%c[%{public}s %{public}s]:%i Command is not in expected format: %{public}@", v36, v42, v44, 1091, v27);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v37 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v38 = object_getClass(*(id *)(a1 + 40));
        if (class_isMetaClass(v38)) {
          int v39 = 43;
        }
        else {
          int v39 = 45;
        }
        id v40 = object_getClassName(*(id *)(a1 + 40));
        uint64_t v41 = sel_getName(*(SEL *)(a1 + 112));
        *(_DWORD *)long long buf = 67110146;
        int v47 = v39;
        __int16 v48 = 2082;
        uint64_t v49 = v40;
        __int16 v50 = 2082;
        BOOL v51 = v41;
        __int16 v52 = 1024;
        int v53 = 1091;
        __int16 v54 = 2114;
        int v55 = v27;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Command is not in expected format: %{public}@", buf, 0x2Cu);
      }
    }
    v45.receiver = *(id *)(a1 + 40);
    v45.super_class = (Class)_NFSecureElementManagerSession;
    id v29 = [super workQueue];
    dispatch_async(v29, *(dispatch_block_t *)(*(void *)(*(void *)(a1 + 104) + 8) + 40));
    goto LABEL_30;
  }
  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
  uint64_t v24 = *(void *)(*(void *)(a1 + 104) + 8);
  uint64_t v25 = *(void **)(v24 + 40);
  *(void *)(v24 + 40) = 0;
}

void sub_10016E700(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 64));
    uint64_t v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 1121, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    objc_super v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 64));
    id v15 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)long long buf = 67110146;
    int v213 = v12;
    __int16 v214 = 2082;
    int v215 = v13;
    __int16 v216 = 2082;
    id v217 = v14;
    __int16 v218 = 1024;
    int v219 = 1121;
    __int16 v220 = 2114;
    uint64_t v221 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    [*(id *)(a1 + 32) markAsDirty:1];
    uint64_t v36 = *(void **)(a1 + 32);
    int v37 = [*(id *)(a1 + 40) seid];
    uint64_t v32 = [v36 _getSecureElementWrapperForSEID:v37];

    if (([*(id *)(a1 + 32) _activateSecureElementWrapper:v32] & 1) == 0)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v42 = NFLogGetLogger();
      if (v42)
      {
        id v43 = (void (*)(uint64_t, const char *, ...))v42;
        BOOL v44 = object_getClass(*(id *)(a1 + 32));
        BOOL v45 = class_isMetaClass(v44);
        BOOL v46 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v175 = sel_getName(*(SEL *)(a1 + 64));
        uint64_t v47 = 45;
        if (v45) {
          uint64_t v47 = 43;
        }
        v43(3, "%c[%{public}s %{public}s]:%i SE activation failed", v47, v46, v175, 1129);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v48 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
      {
        uint64_t v49 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v49)) {
          int v50 = 43;
        }
        else {
          int v50 = 45;
        }
        BOOL v51 = object_getClassName(*(id *)(a1 + 32));
        __int16 v52 = sel_getName(*(SEL *)(a1 + 64));
        *(_DWORD *)long long buf = 67109890;
        int v213 = v50;
        __int16 v214 = 2082;
        int v215 = v51;
        __int16 v216 = 2082;
        id v217 = v52;
        __int16 v218 = 1024;
        int v219 = 1129;
        _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i SE activation failed", buf, 0x22u);
      }

      uint64_t v53 = *(void *)(a1 + 56);
      id v54 = objc_alloc((Class)NSError);
      int v39 = +[NSString stringWithUTF8String:"nfcd"];
      v230[0] = NSLocalizedDescriptionKey;
      int v55 = +[NSString stringWithUTF8String:"Stack Error"];
      v231[0] = v55;
      v231[1] = &off_10031C750;
      v230[1] = @"Line";
      v230[2] = @"Method";
      id v56 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 64))];
      v231[2] = v56;
      v230[3] = NSDebugDescriptionErrorKey;
      id v57 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 64)), 1130];
      v231[3] = v57;
      uint64_t v58 = +[NSDictionary dictionaryWithObjects:v231 forKeys:v230 count:4];
      id v59 = [v54 initWithDomain:v39 code:15 userInfo:v58];
      (*(void (**)(uint64_t, void, uint64_t, id, double))(v53 + 16))(v53, 0, -1, v59, 0.0);

      goto LABEL_40;
    }
    if ([*(id *)(a1 + 40) deactivateAllApps])
    {
      __int16 v38 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      int v39 = sub_100245608(v38);

      if (v39)
      {
        uint64_t v40 = *(void *)(a1 + 56);
        uint64_t v41 = objc_opt_new();
        (*(void (**)(uint64_t, void *, void, void *, double))(v40 + 16))(v40, v41, 0, v39, 0.0);

LABEL_40:
        goto LABEL_24;
      }
    }
    if (![*(id *)(a1 + 48) count])
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v105 = NFLogGetLogger();
      if (v105)
      {
        BOOL v106 = (void (*)(uint64_t, const char *, ...))v105;
        uint64_t v107 = object_getClass(*(id *)(a1 + 32));
        BOOL v108 = class_isMetaClass(v107);
        int v109 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v177 = sel_getName(*(SEL *)(a1 + 64));
        uint64_t v110 = 45;
        if (v108) {
          uint64_t v110 = 43;
        }
        v106(5, "%c[%{public}s %{public}s]:%i Script is empty", v110, v109, v177, 1145);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v111 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v111, OS_LOG_TYPE_DEFAULT))
      {
        id v112 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v112)) {
          int v113 = 43;
        }
        else {
          int v113 = 45;
        }
        NSErrorUserInfoKey v114 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v115 = sel_getName(*(SEL *)(a1 + 64));
        *(_DWORD *)long long buf = 67109890;
        int v213 = v113;
        __int16 v214 = 2082;
        int v215 = v114;
        __int16 v216 = 2082;
        id v217 = v115;
        __int16 v218 = 1024;
        int v219 = 1145;
        _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Script is empty", buf, 0x22u);
      }

      (*(void (**)(double))(*(void *)(a1 + 56) + 16))(0.0);
      goto LABEL_24;
    }
    int v60 = [[*(id *)(a1 + 48) NF_stringForKey:@"kBatchId"];
    uint64_t v61 = [*(id *)(a1 + 48) NF_arrayForKey:@"kCommands"];
    id v62 = [[*(id *)(a1 + 48) NF_stringForKey:@"kTaskId"];
    id v199 = v60;
    if (!v60 || (objc_opt_class(), (objc_opt_isKindOfClass() & 1) == 0))
    {
      long long v84 = v61;
      int v85 = v62;
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v86 = NFLogGetLogger();
      if (v86)
      {
        NSErrorUserInfoKey v87 = (void (*)(uint64_t, const char *, ...))v86;
        uint64_t v88 = object_getClass(*(id *)(a1 + 32));
        BOOL v89 = class_isMetaClass(v88);
        NSErrorUserInfoKey v90 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v176 = sel_getName(*(SEL *)(a1 + 64));
        uint64_t v91 = 45;
        if (v89) {
          uint64_t v91 = 43;
        }
        v87(3, "%c[%{public}s %{public}s]:%i Invalid batch ID", v91, v90, v176, 1156);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v92 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v92, OS_LOG_TYPE_ERROR))
      {
        __int16 v93 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v93)) {
          int v94 = 43;
        }
        else {
          int v94 = 45;
        }
        BOOL v95 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v96 = sel_getName(*(SEL *)(a1 + 64));
        *(_DWORD *)long long buf = 67109890;
        int v213 = v94;
        __int16 v214 = 2082;
        int v215 = v95;
        __int16 v216 = 2082;
        id v217 = v96;
        __int16 v218 = 1024;
        int v219 = 1156;
        _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid batch ID", buf, 0x22u);
      }

      uint64_t v97 = *(void *)(a1 + 56);
      id v98 = objc_alloc((Class)NSError);
      int v99 = +[NSString stringWithUTF8String:"nfcd"];
      v228[0] = NSLocalizedDescriptionKey;
      __int16 v100 = +[NSString stringWithUTF8String:"Missing Parameter"];
      v229[0] = v100;
      v229[1] = &off_10031C768;
      v228[1] = @"Line";
      v228[2] = @"Method";
      id v101 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 64))];
      v229[2] = v101;
      v228[3] = NSDebugDescriptionErrorKey;
      id v102 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 64)), 1157];
      v229[3] = v102;
      uint64_t v103 = +[NSDictionary dictionaryWithObjects:v229 forKeys:v228 count:4];
      id v104 = [v98 initWithDomain:v99 code:9 userInfo:v103];
      (*(void (**)(uint64_t, void, uint64_t, id, double))(v97 + 16))(v97, 0, -1, v104, 0.0);

      id v68 = 0;
      id v62 = v85;
      uint64_t v61 = v84;
      int v60 = v199;
      goto LABEL_103;
    }
    uint64_t v198 = v61;
    if (v61 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    {
      if (v62)
      {
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          if ([*(id *)(a1 + 40) initialSelectBeforeRun])
          {
            id v63 = [*(id *)(a1 + 40) AIDAllowList];
            id v64 = [v63 count];

            if (v64)
            {
              int v195 = v62;
              long long v65 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
              long long v66 = [*(id *)(a1 + 40) AIDAllowList];
              long long v67 = [v66 firstObject];
              id v207 = 0;
              BOOL v196 = [v65 selectByName:v67 error:&v207];
              id v68 = v207;

              if (v68)
              {
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v69 = NFLogGetLogger();
                if (v69)
                {
                  __int16 v70 = (void (*)(uint64_t, const char *, ...))v69;
                  int v71 = object_getClass(*(id *)(a1 + 32));
                  BOOL v190 = class_isMetaClass(v71);
                  uint64_t v185 = object_getClassName(*(id *)(a1 + 32));
                  unsigned int v182 = sel_getName(*(SEL *)(a1 + 64));
                  __int16 v72 = [*(id *)(a1 + 40) AIDAllowList];
                  uint64_t v73 = [v72 firstObject];
                  uint64_t v74 = 45;
                  if (v190) {
                    uint64_t v74 = 43;
                  }
                  v70(3, "%c[%{public}s %{public}s]:%i Fail to select %{public}@", v74, v185, v182, 1182, v73);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                int v75 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
                {
                  __int16 v76 = object_getClass(*(id *)(a1 + 32));
                  if (class_isMetaClass(v76)) {
                    int v77 = 43;
                  }
                  else {
                    int v77 = 45;
                  }
                  int v191 = v77;
                  int v186 = object_getClassName(*(id *)(a1 + 32));
                  id v78 = sel_getName(*(SEL *)(a1 + 64));
                  NSErrorUserInfoKey v79 = [*(id *)(a1 + 40) AIDAllowList];
                  int v80 = [v79 firstObject];
                  *(_DWORD *)long long buf = 67110146;
                  int v213 = v191;
                  __int16 v214 = 2082;
                  int v215 = v186;
                  __int16 v216 = 2082;
                  id v217 = v78;
                  __int16 v218 = 1024;
                  int v219 = 1182;
                  __int16 v220 = 2114;
                  uint64_t v221 = v80;
                  _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Fail to select %{public}@", buf, 0x2Cu);
                }
                uint64_t v81 = *(void *)(a1 + 56);
                id v183 = objc_alloc((Class)NSError);
                uint64_t v82 = +[NSString stringWithUTF8String:"nfcd"];
                id v181 = [v68 code];
                v208[0] = NSLocalizedDescriptionKey;
                if ((uint64_t)[v68 code] > 70) {
                  uint64_t v83 = 71;
                }
                else {
                  uint64_t v83 = (uint64_t)[v68 code];
                }
                uint64_t v192 = +[NSString stringWithUTF8String:off_100305838[v83]];
                v209[0] = v192;
                v209[1] = v68;
                v208[1] = NSUnderlyingErrorKey;
                v208[2] = @"Line";
                v209[2] = &off_10031C7C8;
                v208[3] = @"Method";
                id v152 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 64))];
                v209[3] = v152;
                void v208[4] = NSDebugDescriptionErrorKey;
                id v153 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 64)), 1183];
                void v209[4] = v153;
                BOOL v154 = +[NSDictionary dictionaryWithObjects:v209 forKeys:v208 count:5];
                id v155 = (void *)v82;
                id v156 = [v183 initWithDomain:v82 code:v181 userInfo:v154];
                (*(void (**)(uint64_t, void, uint64_t, id, double))(v81 + 16))(v81, 0, -1, v156, 0.0);
LABEL_119:

                id v62 = v195;
                goto LABEL_103;
              }
              if ([v196 status] != 36864)
              {
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v157 = NFLogGetLogger();
                if (v157)
                {
                  id v158 = (void (*)(uint64_t, const char *, ...))v157;
                  id v159 = object_getClass(*(id *)(a1 + 32));
                  BOOL v193 = class_isMetaClass(v159);
                  uint64_t v187 = object_getClassName(*(id *)(a1 + 32));
                  uint64_t v184 = sel_getName(*(SEL *)(a1 + 64));
                  NSErrorUserInfoKey v160 = [*(id *)(a1 + 40) AIDAllowList];
                  int v161 = [v160 firstObject];
                  uint64_t v180 = [v196 status];
                  uint64_t v162 = 45;
                  if (v193) {
                    uint64_t v162 = 43;
                  }
                  v158(3, "%c[%{public}s %{public}s]:%i Fail to select %{public}@, status=0x%hX", v162, v187, v184, 1176, v161, v180);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                int v163 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v163, OS_LOG_TYPE_ERROR))
                {
                  __int16 v164 = object_getClass(*(id *)(a1 + 32));
                  if (class_isMetaClass(v164)) {
                    int v165 = 43;
                  }
                  else {
                    int v165 = 45;
                  }
                  int v194 = v165;
                  NSErrorUserInfoKey v188 = object_getClassName(*(id *)(a1 + 32));
                  __int16 v166 = sel_getName(*(SEL *)(a1 + 64));
                  __int16 v167 = [*(id *)(a1 + 40) AIDAllowList];
                  __int16 v168 = [v167 firstObject];
                  unsigned int v169 = [v196 status];
                  *(_DWORD *)long long buf = 67110402;
                  int v213 = v194;
                  __int16 v214 = 2082;
                  int v215 = v188;
                  __int16 v216 = 2082;
                  id v217 = v166;
                  __int16 v218 = 1024;
                  int v219 = 1176;
                  __int16 v220 = 2114;
                  uint64_t v221 = v168;
                  __int16 v222 = 1024;
                  unsigned int v223 = v169;
                  _os_log_impl((void *)&_mh_execute_header, v163, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Fail to select %{public}@, status=0x%hX", buf, 0x32u);
                }
                uint64_t v170 = *(void *)(a1 + 56);
                id v189 = objc_alloc((Class)NSError);
                uint64_t v171 = +[NSString stringWithUTF8String:"nfcd"];
                v210[0] = NSLocalizedDescriptionKey;
                uint64_t v192 = +[NSString stringWithUTF8String:"Not found"];
                v211[0] = v192;
                v211[1] = &off_10031C7B0;
                v210[1] = @"Line";
                v210[2] = @"Method";
                id v152 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 64))];
                v211[2] = v152;
                v210[3] = NSDebugDescriptionErrorKey;
                id v172 = objc_alloc((Class)NSString);
                uint64_t v174 = sel_getName(*(SEL *)(a1 + 64));
                v173 = v172;
                id v155 = (void *)v171;
                id v153 = [[v173 initWithFormat:@"%s:%d", v174, 1177];
                v211[3] = v153;
                BOOL v154 = +[NSDictionary dictionaryWithObjects:v211 forKeys:v210 count:4];
                id v156 = [v189 initWithDomain:v171 code:65 userInfo:v154];
                (*(void (**)(uint64_t, void, uint64_t, id, double))(v170 + 16))(v170, 0, -1, v156, 0.0);
                goto LABEL_119;
              }

              id v62 = v195;
            }
          }
          uint64_t v149 = *(void **)(a1 + 32);
          id v150 = *(void **)(a1 + 40);
          v200[0] = _NSConcreteStackBlock;
          v200[1] = 3221225472;
          v200[2] = sub_10016FEE0;
          v200[3] = &unk_100305AF8;
          v200[4] = v149;
          long long v197 = *(_OWORD *)(a1 + 56);
          id v151 = (id)v197;
          long long v206 = v197;
          id v201 = *(id *)(a1 + 40);
          long long v202 = v60;
          uint64_t v203 = v62;
          id v204 = *(id *)(a1 + 48);
          uint64_t v205 = v61;
          sub_10016DCD8(v149, v61, v150, v200);

          id v68 = 0;
LABEL_103:

          goto LABEL_24;
        }
      }
      id v116 = v62;
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v136 = NFLogGetLogger();
      if (v136)
      {
        __int16 v137 = (void (*)(uint64_t, const char *, ...))v136;
        int v138 = object_getClass(*(id *)(a1 + 32));
        BOOL v139 = class_isMetaClass(v138);
        NSErrorUserInfoKey v140 = object_getClassName(*(id *)(a1 + 32));
        id v179 = sel_getName(*(SEL *)(a1 + 64));
        uint64_t v141 = 45;
        if (v139) {
          uint64_t v141 = 43;
        }
        v137(3, "%c[%{public}s %{public}s]:%i Invalid task ID", v141, v140, v179, 1168);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v142 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v142, OS_LOG_TYPE_ERROR))
      {
        NSErrorUserInfoKey v143 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v143)) {
          int v144 = 43;
        }
        else {
          int v144 = 45;
        }
        NSErrorUserInfoKey v145 = object_getClassName(*(id *)(a1 + 32));
        id v146 = sel_getName(*(SEL *)(a1 + 64));
        *(_DWORD *)long long buf = 67109890;
        int v213 = v144;
        __int16 v214 = 2082;
        int v215 = v145;
        __int16 v216 = 2082;
        id v217 = v146;
        __int16 v218 = 1024;
        int v219 = 1168;
        _os_log_impl((void *)&_mh_execute_header, v142, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid task ID", buf, 0x22u);
      }

      uint64_t v128 = *(void *)(a1 + 56);
      id v129 = objc_alloc((Class)NSError);
      int v130 = +[NSString stringWithUTF8String:"nfcd"];
      v224[0] = NSLocalizedDescriptionKey;
      __int16 v131 = +[NSString stringWithUTF8String:"Missing Parameter"];
      v225[0] = v131;
      v225[1] = &off_10031C798;
      v224[1] = @"Line";
      v224[2] = @"Method";
      id v132 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 64))];
      v225[2] = v132;
      v224[3] = NSDebugDescriptionErrorKey;
      id v133 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 64)), 1169];
      v225[3] = v133;
      int v134 = v225;
      __int16 v135 = v224;
    }
    else
    {
      id v116 = v62;
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v117 = NFLogGetLogger();
      if (v117)
      {
        id v118 = (void (*)(uint64_t, const char *, ...))v117;
        uint64_t v119 = object_getClass(*(id *)(a1 + 32));
        BOOL v120 = class_isMetaClass(v119);
        id v121 = object_getClassName(*(id *)(a1 + 32));
        id v178 = sel_getName(*(SEL *)(a1 + 64));
        uint64_t v122 = 45;
        if (v120) {
          uint64_t v122 = 43;
        }
        v118(3, "%c[%{public}s %{public}s]:%i Invalid commands", v122, v121, v178, 1162);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      NSErrorUserInfoKey v123 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v123, OS_LOG_TYPE_ERROR))
      {
        id v124 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v124)) {
          int v125 = 43;
        }
        else {
          int v125 = 45;
        }
        id v126 = object_getClassName(*(id *)(a1 + 32));
        NSErrorUserInfoKey v127 = sel_getName(*(SEL *)(a1 + 64));
        *(_DWORD *)long long buf = 67109890;
        int v213 = v125;
        __int16 v214 = 2082;
        int v215 = v126;
        __int16 v216 = 2082;
        id v217 = v127;
        __int16 v218 = 1024;
        int v219 = 1162;
        _os_log_impl((void *)&_mh_execute_header, v123, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid commands", buf, 0x22u);
      }

      uint64_t v128 = *(void *)(a1 + 56);
      id v129 = objc_alloc((Class)NSError);
      int v130 = +[NSString stringWithUTF8String:"nfcd"];
      v226[0] = NSLocalizedDescriptionKey;
      __int16 v131 = +[NSString stringWithUTF8String:"Missing Parameter"];
      v227[0] = v131;
      v227[1] = &off_10031C780;
      v226[1] = @"Line";
      v226[2] = @"Method";
      id v132 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 64))];
      v227[2] = v132;
      v226[3] = NSDebugDescriptionErrorKey;
      id v133 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 64)), 1163];
      v227[3] = v133;
      int v134 = v227;
      __int16 v135 = v226;
    }
    id v147 = +[NSDictionary dictionaryWithObjects:v134 forKeys:v135 count:4];
    id v148 = [v129 initWithDomain:v130 code:9 userInfo:v147];
    (*(void (**)(uint64_t, void, uint64_t, id, double))(v128 + 16))(v128, 0, -1, v148, 0.0);

    id v68 = 0;
    id v62 = v116;
    uint64_t v61 = v198;
    int v60 = v199;
    goto LABEL_103;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v16 = NFLogGetLogger();
  if (v16)
  {
    id v17 = (void (*)(uint64_t, const char *, ...))v16;
    id v18 = object_getClass(*(id *)(a1 + 32));
    BOOL v19 = class_isMetaClass(v18);
    id v20 = object_getClassName(*(id *)(a1 + 32));
    id v21 = sel_getName(*(SEL *)(a1 + 64));
    uint64_t v22 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v23 = 45;
    if (v19) {
      uint64_t v23 = 43;
    }
    v17(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v23, v20, v21, 1123, v22);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v24 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    uint64_t v25 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v25)) {
      int v26 = 43;
    }
    else {
      int v26 = 45;
    }
    __int16 v27 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v28 = sel_getName(*(SEL *)(a1 + 64));
    id v29 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v213 = v26;
    __int16 v214 = 2082;
    int v215 = v27;
    __int16 v216 = 2082;
    id v217 = v28;
    __int16 v218 = 1024;
    int v219 = 1123;
    __int16 v220 = 2114;
    uint64_t v221 = v29;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v30 = *(void *)(a1 + 56);
  if (v30)
  {
    id v31 = objc_alloc((Class)NSError);
    uint64_t v32 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v232 = NSLocalizedDescriptionKey;
    id v33 = +[NSString stringWithUTF8String:"Session not active"];
    int v233 = v33;
    id v34 = +[NSDictionary dictionaryWithObjects:&v233 forKeys:&v232 count:1];
    id v35 = [v31 initWithDomain:v32 code:54 userInfo:v34];
    (*(void (**)(uint64_t, void, uint64_t, id, double))(v30 + 16))(v30, 0, -1, v35, 0.0);

LABEL_24:
  }
}

void sub_10016FEE0(uint64_t a1, void *a2, uint64_t a3, unint64_t a4, int a5, void *a6)
{
  id v11 = a2;
  id v12 = a6;
  if (v11 && [v11 code] != (id)66 || objc_msgSend(v12, "count"))
  {
    if ([v12 count]
      && ([*(id *)(a1 + 40) disableCompletionNotification] & 1) == 0)
    {
      *(unsigned char *)(*(void *)(a1 + 32) + 161) = 1;
    }
    id v13 = objc_alloc((Class)NSMutableDictionary);
    v68[0] = @"kBatchId";
    v68[1] = @"kTaskId";
    uint64_t v14 = *(void *)(a1 + 56);
    v69[0] = *(void *)(a1 + 48);
    v69[1] = v14;
    v68[2] = @"kCommandsResponse";
    v68[3] = @"kVersion";
    v69[2] = v12;
    v69[3] = &off_10031C7F8;
    id v15 = +[NSDictionary dictionaryWithObjects:v69 forKeys:v68 count:4];
    id v16 = [v13 initWithDictionary:v15];

    if ([*(id *)(a1 + 40) includeAPDUDuration])
    {
      id v17 = +[NSNumber numberWithUnsignedLongLong:a4];
      [v16 setObject:v17 forKeyedSubscript:@"totalCommandResponseTimeInMS"];
    }
    id v18 = [*(id *)(a1 + 64) objectForKey:@"targetSEID"];

    if (v18)
    {
      BOOL v19 = [*(id *)(a1 + 40) seid];
      CFStringRef v20 = @"targetSEID";
    }
    else
    {
      id v21 = [*(id *)(a1 + 64) objectForKey:@"SEID"];

      if (!v21)
      {
LABEL_14:
        id v22 = [v12 count];
        if (v22 != [*(id *)(a1 + 72) count]) {
          [v16 setValue:&__kCFBooleanTrue forKey:@"incompletedExecution"];
        }
        if (a5) {
          [v16 setValue:&__kCFBooleanTrue forKey:@"commandResponseFailureDetected"];
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          uint64_t v24 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(*(id *)(a1 + 32));
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(*(id *)(a1 + 32));
          Name = sel_getName(*(SEL *)(a1 + 88));
          uint64_t v28 = 45;
          if (isMetaClass) {
            uint64_t v28 = 43;
          }
          v24(6, "%c[%{public}s %{public}s]:%i Done running script. Status = %ld, error = %@", v28, ClassName, Name, 1230, a3, v11);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v29 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v30 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v30)) {
            int v31 = 43;
          }
          else {
            int v31 = 45;
          }
          uint64_t v32 = object_getClassName(*(id *)(a1 + 32));
          id v33 = sel_getName(*(SEL *)(a1 + 88));
          *(_DWORD *)long long buf = 67110402;
          int v57 = v31;
          __int16 v58 = 2082;
          id v59 = v32;
          __int16 v60 = 2082;
          uint64_t v61 = v33;
          __int16 v62 = 1024;
          int v63 = 1230;
          __int16 v64 = 2048;
          uint64_t v65 = a3;
          __int16 v66 = 2112;
          id v67 = v11;
          _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Done running script. Status = %ld, error = %@", buf, 0x36u);
        }

        (*(void (**)(double))(*(void *)(a1 + 80) + 16))((double)a4 / 1000.0);
        goto LABEL_38;
      }
      BOOL v19 = [*(id *)(a1 + 40) seid];
      CFStringRef v20 = @"SEID";
    }
    [v16 setValue:v19 forKey:v20];

    goto LABEL_14;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v34 = NFLogGetLogger();
  if (v34)
  {
    id v35 = (void (*)(uint64_t, const char *, ...))v34;
    uint64_t v36 = object_getClass(*(id *)(a1 + 32));
    BOOL v37 = class_isMetaClass(v36);
    __int16 v38 = object_getClassName(*(id *)(a1 + 32));
    int v55 = sel_getName(*(SEL *)(a1 + 88));
    uint64_t v39 = 45;
    if (v37) {
      uint64_t v39 = 43;
    }
    v35(3, "%c[%{public}s %{public}s]:%i No response from SE", v39, v38, v55, 1196);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v40 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
  {
    uint64_t v41 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v41)) {
      int v42 = 43;
    }
    else {
      int v42 = 45;
    }
    id v43 = object_getClassName(*(id *)(a1 + 32));
    BOOL v44 = sel_getName(*(SEL *)(a1 + 88));
    *(_DWORD *)long long buf = 67109890;
    int v57 = v42;
    __int16 v58 = 2082;
    id v59 = v43;
    __int16 v60 = 2082;
    uint64_t v61 = v44;
    __int16 v62 = 1024;
    int v63 = 1196;
    _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i No response from SE", buf, 0x22u);
  }

  double v45 = (double)a4;
  uint64_t v46 = *(void *)(a1 + 80);
  double v47 = v45 / 1000.0;
  id v48 = objc_alloc((Class)NSError);
  id v16 = +[NSString stringWithUTF8String:"nfcd"];
  v70[0] = NSLocalizedDescriptionKey;
  uint64_t v49 = +[NSString stringWithUTF8String:"Empty response"];
  v71[0] = v49;
  v71[1] = &off_10031C7E0;
  v70[1] = @"Line";
  v70[2] = @"Method";
  id v50 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 88))];
  v71[2] = v50;
  v70[3] = NSDebugDescriptionErrorKey;
  id v51 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 88)), 1197];
  v71[3] = v51;
  __int16 v52 = +[NSDictionary dictionaryWithObjects:v71 forKeys:v70 count:4];
  id v53 = [v48 initWithDomain:v16 code:66 userInfo:v52];
  (*(void (**)(uint64_t, void, uint64_t, id, double))(v46 + 16))(v46, 0, -1, v53, v47);

LABEL_38:
}

void sub_100170640(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 1240, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    id v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    id v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 56));
    id v15 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)long long buf = 67110146;
    int v67 = v12;
    __int16 v68 = 2082;
    uint64_t v69 = v13;
    __int16 v70 = 2082;
    int v71 = v14;
    __int16 v72 = 1024;
    int v73 = 1240;
    __int16 v74 = 2114;
    int v75 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    uint64_t v32 = [*(id *)(a1 + 32) _getSecureElementWrapperForSEID:*(void *)(a1 + 40)];
    if ([*(id *)(a1 + 32) _activateSecureElementWrapper:v32])
    {
      uint64_t v36 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      BOOL v37 = [v36 handle];
      __int16 v38 = [v37 info];
      unsigned __int8 v39 = [v38 restrictedMode];

      if ((v39 & 1) == 0)
      {
        uint64_t v40 = +[_NFHardwareManager sharedHardwareManager];
        [v40 refreshSecureElementInfo];
      }
      uint64_t v41 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      uint64_t v34 = sub_10024379C(v41);

      int v42 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      id v43 = sub_100250F44(v42);

      if ([*(id *)(a1 + 32) isDirty])
      {
        BOOL v44 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
        uint64_t v33 = [v44 refreshISDCounter];
      }
      else
      {
        uint64_t v33 = 0;
      }
      if (!(v34 | v33))
      {
        [*(id *)(a1 + 32) markAsDirty:0];
        (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
        uint64_t v34 = 0;
        uint64_t v33 = 0;
        goto LABEL_24;
      }
      if (v34) {
        uint64_t v49 = (void *)v34;
      }
      else {
        uint64_t v49 = (void *)v33;
      }
      uint64_t v59 = *(void *)(a1 + 48);
      id v50 = v49;
      id v51 = objc_alloc((Class)NSError);
      uint64_t v58 = +[NSString stringWithUTF8String:"nfcd"];
      v60[0] = NSLocalizedDescriptionKey;
      __int16 v52 = +[NSString stringWithUTF8String:"Commmand Error"];
      v61[0] = v52;
      v61[1] = v50;
      v60[1] = NSUnderlyingErrorKey;
      v60[2] = @"Line";
      v61[2] = &off_10031C810;
      v60[3] = @"Method";
      id v53 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
      v61[3] = v53;
      void v60[4] = NSDebugDescriptionErrorKey;
      id v54 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 1270];
      void v61[4] = v54;
      int v55 = +[NSDictionary dictionaryWithObjects:v61 forKeys:v60 count:5];
      id v56 = v51;
      double v47 = (void *)v58;
      id v57 = [v56 initWithDomain:v58 code:16 userInfo:v55];
      (*(void (**)(uint64_t, id))(v59 + 16))(v59, v57);
    }
    else
    {
      uint64_t v45 = *(void *)(a1 + 48);
      id v46 = objc_alloc((Class)NSError);
      uint64_t v33 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v62 = NSLocalizedDescriptionKey;
      uint64_t v34 = +[NSString stringWithUTF8String:"Stack Error"];
      uint64_t v63 = v34;
      double v47 = +[NSDictionary dictionaryWithObjects:&v63 forKeys:&v62 count:1];
      id v48 = [v46 initWithDomain:v33 code:15 userInfo:v47];
      (*(void (**)(uint64_t, id))(v45 + 16))(v45, v48);
    }
    goto LABEL_24;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v16 = NFLogGetLogger();
  if (v16)
  {
    id v17 = (void (*)(uint64_t, const char *, ...))v16;
    id v18 = object_getClass(*(id *)(a1 + 32));
    BOOL v19 = class_isMetaClass(v18);
    CFStringRef v20 = object_getClassName(*(id *)(a1 + 32));
    id v21 = sel_getName(*(SEL *)(a1 + 56));
    id v22 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v23 = 45;
    if (v19) {
      uint64_t v23 = 43;
    }
    v17(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v23, v20, v21, 1242, v22);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v24 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    uint64_t v25 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v25)) {
      int v26 = 43;
    }
    else {
      int v26 = 45;
    }
    __int16 v27 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v28 = sel_getName(*(SEL *)(a1 + 56));
    id v29 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v67 = v26;
    __int16 v68 = 2082;
    uint64_t v69 = v27;
    __int16 v70 = 2082;
    int v71 = v28;
    __int16 v72 = 1024;
    int v73 = 1242;
    __int16 v74 = 2114;
    int v75 = v29;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v30 = *(void *)(a1 + 48);
  if (v30)
  {
    id v31 = objc_alloc((Class)NSError);
    uint64_t v32 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v64 = NSLocalizedDescriptionKey;
    uint64_t v33 = +[NSString stringWithUTF8String:"Session not active"];
    uint64_t v65 = v33;
    uint64_t v34 = +[NSDictionary dictionaryWithObjects:&v65 forKeys:&v64 count:1];
    id v35 = [v31 initWithDomain:v32 code:54 userInfo:v34];
    (*(void (**)(uint64_t, id))(v30 + 16))(v30, v35);

LABEL_24:
  }
}

void sub_100170E6C(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 1279, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    id v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    id v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
    id v15 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)long long buf = 67110146;
    int v60 = v12;
    __int16 v61 = 2082;
    NSErrorUserInfoKey v62 = v13;
    __int16 v63 = 2082;
    NSErrorUserInfoKey v64 = v14;
    __int16 v65 = 1024;
    int v66 = 1279;
    __int16 v67 = 2114;
    __int16 v68 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    if ([*(id *)(a1 + 32) uid]) {
      uint64_t v36 = (uint64_t)[*(id *)(a1 + 32) uid];
    }
    else {
      uint64_t v36 = 0xFFFFFFFFLL;
    }
    BOOL v37 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
    unsigned int v38 = sub_1001FAED8(v37, v36);

    switch(v38)
    {
      case 0x18u:
        uint64_t v40 = *(void *)(a1 + 40);
        id v41 = objc_alloc((Class)NSError);
        uint64_t v32 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v53 = NSLocalizedDescriptionKey;
        uint64_t v33 = +[NSString stringWithUTF8String:"Restricted Mode"];
        id v54 = v33;
        int v42 = +[NSDictionary dictionaryWithObjects:&v54 forKeys:&v53 count:1];
        id v43 = v41;
        BOOL v44 = v32;
        uint64_t v45 = 24;
        break;
      case 8u:
        uint64_t v40 = *(void *)(a1 + 40);
        id v46 = objc_alloc((Class)NSError);
        uint64_t v32 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v55 = NSLocalizedDescriptionKey;
        uint64_t v33 = +[NSString stringWithUTF8String:"Security Not Initialized"];
        id v56 = v33;
        int v42 = +[NSDictionary dictionaryWithObjects:&v56 forKeys:&v55 count:1];
        id v43 = v46;
        BOOL v44 = v32;
        uint64_t v45 = 27;
        break;
      case 0u:
        uint64_t v39 = *(void *)(a1 + 40);
        uint64_t v32 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
        (*(void (**)(uint64_t, void, void, id))(v39 + 16))(v39, 0, 0, [v32 getPairingVersion]);
        goto LABEL_25;
      default:
        uint64_t v40 = *(void *)(a1 + 40);
        id v47 = objc_alloc((Class)NSError);
        uint64_t v32 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v51 = NSLocalizedDescriptionKey;
        uint64_t v33 = +[NSString stringWithUTF8String:"Unknown Error"];
        __int16 v52 = v33;
        int v42 = +[NSDictionary dictionaryWithObjects:&v52 forKeys:&v51 count:1];
        id v43 = v47;
        BOOL v44 = v32;
        uint64_t v45 = 6;
        break;
    }
    id v48 = [v43 initWithDomain:v44 code:v45 userInfo:v42];
    uint64_t v49 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
    id v50 = [v49 serialNumber];
    (*(void (**)(uint64_t, id, void *, void))(v40 + 16))(v40, v48, v50, 0);

LABEL_24:
LABEL_25:

    return;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v16 = NFLogGetLogger();
  if (v16)
  {
    id v17 = (void (*)(uint64_t, const char *, ...))v16;
    id v18 = object_getClass(*(id *)(a1 + 32));
    BOOL v19 = class_isMetaClass(v18);
    CFStringRef v20 = object_getClassName(*(id *)(a1 + 32));
    id v21 = sel_getName(*(SEL *)(a1 + 48));
    id v22 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v23 = 45;
    if (v19) {
      uint64_t v23 = 43;
    }
    v17(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v23, v20, v21, 1281, v22);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v24 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    uint64_t v25 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v25)) {
      int v26 = 43;
    }
    else {
      int v26 = 45;
    }
    __int16 v27 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v28 = sel_getName(*(SEL *)(a1 + 48));
    id v29 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v60 = v26;
    __int16 v61 = 2082;
    NSErrorUserInfoKey v62 = v27;
    __int16 v63 = 2082;
    NSErrorUserInfoKey v64 = v28;
    __int16 v65 = 1024;
    int v66 = 1281;
    __int16 v67 = 2114;
    __int16 v68 = v29;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v30 = *(void *)(a1 + 40);
  if (v30)
  {
    id v31 = objc_alloc((Class)NSError);
    uint64_t v32 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v57 = NSLocalizedDescriptionKey;
    uint64_t v33 = +[NSString stringWithUTF8String:"Session not active"];
    uint64_t v58 = v33;
    uint64_t v34 = +[NSDictionary dictionaryWithObjects:&v58 forKeys:&v57 count:1];
    id v35 = [v31 initWithDomain:v32 code:54 userInfo:v34];
    (*(void (**)(uint64_t, id, void, void))(v30 + 16))(v30, v35, 0, 0);

    goto LABEL_24;
  }
}

void sub_1001715E0(uint64_t a1)
{
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 1313, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      id v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      id v13 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v14 = sel_getName(*(SEL *)(a1 + 56));
      id v15 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)long long buf = 67110146;
      int v29 = v12;
      __int16 v30 = 2082;
      id v31 = v13;
      __int16 v32 = 2082;
      uint64_t v33 = v14;
      __int16 v34 = 1024;
      int v35 = 1313;
      __int16 v36 = 2114;
      BOOL v37 = v15;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v16 = *(void *)(a1 + 48);
    if (v16)
    {
      id v17 = objc_alloc((Class)NSError);
      id v18 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v26 = NSLocalizedDescriptionKey;
      BOOL v19 = +[NSString stringWithUTF8String:"Session not active"];
      __int16 v27 = v19;
      CFStringRef v20 = +[NSDictionary dictionaryWithObjects:&v27 forKeys:&v26 count:1];
      id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
      (*(void (**)(uint64_t, id))(v16 + 16))(v16, v21);
    }
  }
  else
  {
    id v25 = [*(id *)(a1 + 32) _getSecureElementWrapperForSEID:*(void *)(a1 + 40)];
    uint64_t v22 = *(void *)(a1 + 48);
    uint64_t v23 = +[_NFHardwareManager sharedHardwareManager];
    uint64_t v24 = [v23 secureElementDidExitRestrictedMode:v25 os:0];
    (*(void (**)(uint64_t, void *))(v22 + 16))(v22, v24);
  }
}

void sub_1001719F4(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 1325, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    id v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    id v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
    id v15 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)long long buf = 67110146;
    int v75 = v12;
    __int16 v76 = 2082;
    int v77 = v13;
    __int16 v78 = 2082;
    NSErrorUserInfoKey v79 = v14;
    __int16 v80 = 1024;
    int v81 = 1325;
    __int16 v82 = 2114;
    uint64_t v83 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    uint64_t v39 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];

    if (v39)
    {
      uint64_t v40 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      id v41 = v40;
      int v66 = 0;
      __int16 v67 = 0;
      if (v40)
      {
        unsigned int v42 = sub_1001FCE84(v40, &v67, &v66);
        BOOL v44 = v66;
        id v43 = v67;
      }
      else
      {
        BOOL v44 = 0;
        id v43 = 0;
        unsigned int v42 = 0;
      }
      id v32 = v43;
      id v33 = v44;

      if (v42)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v45 = NFLogGetLogger();
        if (v45)
        {
          id v46 = (void (*)(uint64_t, const char *, ...))v45;
          id v47 = object_getClass(*(id *)(a1 + 32));
          BOOL v48 = class_isMetaClass(v47);
          uint64_t v49 = object_getClassName(*(id *)(a1 + 32));
          __int16 v65 = sel_getName(*(SEL *)(a1 + 48));
          uint64_t v50 = 45;
          if (v48) {
            uint64_t v50 = 43;
          }
          v46(3, "%c[%{public}s %{public}s]:%i Failed to get cryptogram", v50, v49, v65, 1340);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        NSErrorUserInfoKey v51 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
        {
          __int16 v52 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v52)) {
            int v53 = 43;
          }
          else {
            int v53 = 45;
          }
          id v54 = object_getClassName(*(id *)(a1 + 32));
          NSErrorUserInfoKey v55 = sel_getName(*(SEL *)(a1 + 48));
          *(_DWORD *)long long buf = 67109890;
          int v75 = v53;
          __int16 v76 = 2082;
          int v77 = v54;
          __int16 v78 = 2082;
          NSErrorUserInfoKey v79 = v55;
          __int16 v80 = 1024;
          int v81 = 1340;
          _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get cryptogram", buf, 0x22u);
        }

        uint64_t v56 = *(void *)(a1 + 40);
        id v57 = objc_alloc((Class)NSError);
        uint64_t v58 = +[NSString stringWithUTF8String:"nfcd"];
        uint64_t v59 = v42;
        NSErrorUserInfoKey v68 = NSLocalizedDescriptionKey;
        if (v42 >= 0x47) {
          int v60 = 71;
        }
        else {
          int v60 = v42;
        }
        __int16 v61 = +[NSString stringWithUTF8String:off_100305838[v60]];
        uint64_t v69 = v61;
        NSErrorUserInfoKey v62 = +[NSDictionary dictionaryWithObjects:&v69 forKeys:&v68 count:1];
        id v63 = [v57 initWithDomain:v58 code:v59 userInfo:v62];
        (*(void (**)(uint64_t, void, void, id))(v56 + 16))(v56, 0, 0, v63);
      }
      else
      {
        (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
      }
      goto LABEL_25;
    }
    uint64_t v30 = *(void *)(a1 + 40);
    id v64 = objc_alloc((Class)NSError);
    id v32 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v70 = NSLocalizedDescriptionKey;
    id v33 = +[NSString stringWithUTF8String:"Stack Error"];
    id v71 = v33;
    __int16 v34 = +[NSDictionary dictionaryWithObjects:&v71 forKeys:&v70 count:1];
    int v35 = v64;
    id v36 = v32;
    uint64_t v37 = 15;
LABEL_24:
    id v38 = [v35 initWithDomain:v36 code:v37 userInfo:v34];
    (*(void (**)(uint64_t, void, void, id))(v30 + 16))(v30, 0, 0, v38);

LABEL_25:
    return;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v16 = NFLogGetLogger();
  if (v16)
  {
    id v17 = (void (*)(uint64_t, const char *, ...))v16;
    id v18 = object_getClass(*(id *)(a1 + 32));
    BOOL v19 = class_isMetaClass(v18);
    CFStringRef v20 = object_getClassName(*(id *)(a1 + 32));
    id v21 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v22 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v23 = 45;
    if (v19) {
      uint64_t v23 = 43;
    }
    v17(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v23, v20, v21, 1327, v22);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v24 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    id v25 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v25)) {
      int v26 = 43;
    }
    else {
      int v26 = 45;
    }
    __int16 v27 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v28 = sel_getName(*(SEL *)(a1 + 48));
    int v29 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v75 = v26;
    __int16 v76 = 2082;
    int v77 = v27;
    __int16 v78 = 2082;
    NSErrorUserInfoKey v79 = v28;
    __int16 v80 = 1024;
    int v81 = 1327;
    __int16 v82 = 2114;
    uint64_t v83 = v29;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v30 = *(void *)(a1 + 40);
  if (v30)
  {
    id v31 = objc_alloc((Class)NSError);
    id v32 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v72 = NSLocalizedDescriptionKey;
    id v33 = +[NSString stringWithUTF8String:"Session not active"];
    id v73 = v33;
    __int16 v34 = +[NSDictionary dictionaryWithObjects:&v73 forKeys:&v72 count:1];
    int v35 = v31;
    id v36 = v32;
    uint64_t v37 = 54;
    goto LABEL_24;
  }
}

void sub_100172250(uint64_t a1)
{
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 1358, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      id v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      id v13 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v14 = sel_getName(*(SEL *)(a1 + 56));
      id v15 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)long long buf = 67110146;
      int v60 = v12;
      __int16 v61 = 2082;
      NSErrorUserInfoKey v62 = v13;
      __int16 v63 = 2082;
      id v64 = v14;
      __int16 v65 = 1024;
      int v66 = 1358;
      __int16 v67 = 2114;
      NSErrorUserInfoKey v68 = v15;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v16 = *(void *)(a1 + 48);
    if (v16)
    {
      id v17 = objc_alloc((Class)NSError);
      id v18 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v57 = NSLocalizedDescriptionKey;
      BOOL v19 = +[NSString stringWithUTF8String:"Session not active"];
      uint64_t v58 = v19;
      CFStringRef v20 = +[NSDictionary dictionaryWithObjects:&v58 forKeys:&v57 count:1];
      id v21 = v17;
      uint64_t v22 = v18;
      uint64_t v23 = 54;
LABEL_15:
      id v24 = [v21 initWithDomain:v22 code:v23 userInfo:v20];
      (*(void (**)(uint64_t, id))(v16 + 16))(v16, v24);

LABEL_16:
    }
  }
  else
  {
    id v25 = NFSharedSignpostLog();
    if (os_signpost_enabled(v25))
    {
      *(_WORD *)long long buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v25, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEMSession:setExpressPassConfig", "processing", buf, 2u);
    }

    int v26 = [*(id *)(a1 + 32) expressModeManager];

    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v27 = NFLogGetLogger();
    uint64_t v28 = (void (*)(uint64_t, const char *, ...))v27;
    if (v26)
    {
      if (v27)
      {
        int v29 = object_getClass(*(id *)(a1 + 32));
        BOOL v30 = class_isMetaClass(v29);
        id v31 = object_getClassName(*(id *)(a1 + 32));
        id v32 = sel_getName(*(SEL *)(a1 + 56));
        id v33 = [*(id *)(a1 + 32) clientName];
        uint64_t v34 = 45;
        if (v30) {
          uint64_t v34 = 43;
        }
        v28(6, "%c[%{public}s %{public}s]:%i %{public}@", v34, v31, v32, 1371, v33);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v35 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEFAULT))
      {
        id v36 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v36)) {
          int v37 = 43;
        }
        else {
          int v37 = 45;
        }
        id v38 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v39 = sel_getName(*(SEL *)(a1 + 56));
        uint64_t v40 = [*(id *)(a1 + 32) clientName];
        *(_DWORD *)long long buf = 67110146;
        int v60 = v37;
        __int16 v61 = 2082;
        NSErrorUserInfoKey v62 = v38;
        __int16 v63 = 2082;
        id v64 = v39;
        __int16 v65 = 1024;
        int v66 = 1371;
        __int16 v67 = 2114;
        NSErrorUserInfoKey v68 = v40;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
      }
      id v41 = [*(id *)(a1 + 32) expressModeManager];
      id v18 = sub_1000439FC((uint64_t)v41, *(void **)(a1 + 40), *(unsigned __int8 *)(a1 + 64), 1);

      unsigned int v42 = NFSharedSignpostLog();
      if (os_signpost_enabled(v42))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v42, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:setExpressPassConfig", "user callback", buf, 2u);
      }

      (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
      goto LABEL_16;
    }
    if (v27)
    {
      id v43 = object_getClass(*(id *)(a1 + 32));
      BOOL v44 = class_isMetaClass(v43);
      uint64_t v45 = object_getClassName(*(id *)(a1 + 32));
      id v54 = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v46 = 45;
      if (v44) {
        uint64_t v46 = 43;
      }
      v28(3, "%c[%{public}s %{public}s]:%i EMM is nil!", v46, v45, v54, 1363);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v47 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
    {
      BOOL v48 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v48)) {
        int v49 = 43;
      }
      else {
        int v49 = 45;
      }
      uint64_t v50 = object_getClassName(*(id *)(a1 + 32));
      NSErrorUserInfoKey v51 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)long long buf = 67109890;
      int v60 = v49;
      __int16 v61 = 2082;
      NSErrorUserInfoKey v62 = v50;
      __int16 v63 = 2082;
      id v64 = v51;
      __int16 v65 = 1024;
      int v66 = 1363;
      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i EMM is nil!", buf, 0x22u);
    }

    if (*(void *)(a1 + 48))
    {
      __int16 v52 = NFSharedSignpostLog();
      if (os_signpost_enabled(v52))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v52, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:setExpressPassConfig", "failure", buf, 2u);
      }

      uint64_t v16 = *(void *)(a1 + 48);
      id v53 = objc_alloc((Class)NSError);
      id v18 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v55 = NSLocalizedDescriptionKey;
      BOOL v19 = +[NSString stringWithUTF8String:"Invalid State"];
      uint64_t v56 = v19;
      CFStringRef v20 = +[NSDictionary dictionaryWithObjects:&v56 forKeys:&v55 count:1];
      id v21 = v53;
      uint64_t v22 = v18;
      uint64_t v23 = 12;
      goto LABEL_15;
    }
  }
}

void sub_100172A08(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 1383, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    id v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    id v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
    id v15 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)long long buf = 67110146;
    int v50 = v12;
    __int16 v51 = 2082;
    __int16 v52 = v13;
    __int16 v53 = 2082;
    id v54 = v14;
    __int16 v55 = 1024;
    int v56 = 1383;
    __int16 v57 = 2114;
    uint64_t v58 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    id v36 = [*(id *)(a1 + 32) expressModeManager];

    if (v36)
    {
      int v37 = [*(id *)(a1 + 32) expressModeManager];
      sub_1000444D4(v37);
      id v32 = (id)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      id v38 = objc_alloc((Class)NSError);
      uint64_t v39 = +[NSString stringWithUTF8String:"nfcd"];
      v45[0] = NSLocalizedDescriptionKey;
      uint64_t v40 = +[NSString stringWithUTF8String:"Feature Not Supported"];
      v46[0] = v40;
      v46[1] = &off_10031C828;
      v45[1] = @"Line";
      v45[2] = @"Method";
      id v41 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
      v46[2] = v41;
      v45[3] = NSDebugDescriptionErrorKey;
      id v42 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 1389];
      v46[3] = v42;
      void v45[4] = NSLocalizedFailureReasonErrorKey;
      id v43 = [objc_alloc((Class)NSString) initWithFormat:@"EMM not initialized"];
      void v46[4] = v43;
      BOOL v44 = +[NSDictionary dictionaryWithObjects:v46 forKeys:v45 count:5];
      id v32 = [v38 initWithDomain:v39 code:14 userInfo:v44];
    }
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    goto LABEL_24;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v16 = NFLogGetLogger();
  if (v16)
  {
    id v17 = (void (*)(uint64_t, const char *, ...))v16;
    id v18 = object_getClass(*(id *)(a1 + 32));
    BOOL v19 = class_isMetaClass(v18);
    CFStringRef v20 = object_getClassName(*(id *)(a1 + 32));
    id v21 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v22 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v23 = 45;
    if (v19) {
      uint64_t v23 = 43;
    }
    v17(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v23, v20, v21, 1385, v22);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v24 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    id v25 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v25)) {
      int v26 = 43;
    }
    else {
      int v26 = 45;
    }
    uint64_t v27 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v28 = sel_getName(*(SEL *)(a1 + 48));
    int v29 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v50 = v26;
    __int16 v51 = 2082;
    __int16 v52 = v27;
    __int16 v53 = 2082;
    id v54 = v28;
    __int16 v55 = 1024;
    int v56 = 1385;
    __int16 v57 = 2114;
    uint64_t v58 = v29;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v30 = *(void *)(a1 + 40);
  if (v30)
  {
    id v31 = objc_alloc((Class)NSError);
    id v32 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v47 = NSLocalizedDescriptionKey;
    id v33 = +[NSString stringWithUTF8String:"Session not active"];
    BOOL v48 = v33;
    uint64_t v34 = +[NSDictionary dictionaryWithObjects:&v48 forKeys:&v47 count:1];
    id v35 = [v31 initWithDomain:v32 code:54 userInfo:v34];
    (*(void (**)(uint64_t, void, id))(v30 + 16))(v30, 0, v35);

LABEL_24:
  }
}

void sub_10017310C(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 1403, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    id v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    id v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
    id v15 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)long long buf = 67110146;
    int v117 = v12;
    __int16 v118 = 2082;
    uint64_t v119 = v13;
    __int16 v120 = 2082;
    id v121 = v14;
    __int16 v122 = 1024;
    int v123 = 1403;
    __int16 v124 = 2114;
    int v125 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v16 = NFLogGetLogger();
    if (v16)
    {
      id v17 = (void (*)(uint64_t, const char *, ...))v16;
      id v18 = object_getClass(*(id *)(a1 + 32));
      BOOL v19 = class_isMetaClass(v18);
      CFStringRef v20 = object_getClassName(*(id *)(a1 + 32));
      id v21 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v22 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v23 = 45;
      if (v19) {
        uint64_t v23 = 43;
      }
      v17(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v23, v20, v21, 1405, v22);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v24 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
    {
      id v25 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v25)) {
        int v26 = 43;
      }
      else {
        int v26 = 45;
      }
      uint64_t v27 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v28 = sel_getName(*(SEL *)(a1 + 48));
      int v29 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)long long buf = 67110146;
      int v117 = v26;
      __int16 v118 = 2082;
      uint64_t v119 = v27;
      __int16 v120 = 2082;
      id v121 = v28;
      __int16 v122 = 1024;
      int v123 = 1405;
      __int16 v124 = 2114;
      int v125 = v29;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v30 = *(void *)(a1 + 40);
    if (v30)
    {
      id v31 = objc_alloc((Class)NSError);
      id v32 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v114 = NSLocalizedDescriptionKey;
      id v33 = +[NSString stringWithUTF8String:"Session not active"];
      uint64_t v115 = v33;
      uint64_t v34 = +[NSDictionary dictionaryWithObjects:&v115 forKeys:&v114 count:1];
      id v35 = [v31 initWithDomain:v32 code:54 userInfo:v34];
      (*(void (**)(uint64_t, id))(v30 + 16))(v30, v35);
    }
    return;
  }
  id v36 = NFSharedSignpostLog();
  if (os_signpost_enabled(v36))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v36, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEMSession:setExpressModesControlState", "processing", buf, 2u);
  }

  if (*(void *)(a1 + 56) == 1)
  {
    int v37 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
    id v38 = [v37 handle];
    uint64_t v39 = [v38 info];
    unsigned int v40 = [v39 restrictedMode];

    if (v40)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v41 = NFLogGetLogger();
      if (v41)
      {
        id v42 = (void (*)(uint64_t, const char *, ...))v41;
        id v43 = object_getClass(*(id *)(a1 + 32));
        BOOL v44 = class_isMetaClass(v43);
        uint64_t v45 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v105 = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v46 = 45;
        if (v44) {
          uint64_t v46 = 43;
        }
        v42(3, "%c[%{public}s %{public}s]:%i SE in restricted mode", v46, v45, v105, 1412);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      NSErrorUserInfoKey v47 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
      {
        BOOL v48 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v48)) {
          int v49 = 43;
        }
        else {
          int v49 = 45;
        }
        int v50 = object_getClassName(*(id *)(a1 + 32));
        __int16 v51 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)long long buf = 67109890;
        int v117 = v49;
        __int16 v118 = 2082;
        uint64_t v119 = v50;
        __int16 v120 = 2082;
        id v121 = v51;
        __int16 v122 = 1024;
        int v123 = 1412;
        _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i SE in restricted mode", buf, 0x22u);
      }

      if (*(void *)(a1 + 40))
      {
        __int16 v52 = NFSharedSignpostLog();
        if (os_signpost_enabled(v52))
        {
          *(_WORD *)long long buf = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v52, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:setExpressModesControlState", "failure", buf, 2u);
        }

        uint64_t v53 = *(void *)(a1 + 40);
        id v54 = objc_alloc((Class)NSError);
        __int16 v55 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v112 = NSLocalizedDescriptionKey;
        int v56 = +[NSString stringWithUTF8String:"Restricted Mode"];
        int v113 = v56;
        __int16 v57 = +[NSDictionary dictionaryWithObjects:&v113 forKeys:&v112 count:1];
        uint64_t v58 = v54;
        uint64_t v59 = v55;
        uint64_t v60 = 24;
LABEL_82:
        id v104 = [v58 initWithDomain:v59 code:v60 userInfo:v57];
        (*(void (**)(uint64_t, id))(v53 + 16))(v53, v104);

        return;
      }
      return;
    }
    __int16 v61 = +[_NFHardwareManager sharedHardwareManager];
    id v62 = [v61 nfcRadioEnabled:0 showUIPopup:0];

    if (!v62)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v91 = NFLogGetLogger();
      if (v91)
      {
        uint64_t v92 = (void (*)(uint64_t, const char *, ...))v91;
        __int16 v93 = object_getClass(*(id *)(a1 + 32));
        BOOL v94 = class_isMetaClass(v93);
        BOOL v95 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v107 = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v96 = 45;
        if (v94) {
          uint64_t v96 = 43;
        }
        v92(6, "%c[%{public}s %{public}s]:%i NFC radio disabled", v96, v95, v107, 1421);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v97 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v97, OS_LOG_TYPE_DEFAULT))
      {
        id v98 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v98)) {
          int v99 = 43;
        }
        else {
          int v99 = 45;
        }
        __int16 v100 = object_getClassName(*(id *)(a1 + 32));
        id v101 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)long long buf = 67109890;
        int v117 = v99;
        __int16 v118 = 2082;
        uint64_t v119 = v100;
        __int16 v120 = 2082;
        id v121 = v101;
        __int16 v122 = 1024;
        int v123 = 1421;
        _os_log_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NFC radio disabled", buf, 0x22u);
      }

      if (*(void *)(a1 + 40))
      {
        id v102 = NFSharedSignpostLog();
        if (os_signpost_enabled(v102))
        {
          *(_WORD *)long long buf = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v102, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:setExpressModesControlState", "failure", buf, 2u);
        }

        uint64_t v53 = *(void *)(a1 + 40);
        id v103 = objc_alloc((Class)NSError);
        __int16 v55 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v110 = NSLocalizedDescriptionKey;
        int v56 = +[NSString stringWithUTF8String:"NFC radio disabled"];
        uint64_t v111 = v56;
        __int16 v57 = +[NSDictionary dictionaryWithObjects:&v111 forKeys:&v110 count:1];
        uint64_t v58 = v103;
        uint64_t v59 = v55;
        uint64_t v60 = 50;
        goto LABEL_82;
      }
      return;
    }
  }
  __int16 v63 = [*(id *)(a1 + 32) expressModeManager];

  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v64 = NFLogGetLogger();
  __int16 v65 = (void (*)(uint64_t, const char *, ...))v64;
  if (v63)
  {
    if (v64)
    {
      int v66 = object_getClass(*(id *)(a1 + 32));
      BOOL v67 = class_isMetaClass(v66);
      NSErrorUserInfoKey v68 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v69 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v70 = 45;
      if (v67) {
        uint64_t v70 = 43;
      }
      v65(6, "%c[%{public}s %{public}s]:%i state=%ld", v70, v68, v69, 1439, *(void *)(a1 + 56));
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v71 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
    {
      NSErrorUserInfoKey v72 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v72)) {
        int v73 = 43;
      }
      else {
        int v73 = 45;
      }
      __int16 v74 = object_getClassName(*(id *)(a1 + 32));
      int v75 = sel_getName(*(SEL *)(a1 + 48));
      __int16 v76 = *(void **)(a1 + 56);
      *(_DWORD *)long long buf = 67110146;
      int v117 = v73;
      __int16 v118 = 2082;
      uint64_t v119 = v74;
      __int16 v120 = 2082;
      id v121 = v75;
      __int16 v122 = 1024;
      int v123 = 1439;
      __int16 v124 = 2048;
      int v125 = v76;
      _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i state=%ld", buf, 0x2Cu);
    }

    int v77 = [*(id *)(a1 + 32) expressModeManager];
    id v78 = sub_1000429A8((uint64_t)v77, *(void *)(a1 + 56));

    NSErrorUserInfoKey v79 = NFSharedSignpostLog();
    if (os_signpost_enabled(v79))
    {
      *(_WORD *)long long buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v79, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:setExpressModesControlState", "user callback", buf, 2u);
    }

    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
  else
  {
    if (v64)
    {
      __int16 v80 = object_getClass(*(id *)(a1 + 32));
      BOOL v81 = class_isMetaClass(v80);
      __int16 v82 = object_getClassName(*(id *)(a1 + 32));
      BOOL v106 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v83 = 45;
      if (v81) {
        uint64_t v83 = 43;
      }
      v65(3, "%c[%{public}s %{public}s]:%i EMM is nil!", v83, v82, v106, 1431);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    long long v84 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
    {
      int v85 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v85)) {
        int v86 = 43;
      }
      else {
        int v86 = 45;
      }
      NSErrorUserInfoKey v87 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v88 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)long long buf = 67109890;
      int v117 = v86;
      __int16 v118 = 2082;
      uint64_t v119 = v87;
      __int16 v120 = 2082;
      id v121 = v88;
      __int16 v122 = 1024;
      int v123 = 1431;
      _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i EMM is nil!", buf, 0x22u);
    }

    if (*(void *)(a1 + 40))
    {
      BOOL v89 = NFSharedSignpostLog();
      if (os_signpost_enabled(v89))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v89, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:setExpressModesControlState", "failure", buf, 2u);
      }

      uint64_t v53 = *(void *)(a1 + 40);
      id v90 = objc_alloc((Class)NSError);
      __int16 v55 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v108 = NSLocalizedDescriptionKey;
      int v56 = +[NSString stringWithUTF8String:"Invalid State"];
      int v109 = v56;
      __int16 v57 = +[NSDictionary dictionaryWithObjects:&v109 forKeys:&v108 count:1];
      uint64_t v58 = v90;
      uint64_t v59 = v55;
      uint64_t v60 = 12;
      goto LABEL_82;
    }
  }
}

void sub_100173EF0(uint64_t a1)
{
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 1451, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      id v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      id v13 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v14 = sel_getName(*(SEL *)(a1 + 56));
      id v15 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)long long buf = 67110146;
      int v84 = v12;
      __int16 v85 = 2082;
      int v86 = v13;
      __int16 v87 = 2082;
      uint64_t v88 = v14;
      __int16 v89 = 1024;
      int v90 = 1451;
      __int16 v91 = 2114;
      uint64_t v92 = v15;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v16 = *(void *)(a1 + 48);
    if (v16)
    {
      id v17 = objc_alloc((Class)NSError);
      id v18 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v81 = NSLocalizedDescriptionKey;
      BOOL v19 = +[NSString stringWithUTF8String:"Session not active"];
      __int16 v82 = v19;
      CFStringRef v20 = +[NSDictionary dictionaryWithObjects:&v82 forKeys:&v81 count:1];
      id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
      (*(void (**)(uint64_t, id))(v16 + 16))(v16, v21);
    }
    return;
  }
  uint64_t v22 = NFSharedSignpostLog();
  if (os_signpost_enabled(v22))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v22, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEMSession:restoreAuthorizationForAllAppletsExcept", "processing", buf, 2u);
  }

  uint64_t v23 = [*(id *)(a1 + 32) expressModeManager];

  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v24 = NFLogGetLogger();
  id v25 = (void (*)(uint64_t, const char *, ...))v24;
  if (v23)
  {
    if (v24)
    {
      int v26 = object_getClass(*(id *)(a1 + 32));
      BOOL v27 = class_isMetaClass(v26);
      uint64_t v28 = object_getClassName(*(id *)(a1 + 32));
      int v29 = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v30 = 45;
      if (v27) {
        uint64_t v30 = 43;
      }
      v25(6, "%c[%{public}s %{public}s]:%i %{public}@", v30, v28, v29, 1464, *(void *)(a1 + 40));
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v31 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
    {
      id v32 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v32)) {
        int v33 = 43;
      }
      else {
        int v33 = 45;
      }
      uint64_t v34 = object_getClassName(*(id *)(a1 + 32));
      id v35 = sel_getName(*(SEL *)(a1 + 56));
      id v36 = *(void **)(a1 + 40);
      *(_DWORD *)long long buf = 67110146;
      int v84 = v33;
      __int16 v85 = 2082;
      int v86 = v34;
      __int16 v87 = 2082;
      uint64_t v88 = v35;
      __int16 v89 = 1024;
      int v90 = 1464;
      __int16 v91 = 2114;
      uint64_t v92 = v36;
      _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
    }

    int v37 = [*(id *)(a1 + 32) expressModeManager];
    unsigned int v38 = sub_10004471C(v37, *(void **)(a1 + 40), [*(id *)(a1 + 32) uid]);

    if (v38)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v39 = NFLogGetLogger();
      if (v39)
      {
        unsigned int v40 = (void (*)(uint64_t, const char *, ...))v39;
        uint64_t v41 = object_getClass(*(id *)(a1 + 32));
        BOOL v42 = class_isMetaClass(v41);
        id v43 = object_getClassName(*(id *)(a1 + 32));
        int v75 = sel_getName(*(SEL *)(a1 + 56));
        uint64_t v44 = 45;
        if (v42) {
          uint64_t v44 = 43;
        }
        v40(3, "%c[%{public}s %{public}s]:%i Failed to restore authorization on all applets", v44, v43, v75, 1468);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v45 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
      {
        uint64_t v46 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v46)) {
          int v47 = 43;
        }
        else {
          int v47 = 45;
        }
        BOOL v48 = object_getClassName(*(id *)(a1 + 32));
        int v49 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)long long buf = 67109890;
        int v84 = v47;
        __int16 v85 = 2082;
        int v86 = v48;
        __int16 v87 = 2082;
        uint64_t v88 = v49;
        __int16 v89 = 1024;
        int v90 = 1468;
        _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to restore authorization on all applets", buf, 0x22u);
      }

      int v50 = NFSharedSignpostLog();
      if (os_signpost_enabled(v50))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v50, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:restoreAuthorizationForAllAppletsExcept", "failure", buf, 2u);
      }

      uint64_t v51 = *(void *)(a1 + 48);
      id v52 = objc_alloc((Class)NSError);
      uint64_t v53 = +[NSString stringWithUTF8String:"nfcd"];
      uint64_t v54 = v38;
      NSErrorUserInfoKey v77 = NSLocalizedDescriptionKey;
      if (v38 >= 0x47) {
        int v55 = 71;
      }
      else {
        int v55 = v38;
      }
      int v56 = +[NSString stringWithUTF8String:off_100305838[v55]];
      id v78 = v56;
      __int16 v57 = +[NSDictionary dictionaryWithObjects:&v78 forKeys:&v77 count:1];
      id v58 = [v52 initWithDomain:v53 code:v54 userInfo:v57];
      (*(void (**)(uint64_t, id))(v51 + 16))(v51, v58);

LABEL_57:
      return;
    }
    __int16 v74 = NFSharedSignpostLog();
    if (os_signpost_enabled(v74))
    {
      *(_WORD *)long long buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v74, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:restoreAuthorizationForAllAppletsExcept", "user callback", buf, 2u);
    }

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  else
  {
    if (v24)
    {
      uint64_t v59 = object_getClass(*(id *)(a1 + 32));
      BOOL v60 = class_isMetaClass(v59);
      __int16 v61 = object_getClassName(*(id *)(a1 + 32));
      __int16 v76 = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v62 = 45;
      if (v60) {
        uint64_t v62 = 43;
      }
      v25(3, "%c[%{public}s %{public}s]:%i EMM is nil!", v62, v61, v76, 1456);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v63 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
    {
      uint64_t v64 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v64)) {
        int v65 = 43;
      }
      else {
        int v65 = 45;
      }
      int v66 = object_getClassName(*(id *)(a1 + 32));
      BOOL v67 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)long long buf = 67109890;
      int v84 = v65;
      __int16 v85 = 2082;
      int v86 = v66;
      __int16 v87 = 2082;
      uint64_t v88 = v67;
      __int16 v89 = 1024;
      int v90 = 1456;
      _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i EMM is nil!", buf, 0x22u);
    }

    if (*(void *)(a1 + 48))
    {
      NSErrorUserInfoKey v68 = NFSharedSignpostLog();
      if (os_signpost_enabled(v68))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v68, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:restoreAuthorizationForAllAppletsExcept", "failure", buf, 2u);
      }

      uint64_t v69 = *(void *)(a1 + 48);
      id v70 = objc_alloc((Class)NSError);
      uint64_t v53 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v79 = NSLocalizedDescriptionKey;
      id v71 = +[NSString stringWithUTF8String:"Invalid State"];
      __int16 v80 = v71;
      NSErrorUserInfoKey v72 = +[NSDictionary dictionaryWithObjects:&v80 forKeys:&v79 count:1];
      id v73 = [v70 initWithDomain:v53 code:12 userInfo:v72];
      (*(void (**)(uint64_t, id))(v69 + 16))(v69, v73);

      goto LABEL_57;
    }
  }
}

void sub_100174988(uint64_t a1)
{
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 64));
      uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 1484, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      id v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      id v13 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v14 = sel_getName(*(SEL *)(a1 + 64));
      id v15 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)long long buf = 67110146;
      int v69 = v12;
      __int16 v70 = 2082;
      id v71 = v13;
      __int16 v72 = 2082;
      id v73 = v14;
      __int16 v74 = 1024;
      int v75 = 1484;
      __int16 v76 = 2114;
      NSErrorUserInfoKey v77 = v15;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v16 = *(void *)(a1 + 56);
    if (v16)
    {
      id v17 = objc_alloc((Class)NSError);
      id v18 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v82 = NSLocalizedDescriptionKey;
      BOOL v19 = +[NSString stringWithUTF8String:"Session not active"];
      uint64_t v83 = v19;
      CFStringRef v20 = +[NSDictionary dictionaryWithObjects:&v83 forKeys:&v82 count:1];
      id v21 = v17;
      uint64_t v22 = v18;
      uint64_t v23 = 54;
LABEL_15:
      id v24 = [v21 initWithDomain:v22 code:v23 userInfo:v20];
      (*(void (**)(uint64_t, id))(v16 + 16))(v16, v24);

LABEL_16:
    }
  }
  else
  {
    id v25 = NFSharedSignpostLog();
    if (os_signpost_enabled(v25))
    {
      *(_WORD *)long long buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v25, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEMSession:restoreAuthorizarionForKeys", "processing", buf, 2u);
    }

    int v26 = [*(id *)(a1 + 32) expressModeManager];

    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v27 = NFLogGetLogger();
    uint64_t v28 = (void (*)(uint64_t, const char *, ...))v27;
    if (v26)
    {
      if (v27)
      {
        int v29 = object_getClass(*(id *)(a1 + 32));
        BOOL v30 = class_isMetaClass(v29);
        id v31 = object_getClassName(*(id *)(a1 + 32));
        id v32 = sel_getName(*(SEL *)(a1 + 64));
        uint64_t v33 = 45;
        if (v30) {
          uint64_t v33 = 43;
        }
        v28(6, "%c[%{public}s %{public}s]:%i keys: %{public}@  applet:%{public}@", v33, v31, v32, 1497, *(void *)(a1 + 40), *(void *)(a1 + 48));
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v34 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        id v35 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v35)) {
          int v36 = 43;
        }
        else {
          int v36 = 45;
        }
        int v37 = object_getClassName(*(id *)(a1 + 32));
        unsigned int v38 = sel_getName(*(SEL *)(a1 + 64));
        uint64_t v39 = *(void **)(a1 + 40);
        uint64_t v40 = *(void *)(a1 + 48);
        *(_DWORD *)long long buf = 67110402;
        int v69 = v36;
        __int16 v70 = 2082;
        id v71 = v37;
        __int16 v72 = 2082;
        id v73 = v38;
        __int16 v74 = 1024;
        int v75 = 1497;
        __int16 v76 = 2114;
        NSErrorUserInfoKey v77 = v39;
        __int16 v78 = 2114;
        uint64_t v79 = v40;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i keys: %{public}@  applet:%{public}@", buf, 0x36u);
      }

      uint64_t v41 = [*(id *)(a1 + 32) expressModeManager];
      id v18 = sub_100044A24((uint64_t)v41, *(void **)(a1 + 40), *(void **)(a1 + 48));

      BOOL v42 = NFSharedSignpostLog();
      if (os_signpost_enabled(v42))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v42, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:restoreAuthorizarionForKeys", "user callback", buf, 2u);
      }

      if (v18)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v43 = NFLogGetLogger();
        if (v43)
        {
          uint64_t v44 = (void (*)(uint64_t, const char *, ...))v43;
          uint64_t v45 = object_getClass(*(id *)(a1 + 32));
          BOOL v46 = class_isMetaClass(v45);
          int v47 = object_getClassName(*(id *)(a1 + 32));
          int v66 = sel_getName(*(SEL *)(a1 + 64));
          uint64_t v48 = 45;
          if (v46) {
            uint64_t v48 = 43;
          }
          v44(3, "%c[%{public}s %{public}s]:%i Failed to restore authorization on keys", v48, v47, v66, 1502);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v49 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v49, OS_LOG_TYPE_ERROR))
        {
          int v50 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v50)) {
            int v51 = 43;
          }
          else {
            int v51 = 45;
          }
          id v52 = object_getClassName(*(id *)(a1 + 32));
          uint64_t v53 = sel_getName(*(SEL *)(a1 + 64));
          *(_DWORD *)long long buf = 67109890;
          int v69 = v51;
          __int16 v70 = 2082;
          id v71 = v52;
          __int16 v72 = 2082;
          id v73 = v53;
          __int16 v74 = 1024;
          int v75 = 1502;
          _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to restore authorization on keys", buf, 0x22u);
        }

        uint64_t v54 = *(void (**)(void))(*(void *)(a1 + 56) + 16);
      }
      else
      {
        uint64_t v54 = *(void (**)(void))(*(void *)(a1 + 56) + 16);
      }
      v54();
      goto LABEL_16;
    }
    if (v27)
    {
      int v55 = object_getClass(*(id *)(a1 + 32));
      BOOL v56 = class_isMetaClass(v55);
      __int16 v57 = object_getClassName(*(id *)(a1 + 32));
      BOOL v67 = sel_getName(*(SEL *)(a1 + 64));
      uint64_t v58 = 45;
      if (v56) {
        uint64_t v58 = 43;
      }
      v28(3, "%c[%{public}s %{public}s]:%i EMM is nil!", v58, v57, v67, 1489);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v59 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v59, OS_LOG_TYPE_ERROR))
    {
      BOOL v60 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v60)) {
        int v61 = 43;
      }
      else {
        int v61 = 45;
      }
      uint64_t v62 = object_getClassName(*(id *)(a1 + 32));
      __int16 v63 = sel_getName(*(SEL *)(a1 + 64));
      *(_DWORD *)long long buf = 67109890;
      int v69 = v61;
      __int16 v70 = 2082;
      id v71 = v62;
      __int16 v72 = 2082;
      id v73 = v63;
      __int16 v74 = 1024;
      int v75 = 1489;
      _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i EMM is nil!", buf, 0x22u);
    }

    if (*(void *)(a1 + 56))
    {
      uint64_t v64 = NFSharedSignpostLog();
      if (os_signpost_enabled(v64))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v64, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:restoreAuthorizarionForKeys", "failure", buf, 2u);
      }

      uint64_t v16 = *(void *)(a1 + 56);
      id v65 = objc_alloc((Class)NSError);
      id v18 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v80 = NSLocalizedDescriptionKey;
      BOOL v19 = +[NSString stringWithUTF8String:"Invalid State"];
      NSErrorUserInfoKey v81 = v19;
      CFStringRef v20 = +[NSDictionary dictionaryWithObjects:&v81 forKeys:&v80 count:1];
      id v21 = v65;
      uint64_t v22 = v18;
      uint64_t v23 = 12;
      goto LABEL_15;
    }
  }
}

void sub_100175538(uint64_t a1)
{
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 72));
      uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 1535, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      id v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      id v13 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v14 = sel_getName(*(SEL *)(a1 + 72));
      id v15 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)long long buf = 67110146;
      int v84 = v12;
      __int16 v85 = 2082;
      int v86 = v13;
      __int16 v87 = 2082;
      uint64_t v88 = v14;
      __int16 v89 = 1024;
      int v90 = 1535;
      __int16 v91 = 2114;
      uint64_t v92 = v15;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v16 = *(void *)(a1 + 64);
    if (v16)
    {
      id v17 = objc_alloc((Class)NSError);
      id v18 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v97 = NSLocalizedDescriptionKey;
      BOOL v19 = +[NSString stringWithUTF8String:"Session not active"];
      id v98 = v19;
      CFStringRef v20 = +[NSDictionary dictionaryWithObjects:&v98 forKeys:&v97 count:1];
      id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
      (*(void (**)(uint64_t, id))(v16 + 16))(v16, v21);

LABEL_15:
LABEL_16:
    }
  }
  else
  {
    uint64_t v22 = NFSharedSignpostLog();
    if (os_signpost_enabled(v22))
    {
      *(_WORD *)long long buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v22, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEMSession:disableAuthorizationForApplets", "processing", buf, 2u);
    }

    uint64_t v23 = [*(id *)(a1 + 32) expressModeManager];

    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v24 = NFLogGetLogger();
    id v25 = (void (*)(uint64_t, const char *, ...))v24;
    if (v23)
    {
      if (v24)
      {
        int v26 = object_getClass(*(id *)(a1 + 32));
        BOOL v27 = class_isMetaClass(v26);
        uint64_t v28 = object_getClassName(*(id *)(a1 + 32));
        int v29 = sel_getName(*(SEL *)(a1 + 72));
        BOOL v30 = +[NFApplet aidListForPrinting:*(void *)(a1 + 40)];
        id v31 = [*(id *)(a1 + 32) clientName];
        uint64_t v32 = 45;
        if (v27) {
          uint64_t v32 = 43;
        }
        v25(6, "%c[%{public}s %{public}s]:%i applets=%{public}@  client=%{public}@", v32, v28, v29, 1548, v30, v31);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v33 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v34 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v34)) {
          int v35 = 43;
        }
        else {
          int v35 = 45;
        }
        int v36 = object_getClassName(*(id *)(a1 + 32));
        int v37 = sel_getName(*(SEL *)(a1 + 72));
        unsigned int v38 = +[NFApplet aidListForPrinting:*(void *)(a1 + 40)];
        uint64_t v39 = [*(id *)(a1 + 32) clientName];
        *(_DWORD *)long long buf = 67110402;
        int v84 = v35;
        __int16 v85 = 2082;
        int v86 = v36;
        __int16 v87 = 2082;
        uint64_t v88 = v37;
        __int16 v89 = 1024;
        int v90 = 1548;
        __int16 v91 = 2114;
        uint64_t v92 = v38;
        __int16 v93 = 2114;
        BOOL v94 = v39;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i applets=%{public}@  client=%{public}@", buf, 0x36u);
      }
      uint64_t v40 = [*(id *)(a1 + 32) expressModeManager];
      id v18 = sub_100048244(v40, *(void **)(a1 + 40), *(void **)(a1 + 48), *(void **)(a1 + 56));

      uint64_t v41 = NFSharedSignpostLog();
      if (os_signpost_enabled(v41))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v41, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:disableAuthorizationForApplets", "user callback", buf, 2u);
      }

      if (v18)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v42 = NFLogGetLogger();
        if (v42)
        {
          uint64_t v43 = (void (*)(uint64_t, const char *, ...))v42;
          uint64_t v44 = object_getClass(*(id *)(a1 + 32));
          BOOL v45 = class_isMetaClass(v44);
          BOOL v46 = object_getClassName(*(id *)(a1 + 32));
          uint64_t v79 = sel_getName(*(SEL *)(a1 + 72));
          uint64_t v47 = 45;
          if (v45) {
            uint64_t v47 = 43;
          }
          v43(3, "%c[%{public}s %{public}s]:%i Failed to disable auth on applet", v47, v46, v79, 1553);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v48 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
        {
          int v49 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v49)) {
            int v50 = 43;
          }
          else {
            int v50 = 45;
          }
          int v51 = object_getClassName(*(id *)(a1 + 32));
          id v52 = sel_getName(*(SEL *)(a1 + 72));
          *(_DWORD *)long long buf = 67109890;
          int v84 = v50;
          __int16 v85 = 2082;
          int v86 = v51;
          __int16 v87 = 2082;
          uint64_t v88 = v52;
          __int16 v89 = 1024;
          int v90 = 1553;
          _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to disable auth on applet", buf, 0x22u);
        }

        uint64_t v53 = *(void *)(a1 + 64);
        id v54 = objc_alloc((Class)NSError);
        int v55 = +[NSString stringWithUTF8String:"nfcd"];
        id v56 = [v18 code];
        v81[0] = NSLocalizedDescriptionKey;
        if ((uint64_t)[v18 code] > 70) {
          uint64_t v57 = 71;
        }
        else {
          uint64_t v57 = (uint64_t)[v18 code];
        }
        __int16 v74 = +[NSString stringWithUTF8String:off_100305838[v57]];
        v82[0] = v74;
        v82[1] = v18;
        v81[1] = NSUnderlyingErrorKey;
        v81[2] = @"Line";
        v82[2] = &off_10031C870;
        v81[3] = @"Method";
        id v75 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 72))];
        v82[3] = v75;
        void v81[4] = NSDebugDescriptionErrorKey;
        id v76 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 72)), 1554];
        void v82[4] = v76;
        NSErrorUserInfoKey v77 = +[NSDictionary dictionaryWithObjects:v82 forKeys:v81 count:5];
        id v78 = [v54 initWithDomain:v55 code:v56 userInfo:v77];
        (*(void (**)(uint64_t, id))(v53 + 16))(v53, v78);
      }
      else
      {
        (*(void (**)(void))(*(void *)(a1 + 64) + 16))();
      }
      goto LABEL_16;
    }
    if (v24)
    {
      uint64_t v58 = object_getClass(*(id *)(a1 + 32));
      BOOL v59 = class_isMetaClass(v58);
      BOOL v60 = object_getClassName(*(id *)(a1 + 32));
      NSErrorUserInfoKey v80 = sel_getName(*(SEL *)(a1 + 72));
      uint64_t v61 = 45;
      if (v59) {
        uint64_t v61 = 43;
      }
      v25(3, "%c[%{public}s %{public}s]:%i EMM is nil!", v61, v60, v80, 1540);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v62 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
    {
      __int16 v63 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v63)) {
        int v64 = 43;
      }
      else {
        int v64 = 45;
      }
      id v65 = object_getClassName(*(id *)(a1 + 32));
      int v66 = sel_getName(*(SEL *)(a1 + 72));
      *(_DWORD *)long long buf = 67109890;
      int v84 = v64;
      __int16 v85 = 2082;
      int v86 = v65;
      __int16 v87 = 2082;
      uint64_t v88 = v66;
      __int16 v89 = 1024;
      int v90 = 1540;
      _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i EMM is nil!", buf, 0x22u);
    }

    if (*(void *)(a1 + 64))
    {
      BOOL v67 = NFSharedSignpostLog();
      if (os_signpost_enabled(v67))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v67, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:disableAuthorizationForApplets", "failure", buf, 2u);
      }

      uint64_t v68 = *(void *)(a1 + 64);
      id v69 = objc_alloc((Class)NSError);
      id v18 = +[NSString stringWithUTF8String:"nfcd"];
      v95[0] = NSLocalizedDescriptionKey;
      BOOL v19 = +[NSString stringWithUTF8String:"Invalid State"];
      v96[0] = v19;
      v96[1] = &off_10031C858;
      v95[1] = @"Line";
      v95[2] = @"Method";
      id v70 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 72))];
      v96[2] = v70;
      v95[3] = NSDebugDescriptionErrorKey;
      id v71 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 72)), 1543];
      v96[3] = v71;
      __int16 v72 = +[NSDictionary dictionaryWithObjects:v96 forKeys:v95 count:4];
      id v73 = [v69 initWithDomain:v18 code:12 userInfo:v72];
      (*(void (**)(uint64_t, id))(v68 + 16))(v68, v73);

      goto LABEL_15;
    }
  }
}

void sub_100176140(uint64_t a1)
{
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 64));
      uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 1569, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      id v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      id v13 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v14 = sel_getName(*(SEL *)(a1 + 64));
      id v15 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)long long buf = 67110146;
      int v84 = v12;
      __int16 v85 = 2082;
      int v86 = v13;
      __int16 v87 = 2082;
      uint64_t v88 = v14;
      __int16 v89 = 1024;
      int v90 = 1569;
      __int16 v91 = 2114;
      uint64_t v92 = v15;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v16 = *(void *)(a1 + 56);
    if (v16)
    {
      id v17 = objc_alloc((Class)NSError);
      id v18 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v97 = NSLocalizedDescriptionKey;
      BOOL v19 = +[NSString stringWithUTF8String:"Session not active"];
      id v98 = v19;
      CFStringRef v20 = +[NSDictionary dictionaryWithObjects:&v98 forKeys:&v97 count:1];
      id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
      (*(void (**)(uint64_t, id))(v16 + 16))(v16, v21);

LABEL_15:
LABEL_16:
    }
  }
  else
  {
    uint64_t v22 = NFSharedSignpostLog();
    if (os_signpost_enabled(v22))
    {
      *(_WORD *)long long buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v22, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEMSession:disableAuthorizationForPasses", "processing", buf, 2u);
    }

    uint64_t v23 = [*(id *)(a1 + 32) expressModeManager];

    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v24 = NFLogGetLogger();
    id v25 = (void (*)(uint64_t, const char *, ...))v24;
    if (v23)
    {
      if (v24)
      {
        int v26 = object_getClass(*(id *)(a1 + 32));
        BOOL v27 = class_isMetaClass(v26);
        uint64_t v28 = object_getClassName(*(id *)(a1 + 32));
        int v29 = sel_getName(*(SEL *)(a1 + 64));
        uint64_t v30 = *(void *)(a1 + 40);
        id v31 = [*(id *)(a1 + 32) clientName];
        uint64_t v32 = 45;
        if (v27) {
          uint64_t v32 = 43;
        }
        v25(6, "%c[%{public}s %{public}s]:%i passes=%{public}@  client=%{public}@", v32, v28, v29, 1582, v30, v31);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v33 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v34 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v34)) {
          int v35 = 43;
        }
        else {
          int v35 = 45;
        }
        int v36 = object_getClassName(*(id *)(a1 + 32));
        int v37 = sel_getName(*(SEL *)(a1 + 64));
        unsigned int v38 = *(void **)(a1 + 40);
        uint64_t v39 = [*(id *)(a1 + 32) clientName];
        *(_DWORD *)long long buf = 67110402;
        int v84 = v35;
        __int16 v85 = 2082;
        int v86 = v36;
        __int16 v87 = 2082;
        uint64_t v88 = v37;
        __int16 v89 = 1024;
        int v90 = 1582;
        __int16 v91 = 2114;
        uint64_t v92 = v38;
        __int16 v93 = 2114;
        BOOL v94 = v39;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i passes=%{public}@  client=%{public}@", buf, 0x36u);
      }
      uint64_t v40 = [*(id *)(a1 + 32) expressModeManager];
      id v18 = sub_100049D4C(v40, *(void **)(a1 + 40), *(void **)(a1 + 48));

      uint64_t v41 = NFSharedSignpostLog();
      if (os_signpost_enabled(v41))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v41, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:disableAuthorizationForPasses", "user callback", buf, 2u);
      }

      if (v18)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v42 = NFLogGetLogger();
        if (v42)
        {
          uint64_t v43 = (void (*)(uint64_t, const char *, ...))v42;
          uint64_t v44 = object_getClass(*(id *)(a1 + 32));
          BOOL v45 = class_isMetaClass(v44);
          BOOL v46 = object_getClassName(*(id *)(a1 + 32));
          uint64_t v79 = sel_getName(*(SEL *)(a1 + 64));
          uint64_t v47 = 45;
          if (v45) {
            uint64_t v47 = 43;
          }
          v43(3, "%c[%{public}s %{public}s]:%i Failed to disable auth on passes", v47, v46, v79, 1587);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v48 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
        {
          int v49 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v49)) {
            int v50 = 43;
          }
          else {
            int v50 = 45;
          }
          int v51 = object_getClassName(*(id *)(a1 + 32));
          id v52 = sel_getName(*(SEL *)(a1 + 64));
          *(_DWORD *)long long buf = 67109890;
          int v84 = v50;
          __int16 v85 = 2082;
          int v86 = v51;
          __int16 v87 = 2082;
          uint64_t v88 = v52;
          __int16 v89 = 1024;
          int v90 = 1587;
          _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to disable auth on passes", buf, 0x22u);
        }

        uint64_t v53 = *(void *)(a1 + 56);
        id v54 = objc_alloc((Class)NSError);
        int v55 = +[NSString stringWithUTF8String:"nfcd"];
        id v56 = [v18 code];
        v81[0] = NSLocalizedDescriptionKey;
        if ((uint64_t)[v18 code] > 70) {
          uint64_t v57 = 71;
        }
        else {
          uint64_t v57 = (uint64_t)[v18 code];
        }
        __int16 v74 = +[NSString stringWithUTF8String:off_100305838[v57]];
        v82[0] = v74;
        v82[1] = v18;
        v81[1] = NSUnderlyingErrorKey;
        v81[2] = @"Line";
        v82[2] = &off_10031C8A0;
        v81[3] = @"Method";
        id v75 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 64))];
        v82[3] = v75;
        void v81[4] = NSDebugDescriptionErrorKey;
        id v76 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 64)), 1588];
        void v82[4] = v76;
        NSErrorUserInfoKey v77 = +[NSDictionary dictionaryWithObjects:v82 forKeys:v81 count:5];
        id v78 = [v54 initWithDomain:v55 code:v56 userInfo:v77];
        (*(void (**)(uint64_t, id))(v53 + 16))(v53, v78);
      }
      else
      {
        (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
      }
      goto LABEL_16;
    }
    if (v24)
    {
      uint64_t v58 = object_getClass(*(id *)(a1 + 32));
      BOOL v59 = class_isMetaClass(v58);
      BOOL v60 = object_getClassName(*(id *)(a1 + 32));
      NSErrorUserInfoKey v80 = sel_getName(*(SEL *)(a1 + 64));
      uint64_t v61 = 45;
      if (v59) {
        uint64_t v61 = 43;
      }
      v25(3, "%c[%{public}s %{public}s]:%i EMM is nil!", v61, v60, v80, 1574);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v62 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
    {
      __int16 v63 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v63)) {
        int v64 = 43;
      }
      else {
        int v64 = 45;
      }
      id v65 = object_getClassName(*(id *)(a1 + 32));
      int v66 = sel_getName(*(SEL *)(a1 + 64));
      *(_DWORD *)long long buf = 67109890;
      int v84 = v64;
      __int16 v85 = 2082;
      int v86 = v65;
      __int16 v87 = 2082;
      uint64_t v88 = v66;
      __int16 v89 = 1024;
      int v90 = 1574;
      _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i EMM is nil!", buf, 0x22u);
    }

    if (*(void *)(a1 + 56))
    {
      BOOL v67 = NFSharedSignpostLog();
      if (os_signpost_enabled(v67))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v67, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:disableAuthorizationForPasses", "failure", buf, 2u);
      }

      uint64_t v68 = *(void *)(a1 + 56);
      id v69 = objc_alloc((Class)NSError);
      id v18 = +[NSString stringWithUTF8String:"nfcd"];
      v95[0] = NSLocalizedDescriptionKey;
      BOOL v19 = +[NSString stringWithUTF8String:"Invalid State"];
      v96[0] = v19;
      v96[1] = &off_10031C888;
      v95[1] = @"Line";
      v95[2] = @"Method";
      id v70 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 64))];
      v96[2] = v70;
      v95[3] = NSDebugDescriptionErrorKey;
      id v71 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 64)), 1577];
      v96[3] = v71;
      __int16 v72 = +[NSDictionary dictionaryWithObjects:v96 forKeys:v95 count:4];
      id v73 = [v69 initWithDomain:v18 code:12 userInfo:v72];
      (*(void (**)(uint64_t, id))(v68 + 16))(v68, v73);

      goto LABEL_15;
    }
  }
}

void sub_100176CEC(uint64_t a1)
{
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    uint64_t v22 = NFSharedSignpostLog();
    if (os_signpost_enabled(v22))
    {
      uint64_t v23 = [*(id *)(a1 + 32) expressModeManager];
      uint64_t v24 = (void *)v23;
      if (v23) {
        int v25 = *(unsigned __int8 *)(v23 + 172);
      }
      else {
        int v25 = 0;
      }
      *(_DWORD *)long long buf = 67109120;
      int v79 = v25;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v22, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEMSession:getFelicaAppletState", "InSessionExpress=%d", buf, 8u);
    }
    int v26 = *(void **)(a1 + 32);
    BOOL v27 = [*(id *)(a1 + 40) identifier];
    id v18 = [v26 _getSecureElementForAID:v27];

    if ([*(id *)(a1 + 32) _activateSecureElementWrapper:v18])
    {
      uint64_t v28 = [*(id *)(a1 + 40) identifier];
      BOOL v19 = sub_1002473C8(v18, v28);

      if (!sub_100253528(v18, v19))
      {
        id v71 = 0;
        CFStringRef v20 = sub_10024F870(v18, v19, &v71);
        id v47 = v71;
        uint64_t v48 = NFSharedSignpostLog();
        if (os_signpost_enabled(v48))
        {
          *(_WORD *)long long buf = 0;
          _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v48, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:getFelicaAppletState", "user callback", buf, 2u);
        }

        (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          int v50 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(*(id *)(a1 + 32));
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(*(id *)(a1 + 32));
          Name = sel_getName(*(SEL *)(a1 + 56));
          uint64_t v54 = 45;
          if (isMetaClass) {
            uint64_t v54 = 43;
          }
          v50(6, "%c[%{public}s %{public}s]:%i Delaying express mode", v54, ClassName, Name, 1641);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v55 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
        {
          id v56 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v56)) {
            int v57 = 43;
          }
          else {
            int v57 = 45;
          }
          uint64_t v58 = object_getClassName(*(id *)(a1 + 32));
          BOOL v59 = sel_getName(*(SEL *)(a1 + 56));
          *(_DWORD *)long long buf = 67109890;
          int v79 = v57;
          __int16 v80 = 2082;
          NSErrorUserInfoKey v81 = v58;
          __int16 v82 = 2082;
          uint64_t v83 = v59;
          __int16 v84 = 1024;
          int v85 = 1641;
          _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Delaying express mode", buf, 0x22u);
        }

        id v70 = v47;
        BOOL v60 = sub_10024FF34(v18, v19, &v70);
        id v61 = v70;

        if (!v61)
        {
          uint64_t v62 = [v60 objectForKeyedSubscript:@"DelayExpressReentry"];

          if (v62)
          {
            __int16 v63 = [v60 objectForKeyedSubscript:@"DelayExpressReentry"];
            [v63 doubleValue];
            *(double *)(*(void *)(a1 + 32) + 168) = v64 / 1000.0;
          }
        }

        goto LABEL_15;
      }
      CFStringRef v20 = sub_10006FAC4(v18, v19);
      int v29 = NFSharedSignpostLog();
      if (os_signpost_enabled(v29))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v29, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:getFelicaAppletState", "user callback", buf, 2u);
      }

      uint64_t v30 = *(void *)(a1 + 48);
      if (v20)
      {
        (*(void (**)(uint64_t, void *, void))(v30 + 16))(v30, v20, 0);
        goto LABEL_15;
      }
      id v65 = objc_alloc((Class)NSError);
      CFStringRef v20 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v72 = NSLocalizedDescriptionKey;
      BOOL v45 = +[NSString stringWithUTF8String:"Unexpected Result"];
      id v73 = v45;
      int v66 = +[NSDictionary dictionaryWithObjects:&v73 forKeys:&v72 count:1];
      id v67 = [v65 initWithDomain:v20 code:13 userInfo:v66];
      (*(void (**)(uint64_t, void, id))(v30 + 16))(v30, 0, v67);
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v31 = NFLogGetLogger();
      if (v31)
      {
        uint64_t v32 = (void (*)(uint64_t, const char *, ...))v31;
        uint64_t v33 = object_getClass(*(id *)(a1 + 32));
        BOOL v34 = class_isMetaClass(v33);
        int v35 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v68 = sel_getName(*(SEL *)(a1 + 56));
        uint64_t v36 = 45;
        if (v34) {
          uint64_t v36 = 43;
        }
        v32(3, "%c[%{public}s %{public}s]:%i Failed to set mode to wired", v36, v35, v68, 1613);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v37 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
      {
        unsigned int v38 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v38)) {
          int v39 = 43;
        }
        else {
          int v39 = 45;
        }
        uint64_t v40 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v41 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)long long buf = 67109890;
        int v79 = v39;
        __int16 v80 = 2082;
        NSErrorUserInfoKey v81 = v40;
        __int16 v82 = 2082;
        uint64_t v83 = v41;
        __int16 v84 = 1024;
        int v85 = 1613;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set mode to wired", buf, 0x22u);
      }

      uint64_t v42 = NFSharedSignpostLog();
      if (os_signpost_enabled(v42))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v42, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:getFelicaAppletState", "failure", buf, 2u);
      }

      uint64_t v43 = *(void *)(a1 + 48);
      id v44 = objc_alloc((Class)NSError);
      BOOL v19 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v74 = NSLocalizedDescriptionKey;
      CFStringRef v20 = +[NSString stringWithUTF8String:"Unexpected Result"];
      id v75 = v20;
      BOOL v45 = +[NSDictionary dictionaryWithObjects:&v75 forKeys:&v74 count:1];
      id v46 = [v44 initWithDomain:v19 code:13 userInfo:v45];
      (*(void (**)(uint64_t, void, id))(v43 + 16))(v43, 0, v46);
    }
    goto LABEL_15;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v2 = NFLogGetLogger();
  if (v2)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))v2;
    uint64_t v4 = object_getClass(*(id *)(a1 + 32));
    BOOL v5 = class_isMetaClass(v4);
    uint64_t v6 = object_getClassName(*(id *)(a1 + 32));
    id v7 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v9 = 45;
    if (v5) {
      uint64_t v9 = 43;
    }
    v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, v6, v7, 1604, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    id v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    id v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 56));
    id v15 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v79 = v12;
    __int16 v80 = 2082;
    NSErrorUserInfoKey v81 = v13;
    __int16 v82 = 2082;
    uint64_t v83 = v14;
    __int16 v84 = 1024;
    int v85 = 1604;
    __int16 v86 = 2114;
    __int16 v87 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v16 = *(void *)(a1 + 48);
  if (v16)
  {
    id v17 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v76 = NSLocalizedDescriptionKey;
    BOOL v19 = +[NSString stringWithUTF8String:"Session not active"];
    NSErrorUserInfoKey v77 = v19;
    CFStringRef v20 = +[NSDictionary dictionaryWithObjects:&v77 forKeys:&v76 count:1];
    id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
    (*(void (**)(uint64_t, void, id))(v16 + 16))(v16, 0, v21);

LABEL_15:
  }
}

void sub_100177780(uint64_t a1)
{
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    uint64_t v22 = NFSharedSignpostLog();
    if (os_signpost_enabled(v22))
    {
      uint64_t v23 = [*(id *)(a1 + 32) expressModeManager];
      uint64_t v24 = (void *)v23;
      if (v23) {
        int v25 = *(unsigned __int8 *)(v23 + 172);
      }
      else {
        int v25 = 0;
      }
      *(_DWORD *)long long buf = 67109120;
      int v69 = v25;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v22, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEMSession:getTransitAppletState", "InSessionExpress=%d", buf, 8u);
    }
    int v26 = *(void **)(a1 + 32);
    BOOL v27 = [*(id *)(a1 + 40) identifier];
    id v18 = [v26 _getSecureElementForAID:v27];

    if ([*(id *)(a1 + 32) _activateSecureElementWrapper:v18])
    {
      uint64_t v28 = [*(id *)(a1 + 40) identifier];
      CFStringRef v20 = sub_1002473C8(v18, v28);

      id v63 = 0;
      sub_10024F870(v18, v20, &v63);
      id v21 = (id)objc_claimAutoreleasedReturnValue();
      id v29 = v63;
      uint64_t v30 = NFSharedSignpostLog();
      if (os_signpost_enabled(v30))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v30, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:getTransitAppletState", "user callback", buf, 2u);
      }

      (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        uint64_t v32 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(*(id *)(a1 + 32));
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(*(id *)(a1 + 32));
        Name = sel_getName(*(SEL *)(a1 + 56));
        uint64_t v36 = 45;
        if (isMetaClass) {
          uint64_t v36 = 43;
        }
        v32(6, "%c[%{public}s %{public}s]:%i Delaying express mode", v36, ClassName, Name, 1683);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v37 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
      {
        unsigned int v38 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v38)) {
          int v39 = 43;
        }
        else {
          int v39 = 45;
        }
        uint64_t v40 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v41 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)long long buf = 67109890;
        int v69 = v39;
        __int16 v70 = 2082;
        id v71 = v40;
        __int16 v72 = 2082;
        id v73 = v41;
        __int16 v74 = 1024;
        int v75 = 1683;
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Delaying express mode", buf, 0x22u);
      }

      id v62 = v29;
      sub_10024FF34(v18, v20, &v62);
      id v42 = (id)objc_claimAutoreleasedReturnValue();
      id v19 = v62;

      if (!v19)
      {
        uint64_t v43 = [v42 objectForKeyedSubscript:@"DelayExpressReentry"];

        if (v43)
        {
          id v44 = [v42 objectForKeyedSubscript:@"DelayExpressReentry"];
          [v44 doubleValue];
          *(double *)(*(void *)(a1 + 32) + 168) = v45 / 1000.0;
        }
        id v19 = 0;
      }
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v46 = NFLogGetLogger();
      if (v46)
      {
        id v47 = (void (*)(uint64_t, const char *, ...))v46;
        uint64_t v48 = object_getClass(*(id *)(a1 + 32));
        BOOL v49 = class_isMetaClass(v48);
        int v50 = object_getClassName(*(id *)(a1 + 32));
        id v61 = sel_getName(*(SEL *)(a1 + 56));
        uint64_t v51 = 45;
        if (v49) {
          uint64_t v51 = 43;
        }
        v47(3, "%c[%{public}s %{public}s]:%i Failed to set mode to wired", v51, v50, v61, 1669);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v52 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
      {
        uint64_t v53 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v53)) {
          int v54 = 43;
        }
        else {
          int v54 = 45;
        }
        int v55 = object_getClassName(*(id *)(a1 + 32));
        id v56 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)long long buf = 67109890;
        int v69 = v54;
        __int16 v70 = 2082;
        id v71 = v55;
        __int16 v72 = 2082;
        id v73 = v56;
        __int16 v74 = 1024;
        int v75 = 1669;
        _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set mode to wired", buf, 0x22u);
      }

      int v57 = NFSharedSignpostLog();
      if (os_signpost_enabled(v57))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v57, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:getTransitAppletState", "failure", buf, 2u);
      }

      uint64_t v58 = *(void *)(a1 + 48);
      id v59 = objc_alloc((Class)NSError);
      id v19 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v64 = NSLocalizedDescriptionKey;
      CFStringRef v20 = +[NSString stringWithUTF8String:"Unexpected Result"];
      id v65 = v20;
      id v21 = +[NSDictionary dictionaryWithObjects:&v65 forKeys:&v64 count:1];
      id v42 = [v59 initWithDomain:v19 code:13 userInfo:v21];
      (*(void (**)(uint64_t, void, id))(v58 + 16))(v58, 0, v42);
    }

    goto LABEL_15;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v2 = NFLogGetLogger();
  if (v2)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))v2;
    uint64_t v4 = object_getClass(*(id *)(a1 + 32));
    BOOL v5 = class_isMetaClass(v4);
    uint64_t v6 = object_getClassName(*(id *)(a1 + 32));
    id v7 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v9 = 45;
    if (v5) {
      uint64_t v9 = 43;
    }
    v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, v6, v7, 1660, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    id v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    id v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 56));
    id v15 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v69 = v12;
    __int16 v70 = 2082;
    id v71 = v13;
    __int16 v72 = 2082;
    id v73 = v14;
    __int16 v74 = 1024;
    int v75 = 1660;
    __int16 v76 = 2114;
    NSErrorUserInfoKey v77 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v16 = *(void *)(a1 + 48);
  if (v16)
  {
    id v17 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v66 = NSLocalizedDescriptionKey;
    id v19 = +[NSString stringWithUTF8String:"Session not active"];
    id v67 = v19;
    CFStringRef v20 = +[NSDictionary dictionaryWithObjects:&v67 forKeys:&v66 count:1];
    id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
    (*(void (**)(uint64_t, void, id))(v16 + 16))(v16, 0, v21);
LABEL_15:
  }
}

void sub_10017810C(uint64_t a1)
{
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    uint64_t v22 = NFSharedSignpostLog();
    if (os_signpost_enabled(v22))
    {
      *(_WORD *)long long buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v22, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SEMSession:getServiceProviderDataForApplet", "processing", buf, 2u);
    }

    uint64_t v23 = *(void **)(a1 + 32);
    uint64_t v24 = [*(id *)(a1 + 40) identifier];
    id v18 = [v23 _getSecureElementForAID:v24];

    if ([*(id *)(a1 + 32) _activateSecureElementWrapper:v18])
    {
      int v25 = [*(id *)(a1 + 40) identifier];
      CFStringRef v20 = sub_1002473C8(v18, v25);

      int v26 = *(void **)(a1 + 48);
      if (v26 && (BOOL v27 = *(void **)(a1 + 56)) != 0)
      {
        uint64_t v48 = 0;
        uint64_t v28 = (id *)&v48;
        uint64_t v29 = sub_100250A30(v18, v20, v26, v27, &v48);
      }
      else
      {
        uint64_t v47 = 0;
        uint64_t v28 = (id *)&v47;
        uint64_t v29 = sub_1002503F8(v18, v20, &v47);
      }
      id v21 = (id)v29;
      id v19 = *v28;
      double v45 = NFSharedSignpostLog();
      if (os_signpost_enabled(v45))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v45, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:getServiceProviderDataForApplet", "user callback", buf, 2u);
      }

      (*(void (**)(void, id, id))(*(void *)(a1 + 64) + 16))(*(void *)(a1 + 64), v21, v19);
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        uint64_t v31 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(*(id *)(a1 + 32));
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(*(id *)(a1 + 32));
        Name = sel_getName(*(SEL *)(a1 + 72));
        uint64_t v35 = 45;
        if (isMetaClass) {
          uint64_t v35 = 43;
        }
        v31(3, "%c[%{public}s %{public}s]:%i Failed to set mode to wired", v35, ClassName, Name, 1715);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v36 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        int v37 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v37)) {
          int v38 = 43;
        }
        else {
          int v38 = 45;
        }
        int v39 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v40 = sel_getName(*(SEL *)(a1 + 72));
        *(_DWORD *)long long buf = 67109890;
        int v54 = v38;
        __int16 v55 = 2082;
        id v56 = v39;
        __int16 v57 = 2082;
        uint64_t v58 = v40;
        __int16 v59 = 1024;
        int v60 = 1715;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set mode to wired", buf, 0x22u);
      }

      uint64_t v41 = NFSharedSignpostLog();
      if (os_signpost_enabled(v41))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v41, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "SEMSession:getServiceProviderDataForApplet", "failure", buf, 2u);
      }

      uint64_t v42 = *(void *)(a1 + 64);
      id v43 = objc_alloc((Class)NSError);
      id v19 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v49 = NSLocalizedDescriptionKey;
      CFStringRef v20 = +[NSString stringWithUTF8String:"Unexpected Result"];
      int v50 = v20;
      id v21 = +[NSDictionary dictionaryWithObjects:&v50 forKeys:&v49 count:1];
      id v44 = [v43 initWithDomain:v19 code:13 userInfo:v21];
      (*(void (**)(uint64_t, void, id))(v42 + 16))(v42, 0, v44);
    }
    goto LABEL_15;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v2 = NFLogGetLogger();
  if (v2)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))v2;
    uint64_t v4 = object_getClass(*(id *)(a1 + 32));
    BOOL v5 = class_isMetaClass(v4);
    uint64_t v6 = object_getClassName(*(id *)(a1 + 32));
    id v7 = sel_getName(*(SEL *)(a1 + 72));
    uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v9 = 45;
    if (v5) {
      uint64_t v9 = 43;
    }
    v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, v6, v7, 1706, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    id v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    id v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 72));
    id v15 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v54 = v12;
    __int16 v55 = 2082;
    id v56 = v13;
    __int16 v57 = 2082;
    uint64_t v58 = v14;
    __int16 v59 = 1024;
    int v60 = 1706;
    __int16 v61 = 2114;
    id v62 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v16 = *(void *)(a1 + 64);
  if (v16)
  {
    id v17 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v51 = NSLocalizedDescriptionKey;
    id v19 = +[NSString stringWithUTF8String:"Session not active"];
    id v52 = v19;
    CFStringRef v20 = +[NSDictionary dictionaryWithObjects:&v52 forKeys:&v51 count:1];
    id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
    (*(void (**)(uint64_t, void, id))(v16 + 16))(v16, 0, v21);
LABEL_15:
  }
}

void sub_100178820(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 1754, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    id v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    id v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
    id v15 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)long long buf = 67110146;
    int v73 = v12;
    __int16 v74 = 2082;
    int v75 = v13;
    __int16 v76 = 2082;
    NSErrorUserInfoKey v77 = v14;
    __int16 v78 = 1024;
    int v79 = 1754;
    __int16 v80 = 2114;
    uint64_t v81 = (uint64_t)v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  uint64_t v67 = -1;
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    int v39 = *(void **)(a1 + 32);
    uint64_t v40 = [v39 embeddedSecureElementWrapper];
    LOBYTE(v39) = [v39 _activateSecureElementWrapper:v40];

    if (v39)
    {
      uint64_t v41 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      uint64_t v32 = sub_1000B0908(v41, &v67);

      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v42 = NFLogGetLogger();
      if (v42)
      {
        id v43 = (void (*)(uint64_t, const char *, ...))v42;
        id v44 = object_getClass(*(id *)(a1 + 32));
        BOOL v45 = class_isMetaClass(v44);
        uint64_t v46 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v47 = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v48 = 45;
        if (v45) {
          uint64_t v48 = 43;
        }
        v43(6, "%c[%{public}s %{public}s]:%i Counter = %lu, ", v48, v46, v47, 1767, v67);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      NSErrorUserInfoKey v49 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
      {
        int v50 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v50)) {
          int v51 = 43;
        }
        else {
          int v51 = 45;
        }
        id v52 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v53 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)long long buf = 67110146;
        int v73 = v51;
        __int16 v74 = 2082;
        int v75 = v52;
        __int16 v76 = 2082;
        NSErrorUserInfoKey v77 = v53;
        __int16 v78 = 1024;
        int v79 = 1767;
        __int16 v80 = 2048;
        uint64_t v81 = v67;
        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Counter = %lu, ", buf, 0x2Cu);
      }

      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
      goto LABEL_25;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v54 = NFLogGetLogger();
    if (v54)
    {
      __int16 v55 = (void (*)(uint64_t, const char *, ...))v54;
      id v56 = object_getClass(*(id *)(a1 + 32));
      BOOL v57 = class_isMetaClass(v56);
      uint64_t v58 = object_getClassName(*(id *)(a1 + 32));
      NSErrorUserInfoKey v66 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v59 = 45;
      if (v57) {
        uint64_t v59 = 43;
      }
      v55(3, "%c[%{public}s %{public}s]:%i Failed to set mode to wired", v59, v58, v66, 1761);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v60 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
    {
      __int16 v61 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v61)) {
        int v62 = 43;
      }
      else {
        int v62 = 45;
      }
      id v63 = object_getClassName(*(id *)(a1 + 32));
      NSErrorUserInfoKey v64 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)long long buf = 67109890;
      int v73 = v62;
      __int16 v74 = 2082;
      int v75 = v63;
      __int16 v76 = 2082;
      NSErrorUserInfoKey v77 = v64;
      __int16 v78 = 1024;
      int v79 = 1761;
      _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to set mode to wired", buf, 0x22u);
    }

    uint64_t v30 = *(void *)(a1 + 40);
    id v65 = objc_alloc((Class)NSError);
    uint64_t v32 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v68 = NSLocalizedDescriptionKey;
    uint64_t v33 = +[NSString stringWithUTF8String:"Unexpected Result"];
    int v69 = v33;
    BOOL v34 = +[NSDictionary dictionaryWithObjects:&v69 forKeys:&v68 count:1];
    uint64_t v35 = v65;
    uint64_t v36 = v32;
    uint64_t v37 = 13;
LABEL_24:
    id v38 = [v35 initWithDomain:v36 code:v37 userInfo:v34];
    (*(void (**)(uint64_t, uint64_t, id))(v30 + 16))(v30, -1, v38);

LABEL_25:
    return;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v16 = NFLogGetLogger();
  if (v16)
  {
    id v17 = (void (*)(uint64_t, const char *, ...))v16;
    id v18 = object_getClass(*(id *)(a1 + 32));
    BOOL v19 = class_isMetaClass(v18);
    CFStringRef v20 = object_getClassName(*(id *)(a1 + 32));
    id v21 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v22 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v23 = 45;
    if (v19) {
      uint64_t v23 = 43;
    }
    v17(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v23, v20, v21, 1758, v22);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v24 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    int v25 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v25)) {
      int v26 = 43;
    }
    else {
      int v26 = 45;
    }
    BOOL v27 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v28 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v29 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v73 = v26;
    __int16 v74 = 2082;
    int v75 = v27;
    __int16 v76 = 2082;
    NSErrorUserInfoKey v77 = v28;
    __int16 v78 = 1024;
    int v79 = 1758;
    __int16 v80 = 2114;
    uint64_t v81 = (uint64_t)v29;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v30 = *(void *)(a1 + 40);
  if (v30)
  {
    id v31 = objc_alloc((Class)NSError);
    uint64_t v32 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v70 = NSLocalizedDescriptionKey;
    uint64_t v33 = +[NSString stringWithUTF8String:"Session not active"];
    id v71 = v33;
    BOOL v34 = +[NSDictionary dictionaryWithObjects:&v71 forKeys:&v70 count:1];
    uint64_t v35 = v31;
    uint64_t v36 = v32;
    uint64_t v37 = 54;
    goto LABEL_24;
  }
}

void sub_100179020(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 1777, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    id v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    id v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
    id v15 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)long long buf = 67110146;
    int v58 = v12;
    __int16 v59 = 2082;
    int v60 = v13;
    __int16 v61 = 2082;
    int v62 = v14;
    __int16 v63 = 1024;
    int v64 = 1777;
    __int16 v65 = 2114;
    NSErrorUserInfoKey v66 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v16 = NFLogGetLogger();
  if (v16)
  {
    id v17 = (void (*)(uint64_t, const char *, ...))v16;
    id v18 = object_getClass(*(id *)(a1 + 32));
    BOOL v19 = class_isMetaClass(v18);
    CFStringRef v20 = object_getClassName(*(id *)(a1 + 32));
    id v21 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v22 = [*(id *)(a1 + 32) expressModeManager];
    uint64_t v23 = sub_10004B700((uint64_t)v22);
    uint64_t v24 = 45;
    if (v19) {
      uint64_t v24 = 43;
    }
    v17(6, "%c[%{public}s %{public}s]:%i express applets: %{public}@", v24, v20, v21, 1778, v23);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v25 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
  {
    int v26 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v26)) {
      int v27 = 43;
    }
    else {
      int v27 = 45;
    }
    uint64_t v28 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v29 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v30 = [*(id *)(a1 + 32) expressModeManager];
    id v31 = sub_10004B700((uint64_t)v30);
    *(_DWORD *)long long buf = 67110146;
    int v58 = v27;
    __int16 v59 = 2082;
    int v60 = v28;
    __int16 v61 = 2082;
    int v62 = v29;
    __int16 v63 = 1024;
    int v64 = 1778;
    __int16 v65 = 2114;
    NSErrorUserInfoKey v66 = v31;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i express applets: %{public}@", buf, 0x2Cu);
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    uint64_t v52 = *(void *)(a1 + 40);
    uint64_t v53 = [*(id *)(a1 + 32) expressModeManager];
    uint64_t v48 = (void *)v53;
    if (v53) {
      uint64_t v54 = *(void *)(v53 + 136);
    }
    else {
      uint64_t v54 = 0;
    }
    NSErrorUserInfoKey v49 = [*(id *)(a1 + 32) expressModeManager];
    int v50 = sub_10004B700((uint64_t)v49);
    (*(void (**)(uint64_t, uint64_t, void *, void))(v52 + 16))(v52, v54, v50, 0);
    goto LABEL_33;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v32 = NFLogGetLogger();
  if (v32)
  {
    uint64_t v33 = (void (*)(uint64_t, const char *, ...))v32;
    BOOL v34 = object_getClass(*(id *)(a1 + 32));
    BOOL v35 = class_isMetaClass(v34);
    uint64_t v36 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v37 = sel_getName(*(SEL *)(a1 + 48));
    id v38 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v39 = 45;
    if (v35) {
      uint64_t v39 = 43;
    }
    v33(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v39, v36, v37, 1779, v38);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v40 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
  {
    uint64_t v41 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v41)) {
      int v42 = 43;
    }
    else {
      int v42 = 45;
    }
    id v43 = object_getClassName(*(id *)(a1 + 32));
    id v44 = sel_getName(*(SEL *)(a1 + 48));
    BOOL v45 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v58 = v42;
    __int16 v59 = 2082;
    int v60 = v43;
    __int16 v61 = 2082;
    int v62 = v44;
    __int16 v63 = 1024;
    int v64 = 1779;
    __int16 v65 = 2114;
    NSErrorUserInfoKey v66 = v45;
    _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v46 = *(void *)(a1 + 40);
  if (v46)
  {
    id v47 = objc_alloc((Class)NSError);
    uint64_t v48 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v55 = NSLocalizedDescriptionKey;
    NSErrorUserInfoKey v49 = +[NSString stringWithUTF8String:"Session not active"];
    id v56 = v49;
    int v50 = +[NSDictionary dictionaryWithObjects:&v56 forKeys:&v55 count:1];
    id v51 = [v47 initWithDomain:v48 code:54 userInfo:v50];
    (*(void (**)(uint64_t, void, void, id))(v46 + 16))(v46, 0, 0, v51);

LABEL_33:
  }
}

void sub_1001796E0(uint64_t a1)
{
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    int v25 = [*(id *)(a1 + 40) alternateDSID];

    if (v25)
    {
      int v26 = NFSharedSignpostLog();
      if (os_signpost_enabled(v26))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v26, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SURF_ENROLLMENT", "in", buf, 2u);
      }

      int v27 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      uint64_t v28 = [*(id *)(a1 + 40) alternateDSID];
      id v54 = 0;
      CFStringRef v20 = sub_100099DA8(v27, v28, &v54);
      id v19 = v54;

      id v18 = 0;
      if (!v20)
      {
        uint64_t v29 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
        uint64_t v30 = sub_1000A27EC(v29);

        id v31 = objc_opt_new();
        uint64_t v32 = [v30 objectForKeyedSubscript:@"ECKA"];

        if (v32)
        {
          uint64_t v33 = [v30 objectForKeyedSubscript:@"ECKA"];
          [v31 setObject:v33 forKey:@"ECC"];
        }
        BOOL v34 = [v30 objectForKeyedSubscript:@"ECDSA"];

        if (v34)
        {
          BOOL v35 = [v30 objectForKeyedSubscript:@"ECDSA"];
          [v31 setObject:v35 forKey:@"ECDSA"];
        }
        uint64_t v36 = [v30 objectForKeyedSubscript:@"RSA"];

        if (v36)
        {
          uint64_t v37 = [v30 objectForKeyedSubscript:@"RSA"];
          [v31 setObject:v37 forKey:@"RSA"];
        }
        v55[0] = @"paymentCertificate";
        v55[1] = @"certificates";
        v56[0] = v19;
        v56[1] = v31;
        id v38 = +[NSDictionary dictionaryWithObjects:v56 forKeys:v55 count:2];
        id v18 = [[NFPeerPaymentEnrollmentResponse alloc] initWithDictionary:v38];
      }
      uint64_t v39 = NFSharedSignpostLog();
      if (os_signpost_enabled(v39))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v39, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SURF_ENROLLMENT", "user callback", buf, 2u);
      }

      (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
      uint64_t v40 = NFSharedSignpostLog();
      if (os_signpost_enabled(v40))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v40, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SURF_ENROLLMENT", "out", buf, 2u);
      }

      id v24 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      sub_1000997F0(v24);
      goto LABEL_16;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      int v42 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v46 = 45;
      if (isMetaClass) {
        uint64_t v46 = 43;
      }
      v42(3, "%c[%{public}s %{public}s]:%i Invalid authtoken parameter : nil", v46, ClassName, Name, 1793);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v47 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
    {
      uint64_t v48 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v48)) {
        int v49 = 43;
      }
      else {
        int v49 = 45;
      }
      int v50 = object_getClassName(*(id *)(a1 + 32));
      id v51 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)long long buf = 67109890;
      int v62 = v49;
      __int16 v63 = 2082;
      int v64 = v50;
      __int16 v65 = 2082;
      NSErrorUserInfoKey v66 = v51;
      __int16 v67 = 1024;
      int v68 = 1793;
      _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid authtoken parameter : nil", buf, 0x22u);
    }

    uint64_t v16 = *(void *)(a1 + 48);
    id v52 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v57 = NSLocalizedDescriptionKey;
    id v19 = +[NSString stringWithUTF8String:"Missing Parameter"];
    id v58 = v19;
    CFStringRef v20 = +[NSDictionary dictionaryWithObjects:&v58 forKeys:&v57 count:1];
    id v21 = v52;
    uint64_t v22 = v18;
    uint64_t v23 = 9;
LABEL_15:
    id v24 = [v21 initWithDomain:v22 code:v23 userInfo:v20];
    (*(void (**)(uint64_t, void, id))(v16 + 16))(v16, 0, v24);
LABEL_16:

    return;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v2 = NFLogGetLogger();
  if (v2)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))v2;
    uint64_t v4 = object_getClass(*(id *)(a1 + 32));
    BOOL v5 = class_isMetaClass(v4);
    uint64_t v6 = object_getClassName(*(id *)(a1 + 32));
    id v7 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v9 = 45;
    if (v5) {
      uint64_t v9 = 43;
    }
    v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, v6, v7, 1790, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    id v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    id v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 56));
    id v15 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v62 = v12;
    __int16 v63 = 2082;
    int v64 = v13;
    __int16 v65 = 2082;
    NSErrorUserInfoKey v66 = v14;
    __int16 v67 = 1024;
    int v68 = 1790;
    __int16 v69 = 2114;
    NSErrorUserInfoKey v70 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v16 = *(void *)(a1 + 48);
  if (v16)
  {
    id v17 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v59 = NSLocalizedDescriptionKey;
    id v19 = +[NSString stringWithUTF8String:"Session not active"];
    id v60 = v19;
    CFStringRef v20 = +[NSDictionary dictionaryWithObjects:&v60 forKeys:&v59 count:1];
    id v21 = v17;
    uint64_t v22 = v18;
    uint64_t v23 = 54;
    goto LABEL_15;
  }
}

void sub_100179F3C(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 1836, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    id v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    id v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 56));
    id v15 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)long long buf = 67110146;
    int v51 = v12;
    __int16 v52 = 2082;
    uint64_t v53 = v13;
    __int16 v54 = 2082;
    NSErrorUserInfoKey v55 = v14;
    __int16 v56 = 1024;
    int v57 = 1836;
    __int16 v58 = 2114;
    NSErrorUserInfoKey v59 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    uint64_t v36 = *(void **)(a1 + 40);
    uint64_t v37 = [*(id *)(*(void *)(a1 + 32) + 208) serialNumber];
    if ([v36 isEqualToString:v37])
    {
    }
    else
    {
      id v38 = *(void **)(a1 + 40);
      uint64_t v39 = [*(id *)(*(void *)(a1 + 32) + 208) systemOSSerialNumber];
      LODWORD(v38) = [v38 isEqualToString:v39];

      if (!v38)
      {
        id v41 = objc_alloc((Class)NSError);
        uint64_t v40 = +[NSString stringWithUTF8String:"nfcd"];
        v46[0] = NSLocalizedDescriptionKey;
        int v42 = +[NSString stringWithUTF8String:"SE not available"];
        v47[0] = v42;
        v47[1] = &off_10031C8B8;
        v46[1] = @"Line";
        v46[2] = @"Method";
        id v43 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
        v47[2] = v43;
        v46[3] = NSDebugDescriptionErrorKey;
        id v44 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 1842];
        v47[3] = v44;
        BOOL v45 = +[NSDictionary dictionaryWithObjects:v47 forKeys:v46 count:4];
        id v32 = [v41 initWithDomain:v40 code:35 userInfo:v45];

        goto LABEL_31;
      }
    }
    uint64_t v40 = +[_NFHardwareManager sharedHardwareManager];
    id v32 = [v40 powerCycleSE:*(void *)(*(void *)(a1 + 32) + 208)];
LABEL_31:

    (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    goto LABEL_24;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v16 = NFLogGetLogger();
  if (v16)
  {
    id v17 = (void (*)(uint64_t, const char *, ...))v16;
    id v18 = object_getClass(*(id *)(a1 + 32));
    BOOL v19 = class_isMetaClass(v18);
    CFStringRef v20 = object_getClassName(*(id *)(a1 + 32));
    id v21 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v22 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v23 = 45;
    if (v19) {
      uint64_t v23 = 43;
    }
    v17(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v23, v20, v21, 1837, v22);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v24 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    int v25 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v25)) {
      int v26 = 43;
    }
    else {
      int v26 = 45;
    }
    int v27 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v28 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v29 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v51 = v26;
    __int16 v52 = 2082;
    uint64_t v53 = v27;
    __int16 v54 = 2082;
    NSErrorUserInfoKey v55 = v28;
    __int16 v56 = 1024;
    int v57 = 1837;
    __int16 v58 = 2114;
    NSErrorUserInfoKey v59 = v29;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v30 = *(void *)(a1 + 48);
  if (v30)
  {
    id v31 = objc_alloc((Class)NSError);
    id v32 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v48 = NSLocalizedDescriptionKey;
    uint64_t v33 = +[NSString stringWithUTF8String:"Session not active"];
    int v49 = v33;
    BOOL v34 = +[NSDictionary dictionaryWithObjects:&v49 forKeys:&v48 count:1];
    id v35 = [v31 initWithDomain:v32 code:54 userInfo:v34];
    (*(void (**)(uint64_t, id))(v30 + 16))(v30, v35);

LABEL_24:
  }
}

void sub_10017A60C(uint64_t a1)
{
  unsigned __int8 v73 = 0;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 1856, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    id v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    id v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 56));
    id v15 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)long long buf = 67110146;
    int v83 = v12;
    __int16 v84 = 2082;
    int v85 = v13;
    __int16 v86 = 2082;
    __int16 v87 = v14;
    __int16 v88 = 1024;
    int v89 = 1856;
    __int16 v90 = 2114;
    __int16 v91 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    id v32 = [*(id *)(a1 + 32) _getSecureElementWrapperForSEID:*(void *)(a1 + 40)];
    if ([*(id *)(a1 + 32) _activateSecureElementWrapper:v32])
    {
      BOOL v34 = +[NSMutableDictionary dictionary];
      uint64_t v36 = sub_1000AE4D0(v32);

      if (!v36)
      {
        uint64_t v37 = +[NSNumber numberWithBool:v73];
        [v34 setObject:v37 forKeyedSubscript:@"Presence"];
      }
      id v72 = 0;
      id v38 = sub_1000AD6C4(v32, &v72);
      id v33 = v72;
      [v34 addEntriesFromDictionary:v38];

      if (*(unsigned char *)(a1 + 64)) {
        id v39 = sub_1000AD800(v32);
      }
      id v40 = [v34 count];
      uint64_t v41 = *(void *)(a1 + 48);
      if ((unint64_t)v40 < 2)
      {
        id v57 = objc_alloc((Class)NSError);
        uint64_t v58 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v59 = (void *)v58;
        if (v33)
        {
          id v71 = (void *)v58;
          id v70 = [v33 code];
          v76[0] = NSLocalizedDescriptionKey;
          if ((uint64_t)[v33 code] > 70) {
            uint64_t v60 = 71;
          }
          else {
            uint64_t v60 = (uint64_t)[v33 code];
          }
          __int16 v69 = +[NSString stringWithUTF8String:off_100305838[v60]];
          v77[0] = v69;
          v77[1] = v33;
          v76[1] = NSUnderlyingErrorKey;
          v76[2] = @"Line";
          v77[2] = &off_10031C8D0;
          v76[3] = @"Method";
          id v64 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
          void v77[3] = v64;
          v76[4] = NSDebugDescriptionErrorKey;
          id v65 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 1881];
          v77[4] = v65;
          NSErrorUserInfoKey v66 = +[NSDictionary dictionaryWithObjects:v77 forKeys:v76 count:5];
          id v67 = [v57 initWithDomain:v71 code:v70 userInfo:v66];
          (*(void (**)(uint64_t, void, id))(v41 + 16))(v41, 0, v67);
        }
        else
        {
          NSErrorUserInfoKey v74 = NSLocalizedDescriptionKey;
          __int16 v61 = +[NSString stringWithUTF8String:"Unexpected Result"];
          int v75 = v61;
          int v62 = +[NSDictionary dictionaryWithObjects:&v75 forKeys:&v74 count:1];
          id v63 = [v57 initWithDomain:v59 code:13 userInfo:v62];
          (*(void (**)(uint64_t, void, id))(v41 + 16))(v41, 0, v63);

          id v33 = 0;
        }
      }
      else
      {
        (*(void (**)(void, void *, id))(v41 + 16))(*(void *)(a1 + 48), v34, v33);
      }
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v42 = NFLogGetLogger();
      if (v42)
      {
        id v43 = (void (*)(uint64_t, const char *, ...))v42;
        id v44 = object_getClass(*(id *)(a1 + 32));
        BOOL v45 = class_isMetaClass(v44);
        uint64_t v46 = object_getClassName(*(id *)(a1 + 32));
        int v68 = sel_getName(*(SEL *)(a1 + 56));
        uint64_t v47 = 45;
        if (v45) {
          uint64_t v47 = 43;
        }
        v43(3, "%c[%{public}s %{public}s]:%i Failed to activate embedded secure element", v47, v46, v68, 1862);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      NSErrorUserInfoKey v48 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
      {
        int v49 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v49)) {
          int v50 = 43;
        }
        else {
          int v50 = 45;
        }
        int v51 = object_getClassName(*(id *)(a1 + 32));
        __int16 v52 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)long long buf = 67109890;
        int v83 = v50;
        __int16 v84 = 2082;
        int v85 = v51;
        __int16 v86 = 2082;
        __int16 v87 = v52;
        __int16 v88 = 1024;
        int v89 = 1862;
        _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to activate embedded secure element", buf, 0x22u);
      }

      uint64_t v53 = *(void *)(a1 + 48);
      id v54 = objc_alloc((Class)NSError);
      id v33 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v78 = NSLocalizedDescriptionKey;
      BOOL v34 = +[NSString stringWithUTF8String:"Stack Error"];
      int v79 = v34;
      NSErrorUserInfoKey v55 = +[NSDictionary dictionaryWithObjects:&v79 forKeys:&v78 count:1];
      id v56 = [v54 initWithDomain:v33 code:15 userInfo:v55];
      (*(void (**)(uint64_t, void, id))(v53 + 16))(v53, 0, v56);
    }
    goto LABEL_24;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v16 = NFLogGetLogger();
  if (v16)
  {
    id v17 = (void (*)(uint64_t, const char *, ...))v16;
    id v18 = object_getClass(*(id *)(a1 + 32));
    BOOL v19 = class_isMetaClass(v18);
    CFStringRef v20 = object_getClassName(*(id *)(a1 + 32));
    id v21 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v22 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v23 = 45;
    if (v19) {
      uint64_t v23 = 43;
    }
    v17(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v23, v20, v21, 1858, v22);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v24 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    int v25 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v25)) {
      int v26 = 43;
    }
    else {
      int v26 = 45;
    }
    int v27 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v28 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v29 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v83 = v26;
    __int16 v84 = 2082;
    int v85 = v27;
    __int16 v86 = 2082;
    __int16 v87 = v28;
    __int16 v88 = 1024;
    int v89 = 1858;
    __int16 v90 = 2114;
    __int16 v91 = v29;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v30 = *(void *)(a1 + 48);
  if (v30)
  {
    id v31 = objc_alloc((Class)NSError);
    id v32 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v80 = NSLocalizedDescriptionKey;
    id v33 = +[NSString stringWithUTF8String:"Session not active"];
    id v81 = v33;
    BOOL v34 = +[NSDictionary dictionaryWithObjects:&v81 forKeys:&v80 count:1];
    id v35 = [v31 initWithDomain:v32 code:54 userInfo:v34];
    (*(void (**)(uint64_t, void, id))(v30 + 16))(v30, 0, v35);

LABEL_24:
  }
}

void sub_10017B004(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@", v9, ClassName, Name, 1892, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    id v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    id v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 56));
    id v15 = [*(id *)(a1 + 32) clientName];
    *(_DWORD *)long long buf = 67110146;
    int v59 = v12;
    __int16 v60 = 2082;
    __int16 v61 = v13;
    __int16 v62 = 2082;
    id v63 = v14;
    __int16 v64 = 1024;
    int v65 = 1892;
    __int16 v66 = 2114;
    id v67 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    id v32 = [*(id *)(a1 + 32) _getSecureElementWrapperForSEID:*(void *)(a1 + 40)];
    if ([*(id *)(a1 + 32) _activateSecureElementWrapper:v32])
    {
      id v33 = sub_1000AE4D0(v32);
      (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
      goto LABEL_25;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v36 = NFLogGetLogger();
    if (v36)
    {
      uint64_t v37 = (void (*)(uint64_t, const char *, ...))v36;
      id v38 = object_getClass(*(id *)(a1 + 32));
      BOOL v39 = class_isMetaClass(v38);
      id v40 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v53 = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v41 = 45;
      if (v39) {
        uint64_t v41 = 43;
      }
      v37(3, "%c[%{public}s %{public}s]:%i Failed to activate embedded secure element", v41, v40, v53, 1898);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v42 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
    {
      id v43 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v43)) {
        int v44 = 43;
      }
      else {
        int v44 = 45;
      }
      BOOL v45 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v46 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)long long buf = 67109890;
      int v59 = v44;
      __int16 v60 = 2082;
      __int16 v61 = v45;
      __int16 v62 = 2082;
      id v63 = v46;
      __int16 v64 = 1024;
      int v65 = 1898;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to activate embedded secure element", buf, 0x22u);
    }

    uint64_t v47 = *(void *)(a1 + 48);
    id v48 = objc_alloc((Class)NSError);
    id v33 = +[NSString stringWithUTF8String:"nfcd"];
    v54[0] = NSLocalizedDescriptionKey;
    BOOL v34 = +[NSString stringWithUTF8String:"Stack Error"];
    v55[0] = v34;
    v55[1] = &off_10031C8E8;
    v54[1] = @"Line";
    v54[2] = @"Method";
    id v49 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    void v55[2] = v49;
    v54[3] = NSDebugDescriptionErrorKey;
    id v50 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 1899];
    v55[3] = v50;
    int v51 = +[NSDictionary dictionaryWithObjects:v55 forKeys:v54 count:4];
    id v52 = [v48 initWithDomain:v33 code:15 userInfo:v51];
    (*(void (**)(uint64_t, void, id))(v47 + 16))(v47, 0, v52);

LABEL_24:
LABEL_25:

    return;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v16 = NFLogGetLogger();
  if (v16)
  {
    id v17 = (void (*)(uint64_t, const char *, ...))v16;
    id v18 = object_getClass(*(id *)(a1 + 32));
    BOOL v19 = class_isMetaClass(v18);
    CFStringRef v20 = object_getClassName(*(id *)(a1 + 32));
    id v21 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v22 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v23 = 45;
    if (v19) {
      uint64_t v23 = 43;
    }
    v17(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v23, v20, v21, 1894, v22);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v24 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
  {
    int v25 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v25)) {
      int v26 = 43;
    }
    else {
      int v26 = 45;
    }
    int v27 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v28 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v29 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v59 = v26;
    __int16 v60 = 2082;
    __int16 v61 = v27;
    __int16 v62 = 2082;
    id v63 = v28;
    __int16 v64 = 1024;
    int v65 = 1894;
    __int16 v66 = 2114;
    id v67 = v29;
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v30 = *(void *)(a1 + 48);
  if (v30)
  {
    id v31 = objc_alloc((Class)NSError);
    id v32 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v56 = NSLocalizedDescriptionKey;
    id v33 = +[NSString stringWithUTF8String:"Session not active"];
    id v57 = v33;
    BOOL v34 = +[NSDictionary dictionaryWithObjects:&v57 forKeys:&v56 count:1];
    id v35 = [v31 initWithDomain:v32 code:54 userInfo:v34];
    (*(void (**)(uint64_t, void, id))(v30 + 16))(v30, 0, v35);

    goto LABEL_24;
  }
}

void sub_10017B7B8(uint64_t a1)
{
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    id v18 = [*(id *)(a1 + 32) _getSecureElementWrapperForSEID:*(void *)(a1 + 40)];
    if ([*(id *)(a1 + 32) _activateSecureElementWrapper:v18])
    {
      uint64_t v22 = *(unsigned __int8 *)(a1 + 64);
      id v39 = 0;
      CFStringRef v20 = sub_1000A695C(v18, v22, &v39);
      id v19 = v39;
      (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        id v24 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(*(id *)(a1 + 32));
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(*(id *)(a1 + 32));
        Name = sel_getName(*(SEL *)(a1 + 56));
        uint64_t v28 = 45;
        if (isMetaClass) {
          uint64_t v28 = 43;
        }
        v24(3, "%c[%{public}s %{public}s]:%i Failed to activate secure element", v28, ClassName, Name, 1923);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v29 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      {
        uint64_t v30 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v30)) {
          int v31 = 43;
        }
        else {
          int v31 = 45;
        }
        id v32 = object_getClassName(*(id *)(a1 + 32));
        id v33 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)long long buf = 67109890;
        int v45 = v31;
        __int16 v46 = 2082;
        uint64_t v47 = v32;
        __int16 v48 = 2082;
        id v49 = v33;
        __int16 v50 = 1024;
        int v51 = 1923;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to activate secure element", buf, 0x22u);
      }

      uint64_t v34 = *(void *)(a1 + 48);
      id v35 = objc_alloc((Class)NSError);
      id v19 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v40 = NSLocalizedDescriptionKey;
      CFStringRef v20 = +[NSString stringWithUTF8String:"Stack Error"];
      uint64_t v41 = v20;
      uint64_t v36 = +[NSDictionary dictionaryWithObjects:&v41 forKeys:&v40 count:1];
      id v37 = [v35 initWithDomain:v19 code:15 userInfo:v36];
      (*(void (**)(uint64_t, void, id))(v34 + 16))(v34, 0, v37);
    }
    goto LABEL_15;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v2 = NFLogGetLogger();
  if (v2)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))v2;
    uint64_t v4 = object_getClass(*(id *)(a1 + 32));
    BOOL v5 = class_isMetaClass(v4);
    uint64_t v6 = object_getClassName(*(id *)(a1 + 32));
    id v7 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v9 = 45;
    if (v5) {
      uint64_t v9 = 43;
    }
    v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, v6, v7, 1917, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    id v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    id v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 56));
    id v15 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v45 = v12;
    __int16 v46 = 2082;
    uint64_t v47 = v13;
    __int16 v48 = 2082;
    id v49 = v14;
    __int16 v50 = 1024;
    int v51 = 1917;
    __int16 v52 = 2114;
    uint64_t v53 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v16 = *(void *)(a1 + 48);
  if (v16)
  {
    id v17 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v42 = NSLocalizedDescriptionKey;
    id v19 = +[NSString stringWithUTF8String:"Session not active"];
    id v43 = v19;
    CFStringRef v20 = +[NSDictionary dictionaryWithObjects:&v43 forKeys:&v42 count:1];
    id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
    (*(void (**)(uint64_t, void, id))(v16 + 16))(v16, 0, v21);

LABEL_15:
  }
}

void sub_10017BD74(uint64_t a1)
{
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    int v25 = *(void **)(a1 + 32);
    int v26 = [v25 embeddedSecureElementWrapper];
    LOBYTE(v25) = [v25 _activateSecureElementWrapper:v26];

    if (v25)
    {
      int v27 = [*(id *)(a1 + 32) embeddedSecureElementWrapper];
      id v50 = 0;
      id v19 = sub_1000AD490(v27, &v50);
      id v28 = v50;

      if (v28)
      {
        id v29 = objc_alloc((Class)NSError);
        uint64_t v30 = +[NSString stringWithUTF8String:"nfcd"];
        id v31 = [v28 code];
        v51[0] = NSLocalizedDescriptionKey;
        if ((uint64_t)[v28 code] > 70) {
          uint64_t v32 = 71;
        }
        else {
          uint64_t v32 = (uint64_t)[v28 code];
        }
        int v45 = +[NSString stringWithUTF8String:off_100305838[v32]];
        v52[0] = v45;
        v52[1] = v28;
        v51[1] = NSUnderlyingErrorKey;
        v51[2] = @"Line";
        v52[2] = &off_10031C900;
        v51[3] = @"Method";
        id v46 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
        v52[3] = v46;
        void v51[4] = NSDebugDescriptionErrorKey;
        id v47 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 1952];
        void v52[4] = v47;
        __int16 v48 = +[NSDictionary dictionaryWithObjects:v52 forKeys:v51 count:5];
        id v18 = [v29 initWithDomain:v30 code:v31 userInfo:v48];
      }
      else
      {
        id v18 = 0;
      }
      (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
      goto LABEL_16;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v34 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v38 = 45;
      if (isMetaClass) {
        uint64_t v38 = 43;
      }
      v34(3, "%c[%{public}s %{public}s]:%i Failed to activate embedded secure element", v38, ClassName, Name, 1944);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v39 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
    {
      NSErrorUserInfoKey v40 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v40)) {
        int v41 = 43;
      }
      else {
        int v41 = 45;
      }
      NSErrorUserInfoKey v42 = object_getClassName(*(id *)(a1 + 32));
      id v43 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)long long buf = 67109890;
      int v58 = v41;
      __int16 v59 = 2082;
      __int16 v60 = v42;
      __int16 v61 = 2082;
      __int16 v62 = v43;
      __int16 v63 = 1024;
      int v64 = 1944;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to activate embedded secure element", buf, 0x22u);
    }

    uint64_t v16 = *(void *)(a1 + 40);
    id v44 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v53 = NSLocalizedDescriptionKey;
    id v19 = +[NSString stringWithUTF8String:"Stack Error"];
    id v54 = v19;
    CFStringRef v20 = +[NSDictionary dictionaryWithObjects:&v54 forKeys:&v53 count:1];
    id v21 = v44;
    id v22 = v18;
    uint64_t v23 = 15;
LABEL_15:
    id v24 = [v21 initWithDomain:v22 code:v23 userInfo:v20];
    (*(void (**)(uint64_t, void, id))(v16 + 16))(v16, 0, v24);

LABEL_16:
    return;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v2 = NFLogGetLogger();
  if (v2)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))v2;
    uint64_t v4 = object_getClass(*(id *)(a1 + 32));
    BOOL v5 = class_isMetaClass(v4);
    uint64_t v6 = object_getClassName(*(id *)(a1 + 32));
    id v7 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v9 = 45;
    if (v5) {
      uint64_t v9 = 43;
    }
    v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, v6, v7, 1941, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    id v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    id v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
    id v15 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v58 = v12;
    __int16 v59 = 2082;
    __int16 v60 = v13;
    __int16 v61 = 2082;
    __int16 v62 = v14;
    __int16 v63 = 1024;
    int v64 = 1941;
    __int16 v65 = 2114;
    __int16 v66 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v16 = *(void *)(a1 + 40);
  if (v16)
  {
    id v17 = objc_alloc((Class)NSError);
    id v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v55 = NSLocalizedDescriptionKey;
    id v19 = +[NSString stringWithUTF8String:"Session not active"];
    NSErrorUserInfoKey v56 = v19;
    CFStringRef v20 = +[NSDictionary dictionaryWithObjects:&v56 forKeys:&v55 count:1];
    id v21 = v17;
    id v22 = v18;
    uint64_t v23 = 54;
    goto LABEL_15;
  }
}

NSXPCInterface *sub_10017EF18()
{
  self;

  return +[NSXPCInterface interfaceWithProtocol:&OBJC_PROTOCOL___NFReaderSessionAccessoryInterface];
}

id sub_10017EF50()
{
  self;
  id v0 = +[NSXPCInterface interfaceWithProtocol:&OBJC_PROTOCOL___NFReaderSessionAccessoryCallbacks];
  id v1 = objc_alloc((Class)NSSet);
  uint64_t v2 = objc_opt_class();
  id v3 = [v1 initWithObjects:v2, objc_opt_class(), nil];
  [v0 setClasses:v3 forSelector:"didDetectTags:" argumentIndex:0 ofReply:0];

  return v0;
}

void sub_10017F3A4(uint64_t a1)
{
}

id sub_10017F3AC(id a1, void *a2)
{
  id v2 = a1;
  if (a1)
  {
    id v3 = [a2 sessionID];
    if (v3)
    {
      uint64_t v4 = [v2 driverWrapper];
      sub_10020EC8C(v4, v3, 0);
      id v2 = (id)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      id v2 = 0;
    }
  }

  return v2;
}

void sub_10017F434(void *a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v64 = a3;
  __int16 v62 = a4;
  if (a1)
  {
    __int16 v63 = [v64 NF_whitelistChecker];
    id obj = objc_getProperty(a1, v8, 176, 1);
    objc_sync_enter(obj);
    uint64_t v9 = [v64 NF_userInfo];
    int v10 = [v9 objectForKeyedSubscript:@"assertions"];

    long long v75 = 0u;
    long long v73 = 0u;
    long long v74 = 0u;
    long long v72 = 0u;
    id v11 = v10;
    id v12 = [v11 countByEnumeratingWithState:&v72 objects:v88 count:16];
    if (v12)
    {
      uint64_t v13 = *(void *)v73;
      while (2)
      {
        for (i = 0; i != v12; i = (char *)i + 1)
        {
          if (*(void *)v73 != v13) {
            objc_enumerationMutation(v11);
          }
          id v15 = *(void **)(*((void *)&v72 + 1) + 8 * i);
          uint64_t v16 = [v15 remoteAssertion];
          unsigned int v17 = [v16 isEqual:v7];

          if (v17)
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
            if (Logger)
            {
              Class = object_getClass(a1);
              if (class_isMetaClass(Class)) {
                uint64_t v21 = 43;
              }
              else {
                uint64_t v21 = 45;
              }
              ClassName = object_getClassName(a1);
              Name = sel_getName("_sync_releaseAssertion:xpcConnection:completion:");
              id v24 = [v64 processIdentifier];
              int v25 = [v63 clientName];
              Logger(6, "%c[%{public}s %{public}s]:%i Assertion %{public}@ released from PID %d (%{public}@)", v21, ClassName, Name, 207, v7, v24, v25);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            int v26 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
            {
              int v27 = object_getClass(a1);
              if (class_isMetaClass(v27)) {
                int v28 = 43;
              }
              else {
                int v28 = 45;
              }
              id v29 = object_getClassName(a1);
              uint64_t v30 = sel_getName("_sync_releaseAssertion:xpcConnection:completion:");
              unsigned int v31 = [v64 processIdentifier];
              uint64_t v32 = [v63 clientName];
              *(_DWORD *)long long buf = 67110658;
              int v77 = v28;
              __int16 v78 = 2082;
              int v79 = v29;
              __int16 v80 = 2082;
              id v81 = v30;
              __int16 v82 = 1024;
              int v83 = 207;
              __int16 v84 = 2114;
              *(void *)int v85 = v7;
              *(_WORD *)&v85[8] = 1024;
              *(_DWORD *)&v85[10] = v31;
              __int16 v86 = 2114;
              id v87 = v32;
              _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Assertion %{public}@ released from PID %d (%{public}@)", buf, 0x3Cu);
            }
            id v18 = v15;
            [v11 removeObject:v18];
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            id v33 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
            if (v33)
            {
              uint64_t v34 = object_getClass(a1);
              if (class_isMetaClass(v34)) {
                uint64_t v35 = 43;
              }
              else {
                uint64_t v35 = 45;
              }
              uint64_t v36 = object_getClassName(a1);
              id v37 = sel_getName("_sync_releaseAssertion:xpcConnection:completion:");
              id v38 = [v64 processIdentifier];
              id v39 = [v63 clientName];
              v33(6, "%c[%{public}s %{public}s]:%i Assertion available for PID %d (%{public}@) are %{public}@", v35, v36, v37, 212, v38, v39, v11);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            NSErrorUserInfoKey v40 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
            {
              int v41 = object_getClass(a1);
              if (class_isMetaClass(v41)) {
                int v42 = 43;
              }
              else {
                int v42 = 45;
              }
              id v43 = object_getClassName(a1);
              id v44 = sel_getName("_sync_releaseAssertion:xpcConnection:completion:");
              unsigned int v45 = [v64 processIdentifier];
              id v46 = [v63 clientName];
              *(_DWORD *)long long buf = 67110658;
              int v77 = v42;
              __int16 v78 = 2082;
              int v79 = v43;
              __int16 v80 = 2082;
              id v81 = v44;
              __int16 v82 = 1024;
              int v83 = 212;
              __int16 v84 = 1024;
              *(_DWORD *)int v85 = v45;
              *(_WORD *)&void v85[4] = 2114;
              *(void *)&v85[6] = v46;
              __int16 v86 = 2114;
              id v87 = v11;
              _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Assertion available for PID %d (%{public}@) are %{public}@", buf, 0x3Cu);
            }
            goto LABEL_32;
          }
        }
        id v12 = [v11 countByEnumeratingWithState:&v72 objects:v88 count:16];
        if (v12) {
          continue;
        }
        break;
      }
    }
    id v18 = 0;
LABEL_32:

    objc_sync_exit(obj);
    uint64_t v66 = 0;
    id v67 = &v66;
    uint64_t v68 = 0x3032000000;
    __int16 v69 = sub_10000B898;
    id v70 = sub_10017F3A4;
    id v71 = 0;
    if (v18)
    {
      v65[0] = _NSConcreteStackBlock;
      v65[1] = 3221225472;
      v65[2] = sub_10017FC24;
      v65[3] = &unk_100305F18;
      v65[4] = &v66;
      [v18 onDeassertWithCompletion:v65];
      if ([v7 assertionType] == (id)4)
      {
        [v64 NF_clearPresentmentIntentSuppressionHolder];
      }
      else if ([v7 assertionType] == (id)6)
      {
        [v64 NF_clearFDPresentmentIntentSuppressionHolder];
      }
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v47 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v47)
      {
        __int16 v48 = object_getClass(a1);
        if (class_isMetaClass(v48)) {
          uint64_t v49 = 43;
        }
        else {
          uint64_t v49 = 45;
        }
        id v50 = object_getClassName(a1);
        int v51 = sel_getName("_sync_releaseAssertion:xpcConnection:completion:");
        id v52 = [v64 processIdentifier];
        NSErrorUserInfoKey v53 = [v63 clientName];
        v47(4, "%c[%{public}s %{public}s]:%i Assertion %{public}@ not available for PID %d (%{public}@)", v49, v50, v51, 230, v7, v52, v53);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v54 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
      {
        NSErrorUserInfoKey v55 = object_getClass(a1);
        if (class_isMetaClass(v55)) {
          int v56 = 43;
        }
        else {
          int v56 = 45;
        }
        id v57 = object_getClassName(a1);
        int v58 = sel_getName("_sync_releaseAssertion:xpcConnection:completion:");
        unsigned int v59 = [v64 processIdentifier];
        __int16 v60 = [v63 clientName];
        *(_DWORD *)long long buf = 67110658;
        int v77 = v56;
        __int16 v78 = 2082;
        int v79 = v57;
        __int16 v80 = 2082;
        id v81 = v58;
        __int16 v82 = 1024;
        int v83 = 230;
        __int16 v84 = 2114;
        *(void *)int v85 = v7;
        *(_WORD *)&v85[8] = 1024;
        *(_DWORD *)&v85[10] = v59;
        __int16 v86 = 2114;
        id v87 = v60;
        _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Assertion %{public}@ not available for PID %d (%{public}@)", buf, 0x3Cu);
      }
    }
    v62[2](v62, v67[5]);
    _Block_object_dispose(&v66, 8);
  }
}

void sub_10017FBC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id obj, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
}

void sub_10017FC24(uint64_t a1, void *a2)
{
}

void sub_10017FC34(void *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    id v33 = [v3 NF_whitelistChecker];
    BOOL v5 = [v4 NF_userInfo];
    uint64_t v6 = [v5 objectForKeyedSubscript:@"assertions"];

    long long v36 = 0u;
    long long v37 = 0u;
    long long v34 = 0u;
    long long v35 = 0u;
    id obj = v6;
    id v32 = [obj countByEnumeratingWithState:&v34 objects:v52 count:16];
    if (v32)
    {
      uint64_t v31 = *(void *)v35;
      do
      {
        for (i = 0; i != v32; i = (char *)i + 1)
        {
          if (*(void *)v35 != v31) {
            objc_enumerationMutation(obj);
          }
          SEL v8 = *(void **)(*((void *)&v34 + 1) + 8 * i);
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t Logger = NFLogGetLogger();
          if (Logger)
          {
            int v10 = (void (*)(uint64_t, const char *, ...))Logger;
            Class = object_getClass(a1);
            BOOL isMetaClass = class_isMetaClass(Class);
            ClassName = object_getClassName(a1);
            Name = sel_getName("releaseAssertionsForConnection:");
            id v15 = [v4 processIdentifier];
            uint64_t v16 = [v33 clientName];
            uint64_t v17 = 45;
            if (isMetaClass) {
              uint64_t v17 = 43;
            }
            v10(6, "%c[%{public}s %{public}s]:%i Assertion %{public}@ released from PID %d (%{public}@)", v17, ClassName, Name, 243, v8, v15, v16);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v18 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
          {
            id v19 = object_getClass(a1);
            if (class_isMetaClass(v19)) {
              int v20 = 43;
            }
            else {
              int v20 = 45;
            }
            uint64_t v21 = object_getClassName(a1);
            id v22 = sel_getName("releaseAssertionsForConnection:");
            unsigned int v23 = [v4 processIdentifier];
            id v24 = [v33 clientName];
            *(_DWORD *)long long buf = 67110658;
            int v39 = v20;
            __int16 v40 = 2082;
            int v41 = v21;
            __int16 v42 = 2082;
            id v43 = v22;
            __int16 v44 = 1024;
            int v45 = 243;
            __int16 v46 = 2114;
            id v47 = v8;
            __int16 v48 = 1024;
            unsigned int v49 = v23;
            __int16 v50 = 2114;
            int v51 = v24;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Assertion %{public}@ released from PID %d (%{public}@)", buf, 0x3Cu);
          }
          [v8 onDeassertWithCompletion:0];
          int v25 = [v8 remoteAssertion];
          id v26 = [v25 assertionType];

          if (v26 == (id)4)
          {
            [v4 NF_clearPresentmentIntentSuppressionHolder];
          }
          else
          {
            int v27 = [v8 remoteAssertion];
            id v28 = [v27 assertionType];

            if (v28 == (id)6) {
              [v4 NF_clearFDPresentmentIntentSuppressionHolder];
            }
          }
        }
        id v32 = [obj countByEnumeratingWithState:&v34 objects:v52 count:16];
      }
      while (v32);
    }

    id v29 = [v4 NF_userInfo];
    [v29 setObject:0 forKeyedSubscript:@"assertions"];
  }
}

void sub_10017FFBC(void *a1, void *a2)
{
  if (a1)
  {
    id v3 = [a2 sessionID];
    if (v3)
    {
      id v5 = v3;
      uint64_t v4 = [a1 driverWrapper];
      sub_1002114AC(v4, v5);

      id v3 = v5;
    }
  }
}

void sub_100180030(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if ([v3 isEqualToString:@"NFCameraStateMonitor"])
    {
      id v5 = *(id *)(a1 + 416);

      if (v5)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          SEL v8 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass((id)a1);
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName((id)a1);
          Name = sel_getName("requestConnectionHandoverAssert:");
          uint64_t v12 = 45;
          if (isMetaClass) {
            uint64_t v12 = 43;
          }
          v8(5, "%c[%{public}s %{public}s]:%i Camera assertion exists", v12, ClassName, Name, 268);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v13 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v14 = object_getClass((id)a1);
          if (class_isMetaClass(v14)) {
            int v15 = 43;
          }
          else {
            int v15 = 45;
          }
          *(_DWORD *)long long buf = 67109890;
          int v35 = v15;
          __int16 v36 = 2082;
          long long v37 = object_getClassName((id)a1);
          __int16 v38 = 2082;
          int v39 = sel_getName("requestConnectionHandoverAssert:");
          __int16 v40 = 1024;
          int v41 = 268;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Camera assertion exists", buf, 0x22u);
        }
LABEL_26:

        goto LABEL_27;
      }
      id v17 = objc_getProperty((id)a1, v6, 176, 1);
      objc_sync_enter(v17);
      id v18 = objc_alloc((Class)NFAssertionInternal);
      v32[0] = @"NFAssertionType";
      v32[1] = @"NFAssertionTime";
      v33[0] = &off_10031C978;
      id v19 = +[NSDate now];
      v33[1] = v19;
      int v20 = +[NSDictionary dictionaryWithObjects:v33 forKeys:v32 count:2];
      id v21 = [v18 initWithDictionary:v20];
      objc_storeStrong((id *)(a1 + 416), v21);

      objc_sync_exit(v17);
    }
    else
    {
      int v16 = *(_DWORD *)(a1 + 328);
      if (v16 == -1)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v22 = NFLogGetLogger();
        if (v22)
        {
          unsigned int v23 = (void (*)(uint64_t, const char *, ...))v22;
          id v24 = object_getClass((id)a1);
          BOOL v25 = class_isMetaClass(v24);
          id v26 = object_getClassName((id)a1);
          uint64_t v31 = sel_getName("requestConnectionHandoverAssert:");
          uint64_t v27 = 45;
          if (v25) {
            uint64_t v27 = 43;
          }
          v23(3, "%c[%{public}s %{public}s]:%i CH assertion count overflow!", v27, v26, v31, 283);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v13 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        {
          id v28 = object_getClass((id)a1);
          if (class_isMetaClass(v28)) {
            int v29 = 43;
          }
          else {
            int v29 = 45;
          }
          *(_DWORD *)long long buf = 67109890;
          int v35 = v29;
          __int16 v36 = 2082;
          long long v37 = object_getClassName((id)a1);
          __int16 v38 = 2082;
          int v39 = sel_getName("requestConnectionHandoverAssert:");
          __int16 v40 = 1024;
          int v41 = 283;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i CH assertion count overflow!", buf, 0x22u);
        }
        goto LABEL_26;
      }
      *(_DWORD *)(a1 + 328) = v16 + 1;
    }
  }
LABEL_27:
}

void sub_1001803E8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100180404(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v7 = v3;
    if ([v3 isEqualToString:@"NFCameraStateMonitor"])
    {
      id v5 = objc_getProperty((id)a1, v4, 176, 1);
      objc_sync_enter(v5);
      objc_storeStrong((id *)(a1 + 416), 0);
      objc_sync_exit(v5);

      id v3 = v7;
    }
    else
    {
      int v6 = *(_DWORD *)(a1 + 328);
      id v3 = v7;
      if (v6) {
        *(_DWORD *)(a1 + 328) = v6 - 1;
      }
    }
  }
}

uint64_t sub_1001804AC(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  if (*(_DWORD *)(a1 + 328)) {
    return 1;
  }
  id v2 = *(id *)(a1 + 416);
  BOOL v1 = v2 != 0;

  return v1;
}

id sub_100180B08()
{
  self;
  if (qword_1003474B0 != -1) {
    dispatch_once(&qword_1003474B0, &stru_100305F38);
  }
  id v0 = (void *)qword_1003474A8;

  return v0;
}

void sub_100180B60(id a1)
{
  BOOL v1 = objc_alloc_init(NFCameraStateMonitor);
  uint64_t v2 = qword_1003474A8;
  qword_1003474A8 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_100180B9C(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = objc_opt_new();
    long long v19 = 0u;
    long long v20 = 0u;
    long long v21 = 0u;
    long long v22 = 0u;
    id v3 = *(id *)(a1 + 16);
    id v4 = [v3 countByEnumeratingWithState:&v19 objects:v24 count:16];
    if (v4)
    {
      id v5 = v4;
      uint64_t v6 = *(void *)v20;
      do
      {
        for (i = 0; i != v5; i = (char *)i + 1)
        {
          if (*(void *)v20 != v6) {
            objc_enumerationMutation(v3);
          }
          uint64_t v8 = *(void *)(*((void *)&v19 + 1) + 8 * i);
          uint64_t v9 = [*(id *)(a1 + 16) objectForKey:v8];

          if (!v9) {
            [v2 addObject:v8];
          }
        }
        id v5 = [v3 countByEnumeratingWithState:&v19 objects:v24 count:16];
      }
      while (v5);
    }

    long long v17 = 0u;
    long long v18 = 0u;
    long long v15 = 0u;
    long long v16 = 0u;
    id v10 = v2;
    id v11 = [v10 countByEnumeratingWithState:&v15 objects:v23 count:16];
    if (v11)
    {
      id v12 = v11;
      uint64_t v13 = *(void *)v16;
      do
      {
        for (j = 0; j != v12; j = (char *)j + 1)
        {
          if (*(void *)v16 != v13) {
            objc_enumerationMutation(v10);
          }
          [*(id *)(a1 + 16) removeObjectForKey:*(void *)(*((void *)&v15 + 1) + 8 * (void)j) (void)v15];
        }
        id v12 = [v10 countByEnumeratingWithState:&v15 objects:v23 count:16];
      }
      while (v12);
    }
  }
}

void sub_100180D64(os_unfair_lock_s *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    if (objc_opt_respondsToSelector())
    {
      v17[0] = _NSConcreteStackBlock;
      v17[1] = 3221225472;
      v17[2] = sub_100180FB0;
      v17[3] = &unk_100304628;
      v17[4] = a1;
      id v18 = v5;
      id v19 = v6;
      os_unfair_lock_lock(a1 + 13);
      sub_100180FB0(v17);
      os_unfair_lock_unlock(a1 + 13);
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        uint64_t v8 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("registerStateChangeWithDelegate:client:");
        uint64_t v12 = 45;
        if (isMetaClass) {
          uint64_t v12 = 43;
        }
        v8(3, "%c[%{public}s %{public}s]:%i Unexpected delegate type, dropping registration", v12, ClassName, Name, 131);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v13 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        uint64_t v14 = object_getClass(a1);
        if (class_isMetaClass(v14)) {
          int v15 = 43;
        }
        else {
          int v15 = 45;
        }
        *(_DWORD *)long long buf = 67109890;
        int v21 = v15;
        __int16 v22 = 2082;
        unsigned int v23 = object_getClassName(a1);
        __int16 v24 = 2082;
        BOOL v25 = sel_getName("registerStateChangeWithDelegate:client:");
        __int16 v26 = 1024;
        int v27 = 131;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected delegate type, dropping registration", buf, 0x22u);
      }
    }
  }
}

void sub_100180FB0(uint64_t *a1)
{
  kern_return_t v22;
  void (*v23)(uint64_t, const char *, ...);
  objc_class *v24;
  uint64_t v25;
  const char *v26;
  const char *v27;
  NSObject *v28;
  objc_class *v29;
  int v30;
  const char *v31;
  const char *v32;
  void (*v33)(uint64_t, const char *, ...);
  objc_class *v34;
  uint64_t v35;
  const char *v36;
  const char *v37;
  NSObject *v38;
  objc_class *v39;
  int v40;
  const char *v41;
  const char *v42;
  void (*v43)(uint64_t, const char *, ...);
  objc_class *v44;
  uint64_t v45;
  const char *v46;
  const char *v47;
  objc_class *v48;
  int v49;
  const char *v50;
  const char *v51;
  void (*v52)(uint64_t, const char *, ...);
  objc_class *v53;
  uint64_t v54;
  const char *v55;
  const char *v56;
  NSObject *v57;
  objc_class *v58;
  int v59;
  const char *v60;
  const char *v61;
  NSObject *v62;
  void *v63;
  _DWORD *v64;
  id location;
  id from;
  uint8_t v67[8];
  unsigned char v68[26];
  unsigned char buf[34];
  const char *v70;

  id v2 = [*(id *)(a1[4] + 16) count];
  [*(id *)(a1[4] + 16) setObject:a1[5] forKey:a1[6]];
  sub_100180B9C(a1[4]);
  if (!v2)
  {
    uint64_t v3 = a1[4];
    if (v3)
    {
      objc_initWeak(&location, (id)v3);
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (Logger)
      {
        Class = object_getClass((id)v3);
        if (class_isMetaClass(Class)) {
          uint64_t v6 = 43;
        }
        else {
          uint64_t v6 = 45;
        }
        ClassName = object_getClassName((id)v3);
        Name = sel_getName("_registerForCameraNotifications");
        Logger(6, "%c[%{public}s %{public}s]:%i ", v6, ClassName, Name, 194);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v9 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        id v10 = object_getClass((id)v3);
        if (class_isMetaClass(v10)) {
          int v11 = 43;
        }
        else {
          int v11 = 45;
        }
        uint64_t v12 = object_getClassName((id)v3);
        uint64_t v13 = sel_getName("_registerForCameraNotifications");
        *(_DWORD *)long long buf = 67109890;
        *(_DWORD *)&uint8_t buf[4] = v11;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = v12;
        *(_WORD *)&buf[18] = 2082;
        *(void *)&buf[20] = v13;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 194;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
      }

      if (sub_100182AAC())
      {
        uint64_t v14 = IONotificationPortCreate(kIOMainPortDefault);
        *(void *)(v3 + 40) = v14;
        if (v14)
        {
          IONotificationPortSetDispatchQueue(v14, *(dispatch_queue_t *)(v3 + 32));
          int v15 = *(IONotificationPort **)(v3 + 40);
          io_registry_entry_t v16 = sub_100181E00(v3);
          if (v16)
          {
            objc_initWeak(&from, (id)v3);
            if (!*(void *)(v3 + 8))
            {
              id v17 = objc_alloc((Class)NFTimer);
              *(void *)long long buf = _NSConcreteStackBlock;
              *(void *)&uint8_t buf[8] = 3221225472;
              *(void *)&uint8_t buf[16] = sub_1001825A4;
              *(void *)&buf[24] = &unk_1003022A0;
              objc_copyWeak((id *)&buf[32], &from);
              id v70 = "listenForCameraNotificationFromPort:";
              id v18 = [v17 initWithCallback:buf queue:*(void *)(v3 + 32)];
              id v19 = *(void **)(v3 + 8);
              *(void *)(v3 + 8) = v18;

              objc_destroyWeak((id *)&buf[32]);
            }
            id v20 = objc_loadWeakRetained(&from);
            sub_100181E68(v20, v16, -536870608);

            id v21 = objc_loadWeakRetained(&from);
            __int16 v22 = IOServiceAddInterestNotification(v15, v16, "IOGeneralInterest", (IOServiceInterestCallback)sub_100181E68, v21, (io_object_t *)(v3 + 48));

            if (v22)
            {
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              unsigned int v23 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
              if (v23)
              {
                __int16 v24 = object_getClass((id)v3);
                if (class_isMetaClass(v24)) {
                  BOOL v25 = 43;
                }
                else {
                  BOOL v25 = 45;
                }
                __int16 v26 = object_getClassName((id)v3);
                int v27 = sel_getName("listenForCameraNotificationFromPort:");
                v23(3, "%c[%{public}s %{public}s]:%i Subscribe notification failed", v25, v26, v27, 430);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              id v28 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
              {
                int v29 = object_getClass((id)v3);
                if (class_isMetaClass(v29)) {
                  uint64_t v30 = 43;
                }
                else {
                  uint64_t v30 = 45;
                }
                uint64_t v31 = object_getClassName((id)v3);
                id v32 = sel_getName("listenForCameraNotificationFromPort:");
                *(_DWORD *)id v67 = 67109890;
                *(_DWORD *)&v67[4] = v30;
                *(_WORD *)uint64_t v68 = 2082;
                *(void *)&v68[2] = v31;
                *(_WORD *)&v68[10] = 2082;
                *(void *)&v68[12] = v32;
                *(_WORD *)&v68[20] = 1024;
                *(_DWORD *)&v68[22] = 430;
                _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Subscribe notification failed", v67, 0x22u);
              }
            }
            else
            {
              IOObjectRelease(v16);
            }
            objc_destroyWeak(&from);
          }
          else
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            id v52 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
            if (v52)
            {
              NSErrorUserInfoKey v53 = object_getClass((id)v3);
              if (class_isMetaClass(v53)) {
                id v54 = 43;
              }
              else {
                id v54 = 45;
              }
              NSErrorUserInfoKey v55 = object_getClassName((id)v3);
              int v56 = sel_getName("listenForCameraNotificationFromPort:");
              v52(3, "%c[%{public}s %{public}s]:%i Service not available", v54, v55, v56, 378);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            id v57 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
            {
              int v58 = object_getClass((id)v3);
              if (class_isMetaClass(v58)) {
                unsigned int v59 = 43;
              }
              else {
                unsigned int v59 = 45;
              }
              __int16 v60 = object_getClassName((id)v3);
              __int16 v61 = sel_getName("listenForCameraNotificationFromPort:");
              *(_DWORD *)long long buf = 67109890;
              *(_DWORD *)&uint8_t buf[4] = v59;
              *(_WORD *)&uint8_t buf[8] = 2082;
              *(void *)&buf[10] = v60;
              *(_WORD *)&buf[18] = 2082;
              *(void *)&buf[20] = v61;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = 378;
              _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Service not available", buf, 0x22u);
            }

            __int16 v62 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v62, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "-[NFCameraStateMonitor listenForCameraNotificationFromPort:]";
              _os_log_fault_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_FAULT, "[%{public}s] Cannot locate service; check hardware configuration",
                buf,
                0xCu);
            }
          }
          __int16 v63 = [sub_100181BD4() server];
          *(void *)long long buf = _NSConcreteStackBlock;
          *(void *)&uint8_t buf[8] = 3221225472;
          *(void *)&uint8_t buf[16] = sub_100181CB8;
          *(void *)&buf[24] = &unk_100305F60;
          objc_copyWeak((id *)&buf[32], &location);
          *(void *)id v67 = _NSConcreteStackBlock;
          *(void *)uint64_t v68 = 3221225472;
          *(void *)&v68[8] = sub_100182370;
          *(void *)&v68[16] = &unk_100305F88;
          objc_copyWeak((id *)&v68[24], &location);
          [v63 registerSpringBoardActionHandler:buf withIdentifierCallback:v67];

          id v64 = (id)v3;
          objc_sync_enter(v64);
          v64[16] = -1;
          objc_sync_exit(v64);

          objc_destroyWeak((id *)&v68[24]);
          objc_destroyWeak((id *)&buf[32]);
          goto LABEL_68;
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v43 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v43)
        {
          __int16 v44 = object_getClass((id)v3);
          if (class_isMetaClass(v44)) {
            int v45 = 43;
          }
          else {
            int v45 = 45;
          }
          __int16 v46 = object_getClassName((id)v3);
          id v47 = sel_getName("_registerForCameraNotifications");
          v43(3, "%c[%{public}s %{public}s]:%i Unable to get notify port", v45, v46, v47, 203);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        __int16 v38 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
        {
          __int16 v48 = object_getClass((id)v3);
          if (class_isMetaClass(v48)) {
            unsigned int v49 = 43;
          }
          else {
            unsigned int v49 = 45;
          }
          __int16 v50 = object_getClassName((id)v3);
          int v51 = sel_getName("_registerForCameraNotifications");
          *(_DWORD *)long long buf = 67109890;
          *(_DWORD *)&uint8_t buf[4] = v49;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = v50;
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v51;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = 203;
          _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unable to get notify port", buf, 0x22u);
        }
      }
      else
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v33 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v33)
        {
          long long v34 = object_getClass((id)v3);
          if (class_isMetaClass(v34)) {
            int v35 = 43;
          }
          else {
            int v35 = 45;
          }
          __int16 v36 = object_getClassName((id)v3);
          long long v37 = sel_getName("_registerForCameraNotifications");
          v33(6, "%c[%{public}s %{public}s]:%i No accessibility support", v35, v36, v37, 197);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        __int16 v38 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
        {
          int v39 = object_getClass((id)v3);
          if (class_isMetaClass(v39)) {
            __int16 v40 = 43;
          }
          else {
            __int16 v40 = 45;
          }
          int v41 = object_getClassName((id)v3);
          __int16 v42 = sel_getName("_registerForCameraNotifications");
          *(_DWORD *)long long buf = 67109890;
          *(_DWORD *)&uint8_t buf[4] = v40;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = v41;
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v42;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = 197;
          _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i No accessibility support", buf, 0x22u);
        }
      }

LABEL_68:
      objc_destroyWeak(&location);
    }
  }
}

void sub_100181874(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id a13, id location)
{
  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  objc_destroyWeak(&a13);
  _Unwind_Resume(a1);
}

void sub_1001818FC(os_unfair_lock_s *a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (a1)
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    v5[2] = sub_1001819B4;
    v5[3] = &unk_100301CB8;
    void v5[4] = a1;
    id v6 = v3;
    os_unfair_lock_lock(a1 + 13);
    sub_1001819B4((uint64_t)v5);
    os_unfair_lock_unlock(a1 + 13);
  }
}

void sub_1001819B4(uint64_t a1)
{
  id v2 = [*(id *)(*(void *)(a1 + 32) + 16) count];
  [*(id *)(*(void *)(a1 + 32) + 16) removeObjectForKey:*(void *)(a1 + 40)];
  sub_100180B9C(*(void *)(a1 + 32));
  id v3 = [*(id *)(*(void *)(a1 + 32) + 16) count];
  if (v2) {
    BOOL v4 = v3 == 0;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4)
  {
    uint64_t v5 = *(void *)(a1 + 32);
    if (v5)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        id v7 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass((id)v5);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName((id)v5);
        Name = sel_getName("_unregisterCameraNotifications");
        uint64_t v11 = 45;
        if (isMetaClass) {
          uint64_t v11 = 43;
        }
        v7(6, "%c[%{public}s %{public}s]:%i ", v11, ClassName, Name, 168);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v12 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v13 = object_getClass((id)v5);
        if (class_isMetaClass(v13)) {
          int v14 = 43;
        }
        else {
          int v14 = 45;
        }
        *(_DWORD *)long long buf = 67109890;
        int v21 = v14;
        __int16 v22 = 2082;
        unsigned int v23 = object_getClassName((id)v5);
        __int16 v24 = 2082;
        BOOL v25 = sel_getName("_unregisterCameraNotifications");
        __int16 v26 = 1024;
        int v27 = 168;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
      }

      int v15 = *(IONotificationPort **)(v5 + 40);
      if (v15)
      {
        IONotificationPortDestroy(v15);
        *(void *)(v5 + 40) = 0;
      }
      io_object_t v16 = *(_DWORD *)(v5 + 48);
      if (v16)
      {
        IOObjectRelease(v16);
        *(_DWORD *)(v5 + 48) = 0;
      }
      if (sub_100182AAC())
      {
        id v17 = [sub_100181BD4() server];
        [v17 removeActionHandler:*(void *)(v5 + 24)];
      }
      id v18 = *(void **)(v5 + 24);
      *(void *)(v5 + 24) = 0;

      *(unsigned char *)(v5 + 60) = 0;
    }
  }
}

id sub_100181BD4()
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x2050000000;
  id v0 = (void *)qword_1003474A0;
  uint64_t v7 = qword_1003474A0;
  if (!qword_1003474A0)
  {
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_100182BF0;
    v3[3] = &unk_100301E40;
    v3[4] = &v4;
    sub_100182BF0(v3);
    id v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);

  return v1;
}

void sub_100181CA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100181CB8(uint64_t a1, uint64_t a2)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v4 = WeakRetained;
  if (WeakRetained)
  {
    if (a2 == 10)
    {
      uint64_t v6 = (NSObject **)WeakRetained;
      objc_sync_enter(v6);
      *((unsigned char *)v6 + 60) = 0;
      objc_sync_exit(v6);

      dispatch_time_t v7 = dispatch_time(0, 100000001);
      uint64_t v8 = v6[4];
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100181DA8;
      block[3] = &unk_100301C68;
      block[4] = v6;
      dispatch_after(v7, v8, block);
    }
    else if (a2 == 9)
    {
      uint64_t v5 = WeakRetained;
      objc_sync_enter(v5);
      v5[60] = 1;
      objc_sync_exit(v5);
    }
  }
}

void sub_100181DA8(uint64_t a1)
{
  io_registry_entry_t v2 = sub_100181E00(*(void *)(a1 + 32));
  if (v2)
  {
    io_registry_entry_t v3 = v2;
    uint64_t v4 = *(void **)(a1 + 32);
    sub_100181E68(v4, v3, -536870608);
  }
}

uint64_t sub_100181E00(uint64_t result)
{
  if (result)
  {
    unint64_t v1 = 0;
    do
    {
      CFDictionaryRef v2 = IOServiceMatching((&off_100305FD0)[v1]);
      id result = IOServiceGetMatchingService(kIOMainPortDefault, v2);
      if (v1 > 1) {
        break;
      }
      ++v1;
    }
    while (!result);
  }
  return result;
}

void sub_100181E68(void *a1, io_registry_entry_t a2, int a3)
{
  uint64_t v6 = _os_activity_create((void *)&_mh_execute_header, "Camera state updated", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
  *(void *)state = 0;
  *(void *)&state[8] = 0;
  os_activity_scope_enter(v6, (os_activity_scope_state_t)state);
  os_activity_scope_leave((os_activity_scope_state_t)state);

  if (a3 == -536870608)
  {
    CFBooleanRef CFProperty = (CFBooleanRef)IORegistryEntryCreateCFProperty(a2, @"FrontCameraActive", kCFAllocatorDefault, 0);
    if (CFProperty)
    {
      CFTypeID TypeID = CFBooleanGetTypeID();
      CFTypeID v9 = CFGetTypeID(CFProperty);
      if (CFProperty == kCFBooleanTrue && TypeID == v9) {
        uint64_t v11 = 2;
      }
      else {
        uint64_t v11 = 0;
      }
      CFRelease(CFProperty);
    }
    else
    {
      uint64_t v11 = 0;
    }
    CFBooleanRef v12 = (CFBooleanRef)IORegistryEntryCreateCFProperty(a2, @"BackCameraActive", kCFAllocatorDefault, 0);
    if (v12)
    {
      CFTypeID v13 = CFBooleanGetTypeID();
      BOOL v15 = v13 == CFGetTypeID(v12) && v12 == kCFBooleanTrue;
      CFRelease(v12);
      uint64_t v11 = v11 | v15;
    }
    CFBooleanRef v16 = (CFBooleanRef)IORegistryEntryCreateCFProperty(a2, @"BackTeleCameraActive", kCFAllocatorDefault, 0);
    if (v16)
    {
      CFTypeID v17 = CFBooleanGetTypeID();
      CFTypeID v18 = CFGetTypeID(v16);
      if (v16 == kCFBooleanTrue && v17 == v18) {
        int v20 = 4;
      }
      else {
        int v20 = 0;
      }
      CFRelease(v16);
      uint64_t v11 = v20 | v11;
    }
    CFBooleanRef v21 = (CFBooleanRef)IORegistryEntryCreateCFProperty(a2, @"BackSuperWideCameraActive", kCFAllocatorDefault, 0);
    if (v21)
    {
      CFTypeID v22 = CFBooleanGetTypeID();
      CFTypeID v23 = CFGetTypeID(v21);
      if (v21 == kCFBooleanTrue && v22 == v23) {
        int v25 = 8;
      }
      else {
        int v25 = 0;
      }
      CFRelease(v21);
      uint64_t v11 = v25 | v11;
    }
    if (a1)
    {
      __int16 v26 = a1;
      objc_sync_enter(v26);
      int isa = (int)v26[7].isa;
      if (isa == v11 || BYTE4(v26[7].isa))
      {
        objc_sync_exit(v26);
      }
      else
      {
        LODWORD(v26[7].isa) = v11;
        [(objc_class *)v26[1].isa startTimer:0.100000001];
        if (LODWORD(v26[8].isa) == -1)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (Logger)
          {
            Class = object_getClass(v26);
            if (class_isMetaClass(Class)) {
              uint64_t v30 = 43;
            }
            else {
              uint64_t v30 = 45;
            }
            ClassName = object_getClassName(v26);
            Name = sel_getName("_updateCameraStateValue:");
            Logger(6, "%c[%{public}s %{public}s]:%i Initial state before debounce=%d", v30, ClassName, Name, 284, isa);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v33 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
          {
            long long v34 = object_getClass(v26);
            if (class_isMetaClass(v34)) {
              int v35 = 43;
            }
            else {
              int v35 = 45;
            }
            __int16 v36 = object_getClassName(v26);
            long long v37 = sel_getName("_updateCameraStateValue:");
            int v38 = isa;
            *(_DWORD *)state = 67110146;
            *(_DWORD *)&state[4] = v35;
            *(_WORD *)&state[8] = 2082;
            *(void *)&state[10] = v36;
            __int16 v50 = 2082;
            int v51 = v37;
            __int16 v52 = 1024;
            int v53 = 284;
            __int16 v54 = 1024;
            int v55 = isa;
            _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Initial state before debounce=%d", state, 0x28u);
          }
          else
          {
            int v38 = isa;
          }

          LODWORD(v26[8].isa) = v38;
        }
        objc_sync_exit(v26);

        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v39 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v39)
        {
          __int16 v40 = object_getClass(v26);
          if (class_isMetaClass(v40)) {
            uint64_t v41 = 43;
          }
          else {
            uint64_t v41 = 45;
          }
          __int16 v42 = object_getClassName(v26);
          id v43 = sel_getName("_updateCameraStateValue:");
          v39(6, "%c[%{public}s %{public}s]:%i current=%d, new=%d", v41, v42, v43, 291, isa, v11);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        __int16 v44 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEFAULT))
        {
          int v45 = object_getClass(v26);
          if (class_isMetaClass(v45)) {
            int v46 = 43;
          }
          else {
            int v46 = 45;
          }
          id v47 = object_getClassName(v26);
          __int16 v48 = sel_getName("_updateCameraStateValue:");
          *(_DWORD *)state = 67110402;
          *(_DWORD *)&state[4] = v46;
          *(_WORD *)&state[8] = 2082;
          *(void *)&state[10] = v47;
          __int16 v50 = 2082;
          int v51 = v48;
          __int16 v52 = 1024;
          int v53 = 291;
          __int16 v54 = 1024;
          int v55 = isa;
          __int16 v56 = 1024;
          int v57 = v11;
          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i current=%d, new=%d", state, 0x2Eu);
        }
        __int16 v26 = v44;
      }
    }
  }
}

void sub_100182348(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_100182370(uint64_t a1, void *a2)
{
  id v6 = a2;
  id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v5 = WeakRetained;
  if (WeakRetained) {
    objc_storeStrong(WeakRetained + 3, a2);
  }
}

BOOL sub_1001823D8(void *a1)
{
  if (!a1) {
    return 0;
  }
  unint64_t v1 = a1;
  objc_sync_enter(v1);
  BOOL v2 = v1[14] != 0;
  objc_sync_exit(v1);

  return v2;
}

BOOL sub_100182428(os_unfair_lock_s *a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    uint64_t v15 = 0;
    CFBooleanRef v16 = &v15;
    uint64_t v17 = 0x2020000000;
    char v18 = 0;
    uint64_t v5 = a1 + 13;
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    id v10 = sub_100182550;
    uint64_t v11 = &unk_100305FB0;
    int v14 = &v15;
    CFBooleanRef v12 = a1;
    id v13 = v3;
    id v6 = v9;
    os_unfair_lock_lock(v5);
    v10(v6);
    os_unfair_lock_unlock(v5);

    BOOL v7 = *((unsigned char *)v16 + 24) != 0;
    _Block_object_dispose(&v15, 8);
  }
  else
  {
    BOOL v7 = 0;
  }

  return v7;
}

void sub_100182538(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100182550(void *a1)
{
  BOOL v2 = [*(id *)(a1[4] + 16) objectForKey:a1[5]];
  *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = v2 != 0;
}

void sub_1001825A4(uint64_t a1)
{
  id WeakRetained = (unsigned __int8 *)objc_loadWeakRetained((id *)(a1 + 32));
  id v3 = WeakRetained;
  if (WeakRetained)
  {
    BOOL v4 = sub_1001823D8(WeakRetained);
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v3);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(v3);
      Name = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v11 = 45;
      if (isMetaClass) {
        uint64_t v11 = 43;
      }
      v6(6, "%c[%{public}s %{public}s]:%i state changed: status= %u, visualAlert=%d", v11, ClassName, Name, 397, v4, v3[60]);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    CFBooleanRef v12 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      id v13 = object_getClass(v3);
      if (class_isMetaClass(v13)) {
        int v14 = 43;
      }
      else {
        int v14 = 45;
      }
      uint64_t v15 = object_getClassName(v3);
      CFBooleanRef v16 = sel_getName(*(SEL *)(a1 + 40));
      int v17 = v3[60];
      *(_DWORD *)long long buf = 67110402;
      *(_DWORD *)&uint8_t buf[4] = v14;
      *(_WORD *)__int16 v50 = 2082;
      *(void *)&v50[2] = v15;
      __int16 v51 = 2082;
      __int16 v52 = v16;
      __int16 v53 = 1024;
      int v54 = 397;
      __int16 v55 = 1024;
      BOOL v56 = v4;
      __int16 v57 = 1024;
      int v58 = v17;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i state changed: status= %u, visualAlert=%d", buf, 0x2Eu);
    }

    if (v4) {
      char v18 = "com.apple.nfcd.camera.debounceTimer.on";
    }
    else {
      char v18 = "com.apple.nfcd.camera.debounceTimer.off";
    }
    id v19 = _os_activity_create((void *)&_mh_execute_header, v18, (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
    *(void *)long long buf = 0;
    *(void *)__int16 v50 = 0;
    os_activity_scope_enter(v19, (os_activity_scope_state_t)buf);
    os_activity_scope_leave((os_activity_scope_state_t)buf);

    int v20 = v3;
    objc_sync_enter(v20);
    int v21 = *((_DWORD *)v20 + 16);
    int v22 = *((_DWORD *)v20 + 14);
    *((_DWORD *)v20 + 16) = -1;
    objc_sync_exit(v20);

    if (!v20[60])
    {
      if (v21 == v22)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v23 = NFLogGetLogger();
        if (v23)
        {
          __int16 v24 = (void (*)(uint64_t, const char *, ...))v23;
          int v25 = object_getClass(v20);
          BOOL v26 = class_isMetaClass(v25);
          int v27 = object_getClassName(v20);
          __int16 v42 = sel_getName(*(SEL *)(a1 + 40));
          uint64_t v28 = 45;
          if (v26) {
            uint64_t v28 = 43;
          }
          v24(5, "%c[%{public}s %{public}s]:%i No state change after debounce", v28, v27, v42, 408);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v29 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v30 = object_getClass(v20);
          if (class_isMetaClass(v30)) {
            int v31 = 43;
          }
          else {
            int v31 = 45;
          }
          id v32 = object_getClassName(v20);
          id v33 = sel_getName(*(SEL *)(a1 + 40));
          *(_DWORD *)long long buf = 67109890;
          *(_DWORD *)&uint8_t buf[4] = v31;
          *(_WORD *)__int16 v50 = 2082;
          *(void *)&v50[2] = v32;
          __int16 v51 = 2082;
          __int16 v52 = v33;
          __int16 v53 = 1024;
          int v54 = 408;
          _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i No state change after debounce", buf, 0x22u);
        }
      }
      else
      {
        long long v34 = (os_unfair_lock_s *)(v20 + 52);
        v47[0] = _NSConcreteStackBlock;
        v47[1] = 3221225472;
        v47[2] = sub_100182A20;
        v47[3] = &unk_100302E68;
        void v47[4] = v20;
        os_unfair_lock_lock((os_unfair_lock_t)v20 + 13);
        int v35 = sub_100182A20((uint64_t)v47);
        os_unfair_lock_unlock(v34);
        long long v45 = 0u;
        long long v46 = 0u;
        long long v43 = 0u;
        long long v44 = 0u;
        id v36 = v35;
        id v37 = [v36 countByEnumeratingWithState:&v43 objects:v48 count:16];
        if (v37)
        {
          id v38 = v37;
          uint64_t v39 = *(void *)v44;
          do
          {
            for (i = 0; i != v38; i = (char *)i + 1)
            {
              if (*(void *)v44 != v39) {
                objc_enumerationMutation(v36);
              }
              uint64_t v41 = [v36 objectForKey:*(void *)(*((void *)&v43 + 1) + 8 * i)];
              [v41 didCameraStateChange:v4];
            }
            id v38 = [v36 countByEnumeratingWithState:&v43 objects:v48 count:16];
          }
          while (v38);
        }
      }
    }
  }
}

id sub_100182A20(uint64_t a1)
{
  id v1 = [*(id *)(*(void *)(a1 + 32) + 16) copy];

  return v1;
}

uint64_t sub_100182AAC()
{
  if (!qword_100347498) {
    qword_100347498 = _sl_dlopen();
  }
  return qword_100347498;
}

uint64_t sub_100182B7C()
{
  uint64_t result = _sl_dlopen();
  qword_100347498 = result;
  return result;
}

void sub_100182BF0(void *a1)
{
  if (!sub_100182AAC())
  {
    BOOL v2 = +[NSAssertionHandler currentHandler];
    a1 = +[NSString stringWithUTF8String:"void *AccessibilityUtilitiesLibrary(void)"];
    [v2 handleFailureInFunction:a1 file:@"NFCameraStateMonitor.m" lineNumber:21 description:@"%s"];

    __break(1u);
    free(v3);
  }
  *(void *)(*(void *)(a1[4] + 8) + 24) = objc_getClass("AXSpringBoardServer");
  if (*(void *)(*(void *)(a1[4] + 8) + 24))
  {
    qword_1003474A0 = *(void *)(*(void *)(a1[4] + 8) + 24);
  }
  else
  {
    BOOL v4 = +[NSAssertionHandler currentHandler];
    uint64_t v5 = +[NSString stringWithUTF8String:"Class getAXSpringBoardServerClass(void)_block_invoke"];
    [v4 handleFailureInFunction:v5 file:@"NFCameraStateMonitor.m" lineNumber:22 description:@"Unable to find class %s", "AXSpringBoardServer"];

    __break(1u);
  }
}

id *sub_100182D38(id *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    v8.receiver = a1;
    v8.super_class = (Class)NFAssertSuppressPresentmentIntentToDefaultApp;
    a1 = (id *)[super initWithRemoteAssertion:v5];
    if (a1)
    {
      *((unsigned char *)a1 + 16) = [v5 assertionType] == (id)6;
      objc_storeStrong(a1 + 3, a3);
    }
  }

  return a1;
}

id sub_100183960()
{
  self;
  if (qword_1003474C0 != -1) {
    dispatch_once(&qword_1003474C0, &stru_100306000);
  }
  id v0 = (void *)qword_1003474B8;

  return v0;
}

void sub_1001839B8(id a1)
{
  id v1 = objc_alloc_init(NFLPCDRandomGenerator);
  uint64_t v2 = qword_1003474B8;
  qword_1003474B8 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

void sub_100183A80(os_unfair_lock_s *a1, void *a2)
{
  id v3 = a2;
  BOOL v4 = v3;
  if (a1)
  {
    if ((unint64_t)[v3 length] <= 0xC && (unint64_t)objc_msgSend(v4, "length") > 5)
    {
      v16[0] = _NSConcreteStackBlock;
      v16[1] = 3221225472;
      v16[2] = sub_100183CE0;
      v16[3] = &unk_100301CB8;
      v16[4] = a1;
      id v17 = v4;
      os_unfair_lock_lock(a1 + 3);
      sub_100183CE0((uint64_t)v16);
      os_unfair_lock_unlock(a1 + 3);
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        id v6 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("setOverride:");
        id v15 = [v4 length];
        uint64_t v11 = 45;
        if (isMetaClass) {
          uint64_t v11 = 43;
        }
        v6(3, "%c[%{public}s %{public}s]:%i Invalid data size: %ld", v11, ClassName, Name, 57, v15);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      CFBooleanRef v12 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        id v13 = object_getClass(a1);
        if (class_isMetaClass(v13)) {
          int v14 = 43;
        }
        else {
          int v14 = 45;
        }
        *(_DWORD *)long long buf = 67110146;
        int v19 = v14;
        __int16 v20 = 2082;
        int v21 = object_getClassName(a1);
        __int16 v22 = 2082;
        uint64_t v23 = sel_getName("setOverride:");
        __int16 v24 = 1024;
        int v25 = 57;
        __int16 v26 = 2048;
        id v27 = [v4 length];
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid data size: %ld", buf, 0x2Cu);
      }
    }
  }
}

void sub_100183CE0(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    *(unsigned char *)(v2 + 8) = 1;
  }
  id v3 = [objc_alloc((Class)NSMutableData) initWithData:*(void *)(a1 + 40)];
  sub_100183D50(*(void *)(a1 + 32), v3);
}

void sub_100183D50(uint64_t a1, void *a2)
{
  if (a1) {
    objc_storeStrong((id *)(a1 + 24), a2);
  }
}

void sub_100183D60(os_unfair_lock_s *a1)
{
  if (a1)
  {
    id v1 = a1 + 3;
    v2[0] = _NSConcreteStackBlock;
    v2[1] = 3221225472;
    v2[2] = sub_100183DF4;
    v2[3] = &unk_100301C68;
    v2[4] = a1;
    os_unfair_lock_lock(a1 + 3);
    sub_100183DF4((uint64_t)v2);
    os_unfair_lock_unlock(v1);
  }
}

void sub_100183DF4(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (v1)
  {
    *(unsigned char *)(v1 + 8) = 0;
    uint64_t v2 = *(void *)(a1 + 32);
  }
  else
  {
    uint64_t v2 = 0;
  }
  sub_100183D50(v2, 0);
}

uint64_t sub_100183E14(os_unfair_lock_s *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v11 = 0;
  CFBooleanRef v12 = &v11;
  uint64_t v13 = 0x2020000000;
  uint64_t v14 = 0;
  uint64_t v1 = a1 + 3;
  v5[0] = _NSConcreteStackBlock;
  v5[1] = 3221225472;
  id v6 = sub_100183F14;
  BOOL v7 = &unk_100306028;
  CFTypeID v9 = &v11;
  id v10 = "value";
  objc_super v8 = a1;
  uint64_t v2 = v5;
  os_unfair_lock_lock(v1);
  v6((uint64_t)v2);
  os_unfair_lock_unlock(v1);

  uint64_t v3 = v12[3];
  _Block_object_dispose(&v11, 8);
  return v3;
}

void sub_100183EFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100183F14(uint64_t a1)
{
  uint64_t v2 = *(unsigned char **)(a1 + 32);
  if (v2)
  {
    uint64_t v3 = 24;
    if (!v2[8]) {
      uint64_t v3 = 16;
    }
    uint64_t v2 = *(unsigned char **)&v2[v3];
  }
  BOOL v4 = v2;
  id v5 = (unsigned __int8 *)[v4 bytes];
  if ((unint64_t)[v4 length] >= 9)
  {
    [v4 setLength:8];
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      BOOL v7 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v11 = 45;
      if (isMetaClass) {
        uint64_t v11 = 43;
      }
      v7(4, "%c[%{public}s %{public}s]:%i Dropping %zu MSBs", v11, ClassName, Name, 88, 8);
    }
    v5 += 8;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    CFBooleanRef v12 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      uint64_t v13 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v13)) {
        int v14 = 43;
      }
      else {
        int v14 = 45;
      }
      id v15 = object_getClassName(*(id *)(a1 + 32));
      CFBooleanRef v16 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)long long buf = 67110146;
      int v20 = v14;
      __int16 v21 = 2082;
      __int16 v22 = v15;
      __int16 v23 = 2082;
      __int16 v24 = v16;
      __int16 v25 = 1024;
      int v26 = 88;
      __int16 v27 = 2048;
      uint64_t v28 = 8;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Dropping %zu MSBs", buf, 0x2Cu);
    }
  }
  if ([v4 length])
  {
    unint64_t v17 = 0;
    do
    {
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) <<= 8;
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) |= *v5;
      ++v17;
    }
    while ((unint64_t)[v4 length] > v17);
  }
}

id sub_100184158(os_unfair_lock_s *a1)
{
  if (a1)
  {
    uint64_t v10 = 0;
    uint64_t v11 = &v10;
    uint64_t v12 = 0x3032000000;
    uint64_t v13 = sub_10000B8A8;
    int v14 = sub_100184290;
    id v15 = 0;
    uint64_t v1 = a1 + 3;
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    id v6 = sub_100184298;
    BOOL v7 = &unk_100301EB8;
    objc_super v8 = a1;
    CFTypeID v9 = &v10;
    uint64_t v2 = v5;
    os_unfair_lock_lock(v1);
    v6((uint64_t)v2);
    os_unfair_lock_unlock(v1);

    id v3 = (id)v11[5];
    _Block_object_dispose(&v10, 8);
  }
  else
  {
    id v3 = 0;
  }

  return v3;
}

void sub_100184278(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_100184290(uint64_t a1)
{
}

void sub_100184298(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    uint64_t v3 = 24;
    if (!*(unsigned char *)(v2 + 8)) {
      uint64_t v3 = 16;
    }
    BOOL v4 = *(void **)(v2 + v3);
  }
  else
  {
    BOOL v4 = 0;
  }
  id v5 = v4;
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), v4);
}

void sub_100184318(os_unfair_lock_s *a1)
{
  if (a1)
  {
    uint64_t v1 = a1 + 3;
    v2[0] = _NSConcreteStackBlock;
    v2[1] = 3221225472;
    v2[2] = sub_1001843AC;
    v2[3] = &unk_100301C68;
    v2[4] = a1;
    os_unfair_lock_lock(a1 + 3);
    sub_1001843AC((uint64_t)v2);
    os_unfair_lock_unlock(v1);
  }
}

void sub_1001843AC(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    if (*(unsigned char *)(v2 + 8)) {
      return;
    }
    uint64_t v3 = *(void **)(v2 + 16);
  }
  else
  {
    uint64_t v3 = 0;
  }
  id v4 = [v3 mutableBytes];
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5) {
    id v6 = *(void **)(v5 + 16);
  }
  else {
    id v6 = 0;
  }
  id v7 = [v6 length];

  arc4random_buf(v4, (size_t)v7);
}

void sub_100185214(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  va_start(va, a15);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v15 - 128), 8);
  _Unwind_Resume(a1);
}

void sub_10018524C(uint64_t a1)
{
}

void sub_100185254(uint64_t a1, void *a2, void *a3, int a4)
{
  id v7 = a2;
  id v8 = a3;
  CFTypeID v9 = v8;
  if (!v7 || v8)
  {
    id v10 = *(id *)(a1 + 32);

    id v7 = v10;
  }
  [*(id *)(a1 + 40) sendAPDU:v7];
  if (a4)
  {
    id v11 = [objc_alloc((Class)NSUserDefaults) initWithSuiteName:@"com.apple.stockholm"];
    if ([v11 integerForKey:@"DelayAfterStepUpOperation"]) {
      useconds_t v12 = 1000 * [v11 integerForKey:@"DelayAfterStepUpOperation"];
    }
    else {
      useconds_t v12 = 50000;
    }
    usleep(v12);
    if (v7) {
      BOOL v14 = v9 == 0;
    }
    else {
      BOOL v14 = 0;
    }
    if (v14) {
      uint64_t v15 = &__kCFBooleanFalse;
    }
    else {
      uint64_t v15 = &__kCFBooleanTrue;
    }
    [*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) setObject:v15 forKeyedSubscript:@"didError"];
    CFBooleanRef v16 = [[NFContactlessPaymentEndEvent alloc] initWithDictionary:*(void *)(*(void *)(*(void *)(a1 + 64) + 8) + 40)];
    uint64_t v17 = *(void *)(*(void *)(a1 + 72) + 8);
    char v18 = *(void **)(v17 + 40);
    *(void *)(v17 + 40) = v16;

    int v19 = [*(id *)(*(void *)(a1 + 48) + 48) identifier];
    if (v19)
    {
      id v20 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284178 length:9];
      __int16 v21 = [v20 NF_asHexString];

      if (!objc_msgSend(v19, "compare:options:range:", v21, 1, 0, objc_msgSend(v21, "length")))
      {
        id v32 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284181 length:2];
        __int16 v22 = [*(id *)(*(void *)(a1 + 48) + 48) identifier];
        __int16 v23 = [*(id *)(*(void *)(a1 + 48) + 48) packageIdentifier];
        __int16 v24 = [*(id *)(*(void *)(a1 + 48) + 48) moduleIdentifier];
        id v38 = v9;
        id v25 = +[AppletTranslator parseHCIEvent:v32 withApplet:v22 withPackage:v23 withModule:v24 withTransceiver:0 withError:&v38];
        id v26 = v38;

        CFTypeID v9 = v26;
      }
    }
    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
    uint64_t v27 = *(void *)(a1 + 48);
    uint64_t v28 = *(void **)(v27 + 32);
    if (v28)
    {
      sub_1000B4830((uint64_t)NFUnifiedAccessTransactionCALogger, v28, *(unsigned int *)(v27 + 40), (uint64_t)[v9 code]);
      int v29 = NFSharedSignpostLog();
      if (os_signpost_enabled(v29))
      {
        LOWORD(location) = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v29, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "AtlEvent", "AtlStepUpEventComplete", (uint8_t *)&location, 2u);
      }

      uint64_t v30 = *(void *)(a1 + 48);
      int v31 = *(void **)(v30 + 32);
      *(void *)(v30 + 32) = 0;
    }
  }
  else
  {
    objc_initWeak(&location, *(id *)(a1 + 48));
    uint64_t v13 = *(NSObject **)(*(void *)(a1 + 48) + 16);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_100185634;
    block[3] = &unk_100306050;
    objc_copyWeak(&v36, &location);
    id v35 = *(id *)(a1 + 56);
    id v34 = *(id *)(a1 + 40);
    dispatch_async(v13, block);

    objc_destroyWeak(&v36);
    objc_destroyWeak(&location);
  }
}

void sub_100185634(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 48));
  id v3 = WeakRetained;
  if (WeakRetained) {
    [WeakRetained hceReadWithHandle:*(void *)(a1 + 32) completion:*(void *)(a1 + 40)];
  }
  else {
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

id sub_10018570C()
{
  self;
  if (qword_1003474D0 != -1) {
    dispatch_once(&qword_1003474D0, &stru_100306098);
  }
  id v0 = (void *)qword_1003474C8;

  return v0;
}

void sub_100185764(id a1)
{
  uint64_t v1 = +[NSXPCInterface interfaceWithProtocol:&OBJC_PROTOCOL___NFHardwareManagerAccessoryInterface];
  uint64_t v2 = (void *)qword_1003474C8;
  qword_1003474C8 = v1;

  id v3 = (void *)qword_1003474C8;
  id v4 = sub_10017EF50();
  [v3 setInterface:v4 forSelector:"queueReaderSession:callback:" argumentIndex:0 ofReply:0];

  uint64_t v5 = (void *)qword_1003474C8;
  id v6 = sub_10017EF18();
  [v5 setInterface:v6 forSelector:"queueReaderSession:callback:" argumentIndex:0 ofReply:1];

  id v7 = objc_alloc((Class)NSSet);
  uint64_t v8 = objc_opt_class();
  id v9 = [v7 initWithObjects:v8, objc_opt_class(), 0];
  [(id)qword_1003474C8 setClasses:v9 forSelector:"getLastDetectedTags:" argumentIndex:0 ofReply:1];
  [(id)qword_1003474C8 setClasses:v9 forSelector:"getMultiTagState:" argumentIndex:0 ofReply:1];
}

id sub_1001858B4()
{
  self;
  if (qword_1003474E0 != -1) {
    dispatch_once(&qword_1003474E0, &stru_1003060B8);
  }
  id v0 = (void *)qword_1003474D8;

  return v0;
}

void sub_10018590C(id a1)
{
  uint64_t v1 = +[NSXPCInterface interfaceWithProtocol:&OBJC_PROTOCOL___NFHardwareManagerAccessoryCallbacks];
  uint64_t v2 = qword_1003474D8;
  qword_1003474D8 = v1;

  _objc_release_x1(v1, v2);
}

uint64_t sub_100185954(void *a1, void *a2, int a3, void *a4)
{
  id v5 = a2;
  id v550 = a1;
  v519 = v5;
  if (!a1)
  {
    uint64_t v33 = 0;
    goto LABEL_496;
  }
  id v6 = v5;
  id v523 = (id)objc_opt_new();
  v521 = [v6 objectForKeyedSubscript:@"version"];
  if (v521)
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass()) {
      unsigned int v516 = [v521 unsignedIntValue];
    }
    else {
      unsigned int v516 = 2;
    }
  }
  else
  {
    unsigned int v516 = 2;
  }
  id v7 = [a1 serialNumber];

  if (!v7)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v25 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(v550);
      Name = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
      uint64_t v29 = 45;
      if (isMetaClass) {
        uint64_t v29 = 43;
      }
      v25(3, "%c[%{public}s %{public}s]:%i Failed to get serial number failing remote admin state", v29, ClassName, Name, 103);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v30 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      int v31 = object_getClass(v550);
      if (class_isMetaClass(v31)) {
        int v32 = 43;
      }
      else {
        int v32 = 45;
      }
      *(_DWORD *)long long buf = 67109890;
      *(_DWORD *)&uint8_t buf[4] = v32;
      *(_WORD *)v584 = 2082;
      *(void *)&v584[2] = object_getClassName(v550);
      *(_WORD *)&v584[10] = 2082;
      *(void *)&v584[12] = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
      *(_WORD *)&v584[20] = 1024;
      *(_DWORD *)&v584[22] = 103;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get serial number failing remote admin state", buf, 0x22u);
    }
    uint64_t v33 = 13;
    goto LABEL_495;
  }
  [v523 setObject:@"JCOP" forKey:@"secureElementType"];
  uint64_t v8 = [a1 serialNumber];
  [v523 setObject:v8 forKey:@"SEID"];

  id v9 = [a1 rsaCertificate];
  id v10 = a1;
  if (v9)
  {
    id v11 = [a1 eccCertificate];

    id v10 = v550;
    if (v11)
    {
      useconds_t v12 = objc_opt_new();
      uint64_t v13 = [v550 rsaCertificate];
      [v12 setObject:v13 forKey:@"RSA"];

      BOOL v14 = [v550 eccCertificate];
      [v12 setObject:v14 forKey:@"ECDSA"];

      if (v516 <= 3)
      {
        uint64_t v15 = [v550 eccCertificate];
        [v12 setObject:v15 forKey:@"ECC"];

        CFBooleanRef v16 = [v550 eckaCertificate];

        if (v16)
        {
          uint64_t v17 = [v550 eckaCertificate];
          [v12 setObject:v17 forKey:@"ECKA"];
        }
      }
      [v523 setObject:v12 forKey:@"casdCertificate"];

      id v10 = v550;
    }
  }
  char v18 = objc_opt_new();
  id v19 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284184 length:8];
  unsigned __int8 v20 = [v10 select:v19 error:0];

  if (v20)
  {
    __int16 v21 = [v10 getData:193];
    __int16 v22 = v21;
    if (v21)
    {
      __int16 v23 = [v21 NF_asHexString];
      [v18 setObject:v23 forKey:@"isdSequenceCounter"];
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v42 = NFLogGetLogger();
      if (v42)
      {
        long long v43 = (void (*)(uint64_t, const char *, ...))v42;
        long long v44 = object_getClass(v550);
        BOOL v45 = class_isMetaClass(v44);
        long long v46 = object_getClassName(v550);
        v508 = sel_getName("_getISDInfo");
        uint64_t v47 = 45;
        if (v45) {
          uint64_t v47 = 43;
        }
        v43(3, "%c[%{public}s %{public}s]:%i Failed to get sequence counter", v47, v46, v508, 300);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v48 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
      {
        unsigned int v49 = object_getClass(v550);
        if (class_isMetaClass(v49)) {
          int v50 = 43;
        }
        else {
          int v50 = 45;
        }
        *(_DWORD *)long long buf = 67109890;
        *(_DWORD *)&uint8_t buf[4] = v50;
        *(_WORD *)v584 = 2082;
        *(void *)&v584[2] = object_getClassName(v550);
        *(_WORD *)&v584[10] = 2082;
        *(void *)&v584[12] = sel_getName("_getISDInfo");
        *(_WORD *)&v584[20] = 1024;
        *(_DWORD *)&v584[22] = 300;
        _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get sequence counter", buf, 0x22u);
      }
    }
    __int16 v51 = [v550 getData:254 subtag:57120];
    if (v51)
    {
      id v52 = [objc_alloc((Class)NSString) initWithData:v51 encoding:4];
      if (v52)
      {
        [v18 setObject:v52 forKey:@"kPlatformId"];
LABEL_72:
        long long v73 = [v550 getData:254 subtag:57137];
        long long v74 = v73;
        if (v73 && (unint64_t)[v73 length] > 1)
        {
          [v74 subdataWithRange:0, 2];
          id v85 = (id)objc_claimAutoreleasedReturnValue();
          id v86 = v52;
          id v87 = v85;
          unsigned int v88 = *(unsigned __int16 *)[v87 bytes];
          unsigned int v89 = [v86 isEqualToString:@"N5E0000000990000"];
          if (bswap32(v88) >> 16 > 0xB3) {
            unsigned int v90 = v89;
          }
          else {
            unsigned int v90 = 0;
          }
          if (v90 == 1)
          {
            __int16 v91 = +[NSData NF_dataWithHexString:@"00B3"];
          }
          else
          {
            __int16 v91 = v87;
          }
          __int16 v80 = v91;

          uint64_t v92 = [v80 NF_asHexString];
          [v18 setObject:v92 forKey:@"jsblSequenceCounter"];
        }
        else
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          long long v75 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v75)
          {
            __int16 v76 = object_getClass(v550);
            if (class_isMetaClass(v76)) {
              uint64_t v77 = 43;
            }
            else {
              uint64_t v77 = 45;
            }
            __int16 v78 = object_getClassName(v550);
            int v79 = sel_getName("_getISDInfo");
            v75(3, "%c[%{public}s %{public}s]:%i Failed to get update info", v77, v78, v79, 324);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          __int16 v80 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
          {
            id v81 = object_getClass(v550);
            if (class_isMetaClass(v81)) {
              int v82 = 43;
            }
            else {
              int v82 = 45;
            }
            int v83 = object_getClassName(v550);
            __int16 v84 = sel_getName("_getISDInfo");
            *(_DWORD *)long long buf = 67109890;
            *(_DWORD *)&uint8_t buf[4] = v82;
            *(_WORD *)v584 = 2082;
            *(void *)&v584[2] = v83;
            *(_WORD *)&v584[10] = 2082;
            *(void *)&v584[12] = v84;
            *(_WORD *)&v584[20] = 1024;
            *(_DWORD *)&v584[22] = 324;
            _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get update info", buf, 0x22u);
          }
        }

        v518 = v18;
        goto LABEL_92;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v53 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v53)
      {
        int v54 = object_getClass(v550);
        if (class_isMetaClass(v54)) {
          uint64_t v55 = 43;
        }
        else {
          uint64_t v55 = 45;
        }
        BOOL v56 = object_getClassName(v550);
        __int16 v57 = sel_getName("_getISDInfo");
        v53(3, "%c[%{public}s %{public}s]:%i Fail to encode platform ID into string", v55, v56, v57, 310);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v58 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v58, OS_LOG_TYPE_ERROR))
      {
        unsigned int v59 = object_getClass(v550);
        if (class_isMetaClass(v59)) {
          int v60 = 43;
        }
        else {
          int v60 = 45;
        }
        __int16 v61 = object_getClassName(v550);
        __int16 v62 = sel_getName("_getISDInfo");
        *(_DWORD *)long long buf = 67109890;
        *(_DWORD *)&uint8_t buf[4] = v60;
        *(_WORD *)v584 = 2082;
        *(void *)&v584[2] = v61;
        *(_WORD *)&v584[10] = 2082;
        *(void *)&v584[12] = v62;
        *(_WORD *)&v584[20] = 1024;
        *(_DWORD *)&v584[22] = 310;
        _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Fail to encode platform ID into string", buf, 0x22u);
      }
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v63 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v63)
    {
      id v64 = object_getClass(v550);
      if (class_isMetaClass(v64)) {
        uint64_t v65 = 43;
      }
      else {
        uint64_t v65 = 45;
      }
      uint64_t v66 = object_getClassName(v550);
      id v67 = sel_getName("_getISDInfo");
      v63(3, "%c[%{public}s %{public}s]:%i Failed to get platform ID", v65, v66, v67, 318);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v68 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
    {
      __int16 v69 = object_getClass(v550);
      if (class_isMetaClass(v69)) {
        int v70 = 43;
      }
      else {
        int v70 = 45;
      }
      id v71 = object_getClassName(v550);
      long long v72 = sel_getName("_getISDInfo");
      *(_DWORD *)long long buf = 67109890;
      *(_DWORD *)&uint8_t buf[4] = v70;
      *(_WORD *)v584 = 2082;
      *(void *)&v584[2] = v71;
      *(_WORD *)&v584[10] = 2082;
      *(void *)&v584[12] = v72;
      *(_WORD *)&v584[20] = 1024;
      *(_DWORD *)&v584[22] = 318;
      _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get platform ID", buf, 0x22u);
    }

    id v52 = 0;
    goto LABEL_72;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v34 = NFLogGetLogger();
  if (v34)
  {
    id v35 = (void (*)(uint64_t, const char *, ...))v34;
    id v36 = object_getClass(v10);
    BOOL v37 = class_isMetaClass(v36);
    id v38 = object_getClassName(v10);
    v507 = sel_getName("_getISDInfo");
    uint64_t v39 = 45;
    if (v37) {
      uint64_t v39 = 43;
    }
    v35(3, "%c[%{public}s %{public}s]:%i Failed to select ISD", v39, v38, v507, 290);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  __int16 v22 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
  {
    __int16 v40 = object_getClass(v550);
    if (class_isMetaClass(v40)) {
      int v41 = 43;
    }
    else {
      int v41 = 45;
    }
    *(_DWORD *)long long buf = 67109890;
    *(_DWORD *)&uint8_t buf[4] = v41;
    *(_WORD *)v584 = 2082;
    *(void *)&v584[2] = object_getClassName(v550);
    *(_WORD *)&v584[10] = 2082;
    *(void *)&v584[12] = sel_getName("_getISDInfo");
    *(_WORD *)&v584[20] = 1024;
    *(_DWORD *)&v584[22] = 290;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select ISD", buf, 0x22u);
  }
  v518 = 0;
LABEL_92:

  if (v518) {
    [v523 addEntriesFromDictionary:];
  }
  __int16 v93 = objc_opt_new();
  id v94 = [objc_alloc((Class)NSData) initWithBytes:&unk_10028418C length:12];
  BOOL v95 = [v550 selectByName:v94 error:0];

  if ([v95 status] == 26277)
  {
    [v93 setObject:&__kCFBooleanTrue forKey:@"restrictedMode"];
LABEL_120:
    id v517 = v93;
    goto LABEL_121;
  }
  if ([v95 status] == 36864)
  {
    LODWORD(v580) = 0;
    memset(v579, 0, sizeof(v579));
    if (sub_1000A3344(v550, (uint64_t)v579))
    {
      *(void *)&long long v560 = @"persistentMemory";
      uint64_t v96 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)v579];
      *(void *)long long buf = v96;
      *((void *)&v560 + 1) = @"clearOnResetMemory";
      v546 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)&v579[4]];
      *(void *)v584 = v546;
      *(void *)&long long v561 = @"clearOnDeselectMemory";
      v543 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)&v579[8]];
      *(void *)&v584[8] = v543;
      *((void *)&v561 + 1) = @"availableIndicies";
      v539 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)&v579[12]];
      *(void *)&v584[16] = v539;
      *(void *)&long long v562 = @"totalNumberOfIndicies";
      os_log_t logc = +[NSNumber numberWithUnsignedInt:*(unsigned int *)&v579[16]];
      *(void *)&v584[24] = logc;
      *((void *)&v562 + 1) = @"availablePersistent";
      os_log_t oslogb = +[NSNumber numberWithUnsignedInt:*(unsigned int *)&v579[20]];
      os_log_t v585 = oslogb;
      *(void *)&long long v563 = @"availableTransienteUICC";
      v529 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)&v579[24]];
      id v586 = v529;
      *((void *)&v563 + 1) = @"reservedClearOnDelect";
      NSErrorUserInfoKey v97 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)&v579[28]];
      v587 = v97;
      CFStringRef v564 = @"maximumMappedClearOnDeselect";
      id v98 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)&v579[32]];
      v588 = v98;
      CFStringRef v565 = @"reservedTransientOSUpdate";
      int v99 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)&v579[36]];
      v589 = v99;
      CFStringRef v566 = @"reservedPersistentOSUpdate";
      __int16 v100 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)&v579[40]];
      v590 = v100;
      CFStringRef v567 = @"transientCommonPool";
      id v101 = +[NSNumber numberWithUnsignedInt:*(unsigned int *)&v579[44]];
      v591 = v101;
      CFStringRef v568 = @"persistentCommonPool";
      id v102 = +[NSNumber numberWithUnsignedInt:v580];
      v592 = v102;
      id v103 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v560 count:13];
      [v93 setObject:v103 forKey:@"availableMemory"];
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v117 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v117)
      {
        __int16 v118 = object_getClass(v550);
        if (class_isMetaClass(v118)) {
          uint64_t v119 = 43;
        }
        else {
          uint64_t v119 = 45;
        }
        __int16 v120 = object_getClassName(v550);
        id v121 = sel_getName("_getCASDInfo");
        v117(4, "%c[%{public}s %{public}s]:%i Failed to get memory info", v119, v120, v121, 415);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v96 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
      {
        __int16 v122 = object_getClass(v550);
        if (class_isMetaClass(v122)) {
          int v123 = 43;
        }
        else {
          int v123 = 45;
        }
        __int16 v124 = object_getClassName(v550);
        int v125 = sel_getName("_getCASDInfo");
        *(_DWORD *)long long buf = 67109890;
        *(_DWORD *)&uint8_t buf[4] = v123;
        *(_WORD *)v584 = 2082;
        *(void *)&v584[2] = v124;
        *(_WORD *)&v584[10] = 2082;
        *(void *)&v584[12] = v125;
        *(_WORD *)&v584[20] = 1024;
        *(_DWORD *)&v584[22] = 415;
        _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get memory info", buf, 0x22u);
      }
    }

    goto LABEL_120;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v104 = NFLogGetLogger();
  if (v104)
  {
    uint64_t v105 = (void (*)(uint64_t, const char *, ...))v104;
    BOOL v106 = object_getClass(v550);
    BOOL v107 = class_isMetaClass(v106);
    NSErrorUserInfoKey v108 = object_getClassName(v550);
    int v109 = sel_getName("_getCASDInfo");
    uint64_t v512 = [v95 status];
    uint64_t v110 = 45;
    if (v107) {
      uint64_t v110 = 43;
    }
    v105(3, "%c[%{public}s %{public}s]:%i Failed to select CASD: 0x%04x", v110, v108, v109, 408, v512);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v111 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v111, OS_LOG_TYPE_ERROR))
  {
    NSErrorUserInfoKey v112 = object_getClass(v550);
    if (class_isMetaClass(v112)) {
      int v113 = 43;
    }
    else {
      int v113 = 45;
    }
    NSErrorUserInfoKey v114 = object_getClassName(v550);
    uint64_t v115 = sel_getName("_getCASDInfo");
    unsigned int v116 = [v95 status];
    *(_DWORD *)long long buf = 67110146;
    *(_DWORD *)&uint8_t buf[4] = v113;
    *(_WORD *)v584 = 2082;
    *(void *)&v584[2] = v114;
    *(_WORD *)&v584[10] = 2082;
    *(void *)&v584[12] = v115;
    *(_WORD *)&v584[20] = 1024;
    *(_DWORD *)&v584[22] = 408;
    *(_WORD *)&v584[26] = 1024;
    *(_DWORD *)&v584[28] = v116;
    _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select CASD: 0x%04x", buf, 0x28u);
  }

  id v517 = 0;
LABEL_121:

  if (v517) {
    [v523 addEntriesFromDictionary:];
  }
  v520 = [v523 valueForKey:@"restrictedMode"];

  id v126 = [v550 handle];
  NSErrorUserInfoKey v127 = [v126 info];
  uint64_t v128 = (uint64_t)[v127 deviceType];

  if (v128 > 99)
  {
    id v129 = v550;
    if (v128 > 199)
    {
      if (v128 == 200)
      {
        uint64_t v130 = 7;
      }
      else
      {
        if (v128 != 210) {
          goto LABEL_186;
        }
        uint64_t v130 = 8;
      }
    }
    else if (v128 == 100)
    {
      uint64_t v130 = 6;
    }
    else
    {
      if (v128 != 115) {
        goto LABEL_186;
      }
      uint64_t v130 = 5;
    }
  }
  else
  {
    id v129 = v550;
    if (v128 > 54)
    {
      if (v128 == 55)
      {
        uint64_t v130 = 10;
      }
      else
      {
        if (v128 != 56) {
          goto LABEL_186;
        }
        uint64_t v130 = 13;
      }
    }
    else
    {
      if (v128 != 44)
      {
        if (v128 == 54)
        {
          uint64_t v130 = 11;
          goto LABEL_142;
        }
LABEL_186:
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v193 = NFLogGetLogger();
        if (v193)
        {
          int v194 = (void (*)(uint64_t, const char *, ...))v193;
          int v195 = object_getClass(v129);
          BOOL v196 = class_isMetaClass(v195);
          long long v197 = object_getClassName(v129);
          v510 = sel_getName("_getTSMHardwareType");
          uint64_t v198 = 45;
          if (v196) {
            uint64_t v198 = 43;
          }
          v194(3, "%c[%{public}s %{public}s]:%i Critical error : unsupported hardware!", v198, v197, v510, 83);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v199 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v199, OS_LOG_TYPE_ERROR))
        {
          id v200 = object_getClass(v550);
          if (class_isMetaClass(v200)) {
            int v201 = 43;
          }
          else {
            int v201 = 45;
          }
          long long v202 = object_getClassName(v550);
          uint64_t v203 = sel_getName("_getTSMHardwareType");
          *(_DWORD *)long long buf = 67109890;
          *(_DWORD *)&uint8_t buf[4] = v201;
          *(_WORD *)v584 = 2082;
          *(void *)&v584[2] = v202;
          *(_WORD *)&v584[10] = 2082;
          *(void *)&v584[12] = v203;
          *(_WORD *)&v584[20] = 1024;
          *(_DWORD *)&v584[22] = 83;
          _os_log_impl((void *)&_mh_execute_header, v199, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Critical error : unsupported hardware!", buf, 0x22u);
        }

        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v204 = NFLogGetLogger();
        if (v204)
        {
          uint64_t v205 = (void (*)(uint64_t, const char *, ...))v204;
          long long v206 = object_getClass(v550);
          BOOL v207 = class_isMetaClass(v206);
          uint64_t v208 = object_getClassName(v550);
          v511 = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
          uint64_t v209 = 45;
          if (v207) {
            uint64_t v209 = 43;
          }
          v205(3, "%c[%{public}s %{public}s]:%i Unknown hardware platform", v209, v208, v511, 143);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v210 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v210, OS_LOG_TYPE_ERROR))
        {
          int v211 = object_getClass(v550);
          if (class_isMetaClass(v211)) {
            int v212 = 43;
          }
          else {
            int v212 = 45;
          }
          int v213 = object_getClassName(v550);
          __int16 v214 = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
          *(_DWORD *)long long buf = 67109890;
          *(_DWORD *)&uint8_t buf[4] = v212;
          *(_WORD *)v584 = 2082;
          *(void *)&v584[2] = v213;
          *(_WORD *)&v584[10] = 2082;
          *(void *)&v584[12] = v214;
          *(_WORD *)&v584[20] = 1024;
          *(_DWORD *)&v584[22] = 143;
          _os_log_impl((void *)&_mh_execute_header, v210, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unknown hardware platform", buf, 0x22u);
        }

        int v215 = 0;
        uint64_t v33 = 6;
        goto LABEL_494;
      }
      uint64_t v130 = 9;
    }
  }
LABEL_142:
  __int16 v131 = +[NSNumber numberWithUnsignedInteger:v130];
  [v523 setObject:v131 forKey:@"hardwareType"];

  if (!v520)
  {
    if (sub_100189DC8((BOOL)v550))
    {
      v540 = sub_100189EE8(v550, a3);
      id v136 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284292 length:8];
      *(void *)&long long v560 = v136;
      id v137 = [objc_alloc((Class)NSData) initWithBytes:&unk_10028429A length:9];
      *((void *)&v560 + 1) = v137;
      id v138 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002842A3 length:12];
      *(void *)&long long v561 = v138;
      id v139 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002842AF length:14];
      *((void *)&v561 + 1) = v139;
      id v140 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002842BD length:8];
      *(void *)&long long v562 = v140;
      id v141 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002842C5 length:10];
      *((void *)&v562 + 1) = v141;
      id v142 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002842CF length:12];
      *(void *)&long long v563 = v142;
      NSErrorUserInfoKey v143 = +[NSArray arrayWithObjects:&v560 count:7];
      int v144 = +[NSMutableArray arrayWithArray:v143];

      if (NFIsInternalBuild())
      {
        id v145 = [objc_alloc((Class)NSUserDefaults) initWithSuiteName:@"nfcd"];
        unsigned int v146 = [v145 BOOLForKey:@"UnhideFTA"];

        if (v146)
        {
          id v147 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002842AF length:14];
          [v144 removeObject:v147];
        }
      }
      id v148 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002842DB length:13];
      *(void *)v571 = v148;
      id v149 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002842E8 length:12];
      *(void *)v572 = v149;
      id v150 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002842F4 length:15];
      *(void *)&v572[8] = v150;
      id v151 = +[NSArray arrayWithObjects:v571 count:3];

      *(void *)v579 = 0;
      *(void *)&v579[8] = v579;
      *(void *)&v579[16] = 0x3032000000;
      *(void *)&v579[24] = sub_10000B8C8;
      *(void *)&v579[32] = sub_10018D148;
      *(void *)&v579[40] = objc_opt_new();
      *(void *)long long buf = _NSConcreteStackBlock;
      *(void *)v584 = 3221225472;
      *(void *)&v584[8] = sub_10018E97C;
      *(void *)&v584[16] = &unk_100306158;
      *(void *)&v584[24] = v550;
      v588 = "getStatusProprietaryPackagesWithFiltering:";
      LOBYTE(v589) = a3;
      id v152 = v151;
      os_log_t v585 = v152;
      id v153 = v144;
      id v586 = v153;
      v587 = v579;
      BOOL v154 = sub_10018DC58(v550, 16, (uint64_t)&unk_10028428E, 4uLL, buf);
      if (v154)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v155 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v155)
        {
          id v156 = object_getClass(v550);
          if (class_isMetaClass(v156)) {
            uint64_t v157 = 43;
          }
          else {
            uint64_t v157 = 45;
          }
          id v158 = object_getClassName(v550);
          id v159 = sel_getName("getStatusProprietaryPackagesWithFiltering:");
          v155(3, "%c[%{public}s %{public}s]:%i Failed to call proprietary get status %{public}@", v157, v158, v159, 1084, v154);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        NSErrorUserInfoKey v160 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v160, OS_LOG_TYPE_ERROR))
        {
          int v161 = object_getClass(v550);
          if (class_isMetaClass(v161)) {
            int v162 = 43;
          }
          else {
            int v162 = 45;
          }
          int v163 = object_getClassName(v550);
          __int16 v164 = sel_getName("getStatusProprietaryPackagesWithFiltering:");
          *(_DWORD *)md = 67110146;
          *(_DWORD *)&md[4] = v162;
          *(_WORD *)&md[8] = 2082;
          *(void *)&md[10] = v163;
          *(_WORD *)&md[18] = 2082;
          *(void *)&md[20] = v164;
          *(_WORD *)&md[28] = 1024;
          *(_DWORD *)&md[30] = 1084;
          *(_WORD *)&md[34] = 2114;
          *(void *)&md[36] = v154;
          _os_log_impl((void *)&_mh_execute_header, v160, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to call proprietary get status %{public}@", md, 0x2Cu);
        }

        int v165 = 0;
      }
      else
      {
        v582[0] = @"packages";
        *(void *)md = *(void *)(*(void *)&v579[8] + 40);
        int v165 = +[NSDictionary dictionaryWithObjects:md forKeys:v582 count:1];
      }

      _Block_object_dispose(v579, 8);
      os_log_type_t v304 = [v540 objectForKeyedSubscript:@"orphanedSSDs"];
      v553[0] = _NSConcreteStackBlock;
      v553[1] = 3221225472;
      v553[2] = sub_10018A96C;
      v553[3] = &unk_1003060E0;
      id v305 = v165;
      id v554 = v305;
      uint64_t v306 = +[NSPredicate predicateWithBlock:v553];
      [v304 filterUsingPredicate:v306];

      if (v540) {
        [v523 addEntriesFromDictionary:v540];
      }
      if (v305) {
        [v523 addEntriesFromDictionary:v305];
      }

      goto LABEL_309;
    }
    id v555 = 0;
    id v177 = [v550 selectCRSWithError:&v555];
    id v178 = v555;
    if (v178)
    {
      id v179 = v178;
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v180 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v180)
      {
        id v181 = object_getClass(v550);
        if (class_isMetaClass(v181)) {
          uint64_t v182 = 43;
        }
        else {
          uint64_t v182 = 45;
        }
        id v183 = object_getClassName(v550);
        uint64_t v184 = sel_getName("_getCRSInfoWithFiltering:");
        v180(3, "%c[%{public}s %{public}s]:%i Failed to select CRS: %{public}@", v182, v183, v184, 443, v179);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v185 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v185, OS_LOG_TYPE_ERROR))
      {
        int v186 = object_getClass(v550);
        if (class_isMetaClass(v186)) {
          int v187 = 43;
        }
        else {
          int v187 = 45;
        }
        NSErrorUserInfoKey v188 = object_getClassName(v550);
        id v189 = sel_getName("_getCRSInfoWithFiltering:");
        *(_DWORD *)v571 = 67110146;
        *(_DWORD *)&v571[4] = v187;
        *(_WORD *)v572 = 2082;
        *(void *)&v572[2] = v188;
        *(_WORD *)&v572[10] = 2082;
        *(void *)&v572[12] = v189;
        __int16 v573 = 1024;
        int v574 = 443;
        __int16 v575 = 2114;
        v576 = v179;
        _os_log_impl((void *)&_mh_execute_header, v185, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select CRS: %{public}@", v571, 0x2Cu);
      }

      BOOL v190 = [v179 code] == (id)24;
      if (!v190)
      {
        v540 = 0;
        uint64_t v192 = v550;
LABEL_299:
        v316 = objc_opt_new();
        id v317 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002841FE length:12];
        uint64_t v318 = [v192 selectByName:v317 error:0];

        if ([v318 status] == 36864)
        {
          id v319 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002841FE length:12];
          v320 = [v319 NF_asHexString];
          [v316 addObject:v320];
        }
        id v321 = [objc_alloc((Class)NSData) initWithBytes:&unk_10028420A length:12];
        uint64_t v322 = [v550 selectByName:v321 error:0];

        if ([v322 status] == 36864)
        {
          id v323 = [objc_alloc((Class)NSData) initWithBytes:&unk_10028420A length:12];
          v324 = [v323 NF_asHexString];
          [v316 addObject:v324];
        }
        if ([v316 count])
        {
          *(void *)&long long v560 = @"VASDs";
          *(void *)long long buf = v316;
          int v325 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v560 count:1];
        }
        else
        {
          int v325 = 0;
        }

        if (v325) {
          [v523 addEntriesFromDictionary:v325];
        }

LABEL_309:
        if (v516 >= 4)
        {
          v326 = [v519 objectForKeyedSubscript:@"whitelistedInstances"];
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0 && [v326 count])
          {
            v327 = [v326 objectAtIndexedSubscript:0];
            if (v327)
            {
              v328 = [v326 objectAtIndexedSubscript:0];
            }
            else
            {
              v328 = 0;
            }

            objc_opt_class();
            if (objc_opt_isKindOfClass())
            {
              BOOL v338 = sub_10018AABC(v550, v540, v328);
              if (v338) {
                [v523 setObject:v338 forKeyedSubscript:@"protocolV4Containers"];
              }
            }
            else
            {
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              v339 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
              if (v339)
              {
                uint64_t v340 = object_getClass(v550);
                if (class_isMetaClass(v340)) {
                  uint64_t v341 = 43;
                }
                else {
                  uint64_t v341 = 45;
                }
                v342 = object_getClassName(v550);
                int v343 = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
                v339(3, "%c[%{public}s %{public}s]:%i Unexpected type for allow listed AID.", v341, v342, v343, 203);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              BOOL v338 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v338, OS_LOG_TYPE_ERROR))
              {
                v344 = object_getClass(v550);
                if (class_isMetaClass(v344)) {
                  int v345 = 43;
                }
                else {
                  int v345 = 45;
                }
                v346 = object_getClassName(v550);
                v347 = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
                *(_DWORD *)long long buf = 67109890;
                *(_DWORD *)&uint8_t buf[4] = v345;
                *(_WORD *)v584 = 2082;
                *(void *)&v584[2] = v346;
                *(_WORD *)&v584[10] = 2082;
                *(void *)&v584[12] = v347;
                *(_WORD *)&v584[20] = 1024;
                *(_DWORD *)&v584[22] = 203;
                _os_log_impl((void *)&_mh_execute_header, v338, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected type for allow listed AID.", buf, 0x22u);
              }
            }
          }
          else
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v329 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
            if (v329)
            {
              v330 = object_getClass(v550);
              if (class_isMetaClass(v330)) {
                uint64_t v331 = 43;
              }
              else {
                uint64_t v331 = 45;
              }
              v332 = object_getClassName(v550);
              v333 = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
              v329(4, "%c[%{public}s %{public}s]:%i No whitelisted AID found. Will not populate the V4 container!", v331, v332, v333, 207);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v328 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v328, OS_LOG_TYPE_ERROR))
            {
              v334 = object_getClass(v550);
              if (class_isMetaClass(v334)) {
                int v335 = 43;
              }
              else {
                int v335 = 45;
              }
              v336 = object_getClassName(v550);
              v337 = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
              *(_DWORD *)long long buf = 67109890;
              *(_DWORD *)&uint8_t buf[4] = v335;
              *(_WORD *)v584 = 2082;
              *(void *)&v584[2] = v336;
              *(_WORD *)&v584[10] = 2082;
              *(void *)&v584[12] = v337;
              *(_WORD *)&v584[20] = 1024;
              *(_DWORD *)&v584[22] = 207;
              _os_log_impl((void *)&_mh_execute_header, v328, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i No whitelisted AID found. Will not populate the V4 container!", buf, 0x22u);
            }
          }
        }
        id v348 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284184 length:8];
        unsigned __int8 v349 = [v550 select:v348 error:0];

        if (v349)
        {
          loga = sub_10018C0BC(v550, 1);
          if (loga) {
            [v523 addEntriesFromDictionary:loga];
          }
          id v531 = v523;
          v351 = [v531 objectForKey:@"casdCertificate"];
          uint64_t v352 = [v351 objectForKey:@"RSA"];
          v353 = [v351 objectForKey:@"ECDSA"];
          v354 = [v531 objectForKey:@"isdSequenceCounter"];
          BOOL v355 = objc_opt_new();
          if (v353 && v352)
          {
            v356 = +[NSData NF_dataWithHexString:v353];
            [v355 appendData:v356];

            uint64_t v357 = +[NSData NF_dataWithHexString:v352];
            [v355 appendData:v357];
          }
          v358 = +[NSData NF_dataWithHexString:v354];
          [v355 appendData:v358];

          id v359 = v355;
          CC_SHA256([v359 bytes], (CC_LONG)[v359 length], md);

          id obja = [objc_alloc((Class)NSData) initWithBytes:md length:32];
          v525 = +[NFTLV TLVWithTag:40759 value:obja];
          *(_DWORD *)v571 = 836706527;
          id v360 = [objc_alloc((Class)NSData) initWithBytes:v571 length:4];
          v522 = +[NFTLV TLVWithTag:92 value:v360];

          os_log_t osloga = (os_log_t)objc_opt_new();
          v361 = [v525 asData];
          [osloga appendData:v361];

          v362 = [v522 asData];
          [osloga appendData:v362];

          v528 = [v550 getData:128 tag:257 data:osloga error:0];
          if ([v528 status] == 36864)
          {
            v548 = objc_opt_new();
            id v363 = [v528 response];
            unsigned int v364 = [v363 NF_asHexString];
            [v548 setObject:v364 forKey:@"SignedResponse"];

            uint64_t v365 = [v528 response];
            v366 = +[NFTLV TLVsWithData:v365];

            long long v563 = 0u;
            long long v561 = 0u;
            long long v562 = 0u;
            long long v560 = 0u;
            v367 = v366;
            id v368 = [v367 countByEnumeratingWithState:&v560 objects:buf count:16];
            if (!v368) {
              goto LABEL_376;
            }
            uint64_t v369 = *(void *)v561;
            while (1)
            {
              for (i = 0; i != v368; i = (char *)i + 1)
              {
                if (*(void *)v561 != v369) {
                  objc_enumerationMutation(v367);
                }
                v371 = *(void **)(*((void *)&v560 + 1) + 8 * i);
                int v372 = [v371 tag];
                if (v372 > 57119)
                {
                  if (v372 == 57137)
                  {
                    v387 = [v371 value];
                    v376 = [v387 NF_asHexString];

                    v388 = -[NSObject substringWithRange:](v376, "substringWithRange:", 0, 4);
                    [v548 setObject:v388 forKey:@"jsblSequenceCounter"];
                  }
                  else if (v372 == 57120)
                  {
                    id v374 = objc_alloc((Class)NSString);
                    v375 = [v371 value];
                    v376 = [v374 initWithData:v375 encoding:4];

                    [v548 setObject:v376 forKey:@"kPlatformId"];
                  }
                  else
                  {
LABEL_362:
                    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                    BOOL v377 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
                    if (v377)
                    {
                      uint64_t v378 = object_getClass(v550);
                      if (class_isMetaClass(v378)) {
                        uint64_t v379 = 43;
                      }
                      else {
                        uint64_t v379 = 45;
                      }
                      int v380 = object_getClassName(v550);
                      v381 = sel_getName("_generateCASDSignatureComet:");
                      v377(3, "%c[%{public}s %{public}s]:%i Unexpected tag found, %d", v379, v380, v381, 673, [v371 tag]);
                    }
                    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                    v376 = NFSharedLogGetLogger();
                    if (os_log_type_enabled(v376, OS_LOG_TYPE_ERROR))
                    {
                      v382 = object_getClass(v550);
                      if (class_isMetaClass(v382)) {
                        int v383 = 43;
                      }
                      else {
                        int v383 = 45;
                      }
                      v384 = object_getClassName(v550);
                      v385 = sel_getName("_generateCASDSignatureComet:");
                      unsigned int v386 = [v371 tag];
                      *(_DWORD *)v579 = 67110146;
                      *(_DWORD *)&v579[4] = v383;
                      *(_WORD *)&v579[8] = 2082;
                      *(void *)&v579[10] = v384;
                      *(_WORD *)&v579[18] = 2082;
                      *(void *)&v579[20] = v385;
                      *(_WORD *)&v579[28] = 1024;
                      *(_DWORD *)&v579[30] = 673;
                      *(_WORD *)&v579[34] = 1024;
                      *(_DWORD *)&v579[36] = v386;
                      _os_log_impl((void *)&_mh_execute_header, v376, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected tag found, %d", v579, 0x28u);
                    }
                  }

                  continue;
                }
                if (v372 != 133 && v372 != 24375) {
                  goto LABEL_362;
                }
              }
              id v368 = [v367 countByEnumeratingWithState:&v560 objects:buf count:16];
              if (!v368)
              {
LABEL_376:

                goto LABEL_398;
              }
            }
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v398 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v398)
          {
            v399 = object_getClass(v550);
            if (class_isMetaClass(v399)) {
              uint64_t v400 = 43;
            }
            else {
              uint64_t v400 = 45;
            }
            v401 = object_getClassName(v550);
            v402 = sel_getName("_generateCASDSignatureComet:");
            v398(3, "%c[%{public}s %{public}s]:%i Unable to obtain Authenticated GET DATA 0x%x", v400, v401, v402, 641, [v528 status]);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v367 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v367, OS_LOG_TYPE_ERROR))
          {
            v403 = object_getClass(v550);
            if (class_isMetaClass(v403)) {
              int v404 = 43;
            }
            else {
              int v404 = 45;
            }
            v405 = object_getClassName(v550);
            v406 = sel_getName("_generateCASDSignatureComet:");
            unsigned int v407 = [v528 status];
            *(_DWORD *)long long buf = 67110146;
            *(_DWORD *)&uint8_t buf[4] = v404;
            *(_WORD *)v584 = 2082;
            *(void *)&v584[2] = v405;
            *(_WORD *)&v584[10] = 2082;
            *(void *)&v584[12] = v406;
            *(_WORD *)&v584[20] = 1024;
            *(_DWORD *)&v584[22] = 641;
            *(_WORD *)&v584[26] = 1024;
            *(_DWORD *)&v584[28] = v407;
            _os_log_impl((void *)&_mh_execute_header, v367, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unable to obtain Authenticated GET DATA 0x%x", buf, 0x28u);
          }
          v548 = 0;
LABEL_398:

          v408 = v548;
          if (v548)
          {
            CFStringRef v556 = @"CASDSignedInfo";
            v557 = v548;
            v409 = +[NSDictionary dictionaryWithObjects:&v557 forKeys:&v556 count:1];
            [v531 addEntriesFromDictionary:v409];

            v408 = v548;
          }
        }
        else
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v389 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v389)
          {
            v390 = object_getClass(v550);
            if (class_isMetaClass(v390)) {
              uint64_t v391 = 43;
            }
            else {
              uint64_t v391 = 45;
            }
            v392 = object_getClassName(v550);
            v393 = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
            v389(3, "%c[%{public}s %{public}s]:%i Failed to select ISD", v391, v392, v393, 213);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          loga = NFSharedLogGetLogger();
          if (os_log_type_enabled(loga, OS_LOG_TYPE_ERROR))
          {
            v394 = object_getClass(v550);
            if (class_isMetaClass(v394)) {
              int v395 = 43;
            }
            else {
              int v395 = 45;
            }
            v396 = object_getClassName(v550);
            v397 = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
            *(_DWORD *)long long buf = 67109890;
            *(_DWORD *)&uint8_t buf[4] = v395;
            *(_WORD *)v584 = 2082;
            *(void *)&v584[2] = v396;
            *(_WORD *)&v584[10] = 2082;
            *(void *)&v584[12] = v397;
            *(_WORD *)&v584[20] = 1024;
            *(_DWORD *)&v584[22] = 213;
            _os_log_impl((void *)&_mh_execute_header, loga, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select ISD", buf, 0x22u);
          }
        }

        v410 = [v550 handle];
        v411 = [v410 info];
        v412 = (char *)[v411 migrationState];

        if ((unint64_t)(v412 - 1) > 5)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v414 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v414)
          {
            v415 = object_getClass(v550);
            if (class_isMetaClass(v415)) {
              uint64_t v416 = 43;
            }
            else {
              uint64_t v416 = 45;
            }
            v417 = object_getClassName(v550);
            v418 = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
            v414(3, "%c[%{public}s %{public}s]:%i Unexpected AM status", v416, v417, v418, 244);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v419 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v419, OS_LOG_TYPE_ERROR))
          {
            v420 = object_getClass(v550);
            if (class_isMetaClass(v420)) {
              int v421 = 43;
            }
            else {
              int v421 = 45;
            }
            v422 = object_getClassName(v550);
            uint64_t v423 = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
            *(_DWORD *)long long buf = 67109890;
            *(_DWORD *)&uint8_t buf[4] = v421;
            *(_WORD *)v584 = 2082;
            *(void *)&v584[2] = v422;
            *(_WORD *)&v584[10] = 2082;
            *(void *)&v584[12] = v423;
            *(_WORD *)&v584[20] = 1024;
            *(_DWORD *)&v584[22] = 244;
            _os_log_impl((void *)&_mh_execute_header, v419, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected AM status", buf, 0x22u);
          }
        }
        else
        {
          v413 = +[NSNumber numberWithInt:dword_100284320[(void)(v412 - 1)]];
          [v523 setObject:v413 forKey:@"amStatus"];
        }
        goto LABEL_414;
      }
      int v191 = &off_100323410;
      uint64_t v192 = v550;
    }
    else
    {
      v514 = objc_opt_new();
      __int16 v216 = +[NFTLV TLVWithTag:79 value:0];
      id v217 = [v216 asData];
      [v514 appendData:v217];

      id v218 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284198 length:12];
      int v219 = +[NFTLV TLVWithTag:92 value:v218];
      __int16 v220 = [v219 asData];
      [v514 appendData:v220];

      v513 = sub_1000C1AB4(v550, v514, 0);
      if (v513)
      {
        os_log_t oslog = (os_log_t)objc_opt_new();
        id v221 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002841A4 length:12];
        v582[0] = v221;
        id v222 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002841B0 length:9];
        v582[1] = v222;
        id v223 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002841B9 length:8];
        v582[2] = v223;
        id v224 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002841C1 length:14];
        v582[3] = v224;
        id v225 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002841CF length:9];
        v582[4] = v225;
        v524 = +[NSArray arrayWithObjects:v582 count:5];

        id v226 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002841D8 length:14];
        v581[0] = v226;
        id v227 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002841E6 length:12];
        v581[1] = v227;
        id v228 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002841F2 length:12];
        v581[2] = v228;
        v530 = +[NSArray arrayWithObjects:v581 count:3];

        long long v580 = 0u;
        memset(v579, 0, sizeof(v579));
        id obj = v513;
        SEL v541 = (SEL)[obj countByEnumeratingWithState:v579 objects:buf count:16];
        if (v541)
        {
          os_log_t log = **(os_log_t **)&v579[16];
          do
          {
            int v229 = 0;
            do
            {
              if (**(os_log_t **)&v579[16] != log)
              {
                __int16 v230 = v229;
                objc_enumerationMutation(obj);
                int v229 = v230;
              }
              SEL v544 = v229;
              int v231 = *(void **)(*(void *)&v579[8] + 8 * (void)v229);
              if (!a3
                || ([*(id *)(*(void *)&v579[8] + 8 * (void)v229) identifierAsData],
                    NSErrorUserInfoKey v232 = objc_claimAutoreleasedReturnValue(),
                    unsigned __int8 v233 = [v524 containsObject:v232],
                    v232,
                    (v233 & 1) == 0))
              {
                BOOL v234 = objc_opt_new();
                [oslog addObject:v234];
                int v235 = [v231 identifier];
                [v234 setObject:v235 forKey:@"appletAid"];

                __int16 v236 = +[NSNumber numberWithUnsignedInteger:](NSNumber, "numberWithUnsignedInteger:", [v231 rawGPState]);
                [v234 setObject:v236 forKey:@"lifeCycleState"];

                uint64_t v237 = [v231 identifierAsData];
                unsigned __int8 v238 = [v530 containsObject:v237];

                if ((v238 & 1) == 0
                  && ([v231 isContainer] & 1) == 0
                  && ([v231 isProxy] & 1) == 0)
                {
                  uint64_t v239 = [v231 discretionaryData];
                  v240 = +[NFTLV TLVWithTag:204 fromData:v239];
                  uint64_t v241 = [v240 value];

                  if (v241)
                  {
                    v242 = [v241 NF_asHexString];
                    [v234 setObject:v242 forKey:@"ssdAid"];

                    sub_10018C950(v550, v241, v234);
                  }
                  else
                  {
                    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                    int v243 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
                    if (v243)
                    {
                      __int16 v244 = object_getClass(v550);
                      if (class_isMetaClass(v244)) {
                        uint64_t v245 = 43;
                      }
                      else {
                        uint64_t v245 = 45;
                      }
                      int v246 = object_getClassName(v550);
                      __int16 v247 = sel_getName("_getCRSInfoWithFiltering:");
                      __int16 v248 = [v231 identifier];
                      __int16 v249 = [v231 discretionaryData];
                      v243(4, "%c[%{public}s %{public}s]:%i Failed to get SSD ID %{public}@: %{public}@", v245, v246, v247, 516, v248, v249);
                    }
                    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                    __int16 v250 = NFSharedLogGetLogger();
                    if (os_log_type_enabled(v250, OS_LOG_TYPE_ERROR))
                    {
                      __int16 v251 = object_getClass(v550);
                      if (class_isMetaClass(v251)) {
                        int v252 = 43;
                      }
                      else {
                        int v252 = 45;
                      }
                      __int16 v253 = object_getClassName(v550);
                      id v254 = sel_getName("_getCRSInfoWithFiltering:");
                      __int16 v255 = [v231 identifier];
                      id v256 = [v231 discretionaryData];
                      *(_DWORD *)v571 = 67110402;
                      *(_DWORD *)&v571[4] = v252;
                      *(_WORD *)v572 = 2082;
                      *(void *)&v572[2] = v253;
                      *(_WORD *)&v572[10] = 2082;
                      *(void *)&v572[12] = v254;
                      __int16 v573 = 1024;
                      int v574 = 516;
                      __int16 v575 = 2114;
                      v576 = v255;
                      __int16 v577 = 2114;
                      v578 = v256;
                      _os_log_impl((void *)&_mh_execute_header, v250, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get SSD ID %{public}@: %{public}@", v571, 0x36u);
                    }
                  }
                }
                v257 = [v231 discretionaryData];
                v547 = +[NFTLV TLVWithTag:254 fromData:v257];

                if (v547)
                {
                  long long v570 = 0u;
                  memset(md, 0, sizeof(md));
                  uint64_t v258 = [v547 children];
                  id v259 = [v258 countByEnumeratingWithState:md objects:&v560 count:16];
                  if (v259)
                  {
                    uint64_t v260 = **(void **)&md[16];
                    while (2)
                    {
                      for (j = 0; j != v259; j = (char *)j + 1)
                      {
                        if (**(void **)&md[16] != v260) {
                          objc_enumerationMutation(v258);
                        }
                        v262 = *(void **)(*(void *)&md[8] + 8 * (void)j);
                        if ([v262 tag] == 57152)
                        {
                          v263 = [v262 value];
                          BOOL v264 = [v263 length] == (id)2;

                          if (v264)
                          {
                            id v276 = [v262 value];
                            int v277 = [v276 NF_asHexString];
                            [v234 setObject:v277 forKey:@"extendedFunction"];

                            goto LABEL_252;
                          }
                        }
                      }
                      id v259 = [v258 countByEnumeratingWithState:md objects:&v560 count:16];
                      if (v259) {
                        continue;
                      }
                      break;
                    }
                  }
                }
                else
                {
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  id v265 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
                  if (v265)
                  {
                    id v266 = object_getClass(v550);
                    if (class_isMetaClass(v266)) {
                      uint64_t v267 = 43;
                    }
                    else {
                      uint64_t v267 = 45;
                    }
                    id v268 = object_getClassName(v550);
                    id v269 = sel_getName("_getCRSInfoWithFiltering:");
                    unsigned int v270 = [v231 identifier];
                    v265(3, "%c[%{public}s %{public}s]:%i Failed to get extended function information for %{public}@", v267, v268, v269, 531, v270);
                  }
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  uint64_t v258 = NFSharedLogGetLogger();
                  if (os_log_type_enabled(v258, OS_LOG_TYPE_ERROR))
                  {
                    v271 = object_getClass(v550);
                    if (class_isMetaClass(v271)) {
                      int v272 = 43;
                    }
                    else {
                      int v272 = 45;
                    }
                    BOOL v273 = object_getClassName(v550);
                    uint64_t v274 = sel_getName("_getCRSInfoWithFiltering:");
                    id v275 = [v231 identifier];
                    *(_DWORD *)v571 = 67110146;
                    *(_DWORD *)&v571[4] = v272;
                    *(_WORD *)v572 = 2082;
                    *(void *)&v572[2] = v273;
                    *(_WORD *)&v572[10] = 2082;
                    *(void *)&v572[12] = v274;
                    __int16 v573 = 1024;
                    int v574 = 531;
                    __int16 v575 = 2114;
                    v576 = v275;
                    _os_log_impl((void *)&_mh_execute_header, v258, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get extended function information for %{public}@", v571, 0x2Cu);
                  }
                }
LABEL_252:

                CFStringRef v278 = [v231 discretionaryData];

                if (v278)
                {
                  v279 = [v231 discretionaryData];
                  id v280 = [v279 NF_asHexString];
                  [v234 setObject:v280 forKey:@"discretionaryData"];
                }
                else
                {
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  uint64_t v281 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
                  if (v281)
                  {
                    v282 = object_getClass(v550);
                    if (class_isMetaClass(v282)) {
                      uint64_t v283 = 43;
                    }
                    else {
                      uint64_t v283 = 45;
                    }
                    BOOL v284 = object_getClassName(v550);
                    v285 = sel_getName("_getCRSInfoWithFiltering:");
                    uint64_t v286 = [v231 identifier];
                    v281(3, "%c[%{public}s %{public}s]:%i nil discretionary data for %{public}@", v283, v284, v285, 538, v286);
                  }
                  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                  v279 = NFSharedLogGetLogger();
                  if (os_log_type_enabled(v279, OS_LOG_TYPE_ERROR))
                  {
                    v287 = object_getClass(v550);
                    if (class_isMetaClass(v287)) {
                      int v288 = 43;
                    }
                    else {
                      int v288 = 45;
                    }
                    int v289 = object_getClassName(v550);
                    __int16 v290 = sel_getName("_getCRSInfoWithFiltering:");
                    v291 = [v231 identifier];
                    *(_DWORD *)v571 = 67110146;
                    *(_DWORD *)&v571[4] = v288;
                    *(_WORD *)v572 = 2082;
                    *(void *)&v572[2] = v289;
                    *(_WORD *)&v572[10] = 2082;
                    *(void *)&v572[12] = v290;
                    __int16 v573 = 1024;
                    int v574 = 538;
                    __int16 v575 = 2114;
                    v576 = v291;
                    _os_log_impl((void *)&_mh_execute_header, v279, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i nil discretionary data for %{public}@", v571, 0x2Cu);
                  }
                }

                uint64_t v292 = [v231 groupHeadID];
                if (v292) {
                  [v234 setObject:v292 forKey:@"primaryContainer"];
                }
                v293 = [v231 groupMemberIDs];
                if (v293) {
                  [v234 setObject:v293 forKey:@"auxilaryContainers"];
                }
                v294 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", [v231 isContainer]);
                [v234 setObject:v294 forKey:@"containerInstance"];

                BOOL v295 = +[NSNumber numberWithBool:](NSNumber, "numberWithBool:", [v231 isProxy]);
                [v234 setObject:v295 forKey:@"proxyInstance"];

                uint64_t v296 = [v231 packageIdentifier];

                if (v296)
                {
                  v297 = [v231 packageIdentifier];
                  [v234 setObject:v297 forKey:@"packageAid"];
                }
                NSErrorUserInfoKey v298 = [v231 moduleIdentifier];

                if (v298)
                {
                  int v299 = [v231 moduleIdentifier];
                  [v234 setObject:v299 forKey:@"moduleAid"];
                }
                v300 = [v231 multiSEGroupMemberIDs];
                id v301 = [v300 count];

                if (v301)
                {
                  __int16 v302 = [v231 multiSEGroupMemberIDs];
                  [v234 setObject:v302 forKey:@"multiSEApplicationGroup"];
                }
              }
              int v229 = v544 + 1;
            }
            while (v544 + 1 != v541);
            SEL v541 = (SEL)[obj countByEnumeratingWithState:v579 objects:buf count:16];
          }
          while (v541);
        }

        CFStringRef v558 = @"containers";
        os_log_t v559 = oslog;
        v303 = +[NSDictionary dictionaryWithObjects:&v559 forKeys:&v558 count:1];
      }
      else
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v307 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v307)
        {
          __int16 v308 = object_getClass(v550);
          if (class_isMetaClass(v308)) {
            uint64_t v309 = 43;
          }
          else {
            uint64_t v309 = 45;
          }
          uint64_t v310 = object_getClassName(v550);
          v311 = sel_getName("_getCRSInfoWithFiltering:");
          v307(3, "%c[%{public}s %{public}s]:%i Failed to get applications", v309, v310, v311, 472);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        NFSharedLogGetLogger();
        os_log_t oslog = (os_log_t)objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(oslog, OS_LOG_TYPE_ERROR))
        {
          v312 = object_getClass(v550);
          if (class_isMetaClass(v312)) {
            int v313 = 43;
          }
          else {
            int v313 = 45;
          }
          NSErrorUserInfoKey v314 = object_getClassName(v550);
          v315 = sel_getName("_getCRSInfoWithFiltering:");
          *(_DWORD *)v571 = 67109890;
          *(_DWORD *)&v571[4] = v313;
          *(_WORD *)v572 = 2082;
          *(void *)&v572[2] = v314;
          *(_WORD *)&v572[10] = 2082;
          *(void *)&v572[12] = v315;
          __int16 v573 = 1024;
          int v574 = 472;
          _os_log_impl((void *)&_mh_execute_header, oslog, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get applications", v571, 0x22u);
        }
        v303 = &off_100323438;
      }

      uint64_t v192 = v550;
      int v191 = v303;
      if (!v303)
      {
        v540 = 0;
        goto LABEL_299;
      }
    }
    v540 = v191;
    [v523 addEntriesFromDictionary:];
    goto LABEL_299;
  }
  id v132 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284184 length:8];
  unsigned __int8 v133 = [v550 select:v132 error:0];

  if ((v133 & 1) == 0)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v166 = NFLogGetLogger();
    if (v166)
    {
      __int16 v167 = (void (*)(uint64_t, const char *, ...))v166;
      __int16 v168 = object_getClass(v550);
      BOOL v169 = class_isMetaClass(v168);
      uint64_t v170 = object_getClassName(v550);
      v509 = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
      uint64_t v171 = 45;
      if (v169) {
        uint64_t v171 = 43;
      }
      v167(3, "%c[%{public}s %{public}s]:%i Failed to select ISD", v171, v170, v509, 250);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v172 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v172, OS_LOG_TYPE_ERROR))
    {
      v173 = object_getClass(v550);
      if (class_isMetaClass(v173)) {
        int v174 = 43;
      }
      else {
        int v174 = 45;
      }
      uint64_t v175 = object_getClassName(v550);
      uint64_t v176 = sel_getName("remoteAdminState:appletFiltering:stateInfo:");
      *(_DWORD *)long long buf = 67109890;
      *(_DWORD *)&uint8_t buf[4] = v174;
      *(_WORD *)v584 = 2082;
      *(void *)&v584[2] = v175;
      *(_WORD *)&v584[10] = 2082;
      *(void *)&v584[12] = v176;
      *(_WORD *)&v584[20] = 1024;
      *(_DWORD *)&v584[22] = 250;
      _os_log_impl((void *)&_mh_execute_header, v172, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select ISD", buf, 0x22u);
    }

    v540 = 0;
LABEL_414:
    __int16 v135 = v523;
    goto LABEL_415;
  }
  int v134 = sub_10018C0BC(v550, 1);
  __int16 v135 = v523;
  if (v134) {
    [v523 addEntriesFromDictionary:v134];
  }

  v540 = 0;
LABEL_415:
  if ([v135 count])
  {
    if (v520)
    {
      id v552 = 0;
      id v424 = sub_1000AD6C4(v550, &v552);
      id v549 = v552;
      v425 = objc_opt_new();
      v426 = v425;
      if (v424) {
        [v425 setObject:v424 forKey:@"attackLogDictionary"];
      }
      v427 = objc_opt_new();
      v428 = [v550 handle];
      v429 = [v428 driver];
      v430 = (void *)sub_10002C8B8(v429);

      if (!v430)
      {
        id v453 = v427;
LABEL_489:

        if (v427) {
          [v426 addEntriesFromDictionary:v427];
        }
        [v523 setObject:v426 forKey:@"restrictedMode"];

        int v452 = v523;
LABEL_492:
        uint64_t v33 = 0;
        *a4 = v452;
        goto LABEL_493;
      }
      v545 = (char *)[objc_alloc((Class)NSData) initWithBytes:*v430 length:v430[1]];
      NFDataRelease();
      v431 = +[NFTLV TLVWithData:v545];
      if ([v431 tag] != 48)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v454 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v454)
        {
          long long v455 = object_getClass(v550);
          if (class_isMetaClass(v455)) {
            uint64_t v456 = 43;
          }
          else {
            uint64_t v456 = 45;
          }
          long long v457 = object_getClassName(v550);
          long long v458 = sel_getName("_getUnlockRequestInfoFrom:");
          v454(3, "%c[%{public}s %{public}s]:%i Unexpected tag: 0x%x", v456, v457, v458, 703, [v431 tag]);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v459 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v459, OS_LOG_TYPE_ERROR))
        {
          v460 = object_getClass(v550);
          if (class_isMetaClass(v460)) {
            int v461 = 43;
          }
          else {
            int v461 = 45;
          }
          v462 = object_getClassName(v550);
          v463 = sel_getName("_getUnlockRequestInfoFrom:");
          unsigned int v464 = [v431 tag];
          *(_DWORD *)long long buf = 67110146;
          *(_DWORD *)&uint8_t buf[4] = v461;
          *(_WORD *)v584 = 2082;
          *(void *)&v584[2] = v462;
          *(_WORD *)&v584[10] = 2082;
          *(void *)&v584[12] = v463;
          *(_WORD *)&v584[20] = 1024;
          *(_DWORD *)&v584[22] = 703;
          *(_WORD *)&v584[26] = 1024;
          *(_DWORD *)&v584[28] = v464;
          _os_log_impl((void *)&_mh_execute_header, v459, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected tag: 0x%x", buf, 0x28u);
        }

        id v465 = v427;
        goto LABEL_488;
      }
      os_log_t logb = [v431 children];
      if ([logb count] == (id)5)
      {
        v432 = [logb objectAtIndexedSubscript:0];
        BOOL v433 = [v432 tag] == 2;

        if (v433)
        {
          id v434 = [logb objectAtIndexedSubscript:0];
          id v435 = [v434 valueAsUnsignedLong];

          if (v435 == 2)
          {
            v436 = [logb objectAtIndexedSubscript:4];
            v437 = [v436 value];
            BOOL v438 = [v437 length] == (id)24;

            if (v438)
            {
              __int16 v439 = [logb objectAtIndexedSubscript:1];
              int v440 = [v439 value];
              __int16 v441 = [v440 NF_asHexString];

              v442 = [logb objectAtIndexedSubscript:2];
              __int16 v443 = [v442 value];
              [v443 NF_asHexString];
              id v551 = (id)objc_claimAutoreleasedReturnValue();

              v444 = [logb objectAtIndexedSubscript:3];
              v445 = [v444 value];
              int v446 = [v445 NF_asHexString];

              __int16 v447 = [logb objectAtIndexedSubscript:4];
              v448 = [v447 value];
              __int16 v449 = [v448 NF_asHexString];

              v450 = +[NSNumber numberWithUnsignedInt:2];
              [v427 setObject:v450 forKey:@"version"];

              [v427 setObject:v441 forKey:@"nonce"];
              [v427 setObject:v551 forKey:@"unlockKeyID"];
              [v427 setObject:v446 forKey:@"kPlatformId"];
              [v427 setObject:v449 forKey:@"SEID"];
              id v451 = v427;

LABEL_487:
LABEL_488:

              goto LABEL_489;
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v495 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
            if (v495)
            {
              v496 = object_getClass(v550);
              if (class_isMetaClass(v496)) {
                uint64_t v497 = 43;
              }
              else {
                uint64_t v497 = 45;
              }
              v498 = object_getClassName(v550);
              v499 = sel_getName("_getUnlockRequestInfoFrom:");
              v495(3, "%c[%{public}s %{public}s]:%i Unexpected data structure", v497, v498, v499, 745);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v471 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v471, OS_LOG_TYPE_ERROR))
            {
              v500 = object_getClass(v550);
              if (class_isMetaClass(v500)) {
                int v501 = 43;
              }
              else {
                int v501 = 45;
              }
              v502 = object_getClassName(v550);
              v503 = sel_getName("_getUnlockRequestInfoFrom:");
              *(_DWORD *)long long buf = 67109890;
              *(_DWORD *)&uint8_t buf[4] = v501;
              *(_WORD *)v584 = 2082;
              *(void *)&v584[2] = v502;
              *(_WORD *)&v584[10] = 2082;
              *(void *)&v584[12] = v503;
              *(_WORD *)&v584[20] = 1024;
              *(_DWORD *)&v584[22] = 745;
              _os_log_impl((void *)&_mh_execute_header, v471, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected data structure", buf, 0x22u);
            }
          }
          else
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v486 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
            if (v486)
            {
              v487 = object_getClass(v550);
              if (class_isMetaClass(v487)) {
                uint64_t v488 = 43;
              }
              else {
                uint64_t v488 = 45;
              }
              v489 = object_getClassName(v550);
              v490 = sel_getName("_getUnlockRequestInfoFrom:");
              v486(3, "%c[%{public}s %{public}s]:%i Unsupported version: 0x%x", v488, v489, v490, 721, v435);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            v471 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v471, OS_LOG_TYPE_ERROR))
            {
              v491 = object_getClass(v550);
              if (class_isMetaClass(v491)) {
                int v492 = 43;
              }
              else {
                int v492 = 45;
              }
              v493 = object_getClassName(v550);
              v494 = sel_getName("_getUnlockRequestInfoFrom:");
              *(_DWORD *)long long buf = 67110146;
              *(_DWORD *)&uint8_t buf[4] = v492;
              *(_WORD *)v584 = 2082;
              *(void *)&v584[2] = v493;
              *(_WORD *)&v584[10] = 2082;
              *(void *)&v584[12] = v494;
              *(_WORD *)&v584[20] = 1024;
              *(_DWORD *)&v584[22] = 721;
              *(_WORD *)&v584[26] = 1024;
              *(_DWORD *)&v584[28] = v435;
              _os_log_impl((void *)&_mh_execute_header, v471, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unsupported version: 0x%x", buf, 0x28u);
            }
          }
        }
        else
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v476 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v476)
          {
            v477 = object_getClass(v550);
            if (class_isMetaClass(v477)) {
              uint64_t v478 = 43;
            }
            else {
              uint64_t v478 = 45;
            }
            v479 = object_getClassName(v550);
            v480 = sel_getName("_getUnlockRequestInfoFrom:");
            v476(3, "%c[%{public}s %{public}s]:%i Unexpected tag: 0x%x", v478, v479, v480, 715, [v431 tag]);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          v471 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v471, OS_LOG_TYPE_ERROR))
          {
            v481 = object_getClass(v550);
            if (class_isMetaClass(v481)) {
              int v482 = 43;
            }
            else {
              int v482 = 45;
            }
            v483 = object_getClassName(v550);
            v484 = sel_getName("_getUnlockRequestInfoFrom:");
            unsigned int v485 = [v431 tag];
            *(_DWORD *)long long buf = 67110146;
            *(_DWORD *)&uint8_t buf[4] = v482;
            *(_WORD *)v584 = 2082;
            *(void *)&v584[2] = v483;
            *(_WORD *)&v584[10] = 2082;
            *(void *)&v584[12] = v484;
            *(_WORD *)&v584[20] = 1024;
            *(_DWORD *)&v584[22] = 715;
            *(_WORD *)&v584[26] = 1024;
            *(_DWORD *)&v584[28] = v485;
            _os_log_impl((void *)&_mh_execute_header, v471, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unexpected tag: 0x%x", buf, 0x28u);
          }
        }
      }
      else
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v466 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v466)
        {
          v467 = object_getClass(v550);
          if (class_isMetaClass(v467)) {
            uint64_t v468 = 43;
          }
          else {
            uint64_t v468 = 45;
          }
          v469 = object_getClassName(v550);
          v470 = sel_getName("_getUnlockRequestInfoFrom:");
          v466(3, "%c[%{public}s %{public}s]:%i Invalid number of subtags", v468, v469, v470, 710);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        v471 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v471, OS_LOG_TYPE_ERROR))
        {
          v472 = object_getClass(v550);
          if (class_isMetaClass(v472)) {
            int v473 = 43;
          }
          else {
            int v473 = 45;
          }
          v474 = object_getClassName(v550);
          v475 = sel_getName("_getUnlockRequestInfoFrom:");
          *(_DWORD *)long long buf = 67109890;
          *(_DWORD *)&uint8_t buf[4] = v473;
          *(_WORD *)v584 = 2082;
          *(void *)&v584[2] = v474;
          *(_WORD *)&v584[10] = 2082;
          *(void *)&v584[12] = v475;
          *(_WORD *)&v584[20] = 1024;
          *(_DWORD *)&v584[22] = 710;
          _os_log_impl((void *)&_mh_execute_header, v471, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid number of subtags", buf, 0x22u);
        }
      }

      id v504 = v427;
      goto LABEL_487;
    }
    uint64_t v33 = 6;
    int v452 = v523;
    int v215 = v540;
    if (!v518 || !v517) {
      goto LABEL_494;
    }
    if (v540) {
      goto LABEL_492;
    }
  }
  else
  {
    uint64_t v33 = 6;
  }
LABEL_493:
  int v215 = v540;
LABEL_494:

  uint64_t v30 = v518;
LABEL_495:

LABEL_496:
  return v33;
}

void sub_100189D9C(_Unwind_Exception *a1)
{
}

BOOL sub_100189DC8(BOOL a1)
{
  BOOL v1 = a1;
  if (a1)
  {
    uint64_t v2 = +[_NFHardwareManager sharedHardwareManager];
    id v3 = [v2 controllerInfo];

    id v4 = [(id)v1 handle];
    id v5 = [v4 info];
    unint64_t v6 = (unint64_t)[v5 seType];

    if (v6 <= 7)
    {
      if (((1 << v6) & 0xB1) != 0)
      {
        BOOL v1 = 0;
LABEL_10:

        return v1;
      }
      if (v6 == 2)
      {
        id v7 = [v3 siliconName];
        uint64_t v8 = [(id)v1 handle];
        id v9 = [v8 info];
        id v10 = [v9 sequenceCounter];
        unsigned int v11 = [v10 unsignedIntValue];

        if ((unint64_t)v7 >= 7) {
          BOOL v1 = v11 > 0x630;
        }
        else {
          BOOL v1 = v11 > 0x505;
        }
        goto LABEL_10;
      }
    }
    BOOL v1 = 1;
    goto LABEL_10;
  }
  return v1;
}

id sub_100189EE8(void *a1, char a2)
{
  if (!a1)
  {
    uint64_t v34 = 0;
    goto LABEL_45;
  }
  uint64_t v2 = [a1 handle];
  id v3 = [v2 info];
  uint64_t v4 = (uint64_t)[v3 deviceType];

  int v5 = 0;
  if (v4 <= 99)
  {
    switch(v4)
    {
      case ',':
        unint64_t v6 = [a1 handle];
        id v7 = [v6 info];
        uint64_t v8 = [v7 sequenceCounter];
        BOOL v9 = [v8 unsignedIntValue] > 0x326;
        break;
      case '6':
        unint64_t v6 = [a1 handle];
        id v7 = [v6 info];
        uint64_t v8 = [v7 sequenceCounter];
        BOOL v9 = [v8 unsignedIntValue] > 0x123;
        break;
      case '7':
        goto LABEL_20;
      default:
        goto LABEL_48;
    }
LABEL_16:
    int v5 = v9;

    goto LABEL_20;
  }
  if (v4 > 199)
  {
    if (v4 != 210 && v4 != 200) {
      goto LABEL_48;
    }
    goto LABEL_13;
  }
  if (v4 == 100)
  {
LABEL_13:
    unint64_t v6 = [a1 handle];
    id v7 = [v6 info];
    uint64_t v8 = [v7 sequenceCounter];
    BOOL v9 = [v8 unsignedIntValue] > 0xF1D;
    goto LABEL_16;
  }
  if (v4 != 115) {
LABEL_48:
  }
    int v5 = 1;
LABEL_20:
  int v57 = v5;
  id v59 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002841A4 length:12];
  v106[0] = v59;
  id v60 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002841B0 length:9];
  v106[1] = v60;
  id v62 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002841B9 length:8];
  v106[2] = v62;
  id v65 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002841C1 length:14];
  v106[3] = v65;
  id v10 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284221 length:10];
  v106[4] = v10;
  id v11 = [objc_alloc((Class)NSData) initWithBytes:&unk_10028422B length:14];
  v106[5] = v11;
  id v12 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284239 length:12];
  v106[6] = v12;
  id v13 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284245 length:16];
  v106[7] = v13;
  id v14 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284255 length:13];
  v106[8] = v14;
  id v15 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284262 length:12];
  v106[9] = v15;
  id v16 = [objc_alloc((Class)NSData) initWithBytes:&unk_10028426E length:12];
  v106[10] = v16;
  id v17 = [objc_alloc((Class)NSData) initWithBytes:&unk_10028427A length:10];
  v106[11] = v17;
  id v18 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284284 length:10];
  v106[12] = v18;
  id v19 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002841CF length:9];
  v106[13] = v19;
  BOOL v56 = +[NSArray arrayWithObjects:v106 count:14];

  id v20 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002841D8 length:14];
  v105[0] = v20;
  id v21 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002841E6 length:12];
  v105[1] = v21;
  id v22 = [objc_alloc((Class)NSData) initWithBytes:&unk_1002841F2 length:12];
  v105[2] = v22;
  uint64_t v66 = +[NSArray arrayWithObjects:v105 count:3];

  uint64_t v87 = 0;
  unsigned int v88 = &v87;
  uint64_t v89 = 0x3032000000;
  unsigned int v90 = sub_10000B8C8;
  __int16 v91 = sub_10018D148;
  id v92 = (id)objc_opt_new();
  uint64_t v81 = 0;
  int v82 = &v81;
  uint64_t v83 = 0x3032000000;
  __int16 v84 = sub_10000B8C8;
  id v85 = sub_10018D148;
  id v86 = (id)objc_opt_new();
  uint64_t v75 = 0;
  __int16 v76 = &v75;
  uint64_t v77 = 0x3032000000;
  __int16 v78 = sub_10000B8C8;
  int v79 = sub_10018D148;
  id v80 = [objc_alloc((Class)NSMutableArray) initWithCapacity:2];
  if (v57) {
    unint64_t v23 = 11;
  }
  else {
    unint64_t v23 = 10;
  }
  v68[0] = _NSConcreteStackBlock;
  v68[1] = 3221225472;
  v68[2] = sub_10018D150;
  v68[3] = &unk_100306108;
  void v68[4] = a1;
  long long v73 = "getStatusProprietaryApplicationsWithFiltering:";
  char v74 = a2;
  id v61 = v56;
  id v69 = v61;
  int v70 = &v75;
  id v71 = &v81;
  long long v72 = &v87;
  __int16 v63 = sub_10018DC58(a1, 64, (uint64_t)&unk_100284216, v23, v68);
  if (v63)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (Logger)
    {
      Class = object_getClass(a1);
      if (class_isMetaClass(Class)) {
        uint64_t v26 = 43;
      }
      else {
        uint64_t v26 = 45;
      }
      ClassName = object_getClassName(a1);
      Name = sel_getName("getStatusProprietaryApplicationsWithFiltering:");
      Logger(3, "%c[%{public}s %{public}s]:%i Failed to call proprietary get status %{public}@", v26, ClassName, Name, 947, v63);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v29 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      uint64_t v30 = object_getClass(a1);
      if (class_isMetaClass(v30)) {
        int v31 = 43;
      }
      else {
        int v31 = 45;
      }
      int v32 = object_getClassName(a1);
      uint64_t v33 = sel_getName("getStatusProprietaryApplicationsWithFiltering:");
      *(_DWORD *)long long buf = 67110146;
      int v96 = v31;
      __int16 v97 = 2082;
      id v98 = v32;
      __int16 v99 = 2082;
      __int16 v100 = v33;
      __int16 v101 = 1024;
      int v102 = 947;
      __int16 v103 = 2114;
      uint64_t v104 = v63;
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to call proprietary get status %{public}@", buf, 0x2Cu);
    }

    uint64_t v34 = 0;
  }
  else
  {
    id v35 = (char *)[(id)v88[5] count];
    if (v35)
    {
      for (i = 0; i != v35; ++i)
      {
        BOOL v37 = [(id)v88[5] objectAtIndexedSubscript:i];
        id v38 = [v37 objectForKeyedSubscript:@"associatedSSD"];
        uint64_t v39 = +[NSData NF_dataWithHexString:v38];
        id v40 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284184 length:8];
        unsigned int v41 = [v39 isEqualToData:v40];

        uint64_t v42 = [v37 objectForKeyedSubscript:@"appletAid"];
        long long v43 = +[NSData NF_dataWithHexString:v42];
        unsigned int v44 = [v66 containsObject:v43];

        BOOL v45 = [v37 objectForKeyedSubscript:@"containerInstance"];
        unsigned int v46 = [v45 BOOLValue];

        uint64_t v47 = [v37 objectForKeyedSubscript:@"proxyInstance"];
        unsigned int v48 = [v47 BOOLValue];

        if (v38) {
          int v49 = v41;
        }
        else {
          int v49 = 1;
        }
        if (((v49 | v44 | v46 | v48) & 1) == 0)
        {
          int v50 = +[NSData NF_dataWithHexString:v38];
          sub_10018C950(a1, v50, v37);
        }
      }
    }
    __int16 v51 = (void *)v82[5];
    v67[0] = _NSConcreteStackBlock;
    v67[1] = 3221225472;
    v67[2] = sub_10018E830;
    v67[3] = &unk_100306130;
    v67[4] = &v87;
    id v52 = +[NSPredicate predicateWithBlock:v67];
    [v51 filterUsingPredicate:v52];

    uint64_t v53 = v88[5];
    v93[0] = @"containers";
    v93[1] = @"orphanedSSDs";
    uint64_t v54 = v82[5];
    v94[0] = v53;
    v94[1] = v54;
    v93[2] = @"VASDs";
    v94[2] = v76[5];
    uint64_t v34 = +[NSDictionary dictionaryWithObjects:v94 forKeys:v93 count:3];
  }

  _Block_object_dispose(&v75, 8);
  _Block_object_dispose(&v81, 8);

  _Block_object_dispose(&v87, 8);
LABEL_45:

  return v34;
}

void sub_10018A8FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,char a49)
{
}

uint64_t sub_10018A96C(uint64_t a1, void *a2)
{
  id v3 = a2;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  uint64_t v4 = [[*(id *)(a1 + 32) objectForKeyedSubscript:@"packages"];
  id v5 = [v4 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v14;
    while (2)
    {
      uint64_t v8 = 0;
      do
      {
        if (*(void *)v14 != v7) {
          objc_enumerationMutation(v4);
        }
        BOOL v9 = [*(id *)(*((void *)&v13 + 1) + 8 * (void)v8) objectForKeyedSubscript:@"associatedSSD"];
        unsigned __int8 v10 = [v9 isEqualToString:v3];

        if (v10)
        {
          uint64_t v11 = 0;
          goto LABEL_11;
        }
        uint64_t v8 = (char *)v8 + 1;
      }
      while (v6 != v8);
      id v6 = [v4 countByEnumeratingWithState:&v13 objects:v17 count:16];
      if (v6) {
        continue;
      }
      break;
    }
  }
  uint64_t v11 = 1;
LABEL_11:

  return v11;
}

id sub_10018AABC(void *a1, void *a2, void *a3)
{
  id v4 = a2;
  id v5 = a3;
  id v223 = objc_opt_new();
  id v224 = v4;
  [v4 objectForKeyedSubscript:@"containers"];
  long long v230 = 0u;
  long long v231 = 0u;
  long long v232 = 0u;
  long long v233 = 0u;
  id v6 = (id)objc_claimAutoreleasedReturnValue();
  id v7 = [v6 countByEnumeratingWithState:&v230 objects:v246 count:16];
  if (v7)
  {
    id v8 = v7;
    uint64_t v9 = *(void *)v231;
LABEL_3:
    uint64_t v10 = 0;
    while (1)
    {
      if (*(void *)v231 != v9) {
        objc_enumerationMutation(v6);
      }
      uint64_t v11 = *(void **)(*((void *)&v230 + 1) + 8 * v10);
      id v12 = [v11 objectForKeyedSubscript:@"appletAid"];
      long long v13 = +[NSData NF_dataWithHexString:v12];

      if ([v13 isEqualToData:v5]) {
        break;
      }

      if (v8 == (id)++v10)
      {
        id v8 = [v6 countByEnumeratingWithState:&v230 objects:v246 count:16];
        if (v8) {
          goto LABEL_3;
        }
        goto LABEL_9;
      }
    }
    uint64_t v28 = [v11 objectForKeyedSubscript:@"moduleAid"];
    uint64_t v29 = +[NSData NF_dataWithHexString:v28];
    id v30 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284303 length:16];
    id v222 = v29;
    if ([v29 isEqualToData:v30])
    {
    }
    else
    {
      id v31 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284313 length:12];
      unsigned __int8 v32 = [v29 isEqualToData:v31];

      if ((v32 & 1) == 0)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          uint64_t v54 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(a1);
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(a1);
          Name = sel_getName("getGetProtocolV4Container:forApplet:");
          uint64_t v57 = 45;
          if (isMetaClass) {
            uint64_t v57 = 43;
          }
          v54(3, "%c[%{public}s %{public}s]:%i moduleID  %{public}@ does not match MiFare or MOT MID. ", v57, ClassName, Name, 1253, v29);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v35 = NFSharedLogGetLogger();
        uint64_t v27 = v224;
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          int v58 = object_getClass(a1);
          if (class_isMetaClass(v58)) {
            int v59 = 43;
          }
          else {
            int v59 = 45;
          }
          id v60 = object_getClassName(a1);
          id v61 = sel_getName("getGetProtocolV4Container:forApplet:");
          *(_DWORD *)long long buf = 67110146;
          int v235 = v59;
          __int16 v236 = 2082;
          uint64_t v237 = v60;
          __int16 v238 = 2082;
          uint64_t v239 = v61;
          __int16 v240 = 1024;
          int v241 = 1253;
          __int16 v242 = 2114;
          id v62 = v222;
          *(void *)int v243 = v222;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i moduleID  %{public}@ does not match MiFare or MOT MID. ", buf, 0x2Cu);
          id v25 = 0;
          uint64_t v26 = v223;
        }
        else
        {
          id v25 = 0;
          id v62 = v29;
          uint64_t v26 = v223;
        }
        goto LABEL_156;
      }
    }
    uint64_t v33 = [v11 objectForKeyedSubscript:@"lifeCycleState"];
    unsigned __int8 v34 = [v33 intValue];

    if (v34 != 15 && v34 != 130)
    {
      id v221 = v28;
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v63 = NFLogGetLogger();
      if (v63)
      {
        id v64 = (void (*)(uint64_t, const char *, ...))v63;
        id v65 = object_getClass(a1);
        BOOL v66 = class_isMetaClass(v65);
        int v195 = object_getClassName(a1);
        int v201 = sel_getName("getGetProtocolV4Container:forApplet:");
        uint64_t v67 = 45;
        if (v66) {
          uint64_t v67 = 43;
        }
        v64(3, "%c[%{public}s %{public}s]:%i lifeCycle  %d is not valid ", v67, v195, v201, 1260, v34);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v68 = NFSharedLogGetLogger();
      uint64_t v27 = v224;
      if (os_log_type_enabled(v68, OS_LOG_TYPE_ERROR))
      {
        id v69 = object_getClass(a1);
        if (class_isMetaClass(v69)) {
          int v70 = 43;
        }
        else {
          int v70 = 45;
        }
        id v71 = object_getClassName(a1);
        long long v72 = sel_getName("getGetProtocolV4Container:forApplet:");
        *(_DWORD *)long long buf = 67110146;
        int v235 = v70;
        __int16 v236 = 2082;
        uint64_t v237 = v71;
        __int16 v238 = 2082;
        uint64_t v239 = v72;
        __int16 v240 = 1024;
        int v241 = 1260;
        __int16 v242 = 1024;
        *(_DWORD *)int v243 = v34;
        _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i lifeCycle  %d is not valid ", buf, 0x28u);
      }
      id v25 = 0;
      id v62 = v222;
      uint64_t v26 = v223;
      id v35 = v68;
      uint64_t v28 = v221;
      goto LABEL_156;
    }
    id v35 = objc_opt_new();
    id v36 = [v11 objectForKeyedSubscript:@"ssdCounter"];

    if (v36)
    {
      BOOL v37 = [v11 objectForKeyedSubscript:@"ssdCounter"];
      [v35 setObject:v37 forKeyedSubscript:@"ssdCounter"];

      id v38 = [v11 objectForKeyedSubscript:@"appletAid"];

      if (v38)
      {
        uint64_t v39 = [v11 objectForKeyedSubscript:@"appletAid"];
        [v35 setObject:v39 forKeyedSubscript:@"appletAid"];

        id v229 = 0;
        id v40 = [a1 selectByName:v13 error:&v229];
        unsigned int v41 = v229;
        __int16 v220 = v28;
        if ([v40 status] != 36864)
        {
          int v219 = v40;
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v94 = NFLogGetLogger();
          if (v94)
          {
            BOOL v95 = (void (*)(uint64_t, const char *, ...))v94;
            int v96 = object_getClass(a1);
            BOOL v97 = class_isMetaClass(v96);
            id v98 = v35;
            __int16 v99 = object_getClassName(a1);
            __int16 v100 = sel_getName("getGetProtocolV4Container:forApplet:");
            uint64_t v211 = [v40 status];
            BOOL v196 = v99;
            uint64_t v101 = 45;
            if (v97) {
              uint64_t v101 = 43;
            }
            id v35 = v98;
            v95(3, "%c[%{public}s %{public}s]:%i Failed to select AID %{public}@: status 0x%04x, error = %{public}@", v101, v196, v100, 1289, v13, v211, v41);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          int v102 = NFSharedLogGetLogger();
          if (!os_log_type_enabled(v102, OS_LOG_TYPE_ERROR))
          {
            id v25 = 0;
            int v109 = v102;
            uint64_t v26 = v223;
            uint64_t v27 = v224;
            id v62 = v222;
LABEL_153:
            BOOL v107 = v219;
            goto LABEL_154;
          }
          __int16 v103 = object_getClass(a1);
          if (class_isMetaClass(v103)) {
            int v104 = 43;
          }
          else {
            int v104 = 45;
          }
          uint64_t v105 = object_getClassName(a1);
          BOOL v106 = sel_getName("getGetProtocolV4Container:forApplet:");
          BOOL v107 = v219;
          unsigned int v108 = [v219 status];
          *(_DWORD *)long long buf = 67110658;
          int v235 = v104;
          __int16 v236 = 2082;
          uint64_t v237 = v105;
          __int16 v238 = 2082;
          uint64_t v239 = v106;
          __int16 v240 = 1024;
          int v241 = 1289;
          __int16 v242 = 2114;
          *(void *)int v243 = v13;
          *(_WORD *)&v243[8] = 1024;
          *(_DWORD *)&v243[10] = v108;
          __int16 v244 = 2114;
          uint64_t v245 = v41;
          _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select AID %{public}@: status 0x%04x, error = %{public}@", buf, 0x3Cu);
          id v25 = 0;
          int v109 = v102;
          uint64_t v27 = v224;
          goto LABEL_81;
        }
        uint64_t v42 = v40;
        os_log_t log = v35;
        id v43 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284303 length:16];
        unsigned int v44 = [v222 isEqualToData:v43];

        if (v44)
        {
          id v45 = [objc_alloc((Class)NSData) initWithBytes:&unk_10028431F length:1];
          id v228 = v41;
          unsigned int v46 = a1;
          uint64_t v47 = [a1 getData:128 tag:0 data:v45 error:&v228];
          id v218 = v228;

          if (v47 && [v47 status] == 36864)
          {
            unsigned int v48 = [v47 data];
            int v49 = [v48 NF_asHexString];
            int v50 = [v49 substringWithRange:0, 4];

            if (v50)
            {
              __int16 v51 = v47;
              CFStringRef v52 = @"authenticationCounter";
              id v35 = log;
              goto LABEL_86;
            }
            int v215 = v47;
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v160 = NFLogGetLogger();
            id v35 = log;
            if (v160)
            {
              int v161 = (void (*)(uint64_t, const char *, ...))v160;
              int v162 = object_getClass(a1);
              BOOL v163 = class_isMetaClass(v162);
              __int16 v164 = object_getClassName(a1);
              long long v206 = sel_getName("getGetProtocolV4Container:forApplet:");
              uint64_t v165 = 45;
              if (v163) {
                uint64_t v165 = 43;
              }
              v161(3, "%c[%{public}s %{public}s]:%i Nil auth counter", v165, v164, v206, 1310);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v166 = NFSharedLogGetLogger();
            uint64_t v27 = v224;
            if (!os_log_type_enabled(v166, OS_LOG_TYPE_ERROR)) {
              goto LABEL_140;
            }
            __int16 v167 = object_getClass(a1);
            if (class_isMetaClass(v167)) {
              int v168 = 43;
            }
            else {
              int v168 = 45;
            }
            BOOL v169 = object_getClassName(a1);
            uint64_t v170 = sel_getName("getGetProtocolV4Container:forApplet:");
            *(_DWORD *)long long buf = 67109890;
            int v235 = v168;
            __int16 v236 = 2082;
            uint64_t v237 = v169;
            __int16 v238 = 2082;
            uint64_t v239 = v170;
            __int16 v240 = 1024;
            int v241 = 1310;
            uint64_t v171 = "%c[%{public}s %{public}s]:%i Nil auth counter";
LABEL_139:
            _os_log_impl((void *)&_mh_execute_header, v166, OS_LOG_TYPE_ERROR, v171, buf, 0x22u);
LABEL_140:
            int v109 = v166;
            id v25 = 0;
            BOOL v107 = v215;
            unsigned int v41 = v218;
LABEL_81:
            id v62 = v222;
            uint64_t v26 = v223;
LABEL_154:

            uint64_t v28 = v220;
            goto LABEL_155;
          }
          __int16 v214 = v47;
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v120 = NFLogGetLogger();
          if (v120)
          {
            id v121 = (void (*)(uint64_t, const char *, ...))v120;
            __int16 v122 = object_getClass(a1);
            BOOL v123 = class_isMetaClass(v122);
            __int16 v124 = object_getClassName(a1);
            int v125 = sel_getName("getGetProtocolV4Container:forApplet:");
            uint64_t v209 = [v47 status];
            uint64_t v204 = v125;
            unsigned int v46 = a1;
            uint64_t v126 = 45;
            if (v123) {
              uint64_t v126 = 43;
            }
            v121(3, "%c[%{public}s %{public}s]:%i Failed to execute get auth command: 0x%04x, error = %{public}@", v126, v124, v204, 1301, v209, v218);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          NSErrorUserInfoKey v127 = NFSharedLogGetLogger();
          uint64_t v27 = v224;
          if (os_log_type_enabled(v127, OS_LOG_TYPE_ERROR))
          {
            uint64_t v128 = object_getClass(v46);
            if (class_isMetaClass(v128)) {
              int v129 = 43;
            }
            else {
              int v129 = 45;
            }
            uint64_t v130 = object_getClassName(v46);
            __int16 v131 = sel_getName("getGetProtocolV4Container:forApplet:");
            id v132 = v214;
            unsigned int v133 = [v214 status];
            *(_DWORD *)long long buf = 67110402;
            int v235 = v129;
            __int16 v236 = 2082;
            uint64_t v237 = v130;
            __int16 v238 = 2082;
            uint64_t v239 = v131;
            __int16 v240 = 1024;
            int v241 = 1301;
            __int16 v242 = 1024;
            *(_DWORD *)int v243 = v133;
            *(_WORD *)&void v243[4] = 2114;
            unsigned int v41 = v218;
            *(void *)&v243[6] = v218;
            int v134 = "%c[%{public}s %{public}s]:%i Failed to execute get auth command: 0x%04x, error = %{public}@";
LABEL_108:
            _os_log_impl((void *)&_mh_execute_header, v127, OS_LOG_TYPE_ERROR, v134, buf, 0x32u);
            id v25 = 0;
            int v109 = v127;
            BOOL v107 = v132;
LABEL_110:
            id v62 = v222;
            uint64_t v26 = v223;
            id v35 = log;
            goto LABEL_154;
          }
        }
        else
        {
          id v227 = v41;
          uint64_t v110 = a1;
          uint64_t v111 = [a1 sendCommandWithClass:128 instruction:241 p1:0 p2:0 data:0 error:&v227];
          id v218 = v227;

          if (v111 && [v111 status] == 36864)
          {
            NSErrorUserInfoKey v112 = [v111 data];
            int v50 = [v112 NF_asHexString];

            id v35 = log;
            if (v50)
            {
              __int16 v51 = v111;
              CFStringRef v52 = @"appletSignedState";
LABEL_86:
              [v35 setObject:v50 forKeyedSubscript:v52];

              int v113 = [v11 objectForKeyedSubscript:@"ssdAid"];
              uint64_t v114 = +[NSData NF_dataWithHexString:v113];

              id v226 = v218;
              int v213 = v114;
              uint64_t v115 = [a1 selectByName:v114 error:&v226];
              unsigned int v41 = v226;

              int v219 = v115;
              if ([v115 status] == 36864)
              {
                unsigned int v116 = sub_10018C0BC(a1, 0);
                int v117 = [v116 objectForKeyedSubscript:@"ssdKeyVersionNumber"];
                uint64_t v27 = v224;
                if ([v117 count])
                {
                  __int16 v118 = [v117 objectAtIndexedSubscript:0];
                  id v119 = [objc_alloc((Class)NSString) initWithFormat:@"%02lX", [v118 integerValue]];
                  [log setObject:v119 forKeyedSubscript:@"kvn"];

                  id v35 = log;
                  uint64_t v26 = v223;
                  [v223 addObject:log];
                  id v25 = v223;
LABEL_152:
                  id v62 = v222;
                  int v109 = v213;
                  goto LABEL_153;
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v182 = NFLogGetLogger();
                if (v182)
                {
                  id v183 = (void (*)(uint64_t, const char *, ...))v182;
                  uint64_t v184 = object_getClass(a1);
                  BOOL v185 = class_isMetaClass(v184);
                  int v186 = object_getClassName(a1);
                  uint64_t v208 = sel_getName("getGetProtocolV4Container:forApplet:");
                  uint64_t v187 = 45;
                  if (v185) {
                    uint64_t v187 = 43;
                  }
                  uint64_t v198 = v186;
                  id v35 = log;
                  v183(3, "%c[%{public}s %{public}s]:%i No KVN found", v187, v198, v208, 1367);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                NSErrorUserInfoKey v188 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v188, OS_LOG_TYPE_ERROR))
                {
                  id v189 = object_getClass(a1);
                  loga = v188;
                  if (class_isMetaClass(v189)) {
                    int v190 = 43;
                  }
                  else {
                    int v190 = 45;
                  }
                  int v191 = object_getClassName(a1);
                  uint64_t v192 = sel_getName("getGetProtocolV4Container:forApplet:");
                  *(_DWORD *)long long buf = 67109890;
                  int v235 = v190;
                  NSErrorUserInfoKey v188 = loga;
                  __int16 v236 = 2082;
                  uint64_t v237 = v191;
                  __int16 v238 = 2082;
                  uint64_t v239 = v192;
                  __int16 v240 = 1024;
                  int v241 = 1367;
                  _os_log_impl((void *)&_mh_execute_header, loga, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i No KVN found", buf, 0x22u);
                }

                id v25 = 0;
              }
              else
              {
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v147 = NFLogGetLogger();
                if (v147)
                {
                  id v148 = (void (*)(uint64_t, const char *, ...))v147;
                  id v149 = object_getClass(a1);
                  BOOL v150 = class_isMetaClass(v149);
                  id v151 = object_getClassName(a1);
                  id v152 = sel_getName("getGetProtocolV4Container:forApplet:");
                  uint64_t v212 = [v219 status];
                  long long v197 = v151;
                  uint64_t v153 = 45;
                  if (v150) {
                    uint64_t v153 = 43;
                  }
                  id v35 = log;
                  v148(3, "%c[%{public}s %{public}s]:%i Failed to select SSD %{public}@: 0x%04x, error = %{public}@", v153, v197, v152, 1350, v213, v212, v41);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                BOOL v154 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v154, OS_LOG_TYPE_ERROR))
                {
                  id v155 = object_getClass(a1);
                  if (class_isMetaClass(v155)) {
                    int v156 = 43;
                  }
                  else {
                    int v156 = 45;
                  }
                  uint64_t v157 = object_getClassName(a1);
                  id v158 = sel_getName("getGetProtocolV4Container:forApplet:");
                  unsigned int v159 = [v219 status];
                  *(_DWORD *)long long buf = 67110658;
                  int v235 = v156;
                  __int16 v236 = 2082;
                  uint64_t v237 = v157;
                  __int16 v238 = 2082;
                  uint64_t v239 = v158;
                  id v35 = log;
                  __int16 v240 = 1024;
                  int v241 = 1350;
                  __int16 v242 = 2114;
                  *(void *)int v243 = v213;
                  *(_WORD *)&v243[8] = 1024;
                  *(_DWORD *)&v243[10] = v159;
                  __int16 v244 = 2114;
                  uint64_t v245 = v41;
                  _os_log_impl((void *)&_mh_execute_header, v154, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select SSD %{public}@: 0x%04x, error = %{public}@", buf, 0x3Cu);
                }

                id v25 = 0;
                uint64_t v27 = v224;
              }
              uint64_t v26 = v223;
              goto LABEL_152;
            }
            int v215 = v111;
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v172 = NFLogGetLogger();
            if (v172)
            {
              v173 = (void (*)(uint64_t, const char *, ...))v172;
              int v174 = object_getClass(a1);
              BOOL v175 = class_isMetaClass(v174);
              uint64_t v176 = object_getClassName(a1);
              BOOL v207 = sel_getName("getGetProtocolV4Container:forApplet:");
              uint64_t v177 = 45;
              if (v175) {
                uint64_t v177 = 43;
              }
              v173(3, "%c[%{public}s %{public}s]:%i appletSignedState does not exist", v177, v176, v207, 1337);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v166 = NFSharedLogGetLogger();
            uint64_t v27 = v224;
            if (!os_log_type_enabled(v166, OS_LOG_TYPE_ERROR)) {
              goto LABEL_140;
            }
            id v178 = object_getClass(a1);
            if (class_isMetaClass(v178)) {
              int v179 = 43;
            }
            else {
              int v179 = 45;
            }
            uint64_t v180 = object_getClassName(a1);
            id v181 = sel_getName("getGetProtocolV4Container:forApplet:");
            *(_DWORD *)long long buf = 67109890;
            int v235 = v179;
            __int16 v236 = 2082;
            uint64_t v237 = v180;
            __int16 v238 = 2082;
            uint64_t v239 = v181;
            __int16 v240 = 1024;
            int v241 = 1337;
            uint64_t v171 = "%c[%{public}s %{public}s]:%i appletSignedState does not exist";
            goto LABEL_139;
          }
          __int16 v214 = v111;
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v135 = NFLogGetLogger();
          if (v135)
          {
            id v136 = (void (*)(uint64_t, const char *, ...))v135;
            id v137 = object_getClass(a1);
            BOOL v138 = class_isMetaClass(v137);
            id v139 = object_getClassName(a1);
            id v140 = sel_getName("getGetProtocolV4Container:forApplet:");
            uint64_t v210 = [v111 status];
            uint64_t v205 = v140;
            uint64_t v110 = a1;
            uint64_t v141 = 45;
            if (v138) {
              uint64_t v141 = 43;
            }
            v136(3, "%c[%{public}s %{public}s]:%i Failed to execute get applet signed state command: 0x%04x, error = %{public}@", v141, v139, v205, 1328, v210, v218);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          NSErrorUserInfoKey v127 = NFSharedLogGetLogger();
          uint64_t v27 = v224;
          if (os_log_type_enabled(v127, OS_LOG_TYPE_ERROR))
          {
            id v142 = object_getClass(v110);
            if (class_isMetaClass(v142)) {
              int v143 = 43;
            }
            else {
              int v143 = 45;
            }
            int v144 = object_getClassName(v110);
            id v145 = sel_getName("getGetProtocolV4Container:forApplet:");
            id v132 = v214;
            unsigned int v146 = [v214 status];
            *(_DWORD *)long long buf = 67110402;
            int v235 = v143;
            __int16 v236 = 2082;
            uint64_t v237 = v144;
            __int16 v238 = 2082;
            uint64_t v239 = v145;
            __int16 v240 = 1024;
            int v241 = 1328;
            __int16 v242 = 1024;
            *(_DWORD *)int v243 = v146;
            *(_WORD *)&void v243[4] = 2114;
            unsigned int v41 = v218;
            *(void *)&v243[6] = v218;
            int v134 = "%c[%{public}s %{public}s]:%i Failed to execute get applet signed state command: 0x%04x, error = %{public}@";
            goto LABEL_108;
          }
        }
        id v25 = 0;
        int v109 = v127;
        BOOL v107 = v214;
        unsigned int v41 = v218;
        goto LABEL_110;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v84 = NFLogGetLogger();
      if (v84)
      {
        id v85 = (void (*)(uint64_t, const char *, ...))v84;
        id v86 = object_getClass(a1);
        BOOL v87 = class_isMetaClass(v86);
        unsigned int v88 = object_getClassName(a1);
        uint64_t v203 = sel_getName("getGetProtocolV4Container:forApplet:");
        uint64_t v89 = 45;
        if (v87) {
          uint64_t v89 = 43;
        }
        v85(3, "%c[%{public}s %{public}s]:%i ContainersAppletAID does not exist in container", v89, v88, v203, 1279);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      unsigned int v41 = NFSharedLogGetLogger();
      uint64_t v27 = v224;
      if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      {
LABEL_71:
        id v25 = 0;
        id v62 = v222;
        uint64_t v26 = v223;
LABEL_155:

LABEL_156:
        id v20 = v6;
        goto LABEL_157;
      }
      unsigned int v90 = object_getClass(a1);
      if (class_isMetaClass(v90)) {
        int v91 = 43;
      }
      else {
        int v91 = 45;
      }
      id v92 = object_getClassName(a1);
      __int16 v93 = sel_getName("getGetProtocolV4Container:forApplet:");
      *(_DWORD *)long long buf = 67109890;
      int v235 = v91;
      __int16 v236 = 2082;
      uint64_t v237 = v92;
      __int16 v238 = 2082;
      uint64_t v239 = v93;
      __int16 v240 = 1024;
      int v241 = 1279;
      uint64_t v83 = "%c[%{public}s %{public}s]:%i ContainersAppletAID does not exist in container";
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v73 = NFLogGetLogger();
      uint64_t v27 = v224;
      if (v73)
      {
        char v74 = (void (*)(uint64_t, const char *, ...))v73;
        uint64_t v75 = object_getClass(a1);
        BOOL v76 = class_isMetaClass(v75);
        uint64_t v77 = object_getClassName(a1);
        long long v202 = sel_getName("getGetProtocolV4Container:forApplet:");
        uint64_t v78 = 45;
        if (v76) {
          uint64_t v78 = 43;
        }
        v74(3, "%c[%{public}s %{public}s]:%i SSDCounter does not exist in container", v78, v77, v202, 1271);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      unsigned int v41 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v41, OS_LOG_TYPE_ERROR)) {
        goto LABEL_71;
      }
      int v79 = object_getClass(a1);
      if (class_isMetaClass(v79)) {
        int v80 = 43;
      }
      else {
        int v80 = 45;
      }
      uint64_t v81 = object_getClassName(a1);
      int v82 = sel_getName("getGetProtocolV4Container:forApplet:");
      *(_DWORD *)long long buf = 67109890;
      int v235 = v80;
      __int16 v236 = 2082;
      uint64_t v237 = v81;
      __int16 v238 = 2082;
      uint64_t v239 = v82;
      __int16 v240 = 1024;
      int v241 = 1271;
      uint64_t v83 = "%c[%{public}s %{public}s]:%i SSDCounter does not exist in container";
    }
    _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, v83, buf, 0x22u);
    goto LABEL_71;
  }
LABEL_9:

  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v14 = NFLogGetLogger();
  if (v14)
  {
    long long v15 = (void (*)(uint64_t, const char *, ...))v14;
    long long v16 = object_getClass(a1);
    BOOL v17 = class_isMetaClass(v16);
    id v18 = object_getClassName(a1);
    id v199 = sel_getName("getGetProtocolV4Container:forApplet:");
    uint64_t v19 = 45;
    if (v17) {
      uint64_t v19 = 43;
    }
    v15(3, "%c[%{public}s %{public}s]:%i No matching whitelisted applet found", v19, v18, v199, 1376);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v20 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
  {
    id v21 = object_getClass(a1);
    if (class_isMetaClass(v21)) {
      int v22 = 43;
    }
    else {
      int v22 = 45;
    }
    unint64_t v23 = object_getClassName(a1);
    __int16 v24 = sel_getName("getGetProtocolV4Container:forApplet:");
    *(_DWORD *)long long buf = 67109890;
    int v235 = v22;
    __int16 v236 = 2082;
    uint64_t v237 = v23;
    __int16 v238 = 2082;
    uint64_t v239 = v24;
    __int16 v240 = 1024;
    int v241 = 1376;
    _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i No matching whitelisted applet found", buf, 0x22u);
  }
  id v25 = 0;
  uint64_t v26 = v223;
  uint64_t v27 = v224;
LABEL_157:

  return v25;
}

id sub_10018C0BC(void *a1, int a2)
{
  id v4 = [a1 getData:224];
  if (!v4)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v19 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("_getKeyInfo:");
      uint64_t v23 = 45;
      if (isMetaClass) {
        uint64_t v23 = 43;
      }
      v19(3, "%c[%{public}s %{public}s]:%i Failed to get key information template", v23, ClassName, Name, 339);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    long long v16 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      __int16 v24 = object_getClass(a1);
      if (class_isMetaClass(v24)) {
        int v25 = 43;
      }
      else {
        int v25 = 45;
      }
      *(_DWORD *)long long buf = 67109890;
      int v87 = v25;
      __int16 v88 = 2082;
      uint64_t v89 = object_getClassName(a1);
      __int16 v90 = 2082;
      int v91 = sel_getName("_getKeyInfo:");
      __int16 v92 = 1024;
      int v93 = 339;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get key information template", buf, 0x22u);
    }
    BOOL v17 = 0;
    goto LABEL_26;
  }
  id v5 = +[NFTLV TLVsWithData:v4];
  if ((unint64_t)[v5 count] < 3
    || 0xAAAAAAAAAAAAAAABLL * (unint64_t)[v5 count] > 0x5555555555555555)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v6 = NFLogGetLogger();
    if (v6)
    {
      id v7 = (void (*)(uint64_t, const char *, ...))v6;
      id v8 = object_getClass(a1);
      BOOL v9 = class_isMetaClass(v8);
      uint64_t v10 = object_getClassName(a1);
      long long v72 = sel_getName("_getKeyInfo:");
      uint64_t v11 = 45;
      if (v9) {
        uint64_t v11 = 43;
      }
      v7(3, "%c[%{public}s %{public}s]:%i Invalid key set", v11, v10, v72, 348);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v12 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    long long v13 = object_getClass(a1);
    if (class_isMetaClass(v13)) {
      int v14 = 43;
    }
    else {
      int v14 = 45;
    }
    *(_DWORD *)long long buf = 67109890;
    int v87 = v14;
    __int16 v88 = 2082;
    uint64_t v89 = object_getClassName(a1);
    __int16 v90 = 2082;
    int v91 = sel_getName("_getKeyInfo:");
    __int16 v92 = 1024;
    int v93 = 348;
    long long v15 = "%c[%{public}s %{public}s]:%i Invalid key set";
LABEL_13:
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, v15, buf, 0x22u);
LABEL_14:

    long long v16 = 0;
    BOOL v17 = 0;
    goto LABEL_15;
  }
  if (![v5 count])
  {
LABEL_63:
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v62 = NFLogGetLogger();
    if (v62)
    {
      uint64_t v63 = (void (*)(uint64_t, const char *, ...))v62;
      id v64 = object_getClass(a1);
      BOOL v65 = class_isMetaClass(v64);
      BOOL v66 = object_getClassName(a1);
      BOOL v76 = sel_getName("_getKeyInfo:");
      uint64_t v67 = 45;
      if (v65) {
        uint64_t v67 = 43;
      }
      v63(3, "%c[%{public}s %{public}s]:%i Failed to get key information template", v67, v66, v76, 385);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v12 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v12, OS_LOG_TYPE_ERROR)) {
      goto LABEL_14;
    }
    uint64_t v68 = object_getClass(a1);
    if (class_isMetaClass(v68)) {
      int v69 = 43;
    }
    else {
      int v69 = 45;
    }
    int v70 = object_getClassName(a1);
    id v71 = sel_getName("_getKeyInfo:");
    *(_DWORD *)long long buf = 67109890;
    int v87 = v69;
    __int16 v88 = 2082;
    uint64_t v89 = v70;
    __int16 v90 = 2082;
    int v91 = v71;
    __int16 v92 = 1024;
    int v93 = 385;
    long long v15 = "%c[%{public}s %{public}s]:%i Failed to get key information template";
    goto LABEL_13;
  }
  int v77 = a2;
  uint64_t v78 = v4;
  int v79 = 0;
  uint64_t v27 = 0;
  do
  {
    uint64_t v28 = [v5 objectAtIndexedSubscript:v27];
    uint64_t v29 = [v5 objectAtIndexedSubscript:v27 + 1];
    uint64_t v30 = v27 + 2;
    id v31 = [v5 objectAtIndexedSubscript:v27 + 2];
    if ([v28 tag] == 192
      && [v29 tag] == 192
      && [v31 tag] == 192)
    {
      __int16 v81 = 0;
      unsigned __int8 v80 = 0;
      unsigned __int8 v32 = [v28 value];
      [v32 getBytes:&v81 + 1 range:1];

      uint64_t v33 = [v29 value];
      [v33 getBytes:&v81 range:1];

      unsigned __int8 v34 = [v31 value];
      [v34 getBytes:&v80 range:1];

      if (HIBYTE(v81) == v81 && HIBYTE(v81) == v80)
      {
        if (v79)
        {
          id v35 = +[NSNumber numberWithUnsignedChar:](NSNumber, "numberWithUnsignedChar:");
          uint64_t v36 = [v79 arrayByAddingObject:v35];

          int v79 = v36;
        }
        else
        {
          id v59 = objc_alloc((Class)NSArray);
          id v35 = +[NSNumber numberWithUnsignedChar:HIBYTE(v81)];
          int v79 = [v59 initWithObjects:v35, 0];
        }
      }
      else
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v49 = NFLogGetLogger();
        if (v49)
        {
          int v50 = (void (*)(uint64_t, const char *, ...))v49;
          __int16 v51 = object_getClass(a1);
          BOOL v52 = class_isMetaClass(v51);
          uint64_t v53 = object_getClassName(a1);
          uint64_t v75 = sel_getName("_getKeyInfo:");
          uint64_t v54 = 45;
          if (v52) {
            uint64_t v54 = 43;
          }
          v50(3, "%c[%{public}s %{public}s]:%i Inconsistent KVN in keyset", v54, v53, v75, 373);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v35 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          uint64_t v55 = object_getClass(a1);
          if (class_isMetaClass(v55)) {
            int v56 = 43;
          }
          else {
            int v56 = 45;
          }
          uint64_t v57 = object_getClassName(a1);
          int v58 = sel_getName("_getKeyInfo:");
          *(_DWORD *)long long buf = 67109890;
          int v87 = v56;
          __int16 v88 = 2082;
          uint64_t v89 = v57;
          __int16 v90 = 2082;
          int v91 = v58;
          __int16 v92 = 1024;
          int v93 = 373;
          uint64_t v47 = v35;
          unsigned int v48 = "%c[%{public}s %{public}s]:%i Inconsistent KVN in keyset";
LABEL_47:
          _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, v48, buf, 0x22u);
        }
      }
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v37 = NFLogGetLogger();
      if (v37)
      {
        id v38 = (void (*)(uint64_t, const char *, ...))v37;
        uint64_t v39 = object_getClass(a1);
        BOOL v40 = class_isMetaClass(v39);
        unsigned int v41 = object_getClassName(a1);
        char v74 = sel_getName("_getKeyInfo:");
        uint64_t v42 = 45;
        if (v40) {
          uint64_t v42 = 43;
        }
        v38(3, "%c[%{public}s %{public}s]:%i Invalid data format", v42, v41, v74, 360);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v35 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        id v43 = object_getClass(a1);
        if (class_isMetaClass(v43)) {
          int v44 = 43;
        }
        else {
          int v44 = 45;
        }
        id v45 = object_getClassName(a1);
        unsigned int v46 = sel_getName("_getKeyInfo:");
        *(_DWORD *)long long buf = 67109890;
        int v87 = v44;
        __int16 v88 = 2082;
        uint64_t v89 = v45;
        __int16 v90 = 2082;
        int v91 = v46;
        __int16 v92 = 1024;
        int v93 = 360;
        uint64_t v47 = v35;
        unsigned int v48 = "%c[%{public}s %{public}s]:%i Invalid data format";
        goto LABEL_47;
      }
    }

    uint64_t v27 = v30 + 1;
  }
  while ((unint64_t)[v5 count] > v30 + 1);
  id v4 = v78;
  long long v16 = v79;
  if (!v79) {
    goto LABEL_63;
  }
  if (v77)
  {
    CFStringRef v84 = @"isdKeyVersionNumber";
    id v85 = v79;
    id v60 = &v85;
    id v61 = &v84;
  }
  else
  {
    CFStringRef v82 = @"ssdKeyVersionNumber";
    uint64_t v83 = v79;
    id v60 = &v83;
    id v61 = &v82;
  }
  BOOL v17 = +[NSDictionary dictionaryWithObjects:v60 forKeys:v61 count:1];
LABEL_15:

LABEL_26:

  return v17;
}

void sub_10018C950(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  id v7 = [a1 selectByName:v5 error:0];
  if ([v7 status] == 36864)
  {
    id v8 = [a1 getData:193];
    BOOL v9 = v8;
    if (v8)
    {
      uint64_t v10 = [v8 NF_asHexString];
      [v6 setObject:v10 forKey:@"ssdCounter"];
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        int v22 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(a1);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(a1);
        Name = sel_getName("_addEntriesFromSSD:intoApp:");
        uint64_t v25 = 45;
        if (isMetaClass) {
          uint64_t v25 = 43;
        }
        v22(3, "%c[%{public}s %{public}s]:%i Failed to get sequence counter: %{public}@", v25, ClassName, Name, 1210, v5);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v26 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        uint64_t v27 = object_getClass(a1);
        if (class_isMetaClass(v27)) {
          int v28 = 43;
        }
        else {
          int v28 = 45;
        }
        *(_DWORD *)long long buf = 67110146;
        int v73 = v28;
        __int16 v74 = 2082;
        uint64_t v75 = object_getClassName(a1);
        __int16 v76 = 2082;
        int v77 = sel_getName("_addEntriesFromSSD:intoApp:");
        __int16 v78 = 1024;
        int v79 = 1210;
        __int16 v80 = 2114;
        id v81 = v5;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get sequence counter: %{public}@", buf, 0x2Cu);
      }

      BOOL v9 = 0;
    }
    uint64_t v29 = [a1 getData:254 subtag:57136];
    uint64_t v30 = v29;
    if (v29)
    {
      id v31 = [v29 NF_asHexString];
      [v6 setObject:v31 forKey:@"obgk"];
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v32 = NFLogGetLogger();
      if (v32)
      {
        uint64_t v33 = (void (*)(uint64_t, const char *, ...))v32;
        unsigned __int8 v34 = object_getClass(a1);
        BOOL v35 = class_isMetaClass(v34);
        id v64 = object_getClassName(a1);
        uint64_t v68 = sel_getName("_addEntriesFromSSD:intoApp:");
        uint64_t v36 = 45;
        if (v35) {
          uint64_t v36 = 43;
        }
        v33(3, "%c[%{public}s %{public}s]:%i Failed to get OBGK: %{public}@", v36, v64, v68, 1217, v5);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v31 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        uint64_t v37 = object_getClass(a1);
        if (class_isMetaClass(v37)) {
          int v38 = 43;
        }
        else {
          int v38 = 45;
        }
        uint64_t v39 = object_getClassName(a1);
        BOOL v40 = sel_getName("_addEntriesFromSSD:intoApp:");
        *(_DWORD *)long long buf = 67110146;
        int v73 = v38;
        __int16 v74 = 2082;
        uint64_t v75 = v39;
        __int16 v76 = 2082;
        int v77 = v40;
        __int16 v78 = 1024;
        int v79 = 1217;
        __int16 v80 = 2114;
        id v81 = v5;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get OBGK: %{public}@", buf, 0x2Cu);
      }
    }

    unsigned int v41 = [a1 getData:32545];

    if (v41)
    {
      uint64_t v42 = +[NFTLV TLVWithTag:147 fromData:v41];
      id v43 = [v42 value];

      if (v43)
      {
        int v44 = [v43 NF_asHexString];
        [v6 setObject:v44 forKey:@"certSN"];

LABEL_58:
        goto LABEL_59;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v54 = NFLogGetLogger();
      if (v54)
      {
        uint64_t v55 = (void (*)(uint64_t, const char *, ...))v54;
        int v56 = object_getClass(a1);
        BOOL v57 = class_isMetaClass(v56);
        BOOL v66 = object_getClassName(a1);
        int v70 = sel_getName("_addEntriesFromSSD:intoApp:");
        uint64_t v58 = 45;
        if (v57) {
          uint64_t v58 = 43;
        }
        v55(3, "%c[%{public}s %{public}s]:%i Failed to get certificate serial number: %{public}@", v58, v66, v70, 1229, v5);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v43 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
        goto LABEL_58;
      }
      id v59 = object_getClass(a1);
      if (class_isMetaClass(v59)) {
        int v60 = 43;
      }
      else {
        int v60 = 45;
      }
      id v61 = object_getClassName(a1);
      uint64_t v62 = sel_getName("_addEntriesFromSSD:intoApp:");
      *(_DWORD *)long long buf = 67110146;
      int v73 = v60;
      __int16 v74 = 2082;
      uint64_t v75 = v61;
      __int16 v76 = 2082;
      int v77 = v62;
      __int16 v78 = 1024;
      int v79 = 1229;
      __int16 v80 = 2114;
      id v81 = v5;
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v45 = NFLogGetLogger();
      if (v45)
      {
        unsigned int v46 = (void (*)(uint64_t, const char *, ...))v45;
        uint64_t v47 = object_getClass(a1);
        BOOL v48 = class_isMetaClass(v47);
        BOOL v65 = object_getClassName(a1);
        int v69 = sel_getName("_addEntriesFromSSD:intoApp:");
        uint64_t v49 = 45;
        if (v48) {
          uint64_t v49 = 43;
        }
        v46(3, "%c[%{public}s %{public}s]:%i Failed to get certificate serial number: %{public}@", v49, v65, v69, 1225, v5);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v43 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v43, OS_LOG_TYPE_ERROR)) {
        goto LABEL_58;
      }
      int v50 = object_getClass(a1);
      if (class_isMetaClass(v50)) {
        int v51 = 43;
      }
      else {
        int v51 = 45;
      }
      BOOL v52 = object_getClassName(a1);
      uint64_t v53 = sel_getName("_addEntriesFromSSD:intoApp:");
      *(_DWORD *)long long buf = 67110146;
      int v73 = v51;
      __int16 v74 = 2082;
      uint64_t v75 = v52;
      __int16 v76 = 2082;
      int v77 = v53;
      __int16 v78 = 1024;
      int v79 = 1225;
      __int16 v80 = 2114;
      id v81 = v5;
    }
    _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get certificate serial number: %{public}@", buf, 0x2Cu);
    goto LABEL_58;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v11 = NFLogGetLogger();
  if (v11)
  {
    id v12 = (void (*)(uint64_t, const char *, ...))v11;
    long long v13 = object_getClass(a1);
    BOOL v14 = class_isMetaClass(v13);
    long long v15 = object_getClassName(a1);
    long long v16 = sel_getName("_addEntriesFromSSD:intoApp:");
    uint64_t v71 = [v7 status];
    uint64_t v17 = 45;
    if (v14) {
      uint64_t v17 = 43;
    }
    v12(3, "%c[%{public}s %{public}s]:%i Failed to select SSD %{public}@: 0x%04x", v17, v15, v16, 1196, v5, v71);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v18 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    uint64_t v19 = object_getClass(a1);
    if (class_isMetaClass(v19)) {
      int v20 = 43;
    }
    else {
      int v20 = 45;
    }
    *(_DWORD *)long long buf = 67110402;
    int v73 = v20;
    __int16 v74 = 2082;
    uint64_t v75 = object_getClassName(a1);
    __int16 v76 = 2082;
    int v77 = sel_getName("_addEntriesFromSSD:intoApp:");
    __int16 v78 = 1024;
    int v79 = 1196;
    __int16 v80 = 2114;
    id v81 = v5;
    __int16 v82 = 1024;
    unsigned int v83 = [v7 status];
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to select SSD %{public}@: 0x%04x", buf, 0x32u);
  }

  if ([v7 status] == 27033) {
    [v6 setObject:&__kCFBooleanTrue forKeyedSubscript:@"ssdIsLocked"];
  }
LABEL_59:
}

void sub_10018D148(uint64_t a1)
{
}

void sub_10018D150(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v4 = +[NFTLV TLVSsWithBytes:a2 length:a3 requireDefiniteEncoding:1];
  long long v113 = 0u;
  long long v114 = 0u;
  long long v115 = 0u;
  long long v116 = 0u;
  id v95 = [v4 countByEnumeratingWithState:&v113 objects:v123 count:16];
  if (v95)
  {
    uint64_t v94 = *(void *)v114;
    id v5 = &AMFDRSealingMapCopyLocalData_ptr;
    id v6 = &AMFDRSealingMapCopyLocalData_ptr;
    uint64_t v98 = a1;
    __int16 v92 = v4;
    do
    {
      uint64_t v7 = 0;
      do
      {
        if (*(void *)v114 != v94) {
          objc_enumerationMutation(v4);
        }
        uint64_t v96 = v7;
        id v8 = *(void **)(*((void *)&v113 + 1) + 8 * v7);
        BOOL v97 = [v8 childWithTag:79];
        if (!v97)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t Logger = NFLogGetLogger();
          if (Logger)
          {
            uint64_t v32 = (void (*)(uint64_t, const char *, ...))Logger;
            Class = object_getClass(*(id *)(a1 + 32));
            BOOL isMetaClass = class_isMetaClass(Class);
            ClassName = object_getClassName(*(id *)(a1 + 32));
            Name = sel_getName(*(SEL *)(a1 + 72));
            uint64_t v36 = 45;
            if (isMetaClass) {
              uint64_t v36 = 43;
            }
            v32(3, "%c[%{public}s %{public}s]:%i Missing AID tag", v36, ClassName, Name, 846);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v12 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
          {
            uint64_t v37 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v37)) {
              int v38 = 43;
            }
            else {
              int v38 = 45;
            }
            uint64_t v39 = object_getClassName(*(id *)(a1 + 32));
            BOOL v40 = sel_getName(*(SEL *)(a1 + 72));
            *(_DWORD *)long long buf = 67109890;
            int v125 = v38;
            __int16 v126 = 2082;
            NSErrorUserInfoKey v127 = v39;
            __int16 v128 = 2082;
            int v129 = v40;
            __int16 v130 = 1024;
            int v131 = 846;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Missing AID tag", buf, 0x22u);
          }
          goto LABEL_90;
        }
        if (!*(unsigned char *)(a1 + 80)
          || (BOOL v9 = *(void **)(a1 + 40),
              [v97 value],
              uint64_t v10 = objc_claimAutoreleasedReturnValue(),
              LOBYTE(v9) = [v9 containsObject:v10],
              v10,
              (v9 & 1) == 0))
        {
          uint64_t v11 = [v8 childWithTag:197];
          id v12 = v11;
          if (!v11
            || ([v11 value],
                long long v13 = objc_claimAutoreleasedReturnValue(),
                id v14 = [v13 length],
                v13,
                (unint64_t)v14 >= 5))
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v15 = NFLogGetLogger();
            if (v15)
            {
              long long v16 = (void (*)(uint64_t, const char *, ...))v15;
              uint64_t v17 = object_getClass(*(id *)(a1 + 32));
              BOOL v18 = class_isMetaClass(v17);
              uint64_t v19 = object_getClassName(*(id *)(a1 + 32));
              int v20 = sel_getName(*(SEL *)(a1 + 72));
              id v21 = [v12 value];
              id v91 = [v21 length];
              uint64_t v22 = 45;
              if (v18) {
                uint64_t v22 = 43;
              }
              v16(3, "%c[%{public}s %{public}s]:%i Missing or too long privilege tag 0xC5 %lu", v22, v19, v20, 860, v91);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v23 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            {
              __int16 v24 = object_getClass(*(id *)(a1 + 32));
              uint64_t v25 = v4;
              if (class_isMetaClass(v24)) {
                int v26 = 43;
              }
              else {
                int v26 = 45;
              }
              uint64_t v27 = object_getClassName(*(id *)(a1 + 32));
              int v28 = sel_getName(*(SEL *)(a1 + 72));
              uint64_t v29 = [v12 value];
              id v30 = [v29 length];
              *(_DWORD *)long long buf = 67110146;
              int v125 = v26;
              id v4 = v25;
              __int16 v126 = 2082;
              NSErrorUserInfoKey v127 = v27;
              __int16 v128 = 2082;
              int v129 = v28;
              __int16 v130 = 1024;
              int v131 = 860;
              __int16 v132 = 2048;
              id v133 = v30;
              _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Missing or too long privilege tag 0xC5 %lu", buf, 0x2Cu);
            }
            goto LABEL_89;
          }
          int v93 = v12;
          unsigned int v41 = [v12 valueAsUnsignedLong];
          if ((v41 & 0x800000) != 0)
          {
            if ((~v41 & 0xC10000) != 0)
            {
              if ((v41 & 0x540) == 0)
              {
                __int16 v88 = *(void **)(*(void *)(*(void *)(a1 + 56) + 8) + 40);
                uint64_t v23 = [v97 valueAsHexString];
                [v88 addObject:v23];
                goto LABEL_89;
              }
            }
            else
            {
              int v87 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
              uint64_t v23 = [v97 valueAsHexString];
              [v87 addObject:v23];
LABEL_88:
              id v12 = v93;
LABEL_89:
            }
LABEL_90:

            goto LABEL_91;
          }
          uint64_t v23 = [objc_alloc((Class)NSMutableDictionary) initWithCapacity:18];
          long long v109 = 0u;
          long long v110 = 0u;
          long long v111 = 0u;
          long long v112 = 0u;
          uint64_t v42 = [v8 children];
          id v104 = [v42 countByEnumeratingWithState:&v109 objects:v122 count:16];
          if (!v104) {
            goto LABEL_85;
          }
          uint64_t v43 = *(void *)v110;
          __int16 v100 = v23;
          int v102 = v42;
          uint64_t v103 = *(void *)v110;
          while (2)
          {
            uint64_t v44 = 0;
LABEL_33:
            if (*(void *)v110 != v43) {
              objc_enumerationMutation(v42);
            }
            uint64_t v45 = *(void **)(*((void *)&v109 + 1) + 8 * v44);
            int v46 = [v45 tag];
            if (v46 <= 164)
            {
              if (v46 <= 159)
              {
                if (v46 == 79)
                {
                  BOOL v52 = [v45 valueAsHexString];
                  uint64_t v53 = v23;
                  uint64_t v54 = v52;
                  CFStringRef v55 = @"appletAid";
                }
                else
                {
                  if (v46 != 132) {
                    goto LABEL_83;
                  }
                  BOOL v52 = [v45 valueAsHexString];
                  uint64_t v53 = v23;
                  uint64_t v54 = v52;
                  CFStringRef v55 = @"moduleAid";
                }
                goto LABEL_81;
              }
              if (v46 == 160)
              {
                BOOL v65 = [v45 childWithTag:79];
                BOOL v52 = v65;
                if (!v65) {
                  BOOL v65 = v45;
                }
                BOOL v66 = [v65 valueAsHexString];
                [v23 setObject:v66 forKeyedSubscript:@"primaryContainer"];

                goto LABEL_82;
              }
              if (v46 == 164)
              {
                id v56 = objc_alloc((Class)v5[451]);
                BOOL v57 = [v45 children];
                id v58 = [v56 initWithCapacity:[v57 count]];

                long long v107 = 0u;
                long long v108 = 0u;
                long long v105 = 0u;
                long long v106 = 0u;
                id v59 = [v45 children];
                id v60 = [v59 countByEnumeratingWithState:&v105 objects:v121 count:16];
                if (v60)
                {
                  id v61 = v60;
                  uint64_t v62 = *(void *)v106;
                  do
                  {
                    for (i = 0; i != v61; i = (char *)i + 1)
                    {
                      if (*(void *)v106 != v62) {
                        objc_enumerationMutation(v59);
                      }
                      id v64 = [*(id *)(*((void *)&v105 + 1) + 8 * i) valueAsHexString];
                      [v58 addObject:v64];
                    }
                    id v61 = [v59 countByEnumeratingWithState:&v105 objects:v121 count:16];
                  }
                  while (v61);
                }

                uint64_t v23 = v100;
                [v100 setObject:v58 forKeyedSubscript:@"auxilaryContainers"];

                uint64_t v42 = v102;
                uint64_t v43 = v103;
              }
            }
            else
            {
              if (v46 > 203)
              {
                if (v46 == 204)
                {
                  BOOL v52 = [v45 valueAsHexString];
                  uint64_t v53 = v23;
                  uint64_t v54 = v52;
                  CFStringRef v55 = @"associatedSSD";
                }
                else
                {
                  if (v46 != 218)
                  {
                    if (v46 == 40816)
                    {
                      uint64_t v47 = [v45 value];
                      id v48 = [v47 length];

                      if (v48)
                      {
                        uint64_t v49 = v6[459];
                        id v50 = [v45 value];
                        int v51 = [v49 numberWithUnsignedChar:*(unsigned __int8 *)[v50 bytes]];
                        [v23 setObject:v51 forKeyedSubscript:@"lifeCycleState"];
                      }
                    }
                    goto LABEL_83;
                  }
                  BOOL v52 = [v45 valueAsHexString];
                  uint64_t v53 = v23;
                  uint64_t v54 = v52;
                  CFStringRef v55 = @"appletPresentmentACL";
                }
LABEL_81:
                [v53 setObject:v54 forKeyedSubscript:v55];
LABEL_82:

                goto LABEL_83;
              }
              if (v46 != 165)
              {
                if (v46 != 196) {
                  goto LABEL_83;
                }
                BOOL v52 = [v45 valueAsHexString];
                uint64_t v53 = v23;
                uint64_t v54 = v52;
                CFStringRef v55 = @"packageAid";
                goto LABEL_81;
              }
              uint64_t v67 = [v45 valueAsHexString];
              [v23 setObject:v67 forKeyedSubscript:@"discretionaryData"];

              uint64_t v68 = *(void *)(a1 + 32);
              id v69 = v45;
              int v70 = v23;
              if (v68)
              {
                uint64_t v71 = [v69 childWithTag:254];
                long long v72 = [v71 childWithTag:57152];

                if (v72)
                {
                  int v73 = [v72 valueAsHexString];
                  [v70 setObject:v73 forKeyedSubscript:@"extendedFunction"];

                  LODWORD(v73) = [v72 valueAsUnsignedShort];
                  __int16 v74 = [v6[459] numberWithBool:(v73 >> 2) & 1];
                  [v70 setObject:v74 forKeyedSubscript:@"containerInstance"];

                  uint64_t v75 = [v6[459] numberWithBool:(v73 >> 3) & 1];
                  [v70 setObject:v75 forKeyedSubscript:@"proxyInstance"];
                }
                uint64_t v101 = v72;
                __int16 v76 = [v69 childWithTag:204];
                int v77 = v76;
                if (v76)
                {
                  __int16 v78 = [v76 valueAsHexString];
                  [v70 setObject:v78 forKeyedSubscript:@"ssdAid"];
                }
                int v79 = [v69 childrenWithTag:221];
                if ([v79 count])
                {
                  id v99 = v69;
                  id v80 = [objc_alloc((Class)v5[451]) initWithCapacity:objc_msgSend(v79, "count")];
                  long long v117 = 0u;
                  long long v118 = 0u;
                  long long v119 = 0u;
                  long long v120 = 0u;
                  id v81 = v79;
                  id v82 = [v81 countByEnumeratingWithState:&v117 objects:buf count:16];
                  if (v82)
                  {
                    id v83 = v82;
                    uint64_t v84 = *(void *)v118;
                    do
                    {
                      for (j = 0; j != v83; j = (char *)j + 1)
                      {
                        if (*(void *)v118 != v84) {
                          objc_enumerationMutation(v81);
                        }
                        id v86 = [*(id *)(*((void *)&v117 + 1) + 8 * (void)j) valueAsHexString];
                        [v80 addObject:v86];
                      }
                      id v83 = [v81 countByEnumeratingWithState:&v117 objects:buf count:16];
                    }
                    while (v83);
                  }

                  [v70 setObject:v80 forKeyedSubscript:@"multiSEApplicationGroup"];
                  a1 = v98;
                  id v69 = v99;
                  id v5 = &AMFDRSealingMapCopyLocalData_ptr;
                  id v6 = &AMFDRSealingMapCopyLocalData_ptr;
                  uint64_t v23 = v100;
                }

                uint64_t v42 = v102;
              }

              uint64_t v43 = v103;
            }
LABEL_83:
            if ((id)++v44 == v104)
            {
              id v104 = [v42 countByEnumeratingWithState:&v109 objects:v122 count:16];
              if (!v104)
              {
LABEL_85:

                [*(id *)(*(void *)(*(void *)(a1 + 64) + 8) + 40) addObject:v23];
                id v4 = v92;
                goto LABEL_88;
              }
              continue;
            }
            goto LABEL_33;
          }
        }
LABEL_91:

        uint64_t v7 = v96 + 1;
      }
      while ((id)(v96 + 1) != v95);
      id v89 = [v4 countByEnumeratingWithState:&v113 objects:v123 count:16];
      id v95 = v89;
    }
    while (v89);
  }
}

id sub_10018DC58(void *a1, uint64_t a2, uint64_t a3, unint64_t a4, void *a5)
{
  BOOL v9 = a5;
  if (!a1)
  {
    id v17 = 0;
    goto LABEL_23;
  }
  __int16 v52 = 79;
  char v53 = 92;
  char v54 = a4;
  char v51 = 3;
  if (a4 >= 0x100)
  {
    id v10 = objc_alloc((Class)NSError);
    id v11 = +[NSString stringWithUTF8String:"nfcd"];
    v67[0] = NSLocalizedDescriptionKey;
    id v12 = +[NSString stringWithUTF8String:"Invalid Parameter"];
    v68[0] = v12;
    v68[1] = &off_10031C9C0;
    v67[1] = @"Line";
    v67[2] = @"Method";
    id v13 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("sendProprietaryGetStatusCommand:tagList:tagListLen:callback:")];
    v68[2] = v13;
    v67[3] = NSDebugDescriptionErrorKey;
    id v14 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("sendProprietaryGetStatusCommand:tagList:tagListLen:callback:"), 1111];
    v68[3] = v14;
    v67[4] = NSLocalizedFailureReasonErrorKey;
    id v15 = [objc_alloc((Class)NSString) initWithFormat:@"Tag list length too long"];
    void v68[4] = v15;
    long long v16 = +[NSDictionary dictionaryWithObjects:v68 forKeys:v67 count:5];
    id v17 = [v10 initWithDomain:v11 code:10 userInfo:v16];

    goto LABEL_21;
  }
  BOOL v18 = +[NFCommandAPDU buildAPDUHeaderWithClass:128 instruction:175 p1:a2 p2:2 len:(a4 + 4) useExtendedLength:1];
  if (!v18)
  {
    id v24 = objc_alloc((Class)NSError);
    id v11 = +[NSString stringWithUTF8String:"nfcd"];
    v65[0] = NSLocalizedDescriptionKey;
    id v12 = +[NSString stringWithUTF8String:"No resources"];
    v66[0] = v12;
    v66[1] = &off_10031C9D8;
    v65[1] = @"Line";
    v65[2] = @"Method";
    id v13 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("sendProprietaryGetStatusCommand:tagList:tagListLen:callback:")];
    v66[2] = v13;
    v65[3] = NSDebugDescriptionErrorKey;
    id v14 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("sendProprietaryGetStatusCommand:tagList:tagListLen:callback:"), 1122];
    v66[3] = v14;
    id v15 = +[NSDictionary dictionaryWithObjects:v66 forKeys:v65 count:4];
    id v17 = [v24 initWithDomain:v11 code:34 userInfo:v15];
    goto LABEL_21;
  }
  uint64_t v19 = v18;
  [v18 appendBytes:&v52 length:4];
  [v19 appendBytes:a3 length:a4];
  uint64_t v20 = +[NFCommandAPDU appendExpectedLength:0 usingExtendedLength:1 toAPDU:v19];
  if (v20)
  {
    id v11 = (id)v20;
    id v21 = objc_alloc((Class)NSError);
    id v13 = +[NSString stringWithUTF8String:"nfcd"];
    id v22 = [v11 code];
    v63[0] = NSLocalizedDescriptionKey;
    uint64_t v49 = v9;
    if ((uint64_t)[v11 code] > 70) {
      uint64_t v23 = 71;
    }
    else {
      uint64_t v23 = (uint64_t)[v11 code];
    }
    id v14 = +[NSString stringWithUTF8String:(&off_100306178)[v23]];
    v64[0] = v14;
    v64[1] = v11;
    v63[1] = NSUnderlyingErrorKey;
    v63[2] = @"Line";
    v64[2] = &off_10031C9F0;
    v63[3] = @"Method";
    id v15 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("sendProprietaryGetStatusCommand:tagList:tagListLen:callback:")];
    v64[3] = v15;
    v63[4] = NSDebugDescriptionErrorKey;
    id v32 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", @"sendProprietaryGetStatusCommand:tagList:tagListLen:callback:", 1129];
    v64[4] = v32;
    uint64_t v33 = +[NSDictionary dictionaryWithObjects:v64 forKeys:v63 count:5];
    id v17 = [v21 initWithDomain:v13 code:v22 userInfo:v33];

LABEL_20:
    id v12 = v19;
    BOOL v9 = v49;
    goto LABEL_21;
  }
  id v25 = [objc_alloc((Class)NSData) initWithBytes:&unk_100284184 length:8];
  unsigned int v26 = [a1 select:v25 error:0];

  if (v26)
  {
    uint64_t v49 = v9;
    while (1)
    {
      id v50 = 0;
      id v13 = [a1 transceiveData:v19 toOS:0 error:&v50];
      id v11 = v50;
      if (v11) {
        break;
      }
      if (!v13 || (unint64_t)[v13 length] <= 1)
      {
        id v48 = objc_alloc((Class)NSError);
        id v14 = +[NSString stringWithUTF8String:"nfcd"];
        v57[0] = NSLocalizedDescriptionKey;
        id v15 = +[NSString stringWithUTF8String:"Commmand Error"];
        v58[0] = v15;
        v58[1] = &off_10031CA38;
        v57[1] = @"Line";
        v57[2] = @"Method";
        id v38 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("sendProprietaryGetStatusCommand:tagList:tagListLen:callback:")];
        v58[2] = v38;
        v57[3] = NSDebugDescriptionErrorKey;
        id v39 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("sendProprietaryGetStatusCommand:tagList:tagListLen:callback:"), 1145];
        v58[3] = v39;
        void v57[4] = NSLocalizedFailureReasonErrorKey;
        id v40 = [objc_alloc((Class)NSString) initWithFormat:@"Null or too-short response"];
        void v58[4] = v40;
        unsigned int v41 = v58;
        uint64_t v42 = v57;
LABEL_28:
        uint64_t v43 = +[NSDictionary dictionaryWithObjects:v41 forKeys:v42 count:5];
        id v17 = [v48 initWithDomain:v14 code:16 userInfo:v43];

        goto LABEL_33;
      }
      id v27 = v13;
      int v28 = (char *)[v27 bytes];
      unsigned int v29 = *(unsigned __int16 *)&v28[(void)[v27 length] - 2];
      uint64_t v30 = __rev16(v29);
      if (v30 != 25360 && v30 != 36864)
      {
        id v48 = objc_alloc((Class)NSError);
        id v14 = +[NSString stringWithUTF8String:"nfcd"];
        v55[0] = NSLocalizedDescriptionKey;
        id v15 = +[NSString stringWithUTF8String:"Commmand Error"];
        v56[0] = v15;
        v56[1] = &off_10031CA50;
        v55[1] = @"Line";
        void v55[2] = @"Method";
        id v38 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("sendProprietaryGetStatusCommand:tagList:tagListLen:callback:")];
        void v56[2] = v38;
        v55[3] = NSDebugDescriptionErrorKey;
        id v39 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("sendProprietaryGetStatusCommand:tagList:tagListLen:callback:"), 1149];
        v56[3] = v39;
        void v55[4] = NSLocalizedFailureReasonErrorKey;
        id v40 = [objc_alloc((Class)NSString) initWithFormat:@"error status word 0x%hx", v30];
        void v56[4] = v40;
        unsigned int v41 = v56;
        uint64_t v42 = v55;
        goto LABEL_28;
      }
      id v31 = v27;
      BOOL v9 = v49;
      v49[2](v49, [v31 bytes], (char *)[v31 length] - 2);

      [v19 replaceBytesInRange:3 withBytes:&v51 length:1];
      if (v29 != 4195)
      {
        id v17 = 0;
        goto LABEL_22;
      }
    }
    id v44 = objc_alloc((Class)NSError);
    id v14 = +[NSString stringWithUTF8String:"nfcd"];
    id v45 = [v11 code];
    v59[0] = NSLocalizedDescriptionKey;
    id v47 = v45;
    if ((uint64_t)[v11 code] > 70) {
      uint64_t v46 = 71;
    }
    else {
      uint64_t v46 = (uint64_t)[v11 code];
    }
    id v15 = +[NSString stringWithUTF8String:(&off_100306178)[v46]];
    v60[0] = v15;
    v60[1] = v11;
    v59[1] = NSUnderlyingErrorKey;
    v59[2] = @"Line";
    v60[2] = &off_10031CA20;
    v59[3] = @"Method";
    id v38 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("sendProprietaryGetStatusCommand:tagList:tagListLen:callback:")];
    v60[3] = v38;
    void v59[4] = NSDebugDescriptionErrorKey;
    id v39 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("sendProprietaryGetStatusCommand:tagList:tagListLen:callback:"), 1142];
    void v60[4] = v39;
    id v40 = +[NSDictionary dictionaryWithObjects:v60 forKeys:v59 count:5];
    id v17 = [v44 initWithDomain:v14 code:v47 userInfo:v40];
LABEL_33:

    goto LABEL_20;
  }
  id v35 = objc_alloc((Class)NSError);
  id v12 = +[NSString stringWithUTF8String:"nfcd"];
  v61[0] = NSLocalizedDescriptionKey;
  id v13 = +[NSString stringWithUTF8String:"Commmand Error"];
  v62[0] = v13;
  v62[1] = &off_10031CA08;
  v61[1] = @"Line";
  v61[2] = @"Method";
  id v14 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("sendProprietaryGetStatusCommand:tagList:tagListLen:callback:")];
  v62[2] = v14;
  v61[3] = NSDebugDescriptionErrorKey;
  id v15 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("sendProprietaryGetStatusCommand:tagList:tagListLen:callback:"), 1133];
  v62[3] = v15;
  void v61[4] = NSLocalizedFailureReasonErrorKey;
  id v36 = [objc_alloc((Class)NSString) initWithFormat:@"Failed to select ISD"];
  v62[4] = v36;
  uint64_t v37 = +[NSDictionary dictionaryWithObjects:v62 forKeys:v61 count:5];
  id v17 = [v35 initWithDomain:v12 code:16 userInfo:v37];

  id v11 = v19;
LABEL_21:

  uint64_t v19 = v11;
LABEL_22:

LABEL_23:

  return v17;
}

uint64_t sub_10018E830(uint64_t a1, void *a2)
{
  id v3 = a2;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  id v4 = *(id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40);
  id v5 = [v4 countByEnumeratingWithState:&v13 objects:v17 count:16];
  if (v5)
  {
    id v6 = v5;
    uint64_t v7 = *(void *)v14;
    while (2)
    {
      id v8 = 0;
      do
      {
        if (*(void *)v14 != v7) {
          objc_enumerationMutation(v4);
        }
        BOOL v9 = [*(id *)(*((void *)&v13 + 1) + 8 * (void)v8) objectForKeyedSubscript:@"associatedSSD"];
        unsigned __int8 v10 = [v9 isEqualToString:v3];

        if (v10)
        {
          uint64_t v11 = 0;
          goto LABEL_11;
        }
        id v8 = (char *)v8 + 1;
      }
      while (v6 != v8);
      id v6 = [v4 countByEnumeratingWithState:&v13 objects:v17 count:16];
      if (v6) {
        continue;
      }
      break;
    }
  }
  uint64_t v11 = 1;
LABEL_11:

  return v11;
}

void sub_10018E97C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  +[NFTLV TLVSsWithBytes:a2 length:a3 requireDefiniteEncoding:1];
  long long v103 = 0u;
  long long v104 = 0u;
  long long v105 = 0u;
  long long v106 = 0u;
  id obj = (id)objc_claimAutoreleasedReturnValue();
  id v4 = [obj countByEnumeratingWithState:&v103 objects:v120 count:16];
  if (v4)
  {
    id v5 = v4;
    uint64_t v6 = *(void *)v104;
    uint64_t v91 = *(void *)v104;
    do
    {
      uint64_t v7 = 0;
      id v92 = v5;
      do
      {
        if (*(void *)v104 != v6) {
          objc_enumerationMutation(obj);
        }
        id v8 = *(void **)(*((void *)&v103 + 1) + 8 * (void)v7);
        BOOL v9 = [v8 childWithTag:79];
        unsigned __int8 v10 = v9;
        if (v9)
        {
          uint64_t v11 = [v9 valueAsHexString];
          BOOL v97 = v10;
          if (*(unsigned char *)(a1 + 72)
            && (id v12 = *(void **)(a1 + 40),
                [v10 value],
                long long v13 = objc_claimAutoreleasedReturnValue(),
                LODWORD(v12) = [v12 containsObject:v13],
                v13,
                v12))
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t Logger = NFLogGetLogger();
            if (Logger)
            {
              long long v15 = (void (*)(uint64_t, const char *, ...))Logger;
              Class = object_getClass(*(id *)(a1 + 32));
              BOOL isMetaClass = class_isMetaClass(Class);
              ClassName = object_getClassName(*(id *)(a1 + 32));
              Name = sel_getName(*(SEL *)(a1 + 64));
              uint64_t v18 = 45;
              if (isMetaClass) {
                uint64_t v18 = 43;
              }
              v15(3, "%c[%{public}s %{public}s]:%i Hiding package AID %{public}@", v18, ClassName, Name, 1035, v11);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t v19 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
            {
              uint64_t v20 = object_getClass(*(id *)(a1 + 32));
              if (class_isMetaClass(v20)) {
                int v21 = 43;
              }
              else {
                int v21 = 45;
              }
              id v22 = object_getClassName(*(id *)(a1 + 32));
              uint64_t v23 = sel_getName(*(SEL *)(a1 + 64));
              *(_DWORD *)long long buf = 67110146;
              int v108 = v21;
              __int16 v109 = 2082;
              long long v110 = v22;
              __int16 v111 = 2082;
              long long v112 = v23;
              __int16 v113 = 1024;
              int v114 = 1035;
              __int16 v115 = 2114;
              long long v116 = v11;
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Hiding package AID %{public}@", buf, 0x2Cu);
            }
          }
          else
          {
            uint64_t v98 = v11;
            uint64_t v94 = v8;
            id v24 = [v8 childrenWithTag:132];
            id v25 = [objc_alloc((Class)NSMutableArray) initWithCapacity:[v24 count]];
            long long v99 = 0u;
            long long v100 = 0u;
            long long v101 = 0u;
            long long v102 = 0u;
            uint64_t v19 = v24;
            id v26 = [v19 countByEnumeratingWithState:&v99 objects:v119 count:16];
            if (v26)
            {
              id v27 = v26;
              uint64_t v28 = *(void *)v100;
LABEL_20:
              uint64_t v29 = 0;
              while (1)
              {
                if (*(void *)v100 != v28) {
                  objc_enumerationMutation(v19);
                }
                uint64_t v30 = *(void **)(*((void *)&v99 + 1) + 8 * v29);
                if (*(unsigned char *)(a1 + 72))
                {
                  id v31 = *(void **)(a1 + 48);
                  id v32 = [*(id *)(*((void *)&v99 + 1) + 8 * v29) value];
                  LODWORD(v31) = [v31 containsObject:v32];

                  if (v31) {
                    break;
                  }
                }
                uint64_t v33 = [v30 valueAsHexString];
                [v25 addObject:v33];

                if (v27 == (id)++v29)
                {
                  id v27 = [v19 countByEnumeratingWithState:&v99 objects:v119 count:16];
                  if (v27) {
                    goto LABEL_20;
                  }
                  goto LABEL_27;
                }
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v44 = NFLogGetLogger();
              if (v44)
              {
                id v45 = (void (*)(uint64_t, const char *, ...))v44;
                uint64_t v46 = object_getClass(*(id *)(a1 + 32));
                BOOL v47 = class_isMetaClass(v46);
                id v48 = object_getClassName(*(id *)(a1 + 32));
                uint64_t v49 = sel_getName(*(SEL *)(a1 + 64));
                id v50 = [v30 valueAsHexString];
                uint64_t v51 = 45;
                if (v47) {
                  uint64_t v51 = 43;
                }
                v45(6, "%c[%{public}s %{public}s]:%i Hiding package %{public}@ / module %{public}@", v51, v48, v49, 1044, v98, v50);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              __int16 v52 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
              {
                char v53 = object_getClass(*(id *)(a1 + 32));
                if (class_isMetaClass(v53)) {
                  int v54 = 43;
                }
                else {
                  int v54 = 45;
                }
                CFStringRef v55 = object_getClassName(*(id *)(a1 + 32));
                id v56 = sel_getName(*(SEL *)(a1 + 64));
                BOOL v57 = [v30 valueAsHexString];
                *(_DWORD *)long long buf = 67110402;
                int v108 = v54;
                __int16 v109 = 2082;
                long long v110 = v55;
                __int16 v111 = 2082;
                long long v112 = v56;
                __int16 v113 = 1024;
                int v114 = 1044;
                __int16 v115 = 2114;
                long long v116 = v98;
                __int16 v117 = 2114;
                long long v118 = v57;
                _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Hiding package %{public}@ / module %{public}@", buf, 0x36u);
              }
              uint64_t v11 = v98;
              if (*(unsigned char *)(a1 + 72)) {
                goto LABEL_76;
              }
            }
            else
            {
LABEL_27:

              uint64_t v11 = v98;
            }
            id v58 = [objc_alloc((Class)NSMutableDictionary) initWithObjectsAndKeys:v11, @"packageAid", v25, @"moduleAids", 0];
            id v59 = [v94 childWithTag:206];
            id v60 = v59;
            if (v59)
            {
              id v61 = [v59 valueAsHexString];
              if (v61)
              {
                [v58 setObject:v61 forKeyedSubscript:@"version"];
              }
              else
              {
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v62 = NFLogGetLogger();
                if (v62)
                {
                  uint64_t v63 = (void (*)(uint64_t, const char *, ...))v62;
                  id v64 = object_getClass(*(id *)(a1 + 32));
                  BOOL v65 = class_isMetaClass(v64);
                  id v85 = object_getClassName(*(id *)(a1 + 32));
                  id v89 = sel_getName(*(SEL *)(a1 + 64));
                  uint64_t v66 = 45;
                  if (v65) {
                    uint64_t v66 = 43;
                  }
                  v63(4, "%c[%{public}s %{public}s]:%i Missing package version info %{public}@", v66, v85, v89, 1064, v98);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v67 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
                {
                  uint64_t v68 = object_getClass(*(id *)(a1 + 32));
                  if (class_isMetaClass(v68)) {
                    int v69 = 43;
                  }
                  else {
                    int v69 = 45;
                  }
                  int v70 = object_getClassName(*(id *)(a1 + 32));
                  uint64_t v71 = sel_getName(*(SEL *)(a1 + 64));
                  *(_DWORD *)long long buf = 67110146;
                  int v108 = v69;
                  __int16 v109 = 2082;
                  long long v110 = v70;
                  __int16 v111 = 2082;
                  long long v112 = v71;
                  __int16 v113 = 1024;
                  int v114 = 1064;
                  __int16 v115 = 2114;
                  long long v116 = v98;
                  _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Missing package version info %{public}@", buf, 0x2Cu);
                }
              }
            }
            long long v72 = [v94 childWithTag:204];
            int v73 = v72;
            if (v72)
            {
              __int16 v74 = [v72 valueAsHexString];
              if (v74)
              {
                [v58 setObject:v74 forKeyedSubscript:@"associatedSSD"];
              }
              else
              {
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v75 = NFLogGetLogger();
                if (v75)
                {
                  __int16 v76 = (void (*)(uint64_t, const char *, ...))v75;
                  int v77 = object_getClass(*(id *)(a1 + 32));
                  BOOL v95 = class_isMetaClass(v77);
                  id v86 = object_getClassName(*(id *)(a1 + 32));
                  __int16 v90 = sel_getName(*(SEL *)(a1 + 64));
                  uint64_t v78 = 45;
                  if (v95) {
                    uint64_t v78 = 43;
                  }
                  v76(4, "%c[%{public}s %{public}s]:%i Missing associated SSD String info %{public}@", v78, v86, v90, 1075, v98);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                int v79 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
                {
                  id v80 = object_getClass(*(id *)(a1 + 32));
                  if (class_isMetaClass(v80)) {
                    int v81 = 43;
                  }
                  else {
                    int v81 = 45;
                  }
                  int v96 = v81;
                  id v82 = object_getClassName(*(id *)(a1 + 32));
                  id v83 = sel_getName(*(SEL *)(a1 + 64));
                  *(_DWORD *)long long buf = 67110146;
                  int v108 = v96;
                  __int16 v109 = 2082;
                  long long v110 = v82;
                  __int16 v111 = 2082;
                  long long v112 = v83;
                  __int16 v113 = 1024;
                  int v114 = 1075;
                  __int16 v115 = 2114;
                  long long v116 = v98;
                  _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Missing associated SSD String info %{public}@", buf, 0x2Cu);
                }
              }
            }
            [*(id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40) addObject:v58];

            uint64_t v11 = v98;
LABEL_76:

            uint64_t v6 = v91;
            id v5 = v92;
          }

          unsigned __int8 v10 = v97;
        }
        else
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v34 = NFLogGetLogger();
          if (v34)
          {
            id v35 = (void (*)(uint64_t, const char *, ...))v34;
            id v36 = object_getClass(*(id *)(a1 + 32));
            BOOL v37 = class_isMetaClass(v36);
            id v38 = object_getClassName(*(id *)(a1 + 32));
            __int16 v88 = sel_getName(*(SEL *)(a1 + 64));
            uint64_t v39 = 45;
            if (v37) {
              uint64_t v39 = 43;
            }
            v35(3, "%c[%{public}s %{public}s]:%i Missing packgeTag?!", v39, v38, v88, 1030);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v11 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          {
            id v40 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v40)) {
              int v41 = 43;
            }
            else {
              int v41 = 45;
            }
            uint64_t v42 = object_getClassName(*(id *)(a1 + 32));
            uint64_t v43 = sel_getName(*(SEL *)(a1 + 64));
            *(_DWORD *)long long buf = 67109890;
            int v108 = v41;
            __int16 v109 = 2082;
            long long v110 = v42;
            __int16 v111 = 2082;
            long long v112 = v43;
            __int16 v113 = 1024;
            int v114 = 1030;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Missing packgeTag?!", buf, 0x22u);
          }
        }

        uint64_t v7 = (char *)v7 + 1;
      }
      while (v7 != v5);
      id v5 = [obj countByEnumeratingWithState:&v103 objects:v120 count:16];
    }
    while (v5);
  }
}

void sub_10018F3CC(id a1)
{
  id v3 = [[NFSecureTransactionServicesHandoverBaseSessionInterface alloc] initWithProtocol:&OBJC_PROTOCOL___NFSecureTransactionServicesHandoverBaseSessionInterface];
  uint64_t v1 = [(NFSecureTransactionServicesHandoverBaseSessionInterface *)v3 protocolInterface];
  uint64_t v2 = (void *)qword_1003474E8;
  qword_1003474E8 = v1;
}

void sub_10018F520(id a1)
{
  id v3 = [[NFSecureTransactionServicesHandoverBaseSessionCallbacksInterface alloc] initWithProtocol:&OBJC_PROTOCOL___NFSecureTransactionServicesHandoverBaseSessionCallbacksInterface];
  uint64_t v1 = [(NFSecureTransactionServicesHandoverBaseSessionCallbacksInterface *)v3 protocolInterface];
  uint64_t v2 = (void *)qword_1003474F8;
  qword_1003474F8 = v1;
}

id sub_10018F854(uint64_t a1, void *a2)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = *(void **)(a1 + 56);
  id v3 = [a2 UID];
  id v4 = [v2 objectForKey:v3];

  id v5 = [v4 objectForKey:@"type"];
  uint64_t v6 = v5;
  if (v5) {
    id v7 = [v5 unsignedIntValue];
  }
  else {
    id v7 = 0;
  }

  return v7;
}

id sub_10018F904(uint64_t a1, void *a2)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = *(void **)(a1 + 56);
  id v3 = [a2 UID];
  id v4 = [v2 objectForKey:v3];

  id v5 = [v4 objectForKey:@"tagHandle"];
  uint64_t v6 = v5;
  if (v5) {
    id v7 = [v5 pointerValue];
  }
  else {
    id v7 = 0;
  }

  return v7;
}

uint64_t sub_10018FAE8(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  if (a1)
  {
    id v6 = a1;
    objc_sync_enter(v6);
    if (*((unsigned char *)v6 + 137))
    {
      uint64_t v7 = 3;
    }
    else
    {
      BOOL v9 = malloc_type_calloc(1uLL, 0x60uLL, 0x108004063299CC8uLL);
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (Logger)
      {
        Class = object_getClass(v6);
        if (class_isMetaClass(Class)) {
          uint64_t v12 = 43;
        }
        else {
          uint64_t v12 = 45;
        }
        ClassName = object_getClassName(v6);
        Name = sel_getName("connectTag:updatedTag:");
        Logger(6, "%c[%{public}s %{public}s]:%i Connecting to tag: %{public}@", v12, ClassName, Name, 93, v5);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      long long v15 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        long long v16 = object_getClass(v6);
        if (class_isMetaClass(v16)) {
          int v17 = 43;
        }
        else {
          int v17 = 45;
        }
        *(_DWORD *)long long buf = 67110146;
        int v33 = v17;
        __int16 v34 = 2082;
        id v35 = object_getClassName(v6);
        __int16 v36 = 2082;
        BOOL v37 = sel_getName("connectTag:updatedTag:");
        __int16 v38 = 1024;
        int v39 = 93;
        __int16 v40 = 2114;
        id v41 = v5;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Connecting to tag: %{public}@", buf, 0x2Cu);
      }

      sub_10018F904((uint64_t)v6, v5);
      int v18 = NFDriverRemoteDevConnect();
      if (v18)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v19 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v19)
        {
          uint64_t v20 = object_getClass(v6);
          if (class_isMetaClass(v20)) {
            uint64_t v21 = 43;
          }
          else {
            uint64_t v21 = 45;
          }
          id v22 = object_getClassName(v6);
          uint64_t v23 = sel_getName("connectTag:updatedTag:");
          v19(3, "%c[%{public}s %{public}s]:%i Failed to connect to tag: %{public}@", v21, v22, v23, 100, v5);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v24 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
        {
          id v25 = object_getClass(v6);
          if (class_isMetaClass(v25)) {
            int v26 = 43;
          }
          else {
            int v26 = 45;
          }
          id v27 = object_getClassName(v6);
          uint64_t v28 = sel_getName("connectTag:updatedTag:");
          *(_DWORD *)long long buf = 67110146;
          int v33 = v26;
          __int16 v34 = 2082;
          id v35 = v27;
          __int16 v36 = 2082;
          BOOL v37 = v28;
          __int16 v38 = 1024;
          int v39 = 100;
          __int16 v40 = 2114;
          id v41 = v5;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to connect to tag: %{public}@", buf, 0x2Cu);
        }

        if (v9) {
          free(v9);
        }
        switch(v18)
        {
          case 4:
            uint64_t v7 = 35;
            break;
          case 18:
            uint64_t v7 = 51;
            break;
          case 23:
            uint64_t v7 = 64;
            break;
          default:
            uint64_t v7 = 28;
            break;
        }
      }
      else
      {
        if (a3)
        {
          *a3 = [v6 _refreshTagInfo:v5 update:v9];
        }
        if (v9) {
          free(v9);
        }
        uint64_t v29 = (void *)*((void *)v6 + 6);
        *((void *)v6 + 6) = 0;

        if ([v6 _isEMVPolling])
        {
          dispatch_semaphore_t v30 = dispatch_semaphore_create(0);
          id v31 = (void *)*((void *)v6 + 6);
          *((void *)v6 + 6) = v30;
        }
        uint64_t v7 = 0;
      }
    }
    objc_sync_exit(v6);
  }
  else
  {
    uint64_t v7 = 0;
  }

  return v7;
}

void sub_10018FED4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1001900C4(void *a1, void *a2, unsigned int a3)
{
  id v5 = a2;
  if (a1)
  {
    id v6 = a1;
    objc_sync_enter(v6);
    if (*((unsigned char *)v6 + 137))
    {
      uint64_t v7 = 3;
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (Logger)
      {
        Class = object_getClass(v6);
        if (class_isMetaClass(Class)) {
          uint64_t v10 = 43;
        }
        else {
          uint64_t v10 = 45;
        }
        ClassName = object_getClassName(v6);
        Name = sel_getName("disconnectTag:tagRemovalDetect:");
        Logger(6, "%c[%{public}s %{public}s]:%i disconnecting from tag: %{public}@, tagRemovalDetect=%d", v10, ClassName, Name, 157, v5, a3);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      long long v13 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        long long v14 = object_getClass(v6);
        if (class_isMetaClass(v14)) {
          int v15 = 43;
        }
        else {
          int v15 = 45;
        }
        *(_DWORD *)long long buf = 67110402;
        int v41 = v15;
        __int16 v42 = 2082;
        uint64_t v43 = object_getClassName(v6);
        __int16 v44 = 2082;
        id v45 = sel_getName("disconnectTag:tagRemovalDetect:");
        __int16 v46 = 1024;
        int v47 = 157;
        __int16 v48 = 2114;
        id v49 = v5;
        __int16 v50 = 1024;
        unsigned int v51 = a3;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i disconnecting from tag: %{public}@, tagRemovalDetect=%d", buf, 0x32u);
      }

      if ((*((void *)v6 + 34) & 0x8000000) != 0
        || (sub_10018F904((uint64_t)v6, v5), int v16 = NFDriverRemoteDevDisconnect(), v16 == 19))
      {
        [v6 _cardRemovalDetect:v5];
        sub_10018F904((uint64_t)v6, v5);
        int v16 = NFDriverRemoteDevDisconnect();
      }
      if (!a3 || v16)
      {
        uint64_t v7 = 0;
        if (v16 && v16 != 6)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v28 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v28)
          {
            uint64_t v29 = object_getClass(v6);
            if (class_isMetaClass(v29)) {
              uint64_t v30 = 43;
            }
            else {
              uint64_t v30 = 45;
            }
            id v31 = object_getClassName(v6);
            id v32 = sel_getName("disconnectTag:tagRemovalDetect:");
            v28(3, "%c[%{public}s %{public}s]:%i Failed to disconnect tag: %{public}@", v30, v31, v32, 186, v5);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          int v33 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
          {
            __int16 v34 = object_getClass(v6);
            if (class_isMetaClass(v34)) {
              int v35 = 43;
            }
            else {
              int v35 = 45;
            }
            __int16 v36 = object_getClassName(v6);
            BOOL v37 = sel_getName("disconnectTag:tagRemovalDetect:");
            *(_DWORD *)long long buf = 67110146;
            int v41 = v35;
            __int16 v42 = 2082;
            uint64_t v43 = v36;
            __int16 v44 = 2082;
            id v45 = v37;
            __int16 v46 = 1024;
            int v47 = 186;
            __int16 v48 = 2114;
            id v49 = v5;
            _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to disconnect tag: %{public}@", buf, 0x2Cu);
          }

          if (v16 == 18) {
            uint64_t v7 = 51;
          }
          else {
            uint64_t v7 = 15;
          }
        }
      }
      else
      {
        if (*((void *)v6 + 6))
        {
          if ([v6 _isEMVPolling])
          {
            dispatch_time_t v17 = dispatch_time(0, 300000000000);
            if (dispatch_semaphore_wait(*((dispatch_semaphore_t *)v6 + 6), v17))
            {
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              int v18 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
              if (v18)
              {
                uint64_t v19 = object_getClass(v6);
                if (class_isMetaClass(v19)) {
                  uint64_t v20 = 43;
                }
                else {
                  uint64_t v20 = 45;
                }
                uint64_t v21 = object_getClassName(v6);
                id v22 = sel_getName("disconnectTag:tagRemovalDetect:");
                v18(3, "%c[%{public}s %{public}s]:%i Timeout on tag remove", v20, v21, v22, 181);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v23 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
              {
                id v24 = object_getClass(v6);
                if (class_isMetaClass(v24)) {
                  int v25 = 43;
                }
                else {
                  int v25 = 45;
                }
                int v26 = object_getClassName(v6);
                id v27 = sel_getName("disconnectTag:tagRemovalDetect:");
                *(_DWORD *)long long buf = 67109890;
                int v41 = v25;
                __int16 v42 = 2082;
                uint64_t v43 = v26;
                __int16 v44 = 2082;
                id v45 = v27;
                __int16 v46 = 1024;
                int v47 = 181;
                _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Timeout on tag remove", buf, 0x22u);
              }
            }
          }
        }
        uint64_t v7 = 0;
      }
      if (a3)
      {
        sub_1001E6E4C(*((unsigned char **)v6 + 10), 0);
        if ([*((id *)v6 + 11) readerModeStoppedShouldCooloffRun]) {
          id v38 = sub_10020EC8C(v6, @"Cooloff", 1uLL);
        }
      }
    }
    objc_sync_exit(v6);
  }
  else
  {
    uint64_t v7 = 0;
  }

  return v7;
}

void sub_1001905E4(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100190624(void *a1, void *a2, uint64_t *a3, uint64_t a4)
{
  id v7 = a2;
  if (!a1)
  {
    a4 = 0;
    goto LABEL_44;
  }
  id v8 = a1;
  objc_sync_enter(v8);
  if (!v8[137])
  {
    sub_10018F904((uint64_t)v8, v7);
    int v16 = NFDriverRemoteDevCheckNdef();
    if (!v16)
    {
      if (a4) {
        *(void *)a4 = 0;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (Logger)
      {
        Class = object_getClass(v8);
        if (class_isMetaClass(Class)) {
          uint64_t v28 = 43;
        }
        else {
          uint64_t v28 = 45;
        }
        ClassName = object_getClassName(v8);
        Name = sel_getName("queryTagNDEFCapability:hasNdefAbility:error:");
        if (a3)
        {
          uint64_t v31 = *((unsigned __int8 *)a3 + 16);
          uint64_t v32 = *((unsigned __int8 *)a3 + 17);
          uint64_t v34 = *a3;
          uint64_t v33 = a3[1];
        }
        else
        {
          uint64_t v33 = 0;
          uint64_t v31 = 0;
          uint64_t v32 = 0;
          uint64_t v34 = 0;
        }
        Logger(6, "%c[%{public}s %{public}s]:%i read=%d write=%d capacity=%lu, messageSize=%lu tag=%{public}@", v28, ClassName, Name, 239, v31, v32, v33, v34, v7);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v10 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v36 = object_getClass(v8);
        if (class_isMetaClass(v36)) {
          int v37 = 43;
        }
        else {
          int v37 = 45;
        }
        id v38 = object_getClassName(v8);
        int v39 = sel_getName("queryTagNDEFCapability:hasNdefAbility:error:");
        if (a3)
        {
          int v40 = *((unsigned __int8 *)a3 + 16);
          int v41 = *((unsigned __int8 *)a3 + 17);
          uint64_t v43 = *a3;
          uint64_t v42 = a3[1];
        }
        else
        {
          uint64_t v42 = 0;
          int v40 = 0;
          int v41 = 0;
          uint64_t v43 = 0;
        }
        *(_DWORD *)long long buf = 67111170;
        int v51 = v37;
        __int16 v52 = 2082;
        char v53 = v38;
        __int16 v54 = 2082;
        CFStringRef v55 = v39;
        __int16 v56 = 1024;
        int v57 = 239;
        __int16 v58 = 1024;
        int v59 = v40;
        __int16 v60 = 1024;
        int v61 = v41;
        __int16 v62 = 2048;
        uint64_t v63 = v42;
        __int16 v64 = 2048;
        uint64_t v65 = v43;
        __int16 v66 = 2114;
        id v67 = v7;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i read=%d write=%d capacity=%lu, messageSize=%lu tag=%{public}@", buf, 0x4Cu);
      }
      a4 = 1;
      goto LABEL_42;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    dispatch_time_t v17 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v17)
    {
      int v18 = object_getClass(v8);
      if (class_isMetaClass(v18)) {
        uint64_t v19 = 43;
      }
      else {
        uint64_t v19 = 45;
      }
      uint64_t v20 = object_getClassName(v8);
      uint64_t v21 = sel_getName("queryTagNDEFCapability:hasNdefAbility:error:");
      v17(3, "%c[%{public}s %{public}s]:%i Failed to perform Ndef check", v19, v20, v21, 211);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v22 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      uint64_t v23 = object_getClass(v8);
      if (class_isMetaClass(v23)) {
        int v24 = 43;
      }
      else {
        int v24 = 45;
      }
      *(_DWORD *)long long buf = 67109890;
      int v51 = v24;
      __int16 v52 = 2082;
      char v53 = object_getClassName(v8);
      __int16 v54 = 2082;
      CFStringRef v55 = sel_getName("queryTagNDEFCapability:hasNdefAbility:error:");
      __int16 v56 = 1024;
      int v57 = 211;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to perform Ndef check", buf, 0x22u);
    }

    if (!a4) {
      goto LABEL_43;
    }
    switch(v16)
    {
      case 4:
        id v25 = objc_alloc((Class)NSError);
        uint64_t v10 = +[NSString stringWithUTF8String:"nfcd"];
        v70[0] = NSLocalizedDescriptionKey;
        uint64_t v11 = +[NSString stringWithUTF8String:"SE not available"];
        v71[0] = v11;
        v71[1] = &off_10031CAF8;
        v70[1] = @"Line";
        v70[2] = @"Method";
        id v12 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queryTagNDEFCapability:hasNdefAbility:error:")];
        v71[2] = v12;
        v70[3] = NSDebugDescriptionErrorKey;
        id v13 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", @"queryTagNDEFCapability:hasNdefAbility:error:", 224];
        v71[3] = v13;
        long long v14 = +[NSDictionary dictionaryWithObjects:v71 forKeys:v70 count:4];
        id v15 = [v25 initWithDomain:v10 code:35 userInfo:v14];
        break;
      case 5:
        id v46 = objc_alloc((Class)NSError);
        uint64_t v10 = +[NSString stringWithUTF8String:"nfcd"];
        v78[0] = NSLocalizedDescriptionKey;
        uint64_t v11 = +[NSString stringWithUTF8String:"Invalid Parameter"];
        v79[0] = v11;
        v79[1] = &off_10031CA98;
        v78[1] = @"Line";
        v78[2] = @"Method";
        id v12 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queryTagNDEFCapability:hasNdefAbility:error:")];
        v79[2] = v12;
        v78[3] = NSDebugDescriptionErrorKey;
        id v13 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", @"queryTagNDEFCapability:hasNdefAbility:error:", 216];
        v79[3] = v13;
        long long v14 = +[NSDictionary dictionaryWithObjects:v79 forKeys:v78 count:4];
        id v15 = [v46 initWithDomain:v10 code:10 userInfo:v14];
        break;
      case 6:
        id v47 = objc_alloc((Class)NSError);
        uint64_t v10 = +[NSString stringWithUTF8String:"nfcd"];
        v80[0] = NSLocalizedDescriptionKey;
        uint64_t v11 = +[NSString stringWithUTF8String:"Tag Not Found"];
        v81[0] = v11;
        v81[1] = &off_10031CA80;
        v80[1] = @"Line";
        v80[2] = @"Method";
        id v12 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queryTagNDEFCapability:hasNdefAbility:error:")];
        v81[2] = v12;
        v80[3] = NSDebugDescriptionErrorKey;
        id v13 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("queryTagNDEFCapability:hasNdefAbility:error:"), 214];
        v81[3] = v13;
        long long v14 = +[NSDictionary dictionaryWithObjects:v81 forKeys:v80 count:4];
        id v15 = [v47 initWithDomain:v10 code:28 userInfo:v14];
        break;
      case 7:
      case 8:
      case 9:
      case 10:
      case 11:
        goto LABEL_45;
      case 12:
        id v48 = objc_alloc((Class)NSError);
        uint64_t v10 = +[NSString stringWithUTF8String:"nfcd"];
        v76[0] = NSLocalizedDescriptionKey;
        uint64_t v11 = +[NSString stringWithUTF8String:"Tag Not NDEF formatted"];
        v77[0] = v11;
        v77[1] = &off_10031CAB0;
        v76[1] = @"Line";
        v76[2] = @"Method";
        id v12 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queryTagNDEFCapability:hasNdefAbility:error:")];
        v77[2] = v12;
        v76[3] = NSDebugDescriptionErrorKey;
        id v13 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", @"queryTagNDEFCapability:hasNdefAbility:error:", 218];
        void v77[3] = v13;
        long long v14 = +[NSDictionary dictionaryWithObjects:v77 forKeys:v76 count:4];
        id v15 = [v48 initWithDomain:v10 code:37 userInfo:v14];
        break;
      default:
        if (v16 == 18)
        {
          id v49 = objc_alloc((Class)NSError);
          uint64_t v10 = +[NSString stringWithUTF8String:"nfcd"];
          v74[0] = NSLocalizedDescriptionKey;
          uint64_t v11 = +[NSString stringWithUTF8String:"RF Deactivated"];
          v75[0] = v11;
          v75[1] = &off_10031CAC8;
          v74[1] = @"Line";
          v74[2] = @"Method";
          id v12 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queryTagNDEFCapability:hasNdefAbility:error:")];
          v75[2] = v12;
          v74[3] = NSDebugDescriptionErrorKey;
          id v13 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("queryTagNDEFCapability:hasNdefAbility:error:"), 220];
          v75[3] = v13;
          long long v14 = +[NSDictionary dictionaryWithObjects:v75 forKeys:v74 count:4];
          id v15 = [v49 initWithDomain:v10 code:51 userInfo:v14];
        }
        else if (v16 == 23)
        {
          id v35 = objc_alloc((Class)NSError);
          uint64_t v10 = +[NSString stringWithUTF8String:"nfcd"];
          v72[0] = NSLocalizedDescriptionKey;
          uint64_t v11 = +[NSString stringWithUTF8String:"Reader mode prohibit timer"];
          v73[0] = v11;
          v73[1] = &off_10031CAE0;
          v72[1] = @"Line";
          v72[2] = @"Method";
          id v12 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queryTagNDEFCapability:hasNdefAbility:error:")];
          v73[2] = v12;
          v72[3] = NSDebugDescriptionErrorKey;
          id v13 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("queryTagNDEFCapability:hasNdefAbility:error:"), 222];
          v73[3] = v13;
          long long v14 = +[NSDictionary dictionaryWithObjects:v73 forKeys:v72 count:4];
          id v15 = [v35 initWithDomain:v10 code:64 userInfo:v14];
        }
        else
        {
LABEL_45:
          id v45 = objc_alloc((Class)NSError);
          uint64_t v10 = +[NSString stringWithUTF8String:"nfcd"];
          v68[0] = NSLocalizedDescriptionKey;
          uint64_t v11 = +[NSString stringWithUTF8String:"Stack Error"];
          v69[0] = v11;
          v69[1] = &off_10031CB10;
          v68[1] = @"Line";
          v68[2] = @"Method";
          id v12 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queryTagNDEFCapability:hasNdefAbility:error:")];
          v69[2] = v12;
          v68[3] = NSDebugDescriptionErrorKey;
          id v13 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("queryTagNDEFCapability:hasNdefAbility:error:"), 226];
          v69[3] = v13;
          long long v14 = +[NSDictionary dictionaryWithObjects:v69 forKeys:v68 count:4];
          id v15 = [v45 initWithDomain:v10 code:15 userInfo:v14];
        }
        break;
    }
LABEL_5:
    *(void *)a4 = v15;

    a4 = 0;
LABEL_42:

    goto LABEL_43;
  }
  if (a4)
  {
    id v9 = objc_alloc((Class)NSError);
    uint64_t v10 = +[NSString stringWithUTF8String:"nfcd"];
    v82[0] = NSLocalizedDescriptionKey;
    uint64_t v11 = +[NSString stringWithUTF8String:"Aborted"];
    v83[0] = v11;
    v83[1] = &off_10031CA68;
    v82[1] = @"Line";
    v82[2] = @"Method";
    id v12 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queryTagNDEFCapability:hasNdefAbility:error:")];
    v83[2] = v12;
    v82[3] = NSDebugDescriptionErrorKey;
    id v13 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("queryTagNDEFCapability:hasNdefAbility:error:"), 205];
    v83[3] = v13;
    long long v14 = +[NSDictionary dictionaryWithObjects:v83 forKeys:v82 count:4];
    id v15 = [v9 initWithDomain:v10 code:3 userInfo:v14];
    goto LABEL_5;
  }
LABEL_43:
  objc_sync_exit(v8);

LABEL_44:
  return a4;
}

void sub_10019131C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

unint64_t sub_100191378(void *a1, void *a2, unint64_t a3)
{
  id v5 = a2;
  if (!a1)
  {
    a3 = 0;
    goto LABEL_43;
  }
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v6 = a1;
    objc_sync_enter(v6);
    if (v6[137])
    {
      if (!a3)
      {
LABEL_41:
        objc_sync_exit(v6);
        goto LABEL_42;
      }
      id v7 = objc_alloc((Class)NSError);
      id v8 = +[NSString stringWithUTF8String:"nfcd"];
      v65[0] = NSLocalizedDescriptionKey;
      id v9 = +[NSString stringWithUTF8String:"Aborted"];
      v66[0] = v9;
      v66[1] = &off_10031CB40;
      v65[1] = @"Line";
      v65[2] = @"Method";
      id v10 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queryMifareTagCapability:error:")];
      v66[2] = v10;
      v65[3] = NSDebugDescriptionErrorKey;
      id v11 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("queryMifareTagCapability:error:"), 255];
      v66[3] = v11;
      id v12 = +[NSDictionary dictionaryWithObjects:v66 forKeys:v65 count:4];
      *(void *)a3 = [v7 initWithDomain:v8 code:3 userInfo:v12];
    }
    else
    {
      uint64_t v64 = 0;
      memset(buf, 0, sizeof(buf));
      sub_10018F904((uint64_t)v6, v5);
      int MiFareInfo = NFDriverRemoteDevGetMiFareInfo();
      if (!MiFareInfo)
      {
        if ((*(_DWORD *)buf - 1) >= 4) {
          a3 = 0;
        }
        else {
          a3 = (*(_DWORD *)buf + 12);
        }
        goto LABEL_41;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (Logger)
      {
        Class = object_getClass(v6);
        if (class_isMetaClass(Class)) {
          uint64_t v30 = 43;
        }
        else {
          uint64_t v30 = 45;
        }
        ClassName = object_getClassName(v6);
        Name = sel_getName("queryMifareTagCapability:error:");
        Logger(3, "%c[%{public}s %{public}s]:%i Failed to query MIFARE info", v30, ClassName, Name, 262);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v33 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_ERROR))
      {
        uint64_t v34 = object_getClass(v6);
        if (class_isMetaClass(v34)) {
          int v35 = 43;
        }
        else {
          int v35 = 45;
        }
        *(_DWORD *)CFStringRef v55 = 67109890;
        int v56 = v35;
        __int16 v57 = 2082;
        __int16 v58 = object_getClassName(v6);
        __int16 v59 = 2082;
        __int16 v60 = sel_getName("queryMifareTagCapability:error:");
        __int16 v61 = 1024;
        int v62 = 262;
        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to query MIFARE info", v55, 0x22u);
      }

      if (!a3) {
        goto LABEL_41;
      }
      if (MiFareInfo == 4)
      {
        id v43 = objc_alloc((Class)NSError);
        int v37 = +[NSString stringWithUTF8String:"nfcd"];
        v49[0] = NSLocalizedDescriptionKey;
        id v38 = +[NSString stringWithUTF8String:"SE not available"];
        v50[0] = v38;
        v50[1] = &off_10031CB88;
        v49[1] = @"Line";
        v49[2] = @"Method";
        id v39 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queryMifareTagCapability:error:")];
        v50[2] = v39;
        v49[3] = NSDebugDescriptionErrorKey;
        id v40 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("queryMifareTagCapability:error:"), 269];
        v50[3] = v40;
        int v41 = +[NSDictionary dictionaryWithObjects:v50 forKeys:v49 count:4];
        id v42 = [v43 initWithDomain:v37 code:35 userInfo:v41];
      }
      else if (MiFareInfo == 23)
      {
        id v44 = objc_alloc((Class)NSError);
        int v37 = +[NSString stringWithUTF8String:"nfcd"];
        v51[0] = NSLocalizedDescriptionKey;
        id v38 = +[NSString stringWithUTF8String:"Reader mode prohibit timer"];
        v52[0] = v38;
        v52[1] = &off_10031CB70;
        v51[1] = @"Line";
        v51[2] = @"Method";
        id v39 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queryMifareTagCapability:error:")];
        v52[2] = v39;
        v51[3] = NSDebugDescriptionErrorKey;
        id v40 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("queryMifareTagCapability:error:"), 267];
        v52[3] = v40;
        int v41 = +[NSDictionary dictionaryWithObjects:v52 forKeys:v51 count:4];
        id v42 = [v44 initWithDomain:v37 code:64 userInfo:v41];
      }
      else
      {
        id v36 = objc_alloc((Class)NSError);
        +[NSString stringWithUTF8String:"nfcd"];
        if (MiFareInfo == 18) {
          int v37 = {;
        }
          v53[0] = NSLocalizedDescriptionKey;
          id v38 = +[NSString stringWithUTF8String:"RF Deactivated"];
          v54[0] = v38;
          v54[1] = &off_10031CB58;
          v53[1] = @"Line";
          v53[2] = @"Method";
          id v39 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queryMifareTagCapability:error:")];
          v54[2] = v39;
          v53[3] = NSDebugDescriptionErrorKey;
          id v40 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("queryMifareTagCapability:error:"), 265];
          v54[3] = v40;
          int v41 = +[NSDictionary dictionaryWithObjects:v54 forKeys:v53 count:4];
          id v42 = [v36 initWithDomain:v37 code:51 userInfo:v41];
        }
        else {
          int v37 = {;
        }
          v47[0] = NSLocalizedDescriptionKey;
          id v38 = +[NSString stringWithUTF8String:"Stack Error"];
          v48[0] = v38;
          v48[1] = &off_10031CBA0;
          v47[1] = @"Line";
          v47[2] = @"Method";
          id v39 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queryMifareTagCapability:error:")];
          v48[2] = v39;
          v47[3] = NSDebugDescriptionErrorKey;
          id v40 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("queryMifareTagCapability:error:"), 271];
          v48[3] = v40;
          int v41 = +[NSDictionary dictionaryWithObjects:v48 forKeys:v47 count:4];
          id v42 = [v36 initWithDomain:v37 code:15 userInfo:v41];
        }
      }
      *(void *)a3 = v42;
    }
    a3 = 0;
    goto LABEL_41;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v13 = NFLogGetLogger();
  if (v13)
  {
    long long v14 = (void (*)(uint64_t, const char *, ...))v13;
    id v15 = object_getClass(a1);
    BOOL isMetaClass = class_isMetaClass(v15);
    dispatch_time_t v17 = object_getClassName(a1);
    id v46 = sel_getName("queryMifareTagCapability:error:");
    uint64_t v18 = 45;
    if (isMetaClass) {
      uint64_t v18 = 43;
    }
    v14(3, "%c[%{public}s %{public}s]:%i Invalid tag parameter", v18, v17, v46, 248);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v19 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    uint64_t v20 = object_getClass(a1);
    if (class_isMetaClass(v20)) {
      int v21 = 43;
    }
    else {
      int v21 = 45;
    }
    *(_DWORD *)long long buf = 67109890;
    *(_DWORD *)&uint8_t buf[4] = v21;
    *(_WORD *)&uint8_t buf[8] = 2082;
    *(void *)&buf[10] = object_getClassName(a1);
    *(_WORD *)&buf[18] = 2082;
    *(void *)&buf[20] = sel_getName("queryMifareTagCapability:error:");
    *(_WORD *)&buf[28] = 1024;
    *(_DWORD *)&buf[30] = 248;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid tag parameter", buf, 0x22u);
  }

  if (a3)
  {
    id v22 = objc_alloc((Class)NSError);
    id v6 = +[NSString stringWithUTF8String:"nfcd"];
    v67[0] = NSLocalizedDescriptionKey;
    uint64_t v23 = +[NSString stringWithUTF8String:"Invalid Parameter"];
    v68[0] = v23;
    v68[1] = &off_10031CB28;
    v67[1] = @"Line";
    v67[2] = @"Method";
    id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("queryMifareTagCapability:error:")];
    v68[2] = v24;
    v67[3] = NSDebugDescriptionErrorKey;
    id v25 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("queryMifareTagCapability:error:"), 249];
    v68[3] = v25;
    int v26 = +[NSDictionary dictionaryWithObjects:v68 forKeys:v67 count:4];
    *(void *)a3 = [v22 initWithDomain:v6 code:10 userInfo:v26];

    a3 = 0;
LABEL_42:
  }
LABEL_43:

  return a3;
}

void sub_100191E04(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void *sub_100191E30(void *a1, void *a2, unsigned int a3, void *a4)
{
  id v7 = a2;
  if (a1)
  {
    id v8 = a1;
    objc_sync_enter(v8);
    if (v8[137])
    {
      if (a4)
      {
        id v9 = objc_alloc((Class)NSError);
        id v10 = +[NSString stringWithUTF8String:"nfcd"];
        v115[0] = NSLocalizedDescriptionKey;
        id v11 = +[NSString stringWithUTF8String:"Aborted"];
        v116[0] = v11;
        v116[1] = &off_10031CBB8;
        v115[1] = @"Line";
        v115[2] = @"Method";
        id v12 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("readNdefDataFromTag:messageSize:error:")];
        v116[2] = v12;
        v115[3] = NSDebugDescriptionErrorKey;
        id v13 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("readNdefDataFromTag:messageSize:error:"), 301];
        v116[3] = v13;
        long long v14 = +[NSDictionary dictionaryWithObjects:v116 forKeys:v115 count:4];
        *a4 = [v9 initWithDomain:v10 code:3 userInfo:v14];

LABEL_50:
        a4 = 0;
        goto LABEL_51;
      }
      goto LABEL_51;
    }
    if (a3 > 0x8000)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (Logger)
      {
        Class = object_getClass(v8);
        if (class_isMetaClass(Class)) {
          uint64_t v17 = 43;
        }
        else {
          uint64_t v17 = 45;
        }
        ClassName = object_getClassName(v8);
        Name = sel_getName("readNdefDataFromTag:messageSize:error:");
        Logger(5, "%c[%{public}s %{public}s]:%i NDEF message size is over the read limit", v17, ClassName, Name, 307);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v20 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEFAULT))
      {
        int v21 = object_getClass(v8);
        if (class_isMetaClass(v21)) {
          int v22 = 43;
        }
        else {
          int v22 = 45;
        }
        *(_DWORD *)long long buf = 67109890;
        int v100 = v22;
        __int16 v101 = 2082;
        long long v102 = object_getClassName(v8);
        __int16 v103 = 2082;
        long long v104 = sel_getName("readNdefDataFromTag:messageSize:error:");
        __int16 v105 = 1024;
        int v106 = 307;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NDEF message size is over the read limit", buf, 0x22u);
      }

      if (!a4) {
        goto LABEL_51;
      }
      id v23 = objc_alloc((Class)NSError);
      id v24 = +[NSString stringWithUTF8String:"nfcd"];
      v113[0] = NSLocalizedDescriptionKey;
      id v25 = +[NSString stringWithUTF8String:"NDEF message size is over the limit"];
      v114[0] = v25;
      v114[1] = &off_10031CBD0;
      v113[1] = @"Line";
      v113[2] = @"Method";
      id v26 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("readNdefDataFromTag:messageSize:error:")];
      v114[2] = v26;
      v113[3] = NSDebugDescriptionErrorKey;
      id v27 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("readNdefDataFromTag:messageSize:error:"), 308];
      v114[3] = v27;
      uint64_t v28 = +[NSDictionary dictionaryWithObjects:v114 forKeys:v113 count:4];
      *a4 = [v23 initWithDomain:v24 code:43 userInfo:v28];

      goto LABEL_50;
    }
    if (!a3)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v45 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v45)
      {
        id v46 = object_getClass(v8);
        if (class_isMetaClass(v46)) {
          uint64_t v47 = 43;
        }
        else {
          uint64_t v47 = 45;
        }
        id v48 = object_getClassName(v8);
        id v49 = sel_getName("readNdefDataFromTag:messageSize:error:");
        v45(5, "%c[%{public}s %{public}s]:%i zero-length message", v47, v48, v49, 311);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v50 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
      {
        int v51 = object_getClass(v8);
        if (class_isMetaClass(v51)) {
          int v52 = 43;
        }
        else {
          int v52 = 45;
        }
        *(_DWORD *)long long buf = 67109890;
        int v100 = v52;
        __int16 v101 = 2082;
        long long v102 = object_getClassName(v8);
        __int16 v103 = 2082;
        long long v104 = sel_getName("readNdefDataFromTag:messageSize:error:");
        __int16 v105 = 1024;
        int v106 = 311;
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i zero-length message", buf, 0x22u);
      }

      if (!a4) {
        goto LABEL_51;
      }
      id v53 = objc_alloc((Class)NSError);
      __int16 v54 = +[NSString stringWithUTF8String:"nfcd"];
      v111[0] = NSLocalizedDescriptionKey;
      CFStringRef v55 = +[NSString stringWithUTF8String:"Zero-length NDEF message"];
      v112[0] = v55;
      v112[1] = &off_10031CBE8;
      v111[1] = @"Line";
      v111[2] = @"Method";
      id v56 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("readNdefDataFromTag:messageSize:error:")];
      v112[2] = v56;
      v111[3] = NSDebugDescriptionErrorKey;
      id v57 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("readNdefDataFromTag:messageSize:error:"), 312];
      v112[3] = v57;
      __int16 v58 = +[NSDictionary dictionaryWithObjects:v112 forKeys:v111 count:4];
      *a4 = [v53 initWithDomain:v54 code:49 userInfo:v58];

      goto LABEL_50;
    }
    if (a4) {
      *a4 = 0;
    }
    if (!NFDataCreateWithLength())
    {
      if (a4)
      {
        id v59 = objc_alloc((Class)NSError);
        __int16 v60 = +[NSString stringWithUTF8String:"nfcd"];
        v81[0] = NSLocalizedDescriptionKey;
        __int16 v61 = +[NSString stringWithUTF8String:"No resources"];
        v82[0] = v61;
        v82[1] = &off_10031CCC0;
        v81[1] = @"Line";
        v81[2] = @"Method";
        id v62 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("readNdefDataFromTag:messageSize:error:")];
        v82[2] = v62;
        v81[3] = NSDebugDescriptionErrorKey;
        id v63 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("readNdefDataFromTag:messageSize:error:"), 354];
        v82[3] = v63;
        uint64_t v64 = +[NSDictionary dictionaryWithObjects:v82 forKeys:v81 count:4];
        *a4 = [v59 initWithDomain:v60 code:34 userInfo:v64];

        goto LABEL_50;
      }
LABEL_51:
      objc_sync_exit(v8);

      goto LABEL_52;
    }
    sub_10018F904((uint64_t)v8, v7);
    uint64_t Ndef = NFDriverRemoteDevReadNdef();
    if (Ndef)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v30 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v30)
      {
        uint64_t v31 = object_getClass(v8);
        if (class_isMetaClass(v31)) {
          uint64_t v32 = 43;
        }
        else {
          uint64_t v32 = 45;
        }
        uint64_t v33 = object_getClassName(v8);
        uint64_t v34 = sel_getName("readNdefDataFromTag:messageSize:error:");
        v30(3, "%c[%{public}s %{public}s]:%i Failed to read NDEF from tag %{public}@, status=%d", v32, v33, v34, 325, v7, Ndef);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v35 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
      {
        id v36 = object_getClass(v8);
        if (class_isMetaClass(v36)) {
          int v37 = 43;
        }
        else {
          int v37 = 45;
        }
        *(_DWORD *)long long buf = 67110402;
        int v100 = v37;
        __int16 v101 = 2082;
        long long v102 = object_getClassName(v8);
        __int16 v103 = 2082;
        long long v104 = sel_getName("readNdefDataFromTag:messageSize:error:");
        __int16 v105 = 1024;
        int v106 = 325;
        __int16 v107 = 2114;
        id v108 = v7;
        __int16 v109 = 1024;
        int v110 = Ndef;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to read NDEF from tag %{public}@, status=%d", buf, 0x32u);
      }

      if (!a4) {
        goto LABEL_76;
      }
      switch((int)Ndef)
      {
        case 4:
          id v38 = objc_alloc((Class)NSError);
          id v39 = +[NSString stringWithUTF8String:"nfcd"];
          v87[0] = NSLocalizedDescriptionKey;
          id v40 = +[NSString stringWithUTF8String:"SE not available"];
          v88[0] = v40;
          v88[1] = &off_10031CC78;
          v87[1] = @"Line";
          v87[2] = @"Method";
          id v41 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("readNdefDataFromTag:messageSize:error:")];
          v88[2] = v41;
          v87[3] = NSDebugDescriptionErrorKey;
          id v42 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("readNdefDataFromTag:messageSize:error:"), 338];
          v88[3] = v42;
          id v43 = +[NSDictionary dictionaryWithObjects:v88 forKeys:v87 count:4];
          id v44 = [v38 initWithDomain:v39 code:35 userInfo:v43];
          break;
        case 5:
          id v77 = objc_alloc((Class)NSError);
          id v39 = +[NSString stringWithUTF8String:"nfcd"];
          v95[0] = NSLocalizedDescriptionKey;
          id v40 = +[NSString stringWithUTF8String:"Invalid Parameter"];
          v96[0] = v40;
          v96[1] = &off_10031CC18;
          v95[1] = @"Line";
          v95[2] = @"Method";
          id v41 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("readNdefDataFromTag:messageSize:error:")];
          v96[2] = v41;
          v95[3] = NSDebugDescriptionErrorKey;
          id v42 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("readNdefDataFromTag:messageSize:error:"), 330];
          v96[3] = v42;
          id v43 = +[NSDictionary dictionaryWithObjects:v96 forKeys:v95 count:4];
          id v44 = [v77 initWithDomain:v39 code:10 userInfo:v43];
          break;
        case 6:
          id v78 = objc_alloc((Class)NSError);
          id v39 = +[NSString stringWithUTF8String:"nfcd"];
          v97[0] = NSLocalizedDescriptionKey;
          id v40 = +[NSString stringWithUTF8String:"Connection Closed"];
          v98[0] = v40;
          v98[1] = &off_10031CC00;
          v97[1] = @"Line";
          v97[2] = @"Method";
          id v41 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("readNdefDataFromTag:messageSize:error:")];
          v98[2] = v41;
          v97[3] = NSDebugDescriptionErrorKey;
          id v42 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("readNdefDataFromTag:messageSize:error:"), 328];
          v98[3] = v42;
          id v43 = +[NSDictionary dictionaryWithObjects:v98 forKeys:v97 count:4];
          id v44 = [v78 initWithDomain:v39 code:21 userInfo:v43];
          break;
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
          goto LABEL_70;
        case 12:
          id v79 = objc_alloc((Class)NSError);
          id v39 = +[NSString stringWithUTF8String:"nfcd"];
          v93[0] = NSLocalizedDescriptionKey;
          id v40 = +[NSString stringWithUTF8String:"Tag Not NDEF formatted"];
          v94[0] = v40;
          v94[1] = &off_10031CC30;
          v93[1] = @"Line";
          v93[2] = @"Method";
          id v41 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("readNdefDataFromTag:messageSize:error:")];
          v94[2] = v41;
          void v93[3] = NSDebugDescriptionErrorKey;
          id v42 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("readNdefDataFromTag:messageSize:error:"), 332];
          void v94[3] = v42;
          id v43 = +[NSDictionary dictionaryWithObjects:v94 forKeys:v93 count:4];
          id v44 = [v79 initWithDomain:v39 code:37 userInfo:v43];
          break;
        default:
          if (Ndef == 18)
          {
            id v80 = objc_alloc((Class)NSError);
            id v39 = +[NSString stringWithUTF8String:"nfcd"];
            v91[0] = NSLocalizedDescriptionKey;
            id v40 = +[NSString stringWithUTF8String:"RF Deactivated"];
            v92[0] = v40;
            v92[1] = &off_10031CC48;
            v91[1] = @"Line";
            v91[2] = @"Method";
            id v41 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("readNdefDataFromTag:messageSize:error:")];
            v92[2] = v41;
            v91[3] = NSDebugDescriptionErrorKey;
            id v42 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("readNdefDataFromTag:messageSize:error:"), 334];
            v92[3] = v42;
            id v43 = +[NSDictionary dictionaryWithObjects:v92 forKeys:v91 count:4];
            id v44 = [v80 initWithDomain:v39 code:51 userInfo:v43];
          }
          else if (Ndef == 23)
          {
            id v75 = objc_alloc((Class)NSError);
            id v39 = +[NSString stringWithUTF8String:"nfcd"];
            v89[0] = NSLocalizedDescriptionKey;
            id v40 = +[NSString stringWithUTF8String:"Reader mode prohibit timer"];
            v90[0] = v40;
            v90[1] = &off_10031CC60;
            v89[1] = @"Line";
            v89[2] = @"Method";
            id v41 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("readNdefDataFromTag:messageSize:error:")];
            v90[2] = v41;
            v89[3] = NSDebugDescriptionErrorKey;
            id v42 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("readNdefDataFromTag:messageSize:error:"), 336];
            v90[3] = v42;
            id v43 = +[NSDictionary dictionaryWithObjects:v90 forKeys:v89 count:4];
            id v44 = [v75 initWithDomain:v39 code:64 userInfo:v43];
          }
          else
          {
LABEL_70:
            id v76 = objc_alloc((Class)NSError);
            id v39 = +[NSString stringWithUTF8String:"nfcd"];
            v85[0] = NSLocalizedDescriptionKey;
            id v40 = +[NSString stringWithUTF8String:"Stack Error"];
            v86[0] = v40;
            v86[1] = &off_10031CC90;
            v85[1] = @"Line";
            v85[2] = @"Method";
            id v41 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("readNdefDataFromTag:messageSize:error:")];
            v86[2] = v41;
            v85[3] = NSDebugDescriptionErrorKey;
            id v42 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("readNdefDataFromTag:messageSize:error:"), 340];
            v86[3] = v42;
            id v43 = +[NSDictionary dictionaryWithObjects:v86 forKeys:v85 count:4];
            id v44 = [v76 initWithDomain:v39 code:15 userInfo:v43];
          }
          break;
      }
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v66 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v66)
      {
        id v67 = object_getClass(v8);
        if (class_isMetaClass(v67)) {
          uint64_t v68 = 43;
        }
        else {
          uint64_t v68 = 45;
        }
        int v69 = object_getClassName(v8);
        int v70 = sel_getName("readNdefDataFromTag:messageSize:error:");
        v66(5, "%c[%{public}s %{public}s]:%i zero-length message", v68, v69, v70, 346);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v71 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
      {
        long long v72 = object_getClass(v8);
        if (class_isMetaClass(v72)) {
          int v73 = 43;
        }
        else {
          int v73 = 45;
        }
        *(_DWORD *)long long buf = 67109890;
        int v100 = v73;
        __int16 v101 = 2082;
        long long v102 = object_getClassName(v8);
        __int16 v103 = 2082;
        long long v104 = sel_getName("readNdefDataFromTag:messageSize:error:");
        __int16 v105 = 1024;
        int v106 = 346;
        _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i zero-length message", buf, 0x22u);
      }

      if (!a4) {
        goto LABEL_76;
      }
      id v74 = objc_alloc((Class)NSError);
      id v39 = +[NSString stringWithUTF8String:"nfcd"];
      v83[0] = NSLocalizedDescriptionKey;
      id v40 = +[NSString stringWithUTF8String:"Zero-length NDEF message"];
      v84[0] = v40;
      v84[1] = &off_10031CCA8;
      v83[1] = @"Line";
      v83[2] = @"Method";
      id v41 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("readNdefDataFromTag:messageSize:error:")];
      v84[2] = v41;
      v83[3] = NSDebugDescriptionErrorKey;
      id v42 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("readNdefDataFromTag:messageSize:error:"), 347];
      v84[3] = v42;
      id v43 = +[NSDictionary dictionaryWithObjects:v84 forKeys:v83 count:4];
      id v44 = [v74 initWithDomain:v39 code:49 userInfo:v43];
    }
    *a4 = v44;

LABEL_76:
    a4 = 0;
    NFDataRelease();
    goto LABEL_51;
  }
  a4 = 0;
LABEL_52:

  return a4;
}

void sub_10019326C(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_1001932E8(void *a1, void *a2, void *a3)
{
  if (a1)
  {
    a1 = sub_100193320(a1, a2, 0x8000u, a3);
    uint64_t v3 = vars8;
  }
  return a1;
}

id sub_100193320(void *a1, void *a2, unsigned int a3, void *a4)
{
  if (a1)
  {
    id v4 = sub_100191E30(a1, a2, a3, a4);
    if (v4)
    {
      id v5 = objc_alloc((Class)NFNdefMessageInternal);
      id v6 = v4;
      id v7 = [v5 initWithBytes:[v6 bytes] length:[v6 length]];
    }
    else
    {
      id v7 = 0;
    }
  }
  else
  {
    id v7 = 0;
  }

  return v7;
}

BOOL sub_1001933C0(void *a1, void *a2, void *a3, uint64_t a4, void *a5)
{
  id v84 = a2;
  id v83 = a3;
  if (!a1)
  {
    BOOL v18 = 0;
    goto LABEL_29;
  }
  id v8 = a1;
  objc_sync_enter(v8);
  if (!v8[137])
  {
    id v10 = [v84 asData];
    [v10 bytes];
    [v10 length];
    uint64_t v15 = NFDataCreateWithBytesNoCopy();
    if (!a5 || v15)
    {
      sub_10018F904((uint64_t)v8, v83);
      int v19 = NFDriverRemoteDevWriteNdef();
      BOOL v18 = v19 == 0;
      if (v19)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (Logger)
        {
          Class = object_getClass(v8);
          if (class_isMetaClass(Class)) {
            uint64_t v22 = 43;
          }
          else {
            uint64_t v22 = 45;
          }
          ClassName = object_getClassName(v8);
          Name = sel_getName("writeNdefData:toTag:nLengthOptimization:error:");
          Logger(3, "%c[%{public}s %{public}s]:%i Failed to write NDEF data to tag %{public}@", v22, ClassName, Name, 400, v83);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v25 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          id v26 = object_getClass(v8);
          if (class_isMetaClass(v26)) {
            int v27 = 43;
          }
          else {
            int v27 = 45;
          }
          *(_DWORD *)long long buf = 67110146;
          int v104 = v27;
          __int16 v105 = 2082;
          int v106 = object_getClassName(v8);
          __int16 v107 = 2082;
          id v108 = sel_getName("writeNdefData:toTag:nLengthOptimization:error:");
          __int16 v109 = 1024;
          int v110 = 400;
          __int16 v111 = 2114;
          id v112 = v83;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to write NDEF data to tag %{public}@", buf, 0x2Cu);
        }

        if (a5)
        {
          switch(v19)
          {
            case 3:
              id v65 = objc_alloc((Class)NSError);
              uint64_t v28 = +[NSString stringWithUTF8String:"nfcd"];
              v93[0] = NSLocalizedDescriptionKey;
              id v74 = +[NSString stringWithUTF8String:"No resources"];
              v94[0] = v74;
              v94[1] = &off_10031CD68;
              v93[1] = @"Line";
              v93[2] = @"Method";
              id v29 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("writeNdefData:toTag:nLengthOptimization:error:")];
              v94[2] = v29;
              void v93[3] = NSDebugDescriptionErrorKey;
              id v30 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("writeNdefData:toTag:nLengthOptimization:error:"), 412];
              void v94[3] = v30;
              uint64_t v31 = +[NSDictionary dictionaryWithObjects:v94 forKeys:v93 count:4];
              *a5 = [v65 initWithDomain:v28 code:34 userInfo:v31];

              break;
            case 4:
              id v68 = objc_alloc((Class)NSError);
              id v41 = +[NSString stringWithUTF8String:"nfcd"];
              v87[0] = NSLocalizedDescriptionKey;
              id v77 = +[NSString stringWithUTF8String:"SE not available"];
              v88[0] = v77;
              v88[1] = &off_10031CDB0;
              v87[1] = @"Line";
              v87[2] = @"Method";
              id v42 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("writeNdefData:toTag:nLengthOptimization:error:")];
              v88[2] = v42;
              v87[3] = NSDebugDescriptionErrorKey;
              id v43 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("writeNdefData:toTag:nLengthOptimization:error:"), 418];
              v88[3] = v43;
              id v44 = +[NSDictionary dictionaryWithObjects:v88 forKeys:v87 count:4];
              *a5 = [v68 initWithDomain:v41 code:35 userInfo:v44];

              break;
            case 5:
              id v69 = objc_alloc((Class)NSError);
              id v45 = +[NSString stringWithUTF8String:"nfcd"];
              v99[0] = NSLocalizedDescriptionKey;
              id v78 = +[NSString stringWithUTF8String:"Invalid Parameter"];
              v100[0] = v78;
              v100[1] = &off_10031CD20;
              v99[1] = @"Line";
              v99[2] = @"Method";
              id v46 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("writeNdefData:toTag:nLengthOptimization:error:")];
              v100[2] = v46;
              v99[3] = NSDebugDescriptionErrorKey;
              id v47 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("writeNdefData:toTag:nLengthOptimization:error:"), 406];
              v100[3] = v47;
              id v48 = +[NSDictionary dictionaryWithObjects:v100 forKeys:v99 count:4];
              *a5 = [v69 initWithDomain:v45 code:10 userInfo:v48];

              break;
            case 6:
              id v70 = objc_alloc((Class)NSError);
              id v49 = +[NSString stringWithUTF8String:"nfcd"];
              v101[0] = NSLocalizedDescriptionKey;
              id v79 = +[NSString stringWithUTF8String:"Connection Closed"];
              v102[0] = v79;
              v102[1] = &off_10031CD08;
              v101[1] = @"Line";
              v101[2] = @"Method";
              id v50 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("writeNdefData:toTag:nLengthOptimization:error:")];
              v102[2] = v50;
              v101[3] = NSDebugDescriptionErrorKey;
              id v51 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("writeNdefData:toTag:nLengthOptimization:error:"), 404];
              v102[3] = v51;
              int v52 = +[NSDictionary dictionaryWithObjects:v102 forKeys:v101 count:4];
              *a5 = [v70 initWithDomain:v49 code:21 userInfo:v52];

              break;
            case 7:
            case 8:
            case 9:
            case 10:
            case 11:
            case 13:
            case 14:
            case 16:
            case 17:
              goto LABEL_32;
            case 12:
              id v71 = objc_alloc((Class)NSError);
              id v53 = +[NSString stringWithUTF8String:"nfcd"];
              v97[0] = NSLocalizedDescriptionKey;
              id v80 = +[NSString stringWithUTF8String:"Tag Not NDEF formatted"];
              v98[0] = v80;
              v98[1] = &off_10031CD38;
              v97[1] = @"Line";
              v97[2] = @"Method";
              id v54 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("writeNdefData:toTag:nLengthOptimization:error:")];
              v98[2] = v54;
              v97[3] = NSDebugDescriptionErrorKey;
              id v55 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("writeNdefData:toTag:nLengthOptimization:error:"), 408];
              v98[3] = v55;
              id v56 = +[NSDictionary dictionaryWithObjects:v98 forKeys:v97 count:4];
              *a5 = [v71 initWithDomain:v53 code:37 userInfo:v56];

              break;
            case 15:
              id v72 = objc_alloc((Class)NSError);
              id v57 = +[NSString stringWithUTF8String:"nfcd"];
              v95[0] = NSLocalizedDescriptionKey;
              int v81 = +[NSString stringWithUTF8String:"NDEF message size is over the limit"];
              v96[0] = v81;
              v96[1] = &off_10031CD50;
              v95[1] = @"Line";
              v95[2] = @"Method";
              id v58 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("writeNdefData:toTag:nLengthOptimization:error:")];
              v96[2] = v58;
              v95[3] = NSDebugDescriptionErrorKey;
              id v59 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("writeNdefData:toTag:nLengthOptimization:error:"), 410];
              v96[3] = v59;
              __int16 v60 = +[NSDictionary dictionaryWithObjects:v96 forKeys:v95 count:4];
              *a5 = [v72 initWithDomain:v57 code:43 userInfo:v60];

              break;
            case 18:
              id v73 = objc_alloc((Class)NSError);
              __int16 v61 = +[NSString stringWithUTF8String:"nfcd"];
              v91[0] = NSLocalizedDescriptionKey;
              id v82 = +[NSString stringWithUTF8String:"RF Deactivated"];
              v92[0] = v82;
              v92[1] = &off_10031CD80;
              v91[1] = @"Line";
              v91[2] = @"Method";
              id v62 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("writeNdefData:toTag:nLengthOptimization:error:")];
              v92[2] = v62;
              v91[3] = NSDebugDescriptionErrorKey;
              id v63 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("writeNdefData:toTag:nLengthOptimization:error:"), 414];
              v92[3] = v63;
              uint64_t v64 = +[NSDictionary dictionaryWithObjects:v92 forKeys:v91 count:4];
              *a5 = [v73 initWithDomain:v61 code:51 userInfo:v64];

              break;
            default:
              if (v19 == 23)
              {
                id v66 = objc_alloc((Class)NSError);
                uint64_t v33 = +[NSString stringWithUTF8String:"nfcd"];
                v89[0] = NSLocalizedDescriptionKey;
                id v75 = +[NSString stringWithUTF8String:"Reader mode prohibit timer"];
                v90[0] = v75;
                v90[1] = &off_10031CD98;
                v89[1] = @"Line";
                v89[2] = @"Method";
                id v34 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("writeNdefData:toTag:nLengthOptimization:error:")];
                v90[2] = v34;
                v89[3] = NSDebugDescriptionErrorKey;
                id v35 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("writeNdefData:toTag:nLengthOptimization:error:"), 416];
                v90[3] = v35;
                id v36 = +[NSDictionary dictionaryWithObjects:v90 forKeys:v89 count:4];
                *a5 = [v66 initWithDomain:v33 code:64 userInfo:v36];
              }
              else
              {
LABEL_32:
                id v67 = objc_alloc((Class)NSError);
                int v37 = +[NSString stringWithUTF8String:"nfcd"];
                v85[0] = NSLocalizedDescriptionKey;
                id v76 = +[NSString stringWithUTF8String:"Stack Error"];
                v86[0] = v76;
                v86[1] = &off_10031CDC8;
                v85[1] = @"Line";
                v85[2] = @"Method";
                id v38 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("writeNdefData:toTag:nLengthOptimization:error:")];
                v86[2] = v38;
                v85[3] = NSDebugDescriptionErrorKey;
                id v39 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("writeNdefData:toTag:nLengthOptimization:error:"), 420];
                v86[3] = v39;
                id v40 = +[NSDictionary dictionaryWithObjects:v86 forKeys:v85 count:4];
                *a5 = [v67 initWithDomain:v37 code:15 userInfo:v40];
              }
              break;
          }
        }
      }
      else if (a5)
      {
        *a5 = 0;
      }
      NFDataRelease();
      goto LABEL_27;
    }
    id v16 = objc_alloc((Class)NSError);
    id v11 = +[NSString stringWithUTF8String:"nfcd"];
    v113[0] = NSLocalizedDescriptionKey;
    id v12 = +[NSString stringWithUTF8String:"No resources"];
    v114[0] = v12;
    v114[1] = &off_10031CCF0;
    v113[1] = @"Line";
    v113[2] = @"Method";
    id v13 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("writeNdefData:toTag:nLengthOptimization:error:")];
    v114[2] = v13;
    v113[3] = NSDebugDescriptionErrorKey;
    id v14 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("writeNdefData:toTag:nLengthOptimization:error:"), 394];
    v114[3] = v14;
    uint64_t v17 = +[NSDictionary dictionaryWithObjects:v114 forKeys:v113 count:4];
    *a5 = [v16 initWithDomain:v11 code:34 userInfo:v17];

LABEL_8:
    BOOL v18 = 0;
LABEL_27:

    goto LABEL_28;
  }
  if (a5)
  {
    id v9 = objc_alloc((Class)NSError);
    id v10 = +[NSString stringWithUTF8String:"nfcd"];
    v115[0] = NSLocalizedDescriptionKey;
    id v11 = +[NSString stringWithUTF8String:"Aborted"];
    v116[0] = v11;
    v116[1] = &off_10031CCD8;
    v115[1] = @"Line";
    v115[2] = @"Method";
    id v12 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("writeNdefData:toTag:nLengthOptimization:error:")];
    v116[2] = v12;
    v115[3] = NSDebugDescriptionErrorKey;
    id v13 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("writeNdefData:toTag:nLengthOptimization:error:"), 385];
    v116[3] = v13;
    id v14 = +[NSDictionary dictionaryWithObjects:v116 forKeys:v115 count:4];
    *a5 = [v9 initWithDomain:v10 code:3 userInfo:v14];
    goto LABEL_8;
  }
  BOOL v18 = 0;
LABEL_28:
  objc_sync_exit(v8);

LABEL_29:
  return v18;
}

void sub_100194478(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

BOOL sub_1001944EC(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  if (!a1)
  {
    BOOL v14 = 0;
    goto LABEL_8;
  }
  id v6 = a1;
  objc_sync_enter(v6);
  if (!v6[137])
  {
    sub_10018F904((uint64_t)v6, v5);
    int v16 = NFDriverRemoteDevWriteLockNdef();
    BOOL v14 = v16 == 0;
    if (!a3 || !v16) {
      goto LABEL_7;
    }
    if (v16 > 11)
    {
      if (v16 == 12)
      {
        id v20 = objc_alloc((Class)NSError);
        id v8 = +[NSString stringWithUTF8String:"nfcd"];
        v28[0] = NSLocalizedDescriptionKey;
        id v9 = +[NSString stringWithUTF8String:"Tag Not NDEF formatted"];
        v29[0] = v9;
        v29[1] = &off_10031CE10;
        v28[1] = @"Line";
        v28[2] = @"Method";
        id v10 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("writeLockNdef:error:")];
        v29[2] = v10;
        v28[3] = NSDebugDescriptionErrorKey;
        id v11 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("writeLockNdef:error:"), 447];
        v29[3] = v11;
        id v12 = +[NSDictionary dictionaryWithObjects:v29 forKeys:v28 count:4];
        id v13 = [v20 initWithDomain:v8 code:37 userInfo:v12];
        goto LABEL_5;
      }
      if (v16 == 23)
      {
        id v18 = objc_alloc((Class)NSError);
        id v8 = +[NSString stringWithUTF8String:"nfcd"];
        v26[0] = NSLocalizedDescriptionKey;
        id v9 = +[NSString stringWithUTF8String:"Reader mode prohibit timer"];
        v27[0] = v9;
        v27[1] = &off_10031CE28;
        v26[1] = @"Line";
        v26[2] = @"Method";
        id v10 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("writeLockNdef:error:")];
        v27[2] = v10;
        v26[3] = NSDebugDescriptionErrorKey;
        id v11 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("writeLockNdef:error:"), 449];
        v27[3] = v11;
        id v12 = +[NSDictionary dictionaryWithObjects:v27 forKeys:v26 count:4];
        id v13 = [v18 initWithDomain:v8 code:64 userInfo:v12];
        goto LABEL_5;
      }
    }
    else
    {
      if (v16 == 4)
      {
        id v19 = objc_alloc((Class)NSError);
        id v8 = +[NSString stringWithUTF8String:"nfcd"];
        v24[0] = NSLocalizedDescriptionKey;
        id v9 = +[NSString stringWithUTF8String:"SE not available"];
        v25[0] = v9;
        v25[1] = &off_10031CE40;
        v24[1] = @"Line";
        v24[2] = @"Method";
        id v10 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("writeLockNdef:error:")];
        v25[2] = v10;
        v24[3] = NSDebugDescriptionErrorKey;
        id v11 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("writeLockNdef:error:"), 451];
        v25[3] = v11;
        id v12 = +[NSDictionary dictionaryWithObjects:v25 forKeys:v24 count:4];
        id v13 = [v19 initWithDomain:v8 code:35 userInfo:v12];
        goto LABEL_5;
      }
      if (v16 == 6)
      {
        id v17 = objc_alloc((Class)NSError);
        id v8 = +[NSString stringWithUTF8String:"nfcd"];
        v30[0] = NSLocalizedDescriptionKey;
        id v9 = +[NSString stringWithUTF8String:"Connection Closed"];
        v31[0] = v9;
        v31[1] = &off_10031CDF8;
        v30[1] = @"Line";
        v30[2] = @"Method";
        id v10 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("writeLockNdef:error:")];
        v31[2] = v10;
        v30[3] = NSDebugDescriptionErrorKey;
        id v11 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("writeLockNdef:error:"), 445];
        v31[3] = v11;
        id v12 = +[NSDictionary dictionaryWithObjects:v31 forKeys:v30 count:4];
        id v13 = [v17 initWithDomain:v8 code:21 userInfo:v12];
        goto LABEL_5;
      }
    }
    id v21 = objc_alloc((Class)NSError);
    id v8 = +[NSString stringWithUTF8String:"nfcd"];
    v22[0] = NSLocalizedDescriptionKey;
    id v9 = +[NSString stringWithUTF8String:"Stack Error"];
    v23[0] = v9;
    v23[1] = &off_10031CE58;
    v22[1] = @"Line";
    v22[2] = @"Method";
    id v10 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("writeLockNdef:error:")];
    v23[2] = v10;
    v22[3] = NSDebugDescriptionErrorKey;
    id v11 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("writeLockNdef:error:"), 453];
    v23[3] = v11;
    id v12 = +[NSDictionary dictionaryWithObjects:v23 forKeys:v22 count:4];
    id v13 = [v21 initWithDomain:v8 code:15 userInfo:v12];
    goto LABEL_5;
  }
  if (a3)
  {
    id v7 = objc_alloc((Class)NSError);
    id v8 = +[NSString stringWithUTF8String:"nfcd"];
    v32[0] = NSLocalizedDescriptionKey;
    id v9 = +[NSString stringWithUTF8String:"Aborted"];
    v33[0] = v9;
    v33[1] = &off_10031CDE0;
    v32[1] = @"Line";
    void v32[2] = @"Method";
    id v10 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("writeLockNdef:error:")];
    void v33[2] = v10;
    v32[3] = NSDebugDescriptionErrorKey;
    id v11 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("writeLockNdef:error:"), 437];
    v33[3] = v11;
    id v12 = +[NSDictionary dictionaryWithObjects:v33 forKeys:v32 count:4];
    id v13 = [v7 initWithDomain:v8 code:3 userInfo:v12];
LABEL_5:
    *a3 = v13;
  }
  BOOL v14 = 0;
LABEL_7:
  objc_sync_exit(v6);

LABEL_8:
  return v14;
}

void sub_100194CDC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_100194CFC(void *a1, void *a2)
{
  id v3 = a2;
  if (!a1)
  {
    uint64_t v5 = 0;
    goto LABEL_5;
  }
  id v4 = a1;
  objc_sync_enter(v4);
  if (!v4[137])
  {
    sub_10018F904((uint64_t)v4, v3);
    int v7 = NFDriverRemoteDevCheckPresence();
    if (v7 > 17)
    {
      if (v7 == 18)
      {
        uint64_t v5 = 51;
        goto LABEL_4;
      }
      if (v7 == 23)
      {
        uint64_t v5 = 64;
        goto LABEL_4;
      }
    }
    else
    {
      if (!v7)
      {
        uint64_t v5 = 0;
        goto LABEL_4;
      }
      if (v7 == 4)
      {
        uint64_t v5 = 35;
        goto LABEL_4;
      }
    }
    uint64_t v5 = 28;
    goto LABEL_4;
  }
  uint64_t v5 = 3;
LABEL_4:
  objc_sync_exit(v4);

LABEL_5:
  return v5;
}

void sub_100194DCC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

BOOL sub_100194DE0(void *a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  if (!a1)
  {
    BOOL v16 = 0;
    goto LABEL_28;
  }
  id v9 = a1;
  objc_sync_enter(v9);
  if (v9[137])
  {
    if (a4)
    {
      id v10 = objc_alloc((Class)NSError);
      id v11 = +[NSString stringWithUTF8String:"nfcd"];
      v79[0] = NSLocalizedDescriptionKey;
      id v12 = +[NSString stringWithUTF8String:"Aborted"];
      v80[0] = v12;
      v80[1] = &off_10031CE70;
      v79[1] = @"Line";
      v79[2] = @"Method";
      id v13 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("formatTagToNdef:withKey:error:")];
      v80[2] = v13;
      v79[3] = NSDebugDescriptionErrorKey;
      id v14 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("formatTagToNdef:withKey:error:"), 489];
      v80[3] = v14;
      uint64_t v15 = +[NSDictionary dictionaryWithObjects:v80 forKeys:v79 count:4];
      *a4 = [v10 initWithDomain:v11 code:3 userInfo:v15];
    }
    goto LABEL_5;
  }
  if ([v7 type] != 9
    && [v7 type] != 14
    && [v7 type] != 15
    && [v7 type] != 16
    && [v7 type] != 1
    && [v7 type] != 4)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (Logger)
    {
      Class = object_getClass(v9);
      if (class_isMetaClass(Class)) {
        uint64_t v42 = 43;
      }
      else {
        uint64_t v42 = 45;
      }
      ClassName = object_getClassName(v9);
      Name = sel_getName("formatTagToNdef:withKey:error:");
      Logger(3, "%c[%{public}s %{public}s]:%i Unsupport tag type:%d", v42, ClassName, Name, 495, [v7 type]);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v45 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v45, OS_LOG_TYPE_ERROR))
    {
      id v46 = object_getClass(v9);
      if (class_isMetaClass(v46)) {
        int v47 = 43;
      }
      else {
        int v47 = 45;
      }
      *(_DWORD *)long long buf = 67110146;
      int v70 = v47;
      __int16 v71 = 2082;
      id v72 = object_getClassName(v9);
      __int16 v73 = 2082;
      id v74 = sel_getName("formatTagToNdef:withKey:error:");
      __int16 v75 = 1024;
      int v76 = 495;
      __int16 v77 = 1024;
      unsigned int v78 = [v7 type];
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Unsupport tag type:%d", buf, 0x28u);
    }

    if (a4)
    {
      id v48 = objc_alloc((Class)NSError);
      id v49 = +[NSString stringWithUTF8String:"nfcd"];
      v67[0] = NSLocalizedDescriptionKey;
      id v50 = +[NSString stringWithUTF8String:"Feature Not Supported"];
      v68[0] = v50;
      v68[1] = &off_10031CE88;
      v67[1] = @"Line";
      v67[2] = @"Method";
      id v51 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("formatTagToNdef:withKey:error:")];
      v68[2] = v51;
      v67[3] = NSDebugDescriptionErrorKey;
      id v52 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("formatTagToNdef:withKey:error:"), 496];
      v68[3] = v52;
      id v53 = +[NSDictionary dictionaryWithObjects:v68 forKeys:v67 count:4];
      *a4 = [v48 initWithDomain:v49 code:14 userInfo:v53];
    }
    goto LABEL_5;
  }
  sub_10018F904((uint64_t)v9, v7);
  int v17 = NFDriverRemoteDevCheckNdef();
  if (v17 > 11)
  {
    if (v17 != 12)
    {
      if (v17 == 23)
      {
        if (a4)
        {
          id v24 = objc_alloc((Class)NSError);
          id v19 = +[NSString stringWithUTF8String:"nfcd"];
          v65[0] = NSLocalizedDescriptionKey;
          id v25 = +[NSString stringWithUTF8String:"Reader mode prohibit timer"];
          v66[0] = v25;
          v66[1] = &off_10031CEA0;
          v65[1] = @"Line";
          v65[2] = @"Method";
          id v26 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("formatTagToNdef:withKey:error:")];
          v66[2] = v26;
          v65[3] = NSDebugDescriptionErrorKey;
          id v27 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("formatTagToNdef:withKey:error:"), 504];
          v66[3] = v27;
          uint64_t v28 = +[NSDictionary dictionaryWithObjects:v66 forKeys:v65 count:4];
          *a4 = [v24 initWithDomain:v19 code:64 userInfo:v28];

          goto LABEL_25;
        }
        goto LABEL_5;
      }
LABEL_22:
      uint64_t ErrorCode = NFDriverCreateErrorCode();
      id v19 = (void *)ErrorCode;
      BOOL v16 = 0;
      if (!a4 || !ErrorCode) {
        goto LABEL_26;
      }
      id v55 = objc_alloc((Class)NSError);
      id v57 = +[NSString stringWithUTF8String:"nfcd"];
      v61[0] = NSLocalizedDescriptionKey;
      id v30 = +[NSString stringWithUTF8String:"Stack Error"];
      v62[0] = v30;
      v62[1] = v19;
      v61[1] = NSUnderlyingErrorKey;
      v61[2] = @"Line";
      v62[2] = &off_10031CED0;
      v61[3] = @"Method";
      id v31 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("formatTagToNdef:withKey:error:")];
      v62[3] = v31;
      void v61[4] = NSDebugDescriptionErrorKey;
      id v32 = [objc_alloc((Class)NSString) initWithFormat:sel_getName("formatTagToNdef:withKey:error:")];
      v62[4] = v32;
      uint64_t v33 = +[NSDictionary dictionaryWithObjects:v62 forKeys:v61 count:5];
      *a4 = [v55 initWithDomain:v57 code:15 userInfo:v33];

LABEL_25:
      BOOL v16 = 0;
LABEL_26:

      goto LABEL_27;
    }
LABEL_29:
    if ([v8 length])
    {
      id v35 = v8;
      [v35 bytes];
      [v35 length];
      NFDataCreateWithBytesNoCopy();
    }
    sub_10018F904((uint64_t)v9, v7);
    int v36 = NFDriverRemoteDevFormatNdef();
    BOOL v16 = v36 == 0;
    if (a4 && v36)
    {
      id v54 = objc_alloc((Class)NSError);
      id v56 = +[NSString stringWithUTF8String:"nfcd"];
      v59[0] = NSLocalizedDescriptionKey;
      id v58 = +[NSString stringWithUTF8String:"Tag Error"];
      v60[0] = v58;
      v60[1] = &off_10031CEE8;
      v59[1] = @"Line";
      v59[2] = @"Method";
      id v37 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("formatTagToNdef:withKey:error:")];
      v60[2] = v37;
      v59[3] = NSDebugDescriptionErrorKey;
      id v38 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("formatTagToNdef:withKey:error:"), 529];
      v60[3] = v38;
      id v39 = +[NSDictionary dictionaryWithObjects:v60 forKeys:v59 count:4];
      *a4 = [v54 initWithDomain:v56 code:29 userInfo:v39];
    }
    NFDataRelease();
    goto LABEL_27;
  }
  if (!v17) {
    goto LABEL_29;
  }
  if (v17 != 4) {
    goto LABEL_22;
  }
  if (a4)
  {
    id v18 = objc_alloc((Class)NSError);
    id v19 = +[NSString stringWithUTF8String:"nfcd"];
    v63[0] = NSLocalizedDescriptionKey;
    id v20 = +[NSString stringWithUTF8String:"SE not available"];
    v64[0] = v20;
    v64[1] = &off_10031CEB8;
    v63[1] = @"Line";
    v63[2] = @"Method";
    id v21 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("formatTagToNdef:withKey:error:")];
    v64[2] = v21;
    v63[3] = NSDebugDescriptionErrorKey;
    id v22 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", @"formatTagToNdef:withKey:error:", 507];
    v64[3] = v22;
    id v23 = +[NSDictionary dictionaryWithObjects:v64 forKeys:v63 count:4];
    *a4 = [v18 initWithDomain:v19 code:35 userInfo:v23];

    goto LABEL_25;
  }
LABEL_5:
  BOOL v16 = 0;
LABEL_27:
  objc_sync_exit(v9);

LABEL_28:
  return v16;
}

void sub_1001959E0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_100195A20(void *a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  if (a1)
  {
    id v9 = a1;
    objc_sync_enter(v9);
    if (v9[137])
    {
      if (a4)
      {
        id v10 = objc_alloc((Class)NSError);
        id v11 = +[NSString stringWithUTF8String:"nfcd"];
        v80[0] = NSLocalizedDescriptionKey;
        id v12 = +[NSString stringWithUTF8String:"Aborted"];
        v81[0] = v12;
        v81[1] = &off_10031CF00;
        v80[1] = @"Line";
        v80[2] = @"Method";
        id v13 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("transceive:tag:maxTimeout:error:")];
        v81[2] = v13;
        v80[3] = NSDebugDescriptionErrorKey;
        id v14 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("transceive:tag:maxTimeout:error:"), 540];
        v81[3] = v14;
        uint64_t v15 = +[NSDictionary dictionaryWithObjects:v81 forKeys:v80 count:4];
        *a4 = [v10 initWithDomain:v11 code:3 userInfo:v15];
      }
      goto LABEL_38;
    }
    id v16 = v7;
    [v16 bytes];
    [v16 length];
    NFDataCreateWithBytesNoCopy();
    if (a4) {
      *a4 = 0;
    }
    if ([v8 technology] == 4)
    {
      sub_10018F904((uint64_t)v9, v8);
      int v17 = NFDriverRemoteDeviceFelicaTransceive();
    }
    else if ([v8 technology] == 16)
    {
      sub_10018F904((uint64_t)v9, v8);
      int v17 = NFDriverRemoteDeviceIso15693Transceive();
    }
    else
    {
      if ([v8 technology] != 1 && objc_msgSend(v8, "technology") != 2)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (Logger)
        {
          Class = object_getClass(v9);
          if (class_isMetaClass(Class)) {
            uint64_t v37 = 43;
          }
          else {
            uint64_t v37 = 45;
          }
          ClassName = object_getClassName(v9);
          Name = sel_getName("transceive:tag:maxTimeout:error:");
          Logger(3, "%c[%{public}s %{public}s]:%i Tag tech = %d", v37, ClassName, Name, 564, [v8 technology]);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v40 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
        {
          id v41 = object_getClass(v9);
          if (class_isMetaClass(v41)) {
            int v42 = 43;
          }
          else {
            int v42 = 45;
          }
          id v43 = object_getClassName(v9);
          id v44 = sel_getName("transceive:tag:maxTimeout:error:");
          unsigned int v45 = [v8 technology];
          *(_DWORD *)long long buf = 67110146;
          int v71 = v42;
          __int16 v72 = 2082;
          __int16 v73 = v43;
          __int16 v74 = 2082;
          __int16 v75 = v44;
          __int16 v76 = 1024;
          int v77 = 564;
          __int16 v78 = 1024;
          unsigned int v79 = v45;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Tag tech = %d", buf, 0x28u);
        }

        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v46 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v46)
        {
          int v47 = object_getClass(v9);
          if (class_isMetaClass(v47)) {
            uint64_t v48 = 43;
          }
          else {
            uint64_t v48 = 45;
          }
          id v49 = object_getClassName(v9);
          id v50 = sel_getName("transceive:tag:maxTimeout:error:");
          v46(3, "%c[%{public}s %{public}s]:%i Reader mode transceive is not supported for this tag type", v48, v49, v50, 565);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v51 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
        {
          id v52 = object_getClass(v9);
          if (class_isMetaClass(v52)) {
            int v53 = 43;
          }
          else {
            int v53 = 45;
          }
          id v54 = object_getClassName(v9);
          id v55 = sel_getName("transceive:tag:maxTimeout:error:");
          *(_DWORD *)long long buf = 67109890;
          int v71 = v53;
          __int16 v72 = 2082;
          __int16 v73 = v54;
          __int16 v74 = 2082;
          __int16 v75 = v55;
          __int16 v76 = 1024;
          int v77 = 565;
          _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Reader mode transceive is not supported for this tag type", buf, 0x22u);
        }

        int v18 = 5;
LABEL_16:
        NFDataRelease();
        NFDataRelease();
        if (v18 > 19)
        {
          if (v18 == 20)
          {
            uint64_t ErrorCode = NFDriverCreateErrorCode();
            id v19 = (void *)ErrorCode;
            if (!a4 || !ErrorCode) {
              goto LABEL_37;
            }
            id v30 = objc_alloc((Class)NSError);
            id v59 = +[NSString stringWithUTF8String:"nfcd"];
            v66[0] = NSLocalizedDescriptionKey;
            id v20 = +[NSString stringWithUTF8String:"Tag Error"];
            v66[1] = NSUnderlyingErrorKey;
            v67[0] = v20;
            v67[1] = v19;
            id v21 = +[NSDictionary dictionaryWithObjects:v67 forKeys:v66 count:2];
            id v31 = [v30 initWithDomain:v59 code:29 userInfo:v21];
LABEL_35:
            *a4 = v31;
LABEL_36:

LABEL_37:
            goto LABEL_38;
          }
          if (v18 == 23)
          {
            uint64_t v23 = NFDriverCreateErrorCode();
            id v19 = (void *)v23;
            if (!a4 || !v23) {
              goto LABEL_37;
            }
            id v57 = objc_alloc((Class)NSError);
            id v59 = +[NSString stringWithUTF8String:"nfcd"];
            v64[0] = NSLocalizedDescriptionKey;
            id v20 = +[NSString stringWithUTF8String:"Reader mode prohibit timer"];
            v65[0] = v20;
            v65[1] = v19;
            v64[1] = NSUnderlyingErrorKey;
            v64[2] = @"Line";
            v65[2] = &off_10031CF30;
            v64[3] = @"Method";
            id v21 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("transceive:tag:maxTimeout:error:")];
            v65[3] = v21;
            void v64[4] = NSDebugDescriptionErrorKey;
            id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("transceive:tag:maxTimeout:error:"), 588];
            void v65[4] = v24;
            id v25 = +[NSDictionary dictionaryWithObjects:v65 forKeys:v64 count:5];
            *a4 = [v57 initWithDomain:v59 code:64 userInfo:v25];

            goto LABEL_36;
          }
        }
        else
        {
          if (v18 == 4)
          {
            uint64_t v26 = NFDriverCreateErrorCode();
            id v19 = (void *)v26;
            if (!a4 || !v26) {
              goto LABEL_37;
            }
            id v58 = objc_alloc((Class)NSError);
            id v59 = +[NSString stringWithUTF8String:"nfcd"];
            v62[0] = NSLocalizedDescriptionKey;
            id v20 = +[NSString stringWithUTF8String:"SE not available"];
            v63[0] = v20;
            v63[1] = v19;
            v62[1] = NSUnderlyingErrorKey;
            v62[2] = @"Line";
            v63[2] = &off_10031CF48;
            v62[3] = @"Method";
            id v21 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("transceive:tag:maxTimeout:error:")];
            v63[3] = v21;
            v62[4] = NSDebugDescriptionErrorKey;
            id v27 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("transceive:tag:maxTimeout:error:"), 591];
            void v63[4] = v27;
            uint64_t v28 = +[NSDictionary dictionaryWithObjects:v63 forKeys:v62 count:5];
            *a4 = [v58 initWithDomain:v59 code:35 userInfo:v28];

            goto LABEL_36;
          }
          if (v18 == 6)
          {
            if (!a4)
            {
LABEL_38:
              objc_sync_exit(v9);

              goto LABEL_39;
            }
            id v56 = objc_alloc((Class)NSError);
            id v19 = +[NSString stringWithUTF8String:"nfcd"];
            v68[0] = NSLocalizedDescriptionKey;
            id v59 = +[NSString stringWithUTF8String:"Tag Not Found"];
            v69[0] = v59;
            v69[1] = &off_10031CF18;
            v68[1] = @"Line";
            v68[2] = @"Method";
            id v20 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("transceive:tag:maxTimeout:error:")];
            v69[2] = v20;
            v68[3] = NSDebugDescriptionErrorKey;
            id v21 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("transceive:tag:maxTimeout:error:"), 577];
            v69[3] = v21;
            id v22 = +[NSDictionary dictionaryWithObjects:v69 forKeys:v68 count:4];
            *a4 = [v56 initWithDomain:v19 code:28 userInfo:v22];

            goto LABEL_36;
          }
        }
        uint64_t v32 = NFDriverCreateErrorCode();
        id v19 = (void *)v32;
        if (!a4 || !v32) {
          goto LABEL_37;
        }
        id v33 = objc_alloc((Class)NSError);
        id v59 = +[NSString stringWithUTF8String:"nfcd"];
        v60[0] = NSLocalizedDescriptionKey;
        id v20 = +[NSString stringWithUTF8String:"Stack Error"];
        v60[1] = NSUnderlyingErrorKey;
        v61[0] = v20;
        v61[1] = v19;
        id v21 = +[NSDictionary dictionaryWithObjects:v61 forKeys:v60 count:2];
        id v31 = [v33 initWithDomain:v59 code:15 userInfo:v21];
        goto LABEL_35;
      }
      sub_10018F904((uint64_t)v9, v8);
      int v17 = NFDriverRemoteDeviceIso14443Transceive();
    }
    int v18 = v17;
    goto LABEL_16;
  }
LABEL_39:

  return 0;
}

void sub_1001965A8(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1001965F4(void *a1)
{
  if (a1 && (v1 = a1, objc_sync_enter(v1), int v2 = v1[137], objc_sync_exit(v1), v1, !v2)) {
    return NFDriverRemoteDevReceive();
  }
  else {
    return 0;
  }
}

void sub_1001969EC(void *a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (a1)
  {
    uint64_t v5 = a1;
    objc_sync_enter(v5);
    if (v5[137])
    {
      id v6 = objc_alloc((Class)NSError);
      id v7 = +[NSString stringWithUTF8String:"nfcd"];
      v14[0] = NSLocalizedDescriptionKey;
      id v8 = +[NSString stringWithUTF8String:"Invalid State"];
      v15[0] = v8;
      v15[1] = &off_10031CF60;
      v14[1] = @"Line";
      v14[2] = @"Method";
      id v9 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("readFromHCEDevice:completion:")];
      v15[2] = v9;
      v14[3] = NSDebugDescriptionErrorKey;
      id v10 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("readFromHCEDevice:completion:"), 633];
      v15[3] = v10;
      id v11 = +[NSDictionary dictionaryWithObjects:v15 forKeys:v14 count:4];
      id v12 = [v6 initWithDomain:v7 code:12 userInfo:v11];
      v4[2](v4, 0, v12);

      objc_sync_exit(v5);
    }
    else
    {
      objc_sync_exit(v5);

      id v13 = v4;
      NFDriverRemoteDevReceiveAsync();
      uint64_t v5 = v13;
    }
  }
}

void sub_100196C60(_Unwind_Exception *exception_object)
{
}

void sub_100196C7C(uint64_t a1, int a2)
{
  id v3 = 0;
  switch(a2)
  {
    case 1:
      id v4 = objc_alloc((Class)NSError);
      uint64_t v5 = +[NSString stringWithUTF8String:"nfcd"];
      v23[0] = NSLocalizedDescriptionKey;
      id v6 = +[NSString stringWithUTF8String:"Stack Error"];
      v24[0] = v6;
      v24[1] = &off_10031CF90;
      v23[1] = @"Line";
      v23[2] = @"Method";
      id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 40))];
      v24[2] = v7;
      v23[3] = NSDebugDescriptionErrorKey;
      id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 40)), 645];
      v24[3] = v8;
      id v9 = +[NSDictionary dictionaryWithObjects:v24 forKeys:v23 count:4];
      id v10 = v4;
      id v11 = v5;
      uint64_t v12 = 15;
      goto LABEL_8;
    case 2:
    case 4:
      goto LABEL_9;
    case 3:
      id v14 = objc_alloc((Class)NSError);
      uint64_t v5 = +[NSString stringWithUTF8String:"nfcd"];
      v19[0] = NSLocalizedDescriptionKey;
      id v6 = +[NSString stringWithUTF8String:"No resources"];
      v20[0] = v6;
      v20[1] = &off_10031CFC0;
      v19[1] = @"Line";
      void v19[2] = @"Method";
      id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 40))];
      v20[2] = v7;
      v19[3] = NSDebugDescriptionErrorKey;
      id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 40)), 649];
      v20[3] = v8;
      id v9 = +[NSDictionary dictionaryWithObjects:v20 forKeys:v19 count:4];
      id v10 = v14;
      id v11 = v5;
      uint64_t v12 = 34;
      goto LABEL_8;
    case 5:
      id v15 = objc_alloc((Class)NSError);
      uint64_t v5 = +[NSString stringWithUTF8String:"nfcd"];
      v21[0] = NSLocalizedDescriptionKey;
      id v6 = +[NSString stringWithUTF8String:"Invalid Parameter"];
      v22[0] = v6;
      v22[1] = &off_10031CFA8;
      v21[1] = @"Line";
      v21[2] = @"Method";
      id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 40))];
      v22[2] = v7;
      v21[3] = NSDebugDescriptionErrorKey;
      id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 40)), 647];
      v22[3] = v8;
      id v9 = +[NSDictionary dictionaryWithObjects:v22 forKeys:v21 count:4];
      id v10 = v15;
      id v11 = v5;
      uint64_t v12 = 10;
      goto LABEL_8;
    case 6:
      id v16 = objc_alloc((Class)NSError);
      uint64_t v5 = +[NSString stringWithUTF8String:"nfcd"];
      v25[0] = NSLocalizedDescriptionKey;
      id v6 = +[NSString stringWithUTF8String:"Tag Not Found"];
      v26[0] = v6;
      v26[1] = &off_10031CF78;
      v25[1] = @"Line";
      v25[2] = @"Method";
      id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 40))];
      v26[2] = v7;
      v25[3] = NSDebugDescriptionErrorKey;
      id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 40)), 643];
      v26[3] = v8;
      id v9 = +[NSDictionary dictionaryWithObjects:v26 forKeys:v25 count:4];
      id v10 = v16;
      id v11 = v5;
      uint64_t v12 = 28;
      goto LABEL_8;
    default:
      if (a2 != 21) {
        goto LABEL_9;
      }
      id v13 = objc_alloc((Class)NSError);
      uint64_t v5 = +[NSString stringWithUTF8String:"nfcd"];
      v17[0] = NSLocalizedDescriptionKey;
      id v6 = +[NSString stringWithUTF8String:"Tag is halted"];
      v18[0] = v6;
      v18[1] = &off_10031CFD8;
      v17[1] = @"Line";
      v17[2] = @"Method";
      id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 40))];
      void v18[2] = v7;
      v17[3] = NSDebugDescriptionErrorKey;
      id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 40)), 651];
      v18[3] = v8;
      id v9 = +[NSDictionary dictionaryWithObjects:v18 forKeys:v17 count:4];
      id v10 = v13;
      id v11 = v5;
      uint64_t v12 = 62;
LABEL_8:
      id v3 = [v10 initWithDomain:v11 code:v12 userInfo:v9];

LABEL_9:
      (*(void (**)(void))(*(void *)(a1 + 32) + 16))();

      return;
  }
}

uint64_t sub_1001972F4(void *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = a1;
  objc_sync_enter(v1);
  int v2 = v1[137];
  objc_sync_exit(v1);

  if (v2) {
    return 0;
  }

  return NFDriverRemoteDevSend();
}

void sub_100197388(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  if (a1)
  {
    uint64_t v8 = objc_opt_new();
    [*(id *)(a1 + 56) removeAllObjects];
    sub_100212624(a1);
    id v9 = NFSharedSignpostLog();
    if (os_signpost_enabled(v9))
    {
      *(_WORD *)long long buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v9, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "TAGS_DETECTED", (const char *)&unk_100286819, buf, 2u);
    }
    __int16 v72 = (void *)v8;

    unsigned int v71 = a4;
    if (a4)
    {
      if (!a3)
      {
LABEL_38:
        [*(id *)(a1 + 88) tagDetected];
        sub_1001E6E4C(*(unsigned char **)(a1 + 80), 1u);
        if (!*(unsigned char *)(*(void *)(a1 + 40) + 62) || *(unsigned char *)(a1 + 64))
        {
          id v42 = *(id *)(a1 + 248);
          id v43 = v72;
          [v42 handleRemoteTagsDetected:v72 dropAndRestartDiscovery:v71];

LABEL_62:
          return;
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          id v58 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass((id)a1);
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName((id)a1);
          Name = sel_getName("driverDidDetectRemoteTags:count:dropAndRestartDiscovery:");
          uint64_t v62 = 45;
          if (isMetaClass) {
            uint64_t v62 = 43;
          }
          v58(3, "%c[%{public}s %{public}s]:%i Error ! Applet hasn't started reader mode, yet the field is on.", v62, ClassName, Name, 792);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v63 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
        {
          uint64_t v64 = object_getClass((id)a1);
          if (class_isMetaClass(v64)) {
            int v65 = 43;
          }
          else {
            int v65 = 45;
          }
          id v66 = object_getClassName((id)a1);
          id v67 = sel_getName("driverDidDetectRemoteTags:count:dropAndRestartDiscovery:");
          *(_DWORD *)long long buf = 67109890;
          int v76 = v65;
          __int16 v77 = 2082;
          __int16 v78 = v66;
          __int16 v79 = 2082;
          id v80 = v67;
          __int16 v81 = 1024;
          int v82 = 792;
          _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error ! Applet hasn't started reader mode, yet the field is on.", buf, 0x22u);
        }

        CFStringRef v55 = @"tag found during SERM, Applet did not request SERM.";
        sub_100198FF8((uint64_t)NFBugCapture, @"Applet hasn't started reader mode, yet we found a tag", @"tag found during SERM, Applet did not request SERM.", 0);
        uint64_t v56 = 6;
LABEL_61:
        +[NFExceptionsCALogger postAnalyticsSEFailureEvent:v56 context:v55 error:0];
        id v43 = v72;
        goto LABEL_62;
      }
    }
    else if (!a2 || !a3)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v44 = NFLogGetLogger();
      if (v44)
      {
        unsigned int v45 = (void (*)(uint64_t, const char *, ...))v44;
        id v46 = object_getClass((id)a1);
        BOOL v47 = class_isMetaClass(v46);
        uint64_t v48 = object_getClassName((id)a1);
        id v69 = sel_getName("driverDidDetectRemoteTags:count:dropAndRestartDiscovery:");
        uint64_t v49 = 45;
        if (v47) {
          uint64_t v49 = 43;
        }
        v45(3, "%c[%{public}s %{public}s]:%i Invalid tag data", v49, v48, v69, 697);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v50 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
      {
        id v51 = object_getClass((id)a1);
        if (class_isMetaClass(v51)) {
          int v52 = 43;
        }
        else {
          int v52 = 45;
        }
        int v53 = object_getClassName((id)a1);
        id v54 = sel_getName("driverDidDetectRemoteTags:count:dropAndRestartDiscovery:");
        *(_DWORD *)long long buf = 67109890;
        int v76 = v52;
        __int16 v77 = 2082;
        __int16 v78 = v53;
        __int16 v79 = 2082;
        id v80 = v54;
        __int16 v81 = 1024;
        int v82 = 697;
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid tag data", buf, 0x22u);
      }

      CFStringRef v55 = @"NFC Invalid tag data";
      sub_100198FF8((uint64_t)NFBugCapture, @"NFC Invalid tag data", @"NFC Invalid tag data", 0);
      uint64_t v56 = 5;
      goto LABEL_61;
    }
    uint64_t v10 = a3;
    id v11 = (unsigned __int8 *)(a2 + 67);
    while (2)
    {
      id v12 = objc_alloc_init((Class)NFTagInternal);
      id v13 = [objc_alloc((Class)NSData) initWithBytes:v11 + 5 length:v11[21]];
      [v12 _setIdentifier:v13];
      switch(*(_DWORD *)(v11 - 59))
      {
        case 0:
          [v12 _setTechnology:0];
          id v25 = v12;
          uint64_t v26 = 0;
          goto LABEL_35;
        case 1:
          [v12 _setTechnology:1];
          unsigned int v27 = *(_DWORD *)(v11 - 55);
          if (v27 <= 2) {
            [v12 _setType:v27 + 1];
          }
          id v28 = [objc_alloc((Class)NSData) initWithBytes:v11 - 48 length:*v11];
          [v12 _setHistoricalBytes:v28];

          id v29 = [objc_alloc((Class)NSData) initWithBytes:v11 - 50 length:2];
          [v12 _setAtqa:v29];

          id v30 = [objc_alloc((Class)NSData) initWithBytes:v11 - 51 length:1];
          [v12 _setSak:v30];

          uint64_t v31 = v11[1];
          goto LABEL_27;
        case 2:
          [v12 _setTechnology:2];
          unsigned int v32 = *(_DWORD *)(v11 - 55);
          if (v32 <= 2) {
            [v12 _setType:v32 + 4];
          }
          uint64_t v31 = *(v11 - 51);
LABEL_27:
          [v12 _setSFGI:v31];
          goto LABEL_36;
        case 3:
          [v12 _setTechnology:4];
          [v12 _setType:7];
          id v33 = [objc_alloc((Class)NSData) initWithBytes:v11 - 54 length:*(v11 - 55)];
          [v12 _setIdentifier:v33];

          id v34 = [objc_alloc((Class)NSData) initWithBytes:v11 - 54 length:*(v11 - 55)];
          [v12 _setIDm:v34];

          id v35 = [objc_alloc((Class)NSData) initWithBytes:v11 - 44 length:8];
          [v12 _setPMm:v35];
          goto LABEL_30;
        case 4:
          [v12 _setTechnology:1];
          [v12 _setType:9];
          id v36 = [objc_alloc((Class)NSData) initWithBytes:v11 - 48 length:*v11];
          [v12 _setHistoricalBytes:v36];

          id v37 = [objc_alloc((Class)NSData) initWithBytes:v11 - 50 length:2];
          [v12 _setAtqa:v37];

          id v35 = [objc_alloc((Class)NSData) initWithBytes:v11 - 51 length:1];
          [v12 _setSak:v35];
LABEL_30:

          goto LABEL_36;
        case 5:
          [v12 _setTechnology:16];
          id v25 = v12;
          uint64_t v26 = 8;
          goto LABEL_35;
        case 6:
          [v12 _setTechnology:1];
          id v25 = v12;
          uint64_t v26 = 11;
          goto LABEL_35;
        case 7:
          [v12 _setTechnology:1];
          id v25 = v12;
          uint64_t v26 = 12;
          goto LABEL_35;
        case 8:
          [v12 _setTechnology:0];
          id v25 = v12;
          uint64_t v26 = 10;
LABEL_35:
          [v25 _setType:v26];
          goto LABEL_36;
        case 9:
        case 0xA:
        case 0xB:
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v14 = NFLogGetLogger();
          if (v14)
          {
            id v15 = (void (*)(uint64_t, const char *, ...))v14;
            id v16 = object_getClass((id)a1);
            BOOL v17 = class_isMetaClass(v16);
            int v18 = object_getClassName((id)a1);
            id v68 = sel_getName("driverDidDetectRemoteTags:count:dropAndRestartDiscovery:");
            uint64_t v19 = 45;
            if (v17) {
              uint64_t v19 = 43;
            }
            v15(4, "%c[%{public}s %{public}s]:%i unexpected silent tag found", v19, v18, v68, 772);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v20 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            id v21 = object_getClass((id)a1);
            if (class_isMetaClass(v21)) {
              int v22 = 43;
            }
            else {
              int v22 = 45;
            }
            uint64_t v23 = object_getClassName((id)a1);
            id v24 = sel_getName("driverDidDetectRemoteTags:count:dropAndRestartDiscovery:");
            *(_DWORD *)long long buf = 67109890;
            int v76 = v22;
            __int16 v77 = 2082;
            __int16 v78 = v23;
            __int16 v79 = 2082;
            id v80 = v24;
            __int16 v81 = 1024;
            int v82 = 772;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i unexpected silent tag found", buf, 0x22u);
          }
          goto LABEL_37;
        default:
LABEL_36:
          id v20 = [(id)a1 _getExtendedIdentifier:v12];
          id v38 = *(void **)(a1 + 56);
          v73[0] = @"tagHandle";
          id v39 = +[NSValue valueWithPointer:*(void *)(v11 - 67)];
          v73[1] = @"type";
          v74[0] = v39;
          id v40 = +[NSNumber numberWithUnsignedInt:](NSNumber, "numberWithUnsignedInt:", [v12 type]);
          v74[1] = v40;
          id v41 = +[NSDictionary dictionaryWithObjects:v74 forKeys:v73 count:2];
          [v38 setObject:v41 forKey:v20];

          [v12 _setUID:v20];
          [v72 addObject:v12];
LABEL_37:

          v11 += 96;
          if (!--v10) {
            goto LABEL_38;
          }
          continue;
      }
    }
  }
}

void sub_100197CC0(uint64_t a1)
{
  if (a1)
  {
    id v1 = *(id *)(a1 + 248);
    [v1 handleHceTargetLost];
  }
}

void sub_100197FD8(id a1)
{
  id v1 = objc_alloc_init(NFBugCapture);
  uint64_t v2 = qword_100347530;
  qword_100347530 = (uint64_t)v1;

  _objc_release_x1(v1, v2);
}

id sub_100198D9C(uint64_t a1)
{
  return [*(id *)(a1 + 32) _handleCallbackSync:*(void *)(a1 + 40)];
}

void sub_100198DA8(uint64_t a1, void *a2, void *a3, void *a4, void *a5, void *a6)
{
  id v10 = a2;
  id v11 = a3;
  id v12 = a4;
  id v13 = a5;
  id v14 = a6;
  self;
  if (os_variant_has_internal_diagnostics())
  {
    id v16 = +[NFBugCapture _getInstance];
    BOOL v17 = v16;
    if (v16)
    {
      int v18 = v16[1];
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_100198F34;
      block[3] = &unk_100306448;
      id v20 = v16;
      id v21 = v10;
      id v22 = v11;
      id v23 = 0;
      id v24 = v12;
      id v25 = v13;
      id v26 = v14;
      dispatch_async(v18, block);
    }
  }
}

id sub_100198F34(uint64_t a1)
{
  return [*(id *)(a1 + 32) _requestTapToRadarSync:*(void *)(a1 + 40) componentName:*(void *)(a1 + 48) preferences:*(void *)(a1 + 56) withType:*(void *)(a1 + 64) withSubTypeContext:*(void *)(a1 + 72) additionalInfo:*(void *)(a1 + 80)];
}

void sub_100198F4C(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v6 = a4;
  id v7 = a3;
  id v8 = a2;
  self;
  if (v6) {
    id v9 = v6;
  }
  else {
    id v9 = &off_100323460;
  }
  id v10 = v9;
  sub_100198DA8((uint64_t)NFBugCapture, v8, @"NFC-SE", @"Transaction Failure", v7, v9);
}

void sub_100198FF8(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v6 = a4;
  id v7 = a3;
  id v8 = a2;
  self;
  if (v6) {
    id v9 = v6;
  }
  else {
    id v9 = &off_100323488;
  }
  id v10 = v9;
  sub_100198DA8((uint64_t)NFBugCapture, v8, @"Purple Stockholm", @"Unexpected crash", v7, v9);
}

void sub_1001990A4(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v6 = a4;
  id v7 = a3;
  id v8 = a2;
  self;
  if (v6) {
    id v9 = v6;
  }
  else {
    id v9 = &off_1003234B0;
  }
  id v10 = v9;
  sub_100198DA8((uint64_t)NFBugCapture, v8, @"NFC-SE", @"Contactless Failure", v7, v9);
}

void sub_100199150(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v6 = a4;
  id v7 = a3;
  id v8 = a2;
  self;
  sub_100198DA8((uint64_t)NFBugCapture, v8, @"NFC-SE", @"Provisioning Failure", v7, v6);
}

void sub_1001991EC(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v6 = a4;
  id v7 = a3;
  id v8 = a2;
  self;
  sub_100198DA8((uint64_t)NFBugCapture, v8, @"NFC-SE", @"ATL Failure", v7, v6);
}

void sub_100199288(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v6 = a4;
  id v7 = a3;
  id v8 = a2;
  self;
  if (v6) {
    id v9 = v6;
  }
  else {
    id v9 = &off_1003234D8;
  }
  id v10 = v9;
  sub_100198DA8((uint64_t)NFBugCapture, v8, @"NFC-SE", @"Express Mode Failure", v7, v9);
}

void sub_100199334(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v6 = a4;
  id v7 = a3;
  id v8 = a2;
  self;
  if (v6) {
    id v9 = v6;
  }
  else {
    id v9 = &off_100323500;
  }
  id v10 = v9;
  sub_100198DA8((uint64_t)NFBugCapture, v8, @"Purple Stockholm", @"NFAccessory Failure", v7, v9);
}

void sub_10019A40C()
{
  uint64_t v6 = 0;
  id v7 = &v6;
  uint64_t v8 = 0x2020000000;
  id v0 = (void **)qword_100347510;
  uint64_t v9 = qword_100347510;
  if (!qword_100347510)
  {
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    void v5[2] = sub_10019B568;
    v5[3] = &unk_100301E40;
    void v5[4] = &v6;
    sub_10019B568(v5);
    id v0 = (void **)v7[3];
  }
  _Block_object_dispose(&v6, 8);
  if (v0)
  {
    id v1 = *v0;
    id v2 = v1;
  }
  else
  {
    id v3 = +[NSAssertionHandler currentHandler];
    id v4 = +[NSString stringWithUTF8String:"NSString *getSBUserNotificationDismissOnLock(void)"];
    [v3 handleFailureInFunction:v4 file:@"NFBugCapture.m" lineNumber:43 description:@"%s", dlerror()];

    __break(1u);
  }
}

void sub_10019A538(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_10019A550(uint64_t a1, uint64_t a2)
{
  return +[NFBugCapture handleCallback:a2];
}

void sub_10019AE20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_10019AE40(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v32 = 0;
  id v33 = &v32;
  uint64_t v34 = 0x2020000000;
  id v4 = (void *)qword_100347528;
  uint64_t v35 = qword_100347528;
  if (!qword_100347528)
  {
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)id v37 = 3221225472;
    *(void *)&v37[8] = sub_10019B8D8;
    *(void *)&v37[16] = &unk_100301E40;
    *(void *)&v37[24] = &v32;
    uint64_t v5 = sub_10019B710();
    uint64_t v6 = dlsym(v5, "kSymptomDiagnosticReplySuccess");
    *(void *)(*(void *)(*(void *)&v37[24] + 8) + 24) = v6;
    qword_100347528 = *(void *)(*(void *)(*(void *)&v37[24] + 8) + 24);
    id v4 = (void *)v33[3];
  }
  _Block_object_dispose(&v32, 8);
  if (!v4)
  {
    id v30 = +[NSAssertionHandler currentHandler];
    uint64_t v31 = +[NSString stringWithUTF8String:"NSString *const getkSymptomDiagnosticReplySuccess(void)"];
    [v30 handleFailureInFunction:v31 file:@"NFBugCapture.m" lineNumber:39 description:@"%s", dlerror()];

    __break(1u);
  }
  id v7 = [v3 objectForKeyedSubscript:*v4];
  unsigned int v8 = [v7 BOOLValue];

  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  id v10 = (void (*)(uint64_t, const char *, ...))Logger;
  if (v8)
  {
    if (Logger)
    {
      Class = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(Class)) {
        uint64_t v12 = 43;
      }
      else {
        uint64_t v12 = 45;
      }
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      v10(6, "%c[%{public}s %{public}s]:%i ABC Request submitted successfully", v12, ClassName, Name, 528);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v15 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      id v16 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v16)) {
        int v17 = 43;
      }
      else {
        int v17 = 45;
      }
      int v18 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v19 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)long long buf = 67109890;
      *(_DWORD *)&uint8_t buf[4] = v17;
      *(_WORD *)id v37 = 2082;
      *(void *)&v37[2] = v18;
      *(_WORD *)&v37[10] = 2082;
      *(void *)&v37[12] = v19;
      *(_WORD *)&v37[20] = 1024;
      *(_DWORD *)&v37[22] = 528;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ABC Request submitted successfully", buf, 0x22u);
    }
  }
  else
  {
    if (Logger)
    {
      id v20 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v20)) {
        uint64_t v21 = 43;
      }
      else {
        uint64_t v21 = 45;
      }
      id v22 = object_getClassName(*(id *)(a1 + 32));
      id v23 = sel_getName(*(SEL *)(a1 + 40));
      id v24 = [v3 objectForKeyedSubscript:@"reason"];
      v10(3, "%c[%{public}s %{public}s]:%i ABC Request was rejected. Reason Code: %{public}@", v21, v22, v23, 530, v24);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v15 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      id v25 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v25)) {
        int v26 = 43;
      }
      else {
        int v26 = 45;
      }
      unsigned int v27 = object_getClassName(*(id *)(a1 + 32));
      id v28 = sel_getName(*(SEL *)(a1 + 40));
      id v29 = [v3 objectForKeyedSubscript:@"reason"];
      *(_DWORD *)long long buf = 67110146;
      *(_DWORD *)&uint8_t buf[4] = v26;
      *(_WORD *)id v37 = 2082;
      *(void *)&v37[2] = v27;
      *(_WORD *)&v37[10] = 2082;
      *(void *)&v37[12] = v28;
      *(_WORD *)&v37[20] = 1024;
      *(_DWORD *)&v37[22] = 530;
      *(_WORD *)&v37[26] = 2114;
      *(void *)&v37[28] = v29;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i ABC Request was rejected. Reason Code: %{public}@", buf, 0x2Cu);
    }
  }
}

void sub_10019B264(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_10019B4F4()
{
  uint64_t result = _sl_dlopen();
  qword_100347508 = result;
  return result;
}

void *sub_10019B568(void *a1)
{
  uint64_t v2 = sub_10000AF94();
  if (v2)
  {
    id v3 = (void *)v2;
  }
  else
  {
    a1 = +[NSAssertionHandler currentHandler];
    id v3 = +[NSString stringWithUTF8String:"void *SpringBoardServicesLibrary(void)"];
    [a1 handleFailureInFunction:v3 file:@"NFBugCapture.m" lineNumber:42 description:@"%s"];

    __break(1u);
    free(v5);
  }
  uint64_t result = dlsym(v3, "SBUserNotificationDismissOnLock");
  *(void *)(*(void *)(a1[4] + 8) + 24) = result;
  qword_100347510 = *(void *)(*(void *)(a1[4] + 8) + 24);
  return result;
}

void sub_10019B648(uint64_t a1)
{
  sub_10019B710();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("SDRDiagnosticReporter");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    qword_100347518 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    uint64_t v2 = +[NSAssertionHandler currentHandler];
    id v3 = +[NSString stringWithUTF8String:"Class getSDRDiagnosticReporterClass(void)_block_invoke"];
    [v2 handleFailureInFunction:v3 file:@"NFBugCapture.m" lineNumber:38 description:@"Unable to find class %s", "SDRDiagnosticReporter"];

    __break(1u);
  }
}

void *sub_10019B710()
{
  v4[0] = 0;
  if (!qword_100347520)
  {
    v4[1] = _NSConcreteStackBlock;
    v4[2] = (void *)3221225472;
    v4[3] = sub_10019B864;
    v4[4] = &unk_1003010A8;
    v4[5] = v4;
    long long v5 = off_1003064A8;
    uint64_t v6 = 0;
    qword_100347520 = _sl_dlopen();
  }
  id v0 = (void *)qword_100347520;
  if (!qword_100347520)
  {
    id v0 = +[NSAssertionHandler currentHandler];
    id v3 = +[NSString stringWithUTF8String:"void *SymptomDiagnosticReporterLibrary(void)"];
    [v0 handleFailureInFunction:v3 file:@"NFBugCapture.m" lineNumber:37 description:@"%s" v4[0]];

    __break(1u);
    goto LABEL_7;
  }
  id v1 = v4[0];
  if (v4[0]) {
LABEL_7:
  }
    free(v1);
  return v0;
}

uint64_t sub_10019B864()
{
  uint64_t result = _sl_dlopen();
  qword_100347520 = result;
  return result;
}

void *sub_10019B8D8(uint64_t a1)
{
  uint64_t v2 = sub_10019B710();
  uint64_t result = dlsym(v2, "kSymptomDiagnosticReplySuccess");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  qword_100347528 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_10019B928(void *a1)
{
  if (a1)
  {
    uint64_t v2 = [a1 driverWrapper];
    char v3 = sub_1001AA1B4((uint64_t)v2);

    uint64_t v4 = v3 & 0x1E;
    if (v4)
    {
      if (byte_100347540) {
        return;
      }
      long long v5 = [a1 driverWrapper];
      id v6 = sub_10020EC8C(v5, @"LPEM features", 1uLL);
    }
    else
    {
      if (!byte_100347540) {
        return;
      }
      long long v5 = [a1 driverWrapper];
      sub_1002114AC(v5, @"LPEM features");
    }

    byte_100347540 = v4 != 0;
  }
}

void sub_10019BB10(uint64_t a1)
{
}

void sub_10019BB18(uint64_t a1)
{
  if (-[_NFHardwareManager getPrimaryHardwareState]_0(*(void *)(a1 + 32)) != 2)
  {
    uint64_t v19 = *(void *)(a1 + 40);
    id v29 = objc_alloc((Class)NSError);
    uint64_t v21 = +[NSString stringWithUTF8String:"nfcd"];
    v114[0] = NSLocalizedDescriptionKey;
    id v22 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
    v115[0] = v22;
    v115[1] = &off_10031CFF0;
    v114[1] = @"Line";
    v114[2] = @"Method";
    id v23 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v115[2] = v23;
    v114[3] = NSDebugDescriptionErrorKey;
    id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 54];
    v115[3] = v24;
    id v25 = +[NSDictionary dictionaryWithObjects:v115 forKeys:v114 count:4];
    int v26 = v29;
    unsigned int v27 = v21;
    uint64_t v28 = 58;
LABEL_20:
    id v31 = [v26 initWithDomain:v27 code:v28 userInfo:v25];
    (*(void (**)(uint64_t, id))(v19 + 16))(v19, v31);

    goto LABEL_21;
  }
  uint64_t v2 = [*(id *)(a1 + 32) controllerInfo];
  if (([v2 hasLPEMSupport] & 1) == 0)
  {

    goto LABEL_19;
  }
  char v3 = [*(id *)(a1 + 32) driverWrapper];
  char v4 = sub_1001AA204((uint64_t)v3, *(void *)(a1 + 64));

  if ((v4 & 1) == 0)
  {
LABEL_19:
    uint64_t v19 = *(void *)(a1 + 40);
    id v30 = objc_alloc((Class)NSError);
    uint64_t v21 = +[NSString stringWithUTF8String:"nfcd"];
    v112[0] = NSLocalizedDescriptionKey;
    id v22 = +[NSString stringWithUTF8String:"Feature Not Supported"];
    v113[0] = v22;
    v113[1] = &off_10031D008;
    v112[1] = @"Line";
    v112[2] = @"Method";
    id v23 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v113[2] = v23;
    v112[3] = NSDebugDescriptionErrorKey;
    id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 59];
    v113[3] = v24;
    id v25 = +[NSDictionary dictionaryWithObjects:v113 forKeys:v112 count:4];
    int v26 = v30;
    unsigned int v27 = v21;
    uint64_t v28 = 14;
    goto LABEL_20;
  }
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5)
  {
    id v6 = (unsigned __int8 *)*(id *)(v5 + 24);
    if (v6)
    {
      int v7 = v6[172];

      if (v7)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          uint64_t v9 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(*(id *)(a1 + 32));
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(*(id *)(a1 + 32));
          Name = sel_getName(*(SEL *)(a1 + 56));
          uint64_t v13 = 45;
          if (isMetaClass) {
            uint64_t v13 = 43;
          }
          v9(5, "%c[%{public}s %{public}s]:%i Cannot disable LPEM feature when express mode is active", v13, ClassName, Name, 64);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v14 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          id v15 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v15)) {
            int v16 = 43;
          }
          else {
            int v16 = 45;
          }
          int v17 = object_getClassName(*(id *)(a1 + 32));
          int v18 = sel_getName(*(SEL *)(a1 + 56));
          *(_DWORD *)long long buf = 67109890;
          int v96 = v16;
          __int16 v97 = 2082;
          uint64_t v98 = v17;
          __int16 v99 = 2082;
          int v100 = v18;
          __int16 v101 = 1024;
          int v102 = 64;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Cannot disable LPEM feature when express mode is active", buf, 0x22u);
        }

        uint64_t v19 = *(void *)(a1 + 40);
        id v20 = objc_alloc((Class)NSError);
        uint64_t v21 = +[NSString stringWithUTF8String:"nfcd"];
        v110[0] = NSLocalizedDescriptionKey;
        id v22 = +[NSString stringWithUTF8String:"Busy"];
        v111[0] = v22;
        v111[1] = &off_10031D020;
        v110[1] = @"Line";
        v110[2] = @"Method";
        id v23 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
        v111[2] = v23;
        v110[3] = NSDebugDescriptionErrorKey;
        id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 65];
        v111[3] = v24;
        id v25 = +[NSDictionary dictionaryWithObjects:v111 forKeys:v110 count:4];
        int v26 = v20;
        unsigned int v27 = v21;
        uint64_t v28 = 2;
        goto LABEL_20;
      }
    }
  }
  uint64_t v32 = [*(id *)(a1 + 32) driverWrapper];
  uint64_t v21 = sub_10020EC8C(v32, @"LPEM feature change", 1uLL);

  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v33 = NFLogGetLogger();
  uint64_t v34 = (void (*)(uint64_t, const char *, ...))v33;
  if (v21)
  {
    if (v33)
    {
      uint64_t v35 = object_getClass(*(id *)(a1 + 32));
      BOOL v36 = class_isMetaClass(v35);
      __int16 v88 = object_getClassName(*(id *)(a1 + 32));
      __int16 v90 = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v37 = 45;
      if (v36) {
        uint64_t v37 = 43;
      }
      v34(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v37, v88, v90, 71, v21);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v38 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
    {
      id v39 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v39)) {
        int v40 = 43;
      }
      else {
        int v40 = 45;
      }
      id v41 = object_getClassName(*(id *)(a1 + 32));
      id v42 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)long long buf = 67110146;
      int v96 = v40;
      __int16 v97 = 2082;
      uint64_t v98 = v41;
      __int16 v99 = 2082;
      int v100 = v42;
      __int16 v101 = 1024;
      int v102 = 71;
      __int16 v103 = 2112;
      *(void *)int v104 = v21;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
    }

    uint64_t v43 = *(void *)(a1 + 40);
    id v44 = objc_alloc((Class)NSError);
    unsigned int v45 = +[NSString stringWithUTF8String:"nfcd"];
    id v46 = [v21 code];
    v108[0] = NSLocalizedDescriptionKey;
    if ((uint64_t)[v21 code] > 70) {
      uint64_t v47 = 71;
    }
    else {
      uint64_t v47 = (uint64_t)[v21 code];
    }
    __int16 v79 = +[NSString stringWithUTF8String:off_1003064C0[v47]];
    v109[0] = v79;
    v109[1] = v21;
    v108[1] = NSUnderlyingErrorKey;
    v108[2] = @"Line";
    v109[2] = &off_10031D038;
    v108[3] = @"Method";
    id v80 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v109[3] = v80;
    v108[4] = NSDebugDescriptionErrorKey;
    id v81 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 72];
    v109[4] = v81;
    int v82 = +[NSDictionary dictionaryWithObjects:v109 forKeys:v108 count:5];
    id v83 = [v44 initWithDomain:v45 code:v46 userInfo:v82];
    (*(void (**)(uint64_t, id))(v43 + 16))(v43, v83);
  }
  else
  {
    if (v33)
    {
      uint64_t v48 = object_getClass(*(id *)(a1 + 32));
      BOOL v49 = class_isMetaClass(v48);
      id v50 = object_getClassName(*(id *)(a1 + 32));
      id v51 = sel_getName(*(SEL *)(a1 + 56));
      id v92 = [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) processIdentifier];
      uint64_t v52 = 45;
      if (v49) {
        uint64_t v52 = 43;
      }
      v34(6, "%c[%{public}s %{public}s]:%i PID %d disabling feature %d", v52, v50, v51, 76, v92, *(void *)(a1 + 64));
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v53 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
    {
      id v54 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v54)) {
        int v55 = 43;
      }
      else {
        int v55 = 45;
      }
      uint64_t v56 = object_getClassName(*(id *)(a1 + 32));
      id v57 = sel_getName(*(SEL *)(a1 + 56));
      unsigned int v58 = [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) processIdentifier];
      uint64_t v59 = *(void *)(a1 + 64);
      *(_DWORD *)long long buf = 67110402;
      int v96 = v55;
      __int16 v97 = 2082;
      uint64_t v98 = v56;
      __int16 v99 = 2082;
      int v100 = v57;
      __int16 v101 = 1024;
      int v102 = 76;
      __int16 v103 = 1024;
      *(_DWORD *)int v104 = v58;
      *(_WORD *)&v104[4] = 1024;
      *(_DWORD *)&v104[6] = v59;
      _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i PID %d disabling feature %d", buf, 0x2Eu);
    }

    __int16 v60 = [*(id *)(a1 + 32) driverWrapper];
    char v61 = sub_1001AA914((uint64_t)v60, *(void *)(a1 + 64));

    uint64_t v62 = *(void *)(a1 + 40);
    if (v61)
    {
      (*(void (**)(void, void))(v62 + 16))(*(void *)(a1 + 40), 0);
      sub_10019B928(*(void **)(a1 + 32));
      id v63 = [*(id *)(a1 + 32) driverWrapper];
      uint64_t v64 = sub_1001AA1B4((uint64_t)v63);

      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v65 = NFLogGetLogger();
      if (v65)
      {
        id v66 = (void (*)(uint64_t, const char *, ...))v65;
        id v67 = object_getClass(*(id *)(a1 + 32));
        BOOL v68 = class_isMetaClass(v67);
        id v69 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v91 = sel_getName(*(SEL *)(a1 + 56));
        uint64_t v70 = 45;
        if (v68) {
          uint64_t v70 = 43;
        }
        v66(6, "%c[%{public}s %{public}s]:%i posting %{public}@ to SESD - current state %lx", v70, v69, v91, 83, @"com.apple.stockholm.lpem.changed", v64);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      unsigned int v71 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v72 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v72)) {
          int v73 = 43;
        }
        else {
          int v73 = 45;
        }
        __int16 v74 = object_getClassName(*(id *)(a1 + 32));
        __int16 v75 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)long long buf = 67110402;
        int v96 = v73;
        __int16 v97 = 2082;
        uint64_t v98 = v74;
        __int16 v99 = 2082;
        int v100 = v75;
        __int16 v101 = 1024;
        int v102 = 83;
        __int16 v103 = 2114;
        *(void *)int v104 = @"com.apple.stockholm.lpem.changed";
        *(_WORD *)&v104[8] = 2048;
        uint64_t v105 = v64;
        _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i posting %{public}@ to SESD - current state %lx", buf, 0x36u);
      }

      int v76 = [*(id *)(a1 + 32) sesdEventPublisher];
      v93[0] = @"Payload";
      v93[1] = @"lpemFeatures";
      v94[0] = @"com.apple.stockholm.lpem.changed";
      __int16 v77 = +[NSNumber numberWithUnsignedInteger:v64];
      v94[1] = v77;
      id v78 = +[NSDictionary dictionaryWithObjects:v94 forKeys:v93 count:2];
      [v76 sendXpcNotificationEventWithDictionary:v78];
    }
    else
    {
      id v84 = objc_alloc((Class)NSError);
      int v76 = +[NSString stringWithUTF8String:"nfcd"];
      v106[0] = NSLocalizedDescriptionKey;
      __int16 v77 = +[NSString stringWithUTF8String:"Stack Error"];
      v107[0] = v77;
      v107[1] = &off_10031D050;
      v106[1] = @"Line";
      v106[2] = @"Method";
      id v78 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
      v107[2] = v78;
      v106[3] = NSDebugDescriptionErrorKey;
      id v85 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 78];
      v107[3] = v85;
      id v86 = +[NSDictionary dictionaryWithObjects:v107 forKeys:v106 count:4];
      id v87 = [v84 initWithDomain:v76 code:15 userInfo:v86];
      (*(void (**)(uint64_t, id))(v62 + 16))(v62, v87);
    }
    uint64_t v21 = [*(id *)(a1 + 32) driverWrapper];
    sub_1002114AC(v21, @"LPEM feature change");
  }
LABEL_21:
}

void sub_10019C848(uint64_t a1, uint64_t a2, char a3, void *a4)
{
  id v7 = a4;
  if (a1)
  {
    v15[0] = 0;
    v15[1] = v15;
    v15[2] = 0x3032000000;
    v15[3] = sub_10000B8D8;
    void v15[4] = sub_10019BB10;
    id v16 = +[NSXPCConnection currentConnection];
    unsigned int v8 = *(id *)(a1 + 232);
    v9[0] = _NSConcreteStackBlock;
    v9[1] = 3221225472;
    void v9[2] = sub_10019C988;
    v9[3] = &unk_100306730;
    void v9[4] = a1;
    uint64_t v12 = "enableLPEMFeature:rebootIfNeeded:completion:";
    uint64_t v13 = a2;
    char v14 = a3;
    id v10 = v7;
    id v11 = v15;
    dispatch_async(v8, v9);

    _Block_object_dispose(v15, 8);
  }
}

void sub_10019C988(uint64_t a1)
{
  if (-[_NFHardwareManager getPrimaryHardwareState]_0(*(void *)(a1 + 32)) != 2)
  {
    uint64_t v19 = *(void *)(a1 + 40);
    id v29 = objc_alloc((Class)NSError);
    id v21 = +[NSString stringWithUTF8String:"nfcd"];
    v129[0] = NSLocalizedDescriptionKey;
    id v22 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
    v130[0] = v22;
    v130[1] = &off_10031D068;
    v129[1] = @"Line";
    v129[2] = @"Method";
    id v23 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v130[2] = v23;
    v129[3] = NSDebugDescriptionErrorKey;
    id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 104];
    v130[3] = v24;
    id v25 = +[NSDictionary dictionaryWithObjects:v130 forKeys:v129 count:4];
    int v26 = v29;
    id v27 = v21;
    uint64_t v28 = 58;
LABEL_20:
    id v31 = [v26 initWithDomain:v27 code:v28 userInfo:v25];
    (*(void (**)(uint64_t, id))(v19 + 16))(v19, v31);

    goto LABEL_21;
  }
  uint64_t v2 = [*(id *)(a1 + 32) controllerInfo];
  if (([v2 hasLPEMSupport] & 1) == 0)
  {

    goto LABEL_19;
  }
  char v3 = [*(id *)(a1 + 32) driverWrapper];
  char v4 = sub_1001AA204((uint64_t)v3, *(void *)(a1 + 64));

  if ((v4 & 1) == 0)
  {
LABEL_19:
    uint64_t v19 = *(void *)(a1 + 40);
    id v30 = objc_alloc((Class)NSError);
    id v21 = +[NSString stringWithUTF8String:"nfcd"];
    v127[0] = NSLocalizedDescriptionKey;
    id v22 = +[NSString stringWithUTF8String:"Feature Not Supported"];
    v128[0] = v22;
    v128[1] = &off_10031D080;
    v127[1] = @"Line";
    v127[2] = @"Method";
    id v23 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v128[2] = v23;
    v127[3] = NSDebugDescriptionErrorKey;
    id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 109];
    v128[3] = v24;
    id v25 = +[NSDictionary dictionaryWithObjects:v128 forKeys:v127 count:4];
    int v26 = v30;
    id v27 = v21;
    uint64_t v28 = 14;
    goto LABEL_20;
  }
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5)
  {
    id v6 = (unsigned __int8 *)*(id *)(v5 + 24);
    if (v6)
    {
      int v7 = v6[172];

      if (v7)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          uint64_t v9 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(*(id *)(a1 + 32));
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(*(id *)(a1 + 32));
          Name = sel_getName(*(SEL *)(a1 + 56));
          uint64_t v13 = 45;
          if (isMetaClass) {
            uint64_t v13 = 43;
          }
          v9(5, "%c[%{public}s %{public}s]:%i Cannot enable LPEM feature when express mode is active", v13, ClassName, Name, 114);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        char v14 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
        {
          id v15 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v15)) {
            int v16 = 43;
          }
          else {
            int v16 = 45;
          }
          int v17 = object_getClassName(*(id *)(a1 + 32));
          int v18 = sel_getName(*(SEL *)(a1 + 56));
          *(_DWORD *)long long buf = 67109890;
          int v109 = v16;
          __int16 v110 = 2082;
          __int16 v111 = v17;
          __int16 v112 = 2082;
          __int16 v113 = v18;
          __int16 v114 = 1024;
          int v115 = 114;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Cannot enable LPEM feature when express mode is active", buf, 0x22u);
        }

        uint64_t v19 = *(void *)(a1 + 40);
        id v20 = objc_alloc((Class)NSError);
        id v21 = +[NSString stringWithUTF8String:"nfcd"];
        v125[0] = NSLocalizedDescriptionKey;
        id v22 = +[NSString stringWithUTF8String:"Busy"];
        v126[0] = v22;
        v126[1] = &off_10031D098;
        v125[1] = @"Line";
        v125[2] = @"Method";
        id v23 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
        v126[2] = v23;
        v125[3] = NSDebugDescriptionErrorKey;
        id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 115];
        v126[3] = v24;
        id v25 = +[NSDictionary dictionaryWithObjects:v126 forKeys:v125 count:4];
        int v26 = v20;
        id v27 = v21;
        uint64_t v28 = 2;
        goto LABEL_20;
      }
    }
  }
  uint64_t v32 = [*(id *)(a1 + 32) driverWrapper];
  sub_10020EC8C(v32, @"LPEM feature change", 1uLL);
  id v21 = (id)objc_claimAutoreleasedReturnValue();

  if (v21)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v33 = NFLogGetLogger();
    if (v33)
    {
      uint64_t v34 = (void (*)(uint64_t, const char *, ...))v33;
      uint64_t v35 = object_getClass(*(id *)(a1 + 32));
      BOOL v36 = class_isMetaClass(v35);
      int v100 = object_getClassName(*(id *)(a1 + 32));
      int v102 = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v37 = 45;
      if (v36) {
        uint64_t v37 = 43;
      }
      v34(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v37, v100, v102, 121, v21);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v38 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
    {
      id v39 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v39)) {
        int v40 = 43;
      }
      else {
        int v40 = 45;
      }
      id v41 = object_getClassName(*(id *)(a1 + 32));
      id v42 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)long long buf = 67110146;
      int v109 = v40;
      __int16 v110 = 2082;
      __int16 v111 = v41;
      __int16 v112 = 2082;
      __int16 v113 = v42;
      __int16 v114 = 1024;
      int v115 = 121;
      __int16 v116 = 2112;
      *(void *)__int16 v117 = v21;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
    }

    uint64_t v43 = *(void *)(a1 + 40);
    id v44 = objc_alloc((Class)NSError);
    unsigned int v45 = +[NSString stringWithUTF8String:"nfcd"];
    id v46 = [v21 code];
    v123[0] = NSLocalizedDescriptionKey;
    if ((uint64_t)[v21 code] > 70) {
      uint64_t v47 = 71;
    }
    else {
      uint64_t v47 = (uint64_t)[v21 code];
    }
    id v54 = +[NSString stringWithUTF8String:off_1003064C0[v47]];
    v124[0] = v54;
    v124[1] = v21;
    v123[1] = NSUnderlyingErrorKey;
    v123[2] = @"Line";
    v124[2] = &off_10031D0B0;
    v123[3] = @"Method";
    id v55 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v124[3] = v55;
    v123[4] = NSDebugDescriptionErrorKey;
    id v56 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 122];
    v124[4] = v56;
    id v57 = v124;
    unsigned int v58 = v123;
    goto LABEL_41;
  }
  uint64_t v48 = [*(id *)(a1 + 32) controllerInfo];
  id v49 = [v48 siliconName];

  if (v49 == (id)18 || !*(unsigned char *)(a1 + 72))
  {
    BOOL v61 = 0;
  }
  else
  {
    id v50 = [*(id *)(a1 + 32) driverWrapper];
    id v105 = 0;
    char v51 = sub_1001AB844(v50, &v105);
    id v21 = v105;

    if (v21)
    {
      uint64_t v52 = [*(id *)(a1 + 32) driverWrapper];
      sub_1002114AC(v52, @"LPEM feature change");

      uint64_t v43 = *(void *)(a1 + 40);
      id v44 = objc_alloc((Class)NSError);
      unsigned int v45 = +[NSString stringWithUTF8String:"nfcd"];
      id v46 = [v21 code];
      v121[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[v21 code] > 70) {
        uint64_t v53 = 71;
      }
      else {
        uint64_t v53 = (uint64_t)[v21 code];
      }
      id v54 = +[NSString stringWithUTF8String:off_1003064C0[v53]];
      v122[0] = v54;
      v122[1] = v21;
      v121[1] = NSUnderlyingErrorKey;
      v121[2] = @"Line";
      v122[2] = &off_10031D0C8;
      v121[3] = @"Method";
      id v55 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
      v122[3] = v55;
      v121[4] = NSDebugDescriptionErrorKey;
      id v56 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 133];
      v122[4] = v56;
      id v57 = v122;
      unsigned int v58 = v121;
LABEL_41:
      uint64_t v59 = +[NSDictionary dictionaryWithObjects:v57 forKeys:v58 count:5];
      id v60 = [v44 initWithDomain:v45 code:v46 userInfo:v59];
      (*(void (**)(uint64_t, id))(v43 + 16))(v43, v60);

      goto LABEL_21;
    }
    BOOL v61 = (v51 & 1) == 0;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v62 = NFLogGetLogger();
  if (v62)
  {
    id v63 = (void (*)(uint64_t, const char *, ...))v62;
    uint64_t v64 = object_getClass(*(id *)(a1 + 32));
    BOOL v65 = class_isMetaClass(v64);
    id v66 = object_getClassName(*(id *)(a1 + 32));
    id v67 = sel_getName(*(SEL *)(a1 + 56));
    id v104 = [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) processIdentifier];
    uint64_t v68 = 45;
    if (v65) {
      uint64_t v68 = 43;
    }
    v63(6, "%c[%{public}s %{public}s]:%i PID %d enabling feature %d", v68, v66, v67, 142, v104, *(void *)(a1 + 64));
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v69 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v69, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v70 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v70)) {
      int v71 = 43;
    }
    else {
      int v71 = 45;
    }
    __int16 v72 = object_getClassName(*(id *)(a1 + 32));
    int v73 = sel_getName(*(SEL *)(a1 + 56));
    unsigned int v74 = [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) processIdentifier];
    uint64_t v75 = *(void *)(a1 + 64);
    *(_DWORD *)long long buf = 67110402;
    int v109 = v71;
    __int16 v110 = 2082;
    __int16 v111 = v72;
    __int16 v112 = 2082;
    __int16 v113 = v73;
    __int16 v114 = 1024;
    int v115 = 142;
    __int16 v116 = 1024;
    *(_DWORD *)__int16 v117 = v74;
    *(_WORD *)&v117[4] = 1024;
    *(_DWORD *)&v117[6] = v75;
    _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i PID %d enabling feature %d", buf, 0x2Eu);
  }

  int v76 = [*(id *)(a1 + 32) driverWrapper];
  char v77 = sub_1001AA4BC(v76, *(void *)(a1 + 64));

  uint64_t v78 = *(void *)(a1 + 40);
  if (v77)
  {
    (*(void (**)(void, void))(v78 + 16))(*(void *)(a1 + 40), 0);
    sub_10019B928(*(void **)(a1 + 32));
    if (v61)
    {
      __int16 v79 = [*(id *)(a1 + 32) driverWrapper];
      sub_100212274(v79);
    }
    id v80 = [*(id *)(a1 + 32) driverWrapper];
    uint64_t v81 = sub_1001AA1B4((uint64_t)v80);

    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v82 = NFLogGetLogger();
    if (v82)
    {
      id v83 = (void (*)(uint64_t, const char *, ...))v82;
      id v84 = object_getClass(*(id *)(a1 + 32));
      BOOL v85 = class_isMetaClass(v84);
      id v86 = object_getClassName(*(id *)(a1 + 32));
      __int16 v103 = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v87 = 45;
      if (v85) {
        uint64_t v87 = 43;
      }
      v83(6, "%c[%{public}s %{public}s]:%i posting %{public}@ to SESD - current state %lx", v87, v86, v103, 152, @"com.apple.stockholm.lpem.changed", v81);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v88 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v88, OS_LOG_TYPE_DEFAULT))
    {
      id v89 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v89)) {
        int v90 = 43;
      }
      else {
        int v90 = 45;
      }
      uint64_t v91 = object_getClassName(*(id *)(a1 + 32));
      id v92 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)long long buf = 67110402;
      int v109 = v90;
      __int16 v110 = 2082;
      __int16 v111 = v91;
      __int16 v112 = 2082;
      __int16 v113 = v92;
      __int16 v114 = 1024;
      int v115 = 152;
      __int16 v116 = 2114;
      *(void *)__int16 v117 = @"com.apple.stockholm.lpem.changed";
      *(_WORD *)&v117[8] = 2048;
      uint64_t v118 = v81;
      _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i posting %{public}@ to SESD - current state %lx", buf, 0x36u);
    }

    int v93 = [*(id *)(a1 + 32) sesdEventPublisher];
    v106[0] = @"Payload";
    v106[1] = @"lpemFeatures";
    v107[0] = @"com.apple.stockholm.lpem.changed";
    uint64_t v94 = +[NSNumber numberWithUnsignedInteger:v81];
    v107[1] = v94;
    id v95 = +[NSDictionary dictionaryWithObjects:v107 forKeys:v106 count:2];
    [v93 sendXpcNotificationEventWithDictionary:v95];
  }
  else
  {
    id v96 = objc_alloc((Class)NSError);
    int v93 = +[NSString stringWithUTF8String:"nfcd"];
    v119[0] = NSLocalizedDescriptionKey;
    uint64_t v94 = +[NSString stringWithUTF8String:"Stack Error"];
    v120[0] = v94;
    v120[1] = &off_10031D0E0;
    v119[1] = @"Line";
    v119[2] = @"Method";
    id v95 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v120[2] = v95;
    v119[3] = NSDebugDescriptionErrorKey;
    id v97 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 144];
    v120[3] = v97;
    uint64_t v98 = +[NSDictionary dictionaryWithObjects:v120 forKeys:v119 count:4];
    id v99 = [v96 initWithDomain:v93 code:15 userInfo:v98];
    (*(void (**)(uint64_t, id))(v78 + 16))(v78, v99);
  }
  id v21 = [*(id *)(a1 + 32) driverWrapper];
  sub_1002114AC(v21, @"LPEM feature change");
LABEL_21:
}

void sub_10019D8D4(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    v9[0] = 0;
    v9[1] = v9;
    void v9[2] = 0x3032000000;
    v9[3] = sub_10000B8D8;
    void v9[4] = sub_10019BB10;
    id v10 = +[NSXPCConnection currentConnection];
    char v4 = *(id *)(a1 + 232);
    v5[0] = _NSConcreteStackBlock;
    v5[1] = 3221225472;
    void v5[2] = sub_10019DA00;
    v5[3] = &unk_100306758;
    void v5[4] = a1;
    int v7 = v9;
    unsigned int v8 = "getLPEMFeaturesWithCompletion:";
    id v6 = v3;
    dispatch_async(v4, v5);

    _Block_object_dispose(v9, 8);
  }
}

void sub_10019DA00(uint64_t a1)
{
  if (-[_NFHardwareManager getPrimaryHardwareState]_0(*(void *)(a1 + 32)) != 2)
  {
    uint64_t v20 = *(void *)(a1 + 40);
    id v21 = objc_alloc((Class)NSError);
    int v18 = +[NSString stringWithUTF8String:"nfcd"];
    v44[0] = NSLocalizedDescriptionKey;
    id v22 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
    v45[0] = v22;
    v45[1] = &off_10031D0F8;
    v44[1] = @"Line";
    v44[2] = @"Method";
    id v23 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v45[2] = v23;
    v44[3] = NSDebugDescriptionErrorKey;
    id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 175];
    v45[3] = v24;
    id v25 = +[NSDictionary dictionaryWithObjects:v45 forKeys:v44 count:4];
    int v26 = v21;
    id v27 = v18;
    uint64_t v28 = 58;
LABEL_15:
    id v30 = [v26 initWithDomain:v27 code:v28 userInfo:v25];
    (*(void (**)(uint64_t, id, void))(v20 + 16))(v20, v30, 0);

    goto LABEL_16;
  }
  uint64_t v2 = [*(id *)(a1 + 32) controllerInfo];
  unsigned __int8 v3 = [v2 hasLPEMSupport];

  if ((v3 & 1) == 0)
  {
    uint64_t v20 = *(void *)(a1 + 40);
    id v29 = objc_alloc((Class)NSError);
    int v18 = +[NSString stringWithUTF8String:"nfcd"];
    v42[0] = NSLocalizedDescriptionKey;
    id v22 = +[NSString stringWithUTF8String:"Feature Not Supported"];
    v43[0] = v22;
    v43[1] = &off_10031D110;
    v42[1] = @"Line";
    v42[2] = @"Method";
    id v23 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
    v43[2] = v23;
    v42[3] = NSDebugDescriptionErrorKey;
    id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 180];
    v43[3] = v24;
    id v25 = +[NSDictionary dictionaryWithObjects:v43 forKeys:v42 count:4];
    int v26 = v29;
    id v27 = v18;
    uint64_t v28 = 14;
    goto LABEL_15;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    id v31 = [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) processIdentifier];
    uint64_t v10 = 45;
    if (isMetaClass) {
      uint64_t v10 = 43;
    }
    v5(6, "%c[%{public}s %{public}s]:%i PID %d getting LPEM features", v10, ClassName, Name, 184, v31);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v11 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12)) {
      int v13 = 43;
    }
    else {
      int v13 = 45;
    }
    char v14 = object_getClassName(*(id *)(a1 + 32));
    id v15 = sel_getName(*(SEL *)(a1 + 56));
    unsigned int v16 = [*(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40) processIdentifier];
    *(_DWORD *)long long buf = 67110146;
    int v33 = v13;
    __int16 v34 = 2082;
    uint64_t v35 = v14;
    __int16 v36 = 2082;
    uint64_t v37 = v15;
    __int16 v38 = 1024;
    int v39 = 184;
    __int16 v40 = 1024;
    unsigned int v41 = v16;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i PID %d getting LPEM features", buf, 0x28u);
  }

  uint64_t v17 = *(void *)(a1 + 40);
  int v18 = [*(id *)(a1 + 32) driverWrapper];
  uint64_t v19 = sub_1001AA1B4((uint64_t)v18);
  (*(void (**)(uint64_t, void, uint64_t))(v17 + 16))(v17, 0, v19);
LABEL_16:
}

void sub_10019DF44(uint64_t a1)
{
  id v1 = *(void **)(a1 + 32);
  uint64_t v2 = (void (**)(id, id))*(id *)(a1 + 40);
  if (!v1) {
    goto LABEL_20;
  }
  if (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v1) != 2)
  {
    id v19 = objc_alloc((Class)NSError);
    id v6 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v46 = NSLocalizedDescriptionKey;
    unsigned int v16 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
    *(void *)long long buf = v16;
    *(void *)uint64_t v52 = &off_10031D128;
    CFStringRef v47 = @"Line";
    CFStringRef v48 = @"Method";
    id v20 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_enableHeadlessTestMode:completion:")];
    *(void *)&v52[8] = v20;
    CFStringRef v49 = (const __CFString *)NSDebugDescriptionErrorKey;
    id v21 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_enableHeadlessTestMode:completion:"), 209];
    *(void *)&v52[16] = v21;
    id v22 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v46 count:4];
    id v23 = v19;
    id v24 = v6;
    uint64_t v25 = 58;
LABEL_18:
    id v27 = [v23 initWithDomain:v24 code:v25 userInfo:v22];
    v2[2](v2, v27);

LABEL_19:
    goto LABEL_20;
  }
  unsigned __int8 v3 = [v1 controllerInfo];
  unsigned __int8 v4 = [v3 hasLPEMSupport];

  if ((v4 & 1) == 0)
  {
    id v26 = objc_alloc((Class)NSError);
    id v6 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v46 = NSLocalizedDescriptionKey;
    unsigned int v16 = +[NSString stringWithUTF8String:"Feature Not Supported"];
    *(void *)long long buf = v16;
    *(void *)uint64_t v52 = &off_10031D140;
    CFStringRef v47 = @"Line";
    CFStringRef v48 = @"Method";
    id v20 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_enableHeadlessTestMode:completion:")];
    *(void *)&v52[8] = v20;
    CFStringRef v49 = (const __CFString *)NSDebugDescriptionErrorKey;
    id v21 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_enableHeadlessTestMode:completion:"), 214];
    *(void *)&v52[16] = v21;
    id v22 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v46 count:4];
    id v23 = v26;
    id v24 = v6;
    uint64_t v25 = 14;
    goto LABEL_18;
  }
  uint64_t v5 = [v1 driverWrapper];
  id v6 = sub_10020EC8C(v5, @"Headless Test Mode", 1uLL);

  if (v6)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      unsigned int v8 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(v1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(v1);
      Name = sel_getName("_sync_enableHeadlessTestMode:completion:");
      uint64_t v11 = 45;
      if (isMetaClass) {
        uint64_t v11 = 43;
      }
      v8(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v11, ClassName, Name, 220, v6);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v12 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      int v13 = object_getClass(v1);
      if (class_isMetaClass(v13)) {
        int v14 = 43;
      }
      else {
        int v14 = 45;
      }
      *(_DWORD *)long long buf = 67110146;
      *(_DWORD *)&uint8_t buf[4] = v14;
      *(_WORD *)uint64_t v52 = 2082;
      *(void *)&v52[2] = object_getClassName(v1);
      *(_WORD *)&unsigned char v52[10] = 2082;
      *(void *)&v52[12] = sel_getName("_sync_enableHeadlessTestMode:completion:");
      *(_WORD *)&v52[20] = 1024;
      *(_DWORD *)&v52[22] = 220;
      *(_WORD *)&v52[26] = 2112;
      *(void *)&v52[28] = v6;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
    }

    id v15 = objc_alloc((Class)NSError);
    unsigned int v16 = +[NSString stringWithUTF8String:"nfcd"];
    id v17 = [v6 code];
    NSErrorUserInfoKey v46 = NSLocalizedDescriptionKey;
    if ((uint64_t)[v6 code] > 70) {
      uint64_t v18 = 71;
    }
    else {
      uint64_t v18 = (uint64_t)[v6 code];
    }
    id v31 = +[NSString stringWithUTF8String:off_1003064C0[v18]];
    *(void *)long long buf = v31;
    *(void *)uint64_t v52 = v6;
    CFStringRef v47 = (const __CFString *)NSUnderlyingErrorKey;
    CFStringRef v48 = @"Line";
    *(void *)&v52[8] = &off_10031D158;
    CFStringRef v49 = @"Method";
    id v32 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_enableHeadlessTestMode:completion:")];
    *(void *)&v52[16] = v32;
    NSErrorUserInfoKey v50 = NSDebugDescriptionErrorKey;
    id v33 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_enableHeadlessTestMode:completion:"), 221];
    *(void *)&v52[24] = v33;
    __int16 v34 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v46 count:5];
    id v35 = [v15 initWithDomain:v16 code:v17 userInfo:v34];
    v2[2](v2, v35);

    goto LABEL_19;
  }
  uint64_t v28 = [v1 driverWrapper];
  char v29 = sub_1001ABB20(v28);

  if (v29)
  {
    id v30 = [v1 driverWrapper];
    sub_1002114AC(v30, @"Headless Test Mode");

    v2[2](v2, 0);
  }
  else
  {
    id v36 = objc_alloc((Class)NSError);
    uint64_t v37 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v46 = NSLocalizedDescriptionKey;
    __int16 v38 = +[NSString stringWithUTF8String:"Stack Error"];
    *(void *)long long buf = v38;
    *(void *)uint64_t v52 = &off_10031D170;
    CFStringRef v47 = @"Line";
    CFStringRef v48 = @"Method";
    id v39 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_enableHeadlessTestMode:completion:")];
    *(void *)&v52[8] = v39;
    CFStringRef v49 = (const __CFString *)NSDebugDescriptionErrorKey;
    id v40 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_enableHeadlessTestMode:completion:"), 227];
    *(void *)&v52[16] = v40;
    unsigned int v41 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v46 count:4];
    id v42 = [v36 initWithDomain:v37 code:15 userInfo:v41];
    v2[2](v2, v42);

    uint64_t v43 = [v1 driverWrapper];
    sub_1002114AC(v43, @"Headless Test Mode");
  }
LABEL_20:
}

void sub_10019E84C(uint64_t a1)
{
  int v1 = *(unsigned __int8 *)(a1 + 56);
  uint64_t v2 = *(void **)(a1 + 40);
  unsigned __int8 v3 = *(id **)(a1 + 32);
  id v4 = *(id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
  uint64_t v5 = v2;
  if (v3)
  {
    id v6 = [v4 NF_whitelistChecker];
    if (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v3) != 2)
    {
      id v23 = objc_alloc((Class)NSError);
      id v24 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v89 = NSLocalizedDescriptionKey;
      uint64_t v25 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
      *(void *)long long buf = v25;
      *(void *)id v95 = &off_10031D188;
      CFStringRef v90 = @"Line";
      CFStringRef v91 = @"Method";
      id v26 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:")];
      *(void *)&v95[8] = v26;
      CFStringRef v92 = (const __CFString *)NSDebugDescriptionErrorKey;
      id v27 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:"), 257];
      *(void *)&v95[16] = v27;
      uint64_t v28 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v89 count:4];
      id v29 = [v23 initWithDomain:v24 code:58 userInfo:v28];
      v5[2](v5, v29);

LABEL_34:
      goto LABEL_35;
    }
    __int16 v88 = v6;
    if (([v6 lpmFactoryTest] & 1) == 0)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        id v31 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(v3);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(v3);
        Name = sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:");
        id v36 = v5;
        id v37 = v4;
        id v38 = [v4 processIdentifier];
        id v39 = [v6 clientName];
        id v85 = v38;
        id v4 = v37;
        uint64_t v5 = v36;
        uint64_t v40 = 43;
        if (!isMetaClass) {
          uint64_t v40 = 45;
        }
        v31(3, "%c[%{public}s %{public}s]:%i PID %d (%{public}@) missing entitlement: %s", v40, ClassName, Name, 262, v85, v39, "com.apple.nfcd.lpm.factorytest");
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      unsigned int v41 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
      {
        id v42 = object_getClass(v3);
        if (class_isMetaClass(v42)) {
          int v43 = 43;
        }
        else {
          int v43 = 45;
        }
        id v44 = object_getClassName(v3);
        unsigned int v45 = sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:");
        unsigned int v46 = [v4 processIdentifier];
        CFStringRef v47 = [v88 clientName];
        *(_DWORD *)long long buf = 67110658;
        *(_DWORD *)&uint8_t buf[4] = v43;
        *(_WORD *)id v95 = 2082;
        *(void *)&v95[2] = v44;
        *(_WORD *)&v95[10] = 2082;
        *(void *)&v95[12] = v45;
        *(_WORD *)&v95[20] = 1024;
        *(_DWORD *)&v95[22] = 262;
        *(_WORD *)&v95[26] = 1024;
        *(_DWORD *)&v95[28] = v46;
        *(_WORD *)&v95[32] = 2114;
        *(void *)&v95[34] = v47;
        __int16 v96 = 2080;
        id v97 = "com.apple.nfcd.lpm.factorytest";
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i PID %d (%{public}@) missing entitlement: %s", buf, 0x3Cu);
      }
      id v48 = objc_alloc((Class)NSError);
      CFStringRef v49 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v89 = NSLocalizedDescriptionKey;
      NSErrorUserInfoKey v50 = +[NSString stringWithUTF8String:"Not entitled"];
      *(void *)long long buf = v50;
      *(void *)id v95 = &off_10031D1A0;
      CFStringRef v90 = @"Line";
      CFStringRef v91 = @"Method";
      id v51 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:")];
      *(void *)&v95[8] = v51;
      CFStringRef v92 = (const __CFString *)NSDebugDescriptionErrorKey;
      id v52 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:"), 263];
      *(void *)&v95[16] = v52;
      uint64_t v53 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v89 count:4];
      id v54 = v48;
      id v55 = v49;
      uint64_t v56 = 32;
      goto LABEL_31;
    }
    int v7 = [v3 controllerInfo];
    if ([v7 hasLPEMSupport])
    {
      unsigned int v8 = [v3 driverWrapper];
      char v9 = sub_1001AA204((uint64_t)v8, 1);

      if (v9)
      {
        uint64_t v10 = [v3 driverWrapper];
        uint64_t v11 = sub_10020EC8C(v10, @"Set Headless Factory", 1uLL);

        if (v11)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v12 = NFLogGetLogger();
          if (v12)
          {
            int v13 = (void (*)(uint64_t, const char *, ...))v12;
            int v14 = object_getClass(v3);
            BOOL v15 = class_isMetaClass(v14);
            id v83 = object_getClassName(v3);
            id v84 = sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:");
            uint64_t v16 = 45;
            if (v15) {
              uint64_t v16 = 43;
            }
            v13(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v16, v83, v84, 274, v11);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v17 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
          {
            uint64_t v18 = object_getClass(v3);
            if (class_isMetaClass(v18)) {
              int v19 = 43;
            }
            else {
              int v19 = 45;
            }
            *(_DWORD *)long long buf = 67110146;
            *(_DWORD *)&uint8_t buf[4] = v19;
            *(_WORD *)id v95 = 2082;
            *(void *)&v95[2] = object_getClassName(v3);
            *(_WORD *)&v95[10] = 2082;
            *(void *)&v95[12] = sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:");
            *(_WORD *)&v95[20] = 1024;
            *(_DWORD *)&v95[22] = 274;
            *(_WORD *)&v95[26] = 2112;
            *(void *)&v95[28] = v11;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
          }

          id v20 = objc_alloc((Class)NSError);
          id v21 = +[NSString stringWithUTF8String:"nfcd"];
          NSErrorUserInfoKey v89 = NSLocalizedDescriptionKey;
          id v86 = [v11 code];
          id v87 = v4;
          if ((uint64_t)[v11 code] > 70) {
            uint64_t v22 = 71;
          }
          else {
            uint64_t v22 = (uint64_t)[v11 code];
          }
          id v63 = +[NSString stringWithUTF8String:off_1003064C0[v22]];
          *(void *)long long buf = v63;
          *(void *)id v95 = v11;
          CFStringRef v90 = (const __CFString *)NSUnderlyingErrorKey;
          CFStringRef v91 = @"Line";
          *(void *)&v95[8] = &off_10031D1D0;
          CFStringRef v92 = @"Method";
          id v64 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:")];
          *(void *)&v95[16] = v64;
          NSErrorUserInfoKey v93 = NSDebugDescriptionErrorKey;
          id v65 = objc_alloc((Class)NSString);
          id v66 = sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:");
          uint64_t v67 = 275;
          goto LABEL_46;
        }
        uint64_t v59 = (unsigned __int8 *)v3[3];
        uint64_t v11 = sub_10004C164(v59, v1 != 0);

        id v60 = [v3 driverWrapper];
        BOOL v61 = v60;
        if (v11)
        {
          sub_1002114AC(v60, @"Set Headless Factory");

          id v20 = objc_alloc((Class)NSError);
          id v21 = +[NSString stringWithUTF8String:"nfcd"];
          NSErrorUserInfoKey v89 = NSLocalizedDescriptionKey;
          id v86 = [v11 code];
          id v87 = v4;
          if ((uint64_t)[v11 code] > 70) {
            uint64_t v62 = 71;
          }
          else {
            uint64_t v62 = (uint64_t)[v11 code];
          }
          id v63 = +[NSString stringWithUTF8String:off_1003064C0[v62]];
          *(void *)long long buf = v63;
          *(void *)id v95 = v11;
          CFStringRef v90 = (const __CFString *)NSUnderlyingErrorKey;
          CFStringRef v91 = @"Line";
          *(void *)&v95[8] = &off_10031D1E8;
          CFStringRef v92 = @"Method";
          id v64 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:")];
          *(void *)&v95[16] = v64;
          NSErrorUserInfoKey v93 = NSDebugDescriptionErrorKey;
          id v65 = objc_alloc((Class)NSString);
          id v66 = sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:");
          uint64_t v67 = 283;
LABEL_46:
          id v74 = [v65 initWithFormat:@"%s:%d", v66, v67];
          *(void *)&v95[24] = v74;
          uint64_t v75 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v89 count:5];
          id v76 = [v20 initWithDomain:v21 code:v86 userInfo:v75];
          v5[2](v5, v76);

          id v4 = v87;
          goto LABEL_33;
        }
        if (v1)
        {
          char v68 = sub_1001AA4BC(v60, 1);

          if ((v68 & 1) == 0)
          {
            id v69 = [v3 driverWrapper];
            sub_1002114AC(v69, @"Set Headless Factory");

            id v70 = objc_alloc((Class)NSError);
            CFStringRef v49 = +[NSString stringWithUTF8String:"nfcd"];
            NSErrorUserInfoKey v89 = NSLocalizedDescriptionKey;
            NSErrorUserInfoKey v50 = +[NSString stringWithUTF8String:"Stack Error"];
            *(void *)long long buf = v50;
            *(void *)id v95 = &off_10031D200;
            CFStringRef v90 = @"Line";
            CFStringRef v91 = @"Method";
            id v51 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:")];
            *(void *)&v95[8] = v51;
            CFStringRef v92 = (const __CFString *)NSDebugDescriptionErrorKey;
            id v71 = objc_alloc((Class)NSString);
            __int16 v72 = sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:");
            uint64_t v73 = 291;
LABEL_51:
            id v52 = [[v71 initWithFormat:@"%s:%d", v72, v73];
            *(void *)&v95[16] = v52;
            uint64_t v53 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v89 count:4];
            id v54 = v70;
            id v55 = v49;
            uint64_t v56 = 15;
            goto LABEL_31;
          }
        }
        else
        {
          char v77 = sub_1001AA914((uint64_t)v60, 31);

          if ((v77 & 1) == 0)
          {
            uint64_t v82 = [v3 driverWrapper];
            sub_1002114AC(v82, @"Set Headless Factory");

            id v70 = objc_alloc((Class)NSError);
            CFStringRef v49 = +[NSString stringWithUTF8String:"nfcd"];
            NSErrorUserInfoKey v89 = NSLocalizedDescriptionKey;
            NSErrorUserInfoKey v50 = +[NSString stringWithUTF8String:"Stack Error"];
            *(void *)long long buf = v50;
            *(void *)id v95 = &off_10031D218;
            CFStringRef v90 = @"Line";
            CFStringRef v91 = @"Method";
            id v51 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:")];
            *(void *)&v95[8] = v51;
            CFStringRef v92 = (const __CFString *)NSDebugDescriptionErrorKey;
            id v71 = objc_alloc((Class)NSString);
            __int16 v72 = sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:");
            uint64_t v73 = 299;
            goto LABEL_51;
          }
        }
        unsigned int v78 = sub_1000A49F8(v3);
        __int16 v79 = sub_1000A43A4(v3, v78);

        id v80 = [v3 driverWrapper];
        sub_1002114AC(v80, @"Set Headless Factory");

        if (!v79)
        {
          v5[2](v5, 0);
          goto LABEL_33;
        }
        id v81 = objc_alloc((Class)NSError);
        CFStringRef v49 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v89 = NSLocalizedDescriptionKey;
        NSErrorUserInfoKey v50 = +[NSString stringWithUTF8String:"Stack Error"];
        *(void *)long long buf = v50;
        *(void *)id v95 = &off_10031D230;
        CFStringRef v90 = @"Line";
        CFStringRef v91 = @"Method";
        id v51 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:")];
        *(void *)&v95[8] = v51;
        CFStringRef v92 = (const __CFString *)NSDebugDescriptionErrorKey;
        id v52 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:"), 307];
        *(void *)&v95[16] = v52;
        uint64_t v53 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v89 count:4];
        id v58 = [v81 initWithDomain:v49 code:15 userInfo:v53];
        v5[2](v5, v58);
        goto LABEL_32;
      }
    }
    else
    {
    }
    id v57 = objc_alloc((Class)NSError);
    CFStringRef v49 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v89 = NSLocalizedDescriptionKey;
    NSErrorUserInfoKey v50 = +[NSString stringWithUTF8String:"Feature Not Supported"];
    *(void *)long long buf = v50;
    *(void *)id v95 = &off_10031D1B8;
    CFStringRef v90 = @"Line";
    CFStringRef v91 = @"Method";
    id v51 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:")];
    *(void *)&v95[8] = v51;
    CFStringRef v92 = (const __CFString *)NSDebugDescriptionErrorKey;
    id v52 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_configureHeadlessFactoryMode:connection:completion:"), 268];
    *(void *)&v95[16] = v52;
    uint64_t v53 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v89 count:4];
    id v54 = v57;
    id v55 = v49;
    uint64_t v56 = 14;
LABEL_31:
    id v58 = [v54 initWithDomain:v55 code:v56 userInfo:v53];
    v5[2](v5, v58);
LABEL_32:

LABEL_33:
    id v6 = v88;
    goto LABEL_34;
  }
LABEL_35:
}

void sub_10019F854(void *a1)
{
  int v1 = (void *)a1[5];
  uint64_t v2 = (void *)a1[4];
  id v3 = *(id *)(*(void *)(a1[6] + 8) + 40);
  id v4 = v1;
  if (v2)
  {
    uint64_t v5 = [v3 NF_whitelistChecker];
    if (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v2) != 2)
    {
      id v21 = objc_alloc((Class)NSError);
      id v9 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v82 = NSLocalizedDescriptionKey;
      uint64_t v22 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
      *(void *)long long buf = v22;
      *(void *)__int16 v88 = &off_10031D248;
      CFStringRef v83 = @"Line";
      CFStringRef v84 = @"Method";
      id v23 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_headlessFactoryModeFromConnection:completion:")];
      *(void *)&v88[8] = v23;
      CFStringRef v85 = (const __CFString *)NSDebugDescriptionErrorKey;
      id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_headlessFactoryModeFromConnection:completion:"), 335];
      *(void *)&v88[16] = v24;
      uint64_t v25 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v82 count:4];
      id v26 = [v21 initWithDomain:v9 code:58 userInfo:v25];
      v4[2](v4, v26, 0);

LABEL_31:
      goto LABEL_32;
    }
    id v80 = v5;
    if ([v5 lpmFactoryTest])
    {
      id v6 = [v2 controllerInfo];
      unsigned __int8 v7 = [v6 hasLPEMSupport];

      if (v7)
      {
        unsigned int v8 = [v2 driverWrapper];
        sub_10020EC8C(v8, @"Get Headless Factory", 1uLL);
        id v9 = (id)objc_claimAutoreleasedReturnValue();

        if (v9)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t Logger = NFLogGetLogger();
          if (Logger)
          {
            uint64_t v11 = (void (*)(uint64_t, const char *, ...))Logger;
            Class = object_getClass(v2);
            BOOL isMetaClass = class_isMetaClass(Class);
            ClassName = object_getClassName(v2);
            Name = sel_getName("_sync_headlessFactoryModeFromConnection:completion:");
            uint64_t v14 = 45;
            if (isMetaClass) {
              uint64_t v14 = 43;
            }
            v11(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v14, ClassName, Name, 352, v9);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          BOOL v15 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            uint64_t v16 = object_getClass(v2);
            if (class_isMetaClass(v16)) {
              int v17 = 43;
            }
            else {
              int v17 = 45;
            }
            *(_DWORD *)long long buf = 67110146;
            *(_DWORD *)&uint8_t buf[4] = v17;
            *(_WORD *)__int16 v88 = 2082;
            *(void *)&v88[2] = object_getClassName(v2);
            *(_WORD *)&v88[10] = 2082;
            *(void *)&v88[12] = sel_getName("_sync_headlessFactoryModeFromConnection:completion:");
            *(_WORD *)&v88[20] = 1024;
            *(_DWORD *)&v88[22] = 352;
            *(_WORD *)&v88[26] = 2112;
            *(void *)&v88[28] = v9;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
          }

          id v18 = objc_alloc((Class)NSError);
          int v19 = +[NSString stringWithUTF8String:"nfcd"];
          NSErrorUserInfoKey v82 = NSLocalizedDescriptionKey;
          id v76 = [v9 code];
          id v78 = v3;
          if ((uint64_t)[v9 code] > 70) {
            uint64_t v20 = 71;
          }
          else {
            uint64_t v20 = (uint64_t)[v9 code];
          }
          uint64_t v62 = +[NSString stringWithUTF8String:off_1003064C0[v20]];
          *(void *)long long buf = v62;
          *(void *)__int16 v88 = v9;
          CFStringRef v83 = (const __CFString *)NSUnderlyingErrorKey;
          CFStringRef v84 = @"Line";
          *(void *)&v88[8] = &off_10031D290;
          CFStringRef v85 = @"Method";
          id v63 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_headlessFactoryModeFromConnection:completion:")];
          *(void *)&v88[16] = v63;
          NSErrorUserInfoKey v86 = NSDebugDescriptionErrorKey;
          id v64 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_headlessFactoryModeFromConnection:completion:"), 353];
          *(void *)&v88[24] = v64;
          id v65 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v82 count:5];
          id v66 = [v18 initWithDomain:v19 code:v76 userInfo:v65];
          v4[2](v4, v66, 0);

          id v3 = v78;
        }
        else
        {
          id v55 = [v2 driverWrapper];
          id v81 = 0;
          uint64_t v56 = sub_1001AB844(v55, &v81);
          id v57 = v81;

          if (v57)
          {
            unsigned int v77 = v56;
            id v58 = objc_alloc((Class)NSError);
            uint64_t v59 = +[NSString stringWithUTF8String:"nfcd"];
            id v60 = [v57 code];
            NSErrorUserInfoKey v82 = NSLocalizedDescriptionKey;
            id v79 = v3;
            id v75 = v60;
            if ((uint64_t)[v57 code] > 70) {
              uint64_t v61 = 71;
            }
            else {
              uint64_t v61 = (uint64_t)[v57 code];
            }
            uint64_t v67 = +[NSString stringWithUTF8String:off_1003064C0[v61]];
            *(void *)long long buf = v67;
            *(void *)__int16 v88 = v57;
            CFStringRef v83 = (const __CFString *)NSUnderlyingErrorKey;
            CFStringRef v84 = @"Line";
            *(void *)&v88[8] = &off_10031D2A8;
            CFStringRef v85 = @"Method";
            id v68 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_headlessFactoryModeFromConnection:completion:")];
            *(void *)&v88[16] = v68;
            NSErrorUserInfoKey v86 = NSDebugDescriptionErrorKey;
            id v69 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_headlessFactoryModeFromConnection:completion:"), 359];
            *(void *)&v88[24] = v69;
            id v70 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v82 count:5];
            id v9 = [v58 initWithDomain:v59 code:v75 userInfo:v70];

            id v3 = v79;
            uint64_t v56 = v77;
          }
          else
          {
            id v9 = 0;
          }
          id v71 = [v2 driverWrapper];
          sub_1002114AC(v71, @"Get Headless Factory");

          v4[2](v4, v9, v56);
        }
        goto LABEL_30;
      }
      id v53 = objc_alloc((Class)NSError);
      id v9 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v82 = NSLocalizedDescriptionKey;
      unsigned int v46 = +[NSString stringWithUTF8String:"Feature Not Supported"];
      *(void *)long long buf = v46;
      *(void *)__int16 v88 = &off_10031D278;
      CFStringRef v83 = @"Line";
      CFStringRef v84 = @"Method";
      id v47 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_headlessFactoryModeFromConnection:completion:")];
      *(void *)&v88[8] = v47;
      CFStringRef v85 = (const __CFString *)NSDebugDescriptionErrorKey;
      id v48 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_headlessFactoryModeFromConnection:completion:"), 346];
      *(void *)&v88[16] = v48;
      CFStringRef v49 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v82 count:4];
      NSErrorUserInfoKey v50 = v53;
      id v51 = v9;
      uint64_t v52 = 14;
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v27 = NFLogGetLogger();
      if (v27)
      {
        uint64_t v28 = (void (*)(uint64_t, const char *, ...))v27;
        id v29 = object_getClass(v2);
        BOOL v30 = class_isMetaClass(v29);
        id v31 = object_getClassName(v2);
        id v32 = sel_getName("_sync_headlessFactoryModeFromConnection:completion:");
        id v33 = v4;
        id v34 = v3;
        id v35 = [v3 processIdentifier];
        id v36 = [v5 clientName];
        id v74 = v35;
        id v3 = v34;
        id v4 = v33;
        uint64_t v37 = 43;
        if (!v30) {
          uint64_t v37 = 45;
        }
        v28(3, "%c[%{public}s %{public}s]:%i PID %d (%{public}@) missing entitlement: %s", v37, v31, v32, 340, v74, v36, "com.apple.nfcd.lpm.factorytest");
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v38 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
      {
        id v39 = object_getClass(v2);
        if (class_isMetaClass(v39)) {
          int v40 = 43;
        }
        else {
          int v40 = 45;
        }
        unsigned int v41 = object_getClassName(v2);
        id v42 = sel_getName("_sync_headlessFactoryModeFromConnection:completion:");
        unsigned int v43 = [v3 processIdentifier];
        id v44 = [v80 clientName];
        *(_DWORD *)long long buf = 67110658;
        *(_DWORD *)&uint8_t buf[4] = v40;
        *(_WORD *)__int16 v88 = 2082;
        *(void *)&v88[2] = v41;
        *(_WORD *)&v88[10] = 2082;
        *(void *)&v88[12] = v42;
        *(_WORD *)&v88[20] = 1024;
        *(_DWORD *)&v88[22] = 340;
        *(_WORD *)&v88[26] = 1024;
        *(_DWORD *)&v88[28] = v43;
        *(_WORD *)&v88[32] = 2114;
        *(void *)&v88[34] = v44;
        __int16 v89 = 2080;
        CFStringRef v90 = "com.apple.nfcd.lpm.factorytest";
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i PID %d (%{public}@) missing entitlement: %s", buf, 0x3Cu);
      }
      id v45 = objc_alloc((Class)NSError);
      id v9 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v82 = NSLocalizedDescriptionKey;
      unsigned int v46 = +[NSString stringWithUTF8String:"Not entitled"];
      *(void *)long long buf = v46;
      *(void *)__int16 v88 = &off_10031D260;
      CFStringRef v83 = @"Line";
      CFStringRef v84 = @"Method";
      id v47 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_headlessFactoryModeFromConnection:completion:")];
      *(void *)&v88[8] = v47;
      CFStringRef v85 = (const __CFString *)NSDebugDescriptionErrorKey;
      id v48 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_headlessFactoryModeFromConnection:completion:"), 341];
      *(void *)&v88[16] = v48;
      CFStringRef v49 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v82 count:4];
      NSErrorUserInfoKey v50 = v45;
      id v51 = v9;
      uint64_t v52 = 32;
    }
    id v54 = [v50 initWithDomain:v51 code:v52 userInfo:v49];
    v4[2](v4, v54, 0);

LABEL_30:
    uint64_t v5 = v80;
    goto LABEL_31;
  }
LABEL_32:
}

void sub_1001A04E4(void *a1)
{
  int v1 = (void *)a1[5];
  uint64_t v2 = (void *)a1[4];
  id v3 = *(id *)(*(void *)(a1[6] + 8) + 40);
  id v4 = v1;
  if (v2)
  {
    uint64_t v5 = [v3 NF_whitelistChecker];
    if (-[_NFHardwareManager getPrimaryHardwareState]_0((uint64_t)v2) != 2)
    {
      id v21 = objc_alloc((Class)NSError);
      id v9 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v78 = NSLocalizedDescriptionKey;
      uint64_t v22 = +[NSString stringWithUTF8String:"Unresponsive hardware"];
      *(void *)long long buf = v22;
      *(void *)CFStringRef v84 = &off_10031D2C0;
      CFStringRef v79 = @"Line";
      CFStringRef v80 = @"Method";
      id v23 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:")];
      *(void *)&v84[8] = v23;
      CFStringRef v81 = (const __CFString *)NSDebugDescriptionErrorKey;
      id v24 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:"), 386];
      *(void *)&v84[16] = v24;
      uint64_t v25 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v78 count:4];
      id v26 = [v21 initWithDomain:v9 code:58 userInfo:v25];
      v4[2](v4, v26);

LABEL_31:
      goto LABEL_32;
    }
    unsigned int v77 = v5;
    if ([v5 miniNVWriteAccess])
    {
      id v6 = [v2 controllerInfo];
      unsigned __int8 v7 = [v6 hasLPEMSupport];

      if (v7)
      {
        unsigned int v8 = [v2 driverWrapper];
        sub_10020EC8C(v8, @"Disable Headless", 1uLL);
        id v9 = (id)objc_claimAutoreleasedReturnValue();

        if (v9)
        {
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t Logger = NFLogGetLogger();
          if (Logger)
          {
            uint64_t v11 = (void (*)(uint64_t, const char *, ...))Logger;
            Class = object_getClass(v2);
            BOOL isMetaClass = class_isMetaClass(Class);
            ClassName = object_getClassName(v2);
            Name = sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:");
            uint64_t v14 = 45;
            if (isMetaClass) {
              uint64_t v14 = 43;
            }
            v11(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@error", v14, ClassName, Name, 403, v9);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          BOOL v15 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            uint64_t v16 = object_getClass(v2);
            if (class_isMetaClass(v16)) {
              int v17 = 43;
            }
            else {
              int v17 = 45;
            }
            *(_DWORD *)long long buf = 67110146;
            *(_DWORD *)&uint8_t buf[4] = v17;
            *(_WORD *)CFStringRef v84 = 2082;
            *(void *)&v84[2] = object_getClassName(v2);
            *(_WORD *)&v84[10] = 2082;
            *(void *)&v84[12] = sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:");
            *(_WORD *)&v84[20] = 1024;
            *(_DWORD *)&v84[22] = 403;
            *(_WORD *)&v84[26] = 2112;
            *(void *)&v84[28] = v9;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@error", buf, 0x2Cu);
          }

          id v18 = objc_alloc((Class)NSError);
          int v19 = +[NSString stringWithUTF8String:"nfcd"];
          NSErrorUserInfoKey v78 = NSLocalizedDescriptionKey;
          id v73 = [v9 code];
          id v75 = v3;
          if ((uint64_t)[v9 code] > 70) {
            uint64_t v20 = 71;
          }
          else {
            uint64_t v20 = (uint64_t)[v9 code];
          }
          id v60 = +[NSString stringWithUTF8String:off_1003064C0[v20]];
          *(void *)long long buf = v60;
          *(void *)CFStringRef v84 = v9;
          CFStringRef v79 = (const __CFString *)NSUnderlyingErrorKey;
          CFStringRef v80 = @"Line";
          *(void *)&v84[8] = &off_10031D308;
          CFStringRef v81 = @"Method";
          id v61 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:")];
          *(void *)&v84[16] = v61;
          NSErrorUserInfoKey v82 = NSDebugDescriptionErrorKey;
          id v62 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:"), 404];
          *(void *)&v84[24] = v62;
          id v63 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v78 count:5];
          id v64 = [v18 initWithDomain:v19 code:v73 userInfo:v63];
          v4[2](v4, v64);

          id v3 = v75;
        }
        else
        {
          id v55 = [v2 driverWrapper];
          uint64_t v56 = sub_1001AB184(v55);

          if (v56)
          {
            id v57 = objc_alloc((Class)NSError);
            id v58 = +[NSString stringWithUTF8String:"nfcd"];
            NSErrorUserInfoKey v78 = NSLocalizedDescriptionKey;
            id v74 = [v56 code];
            id v76 = v3;
            if ((uint64_t)[v56 code] > 70) {
              uint64_t v59 = 71;
            }
            else {
              uint64_t v59 = (uint64_t)[v56 code];
            }
            id v65 = +[NSString stringWithUTF8String:off_1003064C0[v59]];
            *(void *)long long buf = v65;
            *(void *)CFStringRef v84 = v56;
            CFStringRef v79 = (const __CFString *)NSUnderlyingErrorKey;
            CFStringRef v80 = @"Line";
            *(void *)&v84[8] = &off_10031D320;
            CFStringRef v81 = @"Method";
            id v66 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:")];
            *(void *)&v84[16] = v66;
            NSErrorUserInfoKey v82 = NSDebugDescriptionErrorKey;
            id v67 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:"), 410];
            *(void *)&v84[24] = v67;
            id v68 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v78 count:5];
            id v9 = [v57 initWithDomain:v58 code:v74 userInfo:v68];

            id v3 = v76;
          }
          else
          {
            id v9 = 0;
          }
          id v69 = [v2 driverWrapper];
          sub_1002114AC(v69, @"Disable Headless");

          v4[2](v4, v9);
        }
        goto LABEL_30;
      }
      id v53 = objc_alloc((Class)NSError);
      id v9 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v78 = NSLocalizedDescriptionKey;
      unsigned int v46 = +[NSString stringWithUTF8String:"Feature Not Supported"];
      *(void *)long long buf = v46;
      *(void *)CFStringRef v84 = &off_10031D2F0;
      CFStringRef v79 = @"Line";
      CFStringRef v80 = @"Method";
      id v47 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:")];
      *(void *)&v84[8] = v47;
      CFStringRef v81 = (const __CFString *)NSDebugDescriptionErrorKey;
      id v48 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:"), 397];
      *(void *)&v84[16] = v48;
      CFStringRef v49 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v78 count:4];
      NSErrorUserInfoKey v50 = v53;
      id v51 = v9;
      uint64_t v52 = 14;
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v27 = NFLogGetLogger();
      if (v27)
      {
        uint64_t v28 = (void (*)(uint64_t, const char *, ...))v27;
        id v29 = object_getClass(v2);
        BOOL v30 = class_isMetaClass(v29);
        id v31 = object_getClassName(v2);
        id v32 = sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:");
        id v33 = v4;
        id v34 = v3;
        id v35 = [v3 processIdentifier];
        id v36 = [v5 clientName];
        id v72 = v35;
        id v3 = v34;
        id v4 = v33;
        uint64_t v37 = 43;
        if (!v30) {
          uint64_t v37 = 45;
        }
        v28(3, "%c[%{public}s %{public}s]:%i PID %d (%{public}@) missing entitlement: %s", v37, v31, v32, 391, v72, v36, "com.apple.nfcd.mininv.write");
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v38 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
      {
        id v39 = object_getClass(v2);
        if (class_isMetaClass(v39)) {
          int v40 = 43;
        }
        else {
          int v40 = 45;
        }
        unsigned int v41 = object_getClassName(v2);
        id v42 = sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:");
        unsigned int v43 = [v3 processIdentifier];
        id v44 = [v77 clientName];
        *(_DWORD *)long long buf = 67110658;
        *(_DWORD *)&uint8_t buf[4] = v40;
        *(_WORD *)CFStringRef v84 = 2082;
        *(void *)&v84[2] = v41;
        *(_WORD *)&v84[10] = 2082;
        *(void *)&v84[12] = v42;
        *(_WORD *)&v84[20] = 1024;
        *(_DWORD *)&v84[22] = 391;
        *(_WORD *)&v84[26] = 1024;
        *(_DWORD *)&v84[28] = v43;
        *(_WORD *)&v84[32] = 2114;
        *(void *)&v84[34] = v44;
        __int16 v85 = 2080;
        NSErrorUserInfoKey v86 = "com.apple.nfcd.mininv.write";
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i PID %d (%{public}@) missing entitlement: %s", buf, 0x3Cu);
      }
      id v45 = objc_alloc((Class)NSError);
      id v9 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v78 = NSLocalizedDescriptionKey;
      unsigned int v46 = +[NSString stringWithUTF8String:"Not entitled"];
      *(void *)long long buf = v46;
      *(void *)CFStringRef v84 = &off_10031D2D8;
      CFStringRef v79 = @"Line";
      CFStringRef v80 = @"Method";
      id v47 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:")];
      *(void *)&v84[8] = v47;
      CFStringRef v81 = (const __CFString *)NSDebugDescriptionErrorKey;
      id v48 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("_sync_disableHeadlessMiniNVForConnection:completion:"), 392];
      *(void *)&v84[16] = v48;
      CFStringRef v49 = +[NSDictionary dictionaryWithObjects:buf forKeys:&v78 count:4];
      NSErrorUserInfoKey v50 = v45;
      id v51 = v9;
      uint64_t v52 = 32;
    }
    id v54 = [v50 initWithDomain:v51 code:v52 userInfo:v49];
    v4[2](v4, v54);

LABEL_30:
    uint64_t v5 = v77;
    goto LABEL_31;
  }
LABEL_32:
}

void sub_1001A102C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (a1)
  {
    id v4 = *(id *)(a1 + 232);
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1001A10E8;
    block[3] = &unk_100301D38;
    void block[4] = a1;
    id v6 = v3;
    unsigned __int8 v7 = "configureMiniNVWithCompletion:";
    dispatch_async(v4, block);
  }
}

void sub_1001A10E8(uint64_t a1)
{
  uint64_t v2 = [*(id *)(a1 + 32) controllerInfo];
  unsigned __int8 v3 = [v2 hasLPEMSupport];

  if ((v3 & 1) == 0)
  {
    uint64_t v17 = *(void *)(a1 + 40);
    id v18 = objc_alloc((Class)NSError);
    id v19 = +[NSString stringWithUTF8String:"nfcd"];
    v106[0] = NSLocalizedDescriptionKey;
    uint64_t v20 = +[NSString stringWithUTF8String:"Feature Not Supported"];
    v107[0] = v20;
    v107[1] = &off_10031D338;
    v106[1] = @"Line";
    void v106[2] = @"Method";
    id v21 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
    void v107[2] = v21;
    v106[3] = NSDebugDescriptionErrorKey;
    id v22 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 426];
    v107[3] = v22;
    id v23 = +[NSDictionary dictionaryWithObjects:v107 forKeys:v106 count:4];
    id v24 = [v18 initWithDomain:v19 code:14 userInfo:v23];
    (*(void (**)(uint64_t, id))(v17 + 16))(v17, v24);

LABEL_48:
    return;
  }
  id v4 = [*(id *)(a1 + 32) controllerInfo];
  id v5 = [v4 siliconName];

  if (v5 != (id)18)
  {
    uint64_t v25 = [*(id *)(a1 + 32) driverWrapper];
    sub_10020EC8C(v25, @"LPEM MiniNV config", 1uLL);
    id v19 = (id)objc_claimAutoreleasedReturnValue();

    if (v19)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        uint64_t v27 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(*(id *)(a1 + 32));
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(*(id *)(a1 + 32));
        Name = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v30 = 45;
        if (isMetaClass) {
          uint64_t v30 = 43;
        }
        v27(3, "%c[%{public}s %{public}s]:%i Failed to open session : %@", v30, ClassName, Name, 438, v19);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v31 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        id v32 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v32)) {
          int v33 = 43;
        }
        else {
          int v33 = 45;
        }
        id v34 = object_getClassName(*(id *)(a1 + 32));
        id v35 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)long long buf = 67110146;
        int v97 = v33;
        __int16 v98 = 2082;
        id v99 = v34;
        __int16 v100 = 2082;
        __int16 v101 = v35;
        __int16 v102 = 1024;
        int v103 = 438;
        __int16 v104 = 2112;
        id v105 = v19;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to open session : %@", buf, 0x2Cu);
      }

      uint64_t v36 = *(void *)(a1 + 40);
      id v37 = objc_alloc((Class)NSError);
      id v38 = +[NSString stringWithUTF8String:"nfcd"];
      id v39 = [v19 code];
      v94[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[v19 code] > 70) {
        uint64_t v40 = 71;
      }
      else {
        uint64_t v40 = (uint64_t)[v19 code];
      }
      id v45 = +[NSString stringWithUTF8String:off_1003064C0[v40]];
      v95[0] = v45;
      v95[1] = v19;
      v94[1] = NSUnderlyingErrorKey;
      void v94[2] = @"Line";
      v95[2] = &off_10031D350;
      void v94[3] = @"Method";
      id v46 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
      v95[3] = v46;
      void v94[4] = NSDebugDescriptionErrorKey;
      id v47 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 439];
      void v95[4] = v47;
      id v48 = v95;
      CFStringRef v49 = v94;
      goto LABEL_47;
    }
    unsigned int v41 = [*(id *)(a1 + 32) driverWrapper];
    id v87 = 0;
    char v42 = sub_1001AB844(v41, &v87);
    id v19 = v87;

    if (v19)
    {
      unsigned int v43 = [*(id *)(a1 + 32) driverWrapper];
      sub_1002114AC(v43, @"LPEM MiniNV config");

      uint64_t v36 = *(void *)(a1 + 40);
      id v37 = objc_alloc((Class)NSError);
      id v38 = +[NSString stringWithUTF8String:"nfcd"];
      id v39 = [v19 code];
      v92[0] = NSLocalizedDescriptionKey;
      if ((uint64_t)[v19 code] > 70) {
        uint64_t v44 = 71;
      }
      else {
        uint64_t v44 = (uint64_t)[v19 code];
      }
      id v45 = +[NSString stringWithUTF8String:off_1003064C0[v44]];
      v93[0] = v45;
      v93[1] = v19;
      v92[1] = NSUnderlyingErrorKey;
      v92[2] = @"Line";
      void v93[2] = &off_10031D368;
      v92[3] = @"Method";
      id v46 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
      void v93[3] = v46;
      void v92[4] = NSDebugDescriptionErrorKey;
      id v47 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 446];
      void v93[4] = v47;
      id v48 = v93;
      CFStringRef v49 = v92;
LABEL_47:
      id v68 = +[NSDictionary dictionaryWithObjects:v48 forKeys:v49 count:5];
      id v69 = [v37 initWithDomain:v38 code:v39 userInfo:v68];
      (*(void (**)(uint64_t, id))(v36 + 16))(v36, v69);

      goto LABEL_48;
    }
    if (v42) {
      goto LABEL_50;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v50 = NFLogGetLogger();
    if (v50)
    {
      id v51 = (void (*)(uint64_t, const char *, ...))v50;
      uint64_t v52 = object_getClass(*(id *)(a1 + 32));
      BOOL v53 = class_isMetaClass(v52);
      id v54 = object_getClassName(*(id *)(a1 + 32));
      __int16 v85 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v55 = 45;
      if (v53) {
        uint64_t v55 = 43;
      }
      v51(6, "%c[%{public}s %{public}s]:%i enabling MiniNV", v55, v54, v85, 451);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v56 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v56, OS_LOG_TYPE_DEFAULT))
    {
      id v57 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v57)) {
        int v58 = 43;
      }
      else {
        int v58 = 45;
      }
      uint64_t v59 = object_getClassName(*(id *)(a1 + 32));
      id v60 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)long long buf = 67109890;
      int v97 = v58;
      __int16 v98 = 2082;
      id v99 = v59;
      __int16 v100 = 2082;
      __int16 v101 = v60;
      __int16 v102 = 1024;
      int v103 = 451;
      _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i enabling MiniNV", buf, 0x22u);
    }

    id v61 = [*(id *)(a1 + 32) driverWrapper];
    sub_1001AB510(v61);
    id v19 = (id)objc_claimAutoreleasedReturnValue();

    if (v19)
    {
      uint64_t v62 = *(void *)(a1 + 40);
      id v63 = (void (**)(uint64_t, id))(v62 + 16);
      NSErrorUserInfoKey v64 = NSLocalizedDescriptionKey;
LABEL_43:
      id v86 = objc_alloc((Class)NSError);
      id v65 = +[NSString stringWithUTF8String:"nfcd"];
      id v66 = [v19 code];
      v88[0] = v64;
      if ((uint64_t)[v19 code] > 70) {
        uint64_t v67 = 71;
      }
      else {
        uint64_t v67 = (uint64_t)[v19 code];
      }
      id v72 = +[NSString stringWithUTF8String:off_1003064C0[v67]];
      v89[0] = v72;
      v89[1] = v19;
      v88[1] = NSUnderlyingErrorKey;
      v88[2] = @"Line";
      v89[2] = &off_10031D380;
      v88[3] = @"Method";
      id v73 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
      v89[3] = v73;
      void v88[4] = NSDebugDescriptionErrorKey;
      id v74 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 459];
      void v89[4] = v74;
      id v75 = +[NSDictionary dictionaryWithObjects:v89 forKeys:v88 count:5];
      id v76 = [v86 initWithDomain:v65 code:v66 userInfo:v75];
      (*v63)(v62, v76);

      goto LABEL_54;
    }
    id v70 = [*(id *)(a1 + 32) driverWrapper];
    int v71 = sub_100212274(v70);

    if (v71)
    {
LABEL_50:
      uint64_t v62 = *(void *)(a1 + 40);
    }
    else
    {
      id v78 = objc_alloc((Class)NSError);
      CFStringRef v79 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v64 = NSLocalizedDescriptionKey;
      NSErrorUserInfoKey v90 = NSLocalizedDescriptionKey;
      CFStringRef v80 = +[NSString stringWithUTF8String:"Stack Error"];
      CFStringRef v91 = v80;
      CFStringRef v81 = +[NSDictionary dictionaryWithObjects:&v91 forKeys:&v90 count:1];
      id v19 = [v78 initWithDomain:v79 code:15 userInfo:v81];

      uint64_t v62 = *(void *)(a1 + 40);
      id v63 = (void (**)(uint64_t, id))(v62 + 16);
      if (v19) {
        goto LABEL_43;
      }
    }
    (*(void (**)(uint64_t, void))(v62 + 16))(v62, 0);
    id v19 = 0;
LABEL_54:
    unsigned int v77 = [*(id *)(a1 + 32) driverWrapper];
    sub_1002114AC(v77, @"LPEM MiniNV config");

    goto LABEL_48;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v6 = NFLogGetLogger();
  if (v6)
  {
    unsigned __int8 v7 = (void (*)(uint64_t, const char *, ...))v6;
    unsigned int v8 = object_getClass(*(id *)(a1 + 32));
    BOOL v9 = class_isMetaClass(v8);
    uint64_t v10 = object_getClassName(*(id *)(a1 + 32));
    CFStringRef v83 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v11 = 45;
    if (v9) {
      uint64_t v11 = 43;
    }
    v7(6, "%c[%{public}s %{public}s]:%i No MiniNV config on this platform.", v11, v10, v83, 431);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v12 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v13)) {
      int v14 = 43;
    }
    else {
      int v14 = 45;
    }
    BOOL v15 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v16 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)long long buf = 67109890;
    int v97 = v14;
    __int16 v98 = 2082;
    id v99 = v15;
    __int16 v100 = 2082;
    __int16 v101 = v16;
    __int16 v102 = 1024;
    int v103 = 431;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i No MiniNV config on this platform.", buf, 0x22u);
  }

  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void *sub_1001A1CA0(void *a1, void *a2, void *a3)
{
  id v5 = a2;
  id v6 = a3;
  if (a1)
  {
    v10.receiver = a1;
    v10.super_class = (Class)NFTagAppProcessorDockKit;
    a1 = [super init];
    if (a1)
    {
      id v7 = [objc_alloc((Class)NFXPCEventPublisher) initWithStreamName:v5 queue:v6];
      unsigned int v8 = (void *)a1[1];
      a1[1] = v7;
    }
  }

  return a1;
}

void sub_1001A2818(uint64_t a1)
{
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    int v16 = NFIsInternalBuild();
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    id v18 = (void (*)(uint64_t, const char *, ...))Logger;
    if (v16)
    {
      if (Logger)
      {
        Class = object_getClass(*(id *)(a1 + 32));
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(*(id *)(a1 + 32));
        Name = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v23 = 45;
        if (isMetaClass) {
          uint64_t v23 = 43;
        }
        v18(10, "%c[%{public}s %{public}s]:%i %@", v23, ClassName, Name, 88, *(void *)(a1 + 40));
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v24 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_34;
      }
      uint64_t v25 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v25)) {
        int v26 = 43;
      }
      else {
        int v26 = 45;
      }
      uint64_t v27 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v28 = sel_getName(*(SEL *)(a1 + 48));
      id v29 = *(void **)(a1 + 40);
      *(_DWORD *)long long buf = 67110146;
      int v45 = v26;
      __int16 v46 = 2082;
      id v47 = v27;
      __int16 v48 = 2082;
      CFStringRef v49 = v28;
      __int16 v50 = 1024;
      int v51 = 88;
      __int16 v52 = 2112;
      BOOL v53 = v29;
      uint64_t v30 = "%c[%{public}s %{public}s]:%i %@";
      id v31 = v24;
      uint32_t v32 = 44;
    }
    else
    {
      if (Logger)
      {
        int v33 = object_getClass(*(id *)(a1 + 32));
        BOOL v34 = class_isMetaClass(v33);
        id v35 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v36 = sel_getName(*(SEL *)(a1 + 48));
        id v43 = [*(id *)(a1 + 40) count];
        uint64_t v37 = 45;
        if (v34) {
          uint64_t v37 = 43;
        }
        v18(6, "%c[%{public}s %{public}s]:%i Setting %d host cards", v37, v35, v36, 91, v43);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v24 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_34;
      }
      id v38 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v38)) {
        int v39 = 43;
      }
      else {
        int v39 = 45;
      }
      uint64_t v40 = object_getClassName(*(id *)(a1 + 32));
      unsigned int v41 = sel_getName(*(SEL *)(a1 + 48));
      unsigned int v42 = [*(id *)(a1 + 40) count];
      *(_DWORD *)long long buf = 67110146;
      int v45 = v39;
      __int16 v46 = 2082;
      id v47 = v40;
      __int16 v48 = 2082;
      CFStringRef v49 = v41;
      __int16 v50 = 1024;
      int v51 = 91;
      __int16 v52 = 1024;
      LODWORD(v53) = v42;
      uint64_t v30 = "%c[%{public}s %{public}s]:%i Setting %d host cards";
      id v31 = v24;
      uint32_t v32 = 40;
    }
    _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, v30, buf, v32);
LABEL_34:

    [*(id *)(*(void *)(a1 + 32) + 371) setHostCards:*(void *)(a1 + 40)];
    return;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v2 = NFLogGetLogger();
  if (v2)
  {
    unsigned __int8 v3 = (void (*)(uint64_t, const char *, ...))v2;
    id v4 = object_getClass(*(id *)(a1 + 32));
    BOOL v5 = class_isMetaClass(v4);
    id v6 = object_getClassName(*(id *)(a1 + 32));
    id v7 = sel_getName(*(SEL *)(a1 + 48));
    unsigned int v8 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v9 = 45;
    if (v5) {
      uint64_t v9 = 43;
    }
    v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, v6, v7, 85, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  objc_super v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    uint64_t v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    int v13 = object_getClassName(*(id *)(a1 + 32));
    int v14 = sel_getName(*(SEL *)(a1 + 48));
    BOOL v15 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v45 = v12;
    __int16 v46 = 2082;
    id v47 = v13;
    __int16 v48 = 2082;
    CFStringRef v49 = v14;
    __int16 v50 = 1024;
    int v51 = 85;
    __int16 v52 = 2114;
    BOOL v53 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
}

void sub_1001A3578(void *a1, void *a2)
{
  if (a1)
  {
    unsigned __int8 v3 = a1;
    id v4 = a2;
    objc_sync_enter(v3);
    objc_storeWeak(v3 + 1, v4);

    objc_sync_exit(v3);
    sub_1001A37A0(v3);
    if (!*((unsigned char *)v3 + 17))
    {
      CFRunLoopGetMain();
      unsigned int v5 = TelephonyBasebandRegisterForReset();
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        id v7 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(v3);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(v3);
        Name = sel_getName("setDelegate:");
        uint64_t v10 = 45;
        if (isMetaClass) {
          uint64_t v10 = 43;
        }
        v7(6, "%c[%{public}s %{public}s]:%i didRegister = %d", v10, ClassName, Name, 60, v5);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v11 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        int v12 = object_getClass(v3);
        if (class_isMetaClass(v12)) {
          int v13 = 43;
        }
        else {
          int v13 = 45;
        }
        *(_DWORD *)long long buf = 67110146;
        int v18 = v13;
        __int16 v19 = 2082;
        uint64_t v20 = object_getClassName(v3);
        __int16 v21 = 2082;
        id v22 = sel_getName("setDelegate:");
        __int16 v23 = 1024;
        int v24 = 60;
        __int16 v25 = 1024;
        unsigned int v26 = v5;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i didRegister = %d", buf, 0x28u);
      }

      *((unsigned char *)v3 + 17) = v5;
    }
    BOOL v14 = sub_1001A3BF4(v3);
    sub_1001A3C44(v3, v14);
  }
}

void sub_1001A37A0(void *a1)
{
  TelephonyBasebandGetReset();
  uint64_t v2 = a1;
  objc_sync_enter(v2);
  v2[16] = 1;
  objc_sync_exit(v2);
}

void sub_1001A37FC(void *a1, uint64_t a2, int a3)
{
  switch(a3)
  {
    case -469794816:
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (Logger) {
        Logger(6, "%s:%i baseband reset", "BBNotificationCallback", 132);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      unsigned int v5 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_25;
      }
      *(_DWORD *)long long buf = 136446466;
      int v16 = "BBNotificationCallback";
      __int16 v17 = 1024;
      int v18 = 132;
      id v6 = "%{public}s:%i baseband reset";
      goto LABEL_24;
    case -469794815:
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v7 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v7) {
        v7(6, "%s:%i baseband alive", "BBNotificationCallback", 136);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      unsigned int v5 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_25;
      }
      *(_DWORD *)long long buf = 136446466;
      int v16 = "BBNotificationCallback";
      __int16 v17 = 1024;
      int v18 = 136;
      id v6 = "%{public}s:%i baseband alive";
      goto LABEL_24;
    case -469794813:
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      unsigned int v8 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v8) {
        v8(6, "%s:%i Baseband power on", "BBNotificationCallback", 140);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v9 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_19;
      }
      *(_DWORD *)long long buf = 136446466;
      int v16 = "BBNotificationCallback";
      __int16 v17 = 1024;
      int v18 = 140;
      uint64_t v10 = "%{public}s:%i Baseband power on";
      goto LABEL_18;
    case -469794812:
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v11 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v11) {
        v11(6, "%s:%i baseband down", "BBNotificationCallback", 143);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v9 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_19;
      }
      *(_DWORD *)long long buf = 136446466;
      int v16 = "BBNotificationCallback";
      __int16 v17 = 1024;
      int v18 = 143;
      uint64_t v10 = "%{public}s:%i baseband down";
LABEL_18:
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v10, buf, 0x12u);
LABEL_19:

      break;
    case -469794811:
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v12 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v12) {
        v12(6, "%s:%i baseband up", "BBNotificationCallback", 146);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      unsigned int v5 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_25;
      }
      *(_DWORD *)long long buf = 136446466;
      int v16 = "BBNotificationCallback";
      __int16 v17 = 1024;
      int v18 = 146;
      id v6 = "%{public}s:%i baseband up";
LABEL_24:
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, v6, buf, 0x12u);
LABEL_25:

      if (a1)
      {
        BOOL v13 = sub_1001A3BF4(a1);
        sub_1001A37A0(a1);
        BOOL v14 = sub_1001A3BF4(a1);
        if (v13 != v14) {
          sub_1001A3C44(a1, v14);
        }
      }
      break;
    default:
      return;
  }
}

BOOL sub_1001A3BF4(void *a1)
{
  if (!a1) {
    return 0;
  }
  int v1 = a1;
  objc_sync_enter(v1);
  BOOL v2 = v1[16] != 0;
  objc_sync_exit(v1);

  return v2;
}

void sub_1001A3C44(void *a1, uint64_t a2)
{
  id obj = a1;
  objc_sync_enter(obj);
  id WeakRetained = objc_loadWeakRetained(obj + 1);
  [WeakRetained basebandStateChanged:a2];

  objc_sync_exit(obj);
}

void sub_1001A3CB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_1001A409C(_Unwind_Exception *a1)
{
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 128));
  _Unwind_Resume(a1);
}

void sub_1001A40C4(uint64_t a1, void *a2, char a3)
{
  id v5 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v7 = WeakRetained;
  if (WeakRetained)
  {
    unsigned int v8 = [WeakRetained workQueue];
    block[0] = _NSConcreteStackBlock;
    block[1] = 3221225472;
    block[2] = sub_1001A41A8;
    block[3] = &unk_100304830;
    uint64_t v9 = *(void *)(a1 + 48);
    void block[4] = v7;
    uint64_t v15 = v9;
    id v10 = v5;
    char v16 = a3;
    uint64_t v11 = *(void *)(a1 + 32);
    id v13 = v10;
    uint64_t v14 = v11;
    dispatch_async(v8, block);
  }
}

id sub_1001A41A8(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    unsigned __int8 v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    id v8 = [*(id *)(a1 + 40) debugDescription];
    id v23 = [v8 UTF8String];
    uint64_t v9 = 45;
    if (isMetaClass) {
      uint64_t v9 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i UI is dismissed, error = %s", v9, ClassName, Name, 91, v23);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    id v13 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v14 = sel_getName(*(SEL *)(a1 + 56));
    id v15 = [*(id *)(a1 + 40) debugDescription];
    *(_DWORD *)long long buf = 67110146;
    int v28 = v12;
    __int16 v29 = 2082;
    uint64_t v30 = v13;
    __int16 v31 = 2082;
    uint32_t v32 = v14;
    __int16 v33 = 1024;
    int v34 = 91;
    __int16 v35 = 2080;
    id v36 = [v15 UTF8String];
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i UI is dismissed, error = %s", buf, 0x2Cu);
  }
  if (*(unsigned char *)(a1 + 64))
  {
    id v16 = objc_alloc((Class)NSError);
    __int16 v17 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v25 = NSLocalizedDescriptionKey;
    int v18 = +[NSString stringWithUTF8String:"User cancelled"];
    unsigned int v26 = v18;
    __int16 v19 = +[NSDictionary dictionaryWithObjects:&v26 forKeys:&v25 count:1];
    id v20 = [v16 initWithDomain:v17 code:48 userInfo:v19];

    if (v20)
    {
      __int16 v21 = [*(id *)(a1 + 32) remoteObject];
      [v21 didTerminate:v20];
    }
  }
  v24.receiver = *(id *)(a1 + 48);
  v24.super_class = (Class)_NFCardSession;
  return [super stopEmulationWithCompletion:0];
}

void sub_1001A4468(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = [*(id *)(a1 + 32) workQueue];
  v7[0] = _NSConcreteStackBlock;
  v7[1] = 3221225472;
  v7[2] = sub_1001A452C;
  v7[3] = &unk_1003045D8;
  id v5 = *(id *)(a1 + 40);
  id v8 = v3;
  id v9 = v5;
  id v6 = v3;
  dispatch_async(v4, v7);
}

uint64_t sub_1001A452C(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

void sub_1001A4AE4(uint64_t a1)
{
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      id v8 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 151, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      uint64_t v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      id v13 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v14 = sel_getName(*(SEL *)(a1 + 56));
      id v15 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)long long buf = 67110146;
      int v31 = v12;
      __int16 v32 = 2082;
      __int16 v33 = v13;
      __int16 v34 = 2082;
      __int16 v35 = v14;
      __int16 v36 = 1024;
      int v37 = 151;
      __int16 v38 = 2114;
      int v39 = v15;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v16 = *(void *)(a1 + 48);
    id v17 = objc_alloc((Class)NSError);
    int v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v28 = NSLocalizedDescriptionKey;
    __int16 v19 = +[NSString stringWithUTF8String:"Session not active"];
    __int16 v29 = v19;
    id v20 = +[NSDictionary dictionaryWithObjects:&v29 forKeys:&v28 count:1];
    id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
    (*(void (**)(uint64_t, id))(v16 + 16))(v16, v21);
  }
  else
  {
    if ([*(id *)(a1 + 32) cardState] == (id)2)
    {
      id v22 = +[NFResponseAPDU responseWithData:*(void *)(a1 + 40)];
      if (!v22) {
        [*(id *)(a1 + 32) setCardState:1];
      }
      if ([v22 status] == 36864) {
        uint64_t v23 = 3;
      }
      else {
        uint64_t v23 = 1;
      }
      [*(id *)(a1 + 32) setCardState:v23];
    }
    objc_super v24 = *(void **)(a1 + 32);
    uint64_t v25 = *(void *)(a1 + 40);
    v26[0] = _NSConcreteStackBlock;
    v26[1] = 3221225472;
    v26[2] = sub_1001A4E58;
    v26[3] = &unk_1003067F8;
    void v26[4] = v24;
    id v27 = *(id *)(a1 + 48);
    [v24 sendAPDU:v25 startReadOnCompletion:1 completion:v26];
  }
}

void sub_1001A4E58(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3) {
    [*(id *)(a1 + 32) setCardState:1];
  }
  (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
}

void sub_1001A4FD0(uint64_t a1)
{
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      id v8 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 180, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      uint64_t v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      id v13 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
      id v15 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)long long buf = 67110146;
      int v30 = v12;
      __int16 v31 = 2082;
      __int16 v32 = v13;
      __int16 v33 = 2082;
      __int16 v34 = v14;
      __int16 v35 = 1024;
      int v36 = 180;
      __int16 v37 = 2114;
      __int16 v38 = v15;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v16 = *(void *)(a1 + 40);
    id v17 = objc_alloc((Class)NSError);
    int v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v27 = NSLocalizedDescriptionKey;
    __int16 v19 = +[NSString stringWithUTF8String:"Session not active"];
    NSErrorUserInfoKey v28 = v19;
    id v20 = +[NSDictionary dictionaryWithObjects:&v28 forKeys:&v27 count:1];
    id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
    (*(void (**)(uint64_t, id))(v16 + 16))(v16, v21);
  }
  else
  {
    id v22 = *(void **)(a1 + 32);
    v25[0] = _NSConcreteStackBlock;
    v25[1] = 3221225472;
    v25[2] = sub_1001A52EC;
    v25[3] = &unk_100302228;
    void v25[4] = v22;
    long long v24 = *(_OWORD *)(a1 + 40);
    id v23 = (id)v24;
    long long v26 = v24;
    [v22 _activateUIControllerWithCompletion:v25];
  }
}

void sub_1001A52EC(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v8 = 45;
      if (isMetaClass) {
        uint64_t v8 = 43;
      }
      v5(5, "%c[%{public}s %{public}s]:%i %{public}@", v8, ClassName, Name, 184, v3);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      id v10 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      int v12 = object_getClassName(*(id *)(a1 + 32));
      id v13 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)long long buf = 67110146;
      int v29 = v11;
      __int16 v30 = 2082;
      __int16 v31 = v12;
      __int16 v32 = 2082;
      __int16 v33 = v13;
      __int16 v34 = 1024;
      int v35 = 184;
      __int16 v36 = 2114;
      id v37 = v3;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
    }

    [*(id *)(*(void *)(a1 + 32) + 224) coreNFCUIInvalidate];
    uint64_t v14 = *(void *)(a1 + 40);
    id v15 = objc_alloc((Class)NSError);
    uint64_t v16 = +[NSString stringWithUTF8String:"nfcd"];
    v26[0] = NSLocalizedDescriptionKey;
    id v17 = +[NSString stringWithUTF8String:"Invalid State"];
    v27[0] = v17;
    v27[1] = &off_10031D3B0;
    v26[1] = @"Line";
    v26[2] = @"Method";
    id v18 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
    v27[2] = v18;
    v26[3] = NSDebugDescriptionErrorKey;
    id v19 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 186];
    v27[3] = v19;
    id v20 = +[NSDictionary dictionaryWithObjects:v27 forKeys:v26 count:4];
    id v21 = [v15 initWithDomain:v16 code:12 userInfo:v20];
    (*(void (**)(uint64_t, id))(v14 + 16))(v14, v21);
  }
  else
  {
    [*(id *)(a1 + 32) setCardState:1];
    uint64_t v22 = *(void *)(a1 + 40);
    v25.receiver = *(id *)(a1 + 32);
    v25.super_class = (Class)_NFCardSession;
    [super _syncStartEmulationWithCompletion:v22];
  }
}

uint64_t sub_1001A5790(uint64_t a1)
{
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) == 0)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v17 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 40));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 40));
      Name = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v21 = 45;
      if (isMetaClass) {
        uint64_t v21 = 43;
      }
      v17(4, "%c[%{public}s %{public}s]:%i Invalid string; dropping request", v21, ClassName, Name, 207);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      uint64_t v22 = object_getClass(*(id *)(a1 + 40));
      if (class_isMetaClass(v22)) {
        int v23 = 43;
      }
      else {
        int v23 = 45;
      }
      long long v24 = object_getClassName(*(id *)(a1 + 40));
      objc_super v25 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)long long buf = 67109890;
      int v42 = v23;
      __int16 v43 = 2082;
      uint64_t v44 = v24;
      __int16 v45 = 2082;
      __int16 v46 = v25;
      __int16 v47 = 1024;
      int v48 = 207;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid string; dropping request",
        buf,
        0x22u);
    }
    goto LABEL_23;
  }
  if (![*(id *)(a1 + 40) didStart]
    || ([*(id *)(a1 + 40) isSuspended] & 1) != 0
    || [*(id *)(a1 + 40) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v2 = NFLogGetLogger();
    if (v2)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))v2;
      id v4 = object_getClass(*(id *)(a1 + 40));
      BOOL v5 = class_isMetaClass(v4);
      id v6 = object_getClassName(*(id *)(a1 + 40));
      id v7 = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v8 = [*(id *)(a1 + 40) sessionUID];
      uint64_t v9 = 45;
      if (v5) {
        uint64_t v9 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, v6, v7, 212, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      int v11 = object_getClass(*(id *)(a1 + 40));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      id v13 = object_getClassName(*(id *)(a1 + 40));
      uint64_t v14 = sel_getName(*(SEL *)(a1 + 56));
      id v15 = [*(id *)(a1 + 40) sessionUID];
      *(_DWORD *)long long buf = 67110146;
      int v42 = v12;
      __int16 v43 = 2082;
      uint64_t v44 = v13;
      __int16 v45 = 2082;
      __int16 v46 = v14;
      __int16 v47 = 1024;
      int v48 = 212;
      __int16 v49 = 2114;
      __int16 v50 = v15;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
LABEL_23:

    return (*(uint64_t (**)(void))(*(void *)(a1 + 48) + 16))();
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v27 = NFLogGetLogger();
  if (v27)
  {
    NSErrorUserInfoKey v28 = (void (*)(uint64_t, const char *, ...))v27;
    int v29 = object_getClass(*(id *)(a1 + 40));
    BOOL v30 = class_isMetaClass(v29);
    __int16 v31 = object_getClassName(*(id *)(a1 + 40));
    __int16 v32 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v33 = 45;
    if (v30) {
      uint64_t v33 = 43;
    }
    v28(5, "%c[%{public}s %{public}s]:%i String updated=%{public}@", v33, v31, v32, 214, *(void *)(a1 + 32));
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  __int16 v34 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
  {
    int v35 = object_getClass(*(id *)(a1 + 40));
    if (class_isMetaClass(v35)) {
      int v36 = 43;
    }
    else {
      int v36 = 45;
    }
    id v37 = object_getClassName(*(id *)(a1 + 40));
    __int16 v38 = sel_getName(*(SEL *)(a1 + 56));
    int v39 = *(void **)(a1 + 32);
    *(_DWORD *)long long buf = 67110146;
    int v42 = v36;
    __int16 v43 = 2082;
    uint64_t v44 = v37;
    __int16 v45 = 2082;
    __int16 v46 = v38;
    __int16 v47 = 1024;
    int v48 = 214;
    __int16 v49 = 2114;
    __int16 v50 = v39;
    _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i String updated=%{public}@", buf, 0x2Cu);
  }

  [*(id *)(*(void *)(a1 + 40) + 224) coreNFCUISetScanText:*(void *)(a1 + 32)];
  return (*(uint64_t (**)(void))(*(void *)(a1 + 48) + 16))();
}

void sub_1001A7CF4(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      BOOL v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v8 = 45;
      if (isMetaClass) {
        uint64_t v8 = 43;
      }
      v5(5, "%c[%{public}s %{public}s]:%i %{public}@", v8, ClassName, Name, 394, v3);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      id v10 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      int v12 = object_getClassName(*(id *)(a1 + 32));
      id v13 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)long long buf = 67110146;
      int v17 = v11;
      __int16 v18 = 2082;
      id v19 = v12;
      __int16 v20 = 2082;
      uint64_t v21 = v13;
      __int16 v22 = 1024;
      int v23 = 394;
      __int16 v24 = 2114;
      id v25 = v3;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
    }

    [*(id *)(*(void *)(a1 + 32) + 224) coreNFCUIInvalidate];
  }
  else
  {
    [*(id *)(a1 + 32) setCardState:1];
  }
}

void sub_1001A7F6C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      BOOL v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v8 = 45;
      if (isMetaClass) {
        uint64_t v8 = 43;
      }
      v5(5, "%c[%{public}s %{public}s]:%i %{public}@", v8, ClassName, Name, 411, v3);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      id v10 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      int v12 = object_getClassName(*(id *)(a1 + 32));
      id v13 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)long long buf = 67110146;
      int v17 = v11;
      __int16 v18 = 2082;
      id v19 = v12;
      __int16 v20 = 2082;
      uint64_t v21 = v13;
      __int16 v22 = 1024;
      int v23 = 411;
      __int16 v24 = 2114;
      id v25 = v3;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
    }

    [*(id *)(*(void *)(a1 + 32) + 224) coreNFCUIInvalidate];
  }
  else
  {
    [*(id *)(a1 + 32) setCardState:1];
  }
}

void sub_1001A8350(uint64_t a1)
{
}

void sub_1001A8358(uint64_t a1, uint64_t a2)
{
  if (sub_1001A8F04())
  {
    uint64_t v89 = 0;
    NSErrorUserInfoKey v90 = &v89;
    uint64_t v91 = 0x2050000000;
    id v4 = (void *)qword_100347550;
    uint64_t v92 = qword_100347550;
    if (!qword_100347550)
    {
      *(void *)long long buf = _NSConcreteStackBlock;
      *(void *)&uint8_t buf[8] = 3221225472;
      *(void *)&uint8_t buf[16] = sub_1001A9048;
      *(void *)&buf[24] = &unk_100301E40;
      *(void *)&buf[32] = &v89;
      sub_1001A9048(buf);
      id v4 = (void *)v90[3];
    }
    BOOL v5 = v4;
    _Block_object_dispose(&v89, 8);
    id v6 = [v5 alloc];
    id v7 = (_OWORD *)(a1 + 64);
    if (a2)
    {
      id v87 = 0;
      long long v8 = *(_OWORD *)(a1 + 80);
      *(_OWORD *)long long buf = *v7;
      *(_OWORD *)&uint8_t buf[16] = v8;
      id v9 = [v6 initWithDomain:13 auditToken:buf error:&v87];
      id v10 = v87;
      int v11 = v10;
      if (!v9 || v10)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (Logger)
        {
          Class = object_getClass(*(id *)(a1 + 48));
          if (class_isMetaClass(Class)) {
            uint64_t v14 = 43;
          }
          else {
            uint64_t v14 = 45;
          }
          ClassName = object_getClassName(*(id *)(a1 + 48));
          Name = sel_getName(*(SEL *)(a1 + 56));
          Logger(3, "%c[%{public}s %{public}s]:%i error=%{public}@", v14, ClassName, Name, 453, v11);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v17 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
        {
          __int16 v18 = object_getClass(*(id *)(a1 + 48));
          if (class_isMetaClass(v18)) {
            int v19 = 43;
          }
          else {
            int v19 = 45;
          }
          __int16 v20 = object_getClassName(*(id *)(a1 + 48));
          uint64_t v21 = sel_getName(*(SEL *)(a1 + 56));
          *(_DWORD *)long long buf = 67110146;
          *(_DWORD *)&uint8_t buf[4] = v19;
          *(_WORD *)&uint8_t buf[8] = 2082;
          *(void *)&buf[10] = v20;
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v21;
          *(_WORD *)&buf[28] = 1024;
          *(_DWORD *)&buf[30] = 453;
          *(_WORD *)&buf[34] = 2114;
          *(void *)&buf[36] = v11;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i error=%{public}@", buf, 0x2Cu);
        }

        (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
        return;
      }
      goto LABEL_30;
    }
    id v88 = 0;
    long long v33 = *(_OWORD *)(a1 + 80);
    *(_OWORD *)long long buf = *v7;
    *(_OWORD *)&uint8_t buf[16] = v33;
    id v9 = [v6 initWithDomain:12 auditToken:buf error:&v88];
    id v34 = v88;
    int v35 = v34;
    if (v9 && !v34)
    {
LABEL_30:
      id v36 = [v9 answer];

      switch((unint64_t)v36)
      {
        case 0uLL:
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v37 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v37)
          {
            __int16 v38 = object_getClass(*(id *)(a1 + 48));
            if (class_isMetaClass(v38)) {
              uint64_t v39 = 43;
            }
            else {
              uint64_t v39 = 45;
            }
            uint64_t v40 = object_getClassName(*(id *)(a1 + 48));
            unsigned int v41 = sel_getName(*(SEL *)(a1 + 56));
            v37(3, "%c[%{public}s %{public}s]:%i Invalid", v39, v40, v41, 463);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          int v42 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
          {
            __int16 v43 = object_getClass(*(id *)(a1 + 48));
            if (class_isMetaClass(v43)) {
              int v44 = 43;
            }
            else {
              int v44 = 45;
            }
            __int16 v45 = object_getClassName(*(id *)(a1 + 48));
            __int16 v46 = sel_getName(*(SEL *)(a1 + 56));
            *(_DWORD *)long long buf = 67109890;
            *(_DWORD *)&uint8_t buf[4] = v44;
            *(_WORD *)&uint8_t buf[8] = 2082;
            *(void *)&buf[10] = v45;
            *(_WORD *)&buf[18] = 2082;
            *(void *)&buf[20] = v46;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = 463;
            _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid", buf, 0x22u);
          }
          goto LABEL_78;
        case 1uLL:
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v59 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v59)
          {
            id v60 = object_getClass(*(id *)(a1 + 48));
            if (class_isMetaClass(v60)) {
              uint64_t v61 = 43;
            }
            else {
              uint64_t v61 = 45;
            }
            uint64_t v62 = object_getClassName(*(id *)(a1 + 48));
            id v63 = sel_getName(*(SEL *)(a1 + 56));
            v59(6, "%c[%{public}s %{public}s]:%i Unknown answer", v61, v62, v63, 475);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          int v42 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
          {
            NSErrorUserInfoKey v64 = object_getClass(*(id *)(a1 + 48));
            if (class_isMetaClass(v64)) {
              int v65 = 43;
            }
            else {
              int v65 = 45;
            }
            id v66 = object_getClassName(*(id *)(a1 + 48));
            uint64_t v67 = sel_getName(*(SEL *)(a1 + 56));
            *(_DWORD *)long long buf = 67109890;
            *(_DWORD *)&uint8_t buf[4] = v65;
            *(_WORD *)&uint8_t buf[8] = 2082;
            *(void *)&buf[10] = v66;
            *(_WORD *)&buf[18] = 2082;
            *(void *)&buf[20] = v67;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = 475;
            _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Unknown answer", buf, 0x22u);
          }
          goto LABEL_78;
        case 2uLL:
          goto LABEL_56;
        case 3uLL:
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v68 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
          if (v68)
          {
            id v69 = object_getClass(*(id *)(a1 + 48));
            if (class_isMetaClass(v69)) {
              uint64_t v70 = 43;
            }
            else {
              uint64_t v70 = 45;
            }
            int v71 = object_getClassName(*(id *)(a1 + 48));
            id v72 = sel_getName(*(SEL *)(a1 + 56));
            v68(4, "%c[%{public}s %{public}s]:%i Forcing uncertainity to ineligible", v70, v71, v72, 469);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          int v42 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
          {
            id v73 = object_getClass(*(id *)(a1 + 48));
            if (class_isMetaClass(v73)) {
              int v74 = 43;
            }
            else {
              int v74 = 45;
            }
            id v75 = object_getClassName(*(id *)(a1 + 48));
            id v76 = sel_getName(*(SEL *)(a1 + 56));
            *(_DWORD *)long long buf = 67109890;
            *(_DWORD *)&uint8_t buf[4] = v74;
            *(_WORD *)&uint8_t buf[8] = 2082;
            *(void *)&buf[10] = v75;
            *(_WORD *)&buf[18] = 2082;
            *(void *)&buf[20] = v76;
            *(_WORD *)&buf[28] = 1024;
            *(_DWORD *)&buf[30] = 469;
            _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Forcing uncertainity to ineligible", buf, 0x22u);
          }
LABEL_78:

          uint64_t v77 = *(void *)(*(void *)(a1 + 40) + 8);
          id v78 = *(void **)(v77 + 40);
          *(void *)(v77 + 40) = 0;

          (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
          break;
        default:
          if (!*(unsigned char *)(a1 + 96) || a2 == 2 || a2 == 1)
          {
LABEL_56:
            uint64_t v57 = *(void *)(*(void *)(a1 + 40) + 8);
            int v58 = *(void **)(v57 + 40);
            *(void *)(v57 + 40) = 0;

            (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
          }
          else
          {
            uint64_t v79 = *(void *)(a1 + 40);
            uint64_t v80 = *(void *)(*(void *)(v79 + 8) + 40);
            v83[0] = _NSConcreteStackBlock;
            v83[1] = 3221225472;
            v83[2] = sub_1001A8E60;
            v83[3] = &unk_100306840;
            int8x16_t v86 = vextq_s8(*(int8x16_t *)(a1 + 48), *(int8x16_t *)(a1 + 48), 8uLL);
            uint64_t v85 = v79;
            id v84 = *(id *)(a1 + 32);
            long long v81 = *(_OWORD *)(a1 + 80);
            *(_OWORD *)long long buf = *v7;
            *(_OWORD *)&uint8_t buf[16] = v81;
            sub_1000B80BC(v80, 1, (long long *)buf, v83);
          }
          break;
      }
      return;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v47 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v47)
    {
      int v48 = object_getClass(*(id *)(a1 + 48));
      if (class_isMetaClass(v48)) {
        uint64_t v49 = 43;
      }
      else {
        uint64_t v49 = 45;
      }
      __int16 v50 = object_getClassName(*(id *)(a1 + 48));
      int v51 = sel_getName(*(SEL *)(a1 + 56));
      v47(3, "%c[%{public}s %{public}s]:%i error=%{public}@", v49, v50, v51, 444, v35);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v52 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
    {
      BOOL v53 = object_getClass(*(id *)(a1 + 48));
      if (class_isMetaClass(v53)) {
        int v54 = 43;
      }
      else {
        int v54 = 45;
      }
      uint64_t v55 = object_getClassName(*(id *)(a1 + 48));
      uint64_t v56 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)long long buf = 67110146;
      *(_DWORD *)&uint8_t buf[4] = v54;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = v55;
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = v56;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 444;
      *(_WORD *)&buf[34] = 2114;
      *(void *)&buf[36] = v35;
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i error=%{public}@", buf, 0x2Cu);
    }

    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
  else
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v22 = NFLogGetLogger();
    if (v22)
    {
      int v23 = (void (*)(uint64_t, const char *, ...))v22;
      __int16 v24 = object_getClass(*(id *)(a1 + 48));
      BOOL isMetaClass = class_isMetaClass(v24);
      long long v26 = object_getClassName(*(id *)(a1 + 48));
      NSErrorUserInfoKey v82 = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v27 = 45;
      if (isMetaClass) {
        uint64_t v27 = 43;
      }
      v23(3, "%c[%{public}s %{public}s]:%i eligibility framework unavailable", v27, v26, v82, 433);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    NSErrorUserInfoKey v28 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
    {
      int v29 = object_getClass(*(id *)(a1 + 48));
      if (class_isMetaClass(v29)) {
        int v30 = 43;
      }
      else {
        int v30 = 45;
      }
      __int16 v31 = object_getClassName(*(id *)(a1 + 48));
      __int16 v32 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)long long buf = 67109890;
      *(_DWORD *)&uint8_t buf[4] = v30;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = v31;
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = v32;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 433;
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i eligibility framework unavailable", buf, 0x22u);
    }

    (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
  }
}

void sub_1001A8E30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, ...)
{
  va_start(va, a17);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001A8E60(void *a1, uint64_t a2)
{
  if (!a2)
  {
    id v3 = +[NSAssertionHandler currentHandler];
    [v3 handleFailureInMethod:a1[6] object:a1[7] file:@"_NFCardSession.m" lineNumber:521 description:@"Invalid state"];
  }
  uint64_t v4 = *(void *)(a1[5] + 8);
  BOOL v5 = *(void **)(v4 + 40);
  *(void *)(v4 + 40) = 0;

  id v6 = *(uint64_t (**)(void))(a1[4] + 16);

  return v6();
}

uint64_t sub_1001A8F04()
{
  if (!qword_100347548) {
    qword_100347548 = _sl_dlopen();
  }
  return qword_100347548;
}

uint64_t sub_1001A8FD4()
{
  uint64_t result = _sl_dlopen();
  qword_100347548 = result;
  return result;
}

void sub_1001A9048(void *a1)
{
  if (!sub_1001A8F04())
  {
    uint64_t v2 = +[NSAssertionHandler currentHandler];
    a1 = +[NSString stringWithUTF8String:"void *OSEligibilityLibrary(void)"];
    [v2 handleFailureInFunction:a1 file:@"_NFCardSession.m" lineNumber:26 description:@"%s"];

    __break(1u);
    free(v3);
  }
  *(void *)(*(void *)(a1[4] + 8) + 24) = objc_getClass("OSEligibilityQuery");
  if (*(void *)(*(void *)(a1[4] + 8) + 24))
  {
    qword_100347550 = *(void *)(*(void *)(a1[4] + 8) + 24);
  }
  else
  {
    uint64_t v4 = +[NSAssertionHandler currentHandler];
    BOOL v5 = +[NSString stringWithUTF8String:"Class getOSEligibilityQueryClass(void)_block_invoke"];
    [v4 handleFailureInFunction:v5 file:@"_NFCardSession.m" lineNumber:27 description:@"Unable to find class %s", "OSEligibilityQuery"];

    __break(1u);
  }
}

void sub_1001A9654(uint64_t a1)
{
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      long long v8 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 54, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      int v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      id v13 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
      id v15 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)long long buf = 67110146;
      int v27 = v12;
      __int16 v28 = 2082;
      int v29 = v13;
      __int16 v30 = 2082;
      __int16 v31 = v14;
      __int16 v32 = 1024;
      int v33 = 54;
      __int16 v34 = 2114;
      int v35 = v15;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v16 = *(void *)(a1 + 40);
    if (v16)
    {
      id v17 = objc_alloc((Class)NSError);
      __int16 v18 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v24 = NSLocalizedDescriptionKey;
      int v19 = +[NSString stringWithUTF8String:"Session not active"];
      id v25 = v19;
      __int16 v20 = +[NSDictionary dictionaryWithObjects:&v25 forKeys:&v24 count:1];
      id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
      (*(void (**)(uint64_t, id))(v16 + 16))(v16, v21);
    }
  }
  else
  {
    uint64_t v22 = *(void *)(a1 + 40);
    sub_1000A230C(*(id *)(*(void *)(a1 + 32) + 160));
    id v23 = (id)objc_claimAutoreleasedReturnValue();
    (*(void (**)(uint64_t))(v22 + 16))(v22);
  }
}

void sub_1001A9A8C(uint64_t a1)
{
  uint64_t v2 = NFSharedSignpostLog();
  if (os_signpost_enabled(v2))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v2, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SURF_PAYMENT", "in", buf, 2u);
  }

  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    id v23 = *(void **)(a1 + 32);
    NSErrorUserInfoKey v24 = *(void **)(a1 + 40);
    id v25 = (void *)v23[20];
    unsigned int v26 = [v23 uid];
    int v27 = *(void **)(a1 + 48);
    int v29 = 0;
    __int16 v20 = sub_1000A09B4(v25, v24, v26, v27, &v29);
    int v19 = v29;
    if (v20) {
      +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:&off_100323550];
    }
    +[NFGeneralStatisticsCALogger updateAnalyticsGeneralTransactionStatistics:&off_100323578];
    __int16 v28 = NFSharedSignpostLog();
    if (os_signpost_enabled(v28))
    {
      *(_WORD *)long long buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v28, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SURF_PAYMENT", "callback", buf, 2u);
    }

    (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
    id v21 = NFSharedSignpostLog();
    if (os_signpost_enabled(v21))
    {
      *(_WORD *)long long buf = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v21, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "SURF_PAYMENT", "out", buf, 2u);
    }
    goto LABEL_17;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v4 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 64));
    uint64_t v9 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v10 = 45;
    if (isMetaClass) {
      uint64_t v10 = 43;
    }
    v4(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v10, ClassName, Name, 68, v9);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v11 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    int v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12)) {
      int v13 = 43;
    }
    else {
      int v13 = 45;
    }
    uint64_t v14 = object_getClassName(*(id *)(a1 + 32));
    id v15 = sel_getName(*(SEL *)(a1 + 64));
    uint64_t v16 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v33 = v13;
    __int16 v34 = 2082;
    int v35 = v14;
    __int16 v36 = 2082;
    id v37 = v15;
    __int16 v38 = 1024;
    int v39 = 68;
    __int16 v40 = 2114;
    unsigned int v41 = v16;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v17 = *(void *)(a1 + 56);
  if (v17)
  {
    id v18 = objc_alloc((Class)NSError);
    int v19 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v30 = NSLocalizedDescriptionKey;
    __int16 v20 = +[NSString stringWithUTF8String:"Session not active"];
    __int16 v31 = v20;
    id v21 = +[NSDictionary dictionaryWithObjects:&v31 forKeys:&v30 count:1];
    id v22 = [v18 initWithDomain:v19 code:54 userInfo:v21];
    (*(void (**)(uint64_t, void, id))(v17 + 16))(v17, 0, v22);

LABEL_17:
  }
}

void *sub_1001A9EEC(void *result)
{
  if (result)
  {
    if (HIBYTE(word_100347559) == 1)
    {
      return (void *)word_100347559;
    }
    else
    {
      int v1 = result;
      if (NFDriverGetControllerInfo())
      {
        HIBYTE(word_100347559) = 1;
        return (void *)word_100347559;
      }
      else
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          id v3 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(v1);
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(v1);
          Name = sel_getName("supportsLPEM");
          uint64_t v7 = 45;
          if (isMetaClass) {
            uint64_t v7 = 43;
          }
          v3(3, "%c[%{public}s %{public}s]:%i Failed to get info", v7, ClassName, Name, 27, 0, 0, 0, 0);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        long long v8 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          uint64_t v9 = object_getClass(v1);
          if (class_isMetaClass(v9)) {
            int v10 = 43;
          }
          else {
            int v10 = 45;
          }
          *(_DWORD *)long long buf = 67109890;
          int v13 = v10;
          __int16 v14 = 2082;
          id v15 = object_getClassName(v1);
          __int16 v16 = 2082;
          uint64_t v17 = sel_getName("supportsLPEM");
          __int16 v18 = 1024;
          int v19 = 27;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to get info", buf, 0x22u);
        }

        return 0;
      }
    }
  }
  return result;
}

uint64_t sub_1001AA11C(void *a1)
{
  if (!sub_1001A9EEC(a1)) {
    return 0;
  }
  uint64_t v1 = (NFProductIsPhone() & 1) != 0 || NFProductIsWatch();
  if ((NFProductIsPhone() & 1) != 0 || NFProductIsWatch()) {
    v1 |= 2uLL;
  }
  if ((NFProductIsPhone() & 1) != 0 || (NFProductIsWatch() & 1) != 0 || NFIsNonRFDeviceWithLPMSupport()) {
    v1 |= 4uLL;
  }
  if (NFIsSeashipSupported()) {
    v1 |= 8uLL;
  }
  if (NFIsSeashipSupported()) {
    return v1 | 0x10;
  }
  else {
    return v1;
  }
}

uint64_t sub_1001AA1B4(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = sub_10021A750();
  if (v1) {
    uint64_t v2 = v1[4];
  }
  else {
    uint64_t v2 = 0;
  }

  return v2;
}

uint64_t sub_1001AA204(uint64_t result, uint64_t a2)
{
  if (result)
  {
    char v2 = a2;
    if (a2)
    {
      id v3 = (unsigned char *)result;
      if ((sub_1001A9EEC((void *)result) & 1) == 0)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          id v15 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(v3);
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(v3);
          Name = sel_getName("isHeadlessModeFeatureSupported:");
          uint64_t v19 = 45;
          if (isMetaClass) {
            uint64_t v19 = 43;
          }
          v15(3, "%c[%{public}s %{public}s]:%i LPEM not supported!", v19, ClassName, Name, 155);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v10 = NFSharedLogGetLogger();
        if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
          goto LABEL_26;
        }
        __int16 v20 = object_getClass(v3);
        if (class_isMetaClass(v20)) {
          int v21 = 43;
        }
        else {
          int v21 = 45;
        }
        *(_DWORD *)long long buf = 67109890;
        int v25 = v21;
        __int16 v26 = 2082;
        int v27 = object_getClassName(v3);
        __int16 v28 = 2082;
        int v29 = sel_getName("isHeadlessModeFeatureSupported:");
        __int16 v30 = 1024;
        int v31 = 155;
        int v13 = "%c[%{public}s %{public}s]:%i LPEM not supported!";
        goto LABEL_25;
      }
      if ((v2 & 3) != 0 && (v3[218] & 1) == 0)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v4 = NFLogGetLogger();
        if (v4)
        {
          BOOL v5 = (void (*)(uint64_t, const char *, ...))v4;
          id v6 = object_getClass(v3);
          BOOL v7 = class_isMetaClass(v6);
          long long v8 = object_getClassName(v3);
          id v22 = sel_getName("isHeadlessModeFeatureSupported:");
          uint64_t v9 = 45;
          if (v7) {
            uint64_t v9 = 43;
          }
          v5(3, "%c[%{public}s %{public}s]:%i no antenna - this type is not supported!", v9, v8, v22, 162);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v10 = NFSharedLogGetLogger();
        if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
          goto LABEL_26;
        }
        int v11 = object_getClass(v3);
        if (class_isMetaClass(v11)) {
          int v12 = 43;
        }
        else {
          int v12 = 45;
        }
        *(_DWORD *)long long buf = 67109890;
        int v25 = v12;
        __int16 v26 = 2082;
        int v27 = object_getClassName(v3);
        __int16 v28 = 2082;
        int v29 = sel_getName("isHeadlessModeFeatureSupported:");
        __int16 v30 = 1024;
        int v31 = 162;
        int v13 = "%c[%{public}s %{public}s]:%i no antenna - this type is not supported!";
LABEL_25:
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, v13, buf, 0x22u);
LABEL_26:

        return 0;
      }
    }
    return 1;
  }
  return result;
}

uint64_t sub_1001AA4BC(void *a1, uint64_t a2)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = a2;
  if (a2 == 31) {
    uint64_t v2 = sub_1001AA11C(a1);
  }
  if ((sub_1001AA204((uint64_t)a1, v2) & 1) == 0)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      int v29 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("addHeadlessModeFeature:");
      uint64_t v32 = 45;
      if (isMetaClass) {
        uint64_t v32 = 43;
      }
      v29(6, "%c[%{public}s %{public}s]:%i type %x not supported!", v32, ClassName, Name, 199, v2);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v27 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
    {
      int v33 = object_getClass(a1);
      if (class_isMetaClass(v33)) {
        int v34 = 43;
      }
      else {
        int v34 = 45;
      }
      *(_DWORD *)long long buf = 67110146;
      int v41 = v34;
      __int16 v42 = 2082;
      __int16 v43 = object_getClassName(a1);
      __int16 v44 = 2082;
      __int16 v45 = sel_getName("addHeadlessModeFeature:");
      __int16 v46 = 1024;
      int v47 = 199;
      __int16 v48 = 1024;
      int v49 = v2;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i type %x not supported!", buf, 0x28u);
    }
    goto LABEL_35;
  }
  uint64_t v4 = sub_10021A750();
  BOOL v5 = sub_10021D4EC(v4, v2);

  if (!v5) {
    return 1;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v6 = NFLogGetLogger();
  if (v6)
  {
    BOOL v7 = (void (*)(uint64_t, const char *, ...))v6;
    long long v8 = object_getClass(a1);
    BOOL v9 = class_isMetaClass(v8);
    int v10 = object_getClassName(a1);
    id v37 = sel_getName("addHeadlessModeFeature:");
    uint64_t v11 = 45;
    if (v9) {
      uint64_t v11 = 43;
    }
    v7(6, "%c[%{public}s %{public}s]:%i LPEM features changed, enabling", v11, v10, v37, 204);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v12 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = object_getClass(a1);
    if (class_isMetaClass(v13)) {
      int v14 = 43;
    }
    else {
      int v14 = 45;
    }
    *(_DWORD *)long long buf = 67109890;
    int v41 = v14;
    __int16 v42 = 2082;
    __int16 v43 = object_getClassName(a1);
    __int16 v44 = 2082;
    __int16 v45 = sel_getName("addHeadlessModeFeature:");
    __int16 v46 = 1024;
    int v47 = 204;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i LPEM features changed, enabling", buf, 0x22u);
  }

  uint64_t v15 = 1;
  if (([a1 enableHeadlessMode:1 shutdown:0] & 1) == 0)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v16 = NFLogGetLogger();
    if (v16)
    {
      uint64_t v17 = (void (*)(uint64_t, const char *, ...))v16;
      __int16 v18 = object_getClass(a1);
      BOOL v19 = class_isMetaClass(v18);
      __int16 v20 = object_getClassName(a1);
      __int16 v38 = sel_getName("addHeadlessModeFeature:");
      uint64_t v21 = 45;
      if (v19) {
        uint64_t v21 = 43;
      }
      v17(3, "%c[%{public}s %{public}s]:%i Failed to enable LPEM, reverting", v21, v20, v38, 206);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v22 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      id v23 = object_getClass(a1);
      if (class_isMetaClass(v23)) {
        int v24 = 43;
      }
      else {
        int v24 = 45;
      }
      int v25 = object_getClassName(a1);
      __int16 v26 = sel_getName("addHeadlessModeFeature:");
      *(_DWORD *)long long buf = 67109890;
      int v41 = v24;
      __int16 v42 = 2082;
      __int16 v43 = v25;
      __int16 v44 = 2082;
      __int16 v45 = v26;
      __int16 v46 = 1024;
      int v47 = 206;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to enable LPEM, reverting", buf, 0x22u);
    }

    int v27 = sub_10021A750();
    sub_10021D824(v27, v2);
LABEL_35:

    return 0;
  }
  return v15;
}

uint64_t sub_1001AA914(uint64_t result, uint64_t a2)
{
  if (result)
  {
    uint64_t v2 = a2;
    id v3 = (void *)result;
    if (a2 == 31) {
      uint64_t v2 = sub_1001AA11C((void *)result);
    }
    if (sub_1001AA204((uint64_t)v3, v2)
      && (sub_10021A750(),
          uint64_t v4 = objc_claimAutoreleasedReturnValue(),
          BOOL v5 = sub_10021D824(v4, v2),
          v4,
          v5)
      && ([v3 enableHeadlessMode:sub_1001AA1B4((uint64_t)v3) != 0 shutdown:0] & 1) == 0)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t Logger = NFLogGetLogger();
      if (Logger)
      {
        BOOL v7 = (void (*)(uint64_t, const char *, ...))Logger;
        Class = object_getClass(v3);
        BOOL isMetaClass = class_isMetaClass(Class);
        ClassName = object_getClassName(v3);
        Name = sel_getName("removeHeadlessModeFeature:");
        uint64_t v11 = 45;
        if (isMetaClass) {
          uint64_t v11 = 43;
        }
        v7(3, "%c[%{public}s %{public}s]:%i Failed to change LPEM, reverting", v11, ClassName, Name, 227);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v12 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
      {
        int v13 = object_getClass(v3);
        if (class_isMetaClass(v13)) {
          int v14 = 43;
        }
        else {
          int v14 = 45;
        }
        *(_DWORD *)long long buf = 67109890;
        int v18 = v14;
        __int16 v19 = 2082;
        __int16 v20 = object_getClassName(v3);
        __int16 v21 = 2082;
        id v22 = sel_getName("removeHeadlessModeFeature:");
        __int16 v23 = 1024;
        int v24 = 227;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to change LPEM, reverting", buf, 0x22u);
      }

      uint64_t v15 = sub_10021A750();
      sub_10021D4EC(v15, v2);

      return 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

id sub_1001AAB3C(id result)
{
  if (result)
  {
    uint64_t v1 = result;
    uint64_t v2 = sub_10021A750();
    sub_10021D45C(v2, 0);

    return [v1 enableHeadlessMode:0 shutdown:1];
  }
  return result;
}

void sub_1001AB150(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_1001AB184(void *a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    objc_sync_enter(v1);
    if (v1[137])
    {
      id v2 = objc_alloc((Class)NSError);
      id v3 = +[NSString stringWithUTF8String:"nfcd"];
      v19[0] = NSLocalizedDescriptionKey;
      uint64_t v4 = +[NSString stringWithUTF8String:"Aborted"];
      v20[0] = v4;
      v20[1] = &off_10031D4A0;
      v19[1] = @"Line";
      void v19[2] = @"Method";
      id v5 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("disableHeadlessMiniNV")];
      v20[2] = v5;
      v19[3] = NSDebugDescriptionErrorKey;
      id v6 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("disableHeadlessMiniNV"), 289];
      v20[3] = v6;
      BOOL v7 = +[NSDictionary dictionaryWithObjects:v20 forKeys:v19 count:4];
      id v8 = [v2 initWithDomain:v3 code:3 userInfo:v7];
    }
    else
    {
      unsigned __int8 v9 = NFDriverSetHeadlessMode();
      unsigned __int8 v10 = NFDriverDisableHeadlessModeMiniNV();
      uint64_t v11 = sub_10021A750();
      sub_10021DD48((uint64_t)v11);

      sub_10021A750();
      int v12 = (unsigned char *)objc_claimAutoreleasedReturnValue();
      id v13 = sub_10021AD90(v12);

      if (v9 & v10)
      {
        int v14 = 0;
LABEL_8:
        objc_sync_exit(v1);

        goto LABEL_9;
      }
      id v15 = objc_alloc((Class)NSError);
      id v3 = +[NSString stringWithUTF8String:"nfcd"];
      v17[0] = NSLocalizedDescriptionKey;
      uint64_t v4 = +[NSString stringWithUTF8String:"Unknown Error"];
      v18[0] = v4;
      v18[1] = &off_10031D4B8;
      v17[1] = @"Line";
      v17[2] = @"Method";
      id v5 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("disableHeadlessMiniNV")];
      void v18[2] = v5;
      v17[3] = NSDebugDescriptionErrorKey;
      id v6 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("disableHeadlessMiniNV"), 298];
      v18[3] = v6;
      BOOL v7 = +[NSDictionary dictionaryWithObjects:v18 forKeys:v17 count:4];
      id v8 = [v15 initWithDomain:v3 code:6 userInfo:v7];
    }
    int v14 = v8;

    goto LABEL_8;
  }
  int v14 = 0;
LABEL_9:

  return v14;
}

void sub_1001AB4F0(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

id sub_1001AB510(void *a1)
{
  if (a1)
  {
    uint64_t v1 = a1;
    objc_sync_enter(v1);
    if (v1[137])
    {
      id v2 = objc_alloc((Class)NSError);
      id v3 = +[NSString stringWithUTF8String:"nfcd"];
      v14[0] = NSLocalizedDescriptionKey;
      uint64_t v4 = +[NSString stringWithUTF8String:"Aborted"];
      v15[0] = v4;
      v15[1] = &off_10031D4D0;
      v14[1] = @"Line";
      v14[2] = @"Method";
      id v5 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("enableHeadlessMiniNV")];
      v15[2] = v5;
      v14[3] = NSDebugDescriptionErrorKey;
      id v6 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("enableHeadlessMiniNV"), 310];
      v15[3] = v6;
      BOOL v7 = +[NSDictionary dictionaryWithObjects:v15 forKeys:v14 count:4];
      id v8 = [v2 initWithDomain:v3 code:3 userInfo:v7];
    }
    else
    {
      if (NFDriverEnableHeadlessModeMiniNV())
      {
        unsigned __int8 v9 = 0;
LABEL_8:
        objc_sync_exit(v1);

        goto LABEL_9;
      }
      id v10 = objc_alloc((Class)NSError);
      id v3 = +[NSString stringWithUTF8String:"nfcd"];
      v12[0] = NSLocalizedDescriptionKey;
      uint64_t v4 = +[NSString stringWithUTF8String:"Unknown Error"];
      v13[0] = v4;
      v13[1] = &off_10031D4E8;
      v12[1] = @"Line";
      v12[2] = @"Method";
      id v5 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("enableHeadlessMiniNV")];
      v13[2] = v5;
      v12[3] = NSDebugDescriptionErrorKey;
      id v6 = [[objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("enableHeadlessMiniNV"), 313];
      v13[3] = v6;
      BOOL v7 = +[NSDictionary dictionaryWithObjects:v13 forKeys:v12 count:4];
      id v8 = [v10 initWithDomain:v3 code:6 userInfo:v7];
    }
    unsigned __int8 v9 = v8;

    goto LABEL_8;
  }
  unsigned __int8 v9 = 0;
LABEL_9:

  return v9;
}

void sub_1001AB828(_Unwind_Exception *exception_object)
{
}

uint64_t sub_1001AB844(void *a1, void *a2)
{
  if (!a1) {
    return 0;
  }
  id v3 = a1;
  objc_sync_enter(v3);
  if (v3[137])
  {
    if (a2)
    {
      id v4 = objc_alloc((Class)NSError);
      id v5 = +[NSString stringWithUTF8String:"nfcd"];
      v12[0] = NSLocalizedDescriptionKey;
      id v6 = +[NSString stringWithUTF8String:"Aborted"];
      v13[0] = v6;
      v13[1] = &off_10031D500;
      v12[1] = @"Line";
      v12[2] = @"Method";
      id v7 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName("getHeadlessFlags:")];
      v13[2] = v7;
      v12[3] = NSDebugDescriptionErrorKey;
      id v8 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName("getHeadlessFlags:"), 327];
      v13[3] = v8;
      unsigned __int8 v9 = +[NSDictionary dictionaryWithObjects:v13 forKeys:v12 count:4];
      *a2 = [v4 initWithDomain:v5 code:3 userInfo:v9];

      uint64_t HeadlessModeFlags = 0;
    }
    else
    {
      uint64_t HeadlessModeFlags = 0;
    }
  }
  else
  {
    uint64_t HeadlessModeFlags = NFDriverGetHeadlessModeFlags();
  }
  objc_sync_exit(v3);

  return HeadlessModeFlags;
}

void sub_1001ABB00(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

uint64_t sub_1001ABB20(void *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v1 = a1;
  objc_sync_enter(v1);
  if (v1[137]) {
    uint64_t v2 = 0;
  }
  else {
    uint64_t v2 = NFDriverEnableHeadlessTestMode();
  }
  objc_sync_exit(v1);

  return v2;
}

void sub_1001ABB90(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1001ABBA4(void *a1)
{
  if (a1)
  {
    id obj = a1;
    objc_sync_enter(obj);
    if (!obj[137]) {
      NFDriverDumpLPMDebugLog();
    }
    objc_sync_exit(obj);
  }
}

void sub_1001ABC1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void *sub_1001ABC30(uint64_t a1, uint64_t a2)
{
  self;
  id v3 = objc_opt_new();
  if (v3) {
    v3[1] = a2;
  }

  return v3;
}

id sub_1001ABC78(uint64_t a1)
{
  if (a1)
  {
    uint64_t v1 = sub_1001ABD60();
    v6[0] = v1;
    v7[0] = &off_10031D518;
    uint64_t v2 = sub_1001ABEC8();
    v6[1] = v2;
    v7[1] = &off_10031D518;
    id v3 = sub_1001AC030();
    v6[2] = v3;
    v7[2] = &off_10031D518;
    id v4 = +[NSDictionary dictionaryWithObjects:v7 forKeys:v6 count:3];
  }
  else
  {
    id v4 = 0;
  }

  return v4;
}

void sub_1001ABD60()
{
  uint64_t v6 = 0;
  id v7 = &v6;
  uint64_t v8 = 0x2020000000;
  id v0 = (void **)qword_100347560;
  uint64_t v9 = qword_100347560;
  if (!qword_100347560)
  {
    uint64_t v1 = sub_1001B17FC();
    void v7[3] = (uint64_t)dlsym(v1, "kCPMSPowerTimeScaleInstantaneous");
    qword_100347560 = v7[3];
    id v0 = (void **)v7[3];
  }
  _Block_object_dispose(&v6, 8);
  if (v0)
  {
    uint64_t v2 = *v0;
    id v3 = v2;
  }
  else
  {
    id v4 = +[NSAssertionHandler currentHandler];
    id v5 = +[NSString stringWithUTF8String:"NSString *getkCPMSPowerTimeScaleInstantaneous(void)"];
    [v4 handleFailureInFunction:v5 file:@"NFCoreDuetWrapper.m" lineNumber:33 description:@"%s", dlerror()];

    __break(1u);
  }
}

void sub_1001ABEB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1001ABEC8()
{
  uint64_t v6 = 0;
  id v7 = &v6;
  uint64_t v8 = 0x2020000000;
  id v0 = (void **)qword_100347568;
  uint64_t v9 = qword_100347568;
  if (!qword_100347568)
  {
    uint64_t v1 = sub_1001B17FC();
    void v7[3] = (uint64_t)dlsym(v1, "kCPMSPowerTimeScale100ms");
    qword_100347568 = v7[3];
    id v0 = (void **)v7[3];
  }
  _Block_object_dispose(&v6, 8);
  if (v0)
  {
    uint64_t v2 = *v0;
    id v3 = v2;
  }
  else
  {
    id v4 = +[NSAssertionHandler currentHandler];
    id v5 = +[NSString stringWithUTF8String:"NSString *getkCPMSPowerTimeScale100ms(void)"];
    [v4 handleFailureInFunction:v5 file:@"NFCoreDuetWrapper.m" lineNumber:34 description:@"%s", dlerror()];

    __break(1u);
  }
}

void sub_1001AC018(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1001AC030()
{
  uint64_t v6 = 0;
  id v7 = &v6;
  uint64_t v8 = 0x2020000000;
  id v0 = (void **)qword_100347570;
  uint64_t v9 = qword_100347570;
  if (!qword_100347570)
  {
    uint64_t v1 = sub_1001B17FC();
    void v7[3] = (uint64_t)dlsym(v1, "kCPMSPowerTimeScale1s");
    qword_100347570 = v7[3];
    id v0 = (void **)v7[3];
  }
  _Block_object_dispose(&v6, 8);
  if (v0)
  {
    uint64_t v2 = *v0;
    id v3 = v2;
  }
  else
  {
    id v4 = +[NSAssertionHandler currentHandler];
    id v5 = +[NSString stringWithUTF8String:"NSString *getkCPMSPowerTimeScale1s(void)"];
    [v4 handleFailureInFunction:v5 file:@"NFCoreDuetWrapper.m" lineNumber:35 description:@"%s", dlerror()];

    __break(1u);
  }
}

void sub_1001AC180(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id sub_1001AC198(void *a1)
{
  if (a1)
  {
    uint64_t v2 = 0;
    switch(a1[1])
    {
      case 7:
      case 8:
        id v3 = sub_1001ABD60();
        v30[0] = v3;
        v31[0] = &off_10031D530;
        id v4 = sub_1001ABEC8();
        v30[1] = v4;
        v31[1] = &off_10031D548;
        id v5 = sub_1001AC030();
        v30[2] = v5;
        v31[2] = &off_10031D560;
        uint64_t v6 = v31;
        id v7 = v30;
        goto LABEL_6;
      case 0xALL:
      case 0xBLL:
      case 0xCLL:
      case 0x14:
        id v3 = sub_1001ABD60();
        v28[0] = v3;
        v29[0] = &off_10031D530;
        id v4 = sub_1001ABEC8();
        v28[1] = v4;
        v29[1] = &off_10031D548;
        id v5 = sub_1001AC030();
        v28[2] = v5;
        v29[2] = &off_10031D560;
        uint64_t v6 = v29;
        id v7 = v28;
        goto LABEL_6;
      case 0xELL:
      case 0xFLL:
      case 0x10:
      case 0x11:
        id v3 = sub_1001ABD60();
        v26[0] = v3;
        v27[0] = &off_10031D578;
        id v4 = sub_1001ABEC8();
        v26[1] = v4;
        v27[1] = &off_10031D578;
        id v5 = sub_1001AC030();
        v26[2] = v5;
        v27[2] = &off_10031D578;
        uint64_t v6 = v27;
        id v7 = v26;
LABEL_6:
        uint64_t v2 = +[NSDictionary dictionaryWithObjects:v6 forKeys:v7 count:3];

        goto LABEL_7;
      case 0x12:
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          id v10 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(a1);
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(a1);
          Name = sel_getName("powerLevelReader");
          uint64_t v14 = 45;
          if (isMetaClass) {
            uint64_t v14 = 43;
          }
          v10(3, "%c[%{public}s %{public}s]:%i This hardware does not support reader", v14, ClassName, Name, 170);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v3 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        {
          id v15 = object_getClass(a1);
          if (class_isMetaClass(v15)) {
            int v16 = 43;
          }
          else {
            int v16 = 45;
          }
          *(_DWORD *)long long buf = 67109890;
          int v19 = v16;
          __int16 v20 = 2082;
          __int16 v21 = object_getClassName(a1);
          __int16 v22 = 2082;
          __int16 v23 = sel_getName("powerLevelReader");
          __int16 v24 = 1024;
          int v25 = 170;
          _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i This hardware does not support reader", buf, 0x22u);
        }
        uint64_t v2 = 0;
LABEL_7:

        break;
      default:
        break;
    }
  }
  else
  {
    uint64_t v2 = 0;
  }

  return v2;
}

id sub_1001AC4F4(void *a1)
{
  if (a1)
  {
    uint64_t v2 = 0;
    switch(a1[1])
    {
      case 7:
      case 8:
        id v3 = sub_1001ABD60();
        v30[0] = v3;
        v31[0] = &off_10031D590;
        id v4 = sub_1001ABEC8();
        v30[1] = v4;
        v31[1] = &off_10031D5A8;
        id v5 = sub_1001AC030();
        v30[2] = v5;
        v31[2] = &off_10031D5C0;
        uint64_t v6 = v31;
        id v7 = v30;
        goto LABEL_6;
      case 0xALL:
      case 0xBLL:
      case 0xCLL:
      case 0x14:
        id v3 = sub_1001ABD60();
        v28[0] = v3;
        v29[0] = &off_10031D5D8;
        id v4 = sub_1001ABEC8();
        v28[1] = v4;
        v29[1] = &off_10031D5F0;
        id v5 = sub_1001AC030();
        v28[2] = v5;
        v29[2] = &off_10031D608;
        uint64_t v6 = v29;
        id v7 = v28;
        goto LABEL_6;
      case 0xELL:
      case 0xFLL:
      case 0x10:
      case 0x11:
        id v3 = sub_1001ABD60();
        v18[0] = v3;
        v19[0] = &off_10031D620;
        id v4 = sub_1001ABEC8();
        v18[1] = v4;
        v19[1] = &off_10031D638;
        id v5 = sub_1001AC030();
        void v18[2] = v5;
        void v19[2] = &off_10031D650;
        uint64_t v6 = v19;
        id v7 = v18;
LABEL_6:
        uint64_t v2 = +[NSDictionary dictionaryWithObjects:v6 forKeys:v7 count:3];

        goto LABEL_7;
      case 0x12:
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          id v10 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(a1);
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(a1);
          Name = sel_getName("powerLevelSECardEmulation");
          uint64_t v14 = 45;
          if (isMetaClass) {
            uint64_t v14 = 43;
          }
          v10(3, "%c[%{public}s %{public}s]:%i This hardware does not support CE", v14, ClassName, Name, 205);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v3 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        {
          id v15 = object_getClass(a1);
          if (class_isMetaClass(v15)) {
            int v16 = 43;
          }
          else {
            int v16 = 45;
          }
          *(_DWORD *)long long buf = 67109890;
          int v21 = v16;
          __int16 v22 = 2082;
          __int16 v23 = object_getClassName(a1);
          __int16 v24 = 2082;
          int v25 = sel_getName("powerLevelSECardEmulation");
          __int16 v26 = 1024;
          int v27 = 205;
          _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i This hardware does not support CE", buf, 0x22u);
        }
        uint64_t v2 = 0;
LABEL_7:

        break;
      default:
        break;
    }
  }
  else
  {
    uint64_t v2 = 0;
  }

  return v2;
}

id sub_1001AC860(void *a1)
{
  if (a1)
  {
    uint64_t v2 = 0;
    switch(a1[1])
    {
      case 7:
      case 8:
        id v3 = sub_1001ABD60();
        v30[0] = v3;
        v31[0] = &off_10031D668;
        id v4 = sub_1001ABEC8();
        v30[1] = v4;
        v31[1] = &off_10031D680;
        id v5 = sub_1001AC030();
        v30[2] = v5;
        v31[2] = &off_10031D698;
        uint64_t v6 = v31;
        id v7 = v30;
        goto LABEL_6;
      case 0xALL:
      case 0xBLL:
      case 0xCLL:
      case 0x14:
        id v3 = sub_1001ABD60();
        v28[0] = v3;
        v29[0] = &off_10031D6B0;
        id v4 = sub_1001ABEC8();
        v28[1] = v4;
        v29[1] = &off_10031D6C8;
        id v5 = sub_1001AC030();
        v28[2] = v5;
        v29[2] = &off_10031D6E0;
        uint64_t v6 = v29;
        id v7 = v28;
        goto LABEL_6;
      case 0xELL:
      case 0xFLL:
      case 0x10:
      case 0x11:
        id v3 = sub_1001ABD60();
        v18[0] = v3;
        v19[0] = &off_10031D6F8;
        id v4 = sub_1001ABEC8();
        v18[1] = v4;
        v19[1] = &off_10031D710;
        id v5 = sub_1001AC030();
        void v18[2] = v5;
        void v19[2] = &off_10031D728;
        uint64_t v6 = v19;
        id v7 = v18;
LABEL_6:
        uint64_t v2 = +[NSDictionary dictionaryWithObjects:v6 forKeys:v7 count:3];

        goto LABEL_7;
      case 0x12:
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          id v10 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(a1);
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(a1);
          Name = sel_getName("powerLevelCombined");
          uint64_t v14 = 45;
          if (isMetaClass) {
            uint64_t v14 = 43;
          }
          v10(3, "%c[%{public}s %{public}s]:%i This hardware does not support CE", v14, ClassName, Name, 254);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v3 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
        {
          id v15 = object_getClass(a1);
          if (class_isMetaClass(v15)) {
            int v16 = 43;
          }
          else {
            int v16 = 45;
          }
          *(_DWORD *)long long buf = 67109890;
          int v21 = v16;
          __int16 v22 = 2082;
          __int16 v23 = object_getClassName(a1);
          __int16 v24 = 2082;
          int v25 = sel_getName("powerLevelCombined");
          __int16 v26 = 1024;
          int v27 = 254;
          _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i This hardware does not support CE", buf, 0x22u);
        }
        uint64_t v2 = 0;
LABEL_7:

        break;
      default:
        break;
    }
  }
  else
  {
    uint64_t v2 = 0;
  }

  return v2;
}

void sub_1001ACBCC(id *a1, void *a2, void *a3)
{
  id obj = a2;
  id v5 = a3;
  if (a1)
  {
    objc_storeWeak(a1 + 8, obj);
    objc_storeStrong(a1 + 9, a3);
    if (obj)
    {
      int v6 = [a1[6] intValue];
      if (v6 >= 1) {
        uint64_t v7 = v6 < 850;
      }
      else {
        uint64_t v7 = 2;
      }
      [obj thermalStateChanged:v7];
    }
  }
}

void sub_1001ACC70(uint64_t a1, void *a2)
{
  if (a2)
  {
    id v31 = [a2 objectForKey:@"com.apple.duet.ppm-bgt.stck"];
    if (v31)
    {
      id WeakRetained = (id *)objc_loadWeakRetained((id *)(a1 + 32));
      id v30 = v31;
      if (WeakRetained)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t Logger = NFLogGetLogger();
        if (Logger)
        {
          id v5 = (void (*)(uint64_t, const char *, ...))Logger;
          Class = object_getClass(WeakRetained);
          BOOL isMetaClass = class_isMetaClass(Class);
          ClassName = object_getClassName(WeakRetained);
          Name = sel_getName("_handleUpdatedBudgetValue:");
          uint64_t v8 = 45;
          if (isMetaClass) {
            uint64_t v8 = 43;
          }
          v5(5, "%c[%{public}s %{public}s]:%i %{public}@", v8, ClassName, Name, 973, v30);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v9 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
        {
          id v10 = object_getClass(WeakRetained);
          if (class_isMetaClass(v10)) {
            int v11 = 43;
          }
          else {
            int v11 = 45;
          }
          *(_DWORD *)long long buf = 67110146;
          *(_DWORD *)&uint8_t buf[4] = v11;
          *(_WORD *)__int16 v46 = 2082;
          *(void *)&v46[2] = object_getClassName(WeakRetained);
          __int16 v47 = 2082;
          __int16 v48 = sel_getName("_handleUpdatedBudgetValue:");
          __int16 v49 = 1024;
          int v50 = 973;
          __int16 v51 = 2114;
          id v52 = v30;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@", buf, 0x2Cu);
        }

        if (![v30 integerValue])
        {
          int v12 = _os_activity_create((void *)&_mh_execute_header, "coreduet revoked", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_IF_NONE_PRESENT);
          *(void *)long long buf = 0;
          *(void *)__int16 v46 = 0;
          os_activity_scope_enter(v12, (os_activity_scope_state_t)buf);
          os_activity_scope_leave((os_activity_scope_state_t)buf);

          id v29 = WeakRetained[4];
          objc_sync_enter(v29);
          long long v35 = 0u;
          long long v36 = 0u;
          long long v33 = 0u;
          long long v34 = 0u;
          id obj = WeakRetained[4];
          id v13 = [obj countByEnumeratingWithState:&v33 objects:buf count:16];
          if (v13)
          {
            uint64_t v14 = *(void *)v34;
            do
            {
              for (i = 0; i != v13; i = (char *)i + 1)
              {
                if (*(void *)v34 != v14) {
                  objc_enumerationMutation(obj);
                }
                int v16 = *(void **)(*((void *)&v33 + 1) + 8 * i);
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                uint64_t v17 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
                if (v17)
                {
                  int v18 = object_getClass(WeakRetained);
                  if (class_isMetaClass(v18)) {
                    uint64_t v19 = 43;
                  }
                  else {
                    uint64_t v19 = 45;
                  }
                  __int16 v20 = object_getClassName(WeakRetained);
                  int v21 = sel_getName("_handleUpdatedBudgetValue:");
                  v17(5, "%c[%{public}s %{public}s]:%i Revoking core duet activity", v19, v20, v21, 980);
                }
                dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
                __int16 v22 = NFSharedLogGetLogger();
                if (os_log_type_enabled(v22, OS_LOG_TYPE_DEFAULT))
                {
                  __int16 v23 = object_getClass(WeakRetained);
                  if (class_isMetaClass(v23)) {
                    int v24 = 43;
                  }
                  else {
                    int v24 = 45;
                  }
                  int v25 = object_getClassName(WeakRetained);
                  __int16 v26 = sel_getName("_handleUpdatedBudgetValue:");
                  *(_DWORD *)id v37 = 67109890;
                  int v38 = v24;
                  __int16 v39 = 2082;
                  __int16 v40 = v25;
                  __int16 v41 = 2082;
                  __int16 v42 = v26;
                  __int16 v43 = 1024;
                  int v44 = 980;
                  _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Revoking core duet activity", v37, 0x22u);
                }

                [v16 coreDuetActivityRevoked];
              }
              id v13 = [obj countByEnumeratingWithState:&v33 objects:buf count:16];
            }
            while (v13);
          }

          objc_sync_exit(v29);
        }
      }
    }
  }
}

void sub_1001AD0DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id obj)
{
}

id sub_1001AD10C(uint64_t a1)
{
  if (!a1 || !sub_1001B18AC()) {
    return 0;
  }
  id v1 = sub_1001AD150();

  return [v1 isCPMSSupported];
}

id sub_1001AD150()
{
  uint64_t v4 = 0;
  id v5 = &v4;
  uint64_t v6 = 0x2050000000;
  id v0 = (void *)qword_100347578;
  uint64_t v7 = qword_100347578;
  if (!qword_100347578)
  {
    v3[0] = _NSConcreteStackBlock;
    v3[1] = 3221225472;
    v3[2] = sub_1001B1A90;
    v3[3] = &unk_100301E40;
    v3[4] = &v4;
    sub_1001B1A90((uint64_t)v3);
    id v0 = (void *)v5[3];
  }
  id v1 = v0;
  _Block_object_dispose(&v4, 8);

  return v1;
}

void sub_1001AD21C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1001AD4D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1001AD50C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 64));
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2)
  {
    int v3 = [*(id *)(v2 + 48) intValue];
    if (v3 >= 1) {
      uint64_t v4 = v3 < 850;
    }
    else {
      uint64_t v4 = 2;
    }
  }
  else
  {
    uint64_t v4 = 0;
  }
  [WeakRetained thermalStateChanged:v4];
}

id sub_1001AD58C(uint64_t a1)
{
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  uint64_t v2 = WeakRetained;
  if (WeakRetained)
  {
    int v3 = WeakRetained[40];
    uint64_t v4 = (void *)*((void *)WeakRetained + 3);
    if (v2[41])
    {
      if (v3) {
        sub_1001AC860(v4);
      }
      else {
        sub_1001AC4F4(v4);
      }
    }
    else if (v3)
    {
      sub_1001AC198(v4);
    }
    else
    {
      sub_1001ABC78((uint64_t)v4);
    uint64_t v5 = };
    uint64_t v6 = (void *)v5;
    uint64_t v7 = NFSharedSignpostLog();
    if (os_signpost_enabled(v7))
    {
      int v9 = 138412290;
      id v10 = v6;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v7, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CPMS_GET_CURRENT", "%@", (uint8_t *)&v9, 0xCu);
    }
  }
  else
  {
    uint64_t v6 = 0;
  }

  return v6;
}

void sub_1001AD6BC(uint64_t a1, void *a2)
{
  id v3 = a2;
  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 40));
  id v5 = [v3 mutableCopy];
  uint64_t v6 = NFSharedSignpostLog();
  if (os_signpost_enabled(v6))
  {
    *(_WORD *)long long buf = 0;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v6, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CPMS_SET_CALLBACK", (const char *)&unk_100286819, buf, 2u);
  }

  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    uint64_t v8 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(WeakRetained);
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(WeakRetained);
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v11 = 45;
    if (isMetaClass) {
      uint64_t v11 = 43;
    }
    v8(6, "%c[%{public}s %{public}s]:%i Got power request : %@", v11, ClassName, Name, 541, v3);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v12 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
  {
    id v13 = object_getClass(WeakRetained);
    if (class_isMetaClass(v13)) {
      int v14 = 43;
    }
    else {
      int v14 = 45;
    }
    id v15 = object_getClassName(WeakRetained);
    int v16 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)long long buf = 67110146;
    *(_DWORD *)&uint8_t buf[4] = v14;
    *(_WORD *)uint64_t v55 = 2082;
    *(void *)&void v55[2] = v15;
    *(_WORD *)&v55[10] = 2082;
    *(void *)&v55[12] = v16;
    *(_WORD *)&v55[20] = 1024;
    *(_DWORD *)&v55[22] = 541;
    *(_WORD *)&v55[26] = 2112;
    *(void *)&v55[28] = v3;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Got power request : %@", buf, 0x2Cu);
  }

  if (NFThermalMonitorProvidedBySMC()
    && *(void *)(a1 + 32) == *((void *)WeakRetained + 2)
    && (sub_1001ADCA4(),
        id v29 = objc_claimAutoreleasedReturnValue(),
        [v3 valueForKey:v29],
        id v30 = objc_claimAutoreleasedReturnValue(),
        v29,
        v30))
  {
    objc_opt_class();
    if (objc_opt_isKindOfClass())
    {
      id v17 = v30;
      if (([*((id *)WeakRetained + 6) isEqualToNumber:v17] & 1) == 0)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v31 = NFLogGetLogger();
        if (v31)
        {
          uint64_t v32 = (void (*)(uint64_t, const char *, ...))v31;
          long long v33 = object_getClass(WeakRetained);
          BOOL v50 = class_isMetaClass(v33);
          id v52 = object_getClassName(WeakRetained);
          long long v34 = sel_getName("processNewThermalBudget:");
          uint64_t v35 = 45;
          if (v50) {
            uint64_t v35 = 43;
          }
          v32(6, "%c[%{public}s %{public}s]:%i New thermal budget: %{public}@ -> %{public}@", v35, v52, v34, 475, *((void *)WeakRetained + 6), v17);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        long long v36 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v36, OS_LOG_TYPE_DEFAULT))
        {
          id v37 = object_getClass(WeakRetained);
          if (class_isMetaClass(v37)) {
            int v38 = 43;
          }
          else {
            int v38 = 45;
          }
          int v53 = v38;
          __int16 v51 = object_getClassName(WeakRetained);
          __int16 v39 = sel_getName("processNewThermalBudget:");
          uint64_t v40 = *((void *)WeakRetained + 6);
          *(_DWORD *)long long buf = 67110402;
          *(_DWORD *)&uint8_t buf[4] = v53;
          *(_WORD *)uint64_t v55 = 2082;
          *(void *)&void v55[2] = v51;
          *(_WORD *)&v55[10] = 2082;
          *(void *)&v55[12] = v39;
          *(_WORD *)&v55[20] = 1024;
          *(_DWORD *)&v55[22] = 475;
          *(_WORD *)&v55[26] = 2114;
          *(void *)&v55[28] = v40;
          __int16 v56 = 2114;
          id v57 = v17;
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i New thermal budget: %{public}@ -> %{public}@", buf, 0x36u);
        }

        objc_storeStrong((id *)WeakRetained + 6, v30);
        id v41 = objc_loadWeakRetained((id *)WeakRetained + 8);
        if (v41)
        {
          uint64_t v42 = *((void *)WeakRetained + 9);

          if (v42)
          {
            __int16 v43 = *((void *)WeakRetained + 9);
            *(void *)long long buf = _NSConcreteStackBlock;
            *(void *)uint64_t v55 = 3221225472;
            *(void *)&v55[8] = sub_1001AD50C;
            *(void *)&v55[16] = &unk_100301C68;
            *(void *)&v55[24] = WeakRetained;
            dispatch_async(v43, buf);
          }
        }
      }
      id v44 = *((id *)WeakRetained + 6);

      if (v44)
      {
        __int16 v45 = sub_1001ADCA4();
        [v5 setValue:v44 forKey:v45];
      }
    }
    else
    {
      id v17 = v30;
    }
  }
  else
  {
    id v17 = 0;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v18 = NFLogGetLogger();
  if (v18)
  {
    uint64_t v19 = (void (*)(uint64_t, const char *, ...))v18;
    __int16 v20 = object_getClass(WeakRetained);
    BOOL v21 = class_isMetaClass(v20);
    __int16 v47 = object_getClassName(WeakRetained);
    __int16 v49 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v22 = 45;
    if (v21) {
      uint64_t v22 = 43;
    }
    v19(6, "%c[%{public}s %{public}s]:%i Got power request : %@", v22, v47, v49, 553, v5);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  __int16 v23 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
  {
    int v24 = object_getClass(WeakRetained);
    if (class_isMetaClass(v24)) {
      int v25 = 43;
    }
    else {
      int v25 = 45;
    }
    __int16 v26 = object_getClassName(WeakRetained);
    int v27 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)long long buf = 67110146;
    *(_DWORD *)&uint8_t buf[4] = v25;
    *(_WORD *)uint64_t v55 = 2082;
    *(void *)&void v55[2] = v26;
    *(_WORD *)&v55[10] = 2082;
    *(void *)&v55[12] = v27;
    *(_WORD *)&v55[20] = 1024;
    *(_DWORD *)&v55[22] = 553;
    *(_WORD *)&v55[26] = 2112;
    *(void *)&v55[28] = v5;
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Got power request : %@", buf, 0x2Cu);
  }

  __int16 v28 = [sub_1001AD150() sharedCPMSAgent];
  [v28 acknowledgePowerBudget:v5 forClientId:*(void *)(a1 + 56) error:0];
}

void sub_1001ADCA4()
{
  uint64_t v6 = 0;
  uint64_t v7 = &v6;
  uint64_t v8 = 0x2020000000;
  id v0 = (void **)qword_100347588;
  uint64_t v9 = qword_100347588;
  if (!qword_100347588)
  {
    id v1 = sub_1001B17FC();
    void v7[3] = (uint64_t)dlsym(v1, "kCPMSPowerTimeScaleThermal");
    qword_100347588 = v7[3];
    id v0 = (void **)v7[3];
  }
  _Block_object_dispose(&v6, 8);
  if (v0)
  {
    uint64_t v2 = *v0;
    id v3 = v2;
  }
  else
  {
    uint64_t v4 = +[NSAssertionHandler currentHandler];
    id v5 = +[NSString stringWithUTF8String:"NSString *getkCPMSPowerTimeScaleThermal(void)"];
    [v4 handleFailureInFunction:v5 file:@"NFCoreDuetWrapper.m" lineNumber:36 description:@"%s", dlerror()];

    __break(1u);
  }
}

void sub_1001ADDF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t sub_1001ADE0C(uint64_t val)
{
  if (!val) {
    return val;
  }
  id v1 = (void *)val;
  uint64_t v2 = *(void *)(val + 24);
  if (v2)
  {
    if (*(unsigned char *)(v2 + 16)) {
      uint64_t v3 = 3;
    }
    else {
      uint64_t v3 = 9;
    }
  }
  else
  {
    uint64_t v3 = 9;
  }
  objc_initWeak(&location, (id)val);
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
  if (Logger)
  {
    Class = object_getClass(v1);
    if (class_isMetaClass(Class)) {
      uint64_t v6 = 43;
    }
    else {
      uint64_t v6 = 45;
    }
    ClassName = object_getClassName(v1);
    Name = sel_getName("createCPMSDescription:");
    Logger(6, "%c[%{public}s %{public}s]:%i Using CPMS for client ID 0x%lx (%@)", v6, ClassName, Name, 496, v3, v1);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v9 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    id v10 = object_getClass(v1);
    if (class_isMetaClass(v10)) {
      int v11 = 43;
    }
    else {
      int v11 = 45;
    }
    int v12 = object_getClassName(v1);
    id v13 = sel_getName("createCPMSDescription:");
    *(_DWORD *)long long buf = 67110402;
    *(_DWORD *)&uint8_t buf[4] = v11;
    *(_WORD *)int v115 = 2082;
    *(void *)&v115[2] = v12;
    *(_WORD *)&v115[10] = 2082;
    *(void *)&v115[12] = v13;
    *(_WORD *)&v115[20] = 1024;
    *(_DWORD *)&v115[22] = 496;
    *(_WORD *)&v115[26] = 2048;
    *(void *)&v115[28] = v3;
    __int16 v116 = 2112;
    *(void *)__int16 v117 = v1;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Using CPMS for client ID 0x%lx (%@)", buf, 0x36u);
  }

  int v14 = (void *)v1[6];
  v1[6] = &off_10031D7B8;

  *(void *)__int16 v110 = 0;
  *(void *)__int16 v111 = v110;
  *(void *)&v111[8] = 0x2050000000;
  id v15 = (void *)qword_100347580;
  *(void *)&v111[16] = qword_100347580;
  if (!qword_100347580)
  {
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)int v115 = 3221225472;
    *(void *)&v115[8] = sub_1001B1B58;
    *(void *)&v115[16] = &unk_100301E40;
    *(void *)&v115[24] = v110;
    sub_1001B1B58((uint64_t)buf);
    id v15 = *(void **)(*(void *)v111 + 24);
  }
  int v16 = v15;
  _Block_object_dispose(v110, 8);
  id v17 = objc_alloc_init(v16);
  uint64_t v18 = v17;
  if (!v17)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v25 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v25)
    {
      __int16 v26 = object_getClass(v1);
      if (class_isMetaClass(v26)) {
        uint64_t v27 = 43;
      }
      else {
        uint64_t v27 = 45;
      }
      __int16 v28 = object_getClassName(v1);
      id v29 = sel_getName("createCPMSDescription:");
      v25(3, "%c[%{public}s %{public}s]:%i Failed to create description", v27, v28, v29, 503);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v30 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      uint64_t v31 = object_getClass(v1);
      if (class_isMetaClass(v31)) {
        int v32 = 43;
      }
      else {
        int v32 = 45;
      }
      long long v33 = object_getClassName(v1);
      long long v34 = sel_getName("createCPMSDescription:");
      *(_DWORD *)long long buf = 67109890;
      *(_DWORD *)&uint8_t buf[4] = v32;
      *(_WORD *)int v115 = 2082;
      *(void *)&v115[2] = v33;
      *(_WORD *)&v115[10] = 2082;
      *(void *)&v115[12] = v34;
      *(_WORD *)&v115[20] = 1024;
      *(_DWORD *)&v115[22] = 503;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to create description", buf, 0x22u);
    }
    id v35 = 0;
    goto LABEL_85;
  }
  [v17 setClientId:v3];
  [v18 setIsContinuous:0];
  [v18 setPowerBudgetUpdateMinimumPeriod:1000];
  uint64_t v19 = v1[3];
  if (v19)
  {
    __int16 v20 = 0;
    switch(*(void *)(v19 + 8))
    {
      case 7:
      case 8:
        BOOL v21 = sub_1001ABD60();
        *(void *)__int16 v110 = v21;
        *(void *)long long buf = &off_100322850;
        uint64_t v22 = sub_1001ABEC8();
        *(void *)__int16 v111 = v22;
        *(void *)int v115 = &off_100322868;
        __int16 v23 = sub_1001AC030();
        *(void *)&v111[8] = v23;
        *(void *)&v115[8] = &off_100322880;
        uint64_t v24 = +[NSDictionary dictionaryWithObjects:buf forKeys:v110 count:3];
        goto LABEL_36;
      case 0xALL:
      case 0xBLL:
      case 0xCLL:
      case 0x14:
        BOOL v21 = sub_1001ABD60();
        *(void *)__int16 v110 = v21;
        *(void *)long long buf = &off_100322898;
        uint64_t v22 = sub_1001ABEC8();
        *(void *)__int16 v111 = v22;
        *(void *)int v115 = &off_1003228B0;
        __int16 v23 = sub_1001AC030();
        *(void *)&v111[8] = v23;
        *(void *)&v115[8] = &off_1003228C8;
        uint64_t v24 = +[NSDictionary dictionaryWithObjects:buf forKeys:v110 count:3];
        goto LABEL_36;
      case 0xELL:
      case 0xFLL:
      case 0x10:
      case 0x11:
        BOOL v21 = sub_1001ABD60();
        *(void *)__int16 v110 = v21;
        *(void *)long long buf = &off_1003228E0;
        uint64_t v22 = sub_1001ABEC8();
        *(void *)__int16 v111 = v22;
        *(void *)int v115 = &off_1003228F8;
        __int16 v23 = sub_1001AC030();
        *(void *)&v111[8] = v23;
        *(void *)&v115[8] = &off_100322910;
        uint64_t v24 = +[NSDictionary dictionaryWithObjects:buf forKeys:v110 count:3];
        goto LABEL_36;
      case 0x12:
        BOOL v21 = sub_1001ABD60();
        *(void *)__int16 v110 = v21;
        *(void *)long long buf = &off_100322928;
        uint64_t v22 = sub_1001ABEC8();
        *(void *)__int16 v111 = v22;
        *(void *)int v115 = &off_100322940;
        __int16 v23 = sub_1001AC030();
        *(void *)&v111[8] = v23;
        *(void *)&v115[8] = &off_100322958;
        uint64_t v24 = +[NSDictionary dictionaryWithObjects:buf forKeys:v110 count:3];
LABEL_36:
        __int16 v20 = (void *)v24;

        break;
      default:
        break;
    }
  }
  else
  {
    __int16 v20 = 0;
  }
  [v18 setPowerLevels:v20];

  v107[0] = _NSConcreteStackBlock;
  v107[1] = 3221225472;
  void v107[2] = sub_1001AD58C;
  v107[3] = &unk_1003068D0;
  objc_copyWeak(&v108, &location);
  [v18 setGetCurrentPower:v107];
  *(void *)long long buf = _NSConcreteStackBlock;
  *(void *)int v115 = 3221225472;
  *(void *)&v115[8] = sub_1001AD6BC;
  *(void *)&v115[16] = &unk_1003068F8;
  objc_copyWeak((id *)&v115[32], &location);
  *(void *)&v117[2] = "createCPMSDescription:";
  id v36 = v18;
  *(void *)&v115[24] = v36;
  uint64_t v118 = v3;
  [v36 setNotificationCallback:buf];
  id v37 = [sub_1001AD150() sharedCPMSAgent];
  id v106 = 0;
  unsigned __int8 v38 = [v37 registerClientWithDescription:v36 error:&v106];
  id v30 = v106;

  if ((v38 & 1) == 0)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v59 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v59)
    {
      id v60 = object_getClass(v1);
      if (class_isMetaClass(v60)) {
        uint64_t v61 = 43;
      }
      else {
        uint64_t v61 = 45;
      }
      uint64_t v62 = object_getClassName(v1);
      id v63 = sel_getName("createCPMSDescription:");
      v59(3, "%c[%{public}s %{public}s]:%i Failed to register CPMS : %{public}@", v61, v62, v63, 559, v30);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    NSErrorUserInfoKey v64 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v64, OS_LOG_TYPE_ERROR))
    {
      int v65 = object_getClass(v1);
      if (class_isMetaClass(v65)) {
        int v66 = 43;
      }
      else {
        int v66 = 45;
      }
      uint64_t v67 = object_getClassName(v1);
      id v68 = sel_getName("createCPMSDescription:");
      *(_DWORD *)__int16 v110 = 67110146;
      *(_DWORD *)&void v110[4] = v66;
      *(_WORD *)__int16 v111 = 2082;
      *(void *)&v111[2] = v67;
      *(_WORD *)&v111[10] = 2082;
      *(void *)&v111[12] = v68;
      *(_WORD *)&v111[20] = 1024;
      *(_DWORD *)&v111[22] = 559;
      __int16 v112 = 2114;
      __int16 v113 = v30;
      _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to register CPMS : %{public}@", v110, 0x2Cu);
    }

    id v35 = 0;
    goto LABEL_84;
  }
  __int16 v39 = [sub_1001AD150() sharedCPMSAgent];
  uint64_t v40 = sub_1001AC860((void *)v1[3]);
  id v105 = v30;
  id v41 = [v39 copyPowerBudgetForRequest:v40 forClient:v3 error:&v105];
  uint64_t v42 = v105;

  __int16 v43 = (void *)v1[7];
  v1[7] = v41;

  uint64_t v44 = v1[7];
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  if (v44)
  {
    __int16 v45 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v45)
    {
      __int16 v46 = object_getClass(v1);
      if (class_isMetaClass(v46)) {
        uint64_t v47 = 43;
      }
      else {
        uint64_t v47 = 45;
      }
      __int16 v48 = object_getClassName(v1);
      __int16 v49 = sel_getName("createCPMSDescription:");
      v45(6, "%c[%{public}s %{public}s]:%i Max Power budget is %{public}@", v47, v48, v49, 568, v1[7]);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    BOOL v50 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_71;
    }
    __int16 v51 = object_getClass(v1);
    if (class_isMetaClass(v51)) {
      int v52 = 43;
    }
    else {
      int v52 = 45;
    }
    int v53 = object_getClassName(v1);
    int v54 = sel_getName("createCPMSDescription:");
    uint64_t v55 = v1[7];
    *(_DWORD *)__int16 v110 = 67110146;
    *(_DWORD *)&void v110[4] = v52;
    *(_WORD *)__int16 v111 = 2082;
    *(void *)&v111[2] = v53;
    *(_WORD *)&v111[10] = 2082;
    *(void *)&v111[12] = v54;
    *(_WORD *)&v111[20] = 1024;
    *(_DWORD *)&v111[22] = 568;
    __int16 v112 = 2114;
    __int16 v113 = v55;
    __int16 v56 = "%c[%{public}s %{public}s]:%i Max Power budget is %{public}@";
    id v57 = v50;
    os_log_type_t v58 = OS_LOG_TYPE_DEFAULT;
  }
  else
  {
    id v69 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v69)
    {
      uint64_t v70 = object_getClass(v1);
      if (class_isMetaClass(v70)) {
        uint64_t v71 = 43;
      }
      else {
        uint64_t v71 = 45;
      }
      id v72 = object_getClassName(v1);
      id v73 = sel_getName("createCPMSDescription:");
      v69(3, "%c[%{public}s %{public}s]:%i Error query power budget CPMS : %{public}@", v71, v72, v73, 566, v42);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    BOOL v50 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v50, OS_LOG_TYPE_ERROR)) {
      goto LABEL_71;
    }
    int v74 = object_getClass(v1);
    if (class_isMetaClass(v74)) {
      int v75 = 43;
    }
    else {
      int v75 = 45;
    }
    id v76 = object_getClassName(v1);
    uint64_t v77 = sel_getName("createCPMSDescription:");
    *(_DWORD *)__int16 v110 = 67110146;
    *(_DWORD *)&void v110[4] = v75;
    *(_WORD *)__int16 v111 = 2082;
    *(void *)&v111[2] = v76;
    *(_WORD *)&v111[10] = 2082;
    *(void *)&v111[12] = v77;
    *(_WORD *)&v111[20] = 1024;
    *(_DWORD *)&v111[22] = 566;
    __int16 v112 = 2114;
    __int16 v113 = v42;
    __int16 v56 = "%c[%{public}s %{public}s]:%i Error query power budget CPMS : %{public}@";
    id v57 = v50;
    os_log_type_t v58 = OS_LOG_TYPE_ERROR;
  }
  _os_log_impl((void *)&_mh_execute_header, v57, v58, v56, v110, 0x2Cu);
LABEL_71:

  id v78 = [sub_1001AD150() sharedCPMSAgent];
  uint64_t v79 = sub_1001ABC78(v1[3]);
  __int16 v104 = v42;
  id v80 = [v78 copyPowerBudgetForRequest:v79 forClient:v3 error:&v104];
  id v30 = v104;

  if (!v80)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    long long v81 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
    if (v81)
    {
      NSErrorUserInfoKey v82 = object_getClass(v1);
      if (class_isMetaClass(v82)) {
        uint64_t v83 = 43;
      }
      else {
        uint64_t v83 = 45;
      }
      id v84 = object_getClassName(v1);
      uint64_t v85 = sel_getName("createCPMSDescription:");
      v81(3, "%c[%{public}s %{public}s]:%i Error resetting power budget CPMS : %{public}@", v83, v84, v85, 573, v30);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int8x16_t v86 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
    {
      id v87 = object_getClass(v1);
      if (class_isMetaClass(v87)) {
        int v88 = 43;
      }
      else {
        int v88 = 45;
      }
      uint64_t v89 = object_getClassName(v1);
      NSErrorUserInfoKey v90 = sel_getName("createCPMSDescription:");
      *(_DWORD *)__int16 v110 = 67110146;
      *(_DWORD *)&void v110[4] = v88;
      *(_WORD *)__int16 v111 = 2082;
      *(void *)&v111[2] = v89;
      *(_WORD *)&v111[10] = 2082;
      *(void *)&v111[12] = v90;
      *(_WORD *)&v111[20] = 1024;
      *(_DWORD *)&v111[22] = 573;
      __int16 v112 = 2114;
      __int16 v113 = v30;
      _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error resetting power budget CPMS : %{public}@", v110, 0x2Cu);
    }
  }
  id v35 = v36;
LABEL_84:

  objc_destroyWeak((id *)&v115[32]);
  objc_destroyWeak(&v108);
LABEL_85:

  objc_destroyWeak(&location);
  uint64_t v91 = (void *)v1[2];
  v1[2] = v35;

  if (v1[2]) {
    return 1;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v92 = NFLogGetLogger();
  if (v92)
  {
    NSErrorUserInfoKey v93 = (void (*)(uint64_t, const char *, ...))v92;
    uint64_t v94 = object_getClass(v1);
    BOOL isMetaClass = class_isMetaClass(v94);
    __int16 v96 = object_getClassName(v1);
    int v103 = sel_getName("setupCPMS");
    uint64_t v97 = 45;
    if (isMetaClass) {
      uint64_t v97 = 43;
    }
    v93(3, "%c[%{public}s %{public}s]:%i Failed to create description", v97, v96, v103, 585);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  __int16 v98 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v98, OS_LOG_TYPE_ERROR))
  {
    id v99 = object_getClass(v1);
    if (class_isMetaClass(v99)) {
      int v100 = 43;
    }
    else {
      int v100 = 45;
    }
    __int16 v101 = object_getClassName(v1);
    __int16 v102 = sel_getName("setupCPMS");
    *(_DWORD *)long long buf = 67109890;
    *(_DWORD *)&uint8_t buf[4] = v100;
    *(_WORD *)int v115 = 2082;
    *(void *)&v115[2] = v101;
    *(_WORD *)&v115[10] = 2082;
    *(void *)&v115[12] = v102;
    *(_WORD *)&v115[20] = 1024;
    *(_DWORD *)&v115[22] = 585;
    _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to create description", buf, 0x22u);
  }

  return 0;
}

void sub_1001AEC24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id *a16, id *location, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,id a26,char a27)
{
}

void sub_1001AED00(uint64_t a1, void *a2)
{
  id v4 = a2;
  if (a1)
  {
    objc_storeStrong((id *)(a1 + 24), a2);
    if (!*(void *)(a1 + 16))
    {
      if (sub_1001AD10C(a1)) {
        sub_1001ADE0C(a1);
      }
    }
  }
}

id sub_1001AED74()
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_1001AEE20;
  v2[3] = &unk_100306918;
  v2[4] = self;
  void v2[5] = "stockholmSystemPowerConsumptionMonitor";
  if (qword_100347598 != -1) {
    dispatch_once(&qword_100347598, v2);
  }
  id v0 = (void *)qword_100347590;

  return v0;
}

void sub_1001AEE20(uint64_t a1)
{
  uint64_t v2 = objc_alloc_init(NFSystemPowerConsumptionMonitor);
  uint64_t v3 = (void *)qword_100347590;
  qword_100347590 = (uint64_t)v2;

  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v10 = 45;
    if (isMetaClass) {
      uint64_t v10 = 43;
    }
    v5(6, "%c[%{public}s %{public}s]:%i Stockholm CPMS : %@", v10, ClassName, Name, 615, qword_100347590);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v11 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12)) {
      int v13 = 43;
    }
    else {
      int v13 = 45;
    }
    int v14 = object_getClassName(*(id *)(a1 + 32));
    id v15 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)long long buf = 67110146;
    int v17 = v13;
    __int16 v18 = 2082;
    uint64_t v19 = v14;
    __int16 v20 = 2082;
    BOOL v21 = v15;
    __int16 v22 = 1024;
    int v23 = 615;
    __int16 v24 = 2112;
    uint64_t v25 = qword_100347590;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Stockholm CPMS : %@", buf, 0x2Cu);
  }
}

id sub_1001AEFD0()
{
  v2[0] = _NSConcreteStackBlock;
  v2[1] = 3221225472;
  v2[2] = sub_1001AF07C;
  v2[3] = &unk_100306918;
  v2[4] = self;
  void v2[5] = "furySystemPowerConsumptionMonitor";
  if (qword_1003475A8 != -1) {
    dispatch_once(&qword_1003475A8, v2);
  }
  id v0 = (void *)qword_1003475A0;

  return v0;
}

void sub_1001AF07C(uint64_t a1)
{
  uint64_t v2 = objc_alloc_init(NFSystemPowerConsumptionMonitor);
  uint64_t v3 = (void *)qword_1003475A0;
  qword_1003475A0 = (uint64_t)v2;

  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v5 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v10 = 45;
    if (isMetaClass) {
      uint64_t v10 = 43;
    }
    v5(6, "%c[%{public}s %{public}s]:%i Fury CPMS : %@", v10, ClassName, Name, 627, qword_1003475A0);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v11 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12)) {
      int v13 = 43;
    }
    else {
      int v13 = 45;
    }
    int v14 = object_getClassName(*(id *)(a1 + 32));
    id v15 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)long long buf = 67110146;
    int v17 = v13;
    __int16 v18 = 2082;
    uint64_t v19 = v14;
    __int16 v20 = 2082;
    BOOL v21 = v15;
    __int16 v22 = 1024;
    int v23 = 627;
    __int16 v24 = 2112;
    uint64_t v25 = qword_1003475A0;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Fury CPMS : %@", buf, 0x2Cu);
  }
}

uint64_t sub_1001AF22C(void *a1)
{
  if (!a1) {
    return 0;
  }
  uint64_t v2 = (void *)a1[1];
  if (!v2) {
    return 0;
  }
  id v18 = 0;
  LODWORD(v3) = [v2 activityStoppedWithLevel:&off_10031D7D0 options:0 error:&v18];
  id v4 = v18;
  if (v4) {
    uint64_t v3 = 0;
  }
  else {
    uint64_t v3 = v3;
  }
  if ((v3 & 1) == 0)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v6 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("didEndPaymentActivityForCoreDuet");
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v6(3, "%c[%{public}s %{public}s]:%i Error stopping PPM activity: %{public}@", v9, ClassName, Name, 648, v4);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      int v11 = object_getClass(a1);
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      int v13 = object_getClassName(a1);
      int v14 = sel_getName("didEndPaymentActivityForCoreDuet");
      *(_DWORD *)long long buf = 67110146;
      int v20 = v12;
      __int16 v21 = 2082;
      __int16 v22 = v13;
      __int16 v23 = 2082;
      __int16 v24 = v14;
      __int16 v25 = 1024;
      int v26 = 648;
      __int16 v27 = 2114;
      id v28 = v4;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error stopping PPM activity: %{public}@", buf, 0x2Cu);
    }
  }
  return v3;
}

BOOL sub_1001AF418(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  if (!*(void *)(a1 + 16))
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass((id)a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName((id)a1);
      Name = sel_getName("didEndPaymentActivityForCPMS");
      uint64_t v8 = 45;
      if (isMetaClass) {
        uint64_t v8 = 43;
      }
      v4(3, "%c[%{public}s %{public}s]:%i Error : no CPMS description", v8, ClassName, Name, 663);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = object_getClass((id)a1);
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      *(_DWORD *)long long buf = 67109890;
      *(_DWORD *)uint64_t v47 = v11;
      *(_WORD *)&void v47[4] = 2082;
      *(void *)&v47[6] = object_getClassName((id)a1);
      __int16 v48 = 2082;
      __int16 v49 = sel_getName("didEndPaymentActivityForCPMS");
      __int16 v50 = 1024;
      int v51 = 663;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error : no CPMS description", buf, 0x22u);
    }
    BOOL v12 = 0;
    goto LABEL_42;
  }
  uint64_t v2 = *(void **)(a1 + 24);
  if (*(unsigned char *)(a1 + 40)) {
    sub_1001AC198(v2);
  }
  else {
  int v13 = sub_1001ABC78((uint64_t)v2);
  }
  int v14 = NFSharedSignpostLog();
  if (os_signpost_enabled(v14))
  {
    *(_DWORD *)long long buf = 138412290;
    *(void *)uint64_t v47 = v13;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CPMS_REQUEST", "%@", buf, 0xCu);
  }

  id v15 = [sub_1001AD150() sharedCPMSAgent];
  id v45 = 0;
  id v16 = [v15 copyPowerBudgetForRequest:v13 forClient:3 error:&v45];
  uint64_t v9 = v45;

  if (!v16 || v9)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v29 = NFLogGetLogger();
    if (v29)
    {
      id v30 = (void (*)(uint64_t, const char *, ...))v29;
      uint64_t v31 = object_getClass((id)a1);
      BOOL v32 = class_isMetaClass(v31);
      uint64_t v40 = object_getClassName((id)a1);
      __int16 v43 = sel_getName("didEndPaymentActivityForCPMS");
      uint64_t v33 = 45;
      if (v32) {
        uint64_t v33 = 43;
      }
      v30(3, "%c[%{public}s %{public}s]:%i Failed to get power budget: error: %{public}@", v33, v40, v43, 678, v9);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v23 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      goto LABEL_40;
    }
    long long v34 = object_getClass((id)a1);
    if (class_isMetaClass(v34)) {
      int v35 = 43;
    }
    else {
      int v35 = 45;
    }
    id v36 = object_getClassName((id)a1);
    id v37 = sel_getName("didEndPaymentActivityForCPMS");
    *(_DWORD *)long long buf = 67110146;
    *(_DWORD *)uint64_t v47 = v35;
    *(_WORD *)&void v47[4] = 2082;
    *(void *)&v47[6] = v36;
    __int16 v48 = 2082;
    __int16 v49 = v37;
    __int16 v50 = 1024;
    int v51 = 678;
    __int16 v52 = 2114;
    int v53 = v9;
    id v28 = "%c[%{public}s %{public}s]:%i Failed to get power budget: error: %{public}@";
    goto LABEL_39;
  }
  int v17 = [sub_1001AD150() sharedCPMSAgent];
  id v44 = 0;
  [v17 acknowledgePowerBudget:v16 forClientId:3 error:&v44];
  uint64_t v9 = v44;

  if (v9)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v18 = NFLogGetLogger();
    if (v18)
    {
      uint64_t v19 = (void (*)(uint64_t, const char *, ...))v18;
      int v20 = object_getClass((id)a1);
      BOOL v21 = class_isMetaClass(v20);
      __int16 v39 = object_getClassName((id)a1);
      uint64_t v42 = sel_getName("didEndPaymentActivityForCPMS");
      uint64_t v22 = 45;
      if (v21) {
        uint64_t v22 = 43;
      }
      v19(3, "%c[%{public}s %{public}s]:%i Failed to acknowledge budget: error: %{public}@", v22, v39, v42, 674, v9);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v23 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      goto LABEL_40;
    }
    __int16 v24 = object_getClass((id)a1);
    if (class_isMetaClass(v24)) {
      int v25 = 43;
    }
    else {
      int v25 = 45;
    }
    int v26 = object_getClassName((id)a1);
    __int16 v27 = sel_getName("didEndPaymentActivityForCPMS");
    *(_DWORD *)long long buf = 67110146;
    *(_DWORD *)uint64_t v47 = v25;
    *(_WORD *)&void v47[4] = 2082;
    *(void *)&v47[6] = v26;
    __int16 v48 = 2082;
    __int16 v49 = v27;
    __int16 v50 = 1024;
    int v51 = 674;
    __int16 v52 = 2114;
    int v53 = v9;
    id v28 = "%c[%{public}s %{public}s]:%i Failed to acknowledge budget: error: %{public}@";
LABEL_39:
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, v28, buf, 0x2Cu);
LABEL_40:
  }
  BOOL v12 = v9 == 0;

LABEL_42:
  return v12;
}

uint64_t sub_1001AF914(uint64_t result)
{
  if (result)
  {
    id v1 = (void *)result;
    if (*(unsigned char *)(result + 41))
    {
      *(unsigned char *)(result + 41) = 0;
      if (sub_1001AD10C(result))
      {
        return sub_1001AF418((uint64_t)v1);
      }
      else
      {
        return sub_1001AF22C(v1);
      }
    }
    else
    {
      return 1;
    }
  }
  return result;
}

uint64_t sub_1001AF994(void *a1)
{
  if (!a1 || !a1[1]) {
    return 0;
  }
  v20[0] = _NSConcreteStackBlock;
  v20[1] = 3221225472;
  v20[2] = sub_1001AFBE8;
  v20[3] = &unk_100306940;
  void v20[4] = a1;
  v20[5] = "willStartPaymentActivityForCoreDuet";
  uint64_t v2 = objc_retainBlock(v20);
  uint64_t v3 = (void *)a1[1];
  id v19 = 0;
  LODWORD(v4) = [v3 admissionCheckWithLevel:&off_10031D7D0 options:0 error:&v19 handler:v2];
  id v5 = v19;
  if (v5) {
    uint64_t v4 = 0;
  }
  else {
    uint64_t v4 = v4;
  }
  if ((v4 & 1) == 0)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v7 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(a1);
      Name = sel_getName("willStartPaymentActivityForCoreDuet");
      uint64_t v10 = 45;
      if (isMetaClass) {
        uint64_t v10 = 43;
      }
      v7(3, "%c[%{public}s %{public}s]:%i Error starting PPM activity: %{public}@", v10, ClassName, Name, 727, v5);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v11 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      BOOL v12 = object_getClass(a1);
      if (class_isMetaClass(v12)) {
        int v13 = 43;
      }
      else {
        int v13 = 45;
      }
      int v14 = object_getClassName(a1);
      id v15 = sel_getName("willStartPaymentActivityForCoreDuet");
      *(_DWORD *)long long buf = 67110146;
      int v22 = v13;
      __int16 v23 = 2082;
      __int16 v24 = v14;
      __int16 v25 = 2082;
      int v26 = v15;
      __int16 v27 = 1024;
      int v28 = 727;
      __int16 v29 = 2114;
      id v30 = v5;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error starting PPM activity: %{public}@", buf, 0x2Cu);
    }
  }
  return v4;
}

void sub_1001AFBE8(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  uint64_t v7 = (void (*)(uint64_t, const char *, ...))Logger;
  if (a2 == 1)
  {
    if (Logger)
    {
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v11 = 45;
      if (isMetaClass) {
        uint64_t v11 = 43;
      }
      v7(6, "%c[%{public}s %{public}s]:%i started", v11, ClassName, Name, 714);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    BOOL v12 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v13)) {
        int v14 = 43;
      }
      else {
        int v14 = 45;
      }
      id v15 = object_getClassName(*(id *)(a1 + 32));
      id v16 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)long long buf = 67109890;
      int v32 = v14;
      __int16 v33 = 2082;
      long long v34 = v15;
      __int16 v35 = 2082;
      id v36 = v16;
      __int16 v37 = 1024;
      int v38 = 714;
      int v17 = "%c[%{public}s %{public}s]:%i started";
      uint64_t v18 = v12;
      os_log_type_t v19 = OS_LOG_TYPE_DEFAULT;
      uint32_t v20 = 34;
LABEL_20:
      _os_log_impl((void *)&_mh_execute_header, v18, v19, v17, buf, v20);
    }
  }
  else
  {
    if (Logger)
    {
      BOOL v21 = object_getClass(*(id *)(a1 + 32));
      BOOL v22 = class_isMetaClass(v21);
      int v28 = object_getClassName(*(id *)(a1 + 32));
      id v30 = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v23 = 45;
      if (v22) {
        uint64_t v23 = 43;
      }
      v7(3, "%c[%{public}s %{public}s]:%i PPM refuses to start activity: %{public}@", v23, v28, v30, 712, v5);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    BOOL v12 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      __int16 v24 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v24)) {
        int v25 = 43;
      }
      else {
        int v25 = 45;
      }
      int v26 = object_getClassName(*(id *)(a1 + 32));
      __int16 v27 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)long long buf = 67110146;
      int v32 = v25;
      __int16 v33 = 2082;
      long long v34 = v26;
      __int16 v35 = 2082;
      id v36 = v27;
      __int16 v37 = 1024;
      int v38 = 712;
      __int16 v39 = 2114;
      id v40 = v5;
      int v17 = "%c[%{public}s %{public}s]:%i PPM refuses to start activity: %{public}@";
      uint64_t v18 = v12;
      os_log_type_t v19 = OS_LOG_TYPE_ERROR;
      uint32_t v20 = 44;
      goto LABEL_20;
    }
  }
}

BOOL sub_1001AFE88(uint64_t a1)
{
  if (!a1) {
    return 0;
  }
  if (!*(void *)(a1 + 16))
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v4 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass((id)a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName((id)a1);
      Name = sel_getName("willStartPaymentActivityForCPMS");
      uint64_t v8 = 45;
      if (isMetaClass) {
        uint64_t v8 = 43;
      }
      v4(3, "%c[%{public}s %{public}s]:%i Error : no CPMS description", v8, ClassName, Name, 743);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      uint64_t v10 = object_getClass((id)a1);
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      *(_DWORD *)long long buf = 67109890;
      *(_DWORD *)uint64_t v47 = v11;
      *(_WORD *)&void v47[4] = 2082;
      *(void *)&v47[6] = object_getClassName((id)a1);
      __int16 v48 = 2082;
      __int16 v49 = sel_getName("willStartPaymentActivityForCPMS");
      __int16 v50 = 1024;
      int v51 = 743;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error : no CPMS description", buf, 0x22u);
    }
    BOOL v12 = 0;
    goto LABEL_42;
  }
  uint64_t v2 = *(void **)(a1 + 24);
  if (*(unsigned char *)(a1 + 40)) {
    sub_1001AC860(v2);
  }
  else {
  int v13 = sub_1001AC4F4(v2);
  }
  int v14 = NFSharedSignpostLog();
  if (os_signpost_enabled(v14))
  {
    *(_DWORD *)long long buf = 138412290;
    *(void *)uint64_t v47 = v13;
    _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v14, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CPMS_REQUEST", "%@", buf, 0xCu);
  }

  id v15 = [sub_1001AD150() sharedCPMSAgent];
  id v45 = 0;
  id v16 = [v15 copyPowerBudgetForRequest:v13 forClient:3 error:&v45];
  uint64_t v9 = v45;

  if (!v16 || v9)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v29 = NFLogGetLogger();
    if (v29)
    {
      id v30 = (void (*)(uint64_t, const char *, ...))v29;
      uint64_t v31 = object_getClass((id)a1);
      BOOL v32 = class_isMetaClass(v31);
      id v40 = object_getClassName((id)a1);
      __int16 v43 = sel_getName("willStartPaymentActivityForCPMS");
      uint64_t v33 = 45;
      if (v32) {
        uint64_t v33 = 43;
      }
      v30(3, "%c[%{public}s %{public}s]:%i Failed to get power budget: error: %{public}@", v33, v40, v43, 758, v9);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v23 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      goto LABEL_40;
    }
    long long v34 = object_getClass((id)a1);
    if (class_isMetaClass(v34)) {
      int v35 = 43;
    }
    else {
      int v35 = 45;
    }
    id v36 = object_getClassName((id)a1);
    __int16 v37 = sel_getName("willStartPaymentActivityForCPMS");
    *(_DWORD *)long long buf = 67110146;
    *(_DWORD *)uint64_t v47 = v35;
    *(_WORD *)&void v47[4] = 2082;
    *(void *)&v47[6] = v36;
    __int16 v48 = 2082;
    __int16 v49 = v37;
    __int16 v50 = 1024;
    int v51 = 758;
    __int16 v52 = 2114;
    int v53 = v9;
    int v28 = "%c[%{public}s %{public}s]:%i Failed to get power budget: error: %{public}@";
    goto LABEL_39;
  }
  int v17 = [sub_1001AD150() sharedCPMSAgent];
  id v44 = 0;
  [v17 acknowledgePowerBudget:v16 forClientId:3 error:&v44];
  uint64_t v9 = v44;

  if (v9)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v18 = NFLogGetLogger();
    if (v18)
    {
      os_log_type_t v19 = (void (*)(uint64_t, const char *, ...))v18;
      uint32_t v20 = object_getClass((id)a1);
      BOOL v21 = class_isMetaClass(v20);
      __int16 v39 = object_getClassName((id)a1);
      uint64_t v42 = sel_getName("willStartPaymentActivityForCPMS");
      uint64_t v22 = 45;
      if (v21) {
        uint64_t v22 = 43;
      }
      v19(3, "%c[%{public}s %{public}s]:%i Failed to acknowledge budget: error: %{public}@", v22, v39, v42, 754, v9);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v23 = NFSharedLogGetLogger();
    if (!os_log_type_enabled(v23, OS_LOG_TYPE_ERROR)) {
      goto LABEL_40;
    }
    __int16 v24 = object_getClass((id)a1);
    if (class_isMetaClass(v24)) {
      int v25 = 43;
    }
    else {
      int v25 = 45;
    }
    int v26 = object_getClassName((id)a1);
    __int16 v27 = sel_getName("willStartPaymentActivityForCPMS");
    *(_DWORD *)long long buf = 67110146;
    *(_DWORD *)uint64_t v47 = v25;
    *(_WORD *)&void v47[4] = 2082;
    *(void *)&v47[6] = v26;
    __int16 v48 = 2082;
    __int16 v49 = v27;
    __int16 v50 = 1024;
    int v51 = 754;
    __int16 v52 = 2114;
    int v53 = v9;
    int v28 = "%c[%{public}s %{public}s]:%i Failed to acknowledge budget: error: %{public}@";
LABEL_39:
    _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, v28, buf, 0x2Cu);
LABEL_40:
  }
  BOOL v12 = v9 == 0;

LABEL_42:
  return v12;
}

uint64_t sub_1001B0384(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    if (*(unsigned char *)(result + 41)) {
      return 1;
    }
    if (sub_1001AD10C(result))
    {
      if (!sub_1001AFE88(v1)) {
        return 0;
      }
    }
    else
    {
      uint64_t result = sub_1001AF994((void *)v1);
      if (!result) {
        return result;
      }
    }
    uint64_t result = 1;
    *(unsigned char *)(v1 + 41) = 1;
  }
  return result;
}

uint64_t sub_1001B03F0(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = v3;
  if (a1)
  {
    if (*(unsigned char *)(a1 + 40))
    {
      if (v3)
      {
        id v5 = *(id *)(a1 + 32);
        objc_sync_enter(v5);
        [*(id *)(a1 + 32) removeObject:v4];
        objc_sync_exit(v5);
      }
      if (!sub_1001AD10C(a1))
      {
        int v17 = *(void **)(a1 + 8);
        if (v17)
        {
          id v67 = 0;
          LODWORD(v16) = [v17 activityStoppedWithLevel:&off_10031D7E8 options:0 error:&v67];
          uint64_t v18 = v67;
          if (v18) {
            uint64_t v16 = 0;
          }
          else {
            uint64_t v16 = v16;
          }
          if ((v16 & 1) == 0)
          {
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            uint64_t Logger = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
            if (Logger)
            {
              Class = object_getClass((id)a1);
              if (class_isMetaClass(Class)) {
                uint64_t v21 = 43;
              }
              else {
                uint64_t v21 = 45;
              }
              ClassName = object_getClassName((id)a1);
              Name = sel_getName("didEndReaderActivityForCoreDuet");
              Logger(3, "%c[%{public}s %{public}s]:%i Error stopping PPM activity: %{public}@", v21, ClassName, Name, 805, v18);
            }
            dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
            __int16 v24 = NFSharedLogGetLogger();
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            {
              int v25 = object_getClass((id)a1);
              if (class_isMetaClass(v25)) {
                int v26 = 43;
              }
              else {
                int v26 = 45;
              }
              __int16 v27 = object_getClassName((id)a1);
              int v28 = sel_getName("didEndReaderActivityForCoreDuet");
              *(_DWORD *)long long buf = 67110146;
              *(_DWORD *)id v69 = v26;
              *(_WORD *)&void v69[4] = 2082;
              *(void *)&v69[6] = v27;
              __int16 v70 = 2082;
              uint64_t v71 = v28;
              __int16 v72 = 1024;
              int v73 = 805;
              __int16 v74 = 2114;
              int v75 = v18;
              _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error stopping PPM activity: %{public}@", buf, 0x2Cu);
            }
          }
        }
        else
        {
          uint64_t v16 = 0;
        }
        goto LABEL_78;
      }
      if (!*(void *)(a1 + 16))
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v29 = NFLogGetLogger();
        if (v29)
        {
          id v30 = (void (*)(uint64_t, const char *, ...))v29;
          uint64_t v31 = object_getClass((id)a1);
          BOOL isMetaClass = class_isMetaClass(v31);
          uint64_t v33 = object_getClassName((id)a1);
          int v65 = sel_getName("didEndReaderActivityForCPMS");
          uint64_t v34 = 45;
          if (isMetaClass) {
            uint64_t v34 = 43;
          }
          v30(3, "%c[%{public}s %{public}s]:%i Error : no CPMS description", v34, v33, v65, 821);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v35 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_ERROR))
        {
          id v36 = object_getClass((id)a1);
          if (class_isMetaClass(v36)) {
            int v37 = 43;
          }
          else {
            int v37 = 45;
          }
          *(_DWORD *)long long buf = 67109890;
          *(_DWORD *)id v69 = v37;
          *(_WORD *)&void v69[4] = 2082;
          *(void *)&v69[6] = object_getClassName((id)a1);
          __int16 v70 = 2082;
          uint64_t v71 = sel_getName("didEndReaderActivityForCPMS");
          __int16 v72 = 1024;
          int v73 = 821;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error : no CPMS description", buf, 0x22u);
        }
        uint64_t v16 = 0;
        goto LABEL_77;
      }
      uint64_t v6 = *(void **)(a1 + 24);
      if (*(unsigned char *)(a1 + 41)) {
        sub_1001AC4F4(v6);
      }
      else {
      int v38 = sub_1001ABC78((uint64_t)v6);
      }
      __int16 v39 = NFSharedSignpostLog();
      if (os_signpost_enabled(v39))
      {
        *(_DWORD *)long long buf = 138412290;
        *(void *)id v69 = v38;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v39, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CPMS_REQUEST", "%@", buf, 0xCu);
      }

      id v40 = [sub_1001AD150() sharedCPMSAgent];
      id v67 = 0;
      id v41 = [v40 copyPowerBudgetForRequest:v38 forClient:3 error:&v67];
      int v35 = v67;

      if (!v41 || v35)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        int v54 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v54)
        {
          uint64_t v55 = object_getClass((id)a1);
          if (class_isMetaClass(v55)) {
            uint64_t v56 = 43;
          }
          else {
            uint64_t v56 = 45;
          }
          id v57 = object_getClassName((id)a1);
          os_log_type_t v58 = sel_getName("didEndReaderActivityForCPMS");
          v54(3, "%c[%{public}s %{public}s]:%i Failed to get power budget: error: %{public}@", v56, v57, v58, 836, v35);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        __int16 v48 = NFSharedLogGetLogger();
        if (!os_log_type_enabled(v48, OS_LOG_TYPE_ERROR)) {
          goto LABEL_75;
        }
        uint64_t v59 = object_getClass((id)a1);
        if (class_isMetaClass(v59)) {
          int v60 = 43;
        }
        else {
          int v60 = 45;
        }
        uint64_t v61 = object_getClassName((id)a1);
        uint64_t v62 = sel_getName("didEndReaderActivityForCPMS");
        *(_DWORD *)long long buf = 67110146;
        *(_DWORD *)id v69 = v60;
        *(_WORD *)&void v69[4] = 2082;
        *(void *)&v69[6] = v61;
        __int16 v70 = 2082;
        uint64_t v71 = v62;
        __int16 v72 = 1024;
        int v73 = 836;
        __int16 v74 = 2114;
        int v75 = v35;
        int v53 = "%c[%{public}s %{public}s]:%i Failed to get power budget: error: %{public}@";
      }
      else
      {
        uint64_t v42 = [sub_1001AD150() sharedCPMSAgent];
        id v66 = 0;
        [v42 acknowledgePowerBudget:v41 forClientId:3 error:&v66];
        int v35 = v66;

        if (!v35)
        {
LABEL_76:
          uint64_t v16 = v35 == 0;

LABEL_77:
LABEL_78:
          *(unsigned char *)(a1 + 40) = 0;
          goto LABEL_79;
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        __int16 v43 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
        if (v43)
        {
          id v44 = object_getClass((id)a1);
          if (class_isMetaClass(v44)) {
            uint64_t v45 = 43;
          }
          else {
            uint64_t v45 = 45;
          }
          __int16 v46 = object_getClassName((id)a1);
          uint64_t v47 = sel_getName("didEndReaderActivityForCPMS");
          v43(3, "%c[%{public}s %{public}s]:%i Failed to acknowledge budget: error: %{public}@", v45, v46, v47, 832, v35);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        __int16 v48 = NFSharedLogGetLogger();
        if (!os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
        {
LABEL_75:

          goto LABEL_76;
        }
        __int16 v49 = object_getClass((id)a1);
        if (class_isMetaClass(v49)) {
          int v50 = 43;
        }
        else {
          int v50 = 45;
        }
        int v51 = object_getClassName((id)a1);
        __int16 v52 = sel_getName("didEndReaderActivityForCPMS");
        *(_DWORD *)long long buf = 67110146;
        *(_DWORD *)id v69 = v50;
        *(_WORD *)&void v69[4] = 2082;
        *(void *)&v69[6] = v51;
        __int16 v70 = 2082;
        uint64_t v71 = v52;
        __int16 v72 = 1024;
        int v73 = 832;
        __int16 v74 = 2114;
        int v75 = v35;
        int v53 = "%c[%{public}s %{public}s]:%i Failed to acknowledge budget: error: %{public}@";
      }
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, v53, buf, 0x2Cu);
      goto LABEL_75;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v7 = NFLogGetLogger();
    if (v7)
    {
      uint64_t v8 = (void (*)(uint64_t, const char *, ...))v7;
      uint64_t v9 = object_getClass((id)a1);
      BOOL v10 = class_isMetaClass(v9);
      int v11 = object_getClassName((id)a1);
      NSErrorUserInfoKey v64 = sel_getName("didEndReaderActivityWithDelegate:");
      uint64_t v12 = 45;
      if (v10) {
        uint64_t v12 = 43;
      }
      v8(6, "%c[%{public}s %{public}s]:%i Reader activity not started", v12, v11, v64, 850);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v13 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      int v14 = object_getClass((id)a1);
      if (class_isMetaClass(v14)) {
        int v15 = 43;
      }
      else {
        int v15 = 45;
      }
      *(_DWORD *)long long buf = 67109890;
      *(_DWORD *)id v69 = v15;
      *(_WORD *)&void v69[4] = 2082;
      *(void *)&v69[6] = object_getClassName((id)a1);
      __int16 v70 = 2082;
      uint64_t v71 = sel_getName("didEndReaderActivityWithDelegate:");
      __int16 v72 = 1024;
      int v73 = 850;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Reader activity not started", buf, 0x22u);
    }
  }
  uint64_t v16 = 0;
LABEL_79:

  return v16;
}

void sub_1001B0BCC(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1001B0BE8(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  uint64_t v7 = (void (*)(uint64_t, const char *, ...))Logger;
  if (a2 == 1)
  {
    if (Logger)
    {
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v11 = 45;
      if (isMetaClass) {
        uint64_t v11 = 43;
      }
      v7(6, "%c[%{public}s %{public}s]:%i acitvity started", v11, ClassName, Name, 884);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v12 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v13)) {
        int v14 = 43;
      }
      else {
        int v14 = 45;
      }
      int v15 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v16 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)long long buf = 67109890;
      int v32 = v14;
      __int16 v33 = 2082;
      uint64_t v34 = v15;
      __int16 v35 = 2082;
      id v36 = v16;
      __int16 v37 = 1024;
      int v38 = 884;
      int v17 = "%c[%{public}s %{public}s]:%i acitvity started";
      uint64_t v18 = v12;
      os_log_type_t v19 = OS_LOG_TYPE_DEFAULT;
      uint32_t v20 = 34;
LABEL_20:
      _os_log_impl((void *)&_mh_execute_header, v18, v19, v17, buf, v20);
    }
  }
  else
  {
    if (Logger)
    {
      uint64_t v21 = object_getClass(*(id *)(a1 + 32));
      BOOL v22 = class_isMetaClass(v21);
      int v28 = object_getClassName(*(id *)(a1 + 32));
      id v30 = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v23 = 45;
      if (v22) {
        uint64_t v23 = 43;
      }
      v7(3, "%c[%{public}s %{public}s]:%i PPM refuses to start activity: %{public}@", v23, v28, v30, 881, v5);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v12 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      __int16 v24 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v24)) {
        int v25 = 43;
      }
      else {
        int v25 = 45;
      }
      int v26 = object_getClassName(*(id *)(a1 + 32));
      __int16 v27 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)long long buf = 67110146;
      int v32 = v25;
      __int16 v33 = 2082;
      uint64_t v34 = v26;
      __int16 v35 = 2082;
      id v36 = v27;
      __int16 v37 = 1024;
      int v38 = 881;
      __int16 v39 = 2114;
      id v40 = v5;
      int v17 = "%c[%{public}s %{public}s]:%i PPM refuses to start activity: %{public}@";
      uint64_t v18 = v12;
      os_log_type_t v19 = OS_LOG_TYPE_ERROR;
      uint32_t v20 = 44;
      goto LABEL_20;
    }
  }
}

uint64_t sub_1001B0E88(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (!a1)
  {
    uint64_t v13 = 0;
    goto LABEL_77;
  }
  if (*(unsigned char *)(a1 + 40))
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass((id)a1);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName((id)a1);
      Name = sel_getName("willStartReaderActivityWithDelegate:");
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v5(6, "%c[%{public}s %{public}s]:%i Reader activity already started", v9, ClassName, Name, 943);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    BOOL v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v11 = object_getClass((id)a1);
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      *(_DWORD *)long long buf = 67109890;
      *(_DWORD *)&uint8_t buf[4] = v12;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = object_getClassName((id)a1);
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = sel_getName("willStartReaderActivityWithDelegate:");
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 943;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Reader activity already started", buf, 0x22u);
    }

    goto LABEL_13;
  }
  *(unsigned char *)(a1 + 40) = 1;
  id v14 = *(id *)(a1 + 32);
  objc_sync_enter(v14);
  [*(id *)(a1 + 32) addObject:v3];
  objc_sync_exit(v14);

  if (sub_1001AD10C(a1))
  {
    if (!*(void *)(a1 + 16))
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v21 = NFLogGetLogger();
      if (v21)
      {
        BOOL v22 = (void (*)(uint64_t, const char *, ...))v21;
        uint64_t v23 = object_getClass((id)a1);
        BOOL v24 = class_isMetaClass(v23);
        int v25 = object_getClassName((id)a1);
        __int16 v70 = sel_getName("willStartReaderActivityForCPMS");
        uint64_t v26 = 45;
        if (v24) {
          uint64_t v26 = 43;
        }
        v22(3, "%c[%{public}s %{public}s]:%i Error : no CPMS description", v26, v25, v70, 913);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v27 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        int v28 = object_getClass((id)a1);
        if (class_isMetaClass(v28)) {
          int v29 = 43;
        }
        else {
          int v29 = 45;
        }
        *(_DWORD *)long long buf = 67109890;
        *(_DWORD *)&uint8_t buf[4] = v29;
        *(_WORD *)&uint8_t buf[8] = 2082;
        *(void *)&buf[10] = object_getClassName((id)a1);
        *(_WORD *)&buf[18] = 2082;
        *(void *)&buf[20] = sel_getName("willStartReaderActivityForCPMS");
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = 913;
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error : no CPMS description", buf, 0x22u);
      }

      goto LABEL_74;
    }
    int v15 = *(void **)(a1 + 24);
    if (*(unsigned char *)(a1 + 41)) {
      sub_1001AC860(v15);
    }
    else {
    id v41 = sub_1001AC198(v15);
    }
    uint64_t v42 = NFSharedSignpostLog();
    if (os_signpost_enabled(v42))
    {
      *(_DWORD *)long long buf = 138412290;
      *(void *)&uint8_t buf[4] = v41;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v42, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "CPMS_REQUEST", "%@", buf, 0xCu);
    }

    __int16 v43 = [sub_1001AD150() sharedCPMSAgent];
    *(void *)__int16 v72 = 0;
    id v44 = [v43 copyPowerBudgetForRequest:v41 forClient:3 error:v72];
    id v45 = *(id *)v72;

    if (!v44 || v45)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      os_log_type_t v58 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v58)
      {
        uint64_t v59 = object_getClass((id)a1);
        if (class_isMetaClass(v59)) {
          uint64_t v60 = 43;
        }
        else {
          uint64_t v60 = 45;
        }
        uint64_t v61 = object_getClassName((id)a1);
        uint64_t v62 = sel_getName("willStartReaderActivityForCPMS");
        v58(3, "%c[%{public}s %{public}s]:%i Failed to get power budget: error: %{public}@", v60, v61, v62, 928, v45);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v52 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v52, OS_LOG_TYPE_ERROR)) {
        goto LABEL_72;
      }
      id v63 = object_getClass((id)a1);
      if (class_isMetaClass(v63)) {
        int v64 = 43;
      }
      else {
        int v64 = 45;
      }
      int v65 = object_getClassName((id)a1);
      id v66 = sel_getName("willStartReaderActivityForCPMS");
      *(_DWORD *)long long buf = 67110146;
      *(_DWORD *)&uint8_t buf[4] = v64;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = v65;
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = v66;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 928;
      *(_WORD *)&buf[34] = 2114;
      *(void *)&buf[36] = v45;
      id v57 = "%c[%{public}s %{public}s]:%i Failed to get power budget: error: %{public}@";
    }
    else
    {
      __int16 v46 = [sub_1001AD150() sharedCPMSAgent];
      id v71 = 0;
      [v46 acknowledgePowerBudget:v44 forClientId:3 error:&v71];
      id v45 = v71;

      if (!v45) {
        goto LABEL_73;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v47 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v47)
      {
        __int16 v48 = object_getClass((id)a1);
        if (class_isMetaClass(v48)) {
          uint64_t v49 = 43;
        }
        else {
          uint64_t v49 = 45;
        }
        int v50 = object_getClassName((id)a1);
        int v51 = sel_getName("willStartReaderActivityForCPMS");
        v47(3, "%c[%{public}s %{public}s]:%i Failed to acknowledge budget: error: %{public}@", v49, v50, v51, 924, v45);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      __int16 v52 = NFSharedLogGetLogger();
      if (!os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
      {
LABEL_72:

LABEL_73:
        if (v45) {
          goto LABEL_74;
        }
LABEL_13:
        uint64_t v13 = 1;
        goto LABEL_77;
      }
      int v53 = object_getClass((id)a1);
      if (class_isMetaClass(v53)) {
        int v54 = 43;
      }
      else {
        int v54 = 45;
      }
      uint64_t v55 = object_getClassName((id)a1);
      uint64_t v56 = sel_getName("willStartReaderActivityForCPMS");
      *(_DWORD *)long long buf = 67110146;
      *(_DWORD *)&uint8_t buf[4] = v54;
      *(_WORD *)&uint8_t buf[8] = 2082;
      *(void *)&buf[10] = v55;
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = v56;
      *(_WORD *)&buf[28] = 1024;
      *(_DWORD *)&buf[30] = 924;
      *(_WORD *)&buf[34] = 2114;
      *(void *)&buf[36] = v45;
      id v57 = "%c[%{public}s %{public}s]:%i Failed to acknowledge budget: error: %{public}@";
    }
    _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_ERROR, v57, buf, 0x2Cu);
    goto LABEL_72;
  }
  if (*(void *)(a1 + 8))
  {
    *(void *)long long buf = _NSConcreteStackBlock;
    *(void *)&uint8_t buf[8] = 3221225472;
    *(void *)&uint8_t buf[16] = sub_1001B0BE8;
    *(void *)&buf[24] = &unk_100306940;
    *(void *)&buf[32] = a1;
    *(void *)&buf[40] = "willStartReaderActivityForCoreDuet";
    uint64_t v16 = objc_retainBlock(buf);
    int v17 = *(void **)(a1 + 8);
    id v71 = 0;
    unsigned __int8 v18 = [v17 admissionCheckWithLevel:&off_10031D7E8 options:0 error:&v71 handler:v16];
    id v19 = v71;
    if (v19) {
      unsigned __int8 v20 = 0;
    }
    else {
      unsigned __int8 v20 = v18;
    }
    if ((v20 & 1) == 0)
    {
      id v30 = v19;
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v31 = (void (*)(uint64_t, const char *, ...))NFLogGetLogger();
      if (v31)
      {
        int v32 = object_getClass((id)a1);
        if (class_isMetaClass(v32)) {
          uint64_t v33 = 43;
        }
        else {
          uint64_t v33 = 45;
        }
        uint64_t v34 = object_getClassName((id)a1);
        __int16 v35 = sel_getName("willStartReaderActivityForCoreDuet");
        v31(3, "%c[%{public}s %{public}s]:%i Error starting PPM activity: %{public}@", v33, v34, v35, 897, v30);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      id v36 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        __int16 v37 = object_getClass((id)a1);
        if (class_isMetaClass(v37)) {
          int v38 = 43;
        }
        else {
          int v38 = 45;
        }
        __int16 v39 = object_getClassName((id)a1);
        id v40 = sel_getName("willStartReaderActivityForCoreDuet");
        *(_DWORD *)__int16 v72 = 67110146;
        *(_DWORD *)&void v72[4] = v38;
        __int16 v73 = 2082;
        __int16 v74 = v39;
        __int16 v75 = 2082;
        id v76 = v40;
        __int16 v77 = 1024;
        int v78 = 897;
        __int16 v79 = 2114;
        id v80 = v30;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error starting PPM activity: %{public}@", v72, 0x2Cu);
      }

      goto LABEL_74;
    }

    goto LABEL_13;
  }
LABEL_74:
  if (v3)
  {
    id v67 = *(id *)(a1 + 32);
    objc_sync_enter(v67);
    [*(id *)(a1 + 32) removeObject:v3];
    objc_sync_exit(v67);
  }
  uint64_t v13 = 0;
  *(unsigned char *)(a1 + 40) = 0;
LABEL_77:

  return v13;
}

void sub_1001B1704(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void *sub_1001B17AC(uint64_t a1)
{
  uint64_t v2 = sub_1001B17FC();
  uint64_t result = dlsym(v2, "kCPMSPowerTimeScaleInstantaneous");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  qword_100347560 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *sub_1001B17FC()
{
  uint64_t v0 = sub_1001B18AC();
  if (v0) {
    return (void *)v0;
  }
  uint64_t v1 = +[NSAssertionHandler currentHandler];
  id v3 = +[NSString stringWithUTF8String:"void *CPMSLibrary(void)"];
  [v1 handleFailureInFunction:v3 file:@"NFCoreDuetWrapper.m" lineNumber:30 description:@"%s"];

  __break(1u);
  free(v4);
  return v1;
}

uint64_t sub_1001B18AC()
{
  if (!qword_100347748) {
    qword_100347748 = _sl_dlopen();
  }
  return qword_100347748;
}

uint64_t sub_1001B197C()
{
  uint64_t result = _sl_dlopen();
  qword_100347748 = result;
  return result;
}

void *sub_1001B19F0(uint64_t a1)
{
  uint64_t v2 = sub_1001B17FC();
  uint64_t result = dlsym(v2, "kCPMSPowerTimeScale100ms");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  qword_100347568 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void *sub_1001B1A40(uint64_t a1)
{
  uint64_t v2 = sub_1001B17FC();
  uint64_t result = dlsym(v2, "kCPMSPowerTimeScale1s");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  qword_100347570 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_1001B1A90(uint64_t a1)
{
  sub_1001B17FC();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("CPMSAgent");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    qword_100347578 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    uint64_t v2 = +[NSAssertionHandler currentHandler];
    id v3 = +[NSString stringWithUTF8String:"Class getCPMSAgentClass(void)_block_invoke"];
    [v2 handleFailureInFunction:v3 file:@"NFCoreDuetWrapper.m" lineNumber:32 description:@"Unable to find class %s", "CPMSAgent"];

    __break(1u);
  }
}

void sub_1001B1B58(uint64_t a1)
{
  sub_1001B17FC();
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = objc_getClass("CPMSClientDescription");
  if (*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    qword_100347580 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  else
  {
    uint64_t v2 = +[NSAssertionHandler currentHandler];
    id v3 = +[NSString stringWithUTF8String:"Class getCPMSClientDescriptionClass(void)_block_invoke"];
    [v2 handleFailureInFunction:v3 file:@"NFCoreDuetWrapper.m" lineNumber:31 description:@"Unable to find class %s", "CPMSClientDescription"];

    __break(1u);
  }
}

void *sub_1001B1C20(uint64_t a1)
{
  uint64_t v2 = sub_1001B17FC();
  uint64_t result = dlsym(v2, "kCPMSPowerTimeScaleThermal");
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = result;
  qword_100347588 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return result;
}

void sub_1001B24F8(uint64_t a1, void *a2, int a3)
{
  id v5 = a2;
  uint64_t v6 = *(void *)(a1 + 32);
  if (!*(unsigned char *)(v6 + 241))
  {
    *(unsigned char *)(v6 + 241) = 1;
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      uint64_t v8 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      [v5 debugDescription];
      id v13 = v5;
      int v14 = a3;
      id v15 = objc_claimAutoreleasedReturnValue();
      id v16 = [v15 UTF8String];
      int v17 = [*(id *)(a1 + 40) sessionUID];
      uint64_t v18 = 45;
      if (isMetaClass) {
        uint64_t v18 = 43;
      }
      v8(6, "%c[%{public}s %{public}s]:%i UI is dismissed, error = %s for session %@", v18, ClassName, Name, 212, v16, v17);

      a3 = v14;
      id v5 = v13;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v19 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      unsigned __int8 v20 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v20)) {
        int v21 = 43;
      }
      else {
        int v21 = 45;
      }
      int v47 = v21;
      BOOL v22 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v23 = sel_getName(*(SEL *)(a1 + 56));
      id v24 = [v5 debugDescription];
      int v25 = a3;
      id v26 = [v24 UTF8String];
      __int16 v27 = [*(id *)(a1 + 40) sessionUID];
      *(_DWORD *)long long buf = 67110402;
      int v63 = v47;
      __int16 v64 = 2082;
      int v65 = v22;
      __int16 v66 = 2082;
      id v67 = v23;
      __int16 v68 = 1024;
      int v69 = 212;
      __int16 v70 = 2080;
      id v71 = v26;
      a3 = v25;
      __int16 v72 = 2112;
      __int16 v73 = v27;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i UI is dismissed, error = %s for session %@", buf, 0x36u);
    }
    id v28 = objc_alloc((Class)NSError);
    int v29 = +[NSString stringWithUTF8String:"nfcd"];
    if (a3)
    {
      NSErrorUserInfoKey v60 = NSLocalizedDescriptionKey;
      id v30 = +[NSString stringWithUTF8String:"User cancelled"];
      uint64_t v61 = v30;
      uint64_t v31 = +[NSDictionary dictionaryWithObjects:&v61 forKeys:&v60 count:1];
      int v32 = v28;
      uint64_t v33 = v29;
      uint64_t v34 = 48;
    }
    else
    {
      NSErrorUserInfoKey v58 = NSLocalizedDescriptionKey;
      id v30 = +[NSString stringWithUTF8String:"Aborted"];
      uint64_t v59 = v30;
      uint64_t v31 = +[NSDictionary dictionaryWithObjects:&v59 forKeys:&v58 count:1];
      int v32 = v28;
      uint64_t v33 = v29;
      uint64_t v34 = 3;
    }
    id v35 = [v32 initWithDomain:v33 code:v34 userInfo:v31];

    id v36 = *(void **)(a1 + 32);
    if (v36[29])
    {
      if (a3) {
        int64_t v37 = 500000000;
      }
      else {
        int64_t v37 = 2500000000;
      }
      dispatch_time_t v38 = dispatch_time(0, v37);
      __int16 v39 = [*(id *)(a1 + 32) workQueue];
      block[0] = _NSConcreteStackBlock;
      block[1] = 3221225472;
      block[2] = sub_1001B29DC;
      block[3] = &unk_100301CE0;
      id v40 = &v55;
      id v41 = &v56;
      id v55 = *(id *)(a1 + 32);
      id v56 = v35;
      uint64_t v42 = (id *)&v57;
      long long v48 = *(_OWORD *)(a1 + 48);
      id v43 = (id)v48;
      long long v57 = v48;
      id v44 = v35;
      dispatch_after(v38, v39, block);
    }
    else
    {
      __int16 v39 = [v36 workQueue];
      v50[0] = _NSConcreteStackBlock;
      v50[1] = 3221225472;
      v50[2] = sub_1001B2BF8;
      v50[3] = &unk_100301CE0;
      id v40 = &v51;
      id v41 = &v52;
      id v51 = *(id *)(a1 + 32);
      id v52 = v35;
      uint64_t v42 = (id *)&v53;
      long long v49 = *(_OWORD *)(a1 + 48);
      id v45 = (id)v49;
      long long v53 = v49;
      id v46 = v35;
      dispatch_async(v39, v50);
    }
  }
}

id sub_1001B29DC(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    id v8 = [*(id *)(a1 + 40) code];
    uint64_t v9 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v10 = 45;
    if (isMetaClass) {
      uint64_t v10 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i Activating invalidation handler: error=0x%lx for session %@", v10, ClassName, Name, 237, v8, v9);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v11 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12)) {
      int v13 = 43;
    }
    else {
      int v13 = 45;
    }
    int v14 = object_getClassName(*(id *)(a1 + 32));
    id v15 = sel_getName(*(SEL *)(a1 + 56));
    id v16 = [*(id *)(a1 + 40) code];
    int v17 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110402;
    int v21 = v13;
    __int16 v22 = 2082;
    uint64_t v23 = v14;
    __int16 v24 = 2082;
    int v25 = v15;
    __int16 v26 = 1024;
    int v27 = 237;
    __int16 v28 = 2048;
    id v29 = v16;
    __int16 v30 = 2112;
    uint64_t v31 = v17;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Activating invalidation handler: error=0x%lx for session %@", buf, 0x36u);
  }
  uint64_t v18 = *(void *)(*(void *)(a1 + 32) + 232);
  if (v18) {
    (*(void (**)(void))(v18 + 16))();
  }
  [*(id *)(a1 + 48) didUIControllerInvalidate:*(void *)(a1 + 40)];
  return [*(id *)(a1 + 32) clearUIControllerInvalidationHandler];
}

id sub_1001B2BF8(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    id v8 = [*(id *)(a1 + 40) code];
    uint64_t v9 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v10 = 45;
    if (isMetaClass) {
      uint64_t v10 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i Activating invalidation handler: error=0x%lx for session %@", v10, ClassName, Name, 246, v8, v9);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v11 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v12)) {
      int v13 = 43;
    }
    else {
      int v13 = 45;
    }
    int v14 = object_getClassName(*(id *)(a1 + 32));
    id v15 = sel_getName(*(SEL *)(a1 + 56));
    id v16 = [*(id *)(a1 + 40) code];
    int v17 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110402;
    int v20 = v13;
    __int16 v21 = 2082;
    __int16 v22 = v14;
    __int16 v23 = 2082;
    __int16 v24 = v15;
    __int16 v25 = 1024;
    int v26 = 246;
    __int16 v27 = 2048;
    id v28 = v16;
    __int16 v29 = 2112;
    __int16 v30 = v17;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Activating invalidation handler: error=0x%lx for session %@", buf, 0x36u);
  }
  [*(id *)(a1 + 48) didUIControllerInvalidate:*(void *)(a1 + 40)];
  return [*(id *)(a1 + 32) clearUIControllerInvalidationHandler];
}

void sub_1001B2DF0(uint64_t a1, void *a2)
{
  id v3 = a2;
  uint64_t v4 = [*(id *)(a1 + 32) workQueue];
  block[0] = _NSConcreteStackBlock;
  block[1] = 3221225472;
  block[2] = sub_1001B2EDC;
  block[3] = &unk_100306BE8;
  id v11 = v3;
  id v5 = *(id *)(a1 + 32);
  uint64_t v6 = *(void *)(a1 + 40);
  id v12 = v5;
  uint64_t v13 = v6;
  long long v9 = *(_OWORD *)(a1 + 48);
  id v7 = (id)v9;
  long long v14 = v9;
  id v8 = v3;
  dispatch_async(v4, block);
}

void sub_1001B2EDC(uint64_t a1)
{
  if (*(void *)(a1 + 32))
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 40));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 40));
      Name = sel_getName(*(SEL *)(a1 + 64));
      uint64_t v8 = *(void *)(a1 + 32);
      long long v9 = [*(id *)(a1 + 40) sessionUID];
      uint64_t v10 = 45;
      if (isMetaClass) {
        uint64_t v10 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Error activating UI : %@ for session %@", v10, ClassName, Name, 257, v8, v9);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v11 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      id v12 = object_getClass(*(id *)(a1 + 40));
      if (class_isMetaClass(v12)) {
        int v13 = 43;
      }
      else {
        int v13 = 45;
      }
      long long v14 = object_getClassName(*(id *)(a1 + 40));
      id v15 = sel_getName(*(SEL *)(a1 + 64));
      uint64_t v16 = *(void *)(a1 + 32);
      int v17 = [*(id *)(a1 + 40) sessionUID];
      *(_DWORD *)long long buf = 67110402;
      int v38 = v13;
      __int16 v39 = 2082;
      id v40 = v14;
      __int16 v41 = 2082;
      uint64_t v42 = v15;
      __int16 v43 = 1024;
      int v44 = 257;
      __int16 v45 = 2112;
      uint64_t v46 = v16;
      __int16 v47 = 2112;
      long long v48 = v17;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Error activating UI : %@ for session %@", buf, 0x36u);
    }
    [*(id *)(a1 + 40) clearUIControllerInvalidationHandler];
    id v18 = *(id *)(a1 + 32);
  }
  else if (([*(id *)(a1 + 40) didEnd] & 1) != 0 {
         || [*(id *)(a1 + 48) isSuspended])
  }
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v19 = NFLogGetLogger();
    if (v19)
    {
      int v20 = (void (*)(uint64_t, const char *, ...))v19;
      __int16 v21 = object_getClass(*(id *)(a1 + 40));
      BOOL v22 = class_isMetaClass(v21);
      __int16 v23 = object_getClassName(*(id *)(a1 + 40));
      uint64_t v34 = sel_getName(*(SEL *)(a1 + 64));
      uint64_t v24 = 45;
      if (v22) {
        uint64_t v24 = 43;
      }
      v20(6, "%c[%{public}s %{public}s]:%i Session has been terminated / suspended", v24, v23, v34, 261);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    __int16 v25 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
    {
      int v26 = object_getClass(*(id *)(a1 + 40));
      if (class_isMetaClass(v26)) {
        int v27 = 43;
      }
      else {
        int v27 = 45;
      }
      id v28 = object_getClassName(*(id *)(a1 + 40));
      __int16 v29 = sel_getName(*(SEL *)(a1 + 64));
      *(_DWORD *)long long buf = 67109890;
      int v38 = v27;
      __int16 v39 = 2082;
      id v40 = v28;
      __int16 v41 = 2082;
      uint64_t v42 = v29;
      __int16 v43 = 1024;
      int v44 = 261;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Session has been terminated / suspended", buf, 0x22u);
    }

    id v30 = objc_alloc((Class)NSError);
    uint64_t v31 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v35 = NSLocalizedDescriptionKey;
    int v32 = +[NSString stringWithUTF8String:"Invalid State"];
    id v36 = v32;
    uint64_t v33 = +[NSDictionary dictionaryWithObjects:&v36 forKeys:&v35 count:1];
    id v18 = [v30 initWithDomain:v31 code:12 userInfo:v33];

    [*(id *)(*(void *)(a1 + 40) + 216) coreNFCUIInvalidate];
  }
  else
  {
    id v18 = 0;
    *(unsigned char *)(*(void *)(a1 + 40) + 240) = 1;
  }
  (*(void (**)(void))(*(void *)(a1 + 56) + 16))();
}

void sub_1001B38E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,id location)
{
}

void sub_1001B3920(uint64_t a1)
{
  uint64_t v2 = _os_activity_create((void *)&_mh_execute_header, "com.apple.nfcd.reader.sessionTimer", (os_activity_t)&_os_activity_current, OS_ACTIVITY_FLAG_DEFAULT);
  *(void *)state = 0;
  *(void *)&state[8] = 0;
  os_activity_scope_enter(v2, (os_activity_scope_state_t)state);
  os_activity_scope_leave((os_activity_scope_state_t)state);

  id WeakRetained = objc_loadWeakRetained((id *)(a1 + 32));
  if (WeakRetained)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(WeakRetained);
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(WeakRetained);
      Name = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v10 = [WeakRetained clientName];
      id v11 = [WeakRetained connection];
      id v12 = [v11 processIdentifier];
      int v13 = [WeakRetained sessionUID];
      uint64_t v14 = 43;
      if (!isMetaClass) {
        uint64_t v14 = 45;
      }
      v5(5, "%c[%{public}s %{public}s]:%i Reader session expired: %@ (%d) %@", v14, ClassName, Name, 337, v10, v12, v13);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v15 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v16 = object_getClass(WeakRetained);
      if (class_isMetaClass(v16)) {
        int v17 = 43;
      }
      else {
        int v17 = 45;
      }
      id v18 = object_getClassName(WeakRetained);
      uint64_t v19 = sel_getName(*(SEL *)(a1 + 40));
      int v20 = [WeakRetained clientName];
      __int16 v21 = [WeakRetained connection];
      unsigned int v22 = [v21 processIdentifier];
      __int16 v23 = [WeakRetained sessionUID];
      *(_DWORD *)state = 67110658;
      *(_DWORD *)&state[4] = v17;
      *(_WORD *)&state[8] = 2082;
      *(void *)&state[10] = v18;
      __int16 v35 = 2082;
      id v36 = v19;
      __int16 v37 = 1024;
      int v38 = 337;
      __int16 v39 = 2112;
      id v40 = v20;
      __int16 v41 = 1024;
      unsigned int v42 = v22;
      __int16 v43 = 2112;
      int v44 = v23;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Reader session expired: %@ (%d) %@", state, 0x3Cu);
    }
    *((_DWORD *)WeakRetained + 50) = 1;
    uint64_t v24 = (void *)*((void *)WeakRetained + 43);
    *((void *)WeakRetained + 43) = 0;

    *((void *)WeakRetained + 2_Block_object_dispose(&STACK[0x260], 8) = 0;
    [WeakRetained endSession:0];
    __int16 v25 = NFSharedSignpostLog();
    if (os_signpost_enabled(v25))
    {
      *(_WORD *)state = 0;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v25, OS_SIGNPOST_EVENT, 0xEEEEB0B5B2B2EEEELL, "sessionTimerExpired", (const char *)&unk_100286819, state, 2u);
    }

    int v26 = [WeakRetained remoteObject];
    id v27 = objc_alloc((Class)NSError);
    id v28 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v32 = NSLocalizedDescriptionKey;
    __int16 v29 = +[NSString stringWithUTF8String:"Timeout"];
    uint64_t v33 = v29;
    id v30 = +[NSDictionary dictionaryWithObjects:&v33 forKeys:&v32 count:1];
    id v31 = [v27 initWithDomain:v28 code:5 userInfo:v30];
    [v26 didTerminate:v31];
  }
}

void sub_1001B46F0(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 40));
    uint64_t v7 = 45;
    if (isMetaClass) {
      uint64_t v7 = 43;
    }
    v3(4, "%c[%{public}s %{public}s]:%i Stopping reader session due to revocation of PPM", v7, ClassName, Name, 451);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v8 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
  {
    long long v9 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v9)) {
      int v10 = 43;
    }
    else {
      int v10 = 45;
    }
    id v11 = object_getClassName(*(id *)(a1 + 32));
    id v12 = sel_getName(*(SEL *)(a1 + 40));
    *(_DWORD *)long long buf = 67109890;
    int v21 = v10;
    __int16 v22 = 2082;
    __int16 v23 = v11;
    __int16 v24 = 2082;
    __int16 v25 = v12;
    __int16 v26 = 1024;
    int v27 = 451;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Stopping reader session due to revocation of PPM", buf, 0x22u);
  }

  if (([*(id *)(a1 + 32) didEnd] & 1) == 0)
  {
    int v13 = +[_NFHardwareManager sharedHardwareManager];
    unsigned int v14 = sub_10012B21C(v13);
    id v15 = [v13 defaultRoutingConfig:3];
    id v16 = [v13 setRoutingConfig:v15];

    id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 320));
    sub_1001B03F0((uint64_t)WeakRetained, *(void **)(a1 + 32));

    [v13 notifyReaderModeActivityEnd];
    if (v14)
    {
      id v18 = NFSharedSignpostLog();
      if (os_signpost_enabled(v18))
      {
        *(_WORD *)long long buf = 0;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v18, OS_SIGNPOST_INTERVAL_END, 0xEEEEB0B5B2B2EEEELL, "Polling", (const char *)&unk_100286819, buf, 2u);
      }
    }
  }
}

id sub_1001B55EC(id result, uint64_t a2)
{
  if (a2 == 1)
  {
    uint64_t v2 = *((void *)result + 4);
    if (*(unsigned char *)(v2 + 240))
    {
      id v3 = *(void **)(v2 + 216);
      id v4 = [*((id *)result + 5) count];
      return [v3 coreNFCUITagScannedCount:v4];
    }
  }
  return result;
}

void sub_1001B7BC4(uint64_t a1)
{
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 829, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      id v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      int v13 = object_getClassName(*(id *)(a1 + 32));
      unsigned int v14 = sel_getName(*(SEL *)(a1 + 56));
      id v15 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)long long buf = 67110146;
      int v28 = v12;
      __int16 v29 = 2082;
      id v30 = v13;
      __int16 v31 = 2082;
      NSErrorUserInfoKey v32 = v14;
      __int16 v33 = 1024;
      int v34 = 829;
      __int16 v35 = 2114;
      id v36 = v15;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v16 = *(void *)(a1 + 48);
    if (v16)
    {
      id v17 = objc_alloc((Class)NSError);
      id v18 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v25 = NSLocalizedDescriptionKey;
      uint64_t v19 = +[NSString stringWithUTF8String:"Session not active"];
      __int16 v26 = v19;
      int v20 = +[NSDictionary dictionaryWithObjects:&v26 forKeys:&v25 count:1];
      id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
      (*(void (**)(uint64_t, void, id))(v16 + 16))(v16, 0, v21);
    }
  }
  else
  {
    __int16 v22 = *(void **)(a1 + 32);
    uint64_t v23 = *(void *)(a1 + 40);
    uint64_t v24 = *(void *)(a1 + 48);
    [v22 _sync_connect:v23 completion:v24];
  }
}

void sub_1001B82F8(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = [*(id *)(a1 + 32) connection];
    id v10 = [v9 processIdentifier];
    id v11 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v12 = 43;
    if (!isMetaClass) {
      uint64_t v12 = 45;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@ (%d) %{public}@", v12, ClassName, Name, 860, v8, v10, v11);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  int v13 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14)) {
      int v15 = 43;
    }
    else {
      int v15 = 45;
    }
    uint64_t v16 = object_getClassName(*(id *)(a1 + 32));
    id v17 = sel_getName(*(SEL *)(a1 + 48));
    id v18 = [*(id *)(a1 + 32) clientName];
    uint64_t v19 = [*(id *)(a1 + 32) connection];
    unsigned int v20 = [v19 processIdentifier];
    id v21 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110658;
    int v45 = v15;
    __int16 v46 = 2082;
    __int16 v47 = v16;
    __int16 v48 = 2082;
    long long v49 = v17;
    __int16 v50 = 1024;
    int v51 = 860;
    __int16 v52 = 2114;
    long long v53 = v18;
    __int16 v54 = 1024;
    unsigned int v55 = v20;
    __int16 v56 = 2114;
    long long v57 = v21;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@ (%d) %{public}@", buf, 0x3Cu);
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    int v38 = [*(id *)(a1 + 32) _disconnectWithCardRemoval:*(unsigned __int8 *)(a1 + 56)];
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
    if (v38)
    {
      [NFExceptionsCALogger postAnalyticsReaderModeExceptionForType:tagType:rfFrameInterface:withErrorCode:[*(id *)(a1 + 32) _getTagTypeFromTag:*(void *)(*(void *)(a1 + 32) + 344)] rfFrameInterface:([*(id *)(a1 + 32) _getTagTypeFromTag:*(void *)(*(void *)(a1 + 32) + 344)] >> 12) & 1 withErrorCode:objc_msgSend(v38, "code")];
      sub_100223B0C((uint64_t)NFDailyStatisticsCALogger, @"readerModeDisconnectErrorCount");
    }
    goto LABEL_24;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v22 = NFLogGetLogger();
  if (v22)
  {
    uint64_t v23 = (void (*)(uint64_t, const char *, ...))v22;
    uint64_t v24 = object_getClass(*(id *)(a1 + 32));
    BOOL v25 = class_isMetaClass(v24);
    __int16 v26 = object_getClassName(*(id *)(a1 + 32));
    int v27 = sel_getName(*(SEL *)(a1 + 48));
    int v28 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v29 = 45;
    if (v25) {
      uint64_t v29 = 43;
    }
    v23(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v29, v26, v27, 862, v28);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v30 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    __int16 v31 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v31)) {
      int v32 = 43;
    }
    else {
      int v32 = 45;
    }
    __int16 v33 = object_getClassName(*(id *)(a1 + 32));
    int v34 = sel_getName(*(SEL *)(a1 + 48));
    __int16 v35 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v45 = v32;
    __int16 v46 = 2082;
    __int16 v47 = v33;
    __int16 v48 = 2082;
    long long v49 = v34;
    __int16 v50 = 1024;
    int v51 = 862;
    __int16 v52 = 2114;
    long long v53 = v35;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v36 = *(void *)(a1 + 40);
  if (v36)
  {
    id v37 = objc_alloc((Class)NSError);
    int v38 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v42 = NSLocalizedDescriptionKey;
    __int16 v39 = +[NSString stringWithUTF8String:"Session not active"];
    __int16 v43 = v39;
    id v40 = +[NSDictionary dictionaryWithObjects:&v43 forKeys:&v42 count:1];
    id v41 = [v37 initWithDomain:v38 code:54 userInfo:v40];
    (*(void (**)(uint64_t, id))(v36 + 16))(v36, v41);

LABEL_24:
  }
}

void sub_1001B9384(uint64_t a1, unsigned int a2)
{
  uint64_t v4 = *(void *)(a1 + 40);
  uint64_t v5 = *(void *)(*(void *)(a1 + 32) + 344);
  id v6 = objc_alloc((Class)NSError);
  uint64_t v7 = +[NSString stringWithUTF8String:"nfcd"];
  NSErrorUserInfoKey v21 = NSLocalizedDescriptionKey;
  if (a2 >= 0x47) {
    int v8 = 71;
  }
  else {
    int v8 = a2;
  }
  uint64_t v9 = +[NSString stringWithUTF8String:](NSString, "stringWithUTF8String:", off_100306978[v8], NSLocalizedDescriptionKey);
  uint64_t v22 = v9;
  id v10 = +[NSDictionary dictionaryWithObjects:&v22 forKeys:&v21 count:1];
  id v11 = [v6 initWithDomain:v7 code:a2 userInfo:v10];
  (*(void (**)(uint64_t, uint64_t, void, id))(v4 + 16))(v4, v5, 0, v11);

  +[NFExceptionsCALogger postAnalyticsReaderModeExceptionForType:tagType:rfFrameInterface:withErrorCode:](NFExceptionsCALogger, "postAnalyticsReaderModeExceptionForType:tagType:rfFrameInterface:withErrorCode:", 3, [*(id *)(a1 + 32) _getTagTypeFromTag:*(void *)(*(void *)(a1 + 32) + 344)], (*(_DWORD *)(*(void *)(a1 + 32) + 280) >> 12) & 1, 8);
  sub_100223B0C((uint64_t)NFDailyStatisticsCALogger, @"readerModeTransceiveErrorCount");
  if (a2 == 32)
  {
    [*(id *)(a1 + 32) endSession:0];
    uint64_t v12 = [*(id *)(a1 + 32) remoteObject];
    id v13 = objc_alloc((Class)NSError);
    unsigned int v14 = +[NSString stringWithUTF8String:"nfcd"];
    uint64_t v19 = v18;
    int v15 = +[NSString stringWithUTF8String:"Not entitled"];
    unsigned int v20 = v15;
    uint64_t v16 = +[NSDictionary dictionaryWithObjects:&v20 forKeys:&v19 count:1];
    id v17 = [v13 initWithDomain:v14 code:32 userInfo:v16];
    [v12 didTerminate:v17];
  }
}

void sub_1001B96FC(uint64_t a1)
{
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      int v8 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 1015, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      id v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      id v13 = object_getClassName(*(id *)(a1 + 32));
      unsigned int v14 = sel_getName(*(SEL *)(a1 + 56));
      int v15 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)long long buf = 67110146;
      int v28 = v12;
      __int16 v29 = 2082;
      id v30 = v13;
      __int16 v31 = 2082;
      int v32 = v14;
      __int16 v33 = 1024;
      int v34 = 1015;
      __int16 v35 = 2114;
      uint64_t v36 = v15;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v16 = *(void *)(a1 + 48);
    if (v16)
    {
      id v17 = objc_alloc((Class)NSError);
      uint64_t v18 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v25 = NSLocalizedDescriptionKey;
      uint64_t v19 = +[NSString stringWithUTF8String:"Session not active"];
      __int16 v26 = v19;
      unsigned int v20 = +[NSDictionary dictionaryWithObjects:&v26 forKeys:&v25 count:1];
      id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
      (*(void (**)(uint64_t, void, void, id))(v16 + 16))(v16, 0, 0, v21);
    }
  }
  else
  {
    uint64_t v22 = *(void **)(a1 + 32);
    uint64_t v23 = *(void *)(a1 + 40);
    uint64_t v24 = *(void *)(a1 + 48);
    [v22 _sync_transceive:v23 completion:v24];
  }
}

void sub_1001B9AC4(uint64_t a1)
{
  memset(v56, 0, sizeof(v56));
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    NSErrorUserInfoKey v25 = *(void **)(a1 + 32);
    if (v25[43])
    {
      unsigned int v26 = [v25 _refreshNdefTagConnection];
      if (!v26)
      {
        uint64_t v48 = *(void *)(a1 + 32);
        long long v49 = *(void **)(v48 + 312);
        __int16 v50 = *(void **)(v48 + 344);
        id v55 = 0;
        char v51 = sub_100190624(v49, v50, v56, (uint64_t)&v55);
        id v52 = v55;
        uint64_t v18 = v52;
        if (v51)
        {
          long long v53 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
        }
        else
        {
          if ([v52 code] == (id)37)
          {

            uint64_t v18 = 0;
          }
          long long v53 = *(void (**)(void))(*(void *)(a1 + 40) + 16);
        }
        v53();
        goto LABEL_17;
      }
      unsigned int v27 = v26;
      uint64_t v28 = *(void *)(a1 + 40);
      id v29 = objc_alloc((Class)NSError);
      uint64_t v18 = +[NSString stringWithUTF8String:"nfcd"];
      uint64_t v30 = v27;
      v57[0] = NSLocalizedDescriptionKey;
      if (v27 >= 0x47) {
        int v31 = 71;
      }
      else {
        int v31 = v27;
      }
      uint64_t v19 = +[NSString stringWithUTF8String:off_100306978[v31]];
      v58[0] = v19;
      v58[1] = &off_10031D848;
      v57[1] = @"Line";
      v57[2] = @"Method";
      id v32 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
      v58[2] = v32;
      v57[3] = NSDebugDescriptionErrorKey;
      id v33 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 1038];
      v58[3] = v33;
      int v34 = +[NSDictionary dictionaryWithObjects:v58 forKeys:v57 count:4];
      id v35 = [v29 initWithDomain:v18 code:v30 userInfo:v34];
      (*(void (**)(uint64_t, void, void, id))(v28 + 16))(v28, 0, 0, v35);

LABEL_16:
LABEL_17:

      return;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v37 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v41 = 45;
      if (isMetaClass) {
        uint64_t v41 = 43;
      }
      v37(3, "%c[%{public}s %{public}s]:%i Tag not connected", v41, ClassName, Name, 1031);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    NSErrorUserInfoKey v42 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
    {
      __int16 v43 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v43)) {
        int v44 = 43;
      }
      else {
        int v44 = 45;
      }
      int v45 = object_getClassName(*(id *)(a1 + 32));
      __int16 v46 = sel_getName(*(SEL *)(a1 + 48));
      *(_DWORD *)long long buf = 67109890;
      int v64 = v44;
      __int16 v65 = 2082;
      __int16 v66 = v45;
      __int16 v67 = 2082;
      __int16 v68 = v46;
      __int16 v69 = 1024;
      int v70 = 1031;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Tag not connected", buf, 0x22u);
    }

    uint64_t v16 = *(void *)(a1 + 40);
    id v47 = objc_alloc((Class)NSError);
    uint64_t v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v59 = NSLocalizedDescriptionKey;
    uint64_t v19 = +[NSString stringWithUTF8String:"Tag Not Found"];
    NSErrorUserInfoKey v60 = v19;
    unsigned int v20 = +[NSDictionary dictionaryWithObjects:&v60 forKeys:&v59 count:1];
    id v21 = v47;
    uint64_t v22 = v18;
    uint64_t v23 = 28;
LABEL_15:
    id v24 = [v21 initWithDomain:v22 code:v23 userInfo:v20];
    (*(void (**)(uint64_t, void, void, id))(v16 + 16))(v16, 0, 0, v24);

    goto LABEL_16;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v2 = NFLogGetLogger();
  if (v2)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))v2;
    uint64_t v4 = object_getClass(*(id *)(a1 + 32));
    BOOL v5 = class_isMetaClass(v4);
    id v6 = object_getClassName(*(id *)(a1 + 32));
    uint64_t v7 = sel_getName(*(SEL *)(a1 + 48));
    int v8 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v9 = 45;
    if (v5) {
      uint64_t v9 = 43;
    }
    v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, v6, v7, 1028, v8);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v10 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    id v11 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v11)) {
      int v12 = 43;
    }
    else {
      int v12 = 45;
    }
    id v13 = object_getClassName(*(id *)(a1 + 32));
    unsigned int v14 = sel_getName(*(SEL *)(a1 + 48));
    int v15 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v64 = v12;
    __int16 v65 = 2082;
    __int16 v66 = v13;
    __int16 v67 = 2082;
    __int16 v68 = v14;
    __int16 v69 = 1024;
    int v70 = 1028;
    __int16 v71 = 2114;
    __int16 v72 = v15;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v16 = *(void *)(a1 + 40);
  if (v16)
  {
    id v17 = objc_alloc((Class)NSError);
    uint64_t v18 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v61 = NSLocalizedDescriptionKey;
    uint64_t v19 = +[NSString stringWithUTF8String:"Session not active"];
    uint64_t v62 = v19;
    unsigned int v20 = +[NSDictionary dictionaryWithObjects:&v62 forKeys:&v61 count:1];
    id v21 = v17;
    uint64_t v22 = v18;
    uint64_t v23 = 54;
    goto LABEL_15;
  }
}

void sub_1001BA240(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    int v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = [*(id *)(a1 + 32) connection];
    id v10 = [v9 processIdentifier];
    id v11 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v12 = 43;
    if (!isMetaClass) {
      uint64_t v12 = 45;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@ (%d) %{public}@", v12, ClassName, Name, 1066, v8, v10, v11);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v13 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14)) {
      int v15 = 43;
    }
    else {
      int v15 = 45;
    }
    uint64_t v16 = object_getClassName(*(id *)(a1 + 32));
    id v17 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v18 = [*(id *)(a1 + 32) clientName];
    uint64_t v19 = [*(id *)(a1 + 32) connection];
    unsigned int v20 = [v19 processIdentifier];
    id v21 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110658;
    int v130 = v15;
    __int16 v131 = 2082;
    __int16 v132 = v16;
    __int16 v133 = 2082;
    int v134 = v17;
    __int16 v135 = 1024;
    int v136 = 1066;
    __int16 v137 = 2114;
    id v138 = v18;
    __int16 v139 = 1024;
    unsigned int v140 = v20;
    __int16 v141 = 2114;
    id v142 = v21;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@ (%d) %{public}@", buf, 0x3Cu);
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    uint64_t v45 = *(void *)(a1 + 32);
    __int16 v46 = *(void **)(v45 + 344);
    if (!v46)
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v57 = NFLogGetLogger();
      if (v57)
      {
        NSErrorUserInfoKey v58 = (void (*)(uint64_t, const char *, ...))v57;
        NSErrorUserInfoKey v59 = object_getClass(*(id *)(a1 + 32));
        BOOL v60 = class_isMetaClass(v59);
        NSErrorUserInfoKey v61 = object_getClassName(*(id *)(a1 + 32));
        __int16 v113 = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v62 = 45;
        if (v60) {
          uint64_t v62 = 43;
        }
        v58(3, "%c[%{public}s %{public}s]:%i Tag not connected", v62, v61, v113, 1071);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v63 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
      {
        int v64 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v64)) {
          int v65 = 43;
        }
        else {
          int v65 = 45;
        }
        __int16 v66 = object_getClassName(*(id *)(a1 + 32));
        __int16 v67 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)long long buf = 67109890;
        int v130 = v65;
        __int16 v131 = 2082;
        __int16 v132 = v66;
        __int16 v133 = 2082;
        int v134 = v67;
        __int16 v135 = 1024;
        int v136 = 1071;
        _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Tag not connected", buf, 0x22u);
      }

      uint64_t v36 = *(void *)(a1 + 40);
      id v68 = objc_alloc((Class)NSError);
      id v38 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v125 = NSLocalizedDescriptionKey;
      __int16 v39 = +[NSString stringWithUTF8String:"Tag Not Found"];
      __int16 v126 = v39;
      id v40 = +[NSDictionary dictionaryWithObjects:&v126 forKeys:&v125 count:1];
      uint64_t v41 = v68;
      id v42 = v38;
      uint64_t v43 = 28;
      goto LABEL_24;
    }
    if ((*(unsigned char *)(v45 + 353) & 2) == 0)
    {
      unsigned int v47 = [(id)v45 _refreshNdefTagConnection];
      if (v47)
      {
        unsigned int v48 = v47;
        uint64_t v49 = *(void *)(a1 + 40);
        id v50 = objc_alloc((Class)NSError);
        id v38 = +[NSString stringWithUTF8String:"nfcd"];
        uint64_t v51 = v48;
        v123[0] = NSLocalizedDescriptionKey;
        if (v48 >= 0x47) {
          int v52 = 71;
        }
        else {
          int v52 = v48;
        }
        __int16 v39 = +[NSString stringWithUTF8String:off_100306978[v52]];
        v124[0] = v39;
        v124[1] = &off_10031D860;
        v123[1] = @"Line";
        v123[2] = @"Method";
        id v53 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 48))];
        v124[2] = v53;
        v123[3] = NSDebugDescriptionErrorKey;
        id v54 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 48)), 1092];
        v124[3] = v54;
        id v55 = +[NSDictionary dictionaryWithObjects:v124 forKeys:v123 count:4];
        id v56 = [v50 initWithDomain:v38 code:v51 userInfo:v55];
        (*(void (**)(uint64_t, id, void))(v49 + 16))(v49, v56, 0);

        goto LABEL_25;
      }
      v118[0] = 0;
      v118[1] = 0;
      uint64_t v119 = 0;
      uint64_t v74 = *(void *)(a1 + 32);
      __int16 v75 = *(void **)(v74 + 312);
      id v76 = *(void **)(v74 + 344);
      id v117 = 0;
      char v77 = sub_100190624(v75, v76, v118, (uint64_t)&v117);
      id v38 = v117;
      if ((v77 & 1) == 0)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v85 = NFLogGetLogger();
        if (v85)
        {
          int8x16_t v86 = (void (*)(uint64_t, const char *, ...))v85;
          id v87 = object_getClass(*(id *)(a1 + 32));
          BOOL v88 = class_isMetaClass(v87);
          __int16 v112 = object_getClassName(*(id *)(a1 + 32));
          __int16 v114 = sel_getName(*(SEL *)(a1 + 48));
          uint64_t v89 = 45;
          if (v88) {
            uint64_t v89 = 43;
          }
          v86(3, "%c[%{public}s %{public}s]:%i Failed to query NDEF capability, %{public}@", v89, v112, v114, 1098, v38);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        NSErrorUserInfoKey v90 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
        {
          uint64_t v91 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v91)) {
            int v92 = 43;
          }
          else {
            int v92 = 45;
          }
          NSErrorUserInfoKey v93 = object_getClassName(*(id *)(a1 + 32));
          uint64_t v94 = sel_getName(*(SEL *)(a1 + 48));
          *(_DWORD *)long long buf = 67110146;
          int v130 = v92;
          __int16 v131 = 2082;
          __int16 v132 = v93;
          __int16 v133 = 2082;
          int v134 = v94;
          __int16 v135 = 1024;
          int v136 = 1098;
          __int16 v137 = 2114;
          id v138 = v38;
          _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to query NDEF capability, %{public}@", buf, 0x2Cu);
        }

        (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
        goto LABEL_26;
      }
      if (!(_BYTE)v119)
      {
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v95 = NFLogGetLogger();
        if (v95)
        {
          __int16 v96 = (void (*)(uint64_t, const char *, ...))v95;
          uint64_t v97 = object_getClass(*(id *)(a1 + 32));
          BOOL v98 = class_isMetaClass(v97);
          id v99 = object_getClassName(*(id *)(a1 + 32));
          int v115 = sel_getName(*(SEL *)(a1 + 48));
          uint64_t v100 = 45;
          if (v98) {
            uint64_t v100 = 43;
          }
          v96(3, "%c[%{public}s %{public}s]:%i Tag is not NDEF readable", v100, v99, v115, 1104);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        __int16 v101 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v101, OS_LOG_TYPE_ERROR))
        {
          __int16 v102 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v102)) {
            int v103 = 43;
          }
          else {
            int v103 = 45;
          }
          __int16 v104 = object_getClassName(*(id *)(a1 + 32));
          id v105 = sel_getName(*(SEL *)(a1 + 48));
          *(_DWORD *)long long buf = 67109890;
          int v130 = v103;
          __int16 v131 = 2082;
          __int16 v132 = v104;
          __int16 v133 = 2082;
          int v134 = v105;
          __int16 v135 = 1024;
          int v136 = 1104;
          _os_log_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Tag is not NDEF readable", buf, 0x22u);
        }

        uint64_t v106 = *(void *)(a1 + 40);
        id v107 = objc_alloc((Class)NSError);
        id v108 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v121 = NSLocalizedDescriptionKey;
        int v109 = +[NSString stringWithUTF8String:"Tag Not NDEF formatted"];
        __int16 v122 = v109;
        __int16 v110 = +[NSDictionary dictionaryWithObjects:&v122 forKeys:&v121 count:1];
        id v111 = [v107 initWithDomain:v108 code:37 userInfo:v110];
        (*(void (**)(uint64_t, id, void))(v106 + 16))(v106, v111, 0);

        goto LABEL_26;
      }
      uint64_t v78 = *(void *)(a1 + 32);
      __int16 v79 = *(void **)(v78 + 312);
      id v80 = *(void **)(v78 + 344);
      id v116 = v38;
      long long v81 = sub_1001932E8(v79, v80, &v116);
      id v82 = v116;

      if (v81)
      {
        uint64_t v83 = sub_10023D968();
        id v84 = [v81 asData];
        sub_10023DF68((uint64_t)v83, (uint64_t)[v84 length]);
      }
      else
      {
        if (!v82)
        {
LABEL_78:
          (*(void (**)(void))(*(void *)(a1 + 40) + 16))();

          id v38 = v82;
          goto LABEL_26;
        }
        uint64_t v83 = sub_10023D968();
        sub_10023E114((uint64_t)v83, v82);
      }

      goto LABEL_78;
    }
    __int16 v69 = *(void **)(v45 + 312);
    id v120 = 0;
    int v70 = sub_1001932E8(v69, v46, &v120);
    id v71 = v120;
    id v38 = v71;
    if (v70)
    {
      __int16 v72 = sub_10023D968();
      __int16 v73 = [v70 asData];
      sub_10023DF68((uint64_t)v72, (uint64_t)[v73 length]);
    }
    else
    {
      if (!v71)
      {
LABEL_54:
        (*(void (**)(void))(*(void *)(a1 + 40) + 16))();

        goto LABEL_26;
      }
      __int16 v72 = sub_10023D968();
      sub_10023E114((uint64_t)v72, v38);
    }

    goto LABEL_54;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v22 = NFLogGetLogger();
  if (v22)
  {
    uint64_t v23 = (void (*)(uint64_t, const char *, ...))v22;
    id v24 = object_getClass(*(id *)(a1 + 32));
    BOOL v25 = class_isMetaClass(v24);
    unsigned int v26 = object_getClassName(*(id *)(a1 + 32));
    unsigned int v27 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v28 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v29 = 45;
    if (v25) {
      uint64_t v29 = 43;
    }
    v23(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v29, v26, v27, 1069, v28);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v30 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    int v31 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v31)) {
      int v32 = 43;
    }
    else {
      int v32 = 45;
    }
    id v33 = object_getClassName(*(id *)(a1 + 32));
    int v34 = sel_getName(*(SEL *)(a1 + 48));
    id v35 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v130 = v32;
    __int16 v131 = 2082;
    __int16 v132 = v33;
    __int16 v133 = 2082;
    int v134 = v34;
    __int16 v135 = 1024;
    int v136 = 1069;
    __int16 v137 = 2114;
    id v138 = v35;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v36 = *(void *)(a1 + 40);
  if (v36)
  {
    id v37 = objc_alloc((Class)NSError);
    id v38 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v127 = NSLocalizedDescriptionKey;
    __int16 v39 = +[NSString stringWithUTF8String:"Session not active"];
    __int16 v128 = v39;
    id v40 = +[NSDictionary dictionaryWithObjects:&v128 forKeys:&v127 count:1];
    uint64_t v41 = v37;
    id v42 = v38;
    uint64_t v43 = 54;
LABEL_24:
    id v44 = [v41 initWithDomain:v42 code:v43 userInfo:v40];
    (*(void (**)(uint64_t, id, void))(v36 + 16))(v36, v44, 0);

LABEL_25:
LABEL_26:
  }
}

void sub_1001BAFA4(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    int v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = [*(id *)(a1 + 32) connection];
    id v10 = [v9 processIdentifier];
    id v11 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v12 = 43;
    if (!isMetaClass) {
      uint64_t v12 = 45;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@ (%d) %{public}@", v12, ClassName, Name, 1124, v8, v10, v11);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v13 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14)) {
      int v15 = 43;
    }
    else {
      int v15 = 45;
    }
    uint64_t v16 = object_getClassName(*(id *)(a1 + 32));
    id v17 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v18 = [*(id *)(a1 + 32) clientName];
    uint64_t v19 = [*(id *)(a1 + 32) connection];
    unsigned int v20 = [v19 processIdentifier];
    id v21 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110658;
    int v142 = v15;
    __int16 v143 = 2082;
    int v144 = v16;
    __int16 v145 = 2082;
    unsigned int v146 = v17;
    __int16 v147 = 1024;
    int v148 = 1124;
    __int16 v149 = 2114;
    id v150 = v18;
    __int16 v151 = 1024;
    unsigned int v152 = v20;
    __int16 v153 = 2114;
    BOOL v154 = v21;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@ (%d) %{public}@", buf, 0x3Cu);
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    if (*(void *)(*(void *)(a1 + 32) + 344))
    {
      if ([*(id *)(a1 + 40) conformsToProtocol:&OBJC_PROTOCOL___NFNdefMessage])
      {
        uint64_t v45 = *(void *)(a1 + 32);
        if ((*(unsigned char *)(v45 + 353) & 2) != 0)
        {
          id v80 = *(void **)(v45 + 312);
          long long v81 = *(void **)(a1 + 40);
          id v82 = *(void **)(v45 + 344);
          int v130 = 0;
          if (v80)
          {
            sub_1001933C0(v80, v81, v82, 1, &v130);
            uint64_t v83 = v130;
          }
          else
          {
            uint64_t v83 = 0;
          }
          id v38 = v83;
        }
        else
        {
          unsigned int v46 = [*(id *)(a1 + 32) _refreshNdefTagConnection];
          if (v46)
          {
            unsigned int v47 = v46;
            uint64_t v48 = *(void *)(a1 + 48);
            id v49 = objc_alloc((Class)NSError);
            id v38 = +[NSString stringWithUTF8String:"nfcd"];
            uint64_t v50 = v47;
            v133[0] = NSLocalizedDescriptionKey;
            if (v47 >= 0x47) {
              int v51 = 71;
            }
            else {
              int v51 = v47;
            }
            __int16 v39 = +[NSString stringWithUTF8String:off_100306978[v51]];
            v134[0] = v39;
            v134[1] = &off_10031D878;
            v133[1] = @"Line";
            v133[2] = @"Method";
            id v52 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
            v134[2] = v52;
            v133[3] = NSDebugDescriptionErrorKey;
            id v53 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 1149];
            v134[3] = v53;
            id v54 = +[NSDictionary dictionaryWithObjects:v134 forKeys:v133 count:4];
            id v55 = [v49 initWithDomain:v38 code:v50 userInfo:v54];
            (*(void (**)(uint64_t, id))(v48 + 16))(v48, v55);

            goto LABEL_25;
          }
          v128[0] = 0;
          v128[1] = 0;
          uint64_t v129 = 0;
          uint64_t v84 = *(void *)(a1 + 32);
          uint64_t v85 = *(void **)(v84 + 312);
          int8x16_t v86 = *(void **)(v84 + 344);
          id v127 = 0;
          char v87 = sub_100190624(v85, v86, v128, (uint64_t)&v127);
          id v38 = v127;
          if (v87)
          {
            if (BYTE1(v129))
            {
              uint64_t v89 = *(void *)(a1 + 32);
              BOOL v88 = *(void **)(a1 + 40);
              NSErrorUserInfoKey v90 = *(void **)(v89 + 312);
              uint64_t v91 = *(void **)(v89 + 344);
              id v126 = v38;
              int v92 = v38;
              if (v90)
              {
                sub_1001933C0(v90, v88, v91, 1, &v126);
                int v92 = v126;
              }
              id v93 = v92;

              (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
              id v38 = v93;
            }
            else
            {
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              uint64_t v104 = NFLogGetLogger();
              if (v104)
              {
                id v105 = (void (*)(uint64_t, const char *, ...))v104;
                uint64_t v106 = object_getClass(*(id *)(a1 + 32));
                BOOL v107 = class_isMetaClass(v106);
                id v108 = object_getClassName(*(id *)(a1 + 32));
                NSErrorUserInfoKey v125 = sel_getName(*(SEL *)(a1 + 56));
                uint64_t v109 = 45;
                if (v107) {
                  uint64_t v109 = 43;
                }
                v105(3, "%c[%{public}s %{public}s]:%i Not writable", v109, v108, v125, 1161);
              }
              dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
              __int16 v110 = NFSharedLogGetLogger();
              if (os_log_type_enabled(v110, OS_LOG_TYPE_ERROR))
              {
                id v111 = object_getClass(*(id *)(a1 + 32));
                if (class_isMetaClass(v111)) {
                  int v112 = 43;
                }
                else {
                  int v112 = 45;
                }
                __int16 v113 = object_getClassName(*(id *)(a1 + 32));
                __int16 v114 = sel_getName(*(SEL *)(a1 + 56));
                *(_DWORD *)long long buf = 67109890;
                int v142 = v112;
                __int16 v143 = 2082;
                int v144 = v113;
                __int16 v145 = 2082;
                unsigned int v146 = v114;
                __int16 v147 = 1024;
                int v148 = 1161;
                _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Not writable", buf, 0x22u);
              }

              uint64_t v115 = *(void *)(a1 + 48);
              id v116 = objc_alloc((Class)NSError);
              id v117 = +[NSString stringWithUTF8String:"nfcd"];
              NSErrorUserInfoKey v131 = NSLocalizedDescriptionKey;
              uint64_t v118 = +[NSString stringWithUTF8String:"Tag is Read Only"];
              __int16 v132 = v118;
              uint64_t v119 = +[NSDictionary dictionaryWithObjects:&v132 forKeys:&v131 count:1];
              id v120 = [v116 initWithDomain:v117 code:46 userInfo:v119];
              (*(void (**)(uint64_t, id))(v115 + 16))(v115, v120);
            }
            goto LABEL_26;
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          uint64_t v94 = NFLogGetLogger();
          if (v94)
          {
            uint64_t v95 = (void (*)(uint64_t, const char *, ...))v94;
            __int16 v96 = object_getClass(*(id *)(a1 + 32));
            BOOL v97 = class_isMetaClass(v96);
            NSErrorUserInfoKey v121 = object_getClassName(*(id *)(a1 + 32));
            __int16 v124 = sel_getName(*(SEL *)(a1 + 56));
            uint64_t v98 = 45;
            if (v97) {
              uint64_t v98 = 43;
            }
            v95(3, "%c[%{public}s %{public}s]:%i Failed to query NDEF capability, %{public}@", v98, v121, v124, 1155, v38);
          }
          dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
          id v99 = NFSharedLogGetLogger();
          if (os_log_type_enabled(v99, OS_LOG_TYPE_ERROR))
          {
            uint64_t v100 = object_getClass(*(id *)(a1 + 32));
            if (class_isMetaClass(v100)) {
              int v101 = 43;
            }
            else {
              int v101 = 45;
            }
            __int16 v102 = object_getClassName(*(id *)(a1 + 32));
            int v103 = sel_getName(*(SEL *)(a1 + 56));
            *(_DWORD *)long long buf = 67110146;
            int v142 = v101;
            __int16 v143 = 2082;
            int v144 = v102;
            __int16 v145 = 2082;
            unsigned int v146 = v103;
            __int16 v147 = 1024;
            int v148 = 1155;
            __int16 v149 = 2114;
            id v150 = v38;
            _os_log_impl((void *)&_mh_execute_header, v99, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Failed to query NDEF capability, %{public}@", buf, 0x2Cu);
          }
        }
        (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
        goto LABEL_26;
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v68 = NFLogGetLogger();
      if (v68)
      {
        __int16 v69 = (void (*)(uint64_t, const char *, ...))v68;
        int v70 = object_getClass(*(id *)(a1 + 32));
        BOOL v71 = class_isMetaClass(v70);
        __int16 v72 = object_getClassName(*(id *)(a1 + 32));
        BOOL v123 = sel_getName(*(SEL *)(a1 + 56));
        uint64_t v73 = 45;
        if (v71) {
          uint64_t v73 = 43;
        }
        v69(3, "%c[%{public}s %{public}s]:%i Invalid parameter", v73, v72, v123, 1136);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v74 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
      {
        __int16 v75 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v75)) {
          int v76 = 43;
        }
        else {
          int v76 = 45;
        }
        char v77 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v78 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)long long buf = 67109890;
        int v142 = v76;
        __int16 v143 = 2082;
        int v144 = v77;
        __int16 v145 = 2082;
        unsigned int v146 = v78;
        __int16 v147 = 1024;
        int v148 = 1136;
        _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid parameter", buf, 0x22u);
      }

      uint64_t v36 = *(void *)(a1 + 48);
      id v79 = objc_alloc((Class)NSError);
      id v38 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v135 = NSLocalizedDescriptionKey;
      __int16 v39 = +[NSString stringWithUTF8String:"Invalid Parameter"];
      int v136 = v39;
      id v40 = +[NSDictionary dictionaryWithObjects:&v136 forKeys:&v135 count:1];
      uint64_t v41 = v79;
      id v42 = v38;
      uint64_t v43 = 10;
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v56 = NFLogGetLogger();
      if (v56)
      {
        uint64_t v57 = (void (*)(uint64_t, const char *, ...))v56;
        NSErrorUserInfoKey v58 = object_getClass(*(id *)(a1 + 32));
        BOOL v59 = class_isMetaClass(v58);
        BOOL v60 = object_getClassName(*(id *)(a1 + 32));
        __int16 v122 = sel_getName(*(SEL *)(a1 + 56));
        uint64_t v61 = 45;
        if (v59) {
          uint64_t v61 = 43;
        }
        v57(3, "%c[%{public}s %{public}s]:%i Tag not connected", v61, v60, v122, 1130);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v62 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
      {
        int v63 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v63)) {
          int v64 = 43;
        }
        else {
          int v64 = 45;
        }
        int v65 = object_getClassName(*(id *)(a1 + 32));
        __int16 v66 = sel_getName(*(SEL *)(a1 + 56));
        *(_DWORD *)long long buf = 67109890;
        int v142 = v64;
        __int16 v143 = 2082;
        int v144 = v65;
        __int16 v145 = 2082;
        unsigned int v146 = v66;
        __int16 v147 = 1024;
        int v148 = 1130;
        _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Tag not connected", buf, 0x22u);
      }

      uint64_t v36 = *(void *)(a1 + 48);
      id v67 = objc_alloc((Class)NSError);
      id v38 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v137 = NSLocalizedDescriptionKey;
      __int16 v39 = +[NSString stringWithUTF8String:"Tag Not Found"];
      id v138 = v39;
      id v40 = +[NSDictionary dictionaryWithObjects:&v138 forKeys:&v137 count:1];
      uint64_t v41 = v67;
      id v42 = v38;
      uint64_t v43 = 28;
    }
LABEL_24:
    id v44 = [v41 initWithDomain:v42 code:v43 userInfo:v40];
    (*(void (**)(uint64_t, id))(v36 + 16))(v36, v44);

LABEL_25:
LABEL_26:

    return;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v22 = NFLogGetLogger();
  if (v22)
  {
    uint64_t v23 = (void (*)(uint64_t, const char *, ...))v22;
    id v24 = object_getClass(*(id *)(a1 + 32));
    BOOL v25 = class_isMetaClass(v24);
    unsigned int v26 = object_getClassName(*(id *)(a1 + 32));
    unsigned int v27 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v28 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v29 = 45;
    if (v25) {
      uint64_t v29 = 43;
    }
    v23(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v29, v26, v27, 1127, v28);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v30 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    int v31 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v31)) {
      int v32 = 43;
    }
    else {
      int v32 = 45;
    }
    id v33 = object_getClassName(*(id *)(a1 + 32));
    int v34 = sel_getName(*(SEL *)(a1 + 56));
    id v35 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v142 = v32;
    __int16 v143 = 2082;
    int v144 = v33;
    __int16 v145 = 2082;
    unsigned int v146 = v34;
    __int16 v147 = 1024;
    int v148 = 1127;
    __int16 v149 = 2114;
    id v150 = v35;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v36 = *(void *)(a1 + 48);
  if (v36)
  {
    id v37 = objc_alloc((Class)NSError);
    id v38 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v139 = NSLocalizedDescriptionKey;
    __int16 v39 = +[NSString stringWithUTF8String:"Session not active"];
    unsigned int v140 = v39;
    id v40 = +[NSDictionary dictionaryWithObjects:&v140 forKeys:&v139 count:1];
    uint64_t v41 = v37;
    id v42 = v38;
    uint64_t v43 = 54;
    goto LABEL_24;
  }
}

void sub_1001BBDD8(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 56));
    int v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = [*(id *)(a1 + 32) connection];
    id v10 = [v9 processIdentifier];
    id v11 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v12 = 43;
    if (!isMetaClass) {
      uint64_t v12 = 45;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@ (%d) %{public}@", v12, ClassName, Name, 1173, v8, v10, v11);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v13 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14)) {
      int v15 = 43;
    }
    else {
      int v15 = 45;
    }
    uint64_t v16 = object_getClassName(*(id *)(a1 + 32));
    id v17 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v18 = [*(id *)(a1 + 32) clientName];
    uint64_t v19 = [*(id *)(a1 + 32) connection];
    unsigned int v20 = [v19 processIdentifier];
    id v21 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110658;
    int v81 = v15;
    __int16 v82 = 2082;
    uint64_t v83 = v16;
    __int16 v84 = 2082;
    uint64_t v85 = v17;
    __int16 v86 = 1024;
    int v87 = 1173;
    __int16 v88 = 2114;
    uint64_t v89 = v18;
    __int16 v90 = 1024;
    unsigned int v91 = v20;
    __int16 v92 = 2114;
    id v93 = v21;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@ (%d) %{public}@", buf, 0x3Cu);
  }
  if ([*(id *)(a1 + 32) didStart]
    && ([*(id *)(a1 + 32) isSuspended] & 1) == 0
    && ![*(id *)(a1 + 32) didEnd])
  {
    uint64_t v45 = *(void **)(a1 + 32);
    if (v45[43])
    {
      unsigned int v46 = [v45 _refreshNdefTagConnection];
      if (!v46)
      {
        uint64_t v69 = *(void *)(a1 + 32);
        uint64_t v68 = *(void **)(a1 + 40);
        int v70 = *(void **)(v69 + 312);
        BOOL v71 = *(void **)(v69 + 344);
        id v73 = 0;
        sub_100194DE0(v70, v71, v68, &v73);
        id v38 = v73;
        (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
        goto LABEL_26;
      }
      unsigned int v47 = v46;
      uint64_t v48 = *(void *)(a1 + 48);
      id v49 = objc_alloc((Class)NSError);
      id v38 = +[NSString stringWithUTF8String:"nfcd"];
      uint64_t v50 = v47;
      v74[0] = NSLocalizedDescriptionKey;
      if (v47 >= 0x47) {
        int v51 = 71;
      }
      else {
        int v51 = v47;
      }
      __int16 v39 = +[NSString stringWithUTF8String:off_100306978[v51]];
      v75[0] = v39;
      v75[1] = &off_10031D890;
      v74[1] = @"Line";
      void v74[2] = @"Method";
      id v52 = [objc_alloc((Class)NSString) initWithFormat:@"%s", sel_getName(*(SEL *)(a1 + 56))];
      v75[2] = v52;
      v74[3] = NSDebugDescriptionErrorKey;
      id v53 = [objc_alloc((Class)NSString) initWithFormat:@"%s:%d", sel_getName(*(SEL *)(a1 + 56)), 1185];
      v75[3] = v53;
      id v54 = +[NSDictionary dictionaryWithObjects:v75 forKeys:v74 count:4];
      id v55 = [v49 initWithDomain:v38 code:v50 userInfo:v54];
      (*(void (**)(uint64_t, id))(v48 + 16))(v48, v55);

LABEL_25:
LABEL_26:

      return;
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v56 = NFLogGetLogger();
    if (v56)
    {
      uint64_t v57 = (void (*)(uint64_t, const char *, ...))v56;
      NSErrorUserInfoKey v58 = object_getClass(*(id *)(a1 + 32));
      BOOL v59 = class_isMetaClass(v58);
      BOOL v60 = object_getClassName(*(id *)(a1 + 32));
      __int16 v72 = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v61 = 45;
      if (v59) {
        uint64_t v61 = 43;
      }
      v57(3, "%c[%{public}s %{public}s]:%i Invalid tag state", v61, v60, v72, 1178);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v62 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
    {
      int v63 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v63)) {
        int v64 = 43;
      }
      else {
        int v64 = 45;
      }
      int v65 = object_getClassName(*(id *)(a1 + 32));
      __int16 v66 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)long long buf = 67109890;
      int v81 = v64;
      __int16 v82 = 2082;
      uint64_t v83 = v65;
      __int16 v84 = 2082;
      uint64_t v85 = v66;
      __int16 v86 = 1024;
      int v87 = 1178;
      _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid tag state", buf, 0x22u);
    }

    uint64_t v36 = *(void *)(a1 + 48);
    id v67 = objc_alloc((Class)NSError);
    id v38 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v76 = NSLocalizedDescriptionKey;
    __int16 v39 = +[NSString stringWithUTF8String:"Invalid State"];
    char v77 = v39;
    id v40 = +[NSDictionary dictionaryWithObjects:&v77 forKeys:&v76 count:1];
    uint64_t v41 = v67;
    id v42 = v38;
    uint64_t v43 = 12;
LABEL_24:
    id v44 = [v41 initWithDomain:v42 code:v43 userInfo:v40];
    (*(void (**)(uint64_t, id))(v36 + 16))(v36, v44);

    goto LABEL_25;
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v22 = NFLogGetLogger();
  if (v22)
  {
    uint64_t v23 = (void (*)(uint64_t, const char *, ...))v22;
    id v24 = object_getClass(*(id *)(a1 + 32));
    BOOL v25 = class_isMetaClass(v24);
    unsigned int v26 = object_getClassName(*(id *)(a1 + 32));
    unsigned int v27 = sel_getName(*(SEL *)(a1 + 56));
    uint64_t v28 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v29 = 45;
    if (v25) {
      uint64_t v29 = 43;
    }
    v23(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v29, v26, v27, 1175, v28);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v30 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
  {
    int v31 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v31)) {
      int v32 = 43;
    }
    else {
      int v32 = 45;
    }
    id v33 = object_getClassName(*(id *)(a1 + 32));
    int v34 = sel_getName(*(SEL *)(a1 + 56));
    id v35 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110146;
    int v81 = v32;
    __int16 v82 = 2082;
    uint64_t v83 = v33;
    __int16 v84 = 2082;
    uint64_t v85 = v34;
    __int16 v86 = 1024;
    int v87 = 1175;
    __int16 v88 = 2114;
    uint64_t v89 = v35;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
  }
  uint64_t v36 = *(void *)(a1 + 48);
  if (v36)
  {
    id v37 = objc_alloc((Class)NSError);
    id v38 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v78 = NSLocalizedDescriptionKey;
    __int16 v39 = +[NSString stringWithUTF8String:"Session not active"];
    id v79 = v39;
    id v40 = +[NSDictionary dictionaryWithObjects:&v79 forKeys:&v78 count:1];
    uint64_t v41 = v37;
    id v42 = v38;
    uint64_t v43 = 54;
    goto LABEL_24;
  }
}

void sub_1001BC680(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    int v8 = [*(id *)(a1 + 32) clientName];
    uint64_t v9 = [*(id *)(a1 + 32) connection];
    id v10 = [v9 processIdentifier];
    id v11 = [*(id *)(a1 + 32) sessionUID];
    uint64_t v12 = 43;
    if (!isMetaClass) {
      uint64_t v12 = 45;
    }
    v3(6, "%c[%{public}s %{public}s]:%i %{public}@ (%d) %{public}@", v12, ClassName, Name, 1199, v8, v10, v11);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  id v13 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v14 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v14)) {
      int v15 = 43;
    }
    else {
      int v15 = 45;
    }
    uint64_t v16 = object_getClassName(*(id *)(a1 + 32));
    id v17 = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v18 = [*(id *)(a1 + 32) clientName];
    uint64_t v19 = [*(id *)(a1 + 32) connection];
    unsigned int v20 = [v19 processIdentifier];
    id v21 = [*(id *)(a1 + 32) sessionUID];
    *(_DWORD *)long long buf = 67110658;
    int v102 = v15;
    __int16 v103 = 2082;
    uint64_t v104 = v16;
    __int16 v105 = 2082;
    uint64_t v106 = v17;
    __int16 v107 = 1024;
    int v108 = 1199;
    __int16 v109 = 2114;
    __int16 v110 = v18;
    __int16 v111 = 1024;
    unsigned int v112 = v20;
    __int16 v113 = 2114;
    __int16 v114 = v21;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i %{public}@ (%d) %{public}@", buf, 0x3Cu);
  }
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v22 = NFLogGetLogger();
    if (v22)
    {
      uint64_t v23 = (void (*)(uint64_t, const char *, ...))v22;
      id v24 = object_getClass(*(id *)(a1 + 32));
      BOOL v25 = class_isMetaClass(v24);
      unsigned int v26 = object_getClassName(*(id *)(a1 + 32));
      unsigned int v27 = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v28 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v29 = 45;
      if (v25) {
        uint64_t v29 = 43;
      }
      v23(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v29, v26, v27, 1201, v28);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v30 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      int v31 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v31)) {
        int v32 = 43;
      }
      else {
        int v32 = 45;
      }
      id v33 = object_getClassName(*(id *)(a1 + 32));
      int v34 = sel_getName(*(SEL *)(a1 + 48));
      id v35 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)long long buf = 67110146;
      int v102 = v32;
      __int16 v103 = 2082;
      uint64_t v104 = v33;
      __int16 v105 = 2082;
      uint64_t v106 = v34;
      __int16 v107 = 1024;
      int v108 = 1201;
      __int16 v109 = 2114;
      __int16 v110 = v35;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v36 = *(void *)(a1 + 40);
    if (v36)
    {
      id v37 = objc_alloc((Class)NSError);
      id v38 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v99 = NSLocalizedDescriptionKey;
      __int16 v39 = +[NSString stringWithUTF8String:"Session not active"];
      uint64_t v100 = v39;
      id v40 = +[NSDictionary dictionaryWithObjects:&v100 forKeys:&v99 count:1];
      id v41 = [v37 initWithDomain:v38 code:54 userInfo:v40];
      (*(void (**)(uint64_t, id, void))(v36 + 16))(v36, v41, 0);
    }
  }
  else
  {
    uint64_t v42 = *(void *)(a1 + 32);
    uint64_t v43 = *(void **)(v42 + 344);
    if (v43)
    {
      unsigned int v44 = sub_100194CFC(*(void **)(v42 + 312), v43);
      if (v44)
      {
        unsigned int v45 = v44;
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        uint64_t v46 = NFLogGetLogger();
        if (v46)
        {
          unsigned int v47 = (void (*)(uint64_t, const char *, ...))v46;
          uint64_t v48 = object_getClass(*(id *)(a1 + 32));
          BOOL v49 = class_isMetaClass(v48);
          uint64_t v50 = object_getClassName(*(id *)(a1 + 32));
          int v51 = sel_getName(*(SEL *)(a1 + 48));
          if (v45 == 28) {
            id v52 = "NFResultTagNotFound";
          }
          else {
            id v52 = "NFResultRFDeactivated";
          }
          uint64_t v53 = 45;
          if (v49) {
            uint64_t v53 = 43;
          }
          v47(3, "%c[%{public}s %{public}s]:%i checkTagPresence return error: %s", v53, v50, v51, 1213, v52);
        }
        dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
        id v54 = NFSharedLogGetLogger();
        if (os_log_type_enabled(v54, OS_LOG_TYPE_ERROR))
        {
          id v55 = object_getClass(*(id *)(a1 + 32));
          if (class_isMetaClass(v55)) {
            int v56 = 43;
          }
          else {
            int v56 = 45;
          }
          uint64_t v57 = object_getClassName(*(id *)(a1 + 32));
          NSErrorUserInfoKey v58 = sel_getName(*(SEL *)(a1 + 48));
          *(_DWORD *)long long buf = 67110146;
          if (v45 == 28) {
            BOOL v59 = "NFResultTagNotFound";
          }
          else {
            BOOL v59 = "NFResultRFDeactivated";
          }
          int v102 = v56;
          __int16 v103 = 2082;
          uint64_t v104 = v57;
          __int16 v105 = 2082;
          uint64_t v106 = v58;
          __int16 v107 = 1024;
          int v108 = 1213;
          __int16 v109 = 2080;
          __int16 v110 = v59;
          _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i checkTagPresence return error: %s", buf, 0x2Cu);
        }

        BOOL v60 = sub_10023D968();
        id v61 = objc_alloc((Class)NSError);
        uint64_t v62 = +[NSString stringWithUTF8String:"nfcd"];
        uint64_t v63 = v45;
        NSErrorUserInfoKey v95 = NSLocalizedDescriptionKey;
        if (v45 >= 0x47) {
          int v64 = 71;
        }
        else {
          int v64 = v45;
        }
        int v65 = off_100306978[v64];
        __int16 v66 = +[NSString stringWithUTF8String:v65];
        __int16 v96 = v66;
        id v67 = +[NSDictionary dictionaryWithObjects:&v96 forKeys:&v95 count:1];
        id v68 = [v61 initWithDomain:v62 code:v63 userInfo:v67];
        sub_10023E114((uint64_t)v60, v68);

        uint64_t v69 = *(void *)(a1 + 40);
        id v70 = objc_alloc((Class)NSError);
        BOOL v71 = +[NSString stringWithUTF8String:"nfcd"];
        NSErrorUserInfoKey v93 = NSLocalizedDescriptionKey;
        __int16 v72 = +[NSString stringWithUTF8String:v65];
        uint64_t v94 = v72;
        id v73 = +[NSDictionary dictionaryWithObjects:&v94 forKeys:&v93 count:1];
        id v74 = [v70 initWithDomain:v71 code:v63 userInfo:v73];
        (*(void (**)(uint64_t, id, void))(v69 + 16))(v69, v74, 0);
      }
      else
      {
        (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
      }
    }
    else
    {
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      uint64_t v75 = NFLogGetLogger();
      if (v75)
      {
        NSErrorUserInfoKey v76 = (void (*)(uint64_t, const char *, ...))v75;
        char v77 = object_getClass(*(id *)(a1 + 32));
        BOOL v78 = class_isMetaClass(v77);
        id v79 = object_getClassName(*(id *)(a1 + 32));
        __int16 v92 = sel_getName(*(SEL *)(a1 + 48));
        uint64_t v80 = 45;
        if (v78) {
          uint64_t v80 = 43;
        }
        v76(3, "%c[%{public}s %{public}s]:%i Invalid tag state", v80, v79, v92, 1204);
      }
      dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
      int v81 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
      {
        __int16 v82 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v82)) {
          int v83 = 43;
        }
        else {
          int v83 = 45;
        }
        __int16 v84 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v85 = sel_getName(*(SEL *)(a1 + 48));
        *(_DWORD *)long long buf = 67109890;
        int v102 = v83;
        __int16 v103 = 2082;
        uint64_t v104 = v84;
        __int16 v105 = 2082;
        uint64_t v106 = v85;
        __int16 v107 = 1024;
        int v108 = 1204;
        _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Invalid tag state", buf, 0x22u);
      }

      uint64_t v86 = *(void *)(a1 + 40);
      id v87 = objc_alloc((Class)NSError);
      __int16 v88 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v97 = NSLocalizedDescriptionKey;
      uint64_t v89 = +[NSString stringWithUTF8String:"Invalid State"];
      uint64_t v98 = v89;
      __int16 v90 = +[NSDictionary dictionaryWithObjects:&v98 forKeys:&v97 count:1];
      id v91 = [v87 initWithDomain:v88 code:12 userInfo:v90];
      (*(void (**)(uint64_t, id, void))(v86 + 16))(v86, v91, 0);
    }
  }
}

id sub_1001BE448(uint64_t a1)
{
  if (([*(id *)(a1 + 32) didEnd] & 1) != 0
    || [*(id *)(a1 + 32) isSuspended])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v7 = 45;
      if (isMetaClass) {
        uint64_t v7 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session has been terminated / suspended", v7, ClassName, Name, 1353);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v8 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v9)) {
        int v10 = 43;
      }
      else {
        int v10 = 45;
      }
      id v11 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v12 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)long long buf = 67109890;
      *(_DWORD *)uint64_t v43 = v10;
      *(_WORD *)&void v43[4] = 2082;
      *(void *)&v43[6] = v11;
      *(_WORD *)&v43[14] = 2082;
      *(void *)&v43[16] = v12;
      __int16 v44 = 1024;
      int v45 = 1353;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session has been terminated / suspended", buf, 0x22u);
    }

    id v13 = objc_alloc((Class)NSError);
    unsigned int v14 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v48 = NSLocalizedDescriptionKey;
    int v15 = +[NSString stringWithUTF8String:"Invalid State"];
    BOOL v49 = v15;
    uint64_t v16 = +[NSDictionary dictionaryWithObjects:&v49 forKeys:&v48 count:1];
    id v17 = [v13 initWithDomain:v14 code:12 userInfo:v16];
  }
  else
  {
    id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 320));
    sub_1001B0E88((uint64_t)WeakRetained, *(void **)(a1 + 32));

    uint64_t v19 = +[_NFHardwareManager sharedHardwareManager];
    [v19 notifyReaderModeActivityEnd];

    *(void *)(*(void *)(a1 + 32) + 20_Block_object_dispose(&STACK[0x260], 8) = *(void *)(a1 + 48);
    if ((*(unsigned char *)(a1 + 57) & 8) != 0) {
      +[NFRoutingConfig readerWithLPCD:1 fieldDetect:2 pollDuration:0 ecp:0];
    }
    else {
    unsigned int v14 = +[NFRoutingConfig readerModeWithFD:2];
    }
    [v14 setPollingMask:*(unsigned int *)(*(void *)(a1 + 32) + 280) tagConfig:objc_msgSend(*(id *)(a1 + 32), "_getTagNotificationConfig")];
    if (*(unsigned char *)(a1 + 64))
    {
      v43[0] = 2;
      *(_DWORD *)long long buf = 4194666;
      id v20 = [objc_alloc((Class)NSData) initWithBytes:buf length:5];
      id v21 = +[_NFHardwareManager sharedHardwareManager];
      [v21 configureECPPolling:v20];
    }
    uint64_t v22 = +[_NFHardwareManager sharedHardwareManager];
    id v17 = [v22 setRoutingConfig:v14];

    if (!v17)
    {
      uint64_t v23 = NFLogGetLogger();
      if (v23)
      {
        id v24 = (void (*)(uint64_t, const char *, ...))v23;
        BOOL v25 = object_getClass(*(id *)(a1 + 32));
        BOOL v26 = class_isMetaClass(v25);
        unsigned int v27 = object_getClassName(*(id *)(a1 + 32));
        uint64_t v28 = sel_getName(*(SEL *)(a1 + 40));
        uint64_t v29 = [*(id *)(a1 + 32) clientName];
        uint64_t v30 = 45;
        if (v26) {
          uint64_t v30 = 43;
        }
        v24(6, "%c[%{public}s %{public}s]:%i NFC Reader mode activated: %@", v30, v27, v28, 1380, v29);
      }
      int v31 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v31, OS_LOG_TYPE_DEFAULT))
      {
        int v32 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v32)) {
          int v33 = 43;
        }
        else {
          int v33 = 45;
        }
        int v34 = object_getClassName(*(id *)(a1 + 32));
        id v35 = sel_getName(*(SEL *)(a1 + 40));
        uint64_t v36 = [*(id *)(a1 + 32) clientName];
        *(_DWORD *)long long buf = 67110146;
        *(_DWORD *)uint64_t v43 = v33;
        *(_WORD *)&void v43[4] = 2082;
        *(void *)&v43[6] = v34;
        *(_WORD *)&v43[14] = 2082;
        *(void *)&v43[16] = v35;
        __int16 v44 = 1024;
        int v45 = 1380;
        __int16 v46 = 2112;
        unsigned int v47 = v36;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NFC Reader mode activated: %@", buf, 0x2Cu);
      }
      id v37 = NFSharedSignpostLog();
      if (os_signpost_enabled(v37))
      {
        unsigned int v38 = [*(id *)(a1 + 32) _isCoreNFCSession];
        uint64_t v39 = *(void *)(*(void *)(a1 + 32) + 360);
        *(_DWORD *)long long buf = 134349312;
        *(void *)uint64_t v43 = v38;
        *(_WORD *)&v43[8] = 2050;
        *(void *)&v43[10] = v39;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v37, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "Polling", " coreNFC=%{public,signpost.description:attribute}lu  sessionType=%{public,signpost.description:attribute}lu ", buf, 0x16u);
      }
    }
    int v15 = sub_10023D968();
    sub_10023E740((uint64_t)v15, *(void *)(*(void *)(a1 + 32) + 208));
  }

  return v17;
}

void sub_1001BE9C4(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      BOOL v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v8 = 45;
      if (isMetaClass) {
        uint64_t v8 = 43;
      }
      v5(6, "%c[%{public}s %{public}s]:%i Not ready: %{public}@", v8, ClassName, Name, 1397, v3);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      uint64_t v12 = object_getClassName(*(id *)(a1 + 32));
      id v13 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)long long buf = 67110146;
      int v26 = v11;
      __int16 v27 = 2082;
      uint64_t v28 = v12;
      __int16 v29 = 2082;
      uint64_t v30 = v13;
      __int16 v31 = 1024;
      int v32 = 1397;
      __int16 v33 = 2114;
      id v34 = v3;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Not ready: %{public}@", buf, 0x2Cu);
    }

    uint64_t v14 = *(void *)(a1 + 40);
    id v15 = objc_alloc((Class)NSError);
    uint64_t v16 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v23 = NSLocalizedDescriptionKey;
    id v17 = +[NSString stringWithUTF8String:"Busy"];
    id v24 = v17;
    uint64_t v18 = +[NSDictionary dictionaryWithObjects:&v24 forKeys:&v23 count:1];
    id v19 = [v15 initWithDomain:v16 code:2 userInfo:v18];
    (*(void (**)(uint64_t, id))(v14 + 16))(v14, v19);
  }
  else
  {
    uint64_t v20 = *(void *)(a1 + 40);
    uint64_t v16 = (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    (*(void (**)(uint64_t, void *))(v20 + 16))(v20, v16);
  }
}

void sub_1001BF080(uint64_t a1)
{
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 1433, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      int v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      id v13 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v14 = sel_getName(*(SEL *)(a1 + 56));
      id v15 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)long long buf = 67110146;
      int v28 = v12;
      __int16 v29 = 2082;
      uint64_t v30 = v13;
      __int16 v31 = 2082;
      int v32 = v14;
      __int16 v33 = 1024;
      int v34 = 1433;
      __int16 v35 = 2114;
      uint64_t v36 = v15;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v16 = *(void *)(a1 + 48);
    if (v16)
    {
      id v17 = objc_alloc((Class)NSError);
      uint64_t v18 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v25 = NSLocalizedDescriptionKey;
      id v19 = +[NSString stringWithUTF8String:"Session not active"];
      int v26 = v19;
      uint64_t v20 = +[NSDictionary dictionaryWithObjects:&v26 forKeys:&v25 count:1];
      id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
      (*(void (**)(uint64_t, id))(v16 + 16))(v16, v21);
    }
  }
  else
  {
    uint64_t v22 = *(void **)(a1 + 32);
    uint64_t v23 = *(void *)(a1 + 40);
    uint64_t v24 = *(void *)(a1 + 48);
    [v22 _sync_setECPPayload:v23 completion:v24];
  }
}

void sub_1001BF4C0(uint64_t a1)
{
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 1463, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      int v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      id v13 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
      id v15 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)long long buf = 67110146;
      int v29 = v12;
      __int16 v30 = 2082;
      __int16 v31 = v13;
      __int16 v32 = 2082;
      __int16 v33 = v14;
      __int16 v34 = 1024;
      int v35 = 1463;
      __int16 v36 = 2114;
      id v37 = v15;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v16 = *(void *)(a1 + 40);
    if (v16)
    {
      id v17 = objc_alloc((Class)NSError);
      uint64_t v18 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v26 = NSLocalizedDescriptionKey;
      id v19 = +[NSString stringWithUTF8String:"Session not active"];
      __int16 v27 = v19;
      uint64_t v20 = +[NSDictionary dictionaryWithObjects:&v27 forKeys:&v26 count:1];
      id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
      (*(void (**)(uint64_t, id))(v16 + 16))(v16, v21);
    }
  }
  else
  {
    uint64_t v22 = *(void *)(a1 + 56);
    uint64_t v23 = *(void *)(a1 + 64);
    uint64_t v24 = *(void **)(a1 + 32);
    uint64_t v25 = *(void *)(a1 + 40);
    [v24 _sync_startPollingForTags:v22 sessionConfig:v23 completion:v25];
  }
}

void sub_1001BF880(uint64_t a1)
{
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t Logger = NFLogGetLogger();
  if (Logger)
  {
    id v3 = (void (*)(uint64_t, const char *, ...))Logger;
    Class = object_getClass(*(id *)(a1 + 32));
    BOOL isMetaClass = class_isMetaClass(Class);
    ClassName = object_getClassName(*(id *)(a1 + 32));
    Name = sel_getName(*(SEL *)(a1 + 48));
    uint64_t v7 = 45;
    if (isMetaClass) {
      uint64_t v7 = 43;
    }
    v3(6, "%c[%{public}s %{public}s]:%i ", v7, ClassName, Name, 1472);
  }
  dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
  uint64_t v8 = NFSharedLogGetLogger();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v9 = object_getClass(*(id *)(a1 + 32));
    if (class_isMetaClass(v9)) {
      int v10 = 43;
    }
    else {
      int v10 = 45;
    }
    int v11 = object_getClassName(*(id *)(a1 + 32));
    int v12 = sel_getName(*(SEL *)(a1 + 48));
    *(_DWORD *)long long buf = 67109890;
    int v37 = v10;
    __int16 v38 = 2082;
    uint64_t v39 = v11;
    __int16 v40 = 2082;
    id v41 = v12;
    __int16 v42 = 1024;
    int v43 = 1472;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i ", buf, 0x22u);
  }

  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v13 = NFLogGetLogger();
    if (v13)
    {
      uint64_t v14 = (void (*)(uint64_t, const char *, ...))v13;
      id v15 = object_getClass(*(id *)(a1 + 32));
      BOOL v16 = class_isMetaClass(v15);
      id v17 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v18 = sel_getName(*(SEL *)(a1 + 48));
      id v19 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v20 = 45;
      if (v16) {
        uint64_t v20 = 43;
      }
      v14(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v20, v17, v18, 1473, v19);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    id v21 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      uint64_t v22 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v22)) {
        int v23 = 43;
      }
      else {
        int v23 = 45;
      }
      uint64_t v24 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v25 = sel_getName(*(SEL *)(a1 + 48));
      NSErrorUserInfoKey v26 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)long long buf = 67110146;
      int v37 = v23;
      __int16 v38 = 2082;
      uint64_t v39 = v24;
      __int16 v40 = 2082;
      id v41 = v25;
      __int16 v42 = 1024;
      int v43 = 1473;
      __int16 v44 = 2114;
      int v45 = v26;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v27 = *(void *)(a1 + 40);
    if (v27)
    {
      id v28 = objc_alloc((Class)NSError);
      int v29 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v34 = NSLocalizedDescriptionKey;
      __int16 v30 = +[NSString stringWithUTF8String:"Session not active"];
      int v35 = v30;
      __int16 v31 = +[NSDictionary dictionaryWithObjects:&v35 forKeys:&v34 count:1];
      id v32 = [v28 initWithDomain:v29 code:54 userInfo:v31];
      (*(void (**)(uint64_t, id))(v27 + 16))(v27, v32);
    }
  }
  else
  {
    *(unsigned char *)(*(void *)(a1 + 32) + 306) = 1;
    (*(void (**)(void))(*(void *)(a1 + 40) + 16))();
  }
}

void sub_1001BFD58(uint64_t a1)
{
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 1484, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      int v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      uint64_t v13 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v14 = sel_getName(*(SEL *)(a1 + 56));
      id v15 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)long long buf = 67110146;
      int v28 = v12;
      __int16 v29 = 2082;
      __int16 v30 = v13;
      __int16 v31 = 2082;
      id v32 = v14;
      __int16 v33 = 1024;
      int v34 = 1484;
      __int16 v35 = 2114;
      __int16 v36 = v15;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v16 = *(void *)(a1 + 48);
    if (v16)
    {
      id v17 = objc_alloc((Class)NSError);
      uint64_t v18 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v25 = NSLocalizedDescriptionKey;
      id v19 = +[NSString stringWithUTF8String:"Session not active"];
      NSErrorUserInfoKey v26 = v19;
      uint64_t v20 = +[NSDictionary dictionaryWithObjects:&v26 forKeys:&v25 count:1];
      id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
      (*(void (**)(uint64_t, id))(v16 + 16))(v16, v21);
    }
  }
  else
  {
    uint64_t v22 = *(void **)(a1 + 32);
    uint64_t v23 = *(void *)(a1 + 40);
    uint64_t v24 = *(void *)(a1 + 48);
    [v22 _sync_startPollingWithConfig:v23 completion:v24];
  }
}

id sub_1001C11C4(uint64_t a1)
{
  if (([*(id *)(a1 + 32) didEnd] & 1) != 0
    || [*(id *)(a1 + 32) isSuspended])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 64));
      uint64_t v7 = 45;
      if (isMetaClass) {
        uint64_t v7 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session has been terminated / suspended", v7, ClassName, Name, 1580);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v8 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v9)) {
        int v10 = 43;
      }
      else {
        int v10 = 45;
      }
      int v11 = object_getClassName(*(id *)(a1 + 32));
      int v12 = sel_getName(*(SEL *)(a1 + 64));
      *(_DWORD *)long long buf = 67109890;
      *(_DWORD *)int v43 = v10;
      *(_WORD *)&void v43[4] = 2082;
      *(void *)&v43[6] = v11;
      *(_WORD *)&v43[14] = 2082;
      *(void *)&v43[16] = v12;
      __int16 v44 = 1024;
      int v45 = 1580;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session has been terminated / suspended", buf, 0x22u);
    }

    id v13 = objc_alloc((Class)NSError);
    uint64_t v14 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v48 = NSLocalizedDescriptionKey;
    id v15 = +[NSString stringWithUTF8String:"Invalid State"];
    BOOL v49 = v15;
    uint64_t v16 = +[NSDictionary dictionaryWithObjects:&v49 forKeys:&v48 count:1];
    id v17 = [v13 initWithDomain:v14 code:12 userInfo:v16];
  }
  else
  {
    id v19 = *(void **)(a1 + 40);
    if (v19) {
      id v20 = [v19 BOOLValue];
    }
    else {
      id v20 = 0;
    }
    uint64_t v21 = *(void *)(a1 + 72);
    uint64_t v22 = *(void **)(a1 + 48);
    if (v22) {
      id v23 = [v22 unsignedIntValue];
    }
    else {
      id v23 = 0;
    }
    uint64_t v14 = +[NFRoutingConfig readerWithLPCD:v20 fieldDetect:v21 pollDuration:v23 ecp:*(void *)(a1 + 56)];
    [v14 setPollingMask:*(unsigned int *)(*(void *)(a1 + 32) + 280) tagConfig:[*(id *)(a1 + 32) _getTagNotificationConfig]];
    uint64_t v24 = +[_NFHardwareManager sharedHardwareManager];
    id v17 = [v24 setRoutingConfig:v14];

    if (v17) {
      goto LABEL_14;
    }
    uint64_t v25 = NFLogGetLogger();
    if (v25)
    {
      NSErrorUserInfoKey v26 = (void (*)(uint64_t, const char *, ...))v25;
      uint64_t v27 = object_getClass(*(id *)(a1 + 32));
      BOOL v28 = class_isMetaClass(v27);
      __int16 v29 = object_getClassName(*(id *)(a1 + 32));
      __int16 v30 = sel_getName(*(SEL *)(a1 + 64));
      __int16 v31 = [*(id *)(a1 + 32) clientName];
      uint64_t v32 = 45;
      if (v28) {
        uint64_t v32 = 43;
      }
      v26(6, "%c[%{public}s %{public}s]:%i NFC Reader mode activated: %@", v32, v29, v30, 1593, v31);
    }
    __int16 v33 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v33, OS_LOG_TYPE_DEFAULT))
    {
      int v34 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v34)) {
        int v35 = 43;
      }
      else {
        int v35 = 45;
      }
      __int16 v36 = object_getClassName(*(id *)(a1 + 32));
      int v37 = sel_getName(*(SEL *)(a1 + 64));
      __int16 v38 = [*(id *)(a1 + 32) clientName];
      *(_DWORD *)long long buf = 67110146;
      *(_DWORD *)int v43 = v35;
      *(_WORD *)&void v43[4] = 2082;
      *(void *)&v43[6] = v36;
      *(_WORD *)&v43[14] = 2082;
      *(void *)&v43[16] = v37;
      __int16 v44 = 1024;
      int v45 = 1593;
      __int16 v46 = 2112;
      unsigned int v47 = v38;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NFC Reader mode activated: %@", buf, 0x2Cu);
    }
    id v15 = NFSharedSignpostLog();
    if (os_signpost_enabled(v15))
    {
      unsigned int v39 = [*(id *)(a1 + 32) _isCoreNFCSession];
      uint64_t v40 = *(void *)(*(void *)(a1 + 32) + 360);
      *(_DWORD *)long long buf = 134349312;
      *(void *)int v43 = v39;
      *(_WORD *)&v43[8] = 2050;
      *(void *)&v43[10] = v40;
      _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v15, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "Polling", " coreNFC=%{public,signpost.description:attribute}lu  sessionType=%{public,signpost.description:attribute}lu ", buf, 0x16u);
    }
    id v17 = 0;
  }

LABEL_14:

  return v17;
}

void sub_1001C168C(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      BOOL v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v8 = 45;
      if (isMetaClass) {
        uint64_t v8 = 43;
      }
      v5(6, "%c[%{public}s %{public}s]:%i Not ready: %{public}@", v8, ClassName, Name, 1608, v3);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      int v12 = object_getClassName(*(id *)(a1 + 32));
      id v13 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)long long buf = 67110146;
      int v26 = v11;
      __int16 v27 = 2082;
      BOOL v28 = v12;
      __int16 v29 = 2082;
      __int16 v30 = v13;
      __int16 v31 = 1024;
      int v32 = 1608;
      __int16 v33 = 2114;
      id v34 = v3;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Not ready: %{public}@", buf, 0x2Cu);
    }

    uint64_t v14 = *(void *)(a1 + 40);
    id v15 = objc_alloc((Class)NSError);
    uint64_t v16 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v23 = NSLocalizedDescriptionKey;
    id v17 = +[NSString stringWithUTF8String:"Busy"];
    uint64_t v24 = v17;
    uint64_t v18 = +[NSDictionary dictionaryWithObjects:&v24 forKeys:&v23 count:1];
    id v19 = [v15 initWithDomain:v16 code:2 userInfo:v18];
    (*(void (**)(uint64_t, id))(v14 + 16))(v14, v19);
  }
  else
  {
    uint64_t v20 = *(void *)(a1 + 40);
    uint64_t v16 = (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    (*(void (**)(uint64_t, void *))(v20 + 16))(v20, v16);
  }
}

void sub_1001C19EC(uint64_t a1)
{
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 1626, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      int v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      id v13 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
      id v15 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)long long buf = 67110146;
      int v28 = v12;
      __int16 v29 = 2082;
      __int16 v30 = v13;
      __int16 v31 = 2082;
      int v32 = v14;
      __int16 v33 = 1024;
      int v34 = 1626;
      __int16 v35 = 2114;
      __int16 v36 = v15;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v16 = *(void *)(a1 + 40);
    if (v16)
    {
      id v17 = objc_alloc((Class)NSError);
      uint64_t v18 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v25 = NSLocalizedDescriptionKey;
      id v19 = +[NSString stringWithUTF8String:"Session not active"];
      int v26 = v19;
      uint64_t v20 = +[NSDictionary dictionaryWithObjects:&v26 forKeys:&v25 count:1];
      id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
      (*(void (**)(uint64_t, id))(v16 + 16))(v16, v21);
    }
  }
  else
  {
    uint64_t v22 = *(void *)(a1 + 56);
    NSErrorUserInfoKey v23 = *(void **)(a1 + 32);
    uint64_t v24 = *(void *)(a1 + 40);
    [v23 _sync_startPollingForNDEFMessagesWithSessionConfig:v22 completion:v24];
  }
}

id sub_1001C2270(uint64_t a1)
{
  if (([*(id *)(a1 + 32) didEnd] & 1) != 0
    || [*(id *)(a1 + 32) isSuspended])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 40));
      uint64_t v7 = 45;
      if (isMetaClass) {
        uint64_t v7 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session has been terminated / suspended", v7, ClassName, Name, 1644);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v8 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      uint64_t v9 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v9)) {
        int v10 = 43;
      }
      else {
        int v10 = 45;
      }
      int v11 = object_getClassName(*(id *)(a1 + 32));
      int v12 = sel_getName(*(SEL *)(a1 + 40));
      *(_DWORD *)long long buf = 67109890;
      *(_DWORD *)id v41 = v10;
      *(_WORD *)&void v41[4] = 2082;
      *(void *)&v41[6] = v11;
      *(_WORD *)&v41[14] = 2082;
      *(void *)&v41[16] = v12;
      __int16 v42 = 1024;
      int v43 = 1644;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session has been terminated / suspended", buf, 0x22u);
    }

    id v13 = objc_alloc((Class)NSError);
    uint64_t v14 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v46 = NSLocalizedDescriptionKey;
    id v15 = +[NSString stringWithUTF8String:"Invalid State"];
    unsigned int v47 = v15;
    uint64_t v16 = +[NSDictionary dictionaryWithObjects:&v47 forKeys:&v46 count:1];
    id v17 = [v13 initWithDomain:v14 code:12 userInfo:v16];
  }
  else
  {
    *(void *)(*(void *)(a1 + 32) + 20_Block_object_dispose(&STACK[0x260], 8) = 2;
    *(void *)(*(void *)(a1 + 32) + 352) = *(void *)(a1 + 48);
    id WeakRetained = objc_loadWeakRetained((id *)(*(void *)(a1 + 32) + 320));
    sub_1001B0E88((uint64_t)WeakRetained, *(void **)(a1 + 32));

    id v19 = +[_NFHardwareManager sharedHardwareManager];
    [v19 notifyReaderModeActivityEnd];

    *(_DWORD *)(*(void *)(a1 + 32) + 280) = 15;
    uint64_t v14 = +[NFRoutingConfig readerModeWithFD:2];
    [v14 setPollingMask:*(unsigned int *)(*(void *)(a1 + 32) + 280) tagConfig:objc_msgSend(*(id *)(a1 + 32), "_getTagNotificationConfig")];
    uint64_t v20 = +[_NFHardwareManager sharedHardwareManager];
    id v17 = [v20 setRoutingConfig:v14];

    if (!v17)
    {
      uint64_t v21 = NFLogGetLogger();
      if (v21)
      {
        uint64_t v22 = (void (*)(uint64_t, const char *, ...))v21;
        NSErrorUserInfoKey v23 = object_getClass(*(id *)(a1 + 32));
        BOOL v24 = class_isMetaClass(v23);
        NSErrorUserInfoKey v25 = object_getClassName(*(id *)(a1 + 32));
        int v26 = sel_getName(*(SEL *)(a1 + 40));
        __int16 v27 = [*(id *)(a1 + 32) clientName];
        uint64_t v28 = 45;
        if (v24) {
          uint64_t v28 = 43;
        }
        v22(6, "%c[%{public}s %{public}s]:%i NFC Reader mode activated: %@", v28, v25, v26, 1665, v27);
      }
      __int16 v29 = NFSharedLogGetLogger();
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v30 = object_getClass(*(id *)(a1 + 32));
        if (class_isMetaClass(v30)) {
          int v31 = 43;
        }
        else {
          int v31 = 45;
        }
        int v32 = object_getClassName(*(id *)(a1 + 32));
        __int16 v33 = sel_getName(*(SEL *)(a1 + 40));
        int v34 = [*(id *)(a1 + 32) clientName];
        *(_DWORD *)long long buf = 67110146;
        *(_DWORD *)id v41 = v31;
        *(_WORD *)&void v41[4] = 2082;
        *(void *)&v41[6] = v32;
        *(_WORD *)&v41[14] = 2082;
        *(void *)&v41[16] = v33;
        __int16 v42 = 1024;
        int v43 = 1665;
        __int16 v44 = 2112;
        int v45 = v34;
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i NFC Reader mode activated: %@", buf, 0x2Cu);
      }
      __int16 v35 = NFSharedSignpostLog();
      if (os_signpost_enabled(v35))
      {
        unsigned int v36 = [*(id *)(a1 + 32) _isCoreNFCSession];
        uint64_t v37 = *(void *)(*(void *)(a1 + 32) + 360);
        *(_DWORD *)long long buf = 134349312;
        *(void *)id v41 = v36;
        *(_WORD *)&v41[8] = 2050;
        *(void *)&v41[10] = v37;
        _os_signpost_emit_with_name_impl((void *)&_mh_execute_header, v35, OS_SIGNPOST_INTERVAL_BEGIN, 0xEEEEB0B5B2B2EEEELL, "Polling", " coreNFC=%{public,signpost.description:attribute}lu  sessionType=%{public,signpost.description:attribute}lu ", buf, 0x16u);
      }
    }
    id v15 = sub_10023D968();
    sub_10023E740((uint64_t)v15, *(void *)(*(void *)(a1 + 32) + 208));
  }

  return v17;
}

void sub_1001C2788(uint64_t a1, void *a2)
{
  id v3 = a2;
  if (v3)
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      BOOL v5 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 56));
      uint64_t v8 = 45;
      if (isMetaClass) {
        uint64_t v8 = 43;
      }
      v5(6, "%c[%{public}s %{public}s]:%i Not ready: %{public}@", v8, ClassName, Name, 1682, v3);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t v9 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v10)) {
        int v11 = 43;
      }
      else {
        int v11 = 45;
      }
      int v12 = object_getClassName(*(id *)(a1 + 32));
      id v13 = sel_getName(*(SEL *)(a1 + 56));
      *(_DWORD *)long long buf = 67110146;
      int v26 = v11;
      __int16 v27 = 2082;
      uint64_t v28 = v12;
      __int16 v29 = 2082;
      __int16 v30 = v13;
      __int16 v31 = 1024;
      int v32 = 1682;
      __int16 v33 = 2114;
      id v34 = v3;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%c[%{public}s %{public}s]:%i Not ready: %{public}@", buf, 0x2Cu);
    }

    uint64_t v14 = *(void *)(a1 + 40);
    id v15 = objc_alloc((Class)NSError);
    uint64_t v16 = +[NSString stringWithUTF8String:"nfcd"];
    NSErrorUserInfoKey v23 = NSLocalizedDescriptionKey;
    id v17 = +[NSString stringWithUTF8String:"Busy"];
    BOOL v24 = v17;
    uint64_t v18 = +[NSDictionary dictionaryWithObjects:&v24 forKeys:&v23 count:1];
    id v19 = [v15 initWithDomain:v16 code:2 userInfo:v18];
    (*(void (**)(uint64_t, id))(v14 + 16))(v14, v19);
  }
  else
  {
    uint64_t v20 = *(void *)(a1 + 40);
    uint64_t v16 = (*(void (**)(void))(*(void *)(a1 + 48) + 16))();
    (*(void (**)(uint64_t, void *))(v20 + 16))(v20, v16);
  }
}

void sub_1001C2ADC(uint64_t a1)
{
  if (![*(id *)(a1 + 32) didStart]
    || ([*(id *)(a1 + 32) isSuspended] & 1) != 0
    || [*(id *)(a1 + 32) didEnd])
  {
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    uint64_t Logger = NFLogGetLogger();
    if (Logger)
    {
      id v3 = (void (*)(uint64_t, const char *, ...))Logger;
      Class = object_getClass(*(id *)(a1 + 32));
      BOOL isMetaClass = class_isMetaClass(Class);
      ClassName = object_getClassName(*(id *)(a1 + 32));
      Name = sel_getName(*(SEL *)(a1 + 48));
      uint64_t v8 = [*(id *)(a1 + 32) sessionUID];
      uint64_t v9 = 45;
      if (isMetaClass) {
        uint64_t v9 = 43;
      }
      v3(3, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", v9, ClassName, Name, 1700, v8);
    }
    dispatch_get_specific(kNFLOG_DISPATCH_SPECIFIC_KEY);
    int v10 = NFSharedLogGetLogger();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      int v11 = object_getClass(*(id *)(a1 + 32));
      if (class_isMetaClass(v11)) {
        int v12 = 43;
      }
      else {
        int v12 = 45;
      }
      id v13 = object_getClassName(*(id *)(a1 + 32));
      uint64_t v14 = sel_getName(*(SEL *)(a1 + 48));
      id v15 = [*(id *)(a1 + 32) sessionUID];
      *(_DWORD *)long long buf = 67110146;
      int v27 = v12;
      __int16 v28 = 2082;
      __int16 v29 = v13;
      __int16 v30 = 2082;
      __int16 v31 = v14;
      __int16 v32 = 1024;
      int v33 = 1700;
      __int16 v34 = 2114;
      __int16 v35 = v15;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%c[%{public}s %{public}s]:%i Session %{public}@ is not active", buf, 0x2Cu);
    }
    uint64_t v16 = *(void *)(a1 + 40);
    if (v16)
    {
      id v17 = objc_alloc((Class)NSError);
      uint64_t v18 = +[NSString stringWithUTF8String:"nfcd"];
      NSErrorUserInfoKey v24 = NSLocalizedDescriptionKey;
      id v19 = +[NSString stringWithUTF8String:"Session not active"];
      NSErrorUserInfoKey v25 = v19;
      uint64_t v20 = +[NSDictionary dictionaryWithObjects:&v25 forKeys:&v24 count:1];
      id v21 = [v17 initWithDomain:v18 code:54 userInfo:v20];
      (*(void (**)(uint64_t, id))(v16 + 16))(v16, v21);
    }
  }
  else
  {
    uint64_t v22 = *(void **)(a1 + 32);
    uint64_t v23 = *(void *)(a1 + 40);
    [v22 _sync_stopPolling:v23];
  }
}