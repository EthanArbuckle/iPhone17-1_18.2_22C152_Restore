uint64_t compatibilityInitializeAvailabilityCheck()
{
  return _initializeAvailabilityCheck(1);
}

uint64_t __isPlatformVersionAtLeast(uint64_t a1, int a2, int a3, int a4)
{
  if (qword_1000901E0 == -1)
  {
    if (qword_1000901E8) {
      return _availability_version_check();
    }
  }
  else
  {
    dispatch_once_f(&qword_1000901E0, 0, (dispatch_function_t)initializeAvailabilityCheck);
    if (qword_1000901E8) {
      return _availability_version_check();
    }
  }
  if (qword_1000901D8 == -1)
  {
    BOOL v8 = _MergedGlobals < a2;
    if (_MergedGlobals > a2) {
      return 1;
    }
  }
  else
  {
    dispatch_once_f(&qword_1000901D8, 0, (dispatch_function_t)compatibilityInitializeAvailabilityCheck);
    BOOL v8 = _MergedGlobals < a2;
    if (_MergedGlobals > a2) {
      return 1;
    }
  }
  if (v8) {
    return 0;
  }
  if (dword_1000901CC > a3) {
    return 1;
  }
  return dword_1000901CC >= a3 && dword_1000901D0 >= a4;
}

uint64_t initializeAvailabilityCheck()
{
  return _initializeAvailabilityCheck(0);
}

uint64_t _initializeAvailabilityCheck(uint64_t result)
{
  v1 = (uint64_t (**)(void))qword_1000901E8;
  if (qword_1000901E8) {
    BOOL v2 = result == 0;
  }
  else {
    BOOL v2 = 0;
  }
  if (!v2)
  {
    if (&__availability_version_check)
    {
      v1 = &__availability_version_check;
      qword_1000901E8 = (uint64_t)&__availability_version_check;
    }
    if (!v1 || result != 0)
    {
      result = (uint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "kCFAllocatorNull");
      if (result)
      {
        v4 = *(unsigned __int8 **)result;
        result = (uint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "CFDataCreateWithBytesNoCopy");
        if (result)
        {
          v5 = (uint64_t (*)(void))result;
          unint64_t v6 = (unint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "CFPropertyListCreateWithData");
          result = (uint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "CFPropertyListCreateFromXMLData");
          if (v6 | result)
          {
            v7 = (uint64_t (*)(void, uint64_t, void, void))result;
            result = (uint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "CFStringCreateWithCStringNoCopy");
            if (result)
            {
              BOOL v8 = (uint64_t (*)(void, const char *, uint64_t, unsigned __int8 *))result;
              result = (uint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "CFDictionaryGetValue");
              if (result)
              {
                v9 = (uint64_t (*)(uint64_t, uint64_t))result;
                result = (uint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "CFGetTypeID");
                if (result)
                {
                  v10 = (uint64_t (*)(uint64_t))result;
                  result = (uint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "CFStringGetTypeID");
                  if (result)
                  {
                    v11 = (uint64_t (*)(void))result;
                    result = (uint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "CFStringGetCString");
                    v28 = (unsigned int (*)(uint64_t, char *, uint64_t, uint64_t))result;
                    if (result)
                    {
                      result = (uint64_t)dlsym((void *)0xFFFFFFFFFFFFFFFELL, "CFRelease");
                      if (result)
                      {
                        v12 = (FILE *)result;
                        result = (uint64_t)fopen("/System/Library/CoreServices/SystemVersion.plist", "r");
                        if (result)
                        {
                          v13 = (FILE *)result;
                          v27 = v12;
                          fseek((FILE *)result, 0, 2);
                          uint64_t v14 = ftell(v13);
                          if (v14 < 0)
                          {
                            v16 = 0;
                          }
                          else
                          {
                            size_t v15 = v14;
                            rewind(v13);
                            v16 = malloc(v15);
                            if (v16)
                            {
                              v26 = v16;
                              if (fread(v16, 1uLL, v15, v13) == v15)
                              {
                                uint64_t v17 = v5(0);
                                if (v17)
                                {
                                  uint64_t v18 = v17;
                                  v19 = v13;
                                  if (v6) {
                                    uint64_t v20 = ((uint64_t (*)(void, uint64_t, void, void, void))v6)(0, v17, 0, 0, 0);
                                  }
                                  else {
                                    uint64_t v20 = v7(0, v17, 0, 0);
                                  }
                                  uint64_t v21 = v20;
                                  if (v20)
                                  {
                                    uint64_t v22 = v8(0, "ProductVersion", 1536, v4);
                                    if (v22)
                                    {
                                      uint64_t v23 = v22;
                                      uint64_t v24 = v9(v21, v22);
                                      ((void (*)(uint64_t))v27)(v23);
                                      if (v24)
                                      {
                                        uint64_t v25 = v10(v24);
                                        if (v25 == v11())
                                        {
                                          if (v28(v24, v29, 32, 134217984)) {
                                            sscanf(v29, "%d.%d.%d", &_MergedGlobals, &dword_1000901CC, &dword_1000901D0);
                                          }
                                        }
                                      }
                                    }
                                    ((void (*)(uint64_t))v27)(v21);
                                    v19 = v13;
                                  }
                                  ((void (*)(uint64_t))v27)(v18);
                                }
                                else
                                {
                                  v19 = v13;
                                }
                                v16 = v26;
                              }
                              else
                              {
                                v16 = v26;
                                v19 = v13;
                              }
                              goto LABEL_41;
                            }
                          }
                          v19 = v13;
LABEL_41:
                          free(v16);
                          return fclose(v19);
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

void node_type_tracker_callback(uint64_t a1, int a2, int a3)
{
  if (a3 == -65569) {
    goto LABEL_4;
  }
  if (a3)
  {
    if (a3 != -65563)
    {
      v13 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)uint64_t v18 = 136446466;
        *(void *)&v18[4] = "node_type_tracker_callback";
        *(_WORD *)&v18[12] = 1024;
        *(_DWORD *)&v18[14] = a3;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: unexpected error %d", v18, 0x12u);
      }
LABEL_20:
      cti_events_discontinue(*(void *)(a1 + 40));
      *(void *)(a1 + 40) = 0;
      int v14 = *(_DWORD *)a1;
      if (*(_DWORD *)a1)
      {
        size_t v15 = global_os_log;
        if (v14 < 10001)
        {
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)uint64_t v18 = 136447490;
            *(void *)&v18[4] = "node_type_tracker_callback";
            *(_WORD *)&v18[12] = 1024;
            *(_DWORD *)&v18[14] = v14;
            *(_WORD *)&v18[18] = 2048;
            *(void *)&v18[20] = a1;
            *(_WORD *)&v18[28] = 2080;
            *(void *)&v18[30] = "tracker";
            *(_WORD *)&v18[38] = 2080;
            *(void *)&v18[40] = "node-type-tracker.c";
            __int16 v19 = 1024;
            int v20 = 116;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v18, 0x36u);
            int v14 = *(_DWORD *)a1;
          }
          *(_DWORD *)a1 = v14 - 1;
          if (v14 == 1)
          {
            v16 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)uint64_t v18 = 136447234;
              *(void *)&v18[4] = "node_type_tracker_callback";
              *(_WORD *)&v18[12] = 2048;
              *(void *)&v18[14] = a1;
              *(_WORD *)&v18[22] = 2080;
              *(void *)&v18[24] = "tracker";
              *(_WORD *)&v18[32] = 2080;
              *(void *)&v18[34] = "node-type-tracker.c";
              *(_WORD *)&v18[42] = 1024;
              *(_DWORD *)&v18[44] = 116;
              _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v18, 0x30u);
            }
            ++node_type_tracker_finalized;
            free((void *)a1);
          }
          return;
        }
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_34:
        }
          abort();
        *(_DWORD *)uint64_t v18 = 136447490;
        *(void *)&v18[4] = "node_type_tracker_callback";
        *(_WORD *)&v18[12] = 1024;
        *(_DWORD *)&v18[14] = v14;
        *(_WORD *)&v18[18] = 2048;
        *(void *)&v18[20] = a1;
        *(_WORD *)&v18[28] = 2080;
        *(void *)&v18[30] = "tracker";
        *(_WORD *)&v18[38] = 2080;
        *(void *)&v18[40] = "node-type-tracker.c";
        __int16 v19 = 1024;
        int v20 = 116;
        uint64_t v17 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      }
      else
      {
        size_t v15 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_34;
        }
        *(_DWORD *)uint64_t v18 = 136447490;
        *(void *)&v18[4] = "node_type_tracker_callback";
        *(_WORD *)&v18[12] = 1024;
        *(_DWORD *)&v18[14] = 0;
        *(_WORD *)&v18[18] = 2048;
        *(void *)&v18[20] = a1;
        *(_WORD *)&v18[28] = 2080;
        *(void *)&v18[30] = "tracker";
        *(_WORD *)&v18[38] = 2080;
        *(void *)&v18[40] = "node-type-tracker.c";
        __int16 v19 = 1024;
        int v20 = 116;
        uint64_t v17 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      }
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_FAULT, v17, v18, 0x36u);
      goto LABEL_34;
    }
LABEL_4:
    v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)uint64_t v18 = 136446210;
      *(void *)&v18[4] = "node_type_tracker_callback";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: disconnected", v18, 0xCu);
    }
    if (*(void *)(a1 + 24))
    {
      unint64_t v6 = *(void (**)(void))(a1 + 16);
      if (v6) {
        v6();
      }
    }
    goto LABEL_20;
  }
  if ((a2 - 1) >= 8) {
    int v8 = 0;
  }
  else {
    int v8 = a2;
  }
  *(void *)uint64_t v18 = 0;
  *(void *)&v18[8] = 0;
  gettimeofday((timeval *)v18, 0);
  *(void *)(a1 + 56) = 1000 * *(void *)v18 + *(_DWORD *)&v18[8] / 1000;
  v9 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    v10 = off_10008CB30[v8];
    *(_DWORD *)uint64_t v18 = 136446722;
    *(void *)&v18[4] = "node_type_tracker_callback";
    *(_WORD *)&v18[12] = 2082;
    *(void *)&v18[14] = v10;
    *(_WORD *)&v18[22] = 1024;
    *(_DWORD *)&v18[24] = a2;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: node type is: %{public}s (%d)\n ", v18, 0x1Cu);
  }
  int v11 = *(_DWORD *)(a1 + 64);
  if (v11 != v8)
  {
    *(_DWORD *)(a1 + 64) = v8;
    *(_DWORD *)(a1 + 68) = v11;
    for (i = *(uint64_t ***)(a1 + 48); i; i = (uint64_t **)*i)
      ((void (*)(uint64_t *))i[2])(i[3]);
  }
}

void dnssd_client_release_(int *a1, char *a2, int a3)
{
  if (!a1) {
    return;
  }
  int v6 = *a1;
  if (!*a1)
  {
    v7 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v11 = 136447490;
    v12 = "dnssd_client_release_";
    __int16 v13 = 1024;
    *(_DWORD *)int v14 = 0;
    *(_WORD *)&v14[4] = 2048;
    *(void *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(void *)&v14[16] = "omw";
    *(_WORD *)&v14[24] = 2080;
    *(void *)&v14[26] = strrchr(a2, 47) + 1;
    __int16 v15 = 1024;
    int v16 = a3;
    v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  v7 = global_os_log;
  if (v6 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v11 = 136447490;
    v12 = "dnssd_client_release_";
    __int16 v13 = 1024;
    *(_DWORD *)int v14 = v6;
    *(_WORD *)&v14[4] = 2048;
    *(void *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(void *)&v14[16] = "omw";
    *(_WORD *)&v14[24] = 2080;
    *(void *)&v14[26] = strrchr(a2, 47) + 1;
    __int16 v15 = 1024;
    int v16 = a3;
    v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v11, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = 136447490;
    v12 = "dnssd_client_release_";
    __int16 v13 = 1024;
    *(_DWORD *)int v14 = v6;
    *(_WORD *)&v14[4] = 2048;
    *(void *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(void *)&v14[16] = "omw";
    *(_WORD *)&v14[24] = 2080;
    *(void *)&v14[26] = strrchr(a2, 47) + 1;
    __int16 v15 = 1024;
    int v16 = a3;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v11, 0x36u);
    int v6 = *a1;
  }
  *a1 = v6 - 1;
  if (v6 == 1)
  {
    int v8 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      v9 = strrchr(a2, 47);
      int v11 = 136447234;
      v12 = "dnssd_client_release_";
      __int16 v13 = 2048;
      *(void *)int v14 = a1;
      *(_WORD *)&v14[8] = 2080;
      *(void *)&v14[10] = "omw";
      *(_WORD *)&v14[18] = 2080;
      *(void *)&v14[20] = v9 + 1;
      *(_WORD *)&v14[28] = 1024;
      *(_DWORD *)&v14[30] = a3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v11, 0x30u);
    }
    ++dnssd_client_finalized;
    dnssd_client_finalize((uint64_t)a1);
  }
}

void dnssd_client_finalize(uint64_t a1)
{
  thread_service_release_(*(int **)(a1 + 136), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-client.c", 129);
  ioloop_wakeup_release_(*(void **)(a1 + 88), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-client.c", 130);
  free(*(void **)(a1 + 8));
  free(*(void **)(a1 + 72));

  free((void *)a1);
}

void dnssd_client_cancel(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 80);
  uint64_t v3 = *(void *)(v2 + 40);
  if (v3)
  {
    service_tracker_cancel_probes(v3);
    service_tracker_callback_cancel(*(void **)(*(void *)(a1 + 80) + 40), a1);
    uint64_t v2 = *(void *)(a1 + 80);
  }
  v4 = *(void **)(v2 + 56);
  if (v4) {
    thread_tracker_callback_cancel(v4, a1);
  }
  ioloop_cancel_wake_event(*(void *)(a1 + 88));
  uint64_t v5 = *(void *)(a1 + 96);
  if (v5)
  {
    cti_events_discontinue(v5);
    int v6 = *(_DWORD *)a1;
    if (*(_DWORD *)a1)
    {
      v7 = global_os_log;
      if (v6 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v10 = 136447490;
          int v11 = "dnssd_client_cancel";
          __int16 v12 = 1024;
          *(_DWORD *)__int16 v13 = v6;
          *(_WORD *)&v13[4] = 2048;
          *(void *)&v13[6] = a1;
          *(_WORD *)&v13[14] = 2080;
          *(void *)&v13[16] = "client";
          *(_WORD *)&v13[24] = 2080;
          *(void *)&v13[26] = "dnssd-client.c";
          __int16 v14 = 1024;
          int v15 = 619;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v10, 0x36u);
          int v6 = *(_DWORD *)a1;
        }
        *(_DWORD *)a1 = v6 - 1;
        if (v6 == 1)
        {
          int v8 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v10 = 136447234;
            int v11 = "dnssd_client_cancel";
            __int16 v12 = 2048;
            *(void *)__int16 v13 = a1;
            *(_WORD *)&v13[8] = 2080;
            *(void *)&v13[10] = "client";
            *(_WORD *)&v13[18] = 2080;
            *(void *)&v13[20] = "dnssd-client.c";
            *(_WORD *)&v13[28] = 1024;
            *(_DWORD *)&v13[30] = 619;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v10, 0x30u);
          }
          ++dnssd_client_finalized;
          dnssd_client_finalize(a1);
        }
        *(void *)(a1 + 96) = 0;
        goto LABEL_15;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_21:
      }
        abort();
      int v10 = 136447490;
      int v11 = "dnssd_client_cancel";
      __int16 v12 = 1024;
      *(_DWORD *)__int16 v13 = v6;
      *(_WORD *)&v13[4] = 2048;
      *(void *)&v13[6] = a1;
      *(_WORD *)&v13[14] = 2080;
      *(void *)&v13[16] = "client";
      *(_WORD *)&v13[24] = 2080;
      *(void *)&v13[26] = "dnssd-client.c";
      __int16 v14 = 1024;
      int v15 = 619;
      v9 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      v7 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_21;
      }
      int v10 = 136447490;
      int v11 = "dnssd_client_cancel";
      __int16 v12 = 1024;
      *(_DWORD *)__int16 v13 = 0;
      *(_WORD *)&v13[4] = 2048;
      *(void *)&v13[6] = a1;
      *(_WORD *)&v13[14] = 2080;
      *(void *)&v13[16] = "client";
      *(_WORD *)&v13[24] = 2080;
      *(void *)&v13[26] = "dnssd-client.c";
      __int16 v14 = 1024;
      int v15 = 619;
      v9 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, v9, (uint8_t *)&v10, 0x36u);
    goto LABEL_21;
  }
LABEL_15:
  dnssd_client_remove_published_service(a1);
  state_machine_cancel((uint64_t *)(a1 + 8));
}

uint64_t dnssd_client_remove_published_service(uint64_t a1)
{
  uint64_t result = *(void *)(a1 + 152);
  if (result)
  {
    mrc_dns_service_registration_invalidate();
    uint64_t result = mrc_release();
    *(void *)(a1 + 152) = 0;
  }
  return result;
}

void dnssd_client_context_release(int *a1)
{
  if (!a1) {
    return;
  }
  int v2 = *a1;
  if (!*a1)
  {
    uint64_t v3 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v6 = 136447490;
    v7 = "dnssd_client_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)v9 = 0;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "client";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "dnssd-client.c";
    __int16 v10 = 1024;
    int v11 = 142;
    uint64_t v5 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  uint64_t v3 = global_os_log;
  if (v2 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v6 = 136447490;
    v7 = "dnssd_client_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "client";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "dnssd-client.c";
    __int16 v10 = 1024;
    int v11 = 142;
    uint64_t v5 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, v5, (uint8_t *)&v6, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 136447490;
    v7 = "dnssd_client_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "client";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "dnssd-client.c";
    __int16 v10 = 1024;
    int v11 = 142;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v6, 0x36u);
    int v2 = *a1;
  }
  *a1 = v2 - 1;
  if (v2 == 1)
  {
    v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 136447234;
      v7 = "dnssd_client_context_release";
      __int16 v8 = 2048;
      *(void *)v9 = a1;
      *(_WORD *)&v9[8] = 2080;
      *(void *)&v9[10] = "client";
      *(_WORD *)&v9[18] = 2080;
      *(void *)&v9[20] = "dnssd-client.c";
      *(_WORD *)&v9[28] = 1024;
      *(_DWORD *)&v9[30] = 142;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v6, 0x30u);
    }
    ++dnssd_client_finalized;
    dnssd_client_finalize((uint64_t)a1);
  }
}

void dnssd_client_service_tracker_callback(uint64_t a1)
{
  int v2 = state_machine_event_create(4);
  if (v2)
  {
    uint64_t v3 = v2;
    state_machine_event_deliver(a1 + 8, (uint64_t)v2);
    int v4 = *v3;
    if (*v3)
    {
      uint64_t v5 = global_os_log;
      if (v4 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v10 = 136447490;
          int v11 = "dnssd_client_service_tracker_callback";
          __int16 v12 = 1024;
          *(_DWORD *)__int16 v13 = v4;
          *(_WORD *)&v13[4] = 2048;
          *(void *)&v13[6] = v3;
          *(_WORD *)&v13[14] = 2080;
          *(void *)&v13[16] = "event";
          *(_WORD *)&v13[24] = 2080;
          *(void *)&v13[26] = "dnssd-client.c";
          __int16 v14 = 1024;
          int v15 = 169;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v10, 0x36u);
          int v4 = *v3;
        }
        *uint64_t v3 = v4 - 1;
        if (v4 == 1)
        {
          int v6 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v10 = 136447234;
            int v11 = "dnssd_client_service_tracker_callback";
            __int16 v12 = 2048;
            *(void *)__int16 v13 = v3;
            *(_WORD *)&v13[8] = 2080;
            *(void *)&v13[10] = "event";
            *(_WORD *)&v13[18] = 2080;
            *(void *)&v13[20] = "dnssd-client.c";
            *(_WORD *)&v13[28] = 1024;
            *(_DWORD *)&v13[30] = 169;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v10, 0x30u);
          }
          ++state_machine_event_finalized;
          v7 = (void (*)(int *))*((void *)v3 + 4);
          if (v7) {
            v7(v3);
          }
          free(v3);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_20:
      }
        abort();
      int v10 = 136447490;
      int v11 = "dnssd_client_service_tracker_callback";
      __int16 v12 = 1024;
      *(_DWORD *)__int16 v13 = v4;
      *(_WORD *)&v13[4] = 2048;
      *(void *)&v13[6] = v3;
      *(_WORD *)&v13[14] = 2080;
      *(void *)&v13[16] = "event";
      *(_WORD *)&v13[24] = 2080;
      *(void *)&v13[26] = "dnssd-client.c";
      __int16 v14 = 1024;
      int v15 = 169;
      v9 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      uint64_t v5 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_20;
      }
      int v10 = 136447490;
      int v11 = "dnssd_client_service_tracker_callback";
      __int16 v12 = 1024;
      *(_DWORD *)__int16 v13 = 0;
      *(_WORD *)&v13[4] = 2048;
      *(void *)&v13[6] = v3;
      *(_WORD *)&v13[14] = 2080;
      *(void *)&v13[16] = "event";
      *(_WORD *)&v13[24] = 2080;
      *(void *)&v13[26] = "dnssd-client.c";
      __int16 v14 = 1024;
      int v15 = 169;
      v9 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, v9, (uint8_t *)&v10, 0x36u);
    goto LABEL_20;
  }
  __int16 v8 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    int v10 = 136446210;
    int v11 = "dnssd_client_service_tracker_callback";
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v10, 0xCu);
  }
}

uint64_t dnssd_client_action_client(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 52);
  if (v2 != 3)
  {
    __int16 v13 = global_os_log;
    uint64_t result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)buf = 136446466;
    v60 = "dnssd_client_action_client";
    __int16 v61 = 1024;
    *(_DWORD *)v62 = v2;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%{public}s: state header type isn't omr_client: %d", buf, 0x12u);
    return 0;
  }
  int v4 = *(int **)(a1 + 8);
  uint64_t v5 = global_os_log;
  BOOL v6 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (!a2)
  {
    if (v6)
    {
      uint64_t v14 = *((void *)v4 + 5);
      uint64_t v15 = *((void *)v4 + 1);
      uint64_t v16 = *((void *)v4 + 3);
      *(_DWORD *)buf = 136447235;
      v60 = "dnssd_client_action_client";
      __int16 v61 = 2082;
      *(void *)v62 = v14;
      *(_WORD *)&v62[8] = 2160;
      *(void *)&v62[10] = 1752392040;
      *(_WORD *)&v62[18] = 2081;
      *(void *)&v62[20] = v15;
      *(_WORD *)&v62[28] = 2082;
      *(void *)&v62[30] = v16;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s/%{private, mask.hash}s: entering state %{public}s", buf, 0x34u);
    }
    dnssd_client_service_unpublish((uint64_t *)v4);
    uint64_t v17 = mdns_domain_name_create();
    uint64_t v18 = *((void *)v4 + 17);
    if ((*(_DWORD *)(v18 + 20) & 0xFFFFFFFE) == 2)
    {
      __int16 v19 = (unsigned __int8 *)(v18 + 64);
      ipBOOL v6 = mdns_address_create_ipv6();
      if (ipv6)
      {
        uint64_t v21 = ipv6;
        int v22 = v4[40];
        if (v22 == 1)
        {
          uint64_t v42 = mdns_dns_service_definition_create();
          if (v42)
          {
            uint64_t v26 = v42;
            if (mdns_dns_service_definition_add_domain()
              || mdns_dns_service_definition_append_server_address())
            {
              uint64_t v24 = 0;
LABEL_97:
              mdns_release();
LABEL_98:
              if (v24) {
                goto LABEL_99;
              }
LABEL_60:
              if (v17) {
                mdns_release();
              }
              if (v21) {
                mdns_release();
              }
              return 0;
            }
            uint64_t v27 = mrc_dns_service_registration_create();
            uint64_t v24 = 0;
            *((void *)v4 + 19) = v27;
            goto LABEL_76;
          }
          uint64_t v58 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
            goto LABEL_60;
          }
          *(_DWORD *)buf = 136446210;
          v60 = "dnssd_client_service_publish";
          v44 = "%{public}s: unable to allocate mdns_dns_service_definition object";
        }
        else
        {
          if (v22 != 2)
          {
            uint64_t v43 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
              goto LABEL_60;
            }
            *(_DWORD *)buf = 136446466;
            v60 = "dnssd_client_service_publish";
            __int16 v61 = 1024;
            *(_DWORD *)v62 = v22;
            v44 = "%{public}s: Unknown DNS service registration type: %d";
            v45 = v43;
            uint32_t v46 = 18;
LABEL_50:
            _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, v44, buf, v46);
            goto LABEL_60;
          }
          uint64_t v23 = mdns_dns_push_service_definition_create();
          if (v23)
          {
            uint64_t v24 = v23;
            if (mdns_dns_push_service_definition_add_domain())
            {
LABEL_99:
              mdns_release();
              goto LABEL_60;
            }
            mdns_dns_push_service_definition_append_server_address();
            uint64_t push = mrc_dns_service_registration_create_push();
            *((void *)v4 + 19) = push;
            if (!push)
            {
              uint64_t v26 = 0;
              goto LABEL_73;
            }
            mrc_dns_service_registration_set_reports_connection_errors();
            uint64_t v26 = 0;
            uint64_t v27 = *((void *)v4 + 19);
LABEL_76:
            if (v27)
            {
              mrc_dns_service_registration_set_queue();
              v49 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                int v50 = *v4;
                *(_DWORD *)buf = 136447490;
                v60 = "dnssd_client_service_publish";
                __int16 v61 = 1024;
                *(_DWORD *)v62 = v50;
                *(_WORD *)&v62[4] = 2048;
                *(void *)&v62[6] = v4;
                *(_WORD *)&v62[14] = 2080;
                *(void *)&v62[16] = "client";
                *(_WORD *)&v62[24] = 2080;
                *(void *)&v62[26] = "dnssd-client.c";
                *(_WORD *)&v62[34] = 1024;
                *(_DWORD *)&v62[36] = 364;
                _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
              }
              int v51 = *v4;
              if (*v4)
              {
                int v52 = v51 + 1;
                int *v4 = v51 + 1;
                if (v51 + 1 >= 10001)
                {
                  v53 = global_os_log;
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                  {
                    *(_DWORD *)buf = 136447490;
                    v60 = "dnssd_client_service_publish";
                    __int16 v61 = 1024;
                    *(_DWORD *)v62 = v52;
                    *(_WORD *)&v62[4] = 2048;
                    *(void *)&v62[6] = v4;
                    *(_WORD *)&v62[14] = 2080;
                    *(void *)&v62[16] = "client";
                    *(_WORD *)&v62[24] = 2080;
                    *(void *)&v62[26] = "dnssd-client.c";
                    *(_WORD *)&v62[34] = 1024;
                    *(_DWORD *)&v62[36] = 364;
                    _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                  }
                  abort();
                }
              }
              else
              {
                ++dnssd_client_created;
                int *v4 = 1;
              }
              mrc_dns_service_registration_set_event_handler();
              v54 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t presentation = mdns_domain_name_get_presentation();
                int v56 = *v19;
                if ((v56 & 0xFE) == 0xFC)
                {
                  v57 = "ULA: ";
                }
                else if (v56 == 254 && (*(unsigned char *)(v18 + 65) & 0xC0) == 0x80)
                {
                  v57 = "LUA: ";
                }
                else if ((v56 & 0xE0) == 0x20)
                {
                  v57 = "GUA: ";
                }
                else
                {
                  v57 = "";
                }
                *(_DWORD *)buf = 136449283;
                v60 = "dnssd_client_service_publish";
                __int16 v61 = 2160;
                *(void *)v62 = 1752392040;
                *(_WORD *)&v62[8] = 2081;
                *(void *)&v62[10] = presentation;
                *(_WORD *)&v62[18] = 2082;
                *(void *)&v62[20] = v57;
                *(_WORD *)&v62[28] = 2160;
                *(void *)&v62[30] = 1752392040;
                *(_WORD *)&v62[38] = 1041;
                *(_DWORD *)&v62[40] = 6;
                *(_WORD *)&v62[44] = 2097;
                *(void *)&v62[46] = v18 + 64;
                *(_WORD *)&v62[54] = 2160;
                *(void *)&v62[56] = 1752392040;
                *(_WORD *)&v62[64] = 1042;
                *(_DWORD *)&v62[66] = 2;
                __int16 v63 = 2098;
                *(void *)v64 = v18 + 70;
                *(_WORD *)&v64[8] = 2160;
                *(void *)&v64[10] = 1752392040;
                __int16 v65 = 1041;
                int v66 = 8;
                __int16 v67 = 2097;
                uint64_t v68 = v18 + 72;
                _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "%{public}s: Publishing dnssd client service -- domain: %{private, mask.hash}s, address: {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}", buf, 0x78u);
              }
              mrc_dns_service_registration_activate();
              goto LABEL_96;
            }
LABEL_73:
            v48 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446210;
              v60 = "dnssd_client_service_publish";
              _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "%{public}s: failed to create DNS service registration", buf, 0xCu);
            }
LABEL_96:
            if (!v26) {
              goto LABEL_98;
            }
            goto LABEL_97;
          }
          uint64_t v58 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
            goto LABEL_60;
          }
          *(_DWORD *)buf = 136446210;
          v60 = "dnssd_client_service_publish";
          v44 = "%{public}s: unable to allocate mdns_dns_push_service_definition object";
        }
        v45 = v58;
        uint32_t v46 = 12;
        goto LABEL_50;
      }
      uint64_t v36 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        int v37 = *v19;
        if ((v37 & 0xFE) == 0xFC)
        {
          v38 = "ULA: ";
        }
        else if (v37 == 254 && (*(unsigned char *)(v18 + 65) & 0xC0) == 0x80)
        {
          v38 = "LUA: ";
        }
        else if ((v37 & 0xE0) == 0x20)
        {
          v38 = "GUA: ";
        }
        else
        {
          v38 = "";
        }
        *(_DWORD *)buf = 136448771;
        v60 = "dnssd_client_service_publish";
        __int16 v61 = 2082;
        *(void *)v62 = v38;
        *(_WORD *)&v62[8] = 2160;
        *(void *)&v62[10] = 1752392040;
        *(_WORD *)&v62[18] = 1041;
        *(_DWORD *)&v62[20] = 6;
        *(_WORD *)&v62[24] = 2097;
        *(void *)&v62[26] = v18 + 64;
        *(_WORD *)&v62[34] = 2160;
        *(void *)&v62[36] = 1752392040;
        *(_WORD *)&v62[44] = 1042;
        *(_DWORD *)&v62[46] = 2;
        *(_WORD *)&v62[50] = 2098;
        *(void *)&v62[52] = v18 + 70;
        *(_WORD *)&v62[60] = 2160;
        *(void *)&v62[62] = 1752392040;
        __int16 v63 = 1041;
        *(_DWORD *)v64 = 8;
        *(_WORD *)&v64[4] = 2097;
        *(void *)&v64[6] = v18 + 72;
        v29 = "%{public}s: failed to create address object -- address: {%{public}s%{private, mask.hash, srp:in6_addr_segm"
              "ent}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}";
        v30 = v36;
        uint32_t v31 = 100;
        goto LABEL_58;
      }
    }
    else
    {
      uint64_t v28 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v60 = "dnssd_client_service_publish";
        v29 = "%{public}s: failed to get service address";
        v30 = v28;
        uint32_t v31 = 12;
LABEL_58:
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, v29, buf, v31);
      }
    }
    uint64_t v21 = 0;
    goto LABEL_60;
  }
  if (v6)
  {
    uint64_t v7 = *((void *)v4 + 5);
    uint64_t v8 = *((void *)v4 + 1);
    uint64_t v9 = *(void *)(a2 + 8);
    uint64_t v10 = *((void *)v4 + 3);
    *(_DWORD *)buf = 136447491;
    v60 = "dnssd_client_action_client";
    __int16 v61 = 2082;
    *(void *)v62 = v7;
    *(_WORD *)&v62[8] = 2160;
    *(void *)&v62[10] = 1752392040;
    *(_WORD *)&v62[18] = 2081;
    *(void *)&v62[20] = v8;
    *(_WORD *)&v62[28] = 2082;
    *(void *)&v62[30] = v9;
    *(_WORD *)&v62[38] = 2082;
    *(void *)&v62[40] = v10;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s/%{private, mask.hash}s: event %{public}s received in state %{public}s", buf, 0x3Eu);
  }
  if (*(_DWORD *)(a2 + 16) == 20)
  {
    uint64_t v11 = *((void *)v4 + 17);
    if (v11)
    {
      *(unsigned char *)(v11 + 27) = 1;
      *(unsigned char *)(v11 + 49) = 0;
      thread_service_release_((int *)v11, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-client.c", 581);
      *((void *)v4 + 17) = 0;
      return 3;
    }
    v32 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      v60 = "dnssd_client_action_client";
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "%{public}s: bad service event received with no published service.", buf, 0xCu);
    }
  }
  if (!*((void *)v4 + 17) || !dnssd_client_should_be_client(*((void *)v4 + 10))) {
    return 2;
  }
  uint64_t v33 = *(void *)(*((void *)v4 + 10) + 40);
  uint64_t v34 = *((void *)v4 + 17);
  if (!v33 || v34 == 0) {
    return 2;
  }
  uint64_t v39 = *(void *)(v33 + 48);
  if (v39)
  {
    while (1)
    {
      if (!*(unsigned char *)(v39 + 27))
      {
        if (*(unsigned char *)(v39 + 49))
        {
          int v40 = *(_DWORD *)(v34 + 20);
          if (v40 == *(_DWORD *)(v39 + 20)) {
            break;
          }
        }
      }
      uint64_t v39 = *(void *)(v39 + 8);
      if (!v39) {
        goto LABEL_40;
      }
    }
    if (v40 == 3)
    {
      if (*(unsigned __int8 *)(v39 + 80) != *(unsigned __int8 *)(v34 + 80))
      {
LABEL_69:
        v47 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136446466;
          v60 = "service_tracker_verified_service_still_exists";
          __int16 v61 = 1024;
          *(_DWORD *)v62 = v40;
          _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_FAULT, "%{public}s: old_service type is bogus: %d", buf, 0x12u);
        }
        LODWORD(v39) = 0;
        int v41 = 1;
        goto LABEL_41;
      }
    }
    else if (v40 != 2 || v39 != v34)
    {
      goto LABEL_69;
    }
    int v41 = 1;
    LODWORD(v39) = 1;
  }
  else
  {
LABEL_40:
    int v41 = 0;
  }
LABEL_41:
  if ((v41 & v39) != 0) {
    return 0;
  }
  else {
    return 2;
  }
}

uint64_t dnssd_client_service_unpublish(uint64_t *a1)
{
  if (a1[19]) {
    thread_service_note(a1[9], a1[17], (uint64_t)"unpublishing service");
  }

  return dnssd_client_remove_published_service((uint64_t)a1);
}

void __dnssd_client_service_publish_block_invoke(uint64_t a1, int a2, int a3)
{
  int v4 = *(int **)(a1 + 32);
  switch(a2)
  {
    case -1:
      uint64_t v5 = global_os_log;
      if (a3)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
          goto LABEL_16;
        }
        int v29 = 136446466;
        v30 = "dnssd_client_dns_service_event_handler";
        __int16 v31 = 1024;
        *(_DWORD *)v32 = a3;
        BOOL v6 = "%{public}s: DNS service registration invalidated with error: %d";
        uint64_t v7 = v5;
        os_log_type_t v8 = OS_LOG_TYPE_ERROR;
        uint32_t v9 = 18;
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_16;
        }
        int v29 = 136446210;
        v30 = "dnssd_client_dns_service_event_handler";
        BOOL v6 = "%{public}s: DNS service registration gracefully invalidated";
        uint64_t v7 = v5;
        os_log_type_t v8 = OS_LOG_TYPE_DEFAULT;
        uint32_t v9 = 12;
      }
      _os_log_impl((void *)&_mh_execute_header, v7, v8, v6, (uint8_t *)&v29, v9);
LABEL_16:
      char v13 = 1;
      int v14 = 15;
LABEL_17:
      uint64_t v15 = state_machine_event_create(v14);
      if (v15)
      {
        uint64_t v16 = v15;
        state_machine_event_deliver((uint64_t)(v4 + 2), (uint64_t)v15);
        int v17 = *v16;
        if (!*v16)
        {
          uint64_t v26 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
            goto LABEL_52;
          }
          int v29 = 136447490;
          v30 = "dnssd_client_dns_service_event_handler";
          __int16 v31 = 1024;
          *(_DWORD *)v32 = 0;
          *(_WORD *)&v32[4] = 2048;
          *(void *)&v32[6] = v16;
          *(_WORD *)&v32[14] = 2080;
          *(void *)&v32[16] = "event";
          *(_WORD *)&v32[24] = 2080;
          *(void *)&v32[26] = "dnssd-client.c";
          __int16 v33 = 1024;
          int v34 = 289;
          uint64_t v27 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
          uint64_t v28 = v26;
          goto LABEL_51;
        }
        uint64_t v18 = global_os_log;
        if (v17 >= 10001)
        {
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
            goto LABEL_52;
          }
          int v29 = 136447490;
          v30 = "dnssd_client_dns_service_event_handler";
          __int16 v31 = 1024;
          *(_DWORD *)v32 = v17;
          *(_WORD *)&v32[4] = 2048;
          *(void *)&v32[6] = v16;
          *(_WORD *)&v32[14] = 2080;
          *(void *)&v32[16] = "event";
          *(_WORD *)&v32[24] = 2080;
          *(void *)&v32[26] = "dnssd-client.c";
          __int16 v33 = 1024;
          int v34 = 289;
          uint64_t v27 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
          uint64_t v28 = v18;
          goto LABEL_51;
        }
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v29 = 136447490;
          v30 = "dnssd_client_dns_service_event_handler";
          __int16 v31 = 1024;
          *(_DWORD *)v32 = v17;
          *(_WORD *)&v32[4] = 2048;
          *(void *)&v32[6] = v16;
          *(_WORD *)&v32[14] = 2080;
          *(void *)&v32[16] = "event";
          *(_WORD *)&v32[24] = 2080;
          *(void *)&v32[26] = "dnssd-client.c";
          __int16 v33 = 1024;
          int v34 = 289;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v29, 0x36u);
          int v17 = *v16;
        }
        int *v16 = v17 - 1;
        if (v17 == 1)
        {
          __int16 v19 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v29 = 136447234;
            v30 = "dnssd_client_dns_service_event_handler";
            __int16 v31 = 2048;
            *(void *)v32 = v16;
            *(_WORD *)&v32[8] = 2080;
            *(void *)&v32[10] = "event";
            *(_WORD *)&v32[18] = 2080;
            *(void *)&v32[20] = "dnssd-client.c";
            *(_WORD *)&v32[28] = 1024;
            *(_DWORD *)&v32[30] = 289;
            _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v29, 0x30u);
          }
          ++state_machine_event_finalized;
          int v20 = (void (*)(int *))*((void *)v16 + 4);
          if (v20) {
            v20(v16);
          }
          free(v16);
        }
      }
      else
      {
        uint64_t v21 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          int v29 = 136446210;
          v30 = "dnssd_client_dns_service_event_handler";
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v29, 0xCu);
        }
      }
      char v22 = v13 ^ 1;
      if (!v4) {
        char v22 = 1;
      }
      if ((v22 & 1) == 0)
      {
        int v23 = *v4;
        if (*v4)
        {
          uint64_t v24 = global_os_log;
          if (v23 < 10001)
          {
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              int v29 = 136447490;
              v30 = "dnssd_client_dns_service_event_handler";
              __int16 v31 = 1024;
              *(_DWORD *)v32 = v23;
              *(_WORD *)&v32[4] = 2048;
              *(void *)&v32[6] = v4;
              *(_WORD *)&v32[14] = 2080;
              *(void *)&v32[16] = "client";
              *(_WORD *)&v32[24] = 2080;
              *(void *)&v32[26] = "dnssd-client.c";
              __int16 v33 = 1024;
              int v34 = 294;
              _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v29, 0x36u);
              int v23 = *v4;
            }
            int *v4 = v23 - 1;
            if (v23 == 1)
            {
              uint64_t v25 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                int v29 = 136447234;
                v30 = "dnssd_client_dns_service_event_handler";
                __int16 v31 = 2048;
                *(void *)v32 = v4;
                *(_WORD *)&v32[8] = 2080;
                *(void *)&v32[10] = "client";
                *(_WORD *)&v32[18] = 2080;
                *(void *)&v32[20] = "dnssd-client.c";
                *(_WORD *)&v32[28] = 1024;
                *(_DWORD *)&v32[30] = 294;
                _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v29, 0x30u);
              }
              ++dnssd_client_finalized;
              dnssd_client_finalize((uint64_t)v4);
            }
            return;
          }
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_52:
          }
            abort();
          int v29 = 136447490;
          v30 = "dnssd_client_dns_service_event_handler";
          __int16 v31 = 1024;
          *(_DWORD *)v32 = v23;
          *(_WORD *)&v32[4] = 2048;
          *(void *)&v32[6] = v4;
          *(_WORD *)&v32[14] = 2080;
          *(void *)&v32[16] = "client";
          *(_WORD *)&v32[24] = 2080;
          *(void *)&v32[26] = "dnssd-client.c";
          __int16 v33 = 1024;
          int v34 = 294;
          uint64_t v27 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        }
        else
        {
          uint64_t v24 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
            goto LABEL_52;
          }
          int v29 = 136447490;
          v30 = "dnssd_client_dns_service_event_handler";
          __int16 v31 = 1024;
          *(_DWORD *)v32 = 0;
          *(_WORD *)&v32[4] = 2048;
          *(void *)&v32[6] = v4;
          *(_WORD *)&v32[14] = 2080;
          *(void *)&v32[16] = "client";
          *(_WORD *)&v32[24] = 2080;
          *(void *)&v32[26] = "dnssd-client.c";
          __int16 v33 = 1024;
          int v34 = 294;
          uint64_t v27 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        }
        uint64_t v28 = v24;
LABEL_51:
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_FAULT, v27, (uint8_t *)&v29, 0x36u);
        goto LABEL_52;
      }
      return;
    case 1:
      uint64_t v10 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      int v29 = 136446210;
      v30 = "dnssd_client_dns_service_event_handler";
      uint64_t v11 = "%{public}s: DNS service registration started";
      goto LABEL_9;
    case 2:
      uint64_t v10 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      int v29 = 136446210;
      v30 = "dnssd_client_dns_service_event_handler";
      uint64_t v11 = "%{public}s: DNS service registration interrupted";
LABEL_9:
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v11, (uint8_t *)&v29, 0xCu);
      return;
    case 3:
      __int16 v12 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        int v29 = 136446466;
        v30 = "dnssd_client_dns_service_event_handler";
        __int16 v31 = 1024;
        *(_DWORD *)v32 = a3;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%{public}s: Registered DNS Push connection failed on server with error: %d", (uint8_t *)&v29, 0x12u);
      }
      char v13 = 0;
      int v14 = 20;
      goto LABEL_17;
    default:
      return;
  }
}

uint64_t dnssd_client_should_be_client(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if (v2)
  {
    unsigned int v3 = *(_DWORD *)(v2 + 56);
    if (v3 <= 5 && ((0x36u >> v3) & 1) != 0)
    {
      LODWORD(v2) = 0;
    }
    else if (service_publisher_have_anycast_service(*(void *)(a1 + 48)))
    {
      LODWORD(v2) = 1;
    }
    else
    {
      LODWORD(v2) = service_publisher_have_competing_unicast_service(v2, 0);
    }
  }
  uint64_t v4 = *(void *)(a1 + 56);
  if (v4) {
    BOOL v5 = *(unsigned __int8 *)(v4 + 72) != 0;
  }
  else {
    BOOL v5 = 0;
  }
  BOOL v6 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = "can't be client";
    if ((v5 & v2) != 0) {
      uint64_t v7 = "could be client";
    }
    os_log_type_t v8 = " might publish";
    if (!v2) {
      os_log_type_t v8 = " won't publish";
    }
    int v11 = 136446978;
    __int16 v12 = "dnssd_client_should_be_client";
    int v14 = v7;
    __int16 v13 = 2082;
    __int16 v15 = 2082;
    uint64_t v16 = v8;
    if (v5) {
      uint32_t v9 = "";
    }
    else {
      uint32_t v9 = " not associated ";
    }
    __int16 v17 = 2082;
    uint64_t v18 = v9;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s%{public}s%{public}s", (uint8_t *)&v11, 0x2Au);
  }
  return v5 & v2;
}

uint64_t dnssd_client_action_probing(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 52);
  if (v2 != 3)
  {
    uint64_t v15 = global_os_log;
    uint64_t result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "dnssd_client_action_probing";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v2;
    __int16 v17 = "%{public}s: state header type isn't omr_client: %d";
    uint64_t v18 = v15;
    os_log_type_t v19 = OS_LOG_TYPE_ERROR;
    uint32_t v20 = 18;
    goto LABEL_51;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  BOOL v5 = global_os_log;
  BOOL v6 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v6)
    {
      uint64_t v7 = *(void *)(v4 + 40);
      uint64_t v8 = *(void *)(v4 + 8);
      uint64_t v9 = *(void *)(a2 + 8);
      uint64_t v10 = *(void *)(v4 + 24);
      *(_DWORD *)buf = 136447491;
      *(void *)&uint8_t buf[4] = "dnssd_client_action_probing";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v7;
      *(_WORD *)&buf[22] = 2160;
      *(void *)&buf[24] = 1752392040;
      *(_WORD *)&buf[32] = 2081;
      *(void *)&buf[34] = v8;
      *(_WORD *)&buf[42] = 2082;
      *(void *)&buf[44] = v9;
      *(_WORD *)&buf[52] = 2082;
      *(void *)&buf[54] = v10;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s/%{private, mask.hash}s: event %{public}s received in state %{public}s", buf, 0x3Eu);
    }
    uint64_t v12 = v4 + 80;
    uint64_t v11 = *(void *)(v4 + 80);
    if (*(_DWORD *)(a2 + 16) == 1)
    {
      uint64_t v13 = *(void *)(v11 + 48);
      if (v13)
      {
        int v14 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "dnssd_client_action_probing";
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: server probe startup timeout expired--publishing cached data.", buf, 0xCu);
          uint64_t v13 = *(void *)(v11 + 48);
        }
        service_publisher_re_advertise_matching(v13);
      }
      return 0;
    }
    if ((dnssd_client_should_be_client(*(void *)(v4 + 80)) & 1) == 0)
    {
      ioloop_cancel_wake_event(*(void *)(v4 + 88));
      return 2;
    }
  }
  else
  {
    if (v6)
    {
      uint64_t v21 = *(void *)(v4 + 40);
      uint64_t v22 = *(void *)(v4 + 8);
      uint64_t v23 = *(void *)(v4 + 24);
      *(_DWORD *)buf = 136447235;
      *(void *)&uint8_t buf[4] = "dnssd_client_action_probing";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = v21;
      *(_WORD *)&buf[22] = 2160;
      *(void *)&buf[24] = 1752392040;
      *(_WORD *)&buf[32] = 2081;
      *(void *)&buf[34] = v22;
      *(_WORD *)&buf[42] = 2082;
      *(void *)&buf[44] = v23;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s/%{private, mask.hash}s: entering state %{public}s", buf, 0x34u);
    }
    uint64_t v12 = v4 + 80;
    uint64_t v11 = *(void *)(v4 + 80);
    ioloop_add_wake_event(*(void *)(v4 + 88), v4, (uint64_t)dnssd_client_wait_expired, (uint64_t)dnssd_client_context_release, 0x1388u);
    uint64_t v24 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v25 = *(_DWORD *)v4;
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "dnssd_client_action_probing";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v25;
      *(_WORD *)&buf[18] = 2048;
      *(void *)&buf[20] = v4;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "client";
      *(_WORD *)&buf[38] = 2080;
      *(void *)&buf[40] = "dnssd-client.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 495;
      _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    int v26 = *(_DWORD *)v4;
    if (*(_DWORD *)v4)
    {
      int v27 = v26 + 1;
      *(_DWORD *)uint64_t v4 = v26 + 1;
      if (v26 + 1 >= 10001)
      {
        uint64_t v28 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_21;
        }
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "dnssd_client_action_probing";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v27;
        *(_WORD *)&buf[18] = 2048;
        *(void *)&buf[20] = v4;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "client";
        *(_WORD *)&buf[38] = 2080;
        *(void *)&buf[40] = "dnssd-client.c";
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 495;
        int v29 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        goto LABEL_20;
      }
    }
    else
    {
      ++dnssd_client_created;
      *(_DWORD *)uint64_t v4 = 1;
    }
  }
  uint64_t v30 = *(void *)(*(void *)v12 + 40);
  if (!v30) {
    goto LABEL_49;
  }
  uint64_t v31 = *(void *)(v30 + 48);
  if (!v31) {
    goto LABEL_49;
  }
  do
  {
    if (!*(unsigned char *)(v31 + 27) && *(unsigned char *)(v31 + 48) && *(unsigned char *)(v31 + 49))
    {
      uint64_t v36 = *(int **)(v4 + 136);
      if (v36) {
        thread_service_release_(v36, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-client.c", 520);
      }
      *(void *)(v4 + 136) = v31;
      thread_service_retain_((int *)v31, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-client.c", 523);
      int v37 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "dnssd_client_action_probing";
        _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "%{public}s: server probe succeeded--unpublishing cached data.", buf, 0xCu);
      }
      service_publisher_unadvertise_all(*(void *)(v11 + 48));
      ioloop_cancel_wake_event(*(void *)(v4 + 88));
      return 4;
    }
    uint64_t v31 = *(void *)(v31 + 8);
  }
  while (v31);
  uint64_t v32 = *(void *)(v30 + 48);
  if (!v32) {
    goto LABEL_49;
  }
  uint64_t v33 = 0;
  do
  {
    if (*(_DWORD *)(v32 + 20) == 2 && !*(unsigned char *)(v32 + 27))
    {
      if (*(unsigned char *)(v32 + 28)) {
        goto LABEL_48;
      }
      if (!v33)
      {
        if (*(unsigned char *)(v32 + 48) || *(void *)(v32 + 56))
        {
          uint64_t v33 = 0;
        }
        else if (*(unsigned char *)(v32 + 24))
        {
          uint64_t v33 = 0;
        }
        else
        {
          uint64_t v33 = v32;
        }
      }
    }
    uint64_t v32 = *(void *)(v32 + 8);
  }
  while (v32);
  if (!v33)
  {
LABEL_49:
    uint64_t v34 = global_os_log;
    BOOL v35 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
    uint64_t result = 0;
    if (!v35) {
      return result;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "dnssd_client_action_probing";
    __int16 v17 = "%{public}s: no service to publish";
    uint64_t v18 = v34;
    os_log_type_t v19 = OS_LOG_TYPE_DEFAULT;
    uint32_t v20 = 12;
LABEL_51:
    _os_log_impl((void *)&_mh_execute_header, v18, v19, v17, buf, v20);
    return 0;
  }
  snprintf(buf, 0x80uLL, "service_tracker_unverified_service_get returning %p", (const void *)v33);
  snprintf(__str, 0x14uLL, "[ST%lld]", *(void *)(v30 + 8));
  thread_service_note((uint64_t)__str, v33, (uint64_t)buf);
  if (!*(unsigned char *)(v33 + 28))
  {
    if (*(_DWORD *)(v33 + 20) == 3)
    {
      *(void *)(v33 + 64) = *(void *)(v4 + 104);
      *(_DWORD *)(v33 + 72) = -16777216;
      *(_WORD *)(v33 + 76) = 254;
      *(_WORD *)(v33 + 78) = bswap32(*(unsigned __int16 *)(v33 + 16)) >> 16;
    }
    v38 = global_os_log;
    BOOL v39 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
    int v40 = *(_DWORD *)v4;
    if (v39)
    {
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "dnssd_client_action_probing";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v40;
      *(_WORD *)&buf[18] = 2048;
      *(void *)&buf[20] = v4;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "client";
      *(_WORD *)&buf[38] = 2080;
      *(void *)&buf[40] = "dnssd-client.c";
      *(_WORD *)&buf[48] = 1024;
      *(_DWORD *)&buf[50] = 551;
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      int v40 = *(_DWORD *)v4;
    }
    if (v40)
    {
      int v41 = v40 + 1;
      *(_DWORD *)uint64_t v4 = v40 + 1;
      if (v40 + 1 >= 10001)
      {
        uint64_t v28 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136447490;
          *(void *)&uint8_t buf[4] = "dnssd_client_action_probing";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v41;
          *(_WORD *)&buf[18] = 2048;
          *(void *)&buf[20] = v4;
          *(_WORD *)&buf[28] = 2080;
          *(void *)&buf[30] = "client";
          *(_WORD *)&buf[38] = 2080;
          *(void *)&buf[40] = "dnssd-client.c";
          *(_WORD *)&buf[48] = 1024;
          *(_DWORD *)&buf[50] = 551;
          int v29 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_20:
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_FAULT, v29, buf, 0x36u);
          goto LABEL_21;
        }
        goto LABEL_21;
      }
    }
    else
    {
      ++dnssd_client_created;
      *(_DWORD *)uint64_t v4 = 1;
    }
    int v42 = *(_DWORD *)(v33 + 20);
    if (v42 == 3)
    {
      memset(&buf[8], 0, 20);
      *(void *)buf = 0;
      *(_OWORD *)&buf[8] = *(_OWORD *)(v33 + 64);
      *(_WORD *)&buf[2] = 13568;
      buf[1] = 30;
    }
    else
    {
      if (v42 != 2)
      {
        v47 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "probe_srp_service";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v42;
          _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_FAULT, "%{public}s: bogus service type in probe_srp_service: %d", buf, 0x12u);
        }
        *(void *)buf = _NSConcreteStackBlock;
        *(void *)&buf[8] = 0x40000000;
        *(void *)&buf[16] = __probe_srp_service_block_invoke;
        *(void *)&buf[24] = &__block_descriptor_tmp_113;
        *(void *)&buf[32] = dnssd_client_probe_callback;
        *(void *)&buf[40] = v33;
        *(void *)&buf[48] = v4;
        *(void *)&buf[56] = dnssd_client_context_release;
        dispatch_async((dispatch_queue_t)&_dispatch_main_q, buf);
        return 0;
      }
      if (*(unsigned char *)(v33 + 28) || *(unsigned char *)(v33 + 24)) {
        return 0;
      }
      memset(&buf[8], 0, 20);
      *(void *)buf = 7680;
      *(_OWORD *)&buf[8] = *(_OWORD *)(v33 + 64);
      *(_WORD *)&buf[2] = *(_WORD *)(v33 + 80);
    }
    uint64_t v43 = probe_srp_create((uint64_t)buf, v33, v4);
    v44 = v43;
    if (!v43) {
      return 0;
    }
    int v45 = *v43;
    if (*v43)
    {
      uint64_t v28 = global_os_log;
      if (v45 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447490;
          *(void *)&uint8_t buf[4] = "probe_srp_service";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v45;
          *(_WORD *)&buf[18] = 2048;
          *(void *)&buf[20] = v44;
          *(_WORD *)&buf[28] = 2080;
          *(void *)&buf[30] = "probe_state";
          *(_WORD *)&buf[38] = 2080;
          *(void *)&buf[40] = "probe-srp.c";
          *(_WORD *)&buf[48] = 1024;
          *(_DWORD *)&buf[50] = 445;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          int v45 = *v44;
        }
        int *v44 = v45 - 1;
        if (v45 == 1)
        {
          uint32_t v46 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "probe_srp_service";
            *(_WORD *)&buf[12] = 2048;
            *(void *)&buf[14] = v44;
            *(_WORD *)&buf[22] = 2080;
            *(void *)&buf[24] = "probe_state";
            *(_WORD *)&buf[32] = 2080;
            *(void *)&buf[34] = "probe-srp.c";
            *(_WORD *)&buf[42] = 1024;
            *(_DWORD *)&buf[44] = 445;
            _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          }
          ++probe_state_finalized;
          probe_state_finalize(v44);
        }
        return 0;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "probe_srp_service";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v45;
        *(_WORD *)&buf[18] = 2048;
        *(void *)&buf[20] = v44;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "probe_state";
        *(_WORD *)&buf[38] = 2080;
        *(void *)&buf[40] = "probe-srp.c";
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 445;
        int v29 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_20;
      }
    }
    else
    {
      uint64_t v28 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "probe_srp_service";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = 0;
        *(_WORD *)&buf[18] = 2048;
        *(void *)&buf[20] = v44;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "probe_state";
        *(_WORD *)&buf[38] = 2080;
        *(void *)&buf[40] = "probe-srp.c";
        *(_WORD *)&buf[48] = 1024;
        *(_DWORD *)&buf[50] = 445;
        int v29 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_20;
      }
    }
LABEL_21:
    abort();
  }
  uint64_t v32 = v33;
LABEL_48:
  snprintf(buf, 0x14uLL, "[ST%lld]", *(void *)(*(void *)(*(void *)v12 + 40) + 8));
  thread_service_note((uint64_t)buf, v32, (uint64_t)" is still being probed");
  return 0;
}

void dnssd_client_probe_callback(uint64_t a1, uint64_t a2)
{
  unsigned int v3 = state_machine_event_create(11);
  if (v3)
  {
    uint64_t v4 = v3;
    state_machine_event_deliver(a2 + 8, (uint64_t)v3);
    int v5 = *v4;
    if (*v4)
    {
      BOOL v6 = global_os_log;
      if (v5 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v11 = 136447490;
          uint64_t v12 = "dnssd_client_probe_callback";
          __int16 v13 = 1024;
          *(_DWORD *)int v14 = v5;
          *(_WORD *)&v14[4] = 2048;
          *(void *)&v14[6] = v4;
          *(_WORD *)&v14[14] = 2080;
          *(void *)&v14[16] = "event";
          *(_WORD *)&v14[24] = 2080;
          *(void *)&v14[26] = "dnssd-client.c";
          __int16 v15 = 1024;
          int v16 = 182;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v11, 0x36u);
          int v5 = *v4;
        }
        int *v4 = v5 - 1;
        if (v5 == 1)
        {
          uint64_t v7 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v11 = 136447234;
            uint64_t v12 = "dnssd_client_probe_callback";
            __int16 v13 = 2048;
            *(void *)int v14 = v4;
            *(_WORD *)&v14[8] = 2080;
            *(void *)&v14[10] = "event";
            *(_WORD *)&v14[18] = 2080;
            *(void *)&v14[20] = "dnssd-client.c";
            *(_WORD *)&v14[28] = 1024;
            *(_DWORD *)&v14[30] = 182;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v11, 0x30u);
          }
          ++state_machine_event_finalized;
          uint64_t v8 = (void (*)(int *))*((void *)v4 + 4);
          if (v8) {
            v8(v4);
          }
          free(v4);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_20:
      }
        abort();
      int v11 = 136447490;
      uint64_t v12 = "dnssd_client_probe_callback";
      __int16 v13 = 1024;
      *(_DWORD *)int v14 = v5;
      *(_WORD *)&v14[4] = 2048;
      *(void *)&v14[6] = v4;
      *(_WORD *)&v14[14] = 2080;
      *(void *)&v14[16] = "event";
      *(_WORD *)&v14[24] = 2080;
      *(void *)&v14[26] = "dnssd-client.c";
      __int16 v15 = 1024;
      int v16 = 182;
      uint64_t v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      BOOL v6 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_20;
      }
      int v11 = 136447490;
      uint64_t v12 = "dnssd_client_probe_callback";
      __int16 v13 = 1024;
      *(_DWORD *)int v14 = 0;
      *(_WORD *)&v14[4] = 2048;
      *(void *)&v14[6] = v4;
      *(_WORD *)&v14[14] = 2080;
      *(void *)&v14[16] = "event";
      *(_WORD *)&v14[24] = 2080;
      *(void *)&v14[26] = "dnssd-client.c";
      __int16 v15 = 1024;
      int v16 = 182;
      uint64_t v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v11, 0x36u);
    goto LABEL_20;
  }
  uint64_t v9 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    int v11 = 136446210;
    uint64_t v12 = "dnssd_client_probe_callback";
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v11, 0xCu);
  }
}

void dnssd_client_wait_expired(uint64_t a1)
{
  int v2 = state_machine_event_create(1);
  if (v2)
  {
    unsigned int v3 = v2;
    state_machine_event_deliver(a1 + 8, (uint64_t)v2);
    int v4 = *v3;
    if (*v3)
    {
      int v5 = global_os_log;
      if (v4 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v10 = 136447490;
          int v11 = "dnssd_client_wait_expired";
          __int16 v12 = 1024;
          *(_DWORD *)__int16 v13 = v4;
          *(_WORD *)&v13[4] = 2048;
          *(void *)&v13[6] = v3;
          *(_WORD *)&v13[14] = 2080;
          *(void *)&v13[16] = "event";
          *(_WORD *)&v13[24] = 2080;
          *(void *)&v13[26] = "dnssd-client.c";
          __int16 v14 = 1024;
          int v15 = 155;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v10, 0x36u);
          int v4 = *v3;
        }
        *unsigned int v3 = v4 - 1;
        if (v4 == 1)
        {
          BOOL v6 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v10 = 136447234;
            int v11 = "dnssd_client_wait_expired";
            __int16 v12 = 2048;
            *(void *)__int16 v13 = v3;
            *(_WORD *)&v13[8] = 2080;
            *(void *)&v13[10] = "event";
            *(_WORD *)&v13[18] = 2080;
            *(void *)&v13[20] = "dnssd-client.c";
            *(_WORD *)&v13[28] = 1024;
            *(_DWORD *)&v13[30] = 155;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v10, 0x30u);
          }
          ++state_machine_event_finalized;
          uint64_t v7 = (void (*)(int *))*((void *)v3 + 4);
          if (v7) {
            v7(v3);
          }
          free(v3);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_20:
      }
        abort();
      int v10 = 136447490;
      int v11 = "dnssd_client_wait_expired";
      __int16 v12 = 1024;
      *(_DWORD *)__int16 v13 = v4;
      *(_WORD *)&v13[4] = 2048;
      *(void *)&v13[6] = v3;
      *(_WORD *)&v13[14] = 2080;
      *(void *)&v13[16] = "event";
      *(_WORD *)&v13[24] = 2080;
      *(void *)&v13[26] = "dnssd-client.c";
      __int16 v14 = 1024;
      int v15 = 155;
      uint64_t v9 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      int v5 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_20;
      }
      int v10 = 136447490;
      int v11 = "dnssd_client_wait_expired";
      __int16 v12 = 1024;
      *(_DWORD *)__int16 v13 = 0;
      *(_WORD *)&v13[4] = 2048;
      *(void *)&v13[6] = v3;
      *(_WORD *)&v13[14] = 2080;
      *(void *)&v13[16] = "event";
      *(_WORD *)&v13[24] = 2080;
      *(void *)&v13[26] = "dnssd-client.c";
      __int16 v14 = 1024;
      int v15 = 155;
      uint64_t v9 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, v9, (uint8_t *)&v10, 0x36u);
    goto LABEL_20;
  }
  uint64_t v8 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    int v10 = 136446210;
    int v11 = "dnssd_client_wait_expired";
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v10, 0xCu);
  }
}

uint64_t dnssd_client_action_not_client(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 52);
  if (v2 != 3)
  {
    __int16 v12 = global_os_log;
    uint64_t result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v16 = 136446466;
    __int16 v17 = "dnssd_client_action_not_client";
    __int16 v18 = 1024;
    LODWORD(v19) = v2;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%{public}s: state header type isn't omr_client: %d", (uint8_t *)&v16, 0x12u);
    return 0;
  }
  int v4 = *(uint64_t **)(a1 + 8);
  int v5 = global_os_log;
  BOOL v6 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (!a2)
  {
    if (v6)
    {
      uint64_t v13 = v4[5];
      uint64_t v14 = v4[1];
      uint64_t v15 = v4[3];
      int v16 = 136447235;
      __int16 v17 = "dnssd_client_action_not_client";
      __int16 v18 = 2082;
      uint64_t v19 = v13;
      __int16 v20 = 2160;
      uint64_t v21 = 1752392040;
      __int16 v22 = 2081;
      uint64_t v23 = v14;
      __int16 v24 = 2082;
      uint64_t v25 = v15;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s/%{private, mask.hash}s: entering state %{public}s", (uint8_t *)&v16, 0x34u);
    }
    if (v4[17]) {
      dnssd_client_service_unpublish(v4);
    }
    return 0;
  }
  if (v6)
  {
    uint64_t v7 = v4[5];
    uint64_t v8 = v4[1];
    uint64_t v9 = *(void *)(a2 + 8);
    uint64_t v10 = v4[3];
    int v16 = 136447491;
    __int16 v17 = "dnssd_client_action_not_client";
    __int16 v18 = 2082;
    uint64_t v19 = v7;
    __int16 v20 = 2160;
    uint64_t v21 = 1752392040;
    __int16 v22 = 2081;
    uint64_t v23 = v8;
    __int16 v24 = 2082;
    uint64_t v25 = v9;
    __int16 v26 = 2082;
    uint64_t v27 = v10;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s/%{private, mask.hash}s: event %{public}s received in state %{public}s", (uint8_t *)&v16, 0x3Eu);
  }
  if (dnssd_client_should_be_client(v4[10])) {
    return 3;
  }
  else {
    return 0;
  }
}

uint64_t dnssd_client_action_startup(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 52);
  if (v2 == 3)
  {
    uint64_t v4 = *(void *)(a1 + 8);
    uint64_t v5 = global_os_log;
    BOOL v6 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
    if (a2)
    {
      if (v6)
      {
        uint64_t v7 = *(void *)(v4 + 40);
        uint64_t v8 = *(void *)(v4 + 8);
        uint64_t v9 = *(void *)(a2 + 8);
        uint64_t v10 = *(void *)(v4 + 24);
        int v19 = 136447491;
        __int16 v20 = "dnssd_client_action_startup";
        __int16 v21 = 2082;
        uint64_t v22 = v7;
        __int16 v23 = 2160;
        uint64_t v24 = 1752392040;
        __int16 v25 = 2081;
        uint64_t v26 = v8;
        __int16 v27 = 2082;
        uint64_t v28 = v9;
        __int16 v29 = 2082;
        uint64_t v30 = v10;
        int v11 = "%{public}s: %{public}s/%{private, mask.hash}s: event %{public}s received in state %{public}s";
        __int16 v12 = v5;
        uint32_t v13 = 62;
LABEL_9:
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v11, (uint8_t *)&v19, v13);
      }
    }
    else if (v6)
    {
      uint64_t v16 = *(void *)(v4 + 40);
      uint64_t v17 = *(void *)(v4 + 8);
      uint64_t v18 = *(void *)(v4 + 24);
      int v19 = 136447235;
      __int16 v20 = "dnssd_client_action_startup";
      __int16 v21 = 2082;
      uint64_t v22 = v16;
      __int16 v23 = 2160;
      uint64_t v24 = 1752392040;
      __int16 v25 = 2081;
      uint64_t v26 = v17;
      __int16 v27 = 2082;
      uint64_t v28 = v18;
      int v11 = "%{public}s: %{public}s/%{private, mask.hash}s: entering state %{public}s";
      __int16 v12 = v5;
      uint32_t v13 = 52;
      goto LABEL_9;
    }
    return 2 * *(unsigned __int8 *)(v4 + 120);
  }
  uint64_t v14 = global_os_log;
  uint64_t result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
  if (result)
  {
    int v19 = 136446466;
    __int16 v20 = "dnssd_client_action_startup";
    __int16 v21 = 1024;
    LODWORD(v22) = v2;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%{public}s: state header type isn't omr_client: %d", (uint8_t *)&v19, 0x12u);
    return 0;
  }
  return result;
}

void dnssd_client_active_data_set_changed_callback(uint64_t a1, int a2)
{
  if (a2)
  {
    uint64_t v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v22 = "dnssd_client_active_data_set_changed_callback";
      __int16 v23 = 1024;
      *(_DWORD *)uint64_t v24 = a2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%{public}s: error %d", buf, 0x12u);
    }
    if (!a1) {
      goto LABEL_13;
    }
    int v5 = *(_DWORD *)a1;
    if (*(_DWORD *)a1)
    {
      BOOL v6 = global_os_log;
      if (v5 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447490;
          uint64_t v22 = "dnssd_client_active_data_set_changed_callback";
          __int16 v23 = 1024;
          *(_DWORD *)uint64_t v24 = v5;
          *(_WORD *)&v24[4] = 2048;
          *(void *)&v24[6] = a1;
          *(_WORD *)&v24[14] = 2080;
          *(void *)&v24[16] = "client";
          *(_WORD *)&v24[24] = 2080;
          *(void *)&v24[26] = "dnssd-client.c";
          __int16 v25 = 1024;
          int v26 = 697;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          int v5 = *(_DWORD *)a1;
        }
        *(_DWORD *)a1 = v5 - 1;
        if (v5 == 1)
        {
          uint64_t v7 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447234;
            uint64_t v22 = "dnssd_client_active_data_set_changed_callback";
            __int16 v23 = 2048;
            *(void *)uint64_t v24 = a1;
            *(_WORD *)&v24[8] = 2080;
            *(void *)&v24[10] = "client";
            *(_WORD *)&v24[18] = 2080;
            *(void *)&v24[20] = "dnssd-client.c";
            *(_WORD *)&v24[28] = 1024;
            *(_DWORD *)&v24[30] = 697;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          }
          ++dnssd_client_finalized;
          dnssd_client_finalize(a1);
        }
LABEL_13:
        cti_events_discontinue(*(void *)(a1 + 96));
        *(void *)(a1 + 96) = 0;
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_40:
      }
        abort();
      *(_DWORD *)buf = 136447490;
      uint64_t v22 = "dnssd_client_active_data_set_changed_callback";
      __int16 v23 = 1024;
      *(_DWORD *)uint64_t v24 = v5;
      *(_WORD *)&v24[4] = 2048;
      *(void *)&v24[6] = a1;
      *(_WORD *)&v24[14] = 2080;
      *(void *)&v24[16] = "client";
      *(_WORD *)&v24[24] = 2080;
      *(void *)&v24[26] = "dnssd-client.c";
      __int16 v25 = 1024;
      int v26 = 697;
      uint64_t v14 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      BOOL v6 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_40;
      }
      *(_DWORD *)buf = 136447490;
      uint64_t v22 = "dnssd_client_active_data_set_changed_callback";
      __int16 v23 = 1024;
      *(_DWORD *)uint64_t v24 = 0;
      *(_WORD *)&v24[4] = 2048;
      *(void *)&v24[6] = a1;
      *(_WORD *)&v24[14] = 2080;
      *(void *)&v24[16] = "client";
      *(_WORD *)&v24[24] = 2080;
      *(void *)&v24[26] = "dnssd-client.c";
      __int16 v25 = 1024;
      int v26 = 697;
      uint64_t v14 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
LABEL_39:
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, v14, buf, 0x36u);
    goto LABEL_40;
  }
  xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v8, "interface", "org.wpantund.v1");
  xpc_dictionary_set_string(v8, "path", "/org/wpantund/utun2");
  xpc_dictionary_set_string(v8, "method", "PropGet");
  xpc_dictionary_set_string(v8, "property_name", "IPv6:MeshLocalPrefix");
  int v9 = setup_for_command(0, (uint64_t)"get_mesh_local_prefix", 0, (uint64_t)"IPv6:MeshLocalPrefix", v8, a1, (uint64_t)dnssd_client_get_mesh_local_prefix_callback, (uint64_t)cti_internal_string_property_reply, 0, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-client.c", 703);
  xpc_release(v8);
  uint64_t v10 = global_os_log;
  if (v9)
  {
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v22 = "dnssd_client_active_data_set_changed_callback";
      __int16 v23 = 1024;
      *(_DWORD *)uint64_t v24 = v9;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%{public}s: cti_get_mesh_local_prefix failed with status %d", buf, 0x12u);
    }
  }
  else
  {
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = *(_DWORD *)a1;
      *(_DWORD *)buf = 136447490;
      uint64_t v22 = "dnssd_client_active_data_set_changed_callback";
      __int16 v23 = 1024;
      *(_DWORD *)uint64_t v24 = v11;
      *(_WORD *)&v24[4] = 2048;
      *(void *)&v24[6] = a1;
      *(_WORD *)&v24[14] = 2080;
      *(void *)&v24[16] = "client";
      *(_WORD *)&v24[24] = 2080;
      *(void *)&v24[26] = "dnssd-client.c";
      __int16 v25 = 1024;
      int v26 = 707;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    int v12 = *(_DWORD *)a1;
    if (*(_DWORD *)a1)
    {
      int v13 = v12 + 1;
      *(_DWORD *)a1 = v12 + 1;
      if (v12 + 1 >= 10001)
      {
        BOOL v6 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_40;
        }
        *(_DWORD *)buf = 136447490;
        uint64_t v22 = "dnssd_client_active_data_set_changed_callback";
        __int16 v23 = 1024;
        *(_DWORD *)uint64_t v24 = v13;
        *(_WORD *)&v24[4] = 2048;
        *(void *)&v24[6] = a1;
        *(_WORD *)&v24[14] = 2080;
        *(void *)&v24[16] = "client";
        *(_WORD *)&v24[24] = 2080;
        *(void *)&v24[26] = "dnssd-client.c";
        __int16 v25 = 1024;
        int v26 = 707;
        uint64_t v14 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        goto LABEL_39;
      }
    }
    else
    {
      ++dnssd_client_created;
      *(_DWORD *)a1 = 1;
    }
  }
  int tunnel_name = cti_get_tunnel_name_(a1, (uint64_t)dnssd_client_get_tunnel_name_callback, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-client.c", 709);
  uint64_t v16 = global_os_log;
  if (tunnel_name)
  {
    int v17 = tunnel_name;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v22 = "dnssd_client_active_data_set_changed_callback";
      __int16 v23 = 1024;
      *(_DWORD *)uint64_t v24 = v17;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "%{public}s: cti_get_tunnel_name failed with status %d", buf, 0x12u);
    }
  }
  else
  {
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v18 = *(_DWORD *)a1;
      *(_DWORD *)buf = 136447490;
      uint64_t v22 = "dnssd_client_active_data_set_changed_callback";
      __int16 v23 = 1024;
      *(_DWORD *)uint64_t v24 = v18;
      *(_WORD *)&v24[4] = 2048;
      *(void *)&v24[6] = a1;
      *(_WORD *)&v24[14] = 2080;
      *(void *)&v24[16] = "client";
      *(_WORD *)&v24[24] = 2080;
      *(void *)&v24[26] = "dnssd-client.c";
      __int16 v25 = 1024;
      int v26 = 713;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    int v19 = *(_DWORD *)a1;
    if (!*(_DWORD *)a1)
    {
      ++dnssd_client_created;
      *(_DWORD *)a1 = 1;
      return;
    }
    int v20 = v19 + 1;
    *(_DWORD *)a1 = v19 + 1;
    if (v19 + 1 >= 10001)
    {
      BOOL v6 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_40;
      }
      *(_DWORD *)buf = 136447490;
      uint64_t v22 = "dnssd_client_active_data_set_changed_callback";
      __int16 v23 = 1024;
      *(_DWORD *)uint64_t v24 = v20;
      *(_WORD *)&v24[4] = 2048;
      *(void *)&v24[6] = a1;
      *(_WORD *)&v24[14] = 2080;
      *(void *)&v24[16] = "client";
      *(_WORD *)&v24[24] = 2080;
      *(void *)&v24[26] = "dnssd-client.c";
      __int16 v25 = 1024;
      int v26 = 713;
      uint64_t v14 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_39;
    }
  }
}

void dnssd_client_get_tunnel_name_callback(int *a1, char *a2, int a3)
{
  if (!a3)
  {
    a1[41] = if_nametoindex(a2);
    goto LABEL_7;
  }
  int v5 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = 136446466;
    int v11 = "dnssd_client_get_tunnel_name_callback";
    __int16 v12 = 1024;
    *(_DWORD *)int v13 = a3;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: didn't get tunnel name, error code %d", (uint8_t *)&v10, 0x12u);
  }
  if (a1)
  {
LABEL_7:
    int v6 = *a1;
    if (*a1)
    {
      uint64_t v7 = global_os_log;
      if (v6 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v10 = 136447490;
          int v11 = "dnssd_client_get_tunnel_name_callback";
          __int16 v12 = 1024;
          *(_DWORD *)int v13 = v6;
          *(_WORD *)&v13[4] = 2048;
          *(void *)&v13[6] = a1;
          *(_WORD *)&v13[14] = 2080;
          *(void *)&v13[16] = "client";
          *(_WORD *)&v13[24] = 2080;
          *(void *)&v13[26] = "dnssd-client.c";
          __int16 v14 = 1024;
          int v15 = 687;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v10, 0x36u);
          int v6 = *a1;
        }
        *a1 = v6 - 1;
        if (v6 == 1)
        {
          xpc_object_t v8 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v10 = 136447234;
            int v11 = "dnssd_client_get_tunnel_name_callback";
            __int16 v12 = 2048;
            *(void *)int v13 = a1;
            *(_WORD *)&v13[8] = 2080;
            *(void *)&v13[10] = "client";
            *(_WORD *)&v13[18] = 2080;
            *(void *)&v13[20] = "dnssd-client.c";
            *(_WORD *)&v13[28] = 1024;
            *(_DWORD *)&v13[30] = 687;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v10, 0x30u);
          }
          ++dnssd_client_finalized;
          dnssd_client_finalize((uint64_t)a1);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_21:
      }
        abort();
      int v10 = 136447490;
      int v11 = "dnssd_client_get_tunnel_name_callback";
      __int16 v12 = 1024;
      *(_DWORD *)int v13 = v6;
      *(_WORD *)&v13[4] = 2048;
      *(void *)&v13[6] = a1;
      *(_WORD *)&v13[14] = 2080;
      *(void *)&v13[16] = "client";
      *(_WORD *)&v13[24] = 2080;
      *(void *)&v13[26] = "dnssd-client.c";
      __int16 v14 = 1024;
      int v15 = 687;
      int v9 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      uint64_t v7 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_21;
      }
      int v10 = 136447490;
      int v11 = "dnssd_client_get_tunnel_name_callback";
      __int16 v12 = 1024;
      *(_DWORD *)int v13 = 0;
      *(_WORD *)&v13[4] = 2048;
      *(void *)&v13[6] = a1;
      *(_WORD *)&v13[14] = 2080;
      *(void *)&v13[16] = "client";
      *(_WORD *)&v13[24] = 2080;
      *(void *)&v13[26] = "dnssd-client.c";
      __int16 v14 = 1024;
      int v15 = 687;
      int v9 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, v9, (uint8_t *)&v10, 0x36u);
    goto LABEL_21;
  }
}

void dnssd_client_get_mesh_local_prefix_callback(uint64_t a1, char *a2, int a3)
{
  int v6 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = "<null>";
    int v25 = 136446722;
    int v26 = "dnssd_client_get_mesh_local_prefix_callback";
    if (a2) {
      uint64_t v7 = a2;
    }
    __int16 v27 = 2082;
    *(void *)uint64_t v28 = v7;
    *(_WORD *)&v28[8] = 1024;
    *(_DWORD *)&v28[10] = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s %d", (uint8_t *)&v25, 0x1Cu);
  }
  if (!a2 || a3)
  {
LABEL_30:
    if (!a1) {
      return;
    }
    goto LABEL_31;
  }
  xpc_object_t v8 = strchr(a2, 47);
  if (v8)
  {
    int64_t v9 = v8 - a2;
    if (v8 == a2)
    {
      int v10 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
        goto LABEL_30;
      }
      int v25 = 136446723;
      int v26 = "dnssd_client_get_mesh_local_prefix_callback";
      __int16 v27 = 2160;
      *(void *)uint64_t v28 = 1752392040;
      *(_WORD *)&v28[8] = 2081;
      *(void *)&v28[10] = a2;
      int v11 = "%{public}s: bogus prefix: %{private, mask.hash}s";
      goto LABEL_29;
    }
    if ((unint64_t)(v9 - 48) <= 0xFFFFFFFFFFFFFFD0)
    {
      int v10 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
        goto LABEL_30;
      }
      int v25 = 136446723;
      int v26 = "dnssd_client_get_mesh_local_prefix_callback";
      __int16 v27 = 2160;
      *(void *)uint64_t v28 = 1752392040;
      *(_WORD *)&v28[8] = 2081;
      *(void *)&v28[10] = a2;
      int v11 = "%{public}s: prefix too long: %{private, mask.hash}s";
LABEL_29:
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, v11, (uint8_t *)&v25, 0x20u);
      goto LABEL_30;
    }
    __memcpy_chk();
    v31[v9] = 0;
    a2 = v31;
  }
  if (!inet_pton(30, a2, (void *)(a1 + 104)))
  {
    int v10 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_30;
    }
    int v25 = 136446723;
    int v26 = "dnssd_client_get_mesh_local_prefix_callback";
    __int16 v27 = 2160;
    *(void *)uint64_t v28 = 1752392040;
    *(_WORD *)&v28[8] = 2081;
    *(void *)&v28[10] = a2;
    int v11 = "%{public}s: prefix syntax incorrect: %{private, mask.hash}s";
    goto LABEL_29;
  }
  *(unsigned char *)(a1 + 120) = 1;
  __int16 v12 = state_machine_event_create(12);
  if (v12)
  {
    int v13 = v12;
    state_machine_event_deliver(a1 + 8, (uint64_t)v12);
    int v14 = *v13;
    if (!*v13)
    {
      uint64_t v24 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        int v25 = 136447490;
        int v26 = "dnssd_client_get_mesh_local_prefix_callback";
        __int16 v27 = 1024;
        *(_DWORD *)uint64_t v28 = 0;
        *(_WORD *)&v28[4] = 2048;
        *(void *)&v28[6] = v13;
        *(_WORD *)&v28[14] = 2080;
        *(void *)&v28[16] = "event";
        *(_WORD *)&v28[24] = 2080;
        *(void *)&v28[26] = "dnssd-client.c";
        __int16 v29 = 1024;
        int v30 = 225;
        uint64_t v22 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        __int16 v23 = v24;
        goto LABEL_47;
      }
      goto LABEL_48;
    }
    int v15 = global_os_log;
    if (v14 >= 10001)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        int v25 = 136447490;
        int v26 = "dnssd_client_get_mesh_local_prefix_callback";
        __int16 v27 = 1024;
        *(_DWORD *)uint64_t v28 = v14;
        *(_WORD *)&v28[4] = 2048;
        *(void *)&v28[6] = v13;
        *(_WORD *)&v28[14] = 2080;
        *(void *)&v28[16] = "event";
        *(_WORD *)&v28[24] = 2080;
        *(void *)&v28[26] = "dnssd-client.c";
        __int16 v29 = 1024;
        int v30 = 225;
        uint64_t v22 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        __int16 v23 = v15;
        goto LABEL_47;
      }
      goto LABEL_48;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v25 = 136447490;
      int v26 = "dnssd_client_get_mesh_local_prefix_callback";
      __int16 v27 = 1024;
      *(_DWORD *)uint64_t v28 = v14;
      *(_WORD *)&v28[4] = 2048;
      *(void *)&v28[6] = v13;
      *(_WORD *)&v28[14] = 2080;
      *(void *)&v28[16] = "event";
      *(_WORD *)&v28[24] = 2080;
      *(void *)&v28[26] = "dnssd-client.c";
      __int16 v29 = 1024;
      int v30 = 225;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v25, 0x36u);
      int v14 = *v13;
    }
    int *v13 = v14 - 1;
    if (v14 == 1)
    {
      uint64_t v16 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v25 = 136447234;
        int v26 = "dnssd_client_get_mesh_local_prefix_callback";
        __int16 v27 = 2048;
        *(void *)uint64_t v28 = v13;
        *(_WORD *)&v28[8] = 2080;
        *(void *)&v28[10] = "event";
        *(_WORD *)&v28[18] = 2080;
        *(void *)&v28[20] = "dnssd-client.c";
        *(_WORD *)&v28[28] = 1024;
        *(_DWORD *)&v28[30] = 225;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v25, 0x30u);
      }
      ++state_machine_event_finalized;
      int v17 = (void (*)(int *))*((void *)v13 + 4);
      if (v17) {
        v17(v13);
      }
      free(v13);
    }
LABEL_31:
    int v18 = *(_DWORD *)a1;
    if (!*(_DWORD *)a1)
    {
      int v19 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_48;
      }
      int v25 = 136447490;
      int v26 = "dnssd_client_get_mesh_local_prefix_callback";
      __int16 v27 = 1024;
      *(_DWORD *)uint64_t v28 = 0;
      *(_WORD *)&v28[4] = 2048;
      *(void *)&v28[6] = a1;
      *(_WORD *)&v28[14] = 2080;
      *(void *)&v28[16] = "client";
      *(_WORD *)&v28[24] = 2080;
      *(void *)&v28[26] = "dnssd-client.c";
      __int16 v29 = 1024;
      int v30 = 227;
      uint64_t v22 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_46;
    }
    int v19 = global_os_log;
    if (v18 < 10001)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v25 = 136447490;
        int v26 = "dnssd_client_get_mesh_local_prefix_callback";
        __int16 v27 = 1024;
        *(_DWORD *)uint64_t v28 = v18;
        *(_WORD *)&v28[4] = 2048;
        *(void *)&v28[6] = a1;
        *(_WORD *)&v28[14] = 2080;
        *(void *)&v28[16] = "client";
        *(_WORD *)&v28[24] = 2080;
        *(void *)&v28[26] = "dnssd-client.c";
        __int16 v29 = 1024;
        int v30 = 227;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v25, 0x36u);
        int v18 = *(_DWORD *)a1;
      }
      *(_DWORD *)a1 = v18 - 1;
      if (v18 == 1)
      {
        int v20 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v25 = 136447234;
          int v26 = "dnssd_client_get_mesh_local_prefix_callback";
          __int16 v27 = 2048;
          *(void *)uint64_t v28 = a1;
          *(_WORD *)&v28[8] = 2080;
          *(void *)&v28[10] = "client";
          *(_WORD *)&v28[18] = 2080;
          *(void *)&v28[20] = "dnssd-client.c";
          *(_WORD *)&v28[28] = 1024;
          *(_DWORD *)&v28[30] = 227;
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v25, 0x30u);
        }
        ++dnssd_client_finalized;
        dnssd_client_finalize(a1);
      }
      return;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      int v25 = 136447490;
      int v26 = "dnssd_client_get_mesh_local_prefix_callback";
      __int16 v27 = 1024;
      *(_DWORD *)uint64_t v28 = v18;
      *(_WORD *)&v28[4] = 2048;
      *(void *)&v28[6] = a1;
      *(_WORD *)&v28[14] = 2080;
      *(void *)&v28[16] = "client";
      *(_WORD *)&v28[24] = 2080;
      *(void *)&v28[26] = "dnssd-client.c";
      __int16 v29 = 1024;
      int v30 = 227;
      uint64_t v22 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_46:
      __int16 v23 = v19;
LABEL_47:
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_FAULT, v22, (uint8_t *)&v25, 0x36u);
    }
LABEL_48:
    abort();
  }
  __int16 v21 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    int v25 = 136446210;
    int v26 = "dnssd_client_get_mesh_local_prefix_callback";
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v25, 0xCu);
  }
}

uint64_t put_tlv_uint32(char a1, unsigned int a2, unint64_t *a3, unint64_t a4)
{
  if (a3)
  {
    unint64_t v4 = *a3;
    if (*a3)
    {
      if (a4 >= v4 && a4 - v4 >= 8)
      {
        *(unsigned char *)unint64_t v4 = 0;
        *(unsigned char *)(v4 + 1) = a1;
        *(_WORD *)(v4 + 2) = 1024;
        *(_DWORD *)(v4 + 4) = bswap32(a2);
        v4 += 8;
      }
    }
    *a3 = v4;
  }
  return 8;
}

uint64_t ConnectToServer(uint64_t *a1, __int16 a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  long long v53 = 0u;
  memset(v54, 0, sizeof(v54));
  long long v51 = 0u;
  long long v52 = 0u;
  sockaddr v49 = (sockaddr)0;
  long long v50 = 0u;
  if (a1)
  {
    if ((a2 & 0x4000) != 0)
    {
      int v20 = (void *)*a1;
      if (!*a1)
      {
        uint64_t v19 = 4294901756;
        syslog(4, "dnssd_clientstub kDNSServiceFlagsShareConnection used with NULL DNSServiceRef");
        return v19;
      }
      if ((int v21 = *((_DWORD *)v20 + 4), v22 = *((_DWORD *)v20 + 8), v21 < 0)
        || (*((_DWORD *)v20 + 5) ^ v21) != 0x12345678
        || (v22 != 19 ? (BOOL v23 = v22 == 1) : (BOOL v23 = 1), !v23 || v20[1]))
      {
        syslog(4, "dnssd_clientstub kDNSServiceFlagsShareConnection used with invalid DNSServiceRef %p %08X %08X op %d", v20, v21, *((_DWORD *)v20 + 5), v22);
        *a1 = 0;
        return 4294901755;
      }
    }
    __int16 v12 = malloc_type_malloc(0x90uLL, 0xA172743EuLL);
    if (!v12) {
      __break(1u);
    }
    int v13 = v12;
    *(void *)__int16 v12 = 0;
    *((void *)v12 + 1) = 0;
    v12[9] = 0;
    v12[10] = 0;
    v12[8] = a3;
    *((_OWORD *)v12 + 1) = xmmword_10007C600;
    *((void *)v12 + 6) = 0;
    *((void *)v12 + 7) = a4;
    *((void *)v12 + 8) = a5;
    *((void *)v12 + 9) = a6;
    *((_OWORD *)v12 + 5) = 0u;
    *((_OWORD *)v12 + 6) = 0u;
    *((_OWORD *)v12 + 7) = 0u;
    *((_OWORD *)v12 + 8) = 0u;
    ++sdref_created;
    if ((a2 & 0x4000) != 0)
    {
      uint64_t v24 = (void *)*a1;
      do
      {
        int v25 = v24;
        uint64_t v24 = (void *)*v24;
      }
      while (v24);
      *int v25 = v12;
      int v26 = *(_DWORD *)(*a1 + 24);
      *(_DWORD *)(*a1 + 24) = v26 + 1;
      if (v26 == -1) {
        ++*(_DWORD *)(*a1 + 28);
      }
      uint64_t v27 = *a1;
      *((void *)v12 + 1) = *a1;
      *((void *)v12 + 2) = *(void *)(v27 + 16);
      *((void *)v12 + 3) = *(void *)(*a1 + 24);
LABEL_29:
      uint64_t v19 = 0;
      *a1 = (uint64_t)v13;
      return v19;
    }
    uint64_t v48 = 1;
    int v14 = getenv("DNSSD_UDS_PATH");
    if (v14)
    {
      int v15 = v14;
      if (strlen(v14) < 0x68) {
        goto LABEL_9;
      }
      syslog(4, "dnssd_clientstub ConnectToServer: using default path since env len is invalid");
    }
    int v15 = "/var/run/mDNSResponder";
LABEL_9:
    *a1 = 0;
    int v16 = socket(1, 1, 0);
    v13[4] = v16;
    v13[5] = v16 ^ 0x12345678;
    if (v16 < 0)
    {
      int v29 = *__error();
      int v30 = __error();
      uint64_t v31 = strerror(*v30);
      syslog(4, "dnssd_clientstub ConnectToServer: socket failed %d %s", v29, v31);
      FreeDNSServiceOp(v13);
      return 4294901757;
    }
    int v17 = fcntl(v16, 1);
    if (v17 == -1)
    {
      int v18 = "dnssd_clientstub ConnectToServer: Failed to get the file descriptor flags of socket %d %s";
    }
    else
    {
      if (fcntl(v13[4], 2, v17 | 1u) != -1) {
        goto LABEL_35;
      }
      int v18 = "dnssd_clientstub ConnectToServer: Failed to set FD_CLOEXEC on socket %d %s";
    }
    uint64_t v32 = *__error();
    uint64_t v33 = __error();
    uint64_t v34 = strerror(*v33);
    syslog(4, v18, v32, v34);
LABEL_35:
    if (setsockopt(v13[4], 0xFFFF, 4130, &v48, 8u) < 0)
    {
      int v35 = *__error();
      uint64_t v36 = __error();
      int v37 = strerror(*v36);
      syslog(4, "dnssd_clientstub ConnectToServer: SO_NOSIGPIPE failed %d %s", v35, v37);
    }
    v49.sa_family = 1;
    if (strlen(v15) > 0x67) {
      v49.sa_data[0] = 0;
    }
    else {
      __memcpy_chk();
    }
    int v47 = 1;
    if (setsockopt(v13[4], 0xFFFF, 4352, &v47, 4u) < 0)
    {
      int v38 = *__error();
      BOOL v39 = __error();
      int v40 = strerror(*v39);
      syslog(4, "dnssd_clientstub ConnectToServer: SO_DEFUNCTOK failed %d %s", v38, v40);
    }
    int v41 = connect(v13[4], &v49, 0x6Au);
    if (v41)
    {
      int v42 = v41;
      int v43 = v13[4];
      int v44 = *__error();
      int v45 = __error();
      uint32_t v46 = strerror(*v45);
      syslog(4, "dnssd_clientstub ConnectToServer: connect() failed path:%s Socket:%d Err:%d Errno:%d %s", v15, v43, v42, v44, v46);
      close(v13[4]);
      FreeDNSServiceOp(v13);
      return 4294901733;
    }
    goto LABEL_29;
  }
  uint64_t v19 = 4294901756;
  syslog(4, "dnssd_clientstub DNSService operation with NULL DNSServiceRef");
  return v19;
}

uint64_t put_attribute_tlvs(uint64_t a1, uint64_t a2, unint64_t *a3, unint64_t a4)
{
  uint64_t v8 = put_tlv_uint32(3, *(_DWORD *)a1, a3, a4);
  uint64_t v9 = put_tlv_uint32(4, *(_DWORD *)(a1 + 16), a3, a4) + v8;
  int v10 = *(_OWORD **)(a1 + 40);
  if (v10)
  {
    if (a3)
    {
      unint64_t v11 = *a3;
      if (*a3 && a4 >= v11 && a4 - v11 >= 0x14)
      {
        *(_DWORD *)unint64_t v11 = 268438016;
        *(_OWORD *)(v11 + 4) = *v10;
        v11 += 20;
      }
      *a3 = v11;
    }
    v9 += 20;
  }
  if (*(unsigned char *)(a1 + 13)) {
    v9 += put_tlv_uint32(5, *(_DWORD *)(a1 + 8), a3, a4);
  }
  if (*(unsigned char *)(a1 + 12)) {
    v9 += put_tlv_uint32(11, *(_DWORD *)(a1 + 4), a3, a4);
  }
  if (a2) {
    *(_DWORD *)(a2 + 8) |= 2u;
  }
  return v9;
}

_DWORD *create_hdr(int a1, size_t *a2, void *a3, int a4, uint64_t a5)
{
  memset(v15, 0, sizeof(v15));
  if (a4) {
    uint64_t v6 = *a2 + 1;
  }
  else {
    uint64_t v6 = *a2;
  }
  *a2 = v6 + 28;
  if (v6 == -28 || (unint64_t v11 = malloc_type_malloc(v6 + 28, 0xA172743EuLL)) == 0) {
    __break(1u);
  }
  __int16 v12 = v11;
  bzero(v11, *a2);
  _DWORD *v12 = 1;
  v12[1] = v6;
  v12[2] = 0;
  v12[3] = a1;
  *((void *)v12 + 2) = *(void *)(a5 + 24);
  v12[6] = 0;
  *a3 = v12 + 7;
  if (a4)
  {
    size_t v13 = strlen((const char *)v15) + 1;
    memcpy(v12 + 7, v15, v13);
    *a3 += v13;
  }
  return v12;
}

uint64_t deliver_request(int8x16_t *a1, uint64_t a2)
{
  unsigned int v26 = -65537;
  if (*(void *)(a2 + 8)) {
    BOOL v4 = 1;
  }
  else {
    BOOL v4 = ((a1->i32[3] - 2) & 0xFFFFFFF6) == 0;
  }
  int v5 = *(_DWORD *)(a2 + 16);
  if (v5 < 0 || (*(_DWORD *)(a2 + 20) ^ v5) != 0x12345678)
  {
    free(a1);
    syslog(4, "dnssd_clientstub deliver_request: invalid DNSServiceRef %p %08X %08X", (const void *)a2, *(_DWORD *)(a2 + 16), *(_DWORD *)(a2 + 20));
    return 4294901755;
  }
  __int32 v6 = a1->i32[1];
  if (v4)
  {
    if (socketpair(1, 1, 0, v28.fds_bits) < 0)
    {
      int v19 = *__error();
      int v20 = __error();
      int v21 = strerror(*v20);
      syslog(4, "dnssd_clientstub deliver_request: %s failed %d (%s)", "socketpair", v19, v21);
      goto LABEL_34;
    }
    int v7 = v28.fds_bits[0];
    int v8 = v28.fds_bits[1];
    LODWORD(v27.tv_sec) = 1;
    if (setsockopt(v28.fds_bits[0], 0xFFFF, 4352, &v27, 4u) < 0)
    {
      int v9 = *__error();
      int v10 = __error();
      unint64_t v11 = strerror(*v10);
      syslog(4, "dnssd_clientstub deliver_request: SO_DEFUNCTOK failed %d %s", v9, v11);
    }
  }
  else
  {
    int v8 = -1;
    int v7 = -1;
  }
  uint64_t v13 = (v6 - v4);
  *a1 = vrev32q_s8(*a1);
  a1[1].i32[2] = bswap32(a1[1].u32[2]);
  int v14 = write_all(*(_DWORD *)(a2 + 16), a1->i8, v13 + 28);
  if (v14 < 0)
  {
    int v15 = v14;
    syslog(6, "dnssd_clientstub deliver_request ERROR: write_all(%d, %lu bytes) failed", *(_DWORD *)(a2 + 16), v13 + 28);
    BOOL v16 = v15 == -2;
  }
  else
  {
    if (v4)
    {
      v25[0] = (char *)a1 + v13 + 28;
      v25[1] = 1;
      *(_OWORD *)v28.fds_bits = 0u;
      v28.fds_bits[7] = 0;
      v28.fds_bits[2] = 0;
      *(void *)&v28.fds_bits[4] = v25;
      v28.fds_bits[6] = 1;
      *(void *)&v28.fds_bits[8] = &v27;
      *(void *)&v28.fds_bits[10] = 16;
      v27.tv_sec = 0xFFFF00000010;
      v27.tv_usec = 1;
      *(&v27.tv_usec + 1) = v8;
      if (sendmsg(*(_DWORD *)(a2 + 16), (const msghdr *)&v28, 0) < 0)
      {
        int v22 = *__error();
        BOOL v23 = __error();
        uint64_t v24 = strerror(*v23);
        syslog(4, "dnssd_clientstub deliver_request ERROR: sendmsg failed read sd=%d write sd=%d errno %d (%s)", v7, v8, v22, v24);
        unsigned int v26 = -65551;
        if (v8 < 0)
        {
LABEL_32:
          if ((v7 & 0x80000000) == 0) {
            close(v7);
          }
          goto LABEL_34;
        }
LABEL_31:
        close(v8);
        goto LABEL_32;
      }
      close(v8);
      int v8 = -1;
    }
    else
    {
      int v7 = *(_DWORD *)(a2 + 16);
    }
    if (v7 <= 1023)
    {
      *(void *)&v27.tv_usec = 0;
      memset(&v28, 0, sizeof(v28));
      if (__darwin_check_fd_set_overflow(v7, &v28, 0)) {
        *(__int32_t *)((char *)v28.fds_bits + (((unint64_t)v7 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v7;
      }
      v27.tv_sec = 60;
      if (!select(v7 + 1, &v28, 0, 0, &v27))
      {
        syslog(4, "dnssd_clientstub set_waitlimit:_daemon timed out (%d secs) without any response: Socket %d", 60, v7);
        unsigned int v18 = -65568;
        goto LABEL_29;
      }
    }
    unsigned int v26 = 0;
    int all = read_all(v7, (char *)&v26, 4uLL);
    if ((all & 0x80000000) == 0)
    {
      unsigned int v18 = bswap32(v26);
      goto LABEL_29;
    }
    BOOL v16 = all == -3;
  }
  if (v16) {
    unsigned int v18 = -65569;
  }
  else {
    unsigned int v18 = -65563;
  }
LABEL_29:
  unsigned int v26 = v18;
  if (v4)
  {
    if (v8 < 0) {
      goto LABEL_32;
    }
    goto LABEL_31;
  }
LABEL_34:
  free(a1);
  return v26;
}

void DNSServiceRefDeallocate(DNSServiceRef sdRef)
{
  if (sdRef)
  {
    DNSServiceRef v1 = sdRef;
    int v2 = *((_DWORD *)sdRef + 4);
    if (v2 < 0 || (*((_DWORD *)sdRef + 5) ^ v2) != 0x12345678)
    {
      syslog(4, "dnssd_clientstub DNSServiceRefDeallocate called with invalid DNSServiceRef %p %08X %08X");
    }
    else
    {
      unsigned int v3 = (_DWORD *)*((void *)sdRef + 6);
      if (v3) {
        *unsigned int v3 = 0;
      }
      DNSServiceRef v4 = (DNSServiceRef)*((void *)sdRef + 1);
      if (v4)
      {
        do
        {
          int v5 = v4;
          DNSServiceRef v4 = *(DNSServiceRef *)v4;
          if (v4) {
            BOOL v6 = v4 == sdRef;
          }
          else {
            BOOL v6 = 1;
          }
        }
        while (!v6);
        if (v4)
        {
          size_t v11 = 0;
          uint64_t v12 = 0;
          int v7 = (int8x16_t *)create_hdr(63, &v11, &v12, 0, (uint64_t)sdRef);
          int8x16_t *v7 = vrev32q_s8(*v7);
          v7[1].i32[2] = bswap32(v7[1].u32[2]);
          write_all(*((_DWORD *)v1 + 4), v7->i8, v11);
          free(v7);
          void *v5 = *(void *)v1;
          FreeDNSServiceOp(v1);
        }
      }
      else
      {
        if (*((void *)sdRef + 11))
        {
          *((void *)sdRef + 7) = 0;
          shutdown(*((_DWORD *)sdRef + 4), 1);
          dispatch_source_cancel(*((dispatch_source_t *)v1 + 11));
          int v8 = *((void *)v1 + 11);
          if (v8)
          {
            dispatch_release(v8);
            *((void *)v1 + 11) = 0;
          }
        }
        else if (!*((void *)sdRef + 12))
        {
          close(*((_DWORD *)sdRef + 4));
        }
        do
        {
          int v9 = *(_DNSServiceRef_t **)v1;
          int v10 = (_DWORD *)*((void *)v1 + 6);
          if (v10) {
            _DWORD *v10 = 0;
          }
          FreeDNSServiceOp(v1);
          DNSServiceRef v1 = v9;
        }
        while (v9);
      }
    }
  }
  else
  {
    syslog(4, "dnssd_clientstub DNSServiceRefDeallocate called with NULL DNSServiceRef");
  }
}

uint64_t write_all(int a1, char *a2, size_t a3)
{
  if (!a3) {
    return 0;
  }
  size_t v3 = a3;
  while (1)
  {
    unint64_t v6 = send(a1, a2, v3, 0);
    unint64_t v7 = v6;
    if ((v6 & 0x8000000000000000) != 0) {
      break;
    }
    BOOL v8 = v3 == v6;
    if (v3 < v6) {
      break;
    }
    a2 += v6;
    v3 -= v6;
    if (v8) {
      return 0;
    }
  }
  int v15 = 0;
  socklen_t v14 = 4;
  if (getsockopt(a1, 0xFFFF, 4353, &v15, &v14) < 0)
  {
    int v10 = *__error();
    size_t v11 = __error();
    uint64_t v12 = strerror(*v11);
    syslog(4, "dnssd_clientstub write_all: SO_ISDEFUNCT failed %d %s", v10, v12);
  }
  if (v15)
  {
    syslog(6, "dnssd_clientstub write_all(%d) DEFUNCT");
  }
  else
  {
    if ((v7 & 0x8000000000000000) != 0)
    {
      __error();
      uint64_t v13 = __error();
      strerror(*v13);
    }
    syslog(4, "dnssd_clientstub write_all(%d) failed %ld/%ld %d %s");
  }
  if (v15) {
    return 4294967294;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

void FreeDNSServiceOp(_DWORD *a1)
{
  if ((_DWORD *)dns_service_op_not_to_be_freed == a1)
  {
    syslog(3, "dnssd_clientstub attempt to dispose protected DNSServiceRef %p", a1);
    abort();
  }
  int v2 = a1[5];
  if ((v2 ^ a1[4]) == 0x12345678)
  {
    *(void *)a1 = 0;
    *((void *)a1 + 1) = 0;
    *((void *)a1 + 2) = 0xDDDDDDDDFFFFFFFFLL;
    *((void *)a1 + 4) = 0;
    a1[10] = 0;
    *((_OWORD *)a1 + 3) = 0u;
    *((_OWORD *)a1 + 4) = 0u;
    size_t v3 = *((void *)a1 + 11);
    if (v3)
    {
      dispatch_release(v3);
      *((void *)a1 + 11) = 0;
    }
    *((void *)a1 + 12) = 0;
    DNSServiceRef v4 = (void *)*((void *)a1 + 15);
    if (v4)
    {
      free(v4);
      *((void *)a1 + 15) = 0;
    }
    *((void *)a1 + 16) = 0;
    int v5 = (void *)*((void *)a1 + 10);
    if (v5)
    {
      do
      {
        unint64_t v6 = (void *)*v5;
        ++rref_finalized;
        unint64_t v7 = (void *)v5[7];
        if (v7) {
          free(v7);
        }
        free(v5);
        int v5 = v6;
      }
      while (v6);
    }
    BOOL v8 = (void *)*((void *)a1 + 17);
    if (v8) {
      free(v8);
    }
    free(a1);
    ++sdref_finalized;
  }
  else
  {
    syslog(4, "dnssd_clientstub attempt to dispose invalid DNSServiceRef %p %08X %08X", a1, a1[4], v2);
    FreeDNSServiceOp_op_were_not_going_to_free_but_we_need_to_fool_the_analyzer = (uint64_t)a1;
  }
}

void ___should_return_noauth_error_block_invoke(id a1)
{
  _should_return_noauth_error_s_should = dyld_program_sdk_at_least();
}

uint64_t read_all(int a1, char *a2, size_t a3)
{
  if (!a3) {
    return 0;
  }
  size_t v3 = a3;
  while (1)
  {
    while (1)
    {
      ssize_t v6 = recv(a1, a2, v3, 0);
      ssize_t v7 = v6;
      if (v6 < 0) {
        break;
      }
      if (v6 - 1 >= v3) {
        goto LABEL_10;
      }
      a2 += v6;
      v3 -= v6;
      if (!v3) {
        return 0;
      }
    }
    if (*__error() != 4) {
      break;
    }
    syslog(6, "dnssd_clientstub read_all: EINTR continue");
  }
LABEL_10:
  socklen_t v13 = 4;
  int v14 = 0;
  if (getsockopt(a1, 0xFFFF, 4353, &v14, &v13) < 0)
  {
    int v9 = *__error();
    int v10 = __error();
    size_t v11 = strerror(*v10);
    syslog(4, "dnssd_clientstub read_all: SO_ISDEFUNCT failed %d %s", v9, v11);
  }
  if (v14)
  {
    syslog(6, "dnssd_clientstub read_all(%d) DEFUNCT");
  }
  else
  {
    if (v7 < 0)
    {
      __error();
      uint64_t v12 = __error();
      strerror(*v12);
    }
    syslog(4, "dnssd_clientstub read_all(%d) failed %ld/%ld %d %s");
  }
  if (v7 < 0 && *__error() == 35) {
    return 4294967294;
  }
  if (v14) {
    return 4294967293;
  }
  return 0xFFFFFFFFLL;
}

void handle_query_response(uint64_t a1, _DWORD *a2, unsigned __int16 *a3, unint64_t a4)
{
  if (a2[9] != -65570) {
    goto LABEL_5;
  }
  if (_should_return_noauth_error_s_once != -1) {
    dispatch_once(&_should_return_noauth_error_s_once, &__block_literal_global);
  }
  if (_should_return_noauth_error_s_should)
  {
LABEL_5:
    if (!a3)
    {
      uint64_t v11 = 0;
      uint64_t v12 = 0;
      int v10 = 0;
      uint64_t v13 = 0;
      v38[0] = 0;
      goto LABEL_21;
    }
    BOOL v8 = v38;
    do
    {
      if ((unint64_t)a3 >= a4 || v8 >= v39)
      {
        uint64_t v11 = 0;
        uint64_t v12 = 0;
        int v10 = 0;
        uint64_t v13 = 0;
        v8[-(v8 == v39)] = 0;
        goto LABEL_21;
      }
      int v9 = *(unsigned __int8 *)a3;
      a3 = (unsigned __int16 *)((char *)a3 + 1);
      *v8++ = v9;
    }
    while (v9);
    int v10 = 0;
    uint64_t v11 = 0;
    if (a3)
    {
      uint64_t v12 = 0;
      uint64_t v13 = 0;
      if ((unint64_t)(a3 + 1) > a4) {
        goto LABEL_21;
      }
      int v10 = 0;
      uint64_t v11 = 0;
      uint64_t v12 = bswap32(*a3) >> 16;
      if (a3 != (unsigned __int16 *)-2 && (unint64_t)(a3 + 2) <= a4)
      {
        uint64_t v13 = 0;
        int v10 = 0;
        uint64_t v11 = bswap32(a3[1]) >> 16;
        if (a3 != (unsigned __int16 *)-4 && (unint64_t)(a3 + 3) <= a4)
        {
          uint64_t v13 = bswap32(a3[2]) >> 16;
          int v10 = a3 + 3;
        }
LABEL_21:
        int v14 = (unsigned int *)((char *)v10 + v13);
        if (v10) {
          BOOL v15 = (unint64_t)v14 > a4;
        }
        else {
          BOOL v15 = 1;
        }
        if (v15)
        {
          int v14 = 0;
          int v17 = 0;
        }
        else
        {
          int v17 = v10;
        }
        unsigned int v18 = v14 + 1;
        if (v14) {
          BOOL v19 = (unint64_t)v18 > a4;
        }
        else {
          BOOL v19 = 1;
        }
        if (v19)
        {
          unsigned int v18 = 0;
          unsigned int v20 = 0;
        }
        else
        {
          unsigned int v20 = bswap32(*v14);
        }
        *(void *)(a1 + 104) = 0;
        *(void *)(a1 + 112) = 0;
        int v21 = a2[2];
        if ((v21 & 2) != 0)
        {
          int v22 = (unsigned __int16 *)v18;
          while (1)
          {
            if ((uint64_t)(a4 - (void)v22) < 4)
            {
              int64_t v23 = 0;
              unsigned int v26 = 0;
              goto LABEL_45;
            }
            int64_t v23 = 0;
            uint64_t v24 = v22 + 2;
            if (v22 == (unsigned __int16 *)-4) {
              break;
            }
            int64_t v25 = __rev16(v22[1]);
            unsigned int v26 = 0;
            if ((uint64_t)(a4 - (void)v24) < v25) {
              goto LABEL_45;
            }
            unsigned int v27 = __rev16(*v22);
            int v22 = (unsigned __int16 *)((char *)v24 + v25);
            if (v27 == 7)
            {
              int64_t v23 = v25;
              unsigned int v26 = v24;
              goto LABEL_45;
            }
          }
          unsigned int v26 = 0;
LABEL_45:
          *(void *)(a1 + 104) = v26;
          *(void *)(a1 + 112) = v23;
        }
        if (!&_ne_tracker_check_is_hostname_blocked) {
          goto LABEL_71;
        }
        if (v12 != 28 && v12 != 1) {
          goto LABEL_71;
        }
        if (v11 != 1) {
          goto LABEL_71;
        }
        int v29 = *(void **)(a1 + 120);
        if (!v29) {
          goto LABEL_71;
        }
        if ((v21 & 2) == 0) {
          goto LABEL_69;
        }
        int v37 = v17;
        int v30 = (unsigned __int16 *)v18;
        while (1)
        {
          if ((uint64_t)(a4 - (void)v30) < 4)
          {
            size_t v31 = 0;
            uint64_t v34 = 0;
            goto LABEL_63;
          }
          size_t v31 = 0;
          uint64_t v32 = (const char *)(v30 + 2);
          if (v30 == (unsigned __int16 *)-4) {
            break;
          }
          int64_t v33 = __rev16(v30[1]);
          uint64_t v34 = 0;
          if ((uint64_t)(a4 - (void)v32) < v33) {
            goto LABEL_63;
          }
          unsigned int v35 = __rev16(*v30);
          int v30 = (unsigned __int16 *)&v32[v33];
          if (v35 == 9)
          {
            size_t v31 = v33;
            uint64_t v34 = v32;
            goto LABEL_63;
          }
        }
        uint64_t v34 = 0;
LABEL_63:
        uint64_t v36 = *(void **)(a1 + 120);
        if (strnlen(v34, v31) == v31 - 1)
        {
          int v17 = v37;
          if (v34)
          {
            ne_tracker_create_xcode_issue();
            int v29 = *(void **)(a1 + 120);
            goto LABEL_68;
          }
        }
        else
        {
          int v17 = v37;
        }
        int v29 = v36;
LABEL_68:
        if (!v29)
        {
LABEL_70:
          *(void *)(a1 + 128) = 0;
LABEL_71:
          if (v18) {
            (*(void (**)(uint64_t, void, void, void, unsigned char *, uint64_t, uint64_t, uint64_t, unsigned __int16 *, unsigned int, void))(a1 + 64))(a1, a2[7], a2[8], a2[9], v38, v12, v11, v13, v17, v20, *(void *)(a1 + 72));
          }
          else {
            syslog(4, "dnssd_clientstub handle_query_response: error reading result from daemon");
          }
          return;
        }
LABEL_69:
        free(v29);
        *(void *)(a1 + 120) = 0;
        goto LABEL_70;
      }
    }
    else
    {
      uint64_t v12 = 0;
    }
    uint64_t v13 = 0;
    goto LABEL_21;
  }
}

void DNSServiceAttributeDeallocate(DNSServiceAttributeRef attr)
{
  ++saref_finalized;
  int v2 = (void *)*((void *)attr + 4);
  if (v2)
  {
    free(v2);
    *((void *)attr + 4) = 0;
  }
  size_t v3 = (void *)*((void *)attr + 5);
  if (v3) {
    free(v3);
  }

  free(attr);
}

void CallbackWithError(uint64_t *a1, uint64_t a2)
{
  while (1)
  {
    DNSServiceRef v4 = (uint64_t *)*a1;
    int v16 = 1;
    a1[6] = (uint64_t)&v16;
    switch(*((_DWORD *)a1 + 8))
    {
      case 1:
      case 0x13:
        int v5 = (void *)a1[10];
        int v6 = 1;
        do
        {
          if (!v5) {
            goto LABEL_23;
          }
          ssize_t v7 = (void *)*v5;
          BOOL v8 = (void (*)(uint64_t *, void, void, uint64_t, void))v5[2];
          if (v8)
          {
            v8(a1, 0, 0, a2, v5[1]);
            int v6 = v16;
          }
          int v5 = v7;
        }
        while (v6);
        syslog(4, "dnssd_clientstub:Record: CallbackwithError morebytes zero");
        return;
      case 4:
        int v9 = (void (*)(uint64_t *, void, void, uint64_t, void, uint64_t))a1[8];
        if (v9) {
          v9(a1, 0, 0, a2, 0, a1[9]);
        }
        break;
      case 5:
        int v10 = (void (*)(uint64_t *, void, uint64_t, void, void, void, uint64_t))a1[8];
        if (v10) {
          v10(a1, 0, a2, 0, 0, 0, a1[9]);
        }
        break;
      case 6:
        uint64_t v11 = (void (*)(uint64_t *, void, void, uint64_t, void, void, void, uint64_t))a1[8];
        if (v11) {
          goto LABEL_22;
        }
        break;
      case 7:
        uint64_t v12 = (void (*)(uint64_t *, void, void, uint64_t, void, void, void, void, void, uint64_t))a1[8];
        if (v12) {
          v12(a1, 0, 0, a2, 0, 0, 0, 0, 0, a1[9]);
        }
        break;
      case 8:
        uint64_t v13 = (void (*)(uint64_t *, void, void, uint64_t, void, void, void, void, void, uint64_t, uint64_t))a1[8];
        if (v13)
        {
          LODWORD(v15) = 0;
          v13(a1, 0, 0, a2, 0, 0, 0, 0, 0, v15, a1[9]);
        }
        break;
      case 0xE:
        int v14 = (void (*)(uint64_t *, void, void, uint64_t, void, void, void, void, _DWORD, uint64_t))a1[8];
        if (v14) {
          v14(a1, 0, 0, a2, 0, 0, 0, 0, 0, a1[9]);
        }
        break;
      case 0xF:
        uint64_t v11 = (void (*)(uint64_t *, void, void, uint64_t, void, void, void, uint64_t))a1[8];
        if (v11) {
LABEL_22:
        }
          v11(a1, 0, 0, a2, 0, 0, 0, a1[9]);
        break;
      default:
        syslog(4, "dnssd_clientstub CallbackWithError called with bad op %d", *((_DWORD *)a1 + 8));
        break;
    }
LABEL_23:
    if (!v16) {
      break;
    }
    a1[6] = 0;
    a1 = v4;
    if (!v4) {
      return;
    }
  }
  syslog(4, "dnssd_clientstub:sdRef: CallbackwithError morebytes zero sdr %p");
}

void handle_regservice_response(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  if (*(_DWORD *)(a2 + 36) != -65570) {
    goto LABEL_5;
  }
  if (_should_return_noauth_error_s_once != -1) {
    dispatch_once(&_should_return_noauth_error_s_once, &__block_literal_global);
  }
  if (_should_return_noauth_error_s_should)
  {
LABEL_5:
    if (a3)
    {
      uint64_t v8 = 0;
      do
      {
        int v9 = (uint64_t *)&v20[v8];
        if (a3 + v8 >= a4 || v9 >= &v21)
        {
          *((unsigned char *)v9 - (v9 == &v21)) = 0;
          goto LABEL_24;
        }
        int v10 = *(unsigned __int8 *)(a3 + v8);
        v20[v8++] = v10;
      }
      while (v10);
      if (!(a3 + v8)) {
        goto LABEL_24;
      }
      uint64_t v11 = 0;
      uint64_t v12 = a3 + v8;
      do
      {
        uint64_t v13 = &v19[v11];
        if (v12 + v11 >= a4 || v13 >= v20)
        {
          v13[-(v13 == v20)] = 0;
          goto LABEL_25;
        }
        int v14 = *(unsigned __int8 *)(a3 + v11 + v8);
        v19[v11++] = v14;
      }
      while (v14);
      uint64_t v15 = (unsigned __int8 *)(v12 + v11);
      if (!(v12 + v11)) {
        goto LABEL_25;
      }
      int v16 = v18;
      do
      {
        if ((unint64_t)v15 >= a4 || v16 >= v19)
        {
          v16[-(v16 == v19)] = 0;
          goto LABEL_26;
        }
        int v17 = *v15++;
        *v16++ = v17;
      }
      while (v17);
      if (!v15) {
        goto LABEL_26;
      }
      (*(void (**)(uint64_t, void, void, unsigned char *, unsigned char *, unsigned char *, void))(a1 + 64))(a1, *(unsigned int *)(a2 + 28), *(unsigned int *)(a2 + 36), v20, v19, v18, *(void *)(a1 + 72));
    }
    else
    {
      v20[0] = 0;
LABEL_24:
      v19[0] = 0;
LABEL_25:
      v18[0] = 0;
LABEL_26:
      syslog(4, "dnssd_clientstub handle_regservice_response: error reading result from daemon");
    }
  }
}

DNSServiceErrorType DNSServiceRegisterWithAttribute(DNSServiceRef *sdRef, DNSServiceFlags flags, uint32_t interfaceIndex, const char *name, const char *regtype, const char *domain, const char *host, uint16_t portInNetworkByteOrder, uint16_t txtLen, const void *txtRecord, DNSServiceAttributeRef attr, DNSServiceRegisterReply callBack, void *context)
{
  DNSServiceErrorType v13 = -65540;
  if (sdRef && regtype)
  {
    if (name) {
      BOOL v19 = name;
    }
    else {
      BOOL v19 = "";
    }
    if (domain) {
      unsigned int v20 = domain;
    }
    else {
      unsigned int v20 = "";
    }
    if (host) {
      uint64_t v21 = host;
    }
    else {
      uint64_t v21 = "";
    }
    __s = (char *)v20;
    int v45 = (char *)v21;
    if (txtRecord) {
      int v22 = (const char *)txtRecord;
    }
    else {
      int v22 = "";
    }
    if (callBack)
    {
      __src = v22;
      int64_t v23 = handle_regservice_response;
      DNSServiceRegisterReply v24 = callBack;
    }
    else
    {
      if ((flags & 8) != 0) {
        return v13;
      }
      __src = v22;
      int64_t v23 = 0;
      DNSServiceRegisterReply v24 = 0;
    }
    DNSServiceErrorType v13 = ConnectToServer((uint64_t *)sdRef, flags, 5, (uint64_t)v23, (uint64_t)v24, (uint64_t)context);
    if (!v13)
    {
      size_t v42 = strlen(v19);
      size_t v26 = strlen(regtype);
      size_t v27 = strlen(__s);
      size_t v28 = strlen(v45);
      DNSServiceErrorType v13 = -65540;
      if (*((unsigned char *)attr + 13))
      {
        if (!*((unsigned char *)attr + 12)) {
          return v13;
        }
      }
      else if (*((unsigned char *)attr + 12))
      {
        return v13;
      }
      uint64_t v46 = put_attribute_tlvs((uint64_t)attr, 0, 0, 0) + v42 + txtLen + v26 + v27 + v28 + 16;
      int v47 = 0;
      int v29 = (int8x16_t *)create_hdr(5, (size_t *)&v46, &v47, *((void *)*sdRef + 1) != 0, (uint64_t)*sdRef);
      if (!callBack) {
        v29->i32[2] |= 1u;
      }
      int v30 = v47;
      size_t v41 = v46;
      char *v47 = HIBYTE(flags);
      v30[1] = BYTE2(flags);
      v30[2] = BYTE1(flags);
      v30[3] = flags;
      v30[4] = HIBYTE(interfaceIndex);
      v30[5] = BYTE2(interfaceIndex);
      v30[6] = BYTE1(interfaceIndex);
      v30[7] = interfaceIndex;
      size_t v31 = v29;
      size_t v32 = strlen(v19) + 1;
      memcpy(v30 + 8, v19, v32);
      int64_t v33 = &v30[v32 + 8];
      size_t v34 = strlen(regtype) + 1;
      memcpy(v33, regtype, v34);
      unsigned int v35 = &v33[v34];
      size_t v36 = strlen(__s) + 1;
      memcpy(v35, __s, v36);
      int v37 = &v35[v36];
      size_t v38 = strlen(v45) + 1;
      memcpy(v37, v45, v38);
      BOOL v39 = &v37[v38];
      *(_WORD *)BOOL v39 = portInNetworkByteOrder;
      v39[2] = HIBYTE(txtLen);
      v39[3] = txtLen;
      memcpy(&v37[v38 + 4], __src, txtLen);
      int v47 = &v37[v38 + 4 + txtLen];
      put_attribute_tlvs((uint64_t)attr, (uint64_t)v31, (unint64_t *)&v47, (unint64_t)&v30[v41]);
      DNSServiceErrorType v40 = deliver_request(v31, (uint64_t)*sdRef);
      DNSServiceErrorType v13 = v40;
      if (v40)
      {
        if (v40 != -65555) {
          goto LABEL_32;
        }
        if (_should_return_noauth_error_s_once != -1) {
          dispatch_once(&_should_return_noauth_error_s_once, &__block_literal_global);
        }
        if (!_should_return_noauth_error_s_should)
        {
          return 0;
        }
        else
        {
LABEL_32:
          DNSServiceRefDeallocate(*sdRef);
          *sdRef = 0;
        }
      }
    }
  }
  return v13;
}

void ConnectionResponse(uint64_t **a1, _DWORD *a2)
{
  int v4 = a2[3];
  if (v4 == 69 || v4 == 73)
  {
    if (a2[9] != -65570) {
      goto LABEL_7;
    }
    if (_should_return_noauth_error_s_once != -1) {
      dispatch_once(&_should_return_noauth_error_s_once, &__block_literal_global);
    }
    if (_should_return_noauth_error_s_should)
    {
LABEL_7:
      int v5 = a1[10];
      if (v5)
      {
        while (*((_DWORD *)v5 + 9) != a2[4] || *((_DWORD *)v5 + 10) != a2[5])
        {
          int v5 = (uint64_t *)*v5;
          if (!v5) {
            goto LABEL_11;
          }
        }
        if ((uint64_t **)v5[6] == a1)
        {
          int v8 = *((_DWORD *)a1 + 8);
          if (v8 == 19 || v8 == 1)
          {
            uint64_t v14 = a2[7];
            uint64_t v15 = a2[9];
            uint64_t v11 = v5[1];
            uint64_t v12 = (void (*)(uint64_t **, uint64_t *, uint64_t, uint64_t, uint64_t))v5[2];
            int v10 = a1;
            DNSServiceErrorType v13 = v5;
          }
          else
          {
            syslog(4, "dnssd_clientstub ConnectionResponse: sdr->op != connection_request");
            int v10 = (uint64_t **)v5[6];
            uint64_t v11 = v5[1];
            uint64_t v12 = (void (*)(uint64_t **, uint64_t *, uint64_t, uint64_t, uint64_t))v5[2];
            DNSServiceErrorType v13 = v5;
            uint64_t v14 = 0;
            uint64_t v15 = 4294901759;
          }
          v12(v10, v13, v14, v15, v11);
        }
        else
        {
          syslog(4, "dnssd_clientstub ConnectionResponse: Record sdr mismatch: rec %p sdr %p");
        }
      }
      else
      {
LABEL_11:
        syslog(6, "dnssd_clientstub ConnectionResponse: Record not found");
      }
    }
  }
  else
  {
    int v6 = *a1;
    if (*a1)
    {
      while (*((_DWORD *)v6 + 6) != a2[4] || *((_DWORD *)v6 + 7) != a2[5])
      {
        int v6 = (uint64_t *)*v6;
        if (!v6) {
          return;
        }
      }
      ssize_t v7 = (void (*)(void))v6[7];
      if (v7)
      {
        v7();
      }
    }
  }
}

DNSServiceErrorType DNSServiceRegisterRecordWithAttribute(DNSServiceRef sdRef, DNSRecordRef *recordRef, DNSServiceFlags flags, uint32_t interfaceIndex, const char *fullname, uint16_t rrtype, uint16_t rrclass, uint16_t rdlen, const void *rdata, uint32_t ttl, DNSServiceAttributeRef attr, DNSServiceRegisterRecordReply callBack, void *context)
{
  int v43 = 0;
  if (!sdRef
    || !recordRef
    || (uint64_t v14 = *(const char **)&interfaceIndex) == 0
    || ((uint64_t v15 = (const void *)rrclass, v16 = rrtype, !rrclass) ? (v17 = rrtype == 0) : (v17 = 1), !v17 || !rdata))
  {
    DNSServiceErrorType v24 = -65540;
    syslog(4, "dnssd_clientstub DNSServiceRegisterRecord called with NULL parameter", *(void *)&flags, *(void *)&interfaceIndex, fullname, rrtype, rrclass, rdlen);
    return v24;
  }
  DNSServiceRef v18 = sdRef;
  int v19 = *((_DWORD *)sdRef + 4);
  if (v19 < 0 || (*((_DWORD *)sdRef + 5) ^ v19) != 0x12345678)
  {
    syslog(4, "dnssd_clientstub DNSServiceRegisterRecord called with invalid DNSServiceRef %p %08X %08X", *(void *)&flags);
    return -65541;
  }
  uint64_t v20 = rdlen;
  __int16 v21 = (__int16)fullname;
  int v23 = *((_DWORD *)sdRef + 8);
  if (v23 != 1 && v23 != 19)
  {
    syslog(4, "dnssd_clientstub DNSServiceRegisterRecord called with non-DNSServiceCreateConnection DNSServiceRef %p %d", *(void *)&flags);
    return -65541;
  }
  DNSServiceErrorType v24 = -65540;
  *recordRef = 0;
  size_t v25 = strlen(*(const char **)&interfaceIndex);
  if (*(unsigned char *)(v20 + 13))
  {
    if (!*(unsigned char *)(v20 + 12)) {
      return v24;
    }
  }
  else if (*(unsigned char *)(v20 + 12))
  {
    return v24;
  }
  uint64_t v42 = put_attribute_tlvs(v20, 0, 0, 0) + v25 + v16 + 19;
  int v27 = *((_DWORD *)v18 + 6);
  *((_DWORD *)v18 + 6) = v27 + 1;
  if (v27 == -1) {
    ++*((_DWORD *)v18 + 7);
  }
  size_t v28 = (int8x16_t *)create_hdr(2, (size_t *)&v42, &v43, 1, (uint64_t)v18);
  int v29 = v43;
  size_t v40 = v42;
  size_t v41 = v28;
  *int v43 = 0x80000;
  v29[4] = HIBYTE(flags);
  v29[5] = BYTE2(flags);
  v29[6] = BYTE1(flags);
  v29[7] = flags;
  size_t v30 = strlen(v14);
  size_t v31 = v14;
  size_t v32 = v30 + 1;
  memcpy(v29 + 8, v31, v30 + 1);
  int64_t v33 = &v29[v32 + 8];
  *int64_t v33 = HIBYTE(v21);
  v33[1] = v21;
  *((_WORD *)v33 + 1) = 256;
  v33[4] = BYTE1(v16);
  size_t v34 = v33 + 6;
  v33[5] = v16;
  memcpy(v33 + 6, v15, v16);
  *(_DWORD *)&v34[v16] = -1810825216;
  int v43 = &v34[v16 + 4];
  put_attribute_tlvs(v20, (uint64_t)v41, (unint64_t *)&v43, (unint64_t)&v29[v40]);
  unsigned int v35 = malloc_type_calloc(1uLL, 0x40uLL, 0xF1748037uLL);
  if (!v35)
  {
    __break(1u);
LABEL_34:
    dispatch_once(&_should_return_noauth_error_s_once, &__block_literal_global);
LABEL_30:
    if (_should_return_noauth_error_s_should) {
      return (int)v18;
    }
    else {
      return 0;
    }
  }
  ++rref_created;
  v35[1] = *(void *)&ttl;
  v35[2] = rdata;
  __int32 v36 = *((_DWORD *)v18 + 9);
  *((_DWORD *)v18 + 9) = v36 + 1;
  *((_DWORD *)v35 + 8) = v36;
  v35[6] = v18;
  *recordRef = (DNSRecordRef)v35;
  *(void *)((char *)v35 + 36) = *((void *)v18 + 3);
  v41[1].i32[2] = v36;
  int v37 = (void *)((char *)v18 + 80);
  do
  {
    size_t v38 = v37;
    int v37 = (void *)*v37;
  }
  while (v37);
  void *v38 = v35;
  DNSServiceErrorType v39 = deliver_request(v41, (uint64_t)v18);
  LODWORD(v18) = -65555;
  DNSServiceErrorType v24 = v39;
  if (v39 == -65555)
  {
    if (_should_return_noauth_error_s_once == -1) {
      goto LABEL_30;
    }
    goto LABEL_34;
  }
  return v24;
}

uint64_t DNSServiceUpdateRecordInternal(uint64_t a1, uint64_t a2, unsigned int a3, const void *a4, uint64_t a5)
{
  int v19 = 0;
  if (!a1 || a3 && !a4)
  {
    uint64_t v10 = 4294901756;
    syslog(4, "dnssd_clientstub DNSServiceUpdateRecord called with NULL parameter");
    return v10;
  }
  int v12 = *(_DWORD *)(a1 + 16);
  int v13 = *(_DWORD *)(a1 + 20);
  if (v12 < 0 || (v13 ^ v12) != 0x12345678)
  {
    syslog(4, "dnssd_clientstub DNSServiceUpdateRecord called with invalid DNSServiceRef %p %08X %08X", (const void *)a1, *(_DWORD *)(a1 + 16), v13);
    return 4294901755;
  }
  uint64_t v20 = a3 + 10;
  if (a5)
  {
    uint64_t v10 = 4294901756;
    if (*(unsigned char *)(a5 + 13))
    {
      if (!*(unsigned char *)(a5 + 12)) {
        return v10;
      }
    }
    else if (*(unsigned char *)(a5 + 12))
    {
      return v10;
    }
    uint64_t v20 = put_attribute_tlvs(a5, 0, 0, 0) + a3 + 10;
  }
  uint64_t v14 = (int8x16_t *)create_hdr(11, (size_t *)&v20, &v19, 1, a1);
  uint64_t v15 = v14;
  if (!*(void *)(a1 + 8))
  {
    v14[1].i64[0] = 0;
    if (a2) {
      goto LABEL_17;
    }
LABEL_19:
    int v16 = -1;
    goto LABEL_20;
  }
  if (!a2) {
    goto LABEL_19;
  }
LABEL_17:
  int v16 = *(_DWORD *)(a2 + 32);
LABEL_20:
  v14[1].i32[2] = v16;
  BOOL v17 = v19;
  size_t v18 = v20;
  _DWORD *v19 = 0;
  v17[4] = BYTE1(a3);
  v17[5] = a3;
  memcpy(v17 + 6, a4, a3);
  *(_DWORD *)&v17[a3 + 6] = 0;
  int v19 = &v17[a3 + 10];
  if (a5) {
    put_attribute_tlvs(a5, (uint64_t)v15, (unint64_t *)&v19, (unint64_t)&v17[v18]);
  }
  return deliver_request(v15, a1);
}

DNSServiceErrorType DNSServiceReconfirmRecord(DNSServiceErrorType flags, uint32_t interfaceIndex, const char *fullname, uint16_t rrtype, uint16_t rrclass, uint16_t rdlen, const void *rdata)
{
  DNSServiceRef sdRef = 0;
  if (*(void *)&interfaceIndex)
  {
    ssize_t v7 = (const void *)rdlen;
    unsigned int v8 = rrclass;
    __int16 v10 = (__int16)fullname;
    uint64_t v11 = *(const char **)&interfaceIndex;
    DNSServiceErrorType v12 = flags;
    if (!rrclass || rdlen)
    {
      uint64_t v20 = 0;
      flags = ConnectToServer((uint64_t *)&sdRef, 0, 9, 0, 0, 0);
      if (!flags)
      {
        size_t v19 = strlen(v11) + v8 + 15;
        int v13 = (int8x16_t *)create_hdr(9, &v19, &v20, 0, (uint64_t)sdRef);
        uint64_t v14 = v20;
        *uint64_t v20 = 0;
        v14[4] = HIBYTE(v12);
        v14[5] = BYTE2(v12);
        v14[6] = BYTE1(v12);
        uint64_t v15 = v14 + 8;
        v14[7] = v12;
        size_t v16 = strlen(v11) + 1;
        memcpy(v15, v11, v16);
        BOOL v17 = &v15[v16];
        *BOOL v17 = HIBYTE(v10);
        v17[1] = v10;
        v17[2] = HIBYTE(rrtype);
        v17[3] = rrtype;
        v17[4] = BYTE1(v8);
        v17[5] = v8;
        memcpy(&v15[v16 + 6], v7, v8);
        deliver_request(v13, (uint64_t)sdRef);
        DNSServiceRefDeallocate(sdRef);
      }
    }
  }
  return flags;
}

void __DNSServiceSetDispatchQueue_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  BOOL v28 = 0;
  if (!v1)
  {
    syslog(4, "dnssd_clientstub DNSServiceProcessResult called with NULL DNSServiceRef");
    return;
  }
  int v2 = *(_DWORD *)(v1 + 16);
  if (v2 < 0 || (*(_DWORD *)(v1 + 20) ^ v2) != 0x12345678)
  {
    syslog(4, "dnssd_clientstub DNSServiceProcessResult called with invalid DNSServiceRef %p %08X %08X");
    return;
  }
  if (*(void *)(v1 + 8))
  {
    syslog(4, "dnssd_clientstub DNSServiceProcessResult undefined for kDNSServiceFlagsShareConnection subordinate DNSServiceRef %p");
    return;
  }
  if (*(void *)(v1 + 56))
  {
    while (1)
    {
      uint64_t v27 = 0;
      *(_OWORD *)size_t v25 = 0u;
      long long v26 = 0u;
      int all = read_all(*(_DWORD *)(v1 + 16), (char *)v25, 0x1CuLL);
      switch(all)
      {
        case -1:
LABEL_50:
          if (all == -3) {
            uint64_t v18 = 4294901727;
          }
          else {
            uint64_t v18 = 4294901733;
          }
          *(void *)(v1 + 56) = 0;
          size_t v19 = *(NSObject **)(v1 + 88);
          if (v19)
          {
            dispatch_source_cancel(v19);
            uint64_t v20 = *(NSObject **)(v1 + 88);
            if (v20)
            {
              dispatch_release(v20);
              *(void *)(v1 + 88) = 0;
            }
            CallbackWithError((uint64_t *)v1, v18);
          }
          return;
        case -2:
          if (v28)
          {
            unsigned int v21 = *(_DWORD *)(v1 + 40);
            if (v21 <= 0x63)
            {
              *(_DWORD *)(v1 + 40) = v21 + 1;
              syslog(4, "dnssd_clientstub DNSServiceProcessResult error: select indicated data was waiting but read_all returned EWOULDBLOCK");
            }
          }
          return;
        case -3:
          goto LABEL_50;
      }
      int8x16_t v4 = vrev32q_s8(*(int8x16_t *)v25);
      *(int8x16_t *)size_t v25 = v4;
      DWORD2(v26) = bswap32(DWORD2(v26));
      if (v4.i32[0] != 1)
      {
        syslog(4, "dnssd_clientstub DNSServiceProcessResult daemon version %d does not match client version %d", v4.i32[0], 1);
        *(void *)(v1 + 56) = 0;
        return;
      }
      if (!v4.i32[1] || (int v5 = (char *)malloc_type_malloc(v4.u32[1], 0xA172743EuLL)) == 0)
      {
LABEL_72:
        __break(1u);
        return;
      }
      int v6 = (unsigned int *)v5;
      int v7 = read_all(*(_DWORD *)(v1 + 16), v5, HIDWORD(v25[0]));
      if (v7 < 0)
      {
        if (v7 == -3) {
          uint64_t v22 = 4294901727;
        }
        else {
          uint64_t v22 = 4294901733;
        }
        *(void *)(v1 + 56) = 0;
        int v23 = *(NSObject **)(v1 + 88);
        if (v23)
        {
          dispatch_source_cancel(v23);
          DNSServiceErrorType v24 = *(NSObject **)(v1 + 88);
          if (v24)
          {
            dispatch_release(v24);
            *(void *)(v1 + 88) = 0;
          }
          CallbackWithError((uint64_t *)v1, v22);
        }
        free(v6);
        return;
      }
      unint64_t v8 = (unint64_t)v6 + HIDWORD(v25[0]);
      if ((unint64_t)(v6 + 1) > v8) {
        break;
      }
      HIDWORD(v26) = bswap32(*v6);
      if (v6 == (unsigned int *)-4 || (unint64_t)(v6 + 2) > v8) {
        goto LABEL_24;
      }
      LODWORD(v27) = bswap32(v6[1]);
      __int16 v10 = v6 + 3;
      if (v6 == (unsigned int *)-8 || (unint64_t)v10 > v8)
      {
        __int16 v10 = 0;
        unsigned int v11 = 0;
      }
      else
      {
        unsigned int v11 = bswap32(v6[2]);
      }
LABEL_25:
      HIDWORD(v27) = v11;
      unint64_t v12 = *(unsigned int *)(v1 + 16);
      v30.tv_sec = 0;
      *(void *)&v30.tv_usec = 0;
      if ((int)v12 >= 1024)
      {
        int v13 = (fd_set *)malloc_type_calloc((v12 >> 5) + 1, 4uLL, 0xF1748037uLL);
        if (!v13) {
          goto LABEL_72;
        }
      }
      else
      {
        int v13 = (fd_set *)v29;
      }
      memset(v29, 0, sizeof(v29));
      if (__darwin_check_fd_set_overflow(v12, v13, 0)) {
        *(__int32_t *)((char *)v13->fds_bits + (((unint64_t)(int)v12 >> 3) & 0x1FFFFFFFFFFFFFFCLL)) |= 1 << v12;
      }
      int v14 = select(v12 + 1, v13, 0, 0, &v30);
      if (v13 != (fd_set *)v29) {
        free(v13);
      }
      BOOL v15 = v14 > 0;
      BOOL v28 = v15;
      if (v14 >= 1)
      {
        HIDWORD(v26) |= 1u;
        *(void *)(v1 + 48) = &v28;
      }
      if (v10)
      {
        (*(void (**)(uint64_t, size_t *, unsigned int *, char *))(v1 + 56))(v1, v25, v10, (char *)v6 + HIDWORD(v25[0]));
        BOOL v15 = v28;
      }
      if (v15) {
        *(void *)(v1 + 48) = 0;
      }
      free(v6);
      if (!v28) {
        return;
      }
    }
    HIDWORD(v26) = 0;
LABEL_24:
    __int16 v10 = 0;
    unsigned int v11 = 0;
    LODWORD(v27) = 0;
    goto LABEL_25;
  }
  int v17 = DNSServiceProcessResult_num_logs;
  if (DNSServiceProcessResult_num_logs <= 9)
  {
    syslog(4, "dnssd_clientstub DNSServiceProcessResult called with DNSServiceRef with no ProcessReply function");
    int v17 = DNSServiceProcessResult_num_logs;
  }
  if (v17 > 999)
  {
    sleep(1u);
  }
  else
  {
    DNSServiceProcessResult_num_logs = v17 + 1;
  }
}

uint64_t __DNSServiceSetDispatchQueue_block_invoke_2(uint64_t a1)
{
  return close(*(_DWORD *)(a1 + 32));
}

uint64_t dso_simple_response(uint64_t a1, uint64_t a2, _WORD *a3, int a4)
{
  memset(&v9[2], 0, 508);
  int v6 = ((unsigned __int16)a3[1] << 8) & 0x7800 | a4;
  v9[0] = *a3;
  v9[1] = bswap32(v6 | 0x8000) >> 16;
  if (a3[2] == 256) {
    dns_rr_parse_();
  }
  v8.iov_base = v9;
  v8.iov_len = 12;
  return ioloop_send_message(a1, a2, &v8);
}

uint64_t dso_retry_delay_response(uint64_t a1, uint64_t a2, __int16 a3, unsigned int a4)
{
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v24 = 0u;
  int v39 = 0;
  long long v23 = 0u;
  long long v22 = 0u;
  long long v21 = 0u;
  long long v20 = 0u;
  long long v19 = 0u;
  long long v18 = 0u;
  long long v17 = 0u;
  long long v16 = 0u;
  long long v15 = 0u;
  long long v14 = 0u;
  long long v13 = 0u;
  long long v12 = 0u;
  long long v11 = 0u;
  long long v10 = 0u;
  long long v9 = 0u;
  uint64_t v7 = 0;
  v6[0] = a3;
  v6[1] = __rev16((((a4 >> 3) & 0xF) << 11) | 0x8002);
  long long v8 = 0xE093040004000200;
  v5.iov_base = v6;
  v5.iov_len = 20;
  return ioloop_send_message(a1, a2, &v5);
}

void probe_state_finalize(void *a1)
{
  int v2 = (void *)a1[2];
  if (v2) {
    ioloop_wakeup_release_(v2, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/probe-srp.c", 80);
  }
  size_t v3 = (int *)a1[3];
  if (v3)
  {
    thread_service_release_(v3, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/probe-srp.c", 83);
    a1[3] = 0;
  }
  uint64_t v4 = a1[1];
  if (v4)
  {
    ioloop_comm_release_(v4, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/probe-srp.c", 87);
    a1[1] = 0;
  }
  iovec v5 = (void (*)(void))a1[6];
  if (v5) {
    v5(a1[4]);
  }

  free(a1);
}

int *probe_srp_create(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = (int *)malloc_type_calloc(1uLL, 0x5D0uLL, 0x10A0040FE44C817uLL);
  uint64_t v7 = global_os_log;
  BOOL v8 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (!v6)
  {
    if (v8)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "probe_srp_create";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: failed to create probe state", buf, 0xCu);
    }
LABEL_90:
    block[0] = _NSConcreteStackBlock;
    block[1] = 0x40000000;
    block[2] = __probe_srp_create_block_invoke;
    block[3] = &__block_descriptor_tmp_8;
    block[4] = dnssd_client_probe_callback;
    block[5] = a2;
    block[6] = a3;
    block[7] = dnssd_client_context_release;
    dispatch_async((dispatch_queue_t)&_dispatch_main_q, block);
    return 0;
  }
  if (v8)
  {
    int v9 = *v6;
    *(_DWORD *)buf = 136447490;
    *(void *)&uint8_t buf[4] = "probe_srp_create";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v9;
    *(_WORD *)&buf[18] = 2048;
    *(void *)&buf[20] = v6;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = "probe_state";
    *(_WORD *)&buf[38] = 2080;
    *(void *)&buf[40] = "probe-srp.c";
    __int16 v66 = 1024;
    LODWORD(v67) = 350;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  int v10 = *v6;
  if (*v6)
  {
    int v11 = v10 + 1;
    *int v6 = v10 + 1;
    if (v10 + 1 >= 10001)
    {
      uint64_t v12 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_137;
      }
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "probe_srp_create";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v11;
      *(_WORD *)&buf[18] = 2048;
      *(void *)&buf[20] = v6;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "probe_state";
      *(_WORD *)&buf[38] = 2080;
      *(void *)&buf[40] = "probe-srp.c";
      __int16 v66 = 1024;
      LODWORD(v67) = 350;
      long long v13 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_115:
      long long v50 = v12;
LABEL_136:
      _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_FAULT, v13, buf, 0x36u);
LABEL_137:
      abort();
    }
  }
  else
  {
    ++probe_state_created;
    *int v6 = 1;
  }
  int v14 = *(unsigned __int8 *)(a1 + 1);
  if (v14 == 2) {
    long long v15 = (const void *)(a1 + 4);
  }
  else {
    long long v15 = (const void *)(a1 + 8);
  }
  inet_ntop(v14, v15, hostname, 0x2Eu);
  snprintf(__str, 0xAuLL, "%d", bswap32(*(unsigned __int16 *)(a1 + 2)) >> 16);
  long long v16 = malloc_type_calloc(1uLL, 0x1A8uLL, 0x10B00402743B0D3uLL);
  if (!v16)
  {
    long long v23 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "ioloop_connection_create";
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "%{public}s: No memory for connection", buf, 0xCu);
    }
    goto LABEL_72;
  }
  uint64_t v17 = (uint64_t)v16;
  v16[45] = ++cur_connection_serial;
  long long v18 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v19 = *(_DWORD *)(v17 + 32);
    *(_DWORD *)buf = 136447490;
    *(void *)&uint8_t buf[4] = "ioloop_connection_create";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v19;
    *(_WORD *)&buf[18] = 2048;
    *(void *)&buf[20] = v17;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = "connection";
    *(_WORD *)&buf[38] = 2080;
    *(void *)&buf[40] = "macos-ioloop.c";
    __int16 v66 = 1024;
    LODWORD(v67) = 1794;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  int v20 = *(_DWORD *)(v17 + 32);
  if (v20)
  {
    int v21 = v20 + 1;
    *(_DWORD *)(v17 + 32) = v20 + 1;
    if (v20 + 1 >= 10001)
    {
      uint64_t v22 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_137;
      }
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "ioloop_connection_create";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v21;
      *(_WORD *)&buf[18] = 2048;
      *(void *)&buf[20] = v17;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "connection";
      *(_WORD *)&buf[38] = 2080;
      *(void *)&buf[40] = "macos-ioloop.c";
      __int16 v66 = 1024;
      LODWORD(v67) = 1794;
      long long v13 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_132:
      long long v50 = v22;
      goto LABEL_136;
    }
  }
  else
  {
    ++comm_created;
    *(_DWORD *)(v17 + 32) = 1;
  }
  nw_endpoint_t host = nw_endpoint_create_host(hostname, __str);
  if (!host)
  {
    long long v34 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "ioloop_connection_create";
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_ERROR, "%{public}s: No memory for connection endpoint.", buf, 0xCu);
    }
    int v35 = *(_DWORD *)(v17 + 32);
    if (!v35)
    {
      uint64_t v22 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_137;
      }
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "ioloop_connection_create";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&buf[18] = 2048;
      *(void *)&buf[20] = v17;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "connection";
      *(_WORD *)&buf[38] = 2080;
      *(void *)&buf[40] = "macos-ioloop.c";
      __int16 v66 = 1024;
      LODWORD(v67) = 1798;
      long long v13 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_132;
    }
    long long v36 = global_os_log;
    if (v35 < 10001)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "ioloop_connection_create";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v35;
        *(_WORD *)&buf[18] = 2048;
        *(void *)&buf[20] = v17;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "connection";
        *(_WORD *)&buf[38] = 2080;
        *(void *)&buf[40] = "macos-ioloop.c";
        __int16 v66 = 1024;
        LODWORD(v67) = 1798;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        int v35 = *(_DWORD *)(v17 + 32);
      }
      *(_DWORD *)(v17 + 32) = v35 - 1;
      if (v35 != 1) {
        goto LABEL_72;
      }
      long long v37 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_71;
      }
      *(_DWORD *)buf = 136447234;
      *(void *)&uint8_t buf[4] = "ioloop_connection_create";
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v17;
      *(_WORD *)&buf[22] = 2080;
      *(void *)&buf[24] = "connection";
      *(_WORD *)&buf[32] = 2080;
      *(void *)&buf[34] = "macos-ioloop.c";
      *(_WORD *)&buf[42] = 1024;
      *(_DWORD *)&buf[44] = 1798;
      goto LABEL_70;
    }
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_137;
    }
    *(_DWORD *)buf = 136447490;
    *(void *)&uint8_t buf[4] = "ioloop_connection_create";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v35;
    *(_WORD *)&buf[18] = 2048;
    *(void *)&buf[20] = v17;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = "connection";
    *(_WORD *)&buf[38] = 2080;
    *(void *)&buf[40] = "macos-ioloop.c";
    __int16 v66 = 1024;
    LODWORD(v67) = 1798;
    long long v13 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_135;
  }
  long long v25 = host;
  secure_udp = nw_parameters_create_secure_udp(_nw_parameters_configure_protocol_disable, _nw_parameters_configure_protocol_default_configuration);
  if (!secure_udp)
  {
    long long v38 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "ioloop_connection_create";
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "%{public}s: No memory for connection parameters.", buf, 0xCu);
    }
    nw_release(v25);
    int v39 = *(_DWORD *)(v17 + 32);
    if (!v39)
    {
      uint64_t v22 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_137;
      }
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "ioloop_connection_create";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&buf[18] = 2048;
      *(void *)&buf[20] = v17;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "connection";
      *(_WORD *)&buf[38] = 2080;
      *(void *)&buf[40] = "macos-ioloop.c";
      __int16 v66 = 1024;
      LODWORD(v67) = 1842;
      long long v13 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_132;
    }
    long long v36 = global_os_log;
    if (v39 < 10001)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "ioloop_connection_create";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v39;
        *(_WORD *)&buf[18] = 2048;
        *(void *)&buf[20] = v17;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "connection";
        *(_WORD *)&buf[38] = 2080;
        *(void *)&buf[40] = "macos-ioloop.c";
        __int16 v66 = 1024;
        LODWORD(v67) = 1842;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        int v39 = *(_DWORD *)(v17 + 32);
      }
      *(_DWORD *)(v17 + 32) = v39 - 1;
      if (v39 != 1) {
        goto LABEL_72;
      }
      long long v37 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_71;
      }
      *(_DWORD *)buf = 136447234;
      *(void *)&uint8_t buf[4] = "ioloop_connection_create";
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v17;
      *(_WORD *)&buf[22] = 2080;
      *(void *)&buf[24] = "connection";
      *(_WORD *)&buf[32] = 2080;
      *(void *)&buf[34] = "macos-ioloop.c";
      *(_WORD *)&buf[42] = 1024;
      *(_DWORD *)&buf[44] = 1842;
      goto LABEL_70;
    }
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_137;
    }
    *(_DWORD *)buf = 136447490;
    *(void *)&uint8_t buf[4] = "ioloop_connection_create";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v39;
    *(_WORD *)&buf[18] = 2048;
    *(void *)&buf[20] = v17;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = "connection";
    *(_WORD *)&buf[38] = 2080;
    *(void *)&buf[40] = "macos-ioloop.c";
    __int16 v66 = 1024;
    LODWORD(v67) = 1842;
    long long v13 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_135;
  }
  long long v27 = secure_udp;
  nw_protocol_stack_t v28 = nw_parameters_copy_default_protocol_stack(secure_udp);
  nw_release(v28);
  long long v29 = strdup(hostname);
  *(void *)(v17 + 192) = v29;
  if (!v29)
  {
    size_t v40 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "ioloop_connection_create";
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "%{public}s: No memory for connection name.", buf, 0xCu);
    }
    nw_release(v25);
    nw_release(v27);
    int v41 = *(_DWORD *)(v17 + 32);
    if (!v41)
    {
      uint64_t v22 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_137;
      }
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "ioloop_connection_create";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&buf[18] = 2048;
      *(void *)&buf[20] = v17;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "connection";
      *(_WORD *)&buf[38] = 2080;
      *(void *)&buf[40] = "macos-ioloop.c";
      __int16 v66 = 1024;
      LODWORD(v67) = 1869;
      long long v13 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_132;
    }
    long long v36 = global_os_log;
    if (v41 < 10001)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "ioloop_connection_create";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v41;
        *(_WORD *)&buf[18] = 2048;
        *(void *)&buf[20] = v17;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "connection";
        *(_WORD *)&buf[38] = 2080;
        *(void *)&buf[40] = "macos-ioloop.c";
        __int16 v66 = 1024;
        LODWORD(v67) = 1869;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        int v41 = *(_DWORD *)(v17 + 32);
      }
      *(_DWORD *)(v17 + 32) = v41 - 1;
      if (v41 != 1) {
        goto LABEL_72;
      }
      long long v37 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_71;
      }
      *(_DWORD *)buf = 136447234;
      *(void *)&uint8_t buf[4] = "ioloop_connection_create";
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v17;
      *(_WORD *)&buf[22] = 2080;
      *(void *)&buf[24] = "connection";
      *(_WORD *)&buf[32] = 2080;
      *(void *)&buf[34] = "macos-ioloop.c";
      *(_WORD *)&buf[42] = 1024;
      *(_DWORD *)&buf[44] = 1869;
      goto LABEL_70;
    }
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_137;
    }
    *(_DWORD *)buf = 136447490;
    *(void *)&uint8_t buf[4] = "ioloop_connection_create";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v41;
    *(_WORD *)&buf[18] = 2048;
    *(void *)&buf[20] = v17;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = "connection";
    *(_WORD *)&buf[38] = 2080;
    *(void *)&buf[40] = "macos-ioloop.c";
    __int16 v66 = 1024;
    LODWORD(v67) = 1869;
    long long v13 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_135:
    long long v50 = v36;
    goto LABEL_136;
  }
  *(void *)uint64_t v17 = nw_connection_create(v25, v27);
  ++nw_connection_created;
  nw_release(v25);
  nw_release(v27);
  if (!*(void *)v17)
  {
    uint64_t v42 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "ioloop_connection_create";
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "%{public}s: no memory for nw_connection object", buf, 0xCu);
    }
    int v43 = *(_DWORD *)(v17 + 32);
    if (!v43)
    {
      uint64_t v22 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_137;
      }
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "ioloop_connection_create";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&buf[18] = 2048;
      *(void *)&buf[20] = v17;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "connection";
      *(_WORD *)&buf[38] = 2080;
      *(void *)&buf[40] = "macos-ioloop.c";
      __int16 v66 = 1024;
      LODWORD(v67) = 1880;
      long long v13 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_132;
    }
    long long v36 = global_os_log;
    if (v43 < 10001)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "ioloop_connection_create";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v43;
        *(_WORD *)&buf[18] = 2048;
        *(void *)&buf[20] = v17;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "connection";
        *(_WORD *)&buf[38] = 2080;
        *(void *)&buf[40] = "macos-ioloop.c";
        __int16 v66 = 1024;
        LODWORD(v67) = 1880;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        int v43 = *(_DWORD *)(v17 + 32);
      }
      *(_DWORD *)(v17 + 32) = v43 - 1;
      if (v43 != 1) {
        goto LABEL_72;
      }
      long long v37 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
LABEL_71:
        ++comm_finalized;
        comm_finalize(v17);
LABEL_72:
        uint64_t v17 = 0;
        goto LABEL_73;
      }
      *(_DWORD *)buf = 136447234;
      *(void *)&uint8_t buf[4] = "ioloop_connection_create";
      *(_WORD *)&buf[12] = 2048;
      *(void *)&buf[14] = v17;
      *(_WORD *)&buf[22] = 2080;
      *(void *)&buf[24] = "connection";
      *(_WORD *)&buf[32] = 2080;
      *(void *)&buf[34] = "macos-ioloop.c";
      *(_WORD *)&buf[42] = 1024;
      *(_DWORD *)&buf[44] = 1880;
LABEL_70:
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
      goto LABEL_71;
    }
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_137;
    }
    *(_DWORD *)buf = 136447490;
    *(void *)&uint8_t buf[4] = "ioloop_connection_create";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v43;
    *(_WORD *)&buf[18] = 2048;
    *(void *)&buf[20] = v17;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = "connection";
    *(_WORD *)&buf[38] = 2080;
    *(void *)&buf[40] = "macos-ioloop.c";
    __int16 v66 = 1024;
    LODWORD(v67) = 1880;
    long long v13 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_135;
  }
  *(void *)(v17 + 200) = v6;
  *(void *)(v17 + 208) = probe_srp_datagram;
  *(void *)(v17 + 224) = probe_srp_connected;
  *(void *)(v17 + 232) = probe_srp_disconnected;
  *(void *)(v17 + 240) = probe_srp_probe_state_context_release;
  *(_WORD *)(v17 + 416) &= 0xFDDFu;
  long long v30 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v31 = *(_DWORD *)(v17 + 32);
    *(_DWORD *)buf = 136447490;
    *(void *)&uint8_t buf[4] = "ioloop_connection_create";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v31;
    *(_WORD *)&buf[18] = 2048;
    *(void *)&buf[20] = v17;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = "connection";
    *(_WORD *)&buf[38] = 2080;
    *(void *)&buf[40] = "macos-ioloop.c";
    __int16 v66 = 1024;
    LODWORD(v67) = 1891;
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  int v32 = *(_DWORD *)(v17 + 32);
  if (v32)
  {
    int v33 = v32 + 1;
    *(_DWORD *)(v17 + 32) = v32 + 1;
    if (v32 + 1 >= 10001)
    {
      uint64_t v22 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_137;
      }
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "ioloop_connection_create";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v33;
      *(_WORD *)&buf[18] = 2048;
      *(void *)&buf[20] = v17;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "connection";
      *(_WORD *)&buf[38] = 2080;
      *(void *)&buf[40] = "macos-ioloop.c";
      __int16 v66 = 1024;
      LODWORD(v67) = 1891;
      long long v13 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_132;
    }
  }
  else
  {
    ++comm_created;
    *(_DWORD *)(v17 + 32) = 1;
  }
  __int16 v63 = *(NSObject **)v17;
  *(void *)buf = _NSConcreteStackBlock;
  *(void *)&buf[8] = 0x40000000;
  *(void *)&buf[16] = __ioloop_connection_create_block_invoke_28;
  *(void *)&buf[24] = &__block_descriptor_tmp_29;
  *(void *)&buf[32] = v17;
  nw_connection_set_state_changed_handler(v63, buf);
  nw_connection_set_queue(*(nw_connection_t *)v17, (dispatch_queue_t)ioloop_main_queue);
  nw_connection_start(*(nw_connection_t *)v17);
LABEL_73:
  *((void *)v6 + 1) = v17;
  int v44 = global_os_log;
  BOOL v45 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (!v17)
  {
    if (v45)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "probe_srp_create";
      _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "%{public}s: failed to create connection", buf, 0xCu);
    }
    int v51 = *v6;
    if (!*v6)
    {
      uint64_t v12 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_137;
      }
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "probe_srp_create";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&buf[18] = 2048;
      *(void *)&buf[20] = v6;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "probe_state";
      *(_WORD *)&buf[38] = 2080;
      *(void *)&buf[40] = "probe-srp.c";
      __int16 v66 = 1024;
      LODWORD(v67) = 379;
      long long v13 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_115;
    }
    long long v52 = global_os_log;
    if (v51 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_137;
      }
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "probe_srp_create";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v51;
      *(_WORD *)&buf[18] = 2048;
      *(void *)&buf[20] = v6;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "probe_state";
      *(_WORD *)&buf[38] = 2080;
      *(void *)&buf[40] = "probe-srp.c";
      __int16 v66 = 1024;
      LODWORD(v67) = 379;
      long long v13 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      long long v50 = v52;
      goto LABEL_136;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "probe_srp_create";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v51;
      *(_WORD *)&buf[18] = 2048;
      *(void *)&buf[20] = v6;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "probe_state";
      *(_WORD *)&buf[38] = 2080;
      *(void *)&buf[40] = "probe-srp.c";
      __int16 v66 = 1024;
      LODWORD(v67) = 379;
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      int v51 = *v6;
    }
    *int v6 = v51 - 1;
    if (v51 == 1)
    {
      long long v53 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "probe_srp_create";
        *(_WORD *)&buf[12] = 2048;
        *(void *)&buf[14] = v6;
        *(_WORD *)&buf[22] = 2080;
        *(void *)&buf[24] = "probe_state";
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = "probe-srp.c";
        *(_WORD *)&buf[42] = 1024;
        *(_DWORD *)&buf[44] = 379;
        _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
      }
      ++probe_state_finalized;
      probe_state_finalize(v6);
    }
    goto LABEL_90;
  }
  if (v45)
  {
    int v46 = *v6;
    *(_DWORD *)buf = 136447490;
    *(void *)&uint8_t buf[4] = "probe_srp_create";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v46;
    *(_WORD *)&buf[18] = 2048;
    *(void *)&buf[20] = v6;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = "probe_state";
    *(_WORD *)&buf[38] = 2080;
    *(void *)&buf[40] = "probe-srp.c";
    __int16 v66 = 1024;
    LODWORD(v67) = 359;
    _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  int v47 = *v6;
  if (*v6)
  {
    int v48 = v47 + 1;
    *int v6 = v47 + 1;
    sockaddr v49 = global_os_log;
    if (v47 + 1 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_137;
      }
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "probe_srp_create";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v48;
      *(_WORD *)&buf[18] = 2048;
      *(void *)&buf[20] = v6;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "probe_state";
      *(_WORD *)&buf[38] = 2080;
      *(void *)&buf[40] = "probe-srp.c";
      __int16 v66 = 1024;
      LODWORD(v67) = 359;
      long long v13 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      long long v50 = v49;
      goto LABEL_136;
    }
  }
  else
  {
    ++probe_state_created;
    *int v6 = 1;
    sockaddr v49 = global_os_log;
  }
  if (os_log_type_enabled(v49, OS_LOG_TYPE_DEFAULT))
  {
    int v54 = *(unsigned __int8 *)(a1 + 8);
    if ((v54 & 0xFE) == 0xFC)
    {
      v55 = "ULA: ";
    }
    else if (v54 == 254 && (*(unsigned char *)(a1 + 9) & 0xC0) == 0x80)
    {
      v55 = "LUA: ";
    }
    else if ((v54 & 0xE0) == 0x20)
    {
      v55 = "GUA: ";
    }
    else
    {
      v55 = "";
    }
    unsigned int v56 = bswap32(*(unsigned __int16 *)(a1 + 2));
    *(_DWORD *)buf = 136449027;
    *(void *)&uint8_t buf[4] = "probe_srp_create";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v55;
    *(_WORD *)&buf[22] = 2160;
    *(void *)&buf[24] = 1752392040;
    *(_WORD *)&buf[32] = 1041;
    *(_DWORD *)&buf[34] = 6;
    *(_WORD *)&buf[38] = 2097;
    *(void *)&buf[40] = a1 + 8;
    __int16 v66 = 2160;
    uint64_t v67 = 1752392040;
    __int16 v68 = 1042;
    int v69 = 2;
    __int16 v70 = 2098;
    uint64_t v71 = a1 + 14;
    __int16 v72 = 2160;
    uint64_t v73 = 1752392040;
    __int16 v74 = 1041;
    int v75 = 8;
    __int16 v76 = 2097;
    uint64_t v77 = a1 + 16;
    __int16 v78 = 1024;
    unsigned int v79 = HIWORD(v56);
    _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "%{public}s: probing service {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} on port %d", buf, 0x6Au);
  }
  *((void *)v6 + 4) = a3;
  *((void *)v6 + 5) = dnssd_client_probe_callback;
  *((void *)v6 + 6) = dnssd_client_context_release;
  *(void *)buf = 0;
  *(void *)&buf[8] = 0;
  clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)buf);
  *(void *)(a2 + 40) = *(void *)buf;
  *(void *)(a2 + 56) = v6;
  v57 = global_os_log;
  uint64_t v58 = v6;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v59 = *v6;
    *(_DWORD *)buf = 136447490;
    *(void *)&uint8_t buf[4] = "probe_srp_create";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v59;
    *(_WORD *)&buf[18] = 2048;
    *(void *)&buf[20] = v6;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = "service->probe_state";
    *(_WORD *)&buf[38] = 2080;
    *(void *)&buf[40] = "probe-srp.c";
    __int16 v66 = 1024;
    LODWORD(v67) = 369;
    _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    uint64_t v58 = *(int **)(a2 + 56);
  }
  int v60 = *v58;
  if (*v58)
  {
    int v61 = v60 + 1;
    *uint64_t v58 = v60 + 1;
    if (v60 + 1 >= 10001)
    {
      uint64_t v22 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_137;
      }
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "probe_srp_create";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v61;
      *(_WORD *)&buf[18] = 2048;
      *(void *)&buf[20] = v58;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "service->probe_state";
      *(_WORD *)&buf[38] = 2080;
      *(void *)&buf[40] = "probe-srp.c";
      __int16 v66 = 1024;
      LODWORD(v67) = 369;
      long long v13 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_132;
    }
  }
  else
  {
    ++probe_state_created;
    *uint64_t v58 = 1;
  }
  *((void *)v6 + 3) = a2;
  thread_service_retain_((int *)a2, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/probe-srp.c", 372);
  return v6;
}

uint64_t __probe_srp_service_block_invoke(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void, void, void))(a1 + 32))(*(void *)(a1 + 40), *(void *)(a1 + 48), 0);
  size_t v3 = *(uint64_t (**)(uint64_t))(a1 + 56);
  if (v3)
  {
    uint64_t v4 = *(void *)(a1 + 48);
    return v3(v4);
  }
  return result;
}

uint64_t __probe_srp_create_block_invoke(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void, void, uint64_t))(a1 + 32))(*(void *)(a1 + 40), *(void *)(a1 + 48), 1);
  size_t v3 = *(uint64_t (**)(uint64_t))(a1 + 56);
  if (v3)
  {
    uint64_t v4 = *(void *)(a1 + 48);
    return v3(v4);
  }
  return result;
}

void probe_srp_probe_state_context_release(void *a1)
{
  if (!a1) {
    return;
  }
  int v2 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    size_t v3 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v6 = 136447490;
    uint64_t v7 = "probe_srp_probe_state_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)int v9 = 0;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "probe_state";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "probe-srp.c";
    __int16 v10 = 1024;
    int v11 = 225;
    iovec v5 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  size_t v3 = global_os_log;
  if (v2 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v6 = 136447490;
    uint64_t v7 = "probe_srp_probe_state_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)int v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "probe_state";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "probe-srp.c";
    __int16 v10 = 1024;
    int v11 = 225;
    iovec v5 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, v5, (uint8_t *)&v6, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 136447490;
    uint64_t v7 = "probe_srp_probe_state_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)int v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "probe_state";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "probe-srp.c";
    __int16 v10 = 1024;
    int v11 = 225;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v6, 0x36u);
    int v2 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v2 - 1;
  if (v2 == 1)
  {
    uint64_t v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 136447234;
      uint64_t v7 = "probe_srp_probe_state_context_release";
      __int16 v8 = 2048;
      *(void *)int v9 = a1;
      *(_WORD *)&v9[8] = 2080;
      *(void *)&v9[10] = "probe_state";
      *(_WORD *)&v9[18] = 2080;
      *(void *)&v9[20] = "probe-srp.c";
      *(_WORD *)&v9[28] = 1024;
      *(_DWORD *)&v9[30] = 225;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v6, 0x30u);
    }
    ++probe_state_finalized;
    probe_state_finalize(a1);
  }
}

void probe_srp_disconnected(uint64_t a1, void *a2)
{
  if (a2[3]) {
    probe_srp_done(a2, 0);
  }
  uint64_t v3 = a2[1];
  if (v3)
  {
    ioloop_comm_release_(v3, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/probe-srp.c", 241);
    a2[1] = 0;
  }
}

void probe_srp_done(void *a1, uint64_t a2)
{
  uint64_t v4 = a1[3];
  a1[3] = 0;
  *(void *)(v4 + 56) = 0;
  if (*(_DWORD *)(v4 + 20) == 3 || *(unsigned char *)(v4 + 82)) {
    unsigned int v5 = 53;
  }
  else {
    unsigned int v5 = __rev16(*(unsigned __int16 *)(v4 + 80));
  }
  int v6 = (unsigned __int8 *)(v4 + 64);
  uint64_t v7 = global_os_log;
  BOOL v8 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v8)
    {
      int v9 = *v6;
      if ((v9 & 0xFE) == 0xFC)
      {
        __int16 v10 = "ULA: ";
      }
      else if (v9 == 254 && (*(unsigned char *)(v4 + 65) & 0xC0) == 0x80)
      {
        __int16 v10 = "LUA: ";
      }
      else if ((v9 & 0xE0) == 0x20)
      {
        __int16 v10 = "GUA: ";
      }
      else
      {
        __int16 v10 = "";
      }
      int v20 = 136449027;
      int v21 = "probe_srp_done";
      __int16 v22 = 2082;
      *(void *)long long v23 = v10;
      *(_WORD *)&v23[8] = 2160;
      *(void *)&v23[10] = 1752392040;
      *(_WORD *)&v23[18] = 1041;
      *(_DWORD *)&v23[20] = 6;
      *(_WORD *)&v23[24] = 2097;
      *(void *)&v23[26] = v4 + 64;
      __int16 v24 = 2160;
      uint64_t v25 = 1752392040;
      __int16 v26 = 1042;
      int v27 = 2;
      __int16 v28 = 2098;
      uint64_t v29 = v4 + 70;
      __int16 v30 = 2160;
      uint64_t v31 = 1752392040;
      __int16 v32 = 1041;
      int v33 = 8;
      __int16 v34 = 2097;
      uint64_t v35 = v4 + 72;
      __int16 v36 = 1024;
      unsigned int v37 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: service {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} responded on port %d", (uint8_t *)&v20, 0x6Au);
    }
    *(_WORD *)(v4 + 27) = 0;
    *(unsigned char *)(v4 + 48) = 1;
  }
  else
  {
    if (v8)
    {
      int v11 = *v6;
      if ((v11 & 0xFE) == 0xFC)
      {
        uint64_t v12 = "ULA: ";
      }
      else if (v11 == 254 && (*(unsigned char *)(v4 + 65) & 0xC0) == 0x80)
      {
        uint64_t v12 = "LUA: ";
      }
      else if ((v11 & 0xE0) == 0x20)
      {
        uint64_t v12 = "GUA: ";
      }
      else
      {
        uint64_t v12 = "";
      }
      int v20 = 136449027;
      int v21 = "probe_srp_done";
      __int16 v22 = 2082;
      *(void *)long long v23 = v12;
      *(_WORD *)&v23[8] = 2160;
      *(void *)&v23[10] = 1752392040;
      *(_WORD *)&v23[18] = 1041;
      *(_DWORD *)&v23[20] = 6;
      *(_WORD *)&v23[24] = 2097;
      *(void *)&v23[26] = v4 + 64;
      __int16 v24 = 2160;
      uint64_t v25 = 1752392040;
      __int16 v26 = 1042;
      int v27 = 2;
      __int16 v28 = 2098;
      uint64_t v29 = v4 + 70;
      __int16 v30 = 2160;
      uint64_t v31 = 1752392040;
      __int16 v32 = 1041;
      int v33 = 8;
      __int16 v34 = 2097;
      uint64_t v35 = v4 + 72;
      __int16 v36 = 1024;
      unsigned int v37 = v5;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: service {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} not responding on port %d", (uint8_t *)&v20, 0x6Au);
    }
    *(_WORD *)(v4 + 27) = 1;
  }
  *(unsigned char *)(v4 + 49) = 1;
  long long v13 = (void (*)(void, void, uint64_t))a1[5];
  if (v13)
  {
    v13(a1[3], a1[4], a2);
    a1[5] = 0;
  }
  int v14 = (void (*)(void))a1[6];
  if (v14) {
    v14(a1[4]);
  }
  a1[4] = 0;
  thread_service_release_((int *)v4, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/probe-srp.c", 169);
  uint64_t v15 = a1[2];
  if (v15) {
    ioloop_cancel_wake_event(v15);
  }
  int v16 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    uint64_t v17 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_48;
    }
    int v20 = 136447490;
    int v21 = "probe_srp_done";
    __int16 v22 = 1024;
    *(_DWORD *)long long v23 = 0;
    *(_WORD *)&v23[4] = 2048;
    *(void *)&v23[6] = a1;
    *(_WORD *)&v23[14] = 2080;
    *(void *)&v23[16] = "probe_state";
    *(_WORD *)&v23[24] = 2080;
    *(void *)&v23[26] = "probe-srp.c";
    __int16 v24 = 1024;
    LODWORD(v25) = 173;
    int v19 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_47;
  }
  uint64_t v17 = global_os_log;
  if (v16 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_48;
    }
    int v20 = 136447490;
    int v21 = "probe_srp_done";
    __int16 v22 = 1024;
    *(_DWORD *)long long v23 = v16;
    *(_WORD *)&v23[4] = 2048;
    *(void *)&v23[6] = a1;
    *(_WORD *)&v23[14] = 2080;
    *(void *)&v23[16] = "probe_state";
    *(_WORD *)&v23[24] = 2080;
    *(void *)&v23[26] = "probe-srp.c";
    __int16 v24 = 1024;
    LODWORD(v25) = 173;
    int v19 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_47:
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, v19, (uint8_t *)&v20, 0x36u);
LABEL_48:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v20 = 136447490;
    int v21 = "probe_srp_done";
    __int16 v22 = 1024;
    *(_DWORD *)long long v23 = v16;
    *(_WORD *)&v23[4] = 2048;
    *(void *)&v23[6] = a1;
    *(_WORD *)&v23[14] = 2080;
    *(void *)&v23[16] = "probe_state";
    *(_WORD *)&v23[24] = 2080;
    *(void *)&v23[26] = "probe-srp.c";
    __int16 v24 = 1024;
    LODWORD(v25) = 173;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v20, 0x36u);
    int v16 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v16 - 1;
  if (v16 == 1)
  {
    long long v18 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v20 = 136447234;
      int v21 = "probe_srp_done";
      __int16 v22 = 2048;
      *(void *)long long v23 = a1;
      *(_WORD *)&v23[8] = 2080;
      *(void *)&v23[10] = "probe_state";
      *(_WORD *)&v23[18] = 2080;
      *(void *)&v23[20] = "probe-srp.c";
      *(_WORD *)&v23[28] = 1024;
      *(_DWORD *)&v23[30] = 173;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v20, 0x30u);
    }
    ++probe_state_finalized;
    probe_state_finalize(a1);
  }
}

void probe_srp_connected(uint64_t a1, uint64_t a2)
{
  if (*(unsigned char *)(a2 + 1486))
  {
    int v2 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      LODWORD(v7) = 136446210;
      *(void *)((char *)&v7 + 4) = "probe_srp_connected";
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: canceled before connection was ready", (uint8_t *)&v7, 0xCu);
    }
  }
  else
  {
    *(void *)(a2 + 64) = 0;
    uint64_t v4 = a2 + 64;
    *(_DWORD *)(a2 + 72) = 0;
    long long v10 = 0u;
    long long v9 = 0u;
    *((void *)&v7 + 1) = a2 + 76;
    unint64_t v8 = a2 + 1474;
    *(void *)&long long v7 = a2 + 64;
    *(_WORD *)(a2 + 64) = arc4random_uniform(0x10000u);
    *(_DWORD *)(v4 + 2) = 0x1000000;
    dns_full_name_to_wire_(0, (uint64_t)&v7, "default.service.arpa", 326);
    __int16 v5 = WORD4(v7);
    if (DWORD2(v10) <= 1)
    {
      int v6 = (_WORD *)(*((void *)&v7 + 1) + 2);
      if (*((void *)&v7 + 1) + 2 < v8)
      {
        **((_WORD **)&v7 + 1) = 1536;
        v5 += 4;
        if ((unint64_t)(v6 + 1) >= v8) {
          __int16 v5 = (__int16)v6;
        }
        else {
          *int v6 = 256;
        }
      }
    }
    *(_WORD *)(a2 + 1484) = v5 - v4;
    *(void *)(a2 + 1476) = 0x3E800000000;
    probe_srp_schedule_retransmission(a2);
  }
}

void probe_srp_schedule_retransmission(uint64_t a1)
{
  if (*(void *)(a1 + 16)
    || (int v2 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/probe-srp.c", 283), (*(void *)(a1 + 16) = v2) != 0))
  {
    int v3 = *(_DWORD *)(a1 + 1480);
    unsigned __int16 v4 = arc4random_uniform(0x10000u);
    int v5 = *(_DWORD *)(a1 + 1480);
    *(_DWORD *)(a1 + 1480) = 2 * v5;
    ioloop_add_wake_event(*(void *)(a1 + 16), a1, (uint64_t)probe_srp_retransmit, (uint64_t)probe_srp_context_release, v4 % v5 + v3);
    int v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = *(_DWORD *)a1;
      *(_DWORD *)buf = 136447490;
      long long v13 = "probe_srp_schedule_retransmission";
      __int16 v14 = 1024;
      int v15 = v7;
      __int16 v16 = 2048;
      uint64_t v17 = a1;
      __int16 v18 = 2080;
      int v19 = "probe_state";
      __int16 v20 = 2080;
      int v21 = "probe-srp.c";
      __int16 v22 = 1024;
      int v23 = 294;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    if (*(_DWORD *)a1)
    {
      int v8 = *(_DWORD *)a1 + 1;
      *(_DWORD *)a1 = v8;
      if (v8 >= 10001)
      {
        int v11 = v8;
        long long v9 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136447490;
          long long v13 = "probe_srp_schedule_retransmission";
          __int16 v14 = 1024;
          int v15 = v11;
          __int16 v16 = 2048;
          uint64_t v17 = a1;
          __int16 v18 = 2080;
          int v19 = "probe_state";
          __int16 v20 = 2080;
          int v21 = "probe-srp.c";
          __int16 v22 = 1024;
          int v23 = 294;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++probe_state_created;
      *(_DWORD *)a1 = 1;
    }
  }
  else
  {
    long long v10 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      long long v13 = "probe_srp_schedule_retransmission";
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%{public}s: can't allocate probe state wakeup", buf, 0xCu);
    }
    probe_srp_done((void *)a1, 0);
    ioloop_comm_cancel(*(void *)(a1 + 8));
  }
}

void probe_srp_context_release(void *a1)
{
  if (!a1) {
    return;
  }
  int v2 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    int v3 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v6 = 136447490;
    int v7 = "probe_srp_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)long long v9 = 0;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "probe_state";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "probe-srp.c";
    __int16 v10 = 1024;
    int v11 = 276;
    int v5 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  int v3 = global_os_log;
  if (v2 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v6 = 136447490;
    int v7 = "probe_srp_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)long long v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "probe_state";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "probe-srp.c";
    __int16 v10 = 1024;
    int v11 = 276;
    int v5 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, v5, (uint8_t *)&v6, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 136447490;
    int v7 = "probe_srp_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)long long v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "probe_state";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "probe-srp.c";
    __int16 v10 = 1024;
    int v11 = 276;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v6, 0x36u);
    int v2 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v2 - 1;
  if (v2 == 1)
  {
    unsigned __int16 v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 136447234;
      int v7 = "probe_srp_context_release";
      __int16 v8 = 2048;
      *(void *)long long v9 = a1;
      *(_WORD *)&v9[8] = 2080;
      *(void *)&v9[10] = "probe_state";
      *(_WORD *)&v9[18] = 2080;
      *(void *)&v9[20] = "probe-srp.c";
      *(_WORD *)&v9[28] = 1024;
      *(_DWORD *)&v9[30] = 276;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v6, 0x30u);
    }
    ++probe_state_finalized;
    probe_state_finalize(a1);
  }
}

void probe_srp_retransmit(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 1476) + 1;
  *(_DWORD *)(a1 + 1476) = v2;
  int v3 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    double v4 = (double)*(int *)(a1 + 1480);
    *(_DWORD *)int v6 = 136446722;
    *(void *)&v6[4] = "probe_srp_retransmit";
    *(_WORD *)&v6[12] = 1024;
    *(_DWORD *)&v6[14] = v2;
    __int16 v7 = 2048;
    double v8 = v4 / 1000.0;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: num_retransmissions = %d, time = %lg", v6, 0x1Cu);
    int v2 = *(_DWORD *)(a1 + 1476);
  }
  if (v2 < 4)
  {
    probe_srp_schedule_retransmission(a1);
    uint64_t v5 = *(unsigned __int16 *)(a1 + 1484);
    *(void *)int v6 = a1 + 64;
    *(void *)&v6[8] = v5;
    ioloop_send_message(*(void *)(a1 + 8), 0, (iovec *)v6);
  }
  else
  {
    probe_srp_done((void *)a1, 0);
    ioloop_comm_cancel(*(void *)(a1 + 8));
  }
}

void probe_srp_datagram(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  if (*(unsigned char *)(a3 + 1486))
  {
    int v3 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int16 v26 = 136446210;
      *(void *)&v26[4] = "probe_srp_datagram";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: datagram received after cancel--ignoring", v26, 0xCu);
    }
    return;
  }
  __int16 v7 = (unsigned __int16 *)(a2 + 88);
  int v8 = *(unsigned char *)(a2 + 91) & 0xF;
  uint64_t v9 = *a1;
  uint64_t v10 = global_os_log;
  BOOL v11 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (v9)
  {
    if (v11)
    {
      uint64_t v12 = a1[24];
      unsigned int v13 = bswap32(*(unsigned __int16 *)(*(void *)(a3 + 8) + 290));
      int v14 = *v7;
      int v15 = *(unsigned __int16 *)(a3 + 64);
      *(_DWORD *)__int16 v26 = 136447747;
      *(void *)&v26[4] = "probe_srp_datagram";
      __int16 v27 = 2160;
      uint64_t v28 = 1752392040;
      __int16 v29 = 2081;
      uint64_t v30 = v12;
      __int16 v31 = 1024;
      int v32 = HIWORD(v13);
      __int16 v33 = 1024;
      *(_DWORD *)__int16 v34 = v14;
      *(_WORD *)&v34[4] = 1024;
      *(_DWORD *)&v34[6] = v15;
      LOWORD(v35) = 1024;
      *(_DWORD *)((char *)&v35 + 2) = v8;
      __int16 v16 = "%{public}s: datagram from %{private, mask.hash}s on port %d xid %x (question xid %x) rcode %d";
      uint64_t v17 = v10;
      uint32_t v18 = 56;
LABEL_17:
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v16, v26, v18);
    }
  }
  else if (v11)
  {
    uint64_t v19 = *(void *)(a3 + 8);
    int v20 = *(unsigned __int8 *)(v19 + 296);
    if ((v20 & 0xFE) == 0xFC)
    {
      int v21 = "ULA: ";
    }
    else if (v20 == 254 && (*(unsigned char *)(v19 + 297) & 0xC0) == 0x80)
    {
      int v21 = "LUA: ";
    }
    else if ((v20 & 0xE0) == 0x20)
    {
      int v21 = "GUA: ";
    }
    else
    {
      int v21 = "";
    }
    unsigned int v22 = bswap32(*(unsigned __int16 *)(v19 + 290));
    int v23 = *v7;
    int v24 = *(unsigned __int16 *)(a3 + 64);
    *(_DWORD *)__int16 v26 = 136449795;
    *(void *)&v26[4] = "probe_srp_datagram";
    __int16 v27 = 2082;
    uint64_t v28 = (uint64_t)v21;
    __int16 v29 = 2160;
    uint64_t v30 = 1752392040;
    __int16 v31 = 1041;
    int v32 = 6;
    __int16 v33 = 2097;
    *(void *)__int16 v34 = v19 + 296;
    *(_WORD *)&v34[8] = 2160;
    uint64_t v35 = 1752392040;
    __int16 v36 = 1042;
    int v37 = 2;
    __int16 v38 = 2098;
    uint64_t v39 = v19 + 302;
    __int16 v40 = 2160;
    uint64_t v41 = 1752392040;
    __int16 v42 = 1041;
    int v43 = 8;
    __int16 v44 = 2097;
    uint64_t v45 = v19 + 304;
    __int16 v46 = 1024;
    unsigned int v47 = HIWORD(v22);
    __int16 v48 = 1024;
    int v49 = v23;
    __int16 v50 = 1024;
    int v51 = v24;
    __int16 v52 = 1024;
    int v53 = v8;
    __int16 v16 = "%{public}s: datagram from {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:i"
          "n6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} on port %d xid %x (question xid %x) rcode %d";
    uint64_t v17 = v10;
    uint32_t v18 = 124;
    goto LABEL_17;
  }
  if (*v7 == *(unsigned __int16 *)(a3 + 64))
  {
    *(void *)__int16 v26 = 0;
    if (dns_wire_parse_((uint64_t *)v26, v7, *(unsigned __int16 *)(a2 + 64)))
    {
      dns_message_free(*(void **)v26);
      if (v8 != 2)
      {
        probe_srp_done((void *)a3, v8 == 0);
        ioloop_comm_cancel(*(void *)(a3 + 8));
        uint64_t v25 = *(void *)(a3 + 16);
        if (v25) {
          ioloop_cancel_wake_event(v25);
        }
      }
    }
  }
}

uint64_t setup_for_command(void *a1, uint64_t a2, const char *a3, uint64_t a4, xpc_object_t xdict, uint64_t a6, uint64_t a7, uint64_t a8, char a9, char *a10, int a11)
{
  if (!a7 || !a8)
  {
    uint64_t v21 = global_os_log;
    uint64_t v22 = 4294901756;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return v22;
    }
    *(_DWORD *)buf = 136446466;
    int v69 = "setup_for_command";
    __int16 v70 = 2082;
    *(void *)uint64_t v71 = a2;
    int v23 = "%{public}s: %{public}s: NULL cti_connection_t OR Callback OR Client_Queue parameter";
    int v24 = v21;
    uint32_t v25 = 22;
LABEL_40:
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, v23, buf, v25);
    return v22;
  }
  if (a9)
  {
    xpc_dictionary_set_string(xdict, "command", "eventsOn");
    xpc_object_t v19 = xpc_array_create(0, 0);
    if (!v19) {
      return 4294901757;
    }
    int v20 = v19;
    uint64_t v58 = a2;
    xpc_array_set_string(v19, 0xFFFFFFFFFFFFFFFFLL, a3);
    xpc_dictionary_set_value(xdict, "eventList", v20);
    xpc_release(v20);
    a3 = 0;
  }
  else
  {
    uint64_t v58 = a2;
    xpc_dictionary_set_string(xdict, "command", "WpanctlCmd");
  }
  __int16 v26 = malloc_type_calloc(1uLL, 0x58uLL, 0x10F00403C42241CuLL);
  if (!v26)
  {
    __int16 v36 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      int v69 = "init_connection";
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_ERROR, "%{public}s: no memory to allocate!", buf, 0xCu);
    }
LABEL_38:
    uint64_t v22 = 4294901757;
    uint64_t v47 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return v22;
    }
    *(_DWORD *)buf = 136446722;
    int v69 = "setup_for_command";
    __int16 v70 = 2082;
    *(void *)uint64_t v71 = v58;
    *(_WORD *)&v71[8] = 1024;
    *(_DWORD *)&v71[10] = -65539;
    int v23 = "%{public}s: %{public}s: Since init_connection() returned %d error returning w/o sending msg";
    int v24 = v47;
    uint32_t v25 = 28;
    goto LABEL_40;
  }
  __int16 v27 = v26;
  v57 = a1;
  int v28 = client_serial_number;
  v26[20] = client_serial_number;
  client_serial_number = v28 + 1;
  __int16 v29 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v30 = *v27;
    *(_DWORD *)buf = 136447490;
    int v69 = "init_connection";
    __int16 v70 = 1024;
    *(_DWORD *)uint64_t v71 = v30;
    *(_WORD *)&v71[4] = 2048;
    *(void *)&v71[6] = v27;
    *(_WORD *)&v71[14] = 2080;
    *(void *)&v71[16] = "conn_ref";
    *(_WORD *)&v71[24] = 2080;
    *(void *)&v71[26] = strrchr(a10, 47) + 1;
    __int16 v72 = 1024;
    int v73 = a11;
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  int v31 = *v27;
  if (*v27)
  {
    int v32 = v31 + 1;
    _DWORD *v27 = v31 + 1;
    if (v31 + 1 >= 10001)
    {
      uint64_t v33 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_55;
      }
      __int16 v34 = strrchr(a10, 47);
      *(_DWORD *)buf = 136447490;
      int v69 = "init_connection";
      __int16 v70 = 1024;
      *(_DWORD *)uint64_t v71 = v32;
      *(_WORD *)&v71[4] = 2048;
      *(void *)&v71[6] = v27;
      *(_WORD *)&v71[14] = 2080;
      *(void *)&v71[16] = "conn_ref";
      *(_WORD *)&v71[24] = 2080;
      *(void *)&v71[26] = v34 + 1;
      __int16 v72 = 1024;
      int v73 = a11;
      uint64_t v35 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_51:
      unsigned int v56 = v33;
      goto LABEL_54;
    }
  }
  else
  {
    ++cti_connection_created;
    _DWORD *v27 = 1;
  }
  dispatch_retain((dispatch_object_t)&_dispatch_main_q);
  *((void *)v27 + 8) = a6;
  *((void *)v27 + 9) = v58;
  *((void *)v27 + 4) = &_dispatch_main_q;
  *((void *)v27 + 5) = a3;
  *((void *)v27 + 1) = a7;
  *((void *)v27 + 6) = a4;
  *((void *)v27 + 7) = a8;
  xpc_connection_t mach_service = xpc_connection_create_mach_service("com.apple.wpantund.xpc", (dispatch_queue_t)&_dispatch_main_q, 2uLL);
  *((void *)v27 + 2) = mach_service;
  __int16 v38 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v39 = v27[20];
    *(_DWORD *)buf = 136446722;
    int v69 = "init_connection";
    __int16 v70 = 1024;
    *(_DWORD *)uint64_t v71 = v39;
    *(_WORD *)&v71[4] = 2048;
    *(void *)&v71[6] = mach_service;
    _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] xpc connection: %p", buf, 0x1Cu);
  }
  *((void *)v27 + 3) = xdict;
  xpc_retain(xdict);
  cti_log_object((uint64_t)"init_connection/command", v27[20], *((void *)v27 + 9), (uint64_t)"", (uint64_t)"", xdict, "");
  __int16 v40 = global_os_log;
  if (!*((void *)v27 + 2))
  {
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      int v69 = "init_connection";
      _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "%{public}s: conn_ref/lib_q is NULL", buf, 0xCu);
    }
    int v44 = *v27;
    if (!*v27)
    {
      uint64_t v33 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_55;
      }
      *(_DWORD *)buf = 136447490;
      int v69 = "init_connection";
      __int16 v70 = 1024;
      *(_DWORD *)uint64_t v71 = 0;
      *(_WORD *)&v71[4] = 2048;
      *(void *)&v71[6] = v27;
      *(_WORD *)&v71[14] = 2080;
      *(void *)&v71[16] = "conn_ref";
      *(_WORD *)&v71[24] = 2080;
      *(void *)&v71[26] = "cti-services.c";
      __int16 v72 = 1024;
      int v73 = 579;
      uint64_t v35 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_51;
    }
    uint64_t v45 = global_os_log;
    if (v44 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_55;
      }
      *(_DWORD *)buf = 136447490;
      int v69 = "init_connection";
      __int16 v70 = 1024;
      *(_DWORD *)uint64_t v71 = v44;
      *(_WORD *)&v71[4] = 2048;
      *(void *)&v71[6] = v27;
      *(_WORD *)&v71[14] = 2080;
      *(void *)&v71[16] = "conn_ref";
      *(_WORD *)&v71[24] = 2080;
      *(void *)&v71[26] = "cti-services.c";
      __int16 v72 = 1024;
      int v73 = 579;
      uint64_t v35 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      unsigned int v56 = v45;
LABEL_54:
      _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_FAULT, v35, buf, 0x36u);
LABEL_55:
      abort();
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447490;
      int v69 = "init_connection";
      __int16 v70 = 1024;
      *(_DWORD *)uint64_t v71 = v44;
      *(_WORD *)&v71[4] = 2048;
      *(void *)&v71[6] = v27;
      *(_WORD *)&v71[14] = 2080;
      *(void *)&v71[16] = "conn_ref";
      *(_WORD *)&v71[24] = 2080;
      *(void *)&v71[26] = "cti-services.c";
      __int16 v72 = 1024;
      int v73 = 579;
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      int v44 = *v27;
    }
    _DWORD *v27 = v44 - 1;
    if (v44 == 1)
    {
      __int16 v46 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447234;
        int v69 = "init_connection";
        __int16 v70 = 2048;
        *(void *)uint64_t v71 = v27;
        *(_WORD *)&v71[8] = 2080;
        *(void *)&v71[10] = "conn_ref";
        *(_WORD *)&v71[18] = 2080;
        *(void *)&v71[20] = "cti-services.c";
        *(_WORD *)&v71[28] = 1024;
        *(_DWORD *)&v71[30] = 579;
        _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
      }
      ++cti_connection_finalized;
      cti_connection_finalize(v27);
    }
    goto LABEL_38;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v41 = *v27;
    *(_DWORD *)buf = 136447490;
    int v69 = "init_connection";
    __int16 v70 = 1024;
    *(_DWORD *)uint64_t v71 = v41;
    *(_WORD *)&v71[4] = 2048;
    *(void *)&v71[6] = v27;
    *(_WORD *)&v71[14] = 2080;
    *(void *)&v71[16] = "conn_ref";
    *(_WORD *)&v71[24] = 2080;
    *(void *)&v71[26] = "cti-services.c";
    __int16 v72 = 1024;
    int v73 = 584;
    _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  int v42 = *v27;
  if (*v27)
  {
    int v43 = v42 + 1;
    _DWORD *v27 = v42 + 1;
    if (v42 + 1 >= 10001)
    {
      uint64_t v33 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_55;
      }
      *(_DWORD *)buf = 136447490;
      int v69 = "init_connection";
      __int16 v70 = 1024;
      *(_DWORD *)uint64_t v71 = v43;
      *(_WORD *)&v71[4] = 2048;
      *(void *)&v71[6] = v27;
      *(_WORD *)&v71[14] = 2080;
      *(void *)&v71[16] = "conn_ref";
      *(_WORD *)&v71[24] = 2080;
      *(void *)&v71[26] = "cti-services.c";
      __int16 v72 = 1024;
      int v73 = 584;
      uint64_t v35 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_51;
    }
  }
  else
  {
    ++cti_connection_created;
    _DWORD *v27 = 1;
  }
  __int16 v48 = (_xpc_connection_s *)*((void *)v27 + 2);
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 0x40000000;
  handler[2] = __init_connection_block_invoke;
  handler[3] = &__block_descriptor_tmp_191;
  handler[4] = v27;
  xpc_connection_set_event_handler(v48, handler);
  xpc_connection_set_finalizer_f(*((xpc_connection_t *)v27 + 2), (xpc_finalizer_t)cti_xpc_connection_finalize);
  xpc_connection_set_context(*((xpc_connection_t *)v27 + 2), v27);
  xpc_connection_resume(*((xpc_connection_t *)v27 + 2));
  strcpy(v67, "srp-mdns-proxy");
  snprintf((char *)buf, 0x23uLL, "%s-%d", v67, v27[20]);
  xpc_object_t v49 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v49, "command", "checkIn");
  xpc_dictionary_set_string(v49, "clientName", (const char *)buf);
  cti_log_object((uint64_t)"init_connection/checkin", v27[20], *((void *)v27 + 9), (uint64_t)"", (uint64_t)"", v49, "");
  __int16 v50 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v51 = v27[20];
    uint64_t v52 = *((void *)v27 + 2);
    *(_DWORD *)int v61 = 136446722;
    v62 = "init_connection";
    __int16 v63 = 1024;
    int v64 = v51;
    __int16 v65 = 2048;
    uint64_t v66 = v52;
    _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] sending message on connection %p", v61, 0x1Cu);
  }
  int v53 = (_xpc_connection_s *)*((void *)v27 + 2);
  int v54 = *((void *)v27 + 4);
  v59[0] = _NSConcreteStackBlock;
  v59[1] = 0x40000000;
  v59[2] = __init_connection_block_invoke_82;
  v59[3] = &__block_descriptor_tmp_83;
  v59[4] = v27;
  xpc_connection_send_message_with_reply(v53, v49, v54, v59);
  xpc_release(v49);
  if (v57) {
    void *v57 = v27;
  }
  return 0;
}

void cti_log_object(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, xpc_object_t object, const char *a7)
{
  xpc_type_t type = xpc_get_type(object);
  if (a7) {
    int v14 = a7;
  }
  else {
    int v14 = (const char *)&cti_log_object_no_indent;
  }
  int v15 = v14;
  if (type != (xpc_type_t)&_xpc_type_dictionary && type != (xpc_type_t)&_xpc_type_array)
  {
    uint64_t v21 = cti_xpc_copy_description(object);
    uint64_t v22 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136448002;
      v105 = "cti_log_object";
      __int16 v106 = 1024;
      int v107 = a2;
      __int16 v108 = 2082;
      uint64_t v109 = a1;
      __int16 v110 = 2082;
      uint64_t v111 = a3;
      __int16 v112 = 2082;
      v113 = v14;
      __int16 v114 = 2082;
      uint64_t v115 = a4;
      __int16 v116 = 2082;
      uint64_t v117 = a5;
      __int16 v118 = 2082;
      v119 = v21;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] %{public}s(%{public}s): %{public}s%{public}s%{public}s %{public}s", buf, 0x4Eu);
    }
    int v24 = v21;
    goto LABEL_17;
  }
  xpc_type_t v17 = type;
  char v81 = 1;
  if (type == (xpc_type_t)&_xpc_type_dictionary)
  {
    v80[0] = _NSConcreteStackBlock;
    v80[1] = 0x40000000;
    v80[2] = __cti_log_object_block_invoke;
    v80[3] = &__block_descriptor_tmp_89;
    v80[4] = &v81;
    xpc_dictionary_apply(object, v80);
    if (v81)
    {
      uint64_t v66 = a1;
      size_t count = xpc_dictionary_get_count(object);
      __int16 v26 = malloc_type_malloc(8 * count, 0x10040436913F5uLL);
      if (v26)
      {
        int v20 = v26;
        size_t v70 = count;
        uint64_t v62 = a3;
        int v78 = 0;
        __int16 v27 = (const char **)malloc_type_malloc(8 * count, 0x50040EE9192B6uLL);
        if (!v27)
        {
          free(v20);
          int v28 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)v82 = 136446466;
            v83 = "cti_log_object";
            __int16 v84 = 1024;
            int v85 = a2;
            _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] no memory", v82, 0x12u);
          }
        }
        int v63 = a2;
        v77[0] = _NSConcreteStackBlock;
        v77[1] = 0x40000000;
        v77[2] = __cti_log_object_block_invoke_93;
        v77[3] = &__block_descriptor_tmp_94;
        v77[4] = v20;
        v77[5] = &v78;
        int v69 = v27;
        v77[6] = v27;
        xpc_dictionary_apply(object, v77);
        uint64_t v67 = "}";
        int v61 = "{";
        size_t v18 = v70;
        if (!v70) {
          goto LABEL_82;
        }
        goto LABEL_25;
      }
LABEL_74:
      int v60 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)v82 = 136446466;
        v83 = "cti_log_object";
        __int16 v84 = 1024;
        int v85 = a2;
        _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] no memory", v82, 0x12u);
      }
      return;
    }
LABEL_70:
    size_t v57 = strlen(v14);
    uint64_t v58 = (char *)malloc_type_malloc(v57 + 3, 0x30358557uLL);
    if (v58)
    {
      int v59 = v58;
      memset(v58, 32, v57 + 2);
      v59[v57 + 2] = 0;
      int v15 = v59;
    }
    if (v17 == (xpc_type_t)&_xpc_type_dictionary)
    {
      v74[0] = _NSConcreteStackBlock;
      v74[1] = 0x40000000;
      v74[2] = __cti_log_object_block_invoke_102;
      v74[3] = &__block_descriptor_tmp_104;
      int v75 = a2;
      v74[4] = a1;
      v74[5] = a3;
      v74[6] = v15;
      xpc_dictionary_apply(object, v74);
    }
    else
    {
      v72[0] = _NSConcreteStackBlock;
      v72[1] = 0x40000000;
      v72[2] = __cti_log_object_block_invoke_2_105;
      v72[3] = &__block_descriptor_tmp_107;
      int v73 = a2;
      v72[4] = a1;
      v72[5] = a3;
      v72[6] = v15;
      xpc_array_apply(object, v72);
    }
    if (v15 == v14) {
      return;
    }
    int v24 = (char *)v15;
LABEL_17:
    free(v24);
    return;
  }
  applier[0] = _NSConcreteStackBlock;
  applier[1] = 0x40000000;
  applier[2] = __cti_log_object_block_invoke_3;
  applier[3] = &__block_descriptor_tmp_92;
  applier[4] = &v81;
  xpc_array_apply(object, applier);
  if (!v81) {
    goto LABEL_70;
  }
  uint64_t v66 = a1;
  size_t v18 = xpc_array_get_count(object);
  xpc_object_t v19 = malloc_type_malloc(8 * v18, 0x10040436913F5uLL);
  if (!v19) {
    goto LABEL_74;
  }
  int v20 = v19;
  uint64_t v62 = a3;
  int v63 = a2;
  v76[0] = _NSConcreteStackBlock;
  v76[1] = 0x40000000;
  v76[2] = __cti_log_object_block_invoke_2_95;
  v76[3] = &__block_descriptor_tmp_96;
  v76[4] = v19;
  xpc_array_apply(object, v76);
  int v69 = 0;
  uint64_t v67 = "]";
  int v61 = "[";
  if (!v18) {
    goto LABEL_82;
  }
LABEL_25:
  uint64_t v64 = a5;
  __int16 v65 = v15;
  uint64_t v29 = 0;
  size_t v71 = v18 - 1;
  int v30 = (char *)buf;
  char v31 = 1;
  size_t v32 = 160;
  do
  {
    size_t v33 = v18;
    __int16 v34 = (const char *)*((void *)v20 + v29);
    if (v34)
    {
      size_t v35 = strlen(*((const char **)v20 + v29)) + 2;
    }
    else
    {
      __int16 v34 = "NULL";
      size_t v35 = 6;
    }
    if (v17 == (xpc_type_t)&_xpc_type_dictionary) {
      v35 += strlen(v69[v29]) + 2;
    }
    unint64_t v36 = v35 + 1;
    if (v35 + 1 <= v32) {
      goto LABEL_49;
    }
    if (v71 == v29) {
      int v37 = v67;
    }
    else {
      int v37 = "";
    }
    if (v32 != 160)
    {
      uint64_t v38 = global_os_log;
      BOOL v39 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
      int v30 = (char *)buf;
      if (v31)
      {
        if (v39)
        {
          *(_DWORD *)v82 = 136448514;
          v83 = "cti_log_object";
          __int16 v84 = 1024;
          int v85 = v63;
          __int16 v86 = 2082;
          uint64_t v87 = v66;
          __int16 v88 = 2082;
          uint64_t v89 = v62;
          __int16 v90 = 2082;
          v91 = v65;
          __int16 v92 = 2082;
          uint64_t v93 = a4;
          __int16 v94 = 2082;
          uint64_t v95 = v64;
          __int16 v96 = 2082;
          v97 = (uint8_t *)v61;
          __int16 v98 = 2082;
          v99 = buf;
          __int16 v100 = 2082;
          v101 = v37;
          __int16 v40 = v38;
          int v41 = "%{public}s: [CX%d] %{public}s(%{public}s): %{public}s%{public}s%{public}s %{public}s%{public}s%{public}s";
          uint32_t v42 = 98;
LABEL_41:
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, v41, v82, v42);
        }
      }
      else if (v39)
      {
        *(_DWORD *)v82 = 136448258;
        v83 = "cti_log_object";
        __int16 v84 = 1024;
        int v85 = v63;
        __int16 v86 = 2082;
        uint64_t v87 = v66;
        __int16 v88 = 2082;
        uint64_t v89 = v62;
        __int16 v90 = 2082;
        v91 = v65;
        __int16 v92 = 2082;
        uint64_t v93 = a4;
        __int16 v94 = 2082;
        uint64_t v95 = v64;
        __int16 v96 = 2082;
        v97 = buf;
        __int16 v98 = 2082;
        v99 = (uint8_t *)v37;
        __int16 v40 = v38;
        int v41 = "%{public}s: [CX%d] %{public}s(%{public}s): %{public}s%{public}s%{public}s +%{public}s%{public}s";
        uint32_t v42 = 88;
        goto LABEL_41;
      }
      char v31 = 0;
    }
    if (v36 < 0xA1)
    {
      size_t v32 = 160;
LABEL_49:
      size_t v18 = v33;
      if (v17 == (xpc_type_t)&_xpc_type_dictionary) {
        snprintf(v30, v32, "%s%s: %s%s");
      }
      else {
        snprintf(v30, v32, "%s%s%s");
      }
      size_t v47 = strlen(v30);
      v30 += v47;
      v32 -= v47;
      goto LABEL_63;
    }
    uint64_t v43 = global_os_log;
    BOOL v44 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
    if (v17 != (xpc_type_t)&_xpc_type_dictionary)
    {
      if (v31)
      {
        if (v44)
        {
          *(_DWORD *)v82 = 136448514;
          v83 = "cti_log_object";
          __int16 v84 = 1024;
          int v85 = v63;
          __int16 v86 = 2082;
          uint64_t v87 = v66;
          __int16 v88 = 2082;
          uint64_t v89 = v62;
          __int16 v90 = 2082;
          v91 = v65;
          __int16 v92 = 2082;
          uint64_t v93 = a4;
          __int16 v94 = 2082;
          uint64_t v95 = v64;
          __int16 v96 = 2082;
          v97 = (uint8_t *)v61;
          __int16 v98 = 2082;
          v99 = (uint8_t *)v34;
          __int16 v100 = 2082;
          v101 = v37;
          uint64_t v45 = v43;
          __int16 v46 = "%{public}s: [CX%d] %{public}s(%{public}s): %{public}s%{public}s%{public}s %{public}s%{public}s%{public}s";
LABEL_60:
          uint32_t v49 = 98;
          goto LABEL_61;
        }
        goto LABEL_62;
      }
      if (!v44) {
        goto LABEL_62;
      }
      *(_DWORD *)v82 = 136448258;
      v83 = "cti_log_object";
      __int16 v84 = 1024;
      int v85 = v63;
      __int16 v86 = 2082;
      uint64_t v87 = v66;
      __int16 v88 = 2082;
      uint64_t v89 = v62;
      __int16 v90 = 2082;
      v91 = v65;
      __int16 v92 = 2082;
      uint64_t v93 = a4;
      __int16 v94 = 2082;
      uint64_t v95 = v64;
      __int16 v96 = 2082;
      v97 = (uint8_t *)v34;
      __int16 v98 = 2082;
      v99 = (uint8_t *)v37;
      uint64_t v45 = v43;
      __int16 v46 = "%{public}s: [CX%d] %{public}s(%{public}s): %{public}s%{public}s%{public}s +%{public}s%{public}s";
      uint32_t v49 = 88;
LABEL_61:
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, v46, v82, v49);
      goto LABEL_62;
    }
    if (v31)
    {
      if (!v44) {
        goto LABEL_62;
      }
      __int16 v48 = (uint8_t *)v69[v29];
      *(_DWORD *)v82 = 136448770;
      v83 = "cti_log_object";
      __int16 v84 = 1024;
      int v85 = v63;
      __int16 v86 = 2082;
      uint64_t v87 = v66;
      __int16 v88 = 2082;
      uint64_t v89 = v62;
      __int16 v90 = 2082;
      v91 = v65;
      __int16 v92 = 2082;
      uint64_t v93 = a4;
      __int16 v94 = 2082;
      uint64_t v95 = v64;
      __int16 v96 = 2082;
      v97 = (uint8_t *)v61;
      __int16 v98 = 2082;
      v99 = v48;
      __int16 v100 = 2082;
      v101 = v34;
      __int16 v102 = 2082;
      v103 = v37;
      uint64_t v45 = v43;
      __int16 v46 = "%{public}s: [CX%d] %{public}s(%{public}s): %{public}s%{public}s%{public}s %{public}s%{public}s: %{public}s%{public}s";
      uint32_t v49 = 108;
      goto LABEL_61;
    }
    if (v44)
    {
      __int16 v50 = (uint8_t *)v69[v29];
      *(_DWORD *)v82 = 136448514;
      v83 = "cti_log_object";
      __int16 v84 = 1024;
      int v85 = v63;
      __int16 v86 = 2082;
      uint64_t v87 = v66;
      __int16 v88 = 2082;
      uint64_t v89 = v62;
      __int16 v90 = 2082;
      v91 = v65;
      __int16 v92 = 2082;
      uint64_t v93 = a4;
      __int16 v94 = 2082;
      uint64_t v95 = v64;
      __int16 v96 = 2082;
      v97 = v50;
      __int16 v98 = 2082;
      v99 = (uint8_t *)v34;
      __int16 v100 = 2082;
      v101 = v37;
      uint64_t v45 = v43;
      __int16 v46 = "%{public}s: [CX%d] %{public}s(%{public}s): %{public}s%{public}s%{public}s +%{public}s: %{public}s%{public}s";
      goto LABEL_60;
    }
LABEL_62:
    char v31 = 0;
    size_t v32 = 160;
    size_t v18 = v33;
LABEL_63:
    int v51 = (void *)*((void *)v20 + v29);
    if (v51)
    {
      free(v51);
      *((void *)v20 + v29) = 0;
    }
    ++v29;
  }
  while (v18 != v29);
  if (buf != (uint8_t *)v30)
  {
    uint64_t v52 = global_os_log;
    BOOL v53 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
    if (v31)
    {
      if (v53)
      {
        *(_DWORD *)v82 = 136448514;
        v83 = "cti_log_object";
        __int16 v84 = 1024;
        int v85 = v63;
        __int16 v86 = 2082;
        uint64_t v87 = v66;
        __int16 v88 = 2082;
        uint64_t v89 = v62;
        __int16 v90 = 2082;
        v91 = v65;
        __int16 v92 = 2082;
        uint64_t v93 = a4;
        __int16 v94 = 2082;
        uint64_t v95 = v64;
        __int16 v96 = 2082;
        v97 = (uint8_t *)v61;
        __int16 v98 = 2082;
        v99 = buf;
        __int16 v100 = 2082;
        v101 = v67;
        int v54 = "%{public}s: [CX%d] %{public}s(%{public}s): %{public}s%{public}s%{public}s %{public}s%{public}s%{public}s";
        v55 = v52;
        uint32_t v56 = 98;
        goto LABEL_81;
      }
    }
    else if (v53)
    {
      *(_DWORD *)v82 = 136448258;
      v83 = "cti_log_object";
      __int16 v84 = 1024;
      int v85 = v63;
      __int16 v86 = 2082;
      uint64_t v87 = v66;
      __int16 v88 = 2082;
      uint64_t v89 = v62;
      __int16 v90 = 2082;
      v91 = v65;
      __int16 v92 = 2082;
      uint64_t v93 = a4;
      __int16 v94 = 2082;
      uint64_t v95 = v64;
      __int16 v96 = 2082;
      v97 = buf;
      __int16 v98 = 2082;
      v99 = (uint8_t *)v67;
      int v54 = "%{public}s: [CX%d] %{public}s(%{public}s): %{public}s%{public}s%{public}s + %{public}s%{public}s";
      v55 = v52;
      uint32_t v56 = 88;
LABEL_81:
      _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, v54, v82, v56);
    }
  }
LABEL_82:
  free(v20);
  int v24 = (char *)v69;
  if (v69) {
    goto LABEL_17;
  }
}

void cti_connection_finalize(void *a1)
{
  int v2 = (void *)a1[3];
  if (v2) {
    xpc_release(v2);
  }

  free(a1);
}

void __init_connection_block_invoke(uint64_t a1, xpc_object_t object)
{
}

void __init_connection_block_invoke_82(uint64_t a1, xpc_object_t object)
{
}

void cti_event_handler(xpc_object_t object, uint64_t a2)
{
  if (object == &_xpc_error_connection_invalid)
  {
    __int16 v16 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = *(_DWORD *)(a2 + 80);
      size_t v18 = *(const char **)(a2 + 72);
      *(_DWORD *)buf = 136446722;
      uint64_t v58 = "cti_event_handler";
      __int16 v59 = 1024;
      int v60 = v17;
      __int16 v61 = 2082;
      string = v18;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] (%{public}s): cleanup", buf, 0x1Cu);
    }
    if (*(void *)(a2 + 8))
    {
      (*(void (**)(uint64_t, void *, uint64_t))(a2 + 56))(a2, &_xpc_error_connection_invalid, 4294901727);
    }
    else
    {
      uint64_t v22 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v23 = *(_DWORD *)(a2 + 80);
        *(_DWORD *)buf = 136446466;
        uint64_t v58 = "cti_event_handler";
        __int16 v59 = 1024;
        int v60 = v23;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] No callback", buf, 0x12u);
      }
    }
    int v24 = *(char **)(a2 + 16);
    if (v24)
    {
      uint32_t v25 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v26 = *(_DWORD *)(a2 + 80);
        *(_DWORD *)buf = 136446722;
        uint64_t v58 = "cti_event_handler";
        __int16 v59 = 1024;
        int v60 = v26;
        __int16 v61 = 2048;
        string = v24;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] releasing connection %p", buf, 0x1Cu);
        int v24 = *(char **)(a2 + 16);
      }
      xpc_release(v24);
      *(void *)(a2 + 16) = 0;
    }
  }
  else if (*(void *)(a2 + 16))
  {
    xpc_type_t type = xpc_get_type(object);
    int v5 = *(_DWORD *)(a2 + 80);
    uint64_t v6 = *(void *)(a2 + 72);
    if (type == (xpc_type_t)&_xpc_type_dictionary)
    {
      cti_log_object((uint64_t)"cti_event_handler", v5, v6, (uint64_t)"", (uint64_t)"", object, "");
      if (*(unsigned char *)(a2 + 84))
      {
        uint64_t v21 = *(void (**)(uint64_t, xpc_object_t, void))(a2 + 56);
        v21(a2, object, 0);
      }
      else
      {
        xpc_object_t value = xpc_dictionary_get_value(object, "commandResult");
        if (value)
        {
          if (xpc_int64_get_value(value)
            || (xpc_object_t v31 = xpc_dictionary_get_value(object, "commandData")) != 0
            && (xpc_object_t v32 = xpc_dictionary_get_value(v31, "ret")) != 0
            && xpc_int64_get_value(v32))
          {
            (*(void (**)(uint64_t, xpc_object_t, uint64_t))(a2 + 56))(a2, object, 4294901759);
            uint64_t v28 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_11;
            }
            int v29 = *(_DWORD *)(a2 + 80);
            int v30 = *(const char **)(a2 + 16);
            *(_DWORD *)buf = 136446722;
            uint64_t v58 = "cti_event_handler";
            __int16 v59 = 1024;
            int v60 = v29;
            __int16 v61 = 2048;
            string = v30;
            uint64_t v12 = "%{public}s: [CX%d] canceling xpc connection %p";
            unsigned int v13 = v28;
LABEL_9:
            os_log_type_t v14 = OS_LOG_TYPE_DEFAULT;
            uint32_t v15 = 28;
LABEL_10:
            _os_log_impl((void *)&_mh_execute_header, v13, v14, v12, buf, v15);
            goto LABEL_11;
          }
        }
        if (*(void *)(a2 + 40))
        {
          xpc_object_t v33 = xpc_dictionary_create(0, 0, 0);
          if (!v33)
          {
            uint64_t v47 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
              goto LABEL_11;
            }
            int v48 = *(_DWORD *)(a2 + 80);
            uint32_t v49 = *(const char **)(a2 + 72);
            uint64_t v50 = *(void *)(a2 + 16);
            *(_DWORD *)buf = 136446978;
            uint64_t v58 = "cti_event_handler";
            __int16 v59 = 1024;
            int v60 = v48;
            __int16 v61 = 2082;
            string = v49;
            __int16 v63 = 2048;
            uint64_t v64 = v50;
            uint64_t v12 = "%{public}s: [CX%d] cti_event_handler(%{public}s): no memory, canceling %p.";
            unsigned int v13 = v47;
            os_log_type_t v14 = OS_LOG_TYPE_ERROR;
            uint32_t v15 = 38;
            goto LABEL_10;
          }
          __int16 v34 = v33;
          xpc_object_t v35 = xpc_array_create(0, 0);
          if (v35)
          {
            unint64_t v36 = v35;
            xpc_dictionary_set_string(v34, "command", "eventsOn");
            xpc_dictionary_set_string(v34, "clientName", "srp-mdns-proxy");
            xpc_dictionary_set_value(v34, "eventList", v36);
            xpc_array_set_string(v36, 0xFFFFFFFFFFFFFFFFLL, *(const char **)(a2 + 40));
            *(void *)(a2 + 40) = 0;
            cti_log_object((uint64_t)"cti_event_handler/events on", *(_DWORD *)(a2 + 80), *(void *)(a2 + 72), (uint64_t)"", (uint64_t)"", v34, "");
            int v37 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              int v38 = *(_DWORD *)(a2 + 80);
              BOOL v39 = *(const char **)(a2 + 16);
              *(_DWORD *)buf = 136446722;
              uint64_t v58 = "cti_event_handler";
              __int16 v59 = 1024;
              int v60 = v38;
              __int16 v61 = 2048;
              string = v39;
              _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] sending message on connection %p", buf, 0x1Cu);
            }
            __int16 v40 = *(_xpc_connection_s **)(a2 + 16);
            int v41 = *(NSObject **)(a2 + 32);
            handler[0] = _NSConcreteStackBlock;
            handler[1] = 0x40000000;
            handler[2] = __cti_event_handler_block_invoke;
            handler[3] = &__block_descriptor_tmp_120;
            handler[4] = a2;
            xpc_connection_send_message_with_reply(v40, v34, v41, handler);
            xpc_release(v36);
          }
          else
          {
            int v51 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            {
              int v52 = *(_DWORD *)(a2 + 80);
              BOOL v53 = *(const char **)(a2 + 72);
              uint64_t v54 = *(void *)(a2 + 16);
              *(_DWORD *)buf = 136446978;
              uint64_t v58 = "cti_event_handler";
              __int16 v59 = 1024;
              int v60 = v52;
              __int16 v61 = 2082;
              string = v53;
              __int16 v63 = 2048;
              uint64_t v64 = v54;
              _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_ERROR, "%{public}s: [CX%d] cti_event_handler(%{public}s): no memory, canceling %p.", buf, 0x26u);
            }
            xpc_connection_cancel(*(xpc_connection_t *)(a2 + 16));
          }
        }
        else
        {
          __int16 v34 = *(void **)(a2 + 24);
          *(void *)(a2 + 24) = 0;
          cti_log_object((uint64_t)"cti_event_handler/command is", *(_DWORD *)(a2 + 80), *(void *)(a2 + 72), (uint64_t)"", (uint64_t)"", v34, "");
          *(unsigned char *)(a2 + 84) = 1;
          uint32_t v42 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v43 = *(_DWORD *)(a2 + 80);
            BOOL v44 = *(const char **)(a2 + 16);
            *(_DWORD *)buf = 136446722;
            uint64_t v58 = "cti_event_handler";
            __int16 v59 = 1024;
            int v60 = v43;
            __int16 v61 = 2048;
            string = v44;
            _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] sending message on connection %p", buf, 0x1Cu);
          }
          uint64_t v45 = *(_xpc_connection_s **)(a2 + 16);
          __int16 v46 = *(NSObject **)(a2 + 32);
          v55[0] = _NSConcreteStackBlock;
          v55[1] = 0x40000000;
          v55[2] = __cti_event_handler_block_invoke_122;
          v55[3] = &__block_descriptor_tmp_123;
          v55[4] = a2;
          xpc_connection_send_message_with_reply(v45, v34, v46, v55);
        }
        xpc_release(v34);
      }
    }
    else
    {
      cti_log_object((uint64_t)"cti_event_handler/other", v5, v6, (uint64_t)"", (uint64_t)"", object, "");
      __int16 v7 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        int v8 = *(_DWORD *)(a2 + 80);
        *(_DWORD *)buf = 136446722;
        uint64_t v58 = "cti_event_handler";
        __int16 v59 = 1024;
        int v60 = v8;
        __int16 v61 = 2082;
        string = xpc_dictionary_get_string(object, _xpc_error_key_description);
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "%{public}s: [CX%d] cti_event_handler: Unexpected Connection Error [%{public}s]", buf, 0x1Cu);
      }
      (*(void (**)(uint64_t, void, uint64_t))(a2 + 56))(a2, 0, 4294901733);
      if (object != &_xpc_error_connection_interrupted)
      {
        uint64_t v9 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
LABEL_11:
          xpc_connection_cancel(*(xpc_connection_t *)(a2 + 16));
          return;
        }
        int v10 = *(_DWORD *)(a2 + 80);
        BOOL v11 = *(const char **)(a2 + 16);
        *(_DWORD *)buf = 136446722;
        uint64_t v58 = "cti_event_handler";
        __int16 v59 = 1024;
        int v60 = v10;
        __int16 v61 = 2048;
        string = v11;
        uint64_t v12 = "%{public}s: [CX%d] canceling xpc connection %p";
        unsigned int v13 = v9;
        goto LABEL_9;
      }
    }
  }
  else
  {
    int v19 = *(_DWORD *)(a2 + 80);
    uint64_t v20 = *(void *)(a2 + 72);
    cti_log_object((uint64_t)"cti_event_handler NULL connection", v19, v20, (uint64_t)"", (uint64_t)"", object, "");
  }
}

uint64_t __cti_event_handler_block_invoke(int a1, xpc_object_t object)
{
  return cti_event_handler(object);
}

uint64_t __cti_event_handler_block_invoke_122(int a1, xpc_object_t object)
{
  return cti_event_handler(object);
}

void cti_xpc_connection_finalize(uint64_t a1)
{
  int v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(_DWORD *)(a1 + 80);
    uint64_t v4 = *(void *)(a1 + 72);
    int v5 = 136446722;
    uint64_t v6 = "cti_xpc_connection_finalize";
    __int16 v7 = 1024;
    int v8 = v3;
    __int16 v9 = 2082;
    uint64_t v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] %{public}s", (uint8_t *)&v5, 0x1Cu);
  }
  cti_connection_release_((void *)a1, 114);
}

void cti_connection_release_(void *a1, int a2)
{
  a1[1] = 0;
  int v4 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    int v5 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_15;
    }
    int v8 = 136447490;
    __int16 v9 = "cti_connection_release_";
    __int16 v10 = 1024;
    *(_DWORD *)BOOL v11 = 0;
    *(_WORD *)&v11[4] = 2048;
    *(void *)&v11[6] = a1;
    *(_WORD *)&v11[14] = 2080;
    *(void *)&v11[16] = "ref";
    *(_WORD *)&v11[24] = 2080;
    *(void *)&v11[26] = "cti-services.c";
    __int16 v12 = 1024;
    int v13 = a2;
    __int16 v7 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_14;
  }
  int v5 = global_os_log;
  if (v4 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_15;
    }
    int v8 = 136447490;
    __int16 v9 = "cti_connection_release_";
    __int16 v10 = 1024;
    *(_DWORD *)BOOL v11 = v4;
    *(_WORD *)&v11[4] = 2048;
    *(void *)&v11[6] = a1;
    *(_WORD *)&v11[14] = 2080;
    *(void *)&v11[16] = "ref";
    *(_WORD *)&v11[24] = 2080;
    *(void *)&v11[26] = "cti-services.c";
    __int16 v12 = 1024;
    int v13 = a2;
    __int16 v7 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_14:
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, v7, (uint8_t *)&v8, 0x36u);
LABEL_15:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v8 = 136447490;
    __int16 v9 = "cti_connection_release_";
    __int16 v10 = 1024;
    *(_DWORD *)BOOL v11 = v4;
    *(_WORD *)&v11[4] = 2048;
    *(void *)&v11[6] = a1;
    *(_WORD *)&v11[14] = 2080;
    *(void *)&v11[16] = "ref";
    *(_WORD *)&v11[24] = 2080;
    *(void *)&v11[26] = "cti-services.c";
    __int16 v12 = 1024;
    int v13 = a2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v8, 0x36u);
    int v4 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v4 - 1;
  if (v4 == 1)
  {
    uint64_t v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = 136447234;
      __int16 v9 = "cti_connection_release_";
      __int16 v10 = 2048;
      *(void *)BOOL v11 = a1;
      *(_WORD *)&v11[8] = 2080;
      *(void *)&v11[10] = "ref";
      *(_WORD *)&v11[18] = 2080;
      *(void *)&v11[20] = "cti-services.c";
      *(_WORD *)&v11[28] = 1024;
      *(_DWORD *)&v11[30] = a2;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v8, 0x30u);
    }
    ++cti_connection_finalized;
    cti_connection_finalize(a1);
  }
}

uint64_t __cti_log_object_block_invoke(uint64_t a1, int a2, xpc_object_t object)
{
  xpc_type_t type = xpc_get_type(object);
  if (type == (xpc_type_t)&_xpc_type_dictionary)
  {
    **(unsigned char **)(a1 + 32) = 0;
  }
  else if (type == (xpc_type_t)&_xpc_type_array)
  {
    applier[0] = _NSConcreteStackBlock;
    applier[1] = 0x40000000;
    applier[2] = __cti_log_object_block_invoke_2;
    applier[3] = &__block_descriptor_tmp_87;
    applier[4] = *(void *)(a1 + 32);
    xpc_array_apply(object, applier);
  }
  return 1;
}

uint64_t __cti_log_object_block_invoke_3(uint64_t a1, int a2, xpc_object_t object)
{
  xpc_type_t type = xpc_get_type(object);
  if (type == (xpc_type_t)&_xpc_type_dictionary || type == (xpc_type_t)&_xpc_type_array) {
    **(unsigned char **)(a1 + 32) = 0;
  }
  return 1;
}

uint64_t __cti_log_object_block_invoke_93(uint64_t a1, uint64_t a2, void *a3)
{
  *(void *)(*(void *)(a1 + 32) + 8 * **(int **)(a1 + 40)) = cti_xpc_copy_description(a3);
  *(void *)(*(void *)(a1 + 48) + 8 * (int)(**(_DWORD **)(a1 + 40))++) = a2;
  return 1;
}

uint64_t __cti_log_object_block_invoke_2_95(uint64_t a1, uint64_t a2, void *a3)
{
  *(void *)(*(void *)(a1 + 32) + 8 * a2) = cti_xpc_copy_description(a3);
  return 1;
}

uint64_t __cti_log_object_block_invoke_102(uint64_t a1, int a2, xpc_object_t object)
{
  return 1;
}

uint64_t __cti_log_object_block_invoke_2_105(uint64_t a1, uint64_t a2, void *a3)
{
  snprintf(__str, 0x17uLL, "%zd", a2);
  cti_log_object(*(void *)(a1 + 32), *(_DWORD *)(a1 + 56), *(void *)(a1 + 40), (int)__str, (int)": ", a3);
  return 1;
}

char *cti_xpc_copy_description(void *a1)
{
  xpc_type_t type = xpc_get_type(a1);
  if (type == (xpc_type_t)&_xpc_type_uint64)
  {
    xpc_uint64_get_value(a1);
    snprintf(__str, 0x17uLL, "%llu");
    return strdup(__str);
  }
  if (type == (xpc_type_t)&_xpc_type_int64)
  {
    xpc_int64_get_value(a1);
    snprintf(__str, 0x17uLL, "%lld");
    return strdup(__str);
  }
  if (type == (xpc_type_t)&_xpc_type_string)
  {
    string_ptr = xpc_string_get_string_ptr(a1);
    size_t length = xpc_string_get_length(a1);
    uint64_t v20 = malloc_type_malloc(length + 3, 0x198576CCuLL);
    if (!v20)
    {
LABEL_39:
      return xpc_copy_description(a1);
    }
    __int16 v9 = v20;
    *uint64_t v20 = 34;
    size_t v21 = length + 1;
    strlcpy(v20 + 1, string_ptr, v21);
    *(_WORD *)&v9[v21] = 34;
    return v9;
  }
  if (type == (xpc_type_t)&_xpc_type_data)
  {
    bytes_ptr = (unsigned __int8 *)xpc_data_get_bytes_ptr(a1);
    size_t v23 = xpc_data_get_length(a1);
    int v24 = malloc_type_malloc(2 * v23 + 3, 0xE248474CuLL);
    if (v24)
    {
      __int16 v9 = v24;
      *int v24 = 30768;
      if (v23)
      {
        uint32_t v25 = (char *)v24;
        do
        {
          int v26 = *bytes_ptr++;
          snprintf(v25, 3uLL, "%02x", v26);
          v25 += 2;
          --v23;
        }
        while (v23);
      }
      return v9;
    }
    goto LABEL_39;
  }
  if (type != (xpc_type_t)&_xpc_type_BOOL)
  {
    if (type == (xpc_type_t)&_xpc_type_array)
    {
      size_t count = xpc_array_get_count(a1);
      int v4 = malloc_type_malloc(8 * count, 0x10040436913F5uLL);
      if (!v4) {
        return 0;
      }
      int v5 = v4;
      applier[0] = _NSConcreteStackBlock;
      applier[1] = 0x40000000;
      applier[2] = __cti_xpc_copy_description_block_invoke;
      applier[3] = &__block_descriptor_tmp_113_234;
      applier[4] = v4;
      xpc_array_apply(a1, applier);
      if (count)
      {
        uint64_t v6 = 0;
        size_t v7 = 0;
        do
        {
          int v8 = (const char *)v5[v6];
          if (v8) {
            v7 += strlen(v8) + 2;
          }
          else {
            v7 += 6;
          }
          ++v6;
        }
        while (count != v6);
        __int16 v9 = malloc_type_malloc(v7 + 3, 0xFD0AE542uLL);
        uint64_t v10 = 0;
        unsigned char *v9 = 91;
        BOOL v11 = v9 + 1;
        do
        {
          if (v11)
          {
            __int16 v12 = " ";
            if (!v10) {
              __int16 v12 = "";
            }
            int v13 = (const char *)v5[v10];
            if (!v13) {
              int v13 = "NULL";
            }
            if (count - 1 == v10) {
              os_log_type_t v14 = "";
            }
            else {
              os_log_type_t v14 = ",";
            }
            snprintf(v11, v7, "%s%s%s", v12, v13, v14);
            size_t v15 = strlen(v11);
            v11 += v15;
            v7 -= v15;
          }
          __int16 v16 = (void *)v5[v10];
          if (v16) {
            free(v16);
          }
          ++v10;
        }
        while (count != v10);
      }
      else
      {
        __int16 v9 = malloc_type_malloc(3uLL, 0xFD0AE542uLL);
        unsigned char *v9 = 91;
        BOOL v11 = v9 + 1;
      }
      *(_WORD *)BOOL v11 = 93;
      free(v5);
      return v9;
    }
    goto LABEL_39;
  }
  if (xpc_BOOL_get_value(a1)) {
    __int16 v27 = "true";
  }
  else {
    __int16 v27 = "false";
  }

  return strdup(v27);
}

uint64_t __cti_xpc_copy_description_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(void *)(*(void *)(a1 + 32) + 8 * a2) = cti_xpc_copy_description(a3);
  return 1;
}

uint64_t __cti_log_object_block_invoke_2(uint64_t a1, int a2, xpc_object_t object)
{
  xpc_type_t type = xpc_get_type(object);
  if (type == (xpc_type_t)&_xpc_type_dictionary || type == (xpc_type_t)&_xpc_type_array) {
    **(unsigned char **)(a1 + 32) = 0;
  }
  return 1;
}

void cti_internal_reply_callback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  cti_internal_event_reply_callback(a1, a2, a3);
  *(void *)(a1 + 8) = 0;
  int v4 = *(_xpc_connection_s **)(a1 + 16);
  if (v4)
  {
    int v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *(_DWORD *)(a1 + 80);
      int v7 = 136446722;
      int v8 = "cti_internal_reply_callback";
      __int16 v9 = 1024;
      int v10 = v6;
      __int16 v11 = 2048;
      __int16 v12 = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] canceling connection %p", (uint8_t *)&v7, 0x1Cu);
      int v4 = *(_xpc_connection_s **)(a1 + 16);
    }
    xpc_connection_cancel(v4);
  }
  cti_connection_release_((void *)a1, 673);
}

void cti_internal_event_reply_callback(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v5 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    if (a1) {
      int v6 = *(_DWORD *)(a1 + 80);
    }
    else {
      int v6 = 0;
    }
    int v8 = 136446722;
    __int16 v9 = "cti_internal_event_reply_callback";
    __int16 v10 = 1024;
    int v11 = v6;
    __int16 v12 = 2048;
    uint64_t v13 = a1;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] conn_ref = %p", (uint8_t *)&v8, 0x1Cu);
  }
  int v7 = *(void (**)(void, uint64_t))(a1 + 8);
  if (v7) {
    v7(*(void *)(a1 + 64), a3);
  }
}

uint64_t cti_get_tunnel_name_(uint64_t a1, uint64_t a2, char *a3, int a4)
{
  xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v8, "interface", "org.wpantund.v1");
  xpc_dictionary_set_string(v8, "path", "/org/wpantund/utun2");
  xpc_dictionary_set_string(v8, "method", "PropGet");
  xpc_dictionary_set_string(v8, "property_name", "Config:TUN:InterfaceName");
  uint64_t v9 = setup_for_command(0, (uint64_t)"get_tunnel_name", 0, (uint64_t)"Config:TUN:InterfaceName", v8, a1, a2, (uint64_t)cti_internal_string_property_reply, 0, a3, a4);
  xpc_release(v8);
  return v9;
}

void cti_internal_string_property_reply(uint64_t a1, void *a2, uint64_t a3)
{
  cti_internal_string_event_reply(a1, a2, a3);
  *(void *)(a1 + 8) = 0;
  int v4 = *(_xpc_connection_s **)(a1 + 16);
  if (v4)
  {
    int v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *(_DWORD *)(a1 + 80);
      int v11 = 136446722;
      __int16 v12 = "cti_internal_string_property_reply";
      __int16 v13 = 1024;
      *(_DWORD *)os_log_type_t v14 = v6;
      *(_WORD *)&v14[4] = 2048;
      *(void *)&v14[6] = v4;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] canceling connection %p", (uint8_t *)&v11, 0x1Cu);
      int v4 = *(_xpc_connection_s **)(a1 + 16);
    }
    xpc_connection_cancel(v4);
  }
  int v7 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    xpc_object_t v8 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_19;
    }
    int v11 = 136447490;
    __int16 v12 = "cti_internal_string_property_reply";
    __int16 v13 = 1024;
    *(_DWORD *)os_log_type_t v14 = 0;
    *(_WORD *)&v14[4] = 2048;
    *(void *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(void *)&v14[16] = "conn_ref";
    *(_WORD *)&v14[24] = 2080;
    *(void *)&v14[26] = "cti-services.c";
    __int16 v15 = 1024;
    int v16 = 925;
    __int16 v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_18;
  }
  xpc_object_t v8 = global_os_log;
  if (v7 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_19;
    }
    int v11 = 136447490;
    __int16 v12 = "cti_internal_string_property_reply";
    __int16 v13 = 1024;
    *(_DWORD *)os_log_type_t v14 = v7;
    *(_WORD *)&v14[4] = 2048;
    *(void *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(void *)&v14[16] = "conn_ref";
    *(_WORD *)&v14[24] = 2080;
    *(void *)&v14[26] = "cti-services.c";
    __int16 v15 = 1024;
    int v16 = 925;
    __int16 v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_18:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v11, 0x36u);
LABEL_19:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = 136447490;
    __int16 v12 = "cti_internal_string_property_reply";
    __int16 v13 = 1024;
    *(_DWORD *)os_log_type_t v14 = v7;
    *(_WORD *)&v14[4] = 2048;
    *(void *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(void *)&v14[16] = "conn_ref";
    *(_WORD *)&v14[24] = 2080;
    *(void *)&v14[26] = "cti-services.c";
    __int16 v15 = 1024;
    int v16 = 925;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v11, 0x36u);
    int v7 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v7 - 1;
  if (v7 == 1)
  {
    uint64_t v9 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 136447234;
      __int16 v12 = "cti_internal_string_property_reply";
      __int16 v13 = 2048;
      *(void *)os_log_type_t v14 = a1;
      *(_WORD *)&v14[8] = 2080;
      *(void *)&v14[10] = "conn_ref";
      *(_WORD *)&v14[18] = 2080;
      *(void *)&v14[20] = "cti-services.c";
      *(_WORD *)&v14[28] = 1024;
      *(_DWORD *)&v14[30] = 925;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v11, 0x30u);
    }
    ++cti_connection_finalized;
    cti_connection_finalize((void *)a1);
  }
}

void cti_internal_string_event_reply(uint64_t a1, xpc_object_t object, uint64_t a3)
{
  int v6 = *(void (**)(void, const char *, uint64_t))(a1 + 8);
  xpc_retain(object);
  if (a3) {
    goto LABEL_2;
  }
  xpc_object_t value = xpc_dictionary_get_value(object, "commandResult");
  if (!value)
  {
    xpc_object_t dictionary = xpc_dictionary_get_dictionary(object, "eventData");
    if (dictionary)
    {
      xpc_object_t array = xpc_dictionary_get_array(dictionary, "value");
      if (!array)
      {
        uint64_t v21 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
          goto LABEL_31;
        }
        int v27 = *(_DWORD *)(a1 + 80);
        int v32 = 136446466;
        xpc_object_t v33 = "cti_internal_string_event_reply";
        __int16 v34 = 1024;
        int v35 = v27;
        __int16 v13 = "%{public}s: [CX%d] eventData dictionary contains no 'value' key";
        goto LABEL_29;
      }
      size_t v18 = array;
      size_t count = xpc_array_get_count(array);
      if (count != 1)
      {
        size_t v20 = count;
        if (!count)
        {
          uint64_t v21 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
            goto LABEL_31;
          }
          int v22 = *(_DWORD *)(a1 + 80);
          int v32 = 136446466;
          xpc_object_t v33 = "cti_internal_string_event_reply";
          __int16 v34 = 1024;
          int v35 = v22;
          __int16 v13 = "%{public}s: [CX%d] eventData value array has no elements";
LABEL_29:
          os_log_type_t v14 = v21;
          uint32_t v15 = 18;
          goto LABEL_30;
        }
        uint64_t v28 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          int v29 = *(_DWORD *)(a1 + 80);
          int v32 = 136446722;
          xpc_object_t v33 = "cti_internal_string_event_reply";
          __int16 v34 = 1024;
          int v35 = v29;
          __int16 v36 = 2048;
          size_t v37 = v20;
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "%{public}s: [CX%d] eventData value array has %zd elements", (uint8_t *)&v32, 0x1Cu);
        }
      }
      string = xpc_array_get_string(v18, 0);
      if (string)
      {
        int v7 = string;
        a3 = 0;
        goto LABEL_32;
      }
      uint64_t v21 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
        goto LABEL_31;
      }
      int v31 = *(_DWORD *)(a1 + 80);
      int v32 = 136446466;
      xpc_object_t v33 = "cti_internal_string_event_reply";
      __int16 v34 = 1024;
      int v35 = v31;
      __int16 v13 = "%{public}s: [CX%d] eventData value array's first element is not a string";
      goto LABEL_29;
    }
    uint64_t v21 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_31;
    }
    int v26 = *(_DWORD *)(a1 + 80);
    int v32 = 136446466;
    xpc_object_t v33 = "cti_internal_string_event_reply";
    __int16 v34 = 1024;
    int v35 = v26;
    __int16 v13 = "%{public}s: [CX%d] no eventData dictionary";
    goto LABEL_29;
  }
  int64_t v9 = xpc_int64_get_value(value);
  if (v9)
  {
    int64_t v10 = v9;
    uint64_t v11 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      int v12 = *(_DWORD *)(a1 + 80);
      int v32 = 136446722;
      xpc_object_t v33 = "cti_internal_string_event_reply";
      __int16 v34 = 1024;
      int v35 = v12;
      __int16 v36 = 2048;
      size_t v37 = v10;
      __int16 v13 = "%{public}s: [CX%d] nonzero result %llu";
      os_log_type_t v14 = v11;
      uint32_t v15 = 28;
LABEL_30:
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, v13, (uint8_t *)&v32, v15);
    }
LABEL_31:
    int v7 = 0;
    a3 = 4294901759;
    goto LABEL_32;
  }
  xpc_object_t v23 = xpc_dictionary_get_dictionary(object, "commandData");
  if (!v23) {
    goto LABEL_31;
  }
  int v24 = v23;
  uint32_t v25 = xpc_dictionary_get_string(v23, "property_name");
  if (!v25) {
    goto LABEL_31;
  }
  a3 = 4294901759;
  if (strcmp(v25, *(const char **)(a1 + 48)))
  {
LABEL_2:
    int v7 = 0;
    goto LABEL_32;
  }
  int v7 = xpc_dictionary_get_string(v24, "value");
  if (v7) {
    a3 = 0;
  }
  else {
    a3 = 4294901759;
  }
LABEL_32:
  if (v6) {
    v6(*(void *)(a1 + 64), v7, a3);
  }
  xpc_release(object);
}

uint64_t cti_track_active_data_set_(void *a1, uint64_t a2, uint64_t a3, char *a4, int a5)
{
  xpc_object_t v10 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v10, "interface", "org.wpantund.v1");
  xpc_dictionary_set_string(v10, "path", "/org/wpantund/utun2");
  uint64_t v11 = setup_for_command(a1, (uint64_t)"track_active_data_set", "ActiveDataSetChanged", 0, v10, a2, a3, (uint64_t)cti_internal_event_reply_callback, 1, a4, a5);
  xpc_release(v10);
  return v11;
}

uint64_t cti_internal_state_reply_callback(uint64_t result, void *a2, uint64_t a3)
{
  uint64_t v3 = result;
  int v4 = *(uint64_t (**)(void, uint64_t, uint64_t))(result + 8);
  if (a3)
  {
    uint64_t v5 = a3;
LABEL_5:
    uint64_t v6 = 12;
    goto LABEL_6;
  }
  *(void *)xdict = 0;
  uint64_t result = cti_event_or_response_extract(a2, xdict);
  if (result)
  {
    uint64_t v5 = result;
    goto LABEL_5;
  }
  uint64_t result = (uint64_t)xpc_dictionary_get_string(*(xpc_object_t *)xdict, "value");
  if (!result)
  {
    uint64_t v5 = 4294901759;
    goto LABEL_5;
  }
  int64_t v9 = (const char *)result;
  uint64_t result = strcmp((const char *)result, "uninitialized");
  if (result)
  {
    uint64_t result = strcmp(v9, "uninitialized:fault");
    if (result)
    {
      uint64_t result = strcmp(v9, "uninitialized:upgrading");
      if (result)
      {
        uint64_t result = strcmp(v9, "offline:deep-sleep");
        if (result)
        {
          uint64_t result = strcmp(v9, "offline");
          if (result)
          {
            uint64_t result = strcmp(v9, "offline:commissioned");
            if (result)
            {
              uint64_t result = strcmp(v9, "associating");
              if (result)
              {
                uint64_t result = strcmp(v9, "associating:credentials-needed");
                if (result)
                {
                  uint64_t result = strcmp(v9, "associated");
                  if (result)
                  {
                    uint64_t result = strcmp(v9, "associated:no-parent");
                    if (result)
                    {
                      uint64_t result = strcmp(v9, "associated:netwake-asleep");
                      if (result)
                      {
                        uint64_t result = strcmp(v9, "associated:netwake-waking");
                        uint64_t v5 = 0;
                        if (result) {
                          uint64_t v6 = 12;
                        }
                        else {
                          uint64_t v6 = 11;
                        }
                      }
                      else
                      {
                        uint64_t v5 = 0;
                        uint64_t v6 = 10;
                      }
                    }
                    else
                    {
                      uint64_t v5 = 0;
                      uint64_t v6 = 9;
                    }
                  }
                  else
                  {
                    uint64_t v5 = 0;
                    uint64_t v6 = 8;
                  }
                }
                else
                {
                  uint64_t v5 = 0;
                  uint64_t v6 = 7;
                }
              }
              else
              {
                uint64_t v5 = 0;
                uint64_t v6 = 6;
              }
            }
            else
            {
              uint64_t v5 = 0;
              uint64_t v6 = 5;
            }
          }
          else
          {
            uint64_t v5 = 0;
            uint64_t v6 = 4;
          }
        }
        else
        {
          uint64_t v5 = 0;
          uint64_t v6 = 3;
        }
      }
      else
      {
        uint64_t v5 = 0;
        uint64_t v6 = 2;
      }
    }
    else
    {
      uint64_t v5 = 0;
      uint64_t v6 = 1;
    }
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v5 = 0;
  }
LABEL_6:
  if (v4)
  {
    int v7 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = *(_DWORD *)(v3 + 80);
      *(_DWORD *)xdict = 136446722;
      *(void *)&xdict[4] = "cti_internal_state_reply_callback";
      __int16 v11 = 1024;
      int v12 = v8;
      __int16 v13 = 2048;
      uint64_t v14 = v3;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] calling callback for %p", xdict, 0x1Cu);
    }
    return v4(*(void *)(v3 + 64), v6, v5);
  }
  return result;
}

uint64_t cti_event_or_response_extract(void *a1, void *a2)
{
  xpc_object_t dictionary = xpc_dictionary_get_dictionary(a1, "commandData");
  if (dictionary)
  {
    xpc_object_t v5 = dictionary;
    int int64 = xpc_dictionary_get_int64(a1, "commandResult");
    if (int64)
    {
      uint64_t v7 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v13 = 136446466;
        uint64_t v14 = "cti_event_or_response_extract";
        __int16 v15 = 1024;
        int v16 = int64;
        int v8 = "%{public}s: nonzero status %d";
        int64_t v9 = v7;
        uint32_t v10 = 18;
LABEL_9:
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, v8, (uint8_t *)&v13, v10);
        return 4294901759;
      }
      return 4294901759;
    }
LABEL_6:
    uint64_t result = 0;
    *a2 = v5;
    return result;
  }
  xpc_object_t v5 = xpc_dictionary_get_dictionary(a1, "eventData");
  if (v5) {
    goto LABEL_6;
  }
  uint64_t v12 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = 136446210;
    uint64_t v14 = "cti_event_or_response_extract";
    int v8 = "%{public}s: null result";
    int64_t v9 = v12;
    uint32_t v10 = 12;
    goto LABEL_9;
  }
  return 4294901759;
}

void cti_internal_network_node_type_callback(uint64_t a1, void *a2, uint64_t a3)
{
  int v4 = *(void (**)(void, uint64_t, uint64_t))(a1 + 8);
  if (a3)
  {
    uint64_t v5 = a3;
    goto LABEL_4;
  }
  xpc_object_t xdict = 0;
  uint64_t v5 = cti_event_or_response_extract(a2, &xdict);
  if (v5) {
    goto LABEL_4;
  }
  xpc_object_t v9 = xdict;
  xpc_object_t value = xpc_dictionary_get_value(xdict, "value");
  if (!value)
  {
    __int16 v15 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      int v16 = *(_DWORD *)(a1 + 80);
      *(_DWORD *)buf = 136446466;
      size_t v20 = "cti_internal_network_node_type_callback";
      __int16 v21 = 1024;
      int v22 = v16;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%{public}s: [CX%d] No node type returned.", buf, 0x12u);
    }
    goto LABEL_4;
  }
  __int16 v11 = value;
  if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_string)
  {
    uint64_t v12 = xpc_copy_description(v11);
    int v13 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      int v14 = *(_DWORD *)(a1 + 80);
      *(_DWORD *)buf = 136446722;
      size_t v20 = "cti_internal_network_node_type_callback";
      __int16 v21 = 1024;
      int v22 = v14;
      __int16 v23 = 2082;
      int v24 = v12;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%{public}s: [CX%d] node type type is %{public}s instead of string.", buf, 0x1Cu);
    }
    free(v12);
    goto LABEL_4;
  }
  string = xpc_dictionary_get_string(v9, "value");
  if (!strcmp(string, "unknown"))
  {
LABEL_4:
    uint64_t v6 = 0;
    goto LABEL_5;
  }
  if (!strcmp(string, "router"))
  {
    uint64_t v6 = 1;
  }
  else if (!strcmp(string, "end-device"))
  {
    uint64_t v6 = 2;
  }
  else if (!strcmp(string, "sleepy-end-device"))
  {
    uint64_t v6 = 3;
  }
  else if (!strcmp(string, "synchronized-sleepy-end-device"))
  {
    uint64_t v6 = 4;
  }
  else if (!strcmp(string, "nl-lurker"))
  {
    uint64_t v6 = 5;
  }
  else if (!strcmp(string, "commissioner"))
  {
    uint64_t v6 = 6;
  }
  else if (!strcmp(string, "leader"))
  {
    uint64_t v6 = 7;
  }
  else
  {
    uint64_t v6 = 8 * (strcmp(string, "sleepy-router") == 0);
  }
LABEL_5:
  if (v4)
  {
    uint64_t v7 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = *(_DWORD *)(a1 + 80);
      *(_DWORD *)buf = 136446722;
      size_t v20 = "cti_internal_network_node_type_callback";
      __int16 v21 = 1024;
      int v22 = v8;
      __int16 v23 = 2048;
      int v24 = (char *)a1;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] calling callback for %p", buf, 0x1Cu);
    }
    v4(*(void *)(a1 + 64), v6, v5);
  }
}

void cti_service_vec_finalize(unint64_t *a1)
{
  int v2 = (void *)a1[2];
  if (!v2) {
    goto LABEL_20;
  }
  if (!*a1) {
    goto LABEL_19;
  }
  unint64_t v3 = 0;
  do
  {
    uint64_t v4 = *(void *)(a1[2] + 8 * v3);
    if (!v4) {
      goto LABEL_17;
    }
    int v5 = *(_DWORD *)(v4 + 48);
    if (!v5)
    {
      uint64_t v10 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_26;
      }
      *(_DWORD *)buf = 136447490;
      int v14 = "cti_service_vec_finalize";
      __int16 v15 = 1024;
      *(_DWORD *)int v16 = 0;
      *(_WORD *)&v16[4] = 2048;
      *(void *)&v16[6] = v4;
      *(_WORD *)&v16[14] = 2080;
      *(void *)&v16[16] = "services->services[i]";
      *(_WORD *)&v16[24] = 2080;
      *(void *)&v16[26] = "cti-services.c";
      __int16 v17 = 1024;
      int v18 = 1280;
      __int16 v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      uint64_t v12 = v10;
      goto LABEL_25;
    }
    uint64_t v6 = global_os_log;
    if (v5 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_26;
      }
      *(_DWORD *)buf = 136447490;
      int v14 = "cti_service_vec_finalize";
      __int16 v15 = 1024;
      *(_DWORD *)int v16 = v5;
      *(_WORD *)&v16[4] = 2048;
      *(void *)&v16[6] = v4;
      *(_WORD *)&v16[14] = 2080;
      *(void *)&v16[16] = "services->services[i]";
      *(_WORD *)&v16[24] = 2080;
      *(void *)&v16[26] = "cti-services.c";
      __int16 v17 = 1024;
      int v18 = 1280;
      __int16 v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      uint64_t v12 = v6;
LABEL_25:
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_FAULT, v11, buf, 0x36u);
LABEL_26:
      abort();
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447490;
      int v14 = "cti_service_vec_finalize";
      __int16 v15 = 1024;
      *(_DWORD *)int v16 = v5;
      *(_WORD *)&v16[4] = 2048;
      *(void *)&v16[6] = v4;
      *(_WORD *)&v16[14] = 2080;
      *(void *)&v16[16] = "services->services[i]";
      *(_WORD *)&v16[24] = 2080;
      *(void *)&v16[26] = "cti-services.c";
      __int16 v17 = 1024;
      int v18 = 1280;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      uint64_t v4 = *(void *)(a1[2] + 8 * v3);
      int v5 = *(_DWORD *)(v4 + 48);
    }
    *(_DWORD *)(v4 + 48) = v5 - 1;
    if (v5 == 1)
    {
      uint64_t v7 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447234;
        int v14 = "cti_service_vec_finalize";
        __int16 v15 = 2048;
        *(void *)int v16 = v4;
        *(_WORD *)&v16[8] = 2080;
        *(void *)&v16[10] = "services->services[i]";
        *(_WORD *)&v16[18] = 2080;
        *(void *)&v16[20] = "cti-services.c";
        *(_WORD *)&v16[28] = 1024;
        *(_DWORD *)&v16[30] = 1280;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        uint64_t v4 = *(void *)(a1[2] + 8 * v3);
      }
      ++cti_service_finalized;
      int v8 = *(void **)(v4 + 24);
      if (v8) {
        free(v8);
      }
      xpc_object_t v9 = *(void **)(v4 + 16);
      if (v9) {
        free(v9);
      }
      free((void *)v4);
    }
LABEL_17:
    ++v3;
  }
  while (v3 < *a1);
  int v2 = (void *)a1[2];
LABEL_19:
  free(v2);
LABEL_20:
  free(a1);
}

_WORD *cti_service_create_(uint64_t a1, __int16 a2, __int16 a3, __int16 a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int16 a9, int a10)
{
  int v18 = malloc_type_calloc(1uLL, 0x38uLL, 0x1010040270935CAuLL);
  int v19 = v18;
  if (v18)
  {
    *(void *)int v18 = a1;
    v18[4] = a3;
    v18[5] = a4;
    v18[6] = a2;
    *((void *)v18 + 2) = a5;
    *((void *)v18 + 3) = a7;
    *((void *)v18 + 4) = a6;
    *((void *)v18 + 5) = a8;
    v18[7] = a9;
    *((_DWORD *)v18 + 13) = a10;
    size_t v20 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v21 = *((_DWORD *)v19 + 12);
      int v26 = 136447490;
      int v27 = "cti_service_create_";
      __int16 v28 = 1024;
      int v29 = v21;
      __int16 v30 = 2048;
      int v31 = v19;
      __int16 v32 = 2080;
      xpc_object_t v33 = "service";
      __int16 v34 = 2080;
      int v35 = "cti-services.c";
      __int16 v36 = 1024;
      int v37 = 1512;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v26, 0x36u);
    }
    int v22 = *((_DWORD *)v19 + 12);
    if (v22)
    {
      int v23 = v22 + 1;
      *((_DWORD *)v19 + 12) = v22 + 1;
      if (v22 + 1 >= 10001)
      {
        int v24 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          int v26 = 136447490;
          int v27 = "cti_service_create_";
          __int16 v28 = 1024;
          int v29 = v23;
          __int16 v30 = 2048;
          int v31 = v19;
          __int16 v32 = 2080;
          xpc_object_t v33 = "service";
          __int16 v34 = 2080;
          int v35 = "cti-services.c";
          __int16 v36 = 1024;
          int v37 = 1512;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v26, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++cti_service_created;
      *((_DWORD *)v19 + 12) = 1;
    }
  }
  return v19;
}

void cti_internal_service_reply_callback(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v3 = a1;
  uint64_t v4 = *(void (**)(void, void, void))(a1 + 8);
  int v5 = &dnssd_client_states;
  if (a3)
  {
    uint64_t v6 = a3;
    goto LABEL_5;
  }
  xpc_object_t xdict = 0;
  uint64_t v7 = cti_event_or_response_extract(a2, &xdict);
  if (v7)
  {
    uint64_t v6 = v7;
    goto LABEL_5;
  }
  xpc_object_t array = xpc_dictionary_get_array(xdict, "value");
  if (!array)
  {
    int v22 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v23 = *(_DWORD *)(v3 + 80);
      *(_DWORD *)buf = 136446466;
      __int16 v86 = "cti_internal_service_reply_callback";
      __int16 v87 = 1024;
      *(_DWORD *)__int16 v88 = v23;
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] services array not present in Thread:Services event.", buf, 0x12u);
    }
    int v8 = 0;
    goto LABEL_33;
  }
  __int16 v15 = array;
  uint64_t v6 = 4294901757;
  size_t count = xpc_array_get_count(array);
  int v8 = (int *)malloc_type_calloc(1uLL, 0x18uLL, 0x1080040216EE090uLL);
  if (!v8) {
    goto LABEL_6;
  }
  if (count)
  {
    __int16 v17 = malloc_type_calloc(count, 8uLL, 0x2004093837F09uLL);
    *((void *)v8 + 2) = v17;
    if (!v17)
    {
      free(v8);
      goto LABEL_5;
    }
  }
  *(void *)int v8 = count;
  int v18 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v19 = v8[2];
    *(_DWORD *)buf = 136447490;
    __int16 v86 = "cti_service_vec_create_";
    __int16 v87 = 1024;
    *(_DWORD *)__int16 v88 = v19;
    *(_WORD *)&v88[4] = 2048;
    *(void *)&v88[6] = v8;
    *(_WORD *)&v88[14] = 2080;
    *(void *)&v88[16] = "services";
    *(_WORD *)&v88[24] = 2080;
    *(void *)&v88[26] = "cti-services.c";
    __int16 v89 = 1024;
    int v90 = 1370;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  int v20 = v8[2];
  if (v20)
  {
    int v21 = v20 + 1;
    v8[2] = v20 + 1;
    if (v20 + 1 >= 10001)
    {
      uint64_t v12 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        __int16 v86 = "cti_service_vec_create_";
        __int16 v87 = 1024;
        *(_DWORD *)__int16 v88 = v21;
        *(_WORD *)&v88[4] = 2048;
        *(void *)&v88[6] = v8;
        *(_WORD *)&v88[14] = 2080;
        *(void *)&v88[16] = "services";
        *(_WORD *)&v88[24] = 2080;
        *(void *)&v88[26] = "cti-services.c";
        __int16 v89 = 1024;
        int v90 = 1370;
        uint64_t v67 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        goto LABEL_144;
      }
      goto LABEL_145;
    }
    if (!count)
    {
LABEL_33:
      uint64_t v6 = 0;
      goto LABEL_6;
    }
  }
  else
  {
    ++cti_service_vec_created;
    v8[2] = 1;
    if (!count) {
      goto LABEL_33;
    }
  }
  __int16 v68 = v4;
  uint64_t v69 = v3;
  uint64_t v6 = 0;
  size_t v24 = 0;
  size_t v70 = v15;
  size_t v72 = count;
  do
  {
    xpc_object_t value = xpc_array_get_value(v15, v24);
    uint64_t v83 = 0;
    uint64_t v84 = 0;
    if (value)
    {
      int v26 = value;
      size_t v27 = xpc_array_get_count(value);
      if (v27)
      {
        size_t v28 = v27;
        __int16 int64 = 0;
        __int16 v75 = 0;
        int v80 = 0;
        uint64_t v76 = 0;
        uint64_t v77 = 0;
        uint64_t v78 = 0;
        unsigned int v79 = 0;
        u__int16 int64 = 0;
        char v73 = 0;
        char v71 = 0;
        char v29 = 0;
        int v30 = 0;
        size_t v31 = 0;
        while (1)
        {
          xpc_object_t v32 = xpc_array_get_value(v26, v31);
          if (!v32)
          {
            int v5 = &dnssd_client_states;
            uint32_t v49 = global_os_log;
            size_t count = v72;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446722;
              __int16 v86 = "cti_parse_services_array";
              __int16 v87 = 2048;
              *(void *)__int16 v88 = v24;
              *(_WORD *)&v88[8] = 2048;
              *(void *)&v88[10] = v31;
              _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_ERROR, "%{public}s: can't get service_array %zd subdictionary %zd", buf, 0x20u);
            }
            __int16 v15 = v70;
            goto LABEL_119;
          }
          xpc_object_t v33 = v32;
          string = xpc_dictionary_get_string(v32, "key");
          if (!string)
          {
            int v5 = &dnssd_client_states;
            uint64_t v53 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
              goto LABEL_118;
            }
            *(_DWORD *)buf = 136446722;
            __int16 v86 = "cti_parse_services_array";
            __int16 v87 = 2048;
            *(void *)__int16 v88 = v24;
            *(_WORD *)&v88[8] = 2048;
            *(void *)&v88[10] = v31;
            uint64_t v54 = v53;
            v55 = "%{public}s: Invalid services array %zd subdictionary %zd: no key";
            uint32_t v56 = 32;
            goto LABEL_117;
          }
          int v35 = string;
          if (!strcmp(string, "EnterpriseNumber"))
          {
            if (v29)
            {
              int v5 = &dnssd_client_states;
              uint64_t v58 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
                goto LABEL_118;
              }
              *(_DWORD *)buf = 136446466;
              __int16 v86 = "cti_parse_services_array";
              __int16 v87 = 2048;
              *(void *)__int16 v88 = v24;
              uint64_t v54 = v58;
              v55 = "%{public}s: services array %zd: Enterprise number appears twice.";
              goto LABEL_116;
            }
            u__int16 int64 = xpc_dictionary_get_uint64(v33, "value");
            char v29 = 1;
          }
          else if (!strcmp(v35, "Origin"))
          {
            if ((v78 & 0x100000000) != 0)
            {
              int v5 = &dnssd_client_states;
              uint64_t v59 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
                goto LABEL_118;
              }
              *(_DWORD *)buf = 136446466;
              __int16 v86 = "cti_parse_services_array";
              __int16 v87 = 2048;
              *(void *)__int16 v88 = v24;
              uint64_t v54 = v59;
              v55 = "%{public}s: Services array %zd: Origin appears twice.";
              goto LABEL_116;
            }
            int v37 = xpc_dictionary_get_string(v33, "value");
            if (!v37)
            {
              int v5 = &dnssd_client_states;
              uint64_t v60 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
                goto LABEL_118;
              }
              *(_DWORD *)buf = 136446466;
              __int16 v86 = "cti_parse_services_array";
              __int16 v87 = 2048;
              *(void *)__int16 v88 = v24;
              uint64_t v54 = v60;
              v55 = "%{public}s: Unable to get origin string from services array %zd";
              goto LABEL_116;
            }
            int v38 = v37;
            if (strcmp(v37, "user"))
            {
              if (strcmp(v38, "ncp"))
              {
                int v5 = &dnssd_client_states;
                uint64_t v62 = global_os_log;
                if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_118;
                }
                *(_DWORD *)buf = 136446466;
                __int16 v86 = "cti_parse_services_array";
                __int16 v87 = 2082;
                *(void *)__int16 v88 = v38;
                uint64_t v54 = v62;
                v55 = "%{public}s: unknown origin %{public}s";
                goto LABEL_116;
              }
              v80 |= 2u;
            }
            BYTE4(v78) = 1;
          }
          else if (!strcmp(v35, "ServerData"))
          {
            if (v78)
            {
              int v5 = &dnssd_client_states;
              uint64_t v61 = global_os_log;
              __int16 v15 = v70;
              size_t count = v72;
              int v41 = v77;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
                goto LABEL_120;
              }
              *(_DWORD *)buf = 136446466;
              __int16 v86 = "cti_parse_services_array";
              __int16 v87 = 2048;
              *(void *)__int16 v88 = v24;
              __int16 v46 = v61;
              os_log_type_t v47 = OS_LOG_TYPE_ERROR;
              int v48 = "%{public}s: Services array %zd: Server data appears twice.";
LABEL_103:
              _os_log_impl((void *)&_mh_execute_header, v46, v47, v48, buf, 0x16u);
              goto LABEL_120;
            }
            xpc_object_t v39 = xpc_dictionary_get_array(v33, "value");
            unsigned int v79 = cti_array_to_bytes(v39, (size_t *)&v84, (uint64_t)"Server data");
            if (!v79)
            {
              unsigned int v79 = 0;
              int v5 = &dnssd_client_states;
              goto LABEL_118;
            }
            LOBYTE(v78) = 1;
          }
          else if (!strcmp(v35, "ServiceData"))
          {
            if (v76)
            {
              int v5 = &dnssd_client_states;
              __int16 v63 = global_os_log;
              __int16 v15 = v70;
              size_t count = v72;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446466;
                __int16 v86 = "cti_parse_services_array";
                __int16 v87 = 2048;
                *(void *)__int16 v88 = v24;
                _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_ERROR, "%{public}s: Services array %zd: Service data appears twice.", buf, 0x16u);
              }
              goto LABEL_119;
            }
            xpc_object_t v40 = xpc_dictionary_get_array(v33, "value");
            uint64_t v77 = cti_array_to_bytes(v40, (size_t *)&v83, (uint64_t)"Service data");
            if (!v77)
            {
              int v41 = 0;
              int v5 = &dnssd_client_states;
              __int16 v15 = v70;
              size_t count = v72;
              goto LABEL_120;
            }
            LOBYTE(v76) = 1;
          }
          else if (!strcmp(v35, "Stable"))
          {
            if (v73)
            {
              int v5 = &dnssd_client_states;
              uint64_t v64 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
                goto LABEL_118;
              }
              goto LABEL_115;
            }
            v80 |= xpc_dictionary_get_BOOL(v33, "value");
            char v73 = 1;
          }
          else if (!strcmp(v35, "RLOC16"))
          {
            if (v71)
            {
              int v5 = &dnssd_client_states;
              uint64_t v64 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
                goto LABEL_118;
              }
LABEL_115:
              *(_DWORD *)buf = 136446466;
              __int16 v86 = "cti_parse_services_array";
              __int16 v87 = 2048;
              *(void *)__int16 v88 = v24;
              uint64_t v54 = v64;
              v55 = "%{public}s: Services array %zd: Stable state appears twice.";
LABEL_116:
              uint32_t v56 = 22;
LABEL_117:
              _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, v55, buf, v56);
              goto LABEL_118;
            }
            __int16 v75 = xpc_dictionary_get_uint64(v33, "value");
            char v71 = 1;
          }
          else
          {
            if (strcmp(v35, "ServiceId"))
            {
              __int16 v36 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136446978;
                __int16 v86 = "cti_parse_services_array";
                __int16 v87 = 2048;
                *(void *)__int16 v88 = v24;
                *(_WORD *)&v88[8] = 2048;
                *(void *)&v88[10] = v31;
                *(_WORD *)&v88[18] = 2082;
                *(void *)&v88[20] = v35;
                _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%{public}s: Unknown key in service array %zd subdictionary %zd: %{public}s", buf, 0x2Au);
              }
              goto LABEL_71;
            }
            if ((v76 & 0x100000000) != 0)
            {
              int v5 = &dnssd_client_states;
              uint64_t v64 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
                goto LABEL_115;
              }
LABEL_118:
              __int16 v15 = v70;
              size_t count = v72;
LABEL_119:
              int v41 = v77;
              goto LABEL_120;
            }
            __int16 int64 = xpc_dictionary_get_int64(v33, "value");
            BYTE4(v76) = 1;
          }
          ++v30;
LABEL_71:
          if (v28 == ++v31)
          {
            int v5 = &dnssd_client_states;
            __int16 v15 = v70;
            size_t count = v72;
            int v41 = v77;
            if (v30 != 7) {
              goto LABEL_77;
            }
            goto LABEL_81;
          }
        }
      }
      __int16 int64 = 0;
      __int16 v75 = 0;
      int v80 = 0;
      int v41 = 0;
      unsigned int v79 = 0;
      u__int16 int64 = 0;
      BYTE4(v76) = 0;
      int v30 = 0;
      size_t count = v72;
LABEL_77:
      int v43 = *((void *)v5 + 306);
      if (os_log_type_enabled(v43, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446978;
        __int16 v86 = "cti_parse_services_array";
        __int16 v87 = 1024;
        *(_DWORD *)__int16 v88 = 7;
        *(_WORD *)&v88[4] = 2048;
        *(void *)&v88[6] = v24;
        *(_WORD *)&v88[14] = 1024;
        *(_DWORD *)&v88[16] = v30;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "%{public}s: expecting %d sub-dictionaries to service array %zd, but got %d.", buf, 0x22u);
      }
      if (v30 < 6 || ((v30 == 6) & BYTE4(v76)) != 0) {
        goto LABEL_120;
      }
LABEL_81:
      uint64_t v44 = v83;
      if (uint64 == 44970)
      {
        if ((unint64_t)(v83 - 3) <= 0xFFFFFFFFFFFFFFFDLL)
        {
          uint64_t v45 = *((void *)v5 + 306);
          if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446466;
            __int16 v86 = "cti_parse_services_array";
            __int16 v87 = 2048;
            *(void *)__int16 v88 = v44;
            __int16 v46 = v45;
            os_log_type_t v47 = OS_LOG_TYPE_DEFAULT;
            int v48 = "%{public}s: Invalid service data: length = %zd";
            goto LABEL_103;
          }
LABEL_120:
          if (v6) {
            uint64_t v6 = v6;
          }
          else {
            uint64_t v6 = 4294901759;
          }
          goto LABEL_123;
        }
        int v51 = *v41;
        int v52 = 1;
        uint64_t v50 = cti_service_create_(44970, v75, *v41, 1, (uint64_t)v41, v83, (uint64_t)v79, v84, int64, v80);
        if (v50)
        {
LABEL_89:
          *(void *)(*((void *)v8 + 2) + 8 * v24) = v50;
          goto LABEL_127;
        }
      }
      else
      {
        uint64_t v50 = cti_service_create_(uint64, v75, 0, 0, (uint64_t)v41, v83, (uint64_t)v79, v84, int64, v80);
        int v51 = 0;
        int v52 = 0;
        if (v50) {
          goto LABEL_89;
        }
      }
      size_t v57 = *((void *)v5 + 306);
      if (os_log_type_enabled(v57, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446978;
        __int16 v86 = "cti_parse_services_array";
        __int16 v87 = 2048;
        *(void *)__int16 v88 = uint64;
        *(_WORD *)&v88[8] = 1024;
        *(_DWORD *)&v88[10] = v51;
        *(_WORD *)&v88[14] = 1024;
        *(_DWORD *)&v88[16] = v52;
        _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_ERROR, "%{public}s: Unable to store service %lld %d %d: out of memory.", buf, 0x22u);
      }
LABEL_123:
      if (v79) {
        free(v79);
      }
      if (v41) {
        free(v41);
      }
      goto LABEL_127;
    }
    uint32_t v42 = *((void *)v5 + 306);
    if (os_log_type_enabled(v42, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      __int16 v86 = "cti_parse_services_array";
      __int16 v87 = 2048;
      *(void *)__int16 v88 = v24;
      _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_ERROR, "%{public}s: Unable to get service array %zd", buf, 0x16u);
    }
LABEL_127:
    ++v24;
  }
  while (v24 != count);
  if (v6)
  {
    int v65 = v8[2];
    uint64_t v3 = v69;
    if (v65)
    {
      uint64_t v12 = *((void *)v5 + 306);
      if (v65 < 10001)
      {
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447490;
          __int16 v86 = "cti_parse_services_array";
          __int16 v87 = 1024;
          *(_DWORD *)__int16 v88 = v65;
          *(_WORD *)&v88[4] = 2048;
          *(void *)&v88[6] = v8;
          *(_WORD *)&v88[14] = 2080;
          *(void *)&v88[16] = "service_vec";
          *(_WORD *)&v88[24] = 2080;
          *(void *)&v88[26] = "cti-services.c";
          __int16 v89 = 1024;
          int v90 = 1539;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          int v65 = v8[2];
        }
        v8[2] = v65 - 1;
        if (v65 != 1)
        {
          int v8 = 0;
          uint64_t v4 = v68;
          goto LABEL_6;
        }
        uint64_t v66 = *((void *)v5 + 306);
        uint64_t v4 = v68;
        if (os_log_type_enabled(v66, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          __int16 v86 = "cti_parse_services_array";
          __int16 v87 = 2048;
          *(void *)__int16 v88 = v8;
          *(_WORD *)&v88[8] = 2080;
          *(void *)&v88[10] = "service_vec";
          *(_WORD *)&v88[18] = 2080;
          *(void *)&v88[20] = "cti-services.c";
          *(_WORD *)&v88[28] = 1024;
          *(_DWORD *)&v88[30] = 1539;
          _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        }
        ++cti_service_vec_finalized;
        cti_service_vec_finalize((unint64_t *)v8);
LABEL_5:
        int v8 = 0;
        goto LABEL_6;
      }
      if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        __int16 v86 = "cti_parse_services_array";
        __int16 v87 = 1024;
        *(_DWORD *)__int16 v88 = v65;
        *(_WORD *)&v88[4] = 2048;
        *(void *)&v88[6] = v8;
        *(_WORD *)&v88[14] = 2080;
        *(void *)&v88[16] = "service_vec";
        *(_WORD *)&v88[24] = 2080;
        *(void *)&v88[26] = "cti-services.c";
        __int16 v89 = 1024;
        int v90 = 1539;
        uint64_t v67 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_144:
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_FAULT, v67, buf, 0x36u);
      }
    }
    else
    {
      uint64_t v12 = *((void *)v5 + 306);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        __int16 v86 = "cti_parse_services_array";
        __int16 v87 = 1024;
        *(_DWORD *)__int16 v88 = 0;
        *(_WORD *)&v88[4] = 2048;
        *(void *)&v88[6] = v8;
        *(_WORD *)&v88[14] = 2080;
        *(void *)&v88[16] = "service_vec";
        *(_WORD *)&v88[24] = 2080;
        *(void *)&v88[26] = "cti-services.c";
        __int16 v89 = 1024;
        int v90 = 1539;
        uint64_t v67 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_144;
      }
    }
LABEL_145:
    abort();
  }
  uint64_t v4 = v68;
  uint64_t v3 = v69;
LABEL_6:
  if (v4)
  {
    xpc_object_t v9 = *((void *)v5 + 306);
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = *(_DWORD *)(v3 + 80);
      *(_DWORD *)buf = 136446722;
      __int16 v86 = "cti_internal_service_reply_callback";
      __int16 v87 = 1024;
      *(_DWORD *)__int16 v88 = v10;
      *(_WORD *)&v88[4] = 2048;
      *(void *)&v88[6] = v3;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] calling callback for %p", buf, 0x1Cu);
    }
    v4(*(void *)(v3 + 64), v8, v6);
  }
  if (v8)
  {
    int v11 = v8[2];
    if (!v11)
    {
      uint64_t v12 = *((void *)v5 + 306);
      if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        __int16 v86 = "cti_internal_service_reply_callback";
        __int16 v87 = 1024;
        *(_DWORD *)__int16 v88 = 0;
        *(_WORD *)&v88[4] = 2048;
        *(void *)&v88[6] = v8;
        *(_WORD *)&v88[14] = 2080;
        *(void *)&v88[16] = "vec";
        *(_WORD *)&v88[24] = 2080;
        *(void *)&v88[26] = "cti-services.c";
        __int16 v89 = 1024;
        int v90 = 1568;
        uint64_t v67 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_144;
      }
      goto LABEL_145;
    }
    uint64_t v12 = *((void *)v5 + 306);
    if (v11 >= 10001)
    {
      if (os_log_type_enabled(v12, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        __int16 v86 = "cti_internal_service_reply_callback";
        __int16 v87 = 1024;
        *(_DWORD *)__int16 v88 = v11;
        *(_WORD *)&v88[4] = 2048;
        *(void *)&v88[6] = v8;
        *(_WORD *)&v88[14] = 2080;
        *(void *)&v88[16] = "vec";
        *(_WORD *)&v88[24] = 2080;
        *(void *)&v88[26] = "cti-services.c";
        __int16 v89 = 1024;
        int v90 = 1568;
        uint64_t v67 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_144;
      }
      goto LABEL_145;
    }
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447490;
      __int16 v86 = "cti_internal_service_reply_callback";
      __int16 v87 = 1024;
      *(_DWORD *)__int16 v88 = v11;
      *(_WORD *)&v88[4] = 2048;
      *(void *)&v88[6] = v8;
      *(_WORD *)&v88[14] = 2080;
      *(void *)&v88[16] = "vec";
      *(_WORD *)&v88[24] = 2080;
      *(void *)&v88[26] = "cti-services.c";
      __int16 v89 = 1024;
      int v90 = 1568;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      int v11 = v8[2];
    }
    v8[2] = v11 - 1;
    if (v11 == 1)
    {
      int v13 = *((void *)v5 + 306);
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447234;
        __int16 v86 = "cti_internal_service_reply_callback";
        __int16 v87 = 2048;
        *(void *)__int16 v88 = v8;
        *(_WORD *)&v88[8] = 2080;
        *(void *)&v88[10] = "vec";
        *(_WORD *)&v88[18] = 2080;
        *(void *)&v88[20] = "cti-services.c";
        *(_WORD *)&v88[28] = 1024;
        *(_DWORD *)&v88[30] = 1568;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
      }
      ++cti_service_vec_finalized;
      cti_service_vec_finalize((unint64_t *)v8);
    }
  }
}

unsigned char *cti_array_to_bytes(void *a1, size_t *a2, uint64_t a3)
{
  size_t count = xpc_array_get_count(a1);
  uint64_t v7 = malloc_type_malloc(count, 0x88ECC842uLL);
  if (v7)
  {
    if (count)
    {
      for (size_t i = 0; i != count; ++i)
        v7[i] = xpc_array_get_uint64(a1, i);
    }
    *a2 = count;
  }
  else
  {
    xpc_object_t v9 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      int v11 = 136446466;
      uint64_t v12 = "cti_array_to_bytes";
      __int16 v13 = 2082;
      uint64_t v14 = a3;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%{public}s: %{public}s: no memory for return buffer", (uint8_t *)&v11, 0x16u);
    }
  }
  return v7;
}

void cti_internal_rloc16_reply_callback(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v4 = *(void (**)(void, void, uint64_t))(a1 + 8);
  xpc_object_t xdict = 0;
  if (a3)
  {
    uint64_t v5 = a3;
LABEL_4:
    unsigned __int16 v6 = 0;
    goto LABEL_5;
  }
  uint64_t v5 = cti_event_or_response_extract(a2, &xdict);
  if (v5) {
    goto LABEL_4;
  }
  string = xpc_dictionary_get_string(xdict, "response");
  *(void *)buf = "\n";
  unsigned __int16 v6 = strtol(string + 2, (char **)buf, 16);
LABEL_5:
  uint64_t v7 = global_os_log;
  BOOL v8 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (v4)
  {
    if (v8)
    {
      int v9 = *(_DWORD *)(a1 + 80);
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "cti_internal_rloc16_reply_callback";
      __int16 v14 = 1024;
      int v15 = v9;
      __int16 v16 = 2048;
      uint64_t v17 = a1;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] calling callback for %p", buf, 0x1Cu);
    }
    v4(*(void *)(a1 + 64), v6, v5);
  }
  else if (v8)
  {
    int v10 = *(_DWORD *)(a1 + 80);
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "cti_internal_rloc16_reply_callback";
    __int16 v14 = 1024;
    int v15 = v10;
    __int16 v16 = 2048;
    uint64_t v17 = a1;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] not calling callback for %p", buf, 0x1Cu);
  }
}

void cti_internal_wed_reply_callback(uint64_t a1, void *a2, uint64_t a3)
{
  uint64_t v4 = *(void (**)(void, const char *, const char *, uint64_t, uint64_t))(a1 + 8);
  if (a3)
  {
    if (v4)
    {
      uint64_t v5 = a3;
      unsigned __int16 v6 = 0;
      uint64_t v7 = 0;
      goto LABEL_9;
    }
    return;
  }
  xpc_object_t xdict = 0;
  uint64_t v5 = cti_event_or_response_extract(a2, &xdict);
  if (v5) {
    goto LABEL_5;
  }
  xpc_object_t array = xpc_dictionary_get_array(xdict, "value");
  if (!array)
  {
    uint32_t v25 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v26 = *(_DWORD *)(a1 + 80);
      *(_DWORD *)buf = 136446466;
      __int16 v36 = "cti_internal_wed_reply_callback";
      __int16 v37 = 1024;
      *(_DWORD *)int v38 = v26;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] wed status array not present in wed status event.", buf, 0x12u);
    }
    goto LABEL_5;
  }
  __int16 v14 = array;
  size_t count = xpc_array_get_count(array);
  if (!count)
  {
LABEL_5:
    unsigned __int16 v6 = 0;
    uint64_t v7 = 0;
    LOBYTE(v8) = 1;
    goto LABEL_6;
  }
  size_t v15 = 0;
  uint64_t v7 = 0;
  unsigned __int16 v6 = 0;
  int v8 = 1;
  while (1)
  {
    xpc_object_t value = xpc_array_get_value(v14, v15);
    if (xpc_get_type(value) != (xpc_type_t)&_xpc_type_dictionary)
    {
      uint64_t v27 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
        goto LABEL_6;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v36 = "cti_internal_wed_reply_callback";
      size_t v28 = "%{public}s: non-dictionary element of value array";
LABEL_48:
      char v29 = v27;
      uint32_t v30 = 12;
LABEL_49:
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, v28, buf, v30);
      goto LABEL_6;
    }
    string = xpc_dictionary_get_string(value, "key");
    if (!string)
    {
      uint64_t v27 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
        goto LABEL_6;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v36 = "cti_internal_wed_reply_callback";
      size_t v28 = "%{public}s: no key in value array";
      goto LABEL_48;
    }
    int v18 = string;
    int v19 = xpc_dictionary_get_string(value, "value");
    if (strcmp(v18, "extendedMACAddress")) {
      break;
    }
    unsigned __int16 v6 = v19;
LABEL_39:
    if (count == ++v15) {
      goto LABEL_6;
    }
  }
  if (!strcmp(v18, "mleid"))
  {
    uint64_t v7 = v19;
    goto LABEL_39;
  }
  if (strcmp(v18, "status"))
  {
    int v32 = v8;
    uint64_t v20 = global_os_log;
    BOOL v21 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
    if (v19)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446979;
        __int16 v36 = "cti_internal_wed_reply_callback";
        __int16 v37 = 2082;
        *(void *)int v38 = v18;
        *(_WORD *)&v38[8] = 2160;
        *(void *)&v38[10] = 1752392040;
        __int16 v39 = 2081;
        xpc_object_t v40 = v19;
        int v22 = v20;
        int v23 = "%{public}s: unknown key %{public}s with value %{private, mask.hash}s";
        uint32_t v24 = 42;
LABEL_37:
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, v23, buf, v24);
      }
    }
    else if (v21)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v36 = "cti_internal_wed_reply_callback";
      __int16 v37 = 2082;
      *(void *)int v38 = v18;
      int v22 = v20;
      int v23 = "%{public}s: unknown key in response: %{public}s";
      uint32_t v24 = 22;
      goto LABEL_37;
    }
    int v8 = v32;
    goto LABEL_39;
  }
  if (!strcmp(v19, "wed_present"))
  {
    int v8 = 1;
    goto LABEL_39;
  }
  if (!strcmp(v19, "wed_removed"))
  {
    int v8 = 0;
    goto LABEL_39;
  }
  uint64_t v31 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446466;
    __int16 v36 = "cti_internal_wed_reply_callback";
    __int16 v37 = 2082;
    *(void *)int v38 = v19;
    size_t v28 = "%{public}s: unknown wed status %{public}s";
    char v29 = v31;
    uint32_t v30 = 22;
    goto LABEL_49;
  }
LABEL_6:
  if (v4)
  {
    if ((v8 & 1) == 0)
    {
      uint64_t v9 = 0;
      goto LABEL_15;
    }
LABEL_9:
    if (v7) {
      BOOL v10 = v6 == 0;
    }
    else {
      BOOL v10 = 1;
    }
    uint64_t v9 = !v10;
LABEL_15:
    int v11 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = *(_DWORD *)(a1 + 80);
      *(_DWORD *)buf = 136446722;
      __int16 v36 = "cti_internal_wed_reply_callback";
      __int16 v37 = 1024;
      *(_DWORD *)int v38 = v12;
      *(_WORD *)&v38[4] = 2048;
      *(void *)&v38[6] = a1;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] calling callback for %p", buf, 0x1Cu);
    }
    v4(*(void *)(a1 + 64), v6, v7, v9, v5);
  }
}

uint64_t cti_add_ml_eid_mapping_(uint64_t a1, const void *a2, const void *a3, const char *a4)
{
  xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v8, "interface", "org.wpantund.v1");
  xpc_dictionary_set_string(v8, "path", "/org/wpantund/utun2");
  xpc_dictionary_set_string(v8, "method", "UpdateAccessoryData");
  inet_ntop(30, a2, string, 0x2Eu);
  xpc_dictionary_set_string(v8, "ipaddr_add", string);
  inet_ntop(30, a3, string, 0x2Eu);
  xpc_dictionary_set_string(v8, "ipaddr_lookup", string);
  xpc_dictionary_set_string(v8, "host_info", a4);
  uint64_t v9 = setup_for_command(0, (uint64_t)"add_mle_mapping", 0, 0, v8, a1, (uint64_t)srp_ml_eid_mapping_callback, (uint64_t)cti_internal_reply_callback, 0, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 3618);
  xpc_release(v8);
  return v9;
}

void cti_events_discontinue(uint64_t a1)
{
  int v2 = *(_xpc_connection_s **)(a1 + 16);
  if (v2)
  {
    uint64_t v3 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = *(_DWORD *)(a1 + 80);
      int v5 = 136446722;
      unsigned __int16 v6 = "cti_events_discontinue";
      __int16 v7 = 1024;
      int v8 = v4;
      __int16 v9 = 2048;
      BOOL v10 = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: [CX%d] canceling connection %p", (uint8_t *)&v5, 0x1Cu);
      int v2 = *(_xpc_connection_s **)(a1 + 16);
    }
    xpc_connection_cancel(v2);
  }
  cti_connection_release_((void *)a1, 2444);
}

uint64_t state_machine_next_state(uint64_t a1, unsigned int a2)
{
  do
  {
    uint64_t result = state_machine_state_get((uint64_t *)a1, a2);
    if (!result)
    {
      unsigned __int16 v6 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        uint64_t v7 = *(void *)(a1 + 32);
        uint64_t v8 = *(void *)a1;
        int v9 = 136447235;
        BOOL v10 = "state_machine_next_state";
        __int16 v11 = 2082;
        uint64_t v12 = v7;
        __int16 v13 = 2160;
        uint64_t v14 = 1752392040;
        __int16 v15 = 2081;
        uint64_t v16 = v8;
        __int16 v17 = 1024;
        unsigned int v18 = a2;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "%{public}s: %{public}s/%{private, mask.hash}s next state is invalid: %d", (uint8_t *)&v9, 0x30u);
      }
      abort();
    }
    *(_DWORD *)(a1 + 48) = a2;
    *(void *)(a1 + 16) = *(void *)(result + 8);
    int v5 = *(uint64_t (**)(uint64_t, void))(result + 16);
    if (v5)
    {
      uint64_t result = v5(a1, 0);
      a2 = result;
    }
  }
  while (a2);
  return result;
}

uint64_t state_machine_state_get(uint64_t *a1, unsigned int a2)
{
  unint64_t v2 = a1[5];
  if (!*((unsigned char *)a1 + 56))
  {
    if (v2)
    {
      uint64_t v3 = 0;
      int v4 = (int *)a1[3];
      int v5 = v4;
      while (1)
      {
        int v6 = *v5;
        v5 += 6;
        if (v3 != v6) {
          break;
        }
        if (v2 == ++v3) {
          goto LABEL_6;
        }
      }
      int v9 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        uint64_t v10 = a1[4];
        uint64_t v11 = *a1;
        uint64_t v12 = *(void *)&v4[6 * v3 + 2];
        int v13 = 136447491;
        uint64_t v14 = "state_machine_state_get";
        __int16 v15 = 2082;
        uint64_t v16 = v10;
        __int16 v17 = 2160;
        uint64_t v18 = 1752392040;
        __int16 v19 = 2081;
        uint64_t v20 = v11;
        __int16 v21 = 2048;
        uint64_t v22 = v3;
        __int16 v23 = 2082;
        uint64_t v24 = v12;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%{public}s: %{public}s/%{private, mask.hash}s state %zu doesn't match %{public}s", (uint8_t *)&v13, 0x3Eu);
      }
LABEL_11:
      abort();
    }
LABEL_6:
    *((unsigned char *)a1 + 56) = 1;
  }
  if (v2 <= a2) {
    goto LABEL_11;
  }
  return a1[3] + 24 * a2;
}

void state_machine_event_deliver(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = state_machine_state_get((uint64_t *)a1, *(_DWORD *)(a1 + 48));
  if (!v4)
  {
    int v13 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      uint64_t v14 = *(void *)(a1 + 32);
      uint64_t v15 = *(void *)a1;
      uint64_t v16 = *(void *)(a2 + 8);
      int v17 = *(_DWORD *)(a1 + 48);
      int v18 = 136447491;
      __int16 v19 = "state_machine_event_deliver";
      __int16 v20 = 2082;
      uint64_t v21 = v14;
      __int16 v22 = 2160;
      uint64_t v23 = 1752392040;
      __int16 v24 = 2081;
      uint64_t v25 = v15;
      __int16 v26 = 2082;
      uint64_t v27 = v16;
      __int16 v28 = 1024;
      LODWORD(v29) = v17;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%{public}s: %{public}s/%{private, mask.hash}s: event %{public}s received in invalid state %d", (uint8_t *)&v18, 0x3Au);
    }
    abort();
  }
  uint64_t v5 = v4;
  int v6 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 16);
  if (v6)
  {
    unsigned int v7 = v6(a1, a2);
    if (v7)
    {
      state_machine_next_state(a1, v7);
    }
  }
  else
  {
    uint64_t v8 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      uint64_t v9 = *(void *)(a1 + 32);
      uint64_t v10 = *(void *)a1;
      uint64_t v11 = *(void *)(a2 + 8);
      uint64_t v12 = *(void *)(v5 + 8);
      int v18 = 136447491;
      __int16 v19 = "state_machine_event_deliver";
      __int16 v20 = 2082;
      uint64_t v21 = v9;
      __int16 v22 = 2160;
      uint64_t v23 = 1752392040;
      __int16 v24 = 2081;
      uint64_t v25 = v10;
      __int16 v26 = 2082;
      uint64_t v27 = v11;
      __int16 v28 = 2082;
      uint64_t v29 = v12;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "%{public}s: %{public}s/%{private, mask.hash}s: event %{public}s received in state %{public}s with NULL action", (uint8_t *)&v18, 0x3Eu);
    }
  }
}

_DWORD *state_machine_event_create(int a1)
{
  if ((state_machine_event_configuration_get_once & 1) == 0)
  {
    uint64_t v2 = 0;
    uint64_t v3 = state_machine_event_configurations;
    while (1)
    {
      int v4 = *v3;
      v3 += 4;
      if (v2 != v4) {
        break;
      }
      if (++v2 == 21)
      {
        state_machine_event_configuration_get_once = 1;
        goto LABEL_6;
      }
    }
    uint64_t v15 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      uint64_t v16 = *(_DWORD **)&state_machine_event_configurations[4 * v2 + 2];
      *(_DWORD *)buf = 136446722;
      __int16 v20 = "state_machine_event_configuration_get";
      __int16 v21 = 1024;
      int v22 = v2;
      __int16 v23 = 2082;
      __int16 v24 = v16;
      uint64_t v10 = "%{public}s: event %d doesn't match %{public}s";
      uint64_t v11 = v15;
      os_log_type_t v12 = OS_LOG_TYPE_ERROR;
      uint32_t v13 = 28;
LABEL_17:
      _os_log_impl((void *)&_mh_execute_header, v11, v12, v10, buf, v13);
      goto LABEL_18;
    }
    goto LABEL_18;
  }
LABEL_6:
  if (!&state_machine_event_configurations[4 * a1])
  {
    uint64_t v17 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      __int16 v20 = "state_machine_event_create";
      __int16 v21 = 1024;
      int v22 = a1;
      uint64_t v10 = "%{public}s: invalid event type %d";
      uint64_t v11 = v17;
      os_log_type_t v12 = OS_LOG_TYPE_ERROR;
      uint32_t v13 = 18;
      goto LABEL_17;
    }
LABEL_18:
    abort();
  }
  uint64_t v5 = malloc_type_calloc(1uLL, 0x28uLL, 0x10F0040AC697359uLL);
  v5[4] = a1;
  *((void *)v5 + 1) = *(void *)&state_machine_event_configurations[4 * a1 + 2];
  int v6 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = *v5;
    *(_DWORD *)buf = 136447490;
    __int16 v20 = "state_machine_event_create";
    __int16 v21 = 1024;
    int v22 = v7;
    __int16 v23 = 2048;
    __int16 v24 = v5;
    __int16 v25 = 2080;
    __int16 v26 = "event";
    __int16 v27 = 2080;
    __int16 v28 = "state-machine.c";
    __int16 v29 = 1024;
    int v30 = 211;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  if (*v5)
  {
    int v8 = *v5 + 1;
    _DWORD *v5 = v8;
    if (v8 >= 10001)
    {
      int v18 = v8;
      uint64_t v9 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136447490;
      __int16 v20 = "state_machine_event_create";
      __int16 v21 = 1024;
      int v22 = v18;
      __int16 v23 = 2048;
      __int16 v24 = v5;
      __int16 v25 = 2080;
      __int16 v26 = "event";
      __int16 v27 = 2080;
      __int16 v28 = "state-machine.c";
      __int16 v29 = 1024;
      int v30 = 211;
      uint64_t v10 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      uint64_t v11 = v9;
      os_log_type_t v12 = OS_LOG_TYPE_FAULT;
      uint32_t v13 = 54;
      goto LABEL_17;
    }
  }
  else
  {
    ++state_machine_event_created;
    _DWORD *v5 = 1;
  }
  *((void *)v5 + 4) = 0;
  return v5;
}

uint64_t state_machine_header_setup(uint64_t a1, uint64_t a2, char *__s1, int a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10 = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  uint64_t v11 = state_machine_types;
  while (1)
  {
    int v12 = *v11;
    v11 += 4;
    if (v12 == a4) {
      break;
    }
    if (++v10 == 4) {
      return 0;
    }
  }
  *(void *)(a1 + 32) = *(void *)&state_machine_types[4 * v10 + 2];
  *(void *)(a1 + 8) = a2;
  uint64_t result = (uint64_t)strdup(__s1);
  *(void *)a1 = result;
  if (result)
  {
    *(_DWORD *)(a1 + 52) = a4;
    *(void *)(a1 + 24) = a5;
    uint64_t result = 1;
    *(void *)(a1 + 40) = a6;
  }
  return result;
}

void state_machine_cancel(uint64_t *a1)
{
  uint64_t v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *a1;
    int v4 = 136446466;
    uint64_t v5 = "state_machine_cancel";
    __int16 v6 = 2082;
    uint64_t v7 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: canceling %{public}s", (uint8_t *)&v4, 0x16u);
  }
  *((_DWORD *)a1 + 12) = 0;
}

char *dns_name_to_wire_(char *result, uint64_t *a2, char *__s, int a4)
{
  if (*((_DWORD *)a2 + 12) <= 1u)
  {
    int v6 = 0;
    int v7 = 0;
    unint64_t v8 = a2[1];
    uint64_t v20 = *a2;
    unint64_t v21 = v8;
    int v22 = result;
    while (1)
    {
      uint64_t v9 = a2[2];
      uint64_t result = strchr(__s, 46);
      if (result) {
        break;
      }
      uint64_t result = (char *)strlen(__s);
      uint64_t v10 = 0;
      if (result)
      {
        uint64_t result = &result[(void)__s];
LABEL_8:
        int v11 = 0;
        if (result > __s)
        {
          int v12 = __s;
          do
          {
            if (*v12 != 92 || v12 + 4 > result) {
              uint64_t v14 = 0;
            }
            else {
              uint64_t v14 = 3;
            }
            ++v11;
            v12 += v14 + 1;
          }
          while (v12 < result);
        }
        if ((uint64_t)(v9 + ~v8) <= v11)
        {
          *((_DWORD *)a2 + 12) |= 1u;
          int v19 = 110;
          goto LABEL_34;
        }
        if (result - __s > 63)
        {
          int v19 = 126;
          goto LABEL_34;
        }
        *(unsigned char *)unint64_t v8 = v11;
        if (result > __s)
        {
          uint64_t v15 = (unsigned char *)(v8 + 1);
          uint64_t v16 = __s;
          while (1)
          {
            int v17 = *v16;
            if (v17 == 92)
            {
              if (v16 + 4 > result) {
                goto LABEL_33;
              }
              int v18 = v16[3];
              v16 += 3;
              int v17 = 100 * *(v16 - 2) + 10 * *(v16 - 1) + v18;
              if (v17 > 5582) {
                goto LABEL_33;
              }
              LOBYTE(v17) = v17 + 48;
            }
            *v15++ = v17;
            if (++v16 >= result) {
              goto LABEL_28;
            }
          }
        }
        goto LABEL_28;
      }
      *(unsigned char *)unint64_t v8 = 0;
LABEL_28:
      unint64_t v8 = a2[1];
      if (*(unsigned char *)v8)
      {
        ++v6;
        v7 += *(unsigned __int8 *)v8 + 1;
        v8 += *(unsigned __int8 *)v8 + 1;
        a2[1] = v8;
        __s = v10;
      }
      if (!v10)
      {
        if (v7 < 256)
        {
          if (v22)
          {
            *(void *)int v22 = 0;
            *((void *)v22 + 1) = v20;
            *((void *)v22 + 2) = v21;
            *((_DWORD *)v22 + 6) = v6;
            *((_DWORD *)v22 + 7) = v7;
          }
        }
        else
        {
          *((_DWORD *)a2 + 12) = a2[6] & 1 | 0x7E;
          *((_DWORD *)a2 + 10) = a4;
        }
        return result;
      }
    }
    if (result == __s)
    {
LABEL_33:
      int v19 = 44;
LABEL_34:
      *((_DWORD *)a2 + 12) = a2[6] & 1 | v19;
      *((_DWORD *)a2 + 10) = a4;
      return result;
    }
    uint64_t v10 = result + 1;
    goto LABEL_8;
  }
  return result;
}

double dns_full_name_to_wire_(_OWORD *a1, uint64_t a2, char *a3, int a4)
{
  if (*(_DWORD *)(a2 + 48) <= 1u)
  {
    long long v10 = 0u;
    long long v11 = 0u;
    dns_name_to_wire_((char *)&v10, (uint64_t *)a2, a3, 180);
    if (*(_DWORD *)(a2 + 48) <= 1u)
    {
      unint64_t v8 = *(unsigned char **)(a2 + 8);
      if ((unint64_t)(v8 + 1) >= *(void *)(a2 + 16))
      {
        *(_DWORD *)(a2 + 48) = 111;
        goto LABEL_7;
      }
      *(void *)(a2 + 8) = v8 + 1;
      *unint64_t v8 = 0;
      ++DWORD2(v11);
      ++HIDWORD(v11);
      if (SHIDWORD(v11) >= 256)
      {
        *(_DWORD *)(a2 + 48) = *(_DWORD *)(a2 + 48) & 1 | 0x7E;
LABEL_7:
        *(_DWORD *)(a2 + 40) = a4;
        return result;
      }
      if (a1)
      {
        double result = *(double *)&v10;
        long long v9 = v11;
        *a1 = v10;
        a1[1] = v9;
      }
    }
  }
  return result;
}

uint64_t dns_pointer_to_wire_(uint64_t result, uint64_t a2, int a3)
{
  unsigned int v3 = *(_DWORD *)(result + 48);
  if (v3 <= 1)
  {
    uint64_t v4 = *(void *)(a2 + 16) - *(void *)(a2 + 8);
    if ((v4 & 0x8000) != 0)
    {
      int v7 = v3 | 0x76;
    }
    else
    {
      uint64_t v5 = *(unsigned char **)(result + 8);
      if ((unint64_t)(v5 + 2) < *(void *)(result + 16))
      {
        *(void *)(result + 8) = v5 + 1;
        unsigned char *v5 = BYTE1(v4) | 0xC0;
        int v6 = *(unsigned char **)(result + 8);
        *(void *)(result + 8) = v6 + 1;
        *int v6 = v4;
        return result;
      }
      int v7 = 111;
    }
    *(_DWORD *)(result + 48) = v7;
    *(_DWORD *)(result + 40) = a3;
  }
  return result;
}

uint64_t dns_u32_to_wire_(uint64_t result, int a2, int a3)
{
  if (*(_DWORD *)(result + 48) <= 1u)
  {
    unsigned int v3 = *(unsigned char **)(result + 8);
    if ((unint64_t)(v3 + 4) >= *(void *)(result + 16))
    {
      *(_DWORD *)(result + 48) = 111;
      *(_DWORD *)(result + 40) = a3;
    }
    else
    {
      *(void *)(result + 8) = v3 + 1;
      *unsigned int v3 = HIBYTE(a2);
      uint64_t v4 = *(unsigned char **)(result + 8);
      *(void *)(result + 8) = v4 + 1;
      unsigned char *v4 = BYTE2(a2);
      uint64_t v5 = *(unsigned char **)(result + 8);
      *(void *)(result + 8) = v5 + 1;
      unsigned char *v5 = BYTE1(a2);
      int v6 = *(unsigned char **)(result + 8);
      *(void *)(result + 8) = v6 + 1;
      *int v6 = a2;
    }
  }
  return result;
}

BOOL srp_tls_init()
{
  int v0 = -67672;
  *(void *)double result = 0;
  *(void *)cf = 0;
  Mutable = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
  if (!Mutable)
  {
    unsigned int v3 = 0;
    int v4 = -6729;
    goto LABEL_21;
  }
  uint64_t v2 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  unsigned int v3 = v2;
  int v4 = -67672;
  if (v2)
  {
    CFDictionaryAddValue(v2, kSecClass, kSecClassCertificate);
    CFDictionaryAddValue(v3, kSecReturnRef, kCFBooleanTrue);
    CFDictionaryAddValue(v3, kSecMatchLimit, kSecMatchLimitAll);
    CFDictionaryAddValue(v3, kSecAttrAccessGroup, @"com.apple.srp-mdns-proxy");
    CFDictionaryAddValue(v3, kSecAttrAccessible, kSecAttrAccessibleAfterFirstUnlock);
    CFDictionaryAddValue(v3, kSecUseDataProtectionKeychain, kCFBooleanTrue);
    CFDictionaryAddValue(v3, kSecAttrSynchronizable, kCFBooleanTrue);
    CFDictionaryAddValue(v3, kSecAttrSyncViewHint, kSecAttrViewHintLimitedPeersAllowed);
    CFDictionaryAddValue(v3, kSecReturnAttributes, kCFBooleanTrue);
    SecItemCopyMatching(v3, (CFTypeRef *)result);
    if (*(void *)result)
    {
      uint64_t Count = CFArrayGetCount(*(CFArrayRef *)result);
      if (Count >= 1)
      {
        v68.size_t length = Count;
        v68.location = 0;
        CFArrayAppendArray(Mutable, *(CFArrayRef *)result, v68);
      }
    }
    CFDictionaryRemoveValue(v3, kSecAttrAccessible);
    SecItemCopyMatching(v3, (CFTypeRef *)cf);
    if (*(void *)cf)
    {
      CFIndex v6 = CFArrayGetCount(*(CFArrayRef *)cf);
      if (v6 >= 1)
      {
        CFIndex v7 = v6;
        for (CFIndex i = 0; i != v7; ++i)
        {
          CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)cf, i);
          if (ValueAtIndex)
          {
            CFDictionaryRef v10 = ValueAtIndex;
            CFStringRef Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, kSecAttrAccessible);
            if (!Value || CFStringCompare(Value, kSecAttrAccessibleAfterFirstUnlock, 0)) {
              CFArrayAppendValue(Mutable, v10);
            }
          }
        }
      }
    }
    if (CFArrayGetCount(Mutable) > 0)
    {
      int v4 = 0;
      goto LABEL_19;
    }
    int v4 = -25300;
  }
  CFRelease(Mutable);
  Mutable = 0;
LABEL_19:
  if (*(void *)cf)
  {
    CFRelease(*(CFTypeRef *)cf);
    *(void *)cf = 0;
  }
LABEL_21:
  if (*(void *)result)
  {
    CFRelease(*(CFTypeRef *)result);
    *(void *)double result = 0;
  }
  if (v3) {
    CFRelease(v3);
  }
  if (v4)
  {
    int v12 = 0;
  }
  else
  {
    if (Mutable) {
      CFIndex v13 = CFArrayGetCount(Mutable);
    }
    else {
      CFIndex v13 = 0;
    }
    int v12 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
    if (v12)
    {
      double Current = CFAbsoluteTimeGetCurrent();
      if (v13 >= 1)
      {
        double v15 = Current;
        for (CFIndex j = 0; j != v13; ++j)
        {
          CFDictionaryRef v17 = (const __CFDictionary *)CFArrayGetValueAtIndex(Mutable, j);
          if (v17)
          {
            CFDictionaryRef v18 = v17;
            CFTypeID v19 = CFGetTypeID(v17);
            if (v19 == CFDictionaryGetTypeID())
            {
              CFDateRef v20 = (const __CFDate *)CFDictionaryGetValue(v18, kSecAttrCreationDate);
              if (v20)
              {
                if (v15 - CFDateGetAbsoluteTime(v20) >= 2419200.0) {
                  CFArrayAppendValue(v12, v18);
                }
              }
            }
          }
        }
      }
      CFIndex v21 = CFArrayGetCount(v12);
      if (v21 >= 1)
      {
        CFIndex v22 = v21;
        for (CFIndex k = 0; k != v22; ++k)
        {
          __int16 v24 = CFArrayGetValueAtIndex(v12, k);
          CFTypeID v25 = CFGetTypeID(v24);
          if (v25 == CFDictionaryGetTypeID())
          {
            CFMutableDictionaryRef v26 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            if (v26)
            {
              __int16 v27 = v26;
              __int16 v28 = CFDictionaryGetValue((CFDictionaryRef)v24, kSecValueRef);
              if (v28)
              {
                CFDictionaryAddValue(v27, kSecValueRef, v28);
                __int16 v29 = CFDictionaryGetValue((CFDictionaryRef)v24, kSecAttrAccessGroup);
                if (v29)
                {
                  CFDictionaryAddValue(v27, kSecAttrAccessGroup, v29);
                  int v30 = CFDictionaryGetValue((CFDictionaryRef)v24, kSecAttrAccessible);
                  if (v30)
                  {
                    CFDictionaryAddValue(v27, kSecAttrAccessible, v30);
                    CFDictionaryAddValue(v27, kSecUseDataProtectionKeychain, kCFBooleanTrue);
                    CFDictionaryAddValue(v27, kSecAttrSynchronizable, kCFBooleanTrue);
                    SecItemDelete(v27);
                  }
                }
              }
              CFRelease(v27);
            }
          }
        }
        int v0 = -67672;
      }
    }
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v12) {
    CFRelease(v12);
  }
  uint64_t v31 = (void *)g_tls_identity;
  if (g_tls_identity)
  {
    int v32 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)
      || (*(_DWORD *)double result = 136446210,
          *(void *)&result[4] = "tls_identity_init",
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "%{public}s: Identity already initialized, reconfirming if it is still valid.", result, 0xCu), (uint64_t v31 = (void *)g_tls_identity) != 0))
    {
      sec_release(v31);
      g_tls_identity = 0;
    }
  }
  if (!keychain_identity_query(0, &g_tls_identity, (double *)&g_tls_identity_creation_time)) {
    return 1;
  }
  int v33 = keychain_identity_query(1, 0, 0);
  if (!v33 || v33 == -25300)
  {
    CFUUIDRef v34 = CFUUIDCreate(kCFAllocatorDefault);
    if (!v34 || (v35 = v34, CFStringRef v36 = CFUUIDCreateString(kCFAllocatorDefault, v34), CFRelease(v35), !v36))
    {
      v55 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)double result = 136446210;
        *(void *)&result[4] = "tls_identity_init";
        _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_FAULT, "%{public}s: Failed to generate an UUID.", result, 0xCu);
      }
      goto LABEL_123;
    }
    *(_DWORD *)&v63[8] = 0;
    __int16 v37 = (const void *)CFStringCreateF();
    *(void *)__int16 v63 = CFPropertyListCreateFormatted();
    if (!*(_DWORD *)v63)
    {
      CFErrorRef error = 0;
      SecKeyRef v38 = SecKeyCreateRandomKey(*(CFDictionaryRef *)&v63[4], &error);
      if (v38)
      {
LABEL_66:
        if (*(void *)&v63[4])
        {
          CFRelease(*(CFTypeRef *)&v63[4]);
          *(void *)&v63[4] = 0;
        }
        if (v37) {
          CFRelease(v37);
        }
        if (v38)
        {
          LODWORD(error) = 0;
          *(void *)&v63[4] = 0;
          *(void *)cf = 0;
          __int16 v39 = (const void *)CFStringCreateF();
          xpc_object_t v40 = 0;
          int v41 = 0;
          if (!error)
          {
            xpc_object_t v40 = 0;
            int v41 = 0;
            LODWORD(error) = CFPropertyListCreateFormatted();
            if (!error)
            {
              int v41 = (const void *)CFStringCreateF();
              if (error || (LODWORD(error) = CFPropertyListCreateFormatted(), error))
              {
                xpc_object_t v40 = 0;
              }
              else
              {
                uint64_t SelfSignedCertificate = SecGenerateSelfSignedCertificate();
                if (SelfSignedCertificate)
                {
                  xpc_object_t v40 = (const void *)SelfSignedCertificate;
                }
                else
                {
                  uint64_t v61 = global_os_log;
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                  {
                    *(_DWORD *)double result = 136446210;
                    *(void *)&result[4] = "certificate_generate";
                    _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_FAULT, "%{public}s: SecGenerateSelfSignedCertificate failed.", result, 0xCu);
                  }
                  xpc_object_t v40 = 0;
                  int v0 = -67672;
                }
              }
            }
          }
          if (*(void *)&v63[4])
          {
            CFRelease(*(CFTypeRef *)&v63[4]);
            *(void *)&v63[4] = 0;
          }
          if (v41) {
            CFRelease(v41);
          }
          if (*(void *)cf)
          {
            CFRelease(*(CFTypeRef *)cf);
            *(void *)cf = 0;
          }
          if (v39) {
            CFRelease(v39);
          }
          if (v40)
          {
            uint64_t v42 = SecIdentityCreate();
            if (v42)
            {
              int v43 = (__SecIdentity *)v42;
              *(void *)double result = 0;
              *(void *)cf = 0;
              uint64_t v44 = CFStringCreateMutable(kCFAllocatorDefault, 0);
              uint64_t v45 = v44;
              if (v44)
              {
                CFStringAppend(v44, @"Key ");
                CFStringAppend(v45, v36);
                __int16 v46 = CFStringCreateMutable(kCFAllocatorDefault, 0);
                os_log_type_t v47 = v46;
                if (v46)
                {
                  CFStringAppend(v46, @"Certificate ");
                  CFStringAppend(v47, v36);
                  int v0 = SecIdentityCopyPrivateKey(v43, (SecKeyRef *)result);
                  if (!v0)
                  {
                    int v0 = SecIdentityCopyCertificate(v43, (SecCertificateRef *)cf);
                    if (!v0)
                    {
                      int v48 = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
                      if (v48)
                      {
                        uint32_t v49 = v48;
                        CFDictionaryAddValue(v48, kSecAttrLabel, v45);
                        CFDictionaryAddValue(v49, kSecAttrAccessGroup, @"com.apple.srp-mdns-proxy");
                        CFDictionaryAddValue(v49, kSecAttrAccessible, kSecAttrAccessibleAfterFirstUnlock);
                        CFDictionaryAddValue(v49, kSecAttrSynchronizable, kCFBooleanFalse);
                        CFDictionaryAddValue(v49, kSecUseDataProtectionKeychain, kCFBooleanTrue);
                        CFDictionaryAddValue(v49, kSecValueRef, *(const void **)result);
                        int v0 = SecItemAdd(v49, 0);
                        if (!v0)
                        {
                          CFDictionaryReplaceValue(v49, kSecAttrLabel, v47);
                          CFDictionaryReplaceValue(v49, kSecValueRef, *(const void **)cf);
                          CFDictionaryReplaceValue(v49, kSecAttrSynchronizable, kCFBooleanTrue);
                          CFDictionaryAddValue(v49, kSecAttrSyncViewHint, kSecAttrViewHintLimitedPeersAllowed);
                          OSStatus v50 = SecItemAdd(v49, 0);
                          if (v50)
                          {
                            int v0 = v50;
                            keychain_key_remove();
                          }
                          else
                          {
                            int v0 = 0;
                          }
                        }
                        CFRelease(v49);
                      }
                      else
                      {
                        int v0 = 0;
                      }
                    }
                  }
                }
                if (*(void *)cf)
                {
                  CFRelease(*(CFTypeRef *)cf);
                  *(void *)cf = 0;
                }
              }
              else
              {
                os_log_type_t v47 = 0;
              }
              if (*(void *)result)
              {
                CFRelease(*(CFTypeRef *)result);
                *(void *)double result = 0;
              }
              if (v47) {
                CFRelease(v47);
              }
              if (v45) {
                CFRelease(v45);
              }
              if (v0)
              {
                uint64_t v60 = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                {
                  *(_DWORD *)double result = 136446210;
                  *(void *)&result[4] = "tls_identity_init";
                  _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_FAULT, "%{public}s: Failed to add the identity into keychain.", result, 0xCu);
                }
              }
              else
              {
                int v0 = keychain_identity_query(0, &g_tls_identity, (double *)&g_tls_identity_creation_time);
              }
              CFRelease(v43);
            }
            else
            {
              uint64_t v59 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)double result = 136446210;
                *(void *)&result[4] = "tls_identity_init";
                _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_FAULT, "%{public}s: Failed to create the identity with the given private key and certificate.", result, 0xCu);
              }
              int v0 = -6728;
            }
            CFRelease(v40);
          }
          else
          {
            uint64_t v58 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)double result = 136446210;
              *(void *)&result[4] = "tls_identity_init";
              _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_FAULT, "%{public}s: Failed to generate a new TLS certificate.", result, 0xCu);
            }
            int v0 = -6700;
          }
          CFRelease(v38);
          CFRelease(v36);
          if (!v0) {
            return 1;
          }
        }
        else
        {
          uint32_t v56 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)double result = 136446210;
            *(void *)&result[4] = "tls_identity_init";
            _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_FAULT, "%{public}s: Failed to generate a new TLS key.", result, 0xCu);
          }
          CFRelease(v36);
        }
        goto LABEL_123;
      }
      CFStringRef v52 = CFErrorCopyDescription(error);
      CFStringGetCString(v52, result, 200, 0x8000100u);
      uint64_t v53 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)cf = 136446466;
        *(void *)&cf[4] = "private_key_generate";
        __int16 v65 = 2080;
        uint64_t v66 = result;
        _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_FAULT, "%{public}s: SecKeyCreateRandomKey failed to create private key - error description: %s.", cf, 0x16u);
      }
      if (v52) {
        CFRelease(v52);
      }
      if (error)
      {
        CFRelease(error);
        CFErrorRef error = 0;
      }
    }
    SecKeyRef v38 = 0;
    goto LABEL_66;
  }
LABEL_123:
  size_t v57 = global_os_log;
  BOOL v51 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
  if (v51)
  {
    *(_DWORD *)double result = 136446210;
    *(void *)&result[4] = "srp_tls_init";
    _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_ERROR, "%{public}s: srp_tls_init: tls_identity_init failed.", result, 0xCu);
    return 0;
  }
  return v51;
}

void srp_tls_configure(nw_protocol_options_t *a1)
{
  uint64_t v2 = nw_tls_copy_sec_protocol_options(*a1);
  sec_identity_t v3 = sec_identity_create((SecIdentityRef)g_tls_identity);
  if (v3)
  {
    int v4 = v3;
    sec_protocol_options_set_tls_server_name(v2, "com.apple.dnssd-proxy");
    sec_protocol_options_set_local_identity(v2, v4);
    sec_protocol_options_append_tls_ciphersuite_group(v2, tls_ciphersuite_group_default);
    sec_protocol_options_set_min_tls_protocol_version(v2, tls_protocol_version_TLSv12);
    sec_protocol_options_set_verify_block(v2, &__block_literal_global_500, a1[1]);
    sec_release(v4);
  }
  else
  {
    uint64_t v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      int v6 = 136446210;
      CFIndex v7 = "srp_tls_configure";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "%{public}s: configure_tls: sec_identity_create failed", (uint8_t *)&v6, 0xCu);
    }
  }
  if (v2) {
    nw_release(v2);
  }
}

void __srp_tls_configure_block_invoke(id a1, sec_protocol_metadata *a2, sec_trust *a3, id a4)
{
}

void tls_certificate_rotate(uint64_t a1)
{
  if (g_tls_identity)
  {
    if (*(double *)&g_tls_identity_creation_time > 0.0)
    {
      CFDateRef v2 = CFDateCreate(kCFAllocatorDefault, *(CFAbsoluteTime *)&g_tls_identity_creation_time);
      if (v2)
      {
        CFDateRef v3 = v2;
        CFAbsoluteTime Current = CFAbsoluteTimeGetCurrent();
        CFDateRef v5 = CFDateCreate(kCFAllocatorDefault, Current);
        if (v5)
        {
          CFDateRef v6 = v5;
          CFIndex v7 = CFDateFormatterCreate(0, 0, kCFDateFormatterShortStyle, kCFDateFormatterShortStyle);
          if (v7)
          {
            unint64_t v8 = v7;
            CFStringRef StringWithDate = CFDateFormatterCreateStringWithDate(0, v7, v6);
            if (StringWithDate)
            {
              CFStringRef v10 = CFDateFormatterCreateStringWithDate(0, v8, v3);
              if (v10)
              {
                CFTimeInterval TimeIntervalSinceDate = CFDateGetTimeIntervalSinceDate(v6, v3);
                int v12 = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                {
                  int v16 = 136446978;
                  CFDictionaryRef v17 = "srp_tls_dispose";
                  __int16 v18 = 2114;
                  CFStringRef v19 = StringWithDate;
                  __int16 v20 = 2114;
                  CFStringRef v21 = v10;
                  __int16 v22 = 2048;
                  CFTimeInterval v23 = TimeIntervalSinceDate;
                  _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: Rotating the expired TLS certificate - creation date: %{public}@, now: %{public}@, elapsed: %lf.", (uint8_t *)&v16, 0x2Au);
                }
                if (g_tls_identity)
                {
                  sec_release((void *)g_tls_identity);
                  g_tls_identity = 0;
                }
                g_tls_identity_creation_time = 0xBFF0000000000000;
              }
            }
            else
            {
              CFStringRef v10 = 0;
            }
            CFRelease(v8);
            CFRelease(v6);
            if (StringWithDate) {
              CFRelease(StringWithDate);
            }
            if (!v10) {
              goto LABEL_19;
            }
            CFIndex v13 = v10;
          }
          else
          {
            CFIndex v13 = v6;
          }
          CFRelease(v13);
        }
LABEL_19:
        CFRelease(v3);
      }
    }
  }
  if (a1 && (uint64_t v14 = *(NSObject **)(a1 + 8)) != 0)
  {
    *(_WORD *)(a1 + 416) |= 0x10u;
    nw_listener_cancel(v14);
  }
  else
  {
    double v15 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      int v16 = 136446210;
      CFDictionaryRef v17 = "tls_certificate_rotate";
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_FAULT, "%{public}s: TLS listener does not exist while the TLS certificate rotation timer is triggered.", (uint8_t *)&v16, 0xCu);
    }
  }
}

void thread_device_startup(uint64_t *a1)
{
  thread_device_shutdown(a1);
  CFDateRef v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446210;
    unint64_t v8 = "thread_device_startup";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: starting up", buf, 0xCu);
  }
  xpc_object_t v3 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v3, "interface", "org.wpantund.v1");
  xpc_dictionary_set_string(v3, "path", "/org/wpantund/utun2");
  xpc_dictionary_set_string(v3, "method", "OtCtlCmd");
  xpc_dictionary_set_string(v3, "otctl_cmd", "rloc16");
  int v4 = setup_for_command(a1 + 23, (uint64_t)"get_rloc16", 0, 0, v3, (uint64_t)a1, (uint64_t)thread_device_rloc16_callback, (uint64_t)cti_internal_rloc16_reply_callback, 0, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/thread-device.c", 135);
  CFDateRef v5 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446466;
    unint64_t v8 = "cti_get_rloc16_";
    __int16 v9 = 1024;
    int v10 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: get_rloc16 result %d", buf, 0x12u);
  }
  xpc_release(v3);
  if (v4)
  {
    CFDateRef v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)buf = 136446466;
      unint64_t v8 = "thread_device_startup";
      __int16 v9 = 1024;
      int v10 = v4;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "%{public}s: can't get rloc16: %d", buf, 0x12u);
    }
  }
}

void thread_device_shutdown(uint64_t *a1)
{
  CFDateRef v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 136446210;
    CFDateRef v6 = "thread_device_shutdown";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: shutting down", (uint8_t *)&v5, 0xCu);
  }
  uint64_t v3 = a1[23];
  if (v3)
  {
    cti_events_discontinue(v3);
    a1[23] = 0;
  }
  uint64_t v4 = a1[24];
  if (v4)
  {
    cti_events_discontinue(v4);
    a1[24] = 0;
  }
  thread_device_stop(a1);
}

void thread_device_rloc16_callback(uint64_t a1, int a2, int a3)
{
  if (a3)
  {
    uint64_t v4 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136446466;
    v151 = "thread_device_rloc16_callback";
    __int16 v152 = 1024;
    *(_DWORD *)v153 = a3;
    int v5 = "%{public}s: rloc16 get failed with status %d";
    CFDateRef v6 = v4;
    os_log_type_t v7 = OS_LOG_TYPE_ERROR;
    uint32_t v8 = 18;
    goto LABEL_251;
  }
  *(_WORD *)(a1 + 276) = a2;
  long long v11 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446466;
    v151 = "thread_device_rloc16_callback";
    __int16 v152 = 1024;
    *(_DWORD *)v153 = a2;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: server_state->rloc16 updated to %d", buf, 0x12u);
  }
  int v12 = _os_feature_enabled_impl();
  *(unsigned char *)(a1 + 287) = v12;
  CFIndex v13 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = "disabled";
    if (v12) {
      uint64_t v14 = "enabled";
    }
    *(_DWORD *)buf = 136446466;
    v151 = "thread_device_rloc16_callback";
    __int16 v152 = 2082;
    *(void *)v153 = v14;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: srp on demand is %{public}s", buf, 0x16u);
  }
  uint64_t v15 = *(void *)(a1 + 40);
  BOOL v16 = v15 == 0;
  if (!v15)
  {
    CFDictionaryRef v17 = malloc_type_calloc(1uLL, 0x40uLL, 0x1020040A7794E27uLL);
    __int16 v18 = global_os_log;
    if (!v17)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        ++service_tracker_serial_number;
        *(_DWORD *)buf = 136446466;
        v151 = "service_tracker_create";
        __int16 v152 = 2048;
        *(void *)v153 = service_tracker_serial_number;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "%{public}s: [ST%lld] no memory", buf, 0x16u);
        __int16 v18 = global_os_log;
      }
      *(void *)(a1 + 40) = 0;
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
        return;
      }
      *(_DWORD *)buf = 136446210;
      v151 = "thread_device_rloc16_callback";
      int v5 = "%{public}s: can't create service tracker.";
      goto LABEL_50;
    }
    CFStringRef v19 = v17;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v20 = *(_DWORD *)v19;
      *(_DWORD *)buf = 136447490;
      v151 = "service_tracker_create";
      __int16 v152 = 1024;
      *(_DWORD *)v153 = v20;
      *(_WORD *)&v153[4] = 2048;
      *(void *)&v153[6] = v19;
      __int16 v154 = 2080;
      v155 = "tracker";
      __int16 v156 = 2080;
      v157 = "service-tracker.c";
      __int16 v158 = 1024;
      int v159 = 361;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    int v21 = *(_DWORD *)v19;
    if (*(_DWORD *)v19)
    {
      int v22 = v21 + 1;
      *(_DWORD *)CFStringRef v19 = v21 + 1;
      if (v21 + 1 >= 10001)
      {
        uint64_t v23 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_264;
        }
        *(_DWORD *)buf = 136447490;
        v151 = "service_tracker_create";
        __int16 v152 = 1024;
        *(_DWORD *)v153 = v22;
        *(_WORD *)&v153[4] = 2048;
        *(void *)&v153[6] = v19;
        __int16 v154 = 2080;
        v155 = "tracker";
        __int16 v156 = 2080;
        v157 = "service-tracker.c";
        __int16 v158 = 1024;
        int v159 = 361;
        __int16 v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_95:
        uint64_t v66 = buf;
LABEL_262:
        __int16 v102 = v23;
        goto LABEL_263;
      }
    }
    else
    {
      ++service_tracker_created;
      *(_DWORD *)CFStringRef v19 = 1;
    }
    v19[1] = ++service_tracker_serial_number;
    v19[3] = a1;
    *(void *)(a1 + 40) = v19;
  }
  if (!*(void *)(a1 + 56))
  {
    CFTypeID v25 = malloc_type_calloc(1uLL, 0x50uLL, 0x10A004065551B19uLL);
    __int16 v18 = global_os_log;
    if (!v25)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        ++thread_tracker_serial_number;
        *(_DWORD *)buf = 136446466;
        v151 = "thread_tracker_create";
        __int16 v152 = 2048;
        *(void *)v153 = thread_tracker_serial_number;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "%{public}s: [ST%lld] no memory", buf, 0x16u);
        __int16 v18 = global_os_log;
      }
      *(void *)(a1 + 56) = 0;
      if (!os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
        return;
      }
      *(_DWORD *)buf = 136446210;
      v151 = "thread_device_rloc16_callback";
      int v5 = "%{public}s: can't create thread tracker.";
      goto LABEL_50;
    }
    CFMutableDictionaryRef v26 = v25;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v27 = *(_DWORD *)v26;
      *(_DWORD *)buf = 136447490;
      v151 = "thread_tracker_create";
      __int16 v152 = 1024;
      *(_DWORD *)v153 = v27;
      *(_WORD *)&v153[4] = 2048;
      *(void *)&v153[6] = v26;
      __int16 v154 = 2080;
      v155 = "tracker";
      __int16 v156 = 2080;
      v157 = "thread-tracker.c";
      __int16 v158 = 1024;
      int v159 = 201;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    int v28 = *(_DWORD *)v26;
    if (*(_DWORD *)v26)
    {
      int v29 = v28 + 1;
      *(_DWORD *)CFMutableDictionaryRef v26 = v28 + 1;
      if (v28 + 1 >= 10001)
      {
        uint64_t v23 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_264;
        }
        *(_DWORD *)buf = 136447490;
        v151 = "thread_tracker_create";
        __int16 v152 = 1024;
        *(_DWORD *)v153 = v29;
        *(_WORD *)&v153[4] = 2048;
        *(void *)&v153[6] = v26;
        __int16 v154 = 2080;
        v155 = "tracker";
        __int16 v156 = 2080;
        v157 = "thread-tracker.c";
        __int16 v158 = 1024;
        int v159 = 201;
        __int16 v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        goto LABEL_95;
      }
    }
    else
    {
      ++thread_tracker_created;
      *(_DWORD *)CFMutableDictionaryRef v26 = 1;
    }
    v26[1] = ++thread_tracker_serial_number;
    v26[4] = a1;
    v26[8] = 0;
    *((_WORD *)v26 + 36) = 0;
    *(void *)(a1 + 56) = v26;
    BOOL v16 = 1;
  }
  if (*(void *)(a1 + 64)) {
    goto LABEL_53;
  }
  int v30 = malloc_type_calloc(1uLL, 0x48uLL, 0x10A0040209ECF46uLL);
  __int16 v18 = global_os_log;
  if (!v30)
  {
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      ++node_type_tracker_serial_number;
      *(_DWORD *)buf = 136446466;
      v151 = "node_type_tracker_create";
      __int16 v152 = 2048;
      *(void *)v153 = node_type_tracker_serial_number;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "%{public}s: [ST%lld] no memory", buf, 0x16u);
      __int16 v18 = global_os_log;
    }
    *(void *)(a1 + 64) = 0;
    if (!os_log_type_enabled(v18, OS_LOG_TYPE_FAULT)) {
      return;
    }
    *(_DWORD *)buf = 136446210;
    v151 = "thread_device_rloc16_callback";
    int v5 = "%{public}s: can't create node type tracker.";
LABEL_50:
    CFDateRef v6 = v18;
LABEL_250:
    os_log_type_t v7 = OS_LOG_TYPE_FAULT;
    uint32_t v8 = 12;
LABEL_251:
    _os_log_impl((void *)&_mh_execute_header, v6, v7, v5, buf, v8);
    return;
  }
  uint64_t v31 = v30;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v32 = *(_DWORD *)v31;
    *(_DWORD *)buf = 136447490;
    v151 = "node_type_tracker_create";
    __int16 v152 = 1024;
    *(_DWORD *)v153 = v32;
    *(_WORD *)&v153[4] = 2048;
    *(void *)&v153[6] = v31;
    __int16 v154 = 2080;
    v155 = "tracker";
    __int16 v156 = 2080;
    v157 = "node-type-tracker.c";
    __int16 v158 = 1024;
    int v159 = 174;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  int v33 = *(_DWORD *)v31;
  if (*(_DWORD *)v31)
  {
    int v34 = v33 + 1;
    *(_DWORD *)uint64_t v31 = v33 + 1;
    if (v33 + 1 >= 10001)
    {
      uint64_t v23 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_264;
      }
      *(_DWORD *)buf = 136447490;
      v151 = "node_type_tracker_create";
      __int16 v152 = 1024;
      *(_DWORD *)v153 = v34;
      *(_WORD *)&v153[4] = 2048;
      *(void *)&v153[6] = v31;
      __int16 v154 = 2080;
      v155 = "tracker";
      __int16 v156 = 2080;
      v157 = "node-type-tracker.c";
      __int16 v158 = 1024;
      int v159 = 174;
      __int16 v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_95;
    }
  }
  else
  {
    ++node_type_tracker_created;
    *(_DWORD *)uint64_t v31 = 1;
  }
  v31[1] = ++node_type_tracker_serial_number;
  v31[4] = a1;
  v31[8] = 0;
  *(void *)(a1 + 64) = v31;
  BOOL v16 = 1;
LABEL_53:
  if (*(void *)(a1 + 48))
  {
    CFUUIDRef v35 = (uint64_t *)(a1 + 128);
    if (*(void *)(a1 + 128))
    {
      if (!v16) {
        return;
      }
LABEL_56:
      uint64_t v36 = *(void *)(a1 + 56);
      xpc_object_t v37 = xpc_dictionary_create(0, 0, 0);
      xpc_dictionary_set_string(v37, "interface", "org.wpantund.v1");
      xpc_dictionary_set_string(v37, "path", "/org/wpantund/utun2");
      xpc_dictionary_set_string(v37, "method", "PropGet");
      xpc_dictionary_set_string(v37, "property_name", "NCP:State");
      int v38 = setup_for_command((void *)(v36 + 40), (uint64_t)"get_state", "NCP:State", 0, v37, v36, (uint64_t)thread_tracker_callback, (uint64_t)cti_internal_state_reply_callback, 0, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/thread-tracker.c", 219);
      xpc_release(v37);
      __int16 v39 = global_os_log;
      if (v38 && os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v40 = *(void *)(v36 + 8);
        *(_DWORD *)buf = 136446722;
        v151 = "thread_tracker_start";
        __int16 v152 = 2048;
        *(void *)v153 = v40;
        *(_WORD *)&v153[8] = 1024;
        *(_DWORD *)&v153[10] = v38;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "%{public}s: [TT%lld] service list get failed: %d", buf, 0x1Cu);
        __int16 v39 = global_os_log;
      }
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT))
      {
        int v41 = *(_DWORD *)v36;
        *(_DWORD *)buf = 136447490;
        v151 = "thread_tracker_start";
        __int16 v152 = 1024;
        *(_DWORD *)v153 = v41;
        *(_WORD *)&v153[4] = 2048;
        *(void *)&v153[6] = v36;
        __int16 v154 = 2080;
        v155 = "tracker";
        __int16 v156 = 2080;
        v157 = "thread-tracker.c";
        __int16 v158 = 1024;
        int v159 = 223;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      }
      int v42 = *(_DWORD *)v36;
      if (*(_DWORD *)v36)
      {
        int v43 = v42 + 1;
        *(_DWORD *)uint64_t v36 = v42 + 1;
        if (v42 + 1 >= 10001)
        {
          uint64_t v23 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
            goto LABEL_264;
          }
          *(_DWORD *)buf = 136447490;
          v151 = "thread_tracker_start";
          __int16 v152 = 1024;
          *(_DWORD *)v153 = v43;
          *(_WORD *)&v153[4] = 2048;
          *(void *)&v153[6] = v36;
          __int16 v154 = 2080;
          v155 = "tracker";
          __int16 v156 = 2080;
          v157 = "thread-tracker.c";
          __int16 v158 = 1024;
          int v159 = 223;
          __int16 v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
          goto LABEL_95;
        }
      }
      else
      {
        ++thread_tracker_created;
        *(_DWORD *)uint64_t v36 = 1;
      }
      uint64_t v58 = *(void *)(a1 + 64);
      xpc_object_t v59 = xpc_dictionary_create(0, 0, 0);
      xpc_dictionary_set_string(v59, "interface", "org.wpantund.v1");
      xpc_dictionary_set_string(v59, "path", "/org/wpantund/utun2");
      xpc_dictionary_set_string(v59, "method", "PropGet");
      xpc_dictionary_set_string(v59, "property_name", "Network:NodeType");
      int v60 = setup_for_command((void *)(v58 + 40), (uint64_t)"get_network_node_type", "Network:NodeType", 0, v59, v58, (uint64_t)node_type_tracker_callback, (uint64_t)cti_internal_network_node_type_callback, 0, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/node-type-tracker.c", 192);
      xpc_release(v59);
      uint64_t v61 = global_os_log;
      if (v60 && os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v62 = *(void *)(v58 + 8);
        *(_DWORD *)buf = 136446722;
        v151 = "node_type_tracker_start";
        __int16 v152 = 2048;
        *(void *)v153 = v62;
        *(_WORD *)&v153[8] = 1024;
        *(_DWORD *)&v153[10] = v60;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "%{public}s: [TT%lld] service list get failed: %d", buf, 0x1Cu);
        uint64_t v61 = global_os_log;
      }
      if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
      {
        int v63 = *(_DWORD *)v58;
        *(_DWORD *)buf = 136447490;
        v151 = "node_type_tracker_start";
        __int16 v152 = 1024;
        *(_DWORD *)v153 = v63;
        *(_WORD *)&v153[4] = 2048;
        *(void *)&v153[6] = v58;
        __int16 v154 = 2080;
        v155 = "tracker";
        __int16 v156 = 2080;
        v157 = "node-type-tracker.c";
        __int16 v158 = 1024;
        int v159 = 196;
        _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      }
      int v64 = *(_DWORD *)v58;
      if (*(_DWORD *)v58)
      {
        int v65 = v64 + 1;
        *(_DWORD *)uint64_t v58 = v64 + 1;
        if (v64 + 1 >= 10001)
        {
          uint64_t v23 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
            goto LABEL_264;
          }
          *(_DWORD *)buf = 136447490;
          v151 = "node_type_tracker_start";
          __int16 v152 = 1024;
          *(_DWORD *)v153 = v65;
          *(_WORD *)&v153[4] = 2048;
          *(void *)&v153[6] = v58;
          __int16 v154 = 2080;
          v155 = "tracker";
          __int16 v156 = 2080;
          v157 = "node-type-tracker.c";
          __int16 v158 = 1024;
          int v159 = 196;
          __int16 v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
          goto LABEL_95;
        }
      }
      else
      {
        ++node_type_tracker_created;
        *(_DWORD *)uint64_t v58 = 1;
      }
      uint64_t v67 = *(void *)(a1 + 48);
      int active = cti_track_active_data_set_((void *)(v67 + 152), v67, (uint64_t)service_publisher_active_data_set_changed_callback, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 1850);
      uint64_t v69 = global_os_log;
      if (active)
      {
        int v70 = active;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v151 = "service_publisher_start";
          __int16 v152 = 1024;
          *(_DWORD *)v153 = v70;
          _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_ERROR, "%{public}s: unable to start tracking active dataset: %d", buf, 0x12u);
        }
      }
      else
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v71 = *(_DWORD *)v67;
          *(_DWORD *)buf = 136447490;
          v151 = "service_publisher_start";
          __int16 v152 = 1024;
          *(_DWORD *)v153 = v71;
          *(_WORD *)&v153[4] = 2048;
          *(void *)&v153[6] = v67;
          __int16 v154 = 2080;
          v155 = "publisher";
          __int16 v156 = 2080;
          v157 = "service-publisher.c";
          __int16 v158 = 1024;
          int v159 = 1854;
          _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        int v72 = *(_DWORD *)v67;
        if (*(_DWORD *)v67)
        {
          int v73 = v72 + 1;
          *(_DWORD *)uint64_t v67 = v72 + 1;
          if (v72 + 1 >= 10001)
          {
            uint64_t v74 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
              goto LABEL_264;
            }
            *(_DWORD *)buf = 136447490;
            v151 = "service_publisher_start";
            __int16 v152 = 1024;
            *(_DWORD *)v153 = v73;
            *(_WORD *)&v153[4] = 2048;
            *(void *)&v153[6] = v67;
            __int16 v154 = 2080;
            v155 = "publisher";
            __int16 v156 = 2080;
            v157 = "service-publisher.c";
            __int16 v158 = 1024;
            int v159 = 1854;
            __int16 v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
            goto LABEL_159;
          }
        }
        else
        {
          ++service_publisher_created;
          *(_DWORD *)uint64_t v67 = 1;
        }
      }
      int tunnel_name = cti_get_tunnel_name_(v67, (uint64_t)service_publisher_tunnel_name_callback, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 1857);
      int v80 = global_os_log;
      if (tunnel_name)
      {
        int v81 = tunnel_name;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          v151 = "service_publisher_start";
          __int16 v152 = 1024;
          *(_DWORD *)v153 = v81;
          _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_ERROR, "%{public}s: unable to get tunnel name: %d", buf, 0x12u);
        }
      }
      else
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v82 = *(_DWORD *)v67;
          *(_DWORD *)buf = 136447490;
          v151 = "service_publisher_start";
          __int16 v152 = 1024;
          *(_DWORD *)v153 = v82;
          *(_WORD *)&v153[4] = 2048;
          *(void *)&v153[6] = v67;
          __int16 v154 = 2080;
          v155 = "publisher";
          __int16 v156 = 2080;
          v157 = "service-publisher.c";
          __int16 v158 = 1024;
          int v159 = 1861;
          _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        int v83 = *(_DWORD *)v67;
        if (*(_DWORD *)v67)
        {
          int v84 = v83 + 1;
          *(_DWORD *)uint64_t v67 = v83 + 1;
          if (v83 + 1 >= 10001)
          {
            uint64_t v74 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
              goto LABEL_264;
            }
            *(_DWORD *)buf = 136447490;
            v151 = "service_publisher_start";
            __int16 v152 = 1024;
            *(_DWORD *)v153 = v84;
            *(_WORD *)&v153[4] = 2048;
            *(void *)&v153[6] = v67;
            __int16 v154 = 2080;
            v155 = "publisher";
            __int16 v156 = 2080;
            v157 = "service-publisher.c";
            __int16 v158 = 1024;
            int v159 = 1861;
            __int16 v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
            goto LABEL_159;
          }
        }
        else
        {
          ++service_publisher_created;
          *(_DWORD *)uint64_t v67 = 1;
        }
      }
      xpc_object_t v85 = xpc_dictionary_create(0, 0, 0);
      xpc_dictionary_set_string(v85, "interface", "org.wpantund.v1");
      xpc_dictionary_set_string(v85, "path", "/org/wpantund/utun2");
      int v86 = setup_for_command((void *)(v67 + 160), (uint64_t)"get_wed_status", "WakeOnDeviceConnectionStatus", 0, v85, v67, (uint64_t)service_publisher_wed_callback, (uint64_t)cti_internal_wed_reply_callback, 1, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 1866);
      xpc_release(v85);
      __int16 v87 = global_os_log;
      if (v86)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136446466;
          v151 = "service_publisher_start";
          __int16 v152 = 1024;
          *(_DWORD *)v153 = v86;
          _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_FAULT, "%{public}s: can't track WED status: %d", buf, 0x12u);
        }
      }
      else
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v88 = *(_DWORD *)v67;
          *(_DWORD *)buf = 136447490;
          v151 = "service_publisher_start";
          __int16 v152 = 1024;
          *(_DWORD *)v153 = v88;
          *(_WORD *)&v153[4] = 2048;
          *(void *)&v153[6] = v67;
          __int16 v154 = 2080;
          v155 = "publisher";
          __int16 v156 = 2080;
          v157 = "service-publisher.c";
          __int16 v158 = 1024;
          int v159 = 1870;
          _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        int v89 = *(_DWORD *)v67;
        if (*(_DWORD *)v67)
        {
          int v90 = v89 + 1;
          *(_DWORD *)uint64_t v67 = v89 + 1;
          if (v89 + 1 >= 10001)
          {
            uint64_t v74 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
              goto LABEL_264;
            }
            *(_DWORD *)buf = 136447490;
            v151 = "service_publisher_start";
            __int16 v152 = 1024;
            *(_DWORD *)v153 = v90;
            *(_WORD *)&v153[4] = 2048;
            *(void *)&v153[6] = v67;
            __int16 v154 = 2080;
            v155 = "publisher";
            __int16 v156 = 2080;
            v157 = "service-publisher.c";
            __int16 v158 = 1024;
            int v159 = 1870;
            __int16 v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
            goto LABEL_159;
          }
        }
        else
        {
          ++service_publisher_created;
          *(_DWORD *)uint64_t v67 = 1;
        }
      }
      xpc_object_t v91 = xpc_dictionary_create(0, 0, 0);
      xpc_dictionary_set_string(v91, "interface", "org.wpantund.v1");
      xpc_dictionary_set_string(v91, "path", "/org/wpantund/utun2");
      int v92 = setup_for_command((void *)(v67 + 168), (uint64_t)"get_neighbor_ml_eid", "ThreadNeighborMeshLocalAddress", 0, v91, v67, (uint64_t)service_publisher_neighbor_callback, (uint64_t)cti_internal_string_event_reply, 1, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 1874);
      xpc_release(v91);
      uint64_t v93 = global_os_log;
      if (v92)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136446466;
          v151 = "service_publisher_start";
          __int16 v152 = 1024;
          *(_DWORD *)v153 = v92;
          _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_FAULT, "%{public}s: can't track WED status: %d", buf, 0x12u);
        }
LABEL_153:
        service_publisher_active_data_set_changed_callback(v67, 0);
        state_machine_next_state(v67 + 8, 1u);
        v97 = (int *)*v35;
        cti_track_active_data_set_((void *)(*v35 + 96), *v35, (uint64_t)dnssd_client_active_data_set_changed_callback, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-client.c", 721);
        __int16 v98 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v99 = *v97;
          *(_DWORD *)buf = 136447490;
          v151 = "dnssd_client_start";
          __int16 v152 = 1024;
          *(_DWORD *)v153 = v99;
          *(_WORD *)&v153[4] = 2048;
          *(void *)&v153[6] = v97;
          __int16 v154 = 2080;
          v155 = "client";
          __int16 v156 = 2080;
          v157 = "dnssd-client.c";
          __int16 v158 = 1024;
          int v159 = 722;
          _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        int v100 = *v97;
        if (*v97)
        {
          int v101 = v100 + 1;
          int *v97 = v100 + 1;
          if (v100 + 1 >= 10001)
          {
            uint64_t v74 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
              goto LABEL_264;
            }
            *(_DWORD *)buf = 136447490;
            v151 = "dnssd_client_start";
            __int16 v152 = 1024;
            *(_DWORD *)v153 = v101;
            *(_WORD *)&v153[4] = 2048;
            *(void *)&v153[6] = v97;
            __int16 v154 = 2080;
            v155 = "client";
            __int16 v156 = 2080;
            v157 = "dnssd-client.c";
            __int16 v158 = 1024;
            int v159 = 722;
            __int16 v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
            goto LABEL_159;
          }
        }
        else
        {
          ++dnssd_client_created;
          int *v97 = 1;
        }
        dnssd_client_active_data_set_changed_callback((uint64_t)v97, 0);
        state_machine_next_state((uint64_t)(v97 + 2), 1u);
        return;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v94 = *(_DWORD *)v67;
        *(_DWORD *)buf = 136447490;
        v151 = "service_publisher_start";
        __int16 v152 = 1024;
        *(_DWORD *)v153 = v94;
        *(_WORD *)&v153[4] = 2048;
        *(void *)&v153[6] = v67;
        __int16 v154 = 2080;
        v155 = "publisher";
        __int16 v156 = 2080;
        v157 = "service-publisher.c";
        __int16 v158 = 1024;
        int v159 = 1878;
        _os_log_impl((void *)&_mh_execute_header, v93, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      }
      int v95 = *(_DWORD *)v67;
      if (!*(_DWORD *)v67)
      {
        ++service_publisher_created;
        *(_DWORD *)uint64_t v67 = 1;
        goto LABEL_153;
      }
      int v96 = v95 + 1;
      *(_DWORD *)uint64_t v67 = v95 + 1;
      if (v95 + 1 < 10001) {
        goto LABEL_153;
      }
      uint64_t v74 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_264;
      }
      *(_DWORD *)buf = 136447490;
      v151 = "service_publisher_start";
      __int16 v152 = 1024;
      *(_DWORD *)v153 = v96;
      *(_WORD *)&v153[4] = 2048;
      *(void *)&v153[6] = v67;
      __int16 v154 = 2080;
      v155 = "publisher";
      __int16 v156 = 2080;
      v157 = "service-publisher.c";
      __int16 v158 = 1024;
      int v159 = 1878;
      __int16 v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_159:
      uint64_t v66 = buf;
      __int16 v102 = v74;
LABEL_263:
      _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_FAULT, v24, v66, 0x36u);
      goto LABEL_264;
    }
LABEL_214:
    v136 = malloc_type_calloc(1uLL, 0xB0uLL, 0x10F004009DEA24DuLL);
    uint64_t v45 = global_os_log;
    if (!v136)
    {
LABEL_247:
      *CFUUIDRef v35 = 0;
      if (!os_log_type_enabled(v45, OS_LOG_TYPE_FAULT)) {
        return;
      }
      *(_DWORD *)buf = 136446210;
      v151 = "thread_device_rloc16_callback";
      int v5 = "%{public}s: can't create dnssd client";
LABEL_249:
      CFDateRef v6 = v45;
      goto LABEL_250;
    }
    uint64_t v137 = (uint64_t)v136;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v138 = *(_DWORD *)v137;
      *(_DWORD *)v160 = 136447490;
      v161 = "dnssd_client_create";
      __int16 v162 = 1024;
      *(_DWORD *)v163 = v138;
      *(_WORD *)&v163[4] = 2048;
      *(void *)&v163[6] = v137;
      *(_WORD *)&v163[14] = 2080;
      *(void *)&v163[16] = "client";
      *(_WORD *)&v163[24] = 2080;
      *(void *)&v163[26] = "dnssd-client.c";
      __int16 v164 = 1024;
      int v165 = 633;
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v160, 0x36u);
    }
    int v139 = *(_DWORD *)v137;
    if (*(_DWORD *)v137)
    {
      int v140 = v139 + 1;
      *(_DWORD *)uint64_t v137 = v139 + 1;
      if (v139 + 1 >= 10001)
      {
        uint64_t v23 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_264;
        }
        *(_DWORD *)v160 = 136447490;
        v161 = "dnssd_client_create";
        __int16 v162 = 1024;
        *(_DWORD *)v163 = v140;
        *(_WORD *)&v163[4] = 2048;
        *(void *)&v163[6] = v137;
        *(_WORD *)&v163[14] = 2080;
        *(void *)&v163[16] = "client";
        *(_WORD *)&v163[24] = 2080;
        *(void *)&v163[26] = "dnssd-client.c";
        __int16 v164 = 1024;
        int v165 = 633;
        __int16 v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        goto LABEL_261;
      }
    }
    else
    {
      ++dnssd_client_created;
      *(_DWORD *)uint64_t v137 = 1;
    }
    v141 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-client.c", 634);
    *(void *)(v137 + 88) = v141;
    if (v141)
    {
      snprintf((char *)buf, 0x64uLL, "[DC%lld]", ++dnssd_client_serial_number);
      v142 = strdup((const char *)buf);
      *(void *)(v137 + 72) = v142;
      if (v142)
      {
        *(void *)(v137 + 160) = 0xFFFFFFFF00000002;
        *(_WORD *)(v137 + 168) = 853;
        if (state_machine_header_setup(v137 + 8, v137, v142, 3, (uint64_t)&dnssd_client_states, 5))
        {
          *(void *)(v137 + 80) = a1;
          if (service_tracker_callback_add(*(int **)(a1 + 40), (uint64_t)dnssd_client_service_tracker_callback, (uint64_t)dnssd_client_context_release, v137))
          {
            v143 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              int v144 = *(_DWORD *)v137;
              *(_DWORD *)v160 = 136447490;
              v161 = "dnssd_client_create";
              __int16 v162 = 1024;
              *(_DWORD *)v163 = v144;
              *(_WORD *)&v163[4] = 2048;
              *(void *)&v163[6] = v137;
              *(_WORD *)&v163[14] = 2080;
              *(void *)&v163[16] = "client";
              *(_WORD *)&v163[24] = 2080;
              *(void *)&v163[26] = "dnssd-client.c";
              __int16 v164 = 1024;
              int v165 = 666;
              _os_log_impl((void *)&_mh_execute_header, v143, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v160, 0x36u);
            }
            int v145 = *(_DWORD *)v137;
            if (*(_DWORD *)v137)
            {
              int v146 = v145 + 1;
              *(_DWORD *)uint64_t v137 = v145 + 1;
              if (v145 + 1 >= 10001)
              {
                uint64_t v23 = global_os_log;
                if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                  goto LABEL_264;
                }
                *(_DWORD *)v160 = 136447490;
                v161 = "dnssd_client_create";
                __int16 v162 = 1024;
                *(_DWORD *)v163 = v146;
                *(_WORD *)&v163[4] = 2048;
                *(void *)&v163[6] = v137;
                *(_WORD *)&v163[14] = 2080;
                *(void *)&v163[16] = "client";
                *(_WORD *)&v163[24] = 2080;
                *(void *)&v163[26] = "dnssd-client.c";
                __int16 v164 = 1024;
                int v165 = 666;
                __int16 v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
                goto LABEL_261;
              }
            }
            else
            {
              ++dnssd_client_created;
              *(_DWORD *)uint64_t v137 = 1;
            }
            *CFUUIDRef v35 = v137;
            goto LABEL_56;
          }
          goto LABEL_239;
        }
        v147 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v160 = 136446210;
          v161 = "dnssd_client_create";
          v148 = "%{public}s: header setup failed";
          goto LABEL_238;
        }
LABEL_239:
        int v149 = *(_DWORD *)v137;
        if (!*(_DWORD *)v137)
        {
          uint64_t v23 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
            goto LABEL_264;
          }
          *(_DWORD *)v160 = 136447490;
          v161 = "dnssd_client_create";
          __int16 v162 = 1024;
          *(_DWORD *)v163 = 0;
          *(_WORD *)&v163[4] = 2048;
          *(void *)&v163[6] = v137;
          *(_WORD *)&v163[14] = 2080;
          *(void *)&v163[16] = "client";
          *(_WORD *)&v163[24] = 2080;
          *(void *)&v163[26] = "dnssd-client.c";
          __int16 v164 = 1024;
          int v165 = 672;
          __int16 v24 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
          goto LABEL_261;
        }
        uint64_t v45 = global_os_log;
        if (v149 < 10001)
        {
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)v160 = 136447490;
            v161 = "dnssd_client_create";
            __int16 v162 = 1024;
            *(_DWORD *)v163 = v149;
            *(_WORD *)&v163[4] = 2048;
            *(void *)&v163[6] = v137;
            *(_WORD *)&v163[14] = 2080;
            *(void *)&v163[16] = "client";
            *(_WORD *)&v163[24] = 2080;
            *(void *)&v163[26] = "dnssd-client.c";
            __int16 v164 = 1024;
            int v165 = 672;
            _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v160, 0x36u);
            int v149 = *(_DWORD *)v137;
            uint64_t v45 = global_os_log;
          }
          *(_DWORD *)uint64_t v137 = v149 - 1;
          if (v149 == 1)
          {
            if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)v160 = 136447234;
              v161 = "dnssd_client_create";
              __int16 v162 = 2048;
              *(void *)v163 = v137;
              *(_WORD *)&v163[8] = 2080;
              *(void *)&v163[10] = "client";
              *(_WORD *)&v163[18] = 2080;
              *(void *)&v163[20] = "dnssd-client.c";
              *(_WORD *)&v163[28] = 1024;
              *(_DWORD *)&v163[30] = 672;
              _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v160, 0x30u);
            }
            ++dnssd_client_finalized;
            dnssd_client_finalize(v137);
            uint64_t v45 = global_os_log;
          }
          goto LABEL_247;
        }
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_264:
        }
          abort();
        *(_DWORD *)v160 = 136447490;
        v161 = "dnssd_client_create";
        __int16 v162 = 1024;
        *(_DWORD *)v163 = v149;
        *(_WORD *)&v163[4] = 2048;
        *(void *)&v163[6] = v137;
        *(_WORD *)&v163[14] = 2080;
        *(void *)&v163[16] = "client";
        *(_WORD *)&v163[24] = 2080;
        *(void *)&v163[26] = "dnssd-client.c";
        __int16 v164 = 1024;
        int v165 = 672;
        __int16 v24 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_267:
        uint64_t v66 = v160;
        __int16 v102 = v45;
        goto LABEL_263;
      }
      v147 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
        goto LABEL_239;
      }
      *(_DWORD *)v160 = 136446210;
      v161 = "dnssd_client_create";
      v148 = "%{public}s: no memory for client ID";
    }
    else
    {
      v147 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
        goto LABEL_239;
      }
      *(_DWORD *)v160 = 136446210;
      v161 = "dnssd_client_create";
      v148 = "%{public}s: wakeup timer alloc failed";
    }
LABEL_238:
    _os_log_impl((void *)&_mh_execute_header, v147, OS_LOG_TYPE_ERROR, v148, v160, 0xCu);
    goto LABEL_239;
  }
  uint64_t v44 = malloc_type_calloc(1uLL, 0x110uLL, 0x10F00405A5F544EuLL);
  uint64_t v45 = global_os_log;
  if (!v44) {
    goto LABEL_120;
  }
  uint64_t v46 = (uint64_t)v44;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v47 = *(_DWORD *)v46;
    *(_DWORD *)v160 = 136447490;
    v161 = "service_publisher_create";
    __int16 v162 = 1024;
    *(_DWORD *)v163 = v47;
    *(_WORD *)&v163[4] = 2048;
    *(void *)&v163[6] = v46;
    *(_WORD *)&v163[14] = 2080;
    *(void *)&v163[16] = "publisher";
    *(_WORD *)&v163[24] = 2080;
    *(void *)&v163[26] = "service-publisher.c";
    __int16 v164 = 1024;
    int v165 = 1517;
    _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v160, 0x36u);
  }
  int v48 = *(_DWORD *)v46;
  if (*(_DWORD *)v46)
  {
    int v49 = v48 + 1;
    *(_DWORD *)uint64_t v46 = v48 + 1;
    if (v48 + 1 >= 10001)
    {
      uint64_t v23 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_264;
      }
      *(_DWORD *)v160 = 136447490;
      v161 = "service_publisher_create";
      __int16 v162 = 1024;
      *(_DWORD *)v163 = v49;
      *(_WORD *)&v163[4] = 2048;
      *(void *)&v163[6] = v46;
      *(_WORD *)&v163[14] = 2080;
      *(void *)&v163[16] = "publisher";
      *(_WORD *)&v163[24] = 2080;
      *(void *)&v163[26] = "service-publisher.c";
      __int16 v164 = 1024;
      int v165 = 1517;
      __int16 v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_261:
      uint64_t v66 = v160;
      goto LABEL_262;
    }
  }
  else
  {
    ++service_publisher_created;
    *(_DWORD *)uint64_t v46 = 1;
  }
  OSStatus v50 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 1518);
  *(void *)(v46 + 96) = v50;
  if (!v50)
  {
    uint64_t v56 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_112;
    }
    *(_DWORD *)v160 = 136446210;
    v161 = "service_publisher_create";
    size_t v57 = "%{public}s: wakeup timer alloc failed";
    goto LABEL_110;
  }
  snprintf((char *)buf, 0x64uLL, "[SP%lld]", ++service_publisher_serial_number);
  BOOL v51 = strdup((const char *)buf);
  *(void *)(v46 + 72) = v51;
  if (!v51)
  {
    uint64_t v56 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_112;
    }
    *(_DWORD *)v160 = 136446210;
    v161 = "service_publisher_create";
    size_t v57 = "%{public}s: no memory for server ID";
    goto LABEL_110;
  }
  if ((state_machine_header_setup(v46 + 8, v46, v51, 2, (uint64_t)&service_publisher_states, 6) & 1) == 0)
  {
    uint64_t v56 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_112;
    }
    *(_DWORD *)v160 = 136446210;
    v161 = "service_publisher_create";
    size_t v57 = "%{public}s: header setup failed";
LABEL_110:
    __int16 v75 = v56;
    os_log_type_t v76 = OS_LOG_TYPE_ERROR;
    uint32_t v77 = 12;
    goto LABEL_111;
  }
  *(void *)(v46 + 88) = a1;
  if (!service_tracker_callback_add(*(int **)(a1 + 40), (uint64_t)service_publisher_service_tracker_callback, (uint64_t)service_publisher_context_release, v46))goto LABEL_112; {
  CFStringRef v52 = global_os_log;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v53 = *(_DWORD *)v46;
    *(_DWORD *)v160 = 136447490;
    v161 = "service_publisher_create";
    __int16 v162 = 1024;
    *(_DWORD *)v163 = v53;
    *(_WORD *)&v163[4] = 2048;
    *(void *)&v163[6] = v46;
    *(_WORD *)&v163[14] = 2080;
    *(void *)&v163[16] = "publisher";
    *(_WORD *)&v163[24] = 2080;
    *(void *)&v163[26] = "service-publisher.c";
    __int16 v164 = 1024;
    int v165 = 1547;
    _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v160, 0x36u);
  }
  int v54 = *(_DWORD *)v46;
  if (*(_DWORD *)v46)
  {
    int v55 = v54 + 1;
    *(_DWORD *)uint64_t v46 = v54 + 1;
    if (v54 + 1 >= 10001)
    {
      uint64_t v23 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_264;
      }
      *(_DWORD *)v160 = 136447490;
      v161 = "service_publisher_create";
      __int16 v162 = 1024;
      *(_DWORD *)v163 = v55;
      *(_WORD *)&v163[4] = 2048;
      *(void *)&v163[6] = v46;
      *(_WORD *)&v163[14] = 2080;
      *(void *)&v163[16] = "publisher";
      *(_WORD *)&v163[24] = 2080;
      *(void *)&v163[26] = "service-publisher.c";
      __int16 v164 = 1024;
      int v165 = 1547;
      __int16 v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_261;
    }
  }
  else
  {
    ++service_publisher_created;
    *(_DWORD *)uint64_t v46 = 1;
  }
  v103 = *(int **)(a1 + 56);
  v104 = v103 + 12;
  while (1)
  {
    v105 = (void *)*v104;
    if (!*v104) {
      break;
    }
    v104 = (void *)*v104;
    if (v105[3] == v46)
    {
      uint64_t v106 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        uint64_t v107 = *((void *)v103 + 1);
        *(_DWORD *)v160 = 136446722;
        v161 = "thread_tracker_callback_add";
        __int16 v162 = 2048;
        *(void *)v163 = v107;
        *(_WORD *)&v163[8] = 2048;
        *(void *)&v163[10] = v46;
        size_t v57 = "%{public}s: [TT%lld] duplicate context %p";
        goto LABEL_192;
      }
      goto LABEL_112;
    }
  }
  __int16 v108 = malloc_type_calloc(1uLL, 0x20uLL, 0xA00403705585FuLL);
  if (!v108)
  {
    uint64_t v114 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_112;
    }
    uint64_t v115 = *((void *)v103 + 1);
    *(_DWORD *)v160 = 136446466;
    v161 = "thread_tracker_callback_add";
    __int16 v162 = 2048;
    *(void *)v163 = v115;
    size_t v57 = "%{public}s: [TT%lld] no memory";
    goto LABEL_204;
  }
  uint64_t v109 = v108;
  v108[2] = service_publisher_thread_tracker_callback;
  v108[3] = v46;
  v108[1] = service_publisher_context_release;
  if (v103 && !*((void *)v103 + 6))
  {
    __int16 v110 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v111 = *v103;
      *(_DWORD *)v160 = 136447490;
      v161 = "thread_tracker_callback_add";
      __int16 v162 = 1024;
      *(_DWORD *)v163 = v111;
      *(_WORD *)&v163[4] = 2048;
      *(void *)&v163[6] = v103;
      *(_WORD *)&v163[14] = 2080;
      *(void *)&v163[16] = "tracker";
      *(_WORD *)&v163[24] = 2080;
      *(void *)&v163[26] = "thread-tracker.c";
      __int16 v164 = 1024;
      int v165 = 252;
      _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v160, 0x36u);
    }
    int v112 = *v103;
    if (*v103)
    {
      int v113 = v112 + 1;
      int *v103 = v112 + 1;
      if (v112 + 1 >= 10001)
      {
        uint64_t v23 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_264;
        }
        *(_DWORD *)v160 = 136447490;
        v161 = "thread_tracker_callback_add";
        __int16 v162 = 1024;
        *(_DWORD *)v163 = v113;
        *(_WORD *)&v163[4] = 2048;
        *(void *)&v163[6] = v103;
        *(_WORD *)&v163[14] = 2080;
        *(void *)&v163[16] = "tracker";
        *(_WORD *)&v163[24] = 2080;
        *(void *)&v163[26] = "thread-tracker.c";
        __int16 v164 = 1024;
        int v165 = 252;
        __int16 v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        goto LABEL_261;
      }
    }
    else
    {
      ++thread_tracker_created;
      int *v103 = 1;
    }
  }
  void *v104 = v109;
  __int16 v116 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v117 = *(_DWORD *)v46;
    *(_DWORD *)v160 = 136447490;
    v161 = "service_publisher_create";
    __int16 v162 = 1024;
    *(_DWORD *)v163 = v117;
    *(_WORD *)&v163[4] = 2048;
    *(void *)&v163[6] = v46;
    *(_WORD *)&v163[14] = 2080;
    *(void *)&v163[16] = "publisher";
    *(_WORD *)&v163[24] = 2080;
    *(void *)&v163[26] = "service-publisher.c";
    __int16 v164 = 1024;
    int v165 = 1554;
    _os_log_impl((void *)&_mh_execute_header, v116, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v160, 0x36u);
  }
  int v118 = *(_DWORD *)v46;
  if (*(_DWORD *)v46)
  {
    int v119 = v118 + 1;
    *(_DWORD *)uint64_t v46 = v118 + 1;
    if (v118 + 1 >= 10001)
    {
      uint64_t v23 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_264;
      }
      *(_DWORD *)v160 = 136447490;
      v161 = "service_publisher_create";
      __int16 v162 = 1024;
      *(_DWORD *)v163 = v119;
      *(_WORD *)&v163[4] = 2048;
      *(void *)&v163[6] = v46;
      *(_WORD *)&v163[14] = 2080;
      *(void *)&v163[16] = "publisher";
      *(_WORD *)&v163[24] = 2080;
      *(void *)&v163[26] = "service-publisher.c";
      __int16 v164 = 1024;
      int v165 = 1554;
      __int16 v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_261;
    }
  }
  else
  {
    ++service_publisher_created;
    *(_DWORD *)uint64_t v46 = 1;
  }
  v120 = *(int **)(a1 + 64);
  v121 = v120 + 12;
  do
  {
    v122 = (void *)*v121;
    if (!*v121)
    {
      v124 = malloc_type_calloc(1uLL, 0x20uLL, 0xA00403705585FuLL);
      if (v124)
      {
        v125 = v124;
        v124[2] = service_publisher_node_type_tracker_callback;
        v124[3] = v46;
        v124[1] = service_publisher_context_release;
        if (v120 && !*((void *)v120 + 6))
        {
          v126 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v127 = *v120;
            *(_DWORD *)v160 = 136447490;
            v161 = "node_type_tracker_callback_add";
            __int16 v162 = 1024;
            *(_DWORD *)v163 = v127;
            *(_WORD *)&v163[4] = 2048;
            *(void *)&v163[6] = v120;
            *(_WORD *)&v163[14] = 2080;
            *(void *)&v163[16] = "tracker";
            *(_WORD *)&v163[24] = 2080;
            *(void *)&v163[26] = "node-type-tracker.c";
            __int16 v164 = 1024;
            int v165 = 225;
            _os_log_impl((void *)&_mh_execute_header, v126, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v160, 0x36u);
          }
          int v128 = *v120;
          if (*v120)
          {
            int v129 = v128 + 1;
            int *v120 = v128 + 1;
            if (v128 + 1 >= 10001)
            {
              uint64_t v23 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                goto LABEL_264;
              }
              *(_DWORD *)v160 = 136447490;
              v161 = "node_type_tracker_callback_add";
              __int16 v162 = 1024;
              *(_DWORD *)v163 = v129;
              *(_WORD *)&v163[4] = 2048;
              *(void *)&v163[6] = v120;
              *(_WORD *)&v163[14] = 2080;
              *(void *)&v163[16] = "tracker";
              *(_WORD *)&v163[24] = 2080;
              *(void *)&v163[26] = "node-type-tracker.c";
              __int16 v164 = 1024;
              int v165 = 225;
              __int16 v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
              goto LABEL_261;
            }
          }
          else
          {
            ++node_type_tracker_created;
            int *v120 = 1;
          }
        }
        void *v121 = v125;
        v131 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v132 = *(_DWORD *)v46;
          *(_DWORD *)v160 = 136447490;
          v161 = "service_publisher_create";
          __int16 v162 = 1024;
          *(_DWORD *)v163 = v132;
          *(_WORD *)&v163[4] = 2048;
          *(void *)&v163[6] = v46;
          *(_WORD *)&v163[14] = 2080;
          *(void *)&v163[16] = "publisher";
          *(_WORD *)&v163[24] = 2080;
          *(void *)&v163[26] = "service-publisher.c";
          __int16 v164 = 1024;
          int v165 = 1561;
          _os_log_impl((void *)&_mh_execute_header, v131, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v160, 0x36u);
        }
        int v133 = *(_DWORD *)v46;
        if (*(_DWORD *)v46)
        {
          int v134 = v133 + 1;
          *(_DWORD *)uint64_t v46 = v133 + 1;
          if (v133 + 1 >= 10001)
          {
            uint64_t v23 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
              goto LABEL_264;
            }
            *(_DWORD *)v160 = 136447490;
            v161 = "service_publisher_create";
            __int16 v162 = 1024;
            *(_DWORD *)v163 = v134;
            *(_WORD *)&v163[4] = 2048;
            *(void *)&v163[6] = v46;
            *(_WORD *)&v163[14] = 2080;
            *(void *)&v163[16] = "publisher";
            *(_WORD *)&v163[24] = 2080;
            *(void *)&v163[26] = "service-publisher.c";
            __int16 v164 = 1024;
            int v165 = 1561;
            __int16 v24 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
            goto LABEL_261;
          }
        }
        else
        {
          ++service_publisher_created;
          *(_DWORD *)uint64_t v46 = 1;
        }
        *(unsigned char *)(v46 + 259) = 1;
        *(_DWORD *)(v46 + 248) = 750;
        CFUUIDRef v35 = (uint64_t *)(a1 + 128);
        uint64_t v135 = *(void *)(a1 + 128);
        *(void *)(a1 + 48) = v46;
        if (v135) {
          goto LABEL_56;
        }
        goto LABEL_214;
      }
      uint64_t v114 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
        goto LABEL_112;
      }
      uint64_t v130 = *((void *)v120 + 1);
      *(_DWORD *)v160 = 136446466;
      v161 = "node_type_tracker_callback_add";
      __int16 v162 = 2048;
      *(void *)v163 = v130;
      size_t v57 = "%{public}s: [TT%lld] no memory";
LABEL_204:
      __int16 v75 = v114;
      os_log_type_t v76 = OS_LOG_TYPE_ERROR;
      uint32_t v77 = 22;
      goto LABEL_111;
    }
    v121 = (void *)*v121;
  }
  while (v122[3] != v46);
  uint64_t v106 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
  {
    uint64_t v123 = *((void *)v120 + 1);
    *(_DWORD *)v160 = 136446722;
    v161 = "node_type_tracker_callback_add";
    __int16 v162 = 2048;
    *(void *)v163 = v123;
    *(_WORD *)&v163[8] = 2048;
    *(void *)&v163[10] = v46;
    size_t v57 = "%{public}s: [TT%lld] duplicate context %p";
LABEL_192:
    __int16 v75 = v106;
    os_log_type_t v76 = OS_LOG_TYPE_FAULT;
    uint32_t v77 = 32;
LABEL_111:
    _os_log_impl((void *)&_mh_execute_header, v75, v76, v57, v160, v77);
  }
LABEL_112:
  int v78 = *(_DWORD *)v46;
  if (!*(_DWORD *)v46)
  {
    uint64_t v23 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_264;
    }
    *(_DWORD *)v160 = 136447490;
    v161 = "service_publisher_create";
    __int16 v162 = 1024;
    *(_DWORD *)v163 = 0;
    *(_WORD *)&v163[4] = 2048;
    *(void *)&v163[6] = v46;
    *(_WORD *)&v163[14] = 2080;
    *(void *)&v163[16] = "publisher";
    *(_WORD *)&v163[24] = 2080;
    *(void *)&v163[26] = "service-publisher.c";
    __int16 v164 = 1024;
    int v165 = 1570;
    __int16 v24 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_261;
  }
  uint64_t v45 = global_os_log;
  if (v78 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_264;
    }
    *(_DWORD *)v160 = 136447490;
    v161 = "service_publisher_create";
    __int16 v162 = 1024;
    *(_DWORD *)v163 = v78;
    *(_WORD *)&v163[4] = 2048;
    *(void *)&v163[6] = v46;
    *(_WORD *)&v163[14] = 2080;
    *(void *)&v163[16] = "publisher";
    *(_WORD *)&v163[24] = 2080;
    *(void *)&v163[26] = "service-publisher.c";
    __int16 v164 = 1024;
    int v165 = 1570;
    __int16 v24 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_267;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)v160 = 136447490;
    v161 = "service_publisher_create";
    __int16 v162 = 1024;
    *(_DWORD *)v163 = v78;
    *(_WORD *)&v163[4] = 2048;
    *(void *)&v163[6] = v46;
    *(_WORD *)&v163[14] = 2080;
    *(void *)&v163[16] = "publisher";
    *(_WORD *)&v163[24] = 2080;
    *(void *)&v163[26] = "service-publisher.c";
    __int16 v164 = 1024;
    int v165 = 1570;
    _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v160, 0x36u);
    int v78 = *(_DWORD *)v46;
    uint64_t v45 = global_os_log;
  }
  *(_DWORD *)uint64_t v46 = v78 - 1;
  if (v78 == 1)
  {
    if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)v160 = 136447234;
      v161 = "service_publisher_create";
      __int16 v162 = 2048;
      *(void *)v163 = v46;
      *(_WORD *)&v163[8] = 2080;
      *(void *)&v163[10] = "publisher";
      *(_WORD *)&v163[18] = 2080;
      *(void *)&v163[20] = "service-publisher.c";
      *(_WORD *)&v163[28] = 1024;
      *(_DWORD *)&v163[30] = 1570;
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v160, 0x30u);
    }
    ++service_publisher_finalized;
    service_publisher_finalize(v46);
    uint64_t v45 = global_os_log;
  }
LABEL_120:
  *(void *)(a1 + 48) = 0;
  if (os_log_type_enabled(v45, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)buf = 136446210;
    v151 = "thread_device_rloc16_callback";
    int v5 = "%{public}s: can't create service publisher.";
    goto LABEL_249;
  }
}

void thread_device_stop(uint64_t *a1)
{
  CFDateRef v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v43 = 136446210;
    uint64_t v44 = "thread_device_stop";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: stopping", (uint8_t *)&v43, 0xCu);
  }
  uint64_t v3 = a1[5];
  if (v3)
  {
    service_tracker_cancel_probes(v3);
    uint64_t v4 = (void *)a1[5];
    if (v4)
    {
      service_tracker_stop((void *)a1[5]);
      int v5 = (void *)v4[5];
      if (v5)
      {
        do
        {
          os_log_type_t v7 = (void *)*v5;
          CFDateRef v6 = (void (*)(void))v5[1];
          if (v6) {
            v6(v5[3]);
          }
          free(v5);
          int v5 = v7;
        }
        while (v7);
        v4[5] = 0;
        int v8 = *(_DWORD *)v4;
        if (!*(_DWORD *)v4)
        {
          uint64_t v40 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
            goto LABEL_131;
          }
          int v43 = 136447490;
          uint64_t v44 = "service_tracker_cancel";
          __int16 v45 = 1024;
          *(_DWORD *)uint64_t v46 = 0;
          *(_WORD *)&v46[4] = 2048;
          *(void *)&v46[6] = v4;
          *(_WORD *)&v46[14] = 2080;
          *(void *)&v46[16] = "tracker";
          *(_WORD *)&v46[24] = 2080;
          *(void *)&v46[26] = "service-tracker.c";
          __int16 v47 = 1024;
          int v48 = 473;
          int v41 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
          goto LABEL_126;
        }
        __int16 v9 = global_os_log;
        if (v8 >= 10001)
        {
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
            goto LABEL_131;
          }
          int v43 = 136447490;
          uint64_t v44 = "service_tracker_cancel";
          __int16 v45 = 1024;
          *(_DWORD *)uint64_t v46 = v8;
          *(_WORD *)&v46[4] = 2048;
          *(void *)&v46[6] = v4;
          *(_WORD *)&v46[14] = 2080;
          *(void *)&v46[16] = "tracker";
          *(_WORD *)&v46[24] = 2080;
          *(void *)&v46[26] = "service-tracker.c";
          __int16 v47 = 1024;
          int v48 = 473;
          int v41 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
          goto LABEL_129;
        }
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v43 = 136447490;
          uint64_t v44 = "service_tracker_cancel";
          __int16 v45 = 1024;
          *(_DWORD *)uint64_t v46 = v8;
          *(_WORD *)&v46[4] = 2048;
          *(void *)&v46[6] = v4;
          *(_WORD *)&v46[14] = 2080;
          *(void *)&v46[16] = "tracker";
          *(_WORD *)&v46[24] = 2080;
          *(void *)&v46[26] = "service-tracker.c";
          __int16 v47 = 1024;
          int v48 = 473;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v43, 0x36u);
          int v8 = *(_DWORD *)v4;
        }
        *(_DWORD *)uint64_t v4 = v8 - 1;
        if (v8 == 1)
        {
          int v10 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v43 = 136447234;
            uint64_t v44 = "service_tracker_cancel";
            __int16 v45 = 2048;
            *(void *)uint64_t v46 = v4;
            *(_WORD *)&v46[8] = 2080;
            *(void *)&v46[10] = "tracker";
            *(_WORD *)&v46[18] = 2080;
            *(void *)&v46[20] = "service-tracker.c";
            *(_WORD *)&v46[28] = 1024;
            *(_DWORD *)&v46[30] = 473;
            _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v43, 0x30u);
          }
          ++service_tracker_finalized;
          service_tracker_finalize(v4);
        }
      }
      long long v11 = (void *)a1[5];
      if (v11)
      {
        int v12 = *(_DWORD *)v11;
        if (!*(_DWORD *)v11)
        {
          uint64_t v40 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
            goto LABEL_131;
          }
          int v43 = 136447490;
          uint64_t v44 = "service_tracker_release_";
          __int16 v45 = 1024;
          *(_DWORD *)uint64_t v46 = 0;
          *(_WORD *)&v46[4] = 2048;
          *(void *)&v46[6] = v11;
          *(_WORD *)&v46[14] = 2080;
          *(void *)&v46[16] = "omw";
          *(_WORD *)&v46[24] = 2080;
          *(void *)&v46[26] = "thread-device.c";
          __int16 v47 = 1024;
          int v48 = 148;
          int v41 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
          goto LABEL_126;
        }
        __int16 v9 = global_os_log;
        if (v12 >= 10001)
        {
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
            goto LABEL_131;
          }
          int v43 = 136447490;
          uint64_t v44 = "service_tracker_release_";
          __int16 v45 = 1024;
          *(_DWORD *)uint64_t v46 = v12;
          *(_WORD *)&v46[4] = 2048;
          *(void *)&v46[6] = v11;
          *(_WORD *)&v46[14] = 2080;
          *(void *)&v46[16] = "omw";
          *(_WORD *)&v46[24] = 2080;
          *(void *)&v46[26] = "thread-device.c";
          __int16 v47 = 1024;
          int v48 = 148;
          int v41 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
          goto LABEL_129;
        }
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v43 = 136447490;
          uint64_t v44 = "service_tracker_release_";
          __int16 v45 = 1024;
          *(_DWORD *)uint64_t v46 = v12;
          *(_WORD *)&v46[4] = 2048;
          *(void *)&v46[6] = v11;
          *(_WORD *)&v46[14] = 2080;
          *(void *)&v46[16] = "omw";
          *(_WORD *)&v46[24] = 2080;
          *(void *)&v46[26] = "thread-device.c";
          __int16 v47 = 1024;
          int v48 = 148;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v43, 0x36u);
          int v12 = *(_DWORD *)v11;
        }
        *(_DWORD *)long long v11 = v12 - 1;
        if (v12 == 1)
        {
          CFIndex v13 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v43 = 136447234;
            uint64_t v44 = "service_tracker_release_";
            __int16 v45 = 2048;
            *(void *)uint64_t v46 = v11;
            *(_WORD *)&v46[8] = 2080;
            *(void *)&v46[10] = "omw";
            *(_WORD *)&v46[18] = 2080;
            *(void *)&v46[20] = "thread-device.c";
            *(_WORD *)&v46[28] = 1024;
            *(_DWORD *)&v46[30] = 148;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v43, 0x30u);
          }
          ++service_tracker_finalized;
          service_tracker_finalize(v11);
        }
      }
    }
    a1[5] = 0;
  }
  uint64_t v14 = (void *)a1[7];
  if (v14)
  {
    uint64_t v15 = v14[5];
    if (v15)
    {
      cti_events_discontinue(v15);
      v14[5] = 0;
      int v16 = *(_DWORD *)v14;
      if (!*(_DWORD *)v14)
      {
        uint64_t v40 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_131;
        }
        int v43 = 136447490;
        uint64_t v44 = "thread_tracker_cancel";
        __int16 v45 = 1024;
        *(_DWORD *)uint64_t v46 = 0;
        *(_WORD *)&v46[4] = 2048;
        *(void *)&v46[6] = v14;
        *(_WORD *)&v46[14] = 2080;
        *(void *)&v46[16] = "tracker";
        *(_WORD *)&v46[24] = 2080;
        *(void *)&v46[26] = "thread-tracker.c";
        __int16 v47 = 1024;
        int v48 = 282;
        int v41 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_126;
      }
      __int16 v9 = global_os_log;
      if (v16 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_131;
        }
        int v43 = 136447490;
        uint64_t v44 = "thread_tracker_cancel";
        __int16 v45 = 1024;
        *(_DWORD *)uint64_t v46 = v16;
        *(_WORD *)&v46[4] = 2048;
        *(void *)&v46[6] = v14;
        *(_WORD *)&v46[14] = 2080;
        *(void *)&v46[16] = "tracker";
        *(_WORD *)&v46[24] = 2080;
        *(void *)&v46[26] = "thread-tracker.c";
        __int16 v47 = 1024;
        int v48 = 282;
        int v41 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_129;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v43 = 136447490;
        uint64_t v44 = "thread_tracker_cancel";
        __int16 v45 = 1024;
        *(_DWORD *)uint64_t v46 = v16;
        *(_WORD *)&v46[4] = 2048;
        *(void *)&v46[6] = v14;
        *(_WORD *)&v46[14] = 2080;
        *(void *)&v46[16] = "tracker";
        *(_WORD *)&v46[24] = 2080;
        *(void *)&v46[26] = "thread-tracker.c";
        __int16 v47 = 1024;
        int v48 = 282;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v43, 0x36u);
        int v16 = *(_DWORD *)v14;
      }
      *(_DWORD *)uint64_t v14 = v16 - 1;
      if (v16 == 1)
      {
        CFDictionaryRef v17 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v43 = 136447234;
          uint64_t v44 = "thread_tracker_cancel";
          __int16 v45 = 2048;
          *(void *)uint64_t v46 = v14;
          *(_WORD *)&v46[8] = 2080;
          *(void *)&v46[10] = "tracker";
          *(_WORD *)&v46[18] = 2080;
          *(void *)&v46[20] = "thread-tracker.c";
          *(_WORD *)&v46[28] = 1024;
          *(_DWORD *)&v46[30] = 282;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v43, 0x30u);
        }
        ++thread_tracker_finalized;
        free(v14);
      }
    }
    __int16 v18 = (void *)v14[6];
    if (v18)
    {
      do
      {
        int v20 = (void *)*v18;
        CFStringRef v19 = (void (*)(void))v18[1];
        if (v19) {
          v19(v18[3]);
        }
        free(v18);
        __int16 v18 = v20;
      }
      while (v20);
      v14[6] = 0;
      int v21 = *(_DWORD *)v14;
      if (!*(_DWORD *)v14)
      {
        uint64_t v40 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_131;
        }
        int v43 = 136447490;
        uint64_t v44 = "thread_tracker_cancel";
        __int16 v45 = 1024;
        *(_DWORD *)uint64_t v46 = 0;
        *(_WORD *)&v46[4] = 2048;
        *(void *)&v46[6] = v14;
        *(_WORD *)&v46[14] = 2080;
        *(void *)&v46[16] = "tracker";
        *(_WORD *)&v46[24] = 2080;
        *(void *)&v46[26] = "thread-tracker.c";
        __int16 v47 = 1024;
        int v48 = 292;
        int v41 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_126;
      }
      __int16 v9 = global_os_log;
      if (v21 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_131;
        }
        int v43 = 136447490;
        uint64_t v44 = "thread_tracker_cancel";
        __int16 v45 = 1024;
        *(_DWORD *)uint64_t v46 = v21;
        *(_WORD *)&v46[4] = 2048;
        *(void *)&v46[6] = v14;
        *(_WORD *)&v46[14] = 2080;
        *(void *)&v46[16] = "tracker";
        *(_WORD *)&v46[24] = 2080;
        *(void *)&v46[26] = "thread-tracker.c";
        __int16 v47 = 1024;
        int v48 = 292;
        int v41 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_129;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v43 = 136447490;
        uint64_t v44 = "thread_tracker_cancel";
        __int16 v45 = 1024;
        *(_DWORD *)uint64_t v46 = v21;
        *(_WORD *)&v46[4] = 2048;
        *(void *)&v46[6] = v14;
        *(_WORD *)&v46[14] = 2080;
        *(void *)&v46[16] = "tracker";
        *(_WORD *)&v46[24] = 2080;
        *(void *)&v46[26] = "thread-tracker.c";
        __int16 v47 = 1024;
        int v48 = 292;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v43, 0x36u);
        int v21 = *(_DWORD *)v14;
      }
      *(_DWORD *)uint64_t v14 = v21 - 1;
      if (v21 == 1)
      {
        int v22 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v43 = 136447234;
          uint64_t v44 = "thread_tracker_cancel";
          __int16 v45 = 2048;
          *(void *)uint64_t v46 = v14;
          *(_WORD *)&v46[8] = 2080;
          *(void *)&v46[10] = "tracker";
          *(_WORD *)&v46[18] = 2080;
          *(void *)&v46[20] = "thread-tracker.c";
          *(_WORD *)&v46[28] = 1024;
          *(_DWORD *)&v46[30] = 292;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v43, 0x30u);
        }
        ++thread_tracker_finalized;
        free(v14);
      }
    }
    uint64_t v23 = (int *)a1[7];
    if (v23)
    {
      int v24 = *v23;
      if (!*v23)
      {
        uint64_t v40 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_131;
        }
        int v43 = 136447490;
        uint64_t v44 = "thread_tracker_release_";
        __int16 v45 = 1024;
        *(_DWORD *)uint64_t v46 = 0;
        *(_WORD *)&v46[4] = 2048;
        *(void *)&v46[6] = v23;
        *(_WORD *)&v46[14] = 2080;
        *(void *)&v46[16] = "omw";
        *(_WORD *)&v46[24] = 2080;
        *(void *)&v46[26] = "thread-device.c";
        __int16 v47 = 1024;
        int v48 = 153;
        int v41 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_126;
      }
      __int16 v9 = global_os_log;
      if (v24 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_131;
        }
        int v43 = 136447490;
        uint64_t v44 = "thread_tracker_release_";
        __int16 v45 = 1024;
        *(_DWORD *)uint64_t v46 = v24;
        *(_WORD *)&v46[4] = 2048;
        *(void *)&v46[6] = v23;
        *(_WORD *)&v46[14] = 2080;
        *(void *)&v46[16] = "omw";
        *(_WORD *)&v46[24] = 2080;
        *(void *)&v46[26] = "thread-device.c";
        __int16 v47 = 1024;
        int v48 = 153;
        int v41 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_129;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v43 = 136447490;
        uint64_t v44 = "thread_tracker_release_";
        __int16 v45 = 1024;
        *(_DWORD *)uint64_t v46 = v24;
        *(_WORD *)&v46[4] = 2048;
        *(void *)&v46[6] = v23;
        *(_WORD *)&v46[14] = 2080;
        *(void *)&v46[16] = "omw";
        *(_WORD *)&v46[24] = 2080;
        *(void *)&v46[26] = "thread-device.c";
        __int16 v47 = 1024;
        int v48 = 153;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v43, 0x36u);
        int v24 = *v23;
      }
      *uint64_t v23 = v24 - 1;
      if (v24 == 1)
      {
        CFTypeID v25 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v43 = 136447234;
          uint64_t v44 = "thread_tracker_release_";
          __int16 v45 = 2048;
          *(void *)uint64_t v46 = v23;
          *(_WORD *)&v46[8] = 2080;
          *(void *)&v46[10] = "omw";
          *(_WORD *)&v46[18] = 2080;
          *(void *)&v46[20] = "thread-device.c";
          *(_WORD *)&v46[28] = 1024;
          *(_DWORD *)&v46[30] = 153;
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v43, 0x30u);
        }
        ++thread_tracker_finalized;
        free(v23);
      }
    }
    a1[7] = 0;
  }
  CFMutableDictionaryRef v26 = (void *)a1[8];
  if (!v26) {
    goto LABEL_91;
  }
  uint64_t v27 = v26[5];
  if (v27)
  {
    cti_events_discontinue(v27);
    v26[5] = 0;
    int v28 = *(_DWORD *)v26;
    if (!*(_DWORD *)v26)
    {
      uint64_t v40 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_131;
      }
      int v43 = 136447490;
      uint64_t v44 = "node_type_tracker_cancel";
      __int16 v45 = 1024;
      *(_DWORD *)uint64_t v46 = 0;
      *(_WORD *)&v46[4] = 2048;
      *(void *)&v46[6] = v26;
      *(_WORD *)&v46[14] = 2080;
      *(void *)&v46[16] = "tracker";
      *(_WORD *)&v46[24] = 2080;
      *(void *)&v46[26] = "node-type-tracker.c";
      __int16 v47 = 1024;
      int v48 = 255;
      int v41 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_126;
    }
    __int16 v9 = global_os_log;
    if (v28 < 10001)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v43 = 136447490;
        uint64_t v44 = "node_type_tracker_cancel";
        __int16 v45 = 1024;
        *(_DWORD *)uint64_t v46 = v28;
        *(_WORD *)&v46[4] = 2048;
        *(void *)&v46[6] = v26;
        *(_WORD *)&v46[14] = 2080;
        *(void *)&v46[16] = "tracker";
        *(_WORD *)&v46[24] = 2080;
        *(void *)&v46[26] = "node-type-tracker.c";
        __int16 v47 = 1024;
        int v48 = 255;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v43, 0x36u);
        int v28 = *(_DWORD *)v26;
      }
      *(_DWORD *)CFMutableDictionaryRef v26 = v28 - 1;
      if (v28 == 1)
      {
        int v29 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v43 = 136447234;
          uint64_t v44 = "node_type_tracker_cancel";
          __int16 v45 = 2048;
          *(void *)uint64_t v46 = v26;
          *(_WORD *)&v46[8] = 2080;
          *(void *)&v46[10] = "tracker";
          *(_WORD *)&v46[18] = 2080;
          *(void *)&v46[20] = "node-type-tracker.c";
          *(_WORD *)&v46[28] = 1024;
          *(_DWORD *)&v46[30] = 255;
          _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v43, 0x30u);
        }
        ++node_type_tracker_finalized;
        free(v26);
      }
      goto LABEL_69;
    }
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_131;
    }
    int v43 = 136447490;
    uint64_t v44 = "node_type_tracker_cancel";
    __int16 v45 = 1024;
    *(_DWORD *)uint64_t v46 = v28;
    *(_WORD *)&v46[4] = 2048;
    *(void *)&v46[6] = v26;
    *(_WORD *)&v46[14] = 2080;
    *(void *)&v46[16] = "tracker";
    *(_WORD *)&v46[24] = 2080;
    *(void *)&v46[26] = "node-type-tracker.c";
    __int16 v47 = 1024;
    int v48 = 255;
    int v41 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_129:
    int v42 = v9;
    goto LABEL_130;
  }
LABEL_69:
  int v30 = (void *)v26[6];
  if (!v30) {
    goto LABEL_81;
  }
  do
  {
    int v32 = (void *)*v30;
    uint64_t v31 = (void (*)(void))v30[1];
    if (v31) {
      v31(v30[3]);
    }
    free(v30);
    int v30 = v32;
  }
  while (v32);
  v26[6] = 0;
  int v33 = *(_DWORD *)v26;
  if (!*(_DWORD *)v26)
  {
    uint64_t v40 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_131;
    }
    int v43 = 136447490;
    uint64_t v44 = "node_type_tracker_cancel";
    __int16 v45 = 1024;
    *(_DWORD *)uint64_t v46 = 0;
    *(_WORD *)&v46[4] = 2048;
    *(void *)&v46[6] = v26;
    *(_WORD *)&v46[14] = 2080;
    *(void *)&v46[16] = "tracker";
    *(_WORD *)&v46[24] = 2080;
    *(void *)&v46[26] = "node-type-tracker.c";
    __int16 v47 = 1024;
    int v48 = 265;
    int v41 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_126;
  }
  __int16 v9 = global_os_log;
  if (v33 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_131;
    }
    int v43 = 136447490;
    uint64_t v44 = "node_type_tracker_cancel";
    __int16 v45 = 1024;
    *(_DWORD *)uint64_t v46 = v33;
    *(_WORD *)&v46[4] = 2048;
    *(void *)&v46[6] = v26;
    *(_WORD *)&v46[14] = 2080;
    *(void *)&v46[16] = "tracker";
    *(_WORD *)&v46[24] = 2080;
    *(void *)&v46[26] = "node-type-tracker.c";
    __int16 v47 = 1024;
    int v48 = 265;
    int v41 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_129;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v43 = 136447490;
    uint64_t v44 = "node_type_tracker_cancel";
    __int16 v45 = 1024;
    *(_DWORD *)uint64_t v46 = v33;
    *(_WORD *)&v46[4] = 2048;
    *(void *)&v46[6] = v26;
    *(_WORD *)&v46[14] = 2080;
    *(void *)&v46[16] = "tracker";
    *(_WORD *)&v46[24] = 2080;
    *(void *)&v46[26] = "node-type-tracker.c";
    __int16 v47 = 1024;
    int v48 = 265;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v43, 0x36u);
    int v33 = *(_DWORD *)v26;
  }
  *(_DWORD *)CFMutableDictionaryRef v26 = v33 - 1;
  if (v33 == 1)
  {
    int v34 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v43 = 136447234;
      uint64_t v44 = "node_type_tracker_cancel";
      __int16 v45 = 2048;
      *(void *)uint64_t v46 = v26;
      *(_WORD *)&v46[8] = 2080;
      *(void *)&v46[10] = "tracker";
      *(_WORD *)&v46[18] = 2080;
      *(void *)&v46[20] = "node-type-tracker.c";
      *(_WORD *)&v46[28] = 1024;
      *(_DWORD *)&v46[30] = 265;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v43, 0x30u);
    }
    ++node_type_tracker_finalized;
    free(v26);
  }
LABEL_81:
  CFUUIDRef v35 = (int *)a1[8];
  if (v35)
  {
    int v36 = *v35;
    if (*v35)
    {
      __int16 v9 = global_os_log;
      if (v36 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v43 = 136447490;
          uint64_t v44 = "node_type_tracker_release_";
          __int16 v45 = 1024;
          *(_DWORD *)uint64_t v46 = v36;
          *(_WORD *)&v46[4] = 2048;
          *(void *)&v46[6] = v35;
          *(_WORD *)&v46[14] = 2080;
          *(void *)&v46[16] = "omw";
          *(_WORD *)&v46[24] = 2080;
          *(void *)&v46[26] = "thread-device.c";
          __int16 v47 = 1024;
          int v48 = 158;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v43, 0x36u);
          int v36 = *v35;
        }
        *CFUUIDRef v35 = v36 - 1;
        if (v36 == 1)
        {
          xpc_object_t v37 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v43 = 136447234;
            uint64_t v44 = "node_type_tracker_release_";
            __int16 v45 = 2048;
            *(void *)uint64_t v46 = v35;
            *(_WORD *)&v46[8] = 2080;
            *(void *)&v46[10] = "omw";
            *(_WORD *)&v46[18] = 2080;
            *(void *)&v46[20] = "thread-device.c";
            *(_WORD *)&v46[28] = 1024;
            *(_DWORD *)&v46[30] = 158;
            _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v43, 0x30u);
          }
          ++node_type_tracker_finalized;
          free(v35);
        }
        goto LABEL_90;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_131:
      }
        abort();
      int v43 = 136447490;
      uint64_t v44 = "node_type_tracker_release_";
      __int16 v45 = 1024;
      *(_DWORD *)uint64_t v46 = v36;
      *(_WORD *)&v46[4] = 2048;
      *(void *)&v46[6] = v35;
      *(_WORD *)&v46[14] = 2080;
      *(void *)&v46[16] = "omw";
      *(_WORD *)&v46[24] = 2080;
      *(void *)&v46[26] = "thread-device.c";
      __int16 v47 = 1024;
      int v48 = 158;
      int v41 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_129;
    }
    uint64_t v40 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_131;
    }
    int v43 = 136447490;
    uint64_t v44 = "node_type_tracker_release_";
    __int16 v45 = 1024;
    *(_DWORD *)uint64_t v46 = 0;
    *(_WORD *)&v46[4] = 2048;
    *(void *)&v46[6] = v35;
    *(_WORD *)&v46[14] = 2080;
    *(void *)&v46[16] = "omw";
    *(_WORD *)&v46[24] = 2080;
    *(void *)&v46[26] = "thread-device.c";
    __int16 v47 = 1024;
    int v48 = 158;
    int v41 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_126:
    int v42 = v40;
LABEL_130:
    _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_FAULT, v41, (uint8_t *)&v43, 0x36u);
    goto LABEL_131;
  }
LABEL_90:
  a1[8] = 0;
LABEL_91:
  uint64_t v38 = a1[6];
  if (v38)
  {
    service_publisher_cancel(v38);
    service_publisher_release_((int *)a1[6], "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/thread-device.c", 163);
    a1[6] = 0;
  }
  uint64_t v39 = a1[16];
  if (v39)
  {
    dnssd_client_cancel(v39);
    dnssd_client_release_((int *)a1[16], "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/thread-device.c", 168);
    a1[16] = 0;
  }
}

void ifpermit_list_add(uint64_t a1, char *__s1)
{
  if (a1 == 1)
  {
    uint64_t v5 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v17 = 136446466;
    __int16 v18 = "ifpermit_list_add";
    __int16 v19 = 2082;
    *(void *)int v20 = __s1;
    CFDateRef v6 = "%{public}s: blocked permit list when adding %{public}s";
  }
  else
  {
    uint64_t v3 = (void *)(a1 + 8);
    while (1)
    {
      uint64_t v4 = (void *)*v3;
      if (!*v3) {
        break;
      }
      uint64_t v3 = (void *)*v3;
      if (!strcmp(__s1, (const char *)v4[1])) {
        goto LABEL_12;
      }
    }
    os_log_type_t v7 = malloc_type_calloc(1uLL, 0x18uLL, 0x103004013764637uLL);
    if (v7)
    {
      uint64_t v4 = v7;
      int v8 = strdup(__s1);
      v4[1] = v8;
      if (v8)
      {
        unsigned int v9 = if_nametoindex(__s1);
        *((_DWORD *)v4 + 4) = v9;
        if (!v9)
        {
          int v16 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          {
            int v17 = 136446466;
            __int16 v18 = "ifpermit_list_add";
            __int16 v19 = 2082;
            *(void *)int v20 = __s1;
            _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "%{public}s: if_nametoindex for interface %{public}s returned 0.", (uint8_t *)&v17, 0x16u);
          }
          free((void *)v4[1]);
          free(v4);
          return;
        }
        *uint64_t v3 = v4;
LABEL_12:
        int v10 = *((_DWORD *)v4 + 5) + 1;
        *((_DWORD *)v4 + 5) = v10;
        uint64_t v11 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        int v12 = *((_DWORD *)v4 + 4);
        int v17 = 136446978;
        __int16 v18 = "ifpermit_list_add";
        __int16 v19 = 1024;
        *(_DWORD *)int v20 = v10;
        *(_WORD *)&v20[4] = 2082;
        *(void *)&v20[6] = __s1;
        __int16 v21 = 1024;
        int v22 = v12;
        CFDateRef v6 = "%{public}s: %d permits for interface %{public}s with index %d";
        CFIndex v13 = v11;
        os_log_type_t v14 = OS_LOG_TYPE_DEFAULT;
        uint32_t v15 = 34;
        goto LABEL_18;
      }
      free(v4);
    }
    uint64_t v5 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v17 = 136446466;
    __int16 v18 = "ifpermit_list_add";
    __int16 v19 = 2082;
    *(void *)int v20 = __s1;
    CFDateRef v6 = "%{public}s: no memory to add permit for %{public}s";
  }
  CFIndex v13 = v5;
  os_log_type_t v14 = OS_LOG_TYPE_ERROR;
  uint32_t v15 = 22;
LABEL_18:
  _os_log_impl((void *)&_mh_execute_header, v13, v14, v6, (uint8_t *)&v17, v15);
}

void ifpermit_list_remove(uint64_t a1, char *__s1)
{
  if (a1 == 1)
  {
    uint64_t v8 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v13 = 136446466;
    os_log_type_t v14 = "ifpermit_list_remove";
    __int16 v15 = 2082;
    *(void *)int v16 = __s1;
    unsigned int v9 = "%{public}s: blocked permit list when removing %{public}s";
    int v10 = v8;
    os_log_type_t v11 = OS_LOG_TYPE_ERROR;
  }
  else
  {
    uint64_t v3 = (const char **)(a1 + 8);
    while (1)
    {
      uint64_t v4 = v3;
      uint64_t v3 = (const char **)*v3;
      if (!v3) {
        break;
      }
      if (!strcmp(__s1, v3[1]))
      {
        int v5 = *((_DWORD *)v3 + 5) - 1;
        *((_DWORD *)v3 + 5) = v5;
        CFDateRef v6 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v7 = *((_DWORD *)v3 + 4);
          int v13 = 136446978;
          os_log_type_t v14 = "ifpermit_list_remove";
          __int16 v15 = 1024;
          *(_DWORD *)int v16 = v5;
          *(_WORD *)&v16[4] = 2082;
          *(void *)&v16[6] = __s1;
          __int16 v17 = 1024;
          int v18 = v7;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: %d permits for interface %{public}s with index %d", (uint8_t *)&v13, 0x22u);
          int v5 = *((_DWORD *)v3 + 5);
        }
        if (!v5)
        {
          void *v4 = *v3;
          free((void *)v3[1]);
          free(v3);
        }
        return;
      }
    }
    uint64_t v12 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      return;
    }
    int v13 = 136446466;
    os_log_type_t v14 = "ifpermit_list_remove";
    __int16 v15 = 2082;
    *(void *)int v16 = __s1;
    unsigned int v9 = "%{public}s: permit remove for interface %{public}s which does not exist";
    int v10 = v12;
    os_log_type_t v11 = OS_LOG_TYPE_FAULT;
  }
  _os_log_impl((void *)&_mh_execute_header, v10, v11, v9, (uint8_t *)&v13, 0x16u);
}

void ifpermit_list_retain_(int *a1, int a2)
{
  if ((unint64_t)a1 >= 2)
  {
    uint64_t v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *a1;
      *(_DWORD *)buf = 136447490;
      int v10 = "ifpermit_list_retain_";
      __int16 v11 = 1024;
      int v12 = v5;
      __int16 v13 = 2048;
      os_log_type_t v14 = a1;
      __int16 v15 = 2080;
      int v16 = "list";
      __int16 v17 = 2080;
      int v18 = "macos-ioloop.c";
      __int16 v19 = 1024;
      int v20 = a2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    if (*a1)
    {
      int v6 = *a1 + 1;
      *a1 = v6;
      if (v6 >= 10001)
      {
        int v8 = v6;
        int v7 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136447490;
          int v10 = "ifpermit_list_retain_";
          __int16 v11 = 1024;
          int v12 = v8;
          __int16 v13 = 2048;
          os_log_type_t v14 = a1;
          __int16 v15 = 2080;
          int v16 = "list";
          __int16 v17 = 2080;
          int v18 = "macos-ioloop.c";
          __int16 v19 = 1024;
          int v20 = a2;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++ifpermit_list_created;
      *a1 = 1;
    }
  }
}

void ifpermit_list_release_(int *a1, int a2)
{
  if ((unint64_t)a1 < 2) {
    return;
  }
  int v4 = *a1;
  if (!*a1)
  {
    int v5 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_18;
    }
    int v10 = 136447490;
    __int16 v11 = "ifpermit_list_release_";
    __int16 v12 = 1024;
    *(_DWORD *)__int16 v13 = 0;
    *(_WORD *)&v13[4] = 2048;
    *(void *)&v13[6] = a1;
    *(_WORD *)&v13[14] = 2080;
    *(void *)&v13[16] = "list";
    *(_WORD *)&v13[24] = 2080;
    *(void *)&v13[26] = "macos-ioloop.c";
    __int16 v14 = 1024;
    int v15 = a2;
    unsigned int v9 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_17;
  }
  int v5 = global_os_log;
  if (v4 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_18;
    }
    int v10 = 136447490;
    __int16 v11 = "ifpermit_list_release_";
    __int16 v12 = 1024;
    *(_DWORD *)__int16 v13 = v4;
    *(_WORD *)&v13[4] = 2048;
    *(void *)&v13[6] = a1;
    *(_WORD *)&v13[14] = 2080;
    *(void *)&v13[16] = "list";
    *(_WORD *)&v13[24] = 2080;
    *(void *)&v13[26] = "macos-ioloop.c";
    __int16 v14 = 1024;
    int v15 = a2;
    unsigned int v9 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_17:
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, v9, (uint8_t *)&v10, 0x36u);
LABEL_18:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = 136447490;
    __int16 v11 = "ifpermit_list_release_";
    __int16 v12 = 1024;
    *(_DWORD *)__int16 v13 = v4;
    *(_WORD *)&v13[4] = 2048;
    *(void *)&v13[6] = a1;
    *(_WORD *)&v13[14] = 2080;
    *(void *)&v13[16] = "list";
    *(_WORD *)&v13[24] = 2080;
    *(void *)&v13[26] = "macos-ioloop.c";
    __int16 v14 = 1024;
    int v15 = a2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v10, 0x36u);
    int v4 = *a1;
  }
  *a1 = v4 - 1;
  if (v4 == 1)
  {
    int v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 136447234;
      __int16 v11 = "ifpermit_list_release_";
      __int16 v12 = 2048;
      *(void *)__int16 v13 = a1;
      *(_WORD *)&v13[8] = 2080;
      *(void *)&v13[10] = "list";
      *(_WORD *)&v13[18] = 2080;
      *(void *)&v13[20] = "macos-ioloop.c";
      *(_WORD *)&v13[28] = 1024;
      *(_DWORD *)&v13[30] = a2;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v10, 0x30u);
    }
    ++ifpermit_list_finalized;
    int v7 = (void **)*((void *)a1 + 1);
    if (v7)
    {
      do
      {
        int v8 = (void **)*v7;
        free(v7[1]);
        free(v7);
        int v7 = v8;
      }
      while (v8);
    }
    free(a1);
  }
}

void ifpermit_add_permitted_interface_to_server_(uint64_t a1, char *__s1, char *a3, int a4)
{
  uint64_t v5 = *(void *)(a1 + 72);
  if (!v5)
  {
    uint64_t v5 = 1;
    unsigned int v9 = malloc_type_calloc(1uLL, 0x10uLL, 0x1020040D5A9D86FuLL);
    if (v9)
    {
      int v10 = v9;
      __int16 v11 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v12 = *v10;
        int v17 = 136447490;
        int v18 = "ifpermit_list_create_";
        __int16 v19 = 1024;
        int v20 = v12;
        __int16 v21 = 2048;
        int v22 = v10;
        __int16 v23 = 2080;
        int v24 = "permits";
        __int16 v25 = 2080;
        CFMutableDictionaryRef v26 = strrchr(a3, 47) + 1;
        __int16 v27 = 1024;
        int v28 = a4;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v17, 0x36u);
      }
      int v13 = *v10;
      if (*v10)
      {
        int v14 = v13 + 1;
        _DWORD *v10 = v13 + 1;
        if (v13 + 1 >= 10001)
        {
          int v15 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            int v16 = strrchr(a3, 47);
            int v17 = 136447490;
            int v18 = "ifpermit_list_create_";
            __int16 v19 = 1024;
            int v20 = v14;
            __int16 v21 = 2048;
            int v22 = v10;
            __int16 v23 = 2080;
            int v24 = "permits";
            __int16 v25 = 2080;
            CFMutableDictionaryRef v26 = v16 + 1;
            __int16 v27 = 1024;
            int v28 = a4;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v17, 0x36u);
          }
          abort();
        }
      }
      else
      {
        ++ifpermit_list_created;
        _DWORD *v10 = 1;
      }
      uint64_t v5 = (uint64_t)v10;
    }
    *(void *)(a1 + 72) = v5;
  }

  ifpermit_list_add(v5, __s1);
}

void thread_service_retain_(int *a1, char *a2, int a3)
{
  if (a1)
  {
    int v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = *a1;
      *(_DWORD *)buf = 136447490;
      int v13 = "thread_service_retain_";
      __int16 v14 = 1024;
      int v15 = v7;
      __int16 v16 = 2048;
      int v17 = a1;
      __int16 v18 = 2080;
      __int16 v19 = "omw";
      __int16 v20 = 2080;
      __int16 v21 = strrchr(a2, 47) + 1;
      __int16 v22 = 1024;
      int v23 = a3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    if (*a1)
    {
      int v8 = *a1 + 1;
      *a1 = v8;
      if (v8 >= 10001)
      {
        int v11 = v8;
        unsigned int v9 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          int v10 = strrchr(a2, 47);
          *(_DWORD *)buf = 136447490;
          int v13 = "thread_service_retain_";
          __int16 v14 = 1024;
          int v15 = v11;
          __int16 v16 = 2048;
          int v17 = a1;
          __int16 v18 = 2080;
          __int16 v19 = "omw";
          __int16 v20 = 2080;
          __int16 v21 = v10 + 1;
          __int16 v22 = 1024;
          int v23 = a3;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++thread_service_created;
      *a1 = 1;
    }
  }
}

void thread_service_release_(int *a1, char *a2, int a3)
{
  if (!a1) {
    return;
  }
  int v6 = *a1;
  if (!*a1)
  {
    int v7 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v11 = 136447490;
    int v12 = "thread_service_release_";
    __int16 v13 = 1024;
    *(_DWORD *)__int16 v14 = 0;
    *(_WORD *)&v14[4] = 2048;
    *(void *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(void *)&v14[16] = "omw";
    *(_WORD *)&v14[24] = 2080;
    *(void *)&v14[26] = strrchr(a2, 47) + 1;
    __int16 v15 = 1024;
    int v16 = a3;
    int v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  int v7 = global_os_log;
  if (v6 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v11 = 136447490;
    int v12 = "thread_service_release_";
    __int16 v13 = 1024;
    *(_DWORD *)__int16 v14 = v6;
    *(_WORD *)&v14[4] = 2048;
    *(void *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(void *)&v14[16] = "omw";
    *(_WORD *)&v14[24] = 2080;
    *(void *)&v14[26] = strrchr(a2, 47) + 1;
    __int16 v15 = 1024;
    int v16 = a3;
    int v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v11, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = 136447490;
    int v12 = "thread_service_release_";
    __int16 v13 = 1024;
    *(_DWORD *)__int16 v14 = v6;
    *(_WORD *)&v14[4] = 2048;
    *(void *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(void *)&v14[16] = "omw";
    *(_WORD *)&v14[24] = 2080;
    *(void *)&v14[26] = strrchr(a2, 47) + 1;
    __int16 v15 = 1024;
    int v16 = a3;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v11, 0x36u);
    int v6 = *a1;
  }
  *a1 = v6 - 1;
  if (v6 == 1)
  {
    int v8 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      unsigned int v9 = strrchr(a2, 47);
      int v11 = 136447234;
      int v12 = "thread_service_release_";
      __int16 v13 = 2048;
      *(void *)__int16 v14 = a1;
      *(_WORD *)&v14[8] = 2080;
      *(void *)&v14[10] = "omw";
      *(_WORD *)&v14[18] = 2080;
      *(void *)&v14[20] = v9 + 1;
      *(_WORD *)&v14[28] = 1024;
      *(_DWORD *)&v14[30] = a3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v11, 0x30u);
    }
    ++thread_service_finalized;
    free(a1);
  }
}

_DWORD *thread_service_unicast_create_(__int16 a1, _OWORD *a2, _WORD *a3, char a4, char *a5, int a6)
{
  int v12 = malloc_type_calloc(1uLL, 0x58uLL, 0x1020040B24B9CA0uLL);
  __int16 v13 = v12;
  if (v12)
  {
    *((_OWORD *)v12 + 4) = *a2;
    *((_WORD *)v12 + 40) = *a3;
    *((_WORD *)v12 + 8) = a1;
    v12[5] = 2;
    *((unsigned char *)v12 + 18) = a4;
    __int16 v14 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = *v13;
      int v21 = 136447490;
      __int16 v22 = "thread_service_unicast_create_";
      __int16 v23 = 1024;
      int v24 = v15;
      __int16 v25 = 2048;
      CFMutableDictionaryRef v26 = v13;
      __int16 v27 = 2080;
      int v28 = "service";
      __int16 v29 = 2080;
      int v30 = strrchr(a5, 47) + 1;
      __int16 v31 = 1024;
      int v32 = a6;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v21, 0x36u);
    }
    int v16 = *v13;
    if (*v13)
    {
      int v17 = v16 + 1;
      _DWORD *v13 = v16 + 1;
      if (v16 + 1 >= 10001)
      {
        __int16 v18 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          __int16 v19 = strrchr(a5, 47);
          int v21 = 136447490;
          __int16 v22 = "thread_service_unicast_create_";
          __int16 v23 = 1024;
          int v24 = v17;
          __int16 v25 = 2048;
          CFMutableDictionaryRef v26 = v13;
          __int16 v27 = 2080;
          int v28 = "service";
          __int16 v29 = 2080;
          int v30 = v19 + 1;
          __int16 v31 = 1024;
          int v32 = a6;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v21, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++thread_service_created;
      _DWORD *v13 = 1;
    }
  }
  return v13;
}

_DWORD *thread_service_anycast_create_(__int16 a1, char a2, char a3, char *a4, int a5)
{
  int v10 = malloc_type_calloc(1uLL, 0x58uLL, 0x1020040B24B9CA0uLL);
  int v11 = v10;
  if (v10)
  {
    *((_WORD *)v10 + 8) = a1;
    *((unsigned char *)v10 + 80) = a2;
    v10[5] = 3;
    *((unsigned char *)v10 + 18) = a3;
    int v12 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = *v11;
      int v19 = 136447490;
      __int16 v20 = "thread_service_anycast_create_";
      __int16 v21 = 1024;
      int v22 = v13;
      __int16 v23 = 2048;
      int v24 = v11;
      __int16 v25 = 2080;
      CFMutableDictionaryRef v26 = "service";
      __int16 v27 = 2080;
      int v28 = strrchr(a4, 47) + 1;
      __int16 v29 = 1024;
      int v30 = a5;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v19, 0x36u);
    }
    int v14 = *v11;
    if (*v11)
    {
      int v15 = v14 + 1;
      *int v11 = v14 + 1;
      if (v14 + 1 >= 10001)
      {
        int v16 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          int v17 = strrchr(a4, 47);
          int v19 = 136447490;
          __int16 v20 = "thread_service_anycast_create_";
          __int16 v21 = 1024;
          int v22 = v15;
          __int16 v23 = 2048;
          int v24 = v11;
          __int16 v25 = 2080;
          CFMutableDictionaryRef v26 = "service";
          __int16 v27 = 2080;
          int v28 = v17 + 1;
          __int16 v29 = 1024;
          int v30 = a5;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v19, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++thread_service_created;
      *int v11 = 1;
    }
  }
  return v11;
}

_DWORD *thread_service_pref_id_create_(__int16 a1, _DWORD *a2, int *a3, char a4, char *a5, int a6)
{
  int v12 = malloc_type_calloc(1uLL, 0x58uLL, 0x1020040B24B9CA0uLL);
  int v13 = v12;
  if (v12)
  {
    *((_WORD *)v12 + 8) = a1;
    v12[16] = *a2;
    int v14 = *a3;
    *((unsigned char *)v12 + 72) = *((unsigned char *)a3 + 4);
    v12[17] = v14;
    v12[5] = 1;
    *((unsigned char *)v12 + 18) = a4;
    int v15 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = *v13;
      int v22 = 136447490;
      __int16 v23 = "thread_service_pref_id_create_";
      __int16 v24 = 1024;
      int v25 = v16;
      __int16 v26 = 2048;
      __int16 v27 = v13;
      __int16 v28 = 2080;
      __int16 v29 = "service";
      __int16 v30 = 2080;
      __int16 v31 = strrchr(a5, 47) + 1;
      __int16 v32 = 1024;
      int v33 = a6;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v22, 0x36u);
    }
    int v17 = *v13;
    if (*v13)
    {
      int v18 = v17 + 1;
      _DWORD *v13 = v17 + 1;
      if (v17 + 1 >= 10001)
      {
        int v19 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          __int16 v20 = strrchr(a5, 47);
          int v22 = 136447490;
          __int16 v23 = "thread_service_pref_id_create_";
          __int16 v24 = 1024;
          int v25 = v18;
          __int16 v26 = 2048;
          __int16 v27 = v13;
          __int16 v28 = 2080;
          __int16 v29 = "service";
          __int16 v30 = 2080;
          __int16 v31 = v20 + 1;
          __int16 v32 = 1024;
          int v33 = a6;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v22, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++thread_service_created;
      _DWORD *v13 = 1;
    }
  }
  return v13;
}

void thread_service_note(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v6 = *(_DWORD *)(a2 + 20);
  switch(v6)
  {
    case 1:
      char v26 = -3;
      int v27 = *(_DWORD *)(a2 + 68);
      char v28 = *(unsigned char *)(a2 + 72);
      uint64_t v29 = 0;
      __int16 v30 = 0;
      uint64_t v13 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      unsigned int v14 = *(unsigned __int8 *)(a2 + 64);
      int v15 = *(unsigned __int8 *)(a2 + 65);
      int v16 = *(unsigned __int8 *)(a2 + 66);
      int v17 = *(unsigned __int8 *)(a2 + 67);
      int v18 = *(unsigned __int16 *)(a2 + 16);
      *(_DWORD *)buf = 136450563;
      __int16 v32 = "thread_service_note";
      __int16 v33 = 2082;
      *(void *)int v34 = a1;
      *(_WORD *)&v34[8] = 2082;
      *(void *)&unsigned char v34[10] = "ULA: ";
      *(_WORD *)&v34[18] = 2160;
      *(void *)CFUUIDRef v35 = 1752392040;
      *(_WORD *)&v35[8] = 1041;
      int v36 = 6;
      __int16 v37 = 2097;
      uint64_t v38 = &v26;
      __int16 v39 = 2160;
      uint64_t v40 = 1752392040;
      __int16 v41 = 1042;
      int v42 = 2;
      __int16 v43 = 2098;
      uint64_t v44 = &v29;
      __int16 v45 = 2160;
      uint64_t v46 = 1752392040;
      __int16 v47 = 1041;
      int v48 = 8;
      __int16 v49 = 2097;
      OSStatus v50 = (char *)&v29 + 2;
      __int16 v51 = 1024;
      unsigned int v52 = v14;
      __int16 v53 = 1024;
      int v54 = v15;
      __int16 v55 = 1024;
      *(_DWORD *)uint64_t v56 = v16;
      *(_WORD *)&v56[4] = 1024;
      *(_DWORD *)&v56[6] = v17;
      __int16 v57 = 1024;
      int v58 = v18;
      __int16 v59 = 2082;
      uint64_t v60 = a3;
      int v10 = "%{public}s: %{public}s pref:id {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash"
            ", srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}:%02x%02x%02x%02x rloc %x %{public}s";
      int v11 = v13;
      uint32_t v12 = 150;
      break;
    case 2:
      unsigned int v19 = *(unsigned __int16 *)(a2 + 80);
      uint64_t v20 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      unsigned int v21 = __rev16(v19);
      int v22 = *(unsigned __int8 *)(a2 + 64);
      if ((v22 & 0xFE) == 0xFC)
      {
        __int16 v23 = "ULA: ";
      }
      else if (v22 == 254 && (*(unsigned char *)(a2 + 65) & 0xC0) == 0x80)
      {
        __int16 v23 = "LUA: ";
      }
      else if ((v22 & 0xE0) == 0x20)
      {
        __int16 v23 = "GUA: ";
      }
      else
      {
        __int16 v23 = "";
      }
      int v25 = *(unsigned __int16 *)(a2 + 16);
      *(_DWORD *)buf = 136449795;
      __int16 v32 = "thread_service_note";
      __int16 v33 = 2082;
      *(void *)int v34 = a1;
      *(_WORD *)&v34[8] = 2082;
      *(void *)&unsigned char v34[10] = v23;
      *(_WORD *)&v34[18] = 2160;
      *(void *)CFUUIDRef v35 = 1752392040;
      *(_WORD *)&v35[8] = 1041;
      int v36 = 6;
      __int16 v37 = 2097;
      uint64_t v38 = (char *)(a2 + 64);
      __int16 v39 = 2160;
      uint64_t v40 = 1752392040;
      __int16 v41 = 1042;
      int v42 = 2;
      __int16 v43 = 2098;
      uint64_t v44 = (uint64_t *)(a2 + 70);
      __int16 v45 = 2160;
      uint64_t v46 = 1752392040;
      __int16 v47 = 1041;
      int v48 = 8;
      __int16 v49 = 2097;
      OSStatus v50 = (char *)(a2 + 72);
      __int16 v51 = 1024;
      unsigned int v52 = v21;
      __int16 v53 = 1024;
      int v54 = v25;
      __int16 v55 = 2082;
      *(void *)uint64_t v56 = a3;
      int v10 = "%{public}s: %{public}s SRP service {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask."
            "hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}%%%d, rloc16 %x %{public}s";
      int v11 = v20;
      uint32_t v12 = 132;
      break;
    case 3:
      uint64_t v7 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      int v8 = *(unsigned __int16 *)(a2 + 16);
      int v9 = *(unsigned __int8 *)(a2 + 80);
      *(_DWORD *)buf = 136447234;
      __int16 v32 = "thread_service_note";
      __int16 v33 = 2082;
      *(void *)int v34 = a1;
      *(_WORD *)&v34[8] = 1024;
      *(_DWORD *)&unsigned char v34[10] = v8;
      *(_WORD *)&v34[14] = 1024;
      *(_DWORD *)&v34[16] = v9;
      *(_WORD *)CFUUIDRef v35 = 2082;
      *(void *)&v35[2] = a3;
      int v10 = "%{public}s: %{public}s SRP service on RLOC16 %x with sequence number %02x %{public}s";
      int v11 = v7;
      uint32_t v12 = 44;
      break;
    default:
      uint64_t v24 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)buf = 136446722;
      __int16 v32 = "thread_service_note";
      __int16 v33 = 1024;
      *(_DWORD *)int v34 = v6;
      *(_WORD *)&v34[4] = 2048;
      *(void *)&v34[6] = a2;
      int v10 = "%{public}s: invalid service type %d on service %p";
      int v11 = v24;
      uint32_t v12 = 28;
      break;
  }
  _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, v10, buf, v12);
}

void ioloop_dump_object_allocation_stats()
{
  if (adv_host_created != old_adv_host_created
    || adv_host_finalized != old_adv_host_finalized
    || adv_instance_created != old_adv_instance_created
    || adv_instance_finalized != old_adv_instance_finalized
    || adv_instance_vec_created != old_adv_instance_vec_created
    || adv_instance_vec_finalized != old_adv_instance_vec_finalized
    || adv_record_created != old_adv_record_created
    || adv_record_finalized != old_adv_record_finalized
    || adv_record_vec_created != old_adv_record_vec_created
    || adv_record_vec_finalized != old_adv_record_vec_finalized
    || adv_update_created != old_adv_update_created
    || adv_update_finalized != old_adv_update_finalized
    || comm_created != old_comm_created
    || comm_finalized != old_comm_finalized
    || cti_connection_created != old_cti_connection_created
    || cti_connection_finalized != old_cti_connection_finalized
    || cti_service_created != old_cti_service_created
    || cti_service_finalized != old_cti_service_finalized
    || cti_service_vec_created != old_cti_service_vec_created
    || cti_service_vec_finalized != old_cti_service_vec_finalized
    || dnssd_client_created != old_dnssd_client_created
    || dnssd_client_finalized != old_dnssd_client_finalized
    || dnssd_query_created != old_dnssd_query_created
    || dnssd_query_finalized != old_dnssd_query_finalized
    || dnssd_txn_created != old_dnssd_txn_created
    || dnssd_txn_finalized != old_dnssd_txn_finalized
    || dp_tracker_created != old_dp_tracker_created
    || dp_tracker_finalized != old_dp_tracker_finalized
    || file_descriptor_created != old_file_descriptor_created
    || file_descriptor_finalized != old_file_descriptor_finalized
    || ifpermit_list_created != old_ifpermit_list_created
    || ifpermit_list_finalized != old_ifpermit_list_finalized
    || listener_created != old_listener_created
    || listener_finalized != old_listener_finalized
    || message_created != old_message_created
    || message_finalized != old_message_finalized
    || node_type_tracker_created != old_node_type_tracker_created
    || node_type_tracker_finalized != old_node_type_tracker_finalized
    || nw_connection_created != old_nw_connection_created
    || nw_connection_finalized != old_nw_connection_finalized
    || nw_listener_created != old_nw_listener_created
    || nw_listener_finalized != old_nw_listener_finalized
    || probe_state_created != old_probe_state_created
    || probe_state_finalized != old_probe_state_finalized
    || question_created != old_question_created
    || question_finalized != old_question_finalized
    || rref_created != old_rref_created
    || rref_finalized != old_rref_finalized
    || sdref_created != old_sdref_created
    || sdref_finalized != old_sdref_finalized
    || saref_created != old_saref_created
    || saref_finalized != old_saref_finalized
    || service_publisher_created != old_service_publisher_created
    || service_publisher_finalized != old_service_publisher_finalized
    || service_tracker_created != old_service_tracker_created
    || service_tracker_finalized != old_service_tracker_finalized
    || srp_xpc_client_created != old_srp_xpc_client_created
    || srp_xpc_client_finalized != old_srp_xpc_client_finalized
    || state_machine_event_created != old_state_machine_event_created
    || state_machine_event_finalized != old_state_machine_event_finalized
    || thread_service_created != old_thread_service_created
    || thread_service_finalized != old_thread_service_finalized
    || thread_tracker_created != old_thread_tracker_created
    || thread_tracker_finalized != old_thread_tracker_finalized
    || wakeup_created != old_wakeup_created
    || wakeup_finalized != old_wakeup_finalized)
  {
    int v0 = snprintf(__str, 0x3E8uLL, "address_query %d %d %d %d|", 0, 0, 0, 0);
    if (v0 <= 900)
    {
      uint64_t v1 = &__str[v0];
    }
    else
    {
      uint64_t v1 = __str;
      CFDateRef v2 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    uint64_t v3 = &v1[snprintf(v1, (char *)&v138 - v1, "adv_host %d %d %d %d|", old_adv_host_created, adv_host_created, old_adv_host_finalized, adv_host_finalized)];
    old_adv_host_created = adv_host_created;
    old_adv_host_finalized = adv_host_finalized;
    if (v3 - __str >= 901)
    {
      uint64_t v3 = __str;
      int v4 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    uint64_t v5 = &v3[snprintf(v3, (char *)&v138 - v3, "adv_instance %d %d %d %d|", old_adv_instance_created, adv_instance_created, old_adv_instance_finalized, adv_instance_finalized)];
    old_adv_instance_created = adv_instance_created;
    old_adv_instance_finalized = adv_instance_finalized;
    if (v5 - __str >= 901)
    {
      uint64_t v5 = __str;
      int v6 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    uint64_t v7 = &v5[snprintf(v5, (char *)&v138 - v5, "adv_instance_vec %d %d %d %d|", old_adv_instance_vec_created, adv_instance_vec_created, old_adv_instance_vec_finalized, adv_instance_vec_finalized)];
    old_adv_instance_vec_created = adv_instance_vec_created;
    old_adv_instance_vec_finalized = adv_instance_vec_finalized;
    if (v7 - __str >= 901)
    {
      uint64_t v7 = __str;
      int v8 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    int v9 = &v7[snprintf(v7, (char *)&v138 - v7, "adv_record %d %d %d %d|", old_adv_record_created, adv_record_created, old_adv_record_finalized, adv_record_finalized)];
    old_adv_record_created = adv_record_created;
    old_adv_record_finalized = adv_record_finalized;
    if (v9 - __str >= 901)
    {
      int v9 = __str;
      int v10 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    int v11 = &v9[snprintf(v9, (char *)&v138 - v9, "adv_record_vec %d %d %d %d|", old_adv_record_vec_created, adv_record_vec_created, old_adv_record_vec_finalized, adv_record_vec_finalized)];
    old_adv_record_vec_created = adv_record_vec_created;
    old_adv_record_vec_finalized = adv_record_vec_finalized;
    if (v11 - __str >= 901)
    {
      int v11 = __str;
      uint32_t v12 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    uint64_t v13 = &v11[snprintf(v11, (char *)&v138 - v11, "adv_update %d %d %d %d|", old_adv_update_created, adv_update_created, old_adv_update_finalized, adv_update_finalized)];
    old_adv_update_created = adv_update_created;
    old_adv_update_finalized = adv_update_finalized;
    if (v13 - __str >= 901)
    {
      uint64_t v13 = __str;
      unsigned int v14 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    int v15 = &v13[snprintf(v13, (char *)&v138 - v13, "advertising_proxy_conn_ref %d %d %d %d|", 0, 0, 0, 0)];
    if (v15 - __str >= 901)
    {
      int v15 = __str;
      int v16 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    int v17 = &v15[snprintf(v15, (char *)&v138 - v15, "comm %d %d %d %d|", old_comm_created, comm_created, old_comm_finalized, comm_finalized)];
    old_comm_created = comm_created;
    old_comm_finalized = comm_finalized;
    if (v17 - __str >= 901)
    {
      int v17 = __str;
      int v18 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    unsigned int v19 = &v17[snprintf(v17, (char *)&v138 - v17, "cti_connection %d %d %d %d|", old_cti_connection_created, cti_connection_created, old_cti_connection_finalized, cti_connection_finalized)];
    old_cti_connection_created = cti_connection_created;
    old_cti_connection_finalized = cti_connection_finalized;
    if (v19 - __str >= 901)
    {
      unsigned int v19 = __str;
      uint64_t v20 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    unsigned int v21 = &v19[snprintf(v19, (char *)&v138 - v19, "cti_prefix %d %d %d %d|", 0, 0, 0, 0)];
    if (v21 - __str >= 901)
    {
      unsigned int v21 = __str;
      int v22 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    __int16 v23 = &v21[snprintf(v21, (char *)&v138 - v21, "cti_prefix_vec %d %d %d %d|", 0, 0, 0, 0)];
    if (v23 - __str >= 901)
    {
      __int16 v23 = __str;
      uint64_t v24 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    int v25 = &v23[snprintf(v23, (char *)&v138 - v23, "cti_route %d %d %d %d|", 0, 0, 0, 0)];
    if (v25 - __str >= 901)
    {
      int v25 = __str;
      char v26 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    int v27 = &v25[snprintf(v25, (char *)&v138 - v25, "cti_route_vec %d %d %d %d|", 0, 0, 0, 0)];
    if (v27 - __str >= 901)
    {
      int v27 = __str;
      char v28 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    uint64_t v29 = &v27[snprintf(v27, (char *)&v138 - v27, "cti_service %d %d %d %d|", old_cti_service_created, cti_service_created, old_cti_service_finalized, cti_service_finalized)];
    old_cti_service_created = cti_service_created;
    old_cti_service_finalized = cti_service_finalized;
    if (v29 - __str >= 901)
    {
      uint64_t v29 = __str;
      __int16 v30 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    __int16 v31 = &v29[snprintf(v29, (char *)&v138 - v29, "cti_service_vec %d %d %d %d|", old_cti_service_vec_created, cti_service_vec_created, old_cti_service_vec_finalized, cti_service_vec_finalized)];
    old_cti_service_vec_created = cti_service_vec_created;
    old_cti_service_vec_finalized = cti_service_vec_finalized;
    if (v31 - __str >= 901)
    {
      __int16 v31 = __str;
      __int16 v32 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    __int16 v33 = &v31[snprintf(v31, (char *)&v138 - v31, "dnssd_client %d %d %d %d|", old_dnssd_client_created, dnssd_client_created, old_dnssd_client_finalized, dnssd_client_finalized)];
    old_dnssd_client_created = dnssd_client_created;
    old_dnssd_client_finalized = dnssd_client_finalized;
    if (v33 - __str >= 901)
    {
      __int16 v33 = __str;
      int v34 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    CFUUIDRef v35 = &v33[snprintf(v33, (char *)&v138 - v33, "dnssd_query %d %d %d %d|", old_dnssd_query_created, dnssd_query_created, old_dnssd_query_finalized, dnssd_query_finalized)];
    old_dnssd_query_created = dnssd_query_created;
    old_dnssd_query_finalized = dnssd_query_finalized;
    if (v35 - __str >= 901)
    {
      CFUUIDRef v35 = __str;
      int v36 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    __int16 v37 = &v35[snprintf(v35, (char *)&v138 - v35, "dnssd_txn %d %d %d %d|", old_dnssd_txn_created, dnssd_txn_created, old_dnssd_txn_finalized, dnssd_txn_finalized)];
    old_dnssd_txn_created = dnssd_txn_created;
    old_dnssd_txn_finalized = dnssd_txn_finalized;
    if (v37 - __str >= 901)
    {
      __int16 v37 = __str;
      uint64_t v38 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    __int16 v39 = &v37[snprintf(v37, (char *)&v138 - v37, "dp_tracker %d %d %d %d|", old_dp_tracker_created, dp_tracker_created, old_dp_tracker_finalized, dp_tracker_finalized)];
    old_dp_tracker_created = dp_tracker_created;
    old_dp_tracker_finalized = dp_tracker_finalized;
    if (v39 - __str >= 901)
    {
      __int16 v39 = __str;
      uint64_t v40 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    __int16 v41 = &v39[snprintf(v39, (char *)&v138 - v39, "file_descriptor %d %d %d %d|", old_file_descriptor_created, file_descriptor_created, old_file_descriptor_finalized, file_descriptor_finalized)];
    old_file_descriptor_created = file_descriptor_created;
    old_file_descriptor_finalized = file_descriptor_finalized;
    if (v41 - __str >= 901)
    {
      __int16 v41 = __str;
      int v42 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    __int16 v43 = &v41[snprintf(v41, (char *)&v138 - v41, "interface %d %d %d %d|", 0, 0, 0, 0)];
    if (v43 - __str >= 901)
    {
      __int16 v43 = __str;
      uint64_t v44 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    __int16 v45 = &v43[snprintf(v43, (char *)&v138 - v43, "ifpermit_list %d %d %d %d|", old_ifpermit_list_created, ifpermit_list_created, old_ifpermit_list_finalized, ifpermit_list_finalized)];
    old_ifpermit_list_created = ifpermit_list_created;
    old_ifpermit_list_finalized = ifpermit_list_finalized;
    if (v45 - __str >= 901)
    {
      __int16 v45 = __str;
      uint64_t v46 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    __int16 v47 = &v45[snprintf(v45, (char *)&v138 - v45, "io %d %d %d %d|", 0, 0, 0, 0)];
    if (v47 - __str >= 901)
    {
      __int16 v47 = __str;
      int v48 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    __int16 v49 = &v47[snprintf(v47, (char *)&v138 - v47, "listener %d %d %d %d|", old_listener_created, listener_created, old_listener_finalized, listener_finalized)];
    old_listener_created = listener_created;
    old_listener_finalized = listener_finalized;
    if (v49 - __str >= 901)
    {
      __int16 v49 = __str;
      OSStatus v50 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    __int16 v51 = &v49[snprintf(v49, (char *)&v138 - v49, "message %d %d %d %d|", old_message_created, message_created, old_message_finalized, message_finalized)];
    old_message_created = message_created;
    old_message_finalized = message_finalized;
    if (v51 - __str >= 901)
    {
      __int16 v51 = __str;
      unsigned int v52 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    __int16 v53 = &v51[snprintf(v51, (char *)&v138 - v51, "nat64 %d %d %d %d|", 0, 0, 0, 0)];
    if (v53 - __str >= 901)
    {
      __int16 v53 = __str;
      int v54 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    __int16 v55 = &v53[snprintf(v53, (char *)&v138 - v53, "nat64_prefix %d %d %d %d|", 0, 0, 0, 0)];
    if (v55 - __str >= 901)
    {
      __int16 v55 = __str;
      uint64_t v56 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    __int16 v57 = &v55[snprintf(v55, (char *)&v138 - v55, "nat64_ipv4_default_route_monitor %d %d %d %d|", 0, 0, 0, 0)];
    if (v57 - __str >= 901)
    {
      __int16 v57 = __str;
      int v58 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    __int16 v59 = &v57[snprintf(v57, (char *)&v138 - v57, "nat64_infra_prefix_monitor %d %d %d %d|", 0, 0, 0, 0)];
    if (v59 - __str >= 901)
    {
      __int16 v59 = __str;
      uint64_t v60 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v60, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    uint64_t v61 = &v59[snprintf(v59, (char *)&v138 - v59, "nat64_thread_prefix_monitor %d %d %d %d|", 0, 0, 0, 0)];
    if (v61 - __str >= 901)
    {
      uint64_t v61 = __str;
      uint64_t v62 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    int v63 = &v61[snprintf(v61, (char *)&v138 - v61, "nat64_infra_prefix_publisher %d %d %d %d|", 0, 0, 0, 0)];
    if (v63 - __str >= 901)
    {
      int v63 = __str;
      int v64 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    int v65 = &v63[snprintf(v63, (char *)&v138 - v63, "nat64_br_prefix_publisher %d %d %d %d|", 0, 0, 0, 0)];
    if (v65 - __str >= 901)
    {
      int v65 = __str;
      uint64_t v66 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    uint64_t v67 = &v65[snprintf(v65, (char *)&v138 - v65, "node_type_tracker %d %d %d %d|", old_node_type_tracker_created, node_type_tracker_created, old_node_type_tracker_finalized, node_type_tracker_finalized)];
    old_node_type_tracker_created = node_type_tracker_created;
    old_node_type_tracker_finalized = node_type_tracker_finalized;
    if (v67 - __str >= 901)
    {
      uint64_t v67 = __str;
      CFRange v68 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    uint64_t v69 = &v67[snprintf(v67, (char *)&v138 - v67, "nw_connection %d %d %d %d|", old_nw_connection_created, nw_connection_created, old_nw_connection_finalized, nw_connection_finalized)];
    old_nw_connection_created = nw_connection_created;
    old_nw_connection_finalized = nw_connection_finalized;
    if (v69 - __str >= 901)
    {
      uint64_t v69 = __str;
      int v70 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    int v71 = &v69[snprintf(v69, (char *)&v138 - v69, "nw_listener %d %d %d %d|", old_nw_listener_created, nw_listener_created, old_nw_listener_finalized, nw_listener_finalized)];
    old_nw_listener_created = nw_listener_created;
    old_nw_listener_finalized = nw_listener_finalized;
    if (v71 - __str >= 901)
    {
      int v71 = __str;
      int v72 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    int v73 = &v71[snprintf(v71, (char *)&v138 - v71, "nw_path_evaluator %d %d %d %d|", 0, 0, 0, 0)];
    if (v73 - __str >= 901)
    {
      int v73 = __str;
      uint64_t v74 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    __int16 v75 = &v73[snprintf(v73, (char *)&v138 - v73, "omr_prefix %d %d %d %d|", 0, 0, 0, 0)];
    if (v75 - __str >= 901)
    {
      __int16 v75 = __str;
      os_log_type_t v76 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    uint32_t v77 = &v75[snprintf(v75, (char *)&v138 - v75, "omr_publisher %d %d %d %d|", 0, 0, 0, 0)];
    if (v77 - __str >= 901)
    {
      uint32_t v77 = __str;
      int v78 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    unsigned int v79 = &v77[snprintf(v77, (char *)&v138 - v77, "omr_watcher %d %d %d %d|", 0, 0, 0, 0)];
    if (v79 - __str >= 901)
    {
      unsigned int v79 = __str;
      int v80 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    int v81 = &v79[snprintf(v79, (char *)&v138 - v79, "prefix_tracker %d %d %d %d|", 0, 0, 0, 0)];
    if (v81 - __str >= 901)
    {
      int v81 = __str;
      int v82 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    int v83 = &v81[snprintf(v81, (char *)&v138 - v81, "probe_state %d %d %d %d|", old_probe_state_created, probe_state_created, old_probe_state_finalized, probe_state_finalized)];
    old_probe_state_created = probe_state_created;
    old_probe_state_finalized = probe_state_finalized;
    if (v83 - __str >= 901)
    {
      int v83 = __str;
      int v84 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    xpc_object_t v85 = &v83[snprintf(v83, (char *)&v138 - v83, "question %d %d %d %d|", old_question_created, question_created, old_question_finalized, question_finalized)];
    old_question_created = question_created;
    old_question_finalized = question_finalized;
    if (v85 - __str >= 901)
    {
      xpc_object_t v85 = __str;
      int v86 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    __int16 v87 = &v85[snprintf(v85, (char *)&v138 - v85, "route_tracker %d %d %d %d|", 0, 0, 0, 0)];
    if (v87 - __str >= 901)
    {
      __int16 v87 = __str;
      int v88 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    int v89 = &v87[snprintf(v87, (char *)&v138 - v87, "rref %d %d %d %d|", old_rref_created, rref_created, old_rref_finalized, rref_finalized)];
    old_rref_created = rref_created;
    old_rref_finalized = rref_finalized;
    if (v89 - __str >= 901)
    {
      int v89 = __str;
      int v90 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    xpc_object_t v91 = &v89[snprintf(v89, (char *)&v138 - v89, "sdref %d %d %d %d|", old_sdref_created, sdref_created, old_sdref_finalized, sdref_finalized)];
    old_sdref_created = sdref_created;
    old_sdref_finalized = sdref_finalized;
    if (v91 - __str >= 901)
    {
      xpc_object_t v91 = __str;
      int v92 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    uint64_t v93 = &v91[snprintf(v91, (char *)&v138 - v91, "saref %d %d %d %d|", old_saref_created, saref_created, old_saref_finalized, saref_finalized)];
    old_saref_created = saref_created;
    old_saref_finalized = saref_finalized;
    if (v93 - __str >= 901)
    {
      uint64_t v93 = __str;
      int v94 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    int v95 = &v93[snprintf(v93, (char *)&v138 - v93, "service_publisher %d %d %d %d|", old_service_publisher_created, service_publisher_created, old_service_publisher_finalized, service_publisher_finalized)];
    old_service_publisher_created = service_publisher_created;
    old_service_publisher_finalized = service_publisher_finalized;
    if (v95 - __str >= 901)
    {
      int v95 = __str;
      int v96 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v97 = &v95[snprintf(v95, (char *)&v138 - v95, "service_tracker %d %d %d %d|", old_service_tracker_created, service_tracker_created, old_service_tracker_finalized, service_tracker_finalized)];
    old_service_tracker_created = service_tracker_created;
    old_service_tracker_finalized = service_tracker_finalized;
    if (v97 - __str >= 901)
    {
      v97 = __str;
      __int16 v98 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v98, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    int v99 = &v97[snprintf(v97, (char *)&v138 - v97, "srp_xpc_client %d %d %d %d|", old_srp_xpc_client_created, srp_xpc_client_created, old_srp_xpc_client_finalized, srp_xpc_client_finalized)];
    old_srp_xpc_client_created = srp_xpc_client_created;
    old_srp_xpc_client_finalized = srp_xpc_client_finalized;
    if (v99 - __str >= 901)
    {
      int v99 = __str;
      int v100 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    int v101 = &v99[snprintf(v99, (char *)&v138 - v99, "srpl_connection %d %d %d %d|", 0, 0, 0, 0)];
    if (v101 - __str >= 901)
    {
      int v101 = __str;
      __int16 v102 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v103 = &v101[snprintf(v101, (char *)&v138 - v101, "srpl_domain %d %d %d %d|", 0, 0, 0, 0)];
    if (v103 - __str >= 901)
    {
      v103 = __str;
      v104 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    v105 = &v103[snprintf(v103, (char *)&v138 - v103, "srpl_instance %d %d %d %d|", 0, 0, 0, 0)];
    if (v105 - __str >= 901)
    {
      v105 = __str;
      uint64_t v106 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    uint64_t v107 = &v105[snprintf(v105, (char *)&v138 - v105, "srpl_instance_service %d %d %d %d|", 0, 0, 0, 0)];
    if (v107 - __str >= 901)
    {
      uint64_t v107 = __str;
      __int16 v108 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    uint64_t v109 = &v107[snprintf(v107, (char *)&v138 - v107, "state_machine_event %d %d %d %d|", old_state_machine_event_created, state_machine_event_created, old_state_machine_event_finalized, state_machine_event_finalized)];
    old_state_machine_event_created = state_machine_event_created;
    old_state_machine_event_finalized = state_machine_event_finalized;
    if (v109 - __str >= 901)
    {
      uint64_t v109 = __str;
      __int16 v110 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    int v111 = &v109[snprintf(v109, (char *)&v138 - v109, "subproc %d %d %d %d|", 0, 0, 0, 0)];
    if (v111 - __str >= 901)
    {
      int v111 = __str;
      int v112 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v112, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    int v113 = &v111[snprintf(v111, (char *)&v138 - v111, "thread_service %d %d %d %d|", old_thread_service_created, thread_service_created, old_thread_service_finalized, thread_service_finalized)];
    old_thread_service_created = thread_service_created;
    old_thread_service_finalized = thread_service_finalized;
    if (v113 - __str >= 901)
    {
      int v113 = __str;
      uint64_t v114 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v114, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    uint64_t v115 = &v113[snprintf(v113, (char *)&v138 - v113, "thread_tracker %d %d %d %d|", old_thread_tracker_created, thread_tracker_created, old_thread_tracker_finalized, thread_tracker_finalized)];
    old_thread_tracker_created = thread_tracker_created;
    old_thread_tracker_finalized = thread_tracker_finalized;
    if (v115 - __str >= 901)
    {
      uint64_t v115 = __str;
      __int16 v116 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v116, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
    int v117 = snprintf(v115, (char *)&v138 - v115, "wakeup %d %d %d %d|", old_wakeup_created, wakeup_created, old_wakeup_finalized, wakeup_finalized);
    old_wakeup_created = wakeup_created;
    old_wakeup_finalized = wakeup_finalized;
    if (&v115[v117] - __str >= 901)
    {
      int v118 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_248;
      }
      goto LABEL_247;
    }
    if (v117)
    {
      int v118 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
LABEL_247:
        *(_DWORD *)buf = 136446466;
        int v129 = "ioloop_dump_object_allocation_stats";
        __int16 v130 = 2082;
        v131 = __str;
        _os_log_impl((void *)&_mh_execute_header, v118, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s", buf, 0x16u);
      }
    }
  }
LABEL_248:
  int v119 = opendir("/dev/fd");
  if (!v119)
  {
    if (*__error() == 24)
    {
      v122 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__str = 136446210;
        int v133 = "get_num_fds";
        int v127 = "%{public}s: per-process open file limit reached.";
LABEL_265:
        _os_log_impl((void *)&_mh_execute_header, v122, OS_LOG_TYPE_FAULT, v127, (uint8_t *)__str, 0xCu);
      }
    }
    else
    {
      int v123 = *__error();
      v122 = global_os_log;
      if (v123 != 23)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          int v124 = *__error();
          v125 = __error();
          v126 = strerror(*v125);
          *(_DWORD *)__str = 136446722;
          int v133 = "get_num_fds";
          __int16 v134 = 1024;
          int v135 = v124;
          __int16 v136 = 2082;
          uint64_t v137 = v126;
          _os_log_impl((void *)&_mh_execute_header, v122, OS_LOG_TYPE_ERROR, "%{public}s: errno %d %{public}s", (uint8_t *)__str, 0x1Cu);
          int v121 = 0;
          v122 = global_os_log;
        }
        else
        {
          int v121 = 0;
        }
        goto LABEL_258;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)__str = 136446210;
        int v133 = "get_num_fds";
        int v127 = "%{public}s: per-system open file limit reached.";
        goto LABEL_265;
      }
    }
    v122 = global_os_log;
LABEL_267:
    if (os_log_type_enabled(v122, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)__str = 136446210;
      int v133 = "ioloop_dump_object_allocation_stats";
      _os_log_impl((void *)&_mh_execute_header, v122, OS_LOG_TYPE_FAULT, "%{public}s: out of file descriptors!!", (uint8_t *)__str, 0xCu);
    }
    abort();
  }
  v120 = v119;
  int v121 = -1;
  do
    ++v121;
  while (readdir(v120));
  closedir(v120);
  v122 = global_os_log;
  if (v121 < 0) {
    goto LABEL_267;
  }
LABEL_258:
  if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__str = 136446466;
    int v133 = "ioloop_dump_object_allocation_stats";
    __int16 v134 = 1024;
    int v135 = v121;
    _os_log_impl((void *)&_mh_execute_header, v122, OS_LOG_TYPE_DEFAULT, "%{public}s: %d file descriptors in use", (uint8_t *)__str, 0x12u);
  }
}

_OWORD *ioloop_message_create_(uint64_t a1, char *a2, int a3)
{
  if ((unint64_t)(a1 - 0x10000) < 0xFFFFFFFFFFFF000CLL) {
    return 0;
  }
  __int16 v6 = a1;
  uint64_t v7 = malloc_type_malloc(a1 + 94, 0xFD9DA76EuLL);
  uint64_t v3 = v7;
  if (v7)
  {
    *(_OWORD *)((char *)v7 + 78) = 0u;
    v7[3] = 0u;
    v7[4] = 0u;
    v7[1] = 0u;
    v7[2] = 0u;
    _OWORD *v7 = 0u;
    int v8 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_10;
    }
    *(_DWORD *)buf = 136447490;
    int v15 = "ioloop_message_create_";
    __int16 v16 = 1024;
    int v17 = 0;
    __int16 v18 = 2048;
    unsigned int v19 = v3;
    __int16 v20 = 2080;
    unsigned int v21 = "message";
    __int16 v22 = 2080;
    __int16 v23 = strrchr(a2, 47) + 1;
    __int16 v24 = 1024;
    int v25 = a3;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    int v9 = *(_DWORD *)v3;
    if (*(_DWORD *)v3)
    {
      int v10 = v9 + 1;
      *(_DWORD *)uint64_t v3 = v9 + 1;
      if (v9 + 1 >= 10001)
      {
        int v11 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          uint32_t v12 = strrchr(a2, 47);
          *(_DWORD *)buf = 136447490;
          int v15 = "ioloop_message_create_";
          __int16 v16 = 1024;
          int v17 = v10;
          __int16 v18 = 2048;
          unsigned int v19 = v3;
          __int16 v20 = 2080;
          unsigned int v21 = "message";
          __int16 v22 = 2080;
          __int16 v23 = v12 + 1;
          __int16 v24 = 1024;
          int v25 = a3;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        abort();
      }
    }
    else
    {
LABEL_10:
      ++message_created;
      *(_DWORD *)uint64_t v3 = 1;
    }
    *((_WORD *)v3 + 32) = v6;
  }
  return v3;
}

void adv_ctl_set_int(uint64_t a1, unint64_t *a2, char *__str)
{
  unint64_t v3 = a2[3];
  if (v3 >= 0x129)
  {
    uint64_t v4 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136446722;
    __int16 v23 = "adv_ctl_set_int";
    __int16 v24 = 2048;
    unint64_t v25 = v3;
    __int16 v26 = 2048;
    uint64_t v27 = 296;
    uint64_t v5 = "%{public}s: which->offset out of range: %zu vs %zu";
    __int16 v6 = v4;
LABEL_19:
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, v5, buf, 0x20u);
    return;
  }
  __endptr = 0;
  if (*__str == 48 && __str[1] == 120)
  {
    int v10 = __str + 2;
    int v11 = 16;
  }
  else
  {
    int v10 = __str;
    int v11 = 10;
  }
  uint64_t v12 = strtol(v10, &__endptr, v11);
  uint64_t v13 = v12;
  if (__endptr == __str) {
    goto LABEL_17;
  }
  if (!__endptr)
  {
    if (v12 == (int)v12) {
      goto LABEL_21;
    }
LABEL_17:
    uint64_t v16 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    unint64_t v17 = *a2;
    *(_DWORD *)buf = 136446722;
    __int16 v23 = "adv_ctl_set_int";
    __int16 v24 = 2082;
    unint64_t v25 = v17;
    __int16 v26 = 2082;
    uint64_t v27 = (uint64_t)__str;
    uint64_t v5 = "%{public}s: invalid int for %{public}s: %{public}s";
    __int16 v6 = v16;
    goto LABEL_19;
  }
  if (*__endptr) {
    BOOL v14 = 1;
  }
  else {
    BOOL v14 = v12 < (uint64_t)0xFFFFFFFF80000000;
  }
  if (v14 || v12 > 0x7FFFFFFF) {
    goto LABEL_17;
  }
LABEL_21:
  __int16 v18 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    unint64_t v19 = *a2;
    int v20 = *(_DWORD *)(a1 + v3);
    *(_DWORD *)buf = 136447746;
    __int16 v23 = "adv_ctl_set_int";
    __int16 v24 = 2082;
    unint64_t v25 = v19;
    __int16 v26 = 2082;
    uint64_t v27 = (uint64_t)__str;
    __int16 v28 = 2048;
    uint64_t v29 = v13;
    __int16 v30 = 2048;
    uint64_t v31 = v13;
    __int16 v32 = 1024;
    int v33 = v20;
    __int16 v34 = 1024;
    int v35 = v20;
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: setting %{public}s to '%{public}s' %ld (%lx), originally %d (%x)", buf, 0x40u);
  }
  *(_DWORD *)(a1 + v3) = v13;
}

void adv_ctl_thread_shutdown_continue(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 176);
  if (v2)
  {
    ioloop_cancel_wake_event(v2);
    ioloop_wakeup_release_(*(void **)(a1 + 176), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/adv-ctl-server.c", 371);
    *(void *)(a1 + 176) = 0;
  }
  xpc_object_t reply = xpc_dictionary_create_reply(*(xpc_object_t *)(a1 + 168));
  if (reply)
  {
    uint64_t v4 = reply;
    xpc_dictionary_set_uint64(reply, "status", 0);
    xpc_connection_send_message(*(xpc_connection_t *)(a1 + 160), v4);
    xpc_release(v4);
    xpc_release(*(xpc_object_t *)(a1 + 168));
    *(void *)(a1 + 168) = 0;
    xpc_release(*(xpc_object_t *)(a1 + 160));
    *(void *)(a1 + 160) = 0;
    *(_WORD *)(a1 + 284) = 0;
    uint64_t v5 = *(void *)(a1 + 144);
    if (v5)
    {
      __int16 v6 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v8 = 136446466;
        int v9 = "adv_ctl_thread_shutdown_continue";
        __int16 v10 = 2048;
        uint64_t v11 = v5;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: clearing server_state->wanted (%p) unconditionally.", (uint8_t *)&v8, 0x16u);
        uint64_t v5 = *(void *)(a1 + 144);
      }
      srp_xpc_client_finalize(v5);
    }
  }
  else
  {
    uint64_t v7 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      int v8 = 136446210;
      int v9 = "adv_ctl_thread_shutdown_continue";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "%{public}s: adv_xpc_message: Unable to create reply dictionary.", (uint8_t *)&v8, 0xCu);
    }
  }
}

void srp_xpc_client_finalize(uint64_t a1)
{
  uint64_t v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 136446210;
    uint64_t v7 = "srp_xpc_client_finalize";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: No longer wanted.", (uint8_t *)&v6, 0xCu);
  }
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3)
  {
    *(void *)(v3 + 144) = 0;
    os_release(*(void **)(a1 + 8));
    free((void *)a1);
    thread_device_shutdown((uint64_t *)v3);
    *(unsigned char *)(v3 + 288) = 0;
    uint64_t v4 = *(void ***)(v3 + 80);
    if (v4)
    {
      do
      {
        uint64_t v5 = (void **)*v4;
        adv_ctl_wanted_service_free(v4);
        uint64_t v4 = v5;
      }
      while (v5);
    }
    *(void *)(v3 + 80) = 0;
  }
  else
  {
    os_release(*(void **)(a1 + 8));
    free((void *)a1);
  }
}

void adv_ctl_wanted_service_free(void **a1)
{
  uint64_t v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = "<null>";
    uint64_t v4 = (const char *)a1[1];
    if (!v4) {
      uint64_t v4 = "<null>";
    }
    if (a1[2]) {
      uint64_t v3 = (const char *)a1[2];
    }
    int v5 = 136447235;
    int v6 = "adv_ctl_wanted_service_free";
    __int16 v7 = 2160;
    uint64_t v8 = 1752392040;
    __int16 v9 = 2081;
    __int16 v10 = v4;
    __int16 v11 = 2082;
    uint64_t v12 = v3;
    __int16 v13 = 2048;
    BOOL v14 = a1;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: %{private, mask.hash}s%{public}s: %p", (uint8_t *)&v5, 0x34u);
  }
  free(a1[1]);
  free(a1[2]);
  free(a1);
}

BOOL adv_xpc_message(xpc_connection_t connection, unint64_t a2, uint64_t a3)
{
  if (!((unint64_t)connection | a2))
  {
    if (adv_xpc_wakeup)
    {
      ioloop_cancel_wake_event(adv_xpc_wakeup);
      uint64_t v4 = (int *)adv_xpc_wakeup;
LABEL_38:
      ioloop_add_wake_event((uint64_t)v4, a3, (uint64_t)adv_xpc_restart, 0, 0x2710u);
      return 0;
    }
    uint64_t v4 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/adv-ctl-server.c", 1026);
    adv_xpc_wakeup = (uint64_t)v4;
    if (v4) {
      goto LABEL_38;
    }
    uint64_t v16 = global_os_log;
    BOOL v37 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
    BOOL result = 0;
    if (!v37) {
      return result;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "adv_xpc_message";
    unint64_t v19 = "%{public}s: can't create a wakeup to try to recover.";
    goto LABEL_63;
  }
  if (!connection)
  {
    uint64_t v16 = global_os_log;
    BOOL v17 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
    BOOL result = 0;
    if (!v17) {
      return result;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "adv_xpc_message";
    unint64_t v19 = "%{public}s: disconnected.";
LABEL_63:
    uint64_t v38 = v16;
    os_log_type_t v39 = OS_LOG_TYPE_DEFAULT;
LABEL_182:
    _os_log_impl((void *)&_mh_execute_header, v38, v39, v19, buf, 0xCu);
    return 0;
  }
  pid_t pid = xpc_connection_get_pid(connection);
  uid_t euid = xpc_connection_get_euid(connection);
  if (!a2)
  {
    uint64_t v20 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "adv_xpc_message";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = euid;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = pid;
      uint64_t v12 = "%{public}s: Client uid %d pid %d disconnected.";
      __int16 v13 = v20;
      os_log_type_t v14 = OS_LOG_TYPE_DEFAULT;
      uint32_t v15 = 24;
      goto LABEL_43;
    }
LABEL_44:
    adv_xpc_connection_delete(connection);
    return 0;
  }
  string = xpc_dictionary_get_string((xpc_object_t)a2, "xpc-command");
  if (!strcmp(string, "enable"))
  {
    unsigned int v21 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "adv_xpc_message";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = euid;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = pid;
      *(_WORD *)&buf[24] = 2082;
      *(void *)&buf[26] = string;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%{public}s: Client uid %d pid %d sent a %{public}s request.", buf, 0x22u);
    }
    xpc_object_t reply = xpc_dictionary_create_reply((xpc_object_t)a2);
    if (!reply)
    {
      uint64_t v70 = global_os_log;
      BOOL result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "adv_proxy_enable";
      unint64_t v19 = "%{public}s: Unable to create reply dictionary.";
LABEL_181:
      uint64_t v38 = v70;
      os_log_type_t v39 = OS_LOG_TYPE_ERROR;
      goto LABEL_182;
    }
    __int16 v23 = reply;
    __int16 v24 = (int *)malloc_type_calloc(1uLL, 0x30uLL, 0x10A0040CB5CB6FCuLL);
    if (!v24)
    {
      int v71 = -65539;
      int v72 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "adv_proxy_enable";
        _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate client state structure.", buf, 0xCu);
      }
      goto LABEL_168;
    }
    unint64_t v25 = v24;
    if (!*(void *)(a3 + 144))
    {
      int v73 = malloc_type_calloc(1uLL, 0x18uLL, 0x1020040F89CB87BuLL);
      *(void *)(a3 + 144) = v73;
      if (!v73)
      {
        int v71 = -65539;
        __int16 v87 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
          goto LABEL_167;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "adv_proxy_enable";
        int v88 = "%{public}s: unable to allocate srp_wanted structure.";
        goto LABEL_147;
      }
      v73[2] = a3;
      *(void *)(*(void *)(a3 + 144) + 8) = os_transaction_create();
      uint64_t v74 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "adv_proxy_enable";
        _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "%{public}s: Wanted.", buf, 0xCu);
      }
    }
    xpc_object_t array = xpc_dictionary_get_array((xpc_object_t)a2, "permitted-interfaces");
    if (array)
    {
      uint64_t v27 = array;
      if (xpc_get_type(array) != (xpc_type_t)&_xpc_type_array)
      {
        __int16 v28 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "adv_proxy_enable";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = "permitted-interfaces";
          _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "%{public}s: %{public}s type is not array", buf, 0x16u);
        }
      }
      size_t count = xpc_array_get_count(v27);
      if (count)
      {
        size_t v30 = count;
        uint64_t v31 = malloc_type_calloc(count, 8uLL, 0x10040436913F5uLL);
        *((void *)v25 + 4) = v31;
        if (v31)
        {
          size_t v32 = 0;
          while (1)
          {
            int v33 = xpc_array_get_string(v27, v32);
            if (!v33) {
              break;
            }
            __int16 v34 = (char *)v33;
            int v35 = strdup(v33);
            uint64_t v36 = v25[10];
            *(void *)(*((void *)v25 + 4) + 8 * v36) = v35;
            if (!*(void *)(*((void *)v25 + 4) + 8 * v36))
            {
              int v96 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "adv_proxy_enable";
                *(_WORD *)&unsigned char buf[12] = 2082;
                *(void *)&buf[14] = v34;
                _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_ERROR, "%{public}s: no memory for client permitted interface list entry for %{public}s", buf, 0x16u);
                LODWORD(v36) = v25[10];
              }
              if ((int)v36 >= 1)
              {
                uint64_t v97 = 0;
                do
                  free(*(void **)(*((void *)v25 + 4) + 8 * v97++));
                while (v97 < v25[10]);
              }
              int v71 = -65539;
              free(*((void **)v25 + 4));
              goto LABEL_167;
            }
            v25[10] = v36 + 1;
            ifpermit_add_permitted_interface_to_server_(a3, v34, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/adv-ctl-server.c", 763);
            if (v30 == ++v32) {
              goto LABEL_133;
            }
          }
          xpc_object_t value = xpc_array_get_value(v27, v32);
          uint64_t v93 = xpc_copy_description(value);
          int v94 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          {
            int v95 = "<null>";
            if (v93) {
              int v95 = v93;
            }
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "adv_proxy_enable";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v95;
            _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_ERROR, "%{public}s: non-string interface %{public}s specified", buf, 0x16u);
          }
          free(v93);
          int v71 = 0;
LABEL_167:
          free(v25);
LABEL_168:
          xpc_dictionary_set_uint64(v23, "status", v71);
          xpc_connection_send_message(connection, v23);
          xpc_release(v23);
          return v71 == 0;
        }
        goto LABEL_141;
      }
      unsigned int v79 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "adv_proxy_enable";
        _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_ERROR, "%{public}s: empty permitted interface array.", buf, 0xCu);
      }
      int v80 = malloc_type_calloc(0, 8uLL, 0x10040436913F5uLL);
      *((void *)v25 + 4) = v80;
      if (!v80)
      {
LABEL_141:
        int v71 = -65539;
        __int16 v87 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
          goto LABEL_167;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "adv_proxy_enable";
        int v88 = "%{public}s: no memory for client permitted interface list.";
LABEL_147:
        _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_ERROR, v88, buf, 0xCu);
        goto LABEL_167;
      }
    }
LABEL_133:
    thread_device_startup((uint64_t *)a3);
    int v81 = *(int **)(a3 + 144);
    if (v81)
    {
      int v82 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v83 = *v81;
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "adv_proxy_enable";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v83;
        *(_WORD *)&buf[18] = 2048;
        *(void *)&buf[20] = v81;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "server_state->wanted";
        __int16 v113 = 2080;
        uint64_t v114 = "adv-ctl-server.c";
        __int16 v115 = 1024;
        int v116 = 768;
        _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        int v81 = *(int **)(a3 + 144);
      }
      int v84 = *v81;
      if (*v81)
      {
        int v85 = v84 + 1;
        *int v81 = v84 + 1;
        if (v84 + 1 >= 10001)
        {
          int v86 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136447490;
            *(void *)&uint8_t buf[4] = "adv_proxy_enable";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v85;
            *(_WORD *)&buf[18] = 2048;
            *(void *)&buf[20] = v81;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = "server_state->wanted";
            __int16 v113 = 2080;
            uint64_t v114 = "adv-ctl-server.c";
            __int16 v115 = 1024;
            int v116 = 768;
            _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          }
          abort();
        }
      }
      else
      {
        ++srp_xpc_client_created;
        *int v81 = 1;
      }
    }
    *((void *)v25 + 1) = connection;
    *((void *)v25 + 2) = a3;
    xpc_retain(connection);
    *((unsigned char *)v25 + 25) = 1;
    int v89 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "adv_proxy_enable";
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v25;
      _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, "%{public}s: connection from client: %p", buf, 0x16u);
    }
    int v90 = &srp_xpc_clients;
    do
    {
      xpc_object_t v91 = v90;
      int v90 = (uint64_t *)*v90;
    }
    while (v90);
    int v71 = 0;
    uint64_t *v91 = (uint64_t)v25;
    goto LABEL_168;
  }
  if (!strcmp(string, "list service types"))
  {
    uint64_t v40 = global_os_log;
    int v41 = 0;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_174;
    }
    goto LABEL_176;
  }
  if (strcmp(string, "list services"))
  {
    if (!strcmp(string, "list hosts"))
    {
      uint64_t v40 = global_os_log;
      int v41 = 0;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_174;
      }
    }
    else if (!strcmp(string, "get host"))
    {
      uint64_t v40 = global_os_log;
      int v41 = 0;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_174;
      }
    }
    else
    {
      if (!strcmp(string, "flush entries"))
      {
        __int16 v75 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "adv_xpc_message";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = euid;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = pid;
          *(_WORD *)&buf[24] = 2082;
          *(void *)&buf[26] = string;
          _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "%{public}s: Client uid %d pid %d sent a %{public}s request.", buf, 0x22u);
        }
        srp_mdns_flush(a3);
        goto LABEL_175;
      }
      if (!strcmp(string, "block service"))
      {
        uint64_t v40 = global_os_log;
        int v41 = 0;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_174;
        }
      }
      else if (!strcmp(string, "unblock service"))
      {
        uint64_t v40 = global_os_log;
        int v41 = 0;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_174;
        }
      }
      else if (!strcmp(string, "regenerate ULA"))
      {
        uint64_t v40 = global_os_log;
        int v41 = 0;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_174;
        }
      }
      else if (!strcmp(string, "advertise prefix"))
      {
        uint64_t v40 = global_os_log;
        int v41 = 0;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_174;
        }
      }
      else
      {
        if (strcmp(string, "advertise prefix high priority"))
        {
          if (!strcmp(string, "add prefix"))
          {
            int v100 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
LABEL_188:
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "adv_xpc_message";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = euid;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = pid;
              *(_WORD *)&buf[24] = 2082;
              *(void *)&buf[26] = string;
              _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_DEFAULT, "%{public}s: Client uid %d pid %d sent a %{public}s request.", buf, 0x22u);
            }
          }
          else
          {
            if (strcmp(string, "remove prefix"))
            {
              if (!strcmp(string, "add nat64 prefix"))
              {
                __int16 v102 = global_os_log;
                if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                {
LABEL_194:
                  int v101 = adv_ctl_nat64_prefix_add_remove((void *)a2);
                  goto LABEL_195;
                }
              }
              else
              {
                if (strcmp(string, "remove nat64 prefix"))
                {
                  if (!strcmp(string, "stop"))
                  {
                    v103 = global_os_log;
                    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 136446978;
                      *(void *)&uint8_t buf[4] = "adv_xpc_message";
                      *(_WORD *)&unsigned char buf[12] = 1024;
                      *(_DWORD *)&buf[14] = euid;
                      *(_WORD *)&buf[18] = 1024;
                      *(_DWORD *)&buf[20] = pid;
                      *(_WORD *)&buf[24] = 2082;
                      *(void *)&buf[26] = string;
                      _os_log_impl((void *)&_mh_execute_header, v103, OS_LOG_TYPE_DEFAULT, "%{public}s: Client uid %d pid %d sent a %{public}s request.", buf, 0x22u);
                    }
                    thread_device_stop((uint64_t *)a3);
                    goto LABEL_175;
                  }
                  if (!strcmp(string, "get ula"))
                  {
                    v104 = global_os_log;
                    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 136446978;
                      *(void *)&uint8_t buf[4] = "adv_xpc_message";
                      *(_WORD *)&unsigned char buf[12] = 1024;
                      *(_DWORD *)&buf[14] = euid;
                      *(_WORD *)&buf[18] = 1024;
                      *(_DWORD *)&buf[20] = pid;
                      *(_WORD *)&buf[24] = 2082;
                      *(void *)&buf[26] = string;
                      _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEFAULT, "%{public}s: Client uid %d pid %d sent a %{public}s request.", buf, 0x22u);
                    }
                    return adv_xpc_get_ula((void *)a2, connection, a3);
                  }
                  if (!strcmp(string, "disable SRP replication"))
                  {
                    uint64_t v40 = global_os_log;
                    int v41 = 0;
                    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_176;
                    }
                  }
                  else if (!strcmp(string, "drop srpl connection"))
                  {
                    uint64_t v40 = global_os_log;
                    int v41 = 0;
                    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_176;
                    }
                  }
                  else if (!strcmp(string, "undrop srpl connection"))
                  {
                    uint64_t v40 = global_os_log;
                    int v41 = 0;
                    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_176;
                    }
                  }
                  else if (!strcmp(string, "drop srpl advertisement"))
                  {
                    uint64_t v40 = global_os_log;
                    int v41 = 0;
                    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_176;
                    }
                  }
                  else if (!strcmp(string, "undrop srpl advertisement"))
                  {
                    uint64_t v40 = global_os_log;
                    int v41 = 0;
                    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
                      goto LABEL_176;
                    }
                  }
                  else
                  {
                    if (!strcmp(string, "start dropping push connections"))
                    {
                      v105 = global_os_log;
                      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)buf = 136446978;
                        *(void *)&uint8_t buf[4] = "adv_xpc_message";
                        *(_WORD *)&unsigned char buf[12] = 1024;
                        *(_DWORD *)&buf[14] = euid;
                        *(_WORD *)&buf[18] = 1024;
                        *(_DWORD *)&buf[20] = pid;
                        *(_WORD *)&buf[24] = 2082;
                        *(void *)&buf[26] = string;
                        _os_log_impl((void *)&_mh_execute_header, v105, OS_LOG_TYPE_DEFAULT, "%{public}s: Client uid %d pid %d sent a %{public}s request.", buf, 0x22u);
                      }
                      dp_start_dropping();
                      goto LABEL_175;
                    }
                    if (!strcmp(string, "start breaking time validation"))
                    {
                      uint64_t v106 = global_os_log;
                      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)buf = 136446978;
                        *(void *)&uint8_t buf[4] = "adv_xpc_message";
                        *(_WORD *)&unsigned char buf[12] = 1024;
                        *(_DWORD *)&buf[14] = euid;
                        *(_WORD *)&buf[18] = 1024;
                        *(_DWORD *)&buf[20] = pid;
                        *(_WORD *)&buf[24] = 2082;
                        *(void *)&buf[26] = string;
                        _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_DEFAULT, "%{public}s: Client uid %d pid %d sent a %{public}s request.", buf, 0x22u);
                      }
                      int v41 = 0;
                      *(unsigned char *)(a3 + 281) = 1;
                      goto LABEL_176;
                    }
                    if (!strcmp(string, "set variable"))
                    {
                      uint64_t v107 = global_os_log;
                      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)buf = 136446978;
                        *(void *)&uint8_t buf[4] = "adv_xpc_message";
                        *(_WORD *)&unsigned char buf[12] = 1024;
                        *(_DWORD *)&buf[14] = euid;
                        *(_WORD *)&buf[18] = 1024;
                        *(_DWORD *)&buf[20] = pid;
                        *(_WORD *)&buf[24] = 2082;
                        *(void *)&buf[26] = string;
                        _os_log_impl((void *)&_mh_execute_header, v107, OS_LOG_TYPE_DEFAULT, "%{public}s: Client uid %d pid %d sent a %{public}s request.", buf, 0x22u);
                      }
                      adv_ctl_xpc_set_variable(a3, (xpc_object_t)a2);
                      goto LABEL_175;
                    }
                    if (!strcmp(string, "block anycast service"))
                    {
                      uint64_t v40 = global_os_log;
                      int v41 = 0;
                      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_176;
                      }
                    }
                    else
                    {
                      if (strcmp(string, "unblock anycast service"))
                      {
                        if (!strcmp(string, "start thread shutdown"))
                        {
                          __int16 v108 = global_os_log;
                          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                          {
                            *(_DWORD *)buf = 136446978;
                            *(void *)&uint8_t buf[4] = "adv_xpc_message";
                            *(_WORD *)&unsigned char buf[12] = 1024;
                            *(_DWORD *)&buf[14] = euid;
                            *(_WORD *)&buf[18] = 1024;
                            *(_DWORD *)&buf[20] = pid;
                            *(_WORD *)&buf[24] = 2082;
                            *(void *)&buf[26] = string;
                            _os_log_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_DEFAULT, "%{public}s: Client uid %d pid %d sent a %{public}s request.", buf, 0x22u);
                          }
                          adv_ctl_start_thread_shutdown((void *)a2, connection, a3);
                          return 1;
                        }
                        int v10 = strcmp(string, "need service instance");
                        __int16 v11 = global_os_log;
                        if (v10)
                        {
                          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                          {
                            *(_DWORD *)buf = 136446978;
                            *(void *)&uint8_t buf[4] = "adv_xpc_message";
                            *(_WORD *)&unsigned char buf[12] = 1024;
                            *(_DWORD *)&buf[14] = euid;
                            *(_WORD *)&buf[18] = 1024;
                            *(_DWORD *)&buf[20] = pid;
                            *(_WORD *)&buf[24] = 2082;
                            *(void *)&buf[26] = string;
                            uint64_t v12 = "%{public}s: Client uid %d pid %d sent a request with unknown message type %{public}s.";
                            __int16 v13 = v11;
                            os_log_type_t v14 = OS_LOG_TYPE_ERROR;
                            uint32_t v15 = 34;
LABEL_43:
                            _os_log_impl((void *)&_mh_execute_header, v13, v14, v12, buf, v15);
                            goto LABEL_44;
                          }
                          goto LABEL_44;
                        }
                        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_DWORD *)buf = 136446722;
                          *(void *)&uint8_t buf[4] = "adv_xpc_message";
                          *(_WORD *)&unsigned char buf[12] = 1024;
                          *(_DWORD *)&buf[14] = euid;
                          *(_WORD *)&buf[18] = 1024;
                          *(_DWORD *)&buf[20] = pid;
                          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: Client uid %d pid %d sent a kDNSSDAdvertisingProxyNeedServiceInstance request.", buf, 0x18u);
                        }
                        adv_ctl_need_service_instance((void *)a2, a3);
                        goto LABEL_175;
                      }
                      uint64_t v40 = global_os_log;
                      int v41 = 0;
                      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
                        goto LABEL_176;
                      }
                    }
                  }
LABEL_174:
                  *(_DWORD *)buf = 136446978;
                  *(void *)&uint8_t buf[4] = "adv_xpc_message";
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = euid;
                  *(_WORD *)&buf[18] = 1024;
                  *(_DWORD *)&buf[20] = pid;
                  *(_WORD *)&buf[24] = 2082;
                  *(void *)&buf[26] = string;
                  _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "%{public}s: Client uid %d pid %d sent a %{public}s request.", buf, 0x22u);
LABEL_175:
                  int v41 = 0;
                  goto LABEL_176;
                }
                __int16 v102 = global_os_log;
                if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_194;
                }
              }
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "adv_xpc_message";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = euid;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = pid;
              *(_WORD *)&buf[24] = 2082;
              *(void *)&buf[26] = string;
              _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_DEFAULT, "%{public}s: Client uid %d pid %d sent a %{public}s request.", buf, 0x22u);
              goto LABEL_194;
            }
            int v100 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
              goto LABEL_188;
            }
          }
          int v101 = adv_ctl_prefix_add_remove((void *)a2);
LABEL_195:
          int v41 = v101;
          goto LABEL_176;
        }
        uint64_t v40 = global_os_log;
        int v41 = 0;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_174;
        }
      }
    }
LABEL_176:
    xpc_object_t v98 = xpc_dictionary_create_reply((xpc_object_t)a2);
    if (v98)
    {
      int v99 = v98;
      xpc_dictionary_set_uint64(v98, "status", v41);
      xpc_connection_send_message(connection, v99);
      int v78 = v99;
LABEL_178:
      xpc_release(v78);
      return 0;
    }
    uint64_t v70 = global_os_log;
    BOOL result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "adv_xpc_message";
    unint64_t v19 = "%{public}s: adv_xpc_message: Unable to create reply dictionary.";
    goto LABEL_181;
  }
  int v42 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "adv_xpc_message";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = euid;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = pid;
    *(_WORD *)&buf[24] = 2082;
    *(void *)&buf[26] = string;
    _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_DEFAULT, "%{public}s: Client uid %d pid %d sent a %{public}s request.", buf, 0x22u);
  }
  xpc_object_t v43 = xpc_array_create(0, 0);
  *(void *)buf = 0;
  *(void *)&buf[8] = 0;
  gettimeofday((timeval *)buf, 0);
  if (!v43)
  {
    uint64_t v70 = global_os_log;
    BOOL result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "adv_xpc_list_services";
    unint64_t v19 = "%{public}s: adv_xpc_list_services: Unable to create service array";
    goto LABEL_181;
  }
  uint64_t v44 = *(void *)buf;
  int v45 = *(_DWORD *)&buf[8];
  xpc_object_t v46 = xpc_dictionary_create_reply((xpc_object_t)a2);
  if (!v46)
  {
    uint64_t v70 = global_os_log;
    BOOL result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "adv_xpc_list_services";
    unint64_t v19 = "%{public}s: adv_xpc_list_services: Unable to create reply dictionary.";
    goto LABEL_181;
  }
  xpc_object_t xdict = v46;
  xpc_dictionary_set_uint64(v46, "status", 0);
  uint64_t v47 = *(void *)(a3 + 8);
  if (!v47) {
    goto LABEL_107;
  }
  uint64_t v48 = 1000 * v44 + v45 / 1000;
  uint64_t v110 = v48;
  xpc_object_t v111 = v43;
  while (2)
  {
    char v49 = 0;
    for (int i = 0; ; ++i)
    {
      uint64_t v51 = *(void *)(v47 + 112);
      if (v51 && i < *(_DWORD *)(v51 + 4))
      {
        uint64_t v52 = *(void *)(*(void *)(v51 + 8) + 8 * i);
        if (!v52) {
          continue;
        }
        goto LABEL_79;
      }
      if (v49) {
        break;
      }
      uint64_t v52 = 0;
LABEL_79:
      xpc_object_t v53 = xpc_dictionary_create(0, 0, 0);
      if (!v53)
      {
        os_log_type_t v76 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          uint64_t v77 = *(void *)(v47 + 56);
          *(_DWORD *)__str = 136446723;
          int v118 = "adv_xpc_list_services";
          __int16 v119 = 2160;
          uint64_t v120 = 1752392040;
          __int16 v121 = 2081;
          uint64_t v122 = v77;
          _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_ERROR, "%{public}s: adv_xpc_list_services: failed to allocate instance dictionary for %{private, mask.hash}s", (uint8_t *)__str, 0x20u);
        }
        xpc_release(v43);
        int v78 = xdict;
        goto LABEL_178;
      }
      int v54 = v53;
      xpc_dictionary_set_string(v53, "hostname", *(const char **)(v47 + 56));
      xpc_dictionary_set_string(v54, "regname", *(const char **)(v47 + 64));
      if (v52)
      {
        xpc_dictionary_set_string(v54, "name", *(const char **)(v52 + 48));
        xpc_dictionary_set_string(v54, "type", *(const char **)(v52 + 56));
        snprintf(__str, 6uLL, "%u", *(_DWORD *)(v52 + 64));
        xpc_dictionary_set_string(v54, "port", __str);
        xpc_dictionary_set_data(v54, "txt", *(const void **)(v52 + 72), *(unsigned __int16 *)(v52 + 80));
        __int16 v55 = "replicated";
        if (*(void *)(v47 + 224) == *(void *)(a3 + 224))
        {
          if (*(unsigned char *)(v52 + 118)) {
            __int16 v55 = "anycast";
          }
          else {
            __int16 v55 = "unicast";
          }
        }
        xpc_dictionary_set_string(v54, "regtype", v55);
      }
      uint64_t v56 = *(void *)(v47 + 96);
      if (v56)
      {
        if (*(int *)(v56 + 4) >= 1)
        {
          xpc_object_t empty = xpc_array_create_empty();
          if (empty)
          {
            int v58 = empty;
            uint64_t v59 = *(void *)(v47 + 96);
            if (*(int *)(v59 + 4) >= 1)
            {
              uint64_t v60 = 0;
              int v61 = 0;
              do
              {
                uint64_t v62 = *(void *)(*(void *)(v59 + 8) + 8 * v60);
                if (v62)
                {
                  int v63 = *(_WORD *)(v62 + 48) == 1 ? 2 : 30;
                  inet_ntop(v63, *(const void **)(v62 + 40), buf, 0x2Eu);
                  xpc_object_t v64 = xpc_string_create(buf);
                  if (v64)
                  {
                    int v65 = v64;
                    xpc_array_append_value(v58, v64);
                    xpc_release(v65);
                    ++v61;
                  }
                }
                ++v60;
                uint64_t v59 = *(void *)(v47 + 96);
              }
              while (v60 < *(int *)(v59 + 4));
              uint64_t v48 = v110;
              if (v61) {
                xpc_dictionary_set_value(v54, "addresses", v58);
              }
            }
            xpc_release(v58);
            xpc_object_t v43 = v111;
          }
        }
      }
      uint64_t v66 = *(void *)(v47 + 256);
      BOOL v67 = v66 < v48;
      int64_t v68 = v66 - v48;
      if (v67) {
        int64_t v69 = -1;
      }
      else {
        int64_t v69 = v68;
      }
      xpc_dictionary_set_int64(v54, "lease", v69);
      xpc_dictionary_set_BOOL(v54, "removed", *(unsigned char *)(v47 + 264));
      xpc_dictionary_set_int64(v54, "update-server-id", *(void *)(v47 + 224));
      xpc_array_append_value(v43, v54);
      xpc_release(v54);
      char v49 = 1;
    }
    uint64_t v47 = *(void *)(v47 + 40);
    if (v47) {
      continue;
    }
    break;
  }
LABEL_107:
  xpc_dictionary_set_value(xdict, "instances", v43);
  xpc_release(v43);
  xpc_connection_send_message(connection, xdict);
  xpc_release(xdict);
  return 1;
}

void adv_xpc_connection_delete(void *a1)
{
  uint64_t v1 = &srp_xpc_clients;
  do
  {
    uint64_t v2 = v1;
    uint64_t v1 = (uint64_t *)*v1;
    if (!v1) {
      return;
    }
  }
  while ((void *)v1[1] != a1);
  xpc_release(a1);
  if (*((unsigned char *)v1 + 25))
  {
    uint64_t v3 = *(int **)(v1[2] + 144);
    if (v3)
    {
      int v4 = *v3;
      if (*v3)
      {
        int v5 = global_os_log;
        if (v4 < 10001)
        {
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v12 = 136447490;
            __int16 v13 = "adv_xpc_connection_delete";
            __int16 v14 = 1024;
            *(_DWORD *)uint32_t v15 = v4;
            *(_WORD *)&_OWORD v15[4] = 2048;
            *(void *)&v15[6] = v3;
            *(_WORD *)&v15[14] = 2080;
            *(void *)&v15[16] = "client->server_state->wanted";
            *(_WORD *)&v15[24] = 2080;
            *(void *)&v15[26] = "adv-ctl-server.c";
            __int16 v16 = 1024;
            int v17 = 835;
            _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v12, 0x36u);
            uint64_t v3 = *(int **)(v1[2] + 144);
            int v4 = *v3;
          }
          *uint64_t v3 = v4 - 1;
          if (v4 == 1)
          {
            int v6 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              int v12 = 136447234;
              __int16 v13 = "adv_xpc_connection_delete";
              __int16 v14 = 2048;
              *(void *)uint32_t v15 = v3;
              *(_WORD *)&v15[8] = 2080;
              *(void *)&v15[10] = "client->server_state->wanted";
              *(_WORD *)&v15[18] = 2080;
              *(void *)&v15[20] = "adv-ctl-server.c";
              *(_WORD *)&v15[28] = 1024;
              *(_DWORD *)&v15[30] = 835;
              _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v12, 0x30u);
              uint64_t v3 = *(int **)(v1[2] + 144);
            }
            ++srp_xpc_client_finalized;
            srp_xpc_client_finalize((uint64_t)v3);
          }
          goto LABEL_14;
        }
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_26:
        }
          abort();
        int v12 = 136447490;
        __int16 v13 = "adv_xpc_connection_delete";
        __int16 v14 = 1024;
        *(_DWORD *)uint32_t v15 = v4;
        *(_WORD *)&_OWORD v15[4] = 2048;
        *(void *)&v15[6] = v3;
        *(_WORD *)&v15[14] = 2080;
        *(void *)&v15[16] = "client->server_state->wanted";
        *(_WORD *)&v15[24] = 2080;
        *(void *)&v15[26] = "adv-ctl-server.c";
        __int16 v16 = 1024;
        int v17 = 835;
        int v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        __int16 v11 = v5;
      }
      else
      {
        uint64_t v9 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_26;
        }
        int v12 = 136447490;
        __int16 v13 = "adv_xpc_connection_delete";
        __int16 v14 = 1024;
        *(_DWORD *)uint32_t v15 = 0;
        *(_WORD *)&_OWORD v15[4] = 2048;
        *(void *)&v15[6] = v3;
        *(_WORD *)&v15[14] = 2080;
        *(void *)&v15[16] = "client->server_state->wanted";
        *(_WORD *)&v15[24] = 2080;
        *(void *)&v15[26] = "adv-ctl-server.c";
        __int16 v16 = 1024;
        int v17 = 835;
        int v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        __int16 v11 = v9;
      }
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v12, 0x36u);
      goto LABEL_26;
    }
  }
LABEL_14:
  if (*((int *)v1 + 10) >= 1)
  {
    uint64_t v7 = 0;
    do
    {
      ifpermit_list_remove(*(void *)(v1[2] + 72), *(char **)(v1[4] + 8 * v7));
      free(*(void **)(v1[4] + 8 * v7++));
    }
    while (v7 < *((int *)v1 + 10));
  }
  free((void *)v1[4]);
  *uint64_t v2 = *v1;
  uint64_t v8 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = 136446466;
    __int16 v13 = "adv_xpc_connection_delete";
    __int16 v14 = 2048;
    *(void *)uint32_t v15 = v1;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: deleting client: %p", (uint8_t *)&v12, 0x16u);
  }
  free(v1);
}

uint64_t adv_ctl_prefix_add_remove(void *a1)
{
  size_t length = 0;
  data = (unsigned __int8 *)xpc_dictionary_get_data(a1, "data", &length);
  size_t v2 = length;
  uint64_t v3 = global_os_log;
  if (data) {
    BOOL v4 = length == 16;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4)
  {
    uint64_t v5 = 0;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *data;
      if ((v6 & 0xFE) == 0xFC)
      {
        uint64_t v7 = "ULA: ";
      }
      else if (v6 == 254 && (data[1] & 0xC0) == 0x80)
      {
        uint64_t v7 = "LUA: ";
      }
      else if ((v6 & 0xE0) == 0x20)
      {
        uint64_t v7 = "GUA: ";
      }
      else
      {
        uint64_t v7 = "";
      }
      *(_DWORD *)buf = 136448771;
      __int16 v11 = "adv_ctl_prefix_add_remove";
      __int16 v12 = 2082;
      __int16 v13 = v7;
      __int16 v14 = 2160;
      uint64_t v15 = 1752392040;
      __int16 v16 = 1041;
      int v17 = 6;
      __int16 v18 = 2097;
      unint64_t v19 = data;
      __int16 v20 = 2160;
      uint64_t v21 = 1752392040;
      __int16 v22 = 1042;
      int v23 = 2;
      __int16 v24 = 2098;
      unint64_t v25 = data + 6;
      __int16 v26 = 2160;
      uint64_t v27 = 1752392040;
      __int16 v28 = 1041;
      int v29 = 8;
      __int16 v30 = 2097;
      uint64_t v31 = data + 8;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: got prefix {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}", buf, 0x64u);
      return 0;
    }
  }
  else
  {
    uint64_t v5 = 4294901756;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      __int16 v11 = "adv_ctl_prefix_add_remove";
      __int16 v12 = 2048;
      __int16 v13 = (const char *)data;
      __int16 v14 = 2048;
      uint64_t v15 = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "%{public}s: invalid request, data[%p], data_len[%ld]", buf, 0x20u);
    }
  }
  return v5;
}

uint64_t adv_ctl_nat64_prefix_add_remove(void *a1)
{
  size_t length = 0;
  data = (unsigned __int8 *)xpc_dictionary_get_data(a1, "data", &length);
  size_t v2 = length;
  uint64_t v3 = global_os_log;
  if (data) {
    BOOL v4 = length == 16;
  }
  else {
    BOOL v4 = 0;
  }
  if (v4)
  {
    uint64_t v5 = 0;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *data;
      if ((v6 & 0xFE) == 0xFC)
      {
        uint64_t v7 = "ULA: ";
      }
      else if (v6 == 254 && (data[1] & 0xC0) == 0x80)
      {
        uint64_t v7 = "LUA: ";
      }
      else if ((v6 & 0xE0) == 0x20)
      {
        uint64_t v7 = "GUA: ";
      }
      else
      {
        uint64_t v7 = "";
      }
      *(_DWORD *)buf = 136448771;
      __int16 v11 = "adv_ctl_nat64_prefix_add_remove";
      __int16 v12 = 2082;
      __int16 v13 = v7;
      __int16 v14 = 2160;
      uint64_t v15 = 1752392040;
      __int16 v16 = 1041;
      int v17 = 6;
      __int16 v18 = 2097;
      unint64_t v19 = data;
      __int16 v20 = 2160;
      uint64_t v21 = 1752392040;
      __int16 v22 = 1042;
      int v23 = 2;
      __int16 v24 = 2098;
      unint64_t v25 = data + 6;
      __int16 v26 = 2160;
      uint64_t v27 = 1752392040;
      __int16 v28 = 1041;
      int v29 = 8;
      __int16 v30 = 2097;
      uint64_t v31 = data + 8;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: got nat64 prefix {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}", buf, 0x64u);
      return 0;
    }
  }
  else
  {
    uint64_t v5 = 4294901756;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      __int16 v11 = "adv_ctl_nat64_prefix_add_remove";
      __int16 v12 = 2048;
      __int16 v13 = (const char *)data;
      __int16 v14 = 2048;
      uint64_t v15 = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_ERROR, "%{public}s: invalid request, data[%p], data_len[%ld]", buf, 0x20u);
    }
  }
  return v5;
}

BOOL adv_xpc_get_ula(void *a1, _xpc_connection_s *a2, uint64_t a3)
{
  xpc_object_t reply = xpc_dictionary_create_reply(a1);
  int v6 = reply;
  if (reply)
  {
    xpc_dictionary_set_uint64(reply, "status", 0);
    uint64_t v7 = 0;
    uint64_t v8 = 0;
    do
      uint64_t v8 = *(unsigned __int8 *)(a3 + 225 + v7++) | (v8 << 8);
    while (v7 != 5);
    xpc_dictionary_set_uint64(v6, "ula", v8);
    xpc_connection_send_message(a2, v6);
    xpc_release(v6);
  }
  else
  {
    uint64_t v9 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      int v11 = 136446210;
      __int16 v12 = "adv_xpc_get_ula";
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%{public}s: Unable to create reply dictionary.", (uint8_t *)&v11, 0xCu);
    }
  }
  return v6 != 0;
}

void adv_ctl_xpc_set_variable(uint64_t a1, xpc_object_t xdict)
{
  size_t length = 0;
  data = (unsigned __int8 *)xpc_dictionary_get_data(xdict, "data", &length);
  if (!data)
  {
    uint64_t v21 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)__str = 136446722;
    int v45 = "adv_ctl_xpc_set_variable";
    __int16 v46 = 2048;
    uint64_t v47 = 0;
    __int16 v48 = 2048;
    size_t v49 = length;
    __int16 v22 = "%{public}s: invalid request, data %p, len %zu";
    int v23 = (uint8_t *)__str;
    __int16 v24 = v21;
    uint32_t v25 = 32;
    goto LABEL_26;
  }
  BOOL v4 = data;
  size_t v5 = length;
  if (length)
  {
    size_t v6 = 0;
    uint64_t v7 = __str;
    do
    {
      size_t v8 = v6 + 1;
      int v9 = snprintf(v7, (char *)&v50 - v7, "%02x ", v4[v6]);
      if (v8 >= v5) {
        break;
      }
      v7 += v9;
      size_t v6 = v8;
    }
    while (v7 < (char *)&v50);
  }
  int v10 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v31 = "adv_ctl_set_variable";
    __int16 v32 = 2082;
    int v33 = __str;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: hexbuf: %{public}s", buf, 0x16u);
  }
  int v11 = (char *)memchr(v4, 0, v5);
  if (!v11)
  {
    uint64_t v26 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v31 = "adv_ctl_set_variable";
    __int16 v22 = "%{public}s: name not NUL-terminated";
LABEL_25:
    int v23 = buf;
    __int16 v24 = v26;
    uint32_t v25 = 12;
    goto LABEL_26;
  }
  __int16 v12 = v11 + 1;
  size_t v13 = v11 + 1 - (char *)v4;
  if (v13 >= v5)
  {
    uint64_t v26 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v31 = "adv_ctl_set_variable";
    __int16 v22 = "%{public}s: no value";
    goto LABEL_25;
  }
  __int16 v14 = memchr(v11 + 1, 0, v13);
  if (!v14)
  {
    uint64_t v26 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v31 = "adv_ctl_set_variable";
    __int16 v22 = "%{public}s: value not NUL-terminated";
    goto LABEL_25;
  }
  uint64_t v15 = v14;
  __int16 v16 = (char *)(v14 - v4);
  if (v14 - v4 != v5 - 1)
  {
    uint64_t v27 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136447746;
    uint64_t v31 = "adv_ctl_set_variable";
    __int16 v32 = 2048;
    int v33 = v16;
    __int16 v34 = 2048;
    size_t v35 = v5;
    __int16 v36 = 2048;
    BOOL v37 = v4;
    __int16 v38 = 2048;
    os_log_type_t v39 = v12;
    __int16 v40 = 2048;
    int v41 = v15;
    __int16 v42 = 2048;
    size_t v43 = v13;
    __int16 v22 = "%{public}s: extra bytes at end of name/value buffer: %zd != %zd %p %p %p %zu";
    int v23 = buf;
    __int16 v24 = v27;
    uint32_t v25 = 72;
LABEL_26:
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, v22, v23, v25);
    return;
  }
  int v17 = variables;
  if (variables)
  {
    uint64_t v18 = 0;
    int v19 = 1;
    __int16 v20 = &variables;
    while (strcmp((const char *)v4, v17))
    {
      uint64_t v18 = v19;
      __int16 v20 = &(&variables)[4 * v19];
      int v17 = *v20;
      ++v19;
      if (!*v20) {
        return;
      }
    }
    __int16 v28 = (&variables)[4 * v18 + 2];
    if (v28) {
      ((void (*)(uint64_t, char **, char *))v28)(a1, v20, v12);
    }
  }
}

void adv_ctl_start_thread_shutdown(void *a1, xpc_object_t object, uint64_t a3)
{
  *(void *)(a3 + 160) = object;
  xpc_retain(object);
  *(void *)(a3 + 168) = a1;
  xpc_retain(a1);
  uint64_t v5 = *(void *)(a3 + 40);
  if (v5) {
    service_tracker_cancel_probes(v5);
  }
  uint64_t v6 = *(void *)(a3 + 128);
  if (v6)
  {
    dnssd_client_cancel(v6);
    dnssd_client_release_(*(int **)(a3 + 128), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/adv-ctl-server.c", 458);
    *(void *)(a3 + 128) = 0;
  }
  uint64_t v7 = *(void *)(a3 + 48);
  if (v7)
  {
    *(unsigned char *)(v7 + 264) = 1;
    size_t v8 = state_machine_event_create(14);
    if (!v8)
    {
      __int16 v14 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        int v20 = 136446210;
        uint64_t v21 = "service_publisher_stop_publishing";
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v20, 0xCu);
      }
      goto LABEL_19;
    }
    int v9 = v8;
    state_machine_event_deliver(v7 + 8, (uint64_t)v8);
    int v10 = *v9;
    if (*v9)
    {
      int v11 = global_os_log;
      if (v10 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v20 = 136447490;
          uint64_t v21 = "service_publisher_stop_publishing";
          __int16 v22 = 1024;
          *(_DWORD *)int v23 = v10;
          *(_WORD *)&v23[4] = 2048;
          *(void *)&v23[6] = v9;
          *(_WORD *)&v23[14] = 2080;
          *(void *)&v23[16] = "event";
          *(_WORD *)&v23[24] = 2080;
          *(void *)&v23[26] = "service-publisher.c";
          __int16 v24 = 1024;
          int v25 = 1153;
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v20, 0x36u);
          int v10 = *v9;
        }
        int *v9 = v10 - 1;
        if (v10 == 1)
        {
          __int16 v12 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v20 = 136447234;
            uint64_t v21 = "service_publisher_stop_publishing";
            __int16 v22 = 2048;
            *(void *)int v23 = v9;
            *(_WORD *)&v23[8] = 2080;
            *(void *)&v23[10] = "event";
            *(_WORD *)&v23[18] = 2080;
            *(void *)&v23[20] = "service-publisher.c";
            *(_WORD *)&v23[28] = 1024;
            *(_DWORD *)&v23[30] = 1153;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v20, 0x30u);
          }
          ++state_machine_event_finalized;
          size_t v13 = (void (*)(int *))*((void *)v9 + 4);
          if (v13) {
            v13(v9);
          }
          free(v9);
        }
LABEL_19:
        service_publisher_cancel(*(void *)(a3 + 48));
        service_publisher_release_(*(int **)(a3 + 48), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/adv-ctl-server.c", 464);
        *(void *)(a3 + 48) = 0;
        uint64_t v15 = *(void *)(a3 + 40);
        if (v15 && *(unsigned char *)(v15 + 58)) {
          *(unsigned char *)(a3 + 284) = 1;
        }
        goto LABEL_22;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_37:
      }
        abort();
      int v20 = 136447490;
      uint64_t v21 = "service_publisher_stop_publishing";
      __int16 v22 = 1024;
      *(_DWORD *)int v23 = v10;
      *(_WORD *)&v23[4] = 2048;
      *(void *)&v23[6] = v9;
      *(_WORD *)&v23[14] = 2080;
      *(void *)&v23[16] = "event";
      *(_WORD *)&v23[24] = 2080;
      *(void *)&v23[26] = "service-publisher.c";
      __int16 v24 = 1024;
      int v25 = 1153;
      uint64_t v18 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      int v19 = v11;
    }
    else
    {
      uint64_t v17 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_37;
      }
      int v20 = 136447490;
      uint64_t v21 = "service_publisher_stop_publishing";
      __int16 v22 = 1024;
      *(_DWORD *)int v23 = 0;
      *(_WORD *)&v23[4] = 2048;
      *(void *)&v23[6] = v9;
      *(_WORD *)&v23[14] = 2080;
      *(void *)&v23[16] = "event";
      *(_WORD *)&v23[24] = 2080;
      *(void *)&v23[26] = "service-publisher.c";
      __int16 v24 = 1024;
      int v25 = 1153;
      uint64_t v18 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      int v19 = v17;
    }
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, v18, (uint8_t *)&v20, 0x36u);
    goto LABEL_37;
  }
LABEL_22:
  if (!*(unsigned char *)(a3 + 284)) {
    adv_ctl_thread_shutdown_continue(a3);
  }
  __int16 v16 = *(int **)(a3 + 176);
  if (v16
    || (__int16 v16 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/adv-ctl-server.c", 402), (*(void *)(a3 + 176) = v16) != 0))
  {
    ioloop_add_wake_event((uint64_t)v16, a3, (uint64_t)adv_ctl_thread_shutdown_continue, 0, 0x7D0u);
  }
  else
  {
    adv_ctl_thread_shutdown_continue(a3);
  }
}

void adv_ctl_need_service_instance(void *a1, uint64_t a2)
{
  string = xpc_dictionary_get_string(a1, "name");
  uint64_t v5 = xpc_dictionary_get_string(a1, "service-type");
  BOOL v6 = xpc_dictionary_get_BOOL(a1, "needed");
  BOOL v7 = v6;
  if (string && v5)
  {
    int v9 = (const char **)(a2 + 80);
    size_t v8 = *(const char ***)(a2 + 80);
    if (v8)
    {
      do
      {
        int v10 = v8;
        if (!strcasecmp(v8[1], string))
        {
          int v11 = strcasecmp(v10[2], v5);
          if (v11) {
            char v12 = 1;
          }
          else {
            char v12 = v7;
          }
          if ((v12 & 1) == 0)
          {
            int *v9 = *v10;
            adv_ctl_wanted_service_free((void **)v10);
            return;
          }
          if (!v11) {
            return;
          }
        }
        size_t v8 = (const char **)*v10;
        int v9 = v10;
      }
      while (*v10);
      if (v7) {
        goto LABEL_17;
      }
    }
    else
    {
      int v10 = (const char **)(a2 + 80);
      if (v6)
      {
LABEL_17:
        __int16 v14 = (void **)malloc_type_calloc(1uLL, 0x18uLL, 0x30040F310086FuLL);
        if (v14)
        {
          uint64_t v15 = strdup(string);
          v14[1] = v15;
          __int16 v16 = strdup(v5);
          v14[2] = v16;
          if (!v15 || !v16)
          {
            adv_ctl_wanted_service_free(v14);
            __int16 v14 = 0;
          }
        }
        uint64_t v17 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v19 = 136447235;
          int v20 = "adv_ctl_wanted_service_allocate";
          __int16 v21 = 2160;
          uint64_t v22 = 1752392040;
          __int16 v23 = 2081;
          __int16 v24 = string;
          __int16 v25 = 2082;
          uint64_t v26 = v5;
          __int16 v27 = 2048;
          __int16 v28 = v14;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: %{private, mask.hash}s%{public}s: %p", (uint8_t *)&v19, 0x34u);
        }
        NSObject *v10 = (const char *)v14;
        if (v14)
        {
          uint64_t v18 = *(void *)(a2 + 48);
          if (v18) {
            service_publisher_wanted_service_added(v18);
          }
        }
      }
    }
  }
  else
  {
    *(unsigned char *)(a2 + 288) = v6;
    uint64_t v13 = *(void *)(a2 + 48);
    service_publisher_wanted_service_added(v13);
  }
}

uint64_t adv_xpc_restart(uint64_t a1)
{
  uint64_t result = ioloop_create_xpc_service();
  *(void *)(a1 + 136) = result;
  if (!result)
  {
    uint64_t v3 = adv_xpc_wakeup;
    return ioloop_add_wake_event(v3, a1, (uint64_t)adv_xpc_restart, 0, 0x2710u);
  }
  return result;
}

void keychain_key_remove()
{
  Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
  if (Mutable)
  {
    uint64_t v1 = Mutable;
    CFDictionaryAddValue(Mutable, kSecClass, kSecClassKey);
    CFDictionaryAddValue(v1, kSecAttrAccessGroup, @"com.apple.srp-mdns-proxy");
    CFDictionaryAddValue(v1, kSecAttrAccessible, kSecAttrAccessibleAfterFirstUnlock);
    CFDictionaryAddValue(v1, kSecUseDataProtectionKeychain, kCFBooleanTrue);
    CFDictionaryAddValue(v1, kSecAttrSynchronizable, kCFBooleanFalse);
    SecItemDelete(v1);
    CFDictionaryRemoveValue(v1, kSecAttrAccessible);
    SecItemDelete(v1);
    CFRelease(v1);
  }
}

uint64_t keychain_identity_query(int a1, uint64_t *a2, double *a3)
{
  CFTypeRef v50 = 0;
  CFTypeRef result = 0;
  if (a1 || (Mutable = 0, uint64_t v7 = 4294967246, a2) && a3)
  {
    uint64_t v7 = 4294899624;
    Mutable = CFDictionaryCreateMutable(kCFAllocatorDefault, 0, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
    if (Mutable)
    {
      CFMutableArrayRef v8 = CFArrayCreateMutable(kCFAllocatorDefault, 0, &kCFTypeArrayCallBacks);
      if (v8)
      {
        int v9 = v8;
        uint64_t v47 = a2;
        __int16 v48 = a3;
        CFStringRef v10 = kSecReturnRef;
        CFDictionaryAddValue(Mutable, kSecReturnRef, kCFBooleanTrue);
        CFStringRef v11 = kSecReturnAttributes;
        CFDictionaryAddValue(Mutable, kSecReturnAttributes, kCFBooleanTrue);
        CFDictionaryAddValue(Mutable, kSecUseDataProtectionKeychain, kCFBooleanTrue);
        CFDictionaryAddValue(Mutable, kSecMatchLimit, kSecMatchLimitAll);
        CFDictionaryAddValue(Mutable, kSecAttrAccessGroup, @"com.apple.srp-mdns-proxy");
        CFDictionaryAddValue(Mutable, kSecAttrAccessible, kSecAttrAccessibleAfterFirstUnlock);
        CFDictionaryAddValue(Mutable, kSecClass, kSecClassKey);
        CFDictionaryAddValue(Mutable, kSecAttrSynchronizable, kCFBooleanFalse);
        uint64_t v12 = SecItemCopyMatching(Mutable, &result);
        if (!a1)
        {
          uint64_t v13 = v12;
          if (v12) {
            goto LABEL_60;
          }
        }
        if (result)
        {
          uint64_t Count = CFArrayGetCount((CFArrayRef)result);
          if (Count >= 1)
          {
            v53.size_t length = Count;
            v53.location = 0;
            CFArrayAppendArray(v9, (CFArrayRef)result, v53);
          }
        }
        if (a1 == 1)
        {
          CFDictionaryRemoveValue(Mutable, kSecAttrAccessible);
          if (!SecItemCopyMatching(Mutable, &v50))
          {
            if (v50)
            {
              CFIndex v40 = CFArrayGetCount((CFArrayRef)v50);
              if (v40 >= 1)
              {
                CFIndex v41 = v40;
                for (CFIndex i = 0; i != v41; ++i)
                {
                  CFDictionaryRef ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)v50, i);
                  CFStringRef Value = (const __CFString *)CFDictionaryGetValue(ValueAtIndex, kSecAttrAccessible);
                  if (!Value || CFStringCompare(Value, kSecAttrAccessibleAfterFirstUnlock, 0)) {
                    CFArrayAppendValue(v9, ValueAtIndex);
                  }
                }
              }
            }
          }
          CFIndex v49 = CFArrayGetCount(v9);
          CFStringRef v11 = kSecReturnAttributes;
          CFStringRef v10 = kSecReturnRef;
          if (v49 < 1) {
            goto LABEL_59;
          }
        }
        else
        {
          CFIndex v49 = CFArrayGetCount(v9);
          if (v49 == 1)
          {
            CFIndex v49 = 1;
          }
          else
          {
            uint64_t v15 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)cf = 134217984;
              *(void *)&cf[4] = v49;
              _os_log_fault_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_FAULT, "Have more than one TLS private keys -- count: %ld", cf, 0xCu);
            }
          }
        }
        CFDictionaryReplaceValue(Mutable, kSecClass, kSecClassCertificate);
        CFDictionaryReplaceValue(Mutable, kSecAttrSynchronizable, kCFBooleanTrue);
        CFDictionaryAddValue(Mutable, kSecAttrSyncViewHint, kSecAttrViewHintLimitedPeersAllowed);
        if (a1 == 1)
        {
          CFDictionaryRemoveValue(Mutable, v10);
          CFDictionaryRemoveValue(Mutable, v11);
          CFDictionaryRemoveValue(Mutable, kSecMatchLimit);
        }
        double Current = CFAbsoluteTimeGetCurrent();
        if (v49 >= 1)
        {
          double v17 = Current;
          CFIndex v18 = 0;
          double AbsoluteTime = -1.0;
          while (1)
          {
            CFDictionaryRef v20 = (const __CFDictionary *)CFArrayGetValueAtIndex(v9, v18);
            if (!v20) {
              goto LABEL_55;
            }
            CFDictionaryRef v21 = v20;
            CFTypeID v22 = CFGetTypeID(v20);
            if (v22 != CFDictionaryGetTypeID()) {
              goto LABEL_55;
            }
            CFStringRef v23 = (const __CFString *)CFDictionaryGetValue(v21, kSecAttrAccessible);
            if (v23)
            {
              if (CFStringCompare(v23, kSecAttrAccessibleAfterFirstUnlock, 0)) {
                CFStringRef v24 = kSecAttrAccessibleAlways;
              }
              else {
                CFStringRef v24 = kSecAttrAccessibleAfterFirstUnlock;
              }
              CFDictionarySetValue(Mutable, kSecAttrAccessible, v24);
            }
            if (!CFDictionaryGetValue(v21, kSecValueRef)) {
              goto LABEL_55;
            }
            CFStringRef v25 = (const __CFString *)CFDictionaryGetValue(v21, kSecAttrLabel);
            if (!v25) {
              goto LABEL_55;
            }
            CFStringRef v26 = v25;
            if (!CFStringHasPrefix(v25, @"Key ")) {
              goto LABEL_55;
            }
            if (!a1)
            {
              CFDateRef v27 = (const __CFDate *)CFDictionaryGetValue(v21, kSecAttrCreationDate);
              if (!v27 || v17 - CFDateGetAbsoluteTime(v27) > 1088640.0) {
                goto LABEL_55;
              }
            }
            MutableCopy = CFStringCreateMutableCopy(kCFAllocatorDefault, 0, v26);
            if (!MutableCopy) {
              goto LABEL_55;
            }
            int v29 = MutableCopy;
            CFStringTrim(MutableCopy, @"Key ");
            CFStringInsert(v29, 0, @"Certificate ");
            CFDictionarySetValue(Mutable, kSecAttrLabel, v29);
            CFRelease(v29);
            if (a1)
            {
              if (a1 != 1)
              {
                uint64_t v13 = 4294899625;
                goto LABEL_60;
              }
              SecItemDelete(Mutable);
              goto LABEL_55;
            }
            *(void *)cf = 0;
            if (SecItemCopyMatching(Mutable, (CFTypeRef *)cf)) {
              break;
            }
            if (!*(void *)cf) {
              goto LABEL_58;
            }
            CFTypeID v31 = CFGetTypeID(*(CFTypeRef *)cf);
            if (v31 != CFArrayGetTypeID()) {
              goto LABEL_58;
            }
            CFIndex v32 = CFArrayGetCount(*(CFArrayRef *)cf);
            if (!v32) {
              goto LABEL_58;
            }
            if (v32 != 1) {
              break;
            }
            CFDictionaryRef v33 = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)cf, 0);
            CFDictionaryRef v30 = v33;
            if (v33)
            {
              CFTypeID v34 = CFGetTypeID(v33);
              if (v34 != CFDictionaryGetTypeID()) {
                break;
              }
              CFDateRef v35 = (const __CFDate *)CFDictionaryGetValue(v30, kSecAttrCreationDate);
              if (!v35) {
                break;
              }
              CFDateRef v36 = v35;
              CFDictionaryRef v37 = (const __CFDictionary *)CFDictionaryGetValue(v30, kSecValueRef);
              CFDictionaryRef v30 = v37;
              if (v37)
              {
                CFRetain(v37);
                double AbsoluteTime = CFDateGetAbsoluteTime(v36);
              }
            }
LABEL_52:
            if (*(void *)cf) {
              CFRelease(*(CFTypeRef *)cf);
            }
            if (v30)
            {
              if (AbsoluteTime >= 0.0)
              {
                uint64_t v46 = SecIdentityCreate();
                uint64_t v45 = 4294899624;
                if (v46)
                {
                  uint64_t v45 = 0;
                  uint64_t *v47 = v46;
                  double *v48 = AbsoluteTime;
                }
              }
              else
              {
                uint64_t v45 = 4294941996;
              }
              CFRelease(v30);
              uint64_t v13 = v45;
              goto LABEL_60;
            }
LABEL_55:
            if (v49 == ++v18) {
              goto LABEL_56;
            }
          }
          CFDictionaryRef v30 = 0;
          goto LABEL_52;
        }
LABEL_56:
        if (!a1)
        {
LABEL_59:
          uint64_t v13 = 4294941996;
          goto LABEL_60;
        }
        keychain_key_remove();
LABEL_58:
        uint64_t v13 = 0;
LABEL_60:
        CFRelease(v9);
        if (v50)
        {
          CFRelease(v50);
          CFTypeRef v50 = 0;
        }
        uint64_t v7 = v13;
      }
      else
      {
        uint64_t v7 = 4294960567;
      }
    }
  }
  if (result)
  {
    CFRelease(result);
    CFTypeRef result = 0;
  }
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (v7 == -25308)
  {
    __int16 v38 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)cf = 0;
      _os_log_error_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "The device has to be unlocked since the last reboot to access keychain.", cf, 2u);
    }
  }
  return v7;
}

uint64_t dns_opt_parse(void *a1, uint64_t a2)
{
  uint64_t result = 0;
  unsigned int v12 = 0;
  if (*(_WORD *)(a2 + 8) == 41)
  {
    unsigned int v4 = *(unsigned __int16 *)(a2 + 24);
    if (*(_WORD *)(a2 + 24))
    {
      uint64_t v5 = *(void *)(a2 + 16);
      while (1)
      {
        int v11 = 0;
        if (!dns_u16_parse(v5, v4, &v12, (_WORD *)&v11 + 1)) {
          break;
        }
        if (!dns_u16_parse(v5, v4, &v12, &v11)) {
          break;
        }
        uint64_t v6 = v12;
        size_t v7 = (unsigned __int16)v11;
        unsigned int v8 = v12 + (unsigned __int16)v11;
        if (v8 > v4) {
          break;
        }
        int v9 = malloc_type_calloc(1uLL, (unsigned __int16)v11 + 16, 0x8544971uLL);
        if (!v9) {
          break;
        }
        CFStringRef v10 = v9;
        v9[4] = v7;
        v9[5] = HIWORD(v11);
        memcpy(v9 + 6, (const void *)(v5 + v6), v7);
        *a1 = v10;
        unsigned int v12 = v8;
        a1 = v10;
        if (v8 >= v4) {
          return 1;
        }
      }
      return 0;
    }
    else
    {
      return 1;
    }
  }
  return result;
}

BOOL dns_u16_parse(uint64_t a1, unsigned int a2, unsigned int *a3, _WORD *a4)
{
  uint64_t v5 = *a3;
  unsigned int v6 = v5 + 2;
  if ((int)v5 + 2 > a2)
  {
    unsigned int v8 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG))
    {
      int v10 = 136446722;
      int v11 = "dns_u16_parse";
      __int16 v12 = 1024;
      unsigned int v13 = v6;
      __int16 v14 = 1024;
      unsigned int v15 = a2;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "%{public}s: dns_u16_parse: not enough room: %u > %u.\n", (uint8_t *)&v10, 0x18u);
    }
  }
  else
  {
    __int16 v7 = *(unsigned __int8 *)(a1 + (v5 + 1)) | (*(unsigned __int8 *)(a1 + v5) << 8);
    *a3 = v6;
    *a4 = v7;
  }
  return v6 <= a2;
}

uint64_t dns_name_parse_(void **a1, uint64_t a2, uint64_t a3, unsigned int *a4, unsigned int a5)
{
  int v10 = 0;
  uint64_t v6 = dns_name_parse_in(&v10, a2, a3, a4, a5);
  __int16 v7 = v10;
  if (v6)
  {
    *a1 = v10;
  }
  else if (v10)
  {
    do
    {
      unsigned int v8 = (void *)*v7;
      free(v7);
      __int16 v7 = v8;
    }
    while (v8);
  }
  return v6;
}

uint64_t dns_name_parse_in(void *a1, uint64_t a2, uint64_t a3, unsigned int *a4, unsigned int a5)
{
  unsigned int v10 = *a4;
  while (1)
  {
    uint64_t result = v10 != a3;
    if (v10 == a3) {
      return result;
    }
    size_t v12 = *(unsigned __int8 *)(a2 + v10);
    if (v12 >= 0xC0) {
      break;
    }
    if (v12 >= 0x40)
    {
      uint64_t v21 = global_os_log;
      uint64_t result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG);
      if (!result) {
        return result;
      }
      *(_DWORD *)buf = 136446466;
      CFDictionaryRef v37 = "dns_name_parse_in";
      __int16 v38 = 1024;
      unsigned int v39 = v12;
      CFDictionaryRef v20 = "%{public}s: invalid label type: %x\n";
LABEL_23:
      CFTypeID v22 = v21;
      uint32_t v23 = 18;
      goto LABEL_24;
    }
    int v13 = v12 + 1;
    unsigned int v14 = v12 + 1 + v10;
    if (v14 > a3)
    {
      uint64_t v19 = global_os_log;
      uint64_t result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG);
      if (!result) {
        return result;
      }
      *(_DWORD *)buf = 136446722;
      CFDictionaryRef v37 = "dns_label_parse_";
      __int16 v38 = 1024;
      unsigned int v39 = v14;
      __int16 v40 = 1024;
      unsigned int v41 = a3;
      CFDictionaryRef v20 = "%{public}s: claimed length of label is too long: %u > %u.\n";
LABEL_16:
      CFTypeID v22 = v19;
LABEL_17:
      uint32_t v23 = 24;
LABEL_24:
      _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEBUG, v20, buf, v23);
      return 0;
    }
    unsigned int v15 = (char *)malloc_type_calloc(1uLL, v12 + 10, 0x26EAE9F4uLL);
    if (!v15)
    {
      uint64_t v24 = global_os_log;
      uint64_t result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG);
      if (!result) {
        return result;
      }
      unsigned int v25 = v13 + *a4;
      uint64_t v26 = a2 + *a4 + 1;
      *(_DWORD *)buf = 136446978;
      CFDictionaryRef v37 = "dns_label_parse_";
      __int16 v38 = 1024;
      unsigned int v39 = v25;
      __int16 v40 = 1040;
      unsigned int v41 = v25;
      __int16 v42 = 2080;
      uint64_t v43 = v26;
      CFDictionaryRef v20 = "%{public}s: memory allocation for %u byte label (%.*s) failed.\n";
      CFTypeID v22 = v24;
      uint32_t v23 = 34;
      goto LABEL_24;
    }
    __int16 v16 = v15;
    v15[8] = v12;
    double v17 = v15 + 9;
    memcpy(v15 + 9, (const void *)(a2 + *a4 + 1), v12);
    v17[v12] = 0;
    unsigned int v10 = v13 + *a4;
    *a4 = v10;
    *a1 = v16;
    a1 = v16;
    if (!v12) {
      return 1;
    }
  }
  unsigned int v18 = v10 + 2;
  if (v10 + 2 > a3)
  {
    uint64_t v19 = global_os_log;
    uint64_t result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG);
    if (!result) {
      return result;
    }
    *(_DWORD *)buf = 136446722;
    CFDictionaryRef v37 = "dns_name_parse_in";
    __int16 v38 = 1024;
    unsigned int v39 = v18;
    __int16 v40 = 1024;
    unsigned int v41 = a3;
    CFDictionaryRef v20 = "%{public}s: incomplete compression pointer: %u > %u";
    goto LABEL_16;
  }
  unsigned int v27 = *(unsigned __int8 *)(a2 + v10 + 1) | ((v12 & 0x3F) << 8);
  *a4 = v18;
  unsigned int v28 = v27 - 11;
  if (v27 <= 0xB)
  {
    uint64_t v21 = global_os_log;
    uint64_t result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG);
    if (!result) {
      return result;
    }
    *(_DWORD *)buf = 136446466;
    CFDictionaryRef v37 = "dns_name_parse_in";
    __int16 v38 = 1024;
    unsigned int v39 = v27;
    CFDictionaryRef v20 = "%{public}s: compression pointer points into header: %u.\n";
    goto LABEL_23;
  }
  unsigned int v29 = v27 - 12;
  unsigned int v35 = v27 - 12;
  if (v27 - 12 >= a5)
  {
    uint64_t v32 = global_os_log;
    uint64_t result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG);
    if (result)
    {
      *(_DWORD *)buf = 136446722;
      CFDictionaryRef v37 = "dns_name_parse_in";
      __int16 v38 = 1024;
      unsigned int v39 = v27 - 12;
      __int16 v40 = 1024;
      unsigned int v41 = a5;
      CFDictionaryRef v20 = "%{public}s: compression pointer points forward: %u >= %u.\n";
      goto LABEL_37;
    }
  }
  else
  {
    unsigned int v30 = *(unsigned __int8 *)(a2 + v29);
    if (v30 >= 0x40)
    {
      uint64_t v33 = global_os_log;
      uint64_t result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG);
      if (result)
      {
        if (v28 >= a3) {
          int v34 = 255;
        }
        else {
          int v34 = *(unsigned __int8 *)(a2 + v28);
        }
        *(_DWORD *)buf = 136446978;
        CFDictionaryRef v37 = "dns_name_parse_in";
        __int16 v38 = 1024;
        unsigned int v39 = v27 - 12;
        __int16 v40 = 1024;
        unsigned int v41 = v30;
        __int16 v42 = 1024;
        LODWORD(v43) = v34;
        CFDictionaryRef v20 = "%{public}s: compression pointer points into pointer: %u %02x%02x.\n";
        CFTypeID v22 = v33;
        uint32_t v23 = 30;
        goto LABEL_24;
      }
    }
    else
    {
      if (v29 + v30 < a5 && v29 + v30 < v18) {
        return dns_name_parse_in(a1, a2, a3, &v35, v27 - 12);
      }
      uint64_t v32 = global_os_log;
      uint64_t result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG);
      if (result)
      {
        *(_DWORD *)buf = 136446722;
        CFDictionaryRef v37 = "dns_name_parse_in";
        __int16 v38 = 1024;
        unsigned int v39 = v27 - 12;
        __int16 v40 = 1024;
        unsigned int v41 = v30;
        CFDictionaryRef v20 = "%{public}s: compression pointer points to something that goes past current position: %u %u\n";
LABEL_37:
        CFTypeID v22 = v32;
        goto LABEL_17;
      }
    }
  }
  return result;
}

BOOL dns_u8_parse(uint64_t a1, unsigned int a2, unsigned int *a3, unsigned char *a4)
{
  uint64_t v5 = *a3;
  unsigned int v6 = v5 + 1;
  if ((int)v5 + 1 > a2)
  {
    unsigned int v8 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG))
    {
      int v10 = 136446722;
      int v11 = "dns_u8_parse";
      __int16 v12 = 1024;
      unsigned int v13 = v6;
      __int16 v14 = 1024;
      unsigned int v15 = a2;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "%{public}s: dns_u8_parse: not enough room: %u > %u.\n", (uint8_t *)&v10, 0x18u);
    }
  }
  else
  {
    char v7 = *(unsigned char *)(a1 + v5);
    *a3 = v6;
    *a4 = v7;
  }
  return v6 <= a2;
}

BOOL dns_u32_parse(uint64_t a1, unsigned int a2, unsigned int *a3, int *a4)
{
  uint64_t v5 = *a3;
  unsigned int v6 = v5 + 4;
  if ((int)v5 + 4 > a2)
  {
    unsigned int v8 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG))
    {
      int v10 = 136446722;
      int v11 = "dns_u32_parse";
      __int16 v12 = 1024;
      unsigned int v13 = v6;
      __int16 v14 = 1024;
      unsigned int v15 = a2;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "%{public}s: dns_u32_parse: not enough room: %u > %u.\n", (uint8_t *)&v10, 0x18u);
    }
  }
  else
  {
    int v7 = (*(unsigned __int8 *)(a1 + v5) << 24) | (*(unsigned __int8 *)(a1 + (v5 + 1)) << 16) | (*(unsigned __int8 *)(a1 + (v5 + 2)) << 8) | *(unsigned __int8 *)(a1 + (v5 + 3));
    *a3 = v6;
    *a4 = v7;
  }
  return v6 <= a2;
}

uint64_t dns_rdata_parse_data_(uint64_t a1, uint64_t a2, unsigned int *a3, uint64_t a4, size_t size, int a6)
{
  uint64_t v7 = *a3;
  unsigned int v8 = a4 - v7;
  if (a4 >= v7)
  {
    unsigned int v14 = size;
    if (a4 <= v7)
    {
      switch(*(_WORD *)(a1 + 8))
      {
        case 1:
          if (size == 4)
          {
            *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + v7);
LABEL_53:
            unsigned int v24 = a4;
LABEL_54:
            *a3 = v24;
LABEL_55:
            unsigned int v25 = *a3;
            if (*a3 == a4) {
              return 1;
            }
            uint64_t v26 = global_os_log;
            uint64_t result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG);
            if (result)
            {
              int v27 = *(unsigned __int16 *)(a1 + 8);
              int v30 = 136446978;
              CFTypeID v31 = "dns_rdata_parse_data_";
              __int16 v32 = 1024;
              int v33 = v27;
              __int16 v34 = 1024;
              int v35 = a4;
              __int16 v36 = 1024;
              unsigned int v37 = v25;
              int v11 = "%{public}s: dns_rdata_parse: parse for rrtype %d not fully contained: %u %u";
              __int16 v12 = v26;
              uint32_t v13 = 30;
              break;
            }
            return result;
          }
          uint64_t v28 = global_os_log;
          uint64_t result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG);
          if (!result) {
            return result;
          }
          int v30 = 136446466;
          CFTypeID v31 = "dns_rdata_parse_data_";
          __int16 v32 = 1024;
          int v33 = v14;
          int v11 = "%{public}s: dns_rdata_parse: A rdlen is not 4: %u";
LABEL_67:
          __int16 v12 = v28;
          uint32_t v13 = 18;
          break;
        case 2:
        case 5:
        case 0xC:
LABEL_20:
          if (dns_name_parse_((void **)(a1 + 16), a2, a4, a3, v7)) {
            goto LABEL_55;
          }
          return 0;
        case 3:
        case 4:
        case 7:
        case 8:
        case 9:
        case 0xA:
        case 0xB:
LABEL_31:
          if (!size) {
            goto LABEL_34;
          }
          uint64_t result = (uint64_t)malloc_type_malloc(size, 0x408B67A7uLL);
          *(void *)(a1 + 16) = result;
          if (!result) {
            return result;
          }
          memcpy((void *)result, (const void *)(a2 + *a3), v14);
LABEL_34:
          *(_WORD *)(a1 + 24) = v14;
          goto LABEL_53;
        case 6:
          uint64_t result = dns_name_parse_((void **)(a1 + 16), a2, a4, a3, v7);
          if (!result) {
            return result;
          }
          uint64_t result = dns_name_parse_((void **)(a1 + 24), a2, a4, a3, *a3);
          if (!result) {
            return result;
          }
          uint64_t result = dns_u32_parse(a2, a4, a3, (int *)(a1 + 32));
          if (!result) {
            return result;
          }
          uint64_t result = dns_u32_parse(a2, a4, a3, (int *)(a1 + 36));
          if (!result) {
            return result;
          }
          uint64_t result = dns_u32_parse(a2, a4, a3, (int *)(a1 + 40));
          if (!result) {
            return result;
          }
          uint64_t result = dns_u32_parse(a2, a4, a3, (int *)(a1 + 44));
          if (!result) {
            return result;
          }
          if (dns_u32_parse(a2, a4, a3, (int *)(a1 + 48))) {
            goto LABEL_55;
          }
          return 0;
        default:
          JUMPOUT(0);
      }
    }
    else
    {
      switch(*(_WORD *)(a1 + 8))
      {
        case 0x18:
          *(_DWORD *)(a1 + 48) = a6;
          uint64_t result = dns_u16_parse(a2, a4, a3, (_WORD *)(a1 + 16));
          if (!result) {
            return result;
          }
          uint64_t result = dns_u8_parse(a2, a4, a3, (unsigned char *)(a1 + 18));
          if (!result) {
            return result;
          }
          uint64_t result = dns_u8_parse(a2, a4, a3, (unsigned char *)(a1 + 19));
          if (!result) {
            return result;
          }
          uint64_t result = dns_u32_parse(a2, a4, a3, (int *)(a1 + 20));
          if (!result) {
            return result;
          }
          uint64_t result = dns_u32_parse(a2, a4, a3, (int *)(a1 + 24));
          if (!result) {
            return result;
          }
          uint64_t result = dns_u32_parse(a2, a4, a3, (int *)(a1 + 28));
          if (!result) {
            return result;
          }
          uint64_t result = dns_u16_parse(a2, a4, a3, (_WORD *)(a1 + 32));
          if (!result) {
            return result;
          }
          uint64_t result = dns_name_parse_((void **)(a1 + 40), a2, a4, a3, *a3);
          if (!result) {
            return result;
          }
          size_t v18 = a4 - *a3;
          *(_DWORD *)(a1 + 52) = v18;
          uint64_t result = (uint64_t)malloc_type_malloc(v18, 0xA58364E2uLL);
          *(void *)(a1 + 56) = result;
          if (!result) {
            return result;
          }
          memcpy((void *)result, (const void *)(a2 + *a3), *(unsigned int *)(a1 + 52));
          int v19 = *(_DWORD *)(a1 + 52);
          goto LABEL_50;
        case 0x19:
          uint64_t result = dns_u16_parse(a2, a4, a3, (_WORD *)(a1 + 16));
          if (!result) {
            return result;
          }
          uint64_t result = dns_u8_parse(a2, a4, a3, (unsigned char *)(a1 + 18));
          if (!result) {
            return result;
          }
          uint64_t result = dns_u8_parse(a2, a4, a3, (unsigned char *)(a1 + 19));
          if (!result) {
            return result;
          }
          size_t v23 = a4 - *a3;
          *(_DWORD *)(a1 + 20) = v23;
          uint64_t result = (uint64_t)malloc_type_malloc(v23, 0x89A5FE76uLL);
          *(void *)(a1 + 24) = result;
          if (!result) {
            return result;
          }
          memcpy((void *)result, (const void *)(a2 + *a3), *(unsigned int *)(a1 + 20));
          int v19 = *(_DWORD *)(a1 + 20);
LABEL_50:
          unsigned int v24 = *a3 + v19;
          goto LABEL_54;
        case 0x1A:
        case 0x1B:
        case 0x1D:
        case 0x1E:
        case 0x1F:
        case 0x20:
          goto LABEL_31;
        case 0x1C:
          if (size == 16)
          {
            *(_OWORD *)(a1 + 16) = *(_OWORD *)(a2 + v7);
            goto LABEL_53;
          }
          uint64_t v28 = global_os_log;
          uint64_t result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG);
          if (!result) {
            return result;
          }
          int v30 = 136446466;
          CFTypeID v31 = "dns_rdata_parse_data_";
          __int16 v32 = 1024;
          int v33 = v14;
          int v11 = "%{public}s: dns_rdata_parse: AAAA rdlen is not 16: %u";
          goto LABEL_67;
        case 0x21:
          uint64_t result = dns_u16_parse(a2, a4, a3, (_WORD *)(a1 + 24));
          if (!result) {
            return result;
          }
          uint64_t result = dns_u16_parse(a2, a4, a3, (_WORD *)(a1 + 26));
          if (!result) {
            return result;
          }
          uint64_t result = dns_u16_parse(a2, a4, a3, (_WORD *)(a1 + 28));
          if (!result) {
            return result;
          }
          LODWORD(v7) = *a3;
          goto LABEL_20;
        default:
          if (*(_WORD *)(a1 + 8) != 16) {
            goto LABEL_31;
          }
          if (v8 != size)
          {
            CFDictionaryRef v20 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            {
              int v30 = 136446722;
              CFTypeID v31 = "dns_rdata_parse_data_";
              __int16 v32 = 1024;
              int v33 = v14;
              __int16 v34 = 1024;
              int v35 = v8;
              _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "%{public}s: TXT record length %u doesn't match remaining space %d", (uint8_t *)&v30, 0x18u);
            }
          }
          if (v8 >= 0x100)
          {
            uint64_t v21 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            {
              int v30 = 136446466;
              CFTypeID v31 = "dns_rdata_parse_data_";
              __int16 v32 = 1024;
              int v33 = v8;
              _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%{public}s: TXT record length %u is longer than 255", (uint8_t *)&v30, 0x12u);
            }
          }
          *(unsigned char *)(a1 + 16) = v8;
          CFTypeID v22 = malloc_type_malloc(v8, 0xBF0E72CEuLL);
          *(void *)(a1 + 24) = v22;
          if (v22)
          {
            memcpy(v22, (const void *)(a2 + *a3), *(unsigned __int8 *)(a1 + 16));
            goto LABEL_53;
          }
          uint64_t v29 = global_os_log;
          uint64_t result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG);
          if (!result) {
            return result;
          }
          int v30 = 136446210;
          CFTypeID v31 = "dns_rdata_parse_data_";
          int v11 = "%{public}s: dns_rdata_parse: no memory for TXT RR";
          __int16 v12 = v29;
          uint32_t v13 = 12;
          break;
      }
    }
  }
  else
  {
    uint64_t v9 = global_os_log;
    uint64_t result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG);
    if (!result) {
      return result;
    }
    int v30 = 136446722;
    CFTypeID v31 = "dns_rdata_parse_data_";
    __int16 v32 = 1024;
    int v33 = a4;
    __int16 v34 = 1024;
    int v35 = v7;
    int v11 = "%{public}s: target %u < *offp %u";
    __int16 v12 = v9;
    uint32_t v13 = 24;
  }
  _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEBUG, v11, (uint8_t *)&v30, v13);
  return 0;
}

uint64_t dns_rr_parse_()
{
  uint64_t v0 = __chkstk_darwin();
  int v2 = v1;
  unsigned int v4 = v3;
  unsigned int v6 = v5;
  uint64_t v8 = v7;
  uint64_t v9 = v0;
  int v10 = *v3;
  *(_OWORD *)(v0 + 32) = 0u;
  *(_OWORD *)(v0 + 48) = 0u;
  *(_OWORD *)uint64_t v0 = 0u;
  *(_OWORD *)(v0 + 16) = 0u;
  uint64_t result = dns_name_parse_((void **)v0, v7, v5, v3, *v3);
  if (result)
  {
    __int16 v12 = (unsigned __int16 *)(v9 + 8);
    uint64_t result = dns_u16_parse(v8, v6, v4, (_WORD *)(v9 + 8));
    if (result)
    {
      uint64_t result = dns_u16_parse(v8, v6, v4, (_WORD *)(v9 + 10));
      if (result)
      {
        if (!v2) {
          goto LABEL_70;
        }
        uint64_t result = dns_u32_parse(v8, v6, v4, (int *)(v9 + 12));
        if (result)
        {
          *(_WORD *)buf = 0;
          if (!dns_u16_parse(v8, v6, v4, buf)) {
            return 0;
          }
          uint64_t v13 = *v4 + *(unsigned __int16 *)buf;
          if (v13 > v6) {
            return 0;
          }
          uint64_t result = dns_rdata_parse_data_(v9, v8, v4, v13, *(unsigned __int16 *)buf, v10);
          if (result)
          {
LABEL_70:
            if (*(void *)v9) {
              dns_name_print_to_limit(*(uint64_t **)v9, 0, (uint64_t)v39, 0x3F2uLL);
            }
            else {
              strcpy(v39, "<null>");
            }
            unsigned int v14 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG))
            {
              int v15 = *v12;
              int v16 = *(unsigned __int16 *)(v9 + 10);
              double v17 = "";
              *(void *)&uint8_t buf[4] = "dns_rr_parse_";
              *(_DWORD *)buf = 136447491;
              if (v2) {
                double v17 = "  rrdata:";
              }
              __int16 v41 = 1024;
              int v42 = v15;
              __int16 v43 = 1024;
              int v44 = v16;
              __int16 v45 = 2160;
              uint64_t v46 = 1752392040;
              __int16 v47 = 2081;
              __int16 v48 = v39;
              __int16 v49 = 2082;
              CFTypeRef v50 = v17;
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEBUG, "%{public}s: rrtype: %u  qclass: %u  name: %{private, mask.hash}s%{public}s", buf, 0x36u);
            }
            if (!v2) {
              return 1;
            }
            unsigned int v18 = *v12;
            if (v18 > 0xB)
            {
              switch(*v12)
              {
                case 0x18u:
                  dns_name_print_to_limit(*(uint64_t **)(v9 + 40), 0, (uint64_t)v51, 0x3F2uLL);
                  snprintf((char *)buf, 0x800uLL, "SIG %d %d %d %lu %lu %lu %d %s", *(unsigned __int16 *)(v9 + 16), *(unsigned __int8 *)(v9 + 18), *(unsigned __int8 *)(v9 + 19), *(unsigned int *)(v9 + 20), *(unsigned int *)(v9 + 24), *(unsigned int *)(v9 + 28), *(unsigned __int16 *)(v9 + 32), (const char *)v51);
                  size_t v20 = strlen((const char *)buf);
                  int v19 = &buf[v20];
                  size_t v21 = 2048 - v20;
                  if (*(_DWORD *)(v9 + 52))
                  {
                    unint64_t v22 = 0;
                    do
                    {
                      if (v22) {
                        snprintf((char *)v19, v21, " %02x");
                      }
                      else {
                        snprintf((char *)v19, v21, "%d [%02x");
                      }
                      size_t v23 = strlen((const char *)v19);
                      v19 += v23;
                      v21 -= v23;
                      ++v22;
                    }
                    while (v22 < *(unsigned int *)(v9 + 52));
                  }
                  goto LABEL_54;
                case 0x19u:
                  unsigned int v33 = *(unsigned __int16 *)(v9 + 16);
                  snprintf((char *)buf, 0x800uLL, "KEY <AC %d> <Z %d> <XT %d> <ZZ %d> <NAMTYPE %d> <ZZZZ %d> <ORY %d> %d %d ", v33 >> 14, (v33 >> 13) & 1, (v33 >> 12) & 1, (v33 >> 10) & 3, (v33 >> 8) & 3, v33 >> 4, v33 & 0xF, *(unsigned __int8 *)(v9 + 18), *(unsigned __int8 *)(v9 + 19));
                  size_t v34 = strlen((const char *)buf);
                  int v19 = &buf[v34];
                  size_t v21 = 2048 - v34;
                  if (*(_DWORD *)(v9 + 20))
                  {
                    unint64_t v35 = 0;
                    do
                    {
                      if (v35) {
                        snprintf((char *)v19, v21, " %02x");
                      }
                      else {
                        snprintf((char *)v19, v21, "%d [%02x");
                      }
                      size_t v36 = strlen((const char *)v19);
                      v19 += v36;
                      v21 -= v36;
                      ++v35;
                    }
                    while (v35 < *(unsigned int *)(v9 + 20));
                  }
LABEL_54:
                  if (v21 <= 1) {
                    goto LABEL_60;
                  }
                  __int16 v37 = 93;
                  goto LABEL_66;
                case 0x1Au:
                case 0x1Bu:
                case 0x1Du:
                case 0x1Eu:
                case 0x1Fu:
                case 0x20u:
                  goto LABEL_44;
                case 0x1Cu:
                  inet_ntop(30, (const void *)(v9 + 16), (char *)v51, 0x2Eu);
                  snprintf((char *)buf, 0x800uLL, "AAAA %s");
                  goto LABEL_59;
                case 0x21u:
                  dns_name_print_to_limit(*(uint64_t **)(v9 + 16), 0, (uint64_t)v51, 0x3F2uLL);
                  snprintf((char *)buf, 0x800uLL, "SRV %d %d %d %s");
                  goto LABEL_59;
                default:
                  if (v18 == 12)
                  {
                    dns_name_print_to_limit(*(uint64_t **)(v9 + 16), 0, (uint64_t)v51, 0x3F2uLL);
                    snprintf((char *)buf, 0x800uLL, "PTR %s");
                    goto LABEL_59;
                  }
                  if (v18 != 16) {
                    goto LABEL_44;
                  }
                  strcpy((char *)buf, "TXT ");
                  size_t v24 = strlen((const char *)buf);
                  int v19 = &buf[v24];
                  size_t v25 = 2048 - v24;
                  if (*(unsigned char *)(v9 + 16))
                  {
                    unint64_t v26 = 0;
                    do
                    {
                      int v27 = *(char *)(*(void *)(v9 + 24) + v26);
                      if ((v27 & 0x80000000) == 0
                        && (_DefaultRuneLocale.__runetype[*(unsigned __int8 *)(*(void *)(v9 + 24) + v26)] & 0x40000) != 0)
                      {
                        if (v25 >= 2)
                        {
                          *(_WORD *)v19++ = v27;
                          --v25;
                        }
                      }
                      else
                      {
                        snprintf((char *)v19, v25, "<%x>", *(unsigned __int8 *)(*(void *)(v9 + 24) + v26));
                        size_t v28 = strlen((const char *)v19);
                        v19 += v28;
                        v25 -= v28;
                      }
                      ++v26;
                    }
                    while (v26 < *(unsigned __int8 *)(v9 + 16));
                  }
                  if (v25 > 1)
                  {
                    __int16 v37 = 34;
LABEL_66:
                    *(_WORD *)v19++ = v37;
                  }
                  break;
              }
              goto LABEL_60;
            }
            if (v18 == 1)
            {
              inet_ntop(2, (const void *)(v9 + 16), (char *)v51, 0x2Eu);
              snprintf((char *)buf, 0x800uLL, "A %s");
            }
            else
            {
              if (v18 != 5)
              {
                if (v18 == 6)
                {
                  dns_name_print_to_limit(*(uint64_t **)(v9 + 16), 0, (uint64_t)v51, 0x3F2uLL);
                  snprintf((char *)buf, 0x800uLL, "SOA %s", (const char *)v51);
                  dns_name_print_to_limit(*(uint64_t **)(v9 + 24), 0, (uint64_t)v51, 0x3F2uLL);
                  snprintf((char *)buf, 0x800uLL, "%s %u %d %d %d %d", (const char *)v51, *(_DWORD *)(v9 + 32), *(_DWORD *)(v9 + 36), *(_DWORD *)(v9 + 40), *(_DWORD *)(v9 + 44), *(_DWORD *)(v9 + 48));
                  int v19 = &buf[strlen((const char *)buf)];
                }
                else
                {
LABEL_44:
                  snprintf((char *)buf, 0x800uLL, "<rrtype %d>:", *v12);
                  size_t v29 = strlen((const char *)buf);
                  int v19 = &buf[v29];
                  size_t v30 = 2048 - v29;
                  if (*(_WORD *)(v9 + 24))
                  {
                    unint64_t v31 = 0;
                    do
                    {
                      snprintf((char *)v19, v30, " %02x", *(unsigned __int8 *)(*(void *)(v9 + 16) + v31));
                      size_t v32 = strlen((const char *)v19);
                      v19 += v32;
                      v30 -= v32;
                      ++v31;
                    }
                    while (v31 < *(unsigned __int16 *)(v9 + 24));
                  }
                  else
                  {
                    snprintf((char *)&buf[v29], v30, " <none>");
                    v19 += strlen((const char *)v19);
                  }
                }
                goto LABEL_60;
              }
              dns_name_print_to_limit(*(uint64_t **)(v9 + 16), 0, (uint64_t)v51, 0x3F2uLL);
              snprintf((char *)buf, 0x800uLL, "CNAME %s");
            }
LABEL_59:
            int v19 = &buf[strlen((const char *)buf)];
LABEL_60:
            uint8_t *v19 = 0;
            __int16 v38 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)uint64_t v51 = 136446466;
              uint64_t v52 = "dns_rrdata_dump";
              __int16 v53 = 2082;
              int v54 = buf;
              _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEBUG, "%{public}s: %{public}s", v51, 0x16u);
            }
            return 1;
          }
        }
      }
    }
  }
  return result;
}

void dns_rrdata_free(uint64_t a1)
{
  if (a1)
  {
    if (!(!v2 & v1))
    {
      switch(*(_WORD *)(a1 + 8))
      {
        case 1:
          return;
        case 2:
        case 5:
        case 0xC:
          goto LABEL_10;
        case 3:
        case 4:
        case 7:
        case 8:
        case 9:
        case 0xA:
        case 0xB:
          goto LABEL_16;
        case 6:
          int v10 = *(void **)(a1 + 16);
          if (v10)
          {
            do
            {
              int v11 = (void *)*v10;
              free(v10);
              int v10 = v11;
            }
            while (v11);
          }
          __int16 v12 = *(void **)(a1 + 24);
          if (v12)
          {
            do
            {
              uint64_t v13 = (void *)*v12;
              free(v12);
              __int16 v12 = v13;
            }
            while (v13);
          }
          return;
        default:
          JUMPOUT(0);
      }
    }
    switch(*(_WORD *)(a1 + 8))
    {
      case 0x18:
        unsigned int v4 = *(void **)(a1 + 40);
        do
        {
          if (!v4) {
            break;
          }
          uint64_t v5 = (void *)*v4;
          free(v4);
          unsigned int v4 = v5;
        }
        while (v5);
        unsigned int v6 = *(void **)(a1 + 56);
        goto LABEL_27;
      case 0x19:
        unsigned int v6 = *(void **)(a1 + 24);
LABEL_27:
        free(v6);
        return;
      case 0x1A:
      case 0x1B:
      case 0x1D:
      case 0x1E:
      case 0x1F:
      case 0x20:
        goto LABEL_16;
      case 0x1C:
        return;
      case 0x21:
LABEL_10:
        uint64_t v7 = *(void **)(a1 + 16);
        do
        {
          if (!v7) {
            break;
          }
          uint64_t v8 = (void *)*v7;
          free(v7);
          uint64_t v7 = v8;
        }
        while (v8);
        goto LABEL_19;
      default:
        if (*(_WORD *)(a1 + 8) == 16)
        {
          free(*(void **)(a1 + 24));
          *(void *)(a1 + 24) = 0;
        }
        else
        {
LABEL_16:
          if (*(_WORD *)(a1 + 24))
          {
            uint64_t v9 = *(void **)(a1 + 16);
            if (v9) {
              free(v9);
            }
          }
LABEL_19:
          *(void *)(a1 + 16) = 0;
        }
        break;
    }
  }
}

void dns_message_free(void *a1)
{
  char v2 = (void *)a1[3];
  if (v2)
  {
    unint64_t v3 = *((unsigned int *)a1 + 1);
    if (v3)
    {
      for (unint64_t i = 0; i < v3; ++i)
      {
        uint64_t v5 = a1[3] + (i << 6);
        if (*(_WORD *)(v5 + 8))
        {
          unsigned int v6 = *(void **)v5;
          if (*(void *)v5)
          {
            do
            {
              uint64_t v7 = (void *)*v6;
              free(v6);
              unsigned int v6 = v7;
            }
            while (v7);
          }
          dns_rrdata_free(v5);
          unint64_t v3 = *((unsigned int *)a1 + 1);
        }
      }
      char v2 = (void *)a1[3];
    }
    free(v2);
  }
  uint64_t v8 = (void *)a1[4];
  if (v8)
  {
    unint64_t v9 = *((unsigned int *)a1 + 2);
    if (v9)
    {
      for (unint64_t j = 0; j < v9; ++j)
      {
        uint64_t v11 = a1[4] + (j << 6);
        if (*(_WORD *)(v11 + 8))
        {
          __int16 v12 = *(void **)v11;
          if (*(void *)v11)
          {
            do
            {
              uint64_t v13 = (void *)*v12;
              free(v12);
              __int16 v12 = v13;
            }
            while (v13);
          }
          dns_rrdata_free(v11);
          unint64_t v9 = *((unsigned int *)a1 + 2);
        }
      }
      uint64_t v8 = (void *)a1[4];
    }
    free(v8);
  }
  unsigned int v14 = (void *)a1[5];
  if (v14)
  {
    unint64_t v15 = *((unsigned int *)a1 + 3);
    if (v15)
    {
      for (unint64_t k = 0; k < v15; ++k)
      {
        uint64_t v17 = a1[5] + (k << 6);
        if (*(_WORD *)(v17 + 8))
        {
          unsigned int v18 = *(void **)v17;
          if (*(void *)v17)
          {
            do
            {
              int v19 = (void *)*v18;
              free(v18);
              unsigned int v18 = v19;
            }
            while (v19);
          }
          dns_rrdata_free(v17);
          unint64_t v15 = *((unsigned int *)a1 + 3);
        }
      }
      unsigned int v14 = (void *)a1[5];
    }
    free(v14);
  }
  size_t v20 = (void *)a1[6];
  if (v20)
  {
    unint64_t v21 = *((unsigned int *)a1 + 4);
    if (v21)
    {
      for (unint64_t m = 0; m < v21; ++m)
      {
        uint64_t v23 = a1[6] + (m << 6);
        if (*(_WORD *)(v23 + 8))
        {
          size_t v24 = *(void **)v23;
          if (*(void *)v23)
          {
            do
            {
              size_t v25 = (void *)*v24;
              free(v24);
              size_t v24 = v25;
            }
            while (v25);
          }
          dns_rrdata_free(v23);
          unint64_t v21 = *((unsigned int *)a1 + 4);
        }
      }
      size_t v20 = (void *)a1[6];
    }
    free(v20);
  }
  unint64_t v26 = (void *)a1[7];
  if (v26)
  {
    do
    {
      int v27 = (void *)*v26;
      free(v26);
      unint64_t v26 = v27;
    }
    while (v27);
  }

  free(a1);
}

uint64_t dns_wire_parse_(uint64_t *a1, unsigned __int16 *a2, unsigned int a3)
{
  uint64_t result = 0;
  if (a3 >= 0xC)
  {
    uint64_t result = (uint64_t)malloc_type_calloc(1uLL, 0x40uLL, 0x1020040822CA6C9uLL);
    if (result)
    {
      uint64_t v6 = result;
      unsigned int v7 = bswap32(a2[2]) >> 16;
      *(_DWORD *)(result + 4) = v7;
      if (v7 >= 0x33)
      {
        *(_DWORD *)(result + 4) = 0;
LABEL_37:
        dns_message_free((void *)v6);
        return 0;
      }
      uint64_t v8 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        size_t v34 = "dns_wire_parse_";
        __int16 v35 = 2080;
        size_t v36 = "question";
        __int16 v37 = 1024;
        unsigned int v38 = v7;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEBUG, "%{public}s: Section %s, %d records", buf, 0x1Cu);
        unsigned int v7 = *(_DWORD *)(v6 + 4);
      }
      if (!v7) {
        goto LABEL_13;
      }
      unint64_t v9 = malloc_type_calloc(v7, 0x40uLL, 0x1032040A90C5805uLL);
      *(void *)(v6 + 24) = v9;
      if (!v9) {
        goto LABEL_37;
      }
      if (*(_DWORD *)(v6 + 4))
      {
        uint64_t v10 = 0;
        unint64_t v11 = 0;
        while ((dns_rr_parse_() & 1) != 0)
        {
          ++v11;
          v10 += 64;
          if (v11 >= *(unsigned int *)(v6 + 4)) {
            goto LABEL_13;
          }
        }
        dns_message_free((void *)v6);
        unsigned int v18 = global_os_log;
        uint64_t result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
        if (result)
        {
          *(_DWORD *)buf = 136446466;
          size_t v34 = "dns_wire_parse_";
          __int16 v35 = 1024;
          LODWORD(v36) = v11;
          int v19 = "%{public}s: question %d RR parse failed.\n";
          goto LABEL_61;
        }
      }
      else
      {
LABEL_13:
        unsigned int v12 = bswap32(a2[3]) >> 16;
        *(_DWORD *)(v6 + 8) = v12;
        if (v12 >= 0x33)
        {
          *(_DWORD *)(v6 + 8) = 0;
          goto LABEL_37;
        }
        uint64_t v13 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          size_t v34 = "dns_wire_parse_";
          __int16 v35 = 2080;
          size_t v36 = "answers";
          __int16 v37 = 1024;
          unsigned int v38 = v12;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEBUG, "%{public}s: Section %s, %d records", buf, 0x1Cu);
          unsigned int v12 = *(_DWORD *)(v6 + 8);
        }
        if (!v12) {
          goto LABEL_23;
        }
        unsigned int v14 = malloc_type_calloc(v12, 0x40uLL, 0x1032040A90C5805uLL);
        *(void *)(v6 + 32) = v14;
        if (!v14) {
          goto LABEL_37;
        }
        if (*(_DWORD *)(v6 + 8))
        {
          uint64_t v15 = 0;
          unint64_t v16 = 0;
          while ((dns_rr_parse_() & 1) != 0)
          {
            ++v16;
            v15 += 64;
            if (v16 >= *(unsigned int *)(v6 + 8)) {
              goto LABEL_23;
            }
          }
          dns_message_free((void *)v6);
          unsigned int v18 = global_os_log;
          uint64_t result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
          if (result)
          {
            *(_DWORD *)buf = 136446466;
            size_t v34 = "dns_wire_parse_";
            __int16 v35 = 1024;
            LODWORD(v36) = v16;
            int v19 = "%{public}s: answers %d RR parse failed.\n";
            goto LABEL_61;
          }
        }
        else
        {
LABEL_23:
          unsigned int v17 = bswap32(a2[4]) >> 16;
          *(_DWORD *)(v6 + 12) = v17;
          if (v17 >= 0x33)
          {
            *(_DWORD *)(v6 + 12) = 0;
            goto LABEL_37;
          }
          size_t v20 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446722;
            size_t v34 = "dns_wire_parse_";
            __int16 v35 = 2080;
            size_t v36 = "authority";
            __int16 v37 = 1024;
            unsigned int v38 = v17;
            _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEBUG, "%{public}s: Section %s, %d records", buf, 0x1Cu);
            unsigned int v17 = *(_DWORD *)(v6 + 12);
          }
          if (!v17) {
            goto LABEL_35;
          }
          unint64_t v21 = malloc_type_calloc(v17, 0x40uLL, 0x1032040A90C5805uLL);
          *(void *)(v6 + 40) = v21;
          if (!v21) {
            goto LABEL_37;
          }
          if (!*(_DWORD *)(v6 + 12))
          {
LABEL_35:
            unsigned int v24 = bswap32(a2[5]) >> 16;
            *(_DWORD *)(v6 + 16) = v24;
            if (v24 >= 0x33)
            {
              *(_DWORD *)(v6 + 16) = 0;
              goto LABEL_37;
            }
            size_t v25 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446722;
              size_t v34 = "dns_wire_parse_";
              __int16 v35 = 2080;
              size_t v36 = "additional";
              __int16 v37 = 1024;
              unsigned int v38 = v24;
              _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEBUG, "%{public}s: Section %s, %d records", buf, 0x1Cu);
              unsigned int v24 = *(_DWORD *)(v6 + 16);
            }
            if (!v24) {
              goto LABEL_56;
            }
            unint64_t v26 = malloc_type_calloc(v24, 0x40uLL, 0x1032040A90C5805uLL);
            *(void *)(v6 + 48) = v26;
            if (!v26) {
              goto LABEL_37;
            }
            if (!*(_DWORD *)(v6 + 16))
            {
LABEL_56:
              *a1 = v6;
              return 1;
            }
            uint64_t v27 = 0;
            unint64_t v28 = 0;
            while ((dns_rr_parse_() & 1) != 0)
            {
              ++v28;
              unint64_t v29 = *(unsigned int *)(v6 + 16);
              v27 += 64;
              if (v28 >= v29)
              {
                if (*(_DWORD *)(v6 + 16))
                {
                  uint64_t v30 = 0;
                  unint64_t v31 = 0;
                  do
                  {
                    uint64_t v32 = *(void *)(v6 + 48) + v30;
                    if (*(_WORD *)(v32 + 8) == 41)
                    {
                      if (!dns_opt_parse((void *)(v6 + 56), v32)) {
                        goto LABEL_37;
                      }
                      unint64_t v29 = *(unsigned int *)(v6 + 16);
                    }
                    ++v31;
                    v30 += 64;
                  }
                  while (v31 < v29);
                }
                goto LABEL_56;
              }
            }
            dns_message_free((void *)v6);
            unsigned int v18 = global_os_log;
            uint64_t result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
            if (!result) {
              return result;
            }
            *(_DWORD *)buf = 136446466;
            size_t v34 = "dns_wire_parse_";
            __int16 v35 = 1024;
            LODWORD(v36) = v28;
            int v19 = "%{public}s: additional %d RR parse failed.\n";
LABEL_61:
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, v19, buf, 0x12u);
            return 0;
          }
          uint64_t v22 = 0;
          unint64_t v23 = 0;
          while ((dns_rr_parse_() & 1) != 0)
          {
            ++v23;
            v22 += 64;
            if (v23 >= *(unsigned int *)(v6 + 12)) {
              goto LABEL_35;
            }
          }
          dns_message_free((void *)v6);
          unsigned int v18 = global_os_log;
          uint64_t result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
          if (result)
          {
            *(_DWORD *)buf = 136446466;
            size_t v34 = "dns_wire_parse_";
            __int16 v35 = 1024;
            LODWORD(v36) = v23;
            int v19 = "%{public}s: authority %d RR parse failed.\n";
            goto LABEL_61;
          }
        }
      }
    }
  }
  return result;
}

uint64_t getipaddr(char *a1, const char *a2)
{
  char v4 = 2;
  uint64_t result = inet_pton(2, a2, a1 + 4);
  if (result)
  {
    char v6 = 16;
  }
  else
  {
    char v4 = 30;
    uint64_t result = inet_pton(30, a2, a1 + 8);
    if (!result) {
      return result;
    }
    char v6 = 28;
  }
  a1[1] = v4;
  *a1 = v6;
  return result;
}

void ioloop_wakeup_release_(void *a1, char *a2, int a3)
{
  if (!a1) {
    return;
  }
  int v6 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    unsigned int v7 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v11 = 136447490;
    unsigned int v12 = "ioloop_wakeup_release_";
    __int16 v13 = 1024;
    *(_DWORD *)unsigned int v14 = 0;
    *(_WORD *)&v14[4] = 2048;
    *(void *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(void *)&v14[16] = "wakeup";
    *(_WORD *)&v14[24] = 2080;
    *(void *)&v14[26] = strrchr(a2, 47) + 1;
    __int16 v15 = 1024;
    int v16 = a3;
    uint64_t v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  unsigned int v7 = global_os_log;
  if (v6 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v11 = 136447490;
    unsigned int v12 = "ioloop_wakeup_release_";
    __int16 v13 = 1024;
    *(_DWORD *)unsigned int v14 = v6;
    *(_WORD *)&v14[4] = 2048;
    *(void *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(void *)&v14[16] = "wakeup";
    *(_WORD *)&v14[24] = 2080;
    *(void *)&v14[26] = strrchr(a2, 47) + 1;
    __int16 v15 = 1024;
    int v16 = a3;
    uint64_t v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v11, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = 136447490;
    unsigned int v12 = "ioloop_wakeup_release_";
    __int16 v13 = 1024;
    *(_DWORD *)unsigned int v14 = v6;
    *(_WORD *)&v14[4] = 2048;
    *(void *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(void *)&v14[16] = "wakeup";
    *(_WORD *)&v14[24] = 2080;
    *(void *)&v14[26] = strrchr(a2, 47) + 1;
    __int16 v15 = 1024;
    int v16 = a3;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v11, 0x36u);
    int v6 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v6 - 1;
  if (v6 == 1)
  {
    uint64_t v8 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      unint64_t v9 = strrchr(a2, 47);
      int v11 = 136447234;
      unsigned int v12 = "ioloop_wakeup_release_";
      __int16 v13 = 2048;
      *(void *)unsigned int v14 = a1;
      *(_WORD *)&v14[8] = 2080;
      *(void *)&v14[10] = "wakeup";
      *(_WORD *)&v14[18] = 2080;
      *(void *)&v14[20] = v9 + 1;
      *(_WORD *)&v14[28] = 1024;
      *(_DWORD *)&v14[30] = a3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v11, 0x30u);
    }
    ++wakeup_finalized;
    wakeup_finalize(a1);
  }
}

void wakeup_finalize(void *a1)
{
  if (!*(_DWORD *)a1)
  {
    char v2 = a1[5];
    if (v2)
    {
      dispatch_release(v2);
      a1[5] = 0;
    }
    uint64_t v3 = a1[2];
    char v4 = (void (*)(void))a1[4];
    a1[4] = 0;
    a1[2] = 0;
    if (v4) {
      BOOL v5 = v3 == 0;
    }
    else {
      BOOL v5 = 1;
    }
    if (!v5) {
      v4();
    }
    free(a1);
  }
}

int *ioloop_wakeup_create_(char *a1, int a2)
{
  char v4 = (int *)malloc_type_calloc(1uLL, 0x30uLL, 0x10A00405AB591E4uLL);
  if (v4)
  {
    BOOL v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = *v4;
      *(_DWORD *)buf = 136447490;
      __int16 v13 = "ioloop_wakeup_create_";
      __int16 v14 = 1024;
      int v15 = v6;
      __int16 v16 = 2048;
      unsigned int v17 = v4;
      __int16 v18 = 2080;
      int v19 = "ret";
      __int16 v20 = 2080;
      unint64_t v21 = strrchr(a1, 47) + 1;
      __int16 v22 = 1024;
      int v23 = a2;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    if (*v4)
    {
      int v7 = *v4 + 1;
      int *v4 = v7;
      if (v7 >= 10001)
      {
        int v11 = v7;
        uint64_t v8 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          unint64_t v9 = strrchr(a1, 47);
          *(_DWORD *)buf = 136447490;
          __int16 v13 = "ioloop_wakeup_create_";
          __int16 v14 = 1024;
          int v15 = v11;
          __int16 v16 = 2048;
          unsigned int v17 = v4;
          __int16 v18 = 2080;
          int v19 = "ret";
          __int16 v20 = 2080;
          unint64_t v21 = v9 + 1;
          __int16 v22 = 1024;
          int v23 = a2;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++wakeup_created;
      int *v4 = 1;
    }
  }
  return v4;
}

BOOL ioloop_add_wake_event(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  if (!a3)
  {
    __int16 v16 = global_os_log;
    BOOL result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v18 = 136446210;
    int v19 = "ioloop_add_wake_event";
    unsigned int v17 = "%{public}s: ioloop_add_wake_event called with null callback";
LABEL_17:
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, v17, (uint8_t *)&v18, 0xCu);
    return 0;
  }
  unsigned int v5 = a5;
  if ((a5 & 0x80000000) != 0)
  {
    __int16 v16 = global_os_log;
    BOOL result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v18 = 136446210;
    int v19 = "ioloop_add_wake_event";
    unsigned int v17 = "%{public}s: ioloop_add_wake_event called with negative timeout";
    goto LABEL_17;
  }
  if (*(void *)(a1 + 40)) {
    ioloop_cancel_wake_event(a1);
  }
  *(void *)(a1 + 16) = a2;
  *(void *)(a1 + 24) = a3;
  *(void *)(a1 + 32) = a4;
  uint64_t v10 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, (dispatch_queue_t)ioloop_main_queue);
  *(void *)(a1 + 40) = v10;
  if (!v10)
  {
    __int16 v16 = global_os_log;
    BOOL result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v18 = 136446210;
    int v19 = "ioloop_add_wake_event";
    unsigned int v17 = "%{public}s: dispatch_source_create failed in ioloop_add_wake_event().";
    goto LABEL_17;
  }
  dispatch_source_set_event_handler_f(v10, (dispatch_function_t)wakeup_event);
  dispatch_set_context(*(dispatch_object_t *)(a1 + 40), (void *)a1);
  if (!v5)
  {
    int v11 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      int v18 = 136446466;
      int v19 = "ioloop_add_wake_event";
      __int16 v20 = 1024;
      int v21 = 0;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%{public}s: ioloop_add_wake_event: milliseconds = %d", (uint8_t *)&v18, 0x12u);
    }
    unsigned int v5 = 10;
  }
  unsigned int v12 = *(NSObject **)(a1 + 40);
  uint64_t v13 = 1000000 * v5;
  dispatch_time_t v14 = dispatch_time(0, v13);
  dispatch_source_set_timer(v12, v14, v13, 0x989680uLL);
  dispatch_resume(*(dispatch_object_t *)(a1 + 40));
  return 1;
}

uint64_t ioloop_cancel_wake_event(uint64_t result)
{
  if (result)
  {
    uint64_t v1 = result;
    char v2 = *(NSObject **)(result + 40);
    if (v2)
    {
      dispatch_source_cancel(v2);
      dispatch_release(*(dispatch_object_t *)(v1 + 40));
      *(void *)(v1 + 40) = 0;
    }
    BOOL result = *(void *)(v1 + 16);
    if (result)
    {
      uint64_t v3 = *(uint64_t (**)(void))(v1 + 32);
      *(void *)(v1 + 16) = 0;
      *(void *)(v1 + 32) = 0;
      if (v3)
      {
        return v3();
      }
    }
  }
  return result;
}

uint64_t wakeup_event(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 16);
  unsigned int v5 = *(uint64_t (**)(uint64_t))(a1 + 32);
  *(void *)(a1 + 16) = 0;
  *(void *)(a1 + 32) = 0;
  ioloop_cancel_wake_event(a1);
  uint64_t result = (*(uint64_t (**)(uint64_t))(a1 + 24))(v2);
  if (v2) {
    BOOL v4 = v5 == 0;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    return v5(v2);
  }
  return result;
}

void ioloop()
{
}

void ioloop_comm_retain_(uint64_t a1, char *a2, int a3)
{
  if (a1)
  {
    int v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = *(_DWORD *)(a1 + 32);
      *(_DWORD *)buf = 136447490;
      dispatch_time_t v14 = "ioloop_comm_retain_";
      __int16 v15 = 1024;
      int v16 = v7;
      __int16 v17 = 2048;
      uint64_t v18 = a1;
      __int16 v19 = 2080;
      __int16 v20 = "comm";
      __int16 v21 = 2080;
      __int16 v22 = strrchr(a2, 47) + 1;
      __int16 v23 = 1024;
      int v24 = a3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    int v8 = *(_DWORD *)(a1 + 32);
    if (v8)
    {
      int v9 = v8 + 1;
      *(_DWORD *)(a1 + 32) = v9;
      if (v9 >= 10001)
      {
        int v12 = v9;
        uint64_t v10 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          int v11 = strrchr(a2, 47);
          *(_DWORD *)buf = 136447490;
          dispatch_time_t v14 = "ioloop_comm_retain_";
          __int16 v15 = 1024;
          int v16 = v12;
          __int16 v17 = 2048;
          uint64_t v18 = a1;
          __int16 v19 = 2080;
          __int16 v20 = "comm";
          __int16 v21 = 2080;
          __int16 v22 = v11 + 1;
          __int16 v23 = 1024;
          int v24 = a3;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++comm_created;
      *(_DWORD *)(a1 + 32) = 1;
    }
  }
}

void ioloop_comm_release_(uint64_t a1, char *a2, int a3)
{
  if (!a1) {
    return;
  }
  int v6 = *(_DWORD *)(a1 + 32);
  if (!v6)
  {
    int v7 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v11 = 136447490;
    int v12 = "ioloop_comm_release_";
    __int16 v13 = 1024;
    *(_DWORD *)dispatch_time_t v14 = 0;
    *(_WORD *)&v14[4] = 2048;
    *(void *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(void *)&v14[16] = "comm";
    *(_WORD *)&v14[24] = 2080;
    *(void *)&v14[26] = strrchr(a2, 47) + 1;
    __int16 v15 = 1024;
    int v16 = a3;
    uint64_t v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  int v7 = global_os_log;
  if (v6 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v11 = 136447490;
    int v12 = "ioloop_comm_release_";
    __int16 v13 = 1024;
    *(_DWORD *)dispatch_time_t v14 = v6;
    *(_WORD *)&v14[4] = 2048;
    *(void *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(void *)&v14[16] = "comm";
    *(_WORD *)&v14[24] = 2080;
    *(void *)&v14[26] = strrchr(a2, 47) + 1;
    __int16 v15 = 1024;
    int v16 = a3;
    uint64_t v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v11, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = 136447490;
    int v12 = "ioloop_comm_release_";
    __int16 v13 = 1024;
    *(_DWORD *)dispatch_time_t v14 = v6;
    *(_WORD *)&v14[4] = 2048;
    *(void *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(void *)&v14[16] = "comm";
    *(_WORD *)&v14[24] = 2080;
    *(void *)&v14[26] = strrchr(a2, 47) + 1;
    __int16 v15 = 1024;
    int v16 = a3;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v11, 0x36u);
    int v6 = *(_DWORD *)(a1 + 32);
  }
  *(_DWORD *)(a1 + 32) = v6 - 1;
  if (v6 == 1)
  {
    int v8 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = strrchr(a2, 47);
      int v11 = 136447234;
      int v12 = "ioloop_comm_release_";
      __int16 v13 = 2048;
      *(void *)dispatch_time_t v14 = a1;
      *(_WORD *)&v14[8] = 2080;
      *(void *)&v14[10] = "comm";
      *(_WORD *)&v14[18] = 2080;
      *(void *)&v14[20] = v9 + 1;
      *(_WORD *)&v14[28] = 1024;
      *(_DWORD *)&v14[30] = a3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v11, 0x30u);
    }
    ++comm_finalized;
    comm_finalize(a1);
  }
}

void comm_finalize(uint64_t a1)
{
  uint64_t v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    int v20 = 136446210;
    __int16 v21 = "comm_finalize";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "%{public}s: comm_finalize", (uint8_t *)&v20, 0xCu);
  }
  if (*(void *)a1)
  {
    nw_release(*(void **)a1);
    ++nw_connection_finalized;
    *(void *)a1 = 0;
  }
  uint64_t v3 = *(void **)(a1 + 8);
  if (v3)
  {
    nw_release(v3);
    ++nw_listener_finalized;
    *(void *)(a1 + 8) = 0;
  }
  BOOL v4 = *(void **)(a1 + 16);
  if (v4)
  {
    nw_release(v4);
    *(void *)(a1 + 16) = 0;
  }
  unsigned int v5 = *(NSObject **)(a1 + 48);
  if (v5)
  {
    dispatch_release(v5);
    *(void *)(a1 + 48) = 0;
  }
  uint64_t v6 = *(void *)(a1 + 24);
  if (v6)
  {
    int v7 = *(_DWORD *)(v6 + 32);
    if (!v7)
    {
      uint64_t v17 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_51;
      }
      int v20 = 136447490;
      __int16 v21 = "comm_finalize";
      __int16 v22 = 1024;
      *(_DWORD *)__int16 v23 = 0;
      *(_WORD *)&v23[4] = 2048;
      *(void *)&v23[6] = v6;
      *(_WORD *)&v23[14] = 2080;
      *(void *)&v23[16] = "comm->listener_state";
      *(_WORD *)&v23[24] = 2080;
      *(void *)&v23[26] = "macos-ioloop.c";
      __int16 v24 = 1024;
      int v25 = 274;
      uint64_t v18 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_46;
    }
    int v8 = global_os_log;
    if (v7 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_51;
      }
      int v20 = 136447490;
      __int16 v21 = "comm_finalize";
      __int16 v22 = 1024;
      *(_DWORD *)__int16 v23 = v7;
      *(_WORD *)&v23[4] = 2048;
      *(void *)&v23[6] = v6;
      *(_WORD *)&v23[14] = 2080;
      *(void *)&v23[16] = "comm->listener_state";
      *(_WORD *)&v23[24] = 2080;
      *(void *)&v23[26] = "macos-ioloop.c";
      __int16 v24 = 1024;
      int v25 = 274;
      uint64_t v18 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_49:
      __int16 v19 = v8;
      goto LABEL_50;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v20 = 136447490;
      __int16 v21 = "comm_finalize";
      __int16 v22 = 1024;
      *(_DWORD *)__int16 v23 = v7;
      *(_WORD *)&v23[4] = 2048;
      *(void *)&v23[6] = v6;
      *(_WORD *)&v23[14] = 2080;
      *(void *)&v23[16] = "comm->listener_state";
      *(_WORD *)&v23[24] = 2080;
      *(void *)&v23[26] = "macos-ioloop.c";
      __int16 v24 = 1024;
      int v25 = 274;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v20, 0x36u);
      uint64_t v6 = *(void *)(a1 + 24);
      int v7 = *(_DWORD *)(v6 + 32);
    }
    *(_DWORD *)(v6 + 32) = v7 - 1;
    if (v7 == 1)
    {
      int v9 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v20 = 136447234;
        __int16 v21 = "comm_finalize";
        __int16 v22 = 2048;
        *(void *)__int16 v23 = v6;
        *(_WORD *)&v23[8] = 2080;
        *(void *)&v23[10] = "comm->listener_state";
        *(_WORD *)&v23[18] = 2080;
        *(void *)&v23[20] = "macos-ioloop.c";
        *(_WORD *)&v23[28] = 1024;
        *(_DWORD *)&v23[30] = 274;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v20, 0x30u);
        uint64_t v6 = *(void *)(a1 + 24);
      }
      ++listener_finalized;
      listener_finalize((void *)v6);
    }
    *(void *)(a1 + 24) = 0;
  }
  if (*(int *)(a1 + 32) > 0) {
    return;
  }
  uint64_t v10 = *(void *)(a1 + 40);
  if (v10)
  {
    ioloop_cancel_wake_event(v10);
    int v11 = *(void **)(a1 + 40);
    if (v11)
    {
      int v12 = *(_DWORD *)v11;
      if (*(_DWORD *)v11)
      {
        int v8 = global_os_log;
        if (v12 < 10001)
        {
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v20 = 136447490;
            __int16 v21 = "comm_finalize";
            __int16 v22 = 1024;
            *(_DWORD *)__int16 v23 = v12;
            *(_WORD *)&v23[4] = 2048;
            *(void *)&v23[6] = v11;
            *(_WORD *)&v23[14] = 2080;
            *(void *)&v23[16] = "comm->idle_timer";
            *(_WORD *)&v23[24] = 2080;
            *(void *)&v23[26] = "macos-ioloop.c";
            __int16 v24 = 1024;
            int v25 = 295;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v20, 0x36u);
            int v11 = *(void **)(a1 + 40);
            int v12 = *(_DWORD *)v11;
          }
          *(_DWORD *)int v11 = v12 - 1;
          if (v12 == 1)
          {
            __int16 v13 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              int v20 = 136447234;
              __int16 v21 = "comm_finalize";
              __int16 v22 = 2048;
              *(void *)__int16 v23 = v11;
              *(_WORD *)&v23[8] = 2080;
              *(void *)&v23[10] = "comm->idle_timer";
              *(_WORD *)&v23[18] = 2080;
              *(void *)&v23[20] = "macos-ioloop.c";
              *(_WORD *)&v23[28] = 1024;
              *(_DWORD *)&v23[30] = 295;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v20, 0x30u);
              int v11 = *(void **)(a1 + 40);
            }
            ++wakeup_finalized;
            wakeup_finalize(v11);
          }
          goto LABEL_32;
        }
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_51:
        }
          abort();
        int v20 = 136447490;
        __int16 v21 = "comm_finalize";
        __int16 v22 = 1024;
        *(_DWORD *)__int16 v23 = v12;
        *(_WORD *)&v23[4] = 2048;
        *(void *)&v23[6] = v11;
        *(_WORD *)&v23[14] = 2080;
        *(void *)&v23[16] = "comm->idle_timer";
        *(_WORD *)&v23[24] = 2080;
        *(void *)&v23[26] = "macos-ioloop.c";
        __int16 v24 = 1024;
        int v25 = 295;
        uint64_t v18 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_49;
      }
      uint64_t v17 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_51;
      }
      int v20 = 136447490;
      __int16 v21 = "comm_finalize";
      __int16 v22 = 1024;
      *(_DWORD *)__int16 v23 = 0;
      *(_WORD *)&v23[4] = 2048;
      *(void *)&v23[6] = v11;
      *(_WORD *)&v23[14] = 2080;
      *(void *)&v23[16] = "comm->idle_timer";
      *(_WORD *)&v23[24] = 2080;
      *(void *)&v23[26] = "macos-ioloop.c";
      __int16 v24 = 1024;
      int v25 = 295;
      uint64_t v18 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_46:
      __int16 v19 = v17;
LABEL_50:
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, v18, (uint8_t *)&v20, 0x36u);
      goto LABEL_51;
    }
  }
LABEL_32:
  dispatch_time_t v14 = *(void **)(a1 + 192);
  if (v14) {
    free(v14);
  }
  __int16 v15 = *(int **)(a1 + 408);
  if (v15) {
    ifpermit_list_release_(v15, 302);
  }
  int v16 = *(void (**)(void))(a1 + 240);
  if (v16) {
    v16(*(void *)(a1 + 200));
  }
  free((void *)a1);
}

void listener_finalize(void *a1)
{
  uint64_t v2 = (void *)a1[1];
  if (v2)
  {
    nw_release(v2);
    ++nw_listener_finalized;
    a1[1] = 0;
  }
  uint64_t v3 = (void *)a1[24];
  if (v3) {
    free(v3);
  }
  BOOL v4 = (void *)a1[2];
  if (v4) {
    nw_release(v4);
  }
  unsigned int v5 = (void *)a1[21];
  if (v5) {
    free(v5);
  }
  uint64_t v6 = (int *)a1[51];
  if (v6) {
    ifpermit_list_release_(v6, 1125);
  }
  int v7 = (void (*)(void))a1[30];
  if (v7) {
    v7(a1[25]);
  }

  free(a1);
}

void ioloop_comm_cancel(uint64_t a1)
{
  __int16 v1 = *(_WORD *)(a1 + 416);
  if ((v1 & 0x400) != 0)
  {
    uint64_t v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v15 = "ioloop_comm_cancel";
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "%{public}s: already canceled", buf, 0xCu);
    }
  }
  else
  {
    uint64_t v3 = *(NSObject **)a1;
    if (*(void *)a1)
    {
      BOOL v4 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446722;
        __int16 v15 = "ioloop_comm_cancel";
        __int16 v16 = 2048;
        *(void *)uint64_t v17 = a1;
        *(_WORD *)&v17[8] = 2048;
        *(void *)&v17[10] = v3;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: %p %p", buf, 0x20u);
        uint64_t v3 = *(NSObject **)a1;
      }
      connection_cancel_(a1, v3, 334);
      __int16 v1 = *(_WORD *)(a1 + 416);
    }
    if ((v1 & 0x20) == 0 && !*(void *)a1 && *(_DWORD *)(a1 + 148) != -1)
    {
      ioloop_close(a1 + 56);
      if (*(void *)(a1 + 248))
      {
        int v7 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v8 = *(_DWORD *)(a1 + 32);
          *(_DWORD *)buf = 136447490;
          __int16 v15 = "ioloop_comm_cancel";
          __int16 v16 = 1024;
          *(_DWORD *)uint64_t v17 = v8;
          *(_WORD *)&v17[4] = 2048;
          *(void *)&v17[6] = a1;
          *(_WORD *)&v17[14] = 2080;
          *(void *)&v17[16] = "connection";
          __int16 v18 = 2080;
          __int16 v19 = "macos-ioloop.c";
          __int16 v20 = 1024;
          int v21 = 346;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        int v9 = *(_DWORD *)(a1 + 32);
        if (v9)
        {
          int v10 = v9 + 1;
          *(_DWORD *)(a1 + 32) = v10;
          if (v10 >= 10001)
          {
            int v12 = v10;
            int v11 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 136447490;
              __int16 v15 = "ioloop_comm_cancel";
              __int16 v16 = 1024;
              *(_DWORD *)uint64_t v17 = v12;
              *(_WORD *)&v17[4] = 2048;
              *(void *)&v17[6] = a1;
              *(_WORD *)&v17[14] = 2080;
              *(void *)&v17[16] = "connection";
              __int16 v18 = 2080;
              __int16 v19 = "macos-ioloop.c";
              __int16 v20 = 1024;
              int v21 = 346;
              _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            }
            abort();
          }
        }
        else
        {
          ++listener_created;
          *(_DWORD *)(a1 + 32) = 1;
        }
        block[0] = _NSConcreteStackBlock;
        block[1] = 0x40000000;
        block[2] = __ioloop_comm_cancel_block_invoke;
        block[3] = &__block_descriptor_tmp_1091;
        block[4] = a1;
        dispatch_async((dispatch_queue_t)ioloop_main_queue, block);
      }
    }
    uint64_t v5 = *(void *)(a1 + 40);
    if (v5) {
      ioloop_cancel_wake_event(v5);
    }
    *(_WORD *)(a1 + 416) |= 0x400u;
  }
}

void connection_cancel_(uint64_t a1, NSObject *a2, int a3)
{
  uint64_t v6 = global_os_log;
  BOOL v7 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v7)
    {
      int v8 = " (already canceled)";
      __int16 v9 = *(_WORD *)(a1 + 416);
      int v11 = "connection_cancel_";
      int v10 = 136447234;
      __int16 v12 = 2048;
      if ((v9 & 0x400) == 0) {
        int v8 = "";
      }
      __int16 v13 = (const char *)a2;
      __int16 v14 = 2082;
      __int16 v15 = v8;
      __int16 v16 = 2082;
      uint64_t v17 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/macos-ioloop.c";
      __int16 v18 = 1024;
      int v19 = a3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: %p: %{public}s %{public}s:%d", (uint8_t *)&v10, 0x30u);
    }
    if ((*(_WORD *)(a1 + 416) & 0x400) == 0) {
      nw_connection_cancel(a2);
    }
  }
  else if (v7)
  {
    int v10 = 136446722;
    int v11 = "connection_cancel_";
    __int16 v12 = 2082;
    __int16 v13 = "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/macos-ioloop.c";
    __int16 v14 = 1024;
    LODWORD(v15) = a3;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: null connection at %{public}s:%d", (uint8_t *)&v10, 0x1Cu);
  }
}

void ioloop_close(uint64_t a1)
{
  uint64_t v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(_DWORD *)(a1 + 92);
    uint64_t v4 = *(void *)(a1 + 72);
    uint64_t v5 = *(void *)(a1 + 80);
    int v8 = 136447234;
    __int16 v9 = "ioloop_close";
    __int16 v10 = 2048;
    uint64_t v11 = a1;
    __int16 v12 = 1024;
    int v13 = v3;
    __int16 v14 = 2048;
    uint64_t v15 = v4;
    __int16 v16 = 2048;
    uint64_t v17 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: io %p fd %d, read source %p, write_source %p", (uint8_t *)&v8, 0x30u);
  }
  uint64_t v6 = *(NSObject **)(a1 + 72);
  if (v6) {
    dispatch_source_cancel(v6);
  }
  BOOL v7 = *(NSObject **)(a1 + 80);
  if (v7) {
    dispatch_source_cancel(v7);
  }
}

void __ioloop_comm_cancel_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(void (**)(void, void))(v2 + 248);
  if (v3)
  {
    v3(*(void *)(a1 + 32), *(void *)(v2 + 200));
    uint64_t v2 = *(void *)(a1 + 32);
    if (!v2) {
      return;
    }
  }
  int v4 = *(_DWORD *)(v2 + 32);
  if (!v4)
  {
    uint64_t v7 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_17;
    }
    int v10 = 136447490;
    uint64_t v11 = "ioloop_comm_cancel_block_invoke";
    __int16 v12 = 1024;
    *(_DWORD *)int v13 = 0;
    *(_WORD *)&v13[4] = 2048;
    *(void *)&v13[6] = v2;
    *(_WORD *)&v13[14] = 2080;
    *(void *)&v13[16] = "connection";
    *(_WORD *)&v13[24] = 2080;
    *(void *)&v13[26] = "macos-ioloop.c";
    __int16 v14 = 1024;
    int v15 = 351;
    int v8 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    __int16 v9 = v7;
    goto LABEL_16;
  }
  uint64_t v5 = global_os_log;
  if (v4 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_17;
    }
    int v10 = 136447490;
    uint64_t v11 = "ioloop_comm_cancel_block_invoke";
    __int16 v12 = 1024;
    *(_DWORD *)int v13 = v4;
    *(_WORD *)&v13[4] = 2048;
    *(void *)&v13[6] = v2;
    *(_WORD *)&v13[14] = 2080;
    *(void *)&v13[16] = "connection";
    *(_WORD *)&v13[24] = 2080;
    *(void *)&v13[26] = "macos-ioloop.c";
    __int16 v14 = 1024;
    int v15 = 351;
    int v8 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    __int16 v9 = v5;
LABEL_16:
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, v8, (uint8_t *)&v10, 0x36u);
LABEL_17:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = 136447490;
    uint64_t v11 = "ioloop_comm_cancel_block_invoke";
    __int16 v12 = 1024;
    *(_DWORD *)int v13 = v4;
    *(_WORD *)&v13[4] = 2048;
    *(void *)&v13[6] = v2;
    *(_WORD *)&v13[14] = 2080;
    *(void *)&v13[16] = "connection";
    *(_WORD *)&v13[24] = 2080;
    *(void *)&v13[26] = "macos-ioloop.c";
    __int16 v14 = 1024;
    int v15 = 351;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v10, 0x36u);
    uint64_t v2 = *(void *)(a1 + 32);
    int v4 = *(_DWORD *)(v2 + 32);
  }
  *(_DWORD *)(v2 + 32) = v4 - 1;
  if (v4 == 1)
  {
    uint64_t v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 136447234;
      uint64_t v11 = "ioloop_comm_cancel_block_invoke";
      __int16 v12 = 2048;
      *(void *)int v13 = v2;
      *(_WORD *)&v13[8] = 2080;
      *(void *)&v13[10] = "connection";
      *(_WORD *)&v13[18] = 2080;
      *(void *)&v13[20] = "macos-ioloop.c";
      *(_WORD *)&v13[28] = 1024;
      *(_DWORD *)&v13[30] = 351;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v10, 0x30u);
      uint64_t v2 = *(void *)(a1 + 32);
    }
    ++listener_finalized;
    listener_finalize((void *)v2);
  }
}

void ioloop_message_retain_(int *a1, char *a2, int a3)
{
  if (a1)
  {
    uint64_t v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = *a1;
      *(_DWORD *)buf = 136447490;
      int v13 = "ioloop_message_retain_";
      __int16 v14 = 1024;
      int v15 = v7;
      __int16 v16 = 2048;
      uint64_t v17 = a1;
      __int16 v18 = 2080;
      int v19 = "message";
      __int16 v20 = 2080;
      int v21 = strrchr(a2, 47) + 1;
      __int16 v22 = 1024;
      int v23 = a3;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    if (*a1)
    {
      int v8 = *a1 + 1;
      *a1 = v8;
      if (v8 >= 10001)
      {
        int v11 = v8;
        __int16 v9 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          int v10 = strrchr(a2, 47);
          *(_DWORD *)buf = 136447490;
          int v13 = "ioloop_message_retain_";
          __int16 v14 = 1024;
          int v15 = v11;
          __int16 v16 = 2048;
          uint64_t v17 = a1;
          __int16 v18 = 2080;
          int v19 = "message";
          __int16 v20 = 2080;
          int v21 = v10 + 1;
          __int16 v22 = 1024;
          int v23 = a3;
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++message_created;
      *a1 = 1;
    }
  }
}

void ioloop_message_release_(int *a1, char *a2, int a3)
{
  int v6 = *a1;
  if (!*a1)
  {
    int v7 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_15;
    }
    int v11 = 136447490;
    __int16 v12 = "ioloop_message_release_";
    __int16 v13 = 1024;
    *(_DWORD *)__int16 v14 = 0;
    *(_WORD *)&v14[4] = 2048;
    *(void *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(void *)&v14[16] = "message";
    *(_WORD *)&v14[24] = 2080;
    *(void *)&v14[26] = strrchr(a2, 47) + 1;
    __int16 v15 = 1024;
    int v16 = a3;
    int v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_14;
  }
  int v7 = global_os_log;
  if (v6 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_15;
    }
    int v11 = 136447490;
    __int16 v12 = "ioloop_message_release_";
    __int16 v13 = 1024;
    *(_DWORD *)__int16 v14 = v6;
    *(_WORD *)&v14[4] = 2048;
    *(void *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(void *)&v14[16] = "message";
    *(_WORD *)&v14[24] = 2080;
    *(void *)&v14[26] = strrchr(a2, 47) + 1;
    __int16 v15 = 1024;
    int v16 = a3;
    int v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_14:
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v11, 0x36u);
LABEL_15:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = 136447490;
    __int16 v12 = "ioloop_message_release_";
    __int16 v13 = 1024;
    *(_DWORD *)__int16 v14 = v6;
    *(_WORD *)&v14[4] = 2048;
    *(void *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(void *)&v14[16] = "message";
    *(_WORD *)&v14[24] = 2080;
    *(void *)&v14[26] = strrchr(a2, 47) + 1;
    __int16 v15 = 1024;
    int v16 = a3;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v11, 0x36u);
    int v6 = *a1;
  }
  *a1 = v6 - 1;
  if (v6 == 1)
  {
    int v8 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v9 = strrchr(a2, 47);
      int v11 = 136447234;
      __int16 v12 = "ioloop_message_release_";
      __int16 v13 = 2048;
      *(void *)__int16 v14 = a1;
      *(_WORD *)&v14[8] = 2080;
      *(void *)&v14[10] = "message";
      *(_WORD *)&v14[18] = 2080;
      *(void *)&v14[20] = v9 + 1;
      *(_WORD *)&v14[28] = 1024;
      *(_DWORD *)&v14[30] = a3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v11, 0x30u);
    }
    ++message_finalized;
    free(a1);
  }
}

uint64_t ioloop_send_message(uint64_t a1, uint64_t a2, iovec *a3)
{
  uint64_t v5 = *(void *)a1;
  if ((*(_WORD *)(a1 + 416) & 0x20) != 0)
  {
    if (!v5)
    {
      uint64_t v17 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v46 = "ioloop_send_message_inner";
      __int16 v18 = "%{public}s: no connection";
      goto LABEL_38;
    }
  }
  else if (!v5)
  {
    if (*(_DWORD *)(a1 + 148) != -1)
    {
      int v6 = *(_DWORD *)(a2 + 60);
      *(void *)&v44.msg_namelen = 0;
      *(&v44.msg_iovlen + 1) = 0;
      v44.msg_iov = a3;
      v44.msg_iovlen = 1;
      v44.msg_name = (void *)(a2 + 4);
      v44.msg_control = &buffer;
      *(void *)&v44.msg_controllen = 0;
      int v7 = *(unsigned __int8 *)(a2 + 33);
      if (v7 == 30)
      {
        v44.msg_namelen = 28;
        v44.msg_controllen = 32;
        uint64_t buffer = 0x2900000020;
        int v91 = 46;
        int v93 = v6;
        long long v92 = *(_OWORD *)(a2 + 40);
      }
      else
      {
        if (v7 != 2)
        {
          __int16 v35 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v46 = "ioloop_udp_send_message";
            __int16 v47 = 1024;
            LODWORD(v48) = v7;
            _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, "%{public}s: unknown family %d", buf, 0x12u);
          }
          abort();
        }
        v44.msg_namelen = 16;
        v44.msg_controllen = 24;
        uint64_t buffer = 24;
        int v91 = 26;
        LODWORD(v92) = v6;
        DWORD1(v92) = *(_DWORD *)(a2 + 36);
        DWORD2(v92) = DWORD1(v92);
      }
      int v19 = (long long *)(a2 + 32);
      size_t iov_len = a3->iov_len;
      uint64_t v40 = 0;
      uint64_t v41 = 0;
      int v43 = 0;
      uint64_t v42 = 0;
      uint64_t v36 = 0;
      uint64_t v37 = 0;
      int v39 = 0;
      uint64_t v38 = 0;
      ioloop_normalize_address((uint64_t)&v40, (long long *)(a2 + 4));
      ioloop_normalize_address((uint64_t)&v36, v19);
      int v21 = BYTE1(v40);
      uint64_t v22 = global_os_log;
      BOOL v23 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
      if (v21 == 2)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136448771;
          uint64_t v46 = "ioloop_udp_send_message";
          __int16 v47 = 2048;
          uint64_t v48 = iov_len;
          __int16 v49 = 2160;
          uint64_t v50 = 1752392040;
          __int16 v51 = 1041;
          *(_DWORD *)uint64_t v52 = 4;
          *(_WORD *)&v52[4] = 2097;
          *(void *)&v52[6] = (char *)&v36 + 4;
          __int16 v53 = 1024;
          *(_DWORD *)int v54 = v6;
          *(_WORD *)&v54[4] = 1024;
          *(_DWORD *)&v54[6] = bswap32(WORD1(v36)) >> 16;
          strcpy((char *)&v55, "p\bhash");
          HIBYTE(v55) = 0;
          __int16 v56 = 0;
          *(_WORD *)__int16 v57 = 1041;
          *(_DWORD *)&v57[2] = 4;
          *(_WORD *)int v58 = 2097;
          *(void *)&v58[2] = (char *)&v40 + 4;
          LOWORD(v59) = 1024;
          *(_DWORD *)((char *)&v59 + 2) = bswap32(WORD1(v40)) >> 16;
          __int16 v24 = "%{public}s: sending %zd byte UDP response from %{private, mask.hash, network:in_addr}.4P port %d index %"
                "d to %{private, mask.hash, network:in_addr}.4P#%d";
          int v25 = v22;
          uint32_t v26 = 92;
LABEL_55:
          _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, v24, buf, v26);
        }
      }
      else if (v23)
      {
        if ((v37 & 0xFE) == 0xFC)
        {
          uint64_t v27 = "ULA: ";
        }
        else if (v37 == 254 && (BYTE1(v37) & 0xC0) == 0x80)
        {
          uint64_t v27 = "LUA: ";
        }
        else if ((v37 & 0xE0) == 0x20)
        {
          uint64_t v27 = "GUA: ";
        }
        else
        {
          uint64_t v27 = "";
        }
        unsigned int v29 = bswap32(WORD1(v36)) >> 16;
        if ((v41 & 0xFE) == 0xFC)
        {
          uint64_t v30 = "ULA: ";
        }
        else if (v41 == 254 && (BYTE1(v41) & 0xC0) == 0x80)
        {
          uint64_t v30 = "LUA: ";
        }
        else
        {
          uint64_t v30 = "";
          if ((v41 & 0xE0) == 0x20) {
            uint64_t v30 = "GUA: ";
          }
        }
        *(_DWORD *)buf = 136452355;
        uint64_t v46 = "ioloop_udp_send_message";
        __int16 v47 = 2048;
        uint64_t v48 = iov_len;
        __int16 v49 = 2082;
        uint64_t v50 = (uint64_t)v27;
        __int16 v51 = 2160;
        *(void *)uint64_t v52 = 1752392040;
        *(_WORD *)&v52[8] = 1041;
        *(_DWORD *)&v52[10] = 6;
        __int16 v53 = 2097;
        *(void *)int v54 = &v37;
        *(_WORD *)&v54[8] = 2160;
        uint64_t v55 = 1752392040;
        __int16 v56 = 1042;
        *(_DWORD *)__int16 v57 = 2;
        *(_WORD *)&v57[4] = 2098;
        *(void *)int v58 = (char *)&v37 + 6;
        *(_WORD *)&v58[8] = 2160;
        uint64_t v59 = 1752392040;
        __int16 v60 = 1041;
        int v61 = 8;
        __int16 v62 = 2097;
        int v63 = &v38;
        __int16 v64 = 1024;
        unsigned int v65 = v29;
        __int16 v66 = 1024;
        int v67 = v6;
        __int16 v68 = 2082;
        int64_t v69 = v30;
        __int16 v70 = 2160;
        uint64_t v71 = 1752392040;
        __int16 v72 = 1041;
        int v73 = 6;
        __int16 v74 = 2097;
        __int16 v75 = &v41;
        __int16 v76 = 2160;
        uint64_t v77 = 1752392040;
        __int16 v78 = 1042;
        int v79 = 2;
        __int16 v80 = 2098;
        int v81 = (char *)&v41 + 6;
        __int16 v82 = 2160;
        uint64_t v83 = 1752392040;
        __int16 v84 = 1041;
        int v85 = 8;
        __int16 v86 = 2097;
        __int16 v87 = &v42;
        __int16 v88 = 1024;
        unsigned int v89 = bswap32(WORD1(v40)) >> 16;
        __int16 v24 = "%{public}s: sending %zd byte UDP response from {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%"
              "{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} port %d index"
              " %d to {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment"
              "}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}#%d";
        int v25 = v22;
        uint32_t v26 = 216;
        goto LABEL_55;
      }
      ssize_t v31 = sendmsg(*(_DWORD *)(a1 + 148), &v44, 0);
      BOOL v16 = v31 >= 0;
      if (v31 < 0)
      {
        uint64_t v32 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          unsigned int v33 = __error();
          size_t v34 = strerror(*v33);
          *(_DWORD *)buf = 136446466;
          uint64_t v46 = "ioloop_udp_send_message";
          __int16 v47 = 2080;
          uint64_t v48 = (uint64_t)v34;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "%{public}s: %s", buf, 0x16u);
        }
      }
      return v16;
    }
    return 0;
  }
  int v8 = dispatch_data_create(a3->iov_base, a3->iov_len, (dispatch_queue_t)ioloop_main_queue, 0);
  if (!v8)
  {
    uint64_t v17 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v46 = "ioloop_send_message_inner";
    __int16 v18 = "%{public}s: ioloop_send_message: no memory.";
LABEL_38:
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, v18, buf, 0xCu);
    return 0;
  }
  __int16 v9 = v8;
  LOWORD(buffer) = a3->iov_len;
  if (!(_WORD)buffer)
  {
    dispatch_release(v8);
    uint64_t v17 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v46 = "ioloop_send_message_inner";
    __int16 v18 = "%{public}s: zero length";
    goto LABEL_38;
  }
  if ((*(_WORD *)(a1 + 416) & 0x20) == 0) {
    goto LABEL_13;
  }
  LOWORD(buffer) = bswap32((unsigned __int16)buffer) >> 16;
  int v10 = dispatch_data_create(&buffer, 2uLL, (dispatch_queue_t)ioloop_main_queue, 0);
  if (!v10)
  {
    dispatch_release(v9);
    uint64_t v17 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v46 = "ioloop_send_message_inner";
    __int16 v18 = "%{public}s: no memory for new_data";
    goto LABEL_38;
  }
  int v11 = v10;
  dispatch_data_t concat = dispatch_data_create_concat(v10, v9);
  dispatch_release(v9);
  dispatch_release(v11);
  __int16 v9 = concat;
  if (!concat)
  {
    uint64_t v17 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v46 = "ioloop_send_message_inner";
    __int16 v18 = "%{public}s: no memory for combined";
    goto LABEL_38;
  }
LABEL_13:
  if (*(void *)(a1 + 48))
  {
    __int16 v13 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      __int16 v14 = *(const char **)(a1 + 192);
      if (!v14) {
        __int16 v14 = "<null>";
      }
      *(_DWORD *)buf = 136446723;
      uint64_t v46 = "ioloop_send_message_inner";
      __int16 v47 = 2160;
      uint64_t v48 = 1752392040;
      __int16 v49 = 2081;
      uint64_t v50 = (uint64_t)v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%{public}s: Dropping pending write on %{private, mask.hash}s", buf, 0x20u);
    }
  }
  *(void *)(a1 + 48) = v9;
  __int16 v15 = *(_WORD *)(a1 + 416);
  *(_WORD *)(a1 + 416) = v15 & 0xFFF7;
  if ((v15 & 4) != 0) {
    connection_write_now(a1);
  }
  return 1;
}

void connection_write_now(uint64_t a1)
{
  ++*(_DWORD *)(a1 + 36);
  uint64_t v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(_DWORD *)(a1 + 32);
    *(_DWORD *)buf = 136447490;
    __int16 v14 = "connection_write_now";
    __int16 v15 = 1024;
    int v16 = v3;
    __int16 v17 = 2048;
    uint64_t v18 = a1;
    __int16 v19 = 2080;
    __int16 v20 = "connection";
    __int16 v21 = 2080;
    uint64_t v22 = "macos-ioloop.c";
    __int16 v23 = 1024;
    int v24 = 564;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  int v4 = *(_DWORD *)(a1 + 32);
  if (v4)
  {
    int v5 = v4 + 1;
    *(_DWORD *)(a1 + 32) = v5;
    if (v5 >= 10001)
    {
      int v11 = v5;
      int v6 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136447490;
        __int16 v14 = "connection_write_now";
        __int16 v15 = 1024;
        int v16 = v11;
        __int16 v17 = 2048;
        uint64_t v18 = a1;
        __int16 v19 = 2080;
        __int16 v20 = "connection";
        __int16 v21 = 2080;
        uint64_t v22 = "macos-ioloop.c";
        __int16 v23 = 1024;
        int v24 = 564;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      }
      abort();
    }
  }
  else
  {
    ++comm_created;
    *(_DWORD *)(a1 + 32) = 1;
  }
  int v7 = *(NSObject **)a1;
  int v8 = *(NSObject **)(a1 + 48);
  if ((*(_WORD *)(a1 + 416) & 8) != 0) {
    __int16 v9 = &_nw_content_context_final_send;
  }
  else {
    __int16 v9 = &_nw_content_context_default_message;
  }
  int v10 = *v9;
  completion[0] = _NSConcreteStackBlock;
  completion[1] = 0x40000000;
  completion[2] = __connection_write_now_block_invoke;
  completion[3] = &__block_descriptor_tmp_47;
  completion[4] = a1;
  nw_connection_send(v7, v8, v10, 1, completion);
  dispatch_release(*(dispatch_object_t *)(a1 + 48));
  *(void *)(a1 + 48) = 0;
}

void __connection_write_now_block_invoke(uint64_t a1, NSObject *a2)
{
  if (a2)
  {
    int v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      int error_code = nw_error_get_error_code(a2);
      int v17 = 136446466;
      uint64_t v18 = "connection_write_now_block_invoke";
      __int16 v19 = 2082;
      *(void *)__int16 v20 = strerror(error_code);
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%{public}s: ioloop_send_message: write failed: %{public}s", (uint8_t *)&v17, 0x16u);
    }
    connection_cancel_(*(void *)(a1 + 32), **(NSObject ***)(a1 + 32), 573);
  }
  uint64_t v6 = *(void *)(a1 + 32);
  int v7 = *(_DWORD *)(v6 + 36);
  BOOL v8 = __OFSUB__(v7, 1);
  int v9 = v7 - 1;
  if (v9 < 0 != v8)
  {
    int v10 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      int v17 = 136446210;
      uint64_t v18 = "connection_write_now_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%{public}s: ioloop_send_message: write callback reached with no writes marked pending.", (uint8_t *)&v17, 0xCu);
      uint64_t v6 = *(void *)(a1 + 32);
      if (!v6) {
        return;
      }
    }
  }
  else
  {
    *(_DWORD *)(v6 + 36) = v9;
  }
  int v11 = *(_DWORD *)(v6 + 32);
  if (!v11)
  {
    uint64_t v14 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_23;
    }
    int v17 = 136447490;
    uint64_t v18 = "connection_write_now_block_invoke";
    __int16 v19 = 1024;
    *(_DWORD *)__int16 v20 = 0;
    *(_WORD *)&v20[4] = 2048;
    *(void *)&v20[6] = v6;
    *(_WORD *)&unsigned char v20[14] = 2080;
    *(void *)&v20[16] = "connection";
    *(_WORD *)&v20[24] = 2080;
    *(void *)&v20[26] = "macos-ioloop.c";
    __int16 v21 = 1024;
    int v22 = 580;
    __int16 v15 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    int v16 = v14;
    goto LABEL_22;
  }
  __int16 v12 = global_os_log;
  if (v11 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_23;
    }
    int v17 = 136447490;
    uint64_t v18 = "connection_write_now_block_invoke";
    __int16 v19 = 1024;
    *(_DWORD *)__int16 v20 = v11;
    *(_WORD *)&v20[4] = 2048;
    *(void *)&v20[6] = v6;
    *(_WORD *)&unsigned char v20[14] = 2080;
    *(void *)&v20[16] = "connection";
    *(_WORD *)&v20[24] = 2080;
    *(void *)&v20[26] = "macos-ioloop.c";
    __int16 v21 = 1024;
    int v22 = 580;
    __int16 v15 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    int v16 = v12;
LABEL_22:
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_FAULT, v15, (uint8_t *)&v17, 0x36u);
LABEL_23:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v17 = 136447490;
    uint64_t v18 = "connection_write_now_block_invoke";
    __int16 v19 = 1024;
    *(_DWORD *)__int16 v20 = v11;
    *(_WORD *)&v20[4] = 2048;
    *(void *)&v20[6] = v6;
    *(_WORD *)&unsigned char v20[14] = 2080;
    *(void *)&v20[16] = "connection";
    *(_WORD *)&v20[24] = 2080;
    *(void *)&v20[26] = "macos-ioloop.c";
    __int16 v21 = 1024;
    int v22 = 580;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v17, 0x36u);
    uint64_t v6 = *(void *)(a1 + 32);
    int v11 = *(_DWORD *)(v6 + 32);
  }
  *(_DWORD *)(v6 + 32) = v11 - 1;
  if (v11 == 1)
  {
    __int16 v13 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = 136447234;
      uint64_t v18 = "connection_write_now_block_invoke";
      __int16 v19 = 2048;
      *(void *)__int16 v20 = v6;
      *(_WORD *)&v20[8] = 2080;
      *(void *)&v20[10] = "connection";
      *(_WORD *)&v20[18] = 2080;
      *(void *)&v20[20] = "macos-ioloop.c";
      *(_WORD *)&v20[28] = 1024;
      *(_DWORD *)&v20[30] = 580;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v17, 0x30u);
      uint64_t v6 = *(void *)(a1 + 32);
    }
    ++comm_finalized;
    comm_finalize(v6);
  }
}

void ioloop_listener_permitted_interface_list_set(uint64_t a1, int *a2)
{
  int v4 = *(int **)(a1 + 408);
  if (v4) {
    ifpermit_list_release_(v4, 992);
  }
  *(void *)(a1 + 408) = a2;

  ifpermit_list_retain_(a2, 995);
}

void __ioloop_listener_cancel_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(void (**)(void, void))(v2 + 248);
  if (v3)
  {
    v3(*(void *)(a1 + 32), *(void *)(v2 + 200));
    uint64_t v2 = *(void *)(a1 + 32);
    if (!v2) {
      return;
    }
  }
  int v4 = *(_DWORD *)(v2 + 32);
  if (!v4)
  {
    uint64_t v7 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_17;
    }
    int v10 = 136447490;
    int v11 = "ioloop_listener_cancel_block_invoke";
    __int16 v12 = 1024;
    *(_DWORD *)__int16 v13 = 0;
    *(_WORD *)&v13[4] = 2048;
    *(void *)&v13[6] = v2;
    *(_WORD *)&v13[14] = 2080;
    *(void *)&v13[16] = "connection";
    *(_WORD *)&v13[24] = 2080;
    *(void *)&v13[26] = "macos-ioloop.c";
    __int16 v14 = 1024;
    int v15 = 1181;
    BOOL v8 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    int v9 = v7;
    goto LABEL_16;
  }
  int v5 = global_os_log;
  if (v4 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_17;
    }
    int v10 = 136447490;
    int v11 = "ioloop_listener_cancel_block_invoke";
    __int16 v12 = 1024;
    *(_DWORD *)__int16 v13 = v4;
    *(_WORD *)&v13[4] = 2048;
    *(void *)&v13[6] = v2;
    *(_WORD *)&v13[14] = 2080;
    *(void *)&v13[16] = "connection";
    *(_WORD *)&v13[24] = 2080;
    *(void *)&v13[26] = "macos-ioloop.c";
    __int16 v14 = 1024;
    int v15 = 1181;
    BOOL v8 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    int v9 = v5;
LABEL_16:
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, v8, (uint8_t *)&v10, 0x36u);
LABEL_17:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v10 = 136447490;
    int v11 = "ioloop_listener_cancel_block_invoke";
    __int16 v12 = 1024;
    *(_DWORD *)__int16 v13 = v4;
    *(_WORD *)&v13[4] = 2048;
    *(void *)&v13[6] = v2;
    *(_WORD *)&v13[14] = 2080;
    *(void *)&v13[16] = "connection";
    *(_WORD *)&v13[24] = 2080;
    *(void *)&v13[26] = "macos-ioloop.c";
    __int16 v14 = 1024;
    int v15 = 1181;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v10, 0x36u);
    uint64_t v2 = *(void *)(a1 + 32);
    int v4 = *(_DWORD *)(v2 + 32);
  }
  *(_DWORD *)(v2 + 32) = v4 - 1;
  if (v4 == 1)
  {
    uint64_t v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v10 = 136447234;
      int v11 = "ioloop_listener_cancel_block_invoke";
      __int16 v12 = 2048;
      *(void *)__int16 v13 = v2;
      *(_WORD *)&v13[8] = 2080;
      *(void *)&v13[10] = "connection";
      *(_WORD *)&v13[18] = 2080;
      *(void *)&v13[20] = "macos-ioloop.c";
      *(_WORD *)&v13[28] = 1024;
      *(_DWORD *)&v13[30] = 1181;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v10, 0x30u);
      uint64_t v2 = *(void *)(a1 + 32);
    }
    ++listener_finalized;
    listener_finalize((void *)v2);
  }
}

_DWORD *ioloop_listener_create(int a1, int a2, int a3, uint64_t a4, const char *a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, int a10, uint64_t a11)
{
  if (a4)
  {
    int v17 = *(unsigned __int8 *)(a4 + 1);
    unsigned int v18 = bswap32(*(unsigned __int16 *)(a4 + 2)) >> 16;
  }
  else
  {
    int v17 = 0;
    unsigned int v18 = 0;
  }
  if (!a6)
  {
    uint64_t v28 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v156 = "ioloop_listener_create";
    unsigned int v29 = "%{public}s: ioloop_setup: no datagram callback provided.";
    uint64_t v30 = v28;
    uint32_t v31 = 12;
LABEL_14:
    _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_ERROR, v29, buf, v31);
    return 0;
  }
  snprintf(__str, 0xAuLL, "%d", v18);
  __int16 v19 = malloc_type_calloc(1uLL, 0x1A8uLL, 0x10B00402743B0D3uLL);
  if (!v19)
  {
    if (a4)
    {
      if (v17 == 30)
      {
        uint64_t v58 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
          return 0;
        }
        int v59 = *(unsigned __int8 *)(a4 + 8);
        if ((v59 & 0xFE) == 0xFC)
        {
          __int16 v60 = "ULA: ";
        }
        else if (v59 == 254 && (*(unsigned char *)(a4 + 9) & 0xC0) == 0x80)
        {
          __int16 v60 = "LUA: ";
        }
        else if ((v59 & 0xE0) == 0x20)
        {
          __int16 v60 = "GUA: ";
        }
        else
        {
          __int16 v60 = "";
        }
        *(_DWORD *)buf = 136449027;
        __int16 v156 = "ioloop_listener_create";
        __int16 v157 = 2082;
        *(void *)__int16 v158 = v60;
        *(_WORD *)&v158[8] = 2160;
        *(void *)&v158[10] = 1752392040;
        *(_WORD *)&v158[18] = 1041;
        *(_DWORD *)&v158[20] = 6;
        *(_WORD *)&v158[24] = 2097;
        *(void *)&v158[26] = a4 + 8;
        *(_WORD *)&v158[34] = 2160;
        *(void *)&v158[36] = 1752392040;
        __int16 v159 = 1042;
        int v160 = 2;
        __int16 v161 = 2098;
        __int16 v162 = (char *)(a4 + 14);
        __int16 v163 = 2160;
        uint64_t v164 = 1752392040;
        __int16 v165 = 1041;
        int v166 = 8;
        __int16 v167 = 2097;
        v168 = (_DWORD *)(a4 + 16);
        __int16 v169 = 1024;
        unsigned int v170 = v18;
        unsigned int v29 = "%{public}s: No memory for listener on {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, "
              "mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}#%d";
        uint64_t v30 = v58;
        uint32_t v31 = 106;
      }
      else if (v17 == 2)
      {
        uint64_t v32 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
          return 0;
        }
        *(_DWORD *)buf = 136447235;
        __int16 v156 = "ioloop_listener_create";
        __int16 v157 = 2160;
        *(void *)__int16 v158 = 1752392040;
        *(_WORD *)&v158[8] = 1041;
        *(_DWORD *)&v158[10] = 4;
        *(_WORD *)&v158[14] = 2097;
        *(void *)&v158[16] = a4 + 4;
        *(_WORD *)&v158[24] = 1024;
        *(_DWORD *)&v158[26] = v18;
        unsigned int v29 = "%{public}s: No memory for listener on %{private, mask.hash, network:in_addr}.4P#%d";
        uint64_t v30 = v32;
        uint32_t v31 = 44;
      }
      else
      {
        uint64_t v61 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
          return 0;
        }
        *(_DWORD *)buf = 136446722;
        __int16 v156 = "ioloop_listener_create";
        __int16 v157 = 1024;
        *(_DWORD *)__int16 v158 = v17;
        *(_WORD *)&v158[4] = 1024;
        *(_DWORD *)&v158[6] = v18;
        unsigned int v29 = "%{public}s: No memory for listener on <family address other than AF_INET or AF_INET6: %d>#%d";
        uint64_t v30 = v61;
        uint32_t v31 = 24;
      }
    }
    else
    {
      uint64_t v44 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
        return 0;
      }
      *(_DWORD *)buf = 136446466;
      __int16 v156 = "ioloop_listener_create";
      __int16 v157 = 1024;
      *(_DWORD *)__int16 v158 = v18;
      unsigned int v29 = "%{public}s: No memory for listener on <NULL>#%d";
      uint64_t v30 = v44;
      uint32_t v31 = 18;
    }
    goto LABEL_14;
  }
  __int16 v20 = v19;
  unsigned int v136 = v18;
  v19[45] = ++cur_connection_serial;
  __int16 v21 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v22 = v20[8];
    *(_DWORD *)buf = 136447490;
    __int16 v156 = "ioloop_listener_create";
    __int16 v157 = 1024;
    *(_DWORD *)__int16 v158 = v22;
    *(_WORD *)&v158[4] = 2048;
    *(void *)&v158[6] = v20;
    *(_WORD *)&v158[14] = 2080;
    *(void *)&v158[16] = "listener";
    *(_WORD *)&v158[24] = 2080;
    *(void *)&v158[26] = "macos-ioloop.c";
    *(_WORD *)&v158[34] = 1024;
    *(_DWORD *)&v158[36] = 1614;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  int v23 = v20[8];
  if (v23)
  {
    int v24 = v23 + 1;
    v20[8] = v23 + 1;
    unsigned int v25 = v136;
    if (v23 + 1 >= 10001)
    {
      uint32_t v26 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_271;
      }
      *(_DWORD *)buf = 136447490;
      __int16 v156 = "ioloop_listener_create";
      __int16 v157 = 1024;
      *(_DWORD *)__int16 v158 = v24;
      *(_WORD *)&v158[4] = 2048;
      *(void *)&v158[6] = v20;
      *(_WORD *)&v158[14] = 2080;
      *(void *)&v158[16] = "listener";
      *(_WORD *)&v158[24] = 2080;
      *(void *)&v158[26] = "macos-ioloop.c";
      *(_WORD *)&v158[34] = 1024;
      *(_DWORD *)&v158[36] = 1614;
      uint64_t v27 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_270;
    }
  }
  else
  {
    ++listener_created;
    int v24 = 1;
    v20[8] = 1;
    unsigned int v25 = v136;
  }
  unsigned int v33 = strdup(a5);
  *((void *)v20 + 24) = v33;
  if (!v33)
  {
    uint64_t v38 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v156 = "ioloop_listener_create";
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "%{public}s: no memory for listener name.", buf, 0xCu);
      int v24 = v20[8];
    }
    if (!v24)
    {
      uint32_t v26 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_271;
      }
      *(_DWORD *)buf = 136447490;
      __int16 v156 = "ioloop_listener_create";
      __int16 v157 = 1024;
      *(_DWORD *)__int16 v158 = 0;
      *(_WORD *)&v158[4] = 2048;
      *(void *)&v158[6] = v20;
      *(_WORD *)&v158[14] = 2080;
      *(void *)&v158[16] = "listener";
      *(_WORD *)&v158[24] = 2080;
      *(void *)&v158[26] = "macos-ioloop.c";
      *(_WORD *)&v158[34] = 1024;
      *(_DWORD *)&v158[36] = 1618;
      uint64_t v27 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_270;
    }
    uint32_t v26 = global_os_log;
    if (v24 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_271;
      }
      *(_DWORD *)buf = 136447490;
      __int16 v156 = "ioloop_listener_create";
      __int16 v157 = 1024;
      *(_DWORD *)__int16 v158 = v24;
      *(_WORD *)&v158[4] = 2048;
      *(void *)&v158[6] = v20;
      *(_WORD *)&v158[14] = 2080;
      *(void *)&v158[16] = "listener";
      *(_WORD *)&v158[24] = 2080;
      *(void *)&v158[26] = "macos-ioloop.c";
      *(_WORD *)&v158[34] = 1024;
      *(_DWORD *)&v158[36] = 1618;
      uint64_t v27 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_270;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447490;
      __int16 v156 = "ioloop_listener_create";
      __int16 v157 = 1024;
      *(_DWORD *)__int16 v158 = v24;
      *(_WORD *)&v158[4] = 2048;
      *(void *)&v158[6] = v20;
      *(_WORD *)&v158[14] = 2080;
      *(void *)&v158[16] = "listener";
      *(_WORD *)&v158[24] = 2080;
      *(void *)&v158[26] = "macos-ioloop.c";
      *(_WORD *)&v158[34] = 1024;
      *(_DWORD *)&v158[36] = 1618;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      int v24 = v20[8];
    }
    v20[8] = v24 - 1;
    if (v24 != 1) {
      return 0;
    }
    int v39 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_230;
    }
    *(_DWORD *)buf = 136447234;
    __int16 v156 = "ioloop_listener_create";
    __int16 v157 = 2048;
    *(void *)__int16 v158 = v20;
    *(_WORD *)&v158[8] = 2080;
    *(void *)&v158[10] = "listener";
    *(_WORD *)&v158[18] = 2080;
    *(void *)&v158[20] = "macos-ioloop.c";
    *(_WORD *)&v158[28] = 1024;
    *(_DWORD *)&v158[30] = 1618;
    goto LABEL_229;
  }
  *((void *)v20 + 32) = a8;
  *((void *)v20 + 25) = a11;
  if (a1) {
    __int16 v34 = 288;
  }
  else {
    __int16 v34 = 256;
  }
  *((_WORD *)v20 + 208) = v34 | v20[104] & 0xFEDF;
  if ((a1 & 1) == 0)
  {
    if (!a3) {
      a5 = 0;
    }
    int v148 = a10;
    if (!a4 || (unsigned __int8 v40 = *(unsigned char *)(a4 + 1), (v41 = v40) == 0))
    {
      unsigned __int8 v40 = 0;
      unsigned __int8 v41 = 30;
    }
    int v147 = 1;
    *(void *)&v144.sa_len = 0;
    *(void *)&v144.sa_data[6] = 0;
    int v146 = 0;
    uint64_t v145 = 0;
    socklen_t v143 = 0;
    uint64_t v42 = v20 + 72;
    int v43 = v41;
    *((unsigned char *)v20 + 289) = v41;
    if (v41 == 2)
    {
      *uint64_t v42 = 16;
    }
    else
    {
      *uint64_t v42 = 28;
      if (v41 == 30)
      {
        int v45 = 1;
        goto LABEL_52;
      }
    }
    int v45 = 0;
LABEL_52:
    unsigned int v46 = __rev16(v25);
    *((_WORD *)v20 + 145) = v46;
    v20[37] = -1;
    if (!a5)
    {
LABEL_58:
      int v52 = socket(v43, 2, 17);
      v20[37] = v52;
      if (v52 < 0)
      {
        uint64_t v54 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          int v63 = __error();
          __int16 v64 = strerror(*v63);
          *(_DWORD *)buf = 136446466;
          __int16 v156 = "ioloop_udp_listener_setup";
          __int16 v157 = 2080;
          *(void *)__int16 v158 = v64;
          __int16 v57 = "%{public}s: Can't get socket: %s";
          goto LABEL_220;
        }
LABEL_222:
        close(v20[37]);
        v20[37] = -1;
        int v130 = v20[8];
        if (!v130)
        {
          uint32_t v26 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
            goto LABEL_271;
          }
          *(_DWORD *)buf = 136447490;
          __int16 v156 = "ioloop_udp_listener_setup";
          __int16 v157 = 1024;
          *(_DWORD *)__int16 v158 = 0;
          *(_WORD *)&v158[4] = 2048;
          *(void *)&v158[6] = v20;
          *(_WORD *)&v158[14] = 2080;
          *(void *)&v158[16] = "listener";
          *(_WORD *)&v158[24] = 2080;
          *(void *)&v158[26] = "macos-ioloop.c";
          *(_WORD *)&v158[34] = 1024;
          *(_DWORD *)&v158[36] = 1479;
          uint64_t v27 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
          goto LABEL_270;
        }
        uint32_t v26 = global_os_log;
        if (v130 >= 10001)
        {
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
            goto LABEL_271;
          }
          *(_DWORD *)buf = 136447490;
          __int16 v156 = "ioloop_udp_listener_setup";
          __int16 v157 = 1024;
          *(_DWORD *)__int16 v158 = v130;
          *(_WORD *)&v158[4] = 2048;
          *(void *)&v158[6] = v20;
          *(_WORD *)&v158[14] = 2080;
          *(void *)&v158[16] = "listener";
          *(_WORD *)&v158[24] = 2080;
          *(void *)&v158[26] = "macos-ioloop.c";
          *(_WORD *)&v158[34] = 1024;
          *(_DWORD *)&v158[36] = 1479;
          uint64_t v27 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
          goto LABEL_270;
        }
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447490;
          __int16 v156 = "ioloop_udp_listener_setup";
          __int16 v157 = 1024;
          *(_DWORD *)__int16 v158 = v130;
          *(_WORD *)&v158[4] = 2048;
          *(void *)&v158[6] = v20;
          *(_WORD *)&v158[14] = 2080;
          *(void *)&v158[16] = "listener";
          *(_WORD *)&v158[24] = 2080;
          *(void *)&v158[26] = "macos-ioloop.c";
          *(_WORD *)&v158[34] = 1024;
          *(_DWORD *)&v158[36] = 1479;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          int v130 = v20[8];
        }
        v20[8] = v130 - 1;
        if (v130 != 1) {
          return 0;
        }
        int v39 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_230;
        }
        *(_DWORD *)buf = 136447234;
        __int16 v156 = "ioloop_udp_listener_setup";
        __int16 v157 = 2048;
        *(void *)__int16 v158 = v20;
        *(_WORD *)&v158[8] = 2080;
        *(void *)&v158[10] = "listener";
        *(_WORD *)&v158[18] = 2080;
        *(void *)&v158[20] = "macos-ioloop.c";
        *(_WORD *)&v158[28] = 1024;
        *(_DWORD *)&v158[30] = 1479;
        goto LABEL_229;
      }
      if (setsockopt(v52, 0xFFFF, 4, &v147, 4u) < 0)
      {
        uint64_t v54 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          __int16 v66 = __error();
          int v67 = strerror(*v66);
          *(_DWORD *)buf = 136446466;
          __int16 v156 = "ioloop_udp_listener_setup";
          __int16 v157 = 2080;
          *(void *)__int16 v158 = v67;
          __int16 v57 = "%{public}s: SO_REUSEADDR failed: %s";
          goto LABEL_220;
        }
        goto LABEL_222;
      }
      if (setsockopt(v20[37], 0xFFFF, 512, &v147, 4u) < 0)
      {
        uint64_t v54 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          __int16 v82 = __error();
          uint64_t v83 = strerror(*v82);
          *(_DWORD *)buf = 136446466;
          __int16 v156 = "ioloop_udp_listener_setup";
          __int16 v157 = 2080;
          *(void *)__int16 v158 = v83;
          __int16 v57 = "%{public}s: SO_REUSEPORT failed: %s";
          goto LABEL_220;
        }
        goto LABEL_222;
      }
      int v140 = 160;
      int v53 = v20[37];
      if (v45)
      {
        if (setsockopt(v53, 41, 36, &v140, 4u) < 0)
        {
          uint64_t v54 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          {
            uint64_t v55 = __error();
            __int16 v56 = strerror(*v55);
            *(_DWORD *)buf = 136446466;
            __int16 v156 = "ioloop_udp_listener_setup";
            __int16 v157 = 2080;
            *(void *)__int16 v158 = v56;
            __int16 v57 = "%{public}s: IPV6_TCLASS failed: %s";
LABEL_220:
            __int16 v119 = v54;
            uint32_t v120 = 22;
            goto LABEL_221;
          }
          goto LABEL_222;
        }
      }
      else if (setsockopt(v53, 0, 3, &v140, 4u) < 0)
      {
        uint64_t v54 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          int v95 = __error();
          int v96 = strerror(*v95);
          *(_DWORD *)buf = 136446466;
          __int16 v156 = "ioloop_udp_listener_setup";
          __int16 v157 = 2080;
          *(void *)__int16 v158 = v96;
          __int16 v57 = "%{public}s: IP_TOS failed: %s";
          goto LABEL_220;
        }
        goto LABEL_222;
      }
      if (v40 == 30)
      {
        int v86 = setsockopt(v20[37], 41, 27, &v147, 4u);
        __int16 v87 = global_os_log;
        BOOL v88 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
        if (v86 < 0)
        {
          if (v88)
          {
            int v97 = *((unsigned __int8 *)v20 + 296);
            if ((v97 & 0xFE) == 0xFC)
            {
              xpc_object_t v98 = "ULA: ";
            }
            else if (v97 == 254 && (*((unsigned char *)v20 + 297) & 0xC0) == 0x80)
            {
              xpc_object_t v98 = "LUA: ";
            }
            else if ((v97 & 0xE0) == 0x20)
            {
              xpc_object_t v98 = "GUA: ";
            }
            else
            {
              xpc_object_t v98 = "";
            }
            *(_DWORD *)buf = 136448771;
            __int16 v156 = "ioloop_udp_listener_setup";
            __int16 v157 = 2082;
            *(void *)__int16 v158 = v98;
            *(_WORD *)&v158[8] = 2160;
            *(void *)&v158[10] = 1752392040;
            *(_WORD *)&v158[18] = 1041;
            *(_DWORD *)&v158[20] = 6;
            *(_WORD *)&v158[24] = 2097;
            *(void *)&v158[26] = v20 + 74;
            *(_WORD *)&v158[34] = 2160;
            *(void *)&v158[36] = 1752392040;
            __int16 v159 = 1042;
            int v160 = 2;
            __int16 v161 = 2098;
            __int16 v162 = (char *)v20 + 302;
            __int16 v163 = 2160;
            uint64_t v164 = 1752392040;
            __int16 v165 = 1041;
            int v166 = 8;
            __int16 v167 = 2097;
            v168 = v20 + 76;
            __int16 v57 = "%{public}s: Unable to set IPv6-only flag on UDP socket for {%{public}s%{private, mask.hash, srp:in6_ad"
                  "dr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}";
            __int16 v119 = v87;
            uint32_t v120 = 100;
            goto LABEL_221;
          }
          goto LABEL_222;
        }
        unsigned int v25 = v136;
        if (v88)
        {
          int v89 = *((unsigned __int8 *)v20 + 296);
          if ((v89 & 0xFE) == 0xFC)
          {
            int v90 = "ULA: ";
          }
          else if (v89 == 254 && (*((unsigned char *)v20 + 297) & 0xC0) == 0x80)
          {
            int v90 = "LUA: ";
          }
          else if ((v89 & 0xE0) == 0x20)
          {
            int v90 = "GUA: ";
          }
          else
          {
            int v90 = "";
          }
          *(_DWORD *)buf = 136448771;
          __int16 v156 = "ioloop_udp_listener_setup";
          __int16 v157 = 2082;
          *(void *)__int16 v158 = v90;
          *(_WORD *)&v158[8] = 2160;
          *(void *)&v158[10] = 1752392040;
          *(_WORD *)&v158[18] = 1041;
          *(_DWORD *)&v158[20] = 6;
          *(_WORD *)&v158[24] = 2097;
          *(void *)&v158[26] = v20 + 74;
          *(_WORD *)&v158[34] = 2160;
          *(void *)&v158[36] = 1752392040;
          __int16 v159 = 1042;
          int v160 = 2;
          __int16 v161 = 2098;
          __int16 v162 = (char *)v20 + 302;
          __int16 v163 = 2160;
          uint64_t v164 = 1752392040;
          __int16 v165 = 1041;
          int v166 = 8;
          __int16 v167 = 2097;
          v168 = v20 + 76;
          _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_ERROR, "%{public}s: Successfully set IPv6-only flag on UDP socket for {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}", buf, 0x64u);
        }
      }
      socklen_t v99 = *((unsigned __int8 *)v20 + 288);
      socklen_t v143 = v99;
      if (bind(v20[37], (const sockaddr *)v20 + 18, v99) < 0)
      {
        uint64_t v115 = global_os_log;
        BOOL v116 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
        if (v40 != 2)
        {
          if (v116)
          {
            int v124 = *((unsigned __int8 *)v20 + 296);
            if ((v124 & 0xFE) == 0xFC)
            {
              v125 = "ULA: ";
            }
            else if (v124 == 254 && (*((unsigned char *)v20 + 297) & 0xC0) == 0x80)
            {
              v125 = "LUA: ";
            }
            else if ((v124 & 0xE0) == 0x20)
            {
              v125 = "GUA: ";
            }
            else
            {
              v125 = "";
            }
            int v132 = __error();
            int v133 = strerror(*v132);
            *(_DWORD *)buf = 136449283;
            __int16 v156 = "ioloop_udp_listener_setup";
            __int16 v157 = 2082;
            *(void *)__int16 v158 = v125;
            *(_WORD *)&v158[8] = 2160;
            *(void *)&v158[10] = 1752392040;
            *(_WORD *)&v158[18] = 1041;
            *(_DWORD *)&v158[20] = 6;
            *(_WORD *)&v158[24] = 2097;
            *(void *)&v158[26] = v20 + 74;
            *(_WORD *)&v158[34] = 2160;
            *(void *)&v158[36] = 1752392040;
            __int16 v159 = 1042;
            int v160 = 2;
            __int16 v161 = 2098;
            __int16 v162 = (char *)v20 + 302;
            __int16 v163 = 2160;
            uint64_t v164 = 1752392040;
            __int16 v165 = 1041;
            int v166 = 8;
            __int16 v167 = 2097;
            v168 = v20 + 76;
            __int16 v169 = 1024;
            unsigned int v170 = v46;
            __int16 v171 = 2080;
            v172 = v133;
            __int16 v57 = "%{public}s: Can't bind to {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.has"
                  "h, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}#%d: %s";
            __int16 v119 = v115;
            uint32_t v120 = 116;
            goto LABEL_221;
          }
          goto LABEL_222;
        }
        if (!v116) {
          goto LABEL_222;
        }
        int v117 = __error();
        int v118 = strerror(*v117);
        *(_DWORD *)buf = 136447491;
        __int16 v156 = "ioloop_udp_listener_setup";
        __int16 v157 = 2160;
        *(void *)__int16 v158 = 1752392040;
        *(_WORD *)&v158[8] = 1041;
        *(_DWORD *)&v158[10] = 4;
        *(_WORD *)&v158[14] = 2097;
        *(void *)&v158[16] = v20 + 73;
        *(_WORD *)&v158[24] = 1024;
        *(_DWORD *)&v158[26] = v46;
        *(_WORD *)&v158[30] = 2080;
        *(void *)&v158[32] = v118;
        __int16 v57 = "%{public}s: Can't bind to %{private, mask.hash, network:in_addr}.4P#%d: %s";
        __int16 v119 = v115;
        uint32_t v120 = 54;
        goto LABEL_221;
      }
      int v94 = v20[37];
LABEL_170:
      if (fcntl(v94, 4, 4) < 0)
      {
        uint64_t v108 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
          goto LABEL_222;
        }
        uint64_t v109 = *((void *)v20 + 24);
        uint64_t v110 = __error();
        xpc_object_t v111 = strerror(*v110);
        *(_DWORD *)buf = 136446722;
        __int16 v156 = "ioloop_udp_listener_setup";
        __int16 v157 = 2080;
        *(void *)__int16 v158 = v109;
        *(_WORD *)&v158[8] = 2080;
        *(void *)&v158[10] = v111;
        __int16 v57 = "%{public}s: %s: Can't set O_NONBLOCK: %s";
      }
      else
      {
        if (a5 || !v25)
        {
          socklen_t v143 = 28;
          if (getsockname(v20[37], &v144, &v143) < 0)
          {
            uint64_t v54 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            {
              int v128 = __error();
              int v129 = strerror(*v128);
              *(_DWORD *)buf = 136446466;
              __int16 v156 = "ioloop_udp_listener_setup";
              __int16 v157 = 2080;
              *(void *)__int16 v158 = v129;
              __int16 v57 = "%{public}s: getsockname: %s";
              goto LABEL_220;
            }
            goto LABEL_222;
          }
          unsigned int v112 = bswap32(*(unsigned __int16 *)v144.sa_data);
          unsigned int v113 = HIWORD(v112);
          *((_WORD *)v20 + 80) = HIWORD(v112);
          if (a5)
          {
            if (v113 != v136)
            {
              uint64_t v114 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446722;
                __int16 v156 = "ioloop_udp_listener_setup";
                __int16 v157 = 1024;
                *(_DWORD *)__int16 v158 = v136;
                *(_WORD *)&v158[4] = 1024;
                *(_DWORD *)&v158[6] = v113;
                _os_log_impl((void *)&_mh_execute_header, v114, OS_LOG_TYPE_ERROR, "%{public}s: launchd port mismatch: %u %u", buf, 0x18u);
              }
            }
          }
        }
        else
        {
          *((_WORD *)v20 + 80) = v25;
        }
        int v100 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v101 = *((unsigned __int16 *)v20 + 80);
          *(_DWORD *)buf = 136446466;
          __int16 v156 = "ioloop_udp_listener_setup";
          __int16 v157 = 1024;
          *(_DWORD *)__int16 v158 = v101;
          _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_DEFAULT, "%{public}s: port is %d", buf, 0x12u);
        }
        if (v148)
        {
          setsockopt(v20[37], 0, 25, &v148, 4u);
          setsockopt(v20[37], 41, 125, &v148, 4u);
        }
        if (v40 == 2) {
          int v102 = 0;
        }
        else {
          int v102 = 41;
        }
        if (v40 == 2) {
          int v103 = 26;
        }
        else {
          int v103 = 61;
        }
        if ((setsockopt(v20[37], v102, v103, &v147, 4u) & 0x80000000) == 0)
        {
          ioloop_add_reader(v20 + 14);
          v104 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v105 = v20[8];
            *(_DWORD *)buf = 136447490;
            __int16 v156 = "ioloop_udp_listener_setup";
            __int16 v157 = 1024;
            *(_DWORD *)__int16 v158 = v105;
            *(_WORD *)&v158[4] = 2048;
            *(void *)&v158[6] = v20;
            *(_WORD *)&v158[14] = 2080;
            *(void *)&v158[16] = "listener";
            *(_WORD *)&v158[24] = 2080;
            *(void *)&v158[26] = "macos-ioloop.c";
            *(_WORD *)&v158[34] = 1024;
            *(_DWORD *)&v158[36] = 1518;
            _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          }
          int v106 = v20[8];
          if (v106)
          {
            int v107 = v106 + 1;
            v20[8] = v106 + 1;
            if (v106 + 1 >= 10001)
            {
              uint32_t v26 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                goto LABEL_271;
              }
              *(_DWORD *)buf = 136447490;
              __int16 v156 = "ioloop_udp_listener_setup";
              __int16 v157 = 1024;
              *(_DWORD *)__int16 v158 = v107;
              *(_WORD *)&v158[4] = 2048;
              *(void *)&v158[6] = v20;
              *(_WORD *)&v158[14] = 2080;
              *(void *)&v158[16] = "listener";
              *(_WORD *)&v158[24] = 2080;
              *(void *)&v158[26] = "macos-ioloop.c";
              *(_WORD *)&v158[34] = 1024;
              *(_DWORD *)&v158[36] = 1518;
              uint64_t v27 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
              goto LABEL_270;
            }
          }
          else
          {
            ++listener_created;
            int v107 = 1;
            v20[8] = 1;
          }
          *((unsigned char *)v20 + 144) = 1;
          *((void *)v20 + 13) = ioloop_listener_context_release;
          *((void *)v20 + 14) = v20;
          if (*((void *)v20 + 32))
          {
            v126 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136447490;
              __int16 v156 = "ioloop_udp_listener_setup";
              __int16 v157 = 1024;
              *(_DWORD *)__int16 v158 = v107;
              *(_WORD *)&v158[4] = 2048;
              *(void *)&v158[6] = v20;
              *(_WORD *)&v158[14] = 2080;
              *(void *)&v158[16] = "listener";
              *(_WORD *)&v158[24] = 2080;
              *(void *)&v158[26] = "macos-ioloop.c";
              *(_WORD *)&v158[34] = 1024;
              *(_DWORD *)&v158[36] = 1525;
              _os_log_impl((void *)&_mh_execute_header, v126, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
              int v107 = v20[8];
            }
            if (v107)
            {
              int v127 = v107 + 1;
              v20[8] = v127;
              if (v127 >= 10001)
              {
                uint32_t v26 = global_os_log;
                if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                  goto LABEL_271;
                }
                *(_DWORD *)buf = 136447490;
                __int16 v156 = "ioloop_udp_listener_setup";
                __int16 v157 = 1024;
                *(_DWORD *)__int16 v158 = v127;
                *(_WORD *)&v158[4] = 2048;
                *(void *)&v158[6] = v20;
                *(_WORD *)&v158[14] = 2080;
                *(void *)&v158[16] = "listener";
                *(_WORD *)&v158[24] = 2080;
                *(void *)&v158[26] = "macos-ioloop.c";
                *(_WORD *)&v158[34] = 1024;
                *(_DWORD *)&v158[36] = 1525;
                uint64_t v27 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
                goto LABEL_270;
              }
            }
            else
            {
              ++listener_created;
              v20[8] = 1;
            }
            *(void *)hostname = _NSConcreteStackBlock;
            uint64_t v150 = 0x40000000;
            v151 = __ioloop_udp_listener_setup_block_invoke;
            __int16 v152 = &__block_descriptor_tmp_50;
            v153 = v20;
            dispatch_async((dispatch_queue_t)ioloop_main_queue, hostname);
          }
          *((void *)v20 + 26) = a6;
          *((void *)v20 + 30) = 0;
          *((void *)v20 + 31) = a7;
          *((void *)v20 + 28) = 0;
          return v20;
        }
        uint64_t v108 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
          goto LABEL_222;
        }
        if (v40 == 2) {
          __int16 v121 = "IP_PKTINFO";
        }
        else {
          __int16 v121 = "IPV6_RECVPKTINFO";
        }
        uint64_t v122 = __error();
        int v123 = strerror(*v122);
        *(_DWORD *)buf = 136446722;
        __int16 v156 = "ioloop_udp_listener_setup";
        __int16 v157 = 2080;
        *(void *)__int16 v158 = v121;
        *(_WORD *)&v158[8] = 2080;
        *(void *)&v158[10] = v123;
        __int16 v57 = "%{public}s: Can't set %s: %s.";
      }
      __int16 v119 = v108;
      uint32_t v120 = 32;
LABEL_221:
      _os_log_impl((void *)&_mh_execute_header, v119, OS_LOG_TYPE_ERROR, v57, buf, v120);
      goto LABEL_222;
    }
    size_t cnt = 0;
    fds = 0;
    int v47 = launch_activate_socket(a5, &fds, &cnt);
    if (v47)
    {
      int v48 = v47;
      __int16 v49 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
LABEL_57:
        v20[37] = -1;
        unsigned int v25 = v136;
        goto LABEL_58;
      }
      uint64_t v50 = strerror(v48);
      *(_DWORD *)buf = 136446722;
      __int16 v156 = "ioloop_udp_listener_setup";
      __int16 v157 = 2082;
      *(void *)__int16 v158 = a5;
      *(_WORD *)&v158[8] = 2082;
      *(void *)&v158[10] = v50;
      __int16 v51 = "%{public}s: launchd_activate_socket failed for %{public}s: %{public}s";
LABEL_56:
      _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_FAULT, v51, buf, 0x20u);
      goto LABEL_57;
    }
    size_t v65 = cnt;
    if (cnt == 1)
    {
      int v91 = fds;
      v20[37] = *fds;
    }
    else
    {
      if (!cnt)
      {
        __int16 v49 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_57;
        }
        *(_DWORD *)buf = 136446722;
        __int16 v156 = "ioloop_udp_listener_setup";
        __int16 v157 = 2082;
        *(void *)__int16 v158 = a5;
        *(_WORD *)&v158[8] = 2048;
        *(void *)&v158[10] = 0;
        __int16 v51 = "%{public}s: too few sockets returned from launchd_active_socket for %{public}s : %zd";
        goto LABEL_56;
      }
      long long v92 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)
        || (*(_DWORD *)buf = 136446722,
            __int16 v156 = "ioloop_udp_listener_setup",
            __int16 v157 = 2082,
            *(void *)__int16 v158 = a5,
            *(_WORD *)&v158[8] = 2048,
            *(void *)&v158[10] = v65,
            _os_log_impl((void *)&_mh_execute_header, v92, OS_LOG_TYPE_FAULT, "%{public}s: too many sockets returned from launchd_active_socket for %{public}s : %zd", buf, 0x20u), cnt))
      {
        size_t v93 = 0;
        do
          close(fds[v93++]);
        while (v93 < cnt);
      }
      int v91 = fds;
      unsigned int v25 = v136;
    }
    free(v91);
    int v94 = v20[37];
    if (v94 != -1) {
      goto LABEL_170;
    }
    goto LABEL_58;
  }
  *((void *)v20 + 26) = a6;
  *((void *)v20 + 30) = 0;
  *((void *)v20 + 31) = a7;
  *((void *)v20 + 28) = 0;
  if (v25)
  {
    *((_WORD *)v20 + 80) = v25;
    if (a4 && v17)
    {
      __int16 v35 = &dnssd_client_states;
      if (v17 == 2)
      {
        uint64_t v36 = (const void *)(a4 + 4);
        int v37 = 2;
      }
      else
      {
        uint64_t v36 = (const void *)(a4 + 8);
        int v37 = v17;
      }
      inet_ntop(v37, v36, hostname, 0x2Eu);
    }
    else
    {
      __int16 v35 = &dnssd_client_states;
      if (v17 == 2) {
        strcpy(hostname, "0.0.0.0");
      }
      else {
        strcpy(hostname, "::");
      }
    }
    nw_endpoint_t host = nw_endpoint_create_host(hostname, __str);
    if (!host)
    {
      __int16 v80 = *((void *)v35 + 306);
      if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v156 = "ioloop_listener_create";
        _os_log_impl((void *)&_mh_execute_header, v80, OS_LOG_TYPE_ERROR, "%{public}s: No memory for listener endpoint.", buf, 0xCu);
      }
      int v81 = v20[8];
      if (!v81)
      {
        uint32_t v26 = *((void *)v35 + 306);
        if (!os_log_type_enabled(v26, OS_LOG_TYPE_FAULT)) {
          goto LABEL_271;
        }
        *(_DWORD *)buf = 136447490;
        __int16 v156 = "ioloop_listener_create";
        __int16 v157 = 1024;
        *(_DWORD *)__int16 v158 = 0;
        *(_WORD *)&v158[4] = 2048;
        *(void *)&v158[6] = v20;
        *(_WORD *)&v158[14] = 2080;
        *(void *)&v158[16] = "listener";
        *(_WORD *)&v158[24] = 2080;
        *(void *)&v158[26] = "macos-ioloop.c";
        *(_WORD *)&v158[34] = 1024;
        *(_DWORD *)&v158[36] = 1670;
        uint64_t v27 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_270;
      }
      uint32_t v26 = *((void *)v35 + 306);
      if (v81 >= 10001)
      {
        if (!os_log_type_enabled(v26, OS_LOG_TYPE_FAULT)) {
          goto LABEL_271;
        }
        *(_DWORD *)buf = 136447490;
        __int16 v156 = "ioloop_listener_create";
        __int16 v157 = 1024;
        *(_DWORD *)__int16 v158 = v81;
        *(_WORD *)&v158[4] = 2048;
        *(void *)&v158[6] = v20;
        *(_WORD *)&v158[14] = 2080;
        *(void *)&v158[16] = "listener";
        *(_WORD *)&v158[24] = 2080;
        *(void *)&v158[26] = "macos-ioloop.c";
        *(_WORD *)&v158[34] = 1024;
        *(_DWORD *)&v158[36] = 1670;
        uint64_t v27 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_270;
      }
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        __int16 v156 = "ioloop_listener_create";
        __int16 v157 = 1024;
        *(_DWORD *)__int16 v158 = v81;
        *(_WORD *)&v158[4] = 2048;
        *(void *)&v158[6] = v20;
        *(_WORD *)&v158[14] = 2080;
        *(void *)&v158[16] = "listener";
        *(_WORD *)&v158[24] = 2080;
        *(void *)&v158[26] = "macos-ioloop.c";
        *(_WORD *)&v158[34] = 1024;
        *(_DWORD *)&v158[36] = 1670;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        int v81 = v20[8];
      }
      v20[8] = v81 - 1;
      if (v81 != 1) {
        return 0;
      }
      int v39 = *((void *)v35 + 306);
      if (!os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_230;
      }
      *(_DWORD *)buf = 136447234;
      __int16 v156 = "ioloop_listener_create";
      __int16 v157 = 2048;
      *(void *)__int16 v158 = v20;
      *(_WORD *)&v158[8] = 2080;
      *(void *)&v158[10] = "listener";
      *(_WORD *)&v158[18] = 2080;
      *(void *)&v158[20] = "macos-ioloop.c";
      *(_WORD *)&v158[28] = 1024;
      *(_DWORD *)&v158[30] = 1670;
      goto LABEL_229;
    }
    __int16 v62 = host;
  }
  else
  {
    __int16 v62 = 0;
    *((unsigned char *)v20 + 184) = 1;
    __int16 v35 = &dnssd_client_states;
  }
  int64_t v69 = _nw_parameters_configure_protocol_disable;
  if (a9 && a2)
  {
    int64_t v69 = configure_tls;
    configure_tls[0] = _NSConcreteStackBlock;
    configure_tls[1] = 0x40000000;
    configure_tls[2] = __ioloop_listener_create_block_invoke;
    configure_tls[3] = &__block_descriptor_tmp_17_1195;
    configure_tls[4] = a9;
  }
  secure_tcp = nw_parameters_create_secure_tcp(v69, &__block_literal_global_1196);
  *((void *)v20 + 2) = secure_tcp;
  if (!secure_tcp)
  {
    __int16 v78 = *((void *)v35 + 306);
    if (os_log_type_enabled(v78, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v156 = "ioloop_listener_create";
      _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_ERROR, "%{public}s: No memory for listener parameters.", buf, 0xCu);
    }
    nw_release(v62);
    int v79 = v20[8];
    if (!v79)
    {
      uint32_t v26 = *((void *)v35 + 306);
      if (!os_log_type_enabled(v26, OS_LOG_TYPE_FAULT)) {
        goto LABEL_271;
      }
      *(_DWORD *)buf = 136447490;
      __int16 v156 = "ioloop_listener_create";
      __int16 v157 = 1024;
      *(_DWORD *)__int16 v158 = 0;
      *(_WORD *)&v158[4] = 2048;
      *(void *)&v158[6] = v20;
      *(_WORD *)&v158[14] = 2080;
      *(void *)&v158[16] = "listener";
      *(_WORD *)&v158[24] = 2080;
      *(void *)&v158[26] = "macos-ioloop.c";
      *(_WORD *)&v158[34] = 1024;
      *(_DWORD *)&v158[36] = 1703;
      uint64_t v27 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_270;
    }
    uint32_t v26 = *((void *)v35 + 306);
    if (v79 >= 10001)
    {
      if (!os_log_type_enabled(v26, OS_LOG_TYPE_FAULT)) {
        goto LABEL_271;
      }
      *(_DWORD *)buf = 136447490;
      __int16 v156 = "ioloop_listener_create";
      __int16 v157 = 1024;
      *(_DWORD *)__int16 v158 = v79;
      *(_WORD *)&v158[4] = 2048;
      *(void *)&v158[6] = v20;
      *(_WORD *)&v158[14] = 2080;
      *(void *)&v158[16] = "listener";
      *(_WORD *)&v158[24] = 2080;
      *(void *)&v158[26] = "macos-ioloop.c";
      *(_WORD *)&v158[34] = 1024;
      *(_DWORD *)&v158[36] = 1703;
      uint64_t v27 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_270;
    }
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447490;
      __int16 v156 = "ioloop_listener_create";
      __int16 v157 = 1024;
      *(_DWORD *)__int16 v158 = v79;
      *(_WORD *)&v158[4] = 2048;
      *(void *)&v158[6] = v20;
      *(_WORD *)&v158[14] = 2080;
      *(void *)&v158[16] = "listener";
      *(_WORD *)&v158[24] = 2080;
      *(void *)&v158[26] = "macos-ioloop.c";
      *(_WORD *)&v158[34] = 1024;
      *(_DWORD *)&v158[36] = 1703;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      int v79 = v20[8];
    }
    v20[8] = v79 - 1;
    if (v79 != 1) {
      return 0;
    }
    int v39 = *((void *)v35 + 306);
    if (!os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_230;
    }
    *(_DWORD *)buf = 136447234;
    __int16 v156 = "ioloop_listener_create";
    __int16 v157 = 2048;
    *(void *)__int16 v158 = v20;
    *(_WORD *)&v158[8] = 2080;
    *(void *)&v158[10] = "listener";
    *(_WORD *)&v158[18] = 2080;
    *(void *)&v158[20] = "macos-ioloop.c";
    *(_WORD *)&v158[28] = 1024;
    *(_DWORD *)&v158[30] = 1703;
    goto LABEL_229;
  }
  if (v62)
  {
    nw_parameters_set_local_endpoint(secure_tcp, v62);
    nw_release(v62);
    secure_tcp = *((void *)v20 + 2);
  }
  nw_parameters_set_reuse_local_address(secure_tcp, 1);
  nw_parameters_prohibit_interface_type(*((nw_parameters_t *)v20 + 2), nw_interface_type_cellular);
  *((void *)v20 + 1) = 0;
  if (!a5
    || !a3
    || (uint64_t v71 = nw_listener_create_with_launchd_key(), (*((void *)v20 + 1) = v71) == 0)
    && ((__int16 v72 = *((void *)v35 + 306), !os_log_type_enabled(v72, OS_LOG_TYPE_ERROR))
     || (*(_DWORD *)buf = 136446210,
         __int16 v156 = "ioloop_listener_create",
         _os_log_impl((void *)&_mh_execute_header, v72, OS_LOG_TYPE_ERROR, "%{public}s: launchd listener create failed, trying to create it without relying on launchd.", buf, 0xCu), (uint64_t v71 = *((void *)v20 + 1)) == 0)))
  {
    uint64_t v71 = nw_listener_create(*((nw_parameters_t *)v20 + 2));
    *((void *)v20 + 1) = v71;
    if (!v71)
    {
      __int16 v84 = *((void *)v35 + 306);
      if (os_log_type_enabled(v84, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v156 = "ioloop_listener_create";
        _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_ERROR, "%{public}s: no memory for nw_listener object", buf, 0xCu);
      }
      int v85 = v20[8];
      if (!v85)
      {
        uint32_t v26 = *((void *)v35 + 306);
        if (!os_log_type_enabled(v26, OS_LOG_TYPE_FAULT)) {
          goto LABEL_271;
        }
        *(_DWORD *)buf = 136447490;
        __int16 v156 = "ioloop_listener_create";
        __int16 v157 = 1024;
        *(_DWORD *)__int16 v158 = 0;
        *(_WORD *)&v158[4] = 2048;
        *(void *)&v158[6] = v20;
        *(_WORD *)&v158[14] = 2080;
        *(void *)&v158[16] = "listener";
        *(_WORD *)&v158[24] = 2080;
        *(void *)&v158[26] = "macos-ioloop.c";
        *(_WORD *)&v158[34] = 1024;
        *(_DWORD *)&v158[36] = 1737;
        uint64_t v27 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_270;
      }
      uint32_t v26 = *((void *)v35 + 306);
      if (v85 >= 10001)
      {
        if (!os_log_type_enabled(v26, OS_LOG_TYPE_FAULT)) {
          goto LABEL_271;
        }
        *(_DWORD *)buf = 136447490;
        __int16 v156 = "ioloop_listener_create";
        __int16 v157 = 1024;
        *(_DWORD *)__int16 v158 = v85;
        *(_WORD *)&v158[4] = 2048;
        *(void *)&v158[6] = v20;
        *(_WORD *)&v158[14] = 2080;
        *(void *)&v158[16] = "listener";
        *(_WORD *)&v158[24] = 2080;
        *(void *)&v158[26] = "macos-ioloop.c";
        *(_WORD *)&v158[34] = 1024;
        *(_DWORD *)&v158[36] = 1737;
        uint64_t v27 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_270:
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_FAULT, v27, buf, 0x36u);
LABEL_271:
        abort();
      }
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        __int16 v156 = "ioloop_listener_create";
        __int16 v157 = 1024;
        *(_DWORD *)__int16 v158 = v85;
        *(_WORD *)&v158[4] = 2048;
        *(void *)&v158[6] = v20;
        *(_WORD *)&v158[14] = 2080;
        *(void *)&v158[16] = "listener";
        *(_WORD *)&v158[24] = 2080;
        *(void *)&v158[26] = "macos-ioloop.c";
        *(_WORD *)&v158[34] = 1024;
        *(_DWORD *)&v158[36] = 1737;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        int v85 = v20[8];
      }
      v20[8] = v85 - 1;
      if (v85 != 1) {
        return 0;
      }
      int v39 = *((void *)v35 + 306);
      if (!os_log_type_enabled(v39, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_230;
      }
      *(_DWORD *)buf = 136447234;
      __int16 v156 = "ioloop_listener_create";
      __int16 v157 = 2048;
      *(void *)__int16 v158 = v20;
      *(_WORD *)&v158[8] = 2080;
      *(void *)&v158[10] = "listener";
      *(_WORD *)&v158[18] = 2080;
      *(void *)&v158[20] = "macos-ioloop.c";
      *(_WORD *)&v158[28] = 1024;
      *(_DWORD *)&v158[30] = 1737;
LABEL_229:
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
LABEL_230:
      ++listener_finalized;
      listener_finalize(v20);
      return 0;
    }
  }
  ++nw_listener_created;
  handler[0] = _NSConcreteStackBlock;
  handler[1] = 0x40000000;
  handler[2] = __ioloop_listener_create_block_invoke_19;
  handler[3] = &__block_descriptor_tmp_21;
  handler[4] = v20;
  nw_listener_set_new_connection_handler(v71, handler);
  int v73 = *((void *)v20 + 1);
  v137[0] = _NSConcreteStackBlock;
  v137[1] = 0x40000000;
  v137[2] = __ioloop_listener_create_block_invoke_2_22;
  v137[3] = &__block_descriptor_tmp_24;
  v137[4] = v20;
  nw_listener_set_state_changed_handler(v73, v137);
  __int16 v74 = *((void *)v35 + 306);
  if (os_log_type_enabled(v74, OS_LOG_TYPE_DEFAULT))
  {
    int v75 = v20[8];
    *(_DWORD *)buf = 136447490;
    __int16 v156 = "ioloop_listener_create";
    __int16 v157 = 1024;
    *(_DWORD *)__int16 v158 = v75;
    *(_WORD *)&v158[4] = 2048;
    *(void *)&v158[6] = v20;
    *(_WORD *)&v158[14] = 2080;
    *(void *)&v158[16] = "listener";
    *(_WORD *)&v158[24] = 2080;
    *(void *)&v158[26] = "macos-ioloop.c";
    *(_WORD *)&v158[34] = 1024;
    *(_DWORD *)&v158[36] = 1749;
    _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  int v76 = v20[8];
  if (v76)
  {
    int v77 = v76 + 1;
    v20[8] = v76 + 1;
    if (v76 + 1 >= 10001)
    {
      uint32_t v26 = *((void *)v35 + 306);
      if (!os_log_type_enabled(v26, OS_LOG_TYPE_FAULT)) {
        goto LABEL_271;
      }
      *(_DWORD *)buf = 136447490;
      __int16 v156 = "ioloop_listener_create";
      __int16 v157 = 1024;
      *(_DWORD *)__int16 v158 = v77;
      *(_WORD *)&v158[4] = 2048;
      *(void *)&v158[6] = v20;
      *(_WORD *)&v158[14] = 2080;
      *(void *)&v158[16] = "listener";
      *(_WORD *)&v158[24] = 2080;
      *(void *)&v158[26] = "macos-ioloop.c";
      *(_WORD *)&v158[34] = 1024;
      *(_DWORD *)&v158[36] = 1749;
      uint64_t v27 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_270;
    }
  }
  else
  {
    ++listener_created;
    v20[8] = 1;
  }
  nw_listener_set_queue(*((nw_listener_t *)v20 + 1), (dispatch_queue_t)ioloop_main_queue);
  nw_listener_start(*((nw_listener_t *)v20 + 1));
  return v20;
}

void ioloop_add_reader(int *a1)
{
  *((void *)a1 + 2) = ioloop_udp_read_callback;
  uint64_t v2 = *((void *)a1 + 9);
  if (v2
    || (uint64_t v2 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, a1[23], 0, (dispatch_queue_t)ioloop_main_queue), (*((void *)a1 + 9) = v2) != 0))
  {
    dispatch_source_set_event_handler_f(v2, (dispatch_function_t)ioloop_read_event);
    dispatch_source_set_cancel_handler_f(*((dispatch_source_t *)a1 + 9), (dispatch_function_t)ioloop_read_source_cancel_callback);
    dispatch_set_finalizer_f(*((dispatch_object_t *)a1 + 9), (dispatch_function_t)ioloop_read_source_finalize);
    dispatch_set_context(*((dispatch_object_t *)a1 + 9), a1);
    int v3 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = *a1;
      *(_DWORD *)buf = 136447490;
      unsigned int v18 = "ioloop_add_reader";
      __int16 v19 = 1024;
      *(_DWORD *)__int16 v20 = v4;
      *(_WORD *)&v20[4] = 2048;
      *(void *)&v20[6] = a1;
      __int16 v21 = 2080;
      int v22 = "io";
      __int16 v23 = 2080;
      int v24 = "macos-ioloop.c";
      __int16 v25 = 1024;
      int v26 = 2412;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    if (*a1)
    {
      int v5 = *a1 + 1;
      *a1 = v5;
      if (v5 >= 10001)
      {
        int v16 = v5;
        uint64_t v6 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136447490;
          unsigned int v18 = "ioloop_add_reader";
          __int16 v19 = 1024;
          *(_DWORD *)__int16 v20 = v16;
          *(_WORD *)&v20[4] = 2048;
          *(void *)&v20[6] = a1;
          __int16 v21 = 2080;
          int v22 = "io";
          __int16 v23 = 2080;
          int v24 = "macos-ioloop.c";
          __int16 v25 = 1024;
          int v26 = 2412;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++file_descriptor_created;
      *a1 = 1;
    }
    dispatch_resume(*((dispatch_object_t *)a1 + 9));
    uint64_t v7 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v8 = a1[23];
      int v9 = (const char *)*((void *)a1 + 9);
      int v10 = (char *)*((void *)a1 + 10);
      *(_DWORD *)buf = 136447234;
      unsigned int v18 = "ioloop_add_reader";
      __int16 v19 = 2048;
      *(void *)__int16 v20 = a1;
      *(_WORD *)&v20[8] = 1024;
      *(_DWORD *)&v20[10] = v8;
      __int16 v21 = 2048;
      int v22 = v9;
      __int16 v23 = 2048;
      int v24 = v10;
      int v11 = "%{public}s: io %p fd %d, read source %p, write_source %p";
      __int16 v12 = v7;
      os_log_type_t v13 = OS_LOG_TYPE_DEFAULT;
      uint32_t v14 = 48;
LABEL_13:
      _os_log_impl((void *)&_mh_execute_header, v12, v13, v11, buf, v14);
    }
  }
  else
  {
    uint64_t v15 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      unsigned int v18 = "ioloop_add_reader";
      int v11 = "%{public}s: dispatch_source_create: unable to create read dispatch source.";
      __int16 v12 = v15;
      os_log_type_t v13 = OS_LOG_TYPE_ERROR;
      uint32_t v14 = 12;
      goto LABEL_13;
    }
  }
}

void __ioloop_udp_listener_setup_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(_WORD *)(v2 + 416) & 0x400) != 0)
  {
    int v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = 136446210;
      os_log_type_t v13 = "ioloop_udp_listener_setup_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ready but canceled", (uint8_t *)&v12, 0xCu);
    }
  }
  else
  {
    int v3 = *(void (**)(void, void))(v2 + 256);
    if (v3) {
      v3(*(void *)(v2 + 200), *(unsigned __int16 *)(v2 + 160));
    }
  }
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5)
  {
    int v6 = *(_DWORD *)(v5 + 32);
    if (v6)
    {
      uint64_t v7 = global_os_log;
      if (v6 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v12 = 136447490;
          os_log_type_t v13 = "ioloop_udp_listener_setup_block_invoke";
          __int16 v14 = 1024;
          *(_DWORD *)uint64_t v15 = v6;
          *(_WORD *)&_OWORD v15[4] = 2048;
          *(void *)&v15[6] = v5;
          *(_WORD *)&v15[14] = 2080;
          *(void *)&v15[16] = "listener";
          *(_WORD *)&v15[24] = 2080;
          *(void *)&v15[26] = "macos-ioloop.c";
          __int16 v16 = 1024;
          int v17 = 1536;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v12, 0x36u);
          uint64_t v5 = *(void *)(a1 + 32);
          int v6 = *(_DWORD *)(v5 + 32);
        }
        *(_DWORD *)(v5 + 32) = v6 - 1;
        if (v6 == 1)
        {
          int v8 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v12 = 136447234;
            os_log_type_t v13 = "ioloop_udp_listener_setup_block_invoke";
            __int16 v14 = 2048;
            *(void *)uint64_t v15 = v5;
            *(_WORD *)&v15[8] = 2080;
            *(void *)&v15[10] = "listener";
            *(_WORD *)&v15[18] = 2080;
            *(void *)&v15[20] = "macos-ioloop.c";
            *(_WORD *)&v15[28] = 1024;
            *(_DWORD *)&v15[30] = 1536;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v12, 0x30u);
            uint64_t v5 = *(void *)(a1 + 32);
          }
          ++listener_finalized;
          listener_finalize((void *)v5);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_21:
      }
        abort();
      int v12 = 136447490;
      os_log_type_t v13 = "ioloop_udp_listener_setup_block_invoke";
      __int16 v14 = 1024;
      *(_DWORD *)uint64_t v15 = v6;
      *(_WORD *)&_OWORD v15[4] = 2048;
      *(void *)&v15[6] = v5;
      *(_WORD *)&v15[14] = 2080;
      *(void *)&v15[16] = "listener";
      *(_WORD *)&v15[24] = 2080;
      *(void *)&v15[26] = "macos-ioloop.c";
      __int16 v16 = 1024;
      int v17 = 1536;
      int v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      int v11 = v7;
    }
    else
    {
      uint64_t v9 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_21;
      }
      int v12 = 136447490;
      os_log_type_t v13 = "ioloop_udp_listener_setup_block_invoke";
      __int16 v14 = 1024;
      *(_DWORD *)uint64_t v15 = 0;
      *(_WORD *)&_OWORD v15[4] = 2048;
      *(void *)&v15[6] = v5;
      *(_WORD *)&v15[14] = 2080;
      *(void *)&v15[16] = "listener";
      *(_WORD *)&v15[24] = 2080;
      *(void *)&v15[26] = "macos-ioloop.c";
      __int16 v16 = 1024;
      int v17 = 1536;
      int v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      int v11 = v9;
    }
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v12, 0x36u);
    goto LABEL_21;
  }
}

uint64_t __ioloop_listener_create_block_invoke(uint64_t a1, uint64_t a2)
{
  v3[0] = a2;
  v3[1] = ioloop_main_queue;
  return (*(uint64_t (**)(void *))(a1 + 32))(v3);
}

void __ioloop_listener_create_block_invoke_19(uint64_t a1, nw_connection_t connection)
{
  uint64_t v3 = *(void *)(a1 + 32);
  nw_connection_set_queue(connection, (dispatch_queue_t)ioloop_main_queue);
  nw_connection_start(connection);
  int v4 = malloc_type_calloc(1uLL, 0x1A8uLL, 0x10B00402743B0D3uLL);
  if (v4)
  {
    uint64_t v5 = v4;
    v4[45] = ++cur_connection_serial;
    *(void *)int v4 = connection;
    nw_retain(connection);
    ++nw_connection_created;
    int v6 = strdup(*(const char **)(v3 + 192));
    *((void *)v5 + 24) = v6;
    if (v6)
    {
      *((void *)v5 + 26) = *(void *)(v3 + 208);
      *((_WORD *)v5 + 208) = *(_WORD *)(v3 + 416) & 0x20 | v5[104] & 0xFFDF | 2;
      *((void *)v5 + 25) = *(void *)(v3 + 200);
      *((void *)v5 + 28) = *(void *)(v3 + 224);
      uint64_t v7 = *(int **)(v3 + 408);
      *((void *)v5 + 51) = v7;
      ifpermit_list_retain_(v7, 1091);
      int v8 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v9 = v5[8];
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "ioloop_listener_connection_callback";
        *(_WORD *)&uint8_t buf[12] = 1024;
        *(_DWORD *)&buf[14] = v9;
        *(_WORD *)&buf[18] = 2048;
        *(void *)&buf[20] = v5;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "connection";
        *(_WORD *)&unsigned char buf[38] = 2080;
        *(void *)&buf[40] = "macos-ioloop.c";
        __int16 v27 = 1024;
        int v28 = 1093;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      }
      int v10 = v5[8];
      if (v10)
      {
        int v11 = v10 + 1;
        v5[8] = v11;
        if (v11 >= 10001)
        {
          int v19 = v11;
          int v12 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)buf = 136447490;
            *(void *)&uint8_t buf[4] = "ioloop_listener_connection_callback";
            *(_WORD *)&uint8_t buf[12] = 1024;
            *(_DWORD *)&buf[14] = v19;
            *(_WORD *)&buf[18] = 2048;
            *(void *)&buf[20] = v5;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = "connection";
            *(_WORD *)&unsigned char buf[38] = 2080;
            *(void *)&buf[40] = "macos-ioloop.c";
            __int16 v27 = 1024;
            int v28 = 1093;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          }
          abort();
        }
      }
      else
      {
        ++comm_created;
        v5[8] = 1;
      }
      __int16 v16 = *(NSObject **)v5;
      *(void *)buf = _NSConcreteStackBlock;
      *(void *)&buf[8] = 0x40000000;
      *(void *)&buf[16] = __ioloop_listener_connection_callback_block_invoke;
      *(void *)&buf[24] = &__block_descriptor_tmp_51;
      *(void *)&buf[32] = v5;
      nw_connection_set_state_changed_handler(v16, buf);
      int v17 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v18 = *((void *)v5 + 24);
        *(_DWORD *)__int16 v20 = 136446723;
        __int16 v21 = "ioloop_listener_connection_callback";
        __int16 v22 = 2160;
        uint64_t v23 = 1752392040;
        __int16 v24 = 2081;
        uint64_t v25 = v18;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: started %{private, mask.hash}s", v20, 0x20u);
      }
    }
    else
    {
      __int16 v14 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        uint64_t v15 = *(void *)(v3 + 192);
        *(_DWORD *)buf = 136446979;
        *(void *)&uint8_t buf[4] = "ioloop_listener_connection_callback";
        *(_WORD *)&uint8_t buf[12] = 2048;
        *(void *)&buf[14] = v3;
        *(_WORD *)&buf[22] = 2160;
        *(void *)&buf[24] = 1752392040;
        *(_WORD *)&buf[32] = 2081;
        *(void *)&buf[34] = v15;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%{public}s: %p: %{private, mask.hash}s: no memory for connection name.", buf, 0x2Au);
      }
      nw_connection_cancel(*(nw_connection_t *)v5);
      nw_release(*(void **)v5);
    }
  }
  else
  {
    os_log_type_t v13 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "ioloop_listener_connection_callback";
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%{public}s: Unable to receive connection: no memory.", buf, 0xCu);
    }
    nw_connection_cancel(connection);
  }
}

void __ioloop_listener_create_block_invoke_2_22(uint64_t a1, int a2, NSObject *a3)
{
  uint64_t v5 = *(void *)(a1 + 32);
  if (!*(void *)(v5 + 8))
  {
    uint64_t v6 = global_os_log;
    if (a2 == 4)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_8;
      }
      uint64_t v7 = *(void *)(v5 + 192);
      *(_DWORD *)buf = 136446723;
      uint64_t v38 = "ioloop_listener_state_changed_handler";
      __int16 v39 = 2160;
      *(void *)unsigned __int8 v40 = 1752392040;
      *(_WORD *)&v40[8] = 2081;
      *(void *)&v40[10] = v7;
      int v8 = "%{public}s: nw_listener gets released before the final nw_listener_state_cancelled event - name: %{private, mask.hash}s";
      int v9 = v6;
      os_log_type_t v10 = OS_LOG_TYPE_DEFAULT;
      uint32_t v11 = 32;
    }
    else
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
        goto LABEL_8;
      }
      uint64_t v12 = *(void *)(v5 + 192);
      *(_DWORD *)buf = 136446979;
      uint64_t v38 = "ioloop_listener_state_changed_handler";
      __int16 v39 = 2160;
      *(void *)unsigned __int8 v40 = 1752392040;
      *(_WORD *)&v40[8] = 2081;
      *(void *)&v40[10] = v12;
      *(_WORD *)&v40[18] = 1024;
      *(_DWORD *)&v40[20] = a2;
      int v8 = "%{public}s: nw_listener gets released before the listener is canceled - name: %{private, mask.hash}s, state: %d";
      int v9 = v6;
      os_log_type_t v10 = OS_LOG_TYPE_ERROR;
      uint32_t v11 = 38;
    }
    _os_log_impl((void *)&_mh_execute_header, v9, v10, v8, buf, v11);
  }
LABEL_8:
  os_log_type_t v13 = global_os_log;
  BOOL v14 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  uint64_t v15 = *(NSObject **)(v5 + 8);
  if (v14)
  {
    uint64_t v16 = *(void *)(v5 + 192);
    *(_DWORD *)buf = 136447234;
    uint64_t v38 = "ioloop_listener_state_changed_handler";
    __int16 v39 = 2048;
    *(void *)unsigned __int8 v40 = v5;
    *(_WORD *)&v40[8] = 2048;
    *(void *)&v40[10] = v15;
    *(_WORD *)&v40[18] = 2082;
    *(void *)&v40[20] = v16;
    *(_WORD *)&v40[28] = 1024;
    *(_DWORD *)&v40[30] = a2;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: %p %p %{public}s %d", buf, 0x30u);
    uint64_t v15 = *(NSObject **)(v5 + 8);
  }
  if (a2 == 4 || v15)
  {
    if (a3)
    {
      connection_error_to_string(a3, (char *)buf);
      int v17 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v33 = 136446466;
        __int16 v34 = "ioloop_listener_state_changed_handler";
        __int16 v35 = 2082;
        uint64_t v36 = buf;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: state changed: %{public}s", (uint8_t *)&v33, 0x16u);
      }
      uint64_t v18 = *(NSObject **)(v5 + 8);
      if (v18) {
LABEL_16:
      }
        nw_listener_cancel(v18);
      return;
    }
    switch(a2)
    {
      case 1:
        uint64_t v19 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v38 = "ioloop_listener_state_changed_handler";
        __int16 v20 = "%{public}s: waiting";
        goto LABEL_26;
      case 2:
        __int16 v23 = *(_WORD *)(v5 + 416);
        __int16 v24 = global_os_log;
        BOOL v25 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
        if ((v23 & 0x400) != 0)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v38 = "ioloop_listener_state_changed_handler";
            __int16 v20 = "%{public}s: ready but canceled";
            __int16 v22 = v24;
LABEL_27:
            _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, v20, buf, 0xCu);
          }
        }
        else
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v38 = "ioloop_listener_state_changed_handler";
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "%{public}s: ready", buf, 0xCu);
          }
          int v26 = *(void (**)(void, void))(v5 + 256);
          if (v26) {
            v26(*(void *)(v5 + 200), *(unsigned __int16 *)(v5 + 160));
          }
        }
        return;
      case 3:
        __int16 v21 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v38 = "ioloop_listener_state_changed_handler";
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%{public}s: failed", buf, 0xCu);
          uint64_t v15 = *(NSObject **)(v5 + 8);
        }
        uint64_t v18 = v15;
        goto LABEL_16;
      case 4:
        __int16 v27 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v38 = "ioloop_listener_state_changed_handler";
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "%{public}s: cancelled", buf, 0xCu);
          uint64_t v15 = *(NSObject **)(v5 + 8);
        }
        nw_release(v15);
        ++nw_listener_finalized;
        *(void *)(v5 + 8) = 0;
        int v28 = *(void (**)(uint64_t, void))(v5 + 248);
        if (v28) {
          v28(v5, *(void *)(v5 + 200));
        }
        int v29 = *(_DWORD *)(v5 + 32);
        if (v29)
        {
          uint64_t v30 = global_os_log;
          if (v29 < 10001)
          {
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136447490;
              uint64_t v38 = "ioloop_listener_state_changed_handler";
              __int16 v39 = 1024;
              *(_DWORD *)unsigned __int8 v40 = v29;
              *(_WORD *)&v40[4] = 2048;
              *(void *)&v40[6] = v5;
              *(_WORD *)&v40[14] = 2080;
              *(void *)&v40[16] = "listener";
              *(_WORD *)&v40[24] = 2080;
              *(void *)&v40[26] = "macos-ioloop.c";
              __int16 v41 = 1024;
              int v42 = 1336;
              _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
              int v29 = *(_DWORD *)(v5 + 32);
            }
            *(_DWORD *)(v5 + 32) = v29 - 1;
            if (v29 == 1)
            {
              uint32_t v31 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)buf = 136447234;
                uint64_t v38 = "ioloop_listener_state_changed_handler";
                __int16 v39 = 2048;
                *(void *)unsigned __int8 v40 = v5;
                *(_WORD *)&v40[8] = 2080;
                *(void *)&v40[10] = "listener";
                *(_WORD *)&v40[18] = 2080;
                *(void *)&v40[20] = "macos-ioloop.c";
                *(_WORD *)&v40[28] = 1024;
                *(_DWORD *)&v40[30] = 1336;
                _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
              }
              ++listener_finalized;
              listener_finalize((void *)v5);
            }
            return;
          }
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_52:
          }
            abort();
          *(_DWORD *)buf = 136447490;
          uint64_t v38 = "ioloop_listener_state_changed_handler";
          __int16 v39 = 1024;
          *(_DWORD *)unsigned __int8 v40 = v29;
          *(_WORD *)&v40[4] = 2048;
          *(void *)&v40[6] = v5;
          *(_WORD *)&v40[14] = 2080;
          *(void *)&v40[16] = "listener";
          *(_WORD *)&v40[24] = 2080;
          *(void *)&v40[26] = "macos-ioloop.c";
          __int16 v41 = 1024;
          int v42 = 1336;
          uint64_t v32 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        }
        else
        {
          uint64_t v30 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
            goto LABEL_52;
          }
          *(_DWORD *)buf = 136447490;
          uint64_t v38 = "ioloop_listener_state_changed_handler";
          __int16 v39 = 1024;
          *(_DWORD *)unsigned __int8 v40 = 0;
          *(_WORD *)&v40[4] = 2048;
          *(void *)&v40[6] = v5;
          *(_WORD *)&v40[14] = 2080;
          *(void *)&v40[16] = "listener";
          *(_WORD *)&v40[24] = 2080;
          *(void *)&v40[26] = "macos-ioloop.c";
          __int16 v41 = 1024;
          int v42 = 1336;
          uint64_t v32 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        }
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_FAULT, v32, buf, 0x36u);
        goto LABEL_52;
      default:
        uint64_t v19 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v38 = "ioloop_listener_state_changed_handler";
        __int16 v20 = "%{public}s: something else";
LABEL_26:
        __int16 v22 = v19;
        goto LABEL_27;
    }
  }
}

void connection_error_to_string(NSObject *a1, char *a2)
{
  *a2 = 0;
  if (!a1) {
    goto LABEL_7;
  }
  uint64_t v3 = nw_error_copy_cf_error(a1);
  if (v3)
  {
    int v4 = v3;
    CFStringRef v5 = CFErrorCopyDescription(v3);
    if (v5)
    {
      CFStringRef v6 = v5;
      CFStringGetCString(v5, a2, 512, 0x8000100u);
      CFRelease(v6);
    }
    CFRelease(v4);
  }
  if (!*a2) {
LABEL_7:
  }
    strcpy(a2, "<NULL>");
}

void __ioloop_listener_connection_callback_block_invoke(uint64_t a1, int a2, NSObject *a3)
{
}

void ioloop_connection_state_changed(uint64_t a1, int a2, NSObject *a3)
{
  connection_error_to_string(a3, v82);
  switch(a2)
  {
    case 3:
      __int16 v6 = *(_WORD *)(a1 + 416);
      if ((v6 & 0x400) == 0)
      {
        if ((v6 & 2) == 0)
        {
LABEL_118:
          int v77 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            __int16 v78 = *(const char **)(a1 + 192);
            nw_connection_t v79 = *(nw_connection_t *)a1;
            if (!v78) {
              __int16 v78 = "<no name>";
            }
            *(_DWORD *)buf = 136447491;
            __int16 v84 = "ioloop_connection_state_changed";
            __int16 v85 = 2160;
            *(void *)int v86 = 1752392040;
            *(_WORD *)&v86[8] = 2081;
            *(void *)&v86[10] = v78;
            *(_WORD *)&v86[18] = 2048;
            *(void *)&v86[20] = a1;
            *(_WORD *)&v86[28] = 2048;
            *(void *)&v86[30] = v79;
            *(_WORD *)&v86[38] = 2082;
            *(void *)&v86[40] = v82;
            _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "%{public}s: %{private, mask.hash}s (%p %p) state is ready; CFErrorRef error = %{public}s",
              buf,
              0x3Eu);
          }
          if ((*(_WORD *)(a1 + 416) & 0x20) != 0) {
            ioloop_tcp_input_start(a1);
          }
          else {
            ioloop_udp_input_start(a1);
          }
          *(_WORD *)(a1 + 416) |= 4u;
          if (*(void *)(a1 + 48)) {
            connection_write_now(a1);
          }
          __int16 v80 = *(void (**)(uint64_t, void))(a1 + 224);
          if (v80) {
            v80(a1, *(void *)(a1 + 200));
          }
          return;
        }
        if (!*(void *)(a1 + 408)) {
          goto LABEL_55;
        }
        uint64_t v7 = nw_connection_copy_connected_path();
        if (v7)
        {
          int v8 = (void *)v7;
          int v9 = nw_path_copy_interface();
          nw_release(v8);
          if (v9)
          {
            uint32_t index = nw_interface_get_index(v9);
            unint64_t v11 = *(void *)(a1 + 408);
            if (v11 >= 2)
            {
              unint64_t v33 = v11 + 8;
              while (1)
              {
                unint64_t v33 = *(void *)v33;
                BOOL v12 = v33 != 0;
                if (!v33) {
                  break;
                }
                if (*(_DWORD *)(v33 + 16) == index)
                {
                  BOOL v12 = 1;
                  break;
                }
              }
            }
            else
            {
              BOOL v12 = 0;
            }
            __int16 v34 = nw_connection_copy_description(*(nw_connection_t *)a1);
            name = nw_interface_get_name(v9);
            uint64_t v36 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              __int16 v84 = "ioloop_listener_connection_ready";
              __int16 v85 = 2160;
              int v37 = "not ";
              *(void *)int v86 = 1752392040;
              *(_WORD *)&v86[8] = 2081;
              *(_DWORD *)buf = 136447235;
              if (v12) {
                int v37 = "";
              }
              *(void *)&v86[10] = v34;
              *(_WORD *)&v86[18] = 2082;
              *(void *)&v86[20] = name;
              *(_WORD *)&v86[28] = 2082;
              *(void *)&v86[30] = v37;
              _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%{public}s: incoming connection from %{private, mask.hash}s is on %{public}s, which is %{public}spermitted.", buf, 0x34u);
            }
            free(v34);
            nw_release(v9);
            if (!v12) {
              goto LABEL_101;
            }
LABEL_55:
            uint64_t v38 = nw_connection_copy_endpoint(*(nw_connection_t *)a1);
            __int16 v39 = v38;
            if (!v38) {
              goto LABEL_85;
            }
            nw_endpoint_type_t type = nw_endpoint_get_type(v38);
            if (type != nw_endpoint_type_address)
            {
              nw_endpoint_type_t v52 = type;
              int v53 = *(char **)(a1 + 192);
              if (!v53)
              {
                int v53 = nw_connection_copy_description(*(nw_connection_t *)a1);
                *(void *)(a1 + 192) = v53;
              }
              uint64_t v54 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446979;
                __int16 v84 = "ioloop_connection_set_name_from_endpoint";
                __int16 v85 = 2160;
                *(void *)int v86 = 1752392040;
                *(_WORD *)&v86[8] = 2081;
                *(void *)&v86[10] = v53;
                *(_WORD *)&v86[18] = 1024;
                *(_DWORD *)&v86[20] = v52;
                _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_ERROR, "%{public}s: incoming connection %{private, mask.hash}s is of unexpected type %d", buf, 0x26u);
              }
              goto LABEL_84;
            }
            __int16 v41 = nw_endpoint_copy_port_string(v39);
            int v42 = nw_endpoint_copy_address_string(v39);
            int v43 = v42;
            if (v41 && v42)
            {
              uint64_t v44 = (char **)(a1 + 192);
              int v45 = *(void **)(a1 + 192);
              unsigned int v46 = "bogus";
              if (v45) {
                unsigned int v46 = *(const char **)(a1 + 192);
              }
              NSObject *v44 = 0;
              asprintf(v44, "%s connection from %s/%s", v46, v43, v41);
              if (v45) {
                free(v45);
              }
              getipaddr((char *)(a1 + 288), v43);
              int v47 = *(unsigned __int8 *)(a1 + 289);
              uint64_t v48 = global_os_log;
              BOOL v49 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
              if (v47 == 30)
              {
                if (v49)
                {
                  int v50 = *(unsigned __int8 *)(a1 + 296);
                  if ((v50 & 0xFE) == 0xFC)
                  {
                    __int16 v51 = "ULA: ";
                  }
                  else if (v50 == 254 && (*(unsigned char *)(a1 + 297) & 0xC0) == 0x80)
                  {
                    __int16 v51 = "LUA: ";
                  }
                  else if ((v50 & 0xE0) == 0x20)
                  {
                    __int16 v51 = "GUA: ";
                  }
                  else
                  {
                    __int16 v51 = "";
                  }
                  *(_DWORD *)buf = 136448771;
                  __int16 v84 = "ioloop_connection_set_name_from_endpoint";
                  __int16 v85 = 2082;
                  *(void *)int v86 = v51;
                  *(_WORD *)&v86[8] = 2160;
                  *(void *)&v86[10] = 1752392040;
                  *(_WORD *)&v86[18] = 1041;
                  *(_DWORD *)&v86[20] = 6;
                  *(_WORD *)&v86[24] = 2097;
                  *(void *)&v86[26] = a1 + 296;
                  *(_WORD *)&v86[34] = 2160;
                  *(void *)&v86[36] = 1752392040;
                  *(_WORD *)&v86[44] = 1042;
                  *(_DWORD *)&v86[46] = 2;
                  *(_WORD *)&v86[50] = 2098;
                  *(void *)&v86[52] = a1 + 302;
                  __int16 v87 = 2160;
                  uint64_t v88 = 1752392040;
                  __int16 v89 = 1041;
                  int v90 = 8;
                  __int16 v91 = 2097;
                  uint64_t v92 = a1 + 304;
                  __int16 v56 = "%{public}s: parsed connection remote IPv6 address is: {%{public}s%{private, mask.hash, srp:in6_a"
                        "ddr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}";
                  __int16 v57 = v48;
                  os_log_type_t v58 = OS_LOG_TYPE_DEFAULT;
                  uint32_t v59 = 100;
                  goto LABEL_82;
                }
LABEL_83:
                free(v41);
                free(v43);
LABEL_84:
                nw_release(v39);
LABEL_85:
                uint64_t v60 = *(void *)(a1 + 192);
                uint64_t v61 = global_os_log;
                if (v60)
                {
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)buf = 136446723;
                    __int16 v84 = "ioloop_listener_connection_ready";
                    __int16 v85 = 2160;
                    *(void *)int v86 = 1752392040;
                    *(_WORD *)&v86[8] = 2081;
                    *(void *)&v86[10] = v60;
                    _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "%{public}s: Received connection from %{private, mask.hash}s", buf, 0x20u);
                  }
                  goto LABEL_91;
                }
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446210;
                  __int16 v84 = "ioloop_listener_connection_ready";
                  _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_ERROR, "%{public}s: Unable to get description of new connection.", buf, 0xCu);
                }
                __int16 v62 = strdup("unidentified");
                *(void *)(a1 + 192) = v62;
                if (v62)
                {
LABEL_91:
                  uint64_t v63 = nw_connection_copy_connected_local_endpoint();
                  if (!v63) {
                    goto LABEL_116;
                  }
                  __int16 v64 = (void *)v63;
                  if (nw_endpoint_get_type(v39) != nw_endpoint_type_address)
                  {
LABEL_115:
                    nw_release(v64);
LABEL_116:
                    int v76 = *(void (**)(uint64_t, void))(a1 + 224);
                    if (v76) {
                      v76(a1, *(void *)(a1 + 200));
                    }
                    goto LABEL_118;
                  }
                  size_t v65 = nw_endpoint_copy_address_string(v39);
                  if (v65)
                  {
                    getipaddr((char *)(a1 + 344), v65);
                    int v66 = *(unsigned __int8 *)(a1 + 345);
                    uint64_t v67 = global_os_log;
                    BOOL v68 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
                    if (v66 == 30)
                    {
                      if (v68)
                      {
                        int v69 = *(unsigned __int8 *)(a1 + 352);
                        if ((v69 & 0xFE) == 0xFC)
                        {
                          __int16 v70 = "ULA: ";
                        }
                        else if (v69 == 254 && (*(unsigned char *)(a1 + 353) & 0xC0) == 0x80)
                        {
                          __int16 v70 = "LUA: ";
                        }
                        else if ((v69 & 0xE0) == 0x20)
                        {
                          __int16 v70 = "GUA: ";
                        }
                        else
                        {
                          __int16 v70 = "";
                        }
                        *(_DWORD *)buf = 136448771;
                        __int16 v84 = "ioloop_connection_get_address_from_endpoint";
                        __int16 v85 = 2082;
                        *(void *)int v86 = v70;
                        *(_WORD *)&v86[8] = 2160;
                        *(void *)&v86[10] = 1752392040;
                        *(_WORD *)&v86[18] = 1041;
                        *(_DWORD *)&v86[20] = 6;
                        *(_WORD *)&v86[24] = 2097;
                        *(void *)&v86[26] = a1 + 352;
                        *(_WORD *)&v86[34] = 2160;
                        *(void *)&v86[36] = 1752392040;
                        *(_WORD *)&v86[44] = 1042;
                        *(_DWORD *)&v86[46] = 2;
                        *(_WORD *)&v86[50] = 2098;
                        *(void *)&v86[52] = a1 + 358;
                        __int16 v87 = 2160;
                        uint64_t v88 = 1752392040;
                        __int16 v89 = 1041;
                        int v90 = 8;
                        __int16 v91 = 2097;
                        uint64_t v92 = a1 + 360;
                        __int16 v72 = "%{public}s: parsed connection local IPv6 address is: {%{public}s%{private, mask.hash, srp:"
                              "in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, s"
                              "rp:in6_addr_segment}.8P}";
                        int v73 = v67;
                        os_log_type_t v74 = OS_LOG_TYPE_DEFAULT;
                        uint32_t v75 = 100;
                        goto LABEL_113;
                      }
LABEL_114:
                      free(v65);
                      goto LABEL_115;
                    }
                    if (!v68) {
                      goto LABEL_114;
                    }
                    *(_DWORD *)buf = 136446979;
                    __int16 v84 = "ioloop_connection_get_address_from_endpoint";
                    __int16 v85 = 2160;
                    *(void *)int v86 = 1752392040;
                    *(_WORD *)&v86[8] = 1041;
                    *(_DWORD *)&v86[10] = 4;
                    *(_WORD *)&v86[14] = 2097;
                    *(void *)&v86[16] = a1 + 348;
                    __int16 v72 = "%{public}s: parsed connection local IPv4 address is: %{private, mask.hash, network:in_addr}.4P";
                    int v73 = v67;
                    os_log_type_t v74 = OS_LOG_TYPE_DEFAULT;
                    uint32_t v75 = 38;
                  }
                  else
                  {
                    uint64_t v71 = global_os_log;
                    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_114;
                    }
                    *(_DWORD *)buf = 136446210;
                    __int16 v84 = "ioloop_connection_get_address_from_endpoint";
                    __int16 v72 = "%{public}s: unable to get description of new connection.";
                    int v73 = v71;
                    os_log_type_t v74 = OS_LOG_TYPE_ERROR;
                    uint32_t v75 = 12;
                  }
LABEL_113:
                  _os_log_impl((void *)&_mh_execute_header, v73, v74, v72, buf, v75);
                  goto LABEL_114;
                }
                uint32_t v31 = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446210;
                  __int16 v84 = "ioloop_listener_connection_ready";
                  uint64_t v32 = "%{public}s: No memory for connection name.";
                  goto LABEL_100;
                }
LABEL_101:
                ioloop_comm_cancel(a1);
                return;
              }
              if (!v49) {
                goto LABEL_83;
              }
              *(_DWORD *)buf = 136446979;
              __int16 v84 = "ioloop_connection_set_name_from_endpoint";
              __int16 v85 = 2160;
              *(void *)int v86 = 1752392040;
              *(_WORD *)&v86[8] = 1041;
              *(_DWORD *)&v86[10] = 4;
              *(_WORD *)&v86[14] = 2097;
              *(void *)&v86[16] = a1 + 292;
              __int16 v56 = "%{public}s: parsed connection remote IPv4 address is: %{private, mask.hash, network:in_addr}.4P";
              __int16 v57 = v48;
              os_log_type_t v58 = OS_LOG_TYPE_DEFAULT;
              uint32_t v59 = 38;
            }
            else
            {
              uint64_t v55 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
                goto LABEL_83;
              }
              *(_DWORD *)buf = 136446210;
              __int16 v84 = "ioloop_connection_set_name_from_endpoint";
              __int16 v56 = "%{public}s: Unable to get description of new connection.";
              __int16 v57 = v55;
              os_log_type_t v58 = OS_LOG_TYPE_ERROR;
              uint32_t v59 = 12;
            }
LABEL_82:
            _os_log_impl((void *)&_mh_execute_header, v57, v58, v56, buf, v59);
            goto LABEL_83;
          }
          uint32_t v31 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
            goto LABEL_101;
          }
          *(_DWORD *)buf = 136446210;
          __int16 v84 = "ioloop_listener_connection_ready";
          uint64_t v32 = "%{public}s: unable to get interface from local endpoint to check for excluded interface types.";
        }
        else
        {
          uint32_t v31 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
            goto LABEL_101;
          }
          *(_DWORD *)buf = 136446210;
          __int16 v84 = "ioloop_listener_connection_ready";
          uint64_t v32 = "%{public}s: unable to get local endpoint to check for excluded interface types.";
        }
LABEL_100:
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, v32, buf, 0xCu);
        goto LABEL_101;
      }
      uint64_t v17 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v84 = "ioloop_connection_state_changed";
      uint64_t v18 = "%{public}s: ready but canceled";
      uint64_t v19 = v17;
      uint32_t v20 = 12;
LABEL_41:
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, v18, buf, v20);
      return;
    case 1:
      goto LABEL_12;
    case 5:
      __int16 v21 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v22 = *(const char **)(a1 + 192);
        nw_connection_t v23 = *(nw_connection_t *)a1;
        if (!v22) {
          __int16 v22 = "<no name>";
        }
        *(_DWORD *)buf = 136447491;
        __int16 v84 = "ioloop_connection_state_changed";
        __int16 v85 = 2160;
        *(void *)int v86 = 1752392040;
        *(_WORD *)&v86[8] = 2081;
        *(void *)&v86[10] = v22;
        *(_WORD *)&v86[18] = 2048;
        *(void *)&v86[20] = a1;
        *(_WORD *)&v86[28] = 2048;
        *(void *)&v86[30] = v23;
        *(_WORD *)&v86[38] = 2082;
        *(void *)&v86[40] = v82;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%{public}s: %{private, mask.hash}s (%p %p) state is canceled; CFErrorRef error = %{public}s",
          buf,
          0x3Eu);
      }
      __int16 v24 = *(void (**)(uint64_t, void, void))(a1 + 232);
      if (v24) {
        v24(a1, *(void *)(a1 + 200), 0);
      }
      int v25 = *(_DWORD *)(a1 + 32);
      if (v25)
      {
        int v26 = global_os_log;
        if (v25 < 10001)
        {
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447490;
            __int16 v84 = "ioloop_connection_state_changed";
            __int16 v85 = 1024;
            *(_DWORD *)int v86 = v25;
            *(_WORD *)&v86[4] = 2048;
            *(void *)&v86[6] = a1;
            *(_WORD *)&v86[14] = 2080;
            *(void *)&v86[16] = "connection";
            *(_WORD *)&v86[24] = 2080;
            *(void *)&v86[26] = "macos-ioloop.c";
            *(_WORD *)&v86[34] = 1024;
            *(_DWORD *)&v86[36] = 878;
            _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            int v25 = *(_DWORD *)(a1 + 32);
          }
          *(_DWORD *)(a1 + 32) = v25 - 1;
          if (v25 == 1)
          {
            __int16 v27 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)buf = 136447234;
              __int16 v84 = "ioloop_connection_state_changed";
              __int16 v85 = 2048;
              *(void *)int v86 = a1;
              *(_WORD *)&v86[8] = 2080;
              *(void *)&v86[10] = "connection";
              *(_WORD *)&v86[18] = 2080;
              *(void *)&v86[20] = "macos-ioloop.c";
              *(_WORD *)&v86[28] = 1024;
              *(_DWORD *)&v86[30] = 878;
              _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
            }
            ++comm_finalized;
            comm_finalize(a1);
          }
          return;
        }
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_135:
        }
          abort();
        *(_DWORD *)buf = 136447490;
        __int16 v84 = "ioloop_connection_state_changed";
        __int16 v85 = 1024;
        *(_DWORD *)int v86 = v25;
        *(_WORD *)&v86[4] = 2048;
        *(void *)&v86[6] = a1;
        *(_WORD *)&v86[14] = 2080;
        *(void *)&v86[16] = "connection";
        *(_WORD *)&v86[24] = 2080;
        *(void *)&v86[26] = "macos-ioloop.c";
        *(_WORD *)&v86[34] = 1024;
        *(_DWORD *)&v86[36] = 878;
        int v81 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      }
      else
      {
        int v26 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_135;
        }
        *(_DWORD *)buf = 136447490;
        __int16 v84 = "ioloop_connection_state_changed";
        __int16 v85 = 1024;
        *(_DWORD *)int v86 = 0;
        *(_WORD *)&v86[4] = 2048;
        *(void *)&v86[6] = a1;
        *(_WORD *)&v86[14] = 2080;
        *(void *)&v86[16] = "connection";
        *(_WORD *)&v86[24] = 2080;
        *(void *)&v86[26] = "macos-ioloop.c";
        *(_WORD *)&v86[34] = 1024;
        *(_DWORD *)&v86[36] = 878;
        int v81 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      }
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_FAULT, v81, buf, 0x36u);
      goto LABEL_135;
    case 4:
LABEL_12:
      os_log_type_t v13 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        BOOL v14 = *(const char **)(a1 + 192);
        __int16 v84 = "ioloop_connection_state_changed";
        __int16 v85 = 2160;
        if (!v14) {
          BOOL v14 = "<no name>";
        }
        *(void *)int v86 = 1752392040;
        uint64_t v15 = "waiting";
        nw_connection_t v16 = *(nw_connection_t *)a1;
        *(_DWORD *)buf = 136447747;
        *(_WORD *)&v86[8] = 2081;
        if (a2 == 4) {
          uint64_t v15 = "failed";
        }
        *(void *)&v86[10] = v14;
        *(_WORD *)&v86[18] = 2048;
        *(void *)&v86[20] = a1;
        *(_WORD *)&v86[28] = 2048;
        *(void *)&v86[30] = v16;
        *(_WORD *)&v86[38] = 2082;
        *(void *)&v86[40] = v15;
        *(_WORD *)&v86[48] = 2082;
        *(void *)&v86[50] = v82;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: %{private, mask.hash}s (%p %p) state is %{public}s; CFErrorRef error = %{public}s",
          buf,
          0x48u);
      }
      connection_cancel_(a1, *(NSObject **)a1, 870);
      return;
  }
  if (a3) {
    connection_cancel_(a1, *(NSObject **)a1, 882);
  }
  uint64_t v28 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v29 = *(const char **)(a1 + 192);
    nw_connection_t v30 = *(nw_connection_t *)a1;
    if (!v29) {
      int v29 = "<no name>";
    }
    *(_DWORD *)buf = 136447747;
    __int16 v84 = "ioloop_connection_state_changed";
    __int16 v85 = 2160;
    *(void *)int v86 = 1752392040;
    *(_WORD *)&v86[8] = 2081;
    *(void *)&v86[10] = v29;
    *(_WORD *)&v86[18] = 2048;
    *(void *)&v86[20] = a1;
    *(_WORD *)&v86[28] = 2048;
    *(void *)&v86[30] = v30;
    *(_WORD *)&v86[38] = 1024;
    *(_DWORD *)&v86[40] = a2;
    *(_WORD *)&v86[44] = 2082;
    *(void *)&v86[46] = v82;
    uint64_t v18 = "%{public}s: %{private, mask.hash}s (%p %p) state is %d; error = %{public}s";
    uint64_t v19 = v28;
    uint32_t v20 = 68;
    goto LABEL_41;
  }
}

void ioloop_tcp_input_start(uint64_t a1)
{
  if (*(void *)a1)
  {
    uint64_t v2 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v3 = *(_DWORD *)(a1 + 32);
      *(_DWORD *)buf = 136447490;
      unint64_t v11 = "ioloop_tcp_input_start";
      __int16 v12 = 1024;
      int v13 = v3;
      __int16 v14 = 2048;
      uint64_t v15 = a1;
      __int16 v16 = 2080;
      uint64_t v17 = "connection";
      __int16 v18 = 2080;
      uint64_t v19 = "macos-ioloop.c";
      __int16 v20 = 1024;
      int v21 = 802;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    int v4 = *(_DWORD *)(a1 + 32);
    if (v4)
    {
      int v5 = v4 + 1;
      *(_DWORD *)(a1 + 32) = v5;
      if (v5 >= 10001)
      {
        int v8 = v5;
        __int16 v6 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136447490;
          unint64_t v11 = "ioloop_tcp_input_start";
          __int16 v12 = 1024;
          int v13 = v8;
          __int16 v14 = 2048;
          uint64_t v15 = a1;
          __int16 v16 = 2080;
          uint64_t v17 = "connection";
          __int16 v18 = 2080;
          uint64_t v19 = "macos-ioloop.c";
          __int16 v20 = 1024;
          int v21 = 802;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++comm_created;
      *(_DWORD *)(a1 + 32) = 1;
    }
    uint64_t v7 = *(NSObject **)a1;
    completion[0] = _NSConcreteStackBlock;
    completion[1] = 0x40000000;
    completion[2] = __ioloop_tcp_input_start_block_invoke;
    completion[3] = &__block_descriptor_tmp_61;
    completion[4] = a1;
    nw_connection_receive(v7, 2u, 2u, completion);
  }
}

void ioloop_udp_input_start(uint64_t a1)
{
  if (a1)
  {
    uint64_t v2 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v3 = *(_DWORD *)(a1 + 32);
      *(_DWORD *)buf = 136447490;
      unint64_t v11 = "ioloop_udp_input_start";
      __int16 v12 = 1024;
      int v13 = v3;
      __int16 v14 = 2048;
      uint64_t v15 = a1;
      __int16 v16 = 2080;
      uint64_t v17 = "connection";
      __int16 v18 = 2080;
      uint64_t v19 = "macos-ioloop.c";
      __int16 v20 = 1024;
      int v21 = 816;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    int v4 = *(_DWORD *)(a1 + 32);
    if (v4)
    {
      int v5 = v4 + 1;
      *(_DWORD *)(a1 + 32) = v5;
      if (v5 >= 10001)
      {
        int v8 = v5;
        __int16 v6 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136447490;
          unint64_t v11 = "ioloop_udp_input_start";
          __int16 v12 = 1024;
          int v13 = v8;
          __int16 v14 = 2048;
          uint64_t v15 = a1;
          __int16 v16 = 2080;
          uint64_t v17 = "connection";
          __int16 v18 = 2080;
          uint64_t v19 = "macos-ioloop.c";
          __int16 v20 = 1024;
          int v21 = 816;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++comm_created;
      *(_DWORD *)(a1 + 32) = 1;
    }
  }
  uint64_t v7 = *(NSObject **)a1;
  completion[0] = _NSConcreteStackBlock;
  completion[1] = 0x40000000;
  completion[2] = __ioloop_udp_input_start_block_invoke;
  completion[3] = &__block_descriptor_tmp_67;
  completion[4] = a1;
  nw_connection_receive_message(v7, completion);
}

void __ioloop_udp_input_start_block_invoke(uint64_t a1, NSObject *a2, uint64_t a3, int a4, NSObject *a5)
{
  if ((ioloop_connection_input_badness_check(*(void *)(a1 + 32), (uint64_t)a2, a4, a5) & 1) == 0)
  {
    uint64_t v8 = *(void *)(a1 + 32);
    size_t size = dispatch_data_get_size(a2);
    if (datagram_read(v8, size, a2, a5)) {
      ioloop_udp_input_start(*(void *)(a1 + 32));
    }
  }
  uint64_t v10 = *(void *)(a1 + 32);
  if (v10)
  {
    int v11 = *(_DWORD *)(v10 + 32);
    if (v11)
    {
      __int16 v12 = global_os_log;
      if (v11 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v17 = 136447490;
          __int16 v18 = "ioloop_udp_input_start_block_invoke";
          __int16 v19 = 1024;
          *(_DWORD *)__int16 v20 = v11;
          *(_WORD *)&uint8_t v20[4] = 2048;
          *(void *)&v20[6] = v10;
          *(_WORD *)&unsigned char v20[14] = 2080;
          *(void *)&v20[16] = "connection";
          *(_WORD *)&v20[24] = 2080;
          *(void *)&v20[26] = "macos-ioloop.c";
          __int16 v21 = 1024;
          int v22 = 825;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v17, 0x36u);
          uint64_t v10 = *(void *)(a1 + 32);
          int v11 = *(_DWORD *)(v10 + 32);
        }
        *(_DWORD *)(v10 + 32) = v11 - 1;
        if (v11 == 1)
        {
          int v13 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v17 = 136447234;
            __int16 v18 = "ioloop_udp_input_start_block_invoke";
            __int16 v19 = 2048;
            *(void *)__int16 v20 = v10;
            *(_WORD *)&v20[8] = 2080;
            *(void *)&v20[10] = "connection";
            *(_WORD *)&v20[18] = 2080;
            *(void *)&v20[20] = "macos-ioloop.c";
            *(_WORD *)&v20[28] = 1024;
            *(_DWORD *)&v20[30] = 825;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v17, 0x30u);
            uint64_t v10 = *(void *)(a1 + 32);
          }
          ++comm_finalized;
          comm_finalize(v10);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_19:
      }
        abort();
      int v17 = 136447490;
      __int16 v18 = "ioloop_udp_input_start_block_invoke";
      __int16 v19 = 1024;
      *(_DWORD *)__int16 v20 = v11;
      *(_WORD *)&uint8_t v20[4] = 2048;
      *(void *)&v20[6] = v10;
      *(_WORD *)&unsigned char v20[14] = 2080;
      *(void *)&v20[16] = "connection";
      *(_WORD *)&v20[24] = 2080;
      *(void *)&v20[26] = "macos-ioloop.c";
      __int16 v21 = 1024;
      int v22 = 825;
      uint64_t v15 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      __int16 v16 = v12;
    }
    else
    {
      uint64_t v14 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_19;
      }
      int v17 = 136447490;
      __int16 v18 = "ioloop_udp_input_start_block_invoke";
      __int16 v19 = 1024;
      *(_DWORD *)__int16 v20 = 0;
      *(_WORD *)&uint8_t v20[4] = 2048;
      *(void *)&v20[6] = v10;
      *(_WORD *)&unsigned char v20[14] = 2080;
      *(void *)&v20[16] = "connection";
      *(_WORD *)&v20[24] = 2080;
      *(void *)&v20[26] = "macos-ioloop.c";
      __int16 v21 = 1024;
      int v22 = 825;
      uint64_t v15 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      __int16 v16 = v14;
    }
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_FAULT, v15, (uint8_t *)&v17, 0x36u);
    goto LABEL_19;
  }
}

uint64_t ioloop_connection_input_badness_check(uint64_t a1, uint64_t a2, int a3, NSObject *a4)
{
  if (a4)
  {
    connection_error_to_string(a4, (char *)buf);
    int v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = 136446722;
      int v13 = "ioloop_connection_input_badness_check";
      __int16 v14 = 2048;
      uint64_t v15 = a1;
      __int16 v16 = 2082;
      int v17 = buf;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %p: %{public}s", (uint8_t *)&v12, 0x20u);
    }
  }
  else
  {
    if ((*(_WORD *)(a1 + 416) & 0x20) != 0 && a3)
    {
      __int16 v6 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v19 = "ioloop_connection_input_badness_check";
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: remote end closed connection.", buf, 0xCu);
      }
      uint64_t v7 = *(NSObject **)a1;
      uint64_t v8 = a1;
      int v9 = 783;
    }
    else
    {
      if (a2) {
        return 0;
      }
      int v11 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v19 = "ioloop_connection_input_badness_check";
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: remote end closed connection.", buf, 0xCu);
      }
      uint64_t v7 = *(NSObject **)a1;
      uint64_t v8 = a1;
      int v9 = 789;
    }
    connection_cancel_(v8, v7, v9);
  }
  return 1;
}

BOOL datagram_read(uint64_t a1, unint64_t a2, NSObject *a3, NSObject *a4)
{
  unsigned __int8 v21 = 1;
  if (a4)
  {
    uint64_t v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      int error_code = nw_error_get_error_code(a4);
      *(_DWORD *)buf = 136446466;
      nw_connection_t v23 = "datagram_read";
      __int16 v24 = 2082;
      int v25 = strerror(error_code);
      uint64_t v8 = "%{public}s: %{public}s";
LABEL_7:
      uint64_t v10 = v6;
      uint32_t v11 = 22;
LABEL_8:
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, v8, buf, v11);
      goto LABEL_9;
    }
    goto LABEL_9;
  }
  if (a2 >= 0x10000)
  {
    uint64_t v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      nw_connection_t v23 = "datagram_read";
      __int16 v24 = 2048;
      int v25 = (char *)a2;
      uint64_t v8 = "%{public}s: oversized datagram length %zd";
      goto LABEL_7;
    }
LABEL_9:
    unsigned __int8 v21 = 0;
LABEL_10:
    if (*(void *)a1)
    {
      connection_cancel_(a1, *(NSObject **)a1, 668);
      int v12 = v21;
    }
    else
    {
      int v12 = 0;
    }
    return v12 != 0;
  }
  uint64_t v15 = ioloop_message_create_(a2, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/macos-ioloop.c", 605);
  if (!v15)
  {
    uint64_t v19 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_9;
    }
    *(_DWORD *)buf = 136446210;
    nw_connection_t v23 = "datagram_read";
    uint64_t v8 = "%{public}s: unable to allocate message.";
    uint64_t v10 = v19;
    uint32_t v11 = 12;
    goto LABEL_8;
  }
  __int16 v16 = v15;
  *((_WORD *)v15 + 32) = a2;
  applier[0] = _NSConcreteStackBlock;
  applier[1] = 0x40000000;
  applier[2] = __datagram_read_block_invoke;
  applier[3] = &__block_descriptor_tmp_66;
  applier[4] = v15;
  void applier[5] = &v21;
  dispatch_data_apply(a3, applier);
  if (v21)
  {
    long long v17 = *(_OWORD *)(a1 + 344);
    *(_OWORD *)((char *)v16 + 44) = *(_OWORD *)(a1 + 356);
    v16[2] = v17;
    uint64_t v18 = *(void *)(a1 + 24);
    if (!v18) {
      uint64_t v18 = a1;
    }
    (*(void (**)(uint64_t, _OWORD *, void))(v18 + 208))(a1, v16, *(void *)(v18 + 200));
  }
  ioloop_message_release_((int *)v16, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/macos-ioloop.c", 665);
  int v12 = v21;
  if (!v21) {
    goto LABEL_10;
  }
  return v12 != 0;
}

BOOL __datagram_read_block_invoke(uint64_t a1, int a2, uint64_t a3, void *__src, size_t __n)
{
  uint64_t v7 = *(void *)(a1 + 32);
  size_t v8 = *(unsigned __int16 *)(v7 + 64);
  size_t v9 = __n + a3;
  if (__n + a3 > v8)
  {
    uint32_t v11 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      int v13 = 136446978;
      __int16 v14 = "datagram_read_block_invoke";
      __int16 v15 = 2048;
      uint64_t v16 = a3;
      __int16 v17 = 2048;
      size_t v18 = __n;
      __int16 v19 = 1024;
      int v20 = v8;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%{public}s: data region %zd:%zd is out of range for message length %d", (uint8_t *)&v13, 0x26u);
    }
    **(unsigned char **)(a1 + 40) = 0;
  }
  else
  {
    memcpy((void *)(v7 + a3 + 88), __src, __n);
  }
  return v9 <= v8;
}

void __ioloop_tcp_input_start_block_invoke(uint64_t a1, NSObject *a2, uint64_t a3, int a4, NSObject *a5)
{
  if ((ioloop_connection_input_badness_check(*(void *)(a1 + 32), (uint64_t)a2, a4, a5) & 1) == 0)
  {
    uint64_t v8 = *(void *)(a1 + 32);
    if ((check_fail(v8, 2, a2, (uint64_t)a5, (uint64_t)"tcp_read_length") & 1) == 0)
    {
      __int16 v24 = 0;
      size_t size_ptr = 0;
      size_t v9 = dispatch_data_create_map(a2, (const void **)&v24, &size_ptr);
      if (v9)
      {
        dispatch_release(v9);
        unsigned int v10 = *v24;
        if (v8)
        {
          uint32_t v11 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v12 = *(_DWORD *)(v8 + 32);
            *(_DWORD *)buf = 136447490;
            *(void *)&uint8_t buf[4] = "tcp_read_length";
            *(_WORD *)&uint8_t buf[12] = 1024;
            *(_DWORD *)&buf[14] = v12;
            *(_WORD *)&buf[18] = 2048;
            *(void *)&buf[20] = v8;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = "connection";
            *(_WORD *)&unsigned char buf[38] = 2080;
            *(void *)&buf[40] = "macos-ioloop.c";
            __int16 v27 = 1024;
            int v28 = 754;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          }
          int v13 = *(_DWORD *)(v8 + 32);
          if (v13)
          {
            int v14 = v13 + 1;
            *(_DWORD *)(v8 + 32) = v13 + 1;
            if (v13 + 1 >= 10001)
            {
              uint64_t v15 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                goto LABEL_32;
              }
              *(_DWORD *)buf = 136447490;
              *(void *)&uint8_t buf[4] = "tcp_read_length";
              *(_WORD *)&uint8_t buf[12] = 1024;
              *(_DWORD *)&buf[14] = v14;
              *(_WORD *)&buf[18] = 2048;
              *(void *)&buf[20] = v8;
              *(_WORD *)&buf[28] = 2080;
              *(void *)&buf[30] = "connection";
              *(_WORD *)&unsigned char buf[38] = 2080;
              *(void *)&buf[40] = "macos-ioloop.c";
              __int16 v27 = 1024;
              int v28 = 754;
              uint64_t v16 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_28:
              nw_connection_t v23 = v15;
              goto LABEL_31;
            }
          }
          else
          {
            ++comm_created;
            *(_DWORD *)(v8 + 32) = 1;
          }
        }
        size_t v18 = *(NSObject **)v8;
        *(void *)buf = _NSConcreteStackBlock;
        *(void *)&buf[8] = 0x40000000;
        *(void *)&buf[16] = __tcp_read_length_block_invoke;
        *(void *)&buf[24] = &__block_descriptor_tmp_63;
        *(void *)&buf[32] = v8;
        *(_DWORD *)&buf[40] = __rev16(v10);
        nw_connection_receive(v18, *(uint32_t *)&buf[40], *(uint32_t *)&buf[40], buf);
      }
      else
      {
        __int16 v17 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "tcp_read_length";
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, "%{public}s: tcp_read_length: map create failed", buf, 0xCu);
        }
        connection_cancel_(v8, *(NSObject **)v8, 749);
      }
    }
  }
  uint64_t v19 = *(void *)(a1 + 32);
  if (v19)
  {
    int v20 = *(_DWORD *)(v19 + 32);
    if (!v20)
    {
      uint64_t v15 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "ioloop_tcp_input_start_block_invoke";
      *(_WORD *)&uint8_t buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&buf[18] = 2048;
      *(void *)&buf[20] = v19;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "connection";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "macos-ioloop.c";
      __int16 v27 = 1024;
      int v28 = 809;
      uint64_t v16 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_28;
    }
    unsigned __int8 v21 = global_os_log;
    if (v20 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_32;
      }
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "ioloop_tcp_input_start_block_invoke";
      *(_WORD *)&uint8_t buf[12] = 1024;
      *(_DWORD *)&buf[14] = v20;
      *(_WORD *)&buf[18] = 2048;
      *(void *)&buf[20] = v19;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "connection";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "macos-ioloop.c";
      __int16 v27 = 1024;
      int v28 = 809;
      uint64_t v16 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      nw_connection_t v23 = v21;
LABEL_31:
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_FAULT, v16, buf, 0x36u);
LABEL_32:
      abort();
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136447490;
      *(void *)&uint8_t buf[4] = "ioloop_tcp_input_start_block_invoke";
      *(_WORD *)&uint8_t buf[12] = 1024;
      *(_DWORD *)&buf[14] = v20;
      *(_WORD *)&buf[18] = 2048;
      *(void *)&buf[20] = v19;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "connection";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "macos-ioloop.c";
      __int16 v27 = 1024;
      int v28 = 809;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      uint64_t v19 = *(void *)(a1 + 32);
      int v20 = *(_DWORD *)(v19 + 32);
    }
    *(_DWORD *)(v19 + 32) = v20 - 1;
    if (v20 == 1)
    {
      int v22 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "ioloop_tcp_input_start_block_invoke";
        *(_WORD *)&uint8_t buf[12] = 2048;
        *(void *)&buf[14] = v19;
        *(_WORD *)&buf[22] = 2080;
        *(void *)&buf[24] = "connection";
        *(_WORD *)&buf[32] = 2080;
        *(void *)&buf[34] = "macos-ioloop.c";
        *(_WORD *)&buf[42] = 1024;
        *(_DWORD *)&buf[44] = 809;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        uint64_t v19 = *(void *)(a1 + 32);
      }
      ++comm_finalized;
      comm_finalize(v19);
    }
  }
}

uint64_t check_fail(uint64_t a1, uint64_t a2, NSObject *a3, uint64_t a4, uint64_t a5)
{
  unsigned int v10 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = *(void *)(a1 + 192);
    if (a3) {
      size_t size = dispatch_data_get_size(a3);
    }
    else {
      size_t size = -1;
    }
    int v22 = 136448003;
    nw_connection_t v23 = "check_fail";
    __int16 v24 = 2160;
    uint64_t v25 = 1752392040;
    __int16 v26 = 2081;
    uint64_t v27 = v11;
    __int16 v28 = 2048;
    size_t v29 = a2;
    __int16 v30 = 2048;
    uint64_t v31 = (uint64_t)a3;
    __int16 v32 = 2048;
    size_t v33 = size;
    __int16 v34 = 2048;
    uint64_t v35 = a4;
    __int16 v36 = 2080;
    uint64_t v37 = a5;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: %{private, mask.hash}s: length %zd, content %p, content_length %ld, error %p, source %s", (uint8_t *)&v22, 0x52u);
  }
  if (a4) {
    goto LABEL_7;
  }
  if (*(void *)a1)
  {
    if (a3)
    {
      if (dispatch_data_get_size(a3) == a2) {
        return 0;
      }
      uint64_t v19 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      size_t v20 = dispatch_data_get_size(a3);
      size_t v21 = *(void *)(a1 + 192);
      int v22 = 136447491;
      nw_connection_t v23 = "check_fail";
      __int16 v24 = 2082;
      uint64_t v25 = a5;
      __int16 v26 = 2048;
      uint64_t v27 = a2;
      __int16 v28 = 2048;
      size_t v29 = v20;
      __int16 v30 = 2160;
      uint64_t v31 = 1752392040;
      __int16 v32 = 2081;
      size_t v33 = v21;
      uint64_t v16 = "%{public}s: short content returned in %{public}s: %zd != %zd: connection must have dropped unexpectedly for "
            "%{private, mask.hash}s";
      __int16 v17 = v19;
      uint32_t v18 = 62;
    }
    else
    {
      uint64_t v14 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
        goto LABEL_7;
      }
      size_t v15 = *(void *)(a1 + 192);
      int v22 = 136446979;
      nw_connection_t v23 = "check_fail";
      __int16 v24 = 2082;
      uint64_t v25 = a5;
      __int16 v26 = 2160;
      uint64_t v27 = 1752392040;
      __int16 v28 = 2081;
      size_t v29 = v15;
      uint64_t v16 = "%{public}s: no content returned in %{public}s: connection must have dropped unexpectedly for %{private, mask.hash}s";
      __int16 v17 = v14;
      uint32_t v18 = 42;
    }
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, v16, (uint8_t *)&v22, v18);
LABEL_7:
    if (*(void *)a1) {
      connection_cancel_(a1, *(NSObject **)a1, 716);
    }
  }
  return 1;
}

void __tcp_read_length_block_invoke(uint64_t a1, NSObject *a2, uint64_t a3, uint64_t a4, NSObject *a5)
{
  if (a5)
  {
    connection_error_to_string(a5, (char *)buf);
    uint64_t v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      int v18 = 136446722;
      uint64_t v19 = "tcp_read_length_block_invoke";
      __int16 v20 = 2048;
      uint64_t v21 = v7;
      __int16 v22 = 2082;
      nw_connection_t v23 = buf;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: %p: %{public}s", (uint8_t *)&v18, 0x20u);
    }
  }
  else
  {
    uint64_t v9 = *(void *)(a1 + 32);
    unint64_t v10 = *(unsigned int *)(a1 + 40);
    if ((check_fail(v9, v10, a2, 0, (uint64_t)"tcp_read") & 1) == 0 && datagram_read(v9, v10, a2, 0)) {
      ioloop_tcp_input_start(v9);
    }
  }
  uint64_t v11 = *(void *)(a1 + 32);
  if (v11)
  {
    int v12 = *(_DWORD *)(v11 + 32);
    if (v12)
    {
      int v13 = global_os_log;
      if (v12 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447490;
          uint64_t v25 = "tcp_read_length_block_invoke";
          __int16 v26 = 1024;
          *(_DWORD *)uint64_t v27 = v12;
          *(_WORD *)&v27[4] = 2048;
          *(void *)&v27[6] = v11;
          *(_WORD *)&v27[14] = 2080;
          *(void *)&v27[16] = "connection";
          *(_WORD *)&v27[24] = 2080;
          *(void *)&v27[26] = "macos-ioloop.c";
          __int16 v28 = 1024;
          int v29 = 766;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          uint64_t v11 = *(void *)(a1 + 32);
          int v12 = *(_DWORD *)(v11 + 32);
        }
        *(_DWORD *)(v11 + 32) = v12 - 1;
        if (v12 == 1)
        {
          uint64_t v14 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136447234;
            uint64_t v25 = "tcp_read_length_block_invoke";
            __int16 v26 = 2048;
            *(void *)uint64_t v27 = v11;
            *(_WORD *)&v27[8] = 2080;
            *(void *)&v27[10] = "connection";
            *(_WORD *)&v27[18] = 2080;
            *(void *)&v27[20] = "macos-ioloop.c";
            *(_WORD *)&v27[28] = 1024;
            *(_DWORD *)&v27[30] = 766;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
            uint64_t v11 = *(void *)(a1 + 32);
          }
          ++comm_finalized;
          comm_finalize(v11);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_22:
      }
        abort();
      *(_DWORD *)buf = 136447490;
      uint64_t v25 = "tcp_read_length_block_invoke";
      __int16 v26 = 1024;
      *(_DWORD *)uint64_t v27 = v12;
      *(_WORD *)&v27[4] = 2048;
      *(void *)&v27[6] = v11;
      *(_WORD *)&v27[14] = 2080;
      *(void *)&v27[16] = "connection";
      *(_WORD *)&v27[24] = 2080;
      *(void *)&v27[26] = "macos-ioloop.c";
      __int16 v28 = 1024;
      int v29 = 766;
      uint64_t v16 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      __int16 v17 = v13;
    }
    else
    {
      uint64_t v15 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136447490;
      uint64_t v25 = "tcp_read_length_block_invoke";
      __int16 v26 = 1024;
      *(_DWORD *)uint64_t v27 = 0;
      *(_WORD *)&v27[4] = 2048;
      *(void *)&v27[6] = v11;
      *(_WORD *)&v27[14] = 2080;
      *(void *)&v27[16] = "connection";
      *(_WORD *)&v27[24] = 2080;
      *(void *)&v27[26] = "macos-ioloop.c";
      __int16 v28 = 1024;
      int v29 = 766;
      uint64_t v16 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      __int16 v17 = v15;
    }
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, v16, buf, 0x36u);
    goto LABEL_22;
  }
}

void __ioloop_listener_create_block_invoke_2(id a1, nw_protocol_options *a2)
{
  int v3 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136446210;
    int v5 = "ioloop_listener_create_block_invoke_2";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: setting tcp mss to 450", (uint8_t *)&v4, 0xCu);
  }
  nw_tcp_options_set_maximum_segment_size((nw_protocol_options_t)a2, 0x1C2u);
}

void ioloop_listener_context_release(uint64_t a1)
{
  if (!a1) {
    return;
  }
  int v2 = *(_DWORD *)(a1 + 32);
  if (!v2)
  {
    int v3 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v6 = 136447490;
    uint64_t v7 = "ioloop_listener_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)uint64_t v9 = 0;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "listener";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "macos-ioloop.c";
    __int16 v10 = 1024;
    int v11 = 1149;
    int v5 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  int v3 = global_os_log;
  if (v2 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v6 = 136447490;
    uint64_t v7 = "ioloop_listener_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)uint64_t v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "listener";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "macos-ioloop.c";
    __int16 v10 = 1024;
    int v11 = 1149;
    int v5 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, v5, (uint8_t *)&v6, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 136447490;
    uint64_t v7 = "ioloop_listener_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)uint64_t v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "listener";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "macos-ioloop.c";
    __int16 v10 = 1024;
    int v11 = 1149;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v6, 0x36u);
    int v2 = *(_DWORD *)(a1 + 32);
  }
  *(_DWORD *)(a1 + 32) = v2 - 1;
  if (v2 == 1)
  {
    int v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 136447234;
      uint64_t v7 = "ioloop_listener_context_release";
      __int16 v8 = 2048;
      *(void *)uint64_t v9 = a1;
      *(_WORD *)&v9[8] = 2080;
      *(void *)&v9[10] = "listener";
      *(_WORD *)&v9[18] = 2080;
      *(void *)&v9[20] = "macos-ioloop.c";
      *(_WORD *)&v9[28] = 1024;
      *(_DWORD *)&v9[30] = 1149;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v6, 0x30u);
    }
    ++listener_finalized;
    listener_finalize((void *)a1);
  }
}

void ioloop_read_source_finalize(_DWORD *a1)
{
  int v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = a1[23];
    uint64_t v4 = *((void *)a1 + 9);
    uint64_t v5 = *((void *)a1 + 10);
    int v13 = 136447234;
    uint64_t v14 = "ioloop_read_source_finalize";
    __int16 v15 = 2048;
    *(void *)uint64_t v16 = a1;
    *(_WORD *)&v16[8] = 1024;
    *(_DWORD *)&v16[10] = v3;
    *(_WORD *)&unsigned char v16[14] = 2048;
    *(void *)&v16[16] = v4;
    *(_WORD *)&v16[24] = 2048;
    *(void *)&v16[26] = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: io %p fd %d, read source %p, write_source %p", (uint8_t *)&v13, 0x30u);
  }
  if (*((unsigned char *)a1 + 88))
  {
    int v6 = (void (*)(void))*((void *)a1 + 6);
    if (v6) {
      v6(*((void *)a1 + 7));
    }
    ++file_descriptor_finalized;
    return;
  }
  int v7 = *a1;
  if (!*a1)
  {
    __int16 v8 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_25;
    }
    int v13 = 136447490;
    uint64_t v14 = "ioloop_read_source_finalize";
    __int16 v15 = 1024;
    *(_DWORD *)uint64_t v16 = 0;
    *(_WORD *)&v16[4] = 2048;
    *(void *)&v16[6] = a1;
    *(_WORD *)&unsigned char v16[14] = 2080;
    *(void *)&v16[16] = "io";
    *(_WORD *)&v16[24] = 2080;
    *(void *)&v16[26] = "macos-ioloop.c";
    __int16 v17 = 1024;
    int v18 = 2353;
    int v12 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_24;
  }
  __int16 v8 = global_os_log;
  if (v7 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_25;
    }
    int v13 = 136447490;
    uint64_t v14 = "ioloop_read_source_finalize";
    __int16 v15 = 1024;
    *(_DWORD *)uint64_t v16 = v7;
    *(_WORD *)&v16[4] = 2048;
    *(void *)&v16[6] = a1;
    *(_WORD *)&unsigned char v16[14] = 2080;
    *(void *)&v16[16] = "io";
    *(_WORD *)&v16[24] = 2080;
    *(void *)&v16[26] = "macos-ioloop.c";
    __int16 v17 = 1024;
    int v18 = 2353;
    int v12 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_24:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, v12, (uint8_t *)&v13, 0x36u);
LABEL_25:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = 136447490;
    uint64_t v14 = "ioloop_read_source_finalize";
    __int16 v15 = 1024;
    *(_DWORD *)uint64_t v16 = v7;
    *(_WORD *)&v16[4] = 2048;
    *(void *)&v16[6] = a1;
    *(_WORD *)&unsigned char v16[14] = 2080;
    *(void *)&v16[16] = "io";
    *(_WORD *)&v16[24] = 2080;
    *(void *)&v16[26] = "macos-ioloop.c";
    __int16 v17 = 1024;
    int v18 = 2353;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v13, 0x36u);
    int v7 = *a1;
  }
  *a1 = v7 - 1;
  if (v7 == 1)
  {
    uint64_t v9 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v13 = 136447234;
      uint64_t v14 = "ioloop_read_source_finalize";
      __int16 v15 = 2048;
      *(void *)uint64_t v16 = a1;
      *(_WORD *)&v16[8] = 2080;
      *(void *)&v16[10] = "io";
      *(_WORD *)&v16[18] = 2080;
      *(void *)&v16[20] = "macos-ioloop.c";
      *(_WORD *)&v16[28] = 1024;
      *(_DWORD *)&v16[30] = 2353;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v13, 0x30u);
      int v10 = *a1;
      ++file_descriptor_finalized;
      if (v10) {
        return;
      }
    }
    else
    {
      ++file_descriptor_finalized;
    }
    int v11 = (void (*)(void))*((void *)a1 + 4);
    if (v11) {
      v11(*((void *)a1 + 7));
    }
    free(a1);
  }
}

void ioloop_read_source_cancel_callback(uint64_t a1)
{
  int v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(_DWORD *)(a1 + 92);
    uint64_t v4 = *(void *)(a1 + 72);
    uint64_t v5 = *(void *)(a1 + 80);
    int v9 = 136447234;
    int v10 = "ioloop_read_source_cancel_callback";
    __int16 v11 = 2048;
    uint64_t v12 = a1;
    __int16 v13 = 1024;
    int v14 = v3;
    __int16 v15 = 2048;
    uint64_t v16 = v4;
    __int16 v17 = 2048;
    uint64_t v18 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: io %p fd %d, read source %p, write_source %p", (uint8_t *)&v9, 0x30u);
  }
  int v6 = *(NSObject **)(a1 + 72);
  if (v6)
  {
    dispatch_release(v6);
    *(void *)(a1 + 72) = 0;
    int v7 = *(_DWORD *)(a1 + 92);
    if (v7 == -1)
    {
      __int16 v8 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        int v9 = 136446210;
        int v10 = "ioloop_read_source_cancel_callback";
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "%{public}s: io->fd has been set to -1 too early", (uint8_t *)&v9, 0xCu);
      }
    }
    else
    {
      close(v7);
      *(_DWORD *)(a1 + 92) = -1;
    }
  }
}

uint64_t ioloop_read_event(uint64_t result)
{
  __int16 v1 = *(uint64_t (**)(uint64_t, void))(result + 16);
  if (v1) {
    return v1(result, *(void *)(result + 56));
  }
  return result;
}

void __ioloop_connection_create_block_invoke_28(uint64_t a1, int a2, NSObject *a3)
{
}

void ioloop_dnssd_txn_cancel(uint64_t a1)
{
  int v2 = *(_DNSServiceRef_t **)(a1 + 8);
  int v3 = global_os_log;
  BOOL v4 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v4)
    {
      int v5 = 136446722;
      int v6 = "ioloop_dnssd_txn_cancel";
      __int16 v7 = 2048;
      uint64_t v8 = a1;
      __int16 v9 = 2048;
      int v10 = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: txn %p serviceref %p", (uint8_t *)&v5, 0x20u);
      int v2 = *(_DNSServiceRef_t **)(a1 + 8);
    }
    DNSServiceRefDeallocate(v2);
    *(void *)(a1 + 8) = 0;
  }
  else if (v4)
  {
    int v5 = 136446210;
    int v6 = "ioloop_dnssd_txn_cancel";
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: dead transaction.", (uint8_t *)&v5, 0xCu);
  }
}

void ioloop_dnssd_txn_release_(int *a1, char *a2, int a3)
{
  if (!a1) {
    return;
  }
  int v6 = *a1;
  if (!*a1)
  {
    __int16 v7 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_20;
    }
    int v12 = 136447490;
    __int16 v13 = "ioloop_dnssd_txn_release_";
    __int16 v14 = 1024;
    *(_DWORD *)__int16 v15 = 0;
    *(_WORD *)&_OWORD v15[4] = 2048;
    *(void *)&v15[6] = a1;
    *(_WORD *)&v15[14] = 2080;
    *(void *)&v15[16] = "dnssd_txn";
    *(_WORD *)&v15[24] = 2080;
    *(void *)&v15[26] = strrchr(a2, 47) + 1;
    __int16 v16 = 1024;
    int v17 = a3;
    __int16 v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_19;
  }
  __int16 v7 = global_os_log;
  if (v6 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_20;
    }
    int v12 = 136447490;
    __int16 v13 = "ioloop_dnssd_txn_release_";
    __int16 v14 = 1024;
    *(_DWORD *)__int16 v15 = v6;
    *(_WORD *)&_OWORD v15[4] = 2048;
    *(void *)&v15[6] = a1;
    *(_WORD *)&v15[14] = 2080;
    *(void *)&v15[16] = "dnssd_txn";
    *(_WORD *)&v15[24] = 2080;
    *(void *)&v15[26] = strrchr(a2, 47) + 1;
    __int16 v16 = 1024;
    int v17 = a3;
    __int16 v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_19:
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, v11, (uint8_t *)&v12, 0x36u);
LABEL_20:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = 136447490;
    __int16 v13 = "ioloop_dnssd_txn_release_";
    __int16 v14 = 1024;
    *(_DWORD *)__int16 v15 = v6;
    *(_WORD *)&_OWORD v15[4] = 2048;
    *(void *)&v15[6] = a1;
    *(_WORD *)&v15[14] = 2080;
    *(void *)&v15[16] = "dnssd_txn";
    *(_WORD *)&v15[24] = 2080;
    *(void *)&v15[26] = strrchr(a2, 47) + 1;
    __int16 v16 = 1024;
    int v17 = a3;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v12, 0x36u);
    int v6 = *a1;
  }
  *a1 = v6 - 1;
  if (v6 == 1)
  {
    uint64_t v8 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v9 = strrchr(a2, 47);
      int v12 = 136447234;
      __int16 v13 = "ioloop_dnssd_txn_release_";
      __int16 v14 = 2048;
      *(void *)__int16 v15 = a1;
      *(_WORD *)&v15[8] = 2080;
      *(void *)&v15[10] = "dnssd_txn";
      *(_WORD *)&v15[18] = 2080;
      *(void *)&v15[20] = v9 + 1;
      *(_WORD *)&v15[28] = 1024;
      *(_DWORD *)&v15[30] = a3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v12, 0x30u);
    }
    ++dnssd_txn_finalized;
    if (*((void *)a1 + 1)) {
      ioloop_dnssd_txn_cancel((uint64_t)a1);
    }
    int v10 = (void (*)(void))*((void *)a1 + 4);
    if (v10) {
      v10(*((void *)a1 + 2));
    }
    free(a1);
  }
}

void *ioloop_dnssd_txn_add_subordinate_(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, int a5)
{
  int v10 = malloc_type_calloc(1uLL, 0x30uLL, 0x10A004060EFF21DuLL);
  if (v10)
  {
    __int16 v11 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = *(_DWORD *)v10;
      int v19 = 136447490;
      __int16 v20 = "ioloop_dnssd_txn_add_subordinate_";
      __int16 v21 = 1024;
      *(_DWORD *)__int16 v22 = v12;
      *(_WORD *)&v22[4] = 2048;
      *(void *)&v22[6] = v10;
      *(_WORD *)&v22[14] = 2080;
      *(void *)&v22[16] = "txn";
      __int16 v23 = 2080;
      __int16 v24 = strrchr(a4, 47) + 1;
      __int16 v25 = 1024;
      int v26 = a5;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v19, 0x36u);
    }
    int v13 = *(_DWORD *)v10;
    if (*(_DWORD *)v10)
    {
      int v14 = v13 + 1;
      *(_DWORD *)int v10 = v13 + 1;
      if (v13 + 1 >= 10001)
      {
        __int16 v15 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          __int16 v16 = strrchr(a4, 47);
          int v19 = 136447490;
          __int16 v20 = "ioloop_dnssd_txn_add_subordinate_";
          __int16 v21 = 1024;
          *(_DWORD *)__int16 v22 = v14;
          *(_WORD *)&v22[4] = 2048;
          *(void *)&v22[6] = v10;
          *(_WORD *)&v22[14] = 2080;
          *(void *)&v22[16] = "txn";
          __int16 v23 = 2080;
          __int16 v24 = v16 + 1;
          __int16 v25 = 1024;
          int v26 = a5;
          _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v19, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++dnssd_txn_created;
      *(_DWORD *)int v10 = 1;
    }
    v10[1] = a1;
    int v17 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v19 = 136446722;
      __int16 v20 = "ioloop_dnssd_txn_add_subordinate_";
      __int16 v21 = 2048;
      *(void *)__int16 v22 = v10;
      *(_WORD *)&v22[8] = 2048;
      *(void *)&v22[10] = a1;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: txn %p serviceref %p", (uint8_t *)&v19, 0x20u);
    }
    v10[2] = a2;
    v10[4] = a3;
  }
  return v10;
}

void *ioloop_dnssd_txn_add_(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, int a5)
{
  int v6 = ioloop_dnssd_txn_add_subordinate_(a1, a2, a3, a4, a5);
  if (v6)
  {
    if (a1)
    {
      int v7 = *(_DWORD *)(a1 + 16);
      if (v7 < 0 || (*(_DWORD *)(a1 + 20) ^ v7) != 0x12345678)
      {
        syslog(4, "dnssd_clientstub DNSServiceRefSockFD called with invalid DNSServiceRef %p %08X %08X");
      }
      else if (*(void *)(a1 + 8))
      {
        syslog(4, "dnssd_clientstub DNSServiceRefSockFD undefined for kDNSServiceFlagsShareConnection subordinate DNSServiceRef %p");
      }
      else
      {
        uint64_t v9 = ioloop_main_queue;
        if (ioloop_main_queue)
        {
          if (*(void *)(a1 + 96))
          {
            syslog(4, "dnssd_clientstub DNSServiceSetDispatchQueue dispatch queue set already");
          }
          else if (*(void *)(a1 + 88))
          {
            syslog(4, "dnssd_clientstub DNSServiceSetDispatchQueue dispatch source set already");
          }
          else
          {
            int v10 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, *(unsigned int *)(a1 + 16), 0, (dispatch_queue_t)ioloop_main_queue);
            *(void *)(a1 + 88) = v10;
            if (v10)
            {
              *(void *)(a1 + 96) = v9;
              handler[0] = _NSConcreteStackBlock;
              handler[1] = 0x40000000;
              handler[2] = __DNSServiceSetDispatchQueue_block_invoke;
              handler[3] = &__block_descriptor_tmp;
              handler[4] = a1;
              dispatch_source_set_event_handler(v10, handler);
              __int16 v11 = *(NSObject **)(a1 + 88);
              v12[0] = _NSConcreteStackBlock;
              v12[1] = 0x40000000;
              v12[2] = __DNSServiceSetDispatchQueue_block_invoke_2;
              v12[3] = &__block_descriptor_tmp_36;
              int v13 = v7;
              dispatch_source_set_cancel_handler(v11, v12);
              dispatch_resume(*(dispatch_object_t *)(a1 + 88));
            }
            else
            {
              syslog(4, "dnssd_clientstub DNSServiceSetDispatchQueue dispatch_source_create failed");
            }
          }
        }
        else
        {
          syslog(4, "dnssd_clientstub: DNSServiceSetDispatchQueue dispatch queue NULL");
        }
      }
    }
    else
    {
      syslog(4, "dnssd_clientstub DNSServiceRefSockFD called with NULL DNSServiceRef");
    }
  }
  return v6;
}

_xpc_connection_s *ioloop_create_xpc_service(uint64_t a1)
{
  xpc_connection_t mach_service = xpc_connection_create_mach_service("com.apple.srp-mdns-proxy.proxy", (dispatch_queue_t)ioloop_main_queue, 1uLL);
  int v3 = mach_service;
  if (mach_service && xpc_get_type(mach_service) == (xpc_type_t)&_xpc_type_connection)
  {
    handler[0] = _NSConcreteStackBlock;
    handler[1] = 0x40000000;
    handler[2] = __ioloop_create_xpc_service_block_invoke;
    handler[3] = &__block_descriptor_tmp_38;
    handler[4] = "com.apple.srp-mdns-proxy.proxy";
    void handler[5] = adv_xpc_message;
    handler[6] = a1;
    xpc_connection_set_event_handler(v3, handler);
    xpc_connection_resume(v3);
  }
  else
  {
    BOOL v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      uint64_t v8 = "ioloop_create_xpc_service";
      __int16 v9 = 2082;
      int v10 = "com.apple.srp-mdns-proxy.proxy";
      __int16 v11 = 2048;
      int v12 = v3;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%{public}s: ioloop_create_xpc_service: %{public}s: unable to create listener %p", buf, 0x20u);
    }
    if (v3)
    {
      xpc_release(v3);
      return 0;
    }
  }
  return v3;
}

void __ioloop_create_xpc_service_block_invoke(uint64_t a1, xpc_object_t object)
{
  xpc_type_t type = xpc_get_type(object);
  if (type != (xpc_type_t)&_xpc_type_connection)
  {
    int v5 = global_os_log;
    if (type != (xpc_type_t)&_xpc_type_error)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "ioloop_create_xpc_service_block_invoke";
      int v6 = "%{public}s: Unknown EventMsg type";
      int v7 = v5;
      os_log_type_t v8 = OS_LOG_TYPE_DEFAULT;
      goto LABEL_20;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "ioloop_create_xpc_service_block_invoke";
      *(_WORD *)&uint8_t buf[12] = 2082;
      *(void *)&buf[14] = xpc_dictionary_get_string(object, _xpc_error_key_description);
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "%{public}s: ioloop_create_xpc_service: XPCError: %{public}s", buf, 0x16u);
    }
    (*(void (**)(void, void, void))(a1 + 40))(0, 0, *(void *)(a1 + 48));
    return;
  }
  __int16 v9 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = *(void *)(a1 + 32);
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "ioloop_create_xpc_service_block_invoke";
    *(_WORD *)&uint8_t buf[12] = 2082;
    *(void *)&buf[14] = v10;
    *(_WORD *)&buf[22] = 2048;
    *(void *)&long long v24 = object;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: New %{public}s Client %p", buf, 0x20u);
  }
  if (!object)
  {
    uint64_t v18 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "ioloop_xpc_accept";
    int v6 = "%{public}s: ioloop_xpc_accept: listener has been canceled.";
LABEL_19:
    int v7 = v18;
    os_log_type_t v8 = OS_LOG_TYPE_ERROR;
LABEL_20:
    _os_log_impl((void *)&_mh_execute_header, v7, v8, v6, buf, 0xCu);
    return;
  }
  uint64_t v11 = *(void *)(a1 + 32);
  int8x16_t v22 = *(int8x16_t *)(a1 + 40);
  int v12 = malloc_type_calloc(1uLL, 0x10uLL, 0xA0040AFF93C70uLL);
  if (!v12)
  {
    uint64_t v18 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "ioloop_xpc_accept";
    int v6 = "%{public}s: ioloop_xpc_accept: no memory for xpc connection state.";
    goto LABEL_19;
  }
  int v13 = v12;
  pid_t pid = xpc_connection_get_pid((xpc_connection_t)object);
  uid_t euid = xpc_connection_get_euid((xpc_connection_t)object);
  __int16 v16 = (void *)xpc_connection_copy_entitlement_value();
  if (v16)
  {
    int v17 = v16;
    if (xpc_get_type(v16) == (xpc_type_t)&_xpc_type_BOOL)
    {
      BOOL value = xpc_BOOL_get_value(v17);
      xpc_release(v17);
      if (value)
      {
        void *v13 = object;
        xpc_retain(object);
        v13[1] = v22.i64[0];
        xpc_connection_set_target_queue((xpc_connection_t)object, (dispatch_queue_t)ioloop_main_queue);
        *(void *)buf = _NSConcreteStackBlock;
        *(void *)&buf[8] = 0x40000000;
        *(void *)&buf[16] = __ioloop_xpc_accept_block_invoke;
        *(void *)&long long v24 = &__block_descriptor_tmp_68;
        *((void *)&v24 + 1) = v13;
        int8x16_t v25 = vextq_s8(v22, v22, 8uLL);
        xpc_connection_set_event_handler((xpc_connection_t)object, buf);
        xpc_connection_resume((xpc_connection_t)object);
        return;
      }
    }
    else
    {
      xpc_release(v17);
    }
  }
  else
  {
    int v19 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "ioloop_xpc_client_is_entitled";
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "%{public}s: ioloop_xpc_client_is_entitled: Client Entitlement is NULL", buf, 0xCu);
    }
  }
  __int16 v21 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "ioloop_xpc_client_is_entitled";
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%{public}s: ioloop_xpc_client_is_entitled: Client is missing Entitlement!", buf, 0xCu);
    __int16 v21 = global_os_log;
  }
  if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "ioloop_xpc_accept";
    *(_WORD *)&uint8_t buf[12] = 1024;
    *(_DWORD *)&buf[14] = euid;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = pid;
    LOWORD(v24) = 2082;
    *(void *)((char *)&v24 + 2) = v11;
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%{public}s: ioloop_xpc_accept: connection from uid %d pid %d is missing entitlement %{public}s.", buf, 0x22u);
  }
  xpc_connection_cancel((xpc_connection_t)object);
  free(v13);
}

void __ioloop_xpc_accept_block_invoke(uint64_t a1, xpc_object_t object)
{
  xpc_type_t type = xpc_get_type(object);
  if (object == &_xpc_error_connection_invalid)
  {
    int v7 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = 136446210;
      __int16 v16 = "ioloop_xpc_accept_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ioloop_xpc_accept event handler: connection has been finalized.", (uint8_t *)&v15, 0xCu);
    }
    os_log_type_t v8 = *(xpc_object_t **)(a1 + 32);
    __int16 v9 = (void (*)(void, void, void))v8[1];
    if (v9)
    {
      v9(*v8, 0, *(void *)(a1 + 40));
      os_log_type_t v8 = *(xpc_object_t **)(a1 + 32);
    }
    if (*v8)
    {
      xpc_release(*v8);
      **(void **)(a1 + 32) = 0;
      os_log_type_t v8 = *(xpc_object_t **)(a1 + 32);
    }
    free(v8);
  }
  else
  {
    if (type != (xpc_type_t)&_xpc_type_dictionary)
    {
      int v5 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v15 = 136446210;
        __int16 v16 = "ioloop_xpc_accept_block_invoke";
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ioloop_xpc_accept event handler: client went away.", (uint8_t *)&v15, 0xCu);
      }
      xpc_connection_cancel(**(xpc_connection_t **)(a1 + 32));
      int v6 = *(void **)(a1 + 32);
      if (!v6[1]) {
        goto LABEL_22;
      }
      (*(void (**)(void, void, void))(a1 + 48))(*v6, 0, *(void *)(a1 + 40));
LABEL_21:
      int v6 = *(void **)(a1 + 32);
LABEL_22:
      v6[1] = 0;
      return;
    }
    uint64_t v10 = *(void **)(a1 + 32);
    uint64_t v11 = (uint64_t (*)(void, xpc_object_t, void))v10[1];
    if (!v11) {
      return;
    }
    char v12 = v11(*v10, object, *(void *)(a1 + 40));
    int v13 = global_os_log;
    BOOL v14 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
    if ((v12 & 1) == 0)
    {
      if (v14)
      {
        int v15 = 136446210;
        __int16 v16 = "ioloop_xpc_accept_block_invoke";
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ioloop_xpc_accept event handler: callback indicated done.", (uint8_t *)&v15, 0xCu);
      }
      xpc_connection_cancel(**(xpc_connection_t **)(a1 + 32));
      goto LABEL_21;
    }
    if (v14)
    {
      int v15 = 136446210;
      __int16 v16 = "ioloop_xpc_accept_block_invoke";
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ioloop_xpc_accept event handler: continuing.", (uint8_t *)&v15, 0xCu);
    }
  }
}

uint64_t __ioloop_run_async_block_invoke(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(a1 + 32))(*(void *)(a1 + 40));
  int v3 = *(uint64_t (**)(uint64_t))(a1 + 48);
  if (v3)
  {
    uint64_t v4 = *(void *)(a1 + 40);
    return v3(v4);
  }
  return result;
}

void service_tracker_finalize(void *a1)
{
  uint64_t v2 = a1[6];
  if (v2)
  {
    do
    {
      uint64_t v3 = *(void *)(v2 + 8);
      thread_service_release_((int *)v2, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-tracker.c", 83);
      uint64_t v2 = v3;
    }
    while (v3);
  }

  free(a1);
}

void service_tracker_start(void *a1)
{
  uint64_t v3 = a1 + 4;
  uint64_t v2 = a1[4];
  if (v2)
  {
    cti_events_discontinue(v2);
    *uint64_t v3 = 0;
    uint64_t v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = a1[1];
      *(_DWORD *)buf = 136446466;
      __int16 v23 = "service_tracker_start";
      __int16 v24 = 2048;
      *(void *)int8x16_t v25 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: [ST%lld] restarting", buf, 0x16u);
    }
    int v6 = *(_DWORD *)a1;
    if (*(_DWORD *)a1 == 1)
    {
      __int16 v9 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v23 = "service_tracker_start";
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "%{public}s: service tracker reference count should not be 1 here!", buf, 0xCu);
      }
    }
    else
    {
      if (!v6)
      {
        uint64_t v19 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_34;
        }
        *(_DWORD *)buf = 136447490;
        __int16 v23 = "service_tracker_start";
        __int16 v24 = 1024;
        *(_DWORD *)int8x16_t v25 = 0;
        *(_WORD *)&v25[4] = 2048;
        *(void *)&v25[6] = a1;
        *(_WORD *)&v25[14] = 2080;
        *(void *)&v25[16] = "tracker";
        *(_WORD *)&v25[24] = 2080;
        *(void *)&v25[26] = "service-tracker.c";
        __int16 v26 = 1024;
        int v27 = 382;
        __int16 v20 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_30:
        __int16 v21 = v19;
LABEL_33:
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_FAULT, v20, buf, 0x36u);
        goto LABEL_34;
      }
      int v7 = global_os_log;
      if (v6 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_34;
        }
        *(_DWORD *)buf = 136447490;
        __int16 v23 = "service_tracker_start";
        __int16 v24 = 1024;
        *(_DWORD *)int8x16_t v25 = v6;
        *(_WORD *)&v25[4] = 2048;
        *(void *)&v25[6] = a1;
        *(_WORD *)&v25[14] = 2080;
        *(void *)&v25[16] = "tracker";
        *(_WORD *)&v25[24] = 2080;
        *(void *)&v25[26] = "service-tracker.c";
        __int16 v26 = 1024;
        int v27 = 382;
        __int16 v20 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        __int16 v21 = v7;
        goto LABEL_33;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        __int16 v23 = "service_tracker_start";
        __int16 v24 = 1024;
        *(_DWORD *)int8x16_t v25 = v6;
        *(_WORD *)&v25[4] = 2048;
        *(void *)&v25[6] = a1;
        *(_WORD *)&v25[14] = 2080;
        *(void *)&v25[16] = "tracker";
        *(_WORD *)&v25[24] = 2080;
        *(void *)&v25[26] = "service-tracker.c";
        __int16 v26 = 1024;
        int v27 = 382;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        int v6 = *(_DWORD *)a1;
      }
      *(_DWORD *)a1 = v6 - 1;
      if (v6 == 1)
      {
        os_log_type_t v8 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          __int16 v23 = "service_tracker_start";
          __int16 v24 = 2048;
          *(void *)int8x16_t v25 = a1;
          *(_WORD *)&v25[8] = 2080;
          *(void *)&v25[10] = "tracker";
          *(_WORD *)&v25[18] = 2080;
          *(void *)&v25[20] = "service-tracker.c";
          *(_WORD *)&v25[28] = 1024;
          *(_DWORD *)&v25[30] = 382;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        }
        ++service_tracker_finalized;
        service_tracker_finalize(a1);
      }
    }
  }
  xpc_object_t v10 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v10, "interface", "org.wpantund.v1");
  xpc_dictionary_set_string(v10, "path", "/org/wpantund/utun2");
  xpc_dictionary_set_string(v10, "method", "PropGet");
  xpc_dictionary_set_string(v10, "property_name", "Thread:Services");
  int v11 = setup_for_command(v3, (uint64_t)"get_service_list", "Thread:Services", 0, v10, (uint64_t)a1, (uint64_t)service_tracker_callback, (uint64_t)cti_internal_service_reply_callback, 0, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-tracker.c", 388);
  xpc_release(v10);
  char v12 = global_os_log;
  BOOL v13 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (!v11)
  {
    if (v13)
    {
      uint64_t v15 = a1[1];
      *(_DWORD *)buf = 136446466;
      __int16 v23 = "service_tracker_start";
      __int16 v24 = 2048;
      *(void *)int8x16_t v25 = v15;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: [ST%lld] service list get started", buf, 0x16u);
      char v12 = global_os_log;
    }
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = *(_DWORD *)a1;
      *(_DWORD *)buf = 136447490;
      __int16 v23 = "service_tracker_start";
      __int16 v24 = 1024;
      *(_DWORD *)int8x16_t v25 = v16;
      *(_WORD *)&v25[4] = 2048;
      *(void *)&v25[6] = a1;
      *(_WORD *)&v25[14] = 2080;
      *(void *)&v25[16] = "tracker";
      *(_WORD *)&v25[24] = 2080;
      *(void *)&v25[26] = "service-tracker.c";
      __int16 v26 = 1024;
      int v27 = 394;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    int v17 = *(_DWORD *)a1;
    if (!*(_DWORD *)a1)
    {
      ++service_tracker_created;
      *(_DWORD *)a1 = 1;
      return;
    }
    int v18 = v17 + 1;
    *(_DWORD *)a1 = v17 + 1;
    if (v17 + 1 < 10001) {
      return;
    }
    uint64_t v19 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_34:
    }
      abort();
    *(_DWORD *)buf = 136447490;
    __int16 v23 = "service_tracker_start";
    __int16 v24 = 1024;
    *(_DWORD *)int8x16_t v25 = v18;
    *(_WORD *)&v25[4] = 2048;
    *(void *)&v25[6] = a1;
    *(_WORD *)&v25[14] = 2080;
    *(void *)&v25[16] = "tracker";
    *(_WORD *)&v25[24] = 2080;
    *(void *)&v25[26] = "service-tracker.c";
    __int16 v26 = 1024;
    int v27 = 394;
    __int16 v20 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
    goto LABEL_30;
  }
  if (v13)
  {
    uint64_t v14 = a1[1];
    *(_DWORD *)buf = 136446722;
    __int16 v23 = "service_tracker_start";
    __int16 v24 = 2048;
    *(void *)int8x16_t v25 = v14;
    *(_WORD *)&v25[8] = 1024;
    *(_DWORD *)&v25[10] = v11;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: [ST%lld] service list get failed: %d", buf, 0x1Cu);
  }
}

void service_tracker_callback(uint64_t a1, unint64_t *a2, int a3)
{
  *(unsigned char *)(a1 + 58) = 0;
  if (a3 == -65569 || a3 == -65563)
  {
    __int16 v21 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v22 = *(void *)(a1 + 8);
      *(_DWORD *)__str = 136446466;
      *(void *)&char __str[4] = "service_tracker_callback";
      *(_WORD *)&__str[12] = 2048;
      *(void *)&__str[14] = v22;
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%{public}s: [ST%lld] disconnected", (uint8_t *)__str, 0x16u);
    }
    cti_events_discontinue(*(void *)(a1 + 32));
    *(void *)(a1 + 32) = 0;
    int v23 = *(_DWORD *)a1;
    if (*(_DWORD *)a1)
    {
      __int16 v24 = global_os_log;
      if (v23 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__str = 136447490;
          *(void *)&char __str[4] = "service_tracker_callback";
          *(_WORD *)&__str[12] = 1024;
          *(_DWORD *)&__str[14] = v23;
          *(_WORD *)&__str[18] = 2048;
          *(void *)&char __str[20] = a1;
          *(_WORD *)&__str[28] = 2080;
          *(void *)&__str[30] = "tracker";
          *(_WORD *)&__str[38] = 2080;
          *(void *)&__str[40] = "service-tracker.c";
          __int16 v52 = 1024;
          int v53 = 148;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)__str, 0x36u);
          int v23 = *(_DWORD *)a1;
        }
        *(_DWORD *)a1 = v23 - 1;
        if (v23 == 1)
        {
          int8x16_t v25 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)__str = 136447234;
            *(void *)&char __str[4] = "service_tracker_callback";
            *(_WORD *)&__str[12] = 2048;
            *(void *)&__str[14] = a1;
            *(_WORD *)&__str[22] = 2080;
            *(void *)&__str[24] = "tracker";
            *(_WORD *)&__str[32] = 2080;
            *(void *)&__str[34] = "service-tracker.c";
            *(_WORD *)&__str[42] = 1024;
            *(_DWORD *)&__str[44] = 148;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)__str, 0x30u);
          }
          ++service_tracker_finalized;
          service_tracker_finalize((void *)a1);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_140:
      }
        abort();
      *(_DWORD *)__str = 136447490;
      *(void *)&char __str[4] = "service_tracker_callback";
      *(_WORD *)&__str[12] = 1024;
      *(_DWORD *)&__str[14] = v23;
      *(_WORD *)&__str[18] = 2048;
      *(void *)&char __str[20] = a1;
      *(_WORD *)&__str[28] = 2080;
      *(void *)&__str[30] = "tracker";
      *(_WORD *)&__str[38] = 2080;
      *(void *)&__str[40] = "service-tracker.c";
      __int16 v52 = 1024;
      int v53 = 148;
      int v50 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      __int16 v24 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_140;
      }
      *(_DWORD *)__str = 136447490;
      *(void *)&char __str[4] = "service_tracker_callback";
      *(_WORD *)&__str[12] = 1024;
      *(_DWORD *)&__str[14] = 0;
      *(_WORD *)&__str[18] = 2048;
      *(void *)&char __str[20] = a1;
      *(_WORD *)&__str[28] = 2080;
      *(void *)&__str[30] = "tracker";
      *(_WORD *)&__str[38] = 2080;
      *(void *)&__str[40] = "service-tracker.c";
      __int16 v52 = 1024;
      int v53 = 148;
      int v50 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_FAULT, v50, (uint8_t *)__str, 0x36u);
    goto LABEL_140;
  }
  if (a3)
  {
    __int16 v26 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      uint64_t v27 = *(void *)(a1 + 8);
      *(_DWORD *)__str = 136446722;
      *(void *)&char __str[4] = "service_tracker_callback";
      *(_WORD *)&__str[12] = 2048;
      *(void *)&__str[14] = v27;
      *(_WORD *)&__str[22] = 1024;
      *(_DWORD *)&__str[24] = a3;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "%{public}s: [ST%lld] %d", (uint8_t *)__str, 0x1Cu);
    }
  }
  else
  {
    int v6 = (uint64_t *)(a1 + 48);
    uint64_t v7 = *(void *)(a1 + 48);
    os_log_type_t v8 = (uint64_t *)(a1 + 48);
    if (v7)
    {
      os_log_type_t v8 = (uint64_t *)(a1 + 48);
      do
      {
        int v9 = *(_DWORD *)(v7 + 20);
        switch(v9)
        {
          case 1:
            unint64_t v10 = *a2;
            if (!*a2) {
              goto LABEL_45;
            }
            uint64_t v11 = 0;
            while (1)
            {
              uint64_t v16 = *(void *)(a2[2] + 8 * v11);
              if (*(void *)v16 == 44970
                && *(_WORD *)(v16 + 8) == 157
                && *(_WORD *)(v16 + 10) == 1
                && *(void *)(v16 + 40) == 9)
              {
                uint64_t v17 = *(void *)(v16 + 24);
                if (*(_DWORD *)(v7 + 64) == *(_DWORD *)v17)
                {
                  int v18 = *(_DWORD *)(v17 + 4);
                  int v19 = *(unsigned __int8 *)(v17 + 8);
                  if (*(_DWORD *)(v7 + 68) == v18 && *(unsigned __int8 *)(v7 + 72) == v19) {
                    break;
                  }
                }
              }
              if (v10 == ++v11) {
                goto LABEL_45;
              }
            }
            break;
          case 2:
            unint64_t v10 = *a2;
            if (!*a2) {
              goto LABEL_45;
            }
            uint64_t v11 = 0;
            while (1)
            {
              uint64_t v13 = *(void *)(a2[2] + 8 * v11);
              if (*(void *)v13 == 44970
                && *(_WORD *)(v13 + 8) == 93
                && *(_WORD *)(v13 + 10) == 1
                && *(void *)(v13 + 40) == 18)
              {
                uint64_t v14 = *(void *)(v13 + 24);
                BOOL v15 = *(void *)(v7 + 64) == *(void *)v14 && *(void *)(v7 + 72) == *(void *)(v14 + 8);
                if (v15 && *(unsigned __int16 *)(v7 + 80) == *(unsigned __int16 *)(v14 + 16)) {
                  break;
                }
              }
              if (v10 == ++v11) {
                goto LABEL_45;
              }
            }
            break;
          case 3:
            unint64_t v10 = *a2;
            if (!*a2) {
              goto LABEL_45;
            }
            uint64_t v11 = 0;
            while (1)
            {
              uint64_t v12 = *(void *)(a2[2] + 8 * v11);
              if (*(void *)v12 == 44970
                && *(_WORD *)(v12 + 8) == 92
                && *(_WORD *)(v12 + 10) == 1
                && *(void *)(v12 + 32) == 2
                && *(unsigned __int16 *)(v7 + 16) == *(unsigned __int16 *)(v12 + 12)
                && *(unsigned __int8 *)(v7 + 80) == *(unsigned __int8 *)(*(void *)(v12 + 16) + 1))
              {
                break;
              }
              if (v10 == ++v11) {
                goto LABEL_45;
              }
            }
            break;
          default:
            goto LABEL_45;
        }
        if (v11 != v10)
        {
          *(unsigned char *)(v7 + 29) = *(unsigned char *)(v7 + 24);
          *(_WORD *)(v7 + 30) = *(_WORD *)(v7 + 25);
          os_log_type_t v8 = (uint64_t *)(v7 + 8);
          *(_DWORD *)(v7 + 24) = 0;
          goto LABEL_46;
        }
LABEL_45:
        snprintf(__str, 0x14uLL, "[ST%lld]", *(void *)(a1 + 8));
        thread_service_note((uint64_t)__str, v7, (uint64_t)"went away");
        *os_log_type_t v8 = *(void *)(v7 + 8);
        thread_service_release_((int *)v7, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-tracker.c", 218);
LABEL_46:
        uint64_t v7 = *v8;
      }
      while (*v8);
    }
    if (*a2)
    {
      for (unint64_t i = 0; i < *a2; ++i)
      {
        int v29 = *(uint64_t **)(a2[2] + 8 * i);
        uint64_t v30 = *v6;
        uint64_t v31 = *v29;
        while (v30)
        {
          if (v31 == 44970)
          {
            int v32 = *((unsigned __int16 *)v29 + 4);
            if (v32 == 92)
            {
              if (*((_WORD *)v29 + 5) == 1
                && v29[4] == 2
                && *(_DWORD *)(v30 + 20) == 3
                && *(unsigned __int16 *)(v30 + 16) == *((unsigned __int16 *)v29 + 6))
              {
                int v36 = *(unsigned __int8 *)(v29[2] + 1);
                int v35 = *(unsigned __int8 *)(v30 + 80);
LABEL_93:
                if (v35 == v36) {
                  goto LABEL_110;
                }
              }
            }
            else if (v32 == 157)
            {
              if (*((_WORD *)v29 + 5) == 1 && v29[5] == 9 && *(_DWORD *)(v30 + 20) == 1)
              {
                uint64_t v37 = v29[3];
                if (*(_DWORD *)(v30 + 64) == *(_DWORD *)v37)
                {
                  int v38 = *(_DWORD *)(v37 + 4);
                  int v39 = *(unsigned __int8 *)(v37 + 8);
                  if (*(_DWORD *)(v30 + 68) == v38 && *(unsigned __int8 *)(v30 + 72) == v39) {
                    goto LABEL_110;
                  }
                }
              }
            }
            else if (v32 == 93 && *((_WORD *)v29 + 5) == 1 && v29[5] == 18 && *(_DWORD *)(v30 + 20) == 2)
            {
              uint64_t v33 = v29[3];
              if (*(void *)(v30 + 64) == *(void *)v33 && *(void *)(v30 + 72) == *(void *)(v33 + 8))
              {
                int v35 = *(unsigned __int16 *)(v30 + 80);
                int v36 = *(unsigned __int16 *)(v33 + 16);
                goto LABEL_93;
              }
            }
          }
          uint64_t v30 = *(void *)(v30 + 8);
        }
        if (v31 == 44970)
        {
          int v41 = *((unsigned __int16 *)v29 + 4);
          if (v41 == 92)
          {
            if (*((_WORD *)v29 + 5) != 1 || v29[4] != 2) {
              continue;
            }
            int v42 = thread_service_anycast_create_(*((_WORD *)v29 + 6), *(unsigned char *)(v29[2] + 1), *((unsigned char *)v29 + 14), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-tracker.c", 269);
          }
          else if (v41 == 157)
          {
            if (*((_WORD *)v29 + 5) != 1 || v29[5] != 9) {
              continue;
            }
            int v42 = thread_service_pref_id_create_(*((_WORD *)v29 + 6), (_DWORD *)v29[3], (int *)(v29[3] + 4), *((unsigned char *)v29 + 14), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-tracker.c", 277);
          }
          else
          {
            if (v41 != 93 || *((_WORD *)v29 + 5) != 1 || v29[5] != 18) {
              continue;
            }
            int v42 = thread_service_unicast_create_(*((_WORD *)v29 + 6), (_OWORD *)v29[3], (_WORD *)(v29[3] + 16), *((unsigned char *)v29 + 14), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-tracker.c", 261);
          }
          uint64_t v30 = (uint64_t)v42;
          if (!v42)
          {
            uint64_t v44 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            {
              uint64_t v45 = *(void *)(a1 + 8);
              *(_DWORD *)__str = 136446466;
              *(void *)&char __str[4] = "service_tracker_callback";
              *(_WORD *)&__str[12] = 2048;
              *(void *)&__str[14] = v45;
              _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_ERROR, "%{public}s: [ST%lld] no memory for service.", (uint8_t *)__str, 0x16u);
            }
            continue;
          }
          snprintf(__str, 0x14uLL, "[ST%lld]", *(void *)(a1 + 8));
          thread_service_note((uint64_t)__str, v30, (uint64_t)"showed up");
          *os_log_type_t v8 = v30;
          os_log_type_t v8 = (uint64_t *)(v30 + 8);
LABEL_110:
          int v43 = *((_DWORD *)v29 + 13);
          if ((v43 & 2) == 0)
          {
            *(unsigned char *)(v30 + 24) = 1;
            *(unsigned char *)(a1 + 58) = 1;
            if ((v43 & 1) == 0) {
              continue;
            }
LABEL_114:
            *(unsigned char *)(v30 + 26) = 1;
            continue;
          }
          *(unsigned char *)(v30 + 25) = 1;
          if (v43) {
            goto LABEL_114;
          }
        }
      }
    }
    memset(__str, 0, sizeof(__str));
    for (uint64_t j = *v6; j; uint64_t j = *(void *)(j + 8))
    {
      if (*(_DWORD *)(j + 20) == 2)
      {
        *(unsigned char *)(j + 82) = 0;
        for (uint64_t k = *v6; k; uint64_t k = *(void *)(k + 8))
        {
          if (*(_DWORD *)(k + 20) == 3 && *(unsigned __int16 *)(k + 16) == *(unsigned __int16 *)(j + 16)) {
            *(unsigned char *)(j + 82) = 1;
          }
        }
      }
      memset(__str, 0, 24);
      *(void *)&__str[24] = __str;
      *(_OWORD *)&__str[32] = 0x14uLL;
      service_tracker_flags_accumulate((size_t)__str, *(unsigned __int8 *)(j + 30), *(unsigned __int8 *)(j + 25), "ncp");
      service_tracker_flags_accumulate((size_t)__str, *(unsigned __int8 *)(j + 31), *(unsigned __int8 *)(j + 25), "stable");
      service_tracker_flags_accumulate((size_t)__str, *(unsigned __int8 *)(j + 29), *(unsigned __int8 *)(j + 24), "user");
      if (__str[40])
      {
        snprintf(v54, 0x14uLL, "[ST%lld]", *(void *)(a1 + 8));
        thread_service_note((uint64_t)v54, j, (uint64_t)__str);
      }
    }
    for (unint64_t m = *(uint64_t ***)(a1 + 40); m; unint64_t m = (uint64_t **)*m)
      ((void (*)(uint64_t *))m[2])(m[3]);
    if (!*(unsigned char *)(a1 + 58))
    {
      uint64_t v49 = *(void *)(a1 + 24);
      if (v49)
      {
        if (*(unsigned char *)(v49 + 284))
        {
          *(unsigned char *)(v49 + 284) = 0;
          adv_ctl_thread_shutdown_continue(v49);
        }
      }
    }
  }
}

size_t service_tracker_flags_accumulate(size_t result, int a2, int a3, const char *a4)
{
  if (a2 != a3)
  {
    size_t v4 = result;
    uint64_t v5 = *(char **)(result + 24);
    int v6 = " ";
    if (v5 == (char *)v4) {
      int v6 = "";
    }
    uint64_t v7 = "-";
    if (a3) {
      uint64_t v7 = "+";
    }
    snprintf(v5, *(void *)(v4 + 32), "%s%s%s", v6, v7, a4);
    uint64_t result = strlen(*(const char **)(v4 + 24));
    size_t v8 = *(void *)(v4 + 32) - result;
    *(void *)(v4 + 24) += result;
    *(void *)(v4 + 32) = v8;
    *(unsigned char *)(v4 + 40) = 1;
  }
  return result;
}

BOOL service_tracker_callback_add(int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  size_t v8 = a1 + 10;
  while (1)
  {
    int v9 = (void *)*v8;
    if (!*v8) {
      break;
    }
    size_t v8 = (void *)*v8;
    if (v9[3] == a4)
    {
      uint64_t v10 = global_os_log;
      BOOL result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT);
      if (!result) {
        return result;
      }
      uint64_t v12 = *((void *)a1 + 1);
      int v26 = 136446722;
      uint64_t v27 = "service_tracker_callback_add";
      __int16 v28 = 2048;
      *(void *)int v29 = v12;
      *(_WORD *)&timeval v29[8] = 2048;
      *(void *)&v29[10] = a4;
      uint64_t v13 = "%{public}s: [ST%lld] duplicate context %p";
      uint64_t v14 = v10;
      os_log_type_t v15 = OS_LOG_TYPE_FAULT;
      uint32_t v16 = 32;
LABEL_18:
      _os_log_impl((void *)&_mh_execute_header, v14, v15, v13, (uint8_t *)&v26, v16);
      return 0;
    }
  }
  uint64_t v17 = malloc_type_calloc(1uLL, 0x20uLL, 0xA00403705585FuLL);
  if (!v17)
  {
    uint64_t v24 = global_os_log;
    BOOL result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    uint64_t v25 = *((void *)a1 + 1);
    int v26 = 136446466;
    uint64_t v27 = "service_tracker_callback_add";
    __int16 v28 = 2048;
    *(void *)int v29 = v25;
    uint64_t v13 = "%{public}s: [ST%lld] no memory";
    uint64_t v14 = v24;
    os_log_type_t v15 = OS_LOG_TYPE_ERROR;
    uint32_t v16 = 22;
    goto LABEL_18;
  }
  int v18 = v17;
  v17[1] = a3;
  v17[2] = a2;
  v17[3] = a4;
  if (a1 && !*((void *)a1 + 5))
  {
    int v19 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v20 = *a1;
      int v26 = 136447490;
      uint64_t v27 = "service_tracker_callback_add";
      __int16 v28 = 1024;
      *(_DWORD *)int v29 = v20;
      *(_WORD *)&v29[4] = 2048;
      *(void *)&v29[6] = a1;
      *(_WORD *)&v29[14] = 2080;
      *(void *)&v29[16] = "tracker";
      __int16 v30 = 2080;
      uint64_t v31 = "service-tracker.c";
      __int16 v32 = 1024;
      int v33 = 423;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v26, 0x36u);
    }
    int v21 = *a1;
    if (*a1)
    {
      int v22 = v21 + 1;
      *a1 = v21 + 1;
      if (v21 + 1 >= 10001)
      {
        int v23 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          int v26 = 136447490;
          uint64_t v27 = "service_tracker_callback_add";
          __int16 v28 = 1024;
          *(_DWORD *)int v29 = v22;
          *(_WORD *)&v29[4] = 2048;
          *(void *)&v29[6] = a1;
          *(_WORD *)&v29[14] = 2080;
          *(void *)&v29[16] = "tracker";
          __int16 v30 = 2080;
          uint64_t v31 = "service-tracker.c";
          __int16 v32 = 1024;
          int v33 = 423;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v26, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++service_tracker_created;
      *a1 = 1;
    }
  }
  *size_t v8 = v18;
  return 1;
}

void service_tracker_stop(void *a1)
{
  if (!a1) {
    return;
  }
  uint64_t v2 = a1[4];
  if (!v2) {
    return;
  }
  cti_events_discontinue(v2);
  a1[4] = 0;
  int v3 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    size_t v4 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_17;
    }
    int v7 = 136447490;
    size_t v8 = "service_tracker_stop";
    __int16 v9 = 1024;
    *(_DWORD *)uint64_t v10 = 0;
    *(_WORD *)&v10[4] = 2048;
    *(void *)&v10[6] = a1;
    *(_WORD *)&v10[14] = 2080;
    *(void *)&v10[16] = "tracker";
    *(_WORD *)&v10[24] = 2080;
    *(void *)&v10[26] = "service-tracker.c";
    __int16 v11 = 1024;
    int v12 = 453;
    int v6 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_16;
  }
  size_t v4 = global_os_log;
  if (v3 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_17;
    }
    int v7 = 136447490;
    size_t v8 = "service_tracker_stop";
    __int16 v9 = 1024;
    *(_DWORD *)uint64_t v10 = v3;
    *(_WORD *)&v10[4] = 2048;
    *(void *)&v10[6] = a1;
    *(_WORD *)&v10[14] = 2080;
    *(void *)&v10[16] = "tracker";
    *(_WORD *)&v10[24] = 2080;
    *(void *)&v10[26] = "service-tracker.c";
    __int16 v11 = 1024;
    int v12 = 453;
    int v6 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_16:
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, v6, (uint8_t *)&v7, 0x36u);
LABEL_17:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 136447490;
    size_t v8 = "service_tracker_stop";
    __int16 v9 = 1024;
    *(_DWORD *)uint64_t v10 = v3;
    *(_WORD *)&v10[4] = 2048;
    *(void *)&v10[6] = a1;
    *(_WORD *)&v10[14] = 2080;
    *(void *)&v10[16] = "tracker";
    *(_WORD *)&v10[24] = 2080;
    *(void *)&v10[26] = "service-tracker.c";
    __int16 v11 = 1024;
    int v12 = 453;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v7, 0x36u);
    int v3 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v3 - 1;
  if (v3 == 1)
  {
    uint64_t v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v7 = 136447234;
      size_t v8 = "service_tracker_stop";
      __int16 v9 = 2048;
      *(void *)uint64_t v10 = a1;
      *(_WORD *)&v10[8] = 2080;
      *(void *)&v10[10] = "tracker";
      *(_WORD *)&v10[18] = 2080;
      *(void *)&v10[20] = "service-tracker.c";
      *(_WORD *)&v10[28] = 1024;
      *(_DWORD *)&v10[30] = 453;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v7, 0x30u);
    }
    ++service_tracker_finalized;
    service_tracker_finalize(a1);
  }
}

void service_tracker_callback_cancel(void *a1, uint64_t a2)
{
  if (a1)
  {
    size_t v4 = a1 + 5;
    int v3 = (void *)a1[5];
    if (v3)
    {
      uint64_t v5 = v3 + 3;
      if (v3[3] == a2)
      {
        int v6 = a1 + 5;
      }
      else
      {
        do
        {
          int v6 = v3;
          int v3 = (void *)*v3;
          if (!v3) {
            return;
          }
        }
        while (v3[3] != a2);
        uint64_t v5 = v3 + 3;
      }
      *int v6 = *v3;
      int v7 = (void (*)(void))v3[1];
      if (v7) {
        v7(*v5);
      }
      free(v3);
      if (!*v4)
      {
        int v8 = *(_DWORD *)a1;
        if (*(_DWORD *)a1)
        {
          __int16 v9 = global_os_log;
          if (v8 < 10001)
          {
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              int v12 = 136447490;
              uint64_t v13 = "service_tracker_callback_cancel";
              __int16 v14 = 1024;
              *(_DWORD *)os_log_type_t v15 = v8;
              *(_WORD *)&_OWORD v15[4] = 2048;
              *(void *)&v15[6] = a1;
              *(_WORD *)&v15[14] = 2080;
              *(void *)&v15[16] = "tracker";
              *(_WORD *)&v15[24] = 2080;
              *(void *)&v15[26] = "service-tracker.c";
              __int16 v16 = 1024;
              int v17 = 490;
              _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v12, 0x36u);
              int v8 = *(_DWORD *)a1;
            }
            *(_DWORD *)a1 = v8 - 1;
            if (v8 == 1)
            {
              uint64_t v10 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                int v12 = 136447234;
                uint64_t v13 = "service_tracker_callback_cancel";
                __int16 v14 = 2048;
                *(void *)os_log_type_t v15 = a1;
                *(_WORD *)&v15[8] = 2080;
                *(void *)&v15[10] = "tracker";
                *(_WORD *)&v15[18] = 2080;
                *(void *)&v15[20] = "service-tracker.c";
                *(_WORD *)&v15[28] = 1024;
                *(_DWORD *)&v15[30] = 490;
                _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v12, 0x30u);
              }
              ++service_tracker_finalized;
              service_tracker_finalize(a1);
            }
            return;
          }
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_25:
          }
            abort();
          int v12 = 136447490;
          uint64_t v13 = "service_tracker_callback_cancel";
          __int16 v14 = 1024;
          *(_DWORD *)os_log_type_t v15 = v8;
          *(_WORD *)&_OWORD v15[4] = 2048;
          *(void *)&v15[6] = a1;
          *(_WORD *)&v15[14] = 2080;
          *(void *)&v15[16] = "tracker";
          *(_WORD *)&v15[24] = 2080;
          *(void *)&v15[26] = "service-tracker.c";
          __int16 v16 = 1024;
          int v17 = 490;
          __int16 v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        }
        else
        {
          __int16 v9 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
            goto LABEL_25;
          }
          int v12 = 136447490;
          uint64_t v13 = "service_tracker_callback_cancel";
          __int16 v14 = 1024;
          *(_DWORD *)os_log_type_t v15 = 0;
          *(_WORD *)&_OWORD v15[4] = 2048;
          *(void *)&v15[6] = a1;
          *(_WORD *)&v15[14] = 2080;
          *(void *)&v15[16] = "tracker";
          *(_WORD *)&v15[24] = 2080;
          *(void *)&v15[26] = "service-tracker.c";
          __int16 v16 = 1024;
          int v17 = 490;
          __int16 v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        }
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, v11, (uint8_t *)&v12, 0x36u);
        goto LABEL_25;
      }
    }
  }
}

void service_tracker_cancel_probes(uint64_t a1)
{
  for (uint64_t i = *(void *)(a1 + 48); i; uint64_t i = *(void *)(i + 8))
  {
    uint64_t v2 = *(void *)(i + 56);
    if (v2)
    {
      *(void *)(v2 + 24) = 0;
      *(void *)(i + 56) = 0;
      int v3 = *(void (**)(void))(v2 + 48);
      if (v3) {
        v3(*(void *)(v2 + 32));
      }
      *(void *)(v2 + 32) = 0;
      thread_service_release_((int *)i, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/probe-srp.c", 108);
      uint64_t v4 = *(void *)(v2 + 16);
      if (v4) {
        ioloop_cancel_wake_event(v4);
      }
      uint64_t v5 = *(void *)(v2 + 8);
      if (v5) {
        ioloop_comm_cancel(v5);
      }
      *(unsigned char *)(v2 + 1486) = 1;
      int v6 = *(_DWORD *)v2;
      if (!*(_DWORD *)v2)
      {
        uint64_t v9 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136447490;
          uint64_t v13 = "probe_srp_service_probe_cancel";
          __int16 v14 = 1024;
          *(_DWORD *)os_log_type_t v15 = 0;
          *(_WORD *)&_OWORD v15[4] = 2048;
          *(void *)&v15[6] = v2;
          *(_WORD *)&v15[14] = 2080;
          *(void *)&v15[16] = "probe_state";
          *(_WORD *)&v15[24] = 2080;
          *(void *)&v15[26] = "probe-srp.c";
          __int16 v16 = 1024;
          int v17 = 117;
          uint64_t v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
          __int16 v11 = v9;
          goto LABEL_23;
        }
LABEL_24:
        abort();
      }
      int v7 = global_os_log;
      if (v6 >= 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)buf = 136447490;
          uint64_t v13 = "probe_srp_service_probe_cancel";
          __int16 v14 = 1024;
          *(_DWORD *)os_log_type_t v15 = v6;
          *(_WORD *)&_OWORD v15[4] = 2048;
          *(void *)&v15[6] = v2;
          *(_WORD *)&v15[14] = 2080;
          *(void *)&v15[16] = "probe_state";
          *(_WORD *)&v15[24] = 2080;
          *(void *)&v15[26] = "probe-srp.c";
          __int16 v16 = 1024;
          int v17 = 117;
          uint64_t v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
          __int16 v11 = v7;
LABEL_23:
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, v10, buf, 0x36u);
        }
        goto LABEL_24;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136447490;
        uint64_t v13 = "probe_srp_service_probe_cancel";
        __int16 v14 = 1024;
        *(_DWORD *)os_log_type_t v15 = v6;
        *(_WORD *)&_OWORD v15[4] = 2048;
        *(void *)&v15[6] = v2;
        *(_WORD *)&v15[14] = 2080;
        *(void *)&v15[16] = "probe_state";
        *(_WORD *)&v15[24] = 2080;
        *(void *)&v15[26] = "probe-srp.c";
        __int16 v16 = 1024;
        int v17 = 117;
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        int v6 = *(_DWORD *)v2;
      }
      *(_DWORD *)uint64_t v2 = v6 - 1;
      if (v6 == 1)
      {
        int v8 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)buf = 136447234;
          uint64_t v13 = "probe_srp_service_probe_cancel";
          __int16 v14 = 2048;
          *(void *)os_log_type_t v15 = v2;
          *(_WORD *)&v15[8] = 2080;
          *(void *)&v15[10] = "probe_state";
          *(_WORD *)&v15[18] = 2080;
          *(void *)&v15[20] = "probe-srp.c";
          *(_WORD *)&v15[28] = 1024;
          *(_DWORD *)&v15[30] = 117;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        }
        ++probe_state_finalized;
        probe_state_finalize((void *)v2);
      }
    }
  }
}

uint64_t dso_state_cancel(uint64_t result)
{
  __int16 v1 = (uint64_t *)result;
  uint64_t v2 = &dso_connections;
  do
  {
    int v3 = v2;
    uint64_t v2 = (uint64_t *)*v2;
    if (v2) {
      BOOL v4 = v2 == (uint64_t *)result;
    }
    else {
      BOOL v4 = 1;
    }
  }
  while (!v4);
  if (v2)
  {
    uint64_t v5 = *(uint64_t (**)(uint64_t, void, uint64_t))(result + 16);
    if (!v5 || (BOOL result = v5(1, *(void *)(result + 8), result), result))
    {
      *int v3 = *v1;
      *__int16 v1 = dso_connections_needing_cleanup;
      dso_connections_needing_cleanup = (uint64_t)v1;
    }
  }
  return result;
}

uint64_t **dso_find_activity(uint64_t a1, char *__s1, uint64_t *a3)
{
  if (!((unint64_t)__s1 | (unint64_t)a3))
  {
    BOOL v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      int v5 = *(_DWORD *)(a1 + 48);
      int v13 = 136446722;
      __int16 v14 = "dso_find_activity";
      __int16 v15 = 1024;
      int v16 = v5;
      __int16 v17 = 2082;
      uint64_t v18 = (uint64_t)"push subscription";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, "%{public}s: [DSO%u] Cannot search for activity with name and context both equal to NULL - activity_type: %{public}s.", (uint8_t *)&v13, 0x1Cu);
    }
    return 0;
  }
  int v6 = *(uint64_t ***)(a1 + 80);
  if (!v6) {
    return v6;
  }
  while (1)
  {
    if (v6[2] != (uint64_t *)"push subscription") {
      goto LABEL_7;
    }
    if (__s1) {
      break;
    }
    if (v6[3] == a3) {
      return v6;
    }
LABEL_7:
    int v6 = (uint64_t **)*v6;
    if (!v6) {
      return v6;
    }
  }
  uint64_t v9 = (const char *)v6[4];
  if (!v9 || strcmp(__s1, v9)) {
    goto LABEL_7;
  }
  if (a3)
  {
    if (v6[3] != a3)
    {
      uint64_t v10 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        int v11 = *(_DWORD *)(a1 + 48);
        int v13 = 136447491;
        __int16 v14 = "dso_find_activity";
        __int16 v15 = 1024;
        int v16 = v11;
        __int16 v17 = 2160;
        uint64_t v18 = 1752392040;
        __int16 v19 = 2081;
        int v20 = __s1;
        __int16 v21 = 2082;
        int v22 = "push subscription";
        __int16 v23 = 2048;
        uint64_t v24 = a3;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "%{public}s: [DSO%u] The activity specified by the name does not have the expected context - name: %{private, mask.hash}s, activity_type: %{public}s, context: %p.", (uint8_t *)&v13, 0x3Au);
      }
    }
  }
  return v6;
}

void dso_drop_activity(uint64_t a1, void *a2)
{
  BOOL v4 = (void *)(a1 + 80);
  while (1)
  {
    int v5 = v4;
    BOOL v4 = (void *)*v4;
    if (!v4) {
      break;
    }
    if (v4 == a2)
    {
      void *v5 = *a2;
      goto LABEL_7;
    }
  }
  int v6 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
  {
    int v7 = *(_DWORD *)(a1 + 48);
    uint64_t v9 = a2[3];
    uint64_t v8 = a2[4];
    uint64_t v10 = a2[2];
    int v17 = 136447491;
    uint64_t v18 = "dso_drop_activity";
    __int16 v19 = 1024;
    int v20 = v7;
    __int16 v21 = 2160;
    uint64_t v22 = 1752392040;
    __int16 v23 = 2081;
    uint64_t v24 = v8;
    __int16 v25 = 2082;
    uint64_t v26 = v10;
    __int16 v27 = 2048;
    uint64_t v28 = v9;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "%{public}s: [DSO%u] Trying to remove an activity that is not in the list - activity name: %{private, mask.hash}s, activity type: %{public}s, activity context: %p.", (uint8_t *)&v17, 0x3Au);
  }
LABEL_7:
  int v11 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = *(_DWORD *)(a1 + 48);
    uint64_t v14 = a2[3];
    uint64_t v13 = a2[4];
    uint64_t v15 = a2[2];
    int v17 = 136447491;
    uint64_t v18 = "dso_drop_activity";
    __int16 v19 = 1024;
    int v20 = v12;
    __int16 v21 = 2160;
    uint64_t v22 = 1752392040;
    __int16 v23 = 2081;
    uint64_t v24 = v13;
    __int16 v25 = 2082;
    uint64_t v26 = v15;
    __int16 v27 = 2048;
    uint64_t v28 = v14;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%u] Removing a DSO activity - activity name: %{private, mask.hash}s, activity type: %{public}s, activity context: %p.", (uint8_t *)&v17, 0x3Au);
  }
  int v16 = (void (*)(void *))a2[1];
  if (v16) {
    v16(a2);
  }
  free(a2);
}

uint64_t dso_retry_delay(uint64_t result, _WORD *a2)
{
  uint64_t v2 = *(uint64_t (**)(void, unsigned int *, uint64_t, uint64_t))(result + 24);
  if (v2)
  {
    uint64_t v3 = result;
    int v4 = *(unsigned __int16 *)(result + 90);
    if (v4 == 4)
    {
      unsigned int v8 = bswap32(**(_DWORD **)(result + 96));
      return v2(*(void *)(result + 8), &v8, result, 12);
    }
    else
    {
      int v6 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = *(void *)(v3 + 152);
        unsigned int v8 = 136446722;
        uint64_t v9 = "dso_retry_delay";
        __int16 v10 = 1024;
        int v11 = v4;
        __int16 v12 = 2080;
        uint64_t v13 = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: Invalid DSO Retry Delay length %d from %s", (uint8_t *)&v8, 0x1Cu);
      }
      return dso_simple_response(*(void *)(v3 + 32), 0, a2, 1);
    }
  }
  return result;
}

void dso_keepalive(uint64_t a1, _WORD *a2, int a3)
{
  int v24 = 0x10000;
  int v5 = *(unsigned __int16 *)(a1 + 90);
  if (v5 != 8)
  {
    uint64_t v13 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v14 = *(void *)(a1 + 152);
      *(_DWORD *)buf = 136446722;
      uint64_t v26 = "dso_keepalive";
      __int16 v27 = 1024;
      int v28 = v5;
      __int16 v29 = 2080;
      v30[0] = v14;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: Invalid DSO Keepalive length %d from %s", buf, 0x1Cu);
    }
    if (!*(unsigned char *)(a1 + 52)) {
      return;
    }
LABEL_19:
    uint64_t v15 = *(void *)(a1 + 32);
    int v16 = a2;
    int v17 = 1;
LABEL_20:
    dso_simple_response(v15, 0, v16, v17);
    return;
  }
  int v6 = *(unsigned __int8 *)(a1 + 52);
  if (*(unsigned char *)(a1 + 52)) {
    BOOL v7 = a3 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (!v7)
  {
    uint64_t v18 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v26 = "dso_keepalive";
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: Dropping Keepalive Response received by DSO server", buf, 0xCu);
    }
    return;
  }
  unsigned int v8 = bswap32(**(_DWORD **)(a1 + 96));
  unsigned int v9 = bswap32(*(_DWORD *)(*(void *)(a1 + 96) + 4));
  unsigned int v22 = v8;
  unsigned int v23 = v9;
  LOWORD(v24) = *a2;
  if (v8 > 0x38000000 || v9 >= 0x38000001)
  {
    int v11 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = *(_DWORD *)(a1 + 48);
      *(_DWORD *)buf = 136446978;
      uint64_t v26 = "dso_keepalive";
      __int16 v27 = 1024;
      int v28 = v12;
      __int16 v29 = 1024;
      LODWORD(v30[0]) = v8;
      WORD2(v30[0]) = 1024;
      *(_DWORD *)((char *)v30 + 6) = v9;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%u] inactivity_timeoutl[%u] keepalive_interva[%u] is unreasonably large.", buf, 0x1Eu);
      int v6 = *(unsigned __int8 *)(a1 + 52);
    }
    if (!v6) {
      return;
    }
    goto LABEL_19;
  }
  if (v6)
  {
    int v20 = *(void (**)(void, unsigned int *, uint64_t, uint64_t))(a1 + 24);
    if (!v20) {
      goto LABEL_31;
    }
    if (*(_DWORD *)(a1 + 60) < v9) {
      unsigned int v23 = *(_DWORD *)(a1 + 60);
    }
    if (*(_DWORD *)(a1 + 64) < v8) {
      unsigned int v22 = *(_DWORD *)(a1 + 64);
    }
    v20(*(void *)(a1 + 8), &v22, a1, 11);
    if (BYTE2(v24))
    {
LABEL_31:
      uint64_t v15 = *(void *)(a1 + 32);
      int v16 = a2;
      int v17 = 0;
      goto LABEL_20;
    }
  }
  else
  {
    if (*(_DWORD *)(a1 + 60) > v9) {
      *(_DWORD *)(a1 + 60) = v9;
    }
    if (*(_DWORD *)(a1 + 64) > v8) {
      *(_DWORD *)(a1 + 64) = v8;
    }
    __int16 v21 = *(void (**)(void, unsigned int *, uint64_t, uint64_t))(a1 + 24);
    if (v21) {
      v21(*(void *)(a1 + 8), &v22, a1, 11);
    }
  }
}

void dso_session_established(uint64_t a1)
{
  uint64_t v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(_DWORD *)(a1 + 48);
    uint64_t v4 = *(void *)(a1 + 152);
    int v5 = 136446978;
    int v6 = "dso_session_established";
    __int16 v7 = 1024;
    int v8 = v3;
    __int16 v9 = 2048;
    uint64_t v10 = a1;
    __int16 v11 = 2080;
    uint64_t v12 = v4;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%u] DSO session established - dso: %p, remote name: %s.", (uint8_t *)&v5, 0x26u);
  }
  *(unsigned char *)(a1 + 53) = 1;
}

void dns_concatenate_name_to_wire_(uint64_t a1, uint64_t **a2, char *a3, char *a4, int a5)
{
  memset(v45, 0, 512);
  BYTE12(v45[0]) = 0;
  if (*(_DWORD *)(a1 + 48) <= 1u)
  {
    int v8 = (char *)((unint64_t)v45 | 0xC);
    long long v43 = 0uLL;
    long long v44 = 0uLL;
    unint64_t v41 = (unint64_t)v45 | 0xC;
    int v42 = v46;
    unsigned __int8 v40 = v45;
    if (a3)
    {
      dns_name_to_wire_(0, (uint64_t *)&v40, a3, 127);
    }
    else
    {
      __int16 v9 = a2;
      if (a2)
      {
        uint64_t v10 = 0;
        unint64_t v11 = 1398;
        uint64_t v12 = (char *)((unint64_t)v45 | 0xC);
        while (1)
        {
          unint64_t v13 = *((unsigned __int8 *)v9 + 8);
          if (v11 <= v13) {
            break;
          }
          char *v12 = v13;
          uint64_t v14 = v12 + 1;
          memcpy(v14, (char *)v9 + 9, *((unsigned __int8 *)v9 + 8));
          uint64_t v15 = *((unsigned __int8 *)v9 + 8);
          uint64_t v12 = &v14[v15];
          v11 += ~v15;
          uint64_t v16 = v10 + v15;
          uint64_t v10 = v16 + 1;
          __int16 v9 = (uint64_t **)*v9;
          if (!v9)
          {
            if (v16 != -1)
            {
              unint64_t v41 = (unint64_t)&v8[v10];
              goto LABEL_11;
            }
            break;
          }
        }
        DWORD2(v44) = 1;
      }
    }
LABEL_11:
    if (a4) {
      dns_full_name_to_wire_(0, (uint64_t)&v40, a4, 148);
    }
    if (DWORD2(v44) >= 2)
    {
      *(_DWORD *)(a1 + 48) = DWORD2(v44);
      *(_DWORD *)(a1 + 40) = a5;
    }
    unint64_t v17 = *(void *)(a1 + 8);
    if (v17)
    {
      unint64_t v18 = *(void *)(a1 + 16);
      unsigned int v19 = BYTE12(v45[0]);
      if (BYTE12(v45[0]))
      {
        unint64_t v20 = *(void *)a1;
        __int16 v21 = *(unsigned char **)(a1 + 8);
        while (v19 <= 0x3F && &v8[v19 + 1] < (char *)&v45[16] + 12)
        {
          if (v20 && v19)
          {
            unsigned int v22 = (unsigned __int8 *)(v17 - v19);
LABEL_23:
            while ((unint64_t)(v22 - 1) >= v20)
            {
              unsigned int v23 = v22--;
              if (*(v23 - 1) == v19 && *v23 == v8[1] && (unint64_t)&v22[v19] < v17)
              {
                LODWORD(v25) = v19;
                uint64_t v26 = v22;
                __int16 v27 = (unsigned __int8 *)v8;
LABEL_30:
                uint64_t v28 = v25 + 1;
                __int16 v29 = v26;
                __int16 v30 = v27;
                uint64_t v31 = v28;
                while (1)
                {
                  int v33 = *v29++;
                  int v32 = v33;
                  int v34 = *v30++;
                  if (v32 != v34) {
                    break;
                  }
                  if (!--v31)
                  {
                    v26 += v28;
                    v27 += v28;
                    uint64_t v25 = *v27;
                    unsigned int v35 = *v26;
                    if (*v27)
                    {
                      if (v35 < 0x40
                        || v35 >= 0xC0
                        && (unint64_t)(v26 + 1) < v17
                        && (int v36 = (unsigned __int8 *)(v20 + ((unint64_t)(v35 & 0x3F) << 8) + v26[1]), v26 >= v36)
                        && (uint64_t v26 = v36, *v36 <= 0x3Fu))
                      {
                        if ((unint64_t)&v26[v25] < v17) {
                          goto LABEL_30;
                        }
                      }
                      goto LABEL_23;
                    }
                    if (*v26) {
                      goto LABEL_23;
                    }
                    int v39 = v21 + 2;
                    if ((unint64_t)(v21 + 2) <= v18)
                    {
                      *__int16 v21 = ((unsigned __int16)((_WORD)v22 - v20) >> 8) | 0xC0;
                      v21[1] = (_BYTE)v22 - v20;
                      int v38 = v21 + 2;
                      if (v39) {
                        goto LABEL_50;
                      }
                    }
                    goto LABEL_51;
                  }
                }
              }
            }
          }
          if ((unint64_t)&v21[v19 + 1] >= v18) {
            break;
          }
          *v21++ = v19;
          ++v8;
          do
          {
            char v37 = *v8++;
            *v21++ = v37;
            --v19;
          }
          while (v19);
          unsigned int v19 = *v8;
          if (!*v8) {
            goto LABEL_49;
          }
        }
      }
      else
      {
        __int16 v21 = *(unsigned char **)(a1 + 8);
        if (v17 < v18)
        {
LABEL_49:
          *__int16 v21 = 0;
          int v38 = v21 + 1;
          if (v38)
          {
LABEL_50:
            if ((unint64_t)v38 <= *(void *)(a1 + 16))
            {
              *(void *)(a1 + 8) = v38;
              return;
            }
          }
        }
      }
    }
LABEL_51:
    *(_DWORD *)(a1 + 48) = 111;
    *(_DWORD *)(a1 + 40) = a5;
  }
}

uint64_t dns_name_print_to_limit(uint64_t *a1, uint64_t *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v4 = 0;
  if (a1 != a2 && a1)
  {
    uint64_t v4 = 0;
    do
    {
      if (v4)
      {
        if (v4 + 2 >= a4) {
          break;
        }
        *(unsigned char *)(a3 + v4++) = 46;
      }
      LOBYTE(v5) = *((unsigned char *)a1 + 8);
      if ((_BYTE)v5)
      {
        unint64_t v6 = 0;
        do
        {
          int v7 = *((char *)a1 + v6 + 9);
          if ((*((unsigned char *)a1 + v6 + 9) & 0x80) == 0
            && (v7 == 32 || (_DefaultRuneLocale.__runetype[v7] & 0x40000) != 0))
          {
            if (v4 + 2 >= a4) {
              break;
            }
            uint64_t v10 = 1;
            uint64_t v9 = v4;
          }
          else
          {
            if (v4 + 5 >= a4) {
              break;
            }
            int v8 = (unsigned char *)(a3 + v4);
            *int v8 = 92;
            v8[1] = (v7 / 0x64u) | 0x30;
            uint64_t v9 = v4 + 3;
            v8[2] = (v7 / 0xAu - 10 * ((unsigned __int16)(26 * (v7 / 0xAu)) >> 8)) | 0x30;
            LOBYTE(v7) = (v7 % 0xAu) | 0x30;
            uint64_t v10 = 4;
          }
          v4 += v10;
          *(unsigned char *)(a3 + v9) = v7;
          ++v6;
          unint64_t v5 = *((unsigned __int8 *)a1 + 8);
        }
        while (v6 < v5);
      }
      else
      {
        unint64_t v6 = 0;
      }
      if (v6 != v5) {
        break;
      }
      a1 = (uint64_t *)*a1;
    }
    while (a1 != a2 && a1 != 0);
  }
  *(unsigned char *)(a3 + v4) = 0;
  return a3;
}

uint64_t dns_labels_equal(uint64_t a1, uint64_t a2, unint64_t a3)
{
  unint64_t v6 = 0;
  unsigned int v7 = 1;
  while (1)
  {
    __darwin_ct_rune_t v8 = *(unsigned __int8 *)(a1 + v6);
    int v9 = *(char *)(a2 + v6);
    if (*(char *)(a1 + v6) < 0 || v9 < 0) {
      break;
    }
    __darwin_ct_rune_t v10 = __tolower(v8);
    if (v10 != __tolower(*(char *)(a2 + v6))) {
      return 0;
    }
LABEL_7:
    unint64_t v6 = v7++;
    if (v6 >= a3) {
      return 1;
    }
  }
  if (v8 == v9) {
    goto LABEL_7;
  }
  return 0;
}

uint64_t dns_names_equal(uint64_t *a1, uint64_t **a2)
{
  while (1)
  {
    unint64_t v4 = *((unsigned __int8 *)a1 + 8);
    if (v4 != *((unsigned __int8 *)a2 + 8)) {
      return 0;
    }
    if (*((unsigned char *)a1 + 8))
    {
      uint64_t result = dns_labels_equal((uint64_t)a1 + 9, (uint64_t)a2 + 9, v4);
      if (!result) {
        return result;
      }
    }
    a1 = (uint64_t *)*a1;
    a2 = (uint64_t **)*a2;
    if (!a1) {
      break;
    }
    if (!a2) {
      return 0;
    }
  }
  return !a2;
}

BOOL dns_names_equal_text(uint64_t *a1, char *__s)
{
  while (1)
  {
    unint64_t v4 = strchr(__s, 46);
    if (!v4) {
      unint64_t v4 = &__s[strlen(__s)];
    }
    if (__s >= v4)
    {
      int v5 = 0;
    }
    else
    {
      int v5 = 0;
      unint64_t v6 = __s;
      do
      {
        if (*v6 == 92)
        {
          if (v6 + 4 > v4) {
            return 0;
          }
          v6 += 3;
        }
        ++v5;
        ++v6;
      }
      while (v6 < v4);
    }
    if (v5 != *((unsigned __int8 *)a1 + 8)) {
      return 0;
    }
    if (*((unsigned char *)a1 + 8) && __s < v4)
    {
      unsigned int v7 = (unsigned __int8 *)a1 + 9;
      while (1)
      {
        int v8 = *__s;
        if (v8 != 92) {
          break;
        }
        int v9 = __s[3];
        __s += 3;
        int v10 = 100 * *(__s - 2) + 10 * *(__s - 1) + v9;
        if (v10 > 5583) {
          return 0;
        }
        int v11 = (char)*v7;
        if (v11 < 0)
        {
          int v8 = v10 - 5328;
LABEL_22:
          if (v8 != v11) {
            return 0;
          }
          goto LABEL_23;
        }
        __darwin_ct_rune_t v12 = __tolower(92);
        if (v12 != __tolower((char)*v7)) {
          return 0;
        }
LABEL_23:
        ++__s;
        ++v7;
        if (__s >= v4) {
          goto LABEL_24;
        }
      }
      int v11 = *v7;
      goto LABEL_22;
    }
LABEL_24:
    a1 = (uint64_t *)*a1;
    if (!a1) {
      return !*v4;
    }
    if (*v4 != 46) {
      return 0;
    }
    __s = v4 + 1;
  }
}

void *dns_pres_name_parse(char *a1)
{
  __int16 v1 = a1;
  uint64_t v14 = 0;
  uint64_t v2 = strchr(a1, 46);
  int v3 = &v14;
  while (1)
  {
    if (!v2) {
      uint64_t v2 = &v1[strlen(v1)];
    }
    if (v2 == v1)
    {
      uint64_t v8 = 0;
      goto LABEL_16;
    }
    if (v1 < v2) {
      break;
    }
    unsigned int v7 = __src;
LABEL_15:
    uint64_t v8 = v7 - __src;
LABEL_16:
    int v9 = (void **)malloc_type_calloc(1uLL, v8 + 10, 0x95FA72F8uLL);
    if (!v9) {
      goto LABEL_29;
    }
    int v10 = v9;
    *int v3 = v9;
    *((unsigned char *)v9 + 8) = v8;
    if ((_BYTE)v8) {
      memcpy((char *)v9 + 9, __src, v8);
    }
    *((unsigned char *)v10 + v8 + 9) = 0;
    if (v8) {
      BOOL v11 = *v2 == 46;
    }
    else {
      BOOL v11 = 0;
    }
    if (v11) {
      __int16 v1 = v2 + 1;
    }
    else {
      __int16 v1 = v2;
    }
    if (*v1)
    {
      uint64_t v2 = strchr(v1, 46);
      int v3 = v10;
    }
    else
    {
      int v3 = v10;
      uint64_t v2 = v1;
      if (!v8) {
        return v14;
      }
    }
  }
  uint64_t v4 = 0;
  while (1)
  {
    int v5 = *v1;
    if (v5 == 92)
    {
      int v6 = v1[3];
      v1 += 3;
      int v5 = 100 * *(v1 - 2) + 10 * *(v1 - 1) + v6;
      if (v5 > 5583) {
        break;
      }
      LOBYTE(v5) = v5 + 48;
    }
    __src[v4] = v5;
    if (v4 == 62) {
      break;
    }
    ++v1;
    ++v4;
    if (v1 >= v2)
    {
      unsigned int v7 = &__src[v4];
      goto LABEL_15;
    }
  }
LABEL_29:
  uint64_t result = v14;
  if (v14)
  {
    do
    {
      unint64_t v13 = (void *)*result;
      free(result);
      uint64_t result = v13;
    }
    while (v13);
  }
  return result;
}

uint64_t *dns_name_subdomain_of(uint64_t *a1, uint64_t **a2)
{
  uint64_t v2 = a1;
  int v3 = 0;
  if (a2)
  {
    uint64_t v4 = a2;
    do
    {
      ++v3;
      uint64_t v4 = (uint64_t **)*v4;
    }
    while (v4);
  }
  BOOL v5 = a1 == 0;
  int v6 = 0;
  if (a1)
  {
    unsigned int v7 = a1;
    do
    {
      ++v6;
      unsigned int v7 = (uint64_t *)*v7;
    }
    while (v7);
  }
  if (v6 < v3) {
    return 0;
  }
  if (a1 && v6 != v3)
  {
    int v8 = v3 - v6 + 1;
    do
    {
      uint64_t v2 = (uint64_t *)*v2;
      BOOL v5 = v2 == 0;
      if (v2) {
        BOOL v9 = v8 == 0;
      }
      else {
        BOOL v9 = 1;
      }
      ++v8;
    }
    while (!v9);
  }
  if (v5 || (dns_names_equal(v2, a2) & 1) == 0) {
    return 0;
  }
  return v2;
}

BOOL dns_keys_rdata_equal(uint64_t a1, uint64_t a2)
{
  BOOL result = 0;
  if (*(_WORD *)(a1 + 8) == 25
    && *(_WORD *)(a2 + 8) == 25
    && *(unsigned __int16 *)(a1 + 16) == *(unsigned __int16 *)(a2 + 16)
    && *(unsigned __int8 *)(a1 + 18) == *(unsigned __int8 *)(a2 + 18)
    && *(unsigned __int8 *)(a1 + 19) == *(unsigned __int8 *)(a2 + 19))
  {
    size_t v2 = *(unsigned int *)(a1 + 20);
    if (v2 == *(_DWORD *)(a2 + 20) && !memcmp(*(const void **)(a1 + 24), *(const void **)(a2 + 24), v2)) {
      return 1;
    }
  }
  return result;
}

unint64_t dns_txt_data_print(unint64_t __str, unsigned int a2, uint64_t a3)
{
  unint64_t v3 = __str + 1398;
  *(unsigned char *)__str = 0;
  if (__str + 1398 >= __str && a2 != 0)
  {
    int v6 = (_WORD *)__str;
    int v7 = 0;
    int v8 = 0;
    size_t v9 = 0;
    int v10 = "";
    do
    {
      int v11 = *(unsigned __int8 *)(a3 + (unsigned __int16)v8);
      int v12 = v8 + v11 + 1;
      if (a2 < (unsigned __int16)(v8 + v11 + 1)) {
        break;
      }
      if ((unsigned __int16)(v8 + v11 + 1) < (unsigned __int16)v8 || (unint64_t)&v6[v9] + 1 >= v3) {
        break;
      }
      if (*(unsigned char *)(a3 + (unsigned __int16)v8))
      {
        if (v9 * 2)
        {
          __str = (unint64_t)memcpy(v6, v10, v9 * 2);
          LOBYTE(v6[v9]) = 0;
          int v6 = (_WORD *)((char *)v6 + v9 * 2);
        }
        unint64_t v14 = (v7 + 1);
        unint64_t v15 = (v14 + v11);
        do
        {
          int v16 = *(char *)(a3 + v14);
          if ((v16 & 0x80000000) == 0 && (_DefaultRuneLocale.__runetype[*(unsigned __int8 *)(a3 + v14)] & 0x40000) != 0)
          {
            if ((unint64_t)v6 + 1 < v3)
            {
              *int v6 = v16;
              int v6 = (_WORD *)((char *)v6 + 1);
            }
          }
          else if ((unint64_t)v6 + 5 < v3)
          {
            __str = snprintf((char *)v6, 5uLL, "%o", *(unsigned __int8 *)(a3 + v14));
            int v6 = (_WORD *)((char *)v6 + (int)__str);
          }
          ++v14;
        }
        while (v14 < v15);
        int v10 = ", ";
        size_t v9 = 1;
      }
      if ((unint64_t)v6 >= v3) {
        break;
      }
      int v7 = (unsigned __int16)v12;
      int v8 = v12;
    }
    while (a2 > (unsigned __int16)v12);
  }
  return __str;
}

const char *dns_qclass_to_string(int a1)
{
  if (a1 <= 3)
  {
    if (a1 == 1) {
      return "in";
    }
    if (a1 == 3) {
      return "chaos";
    }
  }
  else
  {
    switch(a1)
    {
      case 4:
        return "hesiod";
      case 254:
        return "none";
      case 255:
        return "any";
    }
  }
  unint64_t v3 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
  {
    int v4 = 136446466;
    BOOL v5 = "dns_qclass_to_string";
    __int16 v6 = 1024;
    int v7 = a1;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, "%{public}s: Invalid qclass - qclass: %u", (uint8_t *)&v4, 0x12u);
  }
  return "<INVALID dns_qclass>";
}

const char *dns_rrtype_to_string(int a1)
{
  if (a1 > 248)
  {
    switch(a1)
    {
      case 249:
        BOOL result = "tkey";
        break;
      case 250:
        BOOL result = "tsig";
        break;
      case 251:
        BOOL result = "ixfr";
        break;
      case 252:
        BOOL result = "axfr";
        break;
      case 253:
        BOOL result = "mailb";
        break;
      case 254:
        BOOL result = "maila";
        break;
      case 255:
        BOOL result = "any";
        break;
      case 256:
        BOOL result = "uri";
        break;
      case 257:
        BOOL result = "caa";
        break;
      case 258:
        BOOL result = "avc";
        break;
      case 259:
        BOOL result = "doa";
        break;
      case 260:
        BOOL result = "amtrelay";
        break;
      default:
        if (a1 == 0x8000)
        {
          BOOL result = "ta";
        }
        else if (a1 == 32769)
        {
          BOOL result = "dlv";
        }
        else
        {
LABEL_94:
          int v4 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            int v5 = 136446466;
            __int16 v6 = "dns_rrtype_to_string";
            __int16 v7 = 1024;
            int v8 = a1;
            _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, "%{public}s: Invalid dns_rrtype - rrtype: %u", (uint8_t *)&v5, 0x12u);
          }
          BOOL result = "<INVALID dns_rrtype>";
        }
        break;
    }
  }
  else
  {
    int v2 = a1 - 1;
    BOOL result = "a";
    switch(v2)
    {
      case 0:
        return result;
      case 1:
        BOOL result = "ns";
        break;
      case 2:
        BOOL result = "md";
        break;
      case 3:
        BOOL result = "mf";
        break;
      case 4:
        BOOL result = "cname";
        break;
      case 5:
        BOOL result = "soa";
        break;
      case 6:
        BOOL result = "mb";
        break;
      case 7:
        BOOL result = "mg";
        break;
      case 8:
        BOOL result = "mr";
        break;
      case 9:
        BOOL result = "null";
        break;
      case 10:
        BOOL result = "wks";
        break;
      case 11:
        BOOL result = "ptr";
        break;
      case 12:
        BOOL result = "hinfo";
        break;
      case 13:
        BOOL result = "minfo";
        break;
      case 14:
        BOOL result = "mx";
        break;
      case 15:
        BOOL result = "txt";
        break;
      case 16:
        BOOL result = "rp";
        break;
      case 17:
        BOOL result = "afsdb";
        break;
      case 18:
        BOOL result = "x25";
        break;
      case 19:
        BOOL result = "isdn";
        break;
      case 20:
        BOOL result = "rt";
        break;
      case 21:
        BOOL result = "nsap";
        break;
      case 22:
        BOOL result = "nsap_ptr";
        break;
      case 23:
        BOOL result = "sig";
        break;
      case 24:
        BOOL result = "key";
        break;
      case 25:
        BOOL result = "px";
        break;
      case 26:
        BOOL result = "gpos";
        break;
      case 27:
        BOOL result = "aaaa";
        break;
      case 28:
        BOOL result = "loc";
        break;
      case 29:
        BOOL result = "nxt";
        break;
      case 30:
        BOOL result = "eid";
        break;
      case 31:
        BOOL result = "nimloc";
        break;
      case 32:
        BOOL result = "srv";
        break;
      case 33:
        BOOL result = "atma";
        break;
      case 34:
        BOOL result = "naptr";
        break;
      case 35:
        BOOL result = "kx";
        break;
      case 36:
        BOOL result = "cert";
        break;
      case 37:
        BOOL result = "a6";
        break;
      case 38:
        BOOL result = "dname";
        break;
      case 39:
        BOOL result = "sink";
        break;
      case 40:
        BOOL result = "opt";
        break;
      case 41:
        BOOL result = "apl";
        break;
      case 42:
        BOOL result = "ds";
        break;
      case 43:
        BOOL result = "sshfp";
        break;
      case 44:
        BOOL result = "ipseckey";
        break;
      case 45:
        BOOL result = "rrsig";
        break;
      case 46:
        BOOL result = "nsec";
        break;
      case 47:
        BOOL result = "dnskey";
        break;
      case 48:
        BOOL result = "dhcid";
        break;
      case 49:
        BOOL result = "nsec3";
        break;
      case 50:
        BOOL result = "nsec3param";
        break;
      case 51:
        BOOL result = "tlsa";
        break;
      case 52:
        BOOL result = "smimea";
        break;
      case 54:
        BOOL result = "hip";
        break;
      case 55:
        BOOL result = "ninfo";
        break;
      case 56:
        BOOL result = "rkey";
        break;
      case 57:
        BOOL result = "talink";
        break;
      case 58:
        BOOL result = "cds";
        break;
      case 59:
        BOOL result = "cdnskey";
        break;
      case 60:
        BOOL result = "openpgpkey";
        break;
      case 61:
        BOOL result = "csync";
        break;
      case 62:
        BOOL result = "zonemd";
        break;
      case 63:
        BOOL result = "svcb";
        break;
      case 64:
        BOOL result = "https";
        break;
      case 98:
        BOOL result = "spf";
        break;
      case 99:
        BOOL result = "uinfo";
        break;
      case 100:
        BOOL result = "uid";
        break;
      case 101:
        BOOL result = "gid";
        break;
      case 102:
        BOOL result = "unspec";
        break;
      case 103:
        BOOL result = "nid";
        break;
      case 104:
        BOOL result = "l32";
        break;
      case 105:
        BOOL result = "l64";
        break;
      case 106:
        BOOL result = "lp";
        break;
      case 107:
        BOOL result = "eui48";
        break;
      case 108:
        BOOL result = "eui64";
        break;
      default:
        goto LABEL_94;
    }
  }
  return result;
}

void dp_start_dropping()
{
  uint64_t v0 = (int *)connection_dropper;
  if (connection_dropper
    || (uint64_t v0 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 650), (connection_dropper = (uint64_t)v0) != 0))
  {
    ioloop_add_wake_event((uint64_t)v0, 0, (uint64_t)dp_drop_connections, 0, 0x15F90u);
  }
  else
  {
    __int16 v1 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      int v2 = 136446210;
      unint64_t v3 = "dp_start_dropping";
      _os_log_impl((void *)&_mh_execute_header, v1, OS_LOG_TYPE_ERROR, "%{public}s: can't create connection dropper.", (uint8_t *)&v2, 0xCu);
    }
  }
}

uint64_t dp_drop_connections()
{
  for (uint64_t i = dso_connections; i; uint64_t i = *(void *)i)
  {
    if (*(void (**)(uint64_t, uint64_t, uint64_t, int))(i + 24) == dns_push_callback)
    {
      uint64_t v1 = *(void *)(i + 8);
      int v2 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v3 = *(void *)(i + 152);
        *(_DWORD *)buf = 136446723;
        __int16 v7 = "dp_drop_connections";
        __int16 v8 = 2160;
        uint64_t v9 = 1752392040;
        __int16 v10 = 2081;
        uint64_t v11 = v3;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: dropping connection for %{private, mask.hash}s.", buf, 0x20u);
      }
      uint64_t v4 = *(void *)(v1 + 8);
      if (v4) {
        ioloop_comm_cancel(v4);
      }
    }
  }
  return dp_start_dropping();
}

void dns_push_callback(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  switch(a4)
  {
    case 0:
      uint64_t v6 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      if (a3) {
        int v7 = *(_DWORD *)(a3 + 48);
      }
      else {
        int v7 = 0;
      }
      int v26 = (*(unsigned __int16 *)(a2 + 90) >> 3) & 0xF;
      uint64_t v27 = *(void *)(a3 + 152);
      *(_DWORD *)buf = 136447235;
      *(void *)&uint8_t buf[4] = "dns_push_callback";
      __int16 v108 = 1024;
      *(_DWORD *)uint64_t v109 = v7;
      *(_WORD *)&v109[4] = 1024;
      *(_DWORD *)&v109[6] = v26;
      *(_WORD *)&v109[10] = 2160;
      *(void *)&v109[12] = 1752392040;
      *(_WORD *)&v109[20] = 2081;
      *(void *)&v109[22] = v27;
      uint64_t v28 = "%{public}s: [DSO%d] DNS Message (opcode=%d) received from %{private, mask.hash}s";
      goto LABEL_45;
    case 1:
      uint64_t v6 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      if (a3) {
        int v8 = *(_DWORD *)(a3 + 48);
      }
      else {
        int v8 = 0;
      }
      int v29 = (*(unsigned __int16 *)(a2 + 90) >> 3) & 0xF;
      uint64_t v30 = *(void *)(a3 + 152);
      *(_DWORD *)buf = 136447235;
      *(void *)&uint8_t buf[4] = "dns_push_callback";
      __int16 v108 = 1024;
      *(_DWORD *)uint64_t v109 = v8;
      *(_WORD *)&v109[4] = 1024;
      *(_DWORD *)&v109[6] = v29;
      *(_WORD *)&v109[10] = 2160;
      *(void *)&v109[12] = 1752392040;
      *(_WORD *)&v109[20] = 2081;
      *(void *)&v109[22] = v30;
      uint64_t v28 = "%{public}s: [DSO%d] DNS Response (opcode=%d) received from %{private, mask.hash}s";
LABEL_45:
      uint64_t v31 = buf;
      int v32 = v6;
      goto LABEL_58;
    case 2:
      __int16 v10 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        if (a3) {
          int v11 = *(_DWORD *)(a3 + 48);
        }
        else {
          int v11 = 0;
        }
        int v33 = *(unsigned __int16 *)(a3 + 88);
        uint64_t v34 = *(void *)(a3 + 152);
        *(_DWORD *)buf = 136447235;
        *(void *)&uint8_t buf[4] = "dns_push_callback";
        __int16 v108 = 1024;
        *(_DWORD *)uint64_t v109 = v11;
        *(_WORD *)&v109[4] = 1024;
        *(_DWORD *)&v109[6] = v33;
        *(_WORD *)&v109[10] = 2160;
        *(void *)&v109[12] = 1752392040;
        *(_WORD *)&v109[20] = 2081;
        *(void *)&v109[22] = v34;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%d] DSO Message (Primary TLV=%d) received from %{private, mask.hash}s", buf, 0x2Cu);
      }
      if (*(_DWORD *)(a1 + 40) || *(__int16 *)(a3 + 88) == -1780) {
        goto LABEL_96;
      }
      if (num_push_sessions != 15)
      {
        int v57 = ++num_push_sessions;
        os_log_type_t v58 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v59 = *(_DWORD *)(a1 + 4);
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "dso_limit";
          __int16 v108 = 1024;
          *(_DWORD *)uint64_t v109 = v59;
          *(_WORD *)&v109[4] = 1024;
          *(_DWORD *)&v109[6] = v57;
          _os_log_impl((void *)&_mh_execute_header, v58, OS_LOG_TYPE_DEFAULT, "%{public}s: [TRK%d] new DNS Push connection, count is now %d", buf, 0x18u);
        }
        *(_DWORD *)(a1 + 40) = 1;
LABEL_96:
        int v60 = *(unsigned __int16 *)(a3 + 88);
        switch(*(_WORD *)(a3 + 88))
        {
          case '@':
            uint64_t v61 = (_WORD *)(a2 + 88);
            __int16 v62 = "DNS Push Subscribe";
            goto LABEL_105;
          case 'A':
            int v66 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              int v67 = *(_DWORD *)(a3 + 48);
              int v68 = *(_DWORD *)(a1 + 4);
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "dso_message";
              __int16 v108 = 1024;
              *(_DWORD *)uint64_t v109 = v67;
              *(_WORD *)&v109[4] = 1024;
              *(_DWORD *)&v109[6] = v68;
              *(_WORD *)&v109[10] = 1024;
              *(_DWORD *)&v109[12] = 65;
              _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%d][TRK%d] bogus push update message %d", buf, 0x1Eu);
            }
            dso_state_cancel(a3);
            return;
          case 'B':
            uint64_t v61 = (_WORD *)(a2 + 88);
            __int16 v62 = "DNS Push Unsubscribe";
LABEL_105:
            dns_push_subscription_change((uint64_t)v62, a1, v61, a3);
            return;
          case 'C':
            uint64_t v69 = *(void *)(a1 + 8);
            uint16_t v98 = 0;
            memset(rrtype, 0, sizeof(rrtype));
            unsigned int v97 = *(_DWORD *)(a3 + 96) - (a2 + 100);
            unsigned int v70 = v97 + *(unsigned __int16 *)(a3 + 90);
            uint64_t v71 = *(void *)(v69 + 200);
            if (dns_rr_parse_() && dns_u16_parse(a2 + 100, v70, &v97, &v98))
            {
              uint16_t v72 = v98;
              __int16 v73 = v97;
              if (v97 + v98 == v70)
              {
                if (dp_served(*(uint64_t **)rrtype, (uint64_t)buf))
                {
                  size_t v74 = strlen(buf);
                  if (v74 - 249 <= 0xFFFFFFFFFFFFFEFELL)
                  {
                    dso_simple_response(v69, 0, (_WORD *)(a2 + 88), 1);
                    uint64_t v76 = global_os_log;
                    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_123;
                    }
                    int v77 = *(_DWORD *)(a3 + 48);
                    int v78 = *(_DWORD *)(v69 + 180);
                    if (v71) {
                      int v79 = *(_DWORD *)(v71 + 4);
                    }
                    else {
                      int v79 = 0;
                    }
                    *(_DWORD *)socklen_t v99 = 136447234;
                    *(void *)&v99[4] = "dns_push_reconfirm";
                    *(_WORD *)&v99[12] = 1024;
                    *(_DWORD *)&v99[14] = v77;
                    __int16 v100 = 1024;
                    int v101 = v78;
                    __int16 v102 = 1024;
                    int v103 = v79;
                    __int16 v104 = 2080;
                    int v105 = buf;
                    __int16 v84 = "%{public}s: [DSO%d][C%d][TRK%d] name is too long for .local suffix: %s";
                    __int16 v85 = v99;
LABEL_121:
                    int v86 = v76;
                    uint32_t v87 = 40;
LABEL_122:
                    _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_ERROR, v84, v85, v87);
                    goto LABEL_123;
                  }
                  *(void *)&buf[v74] = 0x2E6C61636F6C2ELL;
                }
                else
                {
                  dns_name_print_to_limit(*(uint64_t **)rrtype, 0, (uint64_t)&buf[8], 0xF8uLL);
                }
                DNSServiceReconfirmRecord(0, (uint32_t)buf, (const char *)rrtype[4], rrtype[5], v72, a2 + v73 + 100, v75);
                dso_simple_response(v69, 0, (_WORD *)(a2 + 88), 0);
              }
              else
              {
                int v90 = v97 + v98;
                dso_simple_response(v69, 0, (_WORD *)(a2 + 88), 1);
                uint64_t v91 = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                {
                  int v92 = *(_DWORD *)(a3 + 48);
                  int v93 = *(_DWORD *)(v69 + 180);
                  if (v71) {
                    int v94 = *(_DWORD *)(v71 + 4);
                  }
                  else {
                    int v94 = 0;
                  }
                  uint64_t v95 = *(void *)(a3 + 152);
                  *(_DWORD *)buf = 136447746;
                  *(void *)&uint8_t buf[4] = "dns_push_reconfirm";
                  __int16 v108 = 1024;
                  *(_DWORD *)uint64_t v109 = v92;
                  *(_WORD *)&v109[4] = 1024;
                  *(_DWORD *)&v109[6] = v93;
                  *(_WORD *)&v109[10] = 1024;
                  *(_DWORD *)&v109[12] = v94;
                  *(_WORD *)&v109[16] = 2080;
                  *(void *)&v109[18] = v95;
                  *(_WORD *)&v109[26] = 1024;
                  *(_DWORD *)&v109[28] = v90;
                  __int16 v110 = 1024;
                  unsigned int v111 = v70;
                  __int16 v84 = "%{public}s: [DSO%d][C%d][TRK%d] RRdata parse from %s failed: length mismatch (%d != %d)";
                  __int16 v85 = buf;
                  int v86 = v91;
                  uint32_t v87 = 52;
                  goto LABEL_122;
                }
              }
LABEL_123:
              dns_rrdata_free((uint64_t)rrtype);
              uint64_t v88 = *(void **)rrtype;
              do
              {
                if (!v88) {
                  break;
                }
                __int16 v89 = (void *)*v88;
                free(v88);
                uint64_t v88 = v89;
              }
              while (v89);
              return;
            }
            dso_simple_response(v69, 0, (_WORD *)(a2 + 88), 1);
            uint64_t v76 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
              goto LABEL_123;
            }
            int v80 = *(_DWORD *)(a3 + 48);
            int v81 = *(_DWORD *)(v69 + 180);
            if (v71) {
              int v82 = *(_DWORD *)(v71 + 4);
            }
            else {
              int v82 = 0;
            }
            uint64_t v83 = *(void *)(a3 + 152);
            *(_DWORD *)buf = 136447234;
            *(void *)&uint8_t buf[4] = "dns_push_reconfirm";
            __int16 v108 = 1024;
            *(_DWORD *)uint64_t v109 = v80;
            *(_WORD *)&v109[4] = 1024;
            *(_DWORD *)&v109[6] = v81;
            *(_WORD *)&v109[10] = 1024;
            *(_DWORD *)&v109[12] = v82;
            *(_WORD *)&v109[16] = 2080;
            *(void *)&v109[18] = v83;
            __int16 v84 = "%{public}s: [DSO%d][C%d][TRK%d] RR parse from %s failed";
            __int16 v85 = buf;
            goto LABEL_121;
          default:
            uint64_t v63 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              int v64 = *(_DWORD *)(a3 + 48);
              int v65 = *(_DWORD *)(a1 + 4);
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "dso_message";
              __int16 v108 = 1024;
              *(_DWORD *)uint64_t v109 = v64;
              *(_WORD *)&v109[4] = 1024;
              *(_DWORD *)&v109[6] = v65;
              *(_WORD *)&v109[10] = 1024;
              *(_DWORD *)&v109[12] = v60;
              _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%d][TRK%d] unexpected primary TLV %d", buf, 0x1Eu);
            }
            dso_simple_response(*(void *)(a1 + 8), 0, (_WORD *)(a2 + 88), 11);
            return;
        }
      }
      unsigned int v35 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v36 = *(_DWORD *)(a1 + 4);
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "dso_limit";
        __int16 v108 = 1024;
        *(_DWORD *)uint64_t v109 = v36;
        *(_WORD *)&v109[4] = 1024;
        *(_DWORD *)&v109[6] = 15;
        _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "%{public}s: [TRK%d] no more DNS Push connections allowed--sending retry-delay: %d", buf, 0x18u);
      }
      dso_retry_delay_response(*(void *)(a1 + 8), a2, *(_WORD *)(a2 + 88), *(unsigned __int16 *)(a2 + 90));
      ++num_push_sessions_dropped_for_load;
      dp_tracker_idle_after(a1, 5, 0);
      return;
    case 3:
      uint64_t v12 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      if (a3) {
        int v13 = *(_DWORD *)(a3 + 48);
      }
      else {
        int v13 = 0;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "dns_push_callback";
      __int16 v108 = 1024;
      *(_DWORD *)uint64_t v109 = v13;
      uint64_t v28 = "%{public}s: [DSO%d] Finalize";
      goto LABEL_87;
    case 4:
      uint64_t v14 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      if (a3) {
        int v15 = *(_DWORD *)(a3 + 48);
      }
      else {
        int v15 = 0;
      }
      int v37 = *(unsigned __int16 *)(a3 + 88);
      uint64_t v38 = *(void *)(a3 + 152);
      *(_DWORD *)buf = 136447235;
      *(void *)&uint8_t buf[4] = "dns_push_callback";
      __int16 v108 = 1024;
      *(_DWORD *)uint64_t v109 = v15;
      *(_WORD *)&v109[4] = 1024;
      *(_DWORD *)&v109[6] = v37;
      *(_WORD *)&v109[10] = 2160;
      *(void *)&v109[12] = 1752392040;
      *(_WORD *)&v109[20] = 2081;
      *(void *)&v109[22] = v38;
      uint64_t v28 = "%{public}s: [DSO%d] DSO Response (Primary TLV=%d) received from %{private, mask.hash}s";
      uint64_t v31 = buf;
      int v32 = v14;
LABEL_58:
      os_log_type_t v39 = OS_LOG_TYPE_DEFAULT;
      uint32_t v40 = 44;
      goto LABEL_88;
    case 5:
      uint64_t v16 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      if (a3) {
        int v17 = *(_DWORD *)(a3 + 48);
      }
      else {
        int v17 = 0;
      }
      uint64_t v41 = *(void *)(a3 + 152);
      *(_DWORD *)buf = 136446979;
      *(void *)&uint8_t buf[4] = "dns_push_callback";
      __int16 v108 = 1024;
      *(_DWORD *)uint64_t v109 = v17;
      *(_WORD *)&v109[4] = 2160;
      *(void *)&v109[6] = 1752392040;
      *(_WORD *)&v109[14] = 2081;
      *(void *)&v109[16] = v41;
      uint64_t v28 = "%{public}s: [DSO%d] Connected to %{private, mask.hash}s";
      goto LABEL_67;
    case 6:
      uint64_t v16 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      if (a3) {
        int v18 = *(_DWORD *)(a3 + 48);
      }
      else {
        int v18 = 0;
      }
      uint64_t v42 = *(void *)(a3 + 152);
      *(_DWORD *)buf = 136446979;
      *(void *)&uint8_t buf[4] = "dns_push_callback";
      __int16 v108 = 1024;
      *(_DWORD *)uint64_t v109 = v18;
      *(_WORD *)&v109[4] = 2160;
      *(void *)&v109[6] = 1752392040;
      *(_WORD *)&v109[14] = 2081;
      *(void *)&v109[16] = v42;
      uint64_t v28 = "%{public}s: [DSO%d] Connection to %{private, mask.hash}s failed";
      goto LABEL_67;
    case 7:
      uint64_t v16 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      if (a3) {
        int v19 = *(_DWORD *)(a3 + 48);
      }
      else {
        int v19 = 0;
      }
      uint64_t v43 = *(void *)(a3 + 152);
      *(_DWORD *)buf = 136446979;
      *(void *)&uint8_t buf[4] = "dns_push_callback";
      __int16 v108 = 1024;
      *(_DWORD *)uint64_t v109 = v19;
      *(_WORD *)&v109[4] = 2160;
      *(void *)&v109[6] = 1752392040;
      *(_WORD *)&v109[14] = 2081;
      *(void *)&v109[16] = v43;
      uint64_t v28 = "%{public}s: [DSO%d] Connection to %{private, mask.hash}s disconnected";
      goto LABEL_67;
    case 8:
      uint64_t v16 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      if (a3) {
        int v20 = *(_DWORD *)(a3 + 48);
      }
      else {
        int v20 = 0;
      }
      uint64_t v44 = *(void *)(a3 + 152);
      *(_DWORD *)buf = 136446979;
      *(void *)&uint8_t buf[4] = "dns_push_callback";
      __int16 v108 = 1024;
      *(_DWORD *)uint64_t v109 = v20;
      *(_WORD *)&v109[4] = 2160;
      *(void *)&v109[6] = 1752392040;
      *(_WORD *)&v109[14] = 2081;
      *(void *)&v109[16] = v44;
      uint64_t v28 = "%{public}s: [DSO%d] Connection to %{private, mask.hash}s should reconnect (not for a server)";
LABEL_67:
      uint64_t v31 = buf;
      int v32 = v16;
      os_log_type_t v39 = OS_LOG_TYPE_DEFAULT;
      uint32_t v40 = 38;
      goto LABEL_88;
    case 9:
      uint64_t v12 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      if (a3) {
        int v21 = *(_DWORD *)(a3 + 48);
      }
      else {
        int v21 = 0;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "dns_push_callback";
      __int16 v108 = 1024;
      *(_DWORD *)uint64_t v109 = v21;
      uint64_t v28 = "%{public}s: [DSO%d] Inactivity timer went off, closing connection.";
      goto LABEL_87;
    case 10:
      uint64_t v12 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      if (a3) {
        int v22 = *(_DWORD *)(a3 + 48);
      }
      else {
        int v22 = 0;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "dns_push_callback";
      __int16 v108 = 1024;
      *(_DWORD *)uint64_t v109 = v22;
      uint64_t v28 = "%{public}s: [DSO%d] should send a keepalive now.";
      goto LABEL_87;
    case 11:
      *(unsigned char *)(a2 + 10) = 0;
      unsigned int v23 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        if (a3) {
          int v24 = *(_DWORD *)(a3 + 48);
        }
        else {
          int v24 = 0;
        }
        uint64_t v45 = *(void *)(*(void *)(a3 + 32) + 192);
        int v46 = *(unsigned __int16 *)(a2 + 8);
        *(_DWORD *)buf = 136447235;
        *(void *)&uint8_t buf[4] = "dns_push_callback";
        __int16 v108 = 1024;
        *(_DWORD *)uint64_t v109 = v24;
        *(_WORD *)&v109[4] = 2160;
        *(void *)&v109[6] = 1752392040;
        *(_WORD *)&v109[14] = 2081;
        *(void *)&v109[16] = v45;
        *(_WORD *)&v109[24] = 1024;
        *(_DWORD *)&v109[26] = v46;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%d] %{private, mask.hash}s: keepalive received, xid %04x.", buf, 0x2Cu);
      }
      if (!*(unsigned char *)(a3 + 52)) {
        return;
      }
      if (!*(void *)(a3 + 32))
      {
        uint64_t v53 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
          return;
        }
        uint64_t v54 = *(void *)(a3 + 152);
        *(_DWORD *)buf = 136446723;
        *(void *)&uint8_t buf[4] = "dp_keepalive_response_send";
        __int16 v108 = 2160;
        *(void *)uint64_t v109 = 1752392040;
        *(_WORD *)&v109[8] = 2081;
        *(void *)&v109[10] = v54;
        uint64_t v28 = "%{public}s: dso state %{private, mask.hash}s has no transport";
        uint64_t v31 = buf;
        int v32 = v53;
        os_log_type_t v39 = OS_LOG_TYPE_ERROR;
        uint32_t v40 = 32;
        goto LABEL_88;
      }
      __int16 v47 = *(_WORD *)(a2 + 8);
      *(void *)buf = 11534336;
      *(_DWORD *)&buf[8] = 0;
      if (!*(unsigned char *)(a3 + 53))
      {
        int v96 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)rrxpc_type_t type = 136446210;
          *(void *)&rrtype[2] = "dso_make_message";
          _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "%{public}s: dso_make_message: FATAL: server attempting to make a DSO message with no session!", (uint8_t *)rrtype, 0xCu);
        }
        __assert_rtn("dso_make_message", "dso.c", 640, "0");
      }
      *(_WORD *)buf = v47;
      __int16 v108 = 256;
      if (&v109[6] >= v112)
      {
        int v55 = 3790;
      }
      else
      {
        *(_DWORD *)&v109[2] = bswap32(*(_DWORD *)a2);
        if (&v109[10] < v112)
        {
          *(_DWORD *)&v109[6] = bswap32(*(_DWORD *)(a2 + 4));
          v109[0] = (unsigned __int16)(&v109[10] - v109 - 2) >> 8;
          v109[1] = &v109[10] - v109 - 2;
          *(void *)socklen_t v99 = buf;
          *(void *)&v99[8] = &v109[10] - buf;
          char v48 = ioloop_send_message(*(void *)(a3 + 32), 0, (iovec *)v99);
          uint64_t v49 = global_os_log;
          BOOL v50 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
          if (v48)
          {
            if (!v50) {
              return;
            }
            int v51 = *(unsigned __int16 *)(a2 + 8);
            uint64_t v52 = *(void *)(*(void *)(a3 + 32) + 192);
            *(_DWORD *)rrxpc_type_t type = 136447747;
            *(void *)&rrtype[2] = "dp_keepalive_response_send";
            rrtype[6] = 2048;
            *(void *)&rrtype[7] = *(void *)&v99[8];
            rrtype[11] = 1024;
            *(_DWORD *)&rrtype[12] = buf[0];
            rrtype[14] = 1024;
            *(_DWORD *)&rrtype[15] = buf[1];
            rrtype[17] = 1024;
            *(_DWORD *)&rrtype[18] = v51;
            rrtype[20] = 2160;
            *(void *)&rrtype[21] = 1752392040;
            rrtype[25] = 2081;
            *(void *)&rrtype[26] = v52;
            uint64_t v28 = "%{public}s: sent %zd byte response Keepalive, xid %02x%02x (was %04x), to %{private, mask.hash}s";
            uint64_t v31 = (uint8_t *)rrtype;
            int v32 = v49;
            os_log_type_t v39 = OS_LOG_TYPE_DEFAULT;
            uint32_t v40 = 60;
          }
          else
          {
            if (!v50) {
              return;
            }
            *(_DWORD *)rrxpc_type_t type = 136446210;
            *(void *)&rrtype[2] = "dp_keepalive_response_send";
            uint64_t v28 = "%{public}s: send failed";
            uint64_t v31 = (uint8_t *)rrtype;
            int v32 = v49;
            os_log_type_t v39 = OS_LOG_TYPE_DEFAULT;
            uint32_t v40 = 12;
          }
LABEL_88:
          _os_log_impl((void *)&_mh_execute_header, v32, v39, v28, v31, v40);
          return;
        }
        int v55 = 3791;
      }
      uint64_t v56 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
        return;
      }
      *(_DWORD *)rrxpc_type_t type = 136446722;
      *(void *)&rrtype[2] = "dp_keepalive_response_send";
      rrtype[6] = 2082;
      *(void *)&rrtype[7] = "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c";
      rrtype[11] = 1024;
      *(_DWORD *)&rrtype[12] = v55;
      uint64_t v28 = "%{public}s: ran out of message space at %{public}s, :%d";
      uint64_t v31 = (uint8_t *)rrtype;
      int v32 = v56;
      os_log_type_t v39 = OS_LOG_TYPE_ERROR;
      uint32_t v40 = 28;
      goto LABEL_88;
    case 12:
      uint64_t v12 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      if (a3) {
        int v25 = *(_DWORD *)(a3 + 48);
      }
      else {
        int v25 = 0;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "dns_push_callback";
      __int16 v108 = 1024;
      *(_DWORD *)uint64_t v109 = v25;
      uint64_t v28 = "%{public}s: [DSO%d] keepalive received.";
LABEL_87:
      uint64_t v31 = buf;
      int v32 = v12;
      os_log_type_t v39 = OS_LOG_TYPE_DEFAULT;
      uint32_t v40 = 18;
      goto LABEL_88;
    default:
      return;
  }
}

void dp_tracker_idle_after(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3)
  {
    if ((*(_WORD *)(v3 + 416) & 0x100) == 0
      && !*(void *)(a1 + 24)
      && (!a3 || (uint64_t v6 = *(void *)(a1 + 16)) == 0 || v6 == a3 && !*(void *)(a3 + 16)))
    {
      int v7 = *(int **)(a1 + 32);
      if (v7
        || (int v7 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 880), (*(void *)(a1 + 32) = v7) != 0))
      {
        ioloop_add_wake_event((uint64_t)v7, a1, (uint64_t)dp_tracker_idle, (uint64_t)dp_tracker_context_release, 1000 * a2);
        int v8 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v9 = *(_DWORD *)a1;
          *(_DWORD *)buf = 136447490;
          uint64_t v16 = "dp_tracker_idle_after";
          __int16 v17 = 1024;
          int v18 = v9;
          __int16 v19 = 2048;
          uint64_t v20 = a1;
          __int16 v21 = 2080;
          int v22 = "tracker";
          __int16 v23 = 2080;
          int v24 = "dnssd-proxy.c";
          __int16 v25 = 1024;
          int v26 = 886;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        if (*(_DWORD *)a1)
        {
          int v10 = *(_DWORD *)a1 + 1;
          *(_DWORD *)a1 = v10;
          if (v10 >= 10001)
          {
            int v14 = v10;
            int v11 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)buf = 136447490;
              uint64_t v16 = "dp_tracker_idle_after";
              __int16 v17 = 1024;
              int v18 = v14;
              __int16 v19 = 2048;
              uint64_t v20 = a1;
              __int16 v21 = 2080;
              int v22 = "tracker";
              __int16 v23 = 2080;
              int v24 = "dnssd-proxy.c";
              __int16 v25 = 1024;
              int v26 = 886;
              _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            }
            abort();
          }
        }
        else
        {
          ++dp_tracker_created;
          *(_DWORD *)a1 = 1;
        }
      }
      else
      {
        uint64_t v12 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          int v13 = *(_DWORD *)(a1 + 4);
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "dp_tracker_idle_after";
          __int16 v17 = 1024;
          int v18 = v13;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%{public}s: [TRK%d] no memory for idle timeout", buf, 0x12u);
        }
      }
    }
  }
}

void *dns_push_subscription_change(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4)
{
  int v76 = *(_DWORD *)(a4 + 96) - (a3 + 12);
  unsigned int v8 = v76 + *(unsigned __int16 *)(a4 + 90);
  unsigned __int16 v71 = bswap32((unsigned __int16)*a3) >> 16;
  *(_OWORD *)uint16_t v72 = 0u;
  long long v73 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  if (*(_WORD *)(a4 + 88) == 64)
  {
    if ((dns_rr_parse_() & 1) == 0)
    {
      dso_simple_response(*(void *)(a2 + 8), 0, a3, 1);
      uint64_t v16 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
        goto LABEL_25;
      }
      int v17 = *(_DWORD *)(a4 + 48);
      int v18 = *(_DWORD *)(a2 + 4);
      uint64_t v19 = *(void *)(a4 + 152);
      int buf = 136447234;
      int v94 = "dns_push_subscription_change";
      __int16 v95 = 1024;
      *(_DWORD *)int v96 = v17;
      *(_WORD *)&v96[4] = 1024;
      *(_DWORD *)&v96[6] = v18;
      *(_WORD *)&v96[10] = 2080;
      *(void *)&v96[12] = v19;
      *(_WORD *)&v96[20] = 2080;
      *(void *)&v96[22] = a1;
      uint64_t v20 = "%{public}s: [DSO%d][TRK%d] RR parse for %s from %s failed";
      __int16 v21 = v16;
LABEL_23:
      uint32_t v23 = 44;
      goto LABEL_24;
    }
    dns_name_print_to_limit((uint64_t *)v72[0], 0, (uint64_t)v80, 0x100uLL);
  }
  else
  {
    if (!dns_u16_parse((uint64_t)(a3 + 6), v8, (unsigned int *)&v76, &v71))
    {
      uint64_t v22 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
        goto LABEL_25;
      }
      int buf = 136446210;
      int v94 = "dns_push_subscription_change";
      uint64_t v20 = "%{public}s: unable to get subscribe xid from primary";
      __int16 v21 = v22;
      uint32_t v23 = 12;
      goto LABEL_24;
    }
    strcpy(v80, "none");
  }
  unsigned int v9 = v76;
  if (v76 != v8)
  {
    if (*(_WORD *)(a4 + 88) == 64) {
      dso_simple_response(*(void *)(a2 + 8), 0, a3, 1);
    }
    uint64_t v24 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_25;
    }
    uint64_t v25 = *(void *)(a4 + 152);
    if (*(_WORD *)(a4 + 88) == 64) {
      int v26 = "subscribe";
    }
    else {
      int v26 = "unsubscribe";
    }
    int buf = 136447234;
    int v94 = "dns_push_subscription_change";
    __int16 v95 = 2082;
    *(void *)int v96 = v26;
    *(_WORD *)&v96[8] = 2080;
    *(void *)&v96[10] = v25;
    *(_WORD *)&v96[18] = 1024;
    *(_DWORD *)&v96[20] = v9;
    *(_WORD *)&v96[24] = 1024;
    *(_DWORD *)&v96[26] = v8;
    uint64_t v20 = "%{public}s: DNS push %{public}s parse from %s failed: length mismatch (%d != %d)";
    __int16 v21 = v24;
    goto LABEL_23;
  }
  int v10 = v71;
  snprintf(__str, 5uLL, "%04x", v71);
  activity = dso_find_activity(a4, __str, 0);
  int v12 = *(unsigned __int16 *)(a4 + 88);
  if (!activity)
  {
    int v29 = global_os_log;
    if (v12 == 64)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v30 = *(_DWORD *)(a4 + 48);
        if (a2) {
          int v31 = *(_DWORD *)(a2 + 4);
        }
        else {
          int v31 = 0;
        }
        int buf = 136448003;
        int v94 = "dns_push_subscription_change";
        __int16 v95 = 1024;
        *(_DWORD *)int v96 = v30;
        *(_WORD *)&v96[4] = 1024;
        *(_DWORD *)&v96[6] = v31;
        *(_WORD *)&v96[10] = 2082;
        *(void *)&v96[12] = a1;
        *(_WORD *)&v96[20] = 2160;
        *(void *)&v96[22] = 1752392040;
        *(_WORD *)&v96[30] = 2081;
        *(void *)&v96[32] = v80;
        *(_WORD *)&v96[40] = 2082;
        *(void *)&v96[42] = __str;
        __int16 v97 = 1024;
        int v98 = LOWORD(v72[1]);
        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%d][TRK%d] %{public}s for %{private, mask.hash}s (%{public}s) type %d.", (uint8_t *)&buf, 0x46u);
      }
      int v79 = 0;
      uint64_t v44 = dp_query_create((int *)a2, (uint64_t)v72, 0, a4, &v79);
      if (!v44)
      {
        uint64_t v41 = *(void *)(a2 + 8);
        int v43 = v79;
        uint64_t v42 = a3;
LABEL_45:
        dso_simple_response(v41, 0, v42, v43);
        goto LABEL_25;
      }
      uint64_t v45 = (uint64_t)v44;
      size_t v46 = strlen(__str);
      if (dso_find_activity(a4, __str, (uint64_t *)v45))
      {
        __int16 v47 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          int v48 = *(_DWORD *)(a4 + 48);
          int buf = 136447491;
          int v94 = "dso_add_activity";
          __int16 v95 = 1024;
          *(_DWORD *)int v96 = v48;
          *(_WORD *)&v96[4] = 2160;
          *(void *)&v96[6] = 1752392040;
          *(_WORD *)&v96[14] = 2081;
          *(void *)&v96[16] = __str;
          *(_WORD *)&v96[24] = 2082;
          *(void *)&v96[26] = "push subscription";
          *(_WORD *)&v96[34] = 2048;
          *(void *)&v96[36] = v45;
          _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_FAULT, "%{public}s: [DSO%u] Trying to add a duplicate activity - activity name: %{private, mask.hash}s, activity type: %{public}s, activity context: %p.", (uint8_t *)&buf, 0x3Au);
        }
        uint64_t v49 = 0;
      }
      else
      {
        if (v46 == -41 || (BOOL v50 = malloc_type_calloc(1uLL, (v46 + 41), 0xF1748037uLL)) == 0) {
          __break(1u);
        }
        uint64_t v49 = v50;
        size_t v51 = v46 + 1;
        if (v46 == -1)
        {
          uint64_t v52 = 0;
        }
        else
        {
          uint64_t v52 = (char *)(v50 + 5);
          memcpy(v50 + 5, __str, v51);
        }
        v49[3] = v45;
        v49[4] = v52;
        v49[1] = dns_push_cancel;
        v49[2] = "push subscription";
        uint64_t v53 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v54 = *(_DWORD *)(a4 + 48);
          int buf = 136447491;
          int v94 = "dso_add_activity";
          __int16 v95 = 1024;
          *(_DWORD *)int v96 = v54;
          *(_WORD *)&v96[4] = 2160;
          *(void *)&v96[6] = 1752392040;
          *(_WORD *)&v96[14] = 2081;
          *(void *)&v96[16] = v52;
          *(_WORD *)&v96[24] = 2082;
          *(void *)&v96[26] = "push subscription";
          *(_WORD *)&v96[34] = 2048;
          *(void *)&v96[36] = v45;
          _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%u] Adding a DSO activity - activity name: %{private, mask.hash}s, activity type: %{public}s, activity context: %p.", (uint8_t *)&buf, 0x3Au);
        }
        void *v49 = *(void *)(a4 + 80);
        *(void *)(a4 + 80) = v49;
      }
      int v55 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v56 = *(_DWORD *)v45;
        int buf = 136447490;
        int v94 = "dns_push_subscribe";
        __int16 v95 = 1024;
        *(_DWORD *)int v96 = v56;
        *(_WORD *)&v96[4] = 2048;
        *(void *)&v96[6] = v45;
        *(_WORD *)&v96[14] = 2080;
        *(void *)&v96[16] = "query";
        *(_WORD *)&v96[24] = 2080;
        *(void *)&v96[26] = "dnssd-proxy.c";
        *(_WORD *)&v96[34] = 1024;
        *(_DWORD *)&v96[36] = 3509;
        _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&buf, 0x36u);
      }
      int v57 = *(_DWORD *)v45;
      if (*(_DWORD *)v45)
      {
        int v58 = v57 + 1;
        *(_DWORD *)uint64_t v45 = v57 + 1;
        if (v57 + 1 >= 10001)
        {
          int v59 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
            goto LABEL_98;
          }
          int buf = 136447490;
          int v94 = "dns_push_subscribe";
          __int16 v95 = 1024;
          *(_DWORD *)int v96 = v58;
          *(_WORD *)&v96[4] = 2048;
          *(void *)&v96[6] = v45;
          *(_WORD *)&v96[14] = 2080;
          *(void *)&v96[16] = "query";
          *(_WORD *)&v96[24] = 2080;
          *(void *)&v96[26] = "dnssd-proxy.c";
          *(_WORD *)&v96[34] = 1024;
          *(_DWORD *)&v96[36] = 3509;
          int v60 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
          goto LABEL_97;
        }
      }
      else
      {
        ++dnssd_query_created;
        *(_DWORD *)uint64_t v45 = 1;
      }
      *(void *)(v45 + 80) = v49;
      char v78 = 0;
      if (dp_query_start(v45, &v79, &v78))
      {
        dns_name_print_to_limit((uint64_t *)v72[0], 0, (uint64_t)&buf, 0x100uLL);
        dso_simple_response(*(void *)(a2 + 8), 0, a3, 0);
        if (v78)
        {
          uint64_t v61 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v62 = *(_DWORD *)(a4 + 48);
            int v63 = *(_DWORD *)(v45 + 4);
            int v81 = 136447747;
            int v82 = "dns_push_subscribe";
            __int16 v83 = 1024;
            int v84 = v62;
            __int16 v85 = 1024;
            int v86 = v63;
            __int16 v87 = 2160;
            *(void *)uint64_t v88 = 1752392040;
            *(_WORD *)&v88[8] = 2081;
            *(void *)&v88[10] = &buf;
            *(_WORD *)&v88[18] = 1024;
            *(_DWORD *)&v88[20] = LOWORD(v72[1]);
            __int16 v89 = 1024;
            int v90 = WORD1(v72[1]);
            _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%d][Q%d] hardwired response for %{private, mask.hash}s %d %d", (uint8_t *)&v81, 0x38u);
          }
          dp_push_response(v45, (uint64_t **)v72);
        }
        else
        {
          uint64_t v66 = *(void *)(v45 + 192);
          if (v66)
          {
            int v67 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              int v68 = *(_DWORD *)(a4 + 48);
              int v69 = *(_DWORD *)(v45 + 4);
              int v70 = *(_DWORD *)(v66 + 64);
              int v81 = 136448003;
              int v82 = "dns_push_subscribe";
              __int16 v83 = 1024;
              int v84 = v68;
              __int16 v85 = 1024;
              int v86 = v69;
              __int16 v87 = 1024;
              *(_DWORD *)uint64_t v88 = v70;
              *(_WORD *)&v88[4] = 2160;
              *(void *)&v88[6] = 1752392040;
              *(_WORD *)&v88[14] = 2081;
              *(void *)&v88[16] = &buf;
              __int16 v89 = 1024;
              int v90 = LOWORD(v72[1]);
              __int16 v91 = 1024;
              int v92 = WORD1(v72[1]);
              _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%d][Q%d][QU%d] replying from cache for %{private, mask.hash}s %d %d", (uint8_t *)&v81, 0x3Eu);
              uint64_t v66 = *(void *)(v45 + 192);
            }
            dp_query_reply_from_cache(v66, v45, 0);
          }
        }
      }
      else
      {
        dso_simple_response(*(void *)(a2 + 8), 0, a3, v79);
        dp_question_cache_remove_queries(*(void *)(v45 + 192));
        dnssd_query_cancel(v45);
      }
      int v64 = *(_DWORD *)v45;
      if (*(_DWORD *)v45)
      {
        int v59 = global_os_log;
        if (v64 < 10001)
        {
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int buf = 136447490;
            int v94 = "dns_push_subscribe";
            __int16 v95 = 1024;
            *(_DWORD *)int v96 = v64;
            *(_WORD *)&v96[4] = 2048;
            *(void *)&v96[6] = v45;
            *(_WORD *)&v96[14] = 2080;
            *(void *)&v96[16] = "query";
            *(_WORD *)&v96[24] = 2080;
            *(void *)&v96[26] = "dnssd-proxy.c";
            *(_WORD *)&v96[34] = 1024;
            *(_DWORD *)&v96[36] = 3541;
            _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&buf, 0x36u);
            int v64 = *(_DWORD *)v45;
          }
          *(_DWORD *)uint64_t v45 = v64 - 1;
          if (v64 == 1)
          {
            int v65 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              int buf = 136447234;
              int v94 = "dns_push_subscribe";
              __int16 v95 = 2048;
              *(void *)int v96 = v45;
              *(_WORD *)&v96[8] = 2080;
              *(void *)&v96[10] = "query";
              *(_WORD *)&v96[18] = 2080;
              *(void *)&v96[20] = "dnssd-proxy.c";
              *(_WORD *)&v96[28] = 1024;
              *(_DWORD *)&v96[30] = 3541;
              _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&buf, 0x30u);
            }
            ++dnssd_query_finalized;
            dnssd_query_finalize((void *)v45);
          }
          goto LABEL_25;
        }
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_98:
        }
          abort();
        int buf = 136447490;
        int v94 = "dns_push_subscribe";
        __int16 v95 = 1024;
        *(_DWORD *)int v96 = v64;
        *(_WORD *)&v96[4] = 2048;
        *(void *)&v96[6] = v45;
        *(_WORD *)&v96[14] = 2080;
        *(void *)&v96[16] = "query";
        *(_WORD *)&v96[24] = 2080;
        *(void *)&v96[26] = "dnssd-proxy.c";
        *(_WORD *)&v96[34] = 1024;
        *(_DWORD *)&v96[36] = 3541;
        int v60 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      }
      else
      {
        int v59 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_98;
        }
        int buf = 136447490;
        int v94 = "dns_push_subscribe";
        __int16 v95 = 1024;
        *(_DWORD *)int v96 = 0;
        *(_WORD *)&v96[4] = 2048;
        *(void *)&v96[6] = v45;
        *(_WORD *)&v96[14] = 2080;
        *(void *)&v96[16] = "query";
        *(_WORD *)&v96[24] = 2080;
        *(void *)&v96[26] = "dnssd-proxy.c";
        *(_WORD *)&v96[34] = 1024;
        *(_DWORD *)&v96[36] = 3541;
        int v60 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      }
LABEL_97:
      _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_FAULT, v60, (uint8_t *)&buf, 0x36u);
      goto LABEL_98;
    }
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_25;
    }
    int v36 = *(_DWORD *)(a4 + 48);
    if (a2) {
      int v37 = *(_DWORD *)(a2 + 4);
    }
    else {
      int v37 = 0;
    }
    int buf = 136447747;
    int v94 = "dns_push_subscription_change";
    __int16 v95 = 1024;
    *(_DWORD *)int v96 = v36;
    *(_WORD *)&v96[4] = 1024;
    *(_DWORD *)&v96[6] = v37;
    *(_WORD *)&v96[10] = 2082;
    *(void *)&v96[12] = a1;
    *(_WORD *)&v96[20] = 2160;
    *(void *)&v96[22] = 1752392040;
    *(_WORD *)&v96[30] = 2081;
    *(void *)&v96[32] = v80;
    *(_WORD *)&v96[40] = 2082;
    *(void *)&v96[42] = __str;
    uint64_t v20 = "%{public}s: [DSO%d][TRK%d] %{public}s for %{private, mask.hash}s (%{public}s) when no subscription exists.";
    __int16 v21 = v29;
    uint32_t v23 = 64;
LABEL_24:
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, v20, (uint8_t *)&buf, v23);
    goto LABEL_25;
  }
  if (v12 == 64)
  {
    int v13 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      int v14 = *(_DWORD *)(a4 + 48);
      if (a2) {
        int v15 = *(_DWORD *)(a2 + 4);
      }
      else {
        int v15 = 0;
      }
      int buf = 136448003;
      int v94 = "dns_push_subscription_change";
      __int16 v95 = 1024;
      *(_DWORD *)int v96 = v14;
      *(_WORD *)&v96[4] = 1024;
      *(_DWORD *)&v96[6] = v15;
      *(_WORD *)&v96[10] = 2082;
      *(void *)&v96[12] = a1;
      *(_WORD *)&v96[20] = 2160;
      *(void *)&v96[22] = 1752392040;
      *(_WORD *)&v96[30] = 2081;
      *(void *)&v96[32] = v80;
      *(_WORD *)&v96[40] = 2082;
      *(void *)&v96[42] = __str;
      __int16 v97 = 1024;
      int v98 = v10;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%{public}s: [DSO%d][TRK%d] %{public}s for %{private, mask.hash}s (%{public}s) xid %d when subscription already exists.", (uint8_t *)&buf, 0x46u);
    }
    uint64_t v41 = *(void *)(a2 + 8);
    uint64_t v42 = a3;
    int v43 = 5;
    goto LABEL_45;
  }
  int v32 = activity;
  uint64_t v33 = (uint64_t)activity[3];
  uint64_t v34 = *(void *)(v33 + 192);
  if (v34) {
    unsigned int v35 = *(char **)(v34 + 32);
  }
  else {
    unsigned int v35 = v80;
  }
  uint64_t v38 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v39 = *(_DWORD *)(a4 + 48);
    if (a2) {
      int v40 = *(_DWORD *)(a2 + 4);
    }
    else {
      int v40 = 0;
    }
    int buf = 136448003;
    int v94 = "dns_push_subscription_change";
    __int16 v95 = 1024;
    *(_DWORD *)int v96 = v39;
    *(_WORD *)&v96[4] = 1024;
    *(_DWORD *)&v96[6] = v40;
    *(_WORD *)&v96[10] = 2082;
    *(void *)&v96[12] = a1;
    *(_WORD *)&v96[20] = 2160;
    *(void *)&v96[22] = 1752392040;
    *(_WORD *)&v96[30] = 2081;
    *(void *)&v96[32] = v35;
    *(_WORD *)&v96[40] = 2082;
    *(void *)&v96[42] = __str;
    __int16 v97 = 1024;
    int v98 = LOWORD(v72[1]);
    _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%d][TRK%d] %{public}s for %{private, mask.hash}s (%{public}s) type %d.", (uint8_t *)&buf, 0x46u);
    uint64_t v33 = (uint64_t)v32[3];
  }
  dnssd_query_cancel(v33);
LABEL_25:
  dns_rrdata_free((uint64_t)v72);
  BOOL result = v72[0];
  do
  {
    if (!result) {
      break;
    }
    uint64_t v28 = (void *)*result;
    free(result);
    BOOL result = v28;
  }
  while (v28);
  return result;
}

uint64_t *dp_served(uint64_t *a1, uint64_t a2)
{
  uint64_t v4 = &served_domains;
  while (1)
  {
    uint64_t v4 = (uint64_t *)*v4;
    if (!v4) {
      break;
    }
    int v5 = dns_name_subdomain_of(a1, (uint64_t **)v4[3]);
    if (v5)
    {
      dns_name_print_to_limit(a1, v5, a2, 0x100uLL);
      return v4;
    }
  }
  return v4;
}

int *dp_query_create(int *a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  int v10 = dp_served(*(uint64_t **)a2, (uint64_t)v89);
  if (a3) {
    unsigned int v88 = bswap32(*(unsigned __int16 *)(a3 + 88)) >> 16;
  }
  else {
    unsigned int v88 = 0;
  }
  int v11 = (int *)malloc_type_calloc(1uLL, 0xD0uLL, 0x1030040B73B653FuLL);
  if (!v11)
  {
    *a5 = 2;
    char v78 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446723;
      int v94 = "dp_query_create";
      __int16 v95 = 2160;
      *(void *)int v96 = 1752392040;
      *(_WORD *)&v96[8] = 2081;
      *(void *)&v96[10] = v89;
      _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_ERROR, "%{public}s: Unable to allocate memory for query on %{private, mask.hash}s", buf, 0x20u);
    }
    return 0;
  }
  int v12 = v11;
  int v13 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = *v12;
    *(_DWORD *)int buf = 136447490;
    int v94 = "dp_query_create";
    __int16 v95 = 1024;
    *(_DWORD *)int v96 = v14;
    *(_WORD *)&v96[4] = 2048;
    *(void *)&v96[6] = v12;
    *(_WORD *)&v96[14] = 2080;
    *(void *)&v96[16] = "query";
    *(_WORD *)&v96[24] = 2080;
    *(void *)&v96[26] = "dnssd-proxy.c";
    *(_WORD *)&v96[34] = 1024;
    *(_DWORD *)__int16 v97 = 3347;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  int v15 = *v12;
  if (*v12)
  {
    int v16 = v15 + 1;
    int *v12 = v15 + 1;
    if (v15 + 1 >= 10001)
    {
      int v17 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_112;
      }
      *(_DWORD *)int buf = 136447490;
      int v94 = "dp_query_create";
      __int16 v95 = 1024;
      *(_DWORD *)int v96 = v16;
      *(_WORD *)&v96[4] = 2048;
      *(void *)&v96[6] = v12;
      *(_WORD *)&v96[14] = 2080;
      *(void *)&v96[16] = "query";
      *(_WORD *)&v96[24] = 2080;
      *(void *)&v96[26] = "dnssd-proxy.c";
      *(_WORD *)&v96[34] = 1024;
      *(_DWORD *)__int16 v97 = 3347;
      int v18 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_11;
    }
  }
  else
  {
    ++dnssd_query_created;
    int *v12 = 1;
  }
  int v21 = cur_query_serial + 1;
  cur_query_serial = v21;
  v12[1] = v21;
  if (v10)
  {
    uint64_t v22 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_23;
    }
    int v23 = *(unsigned __int16 *)(a2 + 8);
    uint64_t v24 = "push";
    int v25 = *(unsigned __int16 *)(a2 + 10);
    uint64_t v26 = v10[1];
    if (!a4) {
      uint64_t v24 = " dns";
    }
    *(_DWORD *)int buf = 136449283;
    int v94 = "dp_query_create";
    __int16 v95 = 1024;
    *(_DWORD *)int v96 = v21;
    *(_WORD *)&v96[4] = 1024;
    *(_DWORD *)&v96[6] = v88;
    *(_WORD *)&v96[10] = 2048;
    *(void *)&v96[12] = a3;
    *(_WORD *)&v96[20] = 2082;
    *(void *)&v96[22] = v24;
    *(_WORD *)&v96[30] = 1024;
    *(_DWORD *)&v96[32] = v23;
    *(_WORD *)__int16 v97 = 1024;
    *(_DWORD *)&v97[2] = v25;
    __int16 v98 = 2160;
    uint64_t v99 = 1752392040;
    __int16 v100 = 2081;
    int v101 = v89;
    __int16 v102 = 2160;
    uint64_t v103 = 1752392040;
    __int16 v104 = 2081;
    uint64_t v105 = v26;
    __int16 v106 = 2160;
    uint64_t v107 = 1752392040;
    __int16 v108 = 2081;
    uint64_t v109 = v89;
    uint64_t v27 = "%{public}s: [Q%d][QID%x] msg %p %{public}s question: type %d class %d %{private, mask.hash}s.%{private, mask.h"
          "ash}s -> %{private, mask.hash}s.local.";
    uint64_t v28 = v22;
    uint32_t v29 = 116;
  }
  else
  {
    dns_name_print_to_limit(*(uint64_t **)a2, 0, (uint64_t)v89, 0x100uLL);
    uint64_t v30 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_23;
    }
    int v31 = v12[1];
    int v32 = "push";
    int v33 = *(unsigned __int16 *)(a2 + 8);
    int v34 = *(unsigned __int16 *)(a2 + 10);
    if (!a4) {
      int v32 = " dns";
    }
    *(_DWORD *)int buf = 136448259;
    int v94 = "dp_query_create";
    __int16 v95 = 1024;
    *(_DWORD *)int v96 = v31;
    *(_WORD *)&v96[4] = 1024;
    *(_DWORD *)&v96[6] = v88;
    *(_WORD *)&v96[10] = 2048;
    *(void *)&v96[12] = a3;
    *(_WORD *)&v96[20] = 2082;
    *(void *)&v96[22] = v32;
    *(_WORD *)&v96[30] = 1024;
    *(_DWORD *)&v96[32] = v33;
    *(_WORD *)__int16 v97 = 1024;
    *(_DWORD *)&v97[2] = v34;
    __int16 v98 = 2160;
    uint64_t v99 = 1752392040;
    __int16 v100 = 2081;
    int v101 = v89;
    uint64_t v27 = "%{public}s: [Q%d][QID%x] msg %p %{public}s question: type %d class %d %{private, mask.hash}s";
    uint64_t v28 = v30;
    uint32_t v29 = 76;
  }
  _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, v27, buf, v29);
LABEL_23:
  unsigned int v35 = malloc_type_malloc(0x582uLL, 0x10000408470CEFFuLL);
  *((void *)v12 + 20) = v35;
  if (!v35)
  {
    *a5 = 2;
    int v79 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      int v80 = v12[1];
      *(_DWORD *)int buf = 136446979;
      int v94 = "dp_query_create";
      __int16 v95 = 1024;
      *(_DWORD *)int v96 = v80;
      *(_WORD *)&v96[4] = 2160;
      *(void *)&v96[6] = 1752392040;
      *(_WORD *)&v96[14] = 2081;
      *(void *)&v96[16] = v89;
      _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_ERROR, "%{public}s: [Q%d] Unable to allocate memory for query response on %{private, mask.hash}s", buf, 0x26u);
      if (!*a5) {
        return v12;
      }
    }
    goto LABEL_96;
  }
  *((void *)v12 + 22) = 1398;
  v35[2] = 0;
  *(void *)unsigned int v35 = 0;
  *((void *)v12 + 1) = a1;
  if (a1)
  {
    int v36 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v37 = *a1;
      *(_DWORD *)int buf = 136447490;
      int v94 = "dp_query_create";
      __int16 v95 = 1024;
      *(_DWORD *)int v96 = v37;
      *(_WORD *)&v96[4] = 2048;
      *(void *)&v96[6] = a1;
      *(_WORD *)&v96[14] = 2080;
      *(void *)&v96[16] = "query->tracker";
      *(_WORD *)&v96[24] = 2080;
      *(void *)&v96[26] = "dnssd-proxy.c";
      *(_WORD *)&v96[34] = 1024;
      *(_DWORD *)__int16 v97 = 3375;
      _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      a1 = (int *)*((void *)v12 + 1);
    }
    int v38 = *a1;
    if (*a1)
    {
      int v39 = v38 + 1;
      *a1 = v38 + 1;
      if (v38 + 1 >= 10001)
      {
        uint64_t v40 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_112;
        }
        *(_DWORD *)int buf = 136447490;
        int v94 = "dp_query_create";
        __int16 v95 = 1024;
        *(_DWORD *)int v96 = v39;
        *(_WORD *)&v96[4] = 2048;
        *(void *)&v96[6] = a1;
        *(_WORD *)&v96[14] = 2080;
        *(void *)&v96[16] = "query->tracker";
        *(_WORD *)&v96[24] = 2080;
        *(void *)&v96[26] = "dnssd-proxy.c";
        *(_WORD *)&v96[34] = 1024;
        *(_DWORD *)__int16 v97 = 3375;
        int v18 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        uint64_t v19 = buf;
        goto LABEL_110;
      }
    }
    else
    {
      ++dp_tracker_created;
      *a1 = 1;
    }
  }
  *((void *)v12 + 9) = a4;
  if (a3)
  {
    *((void *)v12 + 8) = a3;
    ioloop_message_retain_((int *)a3, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 3383);
  }
  uint64_t v41 = *((void *)v12 + 20);
  uint64_t v42 = v41 + 12 + *((void *)v12 + 22);
  *((void *)v12 + 12) = v41;
  *((void *)v12 + 13) = v41 + 12;
  *((void *)v12 + 19) = 0;
  *((void *)v12 + 15) = 0;
  *((void *)v12 + 16) = 0;
  *((void *)v12 + 14) = v42;
  int v43 = dp_served(*(uint64_t **)a2, (uint64_t)buf);
  if (v43)
  {
    uint64_t v44 = v43 + 6;
  }
  else
  {
    dns_name_print_to_limit(*(uint64_t **)a2, 0, (uint64_t)buf, 0x100uLL);
    uint64_t v44 = &questions_without_domain;
  }
  uint64_t v45 = *v44;
  if (!*v44)
  {
LABEL_43:
    __int16 v47 = malloc_type_calloc(1uLL, 0x50uLL, 0x1030040F8A6FD2BuLL);
    if (v47)
    {
      uint64_t v48 = (uint64_t)v47;
      uint64_t v49 = strdup((const char *)buf);
      *(void *)(v48 + 32) = v49;
      if (v49)
      {
        *(_DWORD *)(v48 + 72) = *(_DWORD *)(a2 + 8);
        *(void *)__tp = 0;
        *(void *)&__tp[8] = 0;
        clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)__tp);
        uint64_t v50 = *(void *)&__tp[8] / 1000 + 1000000 * *(void *)__tp;
        *(void *)(v48 + 40) = 0;
        *(void *)(v48 + 48) = v50;
        *(void *)(v48 + 8) = v43;
        *(void *)(v48 + 16) = 0;
        *(unsigned char *)(v48 + 76) = 0;
        *(_DWORD *)(v48 + 64) = ++cur_question_serial;
        if (v43)
        {
          size_t v51 = (_DWORD *)v43[5];
          if (v51)
          {
            LODWORD(v51) = *v51;
            int v52 = 1024;
LABEL_50:
            *(_DWORD *)(v48 + 68) = v51;
            *(_DWORD *)(v48 + 56) = v52;
            *(void *)uint64_t v48 = *v44;
            uint64_t *v44 = v48;
            uint64_t v53 = global_os_log;
            uint64_t v54 = v48;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              int v55 = *(_DWORD *)(v48 + 60);
              *(_DWORD *)__tp = 136447490;
              *(void *)&__tp[4] = "dp_query_question_cache_copy";
              *(_WORD *)&__tp[12] = 1024;
              *(_DWORD *)&__tp[14] = v55;
              *(_WORD *)&__tp[18] = 2048;
              *(void *)&__tp[20] = v48;
              *(_WORD *)&__tp[28] = 2080;
              *(void *)&__tp[30] = "*questions";
              *(_WORD *)&__tp[38] = 2080;
              *(void *)&__tp[40] = "dnssd-proxy.c";
              __int16 v91 = 1024;
              int v92 = 3185;
              _os_log_impl((void *)&_mh_execute_header, v53, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", __tp, 0x36u);
              uint64_t v54 = *v44;
            }
            int v56 = *(_DWORD *)(v54 + 60);
            if (v56)
            {
              int v57 = v56 + 1;
              *(_DWORD *)(v54 + 60) = v56 + 1;
              if (v56 + 1 >= 10001)
              {
                uint64_t v40 = global_os_log;
                if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                  goto LABEL_112;
                }
                *(_DWORD *)__tp = 136447490;
                *(void *)&__tp[4] = "dp_query_question_cache_copy";
                *(_WORD *)&__tp[12] = 1024;
                *(_DWORD *)&__tp[14] = v57;
                *(_WORD *)&__tp[18] = 2048;
                *(void *)&__tp[20] = v54;
                *(_WORD *)&__tp[28] = 2080;
                *(void *)&__tp[30] = "*questions";
                *(_WORD *)&__tp[38] = 2080;
                *(void *)&__tp[40] = "dnssd-proxy.c";
                __int16 v91 = 1024;
                int v92 = 3185;
                int v18 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
                goto LABEL_109;
              }
              int v58 = 0;
            }
            else
            {
              int v58 = 0;
              ++question_created;
              *(_DWORD *)(v54 + 60) = 1;
            }
            uint64_t v44 = (uint64_t *)v48;
            goto LABEL_57;
          }
        }
        else
        {
          LODWORD(v51) = 0;
        }
        int v52 = 4096;
        goto LABEL_50;
      }
      int v82 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__tp = 136446723;
        *(void *)&__tp[4] = "dp_query_question_cache_copy";
        *(_WORD *)&__tp[12] = 2160;
        *(void *)&__tp[14] = 1752392040;
        *(_WORD *)&__tp[22] = 2081;
        *(void *)&__tp[24] = buf;
        _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate memory for question name on %{private, mask.hash}s", __tp, 0x20u);
      }
      int v83 = *(_DWORD *)(v48 + 60);
      if (!v83)
      {
        uint64_t v40 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)__tp = 136447490;
          *(void *)&__tp[4] = "dp_query_question_cache_copy";
          *(_WORD *)&__tp[12] = 1024;
          *(_DWORD *)&__tp[14] = 0;
          *(_WORD *)&__tp[18] = 2048;
          *(void *)&__tp[20] = v48;
          *(_WORD *)&__tp[28] = 2080;
          *(void *)&__tp[30] = "new_question";
          *(_WORD *)&__tp[38] = 2080;
          *(void *)&__tp[40] = "dnssd-proxy.c";
          __int16 v91 = 1024;
          int v92 = 3194;
          int v18 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_109:
          uint64_t v19 = __tp;
LABEL_110:
          uint64_t v20 = v40;
          goto LABEL_111;
        }
        goto LABEL_112;
      }
      int v84 = global_os_log;
      if (v83 >= 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)__tp = 136447490;
          *(void *)&__tp[4] = "dp_query_question_cache_copy";
          *(_WORD *)&__tp[12] = 1024;
          *(_DWORD *)&__tp[14] = v83;
          *(_WORD *)&__tp[18] = 2048;
          *(void *)&__tp[20] = v48;
          *(_WORD *)&__tp[28] = 2080;
          *(void *)&__tp[30] = "new_question";
          *(_WORD *)&__tp[38] = 2080;
          *(void *)&__tp[40] = "dnssd-proxy.c";
          __int16 v91 = 1024;
          int v92 = 3194;
          int v18 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
          uint64_t v19 = __tp;
          uint64_t v20 = v84;
          goto LABEL_111;
        }
        goto LABEL_112;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)__tp = 136447490;
        *(void *)&__tp[4] = "dp_query_question_cache_copy";
        *(_WORD *)&__tp[12] = 1024;
        *(_DWORD *)&__tp[14] = v83;
        *(_WORD *)&__tp[18] = 2048;
        *(void *)&__tp[20] = v48;
        *(_WORD *)&__tp[28] = 2080;
        *(void *)&__tp[30] = "new_question";
        *(_WORD *)&__tp[38] = 2080;
        *(void *)&__tp[40] = "dnssd-proxy.c";
        __int16 v91 = 1024;
        int v92 = 3194;
        _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", __tp, 0x36u);
        int v83 = *(_DWORD *)(v48 + 60);
      }
      *(_DWORD *)(v48 + 60) = v83 - 1;
      if (v83 == 1)
      {
        __int16 v85 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__tp = 136447234;
          *(void *)&__tp[4] = "dp_query_question_cache_copy";
          *(_WORD *)&__tp[12] = 2048;
          *(void *)&__tp[14] = v48;
          *(_WORD *)&__tp[22] = 2080;
          *(void *)&__tp[24] = "new_question";
          *(_WORD *)&__tp[32] = 2080;
          *(void *)&__tp[34] = "dnssd-proxy.c";
          *(_WORD *)&__tp[42] = 1024;
          *(_DWORD *)&__tp[44] = 3194;
          _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", __tp, 0x30u);
        }
        ++question_finalized;
        question_finalize(v48);
      }
    }
    else
    {
      int v81 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__tp = 136446723;
        *(void *)&__tp[4] = "dp_query_question_cache_copy";
        *(_WORD *)&__tp[12] = 2160;
        *(void *)&__tp[14] = 1752392040;
        *(_WORD *)&__tp[22] = 2081;
        *(void *)&__tp[24] = buf;
        _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_ERROR, "%{public}s: Unable to allocate memory for question entry on %{private, mask.hash}s", __tp, 0x20u);
      }
    }
    *((void *)v12 + 24) = 0;
    *a5 = 2;
LABEL_96:
    int v86 = *v12;
    if (*v12)
    {
      int v17 = global_os_log;
      if (v86 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447490;
          int v94 = "dp_query_create";
          __int16 v95 = 1024;
          *(_DWORD *)int v96 = v86;
          *(_WORD *)&v96[4] = 2048;
          *(void *)&v96[6] = v12;
          *(_WORD *)&v96[14] = 2080;
          *(void *)&v96[16] = "query";
          *(_WORD *)&v96[24] = 2080;
          *(void *)&v96[26] = "dnssd-proxy.c";
          *(_WORD *)&v96[34] = 1024;
          *(_DWORD *)__int16 v97 = 3408;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          int v86 = *v12;
        }
        int *v12 = v86 - 1;
        if (v86 == 1)
        {
          __int16 v87 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136447234;
            int v94 = "dp_query_create";
            __int16 v95 = 2048;
            *(void *)int v96 = v12;
            *(_WORD *)&v96[8] = 2080;
            *(void *)&v96[10] = "query";
            *(_WORD *)&v96[18] = 2080;
            *(void *)&v96[20] = "dnssd-proxy.c";
            *(_WORD *)&v96[28] = 1024;
            *(_DWORD *)&v96[30] = 3408;
            _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          }
          ++dnssd_query_finalized;
          dnssd_query_finalize(v12);
        }
        return 0;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)int buf = 136447490;
        int v94 = "dp_query_create";
        __int16 v95 = 1024;
        *(_DWORD *)int v96 = v86;
        *(_WORD *)&v96[4] = 2048;
        *(void *)&v96[6] = v12;
        *(_WORD *)&v96[14] = 2080;
        *(void *)&v96[16] = "query";
        *(_WORD *)&v96[24] = 2080;
        *(void *)&v96[26] = "dnssd-proxy.c";
        *(_WORD *)&v96[34] = 1024;
        *(_DWORD *)__int16 v97 = 3408;
        int v18 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_11;
      }
    }
    else
    {
      int v17 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)int buf = 136447490;
        int v94 = "dp_query_create";
        __int16 v95 = 1024;
        *(_DWORD *)int v96 = 0;
        *(_WORD *)&v96[4] = 2048;
        *(void *)&v96[6] = v12;
        *(_WORD *)&v96[14] = 2080;
        *(void *)&v96[16] = "query";
        *(_WORD *)&v96[24] = 2080;
        *(void *)&v96[26] = "dnssd-proxy.c";
        *(_WORD *)&v96[34] = 1024;
        *(_DWORD *)__int16 v97 = 3408;
        int v18 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_11:
        uint64_t v19 = buf;
        uint64_t v20 = v17;
LABEL_111:
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_FAULT, v18, v19, 0x36u);
      }
    }
LABEL_112:
    abort();
  }
  int v46 = *(unsigned __int16 *)(a2 + 8);
  while (1)
  {
    uint64_t v44 = (uint64_t *)v45;
    if (v46 == *(unsigned __int16 *)(v45 + 72)
      && *(unsigned __int16 *)(a2 + 10) == *(unsigned __int16 *)(v45 + 74)
      && !strcmp((const char *)buf, *(const char **)(v45 + 32)))
    {
      break;
    }
    uint64_t v45 = *v44;
    if (!*v44) {
      goto LABEL_43;
    }
  }
  int v58 = 1;
LABEL_57:
  int v59 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v60 = *((_DWORD *)v44 + 15);
    *(_DWORD *)__tp = 136447490;
    *(void *)&__tp[4] = "dp_query_question_cache_copy";
    *(_WORD *)&__tp[12] = 1024;
    *(_DWORD *)&__tp[14] = v60;
    *(_WORD *)&__tp[18] = 2048;
    *(void *)&__tp[20] = v44;
    *(_WORD *)&__tp[28] = 2080;
    *(void *)&__tp[30] = "ret";
    *(_WORD *)&__tp[38] = 2080;
    *(void *)&__tp[40] = "dnssd-proxy.c";
    __int16 v91 = 1024;
    int v92 = 3197;
    _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", __tp, 0x36u);
  }
  int v61 = *((_DWORD *)v44 + 15);
  if (v61)
  {
    int v62 = v61 + 1;
    *((_DWORD *)v44 + 15) = v61 + 1;
    if (v61 + 1 >= 10001)
    {
      uint64_t v40 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_112;
      }
      *(_DWORD *)__tp = 136447490;
      *(void *)&__tp[4] = "dp_query_question_cache_copy";
      *(_WORD *)&__tp[12] = 1024;
      *(_DWORD *)&__tp[14] = v62;
      *(_WORD *)&__tp[18] = 2048;
      *(void *)&__tp[20] = v44;
      *(_WORD *)&__tp[28] = 2080;
      *(void *)&__tp[30] = "ret";
      *(_WORD *)&__tp[38] = 2080;
      *(void *)&__tp[40] = "dnssd-proxy.c";
      __int16 v91 = 1024;
      int v92 = 3197;
      int v18 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_109;
    }
  }
  else
  {
    ++question_created;
    *((_DWORD *)v44 + 15) = 1;
  }
  *((void *)v12 + 24) = v44;
  int v63 = (int **)(v44 + 2);
  do
  {
    int v64 = v63;
    int v65 = *v63;
    int v63 = (int **)(*v63 + 46);
  }
  while (v65);
  *int v64 = v12;
  uint64_t v66 = global_os_log;
  int v67 = v12;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v68 = *v12;
    *(_DWORD *)int buf = 136447490;
    int v94 = "dp_query_create";
    __int16 v95 = 1024;
    *(_DWORD *)int v96 = v68;
    *(_WORD *)&v96[4] = 2048;
    *(void *)&v96[6] = v12;
    *(_WORD *)&v96[14] = 2080;
    *(void *)&v96[16] = "*qr";
    *(_WORD *)&v96[24] = 2080;
    *(void *)&v96[26] = "dnssd-proxy.c";
    *(_WORD *)&v96[34] = 1024;
    *(_DWORD *)__int16 v97 = 3400;
    _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    int v67 = *v64;
  }
  int v69 = *v67;
  if (!*v67)
  {
    ++dnssd_query_created;
    int v69 = *v67;
  }
  int v70 = v69 + 1;
  *int v67 = v69 + 1;
  unsigned __int16 v71 = global_os_log;
  if (v69 + 1 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_112;
    }
    *(_DWORD *)int buf = 136447490;
    int v94 = "dp_query_create";
    __int16 v95 = 1024;
    *(_DWORD *)int v96 = v70;
    *(_WORD *)&v96[4] = 2048;
    *(void *)&v96[6] = v67;
    *(_WORD *)&v96[14] = 2080;
    *(void *)&v96[16] = "*qr";
    *(_WORD *)&v96[24] = 2080;
    *(void *)&v96[26] = "dnssd-proxy.c";
    *(_WORD *)&v96[34] = 1024;
    *(_DWORD *)__int16 v97 = 3400;
    int v18 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
    uint64_t v19 = buf;
    uint64_t v20 = v71;
    goto LABEL_111;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v72 = v12[1];
    long long v73 = "new";
    uint64_t v74 = *((void *)v12 + 8);
    int v75 = *(unsigned __int16 *)(a2 + 8);
    if (v58) {
      long long v73 = " existing";
    }
    int v76 = *(unsigned __int16 *)(a2 + 10);
    *(_DWORD *)int buf = 136448259;
    int v94 = "dp_query_create";
    __int16 v95 = 1024;
    *(_DWORD *)int v96 = v72;
    *(_WORD *)&v96[4] = 1024;
    *(_DWORD *)&v96[6] = v88;
    *(_WORD *)&v96[10] = 2048;
    *(void *)&v96[12] = v74;
    *(_WORD *)&v96[20] = 2082;
    *(void *)&v96[22] = v73;
    *(_WORD *)&v96[30] = 1024;
    *(_DWORD *)&v96[32] = v75;
    *(_WORD *)__int16 v97 = 1024;
    *(_DWORD *)&v97[2] = v76;
    __int16 v98 = 2160;
    uint64_t v99 = 1752392040;
    __int16 v100 = 2081;
    int v101 = v89;
    _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][QID%x] msg %p %{public}s cache entry for question: type %d class %d %{private, mask.hash}s", buf, 0x4Cu);
  }
  *a5 = 0;
  ++dp_num_outstanding_queries;
  return v12;
}

uint64_t dp_query_start(uint64_t a1, _DWORD *a2, unsigned char *a3)
{
  uint64_t v5 = *(void *)(a1 + 192);
  uint64_t v6 = *(void *)(v5 + 8);
  if (!v6) {
    goto LABEL_51;
  }
  uint64_t v8 = *(void *)(v5 + 8);
  unsigned int v9 = *(uint8_t **)(v5 + 32);
  if (!strcasecmp((const char *)v9, &uuid_name))
  {
    int v16 = *(unsigned __int16 *)(v5 + 72);
    if (v16 == 28 || v16 == 1)
    {
      uint64_t v18 = *(void *)(a1 + 64);
      if (v18) {
        uint64_t v19 = v18 + 32;
      }
      else {
        uint64_t v19 = *(void *)(*(void *)(a1 + 72) + 32) + 344;
      }
      int v20 = *(unsigned __int8 *)(v19 + 1);
      if (v16 == 1)
      {
        if (v20 == 30)
        {
          if (*(void *)(v19 + 8) | *(unsigned int *)(v19 + 16) ^ 0xFFFF0000) {
            goto LABEL_49;
          }
          dp_query_add_data_to_response(a1, v9, 1u, 1, 4uLL, (int32x4_t *)(v19 + 20), 3600, 1, 1, (_WORD *)(*(void *)(a1 + 160) + 6));
          goto LABEL_102;
        }
        if (v20 != 2) {
          goto LABEL_49;
        }
        int v21 = (int32x4_t *)(v19 + 4);
        uint64_t v53 = (_WORD *)(*(void *)(a1 + 160) + 6);
        uint64_t v22 = a1;
        int v23 = v9;
        unsigned int v24 = 1;
        size_t v25 = 4;
      }
      else
      {
        if (v16 != 28 || v20 != 30) {
          goto LABEL_49;
        }
        uint64_t v28 = *(void *)(v19 + 8);
        uint64_t v27 = v19 + 8;
        if (!(v28 | *(unsigned int *)(v27 + 8) ^ 0xFFFF0000)) {
          goto LABEL_49;
        }
        long long v54 = *(_OWORD *)v27;
        BOOL v29 = DWORD2(v54) == -16777216 && *(_DWORD *)((char *)&v54 + 11) == -67043585;
        if (v29 || (DWORD2(v54) == -16777216 ? (BOOL v30 = WORD6(v54) == 254) : (BOOL v30 = 0), v30))
        {
          uint64_t v48 = *(void *)(srp_servers + 48);
          if (!v48 || !*(unsigned char *)(v48 + 258))
          {
LABEL_102:
            *a2 = 0;
            uint64_t v44 = 1;
            *a3 = 1;
            size_t v51 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              int v52 = *(_DWORD *)(a1 + 4);
              *(_DWORD *)int buf = 136446466;
              int v56 = "dp_query_start";
              __int16 v57 = 1024;
              *(_DWORD *)int v58 = v52;
              _os_log_impl((void *)&_mh_execute_header, v51, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d] hardwired response", buf, 0x12u);
            }
            return v44;
          }
          long long v54 = *(_OWORD *)(v48 + 176);
          int v31 = "thread device ML-EID";
        }
        else
        {
          int v31 = "local host IPv6 address";
        }
        uint64_t v49 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          if ((v54 & 0xFE) == 0xFC)
          {
            uint64_t v50 = "ULA: ";
          }
          else if (v54 == 254 && (BYTE1(v54) & 0xC0) == 0x80)
          {
            uint64_t v50 = "LUA: ";
          }
          else if ((v54 & 0xE0) == 0x20)
          {
            uint64_t v50 = "GUA: ";
          }
          else
          {
            uint64_t v50 = "";
          }
          *(_DWORD *)int buf = 136449283;
          int v56 = "dnssd_hardwired_response";
          __int16 v57 = 2082;
          *(void *)int v58 = v9;
          *(_WORD *)&v58[8] = 2082;
          *(void *)&unsigned char v58[10] = v50;
          *(_WORD *)&v58[18] = 2160;
          *(void *)&v58[20] = 1752392040;
          *(_WORD *)&v58[28] = 1041;
          *(_DWORD *)&v58[30] = 6;
          __int16 v59 = 2097;
          int v60 = &v54;
          __int16 v61 = 2160;
          uint64_t v62 = 1752392040;
          __int16 v63 = 1042;
          int v64 = 2;
          __int16 v65 = 2098;
          uint64_t v66 = (char *)&v54 + 6;
          __int16 v67 = 2160;
          uint64_t v68 = 1752392040;
          __int16 v69 = 1041;
          int v70 = 8;
          __int16 v71 = 2097;
          int v72 = (char *)&v54 + 8;
          __int16 v73 = 2082;
          uint64_t v74 = v31;
          _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s IN AAAA {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} %{public}s", buf, 0x78u);
          unsigned int v9 = *(uint8_t **)(v5 + 32);
          unsigned int v24 = *(unsigned __int16 *)(v5 + 72);
        }
        else
        {
          unsigned int v24 = 28;
        }
        uint64_t v53 = (_WORD *)(*(void *)(a1 + 160) + 6);
        int v21 = (int32x4_t *)&v54;
        uint64_t v22 = a1;
        int v23 = v9;
        size_t v25 = 16;
      }
      dp_query_add_data_to_response(v22, v23, v24, 1, v25, v21, 300, 1, 1, v53);
      goto LABEL_102;
    }
  }
  int v10 = *(uint64_t ***)(v6 + 32);
  if (!v10) {
    goto LABEL_49;
  }
  int v11 = 0;
  do
  {
    uint64_t v12 = *(void *)(a1 + 192);
    int v13 = *(unsigned __int16 *)(v12 + 72);
    unsigned int v14 = *((unsigned __int16 *)v10 + 4);
    BOOL v15 = v13 == 255 || v13 == v14;
    if (v15 && *(_WORD *)(v12 + 74) == 1 && !strcasecmp((const char *)v10[2], *(const char **)(v12 + 32)))
    {
      if (*(void *)(a1 + 72))
      {
        dp_query_add_data_to_response(a1, (uint8_t *)v10[3], v14, 1, *((unsigned __int16 *)v10 + 20), (int32x4_t *)v10[4], 3600, 1, 0, 0);
      }
      else
      {
        int v11 = "hardwired";
        if (*(unsigned char *)(a1 + 144)) {
          goto LABEL_17;
        }
        dp_query_add_data_to_response(a1, (uint8_t *)v10[3], v14, 1, *((unsigned __int16 *)v10 + 20), (int32x4_t *)v10[4], 3600, 1, 0, (_WORD *)(*(void *)(a1 + 160) + 6));
      }
      int v11 = "hardwired";
    }
LABEL_17:
    int v10 = (uint64_t **)*v10;
  }
  while (v10);
  if (v11) {
    goto LABEL_102;
  }
  uint64_t v8 = *(void *)(v5 + 8);
  if (!v8) {
    goto LABEL_51;
  }
LABEL_49:
  if (*(void *)(v8 + 40) && !**(unsigned char **)(v5 + 32))
  {
    uint64_t v44 = 1;
    if (!*(void *)(a1 + 72)) {
      *a3 = 1;
    }
  }
  else
  {
LABEL_51:
    if (*(void *)(v5 + 24))
    {
      if (*(void *)(v5 + 40) || *(unsigned char *)(v5 + 76))
      {
        int v32 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v33 = *(_DWORD *)(a1 + 4);
          *(_DWORD *)int buf = 136446466;
          int v56 = "dp_query_start";
          __int16 v57 = 1024;
          *(_DWORD *)int v58 = v33;
          _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d] answering immediately from cache", buf, 0x12u);
        }
        *a2 = 0;
        return 1;
      }
LABEL_61:
      if (v6) {
        BOOL v36 = *(void *)(a1 + 72) == 0;
      }
      else {
        BOOL v36 = 0;
      }
      if (v36)
      {
        int v38 = *(int **)(a1 + 24);
        if (v38
          || (int v38 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 3323), (*(void *)(a1 + 24) = v38) != 0))
        {
          ioloop_add_wake_event((uint64_t)v38, a1, (uint64_t)dp_query_wakeup, (uint64_t)dp_query_context_release, 0x320u);
          int v39 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v40 = *(_DWORD *)a1;
            *(_DWORD *)int buf = 136447490;
            int v56 = "dp_query_start";
            __int16 v57 = 1024;
            *(_DWORD *)int v58 = v40;
            *(_WORD *)&v58[4] = 2048;
            *(void *)&v58[6] = a1;
            *(_WORD *)&v58[14] = 2080;
            *(void *)&v58[16] = "query";
            *(_WORD *)&v58[24] = 2080;
            *(void *)&v58[26] = "dnssd-proxy.c";
            __int16 v59 = 1024;
            LODWORD(v60) = 3330;
            _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          }
          int v41 = *(_DWORD *)a1;
          if (*(_DWORD *)a1)
          {
            int v42 = v41 + 1;
            *(_DWORD *)a1 = v41 + 1;
            int v37 = global_os_log;
            if (v41 + 1 >= 10001)
            {
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)int buf = 136447490;
                int v56 = "dp_query_start";
                __int16 v57 = 1024;
                *(_DWORD *)int v58 = v42;
                *(_WORD *)&v58[4] = 2048;
                *(void *)&v58[6] = a1;
                *(_WORD *)&v58[14] = 2080;
                *(void *)&v58[16] = "query";
                *(_WORD *)&v58[24] = 2080;
                *(void *)&v58[26] = "dnssd-proxy.c";
                __int16 v59 = 1024;
                LODWORD(v60) = 3330;
                _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
              }
              abort();
            }
          }
          else
          {
            ++dnssd_query_created;
            *(_DWORD *)a1 = 1;
            int v37 = global_os_log;
          }
          goto LABEL_80;
        }
        uint64_t v44 = 0;
        *a2 = 2;
      }
      else
      {
        int v37 = global_os_log;
LABEL_80:
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        {
          int v46 = *(_DWORD *)(a1 + 4);
          *(_DWORD *)int buf = 136446466;
          int v56 = "dp_query_start";
          __int16 v57 = 1024;
          *(_DWORD *)int v58 = v46;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d] waiting for wakeup or response", buf, 0x12u);
        }
        return 1;
      }
    }
    else
    {
      int started = dp_start_question(v5);
      if (!started) {
        goto LABEL_61;
      }
      if (started == -65553)
      {
        *a2 = 2;
        unsigned int v35 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136446210;
          int v56 = "dp_query_start";
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "%{public}s: question was refused", buf, 0xCu);
        }
        goto LABEL_61;
      }
      *a2 = 2;
      int v43 = global_os_log;
      uint64_t v44 = 0;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v45 = *(_DWORD *)(a1 + 4);
        *(_DWORD *)int buf = 136446466;
        int v56 = "dp_query_start";
        __int16 v57 = 1024;
        *(_DWORD *)int v58 = v45;
        _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d] couldn't start question", buf, 0x12u);
        return 0;
      }
    }
  }
  return v44;
}

void dp_question_cache_remove_queries(uint64_t a1)
{
  if (!a1) {
    return;
  }
  int v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v3 = *(_DWORD *)(a1 + 60);
    *(_DWORD *)int buf = 136447490;
    uint64_t v27 = "dp_question_cache_remove_queries";
    __int16 v28 = 1024;
    *(_DWORD *)BOOL v29 = v3;
    *(_WORD *)&v29[4] = 2048;
    *(void *)&v29[6] = a1;
    *(_WORD *)&v29[14] = 2080;
    *(void *)&v29[16] = "question";
    *(_WORD *)&unsigned char v29[24] = 2080;
    *(void *)&v29[26] = "dnssd-proxy.c";
    __int16 v30 = 1024;
    int v31 = 810;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  int v4 = *(_DWORD *)(a1 + 60);
  if (v4)
  {
    int v5 = v4 + 1;
    *(_DWORD *)(a1 + 60) = v4 + 1;
    if (v4 + 1 >= 10001)
    {
      uint64_t v6 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_60;
      }
      *(_DWORD *)int buf = 136447490;
      uint64_t v27 = "dp_question_cache_remove_queries";
      __int16 v28 = 1024;
      *(_DWORD *)BOOL v29 = v5;
      *(_WORD *)&v29[4] = 2048;
      *(void *)&v29[6] = a1;
      *(_WORD *)&v29[14] = 2080;
      *(void *)&v29[16] = "question";
      *(_WORD *)&unsigned char v29[24] = 2080;
      *(void *)&v29[26] = "dnssd-proxy.c";
      __int16 v30 = 1024;
      int v31 = 810;
      int v7 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_69;
    }
  }
  else
  {
    ++question_created;
    *(_DWORD *)(a1 + 60) = 1;
  }
  uint64_t v8 = (uint64_t *)(a1 + 16);
  uint64_t v9 = *(void *)(a1 + 16);
  if (!v9) {
    goto LABEL_22;
  }
  do
  {
    if (*(unsigned char *)(v9 + 200))
    {
      *uint64_t v8 = *(void *)(v9 + 184);
      int v10 = *(_DWORD *)v9;
      if (!*(_DWORD *)v9)
      {
        uint64_t v24 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_60;
        }
        *(_DWORD *)int buf = 136447490;
        uint64_t v27 = "dp_question_cache_remove_queries";
        __int16 v28 = 1024;
        *(_DWORD *)BOOL v29 = 0;
        *(_WORD *)&v29[4] = 2048;
        *(void *)&v29[6] = v9;
        *(_WORD *)&v29[14] = 2080;
        *(void *)&v29[16] = "cquery";
        *(_WORD *)&unsigned char v29[24] = 2080;
        *(void *)&v29[26] = "dnssd-proxy.c";
        __int16 v30 = 1024;
        int v31 = 816;
        int v7 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        size_t v25 = v24;
        goto LABEL_59;
      }
      int v11 = global_os_log;
      if (v10 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_60;
        }
        *(_DWORD *)int buf = 136447490;
        uint64_t v27 = "dp_question_cache_remove_queries";
        __int16 v28 = 1024;
        *(_DWORD *)BOOL v29 = v10;
        *(_WORD *)&v29[4] = 2048;
        *(void *)&v29[6] = v9;
        *(_WORD *)&v29[14] = 2080;
        *(void *)&v29[16] = "cquery";
        *(_WORD *)&unsigned char v29[24] = 2080;
        *(void *)&v29[26] = "dnssd-proxy.c";
        __int16 v30 = 1024;
        int v31 = 816;
        int v7 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        size_t v25 = v11;
        goto LABEL_59;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136447490;
        uint64_t v27 = "dp_question_cache_remove_queries";
        __int16 v28 = 1024;
        *(_DWORD *)BOOL v29 = v10;
        *(_WORD *)&v29[4] = 2048;
        *(void *)&v29[6] = v9;
        *(_WORD *)&v29[14] = 2080;
        *(void *)&v29[16] = "cquery";
        *(_WORD *)&unsigned char v29[24] = 2080;
        *(void *)&v29[26] = "dnssd-proxy.c";
        __int16 v30 = 1024;
        int v31 = 816;
        _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        int v10 = *(_DWORD *)v9;
      }
      *(_DWORD *)uint64_t v9 = v10 - 1;
      if (v10 == 1)
      {
        uint64_t v12 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447234;
          uint64_t v27 = "dp_question_cache_remove_queries";
          __int16 v28 = 2048;
          *(void *)BOOL v29 = v9;
          *(_WORD *)&timeval v29[8] = 2080;
          *(void *)&v29[10] = "cquery";
          *(_WORD *)&v29[18] = 2080;
          *(void *)&v29[20] = "dnssd-proxy.c";
          *(_WORD *)&v29[28] = 1024;
          *(_DWORD *)&v29[30] = 816;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        }
        ++dnssd_query_finalized;
        dnssd_query_finalize((void *)v9);
      }
    }
    else
    {
      uint64_t v8 = (uint64_t *)(v9 + 184);
    }
    uint64_t v9 = *v8;
  }
  while (*v8);
  if (*(void *)(a1 + 16)) {
    goto LABEL_22;
  }
  uint64_t v15 = *(void *)(a1 + 24);
  if (v15)
  {
    int v16 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = *(_DWORD *)(a1 + 64);
      uint64_t v18 = *(void *)(v15 + 8);
      *(_DWORD *)int buf = 136446978;
      uint64_t v27 = "dp_question_cancel";
      __int16 v28 = 1024;
      *(_DWORD *)BOOL v29 = v17;
      *(_WORD *)&v29[4] = 2048;
      *(void *)&v29[6] = v15;
      *(_WORD *)&v29[14] = 2048;
      *(void *)&v29[16] = v18;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: [QU%d] question->txn = %p sdref=%p", buf, 0x26u);
      uint64_t v15 = *(void *)(a1 + 24);
    }
    ioloop_dnssd_txn_cancel(v15);
    ioloop_dnssd_txn_release_(*(int **)(a1 + 24), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 730);
    *(void *)(a1 + 24) = 0;
  }
  uint64_t v19 = *(void *)(a1 + 8);
  int v20 = (uint64_t *)(v19 + 48);
  if (!v19) {
    int v20 = &questions_without_domain;
  }
  while (1)
  {
    int v21 = v20;
    int v20 = (uint64_t *)*v20;
    if (!v20) {
      break;
    }
    if (v20 == (uint64_t *)a1)
    {
      *int v21 = *(void *)a1;
      uint64_t v19 = *(void *)(a1 + 8);
      break;
    }
  }
  if (v19 && !*(void *)(v19 + 48))
  {
    uint64_t v22 = &served_domains;
    while (1)
    {
      uint64_t v22 = (uint64_t *)*v22;
      if (!v22) {
        break;
      }
      if (v22 == (uint64_t *)v19) {
        goto LABEL_47;
      }
    }
    served_domain_free(v19);
    *(void *)(a1 + 8) = 0;
  }
LABEL_47:
  int v23 = *(_DWORD *)(a1 + 60);
  if (!v23)
  {
    uint64_t v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)int buf = 136447490;
      uint64_t v27 = "dp_question_cancel";
      __int16 v28 = 1024;
      *(_DWORD *)BOOL v29 = 0;
      *(_WORD *)&v29[4] = 2048;
      *(void *)&v29[6] = a1;
      *(_WORD *)&v29[14] = 2080;
      *(void *)&v29[16] = "question";
      *(_WORD *)&unsigned char v29[24] = 2080;
      *(void *)&v29[26] = "dnssd-proxy.c";
      __int16 v30 = 1024;
      int v31 = 764;
      int v7 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_69;
    }
    goto LABEL_60;
  }
  uint64_t v6 = global_os_log;
  if (v23 >= 10001)
  {
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)int buf = 136447490;
      uint64_t v27 = "dp_question_cancel";
      __int16 v28 = 1024;
      *(_DWORD *)BOOL v29 = v23;
      *(_WORD *)&v29[4] = 2048;
      *(void *)&v29[6] = a1;
      *(_WORD *)&v29[14] = 2080;
      *(void *)&v29[16] = "question";
      *(_WORD *)&unsigned char v29[24] = 2080;
      *(void *)&v29[26] = "dnssd-proxy.c";
      __int16 v30 = 1024;
      int v31 = 764;
      int v7 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_69;
    }
    goto LABEL_60;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136447490;
    uint64_t v27 = "dp_question_cancel";
    __int16 v28 = 1024;
    *(_DWORD *)BOOL v29 = v23;
    *(_WORD *)&v29[4] = 2048;
    *(void *)&v29[6] = a1;
    *(_WORD *)&v29[14] = 2080;
    *(void *)&v29[16] = "question";
    *(_WORD *)&unsigned char v29[24] = 2080;
    *(void *)&v29[26] = "dnssd-proxy.c";
    __int16 v30 = 1024;
    int v31 = 764;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    int v23 = *(_DWORD *)(a1 + 60);
    uint64_t v6 = global_os_log;
  }
  int v13 = v23 - 1;
  *(_DWORD *)(a1 + 60) = v13;
  if (!v13)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136447234;
      uint64_t v27 = "dp_question_cancel";
      __int16 v28 = 2048;
      *(void *)BOOL v29 = a1;
      *(_WORD *)&timeval v29[8] = 2080;
      *(void *)&v29[10] = "question";
      *(_WORD *)&v29[18] = 2080;
      *(void *)&v29[20] = "dnssd-proxy.c";
      *(_WORD *)&v29[28] = 1024;
      *(_DWORD *)&v29[30] = 764;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
    }
    ++question_finalized;
    question_finalize(a1);
LABEL_22:
    int v13 = *(_DWORD *)(a1 + 60);
    uint64_t v6 = global_os_log;
    if (!v13)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)int buf = 136447490;
        uint64_t v27 = "dp_question_cache_remove_queries";
        __int16 v28 = 1024;
        *(_DWORD *)BOOL v29 = 0;
        *(_WORD *)&v29[4] = 2048;
        *(void *)&v29[6] = a1;
        *(_WORD *)&v29[14] = 2080;
        *(void *)&v29[16] = "question";
        *(_WORD *)&unsigned char v29[24] = 2080;
        *(void *)&v29[26] = "dnssd-proxy.c";
        __int16 v30 = 1024;
        int v31 = 825;
        int v7 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_69;
      }
LABEL_60:
      abort();
    }
  }
  if (v13 >= 10001)
  {
    if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)int buf = 136447490;
      uint64_t v27 = "dp_question_cache_remove_queries";
      __int16 v28 = 1024;
      *(_DWORD *)BOOL v29 = v13;
      *(_WORD *)&v29[4] = 2048;
      *(void *)&v29[6] = a1;
      *(_WORD *)&v29[14] = 2080;
      *(void *)&v29[16] = "question";
      *(_WORD *)&unsigned char v29[24] = 2080;
      *(void *)&v29[26] = "dnssd-proxy.c";
      __int16 v30 = 1024;
      int v31 = 825;
      int v7 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_69:
      size_t v25 = v6;
LABEL_59:
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_FAULT, v7, buf, 0x36u);
      goto LABEL_60;
    }
    goto LABEL_60;
  }
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136447490;
    uint64_t v27 = "dp_question_cache_remove_queries";
    __int16 v28 = 1024;
    *(_DWORD *)BOOL v29 = v13;
    *(_WORD *)&v29[4] = 2048;
    *(void *)&v29[6] = a1;
    *(_WORD *)&v29[14] = 2080;
    *(void *)&v29[16] = "question";
    *(_WORD *)&unsigned char v29[24] = 2080;
    *(void *)&v29[26] = "dnssd-proxy.c";
    __int16 v30 = 1024;
    int v31 = 825;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    int v13 = *(_DWORD *)(a1 + 60);
  }
  *(_DWORD *)(a1 + 60) = v13 - 1;
  if (v13 == 1)
  {
    unsigned int v14 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136447234;
      uint64_t v27 = "dp_question_cache_remove_queries";
      __int16 v28 = 2048;
      *(void *)BOOL v29 = a1;
      *(_WORD *)&timeval v29[8] = 2080;
      *(void *)&v29[10] = "question";
      *(_WORD *)&v29[18] = 2080;
      *(void *)&v29[20] = "dnssd-proxy.c";
      *(_WORD *)&v29[28] = 1024;
      *(_DWORD *)&v29[30] = 825;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
    }
    ++question_finalized;
    question_finalize(a1);
  }
}

void dnssd_query_cancel(uint64_t a1)
{
  int v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    if (a1) {
      int v3 = *(_DWORD *)(a1 + 4);
    }
    else {
      int v3 = 0;
    }
    uint64_t v4 = *(void *)(a1 + 192);
    int v5 = "";
    if (v4)
    {
      int v6 = *(_DWORD *)(v4 + 64);
      int v7 = *(const char **)(v4 + 32);
      uint64_t v8 = *(void *)(v4 + 8);
      if (v8)
      {
        if (*(void *)(v8 + 40)) {
          uint64_t v9 = ".local.";
        }
        else {
          uint64_t v9 = *(const char **)(v8 + 16);
        }
      }
      else
      {
        uint64_t v9 = "";
      }
    }
    else
    {
      int v6 = 0;
      int v7 = "<null>";
      uint64_t v9 = "";
    }
    if (*(unsigned char *)(a1 + 201)) {
      int v5 = " canceled";
    }
    *(_DWORD *)int buf = 136447747;
    uint64_t v44 = "dnssd_query_cancel";
    __int16 v45 = 1024;
    *(_DWORD *)int v46 = v3;
    *(_WORD *)&v46[4] = 1024;
    *(_DWORD *)&unsigned char v46[6] = v6;
    *(_WORD *)&v46[10] = 2160;
    *(void *)&v46[12] = 1752392040;
    *(_WORD *)&v46[20] = 2081;
    *(void *)&v46[22] = v7;
    *(_WORD *)&v46[30] = 2082;
    *(void *)&v46[32] = v9;
    __int16 v47 = 2082;
    uint64_t v48 = v5;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][QU%d] %{private, mask.hash}s%{public}s%{public}s", buf, 0x40u);
  }
  if (*(unsigned char *)(a1 + 201)) {
    return;
  }
  int v10 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = *(_DWORD *)a1;
    *(_DWORD *)int buf = 136447490;
    uint64_t v44 = "dnssd_query_cancel";
    __int16 v45 = 1024;
    *(_DWORD *)int v46 = v11;
    *(_WORD *)&v46[4] = 2048;
    *(void *)&unsigned char v46[6] = a1;
    *(_WORD *)&v46[14] = 2080;
    *(void *)&v46[16] = "query";
    *(_WORD *)&v46[24] = 2080;
    *(void *)&v46[26] = "dnssd-proxy.c";
    *(_WORD *)&unsigned char v46[34] = 1024;
    *(_DWORD *)&v46[36] = 919;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  int v12 = *(_DWORD *)a1;
  if (*(_DWORD *)a1)
  {
    int v13 = v12 + 1;
    *(_DWORD *)a1 = v12 + 1;
    if (v12 + 1 >= 10001)
    {
      unsigned int v14 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_118;
      }
      *(_DWORD *)int buf = 136447490;
      uint64_t v44 = "dnssd_query_cancel";
      __int16 v45 = 1024;
      *(_DWORD *)int v46 = v13;
      *(_WORD *)&v46[4] = 2048;
      *(void *)&unsigned char v46[6] = a1;
      *(_WORD *)&v46[14] = 2080;
      *(void *)&v46[16] = "query";
      *(_WORD *)&v46[24] = 2080;
      *(void *)&v46[26] = "dnssd-proxy.c";
      *(_WORD *)&unsigned char v46[34] = 1024;
      *(_DWORD *)&v46[36] = 919;
      uint64_t v15 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_97:
      int v42 = v14;
      goto LABEL_117;
    }
  }
  else
  {
    ++dnssd_query_created;
    *(_DWORD *)a1 = 1;
  }
  *(unsigned char *)(a1 + 201) = 1;
  int v16 = *(void **)(a1 + 8);
  if (!v16)
  {
    uint64_t v22 = *(void **)(a1 + 24);
    if (v22)
    {
      ioloop_wakeup_release_(v22, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 996);
      *(void *)(a1 + 24) = 0;
    }
    goto LABEL_84;
  }
  int v17 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v18 = *(_DWORD *)v16;
    *(_DWORD *)int buf = 136447490;
    uint64_t v44 = "dnssd_query_cancel";
    __int16 v45 = 1024;
    *(_DWORD *)int v46 = v18;
    *(_WORD *)&v46[4] = 2048;
    *(void *)&unsigned char v46[6] = v16;
    *(_WORD *)&v46[14] = 2080;
    *(void *)&v46[16] = "tracker";
    *(_WORD *)&v46[24] = 2080;
    *(void *)&v46[26] = "dnssd-proxy.c";
    *(_WORD *)&unsigned char v46[34] = 1024;
    *(_DWORD *)&v46[36] = 925;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  int v19 = *(_DWORD *)v16;
  if (*(_DWORD *)v16)
  {
    int v20 = v19 + 1;
    *(_DWORD *)int v16 = v19 + 1;
    if (v19 + 1 >= 10001)
    {
      uint64_t v21 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)int buf = 136447490;
        uint64_t v44 = "dnssd_query_cancel";
        __int16 v45 = 1024;
        *(_DWORD *)int v46 = v20;
        *(_WORD *)&v46[4] = 2048;
        *(void *)&unsigned char v46[6] = v16;
        *(_WORD *)&v46[14] = 2080;
        *(void *)&v46[16] = "tracker";
        *(_WORD *)&v46[24] = 2080;
        *(void *)&v46[26] = "dnssd-proxy.c";
        *(_WORD *)&unsigned char v46[34] = 1024;
        *(_DWORD *)&v46[36] = 925;
        uint64_t v15 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        goto LABEL_113;
      }
      goto LABEL_118;
    }
  }
  else
  {
    ++dp_tracker_created;
    int v20 = 1;
    *(_DWORD *)int v16 = 1;
  }
  uint64_t v23 = *(void *)(a1 + 72);
  if (v23)
  {
    uint64_t v24 = *(void **)(a1 + 80);
    if (v24)
    {
      dso_drop_activity(v23, v24);
      *(void *)(a1 + 80) = 0;
      int v20 = *(_DWORD *)v16;
    }
    *(void *)(a1 + 8) = 0;
    if (!v20)
    {
      uint64_t v21 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_118;
      }
      *(_DWORD *)int buf = 136447490;
      uint64_t v44 = "dnssd_query_cancel";
      __int16 v45 = 1024;
      *(_DWORD *)int v46 = 0;
      *(_WORD *)&v46[4] = 2048;
      *(void *)&unsigned char v46[6] = v16;
      *(_WORD *)&v46[14] = 2080;
      *(void *)&v46[16] = "tracker";
      *(_WORD *)&v46[24] = 2080;
      *(void *)&v46[26] = "dnssd-proxy.c";
      *(_WORD *)&unsigned char v46[34] = 1024;
      *(_DWORD *)&v46[36] = 975;
      uint64_t v15 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_113;
    }
    size_t v25 = global_os_log;
    if (v20 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_118;
      }
      *(_DWORD *)int buf = 136447490;
      uint64_t v44 = "dnssd_query_cancel";
      __int16 v45 = 1024;
      *(_DWORD *)int v46 = v20;
      *(_WORD *)&v46[4] = 2048;
      *(void *)&unsigned char v46[6] = v16;
      *(_WORD *)&v46[14] = 2080;
      *(void *)&v46[16] = "tracker";
      *(_WORD *)&v46[24] = 2080;
      *(void *)&v46[26] = "dnssd-proxy.c";
      *(_WORD *)&unsigned char v46[34] = 1024;
      *(_DWORD *)&v46[36] = 975;
      uint64_t v15 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_116;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136447490;
      uint64_t v44 = "dnssd_query_cancel";
      __int16 v45 = 1024;
      *(_DWORD *)int v46 = v20;
      *(_WORD *)&v46[4] = 2048;
      *(void *)&unsigned char v46[6] = v16;
      *(_WORD *)&v46[14] = 2080;
      *(void *)&v46[16] = "tracker";
      *(_WORD *)&v46[24] = 2080;
      *(void *)&v46[26] = "dnssd-proxy.c";
      *(_WORD *)&unsigned char v46[34] = 1024;
      *(_DWORD *)&v46[36] = 975;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      int v20 = *(_DWORD *)v16;
    }
    *(_DWORD *)int v16 = v20 - 1;
    if (v20 == 1)
    {
      uint64_t v26 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136447234;
        uint64_t v44 = "dnssd_query_cancel";
        __int16 v45 = 2048;
        *(void *)int v46 = v16;
        *(_WORD *)&v46[8] = 2080;
        *(void *)&v46[10] = "tracker";
        *(_WORD *)&v46[18] = 2080;
        *(void *)&v46[20] = "dnssd-proxy.c";
        *(_WORD *)&v46[28] = 1024;
        *(_DWORD *)&v46[30] = 975;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
      }
      ++dp_tracker_finalized;
      dp_tracker_finalize(v16);
    }
  }
  else
  {
    uint64_t v27 = v16 + 2;
    __int16 v28 = (void *)v16[2];
    if (v28)
    {
      char v29 = 0;
      uint64_t v30 = v16[2];
      do
      {
        if (*(void *)(a1 + 64) == *(void *)(v30 + 64)) {
          v29 |= *(unsigned char *)(a1 + 200) == 0;
        }
        uint64_t v30 = *(void *)(v30 + 16);
      }
      while (v30);
      if ((v29 & 1) == 0)
      {
        do
        {
          if (*(void *)(a1 + 64) == v28[8])
          {
            void *v27 = v28[2];
            int v31 = (void *)v28[3];
            if (v31)
            {
              ioloop_wakeup_release_(v31, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 950);
              v28[3] = 0;
            }
            int v32 = *(_DWORD *)v16;
            if (!*(_DWORD *)v16)
            {
              uint64_t v21 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)int buf = 136447490;
                uint64_t v44 = "dnssd_query_cancel";
                __int16 v45 = 1024;
                *(_DWORD *)int v46 = 0;
                *(_WORD *)&v46[4] = 2048;
                *(void *)&unsigned char v46[6] = v16;
                *(_WORD *)&v46[14] = 2080;
                *(void *)&v46[16] = "tracker";
                *(_WORD *)&v46[24] = 2080;
                *(void *)&v46[26] = "dnssd-proxy.c";
                *(_WORD *)&unsigned char v46[34] = 1024;
                *(_DWORD *)&v46[36] = 955;
                uint64_t v15 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
                goto LABEL_113;
              }
LABEL_118:
              abort();
            }
            int v33 = global_os_log;
            if (v32 >= 10001)
            {
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                goto LABEL_118;
              }
              *(_DWORD *)int buf = 136447490;
              uint64_t v44 = "dnssd_query_cancel";
              __int16 v45 = 1024;
              *(_DWORD *)int v46 = v32;
              *(_WORD *)&v46[4] = 2048;
              *(void *)&unsigned char v46[6] = v16;
              *(_WORD *)&v46[14] = 2080;
              *(void *)&v46[16] = "tracker";
              *(_WORD *)&v46[24] = 2080;
              *(void *)&v46[26] = "dnssd-proxy.c";
              *(_WORD *)&unsigned char v46[34] = 1024;
              *(_DWORD *)&v46[36] = 955;
              uint64_t v15 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
              goto LABEL_106;
            }
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)int buf = 136447490;
              uint64_t v44 = "dnssd_query_cancel";
              __int16 v45 = 1024;
              *(_DWORD *)int v46 = v32;
              *(_WORD *)&v46[4] = 2048;
              *(void *)&unsigned char v46[6] = v16;
              *(_WORD *)&v46[14] = 2080;
              *(void *)&v46[16] = "tracker";
              *(_WORD *)&v46[24] = 2080;
              *(void *)&v46[26] = "dnssd-proxy.c";
              *(_WORD *)&unsigned char v46[34] = 1024;
              *(_DWORD *)&v46[36] = 955;
              _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
              int v32 = *(_DWORD *)v16;
            }
            *(_DWORD *)int v16 = v32 - 1;
            if (v32 == 1)
            {
              int v34 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)int buf = 136447234;
                uint64_t v44 = "dnssd_query_cancel";
                __int16 v45 = 2048;
                *(void *)int v46 = v16;
                *(_WORD *)&v46[8] = 2080;
                *(void *)&v46[10] = "tracker";
                *(_WORD *)&v46[18] = 2080;
                *(void *)&v46[20] = "dnssd-proxy.c";
                *(_WORD *)&v46[28] = 1024;
                *(_DWORD *)&v46[30] = 955;
                _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
              }
              ++dp_tracker_finalized;
              dp_tracker_finalize(v16);
            }
            v28[1] = 0;
            int v35 = *(_DWORD *)v28;
            if (!*(_DWORD *)v28)
            {
              uint64_t v21 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                goto LABEL_118;
              }
              *(_DWORD *)int buf = 136447490;
              uint64_t v44 = "dnssd_query_cancel";
              __int16 v45 = 1024;
              *(_DWORD *)int v46 = 0;
              *(_WORD *)&v46[4] = 2048;
              *(void *)&unsigned char v46[6] = v28;
              *(_WORD *)&v46[14] = 2080;
              *(void *)&v46[16] = "list_query";
              *(_WORD *)&v46[24] = 2080;
              *(void *)&v46[26] = "dnssd-proxy.c";
              *(_WORD *)&unsigned char v46[34] = 1024;
              *(_DWORD *)&v46[36] = 959;
              uint64_t v15 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
              goto LABEL_113;
            }
            int v33 = global_os_log;
            if (v35 >= 10001)
            {
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                goto LABEL_118;
              }
              *(_DWORD *)int buf = 136447490;
              uint64_t v44 = "dnssd_query_cancel";
              __int16 v45 = 1024;
              *(_DWORD *)int v46 = v35;
              *(_WORD *)&v46[4] = 2048;
              *(void *)&unsigned char v46[6] = v28;
              *(_WORD *)&v46[14] = 2080;
              *(void *)&v46[16] = "list_query";
              *(_WORD *)&v46[24] = 2080;
              *(void *)&v46[26] = "dnssd-proxy.c";
              *(_WORD *)&unsigned char v46[34] = 1024;
              *(_DWORD *)&v46[36] = 959;
              uint64_t v15 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_106:
              int v42 = v33;
LABEL_117:
              _os_log_impl((void *)&_mh_execute_header, v42, OS_LOG_TYPE_FAULT, v15, buf, 0x36u);
              goto LABEL_118;
            }
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)int buf = 136447490;
              uint64_t v44 = "dnssd_query_cancel";
              __int16 v45 = 1024;
              *(_DWORD *)int v46 = v35;
              *(_WORD *)&v46[4] = 2048;
              *(void *)&unsigned char v46[6] = v28;
              *(_WORD *)&v46[14] = 2080;
              *(void *)&v46[16] = "list_query";
              *(_WORD *)&v46[24] = 2080;
              *(void *)&v46[26] = "dnssd-proxy.c";
              *(_WORD *)&unsigned char v46[34] = 1024;
              *(_DWORD *)&v46[36] = 959;
              _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
              int v35 = *(_DWORD *)v28;
            }
            *(_DWORD *)__int16 v28 = v35 - 1;
            if (v35 == 1)
            {
              BOOL v36 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)int buf = 136447234;
                uint64_t v44 = "dnssd_query_cancel";
                __int16 v45 = 2048;
                *(void *)int v46 = v28;
                *(_WORD *)&v46[8] = 2080;
                *(void *)&v46[10] = "list_query";
                *(_WORD *)&v46[18] = 2080;
                *(void *)&v46[20] = "dnssd-proxy.c";
                *(_WORD *)&v46[28] = 1024;
                *(_DWORD *)&v46[30] = 959;
                _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
              }
              ++dnssd_query_finalized;
              dnssd_query_finalize(v28);
            }
          }
          else
          {
            uint64_t v27 = v28 + 2;
          }
          __int16 v28 = (void *)*v27;
        }
        while (*v27);
      }
    }
  }
  uint64_t v37 = v16[1];
  if (v37 && !v16[2])
  {
    if ((*(_WORD *)(v37 + 416) & 0x20) != 0)
    {
      dp_tracker_idle_after((uint64_t)v16, 15, a1);
    }
    else
    {
      ioloop_comm_release_(v37, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 986);
      v16[1] = 0;
    }
  }
  int v38 = *(_DWORD *)v16;
  if (!*(_DWORD *)v16)
  {
    uint64_t v21 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_118;
    }
    *(_DWORD *)int buf = 136447490;
    uint64_t v44 = "dnssd_query_cancel";
    __int16 v45 = 1024;
    *(_DWORD *)int v46 = 0;
    *(_WORD *)&v46[4] = 2048;
    *(void *)&unsigned char v46[6] = v16;
    *(_WORD *)&v46[14] = 2080;
    *(void *)&v46[16] = "tracker";
    *(_WORD *)&v46[24] = 2080;
    *(void *)&v46[26] = "dnssd-proxy.c";
    *(_WORD *)&unsigned char v46[34] = 1024;
    *(_DWORD *)&v46[36] = 993;
    uint64_t v15 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_113:
    int v42 = v21;
    goto LABEL_117;
  }
  size_t v25 = global_os_log;
  if (v38 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_118;
    }
    *(_DWORD *)int buf = 136447490;
    uint64_t v44 = "dnssd_query_cancel";
    __int16 v45 = 1024;
    *(_DWORD *)int v46 = v38;
    *(_WORD *)&v46[4] = 2048;
    *(void *)&unsigned char v46[6] = v16;
    *(_WORD *)&v46[14] = 2080;
    *(void *)&v46[16] = "tracker";
    *(_WORD *)&v46[24] = 2080;
    *(void *)&v46[26] = "dnssd-proxy.c";
    *(_WORD *)&unsigned char v46[34] = 1024;
    *(_DWORD *)&v46[36] = 993;
    uint64_t v15 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_116:
    int v42 = v25;
    goto LABEL_117;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136447490;
    uint64_t v44 = "dnssd_query_cancel";
    __int16 v45 = 1024;
    *(_DWORD *)int v46 = v38;
    *(_WORD *)&v46[4] = 2048;
    *(void *)&unsigned char v46[6] = v16;
    *(_WORD *)&v46[14] = 2080;
    *(void *)&v46[16] = "tracker";
    *(_WORD *)&v46[24] = 2080;
    *(void *)&v46[26] = "dnssd-proxy.c";
    *(_WORD *)&unsigned char v46[34] = 1024;
    *(_DWORD *)&v46[36] = 993;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    int v38 = *(_DWORD *)v16;
  }
  *(_DWORD *)int v16 = v38 - 1;
  if (v38 == 1)
  {
    int v39 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136447234;
      uint64_t v44 = "dnssd_query_cancel";
      __int16 v45 = 2048;
      *(void *)int v46 = v16;
      *(_WORD *)&v46[8] = 2080;
      *(void *)&v46[10] = "tracker";
      *(_WORD *)&v46[18] = 2080;
      *(void *)&v46[20] = "dnssd-proxy.c";
      *(_WORD *)&v46[28] = 1024;
      *(_DWORD *)&v46[30] = 993;
      _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
    }
    ++dp_tracker_finalized;
    dp_tracker_finalize(v16);
  }
LABEL_84:
  *(unsigned char *)(a1 + 200) = 1;
  int v40 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    unsigned int v14 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_118;
    }
    *(_DWORD *)int buf = 136447490;
    uint64_t v44 = "dnssd_query_cancel";
    __int16 v45 = 1024;
    *(_DWORD *)int v46 = 0;
    *(_WORD *)&v46[4] = 2048;
    *(void *)&unsigned char v46[6] = a1;
    *(_WORD *)&v46[14] = 2080;
    *(void *)&v46[16] = "query";
    *(_WORD *)&v46[24] = 2080;
    *(void *)&v46[26] = "dnssd-proxy.c";
    *(_WORD *)&unsigned char v46[34] = 1024;
    *(_DWORD *)&v46[36] = 1001;
    uint64_t v15 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_97;
  }
  unsigned int v14 = global_os_log;
  if (v40 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_118;
    }
    *(_DWORD *)int buf = 136447490;
    uint64_t v44 = "dnssd_query_cancel";
    __int16 v45 = 1024;
    *(_DWORD *)int v46 = v40;
    *(_WORD *)&v46[4] = 2048;
    *(void *)&unsigned char v46[6] = a1;
    *(_WORD *)&v46[14] = 2080;
    *(void *)&v46[16] = "query";
    *(_WORD *)&v46[24] = 2080;
    *(void *)&v46[26] = "dnssd-proxy.c";
    *(_WORD *)&unsigned char v46[34] = 1024;
    *(_DWORD *)&v46[36] = 1001;
    uint64_t v15 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_97;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136447490;
    uint64_t v44 = "dnssd_query_cancel";
    __int16 v45 = 1024;
    *(_DWORD *)int v46 = v40;
    *(_WORD *)&v46[4] = 2048;
    *(void *)&unsigned char v46[6] = a1;
    *(_WORD *)&v46[14] = 2080;
    *(void *)&v46[16] = "query";
    *(_WORD *)&v46[24] = 2080;
    *(void *)&v46[26] = "dnssd-proxy.c";
    *(_WORD *)&unsigned char v46[34] = 1024;
    *(_DWORD *)&v46[36] = 1001;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    int v40 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v40 - 1;
  if (v40 == 1)
  {
    int v41 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136447234;
      uint64_t v44 = "dnssd_query_cancel";
      __int16 v45 = 2048;
      *(void *)int v46 = a1;
      *(_WORD *)&v46[8] = 2080;
      *(void *)&v46[10] = "query";
      *(_WORD *)&v46[18] = 2080;
      *(void *)&v46[20] = "dnssd-proxy.c";
      *(_WORD *)&v46[28] = 1024;
      *(_DWORD *)&v46[30] = 1001;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
    }
    ++dnssd_query_finalized;
    dnssd_query_finalize((void *)a1);
  }
}

void dp_push_response(uint64_t a1, uint64_t **a2)
{
  uint64_t v3 = *(void *)(a1 + 192);
  if (v3)
  {
    uint64_t v4 = *(const char **)(v3 + 32);
  }
  else if (a2)
  {
    uint64_t v4 = v38;
    dns_name_print_to_limit(*a2, 0, (uint64_t)v38, 0x3F2uLL);
  }
  else
  {
    uint64_t v4 = "<null question name>";
  }
  uint64_t v5 = *(void *)(a1 + 8);
  if (!v5)
  {
    uint64_t v14 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v15 = *(_DWORD *)(a1 + 4);
    *(_DWORD *)int buf = 136446466;
    uint64_t v27 = "dp_push_response";
    __int16 v28 = 1024;
    int v29 = v15;
    int v16 = "%{public}s: [Q%d] query->tracker NULL for query!";
    int v17 = v14;
    uint32_t v18 = 18;
LABEL_16:
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_ERROR, v16, buf, v18);
    return;
  }
  if (!*(void *)(v5 + 8))
  {
    uint64_t v19 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v20 = *(_DWORD *)(a1 + 4);
    int v21 = *(_DWORD *)(v5 + 4);
    *(_DWORD *)int buf = 136446722;
    uint64_t v27 = "dp_push_response";
    __int16 v28 = 1024;
    int v29 = v20;
    __int16 v30 = 1024;
    int v31 = v21;
    int v16 = "%{public}s: [Q%d][TRK%d] query->tracker->connection NULL";
    int v17 = v19;
    uint32_t v18 = 24;
    goto LABEL_16;
  }
  int v6 = *(unsigned char **)(a1 + 152);
  if (v6)
  {
    uint64_t v7 = *(void *)(a1 + 104);
    size_t v8 = v7 - *(void *)(a1 + 160);
    v25.iov_base = *(void **)(a1 + 160);
    v25.size_t iov_len = v8;
    uint64_t v9 = global_os_log;
    BOOL v10 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
    int v11 = v6;
    if (v10)
    {
      int v12 = *(_DWORD *)(a1 + 4);
      if (v3) {
        int v13 = *(_DWORD *)(v3 + 64);
      }
      else {
        int v13 = 0;
      }
      *(_DWORD *)int buf = 136447491;
      uint64_t v27 = "dp_push_response";
      __int16 v28 = 1024;
      int v29 = v12;
      __int16 v30 = 1024;
      int v31 = v13;
      __int16 v32 = 2160;
      uint64_t v33 = 1752392040;
      __int16 v34 = 2081;
      int v35 = v4;
      __int16 v36 = 2048;
      size_t v37 = v8;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][QU%d] %{private, mask.hash}s (len %zd)", buf, 0x36u);
      int v11 = *(unsigned char **)(a1 + 152);
    }
    *(void *)(a1 + 104) = v11;
    if (*(_DWORD *)(a1 + 144) <= 1u)
    {
      if ((unint64_t)(v11 + 2) >= *(void *)(a1 + 112))
      {
        *(_DWORD *)(a1 + 144) = 111;
        *(_DWORD *)(a1 + 136) = 2669;
      }
      else
      {
        *(void *)(a1 + 104) = v11 + 1;
        *int v11 = (unsigned __int16)(v7 - (_WORD)v6 - 2) >> 8;
        uint64_t v22 = *(unsigned char **)(a1 + 104);
        *(void *)(a1 + 104) = v22 + 1;
        *uint64_t v22 = v7 - (_BYTE)v6 - 2;
      }
    }
    ioloop_send_message(*(void *)(*(void *)(a1 + 8) + 8), *(void *)(a1 + 64), &v25);
    uint64_t v23 = *(void *)(a1 + 160);
    uint64_t v24 = v23 + 12 + *(void *)(a1 + 176);
    *(void *)(a1 + 96) = v23;
    *(void *)(a1 + 104) = v23 + 12;
    *(void *)(a1 + 152) = 0;
    *(void *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
    *(void *)(a1 + 112) = v24;
  }
}

void dp_query_reply_from_cache(uint64_t a1, uint64_t a2, int a3)
{
  if (*(void *)(a2 + 72)
    || !*(unsigned char *)(a1 + 76)
    && (*(void *)(a1 + 40)
     || (*(void *)int buf = 0,
         *(void *)&buf[8] = 0,
         clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)buf),
         *(void *)&buf[8] / 1000 + 1000000 * *(void *)buf - *(void *)(a1 + 48) < 800001)))
  {
    int v6 = *(uint64_t **)(a1 + 40);
    if (!v6) {
      return;
    }
    uint64_t v7 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_5;
    }
    int v8 = *(_DWORD *)(a2 + 4);
    int v9 = *(_DWORD *)(a1 + 64);
    int v10 = *(unsigned __int16 *)(a1 + 72);
    int v11 = *(unsigned __int16 *)(a1 + 74);
    uint64_t v12 = *(void *)(a1 + 32);
    *(_DWORD *)int buf = 136447747;
    *(void *)&uint8_t buf[4] = "dp_query_reply_from_cache";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v8;
    __int16 v23 = 1024;
    int v24 = v9;
    __int16 v25 = 1024;
    int v26 = v10;
    __int16 v27 = 1024;
    int v28 = v11;
    __int16 v29 = 2160;
    uint64_t v30 = 1752392040;
    __int16 v31 = 2081;
    uint64_t v32 = v12;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][QU%d] reply from cache for question - type %d class %d %{private, mask.hash}s", buf, 0x38u);
    int v6 = *(uint64_t **)(a1 + 40);
    if (v6)
    {
LABEL_5:
      if (a3) {
        char v13 = 0;
      }
      else {
        char v13 = 2;
      }
      do
      {
        uint64_t v14 = (uint64_t *)*v6;
        char v15 = v13 | (*v6 != 0);
        if (*(void *)(a2 + 72))
        {
          dns_push_query_answer_process(v15, 0, (uint8_t *)v6[1], *((unsigned __int16 *)v6 + 16), *((unsigned __int16 *)v6 + 17), *((unsigned __int16 *)v6 + 18), (int32x4_t *)v6[2], *((_DWORD *)v6 + 7), a2, 1);
        }
        else if ((a3 & 1) == 0)
        {
          dns_query_answer_process(v15, 0, (uint8_t *)v6[1], *((unsigned __int16 *)v6 + 16), *((unsigned __int16 *)v6 + 17), *((unsigned __int16 *)v6 + 18), (int32x4_t *)v6[2], *((_DWORD *)v6 + 7), a2, 1);
        }
        int v6 = v14;
      }
      while (v14);
    }
  }
  else
  {
    int v16 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v17 = *(_DWORD *)(a2 + 4);
      int v18 = *(_DWORD *)(a1 + 64);
      int v19 = *(unsigned __int16 *)(a1 + 72);
      int v20 = *(unsigned __int16 *)(a1 + 74);
      uint64_t v21 = *(void *)(a1 + 32);
      *(_DWORD *)int buf = 136447747;
      *(void *)&uint8_t buf[4] = "dp_query_reply_from_cache";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v17;
      __int16 v23 = 1024;
      int v24 = v18;
      __int16 v25 = 1024;
      int v26 = v19;
      __int16 v27 = 1024;
      int v28 = v20;
      __int16 v29 = 2160;
      uint64_t v30 = 1752392040;
      __int16 v31 = 2081;
      uint64_t v32 = v21;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][QU%d] no data for question - type %d class %d %{private, mask.hash}s", buf, 0x38u);
    }
    dns_query_answer_process(0, -65554, *(uint8_t **)(a1 + 32), *(unsigned __int16 *)(a1 + 72), *(unsigned __int16 *)(a1 + 74), 0, 0, 0, a2, 1);
  }
  dp_question_cache_remove_queries(a1);
}

void dnssd_query_finalize(void *a1)
{
  int v2 = (void *)a1[1];
  if (v2)
  {
    int v3 = *(_DWORD *)v2;
    if (!*(_DWORD *)v2)
    {
      uint64_t v13 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_40;
      }
      int v16 = 136447490;
      int v17 = "dnssd_query_finalize";
      __int16 v18 = 1024;
      *(_DWORD *)int v19 = 0;
      *(_WORD *)&v19[4] = 2048;
      *(void *)&v19[6] = v2;
      *(_WORD *)&v19[14] = 2080;
      *(void *)&v19[16] = "query->tracker";
      *(_WORD *)&v19[24] = 2080;
      *(void *)&v19[26] = "dnssd-proxy.c";
      __int16 v20 = 1024;
      int v21 = 773;
      uint64_t v14 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_35;
    }
    uint64_t v4 = global_os_log;
    if (v3 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_40;
      }
      int v16 = 136447490;
      int v17 = "dnssd_query_finalize";
      __int16 v18 = 1024;
      *(_DWORD *)int v19 = v3;
      *(_WORD *)&v19[4] = 2048;
      *(void *)&v19[6] = v2;
      *(_WORD *)&v19[14] = 2080;
      *(void *)&v19[16] = "query->tracker";
      *(_WORD *)&v19[24] = 2080;
      *(void *)&v19[26] = "dnssd-proxy.c";
      __int16 v20 = 1024;
      int v21 = 773;
      uint64_t v14 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_38:
      char v15 = v4;
      goto LABEL_39;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = 136447490;
      int v17 = "dnssd_query_finalize";
      __int16 v18 = 1024;
      *(_DWORD *)int v19 = v3;
      *(_WORD *)&v19[4] = 2048;
      *(void *)&v19[6] = v2;
      *(_WORD *)&v19[14] = 2080;
      *(void *)&v19[16] = "query->tracker";
      *(_WORD *)&v19[24] = 2080;
      *(void *)&v19[26] = "dnssd-proxy.c";
      __int16 v20 = 1024;
      int v21 = 773;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v16, 0x36u);
      int v2 = (void *)a1[1];
      int v3 = *(_DWORD *)v2;
    }
    *(_DWORD *)int v2 = v3 - 1;
    if (v3 == 1)
    {
      uint64_t v5 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v16 = 136447234;
        int v17 = "dnssd_query_finalize";
        __int16 v18 = 2048;
        *(void *)int v19 = v2;
        *(_WORD *)&v19[8] = 2080;
        *(void *)&v19[10] = "query->tracker";
        *(_WORD *)&v19[18] = 2080;
        *(void *)&v19[20] = "dnssd-proxy.c";
        *(_WORD *)&v19[28] = 1024;
        *(_DWORD *)&v19[30] = 773;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v16, 0x30u);
        int v2 = (void *)a1[1];
      }
      ++dp_tracker_finalized;
      dp_tracker_finalize(v2);
    }
    a1[1] = 0;
  }
  int v6 = (int *)a1[8];
  if (v6)
  {
    ioloop_message_release_(v6, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 777);
    a1[8] = 0;
  }
  uint64_t v7 = (void *)a1[3];
  if (v7)
  {
    ioloop_wakeup_release_(v7, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 781);
    a1[3] = 0;
  }
  int v8 = (void *)a1[20];
  if (v8)
  {
    free(v8);
    a1[20] = 0;
  }
  int v9 = (void *)a1[21];
  if (v9)
  {
    dns_message_free(v9);
    a1[21] = 0;
  }
  uint64_t v10 = a1[24];
  if (v10)
  {
    int v11 = *(_DWORD *)(v10 + 60);
    if (v11)
    {
      uint64_t v4 = global_os_log;
      if (v11 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v16 = 136447490;
          int v17 = "dnssd_query_finalize";
          __int16 v18 = 1024;
          *(_DWORD *)int v19 = v11;
          *(_WORD *)&v19[4] = 2048;
          *(void *)&v19[6] = v10;
          *(_WORD *)&v19[14] = 2080;
          *(void *)&v19[16] = "query->question";
          *(_WORD *)&v19[24] = 2080;
          *(void *)&v19[26] = "dnssd-proxy.c";
          __int16 v20 = 1024;
          int v21 = 793;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v16, 0x36u);
          uint64_t v10 = a1[24];
          int v11 = *(_DWORD *)(v10 + 60);
        }
        *(_DWORD *)(v10 + 60) = v11 - 1;
        if (v11 == 1)
        {
          uint64_t v12 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v16 = 136447234;
            int v17 = "dnssd_query_finalize";
            __int16 v18 = 2048;
            *(void *)int v19 = v10;
            *(_WORD *)&v19[8] = 2080;
            *(void *)&v19[10] = "query->question";
            *(_WORD *)&v19[18] = 2080;
            *(void *)&v19[20] = "dnssd-proxy.c";
            *(_WORD *)&v19[28] = 1024;
            *(_DWORD *)&v19[30] = 793;
            _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v16, 0x30u);
            uint64_t v10 = a1[24];
          }
          ++question_finalized;
          question_finalize(v10);
        }
        goto LABEL_28;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_40:
      }
        abort();
      int v16 = 136447490;
      int v17 = "dnssd_query_finalize";
      __int16 v18 = 1024;
      *(_DWORD *)int v19 = v11;
      *(_WORD *)&v19[4] = 2048;
      *(void *)&v19[6] = v10;
      *(_WORD *)&v19[14] = 2080;
      *(void *)&v19[16] = "query->question";
      *(_WORD *)&v19[24] = 2080;
      *(void *)&v19[26] = "dnssd-proxy.c";
      __int16 v20 = 1024;
      int v21 = 793;
      uint64_t v14 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_38;
    }
    uint64_t v13 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_40;
    }
    int v16 = 136447490;
    int v17 = "dnssd_query_finalize";
    __int16 v18 = 1024;
    *(_DWORD *)int v19 = 0;
    *(_WORD *)&v19[4] = 2048;
    *(void *)&v19[6] = v10;
    *(_WORD *)&v19[14] = 2080;
    *(void *)&v19[16] = "query->question";
    *(_WORD *)&v19[24] = 2080;
    *(void *)&v19[26] = "dnssd-proxy.c";
    __int16 v20 = 1024;
    int v21 = 793;
    uint64_t v14 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_35:
    char v15 = v13;
LABEL_39:
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_FAULT, v14, (uint8_t *)&v16, 0x36u);
    goto LABEL_40;
  }
LABEL_28:
  free(a1);
  --dp_num_outstanding_queries;
}

void dp_tracker_finalize(void *a1)
{
  int v2 = (void *)a1[4];
  if (v2) {
    ioloop_wakeup_release_(v2, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 680);
  }
  uint64_t v3 = a1[1];
  if (v3) {
    ioloop_comm_release_(v3, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 685);
  }

  free(a1);
}

void question_finalize(uint64_t a1)
{
  int v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    if (a1) {
      int v3 = *(_DWORD *)(a1 + 64);
    }
    else {
      int v3 = 0;
    }
    int v4 = *(unsigned __int16 *)(a1 + 72);
    int v5 = *(unsigned __int16 *)(a1 + 74);
    uint64_t v6 = *(void *)(a1 + 32);
    int v7 = 136447491;
    int v8 = "question_finalize";
    __int16 v9 = 1024;
    int v10 = v3;
    __int16 v11 = 1024;
    int v12 = v4;
    __int16 v13 = 1024;
    int v14 = v5;
    __int16 v15 = 2160;
    uint64_t v16 = 1752392040;
    __int16 v17 = 2081;
    uint64_t v18 = v6;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: [QU%d] type %d class %d %{private, mask.hash}s", (uint8_t *)&v7, 0x32u);
  }
  dp_question_answers_free(a1);
  free(*(void **)(a1 + 32));
  free((void *)a1);
}

void dp_question_answers_free(uint64_t a1)
{
  int v2 = *(void ***)(a1 + 40);
  if (v2)
  {
    do
    {
      int v3 = (void **)*v2;
      free(v2[1]);
      free(v2);
      int v2 = v3;
    }
    while (v3);
  }
  *(void *)(a1 + 40) = 0;
}

void dns_query_answer_process(char a1, int a2, uint8_t *a3, unsigned int a4, int a5, size_t a6, int32x4_t *a7, unsigned int a8, uint64_t a9, char a10)
{
  uint64_t v15 = *(void *)(a9 + 192);
  uint64_t v16 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v17 = *(_DWORD *)(a9 + 4);
    uint64_t v36 = v15;
    if (v15) {
      int v18 = *(_DWORD *)(v15 + 64);
    }
    else {
      int v18 = 0;
    }
    if (a1) {
      int v19 = " m ";
    }
    else {
      int v19 = " ";
    }
    *(_DWORD *)int buf = 136448771;
    int v41 = "dns_query_answer_process";
    __int16 v42 = 1024;
    int v43 = v17;
    __int16 v44 = 1024;
    int v45 = v18;
    __int16 v46 = 2160;
    uint64_t v47 = 1752392040;
    __int16 v48 = 2081;
    uint64_t v49 = a3;
    __int16 v50 = 2082;
    size_t v51 = v19;
    __int16 v52 = 2082;
    uint64_t v53 = dns_rrtype_to_string(a4);
    __int16 v54 = 1024;
    int v55 = a5;
    __int16 v56 = 1024;
    int v57 = a6;
    __int16 v58 = 1024;
    int v59 = a2;
    __int16 v60 = 2048;
    uint64_t v61 = a9;
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][QU%d] %{private, mask.hash}s%{public}s%{public}s %d %x %d %p", buf, 0x5Cu);
    uint64_t v15 = v36;
  }
  uint64_t v20 = *(void *)(a9 + 8);
  if (!v20)
  {
    uint64_t v23 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v24 = *(_DWORD *)(a9 + 4);
    *(_DWORD *)int buf = 136446466;
    int v41 = "dns_query_answer_process";
    __int16 v42 = 1024;
    int v43 = v24;
    __int16 v25 = "%{public}s: [Q%d] query->tracker NULL for query!";
    int v26 = v23;
    os_log_type_t v27 = OS_LOG_TYPE_ERROR;
    uint32_t v28 = 18;
    goto LABEL_26;
  }
  if (!*(void *)(v20 + 8))
  {
    uint64_t v29 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v30 = *(_DWORD *)(a9 + 4);
    int v31 = *(_DWORD *)(v20 + 4);
    *(_DWORD *)int buf = 136446722;
    int v41 = "dns_query_answer_process";
    __int16 v42 = 1024;
    int v43 = v30;
    __int16 v44 = 1024;
    int v45 = v31;
    __int16 v25 = "%{public}s: [Q%d][TRK%d] query->tracker->connection NULL";
    int v26 = v29;
    os_log_type_t v27 = OS_LOG_TYPE_ERROR;
    goto LABEL_25;
  }
  if (a2 == -65554)
  {
    uint64_t v32 = "no such record";
LABEL_37:
    dp_query_send_dns_response(a9, (uint64_t)v32);
    return;
  }
  if (a2)
  {
    *(_WORD *)(*(void *)(a9 + 160) + 2) = *(_WORD *)(*(void *)(a9 + 160) + 2) & 0xF0FF | 0x200;
    uint64_t v32 = "unhandled error";
    goto LABEL_37;
  }
  if (a10)
  {
    if (a8 >= 0x12C) {
      int v21 = 300;
    }
    else {
      int v21 = a8;
    }
    while (1)
    {
      uint64_t v22 = *(void *)(a9 + 104);
      dp_query_add_data_to_response(a9, a3, a4, a5, a6, a7, v21, 0, 0, (_WORD *)(*(void *)(a9 + 160) + 6));
      if ((*(unsigned char *)(a9 + 144) & 1) == 0) {
        break;
      }
      *(void *)(a9 + 104) = v22;
      if ((*(_WORD *)(*(void *)(*(void *)(a9 + 8) + 8) + 416) & 0x20) == 0) {
        break;
      }
      if (!embiggen(a9))
      {
        *(_WORD *)(*(void *)(a9 + 160) + 2) = *(_WORD *)(*(void *)(a9 + 160) + 2) & 0xF0FF | 0x200;
        uint64_t v32 = "failed embiggen";
        goto LABEL_37;
      }
      *(_DWORD *)(a9 + 144) = 0;
    }
  }
  if ((a1 & 1) != 0 && (*(unsigned char *)(a9 + 144) & 1) == 0) {
    return;
  }
  if (a4 != 5 || *(_WORD *)(v15 + 72) == 5)
  {
    uint64_t v32 = "normal success";
    goto LABEL_37;
  }
  uint64_t v33 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v34 = *(_DWORD *)(a9 + 4);
    int v35 = *(_DWORD *)(v15 + 64);
    *(_DWORD *)int buf = 136446722;
    int v41 = "dns_query_answer_process";
    __int16 v42 = 1024;
    int v43 = v34;
    __int16 v44 = 1024;
    int v45 = v35;
    __int16 v25 = "%{public}s: [Q%d][QU%d] not responding yet because CNAME.";
    int v26 = v33;
    os_log_type_t v27 = OS_LOG_TYPE_DEFAULT;
LABEL_25:
    uint32_t v28 = 24;
LABEL_26:
    _os_log_impl((void *)&_mh_execute_header, v26, v27, v25, buf, v28);
  }
}

void dns_push_query_answer_process(char a1, int a2, uint8_t *a3, unsigned int a4, int a5, size_t a6, int32x4_t *a7, int a8, uint64_t a9, char a10)
{
  uint64_t v10 = *(void *)(a9 + 8);
  if (!v10)
  {
    uint64_t v32 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v33 = *(_DWORD *)(a9 + 4);
    *(_DWORD *)int buf = 136446466;
    __int16 v46 = "dns_push_query_answer_process";
    __int16 v47 = 1024;
    int v48 = v33;
    int v34 = "%{public}s: [Q%d] query->tracker NULL for query!";
    int v35 = v32;
    uint32_t v36 = 18;
LABEL_25:
    _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, v34, buf, v36);
    return;
  }
  __int16 v11 = global_os_log;
  if (!*(void *)(v10 + 8))
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v37 = *(_DWORD *)(a9 + 4);
    int v38 = *(_DWORD *)(v10 + 4);
    *(_DWORD *)int buf = 136446722;
    __int16 v46 = "dns_push_query_answer_process";
    __int16 v47 = 1024;
    int v48 = v37;
    __int16 v49 = 1024;
    LODWORD(v50) = v38;
    int v34 = "%{public}s: [Q%d][TRK%d] query->tracker->connection NULL";
    int v35 = v11;
    uint32_t v36 = 24;
    goto LABEL_25;
  }
  uint64_t v43 = *(void *)(a9 + 104);
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v19 = *(_DWORD *)(a9 + 4);
    *(_DWORD *)int buf = 136448259;
    __int16 v46 = "dns_push_query_answer_process";
    __int16 v47 = 1024;
    int v48 = v19;
    __int16 v49 = 2160;
    uint64_t v50 = 1752392040;
    __int16 v51 = 2081;
    __int16 v52 = a3;
    __int16 v53 = 1024;
    *(_DWORD *)__int16 v54 = a4;
    *(_WORD *)&v54[4] = 1024;
    *(_DWORD *)&v54[6] = a5;
    LOWORD(v55) = 1024;
    *(_DWORD *)((char *)&v55 + 2) = a6;
    HIWORD(v55) = 1024;
    *(_DWORD *)__int16 v56 = a2;
    *(_WORD *)&v56[4] = 2048;
    uint64_t v57 = a9;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d] PUSH %{private, mask.hash}s %d %d %x %d %p", buf, 0x48u);
  }
  if (a2 != -65554)
  {
    if (a2)
    {
      int v39 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        int v40 = *(_DWORD *)(a9 + 4);
        *(_DWORD *)int buf = 136446722;
        __int16 v46 = "dns_push_query_answer_process";
        __int16 v47 = 1024;
        int v48 = v40;
        __int16 v49 = 1024;
        LODWORD(v50) = a2;
        _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_ERROR, "%{public}s: [Q%d] unexpected error code %d", buf, 0x18u);
      }
      dnssd_query_cancel(a9);
    }
    else
    {
      if (a10)
      {
        uint64_t v20 = a7;
        if (!a6) {
          uint64_t v20 = 0;
        }
        __int16 v42 = v20;
        if (a6) {
          int v21 = -1;
        }
        else {
          int v21 = -2;
        }
        int v41 = a8;
        while (1)
        {
          uint64_t v22 = global_os_log;
          BOOL v23 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
          if ((a1 & 2) != 0)
          {
            int v24 = a7;
            int v25 = a8;
            if (v23)
            {
              int v29 = *(_DWORD *)(a9 + 4);
              int v30 = dns_rrtype_to_string(a4);
              int v31 = dns_qclass_to_string(a5);
              *(_DWORD *)int buf = 136448003;
              __int16 v46 = "dns_push_query_answer_process";
              __int16 v47 = 1024;
              int v48 = v29;
              a8 = v41;
              __int16 v49 = 2160;
              uint64_t v50 = 1752392040;
              __int16 v51 = 2081;
              __int16 v52 = a3;
              __int16 v53 = 2082;
              *(void *)__int16 v54 = v30;
              *(_WORD *)&v54[8] = 2082;
              int v55 = v31;
              *(_WORD *)__int16 v56 = 1024;
              *(_DWORD *)&v56[2] = a6;
              LOWORD(v57) = 1024;
              *(_DWORD *)((char *)&v57 + 2) = v41;
              _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d] DNS Push adding record - name: %{private, mask.hash}s, rrtype: %{public}s, rrclass: %{public}s, rdlen: %u, ttl: %u.", buf, 0x46u);
              int v24 = a7;
              int v25 = v41;
            }
          }
          else
          {
            int v24 = v42;
            int v25 = v21;
            if (v23)
            {
              int v26 = *(_DWORD *)(a9 + 4);
              os_log_type_t v27 = dns_rrtype_to_string(a4);
              uint32_t v28 = dns_qclass_to_string(a5);
              *(_DWORD *)int buf = 136448003;
              __int16 v46 = "dns_push_query_answer_process";
              __int16 v47 = 1024;
              int v48 = v26;
              a8 = v41;
              __int16 v49 = 2160;
              uint64_t v50 = 1752392040;
              __int16 v51 = 2081;
              __int16 v52 = a3;
              __int16 v53 = 2082;
              *(void *)__int16 v54 = v27;
              *(_WORD *)&v54[8] = 2082;
              int v55 = v28;
              *(_WORD *)__int16 v56 = 1024;
              *(_DWORD *)&v56[2] = a6;
              LOWORD(v57) = 1024;
              *(_DWORD *)((char *)&v57 + 2) = v21;
              _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d] DNS Push removing record - name: %{private, mask.hash}s, rrtype: %{public}s, rrclass: %{public}s, rdlen: %u, ttl: 0x%X.", buf, 0x46u);
              int v24 = v42;
              int v25 = v21;
            }
          }
          dp_query_add_data_to_response(a9, a3, a4, a5, a6, v24, v25, 0, 0, 0);
          if ((*(unsigned char *)(a9 + 144) & 1) == 0) {
            break;
          }
          *(void *)(a9 + 104) = v43;
          *(_DWORD *)(a9 + 144) = 0;
          dp_push_response(a9, 0);
          dns_push_start(a9);
        }
      }
      if ((a1 & 1) == 0) {
        dp_push_response(a9, 0);
      }
    }
  }
}

void dp_query_add_data_to_response(uint64_t a1, uint8_t *a2, unsigned int a3, int a4, size_t a5, int32x4_t *a6, int a7, char a8, char a9, _WORD *a10)
{
  uint64_t v14 = *(void *)(a1 + 192);
  if (!*(void *)(v14 + 8)) {
    a8 = 1;
  }
  if (!a5)
  {
    uint64_t v32 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v33 = *(_DWORD *)(a1 + 4);
    int v34 = *(_DWORD *)(v14 + 64);
    *(_DWORD *)int buf = 136447747;
    v179 = "dp_query_add_data_to_response";
    __int16 v180 = 1024;
    *(_DWORD *)v181 = v33;
    *(_WORD *)&v181[4] = 1024;
    *(_DWORD *)&v181[6] = v34;
    strcpy(v182, "p\bhash");
    v182[7] = 0;
    *(_WORD *)&v182[8] = 0;
    __int16 v183 = 2081;
    v184 = a2;
    __int16 v185 = 2082;
    *(void *)v186 = dns_rrtype_to_string(a3);
    *(_WORD *)&v186[8] = 1024;
    *(_DWORD *)&v186[10] = a4;
    int v35 = "%{public}s: [Q%d][QU%d] eliding zero-length response for %{private, mask.hash}s %{public}s %d";
    uint32_t v36 = v32;
    uint32_t v37 = 60;
LABEL_21:
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, v35, buf, v37);
    return;
  }
  size_t v16 = a5;
  uint64_t v151 = *(void *)(a1 + 104);
  if (a9) {
    goto LABEL_6;
  }
  if (a3 == 1 && a5 == 4)
  {
    int v38 = a6->u8[0];
    if (v38 == 169)
    {
      if (a6->u8[1] == 254)
      {
        uint64_t v39 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
          return;
        }
        int v88 = *(_DWORD *)(a1 + 4);
        int v89 = *(_DWORD *)(v14 + 64);
        *(_DWORD *)int buf = 136448003;
        v179 = "dp_query_add_data_to_response";
        __int16 v180 = 1024;
        *(_DWORD *)v181 = v88;
        *(_WORD *)&v181[4] = 1024;
        *(_DWORD *)&v181[6] = v89;
        strcpy(v182, "p\bhash");
        v182[7] = 0;
        *(_WORD *)&v182[8] = 0;
        __int16 v183 = 2081;
        v184 = a2;
        __int16 v185 = 2160;
        *(void *)v186 = 1752392040;
        *(_WORD *)&v186[8] = 1041;
        *(_DWORD *)&v186[10] = 4;
        *(_WORD *)&v186[14] = 2097;
        *(void *)&v186[16] = a6;
        int v35 = "%{public}s: [Q%d][QU%d] eliding link-local response for %{private, mask.hash}s: %{private, mask.hash, network:in_addr}.4P";
        goto LABEL_118;
      }
    }
    else if (v38 == 127)
    {
      uint64_t v39 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      int v40 = *(_DWORD *)(a1 + 4);
      int v41 = *(_DWORD *)(v14 + 64);
      *(_DWORD *)int buf = 136448003;
      v179 = "dp_query_add_data_to_response";
      __int16 v180 = 1024;
      *(_DWORD *)v181 = v40;
      *(_WORD *)&v181[4] = 1024;
      *(_DWORD *)&v181[6] = v41;
      strcpy(v182, "p\bhash");
      v182[7] = 0;
      *(_WORD *)&v182[8] = 0;
      __int16 v183 = 2081;
      v184 = a2;
      __int16 v185 = 2160;
      *(void *)v186 = 1752392040;
      *(_WORD *)&v186[8] = 1041;
      *(_DWORD *)&v186[10] = 4;
      *(_WORD *)&v186[14] = 2097;
      *(void *)&v186[16] = a6;
      int v35 = "%{public}s: [Q%d][QU%d] eliding localhost response for %{private, mask.hash}s: %{private, mask.hash, network:in_addr}.4P";
LABEL_118:
      uint32_t v36 = v39;
      uint32_t v37 = 70;
      goto LABEL_21;
    }
  }
  else if (a3 == 28 && a5 == 16)
  {
    uint64_t v61 = &a6->i64[1];
    if (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32(*a6, (int32x4_t)xmmword_10007C610)))))
    {
      char v62 = (char)*a6;
      if ((*(_OWORD *)a6 & 0xC0FF) != 0x80FE) {
        goto LABEL_6;
      }
      uint64_t v63 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      int v64 = *(_DWORD *)(a1 + 4);
      int v65 = *(_DWORD *)(v14 + 64);
      uint64_t v66 = "LUA: ";
      *(_DWORD *)int buf = 136449795;
      v179 = "dp_query_add_data_to_response";
      if ((v62 & 0xFE) == 0xFC) {
        uint64_t v66 = "ULA: ";
      }
      __int16 v180 = 1024;
      *(_DWORD *)v181 = v64;
      *(_WORD *)&v181[4] = 1024;
      *(_DWORD *)&v181[6] = v65;
      strcpy(v182, "p\bhash");
      v182[7] = 0;
      *(_WORD *)&v182[8] = 0;
      __int16 v183 = 2081;
      v184 = a2;
      __int16 v185 = 2082;
      *(void *)v186 = v66;
      *(_WORD *)&v186[8] = 2160;
      *(void *)&v186[10] = 1752392040;
      *(_WORD *)&v186[18] = 1041;
      *(_DWORD *)&v186[20] = 6;
      __int16 v187 = 2097;
      uint64_t v188 = (uint64_t)a6;
      __int16 v189 = 2160;
      uint64_t v190 = 1752392040;
      __int16 v191 = 1042;
      int v192 = 2;
      __int16 v193 = 2098;
      v194 = &a6->i8[6];
      __int16 v195 = 2160;
      uint64_t v196 = 1752392040;
      __int16 v197 = 1041;
      int v198 = 8;
      __int16 v199 = 2097;
      v200 = v61;
      int v35 = "%{public}s: [Q%d][QU%d] eliding link-local response for %{private, mask.hash}s: {%{public}s%{private, mask.h"
            "ash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}";
    }
    else
    {
      uint64_t v63 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        return;
      }
      int v123 = *(_DWORD *)(a1 + 4);
      int v124 = *(_DWORD *)(v14 + 64);
      *(_DWORD *)int buf = 136449795;
      v179 = "dp_query_add_data_to_response";
      __int16 v180 = 1024;
      *(_DWORD *)v181 = v123;
      *(_WORD *)&v181[4] = 1024;
      *(_DWORD *)&v181[6] = v124;
      strcpy(v182, "p\bhash");
      v182[7] = 0;
      *(_WORD *)&v182[8] = 0;
      __int16 v183 = 2081;
      v184 = a2;
      __int16 v185 = 2082;
      *(void *)v186 = "";
      *(_WORD *)&v186[8] = 2160;
      *(void *)&v186[10] = 1752392040;
      *(_WORD *)&v186[18] = 1041;
      *(_DWORD *)&v186[20] = 6;
      __int16 v187 = 2097;
      uint64_t v188 = (uint64_t)a6;
      __int16 v189 = 2160;
      uint64_t v190 = 1752392040;
      __int16 v191 = 1042;
      int v192 = 2;
      __int16 v193 = 2098;
      v194 = &a6->i8[6];
      __int16 v195 = 2160;
      uint64_t v196 = 1752392040;
      __int16 v197 = 1041;
      int v198 = 8;
      __int16 v199 = 2097;
      v200 = v61;
      int v35 = "%{public}s: [Q%d][QU%d] eliding localhost response for %{private, mask.hash}s: {%{public}s%{private, mask.ha"
            "sh, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}";
    }
    uint32_t v36 = v63;
    uint32_t v37 = 132;
    goto LABEL_21;
  }
LABEL_6:
  int v18 = &dnssd_client_states;
  int v19 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136446722;
    v179 = "dp_query_add_data_to_response";
    __int16 v180 = 2082;
    *(void *)v181 = dns_rrtype_to_string(a3);
    *(_WORD *)&v181[8] = 1024;
    *(_DWORD *)v182 = v16;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%{public}s: survived for rrtype %{public}s rdlen %d", buf, 0x1Cu);
  }
  uint64_t v20 = a1 + 96;
  if (*(void *)(a1 + 72)) {
    dns_push_start(a1);
  }
  uint64_t v21 = *(void *)(v14 + 8);
  if (v21)
  {
    dns_concatenate_name_to_wire_(a1 + 96, 0, *(char **)(v14 + 32), *(char **)(v21 + 8), 1226);
    if (*(_DWORD *)(a1 + 144) >= 2u) {
      uint64_t v22 = "concatenate_name_to_wire";
    }
    else {
      uint64_t v22 = 0;
    }
    uint64_t v23 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v24 = *(_DWORD *)(a1 + 4);
      int v149 = *(_DWORD *)(v14 + 64);
      if (*(void *)(a1 + 72)) {
        int v25 = "PUSH";
      }
      else {
        int v25 = "DNS ";
      }
      int v26 = dns_rrtype_to_string(a3);
      uint64_t v27 = *(void *)(v14 + 32);
      uint64_t v28 = *(void *)(*(void *)(v14 + 8) + 8);
      *(_DWORD *)int buf = 136448515;
      v179 = "dp_query_add_data_to_response";
      __int16 v180 = 1024;
      *(_DWORD *)v181 = v24;
      *(_WORD *)&v181[4] = 1024;
      *(_DWORD *)&v181[6] = v149;
      int v18 = &dnssd_client_states;
      *(_WORD *)v182 = 2082;
      *(void *)&v182[2] = v25;
      uint64_t v20 = a1 + 96;
      size_t v16 = v16;
      __int16 v183 = 2082;
      v184 = (uint8_t *)v26;
      __int16 v185 = 1024;
      *(_DWORD *)v186 = a4;
      *(_WORD *)&v186[4] = 2160;
      *(void *)&v186[6] = 1752392040;
      *(_WORD *)&v186[14] = 2081;
      *(void *)&v186[16] = v27;
      __int16 v187 = 2160;
      uint64_t v188 = 1752392040;
      __int16 v189 = 2081;
      uint64_t v190 = v28;
      int v29 = "%{public}s: [Q%d][QU%d] %{public}s answer:  type %{public}s class %02d %{private, mask.hash}s.%{private, mask.hash}s";
      int v30 = v23;
      uint32_t v31 = 90;
LABEL_36:
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, v29, buf, v31);
    }
  }
  else
  {
    dns_concatenate_name_to_wire_(a1 + 96, 0, 0, *(char **)(v14 + 32), 1230);
    if (*(_DWORD *)(a1 + 144) >= 2u) {
      uint64_t v22 = "compress_name_to_wire";
    }
    else {
      uint64_t v22 = 0;
    }
    uint64_t v42 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v43 = *(_DWORD *)(a1 + 4);
      int v44 = *(_DWORD *)(v14 + 64);
      uint64_t v45 = v14;
      size_t v46 = v16;
      char v47 = a8;
      if (*(void *)(a1 + 72)) {
        int v48 = "push";
      }
      else {
        int v48 = " dns";
      }
      __int16 v49 = dns_rrtype_to_string(a3);
      uint64_t v50 = *(void *)(v45 + 32);
      *(_DWORD *)int buf = 136448003;
      v179 = "dp_query_add_data_to_response";
      __int16 v180 = 1024;
      *(_DWORD *)v181 = v43;
      uint64_t v20 = a1 + 96;
      *(_WORD *)&v181[4] = 1024;
      *(_DWORD *)&v181[6] = v44;
      *(_WORD *)v182 = 2082;
      *(void *)&v182[2] = v48;
      a8 = v47;
      size_t v16 = v46;
      uint64_t v14 = v45;
      int v18 = &dnssd_client_states;
      __int16 v183 = 2082;
      v184 = (uint8_t *)v49;
      __int16 v185 = 1024;
      *(_DWORD *)v186 = a4;
      *(_WORD *)&v186[4] = 2160;
      *(void *)&v186[6] = 1752392040;
      *(_WORD *)&v186[14] = 2081;
      *(void *)&v186[16] = v50;
      int v29 = "%{public}s: [Q%d][QU%d] %{public}s answer:  type %{public}s class %02d %{private, mask.hash}s (p)";
      int v30 = v42;
      uint32_t v31 = 70;
      goto LABEL_36;
    }
  }
  unsigned int v51 = *(_DWORD *)(a1 + 144);
  unsigned int v52 = a3;
  if (v51 > 1) {
    goto LABEL_63;
  }
  __int16 v53 = *(unsigned char **)(a1 + 104);
  if ((unint64_t)(v53 + 2) >= *(void *)(a1 + 112))
  {
    unsigned int v51 = 111;
    *(_DWORD *)(a1 + 144) = 111;
    *(_DWORD *)(a1 + 136) = 1234;
LABEL_63:
    if (v22) {
      BOOL v67 = 0;
    }
    else {
      BOOL v67 = v51 > 1;
    }
    __int16 v56 = "rrtype";
    if (!v67) {
      __int16 v56 = v22;
    }
    goto LABEL_68;
  }
  *(void *)(a1 + 104) = v53 + 1;
  unsigned char *v53 = BYTE1(a3);
  __int16 v54 = *(unsigned char **)(a1 + 104);
  *(void *)(a1 + 104) = v54 + 1;
  unsigned char *v54 = a3;
  unsigned int v51 = *(_DWORD *)(a1 + 144);
  if (v22) {
    BOOL v55 = 0;
  }
  else {
    BOOL v55 = v51 > 1;
  }
  __int16 v56 = "rrtype";
  if (!v55) {
    __int16 v56 = v22;
  }
  if (v51 > 1)
  {
LABEL_68:
    if (v56) {
      BOOL v68 = 0;
    }
    else {
      BOOL v68 = v51 > 1;
    }
    if (v68) {
      __int16 v60 = "rrclass";
    }
    else {
      __int16 v60 = v56;
    }
    goto LABEL_74;
  }
  uint64_t v57 = *(unsigned char **)(a1 + 104);
  if ((unint64_t)(v57 + 2) >= *(void *)(a1 + 112))
  {
    unsigned int v51 = 111;
    *(_DWORD *)(a1 + 144) = 111;
    *(_DWORD *)(a1 + 136) = 1235;
    if (v56) {
      __int16 v60 = v56;
    }
    else {
      __int16 v60 = "rrclass";
    }
  }
  else
  {
    *(void *)(a1 + 104) = v57 + 1;
    unsigned char *v57 = BYTE1(a4);
    __int16 v58 = *(unsigned char **)(a1 + 104);
    *(void *)(a1 + 104) = v58 + 1;
    *__int16 v58 = a4;
    unsigned int v51 = *(_DWORD *)(a1 + 144);
    if (v56) {
      BOOL v59 = 0;
    }
    else {
      BOOL v59 = v51 > 1;
    }
    if (v59) {
      __int16 v60 = "rrclass";
    }
    else {
      __int16 v60 = v56;
    }
    if (v51 <= 1)
    {
      dns_u32_to_wire_(v20, a7, 1236);
      unsigned int v51 = *(_DWORD *)(a1 + 144);
    }
  }
LABEL_74:
  if (v60) {
    BOOL v69 = 0;
  }
  else {
    BOOL v69 = v51 > 1;
  }
  long long v157 = 0u;
  long long v158 = 0u;
  if (v69) {
    int v70 = "ttl";
  }
  else {
    int v70 = v60;
  }
  long long v155 = 0uLL;
  long long v156 = 0uLL;
  unsigned int v154 = 0;
  WORD4(v155) = a3;
  WORD5(v155) = a4;
  if (!dns_rdata_parse_data_((uint64_t)&v155, (uint64_t)a6, &v154, v16, v16, 0))
  {
    uint64_t v74 = *((void *)v18 + 306);
    if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
    {
      int v75 = *(_DWORD *)(a1 + 4);
      int v76 = *(_DWORD *)(v14 + 64);
      *(_DWORD *)int buf = 136446722;
      v179 = "dp_query_add_data_to_response";
      __int16 v180 = 1024;
      *(_DWORD *)v181 = v75;
      *(_WORD *)&v181[4] = 1024;
      *(_DWORD *)&v181[6] = v76;
      _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_ERROR, "%{public}s: [Q%d][QU%d] rdata from mDNSResponder didn't parse!!", buf, 0x18u);
    }
LABEL_89:
    unsigned int v77 = *(_DWORD *)(a1 + 144);
    if (v77 <= 1)
    {
      char v78 = *(unsigned char **)(a1 + 104);
      if ((unint64_t)(v78 + 2) < *(void *)(a1 + 112))
      {
        *(void *)(a1 + 104) = v78 + 1;
        *char v78 = BYTE1(v16);
        int v79 = *(unsigned char **)(a1 + 104);
        *(void *)(a1 + 104) = v79 + 1;
        *int v79 = v16;
        unsigned int v77 = *(_DWORD *)(a1 + 144);
        if (v70) {
          BOOL v80 = 0;
        }
        else {
          BOOL v80 = v77 > 1;
        }
        unsigned int v81 = v16;
        if (v80) {
          int v82 = "rdlen";
        }
        else {
          int v82 = v70;
        }
        if (v77 <= 1)
        {
          uint64_t v83 = v81;
          int v84 = *(void **)(a1 + 104);
          if ((unint64_t)v84 + v81 <= *(void *)(a1 + 112))
          {
            memcpy(v84, a6, v81);
            *(void *)(a1 + 104) += v83;
            unsigned int v77 = *(_DWORD *)(a1 + 144);
          }
          else
          {
            unsigned int v77 = 111;
            *(_DWORD *)(a1 + 144) = 111;
            *(_DWORD *)(a1 + 136) = 1296;
          }
        }
LABEL_107:
        if (v82) {
          BOOL v86 = 0;
        }
        else {
          BOOL v86 = v77 > 1;
        }
        if (v86) {
          __int16 v87 = "rdata";
        }
        else {
          __int16 v87 = v82;
        }
        if (v77) {
          goto LABEL_174;
        }
        goto LABEL_169;
      }
      unsigned int v77 = 111;
      *(_DWORD *)(a1 + 144) = 111;
      *(_DWORD *)(a1 + 136) = 1295;
    }
    if (v70) {
      BOOL v85 = 0;
    }
    else {
      BOOL v85 = v77 > 1;
    }
    if (v85) {
      int v82 = "rdlen";
    }
    else {
      int v82 = v70;
    }
    goto LABEL_107;
  }
  if (a3 > 0x27)
  {
LABEL_192:
    v125 = *((void *)v18 + 306);
    if (os_log_type_enabled(v125, OS_LOG_TYPE_DEFAULT))
    {
      int v126 = *(_DWORD *)(a1 + 4);
      int v127 = v52;
      int v128 = v18;
      int v129 = *(_DWORD *)(v14 + 64);
      int v130 = dns_rrtype_to_string(v127);
      *(_DWORD *)int buf = 136446978;
      v179 = "dp_query_add_data_to_response";
      __int16 v180 = 1024;
      *(_DWORD *)v181 = v126;
      *(_WORD *)&v181[4] = 1024;
      *(_DWORD *)&v181[6] = v129;
      int v18 = v128;
      *(_WORD *)v182 = 2082;
      *(void *)&v182[2] = v130;
      _os_log_impl((void *)&_mh_execute_header, v125, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][QU%d] record type %{public}s not translated", buf, 0x22u);
    }
    dns_rrdata_free((uint64_t)&v155);
    goto LABEL_89;
  }
  if (((1 << a3) & 0x80008013BCLL) == 0)
  {
    if (a3 == 33)
    {
      uint64_t v71 = v156;
      int v117 = "rdlength begin";
      unsigned int v118 = *(_DWORD *)(a1 + 144);
      __int16 v119 = "answer.data.srv.priority";
      uint32_t v120 = "answer.data.srv.weight";
      if (v118 <= 1)
      {
        uint64_t v121 = *(void *)(a1 + 104);
        uint64_t v122 = (unsigned char *)(v121 + 2);
        if ((unint64_t)(v121 + 2) >= *(void *)(a1 + 112))
        {
          unsigned int v118 = 111;
        }
        else
        {
          if (!*(void *)(a1 + 120))
          {
            *(void *)(a1 + 120) = v121;
            *(void *)(a1 + 104) = v122;
            if (v70) {
              BOOL v135 = 0;
            }
            else {
              BOOL v135 = v118 > 1;
            }
            if (!v135) {
              int v117 = v70;
            }
            if ((unint64_t)(v121 + 4) < *(void *)(a1 + 112))
            {
              char v136 = BYTE8(v156);
              int v137 = HIBYTE(WORD4(v156));
              *(void *)(a1 + 104) = v122 + 1;
              unsigned char *v122 = v137;
              uint64_t v138 = *(unsigned char **)(a1 + 104);
              *(void *)(a1 + 104) = v138 + 1;
              *uint64_t v138 = v136;
              unsigned int v118 = *(_DWORD *)(a1 + 144);
              if (v117) {
                BOOL v139 = 0;
              }
              else {
                BOOL v139 = v118 > 1;
              }
              if (!v139) {
                __int16 v119 = v117;
              }
              if (v118 <= 1)
              {
                int v140 = *(unsigned char **)(a1 + 104);
                if ((unint64_t)(v140 + 2) < *(void *)(a1 + 112))
                {
                  char v141 = BYTE10(v156);
                  int v142 = HIBYTE(WORD5(v156));
                  *(void *)(a1 + 104) = v140 + 1;
                  *int v140 = v142;
                  socklen_t v143 = *(unsigned char **)(a1 + 104);
                  *(void *)(a1 + 104) = v143 + 1;
                  unsigned char *v143 = v141;
                  unsigned int v118 = *(_DWORD *)(a1 + 144);
                  if (v119) {
                    BOOL v144 = 0;
                  }
                  else {
                    BOOL v144 = v118 > 1;
                  }
                  if (!v144) {
                    uint32_t v120 = v119;
                  }
                  if (v118 <= 1)
                  {
                    uint64_t v145 = *(unsigned char **)(a1 + 104);
                    if ((unint64_t)(v145 + 2) >= *(void *)(a1 + 112))
                    {
                      unsigned int v118 = 111;
                      *(_DWORD *)(a1 + 144) = 111;
                      *(_DWORD *)(a1 + 136) = 1265;
                    }
                    else
                    {
                      char v146 = BYTE12(v156);
                      int v147 = HIBYTE(WORD6(v156));
                      *(void *)(a1 + 104) = v145 + 1;
                      *uint64_t v145 = v147;
                      int v148 = *(unsigned char **)(a1 + 104);
                      *(void *)(a1 + 104) = v148 + 1;
                      unsigned char *v148 = v146;
                      unsigned int v118 = *(_DWORD *)(a1 + 144);
                    }
                  }
                  goto LABEL_214;
                }
                unsigned int v118 = 111;
                *(_DWORD *)(a1 + 144) = 111;
                *(_DWORD *)(a1 + 136) = 1264;
              }
LABEL_209:
              if (v119) {
                BOOL v133 = 0;
              }
              else {
                BOOL v133 = v118 > 1;
              }
              if (!v133) {
                uint32_t v120 = v119;
              }
LABEL_214:
              if (v120) {
                BOOL v134 = 0;
              }
              else {
                BOOL v134 = v118 > 1;
              }
              if (v134) {
                __int16 v91 = "answer.data.srv.port";
              }
              else {
                __int16 v91 = v120;
              }
              goto LABEL_127;
            }
            unsigned int v118 = 111;
            *(_DWORD *)(a1 + 144) = 111;
            *(_DWORD *)(a1 + 136) = 1263;
LABEL_204:
            if (v117) {
              BOOL v132 = 0;
            }
            else {
              BOOL v132 = v118 > 1;
            }
            if (!v132) {
              __int16 v119 = v117;
            }
            goto LABEL_209;
          }
          v118 |= 0x2Cu;
        }
        *(_DWORD *)(a1 + 144) = v118;
        *(_DWORD *)(a1 + 136) = 1262;
      }
      if (v70) {
        BOOL v131 = 0;
      }
      else {
        BOOL v131 = v118 > 1;
      }
      if (!v131) {
        int v117 = v70;
      }
      goto LABEL_204;
    }
    goto LABEL_192;
  }
  uint64_t v71 = v156;
  unsigned int v72 = *(_DWORD *)(a1 + 144);
  if (v72 <= 1)
  {
    uint64_t v73 = *(void *)(a1 + 104);
    if ((unint64_t)(v73 + 2) >= *(void *)(a1 + 112))
    {
      unsigned int v72 = 111;
    }
    else
    {
      if (!*(void *)(a1 + 120))
      {
        *(void *)(a1 + 120) = v73;
        *(void *)(a1 + 104) = v73 + 2;
        goto LABEL_121;
      }
      v72 |= 0x2Cu;
    }
    *(_DWORD *)(a1 + 144) = v72;
    *(_DWORD *)(a1 + 136) = 1258;
  }
LABEL_121:
  if (v70) {
    BOOL v90 = 0;
  }
  else {
    BOOL v90 = v72 > 1;
  }
  if (v90) {
    __int16 v91 = "rdlength begin";
  }
  else {
    __int16 v91 = v70;
  }
LABEL_127:
  dns_name_print_to_limit((uint64_t *)v71, 0, (uint64_t)v177, 0x100uLL);
  if (a8) {
    goto LABEL_152;
  }
  int v92 = 0;
  int v93 = (void *)v71;
  do
  {
    int v94 = v92;
    int v92 = v93;
    int v93 = (void *)*v93;
  }
  while (v93);
  if (v94 && *((unsigned char *)v94 + 8) == 5 && dns_labels_equal((uint64_t)v94 + 9, (uint64_t)"local", 5uLL))
  {
    uint64_t v95 = v20;
    if (v71 && *(unsigned char *)(v71 + 8))
    {
      int v96 = 0;
      __int16 v97 = (unsigned char *)v71;
      while (1)
      {
        __int16 v98 = v96;
        int v96 = v97;
        __int16 v97 = *(unsigned char **)v97;
        if (!v97) {
          break;
        }
        if (!v97[8])
        {
          if (v98 && v96[8] == 5 && dns_labels_equal((uint64_t)(v96 + 9), (uint64_t)"local", 5uLL))
          {
            do
            {
              uint64_t v99 = *(unsigned char **)v96;
              free(v96);
              int v96 = v99;
            }
            while (v99);
            *__int16 v98 = 0;
          }
          break;
        }
      }
    }
    dns_name_print_to_limit((uint64_t *)v71, 0, (uint64_t)buf, 0x100uLL);
    dns_concatenate_name_to_wire_(v95, (uint64_t **)v71, 0, *(char **)(*(void *)(v14 + 8) + 8), 1281);
    if (v91) {
      BOOL v100 = 0;
    }
    else {
      BOOL v100 = *(_DWORD *)(a1 + 144) > 1u;
    }
    if (v100) {
      __int16 v87 = "concatenate_name_to_wire 2";
    }
    else {
      __int16 v87 = v91;
    }
    int v101 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v102 = *(_DWORD *)(a1 + 4);
      int v103 = *(_DWORD *)(v14 + 64);
      uint64_t v104 = *(void *)(*(void *)(v14 + 8) + 8);
      *(_DWORD *)__int16 v159 = 136448259;
      int v160 = "dp_query_add_data_to_response";
      __int16 v161 = 1024;
      int v162 = v102;
      __int16 v163 = 1024;
      int v164 = v103;
      __int16 v165 = 2160;
      uint64_t v166 = 1752392040;
      __int16 v167 = 2081;
      v168 = v177;
      __int16 v169 = 2160;
      uint64_t v170 = 1752392040;
      __int16 v171 = 2081;
      v172 = buf;
      __int16 v173 = 2160;
      uint64_t v174 = 1752392040;
      __int16 v175 = 2081;
      uint64_t v176 = v104;
      _os_log_impl((void *)&_mh_execute_header, v101, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][QU%d] translating %{private, mask.hash}s to %{private, mask.hash}s . %{private, mask.hash}s", v159, 0x54u);
    }
    int v18 = &dnssd_client_states;
  }
  else
  {
LABEL_152:
    dns_concatenate_name_to_wire_(v20, (uint64_t **)v71, 0, 0, 1286);
    if (v91) {
      BOOL v105 = 0;
    }
    else {
      BOOL v105 = *(_DWORD *)(a1 + 144) > 1u;
    }
    if (v105) {
      __int16 v87 = "concatenate_name_to_wire 2";
    }
    else {
      __int16 v87 = v91;
    }
    __int16 v106 = *((void *)v18 + 306);
    if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
    {
      int v107 = *(_DWORD *)(a1 + 4);
      if (v14) {
        int v108 = *(_DWORD *)(v14 + 64);
      }
      else {
        int v108 = 0;
      }
      *(_DWORD *)int buf = 136447235;
      v179 = "dp_query_add_data_to_response";
      __int16 v180 = 1024;
      *(_DWORD *)v181 = v107;
      *(_WORD *)&v181[4] = 1024;
      *(_DWORD *)&v181[6] = v108;
      strcpy(v182, "p\bhash");
      v182[7] = 0;
      *(_WORD *)&v182[8] = 0;
      __int16 v183 = 2081;
      v184 = v177;
      _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][QU%d] compressing %{private, mask.hash}s", buf, 0x2Cu);
    }
  }
  do
  {
    if (!v71) {
      break;
    }
    uint64_t v109 = *(void *)v71;
    free((void *)v71);
    uint64_t v71 = v109;
  }
  while (v109);
  unsigned int v110 = *(_DWORD *)(a1 + 144);
  if (v110 > 1)
  {
LABEL_168:
    if (v110) {
      goto LABEL_174;
    }
    goto LABEL_169;
  }
  unsigned int v111 = *(unsigned char **)(a1 + 120);
  if (v111)
  {
    uint64_t v112 = *(void *)(a1 + 104) - (void)v111 - 2;
    *unsigned int v111 = BYTE1(v112);
    *(unsigned char *)(*(void *)(a1 + 120) + 1) = v112;
    *(void *)(a1 + 120) = 0;
    unsigned int v110 = *(_DWORD *)(a1 + 144);
    goto LABEL_168;
  }
  int v113 = v110 | 0x2C;
  *(_DWORD *)(a1 + 144) = v113;
  *(_DWORD *)(a1 + 136) = 1291;
  if (v113) {
    goto LABEL_174;
  }
LABEL_169:
  if (!v87)
  {
    if (a10)
    {
      if (!*(void *)(a1 + 72)) {
        *a10 = bswap32((bswap32((unsigned __int16)*a10) >> 16) + 1) >> 16;
      }
    }
    return;
  }
LABEL_174:
  uint64_t v114 = *((void *)v18 + 306);
  if (os_log_type_enabled(v114, OS_LOG_TYPE_ERROR))
  {
    int v115 = *(_DWORD *)(a1 + 4);
    if (v14) {
      int v116 = *(_DWORD *)(v14 + 64);
    }
    else {
      int v116 = 0;
    }
    *(_DWORD *)__int16 v159 = 136446978;
    int v160 = "dp_query_add_data_to_response";
    __int16 v161 = 1024;
    int v162 = v115;
    __int16 v163 = 1024;
    int v164 = v116;
    __int16 v165 = 2082;
    uint64_t v166 = (uint64_t)v87;
    _os_log_impl((void *)&_mh_execute_header, v114, OS_LOG_TYPE_ERROR, "%{public}s: [Q%d][QU%d] RR ADD FAIL: %{public}s", v159, 0x22u);
  }
  *(void *)(a1 + 104) = v151;
}

void dns_push_start(uint64_t a1)
{
  if (!*(void *)(a1 + 152))
  {
    uint64_t v2 = *(void *)(a1 + 160);
    *(_DWORD *)(v2 + 8) = 0;
    *(void *)uint64_t v2 = 0;
    *(_WORD *)(*(void *)(a1 + 160) + 2) = *(_WORD *)(*(void *)(a1 + 160) + 2) & 0xF007 | 0x30;
    if (*(_DWORD *)(a1 + 144) <= 1u)
    {
      int v3 = *(unsigned char **)(a1 + 104);
      if ((unint64_t)(v3 + 2) >= *(void *)(a1 + 112))
      {
        *(_DWORD *)(a1 + 144) = 111;
        *(_DWORD *)(a1 + 136) = 2633;
      }
      else
      {
        *(void *)(a1 + 104) = v3 + 1;
        *int v3 = 0;
        int v4 = *(unsigned char **)(a1 + 104);
        *(void *)(a1 + 104) = v4 + 1;
        unsigned char *v4 = 65;
      }
    }
    uint64_t v5 = *(void *)(a1 + 104);
    if ((unint64_t)(v5 + 2) <= *(void *)(a1 + 112))
    {
      unsigned int v10 = *(_DWORD *)(a1 + 144);
      *(void *)(a1 + 152) = v5;
      *(void *)(a1 + 104) = v5 + 2;
      if (v10 >= 2)
      {
        __int16 v11 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          int v12 = *(_DWORD *)(a1 + 4);
          int v13 = 136446722;
          uint64_t v14 = "dns_push_start";
          __int16 v15 = 1024;
          int v16 = v12;
          __int16 v17 = 2080;
          int v18 = "kDSOType_DNSPushUpdate";
          _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%{public}s: [Q%d] couldn't start update: %s", (uint8_t *)&v13, 0x1Cu);
        }
      }
    }
    else
    {
      uint64_t v6 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        int v7 = *(_DWORD *)(a1 + 4);
        int v13 = 136446466;
        uint64_t v14 = "dns_push_start";
        __int16 v15 = 1024;
        int v16 = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, "%{public}s: [Q%d] No room for dso length in DNS Push notification message.", (uint8_t *)&v13, 0x12u);
      }
      uint64_t v8 = *(void *)(a1 + 160);
      uint64_t v9 = v8 + 12 + *(void *)(a1 + 176);
      *(void *)(a1 + 96) = v8;
      *(void *)(a1 + 104) = v8 + 12;
      *(void *)(a1 + 152) = 0;
      *(void *)(a1 + 120) = 0;
      *(void *)(a1 + 128) = 0;
      *(void *)(a1 + 112) = v9;
    }
  }
}

BOOL embiggen(uint64_t a1)
{
  uint64_t v2 = (char *)malloc_type_malloc(*(void *)(a1 + 176) + 1410, 0x4261C869uLL);
  int v3 = v2;
  if (v2)
  {
    memcpy(v2, *(const void **)(a1 + 160), *(void *)(a1 + 176) + 12);
    uint64_t v4 = *(void *)(a1 + 176) + 1398;
    *(void *)(a1 + 176) = v4;
    uint64_t v5 = *(void **)(a1 + 160);
    uint64_t v6 = &v3[*(void *)(a1 + 104) - (void)v5];
    *(void *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = 0;
    *(void *)(a1 + 104) = v6;
    *(void *)(a1 + 112) = &v3[v4 + 12];
    *(void *)(a1 + 96) = v3;
    free(v5);
    *(void *)(a1 + 160) = v3;
  }
  return v3 != 0;
}

void dp_query_send_dns_response(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  v260.iov_base = 0;
  v260.size_t iov_len = 0;
  uint64_t v3 = *(void *)(a1 + 104);
  int v4 = *(_DWORD *)(a1 + 144);
  unsigned int v5 = *(unsigned __int16 *)(*(void *)(a1 + 160) + 2);
  uint64_t v6 = *(void *)(a1 + 192);
  *(unsigned char *)(a1 + 200) = 1;
  uint64_t v7 = *(void *)(a1 + 8);
  if (!v7)
  {
    uint64_t v16 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v17 = *(_DWORD *)(v2 + 4);
    *(_DWORD *)int buf = 136446466;
    v262 = "dp_query_send_dns_response";
    __int16 v263 = 1024;
    *(_DWORD *)v264 = v17;
    int v18 = "%{public}s: [Q%d] query->tracker NULL for query!";
    int v19 = v16;
    uint32_t v20 = 18;
    goto LABEL_14;
  }
  if (!*(void *)(v7 + 8))
  {
    uint64_t v21 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v22 = *(_DWORD *)(v2 + 4);
    int v23 = *(_DWORD *)(v7 + 4);
    *(_DWORD *)int buf = 136446722;
    v262 = "dp_query_send_dns_response";
    __int16 v263 = 1024;
    *(_DWORD *)v264 = v22;
    *(_WORD *)&v264[4] = 1024;
    *(_DWORD *)&v264[6] = v23;
    int v18 = "%{public}s: [Q%d][TRK%d] query->tracker->connection NULL";
    int v19 = v21;
    uint32_t v20 = 24;
LABEL_14:
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, v18, buf, v20);
    return;
  }
  uint64_t v9 = a1 + 96;
  int v10 = (v4 & 1) << 9;
  unsigned int v11 = bswap32(v5) >> 16;
  uint64_t v12 = *(void *)(v6 + 8);
  if (v12)
  {
    int v13 = v4 & 1;
    BOOL v14 = *(void *)(v12 + 40) && v13 == 0;
    if (v14 && (*(_WORD *)(v6 + 72) != 6 || **(unsigned char **)(v6 + 32)))
    {
      __int16 v15 = 0;
      uint64_t v26 = a1 + 32;
      while (1)
      {
        dns_pointer_to_wire_(v9, v26, 2413);
        unsigned int v27 = *(_DWORD *)(v2 + 144);
        if (v15) {
          BOOL v28 = 0;
        }
        else {
          BOOL v28 = v27 > 1;
        }
        int v29 = "&query->enclosing_domain_pointer 1";
        if (!v28) {
          int v29 = v15;
        }
        if (v27 >= 2)
        {
          if (!v29) {
            int v29 = "dns_rrtype_soa";
          }
LABEL_51:
          if (v29) {
            BOOL v39 = 0;
          }
          else {
            BOOL v39 = v27 > 1;
          }
          if (v39) {
            uint32_t v36 = "dns_qclass_in";
          }
          else {
            uint32_t v36 = v29;
          }
LABEL_57:
          if (v36) {
            BOOL v40 = 0;
          }
          else {
            BOOL v40 = v27 > 1;
          }
          int v29 = "ttl";
          if (!v40) {
            int v29 = v36;
          }
          goto LABEL_66;
        }
        int v30 = *(unsigned char **)(v2 + 104);
        if ((unint64_t)(v30 + 2) >= *(void *)(v2 + 112)) {
          break;
        }
        *(void *)(v2 + 104) = v30 + 1;
        unsigned char *v30 = 0;
        uint32_t v31 = *(unsigned char **)(v2 + 104);
        *(void *)(v2 + 104) = v31 + 1;
        *uint32_t v31 = 6;
        unsigned int v27 = *(_DWORD *)(v2 + 144);
        if (v29) {
          BOOL v32 = 0;
        }
        else {
          BOOL v32 = v27 > 1;
        }
        if (v32) {
          int v29 = "dns_rrtype_soa";
        }
        if (v27 > 1) {
          goto LABEL_51;
        }
        int v33 = *(unsigned char **)(v2 + 104);
        if ((unint64_t)(v33 + 2) >= *(void *)(v2 + 112))
        {
          unsigned int v27 = 111;
          *(_DWORD *)(v2 + 144) = 111;
          *(_DWORD *)(v2 + 136) = 2417;
          BOOL v41 = v29 == 0;
          uint64_t v42 = "dns_qclass_in";
LABEL_64:
          if (v41) {
            int v29 = v42;
          }
          goto LABEL_66;
        }
        *(void *)(v2 + 104) = v33 + 1;
        *int v33 = 0;
        int v34 = *(unsigned char **)(v2 + 104);
        *(void *)(v2 + 104) = v34 + 1;
        *int v34 = 1;
        unsigned int v27 = *(_DWORD *)(v2 + 144);
        if (v29) {
          BOOL v35 = 0;
        }
        else {
          BOOL v35 = v27 > 1;
        }
        if (v35) {
          uint32_t v36 = "dns_qclass_in";
        }
        else {
          uint32_t v36 = v29;
        }
        if (v27 >= 2) {
          goto LABEL_57;
        }
        dns_u32_to_wire_(v9, 3600, 2418);
        unsigned int v27 = *(_DWORD *)(v2 + 144);
        if (v36) {
          BOOL v37 = 0;
        }
        else {
          BOOL v37 = v27 > 1;
        }
        int v29 = "ttl";
        if (!v37) {
          int v29 = v36;
        }
        if (v27 <= 1)
        {
          uint64_t v38 = *(void *)(v2 + 104);
          if ((unint64_t)(v38 + 2) >= *(void *)(v2 + 112))
          {
            unsigned int v27 = 111;
            goto LABEL_153;
          }
          if (*(void *)(v2 + 120))
          {
            v27 |= 0x2Cu;
LABEL_153:
            *(_DWORD *)(v2 + 144) = v27;
            *(_DWORD *)(v2 + 136) = 2419;
            goto LABEL_66;
          }
          *(void *)(v2 + 120) = v38;
          *(void *)(v2 + 104) = v38 + 2;
        }
LABEL_66:
        if (v29) {
          BOOL v43 = 0;
        }
        else {
          BOOL v43 = v27 > 1;
        }
        if (v43) {
          __int16 v15 = "rdlength_begin ";
        }
        else {
          __int16 v15 = v29;
        }
        if (uuid_name)
        {
          dns_name_to_wire_(0, (uint64_t *)v9, &uuid_name, 2426);
          int v44 = 2428;
          uint64_t v45 = "uuid_name";
        }
        else
        {
          dns_name_to_wire_(0, (uint64_t *)v9, "ns", 2430);
          int v44 = 2432;
          uint64_t v45 = "\"ns\"";
        }
        if (v15) {
          BOOL v46 = 0;
        }
        else {
          BOOL v46 = *(_DWORD *)(a1 + 144) > 1u;
        }
        if (v46) {
          __int16 v15 = v45;
        }
        dns_pointer_to_wire_(v9, v26, v44);
        if (v15) {
          BOOL v47 = 0;
        }
        else {
          BOOL v47 = *(_DWORD *)(a1 + 144) > 1u;
        }
        if (v47) {
          __int16 v15 = "&query->enclosing_domain_pointer 2";
        }
        dns_name_to_wire_(0, (uint64_t *)v9, "postmaster", 2435);
        if (v15) {
          BOOL v48 = 0;
        }
        else {
          BOOL v48 = *(_DWORD *)(a1 + 144) > 1u;
        }
        if (v48) {
          __int16 v15 = "\"postmaster\"";
        }
        dns_pointer_to_wire_(v9, v26, 2437);
        if (v15) {
          BOOL v49 = 0;
        }
        else {
          BOOL v49 = *(_DWORD *)(a1 + 144) > 1u;
        }
        if (v49) {
          __int16 v15 = "&query->enclosing_domain_pointer 3";
        }
        dns_u32_to_wire_(v9, 0, 2438);
        unsigned int v50 = *(_DWORD *)(a1 + 144);
        if (v15) {
          BOOL v51 = 0;
        }
        else {
          BOOL v51 = v50 > 1;
        }
        if (v51) {
          __int16 v15 = "serial";
        }
        if (v50 >= 2)
        {
          if (!v15) {
            __int16 v15 = "refresh";
          }
LABEL_130:
          if (v15) {
            BOOL v58 = 0;
          }
          else {
            BOOL v58 = v50 > 1;
          }
          if (v58) {
            __int16 v15 = "retry";
          }
LABEL_135:
          if (v15) {
            BOOL v59 = 0;
          }
          else {
            BOOL v59 = v50 > 1;
          }
          if (v59) {
            __int16 v15 = "expire";
          }
LABEL_140:
          if (v15) {
            BOOL v60 = 0;
          }
          else {
            BOOL v60 = v50 > 1;
          }
          if (v60) {
            __int16 v15 = "minimum";
          }
LABEL_145:
          if ((v50 & 1) == 0) {
            goto LABEL_155;
          }
          goto LABEL_146;
        }
        dns_u32_to_wire_(v9, 7200, 2439);
        unsigned int v50 = *(_DWORD *)(a1 + 144);
        if (v15) {
          BOOL v52 = 0;
        }
        else {
          BOOL v52 = v50 > 1;
        }
        if (v52) {
          __int16 v15 = "refresh";
        }
        if (v50 >= 2) {
          goto LABEL_130;
        }
        dns_u32_to_wire_(v9, 3600, 2440);
        unsigned int v50 = *(_DWORD *)(a1 + 144);
        if (v15) {
          BOOL v53 = 0;
        }
        else {
          BOOL v53 = v50 > 1;
        }
        if (v53) {
          __int16 v15 = "retry";
        }
        if (v50 >= 2) {
          goto LABEL_135;
        }
        dns_u32_to_wire_(v9, 86400, 2441);
        unsigned int v50 = *(_DWORD *)(a1 + 144);
        if (v15) {
          BOOL v54 = 0;
        }
        else {
          BOOL v54 = v50 > 1;
        }
        if (v54) {
          __int16 v15 = "expire";
        }
        if (v50 >= 2) {
          goto LABEL_140;
        }
        dns_u32_to_wire_(v9, 120, 2442);
        unsigned int v50 = *(_DWORD *)(a1 + 144);
        if (v15) {
          BOOL v55 = 0;
        }
        else {
          BOOL v55 = v50 > 1;
        }
        if (v55) {
          __int16 v15 = "minimum";
        }
        if (v50 > 1) {
          goto LABEL_145;
        }
        __int16 v56 = *(unsigned char **)(a1 + 120);
        if (v56)
        {
          uint64_t v57 = *(void *)(a1 + 104) - (void)v56 - 2;
          *__int16 v56 = BYTE1(v57);
          *(unsigned char *)(*(void *)(a1 + 120) + 1) = v57;
          *(void *)(a1 + 120) = 0;
          if ((*(_DWORD *)(a1 + 144) & 1) == 0) {
            goto LABEL_155;
          }
        }
        else
        {
          int v61 = v50 | 0x2C;
          *(_DWORD *)(a1 + 144) = v61;
          *(_DWORD *)(a1 + 136) = 2443;
          if ((v61 & 1) == 0)
          {
LABEL_155:
            uint64_t v2 = a1;
            *(_WORD *)(*(void *)(a1 + 160) + 8) = 256;
            goto LABEL_157;
          }
        }
LABEL_146:
        uint64_t v2 = a1;
        *(void *)(a1 + 104) = v3;
        if ((*(_WORD *)(*(void *)(*(void *)(a1 + 8) + 8) + 416) & 0x20) == 0)
        {
          int v10 = 512;
LABEL_157:
          v238 = v15;
          int v24 = v10;
          LOWORD(v10) = v11 & 0xFB7F;
          __int16 v25 = 1024;
          int v226 = v24;
          goto LABEL_158;
        }
        if (!embiggen(a1)) {
          goto LABEL_157;
        }
        *(_DWORD *)(a1 + 144) = 0;
      }
      unsigned int v27 = 111;
      *(_DWORD *)(v2 + 144) = 111;
      *(_DWORD *)(v2 + 136) = 2415;
      BOOL v41 = v29 == 0;
      uint64_t v42 = "dns_rrtype_soa";
      goto LABEL_64;
    }
  }
  if (*(_WORD *)(v6 + 72) == 6)
  {
    __int16 v15 = 0;
    goto LABEL_157;
  }
  v238 = 0;
  LOWORD(v24) = v11 & 0xFB7F;
  __int16 v25 = 128;
  int v226 = v10;
LABEL_158:
  __int16 v62 = v24 | v25;
  uint64_t v63 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v64 = *(_DWORD *)(v2 + 4);
    if (v6) {
      int v65 = *(_DWORD *)(v6 + 64);
    }
    else {
      int v65 = 0;
    }
    unsigned int v66 = bswap32(*(unsigned __int16 *)(*(void *)(v2 + 64) + 88));
    uint64_t v67 = *(void *)(v2 + 104);
    uint64_t v68 = *(void *)(v2 + 96) + 12;
    int v69 = *(unsigned char *)(*(void *)(v2 + 160) + 3) & 0xF;
    *(_DWORD *)int buf = 136448258;
    v262 = "dp_query_send_dns_response";
    __int16 v263 = 1024;
    *(_DWORD *)v264 = v64;
    *(_WORD *)&v264[4] = 1024;
    *(_DWORD *)&v264[6] = v65;
    LOWORD(v265) = 1024;
    *(_DWORD *)((char *)&v265 + 2) = HIWORD(v66);
    WORD3(v265) = 2048;
    *((void *)&v265 + 1) = v67;
    __int16 v266 = 2048;
    uint64_t v267 = v68;
    __int16 v268 = 2048;
    uint64_t v269 = v67 - v68;
    __int16 v270 = 1024;
    int v271 = v69;
    __int16 v272 = 2082;
    uint64_t v273 = a2;
    _os_log_impl((void *)&_mh_execute_header, v63, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][QU%d][QID %x] ->p %p ->lim %p len %zd rcode %d %{public}s", buf, 0x4Cu);
  }
  int v70 = (v5 >> 8) & 0xF;
  __int16 v71 = v10 | v62;
  if (*(_DWORD *)(v2 + 144) > 1u || v70)
  {
    uint64_t v174 = *(_WORD **)(v2 + 160);
    uint64_t v79 = v2;
    uint64_t v74 = &dnssd_client_states;
    int v75 = v238;
LABEL_337:
    v174[1] = bswap32(v71 & 0x7ECF | 0xFFFF8000) >> 16;
    if (v70)
    {
      __int16 v180 = __rev16(v71 & 0x7EC0 | 0x8000 | v70);
      goto LABEL_459;
    }
    goto LABEL_340;
  }
  uint64_t v72 = *(void *)(v2 + 8);
  uint64_t v73 = *(void *)(v2 + 192);
  uint64_t v74 = &dnssd_client_states;
  int v75 = v238;
  if (v73)
  {
    int v76 = *(const char **)(v73 + 32);
    if (v72) {
      goto LABEL_167;
    }
LABEL_332:
    __int16 v175 = v76;
    *(_WORD *)(*(void *)(v2 + 160) + 2) = *(_WORD *)(*(void *)(v2 + 160) + 2) & 0xF0FF | 0x200;
    uint64_t v176 = global_os_log;
    BOOL v177 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    uint64_t v79 = v2;
    if (!v177) {
      goto LABEL_335;
    }
    *(_DWORD *)int buf = 136446723;
    v262 = "dp_dns_queries_finished";
    __int16 v263 = 2160;
    *(void *)v264 = 1752392040;
    *(_WORD *)&v264[8] = 2081;
    *(void *)&long long v265 = v175;
    v178 = "%{public}s: NULL tracker on %{private, mask.hash}s";
    goto LABEL_470;
  }
  int v76 = "(null)";
  if (!v72) {
    goto LABEL_332;
  }
LABEL_167:
  uint64_t v227 = *(void *)(v2 + 8);
  uint64_t v77 = *(void *)(v72 + 16);
  if (!v77)
  {
    v221 = v76;
    *(_WORD *)(*(void *)(v2 + 160) + 2) = *(_WORD *)(*(void *)(v2 + 160) + 2) & 0xF0FF | 0x200;
    uint64_t v176 = global_os_log;
    BOOL v222 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    uint64_t v79 = v2;
    if (!v222) {
      goto LABEL_335;
    }
    *(_DWORD *)int buf = 136446723;
    v262 = "dp_dns_queries_finished";
    __int16 v263 = 2160;
    *(void *)v264 = 1752392040;
    *(_WORD *)&v264[8] = 2081;
    *(void *)&long long v265 = v221;
    v178 = "%{public}s: NULL tracker->dns_queries on %{private, mask.hash}s";
LABEL_470:
    _os_log_impl((void *)&_mh_execute_header, v176, OS_LOG_TYPE_ERROR, v178, buf, 0x20u);
    goto LABEL_474;
  }
  int v78 = *(_DWORD *)(v2 + 88);
  uint64_t v79 = v2;
  if (v78 == 1) {
    goto LABEL_335;
  }
  v224 = v76;
  int v80 = 0;
  uint64_t v81 = *(void *)(v72 + 16);
  do
  {
    if (!*(void *)(v81 + 160))
    {
      v220 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446210;
        v262 = "dp_dns_queries_finished";
        _os_log_impl((void *)&_mh_execute_header, v220, OS_LOG_TYPE_ERROR, "%{public}s: null response on match query", buf, 0xCu);
      }
LABEL_473:
      *(_WORD *)(*(void *)(v2 + 160) + 2) = *(_WORD *)(*(void *)(v2 + 160) + 2) & 0xF0FF | 0x200;
LABEL_474:
      uint64_t v79 = v2;
      goto LABEL_335;
    }
    if (*(void *)(v81 + 64) == *(void *)(v2 + 64))
    {
      if (!*(unsigned char *)(v81 + 200)) {
        return;
      }
      ++v80;
    }
    uint64_t v81 = *(void *)(v81 + 16);
  }
  while (v81);
  if (v80 != v78) {
    return;
  }
  uint64_t v79 = 0;
  uint64_t v236 = 0;
  uint64_t v237 = 0;
  uint64_t v82 = 0;
  do
  {
    if (*(void *)(v77 + 64) == *(void *)(v2 + 64))
    {
      uint64_t v83 = v79;
      if ((dns_wire_parse_((uint64_t *)(v77 + 168), *(unsigned __int16 **)(v77 + 160), *(_DWORD *)(v77 + 104) - *(void *)(v77 + 160)) & 1) == 0)goto LABEL_473; {
      int v84 = *(_DWORD **)(v77 + 168);
      }
      if (v83)
      {
        uint64_t v79 = v83;
      }
      else
      {
        uint64_t v82 = *(void *)(v77 + 168);
        uint64_t v79 = v77;
      }
      LODWORD(v236) = v84[1] + v236;
      HIDWORD(v236) += v84[2];
      LODWORD(v237) = v84[3] + v237;
      HIDWORD(v237) += v84[4];
    }
    uint64_t v77 = *(void *)(v77 + 16);
  }
  while (v77);
  __int16 v223 = v71;
  uint64_t v225 = v6;
  int v85 = 0;
  v233 = (int32x4_t *)(v82 + 16);
  v234 = (const void **)(v82 + 48);
  v231 = (int32x4_t *)(v82 + 12);
  v232 = (const void **)(v82 + 40);
  v229 = (int32x4_t *)(v82 + 8);
  v230 = (const void **)(v82 + 32);
  v228 = (const void **)(v82 + 24);
  v235 = (int32x4_t *)(v82 + 4);
  while (2)
  {
    BOOL v86 = *(void **)(v227 + 16);
    if (v86)
    {
      __int16 v87 = 0;
      uint64_t v256 = 0;
      unsigned __int32 v258 = 0;
      int v88 = 0;
      int v89 = 0;
      uint64_t v240 = v79;
      do
      {
        if (*(void *)(v2 + 64) != v86[8]) {
          break;
        }
        switch(v85)
        {
          case 0:
            uint64_t v90 = v86[21];
            int v88 = (const void **)(v90 + 24);
            uint64_t v256 = *(unsigned int *)(v90 + 4);
            int v89 = v228;
            unsigned __int32 v258 = v236;
            __int16 v87 = v235;
            break;
          case 1:
            uint64_t v91 = v86[21];
            int v88 = (const void **)(v91 + 32);
            uint64_t v256 = *(unsigned int *)(v91 + 8);
            int v89 = v230;
            unsigned __int32 v258 = HIDWORD(v236);
            __int16 v87 = v229;
            break;
          case 2:
            uint64_t v92 = v86[21];
            int v88 = (const void **)(v92 + 40);
            uint64_t v256 = *(unsigned int *)(v92 + 12);
            int v89 = v232;
            unsigned __int32 v258 = v237;
            __int16 v87 = v231;
            break;
          case 3:
            uint64_t v93 = v86[21];
            int v88 = (const void **)(v93 + 48);
            uint64_t v256 = *(unsigned int *)(v93 + 16);
            int v89 = v234;
            unsigned __int32 v258 = HIDWORD(v237);
            __int16 v87 = v233;
            break;
          default:
            break;
        }
        if (v89 == v88)
        {
          uint64_t v114 = malloc_type_calloc(v258, 0x40uLL, 0x1032040A90C5805uLL);
          if (!v114)
          {
            *(_WORD *)(*(void *)(v2 + 160) + 2) = *(_WORD *)(*(void *)(v2 + 160) + 2) & 0xF0FF | 0x200;
            uint64_t v74 = &dnssd_client_states;
            uint64_t v176 = global_os_log;
            BOOL v219 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
            uint64_t v79 = v2;
            int v75 = v238;
            __int16 v71 = v223;
            if (!v219) {
              goto LABEL_335;
            }
            *(_DWORD *)int buf = 136446723;
            v262 = "dp_dns_queries_finished";
            __int16 v263 = 2160;
            *(void *)v264 = 1752392040;
            *(_WORD *)&v264[8] = 2081;
            *(void *)&long long v265 = v224;
            v178 = "%{public}s: Unable to allocate memory for query response section on %{private, mask.hash}s";
            goto LABEL_470;
          }
          int v115 = v114;
          memcpy(v114, *v89, v256 << 6);
          bzero((void *)*v89, v256 << 6);
          free((void *)*v89);
          *int v89 = v115;
        }
        else
        {
          v246 = v86;
          unsigned __int32 v94 = v87->i32[0];
          v242 = v89;
          v244 = v88;
          if (v256)
          {
            uint64_t v95 = 0;
            v252 = (char *)*v88;
            v248 = (char *)*v89;
            uint64_t v250 = (uint64_t)*v89 + 16;
            while (!v94)
            {
LABEL_232:
              if (v94 >= v258)
              {
                int v113 = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)int buf = 136446978;
                  v262 = "dp_move_rrs";
                  __int16 v263 = 1024;
                  *(_DWORD *)v264 = v94;
                  *(_WORD *)&v264[4] = 1024;
                  *(_DWORD *)&v264[6] = v258;
                  LOWORD(v265) = 1024;
                  *(_DWORD *)((char *)&v265 + 2) = v95;
                  _os_log_impl((void *)&_mh_execute_header, v113, OS_LOG_TYPE_ERROR, "%{public}s: first_count %d unexpectedly equal to count %d with uint64_t i = %d", buf, 0x1Eu);
                }
              }
              else
              {
                int v108 = &v252[64 * v95];
                long long v109 = *(_OWORD *)v108;
                long long v110 = *((_OWORD *)v108 + 1);
                long long v111 = *((_OWORD *)v108 + 3);
                uint64_t v112 = &v248[64 * (unint64_t)v94];
                *((_OWORD *)v112 + 2) = *((_OWORD *)v108 + 2);
                *((_OWORD *)v112 + 3) = v111;
                *(_OWORD *)uint64_t v112 = v109;
                *((_OWORD *)v112 + 1) = v110;
                ++v94;
                *((_WORD *)v108 + 4) = 0;
              }
LABEL_236:
              if (++v95 == v256) {
                goto LABEL_237;
              }
            }
            uint64_t v96 = (uint64_t)&v252[64 * v95];
            uint64_t v97 = v94;
            __int16 v98 = (uint64_t ***)(v96 + 16);
            v254 = (uint64_t ***)(v96 + 24);
            uint64_t v99 = (uint64_t **)v250;
            while (2)
            {
              if (*((unsigned __int16 *)v99 - 4) == *(unsigned __int16 *)(v96 + 8)
                && *((unsigned __int16 *)v99 - 3) == *(unsigned __int16 *)(v96 + 10))
              {
                int v100 = dns_names_equal(*(v99 - 2), *(uint64_t ***)v96);
                if (v100) {
                  BOOL v101 = v85 == 0;
                }
                else {
                  BOOL v101 = 1;
                }
                if (v101)
                {
LABEL_215:
                  if (v100) {
                    goto LABEL_236;
                  }
                  goto LABEL_216;
                }
                unsigned int v102 = *((unsigned __int16 *)v99 - 4);
                if (v102 > 0xF)
                {
                  unsigned int v103 = v102 - 24;
                  switch(v103)
                  {
                    case 0u:
                      goto LABEL_216;
                    case 1u:
                      LOBYTE(v100) = dns_keys_rdata_equal((uint64_t)(v99 - 2), v96);
                      goto LABEL_215;
                    case 2u:
                    case 3u:
                    case 5u:
                    case 6u:
                    case 7u:
                    case 8u:
                      goto LABEL_218;
                    case 4u:
                      if (*v99 != (uint64_t *)*v98 || v99[1] != *(uint64_t **)(v96 + 24)) {
                        goto LABEL_216;
                      }
                      goto LABEL_236;
                    case 9u:
                      if (*((unsigned __int16 *)v99 + 4) != *(unsigned __int16 *)v254
                        || *((unsigned __int16 *)v99 + 5) != *(unsigned __int16 *)(v96 + 26)
                        || *((unsigned __int16 *)v99 + 6) != *(unsigned __int16 *)(v96 + 28))
                      {
                        goto LABEL_216;
                      }
                      goto LABEL_214;
                    default:
                      if (v103 != 16) {
                        goto LABEL_218;
                      }
                      size_t v104 = *(unsigned __int8 *)v99;
                      if (v104 != *(unsigned __int8 *)v98) {
                        goto LABEL_216;
                      }
                      BOOL v105 = v99[1];
                      __int16 v106 = *v254;
                      break;
                  }
                  goto LABEL_220;
                }
                switch(*((_WORD *)v99 - 4))
                {
                  case 0:
                    goto LABEL_236;
                  case 1:
                    if (*(_DWORD *)v99 != *(_DWORD *)v98) {
                      break;
                    }
                    goto LABEL_236;
                  case 2:
                  case 5:
                    goto LABEL_214;
                  case 3:
                  case 4:
                    goto LABEL_218;
                  default:
                    if (v102 == 12)
                    {
LABEL_214:
                      LOBYTE(v100) = dns_names_equal(*v99, *v98);
                      goto LABEL_215;
                    }
LABEL_218:
                    size_t v104 = *((unsigned __int16 *)v99 + 4);
                    if (v104 == *(unsigned __int16 *)v254)
                    {
                      BOOL v105 = *v99;
                      __int16 v106 = *v98;
LABEL_220:
                      if (!memcmp(v105, v106, v104)) {
                        goto LABEL_236;
                      }
                    }
                    break;
                }
              }
LABEL_216:
              v99 += 8;
              if (!--v97) {
                goto LABEL_232;
              }
              continue;
            }
          }
LABEL_237:
          int v89 = v242;
          v87->i32[0] = v94;
          uint64_t v2 = a1;
          int v88 = v244;
          BOOL v86 = v246;
        }
        BOOL v86 = (void *)v86[2];
        uint64_t v79 = v240;
      }
      while (v86);
    }
    if (++v85 != 4) {
      continue;
    }
    break;
  }
  uint64_t v116 = v79 + 96;
  v257 = (void *)(v79 + 120);
  while (2)
  {
    int v117 = 0;
    uint64_t v118 = *(void *)(v79 + 160);
    uint64_t v119 = *(void *)(v79 + 168);
    uint64_t v120 = v118 + 12 + *(void *)(v79 + 176);
    *(void *)(v79 + 104) = v118 + 12;
    *(void *)(v79 + 112) = v120;
    *(void *)(v79 + 96) = v118;
    *(void *)(v79 + 152) = 0;
    v249 = (uint64_t *)(v119 + 48);
    v251 = (unsigned int *)(v119 + 16);
    v245 = (uint64_t *)(v119 + 40);
    v247 = (unsigned int *)(v119 + 12);
    v243 = (unsigned int *)(v119 + 8);
    void *v257 = 0;
    v257[1] = 0;
    v241 = (uint64_t *)(v119 + 32);
    v255 = (unsigned int *)(v119 + 4);
    v253 = (uint64_t *)(v119 + 24);
    char v259 = 1;
    while (2)
    {
      uint64_t v121 = v253;
      uint64_t v122 = v255;
      switch(v117)
      {
        case 0:
          goto LABEL_248;
        case 1:
          uint64_t v121 = v241;
          uint64_t v122 = v243;
          goto LABEL_248;
        case 2:
          uint64_t v121 = v245;
          uint64_t v122 = v247;
          goto LABEL_248;
        case 3:
          uint64_t v121 = v249;
          uint64_t v122 = v251;
LABEL_248:
          uint64_t v123 = *v122;
          if ((int)v123 < 1) {
            goto LABEL_325;
          }
          int v124 = 0;
          uint64_t v125 = 0;
          uint64_t v126 = *v121;
          uint64_t v127 = v123 << 6;
          break;
        default:
          goto LABEL_325;
      }
      while (2)
      {
        if (*(unsigned char *)(v79 + 144))
        {
LABEL_319:
          v168 = global_os_log;
          uint64_t v169 = v79;
          BOOL v170 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
          uint64_t v79 = v169;
          if (v170)
          {
            int v171 = *(unsigned __int16 *)(v126 + v125 + 8);
            *(_DWORD *)int buf = 136446978;
            v262 = "dns_message_rrs_to_wire";
            __int16 v263 = 1024;
            *(_DWORD *)v264 = v117;
            *(_WORD *)&v264[4] = 1024;
            *(_DWORD *)&v264[6] = v124;
            LOWORD(v265) = 1024;
            *(_DWORD *)((char *)&v265 + 2) = v171;
            _os_log_impl((void *)&_mh_execute_header, v168, OS_LOG_TYPE_ERROR, "%{public}s: no space in message for rr %d/%d %d", buf, 0x1Eu);
            uint64_t v79 = v169;
          }
        }
        else
        {
          uint64_t v128 = *(void *)(v79 + 104);
          uint64_t v129 = v126 + v125;
          uint64_t v130 = v79;
          dns_concatenate_name_to_wire_(v116, *(uint64_t ***)(v126 + v125), 0, 0, 648);
          uint64_t v79 = v130;
          unsigned int v131 = *(_DWORD *)(v130 + 144);
          if (v131 > 1) {
            goto LABEL_257;
          }
          BOOL v132 = *(unsigned char **)(v130 + 104);
          if ((unint64_t)(v132 + 2) < *(void *)(v130 + 112))
          {
            __int16 v133 = *(_WORD *)(v129 + 8);
            *(void *)(v130 + 104) = v132 + 1;
            *BOOL v132 = HIBYTE(v133);
            BOOL v134 = *(unsigned char **)(v130 + 104);
            *(void *)(v130 + 104) = v134 + 1;
            *BOOL v134 = v133;
            unsigned int v131 = *(_DWORD *)(v130 + 144);
            if (v131 > 1) {
              goto LABEL_257;
            }
            BOOL v135 = *(unsigned char **)(v130 + 104);
            if ((unint64_t)(v135 + 2) < *(void *)(v130 + 112))
            {
              __int16 v136 = *(_WORD *)(v126 + v125 + 10);
              *(void *)(v130 + 104) = v135 + 1;
              *BOOL v135 = HIBYTE(v136);
              int v137 = *(unsigned char **)(v130 + 104);
              *(void *)(v130 + 104) = v137 + 1;
              *int v137 = v136;
              unsigned int v131 = *(_DWORD *)(v130 + 144);
              goto LABEL_257;
            }
            unsigned int v131 = 111;
            *(_DWORD *)(v130 + 144) = 111;
            *(_DWORD *)(v130 + 136) = 650;
            if (v259)
            {
LABEL_318:
              *(void *)(v79 + 104) = v128;
              goto LABEL_319;
            }
            goto LABEL_269;
          }
          unsigned int v131 = 111;
          *(_DWORD *)(v130 + 144) = 111;
          *(_DWORD *)(v130 + 136) = 649;
LABEL_257:
          if (v259)
          {
            if (v131) {
              goto LABEL_318;
            }
          }
          else
          {
            if (v131 > 1) {
              goto LABEL_269;
            }
            dns_u32_to_wire_(v116, *(_DWORD *)(v126 + v125 + 12), 654);
            uint64_t v79 = v130;
            unsigned int v131 = *(_DWORD *)(v130 + 144);
            if (v131 > 1) {
              goto LABEL_269;
            }
            uint64_t v138 = *(void *)(v130 + 104);
            if ((unint64_t)(v138 + 2) >= *(void *)(v130 + 112))
            {
              unsigned int v131 = 111;
            }
            else
            {
              if (!*v257)
              {
                *(void *)(v130 + 120) = v138;
                *(void *)(v130 + 104) = v138 + 2;
                goto LABEL_269;
              }
              v131 |= 0x2Cu;
            }
            *(_DWORD *)(v130 + 144) = v131;
            *(_DWORD *)(v130 + 136) = 655;
LABEL_269:
            switch(*(_WORD *)(v129 + 8))
            {
              case 0:
                uint64_t v145 = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)int buf = 136446210;
                  v262 = "dns_rr_to_wire";
                  socklen_t v143 = v145;
                  BOOL v144 = "%{public}s: invalid rr!";
LABEL_288:
                  _os_log_impl((void *)&_mh_execute_header, v143, OS_LOG_TYPE_ERROR, v144, buf, 0xCu);
                  unsigned int v131 = *(_DWORD *)(v130 + 144);
                }
LABEL_289:
                uint64_t v79 = v130;
                *(_DWORD *)(v130 + 144) = v131 & 1 | 0x2C;
                goto LABEL_318;
              case 1:
                if (v131 > 1) {
                  goto LABEL_312;
                }
                char v146 = *(_DWORD **)(v79 + 104);
                if ((unint64_t)(v146 + 1) > *(void *)(v79 + 112))
                {
                  *(_DWORD *)(v79 + 144) = 111;
                  int v147 = 693;
                  goto LABEL_317;
                }
                *char v146 = *(_DWORD *)(v126 + v125 + 16);
                uint64_t v162 = *(void *)(v79 + 104) + 4;
LABEL_306:
                *(void *)(v79 + 104) = v162;
                goto LABEL_312;
              case 2:
              case 5:
              case 0xC:
                BOOL v139 = *(uint64_t ***)(v126 + v125 + 16);
                uint64_t v140 = v116;
                int v141 = 682;
                goto LABEL_310;
              case 3:
              case 4:
              case 7:
              case 8:
              case 9:
              case 0xA:
              case 0xB:
              case 0xD:
              case 0xE:
              case 0xF:
LABEL_283:
                if (v131 > 1) {
                  goto LABEL_312;
                }
                size_t v148 = *(unsigned __int16 *)(v126 + v125 + 24);
                int v149 = *(void **)(v79 + 104);
                if ((unint64_t)v149 + v148 > *(void *)(v79 + 112))
                {
                  *(_DWORD *)(v79 + 144) = 111;
                  int v147 = 665;
                  goto LABEL_317;
                }
                __int16 v163 = *(const void **)(v126 + v125 + 16);
                goto LABEL_304;
              case 6:
                dns_concatenate_name_to_wire_(v116, *(uint64_t ***)(v126 + v125 + 16), 0, 0, 669);
                dns_concatenate_name_to_wire_(v116, *(uint64_t ***)(v126 + v125 + 24), 0, 0, 670);
                dns_u32_to_wire_(v116, *(_DWORD *)(v126 + v125 + 32), 671);
                dns_u32_to_wire_(v116, *(_DWORD *)(v126 + v125 + 36), 672);
                dns_u32_to_wire_(v116, *(_DWORD *)(v126 + v125 + 40), 673);
                dns_u32_to_wire_(v116, *(_DWORD *)(v126 + v125 + 44), 674);
                dns_u32_to_wire_(v116, *(_DWORD *)(v126 + v125 + 48), 675);
                goto LABEL_311;
              case 0x10:
                if (v131 > 1) {
                  goto LABEL_312;
                }
                size_t v148 = *(unsigned __int8 *)(v126 + v125 + 16);
                int v149 = *(void **)(v79 + 104);
                if ((unint64_t)v149 + v148 > *(void *)(v79 + 112))
                {
                  *(_DWORD *)(v79 + 144) = 111;
                  int v147 = 712;
LABEL_317:
                  *(_DWORD *)(v79 + 136) = v147;
                  goto LABEL_318;
                }
                __int16 v163 = *(const void **)(v126 + v125 + 24);
LABEL_304:
                memcpy(v149, v163, v148);
                uint64_t v79 = v130;
                *(void *)(v130 + 104) += v148;
LABEL_312:
                unsigned int v165 = *(_DWORD *)(v79 + 144);
                if (v165 > 1) {
                  goto LABEL_318;
                }
                uint64_t v166 = (unsigned char *)*v257;
                if (!*v257)
                {
                  *(_DWORD *)(v79 + 144) = v165 | 0x2C;
                  int v147 = 715;
                  goto LABEL_317;
                }
                uint64_t v167 = *(void *)(v79 + 104) - (void)v166 - 2;
                *uint64_t v166 = BYTE1(v167);
                *(unsigned char *)(*(void *)(v79 + 120) + 1) = v167;
                *(void *)(v79 + 120) = 0;
                if (*(_DWORD *)(v79 + 144)) {
                  goto LABEL_318;
                }
                break;
              default:
                switch(*(_WORD *)(v129 + 8))
                {
                  case 0x18:
                    uint64_t v142 = global_os_log;
                    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_289;
                    }
                    *(_DWORD *)int buf = 136446210;
                    v262 = "dns_rr_to_wire";
                    socklen_t v143 = v142;
                    BOOL v144 = "%{public}s: signature not valid here!";
                    goto LABEL_288;
                  case 0x19:
                    uint64_t v150 = global_os_log;
                    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_289;
                    }
                    *(_DWORD *)int buf = 136446210;
                    v262 = "dns_rr_to_wire";
                    socklen_t v143 = v150;
                    BOOL v144 = "%{public}s: key not valid here!";
                    goto LABEL_288;
                  case 0x1C:
                    if (v131 > 1) {
                      goto LABEL_312;
                    }
                    uint64_t v151 = *(_OWORD **)(v79 + 104);
                    if ((unint64_t)(v151 + 1) > *(void *)(v79 + 112))
                    {
                      *(_DWORD *)(v79 + 144) = 111;
                      int v147 = 697;
                      goto LABEL_317;
                    }
                    _OWORD *v151 = *(_OWORD *)(v126 + v125 + 16);
                    uint64_t v162 = *(void *)(v79 + 104) + 16;
                    goto LABEL_306;
                  case 0x21:
                    uint64_t v152 = v126 + v125;
                    if (v131 > 1) {
                      goto LABEL_309;
                    }
                    v153 = *(unsigned char **)(v79 + 104);
                    if ((unint64_t)(v153 + 2) >= *(void *)(v79 + 112))
                    {
                      *(_DWORD *)(v79 + 144) = 111;
                      int v164 = 686;
                    }
                    else
                    {
                      __int16 v154 = *(_WORD *)(v152 + 24);
                      *(void *)(v79 + 104) = v153 + 1;
                      unsigned char *v153 = HIBYTE(v154);
                      long long v155 = *(unsigned char **)(v79 + 104);
                      *(void *)(v79 + 104) = v155 + 1;
                      unsigned char *v155 = v154;
                      if (*(_DWORD *)(v79 + 144) > 1u) {
                        goto LABEL_309;
                      }
                      long long v156 = *(unsigned char **)(v79 + 104);
                      if ((unint64_t)(v156 + 2) >= *(void *)(v79 + 112))
                      {
                        *(_DWORD *)(v79 + 144) = 111;
                        int v164 = 687;
                      }
                      else
                      {
                        __int16 v157 = *(_WORD *)(v126 + v125 + 26);
                        *(void *)(v79 + 104) = v156 + 1;
                        *long long v156 = HIBYTE(v157);
                        long long v158 = *(unsigned char **)(v79 + 104);
                        *(void *)(v79 + 104) = v158 + 1;
                        *long long v158 = v157;
                        if (*(_DWORD *)(v79 + 144) > 1u) {
                          goto LABEL_309;
                        }
                        __int16 v159 = *(unsigned char **)(v79 + 104);
                        if ((unint64_t)(v159 + 2) < *(void *)(v79 + 112))
                        {
                          __int16 v160 = *(_WORD *)(v126 + v125 + 28);
                          *(void *)(v79 + 104) = v159 + 1;
                          *__int16 v159 = HIBYTE(v160);
                          __int16 v161 = *(unsigned char **)(v79 + 104);
                          *(void *)(v79 + 104) = v161 + 1;
                          unsigned char *v161 = v160;
                          goto LABEL_309;
                        }
                        *(_DWORD *)(v79 + 144) = 111;
                        int v164 = 688;
                      }
                    }
                    *(_DWORD *)(v79 + 136) = v164;
LABEL_309:
                    BOOL v139 = *(uint64_t ***)(v152 + 16);
                    uint64_t v140 = v116;
                    int v141 = 689;
                    break;
                  default:
                    goto LABEL_283;
                }
LABEL_310:
                dns_concatenate_name_to_wire_(v140, v139, 0, 0, v141);
LABEL_311:
                uint64_t v79 = v130;
                goto LABEL_312;
            }
          }
        }
        v125 += 64;
        ++v124;
        if (v127 != v125) {
          continue;
        }
        break;
      }
LABEL_325:
      char v259 = 0;
      if (++v117 != 4) {
        continue;
      }
      break;
    }
    if ((*(unsigned char *)(v79 + 144) & 1) != 0 && (*(_WORD *)(*(void *)(*(void *)(v79 + 8) + 8) + 416) & 0x20) != 0)
    {
      uint64_t v172 = v79;
      BOOL v173 = embiggen(v79);
      uint64_t v79 = v172;
      if (v173)
      {
        *(_DWORD *)(v172 + 144) = 0;
        continue;
      }
    }
    break;
  }
  *(int8x8_t *)(*(void *)(v79 + 160) + 4) = vrev16_s8((int8x8_t)vmovn_s32(*v235));
  int v75 = v238;
  uint64_t v2 = a1;
  uint64_t v6 = v225;
  uint64_t v74 = &dnssd_client_states;
  __int16 v71 = v223;
LABEL_335:
  uint64_t v174 = *(_WORD **)(v79 + 160);
  unsigned int v179 = (unsigned __int16)v174[1];
  uint64_t v9 = v79 + 96;
  uint64_t v3 = *(void *)(v79 + 104);
  if ((v179 & 0xF00) != 0)
  {
    int v70 = (v179 >> 8) & 0xF;
    goto LABEL_337;
  }
  v174[1] = __rev16(v71 & 0x7ECF | 0x8000);
LABEL_340:
  if (!*(unsigned char *)(v79 + 92)) {
    goto LABEL_448;
  }
  while (2)
  {
    unsigned int v181 = *(_DWORD *)(v9 + 48);
    if (v181 > 1) {
      goto LABEL_387;
    }
    v182 = *(unsigned char **)(v9 + 8);
    if ((unint64_t)(v182 + 1) >= *(void *)(v9 + 16))
    {
      unsigned int v181 = 111;
      *(_DWORD *)(v9 + 48) = 111;
      *(_DWORD *)(v9 + 40) = 2557;
LABEL_387:
      __int16 v183 = v238;
      if (v238) {
        BOOL v200 = 0;
      }
      else {
        BOOL v200 = v181 > 1;
      }
      if (v200) {
        __int16 v183 = "Root label";
      }
      goto LABEL_392;
    }
    *(void *)(v9 + 8) = v182 + 1;
    unsigned char *v182 = 0;
    unsigned int v181 = *(_DWORD *)(v9 + 48);
    __int16 v183 = v238;
    if (v238) {
      BOOL v184 = 0;
    }
    else {
      BOOL v184 = v181 > 1;
    }
    if (v184) {
      __int16 v183 = "Root label";
    }
    if (v181 > 1)
    {
LABEL_392:
      if (v183) {
        BOOL v201 = 0;
      }
      else {
        BOOL v201 = v181 > 1;
      }
      if (v201) {
        __int16 v183 = "dns_rrtype_opt";
      }
LABEL_397:
      if (v183) {
        BOOL v202 = 0;
      }
      else {
        BOOL v202 = v181 > 1;
      }
      if (v202) {
        __int16 v183 = "UDP Payload size";
      }
LABEL_402:
      if (v183) {
        BOOL v203 = 0;
      }
      else {
        BOOL v203 = v181 > 1;
      }
      if (v203) {
        __int16 v183 = "extended-rcode";
      }
LABEL_407:
      if (v183) {
        BOOL v204 = 0;
      }
      else {
        BOOL v204 = v181 > 1;
      }
      if (v204) {
        __int16 v183 = "EDNS version 0";
      }
LABEL_412:
      if (v183) {
        BOOL v205 = 0;
      }
      else {
        BOOL v205 = v181 > 1;
      }
      if (v205) {
        __int16 v183 = "No extended flags";
      }
      break;
    }
    __int16 v185 = *(unsigned char **)(v9 + 8);
    if ((unint64_t)(v185 + 2) >= *(void *)(v9 + 16))
    {
      *(_DWORD *)(v9 + 48) = 111;
      *(_DWORD *)(v9 + 40) = 2558;
      if (!v183) {
        __int16 v183 = "dns_rrtype_opt";
      }
      goto LABEL_440;
    }
    *(void *)(v9 + 8) = v185 + 1;
    *__int16 v185 = 0;
    v186 = *(unsigned char **)(v9 + 8);
    *(void *)(v9 + 8) = v186 + 1;
    unsigned char *v186 = 41;
    unsigned int v181 = *(_DWORD *)(v9 + 48);
    if (v183) {
      BOOL v187 = 0;
    }
    else {
      BOOL v187 = v181 > 1;
    }
    if (v187) {
      __int16 v183 = "dns_rrtype_opt";
    }
    if (v181 > 1) {
      goto LABEL_397;
    }
    uint64_t v188 = *(unsigned char **)(v9 + 8);
    if ((unint64_t)(v188 + 2) >= *(void *)(v9 + 16))
    {
      *(_DWORD *)(v9 + 48) = 111;
      *(_DWORD *)(v9 + 40) = 2559;
      if (!v183) {
        __int16 v183 = "UDP Payload size";
      }
      goto LABEL_440;
    }
    *(void *)(v9 + 8) = v188 + 1;
    *uint64_t v188 = 16;
    __int16 v189 = *(unsigned char **)(v9 + 8);
    *(void *)(v9 + 8) = v189 + 1;
    *__int16 v189 = 0;
    unsigned int v181 = *(_DWORD *)(v9 + 48);
    if (v183) {
      BOOL v190 = 0;
    }
    else {
      BOOL v190 = v181 > 1;
    }
    if (v190) {
      __int16 v183 = "UDP Payload size";
    }
    if (v181 > 1) {
      goto LABEL_402;
    }
    __int16 v191 = *(unsigned char **)(v9 + 8);
    if ((unint64_t)(v191 + 1) >= *(void *)(v9 + 16))
    {
      *(_DWORD *)(v9 + 48) = 111;
      *(_DWORD *)(v9 + 40) = 2560;
      if (!v183) {
        __int16 v183 = "extended-rcode";
      }
      goto LABEL_440;
    }
    *(void *)(v9 + 8) = v191 + 1;
    *__int16 v191 = 0;
    unsigned int v181 = *(_DWORD *)(v9 + 48);
    if (v183) {
      BOOL v192 = 0;
    }
    else {
      BOOL v192 = v181 > 1;
    }
    if (v192) {
      __int16 v183 = "extended-rcode";
    }
    if (v181 > 1) {
      goto LABEL_407;
    }
    __int16 v193 = *(unsigned char **)(v9 + 8);
    if ((unint64_t)(v193 + 1) >= *(void *)(v9 + 16))
    {
      *(_DWORD *)(v9 + 48) = 111;
      *(_DWORD *)(v9 + 40) = 2561;
      if (!v183) {
        __int16 v183 = "EDNS version 0";
      }
      goto LABEL_440;
    }
    *(void *)(v9 + 8) = v193 + 1;
    *__int16 v193 = 0;
    unsigned int v181 = *(_DWORD *)(v9 + 48);
    if (v183) {
      BOOL v194 = 0;
    }
    else {
      BOOL v194 = v181 > 1;
    }
    if (v194) {
      __int16 v183 = "EDNS version 0";
    }
    if (v181 > 1) {
      goto LABEL_412;
    }
    __int16 v195 = *(unsigned char **)(v9 + 8);
    if ((unint64_t)(v195 + 2) >= *(void *)(v9 + 16))
    {
      *(_DWORD *)(v9 + 48) = 111;
      *(_DWORD *)(v9 + 40) = 2562;
      if (!v183) {
        __int16 v183 = "No extended flags";
      }
      goto LABEL_440;
    }
    *(void *)(v9 + 8) = v195 + 1;
    *__int16 v195 = 0;
    uint64_t v196 = *(unsigned char **)(v9 + 8);
    *(void *)(v9 + 8) = v196 + 1;
    *uint64_t v196 = 0;
    unsigned int v181 = *(_DWORD *)(v9 + 48);
    if (v183) {
      BOOL v197 = 0;
    }
    else {
      BOOL v197 = v181 > 1;
    }
    if (v197) {
      __int16 v183 = "No extended flags";
    }
    if (v181 <= 1)
    {
      int v198 = *(unsigned char **)(v9 + 8);
      if ((unint64_t)(v198 + 2) < *(void *)(v9 + 16))
      {
        *(void *)(v9 + 8) = v198 + 1;
        *int v198 = 0;
        __int16 v199 = *(unsigned char **)(v9 + 8);
        *(void *)(v9 + 8) = v199 + 1;
        *__int16 v199 = 0;
        unsigned int v181 = *(_DWORD *)(v9 + 48);
        break;
      }
      *(_DWORD *)(v9 + 48) = 111;
      *(_DWORD *)(v9 + 40) = 2563;
LABEL_440:
      if (v183) {
        v208 = v183;
      }
      else {
        v208 = "No payload";
      }
      v238 = v208;
LABEL_423:
      *(void *)(v79 + 104) = v3;
      if ((*(_WORD *)(*(void *)(*(void *)(v79 + 8) + 8) + 416) & 0x20) == 0) {
        goto LABEL_447;
      }
      uint64_t v207 = v79;
      if (!embiggen(v79))
      {
        int v75 = v238;
        uint64_t v2 = a1;
        uint64_t v74 = &dnssd_client_states;
        uint64_t v79 = v207;
        goto LABEL_448;
      }
      *(_DWORD *)(v207 + 144) = 0;
      uint64_t v79 = v207;
      continue;
    }
    break;
  }
  if (v183) {
    BOOL v206 = 0;
  }
  else {
    BOOL v206 = v181 > 1;
  }
  if (v206) {
    __int16 v183 = "No payload";
  }
  v238 = v183;
  if (v181) {
    goto LABEL_423;
  }
  *(_WORD *)(*(void *)(v79 + 160) + 10) = 256;
LABEL_447:
  int v75 = v238;
  uint64_t v2 = a1;
  uint64_t v74 = &dnssd_client_states;
LABEL_448:
  if (*(_DWORD *)(v9 + 48) < 2u)
  {
    uint64_t v174 = *(_WORD **)(v79 + 160);
    __int16 v180 = v174[1] & 0xF0FF;
    goto LABEL_459;
  }
  uint64_t v209 = v79;
  v210 = *((void *)v74 + 306);
  if (os_log_type_enabled(v210, OS_LOG_TYPE_ERROR))
  {
    if (v2)
    {
      int v211 = *(_DWORD *)(v2 + 4);
      if (v6) {
        goto LABEL_453;
      }
LABEL_455:
      int v212 = 0;
    }
    else
    {
      int v211 = 0;
      if (!v6) {
        goto LABEL_455;
      }
LABEL_453:
      int v212 = *(_DWORD *)(v6 + 64);
    }
    unsigned int v213 = bswap32(*(unsigned __int16 *)(*(void *)(v209 + 64) + 88));
    *(_DWORD *)int buf = 136447234;
    v262 = "dp_query_send_dns_response";
    __int16 v263 = 1024;
    *(_DWORD *)v264 = v211;
    *(_WORD *)&v264[4] = 1024;
    *(_DWORD *)&v264[6] = v212;
    LOWORD(v265) = 1024;
    *(_DWORD *)((char *)&v265 + 2) = HIWORD(v213);
    WORD3(v265) = 2080;
    *((void *)&v265 + 1) = v75;
    _os_log_impl((void *)&_mh_execute_header, v210, OS_LOG_TYPE_ERROR, "%{public}s: [Q%d][QU%d][QID%x] failed on %s", buf, 0x28u);
  }
  uint64_t v79 = v209;
  uint64_t v174 = *(_WORD **)(v209 + 160);
  __int16 v180 = v174[1] & 0xF0FF;
  if (v226 != 512) {
    v180 |= 0x200u;
  }
LABEL_459:
  v174[1] = v180;
  uint64_t v214 = v79;
  size_t v215 = *(void *)(v79 + 104) - (void)v174;
  v260.iov_base = v174;
  v260.size_t iov_len = v215;
  v216 = *((void *)v74 + 306);
  if (os_log_type_enabled(v216, OS_LOG_TYPE_DEFAULT))
  {
    if (v2)
    {
      int v217 = *(_DWORD *)(v2 + 4);
      if (v6) {
        goto LABEL_462;
      }
LABEL_464:
      int v218 = 0;
    }
    else
    {
      int v217 = 0;
      if (!v6) {
        goto LABEL_464;
      }
LABEL_462:
      int v218 = *(_DWORD *)(v6 + 64);
    }
    *(_DWORD *)int buf = 136446978;
    v262 = "dp_query_send_dns_response";
    __int16 v263 = 1024;
    *(_DWORD *)v264 = v217;
    *(_WORD *)&v264[4] = 1024;
    *(_DWORD *)&v264[6] = v218;
    LOWORD(v265) = 2048;
    *(void *)((char *)&v265 + 2) = v215;
    _os_log_impl((void *)&_mh_execute_header, v216, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][QU%d] (len %zd)", buf, 0x22u);
  }
  ioloop_send_message(*(void *)(*(void *)(v214 + 8) + 8), *(void *)(v214 + 64), &v260);
  dnssd_query_cancel(v214);
}

void served_domain_free(uint64_t a1)
{
  uint64_t v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 8);
    int v11 = 136446723;
    uint64_t v12 = "served_domain_free";
    __int16 v13 = 2160;
    uint64_t v14 = 1752392040;
    __int16 v15 = 2081;
    uint64_t v16 = v3;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: served domain removed - domain name: %{private, mask.hash}s", (uint8_t *)&v11, 0x20u);
  }
  uint64_t v4 = *(void *)(a1 + 40);
  if (v4)
  {
    unsigned int v5 = *(void **)(v4 + 16);
    if (v5)
    {
      do
      {
        uint64_t v6 = (void *)*v5;
        free(v5);
        unsigned int v5 = v6;
      }
      while (v6);
      uint64_t v4 = *(void *)(a1 + 40);
    }
    if (*(void *)(v4 + 8))
    {
      free(*(void **)(v4 + 8));
      uint64_t v4 = *(void *)(a1 + 40);
    }
    free((void *)v4);
  }
  uint64_t v7 = *(void **)(a1 + 32);
  if (v7)
  {
    do
    {
      uint64_t v8 = (void *)*v7;
      free(v7);
      uint64_t v7 = v8;
    }
    while (v8);
  }
  uint64_t v9 = *(void **)(a1 + 24);
  if (v9)
  {
    do
    {
      int v10 = (void *)*v9;
      free(v9);
      uint64_t v9 = v10;
    }
    while (v10);
  }
  free(*(void **)(a1 + 16));
  free((void *)a1);
}

uint64_t dp_start_question(uint64_t a1)
{
  DNSServiceRef sdRef = 0;
  uint64_t v2 = *(void **)(a1 + 8);
  uint64_t v3 = *(char **)(a1 + 32);
  if (v2)
  {
    size_t v4 = strlen(*(const char **)(a1 + 32));
    size_t v5 = v4;
    if (v2[5])
    {
      if (v4 - 249 <= 0xFFFFFFFFFFFFFEFELL)
      {
        uint64_t v6 = 4294901756;
        uint64_t v7 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          int v8 = *(_DWORD *)(a1 + 64);
          *(_DWORD *)int buf = 136446722;
          *(void *)&uint8_t buf[4] = "dp_start_question";
          __int16 v56 = 1024;
          int v57 = v8;
          __int16 v58 = 2080;
          uint64_t v59 = (uint64_t)v66;
          uint64_t v9 = "%{public}s: [QU%d] question name %s is too long for .local.";
          int v10 = v7;
          uint32_t v11 = 28;
LABEL_59:
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, v9, buf, v11);
          return v6;
        }
        return v6;
      }
      __memcpy_chk();
      *(void *)&v66[v5] = 0x2E6C61636F6C2ELL;
    }
    else
    {
      uint64_t v12 = (const char *)v2[2];
      size_t v13 = strlen(v12) + 1;
      if (v13 + v5 >= 0x101)
      {
        uint64_t v6 = 4294901756;
        uint64_t v37 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          int v38 = *(_DWORD *)(a1 + 64);
          BOOL v39 = (_DNSServiceRef_t *)v2[1];
          *(_DWORD *)int buf = 136446978;
          *(void *)&uint8_t buf[4] = "dp_start_question";
          __int16 v56 = 1024;
          int v57 = v38;
          __int16 v58 = 2080;
          uint64_t v59 = (uint64_t)v66;
          __int16 v60 = 2080;
          DNSServiceRef v61 = v39;
          uint64_t v9 = "%{public}s: [QU%d] question name %s is too long for %s.";
          int v10 = v37;
          uint32_t v11 = 38;
          goto LABEL_59;
        }
        return v6;
      }
      __memcpy_chk();
      memcpy(&v66[v5], v12, v13);
    }
    uint64_t v3 = v66;
  }
  signed int v14 = *(_DWORD *)(a1 + 68);
  if (v14 == -5)
  {
    signed int v14 = dp_start_question_en0_ifindex;
    if (!dp_start_question_en0_ifindex)
    {
      signed int v14 = if_nametoindex("en0");
      dp_start_question_en0_ifuint32_t index = v14;
      if (!v14)
      {
        __int16 v15 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
          return 4294901743;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "dp_start_question";
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%{public}s: getting en0 ifindex failed!", buf, 0xCu);
        signed int v14 = dp_start_question_en0_ifindex;
      }
    }
    if (v14 >= 1) {
      goto LABEL_16;
    }
    return 4294901743;
  }
LABEL_16:
  int v16 = *(_DWORD *)(a1 + 56);
  int v17 = *(unsigned __int16 *)(a1 + 72);
  int v18 = *(unsigned __int16 *)(a1 + 74);
  if (!&_ne_tracker_check_is_hostname_blocked
    || (v17 != 1 ? (BOOL v19 = v17 == 28) : (BOOL v19 = 1),
        !v19 ? (BOOL v20 = v17 == 255) : (BOOL v20 = 1),
        !v20 ? (int v21 = 0) : (int v21 = 1),
        v18 == 1 ? (BOOL v22 = v21 == 0) : (BOOL v22 = 1),
        v22))
  {
    int should_save_stacktrace = 0;
  }
  else
  {
    int v36 = ne_tracker_check_is_hostname_blocked();
    if (v36 == 1)
    {
      uint64_t v6 = 4294901726;
      goto LABEL_33;
    }
    int should_save_stacktrace = ne_tracker_should_save_stacktrace();
  }
  uint64_t v6 = ConnectToServer((uint64_t *)&sdRef, v16, 8, (uint64_t)handle_query_response, (uint64_t)dns_question_callback, a1);
  if (v6) {
    goto LABEL_33;
  }
  if (v3) {
    uint64_t v26 = v3;
  }
  else {
    uint64_t v26 = (const char *)&unk_10007C630;
  }
  size_t v27 = strlen(v26);
  size_t v54 = v27 + 13;
  os_unfair_lock_lock(&g_defaults_lock);
  os_unfair_lock_unlock(&g_defaults_lock);
  if (should_save_stacktrace) {
    size_t v54 = v27 + 18;
  }
  *(void *)int buf = 0;
  BOOL v28 = (int8x16_t *)create_hdr(8, &v54, buf, *((void *)sdRef + 1) != 0, (uint64_t)sdRef);
  int v29 = *(unsigned char **)buf;
  size_t v52 = v54;
  **(unsigned char **)int buf = HIBYTE(v16);
  v29[1] = BYTE2(v16);
  v29[2] = BYTE1(v16);
  v29[3] = v16;
  v29[4] = HIBYTE(v14);
  v29[5] = BYTE2(v14);
  v29[6] = BYTE1(v14);
  v29[7] = v14;
  size_t v30 = strlen(v26) + 1;
  memcpy(v29 + 8, v26, v30);
  uint32_t v31 = &v29[v30 + 8];
  *uint32_t v31 = BYTE1(v17);
  v31[1] = v17;
  v31[2] = BYTE1(v18);
  BOOL v32 = v31 + 4;
  v31[3] = v18;
  *(void *)int buf = v31 + 4;
  if (should_save_stacktrace)
  {
    if (v31 != (unsigned char *)-4 && &v29[v52] >= v32 && (unint64_t)(&v29[v52] - v32) >= 5)
    {
      *((_DWORD *)v31 + 1) = 16779264;
      v31[8] = 1;
      BOOL v32 = v31 + 9;
    }
    *(void *)int buf = v32;
    v28->i32[2] |= 2u;
  }
  uint64_t v33 = deliver_request(v28, (uint64_t)sdRef);
  uint64_t v6 = v33;
  if (v33) {
    BOOL v34 = 1;
  }
  else {
    BOOL v34 = &_ne_tracker_check_is_hostname_blocked == 0;
  }
  if (!v34 && ((should_save_stacktrace ^ 1) & 1) == 0)
  {
    BOOL v35 = (void *)*((void *)sdRef + 15);
    if (v35)
    {
      free(v35);
      *((void *)sdRef + 15) = 0;
    }
    *((void *)sdRef + 15) = ne_tracker_copy_current_stacktrace();
LABEL_67:
    BOOL v41 = global_os_log;
    BOOL v42 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
    DNSServiceRef v43 = sdRef;
    if (v42)
    {
      int v44 = *(_DWORD *)(a1 + 64);
      uint64_t v45 = *(void *)(a1 + 24);
      *(_DWORD *)int buf = 136446978;
      *(void *)&uint8_t buf[4] = "dp_start_question";
      __int16 v56 = 1024;
      int v57 = v44;
      __int16 v58 = 2048;
      uint64_t v59 = v45;
      __int16 v60 = 2048;
      DNSServiceRef v61 = sdRef;
      _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "%{public}s: [QU%d] txn %p new sdref %p", buf, 0x26u);
      DNSServiceRef v43 = sdRef;
    }
    *(void *)(a1 + 24) = ioloop_dnssd_txn_add_((uint64_t)v43, a1, (uint64_t)dp_question_context_release, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 515);
    BOOL v46 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v47 = *(_DWORD *)(a1 + 60);
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "dp_start_question";
      __int16 v56 = 1024;
      int v57 = v47;
      __int16 v58 = 2048;
      uint64_t v59 = a1;
      __int16 v60 = 2080;
      DNSServiceRef v61 = (DNSServiceRef)"question";
      __int16 v62 = 2080;
      uint64_t v63 = "dnssd-proxy.c";
      __int16 v64 = 1024;
      int v65 = 517;
      _os_log_impl((void *)&_mh_execute_header, v46, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    int v48 = *(_DWORD *)(a1 + 60);
    if (v48)
    {
      int v49 = v48 + 1;
      *(_DWORD *)(a1 + 60) = v48 + 1;
      unsigned int v50 = global_os_log;
      if (v48 + 1 >= 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)int buf = 136447490;
          *(void *)&uint8_t buf[4] = "dp_start_question";
          __int16 v56 = 1024;
          int v57 = v49;
          __int16 v58 = 2048;
          uint64_t v59 = a1;
          __int16 v60 = 2080;
          DNSServiceRef v61 = (DNSServiceRef)"question";
          __int16 v62 = 2080;
          uint64_t v63 = "dnssd-proxy.c";
          __int16 v64 = 1024;
          int v65 = 517;
          _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++question_created;
      *(_DWORD *)(a1 + 60) = 1;
      unsigned int v50 = global_os_log;
    }
    uint64_t v6 = 0;
    if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
    {
      int v51 = *(_DWORD *)(a1 + 64);
      *(_DWORD *)int buf = 136447235;
      *(void *)&uint8_t buf[4] = "dp_start_question";
      __int16 v56 = 1024;
      int v57 = v51;
      __int16 v58 = 2160;
      uint64_t v59 = 1752392040;
      __int16 v60 = 2081;
      DNSServiceRef v61 = (DNSServiceRef)v3;
      __int16 v62 = 1024;
      LODWORD(v63) = 0;
      _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "%{public}s: [QU%d] DNSServiceQueryRecord started for '%{private, mask.hash}s': %d", buf, 0x2Cu);
      return 0;
    }
    return v6;
  }
  if (!v33) {
    goto LABEL_67;
  }
  if (v33 == -65555)
  {
    if (_should_return_noauth_error_s_once != -1) {
      dispatch_once(&_should_return_noauth_error_s_once, &__block_literal_global);
    }
    if (!_should_return_noauth_error_s_should) {
      goto LABEL_67;
    }
  }
  DNSServiceRefDeallocate(sdRef);
  DNSServiceRef sdRef = 0;
LABEL_33:
  uint64_t v24 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    int v25 = *(_DWORD *)(a1 + 64);
    *(_DWORD *)int buf = 136446978;
    *(void *)&uint8_t buf[4] = "dp_start_question";
    __int16 v56 = 1024;
    int v57 = v25;
    __int16 v58 = 2080;
    uint64_t v59 = (uint64_t)v3;
    __int16 v60 = 1024;
    LODWORD(v61) = v6;
    uint64_t v9 = "%{public}s: [QU%d] DNSServiceQueryRecord failed for '%s': %d";
    int v10 = v24;
    uint32_t v11 = 34;
    goto LABEL_59;
  }
  return v6;
}

void dp_query_context_release(void *a1)
{
  if (!a1) {
    return;
  }
  int v2 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    uint64_t v3 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v6 = 136447490;
    uint64_t v7 = "dp_query_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)uint64_t v9 = 0;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "query";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "dnssd-proxy.c";
    __int16 v10 = 1024;
    int v11 = 3262;
    size_t v5 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  uint64_t v3 = global_os_log;
  if (v2 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v6 = 136447490;
    uint64_t v7 = "dp_query_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)uint64_t v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "query";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "dnssd-proxy.c";
    __int16 v10 = 1024;
    int v11 = 3262;
    size_t v5 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, v5, (uint8_t *)&v6, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 136447490;
    uint64_t v7 = "dp_query_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)uint64_t v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "query";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "dnssd-proxy.c";
    __int16 v10 = 1024;
    int v11 = 3262;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v6, 0x36u);
    int v2 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v2 - 1;
  if (v2 == 1)
  {
    size_t v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 136447234;
      uint64_t v7 = "dp_query_context_release";
      __int16 v8 = 2048;
      *(void *)uint64_t v9 = a1;
      *(_WORD *)&v9[8] = 2080;
      *(void *)&v9[10] = "query";
      *(_WORD *)&v9[18] = 2080;
      *(void *)&v9[20] = "dnssd-proxy.c";
      *(_WORD *)&v9[28] = 1024;
      *(_DWORD *)&v9[30] = 3262;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v6, 0x30u);
    }
    ++dnssd_query_finalized;
    dnssd_query_finalize(a1);
  }
}

void dp_query_wakeup(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 192);
  uint64_t v3 = *(const char **)(v2 + 32);
  size_t v4 = strlen(v3);
  if (*(void *)(v2 + 40))
  {
    size_t v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      int v6 = *(_DWORD *)(a1 + 4);
      int v7 = *(_DWORD *)(v2 + 64);
      *(_DWORD *)int buf = 136447235;
      BOOL v28 = "dp_query_wakeup";
      __int16 v29 = 1024;
      int v30 = v6;
      __int16 v31 = 1024;
      int v32 = v7;
      __int16 v33 = 2160;
      uint64_t v34 = 1752392040;
      __int16 v35 = 2081;
      int v36 = v3;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, "%{public}s: [Q%d][QU%d] answers present, but dp_query_wakeup reached for name %{private, mask.hash}s", buf, 0x2Cu);
    }
  }
  else
  {
    *(unsigned char *)(v2 + 76) = 1;
  }
  uint64_t v8 = *(void *)(v2 + 8);
  if (v8)
  {
    if (*(void *)(v8 + 40)) {
      size_t v9 = 8;
    }
    else {
      size_t v9 = strlen(*(const char **)(v8 + 16)) + 1;
    }
  }
  else
  {
    size_t v9 = 0;
  }
  if (v9 + v4 >= 0x101)
  {
    __int16 v10 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      int v11 = *(_DWORD *)(a1 + 4);
      int v12 = *(_DWORD *)(v2 + 64);
      *(_DWORD *)int buf = 136446722;
      BOOL v28 = "dp_query_wakeup";
      __int16 v29 = 1024;
      int v30 = v11;
      __int16 v31 = 1024;
      int v32 = v12;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%{public}s: [Q%d][QU%d] no space to construct name.", buf, 0x18u);
    }
    dnssd_query_cancel(a1);
    return;
  }
  __memcpy_chk();
  if (v8) {
    *(void *)&buf[v4] = 0x2E6C61636F6C2ELL;
  }
  size_t v13 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v14 = *(_DWORD *)a1;
    int v21 = 136447490;
    BOOL v22 = "dp_query_wakeup";
    __int16 v23 = 1024;
    *(_DWORD *)uint64_t v24 = v14;
    *(_WORD *)&v24[4] = 2048;
    *(void *)&v24[6] = a1;
    *(_WORD *)&v24[14] = 2080;
    *(void *)&v24[16] = "query";
    *(_WORD *)&v24[24] = 2080;
    *(void *)&v24[26] = "dnssd-proxy.c";
    __int16 v25 = 1024;
    int v26 = 3119;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v21, 0x36u);
  }
  int v15 = *(_DWORD *)a1;
  if (*(_DWORD *)a1)
  {
    int v16 = v15 + 1;
    *(_DWORD *)a1 = v15 + 1;
    if (v15 + 1 >= 10001)
    {
      int v17 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_37;
      }
      int v21 = 136447490;
      BOOL v22 = "dp_query_wakeup";
      __int16 v23 = 1024;
      *(_DWORD *)uint64_t v24 = v16;
      *(_WORD *)&v24[4] = 2048;
      *(void *)&v24[6] = a1;
      *(_WORD *)&v24[14] = 2080;
      *(void *)&v24[16] = "query";
      *(_WORD *)&v24[24] = 2080;
      *(void *)&v24[26] = "dnssd-proxy.c";
      __int16 v25 = 1024;
      int v26 = 3119;
      int v18 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_36;
    }
  }
  else
  {
    ++dnssd_query_created;
    *(_DWORD *)a1 = 1;
  }
  dp_query_send_dns_response(a1, (uint64_t)"query wakeup");
  dp_question_cache_remove_queries(v2);
  int v19 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    int v17 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_37;
    }
    int v21 = 136447490;
    BOOL v22 = "dp_query_wakeup";
    __int16 v23 = 1024;
    *(_DWORD *)uint64_t v24 = 0;
    *(_WORD *)&v24[4] = 2048;
    *(void *)&v24[6] = a1;
    *(_WORD *)&v24[14] = 2080;
    *(void *)&v24[16] = "query";
    *(_WORD *)&v24[24] = 2080;
    *(void *)&v24[26] = "dnssd-proxy.c";
    __int16 v25 = 1024;
    int v26 = 3122;
    int v18 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_36;
  }
  int v17 = global_os_log;
  if (v19 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_37;
    }
    int v21 = 136447490;
    BOOL v22 = "dp_query_wakeup";
    __int16 v23 = 1024;
    *(_DWORD *)uint64_t v24 = v19;
    *(_WORD *)&v24[4] = 2048;
    *(void *)&v24[6] = a1;
    *(_WORD *)&v24[14] = 2080;
    *(void *)&v24[16] = "query";
    *(_WORD *)&v24[24] = 2080;
    *(void *)&v24[26] = "dnssd-proxy.c";
    __int16 v25 = 1024;
    int v26 = 3122;
    int v18 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_36:
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, v18, (uint8_t *)&v21, 0x36u);
LABEL_37:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v21 = 136447490;
    BOOL v22 = "dp_query_wakeup";
    __int16 v23 = 1024;
    *(_DWORD *)uint64_t v24 = v19;
    *(_WORD *)&v24[4] = 2048;
    *(void *)&v24[6] = a1;
    *(_WORD *)&v24[14] = 2080;
    *(void *)&v24[16] = "query";
    *(_WORD *)&v24[24] = 2080;
    *(void *)&v24[26] = "dnssd-proxy.c";
    __int16 v25 = 1024;
    int v26 = 3122;
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v21, 0x36u);
    int v19 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v19 - 1;
  if (v19 == 1)
  {
    BOOL v20 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v21 = 136447234;
      BOOL v22 = "dp_query_wakeup";
      __int16 v23 = 2048;
      *(void *)uint64_t v24 = a1;
      *(_WORD *)&v24[8] = 2080;
      *(void *)&v24[10] = "query";
      *(_WORD *)&v24[18] = 2080;
      *(void *)&v24[20] = "dnssd-proxy.c";
      *(_WORD *)&v24[28] = 1024;
      *(_DWORD *)&v24[30] = 3122;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v21, 0x30u);
    }
    ++dnssd_query_finalized;
    dnssd_query_finalize((void *)a1);
  }
}

int *dp_handle_server_disconnect(int a1)
{
  uint64_t v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136446466;
    size_t v5 = "dp_handle_server_disconnect";
    __int16 v6 = 1024;
    int v7 = a1;
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: status %d", (uint8_t *)&v4, 0x12u);
  }
  dp_iterate_questions((uint64_t)dp_void_question, 0);
  BOOL result = (int *)discovery_restart_wakeup;
  if (discovery_restart_wakeup) {
    return (int *)ioloop_add_wake_event((uint64_t)result, 0, (uint64_t)dp_restart_all_questions, 0, 0x3E8u);
  }
  BOOL result = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 617);
  discovery_restart_wakeup = (uint64_t)result;
  if (result) {
    return (int *)ioloop_add_wake_event((uint64_t)result, 0, (uint64_t)dp_restart_all_questions, 0, 0x3E8u);
  }
  return result;
}

uint64_t dp_iterate_questions(uint64_t result, uint64_t a2)
{
  uint64_t v3 = (uint64_t (*)(void *, uint64_t))result;
  int v4 = (void *)questions_without_domain;
  if (questions_without_domain)
  {
    while (1)
    {
      BOOL result = v3(v4, a2);
      if (result) {
        break;
      }
      int v4 = (void *)*v4;
      if (!v4) {
        goto LABEL_4;
      }
    }
  }
  else
  {
LABEL_4:
    size_t v5 = (void *)served_domains;
    if (served_domains)
    {
      while (1)
      {
        __int16 v6 = (void *)v5[6];
        if (v6) {
          break;
        }
LABEL_8:
        size_t v5 = (void *)*v5;
        if (!v5) {
          return result;
        }
      }
      while (1)
      {
        BOOL result = v3(v6, a2);
        if (result) {
          break;
        }
        __int16 v6 = (void *)*v6;
        if (!v6) {
          goto LABEL_8;
        }
      }
    }
  }
  return result;
}

uint64_t dp_restart_all_questions()
{
  char v1 = 0;
  return dp_iterate_questions((uint64_t)dp_restart_question, (uint64_t)&v1);
}

uint64_t dp_restart_question(uint64_t a1)
{
  if (!*(void *)(a1 + 24)) {
    dp_start_question();
  }
  return 0;
}

uint64_t dp_void_question(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2)
  {
    uint64_t v3 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = *(_DWORD *)(a1 + 64);
      int v8 = 136446722;
      size_t v9 = "dp_void_question";
      __int16 v10 = 1024;
      int v11 = v4;
      __int16 v12 = 2048;
      uint64_t v13 = v2;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: [QU%d] question->txn = %p", (uint8_t *)&v8, 0x1Cu);
      uint64_t v2 = *(void *)(a1 + 24);
    }
    ioloop_dnssd_txn_cancel(v2);
    ioloop_dnssd_txn_release_(*(int **)(a1 + 24), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 585);
    *(void *)(a1 + 24) = 0;
  }
  if (*(void *)(a1 + 40))
  {
    uint64_t v5 = *(void *)(a1 + 16);
    if (v5)
    {
      do
      {
        uint64_t v6 = *(void *)(v5 + 184);
        if (*(void *)(v5 + 72)) {
          dp_query_reply_from_cache(a1, v5, 1);
        }
        uint64_t v5 = v6;
      }
      while (v6);
    }
    dp_question_answers_free(a1);
  }
  return 0;
}

void dp_question_context_release(uint64_t a1)
{
  if (!a1) {
    return;
  }
  int v2 = *(_DWORD *)(a1 + 60);
  if (!v2)
  {
    uint64_t v3 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v6 = 136447490;
    int v7 = "dp_question_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)size_t v9 = 0;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "question";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "dnssd-proxy.c";
    __int16 v10 = 1024;
    int v11 = 423;
    uint64_t v5 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  uint64_t v3 = global_os_log;
  if (v2 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v6 = 136447490;
    int v7 = "dp_question_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)size_t v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "question";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "dnssd-proxy.c";
    __int16 v10 = 1024;
    int v11 = 423;
    uint64_t v5 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, v5, (uint8_t *)&v6, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 136447490;
    int v7 = "dp_question_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)size_t v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "question";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "dnssd-proxy.c";
    __int16 v10 = 1024;
    int v11 = 423;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v6, 0x36u);
    int v2 = *(_DWORD *)(a1 + 60);
  }
  *(_DWORD *)(a1 + 60) = v2 - 1;
  if (v2 == 1)
  {
    int v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 136447234;
      int v7 = "dp_question_context_release";
      __int16 v8 = 2048;
      *(void *)size_t v9 = a1;
      *(_WORD *)&v9[8] = 2080;
      *(void *)&v9[10] = "question";
      *(_WORD *)&v9[18] = 2080;
      *(void *)&v9[20] = "dnssd-proxy.c";
      *(_WORD *)&v9[28] = 1024;
      *(_DWORD *)&v9[30] = 423;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v6, 0x30u);
    }
    ++question_finalized;
    question_finalize(a1);
  }
}

void dns_question_callback(int a1, char a2, int a3, int a4, uint8_t *__s2, unsigned int a6, int a7, size_t __n, int32x4_t *a9, int a10, uint64_t a11)
{
  uint64_t v17 = a11;
  char v18 = 1;
  if (a4 <= -65555)
  {
    if (a4 == -65569 || a4 == -65563)
    {
      ioloop_dnssd_txn_cancel(*(void *)(a11 + 24));
      ioloop_dnssd_txn_release_(*(int **)(a11 + 24), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 3067);
      *(void *)(a11 + 24) = 0;
      dp_handle_server_disconnect(a4);
      return;
    }
    goto LABEL_65;
  }
  if (a4 == -65554)
  {
    size_t v27 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      if (a11) {
        LODWORD(v17) = *(_DWORD *)(a11 + 64);
      }
      BOOL v28 = dns_rrtype_to_string(a6);
      __int16 v29 = dns_qclass_to_string(a7);
      *(_DWORD *)int buf = 136448003;
      int v30 = " more coming";
      uint64_t v63 = "dns_question_callback";
      int v65 = v17;
      __int16 v66 = 2160;
      __int16 v64 = 1024;
      if ((a2 & 1) == 0) {
        int v30 = " done";
      }
      uint64_t v67 = 1752392040;
      __int16 v68 = 2081;
      int v69 = __s2;
      __int16 v70 = 2082;
      __int16 v71 = v28;
      __int16 v72 = 2082;
      uint64_t v73 = v29;
      __int16 v74 = 1024;
      int v75 = __n;
      __int16 v76 = 2082;
      size_t v77 = (size_t)v30;
      _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "%{public}s: [QU%d] no data - name: %{private, mask.hash}s, rrtype: %{public}s, rrclass: %{public}s, rdlen: %u.%{public}s", buf, 0x4Au);
      uint64_t v17 = a11;
    }
    char v18 = 1;
LABEL_64:
    *(unsigned char *)(v17 + 76) = 1;
    goto LABEL_65;
  }
  if (a4)
  {
LABEL_65:
    uint64_t v53 = v17;
    uint64_t v54 = *(void *)(v17 + 16);
    if (v54)
    {
      do
      {
        uint64_t v55 = *(void *)(v54 + 184);
        if (*(void *)(v54 + 72)) {
          dns_push_query_answer_process(a2, a4, __s2, a6, a7, __n, a9, a10, v54, v18);
        }
        else {
          dns_query_answer_process(a2, a4, __s2, a6, a7, __n, a9, a10, v54, v18);
        }
        uint64_t v54 = v55;
      }
      while (v55);
    }
    dp_question_cache_remove_queries(v53);
    return;
  }
  int v19 = (uint64_t *)(a11 + 40);
  if ((a2 & 2) == 0)
  {
    uint64_t v20 = *v19;
    if (*v19)
    {
      char v21 = 0;
      BOOL v22 = " more coming";
      if ((a2 & 1) == 0) {
        BOOL v22 = " done";
      }
      size_t __na = (size_t)v22;
      do
      {
        while (1)
        {
          uint64_t v23 = v20;
          if (!answer_match(v20, __n, (char *)__s2, a6, a7, a9)) {
            break;
          }
          uint64_t v24 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v59 = v24;
            int v25 = *(_DWORD *)(a11 + 64);
            __int16 v58 = dns_rrtype_to_string(a6);
            int v26 = dns_qclass_to_string(a7);
            *(_DWORD *)int buf = 136448003;
            uint64_t v63 = "dns_question_callback";
            __int16 v64 = 1024;
            int v65 = v25;
            __int16 v66 = 2160;
            uint64_t v67 = 1752392040;
            __int16 v68 = 2081;
            int v69 = __s2;
            __int16 v70 = 2082;
            __int16 v71 = v58;
            __int16 v72 = 2082;
            uint64_t v73 = v26;
            __int16 v74 = 1024;
            int v75 = __n;
            __int16 v76 = 2082;
            size_t v77 = __na;
            _os_log_impl((void *)&_mh_execute_header, v59, OS_LOG_TYPE_DEFAULT, "%{public}s: [QU%d] remove answer from cache - name: %{private, mask.hash}s, rrtype: %{public}s, rrclass: %{public}s, rdlen: %u.%{public}s", buf, 0x4Au);
          }
          uint64_t *v19 = *(void *)v23;
          free(*(void **)(v23 + 8));
          free((void *)v23);
          if (__n)
          {
            uint64_t v23 = (uint64_t)v19;
            goto LABEL_60;
          }
          uint64_t v20 = *v19;
          char v21 = 1;
          if (!*v19) {
            goto LABEL_63;
          }
        }
        uint64_t v20 = *(void *)v23;
        int v19 = (uint64_t *)v23;
      }
      while (*(void *)v23);
      if ((v21 & 1) == 0) {
        goto LABEL_50;
      }
    }
    else
    {
      uint64_t v23 = a11 + 40;
LABEL_50:
      uint64_t v46 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        __nb = v46;
        if (a11) {
          int v47 = *(_DWORD *)(a11 + 64);
        }
        else {
          int v47 = 0;
        }
        unsigned int v50 = dns_rrtype_to_string(a6);
        int v51 = dns_qclass_to_string(a7);
        *(_DWORD *)int buf = 136448003;
        size_t v52 = " more coming";
        uint64_t v63 = "dns_question_callback";
        int v65 = v47;
        __int16 v66 = 2160;
        __int16 v64 = 1024;
        if ((a2 & 1) == 0) {
          size_t v52 = " done";
        }
        uint64_t v67 = 1752392040;
        __int16 v68 = 2081;
        int v69 = __s2;
        __int16 v70 = 2082;
        __int16 v71 = v50;
        __int16 v72 = 2082;
        uint64_t v73 = v51;
        __int16 v74 = 1024;
        int v75 = __n;
        __int16 v76 = 2082;
        size_t v77 = (size_t)v52;
        _os_log_impl((void *)&_mh_execute_header, __nb, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d] remove not found in cache - name: %{private, mask.hash}s, rrtype: %{public}s, rrclass: %{public}s, rdlen: %u.%{public}s", buf, 0x4Au);
      }
LABEL_60:
      if (*(void *)v23)
      {
        char v18 = 1;
LABEL_62:
        uint64_t v17 = a11;
        goto LABEL_65;
      }
    }
LABEL_63:
    char v18 = 1;
    uint64_t v17 = a11;
    goto LABEL_64;
  }
  int v32 = (void *)(a11 + 40);
  while (1)
  {
    int v32 = (void *)*v32;
    if (!v32) {
      break;
    }
    if (answer_match((uint64_t)v32, __n, (char *)__s2, a6, a7, a9))
    {
      __int16 v33 = global_os_log;
      char v18 = 0;
      uint64_t v17 = a11;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_65;
      }
      if (a11) {
        LODWORD(v17) = *(_DWORD *)(a11 + 64);
      }
      uint64_t v34 = dns_rrtype_to_string(a6);
      __int16 v35 = dns_qclass_to_string(a7);
      *(_DWORD *)int buf = 136448003;
      int v36 = " more coming";
      uint64_t v63 = "dns_question_callback";
      int v65 = v17;
      __int16 v66 = 2160;
      __int16 v64 = 1024;
      if ((a2 & 1) == 0) {
        int v36 = " done";
      }
      uint64_t v67 = 1752392040;
      __int16 v68 = 2081;
      int v69 = __s2;
      __int16 v70 = 2082;
      __int16 v71 = v34;
      __int16 v72 = 2082;
      uint64_t v73 = v35;
      __int16 v74 = 1024;
      int v75 = __n;
      __int16 v76 = 2082;
      size_t v77 = (size_t)v36;
      _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "%{public}s: [QU%d] duplicate answer in cache - name: %{private, mask.hash}s, rrtype: %{public}s, rrclass: %{public}s, rdlen: %u.%{public}s", buf, 0x4Au);
      char v18 = 0;
      goto LABEL_62;
    }
  }
  uint64_t v37 = malloc_type_calloc(1uLL, __n + 40, 0xA07D32EFuLL);
  if (v37)
  {
    int v38 = v37;
    BOOL v39 = strdup((const char *)__s2);
    v38[1] = v39;
    if (v39)
    {
      *((_DWORD *)v38 + 6) = a3;
      *((_DWORD *)v38 + 7) = a10;
      *((_WORD *)v38 + 16) = a6;
      *((_WORD *)v38 + 17) = a7;
      *((_WORD *)v38 + 18) = __n;
      v38[2] = v38 + 5;
      memcpy(v38 + 5, a9, __n);
      void *v38 = 0;
      do
      {
        BOOL v40 = v19;
        int v19 = (uint64_t *)*v19;
      }
      while (v19);
      *BOOL v40 = (uint64_t)v38;
      uint64_t v17 = a11;
      *(unsigned char *)(a11 + 76) = 0;
      BOOL v41 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v42 = *(_DWORD *)(a11 + 64);
        DNSServiceRef v43 = dns_rrtype_to_string(a6);
        int v44 = dns_qclass_to_string(a7);
        *(_DWORD *)int buf = 136448003;
        uint64_t v45 = " more coming";
        uint64_t v63 = "dns_question_callback";
        int v65 = v42;
        uint64_t v17 = a11;
        __int16 v66 = 2160;
        __int16 v64 = 1024;
        if ((a2 & 1) == 0) {
          uint64_t v45 = " done";
        }
        uint64_t v67 = 1752392040;
        __int16 v68 = 2081;
        int v69 = __s2;
        __int16 v70 = 2082;
        __int16 v71 = v43;
        __int16 v72 = 2082;
        uint64_t v73 = v44;
        __int16 v74 = 1024;
        int v75 = __n;
        __int16 v76 = 2082;
        size_t v77 = (size_t)v45;
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "%{public}s: [QU%d] add answer to cache - name: %{private, mask.hash}s, rrtype: %{public}s, rrclass: %{public}s, rdlen: %u.%{public}s", buf, 0x4Au);
      }
      char v18 = 1;
      goto LABEL_65;
    }
    __int16 v56 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      int v57 = a11;
      if (a11) {
        int v57 = *(_DWORD *)(a11 + 64);
      }
      *(_DWORD *)int buf = 136446979;
      uint64_t v63 = "dns_question_callback";
      __int16 v64 = 1024;
      int v65 = v57;
      __int16 v66 = 2160;
      uint64_t v67 = 1752392040;
      __int16 v68 = 2081;
      int v69 = __s2;
      _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "%{public}s: [QU%d] strdup failed to copy the answer name: %{private, mask.hash}s", buf, 0x26u);
    }
    free(v38);
  }
  else
  {
    int v48 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      if (a11) {
        int v49 = *(_DWORD *)(a11 + 64);
      }
      else {
        int v49 = 0;
      }
      *(_DWORD *)int buf = 136447747;
      uint64_t v63 = "dns_question_callback";
      __int16 v64 = 1024;
      int v65 = v49;
      __int16 v66 = 2160;
      uint64_t v67 = 1752392040;
      __int16 v68 = 2081;
      int v69 = __s2;
      __int16 v70 = 2082;
      __int16 v71 = dns_rrtype_to_string(a6);
      __int16 v72 = 2082;
      uint64_t v73 = dns_qclass_to_string(a7);
      __int16 v74 = 1024;
      int v75 = __n;
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_ERROR, "%{public}s: [QU%d] unable to allocate memory for answer - name: %{private, mask.hash}s, rrtype: %{public}s, rrclass: %{public}s, rdlen: %u.", buf, 0x40u);
    }
  }
}

BOOL answer_match(uint64_t a1, size_t __n, char *__s2, int a4, int a5, void *a6)
{
  return (a5 == 255 || *(unsigned __int16 *)(a1 + 34) == a5)
      && (a4 == 255 || *(unsigned __int16 *)(a1 + 32) == a4)
      && (!__n
       || *(unsigned __int16 *)(a1 + 36) == __n && !memcmp(*(const void **)(a1 + 16), a6, __n))
      && strcmp(*(const char **)(a1 + 8), __s2) == 0;
}

void dns_push_cancel(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  uint64_t v3 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    if (v2) {
      int v4 = *(_DWORD *)(v2 + 4);
    }
    else {
      int v4 = 0;
    }
    uint64_t v5 = *(void *)(v2 + 192);
    if (v5) {
      LODWORD(v5) = *(_DWORD *)(v5 + 64);
    }
    uint64_t v6 = *(void *)(a1 + 32);
    int v11 = 136446978;
    __int16 v12 = "dns_push_cancel";
    __int16 v13 = 1024;
    *(_DWORD *)int v14 = v4;
    *(_WORD *)&v14[4] = 1024;
    *(_DWORD *)&v14[6] = v5;
    *(_WORD *)&v14[10] = 2082;
    *(void *)&v14[12] = v6;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][QU%d] %{public}s", (uint8_t *)&v11, 0x22u);
  }
  if (*(void *)(v2 + 80))
  {
    *(void *)(v2 + 80) = 0;
    *(unsigned char *)(v2 + 200) = 1;
    dp_question_cache_remove_queries(*(void *)(v2 + 192));
    dnssd_query_cancel(v2);
  }
  int v7 = *(_DWORD *)v2;
  if (!*(_DWORD *)v2)
  {
    __int16 v8 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_24;
    }
    int v11 = 136447490;
    __int16 v12 = "dns_push_cancel";
    __int16 v13 = 1024;
    *(_DWORD *)int v14 = 0;
    *(_WORD *)&v14[4] = 2048;
    *(void *)&v14[6] = v2;
    *(_WORD *)&v14[14] = 2080;
    *(void *)&v14[16] = "query";
    *(_WORD *)&v14[24] = 2080;
    *(void *)&v14[26] = "dnssd-proxy.c";
    __int16 v15 = 1024;
    int v16 = 1081;
    __int16 v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_23;
  }
  __int16 v8 = global_os_log;
  if (v7 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_24;
    }
    int v11 = 136447490;
    __int16 v12 = "dns_push_cancel";
    __int16 v13 = 1024;
    *(_DWORD *)int v14 = v7;
    *(_WORD *)&v14[4] = 2048;
    *(void *)&v14[6] = v2;
    *(_WORD *)&v14[14] = 2080;
    *(void *)&v14[16] = "query";
    *(_WORD *)&v14[24] = 2080;
    *(void *)&v14[26] = "dnssd-proxy.c";
    __int16 v15 = 1024;
    int v16 = 1081;
    __int16 v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_23:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v11, 0x36u);
LABEL_24:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = 136447490;
    __int16 v12 = "dns_push_cancel";
    __int16 v13 = 1024;
    *(_DWORD *)int v14 = v7;
    *(_WORD *)&v14[4] = 2048;
    *(void *)&v14[6] = v2;
    *(_WORD *)&v14[14] = 2080;
    *(void *)&v14[16] = "query";
    *(_WORD *)&v14[24] = 2080;
    *(void *)&v14[26] = "dnssd-proxy.c";
    __int16 v15 = 1024;
    int v16 = 1081;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v11, 0x36u);
    int v7 = *(_DWORD *)v2;
  }
  *(_DWORD *)uint64_t v2 = v7 - 1;
  if (v7 == 1)
  {
    size_t v9 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = 136447234;
      __int16 v12 = "dns_push_cancel";
      __int16 v13 = 2048;
      *(void *)int v14 = v2;
      *(_WORD *)&v14[8] = 2080;
      *(void *)&v14[10] = "query";
      *(_WORD *)&v14[18] = 2080;
      *(void *)&v14[20] = "dnssd-proxy.c";
      *(_WORD *)&v14[28] = 1024;
      *(_DWORD *)&v14[30] = 1081;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v11, 0x30u);
    }
    ++dnssd_query_finalized;
    dnssd_query_finalize((void *)v2);
  }
}

void dp_tracker_context_release(void *a1)
{
  if (!a1) {
    return;
  }
  int v2 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    uint64_t v3 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v6 = 136447490;
    int v7 = "dp_tracker_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)size_t v9 = 0;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "tracker";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "dnssd-proxy.c";
    __int16 v10 = 1024;
    int v11 = 832;
    uint64_t v5 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  uint64_t v3 = global_os_log;
  if (v2 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v6 = 136447490;
    int v7 = "dp_tracker_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)size_t v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "tracker";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "dnssd-proxy.c";
    __int16 v10 = 1024;
    int v11 = 832;
    uint64_t v5 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, v5, (uint8_t *)&v6, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 136447490;
    int v7 = "dp_tracker_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)size_t v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "tracker";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "dnssd-proxy.c";
    __int16 v10 = 1024;
    int v11 = 832;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v6, 0x36u);
    int v2 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v2 - 1;
  if (v2 == 1)
  {
    int v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 136447234;
      int v7 = "dp_tracker_context_release";
      __int16 v8 = 2048;
      *(void *)size_t v9 = a1;
      *(_WORD *)&v9[8] = 2080;
      *(void *)&v9[10] = "tracker";
      *(_WORD *)&v9[18] = 2080;
      *(void *)&v9[20] = "dnssd-proxy.c";
      *(_WORD *)&v9[28] = 1024;
      *(_DWORD *)&v9[30] = 832;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v6, 0x30u);
    }
    ++dp_tracker_finalized;
    dp_tracker_finalize(a1);
  }
}

void dp_tracker_idle(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 8);
  if (v1)
  {
    uint64_t v3 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v4 = *(_DWORD *)(a1 + 4);
      uint64_t v5 = *(void *)(a1 + 24);
      if (v5) {
        LODWORD(v5) = *(_DWORD *)(v5 + 48);
      }
      int v6 = *(_DWORD *)(v1 + 180);
      uint64_t v7 = *(void *)(v1 + 192);
      int v8 = 136447491;
      size_t v9 = "dp_tracker_idle";
      __int16 v10 = 1024;
      int v11 = v4;
      __int16 v12 = 1024;
      int v13 = v5;
      __int16 v14 = 1024;
      int v15 = v6;
      __int16 v16 = 2160;
      uint64_t v17 = 1752392040;
      __int16 v18 = 2081;
      uint64_t v19 = v7;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: [TRK%d][DSO%d][C%d] tracker for connection %{private, mask.hash}s has gone idle.", (uint8_t *)&v8, 0x32u);
    }
    *(void *)(a1 + 8) = 0;
    if ((*(_WORD *)(v1 + 416) & 0x100) == 0) {
      ioloop_comm_cancel(v1);
    }
    ioloop_comm_release_(v1, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 867);
  }
}

void dns_proxy_input_for_server(uint64_t a1, uint64_t a2, void *a3)
{
  if ((*(_WORD *)(a1 + 416) & 0x20) != 0)
  {
    size_t v9 = *(char **)(a1 + 192);
  }
  else
  {
    int v6 = *(unsigned __int8 *)(a2 + 5);
    BOOL v7 = v6 == 30 || v6 == 2;
    if (v7)
    {
      if (v6 == 2) {
        int v8 = (const void *)(a2 + 8);
      }
      else {
        int v8 = (const void *)(a2 + 12);
      }
      size_t v9 = __str;
      inet_ntop(v6, v8, __str, 0x2Eu);
    }
    else
    {
      size_t v9 = __str;
      snprintf(__str, 0x2EuLL, "Address type %d", *(unsigned __int8 *)(a2 + 5));
    }
  }
  uint64_t v10 = *(void *)(a1 + 200);
  int v11 = (NSObject **)&dnssd_client_states;
  __int16 v12 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v13 = *(_DWORD *)(a1 + 180);
    if (v10) {
      int v14 = *(_DWORD *)(v10 + 4);
    }
    else {
      int v14 = 0;
    }
    unsigned int v15 = bswap32(*(unsigned __int16 *)(a2 + 88));
    int v16 = *(unsigned __int16 *)(a2 + 64);
    *(_DWORD *)int buf = 136447747;
    *(void *)&uint8_t buf[4] = "dns_proxy_input_for_server";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v13;
    *(_WORD *)&unsigned char buf[18] = 1024;
    *(_DWORD *)&buf[20] = v14;
    *(_WORD *)&unsigned char buf[24] = 1024;
    *(_DWORD *)&buf[26] = HIWORD(v15);
    *(_WORD *)&buf[30] = 2160;
    *(void *)&v225[0] = 1752392040;
    WORD4(v225[0]) = 2081;
    *(void *)((char *)v225 + 10) = v9;
    WORD1(v225[1]) = 1024;
    DWORD1(v225[1]) = v16;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: [C%d][TRK%d][QID %x] Received a new DNS message - src: %{private, mask.hash}s, message length: %u bytes.", buf, 0x38u);
  }
  memset(v225, 0, sizeof(v225));
  memset(buf, 0, sizeof(buf));
  if (a3)
  {
LABEL_18:
    uint64_t v17 = global_os_log;
    BOOL v18 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
    int v19 = *(_DWORD *)a3;
    if (v18)
    {
      *(_DWORD *)int v226 = 136447490;
      uint64_t v227 = "dnssd_proxy_dns_evaluate";
      __int16 v228 = 1024;
      *(_DWORD *)v229 = v19;
      *(_WORD *)&v229[4] = 2048;
      *(void *)&v229[6] = a3;
      *(_WORD *)&v229[14] = 2080;
      *(void *)&v229[16] = "tracker";
      *(_WORD *)&v229[24] = 2080;
      *(void *)&v229[26] = "dnssd-proxy.c";
      __int16 v230 = 1024;
      int v231 = 4032;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v226, 0x36u);
      int v19 = *(_DWORD *)a3;
    }
    if (v19)
    {
      int v20 = v19 + 1;
      *(_DWORD *)a3 = v19 + 1;
      if (v19 + 1 >= 10001)
      {
        char v21 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)int v226 = 136447490;
          uint64_t v227 = "dnssd_proxy_dns_evaluate";
          __int16 v228 = 1024;
          *(_DWORD *)v229 = v20;
          *(_WORD *)&v229[4] = 2048;
          *(void *)&v229[6] = a3;
          *(_WORD *)&v229[14] = 2080;
          *(void *)&v229[16] = "tracker";
          *(_WORD *)&v229[24] = 2080;
          *(void *)&v229[26] = "dnssd-proxy.c";
          __int16 v230 = 1024;
          int v231 = 4032;
          BOOL v22 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
          goto LABEL_316;
        }
        goto LABEL_331;
      }
    }
    else
    {
      ++dp_tracker_created;
      *(_DWORD *)a3 = 1;
    }
    unsigned int v30 = *(unsigned __int16 *)(a2 + 90);
    if ((v30 & 0x80) != 0)
    {
      BOOL v41 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v42 = *((_DWORD *)a3 + 1);
        int v43 = *(_DWORD *)(a1 + 180);
        uint64_t v44 = *(void *)(a1 + 192);
        *(_DWORD *)int v226 = 136447235;
        uint64_t v227 = "dnssd_proxy_dns_evaluate";
        __int16 v228 = 1024;
        *(_DWORD *)v229 = v42;
        *(_WORD *)&v229[4] = 1024;
        *(_DWORD *)&v229[6] = v43;
        *(_WORD *)&v229[10] = 2160;
        *(void *)&v229[12] = 1752392040;
        *(_WORD *)&v229[20] = 2081;
        *(void *)&v229[22] = v44;
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "%{public}s: [TRK%d][C%d] %{private, mask.hash}s: dropping unexpected response", v226, 0x2Cu);
      }
      goto LABEL_46;
    }
    __int16 v31 = (_WORD *)(a2 + 88);
    int v32 = (v30 >> 3) & 0xF;
    int v218 = (unsigned __int16 *)(a2 + 88);
    if (v32)
    {
      if (v32 != 6)
      {
        dso_simple_response(a1, a2, (_WORD *)(a2 + 88), 4);
        goto LABEL_239;
      }
      if ((*(_WORD *)(a1 + 416) & 0x20) == 0)
      {
        __int16 v33 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          int v34 = *((_DWORD *)a3 + 1);
          int v35 = *(_DWORD *)(a1 + 180);
          uint64_t v36 = *(void *)(a1 + 192);
          *(_DWORD *)int v226 = 136447235;
          uint64_t v227 = "dnssd_proxy_dns_evaluate";
          __int16 v228 = 1024;
          *(_DWORD *)v229 = v34;
          *(_WORD *)&v229[4] = 1024;
          *(_DWORD *)&v229[6] = v35;
          *(_WORD *)&v229[10] = 2160;
          *(void *)&v229[12] = 1752392040;
          *(_WORD *)&v229[20] = 2081;
          *(void *)&v229[22] = v36;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "%{public}s: [TRK%d][C%d] %{private, mask.hash}s: DSO message received on non-tcp socket.", v226, 0x2Cu);
        }
        uint64_t v37 = a1;
        uint64_t v38 = a2;
        BOOL v39 = (_WORD *)(a2 + 88);
        int v40 = 4;
        goto LABEL_43;
      }
      if (!a3[3])
      {
        unsigned int v103 = *(const char **)(a1 + 192);
        size_t v104 = strlen(v103);
        size_t v105 = v104;
        if ((v104 + 209) >> 32)
        {
          __int16 v106 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)int v226 = 136446978;
            uint64_t v227 = "dso_state_create";
            __int16 v228 = 2048;
            *(void *)v229 = 168;
            *(_WORD *)&v229[8] = 2048;
            *(void *)&v229[10] = 40;
            *(_WORD *)&v229[18] = 2048;
            *(void *)&v229[20] = v105 + 1;
            _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_FAULT, "%{public}s: Fatal: sizeof (*dso)[%zd], outsize[%zd], namespace[%zd]", v226, 0x2Au);
            __int16 v106 = global_os_log;
          }
          int v11 = (NSObject **)&dnssd_client_states;
          a3[3] = 0;
          if (os_log_type_enabled(v106, OS_LOG_TYPE_ERROR))
          {
            int v107 = *((_DWORD *)a3 + 1);
            int v108 = *(_DWORD *)(a1 + 180);
            uint64_t v109 = *(void *)(a1 + 192);
            *(_DWORD *)int v226 = 136447235;
            uint64_t v227 = "dnssd_proxy_dns_evaluate";
            __int16 v228 = 1024;
            *(_DWORD *)v229 = v107;
            *(_WORD *)&v229[4] = 1024;
            *(_DWORD *)&v229[6] = v108;
            *(_WORD *)&v229[10] = 2160;
            *(void *)&v229[12] = 1752392040;
            *(_WORD *)&v229[20] = 2081;
            *(void *)&v229[22] = v109;
            _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_ERROR, "%{public}s: [TRK%d][C%d] %{private, mask.hash}s: Unable to create a dso context.", v226, 0x2Cu);
          }
          uint64_t v37 = a1;
          uint64_t v38 = a2;
          BOOL v39 = (_WORD *)(a2 + 88);
          int v40 = 2;
          goto LABEL_43;
        }
        if (v104 == -209 || (char v146 = malloc_type_calloc(1uLL, v104 + 209, 0xF1748037uLL)) == 0) {
LABEL_311:
        }
          __break(1u);
        uint64_t v147 = (uint64_t)v146;
        v146[43] = 2;
        size_t v148 = (char *)(v146 + 52);
        *((void *)v146 + 19) = v146 + 52;
        *((void *)v146 + 20) = v146 + 42;
        memcpy(v146 + 52, v103, v105);
        v148[v105] = 0;
        *(void *)(v147 + 24) = dns_push_callback;
        *(void *)(v147 + 32) = a1;
        *(void *)(v147 + 8) = a3;
        *(void *)(v147 + 16) = dp_tracker_dso_state_change;
        *(unsigned char *)(v147 + 52) = 1;
        int v149 = dso_state_create_dso_state_serial++;
        *(_DWORD *)(v147 + 48) = v149;
        *(void *)(v147 + 104) = v147 + 120;
        *(_DWORD *)(v147 + 116) = 2;
        *(void *)(v147 + 60) = 64424513040000;
        *(void *)uint64_t v147 = dso_connections;
        dso_connections = v147;
        int v11 = (NSObject **)&dnssd_client_states;
        uint64_t v150 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int v226 = 136447234;
          uint64_t v227 = "dso_state_create";
          __int16 v228 = 1024;
          *(_DWORD *)v229 = v149;
          *(_WORD *)&v229[4] = 2048;
          *(void *)&v229[6] = v147;
          *(_WORD *)&v229[14] = 2080;
          *(void *)&v229[16] = v103;
          *(_WORD *)&v229[24] = 2048;
          *(void *)&v229[26] = a3;
          _os_log_impl((void *)&_mh_execute_header, v150, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%u] New dso_state_t created - dso: %p, remote name: %s, context: %p", v226, 0x30u);
        }
        a3[3] = v147;
        *(void *)(a1 + 272) = v147;
      }
      uint64_t v151 = a3[4];
      if (v151) {
        ioloop_cancel_wake_event(v151);
      }
      uint64_t v152 = *(void *)(a1 + 272);
      unint64_t v153 = *(unsigned __int16 *)(a2 + 64);
      int v154 = *(char *)(a2 + 90);
      uint64_t v220 = 0;
      uint64_t v221 = 0;
      uint64_t v222 = 0;
      if (v153 <= 0xB)
      {
        uint64_t v155 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int v226 = 136446466;
          uint64_t v227 = "dso_message_received";
          __int16 v228 = 2048;
          *(void *)v229 = v153;
          long long v156 = "%{public}s: dso_message_received: response too short: %ld bytes";
LABEL_204:
          __int16 v157 = v155;
          uint32_t v158 = 22;
          goto LABEL_237;
        }
        goto LABEL_238;
      }
      if (v154 < 0)
      {
        unsigned int v168 = *v218;
        if (!*v218)
        {
          uint64_t v155 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v170 = *(void *)(v152 + 152);
            *(_DWORD *)int v226 = 136446466;
            uint64_t v227 = "dso_message_received";
            __int16 v228 = 2080;
            *(void *)v229 = v170;
            long long v156 = "%{public}s: dso_message_received: response with id==0 received from %s";
            goto LABEL_204;
          }
LABEL_238:
          dso_state_cancel(v152);
          goto LABEL_239;
        }
        if (v153 <= 0xF && v153 != 12)
        {
          uint64_t v161 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v169 = *(void *)(v152 + 152);
            *(_DWORD *)int v226 = 136446722;
            uint64_t v227 = "dso_message_received";
            __int16 v228 = 2048;
            *(void *)v229 = v153;
            *(_WORD *)&v229[8] = 2080;
            *(void *)&v229[10] = v169;
            long long v156 = "%{public}s: dso_message_received: response with bogus length==%ld received from %s";
            goto LABEL_228;
          }
          goto LABEL_238;
        }
        int v171 = *(_DWORD **)(v152 + 160);
        uint64_t v172 = v171[1];
        if ((int)v172 < 1)
        {
LABEL_235:
          uint64_t v175 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v176 = *(void *)(v152 + 152);
            *(_DWORD *)int v226 = 136447234;
            uint64_t v227 = "dso_message_received";
            __int16 v228 = 2080;
            *(void *)v229 = v176;
            *(_WORD *)&v229[8] = 2048;
            *(void *)&v229[10] = v153;
            *(_WORD *)&v229[18] = 1024;
            *(_DWORD *)&v229[20] = v168;
            *(_WORD *)&v229[24] = 1024;
            *(_DWORD *)&v229[26] = v168 >> 8;
            long long v156 = "%{public}s: dso_message_received: fatal: %s sent %ld byte message, QR=1, xid=%02x%02x";
            __int16 v157 = v175;
            uint32_t v158 = 44;
            goto LABEL_237;
          }
          goto LABEL_238;
        }
        uint64_t v173 = 0;
        uint64_t v174 = 2;
        while (LOWORD(v171[v174]) != v168)
        {
          ++v173;
          v174 += 4;
          if (v172 == v173) {
            goto LABEL_235;
          }
        }
        uint64_t v195 = *(void *)&v171[4 * v173 + 4];
        int v196 = *(unsigned char *)(a2 + 91) & 0xF;
        LOWORD(v222) = *(unsigned char *)(a2 + 91) & 0xF;
        uint64_t v220 = v195;
        uint64_t v221 = a2;
        if (!*(unsigned char *)(v152 + 52) && !*(unsigned char *)(v152 + 53) && v196 == 0)
        {
          dso_session_established(v152);
          int v171 = *(_DWORD **)(v152 + 160);
        }
        int v198 = &v171[4 * v173];
        *((_WORD *)v198 + 4) = 0;
        *((void *)v198 + 2) = 0;
        if (--*v171 < 0)
        {
          int v211 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int v226 = 136446210;
            uint64_t v227 = "dso_message_received";
            _os_log_impl((void *)&_mh_execute_header, v211, OS_LOG_TYPE_DEFAULT, "%{public}s: dso_message_receive: programming error: outstanding_query_count went negative.", v226, 0xCu);
          }
          __assert_rtn("dso_message_received", "dso.c", 827, "0");
        }
        if (v153 == 12)
        {
          *(_DWORD *)(v152 + 88) = 0;
          *(_DWORD *)(v152 + 112) = 0;
        }
      }
      uint64_t v159 = 0;
      __int16 v160 = (unsigned char *)(a2 + 93);
      do
      {
        if (*(v160 - 1) || *v160)
        {
          uint64_t v163 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_238;
          }
          uint64_t v164 = *(void *)(v152 + 152);
          unsigned int v165 = "ANCOUNT";
          uint64_t v166 = "ARCOUNT";
          if (v159 == 2) {
            uint64_t v166 = "NSCOUNT";
          }
          *(_DWORD *)int v226 = 136446978;
          uint64_t v227 = "dso_message_received";
          if (v159 != 1) {
            unsigned int v165 = v166;
          }
          __int16 v228 = 2080;
          *(void *)v229 = v164;
          *(_WORD *)&v229[8] = 2048;
          *(void *)&v229[10] = v153;
          if (v159) {
            uint64_t v167 = v165;
          }
          else {
            uint64_t v167 = "QDCOUNT";
          }
          *(_WORD *)&v229[18] = 2080;
          *(void *)&v229[20] = v167;
          long long v156 = "%{public}s: dso_message_received: fatal: %s sent %ld byte DSO message, %s is nonzero";
          __int16 v157 = v163;
          uint32_t v158 = 42;
          goto LABEL_237;
        }
        ++v159;
        v160 += 2;
      }
      while (v159 != 4);
      if (v153 <= 0xF && v153 != 12)
      {
        uint64_t v161 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_238;
        }
        uint64_t v162 = *(void *)(v152 + 152);
        *(_DWORD *)int v226 = 136446722;
        uint64_t v227 = "dso_message_received";
        __int16 v228 = 2080;
        *(void *)v229 = v162;
        *(_WORD *)&v229[8] = 2048;
        *(void *)&v229[10] = v153;
        long long v156 = "%{public}s: dso_message_received: fatal: %s sent short (%ld byte) DSO message";
LABEL_228:
        __int16 v157 = v161;
        uint32_t v158 = 32;
LABEL_237:
        _os_log_impl((void *)&_mh_execute_header, v157, OS_LOG_TYPE_DEFAULT, v156, v226, v158);
        goto LABEL_238;
      }
      if (!*(unsigned char *)(v152 + 53))
      {
        if (!*(unsigned char *)(v152 + 52) || v154 < 0)
        {
          if (v154 < 0 != (*(unsigned char *)(v152 + 52) != 0)) {
            goto LABEL_249;
          }
        }
        else
        {
          dso_session_established(v152);
          if (*(unsigned char *)(v152 + 53) || v154 < 0 != (*(unsigned char *)(v152 + 52) != 0)) {
            goto LABEL_249;
          }
        }
        BOOL v200 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          BOOL v201 = "request";
          uint64_t v227 = "dso_message_received";
          uint64_t v202 = *(void *)(v152 + 152);
          *(_DWORD *)int v226 = 136446722;
          if (v154 < 0) {
            BOOL v201 = "response";
          }
          __int16 v228 = 2080;
          *(void *)v229 = v201;
          *(_WORD *)&v229[8] = 2080;
          *(void *)&v229[10] = v202;
          _os_log_impl((void *)&_mh_execute_header, v200, OS_LOG_TYPE_DEFAULT, "%{public}s: dso_message_received: received a %s with no established session from %s", v226, 0x20u);
        }
        dso_state_cancel(v152);
      }
LABEL_249:
      unsigned int v212 = v154;
      unsigned int v213 = (void *)(v152 + 120);
      char v179 = 1;
      uint64_t v216 = v152;
      while (1)
      {
        if (v153 >= 0xD)
        {
          unsigned int v180 = 0;
          unint64_t v181 = 12;
          while (1)
          {
            unsigned int v182 = __rev16(*(unsigned __int16 *)((char *)v218 + v181));
            uint64_t v183 = __rev16(*(unsigned __int16 *)((char *)v218 + v181 + 2));
            if (v181 + v183 > v153) {
              break;
            }
            if (v179)
            {
              ++v180;
            }
            else if (v181 == 12)
            {
              *(_WORD *)(v152 + 88) = v182;
              *(_WORD *)(v152 + 90) = v183;
              *(void *)(v152 + 96) = a2 + 104;
              *(_DWORD *)(v152 + 112) = 0;
            }
            else
            {
              uint64_t v184 = v152;
              uint64_t v185 = *(unsigned int *)(v152 + 112);
              unsigned int v186 = *(_DWORD *)(v152 + 116);
              if (v185 >= v186)
              {
                log = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v188 = *(void *)(v216 + 152);
                  *(_DWORD *)int v226 = 136447234;
                  uint64_t v227 = "dso_message_received";
                  __int16 v228 = 2080;
                  *(void *)v229 = v188;
                  *(_WORD *)&v229[8] = 1024;
                  *(_DWORD *)&v229[10] = v182;
                  *(_WORD *)&v229[14] = 2048;
                  *(void *)&v229[16] = v183;
                  *(_WORD *)&v229[24] = 1024;
                  *(_DWORD *)&v229[26] = v186;
                  uint64_t v152 = v216;
                  _os_log_impl((void *)&_mh_execute_header, log, OS_LOG_TYPE_DEFAULT, "%{public}s: dso_message_received: %s: ignoring additional TLV (%d %ld) in excess of %d", v226, 0x2Cu);
                }
                else
                {
                  uint64_t v152 = v216;
                }
              }
              else
              {
                uint64_t v187 = *(void *)(v184 + 104) + 16 * v185;
                *(_WORD *)uint64_t v187 = v182;
                *(_WORD *)(v187 + 2) = v183;
                *(void *)(v187 + 8) = (char *)v218 + v181 + 4;
                *(_DWORD *)(v184 + 112) = v185 + 1;
                uint64_t v152 = v184;
              }
            }
            v181 += v183 + 4;
            if (v181 >= v153) {
              goto LABEL_265;
            }
          }
          __int16 v193 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v194 = *(void *)(v152 + 152);
            *(_DWORD *)int v226 = 136447234;
            uint64_t v227 = "dso_message_received";
            __int16 v228 = 2080;
            *(void *)v229 = v194;
            *(_WORD *)&v229[8] = 1024;
            *(_DWORD *)&v229[10] = v182;
            *(_WORD *)&v229[14] = 2048;
            *(void *)&v229[16] = v183;
            *(_WORD *)&v229[24] = 2048;
            *(void *)&v229[26] = v153;
            _os_log_impl((void *)&_mh_execute_header, v193, OS_LOG_TYPE_DEFAULT, "%{public}s: dso_message_received: fatal: %s: TLV (%d %ld) extends past end (%ld)", v226, 0x30u);
          }
          dso_state_cancel(v152);
          int v11 = (NSObject **)&dnssd_client_states;
          goto LABEL_239;
        }
        unsigned int v180 = 0;
LABEL_265:
        if ((v179 & 1) == 0) {
          break;
        }
        char v179 = 0;
        if (v180 > *(_DWORD *)(v152 + 116))
        {
          __int16 v189 = *(void **)(v152 + 104);
          if (v189 != v213 && v189 != 0)
          {
            free(v189);
            *(void *)(v152 + 104) = 0;
          }
          __int16 v191 = malloc_type_calloc(v180, 0x10uLL, 0xF1748037uLL);
          if (!v191) {
            goto LABEL_311;
          }
          char v179 = 0;
          *(void *)(v152 + 104) = v191;
          *(_DWORD *)(v152 + 116) = v180;
        }
      }
      BOOL v203 = *(void (**)(void, uint64_t *, uint64_t, uint64_t))(v152 + 24);
      int v11 = (NSObject **)&dnssd_client_states;
      if (!v203) {
        goto LABEL_239;
      }
      if (v153 != 12)
      {
        int v204 = *(unsigned __int16 *)(v152 + 88);
        if (v204 == 2)
        {
          dso_retry_delay(v152, v218);
          goto LABEL_239;
        }
        if (v204 == 1)
        {
          dso_keepalive(v152, v218, (v212 >> 7) & 1);
          goto LABEL_239;
        }
      }
      if ((v212 & 0x80000000) != 0)
      {
        BOOL v205 = &v220;
        uint64_t v206 = v152;
        uint64_t v207 = 4;
      }
      else
      {
        BOOL v205 = (uint64_t *)a2;
        uint64_t v206 = v152;
        uint64_t v207 = 2;
      }
      v203(*(void *)(v152 + 8), v205, v206, v207);
      goto LABEL_239;
    }
    if (!*(_WORD *)(a2 + 92))
    {
LABEL_143:
      uint64_t v110 = a3[4];
      if (v110) {
        ioloop_cancel_wake_event(v110);
      }
      goto LABEL_239;
    }
    int v45 = 0;
    unsigned int v46 = __rev16(*(unsigned __int16 *)(a2 + 92));
    size_t v215 = (int **)(a3 + 2);
    unsigned int v214 = v46;
    while (1)
    {
      memset(v225, 0, sizeof(v225));
      memset(buf, 0, sizeof(buf));
      if ((dns_rr_parse_() & 1) == 0)
      {
        long long v111 = v11[306];
        if (os_log_type_enabled(v111, OS_LOG_TYPE_ERROR))
        {
          int v112 = *((_DWORD *)a3 + 1);
          if (a1) {
            int v113 = *(_DWORD *)(a1 + 180);
          }
          else {
            int v113 = 0;
          }
          uint64_t v192 = *(void *)(a1 + 192);
          *(_DWORD *)int v226 = 136447235;
          uint64_t v227 = "dnssd_proxy_dns_evaluate";
          __int16 v228 = 1024;
          *(_DWORD *)v229 = v112;
          *(_WORD *)&v229[4] = 1024;
          *(_DWORD *)&v229[6] = v113;
          *(_WORD *)&v229[10] = 2160;
          *(void *)&v229[12] = 1752392040;
          *(_WORD *)&v229[20] = 2081;
          *(void *)&v229[22] = v192;
          _os_log_impl((void *)&_mh_execute_header, v111, OS_LOG_TYPE_ERROR, "%{public}s: [TRK%d][C%d] %{private, mask.hash}s: rr parse failed.", v226, 0x2Cu);
        }
        uint64_t v37 = a1;
        uint64_t v38 = a2;
        BOOL v39 = v31;
        int v40 = 1;
LABEL_43:
        dso_simple_response(v37, v38, v39, v40);
LABEL_46:
        if ((*(_WORD *)(a1 + 416) & 0x20) != 0) {
          ioloop_comm_cancel(a3[1]);
        }
        goto LABEL_239;
      }
      if (dp_num_outstanding_queries >= 256)
      {
        ++num_queries_dropped_for_load;
        dso_simple_response(a3[1], a2, v31, 2);
        uint64_t v114 = v11[306];
        if (os_log_type_enabled(v114, OS_LOG_TYPE_ERROR))
        {
          int v115 = *((_DWORD *)a3 + 1);
          unsigned int v116 = bswap32((unsigned __int16)*v31);
          *(_DWORD *)int v226 = 136446722;
          uint64_t v227 = "dp_dns_query";
          __int16 v228 = 1024;
          *(_DWORD *)v229 = v115;
          *(_WORD *)&v229[4] = 1024;
          *(_DWORD *)&v229[6] = HIWORD(v116);
          _os_log_impl((void *)&_mh_execute_header, v114, OS_LOG_TYPE_ERROR, "%{public}s: [TRK%d][QID %x] dropping query because there are too many", v226, 0x18u);
        }
        goto LABEL_170;
      }
      LODWORD(v220) = 0;
      int v47 = dp_query_create((int *)a3, (uint64_t)buf, a2, 0, &v220);
      if (!v47)
      {
        int v117 = v11[306];
        if (os_log_type_enabled(v117, OS_LOG_TYPE_ERROR))
        {
          int v118 = *((_DWORD *)a3 + 1);
          unsigned int v119 = bswap32((unsigned __int16)*v31);
          *(_DWORD *)int v226 = 136446722;
          uint64_t v227 = "dp_dns_query";
          __int16 v228 = 1024;
          *(_DWORD *)v229 = v118;
          *(_WORD *)&v229[4] = 1024;
          *(_DWORD *)&v229[6] = HIWORD(v119);
          _os_log_impl((void *)&_mh_execute_header, v117, OS_LOG_TYPE_ERROR, "%{public}s: [TRK%d][QID %x] query create failed", v226, 0x18u);
        }
        dso_simple_response(a3[1], a2, v31, v220);
        goto LABEL_170;
      }
      uint64_t v48 = (uint64_t)v47;
      v47[22] = v46;
      uint64_t v49 = *((void *)v47 + 20);
      *(_WORD *)(v49 + 2) &= 0xF0FFu;
      *(_WORD *)(v49 + 4) = 256;
      uint64_t v50 = *((void *)v47 + 24);
      int v51 = (uint64_t *)(v47 + 24);
      size_t v52 = *(char **)(v50 + 32);
      if (*(void *)(v50 + 8))
      {
        dns_name_to_wire_(0, v51, v52, 3917);
        unsigned int v53 = *(_DWORD *)(v48 + 144);
        dns_full_name_to_wire_((_OWORD *)(v48 + 32), (uint64_t)v51, *(char **)(*(void *)(*(void *)(v48 + 192) + 8) + 8), 3920);
        unsigned int v54 = *(_DWORD *)(v48 + 144);
        uint64_t v55 = "enclosing_domain";
        if (v54 <= 1) {
          uint64_t v55 = 0;
        }
        if (v53 >= 2) {
          uint64_t v55 = "name";
        }
      }
      else
      {
        dns_full_name_to_wire_(0, (uint64_t)v51, v52, 3922);
        unsigned int v54 = *(_DWORD *)(v48 + 144);
        uint64_t v55 = "full name";
        if (v54 < 2) {
          uint64_t v55 = 0;
        }
      }
      if (v54 <= 1)
      {
        __int16 v56 = *(uint8_t **)(v48 + 104);
        if ((unint64_t)(v56 + 2) < *(void *)(v48 + 112))
        {
          uint8_t v57 = buf[8];
          uint8_t v58 = buf[9];
          *(void *)(v48 + 104) = v56 + 1;
          *__int16 v56 = v58;
          uint64_t v59 = *(uint8_t **)(v48 + 104);
          *(void *)(v48 + 104) = v59 + 1;
          *uint64_t v59 = v57;
          unsigned int v54 = *(_DWORD *)(v48 + 144);
          if (v55) {
            BOOL v60 = 0;
          }
          else {
            BOOL v60 = v54 > 1;
          }
          if (v60) {
            uint64_t v55 = "TYPE";
          }
          if (v54 <= 1)
          {
            DNSServiceRef v61 = *(uint8_t **)(v48 + 104);
            if ((unint64_t)(v61 + 2) >= *(void *)(v48 + 112))
            {
              unsigned int v54 = 111;
              *(_DWORD *)(v48 + 144) = 111;
              *(_DWORD *)(v48 + 136) = 3925;
            }
            else
            {
              uint8_t v62 = buf[10];
              uint8_t v63 = buf[11];
              *(void *)(v48 + 104) = v61 + 1;
              *DNSServiceRef v61 = v63;
              __int16 v64 = *(uint8_t **)(v48 + 104);
              *(void *)(v48 + 104) = v64 + 1;
              *__int16 v64 = v62;
              unsigned int v54 = *(_DWORD *)(v48 + 144);
            }
          }
          goto LABEL_77;
        }
        unsigned int v54 = 111;
        *(_DWORD *)(v48 + 144) = 111;
        *(_DWORD *)(v48 + 136) = 3924;
      }
      if (v55) {
        BOOL v65 = 0;
      }
      else {
        BOOL v65 = v54 > 1;
      }
      if (v65) {
        uint64_t v55 = "TYPE";
      }
LABEL_77:
      if (v55) {
        BOOL v66 = 0;
      }
      else {
        BOOL v66 = v54 > 1;
      }
      if (v66) {
        uint64_t v67 = "CLASS";
      }
      else {
        uint64_t v67 = v55;
      }
      if (v67)
      {
        uint64_t v120 = v11[306];
        if (os_log_type_enabled(v120, OS_LOG_TYPE_ERROR))
        {
          int v121 = *((_DWORD *)a3 + 1);
          unsigned int v122 = bswap32((unsigned __int16)*v31);
          *(_DWORD *)int v226 = 136446978;
          uint64_t v227 = "dp_dns_query";
          __int16 v228 = 1024;
          *(_DWORD *)v229 = v121;
          *(_WORD *)&v229[4] = 1024;
          *(_DWORD *)&v229[6] = HIWORD(v122);
          *(_WORD *)&v229[10] = 2082;
          *(void *)&v229[12] = v67;
          uint64_t v123 = "%{public}s: [TRK%d][QID %x] failure encoding question: %{public}s";
          int v124 = v120;
          os_log_type_t v125 = OS_LOG_TYPE_ERROR;
          uint32_t v126 = 34;
          goto LABEL_161;
        }
LABEL_162:
        dso_simple_response(a3[1], a2, v31, v220);
        *(unsigned char *)(v48 + 200) = 1;
        dp_question_cache_remove_queries(*(void *)(v48 + 192));
        dnssd_query_cancel(v48);
        int v131 = *(_DWORD *)v48;
        if (!*(_DWORD *)v48)
        {
          uint64_t v209 = v11[306];
          if (!os_log_type_enabled(v209, OS_LOG_TYPE_FAULT)) {
            goto LABEL_331;
          }
          *(_DWORD *)int v226 = 136447490;
          uint64_t v227 = "dp_dns_query";
          __int16 v228 = 1024;
          *(_DWORD *)v229 = 0;
          *(_WORD *)&v229[4] = 2048;
          *(void *)&v229[6] = v48;
          *(_WORD *)&v229[14] = 2080;
          *(void *)&v229[16] = "query";
          *(_WORD *)&v229[24] = 2080;
          *(void *)&v229[26] = "dnssd-proxy.c";
          __int16 v230 = 1024;
          int v231 = 3967;
          BOOL v22 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
          goto LABEL_329;
        }
        BOOL v132 = v11[306];
        if (v131 >= 10001)
        {
          if (!os_log_type_enabled(v132, OS_LOG_TYPE_FAULT)) {
            goto LABEL_331;
          }
          *(_DWORD *)int v226 = 136447490;
          uint64_t v227 = "dp_dns_query";
          __int16 v228 = 1024;
          *(_DWORD *)v229 = v131;
          *(_WORD *)&v229[4] = 2048;
          *(void *)&v229[6] = v48;
          *(_WORD *)&v229[14] = 2080;
          *(void *)&v229[16] = "query";
          *(_WORD *)&v229[24] = 2080;
          *(void *)&v229[26] = "dnssd-proxy.c";
          __int16 v230 = 1024;
          int v231 = 3967;
          BOOL v22 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
          v208 = v132;
          goto LABEL_330;
        }
        if (os_log_type_enabled(v132, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int v226 = 136447490;
          uint64_t v227 = "dp_dns_query";
          __int16 v228 = 1024;
          *(_DWORD *)v229 = v131;
          *(_WORD *)&v229[4] = 2048;
          *(void *)&v229[6] = v48;
          *(_WORD *)&v229[14] = 2080;
          *(void *)&v229[16] = "query";
          *(_WORD *)&v229[24] = 2080;
          *(void *)&v229[26] = "dnssd-proxy.c";
          __int16 v230 = 1024;
          int v231 = 3967;
          _os_log_impl((void *)&_mh_execute_header, v132, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v226, 0x36u);
          int v131 = *(_DWORD *)v48;
        }
        *(_DWORD *)uint64_t v48 = v131 - 1;
        if (v131 == 1)
        {
          __int16 v133 = v11[306];
          if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int v226 = 136447234;
            uint64_t v227 = "dp_dns_query";
            __int16 v228 = 2048;
            *(void *)v229 = v48;
            *(_WORD *)&v229[8] = 2080;
            *(void *)&v229[10] = "query";
            *(_WORD *)&v229[18] = 2080;
            *(void *)&v229[20] = "dnssd-proxy.c";
            *(_WORD *)&v229[28] = 1024;
            *(_DWORD *)&v229[30] = 3967;
            _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v226, 0x30u);
          }
          ++dnssd_query_finalized;
          dnssd_query_finalize((void *)v48);
        }
LABEL_170:
        dns_rrdata_free((uint64_t)buf);
        BOOL v134 = *(void **)buf;
        do
        {
          if (!v134) {
            break;
          }
          BOOL v135 = (void *)*v134;
          free(v134);
          BOOL v134 = v135;
        }
        while (v135);
        __int16 v136 = *v215;
        if (!*v215) {
          goto LABEL_239;
        }
        int v137 = v11;
        uint64_t v138 = 0;
        do
        {
          while (1)
          {
            BOOL v139 = v136;
            __int16 v136 = (int *)*((void *)v136 + 2);
            if (*((void *)v139 + 8) == a2)
            {
              *((unsigned char *)v139 + 200) = 1;
              dp_question_cache_remove_queries(*((void *)v139 + 24));
              if (!v138) {
                break;
              }
            }
            if (!v136) {
              goto LABEL_185;
            }
          }
          uint64_t v140 = v137[306];
          if (os_log_type_enabled(v140, OS_LOG_TYPE_DEFAULT))
          {
            int v141 = *v139;
            *(_DWORD *)int v226 = 136447490;
            uint64_t v227 = "dnssd_proxy_dns_evaluate";
            __int16 v228 = 1024;
            *(_DWORD *)v229 = v141;
            *(_WORD *)&v229[4] = 2048;
            *(void *)&v229[6] = v139;
            *(_WORD *)&v229[14] = 2080;
            *(void *)&v229[16] = "match";
            *(_WORD *)&v229[24] = 2080;
            *(void *)&v229[26] = "dnssd-proxy.c";
            __int16 v230 = 1024;
            int v231 = 4113;
            _os_log_impl((void *)&_mh_execute_header, v140, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v226, 0x36u);
          }
          int v142 = *v139;
          if (!*v139)
          {
            ++dnssd_query_created;
            int v142 = *v139;
          }
          int v143 = v142 + 1;
          *BOOL v139 = v142 + 1;
          if (v142 + 1 >= 10001)
          {
            uint64_t v209 = v137[306];
            if (!os_log_type_enabled(v209, OS_LOG_TYPE_FAULT)) {
              goto LABEL_331;
            }
            *(_DWORD *)int v226 = 136447490;
            uint64_t v227 = "dnssd_proxy_dns_evaluate";
            __int16 v228 = 1024;
            *(_DWORD *)v229 = v143;
            *(_WORD *)&v229[4] = 2048;
            *(void *)&v229[6] = v139;
            *(_WORD *)&v229[14] = 2080;
            *(void *)&v229[16] = "match";
            *(_WORD *)&v229[24] = 2080;
            *(void *)&v229[26] = "dnssd-proxy.c";
            __int16 v230 = 1024;
            int v231 = 4113;
            BOOL v22 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
            goto LABEL_329;
          }
          uint64_t v138 = v139;
        }
        while (v136);
LABEL_185:
        int v11 = v137;
        if (!v138) {
          goto LABEL_239;
        }
        dnssd_query_cancel((uint64_t)v138);
        int v144 = *(_DWORD *)v138;
        if (*(_DWORD *)v138)
        {
          char v21 = v137[306];
          if (v144 < 10001)
          {
            if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)int v226 = 136447490;
              uint64_t v227 = "dnssd_proxy_dns_evaluate";
              __int16 v228 = 1024;
              *(_DWORD *)v229 = v144;
              *(_WORD *)&v229[4] = 2048;
              *(void *)&v229[6] = v138;
              *(_WORD *)&v229[14] = 2080;
              *(void *)&v229[16] = "match";
              *(_WORD *)&v229[24] = 2080;
              *(void *)&v229[26] = "dnssd-proxy.c";
              __int16 v230 = 1024;
              int v231 = 4119;
              _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v226, 0x36u);
              int v144 = *(_DWORD *)v138;
            }
            *(_DWORD *)uint64_t v138 = v144 - 1;
            if (v144 == 1)
            {
              uint64_t v145 = v137[306];
              if (os_log_type_enabled(v145, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)int v226 = 136447234;
                uint64_t v227 = "dnssd_proxy_dns_evaluate";
                __int16 v228 = 2048;
                *(void *)v229 = v138;
                *(_WORD *)&v229[8] = 2080;
                *(void *)&v229[10] = "match";
                *(_WORD *)&v229[18] = 2080;
                *(void *)&v229[20] = "dnssd-proxy.c";
                *(_WORD *)&v229[28] = 1024;
                *(_DWORD *)&v229[30] = 4119;
                _os_log_impl((void *)&_mh_execute_header, v145, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v226, 0x30u);
              }
              ++dnssd_query_finalized;
              dnssd_query_finalize(v138);
            }
LABEL_239:
            int v177 = *(_DWORD *)a3;
            if (*(_DWORD *)a3)
            {
              char v21 = v11[306];
              if (v177 < 10001)
              {
                if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)int v226 = 136447490;
                  uint64_t v227 = "dnssd_proxy_dns_evaluate";
                  __int16 v228 = 1024;
                  *(_DWORD *)v229 = v177;
                  *(_WORD *)&v229[4] = 2048;
                  *(void *)&v229[6] = a3;
                  *(_WORD *)&v229[14] = 2080;
                  *(void *)&v229[16] = "tracker";
                  *(_WORD *)&v229[24] = 2080;
                  *(void *)&v229[26] = "dnssd-proxy.c";
                  __int16 v230 = 1024;
                  int v231 = 4140;
                  _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v226, 0x36u);
                  int v177 = *(_DWORD *)a3;
                }
                *(_DWORD *)a3 = v177 - 1;
                if (v177 == 1)
                {
                  v178 = v11[306];
                  if (os_log_type_enabled(v178, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)int v226 = 136447234;
                    uint64_t v227 = "dnssd_proxy_dns_evaluate";
                    __int16 v228 = 2048;
                    *(void *)v229 = a3;
                    *(_WORD *)&v229[8] = 2080;
                    *(void *)&v229[10] = "tracker";
                    *(_WORD *)&v229[18] = 2080;
                    *(void *)&v229[20] = "dnssd-proxy.c";
                    *(_WORD *)&v229[28] = 1024;
                    *(_DWORD *)&v229[30] = 4140;
                    _os_log_impl((void *)&_mh_execute_header, v178, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v226, 0x30u);
                  }
                  ++dp_tracker_finalized;
                  dp_tracker_finalize(a3);
                }
                return;
              }
              if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)int v226 = 136447490;
                uint64_t v227 = "dnssd_proxy_dns_evaluate";
                __int16 v228 = 1024;
                *(_DWORD *)v229 = v177;
                *(_WORD *)&v229[4] = 2048;
                *(void *)&v229[6] = a3;
                *(_WORD *)&v229[14] = 2080;
                *(void *)&v229[16] = "tracker";
                *(_WORD *)&v229[24] = 2080;
                *(void *)&v229[26] = "dnssd-proxy.c";
                __int16 v230 = 1024;
                int v231 = 4140;
                BOOL v22 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
                goto LABEL_316;
              }
            }
            else
            {
              char v21 = v11[306];
              if (os_log_type_enabled(v21, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)int v226 = 136447490;
                uint64_t v227 = "dnssd_proxy_dns_evaluate";
                __int16 v228 = 1024;
                *(_DWORD *)v229 = 0;
                *(_WORD *)&v229[4] = 2048;
                *(void *)&v229[6] = a3;
                *(_WORD *)&v229[14] = 2080;
                *(void *)&v229[16] = "tracker";
                *(_WORD *)&v229[24] = 2080;
                *(void *)&v229[26] = "dnssd-proxy.c";
                __int16 v230 = 1024;
                int v231 = 4140;
                BOOL v22 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
                goto LABEL_316;
              }
            }
LABEL_331:
            abort();
          }
          if (!os_log_type_enabled(v21, OS_LOG_TYPE_FAULT)) {
            goto LABEL_331;
          }
          *(_DWORD *)int v226 = 136447490;
          uint64_t v227 = "dnssd_proxy_dns_evaluate";
          __int16 v228 = 1024;
          *(_DWORD *)v229 = v144;
          *(_WORD *)&v229[4] = 2048;
          *(void *)&v229[6] = v138;
          *(_WORD *)&v229[14] = 2080;
          *(void *)&v229[16] = "match";
          *(_WORD *)&v229[24] = 2080;
          *(void *)&v229[26] = "dnssd-proxy.c";
          __int16 v230 = 1024;
          int v231 = 4119;
          BOOL v22 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_316:
          v208 = v21;
LABEL_330:
          _os_log_impl((void *)&_mh_execute_header, v208, OS_LOG_TYPE_FAULT, v22, v226, 0x36u);
          goto LABEL_331;
        }
        uint64_t v209 = v137[306];
        if (!os_log_type_enabled(v209, OS_LOG_TYPE_FAULT)) {
          goto LABEL_331;
        }
        *(_DWORD *)int v226 = 136447490;
        uint64_t v227 = "dnssd_proxy_dns_evaluate";
        __int16 v228 = 1024;
        *(_DWORD *)v229 = 0;
        *(_WORD *)&v229[4] = 2048;
        *(void *)&v229[6] = v138;
        *(_WORD *)&v229[14] = 2080;
        *(void *)&v229[16] = "match";
        *(_WORD *)&v229[24] = 2080;
        *(void *)&v229[26] = "dnssd-proxy.c";
        __int16 v230 = 1024;
        int v231 = 4119;
        BOOL v22 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_329:
        v208 = v209;
        goto LABEL_330;
      }
      **(_WORD **)(v48 + 96) = *v31;
      *(unsigned char *)(v48 + 92) = 1;
      __int16 v68 = a3 + 2;
      int v69 = *v215;
      if (*v215)
      {
        while (v69 != (int *)v48)
        {
          __int16 v70 = v69;
          int v69 = (int *)*((void *)v69 + 2);
          if (!v69)
          {
            __int16 v68 = (uint64_t *)(v70 + 4);
            goto LABEL_88;
          }
        }
        int v75 = v11[306];
        if (os_log_type_enabled(v75, OS_LOG_TYPE_ERROR))
        {
          uint64_t v76 = *(void *)(v48 + 8);
          if (v76) {
            LODWORD(v76) = *(_DWORD *)(v76 + 4);
          }
          int v77 = *(_DWORD *)(v48 + 4);
          *(_DWORD *)int v226 = 136446722;
          uint64_t v227 = "dp_query_track";
          __int16 v228 = 1024;
          *(_DWORD *)v229 = v77;
          *(_WORD *)&v229[4] = 1024;
          *(_DWORD *)&v229[6] = v76;
          _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_ERROR, "%{public}s: [Q%d][TRK%d] query is already being tracked.", v226, 0x18u);
        }
      }
      else
      {
LABEL_88:
        *__int16 v68 = v48;
        __int16 v71 = v11[306];
        if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
        {
          int v72 = *(_DWORD *)v48;
          *(_DWORD *)int v226 = 136447490;
          uint64_t v227 = "dp_query_track";
          __int16 v228 = 1024;
          *(_DWORD *)v229 = v72;
          *(_WORD *)&v229[4] = 2048;
          *(void *)&v229[6] = v48;
          *(_WORD *)&v229[14] = 2080;
          *(void *)&v229[16] = "query";
          *(_WORD *)&v229[24] = 2080;
          *(void *)&v229[26] = "dnssd-proxy.c";
          __int16 v230 = 1024;
          int v231 = 1017;
          _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v226, 0x36u);
        }
        int v73 = *(_DWORD *)v48;
        if (*(_DWORD *)v48)
        {
          int v74 = v73 + 1;
          *(_DWORD *)uint64_t v48 = v73 + 1;
          if (v73 + 1 >= 10001)
          {
            uint64_t v209 = v11[306];
            if (!os_log_type_enabled(v209, OS_LOG_TYPE_FAULT)) {
              goto LABEL_331;
            }
            *(_DWORD *)int v226 = 136447490;
            uint64_t v227 = "dp_query_track";
            __int16 v228 = 1024;
            *(_DWORD *)v229 = v74;
            *(_WORD *)&v229[4] = 2048;
            *(void *)&v229[6] = v48;
            *(_WORD *)&v229[14] = 2080;
            *(void *)&v229[16] = "query";
            *(_WORD *)&v229[24] = 2080;
            *(void *)&v229[26] = "dnssd-proxy.c";
            __int16 v230 = 1024;
            int v231 = 1017;
            BOOL v22 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
            goto LABEL_329;
          }
        }
        else
        {
          ++dnssd_query_created;
          *(_DWORD *)uint64_t v48 = 1;
        }
      }
      char v219 = 0;
      if (!dp_query_start(v48, &v220, &v219))
      {
        uint64_t v127 = v11[306];
        if (os_log_type_enabled(v127, OS_LOG_TYPE_DEFAULT))
        {
          int v128 = *(_DWORD *)(v48 + 4);
          int v129 = *((_DWORD *)a3 + 1);
          unsigned int v130 = bswap32((unsigned __int16)*v31);
          *(_DWORD *)int v226 = 136446978;
          uint64_t v227 = "dp_dns_query";
          __int16 v228 = 1024;
          *(_DWORD *)v229 = v128;
          *(_WORD *)&v229[4] = 1024;
          *(_DWORD *)&v229[6] = v129;
          *(_WORD *)&v229[10] = 1024;
          *(_DWORD *)&v229[12] = HIWORD(v130);
          uint64_t v123 = "%{public}s: [Q%d][TRK%d][QID %x] query start failed";
          int v124 = v127;
          os_log_type_t v125 = OS_LOG_TYPE_DEFAULT;
          uint32_t v126 = 30;
LABEL_161:
          _os_log_impl((void *)&_mh_execute_header, v124, v125, v123, v226, v126);
        }
        goto LABEL_162;
      }
      if (v219)
      {
        int v78 = v11[306];
        if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
        {
          int v79 = *(_DWORD *)(v48 + 4);
          int v80 = *((_DWORD *)a3 + 1);
          *(_DWORD *)int v226 = 136446722;
          uint64_t v227 = "dp_dns_query";
          __int16 v228 = 1024;
          *(_DWORD *)v229 = v79;
          *(_WORD *)&v229[4] = 1024;
          *(_DWORD *)&v229[6] = v80;
          _os_log_impl((void *)&_mh_execute_header, v78, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][TRK%d] hardwired reply", v226, 0x18u);
        }
        dp_query_send_dns_response(v48, (uint64_t)"hardwired");
        dp_question_cache_remove_queries(*(void *)(v48 + 192));
        uint64_t v81 = *(void *)(v48 + 192);
        if (v81)
        {
          int v82 = *(_DWORD *)(v81 + 60);
          if (!v82)
          {
            uint64_t v209 = v11[306];
            if (!os_log_type_enabled(v209, OS_LOG_TYPE_FAULT)) {
              goto LABEL_331;
            }
            *(_DWORD *)int v226 = 136447490;
            uint64_t v227 = "dp_dns_query";
            __int16 v228 = 1024;
            *(_DWORD *)v229 = 0;
            *(_WORD *)&v229[4] = 2048;
            *(void *)&v229[6] = v81;
            *(_WORD *)&v229[14] = 2080;
            *(void *)&v229[16] = "query->question";
            *(_WORD *)&v229[24] = 2080;
            *(void *)&v229[26] = "dnssd-proxy.c";
            __int16 v230 = 1024;
            int v231 = 3951;
            BOOL v22 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
            goto LABEL_329;
          }
          uint64_t v83 = v11;
          int v84 = v11[306];
          if (v82 >= 10001)
          {
            if (!os_log_type_enabled(v84, OS_LOG_TYPE_FAULT)) {
              goto LABEL_331;
            }
            *(_DWORD *)int v226 = 136447490;
            uint64_t v227 = "dp_dns_query";
            __int16 v228 = 1024;
            *(_DWORD *)v229 = v82;
            *(_WORD *)&v229[4] = 2048;
            *(void *)&v229[6] = v81;
            *(_WORD *)&v229[14] = 2080;
            *(void *)&v229[16] = "query->question";
            *(_WORD *)&v229[24] = 2080;
            *(void *)&v229[26] = "dnssd-proxy.c";
            __int16 v230 = 1024;
            int v231 = 3951;
            BOOL v22 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
            v208 = v84;
            goto LABEL_330;
          }
          if (os_log_type_enabled(v84, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int v226 = 136447490;
            uint64_t v227 = "dp_dns_query";
            __int16 v228 = 1024;
            *(_DWORD *)v229 = v82;
            *(_WORD *)&v229[4] = 2048;
            *(void *)&v229[6] = v81;
            *(_WORD *)&v229[14] = 2080;
            *(void *)&v229[16] = "query->question";
            *(_WORD *)&v229[24] = 2080;
            *(void *)&v229[26] = "dnssd-proxy.c";
            __int16 v230 = 1024;
            int v231 = 3951;
            _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v226, 0x36u);
            uint64_t v81 = *(void *)(v48 + 192);
            int v82 = *(_DWORD *)(v81 + 60);
          }
          int v11 = v83;
          *(_DWORD *)(v81 + 60) = v82 - 1;
          if (v82 == 1)
          {
            int v85 = v83[306];
            if (os_log_type_enabled(v85, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)int v226 = 136447234;
              uint64_t v227 = "dp_dns_query";
              __int16 v228 = 2048;
              *(void *)v229 = v81;
              *(_WORD *)&v229[8] = 2080;
              *(void *)&v229[10] = "query->question";
              *(_WORD *)&v229[18] = 2080;
              *(void *)&v229[20] = "dnssd-proxy.c";
              *(_WORD *)&v229[28] = 1024;
              *(_DWORD *)&v229[30] = 3951;
              _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v226, 0x30u);
              uint64_t v81 = *(void *)(v48 + 192);
            }
            ++question_finalized;
            question_finalize(v81);
            int v11 = v83;
          }
        }
        *(void *)(v48 + 192) = 0;
      }
      else
      {
        BOOL v86 = v11;
        uint64_t v87 = *(void *)(v48 + 192);
        int v88 = v86;
        int v89 = v86[306];
        BOOL v90 = os_log_type_enabled(v89, OS_LOG_TYPE_DEFAULT);
        if (v87)
        {
          if (v90)
          {
            int v91 = *(_DWORD *)(v48 + 4);
            int v92 = *((_DWORD *)a3 + 1);
            *(_DWORD *)int v226 = 136446722;
            uint64_t v227 = "dp_dns_query";
            __int16 v228 = 1024;
            *(_DWORD *)v229 = v91;
            *(_WORD *)&v229[4] = 1024;
            *(_DWORD *)&v229[6] = v92;
            _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][TRK%d] replying from cache", v226, 0x18u);
            uint64_t v87 = *(void *)(v48 + 192);
          }
          dp_query_reply_from_cache(v87, v48, 0);
          dp_question_cache_remove_queries(*(void *)(v48 + 192));
          int v11 = v88;
        }
        else
        {
          int v11 = v88;
          if (v90)
          {
            int v93 = *(_DWORD *)(v48 + 4);
            int v94 = *((_DWORD *)a3 + 1);
            *(_DWORD *)int v226 = 136446722;
            uint64_t v227 = "dp_dns_query";
            __int16 v228 = 1024;
            *(_DWORD *)v229 = v93;
            *(_WORD *)&v229[4] = 1024;
            *(_DWORD *)&v229[6] = v94;
            _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_DEFAULT, "%{public}s: [Q%d][TRK%d] not replying from cache", v226, 0x18u);
          }
        }
      }
      int v95 = *(_DWORD *)v48;
      if (!*(_DWORD *)v48)
      {
        uint64_t v209 = v11[306];
        if (!os_log_type_enabled(v209, OS_LOG_TYPE_FAULT)) {
          goto LABEL_331;
        }
        *(_DWORD *)int v226 = 136447490;
        uint64_t v227 = "dp_dns_query";
        __int16 v228 = 1024;
        *(_DWORD *)v229 = 0;
        *(_WORD *)&v229[4] = 2048;
        *(void *)&v229[6] = v48;
        *(_WORD *)&v229[14] = 2080;
        *(void *)&v229[16] = "query";
        *(_WORD *)&v229[24] = 2080;
        *(void *)&v229[26] = "dnssd-proxy.c";
        __int16 v230 = 1024;
        int v231 = 3971;
        BOOL v22 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_329;
      }
      uint64_t v96 = v11[306];
      if (v95 >= 10001)
      {
        if (!os_log_type_enabled(v96, OS_LOG_TYPE_FAULT)) {
          goto LABEL_331;
        }
        *(_DWORD *)int v226 = 136447490;
        uint64_t v227 = "dp_dns_query";
        __int16 v228 = 1024;
        *(_DWORD *)v229 = v95;
        *(_WORD *)&v229[4] = 2048;
        *(void *)&v229[6] = v48;
        *(_WORD *)&v229[14] = 2080;
        *(void *)&v229[16] = "query";
        *(_WORD *)&v229[24] = 2080;
        *(void *)&v229[26] = "dnssd-proxy.c";
        __int16 v230 = 1024;
        int v231 = 3971;
        BOOL v22 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        v208 = v96;
        goto LABEL_330;
      }
      __int16 v31 = (_WORD *)(a2 + 88);
      if (os_log_type_enabled(v96, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int v226 = 136447490;
        uint64_t v227 = "dp_dns_query";
        __int16 v228 = 1024;
        *(_DWORD *)v229 = v95;
        *(_WORD *)&v229[4] = 2048;
        *(void *)&v229[6] = v48;
        *(_WORD *)&v229[14] = 2080;
        *(void *)&v229[16] = "query";
        *(_WORD *)&v229[24] = 2080;
        *(void *)&v229[26] = "dnssd-proxy.c";
        __int16 v230 = 1024;
        int v231 = 3971;
        _os_log_impl((void *)&_mh_execute_header, v96, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v226, 0x36u);
        int v95 = *(_DWORD *)v48;
      }
      BOOL v7 = v95 == 1;
      *(_DWORD *)uint64_t v48 = v95 - 1;
      unsigned int v46 = v214;
      if (v7)
      {
        uint64_t v97 = v11[306];
        if (os_log_type_enabled(v97, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int v226 = 136447234;
          uint64_t v227 = "dp_dns_query";
          __int16 v228 = 2048;
          *(void *)v229 = v48;
          *(_WORD *)&v229[8] = 2080;
          *(void *)&v229[10] = "query";
          *(_WORD *)&v229[18] = 2080;
          *(void *)&v229[20] = "dnssd-proxy.c";
          *(_WORD *)&v229[28] = 1024;
          *(_DWORD *)&v229[30] = 3971;
          _os_log_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v226, 0x30u);
        }
        ++dnssd_query_finalized;
        dnssd_query_finalize((void *)v48);
      }
      dns_rrdata_free((uint64_t)buf);
      __int16 v98 = *(void **)buf;
      do
      {
        if (!v98) {
          break;
        }
        uint64_t v99 = (void *)*v98;
        free(v98);
        __int16 v98 = v99;
      }
      while (v99);
      if (++v45 == v214) {
        goto LABEL_143;
      }
    }
  }
  uint64_t v23 = malloc_type_calloc(1uLL, 0x30uLL, 0x102004009C3B402uLL);
  if (v23)
  {
    a3 = v23;
    v23[1] = a1;
    *((_DWORD *)v23 + 1) = ++cur_tracker_serial;
    ioloop_comm_retain_(a1, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 4023);
    __int16 v24 = *(_WORD *)(a1 + 416);
    if ((v24 & 0x20) != 0)
    {
      if (*(void *)(a1 + 200))
      {
        int v25 = *(void (**)(void))(a1 + 240);
        if (v25) {
          v25();
        }
      }
      *(void *)(a1 + 240) = dp_tracker_context_release;
      *(void *)(a1 + 200) = a3;
      int v26 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v27 = *(_DWORD *)a3;
        *(_DWORD *)int v226 = 136447490;
        uint64_t v227 = "dnssd_proxy_dns_evaluate";
        __int16 v228 = 1024;
        *(_DWORD *)v229 = v27;
        *(_WORD *)&v229[4] = 2048;
        *(void *)&v229[6] = a3;
        *(_WORD *)&v229[14] = 2080;
        *(void *)&v229[16] = "tracker";
        *(_WORD *)&v229[24] = 2080;
        *(void *)&v229[26] = "dnssd-proxy.c";
        __int16 v230 = 1024;
        int v231 = 4026;
        _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v226, 0x36u);
      }
      int v28 = *(_DWORD *)a3;
      if (*(_DWORD *)a3)
      {
        int v29 = v28 + 1;
        *(_DWORD *)a3 = v28 + 1;
        if (v28 + 1 > 10000)
        {
          char v21 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)int v226 = 136447490;
            uint64_t v227 = "dnssd_proxy_dns_evaluate";
            __int16 v228 = 1024;
            *(_DWORD *)v229 = v29;
            *(_WORD *)&v229[4] = 2048;
            *(void *)&v229[6] = a3;
            *(_WORD *)&v229[14] = 2080;
            *(void *)&v229[16] = "tracker";
            *(_WORD *)&v229[24] = 2080;
            *(void *)&v229[26] = "dnssd-proxy.c";
            __int16 v230 = 1024;
            int v231 = 4026;
            BOOL v22 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
            goto LABEL_316;
          }
          goto LABEL_331;
        }
      }
      else
      {
        ++dp_tracker_created;
        *(_DWORD *)a3 = 1;
      }
      __int16 v24 = *(_WORD *)(a1 + 416);
    }
    if ((v24 & 0x100) == 0) {
      *(void *)(a1 + 232) = dp_tracker_disconnected;
    }
    goto LABEL_18;
  }
  int v100 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    int v101 = *(_DWORD *)(a1 + 180);
    uint64_t v102 = *(void *)(a1 + 192);
    *(_DWORD *)int v226 = 136446979;
    uint64_t v227 = "dnssd_proxy_dns_evaluate";
    __int16 v228 = 1024;
    *(_DWORD *)v229 = v101;
    *(_WORD *)&v229[4] = 2160;
    *(void *)&v229[6] = 1752392040;
    *(_WORD *)&v229[14] = 2081;
    *(void *)&v229[16] = v102;
    _os_log_impl((void *)&_mh_execute_header, v100, OS_LOG_TYPE_ERROR, "%{public}s: [C%d] %{private, mask.hash}s: no memory for a connection tracker object!", v226, 0x26u);
  }
}

BOOL dp_tracker_dso_state_change(int a1, void *a2, uint64_t a3)
{
  if (a1 == 1)
  {
    if (a2[3])
    {
      a2[3] = 0;
      uint64_t v6 = a2[1];
      if (v6)
      {
        *(void *)(v6 + 272) = 0;
        ioloop_comm_cancel(v6);
      }
      for (uint64_t i = (void *)a2[2]; i; uint64_t i = (void *)i[2])
      {
        if (i[9] == a3) {
          i[9] = 0;
        }
        if (i[10])
        {
          i[10] = 0;
          int v8 = *(_DWORD *)i;
          if (!*(_DWORD *)i)
          {
            uint64_t v12 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)int buf = 136447490;
              *(void *)&uint8_t buf[4] = "dp_tracker_dso_state_change";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = 0;
              *(_WORD *)&unsigned char buf[18] = 2048;
              *(void *)&buf[20] = i;
              *(_WORD *)&buf[28] = 2080;
              *(void *)&buf[30] = "query";
              *(_WORD *)&unsigned char buf[38] = 2080;
              *(void *)&buf[40] = "dnssd-proxy.c";
              LOWORD(v16) = 1024;
              *(_DWORD *)((char *)&v16 + 2) = 3999;
              int v13 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
              int v14 = v12;
              goto LABEL_24;
            }
LABEL_25:
            abort();
          }
          size_t v9 = global_os_log;
          if (v8 >= 10001)
          {
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)int buf = 136447490;
              *(void *)&uint8_t buf[4] = "dp_tracker_dso_state_change";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v8;
              *(_WORD *)&unsigned char buf[18] = 2048;
              *(void *)&buf[20] = i;
              *(_WORD *)&buf[28] = 2080;
              *(void *)&buf[30] = "query";
              *(_WORD *)&unsigned char buf[38] = 2080;
              *(void *)&buf[40] = "dnssd-proxy.c";
              LOWORD(v16) = 1024;
              *(_DWORD *)((char *)&v16 + 2) = 3999;
              int v13 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
              int v14 = v9;
LABEL_24:
              _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_FAULT, v13, buf, 0x36u);
            }
            goto LABEL_25;
          }
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "dp_tracker_dso_state_change";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v8;
            *(_WORD *)&unsigned char buf[18] = 2048;
            *(void *)&buf[20] = i;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = "query";
            *(_WORD *)&unsigned char buf[38] = 2080;
            *(void *)&buf[40] = "dnssd-proxy.c";
            LOWORD(v16) = 1024;
            *(_DWORD *)((char *)&v16 + 2) = 3999;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            int v8 = *(_DWORD *)i;
          }
          *(_DWORD *)uint64_t i = v8 - 1;
          if (v8 == 1)
          {
            uint64_t v10 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)int buf = 136447234;
              *(void *)&uint8_t buf[4] = "dp_tracker_dso_state_change";
              *(_WORD *)&unsigned char buf[12] = 2048;
              *(void *)&buf[14] = i;
              *(_WORD *)&buf[22] = 2080;
              *(void *)&unsigned char buf[24] = "query";
              *(_WORD *)&uint8_t buf[32] = 2080;
              *(void *)&buf[34] = "dnssd-proxy.c";
              *(_WORD *)&buf[42] = 1024;
              *(_DWORD *)&buf[44] = 3999;
              _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
            }
            ++dnssd_query_finalized;
            dnssd_query_finalize(i);
          }
        }
      }
    }
    *(void *)int buf = _NSConcreteStackBlock;
    *(void *)&buf[8] = 0x40000000;
    *(void *)&buf[16] = __ioloop_run_async_block_invoke;
    *(void *)&unsigned char buf[24] = &__block_descriptor_tmp_41;
    *(void *)&buf[40] = 0;
    uint64_t v16 = 0;
    *(void *)&uint8_t buf[32] = dp_tracker_dso_cleanup;
    dispatch_async((dispatch_queue_t)ioloop_main_queue, buf);
  }
  return a1 == 1;
}

void dp_tracker_dso_cleanup()
{
  uint64_t v0 = (void *)dso_connections_needing_cleanup;
  if (dso_connections_needing_cleanup)
  {
    do
    {
      uint64_t v1 = v0;
      uint64_t v0 = (void *)*v0;
      int v2 = (void *)v1[10];
      if (v2)
      {
        do
        {
          int v4 = (void *)*v2;
          uint64_t v3 = (void (*)(void *))v2[1];
          if (v3) {
            v3(v2);
          }
          free(v2);
          int v2 = v4;
        }
        while (v4);
      }
      if (v1[4])
      {
        uint64_t v5 = (void (*)(void))v1[5];
        if (v5)
        {
          v5();
          v1[4] = 0;
        }
      }
      uint64_t v6 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v7 = *((_DWORD *)v1 + 12);
        uint64_t v8 = v1[19];
        uint64_t v9 = v1[1];
        *(_DWORD *)int buf = 136447234;
        uint64_t v12 = "dso_cleanup";
        __int16 v13 = 1024;
        int v14 = v7;
        __int16 v15 = 2048;
        uint64_t v16 = v1;
        __int16 v17 = 2080;
        uint64_t v18 = v8;
        __int16 v19 = 2048;
        uint64_t v20 = v9;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: [DSO%u] dso_state_t finalizing - dso: %p, remote name: %s, dso->context: %p", buf, 0x30u);
      }
      uint64_t v10 = (void *)v1[13];
      if (v10 != v1 + 15 && v10) {
        free(v10);
      }
      free(v1);
    }
    while (v0);
  }
  dso_connections_needing_cleanup = 0;
}

void dp_tracker_disconnected(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a2 + 8);
  uint64_t v5 = *(void **)(a2 + 16);
  int v4 = (uint64_t *)(a2 + 8);
  *(void *)(a2 + 8) = 0;
  *(void *)(a2 + 16) = 0;
  uint64_t v6 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v7 = *(void *)(a2 + 24);
    if (v7) {
      LODWORD(v7) = *(_DWORD *)(v7 + 48);
    }
    int v8 = *(_DWORD *)(a2 + 4);
    if (v3) {
      int v9 = *(_DWORD *)(v3 + 180);
    }
    else {
      int v9 = 0;
    }
    *(_DWORD *)int buf = 136447234;
    int v26 = "dp_tracker_disconnected";
    __int16 v27 = 1024;
    *(_DWORD *)int v28 = v8;
    *(_WORD *)&v28[4] = 1024;
    *(_DWORD *)&v28[6] = v7;
    *(_WORD *)&v28[10] = 1024;
    *(_DWORD *)&v28[12] = v9;
    *(_WORD *)&v28[16] = 2048;
    *(void *)&v28[18] = v5;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: [TRK%d][DSO%d][C%d] queries %p", buf, 0x28u);
  }
  uint64_t v10 = *(void *)(a2 + 24);
  if (v10)
  {
    int v11 = *(void **)(v10 + 80);
    do
    {
      if (!v11) {
        break;
      }
      dso_drop_activity(v10, v11);
      uint64_t v10 = *(void *)(a2 + 24);
      BOOL v12 = *(void *)(v10 + 80) == (void)v11;
      int v11 = *(void **)(v10 + 80);
    }
    while (!v12);
    dso_state_cancel(v10);
    if (*(_DWORD *)(a2 + 40) == 1)
    {
      __int16 v13 = global_os_log;
      int v14 = --num_push_sessions;
      if (num_push_sessions < 0)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)int buf = 136446210;
          int v26 = "dp_tracker_went_away";
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_FAULT, "%{public}s: DNS Push connection count went negative", buf, 0xCu);
        }
        num_push_sessions = 0;
      }
      else if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v15 = *(void *)(a2 + 24);
        if (v15) {
          LODWORD(v15) = *(_DWORD *)(v15 + 48);
        }
        int v16 = *(_DWORD *)(a2 + 4);
        uint64_t v17 = *v4;
        if (*v4) {
          LODWORD(v17) = *(_DWORD *)(v17 + 180);
        }
        *(_DWORD *)int buf = 136447234;
        int v26 = "dp_tracker_went_away";
        __int16 v27 = 1024;
        *(_DWORD *)int v28 = v16;
        *(_WORD *)&v28[4] = 1024;
        *(_DWORD *)&v28[6] = v15;
        *(_WORD *)&v28[10] = 1024;
        *(_DWORD *)&v28[12] = v17;
        *(_WORD *)&v28[16] = 1024;
        *(_DWORD *)&v28[18] = v14;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: [TRK%d][DSO%d][C%d] dso connection count dropped: %d", buf, 0x24u);
      }
    }
    *(_DWORD *)(a2 + 40) = 0;
    *(void *)(a2 + 24) = 0;
  }
  if (v3)
  {
    ioloop_comm_release_(v3, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 1051);
    uint64_t *v4 = 0;
  }
  if (v5)
  {
    while (1)
    {
      int v18 = *(_DWORD *)v5;
      if (!*(_DWORD *)v5) {
        break;
      }
      __int16 v19 = global_os_log;
      if (v18 >= 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)int buf = 136447490;
          int v26 = "dp_tracker_disconnected";
          __int16 v27 = 1024;
          *(_DWORD *)int v28 = v18;
          *(_WORD *)&v28[4] = 2048;
          *(void *)&v28[6] = v5;
          *(_WORD *)&v28[14] = 2080;
          *(void *)&v28[16] = "query";
          *(_WORD *)&v28[24] = 2080;
          *(void *)&v28[26] = "dnssd-proxy.c";
          __int16 v29 = 1024;
          int v30 = 1061;
          uint64_t v23 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
          __int16 v24 = v19;
LABEL_42:
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_FAULT, v23, buf, 0x36u);
        }
        goto LABEL_43;
      }
      uint64_t v20 = (void *)v5[2];
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136447490;
        int v26 = "dp_tracker_disconnected";
        __int16 v27 = 1024;
        *(_DWORD *)int v28 = v18;
        *(_WORD *)&v28[4] = 2048;
        *(void *)&v28[6] = v5;
        *(_WORD *)&v28[14] = 2080;
        *(void *)&v28[16] = "query";
        *(_WORD *)&v28[24] = 2080;
        *(void *)&v28[26] = "dnssd-proxy.c";
        __int16 v29 = 1024;
        int v30 = 1061;
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        int v18 = *(_DWORD *)v5;
      }
      *(_DWORD *)uint64_t v5 = v18 - 1;
      if (v18 == 1)
      {
        char v21 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447234;
          int v26 = "dp_tracker_disconnected";
          __int16 v27 = 2048;
          *(void *)int v28 = v5;
          *(_WORD *)&v28[8] = 2080;
          *(void *)&v28[10] = "query";
          *(_WORD *)&v28[18] = 2080;
          *(void *)&v28[20] = "dnssd-proxy.c";
          *(_WORD *)&v28[28] = 1024;
          *(_DWORD *)&v28[30] = 1061;
          _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        }
        ++dnssd_query_finalized;
        dnssd_query_finalize(v5);
      }
      uint64_t v5 = v20;
      if (!v20) {
        return;
      }
    }
    uint64_t v22 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)int buf = 136447490;
      int v26 = "dp_tracker_disconnected";
      __int16 v27 = 1024;
      *(_DWORD *)int v28 = 0;
      *(_WORD *)&v28[4] = 2048;
      *(void *)&v28[6] = v5;
      *(_WORD *)&v28[14] = 2080;
      *(void *)&v28[16] = "query";
      *(_WORD *)&v28[24] = 2080;
      *(void *)&v28[26] = "dnssd-proxy.c";
      __int16 v29 = 1024;
      int v30 = 1061;
      uint64_t v23 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      __int16 v24 = v22;
      goto LABEL_42;
    }
LABEL_43:
    abort();
  }
}

void *add_new_served_domain_with_interface(char *__s2)
{
  int v2 = strcmp("local only pseudo interface", __s2);
  if (v2 && !strcmp("all locally-discoverable services pseudo interface", __s2))
  {
    BOOL v4 = 0;
    int v3 = 1;
  }
  else
  {
    int v3 = 0;
    BOOL v4 = strcmp("infrastructure interface", __s2) == 0;
  }
  uint64_t v5 = malloc_type_calloc(1uLL, 0x18uLL, 0x10300403255E7C6uLL);
  if (!v5)
  {
    uint64_t v23 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      int v25 = 136446979;
      int v26 = "add_new_served_domain_with_interface";
      __int16 v27 = 2160;
      uint64_t v28 = 1752392040;
      __int16 v29 = 2081;
      uint64_t v30 = (uint64_t)__s2;
      __int16 v31 = 2048;
      uint64_t v32 = 24;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "%{public}s: calloc failed - name: %{private, mask.hash}s, allocate size: %lu", (uint8_t *)&v25, 0x2Au);
    }
    return 0;
  }
  uint64_t v6 = v5;
  uint64_t v7 = strdup(__s2);
  *((void *)v6 + 1) = v7;
  if (!v7)
  {
    uint64_t v16 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_29;
    }
    int v25 = 136446723;
    int v26 = "add_new_served_domain_with_interface";
    __int16 v27 = 2160;
    uint64_t v28 = 1752392040;
    __int16 v29 = 2081;
    uint64_t v30 = (uint64_t)__s2;
    uint64_t v17 = "%{public}s: strdup failed to copy interface name - interface name: %{private, mask.hash}s";
LABEL_27:
    int v18 = v16;
    uint32_t v19 = 32;
LABEL_28:
    _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, v17, (uint8_t *)&v25, v19);
    goto LABEL_29;
  }
  if (v2) {
    int v8 = v3;
  }
  else {
    int v8 = 1;
  }
  if (((v8 | v4) & 1) == 0)
  {
    *(_DWORD *)uint64_t v6 = if_nametoindex(__s2);
    v6[4] = 0;
    uint64_t v16 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
LABEL_29:
      uint64_t v20 = (void *)*((void *)v6 + 2);
      if (v20)
      {
        if (*v20)
        {
          __int16 v24 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          {
            int v25 = 136446210;
            int v26 = "add_new_served_domain_with_interface";
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%{public}s: multiple addresses added for this new interface", (uint8_t *)&v25, 0xCu);
            uint64_t v20 = (void *)*((void *)v6 + 2);
          }
        }
        free(v20);
      }
      char v21 = (void *)*((void *)v6 + 1);
      if (v21) {
        free(v21);
      }
      free(v6);
      return 0;
    }
    int v25 = 136446723;
    int v26 = "add_new_served_domain_with_interface";
    __int16 v27 = 2160;
    uint64_t v28 = 1752392040;
    __int16 v29 = 2081;
    uint64_t v30 = (uint64_t)__s2;
    uint64_t v17 = "%{public}s: unexpected served domain %{private, mask.hash}s";
    goto LABEL_27;
  }
  int v9 = "local.";
  if (v3) {
    int v9 = "default.service.arpa.";
  }
  if (v2) {
    int v10 = 0;
  }
  else {
    int v10 = -1;
  }
  if (v2) {
    int v11 = v9;
  }
  else {
    int v11 = "openthread.thread.home.arpa.";
  }
  if (v8) {
    int v12 = v10;
  }
  else {
    int v12 = -5;
  }
  *(_DWORD *)uint64_t v6 = v12;
  v6[4] = 0;
  __int16 v13 = new_served_domain((uint64_t)v6, v11);
  int v14 = global_os_log;
  if (!v13)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_29;
    }
    int v25 = 136446979;
    int v26 = "add_new_served_domain_with_interface";
    __int16 v27 = 2082;
    uint64_t v28 = (uint64_t)__s2;
    __int16 v29 = 2160;
    uint64_t v30 = 1752392040;
    __int16 v31 = 2081;
    uint64_t v32 = (uint64_t)v11;
    uint64_t v17 = "%{public}s: new_served_domain failed - interface name: %{public}s, served domain: %{private, mask.hash}s";
    int v18 = v14;
    uint32_t v19 = 42;
    goto LABEL_28;
  }
  uint64_t v15 = v13;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v25 = 136446722;
    int v26 = "add_new_served_domain_with_interface";
    __int16 v27 = 2082;
    uint64_t v28 = (uint64_t)v11;
    __int16 v29 = 2082;
    uint64_t v30 = (uint64_t)__s2;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: new served domain added with interface - served domain: %{public}s, interface name: %{public}s", (uint8_t *)&v25, 0x20u);
  }
  return v15;
}

BOOL dnssd_hardwired_setup_for_served_domain(uint64_t a1)
{
  memset(v22, 0, 512);
  if (*(void *)(a1 + 40))
  {
    memset(v24, 0, 512);
    dnssd_hardwired_add(a1, "_dns-llq._udp", *(const char **)(a1 + 16), 0, (const void *)((unint64_t)v24 | 0xC), 0x21u);
    dnssd_hardwired_add(a1, "_dns-llq-tls._tcp", *(const char **)(a1 + 16), 0, (const void *)((unint64_t)v24 | 0xC), 0x21u);
    dnssd_hardwired_add(a1, "_dns-update._udp", *(const char **)(a1 + 16), 0, (const void *)((unint64_t)v24 | 0xC), 0x21u);
    dnssd_hardwired_add(a1, "_dns-update-tls._tcp", *(const char **)(a1 + 16), 0, (const void *)((unint64_t)v24 | 0xC), 0x21u);
    dnssd_hardwired_add(a1, "_dns-query-tls._udp", *(const char **)(a1 + 16), 0, (const void *)((unint64_t)v24 | 0xC), 0x21u);
    dnssd_hardwired_add(a1, "lb._dns-sd._udp", *(const char **)(a1 + 16), 0, (const void *)((unint64_t)v24 | 0xC), 0xCu);
    dnssd_hardwired_add(a1, "b._dns-sd._udp", *(const char **)(a1 + 16), 0, (const void *)((unint64_t)v24 | 0xC), 0xCu);
    dnssd_hardwired_add(a1, "db._dns-sd._udp", *(const char **)(a1 + 16), 0, (const void *)((unint64_t)v24 | 0xC), 0xCu);
    memset((char *)&v24[1] + 8, 0, 32);
    unint64_t v2 = (unint64_t)v22 | 0xC;
    *(void *)&v24[0] = v22;
    *((void *)&v24[0] + 1) = (unint64_t)v22 | 0xC;
    *(void *)&v24[1] = v23;
    if (uuid_name)
    {
      dns_name_to_wire_(0, (uint64_t *)v24, &uuid_name, 2111);
      int v3 = 2112;
    }
    else
    {
      dns_name_to_wire_(0, (uint64_t *)v24, "ns", 2114);
      int v3 = 2115;
    }
    dns_full_name_to_wire_(0, (uint64_t)v24, *(char **)(a1 + 8), v3);
    dnssd_hardwired_add(a1, "", *(const char **)(a1 + 8), *((void *)&v24[0] + 1) - v2, (const void *)((unint64_t)v22 | 0xC), 2u);
    dns_name_to_wire_(0, (uint64_t *)v24, "postmaster", 2120);
    dns_full_name_to_wire_(0, (uint64_t)v24, *(char **)(a1 + 8), 2121);
    if (LODWORD(v24[3]) <= 1)
    {
      BOOL v4 = (_DWORD *)*((void *)&v24[0] + 1);
      if ((unint64_t)(*((void *)&v24[0] + 1) + 4) >= *(void *)&v24[1]) {
        goto LABEL_16;
      }
      *((void *)&v24[0] + 1) += 4;
      _DWORD *v4 = 0;
      if (LODWORD(v24[3]) > 1) {
        goto LABEL_17;
      }
      uint64_t v5 = (_DWORD *)*((void *)&v24[0] + 1);
      if ((unint64_t)(*((void *)&v24[0] + 1) + 4) >= *(void *)&v24[1]) {
        goto LABEL_16;
      }
      *((void *)&v24[0] + 1) += 4;
      _DWORD *v5 = 538705920;
      if (LODWORD(v24[3]) > 1) {
        goto LABEL_17;
      }
      uint64_t v6 = (_DWORD *)*((void *)&v24[0] + 1);
      if ((unint64_t)(*((void *)&v24[0] + 1) + 4) >= *(void *)&v24[1])
      {
LABEL_16:
        LODWORD(v24[3]) = 111;
      }
      else
      {
        *((void *)&v24[0] + 1) += 4;
        *uint64_t v6 = 269352960;
        if (LODWORD(v24[3]) <= 1)
        {
          uint64_t v7 = (_DWORD *)*((void *)&v24[0] + 1);
          if ((unint64_t)(*((void *)&v24[0] + 1) + 4) < *(void *)&v24[1])
          {
            *((void *)&v24[0] + 1) += 4;
            _DWORD *v7 = -2142174976;
            if (LODWORD(v24[3]) <= 1)
            {
              int v8 = (_DWORD *)*((void *)&v24[0] + 1);
              if ((unint64_t)(*((void *)&v24[0] + 1) + 4) < *(void *)&v24[1])
              {
                *((void *)&v24[0] + 1) += 4;
                *int v8 = 2013265920;
              }
            }
          }
        }
      }
    }
LABEL_17:
    dnssd_hardwired_add(a1, "", *(const char **)(a1 + 8), *((void *)&v24[0] + 1) - v2, (const void *)((unint64_t)v22 | 0xC), 6u);
    uint64_t v9 = *(void *)(a1 + 40);
    if (v9 && *(unsigned char *)(v9 + 4) || dnssd_hardwired_setup_dns_push_for_domain(a1)) {
      return 1;
    }
    int v11 = global_os_log;
    BOOL result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (result)
    {
      uint64_t v12 = *(void *)(a1 + 8);
      int v16 = 136446723;
      uint64_t v17 = "dnssd_hardwired_setup_for_served_domain";
      __int16 v18 = 2160;
      uint64_t v19 = 1752392040;
      __int16 v20 = 2081;
      uint64_t v21 = v12;
      __int16 v13 = "%{public}s: failed to setup DNS push service for hardwired response - domain: %{private, mask.hash}s";
      int v14 = (uint8_t *)&v16;
LABEL_24:
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, v13, v14, 0x20u);
      return 0;
    }
    return result;
  }
  int v11 = global_os_log;
  BOOL result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
  if (result)
  {
    uint64_t v15 = *(void *)(a1 + 8);
    LODWORD(v24[0]) = 136446723;
    *(void *)((char *)v24 + 4) = "dnssd_hardwired_setup_for_served_domain";
    WORD6(v24[0]) = 2160;
    *(void *)((char *)v24 + 14) = 1752392040;
    WORD3(v24[1]) = 2081;
    *((void *)&v24[1] + 1) = v15;
    __int16 v13 = "%{public}s: only domain with usable interface can setup hardwired response - domain name: %{private, mask.hash}s";
    int v14 = (uint8_t *)v24;
    goto LABEL_24;
  }
  return result;
}

void dnssd_hardwired_add(uint64_t a1, char *__s, const char *a3, size_t a4, const void *a5, unsigned int a6)
{
  size_t v11 = strlen(__s);
  size_t v12 = strlen(a3);
  uint64_t v13 = a4 + v12 + 2 * v11;
  int v14 = malloc_type_calloc(1uLL, v13 + 54, 0x8F731961uLL);
  if (!v14)
  {
    uint64_t v20 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)int buf = 136446722;
    unsigned int v46 = "dnssd_hardwired_add";
    __int16 v47 = 2080;
    uint64_t v48 = (uint64_t)__s;
    __int16 v49 = 2080;
    uint64_t v50 = a3;
    uint64_t v21 = "%{public}s: no memory for %s %s";
LABEL_10:
    __int16 v24 = v20;
    os_log_type_t v25 = OS_LOG_TYPE_ERROR;
    uint32_t v26 = 32;
LABEL_11:
    _os_log_impl((void *)&_mh_execute_header, v24, v25, v21, buf, v26);
    return;
  }
  uint64_t v15 = v14;
  int v16 = (char *)v14 + v13 + 49;
  *(_DWORD *)(v16 + 1) = 1684234849;
  uint64_t v17 = v16 + 1;
  __int16 v18 = (char *)(v14 + 6);
  v14[4] = v14 + 6;
  *((_WORD *)v14 + 20) = a4;
  memcpy(v14 + 6, a5, a4);
  v15[2] = &v18[a4];
  memcpy(&v18[a4], __s, v11);
  *(unsigned char *)(v15[2] + v11) = 0;
  uint64_t v19 = (char *)(v15[2] + v11 + 1);
  v15[3] = v19;
  if (v11)
  {
    snprintf(v19, v11 + v12 + 1, "%s%s", __s, a3);
  }
  else
  {
    memcpy(v19, a3, v12);
    *(unsigned char *)(v15[3] + v12) = 0;
  }
  uint64_t v22 = (const char *)v15[3];
  size_t v23 = (size_t)&v22[strlen(v22) + 1];
  if ((const char *)v23 != v17)
  {
    uint64_t v20 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)int buf = 136446722;
    unsigned int v46 = "dnssd_hardwired_add";
    __int16 v47 = 2048;
    uint64_t v48 = v23;
    __int16 v49 = 2048;
    uint64_t v50 = v17;
    uint64_t v21 = "%{public}s: %p != %p";
    goto LABEL_10;
  }
  if (*(_DWORD *)v17 == 1684234849)
  {
    *((_WORD *)v15 + 4) = a6;
    *uint64_t v15 = 0;
    uint64_t v30 = *(void *)(a1 + 32);
    __int16 v29 = (void *)(a1 + 32);
    uint64_t v28 = v30;
    if (v30)
    {
      while (1)
      {
        __int16 v31 = (void *)v28;
        if (*(unsigned __int16 *)(v28 + 8) == a6)
        {
          uint64_t v32 = *(const char **)(v28 + 24);
          if (!strcasecmp(v32, v22)) {
            break;
          }
        }
        uint64_t v28 = *v31;
        __int16 v29 = v31;
        if (!*v31) {
          goto LABEL_30;
        }
      }
      if (a6 <= 0x1C && ((1 << a6) & 0x10001006) != 0)
      {
        __int16 v33 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v34 = v31[2];
          int v35 = *((unsigned __int16 *)v31 + 20);
          *(_DWORD *)int buf = 136447747;
          unsigned int v46 = "dnssd_hardwired_add";
          __int16 v47 = 2160;
          uint64_t v48 = 1752392040;
          __int16 v49 = 2081;
          uint64_t v50 = v32;
          __int16 v51 = 2160;
          uint64_t v52 = 1752392040;
          __int16 v53 = 2081;
          uint64_t v54 = v34;
          __int16 v55 = 1024;
          unsigned int v56 = a6;
          __int16 v57 = 1024;
          int v58 = v35;
          _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "%{public}s: inserting before %{private, mask.hash}s name %{private, mask.hash}s type %d rdlen %d", buf, 0x40u);
        }
        *uint64_t v15 = v31;
      }
      else
      {
        uint64_t v36 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v37 = v31[2];
          int v38 = *((unsigned __int16 *)v31 + 20);
          *(_DWORD *)int buf = 136447747;
          unsigned int v46 = "dnssd_hardwired_add";
          __int16 v47 = 2160;
          uint64_t v48 = 1752392040;
          __int16 v49 = 2081;
          uint64_t v50 = v32;
          __int16 v51 = 2160;
          uint64_t v52 = 1752392040;
          __int16 v53 = 2081;
          uint64_t v54 = v37;
          __int16 v55 = 1024;
          unsigned int v56 = a6;
          __int16 v57 = 1024;
          int v58 = v38;
          _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%{public}s: superseding %{private, mask.hash}s name %{private, mask.hash}s type %d rdlen %d", buf, 0x40u);
        }
        *uint64_t v15 = *v31;
        free(v31);
      }
    }
    __int16 v31 = v29;
LABEL_30:
    *__int16 v31 = v15;
    uint64_t v39 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v41 = v15[2];
      int v40 = (const char *)v15[3];
      unsigned int v42 = *((unsigned __int16 *)v15 + 4);
      int v43 = *((unsigned __int16 *)v15 + 20);
      *(_DWORD *)int buf = 136447747;
      unsigned int v46 = "dnssd_hardwired_add";
      __int16 v47 = 2160;
      uint64_t v48 = 1752392040;
      __int16 v49 = 2081;
      uint64_t v50 = v40;
      __int16 v51 = 2160;
      uint64_t v52 = 1752392040;
      __int16 v53 = 2081;
      uint64_t v54 = v41;
      __int16 v55 = 1024;
      unsigned int v56 = v42;
      __int16 v57 = 1024;
      int v58 = v43;
      uint64_t v21 = "%{public}s: fullname %{private, mask.hash}s name %{private, mask.hash}s type %d rdlen %d";
      __int16 v24 = v39;
      os_log_type_t v25 = OS_LOG_TYPE_DEFAULT;
      uint32_t v26 = 64;
      goto LABEL_11;
    }
  }
  else
  {
    uint64_t v27 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      unsigned int v46 = "dnssd_hardwired_add";
      uint64_t v21 = "%{public}s: ran off the end.";
      __int16 v24 = v27;
      os_log_type_t v25 = OS_LOG_TYPE_ERROR;
      uint32_t v26 = 12;
      goto LABEL_11;
    }
  }
}

BOOL dnssd_hardwired_setup_dns_push_for_domain(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 40);
  if (!v2 || *(unsigned char *)(v2 + 4))
  {
    uint64_t v5 = global_os_log;
    BOOL result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    uint64_t v6 = *(void *)(a1 + 8);
    *(_DWORD *)int buf = 136446723;
    uint64_t v20 = "dnssd_hardwired_setup_dns_push_for_domain";
    __int16 v21 = 2160;
    uint64_t v22 = 1752392040;
    __int16 v23 = 2081;
    uint64_t v24 = v6;
    uint64_t v7 = "%{public}s: the associated interface does not enable DNS push - domain: %{private, mask.hash}s";
    int v8 = v5;
    uint32_t v9 = 32;
    goto LABEL_16;
  }
  if (!my_name)
  {
    uint64_t v10 = global_os_log;
    BOOL result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v20 = "dnssd_hardwired_setup_dns_push_for_domain";
    uint64_t v7 = "%{public}s: my_name is not set";
    int v8 = v10;
    uint32_t v9 = 12;
LABEL_16:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, v7, buf, v9);
    return 0;
  }
  memset(v17, 0, 496);
  long long v15 = 0u;
  long long v16 = 0u;
  long long v14 = 0u;
  size_t v12 = (char *)v17;
  uint64_t v13 = v18;
  BYTE12(v16) = 0;
  HIWORD(v16) = 0;
  size_t v11 = &v16;
  if ((char *)v17 + 2 >= v18)
  {
    DWORD2(v15) = 111;
    LODWORD(v15) = 2165;
  }
  else
  {
    LOWORD(v17[0]) = 21763;
    size_t v12 = (char *)v17 + 2;
  }
  if (uuid_name)
  {
    dns_name_to_wire_(0, (uint64_t *)&v11, &uuid_name, 2178);
    int v3 = 2179;
  }
  else
  {
    dns_name_to_wire_(0, (uint64_t *)&v11, "ns", 2182);
    int v3 = 2183;
  }
  dns_full_name_to_wire_(0, (uint64_t)&v11, *(char **)(a1 + 8), v3);
  dnssd_hardwired_add(a1, "_dns-push-tls._tcp", *(const char **)(a1 + 16), (size_t)&v12[-((unint64_t)&v16 | 0xC)], (const void *)((unint64_t)&v16 | 0xC), 0x21u);
  return 1;
}

void *new_served_domain(uint64_t a1, const char *a2)
{
  BOOL v4 = malloc_type_calloc(1uLL, 0x38uLL, 0x3004060E82668uLL);
  if (!v4)
  {
    size_t v12 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      int v23 = 136446466;
      uint64_t v24 = "new_served_domain";
      __int16 v25 = 2080;
      uint64_t v26 = (uint64_t)a2;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%{public}s: Unable to allocate served domain %s", (uint8_t *)&v23, 0x16u);
    }
    return 0;
  }
  uint64_t v5 = v4;
  size_t v6 = strlen(a2);
  uint64_t v7 = malloc_type_malloc(v6 + 2, 0x18D075F4uLL);
  v5[2] = v7;
  if (!v7)
  {
    uint64_t v13 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    int v23 = 136446466;
    uint64_t v24 = "new_served_domain";
    __int16 v25 = 2080;
    uint64_t v26 = (uint64_t)a2;
    long long v14 = "%{public}s: Unable to allocate served domain name %s";
    long long v15 = v13;
    goto LABEL_10;
  }
  unsigned char *v7 = 46;
  int v8 = (void *)(v5[2] + 1);
  v5[1] = v8;
  memcpy(v8, a2, v6 + 1);
  uint32_t v9 = dns_pres_name_parse((char *)v5[1]);
  v5[3] = v9;
  v5[5] = a1;
  if (!v9)
  {
    uint64_t v17 = global_os_log;
    BOOL v18 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (a1)
    {
      if (v18)
      {
        uint64_t v19 = *(void *)(a1 + 8);
        uint64_t v20 = v5[1];
        int v23 = 136446722;
        uint64_t v24 = "new_served_domain";
        __int16 v25 = 2080;
        uint64_t v26 = v19;
        __int16 v27 = 2080;
        uint64_t v28 = v20;
        long long v14 = "%{public}s: invalid domain name for interface %s: %s";
        long long v15 = v17;
        uint32_t v16 = 32;
        goto LABEL_14;
      }
LABEL_15:
      free(v5);
      return 0;
    }
    if (!v18) {
      goto LABEL_15;
    }
    uint64_t v22 = v5[1];
    int v23 = 136446466;
    uint64_t v24 = "new_served_domain";
    __int16 v25 = 2080;
    uint64_t v26 = v22;
    long long v14 = "%{public}s: invalid domain name: %s";
    long long v15 = v17;
LABEL_10:
    uint32_t v16 = 22;
LABEL_14:
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, v14, (uint8_t *)&v23, v16);
    goto LABEL_15;
  }
  void *v5 = served_domains;
  served_domains = (uint64_t)v5;
  uint64_t v10 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v11 = v5[1];
    int v23 = 136446723;
    uint64_t v24 = "new_served_domain";
    __int16 v25 = 2160;
    uint64_t v26 = 1752392040;
    __int16 v27 = 2081;
    uint64_t v28 = v11;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: new served domain created - domain name: %{private, mask.hash}s", (uint8_t *)&v23, 0x20u);
  }
  return v5;
}

BOOL init_dnssd_proxy(uint64_t a1)
{
  uint64_t v2 = *(char **)(a1 + 112);
  if (v2)
  {
LABEL_4:
    dnssd_proxy_tls_port = 1;
    values = 0;
    SCDynamicStoreRef v3 = SCDynamicStoreCreate(kCFAllocatorDefault, @"dnssd-proxy:watch for name change events", (SCDynamicStoreCallBack)monitor_name_changes_callback, (SCDynamicStoreContext *)(v2 + 56));
    if (!v3)
    {
      __int16 v27 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "monitor_name_changes";
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_ERROR, "%{public}s: failed to create SCDynamicStoreRef", buf, 0xCu);
      }
      goto LABEL_49;
    }
    BOOL v4 = v3;
    HostNames = (__CFString *)SCDynamicStoreKeyCreateHostNames(kCFAllocatorDefault);
    sc_dynamic_store_key_host_name = (uint64_t)HostNames;
    if (HostNames)
    {
      values = HostNames;
      CFArrayRef v6 = CFArrayCreate(kCFAllocatorDefault, (const void **)&values, 1, &kCFTypeArrayCallBacks);
      if (v6)
      {
        CFArrayRef v7 = v6;
        if (SCDynamicStoreSetNotificationKeys(v4, v6, 0))
        {
          int v8 = SCDynamicStoreSetDispatchQueue(v4, (dispatch_queue_t)&_dispatch_main_q);
          uint32_t v9 = global_os_log;
          if (v8)
          {
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "monitor_name_changes";
              _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: Start to monitor local host name changes", buf, 0xCu);
            }
            CFRelease(v7);
            CFStringRef v10 = SCDynamicStoreCopyLocalHostName(0);
            if (update_my_name(v10))
            {
              if (v10) {
                CFRelease(v10);
              }
              *(void *)int buf = 0;
              arc4random_buf(buf, 8uLL);
              unint64_t v11 = *(void *)buf;
              uuid_name = 117;
              size_t v12 = &byte_1000904D9;
              if (*(void *)buf)
              {
                size_t v12 = &byte_1000904D9;
                do
                {
                  *v12++ = initialize_uuid_name_letters[v11 % 0x24];
                  if (v11 < 0x24) {
                    break;
                  }
                  v11 /= 0x24uLL;
                }
                while (v12 < (char *)&unk_1000905D7);
              }
              char *v12 = 0;
              if (srp_tls_init())
              {
                int v13 = dnssd_proxy_num_listeners++;
                tls_listener_uint32_t index = v13;
                dnssd_tls_listener_listen(0, 1);
                dnssd_hardwired_push_setup();
                if (dnssd_proxy_num_listeners >= 1)
                {
                  uint64_t v14 = 0;
                  do
                  {
                    long long v15 = *(int **)(srp_servers + 72);
                    if (v15) {
                      ioloop_listener_permitted_interface_list_set(dnssd_proxy_listeners[v14], v15);
                    }
                    uint32_t v16 = global_os_log;
                    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v17 = *(char **)(dnssd_proxy_listeners[v14] + 192);
                      *(_DWORD *)int buf = 136446466;
                      *(void *)&uint8_t buf[4] = "start_dnssd_proxy_listener";
                      __int16 v41 = 2082;
                      unsigned int v42 = v17;
                      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: listener started - name: %{public}s", buf, 0x16u);
                    }
                    ++v14;
                  }
                  while (v14 < dnssd_proxy_num_listeners);
                }
                BOOL v18 = new_served_domain(0, my_name);
                if (v18)
                {
                  uint64_t v19 = (uint64_t)v18;
                  uint64_t v20 = add_new_served_domain_with_interface("local only pseudo interface");
                  if (!v20)
                  {
LABEL_73:
                    if (!*(void *)(v19 + 48)) {
                      served_domain_free(v19);
                    }
                    return 0;
                  }
                  uint64_t v21 = (uint64_t)v20;
                  if (dnssd_hardwired_setup_for_served_domain((uint64_t)v20))
                  {
                    uint64_t v22 = add_new_served_domain_with_interface("all locally-discoverable services pseudo interface");
                    uint64_t v23 = (uint64_t)v22;
                    if (v22 && dnssd_hardwired_setup_for_served_domain((uint64_t)v22))
                    {
                      uint64_t v24 = add_new_served_domain_with_interface("infrastructure interface");
                      uint64_t v25 = (uint64_t)v24;
                      if (v24 && dnssd_hardwired_setup_for_served_domain((uint64_t)v24)) {
                        return 1;
                      }
                      goto LABEL_65;
                    }
                  }
                  else
                  {
                    uint64_t v23 = 0;
                  }
                  uint64_t v25 = 0;
LABEL_65:
                  if (!*(void *)(v21 + 48)) {
                    served_domain_free(v21);
                  }
                  if (v23 && !*(void *)(v23 + 48)) {
                    served_domain_free(v23);
                  }
                  if (v25 && !*(void *)(v25 + 48)) {
                    served_domain_free(v25);
                  }
                  goto LABEL_73;
                }
                uint64_t v38 = global_os_log;
                BOOL result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
                if (!result) {
                  return result;
                }
                *(_DWORD *)int buf = 136446466;
                *(void *)&uint8_t buf[4] = "served_domain_init";
                __int16 v41 = 2082;
                unsigned int v42 = my_name;
                uint64_t v34 = "%{public}s: failed to create new served domain - domain name: %{public}s";
                int v35 = v38;
                uint32_t v36 = 22;
LABEL_54:
                _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, v34, buf, v36);
                return 0;
              }
              uint64_t v33 = global_os_log;
              BOOL result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
              if (!result) {
                return result;
              }
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "init_dnssd_proxy";
              uint64_t v34 = "%{public}s: srp_tls_init failed.";
LABEL_53:
              int v35 = v33;
              uint32_t v36 = 12;
              goto LABEL_54;
            }
            uint64_t v37 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "initialize_my_name_and_monitoring";
              _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_ERROR, "%{public}s: failed to update myname", buf, 0xCu);
            }
            if (v10) {
              CFRelease(v10);
            }
LABEL_51:
            uint64_t v33 = global_os_log;
            BOOL result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
            if (!result) {
              return result;
            }
            *(_DWORD *)int buf = 136446210;
            *(void *)&uint8_t buf[4] = "init_dnssd_proxy";
            uint64_t v34 = "%{public}s: initialize_my_name_and_monitoring failed";
            goto LABEL_53;
          }
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
            goto LABEL_47;
          }
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "monitor_name_changes";
          __int16 v31 = "%{public}s: SCDynamicStoreSetDispatchQueue failed";
        }
        else
        {
          uint32_t v9 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          {
LABEL_47:
            CFRelease(v4);
            uint64_t v30 = v7;
            goto LABEL_48;
          }
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "monitor_name_changes";
          __int16 v31 = "%{public}s: SCDynamicStoreSetNotificationKeys failed";
        }
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, v31, buf, 0xCu);
        goto LABEL_47;
      }
      uint64_t v28 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "monitor_name_changes";
        __int16 v29 = "%{public}s: failed to create CFArrayRef for monitored keys";
        goto LABEL_40;
      }
    }
    else
    {
      uint64_t v28 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "monitor_name_changes";
        __int16 v29 = "%{public}s: failed to create SCDynamicStoreKey for host name";
LABEL_40:
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, v29, buf, 0xCu);
      }
    }
    uint64_t v30 = v4;
LABEL_48:
    CFRelease(v30);
LABEL_49:
    uint64_t v32 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "initialize_my_name_and_monitoring";
      _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "%{public}s: failed to monitor name changes", buf, 0xCu);
    }
    goto LABEL_51;
  }
  uint64_t v2 = (char *)malloc_type_calloc(1uLL, 0x60uLL, 0x10B0040ED03978EuLL);
  if (v2)
  {
    *(void *)(a1 + 112) = v2;
    *((void *)v2 + 6) = a1;
    *((void *)v2 + 8) = v2;
    goto LABEL_4;
  }
  uint64_t v33 = global_os_log;
  BOOL result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "init_dnssd_proxy";
    uint64_t v34 = "%{public}s: no memory for advertisements";
    goto LABEL_53;
  }
  return result;
}

BOOL update_my_name(const __CFString *a1)
{
  if (!a1)
  {
    strcpy((char *)local_host_name, "localhost.");
    strcpy((char *)local_host_name_dot_local, "localhost.");
    strcpy((char *)&my_name_buf, "localhost.");
    goto LABEL_20;
  }
  if (!CFStringGetCString(a1, (char *)local_host_name, 256, 0x8000100u))
  {
    uint64_t v10 = global_os_log;
    BOOL result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)int buf = 136446723;
    BOOL v18 = "update_my_name";
    __int16 v19 = 2160;
    size_t v20 = 1752392040;
    __int16 v21 = 2081;
    uint64_t CStringPtr = (uint64_t)CFStringGetCStringPtr(a1, 0x8000100u);
    size_t v12 = "%{public}s: CFStringGetCString failed - local host name: %{private, mask.hash}s";
    goto LABEL_17;
  }
  size_t v2 = strlen((const char *)local_host_name);
  size_t v3 = v2;
  if (!v2)
  {
LABEL_14:
    __memcpy_chk();
    strcpy((char *)&my_name_buf + v3, ".home.arpa.");
    if (snprintf((char *)local_host_name_dot_local, 0x100uLL, "%s.local.", (const char *)local_host_name) >= 0x101)
    {
      uint64_t v10 = global_os_log;
      BOOL result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      *(_DWORD *)int buf = 136446722;
      BOOL v18 = "update_my_name";
      __int16 v19 = 2048;
      size_t v20 = strlen((const char *)local_host_name) + 8;
      __int16 v21 = 2048;
      uint64_t CStringPtr = 256;
      size_t v12 = "%{public}s: snprintf failed - name length: %lu, max: %lu";
LABEL_17:
      int v13 = v10;
      uint32_t v14 = 32;
LABEL_18:
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, v12, buf, v14);
      return 0;
    }
LABEL_20:
    my_name = (char *)&my_name_buf;
    long long v15 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136447491;
      BOOL v18 = "update_my_name";
      __int16 v19 = 2082;
      size_t v20 = (size_t)"updated";
      __int16 v21 = 2160;
      uint64_t CStringPtr = 1752392040;
      __int16 v23 = 2081;
      uint64_t v24 = &my_name_buf;
      __int16 v25 = 2160;
      uint64_t v26 = 1752392040;
      __int16 v27 = 2081;
      uint64_t v28 = local_host_name_dot_local;
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s my_name: %{private, mask.hash}s, local host name: %{private, mask.hash}s", buf, 0x3Eu);
    }
    return 1;
  }
  size_t v4 = v2;
  uint64_t v5 = local_host_name;
  do
  {
    __darwin_ct_rune_t v7 = *(char *)v5;
    uint64_t v5 = (uint64_t *)((char *)v5 + 1);
    __darwin_ct_rune_t v6 = v7;
    if (v7 < 0) {
      __uint32_t v8 = __maskrune(v6, 0x500uLL);
    }
    else {
      __uint32_t v8 = _DefaultRuneLocale.__runetype[v6] & 0x500;
    }
    if (v6 != 45 && v8 == 0)
    {
      uint64_t v16 = global_os_log;
      BOOL result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v18 = "update_my_name";
      __int16 v19 = 2082;
      size_t v20 = (size_t)local_host_name;
      size_t v12 = "%{public}s: invalid DNS name - name: %{public}s";
      goto LABEL_26;
    }
    --v4;
  }
  while (v4);
  if (v3 - 245 > 0xFFFFFFFFFFFFFEFELL) {
    goto LABEL_14;
  }
  uint64_t v16 = global_os_log;
  BOOL result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_DWORD *)int buf = 136446466;
    BOOL v18 = "update_my_name";
    __int16 v19 = 2082;
    size_t v20 = (size_t)local_host_name;
    size_t v12 = "%{public}s: generated name too long: %{public}s.home.arpa.";
LABEL_26:
    int v13 = v16;
    uint32_t v14 = 22;
    goto LABEL_18;
  }
  return result;
}

void dnssd_tls_listener_listen(uint64_t a1, int a2)
{
  size_t v4 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136446210;
    uint64_t v24 = "dnssd_tls_listener_listen";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: starting DoT listener", buf, 0xCu);
  }
  v21[1] = 0;
  int v22 = 0;
  v21[2] = 0;
  v21[0] = 28;
  if (dnssd_proxy_tls_port) {
    unsigned int v5 = 853;
  }
  else {
    unsigned int v5 = 0;
  }
  WORD1(v21[0]) = __rev16(v5);
  __darwin_ct_rune_t v6 = ioloop_listener_create(1, 1, a2, (uint64_t)v21, "DNS over TLS", (uint64_t)dns_proxy_input, (uint64_t)dnssd_tls_listener_restart, (uint64_t)dnssd_tls_listener_ready, (uint64_t)srp_tls_configure, 0, a1);
  dnssd_proxy_listeners[tls_listener_index] = v6;
  if (!v6)
  {
    uint64_t v15 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v24 = "dnssd_tls_listener_listen";
    uint32_t v14 = "%{public}s: DNS Push listener: fail.";
    uint64_t v16 = v15;
    os_log_type_t v17 = OS_LOG_TYPE_ERROR;
LABEL_18:
    uint32_t v18 = 12;
LABEL_28:
    _os_log_impl((void *)&_mh_execute_header, v16, v17, v14, buf, v18);
    return;
  }
  __darwin_ct_rune_t v7 = *(int **)(srp_servers + 72);
  if (v7) {
    ioloop_listener_permitted_interface_list_set((uint64_t)v6, v7);
  }
  dnssd_tls_key_change_notification_send();
  uint64_t v8 = dnssd_proxy_listeners[tls_listener_index];
  if (!tls_listener_wakeup)
  {
    tls_listener_wakeup = (uint64_t)ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/tls-macos.c", 389);
    if (!tls_listener_wakeup)
    {
      uint64_t v19 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        return;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v24 = "schedule_tls_certificate_rotation";
      uint32_t v14 = "%{public}s: Unable to allocate wakeup in order to set up TLS certificate rotation timer.";
      uint64_t v16 = v19;
      os_log_type_t v17 = OS_LOG_TYPE_FAULT;
      goto LABEL_18;
    }
  }
  double v9 = *(double *)&g_tls_identity_creation_time;
  if (*(double *)&g_tls_identity_creation_time <= 0.0)
  {
LABEL_23:
    unsigned int v12 = 0;
    goto LABEL_24;
  }
  double Current = CFAbsoluteTimeGetCurrent();
  double v11 = v9 + 1209600.0 - Current;
  if (v11 <= 0.0)
  {
    size_t v20 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)int buf = 136446978;
      uint64_t v24 = "srp_tls_get_next_rotation_time";
      __int16 v25 = 2048;
      double v26 = v9;
      __int16 v27 = 2048;
      double v28 = Current;
      __int16 v29 = 2048;
      double v30 = v9 + 1209600.0;
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_FAULT, "%{public}s: The TLS certificate rotation date is in the past - creation date: %lf, now: %lf, rotate date: %lf.", buf, 0x2Au);
    }
    goto LABEL_23;
  }
  unsigned int v12 = v11;
  if (v11 >= 0x20C49C)
  {
    uint64_t v13 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      return;
    }
    *(_DWORD *)int buf = 136446466;
    uint64_t v24 = "schedule_tls_certificate_rotation";
    __int16 v25 = 1024;
    LODWORD(v26) = v12;
    uint32_t v14 = "%{public}s: Remaining time too long, unable to set the timer - remaining time: %u.";
    goto LABEL_27;
  }
LABEL_24:
  if (!ioloop_add_wake_event(tls_listener_wakeup, v8, (uint64_t)tls_certificate_rotate, 0, 1000 * v12))
  {
    uint64_t v13 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)int buf = 136446466;
      uint64_t v24 = "schedule_tls_certificate_rotation";
      __int16 v25 = 1024;
      LODWORD(v26) = v12;
      uint32_t v14 = "%{public}s: Failed to schedule the wake event for the next TLS certificate rotation - remaining_time_to_rotate: %d.";
LABEL_27:
      uint64_t v16 = v13;
      os_log_type_t v17 = OS_LOG_TYPE_FAULT;
      uint32_t v18 = 18;
      goto LABEL_28;
    }
  }
}

BOOL dnssd_hardwired_push_setup()
{
  uint64_t v0 = (void *)served_domains;
  if (served_domains)
  {
    do
    {
      uint64_t v1 = v0[5];
      if (v1)
      {
        if (!*(unsigned char *)(v1 + 4)) {
          BOOL result = dnssd_hardwired_setup_dns_push_for_domain((uint64_t)v0);
        }
      }
      uint64_t v0 = (void *)*v0;
    }
    while (v0);
  }
  return result;
}

void dnssd_tls_key_change_notification_send()
{
  if (dnssd_tls_key_change_notification_send_dnssd_tls_change_notification_token != -1)
  {
LABEL_2:
    uint32_t v0 = notify_post("com.apple.srp-mdns-proxy.tls-key-update");
    if (v0)
    {
      uint32_t v1 = v0;
      size_t v2 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        int v6 = 136446722;
        __darwin_ct_rune_t v7 = "dnssd_tls_key_change_notification_send";
        __int16 v8 = 2080;
        double v9 = "com.apple.srp-mdns-proxy.tls-key-update";
        __int16 v10 = 1024;
        uint32_t v11 = v1;
        _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_ERROR, "%{public}s: notify_post(%s) %u", (uint8_t *)&v6, 0x1Cu);
      }
      notify_cancel(dnssd_tls_key_change_notification_send_dnssd_tls_change_notification_token);
      dnssd_tls_key_change_notification_send_dnssd_tls_change_notification_token = -1;
    }
    return;
  }
  uint32_t v3 = notify_register_check("com.apple.srp-mdns-proxy.tls-key-update", &dnssd_tls_key_change_notification_send_dnssd_tls_change_notification_token);
  if (!v3)
  {
    if (dnssd_tls_key_change_notification_send_dnssd_tls_change_notification_token == -1) {
      return;
    }
    goto LABEL_2;
  }
  uint32_t v4 = v3;
  dnssd_tls_key_change_notification_send_dnssd_tls_change_notification_token = -1;
  unsigned int v5 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    int v6 = 136446722;
    __darwin_ct_rune_t v7 = "dnssd_tls_key_change_notification_send";
    __int16 v8 = 2080;
    double v9 = "com.apple.srp-mdns-proxy.tls-key-update";
    __int16 v10 = 1024;
    uint32_t v11 = v4;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "%{public}s: notify_register_check(%s) failed with %u", (uint8_t *)&v6, 0x1Cu);
  }
}

void dnssd_tls_listener_restart(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = dnssd_proxy_listeners[tls_listener_index];
  int v3 = *(_DWORD *)(v2 + 32);
  if (!v3)
  {
    uint64_t v15 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_30;
    }
    int v18 = 136447490;
    uint64_t v19 = "ioloop_listener_release_";
    __int16 v20 = 1024;
    *(_DWORD *)__int16 v21 = 0;
    *(_WORD *)&v21[4] = 2048;
    *(void *)&v21[6] = v2;
    *(_WORD *)&v21[14] = 2080;
    *(void *)&v21[16] = "listener";
    *(_WORD *)&v21[24] = 2080;
    *(void *)&v21[26] = "dnssd-proxy.c";
    __int16 v22 = 1024;
    int v23 = 4722;
    uint64_t v16 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    os_log_type_t v17 = v15;
    goto LABEL_29;
  }
  uint32_t v4 = global_os_log;
  if (v3 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_30;
    }
    int v18 = 136447490;
    uint64_t v19 = "ioloop_listener_release_";
    __int16 v20 = 1024;
    *(_DWORD *)__int16 v21 = v3;
    *(_WORD *)&v21[4] = 2048;
    *(void *)&v21[6] = v2;
    *(_WORD *)&v21[14] = 2080;
    *(void *)&v21[16] = "listener";
    *(_WORD *)&v21[24] = 2080;
    *(void *)&v21[26] = "dnssd-proxy.c";
    __int16 v22 = 1024;
    int v23 = 4722;
    uint64_t v16 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    os_log_type_t v17 = v4;
LABEL_29:
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, v16, (uint8_t *)&v18, 0x36u);
LABEL_30:
    abort();
  }
  __int16 v6 = *(_WORD *)(v2 + 416);
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v18 = 136447490;
    uint64_t v19 = "ioloop_listener_release_";
    __int16 v20 = 1024;
    *(_DWORD *)__int16 v21 = v3;
    *(_WORD *)&v21[4] = 2048;
    *(void *)&v21[6] = v2;
    *(_WORD *)&v21[14] = 2080;
    *(void *)&v21[16] = "listener";
    *(_WORD *)&v21[24] = 2080;
    *(void *)&v21[26] = "dnssd-proxy.c";
    __int16 v22 = 1024;
    int v23 = 4722;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v18, 0x36u);
    int v3 = *(_DWORD *)(v2 + 32);
  }
  *(_DWORD *)(v2 + 32) = v3 - 1;
  if (v3 == 1)
  {
    __darwin_ct_rune_t v7 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v18 = 136447234;
      uint64_t v19 = "ioloop_listener_release_";
      __int16 v20 = 2048;
      *(void *)__int16 v21 = v2;
      *(_WORD *)&v21[8] = 2080;
      *(void *)&v21[10] = "listener";
      *(_WORD *)&v21[18] = 2080;
      *(void *)&v21[20] = "dnssd-proxy.c";
      *(_WORD *)&v21[28] = 1024;
      *(_DWORD *)&v21[30] = 4722;
      _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v18, 0x30u);
    }
    ++listener_finalized;
    listener_finalize((void *)v2);
  }
  dnssd_proxy_listeners[tls_listener_index] = 0;
  if ((v6 & 0x10) != 0)
  {
    if (!srp_tls_init())
    {
      uint64_t v10 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        return;
      }
      int v18 = 136446210;
      uint64_t v19 = "dnssd_tls_listener_restart";
      uint32_t v11 = "%{public}s: srp_tls_init failed.";
      unsigned int v12 = v10;
      os_log_type_t v13 = OS_LOG_TYPE_FAULT;
      goto LABEL_23;
    }
    dnssd_tls_key_change_notification_send();
    dnssd_tls_listener_listen(0, 0);
  }
  else
  {
    __int16 v8 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v18 = 136446210;
      uint64_t v19 = "dnssd_tls_listener_restart";
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: Creation of TLS listener failed; reattempting in 10s.",
        (uint8_t *)&v18,
        0xCu);
    }
    double v9 = (int *)tls_listener_wakeup;
    if (tls_listener_wakeup
      || (double v9 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/dnssd-proxy.c", 4739), (tls_listener_wakeup = (uint64_t)v9) != 0))
    {
      ioloop_add_wake_event((uint64_t)v9, a2, (uint64_t)dnssd_tls_listener_relisten, 0, 0x2710u);
      return;
    }
    uint64_t v14 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      int v18 = 136446210;
      uint64_t v19 = "dnssd_tls_listener_restart";
      uint32_t v11 = "%{public}s: Unable to allocate wakeup in order to re-attempt TLS listener creation.";
      unsigned int v12 = v14;
      os_log_type_t v13 = OS_LOG_TYPE_ERROR;
LABEL_23:
      _os_log_impl((void *)&_mh_execute_header, v12, v13, v11, (uint8_t *)&v18, 0xCu);
    }
  }
}

uint64_t dnssd_tls_listener_relisten(uint64_t a1)
{
  return dnssd_tls_listener_listen(a1, 0);
}

void monitor_name_changes_callback(const __SCDynamicStore *a1, CFArrayRef theArray, void *a3)
{
  v76.size_t length = CFArrayGetCount(theArray);
  v76.location = 0;
  if (CFArrayContainsValue(theArray, v76, (const void *)sc_dynamic_store_key_host_name))
  {
    CFStringRef v6 = SCDynamicStoreCopyLocalHostName(a1);
    if (v6)
    {
      CFStringRef v7 = v6;
      BOOL updated = update_my_name(v6);
      double v9 = global_os_log;
      if (updated)
      {
        double v30 = a3;
        CFStringRef v31 = v7;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "dnssd_hardwired_clear";
          _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: Clearing all hardwired response", buf, 0xCu);
        }
        uint64_t v10 = (void *)served_domains;
        if (served_domains)
        {
          do
          {
            uint32_t v11 = (void *)v10[4];
            if (v11)
            {
              v10[4] = 0;
              do
              {
                unsigned int v12 = (void *)*v11;
                free(v11);
                uint32_t v11 = v12;
              }
              while (v12);
            }
            uint64_t v10 = (void *)*v10;
          }
          while (v10);
          uint64_t v13 = served_domains;
          if (served_domains)
          {
            long long v73 = 0u;
            long long v74 = 0u;
            long long v71 = 0u;
            long long v72 = 0u;
            long long v69 = 0u;
            long long v70 = 0u;
            long long v67 = 0u;
            long long v68 = 0u;
            long long v65 = 0u;
            long long v66 = 0u;
            long long v63 = 0u;
            long long v64 = 0u;
            long long v61 = 0u;
            long long v62 = 0u;
            long long v59 = 0u;
            long long v60 = 0u;
            long long v57 = 0u;
            long long v58 = 0u;
            long long v55 = 0u;
            long long v56 = 0u;
            unint64_t v14 = (unint64_t)buf | 0xC;
            long long v53 = 0u;
            long long v54 = 0u;
            long long v51 = 0u;
            long long v52 = 0u;
            long long v49 = 0u;
            long long v50 = 0u;
            long long v47 = 0u;
            long long v48 = 0u;
            long long v46 = 0u;
            long long v44 = 0u;
            long long v45 = 0u;
            *(_OWORD *)int buf = 0u;
            while (!*(void *)(v13 + 40))
            {
LABEL_31:
              uint64_t v13 = *(void *)v13;
              if (!v13) {
                goto LABEL_32;
              }
            }
            dnssd_hardwired_add(v13, "_dns-llq._udp", *(const char **)(v13 + 16), 0, (const void *)((unint64_t)buf | 0xC), 0x21u);
            dnssd_hardwired_add(v13, "_dns-llq-tls._tcp", *(const char **)(v13 + 16), 0, (const void *)((unint64_t)buf | 0xC), 0x21u);
            dnssd_hardwired_add(v13, "_dns-update._udp", *(const char **)(v13 + 16), 0, (const void *)((unint64_t)buf | 0xC), 0x21u);
            dnssd_hardwired_add(v13, "_dns-update-tls._tcp", *(const char **)(v13 + 16), 0, (const void *)((unint64_t)buf | 0xC), 0x21u);
            dnssd_hardwired_add(v13, "_dns-push-tls._tcp", *(const char **)(v13 + 16), 0, (const void *)((unint64_t)buf | 0xC), 0x21u);
            long long v35 = 0u;
            long long v36 = 0u;
            uint64_t v32 = buf;
            uint64_t v33 = (uint8_t *)((unint64_t)buf | 0xC);
            uint64_t v34 = v75;
            if (uuid_name)
            {
              dns_name_to_wire_(0, (uint64_t *)&v32, &uuid_name, 1875);
              int v15 = 1876;
            }
            else
            {
              dns_name_to_wire_(0, (uint64_t *)&v32, "ns", 1878);
              int v15 = 1879;
            }
            dns_full_name_to_wire_(0, (uint64_t)&v32, *(char **)(v13 + 8), v15);
            dnssd_hardwired_add(v13, "", *(const char **)(v13 + 8), (size_t)&v33[-v14], (const void *)((unint64_t)buf | 0xC), 2u);
            dns_name_to_wire_(0, (uint64_t *)&v32, "postmaster", 1884);
            dns_full_name_to_wire_(0, (uint64_t)&v32, *(char **)(v13 + 8), 1885);
            if (DWORD2(v36) <= 1)
            {
              uint64_t v16 = v33;
              os_log_type_t v17 = v33 + 4;
              if (v33 + 4 >= v34)
              {
                DWORD2(v36) = 111;
                int v21 = 1886;
              }
              else
              {
                v33 += 4;
                *(_DWORD *)uint64_t v16 = 0;
                int v18 = v17 + 1;
                if (v17 + 1 >= (_DWORD *)v34)
                {
                  DWORD2(v36) = 111;
                  int v21 = 1887;
                }
                else
                {
                  uint64_t v33 = (uint8_t *)(v17 + 1);
                  *os_log_type_t v17 = 538705920;
                  uint64_t v19 = v17 + 2;
                  if (v18 + 1 >= (_DWORD *)v34)
                  {
                    DWORD2(v36) = 111;
                    int v21 = 1888;
                  }
                  else
                  {
                    uint64_t v33 = (uint8_t *)(v18 + 1);
                    *int v18 = 269352960;
                    __int16 v20 = v18 + 2;
                    if (v19 + 1 >= (_DWORD *)v34)
                    {
                      DWORD2(v36) = 111;
                      int v21 = 1889;
                    }
                    else
                    {
                      uint64_t v33 = (uint8_t *)(v19 + 1);
                      _DWORD *v19 = -2142174976;
                      if (v19 + 2 < (_DWORD *)v34)
                      {
                        uint64_t v33 = (uint8_t *)(v19 + 2);
                        *__int16 v20 = 2013265920;
                        goto LABEL_30;
                      }
                      DWORD2(v36) = 111;
                      int v21 = 1890;
                    }
                  }
                }
              }
              LODWORD(v36) = v21;
            }
LABEL_30:
            dnssd_hardwired_add(v13, "", *(const char **)(v13 + 8), (size_t)&v33[-v14], (const void *)((unint64_t)buf | 0xC), 6u);
            goto LABEL_31;
          }
        }
LABEL_32:
        dnssd_hardwired_push_setup();
        CFStringRef v7 = v31;
        if (!v30[1]) {
          goto LABEL_39;
        }
        bzero(buf, 0x582uLL);
        long long v35 = 0u;
        long long v36 = 0u;
        uint64_t v33 = &buf[12];
        uint64_t v34 = v75;
        uint64_t v32 = buf;
        dns_full_name_to_wire_(0, (uint64_t)&v32, (char *)local_host_name_dot_local, 5364);
        int v22 = DNSServiceUpdateRecordInternal(v30[2], v30[3], (unsigned __int16)((_WORD)v33 - (unsigned __int16)&buf[12]), &buf[12], 0);
        int v23 = global_os_log;
        if (v22)
        {
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)uint64_t v37 = 136446723;
            uint64_t v38 = "monitor_name_changes_callback";
            __int16 v39 = 2160;
            uint64_t v40 = 1752392040;
            __int16 v41 = 2081;
            unsigned int v42 = local_host_name_dot_local;
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_ERROR, "%{public}s: DNSServiceUpdateRecord failed to update NS record to new name - name: %{private, mask.hash}s", v37, 0x20u);
            int v23 = global_os_log;
          }
        }
        if (!os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_39;
        }
        *(_DWORD *)uint64_t v37 = 136446723;
        uint64_t v38 = "monitor_name_changes_callback";
        __int16 v39 = 2160;
        uint64_t v40 = 1752392040;
        __int16 v41 = 2081;
        unsigned int v42 = local_host_name_dot_local;
        uint64_t v24 = "%{public}s: Updating record - new NS record rdata: %{private, mask.hash}s";
        __int16 v25 = v37;
        double v26 = v23;
        os_log_type_t v27 = OS_LOG_TYPE_DEFAULT;
        uint32_t v28 = 32;
      }
      else
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
          goto LABEL_39;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "monitor_name_changes_callback";
        uint64_t v24 = "%{public}s: failed to update my name";
        __int16 v25 = buf;
        double v26 = v9;
        os_log_type_t v27 = OS_LOG_TYPE_ERROR;
        uint32_t v28 = 12;
      }
      _os_log_impl((void *)&_mh_execute_header, v26, v27, v24, v25, v28);
LABEL_39:
      CFRelease(v7);
      return;
    }
    __int16 v29 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "monitor_name_changes_callback";
      _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_ERROR, "%{public}s: failed to get updated local host name", buf, 0xCu);
    }
  }
}

void thread_tracker_callback(uint64_t a1, int a2, int a3)
{
  if (a3 == -65569) {
    goto LABEL_4;
  }
  if (a3)
  {
    if (a3 != -65563)
    {
      uint64_t v13 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int v18 = 136446466;
        *(void *)&v18[4] = "thread_tracker_callback";
        *(_WORD *)&v18[12] = 1024;
        *(_DWORD *)&unsigned char v18[14] = a3;
        _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: unexpected error %d", v18, 0x12u);
      }
LABEL_20:
      cti_events_discontinue(*(void *)(a1 + 40));
      *(void *)(a1 + 40) = 0;
      int v14 = *(_DWORD *)a1;
      if (*(_DWORD *)a1)
      {
        int v15 = global_os_log;
        if (v14 < 10001)
        {
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int v18 = 136447490;
            *(void *)&v18[4] = "thread_tracker_callback";
            *(_WORD *)&v18[12] = 1024;
            *(_DWORD *)&unsigned char v18[14] = v14;
            *(_WORD *)&v18[18] = 2048;
            *(void *)&v18[20] = a1;
            *(_WORD *)&v18[28] = 2080;
            *(void *)&v18[30] = "tracker";
            *(_WORD *)&v18[38] = 2080;
            *(void *)&v18[40] = "thread-tracker.c";
            __int16 v19 = 1024;
            int v20 = 123;
            _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v18, 0x36u);
            int v14 = *(_DWORD *)a1;
          }
          *(_DWORD *)a1 = v14 - 1;
          if (v14 == 1)
          {
            uint64_t v16 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)int v18 = 136447234;
              *(void *)&v18[4] = "thread_tracker_callback";
              *(_WORD *)&v18[12] = 2048;
              *(void *)&unsigned char v18[14] = a1;
              *(_WORD *)&v18[22] = 2080;
              *(void *)&v18[24] = "tracker";
              *(_WORD *)&v18[32] = 2080;
              *(void *)&v18[34] = "thread-tracker.c";
              *(_WORD *)&v18[42] = 1024;
              *(_DWORD *)&v18[44] = 123;
              _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v18, 0x30u);
            }
            ++thread_tracker_finalized;
            free((void *)a1);
          }
          return;
        }
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_34:
        }
          abort();
        *(_DWORD *)int v18 = 136447490;
        *(void *)&v18[4] = "thread_tracker_callback";
        *(_WORD *)&v18[12] = 1024;
        *(_DWORD *)&unsigned char v18[14] = v14;
        *(_WORD *)&v18[18] = 2048;
        *(void *)&v18[20] = a1;
        *(_WORD *)&v18[28] = 2080;
        *(void *)&v18[30] = "tracker";
        *(_WORD *)&v18[38] = 2080;
        *(void *)&v18[40] = "thread-tracker.c";
        __int16 v19 = 1024;
        int v20 = 123;
        os_log_type_t v17 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      }
      else
      {
        int v15 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_34;
        }
        *(_DWORD *)int v18 = 136447490;
        *(void *)&v18[4] = "thread_tracker_callback";
        *(_WORD *)&v18[12] = 1024;
        *(_DWORD *)&unsigned char v18[14] = 0;
        *(_WORD *)&v18[18] = 2048;
        *(void *)&v18[20] = a1;
        *(_WORD *)&v18[28] = 2080;
        *(void *)&v18[30] = "tracker";
        *(_WORD *)&v18[38] = 2080;
        *(void *)&v18[40] = "thread-tracker.c";
        __int16 v19 = 1024;
        int v20 = 123;
        os_log_type_t v17 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      }
      _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_FAULT, v17, v18, 0x36u);
      goto LABEL_34;
    }
LABEL_4:
    unsigned int v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int v18 = 136446210;
      *(void *)&v18[4] = "thread_tracker_callback";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: disconnected", v18, 0xCu);
    }
    if (*(void *)(a1 + 24))
    {
      CFStringRef v6 = *(void (**)(void))(a1 + 16);
      if (v6) {
        v6();
      }
    }
    goto LABEL_20;
  }
  *(void *)int v18 = 0;
  *(void *)&v18[8] = 0;
  gettimeofday((timeval *)v18, 0);
  *(void *)(a1 + 56) = 1000 * *(void *)v18 + *(_DWORD *)&v18[8] / 1000;
  if ((a2 - 1) >= 0xC) {
    int v8 = 0;
  }
  else {
    int v8 = a2;
  }
  double v9 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v10 = (&off_10008D2E8)[v8];
    *(_DWORD *)int v18 = 136446722;
    *(void *)&v18[4] = "thread_tracker_callback";
    *(_WORD *)&v18[12] = 2082;
    *(void *)&unsigned char v18[14] = v10;
    *(_WORD *)&v18[22] = 1024;
    *(_DWORD *)&v18[24] = a2;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: state is: %{public}s (%d)\n ", v18, 0x1Cu);
  }
  int v11 = *(_DWORD *)(a1 + 64);
  if (v11 != v8)
  {
    *(unsigned char *)(a1 + 73) = *(unsigned char *)(a1 + 72);
    *(_DWORD *)(a1 + 64) = v8;
    *(_DWORD *)(a1 + 68) = v11;
    *(unsigned char *)(a1 + 72) = (a2 & 0xFFFFFFFC) == 8;
    for (uint64_t i = *(uint64_t ***)(a1 + 48); i; uint64_t i = (uint64_t **)*i)
      ((void (*)(uint64_t *))i[2])(i[3]);
  }
}

void thread_tracker_callback_cancel(void *a1, uint64_t a2)
{
  if (a1)
  {
    uint32_t v4 = a1 + 6;
    int v3 = (void *)a1[6];
    if (v3)
    {
      unsigned int v5 = v3 + 3;
      if (v3[3] == a2)
      {
        CFStringRef v6 = a1 + 6;
      }
      else
      {
        do
        {
          CFStringRef v6 = v3;
          int v3 = (void *)*v3;
          if (!v3) {
            return;
          }
        }
        while (v3[3] != a2);
        unsigned int v5 = v3 + 3;
      }
      *CFStringRef v6 = *v3;
      CFStringRef v7 = (void (*)(void))v3[1];
      if (v7) {
        v7(*v5);
      }
      free(v3);
      if (!*v4)
      {
        int v8 = *(_DWORD *)a1;
        if (*(_DWORD *)a1)
        {
          double v9 = global_os_log;
          if (v8 < 10001)
          {
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              int v12 = 136447490;
              uint64_t v13 = "thread_tracker_callback_cancel";
              __int16 v14 = 1024;
              *(_DWORD *)int v15 = v8;
              *(_WORD *)&_OWORD v15[4] = 2048;
              *(void *)&v15[6] = a1;
              *(_WORD *)&v15[14] = 2080;
              *(void *)&v15[16] = "tracker";
              *(_WORD *)&v15[24] = 2080;
              *(void *)&v15[26] = "thread-tracker.c";
              __int16 v16 = 1024;
              int v17 = 310;
              _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v12, 0x36u);
              int v8 = *(_DWORD *)a1;
            }
            *(_DWORD *)a1 = v8 - 1;
            if (v8 == 1)
            {
              uint64_t v10 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                int v12 = 136447234;
                uint64_t v13 = "thread_tracker_callback_cancel";
                __int16 v14 = 2048;
                *(void *)int v15 = a1;
                *(_WORD *)&v15[8] = 2080;
                *(void *)&v15[10] = "tracker";
                *(_WORD *)&v15[18] = 2080;
                *(void *)&v15[20] = "thread-tracker.c";
                *(_WORD *)&v15[28] = 1024;
                *(_DWORD *)&v15[30] = 310;
                _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v12, 0x30u);
              }
              ++thread_tracker_finalized;
              free(a1);
            }
            return;
          }
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_25:
          }
            abort();
          int v12 = 136447490;
          uint64_t v13 = "thread_tracker_callback_cancel";
          __int16 v14 = 1024;
          *(_DWORD *)int v15 = v8;
          *(_WORD *)&_OWORD v15[4] = 2048;
          *(void *)&v15[6] = a1;
          *(_WORD *)&v15[14] = 2080;
          *(void *)&v15[16] = "tracker";
          *(_WORD *)&v15[24] = 2080;
          *(void *)&v15[26] = "thread-tracker.c";
          __int16 v16 = 1024;
          int v17 = 310;
          int v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        }
        else
        {
          double v9 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
            goto LABEL_25;
          }
          int v12 = 136447490;
          uint64_t v13 = "thread_tracker_callback_cancel";
          __int16 v14 = 1024;
          *(_DWORD *)int v15 = 0;
          *(_WORD *)&_OWORD v15[4] = 2048;
          *(void *)&v15[6] = a1;
          *(_WORD *)&v15[14] = 2080;
          *(void *)&v15[16] = "tracker";
          *(_WORD *)&v15[24] = 2080;
          *(void *)&v15[26] = "thread-tracker.c";
          __int16 v16 = 1024;
          int v17 = 310;
          int v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        }
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, v11, (uint8_t *)&v12, 0x36u);
        goto LABEL_25;
      }
    }
  }
}

void srp_mdns_shared_record_remove(uint64_t a1, uint64_t a2)
{
  if (a2)
  {
    uint32_t v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = *(_DWORD *)a2;
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "srp_mdns_shared_record_remove";
      __int16 v37 = 1024;
      *(_DWORD *)uint64_t v38 = v5;
      *(_WORD *)&v38[4] = 2048;
      *(void *)&v38[6] = a2;
      *(_WORD *)&v38[14] = 2080;
      *(void *)&v38[16] = "record";
      *(_WORD *)&v38[24] = 2080;
      *(void *)&v38[26] = "srp-mdns-proxy.c";
      __int16 v39 = 1024;
      int v40 = 136;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    int v6 = *(_DWORD *)a2;
    if (*(_DWORD *)a2)
    {
      int v7 = v6 + 1;
      *(_DWORD *)a2 = v6 + 1;
      if (v6 + 1 >= 10001)
      {
        int v8 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_68;
        }
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "srp_mdns_shared_record_remove";
        __int16 v37 = 1024;
        *(_DWORD *)uint64_t v38 = v7;
        *(_WORD *)&v38[4] = 2048;
        *(void *)&v38[6] = a2;
        *(_WORD *)&v38[14] = 2080;
        *(void *)&v38[16] = "record";
        *(_WORD *)&v38[24] = 2080;
        *(void *)&v38[26] = "srp-mdns-proxy.c";
        __int16 v39 = 1024;
        int v40 = 136;
        double v9 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        goto LABEL_67;
      }
    }
    else
    {
      ++adv_record_created;
      *(_DWORD *)a2 = 1;
    }
  }
  uint64_t v10 = *(_DWORD **)(a2 + 8);
  if (v10)
  {
    uint64_t v11 = *(void *)(a2 + 24);
    if (v11)
    {
      uint64_t v12 = *(void *)(a1 + 16);
      uint64_t v13 = global_os_log;
      if (v11 == v12)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "srp_mdns_shared_record_remove";
          __int16 v37 = 2048;
          *(void *)uint64_t v38 = v10;
          _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: removing rref %p", buf, 0x16u);
          uint64_t v12 = *(void *)(a1 + 16);
          uint64_t v10 = *(_DWORD **)(a2 + 8);
        }
        uint64_t v14 = *(void *)(v12 + 8);
        long long v35 = 0;
        if (v14)
        {
          if (v10)
          {
            if (*(_DWORD *)(v14 + 36))
            {
              int v15 = *(_DWORD *)(v14 + 16);
              if (v15 < 0 || (*(_DWORD *)(v14 + 20) ^ v15) != 0x12345678)
              {
                int v21 = -65541;
                syslog(4, "dnssd_clientstub DNSServiceRemoveRecord called with invalid DNSServiceRef %p %08X %08X");
              }
              else
              {
                __int16 v16 = (void *)(v14 + 80);
                do
                {
                  int v17 = v16;
                  __int16 v16 = (void *)*v16;
                  if (v16) {
                    BOOL v18 = v16 == (void *)v10;
                  }
                  else {
                    BOOL v18 = 1;
                  }
                }
                while (!v18);
                if (v16)
                {
                  *(void *)int buf = 4;
                  __int16 v19 = (int8x16_t *)create_hdr(3, (size_t *)buf, &v35, 1, v14);
                  if (!*(void *)(v14 + 8)) {
                    v19[1].i64[0] = 0;
                  }
                  v19[1].i32[2] = v10[8];
                  *long long v35 = 0;
                  int v20 = deliver_request(v19, v14);
                  if (!v20 || (int v21 = v20, v20 == -65541))
                  {
                    *int v17 = *(void *)v10;
                    ++rref_finalized;
                    int v22 = (void *)*((void *)v10 + 7);
                    if (v22) {
                      free(v22);
                    }
                    free(v10);
                    int v23 = *(_DWORD *)a2;
                    if (*(_DWORD *)a2)
                    {
                      int v8 = global_os_log;
                      if (v23 < 10001)
                      {
                        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_DWORD *)int buf = 136447490;
                          *(void *)&uint8_t buf[4] = "srp_mdns_shared_record_remove";
                          __int16 v37 = 1024;
                          *(_DWORD *)uint64_t v38 = v23;
                          *(_WORD *)&v38[4] = 2048;
                          *(void *)&v38[6] = a2;
                          *(_WORD *)&v38[14] = 2080;
                          *(void *)&v38[16] = "record";
                          *(_WORD *)&v38[24] = 2080;
                          *(void *)&v38[26] = "srp-mdns-proxy.c";
                          __int16 v39 = 1024;
                          int v40 = 145;
                          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                          int v23 = *(_DWORD *)a2;
                        }
                        *(_DWORD *)a2 = v23 - 1;
                        if (v23 == 1)
                        {
                          uint64_t v24 = global_os_log;
                          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                          {
                            *(_DWORD *)int buf = 136447234;
                            *(void *)&uint8_t buf[4] = "srp_mdns_shared_record_remove";
                            __int16 v37 = 2048;
                            *(void *)uint64_t v38 = a2;
                            *(_WORD *)&v38[8] = 2080;
                            *(void *)&v38[10] = "record";
                            *(_WORD *)&unsigned char v38[18] = 2080;
                            *(void *)&v38[20] = "srp-mdns-proxy.c";
                            *(_WORD *)&v38[28] = 1024;
                            *(_DWORD *)&v38[30] = 145;
                            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
                          }
                          ++adv_record_finalized;
                          adv_record_finalize(a2);
                        }
                        goto LABEL_53;
                      }
                      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                      {
                        *(_DWORD *)int buf = 136447490;
                        *(void *)&uint8_t buf[4] = "srp_mdns_shared_record_remove";
                        __int16 v37 = 1024;
                        *(_DWORD *)uint64_t v38 = v23;
                        *(_WORD *)&v38[4] = 2048;
                        *(void *)&v38[6] = a2;
                        *(_WORD *)&v38[14] = 2080;
                        *(void *)&v38[16] = "record";
                        *(_WORD *)&v38[24] = 2080;
                        *(void *)&v38[26] = "srp-mdns-proxy.c";
                        __int16 v39 = 1024;
                        int v40 = 145;
                        double v9 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
                        goto LABEL_67;
                      }
                    }
                    else
                    {
                      int v8 = global_os_log;
                      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                      {
                        *(_DWORD *)int buf = 136447490;
                        *(void *)&uint8_t buf[4] = "srp_mdns_shared_record_remove";
                        __int16 v37 = 1024;
                        *(_DWORD *)uint64_t v38 = 0;
                        *(_WORD *)&v38[4] = 2048;
                        *(void *)&v38[6] = a2;
                        *(_WORD *)&v38[14] = 2080;
                        *(void *)&v38[16] = "record";
                        *(_WORD *)&v38[24] = 2080;
                        *(void *)&v38[26] = "srp-mdns-proxy.c";
                        __int16 v39 = 1024;
                        int v40 = 145;
                        double v9 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_67:
                        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, v9, buf, 0x36u);
                      }
                    }
LABEL_68:
                    abort();
                  }
                }
                else
                {
                  int v21 = -65541;
                  syslog(4, "dnssd_clientstub DNSServiceRemoveRecord called with invalid DNSRecordRef %p %08X %08X");
                }
              }
            }
            else
            {
              int v21 = -65541;
              syslog(4, "dnssd_clientstub DNSServiceRemoveRecord called with bad DNSServiceRef");
            }
            goto LABEL_50;
          }
          syslog(4, "dnssd_clientstub DNSServiceRemoveRecord called with NULL DNSRecordRef");
        }
        else
        {
          syslog(4, "dnssd_clientstub DNSServiceRemoveRecord called with NULL DNSServiceRef");
        }
        int v21 = -65540;
LABEL_50:
        if (*(unsigned char *)(a2 + 52)) {
          goto LABEL_53;
        }
        uint64_t v30 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_53;
        }
        uint64_t v31 = *(void *)(*(void *)(a1 + 16) + 8);
        uint64_t v32 = *(void *)(a2 + 8);
        *(_DWORD *)int buf = 136447234;
        *(void *)&uint8_t buf[4] = "srp_mdns_shared_record_remove";
        __int16 v37 = 2048;
        *(void *)uint64_t v38 = v31;
        *(_WORD *)&v38[8] = 2048;
        *(void *)&v38[10] = a2;
        *(_WORD *)&unsigned char v38[18] = 2048;
        *(void *)&v38[20] = v32;
        *(_WORD *)&v38[28] = 1024;
        *(_DWORD *)&v38[30] = v21;
        double v26 = "%{public}s: DNSServiceRemoveRecord(%p, %p, %p, 0) returned %d";
        os_log_type_t v27 = v30;
        os_log_type_t v28 = OS_LOG_TYPE_FAULT;
        uint32_t v29 = 48;
        goto LABEL_43;
      }
    }
    else
    {
      uint64_t v13 = global_os_log;
    }
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
LABEL_53:
      *(void *)(a2 + 8) = 0;
      goto LABEL_54;
    }
    uint64_t v25 = *(void *)(a1 + 16);
    *(_DWORD *)int buf = 136446978;
    *(void *)&uint8_t buf[4] = "srp_mdns_shared_record_remove";
    __int16 v37 = 2048;
    *(void *)uint64_t v38 = v10;
    *(_WORD *)&v38[8] = 2048;
    *(void *)&v38[10] = v11;
    *(_WORD *)&unsigned char v38[18] = 2048;
    *(void *)&v38[20] = v25;
    double v26 = "%{public}s: didn't remove stale rref %p because %lx != %p";
    os_log_type_t v27 = v13;
    os_log_type_t v28 = OS_LOG_TYPE_DEFAULT;
    uint32_t v29 = 42;
LABEL_43:
    _os_log_impl((void *)&_mh_execute_header, v27, v28, v26, buf, v29);
    goto LABEL_53;
  }
LABEL_54:
  *(void *)(a2 + 24) = 0;
  int v33 = *(_DWORD *)a2;
  if (!*(_DWORD *)a2)
  {
    int v8 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_68;
    }
    *(_DWORD *)int buf = 136447490;
    *(void *)&uint8_t buf[4] = "srp_mdns_shared_record_remove";
    __int16 v37 = 1024;
    *(_DWORD *)uint64_t v38 = 0;
    *(_WORD *)&v38[4] = 2048;
    *(void *)&v38[6] = a2;
    *(_WORD *)&v38[14] = 2080;
    *(void *)&v38[16] = "record";
    *(_WORD *)&v38[24] = 2080;
    *(void *)&v38[26] = "srp-mdns-proxy.c";
    __int16 v39 = 1024;
    int v40 = 161;
    double v9 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_67;
  }
  int v8 = global_os_log;
  if (v33 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_68;
    }
    *(_DWORD *)int buf = 136447490;
    *(void *)&uint8_t buf[4] = "srp_mdns_shared_record_remove";
    __int16 v37 = 1024;
    *(_DWORD *)uint64_t v38 = v33;
    *(_WORD *)&v38[4] = 2048;
    *(void *)&v38[6] = a2;
    *(_WORD *)&v38[14] = 2080;
    *(void *)&v38[16] = "record";
    *(_WORD *)&v38[24] = 2080;
    *(void *)&v38[26] = "srp-mdns-proxy.c";
    __int16 v39 = 1024;
    int v40 = 161;
    double v9 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_67;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136447490;
    *(void *)&uint8_t buf[4] = "srp_mdns_shared_record_remove";
    __int16 v37 = 1024;
    *(_DWORD *)uint64_t v38 = v33;
    *(_WORD *)&v38[4] = 2048;
    *(void *)&v38[6] = a2;
    *(_WORD *)&v38[14] = 2080;
    *(void *)&v38[16] = "record";
    *(_WORD *)&v38[24] = 2080;
    *(void *)&v38[26] = "srp-mdns-proxy.c";
    __int16 v39 = 1024;
    int v40 = 161;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    int v33 = *(_DWORD *)a2;
  }
  *(_DWORD *)a2 = v33 - 1;
  if (v33 == 1)
  {
    uint64_t v34 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136447234;
      *(void *)&uint8_t buf[4] = "srp_mdns_shared_record_remove";
      __int16 v37 = 2048;
      *(void *)uint64_t v38 = a2;
      *(_WORD *)&v38[8] = 2080;
      *(void *)&v38[10] = "record";
      *(_WORD *)&unsigned char v38[18] = 2080;
      *(void *)&v38[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v38[28] = 1024;
      *(_DWORD *)&v38[30] = 161;
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
    }
    ++adv_record_finalized;
    adv_record_finalize(a2);
  }
}

void adv_record_finalize(uint64_t a1)
{
  uint64_t v2 = *(int **)(a1 + 32);
  if (v2)
  {
    int v3 = *v2;
    if (!*v2)
    {
      uint64_t v9 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_31;
      }
      int v12 = 136447490;
      uint64_t v13 = "adv_record_finalize";
      __int16 v14 = 1024;
      *(_DWORD *)int v15 = 0;
      *(_WORD *)&_OWORD v15[4] = 2048;
      *(void *)&v15[6] = v2;
      *(_WORD *)&v15[14] = 2080;
      *(void *)&v15[16] = "record->update";
      *(_WORD *)&v15[24] = 2080;
      *(void *)&v15[26] = "srp-mdns-proxy.c";
      __int16 v16 = 1024;
      int v17 = 171;
      uint64_t v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_26:
      uint64_t v11 = v9;
LABEL_30:
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v12, 0x36u);
LABEL_31:
      abort();
    }
    uint32_t v4 = global_os_log;
    if (v3 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_31;
      }
      int v12 = 136447490;
      uint64_t v13 = "adv_record_finalize";
      __int16 v14 = 1024;
      *(_DWORD *)int v15 = v3;
      *(_WORD *)&_OWORD v15[4] = 2048;
      *(void *)&v15[6] = v2;
      *(_WORD *)&v15[14] = 2080;
      *(void *)&v15[16] = "record->update";
      *(_WORD *)&v15[24] = 2080;
      *(void *)&v15[26] = "srp-mdns-proxy.c";
      __int16 v16 = 1024;
      int v17 = 171;
      uint64_t v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_29:
      uint64_t v11 = v4;
      goto LABEL_30;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = 136447490;
      uint64_t v13 = "adv_record_finalize";
      __int16 v14 = 1024;
      *(_DWORD *)int v15 = v3;
      *(_WORD *)&_OWORD v15[4] = 2048;
      *(void *)&v15[6] = v2;
      *(_WORD *)&v15[14] = 2080;
      *(void *)&v15[16] = "record->update";
      *(_WORD *)&v15[24] = 2080;
      *(void *)&v15[26] = "srp-mdns-proxy.c";
      __int16 v16 = 1024;
      int v17 = 171;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v12, 0x36u);
      uint64_t v2 = *(int **)(a1 + 32);
      int v3 = *v2;
    }
    *uint64_t v2 = v3 - 1;
    if (v3 == 1)
    {
      int v5 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v12 = 136447234;
        uint64_t v13 = "adv_record_finalize";
        __int16 v14 = 2048;
        *(void *)int v15 = v2;
        *(_WORD *)&v15[8] = 2080;
        *(void *)&v15[10] = "record->update";
        *(_WORD *)&v15[18] = 2080;
        *(void *)&v15[20] = "srp-mdns-proxy.c";
        *(_WORD *)&v15[28] = 1024;
        *(_DWORD *)&v15[30] = 171;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v12, 0x30u);
        uint64_t v2 = *(int **)(a1 + 32);
      }
      ++adv_update_finalized;
      adv_update_finalize((uint64_t)v2);
    }
  }
  int v6 = *(int **)(a1 + 16);
  if (!v6) {
    goto LABEL_19;
  }
  int v7 = *v6;
  if (!*v6)
  {
    uint64_t v9 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_31;
    }
    int v12 = 136447490;
    uint64_t v13 = "adv_record_finalize";
    __int16 v14 = 1024;
    *(_DWORD *)int v15 = 0;
    *(_WORD *)&_OWORD v15[4] = 2048;
    *(void *)&v15[6] = v6;
    *(_WORD *)&v15[14] = 2080;
    *(void *)&v15[16] = "record->host";
    *(_WORD *)&v15[24] = 2080;
    *(void *)&v15[26] = "srp-mdns-proxy.c";
    __int16 v16 = 1024;
    int v17 = 174;
    uint64_t v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_26;
  }
  uint32_t v4 = global_os_log;
  if (v7 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_31;
    }
    int v12 = 136447490;
    uint64_t v13 = "adv_record_finalize";
    __int16 v14 = 1024;
    *(_DWORD *)int v15 = v7;
    *(_WORD *)&_OWORD v15[4] = 2048;
    *(void *)&v15[6] = v6;
    *(_WORD *)&v15[14] = 2080;
    *(void *)&v15[16] = "record->host";
    *(_WORD *)&v15[24] = 2080;
    *(void *)&v15[26] = "srp-mdns-proxy.c";
    __int16 v16 = 1024;
    int v17 = 174;
    uint64_t v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_29;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v12 = 136447490;
    uint64_t v13 = "adv_record_finalize";
    __int16 v14 = 1024;
    *(_DWORD *)int v15 = v7;
    *(_WORD *)&_OWORD v15[4] = 2048;
    *(void *)&v15[6] = v6;
    *(_WORD *)&v15[14] = 2080;
    *(void *)&v15[16] = "record->host";
    *(_WORD *)&v15[24] = 2080;
    *(void *)&v15[26] = "srp-mdns-proxy.c";
    __int16 v16 = 1024;
    int v17 = 174;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v12, 0x36u);
    int v6 = *(int **)(a1 + 16);
    int v7 = *v6;
  }
  *int v6 = v7 - 1;
  if (v7 == 1)
  {
    int v8 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = 136447234;
      uint64_t v13 = "adv_record_finalize";
      __int16 v14 = 2048;
      *(void *)int v15 = v6;
      *(_WORD *)&v15[8] = 2080;
      *(void *)&v15[10] = "record->host";
      *(_WORD *)&v15[18] = 2080;
      *(void *)&v15[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v15[28] = 1024;
      *(_DWORD *)&v15[30] = 174;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v12, 0x30u);
      int v6 = *(int **)(a1 + 16);
    }
    ++adv_host_finalized;
    adv_host_finalize((uint64_t)v6);
  }
LABEL_19:
  free(*(void **)(a1 + 40));
  free((void *)a1);
}

void adv_update_finalize(uint64_t a1)
{
  uint64_t v2 = *(int **)(a1 + 8);
  if (v2)
  {
    int v3 = *v2;
    if (!*v2)
    {
      uint64_t v18 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_61;
      }
      int v21 = 136447490;
      int v22 = "adv_update_finalize";
      __int16 v23 = 1024;
      *(_DWORD *)uint64_t v24 = 0;
      *(_WORD *)&v24[4] = 2048;
      *(void *)&v24[6] = v2;
      *(_WORD *)&v24[14] = 2080;
      *(void *)&v24[16] = "update->host";
      *(_WORD *)&v24[24] = 2080;
      *(void *)&v24[26] = "srp-mdns-proxy.c";
      __int16 v25 = 1024;
      int v26 = 916;
      __int16 v19 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_56:
      int v20 = v18;
LABEL_60:
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_FAULT, v19, (uint8_t *)&v21, 0x36u);
LABEL_61:
      abort();
    }
    uint32_t v4 = global_os_log;
    if (v3 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_61;
      }
      int v21 = 136447490;
      int v22 = "adv_update_finalize";
      __int16 v23 = 1024;
      *(_DWORD *)uint64_t v24 = v3;
      *(_WORD *)&v24[4] = 2048;
      *(void *)&v24[6] = v2;
      *(_WORD *)&v24[14] = 2080;
      *(void *)&v24[16] = "update->host";
      *(_WORD *)&v24[24] = 2080;
      *(void *)&v24[26] = "srp-mdns-proxy.c";
      __int16 v25 = 1024;
      int v26 = 916;
      __int16 v19 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_59:
      int v20 = v4;
      goto LABEL_60;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v21 = 136447490;
      int v22 = "adv_update_finalize";
      __int16 v23 = 1024;
      *(_DWORD *)uint64_t v24 = v3;
      *(_WORD *)&v24[4] = 2048;
      *(void *)&v24[6] = v2;
      *(_WORD *)&v24[14] = 2080;
      *(void *)&v24[16] = "update->host";
      *(_WORD *)&v24[24] = 2080;
      *(void *)&v24[26] = "srp-mdns-proxy.c";
      __int16 v25 = 1024;
      int v26 = 916;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v21, 0x36u);
      uint64_t v2 = *(int **)(a1 + 8);
      int v3 = *v2;
    }
    *uint64_t v2 = v3 - 1;
    if (v3 == 1)
    {
      int v5 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v21 = 136447234;
        int v22 = "adv_update_finalize";
        __int16 v23 = 2048;
        *(void *)uint64_t v24 = v2;
        *(_WORD *)&v24[8] = 2080;
        *(void *)&v24[10] = "update->host";
        *(_WORD *)&v24[18] = 2080;
        *(void *)&v24[20] = "srp-mdns-proxy.c";
        *(_WORD *)&v24[28] = 1024;
        *(_DWORD *)&v24[30] = 916;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v21, 0x30u);
        uint64_t v2 = *(int **)(a1 + 8);
      }
      ++adv_host_finalized;
      adv_host_finalize((uint64_t)v2);
    }
  }
  int v6 = *(void **)(a1 + 16);
  if (v6)
  {
    srp_parse_client_updates_free_(v6, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 920);
    *(void *)(a1 + 16) = 0;
  }
  uint64_t v7 = *(void *)(a1 + 32);
  if (v7)
  {
    adv_record_vec_remove_update(v7, (int *)a1);
    int v8 = *(int **)(a1 + 32);
    if (v8)
    {
      int v9 = *v8;
      if (!*v8)
      {
        uint64_t v18 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_61;
        }
        int v21 = 136447490;
        int v22 = "adv_update_finalize";
        __int16 v23 = 1024;
        *(_DWORD *)uint64_t v24 = 0;
        *(_WORD *)&v24[4] = 2048;
        *(void *)&v24[6] = v8;
        *(_WORD *)&v24[14] = 2080;
        *(void *)&v24[16] = "update->remove_addresses";
        *(_WORD *)&v24[24] = 2080;
        *(void *)&v24[26] = "srp-mdns-proxy.c";
        __int16 v25 = 1024;
        int v26 = 926;
        __int16 v19 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_56;
      }
      uint32_t v4 = global_os_log;
      if (v9 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_61;
        }
        int v21 = 136447490;
        int v22 = "adv_update_finalize";
        __int16 v23 = 1024;
        *(_DWORD *)uint64_t v24 = v9;
        *(_WORD *)&v24[4] = 2048;
        *(void *)&v24[6] = v8;
        *(_WORD *)&v24[14] = 2080;
        *(void *)&v24[16] = "update->remove_addresses";
        *(_WORD *)&v24[24] = 2080;
        *(void *)&v24[26] = "srp-mdns-proxy.c";
        __int16 v25 = 1024;
        int v26 = 926;
        __int16 v19 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_59;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v21 = 136447490;
        int v22 = "adv_update_finalize";
        __int16 v23 = 1024;
        *(_DWORD *)uint64_t v24 = v9;
        *(_WORD *)&v24[4] = 2048;
        *(void *)&v24[6] = v8;
        *(_WORD *)&v24[14] = 2080;
        *(void *)&v24[16] = "update->remove_addresses";
        *(_WORD *)&v24[24] = 2080;
        *(void *)&v24[26] = "srp-mdns-proxy.c";
        __int16 v25 = 1024;
        int v26 = 926;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v21, 0x36u);
        int v8 = *(int **)(a1 + 32);
        int v9 = *v8;
      }
      *int v8 = v9 - 1;
      if (v9 == 1)
      {
        uint64_t v10 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v21 = 136447234;
          int v22 = "adv_update_finalize";
          __int16 v23 = 2048;
          *(void *)uint64_t v24 = v8;
          *(_WORD *)&v24[8] = 2080;
          *(void *)&v24[10] = "update->remove_addresses";
          *(_WORD *)&v24[18] = 2080;
          *(void *)&v24[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v24[28] = 1024;
          *(_DWORD *)&v24[30] = 926;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v21, 0x30u);
          int v8 = *(int **)(a1 + 32);
        }
        ++adv_record_vec_finalized;
        adv_record_vec_finalize((uint64_t)v8);
      }
    }
  }
  uint64_t v11 = *(void *)(a1 + 40);
  if (v11)
  {
    adv_record_vec_remove_update(v11, (int *)a1);
    int v12 = *(int **)(a1 + 40);
    if (v12)
    {
      int v13 = *v12;
      if (!*v12)
      {
        uint64_t v18 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_61;
        }
        int v21 = 136447490;
        int v22 = "adv_update_finalize";
        __int16 v23 = 1024;
        *(_DWORD *)uint64_t v24 = 0;
        *(_WORD *)&v24[4] = 2048;
        *(void *)&v24[6] = v12;
        *(_WORD *)&v24[14] = 2080;
        *(void *)&v24[16] = "update->add_addresses";
        *(_WORD *)&v24[24] = 2080;
        *(void *)&v24[26] = "srp-mdns-proxy.c";
        __int16 v25 = 1024;
        int v26 = 931;
        __int16 v19 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_56;
      }
      uint32_t v4 = global_os_log;
      if (v13 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_61;
        }
        int v21 = 136447490;
        int v22 = "adv_update_finalize";
        __int16 v23 = 1024;
        *(_DWORD *)uint64_t v24 = v13;
        *(_WORD *)&v24[4] = 2048;
        *(void *)&v24[6] = v12;
        *(_WORD *)&v24[14] = 2080;
        *(void *)&v24[16] = "update->add_addresses";
        *(_WORD *)&v24[24] = 2080;
        *(void *)&v24[26] = "srp-mdns-proxy.c";
        __int16 v25 = 1024;
        int v26 = 931;
        __int16 v19 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_59;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v21 = 136447490;
        int v22 = "adv_update_finalize";
        __int16 v23 = 1024;
        *(_DWORD *)uint64_t v24 = v13;
        *(_WORD *)&v24[4] = 2048;
        *(void *)&v24[6] = v12;
        *(_WORD *)&v24[14] = 2080;
        *(void *)&v24[16] = "update->add_addresses";
        *(_WORD *)&v24[24] = 2080;
        *(void *)&v24[26] = "srp-mdns-proxy.c";
        __int16 v25 = 1024;
        int v26 = 931;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v21, 0x36u);
        int v12 = *(int **)(a1 + 40);
        int v13 = *v12;
      }
      int *v12 = v13 - 1;
      if (v13 == 1)
      {
        __int16 v14 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v21 = 136447234;
          int v22 = "adv_update_finalize";
          __int16 v23 = 2048;
          *(void *)uint64_t v24 = v12;
          *(_WORD *)&v24[8] = 2080;
          *(void *)&v24[10] = "update->add_addresses";
          *(_WORD *)&v24[18] = 2080;
          *(void *)&v24[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v24[28] = 1024;
          *(_DWORD *)&v24[30] = 931;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v21, 0x30u);
          int v12 = *(int **)(a1 + 40);
        }
        ++adv_record_vec_finalized;
        adv_record_vec_finalize((uint64_t)v12);
      }
    }
  }
  adv_update_free_instance_vectors(a1);
  int v15 = *(int **)(a1 + 48);
  if (!v15) {
    goto LABEL_41;
  }
  int v16 = *v15;
  if (!*v15)
  {
    uint64_t v18 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_61;
    }
    int v21 = 136447490;
    int v22 = "adv_update_finalize";
    __int16 v23 = 1024;
    *(_DWORD *)uint64_t v24 = 0;
    *(_WORD *)&v24[4] = 2048;
    *(void *)&v24[6] = v15;
    *(_WORD *)&v24[14] = 2080;
    *(void *)&v24[16] = "update->key";
    *(_WORD *)&v24[24] = 2080;
    *(void *)&v24[26] = "srp-mdns-proxy.c";
    __int16 v25 = 1024;
    int v26 = 936;
    __int16 v19 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_56;
  }
  uint32_t v4 = global_os_log;
  if (v16 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_61;
    }
    int v21 = 136447490;
    int v22 = "adv_update_finalize";
    __int16 v23 = 1024;
    *(_DWORD *)uint64_t v24 = v16;
    *(_WORD *)&v24[4] = 2048;
    *(void *)&v24[6] = v15;
    *(_WORD *)&v24[14] = 2080;
    *(void *)&v24[16] = "update->key";
    *(_WORD *)&v24[24] = 2080;
    *(void *)&v24[26] = "srp-mdns-proxy.c";
    __int16 v25 = 1024;
    int v26 = 936;
    __int16 v19 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_59;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v21 = 136447490;
    int v22 = "adv_update_finalize";
    __int16 v23 = 1024;
    *(_DWORD *)uint64_t v24 = v16;
    *(_WORD *)&v24[4] = 2048;
    *(void *)&v24[6] = v15;
    *(_WORD *)&v24[14] = 2080;
    *(void *)&v24[16] = "update->key";
    *(_WORD *)&v24[24] = 2080;
    *(void *)&v24[26] = "srp-mdns-proxy.c";
    __int16 v25 = 1024;
    int v26 = 936;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v21, 0x36u);
    int v15 = *(int **)(a1 + 48);
    int v16 = *v15;
  }
  *int v15 = v16 - 1;
  if (v16 == 1)
  {
    int v17 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v21 = 136447234;
      int v22 = "adv_update_finalize";
      __int16 v23 = 2048;
      *(void *)uint64_t v24 = v15;
      *(_WORD *)&v24[8] = 2080;
      *(void *)&v24[10] = "update->key";
      *(_WORD *)&v24[18] = 2080;
      *(void *)&v24[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v24[28] = 1024;
      *(_DWORD *)&v24[30] = 936;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v21, 0x30u);
      int v15 = *(int **)(a1 + 48);
    }
    ++adv_record_finalized;
    adv_record_finalize(v15);
  }
LABEL_41:
  free((void *)a1);
}

void adv_host_finalize(uint64_t a1)
{
  host_invalidate(a1);
  uint64_t v2 = *(int **)(a1 + 96);
  if (v2)
  {
    int v3 = *v2;
    if (!*v2)
    {
      uint64_t v19 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_53;
      }
      int v22 = 136447490;
      __int16 v23 = "adv_host_finalize";
      __int16 v24 = 1024;
      *(_DWORD *)__int16 v25 = 0;
      *(_WORD *)&v25[4] = 2048;
      *(void *)&v25[6] = v2;
      *(_WORD *)&v25[14] = 2080;
      *(void *)&v25[16] = "host->addresses";
      *(_WORD *)&v25[24] = 2080;
      *(void *)&v25[26] = "srp-mdns-proxy.c";
      __int16 v26 = 1024;
      int v27 = 1124;
      int v20 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_48;
    }
    uint32_t v4 = global_os_log;
    if (v3 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_53;
      }
      int v22 = 136447490;
      __int16 v23 = "adv_host_finalize";
      __int16 v24 = 1024;
      *(_DWORD *)__int16 v25 = v3;
      *(_WORD *)&v25[4] = 2048;
      *(void *)&v25[6] = v2;
      *(_WORD *)&v25[14] = 2080;
      *(void *)&v25[16] = "host->addresses";
      *(_WORD *)&v25[24] = 2080;
      *(void *)&v25[26] = "srp-mdns-proxy.c";
      __int16 v26 = 1024;
      int v27 = 1124;
      int v20 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_51:
      int v21 = v4;
      goto LABEL_52;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v22 = 136447490;
      __int16 v23 = "adv_host_finalize";
      __int16 v24 = 1024;
      *(_DWORD *)__int16 v25 = v3;
      *(_WORD *)&v25[4] = 2048;
      *(void *)&v25[6] = v2;
      *(_WORD *)&v25[14] = 2080;
      *(void *)&v25[16] = "host->addresses";
      *(_WORD *)&v25[24] = 2080;
      *(void *)&v25[26] = "srp-mdns-proxy.c";
      __int16 v26 = 1024;
      int v27 = 1124;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v22, 0x36u);
      uint64_t v2 = *(int **)(a1 + 96);
      int v3 = *v2;
    }
    *uint64_t v2 = v3 - 1;
    if (v3 == 1)
    {
      int v5 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v22 = 136447234;
        __int16 v23 = "adv_host_finalize";
        __int16 v24 = 2048;
        *(void *)__int16 v25 = v2;
        *(_WORD *)&v25[8] = 2080;
        *(void *)&v25[10] = "host->addresses";
        *(_WORD *)&v25[18] = 2080;
        *(void *)&v25[20] = "srp-mdns-proxy.c";
        *(_WORD *)&v25[28] = 1024;
        *(_DWORD *)&v25[30] = 1124;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v22, 0x30u);
        uint64_t v2 = *(int **)(a1 + 96);
      }
      ++adv_record_vec_finalized;
      adv_record_vec_finalize((uint64_t)v2);
    }
    *(void *)(a1 + 96) = 0;
  }
  int v6 = *(void **)(a1 + 240);
  if (v6)
  {
    free(v6);
    *(void *)(a1 + 240) = 0;
  }
  uint64_t v7 = *(int **)(a1 + 104);
  if (v7)
  {
    int v8 = *v7;
    if (*v7)
    {
      uint32_t v4 = global_os_log;
      if (v8 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v22 = 136447490;
          __int16 v23 = "adv_host_finalize";
          __int16 v24 = 1024;
          *(_DWORD *)__int16 v25 = v8;
          *(_WORD *)&v25[4] = 2048;
          *(void *)&v25[6] = v7;
          *(_WORD *)&v25[14] = 2080;
          *(void *)&v25[16] = "host->key_record";
          *(_WORD *)&v25[24] = 2080;
          *(void *)&v25[26] = "srp-mdns-proxy.c";
          __int16 v26 = 1024;
          int v27 = 1133;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v22, 0x36u);
          uint64_t v7 = *(int **)(a1 + 104);
          int v8 = *v7;
        }
        int *v7 = v8 - 1;
        if (v8 == 1)
        {
          int v9 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v22 = 136447234;
            __int16 v23 = "adv_host_finalize";
            __int16 v24 = 2048;
            *(void *)__int16 v25 = v7;
            *(_WORD *)&v25[8] = 2080;
            *(void *)&v25[10] = "host->key_record";
            *(_WORD *)&v25[18] = 2080;
            *(void *)&v25[20] = "srp-mdns-proxy.c";
            *(_WORD *)&v25[28] = 1024;
            *(_DWORD *)&v25[30] = 1133;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v22, 0x30u);
            uint64_t v7 = *(int **)(a1 + 104);
          }
          ++adv_record_finalized;
          adv_record_finalize(v7);
        }
        *(void *)(a1 + 104) = 0;
        goto LABEL_23;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_53:
      }
        abort();
      int v22 = 136447490;
      __int16 v23 = "adv_host_finalize";
      __int16 v24 = 1024;
      *(_DWORD *)__int16 v25 = v8;
      *(_WORD *)&v25[4] = 2048;
      *(void *)&v25[6] = v7;
      *(_WORD *)&v25[14] = 2080;
      *(void *)&v25[16] = "host->key_record";
      *(_WORD *)&v25[24] = 2080;
      *(void *)&v25[26] = "srp-mdns-proxy.c";
      __int16 v26 = 1024;
      int v27 = 1133;
      int v20 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_51;
    }
    uint64_t v19 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_53;
    }
    int v22 = 136447490;
    __int16 v23 = "adv_host_finalize";
    __int16 v24 = 1024;
    *(_DWORD *)__int16 v25 = 0;
    *(_WORD *)&v25[4] = 2048;
    *(void *)&v25[6] = v7;
    *(_WORD *)&v25[14] = 2080;
    *(void *)&v25[16] = "host->key_record";
    *(_WORD *)&v25[24] = 2080;
    *(void *)&v25[26] = "srp-mdns-proxy.c";
    __int16 v26 = 1024;
    int v27 = 1133;
    int v20 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_48:
    int v21 = v19;
LABEL_52:
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_FAULT, v20, (uint8_t *)&v22, 0x36u);
    goto LABEL_53;
  }
LABEL_23:
  uint64_t v10 = *(int **)(a1 + 72);
  if (v10)
  {
    ioloop_message_release_(v10, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1138);
    *(void *)(a1 + 72) = 0;
  }
  uint64_t v11 = *(void *)(a1 + 32);
  if (v11)
  {
    ioloop_cancel_wake_event(v11);
    ioloop_wakeup_release_(*(void **)(a1 + 32), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1145);
    *(void *)(a1 + 32) = 0;
  }
  uint64_t v12 = *(void *)(a1 + 24);
  if (v12)
  {
    ioloop_cancel_wake_event(v12);
    ioloop_wakeup_release_(*(void **)(a1 + 24), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1151);
    *(void *)(a1 + 24) = 0;
  }
  uint64_t v13 = *(void *)(a1 + 16);
  if (v13)
  {
    ioloop_cancel_wake_event(v13);
    ioloop_wakeup_release_(*(void **)(a1 + 16), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1157);
    *(void *)(a1 + 16) = 0;
  }
  __int16 v14 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v15 = *(const char **)(a1 + 56);
    if (!v15) {
      int v15 = "<null>";
    }
    int v16 = *(_DWORD *)(a1 + 184);
    int v22 = 136446979;
    __int16 v23 = "adv_host_finalize";
    __int16 v24 = 2160;
    *(void *)__int16 v25 = 1752392040;
    *(_WORD *)&v25[8] = 2081;
    *(void *)&v25[10] = v15;
    *(_WORD *)&v25[18] = 1024;
    *(_DWORD *)&v25[20] = v16;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: removed %{private, mask.hash}s, key_id %x", (uint8_t *)&v22, 0x26u);
  }
  uint64_t v18 = *(void **)(a1 + 56);
  int v17 = *(void **)(a1 + 64);
  if (v17 == v18)
  {
    int v17 = 0;
    *(void *)(a1 + 64) = 0;
  }
  if (v18)
  {
    free(v18);
    int v17 = *(void **)(a1 + 64);
  }
  if (v17) {
    free(v17);
  }
  free((void *)a1);
}

void host_invalidate(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2) {
    ioloop_cancel_wake_event(v2);
  }
  uint64_t v3 = *(void *)(a1 + 16);
  if (v3) {
    ioloop_cancel_wake_event(v3);
  }
  uint64_t v4 = *(void *)(a1 + 96);
  if (v4)
  {
    if (*(int *)(v4 + 4) >= 1)
    {
      for (uint64_t i = 0; i < *(int *)(v4 + 4); ++i)
      {
        uint64_t v6 = *(void *)(*(void *)(v4 + 8) + 8 * i);
        if (v6)
        {
          uint64_t v7 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v8 = *(void *)(a1 + 64);
            *(_DWORD *)int buf = 136446723;
            uint64_t v30 = "host_addr_free";
            __int16 v31 = 2160;
            *(void *)uint64_t v32 = 1752392040;
            *(_WORD *)&v32[8] = 2081;
            *(void *)&v32[10] = v8;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: Removing AAAA record for %{private, mask.hash}s", buf, 0x20u);
            uint64_t v6 = *(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 8 * i);
          }
          srp_mdns_shared_record_remove(*(void *)(a1 + 8), v6);
          uint64_t v9 = *(void *)(*(void *)(a1 + 96) + 8);
          uint64_t v10 = *(int **)(v9 + 8 * i);
          if (v10)
          {
            int v11 = *v10;
            if (!*v10)
            {
              uint64_t v26 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                goto LABEL_75;
              }
              *(_DWORD *)int buf = 136447490;
              uint64_t v30 = "host_addr_free";
              __int16 v31 = 1024;
              *(_DWORD *)uint64_t v32 = 0;
              *(_WORD *)&v32[4] = 2048;
              *(void *)&v32[6] = v10;
              *(_WORD *)&v32[14] = 2080;
              *(void *)&v32[16] = "host->addresses->vec[i]";
              *(_WORD *)&v32[24] = 2080;
              *(void *)&v32[26] = "srp-mdns-proxy.c";
              __int16 v33 = 1024;
              int v34 = 1072;
              int v27 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
              goto LABEL_58;
            }
            uint64_t v12 = global_os_log;
            if (v11 >= 10001)
            {
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)int buf = 136447490;
                uint64_t v30 = "host_addr_free";
                __int16 v31 = 1024;
                *(_DWORD *)uint64_t v32 = v11;
                *(_WORD *)&v32[4] = 2048;
                *(void *)&v32[6] = v10;
                *(_WORD *)&v32[14] = 2080;
                *(void *)&v32[16] = "host->addresses->vec[i]";
                *(_WORD *)&v32[24] = 2080;
                *(void *)&v32[26] = "srp-mdns-proxy.c";
                __int16 v33 = 1024;
                int v34 = 1072;
                int v27 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
                os_log_type_t v28 = v12;
                goto LABEL_74;
              }
              goto LABEL_75;
            }
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)int buf = 136447490;
              uint64_t v30 = "host_addr_free";
              __int16 v31 = 1024;
              *(_DWORD *)uint64_t v32 = v11;
              *(_WORD *)&v32[4] = 2048;
              *(void *)&v32[6] = v10;
              *(_WORD *)&v32[14] = 2080;
              *(void *)&v32[16] = "host->addresses->vec[i]";
              *(_WORD *)&v32[24] = 2080;
              *(void *)&v32[26] = "srp-mdns-proxy.c";
              __int16 v33 = 1024;
              int v34 = 1072;
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
              uint64_t v9 = *(void *)(*(void *)(a1 + 96) + 8);
              uint64_t v10 = *(int **)(v9 + 8 * i);
              int v11 = *v10;
            }
            int *v10 = v11 - 1;
            if (v11 == 1)
            {
              uint64_t v13 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)int buf = 136447234;
                uint64_t v30 = "host_addr_free";
                __int16 v31 = 2048;
                *(void *)uint64_t v32 = v10;
                *(_WORD *)&v32[8] = 2080;
                *(void *)&v32[10] = "host->addresses->vec[i]";
                *(_WORD *)&v32[18] = 2080;
                *(void *)&v32[20] = "srp-mdns-proxy.c";
                *(_WORD *)&v32[28] = 1024;
                *(_DWORD *)&v32[30] = 1072;
                _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
                uint64_t v10 = *(int **)(*(void *)(*(void *)(a1 + 96) + 8) + 8 * i);
              }
              ++adv_record_finalized;
              adv_record_finalize(v10);
              uint64_t v9 = *(void *)(*(void *)(a1 + 96) + 8);
            }
          }
          *(void *)(v9 + 8 * i) = 0;
          uint64_t v4 = *(void *)(a1 + 96);
        }
      }
    }
    *(_DWORD *)(v4 + 4) = 0;
  }
  uint64_t v14 = *(void *)(a1 + 112);
  if (v14)
  {
    adv_instances_cancel(v14);
    int v15 = *(int **)(a1 + 112);
    if (v15)
    {
      int v16 = *v15;
      if (!*v15)
      {
        uint64_t v26 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_75;
        }
        *(_DWORD *)int buf = 136447490;
        uint64_t v30 = "host_invalidate";
        __int16 v31 = 1024;
        *(_DWORD *)uint64_t v32 = 0;
        *(_WORD *)&v32[4] = 2048;
        *(void *)&v32[6] = v15;
        *(_WORD *)&v32[14] = 2080;
        *(void *)&v32[16] = "host->instances";
        *(_WORD *)&v32[24] = 2080;
        *(void *)&v32[26] = "srp-mdns-proxy.c";
        __int16 v33 = 1024;
        int v34 = 1098;
        int v27 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_58;
      }
      int v17 = global_os_log;
      if (v16 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_75;
        }
        *(_DWORD *)int buf = 136447490;
        uint64_t v30 = "host_invalidate";
        __int16 v31 = 1024;
        *(_DWORD *)uint64_t v32 = v16;
        *(_WORD *)&v32[4] = 2048;
        *(void *)&v32[6] = v15;
        *(_WORD *)&v32[14] = 2080;
        *(void *)&v32[16] = "host->instances";
        *(_WORD *)&v32[24] = 2080;
        *(void *)&v32[26] = "srp-mdns-proxy.c";
        __int16 v33 = 1024;
        int v34 = 1098;
        int v27 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_73;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136447490;
        uint64_t v30 = "host_invalidate";
        __int16 v31 = 1024;
        *(_DWORD *)uint64_t v32 = v16;
        *(_WORD *)&v32[4] = 2048;
        *(void *)&v32[6] = v15;
        *(_WORD *)&v32[14] = 2080;
        *(void *)&v32[16] = "host->instances";
        *(_WORD *)&v32[24] = 2080;
        *(void *)&v32[26] = "srp-mdns-proxy.c";
        __int16 v33 = 1024;
        int v34 = 1098;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        int v15 = *(int **)(a1 + 112);
        int v16 = *v15;
      }
      *int v15 = v16 - 1;
      if (v16 == 1)
      {
        uint64_t v18 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447234;
          uint64_t v30 = "host_invalidate";
          __int16 v31 = 2048;
          *(void *)uint64_t v32 = v15;
          *(_WORD *)&v32[8] = 2080;
          *(void *)&v32[10] = "host->instances";
          *(_WORD *)&v32[18] = 2080;
          *(void *)&v32[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v32[28] = 1024;
          *(_DWORD *)&v32[30] = 1098;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          int v15 = *(int **)(a1 + 112);
        }
        ++adv_instance_vec_finalized;
        adv_instance_vec_finalize((uint64_t)v15);
      }
    }
    *(void *)(a1 + 112) = 0;
  }
  uint64_t v19 = *(int **)(a1 + 48);
  if (v19)
  {
    int v20 = *v19;
    if (!*v19)
    {
      uint64_t v26 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_75;
      }
      *(_DWORD *)int buf = 136447490;
      uint64_t v30 = "host_invalidate";
      __int16 v31 = 1024;
      *(_DWORD *)uint64_t v32 = 0;
      *(_WORD *)&v32[4] = 2048;
      *(void *)&v32[6] = v19;
      *(_WORD *)&v32[14] = 2080;
      *(void *)&v32[16] = "host->update";
      *(_WORD *)&v32[24] = 2080;
      *(void *)&v32[26] = "srp-mdns-proxy.c";
      __int16 v33 = 1024;
      int v34 = 1103;
      int v27 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_58;
    }
    int v17 = global_os_log;
    if (v20 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_75;
      }
      *(_DWORD *)int buf = 136447490;
      uint64_t v30 = "host_invalidate";
      __int16 v31 = 1024;
      *(_DWORD *)uint64_t v32 = v20;
      *(_WORD *)&v32[4] = 2048;
      *(void *)&v32[6] = v19;
      *(_WORD *)&v32[14] = 2080;
      *(void *)&v32[16] = "host->update";
      *(_WORD *)&v32[24] = 2080;
      *(void *)&v32[26] = "srp-mdns-proxy.c";
      __int16 v33 = 1024;
      int v34 = 1103;
      int v27 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_73;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136447490;
      uint64_t v30 = "host_invalidate";
      __int16 v31 = 1024;
      *(_DWORD *)uint64_t v32 = v20;
      *(_WORD *)&v32[4] = 2048;
      *(void *)&v32[6] = v19;
      *(_WORD *)&v32[14] = 2080;
      *(void *)&v32[16] = "host->update";
      *(_WORD *)&v32[24] = 2080;
      *(void *)&v32[26] = "srp-mdns-proxy.c";
      __int16 v33 = 1024;
      int v34 = 1103;
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      uint64_t v19 = *(int **)(a1 + 48);
      int v20 = *v19;
    }
    int *v19 = v20 - 1;
    if (v20 == 1)
    {
      int v21 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136447234;
        uint64_t v30 = "host_invalidate";
        __int16 v31 = 2048;
        *(void *)uint64_t v32 = v19;
        *(_WORD *)&v32[8] = 2080;
        *(void *)&v32[10] = "host->update";
        *(_WORD *)&v32[18] = 2080;
        *(void *)&v32[20] = "srp-mdns-proxy.c";
        *(_WORD *)&v32[28] = 1024;
        *(_DWORD *)&v32[30] = 1103;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        uint64_t v19 = *(int **)(a1 + 48);
      }
      ++adv_update_finalized;
      adv_update_finalize(v19);
    }
    *(void *)(a1 + 48) = 0;
  }
  uint64_t v22 = *(void *)(a1 + 104);
  if (v22)
  {
    srp_mdns_shared_record_remove(*(void *)(a1 + 8), v22);
    __int16 v23 = *(int **)(a1 + 104);
    if (!v23)
    {
LABEL_54:
      *(void *)(a1 + 104) = 0;
      goto LABEL_55;
    }
    int v24 = *v23;
    if (*v23)
    {
      int v17 = global_os_log;
      if (v24 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447490;
          uint64_t v30 = "host_invalidate";
          __int16 v31 = 1024;
          *(_DWORD *)uint64_t v32 = v24;
          *(_WORD *)&v32[4] = 2048;
          *(void *)&v32[6] = v23;
          *(_WORD *)&v32[14] = 2080;
          *(void *)&v32[16] = "host->key_record";
          *(_WORD *)&v32[24] = 2080;
          *(void *)&v32[26] = "srp-mdns-proxy.c";
          __int16 v33 = 1024;
          int v34 = 1108;
          _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          __int16 v23 = *(int **)(a1 + 104);
          int v24 = *v23;
        }
        *__int16 v23 = v24 - 1;
        if (v24 == 1)
        {
          __int16 v25 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136447234;
            uint64_t v30 = "host_invalidate";
            __int16 v31 = 2048;
            *(void *)uint64_t v32 = v23;
            *(_WORD *)&v32[8] = 2080;
            *(void *)&v32[10] = "host->key_record";
            *(_WORD *)&v32[18] = 2080;
            *(void *)&v32[20] = "srp-mdns-proxy.c";
            *(_WORD *)&v32[28] = 1024;
            *(_DWORD *)&v32[30] = 1108;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
            __int16 v23 = *(int **)(a1 + 104);
          }
          ++adv_record_finalized;
          adv_record_finalize(v23);
        }
        goto LABEL_54;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_75;
      }
      *(_DWORD *)int buf = 136447490;
      uint64_t v30 = "host_invalidate";
      __int16 v31 = 1024;
      *(_DWORD *)uint64_t v32 = v24;
      *(_WORD *)&v32[4] = 2048;
      *(void *)&v32[6] = v23;
      *(_WORD *)&v32[14] = 2080;
      *(void *)&v32[16] = "host->key_record";
      *(_WORD *)&v32[24] = 2080;
      *(void *)&v32[26] = "srp-mdns-proxy.c";
      __int16 v33 = 1024;
      int v34 = 1108;
      int v27 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_73:
      os_log_type_t v28 = v17;
LABEL_74:
      _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_FAULT, v27, buf, 0x36u);
LABEL_75:
      abort();
    }
    uint64_t v26 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_75;
    }
    *(_DWORD *)int buf = 136447490;
    uint64_t v30 = "host_invalidate";
    __int16 v31 = 1024;
    *(_DWORD *)uint64_t v32 = 0;
    *(_WORD *)&v32[4] = 2048;
    *(void *)&v32[6] = v23;
    *(_WORD *)&v32[14] = 2080;
    *(void *)&v32[16] = "host->key_record";
    *(_WORD *)&v32[24] = 2080;
    *(void *)&v32[26] = "srp-mdns-proxy.c";
    __int16 v33 = 1024;
    int v34 = 1108;
    int v27 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_58:
    os_log_type_t v28 = v26;
    goto LABEL_74;
  }
LABEL_55:
  *(void *)(a1 + 48) = 0;
  *(unsigned char *)(a1 + 264) = 1;
}

void adv_record_vec_finalize(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    for (uint64_t i = 0; i < v2; ++i)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      int v5 = *(int **)(v4 + 8 * i);
      if (v5)
      {
        int v6 = *v5;
        if (!*v5)
        {
          uint64_t v9 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)int buf = 136447490;
            uint64_t v13 = "adv_record_vec_finalize";
            __int16 v14 = 1024;
            *(_DWORD *)int v15 = 0;
            *(_WORD *)&_OWORD v15[4] = 2048;
            *(void *)&v15[6] = v5;
            *(_WORD *)&v15[14] = 2080;
            *(void *)&v15[16] = "vec->vec[i]";
            *(_WORD *)&v15[24] = 2080;
            *(void *)&v15[26] = "srp-mdns-proxy.c";
            __int16 v16 = 1024;
            int v17 = 311;
            uint64_t v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
            int v11 = v9;
            goto LABEL_19;
          }
LABEL_20:
          abort();
        }
        uint64_t v7 = global_os_log;
        if (v6 >= 10001)
        {
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)int buf = 136447490;
            uint64_t v13 = "adv_record_vec_finalize";
            __int16 v14 = 1024;
            *(_DWORD *)int v15 = v6;
            *(_WORD *)&_OWORD v15[4] = 2048;
            *(void *)&v15[6] = v5;
            *(_WORD *)&v15[14] = 2080;
            *(void *)&v15[16] = "vec->vec[i]";
            *(_WORD *)&v15[24] = 2080;
            *(void *)&v15[26] = "srp-mdns-proxy.c";
            __int16 v16 = 1024;
            int v17 = 311;
            uint64_t v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
            int v11 = v7;
LABEL_19:
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, v10, buf, 0x36u);
          }
          goto LABEL_20;
        }
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447490;
          uint64_t v13 = "adv_record_vec_finalize";
          __int16 v14 = 1024;
          *(_DWORD *)int v15 = v6;
          *(_WORD *)&_OWORD v15[4] = 2048;
          *(void *)&v15[6] = v5;
          *(_WORD *)&v15[14] = 2080;
          *(void *)&v15[16] = "vec->vec[i]";
          *(_WORD *)&v15[24] = 2080;
          *(void *)&v15[26] = "srp-mdns-proxy.c";
          __int16 v16 = 1024;
          int v17 = 311;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          uint64_t v4 = *(void *)(a1 + 8);
          int v5 = *(int **)(v4 + 8 * i);
          int v6 = *v5;
        }
        int *v5 = v6 - 1;
        if (v6 == 1)
        {
          uint64_t v8 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136447234;
            uint64_t v13 = "adv_record_vec_finalize";
            __int16 v14 = 2048;
            *(void *)int v15 = v5;
            *(_WORD *)&v15[8] = 2080;
            *(void *)&v15[10] = "vec->vec[i]";
            *(_WORD *)&v15[18] = 2080;
            *(void *)&v15[20] = "srp-mdns-proxy.c";
            *(_WORD *)&v15[28] = 1024;
            *(_DWORD *)&v15[30] = 311;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
            int v5 = *(int **)(*(void *)(a1 + 8) + 8 * i);
          }
          ++adv_record_finalized;
          adv_record_finalize(v5);
          uint64_t v4 = *(void *)(a1 + 8);
        }
        *(void *)(v4 + 8 * i) = 0;
        int v2 = *(_DWORD *)(a1 + 4);
      }
    }
  }
  free(*(void **)(a1 + 8));
  free((void *)a1);
}

void adv_instances_cancel(uint64_t a1)
{
  if (*(int *)(a1 + 4) >= 1)
  {
    uint64_t v2 = 0;
    do
    {
      uint64_t v3 = *(void *)(*(void *)(a1 + 8) + 8 * v2);
      if (v3)
      {
        uint64_t v4 = *(void *)(v3 + 8);
        if (v4)
        {
          ioloop_dnssd_txn_cancel(v4);
          ioloop_dnssd_txn_release_(*(int **)(v3 + 8), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 873);
          *(void *)(v3 + 8) = 0;
        }
        uint64_t v5 = *(void *)(v3 + 40);
        if (v5)
        {
          ioloop_cancel_wake_event(v5);
          ioloop_wakeup_release_(*(void **)(v3 + 40), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 878);
          *(void *)(v3 + 40) = 0;
        }
      }
      ++v2;
    }
    while (v2 < *(int *)(a1 + 4));
  }
}

void adv_instance_vec_finalize(uint64_t a1)
{
  int v2 = *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    for (uint64_t i = 0; i < v2; ++i)
    {
      uint64_t v4 = *(void *)(a1 + 8);
      uint64_t v5 = *(int **)(v4 + 8 * i);
      if (v5)
      {
        int v6 = *v5;
        if (!*v5)
        {
          uint64_t v9 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)int buf = 136447490;
            uint64_t v13 = "adv_instance_vec_finalize";
            __int16 v14 = 1024;
            *(_DWORD *)int v15 = 0;
            *(_WORD *)&_OWORD v15[4] = 2048;
            *(void *)&v15[6] = v5;
            *(_WORD *)&v15[14] = 2080;
            *(void *)&v15[16] = "vec->vec[i]";
            *(_WORD *)&v15[24] = 2080;
            *(void *)&v15[26] = "srp-mdns-proxy.c";
            __int16 v16 = 1024;
            int v17 = 307;
            uint64_t v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
            int v11 = v9;
            goto LABEL_19;
          }
LABEL_20:
          abort();
        }
        uint64_t v7 = global_os_log;
        if (v6 >= 10001)
        {
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)int buf = 136447490;
            uint64_t v13 = "adv_instance_vec_finalize";
            __int16 v14 = 1024;
            *(_DWORD *)int v15 = v6;
            *(_WORD *)&_OWORD v15[4] = 2048;
            *(void *)&v15[6] = v5;
            *(_WORD *)&v15[14] = 2080;
            *(void *)&v15[16] = "vec->vec[i]";
            *(_WORD *)&v15[24] = 2080;
            *(void *)&v15[26] = "srp-mdns-proxy.c";
            __int16 v16 = 1024;
            int v17 = 307;
            uint64_t v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
            int v11 = v7;
LABEL_19:
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, v10, buf, 0x36u);
          }
          goto LABEL_20;
        }
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447490;
          uint64_t v13 = "adv_instance_vec_finalize";
          __int16 v14 = 1024;
          *(_DWORD *)int v15 = v6;
          *(_WORD *)&_OWORD v15[4] = 2048;
          *(void *)&v15[6] = v5;
          *(_WORD *)&v15[14] = 2080;
          *(void *)&v15[16] = "vec->vec[i]";
          *(_WORD *)&v15[24] = 2080;
          *(void *)&v15[26] = "srp-mdns-proxy.c";
          __int16 v16 = 1024;
          int v17 = 307;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          uint64_t v4 = *(void *)(a1 + 8);
          uint64_t v5 = *(int **)(v4 + 8 * i);
          int v6 = *v5;
        }
        int *v5 = v6 - 1;
        if (v6 == 1)
        {
          uint64_t v8 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136447234;
            uint64_t v13 = "adv_instance_vec_finalize";
            __int16 v14 = 2048;
            *(void *)int v15 = v5;
            *(_WORD *)&v15[8] = 2080;
            *(void *)&v15[10] = "vec->vec[i]";
            *(_WORD *)&v15[18] = 2080;
            *(void *)&v15[20] = "srp-mdns-proxy.c";
            *(_WORD *)&v15[28] = 1024;
            *(_DWORD *)&v15[30] = 307;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
            uint64_t v5 = *(int **)(*(void *)(a1 + 8) + 8 * i);
          }
          ++adv_instance_finalized;
          adv_instance_finalize(v5);
          uint64_t v4 = *(void *)(a1 + 8);
        }
        *(void *)(v4 + 8 * i) = 0;
        int v2 = *(_DWORD *)(a1 + 4);
      }
    }
  }
  free(*(void **)(a1 + 8));
  free((void *)a1);
}

void adv_instance_finalize(void *a1)
{
  uint64_t v2 = *((void *)a1 + 1);
  if (v2)
  {
    ioloop_dnssd_txn_cancel(v2);
    ioloop_dnssd_txn_release_(*((int **)a1 + 1), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 186);
  }
  uint64_t v3 = (void *)*((void *)a1 + 9);
  if (v3) {
    free(v3);
  }
  uint64_t v4 = (void *)*((void *)a1 + 6);
  if (v4) {
    free(v4);
  }
  uint64_t v5 = (void *)*((void *)a1 + 7);
  if (v5) {
    free(v5);
  }
  int v6 = (int *)*((void *)a1 + 3);
  if (v6)
  {
    int v7 = *v6;
    if (!*v6)
    {
      uint64_t v15 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_45;
      }
      int v18 = 136447490;
      uint64_t v19 = "adv_instance_finalize";
      __int16 v20 = 1024;
      *(_DWORD *)int v21 = 0;
      *(_WORD *)&v21[4] = 2048;
      *(void *)&v21[6] = v6;
      *(_WORD *)&v21[14] = 2080;
      *(void *)&v21[16] = "instance->host";
      *(_WORD *)&v21[24] = 2080;
      *(void *)&v21[26] = "srp-mdns-proxy.c";
      __int16 v22 = 1024;
      int v23 = 198;
      __int16 v16 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_40;
    }
    uint64_t v8 = global_os_log;
    if (v7 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_45;
      }
      int v18 = 136447490;
      uint64_t v19 = "adv_instance_finalize";
      __int16 v20 = 1024;
      *(_DWORD *)int v21 = v7;
      *(_WORD *)&v21[4] = 2048;
      *(void *)&v21[6] = v6;
      *(_WORD *)&v21[14] = 2080;
      *(void *)&v21[16] = "instance->host";
      *(_WORD *)&v21[24] = 2080;
      *(void *)&v21[26] = "srp-mdns-proxy.c";
      __int16 v22 = 1024;
      int v23 = 198;
      __int16 v16 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_43:
      int v17 = v8;
      goto LABEL_44;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v18 = 136447490;
      uint64_t v19 = "adv_instance_finalize";
      __int16 v20 = 1024;
      *(_DWORD *)int v21 = v7;
      *(_WORD *)&v21[4] = 2048;
      *(void *)&v21[6] = v6;
      *(_WORD *)&v21[14] = 2080;
      *(void *)&v21[16] = "instance->host";
      *(_WORD *)&v21[24] = 2080;
      *(void *)&v21[26] = "srp-mdns-proxy.c";
      __int16 v22 = 1024;
      int v23 = 198;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v18, 0x36u);
      int v6 = (int *)*((void *)a1 + 3);
      int v7 = *v6;
    }
    *int v6 = v7 - 1;
    if (v7 == 1)
    {
      uint64_t v9 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v18 = 136447234;
        uint64_t v19 = "adv_instance_finalize";
        __int16 v20 = 2048;
        *(void *)int v21 = v6;
        *(_WORD *)&v21[8] = 2080;
        *(void *)&v21[10] = "instance->host";
        *(_WORD *)&v21[18] = 2080;
        *(void *)&v21[20] = "srp-mdns-proxy.c";
        *(_WORD *)&v21[28] = 1024;
        *(_DWORD *)&v21[30] = 198;
        _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v18, 0x30u);
        int v6 = (int *)*((void *)a1 + 3);
      }
      ++adv_host_finalized;
      adv_host_finalize(v6);
    }
    *((void *)a1 + 3) = 0;
  }
  uint64_t v10 = (int *)*((void *)a1 + 11);
  if (v10)
  {
    ioloop_message_release_(v10, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 202);
    *((void *)a1 + 11) = 0;
  }
  int v11 = (int *)*((void *)a1 + 4);
  if (v11)
  {
    int v12 = *v11;
    if (*v11)
    {
      uint64_t v8 = global_os_log;
      if (v12 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v18 = 136447490;
          uint64_t v19 = "adv_instance_finalize";
          __int16 v20 = 1024;
          *(_DWORD *)int v21 = v12;
          *(_WORD *)&v21[4] = 2048;
          *(void *)&v21[6] = v11;
          *(_WORD *)&v21[14] = 2080;
          *(void *)&v21[16] = "instance->update";
          *(_WORD *)&v21[24] = 2080;
          *(void *)&v21[26] = "srp-mdns-proxy.c";
          __int16 v22 = 1024;
          int v23 = 206;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v18, 0x36u);
          int v11 = (int *)*((void *)a1 + 4);
          int v12 = *v11;
        }
        *int v11 = v12 - 1;
        if (v12 == 1)
        {
          uint64_t v13 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v18 = 136447234;
            uint64_t v19 = "adv_instance_finalize";
            __int16 v20 = 2048;
            *(void *)int v21 = v11;
            *(_WORD *)&v21[8] = 2080;
            *(void *)&v21[10] = "instance->update";
            *(_WORD *)&v21[18] = 2080;
            *(void *)&v21[20] = "srp-mdns-proxy.c";
            *(_WORD *)&v21[28] = 1024;
            *(_DWORD *)&v21[30] = 206;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v18, 0x30u);
            int v11 = (int *)*((void *)a1 + 4);
          }
          ++adv_update_finalized;
          adv_update_finalize(v11);
        }
        *((void *)a1 + 4) = 0;
        goto LABEL_31;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_45:
      }
        abort();
      int v18 = 136447490;
      uint64_t v19 = "adv_instance_finalize";
      __int16 v20 = 1024;
      *(_DWORD *)int v21 = v12;
      *(_WORD *)&v21[4] = 2048;
      *(void *)&v21[6] = v11;
      *(_WORD *)&v21[14] = 2080;
      *(void *)&v21[16] = "instance->update";
      *(_WORD *)&v21[24] = 2080;
      *(void *)&v21[26] = "srp-mdns-proxy.c";
      __int16 v22 = 1024;
      int v23 = 206;
      __int16 v16 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_43;
    }
    uint64_t v15 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_45;
    }
    int v18 = 136447490;
    uint64_t v19 = "adv_instance_finalize";
    __int16 v20 = 1024;
    *(_DWORD *)int v21 = 0;
    *(_WORD *)&v21[4] = 2048;
    *(void *)&v21[6] = v11;
    *(_WORD *)&v21[14] = 2080;
    *(void *)&v21[16] = "instance->update";
    *(_WORD *)&v21[24] = 2080;
    *(void *)&v21[26] = "srp-mdns-proxy.c";
    __int16 v22 = 1024;
    int v23 = 206;
    __int16 v16 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_40:
    int v17 = v15;
LABEL_44:
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, v16, (uint8_t *)&v18, 0x36u);
    goto LABEL_45;
  }
LABEL_31:
  __int16 v14 = (void *)*((void *)a1 + 5);
  if (v14) {
    ioloop_wakeup_release_(v14, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 210);
  }
  free(a1);
}

void adv_record_vec_remove_update(uint64_t a1, int *a2)
{
  int v2 = *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = *(void *)(a1 + 8);
    do
    {
      uint64_t v7 = *(void *)(v6 + 8 * v5);
      if (v7)
      {
        uint64_t v8 = *(int **)(v7 + 32);
        if (v8 && v8 == a2)
        {
          int v10 = *a2;
          if (!*a2)
          {
            uint64_t v14 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)int buf = 136447490;
              int v18 = "adv_record_vec_remove_update";
              __int16 v19 = 1024;
              *(_DWORD *)__int16 v20 = 0;
              *(_WORD *)&uint8_t v20[4] = 2048;
              *(void *)&v20[6] = a2;
              *(_WORD *)&unsigned char v20[14] = 2080;
              *(void *)&v20[16] = "vec->vec[i]->update";
              *(_WORD *)&v20[24] = 2080;
              *(void *)&v20[26] = "srp-mdns-proxy.c";
              __int16 v21 = 1024;
              int v22 = 848;
              uint64_t v15 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
              __int16 v16 = v14;
              goto LABEL_25;
            }
LABEL_26:
            abort();
          }
          int v11 = global_os_log;
          if (v10 >= 10001)
          {
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)int buf = 136447490;
              int v18 = "adv_record_vec_remove_update";
              __int16 v19 = 1024;
              *(_DWORD *)__int16 v20 = v10;
              *(_WORD *)&uint8_t v20[4] = 2048;
              *(void *)&v20[6] = a2;
              *(_WORD *)&unsigned char v20[14] = 2080;
              *(void *)&v20[16] = "vec->vec[i]->update";
              *(_WORD *)&v20[24] = 2080;
              *(void *)&v20[26] = "srp-mdns-proxy.c";
              __int16 v21 = 1024;
              int v22 = 848;
              uint64_t v15 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
              __int16 v16 = v11;
LABEL_25:
              _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_FAULT, v15, buf, 0x36u);
            }
            goto LABEL_26;
          }
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136447490;
            int v18 = "adv_record_vec_remove_update";
            __int16 v19 = 1024;
            *(_DWORD *)__int16 v20 = v10;
            *(_WORD *)&uint8_t v20[4] = 2048;
            *(void *)&v20[6] = a2;
            *(_WORD *)&unsigned char v20[14] = 2080;
            *(void *)&v20[16] = "vec->vec[i]->update";
            *(_WORD *)&v20[24] = 2080;
            *(void *)&v20[26] = "srp-mdns-proxy.c";
            __int16 v21 = 1024;
            int v22 = 848;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            uint64_t v6 = *(void *)(a1 + 8);
            int v12 = *(int **)(*(void *)(v6 + 8 * v5) + 32);
            int v10 = *v12;
          }
          else
          {
            int v12 = a2;
          }
          int *v12 = v10 - 1;
          if (v10 == 1)
          {
            uint64_t v13 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)int buf = 136447234;
              int v18 = "adv_record_vec_remove_update";
              __int16 v19 = 2048;
              *(void *)__int16 v20 = v12;
              *(_WORD *)&v20[8] = 2080;
              *(void *)&v20[10] = "vec->vec[i]->update";
              *(_WORD *)&v20[18] = 2080;
              *(void *)&v20[20] = "srp-mdns-proxy.c";
              *(_WORD *)&v20[28] = 1024;
              *(_DWORD *)&v20[30] = 848;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
              int v12 = *(int **)(*(void *)(*(void *)(a1 + 8) + 8 * v5) + 32);
            }
            ++adv_update_finalized;
            adv_update_finalize(v12);
            uint64_t v6 = *(void *)(a1 + 8);
          }
          *(void *)(*(void *)(v6 + 8 * v5) + 32) = 0;
          int v2 = *(_DWORD *)(a1 + 4);
        }
      }
      ++v5;
    }
    while (v5 < v2);
  }
}

void adv_update_free_instance_vectors(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 56);
  if (v2)
  {
    adv_instance_vec_remove_update(v2, (int *)a1);
    adv_instances_cancel(*(void *)(a1 + 56));
    uint64_t v3 = *(int **)(a1 + 56);
    if (v3)
    {
      int v4 = *v3;
      if (!*v3)
      {
        uint64_t v19 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_65;
        }
        int v22 = 136447490;
        int v23 = "adv_update_free_instance_vectors";
        __int16 v24 = 1024;
        *(_DWORD *)__int16 v25 = 0;
        *(_WORD *)&v25[4] = 2048;
        *(void *)&v25[6] = v3;
        *(_WORD *)&v25[14] = 2080;
        *(void *)&v25[16] = "update->update_instances";
        *(_WORD *)&v25[24] = 2080;
        *(void *)&v25[26] = "srp-mdns-proxy.c";
        __int16 v26 = 1024;
        int v27 = 891;
        __int16 v20 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_60;
      }
      uint64_t v5 = global_os_log;
      if (v4 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_65;
        }
        int v22 = 136447490;
        int v23 = "adv_update_free_instance_vectors";
        __int16 v24 = 1024;
        *(_DWORD *)__int16 v25 = v4;
        *(_WORD *)&v25[4] = 2048;
        *(void *)&v25[6] = v3;
        *(_WORD *)&v25[14] = 2080;
        *(void *)&v25[16] = "update->update_instances";
        *(_WORD *)&v25[24] = 2080;
        *(void *)&v25[26] = "srp-mdns-proxy.c";
        __int16 v26 = 1024;
        int v27 = 891;
        __int16 v20 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_63;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v22 = 136447490;
        int v23 = "adv_update_free_instance_vectors";
        __int16 v24 = 1024;
        *(_DWORD *)__int16 v25 = v4;
        *(_WORD *)&v25[4] = 2048;
        *(void *)&v25[6] = v3;
        *(_WORD *)&v25[14] = 2080;
        *(void *)&v25[16] = "update->update_instances";
        *(_WORD *)&v25[24] = 2080;
        *(void *)&v25[26] = "srp-mdns-proxy.c";
        __int16 v26 = 1024;
        int v27 = 891;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v22, 0x36u);
        uint64_t v3 = *(int **)(a1 + 56);
        int v4 = *v3;
      }
      *uint64_t v3 = v4 - 1;
      if (v4 == 1)
      {
        uint64_t v6 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v22 = 136447234;
          int v23 = "adv_update_free_instance_vectors";
          __int16 v24 = 2048;
          *(void *)__int16 v25 = v3;
          *(_WORD *)&v25[8] = 2080;
          *(void *)&v25[10] = "update->update_instances";
          *(_WORD *)&v25[18] = 2080;
          *(void *)&v25[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v25[28] = 1024;
          *(_DWORD *)&v25[30] = 891;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v22, 0x30u);
          uint64_t v3 = *(int **)(a1 + 56);
        }
        ++adv_instance_vec_finalized;
        adv_instance_vec_finalize((uint64_t)v3);
      }
    }
    *(void *)(a1 + 56) = 0;
  }
  uint64_t v7 = *(void *)(a1 + 64);
  if (v7)
  {
    adv_instance_vec_remove_update(v7, (int *)a1);
    uint64_t v8 = *(int **)(a1 + 64);
    if (v8)
    {
      int v9 = *v8;
      if (!*v8)
      {
        uint64_t v19 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_65;
        }
        int v22 = 136447490;
        int v23 = "adv_update_free_instance_vectors";
        __int16 v24 = 1024;
        *(_DWORD *)__int16 v25 = 0;
        *(_WORD *)&v25[4] = 2048;
        *(void *)&v25[6] = v8;
        *(_WORD *)&v25[14] = 2080;
        *(void *)&v25[16] = "update->remove_instances";
        *(_WORD *)&v25[24] = 2080;
        *(void *)&v25[26] = "srp-mdns-proxy.c";
        __int16 v26 = 1024;
        int v27 = 896;
        __int16 v20 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_60;
      }
      uint64_t v5 = global_os_log;
      if (v9 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_65;
        }
        int v22 = 136447490;
        int v23 = "adv_update_free_instance_vectors";
        __int16 v24 = 1024;
        *(_DWORD *)__int16 v25 = v9;
        *(_WORD *)&v25[4] = 2048;
        *(void *)&v25[6] = v8;
        *(_WORD *)&v25[14] = 2080;
        *(void *)&v25[16] = "update->remove_instances";
        *(_WORD *)&v25[24] = 2080;
        *(void *)&v25[26] = "srp-mdns-proxy.c";
        __int16 v26 = 1024;
        int v27 = 896;
        __int16 v20 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_63;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v22 = 136447490;
        int v23 = "adv_update_free_instance_vectors";
        __int16 v24 = 1024;
        *(_DWORD *)__int16 v25 = v9;
        *(_WORD *)&v25[4] = 2048;
        *(void *)&v25[6] = v8;
        *(_WORD *)&v25[14] = 2080;
        *(void *)&v25[16] = "update->remove_instances";
        *(_WORD *)&v25[24] = 2080;
        *(void *)&v25[26] = "srp-mdns-proxy.c";
        __int16 v26 = 1024;
        int v27 = 896;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v22, 0x36u);
        uint64_t v8 = *(int **)(a1 + 64);
        int v9 = *v8;
      }
      *uint64_t v8 = v9 - 1;
      if (v9 == 1)
      {
        int v10 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v22 = 136447234;
          int v23 = "adv_update_free_instance_vectors";
          __int16 v24 = 2048;
          *(void *)__int16 v25 = v8;
          *(_WORD *)&v25[8] = 2080;
          *(void *)&v25[10] = "update->remove_instances";
          *(_WORD *)&v25[18] = 2080;
          *(void *)&v25[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v25[28] = 1024;
          *(_DWORD *)&v25[30] = 896;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v22, 0x30u);
          uint64_t v8 = *(int **)(a1 + 64);
        }
        ++adv_instance_vec_finalized;
        adv_instance_vec_finalize((uint64_t)v8);
      }
    }
    *(void *)(a1 + 64) = 0;
  }
  uint64_t v11 = *(void *)(a1 + 72);
  if (!v11) {
    goto LABEL_34;
  }
  adv_instance_vec_remove_update(v11, (int *)a1);
  int v12 = *(int **)(a1 + 72);
  if (v12)
  {
    int v13 = *v12;
    if (!*v12)
    {
      uint64_t v19 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_65;
      }
      int v22 = 136447490;
      int v23 = "adv_update_free_instance_vectors";
      __int16 v24 = 1024;
      *(_DWORD *)__int16 v25 = 0;
      *(_WORD *)&v25[4] = 2048;
      *(void *)&v25[6] = v12;
      *(_WORD *)&v25[14] = 2080;
      *(void *)&v25[16] = "update->renew_instances";
      *(_WORD *)&v25[24] = 2080;
      *(void *)&v25[26] = "srp-mdns-proxy.c";
      __int16 v26 = 1024;
      int v27 = 901;
      __int16 v20 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_60;
    }
    uint64_t v5 = global_os_log;
    if (v13 < 10001)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v22 = 136447490;
        int v23 = "adv_update_free_instance_vectors";
        __int16 v24 = 1024;
        *(_DWORD *)__int16 v25 = v13;
        *(_WORD *)&v25[4] = 2048;
        *(void *)&v25[6] = v12;
        *(_WORD *)&v25[14] = 2080;
        *(void *)&v25[16] = "update->renew_instances";
        *(_WORD *)&v25[24] = 2080;
        *(void *)&v25[26] = "srp-mdns-proxy.c";
        __int16 v26 = 1024;
        int v27 = 901;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v22, 0x36u);
        int v12 = *(int **)(a1 + 72);
        int v13 = *v12;
      }
      int *v12 = v13 - 1;
      if (v13 == 1)
      {
        uint64_t v14 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v22 = 136447234;
          int v23 = "adv_update_free_instance_vectors";
          __int16 v24 = 2048;
          *(void *)__int16 v25 = v12;
          *(_WORD *)&v25[8] = 2080;
          *(void *)&v25[10] = "update->renew_instances";
          *(_WORD *)&v25[18] = 2080;
          *(void *)&v25[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v25[28] = 1024;
          *(_DWORD *)&v25[30] = 901;
          _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v22, 0x30u);
          int v12 = *(int **)(a1 + 72);
        }
        ++adv_instance_vec_finalized;
        adv_instance_vec_finalize((uint64_t)v12);
      }
      goto LABEL_33;
    }
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_65;
    }
    int v22 = 136447490;
    int v23 = "adv_update_free_instance_vectors";
    __int16 v24 = 1024;
    *(_DWORD *)__int16 v25 = v13;
    *(_WORD *)&v25[4] = 2048;
    *(void *)&v25[6] = v12;
    *(_WORD *)&v25[14] = 2080;
    *(void *)&v25[16] = "update->renew_instances";
    *(_WORD *)&v25[24] = 2080;
    *(void *)&v25[26] = "srp-mdns-proxy.c";
    __int16 v26 = 1024;
    int v27 = 901;
    __int16 v20 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_63:
    __int16 v21 = v5;
    goto LABEL_64;
  }
LABEL_33:
  *(void *)(a1 + 72) = 0;
LABEL_34:
  uint64_t v15 = *(void *)(a1 + 80);
  if (!v15) {
    return;
  }
  adv_instance_vec_remove_update(v15, (int *)a1);
  adv_instances_cancel(*(void *)(a1 + 80));
  __int16 v16 = *(int **)(a1 + 80);
  if (v16)
  {
    int v17 = *v16;
    if (*v16)
    {
      uint64_t v5 = global_os_log;
      if (v17 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v22 = 136447490;
          int v23 = "adv_update_free_instance_vectors";
          __int16 v24 = 1024;
          *(_DWORD *)__int16 v25 = v17;
          *(_WORD *)&v25[4] = 2048;
          *(void *)&v25[6] = v16;
          *(_WORD *)&v25[14] = 2080;
          *(void *)&v25[16] = "update->add_instances";
          *(_WORD *)&v25[24] = 2080;
          *(void *)&v25[26] = "srp-mdns-proxy.c";
          __int16 v26 = 1024;
          int v27 = 907;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v22, 0x36u);
          __int16 v16 = *(int **)(a1 + 80);
          int v17 = *v16;
        }
        int *v16 = v17 - 1;
        if (v17 == 1)
        {
          int v18 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v22 = 136447234;
            int v23 = "adv_update_free_instance_vectors";
            __int16 v24 = 2048;
            *(void *)__int16 v25 = v16;
            *(_WORD *)&v25[8] = 2080;
            *(void *)&v25[10] = "update->add_instances";
            *(_WORD *)&v25[18] = 2080;
            *(void *)&v25[20] = "srp-mdns-proxy.c";
            *(_WORD *)&v25[28] = 1024;
            *(_DWORD *)&v25[30] = 907;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v22, 0x30u);
            __int16 v16 = *(int **)(a1 + 80);
          }
          ++adv_instance_vec_finalized;
          adv_instance_vec_finalize((uint64_t)v16);
        }
        goto LABEL_44;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_65:
      }
        abort();
      int v22 = 136447490;
      int v23 = "adv_update_free_instance_vectors";
      __int16 v24 = 1024;
      *(_DWORD *)__int16 v25 = v17;
      *(_WORD *)&v25[4] = 2048;
      *(void *)&v25[6] = v16;
      *(_WORD *)&v25[14] = 2080;
      *(void *)&v25[16] = "update->add_instances";
      *(_WORD *)&v25[24] = 2080;
      *(void *)&v25[26] = "srp-mdns-proxy.c";
      __int16 v26 = 1024;
      int v27 = 907;
      __int16 v20 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_63;
    }
    uint64_t v19 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_65;
    }
    int v22 = 136447490;
    int v23 = "adv_update_free_instance_vectors";
    __int16 v24 = 1024;
    *(_DWORD *)__int16 v25 = 0;
    *(_WORD *)&v25[4] = 2048;
    *(void *)&v25[6] = v16;
    *(_WORD *)&v25[14] = 2080;
    *(void *)&v25[16] = "update->add_instances";
    *(_WORD *)&v25[24] = 2080;
    *(void *)&v25[26] = "srp-mdns-proxy.c";
    __int16 v26 = 1024;
    int v27 = 907;
    __int16 v20 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_60:
    __int16 v21 = v19;
LABEL_64:
    _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_FAULT, v20, (uint8_t *)&v22, 0x36u);
    goto LABEL_65;
  }
LABEL_44:
  *(void *)(a1 + 80) = 0;
}

void adv_instance_vec_remove_update(uint64_t a1, int *a2)
{
  int v2 = *(_DWORD *)(a1 + 4);
  if (v2 >= 1)
  {
    uint64_t v5 = 0;
    uint64_t v6 = *(void *)(a1 + 8);
    do
    {
      uint64_t v7 = *(void *)(v6 + 8 * v5);
      if (v7)
      {
        uint64_t v8 = *(int **)(v7 + 32);
        if (v8 && v8 == a2)
        {
          int v10 = *a2;
          if (!*a2)
          {
            uint64_t v14 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)int buf = 136447490;
              int v18 = "adv_instance_vec_remove_update";
              __int16 v19 = 1024;
              *(_DWORD *)__int16 v20 = 0;
              *(_WORD *)&uint8_t v20[4] = 2048;
              *(void *)&v20[6] = a2;
              *(_WORD *)&unsigned char v20[14] = 2080;
              *(void *)&v20[16] = "vec->vec[i]->update";
              *(_WORD *)&v20[24] = 2080;
              *(void *)&v20[26] = "srp-mdns-proxy.c";
              __int16 v21 = 1024;
              int v22 = 859;
              uint64_t v15 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
              __int16 v16 = v14;
              goto LABEL_25;
            }
LABEL_26:
            abort();
          }
          uint64_t v11 = global_os_log;
          if (v10 >= 10001)
          {
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)int buf = 136447490;
              int v18 = "adv_instance_vec_remove_update";
              __int16 v19 = 1024;
              *(_DWORD *)__int16 v20 = v10;
              *(_WORD *)&uint8_t v20[4] = 2048;
              *(void *)&v20[6] = a2;
              *(_WORD *)&unsigned char v20[14] = 2080;
              *(void *)&v20[16] = "vec->vec[i]->update";
              *(_WORD *)&v20[24] = 2080;
              *(void *)&v20[26] = "srp-mdns-proxy.c";
              __int16 v21 = 1024;
              int v22 = 859;
              uint64_t v15 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
              __int16 v16 = v11;
LABEL_25:
              _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_FAULT, v15, buf, 0x36u);
            }
            goto LABEL_26;
          }
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136447490;
            int v18 = "adv_instance_vec_remove_update";
            __int16 v19 = 1024;
            *(_DWORD *)__int16 v20 = v10;
            *(_WORD *)&uint8_t v20[4] = 2048;
            *(void *)&v20[6] = a2;
            *(_WORD *)&unsigned char v20[14] = 2080;
            *(void *)&v20[16] = "vec->vec[i]->update";
            *(_WORD *)&v20[24] = 2080;
            *(void *)&v20[26] = "srp-mdns-proxy.c";
            __int16 v21 = 1024;
            int v22 = 859;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            uint64_t v6 = *(void *)(a1 + 8);
            int v12 = *(int **)(*(void *)(v6 + 8 * v5) + 32);
            int v10 = *v12;
          }
          else
          {
            int v12 = a2;
          }
          int *v12 = v10 - 1;
          if (v10 == 1)
          {
            int v13 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)int buf = 136447234;
              int v18 = "adv_instance_vec_remove_update";
              __int16 v19 = 2048;
              *(void *)__int16 v20 = v12;
              *(_WORD *)&v20[8] = 2080;
              *(void *)&v20[10] = "vec->vec[i]->update";
              *(_WORD *)&v20[18] = 2080;
              *(void *)&v20[20] = "srp-mdns-proxy.c";
              *(_WORD *)&v20[28] = 1024;
              *(_DWORD *)&v20[30] = 859;
              _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
              int v12 = *(int **)(*(void *)(*(void *)(a1 + 8) + 8 * v5) + 32);
            }
            ++adv_update_finalized;
            adv_update_finalize(v12);
            uint64_t v6 = *(void *)(a1 + 8);
          }
          *(void *)(*(void *)(v6 + 8 * v5) + 32) = 0;
          int v2 = *(_DWORD *)(a1 + 4);
        }
      }
      ++v5;
    }
    while (v5 < v2);
  }
}

void adv_instance_context_release(int *a1)
{
  if (!a1) {
    return;
  }
  int v2 = *a1;
  if (!*a1)
  {
    uint64_t v3 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v6 = 136447490;
    uint64_t v7 = "adv_instance_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)int v9 = 0;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "instance";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "srp-mdns-proxy.c";
    __int16 v10 = 1024;
    int v11 = 220;
    uint64_t v5 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  uint64_t v3 = global_os_log;
  if (v2 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v6 = 136447490;
    uint64_t v7 = "adv_instance_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)int v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "instance";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "srp-mdns-proxy.c";
    __int16 v10 = 1024;
    int v11 = 220;
    uint64_t v5 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, v5, (uint8_t *)&v6, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 136447490;
    uint64_t v7 = "adv_instance_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)int v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "instance";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "srp-mdns-proxy.c";
    __int16 v10 = 1024;
    int v11 = 220;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v6, 0x36u);
    int v2 = *a1;
  }
  *a1 = v2 - 1;
  if (v2 == 1)
  {
    int v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 136447234;
      uint64_t v7 = "adv_instance_context_release";
      __int16 v8 = 2048;
      *(void *)int v9 = a1;
      *(_WORD *)&v9[8] = 2080;
      *(void *)&v9[10] = "instance";
      *(_WORD *)&v9[18] = 2080;
      *(void *)&v9[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v9[28] = 1024;
      *(_DWORD *)&v9[30] = 220;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v6, 0x30u);
    }
    ++adv_instance_finalized;
    adv_instance_finalize(a1);
  }
}

uint64_t srp_mdns_shared_registration_txn_setup(uint64_t a1)
{
  if (*(void *)(a1 + 16)) {
    return 1;
  }
  DNSServiceRef sdRef = 0;
  size_t v9 = 0;
  if (!ConnectToServer((uint64_t *)&sdRef, 0, 1, (uint64_t)ConnectionResponse, 0, 0))
  {
    *(void *)int buf = 0;
    uint64_t v3 = (int8x16_t *)create_hdr(1, &v9, buf, 0, (uint64_t)sdRef);
    if (!deliver_request(v3, (uint64_t)sdRef))
    {
      int v4 = ioloop_dnssd_txn_add_((uint64_t)sdRef, a1, 0, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 735);
      *(void *)(a1 + 16) = v4;
      if (v4)
      {
        uint64_t v5 = v4;
        dns_service_op_not_to_be_freed = v4[1];
        int v6 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136446722;
          *(void *)&uint8_t buf[4] = "srp_mdns_shared_registration_txn_setup";
          __int16 v11 = 2048;
          int v12 = v5;
          __int16 v13 = 2048;
          DNSServiceRef v14 = sdRef;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: server_state->shared_registration_txn = %p  sdref = %p", buf, 0x20u);
        }
        return 1;
      }
      uint64_t v7 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "srp_mdns_shared_registration_txn_setup";
        _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_ERROR, "%{public}s: unable to create shared connection for registration.", buf, 0xCu);
      }
      dns_service_op_not_to_be_freed = 0;
    }
    DNSServiceRefDeallocate(sdRef);
  }
  return 0;
}

void srp_mdns_update_finished(uint64_t a1)
{
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v2 = *(void *)(a1 + 16);
  v285 = (uint64_t *)v2;
  if (v2) {
    v289 = *(int **)(v2 + 32);
  }
  else {
    v289 = 0;
  }
  uint64_t v4 = *(void *)(v3 + 96);
  if (v4 && (uint64_t v5 = *(unsigned int *)(v4 + 4), (int)v5 >= 1))
  {
    uint64_t v6 = 0;
    int v7 = 0;
    uint64_t v8 = *(void *)(v4 + 8);
    uint64_t v9 = 8 * v5;
    do
    {
      if (*(void *)(v8 + v6))
      {
        uint64_t v10 = *(void *)(a1 + 32);
        if (!v10 || !*(void *)(*(void *)(v10 + 8) + v6)) {
          ++v7;
        }
      }
      v6 += 8;
    }
    while (v9 != v6);
  }
  else
  {
    int v7 = 0;
  }
  uint64_t v11 = *(void *)(a1 + 40);
  if (v11 && (uint64_t v12 = *(unsigned int *)(v11 + 4), (int)v12 >= 1))
  {
    int v13 = 0;
    DNSServiceRef v14 = *(void **)(v11 + 8);
    do
    {
      if (*v14++) {
        ++v13;
      }
      --v12;
    }
    while (v12);
  }
  else
  {
    int v13 = 0;
  }
  uint64_t v284 = *(void *)(v3 + 8);
  if (v13 + v7 < 1)
  {
    int v18 = 0;
  }
  else
  {
    __int16 v16 = adv_record_vec_create(v13 + v7);
    if (!v16)
    {
      update_failed(a1, 2u, 1);
      return;
    }
    uint64_t v17 = *(void *)(v3 + 96);
    int v18 = v16;
    if (v17 && *(int *)(v17 + 4) >= 1)
    {
      uint64_t v19 = 0;
      int v20 = 0;
      while (1)
      {
        uint64_t v21 = *(void *)(*(void *)(v17 + 8) + 8 * v19);
        if (v21)
        {
          uint64_t v22 = *(void *)(a1 + 32);
          if (!v22 || !*(void *)(*(void *)(v22 + 8) + 8 * v19)) {
            break;
          }
        }
LABEL_49:
        if (++v19 >= *(int *)(v17 + 4)) {
          goto LABEL_53;
        }
      }
      int v23 = *(unsigned __int8 **)(v21 + 40);
      int v24 = *(unsigned __int16 *)(v21 + 48);
      uint64_t v25 = global_os_log;
      BOOL v26 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
      if (v24 == 28)
      {
        if (v26)
        {
          int v27 = *v23;
          os_log_type_t v28 = "ULA: ";
          if ((v27 & 0xFE) != 0xFC)
          {
            if (v27 != 254 || (os_log_type_t v28 = "LUA: ", (v23[1] & 0xC0) != 0x80))
            {
              os_log_type_t v28 = "GUA: ";
              if ((v27 & 0xE0) != 0x20) {
                os_log_type_t v28 = "";
              }
            }
          }
          uint64_t v29 = *(void *)(v3 + 64);
          *(_DWORD *)int buf = 136449283;
          *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v28;
          *(_WORD *)&buf[22] = 2160;
          *(void *)&unsigned char buf[24] = 1752392040;
          *(_WORD *)&uint8_t buf[32] = 1041;
          *(_DWORD *)&buf[34] = 6;
          *(_WORD *)&unsigned char buf[38] = 2097;
          *(void *)&buf[40] = v23;
          *(_WORD *)&unsigned char buf[48] = 2160;
          *(void *)&buf[50] = 1752392040;
          *(_WORD *)&buf[58] = 1042;
          *(_DWORD *)&buf[60] = 2;
          *(_WORD *)&buf[64] = 2098;
          *(void *)&buf[66] = v23 + 6;
          *(_WORD *)&buf[74] = 2160;
          *(void *)&buf[76] = 1752392040;
          __int16 v291 = 1041;
          int v292 = 8;
          __int16 v293 = 2097;
          v294 = v23 + 8;
          __int16 v295 = 2160;
          uint64_t v296 = 1752392040;
          __int16 v297 = 2081;
          uint64_t v298 = v29;
          uint64_t v30 = v25;
          __int16 v31 = "%{public}s: retaining {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp"
                ":in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}on host %{private, mask.hash}s";
          uint32_t v32 = 120;
          goto LABEL_40;
        }
      }
      else if (v26)
      {
        uint64_t v33 = *(void *)(v3 + 64);
        *(_DWORD *)int buf = 136447491;
        *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&unsigned char buf[12] = 2160;
        *(void *)&buf[14] = 1752392040;
        *(_WORD *)&buf[22] = 1041;
        *(_DWORD *)&unsigned char buf[24] = 4;
        *(_WORD *)&buf[28] = 2097;
        *(void *)&buf[30] = v23;
        *(_WORD *)&unsigned char buf[38] = 2160;
        *(void *)&buf[40] = 1752392040;
        *(_WORD *)&unsigned char buf[48] = 2081;
        *(void *)&buf[50] = v33;
        uint64_t v30 = v25;
        __int16 v31 = "%{public}s: retaining %{private, mask.hash, network:in_addr}.4Pon host %{private, mask.hash}s";
        uint32_t v32 = 58;
LABEL_40:
        _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, v31, buf, v32);
      }
      *(void *)(v18[1] + 8 * v20) = v21;
      int v34 = *(int **)(v18[1] + 8 * v20);
      if (v34)
      {
        long long v35 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v36 = *v34;
          *(_DWORD *)int buf = 136447490;
          *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v36;
          *(_WORD *)&unsigned char buf[18] = 2048;
          *(void *)&buf[20] = v34;
          *(_WORD *)&buf[28] = 2080;
          *(void *)&buf[30] = "addresses->vec[j]";
          *(_WORD *)&unsigned char buf[38] = 2080;
          *(void *)&buf[40] = "srp-mdns-proxy.c";
          *(_WORD *)&unsigned char buf[48] = 1024;
          *(_DWORD *)&buf[50] = 1490;
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          int v34 = *(int **)(v18[1] + 8 * v20);
        }
        int v37 = *v34;
        if (*v34)
        {
          int v38 = v37 + 1;
          *int v34 = v37 + 1;
          if (v37 + 1 >= 10001)
          {
            uint64_t v279 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
              goto LABEL_490;
            }
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v38;
            *(_WORD *)&unsigned char buf[18] = 2048;
            *(void *)&buf[20] = v34;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = "addresses->vec[j]";
            *(_WORD *)&unsigned char buf[38] = 2080;
            *(void *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&unsigned char buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1490;
            __int16 v199 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
            goto LABEL_488;
          }
        }
        else
        {
          ++adv_record_created;
          *int v34 = 1;
        }
      }
      ++v20;
      uint64_t v17 = *(void *)(v3 + 96);
      goto LABEL_49;
    }
    int v20 = 0;
LABEL_53:
    uint64_t v39 = *(void *)(a1 + 40);
    if (v39 && *(int *)(v39 + 4) >= 1)
    {
      uint64_t v40 = 0;
      int v41 = v20;
      while (1)
      {
        uint64_t v42 = *(void *)(*(void *)(v39 + 8) + 8 * v40);
        if (!v42) {
          goto LABEL_96;
        }
        int v43 = *(unsigned __int8 **)(v42 + 40);
        int v44 = *(unsigned __int16 *)(v42 + 48);
        uint64_t v45 = global_os_log;
        BOOL v46 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
        if (v44 == 28)
        {
          if (v46)
          {
            int v47 = *v43;
            long long v48 = "ULA: ";
            if ((v47 & 0xFE) != 0xFC)
            {
              if (v47 != 254 || (long long v48 = "LUA: ", (v43[1] & 0xC0) != 0x80))
              {
                long long v48 = "GUA: ";
                if ((v47 & 0xE0) != 0x20) {
                  long long v48 = "";
                }
              }
            }
            uint64_t v49 = *(void *)(v3 + 64);
            *(_DWORD *)int buf = 136449283;
            *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v48;
            *(_WORD *)&buf[22] = 2160;
            *(void *)&unsigned char buf[24] = 1752392040;
            *(_WORD *)&uint8_t buf[32] = 1041;
            *(_DWORD *)&buf[34] = 6;
            *(_WORD *)&unsigned char buf[38] = 2097;
            *(void *)&buf[40] = v43;
            *(_WORD *)&unsigned char buf[48] = 2160;
            *(void *)&buf[50] = 1752392040;
            *(_WORD *)&buf[58] = 1042;
            *(_DWORD *)&buf[60] = 2;
            *(_WORD *)&buf[64] = 2098;
            *(void *)&buf[66] = v43 + 6;
            *(_WORD *)&buf[74] = 2160;
            *(void *)&buf[76] = 1752392040;
            __int16 v291 = 1041;
            int v292 = 8;
            __int16 v293 = 2097;
            v294 = v43 + 8;
            __int16 v295 = 2160;
            uint64_t v296 = 1752392040;
            __int16 v297 = 2081;
            uint64_t v298 = v49;
            long long v50 = v45;
            long long v51 = "%{public}s: adding {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:"
                  "in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}to host %{private, mask.hash}s";
            uint32_t v52 = 120;
            goto LABEL_67;
          }
        }
        else if (v46)
        {
          uint64_t v53 = *(void *)(v3 + 64);
          *(_DWORD *)int buf = 136447491;
          *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&unsigned char buf[12] = 2160;
          *(void *)&buf[14] = 1752392040;
          *(_WORD *)&buf[22] = 1041;
          *(_DWORD *)&unsigned char buf[24] = 4;
          *(_WORD *)&buf[28] = 2097;
          *(void *)&buf[30] = v43;
          *(_WORD *)&unsigned char buf[38] = 2160;
          *(void *)&buf[40] = 1752392040;
          *(_WORD *)&unsigned char buf[48] = 2081;
          *(void *)&buf[50] = v53;
          long long v50 = v45;
          long long v51 = "%{public}s: adding %{private, mask.hash, network:in_addr}.4Pto host %{private, mask.hash}s";
          uint32_t v52 = 58;
LABEL_67:
          _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, v51, buf, v52);
        }
        *(void *)(v18[1] + 8 * v41) = v42;
        long long v54 = *(int **)(v18[1] + 8 * v41);
        if (v54)
        {
          long long v55 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v56 = *v54;
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v56;
            *(_WORD *)&unsigned char buf[18] = 2048;
            *(void *)&buf[20] = v54;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = "addresses->vec[j]";
            *(_WORD *)&unsigned char buf[38] = 2080;
            *(void *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&unsigned char buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1512;
            _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            long long v54 = *(int **)(v18[1] + 8 * v41);
          }
          int v57 = *v54;
          if (*v54)
          {
            int v58 = v57 + 1;
            int *v54 = v57 + 1;
            if (v57 + 1 >= 10001)
            {
              uint64_t v279 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                goto LABEL_490;
              }
              *(_DWORD *)int buf = 136447490;
              *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v58;
              *(_WORD *)&unsigned char buf[18] = 2048;
              *(void *)&buf[20] = v54;
              *(_WORD *)&buf[28] = 2080;
              *(void *)&buf[30] = "addresses->vec[j]";
              *(_WORD *)&unsigned char buf[38] = 2080;
              *(void *)&buf[40] = "srp-mdns-proxy.c";
              *(_WORD *)&unsigned char buf[48] = 1024;
              *(_DWORD *)&buf[50] = 1512;
              __int16 v199 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
              goto LABEL_488;
            }
          }
          else
          {
            ++adv_record_created;
            int *v54 = 1;
          }
        }
        uint64_t v59 = *(void *)(v42 + 32);
        uint64_t v60 = *(void *)(*(void *)(a1 + 40) + 8);
        if (v59)
        {
          uint64_t v61 = *(void *)(v60 + 8 * v40);
          long long v62 = *(int **)(v61 + 32);
          if (v62)
          {
            int v63 = *v62;
            if (!*v62)
            {
              uint64_t v279 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                goto LABEL_490;
              }
              *(_DWORD *)int buf = 136447490;
              *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = 0;
              *(_WORD *)&unsigned char buf[18] = 2048;
              *(void *)&buf[20] = v62;
              *(_WORD *)&buf[28] = 2080;
              *(void *)&buf[30] = "update->add_addresses->vec[i]->update";
              *(_WORD *)&unsigned char buf[38] = 2080;
              *(void *)&buf[40] = "srp-mdns-proxy.c";
              *(_WORD *)&unsigned char buf[48] = 1024;
              *(_DWORD *)&buf[50] = 1515;
              __int16 v199 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
              goto LABEL_488;
            }
            long long v64 = global_os_log;
            if (v63 >= 10001)
            {
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                goto LABEL_490;
              }
              *(_DWORD *)int buf = 136447490;
              *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v63;
              *(_WORD *)&unsigned char buf[18] = 2048;
              *(void *)&buf[20] = v62;
              *(_WORD *)&buf[28] = 2080;
              *(void *)&buf[30] = "update->add_addresses->vec[i]->update";
              *(_WORD *)&unsigned char buf[38] = 2080;
              *(void *)&buf[40] = "srp-mdns-proxy.c";
              *(_WORD *)&unsigned char buf[48] = 1024;
              *(_DWORD *)&buf[50] = 1515;
              __int16 v199 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
              goto LABEL_443;
            }
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)int buf = 136447490;
              *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v63;
              *(_WORD *)&unsigned char buf[18] = 2048;
              *(void *)&buf[20] = v62;
              *(_WORD *)&buf[28] = 2080;
              *(void *)&buf[30] = "update->add_addresses->vec[i]->update";
              *(_WORD *)&unsigned char buf[38] = 2080;
              *(void *)&buf[40] = "srp-mdns-proxy.c";
              *(_WORD *)&unsigned char buf[48] = 1024;
              *(_DWORD *)&buf[50] = 1515;
              _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
              uint64_t v60 = *(void *)(*(void *)(a1 + 40) + 8);
              uint64_t v61 = *(void *)(v60 + 8 * v40);
              long long v62 = *(int **)(v61 + 32);
              int v63 = *v62;
            }
            int *v62 = v63 - 1;
            if (v63 == 1)
            {
              long long v65 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)int buf = 136447234;
                *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
                *(_WORD *)&unsigned char buf[12] = 2048;
                *(void *)&buf[14] = v62;
                *(_WORD *)&buf[22] = 2080;
                *(void *)&unsigned char buf[24] = "update->add_addresses->vec[i]->update";
                *(_WORD *)&uint8_t buf[32] = 2080;
                *(void *)&buf[34] = "srp-mdns-proxy.c";
                *(_WORD *)&buf[42] = 1024;
                *(_DWORD *)&buf[44] = 1515;
                _os_log_impl((void *)&_mh_execute_header, v65, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
                long long v62 = *(int **)(*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 8 * v40) + 32);
              }
              ++adv_update_finalized;
              adv_update_finalize((uint64_t)v62);
              uint64_t v60 = *(void *)(*(void *)(a1 + 40) + 8);
              uint64_t v61 = *(void *)(v60 + 8 * v40);
            }
          }
          *(void *)(v61 + 32) = 0;
        }
        long long v66 = *(int **)(v60 + 8 * v40);
        if (v66)
        {
          int v67 = *v66;
          if (!*v66)
          {
            uint64_t v279 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
              goto LABEL_490;
            }
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 0;
            *(_WORD *)&unsigned char buf[18] = 2048;
            *(void *)&buf[20] = v66;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = "update->add_addresses->vec[i]";
            *(_WORD *)&unsigned char buf[38] = 2080;
            *(void *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&unsigned char buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1518;
            __int16 v199 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
            goto LABEL_488;
          }
          long long v64 = global_os_log;
          if (v67 >= 10001)
          {
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
              goto LABEL_490;
            }
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v67;
            *(_WORD *)&unsigned char buf[18] = 2048;
            *(void *)&buf[20] = v66;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = "update->add_addresses->vec[i]";
            *(_WORD *)&unsigned char buf[38] = 2080;
            *(void *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&unsigned char buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1518;
            __int16 v199 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_443:
            v276 = v64;
            goto LABEL_489;
          }
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v67;
            *(_WORD *)&unsigned char buf[18] = 2048;
            *(void *)&buf[20] = v66;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = "update->add_addresses->vec[i]";
            *(_WORD *)&unsigned char buf[38] = 2080;
            *(void *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&unsigned char buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1518;
            _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            uint64_t v60 = *(void *)(*(void *)(a1 + 40) + 8);
            long long v66 = *(int **)(v60 + 8 * v40);
            int v67 = *v66;
          }
          *long long v66 = v67 - 1;
          if (v67 == 1)
          {
            long long v68 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)int buf = 136447234;
              *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&unsigned char buf[12] = 2048;
              *(void *)&buf[14] = v66;
              *(_WORD *)&buf[22] = 2080;
              *(void *)&unsigned char buf[24] = "update->add_addresses->vec[i]";
              *(_WORD *)&uint8_t buf[32] = 2080;
              *(void *)&buf[34] = "srp-mdns-proxy.c";
              *(_WORD *)&buf[42] = 1024;
              *(_DWORD *)&buf[44] = 1518;
              _os_log_impl((void *)&_mh_execute_header, v68, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
              long long v66 = *(int **)(*(void *)(*(void *)(a1 + 40) + 8) + 8 * v40);
            }
            ++adv_record_finalized;
            adv_record_finalize((uint64_t)v66);
            uint64_t v60 = *(void *)(*(void *)(a1 + 40) + 8);
          }
        }
        ++v41;
        *(void *)(v60 + 8 * v40) = 0;
LABEL_96:
        ++v40;
        uint64_t v39 = *(void *)(a1 + 40);
        if (v40 >= *(int *)(v39 + 4)) {
          goto LABEL_99;
        }
      }
    }
    int v41 = v20;
LABEL_99:
    *((_DWORD *)v18 + 1) = v41;
  }
  uint64_t v69 = *(void *)(v3 + 112);
  if (v69 && (uint64_t v70 = *(unsigned int *)(v69 + 4), (int)v70 >= 1))
  {
    int v71 = 0;
    long long v72 = *(void **)(v69 + 8);
    do
    {
      if (*v72++) {
        ++v71;
      }
      --v70;
    }
    while (v70);
  }
  else
  {
    int v71 = 0;
  }
  uint64_t v74 = *(void *)(a1 + 80);
  v286 = (int *)v18;
  if (v74 && (uint64_t v75 = *(unsigned int *)(v74 + 4), (int)v75 >= 1))
  {
    int v76 = 0;
    int v77 = *(void **)(v74 + 8);
    do
    {
      if (*v77++) {
        ++v76;
      }
      --v75;
    }
    while (v75);
  }
  else
  {
    int v76 = 0;
  }
  int v79 = v76 + v71;
  v288 = adv_instance_vec_create(v76 + v71);
  if (!v288)
  {
    if (v286)
    {
      int v138 = *v286;
      if (!*v286)
      {
        uint64_t v279 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_490;
        }
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 0;
        *(_WORD *)&unsigned char buf[18] = 2048;
        *(void *)&buf[20] = v286;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "addresses";
        *(_WORD *)&unsigned char buf[38] = 2080;
        *(void *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&unsigned char buf[48] = 1024;
        *(_DWORD *)&buf[50] = 1549;
        __int16 v199 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_488;
      }
      BOOL v139 = global_os_log;
      if (v138 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_490;
        }
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v138;
        *(_WORD *)&unsigned char buf[18] = 2048;
        *(void *)&buf[20] = v286;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "addresses";
        *(_WORD *)&unsigned char buf[38] = 2080;
        *(void *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&unsigned char buf[48] = 1024;
        *(_DWORD *)&buf[50] = 1549;
        __int16 v199 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_481;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v138;
        *(_WORD *)&unsigned char buf[18] = 2048;
        *(void *)&buf[20] = v286;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "addresses";
        *(_WORD *)&unsigned char buf[38] = 2080;
        *(void *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&unsigned char buf[48] = 1024;
        *(_DWORD *)&buf[50] = 1549;
        _os_log_impl((void *)&_mh_execute_header, v139, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        int v138 = *v286;
      }
      int *v286 = v138 - 1;
      if (v138 == 1)
      {
        uint64_t v140 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447234;
          *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v286;
          *(_WORD *)&buf[22] = 2080;
          *(void *)&unsigned char buf[24] = "addresses";
          *(_WORD *)&uint8_t buf[32] = 2080;
          *(void *)&buf[34] = "srp-mdns-proxy.c";
          *(_WORD *)&buf[42] = 1024;
          *(_DWORD *)&buf[44] = 1549;
          _os_log_impl((void *)&_mh_execute_header, v140, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        }
        ++adv_record_vec_finalized;
        adv_record_vec_finalize((uint64_t)v286);
      }
    }
    update_failed(a1, 2u, 1);
    return;
  }
  uint64_t v80 = *(void *)(v3 + 112);
  if (!v80 || *(int *)(v80 + 4) < 1)
  {
    int v82 = 0;
    goto LABEL_209;
  }
  uint64_t v81 = 0;
  int v82 = 0;
  while (v82 != v79)
  {
    uint64_t v83 = *(void *)(a1 + 56);
    if (v83)
    {
      uint64_t v84 = *(void *)(*(void *)(v83 + 8) + 8 * v81);
      uint64_t v85 = *(void *)(a1 + 64);
      if (v84)
      {
        if (v85)
        {
          uint64_t v86 = *(void *)(*(void *)(v85 + 8) + 8 * v81);
          uint64_t v87 = global_os_log;
          if (v86)
          {
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v88 = *(void *)(v86 + 48);
              uint64_t v89 = *(void *)(v86 + 56);
              int v90 = *(_DWORD *)(v86 + 64);
              *(_DWORD *)int buf = 136447491;
              *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&unsigned char buf[12] = 2160;
              *(void *)&buf[14] = 1752392040;
              *(_WORD *)&buf[22] = 2081;
              *(void *)&unsigned char buf[24] = v88;
              *(_WORD *)&uint8_t buf[32] = 2160;
              *(void *)&buf[34] = 1752392040;
              *(_WORD *)&buf[42] = 2081;
              *(void *)&buf[44] = v89;
              *(_WORD *)&buf[52] = 1024;
              *(_DWORD *)&buf[54] = v90;
              _os_log_impl((void *)&_mh_execute_header, v87, OS_LOG_TYPE_DEFAULT, "%{public}s: removed instance %{private, mask.hash}s %{private, mask.hash}s %d", buf, 0x3Au);
              uint64_t v87 = global_os_log;
            }
            if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v91 = *(void *)(v84 + 48);
              uint64_t v92 = *(void *)(v84 + 56);
              int v93 = *(_DWORD *)(v84 + 64);
              *(_DWORD *)int buf = 136447491;
              *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&unsigned char buf[12] = 2160;
              *(void *)&buf[14] = 1752392040;
              *(_WORD *)&buf[22] = 2081;
              *(void *)&unsigned char buf[24] = v91;
              *(_WORD *)&uint8_t buf[32] = 2160;
              *(void *)&buf[34] = 1752392040;
              *(_WORD *)&buf[42] = 2081;
              *(void *)&buf[44] = v92;
              *(_WORD *)&buf[52] = 1024;
              *(_DWORD *)&buf[54] = v93;
              int v94 = v87;
              int v95 = "%{public}s: added instance %{private, mask.hash}s %{private, mask.hash}s %d";
              goto LABEL_152;
            }
            goto LABEL_153;
          }
        }
        else
        {
          uint64_t v87 = global_os_log;
        }
        if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v116 = *(void *)(v84 + 48);
          uint64_t v117 = *(void *)(v84 + 56);
          int v118 = *(_DWORD *)(v84 + 64);
          *(_DWORD *)int buf = 136447491;
          *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&unsigned char buf[12] = 2160;
          *(void *)&buf[14] = 1752392040;
          *(_WORD *)&buf[22] = 2081;
          *(void *)&unsigned char buf[24] = v116;
          *(_WORD *)&uint8_t buf[32] = 2160;
          *(void *)&buf[34] = 1752392040;
          *(_WORD *)&buf[42] = 2081;
          *(void *)&buf[44] = v117;
          *(_WORD *)&buf[52] = 1024;
          *(_DWORD *)&buf[54] = v118;
          int v94 = v87;
          int v95 = "%{public}s: updated instance %{private, mask.hash}s %{private, mask.hash}s %d";
LABEL_152:
          _os_log_impl((void *)&_mh_execute_header, v94, OS_LOG_TYPE_DEFAULT, v95, buf, 0x3Au);
        }
LABEL_153:
        *(void *)(v288[1] + 8 * v82) = v84;
        unsigned int v119 = *(int **)(v288[1] + 8 * v82);
        if (v119)
        {
          uint64_t v120 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v121 = *v119;
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v121;
            *(_WORD *)&unsigned char buf[18] = 2048;
            *(void *)&buf[20] = v119;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = "instances->vec[j]";
            *(_WORD *)&unsigned char buf[38] = 2080;
            *(void *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&unsigned char buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1576;
            _os_log_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            unsigned int v119 = *(int **)(v288[1] + 8 * v82);
          }
          int v122 = *v119;
          if (*v119)
          {
            int v123 = v122 + 1;
            int *v119 = v122 + 1;
            if (v122 + 1 >= 10001)
            {
              uint64_t v279 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                goto LABEL_490;
              }
              *(_DWORD *)int buf = 136447490;
              *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v123;
              *(_WORD *)&unsigned char buf[18] = 2048;
              *(void *)&buf[20] = v119;
              *(_WORD *)&buf[28] = 2080;
              *(void *)&buf[30] = "instances->vec[j]";
              *(_WORD *)&unsigned char buf[38] = 2080;
              *(void *)&buf[40] = "srp-mdns-proxy.c";
              *(_WORD *)&unsigned char buf[48] = 1024;
              *(_DWORD *)&buf[50] = 1576;
              __int16 v199 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
              goto LABEL_488;
            }
          }
          else
          {
            ++adv_instance_created;
            int *v119 = 1;
          }
        }
        uint64_t v124 = *(void *)(*(void *)(a1 + 56) + 8);
        os_log_type_t v125 = *(int **)(v124 + 8 * v81);
        if (v125)
        {
          int v126 = *v125;
          if (!*v125)
          {
            uint64_t v279 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
              goto LABEL_490;
            }
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 0;
            *(_WORD *)&unsigned char buf[18] = 2048;
            *(void *)&buf[20] = v125;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = "update->update_instances->vec[i]";
            *(_WORD *)&unsigned char buf[38] = 2080;
            *(void *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&unsigned char buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1578;
            __int16 v199 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
            goto LABEL_488;
          }
          uint64_t v127 = global_os_log;
          if (v126 >= 10001)
          {
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
              goto LABEL_490;
            }
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v126;
            *(_WORD *)&unsigned char buf[18] = 2048;
            *(void *)&buf[20] = v125;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = "update->update_instances->vec[i]";
            *(_WORD *)&unsigned char buf[38] = 2080;
            *(void *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&unsigned char buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1578;
            __int16 v199 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
            goto LABEL_454;
          }
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v126;
            *(_WORD *)&unsigned char buf[18] = 2048;
            *(void *)&buf[20] = v125;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = "update->update_instances->vec[i]";
            *(_WORD *)&unsigned char buf[38] = 2080;
            *(void *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&unsigned char buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1578;
            _os_log_impl((void *)&_mh_execute_header, v127, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            uint64_t v124 = *(void *)(*(void *)(a1 + 56) + 8);
            os_log_type_t v125 = *(int **)(v124 + 8 * v81);
            int v126 = *v125;
          }
          int *v125 = v126 - 1;
          if (v126 == 1)
          {
            int v128 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)int buf = 136447234;
              *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&unsigned char buf[12] = 2048;
              *(void *)&buf[14] = v125;
              *(_WORD *)&buf[22] = 2080;
              *(void *)&unsigned char buf[24] = "update->update_instances->vec[i]";
              *(_WORD *)&uint8_t buf[32] = 2080;
              *(void *)&buf[34] = "srp-mdns-proxy.c";
              *(_WORD *)&buf[42] = 1024;
              *(_DWORD *)&buf[44] = 1578;
              _os_log_impl((void *)&_mh_execute_header, v128, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
              os_log_type_t v125 = *(int **)(*(void *)(*(void *)(a1 + 56) + 8) + 8 * v81);
            }
            ++adv_instance_finalized;
            adv_instance_finalize(v125);
            uint64_t v124 = *(void *)(*(void *)(a1 + 56) + 8);
          }
        }
        *(void *)(v124 + 8 * v81) = 0;
        int v129 = *(int **)(v84 + 32);
        if (v129)
        {
          int v130 = *v129;
          if (!*v129)
          {
            uint64_t v279 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
              goto LABEL_490;
            }
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 0;
            *(_WORD *)&unsigned char buf[18] = 2048;
            *(void *)&buf[20] = v129;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = "instance->update";
            *(_WORD *)&unsigned char buf[38] = 2080;
            *(void *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&unsigned char buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1581;
            __int16 v199 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
            goto LABEL_488;
          }
          uint64_t v127 = global_os_log;
          if (v130 >= 10001)
          {
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
              goto LABEL_490;
            }
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v130;
            *(_WORD *)&unsigned char buf[18] = 2048;
            *(void *)&buf[20] = v129;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = "instance->update";
            *(_WORD *)&unsigned char buf[38] = 2080;
            *(void *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&unsigned char buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1581;
            __int16 v199 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_454:
            v276 = v127;
LABEL_489:
            _os_log_impl((void *)&_mh_execute_header, v276, OS_LOG_TYPE_FAULT, v199, buf, 0x36u);
            goto LABEL_490;
          }
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v130;
            *(_WORD *)&unsigned char buf[18] = 2048;
            *(void *)&buf[20] = v129;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = "instance->update";
            *(_WORD *)&unsigned char buf[38] = 2080;
            *(void *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&unsigned char buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1581;
            _os_log_impl((void *)&_mh_execute_header, v127, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            int v129 = *(int **)(v84 + 32);
            int v130 = *v129;
          }
          *int v129 = v130 - 1;
          if (v130 == 1)
          {
            int v131 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)int buf = 136447234;
              *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&unsigned char buf[12] = 2048;
              *(void *)&buf[14] = v129;
              *(_WORD *)&buf[22] = 2080;
              *(void *)&unsigned char buf[24] = "instance->update";
              *(_WORD *)&uint8_t buf[32] = 2080;
              *(void *)&buf[34] = "srp-mdns-proxy.c";
              *(_WORD *)&buf[42] = 1024;
              *(_DWORD *)&buf[44] = 1581;
              _os_log_impl((void *)&_mh_execute_header, v131, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
              int v129 = *(int **)(v84 + 32);
            }
            ++adv_update_finalized;
            adv_update_finalize((uint64_t)v129);
          }
          *(void *)(v84 + 32) = 0;
        }
LABEL_179:
        ++v82;
        set_instance_message(v84, v289);
        goto LABEL_180;
      }
    }
    else
    {
      uint64_t v85 = *(void *)(a1 + 64);
    }
    if (v85 && (uint64_t v96 = *(void *)(*(void *)(v85 + 8) + 8 * v81)) != 0)
    {
      uint64_t v97 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v98 = *(void *)(v96 + 48);
        uint64_t v99 = *(void *)(v96 + 56);
        int v100 = *(_DWORD *)(v96 + 64);
        *(_DWORD *)int buf = 136447491;
        *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&unsigned char buf[12] = 2160;
        *(void *)&buf[14] = 1752392040;
        *(_WORD *)&buf[22] = 2081;
        *(void *)&unsigned char buf[24] = v98;
        *(_WORD *)&uint8_t buf[32] = 2160;
        *(void *)&buf[34] = 1752392040;
        *(_WORD *)&buf[42] = 2081;
        *(void *)&buf[44] = v99;
        *(_WORD *)&buf[52] = 1024;
        *(_DWORD *)&buf[54] = v100;
        _os_log_impl((void *)&_mh_execute_header, v97, OS_LOG_TYPE_DEFAULT, "%{public}s: removed instance %{private, mask.hash}s %{private, mask.hash}s %d", buf, 0x3Au);
      }
      *(void *)(v288[1] + 8 * v82) = v96;
      int v101 = *(int **)(v288[1] + 8 * v82);
      if (v101)
      {
        uint64_t v102 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v103 = *v101;
          *(_DWORD *)int buf = 136447490;
          *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v103;
          *(_WORD *)&unsigned char buf[18] = 2048;
          *(void *)&buf[20] = v101;
          *(_WORD *)&buf[28] = 2080;
          *(void *)&buf[30] = "instances->vec[j]";
          *(_WORD *)&unsigned char buf[38] = 2080;
          *(void *)&buf[40] = "srp-mdns-proxy.c";
          *(_WORD *)&unsigned char buf[48] = 1024;
          *(_DWORD *)&buf[50] = 1591;
          _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          int v101 = *(int **)(v288[1] + 8 * v82);
        }
        int v104 = *v101;
        if (*v101)
        {
          int v105 = v104 + 1;
          int *v101 = v104 + 1;
          if (v104 + 1 >= 10001)
          {
            uint64_t v279 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
              goto LABEL_490;
            }
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v105;
            *(_WORD *)&unsigned char buf[18] = 2048;
            *(void *)&buf[20] = v101;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = "instances->vec[j]";
            *(_WORD *)&unsigned char buf[38] = 2080;
            *(void *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&unsigned char buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1591;
            __int16 v199 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_488:
            v276 = v279;
            goto LABEL_489;
          }
        }
        else
        {
          ++adv_instance_created;
          int *v101 = 1;
        }
      }
      *(unsigned char *)(v96 + 116) = 1;
      if (v289)
      {
        BOOL v132 = *(int **)(v96 + 88);
        if (v132) {
          ioloop_message_release_(v132, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1596);
        }
        *(void *)(v96 + 88) = v289;
        ioloop_message_retain_(v289, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1599);
      }
      ++v82;
      uint64_t v133 = *(void *)(v96 + 8);
      if (v133)
      {
        ioloop_dnssd_txn_cancel(v133);
        ioloop_dnssd_txn_release_(*(int **)(v96 + 8), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1606);
        *(void *)(v96 + 8) = 0;
      }
      else
      {
        BOOL v134 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          uint64_t v135 = *(void *)(v96 + 48);
          uint64_t v136 = *(void *)(v96 + 56);
          uint64_t v137 = *(void *)(v3 + 56);
          *(_DWORD *)int buf = 136447747;
          *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&unsigned char buf[12] = 2160;
          *(void *)&buf[14] = 1752392040;
          *(_WORD *)&buf[22] = 2081;
          *(void *)&unsigned char buf[24] = v135;
          *(_WORD *)&uint8_t buf[32] = 2160;
          *(void *)&buf[34] = 1752392040;
          *(_WORD *)&buf[42] = 2081;
          *(void *)&buf[44] = v136;
          *(_WORD *)&buf[52] = 2160;
          *(void *)&buf[54] = 1752392040;
          *(_WORD *)&buf[62] = 2081;
          *(void *)&buf[64] = v137;
          _os_log_impl((void *)&_mh_execute_header, v134, OS_LOG_TYPE_ERROR, "%{public}s: instance %{private, mask.hash}s.%{private, mask.hash}s for host %{private, mask.hash}s has no connection.", buf, 0x48u);
        }
      }
    }
    else
    {
      uint64_t v84 = *(void *)(*(void *)(v80 + 8) + 8 * v81);
      if (v84)
      {
        __int16 v106 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v107 = *(void *)(v84 + 48);
          uint64_t v108 = *(void *)(v84 + 56);
          int v109 = *(_DWORD *)(v84 + 64);
          uint64_t v110 = *(void *)(v84 + 88);
          *(_DWORD *)int buf = 136447747;
          *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&unsigned char buf[12] = 2160;
          *(void *)&buf[14] = 1752392040;
          *(_WORD *)&buf[22] = 2081;
          *(void *)&unsigned char buf[24] = v107;
          *(_WORD *)&uint8_t buf[32] = 2160;
          *(void *)&buf[34] = 1752392040;
          *(_WORD *)&buf[42] = 2081;
          *(void *)&buf[44] = v108;
          *(_WORD *)&buf[52] = 1024;
          *(_DWORD *)&buf[54] = v109;
          *(_WORD *)&buf[58] = 2048;
          *(void *)&buf[60] = v110;
          _os_log_impl((void *)&_mh_execute_header, v106, OS_LOG_TYPE_DEFAULT, "%{public}s: kept instance %{private, mask.hash}s %{private, mask.hash}s %d, instance->message = %p", buf, 0x44u);
        }
        *(void *)(v288[1] + 8 * v82) = v84;
        long long v111 = *(int **)(v288[1] + 8 * v82);
        if (v111)
        {
          int v112 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v113 = *v111;
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v113;
            *(_WORD *)&unsigned char buf[18] = 2048;
            *(void *)&buf[20] = v111;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = "instances->vec[j]";
            *(_WORD *)&unsigned char buf[38] = 2080;
            *(void *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&unsigned char buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1615;
            _os_log_impl((void *)&_mh_execute_header, v112, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            long long v111 = *(int **)(v288[1] + 8 * v82);
          }
          int v114 = *v111;
          if (*v111)
          {
            int v115 = v114 + 1;
            *long long v111 = v114 + 1;
            if (v114 + 1 >= 10001)
            {
              uint64_t v279 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                goto LABEL_490;
              }
              *(_DWORD *)int buf = 136447490;
              *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v115;
              *(_WORD *)&unsigned char buf[18] = 2048;
              *(void *)&buf[20] = v111;
              *(_WORD *)&buf[28] = 2080;
              *(void *)&buf[30] = "instances->vec[j]";
              *(_WORD *)&unsigned char buf[38] = 2080;
              *(void *)&buf[40] = "srp-mdns-proxy.c";
              *(_WORD *)&unsigned char buf[48] = 1024;
              *(_DWORD *)&buf[50] = 1615;
              __int16 v199 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
              goto LABEL_488;
            }
          }
          else
          {
            ++adv_instance_created;
            *long long v111 = 1;
          }
        }
        goto LABEL_179;
      }
    }
LABEL_180:
    ++v81;
    uint64_t v80 = *(void *)(v3 + 112);
    if (v81 >= *(int *)(v80 + 4)) {
      goto LABEL_209;
    }
  }
  int v141 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)int buf = 136446722;
    *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v79;
    *(_WORD *)&unsigned char buf[18] = 1024;
    *(_DWORD *)&buf[20] = v79;
    _os_log_impl((void *)&_mh_execute_header, v141, OS_LOG_TYPE_FAULT, "%{public}s: j (%d) == num_instances (%d)", buf, 0x18u);
  }
  int v82 = v79;
LABEL_209:
  uint64_t v142 = *(void *)(a1 + 72);
  if (v142 && *(int *)(v142 + 4) >= 1)
  {
    uint64_t v143 = 0;
    do
    {
      uint64_t v144 = *(void *)(*(void *)(v142 + 8) + 8 * v143);
      if (v144)
      {
        if (v289)
        {
          uint64_t v145 = *(int **)(v144 + 88);
          if (v145) {
            ioloop_message_release_(v145, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1631);
          }
          *(void *)(v144 + 88) = v289;
          ioloop_message_retain_(v289, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1634);
        }
        *(void *)(v144 + 96) = 0;
        char v146 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v147 = *(void *)(v144 + 48);
          uint64_t v148 = *(void *)(v144 + 56);
          int v149 = *(_DWORD *)(v144 + 64);
          *(_DWORD *)int buf = 136447491;
          *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&unsigned char buf[12] = 2160;
          *(void *)&buf[14] = 1752392040;
          *(_WORD *)&buf[22] = 2081;
          *(void *)&unsigned char buf[24] = v147;
          *(_WORD *)&uint8_t buf[32] = 2160;
          *(void *)&buf[34] = 1752392040;
          *(_WORD *)&buf[42] = 2081;
          *(void *)&buf[44] = v148;
          *(_WORD *)&buf[52] = 1024;
          *(_DWORD *)&buf[54] = v149;
          _os_log_impl((void *)&_mh_execute_header, v146, OS_LOG_TYPE_DEFAULT, "%{public}s: renewed instance %{private, mask.hash}s %{private, mask.hash}s %d", buf, 0x3Au);
        }
      }
      ++v143;
      uint64_t v142 = *(void *)(a1 + 72);
    }
    while (v143 < *(int *)(v142 + 4));
  }
  uint64_t v150 = *(void *)(a1 + 80);
  if (v150 && *(int *)(v150 + 4) >= 1)
  {
    for (uint64_t i = 0; i < *(int *)(v150 + 4); ++i)
    {
      uint64_t v152 = *(void *)(*(void *)(v150 + 8) + 8 * i);
      if (v152)
      {
        unint64_t v153 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v154 = *(void *)(v152 + 48);
          uint64_t v155 = *(void *)(v152 + 56);
          int v156 = *(_DWORD *)(v152 + 64);
          *(_DWORD *)int buf = 136447491;
          *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&unsigned char buf[12] = 2160;
          *(void *)&buf[14] = 1752392040;
          *(_WORD *)&buf[22] = 2081;
          *(void *)&unsigned char buf[24] = v154;
          *(_WORD *)&uint8_t buf[32] = 2160;
          *(void *)&buf[34] = 1752392040;
          *(_WORD *)&buf[42] = 2081;
          *(void *)&buf[44] = v155;
          *(_WORD *)&buf[52] = 1024;
          *(_DWORD *)&buf[54] = v156;
          _os_log_impl((void *)&_mh_execute_header, v153, OS_LOG_TYPE_DEFAULT, "%{public}s: added instance %{private, mask.hash}s %{private, mask.hash}s %d", buf, 0x3Au);
        }
        *(void *)(v288[1] + 8 * v82) = v152;
        __int16 v157 = *(int **)(v288[1] + 8 * v82);
        if (v157)
        {
          uint32_t v158 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v159 = *v157;
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v159;
            *(_WORD *)&unsigned char buf[18] = 2048;
            *(void *)&buf[20] = v157;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = "instances->vec[j]";
            *(_WORD *)&unsigned char buf[38] = 2080;
            *(void *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&unsigned char buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1650;
            _os_log_impl((void *)&_mh_execute_header, v158, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            __int16 v157 = *(int **)(v288[1] + 8 * v82);
          }
          int v160 = *v157;
          if (*v157)
          {
            int v161 = v160 + 1;
            int *v157 = v160 + 1;
            if (v160 + 1 >= 10001)
            {
              uint64_t v279 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                goto LABEL_490;
              }
              *(_DWORD *)int buf = 136447490;
              *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v161;
              *(_WORD *)&unsigned char buf[18] = 2048;
              *(void *)&buf[20] = v157;
              *(_WORD *)&buf[28] = 2080;
              *(void *)&buf[30] = "instances->vec[j]";
              *(_WORD *)&unsigned char buf[38] = 2080;
              *(void *)&buf[40] = "srp-mdns-proxy.c";
              *(_WORD *)&unsigned char buf[48] = 1024;
              *(_DWORD *)&buf[50] = 1650;
              __int16 v199 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
              goto LABEL_488;
            }
          }
          else
          {
            ++adv_instance_created;
            int *v157 = 1;
          }
        }
        uint64_t v162 = *(void *)(*(void *)(a1 + 80) + 8);
        uint64_t v163 = *(int **)(v162 + 8 * i);
        if (v163)
        {
          int v164 = *v163;
          if (!*v163)
          {
            uint64_t v279 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
              goto LABEL_490;
            }
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 0;
            *(_WORD *)&unsigned char buf[18] = 2048;
            *(void *)&buf[20] = v163;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = "update->add_instances->vec[i]";
            *(_WORD *)&unsigned char buf[38] = 2080;
            *(void *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&unsigned char buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1652;
            __int16 v199 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
            goto LABEL_488;
          }
          unsigned int v165 = global_os_log;
          if (v164 >= 10001)
          {
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)int buf = 136447490;
              *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v164;
              *(_WORD *)&unsigned char buf[18] = 2048;
              *(void *)&buf[20] = v163;
              *(_WORD *)&buf[28] = 2080;
              *(void *)&buf[30] = "update->add_instances->vec[i]";
              *(_WORD *)&unsigned char buf[38] = 2080;
              *(void *)&buf[40] = "srp-mdns-proxy.c";
              *(_WORD *)&unsigned char buf[48] = 1024;
              *(_DWORD *)&buf[50] = 1652;
              __int16 v199 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
              goto LABEL_430;
            }
            goto LABEL_490;
          }
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v164;
            *(_WORD *)&unsigned char buf[18] = 2048;
            *(void *)&buf[20] = v163;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = "update->add_instances->vec[i]";
            *(_WORD *)&unsigned char buf[38] = 2080;
            *(void *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&unsigned char buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1652;
            _os_log_impl((void *)&_mh_execute_header, v165, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            uint64_t v162 = *(void *)(*(void *)(a1 + 80) + 8);
            uint64_t v163 = *(int **)(v162 + 8 * i);
            int v164 = *v163;
          }
          *uint64_t v163 = v164 - 1;
          if (v164 == 1)
          {
            uint64_t v166 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)int buf = 136447234;
              *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&unsigned char buf[12] = 2048;
              *(void *)&buf[14] = v163;
              *(_WORD *)&buf[22] = 2080;
              *(void *)&unsigned char buf[24] = "update->add_instances->vec[i]";
              *(_WORD *)&uint8_t buf[32] = 2080;
              *(void *)&buf[34] = "srp-mdns-proxy.c";
              *(_WORD *)&buf[42] = 1024;
              *(_DWORD *)&buf[44] = 1652;
              _os_log_impl((void *)&_mh_execute_header, v166, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
              uint64_t v163 = *(int **)(*(void *)(*(void *)(a1 + 80) + 8) + 8 * i);
            }
            ++adv_instance_finalized;
            adv_instance_finalize(v163);
            uint64_t v162 = *(void *)(*(void *)(a1 + 80) + 8);
          }
        }
        *(void *)(v162 + 8 * i) = 0;
        uint64_t v167 = *(int **)(v152 + 32);
        if (v167)
        {
          int v168 = *v167;
          if (!*v167)
          {
            uint64_t v279 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
              goto LABEL_490;
            }
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 0;
            *(_WORD *)&unsigned char buf[18] = 2048;
            *(void *)&buf[20] = v167;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = "instance->update";
            *(_WORD *)&unsigned char buf[38] = 2080;
            *(void *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&unsigned char buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1655;
            __int16 v199 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
            goto LABEL_488;
          }
          unsigned int v165 = global_os_log;
          if (v168 >= 10001)
          {
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)int buf = 136447490;
              *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v168;
              *(_WORD *)&unsigned char buf[18] = 2048;
              *(void *)&buf[20] = v167;
              *(_WORD *)&buf[28] = 2080;
              *(void *)&buf[30] = "instance->update";
              *(_WORD *)&unsigned char buf[38] = 2080;
              *(void *)&buf[40] = "srp-mdns-proxy.c";
              *(_WORD *)&unsigned char buf[48] = 1024;
              *(_DWORD *)&buf[50] = 1655;
              __int16 v199 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
              goto LABEL_430;
            }
LABEL_490:
            abort();
          }
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v168;
            *(_WORD *)&unsigned char buf[18] = 2048;
            *(void *)&buf[20] = v167;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = "instance->update";
            *(_WORD *)&unsigned char buf[38] = 2080;
            *(void *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&unsigned char buf[48] = 1024;
            *(_DWORD *)&buf[50] = 1655;
            _os_log_impl((void *)&_mh_execute_header, v165, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            uint64_t v167 = *(int **)(v152 + 32);
            int v168 = *v167;
          }
          *uint64_t v167 = v168 - 1;
          if (v168 == 1)
          {
            uint64_t v169 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)int buf = 136447234;
              *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&unsigned char buf[12] = 2048;
              *(void *)&buf[14] = v167;
              *(_WORD *)&buf[22] = 2080;
              *(void *)&unsigned char buf[24] = "instance->update";
              *(_WORD *)&uint8_t buf[32] = 2080;
              *(void *)&buf[34] = "srp-mdns-proxy.c";
              *(_WORD *)&buf[42] = 1024;
              *(_DWORD *)&buf[44] = 1655;
              _os_log_impl((void *)&_mh_execute_header, v169, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
              uint64_t v167 = *(int **)(v152 + 32);
            }
            ++adv_update_finalized;
            adv_update_finalize((uint64_t)v167);
          }
          *(void *)(v152 + 32) = 0;
        }
        ++v82;
        set_instance_message(v152, v289);
        uint64_t v150 = *(void *)(a1 + 80);
      }
    }
  }
  *((_DWORD *)v288 + 1) = v82;
  if (v82 >= 1)
  {
    uint64_t v170 = v288[1];
    uint64_t v171 = v82;
    do
    {
      if (*(void *)v170) {
        *(unsigned char *)(*(void *)v170 + 119) = 0;
      }
      v170 += 8;
      --v171;
    }
    while (v171);
  }
  uint64_t v172 = *(int **)(v3 + 96);
  if (v172)
  {
    int v173 = *v172;
    if (!*v172)
    {
      uint64_t v279 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_490;
      }
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&buf[20] = v172;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "host->addresses";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&unsigned char buf[48] = 1024;
      *(_DWORD *)&buf[50] = 1673;
      __int16 v199 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_488;
    }
    unsigned int v165 = global_os_log;
    if (v173 < 10001)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v173;
        *(_WORD *)&unsigned char buf[18] = 2048;
        *(void *)&buf[20] = v172;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "host->addresses";
        *(_WORD *)&unsigned char buf[38] = 2080;
        *(void *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&unsigned char buf[48] = 1024;
        *(_DWORD *)&buf[50] = 1673;
        _os_log_impl((void *)&_mh_execute_header, v165, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        uint64_t v172 = *(int **)(v3 + 96);
        int v173 = *v172;
      }
      int *v172 = v173 - 1;
      if (v173 == 1)
      {
        uint64_t v174 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447234;
          *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v172;
          *(_WORD *)&buf[22] = 2080;
          *(void *)&unsigned char buf[24] = "host->addresses";
          *(_WORD *)&uint8_t buf[32] = 2080;
          *(void *)&buf[34] = "srp-mdns-proxy.c";
          *(_WORD *)&buf[42] = 1024;
          *(_DWORD *)&buf[44] = 1673;
          _os_log_impl((void *)&_mh_execute_header, v174, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          uint64_t v172 = *(int **)(v3 + 96);
        }
        ++adv_record_vec_finalized;
        adv_record_vec_finalize((uint64_t)v172);
      }
      goto LABEL_268;
    }
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_490;
    }
    *(_DWORD *)int buf = 136447490;
    *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v173;
    *(_WORD *)&unsigned char buf[18] = 2048;
    *(void *)&buf[20] = v172;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = "host->addresses";
    *(_WORD *)&unsigned char buf[38] = 2080;
    *(void *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&unsigned char buf[48] = 1024;
    *(_DWORD *)&buf[50] = 1673;
    __int16 v199 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_430:
    v276 = v165;
    goto LABEL_489;
  }
LABEL_268:
  *(void *)(v3 + 96) = v286;
  uint64_t v175 = *(void *)(v3 + 112);
  if (v175)
  {
    if (*(int *)(v175 + 4) >= 1)
    {
      for (uint64_t j = 0; j < *(int *)(v175 + 4); ++j)
      {
        int v177 = *(int **)(*(void *)(v175 + 8) + 8 * j);
        uint64_t v178 = global_os_log;
        BOOL v179 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
        if (v177)
        {
          if (v179)
          {
            uint64_t v180 = *((void *)v177 + 6);
            uint64_t v181 = *((void *)v177 + 7);
            uint64_t v182 = *(void *)(v3 + 56);
            int v183 = *v177;
            *(_DWORD *)int buf = 136448259;
            *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = j;
            *(_WORD *)&unsigned char buf[18] = 2160;
            *(void *)&buf[20] = 1752392040;
            *(_WORD *)&buf[28] = 2081;
            *(void *)&buf[30] = v180;
            *(_WORD *)&unsigned char buf[38] = 2160;
            *(void *)&buf[40] = 1752392040;
            *(_WORD *)&unsigned char buf[48] = 2081;
            *(void *)&buf[50] = v181;
            *(_WORD *)&buf[58] = 2160;
            *(void *)&buf[60] = 1752392040;
            *(_WORD *)&buf[68] = 2081;
            *(void *)&buf[70] = v182;
            *(_WORD *)&buf[78] = 1024;
            *(_DWORD *)&buf[80] = v183;
            uint64_t v184 = v178;
            uint64_t v185 = "%{public}s: old host instance %d %{private, mask.hash}s.%{private, mask.hash}s for host %{private, ma"
                   "sk.hash}s has ref_count %d";
            uint32_t v186 = 84;
LABEL_276:
            _os_log_impl((void *)&_mh_execute_header, v184, OS_LOG_TYPE_DEFAULT, v185, buf, v186);
          }
        }
        else if (v179)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = j;
          uint64_t v184 = v178;
          uint64_t v185 = "%{public}s: old host instance %d is NULL";
          uint32_t v186 = 18;
          goto LABEL_276;
        }
        uint64_t v175 = *(void *)(v3 + 112);
      }
    }
    int v187 = *(_DWORD *)v175;
    if (!*(_DWORD *)v175)
    {
      uint64_t v279 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_490;
      }
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&buf[20] = v175;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "host->instances";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&unsigned char buf[48] = 1024;
      *(_DWORD *)&buf[50] = 1687;
      __int16 v199 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_488;
    }
    unsigned int v165 = global_os_log;
    if (v187 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_490;
      }
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v187;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&buf[20] = v175;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "host->instances";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&unsigned char buf[48] = 1024;
      *(_DWORD *)&buf[50] = 1687;
      __int16 v199 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_430;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v187;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&buf[20] = v175;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "host->instances";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&unsigned char buf[48] = 1024;
      *(_DWORD *)&buf[50] = 1687;
      _os_log_impl((void *)&_mh_execute_header, v165, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      uint64_t v175 = *(void *)(v3 + 112);
      int v187 = *(_DWORD *)v175;
    }
    *(_DWORD *)uint64_t v175 = v187 - 1;
    if (v187 == 1)
    {
      uint64_t v188 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136447234;
        *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v175;
        *(_WORD *)&buf[22] = 2080;
        *(void *)&unsigned char buf[24] = "host->instances";
        *(_WORD *)&uint8_t buf[32] = 2080;
        *(void *)&buf[34] = "srp-mdns-proxy.c";
        *(_WORD *)&buf[42] = 1024;
        *(_DWORD *)&buf[44] = 1687;
        _os_log_impl((void *)&_mh_execute_header, v188, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        uint64_t v175 = *(void *)(v3 + 112);
      }
      ++adv_instance_vec_finalized;
      adv_instance_vec_finalize(v175);
    }
  }
  *(void *)(v3 + 112) = v288;
  uint64_t v189 = *(void *)(v3 + 104);
  if (v189)
  {
    uint64_t v190 = *(void *)(a1 + 48);
    if (!v190 || v189 == v190) {
      goto LABEL_317;
    }
    srp_mdns_shared_record_remove(*(void *)(v3 + 8), v189);
    __int16 v191 = *(int **)(v3 + 104);
    if (v191)
    {
      int v192 = *v191;
      if (!*v191)
      {
        uint64_t v279 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_490;
        }
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 0;
        *(_WORD *)&unsigned char buf[18] = 2048;
        *(void *)&buf[20] = v191;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "host->key_record";
        *(_WORD *)&unsigned char buf[38] = 2080;
        *(void *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&unsigned char buf[48] = 1024;
        *(_DWORD *)&buf[50] = 1693;
        __int16 v199 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_488;
      }
      unsigned int v165 = global_os_log;
      if (v192 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_490;
        }
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v192;
        *(_WORD *)&unsigned char buf[18] = 2048;
        *(void *)&buf[20] = v191;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "host->key_record";
        *(_WORD *)&unsigned char buf[38] = 2080;
        *(void *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&unsigned char buf[48] = 1024;
        *(_DWORD *)&buf[50] = 1693;
        __int16 v199 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_430;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v192;
        *(_WORD *)&unsigned char buf[18] = 2048;
        *(void *)&buf[20] = v191;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "host->key_record";
        *(_WORD *)&unsigned char buf[38] = 2080;
        *(void *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&unsigned char buf[48] = 1024;
        *(_DWORD *)&buf[50] = 1693;
        _os_log_impl((void *)&_mh_execute_header, v165, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        __int16 v191 = *(int **)(v3 + 104);
        int v192 = *v191;
      }
      *__int16 v191 = v192 - 1;
      if (v192 == 1)
      {
        __int16 v193 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447234;
          *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v191;
          *(_WORD *)&buf[22] = 2080;
          *(void *)&unsigned char buf[24] = "host->key_record";
          *(_WORD *)&uint8_t buf[32] = 2080;
          *(void *)&buf[34] = "srp-mdns-proxy.c";
          *(_WORD *)&buf[42] = 1024;
          *(_DWORD *)&buf[44] = 1693;
          _os_log_impl((void *)&_mh_execute_header, v193, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          __int16 v191 = *(int **)(v3 + 104);
        }
        ++adv_record_finalized;
        adv_record_finalize((uint64_t)v191);
      }
    }
    *(void *)(v3 + 104) = 0;
  }
  uint64_t v194 = *(int **)(a1 + 48);
  if (v194)
  {
    *(void *)(v3 + 104) = v194;
    uint64_t v195 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v196 = *v194;
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v196;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&buf[20] = v194;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "host->key_record";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&unsigned char buf[48] = 1024;
      *(_DWORD *)&buf[50] = 1698;
      _os_log_impl((void *)&_mh_execute_header, v195, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      uint64_t v194 = *(int **)(v3 + 104);
    }
    int v197 = *v194;
    if (*v194)
    {
      int v198 = v197 + 1;
      int *v194 = v197 + 1;
      if (v197 + 1 >= 10001)
      {
        uint64_t v279 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_490;
        }
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v198;
        *(_WORD *)&unsigned char buf[18] = 2048;
        *(void *)&buf[20] = v194;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "host->key_record";
        *(_WORD *)&unsigned char buf[38] = 2080;
        *(void *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&unsigned char buf[48] = 1024;
        *(_DWORD *)&buf[50] = 1698;
        __int16 v199 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        goto LABEL_488;
      }
    }
    else
    {
      ++adv_record_created;
      int *v194 = 1;
    }
    uint64_t v200 = *(void *)(a1 + 48);
    BOOL v201 = *(int **)(v200 + 32);
    if (v201)
    {
      int v202 = *v201;
      if (!*v201)
      {
        uint64_t v279 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_490;
        }
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 0;
        *(_WORD *)&unsigned char buf[18] = 2048;
        *(void *)&buf[20] = v201;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "update->key->update";
        *(_WORD *)&unsigned char buf[38] = 2080;
        *(void *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&unsigned char buf[48] = 1024;
        *(_DWORD *)&buf[50] = 1700;
        __int16 v199 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_488;
      }
      unsigned int v165 = global_os_log;
      if (v202 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_490;
        }
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v202;
        *(_WORD *)&unsigned char buf[18] = 2048;
        *(void *)&buf[20] = v201;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "update->key->update";
        *(_WORD *)&unsigned char buf[38] = 2080;
        *(void *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&unsigned char buf[48] = 1024;
        *(_DWORD *)&buf[50] = 1700;
        __int16 v199 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_430;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v202;
        *(_WORD *)&unsigned char buf[18] = 2048;
        *(void *)&buf[20] = v201;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "update->key->update";
        *(_WORD *)&unsigned char buf[38] = 2080;
        *(void *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&unsigned char buf[48] = 1024;
        *(_DWORD *)&buf[50] = 1700;
        _os_log_impl((void *)&_mh_execute_header, v165, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        uint64_t v200 = *(void *)(a1 + 48);
        BOOL v201 = *(int **)(v200 + 32);
        int v202 = *v201;
      }
      *BOOL v201 = v202 - 1;
      if (v202 == 1)
      {
        BOOL v203 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447234;
          *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v201;
          *(_WORD *)&buf[22] = 2080;
          *(void *)&unsigned char buf[24] = "update->key->update";
          *(_WORD *)&uint8_t buf[32] = 2080;
          *(void *)&buf[34] = "srp-mdns-proxy.c";
          *(_WORD *)&buf[42] = 1024;
          *(_DWORD *)&buf[44] = 1700;
          _os_log_impl((void *)&_mh_execute_header, v203, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          BOOL v201 = *(int **)(*(void *)(a1 + 48) + 32);
        }
        ++adv_update_finalized;
        adv_update_finalize((uint64_t)v201);
        uint64_t v200 = *(void *)(a1 + 48);
      }
      *(void *)(v200 + 32) = 0;
    }
  }
LABEL_317:
  uint64_t v204 = *(void *)(a1 + 32);
  if (v204 && *(int *)(v204 + 4) >= 1)
  {
    uint64_t v205 = 0;
    do
    {
      uint64_t v206 = *(void *)(*(void *)(v204 + 8) + 8 * v205);
      if (v206)
      {
        srp_mdns_shared_record_remove(*(void *)(v3 + 8), v206);
        uint64_t v204 = *(void *)(a1 + 32);
      }
      ++v205;
    }
    while (v205 < *(int *)(v204 + 4));
  }
  if (v285)
  {
    uint64_t v207 = *(int **)(v3 + 72);
    if (v207) {
      ioloop_message_release_(v207, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1719);
    }
    v208 = (int *)v285[4];
    *(void *)(v3 + 72) = v208;
    ioloop_message_retain_(v208, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1722);
    advertise_finished(*(void *)(v3 + 56), v285[1], v285[4], 0, (uint64_t)v285, 1);
    uint64_t v287 = *v285;
    uint64_t *v285 = 0;
    srp_parse_client_updates_free_(v285, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1728);
    *(void *)(a1 + 16) = 0;
    uint64_t v209 = *(void *)(*(void *)(v3 + 72) + 72);
    if (v209)
    {
      *(void *)(v3 + 200) = v209;
      *(void *)int buf = 0;
      *(void *)&buf[8] = 0;
      clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)buf);
      uint64_t v210 = *(void *)(v3 + 200);
      uint64_t v211 = *(void *)buf - v210;
      unsigned int v212 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136446722;
        *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v210;
        *(_WORD *)&buf[22] = 2048;
        *(void *)&unsigned char buf[24] = v211;
        _os_log_impl((void *)&_mh_execute_header, v212, OS_LOG_TYPE_DEFAULT, "%{public}s: setting host update time based on message received time: %ld, lease offset = %ld", buf, 0x20u);
      }
    }
    else
    {
      unsigned int v214 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = 0;
        _os_log_impl((void *)&_mh_execute_header, v214, OS_LOG_TYPE_DEFAULT, "%{public}s: setting host update time based on current time: %ld", buf, 0x16u);
      }
      *(void *)int buf = 0;
      *(void *)&buf[8] = 0;
      clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)buf);
      uint64_t v211 = 0;
      *(void *)(v3 + 200) = *(void *)buf;
    }
  }
  else
  {
    unsigned int v213 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = 0;
      _os_log_impl((void *)&_mh_execute_header, v213, OS_LOG_TYPE_DEFAULT, "%{public}s: lease offset = %ld", buf, 0x16u);
    }
    *(void *)int buf = 0;
    *(void *)&buf[8] = 0;
    clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)buf);
    uint64_t v287 = 0;
    uint64_t v211 = *(void *)buf - *(void *)(v3 + 200);
  }
  size_t v215 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v216 = *(_DWORD *)a1;
    *(_DWORD *)int buf = 136447490;
    *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v216;
    *(_WORD *)&unsigned char buf[18] = 2048;
    *(void *)&buf[20] = a1;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = "update";
    *(_WORD *)&unsigned char buf[38] = 2080;
    *(void *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&unsigned char buf[48] = 1024;
    *(_DWORD *)&buf[50] = 1743;
    _os_log_impl((void *)&_mh_execute_header, v215, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  int v217 = *(_DWORD *)a1;
  if (*(_DWORD *)a1)
  {
    int v218 = v217 + 1;
    *(_DWORD *)a1 = v217 + 1;
    if (v217 + 1 >= 10001)
    {
      BOOL v139 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_490;
      }
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v218;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&buf[20] = a1;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "update";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&unsigned char buf[48] = 1024;
      *(_DWORD *)&buf[50] = 1743;
      __int16 v199 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_481:
      v276 = v139;
      goto LABEL_489;
    }
  }
  else
  {
    ++adv_update_created;
    *(_DWORD *)a1 = 1;
  }
  char v219 = *(int **)(v3 + 48);
  if (v219)
  {
    int v220 = *v219;
    if (!*v219)
    {
      uint64_t v279 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_490;
      }
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&buf[20] = v219;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "host->update";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&unsigned char buf[48] = 1024;
      *(_DWORD *)&buf[50] = 1749;
      __int16 v199 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_488;
    }
    unsigned int v165 = global_os_log;
    if (v220 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_490;
      }
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v220;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&buf[20] = v219;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "host->update";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&unsigned char buf[48] = 1024;
      *(_DWORD *)&buf[50] = 1749;
      __int16 v199 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_430;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v220;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&buf[20] = v219;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "host->update";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&unsigned char buf[48] = 1024;
      *(_DWORD *)&buf[50] = 1749;
      _os_log_impl((void *)&_mh_execute_header, v165, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      char v219 = *(int **)(v3 + 48);
      int v220 = *v219;
    }
    *char v219 = v220 - 1;
    if (v220 == 1)
    {
      uint64_t v221 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136447234;
        *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v219;
        *(_WORD *)&buf[22] = 2080;
        *(void *)&unsigned char buf[24] = "host->update";
        *(_WORD *)&uint8_t buf[32] = 2080;
        *(void *)&buf[34] = "srp-mdns-proxy.c";
        *(_WORD *)&buf[42] = 1024;
        *(_DWORD *)&buf[44] = 1749;
        _os_log_impl((void *)&_mh_execute_header, v221, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        char v219 = *(int **)(v3 + 48);
      }
      ++adv_update_finalized;
      adv_update_finalize((uint64_t)v219);
    }
    *(void *)(v3 + 48) = 0;
  }
  else
  {
    uint64_t v222 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
      _os_log_impl((void *)&_mh_execute_header, v222, OS_LOG_TYPE_ERROR, "%{public}s: p_update is null.", buf, 0xCu);
    }
  }
  *(_DWORD *)(v3 + 192) = 0;
  int v223 = *(_DWORD *)(a1 + 108);
  *(_DWORD *)(v3 + 248) = v223;
  *(_DWORD *)(v3 + 252) = v223;
  v224 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v225 = *(_DWORD *)(*(void *)(v3 + 72) + 80);
    *(_DWORD *)int buf = 136446978;
    *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v225;
    *(_WORD *)&unsigned char buf[18] = 1024;
    *(_DWORD *)&buf[20] = v223;
    *(_WORD *)&unsigned char buf[24] = 1024;
    *(_DWORD *)&buf[26] = v223;
    _os_log_impl((void *)&_mh_execute_header, v224, OS_LOG_TYPE_DEFAULT, "%{public}s: host->message->lease = %d, host->lease_interval = %d, host->key_lease = %d", buf, 0x1Eu);
  }
  uint64_t v226 = *(void *)(v3 + 72);
  if (!*(_DWORD *)(v226 + 80)) {
    *(void *)(v226 + 80) = *(void *)(v3 + 248);
  }
  *(void *)int buf = 0;
  *(void *)&buf[8] = 0;
  gettimeofday((timeval *)buf, 0);
  uint64_t v227 = 1000 * *(void *)buf + *(_DWORD *)&buf[8] / 1000;
  uint64_t v228 = *(void *)(a1 + 112);
  if (!v228)
  {
    v232 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v233 = *(void *)(v3 + 56);
      uint64_t v234 = 1000 * (*(unsigned int *)(v3 + 248) - v211);
      *(_DWORD *)int buf = 136446979;
      *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&unsigned char buf[12] = 2160;
      *(void *)&buf[14] = 1752392040;
      *(_WORD *)&buf[22] = 2081;
      *(void *)&unsigned char buf[24] = v233;
      *(_WORD *)&uint8_t buf[32] = 2048;
      *(void *)&buf[34] = v234;
      _os_log_impl((void *)&_mh_execute_header, v232, OS_LOG_TYPE_DEFAULT, "%{public}s: lease_expiry (2) for host %{private, mask.hash}s set to %ld", buf, 0x2Au);
    }
    if (v227 + 1000 * (*(unsigned int *)(v3 + 248) - v211) <= v227) {
      uint64_t v228 = v227;
    }
    else {
      uint64_t v228 = v227 + 1000 * (*(unsigned int *)(v3 + 248) - v211);
    }
    goto LABEL_369;
  }
  v229 = global_os_log;
  if (v228 < v227)
  {
    uint64_t v230 = 1000 * *(void *)buf + *(_DWORD *)&buf[8] / 1000;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      uint64_t v231 = *(void *)(v3 + 64);
      *(_DWORD *)int buf = 136446979;
      *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&unsigned char buf[12] = 2160;
      *(void *)&buf[14] = 1752392040;
      *(_WORD *)&buf[22] = 2081;
      *(void *)&unsigned char buf[24] = v231;
      *(_WORD *)&uint8_t buf[32] = 2048;
      *(void *)&buf[34] = v227 - v228;
      _os_log_impl((void *)&_mh_execute_header, v229, OS_LOG_TYPE_ERROR, "%{public}s: lease expiry for host %{private, mask.hash}s happened %llu milliseconds ago.", buf, 0x2Au);
      uint64_t v228 = *(void *)(a1 + 112);
      uint64_t v230 = v227;
    }
    goto LABEL_370;
  }
  uint64_t v230 = *(void *)(a1 + 112);
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v235 = *(void *)(v3 + 56);
    *(_DWORD *)int buf = 136446979;
    *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
    *(_WORD *)&unsigned char buf[12] = 2160;
    *(void *)&buf[14] = 1752392040;
    *(_WORD *)&buf[22] = 2081;
    *(void *)&unsigned char buf[24] = v235;
    *(_WORD *)&uint8_t buf[32] = 2048;
    *(void *)&buf[34] = v228 - v227;
    _os_log_impl((void *)&_mh_execute_header, v229, OS_LOG_TYPE_DEFAULT, "%{public}s: lease_expiry (1) for host %{private, mask.hash}s set to %lld", buf, 0x2Au);
    uint64_t v228 = *(void *)(a1 + 112);
LABEL_369:
    uint64_t v230 = v228;
  }
LABEL_370:
  *(void *)(v3 + 256) = v228;
  uint64_t v236 = *(void *)(v3 + 112);
  if (*(int *)(v236 + 4) >= 1)
  {
    for (uint64_t k = 0; k < *(int *)(v236 + 4); ++k)
    {
      uint64_t v238 = *(void *)(*(void *)(v236 + 8) + 8 * k);
      if (v238)
      {
        if (*(int **)(v238 + 88) == v289)
        {
          int v248 = *(unsigned __int8 *)(v238 + 116);
          v249 = global_os_log;
          BOOL v250 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
          if (!v248)
          {
            uint64_t v261 = *(void *)(v3 + 256);
            if (v250)
            {
              uint64_t v262 = *(void *)(v3 + 56);
              uint64_t v263 = *(void *)(v238 + 48);
              uint64_t v264 = *(void *)(v238 + 56);
              *(_DWORD *)int buf = 136448003;
              *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&unsigned char buf[12] = 2160;
              *(void *)&buf[14] = 1752392040;
              *(_WORD *)&buf[22] = 2081;
              *(void *)&unsigned char buf[24] = v262;
              *(_WORD *)&uint8_t buf[32] = 2160;
              *(void *)&buf[34] = 1752392040;
              *(_WORD *)&buf[42] = 2081;
              *(void *)&buf[44] = v263;
              *(_WORD *)&buf[52] = 2160;
              *(void *)&buf[54] = 1752392040;
              *(_WORD *)&buf[62] = 2081;
              *(void *)&buf[64] = v264;
              *(_WORD *)&buf[72] = 2048;
              *(void *)&buf[74] = v261 - v227;
              _os_log_impl((void *)&_mh_execute_header, v249, OS_LOG_TYPE_DEFAULT, "%{public}s: lease_expiry (4) for host %{private, mask.hash}s instance %{private, mask.hash}s.%{private, mask.hash}s set to %lld", buf, 0x52u);
              uint64_t v261 = *(void *)(v3 + 256);
            }
            *(void *)(v238 + 104) = v261;
            goto LABEL_393;
          }
          if (v250)
          {
            uint64_t v251 = *(void *)(v3 + 56);
            uint64_t v252 = *(void *)(v238 + 48);
            uint64_t v253 = *(void *)(v238 + 56);
            uint64_t v254 = *(void *)(v238 + 104) - v227;
            *(_DWORD *)int buf = 136448003;
            *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&unsigned char buf[12] = 2160;
            *(void *)&buf[14] = 1752392040;
            *(_WORD *)&buf[22] = 2081;
            *(void *)&unsigned char buf[24] = v251;
            *(_WORD *)&uint8_t buf[32] = 2160;
            *(void *)&buf[34] = 1752392040;
            *(_WORD *)&buf[42] = 2081;
            *(void *)&buf[44] = v252;
            *(_WORD *)&buf[52] = 2160;
            *(void *)&buf[54] = 1752392040;
            *(_WORD *)&buf[62] = 2081;
            *(void *)&buf[64] = v253;
            *(_WORD *)&buf[72] = 2048;
            *(void *)&buf[74] = v254;
            v246 = v249;
            v247 = "%{public}s: lease_expiry (7) for host %{private, mask.hash}s removed instance %{private, mask.hash}s."
                   "%{private, mask.hash}s left at %lld";
            goto LABEL_385;
          }
        }
        else
        {
          uint64_t v239 = *(void *)(v238 + 104);
          uint64_t v240 = global_os_log;
          BOOL v241 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
          if (v239 > v227 && v230 > v239)
          {
            uint64_t v230 = v239;
            if (v241)
            {
              uint64_t v255 = *(void *)(v3 + 56);
              uint64_t v256 = *(void *)(v238 + 48);
              uint64_t v257 = *(void *)(v238 + 56);
              *(_DWORD *)int buf = 136448003;
              *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&unsigned char buf[12] = 2160;
              *(void *)&buf[14] = 1752392040;
              *(_WORD *)&buf[22] = 2081;
              *(void *)&unsigned char buf[24] = v255;
              *(_WORD *)&uint8_t buf[32] = 2160;
              *(void *)&buf[34] = 1752392040;
              *(_WORD *)&buf[42] = 2081;
              *(void *)&buf[44] = v256;
              *(_WORD *)&buf[52] = 2160;
              *(void *)&buf[54] = 1752392040;
              *(_WORD *)&buf[62] = 2081;
              *(void *)&buf[64] = v257;
              *(_WORD *)&buf[72] = 2048;
              *(void *)&buf[74] = v239 - v227;
              _os_log_impl((void *)&_mh_execute_header, v240, OS_LOG_TYPE_DEFAULT, "%{public}s: lease_expiry (3) for host %{private, mask.hash}s instance %{private, mask.hash}s.%{private, mask.hash}s set to %lld", buf, 0x52u);
              uint64_t v230 = *(void *)(v238 + 104);
            }
            goto LABEL_393;
          }
          if (v239 <= v227)
          {
            uint64_t v230 = v227;
            if (v241)
            {
              uint64_t v258 = *(void *)(v3 + 56);
              uint64_t v259 = *(void *)(v238 + 48);
              uint64_t v260 = *(void *)(v238 + 56);
              *(_DWORD *)int buf = 136448003;
              *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
              *(_WORD *)&unsigned char buf[12] = 2160;
              *(void *)&buf[14] = 1752392040;
              *(_WORD *)&buf[22] = 2081;
              *(void *)&unsigned char buf[24] = v258;
              *(_WORD *)&uint8_t buf[32] = 2160;
              *(void *)&buf[34] = 1752392040;
              *(_WORD *)&buf[42] = 2081;
              *(void *)&buf[44] = v259;
              *(_WORD *)&buf[52] = 2160;
              *(void *)&buf[54] = 1752392040;
              *(_WORD *)&buf[62] = 2081;
              *(void *)&buf[64] = v260;
              *(_WORD *)&buf[72] = 2048;
              *(void *)&buf[74] = v227 - v239;
              _os_log_impl((void *)&_mh_execute_header, v240, OS_LOG_TYPE_DEFAULT, "%{public}s: lease_expiry (5) for host %{private, mask.hash}s instance %{private, mask.hash}s.%{private, mask.hash}s in the past at %lld", buf, 0x52u);
              uint64_t v230 = v227;
            }
            goto LABEL_393;
          }
          if (v241)
          {
            uint64_t v243 = *(void *)(v3 + 56);
            uint64_t v244 = *(void *)(v238 + 48);
            uint64_t v245 = *(void *)(v238 + 56);
            *(_DWORD *)int buf = 136448003;
            *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
            *(_WORD *)&unsigned char buf[12] = 2160;
            *(void *)&buf[14] = 1752392040;
            *(_WORD *)&buf[22] = 2081;
            *(void *)&unsigned char buf[24] = v243;
            *(_WORD *)&uint8_t buf[32] = 2160;
            *(void *)&buf[34] = 1752392040;
            *(_WORD *)&buf[42] = 2081;
            *(void *)&buf[44] = v244;
            *(_WORD *)&buf[52] = 2160;
            *(void *)&buf[54] = 1752392040;
            *(_WORD *)&buf[62] = 2081;
            *(void *)&buf[64] = v245;
            *(_WORD *)&buf[72] = 2048;
            *(void *)&buf[74] = v230 - v239;
            v246 = v240;
            v247 = "%{public}s: lease_expiry (6) for host %{private, mask.hash}s instance %{private, mask.hash}s.%{privat"
                   "e, mask.hash}s is later than next_lease_expiry by %lld";
LABEL_385:
            _os_log_impl((void *)&_mh_execute_header, v246, OS_LOG_TYPE_DEFAULT, v247, buf, 0x52u);
          }
        }
      }
LABEL_393:
      uint64_t v236 = *(void *)(v3 + 112);
    }
  }
  if ((unint64_t)(v230 - v227) >= 0x7FFFFFFF) {
    unsigned int v265 = 0x7FFFFFFF;
  }
  else {
    unsigned int v265 = v230 - v227;
  }
  __int16 v266 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v267 = *(_DWORD *)v3;
    *(_DWORD *)int buf = 136447490;
    *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v267;
    *(_WORD *)&unsigned char buf[18] = 2048;
    *(void *)&buf[20] = v3;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = "host";
    *(_WORD *)&unsigned char buf[38] = 2080;
    *(void *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&unsigned char buf[48] = 1024;
    *(_DWORD *)&buf[50] = 1881;
    _os_log_impl((void *)&_mh_execute_header, v266, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  int v268 = *(_DWORD *)v3;
  if (*(_DWORD *)v3)
  {
    int v269 = v268 + 1;
    *(_DWORD *)uint64_t v3 = v268 + 1;
    if (v268 + 1 >= 10001)
    {
      uint64_t v279 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_490;
      }
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v269;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&buf[20] = v3;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "host";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&unsigned char buf[48] = 1024;
      *(_DWORD *)&buf[50] = 1881;
      __int16 v199 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_488;
    }
  }
  else
  {
    ++adv_host_created;
    *(_DWORD *)uint64_t v3 = 1;
  }
  __int16 v270 = global_os_log;
  BOOL v271 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (v230 == v227)
  {
    if (v271)
    {
      uint64_t v272 = *(void *)(v3 + 56);
      *(_DWORD *)int buf = 136446723;
      *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&unsigned char buf[12] = 2160;
      *(void *)&buf[14] = 1752392040;
      *(_WORD *)&buf[22] = 2081;
      *(void *)&unsigned char buf[24] = v272;
      _os_log_impl((void *)&_mh_execute_header, v270, OS_LOG_TYPE_DEFAULT, "%{public}s: scheduling immediate call to lease_callback in the run loop for %{private, mask.hash}s", buf, 0x20u);
    }
    *(void *)int buf = _NSConcreteStackBlock;
    *(void *)&buf[8] = 0x40000000;
    *(void *)&uint8_t buf[16] = __ioloop_run_async_block_invoke;
    *(void *)&unsigned char buf[24] = &__block_descriptor_tmp_41;
    *(void *)&uint8_t buf[32] = lease_callback;
    *(void *)&buf[40] = v3;
    *(void *)&unsigned char buf[48] = srp_adv_host_context_release;
    dispatch_async((dispatch_queue_t)ioloop_main_queue, buf);
  }
  else
  {
    if (v271)
    {
      uint64_t v273 = *(void *)(v3 + 56);
      *(_DWORD *)int buf = 136446979;
      *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v265 / 0x3E8uLL;
      *(_WORD *)&buf[22] = 2160;
      *(void *)&unsigned char buf[24] = 1752392040;
      *(_WORD *)&uint8_t buf[32] = 2081;
      *(void *)&buf[34] = v273;
      _os_log_impl((void *)&_mh_execute_header, v270, OS_LOG_TYPE_DEFAULT, "%{public}s: scheduling wakeup to lease_callback in %llu for host %{private, mask.hash}s", buf, 0x2Au);
    }
    ioloop_add_wake_event(*(void *)(v3 + 32), v3, (uint64_t)lease_callback, (uint64_t)srp_adv_host_context_release, v265);
  }
  adv_update_free_instance_vectors(a1);
  int v274 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    BOOL v139 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_490;
    }
    *(_DWORD *)int buf = 136447490;
    *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = 0;
    *(_WORD *)&unsigned char buf[18] = 2048;
    *(void *)&buf[20] = a1;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = "update";
    *(_WORD *)&unsigned char buf[38] = 2080;
    *(void *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&unsigned char buf[48] = 1024;
    *(_DWORD *)&buf[50] = 1897;
    __int16 v199 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_481;
  }
  BOOL v139 = global_os_log;
  if (v274 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_490;
    }
    *(_DWORD *)int buf = 136447490;
    *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v274;
    *(_WORD *)&unsigned char buf[18] = 2048;
    *(void *)&buf[20] = a1;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = "update";
    *(_WORD *)&unsigned char buf[38] = 2080;
    *(void *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&unsigned char buf[48] = 1024;
    *(_DWORD *)&buf[50] = 1897;
    __int16 v199 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_481;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136447490;
    *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v274;
    *(_WORD *)&unsigned char buf[18] = 2048;
    *(void *)&buf[20] = a1;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = "update";
    *(_WORD *)&unsigned char buf[38] = 2080;
    *(void *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&unsigned char buf[48] = 1024;
    *(_DWORD *)&buf[50] = 1897;
    _os_log_impl((void *)&_mh_execute_header, v139, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    int v274 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v274 - 1;
  if (v274 == 1)
  {
    v275 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136447234;
      *(void *)&uint8_t buf[4] = "srp_mdns_update_finished";
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = a1;
      *(_WORD *)&buf[22] = 2080;
      *(void *)&unsigned char buf[24] = "update";
      *(_WORD *)&uint8_t buf[32] = 2080;
      *(void *)&buf[34] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[42] = 1024;
      *(_DWORD *)&buf[44] = 1897;
      _os_log_impl((void *)&_mh_execute_header, v275, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
    }
    ++adv_update_finalized;
    adv_update_finalize(a1);
  }
  if (v287) {
    srp_update_start();
  }
  else {
    srp_dump_server_stats(v284, 0, 0);
  }
}

void *adv_record_vec_create(unsigned int a1)
{
  uint64_t v2 = malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
  if (v2)
  {
    if (a1 <= 1) {
      int v3 = 1;
    }
    else {
      int v3 = a1;
    }
    uint64_t v4 = malloc_type_calloc(v3, 8uLL, 0x2004093837F09uLL);
    v2[1] = v4;
    if (v4)
    {
      uint64_t v5 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v6 = *(_DWORD *)v2;
        *(_DWORD *)int buf = 136447490;
        uint64_t v12 = "adv_record_vec_create";
        __int16 v13 = 1024;
        int v14 = v6;
        __int16 v15 = 2048;
        __int16 v16 = v2;
        __int16 v17 = 2080;
        int v18 = "vec";
        __int16 v19 = 2080;
        int v20 = "srp-mdns-proxy.c";
        __int16 v21 = 1024;
        int v22 = 309;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      }
      if (*(_DWORD *)v2)
      {
        int v7 = *(_DWORD *)v2 + 1;
        *(_DWORD *)uint64_t v2 = v7;
        if (v7 >= 10001)
        {
          int v10 = v7;
          uint64_t v8 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)int buf = 136447490;
            uint64_t v12 = "adv_record_vec_create";
            __int16 v13 = 1024;
            int v14 = v10;
            __int16 v15 = 2048;
            __int16 v16 = v2;
            __int16 v17 = 2080;
            int v18 = "vec";
            __int16 v19 = 2080;
            int v20 = "srp-mdns-proxy.c";
            __int16 v21 = 1024;
            int v22 = 309;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          }
          abort();
        }
      }
      else
      {
        ++adv_record_vec_created;
        *(_DWORD *)uint64_t v2 = 1;
      }
    }
    else
    {
      free(v2);
      return 0;
    }
  }
  return v2;
}

void update_failed(uint64_t a1, unsigned int a2, int a3)
{
  int v6 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = *(_DWORD *)a1;
    *(_DWORD *)int v18 = 136447490;
    *(void *)&v18[4] = "update_failed";
    *(_WORD *)&v18[12] = 1024;
    *(_DWORD *)&unsigned char v18[14] = v7;
    *(_WORD *)&v18[18] = 2048;
    *(void *)&v18[20] = a1;
    *(_WORD *)&v18[28] = 2080;
    *(void *)&v18[30] = "update";
    *(_WORD *)&v18[38] = 2080;
    *(void *)&v18[40] = "srp-mdns-proxy.c";
    __int16 v19 = 1024;
    int v20 = 1034;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v18, 0x36u);
  }
  int v8 = *(_DWORD *)a1;
  if (*(_DWORD *)a1)
  {
    int v9 = v8 + 1;
    *(_DWORD *)a1 = v8 + 1;
    if (v8 + 1 >= 10001)
    {
      int v10 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_39;
      }
      *(_DWORD *)int v18 = 136447490;
      *(void *)&v18[4] = "update_failed";
      *(_WORD *)&v18[12] = 1024;
      *(_DWORD *)&unsigned char v18[14] = v9;
      *(_WORD *)&v18[18] = 2048;
      *(void *)&v18[20] = a1;
      *(_WORD *)&v18[28] = 2080;
      *(void *)&v18[30] = "update";
      *(_WORD *)&v18[38] = 2080;
      *(void *)&v18[40] = "srp-mdns-proxy.c";
      __int16 v19 = 1024;
      int v20 = 1034;
      uint64_t v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_38;
    }
  }
  else
  {
    ++adv_update_created;
    *(_DWORD *)a1 = 1;
  }
  uint64_t v12 = *(void **)(a1 + 16);
  if (v12)
  {
    uint64_t v13 = *(void *)(a1 + 8);
    adv_update_cancel(a1);
    advertise_finished(*(void *)(v13 + 56), v12[1], v12[4], a2, 0, 1);
    srp_parse_client_updates_free_(v12, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1044);
    *(void *)(a1 + 16) = 0;
    if (a3)
    {
      uint64_t v14 = *(void *)(v13 + 256);
      if (!v14
        || (*(void *)int v18 = 0,
            *(void *)&v18[8] = 0,
            gettimeofday((timeval *)v18, 0),
            v14 <= 1000 * *(void *)v18 + *(_DWORD *)&v18[8] / 1000))
      {
        delete_host(v13);
      }
    }
    int v15 = *(_DWORD *)a1;
    if (!*(_DWORD *)a1)
    {
      int v10 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_39;
      }
      *(_DWORD *)int v18 = 136447490;
      *(void *)&v18[4] = "update_failed";
      *(_WORD *)&v18[12] = 1024;
      *(_DWORD *)&unsigned char v18[14] = 0;
      *(_WORD *)&v18[18] = 2048;
      *(void *)&v18[20] = a1;
      *(_WORD *)&v18[28] = 2080;
      *(void *)&v18[30] = "update";
      *(_WORD *)&v18[38] = 2080;
      *(void *)&v18[40] = "srp-mdns-proxy.c";
      __int16 v19 = 1024;
      int v20 = 1053;
      uint64_t v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_38;
    }
    int v10 = global_os_log;
    if (v15 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_39;
      }
      *(_DWORD *)int v18 = 136447490;
      *(void *)&v18[4] = "update_failed";
      *(_WORD *)&v18[12] = 1024;
      *(_DWORD *)&unsigned char v18[14] = v15;
      *(_WORD *)&v18[18] = 2048;
      *(void *)&v18[20] = a1;
      *(_WORD *)&v18[28] = 2080;
      *(void *)&v18[30] = "update";
      *(_WORD *)&v18[38] = 2080;
      *(void *)&v18[40] = "srp-mdns-proxy.c";
      __int16 v19 = 1024;
      int v20 = 1053;
      uint64_t v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_38;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int v18 = 136447490;
      *(void *)&v18[4] = "update_failed";
      *(_WORD *)&v18[12] = 1024;
      *(_DWORD *)&unsigned char v18[14] = v15;
      *(_WORD *)&v18[18] = 2048;
      *(void *)&v18[20] = a1;
      *(_WORD *)&v18[28] = 2080;
      *(void *)&v18[30] = "update";
      *(_WORD *)&v18[38] = 2080;
      *(void *)&v18[40] = "srp-mdns-proxy.c";
      __int16 v19 = 1024;
      int v20 = 1053;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v18, 0x36u);
      int v15 = *(_DWORD *)a1;
    }
    *(_DWORD *)a1 = v15 - 1;
    if (v15 == 1)
    {
      __int16 v16 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int v18 = 136447234;
        *(void *)&v18[4] = "update_failed";
        *(_WORD *)&v18[12] = 2048;
        *(void *)&unsigned char v18[14] = a1;
        *(_WORD *)&v18[22] = 2080;
        *(void *)&v18[24] = "update";
        *(_WORD *)&v18[32] = 2080;
        *(void *)&v18[34] = "srp-mdns-proxy.c";
        *(_WORD *)&v18[42] = 1024;
        *(_DWORD *)&v18[44] = 1053;
LABEL_27:
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v18, 0x30u);
        goto LABEL_28;
      }
      goto LABEL_28;
    }
  }
  else
  {
    adv_update_cancel(a1);
    int v17 = *(_DWORD *)a1;
    if (!*(_DWORD *)a1)
    {
      int v10 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_39;
      }
      *(_DWORD *)int v18 = 136447490;
      *(void *)&v18[4] = "update_failed";
      *(_WORD *)&v18[12] = 1024;
      *(_DWORD *)&unsigned char v18[14] = 0;
      *(_WORD *)&v18[18] = 2048;
      *(void *)&v18[20] = a1;
      *(_WORD *)&v18[28] = 2080;
      *(void *)&v18[30] = "update";
      *(_WORD *)&v18[38] = 2080;
      *(void *)&v18[40] = "srp-mdns-proxy.c";
      __int16 v19 = 1024;
      int v20 = 1057;
      uint64_t v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_38;
    }
    int v10 = global_os_log;
    if (v17 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_39;
      }
      *(_DWORD *)int v18 = 136447490;
      *(void *)&v18[4] = "update_failed";
      *(_WORD *)&v18[12] = 1024;
      *(_DWORD *)&unsigned char v18[14] = v17;
      *(_WORD *)&v18[18] = 2048;
      *(void *)&v18[20] = a1;
      *(_WORD *)&v18[28] = 2080;
      *(void *)&v18[30] = "update";
      *(_WORD *)&v18[38] = 2080;
      *(void *)&v18[40] = "srp-mdns-proxy.c";
      __int16 v19 = 1024;
      int v20 = 1057;
      uint64_t v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_38:
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, v11, v18, 0x36u);
LABEL_39:
      abort();
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int v18 = 136447490;
      *(void *)&v18[4] = "update_failed";
      *(_WORD *)&v18[12] = 1024;
      *(_DWORD *)&unsigned char v18[14] = v17;
      *(_WORD *)&v18[18] = 2048;
      *(void *)&v18[20] = a1;
      *(_WORD *)&v18[28] = 2080;
      *(void *)&v18[30] = "update";
      *(_WORD *)&v18[38] = 2080;
      *(void *)&v18[40] = "srp-mdns-proxy.c";
      __int16 v19 = 1024;
      int v20 = 1057;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v18, 0x36u);
      int v17 = *(_DWORD *)a1;
    }
    *(_DWORD *)a1 = v17 - 1;
    if (v17 == 1)
    {
      __int16 v16 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int v18 = 136447234;
        *(void *)&v18[4] = "update_failed";
        *(_WORD *)&v18[12] = 2048;
        *(void *)&unsigned char v18[14] = a1;
        *(_WORD *)&v18[22] = 2080;
        *(void *)&v18[24] = "update";
        *(_WORD *)&v18[32] = 2080;
        *(void *)&v18[34] = "srp-mdns-proxy.c";
        *(_WORD *)&v18[42] = 1024;
        *(_DWORD *)&v18[44] = 1057;
        goto LABEL_27;
      }
LABEL_28:
      ++adv_update_finalized;
      adv_update_finalize(a1);
    }
  }
}

void *adv_instance_vec_create(unsigned int a1)
{
  uint64_t v2 = malloc_type_calloc(1uLL, 0x10uLL, 0x108004057E67DB5uLL);
  if (v2)
  {
    if (a1 <= 1) {
      int v3 = 1;
    }
    else {
      int v3 = a1;
    }
    uint64_t v4 = malloc_type_calloc(v3, 8uLL, 0x2004093837F09uLL);
    v2[1] = v4;
    if (v4)
    {
      uint64_t v5 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v6 = *(_DWORD *)v2;
        *(_DWORD *)int buf = 136447490;
        uint64_t v12 = "adv_instance_vec_create";
        __int16 v13 = 1024;
        int v14 = v6;
        __int16 v15 = 2048;
        __int16 v16 = v2;
        __int16 v17 = 2080;
        int v18 = "vec";
        __int16 v19 = 2080;
        int v20 = "srp-mdns-proxy.c";
        __int16 v21 = 1024;
        int v22 = 305;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      }
      if (*(_DWORD *)v2)
      {
        int v7 = *(_DWORD *)v2 + 1;
        *(_DWORD *)uint64_t v2 = v7;
        if (v7 >= 10001)
        {
          int v10 = v7;
          int v8 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)int buf = 136447490;
            uint64_t v12 = "adv_instance_vec_create";
            __int16 v13 = 1024;
            int v14 = v10;
            __int16 v15 = 2048;
            __int16 v16 = v2;
            __int16 v17 = 2080;
            int v18 = "vec";
            __int16 v19 = 2080;
            int v20 = "srp-mdns-proxy.c";
            __int16 v21 = 1024;
            int v22 = 305;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          }
          abort();
        }
      }
      else
      {
        ++adv_instance_vec_created;
        *(_DWORD *)uint64_t v2 = 1;
      }
    }
    else
    {
      free(v2);
      return 0;
    }
  }
  return v2;
}

void set_instance_message(uint64_t a1, int *a2)
{
  if (a2 && *(int **)(a1 + 96) == a2)
  {
    uint64_t v4 = *(int **)(a1 + 88);
    if (v4) {
      ioloop_message_release_(v4, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1404);
    }
    *(void *)(a1 + 88) = a2;
    ioloop_message_retain_(a2, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1407);
    *(void *)(a1 + 96) = 0;
  }
}

void advertise_finished(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, char a6)
{
  int v35 = 0;
  memset(v34, 0, sizeof(v34));
  uint64_t v12 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    if (a4 > 0x17)
    {
      __int16 v13 = "Unknown rcode.";
      if (a5) {
        goto LABEL_4;
      }
    }
    else
    {
      __int16 v13 = (&off_10008D228)[a4];
      if (a5)
      {
LABEL_4:
        int v14 = *(_DWORD *)(a5 + 88);
        int v15 = *(_DWORD *)(a5 + 92);
LABEL_7:
        *(_DWORD *)int buf = 136447747;
        *(void *)&uint8_t buf[4] = "advertise_finished";
        *(_WORD *)&unsigned char buf[12] = 2160;
        *(void *)&buf[14] = 1752392040;
        __int16 v22 = 2081;
        uint64_t v23 = a1;
        __int16 v24 = 2082;
        uint64_t v25 = v13;
        __int16 v26 = 1024;
        int v27 = v14;
        __int16 v28 = 1024;
        int v29 = v15;
        __int16 v30 = 2048;
        uint64_t v31 = a2;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: host %{private, mask.hash}s: rcode = %{public}s, lease = %d, key_lease = %d  connection = %p", buf, 0x40u);
        goto LABEL_8;
      }
    }
    int v14 = 0;
    int v15 = 0;
    goto LABEL_7;
  }
LABEL_8:
  if (!a2) {
    return;
  }
  if (a6)
  {
    uint64_t v33 = 0;
    v32[0] = *(_WORD *)(a3 + 88);
    v32[1] = bswap32(a4 | (bswap32(*(_WORD *)(a3 + 90) & 0xF0FF) >> 16) | 0x8000) >> 16;
    *(void *)int buf = v32;
    if (a5)
    {
      uint64_t v33 = 0x100000000000000;
      *(void *)&v34[0] = 0x8000008205290000;
      BYTE8(v34[0]) = 0;
      if ((uint64_t *)((char *)v34 + 13) < &v36)
      {
        *(_WORD *)((char *)v34 + 11) = 512;
        if ((uint64_t *)((char *)v34 + 15) < &v36 && (uint64_t *)((char *)&v34[1] + 3) < &v36)
        {
          *(_DWORD *)((char *)v34 + 15) = bswap32(*(_DWORD *)(a5 + 88));
          if ((uint64_t *)((char *)&v34[1] + 7) < &v36)
          {
            *(_DWORD *)((char *)&v34[1] + 3) = bswap32(*(_DWORD *)(a5 + 92));
            if (v32 != (_WORD *)-25)
            {
              *(_WORD *)((char *)v34 + 13) = bswap32(8u) >> 16;
              BYTE9(v34[0]) = (unsigned __int16)((char *)&v34[1] + 7 - ((char *)v34 + 9) - 2) >> 8;
              BYTE10(v34[0]) = (char *)&v34[1] + 7 - ((char *)v34 + 9) - 2;
              int64_t v16 = (char *)&v34[1] + 7 - (char *)v32;
LABEL_22:
              *(void *)&buf[8] = v16;
              ioloop_send_message(a2, a3, (iovec *)buf);
              return;
            }
          }
        }
      }
      int v18 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        int v19 = 136446210;
        int v20 = "advertise_finished";
        int64_t v16 = 12;
        _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_ERROR, "%{public}s: unexpectedly failed to send EDNS0 lease option.", (uint8_t *)&v19, 0xCu);
        goto LABEL_22;
      }
    }
    int64_t v16 = 12;
    goto LABEL_22;
  }
  __int16 v17 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "advertise_finished";
    _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: not sending response.", buf, 0xCu);
  }
}

uint64_t srp_update_start()
{
  uint64_t v0 = __chkstk_darwin();
  uint64_t v1 = *(void *)(v0 + 40);
  uint64_t v2 = *(void *)(v0 + 80);
  dns_name_print_to_limit(*(uint64_t **)v1, 0, (uint64_t)__s2, 0x3F2uLL);
  int v3 = 0;
  uint64_t v4 = *(void *)(v0 + 32);
  uint64_t v5 = (void *)v0;
  uint64_t v6 = *(void *)(v0 + 8);
  do
  {
    uint64_t v7 = *(void *)(v5[5] + 16);
    unint64_t v8 = *(unsigned int *)(v7 + 20);
    if (v8)
    {
      unint64_t v9 = 0;
      int v10 = 0;
      uint64_t v11 = *(void *)(v7 + 24);
      do
      {
        v10 += bswap32(*(_DWORD *)(v11 + v9));
        v9 += 4;
      }
      while (v9 < v8);
    }
    else
    {
      int v10 = 0;
    }
    if (v5 == (void *)v0)
    {
      int v3 = v10;
    }
    else if (v3 != v10)
    {
      int64_t v16 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446722;
        *(void *)&uint8_t buf[4] = "srp_update_start";
        __int16 v180 = 1024;
        *(_DWORD *)uint64_t v181 = v3;
        *(_WORD *)&v181[4] = 1024;
        *(_DWORD *)&v181[6] = v10;
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "%{public}s: update contains multiple key ids %x and %x", buf, 0x18u);
      }
      int v18 = __s2;
      uint64_t v19 = 0;
      uint64_t v20 = v4;
      unsigned int v21 = 5;
      char v22 = 0;
      goto LABEL_146;
    }
    uint64_t v5 = (void *)*v5;
  }
  while (v5);
  uint64_t v168 = *(void *)(v0 + 16);
  if (!v168)
  {
    uint64_t v14 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_27;
    }
    int v15 = "";
    goto LABEL_25;
  }
  uint64_t v12 = v1;
  uint64_t v13 = *(void *)(v2 + 8);
  if (!v13)
  {
LABEL_17:
    uint64_t v1 = v12;
LABEL_18:
    uint64_t v14 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_27;
    }
    int v15 = *(const char **)(v168 + 16);
LABEL_25:
    *(_DWORD *)int buf = 136447235;
    *(void *)&uint8_t buf[4] = "srp_update_start";
    __int16 v180 = 2160;
    *(void *)uint64_t v181 = 1752392040;
    *(_WORD *)&v181[8] = 2081;
    *(void *)&unsigned char v181[10] = __s2;
    *(_WORD *)&v181[18] = 1024;
    *(_DWORD *)&v181[20] = v3;
    *(_WORD *)&v181[24] = 2082;
    *(void *)&v181[26] = v15;
    uint64_t v23 = "%{public}s: host update for %{private, mask.hash}s, key id %x %{public}s";
    __int16 v24 = v14;
    uint32_t v25 = 48;
LABEL_26:
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, v23, buf, v25);
    goto LABEL_27;
  }
  while (*(_DWORD *)(v13 + 184) != v3 || strcmp(*(const char **)(v13 + 56), __s2))
  {
    uint64_t v13 = *(void *)(v13 + 40);
    if (!v13) {
      goto LABEL_17;
    }
  }
  uint64_t v87 = "";
  uint64_t v88 = __str;
  while (1)
  {
    uint64_t v89 = *(void *)(v13 + 72);
    if (!v89 || (int v90 = *(unsigned __int16 *)(v89 + 88), v90 != *(unsigned __int16 *)(*(void *)(v0 + 32) + 88)))
    {
      uint64_t v92 = *(void *)(v13 + 112);
      if (!v92 || (uint64_t v93 = *(unsigned int *)(v92 + 4), (int)v93 < 1))
      {
LABEL_164:
        uint64_t v1 = v12;
        goto LABEL_165;
      }
      uint64_t v94 = *(void *)(v92 + 8);
      while (1)
      {
        if (*(void *)v94)
        {
          uint64_t v95 = *(void *)(*(void *)v94 + 88);
          if (v95)
          {
            int v90 = *(unsigned __int16 *)(v95 + 88);
            if (v90 == *(unsigned __int16 *)(*(void *)(v0 + 32) + 88)) {
              break;
            }
          }
        }
        v94 += 8;
        if (!--v93) {
          goto LABEL_164;
        }
      }
    }
    uint64_t v91 = (void *)v0;
    uint64_t v0 = *(void *)v0;
    if (v88 != __str) {
      uint64_t v87 = "s";
    }
    if (v88 + 6 < __s2)
    {
      snprintf(v88, 6uLL, " %04x", v90);
      v88 += 5;
    }
    void *v91 = 0;
    srp_parse_client_updates_free_(v91, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 3777);
    if (!v0) {
      break;
    }
    uint64_t v12 = *(void *)(v0 + 40);
  }
  uint64_t v1 = 0;
LABEL_165:
  if (v88 == __str) {
    goto LABEL_18;
  }
  uint64_t v96 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v97 = *(void *)(v168 + 16);
    *(_DWORD *)int buf = 136447747;
    *(void *)&uint8_t buf[4] = "srp_update_start";
    __int16 v180 = 2160;
    *(void *)uint64_t v181 = 1752392040;
    *(_WORD *)&v181[8] = 2081;
    *(void *)&unsigned char v181[10] = __s2;
    *(_WORD *)&v181[18] = 1024;
    *(_DWORD *)&v181[20] = v3;
    *(_WORD *)&v181[24] = 2082;
    *(void *)&v181[26] = v97;
    *(_WORD *)&v181[34] = 2082;
    *(void *)&v181[36] = v87;
    *(_WORD *)&v181[44] = 2082;
    *(void *)&v181[46] = __str;
    uint64_t v23 = "%{public}s: host update for %{private, mask.hash}s, key id %x %{public}s (skipped xid%{public}s%{public}s)";
    __int16 v24 = v96;
    uint32_t v25 = 68;
    goto LABEL_26;
  }
LABEL_27:
  if (!v0)
  {
    advertise_finished((uint64_t)__s2, 0, v4, 0, 0, 0);
    return 1;
  }
  uint64_t v163 = (_DWORD *)v2;
  uint64_t v164 = v0;
  uint64_t v160 = v6;
  uint64_t v161 = v4;
  unsigned int v165 = *(void **)(v0 + 48);
  __int16 v26 = *(uint64_t **)(v0 + 64);
  int v158 = *(_DWORD *)(v0 + 88);
  int v159 = v3;
  if (v158) {
    int v27 = "update";
  }
  else {
    int v27 = "remove";
  }
  uint64_t v162 = v1;
  for (uint64_t i = *(uint64_t **)(v1 + 8); i; uint64_t i = (uint64_t *)*i)
  {
    int v29 = *((unsigned __int16 *)i + 8);
    uint64_t v30 = global_os_log;
    BOOL v31 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
    if (v29 == 1)
    {
      if (v31)
      {
        if (v168) {
          uint32_t v32 = *(const char **)(v168 + 16);
        }
        else {
          uint32_t v32 = "";
        }
        *(_DWORD *)int buf = 136448003;
        *(void *)&uint8_t buf[4] = "srp_update_start";
        __int16 v180 = 2082;
        *(void *)uint64_t v181 = v27;
        *(_WORD *)&v181[8] = 2160;
        *(void *)&unsigned char v181[10] = 1752392040;
        *(_WORD *)&v181[18] = 2081;
        *(void *)&v181[20] = __s2;
        *(_WORD *)&v181[28] = 2160;
        *(void *)&v181[30] = 1752392040;
        *(_WORD *)&v181[38] = 1041;
        *(_DWORD *)&v181[40] = 4;
        *(_WORD *)&v181[44] = 2097;
        *(void *)&v181[46] = i + 3;
        *(_WORD *)&v181[54] = 2082;
        *(void *)&v181[56] = v32;
        uint64_t v36 = v30;
        int v37 = "%{public}s: host %{public}s for %{private, mask.hash}s, address %{private, mask.hash, network:in_addr}.4P %{public}s";
        uint32_t v38 = 78;
LABEL_48:
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, v37, buf, v38);
      }
    }
    else if (v31)
    {
      int v33 = *((unsigned __int8 *)i + 24);
      int v34 = "ULA: ";
      if ((v33 & 0xFE) != 0xFC)
      {
        if (v33 != 254 || (int v34 = "LUA: ", (*((unsigned char *)i + 25) & 0xC0) != 0x80))
        {
          int v34 = "GUA: ";
          if ((v33 & 0xE0) != 0x20) {
            int v34 = "";
          }
        }
      }
      if (v168) {
        int v35 = *(const char **)(v168 + 16);
      }
      else {
        int v35 = "";
      }
      *(_DWORD *)int buf = 136449795;
      *(void *)&uint8_t buf[4] = "srp_update_start";
      __int16 v180 = 2082;
      *(void *)uint64_t v181 = v27;
      *(_WORD *)&v181[8] = 2160;
      *(void *)&unsigned char v181[10] = 1752392040;
      *(_WORD *)&v181[18] = 2081;
      *(void *)&v181[20] = __s2;
      *(_WORD *)&v181[28] = 2082;
      *(void *)&v181[30] = v34;
      *(_WORD *)&v181[38] = 2160;
      *(void *)&v181[40] = 1752392040;
      *(_WORD *)&v181[48] = 1041;
      *(_DWORD *)&v181[50] = 6;
      *(_WORD *)&v181[54] = 2097;
      *(void *)&v181[56] = i + 3;
      *(_WORD *)&v181[64] = 2160;
      *(void *)&v181[66] = 1752392040;
      *(_WORD *)&v181[74] = 1042;
      *(_DWORD *)&v181[76] = 2;
      *(_WORD *)&v181[80] = 2098;
      *(void *)&v181[82] = (char *)i + 30;
      __int16 v182 = 2160;
      uint64_t v183 = 1752392040;
      __int16 v184 = 1041;
      int v185 = 8;
      __int16 v186 = 2097;
      int v187 = i + 4;
      __int16 v188 = 2082;
      uint64_t v189 = v35;
      uint64_t v36 = v30;
      int v37 = "%{public}s: host %{public}s for %{private, mask.hash}s, address {%{public}s%{private, mask.hash, srp:in6_add"
            "r_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} %{public}s";
      uint32_t v38 = 140;
      goto LABEL_48;
    }
  }
  if (v165)
  {
    uint64_t v39 = v165;
    do
    {
      extract_instance_name(__s1, 0xFDuLL, v190, (uint64_t)v39);
      uint64_t v40 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v41 = v39[6];
        if (v41) {
          int v42 = *(unsigned __int16 *)(v41 + 28);
        }
        else {
          int v42 = -1;
        }
        if (v168) {
          int v43 = *(const char **)(v168 + 16);
        }
        else {
          int v43 = "";
        }
        *(_DWORD *)int buf = 136448515;
        *(void *)&uint8_t buf[4] = "srp_update_start";
        __int16 v180 = 2082;
        *(void *)uint64_t v181 = v27;
        *(_WORD *)&v181[8] = 2160;
        *(void *)&unsigned char v181[10] = 1752392040;
        *(_WORD *)&v181[18] = 2081;
        *(void *)&v181[20] = __s2;
        *(_WORD *)&v181[28] = 2160;
        *(void *)&v181[30] = 1752392040;
        *(_WORD *)&v181[38] = 2081;
        *(void *)&v181[40] = __s1;
        *(_WORD *)&v181[48] = 2160;
        *(void *)&v181[50] = 1752392040;
        *(_WORD *)&v181[58] = 2081;
        *(void *)&v181[60] = v190;
        *(_WORD *)&v181[68] = 1024;
        *(_DWORD *)&v181[70] = v42;
        *(_WORD *)&v181[74] = 2082;
        *(void *)&v181[76] = v43;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "%{public}s: host %{public}s for %{private, mask.hash}s, instance name %{private, mask.hash}s, type %{private, mask.hash}s, port %d %{public}s", buf, 0x62u);
      }
      uint64_t v44 = v39[7];
      if (v44)
      {
        dns_txt_data_print((unint64_t)buf, *(unsigned __int8 *)(v44 + 16), *(void *)(v44 + 24));
        uint64_t v45 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t v169 = 136447235;
          uint64_t v170 = "srp_update_start";
          __int16 v171 = 2160;
          uint64_t v172 = 1752392040;
          __int16 v173 = 2081;
          uint64_t v174 = __s1;
          __int16 v175 = 2160;
          uint64_t v176 = 1752392040;
          __int16 v177 = 2081;
          uint64_t v178 = buf;
          _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%{public}s: text data for instance %{private, mask.hash}s: %{private, mask.hash}s", v169, 0x34u);
        }
      }
      uint64_t v39 = (void *)*v39;
    }
    while (v39);
  }
  BOOL v46 = (uint64_t *)(v2 + 8);
  uint64_t v47 = *(void *)(v2 + 8);
  if (!v47)
  {
    uint64_t v166 = (uint64_t *)(v2 + 8);
    int v167 = 0;
    goto LABEL_124;
  }
  uint64_t v0 = v164;
  while (*(unsigned char *)(v47 + 264) || v165 == 0)
  {
LABEL_71:
    uint64_t v47 = *(void *)(v47 + 40);
    if (!v47)
    {
      int v167 = 0;
      goto LABEL_93;
    }
  }
  uint64_t v49 = v165;
  while (1)
  {
    extract_instance_name(__s1, 0xFDuLL, v190, (uint64_t)v49);
    uint64_t v50 = *(void *)(v47 + 112);
    if (*(int *)(v50 + 4) >= 1) {
      break;
    }
LABEL_77:
    uint64_t v53 = *(void *)(v47 + 48);
    if (v53)
    {
      uint64_t v54 = *(void *)(v53 + 80);
      if (v54)
      {
        if (*(int *)(v54 + 4) >= 1)
        {
          uint64_t v55 = 0;
          do
          {
            int v52 = compare_instance(*(void *)(*(void *)(v54 + 8) + 8 * v55), (uint64_t **)v162, v47, __s1, v190);
            if (v52) {
              goto LABEL_85;
            }
            ++v55;
            uint64_t v54 = *(void *)(*(void *)(v47 + 48) + 80);
          }
          while (v55 < *(int *)(v54 + 4));
        }
      }
    }
    uint64_t v49 = (void *)*v49;
    if (!v49) {
      goto LABEL_71;
    }
  }
  uint64_t v51 = 0;
  while (1)
  {
    int v52 = compare_instance(*(void *)(*(void *)(v50 + 8) + 8 * v51), (uint64_t **)v162, v47, __s1, v190);
    if (v52) {
      break;
    }
    ++v51;
    uint64_t v50 = *(void *)(v47 + 112);
    if (v51 >= *(int *)(v50 + 4)) {
      goto LABEL_77;
    }
  }
LABEL_85:
  if (v52 == 2)
  {
    int v56 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      uint64_t v57 = *(void *)(v47 + 56);
      *(_DWORD *)int buf = 136448259;
      *(void *)&uint8_t buf[4] = "srp_update_start";
      __int16 v180 = 2160;
      *(void *)uint64_t v181 = 1752392040;
      *(_WORD *)&v181[8] = 2081;
      *(void *)&unsigned char v181[10] = __s1;
      *(_WORD *)&v181[18] = 2160;
      *(void *)&v181[20] = 1752392040;
      *(_WORD *)&v181[28] = 2081;
      *(void *)&v181[30] = v190;
      *(_WORD *)&v181[38] = 2160;
      *(void *)&v181[40] = 1752392040;
      *(_WORD *)&v181[48] = 2081;
      *(void *)&v181[50] = v57;
      *(_WORD *)&v181[58] = 2160;
      *(void *)&v181[60] = 1752392040;
      *(_WORD *)&v181[68] = 2081;
      *(void *)&v181[70] = __s2;
      _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_ERROR, "%{public}s: service instance name %{private, mask.hash}s/%{private, mask.hash}s already pointing to host %{private, mask.hash}s, not host %{private, mask.hash}s", buf, 0x5Cu);
    }
    int v18 = *(char **)(v47 + 56);
    uint64_t v19 = v160;
    uint64_t v20 = v161;
    goto LABEL_144;
  }
  int v167 = 1;
LABEL_93:
  uint64_t v166 = v46;
  uint64_t v59 = *v46;
  if (!*v46)
  {
LABEL_124:
    while (v26)
    {
      if (!*((unsigned char *)v26 + 24))
      {
        int v78 = (uint64_t *)v26[1];
        if (v78) {
          dns_name_print_to_limit(v78, 0, (uint64_t)buf, 0x3F2uLL);
        }
        else {
          strcpy(buf, "<null>");
        }
        int v79 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)uint64_t v169 = 136446723;
          uint64_t v170 = "srp_update_start";
          __int16 v171 = 2160;
          uint64_t v172 = 1752392040;
          __int16 v173 = 2081;
          uint64_t v174 = buf;
          _os_log_impl((void *)&_mh_execute_header, v79, OS_LOG_TYPE_DEFAULT, "%{public}s: remove for %{private, mask.hash}s doesn't match any instance on any host.", v169, 0x20u);
        }
      }
      __int16 v26 = (uint64_t *)*v26;
    }
    if (v167)
    {
      int v80 = *(_DWORD *)(v47 + 184);
      uint64_t v0 = v164;
      uint64_t v81 = v161;
      if (v159 == v80 && dns_keys_rdata_equal(*(void *)(v162 + 16), v47 + 120))
      {
        int v82 = v163;
LABEL_136:
        if (*(void *)(v47 + 48))
        {
          uint64_t v83 = global_os_log;
          goto LABEL_138;
        }
        if (v158)
        {
          uint64_t v112 = *(void *)(v47 + 56);
          uint64_t v111 = *(void *)(v47 + 64);
          uint64_t v83 = global_os_log;
          BOOL v113 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
          if (v111 != v112)
          {
            if (!v113) {
              goto LABEL_266;
            }
            *(_DWORD *)int buf = 136447491;
            *(void *)&uint8_t buf[4] = "srp_update_start";
            __int16 v180 = 2160;
            *(void *)uint64_t v181 = 1752392040;
            *(_WORD *)&v181[8] = 2081;
            *(void *)&unsigned char v181[10] = v112;
            *(_WORD *)&v181[18] = 2160;
            *(void *)&v181[20] = 1752392040;
            *(_WORD *)&v181[28] = 2081;
            *(void *)&v181[30] = v111;
            *(_WORD *)&v181[38] = 1024;
            *(_DWORD *)&v181[40] = v159;
            int v114 = "%{public}s: Renewing host %{private, mask.hash}s, alias %{private, mask.hash}s, key id %x";
            int v115 = v83;
            uint32_t v116 = 58;
            goto LABEL_265;
          }
          if (!v113) {
            goto LABEL_266;
          }
          *(_DWORD *)int buf = 136446979;
          *(void *)&uint8_t buf[4] = "srp_update_start";
          __int16 v180 = 2160;
          *(void *)uint64_t v181 = 1752392040;
          *(_WORD *)&v181[8] = 2081;
          *(void *)&unsigned char v181[10] = v111;
          *(_WORD *)&v181[18] = 1024;
          *(_DWORD *)&v181[20] = v159;
          int v114 = "%{public}s: Renewing host %{private, mask.hash}s, key id %x";
LABEL_264:
          int v115 = v83;
          uint32_t v116 = 38;
LABEL_265:
          _os_log_impl((void *)&_mh_execute_header, v115, OS_LOG_TYPE_DEFAULT, v114, buf, v116);
          goto LABEL_266;
        }
        host_invalidate(v47);
        int v129 = *(int **)(v47 + 72);
        if (v129) {
          ioloop_message_release_(v129, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 4197);
        }
        *(void *)(v47 + 72) = v81;
        *(void *)(v47 + 208) = *(void *)(v81 + 72);
        ioloop_message_retain_((int *)v81, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 4202);
LABEL_235:
        int v18 = __s2;
        uint64_t v19 = v160;
        uint64_t v20 = v81;
        unsigned int v21 = 0;
        goto LABEL_145;
      }
      uint64_t v85 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        uint64_t v86 = *(void *)(v47 + 56);
        *(_DWORD *)int buf = 136447747;
        *(void *)&uint8_t buf[4] = "srp_update_start";
        __int16 v180 = 2160;
        *(void *)uint64_t v181 = 1752392040;
        *(_WORD *)&v181[8] = 2081;
        *(void *)&unsigned char v181[10] = __s2;
        *(_WORD *)&v181[18] = 1024;
        *(_DWORD *)&v181[20] = v159;
        *(_WORD *)&v181[24] = 2160;
        *(void *)&v181[26] = 1752392040;
        *(_WORD *)&v181[34] = 2081;
        *(void *)&v181[36] = v86;
        *(_WORD *)&v181[44] = 1024;
        *(_DWORD *)&v181[46] = v80;
        _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_ERROR, "%{public}s: new host with name %{private, mask.hash}s and key id %x conflicts with existing host %{private, mask.hash}s with key id %x", buf, 0x40u);
      }
      int v18 = *(char **)(v47 + 56);
LABEL_143:
      uint64_t v19 = v160;
      uint64_t v20 = v81;
LABEL_144:
      unsigned int v21 = 6;
      goto LABEL_145;
    }
    uint64_t v98 = v166;
    uint64_t v47 = *v166;
    uint64_t v0 = v164;
    uint64_t v81 = v161;
    if (*v166)
    {
      int v82 = v163;
      while (1)
      {
        uint64_t v99 = *(const char **)(v47 + 56);
        int v100 = strcasecmp(__s2, v99);
        if (!v100) {
          break;
        }
        if ((v100 & 0x80000000) == 0)
        {
          uint64_t v98 = (uint64_t *)(v47 + 40);
          uint64_t v47 = *(void *)(v47 + 40);
          if (v47) {
            continue;
          }
        }
        goto LABEL_178;
      }
      if (!*(unsigned char *)(v47 + 264))
      {
        int v125 = *(_DWORD *)(v47 + 184);
        if (v159 == v125 && dns_keys_rdata_equal(*(void *)(v162 + 16), v47 + 120)) {
          goto LABEL_136;
        }
        int v126 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 136447235;
          *(void *)&uint8_t buf[4] = "srp_update_start";
          __int16 v180 = 2160;
          *(void *)uint64_t v181 = 1752392040;
          *(_WORD *)&v181[8] = 2081;
          *(void *)&unsigned char v181[10] = v99;
          *(_WORD *)&v181[18] = 1024;
          *(_DWORD *)&v181[20] = v159;
          *(_WORD *)&v181[24] = 1024;
          *(_DWORD *)&v181[26] = v125;
          _os_log_impl((void *)&_mh_execute_header, v126, OS_LOG_TYPE_ERROR, "%{public}s: update for host %{private, mask.hash}s has key id %x which doesn't match host key id %x.", buf, 0x2Cu);
          uint64_t v99 = *(const char **)(v47 + 56);
        }
        int v18 = (char *)v99;
        goto LABEL_143;
      }
      if (v158)
      {
        if (*(void *)(v47 + 208) > *(void *)(*(void *)(v164 + 32) + 72))
        {
          int v109 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136446723;
            *(void *)&uint8_t buf[4] = "srp_update_start";
            __int16 v180 = 2160;
            *(void *)uint64_t v181 = 1752392040;
            *(_WORD *)&v181[8] = 2081;
            *(void *)&unsigned char v181[10] = v99;
            _os_log_impl((void *)&_mh_execute_header, v109, OS_LOG_TYPE_DEFAULT, "%{public}s: update for host %{private, mask.hash}s which has been deleted.", buf, 0x20u);
            uint64_t v99 = *(const char **)(v47 + 56);
          }
          int v18 = (char *)v99;
          goto LABEL_302;
        }
        *uint64_t v98 = *(void *)(v47 + 40);
        host_invalidate(v47);
        int v139 = *(_DWORD *)v47;
        if (!*(_DWORD *)v47)
        {
          uint64_t v106 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
            goto LABEL_336;
          }
          *(_DWORD *)int buf = 136447490;
          *(void *)&uint8_t buf[4] = "srp_update_start";
          __int16 v180 = 1024;
          *(_DWORD *)uint64_t v181 = 0;
          *(_WORD *)&v181[4] = 2048;
          *(void *)&v181[6] = v47;
          *(_WORD *)&v181[14] = 2080;
          *(void *)&v181[16] = "host";
          *(_WORD *)&v181[24] = 2080;
          *(void *)&v181[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v181[34] = 1024;
          *(_DWORD *)&v181[36] = 4008;
          uint64_t v107 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
          goto LABEL_334;
        }
        uint64_t v140 = global_os_log;
        if (v139 >= 10001)
        {
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
            goto LABEL_336;
          }
          *(_DWORD *)int buf = 136447490;
          *(void *)&uint8_t buf[4] = "srp_update_start";
          __int16 v180 = 1024;
          *(_DWORD *)uint64_t v181 = v139;
          *(_WORD *)&v181[4] = 2048;
          *(void *)&v181[6] = v47;
          *(_WORD *)&v181[14] = 2080;
          *(void *)&v181[16] = "host";
          *(_WORD *)&v181[24] = 2080;
          *(void *)&v181[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v181[34] = 1024;
          *(_DWORD *)&v181[36] = 4008;
          uint64_t v107 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
          __int16 v157 = v140;
          goto LABEL_335;
        }
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447490;
          *(void *)&uint8_t buf[4] = "srp_update_start";
          __int16 v180 = 1024;
          *(_DWORD *)uint64_t v181 = v139;
          *(_WORD *)&v181[4] = 2048;
          *(void *)&v181[6] = v47;
          *(_WORD *)&v181[14] = 2080;
          *(void *)&v181[16] = "host";
          *(_WORD *)&v181[24] = 2080;
          *(void *)&v181[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v181[34] = 1024;
          *(_DWORD *)&v181[36] = 4008;
          _os_log_impl((void *)&_mh_execute_header, v140, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          int v139 = *(_DWORD *)v47;
        }
        *(_DWORD *)uint64_t v47 = v139 - 1;
        if (v139 == 1)
        {
          int v141 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136447234;
            *(void *)&uint8_t buf[4] = "srp_update_start";
            __int16 v180 = 2048;
            *(void *)uint64_t v181 = v47;
            *(_WORD *)&v181[8] = 2080;
            *(void *)&unsigned char v181[10] = "host";
            *(_WORD *)&v181[18] = 2080;
            *(void *)&v181[20] = "srp-mdns-proxy.c";
            *(_WORD *)&v181[28] = 1024;
            *(_DWORD *)&v181[30] = 4008;
            _os_log_impl((void *)&_mh_execute_header, v141, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          }
          ++adv_host_finalized;
          adv_host_finalize(v47);
        }
LABEL_179:
        int v101 = malloc_type_calloc(1uLL, 0x110uLL, 0x10320409BBB0413uLL);
        uint64_t v102 = global_os_log;
        if (!v101)
        {
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)int buf = 136446210;
            *(void *)&uint8_t buf[4] = "srp_update_start";
            _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_ERROR, "%{public}s: no memory for host data structure.", buf, 0xCu);
          }
          int v18 = __s2;
          uint64_t v19 = v160;
          uint64_t v20 = v161;
          goto LABEL_303;
        }
        uint64_t v47 = (uint64_t)v101;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v103 = *(_DWORD *)v47;
          *(_DWORD *)int buf = 136447490;
          *(void *)&uint8_t buf[4] = "srp_update_start";
          __int16 v180 = 1024;
          *(_DWORD *)uint64_t v181 = v103;
          *(_WORD *)&v181[4] = 2048;
          *(void *)&v181[6] = v47;
          *(_WORD *)&v181[14] = 2080;
          *(void *)&v181[16] = "host";
          *(_WORD *)&v181[24] = 2080;
          *(void *)&v181[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v181[34] = 1024;
          *(_DWORD *)&v181[36] = 4066;
          _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        int v104 = *(_DWORD *)v47;
        if (*(_DWORD *)v47)
        {
          int v105 = v104 + 1;
          *(_DWORD *)uint64_t v47 = v104 + 1;
          if (v104 + 1 >= 10001)
          {
            uint64_t v106 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
              goto LABEL_336;
            }
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "srp_update_start";
            __int16 v180 = 1024;
            *(_DWORD *)uint64_t v181 = v105;
            *(_WORD *)&v181[4] = 2048;
            *(void *)&v181[6] = v47;
            *(_WORD *)&v181[14] = 2080;
            *(void *)&v181[16] = "host";
            *(_WORD *)&v181[24] = 2080;
            *(void *)&v181[26] = "srp-mdns-proxy.c";
            *(_WORD *)&v181[34] = 1024;
            *(_DWORD *)&v181[36] = 4066;
            uint64_t v107 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_334:
            __int16 v157 = v106;
            goto LABEL_335;
          }
        }
        else
        {
          ++adv_host_created;
          *(_DWORD *)uint64_t v47 = 1;
        }
        *(void *)(v47 + 8) = v82;
        uint64_t v117 = adv_instance_vec_create(0);
        *(void *)(v47 + 112) = v117;
        if (v117)
        {
          int v118 = adv_record_vec_create(0);
          *(void *)(v47 + 96) = v118;
          if (v118)
          {
            unsigned int v119 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 4087);
            *(void *)(v47 + 24) = v119;
            if (v119)
            {
              uint64_t v120 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 4089);
              *(void *)(v47 + 32) = v120;
            }
            else
            {
              uint64_t v120 = *(int **)(v47 + 32);
            }
            if (v120)
            {
              dns_name_print_to_limit(*(uint64_t **)v162, 0, (uint64_t)v192, 0x3F2uLL);
              int v130 = strdup(v192);
              *(void *)(v47 + 56) = v130;
              if (v130)
              {
                int v131 = *(_OWORD **)(v162 + 16);
                long long v132 = v131[2];
                long long v133 = v131[3];
                long long v134 = v131[1];
                *(_OWORD *)(v47 + 120) = *v131;
                *(_OWORD *)(v47 + 168) = v133;
                *(_OWORD *)(v47 + 152) = v132;
                *(_OWORD *)(v47 + 136) = v134;
                *(void *)(v47 + 120) = 0;
                LOWORD(v131) = *(_WORD *)(*(void *)(v162 + 16) + 20) + 4;
                *(_WORD *)(v47 + 232) = (_WORD)v131;
                uint64_t v135 = malloc_type_malloc((unsigned __int16)v131, 0x101BAE9BuLL);
                *(void *)(v47 + 240) = v135;
                if (v135)
                {
                  *uint64_t v135 = *(_WORD *)(*(void *)(v162 + 16) + 16);
                  *(unsigned char *)(*(void *)(v47 + 240) + 2) = *(unsigned char *)(*(void *)(v162 + 16) + 18);
                  *(unsigned char *)(*(void *)(v47 + 240) + 3) = *(unsigned char *)(*(void *)(v162 + 16) + 19);
                  memcpy((void *)(*(void *)(v47 + 240) + 4), *(const void **)(*(void *)(v162 + 16) + 24), *(unsigned int *)(*(void *)(v162 + 16) + 20));
                  *(void *)(v47 + 144) = *(void *)(v47 + 240) + 4;
                  *(_DWORD *)(v47 + 184) = v159;
                  *(void *)(v47 + 40) = *v98;
                  *uint64_t v98 = v47;
                  uint64_t v83 = global_os_log;
                  if (*(void *)(v47 + 48))
                  {
LABEL_138:
                    if (os_log_type_enabled(v83, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v84 = *(void *)(v47 + 56);
                      *(_DWORD *)int buf = 136446723;
                      *(void *)&uint8_t buf[4] = "srp_update_start";
                      __int16 v180 = 2160;
                      *(void *)uint64_t v181 = 1752392040;
                      *(_WORD *)&v181[8] = 2081;
                      *(void *)&unsigned char v181[10] = v84;
                      _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_DEFAULT, "%{public}s: dropping retransmission of in-progress update for host %{private, mask.hash}s", buf, 0x20u);
                    }
                    goto LABEL_147;
                  }
                  if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                  {
LABEL_266:
                    if (!*(void *)(v47 + 64)) {
                      *(void *)(v47 + 64) = *(void *)(v47 + 56);
                    }
                    int v142 = *(_DWORD *)(v81 + 80);
                    if (v142)
                    {
                      uint64_t v143 = global_os_log;
                      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                      {
                        int v144 = *(_DWORD *)(v81 + 84);
                        *(_DWORD *)int buf = 136446722;
                        *(void *)&uint8_t buf[4] = "srp_update_start";
                        __int16 v180 = 1024;
                        *(_DWORD *)uint64_t v181 = v142;
                        *(_WORD *)&v181[4] = 1024;
                        *(_DWORD *)&v181[6] = v144;
                        _os_log_impl((void *)&_mh_execute_header, v143, OS_LOG_TYPE_DEFAULT, "%{public}s: basing lease time on message: raw_message->lease = %d, raw_message->key_lease = %d", buf, 0x18u);
                        int v142 = *(_DWORD *)(v81 + 80);
                      }
                      *(_DWORD *)(v0 + 88) = v142;
                      *(_DWORD *)(v0 + 92) = *(_DWORD *)(v81 + 84);
LABEL_310:
                      prepare_update((void *)v47, (void *)v0);
                      return 1;
                    }
                    unsigned int v145 = *(_DWORD *)(v0 + 88);
                    unsigned int v146 = v82[63];
                    if (v145 >= v146)
                    {
                      *(_DWORD *)(v0 + 88) = v146;
                      uint64_t v148 = global_os_log;
                      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)int buf = 136446466;
                        *(void *)&uint8_t buf[4] = "srp_update_start";
                        __int16 v180 = 1024;
                        *(_DWORD *)uint64_t v181 = v146;
                        unint64_t v153 = "%{public}s: basing lease time on server_state->max_lease_time: %d";
LABEL_306:
                        _os_log_impl((void *)&_mh_execute_header, v148, OS_LOG_TYPE_DEFAULT, v153, buf, 0x12u);
                      }
                    }
                    else
                    {
                      unsigned int v147 = v82[64];
                      uint64_t v148 = global_os_log;
                      BOOL v149 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
                      if (v145 < v147)
                      {
                        if (v149)
                        {
                          *(_DWORD *)int buf = 136446466;
                          *(void *)&uint8_t buf[4] = "srp_update_start";
                          __int16 v180 = 1024;
                          *(_DWORD *)uint64_t v181 = v147;
                          _os_log_impl((void *)&_mh_execute_header, v148, OS_LOG_TYPE_DEFAULT, "%{public}s: basing lease time on server_state->min_lease_time: %d", buf, 0x12u);
                          unsigned int v147 = v82[64];
                        }
                        *(_DWORD *)(v0 + 88) = v147;
                        goto LABEL_307;
                      }
                      if (v149)
                      {
                        *(_DWORD *)int buf = 136446466;
                        *(void *)&uint8_t buf[4] = "srp_update_start";
                        __int16 v180 = 1024;
                        *(_DWORD *)uint64_t v181 = v145;
                        unint64_t v153 = "%{public}s: basing lease time on client_update->host_lease: %d";
                        goto LABEL_306;
                      }
                    }
LABEL_307:
                    unsigned int v155 = *(_DWORD *)(v0 + 92);
                    unsigned int v156 = v82[65];
                    if (v155 >= v156 || (unsigned int v156 = v82[66], v155 < v156)) {
                      *(_DWORD *)(v0 + 92) = v156;
                    }
                    goto LABEL_310;
                  }
                  uint64_t v136 = *(void *)(v47 + 56);
                  *(_DWORD *)int buf = 136446979;
                  *(void *)&uint8_t buf[4] = "srp_update_start";
                  __int16 v180 = 2160;
                  *(void *)uint64_t v181 = 1752392040;
                  *(_WORD *)&v181[8] = 2081;
                  *(void *)&unsigned char v181[10] = v136;
                  *(_WORD *)&v181[18] = 1024;
                  *(_DWORD *)&v181[20] = v159;
                  int v114 = "%{public}s: New host %{private, mask.hash}s, key id %x";
                  goto LABEL_264;
                }
                int v154 = *(_DWORD *)v47;
                if (!*(_DWORD *)v47)
                {
                  uint64_t v106 = global_os_log;
                  if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                    goto LABEL_336;
                  }
                  *(_DWORD *)int buf = 136447490;
                  *(void *)&uint8_t buf[4] = "srp_update_start";
                  __int16 v180 = 1024;
                  *(_DWORD *)uint64_t v181 = 0;
                  *(_WORD *)&v181[4] = 2048;
                  *(void *)&v181[6] = v47;
                  *(_WORD *)&v181[14] = 2080;
                  *(void *)&v181[16] = "host";
                  *(_WORD *)&v181[24] = 2080;
                  *(void *)&v181[26] = "srp-mdns-proxy.c";
                  *(_WORD *)&v181[34] = 1024;
                  *(_DWORD *)&v181[36] = 4117;
                  uint64_t v107 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
                  goto LABEL_334;
                }
                uint64_t v151 = global_os_log;
                if (v154 < 10001)
                {
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)int buf = 136447490;
                    *(void *)&uint8_t buf[4] = "srp_update_start";
                    __int16 v180 = 1024;
                    *(_DWORD *)uint64_t v181 = v154;
                    *(_WORD *)&v181[4] = 2048;
                    *(void *)&v181[6] = v47;
                    *(_WORD *)&v181[14] = 2080;
                    *(void *)&v181[16] = "host";
                    *(_WORD *)&v181[24] = 2080;
                    *(void *)&v181[26] = "srp-mdns-proxy.c";
                    *(_WORD *)&v181[34] = 1024;
                    *(_DWORD *)&v181[36] = 4117;
                    _os_log_impl((void *)&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                    int v154 = *(_DWORD *)v47;
                    uint64_t v151 = global_os_log;
                  }
                  *(_DWORD *)uint64_t v47 = v154 - 1;
                  if (v154 == 1)
                  {
                    if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)int buf = 136447234;
                      *(void *)&uint8_t buf[4] = "srp_update_start";
                      __int16 v180 = 2048;
                      *(void *)uint64_t v181 = v47;
                      *(_WORD *)&v181[8] = 2080;
                      *(void *)&unsigned char v181[10] = "host";
                      *(_WORD *)&v181[18] = 2080;
                      *(void *)&v181[20] = "srp-mdns-proxy.c";
                      *(_WORD *)&v181[28] = 1024;
                      *(_DWORD *)&v181[30] = 4117;
                      _os_log_impl((void *)&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
                    }
                    ++adv_host_finalized;
                    adv_host_finalize(v47);
                    uint64_t v151 = global_os_log;
                  }
                  if (!os_log_type_enabled(v151, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_301;
                  }
                  *(_DWORD *)int buf = 136446210;
                  *(void *)&uint8_t buf[4] = "srp_update_start";
                  uint64_t v152 = "%{public}s: no memory for host key.";
LABEL_300:
                  _os_log_impl((void *)&_mh_execute_header, v151, OS_LOG_TYPE_ERROR, v152, buf, 0xCu);
LABEL_301:
                  int v18 = __s2;
LABEL_302:
                  uint64_t v19 = v160;
                  uint64_t v20 = v161;
LABEL_303:
                  unsigned int v21 = 2;
                  goto LABEL_145;
                }
                if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_336:
                }
                  abort();
                *(_DWORD *)int buf = 136447490;
                *(void *)&uint8_t buf[4] = "srp_update_start";
                __int16 v180 = 1024;
                *(_DWORD *)uint64_t v181 = v154;
                *(_WORD *)&v181[4] = 2048;
                *(void *)&v181[6] = v47;
                *(_WORD *)&v181[14] = 2080;
                *(void *)&v181[16] = "host";
                *(_WORD *)&v181[24] = 2080;
                *(void *)&v181[26] = "srp-mdns-proxy.c";
                *(_WORD *)&v181[34] = 1024;
                *(_DWORD *)&v181[36] = 4117;
                uint64_t v107 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
              }
              else
              {
                int v150 = *(_DWORD *)v47;
                if (!*(_DWORD *)v47)
                {
                  uint64_t v106 = global_os_log;
                  if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                    goto LABEL_336;
                  }
                  *(_DWORD *)int buf = 136447490;
                  *(void *)&uint8_t buf[4] = "srp_update_start";
                  __int16 v180 = 1024;
                  *(_DWORD *)uint64_t v181 = 0;
                  *(_WORD *)&v181[4] = 2048;
                  *(void *)&v181[6] = v47;
                  *(_WORD *)&v181[14] = 2080;
                  *(void *)&v181[16] = "host";
                  *(_WORD *)&v181[24] = 2080;
                  *(void *)&v181[26] = "srp-mdns-proxy.c";
                  *(_WORD *)&v181[34] = 1024;
                  *(_DWORD *)&v181[36] = 4102;
                  uint64_t v107 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
                  goto LABEL_334;
                }
                uint64_t v151 = global_os_log;
                if (v150 < 10001)
                {
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)int buf = 136447490;
                    *(void *)&uint8_t buf[4] = "srp_update_start";
                    __int16 v180 = 1024;
                    *(_DWORD *)uint64_t v181 = v150;
                    *(_WORD *)&v181[4] = 2048;
                    *(void *)&v181[6] = v47;
                    *(_WORD *)&v181[14] = 2080;
                    *(void *)&v181[16] = "host";
                    *(_WORD *)&v181[24] = 2080;
                    *(void *)&v181[26] = "srp-mdns-proxy.c";
                    *(_WORD *)&v181[34] = 1024;
                    *(_DWORD *)&v181[36] = 4102;
                    _os_log_impl((void *)&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                    int v150 = *(_DWORD *)v47;
                    uint64_t v151 = global_os_log;
                  }
                  *(_DWORD *)uint64_t v47 = v150 - 1;
                  if (v150 == 1)
                  {
                    if (os_log_type_enabled(v151, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)int buf = 136447234;
                      *(void *)&uint8_t buf[4] = "srp_update_start";
                      __int16 v180 = 2048;
                      *(void *)uint64_t v181 = v47;
                      *(_WORD *)&v181[8] = 2080;
                      *(void *)&unsigned char v181[10] = "host";
                      *(_WORD *)&v181[18] = 2080;
                      *(void *)&v181[20] = "srp-mdns-proxy.c";
                      *(_WORD *)&v181[28] = 1024;
                      *(_DWORD *)&v181[30] = 4102;
                      _os_log_impl((void *)&_mh_execute_header, v151, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
                    }
                    ++adv_host_finalized;
                    adv_host_finalize(v47);
                    uint64_t v151 = global_os_log;
                  }
                  if (!os_log_type_enabled(v151, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_301;
                  }
                  *(_DWORD *)int buf = 136446210;
                  *(void *)&uint8_t buf[4] = "srp_update_start";
                  uint64_t v152 = "%{public}s: no memory for hostname.";
                  goto LABEL_300;
                }
                if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                  goto LABEL_336;
                }
                *(_DWORD *)int buf = 136447490;
                *(void *)&uint8_t buf[4] = "srp_update_start";
                __int16 v180 = 1024;
                *(_DWORD *)uint64_t v181 = v150;
                *(_WORD *)&v181[4] = 2048;
                *(void *)&v181[6] = v47;
                *(_WORD *)&v181[14] = 2080;
                *(void *)&v181[16] = "host";
                *(_WORD *)&v181[24] = 2080;
                *(void *)&v181[26] = "srp-mdns-proxy.c";
                *(_WORD *)&v181[34] = 1024;
                *(_DWORD *)&v181[36] = 4102;
                uint64_t v107 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
              }
              __int16 v157 = v151;
              goto LABEL_335;
            }
            uint64_t v137 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "srp_update_start";
              _os_log_impl((void *)&_mh_execute_header, v137, OS_LOG_TYPE_ERROR, "%{public}s: no memory for wake event on host", buf, 0xCu);
            }
            advertise_finished((uint64_t)__s2, v160, v161, 2u, 0, 1);
            int v138 = *(_DWORD *)v47;
            if (!*(_DWORD *)v47)
            {
              uint64_t v106 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                goto LABEL_336;
              }
              *(_DWORD *)int buf = 136447490;
              *(void *)&uint8_t buf[4] = "srp_update_start";
              __int16 v180 = 1024;
              *(_DWORD *)uint64_t v181 = 0;
              *(_WORD *)&v181[4] = 2048;
              *(void *)&v181[6] = v47;
              *(_WORD *)&v181[14] = 2080;
              *(void *)&v181[16] = "host";
              *(_WORD *)&v181[24] = 2080;
              *(void *)&v181[26] = "srp-mdns-proxy.c";
              *(_WORD *)&v181[34] = 1024;
              *(_DWORD *)&v181[36] = 4095;
              uint64_t v107 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
              goto LABEL_334;
            }
            int v123 = global_os_log;
            if (v138 < 10001)
            {
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)int buf = 136447490;
                *(void *)&uint8_t buf[4] = "srp_update_start";
                __int16 v180 = 1024;
                *(_DWORD *)uint64_t v181 = v138;
                *(_WORD *)&v181[4] = 2048;
                *(void *)&v181[6] = v47;
                *(_WORD *)&v181[14] = 2080;
                *(void *)&v181[16] = "host";
                *(_WORD *)&v181[24] = 2080;
                *(void *)&v181[26] = "srp-mdns-proxy.c";
                *(_WORD *)&v181[34] = 1024;
                *(_DWORD *)&v181[36] = 4095;
                _os_log_impl((void *)&_mh_execute_header, v123, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                int v138 = *(_DWORD *)v47;
              }
              *(_DWORD *)uint64_t v47 = v138 - 1;
              if (v138 != 1) {
                goto LABEL_147;
              }
              uint64_t v124 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)int buf = 136447234;
                *(void *)&uint8_t buf[4] = "srp_update_start";
                __int16 v180 = 2048;
                *(void *)uint64_t v181 = v47;
                *(_WORD *)&v181[8] = 2080;
                *(void *)&unsigned char v181[10] = "host";
                *(_WORD *)&v181[18] = 2080;
                *(void *)&v181[20] = "srp-mdns-proxy.c";
                *(_WORD *)&v181[28] = 1024;
                *(_DWORD *)&v181[30] = 4095;
                goto LABEL_252;
              }
LABEL_253:
              ++adv_host_finalized;
              adv_host_finalize(v47);
              goto LABEL_147;
            }
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
              goto LABEL_336;
            }
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "srp_update_start";
            __int16 v180 = 1024;
            *(_DWORD *)uint64_t v181 = v138;
            *(_WORD *)&v181[4] = 2048;
            *(void *)&v181[6] = v47;
            *(_WORD *)&v181[14] = 2080;
            *(void *)&v181[16] = "host";
            *(_WORD *)&v181[24] = 2080;
            *(void *)&v181[26] = "srp-mdns-proxy.c";
            *(_WORD *)&v181[34] = 1024;
            *(_DWORD *)&v181[36] = 4095;
            uint64_t v107 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_323:
            __int16 v157 = v123;
LABEL_335:
            _os_log_impl((void *)&_mh_execute_header, v157, OS_LOG_TYPE_FAULT, v107, buf, 0x36u);
            goto LABEL_336;
          }
          uint64_t v127 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)int buf = 136446210;
            *(void *)&uint8_t buf[4] = "srp_update_start";
            _os_log_impl((void *)&_mh_execute_header, v127, OS_LOG_TYPE_ERROR, "%{public}s: no memory for host address vector.", buf, 0xCu);
          }
          advertise_finished((uint64_t)__s2, v160, v161, 2u, 0, 1);
          int v128 = *(_DWORD *)v47;
          if (!*(_DWORD *)v47)
          {
            uint64_t v106 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
              goto LABEL_336;
            }
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "srp_update_start";
            __int16 v180 = 1024;
            *(_DWORD *)uint64_t v181 = 0;
            *(_WORD *)&v181[4] = 2048;
            *(void *)&v181[6] = v47;
            *(_WORD *)&v181[14] = 2080;
            *(void *)&v181[16] = "host";
            *(_WORD *)&v181[24] = 2080;
            *(void *)&v181[26] = "srp-mdns-proxy.c";
            *(_WORD *)&v181[34] = 1024;
            *(_DWORD *)&v181[36] = 4082;
            uint64_t v107 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
            goto LABEL_334;
          }
          int v123 = global_os_log;
          if (v128 >= 10001)
          {
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
              goto LABEL_336;
            }
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "srp_update_start";
            __int16 v180 = 1024;
            *(_DWORD *)uint64_t v181 = v128;
            *(_WORD *)&v181[4] = 2048;
            *(void *)&v181[6] = v47;
            *(_WORD *)&v181[14] = 2080;
            *(void *)&v181[16] = "host";
            *(_WORD *)&v181[24] = 2080;
            *(void *)&v181[26] = "srp-mdns-proxy.c";
            *(_WORD *)&v181[34] = 1024;
            *(_DWORD *)&v181[36] = 4082;
            uint64_t v107 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
            goto LABEL_323;
          }
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "srp_update_start";
            __int16 v180 = 1024;
            *(_DWORD *)uint64_t v181 = v128;
            *(_WORD *)&v181[4] = 2048;
            *(void *)&v181[6] = v47;
            *(_WORD *)&v181[14] = 2080;
            *(void *)&v181[16] = "host";
            *(_WORD *)&v181[24] = 2080;
            *(void *)&v181[26] = "srp-mdns-proxy.c";
            *(_WORD *)&v181[34] = 1024;
            *(_DWORD *)&v181[36] = 4082;
            _os_log_impl((void *)&_mh_execute_header, v123, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            int v128 = *(_DWORD *)v47;
          }
          *(_DWORD *)uint64_t v47 = v128 - 1;
          if (v128 != 1) {
            goto LABEL_147;
          }
          uint64_t v124 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_253;
          }
          *(_DWORD *)int buf = 136447234;
          *(void *)&uint8_t buf[4] = "srp_update_start";
          __int16 v180 = 2048;
          *(void *)uint64_t v181 = v47;
          *(_WORD *)&v181[8] = 2080;
          *(void *)&unsigned char v181[10] = "host";
          *(_WORD *)&v181[18] = 2080;
          *(void *)&v181[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v181[28] = 1024;
          *(_DWORD *)&v181[30] = 4082;
        }
        else
        {
          int v121 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)int buf = 136446210;
            *(void *)&uint8_t buf[4] = "srp_update_start";
            _os_log_impl((void *)&_mh_execute_header, v121, OS_LOG_TYPE_ERROR, "%{public}s: no memory for host instance vector.", buf, 0xCu);
          }
          advertise_finished((uint64_t)__s2, v160, v161, 2u, 0, 1);
          int v122 = *(_DWORD *)v47;
          if (!*(_DWORD *)v47)
          {
            uint64_t v106 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
              goto LABEL_336;
            }
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "srp_update_start";
            __int16 v180 = 1024;
            *(_DWORD *)uint64_t v181 = 0;
            *(_WORD *)&v181[4] = 2048;
            *(void *)&v181[6] = v47;
            *(_WORD *)&v181[14] = 2080;
            *(void *)&v181[16] = "host";
            *(_WORD *)&v181[24] = 2080;
            *(void *)&v181[26] = "srp-mdns-proxy.c";
            *(_WORD *)&v181[34] = 1024;
            *(_DWORD *)&v181[36] = 4073;
            uint64_t v107 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
            goto LABEL_334;
          }
          int v123 = global_os_log;
          if (v122 >= 10001)
          {
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
              goto LABEL_336;
            }
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "srp_update_start";
            __int16 v180 = 1024;
            *(_DWORD *)uint64_t v181 = v122;
            *(_WORD *)&v181[4] = 2048;
            *(void *)&v181[6] = v47;
            *(_WORD *)&v181[14] = 2080;
            *(void *)&v181[16] = "host";
            *(_WORD *)&v181[24] = 2080;
            *(void *)&v181[26] = "srp-mdns-proxy.c";
            *(_WORD *)&v181[34] = 1024;
            *(_DWORD *)&v181[36] = 4073;
            uint64_t v107 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
            goto LABEL_323;
          }
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "srp_update_start";
            __int16 v180 = 1024;
            *(_DWORD *)uint64_t v181 = v122;
            *(_WORD *)&v181[4] = 2048;
            *(void *)&v181[6] = v47;
            *(_WORD *)&v181[14] = 2080;
            *(void *)&v181[16] = "host";
            *(_WORD *)&v181[24] = 2080;
            *(void *)&v181[26] = "srp-mdns-proxy.c";
            *(_WORD *)&v181[34] = 1024;
            *(_DWORD *)&v181[36] = 4073;
            _os_log_impl((void *)&_mh_execute_header, v123, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            int v122 = *(_DWORD *)v47;
          }
          *(_DWORD *)uint64_t v47 = v122 - 1;
          if (v122 != 1) {
            goto LABEL_147;
          }
          uint64_t v124 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_253;
          }
          *(_DWORD *)int buf = 136447234;
          *(void *)&uint8_t buf[4] = "srp_update_start";
          __int16 v180 = 2048;
          *(void *)uint64_t v181 = v47;
          *(_WORD *)&v181[8] = 2080;
          *(void *)&unsigned char v181[10] = "host";
          *(_WORD *)&v181[18] = 2080;
          *(void *)&v181[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v181[28] = 1024;
          *(_DWORD *)&v181[30] = 4073;
        }
LABEL_252:
        _os_log_impl((void *)&_mh_execute_header, v124, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        goto LABEL_253;
      }
    }
    else
    {
      int v82 = v163;
LABEL_178:
      if (v158) {
        goto LABEL_179;
      }
    }
    uint64_t v110 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446723;
      *(void *)&uint8_t buf[4] = "srp_update_start";
      __int16 v180 = 2160;
      *(void *)uint64_t v181 = 1752392040;
      *(_WORD *)&v181[8] = 2081;
      *(void *)&unsigned char v181[10] = __s2;
      _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_ERROR, "%{public}s: Remove for host %{private, mask.hash}s which doesn't exist.", buf, 0x20u);
    }
    goto LABEL_235;
  }
  while (*(unsigned char *)(v59 + 264) || v26 == 0)
  {
LABEL_123:
    uint64_t v59 = *(void *)(v59 + 40);
    if (!v59) {
      goto LABEL_124;
    }
  }
  uint64_t v61 = v26;
  while (1)
  {
    long long v62 = (uint64_t *)v61[1];
    if (v62)
    {
      int v63 = (uint64_t *)*v62;
      if (*v62)
      {
        if (*v63)
        {
          dns_name_print_to_limit(v62, v63, (uint64_t)__s1, 0xFDuLL);
          dns_name_print_to_limit(*(uint64_t **)v61[1], ***(uint64_t ****)v61[1], (uint64_t)v190, 0x1FAuLL);
          uint64_t v64 = *(void *)(v59 + 112);
          if (*(int *)(v64 + 4) >= 1)
          {
            for (uint64_t j = 0; j < *(int *)(v64 + 4); ++j)
            {
              uint64_t v66 = *(void *)(*(void *)(v64 + 8) + 8 * j);
              if (v66 && !strcmp(__s1, *(const char **)(v66 + 48)) && service_types_equal(v190, *(char **)(v66 + 56)))
              {
                int v67 = *(const char **)(v59 + 56);
                int v68 = strcmp(__s2, v67);
                uint64_t v69 = global_os_log;
                BOOL v70 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
                if (v68)
                {
                  if (v70)
                  {
                    *(_DWORD *)int buf = 136447747;
                    *(void *)&uint8_t buf[4] = "srp_update_start";
                    __int16 v180 = 2160;
                    *(void *)uint64_t v181 = 1752392040;
                    *(_WORD *)&v181[8] = 2081;
                    *(void *)&unsigned char v181[10] = __s1;
                    *(_WORD *)&v181[18] = 2160;
                    *(void *)&v181[20] = 1752392040;
                    *(_WORD *)&v181[28] = 2081;
                    *(void *)&v181[30] = v190;
                    *(_WORD *)&v181[38] = 2160;
                    *(void *)&v181[40] = 1752392040;
                    *(_WORD *)&v181[48] = 2081;
                    *(void *)&v181[50] = v67;
                    _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_ERROR, "%{public}s: remove for %{private, mask.hash}s.%{private, mask.hash}s conflicts with instance on host %{private, mask.hash}s", buf, 0x48u);
                    int v67 = *(const char **)(v59 + 56);
                  }
                  uint64_t v0 = v164;
                  uint64_t v19 = v160;
                  uint64_t v20 = v161;
                  int v18 = (char *)v67;
                  unsigned int v21 = 1;
LABEL_145:
                  char v22 = 1;
LABEL_146:
                  advertise_finished((uint64_t)v18, v19, v20, v21, 0, v22);
                  goto LABEL_147;
                }
                if (v70)
                {
                  *(_DWORD *)int buf = 136447747;
                  *(void *)&uint8_t buf[4] = "srp_update_start";
                  __int16 v180 = 2160;
                  *(void *)uint64_t v181 = 1752392040;
                  *(_WORD *)&v181[8] = 2081;
                  *(void *)&unsigned char v181[10] = __s1;
                  *(_WORD *)&v181[18] = 2160;
                  *(void *)&v181[20] = 1752392040;
                  *(_WORD *)&v181[28] = 2081;
                  *(void *)&v181[30] = v190;
                  *(_WORD *)&v181[38] = 2160;
                  *(void *)&v181[40] = 1752392040;
                  *(_WORD *)&v181[48] = 2081;
                  *(void *)&v181[50] = v67;
                  _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_ERROR, "%{public}s: remove for %{private, mask.hash}s.%{private, mask.hash}s matches instance on host %{private, mask.hash}s", buf, 0x48u);
                  uint64_t v64 = *(void *)(v59 + 112);
                }
                *((unsigned char *)v61 + 24) = 1;
              }
            }
          }
          uint64_t v71 = *(void *)(v59 + 48);
          if (v71)
          {
            uint64_t v72 = *(void *)(v71 + 80);
            if (v72)
            {
              uint64_t v73 = *(unsigned int *)(v72 + 4);
              if ((int)v73 >= 1) {
                break;
              }
            }
          }
        }
      }
    }
LABEL_122:
    uint64_t v61 = (uint64_t *)*v61;
    if (!v61) {
      goto LABEL_123;
    }
  }
  uint64_t v74 = *(uint64_t **)(v72 + 8);
  while (1)
  {
    uint64_t v75 = *v74;
    if (!*v74) {
      goto LABEL_121;
    }
    int v76 = *(const char **)(v75 + 48);
    if (strcmp(__s1, v76) || !service_types_equal(v190, *(char **)(v75 + 56))) {
      goto LABEL_121;
    }
    int v77 = *(const char **)(v59 + 56);
    if (strcmp(__s2, v77)) {
      break;
    }
    *((unsigned char *)v61 + 24) = 1;
LABEL_121:
    ++v74;
    if (!--v73) {
      goto LABEL_122;
    }
  }
  uint64_t v108 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)int buf = 136447235;
    *(void *)&uint8_t buf[4] = "srp_update_start";
    __int16 v180 = 2160;
    *(void *)uint64_t v181 = 1752392040;
    *(_WORD *)&v181[8] = 2081;
    *(void *)&unsigned char v181[10] = v76;
    *(_WORD *)&v181[18] = 2160;
    *(void *)&v181[20] = 1752392040;
    *(_WORD *)&v181[28] = 2081;
    *(void *)&v181[30] = v77;
    _os_log_impl((void *)&_mh_execute_header, v108, OS_LOG_TYPE_ERROR, "%{public}s: remove for %{private, mask.hash}s conflicts with instance on update to host %{private, mask.hash}s", buf, 0x34u);
    int v77 = *(const char **)(v59 + 56);
  }
  advertise_finished((uint64_t)v77, v160, v161, 1u, 0, 1);
  uint64_t v0 = v164;
LABEL_147:
  srp_parse_client_updates_free_((void *)v0, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 4175);
  return 0;
}

void srp_dump_server_stats(uint64_t a1, int a2, int a3)
{
  *(void *)uint64_t v75 = 0;
  *(void *)&v75[8] = 0;
  gettimeofday((timeval *)v75, 0);
  uint64_t v56 = a1;
  uint64_t v5 = *(void *)(a1 + 8);
  uint64_t v6 = (NSObject **)&dnssd_client_states;
  if (v5)
  {
    int v52 = 0;
    int v50 = 0;
    int v7 = 0;
    int v8 = 0;
    int v9 = 0;
    int v55 = 0;
    uint64_t v53 = 1000 * *(void *)v75 + *(_DWORD *)&v75[8] / 1000;
    while (1)
    {
      if (*(unsigned char *)(v5 + 264)) {
        goto LABEL_66;
      }
      uint64_t v10 = *(void *)(v5 + 256);
      BOOL v11 = v10 < v53;
      int v12 = v10 - v53;
      if (v11)
      {
        int v13 = -1;
        if (a2) {
          goto LABEL_9;
        }
      }
      else
      {
        int v13 = v12 / 1000;
        if (a2)
        {
LABEL_9:
          uint64_t v14 = v6[306];
          if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v15 = *(void *)(v5 + 56);
            int v16 = *(_DWORD *)(v5 + 184);
            uint64_t v17 = *(void *)(v5 + 224);
            int v18 = *(_DWORD *)(v5 + 248);
            int v19 = *(_DWORD *)(v5 + 252);
            uint64_t v20 = " update-pending";
            if (!*(unsigned char *)(v5 + 265)) {
              uint64_t v20 = "";
            }
            *(_DWORD *)uint64_t v75 = 136448515;
            *(void *)&v75[4] = "srp_dump_server_stats";
            *(_WORD *)&v75[12] = 2160;
            *(void *)&v75[14] = 1752392040;
            *(_WORD *)&v75[22] = 2081;
            *(void *)&long long v76 = v15;
            WORD4(v76) = 1024;
            *(_DWORD *)((char *)&v76 + 10) = v16;
            HIWORD(v76) = 2048;
            uint64_t v77 = v17;
            *(_WORD *)int v78 = 1024;
            *(_DWORD *)&v78[2] = v18;
            *(_WORD *)&v78[6] = 1024;
            *(_DWORD *)&v78[8] = v19;
            LOWORD(v79) = 1024;
            *(_DWORD *)((char *)&v79 + 2) = v13;
            HIWORD(v79) = 2082;
            int v80 = "";
            __int16 v81 = 2082;
            int v82 = v20;
            _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: host %{private, mask.hash}s key_id %xu stable %llx lease %d key_lease %d expiry %d%{public}s%{public}s", v75, 0x56u);
          }
        }
      }
      uint64_t v21 = *(void *)(v5 + 96);
      if (v21 && *(int *)(v21 + 4) >= 1)
      {
        uint64_t v22 = 0;
        do
        {
          uint64_t v23 = *(void *)(*(void *)(v21 + 8) + 8 * v22);
          if (v23)
          {
            int v24 = *(unsigned __int16 *)(v23 + 48);
            if (v24 == 28)
            {
              if (a2)
              {
                __int16 v28 = v6[306];
                if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
                {
                  int v29 = *(unsigned __int8 **)(v23 + 40);
                  int v30 = *v29;
                  BOOL v31 = "ULA: ";
                  if ((v30 & 0xFE) != 0xFC)
                  {
                    if (v30 != 254 || (BOOL v31 = "LUA: ", (v29[1] & 0xC0) != 0x80))
                    {
                      BOOL v31 = "GUA: ";
                      if ((v30 & 0xE0) != 0x20) {
                        BOOL v31 = "";
                      }
                    }
                  }
                  *(double *)&uint32_t v32 = COERCE_DOUBLE("");
                  if (*(void *)(v23 + 24) == *(void *)(v56 + 16)) {
                    *(double *)&uint32_t v32 = COERCE_DOUBLE(" live");
                  }
                  *(_DWORD *)uint64_t v75 = 136447747;
                  *(void *)&v75[4] = "srp_dump_server_stats";
                  *(_WORD *)&v75[12] = 2082;
                  *(void *)&v75[14] = v31;
                  *(_WORD *)&v75[22] = 2160;
                  *(void *)&long long v76 = 1752392040;
                  WORD4(v76) = 1041;
                  *(_DWORD *)((char *)&v76 + 10) = 16;
                  HIWORD(v76) = 2097;
                  uint64_t v77 = (uint64_t)v29;
                  strcpy(v78, "p\bhash");
                  v78[7] = 0;
                  *(_DWORD *)&v78[8] = 136380416;
                  double v79 = *(double *)&v32;
                  _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_DEFAULT, "%{public}s:   IN AAAA %{public}s%{private, mask.hash, network:in6_addr}.16P%{private, mask.hash}s", v75, 0x44u);
                }
              }
              ++v8;
            }
            else if (v24 == 1)
            {
              if (a2)
              {
                uint32_t v25 = v6[306];
                if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v26 = *(void *)(v23 + 40);
                  int v27 = "";
                  if (*(void *)(v23 + 24) == *(void *)(v56 + 16)) {
                    int v27 = " live";
                  }
                  *(_DWORD *)uint64_t v75 = 136447491;
                  *(void *)&v75[4] = "srp_dump_server_stats";
                  *(_WORD *)&v75[12] = 2160;
                  *(void *)&v75[14] = 1752392040;
                  *(_WORD *)&v75[22] = 1041;
                  LODWORD(v76) = 4;
                  WORD2(v76) = 2097;
                  *(void *)((char *)&v76 + 6) = v26;
                  HIWORD(v76) = 2160;
                  uint64_t v77 = 1752392040;
                  *(_WORD *)int v78 = 2081;
                  *(void *)&v78[2] = v27;
                  _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%{public}s:   IN    A %{private, mask.hash, network:in_addr}.4P%{private, mask.hash}s", v75, 0x3Au);
                }
              }
              ++v9;
            }
          }
          ++v22;
          uint64_t v21 = *(void *)(v5 + 96);
        }
        while (v22 < *(int *)(v21 + 4));
      }
      ++v55;
      uint64_t v33 = *(void *)(v5 + 112);
      if (!v33) {
        goto LABEL_66;
      }
      if (*(int *)(v33 + 4) < 1)
      {
        char v36 = 0;
      }
      else
      {
        int v51 = v8;
        int v34 = v6;
        uint64_t v35 = 0;
        char v36 = 0;
        char v54 = 0;
        do
        {
          uint64_t v37 = *(void *)(*(void *)(v33 + 8) + 8 * v35);
          if (v37)
          {
            if (a2)
            {
              uint64_t v38 = *(void *)(v37 + 72);
              if (v38) {
                dns_txt_data_print((unint64_t)v75, *(unsigned __int16 *)(v37 + 80), v38);
              }
              else {
                v75[0] = 0;
              }
              uint64_t v39 = "removed";
              if (!*(unsigned char *)(v37 + 116))
              {
                if (*(void *)(v37 + 8))
                {
                  if (*(void *)(v37 + 16) == *(void *)(v56 + 16)) {
                    uint64_t v39 = "live";
                  }
                  else {
                    uint64_t v39 = "stale";
                  }
                }
                else
                {
                  uint64_t v39 = "unregistered";
                }
              }
              uint64_t v40 = v34[306];
              if (os_log_type_enabled(v40, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v41 = *(void *)(v37 + 48);
                uint64_t v42 = *(void *)(v37 + 56);
                int v43 = *(_DWORD *)(v37 + 64);
                *(_DWORD *)int buf = 136448259;
                int v58 = "srp_dump_server_stats";
                __int16 v59 = 2082;
                uint64_t v60 = v39;
                __int16 v61 = 2160;
                uint64_t v62 = 1752392040;
                __int16 v63 = 2081;
                uint64_t v64 = v41;
                __int16 v65 = 2160;
                uint64_t v66 = 1752392040;
                __int16 v67 = 2081;
                uint64_t v68 = v42;
                __int16 v69 = 1024;
                int v70 = v43;
                __int16 v71 = 2160;
                uint64_t v72 = 1752392040;
                __int16 v73 = 2081;
                uint64_t v74 = v75;
                _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "%{public}s:   %{public}s instance %{private, mask.hash}s %{private, mask.hash}s %d (%{private, mask.hash}s)", buf, 0x58u);
              }
            }
            if (!*(unsigned char *)(v37 + 116))
            {
              ++v7;
              uint64_t v44 = *(const char **)(v37 + 56);
              if (v44)
              {
                if (!strncmp(*(const char **)(v37 + 56), "_matter", 7uLL))
                {
                  char v54 = 1;
                }
                else if (!strncmp(v44, "_hap._udp", 9uLL))
                {
                  char v36 = 1;
                }
              }
            }
          }
          ++v35;
          uint64_t v33 = *(void *)(v5 + 112);
        }
        while (v35 < *(int *)(v33 + 4));
        if (v54)
        {
          ++v50;
          uint64_t v6 = v34;
          int v8 = v51;
          goto LABEL_66;
        }
        uint64_t v6 = v34;
        int v8 = v51;
      }
      v52 += v36 & 1;
LABEL_66:
      uint64_t v5 = *(void *)(v5 + 40);
      if (!v5) {
        goto LABEL_69;
      }
    }
  }
  int v55 = 0;
  int v9 = 0;
  int v8 = 0;
  int v7 = 0;
  int v50 = 0;
  int v52 = 0;
LABEL_69:
  uint64_t v45 = v6[306];
  if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
  {
    if (a3) {
      BOOL v46 = "";
    }
    else {
      BOOL v46 = "after update, ";
    }
    *(void *)uint64_t v75 = 0;
    *(void *)&v75[8] = 0;
    clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)v75);
    double v47 = (double)*(uint64_t *)v75;
    double v48 = (double)*(uint64_t *)&v75[8];
    *(_DWORD *)uint64_t v75 = 136448258;
    *(void *)&v75[4] = "srp_dump_server_stats";
    *(_WORD *)&v75[12] = 2082;
    *(void *)&v75[14] = v46;
    *(_WORD *)&v75[22] = 1024;
    LODWORD(v76) = v55;
    WORD2(v76) = 1024;
    *(_DWORD *)((char *)&v76 + 6) = v50;
    WORD5(v76) = 1024;
    HIDWORD(v76) = v52;
    LOWORD(v77) = 1024;
    *(_DWORD *)((char *)&v77 + 2) = v7;
    HIWORD(v77) = 1024;
    *(_DWORD *)int v78 = v9;
    *(_WORD *)&v78[4] = 1024;
    *(_DWORD *)&v78[6] = v8;
    *(_WORD *)&v78[10] = 2048;
    double v79 = v48 / 1000000000.0 + v47;
    _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s%d hosts (%d matter, %d hap), %d instances, %d a records, %d aaaa records at %.6lf", v75, 0x44u);
    uint64_t v45 = v6[306];
  }
  if (os_log_type_enabled(v45, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)uint64_t v75 = 136447234;
    *(void *)&v75[4] = "srp_dump_server_stats";
    *(_WORD *)&v75[12] = 1024;
    *(_DWORD *)&v75[14] = num_push_sessions - srp_dump_server_stats_last_num_push_sessions;
    *(_WORD *)&v75[18] = 1024;
    *(_DWORD *)&v75[20] = dp_num_outstanding_queries - srp_dump_server_stats_last_dp_num_outstanding_queries;
    LOWORD(v76) = 1024;
    *(_DWORD *)((char *)&v76 + 2) = num_push_sessions_dropped_for_load
                                  - srp_dump_server_stats_last_num_push_sessions_dropped_for_load;
    WORD3(v76) = 1024;
    DWORD2(v76) = num_queries_dropped_for_load - srp_dump_server_stats_last_num_queries_dropped_for_load;
    _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%{public}s: %d push sessions and %d queries added, %d push sessions and %d queries dropped for load", v75, 0x24u);
  }
  srp_dump_server_stats_last_num_push_sessions = num_push_sessions;
  srp_dump_server_stats_last_dp_num_outstanding_queries = dp_num_outstanding_queries;
  srp_dump_server_stats_last_num_push_sessions_dropped_for_load = num_push_sessions_dropped_for_load;
  srp_dump_server_stats_last_num_queries_dropped_for_load = num_queries_dropped_for_load;
}

BOOL extract_instance_name(unsigned char *a1, unint64_t a2, const char *a3, uint64_t a4)
{
  int v8 = **(uint64_t ***)(*(void *)(a4 + 32) + 16);
  int v9 = (uint64_t **)*v8;
  if (*v8)
  {
    if (*v9) {
      uint64_t v10 = *v9;
    }
    else {
      uint64_t v10 = (uint64_t *)*v8;
    }
  }
  else
  {
    uint64_t v10 = 0;
  }
  dns_name_print_to_limit(v8, v10, (uint64_t)a3, 0x1FAuLL);
  BOOL v11 = *(uint64_t ****)(a4 + 32);
  int v12 = *v11;
  if (*v11)
  {
    int v13 = (uint64_t *)v11[1];
    size_t v14 = strlen(a3);
    while (v12[1] == v13)
    {
      uint64_t v15 = *v12[2];
      if (v14 + *(unsigned __int8 *)(v15 + 8) - 505 <= 0xFFFFFFFFFFFFFE04)
      {
        int v19 = global_os_log;
        BOOL result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
        if (result)
        {
          int v20 = 136447235;
          uint64_t v21 = "extract_instance_name";
          __int16 v22 = 2160;
          uint64_t v23 = 1752392040;
          __int16 v24 = 2081;
          uint32_t v25 = a3;
          __int16 v26 = 2160;
          uint64_t v27 = 1752392040;
          __int16 v28 = 2081;
          uint64_t v29 = v15 + 9;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_ERROR, "%{public}s: service name: %{private, mask.hash}s is too long for additional subtype %{private, mask.hash}s", (uint8_t *)&v20, 0x34u);
          return 0;
        }
        return result;
      }
      size_t v16 = v14 + 1;
      a3[v14] = 44;
      memcpy((void *)&a3[v14 + 1], (const void *)(*v12[2] + 9), *(unsigned __int8 *)(*v12[2] + 8) + 1);
      size_t v14 = v16 + *(unsigned __int8 *)(*v12[2] + 8);
      int v12 = (uint64_t **)*v12;
      if (!v12) {
        break;
      }
    }
  }
  uint64_t v17 = *(uint64_t **)(a4 + 16);
  if (v17) {
    dns_name_print_to_limit(v17, (uint64_t *)*v17, (uint64_t)a1, a2);
  }
  else {
    *a1 = 0;
  }
  return 1;
}

uint64_t compare_instance(uint64_t result, uint64_t **a2, uint64_t a3, char *__s1, char *a5)
{
  if (result)
  {
    if (!*(unsigned char *)(a3 + 264) && (uint64_t v8 = result, !strcmp(__s1, *(const char **)(result + 48))))
    {
      BOOL result = service_types_equal(a5, *(char **)(v8 + 56));
      if (result)
      {
        if (dns_names_equal_text(*a2, *(char **)(a3 + 56))) {
          return 1;
        }
        else {
          return 2;
        }
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

BOOL service_types_equal(char *a1, char *a2)
{
  uint64_t v4 = strchr(a1, 44);
  if (v4) {
    size_t v5 = v4 - a1;
  }
  else {
    size_t v5 = strlen(a1);
  }
  uint64_t v6 = strchr(a2, 44);
  if (v6) {
    size_t v7 = v6 - a2;
  }
  else {
    size_t v7 = strlen(a2);
  }
  return v5 == v7 && memcmp(a2, a1, v5) == 0;
}

void prepare_update(void *a1, void *a2)
{
  uint64_t v4 = (int *)malloc_type_calloc(1uLL, 0x88uLL, 0x1020040C5CF03A7uLL);
  size_t v5 = &dnssd_client_states;
  uint64_t v6 = global_os_log;
  uint64_t v244 = (uint64_t)v4;
  if (!v4)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_11;
    }
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "prepare_update";
    int v12 = "%{public}s: no memory for update.";
    goto LABEL_10;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = *v4;
    *(_DWORD *)int buf = 136447490;
    *(void *)&uint8_t buf[4] = "prepare_update";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v7;
    *(_WORD *)&unsigned char buf[18] = 2048;
    *(void *)&buf[20] = v4;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = "update";
    *(_WORD *)&unsigned char buf[38] = 2080;
    *(void *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&unsigned char buf[48] = 1024;
    *(_DWORD *)&buf[50] = 3260;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  uint64_t v243 = a2;
  int v8 = *v4;
  if (*v4)
  {
    int v9 = v8 + 1;
    int *v4 = v8 + 1;
    if (v8 + 1 >= 10001)
    {
      uint64_t v10 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_483;
      }
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "prepare_update";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v9;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&buf[20] = v4;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "update";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&unsigned char buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3260;
      BOOL v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_474;
    }
  }
  else
  {
    ++adv_update_created;
    int *v4 = 1;
  }
  uint64_t v13 = a1[2];
  a2 = v243;
  if (v13) {
    ioloop_cancel_wake_event(v13);
  }
  *((unsigned char *)a1 + 266) = 0;
  *(void *)int buf = 0;
  *(void *)&buf[8] = 0;
  clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)buf);
  *((void *)v4 + 15) = *(void *)buf;
  uint64_t v14 = a1[12];
  if (!v14 || (unsigned int v15 = *(_DWORD *)(v14 + 4)) == 0)
  {
    uint64_t v18 = 0;
    int v240 = 0;
    goto LABEL_21;
  }
  int v16 = *(_DWORD *)(v14 + 4);
  uint64_t v17 = adv_record_vec_create(v15);
  if (!v17)
  {
    uint64_t v6 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
LABEL_11:
      srp_parse_client_updates_free_(a2, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 3648);
      if (v4) {
        goto LABEL_245;
      }
      return;
    }
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "prepare_update";
    int v12 = "%{public}s: no memory for remove_addrs";
LABEL_10:
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_ERROR, v12, buf, 0xCu);
    goto LABEL_11;
  }
  uint64_t v18 = (uint64_t)v17;
  int v240 = v16;
  *((_DWORD *)v17 + 1) = v16;
LABEL_21:
  int v19 = (void *)(v243[5] + 8);
  unsigned int v20 = -1;
  do
  {
    int v19 = (void *)*v19;
    ++v20;
  }
  while (v19);
  uint64_t v21 = adv_record_vec_create(v20);
  uint64_t v22 = (uint64_t)v21;
  if (!v21)
  {
    uint64_t v45 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "prepare_update";
      BOOL v46 = "%{public}s: no memory for add_addrs";
LABEL_199:
      _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_ERROR, v46, buf, 0xCu);
    }
LABEL_200:
    double v48 = 0;
LABEL_201:
    uint64_t v49 = 0;
    uint64_t v50 = 0;
    goto LABEL_202;
  }
  uint64_t v23 = *(uint64_t ***)(v243[5] + 8);
  v247 = a1;
  if (v23)
  {
    int v24 = 0;
    do
    {
      if (v24 < 1) {
        goto LABEL_37;
      }
      uint32_t v25 = *(uint64_t **)(v22 + 8);
      uint64_t v26 = v24;
      char v27 = 1;
      do
      {
        uint64_t v28 = *v25;
        if (*v25)
        {
          int v29 = *(unsigned __int16 *)(v28 + 48);
          if (v29 == *((unsigned __int16 *)v23 + 8))
          {
            size_t v30 = *(unsigned __int16 *)(v28 + 50);
            int v31 = v29 == 1 ? 4 : 16;
            if (v31 == v30) {
              v27 &= memcmp(*(const void **)(v28 + 40), v23 + 3, v30) != 0;
            }
          }
        }
        ++v25;
        --v26;
      }
      while (v26);
      a1 = v247;
      if (v27)
      {
LABEL_37:
        int v32 = *((unsigned __int16 *)v23 + 8);
        if (v32 == 1) {
          unsigned int v33 = 4;
        }
        else {
          unsigned int v33 = 16;
        }
        int v34 = adv_record_create_(v32, v33, v23 + 3, a1, 3311);
        if (!v34)
        {
          size_t v5 = &dnssd_client_states;
          double v47 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)int buf = 136446210;
            *(void *)&uint8_t buf[4] = "prepare_update";
            _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_ERROR, "%{public}s: No memory for prepared address", buf, 0xCu);
          }
          double v48 = 0;
          uint64_t v49 = 0;
          uint64_t v50 = 0;
          a2 = v243;
          goto LABEL_202;
        }
        *(void *)(*(void *)(v22 + 8) + 8 * v24++) = v34;
      }
      uint64_t v23 = (uint64_t **)*v23;
    }
    while (v23);
    *(_DWORD *)(v22 + 4) = v24;
    v242 = (int *)(v22 + 4);
    if (v24 < 1)
    {
      int v245 = 0;
    }
    else
    {
      uint64_t v35 = 0;
      uint64_t v36 = *(void *)(v22 + 8);
      int v37 = v24;
      do
      {
        uint64_t v38 = *(void *)(v36 + 8 * v35);
        if (v38)
        {
          *(void *)(v38 + 32) = v4;
          uint64_t v39 = *(int **)(*(void *)(v36 + 8 * v35) + 32);
          if (v39)
          {
            uint64_t v40 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              int v41 = *v39;
              *(_DWORD *)int buf = 136447490;
              *(void *)&uint8_t buf[4] = "prepare_update";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v41;
              *(_WORD *)&unsigned char buf[18] = 2048;
              *(void *)&buf[20] = v39;
              *(_WORD *)&buf[28] = 2080;
              *(void *)&buf[30] = "add_addrs->vec[i]->update";
              *(_WORD *)&unsigned char buf[38] = 2080;
              *(void *)&buf[40] = "srp-mdns-proxy.c";
              *(_WORD *)&unsigned char buf[48] = 1024;
              *(_DWORD *)&buf[50] = 3323;
              _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
              uint64_t v36 = *(void *)(v22 + 8);
            }
            uint64_t v42 = *(int **)(*(void *)(v36 + 8 * v35) + 32);
            int v43 = *v42;
            if (!*v42)
            {
              ++adv_update_created;
              int v43 = *v42;
            }
            int v44 = v43 + 1;
            *uint64_t v42 = v43 + 1;
            if (v43 + 1 > 10000)
            {
              uint64_t v230 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)int buf = 136447490;
                *(void *)&uint8_t buf[4] = "prepare_update";
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = v44;
                *(_WORD *)&unsigned char buf[18] = 2048;
                *(void *)&buf[20] = v42;
                *(_WORD *)&buf[28] = 2080;
                *(void *)&buf[30] = "add_addrs->vec[i]->update";
                *(_WORD *)&unsigned char buf[38] = 2080;
                *(void *)&buf[40] = "srp-mdns-proxy.c";
                *(_WORD *)&unsigned char buf[48] = 1024;
                *(_DWORD *)&buf[50] = 3323;
                BOOL v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
                goto LABEL_480;
              }
              goto LABEL_483;
            }
            int v37 = *v242;
            uint64_t v4 = (int *)v244;
          }
        }
        ++v35;
      }
      while (v35 < v37);
      int v245 = 1;
      a1 = v247;
    }
  }
  else
  {
    int v245 = 0;
    int v24 = 0;
    *((_DWORD *)v21 + 1) = 0;
    v242 = (int *)v21 + 1;
  }
  if (v240)
  {
    if (v240 >= 1)
    {
      for (uint64_t i = 0; i != v240; ++i)
      {
        uint64_t v52 = a1[12];
        if (v52)
        {
          uint64_t v53 = *(void *)(*(void *)(v52 + 8) + 8 * i);
          if (v53)
          {
            *(void *)(*(void *)(v18 + 8) + 8 * i) = v53;
            char v54 = *(int **)(*(void *)(v18 + 8) + 8 * i);
            if (v54)
            {
              int v55 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                int v56 = *v54;
                *(_DWORD *)int buf = 136447490;
                *(void *)&uint8_t buf[4] = "prepare_update";
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = v56;
                *(_WORD *)&unsigned char buf[18] = 2048;
                *(void *)&buf[20] = v54;
                *(_WORD *)&buf[28] = 2080;
                *(void *)&buf[30] = "remove_addrs->vec[i]";
                *(_WORD *)&unsigned char buf[38] = 2080;
                *(void *)&buf[40] = "srp-mdns-proxy.c";
                *(_WORD *)&unsigned char buf[48] = 1024;
                *(_DWORD *)&buf[50] = 3353;
                _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                char v54 = *(int **)(*(void *)(v18 + 8) + 8 * i);
              }
              int v57 = *v54;
              if (!*v54)
              {
                ++adv_record_created;
                int v57 = *v54;
              }
              int v58 = v57 + 1;
              int *v54 = v57 + 1;
              if (v57 + 1 >= 10001)
              {
                uint64_t v230 = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                {
                  *(_DWORD *)int buf = 136447490;
                  *(void *)&uint8_t buf[4] = "prepare_update";
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v58;
                  *(_WORD *)&unsigned char buf[18] = 2048;
                  *(void *)&buf[20] = v54;
                  *(_WORD *)&buf[28] = 2080;
                  *(void *)&buf[30] = "remove_addrs->vec[i]";
                  *(_WORD *)&unsigned char buf[38] = 2080;
                  *(void *)&buf[40] = "srp-mdns-proxy.c";
                  *(_WORD *)&unsigned char buf[48] = 1024;
                  *(_DWORD *)&buf[50] = 3353;
                  BOOL v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
                  goto LABEL_480;
                }
                goto LABEL_483;
              }
            }
          }
        }
        if (v245)
        {
          for (uint64_t j = 0; v24 != j; ++j)
          {
            uint64_t v60 = *(void *)(v18 + 8);
            uint64_t v61 = *(void *)(v60 + 8 * i);
            if (v61)
            {
              uint64_t v62 = *(void *)(*(void *)(v22 + 8) + 8 * j);
              if (v62)
              {
                if (*(void *)(v61 + 8))
                {
                  uint64_t v63 = a1[1];
                  if (v63)
                  {
                    if (*(void *)(v61 + 24) == *(void *)(v63 + 16)
                      && *(unsigned __int16 *)(v62 + 48) == *(unsigned __int16 *)(v61 + 48))
                    {
                      size_t v64 = *(unsigned __int16 *)(v62 + 50);
                      if (v64 == *(unsigned __int16 *)(v61 + 50)
                        && !memcmp(*(const void **)(v62 + 40), *(const void **)(v61 + 40), v64))
                      {
                        int v65 = *(_DWORD *)v61;
                        if (!*(_DWORD *)v61)
                        {
                          uint64_t v230 = global_os_log;
                          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                          {
                            *(_DWORD *)int buf = 136447490;
                            *(void *)&uint8_t buf[4] = "prepare_update";
                            *(_WORD *)&unsigned char buf[12] = 1024;
                            *(_DWORD *)&buf[14] = 0;
                            *(_WORD *)&unsigned char buf[18] = 2048;
                            *(void *)&buf[20] = v61;
                            *(_WORD *)&buf[28] = 2080;
                            *(void *)&buf[30] = "remove_addrs->vec[i]";
                            *(_WORD *)&unsigned char buf[38] = 2080;
                            *(void *)&buf[40] = "srp-mdns-proxy.c";
                            *(_WORD *)&unsigned char buf[48] = 1024;
                            *(_DWORD *)&buf[50] = 3366;
                            BOOL v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
                            goto LABEL_480;
                          }
                          goto LABEL_483;
                        }
                        uint64_t v66 = global_os_log;
                        if (v65 >= 10001)
                        {
                          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                            goto LABEL_483;
                          }
                          *(_DWORD *)int buf = 136447490;
                          *(void *)&uint8_t buf[4] = "prepare_update";
                          *(_WORD *)&unsigned char buf[12] = 1024;
                          *(_DWORD *)&buf[14] = v65;
                          *(_WORD *)&unsigned char buf[18] = 2048;
                          *(void *)&buf[20] = v61;
                          *(_WORD *)&buf[28] = 2080;
                          *(void *)&buf[30] = "remove_addrs->vec[i]";
                          *(_WORD *)&unsigned char buf[38] = 2080;
                          *(void *)&buf[40] = "srp-mdns-proxy.c";
                          *(_WORD *)&unsigned char buf[48] = 1024;
                          *(_DWORD *)&buf[50] = 3366;
                          BOOL v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_477:
                          int v225 = buf;
                          uint64_t v226 = v66;
                          goto LABEL_482;
                        }
                        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_DWORD *)int buf = 136447490;
                          *(void *)&uint8_t buf[4] = "prepare_update";
                          *(_WORD *)&unsigned char buf[12] = 1024;
                          *(_DWORD *)&buf[14] = v65;
                          *(_WORD *)&unsigned char buf[18] = 2048;
                          *(void *)&buf[20] = v61;
                          *(_WORD *)&buf[28] = 2080;
                          *(void *)&buf[30] = "remove_addrs->vec[i]";
                          *(_WORD *)&unsigned char buf[38] = 2080;
                          *(void *)&buf[40] = "srp-mdns-proxy.c";
                          *(_WORD *)&unsigned char buf[48] = 1024;
                          *(_DWORD *)&buf[50] = 3366;
                          _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                          uint64_t v60 = *(void *)(v18 + 8);
                          uint64_t v61 = *(void *)(v60 + 8 * i);
                          int v65 = *(_DWORD *)v61;
                        }
                        a1 = v247;
                        *(_DWORD *)uint64_t v61 = v65 - 1;
                        if (v65 == 1)
                        {
                          __int16 v67 = global_os_log;
                          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                          {
                            *(_DWORD *)int buf = 136447234;
                            *(void *)&uint8_t buf[4] = "prepare_update";
                            *(_WORD *)&unsigned char buf[12] = 2048;
                            *(void *)&buf[14] = v61;
                            *(_WORD *)&unsigned char buf[22] = 2080;
                            *(void *)&unsigned char buf[24] = "remove_addrs->vec[i]";
                            *(_WORD *)&uint8_t buf[32] = 2080;
                            *(void *)&buf[34] = "srp-mdns-proxy.c";
                            *(_WORD *)&buf[42] = 1024;
                            *(_DWORD *)&buf[44] = 3366;
                            _os_log_impl((void *)&_mh_execute_header, v67, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
                            uint64_t v61 = *(void *)(*(void *)(v18 + 8) + 8 * i);
                          }
                          ++adv_record_finalized;
                          adv_record_finalize(v61);
                          uint64_t v60 = *(void *)(v18 + 8);
                          a1 = v247;
                        }
                        *(void *)(v60 + 8 * i) = 0;
                        uint64_t v68 = *(void *)(v22 + 8);
                        __int16 v69 = *(int **)(v68 + 8 * j);
                        if (v69)
                        {
                          int v70 = *v69;
                          if (!*v69)
                          {
                            uint64_t v230 = global_os_log;
                            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                            {
                              *(_DWORD *)int buf = 136447490;
                              *(void *)&uint8_t buf[4] = "prepare_update";
                              *(_WORD *)&unsigned char buf[12] = 1024;
                              *(_DWORD *)&buf[14] = 0;
                              *(_WORD *)&unsigned char buf[18] = 2048;
                              *(void *)&buf[20] = v69;
                              *(_WORD *)&buf[28] = 2080;
                              *(void *)&buf[30] = "add_addrs->vec[j]";
                              *(_WORD *)&unsigned char buf[38] = 2080;
                              *(void *)&buf[40] = "srp-mdns-proxy.c";
                              *(_WORD *)&unsigned char buf[48] = 1024;
                              *(_DWORD *)&buf[50] = 3368;
                              BOOL v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
                              goto LABEL_480;
                            }
                            goto LABEL_483;
                          }
                          uint64_t v66 = global_os_log;
                          if (v70 >= 10001)
                          {
                            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                              goto LABEL_483;
                            }
                            *(_DWORD *)int buf = 136447490;
                            *(void *)&uint8_t buf[4] = "prepare_update";
                            *(_WORD *)&unsigned char buf[12] = 1024;
                            *(_DWORD *)&buf[14] = v70;
                            *(_WORD *)&unsigned char buf[18] = 2048;
                            *(void *)&buf[20] = v69;
                            *(_WORD *)&buf[28] = 2080;
                            *(void *)&buf[30] = "add_addrs->vec[j]";
                            *(_WORD *)&unsigned char buf[38] = 2080;
                            *(void *)&buf[40] = "srp-mdns-proxy.c";
                            *(_WORD *)&unsigned char buf[48] = 1024;
                            *(_DWORD *)&buf[50] = 3368;
                            BOOL v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
                            goto LABEL_477;
                          }
                          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                          {
                            *(_DWORD *)int buf = 136447490;
                            *(void *)&uint8_t buf[4] = "prepare_update";
                            *(_WORD *)&unsigned char buf[12] = 1024;
                            *(_DWORD *)&buf[14] = v70;
                            *(_WORD *)&unsigned char buf[18] = 2048;
                            *(void *)&buf[20] = v69;
                            *(_WORD *)&buf[28] = 2080;
                            *(void *)&buf[30] = "add_addrs->vec[j]";
                            *(_WORD *)&unsigned char buf[38] = 2080;
                            *(void *)&buf[40] = "srp-mdns-proxy.c";
                            *(_WORD *)&unsigned char buf[48] = 1024;
                            *(_DWORD *)&buf[50] = 3368;
                            _os_log_impl((void *)&_mh_execute_header, v66, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                            uint64_t v68 = *(void *)(v22 + 8);
                            __int16 v69 = *(int **)(v68 + 8 * j);
                            int v70 = *v69;
                          }
                          a1 = v247;
                          *__int16 v69 = v70 - 1;
                          if (v70 == 1)
                          {
                            __int16 v71 = global_os_log;
                            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                            {
                              *(_DWORD *)int buf = 136447234;
                              *(void *)&uint8_t buf[4] = "prepare_update";
                              *(_WORD *)&unsigned char buf[12] = 2048;
                              *(void *)&buf[14] = v69;
                              *(_WORD *)&unsigned char buf[22] = 2080;
                              *(void *)&unsigned char buf[24] = "add_addrs->vec[j]";
                              *(_WORD *)&uint8_t buf[32] = 2080;
                              *(void *)&buf[34] = "srp-mdns-proxy.c";
                              *(_WORD *)&buf[42] = 1024;
                              *(_DWORD *)&buf[44] = 3368;
                              _os_log_impl((void *)&_mh_execute_header, v71, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
                              __int16 v69 = *(int **)(*(void *)(v22 + 8) + 8 * j);
                            }
                            ++adv_record_finalized;
                            adv_record_finalize((uint64_t)v69);
                            uint64_t v68 = *(void *)(v22 + 8);
                            a1 = v247;
                          }
                        }
                        *(void *)(v68 + 8 * j) = 0;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    *(_DWORD *)(v18 + 4) = v240;
    uint64_t v4 = (int *)v244;
  }
  a2 = v243;
  if (!a1[13])
  {
    uint64_t v89 = adv_record_create_(25, *((unsigned __int16 *)a1 + 116), (const void *)a1[30], a1, 3398);
    *((void *)v4 + 6) = v89;
    if (!v89)
    {
      size_t v5 = &dnssd_client_states;
      uint64_t v45 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "prepare_update";
        BOOL v46 = "%{public}s: no memory for key record";
        goto LABEL_199;
      }
      goto LABEL_200;
    }
    *((void *)v89 + 4) = v4;
    int v90 = global_os_log;
    uint64_t v91 = v4;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v92 = *v4;
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "prepare_update";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v92;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&buf[20] = v4;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "update->key->update";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&unsigned char buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3404;
      _os_log_impl((void *)&_mh_execute_header, v90, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      uint64_t v91 = *(int **)(*((void *)v4 + 6) + 32);
    }
    int v93 = *v91;
    if (*v91)
    {
      int v94 = v93 + 1;
      int *v91 = v93 + 1;
      if (v93 + 1 >= 10001)
      {
        uint64_t v230 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)int buf = 136447490;
          *(void *)&uint8_t buf[4] = "prepare_update";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v94;
          *(_WORD *)&unsigned char buf[18] = 2048;
          *(void *)&buf[20] = v91;
          *(_WORD *)&buf[28] = 2080;
          *(void *)&buf[30] = "update->key->update";
          *(_WORD *)&unsigned char buf[38] = 2080;
          *(void *)&buf[40] = "srp-mdns-proxy.c";
          *(_WORD *)&unsigned char buf[48] = 1024;
          *(_DWORD *)&buf[50] = 3404;
          BOOL v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
          goto LABEL_480;
        }
        goto LABEL_483;
      }
    }
    else
    {
      ++adv_update_created;
      int *v91 = 1;
    }
  }
  unsigned int v72 = *(_DWORD *)(a1[14] + 4);
  __int16 v73 = (int *)adv_instance_vec_create(v72);
  if (!v73)
  {
    size_t v5 = &dnssd_client_states;
    uint64_t v45 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "prepare_update";
      BOOL v46 = "%{public}s: no memory for update_instances";
      goto LABEL_199;
    }
    goto LABEL_200;
  }
  double v48 = v73;
  v73[1] = v72;
  uint64_t v74 = adv_instance_vec_create(v72);
  size_t v5 = &dnssd_client_states;
  if (!v74)
  {
    int v131 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "prepare_update";
      _os_log_impl((void *)&_mh_execute_header, v131, OS_LOG_TYPE_ERROR, "%{public}s: no memory for remove_instances", buf, 0xCu);
    }
    goto LABEL_201;
  }
  uint64_t v50 = (uint64_t)v74;
  *((_DWORD *)v74 + 1) = v72;
  uint64_t v75 = adv_instance_vec_create(v72);
  if (!v75)
  {
    unsigned int v145 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "prepare_update";
      _os_log_impl((void *)&_mh_execute_header, v145, OS_LOG_TYPE_ERROR, "%{public}s: no memory for renew_instances", buf, 0xCu);
    }
    uint64_t v49 = 0;
    goto LABEL_202;
  }
  uint64_t v237 = v48;
  uint64_t v238 = v50;
  uint64_t v236 = v75;
  *((_DWORD *)v75 + 1) = v72;
  for (uint64_t k = (uint64_t **)v243[8]; k; uint64_t k = (uint64_t **)*k)
  {
    uint64_t v77 = k[1];
    if (v77)
    {
      int v78 = (uint64_t *)*v77;
      if (*v77)
      {
        if (*v78)
        {
          dns_name_print_to_limit(v77, v78, (uint64_t)__s1, 0xFDuLL);
          dns_name_print_to_limit((uint64_t *)*k[1], **(uint64_t ***)*k[1], (uint64_t)buf, 0xFEuLL);
          uint64_t v79 = v247[14];
          uint64_t v80 = *(unsigned int *)(v79 + 4);
          if ((int)v80 >= 1)
          {
            uint64_t v81 = 0;
            uint64_t v82 = *(void *)(v79 + 8);
            while (1)
            {
              uint64_t v83 = *(void *)(v82 + 8 * v81);
              if (v83)
              {
                if (!strcmp(__s1, *(const char **)(v83 + 48)) && service_types_equal(buf, *(char **)(v83 + 56))) {
                  break;
                }
              }
              if (v80 == ++v81) {
                goto LABEL_120;
              }
            }
            *(void *)(*(void *)(v50 + 8) + 8 * v81) = v83;
            uint64_t v84 = *(int **)(*(void *)(v50 + 8) + 8 * v81);
            if (v84)
            {
              uint64_t v85 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                int v86 = *v84;
                *(_DWORD *)int v248 = 136447490;
                v249 = "prepare_update";
                __int16 v250 = 1024;
                *(_DWORD *)uint64_t v251 = v86;
                *(_WORD *)&v251[4] = 2048;
                *(void *)&v251[6] = v84;
                *(_WORD *)&v251[14] = 2080;
                *(void *)&v251[16] = "remove_instances->vec[i]";
                *(_WORD *)&v251[24] = 2080;
                *(void *)&v251[26] = "srp-mdns-proxy.c";
                __int16 v252 = 1024;
                int v253 = 3455;
                _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v248, 0x36u);
                uint64_t v84 = *(int **)(*(void *)(v50 + 8) + 8 * v81);
              }
              int v87 = *v84;
              if (*v84)
              {
                int v88 = v87 + 1;
                *uint64_t v84 = v87 + 1;
                if (v87 + 1 >= 10001)
                {
                  uint64_t v230 = global_os_log;
                  if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                    goto LABEL_483;
                  }
                  *(_DWORD *)int v248 = 136447490;
                  v249 = "prepare_update";
                  __int16 v250 = 1024;
                  *(_DWORD *)uint64_t v251 = v88;
                  *(_WORD *)&v251[4] = 2048;
                  *(void *)&v251[6] = v84;
                  *(_WORD *)&v251[14] = 2080;
                  *(void *)&v251[16] = "remove_instances->vec[i]";
                  *(_WORD *)&v251[24] = 2080;
                  *(void *)&v251[26] = "srp-mdns-proxy.c";
                  __int16 v252 = 1024;
                  int v253 = 3455;
                  BOOL v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
                  goto LABEL_488;
                }
              }
              else
              {
                ++adv_instance_created;
                *uint64_t v84 = 1;
              }
            }
          }
LABEL_120:
          uint64_t v4 = (int *)v244;
          size_t v5 = &dnssd_client_states;
        }
      }
    }
  }
  uint64_t v95 = v243 + 6;
  LODWORD(v96) = -1;
  uint64_t v97 = v243 + 6;
  do
  {
    uint64_t v97 = (void *)*v97;
    uint64_t v96 = (v96 + 1);
  }
  while (v97);
  uint64_t v98 = adv_instance_vec_create(v96);
  if (!v98)
  {
    unsigned int v146 = *((void *)v5 + 306);
    uint64_t v50 = v238;
    if (os_log_type_enabled(v146, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "prepare_update";
      _os_log_impl((void *)&_mh_execute_header, v146, OS_LOG_TYPE_ERROR, "%{public}s: prepare_update: no memory for add_instances", buf, 0xCu);
    }
    uint64_t v49 = 0;
    a2 = v243;
    goto LABEL_202;
  }
  uint64_t v99 = v98;
  uint64_t v100 = *v95;
  BOOL v241 = v98;
  if (!*v95)
  {
    LODWORD(v101) = 0;
LABEL_266:
    *((_DWORD *)v99 + 1) = v101;
    if ((int)v96 >= 1)
    {
      uint64_t v147 = 0;
      do
      {
        uint64_t v246 = v147;
        uint64_t v239 = v99[1];
        uint64_t v148 = *(void *)(v239 + 8 * v147);
        if (v148)
        {
          uint64_t v149 = v247[14];
          uint64_t v150 = *(unsigned int *)(v149 + 4);
          if ((int)v150 >= 1)
          {
            uint64_t v151 = 0;
            uint64_t v152 = *(void *)(v149 + 8);
            while (1)
            {
              unint64_t v153 = *(int **)(v152 + 8 * v151);
              if (v153)
              {
                if (!strcmp(*(const char **)(v148 + 48), *((const char **)v153 + 6)))
                {
                  int v154 = *(char **)(v148 + 56);
                  unsigned int v155 = (char *)*((void *)v153 + 7);
                  if (service_types_equal(v154, v155)) {
                    break;
                  }
                }
              }
              if (v150 == ++v151) {
                goto LABEL_275;
              }
            }
            if (!*((unsigned char *)v153 + 116)
              && (size_t v156 = *(unsigned __int16 *)(v148 + 80), v156 == *((unsigned __int16 *)v153 + 40))
              && *(_DWORD *)(v148 + 64) == v153[16]
              && !strcmp(v154, v155)
              && (!v156 || !memcmp(*(const void **)(v148 + 72), *((const void **)v153 + 9), v156)))
            {
              int v166 = *(_DWORD *)v148;
              if (!*(_DWORD *)v148)
              {
                uint64_t v230 = global_os_log;
                if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                  goto LABEL_483;
                }
                *(_DWORD *)int buf = 136447490;
                *(void *)&uint8_t buf[4] = "prepare_update";
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = 0;
                *(_WORD *)&unsigned char buf[18] = 2048;
                *(void *)&buf[20] = v148;
                *(_WORD *)&buf[28] = 2080;
                *(void *)&buf[30] = "add_instances->vec[i]";
                *(_WORD *)&unsigned char buf[38] = 2080;
                *(void *)&buf[40] = "srp-mdns-proxy.c";
                *(_WORD *)&unsigned char buf[48] = 1024;
                *(_DWORD *)&buf[50] = 3531;
                BOOL v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_480:
                int v225 = buf;
                goto LABEL_481;
              }
              uint64_t v110 = global_os_log;
              if (v166 >= 10001)
              {
                if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                  goto LABEL_483;
                }
                *(_DWORD *)int buf = 136447490;
                *(void *)&uint8_t buf[4] = "prepare_update";
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = v166;
                *(_WORD *)&unsigned char buf[18] = 2048;
                *(void *)&buf[20] = v148;
                *(_WORD *)&buf[28] = 2080;
                *(void *)&buf[30] = "add_instances->vec[i]";
                *(_WORD *)&unsigned char buf[38] = 2080;
                *(void *)&buf[40] = "srp-mdns-proxy.c";
                *(_WORD *)&unsigned char buf[48] = 1024;
                *(_DWORD *)&buf[50] = 3531;
                BOOL v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_499:
                int v225 = buf;
                goto LABEL_500;
              }
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)int buf = 136447490;
                *(void *)&uint8_t buf[4] = "prepare_update";
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = v166;
                *(_WORD *)&unsigned char buf[18] = 2048;
                *(void *)&buf[20] = v148;
                *(_WORD *)&buf[28] = 2080;
                *(void *)&buf[30] = "add_instances->vec[i]";
                *(_WORD *)&unsigned char buf[38] = 2080;
                *(void *)&buf[40] = "srp-mdns-proxy.c";
                *(_WORD *)&unsigned char buf[48] = 1024;
                *(_DWORD *)&buf[50] = 3531;
                _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                uint64_t v167 = v241[1];
                uint64_t v148 = *(void *)(v167 + 8 * v246);
                int v166 = *(_DWORD *)v148;
                uint64_t v168 = &dnssd_client_states;
              }
              else
              {
                uint64_t v168 = &dnssd_client_states;
                uint64_t v167 = v239;
              }
              *(_DWORD *)uint64_t v148 = v166 - 1;
              if (v166 == 1)
              {
                uint64_t v169 = *((void *)v168 + 306);
                if (os_log_type_enabled(v169, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)int buf = 136447234;
                  *(void *)&uint8_t buf[4] = "prepare_update";
                  *(_WORD *)&unsigned char buf[12] = 2048;
                  *(void *)&buf[14] = v148;
                  *(_WORD *)&unsigned char buf[22] = 2080;
                  *(void *)&unsigned char buf[24] = "add_instances->vec[i]";
                  *(_WORD *)&uint8_t buf[32] = 2080;
                  *(void *)&buf[34] = "srp-mdns-proxy.c";
                  *(_WORD *)&buf[42] = 1024;
                  *(_DWORD *)&buf[44] = 3531;
                  _os_log_impl((void *)&_mh_execute_header, v169, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
                  uint64_t v148 = *(void *)(v241[1] + 8 * v246);
                }
                ++adv_instance_finalized;
                adv_instance_finalize((void *)v148);
                uint64_t v167 = v241[1];
                uint64_t v168 = &dnssd_client_states;
              }
              *(void *)(v167 + 8 * v246) = 0;
              *(void *)(v236[1] + 8 * v151) = v153;
              uint64_t v170 = *((void *)v168 + 306);
              if (os_log_type_enabled(v170, OS_LOG_TYPE_DEFAULT))
              {
                int v171 = *v153;
                *(_DWORD *)int buf = 136447490;
                *(void *)&uint8_t buf[4] = "prepare_update";
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = v171;
                *(_WORD *)&unsigned char buf[18] = 2048;
                *(void *)&buf[20] = v153;
                *(_WORD *)&buf[28] = 2080;
                *(void *)&buf[30] = "host_instance";
                *(_WORD *)&unsigned char buf[38] = 2080;
                *(void *)&buf[40] = "srp-mdns-proxy.c";
                *(_WORD *)&unsigned char buf[48] = 1024;
                *(_DWORD *)&buf[50] = 3534;
                _os_log_impl((void *)&_mh_execute_header, v170, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
              }
              int v172 = *v153;
              if (*v153)
              {
                int v173 = v172 + 1;
                int *v153 = v172 + 1;
                if (v172 + 1 >= 10001)
                {
                  uint64_t v10 = global_os_log;
                  if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                    goto LABEL_483;
                  }
                  *(_DWORD *)int buf = 136447490;
                  *(void *)&uint8_t buf[4] = "prepare_update";
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v173;
                  *(_WORD *)&unsigned char buf[18] = 2048;
                  *(void *)&buf[20] = v153;
                  *(_WORD *)&buf[28] = 2080;
                  *(void *)&buf[30] = "host_instance";
                  *(_WORD *)&unsigned char buf[38] = 2080;
                  *(void *)&buf[40] = "srp-mdns-proxy.c";
                  *(_WORD *)&unsigned char buf[48] = 1024;
                  *(_DWORD *)&buf[50] = 3534;
                  BOOL v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
                  goto LABEL_474;
                }
              }
              else
              {
                ++adv_instance_created;
                int *v153 = 1;
              }
              uint64_t v174 = v236[1];
              *(void *)(*(void *)(v174 + 8 * v151) + 32) = v244;
              __int16 v175 = *(int **)(*(void *)(v174 + 8 * v151) + 32);
              long long v133 = global_os_log;
              if (v175)
              {
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                {
                  int v176 = *v175;
                  *(_DWORD *)int buf = 136447490;
                  *(void *)&uint8_t buf[4] = "prepare_update";
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v176;
                  *(_WORD *)&unsigned char buf[18] = 2048;
                  *(void *)&buf[20] = v175;
                  *(_WORD *)&buf[28] = 2080;
                  *(void *)&buf[30] = "renew_instances->vec[j]->update";
                  *(_WORD *)&unsigned char buf[38] = 2080;
                  *(void *)&buf[40] = "srp-mdns-proxy.c";
                  *(_WORD *)&unsigned char buf[48] = 1024;
                  *(_DWORD *)&buf[50] = 3536;
                  _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                  __int16 v175 = *(int **)(*(void *)(v236[1] + 8 * v151) + 32);
                }
                int v177 = *v175;
                if (*v175)
                {
                  int v178 = v177 + 1;
                  *__int16 v175 = v177 + 1;
                  long long v133 = global_os_log;
                  if (v177 + 1 >= 10001)
                  {
                    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                      goto LABEL_483;
                    }
                    *(_DWORD *)int buf = 136447490;
                    *(void *)&uint8_t buf[4] = "prepare_update";
                    *(_WORD *)&unsigned char buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v178;
                    *(_WORD *)&unsigned char buf[18] = 2048;
                    *(void *)&buf[20] = v175;
                    *(_WORD *)&buf[28] = 2080;
                    *(void *)&buf[30] = "renew_instances->vec[j]->update";
                    *(_WORD *)&unsigned char buf[38] = 2080;
                    *(void *)&buf[40] = "srp-mdns-proxy.c";
                    *(_WORD *)&unsigned char buf[48] = 1024;
                    *(_DWORD *)&buf[50] = 3536;
                    BOOL v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_460:
                    int v225 = buf;
LABEL_461:
                    uint64_t v226 = v133;
LABEL_482:
                    _os_log_impl((void *)&_mh_execute_header, v226, OS_LOG_TYPE_FAULT, v11, v225, 0x36u);
                    goto LABEL_483;
                  }
                }
                else
                {
                  ++adv_update_created;
                  *__int16 v175 = 1;
                  long long v133 = global_os_log;
                }
              }
              if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v179 = *((void *)v153 + 6);
                uint64_t v180 = *((void *)v153 + 7);
                uint64_t v181 = v247[7];
                *(_DWORD *)int buf = 136447747;
                *(void *)&uint8_t buf[4] = "prepare_update";
                *(_WORD *)&unsigned char buf[12] = 2160;
                *(void *)&buf[14] = 1752392040;
                *(_WORD *)&unsigned char buf[22] = 2081;
                *(void *)&unsigned char buf[24] = v179;
                *(_WORD *)&uint8_t buf[32] = 2160;
                *(void *)&buf[34] = 1752392040;
                *(_WORD *)&buf[42] = 2081;
                *(void *)&buf[44] = v180;
                *(_WORD *)&buf[52] = 2160;
                *(void *)&buf[54] = 1752392040;
                *(_WORD *)&buf[62] = 2081;
                *(void *)&buf[64] = v181;
                _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "%{public}s: %{private, mask.hash}s.%{private, mask.hash}s renewed for host %{private, mask.hash}s", buf, 0x48u);
              }
            }
            else
            {
              *(void *)(*((void *)v237 + 1) + 8 * v151) = v148;
              __int16 v157 = *(int **)(*((void *)v237 + 1) + 8 * v151);
              if (v157)
              {
                int v158 = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                {
                  int v159 = *v157;
                  *(_DWORD *)int buf = 136447490;
                  *(void *)&uint8_t buf[4] = "prepare_update";
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v159;
                  *(_WORD *)&unsigned char buf[18] = 2048;
                  *(void *)&buf[20] = v157;
                  *(_WORD *)&buf[28] = 2080;
                  *(void *)&buf[30] = "update_instances->vec[j]";
                  *(_WORD *)&unsigned char buf[38] = 2080;
                  *(void *)&buf[40] = "srp-mdns-proxy.c";
                  *(_WORD *)&unsigned char buf[48] = 1024;
                  *(_DWORD *)&buf[50] = 3541;
                  _os_log_impl((void *)&_mh_execute_header, v158, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                  __int16 v157 = *(int **)(*((void *)v237 + 1) + 8 * v151);
                }
                int v160 = *v157;
                if (*v157)
                {
                  int v161 = v160 + 1;
                  int *v157 = v160 + 1;
                  if (v160 + 1 >= 10001)
                  {
                    uint64_t v230 = global_os_log;
                    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                    {
                      *(_DWORD *)int buf = 136447490;
                      *(void *)&uint8_t buf[4] = "prepare_update";
                      *(_WORD *)&unsigned char buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v161;
                      *(_WORD *)&unsigned char buf[18] = 2048;
                      *(void *)&buf[20] = v157;
                      *(_WORD *)&buf[28] = 2080;
                      *(void *)&buf[30] = "update_instances->vec[j]";
                      *(_WORD *)&unsigned char buf[38] = 2080;
                      *(void *)&buf[40] = "srp-mdns-proxy.c";
                      *(_WORD *)&unsigned char buf[48] = 1024;
                      *(_DWORD *)&buf[50] = 3541;
                      BOOL v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
                      goto LABEL_480;
                    }
                    goto LABEL_483;
                  }
                }
                else
                {
                  ++adv_instance_created;
                  int *v157 = 1;
                }
              }
              uint64_t v162 = v241[1];
              uint64_t v163 = *(int **)(v162 + 8 * v246);
              if (v163)
              {
                int v164 = *v163;
                if (!*v163)
                {
                  uint64_t v230 = global_os_log;
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                  {
                    *(_DWORD *)int buf = 136447490;
                    *(void *)&uint8_t buf[4] = "prepare_update";
                    *(_WORD *)&unsigned char buf[12] = 1024;
                    *(_DWORD *)&buf[14] = 0;
                    *(_WORD *)&unsigned char buf[18] = 2048;
                    *(void *)&buf[20] = v163;
                    *(_WORD *)&buf[28] = 2080;
                    *(void *)&buf[30] = "add_instances->vec[i]";
                    *(_WORD *)&unsigned char buf[38] = 2080;
                    *(void *)&buf[40] = "srp-mdns-proxy.c";
                    *(_WORD *)&unsigned char buf[48] = 1024;
                    *(_DWORD *)&buf[50] = 3542;
                    BOOL v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
                    goto LABEL_480;
                  }
                  goto LABEL_483;
                }
                uint64_t v110 = global_os_log;
                if (v164 >= 10001)
                {
                  if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                    goto LABEL_483;
                  }
                  *(_DWORD *)int buf = 136447490;
                  *(void *)&uint8_t buf[4] = "prepare_update";
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v164;
                  *(_WORD *)&unsigned char buf[18] = 2048;
                  *(void *)&buf[20] = v163;
                  *(_WORD *)&buf[28] = 2080;
                  *(void *)&buf[30] = "add_instances->vec[i]";
                  *(_WORD *)&unsigned char buf[38] = 2080;
                  *(void *)&buf[40] = "srp-mdns-proxy.c";
                  *(_WORD *)&unsigned char buf[48] = 1024;
                  *(_DWORD *)&buf[50] = 3542;
                  BOOL v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
                  goto LABEL_499;
                }
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                {
                  *(_DWORD *)int buf = 136447490;
                  *(void *)&uint8_t buf[4] = "prepare_update";
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v164;
                  *(_WORD *)&unsigned char buf[18] = 2048;
                  *(void *)&buf[20] = v163;
                  *(_WORD *)&buf[28] = 2080;
                  *(void *)&buf[30] = "add_instances->vec[i]";
                  *(_WORD *)&unsigned char buf[38] = 2080;
                  *(void *)&buf[40] = "srp-mdns-proxy.c";
                  *(_WORD *)&unsigned char buf[48] = 1024;
                  *(_DWORD *)&buf[50] = 3542;
                  _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                  uint64_t v162 = v241[1];
                  uint64_t v163 = *(int **)(v162 + 8 * v246);
                  int v164 = *v163;
                }
                *uint64_t v163 = v164 - 1;
                if (v164 == 1)
                {
                  unsigned int v165 = global_os_log;
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)int buf = 136447234;
                    *(void *)&uint8_t buf[4] = "prepare_update";
                    *(_WORD *)&unsigned char buf[12] = 2048;
                    *(void *)&buf[14] = v163;
                    *(_WORD *)&unsigned char buf[22] = 2080;
                    *(void *)&unsigned char buf[24] = "add_instances->vec[i]";
                    *(_WORD *)&uint8_t buf[32] = 2080;
                    *(void *)&buf[34] = "srp-mdns-proxy.c";
                    *(_WORD *)&buf[42] = 1024;
                    *(_DWORD *)&buf[44] = 3542;
                    _os_log_impl((void *)&_mh_execute_header, v165, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
                    uint64_t v163 = *(int **)(v241[1] + 8 * v246);
                  }
                  ++adv_instance_finalized;
                  adv_instance_finalize(v163);
                  uint64_t v162 = v241[1];
                }
              }
              *(void *)(v162 + 8 * v246) = 0;
            }
          }
        }
LABEL_275:
        uint64_t v147 = v246 + 1;
        uint64_t v99 = v241;
      }
      while (v246 + 1 != v96);
    }
    __int16 v182 = v247;
    *(void *)(v244 + 8) = v247;
    if (v247)
    {
      uint64_t v183 = global_os_log;
      __int16 v184 = (int *)v247;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v185 = *(_DWORD *)v247;
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "prepare_update";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v185;
        *(_WORD *)&unsigned char buf[18] = 2048;
        *(void *)&buf[20] = v247;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "update->host";
        *(_WORD *)&unsigned char buf[38] = 2080;
        *(void *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&unsigned char buf[48] = 1024;
        *(_DWORD *)&buf[50] = 3574;
        _os_log_impl((void *)&_mh_execute_header, v183, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        __int16 v184 = *(int **)(v244 + 8);
      }
      int v186 = *v184;
      if (*v184)
      {
        int v187 = v186 + 1;
        int *v184 = v186 + 1;
        if (v186 + 1 >= 10001)
        {
          uint64_t v230 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "prepare_update";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v187;
            *(_WORD *)&unsigned char buf[18] = 2048;
            *(void *)&buf[20] = v184;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = "update->host";
            *(_WORD *)&unsigned char buf[38] = 2080;
            *(void *)&buf[40] = "srp-mdns-proxy.c";
            *(_WORD *)&unsigned char buf[48] = 1024;
            *(_DWORD *)&buf[50] = 3574;
            BOOL v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
            goto LABEL_480;
          }
          goto LABEL_483;
        }
      }
      else
      {
        ++adv_host_created;
        int *v184 = 1;
      }
    }
    *(void *)(v244 + 16) = v243;
    *(void *)(v244 + 32) = v18;
    *(void *)(v244 + 40) = v22;
    *(void *)(v244 + 56) = v237;
    *(void *)(v244 + 64) = v238;
    *(void *)(v244 + 72) = v236;
    *(void *)(v244 + 80) = v99;
    *(void *)(v244 + 104) = v243[11];
    uint64_t v188 = v243[4];
    if (v188)
    {
      uint64_t v189 = *(void *)(v247[1] + 48);
      if (v189)
      {
        if (*(unsigned char *)(v189 + 258))
        {
          uint64_t v190 = (void *)(v188 + 12);
          if (*(void *)(v189 + 176) == *(void *)(v188 + 12) && v247[12] && *v242 >= 1)
          {
            for (uint64_t m = 0; m < *v242; ++m)
            {
              uint64_t v210 = *(void *)(*(void *)(v22 + 8) + 8 * m);
              if (v210 && *(_WORD *)(v210 + 50) == 16)
              {
                uint64_t v211 = *(void **)(v210 + 40);
                if (*v190 != *v211 || *(void *)(v188 + 20) != v211[1])
                {
                  unsigned int v213 = global_os_log;
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                  {
                    int v214 = *(unsigned __int8 *)v211;
                    size_t v215 = "ULA: ";
                    if ((v214 & 0xFE) != 0xFC)
                    {
                      if (v214 != 254 || (size_t v215 = "LUA: ", (*((unsigned char *)v211 + 1) & 0xC0) != 0x80))
                      {
                        size_t v215 = "";
                        if ((v214 & 0xE0) == 0x20) {
                          size_t v215 = "GUA: ";
                        }
                      }
                    }
                    int v216 = *(unsigned __int8 *)v190;
                    int v217 = "ULA: ";
                    if ((v216 & 0xFE) != 0xFC)
                    {
                      if (v216 != 254 || (int v217 = "LUA: ", (*(unsigned char *)(v188 + 13) & 0xC0) != 0x80))
                      {
                        int v217 = "";
                        if ((v216 & 0xE0) == 0x20) {
                          int v217 = "GUA: ";
                        }
                      }
                    }
                    int v218 = v247;
                    uint64_t v219 = v247[7];
                    *(_DWORD *)int buf = 136451843;
                    *(void *)&uint8_t buf[4] = "prepare_update";
                    *(_WORD *)&unsigned char buf[12] = 2160;
                    *(void *)&buf[14] = 1752392040;
                    *(_WORD *)&unsigned char buf[22] = 2081;
                    *(void *)&unsigned char buf[24] = v219;
                    *(_WORD *)&uint8_t buf[32] = 2082;
                    *(void *)&buf[34] = v215;
                    *(_WORD *)&buf[42] = 2160;
                    *(void *)&buf[44] = 1752392040;
                    *(_WORD *)&buf[52] = 1041;
                    *(_DWORD *)&buf[54] = 6;
                    *(_WORD *)&buf[58] = 2097;
                    *(void *)&buf[60] = v211;
                    *(_WORD *)&buf[68] = 2160;
                    *(void *)&buf[70] = 1752392040;
                    *(_WORD *)&buf[78] = 1042;
                    *(_DWORD *)&buf[80] = 2;
                    __int16 v255 = 2098;
                    *(void *)uint64_t v256 = (char *)v211 + 6;
                    *(_WORD *)&v256[8] = 2160;
                    *(void *)&v256[10] = 1752392040;
                    *(_WORD *)&v256[18] = 1041;
                    int v257 = 8;
                    __int16 v258 = 2097;
                    uint64_t v259 = v211 + 1;
                    __int16 v260 = 2082;
                    uint64_t v261 = v217;
                    __int16 v262 = 2160;
                    uint64_t v263 = 1752392040;
                    __int16 v264 = 1041;
                    int v265 = 6;
                    __int16 v266 = 2097;
                    uint64_t v267 = v188 + 12;
                    __int16 v268 = 2160;
                    uint64_t v269 = 1752392040;
                    __int16 v270 = 1042;
                    int v271 = 2;
                    __int16 v272 = 2098;
                    uint64_t v273 = v188 + 18;
                    __int16 v274 = 2160;
                    uint64_t v275 = 1752392040;
                    __int16 v276 = 1041;
                    int v277 = 8;
                    __int16 v278 = 2097;
                    uint64_t v279 = v188 + 20;
                    _os_log_impl((void *)&_mh_execute_header, v213, OS_LOG_TYPE_DEFAULT, "%{public}s: mapping host %{private, mask.hash}s address {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} to {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}", buf, 0xD0u);
                    uint64_t v211 = *(void **)(v210 + 40);
                  }
                  else
                  {
                    int v218 = v247;
                  }
                  __int16 v182 = v218;
                  if (!cti_add_ml_eid_mapping_(v210, v211, (const void *)(v188 + 12), (const char *)v218[7]))
                  {
                    int v220 = global_os_log;
                    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                    {
                      int v221 = *(_DWORD *)v210;
                      *(_DWORD *)int buf = 136447490;
                      *(void *)&uint8_t buf[4] = "prepare_update";
                      *(_WORD *)&unsigned char buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v221;
                      *(_WORD *)&unsigned char buf[18] = 2048;
                      *(void *)&buf[20] = v210;
                      *(_WORD *)&buf[28] = 2080;
                      *(void *)&buf[30] = "arec";
                      *(_WORD *)&unsigned char buf[38] = 2080;
                      *(void *)&buf[40] = "srp-mdns-proxy.c";
                      *(_WORD *)&unsigned char buf[48] = 1024;
                      *(_DWORD *)&buf[50] = 3620;
                      _os_log_impl((void *)&_mh_execute_header, v220, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                    }
                    int v222 = *(_DWORD *)v210;
                    if (*(_DWORD *)v210)
                    {
                      int v223 = v222 + 1;
                      *(_DWORD *)uint64_t v210 = v222 + 1;
                      __int16 v182 = v247;
                      if (v222 + 1 >= 10001)
                      {
                        uint64_t v230 = global_os_log;
                        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                        {
                          *(_DWORD *)int buf = 136447490;
                          *(void *)&uint8_t buf[4] = "prepare_update";
                          *(_WORD *)&unsigned char buf[12] = 1024;
                          *(_DWORD *)&buf[14] = v223;
                          *(_WORD *)&unsigned char buf[18] = 2048;
                          *(void *)&buf[20] = v210;
                          *(_WORD *)&buf[28] = 2080;
                          *(void *)&buf[30] = "arec";
                          *(_WORD *)&unsigned char buf[38] = 2080;
                          *(void *)&buf[40] = "srp-mdns-proxy.c";
                          *(_WORD *)&unsigned char buf[48] = 1024;
                          *(_DWORD *)&buf[50] = 3620;
                          BOOL v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
                          goto LABEL_480;
                        }
LABEL_483:
                        abort();
                      }
                    }
                    else
                    {
                      ++adv_record_created;
                      *(_DWORD *)uint64_t v210 = 1;
                      __int16 v182 = v247;
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    v182[6] = v244;
    __int16 v191 = global_os_log;
    int v192 = (int *)v244;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v193 = *(_DWORD *)v244;
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "prepare_update";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v193;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&buf[20] = v244;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "host->update";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&unsigned char buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3628;
      _os_log_impl((void *)&_mh_execute_header, v191, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      int v192 = (int *)v182[6];
    }
    int v194 = *v192;
    if (*v192)
    {
      int v195 = v194 + 1;
      *int v192 = v194 + 1;
      if (v194 + 1 >= 10001)
      {
        uint64_t v230 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)int buf = 136447490;
          *(void *)&uint8_t buf[4] = "prepare_update";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v195;
          *(_WORD *)&unsigned char buf[18] = 2048;
          *(void *)&buf[20] = v192;
          *(_WORD *)&buf[28] = 2080;
          *(void *)&buf[30] = "host->update";
          *(_WORD *)&unsigned char buf[38] = 2080;
          *(void *)&buf[40] = "srp-mdns-proxy.c";
          *(_WORD *)&unsigned char buf[48] = 1024;
          *(_DWORD *)&buf[50] = 3628;
          BOOL v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
          goto LABEL_480;
        }
        goto LABEL_483;
      }
    }
    else
    {
      ++adv_update_created;
      *int v192 = 1;
    }
    int v196 = *(_DWORD *)v244;
    if (*(_DWORD *)v244)
    {
      uint64_t v10 = global_os_log;
      if (v196 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447490;
          *(void *)&uint8_t buf[4] = "prepare_update";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v196;
          *(_WORD *)&unsigned char buf[18] = 2048;
          *(void *)&buf[20] = v244;
          *(_WORD *)&buf[28] = 2080;
          *(void *)&buf[30] = "update";
          *(_WORD *)&unsigned char buf[38] = 2080;
          *(void *)&buf[40] = "srp-mdns-proxy.c";
          *(_WORD *)&unsigned char buf[48] = 1024;
          *(_DWORD *)&buf[50] = 3629;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          int v196 = *(_DWORD *)v244;
        }
        *(_DWORD *)uint64_t v244 = v196 - 1;
        if (v196 == 1)
        {
          int v197 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136447234;
            *(void *)&uint8_t buf[4] = "prepare_update";
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(void *)&buf[14] = v244;
            *(_WORD *)&unsigned char buf[22] = 2080;
            *(void *)&unsigned char buf[24] = "update";
            *(_WORD *)&uint8_t buf[32] = 2080;
            *(void *)&buf[34] = "srp-mdns-proxy.c";
            *(_WORD *)&buf[42] = 1024;
            *(_DWORD *)&buf[44] = 3629;
            _os_log_impl((void *)&_mh_execute_header, v197, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          }
          ++adv_update_finalized;
          adv_update_finalize(v244);
        }
        start_host_update(v182);
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_483;
      }
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "prepare_update";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v196;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&buf[20] = v244;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "update";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&unsigned char buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3629;
      BOOL v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      uint64_t v10 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_483;
      }
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "prepare_update";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&buf[20] = v244;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "update";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&unsigned char buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3629;
      BOOL v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    goto LABEL_474;
  }
  uint64_t v101 = 0;
  while (1)
  {
    uint64_t v102 = v101;
    int v103 = (int *)malloc_type_calloc(1uLL, 0x78uLL, 0x10300404874479FuLL);
    int v104 = *((void *)v5 + 306);
    if (!v103)
    {
      a2 = v243;
      double v48 = v237;
      if (!os_log_type_enabled(v104, OS_LOG_TYPE_ERROR)) {
        goto LABEL_438;
      }
      *(_DWORD *)int v248 = 136446210;
      v249 = "adv_instance_create";
      int v198 = "%{public}s: adv_instance:create: unable to allocate raw registration struct.";
      __int16 v199 = v104;
      goto LABEL_437;
    }
    int v105 = v103;
    if (os_log_type_enabled(v104, OS_LOG_TYPE_DEFAULT))
    {
      int v106 = *v105;
      *(_DWORD *)int v248 = 136447490;
      v249 = "adv_instance_create";
      __int16 v250 = 1024;
      *(_DWORD *)uint64_t v251 = v106;
      *(_WORD *)&v251[4] = 2048;
      *(void *)&v251[6] = v105;
      *(_WORD *)&v251[14] = 2080;
      *(void *)&v251[16] = "instance";
      *(_WORD *)&v251[24] = 2080;
      *(void *)&v251[26] = "srp-mdns-proxy.c";
      __int16 v252 = 1024;
      int v253 = 2585;
      _os_log_impl((void *)&_mh_execute_header, v104, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v248, 0x36u);
    }
    int v107 = *v105;
    if (*v105)
    {
      int v108 = v107 + 1;
      int *v105 = v107 + 1;
      if (v107 + 1 >= 10001)
      {
        uint64_t v230 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_483;
        }
        *(_DWORD *)int v248 = 136447490;
        v249 = "adv_instance_create";
        __int16 v250 = 1024;
        *(_DWORD *)uint64_t v251 = v108;
        *(_WORD *)&v251[4] = 2048;
        *(void *)&v251[6] = v105;
        *(_WORD *)&v251[14] = 2080;
        *(void *)&v251[16] = "instance";
        *(_WORD *)&v251[24] = 2080;
        *(void *)&v251[26] = "srp-mdns-proxy.c";
        __int16 v252 = 1024;
        int v253 = 2585;
        BOOL v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        goto LABEL_488;
      }
    }
    else
    {
      ++adv_instance_created;
      int *v105 = 1;
    }
    int v109 = (int *)v247;
    *((void *)v105 + 3) = v247;
    uint64_t v110 = global_os_log;
    if (v247)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v111 = *(_DWORD *)v247;
        *(_DWORD *)int v248 = 136447490;
        v249 = "adv_instance_create";
        __int16 v250 = 1024;
        *(_DWORD *)uint64_t v251 = v111;
        *(_WORD *)&v251[4] = 2048;
        *(void *)&v251[6] = v247;
        *(_WORD *)&v251[14] = 2080;
        *(void *)&v251[16] = "instance->host";
        *(_WORD *)&v251[24] = 2080;
        *(void *)&v251[26] = "srp-mdns-proxy.c";
        __int16 v252 = 1024;
        int v253 = 2587;
        _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v248, 0x36u);
        int v109 = (int *)*((void *)v105 + 3);
      }
      int v112 = *v109;
      if (*v109)
      {
        int v113 = v112 + 1;
        *int v109 = v112 + 1;
        uint64_t v110 = global_os_log;
        if (v112 + 1 >= 10001)
        {
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
            goto LABEL_483;
          }
          *(_DWORD *)int v248 = 136447490;
          v249 = "adv_instance_create";
          __int16 v250 = 1024;
          *(_DWORD *)uint64_t v251 = v113;
          *(_WORD *)&v251[4] = 2048;
          *(void *)&v251[6] = v109;
          *(_WORD *)&v251[14] = 2080;
          *(void *)&v251[16] = "instance->host";
          *(_WORD *)&v251[24] = 2080;
          *(void *)&v251[26] = "srp-mdns-proxy.c";
          __int16 v252 = 1024;
          int v253 = 2587;
          BOOL v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
          int v225 = v248;
LABEL_500:
          uint64_t v226 = v110;
          goto LABEL_482;
        }
      }
      else
      {
        ++adv_host_created;
        *int v109 = 1;
        uint64_t v110 = global_os_log;
      }
    }
    *((void *)v105 + 4) = v4;
    int v114 = v4;
    if (os_log_type_enabled(v110, OS_LOG_TYPE_DEFAULT))
    {
      int v115 = *v4;
      *(_DWORD *)int v248 = 136447490;
      v249 = "adv_instance_create";
      __int16 v250 = 1024;
      *(_DWORD *)uint64_t v251 = v115;
      *(_WORD *)&v251[4] = 2048;
      *(void *)&v251[6] = v4;
      *(_WORD *)&v251[14] = 2080;
      *(void *)&v251[16] = "instance->update";
      *(_WORD *)&v251[24] = 2080;
      *(void *)&v251[26] = "srp-mdns-proxy.c";
      __int16 v252 = 1024;
      int v253 = 2589;
      _os_log_impl((void *)&_mh_execute_header, v110, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v248, 0x36u);
      int v114 = (int *)*((void *)v105 + 4);
    }
    int v116 = *v114;
    if (*v114)
    {
      int v117 = v116 + 1;
      *int v114 = v116 + 1;
      if (v116 + 1 >= 10001)
      {
        uint64_t v230 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_483;
        }
        *(_DWORD *)int v248 = 136447490;
        v249 = "adv_instance_create";
        __int16 v250 = 1024;
        *(_DWORD *)uint64_t v251 = v117;
        *(_WORD *)&v251[4] = 2048;
        *(void *)&v251[6] = v114;
        *(_WORD *)&v251[14] = 2080;
        *(void *)&v251[16] = "instance->update";
        *(_WORD *)&v251[24] = 2080;
        *(void *)&v251[26] = "srp-mdns-proxy.c";
        __int16 v252 = 1024;
        int v253 = 2589;
        BOOL v11 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        goto LABEL_488;
      }
    }
    else
    {
      ++adv_update_created;
      *int v114 = 1;
    }
    uint64_t v118 = *(void *)(v100 + 48);
    if (v118) {
      LODWORD(v118) = *(unsigned __int16 *)(v118 + 28);
    }
    size_t v5 = &dnssd_client_states;
    v105[16] = v118;
    if (!extract_instance_name(buf, 0x3F2uLL, __s1, v100))
    {
      int v200 = *v105;
      if (*v105)
      {
        long long v133 = global_os_log;
        double v48 = v237;
        if (v200 < 10001)
        {
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int v248 = 136447490;
            v249 = "adv_instance_create";
            __int16 v250 = 1024;
            *(_DWORD *)uint64_t v251 = v200;
            *(_WORD *)&v251[4] = 2048;
            *(void *)&v251[6] = v105;
            *(_WORD *)&v251[14] = 2080;
            *(void *)&v251[16] = "instance";
            *(_WORD *)&v251[24] = 2080;
            *(void *)&v251[26] = "srp-mdns-proxy.c";
            __int16 v252 = 1024;
            int v253 = 2596;
            _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v248, 0x36u);
            int v200 = *v105;
          }
          BOOL v129 = v200 == 1;
          int *v105 = v200 - 1;
          a2 = v243;
          if (!v129)
          {
LABEL_438:
            size_t v5 = &dnssd_client_states;
            goto LABEL_439;
          }
          BOOL v201 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int v248 = 136447234;
            v249 = "adv_instance_create";
            __int16 v250 = 2048;
            *(void *)uint64_t v251 = v105;
            *(_WORD *)&v251[8] = 2080;
            *(void *)&v251[10] = "instance";
            *(_WORD *)&v251[18] = 2080;
            *(void *)&v251[20] = "srp-mdns-proxy.c";
            *(_WORD *)&v251[28] = 1024;
            *(_DWORD *)&v251[30] = 2596;
            goto LABEL_382;
          }
LABEL_383:
          ++adv_instance_finalized;
          adv_instance_finalize(v105);
          goto LABEL_438;
        }
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_483;
        }
        *(_DWORD *)int v248 = 136447490;
        v249 = "adv_instance_create";
        __int16 v250 = 1024;
        *(_DWORD *)uint64_t v251 = v200;
        *(_WORD *)&v251[4] = 2048;
        *(void *)&v251[6] = v105;
        *(_WORD *)&v251[14] = 2080;
        *(void *)&v251[16] = "instance";
        *(_WORD *)&v251[24] = 2080;
        *(void *)&v251[26] = "srp-mdns-proxy.c";
        __int16 v252 = 1024;
        int v253 = 2596;
        BOOL v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_525:
        int v225 = v248;
        goto LABEL_461;
      }
      uint64_t v230 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_483;
      }
      *(_DWORD *)int v248 = 136447490;
      v249 = "adv_instance_create";
      __int16 v250 = 1024;
      *(_DWORD *)uint64_t v251 = 0;
      *(_WORD *)&v251[4] = 2048;
      *(void *)&v251[6] = v105;
      *(_WORD *)&v251[14] = 2080;
      *(void *)&v251[16] = "instance";
      *(_WORD *)&v251[24] = 2080;
      *(void *)&v251[26] = "srp-mdns-proxy.c";
      __int16 v252 = 1024;
      int v253 = 2596;
      BOOL v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_488:
      int v225 = v248;
LABEL_481:
      uint64_t v226 = v230;
      goto LABEL_482;
    }
    unsigned int v119 = strdup(buf);
    *((void *)v105 + 6) = v119;
    if (!v119)
    {
      int v202 = global_os_log;
      double v48 = v237;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int v248 = 136446210;
        v249 = "adv_instance_create";
        _os_log_impl((void *)&_mh_execute_header, v202, OS_LOG_TYPE_ERROR, "%{public}s: adv_instance:create: unable to allocate instance name.", v248, 0xCu);
      }
      int v203 = *v105;
      if (!*v105)
      {
        uint64_t v230 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_483;
        }
        *(_DWORD *)int v248 = 136447490;
        v249 = "adv_instance_create";
        __int16 v250 = 1024;
        *(_DWORD *)uint64_t v251 = 0;
        *(_WORD *)&v251[4] = 2048;
        *(void *)&v251[6] = v105;
        *(_WORD *)&v251[14] = 2080;
        *(void *)&v251[16] = "instance";
        *(_WORD *)&v251[24] = 2080;
        *(void *)&v251[26] = "srp-mdns-proxy.c";
        __int16 v252 = 1024;
        int v253 = 2603;
        BOOL v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_488;
      }
      long long v133 = global_os_log;
      if (v203 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_483;
        }
        *(_DWORD *)int v248 = 136447490;
        v249 = "adv_instance_create";
        __int16 v250 = 1024;
        *(_DWORD *)uint64_t v251 = v203;
        *(_WORD *)&v251[4] = 2048;
        *(void *)&v251[6] = v105;
        *(_WORD *)&v251[14] = 2080;
        *(void *)&v251[16] = "instance";
        *(_WORD *)&v251[24] = 2080;
        *(void *)&v251[26] = "srp-mdns-proxy.c";
        __int16 v252 = 1024;
        int v253 = 2603;
        BOOL v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_525;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int v248 = 136447490;
        v249 = "adv_instance_create";
        __int16 v250 = 1024;
        *(_DWORD *)uint64_t v251 = v203;
        *(_WORD *)&v251[4] = 2048;
        *(void *)&v251[6] = v105;
        *(_WORD *)&v251[14] = 2080;
        *(void *)&v251[16] = "instance";
        *(_WORD *)&v251[24] = 2080;
        *(void *)&v251[26] = "srp-mdns-proxy.c";
        __int16 v252 = 1024;
        int v253 = 2603;
        _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v248, 0x36u);
        int v203 = *v105;
      }
      BOOL v129 = v203 == 1;
      int *v105 = v203 - 1;
      a2 = v243;
      if (!v129) {
        goto LABEL_438;
      }
      BOOL v201 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_383;
      }
      *(_DWORD *)int v248 = 136447234;
      v249 = "adv_instance_create";
      __int16 v250 = 2048;
      *(void *)uint64_t v251 = v105;
      *(_WORD *)&v251[8] = 2080;
      *(void *)&v251[10] = "instance";
      *(_WORD *)&v251[18] = 2080;
      *(void *)&v251[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v251[28] = 1024;
      *(_DWORD *)&v251[30] = 2603;
LABEL_382:
      _os_log_impl((void *)&_mh_execute_header, v201, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v248, 0x30u);
      goto LABEL_383;
    }
    uint64_t v120 = strdup(__s1);
    *((void *)v105 + 7) = v120;
    if (!v120)
    {
      uint64_t v204 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int v248 = 136446210;
        v249 = "adv_instance_create";
        _os_log_impl((void *)&_mh_execute_header, v204, OS_LOG_TYPE_ERROR, "%{public}s: adv_instance:create: unable to allocate instance type.", v248, 0xCu);
      }
      int v205 = *v105;
      double v48 = v237;
      if (!*v105)
      {
        uint64_t v230 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_483;
        }
        *(_DWORD *)int v248 = 136447490;
        v249 = "adv_instance_create";
        __int16 v250 = 1024;
        *(_DWORD *)uint64_t v251 = 0;
        *(_WORD *)&v251[4] = 2048;
        *(void *)&v251[6] = v105;
        *(_WORD *)&v251[14] = 2080;
        *(void *)&v251[16] = "instance";
        *(_WORD *)&v251[24] = 2080;
        *(void *)&v251[26] = "srp-mdns-proxy.c";
        __int16 v252 = 1024;
        int v253 = 2609;
        BOOL v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_488;
      }
      long long v133 = global_os_log;
      if (v205 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_483;
        }
        *(_DWORD *)int v248 = 136447490;
        v249 = "adv_instance_create";
        __int16 v250 = 1024;
        *(_DWORD *)uint64_t v251 = v205;
        *(_WORD *)&v251[4] = 2048;
        *(void *)&v251[6] = v105;
        *(_WORD *)&v251[14] = 2080;
        *(void *)&v251[16] = "instance";
        *(_WORD *)&v251[24] = 2080;
        *(void *)&v251[26] = "srp-mdns-proxy.c";
        __int16 v252 = 1024;
        int v253 = 2609;
        BOOL v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_525;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int v248 = 136447490;
        v249 = "adv_instance_create";
        __int16 v250 = 1024;
        *(_DWORD *)uint64_t v251 = v205;
        *(_WORD *)&v251[4] = 2048;
        *(void *)&v251[6] = v105;
        *(_WORD *)&v251[14] = 2080;
        *(void *)&v251[16] = "instance";
        *(_WORD *)&v251[24] = 2080;
        *(void *)&v251[26] = "srp-mdns-proxy.c";
        __int16 v252 = 1024;
        int v253 = 2609;
        _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v248, 0x36u);
        int v205 = *v105;
      }
      BOOL v129 = v205 == 1;
      int *v105 = v205 - 1;
      a2 = v243;
      if (!v129) {
        goto LABEL_438;
      }
      BOOL v201 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_383;
      }
      *(_DWORD *)int v248 = 136447234;
      v249 = "adv_instance_create";
      __int16 v250 = 2048;
      *(void *)uint64_t v251 = v105;
      *(_WORD *)&v251[8] = 2080;
      *(void *)&v251[10] = "instance";
      *(_WORD *)&v251[18] = 2080;
      *(void *)&v251[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v251[28] = 1024;
      *(_DWORD *)&v251[30] = 2609;
      goto LABEL_382;
    }
    uint64_t v121 = *(void *)(v100 + 56);
    if (v121)
    {
      int v122 = malloc_type_malloc(*(unsigned __int8 *)(v121 + 16), 0xE630E6A3uLL);
      if (v122)
      {
        int v123 = v122;
        memcpy(v122, *(const void **)(*(void *)(v100 + 56) + 24), *(unsigned __int8 *)(*(void *)(v100 + 56) + 16));
        *((void *)v105 + 9) = v123;
        LOWORD(v121) = *(unsigned __int8 *)(*(void *)(v100 + 56) + 16);
        size_t v5 = &dnssd_client_states;
        goto LABEL_173;
      }
      int v208 = *v105;
      if (!*v105)
      {
        uint64_t v230 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_483;
        }
        *(_DWORD *)int v248 = 136447490;
        v249 = "adv_instance_create";
        __int16 v250 = 1024;
        *(_DWORD *)uint64_t v251 = 0;
        *(_WORD *)&v251[4] = 2048;
        *(void *)&v251[6] = v105;
        *(_WORD *)&v251[14] = 2080;
        *(void *)&v251[16] = "instance";
        *(_WORD *)&v251[24] = 2080;
        *(void *)&v251[26] = "srp-mdns-proxy.c";
        __int16 v252 = 1024;
        int v253 = 2617;
        BOOL v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_488;
      }
      long long v133 = global_os_log;
      double v48 = v237;
      if (v208 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_483;
        }
        *(_DWORD *)int v248 = 136447490;
        v249 = "adv_instance_create";
        __int16 v250 = 1024;
        *(_DWORD *)uint64_t v251 = v208;
        *(_WORD *)&v251[4] = 2048;
        *(void *)&v251[6] = v105;
        *(_WORD *)&v251[14] = 2080;
        *(void *)&v251[16] = "instance";
        *(_WORD *)&v251[24] = 2080;
        *(void *)&v251[26] = "srp-mdns-proxy.c";
        __int16 v252 = 1024;
        int v253 = 2617;
        BOOL v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_525;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int v248 = 136447490;
        v249 = "adv_instance_create";
        __int16 v250 = 1024;
        *(_DWORD *)uint64_t v251 = v208;
        *(_WORD *)&v251[4] = 2048;
        *(void *)&v251[6] = v105;
        *(_WORD *)&v251[14] = 2080;
        *(void *)&v251[16] = "instance";
        *(_WORD *)&v251[24] = 2080;
        *(void *)&v251[26] = "srp-mdns-proxy.c";
        __int16 v252 = 1024;
        int v253 = 2617;
        _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v248, 0x36u);
        int v208 = *v105;
        long long v133 = global_os_log;
      }
      int *v105 = v208 - 1;
      if (v208 == 1)
      {
        a2 = v243;
        if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int v248 = 136447234;
          v249 = "adv_instance_create";
          __int16 v250 = 2048;
          *(void *)uint64_t v251 = v105;
          *(_WORD *)&v251[8] = 2080;
          *(void *)&v251[10] = "instance";
          *(_WORD *)&v251[18] = 2080;
          *(void *)&v251[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v251[28] = 1024;
          *(_DWORD *)&v251[30] = 2617;
          _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v248, 0x30u);
        }
        ++adv_instance_finalized;
        adv_instance_finalize(v105);
        long long v133 = global_os_log;
      }
      else
      {
        a2 = v243;
      }
      if (!os_log_type_enabled(v133, OS_LOG_TYPE_ERROR)) {
        goto LABEL_438;
      }
      *(_DWORD *)int v248 = 136446210;
      v249 = "adv_instance_create";
      int v198 = "%{public}s: adv_instance:create: unable to allocate txt_data buffer";
      __int16 v199 = v133;
LABEL_437:
      _os_log_impl((void *)&_mh_execute_header, v199, OS_LOG_TYPE_ERROR, v198, v248, 0xCu);
      goto LABEL_438;
    }
    *((void *)v105 + 9) = 0;
LABEL_173:
    *((_WORD *)v105 + 40) = v121;
    *((unsigned char *)v105 + 119) = *(unsigned char *)(v100 + 64);
    if ((v96 & ~((int)v96 >> 31)) == v102) {
      break;
    }
    *((unsigned char *)v105 + 118) = 0;
    if (v243[1])
    {
      uint64_t v124 = v243[4];
      if (v124)
      {
        if (*(unsigned char *)(v124 + 33) == 30)
        {
          unsigned int v125 = *(unsigned __int16 *)(v124 + 34);
          int v126 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v127 = *(unsigned __int8 *)(v124 + 40);
            int v128 = "ULA: ";
            if ((v127 & 0xFE) != 0xFC)
            {
              if (v127 != 254 || (int v128 = "LUA: ", (*(unsigned char *)(v124 + 41) & 0xC0) != 0x80))
              {
                int v128 = "GUA: ";
                if ((v127 & 0xE0) != 0x20) {
                  int v128 = "";
                }
              }
            }
            *(_DWORD *)int buf = 136449027;
            *(void *)&uint8_t buf[4] = "prepare_update";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v128;
            *(_WORD *)&unsigned char buf[22] = 2160;
            *(void *)&unsigned char buf[24] = 1752392040;
            *(_WORD *)&uint8_t buf[32] = 1041;
            *(_DWORD *)&buf[34] = 6;
            *(_WORD *)&unsigned char buf[38] = 2097;
            *(void *)&buf[40] = v124 + 40;
            *(_WORD *)&unsigned char buf[48] = 2160;
            *(void *)&buf[50] = 1752392040;
            *(_WORD *)&buf[58] = 1042;
            *(_DWORD *)&buf[60] = 2;
            *(_WORD *)&buf[64] = 2098;
            *(void *)&buf[66] = v124 + 46;
            *(_WORD *)&buf[74] = 2160;
            *(void *)&buf[76] = 1752392040;
            __int16 v255 = 1041;
            *(_DWORD *)uint64_t v256 = 8;
            *(_WORD *)&v256[4] = 2097;
            *(void *)&v256[6] = v124 + 48;
            *(_WORD *)&v256[14] = 1024;
            *(_DWORD *)&v256[16] = __rev16(v125);
            _os_log_impl((void *)&_mh_execute_header, v126, OS_LOG_TYPE_DEFAULT, "%{public}s: server address {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}; server port %d",
              buf,
              0x6Au);
          }
          BOOL v129 = *(_DWORD *)(v124 + 48) == -16777216 && *(_DWORD *)(v124 + 51) == -67043585;
          if (v129 && v125 == 13568) {
            *((unsigned char *)v105 + 118) = 1;
          }
        }
      }
      else
      {
        int v130 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "connection_get_local_address";
          _os_log_impl((void *)&_mh_execute_header, v130, OS_LOG_TYPE_ERROR, "%{public}s: message is NULL.", buf, 0xCu);
        }
      }
    }
    uint64_t v101 = v102 + 1;
    *(void *)(v241[1] + 8 * v102) = v105;
    uint64_t v100 = *(void *)v100;
    uint64_t v4 = (int *)v244;
    size_t v5 = &dnssd_client_states;
    if (!v100)
    {
      uint64_t v99 = v241;
      goto LABEL_266;
    }
  }
  uint64_t v206 = *((void *)v5 + 306);
  if (os_log_type_enabled(v206, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "prepare_update";
    _os_log_impl((void *)&_mh_execute_header, v206, OS_LOG_TYPE_FAULT, "%{public}s: while preparing client update instances, i >= num_add_instances", buf, 0xCu);
  }
  int v207 = *v105;
  double v48 = v237;
  if (!*v105)
  {
    uint64_t v230 = *((void *)v5 + 306);
    if (os_log_type_enabled(v230, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "prepare_update";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&buf[20] = v105;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "prepared_instance";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&unsigned char buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3485;
      BOOL v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_480;
    }
    goto LABEL_483;
  }
  long long v133 = *((void *)v5 + 306);
  if (v207 >= 10001)
  {
    if (!os_log_type_enabled(v133, OS_LOG_TYPE_FAULT)) {
      goto LABEL_483;
    }
    *(_DWORD *)int buf = 136447490;
    *(void *)&uint8_t buf[4] = "prepare_update";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v207;
    *(_WORD *)&unsigned char buf[18] = 2048;
    *(void *)&buf[20] = v105;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = "prepared_instance";
    *(_WORD *)&unsigned char buf[38] = 2080;
    *(void *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&unsigned char buf[48] = 1024;
    *(_DWORD *)&buf[50] = 3485;
    BOOL v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_460;
  }
  if (os_log_type_enabled(v133, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136447490;
    *(void *)&uint8_t buf[4] = "prepare_update";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v207;
    *(_WORD *)&unsigned char buf[18] = 2048;
    *(void *)&buf[20] = v105;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = "prepared_instance";
    *(_WORD *)&unsigned char buf[38] = 2080;
    *(void *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&unsigned char buf[48] = 1024;
    *(_DWORD *)&buf[50] = 3485;
    _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    int v207 = *v105;
  }
  int *v105 = v207 - 1;
  if (v207 == 1)
  {
    v224 = *((void *)v5 + 306);
    a2 = v243;
    if (os_log_type_enabled(v224, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136447234;
      *(void *)&uint8_t buf[4] = "prepare_update";
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v105;
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&unsigned char buf[24] = "prepared_instance";
      *(_WORD *)&uint8_t buf[32] = 2080;
      *(void *)&buf[34] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[42] = 1024;
      *(_DWORD *)&buf[44] = 3485;
      _os_log_impl((void *)&_mh_execute_header, v224, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
    }
    ++adv_instance_finalized;
    adv_instance_finalize(v105);
  }
  else
  {
    a2 = v243;
  }
LABEL_439:
  uint64_t v50 = v238;
  uint64_t v49 = (int *)v241;
LABEL_202:
  srp_parse_client_updates_free_(a2, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 3648);
  if (!v18) {
    goto LABEL_208;
  }
  int v132 = *(_DWORD *)v18;
  if (!*(_DWORD *)v18)
  {
    uint64_t v230 = *((void *)v5 + 306);
    if (os_log_type_enabled(v230, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "prepare_update";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&buf[20] = v18;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "remove_addrs";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&unsigned char buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3653;
      BOOL v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_480;
    }
    goto LABEL_483;
  }
  long long v133 = *((void *)v5 + 306);
  if (v132 >= 10001)
  {
    if (!os_log_type_enabled(*((os_log_t *)v5 + 306), OS_LOG_TYPE_FAULT)) {
      goto LABEL_483;
    }
    *(_DWORD *)int buf = 136447490;
    *(void *)&uint8_t buf[4] = "prepare_update";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v132;
    *(_WORD *)&unsigned char buf[18] = 2048;
    *(void *)&buf[20] = v18;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = "remove_addrs";
    *(_WORD *)&unsigned char buf[38] = 2080;
    *(void *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&unsigned char buf[48] = 1024;
    *(_DWORD *)&buf[50] = 3653;
    BOOL v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_460;
  }
  if (os_log_type_enabled(*((os_log_t *)v5 + 306), OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136447490;
    *(void *)&uint8_t buf[4] = "prepare_update";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v132;
    *(_WORD *)&unsigned char buf[18] = 2048;
    *(void *)&buf[20] = v18;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = "remove_addrs";
    *(_WORD *)&unsigned char buf[38] = 2080;
    *(void *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&unsigned char buf[48] = 1024;
    *(_DWORD *)&buf[50] = 3653;
    _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    int v132 = *(_DWORD *)v18;
  }
  *(_DWORD *)uint64_t v18 = v132 - 1;
  if (v132 == 1)
  {
    uint64_t v136 = *((void *)v5 + 306);
    if (os_log_type_enabled(v136, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136447234;
      *(void *)&uint8_t buf[4] = "prepare_update";
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v18;
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&unsigned char buf[24] = "remove_addrs";
      *(_WORD *)&uint8_t buf[32] = 2080;
      *(void *)&buf[34] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[42] = 1024;
      *(_DWORD *)&buf[44] = 3653;
      _os_log_impl((void *)&_mh_execute_header, v136, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
    }
    ++adv_record_vec_finalized;
    adv_record_vec_finalize(v18);
    if (v22)
    {
LABEL_209:
      int v134 = *(_DWORD *)v22;
      if (!*(_DWORD *)v22)
      {
        uint64_t v230 = *((void *)v5 + 306);
        if (os_log_type_enabled(v230, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)int buf = 136447490;
          *(void *)&uint8_t buf[4] = "prepare_update";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = 0;
          *(_WORD *)&unsigned char buf[18] = 2048;
          *(void *)&buf[20] = v22;
          *(_WORD *)&buf[28] = 2080;
          *(void *)&buf[30] = "add_addrs";
          *(_WORD *)&unsigned char buf[38] = 2080;
          *(void *)&buf[40] = "srp-mdns-proxy.c";
          *(_WORD *)&unsigned char buf[48] = 1024;
          *(_DWORD *)&buf[50] = 3657;
          BOOL v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
          goto LABEL_480;
        }
        goto LABEL_483;
      }
      long long v133 = *((void *)v5 + 306);
      if (v134 >= 10001)
      {
        if (!os_log_type_enabled(*((os_log_t *)v5 + 306), OS_LOG_TYPE_FAULT)) {
          goto LABEL_483;
        }
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "prepare_update";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v134;
        *(_WORD *)&unsigned char buf[18] = 2048;
        *(void *)&buf[20] = v22;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "add_addrs";
        *(_WORD *)&unsigned char buf[38] = 2080;
        *(void *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&unsigned char buf[48] = 1024;
        *(_DWORD *)&buf[50] = 3657;
        BOOL v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_460;
      }
      if (os_log_type_enabled(*((os_log_t *)v5 + 306), OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "prepare_update";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v134;
        *(_WORD *)&unsigned char buf[18] = 2048;
        *(void *)&buf[20] = v22;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "add_addrs";
        *(_WORD *)&unsigned char buf[38] = 2080;
        *(void *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&unsigned char buf[48] = 1024;
        *(_DWORD *)&buf[50] = 3657;
        _os_log_impl((void *)&_mh_execute_header, v133, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        int v134 = *(_DWORD *)v22;
      }
      *(_DWORD *)uint64_t v22 = v134 - 1;
      if (v134 == 1)
      {
        uint64_t v135 = *((void *)v5 + 306);
        if (os_log_type_enabled(v135, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447234;
          *(void *)&uint8_t buf[4] = "prepare_update";
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v22;
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&unsigned char buf[24] = "add_addrs";
          *(_WORD *)&uint8_t buf[32] = 2080;
          *(void *)&buf[34] = "srp-mdns-proxy.c";
          *(_WORD *)&buf[42] = 1024;
          *(_DWORD *)&buf[44] = 3657;
          _os_log_impl((void *)&_mh_execute_header, v135, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        }
        ++adv_record_vec_finalized;
        adv_record_vec_finalize(v22);
      }
    }
  }
  else
  {
LABEL_208:
    if (v22) {
      goto LABEL_209;
    }
  }
  if (!v49)
  {
LABEL_226:
    if (!v50) {
      goto LABEL_238;
    }
LABEL_227:
    int v138 = *(_DWORD *)v50;
    if (!*(_DWORD *)v50)
    {
      uint64_t v230 = *((void *)v5 + 306);
      if (os_log_type_enabled(v230, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "prepare_update";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 0;
        *(_WORD *)&unsigned char buf[18] = 2048;
        *(void *)&buf[20] = v50;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "remove_instances";
        *(_WORD *)&unsigned char buf[38] = 2080;
        *(void *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&unsigned char buf[48] = 1024;
        *(_DWORD *)&buf[50] = 3665;
        BOOL v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_480;
      }
      goto LABEL_483;
    }
    uint64_t v10 = *((void *)v5 + 306);
    if (v138 < 10001)
    {
      if (os_log_type_enabled(*((os_log_t *)v5 + 306), OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "prepare_update";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v138;
        *(_WORD *)&unsigned char buf[18] = 2048;
        *(void *)&buf[20] = v50;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "remove_instances";
        *(_WORD *)&unsigned char buf[38] = 2080;
        *(void *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&unsigned char buf[48] = 1024;
        *(_DWORD *)&buf[50] = 3665;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        int v138 = *(_DWORD *)v50;
      }
      *(_DWORD *)uint64_t v50 = v138 - 1;
      if (v138 == 1)
      {
        int v139 = *((void *)v5 + 306);
        if (os_log_type_enabled(v139, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447234;
          *(void *)&uint8_t buf[4] = "prepare_update";
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v50;
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&unsigned char buf[24] = "remove_instances";
          *(_WORD *)&uint8_t buf[32] = 2080;
          *(void *)&buf[34] = "srp-mdns-proxy.c";
          *(_WORD *)&buf[42] = 1024;
          *(_DWORD *)&buf[44] = 3665;
          _os_log_impl((void *)&_mh_execute_header, v139, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        }
        ++adv_instance_vec_finalized;
        adv_instance_vec_finalize(v50);
      }
      goto LABEL_238;
    }
    if (!os_log_type_enabled(*((os_log_t *)v5 + 306), OS_LOG_TYPE_FAULT)) {
      goto LABEL_483;
    }
    *(_DWORD *)int buf = 136447490;
    *(void *)&uint8_t buf[4] = "prepare_update";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v138;
    *(_WORD *)&unsigned char buf[18] = 2048;
    *(void *)&buf[20] = v50;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = "remove_instances";
    *(_WORD *)&unsigned char buf[38] = 2080;
    *(void *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&unsigned char buf[48] = 1024;
    *(_DWORD *)&buf[50] = 3665;
    BOOL v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_474;
  }
  int v137 = *v49;
  if (!*v49)
  {
    uint64_t v230 = *((void *)v5 + 306);
    if (os_log_type_enabled(v230, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "prepare_update";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&buf[20] = v49;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "add_instances";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&unsigned char buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3661;
      BOOL v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_480;
    }
    goto LABEL_483;
  }
  uint64_t v10 = *((void *)v5 + 306);
  if (v137 >= 10001)
  {
    if (!os_log_type_enabled(*((os_log_t *)v5 + 306), OS_LOG_TYPE_FAULT)) {
      goto LABEL_483;
    }
    *(_DWORD *)int buf = 136447490;
    *(void *)&uint8_t buf[4] = "prepare_update";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v137;
    *(_WORD *)&unsigned char buf[18] = 2048;
    *(void *)&buf[20] = v49;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = "add_instances";
    *(_WORD *)&unsigned char buf[38] = 2080;
    *(void *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&unsigned char buf[48] = 1024;
    *(_DWORD *)&buf[50] = 3661;
    BOOL v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_474;
  }
  if (os_log_type_enabled(*((os_log_t *)v5 + 306), OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136447490;
    *(void *)&uint8_t buf[4] = "prepare_update";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v137;
    *(_WORD *)&unsigned char buf[18] = 2048;
    *(void *)&buf[20] = v49;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = "add_instances";
    *(_WORD *)&unsigned char buf[38] = 2080;
    *(void *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&unsigned char buf[48] = 1024;
    *(_DWORD *)&buf[50] = 3661;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    int v137 = *v49;
  }
  int *v49 = v137 - 1;
  if (v137 != 1) {
    goto LABEL_226;
  }
  uint64_t v140 = *((void *)v5 + 306);
  if (os_log_type_enabled(v140, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136447234;
    *(void *)&uint8_t buf[4] = "prepare_update";
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(void *)&buf[14] = v49;
    *(_WORD *)&unsigned char buf[22] = 2080;
    *(void *)&unsigned char buf[24] = "add_instances";
    *(_WORD *)&uint8_t buf[32] = 2080;
    *(void *)&buf[34] = "srp-mdns-proxy.c";
    *(_WORD *)&buf[42] = 1024;
    *(_DWORD *)&buf[44] = 3661;
    _os_log_impl((void *)&_mh_execute_header, v140, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
  }
  ++adv_instance_vec_finalized;
  adv_instance_vec_finalize((uint64_t)v49);
  if (v50) {
    goto LABEL_227;
  }
LABEL_238:
  if (!v48) {
    goto LABEL_244;
  }
  int v141 = *v48;
  if (!*v48)
  {
    uint64_t v230 = *((void *)v5 + 306);
    if (os_log_type_enabled(v230, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "prepare_update";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&buf[20] = v48;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "update_instances";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&unsigned char buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3669;
      BOOL v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_480;
    }
    goto LABEL_483;
  }
  uint64_t v10 = *((void *)v5 + 306);
  if (v141 >= 10001)
  {
    if (!os_log_type_enabled(*((os_log_t *)v5 + 306), OS_LOG_TYPE_FAULT)) {
      goto LABEL_483;
    }
    *(_DWORD *)int buf = 136447490;
    *(void *)&uint8_t buf[4] = "prepare_update";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v141;
    *(_WORD *)&unsigned char buf[18] = 2048;
    *(void *)&buf[20] = v48;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = "update_instances";
    *(_WORD *)&unsigned char buf[38] = 2080;
    *(void *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&unsigned char buf[48] = 1024;
    *(_DWORD *)&buf[50] = 3669;
    BOOL v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_474;
  }
  if (os_log_type_enabled(*((os_log_t *)v5 + 306), OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136447490;
    *(void *)&uint8_t buf[4] = "prepare_update";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v141;
    *(_WORD *)&unsigned char buf[18] = 2048;
    *(void *)&buf[20] = v48;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = "update_instances";
    *(_WORD *)&unsigned char buf[38] = 2080;
    *(void *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&unsigned char buf[48] = 1024;
    *(_DWORD *)&buf[50] = 3669;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    int v141 = *v48;
  }
  int *v48 = v141 - 1;
  if (v141 == 1)
  {
    int v144 = *((void *)v5 + 306);
    if (os_log_type_enabled(v144, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136447234;
      *(void *)&uint8_t buf[4] = "prepare_update";
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v48;
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&unsigned char buf[24] = "update_instances";
      *(_WORD *)&uint8_t buf[32] = 2080;
      *(void *)&buf[34] = "srp-mdns-proxy.c";
      *(_WORD *)&buf[42] = 1024;
      *(_DWORD *)&buf[44] = 3669;
      _os_log_impl((void *)&_mh_execute_header, v144, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
    }
    ++adv_instance_vec_finalized;
    adv_instance_vec_finalize((uint64_t)v48);
    if (!v4) {
      return;
    }
LABEL_245:
    int v142 = *v4;
    if (*v4)
    {
      uint64_t v10 = *((void *)v5 + 306);
      if (v142 < 10001)
      {
        if (os_log_type_enabled(*((os_log_t *)v5 + 306), OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447490;
          *(void *)&uint8_t buf[4] = "prepare_update";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v142;
          *(_WORD *)&unsigned char buf[18] = 2048;
          *(void *)&buf[20] = v4;
          *(_WORD *)&buf[28] = 2080;
          *(void *)&buf[30] = "update";
          *(_WORD *)&unsigned char buf[38] = 2080;
          *(void *)&buf[40] = "srp-mdns-proxy.c";
          *(_WORD *)&unsigned char buf[48] = 1024;
          *(_DWORD *)&buf[50] = 3673;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          int v142 = *v4;
        }
        int *v4 = v142 - 1;
        if (v142 == 1)
        {
          uint64_t v143 = *((void *)v5 + 306);
          if (os_log_type_enabled(v143, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136447234;
            *(void *)&uint8_t buf[4] = "prepare_update";
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(void *)&buf[14] = v4;
            *(_WORD *)&unsigned char buf[22] = 2080;
            *(void *)&unsigned char buf[24] = "update";
            *(_WORD *)&uint8_t buf[32] = 2080;
            *(void *)&buf[34] = "srp-mdns-proxy.c";
            *(_WORD *)&buf[42] = 1024;
            *(_DWORD *)&buf[44] = 3673;
            _os_log_impl((void *)&_mh_execute_header, v143, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          }
          ++adv_update_finalized;
          adv_update_finalize((uint64_t)v4);
        }
        return;
      }
      if (!os_log_type_enabled(*((os_log_t *)v5 + 306), OS_LOG_TYPE_FAULT)) {
        goto LABEL_483;
      }
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "prepare_update";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v142;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&buf[20] = v244;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "update";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&unsigned char buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3673;
      BOOL v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      uint64_t v10 = *((void *)v5 + 306);
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_FAULT)) {
        goto LABEL_483;
      }
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "prepare_update";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&buf[20] = v244;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "update";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&unsigned char buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3673;
      BOOL v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
LABEL_474:
    int v225 = buf;
    uint64_t v226 = v10;
    goto LABEL_482;
  }
LABEL_244:
  if (v4) {
    goto LABEL_245;
  }
}

_DWORD *adv_record_create_(__int16 a1, unsigned int a2, const void *a3, _DWORD *a4, int a5)
{
  __int16 v8 = a2;
  size_t v10 = a2;
  BOOL v11 = malloc_type_calloc(1uLL, a2 + 55, 0xB9A43D48uLL);
  if (!v11)
  {
    unsigned int v20 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      int v27 = 136446210;
      uint64_t v28 = "adv_record_create_";
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "%{public}s: no memory for new_record", (uint8_t *)&v27, 0xCu);
    }
    return 0;
  }
  int v12 = v11;
  uint64_t v13 = malloc_type_malloc(v10, 0xF75754B5uLL);
  *((void *)v12 + 5) = v13;
  if (!v13)
  {
    uint64_t v21 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      int v27 = 136446210;
      uint64_t v28 = "adv_record_create_";
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%{public}s: no memory for new_record->rdata", (uint8_t *)&v27, 0xCu);
    }
    free(v12);
    return 0;
  }
  *((void *)v12 + 2) = a4;
  uint64_t v14 = global_os_log;
  if (a4)
  {
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v15 = *a4;
      int v27 = 136447490;
      uint64_t v28 = "adv_record_create_";
      __int16 v29 = 1024;
      int v30 = v15;
      __int16 v31 = 2048;
      int v32 = a4;
      __int16 v33 = 2080;
      int v34 = "host";
      __int16 v35 = 2080;
      uint64_t v36 = "srp-mdns-proxy.c";
      __int16 v37 = 1024;
      int v38 = a5;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v27, 0x36u);
    }
    int v16 = *a4;
    if (*a4)
    {
      int v17 = v16 + 1;
      *a4 = v16 + 1;
      if (v16 + 1 > 10000)
      {
        uint64_t v18 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_25;
        }
        int v27 = 136447490;
        uint64_t v28 = "adv_record_create_";
        __int16 v29 = 1024;
        int v30 = v17;
        __int16 v31 = 2048;
        int v32 = a4;
        __int16 v33 = 2080;
        int v34 = "host";
        __int16 v35 = 2080;
        uint64_t v36 = "srp-mdns-proxy.c";
        __int16 v37 = 1024;
        int v38 = a5;
        int v19 = v18;
        goto LABEL_24;
      }
    }
    else
    {
      ++adv_host_created;
      *a4 = 1;
    }
    uint64_t v13 = (void *)*((void *)v12 + 5);
    uint64_t v14 = global_os_log;
  }
  *((_WORD *)v12 + 24) = a1;
  *((_WORD *)v12 + 25) = v8;
  memcpy(v13, a3, v10);
  if (os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
  {
    int v22 = *v12;
    int v27 = 136447490;
    uint64_t v28 = "adv_record_create_";
    __int16 v29 = 1024;
    int v30 = v22;
    __int16 v31 = 2048;
    int v32 = v12;
    __int16 v33 = 2080;
    int v34 = "new_record";
    __int16 v35 = 2080;
    uint64_t v36 = "srp-mdns-proxy.c";
    __int16 v37 = 1024;
    int v38 = a5;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v27, 0x36u);
  }
  int v23 = *v12;
  if (*v12)
  {
    int v24 = v23 + 1;
    _DWORD *v12 = v23 + 1;
    if (v23 + 1 >= 10001)
    {
      uint64_t v25 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_25;
      }
      int v27 = 136447490;
      uint64_t v28 = "adv_record_create_";
      __int16 v29 = 1024;
      int v30 = v24;
      __int16 v31 = 2048;
      int v32 = v12;
      __int16 v33 = 2080;
      int v34 = "new_record";
      __int16 v35 = 2080;
      uint64_t v36 = "srp-mdns-proxy.c";
      __int16 v37 = 1024;
      int v38 = a5;
      int v19 = v25;
LABEL_24:
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v27, 0x36u);
LABEL_25:
      abort();
    }
  }
  else
  {
    ++adv_record_created;
    _DWORD *v12 = 1;
  }
  return v12;
}

void start_host_update(void *a1)
{
  uint64_t v2 = a1[6];
  if (!v2)
  {
    size_t v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      uint64_t v6 = a1[8];
      *(_DWORD *)int buf = 136446723;
      *(void *)&uint8_t buf[4] = "start_host_update";
      *(_WORD *)&unsigned char buf[12] = 2160;
      *(void *)&buf[14] = 1752392040;
      *(_WORD *)&unsigned char buf[22] = 2081;
      *(void *)&unsigned char buf[24] = v6;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "%{public}s: start_host_update: no work to do for host %{private, mask.hash}s", buf, 0x20u);
    }
    return;
  }
  uint64_t v3 = *(void *)(v2 + 16);
  if (v3) {
    BOOL v4 = *(unsigned __int8 *)(v3 + 103) != 0;
  }
  else {
    BOOL v4 = 0;
  }
  *(_DWORD *)(v2 + 96) = 0;
  uint64_t v7 = *(void *)(v2 + 40);
  if (v7 && *(int *)(v7 + 4) >= 1)
  {
    uint64_t v8 = 0;
    do
    {
      uint64_t v9 = *(void *)(*(void *)(v7 + 8) + 8 * v8);
      if (v9)
      {
        if ((register_host_record((uint64_t)a1, v9, v4) & 1) == 0)
        {
          update_failed(v2, 2u, 1);
          return;
        }
        if (!v4) {
          ++*(_DWORD *)(v2 + 96);
        }
      }
      ++v8;
      uint64_t v7 = *(void *)(v2 + 40);
    }
    while (v8 < *(int *)(v7 + 4));
  }
  uint64_t v10 = a1[12];
  if (v10 && *(int *)(v10 + 4) >= 1)
  {
    for (uint64_t i = 0; i < *(int *)(v10 + 4); ++i)
    {
      uint64_t v12 = *(void *)(v2 + 32);
      if (v12) {
        uint64_t v12 = *(void *)(*(void *)(v12 + 8) + 8 * i);
      }
      if (!v12)
      {
        uint64_t v13 = *(void *)(v10 + 8);
        uint64_t v14 = *(void *)(v13 + 8 * i);
        if (v14)
        {
          if (!*(void *)(v14 + 8))
          {
            *(void *)(v14 + 32) = v2;
            int v15 = *(int **)(*(void *)(v13 + 8 * i) + 32);
            if (v15)
            {
              int v16 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                int v17 = *v15;
                *(_DWORD *)int buf = 136447490;
                *(void *)&uint8_t buf[4] = "start_host_update";
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = v17;
                *(_WORD *)&unsigned char buf[18] = 2048;
                *(void *)&buf[20] = v15;
                *(_WORD *)&buf[28] = 2080;
                *(void *)&buf[30] = "host->addresses->vec[i]->update";
                *(_WORD *)&unsigned char buf[38] = 2080;
                *(void *)&buf[40] = "srp-mdns-proxy.c";
                *(_WORD *)&unsigned char buf[48] = 1024;
                *(_DWORD *)&buf[50] = 3007;
                _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                int v15 = *(int **)(*(void *)(*(void *)(a1[12] + 8) + 8 * i) + 32);
              }
              int v18 = *v15;
              if (!*v15)
              {
                ++adv_update_created;
                int v18 = *v15;
              }
              int v19 = v18 + 1;
              *int v15 = v18 + 1;
              if (v18 + 1 >= 10001)
              {
                uint64_t v26 = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                {
                  *(_DWORD *)int buf = 136447490;
                  *(void *)&uint8_t buf[4] = "start_host_update";
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v19;
                  *(_WORD *)&unsigned char buf[18] = 2048;
                  *(void *)&buf[20] = v15;
                  *(_WORD *)&buf[28] = 2080;
                  *(void *)&buf[30] = "host->addresses->vec[i]->update";
                  *(_WORD *)&unsigned char buf[38] = 2080;
                  *(void *)&buf[40] = "srp-mdns-proxy.c";
                  *(_WORD *)&unsigned char buf[48] = 1024;
                  *(_DWORD *)&buf[50] = 3007;
                  int v27 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
                  goto LABEL_183;
                }
LABEL_185:
                abort();
              }
            }
            if ((register_host_record((uint64_t)a1, v14, v4) & 1) == 0) {
              goto LABEL_161;
            }
            if (!v4) {
              ++*(_DWORD *)(v2 + 96);
            }
          }
        }
      }
      uint64_t v10 = a1[12];
    }
  }
  uint64_t v20 = *(void *)(v2 + 48);
  if (v20)
  {
    if ((register_host_record((uint64_t)a1, v20, v4) & 1) == 0) {
      goto LABEL_161;
    }
    if (!v4) {
      ++*(_DWORD *)(v2 + 96);
    }
    if (*(void *)(v2 + 48)) {
      goto LABEL_196;
    }
  }
  uint64_t v21 = (int *)a1[13];
  if (!v21 || *((void *)v21 + 3) == *(void *)(a1[1] + 16) && *((void *)v21 + 1)) {
    goto LABEL_196;
  }
  *(void *)(v2 + 48) = v21;
  int v22 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v23 = *v21;
    *(_DWORD *)int buf = 136447490;
    *(void *)&uint8_t buf[4] = "start_host_update";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v23;
    *(_WORD *)&unsigned char buf[18] = 2048;
    *(void *)&buf[20] = v21;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = "update->key";
    *(_WORD *)&unsigned char buf[38] = 2080;
    *(void *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&unsigned char buf[48] = 1024;
    *(_DWORD *)&buf[50] = 3033;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    uint64_t v21 = *(int **)(v2 + 48);
  }
  int v24 = *v21;
  if (*v21)
  {
    int v25 = v24 + 1;
    *uint64_t v21 = v24 + 1;
    if (v24 + 1 >= 10001)
    {
      uint64_t v26 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "start_host_update";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v25;
        *(_WORD *)&unsigned char buf[18] = 2048;
        *(void *)&buf[20] = v21;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "update->key";
        *(_WORD *)&unsigned char buf[38] = 2080;
        *(void *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&unsigned char buf[48] = 1024;
        *(_DWORD *)&buf[50] = 3033;
        int v27 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        goto LABEL_183;
      }
      goto LABEL_185;
    }
  }
  else
  {
    ++adv_record_created;
    *uint64_t v21 = 1;
  }
  uint64_t v28 = (int *)a1[13];
  if (v28)
  {
    int v29 = *v28;
    if (!*v28)
    {
      uint64_t v26 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_185;
      }
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "start_host_update";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = 0;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&buf[20] = v28;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "host->key_record";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&unsigned char buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3034;
      int v27 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_183:
      int v38 = v26;
      goto LABEL_184;
    }
    int v30 = global_os_log;
    if (v29 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_185;
      }
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "start_host_update";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v29;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&buf[20] = v28;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "host->key_record";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&unsigned char buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3034;
      int v27 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      int v38 = v30;
      goto LABEL_184;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "start_host_update";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v29;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&buf[20] = v28;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "host->key_record";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&unsigned char buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3034;
      _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      uint64_t v28 = (int *)a1[13];
      int v29 = *v28;
    }
    *uint64_t v28 = v29 - 1;
    if (v29 == 1)
    {
      __int16 v31 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136447234;
        *(void *)&uint8_t buf[4] = "start_host_update";
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v28;
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&unsigned char buf[24] = "host->key_record";
        *(_WORD *)&uint8_t buf[32] = 2080;
        *(void *)&buf[34] = "srp-mdns-proxy.c";
        *(_WORD *)&buf[42] = 1024;
        *(_DWORD *)&buf[44] = 3034;
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        uint64_t v28 = (int *)a1[13];
      }
      ++adv_record_finalized;
      adv_record_finalize((uint64_t)v28);
    }
  }
  a1[13] = 0;
  uint64_t v32 = *(void *)(v2 + 48);
  *(void *)(v32 + 8) = 0;
  *(void *)(v32 + 32) = v2;
  __int16 v33 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v34 = *(_DWORD *)v2;
    *(_DWORD *)int buf = 136447490;
    *(void *)&uint8_t buf[4] = "start_host_update";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v34;
    *(_WORD *)&unsigned char buf[18] = 2048;
    *(void *)&buf[20] = v2;
    *(_WORD *)&buf[28] = 2080;
    *(void *)&buf[30] = "update";
    *(_WORD *)&unsigned char buf[38] = 2080;
    *(void *)&buf[40] = "srp-mdns-proxy.c";
    *(_WORD *)&unsigned char buf[48] = 1024;
    *(_DWORD *)&buf[50] = 3038;
    _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  int v35 = *(_DWORD *)v2;
  if (*(_DWORD *)v2)
  {
    int v36 = v35 + 1;
    *(_DWORD *)uint64_t v2 = v35 + 1;
    if (v35 + 1 >= 10001)
    {
      uint64_t v37 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_185;
      }
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "start_host_update";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v36;
      *(_WORD *)&unsigned char buf[18] = 2048;
      *(void *)&buf[20] = v2;
      *(_WORD *)&buf[28] = 2080;
      *(void *)&buf[30] = "update";
      *(_WORD *)&unsigned char buf[38] = 2080;
      *(void *)&buf[40] = "srp-mdns-proxy.c";
      *(_WORD *)&unsigned char buf[48] = 1024;
      *(_DWORD *)&buf[50] = 3038;
      int v27 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      int v38 = v37;
      goto LABEL_184;
    }
  }
  else
  {
    ++adv_update_created;
    *(_DWORD *)uint64_t v2 = 1;
  }
  if ((register_host_record((uint64_t)a1, *(void *)(v2 + 48), v4) & 1) == 0) {
    goto LABEL_161;
  }
  if (v4)
  {
LABEL_196:
    if (*(_DWORD *)(v2 + 96)) {
      goto LABEL_70;
    }
  }
  else
  {
    int v77 = *(_DWORD *)(v2 + 96) + 1;
    *(_DWORD *)(v2 + 96) = v77;
    if (v77) {
      goto LABEL_70;
    }
  }
  uint64_t v78 = *(void *)(v2 + 48);
  if (!v78)
  {
    uint64_t v78 = a1[13];
    if (!v78) {
      goto LABEL_70;
    }
  }
  uint64_t v79 = *(void *)(v78 + 8);
  if (!v79)
  {
    if ((register_host_record((uint64_t)a1, v78, v4) & 1) == 0) {
      goto LABEL_161;
    }
    if (!v4) {
      ++*(_DWORD *)(v2 + 96);
    }
    goto LABEL_70;
  }
  if (v4) {
    goto LABEL_70;
  }
  uint64_t v80 = *(void *)(v78 + 16);
  if (!v80)
  {
    uint64_t v87 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_70;
    }
    *(_DWORD *)int buf = 136446722;
    *(void *)&uint8_t buf[4] = "update_host_tsr";
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(void *)&buf[14] = 0;
    *(_WORD *)&unsigned char buf[22] = 2048;
    *(void *)&unsigned char buf[24] = v79;
    int v88 = "%{public}s: record->host[%p], record->rref[%p] when we update host TSR.";
    uint64_t v89 = v87;
    os_log_type_t v90 = OS_LOG_TYPE_ERROR;
    uint32_t v91 = 32;
    goto LABEL_174;
  }
  uint64_t v81 = *(void *)(*(void *)(v80 + 8) + 16);
  if (!v81)
  {
    uint64_t v93 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_70;
    }
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "update_host_tsr";
    int v88 = "%{public}s: shared_txn is NULL when we update host TSR.";
LABEL_173:
    uint64_t v89 = v93;
    os_log_type_t v90 = OS_LOG_TYPE_ERROR;
    uint32_t v91 = 12;
LABEL_174:
    _os_log_impl((void *)&_mh_execute_header, v89, v90, v88, buf, v91);
    goto LABEL_70;
  }
  if (!*(void *)(v81 + 8))
  {
    uint64_t v93 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_70;
    }
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "update_host_tsr";
    int v88 = "%{public}s: shared_txn->sdref is NULL when we update host TSR.";
    goto LABEL_173;
  }
  ++saref_created;
  uint64_t v82 = malloc_type_calloc(1uLL, 0x30uLL, 0xF1748037uLL);
  if (!v82) {
    __break(1u);
  }
  uint64_t v83 = (uint64_t)v82;
  uint64_t v84 = *(void *)(v2 + 16);
  if (v84 && (uint64_t v85 = *(void *)(v84 + 32)) != 0 && *(void *)(v85 + 72))
  {
    *(void *)int buf = 0;
    *(void *)&buf[8] = 0;
    clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)buf);
    unsigned int v86 = *(_DWORD *)buf - *(void *)(*(void *)(*(void *)(v2 + 16) + 32) + 72);
    srp_format_time_offset(v104, v86);
  }
  else
  {
    unsigned int v86 = 0;
    *(_DWORD *)int v104 = 7827310;
  }
  if (__isPlatformVersionAtLeast(2, 18, 0, 0))
  {
    int v94 = *(_DWORD *)(*(void *)(v78 + 16) + 184);
    *(unsigned char *)(v83 + 12) = 1;
    *(_DWORD *)(v83 + 4) = v94;
  }
  *(unsigned char *)(v83 + 13) = 1;
  *(_DWORD *)(v83 + 8) = v86;
  int updated = DNSServiceUpdateRecordInternal(*(void *)(v81 + 8), *(void *)(v78 + 8), 0, 0, v83);
  DNSServiceAttributeDeallocate((DNSServiceAttributeRef)v83);
  uint64_t v96 = global_os_log;
  BOOL v97 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (updated)
  {
    if (!v97) {
      goto LABEL_70;
    }
    uint64_t v98 = *(void *)(v78 + 8);
    *(_DWORD *)int buf = 136446978;
    *(void *)&uint8_t buf[4] = "update_host_tsr";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = updated;
    *(_WORD *)&unsigned char buf[18] = 2048;
    *(void *)&buf[20] = v78;
    *(_WORD *)&buf[28] = 2048;
    *(void *)&buf[30] = v98;
    int v88 = "%{public}s: DNSServiceUpdateRecordWithAttribute for host tsr failed: %d (record %p rref %p)";
    uint64_t v89 = v96;
    os_log_type_t v90 = OS_LOG_TYPE_DEFAULT;
    uint32_t v91 = 38;
    goto LABEL_174;
  }
  if (v97)
  {
    uint64_t v99 = *(void *)(v78 + 16);
    if (v99) {
      uint64_t v100 = *(const char **)(v99 + 56);
    }
    else {
      uint64_t v100 = "<null>";
    }
    uint64_t v101 = *(void *)(v78 + 8);
    *(_DWORD *)int buf = 136447491;
    *(void *)&uint8_t buf[4] = "update_host_tsr";
    *(_WORD *)&unsigned char buf[12] = 2160;
    *(void *)&buf[14] = 1752392040;
    *(_WORD *)&unsigned char buf[22] = 2081;
    *(void *)&unsigned char buf[24] = v100;
    *(_WORD *)&uint8_t buf[32] = 2082;
    *(void *)&buf[34] = v104;
    *(_WORD *)&buf[42] = 2048;
    *(void *)&buf[44] = v78;
    *(_WORD *)&buf[52] = 2048;
    uint64_t v103 = v101;
    int v88 = "%{public}s: DNSServiceUpdateRecord TSR for %{private, mask.hash}s set to %{public}s (record %p rref %p)";
    uint64_t v89 = v96;
    os_log_type_t v90 = OS_LOG_TYPE_DEFAULT;
    uint32_t v91 = 62;
    goto LABEL_174;
  }
LABEL_70:
  if (!a1[14]) {
    goto LABEL_136;
  }
  uint64_t v39 = *(void *)(v2 + 80);
  if (v39 && *(int *)(v39 + 4) >= 1)
  {
    uint64_t v40 = 0;
    do
    {
      int v41 = *(_DWORD **)(*(void *)(v39 + 8) + 8 * v40);
      if (v41)
      {
        if (!register_instance(v41)) {
          goto LABEL_161;
        }
        uint64_t v39 = *(void *)(v2 + 80);
      }
      ++v40;
    }
    while (v40 < *(int *)(v39 + 4));
  }
  uint64_t v42 = *(void *)(v2 + 72);
  if (v42 && *(int *)(v42 + 4) >= 1)
  {
    for (uint64_t j = 0; j < *(int *)(v42 + 4); ++j)
    {
      uint64_t v44 = *(void *)(*(void *)(v42 + 8) + 8 * j);
      if (v44)
      {
        uint64_t v45 = *(void *)(v44 + 8);
        if (!v45) {
          goto LABEL_96;
        }
        if (!*(void *)(v45 + 8)) {
          goto LABEL_94;
        }
        uint64_t v46 = *(void *)(v44 + 16);
        if (v46 != *(void *)(a1[1] + 16))
        {
          double v47 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v48 = *(void *)(v44 + 48);
            *(_DWORD *)int buf = 136447235;
            *(void *)&uint8_t buf[4] = "start_host_update";
            *(_WORD *)&unsigned char buf[12] = 2160;
            *(void *)&buf[14] = 1752392040;
            *(_WORD *)&unsigned char buf[22] = 2081;
            *(void *)&unsigned char buf[24] = v48;
            *(_WORD *)&uint8_t buf[32] = 2048;
            *(void *)&buf[34] = v44;
            *(_WORD *)&buf[42] = 2048;
            *(void *)&buf[44] = v46;
            _os_log_impl((void *)&_mh_execute_header, v47, OS_LOG_TYPE_DEFAULT, "%{public}s: instance %{private, mask.hash}s (%p) shared connection (%lx) is stale, re-registering", buf, 0x34u);
            uint64_t v45 = *(void *)(v44 + 8);
          }
          *(void *)(v45 + 8) = 0;
          ioloop_dnssd_txn_cancel(v45);
          ioloop_dnssd_txn_release_(*(int **)(v44 + 8), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 3114);
          *(void *)(v44 + 8) = 0;
          goto LABEL_96;
        }
        if (!update_instance_tsr(v44, 0))
        {
          uint64_t v49 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v50 = *(void *)(v44 + 48);
            *(_DWORD *)int buf = 136446979;
            *(void *)&uint8_t buf[4] = "start_host_update";
            *(_WORD *)&unsigned char buf[12] = 2160;
            *(void *)&buf[14] = 1752392040;
            *(_WORD *)&unsigned char buf[22] = 2081;
            *(void *)&unsigned char buf[24] = v50;
            *(_WORD *)&uint8_t buf[32] = 2048;
            *(void *)&buf[34] = v44;
            _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "%{public}s: instance %{private, mask.hash}s (%p) tsr update failed, re-registering", buf, 0x2Au);
          }
          uint64_t v51 = *(void *)(v44 + 8);
          if (v51)
          {
            ioloop_dnssd_txn_cancel(v51);
            ioloop_dnssd_txn_release_(*(int **)(v44 + 8), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 3114);
            *(void *)(v44 + 8) = 0;
          }
LABEL_94:
          uint64_t v52 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v53 = *(void *)(v44 + 48);
            *(_DWORD *)int buf = 136446979;
            *(void *)&uint8_t buf[4] = "start_host_update";
            *(_WORD *)&unsigned char buf[12] = 2160;
            *(void *)&buf[14] = 1752392040;
            *(_WORD *)&unsigned char buf[22] = 2081;
            *(void *)&unsigned char buf[24] = v53;
            *(_WORD *)&uint8_t buf[32] = 2048;
            *(void *)&buf[34] = v44;
            _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "%{public}s: %{private, mask.hash}s (%p): failed to update TSR, re-registering", buf, 0x2Au);
          }
LABEL_96:
          if ((register_instance(*(_DWORD **)(*(void *)(*(void *)(v2 + 72) + 8) + 8 * j)) & 1) == 0) {
            goto LABEL_161;
          }
          goto LABEL_97;
        }
        *(void *)(v44 + 96) = *(void *)(*(void *)(v2 + 16) + 32);
      }
LABEL_97:
      uint64_t v42 = *(void *)(v2 + 72);
    }
  }
  uint64_t v54 = *(void *)(v2 + 56);
  uint64_t v55 = a1[14];
  if (v54)
  {
    int v56 = *(_DWORD *)(v54 + 4);
    int v57 = *(_DWORD *)(v55 + 4);
    if (v56 != v57)
    {
      uint64_t v61 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_161;
      }
      *(_DWORD *)int buf = 136446722;
      *(void *)&uint8_t buf[4] = "start_host_update";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v56;
      *(_WORD *)&unsigned char buf[18] = 1024;
      *(_DWORD *)&buf[20] = v57;
      uint64_t v62 = "%{public}s: update instance count %d differs from host instance count %d";
LABEL_106:
      uint64_t v63 = v61;
      os_log_type_t v64 = OS_LOG_TYPE_FAULT;
      uint32_t v65 = 24;
      goto LABEL_107;
    }
  }
  uint64_t v58 = *(void *)(v2 + 64);
  if (v58)
  {
    int v59 = *(_DWORD *)(v58 + 4);
    int v60 = *(_DWORD *)(v55 + 4);
    if (v59 != v60)
    {
      uint64_t v61 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_161;
      }
      *(_DWORD *)int buf = 136446722;
      *(void *)&uint8_t buf[4] = "start_host_update";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v59;
      *(_WORD *)&unsigned char buf[18] = 1024;
      *(_DWORD *)&buf[20] = v60;
      uint64_t v62 = "%{public}s: delete instance count %d differs from host instance count %d";
      goto LABEL_106;
    }
  }
  else
  {
    int v59 = *(_DWORD *)(v55 + 4);
  }
  if (v59 < 1)
  {
LABEL_136:
    if (!*(_DWORD *)(v2 + 88) && !*(_DWORD *)(v2 + 96))
    {
      long long v76 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "start_host_update";
        _os_log_impl((void *)&_mh_execute_header, v76, OS_LOG_TYPE_DEFAULT, "%{public}s: no service or record updates, so we're finished.", buf, 0xCu);
      }
      srp_mdns_update_finished(v2);
    }
    return;
  }
  uint64_t v66 = 0;
  while (1)
  {
    uint64_t v67 = *(void *)(*(void *)(*(void *)(v2 + 56) + 8) + 8 * v66);
    if (!v67 || *(unsigned char *)(v67 + 116)) {
      goto LABEL_135;
    }
    uint64_t v68 = *(void *)(*(void *)(v55 + 8) + 8 * v66);
    uint64_t v69 = *(void *)(v68 + 8);
    if (!v69) {
      goto LABEL_134;
    }
    if (!*(void *)(v69 + 8)) {
      goto LABEL_133;
    }
    uint64_t v70 = a1[1];
    if (!v70
      || *(void *)(v68 + 16) != *(void *)(v70 + 16)
      || *(_DWORD *)(v67 + 64) != *(_DWORD *)(v68 + 64)
      || !*(_WORD *)(v67 + 80)
      || !memcmp(*(const void **)(v67 + 72), *(const void **)(v68 + 72), *(unsigned __int16 *)(v67 + 80)))
    {
      goto LABEL_133;
    }
    if (!update_instance_tsr(v68, v67)) {
      break;
    }
    *(void *)(v68 + 96) = *(void *)(*(void *)(v2 + 16) + 32);
    uint64_t v71 = *(void *)(*(void *)(v2 + 56) + 8);
    unsigned int v72 = *(int **)(v71 + 8 * v66);
    if (v72)
    {
      int v73 = *v72;
      if (!*v72)
      {
        uint64_t v26 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_185;
        }
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "start_host_update";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 0;
        *(_WORD *)&unsigned char buf[18] = 2048;
        *(void *)&buf[20] = v72;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "update->update_instances->vec[i]";
        *(_WORD *)&unsigned char buf[38] = 2080;
        *(void *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&unsigned char buf[48] = 1024;
        *(_DWORD *)&buf[50] = 3165;
        int v27 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_183;
      }
      uint64_t v74 = global_os_log;
      if (v73 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_185;
        }
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "start_host_update";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v73;
        *(_WORD *)&unsigned char buf[18] = 2048;
        *(void *)&buf[20] = v72;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "update->update_instances->vec[i]";
        *(_WORD *)&unsigned char buf[38] = 2080;
        *(void *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&unsigned char buf[48] = 1024;
        *(_DWORD *)&buf[50] = 3165;
        int v27 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        int v38 = v74;
LABEL_184:
        _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_FAULT, v27, buf, 0x36u);
        goto LABEL_185;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "start_host_update";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v73;
        *(_WORD *)&unsigned char buf[18] = 2048;
        *(void *)&buf[20] = v72;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "update->update_instances->vec[i]";
        *(_WORD *)&unsigned char buf[38] = 2080;
        *(void *)&buf[40] = "srp-mdns-proxy.c";
        *(_WORD *)&unsigned char buf[48] = 1024;
        *(_DWORD *)&buf[50] = 3165;
        _os_log_impl((void *)&_mh_execute_header, v74, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        uint64_t v71 = *(void *)(*(void *)(v2 + 56) + 8);
        unsigned int v72 = *(int **)(v71 + 8 * v66);
        int v73 = *v72;
      }
      *unsigned int v72 = v73 - 1;
      if (v73 == 1)
      {
        uint64_t v75 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447234;
          *(void *)&uint8_t buf[4] = "start_host_update";
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v72;
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&unsigned char buf[24] = "update->update_instances->vec[i]";
          *(_WORD *)&uint8_t buf[32] = 2080;
          *(void *)&buf[34] = "srp-mdns-proxy.c";
          *(_WORD *)&buf[42] = 1024;
          *(_DWORD *)&buf[44] = 3165;
          _os_log_impl((void *)&_mh_execute_header, v75, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          unsigned int v72 = *(int **)(*(void *)(*(void *)(v2 + 56) + 8) + 8 * v66);
        }
        ++adv_instance_finalized;
        adv_instance_finalize(v72);
        uint64_t v71 = *(void *)(*(void *)(v2 + 56) + 8);
      }
    }
    *(void *)(v71 + 8 * v66) = 0;
LABEL_135:
    ++v66;
    uint64_t v55 = a1[14];
    if (v66 >= *(int *)(v55 + 4)) {
      goto LABEL_136;
    }
  }
  if (*(void *)(v68 + 8))
  {
    uint64_t v69 = *(void *)(*(void *)(*(void *)(a1[14] + 8) + 8 * v66) + 8);
LABEL_133:
    ioloop_dnssd_txn_cancel(v69);
    ioloop_dnssd_txn_release_(*(int **)(*(void *)(*(void *)(a1[14] + 8) + 8 * v66) + 8), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 3175);
    *(void *)(*(void *)(*(void *)(a1[14] + 8) + 8 * v66) + 8) = 0;
  }
LABEL_134:
  if (register_instance(*(_DWORD **)(*(void *)(*(void *)(v2 + 56) + 8) + 8 * v66))) {
    goto LABEL_135;
  }
  uint64_t v92 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "start_host_update";
    uint64_t v62 = "%{public}s: register instance failed.";
    uint64_t v63 = v92;
    os_log_type_t v64 = OS_LOG_TYPE_DEFAULT;
    uint32_t v65 = 12;
LABEL_107:
    _os_log_impl((void *)&_mh_execute_header, v63, v64, v62, buf, v65);
  }
LABEL_161:
  update_failed(v2, 2u, 1);
}

uint64_t register_host_record(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v6 = (DNSRecordRef *)(a2 + 8);
  if (*(void *)(a2 + 8) && (a3 & 1) == 0) {
    srp_mdns_shared_record_remove(*(void *)(a1 + 8), a2);
  }
  if (!srp_mdns_shared_registration_txn_setup(*(void *)(a1 + 8))) {
    return 0;
  }
  uint64_t v7 = *(void *)(a1 + 8);
  uint64_t v8 = *(_DNSServiceRef_t **)(*(void *)(v7 + 16) + 8);
  int v9 = *(unsigned __int16 *)(a2 + 48);
  if (v9 == 28)
  {
    uint64_t v20 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_30;
    }
    if (a3) {
      uint64_t v21 = "skipping ";
    }
    else {
      uint64_t v21 = "";
    }
    int v22 = *(_DWORD *)(v7 + 248);
    uint64_t v23 = *(void *)(a1 + 64);
    int v24 = *(unsigned __int16 *)(a2 + 50);
    int v25 = *(unsigned __int8 **)(a2 + 40);
    int v26 = *v25;
    if ((v26 & 0xFE) == 0xFC)
    {
      int v27 = "ULA: ";
    }
    else if (v26 == 254 && (v25[1] & 0xC0) == 0x80)
    {
      int v27 = "LUA: ";
    }
    else if ((v26 & 0xE0) == 0x20)
    {
      int v27 = "GUA: ";
    }
    else
    {
      int v27 = "";
    }
    *(_DWORD *)int buf = 136451843;
    uint64_t v55 = "register_host_record";
    __int16 v56 = 2082;
    *(void *)int v57 = v21;
    *(_WORD *)&v57[8] = 2048;
    *(void *)&v57[10] = v8;
    *(_WORD *)&v57[18] = 2048;
    *(void *)&v57[20] = v6;
    *(_WORD *)&v57[28] = 1024;
    *(_DWORD *)&v57[30] = 16;
    *(_WORD *)&v57[34] = 1024;
    *(_DWORD *)&v57[36] = v22;
    *(_WORD *)uint64_t v58 = 2080;
    *(void *)&v58[2] = v23;
    __int16 v59 = 1024;
    int v60 = 28;
    __int16 v61 = 1024;
    int v62 = 1;
    __int16 v63 = 1024;
    int v64 = v24;
    __int16 v65 = 2082;
    uint64_t v66 = (uint64_t)v27;
    __int16 v67 = 2160;
    *(void *)uint64_t v68 = 1752392040;
    *(_WORD *)&v68[8] = 1041;
    *(_DWORD *)&v68[10] = 6;
    __int16 v69 = 2097;
    *(void *)uint64_t v70 = v25;
    *(_WORD *)&v70[8] = 2160;
    *(void *)&v70[10] = 1752392040;
    *(_WORD *)&v70[18] = 1042;
    *(_DWORD *)&v70[20] = 2;
    __int16 v71 = 2098;
    unsigned int v72 = v25 + 6;
    __int16 v73 = 2160;
    uint64_t v74 = 1752392040;
    __int16 v75 = 1041;
    int v76 = 8;
    __int16 v77 = 2097;
    uint64_t v78 = v25 + 8;
    __int16 v79 = 1024;
    int v80 = 4500;
    __int16 v81 = 2048;
    uint64_t v82 = register_host_record_completion;
    __int16 v83 = 2048;
    uint64_t v84 = a2;
    int v16 = "%{public}s: %{public}sDNSServiceRegisterRecord(%p %p %d %d %s %d %d %d {%{public}s%{private, mask.hash, srp:in"
          "6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} %d %p %p)";
    int v17 = v20;
    uint32_t v18 = 196;
  }
  else if (v9 == 1)
  {
    uint64_t v10 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_30;
    }
    int v11 = *(_DWORD *)(v7 + 248);
    uint64_t v12 = "";
    uint64_t v13 = *(void *)(a1 + 64);
    int v14 = *(unsigned __int16 *)(a2 + 50);
    if (a3) {
      uint64_t v12 = "skipping ";
    }
    uint64_t v15 = *(void *)(a2 + 40);
    *(_DWORD *)int buf = 136450051;
    uint64_t v55 = "register_host_record";
    __int16 v56 = 2082;
    *(void *)int v57 = v12;
    *(_WORD *)&v57[8] = 2048;
    *(void *)&v57[10] = v8;
    *(_WORD *)&v57[18] = 2048;
    *(void *)&v57[20] = v6;
    *(_WORD *)&v57[28] = 1024;
    *(_DWORD *)&v57[30] = 16;
    *(_WORD *)&v57[34] = 1024;
    *(_DWORD *)&v57[36] = v11;
    *(_WORD *)uint64_t v58 = 2080;
    *(void *)&v58[2] = v13;
    __int16 v59 = 1024;
    int v60 = 1;
    __int16 v61 = 1024;
    int v62 = 1;
    __int16 v63 = 1024;
    int v64 = v14;
    __int16 v65 = 2160;
    uint64_t v66 = 1752392040;
    __int16 v67 = 1041;
    *(_DWORD *)uint64_t v68 = 4;
    *(_WORD *)&v68[4] = 2097;
    *(void *)&v68[6] = v15;
    __int16 v69 = 1024;
    *(_DWORD *)uint64_t v70 = 4500;
    *(_WORD *)&v70[4] = 2048;
    *(void *)&v70[6] = register_host_record_completion;
    *(_WORD *)&v70[14] = 2048;
    *(void *)&v70[16] = a2;
    int v16 = "%{public}s: %{public}sDNSServiceRegisterRecord(%p %p %d %d %s %d %d %d %{private, mask.hash, network:in_addr}.4P %d %p %p)";
    int v17 = v10;
    uint32_t v18 = 134;
  }
  else
  {
    uint64_t v28 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_30;
    }
    int v29 = *(_DWORD *)(v7 + 248);
    int v30 = "";
    uint64_t v31 = *(void *)(a1 + 64);
    int v32 = *(unsigned __int16 *)(a2 + 50);
    if (a3) {
      int v30 = "skipping ";
    }
    uint64_t v33 = *(void *)(a2 + 40);
    *(_DWORD *)int buf = 136449538;
    uint64_t v55 = "register_host_record";
    __int16 v56 = 2082;
    *(void *)int v57 = v30;
    *(_WORD *)&v57[8] = 2048;
    *(void *)&v57[10] = v8;
    *(_WORD *)&v57[18] = 2048;
    *(void *)&v57[20] = v6;
    *(_WORD *)&v57[28] = 1024;
    *(_DWORD *)&v57[30] = 16;
    *(_WORD *)&v57[34] = 1024;
    *(_DWORD *)&v57[36] = v29;
    *(_WORD *)uint64_t v58 = 2080;
    *(void *)&v58[2] = v31;
    __int16 v59 = 1024;
    int v60 = v9;
    __int16 v61 = 1024;
    int v62 = 1;
    __int16 v63 = 1024;
    int v64 = v32;
    __int16 v65 = 2048;
    uint64_t v66 = v33;
    __int16 v67 = 1024;
    *(_DWORD *)uint64_t v68 = 4500;
    *(_WORD *)&v68[4] = 2048;
    *(void *)&v68[6] = register_host_record_completion;
    __int16 v69 = 2048;
    *(void *)uint64_t v70 = a2;
    int v16 = "%{public}s: %{public}sDNSServiceRegisterRecord(%p %p %d %d %s %d %d %d %p %d %p %p)";
    int v17 = v28;
    uint32_t v18 = 118;
  }
  _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, v16, buf, v18);
LABEL_30:
  if (a3) {
    return 1;
  }
  uint64_t v34 = *(void *)(a1 + 48);
  if (v34)
  {
    uint64_t v35 = *(void *)(v34 + 16);
    if (!v35 || (uint64_t v36 = *(void *)(v35 + 32)) == 0) {
      uint64_t v36 = 0;
    }
  }
  else
  {
    uint64_t v36 = *(void *)(a1 + 72);
  }
  uint64_t v37 = (DNSServiceAttribute *)srp_message_tsr_attribute_generate(v36, *(_DWORD *)(a1 + 184), (char *)v53 + 4);
  DNSServiceErrorType v38 = DNSServiceRegisterRecordWithAttribute(v8, v6, *(_DWORD *)(*(void *)(a1 + 8) + 248), *(void *)(a1 + 64), (const char *)*(unsigned __int16 *)(a2 + 48), *(_WORD *)(a2 + 50), *(void *)(a2 + 40), (uint16_t)v37, register_host_record_completion, a2, v53[0], (DNSServiceRegisterRecordReply)v53[1], v53[2]);
  DNSServiceAttributeDeallocate(v37);
  BOOL v19 = v38 == 0;
  if (v38)
  {
    if ((v38 + 65569) <= 0x1D && ((1 << (v38 + 33)) & 0x30000041) != 0)
    {
LABEL_42:
      uint64_t v40 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v41 = *(void *)(a1 + 56);
        uint64_t v42 = "defunct";
        *(_DWORD *)int buf = 136446978;
        uint64_t v55 = "register_host_record";
        __int16 v56 = 2082;
        if (v38 == -65563) {
          uint64_t v42 = "not running";
        }
        *(void *)int v57 = v41;
        *(_WORD *)&v57[8] = 2082;
        *(void *)&v57[10] = v42;
        *(_WORD *)&v57[18] = 2048;
        *(void *)&v57[20] = a2;
        _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "%{public}s: DNSServiceRegisterRecord failed on host %{public}s: %{public}s (record %p)", buf, 0x2Au);
      }
      service_disconnected(*(void *)(a1 + 8), *(void *)(*(void *)(a1 + 8) + 16));
      return v19;
    }
    if (v38 == 1)
    {
      uint64_t v50 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v55 = "register_host_record";
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_FAULT, "%{public}s: bogus error code 1", buf, 0xCu);
      }
      goto LABEL_42;
    }
    uint64_t v52 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136446722;
      uint64_t v55 = "register_host_record";
      __int16 v56 = 1024;
      *(_DWORD *)int v57 = v38;
      *(_WORD *)&v57[4] = 2048;
      *(void *)&unsigned char v57[6] = a2;
      _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "%{public}s: DNSServiceRegisterRecord failed: %d (record %p)", buf, 0x1Cu);
    }
  }
  else
  {
    int v43 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v44 = *(void *)(a1 + 56);
      uint64_t v45 = *(void *)(a2 + 8);
      *(_DWORD *)int buf = 136447491;
      uint64_t v55 = "register_host_record";
      __int16 v56 = 2160;
      *(void *)int v57 = 1752392040;
      *(_WORD *)&v57[8] = 2081;
      *(void *)&v57[10] = v44;
      *(_WORD *)&v57[18] = 2082;
      *(void *)&v57[20] = (char *)v53 + 4;
      *(_WORD *)&v57[28] = 2048;
      *(void *)&v57[30] = a2;
      *(_WORD *)&v57[38] = 2048;
      *(void *)uint64_t v58 = v45;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "%{public}s: DNSServiceRegisterRecord for %{private, mask.hash}s, TSR set to %{public}s (record %p rref %p)", buf, 0x3Eu);
      int v43 = global_os_log;
    }
    *(void *)(a2 + 24) = *(void *)(*(void *)(a1 + 8) + 16);
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEFAULT))
    {
      int v46 = *(_DWORD *)a2;
      *(_DWORD *)int buf = 136447490;
      uint64_t v55 = "register_host_record";
      __int16 v56 = 1024;
      *(_DWORD *)int v57 = v46;
      *(_WORD *)&v57[4] = 2048;
      *(void *)&unsigned char v57[6] = a2;
      *(_WORD *)&v57[14] = 2080;
      *(void *)&v57[16] = "record";
      *(_WORD *)&v57[24] = 2080;
      *(void *)&v57[26] = "srp-mdns-proxy.c";
      *(_WORD *)&v57[34] = 1024;
      *(_DWORD *)&v57[36] = 2793;
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    int v47 = *(_DWORD *)a2;
    if (*(_DWORD *)a2)
    {
      int v48 = v47 + 1;
      *(_DWORD *)a2 = v47 + 1;
      if (v47 + 1 >= 10001)
      {
        uint64_t v49 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)int buf = 136447490;
          uint64_t v55 = "register_host_record";
          __int16 v56 = 1024;
          *(_DWORD *)int v57 = v48;
          *(_WORD *)&v57[4] = 2048;
          *(void *)&unsigned char v57[6] = a2;
          *(_WORD *)&v57[14] = 2080;
          *(void *)&v57[16] = "record";
          *(_WORD *)&v57[24] = 2080;
          *(void *)&v57[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v57[34] = 1024;
          *(_DWORD *)&v57[36] = 2793;
          _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++adv_record_created;
      *(_DWORD *)a2 = 1;
    }
    if (*(void *)(a1 + 48)) {
      *(unsigned char *)(a2 + 52) = 1;
    }
  }
  return v19;
}

uint64_t register_instance(_DWORD *a1)
{
  uint64_t v2 = *(void *)(*((void *)a1 + 3) + 8);
  uint64_t result = srp_mdns_shared_registration_txn_setup(v2);
  if (result)
  {
    BOOL v4 = *(_DNSServiceRef_t **)(*(void *)(v2 + 16) + 8);
    DNSServiceRef sdRef = v4;
    size_t v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *((void *)a1 + 6);
      uint64_t v7 = (_DWORD *)*((void *)a1 + 7);
      if (*((unsigned char *)a1 + 119)) {
        uint64_t v8 = "skipping ";
      }
      else {
        uint64_t v8 = "";
      }
      uint64_t v9 = *(void *)(*((void *)a1 + 3) + 64);
      int v10 = a1[16];
      *(_DWORD *)int buf = 136448771;
      uint64_t v42 = "register_instance";
      __int16 v43 = 2082;
      *(void *)uint64_t v44 = v8;
      *(_WORD *)&v44[8] = 2048;
      *(void *)&v44[10] = v4;
      *(_WORD *)&v44[18] = 2160;
      *(void *)&v44[20] = 1752392040;
      *(_WORD *)&v44[28] = 2081;
      *(void *)&v44[30] = v6;
      *(_WORD *)&v44[38] = 2160;
      uint64_t v45 = 1752392040;
      __int16 v46 = 2081;
      int v47 = v7;
      __int16 v48 = 2160;
      uint64_t v49 = 1752392040;
      __int16 v50 = 2081;
      uint64_t v51 = v9;
      __int16 v52 = 1024;
      int v53 = v10;
      __int16 v54 = 2048;
      uint64_t v55 = a1;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}sDNSServiceRegister(%p, %{private, mask.hash}s, %{private, mask.hash}s, %{private, mask.hash}s, %d, %p)", buf, 0x6Cu);
    }
    uint64_t v11 = *((void *)a1 + 4);
    if (*((unsigned char *)a1 + 119))
    {
      uint64_t v12 = *(void *)(v11 + 16);
      if (v12) {
        *((void *)a1 + 12) = *(void *)(v12 + 32);
      }
      return 1;
    }
    if (v11)
    {
      uint64_t v13 = *(void *)(v11 + 16);
      if (!v13 || (uint64_t v14 = *(void *)(v13 + 32)) == 0) {
        uint64_t v14 = 0;
      }
    }
    else
    {
      uint64_t v14 = *((void *)a1 + 11);
    }
    uint64_t v15 = (DNSServiceAttribute *)srp_message_tsr_attribute_generate(v14, *(_DWORD *)(*((void *)a1 + 3) + 184), v40);
    if (__isPlatformVersionAtLeast(2, 18, 0, 0)) {
      DNSServiceFlags v16 = 18440;
    }
    else {
      DNSServiceFlags v16 = 16392;
    }
    DNSServiceErrorType v17 = DNSServiceRegisterWithAttribute(&sdRef, v16, *(_DWORD *)(v2 + 248), *((const char **)a1 + 6), *((const char **)a1 + 7), "local", *(const char **)(*((void *)a1 + 3) + 64), bswap32(*((unsigned __int16 *)a1 + 32)) >> 16, *((_WORD *)a1 + 40), *((const void **)a1 + 9), v15, (DNSServiceRegisterReply)register_instance_completion, a1);
    DNSServiceAttributeDeallocate(v15);
    if (v17)
    {
      if ((v17 + 65569) <= 0x1D && ((1 << (v17 + 33)) & 0x30000041) != 0)
      {
LABEL_24:
        BOOL v19 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v20 = "defunct";
          uint64_t v42 = "register_instance";
          *(_DWORD *)int buf = 136446722;
          if (v17 == -65563) {
            uint64_t v20 = "not running";
          }
          __int16 v43 = 2082;
          *(void *)uint64_t v44 = v20;
          *(_WORD *)&v44[8] = 2048;
          *(void *)&v44[10] = a1;
          _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%{public}s: DNSServiceRegister failed: %{public}s (instance %p)", buf, 0x20u);
        }
        service_disconnected(v2, *(void *)(v2 + 16));
        return 0;
      }
      if (v17 == 1)
      {
        uint64_t v31 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v42 = "register_instance";
          _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_FAULT, "%{public}s: bogus error code 1", buf, 0xCu);
        }
        goto LABEL_24;
      }
      uint64_t v37 = global_os_log;
      BOOL v38 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
      uint64_t result = 0;
      if (v38)
      {
        *(_DWORD *)int buf = 136446722;
        uint64_t v42 = "register_instance";
        __int16 v43 = 1024;
        *(_DWORD *)uint64_t v44 = v17;
        *(_WORD *)&v44[4] = 2048;
        *(void *)&v44[6] = a1;
        uint64_t v33 = "%{public}s: DNSServiceRegister failed: %d (instance %p)";
        uint64_t v34 = v37;
        os_log_type_t v35 = OS_LOG_TYPE_DEFAULT;
        uint32_t v36 = 28;
        goto LABEL_52;
      }
    }
    else
    {
      uint64_t v21 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v22 = *((void *)a1 + 6);
        uint64_t v23 = *(const char **)(*((void *)a1 + 3) + 56);
        if (!v23) {
          uint64_t v23 = "<null>";
        }
        *(_DWORD *)int buf = 136448003;
        uint64_t v42 = "register_instance";
        __int16 v43 = 2160;
        *(void *)uint64_t v44 = 1752392040;
        *(_WORD *)&v44[8] = 2081;
        *(void *)&v44[10] = v22;
        *(_WORD *)&v44[18] = 2160;
        *(void *)&v44[20] = 1752392040;
        *(_WORD *)&v44[28] = 2081;
        *(void *)&v44[30] = v23;
        *(_WORD *)&v44[38] = 2082;
        uint64_t v45 = (uint64_t)v40;
        __int16 v46 = 2048;
        int v47 = a1;
        __int16 v48 = 2048;
        uint64_t v49 = (uint64_t)sdRef;
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%{public}s: DNSServiceRegister, TSR for instance %{private, mask.hash}s host %{private, mask.hash}s set to %{public}s(instance %p sdref %p)", buf, 0x52u);
      }
      uint64_t v24 = *((void *)a1 + 4);
      if (v24)
      {
        ++*(_DWORD *)(v24 + 88);
        *((unsigned char *)a1 + 117) = 1;
      }
      int v25 = ioloop_dnssd_txn_add_subordinate_((uint64_t)sdRef, (uint64_t)a1, (uint64_t)adv_instance_context_release, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 2314);
      *((void *)a1 + 1) = v25;
      if (v25)
      {
        *((void *)a1 + 2) = *(void *)(v2 + 16);
        int v26 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v27 = *a1;
          *(_DWORD *)int buf = 136447490;
          uint64_t v42 = "register_instance";
          __int16 v43 = 1024;
          *(_DWORD *)uint64_t v44 = v27;
          *(_WORD *)&v44[4] = 2048;
          *(void *)&v44[6] = a1;
          *(_WORD *)&v44[14] = 2080;
          *(void *)&v44[16] = "instance";
          *(_WORD *)&v44[24] = 2080;
          *(void *)&v44[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v44[34] = 1024;
          *(_DWORD *)&v44[36] = 2320;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        int v28 = *a1;
        if (*a1)
        {
          int v29 = v28 + 1;
          *a1 = v28 + 1;
          if (v28 + 1 >= 10001)
          {
            int v30 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)int buf = 136447490;
              uint64_t v42 = "register_instance";
              __int16 v43 = 1024;
              *(_DWORD *)uint64_t v44 = v29;
              *(_WORD *)&v44[4] = 2048;
              *(void *)&v44[6] = a1;
              *(_WORD *)&v44[14] = 2080;
              *(void *)&v44[16] = "instance";
              *(_WORD *)&v44[24] = 2080;
              *(void *)&v44[26] = "srp-mdns-proxy.c";
              *(_WORD *)&v44[34] = 1024;
              *(_DWORD *)&v44[36] = 2320;
              _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            }
            abort();
          }
        }
        else
        {
          ++adv_instance_created;
          *a1 = 1;
        }
        return 1;
      }
      uint64_t v32 = global_os_log;
      uint64_t result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
      if (result)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v42 = "register_instance";
        uint64_t v33 = "%{public}s: no memory for instance transaction.";
        uint64_t v34 = v32;
        os_log_type_t v35 = OS_LOG_TYPE_ERROR;
        uint32_t v36 = 12;
LABEL_52:
        _os_log_impl((void *)&_mh_execute_header, v34, v35, v33, buf, v36);
        return 0;
      }
    }
  }
  return result;
}

BOOL update_instance_tsr(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)(a1 + 8);
  if (!v3)
  {
    uint64_t v12 = global_os_log;
    BOOL result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "update_instance_tsr";
    uint64_t v14 = "%{public}s: txn is NULL updating instance TSR.";
    goto LABEL_15;
  }
  uint64_t v4 = *(void *)(v3 + 8);
  if (!v4)
  {
    uint64_t v12 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
LABEL_16:
      int updated = 0;
      goto LABEL_17;
    }
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "update_instance_tsr";
    uint64_t v14 = "%{public}s: sdref is NULL when updating instance TSR.";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, v14, buf, 0xCu);
    goto LABEL_16;
  }
  if (!a2) {
    goto LABEL_7;
  }
  if (*(unsigned char *)(a1 + 119)
    || (int v32 = DNSServiceUpdateRecordInternal(v4, 0, *(unsigned __int16 *)(a2 + 80), *(const void **)(a2 + 72), 0)) == 0)
  {
    uint64_t v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(const char **)(a1 + 48);
      uint64_t v8 = *(void *)(a1 + 56);
      uint64_t v9 = *(void *)(*(void *)(a1 + 8) + 8);
      *(_DWORD *)int buf = 136447747;
      *(void *)&uint8_t buf[4] = "update_instance_tsr";
      *(_WORD *)&unsigned char buf[12] = 2160;
      *(void *)&buf[14] = 1752392040;
      __int16 v40 = 2081;
      uint64_t v41 = v7;
      __int16 v42 = 2160;
      *(void *)__int16 v43 = 1752392040;
      *(_WORD *)&v43[8] = 2081;
      *(void *)&v43[10] = v8;
      *(_WORD *)&v43[18] = 2048;
      *(void *)&v43[20] = a1;
      __int16 v44 = 2048;
      uint64_t v45 = v9;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: updated TXT record for %{private, mask.hash}s . %{private, mask.hash}s (instance %p sdref %p).", buf, 0x48u);
    }
LABEL_7:
    if (*(unsigned char *)(a1 + 119))
    {
      int v10 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *(const char **)(a1 + 48);
        *(_DWORD *)int buf = 136446979;
        *(void *)&uint8_t buf[4] = "update_instance_tsr";
        *(_WORD *)&unsigned char buf[12] = 2160;
        *(void *)&buf[14] = 1752392040;
        __int16 v40 = 2081;
        uint64_t v41 = v11;
        __int16 v42 = 2048;
        *(void *)__int16 v43 = a1;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: skipping DNSServiceUpdateRecord for instance %{private, mask.hash}s TSR (instance %p)", buf, 0x2Au);
        if (!a2) {
          goto LABEL_16;
        }
      }
      else if (!a2)
      {
        goto LABEL_16;
      }
    }
    else
    {
      ++saref_created;
      uint32_t v18 = malloc_type_calloc(1uLL, 0x30uLL, 0xF1748037uLL);
      if (!v18) {
        __break(1u);
      }
      uint64_t v19 = (uint64_t)v18;
      uint64_t v20 = *(void *)(a1 + 32);
      if (v20 && (uint64_t v21 = *(void *)(v20 + 16)) != 0 && (v22 = *(void *)(v21 + 32)) != 0 && *(void *)(v22 + 72))
      {
        *(void *)int buf = 0;
        *(void *)&buf[8] = 0;
        clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)buf);
        unsigned int v23 = *(_DWORD *)buf - *(void *)(*(void *)(*(void *)(*(void *)(a1 + 32) + 16) + 32) + 72);
        srp_format_time_offset(v38, v23);
      }
      else
      {
        unsigned int v23 = 0;
        *(_DWORD *)BOOL v38 = 7827310;
      }
      if (__isPlatformVersionAtLeast(2, 18, 0, 0))
      {
        int v24 = *(_DWORD *)(*(void *)(a1 + 24) + 184);
        *(unsigned char *)(v19 + 12) = 1;
        *(_DWORD *)(v19 + 4) = v24;
      }
      *(unsigned char *)(v19 + 13) = 1;
      *(_DWORD *)(v19 + 8) = v23;
      int updated = DNSServiceUpdateRecordInternal(*(void *)(*(void *)(a1 + 8) + 8), 0, 0, 0, v19);
      DNSServiceAttributeDeallocate((DNSServiceAttributeRef)v19);
      int v25 = global_os_log;
      BOOL v26 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
      if (updated)
      {
        if (!v26) {
          goto LABEL_17;
        }
        int v27 = *(const char **)(a1 + 48);
        uint64_t v28 = *(void *)(*(void *)(a1 + 8) + 8);
        *(_DWORD *)int buf = 136447491;
        *(void *)&uint8_t buf[4] = "update_instance_tsr";
        *(_WORD *)&unsigned char buf[12] = 2160;
        *(void *)&buf[14] = 1752392040;
        __int16 v40 = 2081;
        uint64_t v41 = v27;
        __int16 v42 = 1024;
        *(_DWORD *)__int16 v43 = updated;
        *(_WORD *)&v43[4] = 2048;
        *(void *)&v43[6] = a1;
        *(_WORD *)&v43[14] = 2048;
        *(void *)&v43[16] = v28;
        int v29 = "%{public}s: DNSServiceUpdateRecord for instance %{private, mask.hash}s, TSR failed: %d (instance %p sdref %p)";
        int v30 = v25;
        uint32_t v31 = 58;
        goto LABEL_40;
      }
      if (v26)
      {
        uint64_t v35 = *(void *)(a1 + 24);
        if (v35) {
          uint32_t v36 = *(const char **)(v35 + 56);
        }
        else {
          uint32_t v36 = "<null>";
        }
        uint64_t v37 = *(void *)(*(void *)(a1 + 8) + 8);
        *(_DWORD *)int buf = 136447491;
        *(void *)&uint8_t buf[4] = "update_instance_tsr";
        *(_WORD *)&unsigned char buf[12] = 2160;
        *(void *)&buf[14] = 1752392040;
        __int16 v40 = 2081;
        uint64_t v41 = v36;
        __int16 v42 = 2082;
        *(void *)__int16 v43 = v38;
        *(_WORD *)&v43[8] = 2048;
        *(void *)&v43[10] = a1;
        *(_WORD *)&v43[18] = 2048;
        *(void *)&v43[20] = v37;
        _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%{public}s: DNSServiceUpdateRecord for %{private, mask.hash}s, TSR set to %{public}s (instance %p sdref %p)", buf, 0x3Eu);
      }
      if (!a2) {
        return 1;
      }
    }
    free(*(void **)(a1 + 72));
    *(void *)(a1 + 72) = *(void *)(a2 + 72);
    *(_WORD *)(a1 + 80) = *(_WORD *)(a2 + 80);
    *(void *)(a2 + 72) = 0;
    *(_WORD *)(a2 + 80) = 0;
    return 1;
  }
  int updated = v32;
  uint64_t v33 = global_os_log;
  if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
    goto LABEL_17;
  }
  uint64_t v34 = *(const char **)(a1 + 48);
  *(_DWORD *)int buf = 136447235;
  *(void *)&uint8_t buf[4] = "update_instance_tsr";
  *(_WORD *)&unsigned char buf[12] = 2160;
  *(void *)&buf[14] = 1752392040;
  __int16 v40 = 2081;
  uint64_t v41 = v34;
  __int16 v42 = 1024;
  *(_DWORD *)__int16 v43 = updated;
  *(_WORD *)&v43[4] = 2048;
  *(void *)&v43[6] = a1;
  int v29 = "%{public}s: DNSServiceUpdateRecord for instance %{private, mask.hash}s TXT record failed: %d (instance %p)";
  int v30 = v33;
  uint32_t v31 = 48;
LABEL_40:
  _os_log_impl((void *)&_mh_execute_header, v30, OS_LOG_TYPE_DEFAULT, v29, buf, v31);
LABEL_17:
  uint64_t v16 = *(void *)(a1 + 8);
  if (!v16) {
    return 0;
  }
  if ((updated + 65541) <= 1)
  {
    DNSServiceErrorType v17 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "update_instance_tsr";
      _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, "%{public}s: we got a bad reference error: why?", buf, 0xCu);
      uint64_t v16 = *(void *)(a1 + 8);
    }
  }
  ioloop_dnssd_txn_cancel(v16);
  ioloop_dnssd_txn_release_(*(int **)(a1 + 8), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 2885);
  BOOL result = 0;
  *(void *)(a1 + 8) = 0;
  return result;
}

size_t srp_format_time_offset(char *a1, uint64_t a2)
{
  memset(&v5, 0, sizeof(v5));
  time_t v4 = time(0) - a2;
  localtime_r(&v4, &v5);
  return strftime(a1, 0x1CuLL, "%F %T", &v5);
}

void service_disconnected(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a1 + 16);
  if (v2) {
    BOOL v3 = v2 == a2;
  }
  else {
    BOOL v3 = 0;
  }
  if (v3)
  {
    uint64_t v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(v2 + 8);
      *(_DWORD *)int buf = 136446722;
      uint64_t v11 = "service_disconnected";
      __int16 v12 = 2048;
      uint64_t v13 = a2;
      __int16 v14 = 2048;
      uint64_t v15 = v7;
      _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: server_state->shared_registration_txn = %p  sdref = %p", buf, 0x20u);
    }
    for (uint64_t i = *(void **)(a1 + 8); i; uint64_t i = (void *)i[5])
    {
      record_vec_txns_forget(i[12], a2, (uint64_t)"host", (uint64_t)i, i[7]);
      instance_vec_txns_forget(i[14], a2, (uint64_t)"host", (uint64_t)i, i[7]);
      record_txn_forget(i[13], a2, (uint64_t)"host key", (uint64_t)i, i[7]);
      uint64_t v9 = i[6];
      if (v9)
      {
        record_vec_txns_forget(*(void *)(v9 + 32), a2, (uint64_t)"host update remove addresses", v9, i[7]);
        record_vec_txns_forget(*(void *)(i[6] + 40), a2, (uint64_t)"host update add addresses", i[6], i[7]);
        record_txn_forget(*(void *)(i[6] + 48), a2, (uint64_t)"host update key", i[6], i[7]);
        instance_vec_txns_forget(*(void *)(i[6] + 56), a2, (uint64_t)"host update update instances", i[6], i[7]);
        instance_vec_txns_forget(*(void *)(i[6] + 64), a2, (uint64_t)"host update remove instances", i[6], i[7]);
        instance_vec_txns_forget(*(void *)(i[6] + 72), a2, (uint64_t)"host update renew instances", i[6], i[7]);
        instance_vec_txns_forget(*(void *)(i[6] + 80), a2, (uint64_t)"host update add instances", i[6], i[7]);
      }
    }
    dns_service_op_not_to_be_freed = 0;
    ioloop_dnssd_txn_cancel(*(void *)(a1 + 16));
    ioloop_dnssd_txn_release_(*(int **)(a1 + 16), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 838);
    *(void *)(a1 + 16) = 0;
  }
}

void record_vec_txns_forget(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a1 && *(int *)(a1 + 4) >= 1)
  {
    uint64_t v10 = 0;
    do
      record_txn_forget(*(void *)(*(void *)(a1 + 8) + 8 * v10++), a2, a3, a4, a5);
    while (v10 < *(int *)(a1 + 4));
  }
}

void instance_vec_txns_forget(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a1)
  {
    int v6 = *(_DWORD *)(a1 + 4);
    if (v6 >= 1)
    {
      for (uint64_t i = 0; i < v6; ++i)
      {
        uint64_t v11 = *(void **)(*(void *)(a1 + 8) + 8 * i);
        if (v11)
        {
          uint64_t v12 = v11[1];
          if (v12)
          {
            uint64_t v13 = *(void *)(v12 + 8);
            if (v13)
            {
              if (v11[2] == a2)
              {
                __int16 v14 = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v15 = v11[6];
                  uint64_t v16 = v11[7];
                  *(_DWORD *)int buf = 136448515;
                  uint64_t v19 = "instance_vec_txns_forget";
                  __int16 v20 = 2048;
                  uint64_t v21 = v13;
                  __int16 v22 = 2082;
                  uint64_t v23 = a3;
                  __int16 v24 = 2048;
                  uint64_t v25 = a4;
                  __int16 v26 = 2160;
                  uint64_t v27 = 1752392040;
                  __int16 v28 = 2081;
                  uint64_t v29 = a5;
                  __int16 v30 = 2160;
                  uint64_t v31 = 1752392040;
                  __int16 v32 = 2081;
                  uint64_t v33 = v15;
                  __int16 v34 = 2160;
                  uint64_t v35 = 1752392040;
                  __int16 v36 = 2081;
                  uint64_t v37 = v16;
                  _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: forgetting sdref %p on %{public}s %p %{private, mask.hash}s instance %{private, mask.hash}s . %{private, mask.hash}s", buf, 0x66u);
                  uint64_t v12 = v11[1];
                  int v6 = *(_DWORD *)(a1 + 4);
                }
                *(void *)(v12 + 8) = 0;
              }
            }
          }
        }
      }
    }
  }
}

void record_txn_forget(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  if (a1)
  {
    uint64_t v6 = *(void *)(a1 + 8);
    if (v6)
    {
      if (*(void *)(a1 + 24) == a2)
      {
        uint64_t v10 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v11 = 136447491;
          uint64_t v12 = "record_txn_forget";
          __int16 v13 = 2048;
          uint64_t v14 = v6;
          __int16 v15 = 2082;
          uint64_t v16 = a3;
          __int16 v17 = 2048;
          uint64_t v18 = a4;
          __int16 v19 = 2160;
          uint64_t v20 = 1752392040;
          __int16 v21 = 2081;
          uint64_t v22 = a5;
          _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: forgetting rref %p on %{public}s %p %{private, mask.hash}s", (uint8_t *)&v11, 0x3Eu);
        }
        *(void *)(a1 + 8) = 0;
      }
    }
  }
}

void register_instance_completion(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  __int16 v13 = *(uint64_t **)(a7 + 24);
  uint64_t v12 = *(void *)(a7 + 32);
  uint64_t v14 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v15 = *(_DWORD *)a7;
    *(_DWORD *)int buf = 136447490;
    uint64_t v89 = "register_instance_completion";
    __int16 v90 = 1024;
    *(_DWORD *)uint32_t v91 = v15;
    *(_WORD *)&v91[4] = 2048;
    *(void *)&v91[6] = a7;
    *(_WORD *)&v91[14] = 2080;
    *(void *)&v91[16] = "instance";
    *(_WORD *)&v91[24] = 2080;
    *(void *)&v91[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v91[34] = 1024;
    *(_DWORD *)&v91[36] = 2034;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  int v16 = *(_DWORD *)a7;
  if (!*(_DWORD *)a7)
  {
    ++adv_instance_created;
    *(_DWORD *)a7 = 1;
    if (v12) {
      goto LABEL_6;
    }
LABEL_26:
    if (a3) {
      goto LABEL_45;
    }
LABEL_46:
    uint64_t v37 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v38 = *(void *)(a7 + 48);
      uint64_t v39 = *(void *)(a7 + 56);
      __int16 v40 = " with a conflict";
      uint64_t v41 = v13[8];
      if (!a3) {
        __int16 v40 = ":";
      }
      *(_DWORD *)int buf = 136448515;
      uint64_t v89 = "register_instance_completion";
      __int16 v90 = 2160;
      *(void *)uint32_t v91 = 1752392040;
      *(_WORD *)&v91[8] = 2081;
      *(void *)&v91[10] = v38;
      *(_WORD *)&v91[18] = 2160;
      *(void *)&v91[20] = 1752392040;
      *(_WORD *)&v91[28] = 2081;
      *(void *)&v91[30] = v39;
      *(_WORD *)&v91[38] = 2160;
      uint64_t v92 = 1752392040;
      __int16 v93 = 2081;
      uint64_t v94 = a6;
      __int16 v95 = 2160;
      uint64_t v96 = 1752392040;
      __int16 v97 = 2081;
      uint64_t v98 = v41;
      __int16 v99 = 2082;
      uint64_t v100 = v40;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "%{public}s: registration for service %{private, mask.hash}s.%{private, mask.hash}s.%{private, mask.hash}s -> %{private, mask.hash}s has completed%{public}s.", buf, 0x66u);
      uint64_t v37 = global_os_log;
    }
    if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136447747;
      uint64_t v89 = "register_instance_completion";
      __int16 v90 = 2160;
      *(void *)uint32_t v91 = 1752392040;
      *(_WORD *)&v91[8] = 2081;
      *(void *)&v91[10] = a4;
      *(_WORD *)&v91[18] = 2160;
      *(void *)&v91[20] = 1752392040;
      *(_WORD *)&v91[28] = 2081;
      *(void *)&v91[30] = a5;
      *(_WORD *)&v91[38] = 2160;
      uint64_t v92 = 1752392040;
      __int16 v93 = 2081;
      uint64_t v94 = a6;
      _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "%{public}s: registration is under %{private, mask.hash}s.%{private, mask.hash}s%{private, mask.hash}s", buf, 0x48u);
    }
    if (!a3) {
      goto LABEL_79;
    }
    uint64_t v87 = a6;
    uint64_t v42 = a4;
    uint64_t v43 = *(void *)(a7 + 8);
    if (v43)
    {
      uint64_t v44 = a5;
      ioloop_dnssd_txn_cancel(v43);
      ioloop_dnssd_txn_release_(*(int **)(a7 + 8), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 2068);
      *(void *)(a7 + 8) = 0;
    }
    else
    {
      uint64_t v44 = a5;
      __int16 v50 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v89 = "register_instance_completion";
        __int16 v90 = 2048;
        *(void *)uint32_t v91 = a7;
        _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_FAULT, "%{public}s: instance->txn is NULL for instance %p!", buf, 0x16u);
      }
    }
    if (*(void *)(a7 + 40)
      || (uint64_t v51 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1953), (*(void *)(a7 + 40) = v51) != 0))
    {
      int v52 = *(_DWORD *)(a7 + 112);
      if (v52) {
        unsigned int v53 = 2 * v52;
      }
      else {
        unsigned int v53 = 5000;
      }
      *(_DWORD *)(a7 + 112) = v53;
      uint32_t v54 = arc4random();
      unsigned int v55 = *(_DWORD *)(a7 + 112);
      __int16 v56 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v57 = *(_DWORD *)a7;
        *(_DWORD *)int buf = 136447490;
        uint64_t v89 = "srp_schedule_instance_retry";
        __int16 v90 = 1024;
        *(_DWORD *)uint32_t v91 = v57;
        *(_WORD *)&v91[4] = 2048;
        *(void *)&v91[6] = a7;
        *(_WORD *)&v91[14] = 2080;
        *(void *)&v91[16] = "instance";
        *(_WORD *)&v91[24] = 2080;
        *(void *)&v91[26] = "srp-mdns-proxy.c";
        *(_WORD *)&v91[34] = 1024;
        *(_DWORD *)&v91[36] = 1960;
        _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      }
      int v58 = *(_DWORD *)a7;
      if (*(_DWORD *)a7)
      {
        int v59 = v58 + 1;
        *(_DWORD *)a7 = v58 + 1;
        if (v58 + 1 >= 10001)
        {
          __int16 v26 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
            goto LABEL_163;
          }
          *(_DWORD *)int buf = 136447490;
          uint64_t v89 = "srp_schedule_instance_retry";
          __int16 v90 = 1024;
          *(_DWORD *)uint32_t v91 = v59;
          *(_WORD *)&v91[4] = 2048;
          *(void *)&v91[6] = a7;
          *(_WORD *)&v91[14] = 2080;
          *(void *)&v91[16] = "instance";
          *(_WORD *)&v91[24] = 2080;
          *(void *)&v91[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v91[34] = 1024;
          *(_DWORD *)&v91[36] = 1960;
          __int16 v32 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
          goto LABEL_141;
        }
      }
      else
      {
        ++adv_instance_created;
        *(_DWORD *)a7 = 1;
      }
      unsigned int v60 = -((double)(v54 % v55) - (double)v53 * 1.5);
      ioloop_add_wake_event(*(void *)(a7 + 40), a7, (uint64_t)srp_instance_retry_callback, (uint64_t)adv_instance_context_release, v60);
      uint64_t v61 = global_os_log;
      a5 = v44;
      a4 = v42;
      a6 = v87;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_79;
      }
      *(_DWORD *)int buf = 136446722;
      uint64_t v89 = "srp_schedule_instance_retry";
      __int16 v90 = 2048;
      *(void *)uint32_t v91 = a7;
      *(_WORD *)&v91[8] = 2048;
      *(double *)&v91[10] = (double)v60 / 1000.0;
      int v62 = "%{public}s: will attempt to reregister instance %p in %.3lf seconds";
      __int16 v63 = v61;
      os_log_type_t v64 = OS_LOG_TYPE_DEFAULT;
      uint32_t v65 = 32;
    }
    else
    {
      uint64_t v85 = global_os_log;
      a5 = v44;
      a4 = v42;
      a6 = v87;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
        goto LABEL_79;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v89 = "srp_schedule_instance_retry";
      int v62 = "%{public}s: unable to make wakeup &instance->retry_wakeup";
      __int16 v63 = v85;
      os_log_type_t v64 = OS_LOG_TYPE_ERROR;
      uint32_t v65 = 12;
    }
    _os_log_impl((void *)&_mh_execute_header, v63, v64, v62, buf, v65);
LABEL_79:
    if (v12)
    {
      if (*(unsigned char *)(a7 + 117))
      {
        uint64_t v66 = *(void *)(v12 + 16);
        if (v66) {
          *(void *)(a7 + 96) = *(void *)(v66 + 32);
        }
        int v67 = *(_DWORD *)(v12 + 96);
        int v68 = *(_DWORD *)(v12 + 92) + 1;
        *(_DWORD *)(v12 + 92) = v68;
        if (*(_DWORD *)(v12 + 100) == v67 && v68 == *(_DWORD *)(v12 + 88)) {
          srp_mdns_update_finished(v12);
        }
        int v69 = *(_DWORD *)v12;
        if (!*(_DWORD *)v12)
        {
          uint64_t v31 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
            goto LABEL_163;
          }
          *(_DWORD *)int buf = 136447490;
          uint64_t v89 = "register_instance_completion";
          __int16 v90 = 1024;
          *(_DWORD *)uint32_t v91 = 0;
          *(_WORD *)&v91[4] = 2048;
          *(void *)&v91[6] = v12;
          *(_WORD *)&v91[14] = 2080;
          *(void *)&v91[16] = "update";
          *(_WORD *)&v91[24] = 2080;
          *(void *)&v91[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v91[34] = 1024;
          *(_DWORD *)&v91[36] = 2087;
          __int16 v32 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
          goto LABEL_161;
        }
        uint64_t v23 = global_os_log;
        if (v69 >= 10001)
        {
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
            goto LABEL_163;
          }
          *(_DWORD *)int buf = 136447490;
          uint64_t v89 = "register_instance_completion";
          __int16 v90 = 1024;
          *(_DWORD *)uint32_t v91 = v69;
          *(_WORD *)&v91[4] = 2048;
          *(void *)&v91[6] = v12;
          *(_WORD *)&v91[14] = 2080;
          *(void *)&v91[16] = "update";
          *(_WORD *)&v91[24] = 2080;
          *(void *)&v91[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v91[34] = 1024;
          *(_DWORD *)&v91[36] = 2087;
          __int16 v32 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
          goto LABEL_158;
        }
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447490;
          uint64_t v89 = "register_instance_completion";
          __int16 v90 = 1024;
          *(_DWORD *)uint32_t v91 = v69;
          *(_WORD *)&v91[4] = 2048;
          *(void *)&v91[6] = v12;
          *(_WORD *)&v91[14] = 2080;
          *(void *)&v91[16] = "update";
          *(_WORD *)&v91[24] = 2080;
          *(void *)&v91[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v91[34] = 1024;
          *(_DWORD *)&v91[36] = 2087;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          int v69 = *(_DWORD *)v12;
        }
        *(_DWORD *)uint64_t v12 = v69 - 1;
        if (v69 == 1)
        {
          uint64_t v70 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136447234;
            uint64_t v89 = "register_instance_completion";
            __int16 v90 = 2048;
            *(void *)uint32_t v91 = v12;
            *(_WORD *)&v91[8] = 2080;
            *(void *)&v91[10] = "update";
            *(_WORD *)&v91[18] = 2080;
            *(void *)&v91[20] = "srp-mdns-proxy.c";
            *(_WORD *)&v91[28] = 1024;
            *(_DWORD *)&v91[30] = 2087;
            _os_log_impl((void *)&_mh_execute_header, v70, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          }
          ++adv_update_finalized;
          adv_update_finalize(v12);
        }
        *(unsigned char *)(a7 + 117) = 0;
      }
      goto LABEL_100;
    }
    uint64_t v71 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_100;
    }
    uint64_t v72 = *(void *)(a7 + 48);
    *(_DWORD *)int buf = 136448259;
    uint64_t v89 = "register_instance_completion";
    __int16 v90 = 2160;
    *(void *)uint32_t v91 = 1752392040;
    *(_WORD *)&v91[8] = 2081;
    *(void *)&v91[10] = v72;
    *(_WORD *)&v91[18] = 2160;
    *(void *)&v91[20] = 1752392040;
    *(_WORD *)&v91[28] = 2081;
    *(void *)&v91[30] = a4;
    *(_WORD *)&v91[38] = 2160;
    uint64_t v92 = 1752392040;
    __int16 v93 = 2081;
    uint64_t v94 = a5;
    __int16 v95 = 2160;
    uint64_t v96 = 1752392040;
    __int16 v97 = 2081;
    uint64_t v98 = a6;
    __int16 v73 = "%{public}s: re-update succeeded for instance %{private, mask.hash}s (%{private, mask.hash}s %{private, mask.ha"
          "sh}s %{private, mask.hash}s)";
    uint64_t v74 = v71;
    os_log_type_t v75 = OS_LOG_TYPE_DEFAULT;
    uint32_t v76 = 92;
LABEL_99:
    _os_log_impl((void *)&_mh_execute_header, v74, v75, v73, buf, v76);
    goto LABEL_100;
  }
  int v17 = v16 + 1;
  *(_DWORD *)a7 = v16 + 1;
  if (v16 + 1 >= 10001)
  {
    __int16 v26 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_163;
    }
    *(_DWORD *)int buf = 136447490;
    uint64_t v89 = "register_instance_completion";
    __int16 v90 = 1024;
    *(_DWORD *)uint32_t v91 = v17;
    *(_WORD *)&v91[4] = 2048;
    *(void *)&v91[6] = a7;
    *(_WORD *)&v91[14] = 2080;
    *(void *)&v91[16] = "instance";
    *(_WORD *)&v91[24] = 2080;
    *(void *)&v91[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v91[34] = 1024;
    *(_DWORD *)&v91[36] = 2034;
    __int16 v32 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
    goto LABEL_141;
  }
  if (!v12) {
    goto LABEL_26;
  }
LABEL_6:
  uint64_t v18 = v13[6];
  __int16 v19 = global_os_log;
  BOOL v20 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (v18 != v12)
  {
    if (v20)
    {
      *(_DWORD *)int buf = 136447235;
      uint64_t v89 = "register_instance_completion";
      __int16 v90 = 2160;
      *(void *)uint32_t v91 = 1752392040;
      *(_WORD *)&v91[8] = 2081;
      *(void *)&v91[10] = a4;
      *(_WORD *)&v91[18] = 2160;
      *(void *)&v91[20] = 1752392040;
      *(_WORD *)&v91[28] = 2081;
      *(void *)&v91[30] = a5;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%{public}s: registration for service %{private, mask.hash}s.%{private, mask.hash}s completed with invalid state.", buf, 0x34u);
    }
    __int16 v21 = *(int **)(a7 + 32);
    if (!v21)
    {
LABEL_18:
      *(void *)(a7 + 32) = 0;
      int v25 = *(_DWORD *)a7;
      if (!*(_DWORD *)a7)
      {
        __int16 v26 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_163;
        }
        *(_DWORD *)int buf = 136447490;
        uint64_t v89 = "register_instance_completion";
        __int16 v90 = 1024;
        *(_DWORD *)uint32_t v91 = 0;
        *(_WORD *)&v91[4] = 2048;
        *(void *)&v91[6] = a7;
        *(_WORD *)&v91[14] = 2080;
        *(void *)&v91[16] = "instance";
        *(_WORD *)&v91[24] = 2080;
        *(void *)&v91[26] = "srp-mdns-proxy.c";
        *(_WORD *)&v91[34] = 1024;
        *(_DWORD *)&v91[36] = 2043;
        __int16 v32 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_141;
      }
      __int16 v26 = global_os_log;
      if (v25 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447490;
          uint64_t v89 = "register_instance_completion";
          __int16 v90 = 1024;
          *(_DWORD *)uint32_t v91 = v25;
          *(_WORD *)&v91[4] = 2048;
          *(void *)&v91[6] = a7;
          *(_WORD *)&v91[14] = 2080;
          *(void *)&v91[16] = "instance";
          *(_WORD *)&v91[24] = 2080;
          *(void *)&v91[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v91[34] = 1024;
          *(_DWORD *)&v91[36] = 2043;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          int v25 = *(_DWORD *)a7;
        }
        *(_DWORD *)a7 = v25 - 1;
        if (v25 == 1)
        {
          uint64_t v27 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136447234;
            uint64_t v89 = "register_instance_completion";
            __int16 v90 = 2048;
            *(void *)uint32_t v91 = a7;
            *(_WORD *)&v91[8] = 2080;
            *(void *)&v91[10] = "instance";
            *(_WORD *)&v91[18] = 2080;
            *(void *)&v91[20] = "srp-mdns-proxy.c";
            *(_WORD *)&v91[28] = 1024;
            *(_DWORD *)&v91[30] = 2043;
LABEL_107:
            _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
            goto LABEL_108;
          }
          goto LABEL_108;
        }
        return;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)int buf = 136447490;
        uint64_t v89 = "register_instance_completion";
        __int16 v90 = 1024;
        *(_DWORD *)uint32_t v91 = v25;
        *(_WORD *)&v91[4] = 2048;
        *(void *)&v91[6] = a7;
        *(_WORD *)&v91[14] = 2080;
        *(void *)&v91[16] = "instance";
        *(_WORD *)&v91[24] = 2080;
        *(void *)&v91[26] = "srp-mdns-proxy.c";
        *(_WORD *)&v91[34] = 1024;
        *(_DWORD *)&v91[36] = 2043;
        __int16 v32 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_141:
        unsigned int v86 = v26;
LABEL_162:
        _os_log_impl((void *)&_mh_execute_header, v86, OS_LOG_TYPE_FAULT, v32, buf, 0x36u);
      }
LABEL_163:
      abort();
    }
    int v22 = *v21;
    if (*v21)
    {
      uint64_t v23 = global_os_log;
      if (v22 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447490;
          uint64_t v89 = "register_instance_completion";
          __int16 v90 = 1024;
          *(_DWORD *)uint32_t v91 = v22;
          *(_WORD *)&v91[4] = 2048;
          *(void *)&v91[6] = v21;
          *(_WORD *)&v91[14] = 2080;
          *(void *)&v91[16] = "instance->update";
          *(_WORD *)&v91[24] = 2080;
          *(void *)&v91[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v91[34] = 1024;
          *(_DWORD *)&v91[36] = 2041;
          _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          __int16 v21 = *(int **)(a7 + 32);
          int v22 = *v21;
        }
        *__int16 v21 = v22 - 1;
        if (v22 == 1)
        {
          __int16 v24 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136447234;
            uint64_t v89 = "register_instance_completion";
            __int16 v90 = 2048;
            *(void *)uint32_t v91 = v21;
            *(_WORD *)&v91[8] = 2080;
            *(void *)&v91[10] = "instance->update";
            *(_WORD *)&v91[18] = 2080;
            *(void *)&v91[20] = "srp-mdns-proxy.c";
            *(_WORD *)&v91[28] = 1024;
            *(_DWORD *)&v91[30] = 2041;
            _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
            __int16 v21 = *(int **)(a7 + 32);
          }
          ++adv_update_finalized;
          adv_update_finalize((uint64_t)v21);
        }
        goto LABEL_18;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_163;
      }
      *(_DWORD *)int buf = 136447490;
      uint64_t v89 = "register_instance_completion";
      __int16 v90 = 1024;
      *(_DWORD *)uint32_t v91 = v22;
      *(_WORD *)&v91[4] = 2048;
      *(void *)&v91[6] = v21;
      *(_WORD *)&v91[14] = 2080;
      *(void *)&v91[16] = "instance->update";
      *(_WORD *)&v91[24] = 2080;
      *(void *)&v91[26] = "srp-mdns-proxy.c";
      *(_WORD *)&v91[34] = 1024;
      *(_DWORD *)&v91[36] = 2041;
      __int16 v32 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_158:
      unsigned int v86 = v23;
      goto LABEL_162;
    }
    uint64_t v31 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_163;
    }
    *(_DWORD *)int buf = 136447490;
    uint64_t v89 = "register_instance_completion";
    __int16 v90 = 1024;
    *(_DWORD *)uint32_t v91 = 0;
    *(_WORD *)&v91[4] = 2048;
    *(void *)&v91[6] = v21;
    *(_WORD *)&v91[14] = 2080;
    *(void *)&v91[16] = "instance->update";
    *(_WORD *)&v91[24] = 2080;
    *(void *)&v91[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v91[34] = 1024;
    *(_DWORD *)&v91[36] = 2041;
    __int16 v32 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_161:
    unsigned int v86 = v31;
    goto LABEL_162;
  }
  if (v20)
  {
    int v28 = *(_DWORD *)v12;
    *(_DWORD *)int buf = 136447490;
    uint64_t v89 = "register_instance_completion";
    __int16 v90 = 1024;
    *(_DWORD *)uint32_t v91 = v28;
    *(_WORD *)&v91[4] = 2048;
    *(void *)&v91[6] = v12;
    *(_WORD *)&v91[14] = 2080;
    *(void *)&v91[16] = "update";
    *(_WORD *)&v91[24] = 2080;
    *(void *)&v91[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v91[34] = 1024;
    *(_DWORD *)&v91[36] = 2051;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  int v29 = *(_DWORD *)v12;
  if (*(_DWORD *)v12)
  {
    int v30 = v29 + 1;
    *(_DWORD *)uint64_t v12 = v29 + 1;
    if (v29 + 1 >= 10001)
    {
      uint64_t v31 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_163;
      }
      *(_DWORD *)int buf = 136447490;
      uint64_t v89 = "register_instance_completion";
      __int16 v90 = 1024;
      *(_DWORD *)uint32_t v91 = v30;
      *(_WORD *)&v91[4] = 2048;
      *(void *)&v91[6] = v12;
      *(_WORD *)&v91[14] = 2080;
      *(void *)&v91[16] = "update";
      *(_WORD *)&v91[24] = 2080;
      *(void *)&v91[26] = "srp-mdns-proxy.c";
      *(_WORD *)&v91[34] = 1024;
      *(_DWORD *)&v91[36] = 2051;
      __int16 v32 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_161;
    }
  }
  else
  {
    ++adv_update_created;
    *(_DWORD *)uint64_t v12 = 1;
  }
  uint64_t v33 = *(int **)(a7 + 32);
  if (v33)
  {
    int v34 = *v33;
    if (!*v33)
    {
      uint64_t v31 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_163;
      }
      *(_DWORD *)int buf = 136447490;
      uint64_t v89 = "register_instance_completion";
      __int16 v90 = 1024;
      *(_DWORD *)uint32_t v91 = 0;
      *(_WORD *)&v91[4] = 2048;
      *(void *)&v91[6] = v33;
      *(_WORD *)&v91[14] = 2080;
      *(void *)&v91[16] = "instance->update";
      *(_WORD *)&v91[24] = 2080;
      *(void *)&v91[26] = "srp-mdns-proxy.c";
      *(_WORD *)&v91[34] = 1024;
      *(_DWORD *)&v91[36] = 2052;
      __int16 v32 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_161;
    }
    uint64_t v35 = global_os_log;
    if (v34 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_163;
      }
      *(_DWORD *)int buf = 136447490;
      uint64_t v89 = "register_instance_completion";
      __int16 v90 = 1024;
      *(_DWORD *)uint32_t v91 = v34;
      *(_WORD *)&v91[4] = 2048;
      *(void *)&v91[6] = v33;
      *(_WORD *)&v91[14] = 2080;
      *(void *)&v91[16] = "instance->update";
      *(_WORD *)&v91[24] = 2080;
      *(void *)&v91[26] = "srp-mdns-proxy.c";
      *(_WORD *)&v91[34] = 1024;
      *(_DWORD *)&v91[36] = 2052;
      __int16 v32 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      unsigned int v86 = v35;
      goto LABEL_162;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136447490;
      uint64_t v89 = "register_instance_completion";
      __int16 v90 = 1024;
      *(_DWORD *)uint32_t v91 = v34;
      *(_WORD *)&v91[4] = 2048;
      *(void *)&v91[6] = v33;
      *(_WORD *)&v91[14] = 2080;
      *(void *)&v91[16] = "instance->update";
      *(_WORD *)&v91[24] = 2080;
      *(void *)&v91[26] = "srp-mdns-proxy.c";
      *(_WORD *)&v91[34] = 1024;
      *(_DWORD *)&v91[36] = 2052;
      _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      uint64_t v33 = *(int **)(a7 + 32);
      int v34 = *v33;
    }
    *uint64_t v33 = v34 - 1;
    if (v34 == 1)
    {
      __int16 v36 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136447234;
        uint64_t v89 = "register_instance_completion";
        __int16 v90 = 2048;
        *(void *)uint32_t v91 = v33;
        *(_WORD *)&v91[8] = 2080;
        *(void *)&v91[10] = "instance->update";
        *(_WORD *)&v91[18] = 2080;
        *(void *)&v91[20] = "srp-mdns-proxy.c";
        *(_WORD *)&v91[28] = 1024;
        *(_DWORD *)&v91[30] = 2052;
        _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        uint64_t v33 = *(int **)(a7 + 32);
      }
      ++adv_update_finalized;
      adv_update_finalize((uint64_t)v33);
    }
  }
  *(void *)(a7 + 32) = 0;
  if (!a3) {
    goto LABEL_46;
  }
LABEL_45:
  if (a3 == -65548) {
    goto LABEL_46;
  }
  uint64_t v45 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v46 = *(void *)(a7 + 48);
    uint64_t v47 = *(void *)(a7 + 56);
    uint64_t v48 = v13[8];
    *(_DWORD *)int buf = 136448515;
    uint64_t v89 = "register_instance_completion";
    __int16 v90 = 2160;
    *(void *)uint32_t v91 = 1752392040;
    *(_WORD *)&v91[8] = 2081;
    *(void *)&v91[10] = v46;
    *(_WORD *)&v91[18] = 2160;
    *(void *)&v91[20] = 1752392040;
    *(_WORD *)&v91[28] = 2081;
    *(void *)&v91[30] = v47;
    *(_WORD *)&v91[38] = 2160;
    uint64_t v92 = 1752392040;
    __int16 v93 = 2081;
    uint64_t v94 = a6;
    __int16 v95 = 2160;
    uint64_t v96 = 1752392040;
    __int16 v97 = 2081;
    uint64_t v98 = v48;
    __int16 v99 = 1024;
    LODWORD(v100) = a3;
    _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%{public}s: registration for service %{private, mask.hash}s.%{private, mask.hash}s.%{private, mask.hash}s -> %{private, mask.hash}s failed with code %d", buf, 0x62u);
  }
  if (a3 == -65563 || a3 == -65569)
  {
    service_disconnected(v13[1], *(void *)(a7 + 16));
    *(void *)(a7 + 16) = 0;
    wait_retry((uint64_t)v13);
  }
  else if (v12)
  {
    update_failed(v12, 2u, 1);
    __int16 v79 = *(int **)(a7 + 32);
    if (v79)
    {
      int v80 = *v79;
      if (!*v79)
      {
        uint64_t v31 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_163;
        }
        *(_DWORD *)int buf = 136447490;
        uint64_t v89 = "register_instance_completion";
        __int16 v90 = 1024;
        *(_DWORD *)uint32_t v91 = 0;
        *(_WORD *)&v91[4] = 2048;
        *(void *)&v91[6] = v79;
        *(_WORD *)&v91[14] = 2080;
        *(void *)&v91[16] = "instance->update";
        *(_WORD *)&v91[24] = 2080;
        *(void *)&v91[26] = "srp-mdns-proxy.c";
        *(_WORD *)&v91[34] = 1024;
        *(_DWORD *)&v91[36] = 2117;
        __int16 v32 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_161;
      }
      __int16 v81 = global_os_log;
      if (v80 >= 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)int buf = 136447490;
          uint64_t v89 = "register_instance_completion";
          __int16 v90 = 1024;
          *(_DWORD *)uint32_t v91 = v80;
          *(_WORD *)&v91[4] = 2048;
          *(void *)&v91[6] = v79;
          *(_WORD *)&v91[14] = 2080;
          *(void *)&v91[16] = "instance->update";
          *(_WORD *)&v91[24] = 2080;
          *(void *)&v91[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v91[34] = 1024;
          *(_DWORD *)&v91[36] = 2117;
          __int16 v32 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
          unsigned int v86 = v81;
          goto LABEL_162;
        }
        goto LABEL_163;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136447490;
        uint64_t v89 = "register_instance_completion";
        __int16 v90 = 1024;
        *(_DWORD *)uint32_t v91 = v80;
        *(_WORD *)&v91[4] = 2048;
        *(void *)&v91[6] = v79;
        *(_WORD *)&v91[14] = 2080;
        *(void *)&v91[16] = "instance->update";
        *(_WORD *)&v91[24] = 2080;
        *(void *)&v91[26] = "srp-mdns-proxy.c";
        *(_WORD *)&v91[34] = 1024;
        *(_DWORD *)&v91[36] = 2117;
        _os_log_impl((void *)&_mh_execute_header, v81, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        __int16 v79 = *(int **)(a7 + 32);
        int v80 = *v79;
      }
      *__int16 v79 = v80 - 1;
      if (v80 == 1)
      {
        uint64_t v82 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447234;
          uint64_t v89 = "register_instance_completion";
          __int16 v90 = 2048;
          *(void *)uint32_t v91 = v79;
          *(_WORD *)&v91[8] = 2080;
          *(void *)&v91[10] = "instance->update";
          *(_WORD *)&v91[18] = 2080;
          *(void *)&v91[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v91[28] = 1024;
          *(_DWORD *)&v91[30] = 2117;
          _os_log_impl((void *)&_mh_execute_header, v82, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          __int16 v79 = *(int **)(a7 + 32);
        }
        ++adv_update_finalized;
        adv_update_finalize((uint64_t)v79);
      }
      *(void *)(a7 + 32) = 0;
    }
    int v83 = *(_DWORD *)v12;
    if (!*(_DWORD *)v12)
    {
      uint64_t v31 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_163;
      }
      *(_DWORD *)int buf = 136447490;
      uint64_t v89 = "register_instance_completion";
      __int16 v90 = 1024;
      *(_DWORD *)uint32_t v91 = 0;
      *(_WORD *)&v91[4] = 2048;
      *(void *)&v91[6] = v12;
      *(_WORD *)&v91[14] = 2080;
      *(void *)&v91[16] = "update";
      *(_WORD *)&v91[24] = 2080;
      *(void *)&v91[26] = "srp-mdns-proxy.c";
      *(_WORD *)&v91[34] = 1024;
      *(_DWORD *)&v91[36] = 2120;
      __int16 v32 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_161;
    }
    uint64_t v23 = global_os_log;
    if (v83 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_163;
      }
      *(_DWORD *)int buf = 136447490;
      uint64_t v89 = "register_instance_completion";
      __int16 v90 = 1024;
      *(_DWORD *)uint32_t v91 = v83;
      *(_WORD *)&v91[4] = 2048;
      *(void *)&v91[6] = v12;
      *(_WORD *)&v91[14] = 2080;
      *(void *)&v91[16] = "update";
      *(_WORD *)&v91[24] = 2080;
      *(void *)&v91[26] = "srp-mdns-proxy.c";
      *(_WORD *)&v91[34] = 1024;
      *(_DWORD *)&v91[36] = 2120;
      __int16 v32 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      goto LABEL_158;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136447490;
      uint64_t v89 = "register_instance_completion";
      __int16 v90 = 1024;
      *(_DWORD *)uint32_t v91 = v83;
      *(_WORD *)&v91[4] = 2048;
      *(void *)&v91[6] = v12;
      *(_WORD *)&v91[14] = 2080;
      *(void *)&v91[16] = "update";
      *(_WORD *)&v91[24] = 2080;
      *(void *)&v91[26] = "srp-mdns-proxy.c";
      *(_WORD *)&v91[34] = 1024;
      *(_DWORD *)&v91[36] = 2120;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      int v83 = *(_DWORD *)v12;
    }
    *(_DWORD *)uint64_t v12 = v83 - 1;
    if (v83 == 1)
    {
      uint64_t v84 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136447234;
        uint64_t v89 = "register_instance_completion";
        __int16 v90 = 2048;
        *(void *)uint32_t v91 = v12;
        *(_WORD *)&v91[8] = 2080;
        *(void *)&v91[10] = "update";
        *(_WORD *)&v91[18] = 2080;
        *(void *)&v91[20] = "srp-mdns-proxy.c";
        *(_WORD *)&v91[28] = 1024;
        *(_DWORD *)&v91[30] = 2120;
        _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
      }
      ++adv_update_finalized;
      adv_update_finalize(v12);
    }
  }
  uint64_t v49 = *(void *)(a7 + 8);
  if (v49)
  {
    ioloop_dnssd_txn_cancel(v49);
    ioloop_dnssd_txn_release_(*(int **)(a7 + 8), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 2147);
    *(void *)(a7 + 8) = 0;
    goto LABEL_100;
  }
  uint64_t v77 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
  {
    *(_DWORD *)int buf = 136446466;
    uint64_t v89 = "register_instance_completion";
    __int16 v90 = 2048;
    *(void *)uint32_t v91 = a7;
    __int16 v73 = "%{public}s: instance->txn is NULL for instance %p!";
    uint64_t v74 = v77;
    os_log_type_t v75 = OS_LOG_TYPE_FAULT;
    uint32_t v76 = 22;
    goto LABEL_99;
  }
LABEL_100:
  int v78 = *(_DWORD *)a7;
  if (!*(_DWORD *)a7)
  {
    __int16 v26 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_163;
    }
    *(_DWORD *)int buf = 136447490;
    uint64_t v89 = "register_instance_completion";
    __int16 v90 = 1024;
    *(_DWORD *)uint32_t v91 = 0;
    *(_WORD *)&v91[4] = 2048;
    *(void *)&v91[6] = a7;
    *(_WORD *)&v91[14] = 2080;
    *(void *)&v91[16] = "instance";
    *(_WORD *)&v91[24] = 2080;
    *(void *)&v91[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v91[34] = 1024;
    *(_DWORD *)&v91[36] = 2151;
    __int16 v32 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_141;
  }
  __int16 v26 = global_os_log;
  if (v78 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_163;
    }
    *(_DWORD *)int buf = 136447490;
    uint64_t v89 = "register_instance_completion";
    __int16 v90 = 1024;
    *(_DWORD *)uint32_t v91 = v78;
    *(_WORD *)&v91[4] = 2048;
    *(void *)&v91[6] = a7;
    *(_WORD *)&v91[14] = 2080;
    *(void *)&v91[16] = "instance";
    *(_WORD *)&v91[24] = 2080;
    *(void *)&v91[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v91[34] = 1024;
    *(_DWORD *)&v91[36] = 2151;
    __int16 v32 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_141;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136447490;
    uint64_t v89 = "register_instance_completion";
    __int16 v90 = 1024;
    *(_DWORD *)uint32_t v91 = v78;
    *(_WORD *)&v91[4] = 2048;
    *(void *)&v91[6] = a7;
    *(_WORD *)&v91[14] = 2080;
    *(void *)&v91[16] = "instance";
    *(_WORD *)&v91[24] = 2080;
    *(void *)&v91[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v91[34] = 1024;
    *(_DWORD *)&v91[36] = 2151;
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    int v78 = *(_DWORD *)a7;
  }
  *(_DWORD *)a7 = v78 - 1;
  if (v78 == 1)
  {
    uint64_t v27 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136447234;
      uint64_t v89 = "register_instance_completion";
      __int16 v90 = 2048;
      *(void *)uint32_t v91 = a7;
      *(_WORD *)&v91[8] = 2080;
      *(void *)&v91[10] = "instance";
      *(_WORD *)&v91[18] = 2080;
      *(void *)&v91[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v91[28] = 1024;
      *(_DWORD *)&v91[30] = 2151;
      goto LABEL_107;
    }
LABEL_108:
    ++adv_instance_finalized;
    adv_instance_finalize((void *)a7);
  }
}

void wait_retry(uint64_t a1)
{
  *(void *)__int16 v13 = 0;
  *(void *)&v13[8] = 0;
  gettimeofday((timeval *)v13, 0);
  uint64_t v2 = 1000 * *(void *)v13 + *(_DWORD *)&v13[8] / 1000;
  uint64_t v3 = *(void *)(a1 + 256);
  if (v3) {
    BOOL v4 = v3 < v2;
  }
  else {
    BOOL v4 = 1;
  }
  if (!v4)
  {
    int v6 = *(_DWORD *)(a1 + 192);
    if (v6)
    {
      if (v6 > 119)
      {
LABEL_14:
        uint64_t v7 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)__int16 v13 = 136446466;
          *(void *)&v13[4] = "wait_retry";
          *(_WORD *)&v13[12] = 1024;
          *(_DWORD *)&v13[14] = v6;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: waiting %d seconds...", v13, 0x12u);
          int v6 = *(_DWORD *)(a1 + 192);
        }
        ioloop_add_wake_event(*(void *)(a1 + 24), a1, (uint64_t)retry_callback, (uint64_t)srp_adv_host_context_release, 1000 * v6);
        uint64_t v8 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v9 = *(_DWORD *)a1;
          *(_DWORD *)__int16 v13 = 136447490;
          *(void *)&v13[4] = "wait_retry";
          *(_WORD *)&v13[12] = 1024;
          *(_DWORD *)&v13[14] = v9;
          *(_WORD *)&v13[18] = 2048;
          *(void *)&v13[20] = a1;
          *(_WORD *)&v13[28] = 2080;
          *(void *)&v13[30] = "host";
          *(_WORD *)&v13[38] = 2080;
          *(void *)&v13[40] = "srp-mdns-proxy.c";
          __int16 v14 = 1024;
          int v15 = 709;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v13, 0x36u);
        }
        int v10 = *(_DWORD *)a1;
        if (*(_DWORD *)a1)
        {
          int v11 = v10 + 1;
          *(_DWORD *)a1 = v10 + 1;
          if (v10 + 1 >= 10001)
          {
            uint64_t v12 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)__int16 v13 = 136447490;
              *(void *)&v13[4] = "wait_retry";
              *(_WORD *)&v13[12] = 1024;
              *(_DWORD *)&v13[14] = v11;
              *(_WORD *)&v13[18] = 2048;
              *(void *)&v13[20] = a1;
              *(_WORD *)&v13[28] = 2080;
              *(void *)&v13[30] = "host";
              *(_WORD *)&v13[38] = 2080;
              *(void *)&v13[40] = "srp-mdns-proxy.c";
              __int16 v14 = 1024;
              int v15 = 709;
              _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", v13, 0x36u);
            }
            abort();
          }
        }
        else
        {
          ++adv_host_created;
          *(_DWORD *)a1 = 1;
        }
        return;
      }
      v6 *= 2;
    }
    else
    {
      int v6 = 15;
    }
    *(_DWORD *)(a1 + 192) = v6;
    goto LABEL_14;
  }
  tm v5 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int16 v13 = 136446978;
    *(void *)&v13[4] = "wait_retry";
    *(_WORD *)&v13[12] = 2048;
    *(void *)&v13[14] = v3;
    *(_WORD *)&v13[22] = 2048;
    *(void *)&v13[24] = v2;
    *(_WORD *)&v13[32] = 2048;
    *(void *)&unsigned char v13[34] = v3 - v2;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: host lease has expired, not retrying: lease_expiry = %lld now = %lld difference = %lld", v13, 0x2Au);
  }
  delete_host(a1);
}

void delete_host(uint64_t a1)
{
  uint64_t v2 = host_ready(a1);
  if (v2)
  {
    uint64_t v3 = v2;
    BOOL v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v5 = *(void *)(a1 + 56);
      int v6 = 136446723;
      uint64_t v7 = "delete_host";
      __int16 v8 = 2160;
      uint64_t v9 = 1752392040;
      __int16 v10 = 2081;
      uint64_t v11 = v5;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: deleting host %{private, mask.hash}s", (uint8_t *)&v6, 0x20u);
    }
    *uint64_t v3 = *(void *)(a1 + 40);
    host_remove((int *)a1);
  }
}

uint64_t retry_callback(int *a1)
{
  if (*((void *)a1 + 6))
  {
    return start_host_update(a1);
  }
  uint64_t v3 = malloc_type_calloc(1uLL, 0x88uLL, 0x1020040C5CF03A7uLL);
  BOOL v4 = global_os_log;
  if (!v3)
  {
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      uint64_t v72 = "update_from_host";
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%{public}s: no memory for update.", buf, 0xCu);
    }
    return wait_retry(a1);
  }
  uint64_t v5 = (uint64_t)v3;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = *(_DWORD *)v5;
    *(_DWORD *)int buf = 136447490;
    uint64_t v72 = "update_from_host";
    __int16 v73 = 1024;
    *(_DWORD *)uint64_t v74 = v6;
    *(_WORD *)&v74[4] = 2048;
    *(void *)&v74[6] = v5;
    *(_WORD *)&v74[14] = 2080;
    *(void *)&v74[16] = "update";
    *(_WORD *)&v74[24] = 2080;
    *(void *)&v74[26] = "srp-mdns-proxy.c";
    __int16 v75 = 1024;
    int v76 = 2346;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  int v7 = *(_DWORD *)v5;
  if (*(_DWORD *)v5)
  {
    int v8 = v7 + 1;
    *(_DWORD *)uint64_t v5 = v7 + 1;
    if (v7 + 1 >= 10001)
    {
      uint64_t v9 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)int buf = 136447490;
        uint64_t v72 = "update_from_host";
        __int16 v73 = 1024;
        *(_DWORD *)uint64_t v74 = v8;
        *(_WORD *)&v74[4] = 2048;
        *(void *)&v74[6] = v5;
        *(_WORD *)&v74[14] = 2080;
        *(void *)&v74[16] = "update";
        *(_WORD *)&v74[24] = 2080;
        *(void *)&v74[26] = "srp-mdns-proxy.c";
        __int16 v75 = 1024;
        int v76 = 2346;
        __int16 v10 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        goto LABEL_129;
      }
      goto LABEL_131;
    }
  }
  else
  {
    ++adv_update_created;
    *(_DWORD *)uint64_t v5 = 1;
  }
  uint64_t v11 = *((void *)a1 + 12);
  if (!v11) {
    goto LABEL_44;
  }
  uint64_t v12 = adv_record_vec_create(*(_DWORD *)(v11 + 4));
  if (!v12)
  {
    *(void *)(v5 + 40) = 0;
    int v28 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_104;
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v72 = "update_from_host";
    int v29 = "%{public}s: no memory for addresses";
LABEL_103:
    _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, v29, buf, 0xCu);
    goto LABEL_104;
  }
  __int16 v13 = v12;
  int v14 = *(_DWORD *)(v11 + 4);
  if (v14 <= 0)
  {
    *((_DWORD *)v12 + 1) = v14;
    *(void *)(v5 + 40) = v12;
    goto LABEL_44;
  }
  for (uint64_t i = 0; i < v14; ++i)
  {
    uint64_t v16 = *(void *)(*(void *)(v11 + 8) + 8 * i);
    if (v16)
    {
      *(void *)(v13[1] + 8 * i) = v16;
      int v17 = *(int **)(v13[1] + 8 * i);
      if (v17)
      {
        uint64_t v18 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v19 = *v17;
          *(_DWORD *)int buf = 136447490;
          uint64_t v72 = "adv_record_vec_copy";
          __int16 v73 = 1024;
          *(_DWORD *)uint64_t v74 = v19;
          *(_WORD *)&v74[4] = 2048;
          *(void *)&v74[6] = v17;
          *(_WORD *)&v74[14] = 2080;
          *(void *)&v74[16] = "new_vec->vec[i]";
          *(_WORD *)&v74[24] = 2080;
          *(void *)&v74[26] = "srp-mdns-proxy.c";
          __int16 v75 = 1024;
          int v76 = 310;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          int v17 = *(int **)(v13[1] + 8 * i);
        }
        int v20 = *v17;
        if (*v17)
        {
          int v21 = v20 + 1;
          *int v17 = v20 + 1;
          if (v20 + 1 > 10000)
          {
            uint64_t v65 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
              goto LABEL_131;
            }
            *(_DWORD *)int buf = 136447490;
            uint64_t v72 = "adv_record_vec_copy";
            __int16 v73 = 1024;
            *(_DWORD *)uint64_t v74 = v21;
            *(_WORD *)&v74[4] = 2048;
            *(void *)&v74[6] = v17;
            *(_WORD *)&v74[14] = 2080;
            *(void *)&v74[16] = "new_vec->vec[i]";
            *(_WORD *)&v74[24] = 2080;
            *(void *)&v74[26] = "srp-mdns-proxy.c";
            __int16 v75 = 1024;
            int v76 = 310;
            __int16 v10 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
            goto LABEL_120;
          }
        }
        else
        {
          ++adv_record_created;
          *int v17 = 1;
        }
        int v14 = *(_DWORD *)(v11 + 4);
      }
    }
  }
  *((_DWORD *)v13 + 1) = v14;
  *(void *)(v5 + 40) = v13;
  if (v14 >= 1)
  {
    uint64_t v22 = 0;
    do
    {
      uint64_t v23 = *(void *)(v13[1] + 8 * v22);
      if (v23)
      {
        *(void *)(v23 + 32) = v5;
        __int16 v24 = global_os_log;
        BOOL v25 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
        int v26 = *(_DWORD *)v5;
        if (v25)
        {
          *(_DWORD *)int buf = 136447490;
          uint64_t v72 = "update_from_host";
          __int16 v73 = 1024;
          *(_DWORD *)uint64_t v74 = v26;
          *(_WORD *)&v74[4] = 2048;
          *(void *)&v74[6] = v5;
          *(_WORD *)&v74[14] = 2080;
          *(void *)&v74[16] = "update";
          *(_WORD *)&v74[24] = 2080;
          *(void *)&v74[26] = "srp-mdns-proxy.c";
          __int16 v75 = 1024;
          int v76 = 2357;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          int v26 = *(_DWORD *)v5;
        }
        if (v26)
        {
          int v27 = v26 + 1;
          *(_DWORD *)uint64_t v5 = v26 + 1;
          if (v26 + 1 > 10000)
          {
            uint64_t v9 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)int buf = 136447490;
              uint64_t v72 = "update_from_host";
              __int16 v73 = 1024;
              *(_DWORD *)uint64_t v74 = v27;
              *(_WORD *)&v74[4] = 2048;
              *(void *)&v74[6] = v5;
              *(_WORD *)&v74[14] = 2080;
              *(void *)&v74[16] = "update";
              *(_WORD *)&v74[24] = 2080;
              *(void *)&v74[26] = "srp-mdns-proxy.c";
              __int16 v75 = 1024;
              int v76 = 2357;
              __int16 v10 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
              goto LABEL_129;
            }
            goto LABEL_131;
          }
        }
        else
        {
          ++adv_update_created;
          *(_DWORD *)uint64_t v5 = 1;
        }
        __int16 v13 = *(void **)(v5 + 40);
      }
      ++v22;
    }
    while (v22 < *((int *)v13 + 1));
  }
LABEL_44:
  uint64_t v30 = *((void *)a1 + 14);
  if (!v30) {
    goto LABEL_76;
  }
  uint64_t v31 = adv_instance_vec_create(*(_DWORD *)(v30 + 4));
  if (!v31)
  {
    *(void *)(v5 + 56) = 0;
    int v28 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_104;
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v72 = "update_from_host";
    int v29 = "%{public}s: no memory for update_instances";
    goto LABEL_103;
  }
  __int16 v32 = v31;
  int v33 = *(_DWORD *)(v30 + 4);
  if (v33 <= 0)
  {
    *((_DWORD *)v31 + 1) = v33;
    *(void *)(v5 + 56) = v31;
    goto LABEL_73;
  }
  uint64_t v34 = 0;
  while (2)
  {
    uint64_t v35 = *(void *)(*(void *)(v30 + 8) + 8 * v34);
    if (v35)
    {
      *(void *)(v32[1] + 8 * v34) = v35;
      __int16 v36 = *(int **)(v32[1] + 8 * v34);
      if (v36)
      {
        uint64_t v37 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v38 = *v36;
          *(_DWORD *)int buf = 136447490;
          uint64_t v72 = "adv_instance_vec_copy";
          __int16 v73 = 1024;
          *(_DWORD *)uint64_t v74 = v38;
          *(_WORD *)&v74[4] = 2048;
          *(void *)&v74[6] = v36;
          *(_WORD *)&v74[14] = 2080;
          *(void *)&v74[16] = "new_vec->vec[i]";
          *(_WORD *)&v74[24] = 2080;
          *(void *)&v74[26] = "srp-mdns-proxy.c";
          __int16 v75 = 1024;
          int v76 = 306;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          __int16 v36 = *(int **)(v32[1] + 8 * v34);
        }
        int v39 = *v36;
        if (*v36)
        {
          int v40 = v39 + 1;
          *__int16 v36 = v39 + 1;
          if (v39 + 1 > 10000)
          {
            uint64_t v65 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
              goto LABEL_131;
            }
            *(_DWORD *)int buf = 136447490;
            uint64_t v72 = "adv_instance_vec_copy";
            __int16 v73 = 1024;
            *(_DWORD *)uint64_t v74 = v40;
            *(_WORD *)&v74[4] = 2048;
            *(void *)&v74[6] = v36;
            *(_WORD *)&v74[14] = 2080;
            *(void *)&v74[16] = "new_vec->vec[i]";
            *(_WORD *)&v74[24] = 2080;
            *(void *)&v74[26] = "srp-mdns-proxy.c";
            __int16 v75 = 1024;
            int v76 = 306;
            __int16 v10 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_120:
            int v69 = v65;
LABEL_130:
            _os_log_impl((void *)&_mh_execute_header, v69, OS_LOG_TYPE_FAULT, v10, buf, 0x36u);
            goto LABEL_131;
          }
        }
        else
        {
          ++adv_instance_created;
          *__int16 v36 = 1;
        }
        int v33 = *(_DWORD *)(v30 + 4);
      }
    }
    if (++v34 < v33) {
      continue;
    }
    break;
  }
  *((_DWORD *)v32 + 1) = v33;
  *(void *)(v5 + 56) = v32;
  if (v33 >= 1)
  {
    for (uint64_t j = 0; j < *((int *)v32 + 1); ++j)
    {
      uint64_t v42 = *(void *)(v32[1] + 8 * j);
      if (v42)
      {
        *(void *)(v42 + 32) = v5;
        uint64_t v43 = global_os_log;
        BOOL v44 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
        int v45 = *(_DWORD *)v5;
        if (v44)
        {
          *(_DWORD *)int buf = 136447490;
          uint64_t v72 = "update_from_host";
          __int16 v73 = 1024;
          *(_DWORD *)uint64_t v74 = v45;
          *(_WORD *)&v74[4] = 2048;
          *(void *)&v74[6] = v5;
          *(_WORD *)&v74[14] = 2080;
          *(void *)&v74[16] = "update";
          *(_WORD *)&v74[24] = 2080;
          *(void *)&v74[26] = "srp-mdns-proxy.c";
          __int16 v75 = 1024;
          int v76 = 2372;
          _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          int v45 = *(_DWORD *)v5;
        }
        if (v45)
        {
          int v46 = v45 + 1;
          *(_DWORD *)uint64_t v5 = v45 + 1;
          if (v45 + 1 > 10000)
          {
            uint64_t v9 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)int buf = 136447490;
              uint64_t v72 = "update_from_host";
              __int16 v73 = 1024;
              *(_DWORD *)uint64_t v74 = v46;
              *(_WORD *)&v74[4] = 2048;
              *(void *)&v74[6] = v5;
              *(_WORD *)&v74[14] = 2080;
              *(void *)&v74[16] = "update";
              *(_WORD *)&v74[24] = 2080;
              *(void *)&v74[26] = "srp-mdns-proxy.c";
              __int16 v75 = 1024;
              int v76 = 2372;
              __int16 v10 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
              goto LABEL_129;
            }
LABEL_131:
            abort();
          }
        }
        else
        {
          ++adv_update_created;
          *(_DWORD *)uint64_t v5 = 1;
        }
        __int16 v32 = *(void **)(v5 + 56);
      }
    }
  }
LABEL_73:
  uint64_t v47 = adv_instance_vec_create(*(_DWORD *)(*((void *)a1 + 14) + 4));
  *(void *)(v5 + 64) = v47;
  if (!v47)
  {
    int v28 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_104;
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v72 = "update_from_host";
    int v29 = "%{public}s: no memory for remove_instances";
    goto LABEL_103;
  }
  uint64_t v48 = *((void *)a1 + 14);
  *((_DWORD *)v47 + 1) = *(_DWORD *)(v48 + 4);
  uint64_t v49 = adv_instance_vec_create(*(_DWORD *)(v48 + 4));
  *(void *)(v5 + 80) = v49;
  if (!v49)
  {
    int v28 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      uint64_t v72 = "update_from_host";
      int v29 = "%{public}s: no memory for add_instances";
      goto LABEL_103;
    }
LABEL_104:
    adv_update_cancel(v5);
    int v63 = *(_DWORD *)v5;
    if (!*(_DWORD *)v5)
    {
      uint64_t v9 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_131;
      }
      *(_DWORD *)int buf = 136447490;
      uint64_t v72 = "update_from_host";
      __int16 v73 = 1024;
      *(_DWORD *)uint64_t v74 = 0;
      *(_WORD *)&v74[4] = 2048;
      *(void *)&v74[6] = v5;
      *(_WORD *)&v74[14] = 2080;
      *(void *)&v74[16] = "update";
      *(_WORD *)&v74[24] = 2080;
      *(void *)&v74[26] = "srp-mdns-proxy.c";
      __int16 v75 = 1024;
      int v76 = 2410;
      __int16 v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_129:
      int v69 = v9;
      goto LABEL_130;
    }
    uint64_t v61 = global_os_log;
    if (v63 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_131;
      }
      *(_DWORD *)int buf = 136447490;
      uint64_t v72 = "update_from_host";
      __int16 v73 = 1024;
      *(_DWORD *)uint64_t v74 = v63;
      *(_WORD *)&v74[4] = 2048;
      *(void *)&v74[6] = v5;
      *(_WORD *)&v74[14] = 2080;
      *(void *)&v74[16] = "update";
      *(_WORD *)&v74[24] = 2080;
      *(void *)&v74[26] = "srp-mdns-proxy.c";
      __int16 v75 = 1024;
      int v76 = 2410;
      __int16 v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_134:
      int v69 = v61;
      goto LABEL_130;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136447490;
      uint64_t v72 = "update_from_host";
      __int16 v73 = 1024;
      *(_DWORD *)uint64_t v74 = v63;
      *(_WORD *)&v74[4] = 2048;
      *(void *)&v74[6] = v5;
      *(_WORD *)&v74[14] = 2080;
      *(void *)&v74[16] = "update";
      *(_WORD *)&v74[24] = 2080;
      *(void *)&v74[26] = "srp-mdns-proxy.c";
      __int16 v75 = 1024;
      int v76 = 2410;
      _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      int v63 = *(_DWORD *)v5;
    }
    *(_DWORD *)uint64_t v5 = v63 - 1;
    if (v63 == 1)
    {
      os_log_type_t v64 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136447234;
        uint64_t v72 = "update_from_host";
        __int16 v73 = 2048;
        *(void *)uint64_t v74 = v5;
        *(_WORD *)&v74[8] = 2080;
        *(void *)&v74[10] = "update";
        *(_WORD *)&v74[18] = 2080;
        *(void *)&v74[20] = "srp-mdns-proxy.c";
        *(_WORD *)&v74[28] = 1024;
        *(_DWORD *)&v74[30] = 2410;
        _os_log_impl((void *)&_mh_execute_header, v64, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
      }
      ++adv_update_finalized;
      adv_update_finalize(v5);
    }
    return wait_retry(a1);
  }
  *((_DWORD *)v49 + 1) = *(_DWORD *)(*((void *)a1 + 14) + 4);
LABEL_76:
  *(void *)(v5 + 8) = a1;
  __int16 v50 = global_os_log;
  uint64_t v51 = a1;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v52 = *a1;
    *(_DWORD *)int buf = 136447490;
    uint64_t v72 = "update_from_host";
    __int16 v73 = 1024;
    *(_DWORD *)uint64_t v74 = v52;
    *(_WORD *)&v74[4] = 2048;
    *(void *)&v74[6] = a1;
    *(_WORD *)&v74[14] = 2080;
    *(void *)&v74[16] = "update->host";
    *(_WORD *)&v74[24] = 2080;
    *(void *)&v74[26] = "srp-mdns-proxy.c";
    __int16 v75 = 1024;
    int v76 = 2395;
    _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    uint64_t v51 = *(int **)(v5 + 8);
  }
  int v53 = *v51;
  if (*v51)
  {
    int v54 = v53 + 1;
    *uint64_t v51 = v53 + 1;
    if (v53 + 1 >= 10001)
    {
      uint64_t v65 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_131;
      }
      *(_DWORD *)int buf = 136447490;
      uint64_t v72 = "update_from_host";
      __int16 v73 = 1024;
      *(_DWORD *)uint64_t v74 = v54;
      *(_WORD *)&v74[4] = 2048;
      *(void *)&v74[6] = v51;
      *(_WORD *)&v74[14] = 2080;
      *(void *)&v74[16] = "update->host";
      *(_WORD *)&v74[24] = 2080;
      *(void *)&v74[26] = "srp-mdns-proxy.c";
      __int16 v75 = 1024;
      int v76 = 2395;
      __int16 v10 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_120;
    }
  }
  else
  {
    ++adv_host_created;
    *uint64_t v51 = 1;
  }
  *(void *)(v5 + 104) = *((void *)a1 + 31);
  *(void *)(v5 + 112) = *((void *)a1 + 32);
  *((void *)a1 + 6) = v5;
  unsigned int v55 = global_os_log;
  __int16 v56 = (int *)v5;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v57 = *(_DWORD *)v5;
    *(_DWORD *)int buf = 136447490;
    uint64_t v72 = "update_from_host";
    __int16 v73 = 1024;
    *(_DWORD *)uint64_t v74 = v57;
    *(_WORD *)&v74[4] = 2048;
    *(void *)&v74[6] = v5;
    *(_WORD *)&v74[14] = 2080;
    *(void *)&v74[16] = "host->update";
    *(_WORD *)&v74[24] = 2080;
    *(void *)&v74[26] = "srp-mdns-proxy.c";
    __int16 v75 = 1024;
    int v76 = 2402;
    _os_log_impl((void *)&_mh_execute_header, v55, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    __int16 v56 = (int *)*((void *)a1 + 6);
  }
  int v58 = *v56;
  if (*v56)
  {
    int v59 = v58 + 1;
    *__int16 v56 = v58 + 1;
    if (v58 + 1 >= 10001)
    {
      uint64_t v65 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_131;
      }
      *(_DWORD *)int buf = 136447490;
      uint64_t v72 = "update_from_host";
      __int16 v73 = 1024;
      *(_DWORD *)uint64_t v74 = v59;
      *(_WORD *)&v74[4] = 2048;
      *(void *)&v74[6] = v56;
      *(_WORD *)&v74[14] = 2080;
      *(void *)&v74[16] = "host->update";
      *(_WORD *)&v74[24] = 2080;
      *(void *)&v74[26] = "srp-mdns-proxy.c";
      __int16 v75 = 1024;
      int v76 = 2402;
      __int16 v10 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_120;
    }
  }
  else
  {
    ++adv_update_created;
    *__int16 v56 = 1;
  }
  int v60 = *(_DWORD *)v5;
  if (!*(_DWORD *)v5)
  {
    uint64_t v9 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_131;
    }
    *(_DWORD *)int buf = 136447490;
    uint64_t v72 = "update_from_host";
    __int16 v73 = 1024;
    *(_DWORD *)uint64_t v74 = 0;
    *(_WORD *)&v74[4] = 2048;
    *(void *)&v74[6] = v5;
    *(_WORD *)&v74[14] = 2080;
    *(void *)&v74[16] = "update";
    *(_WORD *)&v74[24] = 2080;
    *(void *)&v74[26] = "srp-mdns-proxy.c";
    __int16 v75 = 1024;
    int v76 = 2403;
    __int16 v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_129;
  }
  uint64_t v61 = global_os_log;
  if (v60 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_131;
    }
    *(_DWORD *)int buf = 136447490;
    uint64_t v72 = "update_from_host";
    __int16 v73 = 1024;
    *(_DWORD *)uint64_t v74 = v60;
    *(_WORD *)&v74[4] = 2048;
    *(void *)&v74[6] = v5;
    *(_WORD *)&v74[14] = 2080;
    *(void *)&v74[16] = "update";
    *(_WORD *)&v74[24] = 2080;
    *(void *)&v74[26] = "srp-mdns-proxy.c";
    __int16 v75 = 1024;
    int v76 = 2403;
    __int16 v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_134;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136447490;
    uint64_t v72 = "update_from_host";
    __int16 v73 = 1024;
    *(_DWORD *)uint64_t v74 = v60;
    *(_WORD *)&v74[4] = 2048;
    *(void *)&v74[6] = v5;
    *(_WORD *)&v74[14] = 2080;
    *(void *)&v74[16] = "update";
    *(_WORD *)&v74[24] = 2080;
    *(void *)&v74[26] = "srp-mdns-proxy.c";
    __int16 v75 = 1024;
    int v76 = 2403;
    _os_log_impl((void *)&_mh_execute_header, v61, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    int v60 = *(_DWORD *)v5;
  }
  *(_DWORD *)uint64_t v5 = v60 - 1;
  if (v60 == 1)
  {
    int v62 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136447234;
      uint64_t v72 = "update_from_host";
      __int16 v73 = 2048;
      *(void *)uint64_t v74 = v5;
      *(_WORD *)&v74[8] = 2080;
      *(void *)&v74[10] = "update";
      *(_WORD *)&v74[18] = 2080;
      *(void *)&v74[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v74[28] = 1024;
      *(_DWORD *)&v74[30] = 2403;
      _os_log_impl((void *)&_mh_execute_header, v62, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
    }
    ++adv_update_finalized;
    adv_update_finalize(v5);
  }
  return start_host_update(a1);
}

void adv_update_cancel(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 8);
  uint64_t v3 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *(_DWORD *)a1;
    *(_DWORD *)int buf = 136447490;
    int v59 = "adv_update_cancel";
    __int16 v60 = 1024;
    *(_DWORD *)uint64_t v61 = v4;
    *(_WORD *)&uint8_t v61[4] = 2048;
    *(void *)&v61[6] = a1;
    *(_WORD *)&v61[14] = 2080;
    *(void *)&v61[16] = "update";
    *(_WORD *)&v61[24] = 2080;
    *(void *)&v61[26] = "srp-mdns-proxy.c";
    __int16 v62 = 1024;
    int v63 = 947;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  int v5 = *(_DWORD *)a1;
  if (*(_DWORD *)a1)
  {
    int v6 = v5 + 1;
    *(_DWORD *)a1 = v5 + 1;
    if (v5 + 1 >= 10001)
    {
      int v7 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_174;
      }
      *(_DWORD *)int buf = 136447490;
      int v59 = "adv_update_cancel";
      __int16 v60 = 1024;
      *(_DWORD *)uint64_t v61 = v6;
      *(_WORD *)&uint8_t v61[4] = 2048;
      *(void *)&v61[6] = a1;
      *(_WORD *)&v61[14] = 2080;
      *(void *)&v61[16] = "update";
      *(_WORD *)&v61[24] = 2080;
      *(void *)&v61[26] = "srp-mdns-proxy.c";
      __int16 v62 = 1024;
      int v63 = 947;
      int v8 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_172;
    }
  }
  else
  {
    ++adv_update_created;
    *(_DWORD *)a1 = 1;
  }
  uint64_t v9 = global_os_log;
  BOOL v10 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (v2)
  {
    if (v10)
    {
      int v11 = *(_DWORD *)v2;
      *(_DWORD *)int buf = 136447490;
      int v59 = "adv_update_cancel";
      __int16 v60 = 1024;
      *(_DWORD *)uint64_t v61 = v11;
      *(_WORD *)&uint8_t v61[4] = 2048;
      *(void *)&v61[6] = v2;
      *(_WORD *)&v61[14] = 2080;
      *(void *)&v61[16] = "host";
      *(_WORD *)&v61[24] = 2080;
      *(void *)&v61[26] = "srp-mdns-proxy.c";
      __int16 v62 = 1024;
      int v63 = 950;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    int v12 = *(_DWORD *)v2;
    if (*(_DWORD *)v2)
    {
      int v13 = v12 + 1;
      *(_DWORD *)uint64_t v2 = v12 + 1;
      if (v12 + 1 >= 10001)
      {
        uint64_t v14 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_174;
        }
        *(_DWORD *)int buf = 136447490;
        int v59 = "adv_update_cancel";
        __int16 v60 = 1024;
        *(_DWORD *)uint64_t v61 = v13;
        *(_WORD *)&uint8_t v61[4] = 2048;
        *(void *)&v61[6] = v2;
        *(_WORD *)&v61[14] = 2080;
        *(void *)&v61[16] = "host";
        *(_WORD *)&v61[24] = 2080;
        *(void *)&v61[26] = "srp-mdns-proxy.c";
        __int16 v62 = 1024;
        int v63 = 950;
        int v8 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_167:
        int v57 = v14;
        goto LABEL_173;
      }
    }
    else
    {
      ++adv_host_created;
      *(_DWORD *)uint64_t v2 = 1;
    }
    int v15 = *(int **)(a1 + 8);
    if (v15)
    {
      int v16 = *v15;
      if (!*v15)
      {
        uint64_t v14 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_174;
        }
        *(_DWORD *)int buf = 136447490;
        int v59 = "adv_update_cancel";
        __int16 v60 = 1024;
        *(_DWORD *)uint64_t v61 = 0;
        *(_WORD *)&uint8_t v61[4] = 2048;
        *(void *)&v61[6] = v15;
        *(_WORD *)&v61[14] = 2080;
        *(void *)&v61[16] = "update->host";
        *(_WORD *)&v61[24] = 2080;
        *(void *)&v61[26] = "srp-mdns-proxy.c";
        __int16 v62 = 1024;
        int v63 = 951;
        int v8 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_167;
      }
      int v17 = global_os_log;
      if (v16 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_174;
        }
        *(_DWORD *)int buf = 136447490;
        int v59 = "adv_update_cancel";
        __int16 v60 = 1024;
        *(_DWORD *)uint64_t v61 = v16;
        *(_WORD *)&uint8_t v61[4] = 2048;
        *(void *)&v61[6] = v15;
        *(_WORD *)&v61[14] = 2080;
        *(void *)&v61[16] = "update->host";
        *(_WORD *)&v61[24] = 2080;
        *(void *)&v61[26] = "srp-mdns-proxy.c";
        __int16 v62 = 1024;
        int v63 = 951;
        int v8 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_164;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136447490;
        int v59 = "adv_update_cancel";
        __int16 v60 = 1024;
        *(_DWORD *)uint64_t v61 = v16;
        *(_WORD *)&uint8_t v61[4] = 2048;
        *(void *)&v61[6] = v15;
        *(_WORD *)&v61[14] = 2080;
        *(void *)&v61[16] = "update->host";
        *(_WORD *)&v61[24] = 2080;
        *(void *)&v61[26] = "srp-mdns-proxy.c";
        __int16 v62 = 1024;
        int v63 = 951;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        int v15 = *(int **)(a1 + 8);
        int v16 = *v15;
      }
      *int v15 = v16 - 1;
      if (v16 == 1)
      {
        uint64_t v18 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447234;
          int v59 = "adv_update_cancel";
          __int16 v60 = 2048;
          *(void *)uint64_t v61 = v15;
          *(_WORD *)&v61[8] = 2080;
          *(void *)&v61[10] = "update->host";
          *(_WORD *)&v61[18] = 2080;
          *(void *)&v61[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v61[28] = 1024;
          *(_DWORD *)&v61[30] = 951;
          _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          int v15 = *(int **)(a1 + 8);
        }
        ++adv_host_finalized;
        adv_host_finalize((uint64_t)v15);
      }
    }
    *(void *)(a1 + 8) = 0;
    int v19 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = *(void *)(v2 + 64);
      *(_DWORD *)int buf = 136446979;
      int v59 = "adv_update_cancel";
      __int16 v60 = 2048;
      *(void *)uint64_t v61 = a1;
      *(_WORD *)&v61[8] = 2160;
      *(void *)&v61[10] = 1752392040;
      *(_WORD *)&v61[18] = 2081;
      *(void *)&v61[20] = v20;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%{public}s: cancelling update %p for host %{private, mask.hash}s", buf, 0x2Au);
    }
    if (*(void *)(v2 + 48) == a1)
    {
      int v21 = *(_DWORD *)a1;
      if (!*(_DWORD *)a1)
      {
        int v7 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_174;
        }
        *(_DWORD *)int buf = 136447490;
        int v59 = "adv_update_cancel";
        __int16 v60 = 1024;
        *(_DWORD *)uint64_t v61 = 0;
        *(_WORD *)&uint8_t v61[4] = 2048;
        *(void *)&v61[6] = a1;
        *(_WORD *)&v61[14] = 2080;
        *(void *)&v61[16] = "host->update";
        *(_WORD *)&v61[24] = 2080;
        *(void *)&v61[26] = "srp-mdns-proxy.c";
        __int16 v62 = 1024;
        int v63 = 957;
        int v8 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_172;
      }
      uint64_t v22 = global_os_log;
      if (v21 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_174;
        }
        *(_DWORD *)int buf = 136447490;
        int v59 = "adv_update_cancel";
        __int16 v60 = 1024;
        *(_DWORD *)uint64_t v61 = v21;
        *(_WORD *)&uint8_t v61[4] = 2048;
        *(void *)&v61[6] = a1;
        *(_WORD *)&v61[14] = 2080;
        *(void *)&v61[16] = "host->update";
        *(_WORD *)&v61[24] = 2080;
        *(void *)&v61[26] = "srp-mdns-proxy.c";
        __int16 v62 = 1024;
        int v63 = 957;
        int v8 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_177;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136447490;
        int v59 = "adv_update_cancel";
        __int16 v60 = 1024;
        *(_DWORD *)uint64_t v61 = v21;
        *(_WORD *)&uint8_t v61[4] = 2048;
        *(void *)&v61[6] = a1;
        *(_WORD *)&v61[14] = 2080;
        *(void *)&v61[16] = "host->update";
        *(_WORD *)&v61[24] = 2080;
        *(void *)&v61[26] = "srp-mdns-proxy.c";
        __int16 v62 = 1024;
        int v63 = 957;
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        uint64_t v23 = *(int **)(v2 + 48);
        int v21 = *v23;
      }
      else
      {
        uint64_t v23 = (int *)a1;
      }
      *uint64_t v23 = v21 - 1;
      if (v21 == 1)
      {
        __int16 v24 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447234;
          int v59 = "adv_update_cancel";
          __int16 v60 = 2048;
          *(void *)uint64_t v61 = v23;
          *(_WORD *)&v61[8] = 2080;
          *(void *)&v61[10] = "host->update";
          *(_WORD *)&v61[18] = 2080;
          *(void *)&v61[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v61[28] = 1024;
          *(_DWORD *)&v61[30] = 957;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          uint64_t v23 = *(int **)(v2 + 48);
        }
        ++adv_update_finalized;
        adv_update_finalize((uint64_t)v23);
      }
      *(void *)(v2 + 48) = 0;
    }
    uint64_t v25 = *(void *)(v2 + 96);
    if (v25 && *(int *)(v25 + 4) >= 1)
    {
      for (uint64_t i = 0; i < *(int *)(v25 + 4); ++i)
      {
        uint64_t v27 = *(void *)(*(void *)(v25 + 8) + 8 * i);
        if (*(void *)(v27 + 32) == a1)
        {
          int v28 = *(_DWORD *)a1;
          if (!*(_DWORD *)a1)
          {
            int v7 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
              goto LABEL_174;
            }
            *(_DWORD *)int buf = 136447490;
            int v59 = "adv_update_cancel";
            __int16 v60 = 1024;
            *(_DWORD *)uint64_t v61 = 0;
            *(_WORD *)&uint8_t v61[4] = 2048;
            *(void *)&v61[6] = a1;
            *(_WORD *)&v61[14] = 2080;
            *(void *)&v61[16] = "host->addresses->vec[i]->update";
            *(_WORD *)&v61[24] = 2080;
            *(void *)&v61[26] = "srp-mdns-proxy.c";
            __int16 v62 = 1024;
            int v63 = 966;
            int v8 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
            goto LABEL_172;
          }
          int v29 = global_os_log;
          if (v28 >= 10001)
          {
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)int buf = 136447490;
              int v59 = "adv_update_cancel";
              __int16 v60 = 1024;
              *(_DWORD *)uint64_t v61 = v28;
              *(_WORD *)&uint8_t v61[4] = 2048;
              *(void *)&v61[6] = a1;
              *(_WORD *)&v61[14] = 2080;
              *(void *)&v61[16] = "host->addresses->vec[i]->update";
              *(_WORD *)&v61[24] = 2080;
              *(void *)&v61[26] = "srp-mdns-proxy.c";
              __int16 v62 = 1024;
              int v63 = 966;
              int v8 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
              int v57 = v29;
              goto LABEL_173;
            }
LABEL_174:
            abort();
          }
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136447490;
            int v59 = "adv_update_cancel";
            __int16 v60 = 1024;
            *(_DWORD *)uint64_t v61 = v28;
            *(_WORD *)&uint8_t v61[4] = 2048;
            *(void *)&v61[6] = a1;
            *(_WORD *)&v61[14] = 2080;
            *(void *)&v61[16] = "host->addresses->vec[i]->update";
            *(_WORD *)&v61[24] = 2080;
            *(void *)&v61[26] = "srp-mdns-proxy.c";
            __int16 v62 = 1024;
            int v63 = 966;
            _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
            uint64_t v25 = *(void *)(v2 + 96);
            uint64_t v30 = *(int **)(*(void *)(*(void *)(v25 + 8) + 8 * i) + 32);
            int v28 = *v30;
          }
          else
          {
            uint64_t v30 = (int *)a1;
          }
          int *v30 = v28 - 1;
          if (v28 == 1)
          {
            uint64_t v31 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)int buf = 136447234;
              int v59 = "adv_update_cancel";
              __int16 v60 = 2048;
              *(void *)uint64_t v61 = v30;
              *(_WORD *)&v61[8] = 2080;
              *(void *)&v61[10] = "host->addresses->vec[i]->update";
              *(_WORD *)&v61[18] = 2080;
              *(void *)&v61[20] = "srp-mdns-proxy.c";
              *(_WORD *)&v61[28] = 1024;
              *(_DWORD *)&v61[30] = 966;
              _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
              uint64_t v30 = *(int **)(*(void *)(*(void *)(*(void *)(v2 + 96) + 8) + 8 * i) + 32);
            }
            ++adv_update_finalized;
            adv_update_finalize((uint64_t)v30);
            uint64_t v25 = *(void *)(v2 + 96);
          }
          *(void *)(v27 + 32) = 0;
        }
      }
    }
  }
  else if (v10)
  {
    *(_DWORD *)int buf = 136446210;
    int v59 = "adv_update_cancel";
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: canceling update with no host.", buf, 0xCu);
  }
  adv_update_free_instance_vectors(a1);
  uint64_t v32 = *(void *)(a1 + 40);
  if (v32)
  {
    if (*(int *)(v32 + 4) < 1)
    {
      char v34 = 0;
    }
    else
    {
      uint64_t v33 = 0;
      char v34 = 0;
      do
      {
        uint64_t v35 = *(void *)(*(void *)(v32 + 8) + 8 * v33);
        if (v35)
        {
          if (v2)
          {
            if (*(void *)(v35 + 8)) {
              srp_mdns_shared_record_remove(*(void *)(v2 + 8), v35);
            }
          }
          else if ((v34 & 1) == 0)
          {
            __int16 v36 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)int buf = 136446210;
              int v59 = "adv_update_cancel";
              _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_FAULT, "%{public}s: unable to clean up host address registration because host object is gone from update.", buf, 0xCu);
            }
            char v34 = 1;
          }
        }
        ++v33;
        uint64_t v32 = *(void *)(a1 + 40);
      }
      while (v33 < *(int *)(v32 + 4));
    }
    adv_record_vec_remove_update(v32, (int *)a1);
    int v38 = *(int **)(a1 + 40);
    if (v38)
    {
      int v39 = *v38;
      if (!*v38)
      {
        uint64_t v14 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_174;
        }
        *(_DWORD *)int buf = 136447490;
        int v59 = "adv_update_cancel";
        __int16 v60 = 1024;
        *(_DWORD *)uint64_t v61 = 0;
        *(_WORD *)&uint8_t v61[4] = 2048;
        *(void *)&v61[6] = v38;
        *(_WORD *)&v61[14] = 2080;
        *(void *)&v61[16] = "update->add_addresses";
        *(_WORD *)&v61[24] = 2080;
        *(void *)&v61[26] = "srp-mdns-proxy.c";
        __int16 v62 = 1024;
        int v63 = 995;
        int v8 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_167;
      }
      int v17 = global_os_log;
      if (v39 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_174;
        }
        *(_DWORD *)int buf = 136447490;
        int v59 = "adv_update_cancel";
        __int16 v60 = 1024;
        *(_DWORD *)uint64_t v61 = v39;
        *(_WORD *)&uint8_t v61[4] = 2048;
        *(void *)&v61[6] = v38;
        *(_WORD *)&v61[14] = 2080;
        *(void *)&v61[16] = "update->add_addresses";
        *(_WORD *)&v61[24] = 2080;
        *(void *)&v61[26] = "srp-mdns-proxy.c";
        __int16 v62 = 1024;
        int v63 = 995;
        int v8 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_164;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136447490;
        int v59 = "adv_update_cancel";
        __int16 v60 = 1024;
        *(_DWORD *)uint64_t v61 = v39;
        *(_WORD *)&uint8_t v61[4] = 2048;
        *(void *)&v61[6] = v38;
        *(_WORD *)&v61[14] = 2080;
        *(void *)&v61[16] = "update->add_addresses";
        *(_WORD *)&v61[24] = 2080;
        *(void *)&v61[26] = "srp-mdns-proxy.c";
        __int16 v62 = 1024;
        int v63 = 995;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        int v38 = *(int **)(a1 + 40);
        int v39 = *v38;
      }
      int *v38 = v39 - 1;
      if (v39 == 1)
      {
        int v40 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447234;
          int v59 = "adv_update_cancel";
          __int16 v60 = 2048;
          *(void *)uint64_t v61 = v38;
          *(_WORD *)&v61[8] = 2080;
          *(void *)&v61[10] = "update->add_addresses";
          *(_WORD *)&v61[18] = 2080;
          *(void *)&v61[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v61[28] = 1024;
          *(_DWORD *)&v61[30] = 995;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          int v38 = *(int **)(a1 + 40);
        }
        ++adv_record_vec_finalized;
        adv_record_vec_finalize((uint64_t)v38);
      }
    }
    *(void *)(a1 + 40) = 0;
    char v37 = v34 & 1;
  }
  else
  {
    char v37 = 0;
  }
  uint64_t v41 = *(void *)(a1 + 32);
  if (v41)
  {
    adv_record_vec_remove_update(v41, (int *)a1);
    uint64_t v42 = *(int **)(a1 + 32);
    if (v42)
    {
      int v43 = *v42;
      if (!*v42)
      {
        uint64_t v14 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_174;
        }
        *(_DWORD *)int buf = 136447490;
        int v59 = "adv_update_cancel";
        __int16 v60 = 1024;
        *(_DWORD *)uint64_t v61 = 0;
        *(_WORD *)&uint8_t v61[4] = 2048;
        *(void *)&v61[6] = v42;
        *(_WORD *)&v61[14] = 2080;
        *(void *)&v61[16] = "update->remove_addresses";
        *(_WORD *)&v61[24] = 2080;
        *(void *)&v61[26] = "srp-mdns-proxy.c";
        __int16 v62 = 1024;
        int v63 = 1001;
        int v8 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_167;
      }
      int v17 = global_os_log;
      if (v43 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_174;
        }
        *(_DWORD *)int buf = 136447490;
        int v59 = "adv_update_cancel";
        __int16 v60 = 1024;
        *(_DWORD *)uint64_t v61 = v43;
        *(_WORD *)&uint8_t v61[4] = 2048;
        *(void *)&v61[6] = v42;
        *(_WORD *)&v61[14] = 2080;
        *(void *)&v61[16] = "update->remove_addresses";
        *(_WORD *)&v61[24] = 2080;
        *(void *)&v61[26] = "srp-mdns-proxy.c";
        __int16 v62 = 1024;
        int v63 = 1001;
        int v8 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_164;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136447490;
        int v59 = "adv_update_cancel";
        __int16 v60 = 1024;
        *(_DWORD *)uint64_t v61 = v43;
        *(_WORD *)&uint8_t v61[4] = 2048;
        *(void *)&v61[6] = v42;
        *(_WORD *)&v61[14] = 2080;
        *(void *)&v61[16] = "update->remove_addresses";
        *(_WORD *)&v61[24] = 2080;
        *(void *)&v61[26] = "srp-mdns-proxy.c";
        __int16 v62 = 1024;
        int v63 = 1001;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        uint64_t v42 = *(int **)(a1 + 32);
        int v43 = *v42;
      }
      *uint64_t v42 = v43 - 1;
      if (v43 == 1)
      {
        BOOL v44 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447234;
          int v59 = "adv_update_cancel";
          __int16 v60 = 2048;
          *(void *)uint64_t v61 = v42;
          *(_WORD *)&v61[8] = 2080;
          *(void *)&v61[10] = "update->remove_addresses";
          *(_WORD *)&v61[18] = 2080;
          *(void *)&v61[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v61[28] = 1024;
          *(_DWORD *)&v61[30] = 1001;
          _os_log_impl((void *)&_mh_execute_header, v44, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          uint64_t v42 = *(int **)(a1 + 32);
        }
        ++adv_record_vec_finalized;
        adv_record_vec_finalize((uint64_t)v42);
      }
    }
    *(void *)(a1 + 32) = 0;
  }
  uint64_t v45 = *(void *)(a1 + 48);
  if (!v45) {
    goto LABEL_118;
  }
  int v46 = *(int **)(v45 + 32);
  if (v46)
  {
    int v47 = *v46;
    if (!*v46)
    {
      uint64_t v14 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_174;
      }
      *(_DWORD *)int buf = 136447490;
      int v59 = "adv_update_cancel";
      __int16 v60 = 1024;
      *(_DWORD *)uint64_t v61 = 0;
      *(_WORD *)&uint8_t v61[4] = 2048;
      *(void *)&v61[6] = v46;
      *(_WORD *)&v61[14] = 2080;
      *(void *)&v61[16] = "update->key->update";
      *(_WORD *)&v61[24] = 2080;
      *(void *)&v61[26] = "srp-mdns-proxy.c";
      __int16 v62 = 1024;
      int v63 = 1007;
      int v8 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_167;
    }
    uint64_t v48 = global_os_log;
    if (v47 >= 10001)
    {
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_174;
      }
      *(_DWORD *)int buf = 136447490;
      int v59 = "adv_update_cancel";
      __int16 v60 = 1024;
      *(_DWORD *)uint64_t v61 = v47;
      *(_WORD *)&uint8_t v61[4] = 2048;
      *(void *)&v61[6] = v46;
      *(_WORD *)&v61[14] = 2080;
      *(void *)&v61[16] = "update->key->update";
      *(_WORD *)&v61[24] = 2080;
      *(void *)&v61[26] = "srp-mdns-proxy.c";
      __int16 v62 = 1024;
      int v63 = 1007;
      int v8 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
      int v57 = v48;
      goto LABEL_173;
    }
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136447490;
      int v59 = "adv_update_cancel";
      __int16 v60 = 1024;
      *(_DWORD *)uint64_t v61 = v47;
      *(_WORD *)&uint8_t v61[4] = 2048;
      *(void *)&v61[6] = v46;
      *(_WORD *)&v61[14] = 2080;
      *(void *)&v61[16] = "update->key->update";
      *(_WORD *)&v61[24] = 2080;
      *(void *)&v61[26] = "srp-mdns-proxy.c";
      __int16 v62 = 1024;
      int v63 = 1007;
      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      uint64_t v45 = *(void *)(a1 + 48);
      int v46 = *(int **)(v45 + 32);
      int v47 = *v46;
    }
    *int v46 = v47 - 1;
    if (v47 == 1)
    {
      uint64_t v49 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136447234;
        int v59 = "adv_update_cancel";
        __int16 v60 = 2048;
        *(void *)uint64_t v61 = v46;
        *(_WORD *)&v61[8] = 2080;
        *(void *)&v61[10] = "update->key->update";
        *(_WORD *)&v61[18] = 2080;
        *(void *)&v61[20] = "srp-mdns-proxy.c";
        *(_WORD *)&v61[28] = 1024;
        *(_DWORD *)&v61[30] = 1007;
        _os_log_impl((void *)&_mh_execute_header, v49, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        int v46 = *(int **)(*(void *)(a1 + 48) + 32);
      }
      ++adv_update_finalized;
      adv_update_finalize((uint64_t)v46);
      uint64_t v45 = *(void *)(a1 + 48);
    }
    *(void *)(v45 + 32) = 0;
  }
  if (!*(void *)(v45 + 8)) {
    goto LABEL_109;
  }
  if (v2)
  {
    srp_mdns_shared_record_remove(*(void *)(v2 + 8), v45);
  }
  else if ((v37 & 1) == 0)
  {
    __int16 v50 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)int buf = 136446210;
      int v59 = "adv_update_cancel";
      _os_log_impl((void *)&_mh_execute_header, v50, OS_LOG_TYPE_FAULT, "%{public}s: unable to clean up host key registration because host object is gone from update.", buf, 0xCu);
    }
  }
  uint64_t v45 = *(void *)(a1 + 48);
  if (v45)
  {
LABEL_109:
    int v51 = *(_DWORD *)v45;
    if (!*(_DWORD *)v45)
    {
      uint64_t v14 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_174;
      }
      *(_DWORD *)int buf = 136447490;
      int v59 = "adv_update_cancel";
      __int16 v60 = 1024;
      *(_DWORD *)uint64_t v61 = 0;
      *(_WORD *)&uint8_t v61[4] = 2048;
      *(void *)&v61[6] = v45;
      *(_WORD *)&v61[14] = 2080;
      *(void *)&v61[16] = "update->key";
      *(_WORD *)&v61[24] = 2080;
      *(void *)&v61[26] = "srp-mdns-proxy.c";
      __int16 v62 = 1024;
      int v63 = 1021;
      int v8 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      goto LABEL_167;
    }
    int v17 = global_os_log;
    if (v51 < 10001)
    {
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136447490;
        int v59 = "adv_update_cancel";
        __int16 v60 = 1024;
        *(_DWORD *)uint64_t v61 = v51;
        *(_WORD *)&uint8_t v61[4] = 2048;
        *(void *)&v61[6] = v45;
        *(_WORD *)&v61[14] = 2080;
        *(void *)&v61[16] = "update->key";
        *(_WORD *)&v61[24] = 2080;
        *(void *)&v61[26] = "srp-mdns-proxy.c";
        __int16 v62 = 1024;
        int v63 = 1021;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        uint64_t v45 = *(void *)(a1 + 48);
        int v51 = *(_DWORD *)v45;
      }
      *(_DWORD *)uint64_t v45 = v51 - 1;
      if (v51 == 1)
      {
        int v52 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447234;
          int v59 = "adv_update_cancel";
          __int16 v60 = 2048;
          *(void *)uint64_t v61 = v45;
          *(_WORD *)&v61[8] = 2080;
          *(void *)&v61[10] = "update->key";
          *(_WORD *)&v61[18] = 2080;
          *(void *)&v61[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v61[28] = 1024;
          *(_DWORD *)&v61[30] = 1021;
          _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          uint64_t v45 = *(void *)(a1 + 48);
        }
        ++adv_record_finalized;
        adv_record_finalize(v45);
      }
      goto LABEL_117;
    }
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_174;
    }
    *(_DWORD *)int buf = 136447490;
    int v59 = "adv_update_cancel";
    __int16 v60 = 1024;
    *(_DWORD *)uint64_t v61 = v51;
    *(_WORD *)&uint8_t v61[4] = 2048;
    *(void *)&v61[6] = v45;
    *(_WORD *)&v61[14] = 2080;
    *(void *)&v61[16] = "update->key";
    *(_WORD *)&v61[24] = 2080;
    *(void *)&v61[26] = "srp-mdns-proxy.c";
    __int16 v62 = 1024;
    int v63 = 1021;
    int v8 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_164:
    int v57 = v17;
LABEL_173:
    _os_log_impl((void *)&_mh_execute_header, v57, OS_LOG_TYPE_FAULT, v8, buf, 0x36u);
    goto LABEL_174;
  }
LABEL_117:
  *(void *)(a1 + 48) = 0;
LABEL_118:
  if (!v2) {
    goto LABEL_127;
  }
  int v53 = *(_DWORD *)v2;
  if (!*(_DWORD *)v2)
  {
    uint64_t v14 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_174;
    }
    *(_DWORD *)int buf = 136447490;
    int v59 = "adv_update_cancel";
    __int16 v60 = 1024;
    *(_DWORD *)uint64_t v61 = 0;
    *(_WORD *)&uint8_t v61[4] = 2048;
    *(void *)&v61[6] = v2;
    *(_WORD *)&v61[14] = 2080;
    *(void *)&v61[16] = "host";
    *(_WORD *)&v61[24] = 2080;
    *(void *)&v61[26] = "srp-mdns-proxy.c";
    __int16 v62 = 1024;
    int v63 = 1025;
    int v8 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_167;
  }
  uint64_t v22 = global_os_log;
  if (v53 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_174;
    }
    *(_DWORD *)int buf = 136447490;
    int v59 = "adv_update_cancel";
    __int16 v60 = 1024;
    *(_DWORD *)uint64_t v61 = v53;
    *(_WORD *)&uint8_t v61[4] = 2048;
    *(void *)&v61[6] = v2;
    *(_WORD *)&v61[14] = 2080;
    *(void *)&v61[16] = "host";
    *(_WORD *)&v61[24] = 2080;
    *(void *)&v61[26] = "srp-mdns-proxy.c";
    __int16 v62 = 1024;
    int v63 = 1025;
    int v8 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_177:
    int v57 = v22;
    goto LABEL_173;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136447490;
    int v59 = "adv_update_cancel";
    __int16 v60 = 1024;
    *(_DWORD *)uint64_t v61 = v53;
    *(_WORD *)&uint8_t v61[4] = 2048;
    *(void *)&v61[6] = v2;
    *(_WORD *)&v61[14] = 2080;
    *(void *)&v61[16] = "host";
    *(_WORD *)&v61[24] = 2080;
    *(void *)&v61[26] = "srp-mdns-proxy.c";
    __int16 v62 = 1024;
    int v63 = 1025;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    int v53 = *(_DWORD *)v2;
  }
  *(_DWORD *)uint64_t v2 = v53 - 1;
  if (v53 == 1)
  {
    int v54 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136447234;
      int v59 = "adv_update_cancel";
      __int16 v60 = 2048;
      *(void *)uint64_t v61 = v2;
      *(_WORD *)&v61[8] = 2080;
      *(void *)&v61[10] = "host";
      *(_WORD *)&v61[18] = 2080;
      *(void *)&v61[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v61[28] = 1024;
      *(_DWORD *)&v61[30] = 1025;
      _os_log_impl((void *)&_mh_execute_header, v54, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
    }
    ++adv_host_finalized;
    adv_host_finalize(v2);
  }
LABEL_127:
  int v55 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    int v7 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_174;
    }
    *(_DWORD *)int buf = 136447490;
    int v59 = "adv_update_cancel";
    __int16 v60 = 1024;
    *(_DWORD *)uint64_t v61 = 0;
    *(_WORD *)&uint8_t v61[4] = 2048;
    *(void *)&v61[6] = a1;
    *(_WORD *)&v61[14] = 2080;
    *(void *)&v61[16] = "update";
    *(_WORD *)&v61[24] = 2080;
    *(void *)&v61[26] = "srp-mdns-proxy.c";
    __int16 v62 = 1024;
    int v63 = 1027;
    int v8 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_172:
    int v57 = v7;
    goto LABEL_173;
  }
  int v7 = global_os_log;
  if (v55 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_174;
    }
    *(_DWORD *)int buf = 136447490;
    int v59 = "adv_update_cancel";
    __int16 v60 = 1024;
    *(_DWORD *)uint64_t v61 = v55;
    *(_WORD *)&uint8_t v61[4] = 2048;
    *(void *)&v61[6] = a1;
    *(_WORD *)&v61[14] = 2080;
    *(void *)&v61[16] = "update";
    *(_WORD *)&v61[24] = 2080;
    *(void *)&v61[26] = "srp-mdns-proxy.c";
    __int16 v62 = 1024;
    int v63 = 1027;
    int v8 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_172;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136447490;
    int v59 = "adv_update_cancel";
    __int16 v60 = 1024;
    *(_DWORD *)uint64_t v61 = v55;
    *(_WORD *)&uint8_t v61[4] = 2048;
    *(void *)&v61[6] = a1;
    *(_WORD *)&v61[14] = 2080;
    *(void *)&v61[16] = "update";
    *(_WORD *)&v61[24] = 2080;
    *(void *)&v61[26] = "srp-mdns-proxy.c";
    __int16 v62 = 1024;
    int v63 = 1027;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    int v55 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v55 - 1;
  if (v55 == 1)
  {
    __int16 v56 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136447234;
      int v59 = "adv_update_cancel";
      __int16 v60 = 2048;
      *(void *)uint64_t v61 = a1;
      *(_WORD *)&v61[8] = 2080;
      *(void *)&v61[10] = "update";
      *(_WORD *)&v61[18] = 2080;
      *(void *)&v61[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v61[28] = 1024;
      *(_DWORD *)&v61[30] = 1027;
      _os_log_impl((void *)&_mh_execute_header, v56, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
    }
    ++adv_update_finalized;
    adv_update_finalize(a1);
  }
}

void *host_ready(uint64_t a1)
{
  uint64_t v2 = (void *)(*(void *)(a1 + 8) + 8);
  do
  {
    BOOL result = v2;
    uint64_t v4 = *v2;
    uint64_t v2 = (void *)(*v2 + 40);
    if (v4) {
      BOOL v5 = v4 == a1;
    }
    else {
      BOOL v5 = 1;
    }
  }
  while (!v5);
  if (v4)
  {
    if (*(void *)(a1 + 48))
    {
      int v6 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = *(void *)(a1 + 64);
        *(_DWORD *)int buf = 136446723;
        *(void *)&uint8_t buf[4] = "host_ready";
        *(_WORD *)&unsigned char buf[12] = 2160;
        *(void *)&buf[14] = 1752392040;
        *(_WORD *)&unsigned char buf[22] = 2081;
        *(void *)&unsigned char buf[24] = v7;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: reached with pending updates on host %{private, mask.hash}s.", buf, 0x20u);
      }
      ioloop_add_wake_event(*(void *)(a1 + 32), a1, (uint64_t)lease_callback, (uint64_t)srp_adv_host_context_release, 0x2710u);
      int v8 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v9 = *(_DWORD *)a1;
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "host_ready";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v9;
        *(_WORD *)&unsigned char buf[18] = 2048;
        *(void *)&buf[20] = a1;
        *(_WORD *)&buf[28] = 2080;
        *(void *)&buf[30] = "host";
        __int16 v15 = 2080;
        int v16 = "srp-mdns-proxy.c";
        __int16 v17 = 1024;
        int v18 = 1274;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      }
      if (*(_DWORD *)a1)
      {
        int v10 = *(_DWORD *)a1 + 1;
        *(_DWORD *)a1 = v10;
        if (v10 >= 10001)
        {
          int v13 = v10;
          int v11 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "host_ready";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v13;
            *(_WORD *)&unsigned char buf[18] = 2048;
            *(void *)&buf[20] = a1;
            *(_WORD *)&buf[28] = 2080;
            *(void *)&buf[30] = "host";
            __int16 v15 = 2080;
            int v16 = "srp-mdns-proxy.c";
            __int16 v17 = 1024;
            int v18 = 1274;
            _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          }
          abort();
        }
      }
      else
      {
        ++adv_host_created;
        *(_DWORD *)a1 = 1;
      }
      *(void *)int buf = 0;
      *(void *)&buf[8] = 0;
      gettimeofday((timeval *)buf, 0);
      BOOL result = 0;
      *(void *)(a1 + 256) = 1000 * *(void *)buf + *(_DWORD *)&buf[8] / 1000 + 10000;
    }
  }
  else
  {
    int v12 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "host_ready";
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%{public}s: called with nonexistent host.", buf, 0xCu);
    }
    return 0;
  }
  return result;
}

void host_remove(int *a1)
{
  host_invalidate((uint64_t)a1);
  if (!a1) {
    return;
  }
  int v2 = *a1;
  if (!*a1)
  {
    uint64_t v3 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v6 = 136447490;
    uint64_t v7 = "host_remove";
    __int16 v8 = 1024;
    *(_DWORD *)int v9 = 0;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "host";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "srp-mdns-proxy.c";
    __int16 v10 = 1024;
    int v11 = 1249;
    BOOL v5 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  uint64_t v3 = global_os_log;
  if (v2 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v6 = 136447490;
    uint64_t v7 = "host_remove";
    __int16 v8 = 1024;
    *(_DWORD *)int v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "host";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "srp-mdns-proxy.c";
    __int16 v10 = 1024;
    int v11 = 1249;
    BOOL v5 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, v5, (uint8_t *)&v6, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 136447490;
    uint64_t v7 = "host_remove";
    __int16 v8 = 1024;
    *(_DWORD *)int v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "host";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "srp-mdns-proxy.c";
    __int16 v10 = 1024;
    int v11 = 1249;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v6, 0x36u);
    int v2 = *a1;
  }
  *a1 = v2 - 1;
  if (v2 == 1)
  {
    uint64_t v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 136447234;
      uint64_t v7 = "host_remove";
      __int16 v8 = 2048;
      *(void *)int v9 = a1;
      *(_WORD *)&v9[8] = 2080;
      *(void *)&v9[10] = "host";
      *(_WORD *)&v9[18] = 2080;
      *(void *)&v9[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v9[28] = 1024;
      *(_DWORD *)&v9[30] = 1249;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v6, 0x30u);
    }
    ++adv_host_finalized;
    adv_host_finalize((uint64_t)a1);
  }
}

void srp_instance_retry_callback(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 24);
  if (v2 && !*(unsigned char *)(v2 + 264))
  {
    uint64_t v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 136446466;
      int v6 = "srp_instance_retry_callback";
      __int16 v7 = 2048;
      uint64_t v8 = a1;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: re-registering updating instance %p.", (uint8_t *)&v5, 0x16u);
    }
    register_instance(a1);
  }
  else
  {
    uint64_t v3 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v5 = 136446466;
      int v6 = "srp_instance_retry_callback";
      __int16 v7 = 2048;
      uint64_t v8 = a1;
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: no longer updating instance %p because host is no longer valid.", (uint8_t *)&v5, 0x16u);
    }
  }
}

unsigned char *srp_message_tsr_attribute_generate(uint64_t a1, int a2, char *a3)
{
  ++saref_created;
  BOOL result = malloc_type_calloc(1uLL, 0x30uLL, 0xF1748037uLL);
  if (result)
  {
    __int16 v7 = result;
    if (a1 && *(void *)(a1 + 72))
    {
      v9.tv_sec = 0;
      v9.tv_nsec = 0;
      clock_gettime(_CLOCK_MONOTONIC_RAW, &v9);
      unsigned int v8 = LODWORD(v9.tv_sec) - *(void *)(a1 + 72);
      srp_format_time_offset(a3, v8);
    }
    else
    {
      unsigned int v8 = 0;
      *(_DWORD *)a3 = 7827310;
    }
    if (__isPlatformVersionAtLeast(2, 18, 0, 0))
    {
      v7[12] = 1;
      *((_DWORD *)v7 + 1) = a2;
    }
    v7[13] = 1;
    *((_DWORD *)v7 + 2) = v8;
    return v7;
  }
  else
  {
    __break(1u);
  }
  return result;
}

void register_host_record_completion(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  if (!*(void *)(a5 + 8))
  {
    uint64_t v14 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v90 = 136446210;
    uint32_t v91 = "register_host_record_completion";
    __int16 v15 = "%{public}s: null rref";
    int v16 = v14;
    goto LABEL_13;
  }
  int v6 = *(uint64_t **)(a5 + 16);
  __int16 v7 = global_os_log;
  if (!v6)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v90 = 136446210;
    uint32_t v91 = "register_host_record_completion";
    __int16 v15 = "%{public}s: no host";
    int v16 = v7;
LABEL_13:
    _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, v15, (uint8_t *)&v90, 0xCu);
    return;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v9 = *(_DWORD *)a5;
    int v90 = 136447490;
    uint32_t v91 = "register_host_record_completion";
    __int16 v92 = 1024;
    *(_DWORD *)__int16 v93 = v9;
    *(_WORD *)&v93[4] = 2048;
    *(void *)&v93[6] = a5;
    *(_WORD *)&v93[14] = 2080;
    *(void *)&v93[16] = "record";
    *(_WORD *)&v93[24] = 2080;
    *(void *)&v93[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v93[34] = 1024;
    *(_DWORD *)&v93[36] = 2448;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v90, 0x36u);
  }
  int v10 = *(_DWORD *)a5;
  if (*(_DWORD *)a5)
  {
    int v11 = v10 + 1;
    *(_DWORD *)a5 = v10 + 1;
    if (v10 + 1 >= 10001)
    {
      int v12 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_173;
      }
      int v90 = 136447490;
      uint32_t v91 = "register_host_record_completion";
      __int16 v92 = 1024;
      *(_DWORD *)__int16 v93 = v11;
      *(_WORD *)&v93[4] = 2048;
      *(void *)&v93[6] = a5;
      *(_WORD *)&v93[14] = 2080;
      *(void *)&v93[16] = "record";
      *(_WORD *)&v93[24] = 2080;
      *(void *)&v93[26] = "srp-mdns-proxy.c";
      *(_WORD *)&v93[34] = 1024;
      *(_DWORD *)&v93[36] = 2448;
      int v13 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
LABEL_171:
      uint64_t v89 = v12;
LABEL_172:
      _os_log_impl((void *)&_mh_execute_header, v89, OS_LOG_TYPE_FAULT, v13, (uint8_t *)&v90, 0x36u);
      goto LABEL_173;
    }
  }
  else
  {
    ++adv_record_created;
    *(_DWORD *)a5 = 1;
  }
  __int16 v17 = *(int **)(a5 + 32);
  if (!v17) {
    goto LABEL_46;
  }
  int v18 = (int *)v6[6];
  int v19 = global_os_log;
  BOOL v20 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (v18 != v17)
  {
    if (v20)
    {
      int v90 = 136446210;
      uint32_t v91 = "register_host_record_completion";
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%{public}s: registration for host record completed with invalid state.", (uint8_t *)&v90, 0xCu);
      __int16 v17 = *(int **)(a5 + 32);
    }
    adv_update_cancel((uint64_t)v17);
    int v21 = *(int **)(a5 + 32);
    if (!v21) {
      goto LABEL_28;
    }
    int v22 = *v21;
    if (*v21)
    {
      uint64_t v23 = global_os_log;
      if (v22 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_173;
        }
        int v90 = 136447490;
        uint32_t v91 = "register_host_record_completion";
        __int16 v92 = 1024;
        *(_DWORD *)__int16 v93 = v22;
        *(_WORD *)&v93[4] = 2048;
        *(void *)&v93[6] = v21;
        *(_WORD *)&v93[14] = 2080;
        *(void *)&v93[16] = "record->update";
        *(_WORD *)&v93[24] = 2080;
        *(void *)&v93[26] = "srp-mdns-proxy.c";
        *(_WORD *)&v93[34] = 1024;
        *(_DWORD *)&v93[36] = 2456;
        int v13 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        uint64_t v89 = v23;
        goto LABEL_172;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v90 = 136447490;
        uint32_t v91 = "register_host_record_completion";
        __int16 v92 = 1024;
        *(_DWORD *)__int16 v93 = v22;
        *(_WORD *)&v93[4] = 2048;
        *(void *)&v93[6] = v21;
        *(_WORD *)&v93[14] = 2080;
        *(void *)&v93[16] = "record->update";
        *(_WORD *)&v93[24] = 2080;
        *(void *)&v93[26] = "srp-mdns-proxy.c";
        *(_WORD *)&v93[34] = 1024;
        *(_DWORD *)&v93[36] = 2456;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v90, 0x36u);
        int v21 = *(int **)(a5 + 32);
        int v22 = *v21;
      }
      *int v21 = v22 - 1;
      if (v22 == 1)
      {
        __int16 v24 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v90 = 136447234;
          uint32_t v91 = "register_host_record_completion";
          __int16 v92 = 2048;
          *(void *)__int16 v93 = v21;
          *(_WORD *)&v93[8] = 2080;
          *(void *)&v93[10] = "record->update";
          *(_WORD *)&v93[18] = 2080;
          *(void *)&v93[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v93[28] = 1024;
          *(_DWORD *)&v93[30] = 2456;
          _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v90, 0x30u);
          int v21 = *(int **)(a5 + 32);
        }
        ++adv_update_finalized;
        adv_update_finalize((uint64_t)v21);
      }
LABEL_28:
      *(void *)(a5 + 32) = 0;
      srp_mdns_shared_record_remove(v6[1], a5);
      int v25 = *(_DWORD *)a5;
      if (!*(_DWORD *)a5)
      {
        int v12 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_173;
        }
        int v90 = 136447490;
        uint32_t v91 = "register_host_record_completion";
        __int16 v92 = 1024;
        *(_DWORD *)__int16 v93 = 0;
        *(_WORD *)&v93[4] = 2048;
        *(void *)&v93[6] = a5;
        *(_WORD *)&v93[14] = 2080;
        *(void *)&v93[16] = "record";
        *(_WORD *)&v93[24] = 2080;
        *(void *)&v93[26] = "srp-mdns-proxy.c";
        *(_WORD *)&v93[34] = 1024;
        *(_DWORD *)&v93[36] = 2459;
        int v13 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        goto LABEL_171;
      }
      int v12 = global_os_log;
      if (v25 >= 10001)
      {
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
          goto LABEL_173;
        }
        int v90 = 136447490;
        uint32_t v91 = "register_host_record_completion";
        __int16 v92 = 1024;
        *(_DWORD *)__int16 v93 = v25;
        *(_WORD *)&v93[4] = 2048;
        *(void *)&v93[6] = a5;
        *(_WORD *)&v93[14] = 2080;
        *(void *)&v93[16] = "record";
        *(_WORD *)&v93[24] = 2080;
        *(void *)&v93[26] = "srp-mdns-proxy.c";
        *(_WORD *)&v93[34] = 1024;
        *(_DWORD *)&v93[36] = 2459;
        int v13 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_171;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v90 = 136447490;
        uint32_t v91 = "register_host_record_completion";
        __int16 v92 = 1024;
        *(_DWORD *)__int16 v93 = v25;
        *(_WORD *)&v93[4] = 2048;
        *(void *)&v93[6] = a5;
        *(_WORD *)&v93[14] = 2080;
        *(void *)&v93[16] = "record";
        *(_WORD *)&v93[24] = 2080;
        *(void *)&v93[26] = "srp-mdns-proxy.c";
        *(_WORD *)&v93[34] = 1024;
        *(_DWORD *)&v93[36] = 2459;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v90, 0x36u);
        int v25 = *(_DWORD *)a5;
        int v12 = global_os_log;
      }
      int v26 = v25 - 1;
      *(_DWORD *)a5 = v26;
      if (!v26)
      {
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
        {
          int v90 = 136447234;
          uint32_t v91 = "register_host_record_completion";
          __int16 v92 = 2048;
          *(void *)__int16 v93 = a5;
          *(_WORD *)&v93[8] = 2080;
          *(void *)&v93[10] = "record";
          *(_WORD *)&v93[18] = 2080;
          *(void *)&v93[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v93[28] = 1024;
          *(_DWORD *)&v93[30] = 2459;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v90, 0x30u);
        }
        ++adv_record_finalized;
        adv_record_finalize(a5);
        int v26 = *(_DWORD *)a5;
        int v12 = global_os_log;
        if (!*(_DWORD *)a5)
        {
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
            goto LABEL_173;
          }
          int v90 = 136447490;
          uint32_t v91 = "register_host_record_completion";
          __int16 v92 = 1024;
          *(_DWORD *)__int16 v93 = 0;
          *(_WORD *)&v93[4] = 2048;
          *(void *)&v93[6] = a5;
          *(_WORD *)&v93[14] = 2080;
          *(void *)&v93[16] = "record";
          *(_WORD *)&v93[24] = 2080;
          *(void *)&v93[26] = "srp-mdns-proxy.c";
          *(_WORD *)&v93[34] = 1024;
          *(_DWORD *)&v93[36] = 2460;
          int v13 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
          goto LABEL_171;
        }
      }
      if (v26 >= 10001)
      {
        if (!os_log_type_enabled(v12, OS_LOG_TYPE_FAULT)) {
          goto LABEL_173;
        }
        int v90 = 136447490;
        uint32_t v91 = "register_host_record_completion";
        __int16 v92 = 1024;
        *(_DWORD *)__int16 v93 = v26;
        *(_WORD *)&v93[4] = 2048;
        *(void *)&v93[6] = a5;
        *(_WORD *)&v93[14] = 2080;
        *(void *)&v93[16] = "record";
        *(_WORD *)&v93[24] = 2080;
        *(void *)&v93[26] = "srp-mdns-proxy.c";
        *(_WORD *)&v93[34] = 1024;
        *(_DWORD *)&v93[36] = 2460;
        int v13 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        goto LABEL_171;
      }
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
      {
        int v90 = 136447490;
        uint32_t v91 = "register_host_record_completion";
        __int16 v92 = 1024;
        *(_DWORD *)__int16 v93 = v26;
        *(_WORD *)&v93[4] = 2048;
        *(void *)&v93[6] = a5;
        *(_WORD *)&v93[14] = 2080;
        *(void *)&v93[16] = "record";
        *(_WORD *)&v93[24] = 2080;
        *(void *)&v93[26] = "srp-mdns-proxy.c";
        *(_WORD *)&v93[34] = 1024;
        *(_DWORD *)&v93[36] = 2460;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v90, 0x36u);
        int v26 = *(_DWORD *)a5;
      }
      *(_DWORD *)a5 = v26 - 1;
      if (v26 == 1)
      {
        uint64_t v27 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v90 = 136447234;
          uint32_t v91 = "register_host_record_completion";
          __int16 v92 = 2048;
          *(void *)__int16 v93 = a5;
          *(_WORD *)&v93[8] = 2080;
          *(void *)&v93[10] = "record";
          *(_WORD *)&v93[18] = 2080;
          *(void *)&v93[20] = "srp-mdns-proxy.c";
          *(_WORD *)&v93[28] = 1024;
          *(_DWORD *)&v93[30] = 2460;
LABEL_143:
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v90, 0x30u);
          goto LABEL_144;
        }
        goto LABEL_144;
      }
      return;
    }
    uint64_t v81 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_173;
    }
    int v90 = 136447490;
    uint32_t v91 = "register_host_record_completion";
    __int16 v92 = 1024;
    *(_DWORD *)__int16 v93 = 0;
    *(_WORD *)&v93[4] = 2048;
    *(void *)&v93[6] = v21;
    *(_WORD *)&v93[14] = 2080;
    *(void *)&v93[16] = "record->update";
    *(_WORD *)&v93[24] = 2080;
    *(void *)&v93[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v93[34] = 1024;
    *(_DWORD *)&v93[36] = 2456;
    int v13 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_176:
    uint64_t v89 = v81;
    goto LABEL_172;
  }
  if (v20)
  {
    int v28 = *v17;
    int v90 = 136447490;
    uint32_t v91 = "register_host_record_completion";
    __int16 v92 = 1024;
    *(_DWORD *)__int16 v93 = v28;
    *(_WORD *)&v93[4] = 2048;
    *(void *)&v93[6] = v17;
    *(_WORD *)&v93[14] = 2080;
    *(void *)&v93[16] = "update";
    *(_WORD *)&v93[24] = 2080;
    *(void *)&v93[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v93[34] = 1024;
    *(_DWORD *)&v93[36] = 2466;
    _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v90, 0x36u);
  }
  int v29 = *v17;
  if (*v17)
  {
    int v30 = v29 + 1;
    *__int16 v17 = v29 + 1;
    if (v29 + 1 >= 10001)
    {
      uint64_t v81 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_173:
      }
        abort();
      int v90 = 136447490;
      uint32_t v91 = "register_host_record_completion";
      __int16 v92 = 1024;
      *(_DWORD *)__int16 v93 = v30;
      *(_WORD *)&v93[4] = 2048;
      *(void *)&v93[6] = v17;
      *(_WORD *)&v93[14] = 2080;
      *(void *)&v93[16] = "update";
      *(_WORD *)&v93[24] = 2080;
      *(void *)&v93[26] = "srp-mdns-proxy.c";
      *(_WORD *)&v93[34] = 1024;
      *(_DWORD *)&v93[36] = 2466;
      int v13 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_176;
    }
LABEL_46:
    if (!a4) {
      goto LABEL_48;
    }
LABEL_47:
    if (a4 == -65548) {
      goto LABEL_48;
    }
    int v34 = *(unsigned __int16 *)(a5 + 48);
    switch(v34)
    {
      case 28:
        uint64_t v63 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v64 = v6[8];
          uint64_t v65 = *(unsigned __int8 **)(a5 + 40);
          int v66 = *v65;
          if ((v66 & 0xFE) == 0xFC)
          {
            int v67 = "ULA: ";
          }
          else if (v66 == 254 && (v65[1] & 0xC0) == 0x80)
          {
            int v67 = "LUA: ";
          }
          else if ((v66 & 0xE0) == 0x20)
          {
            int v67 = "GUA: ";
          }
          else
          {
            int v67 = "";
          }
          int v90 = 136449539;
          uint32_t v91 = "register_host_record_completion";
          __int16 v92 = 2160;
          *(void *)__int16 v93 = 1752392040;
          *(_WORD *)&v93[8] = 2081;
          *(void *)&v93[10] = v64;
          *(_WORD *)&v93[18] = 2082;
          *(void *)&v93[20] = v67;
          *(_WORD *)&v93[28] = 2160;
          *(void *)&v93[30] = 1752392040;
          *(_WORD *)&v93[38] = 1041;
          *(_DWORD *)&v93[40] = 6;
          __int16 v94 = 2097;
          __int16 v95 = (const char *)v65;
          __int16 v96 = 2160;
          uint64_t v97 = 1752392040;
          __int16 v98 = 1042;
          int v99 = 2;
          __int16 v100 = 2098;
          uint64_t v101 = v65 + 6;
          __int16 v102 = 2160;
          uint64_t v103 = 1752392040;
          __int16 v104 = 1041;
          int v105 = 8;
          __int16 v106 = 2097;
          int v107 = v65 + 8;
          __int16 v108 = 1024;
          LODWORD(v109) = a4;
          int v38 = "%{public}s: registration for host %{private, mask.hash}s address {%{public}s%{private, mask.hash, srp:in"
                "6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segm"
                "ent}.8P} failed, error code = %d.";
          int v39 = v63;
          uint32_t v40 = 126;
          goto LABEL_120;
        }
        break;
      case 25:
        uint64_t v68 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v69 = v6[8];
          int v90 = 136446979;
          uint32_t v91 = "register_host_record_completion";
          __int16 v92 = 2160;
          *(void *)__int16 v93 = 1752392040;
          *(_WORD *)&v93[8] = 2081;
          *(void *)&v93[10] = v69;
          *(_WORD *)&v93[18] = 1024;
          *(_DWORD *)&v93[20] = a4;
          int v38 = "%{public}s: registration for host %{private, mask.hash}s key failed, error code = %d.";
          int v39 = v68;
          uint32_t v40 = 38;
          goto LABEL_120;
        }
        break;
      case 1:
        uint64_t v35 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v36 = v6[8];
          uint64_t v37 = *(void *)(a5 + 40);
          int v90 = 136447747;
          uint32_t v91 = "register_host_record_completion";
          __int16 v92 = 2160;
          *(void *)__int16 v93 = 1752392040;
          *(_WORD *)&v93[8] = 2081;
          *(void *)&v93[10] = v36;
          *(_WORD *)&v93[18] = 2160;
          *(void *)&v93[20] = 1752392040;
          *(_WORD *)&v93[28] = 1041;
          *(_DWORD *)&v93[30] = 4;
          *(_WORD *)&v93[34] = 2097;
          *(void *)&v93[36] = v37;
          __int16 v94 = 1024;
          LODWORD(v95) = a4;
          int v38 = "%{public}s: registration for host %{private, mask.hash}s address %{private, mask.hash, network:in_addr}."
                "4P failed, error code = %d.";
          int v39 = v35;
          uint32_t v40 = 64;
LABEL_120:
          _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, v38, (uint8_t *)&v90, v40);
        }
        break;
      default:
        uint64_t v70 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v71 = v6[8];
          int v90 = 136447235;
          uint32_t v91 = "register_host_record_completion";
          __int16 v92 = 2160;
          *(void *)__int16 v93 = 1752392040;
          *(_WORD *)&v93[8] = 2081;
          *(void *)&v93[10] = v71;
          *(_WORD *)&v93[18] = 1024;
          *(_DWORD *)&v93[20] = v34;
          *(_WORD *)&v93[24] = 1024;
          *(_DWORD *)&v93[26] = a4;
          int v38 = "%{public}s: registration for host %{private, mask.hash}s unknown record type %d failed, error code = %d.";
          int v39 = v70;
          uint32_t v40 = 44;
          goto LABEL_120;
        }
        break;
    }
    if (a4 == -65563 || a4 == -65569)
    {
      service_disconnected(v6[1], *(void *)(a5 + 24));
      if (v17) {
        wait_retry((uint64_t)v6);
      }
    }
    else if (v17)
    {
      update_failed((uint64_t)v17, 2u, 1);
    }
    srp_mdns_shared_record_remove(v6[1], a5);
    if (!v17) {
      goto LABEL_136;
    }
    goto LABEL_128;
  }
  ++adv_update_created;
  *__int16 v17 = 1;
  if (a4) {
    goto LABEL_47;
  }
LABEL_48:
  if (!*(unsigned char *)(a5 + 52))
  {
    uint64_t v33 = " got spurious success callback after completion.";
    if (!a4) {
      goto LABEL_68;
    }
LABEL_61:
    srp_mdns_shared_record_remove(v6[1], a5);
    uint64_t v41 = *(void *)(a5 + 16);
    if (v41 && !*(unsigned char *)(v41 + 264))
    {
      if (!*(unsigned char *)(v41 + 266))
      {
        if (*(void *)(v41 + 16)
          || (uint64_t v72 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 2007), (*(void *)(v41 + 16) = v72) != 0))
        {
          int v73 = *(_DWORD *)(v41 + 188);
          if (v73) {
            unsigned int v74 = 2 * v73;
          }
          else {
            unsigned int v74 = 5000;
          }
          *(_DWORD *)(v41 + 188) = v74;
          uint32_t v75 = arc4random();
          unsigned int v76 = *(_DWORD *)(v41 + 188);
          uint64_t v77 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v78 = *(_DWORD *)v41;
            int v90 = 136447490;
            uint32_t v91 = "srp_schedule_host_record_retry";
            __int16 v92 = 1024;
            *(_DWORD *)__int16 v93 = v78;
            *(_WORD *)&v93[4] = 2048;
            *(void *)&v93[6] = v41;
            *(_WORD *)&v93[14] = 2080;
            *(void *)&v93[16] = "host";
            *(_WORD *)&v93[24] = 2080;
            *(void *)&v93[26] = "srp-mdns-proxy.c";
            *(_WORD *)&v93[34] = 1024;
            *(_DWORD *)&v93[36] = 2014;
            _os_log_impl((void *)&_mh_execute_header, v77, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v90, 0x36u);
          }
          int v79 = *(_DWORD *)v41;
          if (*(_DWORD *)v41)
          {
            int v80 = v79 + 1;
            *(_DWORD *)uint64_t v41 = v79 + 1;
            if (v79 + 1 >= 10001)
            {
              uint64_t v81 = global_os_log;
              if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
                goto LABEL_173;
              }
              int v90 = 136447490;
              uint32_t v91 = "srp_schedule_host_record_retry";
              __int16 v92 = 1024;
              *(_DWORD *)__int16 v93 = v80;
              *(_WORD *)&v93[4] = 2048;
              *(void *)&v93[6] = v41;
              *(_WORD *)&v93[14] = 2080;
              *(void *)&v93[16] = "host";
              *(_WORD *)&v93[24] = 2080;
              *(void *)&v93[26] = "srp-mdns-proxy.c";
              *(_WORD *)&v93[34] = 1024;
              *(_DWORD *)&v93[36] = 2014;
              int v13 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
              goto LABEL_176;
            }
          }
          else
          {
            ++adv_host_created;
            *(_DWORD *)uint64_t v41 = 1;
          }
          unsigned int v86 = -((double)(v75 % v76) - (double)v74 * 1.5);
          ioloop_add_wake_event(*(void *)(v41 + 16), v41, (uint64_t)srp_host_record_retry_callback, (uint64_t)srp_adv_host_context_release, v86);
          uint64_t v87 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
            goto LABEL_67;
          }
          int v90 = 136446722;
          uint32_t v91 = "srp_schedule_host_record_retry";
          __int16 v92 = 2048;
          *(void *)__int16 v93 = a5;
          *(_WORD *)&v93[8] = 2048;
          *(double *)&v93[10] = (double)v86 / 1000.0;
          int v43 = "%{public}s: will attempt to reregister record %p in %.3lf seconds";
          BOOL v44 = v87;
          os_log_type_t v45 = OS_LOG_TYPE_DEFAULT;
          uint32_t v46 = 32;
        }
        else
        {
          uint64_t v88 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
            goto LABEL_67;
          }
          int v90 = 136446210;
          uint32_t v91 = "srp_schedule_host_record_retry";
          int v43 = "%{public}s: unable to make wakeup &host->re_register_wakeup";
          BOOL v44 = v88;
          os_log_type_t v45 = OS_LOG_TYPE_ERROR;
          uint32_t v46 = 12;
        }
        goto LABEL_66;
      }
      uint64_t v42 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_67;
      }
      int v90 = 136446466;
      uint32_t v91 = "srp_schedule_host_record_retry";
      __int16 v92 = 2048;
      *(void *)__int16 v93 = a5;
      int v43 = "%{public}s: already scheduled attempt to reregister record %p";
    }
    else
    {
      uint64_t v42 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
LABEL_67:
        uint64_t v33 = " completed with conflict.";
        goto LABEL_68;
      }
      int v90 = 136446466;
      uint32_t v91 = "srp_schedule_host_record_retry";
      __int16 v92 = 2048;
      *(void *)__int16 v93 = a5;
      int v43 = "%{public}s: will not attempt to reregister record %p";
    }
    BOOL v44 = v42;
    os_log_type_t v45 = OS_LOG_TYPE_DEFAULT;
    uint32_t v46 = 22;
LABEL_66:
    _os_log_impl((void *)&_mh_execute_header, v44, v45, v43, (uint8_t *)&v90, v46);
    goto LABEL_67;
  }
  *(unsigned char *)(a5 + 52) = 0;
  if (v17)
  {
    int v31 = v17[24];
    int v32 = v17[25] + 1;
    v17[25] = v32;
    if (v32 == v31 && v17[23] == v17[22]) {
      srp_mdns_update_finished(v17);
    }
  }
  uint64_t v33 = " has completed.";
  if (a4) {
    goto LABEL_61;
  }
LABEL_68:
  int v47 = *(unsigned __int16 *)(a5 + 48);
  switch(v47)
  {
    case 28:
      uint64_t v54 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_111;
      }
      uint64_t v55 = v6[8];
      __int16 v56 = *(unsigned __int8 **)(a5 + 40);
      int v57 = *v56;
      if ((v57 & 0xFE) == 0xFC)
      {
        int v58 = "ULA: ";
      }
      else if (v57 == 254 && (v56[1] & 0xC0) == 0x80)
      {
        int v58 = "LUA: ";
      }
      else if ((v57 & 0xE0) == 0x20)
      {
        int v58 = "GUA: ";
      }
      else
      {
        int v58 = "";
      }
      int v90 = 136449539;
      uint32_t v91 = "register_host_record_completion";
      __int16 v92 = 2160;
      *(void *)__int16 v93 = 1752392040;
      *(_WORD *)&v93[8] = 2081;
      *(void *)&v93[10] = v55;
      *(_WORD *)&v93[18] = 2082;
      *(void *)&v93[20] = v58;
      *(_WORD *)&v93[28] = 2160;
      *(void *)&v93[30] = 1752392040;
      *(_WORD *)&v93[38] = 1041;
      *(_DWORD *)&v93[40] = 6;
      __int16 v94 = 2097;
      __int16 v95 = (const char *)v56;
      __int16 v96 = 2160;
      uint64_t v97 = 1752392040;
      __int16 v98 = 1042;
      int v99 = 2;
      __int16 v100 = 2098;
      uint64_t v101 = v56 + 6;
      __int16 v102 = 2160;
      uint64_t v103 = 1752392040;
      __int16 v104 = 1041;
      int v105 = 8;
      __int16 v106 = 2097;
      int v107 = v56 + 8;
      __int16 v108 = 2082;
      int v109 = v33;
      int v51 = "%{public}s: registration for host %{private, mask.hash}s address {%{public}s%{private, mask.hash, srp:in6_ad"
            "dr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}%{public}s";
      int v52 = v54;
      uint32_t v53 = 130;
      break;
    case 25:
      uint64_t v59 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_111;
      }
      uint64_t v60 = v6[8];
      int v90 = 136446979;
      uint32_t v91 = "register_host_record_completion";
      __int16 v92 = 2160;
      *(void *)__int16 v93 = 1752392040;
      *(_WORD *)&v93[8] = 2081;
      *(void *)&v93[10] = v60;
      *(_WORD *)&v93[18] = 2082;
      *(void *)&v93[20] = v33;
      int v51 = "%{public}s: registration for host %{private, mask.hash}s key%{public}s";
      int v52 = v59;
      uint32_t v53 = 42;
      break;
    case 1:
      uint64_t v48 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_111;
      }
      uint64_t v49 = v6[8];
      uint64_t v50 = *(void *)(a5 + 40);
      int v90 = 136447747;
      uint32_t v91 = "register_host_record_completion";
      __int16 v92 = 2160;
      *(void *)__int16 v93 = 1752392040;
      *(_WORD *)&v93[8] = 2081;
      *(void *)&v93[10] = v49;
      *(_WORD *)&v93[18] = 2160;
      *(void *)&v93[20] = 1752392040;
      *(_WORD *)&v93[28] = 1041;
      *(_DWORD *)&v93[30] = 4;
      *(_WORD *)&v93[34] = 2097;
      *(void *)&v93[36] = v50;
      __int16 v94 = 2082;
      __int16 v95 = v33;
      int v51 = "%{public}s: registration for host %{private, mask.hash}s address %{private, mask.hash, network:in_addr}.4P%{public}s";
      int v52 = v48;
      uint32_t v53 = 68;
      break;
    default:
      uint64_t v61 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_111;
      }
      uint64_t v62 = v6[8];
      int v90 = 136447235;
      uint32_t v91 = "register_host_record_completion";
      __int16 v92 = 2160;
      *(void *)__int16 v93 = 1752392040;
      *(_WORD *)&v93[8] = 2081;
      *(void *)&v93[10] = v62;
      *(_WORD *)&v93[18] = 1024;
      *(_DWORD *)&v93[20] = v47;
      *(_WORD *)&v93[24] = 2082;
      *(void *)&v93[26] = v33;
      int v51 = "%{public}s: registration for host %{private, mask.hash}s unknown record type %d %{public}s";
      int v52 = v61;
      uint32_t v53 = 48;
      break;
  }
  _os_log_impl((void *)&_mh_execute_header, v52, OS_LOG_TYPE_DEFAULT, v51, (uint8_t *)&v90, v53);
LABEL_111:
  if (!v17) {
    goto LABEL_136;
  }
LABEL_128:
  int v82 = *v17;
  if (!*v17)
  {
    uint64_t v81 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_173;
    }
    int v90 = 136447490;
    uint32_t v91 = "register_host_record_completion";
    __int16 v92 = 1024;
    *(_DWORD *)__int16 v93 = 0;
    *(_WORD *)&v93[4] = 2048;
    *(void *)&v93[6] = v17;
    *(_WORD *)&v93[14] = 2080;
    *(void *)&v93[16] = "update";
    *(_WORD *)&v93[24] = 2080;
    *(void *)&v93[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v93[34] = 1024;
    *(_DWORD *)&v93[36] = 2567;
    int v13 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_176;
  }
  int v83 = global_os_log;
  if (v82 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_173;
    }
    int v90 = 136447490;
    uint32_t v91 = "register_host_record_completion";
    __int16 v92 = 1024;
    *(_DWORD *)__int16 v93 = v82;
    *(_WORD *)&v93[4] = 2048;
    *(void *)&v93[6] = v17;
    *(_WORD *)&v93[14] = 2080;
    *(void *)&v93[16] = "update";
    *(_WORD *)&v93[24] = 2080;
    *(void *)&v93[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v93[34] = 1024;
    *(_DWORD *)&v93[36] = 2567;
    int v13 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    uint64_t v89 = v83;
    goto LABEL_172;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v90 = 136447490;
    uint32_t v91 = "register_host_record_completion";
    __int16 v92 = 1024;
    *(_DWORD *)__int16 v93 = v82;
    *(_WORD *)&v93[4] = 2048;
    *(void *)&v93[6] = v17;
    *(_WORD *)&v93[14] = 2080;
    *(void *)&v93[16] = "update";
    *(_WORD *)&v93[24] = 2080;
    *(void *)&v93[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v93[34] = 1024;
    *(_DWORD *)&v93[36] = 2567;
    _os_log_impl((void *)&_mh_execute_header, v83, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v90, 0x36u);
    int v82 = *v17;
  }
  *__int16 v17 = v82 - 1;
  if (v82 == 1)
  {
    uint64_t v84 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v90 = 136447234;
      uint32_t v91 = "register_host_record_completion";
      __int16 v92 = 2048;
      *(void *)__int16 v93 = v17;
      *(_WORD *)&v93[8] = 2080;
      *(void *)&v93[10] = "update";
      *(_WORD *)&v93[18] = 2080;
      *(void *)&v93[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v93[28] = 1024;
      *(_DWORD *)&v93[30] = 2567;
      _os_log_impl((void *)&_mh_execute_header, v84, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v90, 0x30u);
    }
    ++adv_update_finalized;
    adv_update_finalize((uint64_t)v17);
  }
LABEL_136:
  int v85 = *(_DWORD *)a5;
  if (!*(_DWORD *)a5)
  {
    int v12 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_173;
    }
    int v90 = 136447490;
    uint32_t v91 = "register_host_record_completion";
    __int16 v92 = 1024;
    *(_DWORD *)__int16 v93 = 0;
    *(_WORD *)&v93[4] = 2048;
    *(void *)&v93[6] = a5;
    *(_WORD *)&v93[14] = 2080;
    *(void *)&v93[16] = "record";
    *(_WORD *)&v93[24] = 2080;
    *(void *)&v93[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v93[34] = 1024;
    *(_DWORD *)&v93[36] = 2569;
    int v13 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_171;
  }
  int v12 = global_os_log;
  if (v85 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_173;
    }
    int v90 = 136447490;
    uint32_t v91 = "register_host_record_completion";
    __int16 v92 = 1024;
    *(_DWORD *)__int16 v93 = v85;
    *(_WORD *)&v93[4] = 2048;
    *(void *)&v93[6] = a5;
    *(_WORD *)&v93[14] = 2080;
    *(void *)&v93[16] = "record";
    *(_WORD *)&v93[24] = 2080;
    *(void *)&v93[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v93[34] = 1024;
    *(_DWORD *)&v93[36] = 2569;
    int v13 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_171;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v90 = 136447490;
    uint32_t v91 = "register_host_record_completion";
    __int16 v92 = 1024;
    *(_DWORD *)__int16 v93 = v85;
    *(_WORD *)&v93[4] = 2048;
    *(void *)&v93[6] = a5;
    *(_WORD *)&v93[14] = 2080;
    *(void *)&v93[16] = "record";
    *(_WORD *)&v93[24] = 2080;
    *(void *)&v93[26] = "srp-mdns-proxy.c";
    *(_WORD *)&v93[34] = 1024;
    *(_DWORD *)&v93[36] = 2569;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v90, 0x36u);
    int v85 = *(_DWORD *)a5;
  }
  *(_DWORD *)a5 = v85 - 1;
  if (v85 == 1)
  {
    uint64_t v27 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v90 = 136447234;
      uint32_t v91 = "register_host_record_completion";
      __int16 v92 = 2048;
      *(void *)__int16 v93 = a5;
      *(_WORD *)&v93[8] = 2080;
      *(void *)&v93[10] = "record";
      *(_WORD *)&v93[18] = 2080;
      *(void *)&v93[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v93[28] = 1024;
      *(_DWORD *)&v93[30] = 2569;
      goto LABEL_143;
    }
LABEL_144:
    ++adv_record_finalized;
    adv_record_finalize(a5);
  }
}

void srp_host_record_retry_callback(uint64_t a1)
{
  if (a1 && (*(unsigned char *)(a1 + 266) = 0, !*(unsigned char *)(a1 + 264)))
  {
    uint64_t v3 = *(void *)(a1 + 96);
    if (v3 && *(int *)(v3 + 4) >= 1)
    {
      uint64_t v4 = 0;
      do
      {
        uint64_t v5 = *(void *)(*(void *)(v3 + 8) + 8 * v4);
        if (v5)
        {
          int v6 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136446466;
            int v10 = "srp_host_record_retry_callback";
            __int16 v11 = 2048;
            uint64_t v12 = v5;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: re-registering host record %p.", buf, 0x16u);
          }
          register_host_record(a1, v5, 0);
          uint64_t v3 = *(void *)(a1 + 96);
        }
        ++v4;
      }
      while (v4 < *(int *)(v3 + 4));
    }
    uint64_t v7 = *(void *)(a1 + 104);
    if (v7)
    {
      unsigned int v8 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136446466;
        int v10 = "srp_host_record_retry_callback";
        __int16 v11 = 2048;
        uint64_t v12 = v7;
        _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: re-registering host record %p.", buf, 0x16u);
        uint64_t v7 = *(void *)(a1 + 104);
      }
      register_host_record(a1, v7, 0);
    }
  }
  else
  {
    uint64_t v2 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136446466;
      int v10 = "srp_host_record_retry_callback";
      __int16 v11 = 2048;
      uint64_t v12 = a1;
      _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: no longer updating host %p because host is no longer valid.", buf, 0x16u);
    }
  }
}

void srp_ml_eid_mapping_callback(uint64_t a1, int a2)
{
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v5 = global_os_log;
  BOOL v6 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (v4)
    {
      if (!v6) {
        goto LABEL_45;
      }
      uint64_t v7 = *(unsigned __int8 **)(a1 + 40);
      int v8 = *v7;
      if ((v8 & 0xFE) == 0xFC)
      {
        int v9 = "ULA: ";
      }
      else if (v8 == 254 && (v7[1] & 0xC0) == 0x80)
      {
        int v9 = "LUA: ";
      }
      else if ((v8 & 0xE0) == 0x20)
      {
        int v9 = "GUA: ";
      }
      else
      {
        int v9 = "";
      }
      uint64_t v19 = *(void *)(v4 + 56);
      int v28 = 136449539;
      int v29 = "srp_ml_eid_mapping_callback";
      __int16 v30 = 2082;
      *(void *)int v31 = v9;
      *(_WORD *)&v31[8] = 2160;
      *(void *)&v31[10] = 1752392040;
      *(_WORD *)&v31[18] = 1041;
      *(_DWORD *)&v31[20] = 6;
      *(_WORD *)&v31[24] = 2097;
      *(void *)&v31[26] = v7;
      __int16 v32 = 2160;
      uint64_t v33 = 1752392040;
      __int16 v34 = 1042;
      int v35 = 2;
      __int16 v36 = 2098;
      uint64_t v37 = v7 + 6;
      __int16 v38 = 2160;
      uint64_t v39 = 1752392040;
      __int16 v40 = 1041;
      int v41 = 8;
      __int16 v42 = 2097;
      int v43 = v7 + 8;
      __int16 v44 = 2160;
      uint64_t v45 = 1752392040;
      __int16 v46 = 2081;
      uint64_t v47 = v19;
      __int16 v48 = 1024;
      int v49 = a2;
      BOOL v20 = "%{public}s: mapping for address {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.has"
            "h, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} to host %{private, mask.hash}s failed: %d";
      int v21 = v5;
      uint32_t v22 = 126;
    }
    else
    {
      if (!v6) {
        goto LABEL_45;
      }
      int v13 = *(unsigned __int8 **)(a1 + 40);
      int v14 = *v13;
      if ((v14 & 0xFE) == 0xFC)
      {
        __int16 v15 = "ULA: ";
      }
      else if (v14 == 254 && (v13[1] & 0xC0) == 0x80)
      {
        __int16 v15 = "LUA: ";
      }
      else if ((v14 & 0xE0) == 0x20)
      {
        __int16 v15 = "GUA: ";
      }
      else
      {
        __int16 v15 = "";
      }
      int v28 = 136449027;
      int v29 = "srp_ml_eid_mapping_callback";
      __int16 v30 = 2082;
      *(void *)int v31 = v15;
      *(_WORD *)&v31[8] = 2160;
      *(void *)&v31[10] = 1752392040;
      *(_WORD *)&v31[18] = 1041;
      *(_DWORD *)&v31[20] = 6;
      *(_WORD *)&v31[24] = 2097;
      *(void *)&v31[26] = v13;
      __int16 v32 = 2160;
      uint64_t v33 = 1752392040;
      __int16 v34 = 1042;
      int v35 = 2;
      __int16 v36 = 2098;
      uint64_t v37 = v13 + 6;
      __int16 v38 = 2160;
      uint64_t v39 = 1752392040;
      __int16 v40 = 1041;
      int v41 = 8;
      __int16 v42 = 2097;
      int v43 = v13 + 8;
      __int16 v44 = 1024;
      LODWORD(v45) = a2;
      BOOL v20 = "%{public}s: orphaned mapping for address {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public,"
            " mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} failed: %d";
      int v21 = v5;
      uint32_t v22 = 106;
    }
  }
  else if (v4)
  {
    if (!v6) {
      goto LABEL_45;
    }
    int v10 = *(unsigned __int8 **)(a1 + 40);
    int v11 = *v10;
    if ((v11 & 0xFE) == 0xFC)
    {
      uint64_t v12 = "ULA: ";
    }
    else if (v11 == 254 && (v10[1] & 0xC0) == 0x80)
    {
      uint64_t v12 = "LUA: ";
    }
    else if ((v11 & 0xE0) == 0x20)
    {
      uint64_t v12 = "GUA: ";
    }
    else
    {
      uint64_t v12 = "";
    }
    uint64_t v23 = *(void *)(v4 + 56);
    int v28 = 136449283;
    int v29 = "srp_ml_eid_mapping_callback";
    __int16 v30 = 2082;
    *(void *)int v31 = v12;
    *(_WORD *)&v31[8] = 2160;
    *(void *)&v31[10] = 1752392040;
    *(_WORD *)&v31[18] = 1041;
    *(_DWORD *)&v31[20] = 6;
    *(_WORD *)&v31[24] = 2097;
    *(void *)&v31[26] = v10;
    __int16 v32 = 2160;
    uint64_t v33 = 1752392040;
    __int16 v34 = 1042;
    int v35 = 2;
    __int16 v36 = 2098;
    uint64_t v37 = v10 + 6;
    __int16 v38 = 2160;
    uint64_t v39 = 1752392040;
    __int16 v40 = 1041;
    int v41 = 8;
    __int16 v42 = 2097;
    int v43 = v10 + 8;
    __int16 v44 = 2160;
    uint64_t v45 = 1752392040;
    __int16 v46 = 2081;
    uint64_t v47 = v23;
    BOOL v20 = "%{public}s: mapping for address {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash,"
          " srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} to host %{private, mask.hash}s succeeded";
    int v21 = v5;
    uint32_t v22 = 120;
  }
  else
  {
    if (!v6) {
      goto LABEL_45;
    }
    int v16 = *(unsigned __int8 **)(a1 + 40);
    int v17 = *v16;
    if ((v17 & 0xFE) == 0xFC)
    {
      int v18 = "ULA: ";
    }
    else if (v17 == 254 && (v16[1] & 0xC0) == 0x80)
    {
      int v18 = "LUA: ";
    }
    else if ((v17 & 0xE0) == 0x20)
    {
      int v18 = "GUA: ";
    }
    else
    {
      int v18 = "";
    }
    int v28 = 136448771;
    int v29 = "srp_ml_eid_mapping_callback";
    __int16 v30 = 2082;
    *(void *)int v31 = v18;
    *(_WORD *)&v31[8] = 2160;
    *(void *)&v31[10] = 1752392040;
    *(_WORD *)&v31[18] = 1041;
    *(_DWORD *)&v31[20] = 6;
    *(_WORD *)&v31[24] = 2097;
    *(void *)&v31[26] = v16;
    __int16 v32 = 2160;
    uint64_t v33 = 1752392040;
    __int16 v34 = 1042;
    int v35 = 2;
    __int16 v36 = 2098;
    uint64_t v37 = v16 + 6;
    __int16 v38 = 2160;
    uint64_t v39 = 1752392040;
    __int16 v40 = 1041;
    int v41 = 8;
    __int16 v42 = 2097;
    int v43 = v16 + 8;
    BOOL v20 = "%{public}s: mapping for address {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash,"
          " srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} was orphaned.";
    int v21 = v5;
    uint32_t v22 = 100;
  }
  _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, v20, (uint8_t *)&v28, v22);
LABEL_45:
  int v24 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    int v25 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_59;
    }
    int v28 = 136447490;
    int v29 = "srp_ml_eid_mapping_callback";
    __int16 v30 = 1024;
    *(_DWORD *)int v31 = 0;
    *(_WORD *)&v31[4] = 2048;
    *(void *)&v31[6] = a1;
    *(_WORD *)&v31[14] = 2080;
    *(void *)&v31[16] = "arec";
    *(_WORD *)&v31[24] = 2080;
    *(void *)&v31[26] = "srp-mdns-proxy.c";
    __int16 v32 = 1024;
    LODWORD(v33) = 595;
    uint64_t v27 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_58;
  }
  int v25 = global_os_log;
  if (v24 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_59;
    }
    int v28 = 136447490;
    int v29 = "srp_ml_eid_mapping_callback";
    __int16 v30 = 1024;
    *(_DWORD *)int v31 = v24;
    *(_WORD *)&v31[4] = 2048;
    *(void *)&v31[6] = a1;
    *(_WORD *)&v31[14] = 2080;
    *(void *)&v31[16] = "arec";
    *(_WORD *)&v31[24] = 2080;
    *(void *)&v31[26] = "srp-mdns-proxy.c";
    __int16 v32 = 1024;
    LODWORD(v33) = 595;
    uint64_t v27 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_58:
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_FAULT, v27, (uint8_t *)&v28, 0x36u);
LABEL_59:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v28 = 136447490;
    int v29 = "srp_ml_eid_mapping_callback";
    __int16 v30 = 1024;
    *(_DWORD *)int v31 = v24;
    *(_WORD *)&v31[4] = 2048;
    *(void *)&v31[6] = a1;
    *(_WORD *)&v31[14] = 2080;
    *(void *)&v31[16] = "arec";
    *(_WORD *)&v31[24] = 2080;
    *(void *)&v31[26] = "srp-mdns-proxy.c";
    __int16 v32 = 1024;
    LODWORD(v33) = 595;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v28, 0x36u);
    int v24 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v24 - 1;
  if (v24 == 1)
  {
    int v26 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v28 = 136447234;
      int v29 = "srp_ml_eid_mapping_callback";
      __int16 v30 = 2048;
      *(void *)int v31 = a1;
      *(_WORD *)&v31[8] = 2080;
      *(void *)&v31[10] = "arec";
      *(_WORD *)&v31[18] = 2080;
      *(void *)&v31[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v31[28] = 1024;
      *(_DWORD *)&v31[30] = 595;
      _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v28, 0x30u);
    }
    ++adv_record_finalized;
    adv_record_finalize(a1);
  }
}

void srp_adv_host_context_release(int *a1)
{
  if (!a1) {
    return;
  }
  int v2 = *a1;
  if (!*a1)
  {
    uint64_t v3 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v6 = 136447490;
    uint64_t v7 = "srp_adv_host_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)int v9 = 0;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "host";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "srp-mdns-proxy.c";
    __int16 v10 = 1024;
    int v11 = 686;
    uint64_t v5 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  uint64_t v3 = global_os_log;
  if (v2 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v6 = 136447490;
    uint64_t v7 = "srp_adv_host_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)int v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "host";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "srp-mdns-proxy.c";
    __int16 v10 = 1024;
    int v11 = 686;
    uint64_t v5 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, v5, (uint8_t *)&v6, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 136447490;
    uint64_t v7 = "srp_adv_host_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)int v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "host";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "srp-mdns-proxy.c";
    __int16 v10 = 1024;
    int v11 = 686;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v6, 0x36u);
    int v2 = *a1;
  }
  *a1 = v2 - 1;
  if (v2 == 1)
  {
    uint64_t v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 136447234;
      uint64_t v7 = "srp_adv_host_context_release";
      __int16 v8 = 2048;
      *(void *)int v9 = a1;
      *(_WORD *)&v9[8] = 2080;
      *(void *)&v9[10] = "host";
      *(_WORD *)&v9[18] = 2080;
      *(void *)&v9[20] = "srp-mdns-proxy.c";
      *(_WORD *)&v9[28] = 1024;
      *(_DWORD *)&v9[30] = 686;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v6, 0x30u);
    }
    ++adv_host_finalized;
    adv_host_finalize((uint64_t)a1);
  }
}

void lease_callback(uint64_t a1)
{
  *(void *)uint64_t v47 = 0;
  *(void *)&v47[8] = 0;
  gettimeofday((timeval *)v47, 0);
  uint64_t v2 = *(void *)v47;
  int v3 = *(_DWORD *)&v47[8];
  uint64_t v4 = host_ready(a1);
  uint64_t v5 = global_os_log;
  BOOL v6 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (!v4)
  {
    if (!v6) {
      return;
    }
    *(_DWORD *)uint64_t v47 = 136446210;
    *(void *)&v47[4] = "lease_callback";
    int v9 = "%{public}s: host expired";
    __int16 v10 = v5;
    goto LABEL_40;
  }
  uint64_t v7 = 1000 * v2 + v3 / 1000;
  if (v6)
  {
    uint64_t v8 = *(void *)(a1 + 56);
    *(_DWORD *)uint64_t v47 = 136446723;
    *(void *)&v47[4] = "lease_callback";
    *(_WORD *)&v47[12] = 2160;
    *(void *)&v47[14] = 1752392040;
    *(_WORD *)&v47[22] = 2081;
    *(void *)&v47[24] = v8;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: host %{private, mask.hash}s", v47, 0x20u);
  }
  if (*(void *)(a1 + 256) < v7)
  {
    delete_host(a1);
    return;
  }
  int v11 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = *(void *)(a1 + 56);
    *(_DWORD *)uint64_t v47 = 136446723;
    *(void *)&v47[4] = "lease_callback";
    *(_WORD *)&v47[12] = 2160;
    *(void *)&v47[14] = 1752392040;
    *(_WORD *)&v47[22] = 2081;
    *(void *)&v47[24] = v12;
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: host %{private, mask.hash}s is still alive", v47, 0x20u);
  }
  uint64_t v13 = *(void *)(a1 + 112);
  if (!v13)
  {
    uint64_t v35 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)uint64_t v47 = 136446210;
    *(void *)&v47[4] = "lease_callback";
    int v9 = "%{public}s: no instances";
    __int16 v10 = v35;
LABEL_40:
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, v9, v47, 0xCu);
    return;
  }
  LODWORD(v14) = *(_DWORD *)(v13 + 4);
  if ((int)v14 <= 0)
  {
    int v32 = 0;
    uint64_t v30 = *(void *)(a1 + 256);
  }
  else
  {
    uint64_t v15 = 0;
    do
    {
      int v16 = *(void **)(*(void *)(v13 + 8) + 8 * v15);
      if (v16)
      {
        uint64_t v17 = *((void *)v16 + 13);
        int v18 = global_os_log;
        BOOL v19 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
        if (v17 >= v7)
        {
          if (v19)
          {
            uint64_t v27 = *(void *)(a1 + 56);
            uint64_t v28 = *((void *)v16 + 6);
            uint64_t v29 = *((void *)v16 + 7);
            *(_DWORD *)uint64_t v47 = 136447747;
            *(void *)&v47[4] = "lease_callback";
            *(_WORD *)&v47[12] = 2160;
            *(void *)&v47[14] = 1752392040;
            *(_WORD *)&v47[22] = 2081;
            *(void *)&v47[24] = v27;
            *(_WORD *)&v47[32] = 2160;
            *(void *)&v47[34] = 1752392040;
            *(_WORD *)&v47[42] = 2081;
            *(void *)&v47[44] = v28;
            *(_WORD *)&v47[52] = 2160;
            uint64_t v48 = 1752392040;
            __int16 v49 = 2081;
            uint64_t v50 = v29;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: host %{private, mask.hash}s instance %{private, mask.hash}s.%{private, mask.hash}s has not expired", v47, 0x48u);
          }
        }
        else
        {
          if (v19)
          {
            uint64_t v20 = *(void *)(a1 + 56);
            uint64_t v21 = *((void *)v16 + 6);
            uint64_t v22 = *((void *)v16 + 7);
            *(_DWORD *)uint64_t v47 = 136447747;
            *(void *)&v47[4] = "lease_callback";
            *(_WORD *)&v47[12] = 2160;
            *(void *)&v47[14] = 1752392040;
            *(_WORD *)&v47[22] = 2081;
            *(void *)&v47[24] = v20;
            *(_WORD *)&v47[32] = 2160;
            *(void *)&v47[34] = 1752392040;
            *(_WORD *)&v47[42] = 2081;
            *(void *)&v47[44] = v21;
            *(_WORD *)&v47[52] = 2160;
            uint64_t v48 = 1752392040;
            __int16 v49 = 2081;
            uint64_t v50 = v22;
            _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: host %{private, mask.hash}s instance %{private, mask.hash}s.%{private, mask.hash}s has expired", v47, 0x48u);
          }
          uint64_t v23 = (int *)*((void *)v16 + 1);
          if (v23)
          {
            *((void *)v16 + 1) = 0;
            ioloop_dnssd_txn_release_(v23, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 1323);
          }
          *(void *)(*(void *)(*(void *)(a1 + 112) + 8) + 8 * v15) = 0;
          int v24 = *(_DWORD *)v16;
          if (!*(_DWORD *)v16)
          {
            uint64_t v46 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)uint64_t v47 = 136447490;
              *(void *)&v47[4] = "lease_callback";
              *(_WORD *)&v47[12] = 1024;
              *(_DWORD *)&v47[14] = 0;
              *(_WORD *)&v47[18] = 2048;
              *(void *)&v47[20] = v16;
              *(_WORD *)&v47[28] = 2080;
              *(void *)&v47[30] = "instance";
              *(_WORD *)&v47[38] = 2080;
              *(void *)&v47[40] = "srp-mdns-proxy.c";
              *(_WORD *)&v47[48] = 1024;
              *(_DWORD *)&v47[50] = 1326;
              __int16 v44 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
              uint64_t v45 = v46;
              goto LABEL_60;
            }
LABEL_61:
            abort();
          }
          int v25 = global_os_log;
          if (v24 >= 10001)
          {
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
            {
              *(_DWORD *)uint64_t v47 = 136447490;
              *(void *)&v47[4] = "lease_callback";
              *(_WORD *)&v47[12] = 1024;
              *(_DWORD *)&v47[14] = v24;
              *(_WORD *)&v47[18] = 2048;
              *(void *)&v47[20] = v16;
              *(_WORD *)&v47[28] = 2080;
              *(void *)&v47[30] = "instance";
              *(_WORD *)&v47[38] = 2080;
              *(void *)&v47[40] = "srp-mdns-proxy.c";
              *(_WORD *)&v47[48] = 1024;
              *(_DWORD *)&v47[50] = 1326;
              __int16 v44 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
              uint64_t v45 = v25;
LABEL_60:
              _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_FAULT, v44, v47, 0x36u);
            }
            goto LABEL_61;
          }
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)uint64_t v47 = 136447490;
            *(void *)&v47[4] = "lease_callback";
            *(_WORD *)&v47[12] = 1024;
            *(_DWORD *)&v47[14] = v24;
            *(_WORD *)&v47[18] = 2048;
            *(void *)&v47[20] = v16;
            *(_WORD *)&v47[28] = 2080;
            *(void *)&v47[30] = "instance";
            *(_WORD *)&v47[38] = 2080;
            *(void *)&v47[40] = "srp-mdns-proxy.c";
            *(_WORD *)&v47[48] = 1024;
            *(_DWORD *)&v47[50] = 1326;
            _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v47, 0x36u);
            int v24 = *(_DWORD *)v16;
          }
          *(_DWORD *)int v16 = v24 - 1;
          if (v24 == 1)
          {
            int v26 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              *(_DWORD *)uint64_t v47 = 136447234;
              *(void *)&v47[4] = "lease_callback";
              *(_WORD *)&v47[12] = 2048;
              *(void *)&v47[14] = v16;
              *(_WORD *)&v47[22] = 2080;
              *(void *)&v47[24] = "instance";
              *(_WORD *)&v47[32] = 2080;
              *(void *)&v47[34] = "srp-mdns-proxy.c";
              *(_WORD *)&v47[42] = 1024;
              *(_DWORD *)&v47[44] = 1326;
              _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v47, 0x30u);
            }
            ++adv_instance_finalized;
            adv_instance_finalize(v16);
          }
        }
      }
      ++v15;
      uint64_t v13 = *(void *)(a1 + 112);
      uint64_t v14 = *(int *)(v13 + 4);
    }
    while (v15 < v14);
    uint64_t v30 = *(void *)(a1 + 256);
    if ((int)v14 < 1)
    {
      int v32 = 0;
    }
    else
    {
      uint64_t v31 = 0;
      int v32 = 0;
      do
      {
        uint64_t v33 = *(void *)(v13 + 8);
        uint64_t v34 = *(void *)(v33 + 8 * v31);
        if (v34)
        {
          *(void *)(v33 + 8 * v32++) = v34;
          if (v30 >= *(void *)(v34 + 104)) {
            uint64_t v30 = *(void *)(v34 + 104);
          }
          uint64_t v13 = *(void *)(a1 + 112);
        }
        ++v31;
        uint64_t v14 = *(int *)(v13 + 4);
      }
      while (v31 < v14);
    }
  }
  __int16 v36 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v37 = *(void *)(a1 + 56);
    *(_DWORD *)uint64_t v47 = 136446979;
    *(void *)&v47[4] = "lease_callback";
    *(_WORD *)&v47[12] = 2160;
    *(void *)&v47[14] = 1752392040;
    *(_WORD *)&v47[22] = 2081;
    *(void *)&v47[24] = v37;
    *(_WORD *)&v47[32] = 1024;
    *(_DWORD *)&v47[34] = v14 - v32;
    _os_log_impl((void *)&_mh_execute_header, v36, OS_LOG_TYPE_DEFAULT, "%{public}s: host %{private, mask.hash}s lost %d instances", v47, 0x26u);
    uint64_t v13 = *(void *)(a1 + 112);
  }
  *(_DWORD *)(v13 + 4) = v32;
  if ((unint64_t)(v30 - v7) >= 0x7FFFFFFF) {
    unsigned int v38 = 0x7FFFFFFF;
  }
  else {
    unsigned int v38 = v30 - v7;
  }
  ioloop_add_wake_event(*(void *)(a1 + 32), a1, (uint64_t)lease_callback, (uint64_t)srp_adv_host_context_release, v38);
  uint64_t v39 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v40 = *(_DWORD *)a1;
    *(_DWORD *)uint64_t v47 = 136447490;
    *(void *)&v47[4] = "lease_callback";
    *(_WORD *)&v47[12] = 1024;
    *(_DWORD *)&v47[14] = v40;
    *(_WORD *)&v47[18] = 2048;
    *(void *)&v47[20] = a1;
    *(_WORD *)&v47[28] = 2080;
    *(void *)&v47[30] = "host";
    *(_WORD *)&v47[38] = 2080;
    *(void *)&v47[40] = "srp-mdns-proxy.c";
    *(_WORD *)&v47[48] = 1024;
    *(_DWORD *)&v47[50] = 1359;
    _os_log_impl((void *)&_mh_execute_header, v39, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v47, 0x36u);
  }
  int v41 = *(_DWORD *)a1;
  if (*(_DWORD *)a1)
  {
    int v42 = v41 + 1;
    *(_DWORD *)a1 = v41 + 1;
    if (v41 + 1 >= 10001)
    {
      uint64_t v43 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)uint64_t v47 = 136447490;
        *(void *)&v47[4] = "lease_callback";
        *(_WORD *)&v47[12] = 1024;
        *(_DWORD *)&v47[14] = v42;
        *(_WORD *)&v47[18] = 2048;
        *(void *)&v47[20] = a1;
        *(_WORD *)&v47[28] = 2080;
        *(void *)&v47[30] = "host";
        *(_WORD *)&v47[38] = 2080;
        *(void *)&v47[40] = "srp-mdns-proxy.c";
        *(_WORD *)&v47[48] = 1024;
        *(_DWORD *)&v47[50] = 1359;
        __int16 v44 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
        uint64_t v45 = v43;
        goto LABEL_60;
      }
      goto LABEL_61;
    }
  }
  else
  {
    ++adv_host_created;
    *(_DWORD *)a1 = 1;
  }
}

void srp_mdns_flush(uint64_t a1)
{
  uint64_t v2 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136446210;
    __int16 v10 = "srp_mdns_flush";
    _os_log_impl((void *)&_mh_execute_header, v2, OS_LOG_TYPE_DEFAULT, "%{public}s: flushing all host entries.", buf, 0xCu);
  }
  uint64_t v3 = *(void *)(a1 + 8);
  if (v3)
  {
    do
    {
      uint64_t v4 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v5 = *(void *)(v3 + 56);
        uint64_t v6 = *(void *)(v3 + 64);
        *(_DWORD *)int buf = 136447235;
        __int16 v10 = "srp_mdns_flush";
        __int16 v11 = 2160;
        uint64_t v12 = 1752392040;
        __int16 v13 = 2081;
        uint64_t v14 = v5;
        __int16 v15 = 2160;
        uint64_t v16 = 1752392040;
        __int16 v17 = 2081;
        uint64_t v18 = v6;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: Flushing services and host entry for %{private, mask.hash}s (%{private, mask.hash}s)", buf, 0x34u);
      }
      uint64_t v7 = *(void *)(v3 + 48);
      if (v7) {
        update_failed(v7, 5u, 0);
      }
      uint64_t v8 = *(void *)(v3 + 40);
      host_remove((int *)v3);
      uint64_t v3 = v8;
    }
    while (v8);
  }
  *(void *)(a1 + 8) = 0;
}

int main(int argc, const char **argv, const char **envp)
{
  __endptr = 0;
  uint64_t v5 = malloc_type_calloc(1uLL, 0x128uLL, 0x10B0040518C6F66uLL);
  if (!v5 || (uint64_t v6 = strdup("srp-mdns-proxy"), (*v5 = v6) == 0))
  {
    unsigned int v38 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      __int16 v49 = "server_state_create";
      _os_log_impl((void *)&_mh_execute_header, v38, OS_LOG_TYPE_ERROR, "%{public}s: no memory for server state", buf, 0xCu);
    }
    free(v5);
    srp_servers = 0;
    return 1;
  }
  *(_OWORD *)((char *)v5 + 252) = xmmword_10007C620;
  *((_DWORD *)v5 + 68) = 0;
  uint64_t v7 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136446466;
    __int16 v49 = "server_state_create";
    __int16 v50 = 1024;
    LODWORD(v51) = 0;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: priority set to %d", buf, 0x12u);
  }
  srp_servers = (uint64_t)v5;
  int v8 = _os_feature_enabled_impl();
  *(unsigned char *)(srp_servers + 280) = v8;
  int v9 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v10 = "disabled";
    if (v8) {
      __int16 v10 = "enabled";
    }
    *(_DWORD *)int buf = 136446466;
    __int16 v49 = "main";
    __int16 v50 = 2082;
    int v51 = v10;
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: srp replication is %{public}s", buf, 0x16u);
  }
  int v11 = _os_feature_enabled_impl();
  *(unsigned char *)(srp_servers + 287) = v11;
  uint64_t v12 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    __int16 v13 = "disabled";
    if (v11) {
      __int16 v13 = "enabled";
    }
    *(_DWORD *)int buf = 136446466;
    __int16 v49 = "main";
    __int16 v50 = 2082;
    int v51 = v13;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: srp on demand is %{public}s", buf, 0x16u);
  }
  _os_feature_enabled_impl();
  unsigned int v14 = if_nametoindex("lo0");
  uint64_t v15 = srp_servers;
  *(_DWORD *)(srp_servers + 248) = v14;
  if (argc < 2) {
    goto LABEL_40;
  }
  int v16 = 0;
  LODWORD(v17) = 1;
  do
  {
    while (1)
    {
      int v18 = v17;
      BOOL v19 = argv[(int)v17];
      if (!strcmp(v19, "--max-lease-time")) {
        break;
      }
      if (!strcmp(v19, "--min-lease-time"))
      {
        uint64_t v17 = (int)v17 + 1;
        if (v18 + 1 == argc) {
          goto LABEL_62;
        }
        int v21 = strtoul(argv[v17], &__endptr, 10);
        uint64_t v15 = srp_servers;
        *(_DWORD *)(srp_servers + 256) = v21;
        uint64_t v22 = __endptr;
        uint64_t v23 = argv[v17];
LABEL_31:
        if (v22 == v23 || *v22) {
          goto LABEL_62;
        }
        goto LABEL_37;
      }
      if (strcmp(v19, "--log-stderr"))
      {
        if (!strcmp(v19, "--enable-replication"))
        {
          char v26 = 1;
        }
        else
        {
          if (strcmp(v19, "--disable-replication"))
          {
            if (strcmp(v19, "--fake-xpanid")) {
              goto LABEL_62;
            }
            uint64_t v24 = (int)v17 + 1;
            if (v24 == argc) {
              goto LABEL_62;
            }
            unint64_t v25 = strtoul(argv[v24], &__endptr, 16);
            uint64_t v15 = srp_servers;
            *(void *)(srp_servers + 240) = v25;
            uint64_t v22 = __endptr;
            uint64_t v23 = argv[v24];
            goto LABEL_31;
          }
          char v26 = 0;
        }
        *(unsigned char *)(v15 + 280) = v26;
        goto LABEL_37;
      }
      LODWORD(v17) = v17 + 1;
      int v16 = 1;
      if ((int)v17 >= argc) {
        goto LABEL_39;
      }
    }
    uint64_t v17 = (int)v17 + 1;
    if (v18 + 1 == argc
      || (int v20 = strtoul(argv[v17], &__endptr, 10),
          uint64_t v15 = srp_servers,
          *(_DWORD *)(srp_servers + 252) = v20,
          __endptr == argv[v17])
      || *__endptr)
    {
LABEL_62:
      usage();
    }
LABEL_37:
    LODWORD(v17) = v17 + 1;
  }
  while ((int)v17 < argc);
  if (v16) {
LABEL_39:
  }
    putenv("ACTIVITY_LOG_STDERR=1");
LABEL_40:
  uint64_t v27 = os_log_create("com.apple.srp-mdns-proxy", "0");
  global_os_log = (uint64_t)v27;
  if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136446722;
    __int16 v49 = "main";
    __int16 v50 = 2082;
    int v51 = "Nov 10 2024";
    __int16 v52 = 2082;
    uint32_t v53 = "04:16:55";
    _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "%{public}s: --------------------------------srp-mdns-proxy starting, compiled on %{public}s, %{public}s--------------------------------", buf, 0x20u);
  }
  ioloop_main_queue = (uint64_t)&_dispatch_main_q;
  dispatch_retain((dispatch_object_t)&_dispatch_main_q);
  ifpermit_add_permitted_interface_to_server_(srp_servers, "lo0", "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 4565);
  if (srp_mdns_shared_registration_txn_setup(srp_servers))
  {
    dns_service_op_not_to_be_freed = *(void *)(*(void *)(srp_servers + 16) + 8);
    if (!init_dnssd_proxy(srp_servers))
    {
      uint64_t v28 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v49 = "main";
        _os_log_impl((void *)&_mh_execute_header, v28, OS_LOG_TYPE_ERROR, "%{public}s: failed to setup dnssd-proxy", buf, 0xCu);
      }
    }
    uint64_t v29 = srp_servers;
    xpc_service = ioloop_create_xpc_service(srp_servers);
    *(void *)(v29 + 136) = xpc_service;
    if (!xpc_service)
    {
      uint64_t v31 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v49 = "main";
        _os_log_impl((void *)&_mh_execute_header, v31, OS_LOG_TYPE_ERROR, "%{public}s: Can't start advertising proxy control server.", buf, 0xCu);
      }
    }
    v46.rlim_t rlim_cur = 0;
    v46.rlim_t rlim_max = 0;
    if (getrlimit(8, &v46) < 0)
    {
      int v32 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        uint64_t v33 = __error();
        uint64_t v34 = strerror(*v33);
        *(_DWORD *)int buf = 136446466;
        __int16 v49 = "main";
        __int16 v50 = 2082;
        int v51 = v34;
        _os_log_impl((void *)&_mh_execute_header, v32, OS_LOG_TYPE_ERROR, "%{public}s: getrlimit failed: %{public}s", buf, 0x16u);
      }
    }
    rlim_t rlim_cur = v46.rlim_cur;
    if (v46.rlim_cur <= 0x3FF)
    {
      rlim_t rlim_max = v46.rlim_max;
      if (v46.rlim_max > 0x3FF)
      {
        v46.rlim_t rlim_cur = 1024;
      }
      else
      {
        uint64_t v37 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v49 = "main";
          __int16 v50 = 2048;
          int v51 = (const char *)rlim_max;
          _os_log_impl((void *)&_mh_execute_header, v37, OS_LOG_TYPE_DEFAULT, "%{public}s: file descriptor hard limit is %llu", buf, 0x16u);
          rlim_t rlim_cur = v46.rlim_cur;
          rlim_t rlim_max = v46.rlim_max;
        }
        if (rlim_cur != rlim_max) {
          v46.rlim_t rlim_cur = rlim_max;
        }
      }
      if (setrlimit(8, &v46) < 0)
      {
        int v40 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          int v41 = __error();
          int v42 = strerror(*v41);
          *(_DWORD *)int buf = 136446466;
          __int16 v49 = "main";
          __int16 v50 = 2082;
          int v51 = v42;
          _os_log_impl((void *)&_mh_execute_header, v40, OS_LOG_TYPE_ERROR, "%{public}s: setrlimit failed: %{public}s", buf, 0x16u);
        }
      }
    }
    srp_proxy_init();
    uint64_t v43 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-mdns-proxy.c", 4677);
    uint64_t v44 = srp_servers;
    *(void *)(srp_servers + 216) = v43;
    if (v43)
    {
      *(_DWORD *)(v44 + 268) = 1;
      object_allocation_stats_dump_callback(v44);
    }
    else
    {
      uint64_t v45 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136446210;
        __int16 v49 = "main";
        _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_DEFAULT, "%{public}s: no memory for srp_servers->object_allocation_stats_dump_wakeup", buf, 0xCu);
        ioloop();
      }
    }
    ioloop();
  }
  return 1;
}

void usage()
{
  uint64_t v0 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    int v1 = 136446210;
    uint64_t v2 = "usage";
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%{public}s: srp-mdns-proxy [--max-lease-time <seconds>] [--min-lease-time <seconds>] [--log-stderr]", (uint8_t *)&v1, 0xCu);
    uint64_t v0 = global_os_log;
  }
  if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR))
  {
    int v1 = 136446210;
    uint64_t v2 = "usage";
    _os_log_impl((void *)&_mh_execute_header, v0, OS_LOG_TYPE_ERROR, "%{public}s:                [--enable-replication | --disable-replication]", (uint8_t *)&v1, 0xCu);
  }
  exit(1);
}

BOOL object_allocation_stats_dump_callback(uint64_t a1)
{
  ioloop_dump_object_allocation_stats();
  if (*(_DWORD *)(a1 + 268))
  {
    srp_dump_server_stats(a1, 0, 1);
    int v2 = *(_DWORD *)(a1 + 268) - 1;
  }
  else
  {
    srp_dump_server_stats(a1, 1, 1);
    int v2 = 11;
  }
  *(_DWORD *)(a1 + 268) = v2;
  uint64_t v3 = *(void *)(a1 + 216);

  return ioloop_add_wake_event(v3, a1, (uint64_t)object_allocation_stats_dump_callback, 0, 0x493E0u);
}

void service_publisher_unadvertise_all(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 88);
  *(unsigned char *)(a1 + 268) = 0;
  for (uint64_t i = *(void **)(v1 + 8); i; uint64_t i = (void *)i[5])
  {
    uint64_t v3 = i[6];
    if (v3) {
      srp_mdns_update_finished(v3);
    }
    uint64_t v4 = i[12];
    if (v4 && *(int *)(v4 + 4) >= 1)
    {
      uint64_t v5 = 0;
      do
      {
        uint64_t v6 = *(void *)(*(void *)(v4 + 8) + 8 * v5);
        if (v6)
        {
          if (*(_WORD *)(v6 + 48) == 28 && *(_WORD *)(v6 + 50) == 16)
          {
            uint64_t v7 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              int v8 = *(unsigned __int8 **)(v6 + 40);
              int v9 = *v8;
              __int16 v10 = "ULA: ";
              if ((v9 & 0xFE) != 0xFC)
              {
                if (v9 != 254 || (__int16 v10 = "LUA: ", (v8[1] & 0xC0) != 0x80))
                {
                  __int16 v10 = "";
                  if ((v9 & 0xE0) == 0x20) {
                    __int16 v10 = "GUA: ";
                  }
                }
              }
              uint64_t v11 = i[7];
              uint64_t v12 = *(void *)(v6 + 8);
              *(_DWORD *)int buf = 136449795;
              uint64_t v24 = "service_publisher_unadvertise_all";
              __int16 v25 = 2160;
              uint64_t v26 = 1752392040;
              __int16 v27 = 2081;
              uint64_t v28 = v11;
              __int16 v29 = 2082;
              uint64_t v30 = (uint64_t)v10;
              __int16 v31 = 2160;
              uint64_t v32 = 1752392040;
              __int16 v33 = 1041;
              *(_DWORD *)uint64_t v34 = 6;
              *(_WORD *)&v34[4] = 2097;
              *(void *)&v34[6] = v8;
              *(_WORD *)&v34[14] = 2160;
              *(void *)&v34[16] = 1752392040;
              __int16 v35 = 1042;
              int v36 = 2;
              __int16 v37 = 2098;
              unsigned int v38 = v8 + 6;
              __int16 v39 = 2160;
              uint64_t v40 = 1752392040;
              __int16 v41 = 1041;
              int v42 = 8;
              __int16 v43 = 2097;
              uint64_t v44 = v8 + 8;
              __int16 v45 = 2048;
              uint64_t v46 = v6;
              __int16 v47 = 2048;
              uint64_t v48 = v12;
              _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: unadvertising %{private, mask.hash}s IN AAAA {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P} rec %p rref %p", buf, 0x8Cu);
            }
          }
          srp_mdns_shared_record_remove(v1, v6);
          DNSServiceReconfirmRecord(*(_DWORD *)(v1 + 248), i[7], (const char *)*(unsigned __int16 *)(v6 + 48), 1u, *(_WORD *)(v6 + 50), *(void *)(v6 + 40), v13);
          uint64_t v4 = i[12];
        }
        ++v5;
      }
      while (v5 < *(int *)(v4 + 4));
    }
    uint64_t v14 = i[13];
    if (v14) {
      srp_mdns_shared_record_remove(v1, v14);
    }
    uint64_t v15 = i[14];
    if (v15 && *(int *)(v15 + 4) >= 1)
    {
      uint64_t v16 = 0;
      do
      {
        uint64_t v17 = *(uint64_t **)(*(void *)(v15 + 8) + 8 * v16);
        if (v17)
        {
          uint64_t v18 = v17[1];
          if (v18)
          {
            BOOL v19 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v20 = v17[6];
              uint64_t v21 = v17[7];
              uint64_t v22 = *(void *)(v18 + 8);
              *(_DWORD *)int buf = 136447747;
              uint64_t v24 = "service_publisher_unadvertise_all";
              __int16 v25 = 2160;
              uint64_t v26 = 1752392040;
              __int16 v27 = 2081;
              uint64_t v28 = v20;
              __int16 v29 = 2160;
              uint64_t v30 = 1752392040;
              __int16 v31 = 2081;
              uint64_t v32 = v21;
              __int16 v33 = 2048;
              *(void *)uint64_t v34 = v17;
              *(_WORD *)&v34[8] = 2048;
              *(void *)&unsigned char v34[10] = v22;
              _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%{public}s: unadvertising %{private, mask.hash}s.%{private, mask.hash}s instance %p sdref %p", buf, 0x48u);
              uint64_t v18 = v17[1];
            }
            ioloop_dnssd_txn_cancel(v18);
            ioloop_dnssd_txn_release_((int *)v17[1], "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 193);
            v17[1] = 0;
            uint64_t v15 = i[14];
          }
        }
        ++v16;
      }
      while (v16 < *(int *)(v15 + 4));
    }
  }
}

void service_publisher_re_advertise_matching(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 56))
  {
    uint64_t v2 = *(void *)(a1 + 88);
    if (srp_mdns_shared_registration_txn_setup(v2))
    {
      uint64_t v3 = *(void *)(v2 + 8);
      if (v3)
      {
LABEL_4:
        uint64_t v4 = *(void *)(v3 + 96);
        if (!v4 || *(int *)(v4 + 4) < 1) {
          goto LABEL_53;
        }
        uint64_t v5 = 0;
        char v6 = 0;
        while (1)
        {
          uint64_t v7 = *(void *)(*(void *)(v4 + 8) + 8 * v5);
          if (v7 && *(_WORD *)(v7 + 48) == 28 && *(_WORD *)(v7 + 50) == 16)
          {
            int v8 = *(unsigned __int8 **)(v7 + 40);
            if (*(void *)(a1 + 232))
            {
              if (*(void *)(a1 + 192) == *(void *)v8 && *(void *)(a1 + 200) == *((void *)v8 + 1))
              {
LABEL_18:
                __int16 v10 = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                {
                  int v11 = *v8;
                  uint64_t v12 = "ULA: ";
                  if ((v11 & 0xFE) != 0xFC)
                  {
                    if (v11 != 254 || (uint64_t v12 = "LUA: ", (v8[1] & 0xC0) != 0x80))
                    {
                      uint64_t v12 = "";
                      if ((v11 & 0xE0) == 0x20) {
                        uint64_t v12 = "GUA: ";
                      }
                    }
                  }
                  uint64_t v13 = *(void *)(v3 + 56);
                  *(_DWORD *)int buf = 136449283;
                  unsigned int v38 = "service_publisher_re_advertise_matching";
                  __int16 v39 = 2160;
                  *(void *)uint64_t v40 = 1752392040;
                  *(_WORD *)&v40[8] = 2081;
                  *(void *)&v40[10] = v13;
                  *(_WORD *)&v40[18] = 2082;
                  *(void *)&v40[20] = v12;
                  *(_WORD *)&char v40[28] = 2160;
                  *(void *)&v40[30] = 1752392040;
                  *(_WORD *)&v40[38] = 1041;
                  *(_DWORD *)__int16 v41 = 6;
                  *(_WORD *)&v41[4] = 2097;
                  *(void *)&v41[6] = v8;
                  *(_WORD *)&v41[14] = 2160;
                  *(void *)&v41[16] = 1752392040;
                  *(_WORD *)&v41[24] = 1042;
                  *(_DWORD *)&v41[26] = 2;
                  __int16 v42 = 2098;
                  __int16 v43 = v8 + 6;
                  __int16 v44 = 2160;
                  uint64_t v45 = 1752392040;
                  __int16 v46 = 1041;
                  int v47 = 8;
                  __int16 v48 = 2097;
                  __int16 v49 = v8 + 8;
                  _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: re-advertising %{private, mask.hash}s IN AAAA {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}", buf, 0x78u);
                }
                service_publisher_re_advertise_record(v2, v3, v7);
                uint64_t v4 = *(void *)(v3 + 96);
                char v6 = 1;
              }
            }
            else if (*(void *)(a1 + 176) == *(void *)v8)
            {
              goto LABEL_18;
            }
          }
          if (++v5 >= *(int *)(v4 + 4))
          {
            if (v6)
            {
              uint64_t v14 = *(void *)(v3 + 104);
              if (v14) {
                service_publisher_re_advertise_record(v2, v3, v14);
              }
              uint64_t v15 = *(void *)(v3 + 112);
              if (v15)
              {
                if (*(int *)(v15 + 4) >= 1)
                {
                  uint64_t v16 = 0;
                  while (2)
                  {
                    uint64_t v17 = *(_DWORD **)(*(void *)(v15 + 8) + 8 * v16);
                    if (!v17 || *((void *)v17 + 1)) {
                      goto LABEL_48;
                    }
                    DNSServiceRef sdRef = *(DNSServiceRef *)(*(void *)(v2 + 16) + 8);
                    uint64_t v18 = (DNSServiceAttribute *)srp_message_tsr_attribute_generate(0, *(_DWORD *)(v3 + 184), v50);
                    DNSServiceErrorType v19 = DNSServiceRegisterWithAttribute(&sdRef, 0x4808u, *(_DWORD *)(v2 + 248), *((const char **)v17 + 6), *((const char **)v17 + 7), 0, *(const char **)(v3 + 64), bswap32(*((unsigned __int16 *)v17 + 32)) >> 16, *((_WORD *)v17 + 40), *((const void **)v17 + 9), v18, (DNSServiceRegisterReply)service_publisher_instance_callback, v17);
                    uint64_t v20 = global_os_log;
                    BOOL v21 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
                    if (v19)
                    {
                      if (v21)
                      {
                        uint64_t v22 = *((void *)v17 + 6);
                        uint64_t v23 = *((void *)v17 + 7);
                        uint64_t v24 = *(void *)(v3 + 64);
                        *(_DWORD *)int buf = 136447747;
                        unsigned int v38 = "service_publisher_re_advertise_instance";
                        __int16 v39 = 2082;
                        *(void *)uint64_t v40 = v22;
                        *(_WORD *)&v40[8] = 2082;
                        *(void *)&v40[10] = v23;
                        *(_WORD *)&v40[18] = 2160;
                        *(void *)&v40[20] = 1752392040;
                        *(_WORD *)&char v40[28] = 2081;
                        *(void *)&v40[30] = v24;
                        *(_WORD *)&v40[38] = 1024;
                        *(_DWORD *)__int16 v41 = v19;
                        *(_WORD *)&v41[4] = 2048;
                        *(void *)&v41[6] = v17;
                        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%{public}s: DNSServiceRegister failed: %{public}s.%{public}s host %{private, mask.hash}s: %d (instance %p)", buf, 0x44u);
                      }
                      goto LABEL_46;
                    }
                    if (v21)
                    {
                      uint64_t v25 = *((void *)v17 + 6);
                      uint64_t v26 = *((void *)v17 + 7);
                      uint64_t v27 = *(void *)(v3 + 64);
                      *(_DWORD *)int buf = 136448003;
                      unsigned int v38 = "service_publisher_re_advertise_instance";
                      __int16 v39 = 2082;
                      *(void *)uint64_t v40 = v25;
                      *(_WORD *)&v40[8] = 2082;
                      *(void *)&v40[10] = v26;
                      *(_WORD *)&v40[18] = 2160;
                      *(void *)&v40[20] = 1752392040;
                      *(_WORD *)&char v40[28] = 2081;
                      *(void *)&v40[30] = v27;
                      *(_WORD *)&v40[38] = 2082;
                      *(void *)__int16 v41 = v50;
                      *(_WORD *)&v41[8] = 2048;
                      *(void *)&v41[10] = v17;
                      *(_WORD *)&v41[18] = 2048;
                      *(void *)&v41[20] = sdRef;
                      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%{public}s: DNSServiceRegister succeeded: %{public}s.%{public}s host %{private, mask.hash}s at %{public}s (instance %p sdref %p)", buf, 0x52u);
                    }
                    uint64_t v28 = ioloop_dnssd_txn_add_subordinate_((uint64_t)sdRef, (uint64_t)v17, (uint64_t)adv_instance_context_release, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 271);
                    *((void *)v17 + 1) = v28;
                    if (v28)
                    {
                      *((void *)v17 + 2) = *(void *)(v2 + 16);
                      __int16 v29 = global_os_log;
                      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                      {
                        int v30 = *v17;
                        *(_DWORD *)int buf = 136447490;
                        unsigned int v38 = "adv_instance_retain_";
                        __int16 v39 = 1024;
                        *(_DWORD *)uint64_t v40 = v30;
                        *(_WORD *)&v40[4] = 2048;
                        *(void *)&v40[6] = v17;
                        *(_WORD *)&v40[14] = 2080;
                        *(void *)&v40[16] = "instance";
                        *(_WORD *)&v40[24] = 2080;
                        *(void *)&v40[26] = "service-publisher.c";
                        *(_WORD *)&unsigned char v40[34] = 1024;
                        *(_DWORD *)&v40[36] = 278;
                        _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                      }
                      int v31 = *v17;
                      if (!*v17)
                      {
                        ++adv_instance_created;
                        int v31 = *v17;
                      }
                      int v32 = v31 + 1;
                      *uint64_t v17 = v31 + 1;
                      if (v31 + 1 >= 10001)
                      {
                        __int16 v35 = global_os_log;
                        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                        {
                          *(_DWORD *)int buf = 136447490;
                          unsigned int v38 = "adv_instance_retain_";
                          __int16 v39 = 1024;
                          *(_DWORD *)uint64_t v40 = v32;
                          *(_WORD *)&v40[4] = 2048;
                          *(void *)&v40[6] = v17;
                          *(_WORD *)&v40[14] = 2080;
                          *(void *)&v40[16] = "instance";
                          *(_WORD *)&v40[24] = 2080;
                          *(void *)&v40[26] = "service-publisher.c";
                          *(_WORD *)&unsigned char v40[34] = 1024;
                          *(_DWORD *)&v40[36] = 278;
                          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
                        }
                        abort();
                      }
LABEL_46:
                      DNSServiceAttributeDeallocate(v18);
                    }
                    else
                    {
                      __int16 v33 = global_os_log;
                      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)int buf = 136446210;
                        unsigned int v38 = "service_publisher_re_advertise_instance";
                        _os_log_impl((void *)&_mh_execute_header, v33, OS_LOG_TYPE_ERROR, "%{public}s: no memory for instance transaction.", buf, 0xCu);
                      }
                      DNSServiceRefDeallocate(sdRef);
                    }
                    uint64_t v15 = *(void *)(v3 + 112);
LABEL_48:
                    if (++v16 >= *(int *)(v15 + 4)) {
                      break;
                    }
                    continue;
                  }
                }
              }
            }
LABEL_53:
            uint64_t v3 = *(void *)(v3 + 40);
            if (!v3) {
              break;
            }
            goto LABEL_4;
          }
        }
      }
      *(unsigned char *)(a1 + 268) = 1;
    }
  }
  else
  {
    uint64_t v34 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136446210;
      unsigned int v38 = "service_publisher_re_advertise_matching";
      _os_log_impl((void *)&_mh_execute_header, v34, OS_LOG_TYPE_DEFAULT, "%{public}s: publisher is in an invalid state, so we shouldn't re-advertise anything.", buf, 0xCu);
    }
  }
}

void service_publisher_re_advertise_record(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6 = *(void *)(a2 + 8);
  uint64_t v7 = *(_DNSServiceRef_t **)(*(void *)(v6 + 16) + 8);
  int v8 = (DNSRecordRef *)(a3 + 8);
  uint64_t v9 = *(void *)(a3 + 8);
  if (v9)
  {
    uint64_t v10 = *(void *)(a3 + 24);
    uint64_t v11 = *(void *)(a1 + 16);
    uint64_t v12 = global_os_log;
    BOOL v13 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
    if (v10 == v11)
    {
      if (v13)
      {
        uint64_t v14 = *(void *)(a2 + 64);
        *(_DWORD *)int buf = 136446978;
        __int16 v29 = "service_publisher_re_advertise_record";
        __int16 v30 = 2082;
        *(void *)int v31 = v14;
        *(_WORD *)&v31[8] = 2048;
        *(void *)&v31[10] = a3;
        *(_WORD *)&v31[18] = 2048;
        *(void *)&v31[20] = v9;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: host is already registered: %{public}s (record %p rref %p)", buf, 0x2Au);
      }
      return;
    }
    if (v13)
    {
      uint64_t v15 = *(void *)(a2 + 64);
      *(_DWORD *)int buf = 136446978;
      __int16 v29 = "service_publisher_re_advertise_record";
      __int16 v30 = 2082;
      *(void *)int v31 = v15;
      *(_WORD *)&v31[8] = 2048;
      *(void *)&v31[10] = a3;
      *(_WORD *)&v31[18] = 2048;
      *(void *)&v31[20] = v9;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: host registration is stale: %{public}s (record %p rref %p)", buf, 0x2Au);
      uint64_t v6 = *(void *)(a2 + 8);
    }
    srp_mdns_shared_record_remove(v6, a3);
  }
  uint64_t v16 = (DNSServiceAttribute *)srp_message_tsr_attribute_generate(0, *(_DWORD *)(a2 + 184), (char *)v27 + 4);
  DNSServiceErrorType v17 = DNSServiceRegisterRecordWithAttribute(v7, v8, *(_DWORD *)(a1 + 248), *(void *)(a2 + 64), (const char *)*(unsigned __int16 *)(a3 + 48), *(_WORD *)(a3 + 50), *(void *)(a3 + 40), (uint16_t)v16, service_publisher_record_callback, a3, v27[0], (DNSServiceRegisterRecordReply)v27[1], v27[2]);
  uint64_t v18 = global_os_log;
  BOOL v19 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (v17)
  {
    if (v19)
    {
      uint64_t v20 = *(void *)(a2 + 56);
      *(_DWORD *)int buf = 136446978;
      __int16 v29 = "service_publisher_re_advertise_record";
      __int16 v30 = 2082;
      *(void *)int v31 = v20;
      *(_WORD *)&v31[8] = 1024;
      *(_DWORD *)&v31[10] = v17;
      *(_WORD *)&v31[14] = 2048;
      *(void *)&v31[16] = a3;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: DNSServiceRegisterRecord failed on host %{public}s: %d (record %p)", buf, 0x26u);
    }
  }
  else
  {
    if (v19)
    {
      uint64_t v21 = *(void *)(a2 + 56);
      uint64_t v22 = *(void *)(a3 + 8);
      *(_DWORD *)int buf = 136447234;
      __int16 v29 = "service_publisher_re_advertise_record";
      __int16 v30 = 2082;
      *(void *)int v31 = v21;
      *(_WORD *)&v31[8] = 2082;
      *(void *)&v31[10] = (char *)v27 + 4;
      *(_WORD *)&v31[18] = 2048;
      *(void *)&v31[20] = a3;
      *(_WORD *)&v31[28] = 2048;
      *(void *)&v31[30] = v22;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: DNSServiceRegisterRecord succeeded on host %{public}s at %{public}s (record %p rref %p)", buf, 0x34u);
      uint64_t v18 = global_os_log;
    }
    *(void *)(a3 + 24) = *(void *)(*(void *)(a2 + 8) + 16);
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEFAULT))
    {
      int v23 = *(_DWORD *)a3;
      *(_DWORD *)int buf = 136447490;
      __int16 v29 = "adv_record_retain_";
      __int16 v30 = 1024;
      *(_DWORD *)int v31 = v23;
      *(_WORD *)&v31[4] = 2048;
      *(void *)&v31[6] = a3;
      *(_WORD *)&v31[14] = 2080;
      *(void *)&v31[16] = "record";
      *(_WORD *)&v31[24] = 2080;
      *(void *)&v31[26] = "service-publisher.c";
      *(_WORD *)&unsigned char v31[34] = 1024;
      *(_DWORD *)&v31[36] = 338;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    int v24 = *(_DWORD *)a3;
    if (*(_DWORD *)a3)
    {
      int v25 = v24 + 1;
      *(_DWORD *)a3 = v24 + 1;
      if (v24 + 1 >= 10001)
      {
        uint64_t v26 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)int buf = 136447490;
          __int16 v29 = "adv_record_retain_";
          __int16 v30 = 1024;
          *(_DWORD *)int v31 = v25;
          *(_WORD *)&v31[4] = 2048;
          *(void *)&v31[6] = a3;
          *(_WORD *)&v31[14] = 2080;
          *(void *)&v31[16] = "record";
          *(_WORD *)&v31[24] = 2080;
          *(void *)&v31[26] = "service-publisher.c";
          *(_WORD *)&unsigned char v31[34] = 1024;
          *(_DWORD *)&v31[36] = 338;
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        abort();
      }
    }
    else
    {
      ++adv_record_created;
      *(_DWORD *)a3 = 1;
    }
  }
  DNSServiceAttributeDeallocate(v16);
}

void service_publisher_instance_callback(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7)
{
  uint64_t v12 = global_os_log;
  BOOL v13 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (a3)
  {
    if (v13)
    {
      uint64_t v14 = a7[1];
      if (v14) {
        uint64_t v14 = *(void *)(v14 + 8);
      }
      int v19 = 136448003;
      uint64_t v20 = "service_publisher_instance_callback";
      __int16 v21 = 2082;
      uint64_t v22 = a4;
      __int16 v23 = 2082;
      uint64_t v24 = a5;
      __int16 v25 = 2160;
      uint64_t v26 = 1752392040;
      __int16 v27 = 2081;
      uint64_t v28 = a6;
      __int16 v29 = 1024;
      *(_DWORD *)__int16 v30 = a3;
      *(_WORD *)&v30[4] = 2048;
      *(void *)&v30[6] = a7;
      *(_WORD *)&v30[14] = 2048;
      *(void *)&v30[16] = v14;
      _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: DNSServiceRegister failed: %{public}s.%{public}s host %{private, mask.hash}s: %d (instance %p sdref %p)", (uint8_t *)&v19, 0x4Eu);
    }
    ioloop_dnssd_txn_cancel(a7[1]);
    ioloop_dnssd_txn_release_((int *)a7[1], "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 210);
    a7[1] = 0;
  }
  else if (v13)
  {
    uint64_t v16 = a7[6];
    uint64_t v15 = a7[7];
    uint64_t v17 = *(void *)(a7[3] + 64);
    uint64_t v18 = a7[1];
    if (v18) {
      uint64_t v18 = *(void *)(v18 + 8);
    }
    int v19 = 136447747;
    uint64_t v20 = "service_publisher_instance_callback";
    __int16 v21 = 2082;
    uint64_t v22 = v16;
    __int16 v23 = 2082;
    uint64_t v24 = v15;
    __int16 v25 = 2160;
    uint64_t v26 = 1752392040;
    __int16 v27 = 2081;
    uint64_t v28 = v17;
    __int16 v29 = 2048;
    *(void *)__int16 v30 = a7;
    *(_WORD *)&v30[8] = 2048;
    *(void *)&v30[10] = v18;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: DNSServiceRegister succeeded: %{public}s.%{public}s host %{private, mask.hash}s (instance %p sdref %p)", (uint8_t *)&v19, 0x48u);
  }
}

void service_publisher_record_callback(uint64_t a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v8 = *(void *)(a5 + 16);
  if (v8) {
    uint64_t v9 = *(const char **)(v8 + 56);
  }
  else {
    uint64_t v9 = "<null>";
  }
  uint64_t v10 = global_os_log;
  if (a4)
  {
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      int v15 = 136447491;
      uint64_t v16 = "service_publisher_record_callback";
      __int16 v17 = 2160;
      *(void *)uint64_t v18 = 1752392040;
      *(_WORD *)&v18[8] = 2081;
      *(void *)&v18[10] = v9;
      *(_WORD *)&v18[18] = 2048;
      *(void *)&v18[20] = a5;
      *(_WORD *)&v18[28] = 2048;
      *(void *)&v18[30] = a2;
      *(_WORD *)&v18[38] = 1024;
      int v19 = a4;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%{public}s: re-registration for %{private, mask.hash}s (record %p rref %p) failed with code %d", (uint8_t *)&v15, 0x3Au);
    }
    *(void *)(a5 + 8) = 0;
    *(void *)(a5 + 24) = 0;
    int v11 = *(_DWORD *)a5;
    if (*(_DWORD *)a5)
    {
      uint64_t v12 = global_os_log;
      if (v11 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v15 = 136447490;
          uint64_t v16 = "adv_record_release_";
          __int16 v17 = 1024;
          *(_DWORD *)uint64_t v18 = v11;
          *(_WORD *)&v18[4] = 2048;
          *(void *)&v18[6] = a5;
          *(_WORD *)&unsigned char v18[14] = 2080;
          *(void *)&v18[16] = "record";
          *(_WORD *)&v18[24] = 2080;
          *(void *)&v18[26] = "service-publisher.c";
          *(_WORD *)&v18[34] = 1024;
          *(_DWORD *)&v18[36] = 294;
          _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v15, 0x36u);
          int v11 = *(_DWORD *)a5;
        }
        *(_DWORD *)a5 = v11 - 1;
        if (v11 == 1)
        {
          BOOL v13 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v15 = 136447234;
            uint64_t v16 = "adv_record_release_";
            __int16 v17 = 2048;
            *(void *)uint64_t v18 = a5;
            *(_WORD *)&v18[8] = 2080;
            *(void *)&v18[10] = "record";
            *(_WORD *)&v18[18] = 2080;
            *(void *)&v18[20] = "service-publisher.c";
            *(_WORD *)&v18[28] = 1024;
            *(_DWORD *)&v18[30] = 294;
            _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v15, 0x30u);
          }
          ++adv_record_finalized;
          adv_record_finalize(a5);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_23:
      }
        abort();
      int v15 = 136447490;
      uint64_t v16 = "adv_record_release_";
      __int16 v17 = 1024;
      *(_DWORD *)uint64_t v18 = v11;
      *(_WORD *)&v18[4] = 2048;
      *(void *)&v18[6] = a5;
      *(_WORD *)&unsigned char v18[14] = 2080;
      *(void *)&v18[16] = "record";
      *(_WORD *)&v18[24] = 2080;
      *(void *)&v18[26] = "service-publisher.c";
      *(_WORD *)&v18[34] = 1024;
      *(_DWORD *)&v18[36] = 294;
      uint64_t v14 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      uint64_t v12 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_23;
      }
      int v15 = 136447490;
      uint64_t v16 = "adv_record_release_";
      __int16 v17 = 1024;
      *(_DWORD *)uint64_t v18 = 0;
      *(_WORD *)&v18[4] = 2048;
      *(void *)&v18[6] = a5;
      *(_WORD *)&unsigned char v18[14] = 2080;
      *(void *)&v18[16] = "record";
      *(_WORD *)&v18[24] = 2080;
      *(void *)&v18[26] = "service-publisher.c";
      *(_WORD *)&v18[34] = 1024;
      *(_DWORD *)&v18[36] = 294;
      uint64_t v14 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_FAULT, v14, (uint8_t *)&v15, 0x36u);
    goto LABEL_23;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v15 = 136447235;
    uint64_t v16 = "service_publisher_record_callback";
    __int16 v17 = 2160;
    *(void *)uint64_t v18 = 1752392040;
    *(_WORD *)&v18[8] = 2081;
    *(void *)&v18[10] = v9;
    *(_WORD *)&v18[18] = 2048;
    *(void *)&v18[20] = a5;
    *(_WORD *)&v18[28] = 2048;
    *(void *)&v18[30] = a2;
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: re-registration for %{private, mask.hash}s (record %p rref %p) succeeded.", (uint8_t *)&v15, 0x34u);
  }
}

void service_publisher_release_(int *a1, char *a2, int a3)
{
  if (!a1) {
    return;
  }
  int v6 = *a1;
  if (!*a1)
  {
    uint64_t v7 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v11 = 136447490;
    uint64_t v12 = "service_publisher_release_";
    __int16 v13 = 1024;
    *(_DWORD *)uint64_t v14 = 0;
    *(_WORD *)&v14[4] = 2048;
    *(void *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(void *)&v14[16] = "omw";
    *(_WORD *)&v14[24] = 2080;
    *(void *)&v14[26] = strrchr(a2, 47) + 1;
    __int16 v15 = 1024;
    int v16 = a3;
    uint64_t v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  uint64_t v7 = global_os_log;
  if (v6 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v11 = 136447490;
    uint64_t v12 = "service_publisher_release_";
    __int16 v13 = 1024;
    *(_DWORD *)uint64_t v14 = v6;
    *(_WORD *)&v14[4] = 2048;
    *(void *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(void *)&v14[16] = "omw";
    *(_WORD *)&v14[24] = 2080;
    *(void *)&v14[26] = strrchr(a2, 47) + 1;
    __int16 v15 = 1024;
    int v16 = a3;
    uint64_t v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v11, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v11 = 136447490;
    uint64_t v12 = "service_publisher_release_";
    __int16 v13 = 1024;
    *(_DWORD *)uint64_t v14 = v6;
    *(_WORD *)&v14[4] = 2048;
    *(void *)&v14[6] = a1;
    *(_WORD *)&v14[14] = 2080;
    *(void *)&v14[16] = "omw";
    *(_WORD *)&v14[24] = 2080;
    *(void *)&v14[26] = strrchr(a2, 47) + 1;
    __int16 v15 = 1024;
    int v16 = a3;
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v11, 0x36u);
    int v6 = *a1;
  }
  *a1 = v6 - 1;
  if (v6 == 1)
  {
    uint64_t v8 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v9 = strrchr(a2, 47);
      int v11 = 136447234;
      uint64_t v12 = "service_publisher_release_";
      __int16 v13 = 2048;
      *(void *)uint64_t v14 = a1;
      *(_WORD *)&v14[8] = 2080;
      *(void *)&v14[10] = "omw";
      *(_WORD *)&v14[18] = 2080;
      *(void *)&v14[20] = v9 + 1;
      *(_WORD *)&v14[28] = 1024;
      *(_DWORD *)&v14[30] = a3;
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v11, 0x30u);
    }
    ++service_publisher_finalized;
    service_publisher_finalize((uint64_t)a1);
  }
}

void service_publisher_finalize(uint64_t a1)
{
  thread_service_release_(*(int **)(a1 + 128), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 456);
  thread_service_release_(*(int **)(a1 + 136), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 457);
  uint64_t v2 = *(void **)(a1 + 144);
  if (v2)
  {
    while (1)
    {
      *(void *)(a1 + 144) = v2[1];
      int v3 = *(_DWORD *)v2;
      if (!*(_DWORD *)v2) {
        break;
      }
      uint64_t v4 = global_os_log;
      if (v3 >= 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)int buf = 136447490;
          uint64_t v10 = "thread_service_list_release";
          __int16 v11 = 1024;
          *(_DWORD *)uint64_t v12 = v3;
          *(_WORD *)&void v12[4] = 2048;
          *(void *)&v12[6] = v2;
          *(_WORD *)&v12[14] = 2080;
          *(void *)&v12[16] = "service";
          *(_WORD *)&v12[24] = 2080;
          *(void *)&v12[26] = "thread-service.c";
          __int16 v13 = 1024;
          int v14 = 89;
          uint64_t v7 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
          uint64_t v8 = v4;
LABEL_18:
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, v7, buf, 0x36u);
        }
        goto LABEL_19;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136447490;
        uint64_t v10 = "thread_service_list_release";
        __int16 v11 = 1024;
        *(_DWORD *)uint64_t v12 = v3;
        *(_WORD *)&void v12[4] = 2048;
        *(void *)&v12[6] = v2;
        *(_WORD *)&v12[14] = 2080;
        *(void *)&v12[16] = "service";
        *(_WORD *)&v12[24] = 2080;
        *(void *)&v12[26] = "thread-service.c";
        __int16 v13 = 1024;
        int v14 = 89;
        _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        int v3 = *(_DWORD *)v2;
      }
      *(_DWORD *)uint64_t v2 = v3 - 1;
      if (v3 == 1)
      {
        uint64_t v5 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447234;
          uint64_t v10 = "thread_service_list_release";
          __int16 v11 = 2048;
          *(void *)uint64_t v12 = v2;
          *(_WORD *)&v12[8] = 2080;
          *(void *)&v12[10] = "service";
          *(_WORD *)&v12[18] = 2080;
          *(void *)&v12[20] = "thread-service.c";
          *(_WORD *)&v12[28] = 1024;
          *(_DWORD *)&v12[30] = 89;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
        }
        ++thread_service_finalized;
        free(v2);
      }
      uint64_t v2 = *(void **)(a1 + 144);
      if (!v2) {
        goto LABEL_11;
      }
    }
    uint64_t v6 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
    {
      *(_DWORD *)int buf = 136447490;
      uint64_t v10 = "thread_service_list_release";
      __int16 v11 = 1024;
      *(_DWORD *)uint64_t v12 = 0;
      *(_WORD *)&void v12[4] = 2048;
      *(void *)&v12[6] = v2;
      *(_WORD *)&v12[14] = 2080;
      *(void *)&v12[16] = "service";
      *(_WORD *)&v12[24] = 2080;
      *(void *)&v12[26] = "thread-service.c";
      __int16 v13 = 1024;
      int v14 = 89;
      uint64_t v7 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
      uint64_t v8 = v6;
      goto LABEL_18;
    }
LABEL_19:
    abort();
  }
LABEL_11:
  free(*(void **)(a1 + 8));
  free(*(void **)(a1 + 224));
  free(*(void **)(a1 + 232));
  free(*(void **)(a1 + 240));
  free(*(void **)(a1 + 72));
  ioloop_wakeup_release_(*(void **)(a1 + 96), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 465);
  free(*(void **)(a1 + 80));

  free((void *)a1);
}

uint64_t service_publisher_have_anycast_service(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 88) + 40);
  if (v1)
  {
    uint64_t v2 = *(void *)(v1 + 48);
    if (v2)
    {
      LOBYTE(v1) = 0;
      do
      {
        if (!*(unsigned char *)(v2 + 27) && *(_DWORD *)(v2 + 20) == 3)
        {
          thread_service_note(*(void *)(a1 + 72), v2, (uint64_t)"is present and supersedes our unicast service");
          LOBYTE(v1) = 1;
        }
        uint64_t v2 = *(void *)(v2 + 8);
      }
      while (v2);
    }
    else
    {
      LOBYTE(v1) = 0;
    }
  }
  return v1 & 1;
}

uint64_t service_publisher_have_competing_unicast_service(uint64_t a1, int a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 88) + 40);
  if (v2)
  {
    uint64_t v3 = *(void *)(v2 + 48);
    if (v3)
    {
      char v6 = 0;
      uint64_t v7 = *(void *)(a1 + 128);
      uint64_t v8 = &dnssd_client_states;
      while (1)
      {
        if (*(unsigned char *)(v3 + 27) || *(_DWORD *)(v3 + 20) != 2) {
          goto LABEL_27;
        }
        if (v7)
        {
          if (*(void *)(v3 + 64) == *(void *)(v7 + 64))
          {
            unint64_t v13 = bswap64(*(void *)(v3 + 64));
            unint64_t v14 = bswap64(*(void *)(v7 + 64));
            if (v13 == v14)
            {
              unint64_t v13 = bswap64(*(void *)(v3 + 72));
              unint64_t v14 = bswap64(*(void *)(v7 + 72));
              if (v13 == v14)
              {
                uint64_t v9 = *(void *)(a1 + 72);
                uint64_t v10 = v3;
                if (*(unsigned __int16 *)(v3 + 80) == *(unsigned __int16 *)(v7 + 80))
                {
                  uint64_t v18 = "is the one we are publishing.";
                  goto LABEL_38;
                }
                __int16 v15 = "is on our ml-eid but is not the one we are publishing, so it's stale.";
                goto LABEL_34;
              }
            }
            if (v13 < v14) {
              int v17 = -1;
            }
            else {
              int v17 = 1;
            }
            if (*(unsigned __int16 *)(v3 + 16) == *(unsigned __int16 *)(*(void *)(a1 + 88) + 276))
            {
              uint64_t v9 = *(void *)(a1 + 72);
              uint64_t v10 = v3;
              __int16 v15 = "is a stale service published on our rloc16 with a different ml-eid.";
LABEL_34:
              thread_service_note(v9, v10, (uint64_t)v15);
              service_publisher_unpublish_stale_service(a1, v3);
              goto LABEL_27;
            }
            uint64_t v9 = *(void *)(a1 + 72);
            uint64_t v10 = v3;
            if ((v17 & 0x80000000) == 0)
            {
              uint64_t v18 = "is not ours and loses against ours.";
LABEL_38:
              thread_service_note(v9, v10, (uint64_t)v18);
              goto LABEL_27;
            }
            __int16 v11 = "is not ours and wins against ours.";
          }
          else
          {
            uint64_t v9 = *(void *)(a1 + 72);
            uint64_t v10 = v3;
            __int16 v11 = "is a competing service.";
          }
        }
        else
        {
          if (*(unsigned __int16 *)(v3 + 16) == *(unsigned __int16 *)(*(void *)(a1 + 88) + 276)
            || *(unsigned char *)(a1 + 258)
            && (*(void *)(v3 + 64) == *(void *)(a1 + 176)
              ? (BOOL v16 = *(void *)(v3 + 72) == *(void *)(a1 + 184))
              : (BOOL v16 = 0),
                v16))
          {
            thread_service_note(*(void *)(a1 + 72), v3, (uint64_t)"is on our ml-eid or rloc16 but we aren't publishing it, so it's stale.");
            service_publisher_unpublish_stale_service(a1, v3);
            if (a2 && !*(unsigned char *)(a1 + 268) && !*(unsigned char *)(a1 + 269))
            {
              uint64_t v12 = *((void *)v8 + 306);
              if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)int buf = 136446210;
                __int16 v21 = "service_publisher_have_competing_unicast_service";
                _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: starting wakeup timer to publish cached services after stale service timeout.", buf, 0xCu);
              }
              *(unsigned char *)(a1 + 269) = 1;
              service_publisher_start_wait(a1, 0x7D0u);
              uint64_t v8 = &dnssd_client_states;
            }
            goto LABEL_27;
          }
          uint64_t v9 = *(void *)(a1 + 72);
          uint64_t v10 = v3;
          __int16 v11 = "is not ours and we aren't publishing.";
        }
        thread_service_note(v9, v10, (uint64_t)v11);
        char v6 = 1;
LABEL_27:
        uint64_t v3 = *(void *)(v3 + 8);
        if (!v3) {
          return v6 & 1;
        }
      }
    }
  }
  char v6 = 0;
  return v6 & 1;
}

void service_publisher_unpublish_stale_service(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v7 = 136446210;
    uint64_t v8 = "service_publisher_unpublish_stale_service";
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: setting seen_service_list to false", (uint8_t *)&v7, 0xCu);
  }
  *(unsigned char *)(a1 + 263) = 0;
  service_for_queue = service_publisher_create_service_for_queue(a2);
  if (service_for_queue)
  {
    char v6 = service_for_queue;
    service_publisher_queue_update(a1, (uint64_t)service_for_queue, 7);
    thread_service_release_(v6, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 691);
    *(unsigned char *)(a2 + 27) = 1;
  }
  else
  {
    thread_service_note(*(void *)(a1 + 72), a2, (uint64_t)"no memory for service to delete");
  }
}

void service_publisher_start_wait(uint64_t a1, unsigned int a2)
{
  ioloop_add_wake_event(*(void *)(a1 + 96), a1, (uint64_t)service_publisher_wait_expired, (uint64_t)service_publisher_context_release, a2);
  uint64_t v3 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = *(_DWORD *)a1;
    *(_DWORD *)int buf = 136447490;
    uint64_t v9 = "service_publisher_start_wait";
    __int16 v10 = 1024;
    int v11 = v4;
    __int16 v12 = 2048;
    uint64_t v13 = a1;
    __int16 v14 = 2080;
    __int16 v15 = "publisher";
    __int16 v16 = 2080;
    int v17 = "service-publisher.c";
    __int16 v18 = 1024;
    int v19 = 714;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
  }
  if (*(_DWORD *)a1)
  {
    int v5 = *(_DWORD *)a1 + 1;
    *(_DWORD *)a1 = v5;
    if (v5 >= 10001)
    {
      int v7 = v5;
      char v6 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)int buf = 136447490;
        uint64_t v9 = "service_publisher_start_wait";
        __int16 v10 = 1024;
        int v11 = v7;
        __int16 v12 = 2048;
        uint64_t v13 = a1;
        __int16 v14 = 2080;
        __int16 v15 = "publisher";
        __int16 v16 = 2080;
        int v17 = "service-publisher.c";
        __int16 v18 = 1024;
        int v19 = 714;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      }
      abort();
    }
  }
  else
  {
    ++service_publisher_created;
    *(_DWORD *)a1 = 1;
  }
}

void service_publisher_context_release(int *a1)
{
  if (!a1) {
    return;
  }
  int v2 = *a1;
  if (!*a1)
  {
    uint64_t v3 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v6 = 136447490;
    int v7 = "service_publisher_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)uint64_t v9 = 0;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "publisher";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "service-publisher.c";
    __int16 v10 = 1024;
    int v11 = 476;
    int v5 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_15;
  }
  uint64_t v3 = global_os_log;
  if (v2 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_16;
    }
    int v6 = 136447490;
    int v7 = "service_publisher_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)uint64_t v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "publisher";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "service-publisher.c";
    __int16 v10 = 1024;
    int v11 = 476;
    int v5 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
LABEL_15:
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_FAULT, v5, (uint8_t *)&v6, 0x36u);
LABEL_16:
    abort();
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v6 = 136447490;
    int v7 = "service_publisher_context_release";
    __int16 v8 = 1024;
    *(_DWORD *)uint64_t v9 = v2;
    *(_WORD *)&v9[4] = 2048;
    *(void *)&v9[6] = a1;
    *(_WORD *)&v9[14] = 2080;
    *(void *)&v9[16] = "publisher";
    *(_WORD *)&v9[24] = 2080;
    *(void *)&v9[26] = "service-publisher.c";
    __int16 v10 = 1024;
    int v11 = 476;
    _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v6, 0x36u);
    int v2 = *a1;
  }
  *a1 = v2 - 1;
  if (v2 == 1)
  {
    int v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v6 = 136447234;
      int v7 = "service_publisher_context_release";
      __int16 v8 = 2048;
      *(void *)uint64_t v9 = a1;
      *(_WORD *)&v9[8] = 2080;
      *(void *)&v9[10] = "publisher";
      *(_WORD *)&v9[18] = 2080;
      *(void *)&v9[20] = "service-publisher.c";
      *(_WORD *)&v9[28] = 1024;
      *(_DWORD *)&v9[30] = 476;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v6, 0x30u);
    }
    ++service_publisher_finalized;
    service_publisher_finalize((uint64_t)a1);
  }
}

void service_publisher_wait_expired(uint64_t a1)
{
  int v2 = state_machine_event_create(1);
  if (v2)
  {
    uint64_t v3 = v2;
    state_machine_event_deliver(a1 + 8, (uint64_t)v2);
    int v4 = *v3;
    if (*v3)
    {
      int v5 = global_os_log;
      if (v4 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v10 = 136447490;
          int v11 = "service_publisher_wait_expired";
          __int16 v12 = 1024;
          *(_DWORD *)uint64_t v13 = v4;
          *(_WORD *)&v13[4] = 2048;
          *(void *)&v13[6] = v3;
          *(_WORD *)&v13[14] = 2080;
          *(void *)&v13[16] = "event";
          *(_WORD *)&v13[24] = 2080;
          *(void *)&v13[26] = "service-publisher.c";
          __int16 v14 = 1024;
          int v15 = 706;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v10, 0x36u);
          int v4 = *v3;
        }
        *uint64_t v3 = v4 - 1;
        if (v4 == 1)
        {
          int v6 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v10 = 136447234;
            int v11 = "service_publisher_wait_expired";
            __int16 v12 = 2048;
            *(void *)uint64_t v13 = v3;
            *(_WORD *)&v13[8] = 2080;
            *(void *)&v13[10] = "event";
            *(_WORD *)&v13[18] = 2080;
            *(void *)&v13[20] = "service-publisher.c";
            *(_WORD *)&v13[28] = 1024;
            *(_DWORD *)&v13[30] = 706;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v10, 0x30u);
          }
          ++state_machine_event_finalized;
          int v7 = (void (*)(int *))*((void *)v3 + 4);
          if (v7) {
            v7(v3);
          }
          free(v3);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_20:
      }
        abort();
      int v10 = 136447490;
      int v11 = "service_publisher_wait_expired";
      __int16 v12 = 1024;
      *(_DWORD *)uint64_t v13 = v4;
      *(_WORD *)&v13[4] = 2048;
      *(void *)&v13[6] = v3;
      *(_WORD *)&v13[14] = 2080;
      *(void *)&v13[16] = "event";
      *(_WORD *)&v13[24] = 2080;
      *(void *)&v13[26] = "service-publisher.c";
      __int16 v14 = 1024;
      int v15 = 706;
      uint64_t v9 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      int v5 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_20;
      }
      int v10 = 136447490;
      int v11 = "service_publisher_wait_expired";
      __int16 v12 = 1024;
      *(_DWORD *)uint64_t v13 = 0;
      *(_WORD *)&v13[4] = 2048;
      *(void *)&v13[6] = v3;
      *(_WORD *)&v13[14] = 2080;
      *(void *)&v13[16] = "event";
      *(_WORD *)&v13[24] = 2080;
      *(void *)&v13[26] = "service-publisher.c";
      __int16 v14 = 1024;
      int v15 = 706;
      uint64_t v9 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, v9, (uint8_t *)&v10, 0x36u);
    goto LABEL_20;
  }
  __int16 v8 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    int v10 = 136446210;
    int v11 = "service_publisher_wait_expired";
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v10, 0xCu);
  }
}

_DWORD *service_publisher_create_service_for_queue(uint64_t a1)
{
  int v1 = *(_DWORD *)(a1 + 20);
  switch(v1)
  {
    case 1:
      return thread_service_pref_id_create_(*(_WORD *)(a1 + 16), (_DWORD *)(a1 + 64), (int *)(a1 + 68), *(unsigned char *)(a1 + 18), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 638);
    case 3:
      return thread_service_anycast_create_(*(_WORD *)(a1 + 16), *(unsigned char *)(a1 + 80), *(unsigned char *)(a1 + 18), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 635);
    case 2:
      return thread_service_unicast_create_(*(_WORD *)(a1 + 16), (_OWORD *)(a1 + 64), (_WORD *)(a1 + 80), *(unsigned char *)(a1 + 18), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 633);
  }
  return 0;
}

void service_publisher_queue_update(uint64_t a1, uint64_t a2, int a3)
{
  int v3 = *(_DWORD *)(a2 + 20);
  if (v3 == 2)
  {
    uint64_t v7 = *(void *)(a1 + 128);
    if (v7) {
      BOOL v8 = a2 == 0;
    }
    else {
      BOOL v8 = 1;
    }
    if (!v8
      && *(_DWORD *)(v7 + 20) == 2
      && *(void *)(v7 + 64) == *(void *)(a2 + 64)
      && *(void *)(v7 + 72) == *(void *)(a2 + 72)
      && *(unsigned __int16 *)(v7 + 80) == *(unsigned __int16 *)(a2 + 80))
    {
      int v10 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        int v15 = 136446466;
        __int16 v16 = "service_publisher_queue_update";
        __int16 v17 = 2048;
        uint64_t v18 = v7;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "%{public}s: published service still present: %p", (uint8_t *)&v15, 0x16u);
      }
    }
    *(_DWORD *)(a2 + 32) = a3;
    if (a3 == 6)
    {
      *(void *)(a1 + 128) = a2;
      thread_service_retain_((int *)a2, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 616);
    }
    int v11 = (void *)(a1 + 144);
    do
    {
      __int16 v12 = v11;
      uint64_t v13 = *v11;
      int v11 = (void *)(*v11 + 8);
    }
    while (v13);
    void *v12 = a2;
    thread_service_retain_((int *)a2, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 623);
    service_publisher_queue_run(a1);
  }
  else
  {
    __int16 v14 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      int v15 = 136446466;
      __int16 v16 = "service_publisher_queue_update";
      __int16 v17 = 1024;
      LODWORD(v18) = v3;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%{public}s: unsupported service type %d", (uint8_t *)&v15, 0x12u);
    }
  }
}

void service_publisher_queue_run(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 144);
  if (!v1)
  {
    uint64_t v11 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)int buf = 136446210;
    __int16 v27 = "service_publisher_queue_run";
    uint64_t v7 = "%{public}s: the queue is empty.";
    goto LABEL_12;
  }
  uint64_t v2 = *(unsigned int *)(v1 + 32);
  if ((v2 - 4) < 2)
  {
    uint64_t v11 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    *(_DWORD *)int buf = 136446210;
    __int16 v27 = "service_publisher_queue_run";
    uint64_t v7 = "%{public}s: there is a pending update at the head of the queue.";
LABEL_12:
    BOOL v8 = v11;
    os_log_type_t v9 = OS_LOG_TYPE_DEFAULT;
    uint32_t v10 = 12;
    goto LABEL_13;
  }
  if (v2 == 6)
  {
    int v12 = service_publisher_service_update(a1, *(void *)(a1 + 144), 1);
    if (!v12)
    {
      *(_DWORD *)(v1 + 32) = 4;
      __int16 v23 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v24 = *(_DWORD *)a1;
        *(_DWORD *)int buf = 136447490;
        __int16 v27 = "service_publisher_queue_run";
        __int16 v28 = 1024;
        int v29 = v24;
        __int16 v30 = 2048;
        uint64_t v31 = a1;
        __int16 v32 = 2080;
        __int16 v33 = "publisher";
        __int16 v34 = 2080;
        __int16 v35 = "service-publisher.c";
        __int16 v36 = 1024;
        int v37 = 583;
        _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      }
      int v20 = *(_DWORD *)a1;
      if (*(_DWORD *)a1)
      {
        int v25 = v20 + 1;
        *(_DWORD *)a1 = v20 + 1;
        if (v20 + 1 < 10001) {
          return;
        }
        uint64_t v22 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)int buf = 136447490;
          __int16 v27 = "service_publisher_queue_run";
          __int16 v28 = 1024;
          int v29 = v25;
          __int16 v30 = 2048;
          uint64_t v31 = a1;
          __int16 v32 = 2080;
          __int16 v33 = "publisher";
          __int16 v34 = 2080;
          __int16 v35 = "service-publisher.c";
          __int16 v36 = 1024;
          int v37 = 583;
          goto LABEL_36;
        }
LABEL_37:
        abort();
      }
LABEL_38:
      ++service_publisher_created;
      *(_DWORD *)a1 = v20 + 1;
      return;
    }
    int v13 = v12;
    __int16 v14 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446466;
      __int16 v27 = "service_publisher_queue_run";
      __int16 v28 = 1024;
      int v29 = v13;
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%{public}s: cti_add_service failed: %d", buf, 0x12u);
    }
    *(void *)(a1 + 144) = *(void *)(v1 + 8);
    int v15 = (int *)v1;
    int v16 = 580;
LABEL_22:
    thread_service_release_(v15, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", v16);
    return;
  }
  if (v2 != 7)
  {
    if (v2 > 7) {
      __int16 v17 = "<unknown>";
    }
    else {
      __int16 v17 = off_10008CFA8[v2];
    }
    snprintf((char *)buf, 0x100uLL, "is in unexpected state %s on the publication queue", v17);
    thread_service_note(*(void *)(a1 + 72), v1, (uint64_t)buf);
    *(void *)(a1 + 144) = *(void *)(v1 + 8);
    int v15 = (int *)v1;
    int v16 = 591;
    goto LABEL_22;
  }
  int v4 = service_publisher_service_update(a1, *(void *)(a1 + 144), 0);
  if (!v4)
  {
    *(_DWORD *)(v1 + 32) = 5;
    uint64_t v18 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v19 = *(_DWORD *)a1;
      *(_DWORD *)int buf = 136447490;
      __int16 v27 = "service_publisher_queue_run";
      __int16 v28 = 1024;
      int v29 = v19;
      __int16 v30 = 2048;
      uint64_t v31 = a1;
      __int16 v32 = 2080;
      __int16 v33 = "publisher";
      __int16 v34 = 2080;
      __int16 v35 = "service-publisher.c";
      __int16 v36 = 1024;
      int v37 = 573;
      _os_log_impl((void *)&_mh_execute_header, v18, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    int v20 = *(_DWORD *)a1;
    if (*(_DWORD *)a1)
    {
      int v21 = v20 + 1;
      *(_DWORD *)a1 = v20 + 1;
      if (v20 + 1 < 10001) {
        return;
      }
      uint64_t v22 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)int buf = 136447490;
        __int16 v27 = "service_publisher_queue_run";
        __int16 v28 = 1024;
        int v29 = v21;
        __int16 v30 = 2048;
        uint64_t v31 = a1;
        __int16 v32 = 2080;
        __int16 v33 = "publisher";
        __int16 v34 = 2080;
        __int16 v35 = "service-publisher.c";
        __int16 v36 = 1024;
        int v37 = 573;
LABEL_36:
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        goto LABEL_37;
      }
      goto LABEL_37;
    }
    goto LABEL_38;
  }
  int v5 = v4;
  uint64_t v6 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)int buf = 136446466;
    __int16 v27 = "service_publisher_queue_run";
    __int16 v28 = 1024;
    int v29 = v5;
    uint64_t v7 = "%{public}s: cti_remove_service failed: %d";
    BOOL v8 = v6;
    os_log_type_t v9 = OS_LOG_TYPE_ERROR;
    uint32_t v10 = 18;
LABEL_13:
    _os_log_impl((void *)&_mh_execute_header, v8, v9, v7, buf, v10);
  }
}

uint64_t service_publisher_service_update(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3 = 4294901747;
  int v4 = *(_DWORD *)(a2 + 20);
  switch(v4)
  {
    case 1:
      return 4294901756;
    case 3:
      size_t v7 = 0;
      bytes[0] = 92;
      bytes[1] = *(unsigned char *)(a2 + 80);
      size_t v8 = 2;
      break;
    case 2:
      bytes[0] = 93;
      long long v12 = *(_OWORD *)(a2 + 64);
      __int16 v13 = *(_WORD *)(a2 + 80);
      size_t v7 = 18;
      size_t v8 = 1;
      break;
    default:
      return v3;
  }
  xpc_object_t v9 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_data(v9, "service_data", bytes, v8);
  if (a3)
  {
    xpc_dictionary_set_data(v9, "server_data", &v12, v7);
    xpc_dictionary_set_uint64(v9, "enterprise_number", 0xAFAAuLL);
    xpc_dictionary_set_string(v9, "interface", "org.wpantund.v1");
    xpc_dictionary_set_string(v9, "path", "/org/wpantund/utun2");
    xpc_dictionary_set_string(v9, "method", "ServiceAdd");
    xpc_dictionary_set_BOOL(v9, "stable", 1);
    uint64_t v10 = setup_for_command(0, (uint64_t)"add_service", 0, 0, v9, a1, (uint64_t)service_publisher_update_callback, (uint64_t)cti_internal_reply_callback, 0, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 547);
  }
  else
  {
    xpc_dictionary_set_uint64(v9, "enterprise_number", 0xAFAAuLL);
    xpc_dictionary_set_string(v9, "interface", "org.wpantund.v1");
    xpc_dictionary_set_string(v9, "path", "/org/wpantund/utun2");
    xpc_dictionary_set_string(v9, "method", "ServiceRemove");
    uint64_t v10 = setup_for_command(0, (uint64_t)"remove_service", 0, 0, v9, a1, (uint64_t)service_publisher_update_callback, (uint64_t)cti_internal_reply_callback, 0, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 550);
  }
  uint64_t v3 = v10;
  xpc_release(v9);
  return v3;
}

void service_publisher_update_callback(uint64_t a1, int a2)
{
  if (*(unsigned char *)(a1 + 261))
  {
    int v3 = *(_DWORD *)a1;
    if (*(_DWORD *)a1)
    {
      int v4 = global_os_log;
      if (v3 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447490;
          int v24 = "service_publisher_update_callback";
          __int16 v25 = 1024;
          *(_DWORD *)uint64_t v26 = v3;
          *(_WORD *)&v26[4] = 2048;
          *(void *)&v26[6] = a1;
          *(_WORD *)&v26[14] = 2080;
          *(void *)&v26[16] = "publisher";
          *(_WORD *)&v26[24] = 2080;
          *(void *)&v26[26] = "service-publisher.c";
          __int16 v27 = 1024;
          int v28 = 486;
          _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          int v3 = *(_DWORD *)a1;
        }
        *(_DWORD *)a1 = v3 - 1;
        if (v3 == 1)
        {
          int v5 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136447234;
            int v24 = "service_publisher_update_callback";
            __int16 v25 = 2048;
            *(void *)uint64_t v26 = a1;
            *(_WORD *)&v26[8] = 2080;
            *(void *)&v26[10] = "publisher";
            *(_WORD *)&v26[18] = 2080;
            *(void *)&v26[20] = "service-publisher.c";
            *(_WORD *)&v26[28] = 1024;
            *(_DWORD *)&v26[30] = 486;
            uint64_t v6 = buf;
LABEL_34:
            _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", v6, 0x30u);
            goto LABEL_35;
          }
          goto LABEL_35;
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_48:
      }
        abort();
      *(_DWORD *)int buf = 136447490;
      int v24 = "service_publisher_update_callback";
      __int16 v25 = 1024;
      *(_DWORD *)uint64_t v26 = v3;
      *(_WORD *)&v26[4] = 2048;
      *(void *)&v26[6] = a1;
      *(_WORD *)&v26[14] = 2080;
      *(void *)&v26[16] = "publisher";
      *(_WORD *)&v26[24] = 2080;
      *(void *)&v26[26] = "service-publisher.c";
      __int16 v27 = 1024;
      int v28 = 486;
      int v15 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      int v4 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_48;
      }
      *(_DWORD *)int buf = 136447490;
      int v24 = "service_publisher_update_callback";
      __int16 v25 = 1024;
      *(_DWORD *)uint64_t v26 = 0;
      *(_WORD *)&v26[4] = 2048;
      *(void *)&v26[6] = a1;
      *(_WORD *)&v26[14] = 2080;
      *(void *)&v26[16] = "publisher";
      *(_WORD *)&v26[24] = 2080;
      *(void *)&v26[26] = "service-publisher.c";
      __int16 v27 = 1024;
      int v28 = 486;
      int v15 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    int v16 = buf;
LABEL_47:
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_FAULT, v15, v16, 0x36u);
    goto LABEL_48;
  }
  uint64_t v7 = *(void *)(a1 + 144);
  if (!v7)
  {
    uint64_t v11 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      int v24 = "service_publisher_update_callback";
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%{public}s: no pending service update", buf, 0xCu);
    }
    return;
  }
  uint64_t v9 = *(unsigned int *)(v7 + 32);
  if (v9 > 7) {
    uint64_t v10 = "<unknown>";
  }
  else {
    uint64_t v10 = off_10008CFA8[v9];
  }
  snprintf((char *)buf, 0x100uLL, "is in state %s, status = %d", v10, a2);
  thread_service_note(*(void *)(a1 + 72), v7, (uint64_t)buf);
  int v12 = *(_DWORD *)(v7 + 32);
  if (a2)
  {
    if (v12 == 4)
    {
      int v13 = 2;
    }
    else
    {
      if (v12 != 5) {
        goto LABEL_25;
      }
      int v13 = 3;
    }
  }
  else if (v12 == 4)
  {
    int v13 = 0;
  }
  else
  {
    if (v12 != 5) {
      goto LABEL_25;
    }
    int v13 = 1;
  }
  *(_DWORD *)(v7 + 32) = v13;
LABEL_25:
  *(void *)(a1 + 144) = *(void *)(v7 + 8);
  thread_service_release_((int *)v7, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 512);
  if (!*(unsigned char *)(a1 + 261)) {
    service_publisher_queue_run(a1);
  }
  int v14 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    int v4 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_48;
    }
    *(_DWORD *)__int16 v17 = 136447490;
    uint64_t v18 = "service_publisher_update_callback";
    __int16 v19 = 1024;
    *(_DWORD *)int v20 = 0;
    *(_WORD *)&uint8_t v20[4] = 2048;
    *(void *)&v20[6] = a1;
    *(_WORD *)&unsigned char v20[14] = 2080;
    *(void *)&v20[16] = "publisher";
    *(_WORD *)&v20[24] = 2080;
    *(void *)&v20[26] = "service-publisher.c";
    __int16 v21 = 1024;
    int v22 = 516;
    int v15 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_46:
    int v16 = v17;
    goto LABEL_47;
  }
  int v4 = global_os_log;
  if (v14 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_48;
    }
    *(_DWORD *)__int16 v17 = 136447490;
    uint64_t v18 = "service_publisher_update_callback";
    __int16 v19 = 1024;
    *(_DWORD *)int v20 = v14;
    *(_WORD *)&uint8_t v20[4] = 2048;
    *(void *)&v20[6] = a1;
    *(_WORD *)&unsigned char v20[14] = 2080;
    *(void *)&v20[16] = "publisher";
    *(_WORD *)&v20[24] = 2080;
    *(void *)&v20[26] = "service-publisher.c";
    __int16 v21 = 1024;
    int v22 = 516;
    int v15 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_46;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)__int16 v17 = 136447490;
    uint64_t v18 = "service_publisher_update_callback";
    __int16 v19 = 1024;
    *(_DWORD *)int v20 = v14;
    *(_WORD *)&uint8_t v20[4] = 2048;
    *(void *)&v20[6] = a1;
    *(_WORD *)&unsigned char v20[14] = 2080;
    *(void *)&v20[16] = "publisher";
    *(_WORD *)&v20[24] = 2080;
    *(void *)&v20[26] = "service-publisher.c";
    __int16 v21 = 1024;
    int v22 = 516;
    _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", v17, 0x36u);
    int v14 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v14 - 1;
  if (v14 == 1)
  {
    int v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)__int16 v17 = 136447234;
      uint64_t v18 = "service_publisher_update_callback";
      __int16 v19 = 2048;
      *(void *)int v20 = a1;
      *(_WORD *)&v20[8] = 2080;
      *(void *)&v20[10] = "publisher";
      *(_WORD *)&v20[18] = 2080;
      *(void *)&v20[20] = "service-publisher.c";
      *(_WORD *)&v20[28] = 1024;
      *(_DWORD *)&v20[30] = 516;
      uint64_t v6 = v17;
      goto LABEL_34;
    }
LABEL_35:
    ++service_publisher_finalized;
    service_publisher_finalize(a1);
  }
}

void service_publisher_wanted_service_added(uint64_t a1)
{
  uint64_t v2 = state_machine_event_create(19);
  if (v2)
  {
    int v3 = v2;
    state_machine_event_deliver(a1 + 8, (uint64_t)v2);
    int v4 = *v3;
    if (*v3)
    {
      int v5 = global_os_log;
      if (v4 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v10 = 136447490;
          uint64_t v11 = "service_publisher_wanted_service_added";
          __int16 v12 = 1024;
          *(_DWORD *)int v13 = v4;
          *(_WORD *)&v13[4] = 2048;
          *(void *)&v13[6] = v3;
          *(_WORD *)&v13[14] = 2080;
          *(void *)&v13[16] = "event";
          *(_WORD *)&v13[24] = 2080;
          *(void *)&v13[26] = "service-publisher.c";
          __int16 v14 = 1024;
          int v15 = 833;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v10, 0x36u);
          int v4 = *v3;
        }
        *int v3 = v4 - 1;
        if (v4 == 1)
        {
          uint64_t v6 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v10 = 136447234;
            uint64_t v11 = "service_publisher_wanted_service_added";
            __int16 v12 = 2048;
            *(void *)int v13 = v3;
            *(_WORD *)&v13[8] = 2080;
            *(void *)&v13[10] = "event";
            *(_WORD *)&v13[18] = 2080;
            *(void *)&v13[20] = "service-publisher.c";
            *(_WORD *)&v13[28] = 1024;
            *(_DWORD *)&v13[30] = 833;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v10, 0x30u);
          }
          ++state_machine_event_finalized;
          uint64_t v7 = (void (*)(int *))*((void *)v3 + 4);
          if (v7) {
            v7(v3);
          }
          free(v3);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_20:
      }
        abort();
      int v10 = 136447490;
      uint64_t v11 = "service_publisher_wanted_service_added";
      __int16 v12 = 1024;
      *(_DWORD *)int v13 = v4;
      *(_WORD *)&v13[4] = 2048;
      *(void *)&v13[6] = v3;
      *(_WORD *)&v13[14] = 2080;
      *(void *)&v13[16] = "event";
      *(_WORD *)&v13[24] = 2080;
      *(void *)&v13[26] = "service-publisher.c";
      __int16 v14 = 1024;
      int v15 = 833;
      uint64_t v9 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      int v5 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_20;
      }
      int v10 = 136447490;
      uint64_t v11 = "service_publisher_wanted_service_added";
      __int16 v12 = 1024;
      *(_DWORD *)int v13 = 0;
      *(_WORD *)&v13[4] = 2048;
      *(void *)&v13[6] = v3;
      *(_WORD *)&v13[14] = 2080;
      *(void *)&v13[16] = "event";
      *(_WORD *)&v13[24] = 2080;
      *(void *)&v13[26] = "service-publisher.c";
      __int16 v14 = 1024;
      int v15 = 833;
      uint64_t v9 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, v9, (uint8_t *)&v10, 0x36u);
    goto LABEL_20;
  }
  size_t v8 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    int v10 = 136446210;
    uint64_t v11 = "service_publisher_wanted_service_added";
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v10, 0xCu);
  }
}

void service_publisher_cancel(uint64_t a1)
{
  ioloop_cancel_wake_event(*(void *)(a1 + 96));
  service_publisher_listener_cancel(a1);
  service_tracker_callback_cancel(*(void **)(*(void *)(a1 + 88) + 40), a1);
  thread_tracker_callback_cancel(*(void **)(*(void *)(a1 + 88) + 56), a1);
  uint64_t v2 = *(void **)(*(void *)(a1 + 88) + 64);
  if (v2)
  {
    int v3 = (void *)v2[6];
    if (v3)
    {
      int v4 = v3 + 3;
      if (v3[3] == a1)
      {
        int v5 = v2 + 6;
      }
      else
      {
        do
        {
          int v5 = v3;
          int v3 = (void *)*v3;
          if (!v3) {
            goto LABEL_19;
          }
        }
        while (v3[3] != a1);
        int v4 = v3 + 3;
      }
      void *v5 = *v3;
      uint64_t v6 = (void (*)(void))v3[1];
      if (v6) {
        v6(*v4);
      }
      free(v3);
      if (!v2[6])
      {
        int v7 = *(_DWORD *)v2;
        if (*(_DWORD *)v2)
        {
          size_t v8 = global_os_log;
          if (v7 < 10001)
          {
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
            {
              int v24 = 136447490;
              __int16 v25 = "node_type_tracker_callback_cancel";
              __int16 v26 = 1024;
              *(_DWORD *)__int16 v27 = v7;
              *(_WORD *)&DNSServiceAttributeRef v27[4] = 2048;
              *(void *)&v27[6] = v2;
              *(_WORD *)&v27[14] = 2080;
              *(void *)&v27[16] = "tracker";
              *(_WORD *)&v27[24] = 2080;
              *(void *)&v27[26] = "node-type-tracker.c";
              __int16 v28 = 1024;
              int v29 = 282;
              _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v24, 0x36u);
              int v7 = *(_DWORD *)v2;
            }
            *(_DWORD *)uint64_t v2 = v7 - 1;
            if (v7 == 1)
            {
              uint64_t v9 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                int v24 = 136447234;
                __int16 v25 = "node_type_tracker_callback_cancel";
                __int16 v26 = 2048;
                *(void *)__int16 v27 = v2;
                *(_WORD *)&v27[8] = 2080;
                *(void *)&v27[10] = "tracker";
                *(_WORD *)&v27[18] = 2080;
                *(void *)&v27[20] = "node-type-tracker.c";
                *(_WORD *)&v27[28] = 1024;
                *(_DWORD *)&v27[30] = 282;
                _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v24, 0x30u);
              }
              ++node_type_tracker_finalized;
              free(v2);
            }
            goto LABEL_19;
          }
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            int v24 = 136447490;
            __int16 v25 = "node_type_tracker_callback_cancel";
            __int16 v26 = 1024;
            *(_DWORD *)__int16 v27 = v7;
            *(_WORD *)&DNSServiceAttributeRef v27[4] = 2048;
            *(void *)&v27[6] = v2;
            *(_WORD *)&v27[14] = 2080;
            *(void *)&v27[16] = "tracker";
            *(_WORD *)&v27[24] = 2080;
            *(void *)&v27[26] = "node-type-tracker.c";
            __int16 v28 = 1024;
            int v29 = 282;
            __int16 v21 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
            int v22 = v8;
            goto LABEL_62;
          }
        }
        else
        {
          uint64_t v23 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
          {
            int v24 = 136447490;
            __int16 v25 = "node_type_tracker_callback_cancel";
            __int16 v26 = 1024;
            *(_DWORD *)__int16 v27 = 0;
            *(_WORD *)&DNSServiceAttributeRef v27[4] = 2048;
            *(void *)&v27[6] = v2;
            *(_WORD *)&v27[14] = 2080;
            *(void *)&v27[16] = "tracker";
            *(_WORD *)&v27[24] = 2080;
            *(void *)&v27[26] = "node-type-tracker.c";
            __int16 v28 = 1024;
            int v29 = 282;
            __int16 v21 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
            int v22 = v23;
            goto LABEL_62;
          }
        }
LABEL_63:
        abort();
      }
    }
  }
LABEL_19:
  uint64_t v10 = *(void *)(a1 + 152);
  if (!v10) {
    goto LABEL_28;
  }
  cti_events_discontinue(v10);
  *(void *)(a1 + 152) = 0;
  int v11 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    __int16 v12 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_63;
    }
    int v24 = 136447490;
    __int16 v25 = "service_publisher_cancel";
    __int16 v26 = 1024;
    *(_DWORD *)__int16 v27 = 0;
    *(_WORD *)&DNSServiceAttributeRef v27[4] = 2048;
    *(void *)&v27[6] = a1;
    *(_WORD *)&v27[14] = 2080;
    *(void *)&v27[16] = "publisher";
    *(_WORD *)&v27[24] = 2080;
    *(void *)&v27[26] = "service-publisher.c";
    __int16 v28 = 1024;
    int v29 = 1490;
    __int16 v21 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_61:
    int v22 = v12;
LABEL_62:
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_FAULT, v21, (uint8_t *)&v24, 0x36u);
    goto LABEL_63;
  }
  __int16 v12 = global_os_log;
  if (v11 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_63;
    }
    int v24 = 136447490;
    __int16 v25 = "service_publisher_cancel";
    __int16 v26 = 1024;
    *(_DWORD *)__int16 v27 = v11;
    *(_WORD *)&DNSServiceAttributeRef v27[4] = 2048;
    *(void *)&v27[6] = a1;
    *(_WORD *)&v27[14] = 2080;
    *(void *)&v27[16] = "publisher";
    *(_WORD *)&v27[24] = 2080;
    *(void *)&v27[26] = "service-publisher.c";
    __int16 v28 = 1024;
    int v29 = 1490;
    __int16 v21 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_61;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v24 = 136447490;
    __int16 v25 = "service_publisher_cancel";
    __int16 v26 = 1024;
    *(_DWORD *)__int16 v27 = v11;
    *(_WORD *)&DNSServiceAttributeRef v27[4] = 2048;
    *(void *)&v27[6] = a1;
    *(_WORD *)&v27[14] = 2080;
    *(void *)&v27[16] = "publisher";
    *(_WORD *)&v27[24] = 2080;
    *(void *)&v27[26] = "service-publisher.c";
    __int16 v28 = 1024;
    int v29 = 1490;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v24, 0x36u);
    int v11 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v11 - 1;
  if (v11 == 1)
  {
    int v13 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v24 = 136447234;
      __int16 v25 = "service_publisher_cancel";
      __int16 v26 = 2048;
      *(void *)__int16 v27 = a1;
      *(_WORD *)&v27[8] = 2080;
      *(void *)&v27[10] = "publisher";
      *(_WORD *)&v27[18] = 2080;
      *(void *)&v27[20] = "service-publisher.c";
      *(_WORD *)&v27[28] = 1024;
      *(_DWORD *)&v27[30] = 1490;
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v24, 0x30u);
    }
    ++service_publisher_finalized;
    service_publisher_finalize(a1);
  }
LABEL_28:
  uint64_t v14 = *(void *)(a1 + 160);
  if (!v14) {
    goto LABEL_37;
  }
  cti_events_discontinue(v14);
  *(void *)(a1 + 160) = 0;
  int v15 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    __int16 v12 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_63;
    }
    int v24 = 136447490;
    __int16 v25 = "service_publisher_cancel";
    __int16 v26 = 1024;
    *(_DWORD *)__int16 v27 = 0;
    *(_WORD *)&DNSServiceAttributeRef v27[4] = 2048;
    *(void *)&v27[6] = a1;
    *(_WORD *)&v27[14] = 2080;
    *(void *)&v27[16] = "publisher";
    *(_WORD *)&v27[24] = 2080;
    *(void *)&v27[26] = "service-publisher.c";
    __int16 v28 = 1024;
    int v29 = 1495;
    __int16 v21 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_61;
  }
  __int16 v12 = global_os_log;
  if (v15 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_63;
    }
    int v24 = 136447490;
    __int16 v25 = "service_publisher_cancel";
    __int16 v26 = 1024;
    *(_DWORD *)__int16 v27 = v15;
    *(_WORD *)&DNSServiceAttributeRef v27[4] = 2048;
    *(void *)&v27[6] = a1;
    *(_WORD *)&v27[14] = 2080;
    *(void *)&v27[16] = "publisher";
    *(_WORD *)&v27[24] = 2080;
    *(void *)&v27[26] = "service-publisher.c";
    __int16 v28 = 1024;
    int v29 = 1495;
    __int16 v21 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_61;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v24 = 136447490;
    __int16 v25 = "service_publisher_cancel";
    __int16 v26 = 1024;
    *(_DWORD *)__int16 v27 = v15;
    *(_WORD *)&DNSServiceAttributeRef v27[4] = 2048;
    *(void *)&v27[6] = a1;
    *(_WORD *)&v27[14] = 2080;
    *(void *)&v27[16] = "publisher";
    *(_WORD *)&v27[24] = 2080;
    *(void *)&v27[26] = "service-publisher.c";
    __int16 v28 = 1024;
    int v29 = 1495;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v24, 0x36u);
    int v15 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v15 - 1;
  if (v15 == 1)
  {
    int v16 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v24 = 136447234;
      __int16 v25 = "service_publisher_cancel";
      __int16 v26 = 2048;
      *(void *)__int16 v27 = a1;
      *(_WORD *)&v27[8] = 2080;
      *(void *)&v27[10] = "publisher";
      *(_WORD *)&v27[18] = 2080;
      *(void *)&v27[20] = "service-publisher.c";
      *(_WORD *)&v27[28] = 1024;
      *(_DWORD *)&v27[30] = 1495;
      _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v24, 0x30u);
    }
    ++service_publisher_finalized;
    service_publisher_finalize(a1);
  }
LABEL_37:
  uint64_t v17 = *(void *)(a1 + 168);
  if (!v17) {
    goto LABEL_46;
  }
  cti_events_discontinue(v17);
  *(void *)(a1 + 168) = 0;
  int v18 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    __int16 v12 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_63;
    }
    int v24 = 136447490;
    __int16 v25 = "service_publisher_cancel";
    __int16 v26 = 1024;
    *(_DWORD *)__int16 v27 = 0;
    *(_WORD *)&DNSServiceAttributeRef v27[4] = 2048;
    *(void *)&v27[6] = a1;
    *(_WORD *)&v27[14] = 2080;
    *(void *)&v27[16] = "publisher";
    *(_WORD *)&v27[24] = 2080;
    *(void *)&v27[26] = "service-publisher.c";
    __int16 v28 = 1024;
    int v29 = 1500;
    __int16 v21 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    goto LABEL_61;
  }
  __int16 v12 = global_os_log;
  if (v18 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_63;
    }
    int v24 = 136447490;
    __int16 v25 = "service_publisher_cancel";
    __int16 v26 = 1024;
    *(_DWORD *)__int16 v27 = v18;
    *(_WORD *)&DNSServiceAttributeRef v27[4] = 2048;
    *(void *)&v27[6] = a1;
    *(_WORD *)&v27[14] = 2080;
    *(void *)&v27[16] = "publisher";
    *(_WORD *)&v27[24] = 2080;
    *(void *)&v27[26] = "service-publisher.c";
    __int16 v28 = 1024;
    int v29 = 1500;
    __int16 v21 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_61;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v24 = 136447490;
    __int16 v25 = "service_publisher_cancel";
    __int16 v26 = 1024;
    *(_DWORD *)__int16 v27 = v18;
    *(_WORD *)&DNSServiceAttributeRef v27[4] = 2048;
    *(void *)&v27[6] = a1;
    *(_WORD *)&v27[14] = 2080;
    *(void *)&v27[16] = "publisher";
    *(_WORD *)&v27[24] = 2080;
    *(void *)&v27[26] = "service-publisher.c";
    __int16 v28 = 1024;
    int v29 = 1500;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v24, 0x36u);
    int v18 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v18 - 1;
  if (v18 == 1)
  {
    __int16 v19 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v24 = 136447234;
      __int16 v25 = "service_publisher_cancel";
      __int16 v26 = 2048;
      *(void *)__int16 v27 = a1;
      *(_WORD *)&v27[8] = 2080;
      *(void *)&v27[10] = "publisher";
      *(_WORD *)&v27[18] = 2080;
      *(void *)&v27[20] = "service-publisher.c";
      *(_WORD *)&v27[28] = 1024;
      *(_DWORD *)&v27[30] = 1500;
      _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v24, 0x30u);
    }
    ++service_publisher_finalized;
    service_publisher_finalize(a1);
  }
LABEL_46:
  int v20 = *(char **)(a1 + 80);
  if (v20) {
    ifpermit_list_remove(*(void *)(*(void *)(a1 + 88) + 72), v20);
  }
  state_machine_cancel((uint64_t *)(a1 + 8));
}

void service_publisher_listener_cancel(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 112);
  if (v2)
  {
    if ((*(_WORD *)(v2 + 416) & 0x400) != 0)
    {
      uint64_t v10 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        uint64_t v11 = *(void *)(v2 + 192);
        *(_DWORD *)__int16 v12 = 136446723;
        *(void *)&void v12[4] = "ioloop_listener_cancel";
        *(_WORD *)&v12[12] = 2160;
        *(void *)&v12[14] = 1752392040;
        *(_WORD *)&v12[22] = 2081;
        *(void *)&v12[24] = v11;
        _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_FAULT, "%{public}s: cancel on canceled connection %{private, mask.hash}s", v12, 0x20u);
      }
    }
    else
    {
      __int16 v3 = *(_WORD *)(v2 + 416) | 0x400;
      *(_WORD *)(v2 + 416) = v3;
      int v4 = *(NSObject **)(v2 + 8);
      if (v4)
      {
        nw_listener_cancel(v4);
        __int16 v3 = *(_WORD *)(v2 + 416);
      }
      if ((v3 & 0x20) == 0 && !*(void *)v2 && *(_DWORD *)(v2 + 148) != -1)
      {
        ioloop_close(v2 + 56);
        if (*(void *)(v2 + 248))
        {
          int v5 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v6 = *(_DWORD *)(v2 + 32);
            *(_DWORD *)__int16 v12 = 136447490;
            *(void *)&void v12[4] = "ioloop_listener_cancel";
            *(_WORD *)&v12[12] = 1024;
            *(_DWORD *)&v12[14] = v6;
            *(_WORD *)&v12[18] = 2048;
            *(void *)&v12[20] = v2;
            *(_WORD *)&v12[28] = 2080;
            *(void *)&v12[30] = "connection";
            *(_WORD *)&v12[38] = 2080;
            int v13 = "macos-ioloop.c";
            __int16 v14 = 1024;
            int v15 = 1176;
            _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", v12, 0x36u);
          }
          int v7 = *(_DWORD *)(v2 + 32);
          if (v7)
          {
            int v8 = v7 + 1;
            *(_DWORD *)(v2 + 32) = v7 + 1;
            if (v7 + 1 >= 10001)
            {
              uint64_t v9 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
              {
                *(_DWORD *)__int16 v12 = 136447490;
                *(void *)&void v12[4] = "ioloop_listener_cancel";
                *(_WORD *)&v12[12] = 1024;
                *(_DWORD *)&v12[14] = v8;
                *(_WORD *)&v12[18] = 2048;
                *(void *)&v12[20] = v2;
                *(_WORD *)&v12[28] = 2080;
                *(void *)&v12[30] = "connection";
                *(_WORD *)&v12[38] = 2080;
                int v13 = "macos-ioloop.c";
                __int16 v14 = 1024;
                int v15 = 1176;
                _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", v12, 0x36u);
              }
              abort();
            }
          }
          else
          {
            ++listener_created;
            *(_DWORD *)(v2 + 32) = 1;
          }
          *(void *)__int16 v12 = _NSConcreteStackBlock;
          *(void *)&v12[8] = 0x40000000;
          *(void *)&v12[16] = __ioloop_listener_cancel_block_invoke;
          *(void *)&v12[24] = &__block_descriptor_tmp_8_1136;
          *(void *)&v12[32] = v2;
          dispatch_async((dispatch_queue_t)ioloop_main_queue, v12);
        }
      }
    }
    ioloop_comm_release_(*(void *)(a1 + 112), "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 1229);
    *(void *)(a1 + 112) = 0;
  }
  *(unsigned char *)(a1 + 262) = 0;

  service_publisher_unadvertise_all(a1);
}

void service_publisher_node_type_tracker_callback(uint64_t a1)
{
  uint64_t v2 = state_machine_event_create(10);
  if (v2)
  {
    __int16 v3 = v2;
    state_machine_event_deliver(a1 + 8, (uint64_t)v2);
    int v4 = *v3;
    if (*v3)
    {
      int v5 = global_os_log;
      if (v4 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v10 = 136447490;
          uint64_t v11 = "service_publisher_node_type_tracker_callback";
          __int16 v12 = 1024;
          *(_DWORD *)int v13 = v4;
          *(_WORD *)&v13[4] = 2048;
          *(void *)&v13[6] = v3;
          *(_WORD *)&v13[14] = 2080;
          *(void *)&v13[16] = "event";
          *(_WORD *)&v13[24] = 2080;
          *(void *)&v13[26] = "service-publisher.c";
          __int16 v14 = 1024;
          int v15 = 915;
          _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v10, 0x36u);
          int v4 = *v3;
        }
        *__int16 v3 = v4 - 1;
        if (v4 == 1)
        {
          int v6 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v10 = 136447234;
            uint64_t v11 = "service_publisher_node_type_tracker_callback";
            __int16 v12 = 2048;
            *(void *)int v13 = v3;
            *(_WORD *)&v13[8] = 2080;
            *(void *)&v13[10] = "event";
            *(_WORD *)&v13[18] = 2080;
            *(void *)&v13[20] = "service-publisher.c";
            *(_WORD *)&v13[28] = 1024;
            *(_DWORD *)&v13[30] = 915;
            _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v10, 0x30u);
          }
          ++state_machine_event_finalized;
          int v7 = (void (*)(int *))*((void *)v3 + 4);
          if (v7) {
            v7(v3);
          }
          free(v3);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_20:
      }
        abort();
      int v10 = 136447490;
      uint64_t v11 = "service_publisher_node_type_tracker_callback";
      __int16 v12 = 1024;
      *(_DWORD *)int v13 = v4;
      *(_WORD *)&v13[4] = 2048;
      *(void *)&v13[6] = v3;
      *(_WORD *)&v13[14] = 2080;
      *(void *)&v13[16] = "event";
      *(_WORD *)&v13[24] = 2080;
      *(void *)&v13[26] = "service-publisher.c";
      __int16 v14 = 1024;
      int v15 = 915;
      uint64_t v9 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      int v5 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_20;
      }
      int v10 = 136447490;
      uint64_t v11 = "service_publisher_node_type_tracker_callback";
      __int16 v12 = 1024;
      *(_DWORD *)int v13 = 0;
      *(_WORD *)&v13[4] = 2048;
      *(void *)&v13[6] = v3;
      *(_WORD *)&v13[14] = 2080;
      *(void *)&v13[16] = "event";
      *(_WORD *)&v13[24] = 2080;
      *(void *)&v13[26] = "service-publisher.c";
      __int16 v14 = 1024;
      int v15 = 915;
      uint64_t v9 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_FAULT, v9, (uint8_t *)&v10, 0x36u);
    goto LABEL_20;
  }
  int v8 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    int v10 = 136446210;
    uint64_t v11 = "service_publisher_node_type_tracker_callback";
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v10, 0xCu);
  }
}

void service_publisher_thread_tracker_callback(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 88);
  uint64_t v3 = *(void *)(v2 + 56);
  if (v3)
  {
    int v4 = *(void **)(v2 + 40);
    if (*(unsigned char *)(v3 + 72))
    {
      service_tracker_start(v4);
      goto LABEL_6;
    }
  }
  else
  {
    int v4 = *(void **)(v2 + 40);
  }
  service_tracker_stop(v4);
LABEL_6:
  int v5 = state_machine_event_create(9);
  if (v5)
  {
    int v6 = v5;
    state_machine_event_deliver(a1 + 8, (uint64_t)v5);
    int v7 = *v6;
    if (*v6)
    {
      int v8 = global_os_log;
      if (v7 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v13 = 136447490;
          __int16 v14 = "service_publisher_thread_tracker_callback";
          __int16 v15 = 1024;
          *(_DWORD *)int v16 = v7;
          *(_WORD *)&v16[4] = 2048;
          *(void *)&v16[6] = v6;
          *(_WORD *)&unsigned char v16[14] = 2080;
          *(void *)&v16[16] = "event";
          *(_WORD *)&v16[24] = 2080;
          *(void *)&v16[26] = "service-publisher.c";
          __int16 v17 = 1024;
          int v18 = 902;
          _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v13, 0x36u);
          int v7 = *v6;
        }
        *int v6 = v7 - 1;
        if (v7 == 1)
        {
          uint64_t v9 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v13 = 136447234;
            __int16 v14 = "service_publisher_thread_tracker_callback";
            __int16 v15 = 2048;
            *(void *)int v16 = v6;
            *(_WORD *)&v16[8] = 2080;
            *(void *)&v16[10] = "event";
            *(_WORD *)&v16[18] = 2080;
            *(void *)&v16[20] = "service-publisher.c";
            *(_WORD *)&v16[28] = 1024;
            *(_DWORD *)&v16[30] = 902;
            _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v13, 0x30u);
          }
          ++state_machine_event_finalized;
          int v10 = (void (*)(int *))*((void *)v6 + 4);
          if (v10) {
            v10(v6);
          }
          free(v6);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_25:
      }
        abort();
      int v13 = 136447490;
      __int16 v14 = "service_publisher_thread_tracker_callback";
      __int16 v15 = 1024;
      *(_DWORD *)int v16 = v7;
      *(_WORD *)&v16[4] = 2048;
      *(void *)&v16[6] = v6;
      *(_WORD *)&unsigned char v16[14] = 2080;
      *(void *)&v16[16] = "event";
      *(_WORD *)&v16[24] = 2080;
      *(void *)&v16[26] = "service-publisher.c";
      __int16 v17 = 1024;
      int v18 = 902;
      __int16 v12 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      int v8 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_25;
      }
      int v13 = 136447490;
      __int16 v14 = "service_publisher_thread_tracker_callback";
      __int16 v15 = 1024;
      *(_DWORD *)int v16 = 0;
      *(_WORD *)&v16[4] = 2048;
      *(void *)&v16[6] = v6;
      *(_WORD *)&unsigned char v16[14] = 2080;
      *(void *)&v16[16] = "event";
      *(_WORD *)&v16[24] = 2080;
      *(void *)&v16[26] = "service-publisher.c";
      __int16 v17 = 1024;
      int v18 = 902;
      __int16 v12 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_FAULT, v12, (uint8_t *)&v13, 0x36u);
    goto LABEL_25;
  }
  uint64_t v11 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    int v13 = 136446210;
    __int16 v14 = "service_publisher_thread_tracker_callback";
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v13, 0xCu);
  }
}

void service_publisher_service_tracker_callback(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 88) + 56);
  if (v2 && *(unsigned char *)(v2 + 72))
  {
    uint64_t v3 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v12 = 136446210;
      int v13 = "service_publisher_service_tracker_callback";
      _os_log_impl((void *)&_mh_execute_header, v3, OS_LOG_TYPE_DEFAULT, "%{public}s: setting seen_service_list to true", (uint8_t *)&v12, 0xCu);
    }
    *(unsigned char *)(a1 + 263) = 1;
  }
  int v4 = state_machine_event_create(4);
  if (v4)
  {
    int v5 = v4;
    state_machine_event_deliver(a1 + 8, (uint64_t)v4);
    int v6 = *v5;
    if (*v5)
    {
      int v7 = global_os_log;
      if (v6 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v12 = 136447490;
          int v13 = "service_publisher_service_tracker_callback";
          __int16 v14 = 1024;
          *(_DWORD *)__int16 v15 = v6;
          *(_WORD *)&_OWORD v15[4] = 2048;
          *(void *)&v15[6] = v5;
          *(_WORD *)&v15[14] = 2080;
          *(void *)&v15[16] = "event";
          *(_WORD *)&v15[24] = 2080;
          *(void *)&v15[26] = "service-publisher.c";
          __int16 v16 = 1024;
          int v17 = 876;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v12, 0x36u);
          int v6 = *v5;
        }
        int *v5 = v6 - 1;
        if (v6 == 1)
        {
          int v8 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v12 = 136447234;
            int v13 = "service_publisher_service_tracker_callback";
            __int16 v14 = 2048;
            *(void *)__int16 v15 = v5;
            *(_WORD *)&v15[8] = 2080;
            *(void *)&v15[10] = "event";
            *(_WORD *)&v15[18] = 2080;
            *(void *)&v15[20] = "service-publisher.c";
            *(_WORD *)&v15[28] = 1024;
            *(_DWORD *)&v15[30] = 876;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v12, 0x30u);
          }
          ++state_machine_event_finalized;
          uint64_t v9 = (void (*)(int *))*((void *)v5 + 4);
          if (v9) {
            v9(v5);
          }
          free(v5);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_25:
      }
        abort();
      int v12 = 136447490;
      int v13 = "service_publisher_service_tracker_callback";
      __int16 v14 = 1024;
      *(_DWORD *)__int16 v15 = v6;
      *(_WORD *)&_OWORD v15[4] = 2048;
      *(void *)&v15[6] = v5;
      *(_WORD *)&v15[14] = 2080;
      *(void *)&v15[16] = "event";
      *(_WORD *)&v15[24] = 2080;
      *(void *)&v15[26] = "service-publisher.c";
      __int16 v16 = 1024;
      int v17 = 876;
      uint64_t v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      int v7 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_25;
      }
      int v12 = 136447490;
      int v13 = "service_publisher_service_tracker_callback";
      __int16 v14 = 1024;
      *(_DWORD *)__int16 v15 = 0;
      *(_WORD *)&_OWORD v15[4] = 2048;
      *(void *)&v15[6] = v5;
      *(_WORD *)&v15[14] = 2080;
      *(void *)&v15[16] = "event";
      *(_WORD *)&v15[24] = 2080;
      *(void *)&v15[26] = "service-publisher.c";
      __int16 v16 = 1024;
      int v17 = 876;
      uint64_t v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, v11, (uint8_t *)&v12, 0x36u);
    goto LABEL_25;
  }
  int v10 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    int v12 = 136446210;
    int v13 = "service_publisher_service_tracker_callback";
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v12, 0xCu);
  }
}

uint64_t service_publisher_action_publishing(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 52);
  if (v2 == 2)
  {
    uint64_t v4 = *(void *)(a1 + 8);
    int v5 = global_os_log;
    BOOL v6 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
    if (a2)
    {
      if (v6)
      {
        uint64_t v7 = *(void *)(v4 + 40);
        uint64_t v8 = *(void *)(v4 + 8);
        uint64_t v9 = *(uint64_t **)(a2 + 8);
        uint64_t v10 = *(void *)(v4 + 24);
        *(_DWORD *)int buf = 136447491;
        uint64_t v72 = "service_publisher_action_publishing";
        __int16 v73 = 2082;
        uint64_t v74 = v7;
        __int16 v75 = 2160;
        uint64_t v76 = 1752392040;
        __int16 v77 = 2081;
        uint64_t v78 = v8;
        __int16 v79 = 2082;
        int v80 = v9;
        __int16 v81 = 2082;
        uint64_t v82 = v10;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s/%{private, mask.hash}s: event %{public}s received in state %{public}s", buf, 0x3Eu);
      }
      int v11 = *(_DWORD *)(a2 + 16);
      if (v11 > 6)
      {
        if (v11 == 7)
        {
          service_publisher_listener_cancel(v4);
          uint64_t v12 = 1;
          service_publisher_service_unpublish(v4, 1);
          return v12;
        }
        if (v11 != 19) {
          goto LABEL_67;
        }
      }
      else if (v11 != 1)
      {
        if (v11 == 6)
        {
          uint64_t v12 = 1;
          service_publisher_service_unpublish(v4, 1);
          *(_DWORD *)(v4 + 248) = 1;
          return v12;
        }
LABEL_67:
        if ((service_publisher_can_publish(v4) & 1) == 0)
        {
          service_publisher_listener_cancel(v4);
          service_publisher_service_unpublish(v4, 1);
          return 3;
        }
        if (*(_DWORD *)(a2 + 16) != 4) {
          return 0;
        }
        uint64_t v52 = *(void *)(v4 + 128);
        if ((!v52 || *(unsigned char *)(v4 + 266)) && (!*(void *)(v4 + 136) || *(unsigned char *)(v4 + 267))) {
          return 0;
        }
        *(_WORD *)(v4 + 266) = 0;
        uint64_t v53 = *(void *)(v4 + 88);
        uint64_t v54 = *(void *)(v53 + 40);
        if (v54)
        {
          uint64_t v55 = *(void *)(v54 + 48);
          if (v55)
          {
            LODWORD(v54) = 0;
            int v56 = 0;
            do
            {
              int v57 = *(_DWORD *)(v55 + 20);
              if (v57 == 3)
              {
                if (*(unsigned char *)(v55 + 25))
                {
                  if (*(unsigned char *)(v53 + 278))
                  {
                    if (*(unsigned __int16 *)(v55 + 16) == *(unsigned __int16 *)(v53 + 276))
                    {
                      uint64_t v60 = *(void *)(v4 + 136);
                      if (v60)
                      {
                        if (*(unsigned __int8 *)(v55 + 80) == *(unsigned __int8 *)(v60 + 80))
                        {
                          LODWORD(v54) = 1;
                          *(unsigned char *)(v4 + 267) = 1;
                        }
                      }
                    }
                  }
                }
              }
              else if (v57 == 2 && *(unsigned char *)(v55 + 25) && v52 != 0)
              {
                BOOL v59 = *(void *)(v55 + 64) == *(void *)(v52 + 64) && *(void *)(v55 + 72) == *(void *)(v52 + 72);
                if (v59 && *(unsigned __int16 *)(v55 + 80) == *(unsigned __int16 *)(v52 + 80))
                {
                  int v56 = 1;
                  *(unsigned char *)(v4 + 266) = 1;
                }
              }
              uint64_t v55 = *(void *)(v55 + 8);
            }
            while (v55);
            goto LABEL_106;
          }
          LODWORD(v54) = 0;
        }
        int v56 = 0;
LABEL_106:
        if ((!v52 || v56) && (!*(void *)(v4 + 136) || v54)) {
          ioloop_cancel_wake_event(*(void *)(v4 + 96));
        }
        return 0;
      }
      if (!*(void *)(v4 + 128))
      {
LABEL_21:
        uint64_t v22 = *(void *)(v4 + 88);
        if (!*(unsigned char *)(v22 + 287)) {
          goto LABEL_26;
        }
        if (*(unsigned char *)(v22 + 288))
        {
          uint64_t v23 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136446210;
            uint64_t v72 = "service_publisher_wanted_service_missing";
            int v24 = "%{public}s: srp_service_needed == true -> true";
            __int16 v25 = v23;
            uint32_t v26 = 12;
            goto LABEL_25;
          }
          goto LABEL_26;
        }
        uint64_t v31 = *(uint64_t ***)(v22 + 80);
        if (!v31) {
          goto LABEL_65;
        }
        uint64_t v70 = *(void *)(v4 + 88);
LABEL_36:
        __int16 v32 = *(void **)(v22 + 8);
        if (v32)
        {
          while (1)
          {
            uint64_t v33 = v32[14];
            if (v33)
            {
              if (*(int *)(v33 + 4) >= 1) {
                break;
              }
            }
LABEL_52:
            __int16 v32 = (void *)v32[5];
            if (!v32) {
              goto LABEL_101;
            }
          }
          uint64_t v34 = 0;
          while (1)
          {
            uint64_t v35 = *(void *)(*(void *)(v33 + 8) + 8 * v34);
            if (v35 && !strcasecmp(*(const char **)(v35 + 48), (const char *)v31[1]))
            {
              __int16 v36 = (const char *)v31[2];
              int v37 = *(char **)(v35 + 56);
              unsigned int v38 = strchr(v37, 44);
              if (v38)
              {
                size_t v39 = v38 - v37;
                uint64_t v40 = (char *)malloc_type_malloc(v38 - v37 + 1, 0xC28C7701uLL);
                if (v40)
                {
                  __int16 v41 = v40;
                  memcpy(v40, v37, v39);
                  v41[v39] = 0;
                  int v42 = strcasecmp(v36, v41);
                  free(v41);
                  if (!v42) {
                    goto LABEL_54;
                  }
                }
                else
                {
                  __int16 v43 = global_os_log;
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)int buf = 136446210;
                    uint64_t v72 = "adv_ctl_service_types_compare";
                    _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, "%{public}s: no memory for base_type, comparison can't be done.", buf, 0xCu);
                  }
                }
              }
              else if (!strcasecmp(v36, v37))
              {
LABEL_54:
                uint64_t v44 = v32[12];
                if (v44)
                {
                  uint64_t v45 = *(unsigned int *)(v44 + 4);
                  if ((int)v45 >= 1)
                  {
                    __int16 v46 = *(uint64_t **)(v44 + 8);
                    while (1)
                    {
                      uint64_t v47 = *v46;
                      if (*v46)
                      {
                        if (*(_WORD *)(v47 + 50) == 16 && **(void **)(v47 + 40) == *(void *)(v4 + 176)) {
                          break;
                        }
                      }
                      ++v46;
                      if (!--v45) {
                        goto LABEL_99;
                      }
                    }
                    __int16 v48 = global_os_log;
                    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                    {
                      uint64_t v49 = (uint64_t)v31[1];
                      __int16 v50 = v31[2];
                      *(_DWORD *)int buf = 136447235;
                      uint64_t v72 = "service_publisher_wanted_service_missing";
                      __int16 v73 = 2160;
                      uint64_t v74 = 1752392040;
                      __int16 v75 = 2081;
                      uint64_t v76 = v49;
                      __int16 v77 = 2160;
                      uint64_t v78 = 1752392040;
                      __int16 v79 = 2081;
                      int v80 = v50;
                      _os_log_impl((void *)&_mh_execute_header, v48, OS_LOG_TYPE_DEFAULT, "%{public}s: service %{private, mask.hash}s.%{private, mask.hash}s is present", buf, 0x34u);
                    }
                    uint64_t v31 = (uint64_t **)*v31;
                    uint64_t v22 = v70;
                    if (!v31)
                    {
LABEL_65:
                      uint64_t v51 = global_os_log;
                      uint64_t v12 = 0;
                      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)int buf = 136446210;
                        uint64_t v72 = "service_publisher_wanted_service_missing";
                        __int16 v14 = "%{public}s: all needed services present -> false";
                        __int16 v15 = v51;
                        os_log_type_t v16 = OS_LOG_TYPE_DEFAULT;
                        uint32_t v17 = 12;
LABEL_11:
                        _os_log_impl((void *)&_mh_execute_header, v15, v16, v14, buf, v17);
                        return 0;
                      }
                      return v12;
                    }
                    goto LABEL_36;
                  }
LABEL_99:
                  uint64_t v61 = global_os_log;
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                  {
                    uint64_t v62 = (uint64_t)v31[1];
                    uint64_t v63 = v31[2];
                    uint64_t v64 = *(void *)(v35 + 48);
                    *(_DWORD *)int buf = 136447747;
                    uint64_t v72 = "service_publisher_wanted_service_missing";
                    __int16 v73 = 2160;
                    uint64_t v74 = 1752392040;
                    __int16 v75 = 2081;
                    uint64_t v76 = v62;
                    __int16 v77 = 2160;
                    uint64_t v78 = 1752392040;
                    __int16 v79 = 2081;
                    int v80 = v63;
                    __int16 v81 = 2160;
                    uint64_t v82 = 1752392040;
                    __int16 v83 = 2081;
                    uint64_t v84 = v64;
                    int v24 = "%{public}s: srp service %{private, mask.hash}s.%{private, mask.hash}s present as %{private, ma"
                          "sk.hash}s but has no address on local mesh -> true";
                    __int16 v25 = v61;
                    uint32_t v26 = 72;
                    goto LABEL_25;
                  }
LABEL_26:
                  *(_WORD *)int buf = bswap32(*(unsigned __int16 *)(v4 + 256)) >> 16;
                  __int16 v27 = thread_service_unicast_create_(*(_WORD *)(*(void *)(v4 + 88) + 276), (_OWORD *)(v4 + 176), buf, 0, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 1402);
                  service_publisher_queue_update(v4, (uint64_t)v27, 6);
                  thread_service_release_(v27, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 1404);
                  if (a2)
                  {
                    service_tracker_start(*(void **)(*(void *)(v4 + 88) + 40));
                    int v28 = *(_DWORD *)(v4 + 252);
                    if (v28 <= 3599)
                    {
                      v28 *= 2;
                      goto LABEL_30;
                    }
                  }
                  else
                  {
                    int v28 = 5;
LABEL_30:
                    *(_DWORD *)(v4 + 252) = v28;
                  }
                  uint32_t v29 = arc4random();
                  service_publisher_start_wait(v4, ((v29 % (unint64_t)(1000 * *(int *)(v4 + 252))) >> 1) + 1000 * v28);
                  return 0;
                }
                uint64_t v65 = global_os_log;
                if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
                  goto LABEL_26;
                }
                uint64_t v68 = (uint64_t)v31[1];
                uint64_t v69 = v31[2];
                *(_DWORD *)int buf = 136447235;
                uint64_t v72 = "service_publisher_wanted_service_missing";
                __int16 v73 = 2160;
                uint64_t v74 = 1752392040;
                __int16 v75 = 2081;
                uint64_t v76 = v68;
                __int16 v77 = 2160;
                uint64_t v78 = 1752392040;
                __int16 v79 = 2081;
                int v80 = v69;
                int v24 = "%{public}s: srp service %{private, mask.hash}s.%{private, mask.hash}s present but no addresses -> true";
LABEL_103:
                __int16 v25 = v65;
                uint32_t v26 = 52;
LABEL_25:
                _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, v24, buf, v26);
                goto LABEL_26;
              }
              uint64_t v33 = v32[14];
            }
            if (++v34 >= *(int *)(v33 + 4)) {
              goto LABEL_52;
            }
          }
        }
LABEL_101:
        uint64_t v65 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
          goto LABEL_26;
        }
        uint64_t v66 = (uint64_t)v31[1];
        int v67 = v31[2];
        *(_DWORD *)int buf = 136447235;
        uint64_t v72 = "service_publisher_wanted_service_missing";
        __int16 v73 = 2160;
        uint64_t v74 = 1752392040;
        __int16 v75 = 2081;
        uint64_t v76 = v66;
        __int16 v77 = 2160;
        uint64_t v78 = 1752392040;
        __int16 v79 = 2081;
        int v80 = v67;
        int v24 = "%{public}s: service %{private, mask.hash}s.%{private, mask.hash}s host not present -> true";
        goto LABEL_103;
      }
    }
    else
    {
      if (v6)
      {
        uint64_t v18 = *(void *)(v4 + 40);
        uint64_t v19 = *(void *)(v4 + 8);
        int v20 = *(uint64_t **)(v4 + 24);
        *(_DWORD *)int buf = 136447235;
        uint64_t v72 = "service_publisher_action_publishing";
        __int16 v73 = 2082;
        uint64_t v74 = v18;
        __int16 v75 = 2160;
        uint64_t v76 = 1752392040;
        __int16 v77 = 2081;
        uint64_t v78 = v19;
        __int16 v79 = 2082;
        int v80 = v20;
        _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s/%{private, mask.hash}s: entering state %{public}s", buf, 0x34u);
      }
      if (!*(void *)(v4 + 128)) {
        goto LABEL_21;
      }
      __int16 v21 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v72 = "service_publisher_action_publishing";
        _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%{public}s: unicast service still published!", buf, 0xCu);
      }
    }
    service_publisher_service_unpublish(v4, a2 == 0);
    goto LABEL_21;
  }
  uint64_t v13 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)int buf = 136446466;
    uint64_t v72 = "service_publisher_action_publishing";
    __int16 v73 = 1024;
    LODWORD(v74) = v2;
    __int16 v14 = "%{public}s: state header type isn't service_publisher: %d";
    __int16 v15 = v13;
    os_log_type_t v16 = OS_LOG_TYPE_ERROR;
    uint32_t v17 = 18;
    goto LABEL_11;
  }
  return 0;
}

void service_publisher_service_unpublish(uint64_t a1, int a2)
{
  int v2 = *(int **)(a1 + 128);
  *(void *)(a1 + 128) = 0;
  if (v2)
  {
    if (a2)
    {
      service_for_queue = service_publisher_create_service_for_queue((uint64_t)v2);
      service_publisher_queue_update(a1, (uint64_t)service_for_queue, 7);
      thread_service_release_(service_for_queue, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 673);
      thread_service_release_(v2, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 674);
    }
  }
  else
  {
    int v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      int v6 = 136446210;
      uint64_t v7 = "service_publisher_service_unpublish";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_ERROR, "%{public}s: request to unpublished service that's not present", (uint8_t *)&v6, 0xCu);
    }
  }
}

uint64_t service_publisher_can_publish(uint64_t a1)
{
  int have_competing_unicast_service = service_publisher_have_competing_unicast_service(a1, 0);
  int have_anycast_service = service_publisher_have_anycast_service(a1);
  int v4 = have_anycast_service;
  uint64_t v5 = *(void *)(a1 + 88);
  uint64_t v6 = *(void *)(v5 + 56);
  if (v6 && *(unsigned char *)(v6 + 72))
  {
    unsigned int v7 = (have_anycast_service | have_competing_unicast_service) ^ 1;
    uint64_t v8 = "";
  }
  else
  {
    uint64_t v9 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136446210;
      uint64_t v53 = "service_publisher_can_publish";
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: setting seen_service_list to false", buf, 0xCu);
    }
    unsigned int v7 = 0;
    *(unsigned char *)(a1 + 263) = 0;
    uint64_t v8 = " / not associated ";
  }
  uint64_t v10 = *(void *)(v5 + 64);
  if (v10)
  {
    int v11 = 0;
    int v12 = 0;
    int v13 = 0;
    int v14 = 1;
    __int16 v15 = "";
    switch(*(_DWORD *)(v10 + 64))
    {
      case 0:
        goto LABEL_10;
      case 1:
      case 7:
        break;
      case 2:
        int v14 = 0;
        int v11 = 0;
        int v12 = 0;
        int v13 = 1;
        break;
      case 3:
      case 4:
        int v14 = 0;
        int v11 = 0;
        int v13 = 0;
        int v12 = 1;
        break;
      case 8:
        int v14 = 0;
        int v12 = 0;
        int v13 = 0;
        int v11 = 1;
        break;
      default:
        int v14 = 0;
        int v11 = 0;
        int v12 = 0;
        int v13 = 0;
        __int16 v15 = "";
        break;
    }
  }
  else
  {
LABEL_10:
    int v14 = 0;
    unsigned int v7 = 0;
    int v11 = 0;
    int v12 = 0;
    int v13 = 0;
    __int16 v15 = " / no node type";
  }
  int v16 = *(unsigned __int8 *)(a1 + 258);
  if (*(unsigned char *)(a1 + 263)) {
    BOOL v17 = *(unsigned char *)(a1 + 264) == 0;
  }
  else {
    BOOL v17 = 0;
  }
  if (!v17 || v16 == 0 || *(unsigned char *)(a1 + 265) == 0) {
    unsigned int v7 = 0;
  }
  if (*(void *)(a1 + 232)) {
    uint64_t v20 = v7;
  }
  else {
    uint64_t v20 = v7 & ~v11;
  }
  if (*(void *)(a1 + 232)) {
    __int16 v21 = "";
  }
  else {
    __int16 v21 = " / no wed ";
  }
  uint64_t v51 = v8;
  int v50 = v11;
  uint64_t v49 = v15;
  int v47 = *(unsigned __int8 *)(a1 + 265);
  int v48 = v14;
  __int16 v46 = v21;
  if (*(void *)(a1 + 240))
  {
    int v22 = v12;
    int v23 = v13;
    int v24 = "";
    goto LABEL_36;
  }
  if ((v14 | v12 | v13) == 1)
  {
    if (*(void *)(a1 + 104)
      || (uint64_t v40 = ioloop_wakeup_create_("/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 1092), (*(void *)(a1 + 104) = v40) == 0))
    {
      int v22 = v12;
    }
    else
    {
      ioloop_add_wake_event((uint64_t)v40, a1, (uint64_t)service_publisher_sed_timeout_expired, (uint64_t)service_publisher_context_release, 0x1F4u);
      __int16 v41 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        int v42 = *(_DWORD *)a1;
        *(_DWORD *)int buf = 136447490;
        uint64_t v53 = "service_publisher_can_publish";
        __int16 v54 = 1024;
        *(_DWORD *)uint64_t v55 = v42;
        *(_WORD *)&v55[4] = 2048;
        *(void *)&v55[6] = a1;
        *(_WORD *)&v55[14] = 2080;
        *(void *)&v55[16] = "publisher";
        *(_WORD *)&v55[24] = 2080;
        *(void *)&v55[26] = "service-publisher.c";
        *(_WORD *)&v55[34] = 1024;
        *(_DWORD *)&v55[36] = 1096;
        _os_log_impl((void *)&_mh_execute_header, v41, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
      }
      int v22 = v12;
      int v43 = *(_DWORD *)a1;
      if (!*(_DWORD *)a1)
      {
        int v23 = v13;
        uint64_t v20 = 0;
        ++service_publisher_created;
        *(_DWORD *)a1 = 1;
        goto LABEL_35;
      }
      int v44 = v43 + 1;
      *(_DWORD *)a1 = v43 + 1;
      if (v43 + 1 >= 10001)
      {
        uint64_t v45 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
        {
          *(_DWORD *)int buf = 136447490;
          uint64_t v53 = "service_publisher_can_publish";
          __int16 v54 = 1024;
          *(_DWORD *)uint64_t v55 = v44;
          *(_WORD *)&v55[4] = 2048;
          *(void *)&v55[6] = a1;
          *(_WORD *)&v55[14] = 2080;
          *(void *)&v55[16] = "publisher";
          *(_WORD *)&v55[24] = 2080;
          *(void *)&v55[26] = "service-publisher.c";
          *(_WORD *)&v55[34] = 1024;
          *(_DWORD *)&v55[36] = 1096;
          _os_log_impl((void *)&_mh_execute_header, v45, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
        }
        abort();
      }
    }
    int v23 = v13;
    uint64_t v20 = 0;
  }
  else
  {
    int v22 = v12;
    int v23 = v13;
  }
LABEL_35:
  int v24 = " / no neighbor ";
LABEL_36:
  __int16 v25 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    uint32_t v26 = "can't publish";
    int v27 = *(unsigned __int8 *)(a1 + 263);
    int v28 = *(unsigned __int8 *)(a1 + 264);
    uint64_t v53 = "service_publisher_can_publish";
    *(_DWORD *)int buf = 136450050;
    if (v20) {
      uint32_t v26 = "can publish";
    }
    *(void *)uint64_t v55 = v26;
    uint32_t v29 = " / no service list";
    __int16 v54 = 2082;
    if (v27) {
      uint32_t v29 = "";
    }
    *(_WORD *)&v55[8] = 2082;
    *(void *)&v55[10] = v29;
    if (have_competing_unicast_service) {
      __int16 v30 = " / competing present";
    }
    else {
      __int16 v30 = "";
    }
    *(_WORD *)&v55[18] = 2082;
    *(void *)&v55[20] = v30;
    if (v4) {
      uint64_t v31 = " / anycast present";
    }
    else {
      uint64_t v31 = "";
    }
    *(_WORD *)&v55[28] = 2082;
    *(void *)&v55[30] = v31;
    if (v48) {
      __int16 v32 = " / router ";
    }
    else {
      __int16 v32 = "";
    }
    *(_WORD *)&v55[38] = 2082;
    uint64_t v33 = " / sleepy router";
    int v56 = v51;
    if (!v50) {
      uint64_t v33 = "";
    }
    __int16 v57 = 2082;
    int v58 = v32;
    if (v22) {
      uint64_t v34 = " / sleepy end device";
    }
    else {
      uint64_t v34 = "";
    }
    __int16 v59 = 2082;
    uint64_t v60 = v33;
    if (v23) {
      uint64_t v35 = " / end device";
    }
    else {
      uint64_t v35 = "";
    }
    __int16 v61 = 2082;
    uint64_t v62 = v34;
    if (v16) {
      __int16 v36 = "";
    }
    else {
      __int16 v36 = " / no ml-eid ";
    }
    __int16 v63 = 2082;
    uint64_t v64 = v35;
    if (v47) {
      int v37 = "";
    }
    else {
      int v37 = " / no interface ";
    }
    __int16 v65 = 2082;
    uint64_t v66 = v49;
    if (v28) {
      unsigned int v38 = " / stopped";
    }
    else {
      unsigned int v38 = "";
    }
    __int16 v67 = 2082;
    uint64_t v68 = v36;
    __int16 v69 = 2082;
    uint64_t v70 = v46;
    __int16 v71 = 2082;
    uint64_t v72 = v24;
    __int16 v73 = 2082;
    uint64_t v74 = v37;
    __int16 v75 = 2082;
    uint64_t v76 = v38;
    _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s%{public}s%{public}s%{public}s%{public}s%{public}s%{public}s%{public}s%{public}s%{public}s%{public}s%{public}s%{public}s%{public}s%{public}s", buf, 0xA2u);
  }
  return v20;
}

void service_publisher_sed_timeout_expired(void *a1)
{
  int v2 = (void *)a1[13];
  if (v2)
  {
    ioloop_wakeup_release_(v2, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 842);
    a1[13] = 0;
  }
  if (!a1[30])
  {
    a1[30] = strdup("none");
    a1[26] = 0;
    a1[27] = 0;
  }
  uint64_t v3 = state_machine_event_create(18);
  if (v3)
  {
    int v4 = v3;
    state_machine_event_deliver((uint64_t)(a1 + 1), (uint64_t)v3);
    int v5 = *v4;
    if (*v4)
    {
      uint64_t v6 = global_os_log;
      if (v5 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v11 = 136447490;
          int v12 = "service_publisher_sed_timeout_expired";
          __int16 v13 = 1024;
          *(_DWORD *)int v14 = v5;
          *(_WORD *)&v14[4] = 2048;
          *(void *)&v14[6] = v4;
          *(_WORD *)&v14[14] = 2080;
          *(void *)&v14[16] = "event";
          *(_WORD *)&v14[24] = 2080;
          *(void *)&v14[26] = "service-publisher.c";
          __int16 v15 = 1024;
          int v16 = 854;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v11, 0x36u);
          int v5 = *v4;
        }
        int *v4 = v5 - 1;
        if (v5 == 1)
        {
          unsigned int v7 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v11 = 136447234;
            int v12 = "service_publisher_sed_timeout_expired";
            __int16 v13 = 2048;
            *(void *)int v14 = v4;
            *(_WORD *)&v14[8] = 2080;
            *(void *)&v14[10] = "event";
            *(_WORD *)&v14[18] = 2080;
            *(void *)&v14[20] = "service-publisher.c";
            *(_WORD *)&v14[28] = 1024;
            *(_DWORD *)&v14[30] = 854;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v11, 0x30u);
          }
          ++state_machine_event_finalized;
          uint64_t v8 = (void (*)(int *))*((void *)v4 + 4);
          if (v8) {
            v8(v4);
          }
          free(v4);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_24:
      }
        abort();
      int v11 = 136447490;
      int v12 = "service_publisher_sed_timeout_expired";
      __int16 v13 = 1024;
      *(_DWORD *)int v14 = v5;
      *(_WORD *)&v14[4] = 2048;
      *(void *)&v14[6] = v4;
      *(_WORD *)&v14[14] = 2080;
      *(void *)&v14[16] = "event";
      *(_WORD *)&v14[24] = 2080;
      *(void *)&v14[26] = "service-publisher.c";
      __int16 v15 = 1024;
      int v16 = 854;
      uint64_t v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      uint64_t v6 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_24;
      }
      int v11 = 136447490;
      int v12 = "service_publisher_sed_timeout_expired";
      __int16 v13 = 1024;
      *(_DWORD *)int v14 = 0;
      *(_WORD *)&v14[4] = 2048;
      *(void *)&v14[6] = v4;
      *(_WORD *)&v14[14] = 2080;
      *(void *)&v14[16] = "event";
      *(_WORD *)&v14[24] = 2080;
      *(void *)&v14[26] = "service-publisher.c";
      __int16 v15 = 1024;
      int v16 = 854;
      uint64_t v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v11, 0x36u);
    goto LABEL_24;
  }
  uint64_t v9 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    int v11 = 136446210;
    int v12 = "service_publisher_sed_timeout_expired";
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v11, 0xCu);
  }
}

uint64_t service_publisher_action_start_listeners(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 52);
  if (v2 != 2)
  {
    uint64_t v12 = global_os_log;
    uint64_t result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)int buf = 136446466;
    uint32_t v26 = "service_publisher_action_start_listeners";
    __int16 v27 = 1024;
    LODWORD(v28) = v2;
    __int16 v13 = "%{public}s: state header type isn't service_publisher: %d";
    int v14 = v12;
    uint32_t v15 = 18;
    goto LABEL_11;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  int v5 = global_os_log;
  BOOL v6 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (!a2)
  {
    if (v6)
    {
      uint64_t v16 = *(void *)(v4 + 40);
      uint64_t v17 = *(void *)(v4 + 8);
      uint64_t v18 = *(void *)(v4 + 24);
      *(_DWORD *)int buf = 136447235;
      uint32_t v26 = "service_publisher_action_start_listeners";
      __int16 v27 = 2082;
      uint64_t v28 = v16;
      __int16 v29 = 2160;
      uint64_t v30 = 1752392040;
      __int16 v31 = 2081;
      uint64_t v32 = v17;
      __int16 v33 = 2082;
      uint64_t v34 = v18;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s/%{private, mask.hash}s: entering state %{public}s", buf, 0x34u);
    }
    if (*(unsigned char *)(v4 + 262))
    {
      if (*(void *)(v4 + 112)) {
        return 5;
      }
      uint64_t v19 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)int buf = 136446210;
        uint32_t v26 = "service_publisher_action_start_listeners";
        _os_log_impl((void *)&_mh_execute_header, v19, OS_LOG_TYPE_FAULT, "%{public}s: have_srp_listener is true but there's no listener!", buf, 0xCu);
      }
      *(unsigned char *)(v4 + 262) = 0;
    }
    if (*(void *)(v4 + 112))
    {
      uint64_t v20 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)int buf = 136446210;
        uint32_t v26 = "service_publisher_listener_start";
        _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_FAULT, "%{public}s: listener still present", buf, 0xCu);
      }
      service_publisher_listener_cancel(v4);
    }
    __int16 v21 = *(const char **)(v4 + 80);
    uint64_t v22 = *(void *)(v4 + 88);
    if (v21 && (LODWORD(v21) = if_nametoindex(v21), !v21))
    {
      *(void *)(v4 + 112) = 0;
    }
    else
    {
      int v23 = ioloop_listener_create(0, 0, 0, 0, "SRP UDP listener", (uint64_t)dns_input, (uint64_t)service_publisher_listener_cancel_callback, (uint64_t)service_publisher_listener_ready, 0, (int)v21, v22);
      *(void *)(v4 + 112) = v23;
      if (v23)
      {
        service_publisher_re_advertise_matching(v4);
        ioloop_listener_permitted_interface_list_set(*(void *)(v4 + 112), *(int **)(*(void *)(v4 + 88) + 72));
        return 0;
      }
    }
    uint64_t v24 = global_os_log;
    uint64_t result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)int buf = 136446210;
    uint32_t v26 = "service_publisher_listener_start";
    __int16 v13 = "%{public}s: failed to setup SRP listener";
    int v14 = v24;
    uint32_t v15 = 12;
LABEL_11:
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, v13, buf, v15);
    return 0;
  }
  if (v6)
  {
    uint64_t v7 = *(void *)(v4 + 40);
    uint64_t v8 = *(void *)(v4 + 8);
    uint64_t v9 = *(void *)(a2 + 8);
    uint64_t v10 = *(void *)(v4 + 24);
    *(_DWORD *)int buf = 136447491;
    uint32_t v26 = "service_publisher_action_start_listeners";
    __int16 v27 = 2082;
    uint64_t v28 = v7;
    __int16 v29 = 2160;
    uint64_t v30 = 1752392040;
    __int16 v31 = 2081;
    uint64_t v32 = v8;
    __int16 v33 = 2082;
    uint64_t v34 = v9;
    __int16 v35 = 2082;
    uint64_t v36 = v10;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s/%{private, mask.hash}s: event %{public}s received in state %{public}s", buf, 0x3Eu);
  }
  if (service_publisher_can_publish(v4))
  {
    if (*(_DWORD *)(a2 + 16) == 5) {
      return 5;
    }
    else {
      return 0;
    }
  }
  else
  {
    service_publisher_listener_cancel(v4);
    return 3;
  }
}

void service_publisher_listener_cancel_callback(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 48);
  if (!v2) {
    return;
  }
  uint64_t v3 = state_machine_event_create(6);
  if (v3)
  {
    uint64_t v4 = v3;
    state_machine_event_deliver(v2 + 8, (uint64_t)v3);
    int v5 = *v4;
    if (*v4)
    {
      BOOL v6 = global_os_log;
      if (v5 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v11 = 136447490;
          uint64_t v12 = "service_publisher_listener_cancel_callback";
          __int16 v13 = 1024;
          *(_DWORD *)int v14 = v5;
          *(_WORD *)&v14[4] = 2048;
          *(void *)&v14[6] = v4;
          *(_WORD *)&v14[14] = 2080;
          *(void *)&v14[16] = "event";
          *(_WORD *)&v14[24] = 2080;
          *(void *)&v14[26] = "service-publisher.c";
          __int16 v15 = 1024;
          int v16 = 1220;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v11, 0x36u);
          int v5 = *v4;
        }
        int *v4 = v5 - 1;
        if (v5 == 1)
        {
          uint64_t v7 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v11 = 136447234;
            uint64_t v12 = "service_publisher_listener_cancel_callback";
            __int16 v13 = 2048;
            *(void *)int v14 = v4;
            *(_WORD *)&v14[8] = 2080;
            *(void *)&v14[10] = "event";
            *(_WORD *)&v14[18] = 2080;
            *(void *)&v14[20] = "service-publisher.c";
            *(_WORD *)&v14[28] = 1024;
            *(_DWORD *)&v14[30] = 1220;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v11, 0x30u);
          }
          ++state_machine_event_finalized;
          uint64_t v8 = (void (*)(int *))*((void *)v4 + 4);
          if (v8) {
            v8(v4);
          }
          free(v4);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_21:
      }
        abort();
      int v11 = 136447490;
      uint64_t v12 = "service_publisher_listener_cancel_callback";
      __int16 v13 = 1024;
      *(_DWORD *)int v14 = v5;
      *(_WORD *)&v14[4] = 2048;
      *(void *)&v14[6] = v4;
      *(_WORD *)&v14[14] = 2080;
      *(void *)&v14[16] = "event";
      *(_WORD *)&v14[24] = 2080;
      *(void *)&v14[26] = "service-publisher.c";
      __int16 v15 = 1024;
      int v16 = 1220;
      uint64_t v10 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      BOOL v6 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_21;
      }
      int v11 = 136447490;
      uint64_t v12 = "service_publisher_listener_cancel_callback";
      __int16 v13 = 1024;
      *(_DWORD *)int v14 = 0;
      *(_WORD *)&v14[4] = 2048;
      *(void *)&v14[6] = v4;
      *(_WORD *)&v14[14] = 2080;
      *(void *)&v14[16] = "event";
      *(_WORD *)&v14[24] = 2080;
      *(void *)&v14[26] = "service-publisher.c";
      __int16 v15 = 1024;
      int v16 = 1220;
      uint64_t v10 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, v10, (uint8_t *)&v11, 0x36u);
    goto LABEL_21;
  }
  uint64_t v9 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    int v11 = 136446210;
    uint64_t v12 = "service_publisher_listener_cancel_callback";
    _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v11, 0xCu);
  }
}

void service_publisher_listener_ready(uint64_t a1, __int16 a2)
{
  uint64_t v2 = *(void *)(a1 + 48);
  if (!v2) {
    return;
  }
  uint64_t v4 = state_machine_event_create(5);
  if (v4)
  {
    int v5 = v4;
    *(unsigned char *)(v2 + 262) = 1;
    *(_WORD *)(v2 + 256) = a2;
    state_machine_event_deliver(v2 + 8, (uint64_t)v4);
    int v6 = *v5;
    if (*v5)
    {
      uint64_t v7 = global_os_log;
      if (v6 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v12 = 136447490;
          __int16 v13 = "service_publisher_listener_ready";
          __int16 v14 = 1024;
          *(_DWORD *)__int16 v15 = v6;
          *(_WORD *)&_OWORD v15[4] = 2048;
          *(void *)&v15[6] = v5;
          *(_WORD *)&v15[14] = 2080;
          *(void *)&v15[16] = "event";
          *(_WORD *)&v15[24] = 2080;
          *(void *)&v15[26] = "service-publisher.c";
          __int16 v16 = 1024;
          int v17 = 1250;
          _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v12, 0x36u);
          int v6 = *v5;
        }
        int *v5 = v6 - 1;
        if (v6 == 1)
        {
          uint64_t v8 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v12 = 136447234;
            __int16 v13 = "service_publisher_listener_ready";
            __int16 v14 = 2048;
            *(void *)__int16 v15 = v5;
            *(_WORD *)&v15[8] = 2080;
            *(void *)&v15[10] = "event";
            *(_WORD *)&v15[18] = 2080;
            *(void *)&v15[20] = "service-publisher.c";
            *(_WORD *)&v15[28] = 1024;
            *(_DWORD *)&v15[30] = 1250;
            _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v12, 0x30u);
          }
          ++state_machine_event_finalized;
          uint64_t v9 = (void (*)(int *))*((void *)v5 + 4);
          if (v9) {
            v9(v5);
          }
          free(v5);
        }
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_21:
      }
        abort();
      int v12 = 136447490;
      __int16 v13 = "service_publisher_listener_ready";
      __int16 v14 = 1024;
      *(_DWORD *)__int16 v15 = v6;
      *(_WORD *)&_OWORD v15[4] = 2048;
      *(void *)&v15[6] = v5;
      *(_WORD *)&v15[14] = 2080;
      *(void *)&v15[16] = "event";
      *(_WORD *)&v15[24] = 2080;
      *(void *)&v15[26] = "service-publisher.c";
      __int16 v16 = 1024;
      int v17 = 1250;
      int v11 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      uint64_t v7 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_21;
      }
      int v12 = 136447490;
      __int16 v13 = "service_publisher_listener_ready";
      __int16 v14 = 1024;
      *(_DWORD *)__int16 v15 = 0;
      *(_WORD *)&_OWORD v15[4] = 2048;
      *(void *)&v15[6] = v5;
      *(_WORD *)&v15[14] = 2080;
      *(void *)&v15[16] = "event";
      *(_WORD *)&v15[24] = 2080;
      *(void *)&v15[26] = "service-publisher.c";
      __int16 v16 = 1024;
      int v17 = 1250;
      int v11 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
    _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_FAULT, v11, (uint8_t *)&v12, 0x36u);
    goto LABEL_21;
  }
  uint64_t v10 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    int v12 = 136446210;
    __int16 v13 = "service_publisher_listener_ready";
    _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v12, 0xCu);
  }
}

uint64_t service_publisher_action_not_publishing(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 52);
  if (v2 != 2)
  {
    int v12 = global_os_log;
    uint64_t result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v16 = 136446466;
    int v17 = "service_publisher_action_not_publishing";
    __int16 v18 = 1024;
    LODWORD(v19) = v2;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%{public}s: state header type isn't service_publisher: %d", (uint8_t *)&v16, 0x12u);
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  int v5 = global_os_log;
  BOOL v6 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (!a2)
  {
    if (v6)
    {
      uint64_t v13 = *(void *)(v4 + 40);
      uint64_t v14 = *(void *)(v4 + 8);
      uint64_t v15 = *(void *)(v4 + 24);
      int v16 = 136447235;
      int v17 = "service_publisher_action_not_publishing";
      __int16 v18 = 2082;
      uint64_t v19 = v13;
      __int16 v20 = 2160;
      uint64_t v21 = 1752392040;
      __int16 v22 = 2081;
      uint64_t v23 = v14;
      __int16 v24 = 2082;
      uint64_t v25 = v15;
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s/%{private, mask.hash}s: entering state %{public}s", (uint8_t *)&v16, 0x34u);
    }
    if (*(void *)(v4 + 128)) {
      service_publisher_service_unpublish(v4, 1);
    }
    return 0;
  }
  if (v6)
  {
    uint64_t v7 = *(void *)(v4 + 40);
    uint64_t v8 = *(void *)(v4 + 8);
    uint64_t v9 = *(void *)(a2 + 8);
    uint64_t v10 = *(void *)(v4 + 24);
    int v16 = 136447491;
    int v17 = "service_publisher_action_not_publishing";
    __int16 v18 = 2082;
    uint64_t v19 = v7;
    __int16 v20 = 2160;
    uint64_t v21 = 1752392040;
    __int16 v22 = 2081;
    uint64_t v23 = v8;
    __int16 v24 = 2082;
    uint64_t v25 = v9;
    __int16 v26 = 2082;
    uint64_t v27 = v10;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s/%{private, mask.hash}s: event %{public}s received in state %{public}s", (uint8_t *)&v16, 0x3Eu);
  }
  uint64_t result = service_publisher_can_publish(v4);
  if (result)
  {
    *(_DWORD *)(v4 + 248) = 5000;
    return 1;
  }
  return result;
}

uint64_t service_publisher_action_waiting_to_publish(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 52);
  if (v2 != 2)
  {
    uint64_t v14 = global_os_log;
    uint64_t result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v19 = 136446466;
    __int16 v20 = "service_publisher_action_waiting_to_publish";
    __int16 v21 = 1024;
    LODWORD(v22) = v2;
    _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%{public}s: state header type isn't service_publisher: %d", (uint8_t *)&v19, 0x12u);
    return 0;
  }
  uint64_t v4 = *(void *)(a1 + 8);
  uint64_t v5 = global_os_log;
  BOOL v6 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (a2)
  {
    if (!v6) {
      goto LABEL_11;
    }
    uint64_t v7 = *(void *)(v4 + 40);
    uint64_t v8 = *(void *)(v4 + 8);
    uint64_t v9 = *(void *)(a2 + 8);
    uint64_t v10 = *(void *)(v4 + 24);
    int v19 = 136447491;
    __int16 v20 = "service_publisher_action_waiting_to_publish";
    __int16 v21 = 2082;
    uint64_t v22 = v7;
    __int16 v23 = 2160;
    uint64_t v24 = 1752392040;
    __int16 v25 = 2081;
    uint64_t v26 = v8;
    __int16 v27 = 2082;
    uint64_t v28 = v9;
    __int16 v29 = 2082;
    uint64_t v30 = v10;
    int v11 = "%{public}s: %{public}s/%{private, mask.hash}s: event %{public}s received in state %{public}s";
    int v12 = v5;
    uint32_t v13 = 62;
  }
  else
  {
    if (!v6) {
      goto LABEL_11;
    }
    uint64_t v16 = *(void *)(v4 + 40);
    uint64_t v17 = *(void *)(v4 + 8);
    uint64_t v18 = *(void *)(v4 + 24);
    int v19 = 136447235;
    __int16 v20 = "service_publisher_action_waiting_to_publish";
    __int16 v21 = 2082;
    uint64_t v22 = v16;
    __int16 v23 = 2160;
    uint64_t v24 = 1752392040;
    __int16 v25 = 2081;
    uint64_t v26 = v17;
    __int16 v27 = 2082;
    uint64_t v28 = v18;
    int v11 = "%{public}s: %{public}s/%{private, mask.hash}s: entering state %{public}s";
    int v12 = v5;
    uint32_t v13 = 52;
  }
  _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, v11, (uint8_t *)&v19, v13);
LABEL_11:
  if (service_publisher_can_publish(v4))
  {
    ioloop_cancel_wake_event(*(void *)(v4 + 96));
    *(unsigned char *)(v4 + 269) = 0;
    return 4;
  }
  if (!service_publisher_have_competing_unicast_service(v4, 1))
  {
    if (a2 && *(_DWORD *)(a2 + 16) == 1 && !*(unsigned char *)(v4 + 268)) {
      service_publisher_re_advertise_matching(v4);
    }
    return 0;
  }
  ioloop_cancel_wake_event(*(void *)(v4 + 96));
  *(unsigned char *)(v4 + 269) = 0;
  return 3;
}

uint64_t service_publisher_action_startup(uint64_t a1, uint64_t a2)
{
  int v2 = *(_DWORD *)(a1 + 52);
  if (v2 != 2)
  {
    uint64_t v16 = global_os_log;
    uint64_t result = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v28 = 136446466;
    __int16 v29 = "service_publisher_action_startup";
    __int16 v30 = 1024;
    LODWORD(v31) = v2;
    uint64_t v17 = "%{public}s: state header type isn't service_publisher: %d";
    uint64_t v18 = v16;
    os_log_type_t v19 = OS_LOG_TYPE_ERROR;
    uint32_t v20 = 18;
    goto LABEL_16;
  }
  uint64_t v4 = *(void **)(a1 + 8);
  uint64_t v5 = global_os_log;
  BOOL v6 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
  if (!a2)
  {
    if (v6)
    {
      uint64_t v21 = v4[5];
      uint64_t v22 = v4[1];
      uint64_t v23 = v4[3];
      int v28 = 136447235;
      __int16 v29 = "service_publisher_action_startup";
      __int16 v30 = 2082;
      uint64_t v31 = v21;
      __int16 v32 = 2160;
      uint64_t v33 = 1752392040;
      __int16 v34 = 2081;
      uint64_t v35 = v22;
      __int16 v36 = 2082;
      uint64_t v37 = v23;
      uint32_t v13 = "%{public}s: %{public}s/%{private, mask.hash}s: entering state %{public}s";
      uint64_t v14 = v5;
      uint32_t v15 = 52;
      goto LABEL_12;
    }
    return 2;
  }
  if (v6)
  {
    uint64_t v7 = v4[5];
    uint64_t v8 = v4[1];
    uint64_t v9 = *(void *)(a2 + 8);
    uint64_t v10 = v4[3];
    int v28 = 136447491;
    __int16 v29 = "service_publisher_action_startup";
    __int16 v30 = 2082;
    uint64_t v31 = v7;
    __int16 v32 = 2160;
    uint64_t v33 = 1752392040;
    __int16 v34 = 2081;
    uint64_t v35 = v8;
    __int16 v36 = 2082;
    uint64_t v37 = v9;
    __int16 v38 = 2082;
    uint64_t v39 = v10;
    _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s/%{private, mask.hash}s: event %{public}s received in state %{public}s", (uint8_t *)&v28, 0x3Eu);
    uint64_t v5 = global_os_log;
  }
  int v11 = *(_DWORD *)(a2 + 16);
  uint64_t result = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v11 == 1)
  {
    if (result)
    {
      int v28 = 136446210;
      __int16 v29 = "service_publisher_action_startup";
      uint32_t v13 = "%{public}s: startup timeout";
      uint64_t v14 = v5;
      uint32_t v15 = 12;
LABEL_12:
      _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_DEFAULT, v13, (uint8_t *)&v28, v15);
      return 2;
    }
    return 2;
  }
  if (result)
  {
    uint64_t v24 = v4[5];
    uint64_t v25 = v4[1];
    uint64_t v26 = *(void *)(a2 + 8);
    uint64_t v27 = v4[3];
    int v28 = 136447491;
    __int16 v29 = "service_publisher_action_startup";
    __int16 v30 = 2082;
    uint64_t v31 = v24;
    __int16 v32 = 2160;
    uint64_t v33 = 1752392040;
    __int16 v34 = 2081;
    uint64_t v35 = v25;
    __int16 v36 = 2082;
    uint64_t v37 = v26;
    __int16 v38 = 2082;
    uint64_t v39 = v27;
    uint64_t v17 = "%{public}s: %{public}s/%{private, mask.hash}s: unexpected event %{public}s in state %{public}s";
    uint64_t v18 = v5;
    os_log_type_t v19 = OS_LOG_TYPE_DEFAULT;
    uint32_t v20 = 62;
LABEL_16:
    _os_log_impl((void *)&_mh_execute_header, v18, v19, v17, (uint8_t *)&v28, v20);
    return 0;
  }
  return result;
}

void service_publisher_active_data_set_changed_callback(uint64_t a1, int a2)
{
  if (a2)
  {
    uint64_t v4 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446466;
      uint64_t v16 = "service_publisher_active_data_set_changed_callback";
      __int16 v17 = 1024;
      *(_DWORD *)uint64_t v18 = a2;
      _os_log_impl((void *)&_mh_execute_header, v4, OS_LOG_TYPE_ERROR, "%{public}s: error %d", buf, 0x12u);
    }
    if (!a1) {
      goto LABEL_13;
    }
    int v5 = *(_DWORD *)a1;
    if (*(_DWORD *)a1)
    {
      BOOL v6 = global_os_log;
      if (v5 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447490;
          uint64_t v16 = "service_publisher_active_data_set_changed_callback";
          __int16 v17 = 1024;
          *(_DWORD *)uint64_t v18 = v5;
          *(_WORD *)&v18[4] = 2048;
          *(void *)&v18[6] = a1;
          *(_WORD *)&unsigned char v18[14] = 2080;
          *(void *)&v18[16] = "publisher";
          *(_WORD *)&v18[24] = 2080;
          *(void *)&v18[26] = "service-publisher.c";
          __int16 v19 = 1024;
          int v20 = 1649;
          _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          int v5 = *(_DWORD *)a1;
        }
        *(_DWORD *)a1 = v5 - 1;
        if (v5 == 1)
        {
          uint64_t v7 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136447234;
            uint64_t v16 = "service_publisher_active_data_set_changed_callback";
            __int16 v17 = 2048;
            *(void *)uint64_t v18 = a1;
            *(_WORD *)&v18[8] = 2080;
            *(void *)&v18[10] = "publisher";
            *(_WORD *)&v18[18] = 2080;
            *(void *)&v18[20] = "service-publisher.c";
            *(_WORD *)&v18[28] = 1024;
            *(_DWORD *)&v18[30] = 1649;
            _os_log_impl((void *)&_mh_execute_header, v7, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          }
          ++service_publisher_finalized;
          service_publisher_finalize(a1);
        }
LABEL_13:
        cti_events_discontinue(*(void *)(a1 + 152));
        *(void *)(a1 + 152) = 0;
        return;
      }
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_30:
      }
        abort();
      *(_DWORD *)int buf = 136447490;
      uint64_t v16 = "service_publisher_active_data_set_changed_callback";
      __int16 v17 = 1024;
      *(_DWORD *)uint64_t v18 = v5;
      *(_WORD *)&v18[4] = 2048;
      *(void *)&v18[6] = a1;
      *(_WORD *)&unsigned char v18[14] = 2080;
      *(void *)&v18[16] = "publisher";
      *(_WORD *)&v18[24] = 2080;
      *(void *)&v18[26] = "service-publisher.c";
      __int16 v19 = 1024;
      int v20 = 1649;
      uint64_t v14 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    }
    else
    {
      BOOL v6 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_30;
      }
      *(_DWORD *)int buf = 136447490;
      uint64_t v16 = "service_publisher_active_data_set_changed_callback";
      __int16 v17 = 1024;
      *(_DWORD *)uint64_t v18 = 0;
      *(_WORD *)&v18[4] = 2048;
      *(void *)&v18[6] = a1;
      *(_WORD *)&unsigned char v18[14] = 2080;
      *(void *)&v18[16] = "publisher";
      *(_WORD *)&v18[24] = 2080;
      *(void *)&v18[26] = "service-publisher.c";
      __int16 v19 = 1024;
      int v20 = 1649;
      uint64_t v14 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
    }
LABEL_29:
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_FAULT, v14, buf, 0x36u);
    goto LABEL_30;
  }
  xpc_object_t v8 = xpc_dictionary_create(0, 0, 0);
  xpc_dictionary_set_string(v8, "interface", "org.wpantund.v1");
  xpc_dictionary_set_string(v8, "path", "/org/wpantund/utun2");
  xpc_dictionary_set_string(v8, "method", "PropGet");
  xpc_dictionary_set_string(v8, "property_name", "IPv6:MeshLocalAddress");
  int v9 = setup_for_command(0, (uint64_t)"get_mesh_local_address", 0, (uint64_t)"IPv6:MeshLocalAddress", v8, a1, (uint64_t)service_publisher_get_mesh_local_address_callback, (uint64_t)cti_internal_string_property_reply, 0, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 1656);
  xpc_release(v8);
  uint64_t v10 = global_os_log;
  if (v9)
  {
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446466;
      uint64_t v16 = "service_publisher_active_data_set_changed_callback";
      __int16 v17 = 1024;
      *(_DWORD *)uint64_t v18 = v9;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_ERROR, "%{public}s: cti_get_mesh_local_address failed with status %d", buf, 0x12u);
    }
  }
  else
  {
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v11 = *(_DWORD *)a1;
      *(_DWORD *)int buf = 136447490;
      uint64_t v16 = "service_publisher_active_data_set_changed_callback";
      __int16 v17 = 1024;
      *(_DWORD *)uint64_t v18 = v11;
      *(_WORD *)&v18[4] = 2048;
      *(void *)&v18[6] = a1;
      *(_WORD *)&unsigned char v18[14] = 2080;
      *(void *)&v18[16] = "publisher";
      *(_WORD *)&v18[24] = 2080;
      *(void *)&v18[26] = "service-publisher.c";
      __int16 v19 = 1024;
      int v20 = 1660;
      _os_log_impl((void *)&_mh_execute_header, v10, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    }
    int v12 = *(_DWORD *)a1;
    if (!*(_DWORD *)a1)
    {
      ++service_publisher_created;
      *(_DWORD *)a1 = 1;
      return;
    }
    int v13 = v12 + 1;
    *(_DWORD *)a1 = v12 + 1;
    if (v12 + 1 >= 10001)
    {
      BOOL v6 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
        goto LABEL_30;
      }
      *(_DWORD *)int buf = 136447490;
      uint64_t v16 = "service_publisher_active_data_set_changed_callback";
      __int16 v17 = 1024;
      *(_DWORD *)uint64_t v18 = v13;
      *(_WORD *)&v18[4] = 2048;
      *(void *)&v18[6] = a1;
      *(_WORD *)&unsigned char v18[14] = 2080;
      *(void *)&v18[16] = "publisher";
      *(_WORD *)&v18[24] = 2080;
      *(void *)&v18[26] = "service-publisher.c";
      __int16 v19 = 1024;
      int v20 = 1660;
      uint64_t v14 = "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d";
      goto LABEL_29;
    }
  }
}

void service_publisher_get_mesh_local_address_callback(uint64_t a1, const char *a2, int a3)
{
  if (a3 == -65563 || a3 == -65569)
  {
    int v5 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136446210;
      uint64_t v33 = "service_publisher_get_mesh_local_address_callback";
      _os_log_impl((void *)&_mh_execute_header, v5, OS_LOG_TYPE_DEFAULT, "%{public}s: disconnected", buf, 0xCu);
    }
    BOOL v6 = *(void (**)(void))(a1 + 120);
    if (v6) {
      v6(*(void *)(a1 + 88));
    }
    goto LABEL_10;
  }
  int v12 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v14 = "<null>";
    *(_DWORD *)int buf = 136446722;
    uint64_t v33 = "service_publisher_get_mesh_local_address_callback";
    if (a2) {
      uint64_t v14 = a2;
    }
    __int16 v34 = 2082;
    *(void *)uint64_t v35 = v14;
    *(_WORD *)&v35[8] = 1024;
    *(_DWORD *)&unsigned char v35[10] = a3;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: %{public}s %d", buf, 0x1Cu);
  }
  if (!a2 || a3)
  {
LABEL_10:
    *(unsigned char *)(a1 + 258) = 0;
    goto LABEL_11;
  }
  long long v31 = 0uLL;
  if (!inet_pton(30, a2, &v31))
  {
    uint64_t v25 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446723;
      uint64_t v33 = "service_publisher_get_mesh_local_address_callback";
      __int16 v34 = 2160;
      *(void *)uint64_t v35 = 1752392040;
      *(_WORD *)&v35[8] = 2081;
      *(void *)&unsigned char v35[10] = a2;
      _os_log_impl((void *)&_mh_execute_header, v25, OS_LOG_TYPE_ERROR, "%{public}s: address syntax incorrect: %{private, mask.hash}s", buf, 0x20u);
    }
    goto LABEL_10;
  }
  if (*(unsigned char *)(a1 + 258))
  {
    if ((void)v31 == *(void *)(a1 + 176) && *((void *)&v31 + 1) == *(void *)(a1 + 184))
    {
      uint64_t v27 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v33 = "service_publisher_get_mesh_local_address_callback";
        _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "%{public}s: address didn't change", buf, 0xCu);
      }
      goto LABEL_11;
    }
  }
  *(_OWORD *)(a1 + 176) = v31;
  *(unsigned char *)(a1 + 258) = 1;
  uint64_t v16 = *(void *)(*(void *)(a1 + 88) + 40);
  if (v16)
  {
    for (uint64_t i = *(void *)(v16 + 48); i; uint64_t i = *(void *)(i + 8))
    {
      if (!*(unsigned char *)(i + 27) && *(_DWORD *)(i + 20) == 2 && !*(void *)(a1 + 128))
      {
        if (*(unsigned __int16 *)(i + 16) == *(unsigned __int16 *)(*(void *)(a1 + 88) + 276)
          || *(unsigned char *)(a1 + 258)
          && (*(void *)(i + 64) == *(void *)(a1 + 176)
            ? (BOOL v18 = *(void *)(i + 72) == *(void *)(a1 + 184))
            : (BOOL v18 = 0),
              v18))
        {
          thread_service_note(*(void *)(a1 + 72), i, (uint64_t)"is on our ml-eid or rloc16 but we aren't publishing it, so it's stale.");
          service_publisher_unpublish_stale_service(a1, i);
        }
      }
    }
  }
  __int16 v19 = state_machine_event_create(7);
  if (v19)
  {
    int v20 = v19;
    state_machine_event_deliver(a1 + 8, (uint64_t)v19);
    int v21 = *v20;
    if (*v20)
    {
      uint64_t v22 = global_os_log;
      if (v21 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)int buf = 136447490;
          uint64_t v33 = "service_publisher_get_mesh_local_address_callback";
          __int16 v34 = 1024;
          *(_DWORD *)uint64_t v35 = v21;
          *(_WORD *)&v35[4] = 2048;
          *(void *)&v35[6] = v20;
          *(_WORD *)&v35[14] = 2080;
          *(void *)&v35[16] = "event";
          *(_WORD *)&v35[24] = 2080;
          *(void *)&v35[26] = "service-publisher.c";
          __int16 v36 = 1024;
          int v37 = 1633;
          _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
          int v21 = *v20;
        }
        *int v20 = v21 - 1;
        if (v21 == 1)
        {
          uint64_t v23 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)int buf = 136447234;
            uint64_t v33 = "service_publisher_get_mesh_local_address_callback";
            __int16 v34 = 2048;
            *(void *)uint64_t v35 = v20;
            *(_WORD *)&v35[8] = 2080;
            *(void *)&unsigned char v35[10] = "event";
            *(_WORD *)&v35[18] = 2080;
            *(void *)&v35[20] = "service-publisher.c";
            *(_WORD *)&v35[28] = 1024;
            *(_DWORD *)&v35[30] = 1633;
            _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
          }
          ++state_machine_event_finalized;
          uint64_t v24 = (void (*)(int *))*((void *)v20 + 4);
          if (v24) {
            v24(v20);
          }
          free(v20);
        }
        goto LABEL_60;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)int buf = 136447490;
        uint64_t v33 = "service_publisher_get_mesh_local_address_callback";
        __int16 v34 = 1024;
        *(_DWORD *)uint64_t v35 = v21;
        *(_WORD *)&v35[4] = 2048;
        *(void *)&v35[6] = v20;
        *(_WORD *)&v35[14] = 2080;
        *(void *)&v35[16] = "event";
        *(_WORD *)&v35[24] = 2080;
        *(void *)&v35[26] = "service-publisher.c";
        __int16 v36 = 1024;
        int v37 = 1633;
        int v28 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        __int16 v29 = v22;
        goto LABEL_69;
      }
    }
    else
    {
      uint64_t v30 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        *(_DWORD *)int buf = 136447490;
        uint64_t v33 = "service_publisher_get_mesh_local_address_callback";
        __int16 v34 = 1024;
        *(_DWORD *)uint64_t v35 = 0;
        *(_WORD *)&v35[4] = 2048;
        *(void *)&v35[6] = v20;
        *(_WORD *)&v35[14] = 2080;
        *(void *)&v35[16] = "event";
        *(_WORD *)&v35[24] = 2080;
        *(void *)&v35[26] = "service-publisher.c";
        __int16 v36 = 1024;
        int v37 = 1633;
        int v28 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        __int16 v29 = v30;
        goto LABEL_69;
      }
    }
LABEL_70:
    abort();
  }
  uint64_t v26 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)int buf = 136446210;
    uint64_t v33 = "service_publisher_get_mesh_local_address_callback";
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", buf, 0xCu);
  }
LABEL_60:
  if (!a1) {
    return;
  }
LABEL_11:
  int v7 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    xpc_object_t v8 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_70;
    }
    *(_DWORD *)int buf = 136447490;
    uint64_t v33 = "service_publisher_get_mesh_local_address_callback";
    __int16 v34 = 1024;
    *(_DWORD *)uint64_t v35 = 0;
    *(_WORD *)&v35[4] = 2048;
    *(void *)&v35[6] = a1;
    *(_WORD *)&v35[14] = 2080;
    *(void *)&v35[16] = "publisher";
    *(_WORD *)&v35[24] = 2080;
    *(void *)&v35[26] = "service-publisher.c";
    __int16 v36 = 1024;
    int v37 = 1638;
    int v28 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_68:
    __int16 v29 = v8;
LABEL_69:
    _os_log_impl((void *)&_mh_execute_header, v29, OS_LOG_TYPE_FAULT, v28, buf, 0x36u);
    goto LABEL_70;
  }
  xpc_object_t v8 = global_os_log;
  if (v7 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_70;
    }
    *(_DWORD *)int buf = 136447490;
    uint64_t v33 = "service_publisher_get_mesh_local_address_callback";
    __int16 v34 = 1024;
    *(_DWORD *)uint64_t v35 = v7;
    *(_WORD *)&v35[4] = 2048;
    *(void *)&v35[6] = a1;
    *(_WORD *)&v35[14] = 2080;
    *(void *)&v35[16] = "publisher";
    *(_WORD *)&v35[24] = 2080;
    *(void *)&v35[26] = "service-publisher.c";
    __int16 v36 = 1024;
    int v37 = 1638;
    int v28 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_68;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136447490;
    uint64_t v33 = "service_publisher_get_mesh_local_address_callback";
    __int16 v34 = 1024;
    *(_DWORD *)uint64_t v35 = v7;
    *(_WORD *)&v35[4] = 2048;
    *(void *)&v35[6] = a1;
    *(_WORD *)&v35[14] = 2080;
    *(void *)&v35[16] = "publisher";
    *(_WORD *)&v35[24] = 2080;
    *(void *)&v35[26] = "service-publisher.c";
    __int16 v36 = 1024;
    int v37 = 1638;
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", buf, 0x36u);
    int v7 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v7 - 1;
  if (v7 == 1)
  {
    int v9 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136447234;
      uint64_t v33 = "service_publisher_get_mesh_local_address_callback";
      __int16 v34 = 2048;
      *(void *)uint64_t v35 = a1;
      *(_WORD *)&v35[8] = 2080;
      *(void *)&unsigned char v35[10] = "publisher";
      *(_WORD *)&v35[18] = 2080;
      *(void *)&v35[20] = "service-publisher.c";
      *(_WORD *)&v35[28] = 1024;
      *(_DWORD *)&v35[30] = 1638;
      _os_log_impl((void *)&_mh_execute_header, v9, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", buf, 0x30u);
    }
    ++service_publisher_finalized;
    service_publisher_finalize(a1);
  }
}

void service_publisher_neighbor_callback(void *a1, char *__s1, int a3)
{
  if (a3 == -65563 || a3 == -65569)
  {
    uint64_t v4 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v28 = 136446210;
    __int16 v29 = "service_publisher_neighbor_callback";
    int v5 = "%{public}s: disconnected";
    BOOL v6 = v4;
    os_log_type_t v7 = OS_LOG_TYPE_DEFAULT;
    goto LABEL_8;
  }
  int v9 = __s1;
  if (__s1)
  {
    int v11 = strcmp(__s1, "none");
    int v12 = a1 + 26;
    if (v11)
    {
      if (!inet_pton(30, v9, v12)) {
        int v9 = "<none>";
      }
    }
    else
    {
      void *v12 = 0;
      a1[27] = 0;
    }
  }
  else
  {
    int v9 = "<none>";
  }
  int v13 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v28 = 136446979;
    __int16 v29 = "service_publisher_neighbor_callback";
    __int16 v30 = 2160;
    *(void *)long long v31 = 1752392040;
    *(_WORD *)&v31[8] = 2081;
    *(void *)&v31[10] = v9;
    *(_WORD *)&v31[18] = 1024;
    *(_DWORD *)&v31[20] = a3;
    _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_DEFAULT, "%{public}s: ml_eid: %{private, mask.hash}s, status %d", (uint8_t *)&v28, 0x26u);
  }
  if (!a3)
  {
    uint64_t v14 = (void *)a1[30];
    if (v14)
    {
      free(v14);
      a1[30] = 0;
    }
    if (v9 != "<none>")
    {
      uint32_t v15 = strdup(v9);
      a1[30] = v15;
      if (v15)
      {
LABEL_27:
        __int16 v17 = state_machine_event_create(18);
        if (v17)
        {
          BOOL v18 = v17;
          state_machine_event_deliver((uint64_t)(a1 + 1), (uint64_t)v17);
          int v19 = *v18;
          if (*v18)
          {
            int v20 = global_os_log;
            if (v19 < 10001)
            {
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                int v28 = 136447490;
                __int16 v29 = "service_publisher_neighbor_callback";
                __int16 v30 = 1024;
                *(_DWORD *)long long v31 = v19;
                *(_WORD *)&v31[4] = 2048;
                *(void *)&v31[6] = v18;
                *(_WORD *)&v31[14] = 2080;
                *(void *)&v31[16] = "event";
                *(_WORD *)&v31[24] = 2080;
                *(void *)&v31[26] = "service-publisher.c";
                __int16 v32 = 1024;
                int v33 = 1834;
                _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v28, 0x36u);
                int v19 = *v18;
              }
              *BOOL v18 = v19 - 1;
              if (v19 == 1)
              {
                int v21 = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                {
                  int v28 = 136447234;
                  __int16 v29 = "service_publisher_neighbor_callback";
                  __int16 v30 = 2048;
                  *(void *)long long v31 = v18;
                  *(_WORD *)&v31[8] = 2080;
                  *(void *)&v31[10] = "event";
                  *(_WORD *)&v31[18] = 2080;
                  *(void *)&v31[20] = "service-publisher.c";
                  *(_WORD *)&v31[28] = 1024;
                  *(_DWORD *)&v31[30] = 1834;
                  _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v28, 0x30u);
                }
                ++state_machine_event_finalized;
                uint64_t v22 = (void (*)(int *))*((void *)v18 + 4);
                if (v22) {
                  v22(v18);
                }
                free(v18);
              }
              uint64_t v23 = a1[13];
              if (v23)
              {
                ioloop_cancel_wake_event(v23);
                ioloop_wakeup_release_((void *)a1[13], "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/service-publisher.c", 1838);
                a1[13] = 0;
              }
              return;
            }
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_47:
            }
              abort();
            int v28 = 136447490;
            __int16 v29 = "service_publisher_neighbor_callback";
            __int16 v30 = 1024;
            *(_DWORD *)long long v31 = v19;
            *(_WORD *)&v31[4] = 2048;
            *(void *)&v31[6] = v18;
            *(_WORD *)&v31[14] = 2080;
            *(void *)&v31[16] = "event";
            *(_WORD *)&v31[24] = 2080;
            *(void *)&v31[26] = "service-publisher.c";
            __int16 v32 = 1024;
            int v33 = 1834;
            uint64_t v26 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
            uint64_t v27 = v20;
          }
          else
          {
            uint64_t v25 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
              goto LABEL_47;
            }
            int v28 = 136447490;
            __int16 v29 = "service_publisher_neighbor_callback";
            __int16 v30 = 1024;
            *(_DWORD *)long long v31 = 0;
            *(_WORD *)&v31[4] = 2048;
            *(void *)&v31[6] = v18;
            *(_WORD *)&v31[14] = 2080;
            *(void *)&v31[16] = "event";
            *(_WORD *)&v31[24] = 2080;
            *(void *)&v31[26] = "service-publisher.c";
            __int16 v32 = 1024;
            int v33 = 1834;
            uint64_t v26 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
            uint64_t v27 = v25;
          }
          _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_FAULT, v26, (uint8_t *)&v28, 0x36u);
          goto LABEL_47;
        }
        uint64_t v24 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
          return;
        }
        int v28 = 136446210;
        __int16 v29 = "service_publisher_neighbor_callback";
        int v5 = "%{public}s: unable to allocate event to deliver";
        BOOL v6 = v24;
        os_log_type_t v7 = OS_LOG_TYPE_ERROR;
LABEL_8:
        _os_log_impl((void *)&_mh_execute_header, v6, v7, v5, (uint8_t *)&v28, 0xCu);
        return;
      }
      uint64_t v16 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        int v28 = 136446210;
        __int16 v29 = "service_publisher_neighbor_callback";
        _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_ERROR, "%{public}s: no memory for neighbor_ml_eid string!", (uint8_t *)&v28, 0xCu);
      }
    }
    a1[26] = 0;
    a1[27] = 0;
    goto LABEL_27;
  }
}

void service_publisher_wed_callback(void *a1, const char *a2, char *a3, int a4, int a5)
{
  if (a5 == -65563 || a5 == -65569)
  {
    uint64_t v6 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
      return;
    }
    int v31 = 136446210;
    __int16 v32 = "service_publisher_wed_callback";
    os_log_type_t v7 = "%{public}s: disconnected";
    xpc_object_t v8 = v6;
    os_log_type_t v9 = OS_LOG_TYPE_DEFAULT;
    goto LABEL_8;
  }
  int v12 = a3;
  if (a2) {
    uint64_t v14 = a2;
  }
  else {
    uint64_t v14 = "<none>";
  }
  if (a3)
  {
    if (!inet_pton(30, a3, a1 + 24)) {
      int v12 = "<none>";
    }
  }
  else
  {
    int v12 = "<none>";
  }
  uint32_t v15 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v16 = " removed";
    int v31 = 136447747;
    __int16 v32 = "service_publisher_wed_callback";
    __int16 v33 = 2160;
    *(void *)__int16 v34 = 1752392040;
    if (a4) {
      uint64_t v16 = " added";
    }
    *(_WORD *)&v34[8] = 2081;
    *(void *)&unsigned char v34[10] = v14;
    *(_WORD *)&v34[18] = 2160;
    *(void *)&unsigned char v34[20] = 1752392040;
    *(_WORD *)&v34[28] = 2081;
    *(void *)&v34[30] = v12;
    *(_WORD *)&v34[38] = 2082;
    uint64_t v35 = v16;
    __int16 v36 = 1024;
    int v37 = a5;
    _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_DEFAULT, "%{public}s: ext_address: %{private, mask.hash}s  ml_eid: %{private, mask.hash}s%{public}s %d", (uint8_t *)&v31, 0x44u);
  }
  if (!a5)
  {
    __int16 v17 = (void *)a1[28];
    if (v17)
    {
      free(v17);
      a1[28] = 0;
    }
    BOOL v18 = (void *)a1[29];
    if (v18)
    {
      free(v18);
      a1[29] = 0;
    }
    if (!a4) {
      goto LABEL_37;
    }
    if (v14 != "<none>")
    {
      int v19 = strdup(v14);
      a1[28] = v19;
      if (!v19)
      {
        int v20 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          int v31 = 136446210;
          __int16 v32 = "service_publisher_wed_callback";
          _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "%{public}s: no memory for wed_ext_address string!", (uint8_t *)&v31, 0xCu);
        }
      }
    }
    if (v12 != "<none>")
    {
      int v21 = strdup(v12);
      a1[29] = v21;
      if (v21)
      {
LABEL_37:
        uint64_t v23 = state_machine_event_create(17);
        if (v23)
        {
          uint64_t v24 = v23;
          state_machine_event_deliver((uint64_t)(a1 + 1), (uint64_t)v23);
          int v25 = *v24;
          if (*v24)
          {
            uint64_t v26 = global_os_log;
            if (v25 < 10001)
            {
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
              {
                int v31 = 136447490;
                __int16 v32 = "service_publisher_wed_callback";
                __int16 v33 = 1024;
                *(_DWORD *)__int16 v34 = v25;
                *(_WORD *)&v34[4] = 2048;
                *(void *)&v34[6] = v24;
                *(_WORD *)&v34[14] = 2080;
                *(void *)&v34[16] = "event";
                *(_WORD *)&unsigned char v34[24] = 2080;
                *(void *)&v34[26] = "service-publisher.c";
                *(_WORD *)&v34[34] = 1024;
                *(_DWORD *)&v34[36] = 1780;
                _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v31, 0x36u);
                int v25 = *v24;
              }
              *uint64_t v24 = v25 - 1;
              if (v25 == 1)
              {
                uint64_t v27 = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                {
                  int v31 = 136447234;
                  __int16 v32 = "service_publisher_wed_callback";
                  __int16 v33 = 2048;
                  *(void *)__int16 v34 = v24;
                  *(_WORD *)&v34[8] = 2080;
                  *(void *)&unsigned char v34[10] = "event";
                  *(_WORD *)&v34[18] = 2080;
                  *(void *)&unsigned char v34[20] = "service-publisher.c";
                  *(_WORD *)&v34[28] = 1024;
                  *(_DWORD *)&v34[30] = 1780;
                  _os_log_impl((void *)&_mh_execute_header, v27, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v31, 0x30u);
                }
                ++state_machine_event_finalized;
                int v28 = (void (*)(int *))*((void *)v24 + 4);
                if (v28) {
                  v28(v24);
                }
                free(v24);
              }
              return;
            }
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
LABEL_55:
            }
              abort();
            int v31 = 136447490;
            __int16 v32 = "service_publisher_wed_callback";
            __int16 v33 = 1024;
            *(_DWORD *)__int16 v34 = v25;
            *(_WORD *)&v34[4] = 2048;
            *(void *)&v34[6] = v24;
            *(_WORD *)&v34[14] = 2080;
            *(void *)&v34[16] = "event";
            *(_WORD *)&unsigned char v34[24] = 2080;
            *(void *)&v34[26] = "service-publisher.c";
            *(_WORD *)&v34[34] = 1024;
            *(_DWORD *)&v34[36] = 1780;
            __int16 v30 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
          }
          else
          {
            uint64_t v26 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
              goto LABEL_55;
            }
            int v31 = 136447490;
            __int16 v32 = "service_publisher_wed_callback";
            __int16 v33 = 1024;
            *(_DWORD *)__int16 v34 = 0;
            *(_WORD *)&v34[4] = 2048;
            *(void *)&v34[6] = v24;
            *(_WORD *)&v34[14] = 2080;
            *(void *)&v34[16] = "event";
            *(_WORD *)&unsigned char v34[24] = 2080;
            *(void *)&v34[26] = "service-publisher.c";
            *(_WORD *)&v34[34] = 1024;
            *(_DWORD *)&v34[36] = 1780;
            __int16 v30 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
          }
          _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_FAULT, v30, (uint8_t *)&v31, 0x36u);
          goto LABEL_55;
        }
        uint64_t v29 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
          return;
        }
        int v31 = 136446210;
        __int16 v32 = "service_publisher_wed_callback";
        os_log_type_t v7 = "%{public}s: unable to allocate event to deliver";
        xpc_object_t v8 = v29;
        os_log_type_t v9 = OS_LOG_TYPE_ERROR;
LABEL_8:
        _os_log_impl((void *)&_mh_execute_header, v8, v9, v7, (uint8_t *)&v31, 0xCu);
        return;
      }
      uint64_t v22 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        int v31 = 136446210;
        __int16 v32 = "service_publisher_wed_callback";
        _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_ERROR, "%{public}s: no memory for wed_ml_eid string!", (uint8_t *)&v31, 0xCu);
      }
    }
    a1[24] = 0;
    a1[25] = 0;
    goto LABEL_37;
  }
}

void service_publisher_tunnel_name_callback(uint64_t a1, char *__s1, int a3)
{
  if (a3 == -65569) {
    goto LABEL_4;
  }
  if (a3)
  {
    if (a3 != -65563)
    {
      uint64_t v19 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_30;
      }
      int v20 = "<null>";
      int v28 = 136446722;
      uint64_t v29 = "service_publisher_tunnel_name_callback";
      if (__s1) {
        int v20 = __s1;
      }
      __int16 v30 = 2082;
      *(void *)int v31 = v20;
      *(_WORD *)&v31[8] = 1024;
      *(_DWORD *)&v31[10] = a3;
      os_log_type_t v7 = "%{public}s: %{public}s %d";
      xpc_object_t v8 = v19;
      uint32_t v9 = 28;
LABEL_29:
      _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_DEFAULT, v7, (uint8_t *)&v28, v9);
LABEL_30:
      if (!a1) {
        return;
      }
      goto LABEL_31;
    }
LABEL_4:
    uint64_t v6 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_30;
    }
    int v28 = 136446210;
    uint64_t v29 = "service_publisher_tunnel_name_callback";
    os_log_type_t v7 = "%{public}s: disconnected";
    xpc_object_t v8 = v6;
    uint32_t v9 = 12;
    goto LABEL_29;
  }
  *(unsigned char *)(a1 + 265) = 1;
  uint64_t v10 = *(char **)(a1 + 80);
  if (!v10) {
    goto LABEL_9;
  }
  if (strcmp(__s1, *(const char **)(a1 + 80)))
  {
    ifpermit_list_remove(*(void *)(*(void *)(a1 + 88) + 72), v10);
    free(*(void **)(a1 + 80));
    *(void *)(a1 + 80) = 0;
LABEL_9:
    *(void *)(a1 + 80) = strdup(__s1);
    ifpermit_list_add(*(void *)(*(void *)(a1 + 88) + 72), __s1);
    int v11 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v28 = 136446466;
      uint64_t v29 = "service_publisher_tunnel_name_callback";
      __int16 v30 = 2082;
      *(void *)int v31 = __s1;
      _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_DEFAULT, "%{public}s: thread interface at %{public}s", (uint8_t *)&v28, 0x16u);
    }
    if (!*(void *)(a1 + 80))
    {
      int v12 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        int v28 = 136446466;
        uint64_t v29 = "service_publisher_tunnel_name_callback";
        __int16 v30 = 2082;
        *(void *)int v31 = __s1;
        _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, "%{public}s: No memory to save thread interface name %{public}s", (uint8_t *)&v28, 0x16u);
      }
    }
  }
  int v13 = state_machine_event_create(16);
  if (v13)
  {
    uint64_t v14 = v13;
    state_machine_event_deliver(a1 + 8, (uint64_t)v13);
    int v15 = *v14;
    if (*v14)
    {
      uint64_t v16 = global_os_log;
      if (v15 < 10001)
      {
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
        {
          int v28 = 136447490;
          uint64_t v29 = "service_publisher_tunnel_name_callback";
          __int16 v30 = 1024;
          *(_DWORD *)int v31 = v15;
          *(_WORD *)&v31[4] = 2048;
          *(void *)&v31[6] = v14;
          *(_WORD *)&v31[14] = 2080;
          *(void *)&v31[16] = "event";
          *(_WORD *)&v31[24] = 2080;
          *(void *)&v31[26] = "service-publisher.c";
          __int16 v32 = 1024;
          int v33 = 1714;
          _os_log_impl((void *)&_mh_execute_header, v16, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v28, 0x36u);
          int v15 = *v14;
        }
        *uint64_t v14 = v15 - 1;
        if (v15 == 1)
        {
          __int16 v17 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            int v28 = 136447234;
            uint64_t v29 = "service_publisher_tunnel_name_callback";
            __int16 v30 = 2048;
            *(void *)int v31 = v14;
            *(_WORD *)&v31[8] = 2080;
            *(void *)&v31[10] = "event";
            *(_WORD *)&v31[18] = 2080;
            *(void *)&v31[20] = "service-publisher.c";
            *(_WORD *)&v31[28] = 1024;
            *(_DWORD *)&v31[30] = 1714;
            _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v28, 0x30u);
          }
          ++state_machine_event_finalized;
          BOOL v18 = (void (*)(int *))*((void *)v14 + 4);
          if (v18) {
            v18(v14);
          }
          free(v14);
        }
        goto LABEL_31;
      }
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        int v28 = 136447490;
        uint64_t v29 = "service_publisher_tunnel_name_callback";
        __int16 v30 = 1024;
        *(_DWORD *)int v31 = v15;
        *(_WORD *)&v31[4] = 2048;
        *(void *)&v31[6] = v14;
        *(_WORD *)&v31[14] = 2080;
        *(void *)&v31[16] = "event";
        *(_WORD *)&v31[24] = 2080;
        *(void *)&v31[26] = "service-publisher.c";
        __int16 v32 = 1024;
        int v33 = 1714;
        int v25 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
        uint64_t v26 = v16;
        goto LABEL_47;
      }
    }
    else
    {
      uint64_t v27 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        int v28 = 136447490;
        uint64_t v29 = "service_publisher_tunnel_name_callback";
        __int16 v30 = 1024;
        *(_DWORD *)int v31 = 0;
        *(_WORD *)&v31[4] = 2048;
        *(void *)&v31[6] = v14;
        *(_WORD *)&v31[14] = 2080;
        *(void *)&v31[16] = "event";
        *(_WORD *)&v31[24] = 2080;
        *(void *)&v31[26] = "service-publisher.c";
        __int16 v32 = 1024;
        int v33 = 1714;
        int v25 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
        uint64_t v26 = v27;
        goto LABEL_47;
      }
    }
LABEL_48:
    abort();
  }
  uint64_t v24 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    int v28 = 136446210;
    uint64_t v29 = "service_publisher_tunnel_name_callback";
    _os_log_impl((void *)&_mh_execute_header, v24, OS_LOG_TYPE_ERROR, "%{public}s: unable to allocate event to deliver", (uint8_t *)&v28, 0xCu);
  }
LABEL_31:
  int v21 = *(_DWORD *)a1;
  if (!*(_DWORD *)a1)
  {
    uint64_t v22 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_48;
    }
    int v28 = 136447490;
    uint64_t v29 = "service_publisher_tunnel_name_callback";
    __int16 v30 = 1024;
    *(_DWORD *)int v31 = 0;
    *(_WORD *)&v31[4] = 2048;
    *(void *)&v31[6] = a1;
    *(_WORD *)&v31[14] = 2080;
    *(void *)&v31[16] = "publisher";
    *(_WORD *)&v31[24] = 2080;
    *(void *)&v31[26] = "service-publisher.c";
    __int16 v32 = 1024;
    int v33 = 1716;
    int v25 = "%{public}s: ALLOC: release after finalize at %2.2d: %p (%10s): %s:%d";
LABEL_46:
    uint64_t v26 = v22;
LABEL_47:
    _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_FAULT, v25, (uint8_t *)&v28, 0x36u);
    goto LABEL_48;
  }
  uint64_t v22 = global_os_log;
  if (v21 >= 10001)
  {
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT)) {
      goto LABEL_48;
    }
    int v28 = 136447490;
    uint64_t v29 = "service_publisher_tunnel_name_callback";
    __int16 v30 = 1024;
    *(_DWORD *)int v31 = v21;
    *(_WORD *)&v31[4] = 2048;
    *(void *)&v31[6] = a1;
    *(_WORD *)&v31[14] = 2080;
    *(void *)&v31[16] = "publisher";
    *(_WORD *)&v31[24] = 2080;
    *(void *)&v31[26] = "service-publisher.c";
    __int16 v32 = 1024;
    int v33 = 1716;
    int v25 = "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d";
    goto LABEL_46;
  }
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    int v28 = 136447490;
    uint64_t v29 = "service_publisher_tunnel_name_callback";
    __int16 v30 = 1024;
    *(_DWORD *)int v31 = v21;
    *(_WORD *)&v31[4] = 2048;
    *(void *)&v31[6] = a1;
    *(_WORD *)&v31[14] = 2080;
    *(void *)&v31[16] = "publisher";
    *(_WORD *)&v31[24] = 2080;
    *(void *)&v31[26] = "service-publisher.c";
    __int16 v32 = 1024;
    int v33 = 1716;
    _os_log_impl((void *)&_mh_execute_header, v22, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC: release at %2.2d: %p (%10s): %s:%d", (uint8_t *)&v28, 0x36u);
    int v21 = *(_DWORD *)a1;
  }
  *(_DWORD *)a1 = v21 - 1;
  if (v21 == 1)
  {
    uint64_t v23 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      int v28 = 136447234;
      uint64_t v29 = "service_publisher_tunnel_name_callback";
      __int16 v30 = 2048;
      *(void *)int v31 = a1;
      *(_WORD *)&v31[8] = 2080;
      *(void *)&v31[10] = "publisher";
      *(_WORD *)&v31[18] = 2080;
      *(void *)&v31[20] = "service-publisher.c";
      *(_WORD *)&v31[28] = 1024;
      *(_DWORD *)&v31[30] = 1716;
      _os_log_impl((void *)&_mh_execute_header, v23, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:      finalize: %p (%10s): %s:%d", (uint8_t *)&v28, 0x30u);
    }
    ++service_publisher_finalized;
    service_publisher_finalize(a1);
  }
}

void srp_parse_client_updates_free_(void *a1, uint64_t a2, int a3)
{
  if (a1)
  {
    int v5 = a1;
    do
    {
      uint64_t v6 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136446978;
        int v21 = "srp_parse_client_updates_free_";
        __int16 v22 = 2048;
        uint64_t v23 = v5;
        __int16 v24 = 2082;
        uint64_t v25 = a2;
        __int16 v26 = 1024;
        int v27 = a3;
        _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: %p at %{public}s:%d", buf, 0x26u);
      }
      os_log_type_t v7 = (void *)*v5;
      xpc_object_t v8 = (void *)v5[6];
      if (v8)
      {
        do
        {
          uint32_t v9 = (void *)*v8;
          free(v8);
          xpc_object_t v8 = v9;
        }
        while (v9);
      }
      uint64_t v10 = (void *)v5[7];
      if (v10)
      {
        do
        {
          int v11 = (void *)*v10;
          free(v10);
          uint64_t v10 = v11;
        }
        while (v11);
      }
      int v12 = (void *)v5[8];
      if (v12)
      {
        do
        {
          int v13 = (void *)*v12;
          free(v12);
          int v12 = v13;
        }
        while (v13);
      }
      uint64_t v14 = (void *)v5[5];
      if (v14)
      {
        int v15 = (void *)v14[1];
        if (v15)
        {
          do
          {
            uint64_t v16 = (void *)*v15;
            free(v15);
            int v15 = v16;
          }
          while (v16);
          uint64_t v14 = (void *)v5[5];
        }
        free(v14);
      }
      __int16 v17 = (void *)v5[3];
      if (v17) {
        dns_message_free(v17);
      }
      BOOL v18 = (int *)v5[4];
      if (v18) {
        ioloop_message_release_(v18, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-parse.c", 88);
      }
      uint64_t v19 = v5[1];
      if (v19) {
        ioloop_comm_release_(v19, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-parse.c", 97);
      }
      free(v5);
      int v5 = v7;
    }
    while (v7);
  }
}

uint64_t make_delete(void *a1, void *a2, uint64_t **a3, uint64_t **a4)
{
  while (1)
  {
    xpc_object_t v8 = (void *)*a1;
    if (!*a1) {
      break;
    }
    a1 = (void *)*a1;
    if (dns_names_equal((uint64_t *)v8[1], (uint64_t **)*a3))
    {
      if (*a3) {
        dns_name_print_to_limit(*a3, 0, (uint64_t)buf, 0x3F2uLL);
      }
      else {
        strcpy((char *)buf, "<null>");
      }
      uint64_t v14 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)__int16 v26 = 136446723;
        *(void *)&v26[4] = "make_delete";
        __int16 v27 = 2160;
        uint64_t v28 = 1752392040;
        __int16 v29 = 2081;
        __int16 v30 = buf;
        _os_log_impl((void *)&_mh_execute_header, v14, OS_LOG_TYPE_ERROR, "%{public}s: two deletes for the same name: %{private, mask.hash}s", v26, 0x20u);
      }
      return 1;
    }
  }
  uint32_t v9 = malloc_type_calloc(1uLL, 0x20uLL, 0x102004034AC6F07uLL);
  if (v9)
  {
    uint64_t v10 = v9;
    *a1 = v9;
    int v11 = dns_name_subdomain_of(*a3, a4);
    v10[2] = v11;
    if (!v11)
    {
      if (a4) {
        dns_name_print_to_limit((uint64_t *)a4, 0, (uint64_t)buf, 0x3F2uLL);
      }
      else {
        strcpy((char *)buf, "<null>");
      }
      if (*a3) {
        dns_name_print_to_limit(*a3, 0, (uint64_t)v26, 0x3F2uLL);
      }
      else {
        strcpy(v26, "<null>");
      }
      int v15 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        int v16 = 136447235;
        __int16 v17 = "make_delete";
        __int16 v18 = 2160;
        uint64_t v19 = 1752392040;
        __int16 v20 = 2081;
        int v21 = buf;
        __int16 v22 = 2160;
        uint64_t v23 = 1752392040;
        __int16 v24 = 2081;
        uint64_t v25 = v26;
        _os_log_impl((void *)&_mh_execute_header, v15, OS_LOG_TYPE_ERROR, "%{public}s: delete for record not in update zone %{private, mask.hash}s: %{private, mask.hash}s", (uint8_t *)&v16, 0x34u);
      }
      free(v10);
      return 1;
    }
    v10[1] = *a3;
    uint64_t result = 0;
    if (a2) {
      *a2 = v10;
    }
  }
  else
  {
    int v13 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "make_delete";
      _os_log_impl((void *)&_mh_execute_header, v13, OS_LOG_TYPE_ERROR, "%{public}s: no memory.", buf, 0xCu);
    }
    return 2;
  }
  return result;
}

void replace_zone_name(void *a1, void *a2, uint64_t *a3)
{
  do
  {
    uint64_t v4 = a1;
    a1 = (void *)*a1;
    if (a1) {
      BOOL v5 = a1 == a2;
    }
    else {
      BOOL v5 = 1;
    }
  }
  while (!v5);
  if (!a1)
  {
    int v11 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)int v15 = 136446210;
    *(void *)&_OWORD v15[4] = "replace_zone_name";
    int v12 = "%{public}s: replace_zone: dns_name_subdomain_of returned bogus pointer.";
    goto LABEL_23;
  }
  do
  {
    uint64_t v6 = (void *)*a1;
    free(a1);
    a1 = v6;
  }
  while (v6);
  *(void *)int v15 = 0;
  os_log_type_t v7 = v15;
  do
  {
    xpc_object_t v8 = (uint8_t *)malloc_type_calloc(1uLL, *((unsigned __int8 *)a3 + 8) + 10, 0x7B23CD92uLL);
    *(void *)os_log_type_t v7 = v8;
    if (!v8)
    {
      int v13 = *(void **)v15;
      if (*(void *)v15)
      {
        do
        {
          uint64_t v14 = (void *)*v13;
          free(v13);
          int v13 = v14;
        }
        while (v14);
      }
      void *v4 = 0;
      goto LABEL_21;
    }
    uint64_t v9 = *((unsigned __int8 *)a3 + 8);
    if (*((unsigned char *)a3 + 8))
    {
      memcpy(v8 + 9, (char *)a3 + 9, v9 + 1);
      LOBYTE(v9) = *((unsigned char *)a3 + 8);
      os_log_type_t v7 = *(uint8_t **)v7;
    }
    else
    {
      os_log_type_t v7 = v8;
    }
    v7[8] = v9;
    a3 = (uint64_t *)*a3;
  }
  while (a3);
  uint64_t v10 = *(void *)v15;
  void *v4 = *(void *)v15;
  if (v10) {
    return;
  }
LABEL_21:
  int v11 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)int v15 = 136446210;
    *(void *)&_OWORD v15[4] = "replace_zone_name";
    int v12 = "%{public}s: replace_zone_name: no memory for replacement zone";
LABEL_23:
    _os_log_impl((void *)&_mh_execute_header, v11, OS_LOG_TYPE_ERROR, v12, v15, 0xCu);
  }
}

uint64_t send_fail_response(uint64_t a1, uint64_t a2, unsigned int a3)
{
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v28 = 0u;
  int v43 = 0;
  long long v27 = 0u;
  long long v26 = 0u;
  long long v25 = 0u;
  long long v24 = 0u;
  long long v23 = 0u;
  long long v22 = 0u;
  long long v21 = 0u;
  long long v20 = 0u;
  long long v19 = 0u;
  long long v18 = 0u;
  long long v17 = 0u;
  long long v16 = 0u;
  long long v15 = 0u;
  long long v14 = 0u;
  long long v13 = 0u;
  long long v12 = 0u;
  uint64_t v6 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    if (a3 > 0x17) {
      os_log_type_t v7 = "Unknown rcode.";
    }
    else {
      os_log_type_t v7 = (&off_10008D228)[a3];
    }
    *(_DWORD *)uint64_t v9 = 136446466;
    *(void *)&v9[4] = "send_fail_response";
    *(_WORD *)&v9[12] = 2082;
    *(void *)&v9[14] = v7;
    _os_log_impl((void *)&_mh_execute_header, v6, OS_LOG_TYPE_DEFAULT, "%{public}s: rcode = %{public}s", v9, 0x16u);
  }
  uint64_t v11 = 0;
  v10[0] = *(_WORD *)(a2 + 88);
  v10[1] = bswap32(a3 | (bswap32(*(_WORD *)(a2 + 90) & 0xF0FF) >> 16) | 0x8000) >> 16;
  *(void *)uint64_t v9 = v10;
  *(void *)&v9[8] = 12;
  return ioloop_send_message(a1, a2, (iovec *)v9);
}

void dns_input(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3 = *(unsigned __int16 *)(a2 + 90);
  if ((v3 & 0x80) != 0)
  {
    uint64_t v6 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_19;
    }
    buf[0].count[0] = 136446466;
    *(void *)&buf[0].count[1] = "srp_dns_evaluate";
    LOWORD(buf[0].hash[1]) = 1024;
    *(CC_LONG *)((char *)&buf[0].hash[1] + 2) = (v3 >> 3) & 0xF;
    os_log_type_t v7 = "%{public}s: received a message that was a DNS response: %d";
    xpc_object_t v8 = v6;
    goto LABEL_18;
  }
  if ((v3 & 0x78) != 0x28)
  {
    if ((v3 & 0x78) == 0)
    {
      dns_proxy_input_for_server(a1, a2, 0);
LABEL_19:
      uint64_t v11 = 0;
LABEL_20:
      srp_parse_client_updates_free_(v11, (uint64_t)"/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-parse.c", 923);
      return;
    }
    send_fail_response(a1, a2, 5u);
    uint64_t v18 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_19;
    }
    int v19 = (*(unsigned __int16 *)(a2 + 90) >> 3) & 0xF;
    buf[0].count[0] = 136446466;
    *(void *)&buf[0].count[1] = "srp_dns_evaluate";
    LOWORD(buf[0].hash[1]) = 1024;
    *(CC_LONG *)((char *)&buf[0].hash[1] + 2) = v19;
    os_log_type_t v7 = "%{public}s: received a message that was not a DNS update: %d";
    xpc_object_t v8 = v18;
LABEL_18:
    _os_log_impl((void *)&_mh_execute_header, v8, OS_LOG_TYPE_ERROR, v7, (uint8_t *)buf, 0x12u);
    goto LABEL_19;
  }
  uint64_t v234 = 0;
  uint64_t v235 = 0;
  v232 = 0;
  uint64_t v233 = 0;
  *(void *)&v230.tv_usec = 0;
  uint64_t v231 = 0;
  v230.__darwin_time_t tv_sec = 0;
  uint64_t v10 = (uint64_t *)malloc_type_calloc(1uLL, 0x68uLL, 0x10200408B6E1FCBuLL);
  if (!v10)
  {
    long long v20 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      buf[0].count[0] = 136446210;
      *(void *)&buf[0].count[1] = "srp_evaluate";
      _os_log_impl((void *)&_mh_execute_header, v20, OS_LOG_TYPE_ERROR, "%{public}s: no memory for client update", (uint8_t *)buf, 0xCu);
    }
    send_fail_response(a1, a2, 2u);
    goto LABEL_19;
  }
  uint64_t v11 = v10;
  *((unsigned char *)v10 + 102) = 0;
  *((unsigned char *)v10 + 100) = 2;
  if (!dns_wire_parse_(v10 + 3, (unsigned __int16 *)(a2 + 88), *(unsigned __int16 *)(a2 + 64)))
  {
    long long v21 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      buf[0].count[0] = 136446210;
      *(void *)&buf[0].count[1] = "srp_evaluate";
      _os_log_impl((void *)&_mh_execute_header, v21, OS_LOG_TYPE_ERROR, "%{public}s: dns_wire_parse failed.", (uint8_t *)buf, 0xCu);
    }
    long long v22 = 0;
    long long v23 = 0;
    long long v24 = 0;
    goto LABEL_52;
  }
  v11[4] = a2;
  long long v12 = global_os_log;
  long long v13 = (int *)a2;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
  {
    CC_LONG v14 = *(_DWORD *)a2;
    buf[0].count[0] = 136447490;
    *(void *)&buf[0].count[1] = "srp_evaluate";
    LOWORD(buf[0].hash[1]) = 1024;
    *(CC_LONG *)((char *)&buf[0].hash[1] + 2) = v14;
    HIWORD(buf[0].hash[2]) = 2048;
    *(void *)&buf[0].hash[3] = a2;
    LOWORD(buf[0].hash[5]) = 2080;
    *(void *)((char *)&buf[0].hash[5] + 2) = "ret->message";
    HIWORD(buf[0].hash[7]) = 2080;
    *(void *)buf[0].wint buf = "srp-parse.c";
    LOWORD(buf[0].wbuf[2]) = 1024;
    *(CC_LONG *)((char *)&buf[0].wbuf[2] + 2) = 303;
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_DEFAULT, "%{public}s: ALLOC:  retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)buf, 0x36u);
    long long v13 = (int *)v11[4];
  }
  int v15 = *v13;
  if (*v13)
  {
    CC_LONG v16 = v15 + 1;
    int *v13 = v15 + 1;
    if (v15 + 1 >= 10001)
    {
      long long v17 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
      {
        buf[0].count[0] = 136447490;
        *(void *)&buf[0].count[1] = "srp_evaluate";
        LOWORD(buf[0].hash[1]) = 1024;
        *(CC_LONG *)((char *)&buf[0].hash[1] + 2) = v16;
        HIWORD(buf[0].hash[2]) = 2048;
        *(void *)&buf[0].hash[3] = v13;
        LOWORD(buf[0].hash[5]) = 2080;
        *(void *)((char *)&buf[0].hash[5] + 2) = "ret->message";
        HIWORD(buf[0].hash[7]) = 2080;
        *(void *)buf[0].wint buf = "srp-parse.c";
        LOWORD(buf[0].wbuf[2]) = 1024;
        *(CC_LONG *)((char *)&buf[0].wbuf[2] + 2) = 303;
        _os_log_impl((void *)&_mh_execute_header, v17, OS_LOG_TYPE_FAULT, "%{public}s: ALLOC: retain at %2.2d: %p (%10s): %s:%d", (uint8_t *)buf, 0x36u);
      }
      abort();
    }
  }
  else
  {
    ++message_created;
    int *v13 = 1;
  }
  uint64_t v25 = v11[3];
  *(_DWORD *)md = 3600;
  *(_DWORD *)BOOL v241 = 604800;
  long long v26 = *(uint64_t **)(v25 + 56);
  if (!v26) {
    goto LABEL_48;
  }
  char v27 = 0;
  do
  {
    while (*((_WORD *)v26 + 5) == 2)
    {
      LODWORD(error) = 0;
      CC_LONG v28 = *((unsigned __int16 *)v26 + 4);
      if (v28 != 4 && v28 != 8)
      {
        uint64_t v86 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          buf[0].count[0] = 136446466;
          *(void *)&buf[0].count[1] = "srp_parse_lease_times";
          LOWORD(buf[0].hash[1]) = 1024;
          *(CC_LONG *)((char *)&buf[0].hash[1] + 2) = v28;
          long long v34 = "%{public}s: edns0 update-lease option length bogus: %d";
          long long v35 = v86;
          uint32_t v36 = 18;
LABEL_50:
          _os_log_impl((void *)&_mh_execute_header, v35, OS_LOG_TYPE_ERROR, v34, (uint8_t *)buf, v36);
        }
LABEL_51:
        long long v22 = 0;
        long long v23 = 0;
        long long v24 = 0;
        *((unsigned char *)v11 + 100) = 1;
        goto LABEL_52;
      }
      dns_u32_parse((uint64_t)v26 + 12, *((unsigned __int16 *)v26 + 4), (unsigned int *)&error, (int *)md);
      if (*((_WORD *)v26 + 4) == 8) {
        dns_u32_parse((uint64_t)v26 + 12, 8u, (unsigned int *)&error, (int *)v241);
      }
      else {
        *(_DWORD *)BOOL v241 = 7 * *(_DWORD *)md;
      }
      long long v26 = (uint64_t *)*v26;
      char v27 = 1;
      if (!v26) {
        goto LABEL_44;
      }
    }
    long long v26 = (uint64_t *)*v26;
  }
  while (v26);
  if ((v27 & 1) == 0)
  {
LABEL_48:
    uint64_t v33 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      buf[0].count[0] = 136446210;
      *(void *)&buf[0].count[1] = "srp_parse_lease_times";
      long long v34 = "%{public}s: no update-lease edns0 option found in supposed SRP update";
      long long v35 = v33;
      uint32_t v36 = 12;
      goto LABEL_50;
    }
    goto LABEL_51;
  }
LABEL_44:
  int v30 = *(_DWORD *)v241;
  *((_DWORD *)v11 + 22) = *(_DWORD *)md;
  *((_DWORD *)v11 + 23) = v30;
  if (*(_DWORD *)(v25 + 4) != 1)
  {
    uint64_t v31 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      buf[0].count[0] = 136446210;
      *(void *)&buf[0].count[1] = "srp_evaluate";
      long long v32 = "%{public}s: update received with qdcount > 1";
      goto LABEL_63;
    }
LABEL_65:
    unsigned int v42 = 1;
    *((unsigned char *)v11 + 100) = 1;
LABEL_66:
    if (!*((unsigned char *)v11 + 102)) {
      send_fail_response(a1, a2, v42);
    }
    goto LABEL_20;
  }
  if (*(_DWORD *)(v25 + 8))
  {
    uint64_t v31 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      buf[0].count[0] = 136446210;
      *(void *)&buf[0].count[1] = "srp_evaluate";
      long long v32 = "%{public}s: update received with ancount > 0";
LABEL_63:
      int v43 = v31;
      uint32_t v44 = 12;
LABEL_64:
      _os_log_impl((void *)&_mh_execute_header, v43, OS_LOG_TYPE_ERROR, v32, (uint8_t *)buf, v44);
      goto LABEL_65;
    }
    goto LABEL_65;
  }
  CC_LONG v45 = *(unsigned __int16 *)(*(void *)(v25 + 24) + 8);
  if (v45 != 6)
  {
    uint64_t v48 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_65;
    }
    buf[0].count[0] = 136446466;
    *(void *)&buf[0].count[1] = "srp_evaluate";
    LOWORD(buf[0].hash[1]) = 1024;
    *(CC_LONG *)((char *)&buf[0].hash[1] + 2) = v45;
    long long v32 = "%{public}s: update received with rrtype %d instead of SOA in question section.";
    int v43 = v48;
    uint32_t v44 = 18;
    goto LABEL_64;
  }
  *(void *)buf[0].hash = 0;
  *(void *)buf[0].size_t count = 0;
  clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)buf);
  *(void *)(a2 + 72) = *(void *)buf[0].count;
  long long v23 = **(uint64_t ****)(v25 + 24);
  if (service_update_zone)
  {
    BOOL v46 = dns_names_equal_text(**(uint64_t ***)(v25 + 24), "default.service.arpa.");
    uint64_t v47 = service_update_zone;
    if (!v46) {
      uint64_t v47 = 0;
    }
    int v218 = (uint64_t *)v47;
  }
  else
  {
    int v218 = 0;
  }
  LODWORD(v49) = *(_DWORD *)(v25 + 12);
  if (!v49)
  {
    uint64_t v84 = 0;
LABEL_161:
    int v85 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      buf[0].count[0] = 136446210;
      *(void *)&buf[0].count[1] = "srp_evaluate";
      _os_log_impl((void *)&_mh_execute_header, v85, OS_LOG_TYPE_ERROR, "%{public}s: SRP update does not include a host description.", (uint8_t *)buf, 0xCu);
    }
    long long v24 = 0;
    *((unsigned char *)v11 + 100) = 1;
    long long v22 = v218;
    goto LABEL_318;
  }
  size_t v50 = 0;
  unsigned int key = 0;
  int v216 = 0;
  int v217 = v23;
  uint64_t v219 = 0;
  uint64_t v51 = 0;
  uint64_t v204 = &v232;
  data = &v231;
  LODWORD(signature) = 1;
  do
  {
    v229 = v51;
    CFAllocatorRef v52 = *(CFAllocatorRef *)(v25 + 40);
    uint64_t v53 = (uint64_t **)((char *)v52 + 64 * v50);
    CFAllocatorRef v54 = (const __CFAllocator *)(v53 + 1);
    unsigned int v55 = *((unsigned __int16 *)v53 + 4);
    if (v55 > 0x18)
    {
      if (*((unsigned __int16 *)v53 + 4) <= 0x20u)
      {
        if (v55 != 25)
        {
          if (v55 != 28) {
            goto LABEL_224;
          }
          goto LABEL_94;
        }
        if (key)
        {
          if (key == 1)
          {
            size_t sizec = v50;
            size_t signature = (v49 - v50 + 1);
            __int16 v63 = malloc_type_calloc(signature, 8uLL, 0x2004093837F09uLL);
            if (!v63)
            {
              unsigned int v125 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
              {
                buf[0].count[0] = 136446210;
                *(void *)&buf[0].count[1] = "srp_evaluate";
                _os_log_impl((void *)&_mh_execute_header, v125, OS_LOG_TYPE_ERROR, "%{public}s: no memory", (uint8_t *)buf, 0xCu);
              }
              long long v23 = v217;
              long long v22 = v218;
              long long v24 = v229;
              goto LABEL_52;
            }
            int v216 = v63;
            *__int16 v63 = v219;
            size_t v50 = sizec;
          }
          uint64_t v51 = v229;
          if (key >= signature)
          {
            uint64_t v118 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
              goto LABEL_315;
            }
            buf[0].count[0] = 136446210;
            *(void *)&buf[0].count[1] = "srp_evaluate";
            unsigned int v119 = "%{public}s: coding error in key allocation";
            goto LABEL_262;
          }
          v216[key++] = v53;
          goto LABEL_151;
        }
        unsigned int key = 1;
        uint64_t v219 = (uint64_t ***)((char *)v52 + 64 * v50);
LABEL_150:
        uint64_t v51 = v229;
        goto LABEL_151;
      }
      if (v55 != 33)
      {
        if (v55 != 255 || (int v56 = (char *)v52 + 64 * v50, *((_WORD *)v56 + 5) != 255) || *((_DWORD *)v56 + 3))
        {
LABEL_224:
          if (*v53) {
            dns_name_print_to_limit(*v53, 0, (uint64_t)buf, 0x3F2uLL);
          }
          else {
            strcpy((char *)buf, "<null>");
          }
          uint64_t v112 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
            goto LABEL_314;
          }
          *(_DWORD *)md = 136446979;
          *(void *)&md[4] = "srp_evaluate";
          *(_WORD *)&md[12] = 1024;
          *(_DWORD *)&md[14] = v55;
          *(_WORD *)&md[18] = 2160;
          *(void *)&md[20] = 1752392040;
          *(_WORD *)&md[28] = 2081;
          *(void *)&md[30] = buf;
          int v113 = "%{public}s: unexpected rrtype %d on %{private, mask.hash}s in update.";
          int v114 = md;
          int v115 = v112;
          uint32_t v116 = 38;
          goto LABEL_313;
        }
        size_t size = v50;
        __int16 v57 = 0;
        int v58 = (uint64_t **)((char *)v52 + 64 * v50);
        goto LABEL_92;
      }
      goto LABEL_101;
    }
    if (v55 != 1)
    {
      if (v55 == 12)
      {
        uint64_t v64 = *v53;
        size_t size = v50;
        CFAllocatorRef allocatora = *(CFAllocatorRef *)(v25 + 40);
        if (*v53 && (uint64_t v65 = *v64) != 0 && (v203 = *(uint64_t ***)v65) != 0)
        {
          if (!strcmp((const char *)(v65 + 9), "_sub"))
          {
            uint64_t v66 = v231;
            if (!v231) {
              goto LABEL_159;
            }
            do
            {
              if (dns_names_equal(*(uint64_t **)(v66[2] + 16), *((uint64_t ***)allocatora + 8 * size + 2))
                && (dns_names_equal(*(uint64_t **)v66[2], v203) & 1) != 0)
              {
                goto LABEL_116;
              }
              uint64_t v66 = (uint64_t *)*v66;
            }
            while (v66);
            uint64_t v64 = *v53;
            if (!*v53) {
              strcpy((char *)buf, "<null>");
            }
            else {
LABEL_159:
            }
              dns_name_print_to_limit(v64, 0, (uint64_t)buf, 0x3F2uLL);
            int v122 = (uint64_t *)*((void *)allocatora + 8 * size + 2);
            if (v122) {
              dns_name_print_to_limit(v122, 0, (uint64_t)md, 0x3F2uLL);
            }
            else {
              strcpy(md, "<null>");
            }
            uint64_t v123 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
              goto LABEL_314;
            }
            *(_DWORD *)BOOL v241 = 136447235;
            v242 = "srp_evaluate";
            __int16 v243 = 2160;
            uint64_t v244 = 1752392040;
            __int16 v245 = 2081;
            uint64_t v246 = buf;
            __int16 v247 = 2160;
            uint64_t v248 = 1752392040;
            __int16 v249 = 2081;
            __int16 v250 = md;
            int v113 = "%{public}s: service subtype %{private, mask.hash}s for %{private, mask.hash}s has no preceding base type ";
LABEL_280:
            int v114 = v241;
            int v115 = v123;
            uint32_t v116 = 52;
LABEL_313:
            _os_log_impl((void *)&_mh_execute_header, v115, OS_LOG_TYPE_ERROR, v113, v114, v116);
            goto LABEL_314;
          }
          uint64_t v66 = 0;
LABEL_116:
          size_t v50 = size;
          CFAllocatorRef v52 = allocatora;
        }
        else
        {
          uint64_t v66 = 0;
        }
        uint64_t v68 = (char *)v52 + 64 * v50;
        if (*((_WORD *)v68 + 5) != 254 || *((_DWORD *)v68 + 3))
        {
          __int16 v69 = (uint64_t **)malloc_type_calloc(1uLL, 0x20uLL, 0x20040DC1BFBCFuLL);
          if (!v69)
          {
            uint64_t v118 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
              goto LABEL_315;
            }
            buf[0].count[0] = 136446210;
            *(void *)&buf[0].count[1] = "srp_evaluate";
            unsigned int v119 = "%{public}s: no memory";
LABEL_262:
            _os_log_impl((void *)&_mh_execute_header, v118, OS_LOG_TYPE_ERROR, v119, (uint8_t *)buf, 0xCu);
            goto LABEL_315;
          }
          uint64_t v70 = v69;
          unsigned __int8 *data = (uint64_t *)v69;
          if (v66) {
            __int16 v71 = v66;
          }
          else {
            __int16 v71 = (uint64_t *)v69;
          }
          v69[1] = v71;
          v69[2] = (uint64_t *)v53;
          long long v23 = v217;
          uint64_t v72 = dns_name_subdomain_of(*v53, v217);
          v70[3] = v72;
          if (!v72)
          {
            if (*v53) {
              dns_name_print_to_limit(*v53, 0, (uint64_t)buf, 0x3F2uLL);
            }
            else {
              strcpy((char *)buf, "<null>");
            }
            int v127 = (uint64_t *)*((void *)allocatora + 8 * size + 2);
            if (v127) {
              dns_name_print_to_limit(v127, 0, (uint64_t)md, 0x3F2uLL);
            }
            else {
              strcpy(md, "<null>");
            }
            uint64_t v123 = global_os_log;
            if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
              goto LABEL_314;
            }
            *(_DWORD *)BOOL v241 = 136447235;
            v242 = "srp_evaluate";
            __int16 v243 = 2160;
            uint64_t v244 = 1752392040;
            __int16 v245 = 2081;
            uint64_t v246 = buf;
            __int16 v247 = 2160;
            uint64_t v248 = 1752392040;
            __int16 v249 = 2081;
            __int16 v250 = md;
            int v113 = "%{public}s: service name %{private, mask.hash}s for %{private, mask.hash}s is not in the update zone";
            goto LABEL_280;
          }
          data = v70;
          goto LABEL_130;
        }
        __int16 v57 = (void **)&v234;
        int v58 = v53;
        long long v23 = v217;
LABEL_92:
        int v59 = make_delete(&v235, v57, v58, v23);
        if (v59)
        {
          *((unsigned char *)v11 + 100) = v59;
          goto LABEL_316;
        }
LABEL_130:
        size_t v50 = size;
        uint64_t v51 = v229;
        goto LABEL_151;
      }
      if (v55 != 16) {
        goto LABEL_224;
      }
LABEL_101:
      size_t sizeb = v50;
      uint64_t v62 = (uint64_t *)v235;
      if (!v235)
      {
LABEL_164:
        uint64_t v234 = 0;
        if (*v53) {
          dns_name_print_to_limit(*v53, 0, (uint64_t)buf, 0x3F2uLL);
        }
        else {
          strcpy((char *)buf, "<null>");
        }
        long long v23 = v217;
        long long v22 = v218;
        uint64_t v84 = v216;
        uint64_t v88 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)md = 136446723;
          *(void *)&md[4] = "srp_evaluate";
          *(_WORD *)&md[12] = 2160;
          *(void *)&md[14] = 1752392040;
          *(_WORD *)&md[22] = 2081;
          *(void *)&md[24] = buf;
          _os_log_impl((void *)&_mh_execute_header, v88, OS_LOG_TYPE_ERROR, "%{public}s: ADD for service instance not preceded by delete: %{private, mask.hash}s", md, 0x20u);
        }
        *((unsigned char *)v11 + 100) = 1;
        goto LABEL_317;
      }
      while ((dns_names_equal((uint64_t *)v62[1], (uint64_t **)*v53) & 1) == 0)
      {
        uint64_t v62 = (uint64_t *)*v62;
        if (!v62) {
          goto LABEL_164;
        }
      }
      uint64_t v234 = v62;
      __int16 v67 = &v232;
      long long v23 = v217;
      while (1)
      {
        __int16 v67 = (void *)*v67;
        if (!v67) {
          break;
        }
        if (dns_names_equal((uint64_t *)v67[2], (uint64_t **)*v53)) {
          goto LABEL_133;
        }
      }
      __int16 v73 = malloc_type_calloc(1uLL, 0x48uLL, 0x10200400D7E17FBuLL);
      if (!v73)
      {
        uint64_t v118 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
          goto LABEL_315;
        }
        buf[0].count[0] = 136446210;
        *(void *)&buf[0].count[1] = "srp_evaluate";
        unsigned int v119 = "%{public}s: no memory";
        goto LABEL_262;
      }
      __int16 v67 = v73;
      uint64_t v74 = v234;
      v73[3] = v234;
      v74[24] = 1;
      v73[2] = *((void *)v74 + 1);
      *uint64_t v204 = v73;
      uint64_t v204 = v73;
LABEL_133:
      size_t v50 = sizeb;
      int v75 = *((unsigned __int16 *)v53 + 4);
      if (v75 == 16)
      {
        if (!v67[7])
        {
          v67[7] = v53;
          goto LABEL_150;
        }
        if (*v53) {
          dns_name_print_to_limit(*v53, 0, (uint64_t)buf, 0x3F2uLL);
        }
        else {
          strcpy((char *)buf, "<null>");
        }
        uint64_t v121 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
          goto LABEL_314;
        }
        *(_DWORD *)md = 136446723;
        *(void *)&md[4] = "srp_evaluate";
        *(_WORD *)&md[12] = 2160;
        *(void *)&md[14] = 1752392040;
        *(_WORD *)&md[22] = 2081;
        *(void *)&md[24] = buf;
        int v113 = "%{public}s: more than one TXT rr received for service instance: %{private, mask.hash}s";
      }
      else
      {
        if (v75 != 33) {
          goto LABEL_150;
        }
        if (!v67[6])
        {
          v67[6] = v53;
          goto LABEL_150;
        }
        if (*v53) {
          dns_name_print_to_limit(*v53, 0, (uint64_t)buf, 0x3F2uLL);
        }
        else {
          strcpy((char *)buf, "<null>");
        }
        uint64_t v121 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
          goto LABEL_314;
        }
        *(_DWORD *)md = 136446723;
        *(void *)&md[4] = "srp_evaluate";
        *(_WORD *)&md[12] = 2160;
        *(void *)&md[14] = 1752392040;
        *(_WORD *)&md[22] = 2081;
        *(void *)&md[24] = buf;
        int v113 = "%{public}s: more than one SRV rr received for service instance: %{private, mask.hash}s";
      }
LABEL_312:
      int v114 = md;
      int v115 = v121;
      uint32_t v116 = 32;
      goto LABEL_313;
    }
LABEL_94:
    uint64_t v51 = v229;
    size_t sizea = v50;
    if (!v229)
    {
      uint64_t v60 = malloc_type_calloc(1uLL, 0x28uLL, 0x10200401C8C6399uLL);
      CFAllocatorRef v54 = (const __CFAllocator *)(v53 + 1);
      size_t v50 = sizea;
      uint64_t v51 = v60;
      if (!v60)
      {
        uint64_t v120 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          buf[0].count[0] = 136446210;
          *(void *)&buf[0].count[1] = "srp_evaluate";
          goto LABEL_245;
        }
LABEL_246:
        long long v24 = 0;
        long long v23 = v217;
        long long v22 = v218;
        uint64_t v84 = v216;
        goto LABEL_318;
      }
    }
    if (!v51[3])
    {
      CFAllocatorRef allocator = v54;
      __int16 v61 = (uint64_t *)v235;
      if (!v235)
      {
LABEL_172:
        uint64_t v234 = 0;
        uint64_t v89 = v51;
        if (*v53) {
          dns_name_print_to_limit(*v53, 0, (uint64_t)buf, 0x3F2uLL);
        }
        else {
          strcpy((char *)buf, "<null>");
        }
        uint64_t v84 = v216;
        long long v23 = v217;
        int v109 = global_os_log;
        long long v22 = v218;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)md = 136446723;
          *(void *)&md[4] = "srp_evaluate";
          *(_WORD *)&md[12] = 2160;
          *(void *)&md[14] = 1752392040;
          *(_WORD *)&md[22] = 2081;
          *(void *)&md[24] = buf;
          _os_log_impl((void *)&_mh_execute_header, v109, OS_LOG_TYPE_ERROR, "%{public}s: ADD for hostname %{private, mask.hash}s without a preceding delete.", md, 0x20u);
        }
        *((unsigned char *)v11 + 100) = 1;
        goto LABEL_223;
      }
      while ((dns_names_equal((uint64_t *)v61[1], (uint64_t **)*v53) & 1) == 0)
      {
        __int16 v61 = (uint64_t *)*v61;
        if (!v61) {
          goto LABEL_172;
        }
      }
      uint64_t v234 = v61;
      v51[3] = v61;
      *uint64_t v51 = v61[1];
      v234[24] = 1;
      long long v23 = v217;
      size_t v50 = sizea;
      CFAllocatorRef v54 = allocator;
    }
    int v76 = *(unsigned __int16 *)v54;
    if (v76 == 28 || v76 == 1)
    {
      uint64_t v78 = (char *)malloc_type_calloc(1uLL, 0x48uLL, 0x103204052D25189uLL);
      if (v78)
      {
        __int16 v79 = v51 + 1;
        size_t v50 = sizea;
        do
        {
          int v80 = v79;
          __int16 v79 = (void *)*v79;
        }
        while (v79);
        *int v80 = v78;
        long long v81 = *(_OWORD *)v53;
        long long v82 = *((_OWORD *)v53 + 1);
        long long v83 = *((_OWORD *)v53 + 2);
        *(_OWORD *)(v78 + 56) = *((_OWORD *)v53 + 3);
        *(_OWORD *)(v78 + 40) = v83;
        *(_OWORD *)(v78 + 24) = v82;
        *(_OWORD *)(v78 + 8) = v81;
        goto LABEL_151;
      }
      uint64_t v89 = v51;
      int v117 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        buf[0].count[0] = 136446210;
        *(void *)&buf[0].count[1] = "add_host_addr";
        _os_log_impl((void *)&_mh_execute_header, v117, OS_LOG_TYPE_ERROR, "%{public}s: add_host_addr: no memory for record", (uint8_t *)buf, 0xCu);
      }
      long long v23 = v217;
      long long v22 = v218;
      uint64_t v84 = v216;
LABEL_223:
      long long v24 = v89;
      goto LABEL_318;
    }
LABEL_151:
    ++v50;
    size_t v49 = *(unsigned int *)(v25 + 12);
  }
  while (v50 < v49);
  v229 = v51;
  if (v51) {
    goto LABEL_175;
  }
  if (*((_DWORD *)v11 + 22) || !v219) {
    goto LABEL_232;
  }
  uint64_t v110 = (uint64_t *)v235;
  if (!v235)
  {
LABEL_231:
    uint64_t v234 = 0;
LABEL_232:
    uint64_t v84 = v216;
    long long v23 = v217;
    goto LABEL_161;
  }
  while ((dns_names_equal((uint64_t *)v110[1], *v219) & 1) == 0)
  {
    uint64_t v110 = (uint64_t *)*v110;
    if (!v110) {
      goto LABEL_231;
    }
  }
  uint64_t v234 = v110;
  v229 = malloc_type_calloc(1uLL, 0x28uLL, 0x10200401C8C6399uLL);
  if (!v229)
  {
    uint64_t v120 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
    {
      buf[0].count[0] = 136446210;
      *(void *)&buf[0].count[1] = "srp_evaluate";
LABEL_245:
      _os_log_impl((void *)&_mh_execute_header, v120, OS_LOG_TYPE_ERROR, "%{public}s: no memory", (uint8_t *)buf, 0xCu);
    }
    goto LABEL_246;
  }
  int v126 = v234;
  v229[3] = v234;
  void *v229 = *((void *)v126 + 1);
  v126[24] = 1;
LABEL_175:
  int v90 = v231;
  if (!v231) {
    goto LABEL_182;
  }
  do
  {
    if ((uint64_t *)v90[1] != v90) {
      goto LABEL_181;
    }
    uint32_t v91 = &v232;
    do
    {
      uint32_t v91 = (void *)*v91;
      if (!v91)
      {
        int v111 = *(uint64_t **)v90[2];
        if (v111) {
          dns_name_print_to_limit(v111, 0, (uint64_t)buf, 0x3F2uLL);
        }
        else {
          strcpy((char *)buf, "<null>");
        }
        uint64_t v121 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
          goto LABEL_314;
        }
        *(_DWORD *)md = 136446723;
        *(void *)&md[4] = "srp_evaluate";
        *(_WORD *)&md[12] = 2160;
        *(void *)&md[14] = 1752392040;
        *(_WORD *)&md[22] = 2081;
        *(void *)&md[24] = buf;
        int v113 = "%{public}s: service points to an instance that's not included: %{private, mask.hash}s";
        goto LABEL_312;
      }
    }
    while (!dns_names_equal((uint64_t *)v91[2], *(uint64_t ***)(v90[2] + 16)));
    v91[4] = v90;
    ++*((_DWORD *)v91 + 10);
LABEL_181:
    int v90 = (uint64_t *)*v90;
  }
  while (v90);
LABEL_182:
  __int16 v92 = v232;
  __int16 v93 = v229;
  if (v232)
  {
    while (*((_DWORD *)v92 + 10))
    {
      if (dns_names_equal((uint64_t *)*v229, *(uint64_t ***)(v92[6] + 16)))
      {
        v92[1] = v229;
        ++*((_DWORD *)v229 + 8);
      }
      __int16 v92 = (void *)*v92;
      if (!v92) {
        goto LABEL_187;
      }
    }
    uint64_t v124 = (uint64_t *)v92[2];
    if (v124) {
      dns_name_print_to_limit(v124, 0, (uint64_t)buf, 0x3F2uLL);
    }
    else {
      strcpy((char *)buf, "<null>");
    }
    uint64_t v121 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      goto LABEL_314;
    }
    *(_DWORD *)md = 136446723;
    *(void *)&md[4] = "srp_evaluate";
    *(_WORD *)&md[12] = 2160;
    *(void *)&md[14] = 1752392040;
    *(_WORD *)&md[22] = 2081;
    *(void *)&md[24] = buf;
    int v113 = "%{public}s: service instance update for %{private, mask.hash}s is not referenced by a service update.";
    goto LABEL_312;
  }
LABEL_187:
  if (!key)
  {
LABEL_200:
    if (!v93[2])
    {
      if (*v229) {
        dns_name_print_to_limit((uint64_t *)*v229, 0, (uint64_t)buf, 0x3F2uLL);
      }
      else {
        strcpy((char *)buf, "<null>");
      }
      uint64_t v121 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
        goto LABEL_314;
      }
      *(_DWORD *)md = 136446723;
      *(void *)&md[4] = "srp_evaluate";
      *(_WORD *)&md[12] = 2160;
      *(void *)&md[14] = 1752392040;
      *(_WORD *)&md[22] = 2081;
      *(void *)&md[24] = buf;
      int v113 = "%{public}s: host description %{private, mask.hash}s doesn't contain a key.";
      goto LABEL_312;
    }
    int v99 = (uint64_t **)v235;
    if (v235)
    {
      __int16 v100 = &v235;
      sizee = (uint64_t ***)&v233;
      do
      {
        uint64_t v234 = v99;
        if (*((unsigned char *)v99 + 24))
        {
          __int16 v100 = (void **)v99;
        }
        else
        {
          uint64_t v101 = v99[1];
          if (v101) {
            dns_name_print_to_limit(v101, 0, (uint64_t)buf, 0x3F2uLL);
          }
          else {
            strcpy((char *)buf, "<null>");
          }
          __int16 v102 = global_os_log;
          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)md = 136446723;
            *(void *)&md[4] = "srp_evaluate";
            *(_WORD *)&md[12] = 2160;
            *(void *)&md[14] = 1752392040;
            *(_WORD *)&md[22] = 2081;
            *(void *)&md[24] = buf;
            _os_log_impl((void *)&_mh_execute_header, v102, OS_LOG_TYPE_DEFAULT, "%{public}s: delete for presumably previously-registered instance which is being withdrawn: %{private, mask.hash}s", md, 0x20u);
            int v99 = (uint64_t **)v234;
          }
          *sizee = v99;
          sizee = (uint64_t ***)v234;
          *__int16 v100 = *(void **)v234;
          *(void *)uint64_t v234 = 0;
        }
        int v99 = (uint64_t **)*v100;
      }
      while (*v100);
    }
    int v103 = *(_DWORD *)(v25 + 16);
    if (!v103)
    {
      uint64_t v129 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
        goto LABEL_314;
      }
      buf[0].count[0] = 136446210;
      *(void *)&buf[0].count[1] = "srp_evaluate";
      int v113 = "%{public}s: signature not present";
      goto LABEL_293;
    }
    uint64_t v104 = (v103 - 1);
    size_t sizef = *(void *)(v25 + 48);
    size_t v105 = sizef + (v104 << 6);
    if (*(_WORD *)(v105 + 8) != 24)
    {
      uint64_t v129 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
        goto LABEL_314;
      }
      buf[0].count[0] = 136446210;
      *(void *)&buf[0].count[1] = "srp_evaluate";
      int v113 = "%{public}s: signature is not at the end or is not present";
      goto LABEL_293;
    }
    size_t v106 = v105 + 16;
    if ((dns_names_equal(*(uint64_t **)(v105 + 40), (uint64_t **)*v229) & 1) == 0)
    {
      int v130 = *(uint64_t **)(v106 + 24);
      if (v130) {
        dns_name_print_to_limit(v130, 0, (uint64_t)buf, 0x3F2uLL);
      }
      else {
        strcpy((char *)buf, "<null>");
      }
      if (*v229) {
        dns_name_print_to_limit((uint64_t *)*v229, 0, (uint64_t)md, 0x3F2uLL);
      }
      else {
        strcpy(md, "<null>");
      }
      uint64_t v123 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
        goto LABEL_314;
      }
      *(_DWORD *)BOOL v241 = 136447235;
      v242 = "srp_evaluate";
      __int16 v243 = 2160;
      uint64_t v244 = 1752392040;
      __int16 v245 = 2081;
      uint64_t v246 = buf;
      __int16 v247 = 2160;
      uint64_t v248 = 1752392040;
      __int16 v249 = 2081;
      __int16 v250 = md;
      int v113 = "%{public}s: signer %{private, mask.hash}s doesn't match host %{private, mask.hash}s";
      goto LABEL_280;
    }
    if (*(_DWORD *)(v106 + 12) || *(_DWORD *)(v106 + 8))
    {
      gettimeofday(&v230, 0);
      uint64_t v107 = *(void *)(a2 + 72);
      if (v107)
      {
        *(void *)buf[0].hash = 0;
        *(void *)buf[0].size_t count = 0;
        clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)buf);
        __darwin_time_t tv_sec = v107 - *(void *)buf[0].count + v230.tv_sec;
        v230.__darwin_time_t tv_sec = tv_sec;
        v230.tv_usec = 0;
      }
      else
      {
        __darwin_time_t tv_sec = v230.tv_sec;
      }
      uint64_t v131 = *(unsigned int *)(v106 + 8);
      if (v131 < tv_sec || *(_DWORD *)(v106 + 12) > tv_sec)
      {
        uint64_t v132 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          uint64_t v133 = *(unsigned int *)(v106 + 12);
          buf[0].count[0] = 136446978;
          *(void *)&buf[0].count[1] = "srp_evaluate";
          LOWORD(buf[0].hash[1]) = 2048;
          *(void *)((char *)&buf[0].hash[1] + 2) = v133;
          HIWORD(buf[0].hash[3]) = 2048;
          *(void *)&buf[0].hash[4] = tv_sec;
          LOWORD(buf[0].hash[6]) = 2048;
          *(void *)((char *)&buf[0].hash[6] + 2) = v131;
          int v134 = "%{public}s: signature is not timely: %lu < %lu < %lu does not hold";
          uint64_t v135 = v132;
          uint32_t v136 = 42;
LABEL_390:
          _os_log_impl((void *)&_mh_execute_header, v135, OS_LOG_TYPE_ERROR, v134, (uint8_t *)buf, v136);
          goto LABEL_391;
        }
        goto LABEL_391;
      }
    }
    uint64_t v137 = v229[2];
    CFErrorRef err = 0;
    uint64_t v220 = v137;
    CC_LONG v138 = *(unsigned __int8 *)(v137 + 19);
    size_t v139 = sizef + (v104 << 6);
    CC_LONG v140 = *(unsigned __int8 *)(v139 + 18);
    dataa = (unsigned __int8 *)(v139 + 18);
    if (v138 != v140)
    {
      uint64_t v190 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
        goto LABEL_388;
      }
      buf[0].count[0] = 136446722;
      *(void *)&buf[0].count[1] = "srp_sig0_verify";
      LOWORD(buf[0].hash[1]) = 1024;
      *(CC_LONG *)((char *)&buf[0].hash[1] + 2) = v138;
      HIWORD(buf[0].hash[2]) = 1024;
      buf[0].hash[3] = v140;
      __int16 v191 = "%{public}s: KEY algorithm does not match the SIG(0) algorithm - KEY algorithm: %u, SIG(0) algorithm: %u";
      int v192 = v190;
      uint32_t v193 = 24;
      goto LABEL_419;
    }
    if (v138 == 13)
    {
      CC_LONG v141 = *(_DWORD *)(v220 + 20);
      if (v141 == 64)
      {
        size_t v142 = sizef + (v104 << 6);
        CC_LONG v145 = *(_DWORD *)(v142 + 52);
        int v144 = (unsigned int *)(v142 + 52);
        CC_LONG v143 = v145;
        if (v145 == 64)
        {
          CFErrorRef error = 0;
          UInt8 bytes = 4;
          *(void *)buf[0].size_t count = kSecAttrKeyType;
          *(void *)buf[0].hash = kSecAttrKeyClass;
          *(void *)md = kSecAttrKeyTypeECSECPrimeRandom;
          *(void *)&md[8] = kSecAttrKeyClassPublic;
          Mutable = CFDataCreateMutable(kCFAllocatorDefault, 65);
          if (Mutable)
          {
            uint64_t v147 = Mutable;
            CFDataAppendBytes(Mutable, &bytes, 1);
            CFDataAppendBytes(v147, *(const UInt8 **)(v220 + 24), *(unsigned int *)(v220 + 20));
            CFDictionaryRef v148 = CFDictionaryCreate(kCFAllocatorDefault, (const void **)buf, (const void **)md, 2, &kCFTypeDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks);
            if (v148)
            {
              CFDictionaryRef v149 = v148;
              SecKeyRef keya = SecKeyCreateWithData(v147, v148, &error);
              if (!keya)
              {
                signatureb = global_os_log;
                if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)BOOL v241 = 136446210;
                  v242 = "create_public_sec_key";
                  _os_log_impl((void *)&_mh_execute_header, signatureb, OS_LOG_TYPE_ERROR, "%{public}s: SecKeyCreateWithData failed when creating public key SecKeyRef", v241, 0xCu);
                }
              }
              CFRelease(v147);
              CFRelease(v149);
              if (error) {
                CFRelease(error);
              }
              if (keya)
              {
                CFDataRef signaturea = CFDataCreate(kCFAllocatorDefault, *(const UInt8 **)(sizef + (v104 << 6) + 56), *v144);
                if (!signaturea)
                {
                  int v198 = global_os_log;
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                  {
                    buf[0].count[0] = 136446210;
                    *(void *)&buf[0].count[1] = "srp_sig0_verify";
                    _os_log_impl((void *)&_mh_execute_header, v198, OS_LOG_TYPE_ERROR, "%{public}s: CFDataCreate failed when creating sig_to_match_cfdata", (uint8_t *)buf, 0xCu);
                  }
LABEL_387:
                  CFRelease(keya);
                  goto LABEL_388;
                }
                int v150 = *dataa;
                if (v150 != 13)
                {
                  uint64_t v199 = global_os_log;
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                  {
                    *(_DWORD *)BOOL v241 = 136446466;
                    v242 = "create_data_to_verify";
                    __int16 v243 = 1024;
                    LODWORD(v244) = v150;
                    size_t v156 = "%{public}s: Unsupported SIG(0) algorithm - SIG(0) algorithm: %u";
                    __int16 v157 = v199;
                    os_log_type_t v158 = OS_LOG_TYPE_FAULT;
                    uint32_t v200 = 18;
LABEL_429:
                    _os_log_impl((void *)&_mh_execute_header, v157, v158, v156, v241, v200);
                    goto LABEL_367;
                  }
                  goto LABEL_367;
                }
                memset(buf, 0, 104);
                CC_SHA256_Init(buf);
                size_t v151 = sizef + (v104 << 6);
                int v205 = (_DWORD *)(v151 + 48);
                CC_SHA256_Update(buf, (const void *)(a2 + (*(_DWORD *)(v151 + 48) + 11) + 100), 0x12u);
                int v154 = *(uint64_t ***)(v151 + 40);
                unint64_t v153 = (uint64_t ***)(v151 + 40);
                uint64_t v152 = v154;
                if (v154)
                {
                  size_t sizeg = 0;
                  do
                  {
                    sizeg += *((unsigned __int8 *)v152 + 8) + 1;
                    uint64_t v152 = (uint64_t **)*v152;
                  }
                  while (v152);
                  if (sizeg >= 0x101)
                  {
                    uint64_t v155 = global_os_log;
                    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                    {
                      *(_DWORD *)BOOL v241 = 136446466;
                      v242 = "create_data_to_verify";
                      __int16 v243 = 2048;
                      uint64_t v244 = sizeg;
                      size_t v156 = "%{public}s: Invalid signer name length - signer name length: %zu";
                      __int16 v157 = v155;
                      os_log_type_t v158 = OS_LOG_TYPE_FAULT;
LABEL_428:
                      uint32_t v200 = 22;
                      goto LABEL_429;
                    }
                    goto LABEL_367;
                  }
                }
                else
                {
                  size_t sizeg = 0;
                }
                datab = (char *)malloc_type_malloc(sizeg, 0xD87643A6uLL);
                if (!datab)
                {
                  uint64_t v201 = global_os_log;
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)BOOL v241 = 136446466;
                    v242 = "create_data_to_verify";
                    __int16 v243 = 2048;
                    uint64_t v244 = sizeg;
                    size_t v156 = "%{public}s: malloc failed when allocating memory - for canonical_signer_name, len: %lu";
                    __int16 v157 = v201;
                    os_log_type_t v158 = OS_LOG_TYPE_ERROR;
                    goto LABEL_428;
                  }
LABEL_367:
                  __int16 v175 = global_os_log;
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                  {
                    buf[0].count[0] = 136446210;
                    *(void *)&buf[0].count[1] = "srp_sig0_verify";
                    _os_log_impl((void *)&_mh_execute_header, v175, OS_LOG_TYPE_ERROR, "%{public}s: Failed to data_to_verify_cfdata", (uint8_t *)buf, 0xCu);
                  }
LABEL_386:
                  CFRelease(signaturea);
                  goto LABEL_387;
                }
                int v159 = *v153;
                if (v159)
                {
                  uint64_t v160 = 0;
                  size_t v161 = sizeg;
                  uint64_t v162 = datab;
                  do
                  {
                    size_t v163 = *((unsigned __int8 *)v159 + 8);
                    if (v161 <= v163) {
                      goto LABEL_363;
                    }
                    *uint64_t v162 = v163;
                    int v164 = v162 + 1;
                    memcpy(v164, (char *)v159 + 9, *((unsigned __int8 *)v159 + 8));
                    uint64_t v165 = *((unsigned __int8 *)v159 + 8);
                    uint64_t v162 = &v164[v165];
                    v161 += ~v165;
                    uint64_t v166 = v160 + v165;
                    uint64_t v160 = v166 + 1;
                    int v159 = (uint64_t **)*v159;
                  }
                  while (v159);
                  if (v166 == -1) {
                    goto LABEL_363;
                  }
                  CC_SHA256_Update(buf, datab, sizeg);
                  *(_WORD *)(a2 + 98) = bswap32((bswap32(*(unsigned __int16 *)(a2 + 98)) >> 16) - 1) >> 16;
                  CC_SHA256_Update(buf, (const void *)(a2 + 88), *v205 + 12);
                  *(_WORD *)(a2 + 98) = bswap32((bswap32(*(unsigned __int16 *)(a2 + 98)) >> 16) + 1) >> 16;
                  CC_SHA256_Final(md, buf);
                  CFDataRef v167 = CFDataCreate(kCFAllocatorDefault, md, 32);
                  if (v167)
                  {
                    CFDataRef v168 = v167;
                    free(datab);
                    CC_LONG v169 = *(unsigned __int8 *)(v220 + 19);
                    if (v169 == 13)
                    {
                      if (SecKeyVerifySignature(keya, kSecKeyAlgorithmECDSASignatureDigestRFC4754, v168, signaturea, &err))
                      {
                        CFRelease(v168);
                        CFRelease(signaturea);
                        CFRelease(keya);
                        if (!v218) {
                          goto LABEL_380;
                        }
                        for (uint64_t i = v235; ; uint64_t i = *(unsigned char **)v234)
                        {
                          uint64_t v234 = i;
                          if (!i) {
                            break;
                          }
                          replace_zone_name((void *)i + 1, *((void **)i + 2), v218);
                        }
                        for (uint64_t j = v233; ; uint64_t j = *(void *)v234)
                        {
                          uint64_t v234 = (unsigned char *)j;
                          if (!j) {
                            break;
                          }
                          replace_zone_name((void *)(j + 8), *(void **)(j + 16), v218);
                        }
                        int v178 = (uint64_t **)v231;
                        if (v231)
                        {
                          while (1)
                          {
                            replace_zone_name(v178[2], v178[3], v218);
                            uint64_t v179 = dns_name_subdomain_of((uint64_t *)v178[2][2], v217);
                            if (!v179) {
                              break;
                            }
                            replace_zone_name(v178[2] + 2, v179, v218);
                            int v178 = (uint64_t **)*v178;
                            if (!v178) {
                              goto LABEL_377;
                            }
                          }
                          uint64_t v129 = global_os_log;
                          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
                            goto LABEL_314;
                          }
                          buf[0].count[0] = 136446210;
                          *(void *)&buf[0].count[1] = "srp_evaluate";
                          int v113 = "%{public}s: service PTR record zone match fail!!";
                          goto LABEL_293;
                        }
LABEL_377:
                        uint64_t v180 = v232;
                        if (!v232)
                        {
LABEL_380:
                          if (*v229) {
                            dns_name_print_to_limit((uint64_t *)*v229, 0, (uint64_t)v240, 0x3F2uLL);
                          }
                          else {
                            strcpy(v240, "<null>");
                          }
                          if (*(void *)(a2 + 72))
                          {
                            *(void *)buf[0].hash = 0;
                            *(void *)buf[0].size_t count = 0;
                            clock_gettime(_CLOCK_MONOTONIC_RAW, (timespec *)buf);
                            srp_format_time_offset((char *)v239, *(void *)buf[0].count - *(void *)(a2 + 72));
                          }
                          else
                          {
                            v239[0] = 0x74657320746F6ELL;
                          }
                          int v185 = global_os_log;
                          if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
                          {
                            CC_LONG v186 = *(unsigned __int16 *)(a2 + 88);
                            CC_LONG v188 = *((_DWORD *)v11 + 22);
                            CC_LONG v187 = *((_DWORD *)v11 + 23);
                            CC_LONG v189 = *(_DWORD *)(a2 + 80);
                            buf[0].count[0] = 136449027;
                            *(void *)&buf[0].count[1] = "srp_evaluate";
                            LOWORD(buf[0].hash[1]) = 2160;
                            *(void *)((char *)&buf[0].hash[1] + 2) = 1752392040;
                            HIWORD(buf[0].hash[3]) = 2081;
                            *(void *)&buf[0].hash[4] = v240;
                            LOWORD(buf[0].hash[6]) = 1024;
                            *(CC_LONG *)((char *)&buf[0].hash[6] + 2) = 0;
                            HIWORD(buf[0].hash[7]) = 1024;
                            buf[0].wbuf[0] = v186;
                            LOWORD(buf[0].wbuf[1]) = 1024;
                            *(CC_LONG *)((char *)&buf[0].wbuf[1] + 2) = v187;
                            HIWORD(buf[0].wbuf[2]) = 1024;
                            buf[0].wbuf[3] = v188;
                            LOWORD(buf[0].wbuf[4]) = 1024;
                            *(CC_LONG *)((char *)&buf[0].wbuf[4] + 2) = v189;
                            HIWORD(buf[0].wbuf[5]) = 2082;
                            *(void *)&buf[0].wbuf[6] = v239;
                            LOWORD(buf[0].wbuf[8]) = 2160;
                            *(void *)((char *)&buf[0].wbuf[8] + 2) = 1752392040;
                            HIWORD(buf[0].wbuf[10]) = 2081;
                            *(void *)&buf[0].wbuf[11] = "(none)";
                            LOWORD(buf[0].wbuf[13]) = 2048;
                            *(void *)((char *)&buf[0].wbuf[13] + 2) = v11;
                            _os_log_impl((void *)&_mh_execute_header, v185, OS_LOG_TYPE_DEFAULT, "%{public}s: update for %{private, mask.hash}s #%d, xid %x validates, key lease %d, host lease %d, message lease %d, receive_time %{public}s, remote %{private, mask.hash}s -> %p.", (uint8_t *)buf, 0x66u);
                          }
                          *((unsigned char *)v11 + 100) = 0;
                          goto LABEL_315;
                        }
                        while (1)
                        {
                          uint64_t v181 = dns_name_subdomain_of(*(uint64_t **)(v180[6] + 16), v217);
                          if (!v181) {
                            break;
                          }
                          replace_zone_name((void *)(v180[6] + 16), v181, v218);
                          uint64_t v180 = (void *)*v180;
                          if (!v180) {
                            goto LABEL_380;
                          }
                        }
                        uint64_t v129 = global_os_log;
                        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
                          goto LABEL_314;
                        }
                        buf[0].count[0] = 136446210;
                        *(void *)&buf[0].count[1] = "srp_evaluate";
                        int v113 = "%{public}s: service instance SRV record zone match fail!!";
LABEL_293:
                        int v114 = (uint8_t *)buf;
                        int v115 = v129;
                        uint32_t v116 = 12;
                        goto LABEL_313;
                      }
                      CFStringRef v182 = CFErrorCopyDescription(err);
                      CFStringGetCString(v182, (char *)buf, 200, 0x8000100u);
                      uint64_t v183 = global_os_log;
                      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)md = 136446466;
                        *(void *)&md[4] = "srp_sig0_verify";
                        *(_WORD *)&md[12] = 2080;
                        *(void *)&md[14] = buf;
                        _os_log_impl((void *)&_mh_execute_header, v183, OS_LOG_TYPE_ERROR, "%{public}s: SecKeyVerifySignature failed to validate - Error Description: %s", md, 0x16u);
                      }
                      CFRelease(v182);
                      CFRelease(err);
                      CFErrorRef err = 0;
                    }
                    else
                    {
                      int v176 = global_os_log;
                      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_FAULT))
                      {
                        buf[0].count[0] = 136446466;
                        *(void *)&buf[0].count[1] = "srp_sig0_verify";
                        LOWORD(buf[0].hash[1]) = 1024;
                        *(CC_LONG *)((char *)&buf[0].hash[1] + 2) = v169;
                        _os_log_impl((void *)&_mh_execute_header, v176, OS_LOG_TYPE_FAULT, "%{public}s: Unsupported KEY algorithm - KEY algorithm: %u", (uint8_t *)buf, 0x12u);
                      }
                    }
                    CFRelease(v168);
                    goto LABEL_386;
                  }
                  uint64_t v202 = global_os_log;
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)BOOL v241 = 136446210;
                    v242 = "create_data_to_verify";
                    int v172 = "%{public}s: CFDataCreate failed when creating data_to_verify_cfdata";
                    int v173 = v202;
                    uint32_t v174 = 12;
                    goto LABEL_365;
                  }
                }
                else
                {
LABEL_363:
                  uint64_t v171 = global_os_log;
                  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)BOOL v241 = 136446466;
                    v242 = "create_data_to_verify";
                    __int16 v243 = 2048;
                    uint64_t v244 = sizeg;
                    int v172 = "%{public}s: Failed to write canonical name - canonical_signer_name_length: %lu";
                    int v173 = v171;
                    uint32_t v174 = 22;
LABEL_365:
                    _os_log_impl((void *)&_mh_execute_header, v173, OS_LOG_TYPE_ERROR, v172, v241, v174);
                  }
                }
                free(datab);
                goto LABEL_367;
              }
            }
            else
            {
              int v196 = global_os_log;
              if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)BOOL v241 = 136446210;
                v242 = "create_public_sec_key";
                _os_log_impl((void *)&_mh_execute_header, v196, OS_LOG_TYPE_ERROR, "%{public}s: CFDictionaryCreate failed when creating public key options CFDictionaryRef", v241, 0xCu);
              }
              CFRelease(v147);
            }
          }
          else
          {
            int v195 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)BOOL v241 = 136446210;
              v242 = "create_public_sec_key";
              _os_log_impl((void *)&_mh_execute_header, v195, OS_LOG_TYPE_ERROR, "%{public}s: CFDataCreateMutable failed when creating public key CFMutableDataRef", v241, 0xCu);
            }
          }
          uint64_t v197 = global_os_log;
          if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
          {
LABEL_388:
            uint64_t v184 = global_os_log;
            if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
            {
              buf[0].count[0] = 136446210;
              *(void *)&buf[0].count[1] = "srp_evaluate";
              int v134 = "%{public}s: signature is not valid";
              uint64_t v135 = v184;
              uint32_t v136 = 12;
              goto LABEL_390;
            }
LABEL_391:
            *((unsigned char *)v11 + 102) = 1;
            goto LABEL_315;
          }
          buf[0].count[0] = 136446210;
          *(void *)&buf[0].count[1] = "srp_sig0_verify";
          __int16 v191 = "%{public}s: Failed to create public_key";
          int v192 = v197;
          uint32_t v193 = 12;
LABEL_419:
          _os_log_impl((void *)&_mh_execute_header, v192, OS_LOG_TYPE_ERROR, v191, (uint8_t *)buf, v193);
          goto LABEL_388;
        }
        uint64_t v194 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
          goto LABEL_388;
        }
        buf[0].count[0] = 136446466;
        *(void *)&buf[0].count[1] = "srp_sig0_verify";
        LOWORD(buf[0].hash[1]) = 1024;
        *(CC_LONG *)((char *)&buf[0].hash[1] + 2) = v143;
        __int16 v191 = "%{public}s: Invalid SIG(0) length - SIG(0) length: %d";
      }
      else
      {
        uint64_t v194 = global_os_log;
        if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
          goto LABEL_388;
        }
        buf[0].count[0] = 136446466;
        *(void *)&buf[0].count[1] = "srp_sig0_verify";
        LOWORD(buf[0].hash[1]) = 1024;
        *(CC_LONG *)((char *)&buf[0].hash[1] + 2) = v141;
        __int16 v191 = "%{public}s: Invalid KEY length - KEY len: %d";
      }
    }
    else
    {
      uint64_t v194 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
        goto LABEL_388;
      }
      buf[0].count[0] = 136446466;
      *(void *)&buf[0].count[1] = "srp_sig0_verify";
      LOWORD(buf[0].hash[1]) = 1024;
      *(CC_LONG *)((char *)&buf[0].hash[1] + 2) = v138;
      __int16 v191 = "%{public}s: Unsupported KEY algorithm - KEY algorithm: %u";
    }
    int v192 = v194;
    uint32_t v193 = 18;
    goto LABEL_419;
  }
  uint64_t v94 = 0;
  char v95 = 0;
  while (1)
  {
    if (v94)
    {
      uint64_t v96 = v216[v94];
      BOOL v97 = dns_keys_rdata_equal((uint64_t)v219, v96);
      uint64_t v219 = (uint64_t ***)v96;
      if (!v97)
      {
        int v128 = global_os_log;
        if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
        {
          buf[0].count[0] = 136446210;
          *(void *)&buf[0].count[1] = "srp_evaluate";
          _os_log_impl((void *)&_mh_execute_header, v128, OS_LOG_TYPE_ERROR, "%{public}s: more than one key presented", (uint8_t *)buf, 0xCu);
        }
        *((unsigned char *)v11 + 100) = 1;
        long long v23 = v217;
        long long v22 = v218;
        uint64_t v84 = v216;
        long long v24 = v229;
        goto LABEL_319;
      }
    }
    char sized = v95;
    __int16 v93 = v229;
    if (v229[2] || !dns_names_equal((uint64_t *)*v219, (uint64_t **)*v229)) {
      break;
    }
    v229[2] = v219;
LABEL_199:
    ++v94;
    char v95 = 1;
    if (v94 == key) {
      goto LABEL_200;
    }
  }
  __int16 v98 = &v232;
  while (1)
  {
    __int16 v98 = (void *)*v98;
    if (!v98) {
      break;
    }
    if (dns_names_equal((uint64_t *)v98[2], *v219)) {
      goto LABEL_199;
    }
  }
  if (sized) {
    goto LABEL_199;
  }
  if (*v219) {
    dns_name_print_to_limit((uint64_t *)*v219, 0, (uint64_t)buf, 0x3F2uLL);
  }
  else {
    strcpy((char *)buf, "<null>");
  }
  uint64_t v121 = global_os_log;
  if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)md = 136446723;
    *(void *)&md[4] = "srp_evaluate";
    *(_WORD *)&md[12] = 2160;
    *(void *)&md[14] = 1752392040;
    *(_WORD *)&md[22] = 2081;
    *(void *)&md[24] = buf;
    int v113 = "%{public}s: key present for name %{private, mask.hash}s which is neither a host nor an instance name.";
    goto LABEL_312;
  }
LABEL_314:
  *((unsigned char *)v11 + 100) = 1;
LABEL_315:
  long long v23 = v217;
LABEL_316:
  long long v22 = v218;
  uint64_t v84 = v216;
LABEL_317:
  long long v24 = v229;
LABEL_318:
  if (v84) {
LABEL_319:
  }
    free(v84);
LABEL_52:
  long long v37 = (void **)v235;
  uint64_t v234 = v235;
  if (v235)
  {
    do
    {
      long long v38 = *v37;
      free(v37);
      uint64_t v234 = v38;
      long long v37 = (void **)v38;
    }
    while (v38);
  }
  long long v39 = v232;
  uint64_t v40 = v233;
  v11[5] = (uint64_t)v24;
  v11[6] = (uint64_t)v39;
  v11[7] = (uint64_t)v231;
  v11[8] = v40;
  if (v22) {
    long long v41 = (uint64_t **)v22;
  }
  else {
    long long v41 = v23;
  }
  v11[9] = (uint64_t)v41;
  unsigned int v42 = *((unsigned __int8 *)v11 + 100);
  if (*((unsigned char *)v11 + 100)) {
    goto LABEL_66;
  }
  v11[1] = a1;
  ioloop_comm_retain_(a1, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/srp-parse.c", 917);
  v11[10] = a3;

  srp_update_start();
}

void *srp_proxy_init()
{
  uint64_t v0 = (void *)service_update_zone;
  if (service_update_zone)
  {
    do
    {
      uint64_t v1 = (void *)*v0;
      free(v0);
      uint64_t v0 = v1;
    }
    while (v1);
  }
  uint64_t result = dns_pres_name_parse("local");
  service_update_zone = (uint64_t)result;
  return result;
}

void ioloop_udp_read_callback(uint64_t a1, uint64_t a2)
{
  memset(v48, 0, 28);
  *(&v47.msg_iovlen + 1) = 0;
  *(&v47.msg_namelen + 1) = 0;
  v46[0] = __src;
  v46[1] = 1410;
  v47.msg_iov = (iovec *)v46;
  v47.msg_iovlen = 1;
  v47.msg_name = v48;
  v47.msg_namelen = 28;
  v47.msg_control = &v91;
  v47.msg_flags = 0;
  v47.msg_controllen = 128;
  ssize_t v3 = recvmsg(*(_DWORD *)(a1 + 92), &v47, 0);
  if (v3 < 0)
  {
    uint64_t v8 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    uint64_t v10 = __error();
    uint64_t v11 = strerror(*v10);
    *(_DWORD *)int buf = 136446466;
    size_t v50 = "ioloop_udp_read_callback";
    __int16 v51 = 2080;
    size_t v52 = (size_t)v11;
    uint64_t v9 = "%{public}s: %s";
    goto LABEL_8;
  }
  size_t v4 = v3;
  BOOL v5 = ioloop_message_create_(v3, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/ioloop.c", 604);
  if (!v5)
  {
    uint64_t v14 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)int buf = 136446210;
    size_t v50 = "ioloop_udp_read_callback";
    uint64_t v9 = "%{public}s: out of memory";
    long long v12 = v14;
    uint32_t v13 = 12;
    goto LABEL_11;
  }
  uint64_t v6 = v5;
  long long v7 = v48[0];
  v5[1] = *(_OWORD *)((char *)v48 + 12);
  *(_OWORD *)((char *)v5 + 4) = v7;
  if (v4 >= 0x10000)
  {
    uint64_t v8 = global_os_log;
    if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR)) {
      return;
    }
    *(_DWORD *)int buf = 136446466;
    size_t v50 = "ioloop_udp_read_callback";
    __int16 v51 = 2048;
    size_t v52 = v4;
    uint64_t v9 = "%{public}s: message is surprisingly large: %zd";
LABEL_8:
    long long v12 = v8;
    uint32_t v13 = 22;
LABEL_11:
    _os_log_impl((void *)&_mh_execute_header, v12, OS_LOG_TYPE_ERROR, v9, buf, v13);
    return;
  }
  *((_WORD *)v5 + 32) = v4;
  memcpy((char *)v5 + 88, __src, v4);
  int v15 = 0;
  if (v47.msg_controllen >= 0xC)
  {
    msg_control = (unsigned int *)v47.msg_control;
    if (v47.msg_control)
    {
      LOBYTE(v15) = 0;
      do
      {
        memset(v45, 0, 28);
        uint64_t v41 = 0;
        uint64_t v42 = 0;
        int v44 = 0;
        uint64_t v43 = 0;
        unsigned int v17 = msg_control[1];
        if (v17)
        {
          if (v17 == 41 && msg_control[2] == 46)
          {
            long long v18 = *(_OWORD *)(msg_control + 3);
            *((_DWORD *)v6 + 15) = msg_control[7];
            *((unsigned char *)v6 + 33) = 30;
            *((_WORD *)v6 + 17) = bswap32(*(unsigned __int16 *)(a2 + 160)) >> 16;
            *(_OWORD *)((char *)v6 + 40) = v18;
            *((unsigned char *)v6 + 32) = 28;
LABEL_22:
            if (*((void *)&v48[0] + 1) || LOWORD(v48[1]) || WORD1(v48[1]) != 0xFFFF)
            {
              v45[0] = v48[0];
              *(_OWORD *)((char *)v45 + 12) = *(_OWORD *)((char *)v48 + 12);
              int v20 = BYTE1(v48[0]);
            }
            else
            {
              int v20 = 2;
              BYTE1(v45[0]) = 2;
              DWORD1(v45[0]) = DWORD1(v48[1]);
              WORD1(v45[0]) = WORD1(v48[0]);
            }
            ioloop_normalize_address((uint64_t)&v41, v6 + 2);
            uint64_t v21 = global_os_log;
            BOOL v22 = os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT);
            if (v20 == 30)
            {
              if (v22)
              {
                long long v23 = "ULA: ";
                if ((v42 & 0xFE) != 0xFC)
                {
                  if (v42 != 254 || (long long v23 = "LUA: ", (BYTE1(v42) & 0xC0) != 0x80))
                  {
                    long long v23 = "";
                    if ((v42 & 0xE0) == 0x20) {
                      long long v23 = "GUA: ";
                    }
                  }
                }
                long long v24 = "ULA: ";
                if ((BYTE8(v45[0]) & 0xFE) != 0xFC)
                {
                  if (BYTE8(v45[0]) != 254 || (long long v24 = "LUA: ", (BYTE9(v45[0]) & 0xC0) != 0x80))
                  {
                    long long v24 = "";
                    if ((BYTE8(v45[0]) & 0xE0) == 0x20) {
                      long long v24 = "GUA: ";
                    }
                  }
                }
                int v25 = *((_DWORD *)v6 + 15);
                *(_DWORD *)int buf = 136452355;
                size_t v50 = "ioloop_udp_read_callback";
                __int16 v51 = 2048;
                size_t v52 = v4;
                __int16 v53 = 1024;
                int v54 = v25;
                __int16 v55 = 2082;
                uint64_t v56 = (uint64_t)v23;
                __int16 v57 = 2160;
                *(void *)int v58 = 1752392040;
                *(_WORD *)&v58[8] = 1041;
                *(_DWORD *)&unsigned char v58[10] = 6;
                __int16 v59 = 2097;
                *(void *)uint64_t v60 = &v42;
                *(_WORD *)&v60[8] = 2160;
                *(void *)&v60[10] = 1752392040;
                *(_WORD *)&v60[18] = 1042;
                LODWORD(v61) = 2;
                WORD2(v61) = 2098;
                *(void *)((char *)&v61 + 6) = (char *)&v42 + 6;
                HIWORD(v61) = 2160;
                uint64_t v62 = 1752392040;
                __int16 v63 = 1041;
                int v64 = 8;
                __int16 v65 = 2097;
                uint64_t v66 = &v43;
                __int16 v67 = 1024;
                unsigned int v68 = bswap32(WORD1(v41)) >> 16;
                __int16 v69 = 2082;
                uint64_t v70 = v24;
                __int16 v71 = 2160;
                uint64_t v72 = 1752392040;
                __int16 v73 = 1041;
                int v74 = 6;
                __int16 v75 = 2097;
                int v76 = (char *)v45 + 8;
                __int16 v77 = 2160;
                uint64_t v78 = 1752392040;
                __int16 v79 = 1042;
                int v80 = 2;
                __int16 v81 = 2098;
                long long v82 = (char *)v45 + 14;
                __int16 v83 = 2160;
                uint64_t v84 = 1752392040;
                __int16 v85 = 1041;
                int v86 = 8;
                __int16 v87 = 2097;
                uint64_t v88 = &v45[1];
                __int16 v89 = 1024;
                unsigned int v90 = bswap32(WORD1(v45[0])) >> 16;
                long long v26 = v21;
                char v27 = "%{public}s: received %zd byte UDP message on index %d to {%{public}s%{private, mask.hash, srp:in6_"
                      "addr_segment}.6P:%{public, mask.hash, srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_"
                      "segment}.8P}#%d from {%{public}s%{private, mask.hash, srp:in6_addr_segment}.6P:%{public, mask.hash"
                      ", srp:in6_addr_segment}.2P:%{private, mask.hash, srp:in6_addr_segment}.8P}#%d";
                uint32_t v28 = 216;
LABEL_43:
                _os_log_impl((void *)&_mh_execute_header, v26, OS_LOG_TYPE_DEFAULT, v27, buf, v28);
              }
            }
            else if (v22)
            {
              int v29 = *((_DWORD *)v6 + 15);
              *(_DWORD *)int buf = 136448771;
              size_t v50 = "ioloop_udp_read_callback";
              __int16 v51 = 2048;
              size_t v52 = v4;
              __int16 v53 = 1024;
              int v54 = v29;
              __int16 v55 = 2160;
              uint64_t v56 = 1752392040;
              __int16 v57 = 1041;
              *(_DWORD *)int v58 = 4;
              *(_WORD *)&v58[4] = 2097;
              *(void *)&v58[6] = (char *)&v41 + 4;
              __int16 v59 = 1024;
              *(_DWORD *)uint64_t v60 = bswap32(WORD1(v41)) >> 16;
              *(_WORD *)&v60[4] = 2160;
              *(void *)&v60[6] = 1752392040;
              *(_WORD *)&v60[14] = 1041;
              *(_DWORD *)&v60[16] = 4;
              LOWORD(v61) = 2097;
              *(void *)((char *)&v61 + 2) = (char *)&v41 + 4;
              WORD5(v61) = 1024;
              HIDWORD(v61) = bswap32(WORD1(v45[0])) >> 16;
              long long v26 = v21;
              char v27 = "%{public}s: received %zd byte UDP message on index %d to %{private, mask.hash, network:in_addr}.4P#%"
                    "d from %{private, mask.hash, network:in_addr}.4P#%d";
              uint32_t v28 = 92;
              goto LABEL_43;
            }
            int v15 = 1;
            goto LABEL_45;
          }
        }
        else if (msg_control[2] == 26)
        {
          unsigned int v19 = msg_control[5];
          *((_DWORD *)v6 + 15) = msg_control[3];
          *((_DWORD *)v6 + 9) = v19;
          *((_WORD *)v6 + 16) = 540;
          *((_WORD *)v6 + 17) = bswap32(*(unsigned __int16 *)(a2 + 160)) >> 16;
          goto LABEL_22;
        }
        if (v15) {
          goto LABEL_22;
        }
        int v15 = 0;
LABEL_45:
        msg_control = (unsigned int *)((char *)msg_control + ((*msg_control + 3) & 0x1FFFFFFFCLL));
      }
      while ((char *)(msg_control + 3) <= (char *)v47.msg_control + v47.msg_controllen && msg_control != 0);
    }
  }
  unint64_t v31 = *(void *)(a2 + 408);
  if (v31)
  {
    int v32 = *((_DWORD *)v6 + 15);
    if (v32)
    {
      if (v31 >= 2)
      {
        unint64_t v39 = v31 + 8;
        while (1)
        {
          unint64_t v39 = *(void *)v39;
          if (!v39) {
            break;
          }
          if (*(_DWORD *)(v39 + 16) == v32) {
            goto LABEL_60;
          }
        }
      }
      uint64_t v33 = global_os_log;
      if (!os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_66;
      }
      *(_DWORD *)int buf = 136446466;
      size_t v50 = "ioloop_udp_read_callback";
      __int16 v51 = 1024;
      LODWORD(v52) = v32;
      long long v34 = "%{public}s: dropping message because it arrived on interface index %d which is not permitted";
      long long v35 = v33;
      os_log_type_t v36 = OS_LOG_TYPE_DEFAULT;
      uint32_t v37 = 18;
      goto LABEL_65;
    }
    uint64_t v38 = global_os_log;
    if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136446210;
      size_t v50 = "ioloop_udp_read_callback";
      long long v34 = "%{public}s: dropping message because we didn't receive an interface index";
      long long v35 = v38;
      os_log_type_t v36 = OS_LOG_TYPE_DEFAULT;
LABEL_64:
      uint32_t v37 = 12;
LABEL_65:
      _os_log_impl((void *)&_mh_execute_header, v35, v36, v34, buf, v37);
    }
  }
  else
  {
LABEL_60:
    if (v15)
    {
      (*(void (**)(uint64_t, _OWORD *, void))(a2 + 208))(a2, v6, *(void *)(a2 + 200));
    }
    else
    {
      uint64_t v40 = global_os_log;
      if (os_log_type_enabled((os_log_t)global_os_log, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446210;
        size_t v50 = "ioloop_udp_read_callback";
        long long v34 = "%{public}s: dropping incoming packet because we didn't get a destination address.";
        long long v35 = v40;
        os_log_type_t v36 = OS_LOG_TYPE_ERROR;
        goto LABEL_64;
      }
    }
  }
LABEL_66:
  ioloop_message_release_((int *)v6, "/Library/Caches/com.apple.xbs/Sources/mDNSResponderExtras/ServiceRegistration/ioloop.c", 699);
}

uint64_t ioloop_normalize_address(uint64_t result, long long *a2)
{
  if (*((_WORD *)a2 + 4)
    || *((_WORD *)a2 + 5)
    || *((_WORD *)a2 + 6)
    || *((_WORD *)a2 + 7)
    || *((_WORD *)a2 + 8)
    || *((__int16 *)a2 + 9) != -1)
  {
    long long v2 = *a2;
    *(_OWORD *)(result + 12) = *(long long *)((char *)a2 + 12);
    *(_OWORD *)uint64_t result = v2;
  }
  else
  {
    *(unsigned char *)(result + 1) = 2;
    *(_DWORD *)(result + 4) = *((_DWORD *)a2 + 5);
    *(_WORD *)(result + 2) = *((_WORD *)a2 + 1);
  }
  return result;
}

int CC_SHA256_Final(unsigned __int8 *md, CC_SHA256_CTX *c)
{
  return _CC_SHA256_Final(md, c);
}

int CC_SHA256_Init(CC_SHA256_CTX *c)
{
  return _CC_SHA256_Init(c);
}

int CC_SHA256_Update(CC_SHA256_CTX *c, const void *data, CC_LONG len)
{
  return _CC_SHA256_Update(c, data, len);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  return _CFAbsoluteTimeGetCurrent();
}

void CFArrayAppendArray(CFMutableArrayRef theArray, CFArrayRef otherArray, CFRange otherRange)
{
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
}

Boolean CFArrayContainsValue(CFArrayRef theArray, CFRange range, const void *value)
{
  return _CFArrayContainsValue(theArray, range, value);
}

CFArrayRef CFArrayCreate(CFAllocatorRef allocator, const void **values, CFIndex numValues, const CFArrayCallBacks *callBacks)
{
  return _CFArrayCreate(allocator, values, numValues, callBacks);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return _CFArrayCreateMutable(allocator, capacity, callBacks);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return _CFArrayGetCount(theArray);
}

CFTypeID CFArrayGetTypeID(void)
{
  return _CFArrayGetTypeID();
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return _CFArrayGetValueAtIndex(theArray, idx);
}

void CFDataAppendBytes(CFMutableDataRef theData, const UInt8 *bytes, CFIndex length)
{
}

CFDataRef CFDataCreate(CFAllocatorRef allocator, const UInt8 *bytes, CFIndex length)
{
  return _CFDataCreate(allocator, bytes, length);
}

CFMutableDataRef CFDataCreateMutable(CFAllocatorRef allocator, CFIndex capacity)
{
  return _CFDataCreateMutable(allocator, capacity);
}

CFDateRef CFDateCreate(CFAllocatorRef allocator, CFAbsoluteTime at)
{
  return _CFDateCreate(allocator, at);
}

CFDateFormatterRef CFDateFormatterCreate(CFAllocatorRef allocator, CFLocaleRef locale, CFDateFormatterStyle dateStyle, CFDateFormatterStyle timeStyle)
{
  return _CFDateFormatterCreate(allocator, locale, dateStyle, timeStyle);
}

CFStringRef CFDateFormatterCreateStringWithDate(CFAllocatorRef allocator, CFDateFormatterRef formatter, CFDateRef date)
{
  return _CFDateFormatterCreateStringWithDate(allocator, formatter, date);
}

CFAbsoluteTime CFDateGetAbsoluteTime(CFDateRef theDate)
{
  return _CFDateGetAbsoluteTime(theDate);
}

CFTimeInterval CFDateGetTimeIntervalSinceDate(CFDateRef theDate, CFDateRef otherDate)
{
  return _CFDateGetTimeIntervalSinceDate(theDate, otherDate);
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return _CFDictionaryCreate(allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return _CFDictionaryCreateMutable(allocator, capacity, keyCallBacks, valueCallBacks);
}

CFTypeID CFDictionaryGetTypeID(void)
{
  return _CFDictionaryGetTypeID();
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return _CFDictionaryGetValue(theDict, key);
}

void CFDictionaryRemoveValue(CFMutableDictionaryRef theDict, const void *key)
{
}

void CFDictionaryReplaceValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
}

CFStringRef CFErrorCopyDescription(CFErrorRef err)
{
  return _CFErrorCopyDescription(err);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return _CFGetTypeID(cf);
}

uint64_t CFPropertyListCreateFormatted()
{
  return _CFPropertyListCreateFormatted();
}

void CFRelease(CFTypeRef cf)
{
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return _CFRetain(cf);
}

void CFStringAppend(CFMutableStringRef theString, CFStringRef appendedString)
{
}

CFComparisonResult CFStringCompare(CFStringRef theString1, CFStringRef theString2, CFStringCompareFlags compareOptions)
{
  return _CFStringCompare(theString1, theString2, compareOptions);
}

uint64_t CFStringCreateF()
{
  return _CFStringCreateF();
}

CFMutableStringRef CFStringCreateMutable(CFAllocatorRef alloc, CFIndex maxLength)
{
  return _CFStringCreateMutable(alloc, maxLength);
}

CFMutableStringRef CFStringCreateMutableCopy(CFAllocatorRef alloc, CFIndex maxLength, CFStringRef theString)
{
  return _CFStringCreateMutableCopy(alloc, maxLength, theString);
}

Boolean CFStringGetCString(CFStringRef theString, char *buffer, CFIndex bufferSize, CFStringEncoding encoding)
{
  return _CFStringGetCString(theString, buffer, bufferSize, encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return _CFStringGetCStringPtr(theString, encoding);
}

Boolean CFStringHasPrefix(CFStringRef theString, CFStringRef prefix)
{
  return _CFStringHasPrefix(theString, prefix);
}

void CFStringInsert(CFMutableStringRef str, CFIndex idx, CFStringRef insertedStr)
{
}

void CFStringTrim(CFMutableStringRef theString, CFStringRef trimString)
{
}

CFUUIDRef CFUUIDCreate(CFAllocatorRef alloc)
{
  return _CFUUIDCreate(alloc);
}

CFStringRef CFUUIDCreateString(CFAllocatorRef alloc, CFUUIDRef uuid)
{
  return _CFUUIDCreateString(alloc, uuid);
}

CFStringRef SCDynamicStoreCopyLocalHostName(SCDynamicStoreRef store)
{
  return _SCDynamicStoreCopyLocalHostName(store);
}

SCDynamicStoreRef SCDynamicStoreCreate(CFAllocatorRef allocator, CFStringRef name, SCDynamicStoreCallBack callout, SCDynamicStoreContext *context)
{
  return _SCDynamicStoreCreate(allocator, name, callout, context);
}

CFStringRef SCDynamicStoreKeyCreateHostNames(CFAllocatorRef allocator)
{
  return _SCDynamicStoreKeyCreateHostNames(allocator);
}

Boolean SCDynamicStoreSetDispatchQueue(SCDynamicStoreRef store, dispatch_queue_t queue)
{
  return _SCDynamicStoreSetDispatchQueue(store, queue);
}

Boolean SCDynamicStoreSetNotificationKeys(SCDynamicStoreRef store, CFArrayRef keys, CFArrayRef patterns)
{
  return _SCDynamicStoreSetNotificationKeys(store, keys, patterns);
}

uint64_t SecGenerateSelfSignedCertificate()
{
  return _SecGenerateSelfSignedCertificate();
}

OSStatus SecIdentityCopyCertificate(SecIdentityRef identityRef, SecCertificateRef *certificateRef)
{
  return _SecIdentityCopyCertificate(identityRef, certificateRef);
}

OSStatus SecIdentityCopyPrivateKey(SecIdentityRef identityRef, SecKeyRef *privateKeyRef)
{
  return _SecIdentityCopyPrivateKey(identityRef, privateKeyRef);
}

uint64_t SecIdentityCreate()
{
  return _SecIdentityCreate();
}

OSStatus SecItemAdd(CFDictionaryRef attributes, CFTypeRef *result)
{
  return _SecItemAdd(attributes, result);
}

OSStatus SecItemCopyMatching(CFDictionaryRef query, CFTypeRef *result)
{
  return _SecItemCopyMatching(query, result);
}

OSStatus SecItemDelete(CFDictionaryRef query)
{
  return _SecItemDelete(query);
}

SecKeyRef SecKeyCreateRandomKey(CFDictionaryRef parameters, CFErrorRef *error)
{
  return _SecKeyCreateRandomKey(parameters, error);
}

SecKeyRef SecKeyCreateWithData(CFDataRef keyData, CFDictionaryRef attributes, CFErrorRef *error)
{
  return _SecKeyCreateWithData(keyData, attributes, error);
}

Boolean SecKeyVerifySignature(SecKeyRef key, SecKeyAlgorithm algorithm, CFDataRef signedData, CFDataRef signature, CFErrorRef *error)
{
  return _SecKeyVerifySignature(key, algorithm, signedData, signature, error);
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
}

int __darwin_check_fd_set_overflow(int a1, const void *a2, int a3)
{
  return ___darwin_check_fd_set_overflow(a1, a2, a3);
}

int *__error(void)
{
  return ___error();
}

int __maskrune(__darwin_ct_rune_t a1, unint64_t a2)
{
  return ___maskrune(a1, a2);
}

uint64_t __memcpy_chk()
{
  return ___memcpy_chk();
}

__darwin_ct_rune_t __tolower(__darwin_ct_rune_t a1)
{
  return ___tolower(a1);
}

uint64_t _availability_version_check()
{
  return __availability_version_check();
}

uint64_t _os_feature_enabled_impl()
{
  return __os_feature_enabled_impl();
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_fault_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
}

void abort(void)
{
}

uint32_t arc4random(void)
{
  return _arc4random();
}

void arc4random_buf(void *__buf, size_t __nbytes)
{
}

uint32_t arc4random_uniform(uint32_t __upper_bound)
{
  return _arc4random_uniform(__upper_bound);
}

int asprintf(char **a1, const char *a2, ...)
{
  return _asprintf(a1, a2);
}

int bind(int a1, const sockaddr *a2, socklen_t a3)
{
  return _bind(a1, a2, a3);
}

void bzero(void *a1, size_t a2)
{
}

int clock_gettime(clockid_t __clock_id, timespec *__tp)
{
  return _clock_gettime(__clock_id, __tp);
}

int close(int a1)
{
  return _close(a1);
}

int closedir(DIR *a1)
{
  return _closedir(a1);
}

int connect(int a1, const sockaddr *a2, socklen_t a3)
{
  return _connect(a1, a2, a3);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
}

BOOL dispatch_data_apply(dispatch_data_t data, dispatch_data_applier_t applier)
{
  return _dispatch_data_apply(data, applier);
}

dispatch_data_t dispatch_data_create(const void *buffer, size_t size, dispatch_queue_t queue, dispatch_block_t destructor)
{
  return _dispatch_data_create(buffer, size, queue, destructor);
}

dispatch_data_t dispatch_data_create_concat(dispatch_data_t data1, dispatch_data_t data2)
{
  return _dispatch_data_create_concat(data1, data2);
}

dispatch_data_t dispatch_data_create_map(dispatch_data_t data, const void **buffer_ptr, size_t *size_ptr)
{
  return _dispatch_data_create_map(data, buffer_ptr, size_ptr);
}

size_t dispatch_data_get_size(dispatch_data_t data)
{
  return _dispatch_data_get_size(data);
}

void dispatch_main(void)
{
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
}

void dispatch_once_f(dispatch_once_t *predicate, void *context, dispatch_function_t function)
{
}

void dispatch_release(dispatch_object_t object)
{
}

void dispatch_resume(dispatch_object_t object)
{
}

void dispatch_retain(dispatch_object_t object)
{
}

void dispatch_set_context(dispatch_object_t object, void *context)
{
}

void dispatch_set_finalizer_f(dispatch_object_t object, dispatch_function_t finalizer)
{
}

void dispatch_source_cancel(dispatch_source_t source)
{
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return _dispatch_source_create(type, handle, mask, queue);
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_cancel_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
}

void dispatch_source_set_event_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return _dispatch_time(when, delta);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return _dlsym(__handle, __symbol);
}

uint64_t dyld_program_sdk_at_least()
{
  return _dyld_program_sdk_at_least();
}

void exit(int a1)
{
}

int fclose(FILE *a1)
{
  return _fclose(a1);
}

int fcntl(int a1, int a2, ...)
{
  return _fcntl(a1, a2);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return _fopen(__filename, __mode);
}

size_t fread(void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return _fread(__ptr, __size, __nitems, __stream);
}

void free(void *a1)
{
}

int fseek(FILE *a1, uint64_t a2, int a3)
{
  return _fseek(a1, a2, a3);
}

uint64_t ftell(FILE *a1)
{
  return _ftell(a1);
}

char *__cdecl getenv(const char *a1)
{
  return _getenv(a1);
}

int getrlimit(int a1, rlimit *a2)
{
  return _getrlimit(a1, a2);
}

int getsockname(int a1, sockaddr *a2, socklen_t *a3)
{
  return _getsockname(a1, a2, a3);
}

int getsockopt(int a1, int a2, int a3, void *a4, socklen_t *a5)
{
  return _getsockopt(a1, a2, a3, a4, a5);
}

int gettimeofday(timeval *a1, void *a2)
{
  return _gettimeofday(a1, a2);
}

unsigned int if_nametoindex(const char *a1)
{
  return _if_nametoindex(a1);
}

const char *__cdecl inet_ntop(int a1, const void *a2, char *a3, socklen_t a4)
{
  return _inet_ntop(a1, a2, a3, a4);
}

int inet_pton(int a1, const char *a2, void *a3)
{
  return _inet_pton(a1, a2, a3);
}

int launch_activate_socket(const char *name, int **fds, size_t *cnt)
{
  return _launch_activate_socket(name, fds, cnt);
}

tm *__cdecl localtime_r(const time_t *a1, tm *a2)
{
  return _localtime_r(a1, a2);
}

void *__cdecl malloc(size_t __size)
{
  return _malloc(__size);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_calloc(count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return _malloc_type_malloc(size, type_id);
}

uint64_t mdns_address_create_ipv6()
{
  return _mdns_address_create_ipv6();
}

uint64_t mdns_dns_push_service_definition_add_domain()
{
  return _mdns_dns_push_service_definition_add_domain();
}

uint64_t mdns_dns_push_service_definition_append_server_address()
{
  return _mdns_dns_push_service_definition_append_server_address();
}

uint64_t mdns_dns_push_service_definition_create()
{
  return _mdns_dns_push_service_definition_create();
}

uint64_t mdns_dns_service_definition_add_domain()
{
  return _mdns_dns_service_definition_add_domain();
}

uint64_t mdns_dns_service_definition_append_server_address()
{
  return _mdns_dns_service_definition_append_server_address();
}

uint64_t mdns_dns_service_definition_create()
{
  return _mdns_dns_service_definition_create();
}

uint64_t mdns_domain_name_create()
{
  return _mdns_domain_name_create();
}

uint64_t mdns_domain_name_get_presentation()
{
  return _mdns_domain_name_get_presentation();
}

uint64_t mdns_release()
{
  return _mdns_release();
}

void *__cdecl memchr(void *__s, int __c, size_t __n)
{
  return _memchr(__s, __c, __n);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return _memcmp(__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return _memcpy(__dst, __src, __n);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return _memset(__b, __c, __len);
}

uint64_t mrc_dns_service_registration_activate()
{
  return _mrc_dns_service_registration_activate();
}

uint64_t mrc_dns_service_registration_create()
{
  return _mrc_dns_service_registration_create();
}

uint64_t mrc_dns_service_registration_create_push()
{
  return _mrc_dns_service_registration_create_push();
}

uint64_t mrc_dns_service_registration_invalidate()
{
  return _mrc_dns_service_registration_invalidate();
}

uint64_t mrc_dns_service_registration_set_event_handler()
{
  return _mrc_dns_service_registration_set_event_handler();
}

uint64_t mrc_dns_service_registration_set_queue()
{
  return _mrc_dns_service_registration_set_queue();
}

uint64_t mrc_dns_service_registration_set_reports_connection_errors()
{
  return _mrc_dns_service_registration_set_reports_connection_errors();
}

uint64_t mrc_release()
{
  return _mrc_release();
}

uint64_t ne_tracker_check_is_hostname_blocked()
{
  return _ne_tracker_check_is_hostname_blocked();
}

uint64_t ne_tracker_copy_current_stacktrace()
{
  return _ne_tracker_copy_current_stacktrace();
}

uint64_t ne_tracker_create_xcode_issue()
{
  return _ne_tracker_create_xcode_issue();
}

uint64_t ne_tracker_should_save_stacktrace()
{
  return _ne_tracker_should_save_stacktrace();
}

uint32_t notify_cancel(int token)
{
  return _notify_cancel(token);
}

uint32_t notify_post(const char *name)
{
  return _notify_post(name);
}

uint32_t notify_register_check(const char *name, int *out_token)
{
  return _notify_register_check(name, out_token);
}

void nw_connection_cancel(nw_connection_t connection)
{
}

uint64_t nw_connection_copy_connected_local_endpoint()
{
  return _nw_connection_copy_connected_local_endpoint();
}

uint64_t nw_connection_copy_connected_path()
{
  return _nw_connection_copy_connected_path();
}

char *__cdecl nw_connection_copy_description(nw_connection_t connection)
{
  return _nw_connection_copy_description(connection);
}

nw_endpoint_t nw_connection_copy_endpoint(nw_connection_t connection)
{
  return _nw_connection_copy_endpoint(connection);
}

nw_connection_t nw_connection_create(nw_endpoint_t endpoint, nw_parameters_t parameters)
{
  return _nw_connection_create(endpoint, parameters);
}

void nw_connection_receive(nw_connection_t connection, uint32_t minimum_incomplete_length, uint32_t maximum_length, nw_connection_receive_completion_t completion)
{
}

void nw_connection_receive_message(nw_connection_t connection, nw_connection_receive_completion_t completion)
{
}

void nw_connection_send(nw_connection_t connection, dispatch_data_t content, nw_content_context_t context, BOOL is_complete, nw_connection_send_completion_t completion)
{
}

void nw_connection_set_queue(nw_connection_t connection, dispatch_queue_t queue)
{
}

void nw_connection_set_state_changed_handler(nw_connection_t connection, nw_connection_state_changed_handler_t handler)
{
}

void nw_connection_start(nw_connection_t connection)
{
}

char *__cdecl nw_endpoint_copy_address_string(nw_endpoint_t endpoint)
{
  return _nw_endpoint_copy_address_string(endpoint);
}

char *__cdecl nw_endpoint_copy_port_string(nw_endpoint_t endpoint)
{
  return _nw_endpoint_copy_port_string(endpoint);
}

nw_endpoint_t nw_endpoint_create_host(const char *hostname, const char *port)
{
  return _nw_endpoint_create_host(hostname, port);
}

nw_endpoint_type_t nw_endpoint_get_type(nw_endpoint_t endpoint)
{
  return _nw_endpoint_get_type(endpoint);
}

CFErrorRef nw_error_copy_cf_error(nw_error_t error)
{
  return _nw_error_copy_cf_error(error);
}

int nw_error_get_error_code(nw_error_t error)
{
  return _nw_error_get_error_code(error);
}

uint32_t nw_interface_get_index(nw_interface_t interface)
{
  return _nw_interface_get_index(interface);
}

const char *__cdecl nw_interface_get_name(nw_interface_t interface)
{
  return _nw_interface_get_name(interface);
}

void nw_listener_cancel(nw_listener_t listener)
{
}

nw_listener_t nw_listener_create(nw_parameters_t parameters)
{
  return _nw_listener_create(parameters);
}

uint64_t nw_listener_create_with_launchd_key()
{
  return _nw_listener_create_with_launchd_key();
}

void nw_listener_set_new_connection_handler(nw_listener_t listener, nw_listener_new_connection_handler_t handler)
{
}

void nw_listener_set_queue(nw_listener_t listener, dispatch_queue_t queue)
{
}

void nw_listener_set_state_changed_handler(nw_listener_t listener, nw_listener_state_changed_handler_t handler)
{
}

void nw_listener_start(nw_listener_t listener)
{
}

nw_protocol_stack_t nw_parameters_copy_default_protocol_stack(nw_parameters_t parameters)
{
  return _nw_parameters_copy_default_protocol_stack(parameters);
}

nw_parameters_t nw_parameters_create_secure_tcp(nw_parameters_configure_protocol_block_t configure_tls, nw_parameters_configure_protocol_block_t configure_tcp)
{
  return _nw_parameters_create_secure_tcp(configure_tls, configure_tcp);
}

nw_parameters_t nw_parameters_create_secure_udp(nw_parameters_configure_protocol_block_t configure_dtls, nw_parameters_configure_protocol_block_t configure_udp)
{
  return _nw_parameters_create_secure_udp(configure_dtls, configure_udp);
}

void nw_parameters_prohibit_interface_type(nw_parameters_t parameters, nw_interface_type_t interface_type)
{
}

void nw_parameters_set_local_endpoint(nw_parameters_t parameters, nw_endpoint_t local_endpoint)
{
}

void nw_parameters_set_reuse_local_address(nw_parameters_t parameters, BOOL reuse_local_address)
{
}

uint64_t nw_path_copy_interface()
{
  return _nw_path_copy_interface();
}

void nw_release(void *obj)
{
}

void *__cdecl nw_retain(void *obj)
{
  return _nw_retain(obj);
}

void nw_tcp_options_set_maximum_segment_size(nw_protocol_options_t options, uint32_t maximum_segment_size)
{
}

sec_protocol_options_t nw_tls_copy_sec_protocol_options(nw_protocol_options_t options)
{
  return _nw_tls_copy_sec_protocol_options(options);
}

DIR *__cdecl opendir(const char *a1)
{
  return _opendir(a1);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return _os_log_create(subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return _os_log_type_enabled(oslog, type);
}

void os_release(void *object)
{
}

uint64_t os_transaction_create()
{
  return _os_transaction_create();
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
}

int putenv(char *a1)
{
  return _putenv(a1);
}

dirent *__cdecl readdir(DIR *a1)
{
  return _readdir(a1);
}

ssize_t recv(int a1, void *a2, size_t a3, int a4)
{
  return _recv(a1, a2, a3, a4);
}

ssize_t recvmsg(int a1, msghdr *a2, int a3)
{
  return _recvmsg(a1, a2, a3);
}

void rewind(FILE *a1)
{
}

sec_identity_t sec_identity_create(SecIdentityRef identity)
{
  return _sec_identity_create(identity);
}

void sec_protocol_options_append_tls_ciphersuite_group(sec_protocol_options_t options, tls_ciphersuite_group_t group)
{
}

void sec_protocol_options_set_local_identity(sec_protocol_options_t options, sec_identity_t identity)
{
}

void sec_protocol_options_set_min_tls_protocol_version(sec_protocol_options_t options, tls_protocol_version_t version)
{
}

void sec_protocol_options_set_tls_server_name(sec_protocol_options_t options, const char *server_name)
{
}

void sec_protocol_options_set_verify_block(sec_protocol_options_t options, sec_protocol_verify_t verify_block, dispatch_queue_t verify_block_queue)
{
}

void sec_release(void *obj)
{
}

int select(int a1, fd_set *a2, fd_set *a3, fd_set *a4, timeval *a5)
{
  return _select(a1, a2, a3, a4, a5);
}

ssize_t send(int a1, const void *a2, size_t a3, int a4)
{
  return _send(a1, a2, a3, a4);
}

ssize_t sendmsg(int a1, const msghdr *a2, int a3)
{
  return _sendmsg(a1, a2, a3);
}

int setrlimit(int a1, const rlimit *a2)
{
  return _setrlimit(a1, a2);
}

int setsockopt(int a1, int a2, int a3, const void *a4, socklen_t a5)
{
  return _setsockopt(a1, a2, a3, a4, a5);
}

int shutdown(int a1, int a2)
{
  return _shutdown(a1, a2);
}

unsigned int sleep(unsigned int a1)
{
  return _sleep(a1);
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return _snprintf(__str, __size, __format);
}

int socket(int a1, int a2, int a3)
{
  return _socket(a1, a2, a3);
}

int socketpair(int a1, int a2, int a3, int *a4)
{
  return _socketpair(a1, a2, a3, a4);
}

int sscanf(const char *a1, const char *a2, ...)
{
  return _sscanf(a1, a2);
}

int strcasecmp(const char *a1, const char *a2)
{
  return _strcasecmp(a1, a2);
}

char *__cdecl strchr(char *__s, int __c)
{
  return _strchr(__s, __c);
}

int strcmp(const char *__s1, const char *__s2)
{
  return _strcmp(__s1, __s2);
}

char *__cdecl strdup(const char *__s1)
{
  return _strdup(__s1);
}

char *__cdecl strerror(int __errnum)
{
  return _strerror(__errnum);
}

size_t strftime(char *a1, size_t a2, const char *a3, const tm *a4)
{
  return _strftime(a1, a2, a3, a4);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return _strlcpy(__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return _strlen(__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return _strncmp(__s1, __s2, __n);
}

size_t strnlen(const char *__s1, size_t __n)
{
  return _strnlen(__s1, __n);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return _strrchr(__s, __c);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return _strtol(__str, __endptr, __base);
}

unint64_t strtoul(const char *__str, char **__endptr, int __base)
{
  return _strtoul(__str, __endptr, __base);
}

void syslog(int a1, const char *a2, ...)
{
}

time_t time(time_t *a1)
{
  return _time(a1);
}

void xpc_array_append_value(xpc_object_t xarray, xpc_object_t value)
{
}

BOOL xpc_array_apply(xpc_object_t xarray, xpc_array_applier_t applier)
{
  return _xpc_array_apply(xarray, applier);
}

xpc_object_t xpc_array_create(xpc_object_t *objects, size_t count)
{
  return _xpc_array_create(objects, count);
}

xpc_object_t xpc_array_create_empty(void)
{
  return _xpc_array_create_empty();
}

size_t xpc_array_get_count(xpc_object_t xarray)
{
  return _xpc_array_get_count(xarray);
}

const char *__cdecl xpc_array_get_string(xpc_object_t xarray, size_t index)
{
  return _xpc_array_get_string(xarray, index);
}

uint64_t xpc_array_get_uint64(xpc_object_t xarray, size_t index)
{
  return _xpc_array_get_uint64(xarray, index);
}

xpc_object_t xpc_array_get_value(xpc_object_t xarray, size_t index)
{
  return _xpc_array_get_value(xarray, index);
}

void xpc_array_set_string(xpc_object_t xarray, size_t index, const char *string)
{
}

BOOL xpc_BOOL_get_value(xpc_object_t xBOOL)
{
  return _xpc_BOOL_get_value(xBOOL);
}

void xpc_connection_cancel(xpc_connection_t connection)
{
}

uint64_t xpc_connection_copy_entitlement_value()
{
  return _xpc_connection_copy_entitlement_value();
}

xpc_connection_t xpc_connection_create_mach_service(const char *name, dispatch_queue_t targetq, uint64_t flags)
{
  return _xpc_connection_create_mach_service(name, targetq, flags);
}

uid_t xpc_connection_get_euid(xpc_connection_t connection)
{
  return _xpc_connection_get_euid(connection);
}

pid_t xpc_connection_get_pid(xpc_connection_t connection)
{
  return _xpc_connection_get_pid(connection);
}

void xpc_connection_resume(xpc_connection_t connection)
{
}

void xpc_connection_send_message(xpc_connection_t connection, xpc_object_t message)
{
}

void xpc_connection_send_message_with_reply(xpc_connection_t connection, xpc_object_t message, dispatch_queue_t replyq, xpc_handler_t handler)
{
}

void xpc_connection_set_context(xpc_connection_t connection, void *context)
{
}

void xpc_connection_set_event_handler(xpc_connection_t connection, xpc_handler_t handler)
{
}

void xpc_connection_set_finalizer_f(xpc_connection_t connection, xpc_finalizer_t finalizer)
{
}

void xpc_connection_set_target_queue(xpc_connection_t connection, dispatch_queue_t targetq)
{
}

char *__cdecl xpc_copy_description(xpc_object_t object)
{
  return _xpc_copy_description(object);
}

const void *__cdecl xpc_data_get_bytes_ptr(xpc_object_t xdata)
{
  return _xpc_data_get_bytes_ptr(xdata);
}

size_t xpc_data_get_length(xpc_object_t xdata)
{
  return _xpc_data_get_length(xdata);
}

BOOL xpc_dictionary_apply(xpc_object_t xdict, xpc_dictionary_applier_t applier)
{
  return _xpc_dictionary_apply(xdict, applier);
}

xpc_object_t xpc_dictionary_create(const char *const *keys, xpc_object_t *values, size_t count)
{
  return _xpc_dictionary_create(keys, values, count);
}

xpc_object_t xpc_dictionary_create_reply(xpc_object_t original)
{
  return _xpc_dictionary_create_reply(original);
}

xpc_object_t xpc_dictionary_get_array(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_array(xdict, key);
}

BOOL xpc_dictionary_get_BOOL(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_BOOL(xdict, key);
}

size_t xpc_dictionary_get_count(xpc_object_t xdict)
{
  return _xpc_dictionary_get_count(xdict);
}

const void *__cdecl xpc_dictionary_get_data(xpc_object_t xdict, const char *key, size_t *length)
{
  return _xpc_dictionary_get_data(xdict, key, length);
}

xpc_object_t xpc_dictionary_get_dictionary(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_dictionary(xdict, key);
}

int64_t xpc_dictionary_get_int64(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_int64(xdict, key);
}

const char *__cdecl xpc_dictionary_get_string(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_string(xdict, key);
}

uint64_t xpc_dictionary_get_uint64(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_uint64(xdict, key);
}

xpc_object_t xpc_dictionary_get_value(xpc_object_t xdict, const char *key)
{
  return _xpc_dictionary_get_value(xdict, key);
}

void xpc_dictionary_set_BOOL(xpc_object_t xdict, const char *key, BOOL value)
{
}

void xpc_dictionary_set_data(xpc_object_t xdict, const char *key, const void *bytes, size_t length)
{
}

void xpc_dictionary_set_int64(xpc_object_t xdict, const char *key, int64_t value)
{
}

void xpc_dictionary_set_string(xpc_object_t xdict, const char *key, const char *string)
{
}

void xpc_dictionary_set_uint64(xpc_object_t xdict, const char *key, uint64_t value)
{
}

void xpc_dictionary_set_value(xpc_object_t xdict, const char *key, xpc_object_t value)
{
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return _xpc_get_type(object);
}

int64_t xpc_int64_get_value(xpc_object_t xint)
{
  return _xpc_int64_get_value(xint);
}

void xpc_release(xpc_object_t object)
{
}

xpc_object_t xpc_retain(xpc_object_t object)
{
  return _xpc_retain(object);
}

xpc_object_t xpc_string_create(const char *string)
{
  return _xpc_string_create(string);
}

size_t xpc_string_get_length(xpc_object_t xstring)
{
  return _xpc_string_get_length(xstring);
}

const char *__cdecl xpc_string_get_string_ptr(xpc_object_t xstring)
{
  return _xpc_string_get_string_ptr(xstring);
}

uint64_t xpc_uint64_get_value(xpc_object_t xuint)
{
  return _xpc_uint64_get_value(xuint);
}